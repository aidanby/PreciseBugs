{"buggy_code": ["package com.appsmith.external.helpers.restApiUtils.helpers;\n\nimport com.appsmith.external.exceptions.pluginExceptions.AppsmithPluginError;\nimport com.appsmith.external.exceptions.pluginExceptions.AppsmithPluginException;\nimport com.appsmith.external.helpers.SSLHelper;\nimport com.appsmith.external.helpers.restApiUtils.connections.APIConnection;\nimport com.appsmith.external.helpers.restApiUtils.constants.ResponseDataType;\nimport com.appsmith.external.models.ActionConfiguration;\nimport com.appsmith.external.models.ActionExecutionRequest;\nimport com.appsmith.external.models.ActionExecutionResult;\nimport com.appsmith.external.models.DatasourceConfiguration;\nimport com.appsmith.external.models.Property;\nimport com.appsmith.util.WebClientUtils;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.security.Keys;\nimport lombok.NoArgsConstructor;\nimport org.bson.internal.Base64;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.client.reactive.ClientHttpRequest;\nimport org.springframework.web.reactive.function.BodyInserter;\nimport org.springframework.web.reactive.function.client.ClientResponse;\nimport org.springframework.web.reactive.function.client.ExchangeStrategies;\nimport org.springframework.web.reactive.function.client.WebClient;\nimport reactor.core.Exceptions;\nimport reactor.core.publisher.Mono;\nimport reactor.netty.http.client.HttpClient;\nimport reactor.netty.resources.ConnectionProvider;\n\nimport javax.crypto.SecretKey;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.UnknownHostException;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Set;\n\nimport static com.appsmith.external.helpers.restApiUtils.helpers.URIUtils.DISALLOWED_HOSTS;\nimport static org.apache.commons.lang3.StringUtils.isNotEmpty;\n\n@NoArgsConstructor\npublic class TriggerUtils {\n\n    public static String SIGNATURE_HEADER_NAME = \"X-APPSMITH-SIGNATURE\";\n    public static String RESPONSE_DATA_TYPE = \"X-APPSMITH-DATATYPE\";\n    public static int MAX_REDIRECTS = 5;\n    public static Set BINARY_DATA_TYPES = Set.of(\"application/zip\", \"application/octet-stream\", \"application/pdf\",\n            \"application/pkcs8\", \"application/x-binary\");\n\n    public static HeaderUtils headerUtils = new HeaderUtils();\n\n    public Mono<ActionExecutionResult> triggerApiCall(WebClient client, HttpMethod httpMethod, URI uri,\n                                                             Object requestBody,\n                                                             ActionExecutionRequest actionExecutionRequest,\n                                                             ObjectMapper objectMapper, Set<String> hintMessages,\n                                                             ActionExecutionResult errorResult,\n                                                             RequestCaptureFilter requestCaptureFilter) {\n        return httpCall(client, httpMethod, uri, requestBody, 0)\n                .flatMap(clientResponse -> clientResponse.toEntity(byte[].class))\n                .map(stringResponseEntity -> {\n                    HttpHeaders headers = stringResponseEntity.getHeaders();\n                        /*\n                            Find the media type of the response to parse the body as required. In case the content-type\n                            header is not present in the response then set it to our default i.e. \"text/plain\" although\n                            the RFC 7231 standard suggests assuming \"application/octet-stream\" content-type in case\n                            it's not present in response header.\n                         */\n                    MediaType contentType = headers.getContentType();\n                    if (contentType == null) {\n                        contentType = MediaType.TEXT_PLAIN;\n                    }\n                    byte[] body = stringResponseEntity.getBody();\n                    HttpStatus statusCode = stringResponseEntity.getStatusCode();\n\n                    ActionExecutionResult result = new ActionExecutionResult();\n\n                    // Set the request fields\n                    result.setRequest(requestCaptureFilter.populateRequestFields(actionExecutionRequest));\n\n                    result.setStatusCode(statusCode.toString());\n                    result.setIsExecutionSuccess(statusCode.is2xxSuccessful());\n\n                    // Convert the headers into json tree to store in the results\n                    String headerInJsonString;\n                    try {\n                        headerInJsonString = objectMapper.writeValueAsString(headers);\n                    } catch (JsonProcessingException e) {\n                        throw Exceptions.propagate(new AppsmithPluginException(AppsmithPluginError.PLUGIN_ERROR, e));\n                    }\n\n                    // Set headers in the result now\n                    try {\n                        result.setHeaders(objectMapper.readTree(headerInJsonString));\n                    } catch (IOException e) {\n                        throw Exceptions.propagate(\n                                new AppsmithPluginException(\n                                        AppsmithPluginError.PLUGIN_JSON_PARSE_ERROR,\n                                        headerInJsonString,\n                                        e.getMessage()\n                                )\n                        );\n                    }\n\n                    if (body != null) {\n\n                        ResponseDataType responseDataType = ResponseDataType.UNDEFINED;\n\n                        /**TODO\n                         * Handle XML response. Currently we only handle JSON & Image responses. The other kind of responses\n                         * are kept as is and returned as a string.\n                         */\n                        if (contentType.includes(MediaType.APPLICATION_JSON)) {\n                            try {\n                                String jsonBody = new String(body, StandardCharsets.UTF_8);\n                                result.setBody(objectMapper.readTree(jsonBody));\n                                responseDataType = ResponseDataType.JSON;\n                            } catch (IOException e) {\n                                System.out.println(\"Unable to parse response JSON. Setting response body as string.\");\n                                String bodyString = new String(body, StandardCharsets.UTF_8);\n                                result.setBody(bodyString.trim());\n\n                                // Warn user that the API response is not a valid JSON.\n                                hintMessages.add(\"The response returned by this API is not a valid JSON. Please \" +\n                                        \"be careful when using the API response anywhere a valid JSON is required\" +\n                                        \". You may resolve this issue either by modifying the 'Content-Type' \" +\n                                        \"Header to indicate a non-JSON response or by modifying the API response \" +\n                                        \"to return a valid JSON.\");\n                            }\n                        } else if (MediaType.IMAGE_GIF.equals(contentType) ||\n                                MediaType.IMAGE_JPEG.equals(contentType) ||\n                                MediaType.IMAGE_PNG.equals(contentType)) {\n                            String encode = Base64.encode(body);\n                            result.setBody(encode);\n                            responseDataType = ResponseDataType.IMAGE;\n\n                        } else if (BINARY_DATA_TYPES.contains(contentType.toString())) {\n                            String encode = Base64.encode(body);\n                            result.setBody(encode);\n                            responseDataType = ResponseDataType.BINARY;\n                        } else {\n                            // If the body is not of JSON type, just set it as is.\n                            String bodyString = new String(body, StandardCharsets.UTF_8);\n                            result.setBody(bodyString.trim());\n                            responseDataType = ResponseDataType.TEXT;\n                        }\n\n                        // Now add a new header which specifies the data type of the response as per Appsmith\n                        JsonNode headersJsonNode = result.getHeaders();\n                        ObjectNode headersObjectNode = (ObjectNode) headersJsonNode;\n                        headersObjectNode.putArray(RESPONSE_DATA_TYPE)\n                                .add(String.valueOf(responseDataType));\n                        result.setHeaders(headersObjectNode);\n\n                    }\n\n                    result.setMessages(hintMessages);\n                    return result;\n                })\n                .onErrorResume(error -> {\n                    errorResult.setRequest(requestCaptureFilter.populateRequestFields(actionExecutionRequest));\n                    errorResult.setIsExecutionSuccess(false);\n                    errorResult.setErrorInfo(error);\n                    return Mono.just(errorResult);\n                });\n\n    }\n\n    protected Mono<ClientResponse> httpCall(WebClient webClient, HttpMethod httpMethod, URI uri, Object requestBody,\n                                          int iteration) {\n        if (iteration == MAX_REDIRECTS) {\n            return Mono.error(new AppsmithPluginException(\n                    AppsmithPluginError.PLUGIN_ERROR,\n                    \"Exceeded the HTTP redirect limits of \" + MAX_REDIRECTS\n            ));\n        }\n\n        assert requestBody instanceof BodyInserter<?, ?>;\n        BodyInserter<?, ?> finalRequestBody = (BodyInserter<?, ?>) requestBody;\n\n        return webClient\n                .method(httpMethod)\n                .uri(uri)\n                .body((BodyInserter<?, ? super ClientHttpRequest>) finalRequestBody)\n                .exchange()\n                .doOnError(e -> Mono.error(new AppsmithPluginException(AppsmithPluginError.PLUGIN_ERROR, e)))\n                .flatMap(response -> {\n                    if (response.statusCode().is3xxRedirection()) {\n                        String redirectUrl = response.headers().header(\"Location\").get(0);\n                        /**\n                         * TODO\n                         * In case the redirected URL is not absolute (complete), create the new URL using the relative path\n                         * This particular scenario is seen in the URL : https://rickandmortyapi.com/api/character\n                         * It redirects to partial URI : /api/character/\n                         * In this scenario we should convert the partial URI to complete URI\n                         */\n                        URI redirectUri;\n                        try {\n                            redirectUri = new URI(redirectUrl);\n                            if (DISALLOWED_HOSTS.contains(redirectUri.getHost())\n                                    || DISALLOWED_HOSTS.contains(InetAddress.getByName(redirectUri.getHost()).getHostAddress())) {\n                                return Mono.error(new AppsmithPluginException(AppsmithPluginError.PLUGIN_EXECUTE_ARGUMENT_ERROR, \"Host not allowed.\"));\n                            }\n                        } catch (URISyntaxException | UnknownHostException e) {\n                            return Mono.error(new AppsmithPluginException(AppsmithPluginError.PLUGIN_ERROR, e));\n                        }\n\n                        return httpCall(webClient, httpMethod, redirectUri, finalRequestBody, iteration + 1);\n                    }\n                    return Mono.just(response);\n                });\n    }\n\n    public WebClient getWebClient(WebClient.Builder webClientBuilder, APIConnection apiConnection,\n                                         String reqContentType, ObjectMapper objectMapper,\n                                         ExchangeStrategies EXCHANGE_STRATEGIES, RequestCaptureFilter requestCaptureFilter) {\n        // Right before building the webclient object, we populate it with whatever mutation the APIConnection object demands\n        if (apiConnection != null) {\n            webClientBuilder.filter(apiConnection);\n        }\n\n        if (MediaType.MULTIPART_FORM_DATA_VALUE.equals(reqContentType)) {\n            webClientBuilder.filter(new BufferingFilter());\n        }\n\n        webClientBuilder.filter(requestCaptureFilter);\n\n        return webClientBuilder.exchangeStrategies(EXCHANGE_STRATEGIES).build();\n    }\n\n    public WebClient.Builder getWebClientBuilder(ActionConfiguration actionConfiguration,\n                                                        DatasourceConfiguration datasourceConfiguration) {\n        HttpClient httpClient = getHttpClient(datasourceConfiguration);\n        WebClient.Builder webClientBuilder = WebClientUtils.builder(httpClient);\n        addAllHeaders(webClientBuilder, actionConfiguration, datasourceConfiguration);\n        addSecretKey(webClientBuilder, datasourceConfiguration);\n\n        return webClientBuilder;\n    }\n\n    protected void addSecretKey(WebClient.Builder webClientBuilder,\n                                     DatasourceConfiguration datasourceConfiguration) throws AppsmithPluginException {\n        // If users have chosen to share the Appsmith signature in the header, calculate and add that\n        String secretKey;\n        secretKey = headerUtils.getSignatureKey(datasourceConfiguration);\n\n        if (secretKey != null) {\n            final SecretKey key = Keys.hmacShaKeyFor(secretKey.getBytes(StandardCharsets.UTF_8));\n            final Instant now = Instant.now();\n            final String token = Jwts.builder()\n                    .setIssuer(\"Appsmith\")\n                    .setIssuedAt(new Date(now.toEpochMilli()))\n                    .setExpiration(new Date(now.plusSeconds(600).toEpochMilli()))\n                    .signWith(key)\n                    .compact();\n\n            webClientBuilder.defaultHeader(SIGNATURE_HEADER_NAME, token);\n        }\n    }\n\n    protected void addAllHeaders(WebClient.Builder webClientBuilder, ActionConfiguration actionConfiguration,\n                                      DatasourceConfiguration datasourceConfiguration) {\n        /**\n         * First, check if headers are defined in API datasource and add them.\n         */\n        if (datasourceConfiguration.getHeaders() != null) {\n            addHeaders(webClientBuilder, datasourceConfiguration.getHeaders());\n        }\n\n        /**\n         * If headers are defined in API action config, then add them too.\n         * In case there is a conflict with the datasource headers then the header defined in the API action config\n         * will override it.\n         */\n        if (actionConfiguration.getHeaders() != null) {\n            addHeaders(webClientBuilder, actionConfiguration.getHeaders());\n        }\n    }\n\n    protected void addHeaders(WebClient.Builder webClientBuilder, List<Property> headers) {\n        headers.stream()\n                .filter(header -> isNotEmpty(header.getKey()))\n                .forEach(header -> webClientBuilder.defaultHeader(header.getKey(), (String) header.getValue()));\n    }\n\n    protected HttpClient getHttpClient(DatasourceConfiguration datasourceConfiguration) {\n        // Initializing webClient to be used for http call\n        final ConnectionProvider provider = ConnectionProvider\n                .builder(\"rest-api-provider\")\n                .maxIdleTime(Duration.ofSeconds(600))\n                .maxLifeTime(Duration.ofSeconds(600))\n                .build();\n\n        HttpClient httpClient = HttpClient.create(provider)\n                .secure(SSLHelper.sslCheckForHttpClient(datasourceConfiguration))\n                .compress(true);\n\n        return httpClient;\n    }\n}\n", "package com.appsmith.external.helpers.restApiUtils.helpers;\n\nimport com.appsmith.external.models.ActionConfiguration;\nimport com.appsmith.external.models.DatasourceConfiguration;\nimport com.appsmith.external.models.Property;\nimport lombok.AccessLevel;\nimport lombok.NoArgsConstructor;\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.web.util.UriComponentsBuilder;\n\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URLEncoder;\nimport java.net.UnknownHostException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\nimport static org.apache.commons.collections.CollectionUtils.isEmpty;\nimport static org.apache.commons.lang3.StringUtils.isNotEmpty;\n\n@NoArgsConstructor\npublic class URIUtils {\n    public static final Set<String> DISALLOWED_HOSTS = Set.of(\n            \"169.254.169.254\",\n            \"metadata.google.internal\"\n    );\n\n    public URI createUriWithQueryParams(ActionConfiguration actionConfiguration,\n                                        DatasourceConfiguration datasourceConfiguration, String url,\n                                        boolean encodeParamsToggle) throws URISyntaxException {\n        String httpUrl = addHttpToUrlWhenPrefixNotPresent(url);\n\n        ArrayList<Property> allQueryParams = new ArrayList<>();\n        if (!isEmpty(actionConfiguration.getQueryParameters())) {\n            allQueryParams.addAll(actionConfiguration.getQueryParameters());\n        }\n\n        if (!isEmpty(datasourceConfiguration.getQueryParameters())) {\n            allQueryParams.addAll(datasourceConfiguration.getQueryParameters());\n        }\n\n        return addQueryParamsToURI(new URI(httpUrl), allQueryParams, encodeParamsToggle);\n    }\n\n    public URI addQueryParamsToURI(URI uri, List<Property> allQueryParams, boolean encodeParamsToggle) {\n        UriComponentsBuilder uriBuilder = UriComponentsBuilder.newInstance();\n        uriBuilder.uri(uri);\n\n        if (allQueryParams != null) {\n            for (Property queryParam : allQueryParams) {\n                String key = queryParam.getKey();\n                if (isNotEmpty(key)) {\n                    if (encodeParamsToggle == true) {\n                        uriBuilder.queryParam(\n                                URLEncoder.encode(key, StandardCharsets.UTF_8),\n                                URLEncoder.encode((String) queryParam.getValue(), StandardCharsets.UTF_8)\n                        );\n                    } else {\n                        uriBuilder.queryParam(\n                                key,\n                                queryParam.getValue()\n                        );\n                    }\n                }\n            }\n        }\n\n        return uriBuilder.build(true).toUri();\n    }\n\n    protected String addHttpToUrlWhenPrefixNotPresent(String url) {\n        if (url == null || url.toLowerCase().startsWith(\"http\") || url.contains(\"://\")) {\n            return url;\n        }\n        return \"http://\" + url;\n    }\n\n    public boolean isHostDisallowed(URI uri) throws UnknownHostException {\n        String host = uri.getHost();\n        return StringUtils.isEmpty(host) || DISALLOWED_HOSTS.contains(host)\n                || DISALLOWED_HOSTS.contains(InetAddress.getByName(host).getHostAddress());\n    }\n}\n", "package com.appsmith.util;\n\nimport org.springframework.http.client.reactive.ReactorClientHttpConnector;\nimport org.springframework.web.reactive.function.client.WebClient;\nimport reactor.netty.http.client.HttpClient;\n\npublic class WebClientUtils {\n\n    private WebClientUtils() {\n    }\n\n    public static WebClient create() {\n        return builder()\n                .build();\n    }\n\n    public static WebClient create(String baseUrl) {\n        return builder()\n                .baseUrl(baseUrl)\n                .build();\n    }\n\n    private static boolean shouldUseSystemProxy() {\n        return \"true\".equals(System.getProperty(\"java.net.useSystemProxies\"))\n                && (!System.getProperty(\"http.proxyHost\", \"\").isEmpty() || !System.getProperty(\"https.proxyHost\", \"\").isEmpty());\n    }\n\n    public static WebClient.Builder builder() {\n        return builder(HttpClient.create());\n    }\n\n    public static WebClient.Builder builder(HttpClient httpClient) {\n        return WebClient.builder()\n                .clientConnector(new ReactorClientHttpConnector(applyProxyIfConfigured(httpClient)));\n    }\n\n    private static HttpClient applyProxyIfConfigured(HttpClient httpClient) {\n        if (shouldUseSystemProxy()) {\n            httpClient = httpClient.proxyWithSystemProperties();\n        }\n\n        return httpClient;\n    }\n\n}\n", "package com.external.plugins;\n\nimport com.appsmith.external.dtos.ExecuteActionDTO;\nimport com.appsmith.external.exceptions.pluginExceptions.AppsmithPluginError;\nimport com.appsmith.external.exceptions.pluginExceptions.AppsmithPluginException;\nimport com.appsmith.external.helpers.DataTypeStringUtils;\nimport com.appsmith.external.helpers.MustacheHelper;\nimport com.appsmith.external.helpers.restApiUtils.connections.APIConnection;\nimport com.appsmith.external.helpers.restApiUtils.helpers.RequestCaptureFilter;\nimport com.appsmith.external.models.ActionConfiguration;\nimport com.appsmith.external.models.ActionExecutionRequest;\nimport com.appsmith.external.models.ActionExecutionResult;\nimport com.appsmith.external.models.ApiContentType;\nimport com.appsmith.external.models.DatasourceConfiguration;\nimport com.appsmith.external.models.PaginationType;\nimport com.appsmith.external.models.Property;\nimport com.appsmith.external.plugins.BasePlugin;\nimport com.appsmith.external.plugins.BaseRestApiPluginExecutor;\nimport com.appsmith.external.services.SharedConfig;\nimport com.external.utils.GraphQLHintMessageUtils;\nimport lombok.extern.slf4j.Slf4j;\nimport org.pf4j.Extension;\nimport org.pf4j.PluginWrapper;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.web.reactive.function.client.WebClient;\nimport reactor.core.publisher.Mono;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static com.appsmith.external.helpers.PluginUtils.getValueSafelyFromPropertyList;\nimport static com.appsmith.external.helpers.PluginUtils.setValueSafelyInPropertyList;\nimport static com.external.utils.GraphQLBodyUtils.PAGINATION_DATA_INDEX;\nimport static com.external.utils.GraphQLDataTypeUtils.smartlyReplaceGraphQLQueryBodyPlaceholderWithValue;\nimport static com.external.utils.GraphQLPaginationUtils.updateVariablesWithPaginationValues;\nimport static com.external.utils.GraphQLBodyUtils.QUERY_VARIABLES_INDEX;\nimport static com.external.utils.GraphQLBodyUtils.convertToGraphQLPOSTBodyFormat;\nimport static com.external.utils.GraphQLBodyUtils.getGraphQLQueryParamsForBodyAndVariables;\nimport static com.external.utils.GraphQLBodyUtils.validateBodyAndVariablesSyntax;\nimport static java.lang.Boolean.TRUE;\nimport static org.apache.commons.lang3.StringUtils.isBlank;\n\npublic class GraphQLPlugin extends BasePlugin {\n\n    public GraphQLPlugin(PluginWrapper wrapper) {\n        super(wrapper);\n    }\n\n    @Slf4j\n    @Extension\n    public static class GraphQLPluginExecutor extends BaseRestApiPluginExecutor {\n\n        public GraphQLPluginExecutor(SharedConfig sharedConfig) {\n            super(sharedConfig);\n\n            GraphQLHintMessageUtils hintMessageUtils = new GraphQLHintMessageUtils();\n            super.setHintMessageUtils(hintMessageUtils);\n        }\n\n        /**\n         * Instead of using the default executeParametrized provided by pluginExecutor, this implementation affords an opportunity\n         * also update the datasource and action configuration for pagination and some minor cleanup of the configuration before execution\n         *\n         * @param connection              : This is the connection that is established to the data source. This connection is according\n         *                                to the parameters in Datasource Configuration\n         * @param executeActionDTO        : This is the data structure sent by the client during execute. This contains the params\n         *                                which would be used for substitution\n         * @param datasourceConfiguration : These are the configurations which have been used to create a Datasource from a Plugin\n         * @param actionConfiguration     : These are the configurations which have been used to create an Action from a Datasource.\n         * @return\n         */\n        @Override\n        public Mono<ActionExecutionResult> executeParameterized(APIConnection connection,\n                                                                ExecuteActionDTO executeActionDTO,\n                                                                DatasourceConfiguration datasourceConfiguration,\n                                                                ActionConfiguration actionConfiguration) {\n\n            final List<Property> properties = actionConfiguration.getPluginSpecifiedTemplates();\n            List<Map.Entry<String, String>> parameters = new ArrayList<>();\n\n            String variables = getValueSafelyFromPropertyList(properties, QUERY_VARIABLES_INDEX, String.class);\n            Boolean smartSubstitution = this.smartSubstitutionUtils.isSmartSubstitutionEnabled(properties);\n            if (TRUE.equals(smartSubstitution)) {\n                /* Apply smart JSON substitution logic to mustache binding values in query variables */\n                if (!isBlank(variables)) {\n                    List<String> mustacheKeysInOrder = MustacheHelper.extractMustacheKeysInOrder(variables);\n                    // Replace all the bindings with a ? as expected in a prepared statement.\n                    String updatedVariables = MustacheHelper.replaceMustacheWithPlaceholder(variables, mustacheKeysInOrder);\n\n                    try {\n                        updatedVariables = (String) smartSubstitutionOfBindings(updatedVariables,\n                                mustacheKeysInOrder,\n                                executeActionDTO.getParams(),\n                                parameters,\n                                false);\n                        setValueSafelyInPropertyList(properties, QUERY_VARIABLES_INDEX, updatedVariables);\n                    } catch (AppsmithPluginException e) {\n                        ActionExecutionResult errorResult = new ActionExecutionResult();\n                        errorResult.setIsExecutionSuccess(false);\n                        errorResult.setErrorInfo(e);\n                        errorResult.setStatusCode(AppsmithPluginError.PLUGIN_ERROR.getAppErrorCode().toString());\n                        return Mono.just(errorResult);\n                    }\n                }\n\n                /* Apply smart substitution logic to query body */\n                String query = actionConfiguration.getBody();\n                if (!isBlank(query)) {\n                    List<String> mustacheKeysInOrder = MustacheHelper.extractMustacheKeysInOrder(query);\n                    // Replace all the bindings with a ? as expected in a prepared statement.\n                    String updatedQuery = MustacheHelper.replaceMustacheWithPlaceholder(query, mustacheKeysInOrder);\n\n                    try {\n                        updatedQuery = (String) smartSubstitutionOfBindings(updatedQuery,\n                                mustacheKeysInOrder,\n                                executeActionDTO.getParams(),\n                                parameters,\n                                true);\n                        actionConfiguration.setBody(updatedQuery);\n                    } catch (AppsmithPluginException e) {\n                        ActionExecutionResult errorResult = new ActionExecutionResult();\n                        errorResult.setIsExecutionSuccess(false);\n                        errorResult.setErrorInfo(e);\n                        errorResult.setStatusCode(AppsmithPluginError.PLUGIN_ERROR.getAppErrorCode().toString());\n                        return Mono.just(errorResult);\n                    }\n                }\n            }\n\n            prepareConfigurationsForExecution(executeActionDTO, actionConfiguration, datasourceConfiguration);\n\n            if (isBlank(variables)) {\n                setValueSafelyInPropertyList(properties, QUERY_VARIABLES_INDEX, \"{}\");\n            }\n\n            /* Check if the query body and query variables have the correct GraphQL syntax. */\n            try {\n                validateBodyAndVariablesSyntax(actionConfiguration);\n            } catch (AppsmithPluginException e) {\n                return Mono.error(e);\n            }\n\n            if (actionConfiguration.getPaginationType() != null && !PaginationType.NONE.equals(actionConfiguration.getPaginationType())) {\n                updateVariablesWithPaginationValues(actionConfiguration, executeActionDTO);\n            }\n\n            // Filter out any empty headers\n            headerUtils.removeEmptyHeaders(actionConfiguration);\n\n            return this.executeCommon(connection, datasourceConfiguration, actionConfiguration, parameters);\n        }\n\n        public Mono<ActionExecutionResult> executeCommon(APIConnection apiConnection,\n                                                         DatasourceConfiguration datasourceConfiguration,\n                                                         ActionConfiguration actionConfiguration,\n                                                         List<Map.Entry<String, String>> insertedParams) {\n\n            // Initializing object for error condition\n            ActionExecutionResult errorResult = new ActionExecutionResult();\n            initUtils.initializeResponseWithError(errorResult);\n\n            // Initializing request URL\n            String url = initUtils.initializeRequestUrl(actionConfiguration, datasourceConfiguration);\n\n            Boolean encodeParamsToggle = headerUtils.isEncodeParamsToggleEnabled(actionConfiguration);\n\n            URI uri;\n            try {\n                uri = uriUtils.createUriWithQueryParams(actionConfiguration, datasourceConfiguration, url,\n                        encodeParamsToggle);\n            } catch (URISyntaxException e) {\n                ActionExecutionRequest actionExecutionRequest =\n                        RequestCaptureFilter.populateRequestFields(actionConfiguration, null, insertedParams, objectMapper);\n                actionExecutionRequest.setUrl(url);\n                errorResult.setBody(AppsmithPluginError.PLUGIN_EXECUTE_ARGUMENT_ERROR.getMessage(e));\n                errorResult.setRequest(actionExecutionRequest);\n                return Mono.just(errorResult);\n            }\n\n            ActionExecutionRequest actionExecutionRequest =\n                    RequestCaptureFilter.populateRequestFields(actionConfiguration, uri, insertedParams, objectMapper);\n\n            try {\n                if (uriUtils.isHostDisallowed(uri)) {\n                    errorResult.setBody(AppsmithPluginError.PLUGIN_EXECUTE_ARGUMENT_ERROR.getMessage(\"Host not allowed.\"));\n                    errorResult.setRequest(actionExecutionRequest);\n                    return Mono.just(errorResult);\n                }\n            } catch (UnknownHostException e) {\n                errorResult.setBody(AppsmithPluginError.PLUGIN_EXECUTE_ARGUMENT_ERROR.getMessage(\"Unknown host.\"));\n                errorResult.setRequest(actionExecutionRequest);\n                return Mono.just(errorResult);\n            }\n\n            WebClient.Builder webClientBuilder = triggerUtils.getWebClientBuilder(actionConfiguration,\n                    datasourceConfiguration);\n\n            String reqContentType = headerUtils.getRequestContentType(actionConfiguration, datasourceConfiguration);\n\n            /* Check for content type */\n            final String contentTypeError = headerUtils.verifyContentType(actionConfiguration.getHeaders());\n            if (contentTypeError != null) {\n                errorResult.setBody(AppsmithPluginError.PLUGIN_EXECUTE_ARGUMENT_ERROR.getMessage(\"Invalid value for Content-Type.\"));\n                errorResult.setRequest(actionExecutionRequest);\n                return Mono.just(errorResult);\n            }\n\n            HttpMethod httpMethod = actionConfiguration.getHttpMethod();\n            if (httpMethod == null) {\n                errorResult.setBody(AppsmithPluginError.PLUGIN_EXECUTE_ARGUMENT_ERROR.getMessage(\"HTTPMethod must be set.\"));\n                errorResult.setRequest(actionExecutionRequest);\n                return Mono.just(errorResult);\n            }\n\n            if (HttpMethod.POST.equals(httpMethod)) {\n                /**\n                 * For content-type=application/json re-formatting is required.\n                 * Ref: https://graphql.org/learn/serving-over-http/#post-request\n                 *\n                 * Graphql reference doc also mentions that content-type=application/graphql does not require any\n                 * re-formatting.\n                 * Ref: https://graphql.org/learn/serving-over-http/#post-request\n                 *\n                 * On searching over the web I also found that there are some custom content-type in use like\n                 * `application/graphql+json` or `application/graphql-json` that expect the data in the same format\n                 * as is for `application/json`. Hence, the current check assumes that any content type that differs\n                 * from `application/graphql` would expect the data in the same format as for `application/json`\n                 */\n                if (!ApiContentType.GRAPHQL.getValue().equals(reqContentType)) {\n                    /**\n                     * When a GraphQL request is sent using HTTP POST method, then the request body needs to be in the\n                     * following format:\n                     * {\n                     *     \"query\": \"... graphql query body ...\",\n                     *     \"variables\": {\"var1\": val1, \"var2\": val2 ...},\n                     *     \"operationName\": \"name of operation\" // only required if multiple operations are defined in a\n                     *     single query body\n                     * }\n                     * Ref: https://graphql.org/learn/serving-over-http/\n                     */\n                    try {\n                        actionConfiguration.setBody(convertToGraphQLPOSTBodyFormat(actionConfiguration));\n                    } catch (AppsmithPluginException e) {\n                        return Mono.error(e);\n                    }\n                }\n            }\n            else if (HttpMethod.GET.equals(httpMethod)) {\n                /**\n                 * When a GraphQL request is sent using GET method, the GraphQL body and variables are sent as part of\n                 * query parameters in the URL.\n                 * Ref: https://graphql.org/learn/serving-over-http/\n                 */\n                List<Property> additionalQueryParams = getGraphQLQueryParamsForBodyAndVariables(actionConfiguration);\n                uri = uriUtils.addQueryParamsToURI(uri, additionalQueryParams, encodeParamsToggle);\n            }\n            else {\n                /**\n                 * Only POST and GET HTTP methods are supported by GraphQL specifications.\n                 * Ref: https://graphql.org/learn/serving-over-http/\n                 */\n                return Mono.error(\n                        new AppsmithPluginException(\n                                AppsmithPluginError.PLUGIN_ERROR,\n                                \"Appsmith server has found an unexpected HTTP method configured with the GraphQL \" +\n                                        \"plugin query: \" + httpMethod\n                        )\n                );\n            }\n\n            final RequestCaptureFilter requestCaptureFilter = new RequestCaptureFilter(objectMapper);\n            Object requestBodyObj = dataUtils.getRequestBodyObject(actionConfiguration, reqContentType,\n                    encodeParamsToggle,\n                    httpMethod);\n            WebClient client = triggerUtils.getWebClient(webClientBuilder, apiConnection, reqContentType, objectMapper,\n                    EXCHANGE_STRATEGIES, requestCaptureFilter);\n\n            /* Triggering the actual REST API call */\n            Set<String> hintMessages = new HashSet<String>();\n            return triggerUtils.triggerApiCall(client, httpMethod, uri, requestBodyObj, actionExecutionRequest,\n                    objectMapper,\n                    hintMessages, errorResult, requestCaptureFilter);\n        }\n\n        @Override\n        public Object substituteValueInInput(int index,\n                                             String binding,\n                                             String value,\n                                             Object input,\n                                             List<Map.Entry<String, String>> insertedParams,\n                                             Object... args) {\n            boolean isInputQueryBody = (boolean) args[0];\n            if (!isInputQueryBody) {\n                String queryVariables = (String) input;\n                return DataTypeStringUtils.jsonSmartReplacementPlaceholderWithValue(queryVariables, value, null, insertedParams, null);\n            }\n            else {\n                String queryBody = (String) input;\n                return smartlyReplaceGraphQLQueryBodyPlaceholderWithValue(queryBody, value, insertedParams);\n            }\n        }\n\n        /**\n         * This method returns a set of paths that are expected to contain bindings that refer to the\n         * same action object i.e. a cyclic reference. e.g. A GraphQL API response can contain pagination\n         * cursors that are required to be configured in the pagination tab of the same API. We don't want to treat\n         * these cyclic references as cyclic dependency errors.\n         */\n        @Override\n        public Set<String> getSelfReferencingDataPaths() {\n            return Set.of(\"pluginSpecifiedTemplates[\" + PAGINATION_DATA_INDEX + \"].value.limitBased.limit.value\",\n                    \"pluginSpecifiedTemplates[\" + PAGINATION_DATA_INDEX + \"].value.limitBased.offset.value\",\n                    \"pluginSpecifiedTemplates[\" + PAGINATION_DATA_INDEX + \"].value.cursorBased.next.limit.value\",\n                    \"pluginSpecifiedTemplates[\" + PAGINATION_DATA_INDEX + \"].value.cursorBased.next.cursor.value\",\n                    \"pluginSpecifiedTemplates[\" + PAGINATION_DATA_INDEX + \"].value.cursorBased.previous.limit.value\",\n                    \"pluginSpecifiedTemplates[\" + PAGINATION_DATA_INDEX + \"].value.cursorBased.previous.cursor.value\");\n        }\n    }\n}\n", "package com.external.plugins;\n\nimport com.appsmith.external.dtos.ExecuteActionDTO;\nimport com.appsmith.external.exceptions.pluginExceptions.AppsmithPluginError;\nimport com.appsmith.external.exceptions.pluginExceptions.AppsmithPluginException;\nimport com.appsmith.external.helpers.DataTypeStringUtils;\nimport com.appsmith.external.helpers.MustacheHelper;\nimport com.appsmith.external.models.ActionConfiguration;\nimport com.appsmith.external.models.ActionExecutionRequest;\nimport com.appsmith.external.models.ActionExecutionResult;\nimport com.appsmith.external.models.DatasourceConfiguration;\nimport com.appsmith.external.models.PaginationField;\nimport com.appsmith.external.models.PaginationType;\nimport com.appsmith.external.models.Property;\nimport com.appsmith.external.plugins.BasePlugin;\nimport com.appsmith.external.plugins.BaseRestApiPluginExecutor;\nimport com.appsmith.external.services.SharedConfig;\nimport com.appsmith.external.helpers.restApiUtils.connections.APIConnection;\nimport com.appsmith.external.helpers.restApiUtils.helpers.RequestCaptureFilter;\nimport lombok.extern.slf4j.Slf4j;\nimport org.pf4j.Extension;\nimport org.pf4j.PluginWrapper;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.web.reactive.function.client.WebClient;\nimport reactor.core.publisher.Mono;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static java.lang.Boolean.TRUE;\n\n@Slf4j\npublic class RestApiPlugin extends BasePlugin {\n\n    public RestApiPlugin(PluginWrapper wrapper) {\n        super(wrapper);\n    }\n\n    @Extension\n    public static class RestApiPluginExecutor extends BaseRestApiPluginExecutor {\n\n        public RestApiPluginExecutor(SharedConfig sharedConfig) {\n            super(sharedConfig);\n        }\n\n        /**\n         * Instead of using the default executeParametrized provided by pluginExecutor, this implementation affords an opportunity\n         * also update the datasource and action configuration for pagination and some minor cleanup of the configuration before execution\n         *\n         * @param connection              : This is the connection that is established to the data source. This connection is according\n         *                                to the parameters in Datasource Configuration\n         * @param executeActionDTO        : This is the data structure sent by the client during execute. This contains the params\n         *                                which would be used for substitution\n         * @param datasourceConfiguration : These are the configurations which have been used to create a Datasource from a Plugin\n         * @param actionConfiguration     : These are the configurations which have been used to create an Action from a Datasource.\n         * @return\n         */\n        @Override\n        public Mono<ActionExecutionResult> executeParameterized(APIConnection connection,\n                                                                ExecuteActionDTO executeActionDTO,\n                                                                DatasourceConfiguration datasourceConfiguration,\n                                                                ActionConfiguration actionConfiguration) {\n\n            final List<Property> properties = actionConfiguration.getPluginSpecifiedTemplates();\n            List<Map.Entry<String, String>> parameters = new ArrayList<>();\n\n            // Smartly substitute in actionConfiguration.body and replace all the bindings with values.\n            Boolean smartJsonSubstitution = this.smartSubstitutionUtils.isSmartSubstitutionEnabled(properties);\n            if (TRUE.equals(smartJsonSubstitution)) {\n                // Do smart replacements in JSON body\n                if (actionConfiguration.getBody() != null) {\n\n                    // First extract all the bindings in order\n                    List<String> mustacheKeysInOrder = MustacheHelper.extractMustacheKeysInOrder(actionConfiguration.getBody());\n                    // Replace all the bindings with a ? as expected in a prepared statement.\n                    String updatedBody = MustacheHelper.replaceMustacheWithPlaceholder(actionConfiguration.getBody(), mustacheKeysInOrder);\n\n                    try {\n                        updatedBody = (String) smartSubstitutionOfBindings(updatedBody,\n                                mustacheKeysInOrder,\n                                executeActionDTO.getParams(),\n                                parameters);\n                    } catch (AppsmithPluginException e) {\n                        ActionExecutionResult errorResult = new ActionExecutionResult();\n                        errorResult.setIsExecutionSuccess(false);\n                        errorResult.setErrorInfo(e);\n                        errorResult.setStatusCode(AppsmithPluginError.PLUGIN_ERROR.getAppErrorCode().toString());\n                        return Mono.just(errorResult);\n                    }\n\n                    actionConfiguration.setBody(updatedBody);\n                }\n            }\n\n            prepareConfigurationsForExecution(executeActionDTO, actionConfiguration, datasourceConfiguration);\n\n            // If the action is paginated, update the configurations to update the correct URL.\n            if (actionConfiguration.getPaginationType() != null &&\n                    PaginationType.URL.equals(actionConfiguration.getPaginationType()) &&\n                    executeActionDTO.getPaginationField() != null) {\n                updateDatasourceConfigurationForPagination(actionConfiguration, datasourceConfiguration, executeActionDTO.getPaginationField());\n                updateActionConfigurationForPagination(actionConfiguration, executeActionDTO.getPaginationField());\n            }\n\n            // Filter out any empty headers\n            headerUtils.removeEmptyHeaders(actionConfiguration);\n\n            return this.executeCommon(connection, datasourceConfiguration, actionConfiguration, parameters);\n        }\n\n        public Mono<ActionExecutionResult> executeCommon(APIConnection apiConnection,\n                                                         DatasourceConfiguration datasourceConfiguration,\n                                                         ActionConfiguration actionConfiguration,\n                                                         List<Map.Entry<String, String>> insertedParams) {\n\n            // Initializing object for error condition\n            ActionExecutionResult errorResult = new ActionExecutionResult();\n            initUtils.initializeResponseWithError(errorResult);\n\n            // Set of hint messages that can be returned to the user.\n            Set<String> hintMessages = new HashSet();\n\n            // Initializing request URL\n            String url = initUtils.initializeRequestUrl(actionConfiguration, datasourceConfiguration);\n\n            Boolean encodeParamsToggle = headerUtils.isEncodeParamsToggleEnabled(actionConfiguration);\n\n            URI uri;\n            try {\n                uri = uriUtils.createUriWithQueryParams(actionConfiguration, datasourceConfiguration, url,\n                        encodeParamsToggle);\n            } catch (URISyntaxException e) {\n                ActionExecutionRequest actionExecutionRequest =\n                        RequestCaptureFilter.populateRequestFields(actionConfiguration, null, insertedParams, objectMapper);\n                actionExecutionRequest.setUrl(url);\n                errorResult.setBody(AppsmithPluginError.PLUGIN_EXECUTE_ARGUMENT_ERROR.getMessage(e));\n                errorResult.setRequest(actionExecutionRequest);\n                return Mono.just(errorResult);\n            }\n\n            ActionExecutionRequest actionExecutionRequest =\n                    RequestCaptureFilter.populateRequestFields(actionConfiguration, uri, insertedParams, objectMapper);\n\n            try {\n                if (uriUtils.isHostDisallowed(uri)) {\n                    errorResult.setBody(AppsmithPluginError.PLUGIN_EXECUTE_ARGUMENT_ERROR.getMessage(\"Host not allowed.\"));\n                    errorResult.setRequest(actionExecutionRequest);\n                    return Mono.just(errorResult);\n                }\n            } catch (UnknownHostException e) {\n                errorResult.setBody(AppsmithPluginError.PLUGIN_EXECUTE_ARGUMENT_ERROR.getMessage(\"Unknown host.\"));\n                errorResult.setRequest(actionExecutionRequest);\n                return Mono.just(errorResult);\n            }\n\n            WebClient.Builder webClientBuilder = triggerUtils.getWebClientBuilder(actionConfiguration,\n                    datasourceConfiguration);\n            String reqContentType = headerUtils.getRequestContentType(actionConfiguration, datasourceConfiguration);\n\n            /* Check for content type */\n            final String contentTypeError = headerUtils.verifyContentType(actionConfiguration.getHeaders());\n            if (contentTypeError != null) {\n                errorResult.setBody(AppsmithPluginError.PLUGIN_EXECUTE_ARGUMENT_ERROR.getMessage(\"Invalid value for Content-Type.\"));\n                errorResult.setRequest(actionExecutionRequest);\n                return Mono.just(errorResult);\n            }\n\n            HttpMethod httpMethod = actionConfiguration.getHttpMethod();\n            if (httpMethod == null) {\n                errorResult.setBody(AppsmithPluginError.PLUGIN_EXECUTE_ARGUMENT_ERROR.getMessage(\"HTTPMethod must be set.\"));\n                errorResult.setRequest(actionExecutionRequest);\n                return Mono.just(errorResult);\n            }\n\n            final RequestCaptureFilter requestCaptureFilter = new RequestCaptureFilter(objectMapper);\n            Object requestBodyObj = dataUtils.getRequestBodyObject(actionConfiguration, reqContentType,\n                    encodeParamsToggle,\n                    httpMethod);\n            WebClient client = triggerUtils.getWebClient(webClientBuilder, apiConnection, reqContentType, objectMapper,\n                    EXCHANGE_STRATEGIES, requestCaptureFilter);\n\n            /* Triggering the actual REST API call */\n            return triggerUtils.triggerApiCall(client, httpMethod, uri, requestBodyObj, actionExecutionRequest,\n                    objectMapper, hintMessages, errorResult, requestCaptureFilter);\n        }\n\n        private ActionConfiguration updateActionConfigurationForPagination(ActionConfiguration actionConfiguration,\n                                                                           PaginationField paginationField) {\n            if (PaginationField.NEXT.equals(paginationField) || PaginationField.PREV.equals(paginationField)) {\n                actionConfiguration.setPath(\"\");\n                actionConfiguration.setQueryParameters(null);\n            }\n            return actionConfiguration;\n        }\n\n        private DatasourceConfiguration updateDatasourceConfigurationForPagination(ActionConfiguration actionConfiguration,\n                                                                                   DatasourceConfiguration datasourceConfiguration,\n                                                                                   PaginationField paginationField) {\n            if (PaginationField.NEXT.equals(paginationField)) {\n                if (actionConfiguration.getNext() == null) {\n                    datasourceConfiguration.setUrl(null);\n                } else {\n                    datasourceConfiguration.setUrl(URLDecoder.decode(actionConfiguration.getNext(), StandardCharsets.UTF_8));\n                }\n            } else if (PaginationField.PREV.equals(paginationField)) {\n                datasourceConfiguration.setUrl(actionConfiguration.getPrev());\n            }\n            return datasourceConfiguration;\n        }\n\n        @Override\n        public Object substituteValueInInput(int index,\n                                             String binding,\n                                             String value,\n                                             Object input,\n                                             List<Map.Entry<String, String>> insertedParams,\n                                             Object... args) {\n            String jsonBody = (String) input;\n            return DataTypeStringUtils.jsonSmartReplacementPlaceholderWithValue(jsonBody, value, null, insertedParams, null);\n        }\n    }\n}\n"], "fixing_code": ["package com.appsmith.external.helpers.restApiUtils.helpers;\n\nimport com.appsmith.external.exceptions.pluginExceptions.AppsmithPluginError;\nimport com.appsmith.external.exceptions.pluginExceptions.AppsmithPluginException;\nimport com.appsmith.external.helpers.SSLHelper;\nimport com.appsmith.external.helpers.restApiUtils.connections.APIConnection;\nimport com.appsmith.external.helpers.restApiUtils.constants.ResponseDataType;\nimport com.appsmith.external.models.ActionConfiguration;\nimport com.appsmith.external.models.ActionExecutionRequest;\nimport com.appsmith.external.models.ActionExecutionResult;\nimport com.appsmith.external.models.DatasourceConfiguration;\nimport com.appsmith.external.models.Property;\nimport com.appsmith.util.WebClientUtils;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.security.Keys;\nimport lombok.NoArgsConstructor;\nimport org.bson.internal.Base64;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.client.reactive.ClientHttpRequest;\nimport org.springframework.web.reactive.function.BodyInserter;\nimport org.springframework.web.reactive.function.client.ClientResponse;\nimport org.springframework.web.reactive.function.client.ExchangeStrategies;\nimport org.springframework.web.reactive.function.client.WebClient;\nimport reactor.core.Exceptions;\nimport reactor.core.publisher.Mono;\nimport reactor.netty.http.client.HttpClient;\nimport reactor.netty.resources.ConnectionProvider;\n\nimport javax.crypto.SecretKey;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Set;\n\nimport static org.apache.commons.lang3.StringUtils.isNotEmpty;\n\n@NoArgsConstructor\npublic class TriggerUtils {\n\n    public static String SIGNATURE_HEADER_NAME = \"X-APPSMITH-SIGNATURE\";\n    public static String RESPONSE_DATA_TYPE = \"X-APPSMITH-DATATYPE\";\n    public static int MAX_REDIRECTS = 5;\n    public static Set BINARY_DATA_TYPES = Set.of(\"application/zip\", \"application/octet-stream\", \"application/pdf\",\n            \"application/pkcs8\", \"application/x-binary\");\n\n    public static HeaderUtils headerUtils = new HeaderUtils();\n\n    public Mono<ActionExecutionResult> triggerApiCall(WebClient client, HttpMethod httpMethod, URI uri,\n                                                             Object requestBody,\n                                                             ActionExecutionRequest actionExecutionRequest,\n                                                             ObjectMapper objectMapper, Set<String> hintMessages,\n                                                             ActionExecutionResult errorResult,\n                                                             RequestCaptureFilter requestCaptureFilter) {\n        return httpCall(client, httpMethod, uri, requestBody, 0)\n                .flatMap(clientResponse -> clientResponse.toEntity(byte[].class))\n                .map(stringResponseEntity -> {\n                    HttpHeaders headers = stringResponseEntity.getHeaders();\n                        /*\n                            Find the media type of the response to parse the body as required. In case the content-type\n                            header is not present in the response then set it to our default i.e. \"text/plain\" although\n                            the RFC 7231 standard suggests assuming \"application/octet-stream\" content-type in case\n                            it's not present in response header.\n                         */\n                    MediaType contentType = headers.getContentType();\n                    if (contentType == null) {\n                        contentType = MediaType.TEXT_PLAIN;\n                    }\n                    byte[] body = stringResponseEntity.getBody();\n                    HttpStatus statusCode = stringResponseEntity.getStatusCode();\n\n                    ActionExecutionResult result = new ActionExecutionResult();\n\n                    // Set the request fields\n                    result.setRequest(requestCaptureFilter.populateRequestFields(actionExecutionRequest));\n\n                    result.setStatusCode(statusCode.toString());\n                    result.setIsExecutionSuccess(statusCode.is2xxSuccessful());\n\n                    // Convert the headers into json tree to store in the results\n                    String headerInJsonString;\n                    try {\n                        headerInJsonString = objectMapper.writeValueAsString(headers);\n                    } catch (JsonProcessingException e) {\n                        throw Exceptions.propagate(new AppsmithPluginException(AppsmithPluginError.PLUGIN_ERROR, e));\n                    }\n\n                    // Set headers in the result now\n                    try {\n                        result.setHeaders(objectMapper.readTree(headerInJsonString));\n                    } catch (IOException e) {\n                        throw Exceptions.propagate(\n                                new AppsmithPluginException(\n                                        AppsmithPluginError.PLUGIN_JSON_PARSE_ERROR,\n                                        headerInJsonString,\n                                        e.getMessage()\n                                )\n                        );\n                    }\n\n                    if (body != null) {\n\n                        ResponseDataType responseDataType = ResponseDataType.UNDEFINED;\n\n                        /**TODO\n                         * Handle XML response. Currently we only handle JSON & Image responses. The other kind of responses\n                         * are kept as is and returned as a string.\n                         */\n                        if (contentType.includes(MediaType.APPLICATION_JSON)) {\n                            try {\n                                String jsonBody = new String(body, StandardCharsets.UTF_8);\n                                result.setBody(objectMapper.readTree(jsonBody));\n                                responseDataType = ResponseDataType.JSON;\n                            } catch (IOException e) {\n                                System.out.println(\"Unable to parse response JSON. Setting response body as string.\");\n                                String bodyString = new String(body, StandardCharsets.UTF_8);\n                                result.setBody(bodyString.trim());\n\n                                // Warn user that the API response is not a valid JSON.\n                                hintMessages.add(\"The response returned by this API is not a valid JSON. Please \" +\n                                        \"be careful when using the API response anywhere a valid JSON is required\" +\n                                        \". You may resolve this issue either by modifying the 'Content-Type' \" +\n                                        \"Header to indicate a non-JSON response or by modifying the API response \" +\n                                        \"to return a valid JSON.\");\n                            }\n                        } else if (MediaType.IMAGE_GIF.equals(contentType) ||\n                                MediaType.IMAGE_JPEG.equals(contentType) ||\n                                MediaType.IMAGE_PNG.equals(contentType)) {\n                            String encode = Base64.encode(body);\n                            result.setBody(encode);\n                            responseDataType = ResponseDataType.IMAGE;\n\n                        } else if (BINARY_DATA_TYPES.contains(contentType.toString())) {\n                            String encode = Base64.encode(body);\n                            result.setBody(encode);\n                            responseDataType = ResponseDataType.BINARY;\n                        } else {\n                            // If the body is not of JSON type, just set it as is.\n                            String bodyString = new String(body, StandardCharsets.UTF_8);\n                            result.setBody(bodyString.trim());\n                            responseDataType = ResponseDataType.TEXT;\n                        }\n\n                        // Now add a new header which specifies the data type of the response as per Appsmith\n                        JsonNode headersJsonNode = result.getHeaders();\n                        ObjectNode headersObjectNode = (ObjectNode) headersJsonNode;\n                        headersObjectNode.putArray(RESPONSE_DATA_TYPE)\n                                .add(String.valueOf(responseDataType));\n                        result.setHeaders(headersObjectNode);\n\n                    }\n\n                    result.setMessages(hintMessages);\n                    return result;\n                })\n                .onErrorResume(error -> {\n                    errorResult.setRequest(requestCaptureFilter.populateRequestFields(actionExecutionRequest));\n                    errorResult.setIsExecutionSuccess(false);\n                    errorResult.setErrorInfo(error);\n                    return Mono.just(errorResult);\n                });\n\n    }\n\n    protected Mono<ClientResponse> httpCall(WebClient webClient, HttpMethod httpMethod, URI uri, Object requestBody,\n                                          int iteration) {\n        if (iteration == MAX_REDIRECTS) {\n            return Mono.error(new AppsmithPluginException(\n                    AppsmithPluginError.PLUGIN_ERROR,\n                    \"Exceeded the HTTP redirect limits of \" + MAX_REDIRECTS\n            ));\n        }\n\n        assert requestBody instanceof BodyInserter<?, ?>;\n        BodyInserter<?, ?> finalRequestBody = (BodyInserter<?, ?>) requestBody;\n\n        return webClient\n                .method(httpMethod)\n                .uri(uri)\n                .body((BodyInserter<?, ? super ClientHttpRequest>) finalRequestBody)\n                .exchange()\n                .doOnError(e -> Mono.error(new AppsmithPluginException(AppsmithPluginError.PLUGIN_ERROR, e)))\n                .flatMap(response -> {\n                    if (response.statusCode().is3xxRedirection()) {\n                        String redirectUrl = response.headers().header(\"Location\").get(0);\n                        /**\n                         * TODO\n                         * In case the redirected URL is not absolute (complete), create the new URL using the relative path\n                         * This particular scenario is seen in the URL : https://rickandmortyapi.com/api/character\n                         * It redirects to partial URI : /api/character/\n                         * In this scenario we should convert the partial URI to complete URI\n                         */\n                        final URI redirectUri;\n                        try {\n                            redirectUri = new URI(redirectUrl);\n                        } catch (URISyntaxException e) {\n                            return Mono.error(new AppsmithPluginException(AppsmithPluginError.PLUGIN_ERROR, e));\n                        }\n\n                        return httpCall(webClient, httpMethod, redirectUri, finalRequestBody, iteration + 1);\n                    }\n                    return Mono.just(response);\n                });\n    }\n\n    public WebClient getWebClient(WebClient.Builder webClientBuilder, APIConnection apiConnection,\n                                         String reqContentType, ObjectMapper objectMapper,\n                                         ExchangeStrategies EXCHANGE_STRATEGIES, RequestCaptureFilter requestCaptureFilter) {\n        // Right before building the webclient object, we populate it with whatever mutation the APIConnection object demands\n        if (apiConnection != null) {\n            webClientBuilder.filter(apiConnection);\n        }\n\n        if (MediaType.MULTIPART_FORM_DATA_VALUE.equals(reqContentType)) {\n            webClientBuilder.filter(new BufferingFilter());\n        }\n\n        webClientBuilder.filter(requestCaptureFilter);\n\n        return webClientBuilder.exchangeStrategies(EXCHANGE_STRATEGIES).build();\n    }\n\n    public WebClient.Builder getWebClientBuilder(ActionConfiguration actionConfiguration,\n                                                        DatasourceConfiguration datasourceConfiguration) {\n        HttpClient httpClient = getHttpClient(datasourceConfiguration);\n        WebClient.Builder webClientBuilder = WebClientUtils.builder(httpClient);\n        addAllHeaders(webClientBuilder, actionConfiguration, datasourceConfiguration);\n        addSecretKey(webClientBuilder, datasourceConfiguration);\n\n        return webClientBuilder;\n    }\n\n    protected void addSecretKey(WebClient.Builder webClientBuilder,\n                                     DatasourceConfiguration datasourceConfiguration) throws AppsmithPluginException {\n        // If users have chosen to share the Appsmith signature in the header, calculate and add that\n        String secretKey;\n        secretKey = headerUtils.getSignatureKey(datasourceConfiguration);\n\n        if (secretKey != null) {\n            final SecretKey key = Keys.hmacShaKeyFor(secretKey.getBytes(StandardCharsets.UTF_8));\n            final Instant now = Instant.now();\n            final String token = Jwts.builder()\n                    .setIssuer(\"Appsmith\")\n                    .setIssuedAt(new Date(now.toEpochMilli()))\n                    .setExpiration(new Date(now.plusSeconds(600).toEpochMilli()))\n                    .signWith(key)\n                    .compact();\n\n            webClientBuilder.defaultHeader(SIGNATURE_HEADER_NAME, token);\n        }\n    }\n\n    protected void addAllHeaders(WebClient.Builder webClientBuilder, ActionConfiguration actionConfiguration,\n                                      DatasourceConfiguration datasourceConfiguration) {\n        /**\n         * First, check if headers are defined in API datasource and add them.\n         */\n        if (datasourceConfiguration.getHeaders() != null) {\n            addHeaders(webClientBuilder, datasourceConfiguration.getHeaders());\n        }\n\n        /**\n         * If headers are defined in API action config, then add them too.\n         * In case there is a conflict with the datasource headers then the header defined in the API action config\n         * will override it.\n         */\n        if (actionConfiguration.getHeaders() != null) {\n            addHeaders(webClientBuilder, actionConfiguration.getHeaders());\n        }\n    }\n\n    protected void addHeaders(WebClient.Builder webClientBuilder, List<Property> headers) {\n        headers.stream()\n                .filter(header -> isNotEmpty(header.getKey()))\n                .forEach(header -> webClientBuilder.defaultHeader(header.getKey(), (String) header.getValue()));\n    }\n\n    protected HttpClient getHttpClient(DatasourceConfiguration datasourceConfiguration) {\n        // Initializing webClient to be used for http call\n        final ConnectionProvider provider = ConnectionProvider\n                .builder(\"rest-api-provider\")\n                .maxIdleTime(Duration.ofSeconds(600))\n                .maxLifeTime(Duration.ofSeconds(600))\n                .build();\n\n        HttpClient httpClient = HttpClient.create(provider)\n                .secure(SSLHelper.sslCheckForHttpClient(datasourceConfiguration))\n                .compress(true);\n\n        return httpClient;\n    }\n}\n", "package com.appsmith.external.helpers.restApiUtils.helpers;\n\nimport com.appsmith.external.models.ActionConfiguration;\nimport com.appsmith.external.models.DatasourceConfiguration;\nimport com.appsmith.external.models.Property;\nimport lombok.NoArgsConstructor;\nimport org.springframework.web.util.UriComponentsBuilder;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.apache.commons.collections.CollectionUtils.isEmpty;\nimport static org.apache.commons.lang3.StringUtils.isNotEmpty;\n\n@NoArgsConstructor\npublic class URIUtils {\n\n    public URI createUriWithQueryParams(ActionConfiguration actionConfiguration,\n                                        DatasourceConfiguration datasourceConfiguration, String url,\n                                        boolean encodeParamsToggle) throws URISyntaxException {\n        String httpUrl = addHttpToUrlWhenPrefixNotPresent(url);\n\n        ArrayList<Property> allQueryParams = new ArrayList<>();\n        if (!isEmpty(actionConfiguration.getQueryParameters())) {\n            allQueryParams.addAll(actionConfiguration.getQueryParameters());\n        }\n\n        if (!isEmpty(datasourceConfiguration.getQueryParameters())) {\n            allQueryParams.addAll(datasourceConfiguration.getQueryParameters());\n        }\n\n        return addQueryParamsToURI(new URI(httpUrl), allQueryParams, encodeParamsToggle);\n    }\n\n    public URI addQueryParamsToURI(URI uri, List<Property> allQueryParams, boolean encodeParamsToggle) {\n        UriComponentsBuilder uriBuilder = UriComponentsBuilder.newInstance();\n        uriBuilder.uri(uri);\n\n        if (allQueryParams != null) {\n            for (Property queryParam : allQueryParams) {\n                String key = queryParam.getKey();\n                if (isNotEmpty(key)) {\n                    if (encodeParamsToggle) {\n                        uriBuilder.queryParam(\n                                URLEncoder.encode(key, StandardCharsets.UTF_8),\n                                URLEncoder.encode((String) queryParam.getValue(), StandardCharsets.UTF_8)\n                        );\n                    } else {\n                        uriBuilder.queryParam(\n                                key,\n                                queryParam.getValue()\n                        );\n                    }\n                }\n            }\n        }\n\n        return uriBuilder.build(true).toUri();\n    }\n\n    protected String addHttpToUrlWhenPrefixNotPresent(String url) {\n        if (url == null || url.toLowerCase().startsWith(\"http\") || url.contains(\"://\")) {\n            return url;\n        }\n        return \"http://\" + url;\n    }\n\n}\n", "package com.appsmith.util;\n\nimport io.netty.resolver.AddressResolver;\nimport io.netty.resolver.AddressResolverGroup;\nimport io.netty.resolver.InetNameResolver;\nimport io.netty.resolver.InetSocketAddressResolver;\nimport io.netty.util.concurrent.EventExecutor;\nimport io.netty.util.concurrent.Promise;\nimport io.netty.util.internal.SocketUtils;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.http.client.reactive.ReactorClientHttpConnector;\nimport org.springframework.web.reactive.function.client.WebClient;\nimport reactor.netty.http.client.HttpClient;\n\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Set;\n\npublic class WebClientUtils {\n\n    private static final Set<String> DISALLOWED_HOSTS = Set.of(\n            \"169.254.169.254\",\n            \"metadata.google.internal\"\n    );\n\n    private WebClientUtils() {\n    }\n\n    public static WebClient create() {\n        return builder()\n                .build();\n    }\n\n    public static WebClient create(String baseUrl) {\n        return builder()\n                .baseUrl(baseUrl)\n                .build();\n    }\n\n    private static boolean shouldUseSystemProxy() {\n        return \"true\".equals(System.getProperty(\"java.net.useSystemProxies\"))\n                && (!System.getProperty(\"http.proxyHost\", \"\").isEmpty() || !System.getProperty(\"https.proxyHost\", \"\").isEmpty());\n    }\n\n    public static WebClient.Builder builder() {\n        return builder(HttpClient.create());\n    }\n\n    public static WebClient.Builder builder(HttpClient httpClient) {\n        return WebClient.builder()\n                .clientConnector(new ReactorClientHttpConnector(makeSafeHttpClient(httpClient)));\n    }\n\n    private static HttpClient makeSafeHttpClient(HttpClient httpClient) {\n        if (shouldUseSystemProxy()) {\n            httpClient = httpClient.proxyWithSystemProperties();\n        }\n\n        return httpClient.resolver(ResolverGroup.INSTANCE);\n    }\n\n    private static class ResolverGroup extends AddressResolverGroup<InetSocketAddress> {\n        public static final ResolverGroup INSTANCE = new ResolverGroup();\n\n        @Override\n        protected AddressResolver<InetSocketAddress> newResolver(EventExecutor executor) {\n            return new InetSocketAddressResolver(executor, new NameResolver(executor));\n        }\n    }\n\n    @Slf4j\n    private static class NameResolver extends InetNameResolver {\n\n        public NameResolver(EventExecutor executor) {\n            super(executor);\n        }\n\n        private static boolean isDisallowedAndFail(String host, Promise<?> promise) {\n            if (DISALLOWED_HOSTS.contains(host)) {\n                log.warn(\"Host {} is disallowed. Failing the request.\", host);\n                promise.setFailure(new UnknownHostException(\"Host not allowed.\"));\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        protected void doResolve(String inetHost, Promise<InetAddress> promise) {\n            if (isDisallowedAndFail(inetHost, promise)) {\n                return;\n            }\n\n            final InetAddress address;\n            try {\n                address = SocketUtils.addressByName(inetHost);\n            } catch (UnknownHostException e) {\n                promise.setFailure(e);\n                return;\n            }\n\n            if (isDisallowedAndFail(address.getHostAddress(), promise)) {\n                return;\n            }\n\n            promise.setSuccess(address);\n        }\n\n        @Override\n        protected void doResolveAll(String inetHost, Promise<List<InetAddress>> promise) {\n            if (isDisallowedAndFail(inetHost, promise)) {\n                return;\n            }\n\n            final List<InetAddress> addresses;\n            try {\n                addresses = Arrays.asList(SocketUtils.allAddressesByName(inetHost));\n            } catch (UnknownHostException e) {\n                promise.setFailure(e);\n                return;\n            }\n\n            // Even if _one_ of the addresses is disallowed, we fail the request.\n            for (InetAddress address : addresses) {\n                if (isDisallowedAndFail(address.getHostAddress(), promise)) {\n                    return;\n                }\n            }\n\n            promise.setSuccess(addresses);\n        }\n    }\n\n}\n", "package com.external.plugins;\n\nimport com.appsmith.external.dtos.ExecuteActionDTO;\nimport com.appsmith.external.exceptions.pluginExceptions.AppsmithPluginError;\nimport com.appsmith.external.exceptions.pluginExceptions.AppsmithPluginException;\nimport com.appsmith.external.helpers.DataTypeStringUtils;\nimport com.appsmith.external.helpers.MustacheHelper;\nimport com.appsmith.external.helpers.restApiUtils.connections.APIConnection;\nimport com.appsmith.external.helpers.restApiUtils.helpers.RequestCaptureFilter;\nimport com.appsmith.external.models.ActionConfiguration;\nimport com.appsmith.external.models.ActionExecutionRequest;\nimport com.appsmith.external.models.ActionExecutionResult;\nimport com.appsmith.external.models.ApiContentType;\nimport com.appsmith.external.models.DatasourceConfiguration;\nimport com.appsmith.external.models.PaginationType;\nimport com.appsmith.external.models.Property;\nimport com.appsmith.external.plugins.BasePlugin;\nimport com.appsmith.external.plugins.BaseRestApiPluginExecutor;\nimport com.appsmith.external.services.SharedConfig;\nimport com.external.utils.GraphQLHintMessageUtils;\nimport lombok.extern.slf4j.Slf4j;\nimport org.pf4j.Extension;\nimport org.pf4j.PluginWrapper;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.web.reactive.function.client.WebClient;\nimport reactor.core.publisher.Mono;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static com.appsmith.external.helpers.PluginUtils.getValueSafelyFromPropertyList;\nimport static com.appsmith.external.helpers.PluginUtils.setValueSafelyInPropertyList;\nimport static com.external.utils.GraphQLBodyUtils.PAGINATION_DATA_INDEX;\nimport static com.external.utils.GraphQLBodyUtils.QUERY_VARIABLES_INDEX;\nimport static com.external.utils.GraphQLBodyUtils.convertToGraphQLPOSTBodyFormat;\nimport static com.external.utils.GraphQLBodyUtils.getGraphQLQueryParamsForBodyAndVariables;\nimport static com.external.utils.GraphQLBodyUtils.validateBodyAndVariablesSyntax;\nimport static com.external.utils.GraphQLDataTypeUtils.smartlyReplaceGraphQLQueryBodyPlaceholderWithValue;\nimport static com.external.utils.GraphQLPaginationUtils.updateVariablesWithPaginationValues;\nimport static java.lang.Boolean.TRUE;\nimport static org.apache.commons.lang3.StringUtils.isBlank;\n\npublic class GraphQLPlugin extends BasePlugin {\n\n    public GraphQLPlugin(PluginWrapper wrapper) {\n        super(wrapper);\n    }\n\n    @Slf4j\n    @Extension\n    public static class GraphQLPluginExecutor extends BaseRestApiPluginExecutor {\n\n        public GraphQLPluginExecutor(SharedConfig sharedConfig) {\n            super(sharedConfig);\n\n            GraphQLHintMessageUtils hintMessageUtils = new GraphQLHintMessageUtils();\n            super.setHintMessageUtils(hintMessageUtils);\n        }\n\n        /**\n         * Instead of using the default executeParametrized provided by pluginExecutor, this implementation affords an opportunity\n         * also update the datasource and action configuration for pagination and some minor cleanup of the configuration before execution\n         *\n         * @param connection              : This is the connection that is established to the data source. This connection is according\n         *                                to the parameters in Datasource Configuration\n         * @param executeActionDTO        : This is the data structure sent by the client during execute. This contains the params\n         *                                which would be used for substitution\n         * @param datasourceConfiguration : These are the configurations which have been used to create a Datasource from a Plugin\n         * @param actionConfiguration     : These are the configurations which have been used to create an Action from a Datasource.\n         * @return\n         */\n        @Override\n        public Mono<ActionExecutionResult> executeParameterized(APIConnection connection,\n                                                                ExecuteActionDTO executeActionDTO,\n                                                                DatasourceConfiguration datasourceConfiguration,\n                                                                ActionConfiguration actionConfiguration) {\n\n            final List<Property> properties = actionConfiguration.getPluginSpecifiedTemplates();\n            List<Map.Entry<String, String>> parameters = new ArrayList<>();\n\n            String variables = getValueSafelyFromPropertyList(properties, QUERY_VARIABLES_INDEX, String.class);\n            Boolean smartSubstitution = this.smartSubstitutionUtils.isSmartSubstitutionEnabled(properties);\n            if (TRUE.equals(smartSubstitution)) {\n                /* Apply smart JSON substitution logic to mustache binding values in query variables */\n                if (!isBlank(variables)) {\n                    List<String> mustacheKeysInOrder = MustacheHelper.extractMustacheKeysInOrder(variables);\n                    // Replace all the bindings with a ? as expected in a prepared statement.\n                    String updatedVariables = MustacheHelper.replaceMustacheWithPlaceholder(variables, mustacheKeysInOrder);\n\n                    try {\n                        updatedVariables = (String) smartSubstitutionOfBindings(updatedVariables,\n                                mustacheKeysInOrder,\n                                executeActionDTO.getParams(),\n                                parameters,\n                                false);\n                        setValueSafelyInPropertyList(properties, QUERY_VARIABLES_INDEX, updatedVariables);\n                    } catch (AppsmithPluginException e) {\n                        ActionExecutionResult errorResult = new ActionExecutionResult();\n                        errorResult.setIsExecutionSuccess(false);\n                        errorResult.setErrorInfo(e);\n                        errorResult.setStatusCode(AppsmithPluginError.PLUGIN_ERROR.getAppErrorCode().toString());\n                        return Mono.just(errorResult);\n                    }\n                }\n\n                /* Apply smart substitution logic to query body */\n                String query = actionConfiguration.getBody();\n                if (!isBlank(query)) {\n                    List<String> mustacheKeysInOrder = MustacheHelper.extractMustacheKeysInOrder(query);\n                    // Replace all the bindings with a ? as expected in a prepared statement.\n                    String updatedQuery = MustacheHelper.replaceMustacheWithPlaceholder(query, mustacheKeysInOrder);\n\n                    try {\n                        updatedQuery = (String) smartSubstitutionOfBindings(updatedQuery,\n                                mustacheKeysInOrder,\n                                executeActionDTO.getParams(),\n                                parameters,\n                                true);\n                        actionConfiguration.setBody(updatedQuery);\n                    } catch (AppsmithPluginException e) {\n                        ActionExecutionResult errorResult = new ActionExecutionResult();\n                        errorResult.setIsExecutionSuccess(false);\n                        errorResult.setErrorInfo(e);\n                        errorResult.setStatusCode(AppsmithPluginError.PLUGIN_ERROR.getAppErrorCode().toString());\n                        return Mono.just(errorResult);\n                    }\n                }\n            }\n\n            prepareConfigurationsForExecution(executeActionDTO, actionConfiguration, datasourceConfiguration);\n\n            if (isBlank(variables)) {\n                setValueSafelyInPropertyList(properties, QUERY_VARIABLES_INDEX, \"{}\");\n            }\n\n            /* Check if the query body and query variables have the correct GraphQL syntax. */\n            try {\n                validateBodyAndVariablesSyntax(actionConfiguration);\n            } catch (AppsmithPluginException e) {\n                return Mono.error(e);\n            }\n\n            if (actionConfiguration.getPaginationType() != null && !PaginationType.NONE.equals(actionConfiguration.getPaginationType())) {\n                updateVariablesWithPaginationValues(actionConfiguration, executeActionDTO);\n            }\n\n            // Filter out any empty headers\n            headerUtils.removeEmptyHeaders(actionConfiguration);\n\n            return this.executeCommon(connection, datasourceConfiguration, actionConfiguration, parameters);\n        }\n\n        public Mono<ActionExecutionResult> executeCommon(APIConnection apiConnection,\n                                                         DatasourceConfiguration datasourceConfiguration,\n                                                         ActionConfiguration actionConfiguration,\n                                                         List<Map.Entry<String, String>> insertedParams) {\n\n            // Initializing object for error condition\n            ActionExecutionResult errorResult = new ActionExecutionResult();\n            initUtils.initializeResponseWithError(errorResult);\n\n            // Initializing request URL\n            String url = initUtils.initializeRequestUrl(actionConfiguration, datasourceConfiguration);\n\n            Boolean encodeParamsToggle = headerUtils.isEncodeParamsToggleEnabled(actionConfiguration);\n\n            URI uri;\n            try {\n                uri = uriUtils.createUriWithQueryParams(actionConfiguration, datasourceConfiguration, url,\n                        encodeParamsToggle);\n            } catch (URISyntaxException e) {\n                ActionExecutionRequest actionExecutionRequest =\n                        RequestCaptureFilter.populateRequestFields(actionConfiguration, null, insertedParams, objectMapper);\n                actionExecutionRequest.setUrl(url);\n                errorResult.setBody(AppsmithPluginError.PLUGIN_EXECUTE_ARGUMENT_ERROR.getMessage(e));\n                errorResult.setRequest(actionExecutionRequest);\n                return Mono.just(errorResult);\n            }\n\n            ActionExecutionRequest actionExecutionRequest =\n                    RequestCaptureFilter.populateRequestFields(actionConfiguration, uri, insertedParams, objectMapper);\n\n            WebClient.Builder webClientBuilder = triggerUtils.getWebClientBuilder(actionConfiguration,\n                    datasourceConfiguration);\n\n            String reqContentType = headerUtils.getRequestContentType(actionConfiguration, datasourceConfiguration);\n\n            /* Check for content type */\n            final String contentTypeError = headerUtils.verifyContentType(actionConfiguration.getHeaders());\n            if (contentTypeError != null) {\n                errorResult.setBody(AppsmithPluginError.PLUGIN_EXECUTE_ARGUMENT_ERROR.getMessage(\"Invalid value for Content-Type.\"));\n                errorResult.setRequest(actionExecutionRequest);\n                return Mono.just(errorResult);\n            }\n\n            HttpMethod httpMethod = actionConfiguration.getHttpMethod();\n            if (httpMethod == null) {\n                errorResult.setBody(AppsmithPluginError.PLUGIN_EXECUTE_ARGUMENT_ERROR.getMessage(\"HTTPMethod must be set.\"));\n                errorResult.setRequest(actionExecutionRequest);\n                return Mono.just(errorResult);\n            }\n\n            if (HttpMethod.POST.equals(httpMethod)) {\n                /**\n                 * For content-type=application/json re-formatting is required.\n                 * Ref: https://graphql.org/learn/serving-over-http/#post-request\n                 *\n                 * Graphql reference doc also mentions that content-type=application/graphql does not require any\n                 * re-formatting.\n                 * Ref: https://graphql.org/learn/serving-over-http/#post-request\n                 *\n                 * On searching over the web I also found that there are some custom content-type in use like\n                 * `application/graphql+json` or `application/graphql-json` that expect the data in the same format\n                 * as is for `application/json`. Hence, the current check assumes that any content type that differs\n                 * from `application/graphql` would expect the data in the same format as for `application/json`\n                 */\n                if (!ApiContentType.GRAPHQL.getValue().equals(reqContentType)) {\n                    /**\n                     * When a GraphQL request is sent using HTTP POST method, then the request body needs to be in the\n                     * following format:\n                     * {\n                     *     \"query\": \"... graphql query body ...\",\n                     *     \"variables\": {\"var1\": val1, \"var2\": val2 ...},\n                     *     \"operationName\": \"name of operation\" // only required if multiple operations are defined in a\n                     *     single query body\n                     * }\n                     * Ref: https://graphql.org/learn/serving-over-http/\n                     */\n                    try {\n                        actionConfiguration.setBody(convertToGraphQLPOSTBodyFormat(actionConfiguration));\n                    } catch (AppsmithPluginException e) {\n                        return Mono.error(e);\n                    }\n                }\n            }\n            else if (HttpMethod.GET.equals(httpMethod)) {\n                /**\n                 * When a GraphQL request is sent using GET method, the GraphQL body and variables are sent as part of\n                 * query parameters in the URL.\n                 * Ref: https://graphql.org/learn/serving-over-http/\n                 */\n                List<Property> additionalQueryParams = getGraphQLQueryParamsForBodyAndVariables(actionConfiguration);\n                uri = uriUtils.addQueryParamsToURI(uri, additionalQueryParams, encodeParamsToggle);\n            }\n            else {\n                /**\n                 * Only POST and GET HTTP methods are supported by GraphQL specifications.\n                 * Ref: https://graphql.org/learn/serving-over-http/\n                 */\n                return Mono.error(\n                        new AppsmithPluginException(\n                                AppsmithPluginError.PLUGIN_ERROR,\n                                \"Appsmith server has found an unexpected HTTP method configured with the GraphQL \" +\n                                        \"plugin query: \" + httpMethod\n                        )\n                );\n            }\n\n            final RequestCaptureFilter requestCaptureFilter = new RequestCaptureFilter(objectMapper);\n            Object requestBodyObj = dataUtils.getRequestBodyObject(actionConfiguration, reqContentType,\n                    encodeParamsToggle,\n                    httpMethod);\n            WebClient client = triggerUtils.getWebClient(webClientBuilder, apiConnection, reqContentType, objectMapper,\n                    EXCHANGE_STRATEGIES, requestCaptureFilter);\n\n            /* Triggering the actual REST API call */\n            Set<String> hintMessages = new HashSet<>();\n            return triggerUtils.triggerApiCall(client, httpMethod, uri, requestBodyObj, actionExecutionRequest,\n                    objectMapper,\n                    hintMessages, errorResult, requestCaptureFilter);\n        }\n\n        @Override\n        public Object substituteValueInInput(int index,\n                                             String binding,\n                                             String value,\n                                             Object input,\n                                             List<Map.Entry<String, String>> insertedParams,\n                                             Object... args) {\n            boolean isInputQueryBody = (boolean) args[0];\n            if (!isInputQueryBody) {\n                String queryVariables = (String) input;\n                return DataTypeStringUtils.jsonSmartReplacementPlaceholderWithValue(queryVariables, value, null, insertedParams, null);\n            }\n            else {\n                String queryBody = (String) input;\n                return smartlyReplaceGraphQLQueryBodyPlaceholderWithValue(queryBody, value, insertedParams);\n            }\n        }\n\n        /**\n         * This method returns a set of paths that are expected to contain bindings that refer to the\n         * same action object i.e. a cyclic reference. e.g. A GraphQL API response can contain pagination\n         * cursors that are required to be configured in the pagination tab of the same API. We don't want to treat\n         * these cyclic references as cyclic dependency errors.\n         */\n        @Override\n        public Set<String> getSelfReferencingDataPaths() {\n            return Set.of(\"pluginSpecifiedTemplates[\" + PAGINATION_DATA_INDEX + \"].value.limitBased.limit.value\",\n                    \"pluginSpecifiedTemplates[\" + PAGINATION_DATA_INDEX + \"].value.limitBased.offset.value\",\n                    \"pluginSpecifiedTemplates[\" + PAGINATION_DATA_INDEX + \"].value.cursorBased.next.limit.value\",\n                    \"pluginSpecifiedTemplates[\" + PAGINATION_DATA_INDEX + \"].value.cursorBased.next.cursor.value\",\n                    \"pluginSpecifiedTemplates[\" + PAGINATION_DATA_INDEX + \"].value.cursorBased.previous.limit.value\",\n                    \"pluginSpecifiedTemplates[\" + PAGINATION_DATA_INDEX + \"].value.cursorBased.previous.cursor.value\");\n        }\n    }\n}\n", "package com.external.plugins;\n\nimport com.appsmith.external.dtos.ExecuteActionDTO;\nimport com.appsmith.external.exceptions.pluginExceptions.AppsmithPluginError;\nimport com.appsmith.external.exceptions.pluginExceptions.AppsmithPluginException;\nimport com.appsmith.external.helpers.DataTypeStringUtils;\nimport com.appsmith.external.helpers.MustacheHelper;\nimport com.appsmith.external.helpers.restApiUtils.connections.APIConnection;\nimport com.appsmith.external.helpers.restApiUtils.helpers.RequestCaptureFilter;\nimport com.appsmith.external.models.ActionConfiguration;\nimport com.appsmith.external.models.ActionExecutionRequest;\nimport com.appsmith.external.models.ActionExecutionResult;\nimport com.appsmith.external.models.DatasourceConfiguration;\nimport com.appsmith.external.models.PaginationField;\nimport com.appsmith.external.models.PaginationType;\nimport com.appsmith.external.models.Property;\nimport com.appsmith.external.plugins.BasePlugin;\nimport com.appsmith.external.plugins.BaseRestApiPluginExecutor;\nimport com.appsmith.external.services.SharedConfig;\nimport lombok.extern.slf4j.Slf4j;\nimport org.pf4j.Extension;\nimport org.pf4j.PluginWrapper;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.web.reactive.function.client.WebClient;\nimport reactor.core.publisher.Mono;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URLDecoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static java.lang.Boolean.TRUE;\n\n@Slf4j\npublic class RestApiPlugin extends BasePlugin {\n\n    public RestApiPlugin(PluginWrapper wrapper) {\n        super(wrapper);\n    }\n\n    @Extension\n    public static class RestApiPluginExecutor extends BaseRestApiPluginExecutor {\n\n        public RestApiPluginExecutor(SharedConfig sharedConfig) {\n            super(sharedConfig);\n        }\n\n        /**\n         * Instead of using the default executeParametrized provided by pluginExecutor, this implementation affords an opportunity\n         * also update the datasource and action configuration for pagination and some minor cleanup of the configuration before execution\n         *\n         * @param connection              : This is the connection that is established to the data source. This connection is according\n         *                                to the parameters in Datasource Configuration\n         * @param executeActionDTO        : This is the data structure sent by the client during execute. This contains the params\n         *                                which would be used for substitution\n         * @param datasourceConfiguration : These are the configurations which have been used to create a Datasource from a Plugin\n         * @param actionConfiguration     : These are the configurations which have been used to create an Action from a Datasource.\n         * @return\n         */\n        @Override\n        public Mono<ActionExecutionResult> executeParameterized(APIConnection connection,\n                                                                ExecuteActionDTO executeActionDTO,\n                                                                DatasourceConfiguration datasourceConfiguration,\n                                                                ActionConfiguration actionConfiguration) {\n\n            final List<Property> properties = actionConfiguration.getPluginSpecifiedTemplates();\n            List<Map.Entry<String, String>> parameters = new ArrayList<>();\n\n            // Smartly substitute in actionConfiguration.body and replace all the bindings with values.\n            Boolean smartJsonSubstitution = this.smartSubstitutionUtils.isSmartSubstitutionEnabled(properties);\n            if (TRUE.equals(smartJsonSubstitution)) {\n                // Do smart replacements in JSON body\n                if (actionConfiguration.getBody() != null) {\n\n                    // First extract all the bindings in order\n                    List<String> mustacheKeysInOrder = MustacheHelper.extractMustacheKeysInOrder(actionConfiguration.getBody());\n                    // Replace all the bindings with a ? as expected in a prepared statement.\n                    String updatedBody = MustacheHelper.replaceMustacheWithPlaceholder(actionConfiguration.getBody(), mustacheKeysInOrder);\n\n                    try {\n                        updatedBody = (String) smartSubstitutionOfBindings(updatedBody,\n                                mustacheKeysInOrder,\n                                executeActionDTO.getParams(),\n                                parameters);\n                    } catch (AppsmithPluginException e) {\n                        ActionExecutionResult errorResult = new ActionExecutionResult();\n                        errorResult.setIsExecutionSuccess(false);\n                        errorResult.setErrorInfo(e);\n                        errorResult.setStatusCode(AppsmithPluginError.PLUGIN_ERROR.getAppErrorCode().toString());\n                        return Mono.just(errorResult);\n                    }\n\n                    actionConfiguration.setBody(updatedBody);\n                }\n            }\n\n            prepareConfigurationsForExecution(executeActionDTO, actionConfiguration, datasourceConfiguration);\n\n            // If the action is paginated, update the configurations to update the correct URL.\n            if (actionConfiguration.getPaginationType() != null &&\n                    PaginationType.URL.equals(actionConfiguration.getPaginationType()) &&\n                    executeActionDTO.getPaginationField() != null) {\n                updateDatasourceConfigurationForPagination(actionConfiguration, datasourceConfiguration, executeActionDTO.getPaginationField());\n                updateActionConfigurationForPagination(actionConfiguration, executeActionDTO.getPaginationField());\n            }\n\n            // Filter out any empty headers\n            headerUtils.removeEmptyHeaders(actionConfiguration);\n\n            return this.executeCommon(connection, datasourceConfiguration, actionConfiguration, parameters);\n        }\n\n        public Mono<ActionExecutionResult> executeCommon(APIConnection apiConnection,\n                                                         DatasourceConfiguration datasourceConfiguration,\n                                                         ActionConfiguration actionConfiguration,\n                                                         List<Map.Entry<String, String>> insertedParams) {\n\n            // Initializing object for error condition\n            ActionExecutionResult errorResult = new ActionExecutionResult();\n            initUtils.initializeResponseWithError(errorResult);\n\n            // Set of hint messages that can be returned to the user.\n            Set<String> hintMessages = new HashSet<>();\n\n            // Initializing request URL\n            String url = initUtils.initializeRequestUrl(actionConfiguration, datasourceConfiguration);\n\n            Boolean encodeParamsToggle = headerUtils.isEncodeParamsToggleEnabled(actionConfiguration);\n\n            URI uri;\n            try {\n                uri = uriUtils.createUriWithQueryParams(actionConfiguration, datasourceConfiguration, url,\n                        encodeParamsToggle);\n            } catch (URISyntaxException e) {\n                ActionExecutionRequest actionExecutionRequest =\n                        RequestCaptureFilter.populateRequestFields(actionConfiguration, null, insertedParams, objectMapper);\n                actionExecutionRequest.setUrl(url);\n                errorResult.setBody(AppsmithPluginError.PLUGIN_EXECUTE_ARGUMENT_ERROR.getMessage(e));\n                errorResult.setRequest(actionExecutionRequest);\n                return Mono.just(errorResult);\n            }\n\n            ActionExecutionRequest actionExecutionRequest =\n                    RequestCaptureFilter.populateRequestFields(actionConfiguration, uri, insertedParams, objectMapper);\n\n            WebClient.Builder webClientBuilder = triggerUtils.getWebClientBuilder(actionConfiguration,\n                    datasourceConfiguration);\n            String reqContentType = headerUtils.getRequestContentType(actionConfiguration, datasourceConfiguration);\n\n            /* Check for content type */\n            final String contentTypeError = headerUtils.verifyContentType(actionConfiguration.getHeaders());\n            if (contentTypeError != null) {\n                errorResult.setBody(AppsmithPluginError.PLUGIN_EXECUTE_ARGUMENT_ERROR.getMessage(\"Invalid value for Content-Type.\"));\n                errorResult.setRequest(actionExecutionRequest);\n                return Mono.just(errorResult);\n            }\n\n            HttpMethod httpMethod = actionConfiguration.getHttpMethod();\n            if (httpMethod == null) {\n                errorResult.setBody(AppsmithPluginError.PLUGIN_EXECUTE_ARGUMENT_ERROR.getMessage(\"HTTPMethod must be set.\"));\n                errorResult.setRequest(actionExecutionRequest);\n                return Mono.just(errorResult);\n            }\n\n            final RequestCaptureFilter requestCaptureFilter = new RequestCaptureFilter(objectMapper);\n            Object requestBodyObj = dataUtils.getRequestBodyObject(actionConfiguration, reqContentType,\n                    encodeParamsToggle,\n                    httpMethod);\n            WebClient client = triggerUtils.getWebClient(webClientBuilder, apiConnection, reqContentType, objectMapper,\n                    EXCHANGE_STRATEGIES, requestCaptureFilter);\n\n            /* Triggering the actual REST API call */\n            return triggerUtils.triggerApiCall(client, httpMethod, uri, requestBodyObj, actionExecutionRequest,\n                    objectMapper, hintMessages, errorResult, requestCaptureFilter);\n        }\n\n        private ActionConfiguration updateActionConfigurationForPagination(ActionConfiguration actionConfiguration,\n                                                                           PaginationField paginationField) {\n            if (PaginationField.NEXT.equals(paginationField) || PaginationField.PREV.equals(paginationField)) {\n                actionConfiguration.setPath(\"\");\n                actionConfiguration.setQueryParameters(null);\n            }\n            return actionConfiguration;\n        }\n\n        private DatasourceConfiguration updateDatasourceConfigurationForPagination(ActionConfiguration actionConfiguration,\n                                                                                   DatasourceConfiguration datasourceConfiguration,\n                                                                                   PaginationField paginationField) {\n            if (PaginationField.NEXT.equals(paginationField)) {\n                if (actionConfiguration.getNext() == null) {\n                    datasourceConfiguration.setUrl(null);\n                } else {\n                    datasourceConfiguration.setUrl(URLDecoder.decode(actionConfiguration.getNext(), StandardCharsets.UTF_8));\n                }\n            } else if (PaginationField.PREV.equals(paginationField)) {\n                datasourceConfiguration.setUrl(actionConfiguration.getPrev());\n            }\n            return datasourceConfiguration;\n        }\n\n        @Override\n        public Object substituteValueInInput(int index,\n                                             String binding,\n                                             String value,\n                                             Object input,\n                                             List<Map.Entry<String, String>> insertedParams,\n                                             Object... args) {\n            String jsonBody = (String) input;\n            return DataTypeStringUtils.jsonSmartReplacementPlaceholderWithValue(jsonBody, value, null, insertedParams, null);\n        }\n    }\n}\n"], "filenames": ["app/server/appsmith-interfaces/src/main/java/com/appsmith/external/helpers/restApiUtils/helpers/TriggerUtils.java", "app/server/appsmith-interfaces/src/main/java/com/appsmith/external/helpers/restApiUtils/helpers/URIUtils.java", "app/server/appsmith-interfaces/src/main/java/com/appsmith/util/WebClientUtils.java", "app/server/appsmith-plugins/graphqlPlugin/src/main/java/com/external/plugins/GraphQLPlugin.java", "app/server/appsmith-plugins/restApiPlugin/src/main/java/com/external/plugins/RestApiPlugin.java"], "buggy_code_start_loc": [38, 6, 2, 30, 7], "buggy_code_end_loc": [215, 86, 43, 286, 163], "fixing_code_start_loc": [37, 5, 3, 29, 8], "fixing_code_end_loc": [208, 71, 134, 273, 150], "type": "CWE-918", "message": "Server-Side Request Forgery (SSRF) in GitHub repository appsmithorg/appsmith prior to 1.8.2.", "other": {"cve": {"id": "CVE-2022-4096", "sourceIdentifier": "security@huntr.dev", "published": "2022-11-21T15:15:12.483", "lastModified": "2022-11-23T15:57:42.533", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Server-Side Request Forgery (SSRF) in GitHub repository appsmithorg/appsmith prior to 1.8.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:appsmith:appsmith:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.8.2", "matchCriteriaId": "F0B236E5-47D6-4A18-A72C-A1C6197E2138"}]}]}], "references": [{"url": "https://github.com/appsmithorg/appsmith/commit/769719ccfe667f059fe0b107a19ec9feb90f2e40", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/7969e834-5982-456e-9683-861a7a5e2d22", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/appsmithorg/appsmith/commit/769719ccfe667f059fe0b107a19ec9feb90f2e40"}}