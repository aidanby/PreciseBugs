{"buggy_code": ["3.1.999: 05ca875fb543350795f6709ab7afcbb6e8f5871b\n3.1.0.beta5: e0eb21f7a97c54cfe40eb07b2c5ca53cde7b370a\n3.1.0.beta3: 0f3c612bd1d274ba71362c423f16fd19a32bbd46\n2.9.0.beta3: adef8c76aaeccaeb081a61bdd8ce7ab90ca41538\n2.9.0.beta2: dc2b844e386351c778b097c7a4e0ec65726296ec\n", "import Component from \"@ember/component\";\nimport EmberObject from \"@ember/object\";\nimport { scheduleOnce } from \"@ember/runloop\";\nimport discourseDebounce from \"discourse-common/lib/debounce\";\nimport { iconHTML } from \"discourse-common/lib/icon-library\";\nimport { withPluginApi } from \"discourse/lib/plugin-api\";\nimport { emojiUnescape } from \"discourse/lib/text\";\nimport { escapeExpression } from \"discourse/lib/utilities\";\nimport {\n  ENCRYPT_ACTIVE,\n  getEncryptionStatus,\n  getTopicTitle,\n  hasTopicTitle,\n  putTopicKey,\n  putTopicTitle,\n  syncGetTopicTitle,\n} from \"discourse/plugins/discourse-encrypt/lib/discourse\";\nimport { observes } from \"discourse-common/utils/decorators\";\n\nconst PLUGIN_ID = \"discourse-encrypt\";\n\n/**\n * Decrypts elements that contain topic titles\n *\n * @param {String} containerSelector Item list (container) selector\n * @param {String} elementSelector   Encrypted title element selector\n *                                   If not present, the container is used\n * @param {Boolean} addIcon          Adds \"user-secret\" icon before title\n */\nfunction decryptTopicTitles(\n  containerSelector,\n  elementSelector,\n  addIcon = false\n) {\n  document.querySelectorAll(containerSelector).forEach((element) => {\n    const titleElement = elementSelector\n      ? element.querySelector(elementSelector)\n      : element;\n    if (!titleElement) {\n      return;\n    }\n\n    const topicId = element.dataset.topicId || titleElement.dataset.topicId;\n    if (!topicId || !hasTopicTitle(topicId)) {\n      return;\n    }\n\n    getTopicTitle(topicId)\n      .then((title) => {\n        title = emojiUnescape(escapeExpression(title));\n\n        if (addIcon) {\n          const icon = iconHTML(\"user-secret\", {\n            title: \"encrypt.encrypted_icon_title\",\n            class: \"private-message-glyph\",\n          });\n\n          titleElement.innerHTML = icon + \" \" + title;\n        } else {\n          titleElement.innerHTML = title;\n        }\n      })\n      .catch(() => {});\n  });\n}\n\n/**\n * Replaces PM icon with \"user-secret\" icon\n *\n * @param {String} containerSelector Item list (container) selector\n * @param {String} elementSelector   Encrypted title element selector\n *                                   If not present, the container is used\n * @param {Boolean} iconSelector     Icon container selector\n */\nfunction replaceIcons(containerSelector, elementSelector, iconSelector) {\n  document.querySelectorAll(containerSelector).forEach((element) => {\n    const titleElement = elementSelector\n      ? element.querySelector(elementSelector)\n      : element;\n    if (!titleElement) {\n      return;\n    }\n\n    const topicId = element.dataset.topicId || titleElement.dataset.topicId;\n    if (!topicId || !hasTopicTitle(topicId)) {\n      return;\n    }\n\n    const iconElement = element.querySelector(iconSelector);\n    if (iconElement) {\n      iconElement.innerHTML = iconHTML(\"user-secret\", {\n        title: \"encrypt.encrypted_icon_title\",\n        class: \"private-message-glyph\",\n      });\n    }\n  });\n}\n\nlet registeredComponentHook = false;\n\nexport default {\n  name: \"decrypt-topics\",\n  container: null,\n\n  initialize(container) {\n    const currentUser = container.lookup(\"service:current-user\");\n    if (getEncryptionStatus(currentUser) !== ENCRYPT_ACTIVE) {\n      return;\n    }\n\n    // Save a reference to container to be used by `decryptTopicPage`\n    this.container = container;\n\n    const appEvents = container.lookup(\"service:app-events\");\n    appEvents.on(\"encrypt:status-changed\", this, this.decryptTopicTitles);\n    appEvents.on(\"page:changed\", this, this.decryptTopicPage);\n\n    const self = this;\n    if (!registeredComponentHook) {\n      // Try to decrypt new titles that may appear after rendering a component\n      EmberObject.reopen.call(Component, {\n        didRender() {\n          scheduleOnce(\"afterRender\", self, () => {\n            discourseDebounce(self, self.decryptTopicTitles, 500);\n          });\n          return this._super(...arguments);\n        },\n      });\n      registeredComponentHook = true;\n    }\n\n    withPluginApi(\"0.11.3\", (api) => {\n      // Full-screen notification list topic titles\n      api.reopenWidget(\"default-notification-item\", {\n        description() {\n          if (\n            this.attrs.fancy_title &&\n            this.attrs.topic_id &&\n            this.attrs.topic_key\n          ) {\n            const decrypted = syncGetTopicTitle(this.attrs.topic_id);\n            if (decrypted) {\n              return `<span data-topic-id=\"${\n                this.attrs.topic_id\n              }\">${emojiUnescape(escapeExpression(decrypted))}</span>`;\n            }\n          }\n          return this._super(...arguments);\n        },\n      });\n\n      if (api.registerModelTransformer) {\n        api.registerModelTransformer(\"topic\", async (topics) => {\n          for (const topic of topics) {\n            if (topic.topic_key && topic.encrypted_title) {\n              putTopicKey(topic.id, topic.topic_key);\n              putTopicTitle(topic.id, topic.encrypted_title);\n              try {\n                const decryptedTitle = await getTopicTitle(topic.id);\n                if (decryptedTitle) {\n                  topic.fancy_title = escapeExpression(decryptedTitle);\n                }\n              } catch (err) {\n                // eslint-disable-next-line no-console\n                console.warn(\n                  `Decrypting the title of encrypted message (topicId: ${topic.id}) failed with the following error:`,\n                  err,\n                  err.stack\n                );\n              }\n            }\n          }\n        });\n        api.registerModelTransformer(\"bookmark\", async (bookmarks) => {\n          for (const bookmark of bookmarks) {\n            if (\n              bookmark.topic_id &&\n              bookmark.topic_key &&\n              bookmark.encrypted_title\n            ) {\n              putTopicKey(bookmark.topic_id, bookmark.topic_key);\n              putTopicTitle(bookmark.topic_id, bookmark.encrypted_title);\n              try {\n                const decryptedTitle = await getTopicTitle(bookmark.topic_id);\n                if (decryptedTitle) {\n                  bookmark.title = decryptedTitle;\n                }\n              } catch (err) {\n                // eslint-disable-next-line no-console\n                console.warn(\n                  `Decrypting the title of encrypted message (topicId: ${bookmark.topic_id}) failed with the following error:`,\n                  err,\n                  err.stack\n                );\n              }\n            }\n          }\n        });\n        api.registerModelTransformer(\"notification\", async (notifications) => {\n          for (const notification of notifications) {\n            if (\n              notification.topic_id &&\n              notification.topic_key &&\n              notification.encrypted_title\n            ) {\n              putTopicKey(notification.topic_id, notification.topic_key);\n              putTopicTitle(\n                notification.topic_id,\n                notification.encrypted_title\n              );\n              try {\n                const decryptedTitle = await getTopicTitle(\n                  notification.topic_id\n                );\n                if (decryptedTitle) {\n                  notification.fancy_title = escapeExpression(decryptedTitle);\n                }\n              } catch (err) {\n                // eslint-disable-next-line no-console\n                console.warn(\n                  `Decrypting the title of encrypted message (topicId: ${notification.topic_id}) failed with the following error:`,\n                  err,\n                  err.stack\n                );\n              }\n            }\n          }\n        });\n      }\n\n      api.decorateWidget(\"header:after\", (helper) => {\n        if (\n          helper.widget.state.userVisible ||\n          helper.widget.state.searchVisible\n        ) {\n          discourseDebounce(self, self.decryptTopicTitles, 500);\n        }\n      });\n\n      api.modifyClass(\"controller:topic\", {\n        pluginId: PLUGIN_ID,\n\n        @observes(\"editingTopic\")\n        _editingTopicChanged() {\n          if (this.get(\"editingTopic\")) {\n            const topicId = this.get(\"model.id\");\n\n            getTopicTitle(topicId).then((topicTitle) => {\n              // Update the title stored in buffered state\n              this.buffered.set(\"title\", topicTitle);\n            });\n          }\n        },\n      });\n    });\n  },\n\n  decryptTopicTitles() {\n    // Title in miscellaneous\n    decryptTopicTitles(\"a.raw-topic-link\", null, true);\n    decryptTopicTitles(\"a.topic-link\", \"span\");\n    decryptTopicTitles(\"a.topic-link\", null, true);\n\n    // Title in site header\n    decryptTopicTitles(\"h1.header-title\", \".topic-link\");\n\n    // Title in topic lists\n    decryptTopicTitles(\n      \".topic-list-item, .latest-topic-list-item\",\n      \".title\",\n      true\n    );\n\n    // Replace PM icons\n    replaceIcons(\"h1\", null, \".private-message-glyph-wrapper\");\n    replaceIcons(\"h1\", \".topic-link\", \".private-message-glyph-wrapper\");\n\n    // Decrypt topic controller\n    // This is necessary because sometimes the model is loaded after\n    // page:changed event was triggered.\n    if (\n      !this.container ||\n      this.container.isDestroyed ||\n      this.container.isDestroying\n    ) {\n      return;\n    }\n\n    const { currentRouteName } = this.container.lookup(\"service:router\");\n    this.decryptTopicPage({ currentRouteName });\n  },\n\n  decryptTopicPage(data) {\n    if (!data.currentRouteName?.startsWith(\"topic.\")) {\n      return;\n    }\n\n    if (\n      !this.container ||\n      this.container.isDestroyed ||\n      this.container.isDestroying\n    ) {\n      return;\n    }\n\n    const topicController = this.container.lookup(\"controller:topic\");\n    const topic = topicController.get(\"model\");\n    const topicId = topic.id;\n\n    if (topic?.encrypted_title) {\n      document.querySelector(\".private_message\").classList.add(\"encrypted\");\n    }\n\n    getTopicTitle(topicId).then((topicTitle) => {\n      // Update fancy title stored in model\n      topicController.model.set(\"fancy_title\", topicTitle);\n\n      // Update document title\n      const documentTitle = this.container.lookup(\"service:document-title\");\n      documentTitle.setTitle(\n        documentTitle\n          .getTitle()\n          .replace(topicController.model.title, topicTitle)\n      );\n    });\n  },\n};\n", "import {\n  click,\n  fillIn,\n  triggerKeyEvent,\n  visit,\n  waitUntil,\n} from \"@ember/test-helpers\";\nimport { registerWaiter, unregisterWaiter } from \"@ember/test\";\nimport User from \"discourse/models/user\";\nimport {\n  deleteDb,\n  loadDbIdentity,\n  saveDbIdentity,\n} from \"discourse/plugins/discourse-encrypt/lib/database\";\nimport {\n  ENCRYPT_ACTIVE,\n  ENCRYPT_DISABLED,\n  ENCRYPT_ENABLED,\n  getEncryptionStatus,\n  getIdentity,\n  putTopicTitle,\n  resetEncrypt,\n} from \"discourse/plugins/discourse-encrypt/lib/discourse\";\nimport {\n  encrypt,\n  exportIdentity,\n  exportKey,\n  generateIdentity,\n  generateKey,\n  importIdentity,\n} from \"discourse/plugins/discourse-encrypt/lib/protocol\";\nimport { NOTIFICATION_TYPES } from \"discourse/tests/fixtures/concerns/notification-types\";\nimport userFixtures from \"discourse/tests/fixtures/user-fixtures\";\nimport pretender, {\n  parsePostData,\n  response,\n} from \"discourse/tests/helpers/create-pretender\";\nimport {\n  acceptance,\n  count,\n  exists,\n  query,\n  queryAll,\n  updateCurrentUser,\n} from \"discourse/tests/helpers/qunit-helpers\";\nimport selectKit from \"discourse/tests/helpers/select-kit-helper\";\nimport I18n from \"I18n\";\nimport QUnit, { test } from \"qunit\";\nimport { cloneJSON } from \"discourse-common/lib/object\";\n\n/*\n * Checks if a string is not contained in a string.\n *\n * @param haystack\n * @param needle\n * @param message\n */\nQUnit.assert.notContains = function notContains(haystack, needle, message) {\n  this.pushResult({\n    result: haystack.indexOf(needle) === -1,\n    actual: haystack,\n    expected: \"not to contain \" + needle,\n    message,\n  });\n};\n\n/**\n * @var PASSPHRASE Secret passphrase used for testing purposes.\n */\nconst PASSPHRASE = \"curren7U$er.pa$$Phr4se\";\n\n/**\n * @var PLAINTEXT Constant string that is used to check for plaintext leakage.\n */\nconst PLAINTEXT = \"!PL41N73X7!\";\nconst PLAINTEXT_TITLE = `A new topic ${PLAINTEXT}`;\nconst PLAINTEXT_RAW = `Hello, world! ${PLAINTEXT}\\n`.repeat(42);\n\n/**\n * @var keys User keys.\n */\nconst keys = {};\n\n/**\n * @var globalAssert Global assert instance used to report plaintext leakage.\n */\nlet globalAssert;\n\n/**\n * @var requests Request URLs intercepted by the leak checker.\n */\nlet requests = [];\n\n/**\n * Sets up encryption.\n *\n * @param status\n */\nasync function setEncryptionStatus(status) {\n  const user = User.current();\n\n  // Resetting IndexedDB.\n  try {\n    await deleteDb();\n  } catch (e) {}\n\n  // Generating a new key pair if enabling or creating a dummy one if disabling.\n  let identity = {};\n  let exported = {};\n  let exportedPrivate;\n  if (status !== ENCRYPT_DISABLED) {\n    identity = await generateIdentity();\n    exported = await exportIdentity(identity, PASSPHRASE);\n    exportedPrivate = JSON.stringify({ passphrase: exported.private });\n  }\n\n  // Overwriting server-side fields.\n  user.set(\"encrypt_public\", exported.public);\n  user.set(\"encrypt_private\", exportedPrivate);\n\n  // Setting the appropriate custom fields is not always enough (i.e. if user\n  // navigates to preferences).\n  pretender.get(\"/u/eviltrout.json\", () => {\n    const json = cloneJSON(userFixtures[\"/u/eviltrout.json\"]);\n    json.user.can_edit = true;\n    json.user.encrypt_public = exported.public;\n    json.user.encrypt_private = exportedPrivate;\n    return [200, { \"Content-Type\": \"application/json\" }, json];\n  });\n\n  // Activating encryption on client-side.\n  if (status === ENCRYPT_ACTIVE) {\n    await saveDbIdentity(identity);\n  }\n\n  keys[user.username] = exported.public;\n  return identity;\n}\n\n/**\n * Executes the given function and waits until current encryption status\n * changes or given waiter becomes true.\n *\n * @param statusOrWaiter\n * @param func\n */\nasync function wait(statusOrWaiter, func) {\n  const waiter =\n    typeof statusOrWaiter === \"function\"\n      ? statusOrWaiter\n      : () => getEncryptionStatus(User.current()) === statusOrWaiter;\n\n  try {\n    registerWaiter(waiter);\n    await func();\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error(`Caught exception while waiting: ${e.message}`, e);\n  } finally {\n    unregisterWaiter(waiter);\n  }\n}\n\nfunction setupEncryptTests(needs) {\n  needs.user({\n    can_encrypt: true,\n    encrypt_pms_default: true,\n  });\n\n  needs.hooks.beforeEach(function () {\n    // Hook `XMLHttpRequest` to search for leaked plaintext.\n    XMLHttpRequest.prototype.send_ = XMLHttpRequest.prototype.send;\n    XMLHttpRequest.prototype.send = function (body) {\n      requests.push(this.url);\n      if (body && globalAssert) {\n        globalAssert.notContains(body, PLAINTEXT, \"does not leak plaintext\");\n        globalAssert.notContains(body, PASSPHRASE, \"does not leak passphrase\");\n      }\n      return this.send_(...arguments);\n    };\n\n    resetEncrypt();\n  });\n\n  needs.hooks.afterEach(function () {\n    // Restore `XMLHttpRequest`.\n    XMLHttpRequest.prototype.send = XMLHttpRequest.prototype.send_;\n    delete XMLHttpRequest.prototype.send_;\n\n    globalAssert = null;\n  });\n\n  needs.pretender((server, helper) => {\n    pretender.get(\"/encrypt/user\", (request) => {\n      const resp = {};\n      request.queryParams[\"usernames\"].forEach((u) => (resp[u] = keys[u]));\n      return helper.response(resp);\n    });\n\n    pretender.get(\"/encrypt/posts\", () => {\n      return helper.response({ posts: [], topics: [] });\n    });\n\n    pretender.put(\"/encrypt/post\", () => {\n      return helper.response({});\n    });\n  });\n}\n\nasync function setupEncryptedTopicPretender(server, { identity } = {}) {\n  identity = identity || (await getIdentity());\n  const topicKey = await generateKey();\n  const exportedTopicKey = await exportKey(topicKey, identity.encryptPublic);\n  const encryptedTitle = await encrypt(topicKey, { raw: \"Top Secret Title\" });\n  const encryptedRaw = await encrypt(topicKey, { raw: \"Top Secret Post\" });\n\n  server.get(\"/t/42.json\", () => {\n    return [\n      200,\n      { \"Content-Type\": \"application/json\" },\n      {\n        post_stream: {\n          posts: [\n            {\n              id: 42,\n              name: null,\n              username: \"bar\",\n              avatar_template:\n                \"/letter_avatar_proxy/v4/letter/b/000000/{size}.png\",\n              created_at: \"2020-01-01T12:00:00.000Z\",\n              cooked:\n                \"<p>This is a secret message with end to end encryption. To view it, you must be invited to this topic.</p>\",\n              post_number: 1,\n              post_type: 1,\n              updated_at: \"2020-01-01T12:00:00.000Z\",\n              reply_count: 0,\n              reply_to_post_number: null,\n              quote_count: 0,\n              incoming_link_count: 0,\n              reads: 2,\n              readers_count: 1,\n              score: 0.4,\n              yours: false,\n              topic_id: 42,\n              topic_slug: \"a-secret-message\",\n              display_username: null,\n              primary_group_name: null,\n              primary_group_flair_url: null,\n              primary_group_flair_bg_color: null,\n              primary_group_flair_color: null,\n              version: 1,\n              can_edit: true,\n              can_delete: false,\n              can_recover: false,\n              can_wiki: true,\n              read: true,\n              user_title: null,\n              title_is_group: false,\n              bookmarked: false,\n              actions_summary: [\n                {\n                  id: 2,\n                  can_act: true,\n                },\n                {\n                  id: 3,\n                  can_act: true,\n                },\n                {\n                  id: 4,\n                  can_act: true,\n                },\n                {\n                  id: 8,\n                  can_act: true,\n                },\n                {\n                  id: 6,\n                  can_act: true,\n                },\n                {\n                  id: 7,\n                  can_act: true,\n                },\n              ],\n              moderator: false,\n              admin: true,\n              staff: true,\n              user_id: 2,\n              hidden: false,\n              trust_level: 0,\n              deleted_at: null,\n              user_deleted: false,\n              edit_reason: null,\n              can_view_edit_history: true,\n              wiki: false,\n              reviewable_id: 0,\n              reviewable_score_count: 0,\n              reviewable_score_pending_count: 0,\n              encrypted_raw: encryptedRaw,\n            },\n          ],\n          stream: [42],\n        },\n        timeline_lookup: [[1, 0]],\n        related_messages: [],\n        suggested_topics: [],\n        id: 42,\n        title: \"A secret message\",\n        fancy_title: \"A secret message\",\n        posts_count: 1,\n        created_at: \"2020-01-01T12:00:00.000Z\",\n        views: 2,\n        reply_count: 0,\n        like_count: 0,\n        last_posted_at: \"2020-01-01T12:00:00.000Z\",\n        visible: true,\n        closed: false,\n        archived: false,\n        has_summary: false,\n        archetype: \"private_message\",\n        slug: \"a-secret-message\",\n        category_id: null,\n        word_count: 16,\n        deleted_at: null,\n        user_id: 2,\n        featured_link: null,\n        pinned_globally: false,\n        pinned_at: null,\n        pinned_until: null,\n        image_url: null,\n        slow_mode_seconds: 0,\n        draft: null,\n        draft_key: \"topic_42\",\n        draft_sequence: 0,\n        posted: false,\n        unpinned: null,\n        pinned: false,\n        current_post_number: 1,\n        highest_post_number: 1,\n        last_read_post_number: 1,\n        last_read_post_id: 42,\n        deleted_by: null,\n        has_deleted: false,\n        actions_summary: [\n          {\n            id: 4,\n            count: 0,\n            hidden: false,\n            can_act: true,\n          },\n          {\n            id: 8,\n            count: 0,\n            hidden: false,\n            can_act: true,\n          },\n          {\n            id: 7,\n            count: 0,\n            hidden: false,\n            can_act: true,\n          },\n        ],\n        chunk_size: 20,\n        bookmarked: false,\n        message_archived: false,\n        topic_timer: null,\n        message_bus_last_id: 3,\n        participant_count: 1,\n        pm_with_non_human_user: false,\n        queued_posts_count: 0,\n        show_read_indicator: false,\n        requested_group_name: null,\n        thumbnails: null,\n        slow_mode_enabled_until: null,\n        encrypted_title: encryptedTitle,\n        topic_key: exportedTopicKey,\n        details: {\n          can_edit: true,\n          notification_level: 3,\n          notifications_reason_id: 2,\n          can_move_posts: true,\n          can_delete: true,\n          can_remove_allowed_users: true,\n          can_invite_to: true,\n          can_invite_via_email: true,\n          can_create_post: true,\n          can_reply_as_new_topic: true,\n          can_flag_topic: true,\n          can_convert_topic: true,\n          can_review_topic: true,\n          can_close_topic: true,\n          can_archive_topic: true,\n          can_split_merge_topic: true,\n          can_edit_staff_notes: true,\n          can_toggle_topic_visibility: true,\n          can_pin_unpin_topic: true,\n          can_moderate_category: true,\n          can_remove_self_id: 1,\n          participants: [\n            {\n              id: 2,\n              username: \"bar\",\n              name: null,\n              avatar_template:\n                \"/letter_avatar_proxy/v4/letter/b/000000/{size}.png\",\n              post_count: 1,\n              primary_group_name: null,\n              primary_group_flair_url: null,\n              primary_group_flair_color: null,\n              primary_group_flair_bg_color: null,\n              admin: true,\n              trust_level: 0,\n            },\n          ],\n          allowed_users: [\n            {\n              id: 1,\n              username: \"foo\",\n              name: null,\n              avatar_template:\n                \"/letter_avatar_proxy/v4/letter/f/000000/{size}.png\",\n            },\n            {\n              id: 2,\n              username: \"bar\",\n              name: null,\n              avatar_template:\n                \"/letter_avatar_proxy/v4/letter/b/000000/{size}.png\",\n            },\n          ],\n          created_by: {\n            id: 2,\n            username: \"bar\",\n            name: null,\n            avatar_template:\n              \"/letter_avatar_proxy/v4/letter/b/000000/{size}.png\",\n          },\n          last_poster: {\n            id: 2,\n            username: \"bar\",\n            name: null,\n            avatar_template:\n              \"/letter_avatar_proxy/v4/letter/b/000000/{size}.png\",\n          },\n          allowed_groups: [],\n        },\n        pending_posts: [],\n      },\n    ];\n  });\n}\n\nasync function setupEncryptedSearchResultPretender(server) {\n  const identity = await getIdentity();\n  const topicKey = await generateKey();\n  const exportedKey = await exportKey(topicKey, identity.encryptPublic);\n  const title = \"Top Secret Developer <a> :male_detective:\";\n  const encryptedTitle = await encrypt(topicKey, { raw: title });\n\n  server.get(\"/encrypt/posts\", (request) => {\n    if (request.queryParams[\"term\"]) {\n      return [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        {\n          success: \"OK\",\n          topics: [],\n          posts: [],\n        },\n      ];\n    } else {\n      return [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        {\n          success: \"OK\",\n          topics: [\n            {\n              id: 42,\n              title: \"A secret message\",\n              fancy_title: \"A secret message\",\n              slug: \"a-secret-message\",\n              posts_count: 1,\n              reply_count: 0,\n              highest_post_number: 1,\n              created_at: \"2021-01-01T12:00:00.000Z\",\n              last_posted_at: \"2021-01-01T12:00:00.000Z\",\n              bumped: true,\n              bumped_at: \"2021-01-01T12:00:00.000Z\",\n              archetype: \"private_message\",\n              unseen: false,\n              pinned: false,\n              unpinned: null,\n              visible: true,\n              closed: false,\n              archived: false,\n              bookmarked: null,\n              liked: null,\n              category_id: null,\n              encrypted_title: encryptedTitle,\n              topic_key: exportedKey,\n            },\n          ],\n          posts: [\n            {\n              id: 42,\n              username: \"foo\",\n              avatar_template:\n                \"/letter_avatar_proxy/v4/letter/f/eada6e/{size}.png\",\n              created_at: \"2021-01-01T12:00:00.000Z\",\n              like_count: 0,\n              post_number: 1,\n              topic_id: 42,\n            },\n            {\n              id: 43,\n              username: \"foo\",\n              avatar_template:\n                \"/letter_avatar_proxy/v4/letter/f/eada6e/{size}.png\",\n              created_at: \"2021-01-01T12:00:00.000Z\",\n              like_count: 0,\n              post_number: 2,\n              topic_id: 42,\n            },\n          ],\n        },\n      ];\n    }\n  });\n\n  return { encryptedTitle, exportedKey };\n}\n\nacceptance(\"Encrypt - disabled\", function (needs) {\n  setupEncryptTests(needs);\n\n  needs.hooks.beforeEach(async function () {\n    await setEncryptionStatus(ENCRYPT_DISABLED);\n  });\n\n  test(\"enabling works\", async function (assert) {\n    let ajaxRequested = false;\n    pretender.put(\"/encrypt/keys\", () => {\n      ajaxRequested = true;\n      return [200, { \"Content-Type\": \"application/json\" }, { success: \"OK\" }];\n    });\n\n    await visit(\"/u/eviltrout/preferences/security\");\n    await click(\".encrypt button.btn-primary\");\n    await waitUntil(\n      () => getEncryptionStatus(User.current()) === ENCRYPT_ACTIVE\n    );\n    assert.ok(ajaxRequested, \"AJAX request to save keys was made\");\n\n    const identity = await loadDbIdentity();\n    assert.ok(identity.encryptPublic instanceof CryptoKey);\n    assert.ok(identity.encryptPrivate instanceof CryptoKey);\n    assert.ok(identity.signPublic instanceof CryptoKey);\n    assert.ok(identity.signPrivate instanceof CryptoKey);\n  });\n\n  test(\"encrypt settings visible only if user can encrypt\", async function (assert) {\n    await visit(\"/u/eviltrout/preferences/security\");\n    assert.ok(\n      query(\".encrypt\").innerText.trim().length > 0,\n      \"encrypt settings are visible\"\n    );\n\n    updateCurrentUser({ can_encrypt: false });\n\n    await visit(\"/u/eviltrout/preferences\");\n    await click(\".user-nav__preferences-security a\");\n    assert.strictEqual(\n      query(\".encrypt\").innerText.trim().length,\n      0,\n      \"encrypt settings are not visible\"\n    );\n\n    updateCurrentUser({ can_encrypt: true });\n\n    await visit(\"/u/eviltrout/preferences\");\n    await click(\".user-nav__preferences-security a\");\n    assert.ok(\n      query(\".encrypt\").innerText.trim().length > 0,\n      \"encrypt settings are visible\"\n    );\n  });\n\n  test(\"user preferences connector works for other users\", async function (assert) {\n    pretender.get(\"/u/eviltrout2.json\", () => {\n      const json = cloneJSON(userFixtures[\"/u/eviltrout.json\"]);\n      json.user.id += 1;\n      json.user.can_edit = true;\n      json.user.can_encrypt = true;\n      json.user.encrypt_public = \"encrypted public identity\";\n      return [200, { \"Content-Type\": \"application/json\" }, json];\n    });\n\n    await visit(\"/u/eviltrout2/preferences/security\");\n\n    assert.ok(\n      query(\".user-preferences-security-outlet.encrypt\")\n        .innerText.trim()\n        .includes(I18n.t(\"encrypt.preferences.status_enabled_other\"))\n    );\n  });\n});\n\nacceptance(\"Encrypt - enabled\", function (needs) {\n  setupEncryptTests(needs);\n\n  needs.hooks.beforeEach(async function () {\n    await setEncryptionStatus(ENCRYPT_ENABLED);\n  });\n\n  test(\"activation works\", async function (assert) {\n    await visit(\"/u/eviltrout/preferences/security\");\n    await fillIn(\".encrypt #passphrase\", PASSPHRASE);\n    await click(\".encrypt button.btn-primary\");\n\n    await waitUntil(\n      () => getEncryptionStatus(User.current()) === ENCRYPT_ACTIVE\n    );\n\n    const identity = await loadDbIdentity();\n    assert.ok(identity.encryptPublic instanceof CryptoKey);\n    assert.ok(identity.encryptPrivate instanceof CryptoKey);\n    assert.ok(identity.signPublic instanceof CryptoKey);\n    assert.ok(identity.signPrivate instanceof CryptoKey);\n  });\n\n  test(\"viewing encrypted topic works when just enabled\", async function (assert) {\n    globalAssert = assert;\n\n    const identities = JSON.parse(User.current().encrypt_private);\n    const identity = await importIdentity(identities[\"passphrase\"], PASSPHRASE);\n    await setupEncryptedTopicPretender(pretender, { identity });\n\n    await visit(\"/t/a-secret-message/42\");\n    assert.dom(\".modal.activate-encrypt-modal\").exists();\n  });\n});\n\nacceptance(\"Encrypt - active\", function (needs) {\n  setupEncryptTests(needs);\n\n  needs.hooks.beforeEach(async function () {\n    await setEncryptionStatus(ENCRYPT_ACTIVE);\n  });\n\n  test(\"meta: leak checker works\", async function (assert) {\n    globalAssert = { notContains: () => assert.ok(true) };\n\n    await visit(\"/\");\n    await click(\"#create-topic\");\n    const categoryChooser = selectKit(\".category-chooser\");\n    await categoryChooser.expand();\n    await categoryChooser.selectRowByValue(2);\n\n    await fillIn(\"#reply-title\", `Some hidden message ${PLAINTEXT}`);\n    await fillIn(\".d-editor-input\", PLAINTEXT_RAW);\n\n    requests = [];\n    await click(\"button.create\");\n    assert.true(requests.includes(\"/posts\"));\n  });\n\n  test(\"posting does not leak plaintext\", async function (assert) {\n    globalAssert = assert;\n\n    pretender.get(\"/u/search/users\", () => {\n      return [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        {\n          users: [\n            {\n              username: \"eviltrout\",\n              name: \"eviltrout\",\n              avatar_template: \"/images/avatar.png\",\n            },\n          ],\n        },\n      ];\n    });\n\n    pretender.get(\"/composer_messages/user_not_seen_in_a_while\", () => {\n      return response({});\n    });\n\n    pretender.post(\"/posts\", (request) => {\n      const body = parsePostData(request.requestBody);\n\n      assert.strictEqual(body.raw, I18n.t(\"encrypt.encrypted_post\"));\n      assert.strictEqual(body.title, I18n.t(\"encrypt.encrypted_title\"));\n      assert.strictEqual(body.archetype, \"private_message\");\n      assert.strictEqual(body.target_recipients, \"eviltrout\");\n      assert.strictEqual(body.draft_key, \"new_private_message\");\n      assert.strictEqual(body.is_encrypted, \"true\");\n      assert.ok(body.encrypted_title.startsWith(\"1$\"));\n      assert.ok(body.encrypted_raw.startsWith(\"1$\"));\n      assert.ok(JSON.parse(body.encrypted_keys).eviltrout);\n\n      return [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        { action: \"create_post\", post: { topic_id: 34 } },\n      ];\n    });\n\n    await visit(\"/u/eviltrout/messages\");\n    await click(\".new-private-message\");\n\n    // simulate selecting from autocomplete suggestions\n    const usersSelector = selectKit(\"#private-message-users\");\n    await usersSelector.expand();\n    await usersSelector.fillInFilter(\"evilt\");\n    await usersSelector.selectRowByValue(\"eviltrout\");\n    await usersSelector.collapse();\n\n    requests = [];\n\n    await fillIn(\"#reply-title\", `Some hidden message ${PLAINTEXT}`);\n    await fillIn(\".d-editor-input\", PLAINTEXT_RAW);\n    await waitUntil(() => requests.includes(\"/drafts.json\"));\n\n    requests = [];\n    await click(\"button.create\");\n    assert.true(requests.includes(\"/posts\"));\n    assert.true(requests.includes(\"/encrypt/post\"));\n  });\n\n  test(\"new draft for public topic is not encrypted\", async function (assert) {\n    let assertedTitle, assertedReply;\n    pretender.post(\"/drafts.json\", (request) => {\n      const data = JSON.parse(parsePostData(request.requestBody).data);\n      if (data.title) {\n        assertedTitle = true;\n        assert.strictEqual(data.title, PLAINTEXT_TITLE);\n      }\n      if (data.reply) {\n        assertedReply = true;\n        assert.strictEqual(data.reply, PLAINTEXT_RAW);\n      }\n      return [200, { \"Content-Type\": \"application/json\" }, {}];\n    });\n\n    await visit(\"/\");\n    await click(\"#create-topic\");\n    const categoryChooser = selectKit(\".category-chooser\");\n    await categoryChooser.expand();\n    await categoryChooser.selectRowByValue(2);\n    await fillIn(\"#reply-title\", PLAINTEXT_TITLE);\n    await fillIn(\".d-editor-input\", PLAINTEXT_RAW);\n\n    await wait(\n      () => assertedTitle && assertedReply,\n      () => click(\".toggler\")\n    );\n  });\n\n  test(\"draft for new topics is encrypted\", async function (assert) {\n    let assertedTitle, assertedReply;\n    pretender.post(\"/drafts.json\", (request) => {\n      const data = JSON.parse(parsePostData(request.requestBody).data);\n      if (data.title) {\n        assertedTitle = true;\n        assert.notStrictEqual(data.title, PLAINTEXT_TITLE);\n      }\n      if (data.reply) {\n        assertedReply = true;\n        assert.notStrictEqual(data.reply, PLAINTEXT_RAW);\n      }\n      return [200, { \"Content-Type\": \"application/json\" }, {}];\n    });\n\n    await visit(\"/u/eviltrout/messages\");\n    await click(\".new-private-message\");\n    await fillIn(\"#reply-title\", PLAINTEXT_TITLE);\n    await fillIn(\".d-editor-input\", PLAINTEXT_RAW);\n\n    await wait(\n      () => assertedTitle && assertedReply,\n      () => click(\".toggler\")\n    );\n  });\n\n  test(\"draft for replies is encrypted\", async function (assert) {\n    let assertedReply;\n    pretender.post(\"/drafts.json\", (request) => {\n      const data = JSON.parse(parsePostData(request.requestBody).data);\n      if (data.reply) {\n        assertedReply = true;\n        assert.notStrictEqual(data.reply, PLAINTEXT_RAW);\n      }\n      return [200, { \"Content-Type\": \"application/json\" }, {}];\n    });\n\n    await setupEncryptedTopicPretender(pretender);\n\n    await visit(\"/t/a-secret-message/42\");\n    await click(\".topic-footer-main-buttons .btn-primary.create\");\n    await fillIn(\".d-editor-input\", PLAINTEXT_RAW);\n\n    await wait(\n      () => assertedReply,\n      () => click(\".toggler\")\n    );\n  });\n\n  test(\"deactivation works\", async function (assert) {\n    await visit(\"/u/eviltrout/preferences/security\");\n    await click(\".encrypt button#encrypt-deactivate\");\n\n    await waitUntil(\n      () => getEncryptionStatus(User.current()) === ENCRYPT_ENABLED\n    );\n\n    assert.rejects(loadDbIdentity());\n  });\n\n  test(\"viewing encrypted topic works when active\", async function (assert) {\n    globalAssert = assert;\n\n    await setupEncryptedTopicPretender(pretender);\n\n    await visit(\"/t/a-secret-message/42\");\n\n    assert.strictEqual(\n      query(\".fancy-title\").innerText.trim(),\n      \"Top Secret Title\"\n    );\n    assert.strictEqual(query(\".cooked\").innerText.trim(), \"Top Secret Post\");\n    assert.strictEqual(\n      document.title,\n      \"Top Secret Title - QUnit Discourse Tests\"\n    );\n    assert.ok(exists(\".private_message.encrypted\"), \"encrypted class is added\");\n\n    await click(\".private_message.encrypted h1[data-topic-id] .edit-topic\");\n\n    assert.strictEqual(query(\"#edit-title\").value.trim(), \"Top Secret Title\");\n  });\n\n  test(\"topic titles in notification panel are decrypted\", async function (assert) {\n    const identity = await getIdentity();\n    const topicKey = await generateKey();\n    const exportedKey = await exportKey(topicKey, identity.encryptPublic);\n    const title = \"Top Secret :male_detective:\";\n    const encryptedTitle = await encrypt(topicKey, { raw: title });\n    putTopicTitle(42, title);\n\n    pretender.get(\"/notifications\", () => [\n      200,\n      { \"Content-Type\": \"application/json\" },\n      {\n        notifications: [\n          {\n            id: 42,\n            user_id: 1,\n            notification_type: NOTIFICATION_TYPES.private_message,\n            read: false,\n            created_at: \"2020-01-01T12:12:12.000Z\",\n            post_number: 1,\n            topic_id: 42,\n            fancy_title: \"A Secret Message\",\n            slug: \"a-secret-message\",\n            data: {\n              topic_title: \"A Secret Message\",\n              original_post_id: 42,\n              original_post_type: 1,\n              original_username: \"foo\",\n              revision_number: null,\n              display_username: \"foo\",\n            },\n            encrypted_title: encryptedTitle,\n            topic_key: exportedKey,\n          },\n        ],\n        total_rows_notifications: 1,\n        seen_notification_id: 5,\n        load_more_notifications: \"/notifications?offset=60&username=foo\",\n      },\n    ]);\n\n    await visit(\"/\");\n    await click(\".header-dropdown-toggle.current-user\");\n\n    assert\n      .dom(\".quick-access-panel span[data-topic-id]\")\n      .includesText(\"Top Secret\");\n    assert\n      .dom(\".quick-access-panel span[data-topic-id] img\")\n      .exists({ count: 1 });\n  });\n\n  test(\"encrypted topic titles in experiemental user menu notifications tab are decrypted\", async function (assert) {\n    updateCurrentUser({\n      redesigned_user_menu_enabled: true,\n    });\n    const identity = await getIdentity();\n    const topicKey = await generateKey();\n    const exportedKey = await exportKey(topicKey, identity.encryptPublic);\n    const title = \"Top Secret <a> :male_detective:\";\n    const encryptedTitle = await encrypt(topicKey, { raw: title });\n    putTopicTitle(42, title);\n\n    pretender.get(\"/notifications\", () => [\n      200,\n      { \"Content-Type\": \"application/json\" },\n      {\n        notifications: [\n          {\n            id: 42,\n            user_id: 1,\n            notification_type: NOTIFICATION_TYPES.private_message,\n            read: false,\n            created_at: \"2020-01-01T12:12:12.000Z\",\n            post_number: 1,\n            topic_id: 42,\n            fancy_title: \"A Secret Message\",\n            slug: \"a-secret-message\",\n            data: {\n              topic_title: \"A Secret Message\",\n              original_post_id: 42,\n              original_post_type: 1,\n              original_username: \"foo\",\n              revision_number: null,\n              display_username: \"secret-mailer\",\n            },\n            encrypted_title: encryptedTitle,\n            topic_key: exportedKey,\n          },\n        ],\n        total_rows_notifications: 1,\n        seen_notification_id: 5,\n        load_more_notifications: \"/notifications?offset=60&username=foo\",\n      },\n    ]);\n\n    await visit(\"/\");\n    await click(\".header-dropdown-toggle.current-user\");\n\n    const notifications = queryAll(\n      \"#quick-access-all-notifications ul li.notification\"\n    );\n\n    assert.strictEqual(\n      notifications[0].textContent.replace(/\\s+/g, \" \").trim(),\n      \"secret-mailer Top Secret <a>\",\n      \"message title in the notifications tab is decrypted and rendered safely\"\n    );\n    const emoji = notifications[0].querySelector(\".item-description img.emoji\");\n    assert.strictEqual(\n      emoji.title,\n      \"male_detective\",\n      \"emoji in encrypted message title in the notifications tab is rendered correctly\"\n    );\n  });\n\n  test(\"encrypted topic titles in experiemental user menu bookmarks tab are decrypted\", async function (assert) {\n    updateCurrentUser({\n      redesigned_user_menu_enabled: true,\n    });\n    const identity = await getIdentity();\n    const topicKey = await generateKey();\n    const exportedKey = await exportKey(topicKey, identity.encryptPublic);\n    const title = \"Top Secret <a> :male_detective:\";\n    const encryptedTitle = await encrypt(topicKey, { raw: title });\n    putTopicTitle(8223, title);\n\n    pretender.get(\"/u/eviltrout/user-menu-bookmarks\", () => [\n      200,\n      { \"Content-Type\": \"application/json\" },\n      {\n        notifications: [],\n        bookmarks: [\n          {\n            id: 18207,\n            created_at: \"2022-08-25T21:19:09.646Z\",\n            updated_at: \"2022-08-25T21:19:09.646Z\",\n            name: \"\",\n            reminder_at: null,\n            pinned: false,\n            title: \"A secret message\",\n            fancy_title: \"A secret message\",\n            excerpt:\n              \"This is a secret message with end to end encryption. To view it, you must be invited to this topic.\",\n            bookmarkable_id: 84390,\n            bookmarkable_type: \"Post\",\n            bookmarkable_url:\n              \"https://local.discourse.org/t/a-secret-message/8223/1\",\n            tags: [],\n            tags_descriptions: {},\n            topic_id: 8223,\n            linked_post_number: 1,\n            deleted: false,\n            hidden: false,\n            category_id: null,\n            closed: false,\n            archived: false,\n            archetype: \"private_message\",\n            highest_post_number: 1,\n            bumped_at: \"2022-08-25T08:53:01.491Z\",\n            slug: \"a-secret-message\",\n            encrypted_title: encryptedTitle,\n            topic_key: exportedKey,\n            user: {\n              id: 1500,\n              username: \"top-sekret-man\",\n              avatar_template: \"/user_avatar/localhost/nat/{size}/515078_2.png\",\n            },\n          },\n        ],\n      },\n    ]);\n\n    await visit(\"/\");\n    await click(\".header-dropdown-toggle.current-user\");\n    await click(\"#user-menu-button-bookmarks\");\n\n    const bookmarks = queryAll(\"#quick-access-bookmarks ul li.bookmark\");\n\n    assert.strictEqual(\n      bookmarks[0].textContent.replace(/\\s+/g, \" \").trim(),\n      \"top-sekret-man Top Secret <a>\",\n      \"message title in the bookmarks tab is decrypted and rendered safely\"\n    );\n    const emoji = bookmarks[0].querySelector(\".item-description img.emoji\");\n    assert.strictEqual(\n      emoji.title,\n      \"male_detective\",\n      \"emoji in encrypted message title in the bookmarks tab is rendered correctly\"\n    );\n  });\n\n  test(\"encrypted topic titles in experiemental user menu messages tab are decrypted\", async function (assert) {\n    updateCurrentUser({\n      redesigned_user_menu_enabled: true,\n      can_send_private_messages: true,\n    });\n    const identity = await getIdentity();\n    const topicKey = await generateKey();\n    const exportedKey = await exportKey(topicKey, identity.encryptPublic);\n    const title = \"Top Secret <a> :male_detective:\";\n    const encryptedTitle = await encrypt(topicKey, { raw: title });\n    putTopicTitle(127, title);\n\n    pretender.get(\"/u/eviltrout/user-menu-private-messages\", () => [\n      200,\n      { \"Content-Type\": \"application/json\" },\n      {\n        unread_notifications: [],\n        read_notifications: [],\n        topics: [\n          {\n            id: 127,\n            title: \"A secret message\",\n            fancy_title: \"A secret message\",\n            slug: \"a-secret-message\",\n            posts_count: 1,\n            reply_count: 0,\n            highest_post_number: 2,\n            image_url: null,\n            created_at: \"2019-07-26T01:29:24.008Z\",\n            last_posted_at: \"2019-07-26T01:29:24.177Z\",\n            bumped: true,\n            bumped_at: \"2019-07-26T01:29:24.177Z\",\n            unseen: false,\n            last_read_post_number: 2,\n            unread_posts: 0,\n            pinned: false,\n            unpinned: null,\n            visible: true,\n            closed: false,\n            archived: false,\n            notification_level: 3,\n            bookmarked: false,\n            bookmarks: [],\n            liked: false,\n            views: 5,\n            like_count: 0,\n            has_summary: false,\n            archetype: \"private_message\",\n            last_poster_username: \"detective\",\n            category_id: null,\n            pinned_globally: false,\n            featured_link: null,\n            posters: [\n              {\n                extras: \"latest single\",\n                description: \"Original Poster, Most Recent Poster\",\n                user_id: 13,\n                primary_group_id: null,\n              },\n            ],\n            participants: [\n              {\n                extras: \"latest\",\n                description: null,\n                user_id: 13,\n                primary_group_id: null,\n              },\n            ],\n            encrypted_title: encryptedTitle,\n            topic_key: exportedKey,\n          },\n        ],\n      },\n    ]);\n\n    await visit(\"/\");\n    await click(\".header-dropdown-toggle.current-user\");\n    await click(\"#user-menu-button-messages\");\n\n    const messages = queryAll(\"#quick-access-messages ul li.message\");\n    assert.strictEqual(messages.length, 1);\n\n    assert.strictEqual(\n      messages[0].textContent.replace(/\\s+/g, \" \").trim(),\n      \"detective Top Secret <a>\",\n      \"message title in the messages tab is decrypted and rendered safely\"\n    );\n    const emoji = messages[0].querySelector(\".item-description img.emoji\");\n    assert.strictEqual(\n      emoji.title,\n      \"male_detective\",\n      \"emoji in encrypted message title in the messages tab is rendered correctly\"\n    );\n  });\n\n  test(\"searching in messages with filters\", async function (assert) {\n    pretender.get(\"/search/query\", (request) => {\n      // return only one result for PM search\n      return [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        {\n          posts: [\n            {\n              id: 3833,\n              name: \"Bill Dudney\",\n              username: \"bdudney\",\n              avatar_template:\n                \"/user_avatar/meta.discourse.org/bdudney/{size}/8343_1.png\",\n              uploaded_avatar_id: 8343,\n              created_at: \"2013-02-07T17:46:57.469Z\",\n              cooked:\n                \"<p>I've gotten vagrant up and running with a development environment but it's taking forever to load.</p>\\n\\n<p>For example <a href=\\\"http://192.168.10.200:3000/\\\" rel=\\\"nofollow\\\">http://192.168.10.200:3000/</a> takes tens of seconds to load.</p>\\n\\n<p>I'm running the whole stack on a new rMBP with OS X 10.8.2.</p>\\n\\n<p>Any ideas of what I've done wrong? Or is this just a function of being on the bleeding edge?</p>\\n\\n<p>Thanks,</p>\\n\\n<p>-bd</p>\",\n              post_number: 1,\n              post_type: 1,\n              updated_at: \"2013-02-07T17:46:57.469Z\",\n              like_count: 0,\n              reply_count: 1,\n              reply_to_post_number: null,\n              quote_count: 0,\n              incoming_link_count: 4422,\n              reads: 327,\n              score: 21978.4,\n              yours: false,\n              topic_id: 2179,\n              topic_slug: \"development-mode-super-slow\",\n              display_username: \"Bill Dudney\",\n              primary_group_name: null,\n              version: 2,\n              can_edit: false,\n              can_delete: false,\n              can_recover: false,\n              user_title: null,\n              actions_summary: [\n                {\n                  id: 2,\n                  count: 0,\n                  hidden: false,\n                  can_act: false,\n                },\n                {\n                  id: 3,\n                  count: 0,\n                  hidden: false,\n                  can_act: false,\n                },\n                {\n                  id: 4,\n                  count: 0,\n                  hidden: false,\n                  can_act: false,\n                },\n                {\n                  id: 5,\n                  count: 0,\n                  hidden: true,\n                  can_act: false,\n                },\n                {\n                  id: 6,\n                  count: 0,\n                  hidden: false,\n                  can_act: false,\n                },\n                {\n                  id: 7,\n                  count: 0,\n                  hidden: false,\n                  can_act: false,\n                },\n                {\n                  id: 8,\n                  count: 0,\n                  hidden: false,\n                  can_act: false,\n                },\n              ],\n              moderator: false,\n              admin: false,\n              staff: false,\n              user_id: 1828,\n              hidden: false,\n              hidden_reason_id: null,\n              trust_level: 1,\n              deleted_at: null,\n              user_deleted: false,\n              edit_reason: null,\n              can_view_edit_history: true,\n              wiki: false,\n              blurb:\n                \"I've gotten vagrant up and running with a development environment but it's taking forever to load. For example http://192.168.10.200:3000/ takes...\",\n            },\n          ],\n          topics: [\n            {\n              id: 2179,\n              title: \"Development mode super slow\",\n              fancy_title: \"Development mode super slow\",\n              slug: \"development-mode-super-slow\",\n              posts_count: 72,\n              reply_count: 53,\n              highest_post_number: 73,\n              image_url: null,\n              created_at: \"2013-02-07T17:46:57.262Z\",\n              last_posted_at: \"2015-04-17T08:08:26.671Z\",\n              bumped: true,\n              bumped_at: \"2015-04-17T08:08:26.671Z\",\n              unseen: false,\n              pinned: false,\n              unpinned: null,\n              visible: true,\n              closed: false,\n              archived: false,\n              bookmarked: null,\n              liked: null,\n              views: 9538,\n              like_count: 45,\n              has_summary: true,\n              archetype: \"regular\",\n              last_poster_username: null,\n              category_id: 7,\n              pinned_globally: false,\n              posters: [],\n              tags: [\"dev\", \"slow\"],\n              tags_descriptions: {\n                dev: \"dev description\",\n                slow: \"slow description\",\n              },\n            },\n          ],\n          grouped_search_result: {\n            term: request.queryParams.term,\n            type_filter: \"private_messages\",\n            post_ids: [3833],\n          },\n        },\n      ];\n    });\n\n    await setupEncryptedSearchResultPretender(pretender);\n\n    await visit(\"/\");\n    await click(\"#search-button\");\n\n    await fillIn(\"#search-term\", \"dev\");\n    await triggerKeyEvent(\".search-menu\", \"keydown\", \"ArrowDown\");\n    await click(document.activeElement);\n\n    const item = \".search-menu .results .item\";\n    assert.strictEqual(\n      query(`${item} [data-topic-id='2179']`)?.innerText?.trim(),\n      \"Development mode super slow\"\n    );\n    assert.strictEqual(\n      query(`${item} [data-topic-id='42']`)?.innerText?.trim(),\n      \"Top Secret Developer\"\n    );\n\n    await fillIn(\"#search-term\", \"group_messages:staff dev\");\n    await triggerKeyEvent(\".search-menu\", \"keydown\", \"ArrowDown\");\n    await click(document.activeElement);\n\n    assert.strictEqual(\n      query(`${item} [data-topic-id='2179']`)?.innerText?.trim(),\n      \"Development mode super slow\"\n    );\n    assert.notOk(exists(`${item} [data-topic-id='42']`));\n\n    await fillIn(\"#search-term\", \"in:messages after:2022-11-01 dev\");\n    await triggerKeyEvent(\".search-menu\", \"keydown\", \"ArrowDown\");\n    await click(document.activeElement);\n\n    assert.strictEqual(\n      query(`${item} [data-topic-id='2179']`)?.innerText?.trim(),\n      \"Development mode super slow\"\n    );\n    assert.notOk(exists(`${item} [data-topic-id='42']`));\n  });\n\n  test(\"searching in encrypted topic titles\", async function (assert) {\n    pretender.get(\"/search\", (request) => {\n      return [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        {\n          posts: [],\n          topics: [],\n          grouped_search_result: {\n            term: request.queryParams.q,\n            type_filter: \"private_messages\",\n            post_ids: [],\n          },\n        },\n      ];\n    });\n\n    const result = await setupEncryptedSearchResultPretender(pretender);\n\n    await visit(\"/search?q=secret+in:personal\");\n    assert.strictEqual(count(\".fps-result\"), 1);\n    assert.strictEqual(\n      query(\".fps-result .topic-title\").innerText.trim(),\n      \"Top Secret Developer\"\n    );\n\n    pretender.get(\"/search\", (request) => {\n      return [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        {\n          posts: [\n            {\n              id: 42,\n              username: \"foo\",\n              avatar_template:\n                \"/letter_avatar_proxy/v4/letter/f/eada6e/{size}.png\",\n              created_at: \"2021-01-01T12:00:00.000Z\",\n              like_count: 0,\n              blurb:\n                'This is a <span class=\"search-highlight\">secret</span> message with end to end encryption. To view it, you must be invited to this topic...',\n              post_number: 1,\n              topic_title_headline:\n                'A <span class=\"search-highlight\">secret</span> message',\n              topic_id: 42,\n            },\n          ],\n          topics: [\n            {\n              id: 42,\n              title: \"A secret message\",\n              fancy_title: \"A secret message\",\n              slug: \"a-secret-message\",\n              posts_count: 1,\n              reply_count: 0,\n              highest_post_number: 1,\n              created_at: \"2021-01-01T12:00:00.000Z\",\n              last_posted_at: \"2021-01-01T12:00:00.000Z\",\n              bumped: true,\n              bumped_at: \"2021-01-01T12:00:00.000Z\",\n              archetype: \"private_message\",\n              unseen: false,\n              last_read_post_number: 1,\n              unread: 0,\n              new_posts: 0,\n              pinned: false,\n              unpinned: null,\n              visible: true,\n              closed: false,\n              archived: false,\n              notification_level: 3,\n              bookmarked: false,\n              liked: false,\n              category_id: null,\n              encrypted_title: result.encryptedTitle,\n              topic_key: result.exportedKey,\n            },\n          ],\n          users: [],\n          categories: [],\n          tags: [],\n          groups: [],\n          grouped_search_result: {\n            more_posts: null,\n            more_users: null,\n            more_categories: null,\n            term: request.queryParams.q,\n            search_log_id: 42,\n            more_full_page_results: null,\n            can_create_topic: true,\n            error: null,\n            type_filter: \"private_messages\",\n            post_ids: [42],\n            user_ids: [],\n            category_ids: [],\n            tag_ids: [],\n            group_ids: [],\n          },\n        },\n      ];\n    });\n\n    await visit(\"/search?q=secret++in:personal\");\n    assert.strictEqual(count(\".fps-result\"), 1);\n    assert.strictEqual(\n      query(\".fps-result .topic-title\").innerText.trim(),\n      \"Top Secret Developer\"\n    );\n  });\n\n  test(\"searching works when user has no encrypted topics\", async function (assert) {\n    pretender.get(\"/search\", (request) => {\n      return [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        {\n          posts: [],\n          topics: [],\n          grouped_search_result: {\n            term: request.queryParams.q,\n            type_filter: \"private_messages\",\n            post_ids: [],\n          },\n        },\n      ];\n    });\n\n    pretender.get(\"/encrypt/posts\", () => {\n      return [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        {\n          success: \"OK\",\n          topics: [],\n          posts: [],\n        },\n      ];\n    });\n\n    await visit(\"/search?q=nothing+in:personal\");\n    assert.strictEqual(count(\".fps-result\"), 0);\n  });\n\n  test(\"searching in bookmarks\", async function (assert) {\n    const identity = await getIdentity();\n\n    const topicKey = await generateKey();\n    const exportedTopicKey = await exportKey(topicKey, identity.encryptPublic);\n    const encryptedTitle = await encrypt(topicKey, { raw: \"Top Secret Title\" });\n\n    const topicKey2 = await generateKey();\n    const exportedTopicKey2 = await exportKey(\n      topicKey2,\n      identity.encryptPublic\n    );\n    const encryptedTitle2 = await encrypt(topicKey2, { raw: \"Not a Secret\" });\n\n    pretender.get(\"/u/eviltrout/bookmarks.json\", (request) => {\n      if (request.queryParams.q) {\n        return [\n          200,\n          { \"Content-Type\": \"application/json\" },\n          {\n            bookmarks: [],\n          },\n        ];\n      }\n\n      return [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        {\n          user_bookmark_list: {\n            more_bookmarks_url: \"/u/eviltrout/bookmarks.json?page=1\",\n            bookmarks: [\n              {\n                excerpt: \"\",\n                id: 42,\n                created_at: \"2020-01-01T12:00:00.000Z\",\n                updated_at: \"2020-01-01T12:00:00.000Z\",\n                topic_id: 42,\n                linked_post_number: 1,\n                bookmarkable_id: 42,\n                bookmarkable_type: \"Post\",\n                name: null,\n                reminder_at: null,\n                pinned: false,\n                title: \"A secret message\",\n                fancy_title: \"A secret message\",\n                deleted: false,\n                hidden: false,\n                category_id: null,\n                closed: false,\n                archived: false,\n                archetype: \"private_message\",\n                highest_post_number: 1,\n                bumped_at: \"2020-01-01T12:00:00.000Z\",\n                slug: \"a-secret-message\",\n                post_user_username: \"foo\",\n                post_user_avatar_template:\n                  \"/letter_avatar_proxy/v4/letter/f/eada6e/{size}.png\",\n                post_user_name: null,\n                encrypted_title: encryptedTitle,\n                topic_key: exportedTopicKey,\n              },\n              {\n                excerpt: \"\",\n                id: 43,\n                created_at: \"2020-01-01T12:00:00.000Z\",\n                updated_at: \"2020-01-01T12:00:00.000Z\",\n                topic_id: 43,\n                linked_post_number: 1,\n                bookmarkable_id: 43,\n                bookmarkable_type: \"Post\",\n                name: null,\n                reminder_at: null,\n                pinned: false,\n                title: \"A secret message\",\n                fancy_title: \"A secret message\",\n                deleted: false,\n                hidden: false,\n                category_id: null,\n                closed: false,\n                archived: false,\n                archetype: \"private_message\",\n                highest_post_number: 1,\n                bumped_at: \"2020-01-01T12:00:00.000Z\",\n                slug: \"a-secret-message\",\n                post_user_username: \"foo\",\n                post_user_avatar_template:\n                  \"/letter_avatar_proxy/v4/letter/f/eada6e/{size}.png\",\n                post_user_name: null,\n                encrypted_title: encryptedTitle2,\n                topic_key: exportedTopicKey2,\n              },\n            ],\n          },\n        },\n      ];\n    });\n\n    await visit(\"/u/eviltrout/activity/bookmarks\");\n    await visit(\"/u/eviltrout/activity/bookmarks\"); // extra wait\n\n    assert.strictEqual(count(\".bookmark-list-item\"), 2);\n    assert.strictEqual(\n      queryAll(\".bookmark-list-item .title\")[0].innerText.trim(),\n      \"Top Secret Title\"\n    );\n    assert.strictEqual(\n      queryAll(\".bookmark-list-item .title\")[1].innerText.trim(),\n      \"Not a Secret\"\n    );\n\n    await visit(\"/\");\n    await visit(\"/u/eviltrout/activity/bookmarks?q=Top\");\n\n    assert.strictEqual(count(\".bookmark-list-item\"), 1);\n    assert.strictEqual(\n      queryAll(\".bookmark-list-item .title\")[0].innerText.trim(),\n      \"Top Secret Title\"\n    );\n  });\n});\n"], "fixing_code": ["3.1.0.beta5: e0eb21f7a97c54cfe40eb07b2c5ca53cde7b370a\n3.1.0.beta3: 0f3c612bd1d274ba71362c423f16fd19a32bbd46\n2.9.0.beta3: adef8c76aaeccaeb081a61bdd8ce7ab90ca41538\n2.9.0.beta2: dc2b844e386351c778b097c7a4e0ec65726296ec\n", "import Component from \"@ember/component\";\nimport EmberObject from \"@ember/object\";\nimport { scheduleOnce } from \"@ember/runloop\";\nimport discourseDebounce from \"discourse-common/lib/debounce\";\nimport { iconHTML } from \"discourse-common/lib/icon-library\";\nimport { withPluginApi } from \"discourse/lib/plugin-api\";\nimport { emojiUnescape } from \"discourse/lib/text\";\nimport { escapeExpression } from \"discourse/lib/utilities\";\nimport {\n  ENCRYPT_ACTIVE,\n  getEncryptionStatus,\n  getTopicTitle,\n  hasTopicTitle,\n  putTopicKey,\n  putTopicTitle,\n  syncGetTopicTitle,\n} from \"discourse/plugins/discourse-encrypt/lib/discourse\";\nimport { observes } from \"discourse-common/utils/decorators\";\n\nconst PLUGIN_ID = \"discourse-encrypt\";\n\n/**\n * Decrypts elements that contain topic titles\n *\n * @param {String} containerSelector Item list (container) selector\n * @param {String} elementSelector   Encrypted title element selector\n *                                   If not present, the container is used\n * @param {Boolean} addIcon          Adds \"user-secret\" icon before title\n */\nfunction decryptTopicTitles(\n  containerSelector,\n  elementSelector,\n  addIcon = false\n) {\n  document.querySelectorAll(containerSelector).forEach((element) => {\n    const titleElement = elementSelector\n      ? element.querySelector(elementSelector)\n      : element;\n    if (!titleElement) {\n      return;\n    }\n\n    const topicId = element.dataset.topicId || titleElement.dataset.topicId;\n    if (!topicId || !hasTopicTitle(topicId)) {\n      return;\n    }\n\n    getTopicTitle(topicId)\n      .then((title) => {\n        title = emojiUnescape(escapeExpression(title));\n\n        if (addIcon) {\n          const icon = iconHTML(\"user-secret\", {\n            title: \"encrypt.encrypted_icon_title\",\n            class: \"private-message-glyph\",\n          });\n\n          titleElement.innerHTML = icon + \" \" + title;\n        } else {\n          titleElement.innerHTML = title;\n        }\n      })\n      .catch(() => {});\n  });\n}\n\n/**\n * Replaces PM icon with \"user-secret\" icon\n *\n * @param {String} containerSelector Item list (container) selector\n * @param {String} elementSelector   Encrypted title element selector\n *                                   If not present, the container is used\n * @param {Boolean} iconSelector     Icon container selector\n */\nfunction replaceIcons(containerSelector, elementSelector, iconSelector) {\n  document.querySelectorAll(containerSelector).forEach((element) => {\n    const titleElement = elementSelector\n      ? element.querySelector(elementSelector)\n      : element;\n    if (!titleElement) {\n      return;\n    }\n\n    const topicId = element.dataset.topicId || titleElement.dataset.topicId;\n    if (!topicId || !hasTopicTitle(topicId)) {\n      return;\n    }\n\n    const iconElement = element.querySelector(iconSelector);\n    if (iconElement) {\n      iconElement.innerHTML = iconHTML(\"user-secret\", {\n        title: \"encrypt.encrypted_icon_title\",\n        class: \"private-message-glyph\",\n      });\n    }\n  });\n}\n\nlet registeredComponentHook = false;\n\nexport default {\n  name: \"decrypt-topics\",\n  container: null,\n\n  initialize(container) {\n    const currentUser = container.lookup(\"service:current-user\");\n    if (getEncryptionStatus(currentUser) !== ENCRYPT_ACTIVE) {\n      return;\n    }\n\n    // Save a reference to container to be used by `decryptTopicPage`\n    this.container = container;\n\n    const appEvents = container.lookup(\"service:app-events\");\n    appEvents.on(\"encrypt:status-changed\", this, this.decryptTopicTitles);\n    appEvents.on(\"page:changed\", this, this.decryptTopicPage);\n\n    const self = this;\n    if (!registeredComponentHook) {\n      // Try to decrypt new titles that may appear after rendering a component\n      EmberObject.reopen.call(Component, {\n        didRender() {\n          scheduleOnce(\"afterRender\", self, () => {\n            discourseDebounce(self, self.decryptTopicTitles, 500);\n          });\n          return this._super(...arguments);\n        },\n      });\n      registeredComponentHook = true;\n    }\n\n    withPluginApi(\"0.11.3\", (api) => {\n      // Full-screen notification list topic titles\n      api.reopenWidget(\"default-notification-item\", {\n        description() {\n          if (\n            this.attrs.fancy_title &&\n            this.attrs.topic_id &&\n            this.attrs.topic_key\n          ) {\n            const decrypted = syncGetTopicTitle(this.attrs.topic_id);\n            if (decrypted) {\n              return `<span data-topic-id=\"${\n                this.attrs.topic_id\n              }\">${emojiUnescape(escapeExpression(decrypted))}</span>`;\n            }\n          }\n          return this._super(...arguments);\n        },\n      });\n\n      if (api.registerModelTransformer) {\n        api.registerModelTransformer(\"topic\", async (topics) => {\n          for (const topic of topics) {\n            if (topic.topic_key && topic.encrypted_title) {\n              putTopicKey(topic.id, topic.topic_key);\n              putTopicTitle(topic.id, topic.encrypted_title);\n              try {\n                const decryptedTitle = await getTopicTitle(topic.id);\n                if (decryptedTitle) {\n                  topic.fancy_title = escapeExpression(decryptedTitle);\n                }\n              } catch (err) {\n                // eslint-disable-next-line no-console\n                console.warn(\n                  `Decrypting the title of encrypted message (topicId: ${topic.id}) failed with the following error:`,\n                  err,\n                  err.stack\n                );\n              }\n            }\n          }\n        });\n        api.registerModelTransformer(\"bookmark\", async (bookmarks) => {\n          for (const bookmark of bookmarks) {\n            if (\n              bookmark.topic_id &&\n              bookmark.topic_key &&\n              bookmark.encrypted_title\n            ) {\n              putTopicKey(bookmark.topic_id, bookmark.topic_key);\n              putTopicTitle(bookmark.topic_id, bookmark.encrypted_title);\n              try {\n                const decryptedTitle = await getTopicTitle(bookmark.topic_id);\n                if (decryptedTitle) {\n                  bookmark.title = decryptedTitle;\n                }\n              } catch (err) {\n                // eslint-disable-next-line no-console\n                console.warn(\n                  `Decrypting the title of encrypted message (topicId: ${bookmark.topic_id}) failed with the following error:`,\n                  err,\n                  err.stack\n                );\n              }\n            }\n          }\n        });\n        api.registerModelTransformer(\"notification\", async (notifications) => {\n          for (const notification of notifications) {\n            if (\n              notification.topic_id &&\n              notification.topic_key &&\n              notification.encrypted_title\n            ) {\n              putTopicKey(notification.topic_id, notification.topic_key);\n              putTopicTitle(\n                notification.topic_id,\n                notification.encrypted_title\n              );\n              try {\n                const decryptedTitle = await getTopicTitle(\n                  notification.topic_id\n                );\n                if (decryptedTitle) {\n                  notification.fancy_title = escapeExpression(decryptedTitle);\n                }\n              } catch (err) {\n                // eslint-disable-next-line no-console\n                console.warn(\n                  `Decrypting the title of encrypted message (topicId: ${notification.topic_id}) failed with the following error:`,\n                  err,\n                  err.stack\n                );\n              }\n            }\n          }\n        });\n      }\n\n      api.decorateWidget(\"header:after\", (helper) => {\n        if (\n          helper.widget.state.userVisible ||\n          helper.widget.state.searchVisible\n        ) {\n          discourseDebounce(self, self.decryptTopicTitles, 500);\n        }\n      });\n\n      api.modifyClass(\"controller:topic\", {\n        pluginId: PLUGIN_ID,\n\n        @observes(\"editingTopic\")\n        _editingTopicChanged() {\n          if (this.get(\"editingTopic\")) {\n            const topicId = this.get(\"model.id\");\n\n            getTopicTitle(topicId).then((topicTitle) => {\n              // Update the title stored in buffered state\n              this.buffered.set(\"title\", topicTitle);\n            });\n          }\n        },\n      });\n    });\n  },\n\n  decryptTopicTitles() {\n    // Title in miscellaneous\n    decryptTopicTitles(\"a.raw-topic-link\", null, true);\n    decryptTopicTitles(\"a.topic-link\", \"span\");\n    decryptTopicTitles(\"a.topic-link\", null, true);\n\n    // Title in site header\n    decryptTopicTitles(\"h1.header-title\", \".topic-link\");\n\n    // Title in topic lists\n    decryptTopicTitles(\n      \".topic-list-item, .latest-topic-list-item\",\n      \".title\",\n      true\n    );\n\n    // Replace PM icons\n    replaceIcons(\"h1\", null, \".private-message-glyph-wrapper\");\n    replaceIcons(\"h1\", \".topic-link\", \".private-message-glyph-wrapper\");\n\n    // Decrypt topic controller\n    // This is necessary because sometimes the model is loaded after\n    // page:changed event was triggered.\n    if (\n      !this.container ||\n      this.container.isDestroyed ||\n      this.container.isDestroying\n    ) {\n      return;\n    }\n\n    const { currentRouteName } = this.container.lookup(\"service:router\");\n    this.decryptTopicPage({ currentRouteName });\n  },\n\n  decryptTopicPage(data) {\n    if (!data.currentRouteName?.startsWith(\"topic.\")) {\n      return;\n    }\n\n    if (\n      !this.container ||\n      this.container.isDestroyed ||\n      this.container.isDestroying\n    ) {\n      return;\n    }\n\n    const topicController = this.container.lookup(\"controller:topic\");\n    const topic = topicController.get(\"model\");\n    const topicId = topic.id;\n\n    if (topic?.encrypted_title) {\n      document.querySelector(\".private_message\").classList.add(\"encrypted\");\n    }\n\n    getTopicTitle(topicId).then((topicTitle) => {\n      // Update fancy title stored in model\n      topicController.model.set(\"fancy_title\", escapeExpression(topicTitle));\n\n      // Update document title\n      const documentTitle = this.container.lookup(\"service:document-title\");\n      documentTitle.setTitle(\n        documentTitle\n          .getTitle()\n          .replace(topicController.model.title, topicTitle)\n      );\n    });\n  },\n};\n", "import {\n  click,\n  fillIn,\n  triggerKeyEvent,\n  visit,\n  waitUntil,\n} from \"@ember/test-helpers\";\nimport { registerWaiter, unregisterWaiter } from \"@ember/test\";\nimport User from \"discourse/models/user\";\nimport {\n  deleteDb,\n  loadDbIdentity,\n  saveDbIdentity,\n} from \"discourse/plugins/discourse-encrypt/lib/database\";\nimport {\n  ENCRYPT_ACTIVE,\n  ENCRYPT_DISABLED,\n  ENCRYPT_ENABLED,\n  getEncryptionStatus,\n  getIdentity,\n  putTopicTitle,\n  resetEncrypt,\n} from \"discourse/plugins/discourse-encrypt/lib/discourse\";\nimport {\n  encrypt,\n  exportIdentity,\n  exportKey,\n  generateIdentity,\n  generateKey,\n  importIdentity,\n} from \"discourse/plugins/discourse-encrypt/lib/protocol\";\nimport { NOTIFICATION_TYPES } from \"discourse/tests/fixtures/concerns/notification-types\";\nimport userFixtures from \"discourse/tests/fixtures/user-fixtures\";\nimport pretender, {\n  parsePostData,\n  response,\n} from \"discourse/tests/helpers/create-pretender\";\nimport {\n  acceptance,\n  count,\n  exists,\n  query,\n  queryAll,\n  updateCurrentUser,\n} from \"discourse/tests/helpers/qunit-helpers\";\nimport selectKit from \"discourse/tests/helpers/select-kit-helper\";\nimport I18n from \"I18n\";\nimport QUnit, { test } from \"qunit\";\nimport { cloneJSON } from \"discourse-common/lib/object\";\n\n/*\n * Checks if a string is not contained in a string.\n *\n * @param haystack\n * @param needle\n * @param message\n */\nQUnit.assert.notContains = function notContains(haystack, needle, message) {\n  this.pushResult({\n    result: haystack.indexOf(needle) === -1,\n    actual: haystack,\n    expected: \"not to contain \" + needle,\n    message,\n  });\n};\n\n/**\n * @var PASSPHRASE Secret passphrase used for testing purposes.\n */\nconst PASSPHRASE = \"curren7U$er.pa$$Phr4se\";\n\n/**\n * @var PLAINTEXT Constant string that is used to check for plaintext leakage.\n */\nconst PLAINTEXT = \"!PL41N73X7!\";\nconst PLAINTEXT_TITLE = `A new topic ${PLAINTEXT}`;\nconst PLAINTEXT_RAW = `Hello, world! ${PLAINTEXT}\\n`.repeat(42);\n\n/**\n * @var keys User keys.\n */\nconst keys = {};\n\n/**\n * @var globalAssert Global assert instance used to report plaintext leakage.\n */\nlet globalAssert;\n\n/**\n * @var requests Request URLs intercepted by the leak checker.\n */\nlet requests = [];\n\n/**\n * Sets up encryption.\n *\n * @param status\n */\nasync function setEncryptionStatus(status) {\n  const user = User.current();\n\n  // Resetting IndexedDB.\n  try {\n    await deleteDb();\n  } catch (e) {}\n\n  // Generating a new key pair if enabling or creating a dummy one if disabling.\n  let identity = {};\n  let exported = {};\n  let exportedPrivate;\n  if (status !== ENCRYPT_DISABLED) {\n    identity = await generateIdentity();\n    exported = await exportIdentity(identity, PASSPHRASE);\n    exportedPrivate = JSON.stringify({ passphrase: exported.private });\n  }\n\n  // Overwriting server-side fields.\n  user.set(\"encrypt_public\", exported.public);\n  user.set(\"encrypt_private\", exportedPrivate);\n\n  // Setting the appropriate custom fields is not always enough (i.e. if user\n  // navigates to preferences).\n  pretender.get(\"/u/eviltrout.json\", () => {\n    const json = cloneJSON(userFixtures[\"/u/eviltrout.json\"]);\n    json.user.can_edit = true;\n    json.user.encrypt_public = exported.public;\n    json.user.encrypt_private = exportedPrivate;\n    return [200, { \"Content-Type\": \"application/json\" }, json];\n  });\n\n  // Activating encryption on client-side.\n  if (status === ENCRYPT_ACTIVE) {\n    await saveDbIdentity(identity);\n  }\n\n  keys[user.username] = exported.public;\n  return identity;\n}\n\n/**\n * Executes the given function and waits until current encryption status\n * changes or given waiter becomes true.\n *\n * @param statusOrWaiter\n * @param func\n */\nasync function wait(statusOrWaiter, func) {\n  const waiter =\n    typeof statusOrWaiter === \"function\"\n      ? statusOrWaiter\n      : () => getEncryptionStatus(User.current()) === statusOrWaiter;\n\n  try {\n    registerWaiter(waiter);\n    await func();\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error(`Caught exception while waiting: ${e.message}`, e);\n  } finally {\n    unregisterWaiter(waiter);\n  }\n}\n\nfunction setupEncryptTests(needs) {\n  needs.user({\n    can_encrypt: true,\n    encrypt_pms_default: true,\n  });\n\n  needs.hooks.beforeEach(function () {\n    // Hook `XMLHttpRequest` to search for leaked plaintext.\n    XMLHttpRequest.prototype.send_ = XMLHttpRequest.prototype.send;\n    XMLHttpRequest.prototype.send = function (body) {\n      requests.push(this.url);\n      if (body && globalAssert) {\n        globalAssert.notContains(body, PLAINTEXT, \"does not leak plaintext\");\n        globalAssert.notContains(body, PASSPHRASE, \"does not leak passphrase\");\n      }\n      return this.send_(...arguments);\n    };\n\n    resetEncrypt();\n  });\n\n  needs.hooks.afterEach(function () {\n    // Restore `XMLHttpRequest`.\n    XMLHttpRequest.prototype.send = XMLHttpRequest.prototype.send_;\n    delete XMLHttpRequest.prototype.send_;\n\n    globalAssert = null;\n  });\n\n  needs.pretender((server, helper) => {\n    pretender.get(\"/encrypt/user\", (request) => {\n      const resp = {};\n      request.queryParams[\"usernames\"].forEach((u) => (resp[u] = keys[u]));\n      return helper.response(resp);\n    });\n\n    pretender.get(\"/encrypt/posts\", () => {\n      return helper.response({ posts: [], topics: [] });\n    });\n\n    pretender.put(\"/encrypt/post\", () => {\n      return helper.response({});\n    });\n  });\n}\n\nasync function setupEncryptedTopicPretender(\n  server,\n  { identity, topicTitle = \"Top Secret Title\" } = {}\n) {\n  identity = identity || (await getIdentity());\n  const topicKey = await generateKey();\n  const exportedTopicKey = await exportKey(topicKey, identity.encryptPublic);\n  const encryptedTitle = await encrypt(topicKey, { raw: topicTitle });\n  const encryptedRaw = await encrypt(topicKey, { raw: \"Top Secret Post\" });\n\n  server.get(\"/t/42.json\", () => {\n    return [\n      200,\n      { \"Content-Type\": \"application/json\" },\n      {\n        post_stream: {\n          posts: [\n            {\n              id: 42,\n              name: null,\n              username: \"bar\",\n              avatar_template:\n                \"/letter_avatar_proxy/v4/letter/b/000000/{size}.png\",\n              created_at: \"2020-01-01T12:00:00.000Z\",\n              cooked:\n                \"<p>This is a secret message with end to end encryption. To view it, you must be invited to this topic.</p>\",\n              post_number: 1,\n              post_type: 1,\n              updated_at: \"2020-01-01T12:00:00.000Z\",\n              reply_count: 0,\n              reply_to_post_number: null,\n              quote_count: 0,\n              incoming_link_count: 0,\n              reads: 2,\n              readers_count: 1,\n              score: 0.4,\n              yours: false,\n              topic_id: 42,\n              topic_slug: \"a-secret-message\",\n              display_username: null,\n              primary_group_name: null,\n              primary_group_flair_url: null,\n              primary_group_flair_bg_color: null,\n              primary_group_flair_color: null,\n              version: 1,\n              can_edit: true,\n              can_delete: false,\n              can_recover: false,\n              can_wiki: true,\n              read: true,\n              user_title: null,\n              title_is_group: false,\n              bookmarked: false,\n              actions_summary: [\n                {\n                  id: 2,\n                  can_act: true,\n                },\n                {\n                  id: 3,\n                  can_act: true,\n                },\n                {\n                  id: 4,\n                  can_act: true,\n                },\n                {\n                  id: 8,\n                  can_act: true,\n                },\n                {\n                  id: 6,\n                  can_act: true,\n                },\n                {\n                  id: 7,\n                  can_act: true,\n                },\n              ],\n              moderator: false,\n              admin: true,\n              staff: true,\n              user_id: 2,\n              hidden: false,\n              trust_level: 0,\n              deleted_at: null,\n              user_deleted: false,\n              edit_reason: null,\n              can_view_edit_history: true,\n              wiki: false,\n              reviewable_id: 0,\n              reviewable_score_count: 0,\n              reviewable_score_pending_count: 0,\n              encrypted_raw: encryptedRaw,\n            },\n          ],\n          stream: [42],\n        },\n        timeline_lookup: [[1, 0]],\n        related_messages: [],\n        suggested_topics: [],\n        id: 42,\n        title: \"A secret message\",\n        fancy_title: \"A secret message\",\n        posts_count: 1,\n        created_at: \"2020-01-01T12:00:00.000Z\",\n        views: 2,\n        reply_count: 0,\n        like_count: 0,\n        last_posted_at: \"2020-01-01T12:00:00.000Z\",\n        visible: true,\n        closed: false,\n        archived: false,\n        has_summary: false,\n        archetype: \"private_message\",\n        slug: \"a-secret-message\",\n        category_id: null,\n        word_count: 16,\n        deleted_at: null,\n        user_id: 2,\n        featured_link: null,\n        pinned_globally: false,\n        pinned_at: null,\n        pinned_until: null,\n        image_url: null,\n        slow_mode_seconds: 0,\n        draft: null,\n        draft_key: \"topic_42\",\n        draft_sequence: 0,\n        posted: false,\n        unpinned: null,\n        pinned: false,\n        current_post_number: 1,\n        highest_post_number: 1,\n        last_read_post_number: 1,\n        last_read_post_id: 42,\n        deleted_by: null,\n        has_deleted: false,\n        actions_summary: [\n          {\n            id: 4,\n            count: 0,\n            hidden: false,\n            can_act: true,\n          },\n          {\n            id: 8,\n            count: 0,\n            hidden: false,\n            can_act: true,\n          },\n          {\n            id: 7,\n            count: 0,\n            hidden: false,\n            can_act: true,\n          },\n        ],\n        chunk_size: 20,\n        bookmarked: false,\n        message_archived: false,\n        topic_timer: null,\n        message_bus_last_id: 3,\n        participant_count: 1,\n        pm_with_non_human_user: false,\n        queued_posts_count: 0,\n        show_read_indicator: false,\n        requested_group_name: null,\n        thumbnails: null,\n        slow_mode_enabled_until: null,\n        encrypted_title: encryptedTitle,\n        topic_key: exportedTopicKey,\n        details: {\n          can_edit: true,\n          notification_level: 3,\n          notifications_reason_id: 2,\n          can_move_posts: true,\n          can_delete: true,\n          can_remove_allowed_users: true,\n          can_invite_to: true,\n          can_invite_via_email: true,\n          can_create_post: true,\n          can_reply_as_new_topic: true,\n          can_flag_topic: true,\n          can_convert_topic: true,\n          can_review_topic: true,\n          can_close_topic: true,\n          can_archive_topic: true,\n          can_split_merge_topic: true,\n          can_edit_staff_notes: true,\n          can_toggle_topic_visibility: true,\n          can_pin_unpin_topic: true,\n          can_moderate_category: true,\n          can_remove_self_id: 1,\n          participants: [\n            {\n              id: 2,\n              username: \"bar\",\n              name: null,\n              avatar_template:\n                \"/letter_avatar_proxy/v4/letter/b/000000/{size}.png\",\n              post_count: 1,\n              primary_group_name: null,\n              primary_group_flair_url: null,\n              primary_group_flair_color: null,\n              primary_group_flair_bg_color: null,\n              admin: true,\n              trust_level: 0,\n            },\n          ],\n          allowed_users: [\n            {\n              id: 1,\n              username: \"foo\",\n              name: null,\n              avatar_template:\n                \"/letter_avatar_proxy/v4/letter/f/000000/{size}.png\",\n            },\n            {\n              id: 2,\n              username: \"bar\",\n              name: null,\n              avatar_template:\n                \"/letter_avatar_proxy/v4/letter/b/000000/{size}.png\",\n            },\n          ],\n          created_by: {\n            id: 2,\n            username: \"bar\",\n            name: null,\n            avatar_template:\n              \"/letter_avatar_proxy/v4/letter/b/000000/{size}.png\",\n          },\n          last_poster: {\n            id: 2,\n            username: \"bar\",\n            name: null,\n            avatar_template:\n              \"/letter_avatar_proxy/v4/letter/b/000000/{size}.png\",\n          },\n          allowed_groups: [],\n        },\n        pending_posts: [],\n      },\n    ];\n  });\n}\n\nasync function setupEncryptedSearchResultPretender(server) {\n  const identity = await getIdentity();\n  const topicKey = await generateKey();\n  const exportedKey = await exportKey(topicKey, identity.encryptPublic);\n  const title = \"Top Secret Developer <a> :male_detective:\";\n  const encryptedTitle = await encrypt(topicKey, { raw: title });\n\n  server.get(\"/encrypt/posts\", (request) => {\n    if (request.queryParams[\"term\"]) {\n      return [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        {\n          success: \"OK\",\n          topics: [],\n          posts: [],\n        },\n      ];\n    } else {\n      return [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        {\n          success: \"OK\",\n          topics: [\n            {\n              id: 42,\n              title: \"A secret message\",\n              fancy_title: \"A secret message\",\n              slug: \"a-secret-message\",\n              posts_count: 1,\n              reply_count: 0,\n              highest_post_number: 1,\n              created_at: \"2021-01-01T12:00:00.000Z\",\n              last_posted_at: \"2021-01-01T12:00:00.000Z\",\n              bumped: true,\n              bumped_at: \"2021-01-01T12:00:00.000Z\",\n              archetype: \"private_message\",\n              unseen: false,\n              pinned: false,\n              unpinned: null,\n              visible: true,\n              closed: false,\n              archived: false,\n              bookmarked: null,\n              liked: null,\n              category_id: null,\n              encrypted_title: encryptedTitle,\n              topic_key: exportedKey,\n            },\n          ],\n          posts: [\n            {\n              id: 42,\n              username: \"foo\",\n              avatar_template:\n                \"/letter_avatar_proxy/v4/letter/f/eada6e/{size}.png\",\n              created_at: \"2021-01-01T12:00:00.000Z\",\n              like_count: 0,\n              post_number: 1,\n              topic_id: 42,\n            },\n            {\n              id: 43,\n              username: \"foo\",\n              avatar_template:\n                \"/letter_avatar_proxy/v4/letter/f/eada6e/{size}.png\",\n              created_at: \"2021-01-01T12:00:00.000Z\",\n              like_count: 0,\n              post_number: 2,\n              topic_id: 42,\n            },\n          ],\n        },\n      ];\n    }\n  });\n\n  return { encryptedTitle, exportedKey };\n}\n\nacceptance(\"Encrypt - disabled\", function (needs) {\n  setupEncryptTests(needs);\n\n  needs.hooks.beforeEach(async function () {\n    await setEncryptionStatus(ENCRYPT_DISABLED);\n  });\n\n  test(\"enabling works\", async function (assert) {\n    let ajaxRequested = false;\n    pretender.put(\"/encrypt/keys\", () => {\n      ajaxRequested = true;\n      return [200, { \"Content-Type\": \"application/json\" }, { success: \"OK\" }];\n    });\n\n    await visit(\"/u/eviltrout/preferences/security\");\n    await click(\".encrypt button.btn-primary\");\n    await waitUntil(\n      () => getEncryptionStatus(User.current()) === ENCRYPT_ACTIVE\n    );\n    assert.ok(ajaxRequested, \"AJAX request to save keys was made\");\n\n    const identity = await loadDbIdentity();\n    assert.ok(identity.encryptPublic instanceof CryptoKey);\n    assert.ok(identity.encryptPrivate instanceof CryptoKey);\n    assert.ok(identity.signPublic instanceof CryptoKey);\n    assert.ok(identity.signPrivate instanceof CryptoKey);\n  });\n\n  test(\"encrypt settings visible only if user can encrypt\", async function (assert) {\n    await visit(\"/u/eviltrout/preferences/security\");\n    assert.ok(\n      query(\".encrypt\").innerText.trim().length > 0,\n      \"encrypt settings are visible\"\n    );\n\n    updateCurrentUser({ can_encrypt: false });\n\n    await visit(\"/u/eviltrout/preferences\");\n    await click(\".user-nav__preferences-security a\");\n    assert.strictEqual(\n      query(\".encrypt\").innerText.trim().length,\n      0,\n      \"encrypt settings are not visible\"\n    );\n\n    updateCurrentUser({ can_encrypt: true });\n\n    await visit(\"/u/eviltrout/preferences\");\n    await click(\".user-nav__preferences-security a\");\n    assert.ok(\n      query(\".encrypt\").innerText.trim().length > 0,\n      \"encrypt settings are visible\"\n    );\n  });\n\n  test(\"user preferences connector works for other users\", async function (assert) {\n    pretender.get(\"/u/eviltrout2.json\", () => {\n      const json = cloneJSON(userFixtures[\"/u/eviltrout.json\"]);\n      json.user.id += 1;\n      json.user.can_edit = true;\n      json.user.can_encrypt = true;\n      json.user.encrypt_public = \"encrypted public identity\";\n      return [200, { \"Content-Type\": \"application/json\" }, json];\n    });\n\n    await visit(\"/u/eviltrout2/preferences/security\");\n\n    assert.ok(\n      query(\".user-preferences-security-outlet.encrypt\")\n        .innerText.trim()\n        .includes(I18n.t(\"encrypt.preferences.status_enabled_other\"))\n    );\n  });\n});\n\nacceptance(\"Encrypt - enabled\", function (needs) {\n  setupEncryptTests(needs);\n\n  needs.hooks.beforeEach(async function () {\n    await setEncryptionStatus(ENCRYPT_ENABLED);\n  });\n\n  test(\"activation works\", async function (assert) {\n    await visit(\"/u/eviltrout/preferences/security\");\n    await fillIn(\".encrypt #passphrase\", PASSPHRASE);\n    await click(\".encrypt button.btn-primary\");\n\n    await waitUntil(\n      () => getEncryptionStatus(User.current()) === ENCRYPT_ACTIVE\n    );\n\n    const identity = await loadDbIdentity();\n    assert.ok(identity.encryptPublic instanceof CryptoKey);\n    assert.ok(identity.encryptPrivate instanceof CryptoKey);\n    assert.ok(identity.signPublic instanceof CryptoKey);\n    assert.ok(identity.signPrivate instanceof CryptoKey);\n  });\n\n  test(\"viewing encrypted topic works when just enabled\", async function (assert) {\n    globalAssert = assert;\n\n    const identities = JSON.parse(User.current().encrypt_private);\n    const identity = await importIdentity(identities[\"passphrase\"], PASSPHRASE);\n    await setupEncryptedTopicPretender(pretender, { identity });\n\n    await visit(\"/t/a-secret-message/42\");\n    assert.dom(\".modal.activate-encrypt-modal\").exists();\n  });\n});\n\nacceptance(\"Encrypt - active\", function (needs) {\n  setupEncryptTests(needs);\n\n  needs.hooks.beforeEach(async function () {\n    await setEncryptionStatus(ENCRYPT_ACTIVE);\n  });\n\n  test(\"meta: leak checker works\", async function (assert) {\n    globalAssert = { notContains: () => assert.ok(true) };\n\n    await visit(\"/\");\n    await click(\"#create-topic\");\n    const categoryChooser = selectKit(\".category-chooser\");\n    await categoryChooser.expand();\n    await categoryChooser.selectRowByValue(2);\n\n    await fillIn(\"#reply-title\", `Some hidden message ${PLAINTEXT}`);\n    await fillIn(\".d-editor-input\", PLAINTEXT_RAW);\n\n    requests = [];\n    await click(\"button.create\");\n    assert.true(requests.includes(\"/posts\"));\n  });\n\n  test(\"posting does not leak plaintext\", async function (assert) {\n    globalAssert = assert;\n\n    pretender.get(\"/u/search/users\", () => {\n      return [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        {\n          users: [\n            {\n              username: \"eviltrout\",\n              name: \"eviltrout\",\n              avatar_template: \"/images/avatar.png\",\n            },\n          ],\n        },\n      ];\n    });\n\n    pretender.get(\"/composer_messages/user_not_seen_in_a_while\", () => {\n      return response({});\n    });\n\n    pretender.post(\"/posts\", (request) => {\n      const body = parsePostData(request.requestBody);\n\n      assert.strictEqual(body.raw, I18n.t(\"encrypt.encrypted_post\"));\n      assert.strictEqual(body.title, I18n.t(\"encrypt.encrypted_title\"));\n      assert.strictEqual(body.archetype, \"private_message\");\n      assert.strictEqual(body.target_recipients, \"eviltrout\");\n      assert.strictEqual(body.draft_key, \"new_private_message\");\n      assert.strictEqual(body.is_encrypted, \"true\");\n      assert.ok(body.encrypted_title.startsWith(\"1$\"));\n      assert.ok(body.encrypted_raw.startsWith(\"1$\"));\n      assert.ok(JSON.parse(body.encrypted_keys).eviltrout);\n\n      return [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        { action: \"create_post\", post: { topic_id: 34 } },\n      ];\n    });\n\n    await visit(\"/u/eviltrout/messages\");\n    await click(\".new-private-message\");\n\n    // simulate selecting from autocomplete suggestions\n    const usersSelector = selectKit(\"#private-message-users\");\n    await usersSelector.expand();\n    await usersSelector.fillInFilter(\"evilt\");\n    await usersSelector.selectRowByValue(\"eviltrout\");\n    await usersSelector.collapse();\n\n    requests = [];\n\n    await fillIn(\"#reply-title\", `Some hidden message ${PLAINTEXT}`);\n    await fillIn(\".d-editor-input\", PLAINTEXT_RAW);\n    await waitUntil(() => requests.includes(\"/drafts.json\"));\n\n    requests = [];\n    await click(\"button.create\");\n    assert.true(requests.includes(\"/posts\"));\n    assert.true(requests.includes(\"/encrypt/post\"));\n  });\n\n  test(\"new draft for public topic is not encrypted\", async function (assert) {\n    let assertedTitle, assertedReply;\n    pretender.post(\"/drafts.json\", (request) => {\n      const data = JSON.parse(parsePostData(request.requestBody).data);\n      if (data.title) {\n        assertedTitle = true;\n        assert.strictEqual(data.title, PLAINTEXT_TITLE);\n      }\n      if (data.reply) {\n        assertedReply = true;\n        assert.strictEqual(data.reply, PLAINTEXT_RAW);\n      }\n      return [200, { \"Content-Type\": \"application/json\" }, {}];\n    });\n\n    await visit(\"/\");\n    await click(\"#create-topic\");\n    const categoryChooser = selectKit(\".category-chooser\");\n    await categoryChooser.expand();\n    await categoryChooser.selectRowByValue(2);\n    await fillIn(\"#reply-title\", PLAINTEXT_TITLE);\n    await fillIn(\".d-editor-input\", PLAINTEXT_RAW);\n\n    await wait(\n      () => assertedTitle && assertedReply,\n      () => click(\".toggler\")\n    );\n  });\n\n  test(\"draft for new topics is encrypted\", async function (assert) {\n    let assertedTitle, assertedReply;\n    pretender.post(\"/drafts.json\", (request) => {\n      const data = JSON.parse(parsePostData(request.requestBody).data);\n      if (data.title) {\n        assertedTitle = true;\n        assert.notStrictEqual(data.title, PLAINTEXT_TITLE);\n      }\n      if (data.reply) {\n        assertedReply = true;\n        assert.notStrictEqual(data.reply, PLAINTEXT_RAW);\n      }\n      return [200, { \"Content-Type\": \"application/json\" }, {}];\n    });\n\n    await visit(\"/u/eviltrout/messages\");\n    await click(\".new-private-message\");\n    await fillIn(\"#reply-title\", PLAINTEXT_TITLE);\n    await fillIn(\".d-editor-input\", PLAINTEXT_RAW);\n\n    await wait(\n      () => assertedTitle && assertedReply,\n      () => click(\".toggler\")\n    );\n  });\n\n  test(\"draft for replies is encrypted\", async function (assert) {\n    let assertedReply;\n    pretender.post(\"/drafts.json\", (request) => {\n      const data = JSON.parse(parsePostData(request.requestBody).data);\n      if (data.reply) {\n        assertedReply = true;\n        assert.notStrictEqual(data.reply, PLAINTEXT_RAW);\n      }\n      return [200, { \"Content-Type\": \"application/json\" }, {}];\n    });\n\n    await setupEncryptedTopicPretender(pretender);\n\n    await visit(\"/t/a-secret-message/42\");\n    await click(\".topic-footer-main-buttons .btn-primary.create\");\n    await fillIn(\".d-editor-input\", PLAINTEXT_RAW);\n\n    await wait(\n      () => assertedReply,\n      () => click(\".toggler\")\n    );\n  });\n\n  test(\"deactivation works\", async function (assert) {\n    await visit(\"/u/eviltrout/preferences/security\");\n    await click(\".encrypt button#encrypt-deactivate\");\n\n    await waitUntil(\n      () => getEncryptionStatus(User.current()) === ENCRYPT_ENABLED\n    );\n\n    assert.rejects(loadDbIdentity());\n  });\n\n  test(\"viewing encrypted topic works when active\", async function (assert) {\n    globalAssert = assert;\n\n    await setupEncryptedTopicPretender(pretender);\n\n    await visit(\"/t/a-secret-message/42\");\n\n    assert.strictEqual(\n      query(\".fancy-title\").innerText.trim(),\n      \"Top Secret Title\"\n    );\n    assert.strictEqual(query(\".cooked\").innerText.trim(), \"Top Secret Post\");\n    assert.strictEqual(\n      document.title,\n      \"Top Secret Title - QUnit Discourse Tests\"\n    );\n    assert.ok(exists(\".private_message.encrypted\"), \"encrypted class is added\");\n\n    await click(\".private_message.encrypted h1[data-topic-id] .edit-topic\");\n\n    assert.strictEqual(query(\"#edit-title\").value.trim(), \"Top Secret Title\");\n  });\n\n  test(\"viewing encrypted topic escapes title correctly\", async function (assert) {\n    globalAssert = assert;\n\n    const title = \"Title <a>with some html chars</a>\";\n    await setupEncryptedTopicPretender(pretender, { topicTitle: title });\n\n    await visit(\"/t/a-secret-message/42\");\n\n    assert\n      .dom(\".fancy-title\")\n      .hasText(title, \"Title in UI is escaped correctly\");\n    assert.strictEqual(document.title, `${title} - QUnit Discourse Tests`);\n  });\n\n  test(\"topic titles in notification panel are decrypted\", async function (assert) {\n    const identity = await getIdentity();\n    const topicKey = await generateKey();\n    const exportedKey = await exportKey(topicKey, identity.encryptPublic);\n    const title = \"Top Secret :male_detective:\";\n    const encryptedTitle = await encrypt(topicKey, { raw: title });\n    putTopicTitle(42, title);\n\n    pretender.get(\"/notifications\", () => [\n      200,\n      { \"Content-Type\": \"application/json\" },\n      {\n        notifications: [\n          {\n            id: 42,\n            user_id: 1,\n            notification_type: NOTIFICATION_TYPES.private_message,\n            read: false,\n            created_at: \"2020-01-01T12:12:12.000Z\",\n            post_number: 1,\n            topic_id: 42,\n            fancy_title: \"A Secret Message\",\n            slug: \"a-secret-message\",\n            data: {\n              topic_title: \"A Secret Message\",\n              original_post_id: 42,\n              original_post_type: 1,\n              original_username: \"foo\",\n              revision_number: null,\n              display_username: \"foo\",\n            },\n            encrypted_title: encryptedTitle,\n            topic_key: exportedKey,\n          },\n        ],\n        total_rows_notifications: 1,\n        seen_notification_id: 5,\n        load_more_notifications: \"/notifications?offset=60&username=foo\",\n      },\n    ]);\n\n    await visit(\"/\");\n    await click(\".header-dropdown-toggle.current-user\");\n\n    assert\n      .dom(\".quick-access-panel span[data-topic-id]\")\n      .includesText(\"Top Secret\");\n    assert\n      .dom(\".quick-access-panel span[data-topic-id] img\")\n      .exists({ count: 1 });\n  });\n\n  test(\"encrypted topic titles in experiemental user menu notifications tab are decrypted\", async function (assert) {\n    updateCurrentUser({\n      redesigned_user_menu_enabled: true,\n    });\n    const identity = await getIdentity();\n    const topicKey = await generateKey();\n    const exportedKey = await exportKey(topicKey, identity.encryptPublic);\n    const title = \"Top Secret <a> :male_detective:\";\n    const encryptedTitle = await encrypt(topicKey, { raw: title });\n    putTopicTitle(42, title);\n\n    pretender.get(\"/notifications\", () => [\n      200,\n      { \"Content-Type\": \"application/json\" },\n      {\n        notifications: [\n          {\n            id: 42,\n            user_id: 1,\n            notification_type: NOTIFICATION_TYPES.private_message,\n            read: false,\n            created_at: \"2020-01-01T12:12:12.000Z\",\n            post_number: 1,\n            topic_id: 42,\n            fancy_title: \"A Secret Message\",\n            slug: \"a-secret-message\",\n            data: {\n              topic_title: \"A Secret Message\",\n              original_post_id: 42,\n              original_post_type: 1,\n              original_username: \"foo\",\n              revision_number: null,\n              display_username: \"secret-mailer\",\n            },\n            encrypted_title: encryptedTitle,\n            topic_key: exportedKey,\n          },\n        ],\n        total_rows_notifications: 1,\n        seen_notification_id: 5,\n        load_more_notifications: \"/notifications?offset=60&username=foo\",\n      },\n    ]);\n\n    await visit(\"/\");\n    await click(\".header-dropdown-toggle.current-user\");\n\n    const notifications = queryAll(\n      \"#quick-access-all-notifications ul li.notification\"\n    );\n\n    assert.strictEqual(\n      notifications[0].textContent.replace(/\\s+/g, \" \").trim(),\n      \"secret-mailer Top Secret <a>\",\n      \"message title in the notifications tab is decrypted and rendered safely\"\n    );\n    const emoji = notifications[0].querySelector(\".item-description img.emoji\");\n    assert.strictEqual(\n      emoji.title,\n      \"male_detective\",\n      \"emoji in encrypted message title in the notifications tab is rendered correctly\"\n    );\n  });\n\n  test(\"encrypted topic titles in experiemental user menu bookmarks tab are decrypted\", async function (assert) {\n    updateCurrentUser({\n      redesigned_user_menu_enabled: true,\n    });\n    const identity = await getIdentity();\n    const topicKey = await generateKey();\n    const exportedKey = await exportKey(topicKey, identity.encryptPublic);\n    const title = \"Top Secret <a> :male_detective:\";\n    const encryptedTitle = await encrypt(topicKey, { raw: title });\n    putTopicTitle(8223, title);\n\n    pretender.get(\"/u/eviltrout/user-menu-bookmarks\", () => [\n      200,\n      { \"Content-Type\": \"application/json\" },\n      {\n        notifications: [],\n        bookmarks: [\n          {\n            id: 18207,\n            created_at: \"2022-08-25T21:19:09.646Z\",\n            updated_at: \"2022-08-25T21:19:09.646Z\",\n            name: \"\",\n            reminder_at: null,\n            pinned: false,\n            title: \"A secret message\",\n            fancy_title: \"A secret message\",\n            excerpt:\n              \"This is a secret message with end to end encryption. To view it, you must be invited to this topic.\",\n            bookmarkable_id: 84390,\n            bookmarkable_type: \"Post\",\n            bookmarkable_url:\n              \"https://local.discourse.org/t/a-secret-message/8223/1\",\n            tags: [],\n            tags_descriptions: {},\n            topic_id: 8223,\n            linked_post_number: 1,\n            deleted: false,\n            hidden: false,\n            category_id: null,\n            closed: false,\n            archived: false,\n            archetype: \"private_message\",\n            highest_post_number: 1,\n            bumped_at: \"2022-08-25T08:53:01.491Z\",\n            slug: \"a-secret-message\",\n            encrypted_title: encryptedTitle,\n            topic_key: exportedKey,\n            user: {\n              id: 1500,\n              username: \"top-sekret-man\",\n              avatar_template: \"/user_avatar/localhost/nat/{size}/515078_2.png\",\n            },\n          },\n        ],\n      },\n    ]);\n\n    await visit(\"/\");\n    await click(\".header-dropdown-toggle.current-user\");\n    await click(\"#user-menu-button-bookmarks\");\n\n    const bookmarks = queryAll(\"#quick-access-bookmarks ul li.bookmark\");\n\n    assert.strictEqual(\n      bookmarks[0].textContent.replace(/\\s+/g, \" \").trim(),\n      \"top-sekret-man Top Secret <a>\",\n      \"message title in the bookmarks tab is decrypted and rendered safely\"\n    );\n    const emoji = bookmarks[0].querySelector(\".item-description img.emoji\");\n    assert.strictEqual(\n      emoji.title,\n      \"male_detective\",\n      \"emoji in encrypted message title in the bookmarks tab is rendered correctly\"\n    );\n  });\n\n  test(\"encrypted topic titles in experiemental user menu messages tab are decrypted\", async function (assert) {\n    updateCurrentUser({\n      redesigned_user_menu_enabled: true,\n      can_send_private_messages: true,\n    });\n    const identity = await getIdentity();\n    const topicKey = await generateKey();\n    const exportedKey = await exportKey(topicKey, identity.encryptPublic);\n    const title = \"Top Secret <a> :male_detective:\";\n    const encryptedTitle = await encrypt(topicKey, { raw: title });\n    putTopicTitle(127, title);\n\n    pretender.get(\"/u/eviltrout/user-menu-private-messages\", () => [\n      200,\n      { \"Content-Type\": \"application/json\" },\n      {\n        unread_notifications: [],\n        read_notifications: [],\n        topics: [\n          {\n            id: 127,\n            title: \"A secret message\",\n            fancy_title: \"A secret message\",\n            slug: \"a-secret-message\",\n            posts_count: 1,\n            reply_count: 0,\n            highest_post_number: 2,\n            image_url: null,\n            created_at: \"2019-07-26T01:29:24.008Z\",\n            last_posted_at: \"2019-07-26T01:29:24.177Z\",\n            bumped: true,\n            bumped_at: \"2019-07-26T01:29:24.177Z\",\n            unseen: false,\n            last_read_post_number: 2,\n            unread_posts: 0,\n            pinned: false,\n            unpinned: null,\n            visible: true,\n            closed: false,\n            archived: false,\n            notification_level: 3,\n            bookmarked: false,\n            bookmarks: [],\n            liked: false,\n            views: 5,\n            like_count: 0,\n            has_summary: false,\n            archetype: \"private_message\",\n            last_poster_username: \"detective\",\n            category_id: null,\n            pinned_globally: false,\n            featured_link: null,\n            posters: [\n              {\n                extras: \"latest single\",\n                description: \"Original Poster, Most Recent Poster\",\n                user_id: 13,\n                primary_group_id: null,\n              },\n            ],\n            participants: [\n              {\n                extras: \"latest\",\n                description: null,\n                user_id: 13,\n                primary_group_id: null,\n              },\n            ],\n            encrypted_title: encryptedTitle,\n            topic_key: exportedKey,\n          },\n        ],\n      },\n    ]);\n\n    await visit(\"/\");\n    await click(\".header-dropdown-toggle.current-user\");\n    await click(\"#user-menu-button-messages\");\n\n    const messages = queryAll(\"#quick-access-messages ul li.message\");\n    assert.strictEqual(messages.length, 1);\n\n    assert.strictEqual(\n      messages[0].textContent.replace(/\\s+/g, \" \").trim(),\n      \"detective Top Secret <a>\",\n      \"message title in the messages tab is decrypted and rendered safely\"\n    );\n    const emoji = messages[0].querySelector(\".item-description img.emoji\");\n    assert.strictEqual(\n      emoji.title,\n      \"male_detective\",\n      \"emoji in encrypted message title in the messages tab is rendered correctly\"\n    );\n  });\n\n  test(\"searching in messages with filters\", async function (assert) {\n    pretender.get(\"/search/query\", (request) => {\n      // return only one result for PM search\n      return [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        {\n          posts: [\n            {\n              id: 3833,\n              name: \"Bill Dudney\",\n              username: \"bdudney\",\n              avatar_template:\n                \"/user_avatar/meta.discourse.org/bdudney/{size}/8343_1.png\",\n              uploaded_avatar_id: 8343,\n              created_at: \"2013-02-07T17:46:57.469Z\",\n              cooked:\n                \"<p>I've gotten vagrant up and running with a development environment but it's taking forever to load.</p>\\n\\n<p>For example <a href=\\\"http://192.168.10.200:3000/\\\" rel=\\\"nofollow\\\">http://192.168.10.200:3000/</a> takes tens of seconds to load.</p>\\n\\n<p>I'm running the whole stack on a new rMBP with OS X 10.8.2.</p>\\n\\n<p>Any ideas of what I've done wrong? Or is this just a function of being on the bleeding edge?</p>\\n\\n<p>Thanks,</p>\\n\\n<p>-bd</p>\",\n              post_number: 1,\n              post_type: 1,\n              updated_at: \"2013-02-07T17:46:57.469Z\",\n              like_count: 0,\n              reply_count: 1,\n              reply_to_post_number: null,\n              quote_count: 0,\n              incoming_link_count: 4422,\n              reads: 327,\n              score: 21978.4,\n              yours: false,\n              topic_id: 2179,\n              topic_slug: \"development-mode-super-slow\",\n              display_username: \"Bill Dudney\",\n              primary_group_name: null,\n              version: 2,\n              can_edit: false,\n              can_delete: false,\n              can_recover: false,\n              user_title: null,\n              actions_summary: [\n                {\n                  id: 2,\n                  count: 0,\n                  hidden: false,\n                  can_act: false,\n                },\n                {\n                  id: 3,\n                  count: 0,\n                  hidden: false,\n                  can_act: false,\n                },\n                {\n                  id: 4,\n                  count: 0,\n                  hidden: false,\n                  can_act: false,\n                },\n                {\n                  id: 5,\n                  count: 0,\n                  hidden: true,\n                  can_act: false,\n                },\n                {\n                  id: 6,\n                  count: 0,\n                  hidden: false,\n                  can_act: false,\n                },\n                {\n                  id: 7,\n                  count: 0,\n                  hidden: false,\n                  can_act: false,\n                },\n                {\n                  id: 8,\n                  count: 0,\n                  hidden: false,\n                  can_act: false,\n                },\n              ],\n              moderator: false,\n              admin: false,\n              staff: false,\n              user_id: 1828,\n              hidden: false,\n              hidden_reason_id: null,\n              trust_level: 1,\n              deleted_at: null,\n              user_deleted: false,\n              edit_reason: null,\n              can_view_edit_history: true,\n              wiki: false,\n              blurb:\n                \"I've gotten vagrant up and running with a development environment but it's taking forever to load. For example http://192.168.10.200:3000/ takes...\",\n            },\n          ],\n          topics: [\n            {\n              id: 2179,\n              title: \"Development mode super slow\",\n              fancy_title: \"Development mode super slow\",\n              slug: \"development-mode-super-slow\",\n              posts_count: 72,\n              reply_count: 53,\n              highest_post_number: 73,\n              image_url: null,\n              created_at: \"2013-02-07T17:46:57.262Z\",\n              last_posted_at: \"2015-04-17T08:08:26.671Z\",\n              bumped: true,\n              bumped_at: \"2015-04-17T08:08:26.671Z\",\n              unseen: false,\n              pinned: false,\n              unpinned: null,\n              visible: true,\n              closed: false,\n              archived: false,\n              bookmarked: null,\n              liked: null,\n              views: 9538,\n              like_count: 45,\n              has_summary: true,\n              archetype: \"regular\",\n              last_poster_username: null,\n              category_id: 7,\n              pinned_globally: false,\n              posters: [],\n              tags: [\"dev\", \"slow\"],\n              tags_descriptions: {\n                dev: \"dev description\",\n                slow: \"slow description\",\n              },\n            },\n          ],\n          grouped_search_result: {\n            term: request.queryParams.term,\n            type_filter: \"private_messages\",\n            post_ids: [3833],\n          },\n        },\n      ];\n    });\n\n    await setupEncryptedSearchResultPretender(pretender);\n\n    await visit(\"/\");\n    await click(\"#search-button\");\n\n    await fillIn(\"#search-term\", \"dev\");\n    await triggerKeyEvent(\".search-menu\", \"keydown\", \"ArrowDown\");\n    await click(document.activeElement);\n\n    const item = \".search-menu .results .item\";\n    assert.strictEqual(\n      query(`${item} [data-topic-id='2179']`)?.innerText?.trim(),\n      \"Development mode super slow\"\n    );\n    assert.strictEqual(\n      query(`${item} [data-topic-id='42']`)?.innerText?.trim(),\n      \"Top Secret Developer\"\n    );\n\n    await fillIn(\"#search-term\", \"group_messages:staff dev\");\n    await triggerKeyEvent(\".search-menu\", \"keydown\", \"ArrowDown\");\n    await click(document.activeElement);\n\n    assert.strictEqual(\n      query(`${item} [data-topic-id='2179']`)?.innerText?.trim(),\n      \"Development mode super slow\"\n    );\n    assert.notOk(exists(`${item} [data-topic-id='42']`));\n\n    await fillIn(\"#search-term\", \"in:messages after:2022-11-01 dev\");\n    await triggerKeyEvent(\".search-menu\", \"keydown\", \"ArrowDown\");\n    await click(document.activeElement);\n\n    assert.strictEqual(\n      query(`${item} [data-topic-id='2179']`)?.innerText?.trim(),\n      \"Development mode super slow\"\n    );\n    assert.notOk(exists(`${item} [data-topic-id='42']`));\n  });\n\n  test(\"searching in encrypted topic titles\", async function (assert) {\n    pretender.get(\"/search\", (request) => {\n      return [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        {\n          posts: [],\n          topics: [],\n          grouped_search_result: {\n            term: request.queryParams.q,\n            type_filter: \"private_messages\",\n            post_ids: [],\n          },\n        },\n      ];\n    });\n\n    const result = await setupEncryptedSearchResultPretender(pretender);\n\n    await visit(\"/search?q=secret+in:personal\");\n    assert.strictEqual(count(\".fps-result\"), 1);\n    assert.strictEqual(\n      query(\".fps-result .topic-title\").innerText.trim(),\n      \"Top Secret Developer\"\n    );\n\n    pretender.get(\"/search\", (request) => {\n      return [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        {\n          posts: [\n            {\n              id: 42,\n              username: \"foo\",\n              avatar_template:\n                \"/letter_avatar_proxy/v4/letter/f/eada6e/{size}.png\",\n              created_at: \"2021-01-01T12:00:00.000Z\",\n              like_count: 0,\n              blurb:\n                'This is a <span class=\"search-highlight\">secret</span> message with end to end encryption. To view it, you must be invited to this topic...',\n              post_number: 1,\n              topic_title_headline:\n                'A <span class=\"search-highlight\">secret</span> message',\n              topic_id: 42,\n            },\n          ],\n          topics: [\n            {\n              id: 42,\n              title: \"A secret message\",\n              fancy_title: \"A secret message\",\n              slug: \"a-secret-message\",\n              posts_count: 1,\n              reply_count: 0,\n              highest_post_number: 1,\n              created_at: \"2021-01-01T12:00:00.000Z\",\n              last_posted_at: \"2021-01-01T12:00:00.000Z\",\n              bumped: true,\n              bumped_at: \"2021-01-01T12:00:00.000Z\",\n              archetype: \"private_message\",\n              unseen: false,\n              last_read_post_number: 1,\n              unread: 0,\n              new_posts: 0,\n              pinned: false,\n              unpinned: null,\n              visible: true,\n              closed: false,\n              archived: false,\n              notification_level: 3,\n              bookmarked: false,\n              liked: false,\n              category_id: null,\n              encrypted_title: result.encryptedTitle,\n              topic_key: result.exportedKey,\n            },\n          ],\n          users: [],\n          categories: [],\n          tags: [],\n          groups: [],\n          grouped_search_result: {\n            more_posts: null,\n            more_users: null,\n            more_categories: null,\n            term: request.queryParams.q,\n            search_log_id: 42,\n            more_full_page_results: null,\n            can_create_topic: true,\n            error: null,\n            type_filter: \"private_messages\",\n            post_ids: [42],\n            user_ids: [],\n            category_ids: [],\n            tag_ids: [],\n            group_ids: [],\n          },\n        },\n      ];\n    });\n\n    await visit(\"/search?q=secret++in:personal\");\n    assert.strictEqual(count(\".fps-result\"), 1);\n    assert.strictEqual(\n      query(\".fps-result .topic-title\").innerText.trim(),\n      \"Top Secret Developer\"\n    );\n  });\n\n  test(\"searching works when user has no encrypted topics\", async function (assert) {\n    pretender.get(\"/search\", (request) => {\n      return [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        {\n          posts: [],\n          topics: [],\n          grouped_search_result: {\n            term: request.queryParams.q,\n            type_filter: \"private_messages\",\n            post_ids: [],\n          },\n        },\n      ];\n    });\n\n    pretender.get(\"/encrypt/posts\", () => {\n      return [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        {\n          success: \"OK\",\n          topics: [],\n          posts: [],\n        },\n      ];\n    });\n\n    await visit(\"/search?q=nothing+in:personal\");\n    assert.strictEqual(count(\".fps-result\"), 0);\n  });\n\n  test(\"searching in bookmarks\", async function (assert) {\n    const identity = await getIdentity();\n\n    const topicKey = await generateKey();\n    const exportedTopicKey = await exportKey(topicKey, identity.encryptPublic);\n    const encryptedTitle = await encrypt(topicKey, { raw: \"Top Secret Title\" });\n\n    const topicKey2 = await generateKey();\n    const exportedTopicKey2 = await exportKey(\n      topicKey2,\n      identity.encryptPublic\n    );\n    const encryptedTitle2 = await encrypt(topicKey2, { raw: \"Not a Secret\" });\n\n    pretender.get(\"/u/eviltrout/bookmarks.json\", (request) => {\n      if (request.queryParams.q) {\n        return [\n          200,\n          { \"Content-Type\": \"application/json\" },\n          {\n            bookmarks: [],\n          },\n        ];\n      }\n\n      return [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        {\n          user_bookmark_list: {\n            more_bookmarks_url: \"/u/eviltrout/bookmarks.json?page=1\",\n            bookmarks: [\n              {\n                excerpt: \"\",\n                id: 42,\n                created_at: \"2020-01-01T12:00:00.000Z\",\n                updated_at: \"2020-01-01T12:00:00.000Z\",\n                topic_id: 42,\n                linked_post_number: 1,\n                bookmarkable_id: 42,\n                bookmarkable_type: \"Post\",\n                name: null,\n                reminder_at: null,\n                pinned: false,\n                title: \"A secret message\",\n                fancy_title: \"A secret message\",\n                deleted: false,\n                hidden: false,\n                category_id: null,\n                closed: false,\n                archived: false,\n                archetype: \"private_message\",\n                highest_post_number: 1,\n                bumped_at: \"2020-01-01T12:00:00.000Z\",\n                slug: \"a-secret-message\",\n                post_user_username: \"foo\",\n                post_user_avatar_template:\n                  \"/letter_avatar_proxy/v4/letter/f/eada6e/{size}.png\",\n                post_user_name: null,\n                encrypted_title: encryptedTitle,\n                topic_key: exportedTopicKey,\n              },\n              {\n                excerpt: \"\",\n                id: 43,\n                created_at: \"2020-01-01T12:00:00.000Z\",\n                updated_at: \"2020-01-01T12:00:00.000Z\",\n                topic_id: 43,\n                linked_post_number: 1,\n                bookmarkable_id: 43,\n                bookmarkable_type: \"Post\",\n                name: null,\n                reminder_at: null,\n                pinned: false,\n                title: \"A secret message\",\n                fancy_title: \"A secret message\",\n                deleted: false,\n                hidden: false,\n                category_id: null,\n                closed: false,\n                archived: false,\n                archetype: \"private_message\",\n                highest_post_number: 1,\n                bumped_at: \"2020-01-01T12:00:00.000Z\",\n                slug: \"a-secret-message\",\n                post_user_username: \"foo\",\n                post_user_avatar_template:\n                  \"/letter_avatar_proxy/v4/letter/f/eada6e/{size}.png\",\n                post_user_name: null,\n                encrypted_title: encryptedTitle2,\n                topic_key: exportedTopicKey2,\n              },\n            ],\n          },\n        },\n      ];\n    });\n\n    await visit(\"/u/eviltrout/activity/bookmarks\");\n    await visit(\"/u/eviltrout/activity/bookmarks\"); // extra wait\n\n    assert.strictEqual(count(\".bookmark-list-item\"), 2);\n    assert.strictEqual(\n      queryAll(\".bookmark-list-item .title\")[0].innerText.trim(),\n      \"Top Secret Title\"\n    );\n    assert.strictEqual(\n      queryAll(\".bookmark-list-item .title\")[1].innerText.trim(),\n      \"Not a Secret\"\n    );\n\n    await visit(\"/\");\n    await visit(\"/u/eviltrout/activity/bookmarks?q=Top\");\n\n    assert.strictEqual(count(\".bookmark-list-item\"), 1);\n    assert.strictEqual(\n      queryAll(\".bookmark-list-item .title\")[0].innerText.trim(),\n      \"Top Secret Title\"\n    );\n  });\n});\n"], "filenames": [".discourse-compatibility", "assets/javascripts/discourse/initializers/decrypt-topics.js", "test/javascripts/acceptance/encrypt-test.js"], "buggy_code_start_loc": [1, 316, 210], "buggy_code_end_loc": [2, 317, 846], "fixing_code_start_loc": [0, 316, 210], "fixing_code_end_loc": [0, 317, 864], "type": "CWE-79", "message": "discourse-encrypt is a plugin that provides a secure communication channel through Discourse. Improper escaping of encrypted topic titles could lead to a cross site scripting (XSS) issue when a site has content security policy (CSP) headers disabled. Having CSP disabled is a non-default configuration, and having it disabled with discourse-encrypt installed will result in a warning in the Discourse admin dashboard. This has been fixed in commit `9c75810af9` which is included in the latest version of the discourse-encrypt plugin. Users are advised to upgrade. Users unable to upgrade should ensure that CSP headers are enabled and properly configured.", "other": {"cve": {"id": "CVE-2023-43657", "sourceIdentifier": "security-advisories@github.com", "published": "2023-09-28T19:15:10.547", "lastModified": "2023-10-02T20:15:53.177", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "discourse-encrypt is a plugin that provides a secure communication channel through Discourse. Improper escaping of encrypted topic titles could lead to a cross site scripting (XSS) issue when a site has content security policy (CSP) headers disabled. Having CSP disabled is a non-default configuration, and having it disabled with discourse-encrypt installed will result in a warning in the Discourse admin dashboard. This has been fixed in commit `9c75810af9` which is included in the latest version of the discourse-encrypt plugin. Users are advised to upgrade. Users unable to upgrade should ensure that CSP headers are enabled and properly configured."}, {"lang": "es", "value": "discourse-encrypt es un complemento que proporciona un canal de comunicaci\u00f3n seguro a trav\u00e9s de Discourse. El escape inadecuado de los topic titles cifrados podr\u00eda provocar un problema de Cross Site Scripting (XSS) cuando un sitio tiene los encabezados de la pol\u00edtica de seguridad de contenido (CSP) deshabilitados. Tener CSP deshabilitado es una configuraci\u00f3n no predeterminada, y tenerlo deshabilitado con el discourse-encrypt instalado generar\u00e1 una advertencia en el panel de administraci\u00f3n de Discourse. Esto se solucion\u00f3 en el commit `9c75810af9` que se incluye en la \u00faltima versi\u00f3n del complemento discourse-encrypt. Se recomienda a los usuarios que actualicen. Los usuarios que no puedan actualizar deben asegurarse de que los encabezados CSP est\u00e9n habilitados y configurados correctamente."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse-encrypt:*:*:*:*:*:discourse:*:*", "versionEndExcluding": "2023-09-28", "matchCriteriaId": "F107A6F2-A831-40B8-9052-CE35E247D142"}]}]}], "references": [{"url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/discourse/discourse-encrypt/commit/9c75810af9a474d7edaec67dea66f852c0ba1f4e", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse-encrypt/security/advisories/GHSA-5fh6-wp7p-xx7v", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse-encrypt/commit/9c75810af9a474d7edaec67dea66f852c0ba1f4e"}}