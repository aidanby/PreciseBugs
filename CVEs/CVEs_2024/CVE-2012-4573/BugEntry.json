{"buggy_code": ["# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2010 OpenStack LLC.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\n/images endpoint for Glance v1 API\n\"\"\"\n\nimport errno\nimport logging\nimport sys\nimport traceback\n\nfrom webob.exc import (HTTPError,\n                       HTTPNotFound,\n                       HTTPConflict,\n                       HTTPBadRequest,\n                       HTTPForbidden,\n                       HTTPRequestEntityTooLarge,\n                       HTTPServiceUnavailable,\n                      )\n\nfrom glance.api import policy\nimport glance.api.v1\nfrom glance.api.v1 import controller\nfrom glance.api.v1 import filters\nfrom glance.common import cfg\nfrom glance.common import exception\nfrom glance.common import wsgi\nfrom glance.common import utils\nimport glance.store\nimport glance.store.filesystem\nimport glance.store.http\nimport glance.store.rbd\nimport glance.store.s3\nimport glance.store.swift\nfrom glance.store import (get_from_backend,\n                          get_size_from_backend,\n                          schedule_delete_from_backend,\n                          get_store_from_location,\n                          get_store_from_scheme)\nfrom glance import registry\nfrom glance import notifier\n\n\nlogger = logging.getLogger(__name__)\nSUPPORTED_PARAMS = glance.api.v1.SUPPORTED_PARAMS\nSUPPORTED_FILTERS = glance.api.v1.SUPPORTED_FILTERS\n\n\n# 1 PiB, which is a *huge* image by anyone's measure.  This is just to protect\n# against client programming errors (or DoS attacks) in the image metadata.\n# We have a known limit of 1 << 63 in the database -- images.size is declared\n# as a BigInteger.\nIMAGE_SIZE_CAP = 1 << 50\n\n\nclass Controller(controller.BaseController):\n    \"\"\"\n    WSGI controller for images resource in Glance v1 API\n\n    The images resource API is a RESTful web service for image data. The API\n    is as follows::\n\n        GET /images -- Returns a set of brief metadata about images\n        GET /images/detail -- Returns a set of detailed metadata about\n                              images\n        HEAD /images/<ID> -- Return metadata about an image with id <ID>\n        GET /images/<ID> -- Return image data for image with id <ID>\n        POST /images -- Store image data and return metadata about the\n                        newly-stored image\n        PUT /images/<ID> -- Update image metadata and/or upload image\n                            data for a previously-reserved image\n        DELETE /images/<ID> -- Delete the image with id <ID>\n    \"\"\"\n\n    default_store_opt = cfg.StrOpt('default_store', default='file')\n\n    def __init__(self, conf):\n        self.conf = conf\n        self.conf.register_opt(self.default_store_opt)\n        glance.store.create_stores(conf)\n        self.verify_store_or_exit(self.conf.default_store)\n        self.notifier = notifier.Notifier(conf)\n        registry.configure_registry_client(conf)\n        self.policy = policy.Enforcer(conf)\n\n    def _enforce(self, req, action):\n        \"\"\"Authorize an action against our policies\"\"\"\n        try:\n            self.policy.enforce(req.context, action, {})\n        except exception.Forbidden:\n            raise HTTPForbidden()\n\n    def index(self, req):\n        \"\"\"\n        Returns the following information for all public, available images:\n\n            * id -- The opaque image identifier\n            * name -- The name of the image\n            * disk_format -- The disk image format\n            * container_format -- The \"container\" format of the image\n            * checksum -- MD5 checksum of the image data\n            * size -- Size of image data in bytes\n\n        :param req: The WSGI/Webob Request object\n        :retval The response body is a mapping of the following form::\n\n            {'images': [\n                {'id': <ID>,\n                 'name': <NAME>,\n                 'disk_format': <DISK_FORMAT>,\n                 'container_format': <DISK_FORMAT>,\n                 'checksum': <CHECKSUM>\n                 'size': <SIZE>}, ...\n            ]}\n        \"\"\"\n        self._enforce(req, 'get_images')\n        params = self._get_query_params(req)\n        try:\n            images = registry.get_images_list(req.context, **params)\n        except exception.Invalid, e:\n            raise HTTPBadRequest(explanation=\"%s\" % e)\n\n        return dict(images=images)\n\n    def detail(self, req):\n        \"\"\"\n        Returns detailed information for all public, available images\n\n        :param req: The WSGI/Webob Request object\n        :retval The response body is a mapping of the following form::\n\n            {'images': [\n                {'id': <ID>,\n                 'name': <NAME>,\n                 'size': <SIZE>,\n                 'disk_format': <DISK_FORMAT>,\n                 'container_format': <CONTAINER_FORMAT>,\n                 'checksum': <CHECKSUM>,\n                 'min_disk': <MIN_DISK>,\n                 'min_ram': <MIN_RAM>,\n                 'store': <STORE>,\n                 'status': <STATUS>,\n                 'created_at': <TIMESTAMP>,\n                 'updated_at': <TIMESTAMP>,\n                 'deleted_at': <TIMESTAMP>|<NONE>,\n                 'properties': {'distro': 'Ubuntu 10.04 LTS', ...}}, ...\n            ]}\n        \"\"\"\n        self._enforce(req, 'get_images')\n        params = self._get_query_params(req)\n        try:\n            images = registry.get_images_detail(req.context, **params)\n            # Strip out the Location attribute. Temporary fix for\n            # LP Bug #755916. This information is still coming back\n            # from the registry, since the API server still needs access\n            # to it, however we do not return this potential security\n            # information to the API end user...\n            for image in images:\n                del image['location']\n        except exception.Invalid, e:\n            raise HTTPBadRequest(explanation=\"%s\" % e)\n        return dict(images=images)\n\n    def _get_query_params(self, req):\n        \"\"\"\n        Extracts necessary query params from request.\n\n        :param req: the WSGI Request object\n        :retval dict of parameters that can be used by registry client\n        \"\"\"\n        params = {'filters': self._get_filters(req)}\n\n        for PARAM in SUPPORTED_PARAMS:\n            if PARAM in req.params:\n                params[PARAM] = req.params.get(PARAM)\n        return params\n\n    def _get_filters(self, req):\n        \"\"\"\n        Return a dictionary of query param filters from the request\n\n        :param req: the Request object coming from the wsgi layer\n        :retval a dict of key/value filters\n        \"\"\"\n        query_filters = {}\n        for param in req.params:\n            if param in SUPPORTED_FILTERS or param.startswith('property-'):\n                query_filters[param] = req.params.get(param)\n                if not filters.validate(param, query_filters[param]):\n                    raise HTTPBadRequest('Bad value passed to filter %s '\n                                         'got %s' % (param,\n                                                     query_filters[param]))\n        return query_filters\n\n    def meta(self, req, id):\n        \"\"\"\n        Returns metadata about an image in the HTTP headers of the\n        response object\n\n        :param req: The WSGI/Webob Request object\n        :param id: The opaque image identifier\n        :retval similar to 'show' method but without image_data\n\n        :raises HTTPNotFound if image metadata is not available to user\n        \"\"\"\n        self._enforce(req, 'get_image')\n        image_meta = self.get_image_meta_or_404(req, id)\n        del image_meta['location']\n        return {\n            'image_meta': image_meta\n        }\n\n    @staticmethod\n    def _validate_source(source, req):\n        \"\"\"\n        External sources (as specified via the location or copy-from headers)\n        are supported only over non-local store types, i.e. S3, Swift, HTTP.\n        Note the absence of file:// for security reasons, see LP bug #942118.\n        If the above constraint is violated, we reject with 400 \"Bad Request\".\n        \"\"\"\n        if source:\n            for scheme in ['s3', 'swift', 'http']:\n                if source.lower().startswith(scheme):\n                    return source\n            msg = _(\"External sourcing not supported for store %s\") % source\n            logger.error(msg)\n            raise HTTPBadRequest(msg, request=req, content_type=\"text/plain\")\n\n    @staticmethod\n    def _copy_from(req):\n        return req.headers.get('x-glance-api-copy-from')\n\n    @staticmethod\n    def _external_source(image_meta, req):\n        source = image_meta.get('location', Controller._copy_from(req))\n        return Controller._validate_source(source, req)\n\n    @staticmethod\n    def _get_from_store(where):\n        try:\n            image_data, image_size = get_from_backend(where)\n        except exception.NotFound, e:\n            raise HTTPNotFound(explanation=\"%s\" % e)\n        image_size = int(image_size) if image_size else None\n        return image_data, image_size\n\n    def show(self, req, id):\n        \"\"\"\n        Returns an iterator that can be used to retrieve an image's\n        data along with the image metadata.\n\n        :param req: The WSGI/Webob Request object\n        :param id: The opaque image identifier\n\n        :raises HTTPNotFound if image is not available to user\n        \"\"\"\n        self._enforce(req, 'get_image')\n        image_meta = self.get_active_image_meta_or_404(req, id)\n\n        if image_meta.get('size') == 0:\n            image_iterator = iter([])\n        else:\n            image_iterator, size = self._get_from_store(image_meta['location'])\n            image_meta['size'] = size or image_meta['size']\n\n        del image_meta['location']\n        return {\n            'image_iterator': image_iterator,\n            'image_meta': image_meta,\n        }\n\n    def _reserve(self, req, image_meta):\n        \"\"\"\n        Adds the image metadata to the registry and assigns\n        an image identifier if one is not supplied in the request\n        headers. Sets the image's status to `queued`.\n\n        :param req: The WSGI/Webob Request object\n        :param id: The opaque image identifier\n        :param image_meta: The image metadata\n\n        :raises HTTPConflict if image already exists\n        :raises HTTPBadRequest if image metadata is not valid\n        \"\"\"\n        location = self._external_source(image_meta, req)\n\n        image_meta['status'] = ('active' if image_meta.get('size') == 0\n                                else 'queued')\n\n        if location:\n            store = get_store_from_location(location)\n            # check the store exists before we hit the registry, but we\n            # don't actually care what it is at this point\n            self.get_store_or_400(req, store)\n\n            # retrieve the image size from remote store (if not provided)\n            image_meta['size'] = self._get_size(image_meta, location)\n        else:\n            # Ensure that the size attribute is set to zero for directly\n            # uploadable images (if not provided). The size will be set\n            # to a non-zero value during upload\n            image_meta['size'] = image_meta.get('size', 0)\n\n        try:\n            image_meta = registry.add_image_metadata(req.context, image_meta)\n            return image_meta\n        except exception.Duplicate:\n            msg = (_(\"An image with identifier %s already exists\")\n                  % image_meta['id'])\n            logger.error(msg)\n            raise HTTPConflict(msg, request=req, content_type=\"text/plain\")\n        except exception.Invalid, e:\n            msg = (_(\"Failed to reserve image. Got error: %(e)s\") % locals())\n            for line in msg.split('\\n'):\n                logger.error(line)\n            raise HTTPBadRequest(msg, request=req, content_type=\"text/plain\")\n        except exception.Forbidden:\n            msg = _(\"Forbidden to reserve image.\")\n            logger.error(msg)\n            raise HTTPForbidden(msg, request=req, content_type=\"text/plain\")\n\n    def _upload(self, req, image_meta):\n        \"\"\"\n        Uploads the payload of the request to a backend store in\n        Glance. If the `x-image-meta-store` header is set, Glance\n        will attempt to use that store, if not, Glance will use the\n        store set by the flag `default_store`.\n\n        :param req: The WSGI/Webob Request object\n        :param image_meta: Mapping of metadata about image\n\n        :raises HTTPConflict if image already exists\n        :retval The location where the image was stored\n        \"\"\"\n\n        copy_from = self._copy_from(req)\n        if copy_from:\n            image_data, image_size = self._get_from_store(copy_from)\n            image_meta['size'] = image_size or image_meta['size']\n        else:\n            try:\n                req.get_content_type('application/octet-stream')\n            except exception.InvalidContentType:\n                self._safe_kill(req, image_meta['id'])\n                msg = _(\"Content-Type must be application/octet-stream\")\n                logger.error(msg)\n                raise HTTPBadRequest(explanation=msg)\n\n            image_data = req.body_file\n\n            if req.content_length:\n                image_size = int(req.content_length)\n            elif 'x-image-meta-size' in req.headers:\n                image_size = int(req.headers['x-image-meta-size'])\n            else:\n                logger.debug(_(\"Got request with no content-length and no \"\n                               \"x-image-meta-size header\"))\n                image_size = 0\n\n        store_name = req.headers.get('x-image-meta-store',\n                                     self.conf.default_store)\n\n        store = self.get_store_or_400(req, store_name)\n\n        image_id = image_meta['id']\n        logger.debug(_(\"Setting image %s to status 'saving'\"), image_id)\n        registry.update_image_metadata(req.context, image_id,\n                                       {'status': 'saving'})\n        try:\n            logger.debug(_(\"Uploading image data for image %(image_id)s \"\n                         \"to %(store_name)s store\"), locals())\n\n            if image_size > IMAGE_SIZE_CAP:\n                max_image_size = IMAGE_SIZE_CAP\n                msg = _(\"Denying attempt to upload image larger than \"\n                        \"%(max_image_size)d. Supplied image size was \"\n                        \"%(image_size)d\") % locals()\n                logger.warn(msg)\n                raise HTTPBadRequest(msg, request=req)\n\n            location, size, checksum = store.add(image_meta['id'],\n                                                 image_data,\n                                                 image_size)\n\n            # Verify any supplied checksum value matches checksum\n            # returned from store when adding image\n            supplied_checksum = image_meta.get('checksum')\n            if supplied_checksum and supplied_checksum != checksum:\n                msg = _(\"Supplied checksum (%(supplied_checksum)s) and \"\n                       \"checksum generated from uploaded image \"\n                       \"(%(checksum)s) did not match. Setting image \"\n                       \"status to 'killed'.\") % locals()\n                logger.error(msg)\n                self._safe_kill(req, image_id)\n                raise HTTPBadRequest(msg, content_type=\"text/plain\",\n                                     request=req)\n\n            # Update the database with the checksum returned\n            # from the backend store\n            logger.debug(_(\"Updating image %(image_id)s data. \"\n                         \"Checksum set to %(checksum)s, size set \"\n                         \"to %(size)d\"), locals())\n            update_data = {'checksum': checksum,\n                           'size': size}\n            image_meta = registry.update_image_metadata(req.context,\n                                                        image_id,\n                                                        update_data)\n            self.notifier.info('image.upload', image_meta)\n\n            return location\n\n        except exception.Duplicate, e:\n            msg = _(\"Attempt to upload duplicate image: %s\") % e\n            logger.error(msg)\n            self._safe_kill(req, image_id)\n            self.notifier.error('image.upload', msg)\n            raise HTTPConflict(msg, request=req)\n\n        except exception.Forbidden, e:\n            msg = _(\"Forbidden upload attempt: %s\") % e\n            logger.error(msg)\n            self._safe_kill(req, image_id)\n            self.notifier.error('image.upload', msg)\n            raise HTTPForbidden(msg, request=req, content_type=\"text/plain\")\n\n        except exception.StorageFull, e:\n            msg = _(\"Image storage media is full: %s\") % e\n            logger.error(msg)\n            self._safe_kill(req, image_id)\n            self.notifier.error('image.upload', msg)\n            raise HTTPRequestEntityTooLarge(msg, request=req,\n                                            content_type='text/plain')\n\n        except exception.StorageWriteDenied, e:\n            msg = _(\"Insufficient permissions on image storage media: %s\") % e\n            logger.error(msg)\n            self._safe_kill(req, image_id)\n            self.notifier.error('image.upload', msg)\n            raise HTTPServiceUnavailable(msg, request=req,\n                                         content_type='text/plain')\n\n        except HTTPError, e:\n            self._safe_kill(req, image_id)\n            self.notifier.error('image.upload', e.explanation)\n            raise\n\n        except Exception, e:\n            tb_info = traceback.format_exc()\n            logger.error(tb_info)\n\n            self._safe_kill(req, image_id)\n\n            msg = _(\"Error uploading image: (%(class_name)s): \"\n                    \"%(exc)s\") % ({'class_name': e.__class__.__name__,\n                    'exc': str(e)})\n\n            self.notifier.error('image.upload', msg)\n            raise HTTPBadRequest(msg, request=req)\n\n    def _activate(self, req, image_id, location):\n        \"\"\"\n        Sets the image status to `active` and the image's location\n        attribute.\n\n        :param req: The WSGI/Webob Request object\n        :param image_id: Opaque image identifier\n        :param location: Location of where Glance stored this image\n        \"\"\"\n        image_meta = {}\n        image_meta['location'] = location\n        image_meta['status'] = 'active'\n\n        try:\n            return registry.update_image_metadata(req.context,\n                                                  image_id,\n                                                  image_meta)\n        except exception.Invalid, e:\n            msg = (_(\"Failed to activate image. Got error: %(e)s\")\n                   % locals())\n            for line in msg.split('\\n'):\n                logger.error(line)\n            self.notifier.error('image.update', msg)\n            raise HTTPBadRequest(msg, request=req, content_type=\"text/plain\")\n\n    def _kill(self, req, image_id):\n        \"\"\"\n        Marks the image status to `killed`.\n\n        :param req: The WSGI/Webob Request object\n        :param image_id: Opaque image identifier\n        \"\"\"\n        registry.update_image_metadata(req.context, image_id,\n                                       {'status': 'killed'})\n\n    def _safe_kill(self, req, image_id):\n        \"\"\"\n        Mark image killed without raising exceptions if it fails.\n\n        Since _kill is meant to be called from exceptions handlers, it should\n        not raise itself, rather it should just log its error.\n\n        :param req: The WSGI/Webob Request object\n        :param image_id: Opaque image identifier\n        \"\"\"\n        try:\n            self._kill(req, image_id)\n        except Exception, e:\n            logger.error(_(\"Unable to kill image %(id)s: \"\n                           \"%(exc)s\") % ({'id': image_id,\n                           'exc': repr(e)}))\n\n    def _upload_and_activate(self, req, image_meta):\n        \"\"\"\n        Safely uploads the image data in the request payload\n        and activates the image in the registry after a successful\n        upload.\n\n        :param req: The WSGI/Webob Request object\n        :param image_meta: Mapping of metadata about image\n\n        :retval Mapping of updated image data\n        \"\"\"\n        image_id = image_meta['id']\n        # This is necessary because of a bug in Webob 1.0.2 - 1.0.7\n        # See: https://bitbucket.org/ianb/webob/\n        # issue/12/fix-for-issue-6-broke-chunked-transfer\n        req.is_body_readable = True\n        location = self._upload(req, image_meta)\n        return self._activate(req, image_id, location)\n\n    def _get_size(self, image_meta, location):\n        # retrieve the image size from remote store (if not provided)\n        return image_meta.get('size', 0) or get_size_from_backend(location)\n\n    def _handle_source(self, req, image_id, image_meta, image_data):\n        if image_data or self._copy_from(req):\n            image_meta = self._upload_and_activate(req, image_meta)\n        else:\n            location = image_meta.get('location')\n            if location:\n                image_meta = self._activate(req, image_id, location)\n        return image_meta\n\n    def create(self, req, image_meta, image_data):\n        \"\"\"\n        Adds a new image to Glance. Four scenarios exist when creating an\n        image:\n\n        1. If the image data is available directly for upload, create can be\n           passed the image data as the request body and the metadata as the\n           request headers. The image will initially be 'queued', during\n           upload it will be in the 'saving' status, and then 'killed' or\n           'active' depending on whether the upload completed successfully.\n\n        2. If the image data exists somewhere else, you can upload indirectly\n           from the external source using the x-glance-api-copy-from header.\n           Once the image is uploaded, the external store is not subsequently\n           consulted, i.e. the image content is served out from the configured\n           glance image store.  State transitions are as for option #1.\n\n        3. If the image data exists somewhere else, you can reference the\n           source using the x-image-meta-location header. The image content\n           will be served out from the external store, i.e. is never uploaded\n           to the configured glance image store.\n\n        4. If the image data is not available yet, but you'd like reserve a\n           spot for it, you can omit the data and a record will be created in\n           the 'queued' state. This exists primarily to maintain backwards\n           compatibility with OpenStack/Rackspace API semantics.\n\n        The request body *must* be encoded as application/octet-stream,\n        otherwise an HTTPBadRequest is returned.\n\n        Upon a successful save of the image data and metadata, a response\n        containing metadata about the image is returned, including its\n        opaque identifier.\n\n        :param req: The WSGI/Webob Request object\n        :param image_meta: Mapping of metadata about image\n        :param image_data: Actual image data that is to be stored\n\n        :raises HTTPBadRequest if x-image-meta-location is missing\n                and the request body is not application/octet-stream\n                image data.\n        \"\"\"\n        self._enforce(req, 'add_image')\n        if image_meta.get('is_public'):\n            self._enforce(req, 'publicize_image')\n        if req.context.read_only:\n            msg = _(\"Read-only access\")\n            logger.debug(msg)\n            raise HTTPForbidden(msg, request=req,\n                                content_type=\"text/plain\")\n\n        image_meta = self._reserve(req, image_meta)\n        id = image_meta['id']\n\n        image_meta = self._handle_source(req, id, image_meta, image_data)\n\n        # Prevent client from learning the location, as it\n        # could contain security credentials\n        image_meta.pop('location', None)\n\n        return {'image_meta': image_meta}\n\n    def update(self, req, id, image_meta, image_data):\n        \"\"\"\n        Updates an existing image with the registry.\n\n        :param request: The WSGI/Webob Request object\n        :param id: The opaque image identifier\n\n        :retval Returns the updated image information as a mapping\n        \"\"\"\n        self._enforce(req, 'modify_image')\n        if image_meta.get('is_public'):\n            self._enforce(req, 'publicize_image')\n        if req.context.read_only:\n            msg = _(\"Read-only access\")\n            logger.debug(msg)\n            raise HTTPForbidden(msg, request=req,\n                                content_type=\"text/plain\")\n\n        orig_image_meta = self.get_image_meta_or_404(req, id)\n        orig_status = orig_image_meta['status']\n\n        # The default behaviour for a PUT /images/<IMAGE_ID> is to\n        # override any properties that were previously set. This, however,\n        # leads to a number of issues for the common use case where a caller\n        # registers an image with some properties and then almost immediately\n        # uploads an image file along with some more properties. Here, we\n        # check for a special header value to be false in order to force\n        # properties NOT to be purged. However we also disable purging of\n        # properties if an image file is being uploaded...\n        purge_props = req.headers.get('x-glance-registry-purge-props', True)\n        purge_props = (utils.bool_from_string(purge_props) and\n                       image_data is None)\n\n        if image_data is not None and orig_status != 'queued':\n            raise HTTPConflict(_(\"Cannot upload to an unqueued image\"))\n\n        # Only allow the Location|Copy-From fields to be modified if the\n        # image is in queued status, which indicates that the user called\n        # POST /images but originally supply neither a Location|Copy-From\n        # field NOR image data\n        location = self._external_source(image_meta, req)\n        reactivating = orig_status != 'queued' and location\n        activating = orig_status == 'queued' and (location or image_data)\n\n        if reactivating:\n            msg = _(\"Attempted to update Location field for an image \"\n                    \"not in queued status.\")\n            raise HTTPBadRequest(msg, request=req, content_type=\"text/plain\")\n\n        try:\n            if location:\n                image_meta['size'] = self._get_size(image_meta, location)\n\n            image_meta = registry.update_image_metadata(req.context,\n                                                        id,\n                                                        image_meta,\n                                                        purge_props)\n\n            if activating:\n                image_meta = self._handle_source(req, id, image_meta,\n                                                 image_data)\n        except exception.Invalid, e:\n            msg = (_(\"Failed to update image metadata. Got error: %(e)s\")\n                   % locals())\n            for line in msg.split('\\n'):\n                logger.error(line)\n            self.notifier.error('image.update', msg)\n            raise HTTPBadRequest(msg, request=req, content_type=\"text/plain\")\n        except exception.NotFound, e:\n            msg = (\"Failed to find image to update: %(e)s\" % locals())\n            for line in msg.split('\\n'):\n                logger.info(line)\n            self.notifier.info('image.update', msg)\n            raise HTTPNotFound(msg, request=req, content_type=\"text/plain\")\n        except exception.Forbidden, e:\n            msg = (\"Forbidden to update image: %(e)s\" % locals())\n            for line in msg.split('\\n'):\n                logger.info(line)\n            self.notifier.info('image.update', msg)\n            raise HTTPForbidden(msg, request=req, content_type=\"text/plain\")\n        else:\n            self.notifier.info('image.update', image_meta)\n\n        # Prevent client from learning the location, as it\n        # could contain security credentials\n        image_meta.pop('location', None)\n\n        return {'image_meta': image_meta}\n\n    def delete(self, req, id):\n        \"\"\"\n        Deletes the image and all its chunks from the Glance\n\n        :param req: The WSGI/Webob Request object\n        :param id: The opaque image identifier\n\n        :raises HttpBadRequest if image registry is invalid\n        :raises HttpNotFound if image or any chunk is not available\n        :raises HttpUnauthorized if image or any chunk is not\n                deleteable by the requesting user\n        \"\"\"\n        self._enforce(req, 'delete_image')\n        if req.context.read_only:\n            msg = _(\"Read-only access\")\n            logger.debug(msg)\n            raise HTTPForbidden(msg, request=req,\n                                content_type=\"text/plain\")\n\n        image = self.get_image_meta_or_404(req, id)\n        if image['protected']:\n            msg = _(\"Image is protected\")\n            logger.debug(msg)\n            raise HTTPForbidden(msg, request=req,\n                                content_type=\"text/plain\")\n\n        # The image's location field may be None in the case\n        # of a saving or queued image, therefore don't ask a backend\n        # to delete the image if the backend doesn't yet store it.\n        # See https://bugs.launchpad.net/glance/+bug/747799\n        try:\n            if image['location']:\n                schedule_delete_from_backend(image['location'], self.conf,\n                                             req.context, id)\n            registry.delete_image_metadata(req.context, id)\n        except exception.NotFound, e:\n            msg = (\"Failed to find image to delete: %(e)s\" % locals())\n            for line in msg.split('\\n'):\n                logger.info(line)\n            self.notifier.info('image.delete', msg)\n            raise HTTPNotFound(msg, request=req, content_type=\"text/plain\")\n        except exception.Forbidden, e:\n            msg = (\"Forbidden to delete image: %(e)s\" % locals())\n            for line in msg.split('\\n'):\n                logger.info(line)\n            self.notifier.info('image.delete', msg)\n            raise HTTPForbidden(msg, request=req, content_type=\"text/plain\")\n        else:\n            self.notifier.info('image.delete', id)\n\n    def get_store_or_400(self, request, store_name):\n        \"\"\"\n        Grabs the storage backend for the supplied store name\n        or raises an HTTPBadRequest (400) response\n\n        :param request: The WSGI/Webob Request object\n        :param store_name: The backend store name\n\n        :raises HTTPNotFound if store does not exist\n        \"\"\"\n        try:\n            return get_store_from_scheme(store_name)\n        except exception.UnknownScheme:\n            msg = (_(\"Requested store %s not available on this Glance server\")\n                   % store_name)\n            logger.error(msg)\n            raise HTTPBadRequest(msg, request=request,\n                                 content_type='text/plain')\n\n    def verify_store_or_exit(self, store_name):\n        \"\"\"\n        Verifies availability of the storage backend for the\n        given store name or exits\n\n        :param store_name: The backend store name\n        \"\"\"\n        try:\n            get_store_from_scheme(store_name)\n        except exception.UnknownScheme:\n            msg = (_(\"Default store %s not available on this Glance server\\n\")\n                   % store_name)\n            logger.error(msg)\n            # message on stderr will only be visible if started directly via\n            # bin/glance-api, as opposed to being daemonized by glance-control\n            sys.stderr.write(msg)\n            sys.exit(255)\n\n\nclass ImageDeserializer(wsgi.JSONRequestDeserializer):\n    \"\"\"Handles deserialization of specific controller method requests.\"\"\"\n\n    def _deserialize(self, request):\n        result = {}\n        try:\n            result['image_meta'] = utils.get_image_meta_from_headers(request)\n        except exception.Invalid:\n            image_size_str = request.headers['x-image-meta-size']\n            msg = _(\"Incoming image size of %s was not convertible to \"\n                    \"an integer.\") % image_size_str\n            raise HTTPBadRequest(msg, request=request)\n\n        image_meta = result['image_meta']\n        if 'size' in image_meta:\n            incoming_image_size = image_meta['size']\n            if incoming_image_size > IMAGE_SIZE_CAP:\n                max_image_size = IMAGE_SIZE_CAP\n                msg = _(\"Denying attempt to upload image larger than \"\n                        \"%(max_image_size)d. Supplied image size was \"\n                        \"%(incoming_image_size)d\") % locals()\n                logger.warn(msg)\n                raise HTTPBadRequest(msg, request=request)\n\n        data = request.body_file if self.has_body(request) else None\n        result['image_data'] = data\n        return result\n\n    def create(self, request):\n        return self._deserialize(request)\n\n    def update(self, request):\n        return self._deserialize(request)\n\n\nclass ImageSerializer(wsgi.JSONResponseSerializer):\n    \"\"\"Handles serialization of specific controller method responses.\"\"\"\n\n    def __init__(self, conf):\n        self.conf = conf\n        self.notifier = notifier.Notifier(conf)\n\n    def _inject_location_header(self, response, image_meta):\n        location = self._get_image_location(image_meta)\n        response.headers['Location'] = location\n\n    def _inject_checksum_header(self, response, image_meta):\n        response.headers['ETag'] = image_meta['checksum']\n\n    def _inject_image_meta_headers(self, response, image_meta):\n        \"\"\"\n        Given a response and mapping of image metadata, injects\n        the Response with a set of HTTP headers for the image\n        metadata. Each main image metadata field is injected\n        as a HTTP header with key 'x-image-meta-<FIELD>' except\n        for the properties field, which is further broken out\n        into a set of 'x-image-meta-property-<KEY>' headers\n\n        :param response: The Webob Response object\n        :param image_meta: Mapping of image metadata\n        \"\"\"\n        headers = utils.image_meta_to_http_headers(image_meta)\n\n        for k, v in headers.items():\n            response.headers[k] = v\n\n    def _get_image_location(self, image_meta):\n        \"\"\"Build a relative url to reach the image defined by image_meta.\"\"\"\n        return \"/v1/images/%s\" % image_meta['id']\n\n    def meta(self, response, result):\n        image_meta = result['image_meta']\n        self._inject_image_meta_headers(response, image_meta)\n        self._inject_location_header(response, image_meta)\n        self._inject_checksum_header(response, image_meta)\n        return response\n\n    def image_send_notification(self, bytes_written, expected_size,\n                                image_meta, request):\n        \"\"\"Send an image.send message to the notifier.\"\"\"\n        try:\n            context = request.context\n            payload = {\n                'bytes_sent': bytes_written,\n                'image_id': image_meta['id'],\n                'owner_id': image_meta['owner'],\n                'receiver_tenant_id': context.tenant,\n                'receiver_user_id': context.user,\n                'destination_ip': request.remote_addr,\n            }\n            if bytes_written != expected_size:\n                self.notifier.error('image.send', payload)\n            else:\n                self.notifier.info('image.send', payload)\n        except Exception, err:\n            msg = _(\"An error occurred during image.send\"\n                    \" notification: %(err)s\") % locals()\n            logger.error(msg)\n\n    def show(self, response, result):\n        image_meta = result['image_meta']\n        image_id = image_meta['id']\n\n        # We use a secondary iterator here to wrap the\n        # iterator coming back from the store driver in\n        # order to check for disconnections from the backend\n        # storage connections and log an error if the size of\n        # the transferred image is not the same as the expected\n        # size of the image file. See LP Bug #882585.\n        def checked_iter(image_id, expected_size, image_iter):\n            bytes_written = 0\n\n            def notify_image_sent_hook(env):\n                self.image_send_notification(bytes_written, expected_size,\n                                             image_meta, response.request)\n\n            # Add hook to process after response is fully sent\n            if 'eventlet.posthooks' in response.request.environ:\n                response.request.environ['eventlet.posthooks'].append(\n                    (notify_image_sent_hook, (), {}))\n\n            try:\n                for chunk in image_iter:\n                    yield chunk\n                    bytes_written += len(chunk)\n            except Exception, err:\n                msg = _(\"An error occurred reading from backend storage \"\n                        \"for image %(image_id): %(err)s\") % locals()\n                logger.error(msg)\n                raise\n\n            if expected_size != bytes_written:\n                msg = _(\"Backend storage for image %(image_id)s \"\n                        \"disconnected after writing only %(bytes_written)d \"\n                        \"bytes\") % locals()\n                logger.error(msg)\n                raise IOError(errno.EPIPE, _(\"Corrupt image download for \"\n                                             \"image %(image_id)s\") % locals())\n\n        image_iter = result['image_iterator']\n        # image_meta['size'] is a str\n        expected_size = int(image_meta['size'])\n        response.app_iter = checked_iter(image_id, expected_size, image_iter)\n        # Using app_iter blanks content-length, so we set it here...\n        response.headers['Content-Length'] = image_meta['size']\n        response.headers['Content-Type'] = 'application/octet-stream'\n\n        self._inject_image_meta_headers(response, image_meta)\n        self._inject_location_header(response, image_meta)\n        self._inject_checksum_header(response, image_meta)\n\n        return response\n\n    def update(self, response, result):\n        image_meta = result['image_meta']\n        response.body = self.to_json(dict(image=image_meta))\n        response.headers['Content-Type'] = 'application/json'\n        self._inject_location_header(response, image_meta)\n        self._inject_checksum_header(response, image_meta)\n        return response\n\n    def create(self, response, result):\n        image_meta = result['image_meta']\n        response.status = 201\n        response.headers['Content-Type'] = 'application/json'\n        response.body = self.to_json(dict(image=image_meta))\n        self._inject_location_header(response, image_meta)\n        self._inject_checksum_header(response, image_meta)\n        return response\n\n\ndef create_resource(conf):\n    \"\"\"Images resource factory method\"\"\"\n    deserializer = ImageDeserializer()\n    serializer = ImageSerializer(conf)\n    return wsgi.Resource(Controller(conf), deserializer, serializer)\n"], "fixing_code": ["# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2010 OpenStack LLC.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\n/images endpoint for Glance v1 API\n\"\"\"\n\nimport errno\nimport logging\nimport sys\nimport traceback\n\nfrom webob.exc import (HTTPError,\n                       HTTPNotFound,\n                       HTTPConflict,\n                       HTTPBadRequest,\n                       HTTPForbidden,\n                       HTTPRequestEntityTooLarge,\n                       HTTPServiceUnavailable,\n                      )\n\nfrom glance.api import policy\nimport glance.api.v1\nfrom glance.api.v1 import controller\nfrom glance.api.v1 import filters\nfrom glance.common import cfg\nfrom glance.common import exception\nfrom glance.common import wsgi\nfrom glance.common import utils\nimport glance.store\nimport glance.store.filesystem\nimport glance.store.http\nimport glance.store.rbd\nimport glance.store.s3\nimport glance.store.swift\nfrom glance.store import (get_from_backend,\n                          get_size_from_backend,\n                          schedule_delete_from_backend,\n                          get_store_from_location,\n                          get_store_from_scheme)\nfrom glance import registry\nfrom glance import notifier\n\n\nlogger = logging.getLogger(__name__)\nSUPPORTED_PARAMS = glance.api.v1.SUPPORTED_PARAMS\nSUPPORTED_FILTERS = glance.api.v1.SUPPORTED_FILTERS\n\n\n# 1 PiB, which is a *huge* image by anyone's measure.  This is just to protect\n# against client programming errors (or DoS attacks) in the image metadata.\n# We have a known limit of 1 << 63 in the database -- images.size is declared\n# as a BigInteger.\nIMAGE_SIZE_CAP = 1 << 50\n\n\nclass Controller(controller.BaseController):\n    \"\"\"\n    WSGI controller for images resource in Glance v1 API\n\n    The images resource API is a RESTful web service for image data. The API\n    is as follows::\n\n        GET /images -- Returns a set of brief metadata about images\n        GET /images/detail -- Returns a set of detailed metadata about\n                              images\n        HEAD /images/<ID> -- Return metadata about an image with id <ID>\n        GET /images/<ID> -- Return image data for image with id <ID>\n        POST /images -- Store image data and return metadata about the\n                        newly-stored image\n        PUT /images/<ID> -- Update image metadata and/or upload image\n                            data for a previously-reserved image\n        DELETE /images/<ID> -- Delete the image with id <ID>\n    \"\"\"\n\n    default_store_opt = cfg.StrOpt('default_store', default='file')\n\n    def __init__(self, conf):\n        self.conf = conf\n        self.conf.register_opt(self.default_store_opt)\n        glance.store.create_stores(conf)\n        self.verify_store_or_exit(self.conf.default_store)\n        self.notifier = notifier.Notifier(conf)\n        registry.configure_registry_client(conf)\n        self.policy = policy.Enforcer(conf)\n\n    def _enforce(self, req, action):\n        \"\"\"Authorize an action against our policies\"\"\"\n        try:\n            self.policy.enforce(req.context, action, {})\n        except exception.Forbidden:\n            raise HTTPForbidden()\n\n    def index(self, req):\n        \"\"\"\n        Returns the following information for all public, available images:\n\n            * id -- The opaque image identifier\n            * name -- The name of the image\n            * disk_format -- The disk image format\n            * container_format -- The \"container\" format of the image\n            * checksum -- MD5 checksum of the image data\n            * size -- Size of image data in bytes\n\n        :param req: The WSGI/Webob Request object\n        :retval The response body is a mapping of the following form::\n\n            {'images': [\n                {'id': <ID>,\n                 'name': <NAME>,\n                 'disk_format': <DISK_FORMAT>,\n                 'container_format': <DISK_FORMAT>,\n                 'checksum': <CHECKSUM>\n                 'size': <SIZE>}, ...\n            ]}\n        \"\"\"\n        self._enforce(req, 'get_images')\n        params = self._get_query_params(req)\n        try:\n            images = registry.get_images_list(req.context, **params)\n        except exception.Invalid, e:\n            raise HTTPBadRequest(explanation=\"%s\" % e)\n\n        return dict(images=images)\n\n    def detail(self, req):\n        \"\"\"\n        Returns detailed information for all public, available images\n\n        :param req: The WSGI/Webob Request object\n        :retval The response body is a mapping of the following form::\n\n            {'images': [\n                {'id': <ID>,\n                 'name': <NAME>,\n                 'size': <SIZE>,\n                 'disk_format': <DISK_FORMAT>,\n                 'container_format': <CONTAINER_FORMAT>,\n                 'checksum': <CHECKSUM>,\n                 'min_disk': <MIN_DISK>,\n                 'min_ram': <MIN_RAM>,\n                 'store': <STORE>,\n                 'status': <STATUS>,\n                 'created_at': <TIMESTAMP>,\n                 'updated_at': <TIMESTAMP>,\n                 'deleted_at': <TIMESTAMP>|<NONE>,\n                 'properties': {'distro': 'Ubuntu 10.04 LTS', ...}}, ...\n            ]}\n        \"\"\"\n        self._enforce(req, 'get_images')\n        params = self._get_query_params(req)\n        try:\n            images = registry.get_images_detail(req.context, **params)\n            # Strip out the Location attribute. Temporary fix for\n            # LP Bug #755916. This information is still coming back\n            # from the registry, since the API server still needs access\n            # to it, however we do not return this potential security\n            # information to the API end user...\n            for image in images:\n                del image['location']\n        except exception.Invalid, e:\n            raise HTTPBadRequest(explanation=\"%s\" % e)\n        return dict(images=images)\n\n    def _get_query_params(self, req):\n        \"\"\"\n        Extracts necessary query params from request.\n\n        :param req: the WSGI Request object\n        :retval dict of parameters that can be used by registry client\n        \"\"\"\n        params = {'filters': self._get_filters(req)}\n\n        for PARAM in SUPPORTED_PARAMS:\n            if PARAM in req.params:\n                params[PARAM] = req.params.get(PARAM)\n        return params\n\n    def _get_filters(self, req):\n        \"\"\"\n        Return a dictionary of query param filters from the request\n\n        :param req: the Request object coming from the wsgi layer\n        :retval a dict of key/value filters\n        \"\"\"\n        query_filters = {}\n        for param in req.params:\n            if param in SUPPORTED_FILTERS or param.startswith('property-'):\n                query_filters[param] = req.params.get(param)\n                if not filters.validate(param, query_filters[param]):\n                    raise HTTPBadRequest('Bad value passed to filter %s '\n                                         'got %s' % (param,\n                                                     query_filters[param]))\n        return query_filters\n\n    def meta(self, req, id):\n        \"\"\"\n        Returns metadata about an image in the HTTP headers of the\n        response object\n\n        :param req: The WSGI/Webob Request object\n        :param id: The opaque image identifier\n        :retval similar to 'show' method but without image_data\n\n        :raises HTTPNotFound if image metadata is not available to user\n        \"\"\"\n        self._enforce(req, 'get_image')\n        image_meta = self.get_image_meta_or_404(req, id)\n        del image_meta['location']\n        return {\n            'image_meta': image_meta\n        }\n\n    @staticmethod\n    def _validate_source(source, req):\n        \"\"\"\n        External sources (as specified via the location or copy-from headers)\n        are supported only over non-local store types, i.e. S3, Swift, HTTP.\n        Note the absence of file:// for security reasons, see LP bug #942118.\n        If the above constraint is violated, we reject with 400 \"Bad Request\".\n        \"\"\"\n        if source:\n            for scheme in ['s3', 'swift', 'http']:\n                if source.lower().startswith(scheme):\n                    return source\n            msg = _(\"External sourcing not supported for store %s\") % source\n            logger.error(msg)\n            raise HTTPBadRequest(msg, request=req, content_type=\"text/plain\")\n\n    @staticmethod\n    def _copy_from(req):\n        return req.headers.get('x-glance-api-copy-from')\n\n    @staticmethod\n    def _external_source(image_meta, req):\n        source = image_meta.get('location', Controller._copy_from(req))\n        return Controller._validate_source(source, req)\n\n    @staticmethod\n    def _get_from_store(where):\n        try:\n            image_data, image_size = get_from_backend(where)\n        except exception.NotFound, e:\n            raise HTTPNotFound(explanation=\"%s\" % e)\n        image_size = int(image_size) if image_size else None\n        return image_data, image_size\n\n    def show(self, req, id):\n        \"\"\"\n        Returns an iterator that can be used to retrieve an image's\n        data along with the image metadata.\n\n        :param req: The WSGI/Webob Request object\n        :param id: The opaque image identifier\n\n        :raises HTTPNotFound if image is not available to user\n        \"\"\"\n        self._enforce(req, 'get_image')\n        image_meta = self.get_active_image_meta_or_404(req, id)\n\n        if image_meta.get('size') == 0:\n            image_iterator = iter([])\n        else:\n            image_iterator, size = self._get_from_store(image_meta['location'])\n            image_meta['size'] = size or image_meta['size']\n\n        del image_meta['location']\n        return {\n            'image_iterator': image_iterator,\n            'image_meta': image_meta,\n        }\n\n    def _reserve(self, req, image_meta):\n        \"\"\"\n        Adds the image metadata to the registry and assigns\n        an image identifier if one is not supplied in the request\n        headers. Sets the image's status to `queued`.\n\n        :param req: The WSGI/Webob Request object\n        :param id: The opaque image identifier\n        :param image_meta: The image metadata\n\n        :raises HTTPConflict if image already exists\n        :raises HTTPBadRequest if image metadata is not valid\n        \"\"\"\n        location = self._external_source(image_meta, req)\n\n        image_meta['status'] = ('active' if image_meta.get('size') == 0\n                                else 'queued')\n\n        if location:\n            store = get_store_from_location(location)\n            # check the store exists before we hit the registry, but we\n            # don't actually care what it is at this point\n            self.get_store_or_400(req, store)\n\n            # retrieve the image size from remote store (if not provided)\n            image_meta['size'] = self._get_size(image_meta, location)\n        else:\n            # Ensure that the size attribute is set to zero for directly\n            # uploadable images (if not provided). The size will be set\n            # to a non-zero value during upload\n            image_meta['size'] = image_meta.get('size', 0)\n\n        try:\n            image_meta = registry.add_image_metadata(req.context, image_meta)\n            return image_meta\n        except exception.Duplicate:\n            msg = (_(\"An image with identifier %s already exists\")\n                  % image_meta['id'])\n            logger.error(msg)\n            raise HTTPConflict(msg, request=req, content_type=\"text/plain\")\n        except exception.Invalid, e:\n            msg = (_(\"Failed to reserve image. Got error: %(e)s\") % locals())\n            for line in msg.split('\\n'):\n                logger.error(line)\n            raise HTTPBadRequest(msg, request=req, content_type=\"text/plain\")\n        except exception.Forbidden:\n            msg = _(\"Forbidden to reserve image.\")\n            logger.error(msg)\n            raise HTTPForbidden(msg, request=req, content_type=\"text/plain\")\n\n    def _upload(self, req, image_meta):\n        \"\"\"\n        Uploads the payload of the request to a backend store in\n        Glance. If the `x-image-meta-store` header is set, Glance\n        will attempt to use that store, if not, Glance will use the\n        store set by the flag `default_store`.\n\n        :param req: The WSGI/Webob Request object\n        :param image_meta: Mapping of metadata about image\n\n        :raises HTTPConflict if image already exists\n        :retval The location where the image was stored\n        \"\"\"\n\n        copy_from = self._copy_from(req)\n        if copy_from:\n            image_data, image_size = self._get_from_store(copy_from)\n            image_meta['size'] = image_size or image_meta['size']\n        else:\n            try:\n                req.get_content_type('application/octet-stream')\n            except exception.InvalidContentType:\n                self._safe_kill(req, image_meta['id'])\n                msg = _(\"Content-Type must be application/octet-stream\")\n                logger.error(msg)\n                raise HTTPBadRequest(explanation=msg)\n\n            image_data = req.body_file\n\n            if req.content_length:\n                image_size = int(req.content_length)\n            elif 'x-image-meta-size' in req.headers:\n                image_size = int(req.headers['x-image-meta-size'])\n            else:\n                logger.debug(_(\"Got request with no content-length and no \"\n                               \"x-image-meta-size header\"))\n                image_size = 0\n\n        store_name = req.headers.get('x-image-meta-store',\n                                     self.conf.default_store)\n\n        store = self.get_store_or_400(req, store_name)\n\n        image_id = image_meta['id']\n        logger.debug(_(\"Setting image %s to status 'saving'\"), image_id)\n        registry.update_image_metadata(req.context, image_id,\n                                       {'status': 'saving'})\n        try:\n            logger.debug(_(\"Uploading image data for image %(image_id)s \"\n                         \"to %(store_name)s store\"), locals())\n\n            if image_size > IMAGE_SIZE_CAP:\n                max_image_size = IMAGE_SIZE_CAP\n                msg = _(\"Denying attempt to upload image larger than \"\n                        \"%(max_image_size)d. Supplied image size was \"\n                        \"%(image_size)d\") % locals()\n                logger.warn(msg)\n                raise HTTPBadRequest(msg, request=req)\n\n            location, size, checksum = store.add(image_meta['id'],\n                                                 image_data,\n                                                 image_size)\n\n            # Verify any supplied checksum value matches checksum\n            # returned from store when adding image\n            supplied_checksum = image_meta.get('checksum')\n            if supplied_checksum and supplied_checksum != checksum:\n                msg = _(\"Supplied checksum (%(supplied_checksum)s) and \"\n                       \"checksum generated from uploaded image \"\n                       \"(%(checksum)s) did not match. Setting image \"\n                       \"status to 'killed'.\") % locals()\n                logger.error(msg)\n                self._safe_kill(req, image_id)\n                raise HTTPBadRequest(msg, content_type=\"text/plain\",\n                                     request=req)\n\n            # Update the database with the checksum returned\n            # from the backend store\n            logger.debug(_(\"Updating image %(image_id)s data. \"\n                         \"Checksum set to %(checksum)s, size set \"\n                         \"to %(size)d\"), locals())\n            update_data = {'checksum': checksum,\n                           'size': size}\n            image_meta = registry.update_image_metadata(req.context,\n                                                        image_id,\n                                                        update_data)\n            self.notifier.info('image.upload', image_meta)\n\n            return location\n\n        except exception.Duplicate, e:\n            msg = _(\"Attempt to upload duplicate image: %s\") % e\n            logger.error(msg)\n            self._safe_kill(req, image_id)\n            self.notifier.error('image.upload', msg)\n            raise HTTPConflict(msg, request=req)\n\n        except exception.Forbidden, e:\n            msg = _(\"Forbidden upload attempt: %s\") % e\n            logger.error(msg)\n            self._safe_kill(req, image_id)\n            self.notifier.error('image.upload', msg)\n            raise HTTPForbidden(msg, request=req, content_type=\"text/plain\")\n\n        except exception.StorageFull, e:\n            msg = _(\"Image storage media is full: %s\") % e\n            logger.error(msg)\n            self._safe_kill(req, image_id)\n            self.notifier.error('image.upload', msg)\n            raise HTTPRequestEntityTooLarge(msg, request=req,\n                                            content_type='text/plain')\n\n        except exception.StorageWriteDenied, e:\n            msg = _(\"Insufficient permissions on image storage media: %s\") % e\n            logger.error(msg)\n            self._safe_kill(req, image_id)\n            self.notifier.error('image.upload', msg)\n            raise HTTPServiceUnavailable(msg, request=req,\n                                         content_type='text/plain')\n\n        except HTTPError, e:\n            self._safe_kill(req, image_id)\n            self.notifier.error('image.upload', e.explanation)\n            raise\n\n        except Exception, e:\n            tb_info = traceback.format_exc()\n            logger.error(tb_info)\n\n            self._safe_kill(req, image_id)\n\n            msg = _(\"Error uploading image: (%(class_name)s): \"\n                    \"%(exc)s\") % ({'class_name': e.__class__.__name__,\n                    'exc': str(e)})\n\n            self.notifier.error('image.upload', msg)\n            raise HTTPBadRequest(msg, request=req)\n\n    def _activate(self, req, image_id, location):\n        \"\"\"\n        Sets the image status to `active` and the image's location\n        attribute.\n\n        :param req: The WSGI/Webob Request object\n        :param image_id: Opaque image identifier\n        :param location: Location of where Glance stored this image\n        \"\"\"\n        image_meta = {}\n        image_meta['location'] = location\n        image_meta['status'] = 'active'\n\n        try:\n            return registry.update_image_metadata(req.context,\n                                                  image_id,\n                                                  image_meta)\n        except exception.Invalid, e:\n            msg = (_(\"Failed to activate image. Got error: %(e)s\")\n                   % locals())\n            for line in msg.split('\\n'):\n                logger.error(line)\n            self.notifier.error('image.update', msg)\n            raise HTTPBadRequest(msg, request=req, content_type=\"text/plain\")\n\n    def _kill(self, req, image_id):\n        \"\"\"\n        Marks the image status to `killed`.\n\n        :param req: The WSGI/Webob Request object\n        :param image_id: Opaque image identifier\n        \"\"\"\n        registry.update_image_metadata(req.context, image_id,\n                                       {'status': 'killed'})\n\n    def _safe_kill(self, req, image_id):\n        \"\"\"\n        Mark image killed without raising exceptions if it fails.\n\n        Since _kill is meant to be called from exceptions handlers, it should\n        not raise itself, rather it should just log its error.\n\n        :param req: The WSGI/Webob Request object\n        :param image_id: Opaque image identifier\n        \"\"\"\n        try:\n            self._kill(req, image_id)\n        except Exception, e:\n            logger.error(_(\"Unable to kill image %(id)s: \"\n                           \"%(exc)s\") % ({'id': image_id,\n                           'exc': repr(e)}))\n\n    def _upload_and_activate(self, req, image_meta):\n        \"\"\"\n        Safely uploads the image data in the request payload\n        and activates the image in the registry after a successful\n        upload.\n\n        :param req: The WSGI/Webob Request object\n        :param image_meta: Mapping of metadata about image\n\n        :retval Mapping of updated image data\n        \"\"\"\n        image_id = image_meta['id']\n        # This is necessary because of a bug in Webob 1.0.2 - 1.0.7\n        # See: https://bitbucket.org/ianb/webob/\n        # issue/12/fix-for-issue-6-broke-chunked-transfer\n        req.is_body_readable = True\n        location = self._upload(req, image_meta)\n        return self._activate(req, image_id, location)\n\n    def _get_size(self, image_meta, location):\n        # retrieve the image size from remote store (if not provided)\n        return image_meta.get('size', 0) or get_size_from_backend(location)\n\n    def _handle_source(self, req, image_id, image_meta, image_data):\n        if image_data or self._copy_from(req):\n            image_meta = self._upload_and_activate(req, image_meta)\n        else:\n            location = image_meta.get('location')\n            if location:\n                image_meta = self._activate(req, image_id, location)\n        return image_meta\n\n    def create(self, req, image_meta, image_data):\n        \"\"\"\n        Adds a new image to Glance. Four scenarios exist when creating an\n        image:\n\n        1. If the image data is available directly for upload, create can be\n           passed the image data as the request body and the metadata as the\n           request headers. The image will initially be 'queued', during\n           upload it will be in the 'saving' status, and then 'killed' or\n           'active' depending on whether the upload completed successfully.\n\n        2. If the image data exists somewhere else, you can upload indirectly\n           from the external source using the x-glance-api-copy-from header.\n           Once the image is uploaded, the external store is not subsequently\n           consulted, i.e. the image content is served out from the configured\n           glance image store.  State transitions are as for option #1.\n\n        3. If the image data exists somewhere else, you can reference the\n           source using the x-image-meta-location header. The image content\n           will be served out from the external store, i.e. is never uploaded\n           to the configured glance image store.\n\n        4. If the image data is not available yet, but you'd like reserve a\n           spot for it, you can omit the data and a record will be created in\n           the 'queued' state. This exists primarily to maintain backwards\n           compatibility with OpenStack/Rackspace API semantics.\n\n        The request body *must* be encoded as application/octet-stream,\n        otherwise an HTTPBadRequest is returned.\n\n        Upon a successful save of the image data and metadata, a response\n        containing metadata about the image is returned, including its\n        opaque identifier.\n\n        :param req: The WSGI/Webob Request object\n        :param image_meta: Mapping of metadata about image\n        :param image_data: Actual image data that is to be stored\n\n        :raises HTTPBadRequest if x-image-meta-location is missing\n                and the request body is not application/octet-stream\n                image data.\n        \"\"\"\n        self._enforce(req, 'add_image')\n        if image_meta.get('is_public'):\n            self._enforce(req, 'publicize_image')\n        if req.context.read_only:\n            msg = _(\"Read-only access\")\n            logger.debug(msg)\n            raise HTTPForbidden(msg, request=req,\n                                content_type=\"text/plain\")\n\n        image_meta = self._reserve(req, image_meta)\n        id = image_meta['id']\n\n        image_meta = self._handle_source(req, id, image_meta, image_data)\n\n        # Prevent client from learning the location, as it\n        # could contain security credentials\n        image_meta.pop('location', None)\n\n        return {'image_meta': image_meta}\n\n    def update(self, req, id, image_meta, image_data):\n        \"\"\"\n        Updates an existing image with the registry.\n\n        :param request: The WSGI/Webob Request object\n        :param id: The opaque image identifier\n\n        :retval Returns the updated image information as a mapping\n        \"\"\"\n        self._enforce(req, 'modify_image')\n        if image_meta.get('is_public'):\n            self._enforce(req, 'publicize_image')\n        if req.context.read_only:\n            msg = _(\"Read-only access\")\n            logger.debug(msg)\n            raise HTTPForbidden(msg, request=req,\n                                content_type=\"text/plain\")\n\n        orig_image_meta = self.get_image_meta_or_404(req, id)\n        orig_status = orig_image_meta['status']\n\n        # The default behaviour for a PUT /images/<IMAGE_ID> is to\n        # override any properties that were previously set. This, however,\n        # leads to a number of issues for the common use case where a caller\n        # registers an image with some properties and then almost immediately\n        # uploads an image file along with some more properties. Here, we\n        # check for a special header value to be false in order to force\n        # properties NOT to be purged. However we also disable purging of\n        # properties if an image file is being uploaded...\n        purge_props = req.headers.get('x-glance-registry-purge-props', True)\n        purge_props = (utils.bool_from_string(purge_props) and\n                       image_data is None)\n\n        if image_data is not None and orig_status != 'queued':\n            raise HTTPConflict(_(\"Cannot upload to an unqueued image\"))\n\n        # Only allow the Location|Copy-From fields to be modified if the\n        # image is in queued status, which indicates that the user called\n        # POST /images but originally supply neither a Location|Copy-From\n        # field NOR image data\n        location = self._external_source(image_meta, req)\n        reactivating = orig_status != 'queued' and location\n        activating = orig_status == 'queued' and (location or image_data)\n\n        if reactivating:\n            msg = _(\"Attempted to update Location field for an image \"\n                    \"not in queued status.\")\n            raise HTTPBadRequest(msg, request=req, content_type=\"text/plain\")\n\n        try:\n            if location:\n                image_meta['size'] = self._get_size(image_meta, location)\n\n            image_meta = registry.update_image_metadata(req.context,\n                                                        id,\n                                                        image_meta,\n                                                        purge_props)\n\n            if activating:\n                image_meta = self._handle_source(req, id, image_meta,\n                                                 image_data)\n        except exception.Invalid, e:\n            msg = (_(\"Failed to update image metadata. Got error: %(e)s\")\n                   % locals())\n            for line in msg.split('\\n'):\n                logger.error(line)\n            self.notifier.error('image.update', msg)\n            raise HTTPBadRequest(msg, request=req, content_type=\"text/plain\")\n        except exception.NotFound, e:\n            msg = (\"Failed to find image to update: %(e)s\" % locals())\n            for line in msg.split('\\n'):\n                logger.info(line)\n            self.notifier.info('image.update', msg)\n            raise HTTPNotFound(msg, request=req, content_type=\"text/plain\")\n        except exception.Forbidden, e:\n            msg = (\"Forbidden to update image: %(e)s\" % locals())\n            for line in msg.split('\\n'):\n                logger.info(line)\n            self.notifier.info('image.update', msg)\n            raise HTTPForbidden(msg, request=req, content_type=\"text/plain\")\n        else:\n            self.notifier.info('image.update', image_meta)\n\n        # Prevent client from learning the location, as it\n        # could contain security credentials\n        image_meta.pop('location', None)\n\n        return {'image_meta': image_meta}\n\n    def delete(self, req, id):\n        \"\"\"\n        Deletes the image and all its chunks from the Glance\n\n        :param req: The WSGI/Webob Request object\n        :param id: The opaque image identifier\n\n        :raises HttpBadRequest if image registry is invalid\n        :raises HttpNotFound if image or any chunk is not available\n        :raises HttpUnauthorized if image or any chunk is not\n                deleteable by the requesting user\n        \"\"\"\n        self._enforce(req, 'delete_image')\n        if req.context.read_only:\n            msg = _(\"Read-only access\")\n            logger.debug(msg)\n            raise HTTPForbidden(msg, request=req,\n                                content_type=\"text/plain\")\n\n        image = self.get_image_meta_or_404(req, id)\n\n        if not (req.context.is_admin\n                or image['owner'] == None\n                or image['owner'] == req.context.owner):\n            msg = _(\"Unable to delete image you do not own\")\n            logger.debug(msg)\n            raise HTTPForbidden(msg, request=req,\n                                content_type=\"text/plain\")\n\n        if image['protected']:\n            msg = _(\"Image is protected\")\n            logger.debug(msg)\n            raise HTTPForbidden(msg, request=req,\n                                content_type=\"text/plain\")\n\n        # The image's location field may be None in the case\n        # of a saving or queued image, therefore don't ask a backend\n        # to delete the image if the backend doesn't yet store it.\n        # See https://bugs.launchpad.net/glance/+bug/747799\n        try:\n            if image['location']:\n                schedule_delete_from_backend(image['location'], self.conf,\n                                             req.context, id)\n            registry.delete_image_metadata(req.context, id)\n        except exception.NotFound, e:\n            msg = (\"Failed to find image to delete: %(e)s\" % locals())\n            for line in msg.split('\\n'):\n                logger.info(line)\n            self.notifier.info('image.delete', msg)\n            raise HTTPNotFound(msg, request=req, content_type=\"text/plain\")\n        except exception.Forbidden, e:\n            msg = (\"Forbidden to delete image: %(e)s\" % locals())\n            for line in msg.split('\\n'):\n                logger.info(line)\n            self.notifier.info('image.delete', msg)\n            raise HTTPForbidden(msg, request=req, content_type=\"text/plain\")\n        else:\n            self.notifier.info('image.delete', id)\n\n    def get_store_or_400(self, request, store_name):\n        \"\"\"\n        Grabs the storage backend for the supplied store name\n        or raises an HTTPBadRequest (400) response\n\n        :param request: The WSGI/Webob Request object\n        :param store_name: The backend store name\n\n        :raises HTTPNotFound if store does not exist\n        \"\"\"\n        try:\n            return get_store_from_scheme(store_name)\n        except exception.UnknownScheme:\n            msg = (_(\"Requested store %s not available on this Glance server\")\n                   % store_name)\n            logger.error(msg)\n            raise HTTPBadRequest(msg, request=request,\n                                 content_type='text/plain')\n\n    def verify_store_or_exit(self, store_name):\n        \"\"\"\n        Verifies availability of the storage backend for the\n        given store name or exits\n\n        :param store_name: The backend store name\n        \"\"\"\n        try:\n            get_store_from_scheme(store_name)\n        except exception.UnknownScheme:\n            msg = (_(\"Default store %s not available on this Glance server\\n\")\n                   % store_name)\n            logger.error(msg)\n            # message on stderr will only be visible if started directly via\n            # bin/glance-api, as opposed to being daemonized by glance-control\n            sys.stderr.write(msg)\n            sys.exit(255)\n\n\nclass ImageDeserializer(wsgi.JSONRequestDeserializer):\n    \"\"\"Handles deserialization of specific controller method requests.\"\"\"\n\n    def _deserialize(self, request):\n        result = {}\n        try:\n            result['image_meta'] = utils.get_image_meta_from_headers(request)\n        except exception.Invalid:\n            image_size_str = request.headers['x-image-meta-size']\n            msg = _(\"Incoming image size of %s was not convertible to \"\n                    \"an integer.\") % image_size_str\n            raise HTTPBadRequest(msg, request=request)\n\n        image_meta = result['image_meta']\n        if 'size' in image_meta:\n            incoming_image_size = image_meta['size']\n            if incoming_image_size > IMAGE_SIZE_CAP:\n                max_image_size = IMAGE_SIZE_CAP\n                msg = _(\"Denying attempt to upload image larger than \"\n                        \"%(max_image_size)d. Supplied image size was \"\n                        \"%(incoming_image_size)d\") % locals()\n                logger.warn(msg)\n                raise HTTPBadRequest(msg, request=request)\n\n        data = request.body_file if self.has_body(request) else None\n        result['image_data'] = data\n        return result\n\n    def create(self, request):\n        return self._deserialize(request)\n\n    def update(self, request):\n        return self._deserialize(request)\n\n\nclass ImageSerializer(wsgi.JSONResponseSerializer):\n    \"\"\"Handles serialization of specific controller method responses.\"\"\"\n\n    def __init__(self, conf):\n        self.conf = conf\n        self.notifier = notifier.Notifier(conf)\n\n    def _inject_location_header(self, response, image_meta):\n        location = self._get_image_location(image_meta)\n        response.headers['Location'] = location\n\n    def _inject_checksum_header(self, response, image_meta):\n        response.headers['ETag'] = image_meta['checksum']\n\n    def _inject_image_meta_headers(self, response, image_meta):\n        \"\"\"\n        Given a response and mapping of image metadata, injects\n        the Response with a set of HTTP headers for the image\n        metadata. Each main image metadata field is injected\n        as a HTTP header with key 'x-image-meta-<FIELD>' except\n        for the properties field, which is further broken out\n        into a set of 'x-image-meta-property-<KEY>' headers\n\n        :param response: The Webob Response object\n        :param image_meta: Mapping of image metadata\n        \"\"\"\n        headers = utils.image_meta_to_http_headers(image_meta)\n\n        for k, v in headers.items():\n            response.headers[k] = v\n\n    def _get_image_location(self, image_meta):\n        \"\"\"Build a relative url to reach the image defined by image_meta.\"\"\"\n        return \"/v1/images/%s\" % image_meta['id']\n\n    def meta(self, response, result):\n        image_meta = result['image_meta']\n        self._inject_image_meta_headers(response, image_meta)\n        self._inject_location_header(response, image_meta)\n        self._inject_checksum_header(response, image_meta)\n        return response\n\n    def image_send_notification(self, bytes_written, expected_size,\n                                image_meta, request):\n        \"\"\"Send an image.send message to the notifier.\"\"\"\n        try:\n            context = request.context\n            payload = {\n                'bytes_sent': bytes_written,\n                'image_id': image_meta['id'],\n                'owner_id': image_meta['owner'],\n                'receiver_tenant_id': context.tenant,\n                'receiver_user_id': context.user,\n                'destination_ip': request.remote_addr,\n            }\n            if bytes_written != expected_size:\n                self.notifier.error('image.send', payload)\n            else:\n                self.notifier.info('image.send', payload)\n        except Exception, err:\n            msg = _(\"An error occurred during image.send\"\n                    \" notification: %(err)s\") % locals()\n            logger.error(msg)\n\n    def show(self, response, result):\n        image_meta = result['image_meta']\n        image_id = image_meta['id']\n\n        # We use a secondary iterator here to wrap the\n        # iterator coming back from the store driver in\n        # order to check for disconnections from the backend\n        # storage connections and log an error if the size of\n        # the transferred image is not the same as the expected\n        # size of the image file. See LP Bug #882585.\n        def checked_iter(image_id, expected_size, image_iter):\n            bytes_written = 0\n\n            def notify_image_sent_hook(env):\n                self.image_send_notification(bytes_written, expected_size,\n                                             image_meta, response.request)\n\n            # Add hook to process after response is fully sent\n            if 'eventlet.posthooks' in response.request.environ:\n                response.request.environ['eventlet.posthooks'].append(\n                    (notify_image_sent_hook, (), {}))\n\n            try:\n                for chunk in image_iter:\n                    yield chunk\n                    bytes_written += len(chunk)\n            except Exception, err:\n                msg = _(\"An error occurred reading from backend storage \"\n                        \"for image %(image_id): %(err)s\") % locals()\n                logger.error(msg)\n                raise\n\n            if expected_size != bytes_written:\n                msg = _(\"Backend storage for image %(image_id)s \"\n                        \"disconnected after writing only %(bytes_written)d \"\n                        \"bytes\") % locals()\n                logger.error(msg)\n                raise IOError(errno.EPIPE, _(\"Corrupt image download for \"\n                                             \"image %(image_id)s\") % locals())\n\n        image_iter = result['image_iterator']\n        # image_meta['size'] is a str\n        expected_size = int(image_meta['size'])\n        response.app_iter = checked_iter(image_id, expected_size, image_iter)\n        # Using app_iter blanks content-length, so we set it here...\n        response.headers['Content-Length'] = image_meta['size']\n        response.headers['Content-Type'] = 'application/octet-stream'\n\n        self._inject_image_meta_headers(response, image_meta)\n        self._inject_location_header(response, image_meta)\n        self._inject_checksum_header(response, image_meta)\n\n        return response\n\n    def update(self, response, result):\n        image_meta = result['image_meta']\n        response.body = self.to_json(dict(image=image_meta))\n        response.headers['Content-Type'] = 'application/json'\n        self._inject_location_header(response, image_meta)\n        self._inject_checksum_header(response, image_meta)\n        return response\n\n    def create(self, response, result):\n        image_meta = result['image_meta']\n        response.status = 201\n        response.headers['Content-Type'] = 'application/json'\n        response.body = self.to_json(dict(image=image_meta))\n        self._inject_location_header(response, image_meta)\n        self._inject_checksum_header(response, image_meta)\n        return response\n\n\ndef create_resource(conf):\n    \"\"\"Images resource factory method\"\"\"\n    deserializer = ImageDeserializer()\n    serializer = ImageSerializer(conf)\n    return wsgi.Resource(Controller(conf), deserializer, serializer)\n"], "filenames": ["glance/api/v1/images.py"], "buggy_code_start_loc": [729], "buggy_code_end_loc": [729], "fixing_code_start_loc": [730], "fixing_code_end_loc": [739], "type": "CWE-264", "message": "The v1 API in OpenStack Glance Grizzly, Folsom (2012.2), and Essex (2012.1) allows remote authenticated users to delete arbitrary non-protected images via an image deletion request, a different vulnerability than CVE-2012-5482.", "other": {"cve": {"id": "CVE-2012-4573", "sourceIdentifier": "secalert@redhat.com", "published": "2012-11-11T13:00:58.883", "lastModified": "2017-08-29T01:32:19.510", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The v1 API in OpenStack Glance Grizzly, Folsom (2012.2), and Essex (2012.1) allows remote authenticated users to delete arbitrary non-protected images via an image deletion request, a different vulnerability than CVE-2012-5482."}, {"lang": "es", "value": "La API v1 en OpenStack Vistazo Grizzly, Folsom (2.012,2) y Essex (2012.1) permite a usuarios autenticados remotamente borrar im\u00e1genes de su elecci\u00f3n no protegidas a trav\u00e9s de una solicitud de eliminaci\u00f3n de im\u00e1genes, una vulnerabilidad diferente a CVE-2012-5482."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openstack:essex:2012.1:*:*:*:*:*:*:*", "matchCriteriaId": "E5FDB43F-B315-4F68-9D86-B644F2D4DF9A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openstack:folsom:2012.2:*:*:*:*:*:*:*", "matchCriteriaId": "E76B76AB-D744-4163-8615-7BA18ABB1347"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openstack:image_registry_and_delivery_service_\\(glance\\):-:*:*:*:*:*:*:*", "matchCriteriaId": "EC5343C7-8EBD-49A5-8423-22F88DE0CBD2"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-November/092192.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2012-11/msg00002.html", "source": "secalert@redhat.com"}, {"url": "http://packetstormsecurity.com/files/118733/Red-Hat-Security-Advisory-2012-1558-01.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-1558.html", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/11/07/6", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/11/09/5", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/56437", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1626-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1626-2", "source": "secalert@redhat.com"}, {"url": "https://bugs.launchpad.net/glance/+bug/1065187", "source": "secalert@redhat.com"}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/79895", "source": "secalert@redhat.com"}, {"url": "https://github.com/openstack/glance/commit/6ab0992e5472ae3f9bef0d2ced41030655d9d2bc", "source": "secalert@redhat.com"}, {"url": "https://github.com/openstack/glance/commit/90bcdc5a89e350a358cf320a03f5afe99795f6f6", "source": "secalert@redhat.com"}, {"url": "https://github.com/openstack/glance/commit/efd7e75b1f419a52c7103c7840e24af8e5deb29d", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/openstack/glance/commit/efd7e75b1f419a52c7103c7840e24af8e5deb29d"}}