{"buggy_code": ["// ***************************************************************** -*- C++ -*-\n/*\n * Copyright (C) 2004-2021 Exiv2 authors\n * This program is part of the Exiv2 distribution.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, 5th Floor, Boston, MA 02110-1301 USA.\n */\n\n// *****************************************************************************\n\n// included header files\n#include \"config.h\"\n\n#include \"jp2image.hpp\"\n#include \"tiffimage.hpp\"\n#include \"image.hpp\"\n#include \"image_int.hpp\"\n#include \"basicio.hpp\"\n#include \"enforce.hpp\"\n#include \"error.hpp\"\n#include \"futils.hpp\"\n#include \"types.hpp\"\n#include \"safe_op.hpp\"\n\n// + standard includes\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <cstdio>\n\n// JPEG-2000 box types\nconst uint32_t kJp2BoxTypeJp2Header   = 0x6a703268; // 'jp2h'\nconst uint32_t kJp2BoxTypeImageHeader = 0x69686472; // 'ihdr'\nconst uint32_t kJp2BoxTypeColorHeader = 0x636f6c72; // 'colr'\nconst uint32_t kJp2BoxTypeUuid        = 0x75756964; // 'uuid'\nconst uint32_t kJp2BoxTypeClose       = 0x6a703263; // 'jp2c'\n\n// from openjpeg-2.1.2/src/lib/openjp2/jp2.h\n/*#define JPIP_JPIP 0x6a706970*/\n\n#define     JP2_JP   0x6a502020    /**< JPEG 2000 signature box */\n#define     JP2_FTYP 0x66747970    /**< File type box */\n#define     JP2_JP2H 0x6a703268    /**< JP2 header box (super-box) */\n#define     JP2_IHDR 0x69686472    /**< Image header box */\n#define     JP2_COLR 0x636f6c72    /**< Colour specification box */\n#define     JP2_JP2C 0x6a703263    /**< Contiguous codestream box */\n#define     JP2_URL  0x75726c20    /**< Data entry URL box */\n#define     JP2_PCLR 0x70636c72    /**< Palette box */\n#define     JP2_CMAP 0x636d6170    /**< Component Mapping box */\n#define     JP2_CDEF 0x63646566    /**< Channel Definition box */\n#define     JP2_DTBL 0x6474626c    /**< Data Reference box */\n#define     JP2_BPCC 0x62706363    /**< Bits per component box */\n#define     JP2_JP2  0x6a703220    /**< File type fields */\n\n/* For the future */\n/* #define JP2_RES 0x72657320 */  /**< Resolution box (super-box) */\n/* #define JP2_JP2I 0x6a703269 */  /**< Intellectual property box */\n/* #define JP2_XML  0x786d6c20 */  /**< XML box */\n/* #define JP2_UUID 0x75756994 */  /**< UUID box */\n/* #define JP2_UINF 0x75696e66 */  /**< UUID info box (super-box) */\n/* #define JP2_ULST 0x756c7374 */  /**< UUID list box */\n\n// JPEG-2000 UUIDs for embedded metadata\n//\n// See http://www.jpeg.org/public/wg1n2600.doc for information about embedding IPTC-NAA data in JPEG-2000 files\n// See http://www.adobe.com/devnet/xmp/pdfs/xmp_specification.pdf for information about embedding XMP data in JPEG-2000 files\nconst unsigned char kJp2UuidExif[] = \"JpgTiffExif->JP2\";\nconst unsigned char kJp2UuidIptc[] = \"\\x33\\xc7\\xa4\\xd2\\xb8\\x1d\\x47\\x23\\xa0\\xba\\xf1\\xa3\\xe0\\x97\\xad\\x38\";\nconst unsigned char kJp2UuidXmp[]  = \"\\xbe\\x7a\\xcf\\xcb\\x97\\xa9\\x42\\xe8\\x9c\\x71\\x99\\x94\\x91\\xe3\\xaf\\xac\";\n\n// See section B.1.1 (JPEG 2000 Signature box) of JPEG-2000 specification\nconst unsigned char Jp2Signature[12] = { 0x00, 0x00, 0x00, 0x0c, 0x6a, 0x50, 0x20, 0x20, 0x0d, 0x0a, 0x87, 0x0a };\n\nconst unsigned char Jp2Blank[] = { 0x00,0x00,0x00,0x0c,0x6a,0x50,0x20,0x20,0x0d,0x0a,0x87,0x0a,0x00,0x00,0x00,0x14,\n                                   0x66,0x74,0x79,0x70,0x6a,0x70,0x32,0x20,0x00,0x00,0x00,0x00,0x6a,0x70,0x32,0x20,\n                                   0x00,0x00,0x00,0x2d,0x6a,0x70,0x32,0x68,0x00,0x00,0x00,0x16,0x69,0x68,0x64,0x72,\n                                   0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x01,0x07,0x07,0x00,0x00,0x00,0x00,\n                                   0x00,0x0f,0x63,0x6f,0x6c,0x72,0x01,0x00,0x00,0x00,0x00,0x00,0x11,0x00,0x00,0x00,\n                                   0x00,0x6a,0x70,0x32,0x63,0xff,0x4f,0xff,0x51,0x00,0x29,0x00,0x00,0x00,0x00,0x00,\n                                   0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n                                   0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x07,\n                                   0x01,0x01,0xff,0x64,0x00,0x23,0x00,0x01,0x43,0x72,0x65,0x61,0x74,0x6f,0x72,0x3a,\n                                   0x20,0x4a,0x61,0x73,0x50,0x65,0x72,0x20,0x56,0x65,0x72,0x73,0x69,0x6f,0x6e,0x20,\n                                   0x31,0x2e,0x39,0x30,0x30,0x2e,0x31,0xff,0x52,0x00,0x0c,0x00,0x00,0x00,0x01,0x00,\n                                   0x05,0x04,0x04,0x00,0x01,0xff,0x5c,0x00,0x13,0x40,0x40,0x48,0x48,0x50,0x48,0x48,\n                                   0x50,0x48,0x48,0x50,0x48,0x48,0x50,0x48,0x48,0x50,0xff,0x90,0x00,0x0a,0x00,0x00,\n                                   0x00,0x00,0x00,0x2d,0x00,0x01,0xff,0x5d,0x00,0x14,0x00,0x40,0x40,0x00,0x00,0x00,\n                                   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x93,0xcf,0xb4,\n                                   0x04,0x00,0x80,0x80,0x80,0x80,0x80,0xff,0xd9\n                                 };\n\n//! @cond IGNORE\nstruct Jp2BoxHeader\n{\n    uint32_t length;\n    uint32_t type;\n};\n\nstruct Jp2ImageHeaderBox\n{\n    uint32_t imageHeight;\n    uint32_t imageWidth;\n    uint16_t componentCount;\n    uint8_t  bitsPerComponent;\n    uint8_t  compressionType;\n    uint8_t  colorspaceIsUnknown;\n    uint8_t  intellectualPropertyFlag;\n    uint16_t compressionTypeProfile;\n};\n\nstruct Jp2UuidBox\n{\n    uint8_t  uuid[16];\n};\n//! @endcond\n\n// *****************************************************************************\n// class member definitions\nnamespace Exiv2\n{\n\n    Jp2Image::Jp2Image(BasicIo::UniquePtr io, bool create)\n            : Image(ImageType::jp2, mdExif | mdIptc | mdXmp, std::move(io))\n    {\n        if (create)\n        {\n            if (io_->open() == 0)\n            {\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cerr << \"Exiv2::Jp2Image:: Creating JPEG2000 image to memory\" << std::endl;\n#endif\n                IoCloser closer(*io_);\n                if (io_->write(Jp2Blank, sizeof(Jp2Blank)) != sizeof(Jp2Blank))\n                {\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cerr << \"Exiv2::Jp2Image:: Failed to create JPEG2000 image on memory\" << std::endl;\n#endif\n                }\n            }\n        }\n    } // Jp2Image::Jp2Image\n\n    std::string Jp2Image::mimeType() const\n    {\n        return \"image/jp2\";\n    }\n\n    void Jp2Image::setComment(const std::string& /*comment*/)\n    {\n        // Todo: implement me!\n        throw(Error(kerInvalidSettingForImage, \"Image comment\", \"JP2\"));\n    } // Jp2Image::setComment\n\n    static void lf(std::ostream& out,bool& bLF)\n    {\n        if ( bLF ) {\n            out << std::endl;\n            out.flush();\n            bLF = false ;\n        }\n    }\n\n    static bool isBigEndian()\n    {\n        union {\n            uint32_t i;\n            char c[4];\n        } e = { 0x01000000 };\n\n        return e.c[0]?true:false;\n    }\n\n    static std::string toAscii(long n)\n    {\n        const char* p = (const char*) &n;\n        std::string result;\n        bool bBigEndian = isBigEndian();\n        for ( int i = 0 ; i < 4 ; i++) {\n            result += p[ bBigEndian ? i : (3-i) ];\n        }\n        return result;\n    }\n\nstatic void boxes_check(size_t b,size_t m)\n{\n    if ( b > m ) {\n#ifdef EXIV2_DEBUG_MESSAGES\n        std::cout << \"Exiv2::Jp2Image::readMetadata box maximum exceeded\" << std::endl;\n#endif\n        throw Error(kerCorruptedMetadata);\n    }\n}\n\n    void Jp2Image::readMetadata()\n    {\n#ifdef EXIV2_DEBUG_MESSAGES\n        std::cerr << \"Exiv2::Jp2Image::readMetadata: Reading JPEG-2000 file \" << io_->path() << std::endl;\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isJp2Type(*io_, true))\n        {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"JPEG-2000\");\n        }\n\n        long              position  = 0;\n        Jp2BoxHeader      box       = {0,0};\n        Jp2BoxHeader      subBox    = {0,0};\n        Jp2ImageHeaderBox ihdr      = {0,0,0,0,0,0,0,0};\n        Jp2UuidBox        uuid      = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};\n        size_t            boxes     = 0 ;\n        size_t            boxem     = 1000 ; // boxes max\n\n        while (io_->read((byte*)&box, sizeof(box)) == sizeof(box))\n        {\n            boxes_check(boxes++,boxem );\n            position   = io_->tell();\n            box.length = getLong((byte*)&box.length, bigEndian);\n            box.type   = getLong((byte*)&box.type, bigEndian);\n#ifdef EXIV2_DEBUG_MESSAGES\n            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                      << \"Position: \" << position\n                      << \" box type: \" << toAscii(box.type)\n                      << \" length: \" << box.length\n                      << std::endl;\n#endif\n\n            if (box.length == 0) return ;\n\n            if (box.length == 1)\n            {\n                // FIXME. Special case. the real box size is given in another place.\n            }\n\n            switch(box.type)\n            {\n                case kJp2BoxTypeJp2Header:\n                {\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: JP2Header box found\" << std::endl;\n#endif\n                    long restore = io_->tell();\n\n                    while (io_->read((byte*)&subBox, sizeof(subBox)) == sizeof(subBox) && subBox.length )\n                    {\n                        boxes_check(boxes++, boxem) ;\n                        subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                        subBox.type   = getLong((byte*)&subBox.type, bigEndian);\n                        if (subBox.length > io_->size() ) {\n                            throw Error(kerCorruptedMetadata);\n                        }\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                        << \"subBox = \" << toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n#endif\n                        if(subBox.type == kJp2BoxTypeColorHeader && subBox.length != 15)\n                        {\n#ifdef EXIV2_DEBUG_MESSAGES\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                                     << \"Color data found\" << std::endl;\n#endif\n\n                            const long pad = 3 ; // 3 padding bytes 2 0 0\n                            const size_t data_length = Safe::add(subBox.length, static_cast<uint32_t>(8));\n                            // data_length makes no sense if it is larger than the rest of the file\n                            if (data_length > io_->size() - io_->tell()) {\n                                throw Error(kerCorruptedMetadata);\n                            }\n                            DataBuf data(static_cast<long>(data_length));\n                            io_->read(data.pData_,data.size_);\n                            const long    iccLength = getULong(data.pData_+pad, bigEndian);\n                            // subtracting pad from data.size_ is safe:\n                            // size_ is at least 8 and pad = 3\n                            if (iccLength > data.size_ - pad) {\n                                throw Error(kerCorruptedMetadata);\n                            }\n                            DataBuf icc(iccLength);\n                            ::memcpy(icc.pData_,data.pData_+pad,icc.size_);\n#ifdef EXIV2_DEBUG_MESSAGES\n                            const char* iccPath = \"/tmp/libexiv2_jp2.icc\";\n                            FILE* f = fopen(iccPath,\"wb\");\n                            if ( f ) {\n                                fwrite(icc.pData_,icc.size_,1,f);\n                                fclose(f);\n                            }\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: wrote iccProfile \" << icc.size_<< \" bytes to \" << iccPath << std::endl ;\n#endif\n                            setIccProfile(icc);\n                        }\n\n                        if( subBox.type == kJp2BoxTypeImageHeader)\n                        {\n                            io_->read((byte*)&ihdr, sizeof(ihdr));\n#ifdef EXIV2_DEBUG_MESSAGES\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: Ihdr data found\" << std::endl;\n#endif\n                            ihdr.imageHeight            = getLong((byte*)&ihdr.imageHeight, bigEndian);\n                            ihdr.imageWidth             = getLong((byte*)&ihdr.imageWidth, bigEndian);\n                            ihdr.componentCount         = getShort((byte*)&ihdr.componentCount, bigEndian);\n                            ihdr.compressionTypeProfile = getShort((byte*)&ihdr.compressionTypeProfile, bigEndian);\n\n                            pixelWidth_  = ihdr.imageWidth;\n                            pixelHeight_ = ihdr.imageHeight;\n                        }\n\n                        io_->seek(restore,BasicIo::beg);\n                        if ( io_->seek(subBox.length, Exiv2::BasicIo::cur) != 0 ) {\n                            throw Error(kerCorruptedMetadata);\n                        }\n                        restore = io_->tell();\n                    }\n                    break;\n                }\n\n                case kJp2BoxTypeUuid:\n                {\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: UUID box found\" << std::endl;\n#endif\n\n                    if (io_->read((byte*)&uuid, sizeof(uuid)) == sizeof(uuid))\n                    {\n                        DataBuf rawData;\n                        long    bufRead;\n                        bool    bIsExif = memcmp(uuid.uuid, kJp2UuidExif, sizeof(uuid))==0;\n                        bool    bIsIPTC = memcmp(uuid.uuid, kJp2UuidIptc, sizeof(uuid))==0;\n                        bool    bIsXMP  = memcmp(uuid.uuid, kJp2UuidXmp , sizeof(uuid))==0;\n\n                        if(bIsExif)\n                        {\n#ifdef EXIV2_DEBUG_MESSAGES\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Exif data found\" << std::endl ;\n#endif\n                            rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(kerFailedToReadImageData);\n                            if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);\n\n                            if (rawData.size_ > 8) // \"II*\\0long\"\n                            {\n                                // Find the position of Exif header in bytes array.\n                                long pos = (     (rawData.pData_[0]      == rawData.pData_[1])\n                                           &&    (rawData.pData_[0]=='I' || rawData.pData_[0]=='M')\n                                           )  ? 0 : -1;\n\n                                // #1242  Forgive having Exif\\0\\0 in rawData.pData_\n                                const byte exifHeader[] = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                                for (long i=0 ; pos < 0 && i < rawData.size_-(long)sizeof(exifHeader) ; i++)\n                                {\n                                    if (memcmp(exifHeader, &rawData.pData_[i], sizeof(exifHeader)) == 0)\n                                    {\n                                        pos = i+sizeof(exifHeader);\n#ifndef SUPPRESS_WARNINGS\n                                        EXV_WARNING << \"Reading non-standard UUID-EXIF_bad box in \" << io_->path() << std::endl;\n#endif\n\n                                    }\n                                }\n\n                                // If found it, store only these data at from this place.\n                                if (pos >= 0 )\n                                {\n#ifdef EXIV2_DEBUG_MESSAGES\n                                    std::cout << \"Exiv2::Jp2Image::readMetadata: Exif header found at position \" << pos << std::endl;\n#endif\n                                    ByteOrder bo = TiffParser::decode(exifData(),\n                                                                      iptcData(),\n                                                                      xmpData(),\n                                                                      rawData.pData_ + pos,\n                                                                      rawData.size_ - pos);\n                                    setByteOrder(bo);\n                                }\n                            }\n                            else\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                                exifData_.clear();\n                            }\n                        }\n\n                        if(bIsIPTC)\n                        {\n#ifdef EXIV2_DEBUG_MESSAGES\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Iptc data found\" << std::endl;\n#endif\n                            rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(kerFailedToReadImageData);\n                            if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);\n\n                            if (IptcParser::decode(iptcData_, rawData.pData_, rawData.size_))\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode IPTC metadata.\" << std::endl;\n#endif\n                                iptcData_.clear();\n                            }\n                        }\n\n                        if(bIsXMP)\n                        {\n#ifdef EXIV2_DEBUG_MESSAGES\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Xmp data found\" << std::endl;\n#endif\n                            rawData.alloc(box.length - (uint32_t)(sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(kerFailedToReadImageData);\n                            if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);\n                            xmpPacket_.assign(reinterpret_cast<char *>(rawData.pData_), rawData.size_);\n\n                            std::string::size_type idx = xmpPacket_.find_first_of('<');\n                            if (idx != std::string::npos && idx > 0)\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Removing \" << static_cast<uint32_t>(idx)\n                                            << \" characters from the beginning of the XMP packet\" << std::endl;\n#endif\n                                xmpPacket_ = xmpPacket_.substr(idx);\n                            }\n\n                            if (xmpPacket_.size() > 0 && XmpParser::decode(xmpData_, xmpPacket_))\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                            }\n                        }\n                    }\n                    break;\n                }\n\n                default:\n                {\n                    break;\n                }\n            }\n\n            // Move to the next box.\n            io_->seek(static_cast<long>(position - sizeof(box) + box.length), BasicIo::beg);\n            if (io_->error()) throw Error(kerFailedToReadImageData);\n        }\n\n    } // Jp2Image::readMetadata\n\n    void Jp2Image::printStructure(std::ostream& out, PrintStructureOption option, int depth)\n    {\n        if (io_->open() != 0)\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n\n        // Ensure that this is the correct image type\n        if (!isJp2Type(*io_, false)) {\n            if (io_->error() || io_->eof())\n                throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAJpeg);\n        }\n\n        bool bPrint = option == kpsBasic || option == kpsRecursive;\n        bool bRecursive = option == kpsRecursive;\n        bool bICC = option == kpsIccProfile;\n        bool bXMP = option == kpsXMP;\n        bool bIPTCErase = option == kpsIptcErase;\n\n        if (bPrint) {\n            out << \"STRUCTURE OF JPEG2000 FILE: \" << io_->path() << std::endl;\n            out << \" address |   length | box       | data\" << std::endl;\n        }\n\n        if ( bPrint || bXMP || bICC || bIPTCErase ) {\n\n            long              position  = 0;\n            Jp2BoxHeader      box       = {1,1};\n            Jp2BoxHeader      subBox    = {1,1};\n            Jp2UuidBox        uuid      = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};\n            bool              bLF       = false;\n\n            while (box.length && box.type != kJp2BoxTypeClose && io_->read((byte*)&box, sizeof(box)) == sizeof(box))\n            {\n                position   = io_->tell();\n                box.length = getLong((byte*)&box.length, bigEndian);\n                box.type = getLong((byte*)&box.type, bigEndian);\n                enforce(box.length <= io_->size()-io_->tell() , Exiv2::kerCorruptedMetadata);\n\n                if (bPrint) {\n                    out << Internal::stringFormat(\"%8ld | %8ld | \", position - sizeof(box),\n                                                  (size_t)box.length)\n                        << toAscii(box.type) << \"      | \";\n                    bLF = true;\n                    if (box.type == kJp2BoxTypeClose)\n                        lf(out, bLF);\n                }\n                if (box.type == kJp2BoxTypeClose)\n                    break;\n\n                switch (box.type) {\n                    case kJp2BoxTypeJp2Header: {\n                        lf(out, bLF);\n\n                        while (io_->read((byte*)&subBox, sizeof(subBox)) == sizeof(subBox) &&\n                               io_->tell() < position + (long)box.length)  // don't read beyond the box!\n                        {\n                            int address = io_->tell() - sizeof(subBox);\n                            subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                            subBox.type = getLong((byte*)&subBox.type, bigEndian);\n\n                            if (subBox.length < sizeof(box) || subBox.length > io_->size() - io_->tell()) {\n                                throw Error(kerCorruptedMetadata);\n                            }\n\n                            DataBuf data(subBox.length - sizeof(box));\n                            io_->read(data.pData_, data.size_);\n                            if (bPrint) {\n                                out << Internal::stringFormat(\"%8ld | %8ld |  sub:\", (size_t)address,\n                                                              (size_t)subBox.length)\n                                    << toAscii(subBox.type) << \" | \"\n                                    << Internal::binaryToString(makeSlice(data, 0, std::min(30l, data.size_)));\n                                bLF = true;\n                            }\n\n                            if (subBox.type == kJp2BoxTypeColorHeader) {\n                                long pad = 3;  // don't know why there are 3 padding bytes\n                                if (bPrint) {\n                                    out << \" | pad:\";\n                                    for (int i = 0; i < 3; i++)\n                                        out << \" \" << (int)data.pData_[i];\n                                }\n                                long iccLength = getULong(data.pData_ + pad, bigEndian);\n                                if (bPrint) {\n                                    out << \" | iccLength:\" << iccLength;\n                                }\n                                if (bICC) {\n                                    out.write((const char*)data.pData_ + pad, iccLength);\n                                }\n                            }\n                            lf(out, bLF);\n                        }\n                    } break;\n\n                    case kJp2BoxTypeUuid: {\n                        if (io_->read((byte*)&uuid, sizeof(uuid)) == sizeof(uuid)) {\n                            bool bIsExif = memcmp(uuid.uuid, kJp2UuidExif, sizeof(uuid)) == 0;\n                            bool bIsIPTC = memcmp(uuid.uuid, kJp2UuidIptc, sizeof(uuid)) == 0;\n                            bool bIsXMP = memcmp(uuid.uuid, kJp2UuidXmp, sizeof(uuid)) == 0;\n\n                            bool bUnknown = !(bIsExif || bIsIPTC || bIsXMP);\n\n                            if (bPrint) {\n                                if (bIsExif)\n                                    out << \"Exif: \";\n                                if (bIsIPTC)\n                                    out << \"IPTC: \";\n                                if (bIsXMP)\n                                    out << \"XMP : \";\n                                if (bUnknown)\n                                    out << \"????: \";\n                            }\n\n                            DataBuf rawData;\n                            rawData.alloc(box.length - sizeof(uuid) - sizeof(box));\n                            long bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error())\n                                throw Error(kerFailedToReadImageData);\n                            if (bufRead != rawData.size_)\n                                throw Error(kerInputDataReadFailed);\n\n                            if (bPrint) {\n                                out << Internal::binaryToString(\n                                        makeSlice(rawData, 0, rawData.size_>40?40:rawData.size_));\n                                out.flush();\n                            }\n                            lf(out, bLF);\n\n                            if (bIsExif && bRecursive && rawData.size_ > 8) { // \"II*\\0long\"\n                                if ((rawData.pData_[0] == rawData.pData_[1]) &&\n                                    (rawData.pData_[0] == 'I' || rawData.pData_[0] == 'M')) {\n                                    BasicIo::UniquePtr p = BasicIo::UniquePtr(new MemIo(rawData.pData_, rawData.size_));\n                                    printTiffStructure(*p, out, option, depth);\n                                }\n                            }\n\n                            if (bIsIPTC && bRecursive) {\n                                IptcData::printStructure(out, makeSlice(rawData.pData_, 0, rawData.size_), depth);\n                            }\n\n                            if (bIsXMP && bXMP) {\n                                out.write((const char*)rawData.pData_, rawData.size_);\n                            }\n                        }\n                    } break;\n\n                    default:\n                        break;\n                }\n\n                // Move to the next box.\n                io_->seek(static_cast<long>(position - sizeof(box) + box.length), BasicIo::beg);\n                if (io_->error())\n                    throw Error(kerFailedToReadImageData);\n                if (bPrint)\n                    lf(out, bLF);\n            }\n        }\n    }  // JpegBase::printStructure\n\n    void Jp2Image::writeMetadata()\n    {\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        BasicIo::UniquePtr tempIo(new MemIo);\n        assert (tempIo.get() != 0);\n\n        doWriteMetadata(*tempIo); // may throw\n        io_->close();\n        io_->transfer(*tempIo); // may throw\n\n    } // Jp2Image::writeMetadata\n\n#ifdef __clang__\n// ignore cast align errors.  dataBuf.pData_ is allocated by malloc() and 4 (or 8 byte aligned).\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wcast-align\"\n#endif\n\n    void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf)\n    {\n        DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space\n        int     outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?\n        int      inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?\n        Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;\n        int32_t       length = getLong((byte*)&pBox->length, bigEndian);\n        int32_t       count  = sizeof (Jp2BoxHeader);\n        char*         p      = (char*) boxBuf.pData_;\n        bool          bWroteColor = false ;\n\n        while ( count < length || !bWroteColor ) {\n            Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ;\n\n            // copy data.  pointer could be into a memory mapped file which we will decode!\n            Jp2BoxHeader   subBox ; memcpy(&subBox,pSubBox,sizeof(subBox));\n            Jp2BoxHeader   newBox =  subBox;\n\n            if ( count < length ) {\n                subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                subBox.type   = getLong((byte*)&subBox.type  , bigEndian);\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n#endif\n                count        += subBox.length;\n                newBox.type   = subBox.type;\n            } else {\n                subBox.length=0;\n                newBox.type = kJp2BoxTypeColorHeader;\n                count = length;\n            }\n\n            int32_t newlen = subBox.length;\n            if ( newBox.type == kJp2BoxTypeColorHeader ) {\n                bWroteColor = true ;\n                if ( ! iccProfileDefined() ) {\n                    const char* pad   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";\n                    uint32_t    psize = 15;\n                    newlen            = sizeof(newBox) + psize ;\n                    ul2Data((byte*)&newBox.length,psize      ,bigEndian);\n                    ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         );\n                } else {\n                    const char* pad   = \"\\x02\\x00\\x00\";\n                    uint32_t    psize = 3;\n                    newlen            = sizeof(newBox) + psize + iccProfile_.size_;\n                    ul2Data((byte*)&newBox.length,newlen,bigEndian);\n                    ul2Data((byte*)&newBox.type,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);\n                }\n            } else {\n                ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);\n            }\n\n            outlen += newlen;\n            inlen  += subBox.length;\n        }\n\n        // allocate the correct number of bytes, copy the data and update the box header\n        outBuf.alloc(outlen);\n        ::memcpy(outBuf.pData_,output.pData_,outlen);\n        pBox   = (Jp2BoxHeader*) outBuf.pData_;\n        ul2Data((byte*)&pBox->type,kJp2BoxTypeJp2Header,bigEndian);\n        ul2Data((byte*)&pBox->length,outlen,bigEndian);\n    } // Jp2Image::encodeJp2Header\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n    void Jp2Image::doWriteMetadata(BasicIo& outIo)\n    {\n        if (!io_->isopen()) throw Error(kerInputDataReadFailed);\n        if (!outIo.isopen()) throw Error(kerImageWriteFailed);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Writing JPEG-2000 file \" << io_->path() << std::endl;\n        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: tmp file created \" << outIo.path() << std::endl;\n#endif\n\n        // Ensure that this is the correct image type\n        if (!isJp2Type(*io_, true))\n        {\n            if (io_->error() || io_->eof()) throw Error(kerInputDataReadFailed);\n            throw Error(kerNoImageInInputData);\n        }\n\n        // Write JPEG2000 Signature.\n        if (outIo.write(Jp2Signature, 12) != 12) throw Error(kerImageWriteFailed);\n\n        Jp2BoxHeader box = {0,0};\n\n        byte    boxDataSize[4];\n        byte    boxUUIDtype[4];\n        DataBuf bheaderBuf(8);     // Box header : 4 bytes (data size) + 4 bytes (box type).\n\n        // FIXME: Andreas, why the loop do not stop when EOF is taken from _io. The loop go out by an exception\n        // generated by a zero size data read.\n\n        while(io_->tell() < (long) io_->size())\n        {\n#ifdef EXIV2_DEBUG_MESSAGES\n            std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Position: \" << io_->tell() << \" / \" << io_->size() << std::endl;\n#endif\n\n            // Read chunk header.\n\n            std::memset(bheaderBuf.pData_, 0x00, bheaderBuf.size_);\n            long bufRead = io_->read(bheaderBuf.pData_, bheaderBuf.size_);\n            if (io_->error()) throw Error(kerFailedToReadImageData);\n            if (bufRead != bheaderBuf.size_) throw Error(kerInputDataReadFailed);\n\n            // Decode box header.\n\n            box.length = getLong(bheaderBuf.pData_,     bigEndian);\n            box.type   = getLong(bheaderBuf.pData_ + 4, bigEndian);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n            std::cout << \"Exiv2::Jp2Image::doWriteMetadata: box type: \" << toAscii(box.type)\n                      << \" length: \" << box.length << std::endl;\n#endif\n\n            if (box.length == 0)\n            {\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Null Box size has been found. \"\n                             \"This is the last box of file.\" << std::endl;\n#endif\n                box.length = (uint32_t) (io_->size() - io_->tell() + 8);\n            }\n            if (box.length < 8)\n            {\n                // box is broken, so there is nothing we can do here\n                throw Error(kerCorruptedMetadata);\n            }\n\n            // Read whole box : Box header + Box data (not fixed size - can be null).\n\n            DataBuf boxBuf(box.length);                             // Box header (8 bytes) + box data.\n            memcpy(boxBuf.pData_, bheaderBuf.pData_, 8);               // Copy header.\n            bufRead = io_->read(boxBuf.pData_ + 8, box.length - 8); // Extract box data.\n            if (io_->error())\n            {\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Error reading source file\" << std::endl;\n#endif\n\n                throw Error(kerFailedToReadImageData);\n            }\n\n            if (bufRead != (long)(box.length - 8))\n            {\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Cannot read source file data\" << std::endl;\n#endif\n                throw Error(kerInputDataReadFailed);\n            }\n\n            switch(box.type)\n            {\n                case kJp2BoxTypeJp2Header:\n                {\n                    DataBuf newBuf;\n                    encodeJp2Header(boxBuf,newBuf);\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Write JP2Header box (length: \" << box.length << \")\" << std::endl;\n#endif\n                    if (outIo.write(newBuf.pData_, newBuf.size_) != newBuf.size_) throw Error(kerImageWriteFailed);\n\n                    // Write all updated metadata here, just after JP2Header.\n\n                    if (exifData_.count() > 0)\n                    {\n                        // Update Exif data to a new UUID box\n\n                        Blob blob;\n                        ExifParser::encode(blob, littleEndian, exifData_);\n                        if (blob.size())\n                        {\n                            DataBuf rawExif(static_cast<long>(blob.size()));\n                            memcpy(rawExif.pData_, &blob[0], blob.size());\n\n                            DataBuf boxData(8 + 16 + rawExif.size_);\n                            ul2Data(boxDataSize, boxData.size_, Exiv2::bigEndian);\n                            ul2Data(boxUUIDtype, kJp2BoxTypeUuid, Exiv2::bigEndian);\n                            memcpy(boxData.pData_,          boxDataSize,    4);\n                            memcpy(boxData.pData_ + 4,      boxUUIDtype,    4);\n                            memcpy(boxData.pData_ + 8,      kJp2UuidExif,   16);\n                            memcpy(boxData.pData_ + 8 + 16, rawExif.pData_, rawExif.size_);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n                            std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Write box with Exif metadata (length: \"\n                                      << boxData.size_ << std::endl;\n#endif\n                            if (outIo.write(boxData.pData_, boxData.size_) != boxData.size_) throw Error(kerImageWriteFailed);\n                        }\n                    }\n\n                    if (iptcData_.count() > 0)\n                    {\n                        // Update Iptc data to a new UUID box\n\n                        DataBuf rawIptc = IptcParser::encode(iptcData_);\n                        if (rawIptc.size_ > 0)\n                        {\n                            DataBuf boxData(8 + 16 + rawIptc.size_);\n                            ul2Data(boxDataSize, boxData.size_, Exiv2::bigEndian);\n                            ul2Data(boxUUIDtype, kJp2BoxTypeUuid, Exiv2::bigEndian);\n                            memcpy(boxData.pData_,          boxDataSize,    4);\n                            memcpy(boxData.pData_ + 4,      boxUUIDtype,    4);\n                            memcpy(boxData.pData_ + 8,      kJp2UuidIptc,   16);\n                            memcpy(boxData.pData_ + 8 + 16, rawIptc.pData_, rawIptc.size_);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n                            std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Write box with Iptc metadata (length: \"\n                                      << boxData.size_ << std::endl;\n#endif\n                            if (outIo.write(boxData.pData_, boxData.size_) != boxData.size_) throw Error(kerImageWriteFailed);\n                        }\n                    }\n\n                    if (writeXmpFromPacket() == false)\n                    {\n                        if (XmpParser::encode(xmpPacket_, xmpData_) > 1)\n                        {\n#ifndef SUPPRESS_WARNINGS\n                            EXV_ERROR << \"Failed to encode XMP metadata.\" << std::endl;\n#endif\n                        }\n                    }\n                    if (xmpPacket_.size() > 0)\n                    {\n                        // Update Xmp data to a new UUID box\n\n                        DataBuf xmp(reinterpret_cast<const byte*>(xmpPacket_.data()), static_cast<long>(xmpPacket_.size()));\n                        DataBuf boxData(8 + 16 + xmp.size_);\n                        ul2Data(boxDataSize, boxData.size_, Exiv2::bigEndian);\n                        ul2Data(boxUUIDtype, kJp2BoxTypeUuid, Exiv2::bigEndian);\n                        memcpy(boxData.pData_,          boxDataSize,  4);\n                        memcpy(boxData.pData_ + 4,      boxUUIDtype,  4);\n                        memcpy(boxData.pData_ + 8,      kJp2UuidXmp,  16);\n                        memcpy(boxData.pData_ + 8 + 16, xmp.pData_,   xmp.size_);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Write box with XMP metadata (length: \"\n                                  << boxData.size_ << \")\" << std::endl;\n#endif\n                        if (outIo.write(boxData.pData_, boxData.size_) != boxData.size_) throw Error(kerImageWriteFailed);\n                    }\n\n                    break;\n                }\n\n                case kJp2BoxTypeUuid:\n                {\n                    if(memcmp(boxBuf.pData_ + 8, kJp2UuidExif, 16) == 0)\n                    {\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: strip Exif Uuid box\" << std::endl;\n#endif\n                    }\n                    else if(memcmp(boxBuf.pData_ + 8, kJp2UuidIptc, 16) == 0)\n                    {\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: strip Iptc Uuid box\" << std::endl;\n#endif\n                    }\n                    else if(memcmp(boxBuf.pData_ + 8, kJp2UuidXmp,  16) == 0)\n                    {\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: strip Xmp Uuid box\" << std::endl;\n#endif\n                    }\n                    else\n                    {\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: write Uuid box (length: \" << box.length << \")\" << std::endl;\n#endif\n                        if (outIo.write(boxBuf.pData_, boxBuf.size_) != boxBuf.size_) throw Error(kerImageWriteFailed);\n                    }\n                    break;\n                }\n\n                default:\n                {\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cout << \"Exiv2::Jp2Image::doWriteMetadata: write box (length: \" << box.length << \")\" << std::endl;\n#endif\n                    if (outIo.write(boxBuf.pData_, boxBuf.size_) != boxBuf.size_) throw Error(kerImageWriteFailed);\n\n                    break;\n                }\n            }\n        }\n\n#ifdef EXIV2_DEBUG_MESSAGES\n        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: EOF\" << std::endl;\n#endif\n\n    } // Jp2Image::doWriteMetadata\n\n    // *************************************************************************\n    // free functions\n    Image::UniquePtr newJp2Instance(BasicIo::UniquePtr io, bool create)\n    {\n        Image::UniquePtr image(new Jp2Image(std::move(io), create));\n        if (!image->good())\n        {\n            image.reset();\n        }\n        return image;\n    }\n\n    bool isJp2Type(BasicIo& iIo, bool advance)\n    {\n        const int32_t len = 12;\n        byte buf[len];\n        iIo.read(buf, len);\n        if (iIo.error() || iIo.eof())\n        {\n            return false;\n        }\n        bool matched = (memcmp(buf, Jp2Signature, len) == 0);\n        if (!advance || !matched)\n        {\n            iIo.seek(-len, BasicIo::cur);\n        }\n        return matched;\n    }\n}                                       // namespace Exiv2\n"], "fixing_code": ["// ***************************************************************** -*- C++ -*-\n/*\n * Copyright (C) 2004-2021 Exiv2 authors\n * This program is part of the Exiv2 distribution.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, 5th Floor, Boston, MA 02110-1301 USA.\n */\n\n// *****************************************************************************\n\n// included header files\n#include \"config.h\"\n\n#include \"jp2image.hpp\"\n#include \"tiffimage.hpp\"\n#include \"image.hpp\"\n#include \"image_int.hpp\"\n#include \"basicio.hpp\"\n#include \"enforce.hpp\"\n#include \"error.hpp\"\n#include \"futils.hpp\"\n#include \"types.hpp\"\n#include \"safe_op.hpp\"\n\n// + standard includes\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <cstdio>\n\n// JPEG-2000 box types\nconst uint32_t kJp2BoxTypeJp2Header   = 0x6a703268; // 'jp2h'\nconst uint32_t kJp2BoxTypeImageHeader = 0x69686472; // 'ihdr'\nconst uint32_t kJp2BoxTypeColorHeader = 0x636f6c72; // 'colr'\nconst uint32_t kJp2BoxTypeUuid        = 0x75756964; // 'uuid'\nconst uint32_t kJp2BoxTypeClose       = 0x6a703263; // 'jp2c'\n\n// from openjpeg-2.1.2/src/lib/openjp2/jp2.h\n/*#define JPIP_JPIP 0x6a706970*/\n\n#define     JP2_JP   0x6a502020    /**< JPEG 2000 signature box */\n#define     JP2_FTYP 0x66747970    /**< File type box */\n#define     JP2_JP2H 0x6a703268    /**< JP2 header box (super-box) */\n#define     JP2_IHDR 0x69686472    /**< Image header box */\n#define     JP2_COLR 0x636f6c72    /**< Colour specification box */\n#define     JP2_JP2C 0x6a703263    /**< Contiguous codestream box */\n#define     JP2_URL  0x75726c20    /**< Data entry URL box */\n#define     JP2_PCLR 0x70636c72    /**< Palette box */\n#define     JP2_CMAP 0x636d6170    /**< Component Mapping box */\n#define     JP2_CDEF 0x63646566    /**< Channel Definition box */\n#define     JP2_DTBL 0x6474626c    /**< Data Reference box */\n#define     JP2_BPCC 0x62706363    /**< Bits per component box */\n#define     JP2_JP2  0x6a703220    /**< File type fields */\n\n/* For the future */\n/* #define JP2_RES 0x72657320 */  /**< Resolution box (super-box) */\n/* #define JP2_JP2I 0x6a703269 */  /**< Intellectual property box */\n/* #define JP2_XML  0x786d6c20 */  /**< XML box */\n/* #define JP2_UUID 0x75756994 */  /**< UUID box */\n/* #define JP2_UINF 0x75696e66 */  /**< UUID info box (super-box) */\n/* #define JP2_ULST 0x756c7374 */  /**< UUID list box */\n\n// JPEG-2000 UUIDs for embedded metadata\n//\n// See http://www.jpeg.org/public/wg1n2600.doc for information about embedding IPTC-NAA data in JPEG-2000 files\n// See http://www.adobe.com/devnet/xmp/pdfs/xmp_specification.pdf for information about embedding XMP data in JPEG-2000 files\nconst unsigned char kJp2UuidExif[] = \"JpgTiffExif->JP2\";\nconst unsigned char kJp2UuidIptc[] = \"\\x33\\xc7\\xa4\\xd2\\xb8\\x1d\\x47\\x23\\xa0\\xba\\xf1\\xa3\\xe0\\x97\\xad\\x38\";\nconst unsigned char kJp2UuidXmp[]  = \"\\xbe\\x7a\\xcf\\xcb\\x97\\xa9\\x42\\xe8\\x9c\\x71\\x99\\x94\\x91\\xe3\\xaf\\xac\";\n\n// See section B.1.1 (JPEG 2000 Signature box) of JPEG-2000 specification\nconst unsigned char Jp2Signature[12] = { 0x00, 0x00, 0x00, 0x0c, 0x6a, 0x50, 0x20, 0x20, 0x0d, 0x0a, 0x87, 0x0a };\n\nconst unsigned char Jp2Blank[] = { 0x00,0x00,0x00,0x0c,0x6a,0x50,0x20,0x20,0x0d,0x0a,0x87,0x0a,0x00,0x00,0x00,0x14,\n                                   0x66,0x74,0x79,0x70,0x6a,0x70,0x32,0x20,0x00,0x00,0x00,0x00,0x6a,0x70,0x32,0x20,\n                                   0x00,0x00,0x00,0x2d,0x6a,0x70,0x32,0x68,0x00,0x00,0x00,0x16,0x69,0x68,0x64,0x72,\n                                   0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x01,0x07,0x07,0x00,0x00,0x00,0x00,\n                                   0x00,0x0f,0x63,0x6f,0x6c,0x72,0x01,0x00,0x00,0x00,0x00,0x00,0x11,0x00,0x00,0x00,\n                                   0x00,0x6a,0x70,0x32,0x63,0xff,0x4f,0xff,0x51,0x00,0x29,0x00,0x00,0x00,0x00,0x00,\n                                   0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n                                   0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x07,\n                                   0x01,0x01,0xff,0x64,0x00,0x23,0x00,0x01,0x43,0x72,0x65,0x61,0x74,0x6f,0x72,0x3a,\n                                   0x20,0x4a,0x61,0x73,0x50,0x65,0x72,0x20,0x56,0x65,0x72,0x73,0x69,0x6f,0x6e,0x20,\n                                   0x31,0x2e,0x39,0x30,0x30,0x2e,0x31,0xff,0x52,0x00,0x0c,0x00,0x00,0x00,0x01,0x00,\n                                   0x05,0x04,0x04,0x00,0x01,0xff,0x5c,0x00,0x13,0x40,0x40,0x48,0x48,0x50,0x48,0x48,\n                                   0x50,0x48,0x48,0x50,0x48,0x48,0x50,0x48,0x48,0x50,0xff,0x90,0x00,0x0a,0x00,0x00,\n                                   0x00,0x00,0x00,0x2d,0x00,0x01,0xff,0x5d,0x00,0x14,0x00,0x40,0x40,0x00,0x00,0x00,\n                                   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x93,0xcf,0xb4,\n                                   0x04,0x00,0x80,0x80,0x80,0x80,0x80,0xff,0xd9\n                                 };\n\n//! @cond IGNORE\nstruct Jp2BoxHeader\n{\n    uint32_t length;\n    uint32_t type;\n};\n\nstruct Jp2ImageHeaderBox\n{\n    uint32_t imageHeight;\n    uint32_t imageWidth;\n    uint16_t componentCount;\n    uint8_t  bitsPerComponent;\n    uint8_t  compressionType;\n    uint8_t  colorspaceIsUnknown;\n    uint8_t  intellectualPropertyFlag;\n    uint16_t compressionTypeProfile;\n};\n\nstruct Jp2UuidBox\n{\n    uint8_t  uuid[16];\n};\n//! @endcond\n\n// *****************************************************************************\n// class member definitions\nnamespace Exiv2\n{\n\n    Jp2Image::Jp2Image(BasicIo::UniquePtr io, bool create)\n            : Image(ImageType::jp2, mdExif | mdIptc | mdXmp, std::move(io))\n    {\n        if (create)\n        {\n            if (io_->open() == 0)\n            {\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cerr << \"Exiv2::Jp2Image:: Creating JPEG2000 image to memory\" << std::endl;\n#endif\n                IoCloser closer(*io_);\n                if (io_->write(Jp2Blank, sizeof(Jp2Blank)) != sizeof(Jp2Blank))\n                {\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cerr << \"Exiv2::Jp2Image:: Failed to create JPEG2000 image on memory\" << std::endl;\n#endif\n                }\n            }\n        }\n    } // Jp2Image::Jp2Image\n\n    std::string Jp2Image::mimeType() const\n    {\n        return \"image/jp2\";\n    }\n\n    void Jp2Image::setComment(const std::string& /*comment*/)\n    {\n        // Todo: implement me!\n        throw(Error(kerInvalidSettingForImage, \"Image comment\", \"JP2\"));\n    } // Jp2Image::setComment\n\n    static void lf(std::ostream& out,bool& bLF)\n    {\n        if ( bLF ) {\n            out << std::endl;\n            out.flush();\n            bLF = false ;\n        }\n    }\n\n    static bool isBigEndian()\n    {\n        union {\n            uint32_t i;\n            char c[4];\n        } e = { 0x01000000 };\n\n        return e.c[0]?true:false;\n    }\n\n    static std::string toAscii(long n)\n    {\n        const char* p = (const char*) &n;\n        std::string result;\n        bool bBigEndian = isBigEndian();\n        for ( int i = 0 ; i < 4 ; i++) {\n            result += p[ bBigEndian ? i : (3-i) ];\n        }\n        return result;\n    }\n\nstatic void boxes_check(size_t b,size_t m)\n{\n    if ( b > m ) {\n#ifdef EXIV2_DEBUG_MESSAGES\n        std::cout << \"Exiv2::Jp2Image::readMetadata box maximum exceeded\" << std::endl;\n#endif\n        throw Error(kerCorruptedMetadata);\n    }\n}\n\n    void Jp2Image::readMetadata()\n    {\n#ifdef EXIV2_DEBUG_MESSAGES\n        std::cerr << \"Exiv2::Jp2Image::readMetadata: Reading JPEG-2000 file \" << io_->path() << std::endl;\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isJp2Type(*io_, true))\n        {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"JPEG-2000\");\n        }\n\n        long              position  = 0;\n        Jp2BoxHeader      box       = {0,0};\n        Jp2BoxHeader      subBox    = {0,0};\n        Jp2ImageHeaderBox ihdr      = {0,0,0,0,0,0,0,0};\n        Jp2UuidBox        uuid      = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};\n        size_t            boxes     = 0 ;\n        size_t            boxem     = 1000 ; // boxes max\n\n        while (io_->read((byte*)&box, sizeof(box)) == sizeof(box))\n        {\n            boxes_check(boxes++,boxem );\n            position   = io_->tell();\n            box.length = getLong((byte*)&box.length, bigEndian);\n            box.type   = getLong((byte*)&box.type, bigEndian);\n#ifdef EXIV2_DEBUG_MESSAGES\n            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                      << \"Position: \" << position\n                      << \" box type: \" << toAscii(box.type)\n                      << \" length: \" << box.length\n                      << std::endl;\n#endif\n\n            if (box.length == 0) return ;\n\n            if (box.length == 1)\n            {\n                // FIXME. Special case. the real box size is given in another place.\n            }\n\n            switch(box.type)\n            {\n                case kJp2BoxTypeJp2Header:\n                {\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: JP2Header box found\" << std::endl;\n#endif\n                    long restore = io_->tell();\n\n                    while (io_->read((byte*)&subBox, sizeof(subBox)) == sizeof(subBox) && subBox.length )\n                    {\n                        boxes_check(boxes++, boxem) ;\n                        subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                        subBox.type   = getLong((byte*)&subBox.type, bigEndian);\n                        if (subBox.length > io_->size() ) {\n                            throw Error(kerCorruptedMetadata);\n                        }\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                        << \"subBox = \" << toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n#endif\n                        if(subBox.type == kJp2BoxTypeColorHeader && subBox.length != 15)\n                        {\n#ifdef EXIV2_DEBUG_MESSAGES\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                                     << \"Color data found\" << std::endl;\n#endif\n\n                            const long pad = 3 ; // 3 padding bytes 2 0 0\n                            const size_t data_length = Safe::add(subBox.length, static_cast<uint32_t>(8));\n                            // data_length makes no sense if it is larger than the rest of the file\n                            if (data_length > io_->size() - io_->tell()) {\n                                throw Error(kerCorruptedMetadata);\n                            }\n                            DataBuf data(static_cast<long>(data_length));\n                            io_->read(data.pData_,data.size_);\n                            const long    iccLength = getULong(data.pData_+pad, bigEndian);\n                            // subtracting pad from data.size_ is safe:\n                            // size_ is at least 8 and pad = 3\n                            if (iccLength > data.size_ - pad) {\n                                throw Error(kerCorruptedMetadata);\n                            }\n                            DataBuf icc(iccLength);\n                            ::memcpy(icc.pData_,data.pData_+pad,icc.size_);\n#ifdef EXIV2_DEBUG_MESSAGES\n                            const char* iccPath = \"/tmp/libexiv2_jp2.icc\";\n                            FILE* f = fopen(iccPath,\"wb\");\n                            if ( f ) {\n                                fwrite(icc.pData_,icc.size_,1,f);\n                                fclose(f);\n                            }\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: wrote iccProfile \" << icc.size_<< \" bytes to \" << iccPath << std::endl ;\n#endif\n                            setIccProfile(icc);\n                        }\n\n                        if( subBox.type == kJp2BoxTypeImageHeader)\n                        {\n                            io_->read((byte*)&ihdr, sizeof(ihdr));\n#ifdef EXIV2_DEBUG_MESSAGES\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: Ihdr data found\" << std::endl;\n#endif\n                            ihdr.imageHeight            = getLong((byte*)&ihdr.imageHeight, bigEndian);\n                            ihdr.imageWidth             = getLong((byte*)&ihdr.imageWidth, bigEndian);\n                            ihdr.componentCount         = getShort((byte*)&ihdr.componentCount, bigEndian);\n                            ihdr.compressionTypeProfile = getShort((byte*)&ihdr.compressionTypeProfile, bigEndian);\n\n                            pixelWidth_  = ihdr.imageWidth;\n                            pixelHeight_ = ihdr.imageHeight;\n                        }\n\n                        io_->seek(restore,BasicIo::beg);\n                        if ( io_->seek(subBox.length, Exiv2::BasicIo::cur) != 0 ) {\n                            throw Error(kerCorruptedMetadata);\n                        }\n                        restore = io_->tell();\n                    }\n                    break;\n                }\n\n                case kJp2BoxTypeUuid:\n                {\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: UUID box found\" << std::endl;\n#endif\n\n                    if (io_->read((byte*)&uuid, sizeof(uuid)) == sizeof(uuid))\n                    {\n                        DataBuf rawData;\n                        long    bufRead;\n                        bool    bIsExif = memcmp(uuid.uuid, kJp2UuidExif, sizeof(uuid))==0;\n                        bool    bIsIPTC = memcmp(uuid.uuid, kJp2UuidIptc, sizeof(uuid))==0;\n                        bool    bIsXMP  = memcmp(uuid.uuid, kJp2UuidXmp , sizeof(uuid))==0;\n\n                        if(bIsExif)\n                        {\n#ifdef EXIV2_DEBUG_MESSAGES\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Exif data found\" << std::endl ;\n#endif\n                            rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(kerFailedToReadImageData);\n                            if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);\n\n                            if (rawData.size_ > 8) // \"II*\\0long\"\n                            {\n                                // Find the position of Exif header in bytes array.\n                                long pos = (     (rawData.pData_[0]      == rawData.pData_[1])\n                                           &&    (rawData.pData_[0]=='I' || rawData.pData_[0]=='M')\n                                           )  ? 0 : -1;\n\n                                // #1242  Forgive having Exif\\0\\0 in rawData.pData_\n                                const byte exifHeader[] = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                                for (long i=0 ; pos < 0 && i < rawData.size_-(long)sizeof(exifHeader) ; i++)\n                                {\n                                    if (memcmp(exifHeader, &rawData.pData_[i], sizeof(exifHeader)) == 0)\n                                    {\n                                        pos = i+sizeof(exifHeader);\n#ifndef SUPPRESS_WARNINGS\n                                        EXV_WARNING << \"Reading non-standard UUID-EXIF_bad box in \" << io_->path() << std::endl;\n#endif\n\n                                    }\n                                }\n\n                                // If found it, store only these data at from this place.\n                                if (pos >= 0 )\n                                {\n#ifdef EXIV2_DEBUG_MESSAGES\n                                    std::cout << \"Exiv2::Jp2Image::readMetadata: Exif header found at position \" << pos << std::endl;\n#endif\n                                    ByteOrder bo = TiffParser::decode(exifData(),\n                                                                      iptcData(),\n                                                                      xmpData(),\n                                                                      rawData.pData_ + pos,\n                                                                      rawData.size_ - pos);\n                                    setByteOrder(bo);\n                                }\n                            }\n                            else\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                                exifData_.clear();\n                            }\n                        }\n\n                        if(bIsIPTC)\n                        {\n#ifdef EXIV2_DEBUG_MESSAGES\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Iptc data found\" << std::endl;\n#endif\n                            rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(kerFailedToReadImageData);\n                            if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);\n\n                            if (IptcParser::decode(iptcData_, rawData.pData_, rawData.size_))\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode IPTC metadata.\" << std::endl;\n#endif\n                                iptcData_.clear();\n                            }\n                        }\n\n                        if(bIsXMP)\n                        {\n#ifdef EXIV2_DEBUG_MESSAGES\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Xmp data found\" << std::endl;\n#endif\n                            rawData.alloc(box.length - (uint32_t)(sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(kerFailedToReadImageData);\n                            if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);\n                            xmpPacket_.assign(reinterpret_cast<char *>(rawData.pData_), rawData.size_);\n\n                            std::string::size_type idx = xmpPacket_.find_first_of('<');\n                            if (idx != std::string::npos && idx > 0)\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Removing \" << static_cast<uint32_t>(idx)\n                                            << \" characters from the beginning of the XMP packet\" << std::endl;\n#endif\n                                xmpPacket_ = xmpPacket_.substr(idx);\n                            }\n\n                            if (xmpPacket_.size() > 0 && XmpParser::decode(xmpData_, xmpPacket_))\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                            }\n                        }\n                    }\n                    break;\n                }\n\n                default:\n                {\n                    break;\n                }\n            }\n\n            // Move to the next box.\n            io_->seek(static_cast<long>(position - sizeof(box) + box.length), BasicIo::beg);\n            if (io_->error()) throw Error(kerFailedToReadImageData);\n        }\n\n    } // Jp2Image::readMetadata\n\n    void Jp2Image::printStructure(std::ostream& out, PrintStructureOption option, int depth)\n    {\n        if (io_->open() != 0)\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n\n        // Ensure that this is the correct image type\n        if (!isJp2Type(*io_, false)) {\n            if (io_->error() || io_->eof())\n                throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAJpeg);\n        }\n\n        bool bPrint = option == kpsBasic || option == kpsRecursive;\n        bool bRecursive = option == kpsRecursive;\n        bool bICC = option == kpsIccProfile;\n        bool bXMP = option == kpsXMP;\n        bool bIPTCErase = option == kpsIptcErase;\n\n        if (bPrint) {\n            out << \"STRUCTURE OF JPEG2000 FILE: \" << io_->path() << std::endl;\n            out << \" address |   length | box       | data\" << std::endl;\n        }\n\n        if ( bPrint || bXMP || bICC || bIPTCErase ) {\n\n            long              position  = 0;\n            Jp2BoxHeader      box       = {1,1};\n            Jp2BoxHeader      subBox    = {1,1};\n            Jp2UuidBox        uuid      = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};\n            bool              bLF       = false;\n\n            while (box.length && box.type != kJp2BoxTypeClose && io_->read((byte*)&box, sizeof(box)) == sizeof(box))\n            {\n                position   = io_->tell();\n                box.length = getLong((byte*)&box.length, bigEndian);\n                box.type = getLong((byte*)&box.type, bigEndian);\n                enforce(box.length <= io_->size()-io_->tell() , Exiv2::kerCorruptedMetadata);\n\n                if (bPrint) {\n                    out << Internal::stringFormat(\"%8ld | %8ld | \", position - sizeof(box),\n                                                  (size_t)box.length)\n                        << toAscii(box.type) << \"      | \";\n                    bLF = true;\n                    if (box.type == kJp2BoxTypeClose)\n                        lf(out, bLF);\n                }\n                if (box.type == kJp2BoxTypeClose)\n                    break;\n\n                switch (box.type) {\n                    case kJp2BoxTypeJp2Header: {\n                        lf(out, bLF);\n\n                        while (io_->read((byte*)&subBox, sizeof(subBox)) == sizeof(subBox) &&\n                               io_->tell() < position + (long)box.length)  // don't read beyond the box!\n                        {\n                            int address = io_->tell() - sizeof(subBox);\n                            subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                            subBox.type = getLong((byte*)&subBox.type, bigEndian);\n\n                            if (subBox.length < sizeof(box) || subBox.length > io_->size() - io_->tell()) {\n                                throw Error(kerCorruptedMetadata);\n                            }\n\n                            DataBuf data(subBox.length - sizeof(box));\n                            io_->read(data.pData_, data.size_);\n                            if (bPrint) {\n                                out << Internal::stringFormat(\"%8ld | %8ld |  sub:\", (size_t)address,\n                                                              (size_t)subBox.length)\n                                    << toAscii(subBox.type) << \" | \"\n                                    << Internal::binaryToString(makeSlice(data, 0, std::min(30l, data.size_)));\n                                bLF = true;\n                            }\n\n                            if (subBox.type == kJp2BoxTypeColorHeader) {\n                                long pad = 3;  // don't know why there are 3 padding bytes\n                                if (bPrint) {\n                                    out << \" | pad:\";\n                                    for (int i = 0; i < 3; i++)\n                                        out << \" \" << (int)data.pData_[i];\n                                }\n                                long iccLength = getULong(data.pData_ + pad, bigEndian);\n                                if (bPrint) {\n                                    out << \" | iccLength:\" << iccLength;\n                                }\n                                if (bICC) {\n                                    out.write((const char*)data.pData_ + pad, iccLength);\n                                }\n                            }\n                            lf(out, bLF);\n                        }\n                    } break;\n\n                    case kJp2BoxTypeUuid: {\n                        if (io_->read((byte*)&uuid, sizeof(uuid)) == sizeof(uuid)) {\n                            bool bIsExif = memcmp(uuid.uuid, kJp2UuidExif, sizeof(uuid)) == 0;\n                            bool bIsIPTC = memcmp(uuid.uuid, kJp2UuidIptc, sizeof(uuid)) == 0;\n                            bool bIsXMP = memcmp(uuid.uuid, kJp2UuidXmp, sizeof(uuid)) == 0;\n\n                            bool bUnknown = !(bIsExif || bIsIPTC || bIsXMP);\n\n                            if (bPrint) {\n                                if (bIsExif)\n                                    out << \"Exif: \";\n                                if (bIsIPTC)\n                                    out << \"IPTC: \";\n                                if (bIsXMP)\n                                    out << \"XMP : \";\n                                if (bUnknown)\n                                    out << \"????: \";\n                            }\n\n                            DataBuf rawData;\n                            rawData.alloc(box.length - sizeof(uuid) - sizeof(box));\n                            long bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error())\n                                throw Error(kerFailedToReadImageData);\n                            if (bufRead != rawData.size_)\n                                throw Error(kerInputDataReadFailed);\n\n                            if (bPrint) {\n                                out << Internal::binaryToString(\n                                        makeSlice(rawData, 0, rawData.size_>40?40:rawData.size_));\n                                out.flush();\n                            }\n                            lf(out, bLF);\n\n                            if (bIsExif && bRecursive && rawData.size_ > 8) { // \"II*\\0long\"\n                                if ((rawData.pData_[0] == rawData.pData_[1]) &&\n                                    (rawData.pData_[0] == 'I' || rawData.pData_[0] == 'M')) {\n                                    BasicIo::UniquePtr p = BasicIo::UniquePtr(new MemIo(rawData.pData_, rawData.size_));\n                                    printTiffStructure(*p, out, option, depth);\n                                }\n                            }\n\n                            if (bIsIPTC && bRecursive) {\n                                IptcData::printStructure(out, makeSlice(rawData.pData_, 0, rawData.size_), depth);\n                            }\n\n                            if (bIsXMP && bXMP) {\n                                out.write((const char*)rawData.pData_, rawData.size_);\n                            }\n                        }\n                    } break;\n\n                    default:\n                        break;\n                }\n\n                // Move to the next box.\n                io_->seek(static_cast<long>(position - sizeof(box) + box.length), BasicIo::beg);\n                if (io_->error())\n                    throw Error(kerFailedToReadImageData);\n                if (bPrint)\n                    lf(out, bLF);\n            }\n        }\n    }  // JpegBase::printStructure\n\n    void Jp2Image::writeMetadata()\n    {\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        BasicIo::UniquePtr tempIo(new MemIo);\n        assert (tempIo.get() != 0);\n\n        doWriteMetadata(*tempIo); // may throw\n        io_->close();\n        io_->transfer(*tempIo); // may throw\n\n    } // Jp2Image::writeMetadata\n\n#ifdef __clang__\n// ignore cast align errors.  dataBuf.pData_ is allocated by malloc() and 4 (or 8 byte aligned).\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wcast-align\"\n#endif\n\n    void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf)\n    {\n        DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space\n        long    outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?\n        long    inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?\n        Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;\n        uint32_t      length = getLong((byte*)&pBox->length, bigEndian);\n        uint32_t      count  = sizeof (Jp2BoxHeader);\n        char*         p      = (char*) boxBuf.pData_;\n        bool          bWroteColor = false ;\n\n        while ( count < length || !bWroteColor ) {\n            Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ;\n\n            // copy data.  pointer could be into a memory mapped file which we will decode!\n            Jp2BoxHeader   subBox ; memcpy(&subBox,pSubBox,sizeof(subBox));\n            Jp2BoxHeader   newBox =  subBox;\n\n            if ( count < length ) {\n                subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                subBox.type   = getLong((byte*)&subBox.type  , bigEndian);\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n#endif\n                enforce(subBox.length <= length - count, Exiv2::kerCorruptedMetadata);\n                count        += subBox.length;\n                newBox.type   = subBox.type;\n            } else {\n                subBox.length=0;\n                newBox.type = kJp2BoxTypeColorHeader;\n                count = length;\n            }\n\n            uint32_t newlen = subBox.length;\n            if ( newBox.type == kJp2BoxTypeColorHeader ) {\n                bWroteColor = true ;\n                if ( ! iccProfileDefined() ) {\n                    const char* pad   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";\n                    uint32_t    psize = 15;\n                    newlen            = sizeof(newBox) + psize ;\n                    enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);\n                    ul2Data((byte*)&newBox.length,psize      ,bigEndian);\n                    ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         );\n                } else {\n                    const char* pad   = \"\\x02\\x00\\x00\";\n                    uint32_t    psize = 3;\n                    newlen            = sizeof(newBox) + psize + iccProfile_.size_;\n                    enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);\n                    ul2Data((byte*)&newBox.length,newlen,bigEndian);\n                    ul2Data((byte*)&newBox.type,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);\n                }\n            } else {\n                enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);\n                ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);\n            }\n\n            outlen += newlen;\n            inlen  += subBox.length;\n        }\n\n        // allocate the correct number of bytes, copy the data and update the box header\n        outBuf.alloc(outlen);\n        ::memcpy(outBuf.pData_,output.pData_,outlen);\n        pBox   = (Jp2BoxHeader*) outBuf.pData_;\n        ul2Data((byte*)&pBox->type,kJp2BoxTypeJp2Header,bigEndian);\n        ul2Data((byte*)&pBox->length,outlen,bigEndian);\n    } // Jp2Image::encodeJp2Header\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n    void Jp2Image::doWriteMetadata(BasicIo& outIo)\n    {\n        if (!io_->isopen()) throw Error(kerInputDataReadFailed);\n        if (!outIo.isopen()) throw Error(kerImageWriteFailed);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Writing JPEG-2000 file \" << io_->path() << std::endl;\n        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: tmp file created \" << outIo.path() << std::endl;\n#endif\n\n        // Ensure that this is the correct image type\n        if (!isJp2Type(*io_, true))\n        {\n            if (io_->error() || io_->eof()) throw Error(kerInputDataReadFailed);\n            throw Error(kerNoImageInInputData);\n        }\n\n        // Write JPEG2000 Signature.\n        if (outIo.write(Jp2Signature, 12) != 12) throw Error(kerImageWriteFailed);\n\n        Jp2BoxHeader box = {0,0};\n\n        byte    boxDataSize[4];\n        byte    boxUUIDtype[4];\n        DataBuf bheaderBuf(8);     // Box header : 4 bytes (data size) + 4 bytes (box type).\n\n        // FIXME: Andreas, why the loop do not stop when EOF is taken from _io. The loop go out by an exception\n        // generated by a zero size data read.\n\n        while(io_->tell() < (long) io_->size())\n        {\n#ifdef EXIV2_DEBUG_MESSAGES\n            std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Position: \" << io_->tell() << \" / \" << io_->size() << std::endl;\n#endif\n\n            // Read chunk header.\n\n            std::memset(bheaderBuf.pData_, 0x00, bheaderBuf.size_);\n            long bufRead = io_->read(bheaderBuf.pData_, bheaderBuf.size_);\n            if (io_->error()) throw Error(kerFailedToReadImageData);\n            if (bufRead != bheaderBuf.size_) throw Error(kerInputDataReadFailed);\n\n            // Decode box header.\n\n            box.length = getLong(bheaderBuf.pData_,     bigEndian);\n            box.type   = getLong(bheaderBuf.pData_ + 4, bigEndian);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n            std::cout << \"Exiv2::Jp2Image::doWriteMetadata: box type: \" << toAscii(box.type)\n                      << \" length: \" << box.length << std::endl;\n#endif\n\n            if (box.length == 0)\n            {\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Null Box size has been found. \"\n                             \"This is the last box of file.\" << std::endl;\n#endif\n                box.length = (uint32_t) (io_->size() - io_->tell() + 8);\n            }\n            if (box.length < 8)\n            {\n                // box is broken, so there is nothing we can do here\n                throw Error(kerCorruptedMetadata);\n            }\n\n            // Read whole box : Box header + Box data (not fixed size - can be null).\n\n            DataBuf boxBuf(box.length);                             // Box header (8 bytes) + box data.\n            memcpy(boxBuf.pData_, bheaderBuf.pData_, 8);               // Copy header.\n            bufRead = io_->read(boxBuf.pData_ + 8, box.length - 8); // Extract box data.\n            if (io_->error())\n            {\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Error reading source file\" << std::endl;\n#endif\n\n                throw Error(kerFailedToReadImageData);\n            }\n\n            if (bufRead != (long)(box.length - 8))\n            {\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Cannot read source file data\" << std::endl;\n#endif\n                throw Error(kerInputDataReadFailed);\n            }\n\n            switch(box.type)\n            {\n                case kJp2BoxTypeJp2Header:\n                {\n                    DataBuf newBuf;\n                    encodeJp2Header(boxBuf,newBuf);\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Write JP2Header box (length: \" << box.length << \")\" << std::endl;\n#endif\n                    if (outIo.write(newBuf.pData_, newBuf.size_) != newBuf.size_) throw Error(kerImageWriteFailed);\n\n                    // Write all updated metadata here, just after JP2Header.\n\n                    if (exifData_.count() > 0)\n                    {\n                        // Update Exif data to a new UUID box\n\n                        Blob blob;\n                        ExifParser::encode(blob, littleEndian, exifData_);\n                        if (blob.size())\n                        {\n                            DataBuf rawExif(static_cast<long>(blob.size()));\n                            memcpy(rawExif.pData_, &blob[0], blob.size());\n\n                            DataBuf boxData(8 + 16 + rawExif.size_);\n                            ul2Data(boxDataSize, boxData.size_, Exiv2::bigEndian);\n                            ul2Data(boxUUIDtype, kJp2BoxTypeUuid, Exiv2::bigEndian);\n                            memcpy(boxData.pData_,          boxDataSize,    4);\n                            memcpy(boxData.pData_ + 4,      boxUUIDtype,    4);\n                            memcpy(boxData.pData_ + 8,      kJp2UuidExif,   16);\n                            memcpy(boxData.pData_ + 8 + 16, rawExif.pData_, rawExif.size_);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n                            std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Write box with Exif metadata (length: \"\n                                      << boxData.size_ << std::endl;\n#endif\n                            if (outIo.write(boxData.pData_, boxData.size_) != boxData.size_) throw Error(kerImageWriteFailed);\n                        }\n                    }\n\n                    if (iptcData_.count() > 0)\n                    {\n                        // Update Iptc data to a new UUID box\n\n                        DataBuf rawIptc = IptcParser::encode(iptcData_);\n                        if (rawIptc.size_ > 0)\n                        {\n                            DataBuf boxData(8 + 16 + rawIptc.size_);\n                            ul2Data(boxDataSize, boxData.size_, Exiv2::bigEndian);\n                            ul2Data(boxUUIDtype, kJp2BoxTypeUuid, Exiv2::bigEndian);\n                            memcpy(boxData.pData_,          boxDataSize,    4);\n                            memcpy(boxData.pData_ + 4,      boxUUIDtype,    4);\n                            memcpy(boxData.pData_ + 8,      kJp2UuidIptc,   16);\n                            memcpy(boxData.pData_ + 8 + 16, rawIptc.pData_, rawIptc.size_);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n                            std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Write box with Iptc metadata (length: \"\n                                      << boxData.size_ << std::endl;\n#endif\n                            if (outIo.write(boxData.pData_, boxData.size_) != boxData.size_) throw Error(kerImageWriteFailed);\n                        }\n                    }\n\n                    if (writeXmpFromPacket() == false)\n                    {\n                        if (XmpParser::encode(xmpPacket_, xmpData_) > 1)\n                        {\n#ifndef SUPPRESS_WARNINGS\n                            EXV_ERROR << \"Failed to encode XMP metadata.\" << std::endl;\n#endif\n                        }\n                    }\n                    if (xmpPacket_.size() > 0)\n                    {\n                        // Update Xmp data to a new UUID box\n\n                        DataBuf xmp(reinterpret_cast<const byte*>(xmpPacket_.data()), static_cast<long>(xmpPacket_.size()));\n                        DataBuf boxData(8 + 16 + xmp.size_);\n                        ul2Data(boxDataSize, boxData.size_, Exiv2::bigEndian);\n                        ul2Data(boxUUIDtype, kJp2BoxTypeUuid, Exiv2::bigEndian);\n                        memcpy(boxData.pData_,          boxDataSize,  4);\n                        memcpy(boxData.pData_ + 4,      boxUUIDtype,  4);\n                        memcpy(boxData.pData_ + 8,      kJp2UuidXmp,  16);\n                        memcpy(boxData.pData_ + 8 + 16, xmp.pData_,   xmp.size_);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Write box with XMP metadata (length: \"\n                                  << boxData.size_ << \")\" << std::endl;\n#endif\n                        if (outIo.write(boxData.pData_, boxData.size_) != boxData.size_) throw Error(kerImageWriteFailed);\n                    }\n\n                    break;\n                }\n\n                case kJp2BoxTypeUuid:\n                {\n                    if(memcmp(boxBuf.pData_ + 8, kJp2UuidExif, 16) == 0)\n                    {\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: strip Exif Uuid box\" << std::endl;\n#endif\n                    }\n                    else if(memcmp(boxBuf.pData_ + 8, kJp2UuidIptc, 16) == 0)\n                    {\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: strip Iptc Uuid box\" << std::endl;\n#endif\n                    }\n                    else if(memcmp(boxBuf.pData_ + 8, kJp2UuidXmp,  16) == 0)\n                    {\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: strip Xmp Uuid box\" << std::endl;\n#endif\n                    }\n                    else\n                    {\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: write Uuid box (length: \" << box.length << \")\" << std::endl;\n#endif\n                        if (outIo.write(boxBuf.pData_, boxBuf.size_) != boxBuf.size_) throw Error(kerImageWriteFailed);\n                    }\n                    break;\n                }\n\n                default:\n                {\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cout << \"Exiv2::Jp2Image::doWriteMetadata: write box (length: \" << box.length << \")\" << std::endl;\n#endif\n                    if (outIo.write(boxBuf.pData_, boxBuf.size_) != boxBuf.size_) throw Error(kerImageWriteFailed);\n\n                    break;\n                }\n            }\n        }\n\n#ifdef EXIV2_DEBUG_MESSAGES\n        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: EOF\" << std::endl;\n#endif\n\n    } // Jp2Image::doWriteMetadata\n\n    // *************************************************************************\n    // free functions\n    Image::UniquePtr newJp2Instance(BasicIo::UniquePtr io, bool create)\n    {\n        Image::UniquePtr image(new Jp2Image(std::move(io), create));\n        if (!image->good())\n        {\n            image.reset();\n        }\n        return image;\n    }\n\n    bool isJp2Type(BasicIo& iIo, bool advance)\n    {\n        const int32_t len = 12;\n        byte buf[len];\n        iIo.read(buf, len);\n        if (iIo.error() || iIo.eof())\n        {\n            return false;\n        }\n        bool matched = (memcmp(buf, Jp2Signature, len) == 0);\n        if (!advance || !matched)\n        {\n            iIo.seek(-len, BasicIo::cur);\n        }\n        return matched;\n    }\n}                                       // namespace Exiv2\n"], "filenames": ["src/jp2image.cpp"], "buggy_code_start_loc": [649], "buggy_code_end_loc": [699], "fixing_code_start_loc": [649], "fixing_code_end_loc": [704], "type": "CWE-787", "message": "Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. A heap buffer overflow was found in Exiv2 versions v0.27.3 and earlier. The heap overflow is triggered when Exiv2 is used to write metadata into a crafted image file. An attacker could potentially exploit the vulnerability to gain code execution, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when writing the metadata, which is a less frequently used Exiv2 operation than reading the metadata. For example, to trigger the bug in the Exiv2 command-line application, you need to add an extra command-line argument such as `insert`. The bug is fixed in version v0.27.4.", "other": {"cve": {"id": "CVE-2021-29464", "sourceIdentifier": "security-advisories@github.com", "published": "2021-04-30T19:15:07.187", "lastModified": "2022-04-05T18:02:59.593", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. A heap buffer overflow was found in Exiv2 versions v0.27.3 and earlier. The heap overflow is triggered when Exiv2 is used to write metadata into a crafted image file. An attacker could potentially exploit the vulnerability to gain code execution, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when writing the metadata, which is a less frequently used Exiv2 operation than reading the metadata. For example, to trigger the bug in the Exiv2 command-line application, you need to add an extra command-line argument such as `insert`. The bug is fixed in version v0.27.4."}, {"lang": "es", "value": "Exiv2 es una utilidad de l\u00ednea de comandos y una biblioteca C++ para leer, escribir, eliminar y modificar los metadatos de archivos de imagen.&#xa0;Se encontr\u00f3 un desbordamiento del b\u00fafer de la memoria en Exiv2 versiones v0.27.3 y anteriores.&#xa0;El desbordamiento de la pila es activada cuando se usa Exiv2 para escribir metadatos en un archivo de imagen dise\u00f1ado.&#xa0;Un atacante podr\u00eda explotar potencialmente la vulnerabilidad para conseguir una ejecuci\u00f3n del c\u00f3digo, si puede enga\u00f1ar a la v\u00edctima para ejecutar Exiv2 en un archivo de imagen dise\u00f1ado.&#xa0;Tome en cuenta que este bug solo es activado al escribir los metadatos, que es una operaci\u00f3n Exiv2 que es usado con menos frecuencia que leer los metadatos.&#xa0;Por ejemplo, para desencadenar el bug en la aplicaci\u00f3n de l\u00ednea de comandos Exiv2, es necesario agregar un argumento de l\u00ednea de comando adicional como \"insert\".&#xa0;El bug se corrigi\u00f3 en la versi\u00f3n v0.27.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:exiv2:exiv2:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.27.4", "matchCriteriaId": "0A049EBD-7A7E-458F-9ABD-F6626DDEABB9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}], "references": [{"url": "https://github.com/Exiv2/exiv2/commit/f9308839198aca5e68a65194f151a1de92398f54", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Exiv2/exiv2/security/advisories/GHSA-jgm9-5fw5-pw9p", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/K3HKXR6JOVKMBE4HY4FDXNVZGNCQG6T3/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NDMZTVQAZSMLPTDVDYLBHAAF7I5QXVYQ/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Exiv2/exiv2/commit/f9308839198aca5e68a65194f151a1de92398f54"}}