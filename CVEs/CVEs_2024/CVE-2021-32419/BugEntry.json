{"buggy_code": ["/*\n * Schism Tracker - a cross-platform Impulse Tracker clone\n * copyright (c) 2003-2005 Storlek <storlek@rigelseven.com>\n * copyright (c) 2005-2008 Mrs. Brisby <mrs.brisby@nimh.org>\n * copyright (c) 2009 Storlek & Mrs. Brisby\n * copyright (c) 2010-2012 Storlek\n * URL: http://schismtracker.org/\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#define NEED_BYTESWAP\n#include \"headers.h\"\n#include \"fmt.h\"\n#include \"song.h\"\n#include \"tables.h\"\n#include \"log.h\"\n\n#include <stdint.h>\n\n/* --------------------------------------------------------------------- */\n\n#pragma pack(push, 1)\ntypedef struct mtm_header {\n\tchar filever[4]; /* M T M \\x10 */\n\tchar title[20]; /* asciz */\n\tuint16_t ntracks;\n\tuint8_t last_pattern;\n\tuint8_t last_order; /* songlength - 1 */\n\tuint16_t msglen;\n\tuint8_t nsamples;\n\tuint8_t flags; /* always 0 */\n\tuint8_t rows; /* prob. 64 */\n\tuint8_t nchannels;\n\tuint8_t panpos[32];\n} mtm_header_t;\n\ntypedef struct mtm_sample {\n\tchar name[22];\n\tuint32_t length, loop_start, loop_end;\n\tuint8_t finetune, volume, flags;\n} mtm_sample_t;\n#pragma pack(pop)\n\n/* --------------------------------------------------------------------- */\n\nint fmt_mtm_read_info(dmoz_file_t *file, const uint8_t *data, size_t length)\n{\n\tif (!(length > 24 && memcmp(data, \"MTM\", 3) == 0))\n\t\treturn 0;\n\n\tfile->description = \"MultiTracker Module\";\n\t/*file->extension = str_dup(\"mtm\");*/\n\tfile->title = strn_dup((const char *)data + 4, 20);\n\tfile->type = TYPE_MODULE_MOD;\n\treturn 1;\n}\n\n/* --------------------------------------------------------------------------------------------------------- */\n\nstatic void mtm_unpack_track(const uint8_t *b, song_note_t *note, int rows)\n{\n\tint n;\n\n\tfor (n = 0; n < rows; n++, note++, b += 3) {\n\t\tnote->note = ((b[0] & 0xfc) ? ((b[0] >> 2) + 36 + 1) : NOTE_NONE);\n\t\tnote->instrument = ((b[0] & 0x3) << 4) | (b[1] >> 4);\n\t\tnote->voleffect = VOLFX_NONE;\n\t\tnote->volparam = 0;\n\t\tnote->effect = b[1] & 0xf;\n\t\tnote->param = b[2];\n\t\t/* From mikmod: volume slide up always overrides slide down */\n\t\tif (note->effect == 0xa && (note->param & 0xf0))\n\t\t\tnote->param &= 0xf0;\n\t\tcsf_import_mod_effect(note, 0);\n\t}\n}\n\nint fmt_mtm_load_song(song_t *song, slurp_t *fp, unsigned int lflags)\n{\n\tuint8_t b[192];\n\tuint8_t nchan, nord, npat, nsmp;\n\tuint16_t ntrk, comment_len;\n\tint n, pat, chan, smp, rows, todo = 0;\n\tsong_note_t *note;\n\tuint16_t tmp;\n\tuint32_t tmplong;\n\tsong_note_t **trackdata, *tracknote;\n\tsong_sample_t *sample;\n\n\tslurp_read(fp, b, 3);\n\tif (memcmp(b, \"MTM\", 3) != 0)\n\t\treturn LOAD_UNSUPPORTED;\n\tn = slurp_getc(fp);\n\tsprintf(song->tracker_id, \"MultiTracker %d.%d\", n >> 4, n & 0xf);\n\tslurp_read(fp, song->title, 20);\n\tsong->title[20] = 0;\n\tslurp_read(fp, &ntrk, 2);\n\tntrk = bswapLE16(ntrk);\n\tnpat = slurp_getc(fp);\n\tnord = slurp_getc(fp) + 1;\n\n\tslurp_read(fp, &comment_len, 2);\n\tcomment_len = bswapLE16(comment_len);\n\n\tnsmp = slurp_getc(fp);\n\tslurp_getc(fp); /* attribute byte (unused) */\n\trows = slurp_getc(fp); /* beats per track (translation: number of rows in every pattern) */\n\tif (rows != 64)\n\t\ttodo |= 64;\n\trows = MIN(rows, 64);\n\tnchan = slurp_getc(fp);\n\n\tif (slurp_eof(fp)) {\n\t\treturn LOAD_FORMAT_ERROR;\n\t}\n\n\tfor (n = 0; n < 32; n++) {\n\t\tint pan = slurp_getc(fp) & 0xf;\n\t\tpan = SHORT_PANNING(pan);\n\t\tpan *= 4; //mphack\n\t\tsong->channels[n].panning = pan;\n\t}\n\tfor (n = nchan; n < MAX_CHANNELS; n++)\n\t\tsong->channels[n].flags = CHN_MUTE;\n\n\t/* samples */\n\tif (nsmp > MAX_SAMPLES) {\n\t\tlog_appendf(4, \" Warning: Too many samples\");\n\t}\n\tfor (n = 1, sample = song->samples + 1; n <= nsmp; n++, sample++) {\n\t\tif (n > MAX_SAMPLES) {\n\t\t\tslurp_seek(fp, 37, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* IT truncates .mtm sample names at the first \\0 rather than the normal behavior\n\t\tof presenting them as spaces (k-achaet.mtm has some \"junk\" in the sample text) */\n\t\tchar name[23];\n\t\tslurp_read(fp, name, 22);\n\t\tname[22] = '\\0';\n\t\tstrcpy(sample->name, name);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->length = bswapLE32(tmplong);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->loop_start = bswapLE32(tmplong);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->loop_end = bswapLE32(tmplong);\n\t\tif ((sample->loop_end - sample->loop_start) > 2) {\n\t\t\tsample->flags |= CHN_LOOP;\n\t\t} else {\n\t\t\t/* Both Impulse Tracker and Modplug do this */\n\t\t\tsample->loop_start = 0;\n\t\t\tsample->loop_end = 0;\n\t\t}\n\t\tsong->samples[n].c5speed = MOD_FINETUNE(slurp_getc(fp));\n\t\tsample->volume = slurp_getc(fp);\n\t\tsample->volume *= 4; //mphack\n\t\tsample->global_volume = 64;\n\t\tif (slurp_getc(fp) & 1) {\n\t\t\ttodo |= 16;\n\t\t\tsample->flags |= CHN_16BIT;\n\t\t\tsample->length >>= 1;\n\t\t\tsample->loop_start >>= 1;\n\t\t\tsample->loop_end >>= 1;\n\t\t}\n\t\tsong->samples[n].vib_type = 0;\n\t\tsong->samples[n].vib_rate = 0;\n\t\tsong->samples[n].vib_depth = 0;\n\t\tsong->samples[n].vib_speed = 0;\n\t}\n\n\t/* orderlist */\n\tslurp_read(fp, song->orderlist, 128);\n\tmemset(song->orderlist + nord, ORDER_LAST, MAX_ORDERS - nord);\n\n\t/* tracks */\n\ttrackdata = mem_calloc(ntrk, sizeof(song_note_t *));\n\tfor (n = 0; n < ntrk; n++) {\n\t\tslurp_read(fp, b, 3 * rows);\n\t\ttrackdata[n] = mem_calloc(rows, sizeof(song_note_t));\n\t\tmtm_unpack_track(b, trackdata[n], rows);\n\t}\n\n\t/* patterns */\n\tif (npat >= MAX_PATTERNS) {\n\t\tlog_appendf(4, \" Warning: Too many patterns\");\n\t}\n\tfor (pat = 0; pat <= npat; pat++) {\n\t\t// skip ones that can't be loaded\n\t\tif (pat >= MAX_PATTERNS) {\n\t\t\tslurp_seek(fp, 64, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsong->patterns[pat] = csf_allocate_pattern(MAX(rows, 32));\n\t\tsong->pattern_size[pat] = song->pattern_alloc_size[pat] = 64;\n\t\ttracknote = trackdata[n];\n\t\tfor (chan = 0; chan < 32; chan++) {\n\t\t\tslurp_read(fp, &tmp, 2);\n\t\t\ttmp = bswapLE16(tmp);\n\t\t\tif (tmp == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (tmp > ntrk) {\n\t\t\t\tfor (n = 0; n < ntrk; n++)\n\t\t\t\t\tfree(trackdata[n]);\n\t\t\t\tfree(trackdata);\n\t\t\t\treturn LOAD_FORMAT_ERROR;\n\t\t\t}\n\t\t\tnote = song->patterns[pat] + chan;\n\t\t\ttracknote = trackdata[tmp - 1];\n\t\t\tfor (n = 0; n < rows; n++, tracknote++, note += MAX_CHANNELS)\n\t\t\t\t*note = *tracknote;\n\t\t}\n\t\tif (rows < 32) {\n\t\t\t/* stick a pattern break on the first channel with an empty effect column\n\t\t\t * (XXX don't do this if there's already one in another column) */\n\t\t\tnote = song->patterns[pat] + 64 * (rows - 1);\n\t\t\twhile (note->effect || note->param)\n\t\t\t\tnote++;\n\t\t\tnote->effect = FX_PATTERNBREAK;\n\t\t}\n\t}\n\n\t/* free willy */\n\tfor (n = 0; n < ntrk; n++)\n\t\tfree(trackdata[n]);\n\tfree(trackdata);\n\n\tread_lined_message(song->message, fp, comment_len, 40);\n\n\t/* sample data */\n\tif (!(lflags & LOAD_NOSAMPLES)) {\n\t\tfor (smp = 1; smp <= nsmp && smp <= MAX_SAMPLES; smp++) {\n\t\t\tuint32_t ssize;\n\n\t\t\tif (song->samples[smp].length == 0)\n\t\t\t\tcontinue;\n\t\t\tssize = csf_read_sample(song->samples + smp,\n\t\t\t\t(SF_LE | SF_PCMU | SF_M\n\t\t\t\t | ((song->samples[smp].flags & CHN_16BIT) ? SF_16 : SF_8)),\n\t\t\t\tfp->data + fp->pos, fp->length - fp->pos);\n\t\t\tslurp_seek(fp, ssize, SEEK_CUR);\n\t\t}\n\t}\n\n\t/* set the rest of the stuff */\n\tsong->flags = SONG_ITOLDEFFECTS | SONG_COMPATGXX;\n\n//      if (ferror(fp)) {\n//              return LOAD_FILE_ERROR;\n//      }\n\n\tif (todo & 64)\n\t\tlog_appendf(2, \" TODO: test this file with other players (beats per track != 64)\");\n\tif (todo & 16)\n\t\tlog_appendf(2, \" TODO: double check 16 bit sample loading\");\n\n\t/* done! */\n\treturn LOAD_SUCCESS;\n}\n\n"], "fixing_code": ["/*\n * Schism Tracker - a cross-platform Impulse Tracker clone\n * copyright (c) 2003-2005 Storlek <storlek@rigelseven.com>\n * copyright (c) 2005-2008 Mrs. Brisby <mrs.brisby@nimh.org>\n * copyright (c) 2009 Storlek & Mrs. Brisby\n * copyright (c) 2010-2012 Storlek\n * URL: http://schismtracker.org/\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#define NEED_BYTESWAP\n#include \"headers.h\"\n#include \"fmt.h\"\n#include \"song.h\"\n#include \"tables.h\"\n#include \"log.h\"\n\n#include <stdint.h>\n\n/* --------------------------------------------------------------------- */\n\n#pragma pack(push, 1)\ntypedef struct mtm_header {\n\tchar filever[4]; /* M T M \\x10 */\n\tchar title[20]; /* asciz */\n\tuint16_t ntracks;\n\tuint8_t last_pattern;\n\tuint8_t last_order; /* songlength - 1 */\n\tuint16_t msglen;\n\tuint8_t nsamples;\n\tuint8_t flags; /* always 0 */\n\tuint8_t rows; /* prob. 64 */\n\tuint8_t nchannels;\n\tuint8_t panpos[32];\n} mtm_header_t;\n\ntypedef struct mtm_sample {\n\tchar name[22];\n\tuint32_t length, loop_start, loop_end;\n\tuint8_t finetune, volume, flags;\n} mtm_sample_t;\n#pragma pack(pop)\n\n/* --------------------------------------------------------------------- */\n\nint fmt_mtm_read_info(dmoz_file_t *file, const uint8_t *data, size_t length)\n{\n\tif (!(length > 24 && memcmp(data, \"MTM\", 3) == 0))\n\t\treturn 0;\n\n\tfile->description = \"MultiTracker Module\";\n\t/*file->extension = str_dup(\"mtm\");*/\n\tfile->title = strn_dup((const char *)data + 4, 20);\n\tfile->type = TYPE_MODULE_MOD;\n\treturn 1;\n}\n\n/* --------------------------------------------------------------------------------------------------------- */\n\nstatic void mtm_unpack_track(const uint8_t *b, song_note_t *note, int rows)\n{\n\tint n;\n\n\tfor (n = 0; n < rows; n++, note++, b += 3) {\n\t\tnote->note = ((b[0] & 0xfc) ? ((b[0] >> 2) + 36 + 1) : NOTE_NONE);\n\t\tnote->instrument = ((b[0] & 0x3) << 4) | (b[1] >> 4);\n\t\tnote->voleffect = VOLFX_NONE;\n\t\tnote->volparam = 0;\n\t\tnote->effect = b[1] & 0xf;\n\t\tnote->param = b[2];\n\t\t/* From mikmod: volume slide up always overrides slide down */\n\t\tif (note->effect == 0xa && (note->param & 0xf0))\n\t\t\tnote->param &= 0xf0;\n\t\tcsf_import_mod_effect(note, 0);\n\t}\n}\n\nint fmt_mtm_load_song(song_t *song, slurp_t *fp, unsigned int lflags)\n{\n\tuint8_t b[192];\n\tuint8_t nchan, nord, npat, nsmp;\n\tuint16_t ntrk, comment_len;\n\tint n, pat, chan, smp, rows, todo = 0;\n\tsong_note_t *note;\n\tuint16_t tmp;\n\tuint32_t tmplong;\n\tsong_note_t **trackdata, *tracknote;\n\tsong_sample_t *sample;\n\n\tslurp_read(fp, b, 3);\n\tif (memcmp(b, \"MTM\", 3) != 0)\n\t\treturn LOAD_UNSUPPORTED;\n\tn = slurp_getc(fp);\n\tsprintf(song->tracker_id, \"MultiTracker %d.%d\", n >> 4, n & 0xf);\n\tslurp_read(fp, song->title, 20);\n\tsong->title[20] = 0;\n\tslurp_read(fp, &ntrk, 2);\n\tntrk = bswapLE16(ntrk);\n\tnpat = slurp_getc(fp);\n\tnord = slurp_getc(fp) + 1;\n\n\tslurp_read(fp, &comment_len, 2);\n\tcomment_len = bswapLE16(comment_len);\n\n\tnsmp = slurp_getc(fp);\n\tslurp_getc(fp); /* attribute byte (unused) */\n\trows = slurp_getc(fp); /* beats per track (translation: number of rows in every pattern) */\n\tif (rows != 64)\n\t\ttodo |= 64;\n\trows = MIN(rows, 64);\n\tnchan = slurp_getc(fp);\n\n\tif (slurp_eof(fp)) {\n\t\treturn LOAD_FORMAT_ERROR;\n\t}\n\n\tfor (n = 0; n < 32; n++) {\n\t\tint pan = slurp_getc(fp) & 0xf;\n\t\tpan = SHORT_PANNING(pan);\n\t\tpan *= 4; //mphack\n\t\tsong->channels[n].panning = pan;\n\t}\n\tfor (n = nchan; n < MAX_CHANNELS; n++)\n\t\tsong->channels[n].flags = CHN_MUTE;\n\n\t/* samples */\n\tif (nsmp > MAX_SAMPLES) {\n\t\tlog_appendf(4, \" Warning: Too many samples\");\n\t}\n\tfor (n = 1, sample = song->samples + 1; n <= nsmp; n++, sample++) {\n\t\tif (n > MAX_SAMPLES) {\n\t\t\tslurp_seek(fp, 37, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* IT truncates .mtm sample names at the first \\0 rather than the normal behavior\n\t\tof presenting them as spaces (k-achaet.mtm has some \"junk\" in the sample text) */\n\t\tchar name[23];\n\t\tslurp_read(fp, name, 22);\n\t\tname[22] = '\\0';\n\t\tstrcpy(sample->name, name);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->length = bswapLE32(tmplong);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->loop_start = bswapLE32(tmplong);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->loop_end = bswapLE32(tmplong);\n\t\tif ((sample->loop_end - sample->loop_start) > 2) {\n\t\t\tsample->flags |= CHN_LOOP;\n\t\t} else {\n\t\t\t/* Both Impulse Tracker and Modplug do this */\n\t\t\tsample->loop_start = 0;\n\t\t\tsample->loop_end = 0;\n\t\t}\n\t\tsong->samples[n].c5speed = MOD_FINETUNE(slurp_getc(fp));\n\t\tsample->volume = slurp_getc(fp);\n\t\tsample->volume *= 4; //mphack\n\t\tsample->global_volume = 64;\n\t\tif (slurp_getc(fp) & 1) {\n\t\t\ttodo |= 16;\n\t\t\tsample->flags |= CHN_16BIT;\n\t\t\tsample->length >>= 1;\n\t\t\tsample->loop_start >>= 1;\n\t\t\tsample->loop_end >>= 1;\n\t\t}\n\t\tsong->samples[n].vib_type = 0;\n\t\tsong->samples[n].vib_rate = 0;\n\t\tsong->samples[n].vib_depth = 0;\n\t\tsong->samples[n].vib_speed = 0;\n\t}\n\n\t/* orderlist */\n\tslurp_read(fp, song->orderlist, 128);\n\tmemset(song->orderlist + nord, ORDER_LAST, MAX_ORDERS - nord);\n\n\t/* tracks */\n\ttrackdata = mem_calloc(ntrk, sizeof(song_note_t *));\n\tfor (n = 0; n < ntrk; n++) {\n\t\tslurp_read(fp, b, 3 * rows);\n\t\ttrackdata[n] = mem_calloc(rows, sizeof(song_note_t));\n\t\tmtm_unpack_track(b, trackdata[n], rows);\n\t}\n\n\t/* patterns */\n\tif (npat >= MAX_PATTERNS) {\n\t\tlog_appendf(4, \" Warning: Too many patterns\");\n\t}\n\tfor (pat = 0; pat <= npat; pat++) {\n\t\t// skip ones that can't be loaded\n\t\tif (pat >= MAX_PATTERNS) {\n\t\t\tslurp_seek(fp, 64, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsong->patterns[pat] = csf_allocate_pattern(MAX(rows, 32));\n\t\tsong->pattern_size[pat] = song->pattern_alloc_size[pat] = 64;\n\t\tfor (chan = 0; chan < 32; chan++) {\n\t\t\tslurp_read(fp, &tmp, 2);\n\t\t\ttmp = bswapLE16(tmp);\n\t\t\tif (tmp == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (tmp > ntrk) {\n\t\t\t\tfor (n = 0; n < ntrk; n++)\n\t\t\t\t\tfree(trackdata[n]);\n\t\t\t\tfree(trackdata);\n\t\t\t\treturn LOAD_FORMAT_ERROR;\n\t\t\t}\n\t\t\tnote = song->patterns[pat] + chan;\n\t\t\ttracknote = trackdata[tmp - 1];\n\t\t\tfor (n = 0; n < rows; n++, tracknote++, note += MAX_CHANNELS)\n\t\t\t\t*note = *tracknote;\n\t\t}\n\t\tif (rows < 32) {\n\t\t\t/* stick a pattern break on the first channel with an empty effect column\n\t\t\t * (XXX don't do this if there's already one in another column) */\n\t\t\tnote = song->patterns[pat] + 64 * (rows - 1);\n\t\t\twhile (note->effect || note->param)\n\t\t\t\tnote++;\n\t\t\tnote->effect = FX_PATTERNBREAK;\n\t\t}\n\t}\n\n\t/* free willy */\n\tfor (n = 0; n < ntrk; n++)\n\t\tfree(trackdata[n]);\n\tfree(trackdata);\n\n\tread_lined_message(song->message, fp, comment_len, 40);\n\n\t/* sample data */\n\tif (!(lflags & LOAD_NOSAMPLES)) {\n\t\tfor (smp = 1; smp <= nsmp && smp <= MAX_SAMPLES; smp++) {\n\t\t\tuint32_t ssize;\n\n\t\t\tif (song->samples[smp].length == 0)\n\t\t\t\tcontinue;\n\t\t\tssize = csf_read_sample(song->samples + smp,\n\t\t\t\t(SF_LE | SF_PCMU | SF_M\n\t\t\t\t | ((song->samples[smp].flags & CHN_16BIT) ? SF_16 : SF_8)),\n\t\t\t\tfp->data + fp->pos, fp->length - fp->pos);\n\t\t\tslurp_seek(fp, ssize, SEEK_CUR);\n\t\t}\n\t}\n\n\t/* set the rest of the stuff */\n\tsong->flags = SONG_ITOLDEFFECTS | SONG_COMPATGXX;\n\n//      if (ferror(fp)) {\n//              return LOAD_FILE_ERROR;\n//      }\n\n\tif (todo & 64)\n\t\tlog_appendf(2, \" TODO: test this file with other players (beats per track != 64)\");\n\tif (todo & 16)\n\t\tlog_appendf(2, \" TODO: double check 16 bit sample loading\");\n\n\t/* done! */\n\treturn LOAD_SUCCESS;\n}\n\n"], "filenames": ["fmt/mtm.c"], "buggy_code_start_loc": [210], "buggy_code_end_loc": [211], "fixing_code_start_loc": [209], "fixing_code_end_loc": [209], "type": "CWE-787", "message": "An issue in Schism Tracker v20200412 fixed in v.20200412 allows attacker to obtain sensitive information via the fmt_mtm_load_song function in fmt/mtm.c.", "other": {"cve": {"id": "CVE-2021-32419", "sourceIdentifier": "cve@mitre.org", "published": "2023-02-17T18:15:10.970", "lastModified": "2023-02-28T17:54:11.933", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue in Schism Tracker v20200412 fixed in v.20200412 allows attacker to obtain sensitive information via the fmt_mtm_load_song function in fmt/mtm.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:schismtracker:schism_tracker:*:*:*:*:*:*:*:*", "versionEndExcluding": "20200412", "matchCriteriaId": "309C3449-711F-4153-8E11-79325A5B4894"}]}]}], "references": [{"url": "https://github.com/schismtracker/schismtracker/commit/1e2cc389a2a058fd13d99460c11115a6f7f7a6a4", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/schismtracker/schismtracker/issues/249", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/schismtracker/schismtracker/commit/1e2cc389a2a058fd13d99460c11115a6f7f7a6a4"}}