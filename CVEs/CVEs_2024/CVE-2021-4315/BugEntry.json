{"buggy_code": ["# -*- coding: utf-8 -*-\n\"\"\" This module provides the backend Flask server used by psiTurk. \"\"\"\nfrom __future__ import generator_stop\nimport os\nimport sys\nimport datetime\nimport logging\nfrom random import choice\nimport user_agents\nimport requests\nimport re\nimport json\nfrom jinja2 import TemplateNotFound\nfrom collections import Counter\n\n\n# Setup flask\nfrom flask import Flask, render_template, render_template_string, request, \\\n    jsonify, send_from_directory\n\n# Setup database\n\nfrom .db import db_session, init_db\nfrom .models import Participant\nfrom sqlalchemy import or_, exc\n\nfrom .psiturk_statuses import *\nfrom .psiturk_config import PsiturkConfig\nfrom .experiment_errors import ExperimentError, ExperimentApiError\nfrom .user_utils import nocache\n\n# Setup config\nCONFIG = PsiturkConfig()\nCONFIG.load_config()\n\nLOG_LEVELS = [logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\nlogging.CRITICAL]\nLOG_LEVEL = LOG_LEVELS[CONFIG.getint('Server Parameters', 'loglevel')]\n\nlogfile = CONFIG.get(\"Server Parameters\", \"errorlog\")\nif logfile != '-':\n    file_path = os.path.join(os.getcwd(), logfile)\n    logging.basicConfig(filename=file_path, format='%(asctime)s %(message)s',\n                        level=LOG_LEVEL)\n\n# Let's start\n# ===========\n\napp = Flask(\"Experiment_Server\")\napp.logger.setLevel(LOG_LEVEL)\n\n# Set cache timeout to 10 seconds for static files\napp.config.update(SEND_FILE_MAX_AGE_DEFAULT=10)\napp.secret_key = CONFIG.get('Server Parameters', 'secret_key')\n\n\ndef check_templates_exist():\n    # this checks for templates that are required if you are hosting your own ad.\n    try:\n        try_these = ['thanks-mturksubmit.html', 'closepopup.html']\n        [app.jinja_env.get_template(try_this) for try_this in try_these]\n    except TemplateNotFound as e:\n        raise RuntimeError((\n            f\"Missing one of the following templates: {', '.join(try_these)}.\"\n            f\"Copy these over from a freshly-created psiturk example experiment.\"\n            f\"{type(e).__name__, str(e)}\"\n        ))\n\n\ncheck_templates_exist()\n\n\n# Serving warm, fresh, & sweet custom, user-provided routes\n# ==========================================================\n\ntry:\n    sys.path.append(os.getcwd())\n    from custom import custom_code\nexcept ModuleNotFoundError as e:\n    app.logger.info(\"Hmm... it seems no custom code (custom.py) associated \\\n                    with this project.\")\nexcept ImportError as e:\n    app.logger.error(\"There is custom code (custom.py) associated with this \\\n                      project but it doesn't import cleanly.  Raising exception,\")\n    raise\nelse:\n    app.register_blueprint(custom_code)\n    try:\n        # noinspection PyUnresolvedReferences\n        from custom import init_app as custom_init_app\n    except ImportError as e:\n        pass\n    else:\n        custom_init_app(app)\n\n# scheduler\n\nfrom apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore\nfrom pytz import utc\n\nfrom .db import engine\njobstores = {\n    'default': SQLAlchemyJobStore(engine=engine)\n}\nif 'gunicorn' in os.environ.get('SERVER_SOFTWARE', ''):\n    from apscheduler.schedulers.gevent import GeventScheduler as Scheduler\nelse:\n    from apscheduler.schedulers.background import BackgroundScheduler as Scheduler\nlogging.getLogger('apscheduler').setLevel(logging.DEBUG)\nscheduler = Scheduler(jobstores=jobstores, timezone=utc)\napp.apscheduler = scheduler\nscheduler.app = app\n\nif CONFIG.getboolean('Server Parameters', 'do_scheduler'):\n    app.logger.info(\"Scheduler starting!\")\n    scheduler.start()\nelse:\n    app.logger.info(\"Starting scheduler in 'paused' mode -- it will not run any tasks, but it can be used to create, modify, or delete tasks.\")\n    scheduler.start(paused=True)\n\n\n#\n# Dashboard\n#\nif CONFIG.getboolean('Server Parameters', 'enable_dashboard'):\n    from .dashboard import dashboard, init_app as dashboard_init_app # management dashboard\n    app.register_blueprint(dashboard)\n    dashboard_init_app(app)\n\n    from .api import api_blueprint\n    app.register_blueprint(api_blueprint)\n\ninit_db()\n\n# Read psiturk.js file into memory\nPSITURK_JS_FILE = os.path.join(os.path.dirname(__file__),\n                               \"psiturk_js/psiturk.js\")\napp.logger.info(PSITURK_JS_FILE)\n\nif os.path.exists(PSITURK_JS_FILE):\n    PSITURK_JS_CODE = open(PSITURK_JS_FILE).read()\nelse:\n    PSITURK_JS_CODE = \"alert('psiturk.js file not found!');\"\n\n\n@app.errorhandler(ExperimentError)\ndef handle_exp_error(exception):\n    \"\"\"Handle errors by sending an error page.\"\"\"\n    app.logger.error(\n        \"%s (%s) %s\", exception.value, exception.errornum, str(dict(request.args)))\n    return exception.error_page(request, CONFIG.get('Task Parameters',\n                                                    'contact_email_on_error'))\n\n\n@app.errorhandler(ExperimentApiError)\ndef handle_experiment_api_error(error):\n    # for use with API errors\n    response = jsonify(error.to_dict())\n    response.status_code = error.status_code\n    app.logger.error(error.message)\n    return response\n\n\n@app.teardown_request\ndef shutdown_session(_=None):\n    \"\"\" Shut down session route \"\"\"\n    db_session.remove()\n\n\n# Experiment counterbalancing code\n# ================================\n\ndef get_random_condcount(mode):\n    \"\"\"\n    HITs can be in one of three states:\n        - jobs that are finished\n        - jobs that are started but not finished\n        - jobs that are never going to finish (user decided not to do it)\n    Our count should be based on the first two, so we count any tasks finished\n    or any tasks not finished that were started in the last cutoff_time\n    minutes, as specified in the cutoff_time variable in the config file.\n\n    Returns a tuple: (cond, condition)\n    \"\"\"\n    cutofftime = datetime.timedelta(minutes=-CONFIG.getint('Task Parameters',\n                                                           'cutoff_time'))\n    starttime = datetime.datetime.now(datetime.timezone.utc) + cutofftime\n\n    try:\n        conditions = json.load(\n            open(os.path.join(app.root_path, 'conditions.json')))\n        numconds = len(list(conditions.keys()))\n        numcounts = 1\n    except IOError:\n        numconds = CONFIG.getint('Task Parameters', 'num_conds')\n        numcounts = CONFIG.getint('Task Parameters', 'num_counters')\n\n    participants = Participant.query.\\\n        filter(Participant.codeversion ==\n               CONFIG.get('Task Parameters', 'experiment_code_version')).\\\n        filter(Participant.mode == mode).\\\n        filter(or_(Participant.status == COMPLETED,\n                   Participant.status == CREDITED,\n                   Participant.status == SUBMITTED,\n                   Participant.status == BONUSED,\n                   Participant.beginhit > starttime)).all()\n    counts = Counter()\n    for cond in range(numconds):\n        for counter in range(numcounts):\n            counts[(cond, counter)] = 0\n    for participant in participants:\n        condcount = (participant.cond, participant.counterbalance)\n        if condcount in counts:\n            counts[condcount] += 1\n    mincount = min(counts.values())\n    minima = [hsh for hsh, count in counts.items() if count == mincount]\n    chosen = choice(minima)\n    app.logger.info(\"given %(a)s chose %(b)s\" % {'a': counts, 'b': chosen})\n\n    return chosen\n\n\ntry:\n    from custom import custom_get_condition as get_condition\nexcept (ModuleNotFoundError, ImportError):\n    get_condition = get_random_condcount\n\n# Routes\n# ======\n\n\n@app.route('/')\n@nocache\ndef index():\n    \"\"\" Index route \"\"\"\n    return render_template('default.html')\n\n\n@app.route('/favicon.ico')\ndef favicon():\n    \"\"\" Serve favicon \"\"\"\n    return app.send_static_file('favicon.ico')\n\n\n@app.route('/static/js/psiturk.js')\ndef psiturk_js():\n    \"\"\" psiTurk js route \"\"\"\n    return render_template_string(PSITURK_JS_CODE)\n\n\n@app.route('/check_worker_status', methods=['GET'])\ndef check_worker_status():\n    \"\"\" Check worker status route \"\"\"\n    if 'workerId' not in request.args:\n        resp = {\"status\": \"bad request\"}\n        return jsonify(**resp)\n    else:\n        worker_id = request.args['workerId']\n        assignment_id = request.args['assignmentId']\n        allow_repeats = CONFIG.getboolean('Task Parameters', 'allow_repeats')\n        if allow_repeats:  # if you allow repeats focus on current worker/assignment combo\n            try:\n                part = Participant.query.\\\n                    filter(Participant.workerid == worker_id).\\\n                    filter(Participant.assignmentid == assignment_id).one()\n                status = part.status\n            except exc.SQLAlchemyError:\n                status = NOT_ACCEPTED\n        else:  # if you disallow repeats search for highest status of anything by this worker\n            try:\n                matches = Participant.query.\\\n                    filter(Participant.workerid == worker_id).all()\n                numrecs = len(matches)\n                if numrecs == 0:  # this should be caught by exception, but just to be safe\n                    status = NOT_ACCEPTED\n                else:\n                    status = max([record.status for record in matches])\n            except exc.SQLAlchemyError:\n                status = NOT_ACCEPTED\n        resp = {\"status\": status}\n        return jsonify(**resp)\n\n\n@app.route('/ad', methods=['GET'])\n@app.route('/pub', methods=['GET'])\n@nocache\ndef advertisement():\n    \"\"\"\n    This is the url we give for the ad for our 'external question'.  The ad has\n    to display two different things: This page will be called from within\n    mechanical turk, with url arguments hitId, assignmentId, and workerId.\n    If the worker has not yet accepted the hit:\n        These arguments will have null values, we should just show an ad for\n        the experiment.\n    If the worker has accepted the hit:\n        These arguments will have appropriate values and we should enter the\n        person in the database and provide a link to the experiment popup.\n    \"\"\"\n    user_agent_string = request.user_agent.string\n    user_agent_obj = user_agents.parse(user_agent_string)\n    browser_ok = True\n    browser_exclude_rule = CONFIG.get('Task Parameters', 'browser_exclude_rule')\n    for rule in browser_exclude_rule.split(','):\n        myrule = rule.strip()\n        if myrule in [\"mobile\", \"tablet\", \"touchcapable\", \"pc\", \"bot\"]:\n            if (myrule == \"mobile\" and user_agent_obj.is_mobile) or\\\n               (myrule == \"tablet\" and user_agent_obj.is_tablet) or\\\n               (myrule == \"touchcapable\" and user_agent_obj.is_touch_capable) or\\\n               (myrule == \"pc\" and user_agent_obj.is_pc) or\\\n               (myrule == \"bot\" and user_agent_obj.is_bot):\n                browser_ok = False\n        elif myrule == \"Safari\" or myrule == \"safari\":\n            if \"Chrome\" in user_agent_string and \"Safari\" in user_agent_string:\n                pass\n            elif \"Safari\" in user_agent_string:\n                browser_ok = False\n        elif myrule in user_agent_string:\n            browser_ok = False\n\n    if not browser_ok:\n        # Handler for IE users if IE is not supported.\n        raise ExperimentError('browser_type_not_allowed')\n\n    if not ('hitId' in request.args and 'assignmentId' in request.args):\n        raise ExperimentError('hit_assign_worker_id_not_set_in_mturk')\n    hit_id = request.args['hitId']\n    assignment_id = request.args['assignmentId']\n    mode = request.args['mode']\n    if hit_id[:5] == \"debug\":\n        debug_mode = True\n    else:\n        debug_mode = False\n    already_in_db = False\n    if 'workerId' in request.args:\n        worker_id = request.args['workerId']\n        # First check if this workerId has completed the task before (v1).\n        nrecords = Participant.query.\\\n            filter(Participant.assignmentid != assignment_id).\\\n            filter(Participant.workerid == worker_id).\\\n            count()\n\n        if nrecords > 0:  # Already completed task\n            already_in_db = True\n    else:  # If worker has not accepted the hit\n        worker_id = None\n    try:\n        part = Participant.query.\\\n            filter(Participant.hitid == hit_id).\\\n            filter(Participant.assignmentid == assignment_id).\\\n            filter(Participant.workerid == worker_id).\\\n            one()\n        status = part.status\n    except exc.SQLAlchemyError:\n        status = None\n\n    allow_repeats = CONFIG.getboolean('Task Parameters', 'allow_repeats')\n    if (status == STARTED or status == QUITEARLY) and not debug_mode:\n        # Once participants have finished the instructions, we do not allow\n        # them to start the task again.\n        raise ExperimentError('already_started_exp_mturk')\n    elif status == COMPLETED or (status == SUBMITTED and not already_in_db):\n        # 'or status == SUBMITTED' because we suspect that sometimes the post\n        # to mturk fails after we've set status to SUBMITTED, so really they\n        # have not successfully submitted. This gives another chance for the\n        # submit to work.\n\n        # They've finished the experiment but haven't successfully submitted the HIT\n        # yet.\n        return render_template(\n            'thanks-mturksubmit.html',\n            using_sandbox=(mode == \"sandbox\"),\n            hitid=hit_id,\n            assignmentid=assignment_id,\n            workerid=worker_id\n        )\n    elif already_in_db and not (debug_mode or allow_repeats):\n        raise ExperimentError('already_did_exp_hit')\n    elif status == ALLOCATED or not status or debug_mode:\n        # Participant has not yet agreed to the consent. They might not\n        # even have accepted the HIT.\n        with open('templates/ad.html', 'r') as temp_file:\n            ad_string = temp_file.read()\n        ad_string = insert_mode(ad_string, mode)\n        return render_template_string(\n            ad_string,\n            hitid=hit_id,\n            assignmentid=assignment_id,\n            workerid=worker_id\n        )\n    else:\n        raise ExperimentError('status_incorrectly_set')\n\n\n@app.route('/consent', methods=['GET'])\n@nocache\ndef give_consent():\n    \"\"\"\n    Serves up the consent in the popup window.\n    \"\"\"\n    if not ('hitId' in request.args and 'assignmentId' in request.args and\n            'workerId' in request.args):\n        raise ExperimentError('hit_assign_worker_id_not_set_in_consent')\n    hit_id = request.args['hitId']\n    assignment_id = request.args['assignmentId']\n    worker_id = request.args['workerId']\n    mode = request.args['mode']\n    with open('templates/consent.html', 'r') as temp_file:\n        consent_string = temp_file.read()\n    consent_string = insert_mode(consent_string, mode)\n    return render_template_string(\n        consent_string,\n        hitid=hit_id,\n        assignmentid=assignment_id,\n        workerid=worker_id\n    )\n\n\n@app.route('/exp', methods=['GET'])\n@nocache\ndef start_exp():\n    \"\"\" Serves up the experiment applet. \"\"\"\n    if not (('hitId' in request.args) and ('assignmentId' in request.args) and\n            ('workerId' in request.args) and ('mode' in request.args)):\n        raise ExperimentError('hit_assign_worker_id_not_set_in_exp')\n    hit_id = request.args['hitId']\n    assignment_id = request.args['assignmentId']\n    worker_id = request.args['workerId']\n    mode = request.args['mode']\n    app.logger.info(\"Accessing /exp: %(h)s %(a)s %(w)s \" % {\n        \"h\": hit_id,\n        \"a\": assignment_id,\n        \"w\": worker_id\n    })\n    if hit_id[:5] == \"debug\":\n        debug_mode = True\n    else:\n        debug_mode = False\n\n    # Check first to see if this hitId or assignmentId exists.  If so, check to\n    # see if inExp is set\n    allow_repeats = CONFIG.getboolean('Task Parameters', 'allow_repeats')\n    if allow_repeats:\n        matches = Participant.query.\\\n            filter(Participant.workerid == worker_id).\\\n            filter(Participant.assignmentid == assignment_id).\\\n            all()\n    else:\n        matches = Participant.query.\\\n            filter(Participant.workerid == worker_id).\\\n            all()\n\n    numrecs = len(matches)\n    if numrecs == 0:\n        # Choose condition and counterbalance\n        subj_cond, subj_counter = get_condition(mode)\n\n        worker_ip = \"UNKNOWN\" if not request.remote_addr else \\\n            request.remote_addr\n        browser = \"UNKNOWN\" if not request.user_agent.browser else \\\n            request.user_agent.browser\n        platform = \"UNKNOWN\" if not request.user_agent.platform else \\\n            request.user_agent.platform\n        language = \"UNKNOWN\" if not request.accept_languages else \\\n            request.accept_languages.best\n\n        # Set condition here and insert into database.\n        participant_attributes = dict(\n            assignmentid=assignment_id,\n            workerid=worker_id,\n            hitid=hit_id,\n            cond=subj_cond,\n            counterbalance=subj_counter,\n            ipaddress=worker_ip,\n            browser=browser,\n            platform=platform,\n            language=language,\n            mode=mode\n        )\n        part = Participant(**participant_attributes)\n        db_session.add(part)\n        db_session.commit()\n\n    else:\n        # A couple possible problems here:\n        # 1: They've already done an assignment, then we should tell them they\n        #    can't do another one\n        # 2: They've already worked on this assignment, and got too far to\n        #    start over.\n        # 3: They're in the database twice for the same assignment, that should\n        #    never happen.\n        # 4: They're returning and all is well.\n        nrecords = 0\n        for record in matches:\n            other_assignment = False\n            if record.assignmentid != assignment_id:\n                other_assignment = True\n            else:\n                nrecords += 1\n        if nrecords <= 1 and not other_assignment:\n            part = matches[0]\n            # In experiment (or later) can't restart at this point\n            if part.status >= STARTED and not debug_mode:\n                raise ExperimentError('already_started_exp')\n        else:\n            if nrecords > 1:\n                app.logger.error(\"Error, hit/assignment appears in database \\\n                                 more than once (serious problem)\")\n                raise ExperimentError(\n                    'hit_assign_appears_in_database_more_than_once'\n                )\n            if other_assignment:\n                raise ExperimentError('already_did_exp_hit')\n\n    ad_server_location = '/complete'\n\n    return render_template(\n        'exp.html', uniqueId=part.uniqueid,\n        condition=part.cond,\n        counterbalance=part.counterbalance,\n        adServerLoc=ad_server_location,\n        mode=mode,\n        contact_address=CONFIG.get(\n            'Task Parameters', 'contact_email_on_error'),\n        codeversion=CONFIG.get(\n            'Task Parameters', 'experiment_code_version')\n    )\n\n\n@app.route('/inexp', methods=['POST'])\ndef enterexp():\n    \"\"\"\n    AJAX listener that listens for a signal from the user's script when they\n    leave the instructions and enter the real experiment. After the server\n    receives this signal, it will no longer allow them to re-access the\n    experiment applet (meaning they can't do part of the experiment and\n    referesh to start over).\n    \"\"\"\n    app.logger.info(\"Accessing /inexp\")\n    if 'uniqueId' not in request.form:\n        raise ExperimentError('improper_inputs')\n    unique_id = request.form['uniqueId']\n\n    try:\n        user = Participant.query.\\\n            filter(Participant.uniqueid == unique_id).one()\n        user.status = STARTED\n        user.beginexp = datetime.datetime.now(datetime.timezone.utc)\n        db_session.add(user)\n        db_session.commit()\n        resp = {\"status\": \"success\"}\n    except exc.SQLAlchemyError:\n        app.logger.error(\"DB error: Unique user not found.\")\n        resp = {\"status\": \"error, uniqueId not found\"}\n    return jsonify(**resp)\n\n# TODD SAYS: This the only route in the whole thing that uses <id> like this\n# where everything else uses POST!  This could be confusing but is forced\n# somewhat by Backbone?  Take heed!\n@app.route('/sync/<uid>', methods=['GET'])\ndef load(uid=None):\n    \"\"\"\n    Load experiment data, which should be a JSON object and will be stored\n    after converting to string.\n    \"\"\"\n    app.logger.info(\"GET /sync route with id: %s\" % uid)\n\n    try:\n        user = Participant.query.\\\n            filter(Participant.uniqueid == uid).\\\n            one()\n    except exc.SQLAlchemyError:\n        app.logger.error(\"DB error: Unique user not found.\")\n    else:\n        try:\n            resp = json.loads(user.datastring)\n        except (ValueError, TypeError, json.JSONDecodeError):\n            resp = {\n                \"condition\": user.cond,\n                \"counterbalance\": user.counterbalance,\n                \"assignmentId\": user.assignmentid,\n                \"workerId\": user.workerid,\n                \"hitId\": user.hitid,\n                \"bonus\": user.bonus\n            }\n        return jsonify(**resp)\n\n\n@app.route('/sync/<uid>', methods=['PUT'])\ndef update(uid=None):\n    \"\"\"\n    Save experiment data, which should be a JSON object and will be stored\n    after converting to string.\n    \"\"\"\n    app.logger.info(\"PUT /sync route with id: %s\" % uid)\n\n    try:\n        user = Participant.query.\\\n            filter(Participant.uniqueid == uid).\\\n            one()\n    except exc.SQLAlchemyError:\n        raise ExperimentApiError(\"DB error: Unique user not found.\")\n\n    user.datastring = json.dumps(request.json)\n    db_session.add(user)\n    db_session.commit()\n\n    try:\n        data = json.loads(user.datastring)\n    except Exception as e:\n        raise ExperimentApiError('failed to load json datastring back from database as object! Error was {}: {}'.format(type(e), str(e)))\n\n    trial = data.get(\"currenttrial\", None)\n    app.logger.info(\"saved data for %s (current trial: %s)\", uid, trial)\n    resp = {\"status\": \"user data saved\"}\n    return jsonify(**resp)\n\n\n@app.route('/quitter', methods=['POST'])\ndef quitter():\n    \"\"\"\n    Mark quitter as such.\n    \"\"\"\n    unique_id = request.form['uniqueId']\n    if unique_id[:5] == \"debug\":\n        debug_mode = True\n    else:\n        debug_mode = False\n\n    if debug_mode:\n        resp = {\"status\": \"didn't mark as quitter since this is debugging\"}\n        return jsonify(**resp)\n    else:\n        try:\n            unique_id = request.form['uniqueId']\n            app.logger.info(\"Marking quitter %s\" % unique_id)\n            user = Participant.query.\\\n                filter(Participant.uniqueid == unique_id).\\\n                one()\n            user.status = QUITEARLY\n            db_session.add(user)\n            db_session.commit()\n        except exc.SQLAlchemyError:\n            raise ExperimentError('tried_to_quit')\n        else:\n            resp = {\"status\": \"marked as quitter\"}\n            return jsonify(**resp)\n\n# Note: This route should only used when debugging\n# or when not using the psiturk adserver\n@app.route('/complete', methods=['GET'])\n@nocache\ndef debug_complete():\n    \"\"\" Debugging route for complete. \"\"\"\n    if 'uniqueId' not in request.args:\n        raise ExperimentError('improper_inputs')\n    else:\n        unique_id = request.args['uniqueId']\n        mode = request.args['mode']\n        try:\n            user = Participant.query.\\\n                filter(Participant.uniqueid == unique_id).one()\n            user.status = COMPLETED\n            user.endhit = datetime.datetime.now(datetime.timezone.utc)\n            db_session.add(user)\n            db_session.commit()\n        except exc.SQLAlchemyError:\n            raise ExperimentError('error_setting_worker_complete')\n        else:\n            # send them back to mturk.\n            if mode == 'sandbox' or mode == 'live':\n                return render_template('closepopup.html')\n            else:\n                allow_repeats = CONFIG.getboolean('Task Parameters', 'allow_repeats')\n                return render_template('complete.html',\n                                       allow_repeats=allow_repeats,\n                                       worker_id=user.workerid)\n\n\n@app.route('/worker_complete', methods=['GET'])\ndef worker_complete():\n    \"\"\" Complete worker. \"\"\"\n    if 'uniqueId' not in request.args:\n        resp = {\"status\": \"bad request\"}\n        return jsonify(**resp)\n    else:\n        unique_id = request.args['uniqueId']\n        app.logger.info(\"Completed experiment %s\" % unique_id)\n        try:\n            user = Participant.query.\\\n                filter(Participant.uniqueid == unique_id).one()\n            user.status = COMPLETED\n            user.endhit = datetime.datetime.now(datetime.timezone.utc)\n            db_session.add(user)\n            db_session.commit()\n            status = \"success\"\n        except exc.SQLAlchemyError:\n            status = \"database error\"\n        resp = {\"status\": status}\n        return jsonify(**resp)\n\n\n@app.route('/worker_submitted', methods=['GET'])\ndef worker_submitted():\n    \"\"\" Submit worker \"\"\"\n    if 'uniqueId' not in request.args:\n        resp = {\"status\": \"bad request\"}\n        return jsonify(**resp)\n    else:\n        unique_id = request.args['uniqueId']\n        app.logger.info(\"Submitted experiment for %s\" % unique_id)\n        try:\n            user = Participant.query.\\\n                filter(Participant.uniqueid == unique_id).one()\n            user.status = SUBMITTED\n            db_session.add(user)\n            db_session.commit()\n            status = \"success\"\n        except exc.SQLAlchemyError:\n            status = \"database error\"\n        resp = {\"status\": status}\n        return jsonify(**resp)\n\n# Is this a security risk?\n@app.route(\"/ppid\")\ndef ppid():\n    \"\"\" Get ppid \"\"\"\n    proc_id = os.getppid()\n    return str(proc_id)\n\n# Insert \"mode\" into pages so it's carried from page to page done server-side\n# to avoid breaking backwards compatibility with old templates.\n\n\ndef insert_mode(page_html, mode):\n    \"\"\" Insert mode \"\"\"\n    page_html = page_html\n    match_found = False\n    matches = re.finditer('workerId={{ workerid }}', page_html)\n    match = None\n    for match in matches:\n        match_found = True\n    if match_found:\n        new_html = page_html[:match.end()] + \"&mode=\" + mode +\\\n            page_html[match.end():]\n        return new_html\n    else:\n        raise ExperimentError(\"insert_mode_failed\")\n\n\n# Generic route\n# =============\n\n@app.route('/<path:path>')\ndef regularpage(path):\n    \"\"\"\n    Route not found by the other routes above. May point to a static template.\n    \"\"\"\n    return send_from_directory('templates', path)\n\n\ndef run_webserver():\n    \"\"\" Run web server \"\"\"\n    host = CONFIG.get('Server Parameters', 'host')\n    port = CONFIG.getint('Server Parameters', 'port')\n    print(f\"Serving on http://{host}:{port}\")\n    app.config['TEMPLATES_AUTO_RELOAD'] = True\n    app.jinja_env.auto_reload = True\n    app.run(debug=True, host=host, port=port)\n\n\nif __name__ == '__main__':\n    run_webserver()\n", "# -*- coding: utf-8 -*-\n\"\"\" This module tests the psiTurk suite.  \"\"\"\n\nfrom builtins import str\nfrom builtins import object\nimport os\nimport unittest\nimport psiturk\nimport json\nfrom faker import Faker\nimport pytest\nfrom importlib import reload  # Python 3.4+\n\nfake = Faker()  # Fake data generator\n\n\nclass FlaskTestClientProxy(object):\n    \"\"\"Spoof user agent (Chrome)\"\"\"\n\n    def __init__(self, app):\n        self.app = app\n\n    def __call__(self, environ, start_response):\n        environ['REMOTE_ADDR'] = environ.get('REMOTE_ADDR', fake.ipv4())\n        environ['HTTP_USER_AGENT'] = 'Mozilla/5.0 (Macintosh; Intel Mac OS X\\\n            10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1944.0\\\n            Safari/537.36'\n        return self.app(environ, start_response)\n\n\nclass BadFlaskTestClientProxy(object):\n    \"\"\"Spoof user agent (iPad)\"\"\"\n\n    def __init__(self, app):\n        self.app = app\n\n    def __call__(self, environ, start_response):\n        environ['REMOTE_ADDR'] = environ.get('REMOTE_ADDR', fake.ipv4())\n        environ['HTTP_USER_AGENT'] = 'Mozilla/5.0 (iPad; U; CPU OS 3_2 like \\\n            Mac OS X; en-us) AppleWebKit/531.21.10 (KHTML, like Gecko) \\\n            Version/4.0.4 Mobile/7B334b Safari/531.21.10'\n        return self.app(environ, start_response)\n\n\nclass PsiturkUnitTest(unittest.TestCase):\n\n    def setUp(self, case=None):\n        \"\"\"Build up fixtures\"\"\"\n        import psiturk.experiment\n        reload(psiturk.experiment)\n\n        psiturk.experiment.app.wsgi_app = FlaskTestClientProxy(\n            psiturk.experiment.app.wsgi_app)\n        self.app = psiturk.experiment.app.test_client()\n        self.config = psiturk.experiment.CONFIG\n\n        # Fake MTurk data\n        self.worker_id = fake.md5(raw_output=False)\n        self.hit_id = fake.md5(raw_output=False)\n        self.assignment_id = fake.md5(raw_output=False)\n\n    def tearDown(self):\n        \"\"\"Tear down fixtures\"\"\"\n        self.app = None\n\n    def set_config(self, section, field, value):\n        self.config.parent.set(self.config, section, field, str(value))\n\n\n@pytest.fixture()\ndef remove_file(tmpdir):\n    def do_it(filename):\n        import shutil\n        shutil.move(filename, './{}.xyz'.format(filename))\n\n    return do_it\n\n\n@pytest.fixture()\ndef remove_template(remove_file):\n    def do_it(template_name):\n        remove_file('templates/{}'.format(template_name))\n\n    return do_it\n\n\n@pytest.fixture()\ndef psiturk_test_client():\n    def do_it():\n        import psiturk.experiment\n        reload(psiturk.experiment)\n        psiturk.experiment.app.wsgi_app = FlaskTestClientProxy(\n            psiturk.experiment.app.wsgi_app)\n        return psiturk.experiment.app\n\n    yield do_it\n\n\ndef test_custom_get_condition_can_import(mocker, psiturk_test_client):\n    # pytest.set_trace()\n    # import psiturk.experiment\n    import sys\n    sys.path.append(os.getcwd())\n    import custom\n    reload(custom)\n    mocker.patch.object(custom, 'custom_get_condition', lambda mode: (9, 9), create=True)\n    app = psiturk_test_client()\n\n    from psiturk.experiment import get_condition\n    assert get_condition('') == (9, 9)\n\n\ndef test_custom_get_condition_not_necessary(tmpdir, mocker, psiturk_test_client):\n    import sys\n    sys.path.append(os.getcwd())\n    import custom\n    reload(custom)\n    app = psiturk_test_client()\n\n    from psiturk.experiment import get_condition\n    assert get_condition('') == (0, 0)\n\n\ndef test_missing_template_exception(edit_config_file, remove_template, psiturk_test_client):\n    remove_template('closepopup.html')\n    with pytest.raises(RuntimeError):\n        app = psiturk_test_client()\n\n\ndef test_notmissing_template(edit_config_file, remove_template, psiturk_test_client):\n    psiturk_test_client()\n\n\ndef test_does_not_die_if_no_custompy(remove_file, psiturk_test_client):\n    remove_file('custom.py')\n    psiturk_test_client()\n\n\ndef test_insert_mode(psiturk_test_client):\n    with open('templates/ad.html', 'r') as temp_file:\n        ad_string = temp_file.read()\n\n    from psiturk.experiment import insert_mode\n    insert_mode(ad_string, 'debug')\n\n\nclass PsiTurkStandardTests(PsiturkUnitTest):\n\n    # Test experiment.py\n    # ==================\n\n    def test_default_page(self):\n        \"\"\"Test that root page works.\"\"\"\n        rv = self.app.get('/')\n        response = rv.get_data(as_text=True)\n        # print(os.getcwd())\n        # with open('server.log','r') as infile:\n        # print(file.read())\n        assert ('Welcome to psiTurk!' in response)\n\n    def test_exp_debug_no_url_vars(self):\n        \"\"\"Test that exp page throws Error #1003 with no url vars.\"\"\"\n        rv = self.app.get('/exp')\n        assert u'<b>Error</b>: 1003' in rv.get_data(as_text=True)\n\n    def test_ad_no_url_vars(self):\n        \"\"\"Test that ad page throws Error #1001 with no url vars.\"\"\"\n        rv = self.app.get('/ad')\n        assert u'<b>Error</b>: 1001' in rv.get_data(as_text=True)\n\n    def test_ad_with_all_urls(self):\n        \"\"\"Test that ad page throws Error #1003 with no url vars.\"\"\"\n        args = '&'.join([\n            'assignmentId=debug%s' % self.assignment_id,\n            'workerId=debug%s' % self.worker_id,\n            'hitId=debug%s' % self.hit_id,\n            'mode=sandbox'])\n        rv = self.app.get('/ad?%s' % args)\n        assert 'Thank you for accepting this HIT!' in rv.get_data(as_text=True)\n\n    @pytest.mark.skip('psiturk api server is slow for this test')\n    def test_exp_with_all_url_vars_not_registered_on_ad_server(self):\n        \"\"\"Test that exp page throws Error #1018 with all url vars but not registered.\"\"\"\n        self.set_config('Shell Parameters', 'use_psiturk_ad_server', 'true')\n        args = '&'.join([\n            'assignmentId=debug%s' % self.assignment_id,\n            'workerId=debug%s' % self.worker_id,\n            'hitId=debug%s' % self.hit_id,\n            'mode=sandbox'])\n        rv = self.app.get('/exp?%s' % args)\n        assert '<b>Error</b>: 1018' in rv.get_data(as_text=True)\n\n    def test_sync_put(self):\n        request = \"&\".join([\n            \"assignmentId=debug%s\" % self.assignment_id,\n            \"workerId=debug%s\" % self.worker_id,\n            \"hitId=debug%s\" % self.hit_id,\n            \"mode=debug\"])\n\n        # put the user in the database\n        rv = self.app.get(\"/exp?%s\" % request)\n\n        # try putting the sync, simulating a Backbone PUT payload\n        uniqueid = \"debug%s:debug%s\" % (self.worker_id, self.assignment_id)\n        payload = {\n            \"condition\": 5,\n            \"counterbalance\": 0,\n            \"assignmentId\": self.assignment_id,\n            \"workerId\": self.worker_id,\n            \"hitId\": self.hit_id,\n            \"currenttrial\": 2,\n            \"bonus\": 0,\n            \"data\": [\n                {\n                    \"uniqueid\": uniqueid,\n                    \"current_trial\": 0,\n                    \"dateTime\": 1564425799481,\n                    \"trialdata\": {\n                        \"phase\": \"postquestionnaire\",\n                        \"status\": \"begin\"\n                    }\n                }, {\n                    \"uniqueid\": uniqueid,\n                    \"current_trial\": 1,\n                    \"dateTime\": 1564425802158,\n                    \"trialdata\": {\n                        \"phase\": \"postquestionnaire\",\n                        \"status\": \"submit\"\n                    }\n                }\n            ],\n            \"questiondata\": {\n                \"engagement\": \"5\",\n                \"difficulty\": \"5\"\n            },\n            \"eventdata\": [\n                {\n                    \"eventtype\": \"initialized\",\n                    \"value\": '',\n                    \"timestamp\": 1564425799139,\n                    \"interval\": 0\n                }, {\n                    \"eventtype\": \"window_resize\",\n                    \"value\": [933, 708],\n                    \"timestamp\": 1564425799139,\n                    \"interval\": 0\n                }\n            ],\n            \"useragent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36\",\n            \"mode\": \"debug\"\n        }\n        rv = self.app.put('/sync/%s' % uniqueid, json=payload)\n        status = json.loads(rv.get_data(as_text=True)).get(\"status\", \"\")\n        assert status == \"user data saved\"\n\n    def test_sync_get(self):\n        self.assignment_id = \"debug%s\" % self.assignment_id\n        self.worker_id = \"debug%s\" % self.worker_id\n        self.hit_id = \"debug%s\" % self.hit_id\n\n        request = \"&\".join([\n            \"assignmentId=%s\" % self.assignment_id,\n            \"workerId=%s\" % self.worker_id,\n            \"hitId=%s\" % self.hit_id,\n            \"mode=\"])\n\n        # put the user in the database\n        rv = self.app.get(\"/exp?%s\" % request)\n\n        # save data with sync PUT\n        uniqueid = \"%s:%s\" % (self.worker_id, self.assignment_id)\n        condition = 0\n        counterbalance = 0\n        bonus = 0.0\n        payload = {\n            \"condition\": condition,\n            \"counterbalance\": counterbalance,\n            \"assignmentId\": self.assignment_id,\n            \"workerId\": self.worker_id,\n            \"hitId\": self.hit_id,\n            \"currenttrial\": 2,\n            \"bonus\": bonus,\n            \"data\": [\n                {\n                    \"uniqueid\": uniqueid,\n                    \"current_trial\": 0,\n                    \"dateTime\": 1564425799481,\n                    \"trialdata\": {\n                        \"phase\": \"postquestionnaire\",\n                        \"status\": \"begin\"\n                    }\n                },\n                {\n                    \"uniqueid\": uniqueid,\n                    \"current_trial\": 1,\n                    \"dateTime\": 1564425802158,\n                    \"trialdata\": {\n                        \"phase\": \"postquestionnaire\",\n                        \"status\": \"submit\"\n                    }\n                }\n            ],\n            \"questiondata\": {\n                \"engagement\": \"5\",\n                \"difficulty\": \"5\"\n            },\n            \"eventdata\": [\n                {\n                    \"eventtype\": \"initialized\",\n                    \"value\": '',\n                    \"timestamp\": 1564425799139,\n                    \"interval\": 0\n                },\n                {\n                    \"eventtype\": \"window_resize\",\n                    \"value\": [933, 708],\n                    \"timestamp\": 1564425799139,\n                    \"interval\": 0\n                }\n            ],\n            \"useragent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36\",\n            \"mode\": \"debug\"\n        }\n        rv = self.app.put('/sync/%s' % uniqueid, json=payload)\n\n        # get data with sync GET\n        uniqueid = \"%s:%s\" % (self.worker_id, self.assignment_id)\n        rv = self.app.get('/sync/%s' % uniqueid)\n\n        response = json.loads(rv.get_data(as_text=True))\n        assert response.get(\"assignmentId\", \"\") == \"%s\" % self.assignment_id\n        assert response.get(\"workerId\", \"\") == \"%s\" % self.worker_id\n        assert response.get(\"hitId\", \"\") == \"%s\" % self.hit_id\n        assert response.get(\"condition\", None) == condition\n        assert response.get(\"counterbalance\", None) == counterbalance\n        assert response.get(\"bonus\", None) == bonus\n\n    def test_favicon(self):\n        \"\"\"Test that favicon loads.\"\"\"\n        rv = self.app.get('/favicon.ico')\n        assert rv.status_code == 200\n\n    def test_complete_experiment(self):\n        \"\"\"Test that a participant can start and finish the experiment.\"\"\"\n        request = \"&\".join([\n            \"assignmentId=debug%s\" % self.assignment_id,\n            \"workerId=debug%s\" % self.worker_id,\n            \"hitId=debug%s\" % self.hit_id,\n            \"mode=debug\"])\n\n        # put the user in the database\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert rv.status_code == 200\n\n        # complete experiment\n        uniqueid = \"debug%s:debug%s\" % (self.worker_id, self.assignment_id)\n        mode = 'debug'\n        rv = self.app.get('/complete?uniqueId=%s&mode=%s' % (uniqueid, mode))\n        assert rv.status_code == 200\n\n    def test_repeat_experiment_fail(self):\n        \"\"\"Test that a participant cannot repeat the experiment.\"\"\"\n        request = \"&\".join([\n            \"assignmentId=%s\" % self.assignment_id,\n            \"workerId=%s\" % self.worker_id,\n            \"hitId=%s\" % self.hit_id,\n            \"mode=debug\"])\n\n        # put the user in the database\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert rv.status_code == 200\n\n        # save data with sync PUT\n        uniqueid = \"%s:%s\" % (self.worker_id, self.assignment_id)\n        payload = {\n            \"condition\": 5, \"counterbalance\": 0,\n            \"assignmentId\": self.assignment_id,\n            \"workerId\": self.worker_id,\n            \"hitId\": self.hit_id,\n            \"currenttrial\": 2,\n            \"bonus\": 0,\n            \"data\": [\n                {\n                    \"uniqueid\": uniqueid,\n                    \"current_trial\": 0,\n                    \"dateTime\": 1564425799481,\n                    \"trialdata\": {\n                        \"phase\": \"postquestionnaire\",\n                        \"status\": \"begin\"\n                    }\n                },\n                {\n                    \"uniqueid\": uniqueid,\n                    \"current_trial\": 1,\n                    \"dateTime\": 1564425802158,\n                    \"trialdata\": {\n                        \"phase\": \"postquestionnaire\",\n                        \"status\": \"submit\"\n                    }\n                }\n            ],\n            \"questiondata\": {\n                \"engagement\": \"5\",\n                \"difficulty\": \"5\"\n            },\n            \"eventdata\": [\n                {\n                    \"eventtype\": \"initialized\",\n                    \"value\": '',\n                    \"timestamp\": 1564425799139,\n                    \"interval\": 0\n                },\n                {\n                    \"eventtype\": \"window_resize\",\n                    \"value\": [933, 708],\n                    \"timestamp\": 1564425799139,\n                    \"interval\": 0\n                }\n            ],\n            \"useragent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36\",\n            \"mode\": \"debug\"\n        }\n        rv = self.app.put('/sync/%s' % uniqueid, json={\n            \"condition\": 5,\n            \"counterbalance\": 0,\n            \"assignmentId\": self.assignment_id,\n            \"workerId\": self.worker_id,\n            \"hitId\": self.hit_id,\n            \"currenttrial\": 2,\n            \"bonus\": 0, \"data\": [\n                {\n                    \"uniqueid\": uniqueid,\n                    \"current_trial\": 0,\n                    \"dateTime\": 1564425799481,\n                    \"trialdata\": {\n                        \"phase\": \"postquestionnaire\",\n                        \"status\": \"begin\"\n                    }\n                },\n                {\n                    \"uniqueid\": uniqueid,\n                    \"current_trial\": 1,\n                    \"dateTime\": 1564425802158,\n                    \"trialdata\": {\n                        \"phase\": \"postquestionnaire\",\n                        \"status\": \"submit\"\n                    }\n                }\n            ],\n            \"questiondata\": {\n                \"engagement\": \"5\",\n                \"difficulty\": \"5\"\n            },\n            \"eventdata\": [\n                {\n                    \"eventtype\": \"initialized\", \"value\": '',\n                    \"timestamp\": 1564425799139,\n                    \"interval\": 0\n                },\n                {\n                    \"eventtype\": \"window_resize\",\n                    \"value\": [933, 708],\n                    \"timestamp\": 1564425799139,\n                    \"interval\": 0\n                }\n            ],\n            \"useragent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36\",\n            \"mode\": \"debug\"\n        })\n        assert rv.status_code == 200\n\n        # complete experiment\n        mode = 'debug'\n        rv = self.app.get('/complete?uniqueId=%s&mode=%s' % (uniqueid, mode))\n        assert rv.status_code == 200\n\n        # choose new assignment and hit ids\n        self.assignment_id = fake.md5(raw_output=False)\n        self.hit_id = fake.md5(raw_output=False)\n        request = \"&\".join([\n            \"assignmentId=%s\" % self.assignment_id,\n            \"workerId=%s\" % self.worker_id,\n            \"hitId=%s\" % self.hit_id,\n            \"mode=debug\"])\n\n        # make sure they are blocked on the ad page\n        rv = self.app.get('/ad?%s' % request)\n        assert ': 1010' in rv.get_data(as_text=True)\n\n        # make sure they are blocked on the experiment page\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert ': 1010' in rv.get_data(as_text=True)\n\n    def test_repeat_experiment_success(self):\n        \"\"\"Test that a participant can repeat the experiment.\"\"\"\n        self.set_config(u'Task Parameters', u'allow_repeats', u'true')\n        request = \"&\".join([\n            \"assignmentId=%s\" % self.assignment_id,\n            \"workerId=%s\" % self.worker_id,\n            \"hitId=%s\" % self.hit_id,\n            \"mode=debug\"])\n\n        # put the user in the database\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert rv.status_code == 200\n\n        # save data with sync PUT\n        uniqueid = \"%s:%s\" % (self.worker_id, self.assignment_id)\n        payload = {\n            \"condition\": 5, \"counterbalance\": 0,\n            \"assignmentId\": self.assignment_id, \"workerId\": self.worker_id,\n            \"hitId\": self.hit_id, \"currenttrial\": 2, \"bonus\": 0, \"data\": [\n                {\"uniqueid\": uniqueid, \"current_trial\": 0, \"dateTime\": 1564425799481,\n                 \"trialdata\": {\"phase\": \"postquestionnaire\", \"status\": \"begin\"}},\n                {\"uniqueid\": uniqueid, \"current_trial\": 1, \"dateTime\": 1564425802158,\n                 \"trialdata\": {\"phase\": \"postquestionnaire\", \"status\": \"submit\"}}],\n            \"questiondata\": {\"engagement\": \"5\", \"difficulty\": \"5\"}, \"eventdata\": [\n                {\"eventtype\": \"initialized\", \"value\": '', \"timestamp\": 1564425799139,\n                 \"interval\": 0},\n                {\"eventtype\": \"window_resize\", \"value\": [933, 708], \"timestamp\": 1564425799139,\n                 \"interval\": 0}],\n            \"useragent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36\",\n            \"mode\": \"debug\"}\n        rv = self.app.put('/sync/%s' % uniqueid, json=payload)\n        assert rv.status_code == 200\n\n        # complete experiment\n        mode = 'debug'\n        rv = self.app.get('/complete?uniqueId=%s&mode=%s' % (uniqueid, mode))\n        assert rv.status_code == 200\n\n        # choose new assignment and hit ids\n        self.assignment_id = fake.md5(raw_output=False)\n        self.hit_id = fake.md5(raw_output=False)\n        request = \"&\".join([\n            \"assignmentId=%s\" % self.assignment_id,\n            \"workerId=%s\" % self.worker_id,\n            \"hitId=%s\" % self.hit_id,\n            \"mode=debug\"])\n\n        # make sure they are not blocked on the ad page\n        rv = self.app.get('/ad?%s' % request)\n        assert rv.status_code == 200\n        assert ': 1010' not in rv.get_data(as_text=True)\n\n        # make sure they are not blocked on the experiment page\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert rv.status_code == 200\n        assert ': 1010' not in rv.get_data(as_text=True)\n\n        # save data with sync PUT\n        uniqueid = \"%s:%s\" % (self.worker_id, self.assignment_id)\n        payload = payload = {\n            \"condition\": 5, \"counterbalance\": 0,\n            \"assignmentId\": self.assignment_id, \"workerId\": self.worker_id,\n            \"hitId\": self.hit_id, \"currenttrial\": 2, \"bonus\": 0, \"data\": [\n                {\"uniqueid\": uniqueid, \"current_trial\": 0, \"dateTime\": 1564425799481,\n                 \"trialdata\": {\"phase\": \"postquestionnaire\", \"status\": \"begin\"}},\n                {\"uniqueid\": uniqueid, \"current_trial\": 1, \"dateTime\": 1564425802158,\n                 \"trialdata\": {\"phase\": \"postquestionnaire\", \"status\": \"submit\"}}],\n            \"questiondata\": {\"engagement\": \"5\", \"difficulty\": \"5\"}, \"eventdata\": [\n                {\"eventtype\": \"initialized\", \"value\": '', \"timestamp\": 1564425799139,\n                 \"interval\": 0},\n                {\"eventtype\": \"window_resize\", \"value\": [933, 708], \"timestamp\": 1564425799139,\n                 \"interval\": 0}],\n            \"useragent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36\",\n            \"mode\": \"debug\"}\n        rv = self.app.put('/sync/%s' % uniqueid, json=payload)\n        assert rv.status_code == 200\n\n        # complete experiment\n        mode = 'debug'\n        rv = self.app.get('/complete?uniqueId=%s&mode=%s' % (uniqueid, mode))\n        assert rv.status_code == 200\n\n    def test_repeat_experiment_quit(self):\n        \"\"\"Test that a participant cannot restart the experiment.\"\"\"\n        request = \"&\".join([\n            \"assignmentId=%s\" % self.assignment_id,\n            \"workerId=%s\" % self.worker_id,\n            \"hitId=%s\" % self.hit_id,\n            \"mode=debug\"])\n\n        # put the user in the database\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert rv.status_code == 200\n\n        # put the in the experiment\n        uniqueid = \"%s:%s\" % (self.worker_id, self.assignment_id)\n        rv = self.app.post(\"/inexp\", data=dict(uniqueId=uniqueid))\n        assert rv.status_code == 200\n\n        # make sure they are blocked on the ad page\n        rv = self.app.get('/ad?%s' % request)\n        assert rv.status_code == 200\n        assert ': 1009' in rv.get_data(as_text=True)\n\n        # make sure they are blocked on the experiment page\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert rv.status_code == 200\n        assert ': 1008' in rv.get_data(as_text=True)\n\n        # have them quit the experiment\n        rv = self.app.post(\"/quitter\", data=dict(uniqueId=uniqueid))\n        assert rv.status_code == 200\n\n        # make sure they are blocked on the ad page\n        rv = self.app.get('/ad?%s' % request)\n        assert rv.status_code == 200\n        assert ': 1009' in rv.get_data(as_text=True)\n\n        # make sure they are blocked on the experiment page\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert rv.status_code == 200\n        assert ': 1008' in rv.get_data(as_text=True)\n\n    def test_repeat_experiment_quit_allow_repeats(self):\n        \"\"\"Test that a participant cannot restart the experiment, even when repeats are allowed.\"\"\"\n        self.set_config(u'Task Parameters', u'allow_repeats', u'true')\n        request = \"&\".join([\n            \"assignmentId=%s\" % self.assignment_id,\n            \"workerId=%s\" % self.worker_id,\n            \"hitId=%s\" % self.hit_id,\n            \"mode=debug\"])\n\n        # put the user in the database\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert rv.status_code == 200\n\n        # put the in the experiment\n        uniqueid = \"%s:%s\" % (self.worker_id, self.assignment_id)\n        rv = self.app.post(\"/inexp\", data=dict(uniqueId=uniqueid))\n        assert rv.status_code == 200\n\n        # make sure they are blocked on the ad page\n        rv = self.app.get('/ad?%s' % request)\n        assert rv.status_code == 200\n        assert ': 1009' in rv.get_data(as_text=True)\n\n        # make sure they are blocked on the experiment page\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert rv.status_code == 200\n        assert ': 1008' in rv.get_data(as_text=True)\n\n        # have them quit the experiment\n        rv = self.app.post(\"/quitter\", data=dict(uniqueId=uniqueid))\n        assert rv.status_code == 200\n\n        # make sure they are blocked on the ad page\n        rv = self.app.get('/ad?%s' % request)\n        assert rv.status_code == 200\n        assert ': 1009' in rv.get_data(as_text=True)\n\n        # make sure they are blocked on the experiment page\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert rv.status_code == 200\n        assert ': 1008' in rv.get_data(as_text=True)\n\n\nclass BadUserAgent(PsiturkUnitTest):\n    \"\"\"Setup test blocked user agent (iPad/tablets)\"\"\"\n\n    def setUp(self):\n        \"\"\"Build up fixtures\"\"\"\n        import psiturk.experiment\n        reload(psiturk.experiment)\n\n        psiturk.experiment.app.wsgi_app = BadFlaskTestClientProxy(\n            psiturk.experiment.app.wsgi_app)\n        self.app = psiturk.experiment.app.test_client()\n\n        # Fake MTurk data\n        self.worker_id = fake.md5(raw_output=False)\n        self.hit_id = fake.md5(raw_output=False)\n        self.assignment_id = fake.md5(raw_output=False)\n\n    def test_ad_with_bad_user_agent(self):\n        \"\"\"Test that ad page throws Error when user agent is blocked.\"\"\"\n        rv = self.app.get(\n            '/ad' + '?assignmentId=debug' + self.assignment_id + '&workerId=debug' +\n            self.worker_id + '&hitId=debug' + self.hit_id + '&mode=sandbox'\n        )\n        assert '<b>Error</b>: 1014' in rv.get_data(as_text=True)\n\n\nclass PsiTurkTestPsiturkJS(PsiturkUnitTest):\n    \"\"\" Setup test for missing psiturk.js file. \"\"\"\n\n    def setUp(self):\n        \"\"\"Build up fixtures\"\"\"\n        self.PSITURK_JS_FILE = '../psiturk/psiturk_js/psiturk.js'\n        os.rename(self.PSITURK_JS_FILE, self.PSITURK_JS_FILE + '.bup')\n        import psiturk.experiment\n        reload(psiturk.experiment)\n\n        psiturk.experiment.app.wsgi_app = FlaskTestClientProxy(\n            psiturk.experiment.app.wsgi_app)\n        self.app = psiturk.experiment.app.test_client()\n\n    @pytest.mark.skip('soemthing about the testing env is making this not work well')\n    def test_psiturk_js_is_missing(self):\n        \"\"\" Test for missing psiturk.js \"\"\"\n        rv = self.app.get('static/js/psiturk.js')\n        assert 'file not found' in rv.get_data(as_text=True)\n\n    def tearDown(self):\n        \"\"\"Tear down fixtures\"\"\"\n        super(PsiTurkTestPsiturkJS, self).tearDown()\n        os.rename(self.PSITURK_JS_FILE + '.bup', self.PSITURK_JS_FILE)\n\n\nclass ExperimentErrorsTest(PsiturkUnitTest):\n\n    def test_experiment_errors(self):\n        \"\"\"Make sure every error has a description\"\"\"\n        error_cls = psiturk.experiment_errors.ExperimentError\n\n        for error_name in error_cls.experiment_errors:\n            assert error_name in error_cls.error_descriptions\n\n        for error_name in error_cls.error_descriptions:\n            assert error_name in error_cls.experiment_errors\n\n\nif __name__ == '__main__':\n    unittest.main()\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n\"\"\" This module provides the backend Flask server used by psiTurk. \"\"\"\nfrom __future__ import generator_stop\nimport os\nimport sys\nimport datetime\nimport logging\nfrom random import choice\nimport user_agents\nimport requests\nimport re\nimport json\nfrom jinja2 import TemplateNotFound\nfrom collections import Counter\n\n\n# Setup flask\nfrom flask import Flask, render_template, render_template_string, request, \\\n    jsonify, send_from_directory\n\n# Setup database\n\nfrom .db import db_session, init_db\nfrom .models import Participant\nfrom sqlalchemy import or_, exc\n\nfrom .psiturk_statuses import *\nfrom .psiturk_config import PsiturkConfig\nfrom .experiment_errors import ExperimentError, ExperimentApiError\nfrom .user_utils import nocache\n\n# Setup config\nCONFIG = PsiturkConfig()\nCONFIG.load_config()\n\nLOG_LEVELS = [logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\nlogging.CRITICAL]\nLOG_LEVEL = LOG_LEVELS[CONFIG.getint('Server Parameters', 'loglevel')]\n\nlogfile = CONFIG.get(\"Server Parameters\", \"errorlog\")\nif logfile != '-':\n    file_path = os.path.join(os.getcwd(), logfile)\n    logging.basicConfig(filename=file_path, format='%(asctime)s %(message)s',\n                        level=LOG_LEVEL)\n\n# Let's start\n# ===========\n\napp = Flask(\"Experiment_Server\")\napp.logger.setLevel(LOG_LEVEL)\n\n# Set cache timeout to 10 seconds for static files\napp.config.update(SEND_FILE_MAX_AGE_DEFAULT=10)\napp.secret_key = CONFIG.get('Server Parameters', 'secret_key')\n\n\ndef check_templates_exist():\n    # this checks for templates that are required if you are hosting your own ad.\n    try:\n        try_these = ['thanks-mturksubmit.html', 'closepopup.html']\n        [app.jinja_env.get_template(try_this) for try_this in try_these]\n    except TemplateNotFound as e:\n        raise RuntimeError((\n            f\"Missing one of the following templates: {', '.join(try_these)}.\"\n            f\"Copy these over from a freshly-created psiturk example experiment.\"\n            f\"{type(e).__name__, str(e)}\"\n        ))\n\n\ncheck_templates_exist()\n\n\n# Serving warm, fresh, & sweet custom, user-provided routes\n# ==========================================================\n\ntry:\n    sys.path.append(os.getcwd())\n    from custom import custom_code\nexcept ModuleNotFoundError as e:\n    app.logger.info(\"Hmm... it seems no custom code (custom.py) associated \\\n                    with this project.\")\nexcept ImportError as e:\n    app.logger.error(\"There is custom code (custom.py) associated with this \\\n                      project but it doesn't import cleanly.  Raising exception,\")\n    raise\nelse:\n    app.register_blueprint(custom_code)\n    try:\n        # noinspection PyUnresolvedReferences\n        from custom import init_app as custom_init_app\n    except ImportError as e:\n        pass\n    else:\n        custom_init_app(app)\n\n# scheduler\n\nfrom apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore\nfrom pytz import utc\n\nfrom .db import engine\njobstores = {\n    'default': SQLAlchemyJobStore(engine=engine)\n}\nif 'gunicorn' in os.environ.get('SERVER_SOFTWARE', ''):\n    from apscheduler.schedulers.gevent import GeventScheduler as Scheduler\nelse:\n    from apscheduler.schedulers.background import BackgroundScheduler as Scheduler\nlogging.getLogger('apscheduler').setLevel(logging.DEBUG)\nscheduler = Scheduler(jobstores=jobstores, timezone=utc)\napp.apscheduler = scheduler\nscheduler.app = app\n\nif CONFIG.getboolean('Server Parameters', 'do_scheduler'):\n    app.logger.info(\"Scheduler starting!\")\n    scheduler.start()\nelse:\n    app.logger.info(\"Starting scheduler in 'paused' mode -- it will not run any tasks, but it can be used to create, modify, or delete tasks.\")\n    scheduler.start(paused=True)\n\n\n#\n# Dashboard\n#\nif CONFIG.getboolean('Server Parameters', 'enable_dashboard'):\n    from .dashboard import dashboard, init_app as dashboard_init_app # management dashboard\n    app.register_blueprint(dashboard)\n    dashboard_init_app(app)\n\n    from .api import api_blueprint\n    app.register_blueprint(api_blueprint)\n\ninit_db()\n\n# Read psiturk.js file into memory\nPSITURK_JS_FILE = os.path.join(os.path.dirname(__file__),\n                               \"psiturk_js/psiturk.js\")\napp.logger.info(PSITURK_JS_FILE)\n\nif os.path.exists(PSITURK_JS_FILE):\n    PSITURK_JS_CODE = open(PSITURK_JS_FILE).read()\nelse:\n    PSITURK_JS_CODE = \"alert('psiturk.js file not found!');\"\n\n\n@app.errorhandler(ExperimentError)\ndef handle_exp_error(exception):\n    \"\"\"Handle errors by sending an error page.\"\"\"\n    app.logger.error(\n        \"%s (%s) %s\", exception.value, exception.errornum, str(dict(request.args)))\n    return exception.error_page(request, CONFIG.get('Task Parameters',\n                                                    'contact_email_on_error'))\n\n\n@app.errorhandler(ExperimentApiError)\ndef handle_experiment_api_error(error):\n    # for use with API errors\n    response = jsonify(error.to_dict())\n    response.status_code = error.status_code\n    app.logger.error(error.message)\n    return response\n\n\n@app.teardown_request\ndef shutdown_session(_=None):\n    \"\"\" Shut down session route \"\"\"\n    db_session.remove()\n\n\n# Experiment counterbalancing code\n# ================================\n\ndef get_random_condcount(mode):\n    \"\"\"\n    HITs can be in one of three states:\n        - jobs that are finished\n        - jobs that are started but not finished\n        - jobs that are never going to finish (user decided not to do it)\n    Our count should be based on the first two, so we count any tasks finished\n    or any tasks not finished that were started in the last cutoff_time\n    minutes, as specified in the cutoff_time variable in the config file.\n\n    Returns a tuple: (cond, condition)\n    \"\"\"\n    cutofftime = datetime.timedelta(minutes=-CONFIG.getint('Task Parameters',\n                                                           'cutoff_time'))\n    starttime = datetime.datetime.now(datetime.timezone.utc) + cutofftime\n\n    try:\n        conditions = json.load(\n            open(os.path.join(app.root_path, 'conditions.json')))\n        numconds = len(list(conditions.keys()))\n        numcounts = 1\n    except IOError:\n        numconds = CONFIG.getint('Task Parameters', 'num_conds')\n        numcounts = CONFIG.getint('Task Parameters', 'num_counters')\n\n    participants = Participant.query.\\\n        filter(Participant.codeversion ==\n               CONFIG.get('Task Parameters', 'experiment_code_version')).\\\n        filter(Participant.mode == mode).\\\n        filter(or_(Participant.status == COMPLETED,\n                   Participant.status == CREDITED,\n                   Participant.status == SUBMITTED,\n                   Participant.status == BONUSED,\n                   Participant.beginhit > starttime)).all()\n    counts = Counter()\n    for cond in range(numconds):\n        for counter in range(numcounts):\n            counts[(cond, counter)] = 0\n    for participant in participants:\n        condcount = (participant.cond, participant.counterbalance)\n        if condcount in counts:\n            counts[condcount] += 1\n    mincount = min(counts.values())\n    minima = [hsh for hsh, count in counts.items() if count == mincount]\n    chosen = choice(minima)\n    app.logger.info(\"given %(a)s chose %(b)s\" % {'a': counts, 'b': chosen})\n\n    return chosen\n\n\ntry:\n    from custom import custom_get_condition as get_condition\nexcept (ModuleNotFoundError, ImportError):\n    get_condition = get_random_condcount\n\n# Routes\n# ======\n\n\n@app.route('/')\n@nocache\ndef index():\n    \"\"\" Index route \"\"\"\n    return render_template('default.html')\n\n\n@app.route('/favicon.ico')\ndef favicon():\n    \"\"\" Serve favicon \"\"\"\n    return app.send_static_file('favicon.ico')\n\n\n@app.route('/static/js/psiturk.js')\ndef psiturk_js():\n    \"\"\" psiTurk js route \"\"\"\n    return render_template_string(PSITURK_JS_CODE)\n\n\n@app.route('/check_worker_status', methods=['GET'])\ndef check_worker_status():\n    \"\"\" Check worker status route \"\"\"\n    if 'workerId' not in request.args:\n        resp = {\"status\": \"bad request\"}\n        return jsonify(**resp)\n    else:\n        worker_id = request.args['workerId']\n        assignment_id = request.args['assignmentId']\n        allow_repeats = CONFIG.getboolean('Task Parameters', 'allow_repeats')\n        if allow_repeats:  # if you allow repeats focus on current worker/assignment combo\n            try:\n                part = Participant.query.\\\n                    filter(Participant.workerid == worker_id).\\\n                    filter(Participant.assignmentid == assignment_id).one()\n                status = part.status\n            except exc.SQLAlchemyError:\n                status = NOT_ACCEPTED\n        else:  # if you disallow repeats search for highest status of anything by this worker\n            try:\n                matches = Participant.query.\\\n                    filter(Participant.workerid == worker_id).all()\n                numrecs = len(matches)\n                if numrecs == 0:  # this should be caught by exception, but just to be safe\n                    status = NOT_ACCEPTED\n                else:\n                    status = max([record.status for record in matches])\n            except exc.SQLAlchemyError:\n                status = NOT_ACCEPTED\n        resp = {\"status\": status}\n        return jsonify(**resp)\n\n\n@app.route('/ad', methods=['GET'])\n@app.route('/pub', methods=['GET'])\n@nocache\ndef advertisement():\n    \"\"\"\n    This is the url we give for the ad for our 'external question'.  The ad has\n    to display two different things: This page will be called from within\n    mechanical turk, with url arguments hitId, assignmentId, and workerId.\n    If the worker has not yet accepted the hit:\n        These arguments will have null values, we should just show an ad for\n        the experiment.\n    If the worker has accepted the hit:\n        These arguments will have appropriate values and we should enter the\n        person in the database and provide a link to the experiment popup.\n    \"\"\"\n    user_agent_string = request.user_agent.string\n    user_agent_obj = user_agents.parse(user_agent_string)\n    browser_ok = True\n    browser_exclude_rule = CONFIG.get('Task Parameters', 'browser_exclude_rule')\n    for rule in browser_exclude_rule.split(','):\n        myrule = rule.strip()\n        if myrule in [\"mobile\", \"tablet\", \"touchcapable\", \"pc\", \"bot\"]:\n            if (myrule == \"mobile\" and user_agent_obj.is_mobile) or\\\n               (myrule == \"tablet\" and user_agent_obj.is_tablet) or\\\n               (myrule == \"touchcapable\" and user_agent_obj.is_touch_capable) or\\\n               (myrule == \"pc\" and user_agent_obj.is_pc) or\\\n               (myrule == \"bot\" and user_agent_obj.is_bot):\n                browser_ok = False\n        elif myrule == \"Safari\" or myrule == \"safari\":\n            if \"Chrome\" in user_agent_string and \"Safari\" in user_agent_string:\n                pass\n            elif \"Safari\" in user_agent_string:\n                browser_ok = False\n        elif myrule in user_agent_string:\n            browser_ok = False\n\n    if not browser_ok:\n        # Handler for IE users if IE is not supported.\n        raise ExperimentError('browser_type_not_allowed')\n\n    if not ('hitId' in request.args and 'assignmentId' in request.args):\n        raise ExperimentError('hit_assign_worker_id_not_set_in_mturk')\n    hit_id = request.args['hitId']\n    assignment_id = request.args['assignmentId']\n    mode = request.args['mode']\n    if hit_id[:5] == \"debug\":\n        debug_mode = True\n    else:\n        debug_mode = False\n    already_in_db = False\n    if 'workerId' in request.args:\n        worker_id = request.args['workerId']\n        # First check if this workerId has completed the task before (v1).\n        nrecords = Participant.query.\\\n            filter(Participant.assignmentid != assignment_id).\\\n            filter(Participant.workerid == worker_id).\\\n            count()\n\n        if nrecords > 0:  # Already completed task\n            already_in_db = True\n    else:  # If worker has not accepted the hit\n        worker_id = None\n    try:\n        part = Participant.query.\\\n            filter(Participant.hitid == hit_id).\\\n            filter(Participant.assignmentid == assignment_id).\\\n            filter(Participant.workerid == worker_id).\\\n            one()\n        status = part.status\n    except exc.SQLAlchemyError:\n        status = None\n\n    allow_repeats = CONFIG.getboolean('Task Parameters', 'allow_repeats')\n    if (status == STARTED or status == QUITEARLY) and not debug_mode:\n        # Once participants have finished the instructions, we do not allow\n        # them to start the task again.\n        raise ExperimentError('already_started_exp_mturk')\n    elif status == COMPLETED or (status == SUBMITTED and not already_in_db):\n        # 'or status == SUBMITTED' because we suspect that sometimes the post\n        # to mturk fails after we've set status to SUBMITTED, so really they\n        # have not successfully submitted. This gives another chance for the\n        # submit to work.\n\n        # They've finished the experiment but haven't successfully submitted the HIT\n        # yet.\n        return render_template(\n            'thanks-mturksubmit.html',\n            using_sandbox=(mode == \"sandbox\"),\n            hitid=hit_id,\n            assignmentid=assignment_id,\n            workerid=worker_id\n        )\n    elif already_in_db and not (debug_mode or allow_repeats):\n        raise ExperimentError('already_did_exp_hit')\n    elif status == ALLOCATED or not status or debug_mode:\n        # Participant has not yet agreed to the consent. They might not\n        # even have accepted the HIT.\n        with open('templates/ad.html', 'r') as temp_file:\n            ad_string = temp_file.read()\n        ad_string = insert_mode(ad_string)\n        return render_template_string(\n            ad_string,\n            mode=mode,\n            hitid=hit_id,\n            assignmentid=assignment_id,\n            workerid=worker_id\n        )\n    else:\n        raise ExperimentError('status_incorrectly_set')\n\n\n@app.route('/consent', methods=['GET'])\n@nocache\ndef give_consent():\n    \"\"\"\n    Serves up the consent in the popup window.\n    \"\"\"\n    if not ('hitId' in request.args and 'assignmentId' in request.args and\n            'workerId' in request.args):\n        raise ExperimentError('hit_assign_worker_id_not_set_in_consent')\n    hit_id = request.args['hitId']\n    assignment_id = request.args['assignmentId']\n    worker_id = request.args['workerId']\n    mode = request.args['mode']\n    with open('templates/consent.html', 'r') as temp_file:\n        consent_string = temp_file.read()\n    consent_string = insert_mode(consent_string)\n    return render_template_string(\n        consent_string,\n        mode=mode,\n        hitid=hit_id,\n        assignmentid=assignment_id,\n        workerid=worker_id\n    )\n\n\n@app.route('/exp', methods=['GET'])\n@nocache\ndef start_exp():\n    \"\"\" Serves up the experiment applet. \"\"\"\n    if not (('hitId' in request.args) and ('assignmentId' in request.args) and\n            ('workerId' in request.args) and ('mode' in request.args)):\n        raise ExperimentError('hit_assign_worker_id_not_set_in_exp')\n    hit_id = request.args['hitId']\n    assignment_id = request.args['assignmentId']\n    worker_id = request.args['workerId']\n    mode = request.args['mode']\n    app.logger.info(\"Accessing /exp: %(h)s %(a)s %(w)s \" % {\n        \"h\": hit_id,\n        \"a\": assignment_id,\n        \"w\": worker_id\n    })\n    if hit_id[:5] == \"debug\":\n        debug_mode = True\n    else:\n        debug_mode = False\n\n    # Check first to see if this hitId or assignmentId exists.  If so, check to\n    # see if inExp is set\n    allow_repeats = CONFIG.getboolean('Task Parameters', 'allow_repeats')\n    if allow_repeats:\n        matches = Participant.query.\\\n            filter(Participant.workerid == worker_id).\\\n            filter(Participant.assignmentid == assignment_id).\\\n            all()\n    else:\n        matches = Participant.query.\\\n            filter(Participant.workerid == worker_id).\\\n            all()\n\n    numrecs = len(matches)\n    if numrecs == 0:\n        # Choose condition and counterbalance\n        subj_cond, subj_counter = get_condition(mode)\n\n        worker_ip = \"UNKNOWN\" if not request.remote_addr else \\\n            request.remote_addr\n        browser = \"UNKNOWN\" if not request.user_agent.browser else \\\n            request.user_agent.browser\n        platform = \"UNKNOWN\" if not request.user_agent.platform else \\\n            request.user_agent.platform\n        language = \"UNKNOWN\" if not request.accept_languages else \\\n            request.accept_languages.best\n\n        # Set condition here and insert into database.\n        participant_attributes = dict(\n            assignmentid=assignment_id,\n            workerid=worker_id,\n            hitid=hit_id,\n            cond=subj_cond,\n            counterbalance=subj_counter,\n            ipaddress=worker_ip,\n            browser=browser,\n            platform=platform,\n            language=language,\n            mode=mode\n        )\n        part = Participant(**participant_attributes)\n        db_session.add(part)\n        db_session.commit()\n\n    else:\n        # A couple possible problems here:\n        # 1: They've already done an assignment, then we should tell them they\n        #    can't do another one\n        # 2: They've already worked on this assignment, and got too far to\n        #    start over.\n        # 3: They're in the database twice for the same assignment, that should\n        #    never happen.\n        # 4: They're returning and all is well.\n        nrecords = 0\n        for record in matches:\n            other_assignment = False\n            if record.assignmentid != assignment_id:\n                other_assignment = True\n            else:\n                nrecords += 1\n        if nrecords <= 1 and not other_assignment:\n            part = matches[0]\n            # In experiment (or later) can't restart at this point\n            if part.status >= STARTED and not debug_mode:\n                raise ExperimentError('already_started_exp')\n        else:\n            if nrecords > 1:\n                app.logger.error(\"Error, hit/assignment appears in database \\\n                                 more than once (serious problem)\")\n                raise ExperimentError(\n                    'hit_assign_appears_in_database_more_than_once'\n                )\n            if other_assignment:\n                raise ExperimentError('already_did_exp_hit')\n\n    ad_server_location = '/complete'\n\n    return render_template(\n        'exp.html', uniqueId=part.uniqueid,\n        condition=part.cond,\n        counterbalance=part.counterbalance,\n        adServerLoc=ad_server_location,\n        mode=mode,\n        contact_address=CONFIG.get(\n            'Task Parameters', 'contact_email_on_error'),\n        codeversion=CONFIG.get(\n            'Task Parameters', 'experiment_code_version')\n    )\n\n\n@app.route('/inexp', methods=['POST'])\ndef enterexp():\n    \"\"\"\n    AJAX listener that listens for a signal from the user's script when they\n    leave the instructions and enter the real experiment. After the server\n    receives this signal, it will no longer allow them to re-access the\n    experiment applet (meaning they can't do part of the experiment and\n    referesh to start over).\n    \"\"\"\n    app.logger.info(\"Accessing /inexp\")\n    if 'uniqueId' not in request.form:\n        raise ExperimentError('improper_inputs')\n    unique_id = request.form['uniqueId']\n\n    try:\n        user = Participant.query.\\\n            filter(Participant.uniqueid == unique_id).one()\n        user.status = STARTED\n        user.beginexp = datetime.datetime.now(datetime.timezone.utc)\n        db_session.add(user)\n        db_session.commit()\n        resp = {\"status\": \"success\"}\n    except exc.SQLAlchemyError:\n        app.logger.error(\"DB error: Unique user not found.\")\n        resp = {\"status\": \"error, uniqueId not found\"}\n    return jsonify(**resp)\n\n# TODD SAYS: This the only route in the whole thing that uses <id> like this\n# where everything else uses POST!  This could be confusing but is forced\n# somewhat by Backbone?  Take heed!\n@app.route('/sync/<uid>', methods=['GET'])\ndef load(uid=None):\n    \"\"\"\n    Load experiment data, which should be a JSON object and will be stored\n    after converting to string.\n    \"\"\"\n    app.logger.info(\"GET /sync route with id: %s\" % uid)\n\n    try:\n        user = Participant.query.\\\n            filter(Participant.uniqueid == uid).\\\n            one()\n    except exc.SQLAlchemyError:\n        app.logger.error(\"DB error: Unique user not found.\")\n    else:\n        try:\n            resp = json.loads(user.datastring)\n        except (ValueError, TypeError, json.JSONDecodeError):\n            resp = {\n                \"condition\": user.cond,\n                \"counterbalance\": user.counterbalance,\n                \"assignmentId\": user.assignmentid,\n                \"workerId\": user.workerid,\n                \"hitId\": user.hitid,\n                \"bonus\": user.bonus\n            }\n        return jsonify(**resp)\n\n\n@app.route('/sync/<uid>', methods=['PUT'])\ndef update(uid=None):\n    \"\"\"\n    Save experiment data, which should be a JSON object and will be stored\n    after converting to string.\n    \"\"\"\n    app.logger.info(\"PUT /sync route with id: %s\" % uid)\n\n    try:\n        user = Participant.query.\\\n            filter(Participant.uniqueid == uid).\\\n            one()\n    except exc.SQLAlchemyError:\n        raise ExperimentApiError(\"DB error: Unique user not found.\")\n\n    user.datastring = json.dumps(request.json)\n    db_session.add(user)\n    db_session.commit()\n\n    try:\n        data = json.loads(user.datastring)\n    except Exception as e:\n        raise ExperimentApiError('failed to load json datastring back from database as object! Error was {}: {}'.format(type(e), str(e)))\n\n    trial = data.get(\"currenttrial\", None)\n    app.logger.info(\"saved data for %s (current trial: %s)\", uid, trial)\n    resp = {\"status\": \"user data saved\"}\n    return jsonify(**resp)\n\n\n@app.route('/quitter', methods=['POST'])\ndef quitter():\n    \"\"\"\n    Mark quitter as such.\n    \"\"\"\n    unique_id = request.form['uniqueId']\n    if unique_id[:5] == \"debug\":\n        debug_mode = True\n    else:\n        debug_mode = False\n\n    if debug_mode:\n        resp = {\"status\": \"didn't mark as quitter since this is debugging\"}\n        return jsonify(**resp)\n    else:\n        try:\n            unique_id = request.form['uniqueId']\n            app.logger.info(\"Marking quitter %s\" % unique_id)\n            user = Participant.query.\\\n                filter(Participant.uniqueid == unique_id).\\\n                one()\n            user.status = QUITEARLY\n            db_session.add(user)\n            db_session.commit()\n        except exc.SQLAlchemyError:\n            raise ExperimentError('tried_to_quit')\n        else:\n            resp = {\"status\": \"marked as quitter\"}\n            return jsonify(**resp)\n\n# Note: This route should only used when debugging\n# or when not using the psiturk adserver\n@app.route('/complete', methods=['GET'])\n@nocache\ndef debug_complete():\n    \"\"\" Debugging route for complete. \"\"\"\n    if 'uniqueId' not in request.args:\n        raise ExperimentError('improper_inputs')\n    else:\n        unique_id = request.args['uniqueId']\n        mode = request.args['mode']\n        try:\n            user = Participant.query.\\\n                filter(Participant.uniqueid == unique_id).one()\n            user.status = COMPLETED\n            user.endhit = datetime.datetime.now(datetime.timezone.utc)\n            db_session.add(user)\n            db_session.commit()\n        except exc.SQLAlchemyError:\n            raise ExperimentError('error_setting_worker_complete')\n        else:\n            # send them back to mturk.\n            if mode == 'sandbox' or mode == 'live':\n                return render_template('closepopup.html')\n            else:\n                allow_repeats = CONFIG.getboolean('Task Parameters', 'allow_repeats')\n                return render_template('complete.html',\n                                       allow_repeats=allow_repeats,\n                                       worker_id=user.workerid)\n\n\n@app.route('/worker_complete', methods=['GET'])\ndef worker_complete():\n    \"\"\" Complete worker. \"\"\"\n    if 'uniqueId' not in request.args:\n        resp = {\"status\": \"bad request\"}\n        return jsonify(**resp)\n    else:\n        unique_id = request.args['uniqueId']\n        app.logger.info(\"Completed experiment %s\" % unique_id)\n        try:\n            user = Participant.query.\\\n                filter(Participant.uniqueid == unique_id).one()\n            user.status = COMPLETED\n            user.endhit = datetime.datetime.now(datetime.timezone.utc)\n            db_session.add(user)\n            db_session.commit()\n            status = \"success\"\n        except exc.SQLAlchemyError:\n            status = \"database error\"\n        resp = {\"status\": status}\n        return jsonify(**resp)\n\n\n@app.route('/worker_submitted', methods=['GET'])\ndef worker_submitted():\n    \"\"\" Submit worker \"\"\"\n    if 'uniqueId' not in request.args:\n        resp = {\"status\": \"bad request\"}\n        return jsonify(**resp)\n    else:\n        unique_id = request.args['uniqueId']\n        app.logger.info(\"Submitted experiment for %s\" % unique_id)\n        try:\n            user = Participant.query.\\\n                filter(Participant.uniqueid == unique_id).one()\n            user.status = SUBMITTED\n            db_session.add(user)\n            db_session.commit()\n            status = \"success\"\n        except exc.SQLAlchemyError:\n            status = \"database error\"\n        resp = {\"status\": status}\n        return jsonify(**resp)\n\n# Is this a security risk?\n@app.route(\"/ppid\")\ndef ppid():\n    \"\"\" Get ppid \"\"\"\n    proc_id = os.getppid()\n    return str(proc_id)\n\n# Insert \"mode\" into pages so it's carried from page to page done server-side\n# to avoid breaking backwards compatibility with old templates.\n\n\ndef insert_mode(page_html):\n    \"\"\" Insert mode \"\"\"\n    page_html = page_html\n    match_found = False\n    matches = re.finditer('workerId={{ workerid }}', page_html)\n    match = None\n    for match in matches:\n        match_found = True\n    if match_found:\n        new_html = page_html[:match.end()] + '&mode={{ mode }}' +\\\n            page_html[match.end():]\n        return new_html\n    else:\n        raise ExperimentError(\"insert_mode_failed\")\n\n\n# Generic route\n# =============\n\n@app.route('/<path:path>')\ndef regularpage(path):\n    \"\"\"\n    Route not found by the other routes above. May point to a static template.\n    \"\"\"\n    return send_from_directory('templates', path)\n\n\ndef run_webserver():\n    \"\"\" Run web server \"\"\"\n    host = CONFIG.get('Server Parameters', 'host')\n    port = CONFIG.getint('Server Parameters', 'port')\n    print(f\"Serving on http://{host}:{port}\")\n    app.config['TEMPLATES_AUTO_RELOAD'] = True\n    app.jinja_env.auto_reload = True\n    app.run(debug=True, host=host, port=port)\n\n\nif __name__ == '__main__':\n    run_webserver()\n", "# -*- coding: utf-8 -*-\n\"\"\" This module tests the psiTurk suite.  \"\"\"\n\nfrom builtins import str\nfrom builtins import object\nimport os\nimport unittest\nimport psiturk\nimport json\nfrom faker import Faker\nimport pytest\nfrom importlib import reload  # Python 3.4+\n\nfake = Faker()  # Fake data generator\n\n\nclass FlaskTestClientProxy(object):\n    \"\"\"Spoof user agent (Chrome)\"\"\"\n\n    def __init__(self, app):\n        self.app = app\n\n    def __call__(self, environ, start_response):\n        environ['REMOTE_ADDR'] = environ.get('REMOTE_ADDR', fake.ipv4())\n        environ['HTTP_USER_AGENT'] = 'Mozilla/5.0 (Macintosh; Intel Mac OS X\\\n            10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1944.0\\\n            Safari/537.36'\n        return self.app(environ, start_response)\n\n\nclass BadFlaskTestClientProxy(object):\n    \"\"\"Spoof user agent (iPad)\"\"\"\n\n    def __init__(self, app):\n        self.app = app\n\n    def __call__(self, environ, start_response):\n        environ['REMOTE_ADDR'] = environ.get('REMOTE_ADDR', fake.ipv4())\n        environ['HTTP_USER_AGENT'] = 'Mozilla/5.0 (iPad; U; CPU OS 3_2 like \\\n            Mac OS X; en-us) AppleWebKit/531.21.10 (KHTML, like Gecko) \\\n            Version/4.0.4 Mobile/7B334b Safari/531.21.10'\n        return self.app(environ, start_response)\n\n\nclass PsiturkUnitTest(unittest.TestCase):\n\n    def setUp(self, case=None):\n        \"\"\"Build up fixtures\"\"\"\n        import psiturk.experiment\n        reload(psiturk.experiment)\n\n        psiturk.experiment.app.wsgi_app = FlaskTestClientProxy(\n            psiturk.experiment.app.wsgi_app)\n        self.app = psiturk.experiment.app.test_client()\n        self.config = psiturk.experiment.CONFIG\n\n        # Fake MTurk data\n        self.worker_id = fake.md5(raw_output=False)\n        self.hit_id = fake.md5(raw_output=False)\n        self.assignment_id = fake.md5(raw_output=False)\n\n    def tearDown(self):\n        \"\"\"Tear down fixtures\"\"\"\n        self.app = None\n\n    def set_config(self, section, field, value):\n        self.config.parent.set(self.config, section, field, str(value))\n\n\n@pytest.fixture()\ndef remove_file(tmpdir):\n    def do_it(filename):\n        import shutil\n        shutil.move(filename, './{}.xyz'.format(filename))\n\n    return do_it\n\n\n@pytest.fixture()\ndef remove_template(remove_file):\n    def do_it(template_name):\n        remove_file('templates/{}'.format(template_name))\n\n    return do_it\n\n\n@pytest.fixture()\ndef psiturk_test_client():\n    def do_it():\n        import psiturk.experiment\n        reload(psiturk.experiment)\n        psiturk.experiment.app.wsgi_app = FlaskTestClientProxy(\n            psiturk.experiment.app.wsgi_app)\n        return psiturk.experiment.app\n\n    yield do_it\n\n\ndef test_custom_get_condition_can_import(mocker, psiturk_test_client):\n    # pytest.set_trace()\n    # import psiturk.experiment\n    import sys\n    sys.path.append(os.getcwd())\n    import custom\n    reload(custom)\n    mocker.patch.object(custom, 'custom_get_condition', lambda mode: (9, 9), create=True)\n    app = psiturk_test_client()\n\n    from psiturk.experiment import get_condition\n    assert get_condition('') == (9, 9)\n\n\ndef test_custom_get_condition_not_necessary(tmpdir, mocker, psiturk_test_client):\n    import sys\n    sys.path.append(os.getcwd())\n    import custom\n    reload(custom)\n    app = psiturk_test_client()\n\n    from psiturk.experiment import get_condition\n    assert get_condition('') == (0, 0)\n\n\ndef test_missing_template_exception(edit_config_file, remove_template, psiturk_test_client):\n    remove_template('closepopup.html')\n    with pytest.raises(RuntimeError):\n        app = psiturk_test_client()\n\n\ndef test_notmissing_template(edit_config_file, remove_template, psiturk_test_client):\n    psiturk_test_client()\n\n\ndef test_does_not_die_if_no_custompy(remove_file, psiturk_test_client):\n    remove_file('custom.py')\n    psiturk_test_client()\n\n\ndef test_insert_mode(psiturk_test_client):\n    with open('templates/ad.html', 'r') as temp_file:\n        ad_string = temp_file.read()\n\n    from psiturk.experiment import insert_mode\n    insert_mode(ad_string)\n\n\nclass PsiTurkStandardTests(PsiturkUnitTest):\n\n    # Test experiment.py\n    # ==================\n\n    def test_default_page(self):\n        \"\"\"Test that root page works.\"\"\"\n        rv = self.app.get('/')\n        response = rv.get_data(as_text=True)\n        # print(os.getcwd())\n        # with open('server.log','r') as infile:\n        # print(file.read())\n        assert ('Welcome to psiTurk!' in response)\n\n    def test_exp_debug_no_url_vars(self):\n        \"\"\"Test that exp page throws Error #1003 with no url vars.\"\"\"\n        rv = self.app.get('/exp')\n        assert u'<b>Error</b>: 1003' in rv.get_data(as_text=True)\n\n    def test_ad_no_url_vars(self):\n        \"\"\"Test that ad page throws Error #1001 with no url vars.\"\"\"\n        rv = self.app.get('/ad')\n        assert u'<b>Error</b>: 1001' in rv.get_data(as_text=True)\n\n    def test_ad_with_all_urls(self):\n        \"\"\"Test that ad page throws Error #1003 with no url vars.\"\"\"\n        args = '&'.join([\n            'assignmentId=debug%s' % self.assignment_id,\n            'workerId=debug%s' % self.worker_id,\n            'hitId=debug%s' % self.hit_id,\n            'mode=sandbox'])\n        rv = self.app.get('/ad?%s' % args)\n        assert 'Thank you for accepting this HIT!' in rv.get_data(as_text=True)\n\n    @pytest.mark.skip('psiturk api server is slow for this test')\n    def test_exp_with_all_url_vars_not_registered_on_ad_server(self):\n        \"\"\"Test that exp page throws Error #1018 with all url vars but not registered.\"\"\"\n        self.set_config('Shell Parameters', 'use_psiturk_ad_server', 'true')\n        args = '&'.join([\n            'assignmentId=debug%s' % self.assignment_id,\n            'workerId=debug%s' % self.worker_id,\n            'hitId=debug%s' % self.hit_id,\n            'mode=sandbox'])\n        rv = self.app.get('/exp?%s' % args)\n        assert '<b>Error</b>: 1018' in rv.get_data(as_text=True)\n\n    def test_sync_put(self):\n        request = \"&\".join([\n            \"assignmentId=debug%s\" % self.assignment_id,\n            \"workerId=debug%s\" % self.worker_id,\n            \"hitId=debug%s\" % self.hit_id,\n            \"mode=debug\"])\n\n        # put the user in the database\n        rv = self.app.get(\"/exp?%s\" % request)\n\n        # try putting the sync, simulating a Backbone PUT payload\n        uniqueid = \"debug%s:debug%s\" % (self.worker_id, self.assignment_id)\n        payload = {\n            \"condition\": 5,\n            \"counterbalance\": 0,\n            \"assignmentId\": self.assignment_id,\n            \"workerId\": self.worker_id,\n            \"hitId\": self.hit_id,\n            \"currenttrial\": 2,\n            \"bonus\": 0,\n            \"data\": [\n                {\n                    \"uniqueid\": uniqueid,\n                    \"current_trial\": 0,\n                    \"dateTime\": 1564425799481,\n                    \"trialdata\": {\n                        \"phase\": \"postquestionnaire\",\n                        \"status\": \"begin\"\n                    }\n                }, {\n                    \"uniqueid\": uniqueid,\n                    \"current_trial\": 1,\n                    \"dateTime\": 1564425802158,\n                    \"trialdata\": {\n                        \"phase\": \"postquestionnaire\",\n                        \"status\": \"submit\"\n                    }\n                }\n            ],\n            \"questiondata\": {\n                \"engagement\": \"5\",\n                \"difficulty\": \"5\"\n            },\n            \"eventdata\": [\n                {\n                    \"eventtype\": \"initialized\",\n                    \"value\": '',\n                    \"timestamp\": 1564425799139,\n                    \"interval\": 0\n                }, {\n                    \"eventtype\": \"window_resize\",\n                    \"value\": [933, 708],\n                    \"timestamp\": 1564425799139,\n                    \"interval\": 0\n                }\n            ],\n            \"useragent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36\",\n            \"mode\": \"debug\"\n        }\n        rv = self.app.put('/sync/%s' % uniqueid, json=payload)\n        status = json.loads(rv.get_data(as_text=True)).get(\"status\", \"\")\n        assert status == \"user data saved\"\n\n    def test_sync_get(self):\n        self.assignment_id = \"debug%s\" % self.assignment_id\n        self.worker_id = \"debug%s\" % self.worker_id\n        self.hit_id = \"debug%s\" % self.hit_id\n\n        request = \"&\".join([\n            \"assignmentId=%s\" % self.assignment_id,\n            \"workerId=%s\" % self.worker_id,\n            \"hitId=%s\" % self.hit_id,\n            \"mode=\"])\n\n        # put the user in the database\n        rv = self.app.get(\"/exp?%s\" % request)\n\n        # save data with sync PUT\n        uniqueid = \"%s:%s\" % (self.worker_id, self.assignment_id)\n        condition = 0\n        counterbalance = 0\n        bonus = 0.0\n        payload = {\n            \"condition\": condition,\n            \"counterbalance\": counterbalance,\n            \"assignmentId\": self.assignment_id,\n            \"workerId\": self.worker_id,\n            \"hitId\": self.hit_id,\n            \"currenttrial\": 2,\n            \"bonus\": bonus,\n            \"data\": [\n                {\n                    \"uniqueid\": uniqueid,\n                    \"current_trial\": 0,\n                    \"dateTime\": 1564425799481,\n                    \"trialdata\": {\n                        \"phase\": \"postquestionnaire\",\n                        \"status\": \"begin\"\n                    }\n                },\n                {\n                    \"uniqueid\": uniqueid,\n                    \"current_trial\": 1,\n                    \"dateTime\": 1564425802158,\n                    \"trialdata\": {\n                        \"phase\": \"postquestionnaire\",\n                        \"status\": \"submit\"\n                    }\n                }\n            ],\n            \"questiondata\": {\n                \"engagement\": \"5\",\n                \"difficulty\": \"5\"\n            },\n            \"eventdata\": [\n                {\n                    \"eventtype\": \"initialized\",\n                    \"value\": '',\n                    \"timestamp\": 1564425799139,\n                    \"interval\": 0\n                },\n                {\n                    \"eventtype\": \"window_resize\",\n                    \"value\": [933, 708],\n                    \"timestamp\": 1564425799139,\n                    \"interval\": 0\n                }\n            ],\n            \"useragent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36\",\n            \"mode\": \"debug\"\n        }\n        rv = self.app.put('/sync/%s' % uniqueid, json=payload)\n\n        # get data with sync GET\n        uniqueid = \"%s:%s\" % (self.worker_id, self.assignment_id)\n        rv = self.app.get('/sync/%s' % uniqueid)\n\n        response = json.loads(rv.get_data(as_text=True))\n        assert response.get(\"assignmentId\", \"\") == \"%s\" % self.assignment_id\n        assert response.get(\"workerId\", \"\") == \"%s\" % self.worker_id\n        assert response.get(\"hitId\", \"\") == \"%s\" % self.hit_id\n        assert response.get(\"condition\", None) == condition\n        assert response.get(\"counterbalance\", None) == counterbalance\n        assert response.get(\"bonus\", None) == bonus\n\n    def test_favicon(self):\n        \"\"\"Test that favicon loads.\"\"\"\n        rv = self.app.get('/favicon.ico')\n        assert rv.status_code == 200\n\n    def test_complete_experiment(self):\n        \"\"\"Test that a participant can start and finish the experiment.\"\"\"\n        request = \"&\".join([\n            \"assignmentId=debug%s\" % self.assignment_id,\n            \"workerId=debug%s\" % self.worker_id,\n            \"hitId=debug%s\" % self.hit_id,\n            \"mode=debug\"])\n\n        # put the user in the database\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert rv.status_code == 200\n\n        # complete experiment\n        uniqueid = \"debug%s:debug%s\" % (self.worker_id, self.assignment_id)\n        mode = 'debug'\n        rv = self.app.get('/complete?uniqueId=%s&mode=%s' % (uniqueid, mode))\n        assert rv.status_code == 200\n\n    def test_repeat_experiment_fail(self):\n        \"\"\"Test that a participant cannot repeat the experiment.\"\"\"\n        request = \"&\".join([\n            \"assignmentId=%s\" % self.assignment_id,\n            \"workerId=%s\" % self.worker_id,\n            \"hitId=%s\" % self.hit_id,\n            \"mode=debug\"])\n\n        # put the user in the database\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert rv.status_code == 200\n\n        # save data with sync PUT\n        uniqueid = \"%s:%s\" % (self.worker_id, self.assignment_id)\n        payload = {\n            \"condition\": 5, \"counterbalance\": 0,\n            \"assignmentId\": self.assignment_id,\n            \"workerId\": self.worker_id,\n            \"hitId\": self.hit_id,\n            \"currenttrial\": 2,\n            \"bonus\": 0,\n            \"data\": [\n                {\n                    \"uniqueid\": uniqueid,\n                    \"current_trial\": 0,\n                    \"dateTime\": 1564425799481,\n                    \"trialdata\": {\n                        \"phase\": \"postquestionnaire\",\n                        \"status\": \"begin\"\n                    }\n                },\n                {\n                    \"uniqueid\": uniqueid,\n                    \"current_trial\": 1,\n                    \"dateTime\": 1564425802158,\n                    \"trialdata\": {\n                        \"phase\": \"postquestionnaire\",\n                        \"status\": \"submit\"\n                    }\n                }\n            ],\n            \"questiondata\": {\n                \"engagement\": \"5\",\n                \"difficulty\": \"5\"\n            },\n            \"eventdata\": [\n                {\n                    \"eventtype\": \"initialized\",\n                    \"value\": '',\n                    \"timestamp\": 1564425799139,\n                    \"interval\": 0\n                },\n                {\n                    \"eventtype\": \"window_resize\",\n                    \"value\": [933, 708],\n                    \"timestamp\": 1564425799139,\n                    \"interval\": 0\n                }\n            ],\n            \"useragent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36\",\n            \"mode\": \"debug\"\n        }\n        rv = self.app.put('/sync/%s' % uniqueid, json={\n            \"condition\": 5,\n            \"counterbalance\": 0,\n            \"assignmentId\": self.assignment_id,\n            \"workerId\": self.worker_id,\n            \"hitId\": self.hit_id,\n            \"currenttrial\": 2,\n            \"bonus\": 0, \"data\": [\n                {\n                    \"uniqueid\": uniqueid,\n                    \"current_trial\": 0,\n                    \"dateTime\": 1564425799481,\n                    \"trialdata\": {\n                        \"phase\": \"postquestionnaire\",\n                        \"status\": \"begin\"\n                    }\n                },\n                {\n                    \"uniqueid\": uniqueid,\n                    \"current_trial\": 1,\n                    \"dateTime\": 1564425802158,\n                    \"trialdata\": {\n                        \"phase\": \"postquestionnaire\",\n                        \"status\": \"submit\"\n                    }\n                }\n            ],\n            \"questiondata\": {\n                \"engagement\": \"5\",\n                \"difficulty\": \"5\"\n            },\n            \"eventdata\": [\n                {\n                    \"eventtype\": \"initialized\", \"value\": '',\n                    \"timestamp\": 1564425799139,\n                    \"interval\": 0\n                },\n                {\n                    \"eventtype\": \"window_resize\",\n                    \"value\": [933, 708],\n                    \"timestamp\": 1564425799139,\n                    \"interval\": 0\n                }\n            ],\n            \"useragent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36\",\n            \"mode\": \"debug\"\n        })\n        assert rv.status_code == 200\n\n        # complete experiment\n        mode = 'debug'\n        rv = self.app.get('/complete?uniqueId=%s&mode=%s' % (uniqueid, mode))\n        assert rv.status_code == 200\n\n        # choose new assignment and hit ids\n        self.assignment_id = fake.md5(raw_output=False)\n        self.hit_id = fake.md5(raw_output=False)\n        request = \"&\".join([\n            \"assignmentId=%s\" % self.assignment_id,\n            \"workerId=%s\" % self.worker_id,\n            \"hitId=%s\" % self.hit_id,\n            \"mode=debug\"])\n\n        # make sure they are blocked on the ad page\n        rv = self.app.get('/ad?%s' % request)\n        assert ': 1010' in rv.get_data(as_text=True)\n\n        # make sure they are blocked on the experiment page\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert ': 1010' in rv.get_data(as_text=True)\n\n    def test_repeat_experiment_success(self):\n        \"\"\"Test that a participant can repeat the experiment.\"\"\"\n        self.set_config(u'Task Parameters', u'allow_repeats', u'true')\n        request = \"&\".join([\n            \"assignmentId=%s\" % self.assignment_id,\n            \"workerId=%s\" % self.worker_id,\n            \"hitId=%s\" % self.hit_id,\n            \"mode=debug\"])\n\n        # put the user in the database\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert rv.status_code == 200\n\n        # save data with sync PUT\n        uniqueid = \"%s:%s\" % (self.worker_id, self.assignment_id)\n        payload = {\n            \"condition\": 5, \"counterbalance\": 0,\n            \"assignmentId\": self.assignment_id, \"workerId\": self.worker_id,\n            \"hitId\": self.hit_id, \"currenttrial\": 2, \"bonus\": 0, \"data\": [\n                {\"uniqueid\": uniqueid, \"current_trial\": 0, \"dateTime\": 1564425799481,\n                 \"trialdata\": {\"phase\": \"postquestionnaire\", \"status\": \"begin\"}},\n                {\"uniqueid\": uniqueid, \"current_trial\": 1, \"dateTime\": 1564425802158,\n                 \"trialdata\": {\"phase\": \"postquestionnaire\", \"status\": \"submit\"}}],\n            \"questiondata\": {\"engagement\": \"5\", \"difficulty\": \"5\"}, \"eventdata\": [\n                {\"eventtype\": \"initialized\", \"value\": '', \"timestamp\": 1564425799139,\n                 \"interval\": 0},\n                {\"eventtype\": \"window_resize\", \"value\": [933, 708], \"timestamp\": 1564425799139,\n                 \"interval\": 0}],\n            \"useragent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36\",\n            \"mode\": \"debug\"}\n        rv = self.app.put('/sync/%s' % uniqueid, json=payload)\n        assert rv.status_code == 200\n\n        # complete experiment\n        mode = 'debug'\n        rv = self.app.get('/complete?uniqueId=%s&mode=%s' % (uniqueid, mode))\n        assert rv.status_code == 200\n\n        # choose new assignment and hit ids\n        self.assignment_id = fake.md5(raw_output=False)\n        self.hit_id = fake.md5(raw_output=False)\n        request = \"&\".join([\n            \"assignmentId=%s\" % self.assignment_id,\n            \"workerId=%s\" % self.worker_id,\n            \"hitId=%s\" % self.hit_id,\n            \"mode=debug\"])\n\n        # make sure they are not blocked on the ad page\n        rv = self.app.get('/ad?%s' % request)\n        assert rv.status_code == 200\n        assert ': 1010' not in rv.get_data(as_text=True)\n\n        # make sure they are not blocked on the experiment page\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert rv.status_code == 200\n        assert ': 1010' not in rv.get_data(as_text=True)\n\n        # save data with sync PUT\n        uniqueid = \"%s:%s\" % (self.worker_id, self.assignment_id)\n        payload = payload = {\n            \"condition\": 5, \"counterbalance\": 0,\n            \"assignmentId\": self.assignment_id, \"workerId\": self.worker_id,\n            \"hitId\": self.hit_id, \"currenttrial\": 2, \"bonus\": 0, \"data\": [\n                {\"uniqueid\": uniqueid, \"current_trial\": 0, \"dateTime\": 1564425799481,\n                 \"trialdata\": {\"phase\": \"postquestionnaire\", \"status\": \"begin\"}},\n                {\"uniqueid\": uniqueid, \"current_trial\": 1, \"dateTime\": 1564425802158,\n                 \"trialdata\": {\"phase\": \"postquestionnaire\", \"status\": \"submit\"}}],\n            \"questiondata\": {\"engagement\": \"5\", \"difficulty\": \"5\"}, \"eventdata\": [\n                {\"eventtype\": \"initialized\", \"value\": '', \"timestamp\": 1564425799139,\n                 \"interval\": 0},\n                {\"eventtype\": \"window_resize\", \"value\": [933, 708], \"timestamp\": 1564425799139,\n                 \"interval\": 0}],\n            \"useragent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36\",\n            \"mode\": \"debug\"}\n        rv = self.app.put('/sync/%s' % uniqueid, json=payload)\n        assert rv.status_code == 200\n\n        # complete experiment\n        mode = 'debug'\n        rv = self.app.get('/complete?uniqueId=%s&mode=%s' % (uniqueid, mode))\n        assert rv.status_code == 200\n\n    def test_repeat_experiment_quit(self):\n        \"\"\"Test that a participant cannot restart the experiment.\"\"\"\n        request = \"&\".join([\n            \"assignmentId=%s\" % self.assignment_id,\n            \"workerId=%s\" % self.worker_id,\n            \"hitId=%s\" % self.hit_id,\n            \"mode=debug\"])\n\n        # put the user in the database\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert rv.status_code == 200\n\n        # put the in the experiment\n        uniqueid = \"%s:%s\" % (self.worker_id, self.assignment_id)\n        rv = self.app.post(\"/inexp\", data=dict(uniqueId=uniqueid))\n        assert rv.status_code == 200\n\n        # make sure they are blocked on the ad page\n        rv = self.app.get('/ad?%s' % request)\n        assert rv.status_code == 200\n        assert ': 1009' in rv.get_data(as_text=True)\n\n        # make sure they are blocked on the experiment page\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert rv.status_code == 200\n        assert ': 1008' in rv.get_data(as_text=True)\n\n        # have them quit the experiment\n        rv = self.app.post(\"/quitter\", data=dict(uniqueId=uniqueid))\n        assert rv.status_code == 200\n\n        # make sure they are blocked on the ad page\n        rv = self.app.get('/ad?%s' % request)\n        assert rv.status_code == 200\n        assert ': 1009' in rv.get_data(as_text=True)\n\n        # make sure they are blocked on the experiment page\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert rv.status_code == 200\n        assert ': 1008' in rv.get_data(as_text=True)\n\n    def test_repeat_experiment_quit_allow_repeats(self):\n        \"\"\"Test that a participant cannot restart the experiment, even when repeats are allowed.\"\"\"\n        self.set_config(u'Task Parameters', u'allow_repeats', u'true')\n        request = \"&\".join([\n            \"assignmentId=%s\" % self.assignment_id,\n            \"workerId=%s\" % self.worker_id,\n            \"hitId=%s\" % self.hit_id,\n            \"mode=debug\"])\n\n        # put the user in the database\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert rv.status_code == 200\n\n        # put the in the experiment\n        uniqueid = \"%s:%s\" % (self.worker_id, self.assignment_id)\n        rv = self.app.post(\"/inexp\", data=dict(uniqueId=uniqueid))\n        assert rv.status_code == 200\n\n        # make sure they are blocked on the ad page\n        rv = self.app.get('/ad?%s' % request)\n        assert rv.status_code == 200\n        assert ': 1009' in rv.get_data(as_text=True)\n\n        # make sure they are blocked on the experiment page\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert rv.status_code == 200\n        assert ': 1008' in rv.get_data(as_text=True)\n\n        # have them quit the experiment\n        rv = self.app.post(\"/quitter\", data=dict(uniqueId=uniqueid))\n        assert rv.status_code == 200\n\n        # make sure they are blocked on the ad page\n        rv = self.app.get('/ad?%s' % request)\n        assert rv.status_code == 200\n        assert ': 1009' in rv.get_data(as_text=True)\n\n        # make sure they are blocked on the experiment page\n        rv = self.app.get(\"/exp?%s\" % request)\n        assert rv.status_code == 200\n        assert ': 1008' in rv.get_data(as_text=True)\n\n\nclass BadUserAgent(PsiturkUnitTest):\n    \"\"\"Setup test blocked user agent (iPad/tablets)\"\"\"\n\n    def setUp(self):\n        \"\"\"Build up fixtures\"\"\"\n        import psiturk.experiment\n        reload(psiturk.experiment)\n\n        psiturk.experiment.app.wsgi_app = BadFlaskTestClientProxy(\n            psiturk.experiment.app.wsgi_app)\n        self.app = psiturk.experiment.app.test_client()\n\n        # Fake MTurk data\n        self.worker_id = fake.md5(raw_output=False)\n        self.hit_id = fake.md5(raw_output=False)\n        self.assignment_id = fake.md5(raw_output=False)\n\n    def test_ad_with_bad_user_agent(self):\n        \"\"\"Test that ad page throws Error when user agent is blocked.\"\"\"\n        rv = self.app.get(\n            '/ad' + '?assignmentId=debug' + self.assignment_id + '&workerId=debug' +\n            self.worker_id + '&hitId=debug' + self.hit_id + '&mode=sandbox'\n        )\n        assert '<b>Error</b>: 1014' in rv.get_data(as_text=True)\n\n\nclass PsiTurkTestPsiturkJS(PsiturkUnitTest):\n    \"\"\" Setup test for missing psiturk.js file. \"\"\"\n\n    def setUp(self):\n        \"\"\"Build up fixtures\"\"\"\n        self.PSITURK_JS_FILE = '../psiturk/psiturk_js/psiturk.js'\n        os.rename(self.PSITURK_JS_FILE, self.PSITURK_JS_FILE + '.bup')\n        import psiturk.experiment\n        reload(psiturk.experiment)\n\n        psiturk.experiment.app.wsgi_app = FlaskTestClientProxy(\n            psiturk.experiment.app.wsgi_app)\n        self.app = psiturk.experiment.app.test_client()\n\n    @pytest.mark.skip('soemthing about the testing env is making this not work well')\n    def test_psiturk_js_is_missing(self):\n        \"\"\" Test for missing psiturk.js \"\"\"\n        rv = self.app.get('static/js/psiturk.js')\n        assert 'file not found' in rv.get_data(as_text=True)\n\n    def tearDown(self):\n        \"\"\"Tear down fixtures\"\"\"\n        super(PsiTurkTestPsiturkJS, self).tearDown()\n        os.rename(self.PSITURK_JS_FILE + '.bup', self.PSITURK_JS_FILE)\n\n\nclass ExperimentErrorsTest(PsiturkUnitTest):\n\n    def test_experiment_errors(self):\n        \"\"\"Make sure every error has a description\"\"\"\n        error_cls = psiturk.experiment_errors.ExperimentError\n\n        for error_name in error_cls.experiment_errors:\n            assert error_name in error_cls.error_descriptions\n\n        for error_name in error_cls.error_descriptions:\n            assert error_name in error_cls.experiment_errors\n\n\nif __name__ == '__main__':\n    unittest.main()\n"], "filenames": ["psiturk/experiment.py", "tests/test_psiturk.py"], "buggy_code_start_loc": [383, 144], "buggy_code_end_loc": [744, 145], "fixing_code_start_loc": [383, 144], "fixing_code_end_loc": [746, 145], "type": "CWE-1336", "message": "A vulnerability has been found in NYUCCL psiTurk up to 3.2.0 and classified as critical. This vulnerability affects unknown code of the file psiturk/experiment.py. The manipulation of the argument mode leads to improper neutralization of special elements used in a template engine. The exploit has been disclosed to the public and may be used. Upgrading to version 3.2.1 is able to address this issue. The name of the patch is 47787e15cecd66f2aa87687bf852ae0194a4335f. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-219676.", "other": {"cve": {"id": "CVE-2021-4315", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-28T23:15:08.687", "lastModified": "2023-02-07T19:55:10.517", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability has been found in NYUCCL psiTurk up to 3.2.0 and classified as critical. This vulnerability affects unknown code of the file psiturk/experiment.py. The manipulation of the argument mode leads to improper neutralization of special elements used in a template engine. The exploit has been disclosed to the public and may be used. Upgrading to version 3.2.1 is able to address this issue. The name of the patch is 47787e15cecd66f2aa87687bf852ae0194a4335f. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-219676."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1336"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:psiturk:psiturk:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.1", "matchCriteriaId": "1E68E62D-79F6-4695-8E5A-19B48CA72304"}]}]}], "references": [{"url": "https://github.com/NYUCCL/psiTurk/commit/47787e15cecd66f2aa87687bf852ae0194a4335f", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/NYUCCL/psiTurk/pull/517", "source": "cna@vuldb.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/NYUCCL/psiTurk/releases/tag/v3.2.1", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.219676", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.219676", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/NYUCCL/psiTurk/commit/47787e15cecd66f2aa87687bf852ae0194a4335f"}}