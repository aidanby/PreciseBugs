{"buggy_code": ["/*\n * helper functions for vmalloc video4linux capture buffers\n *\n * The functions expect the hardware being able to scatter gatter\n * (i.e. the buffers are not linear in physical memory, but fragmented\n * into PAGE_SIZE chunks).  They also assume the driver does not need\n * to touch the video data.\n *\n * (c) 2007 Mauro Carvalho Chehab, <mchehab@infradead.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2\n */\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <asm/page.h>\n#include <asm/pgtable.h>\n\n#include <media/videobuf-vmalloc.h>\n\n#define MAGIC_DMABUF   0x17760309\n#define MAGIC_VMAL_MEM 0x18221223\n\n#define MAGIC_CHECK(is,should)\tif (unlikely((is) != (should))) \\\n\t{ printk(KERN_ERR \"magic mismatch: %x (expected %x)\\n\",is,should); BUG(); }\n\nstatic int debug = 0;\nmodule_param(debug, int, 0644);\n\nMODULE_DESCRIPTION(\"helper module to manage video4linux vmalloc buffers\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab <mchehab@infradead.org>\");\nMODULE_LICENSE(\"GPL\");\n\n#define dprintk(level, fmt, arg...)\tif (debug >= level) \\\n\tprintk(KERN_DEBUG \"vbuf-sg: \" fmt , ## arg)\n\n\n/***************************************************************************/\n\nstatic void\nvideobuf_vm_open(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\n\tdprintk(2,\"vm_open %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\n\tmap->count++;\n}\n\nstatic void\nvideobuf_vm_close(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tstruct videobuf_queue *q = map->q;\n\tint i;\n\n\tdprintk(2,\"vm_close %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\n\tmap->count--;\n\tif (0 == map->count) {\n\t\tdprintk(1,\"munmap %p q=%p\\n\",map,q);\n\t\tmutex_lock(&q->lock);\n\t\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\t\tif (NULL == q->bufs[i])\n\t\t\t\tcontinue;\n\n\t\t\tif (q->bufs[i]->map != map)\n\t\t\t\tcontinue;\n\n\t\t\tq->ops->buf_release(q,q->bufs[i]);\n\n\t\t\tq->bufs[i]->map   = NULL;\n\t\t\tq->bufs[i]->baddr = 0;\n\t\t}\n\t\tmutex_unlock(&q->lock);\n\t\tkfree(map);\n\t}\n\treturn;\n}\n\nstatic struct vm_operations_struct videobuf_vm_ops =\n{\n\t.open     = videobuf_vm_open,\n\t.close    = videobuf_vm_close,\n};\n\n/* ---------------------------------------------------------------------\n * vmalloc handlers for the generic methods\n */\n\n/* Allocated area consists on 3 parts:\n\tstruct video_buffer\n\tstruct <driver>_buffer (cx88_buffer, saa7134_buf, ...)\n\tstruct videobuf_pci_sg_memory\n */\n\nstatic void *__videobuf_alloc(size_t size)\n{\n\tstruct videbuf_vmalloc_memory *mem;\n\tstruct videobuf_buffer *vb;\n\n\tvb = kzalloc(size+sizeof(*mem),GFP_KERNEL);\n\n\tmem = vb->priv = ((char *)vb)+size;\n\tmem->magic=MAGIC_VMAL_MEM;\n\n\tdprintk(1,\"%s: allocated at %p(%ld+%ld) & %p(%ld)\\n\",\n\t\t__FUNCTION__,vb,(long)sizeof(*vb),(long)size-sizeof(*vb),\n\t\tmem,(long)sizeof(*mem));\n\n\treturn vb;\n}\n\nstatic int __videobuf_iolock (struct videobuf_queue* q,\n\t\t\t      struct videobuf_buffer *vb,\n\t\t\t      struct v4l2_framebuffer *fbuf)\n{\n\tint pages;\n\n\tstruct videbuf_vmalloc_memory *mem=vb->priv;\n\n\n\tBUG_ON(!mem);\n\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\tpages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;\n\n\t/* Currently, doesn't support V4L2_MEMORY_OVERLAY */\n\tif ((vb->memory != V4L2_MEMORY_MMAP) &&\n\t\t\t\t(vb->memory != V4L2_MEMORY_USERPTR) ) {\n\t\tprintk(KERN_ERR \"Method currently unsupported.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* FIXME: should be tested with kernel mmap mem */\n\tmem->vmalloc=vmalloc_user (PAGE_ALIGN(vb->size));\n\tif (NULL == mem->vmalloc) {\n\t\tprintk(KERN_ERR \"vmalloc (%d pages) failed\\n\",pages);\n\t\treturn -ENOMEM;\n\t}\n\n\tdprintk(1,\"vmalloc is at addr 0x%08lx, size=%d\\n\",\n\t\t\t\t(unsigned long)mem->vmalloc,\n\t\t\t\tpages << PAGE_SHIFT);\n\n\t/* It seems that some kernel versions need to do remap *after*\n\t   the mmap() call\n\t */\n\tif (mem->vma) {\n\t\tint retval=remap_vmalloc_range(mem->vma, mem->vmalloc,0);\n\t\tkfree(mem->vma);\n\t\tmem->vma=NULL;\n\t\tif (retval<0) {\n\t\t\tdprintk(1,\"mmap app bug: remap_vmalloc_range area %p error %d\\n\",\n\t\t\t\tmem->vmalloc,retval);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __videobuf_sync(struct videobuf_queue *q,\n\t\t\t   struct videobuf_buffer *buf)\n{\n\treturn 0;\n}\n\nstatic int __videobuf_mmap_free(struct videobuf_queue *q)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\tif (q->bufs[i]) {\n\t\t\tif (q->bufs[i]->map)\n\t\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __videobuf_mmap_mapper(struct videobuf_queue *q,\n\t\t\t struct vm_area_struct *vma)\n{\n\tstruct videbuf_vmalloc_memory *mem;\n\tstruct videobuf_mapping *map;\n\tunsigned int first;\n\tint retval;\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\t/* look for first buffer to map */\n\tfor (first = 0; first < VIDEO_MAX_FRAME; first++) {\n\t\tif (NULL == q->bufs[first])\n\t\t\tcontinue;\n\n\t\tif (V4L2_MEMORY_MMAP != q->bufs[first]->memory)\n\t\t\tcontinue;\n\t\tif (q->bufs[first]->boff == offset)\n\t\t\tbreak;\n\t}\n\tif (VIDEO_MAX_FRAME == first) {\n\t\tdprintk(1,\"mmap app bug: offset invalid [offset=0x%lx]\\n\",\n\t\t\t(vma->vm_pgoff << PAGE_SHIFT));\n\t\treturn -EINVAL;\n\t}\n\n\t/* create mapping + update buffer list */\n\tmap = q->bufs[first]->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);\n\tif (NULL == map)\n\t\treturn -ENOMEM;\n\n\tmap->start = vma->vm_start;\n\tmap->end   = vma->vm_end;\n\tmap->q     = q;\n\n\tq->bufs[first]->baddr = vma->vm_start;\n\n\tvma->vm_ops          = &videobuf_vm_ops;\n\tvma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;\n\tvma->vm_private_data = map;\n\n\tmem=q->bufs[first]->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\t/* Try to remap memory */\n\tretval=remap_vmalloc_range(vma, mem->vmalloc,0);\n\tif (retval<0) {\n\t\tdprintk(1,\"mmap: postponing remap_vmalloc_range\\n\");\n\n\t\tmem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);\n\t\tif (!mem->vma) {\n\t\t\tkfree(map);\n\t\t\tq->bufs[first]->map=NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(mem->vma,vma,sizeof(*vma));\n\t}\n\n\tdprintk(1,\"mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\\n\",\n\t\tmap,q,vma->vm_start,vma->vm_end,\n\t\t(long int) q->bufs[first]->bsize,\n\t\tvma->vm_pgoff,first);\n\n\tvideobuf_vm_open(vma);\n\n\treturn (0);\n}\n\nstatic int __videobuf_copy_to_user ( struct videobuf_queue *q,\n\t\t\t\tchar __user *data, size_t count,\n\t\t\t\tint nonblocking )\n{\n\tstruct videbuf_vmalloc_memory *mem=q->read_buf->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\tBUG_ON (!mem->vmalloc);\n\n\t/* copy to userspace */\n\tif (count > q->read_buf->size - q->read_off)\n\t\tcount = q->read_buf->size - q->read_off;\n\n\tif (copy_to_user(data, mem->vmalloc+q->read_off, count))\n\t\treturn -EFAULT;\n\n\treturn count;\n}\n\nstatic int __videobuf_copy_stream ( struct videobuf_queue *q,\n\t\t\t\tchar __user *data, size_t count, size_t pos,\n\t\t\t\tint vbihack, int nonblocking )\n{\n\tunsigned int  *fc;\n\tstruct videbuf_vmalloc_memory *mem=q->read_buf->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\tif (vbihack) {\n\t\t/* dirty, undocumented hack -- pass the frame counter\n\t\t\t* within the last four bytes of each vbi data block.\n\t\t\t* We need that one to maintain backward compatibility\n\t\t\t* to all vbi decoding software out there ... */\n\t\tfc  = (unsigned int*)mem->vmalloc;\n\t\tfc += (q->read_buf->size>>2) -1;\n\t\t*fc = q->read_buf->field_count >> 1;\n\t\tdprintk(1,\"vbihack: %d\\n\",*fc);\n\t}\n\n\t/* copy stuff using the common method */\n\tcount = __videobuf_copy_to_user (q,data,count,nonblocking);\n\n\tif ( (count==-EFAULT) && (0 == pos) )\n\t\treturn -EFAULT;\n\n\treturn count;\n}\n\nstatic struct videobuf_qtype_ops qops = {\n\t.magic        = MAGIC_QTYPE_OPS,\n\n\t.alloc        = __videobuf_alloc,\n\t.iolock       = __videobuf_iolock,\n\t.sync         = __videobuf_sync,\n\t.mmap_free    = __videobuf_mmap_free,\n\t.mmap_mapper  = __videobuf_mmap_mapper,\n\t.video_copy_to_user = __videobuf_copy_to_user,\n\t.copy_stream  = __videobuf_copy_stream,\n};\n\nvoid videobuf_queue_vmalloc_init(struct videobuf_queue* q,\n\t\t\t struct videobuf_queue_ops *ops,\n\t\t\t void *dev,\n\t\t\t spinlock_t *irqlock,\n\t\t\t enum v4l2_buf_type type,\n\t\t\t enum v4l2_field field,\n\t\t\t unsigned int msize,\n\t\t\t void *priv)\n{\n\tvideobuf_queue_core_init(q, ops, dev, irqlock, type, field, msize,\n\t\t\t\t priv, &qops);\n}\n\nEXPORT_SYMBOL_GPL(videobuf_queue_vmalloc_init);\n\nvoid *videobuf_to_vmalloc (struct videobuf_buffer *buf)\n{\n\tstruct videbuf_vmalloc_memory *mem=buf->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\treturn mem->vmalloc;\n}\nEXPORT_SYMBOL_GPL(videobuf_to_vmalloc);\n\nvoid videobuf_vmalloc_free (struct videobuf_buffer *buf)\n{\n\tstruct videbuf_vmalloc_memory *mem=buf->priv;\n\tBUG_ON (!mem);\n\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\tvfree(mem->vmalloc);\n\tmem->vmalloc=NULL;\n\n\treturn;\n}\nEXPORT_SYMBOL_GPL(videobuf_vmalloc_free);\n\n/*\n * Local variables:\n * c-basic-offset: 8\n * End:\n */\n"], "fixing_code": ["/*\n * helper functions for vmalloc video4linux capture buffers\n *\n * The functions expect the hardware being able to scatter gatter\n * (i.e. the buffers are not linear in physical memory, but fragmented\n * into PAGE_SIZE chunks).  They also assume the driver does not need\n * to touch the video data.\n *\n * (c) 2007 Mauro Carvalho Chehab, <mchehab@infradead.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2\n */\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <asm/page.h>\n#include <asm/pgtable.h>\n\n#include <media/videobuf-vmalloc.h>\n\n#define MAGIC_DMABUF   0x17760309\n#define MAGIC_VMAL_MEM 0x18221223\n\n#define MAGIC_CHECK(is,should)\tif (unlikely((is) != (should))) \\\n\t{ printk(KERN_ERR \"magic mismatch: %x (expected %x)\\n\",is,should); BUG(); }\n\nstatic int debug = 0;\nmodule_param(debug, int, 0644);\n\nMODULE_DESCRIPTION(\"helper module to manage video4linux vmalloc buffers\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab <mchehab@infradead.org>\");\nMODULE_LICENSE(\"GPL\");\n\n#define dprintk(level, fmt, arg...)\tif (debug >= level) \\\n\tprintk(KERN_DEBUG \"vbuf-sg: \" fmt , ## arg)\n\n\n/***************************************************************************/\n\nstatic void\nvideobuf_vm_open(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\n\tdprintk(2,\"vm_open %p [count=%u,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\n\tmap->count++;\n}\n\nstatic void\nvideobuf_vm_close(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tstruct videobuf_queue *q = map->q;\n\tint i;\n\n\tdprintk(2,\"vm_close %p [count=%u,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\n\tmap->count--;\n\tif (0 == map->count) {\n\t\tdprintk(1,\"munmap %p q=%p\\n\",map,q);\n\t\tmutex_lock(&q->lock);\n\t\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\t\tif (NULL == q->bufs[i])\n\t\t\t\tcontinue;\n\n\t\t\tif (q->bufs[i]->map != map)\n\t\t\t\tcontinue;\n\n\t\t\tq->ops->buf_release(q,q->bufs[i]);\n\n\t\t\tq->bufs[i]->map   = NULL;\n\t\t\tq->bufs[i]->baddr = 0;\n\t\t}\n\t\tmutex_unlock(&q->lock);\n\t\tkfree(map);\n\t}\n\treturn;\n}\n\nstatic struct vm_operations_struct videobuf_vm_ops =\n{\n\t.open     = videobuf_vm_open,\n\t.close    = videobuf_vm_close,\n};\n\n/* ---------------------------------------------------------------------\n * vmalloc handlers for the generic methods\n */\n\n/* Allocated area consists on 3 parts:\n\tstruct video_buffer\n\tstruct <driver>_buffer (cx88_buffer, saa7134_buf, ...)\n\tstruct videobuf_pci_sg_memory\n */\n\nstatic void *__videobuf_alloc(size_t size)\n{\n\tstruct videbuf_vmalloc_memory *mem;\n\tstruct videobuf_buffer *vb;\n\n\tvb = kzalloc(size+sizeof(*mem),GFP_KERNEL);\n\n\tmem = vb->priv = ((char *)vb)+size;\n\tmem->magic=MAGIC_VMAL_MEM;\n\n\tdprintk(1,\"%s: allocated at %p(%ld+%ld) & %p(%ld)\\n\",\n\t\t__FUNCTION__,vb,(long)sizeof(*vb),(long)size-sizeof(*vb),\n\t\tmem,(long)sizeof(*mem));\n\n\treturn vb;\n}\n\nstatic int __videobuf_iolock (struct videobuf_queue* q,\n\t\t\t      struct videobuf_buffer *vb,\n\t\t\t      struct v4l2_framebuffer *fbuf)\n{\n\tint pages;\n\n\tstruct videbuf_vmalloc_memory *mem=vb->priv;\n\n\n\tBUG_ON(!mem);\n\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\tpages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;\n\n\t/* Currently, doesn't support V4L2_MEMORY_OVERLAY */\n\tif ((vb->memory != V4L2_MEMORY_MMAP) &&\n\t\t\t\t(vb->memory != V4L2_MEMORY_USERPTR) ) {\n\t\tprintk(KERN_ERR \"Method currently unsupported.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* FIXME: should be tested with kernel mmap mem */\n\tmem->vmalloc=vmalloc_user (PAGE_ALIGN(vb->size));\n\tif (NULL == mem->vmalloc) {\n\t\tprintk(KERN_ERR \"vmalloc (%d pages) failed\\n\",pages);\n\t\treturn -ENOMEM;\n\t}\n\n\tdprintk(1,\"vmalloc is at addr 0x%08lx, size=%d\\n\",\n\t\t\t\t(unsigned long)mem->vmalloc,\n\t\t\t\tpages << PAGE_SHIFT);\n\n\t/* It seems that some kernel versions need to do remap *after*\n\t   the mmap() call\n\t */\n\tif (mem->vma) {\n\t\tint retval=remap_vmalloc_range(mem->vma, mem->vmalloc,0);\n\t\tkfree(mem->vma);\n\t\tmem->vma=NULL;\n\t\tif (retval<0) {\n\t\t\tdprintk(1,\"mmap app bug: remap_vmalloc_range area %p error %d\\n\",\n\t\t\t\tmem->vmalloc,retval);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __videobuf_sync(struct videobuf_queue *q,\n\t\t\t   struct videobuf_buffer *buf)\n{\n\treturn 0;\n}\n\nstatic int __videobuf_mmap_free(struct videobuf_queue *q)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\tif (q->bufs[i]) {\n\t\t\tif (q->bufs[i]->map)\n\t\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __videobuf_mmap_mapper(struct videobuf_queue *q,\n\t\t\t struct vm_area_struct *vma)\n{\n\tstruct videbuf_vmalloc_memory *mem;\n\tstruct videobuf_mapping *map;\n\tunsigned int first;\n\tint retval;\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\t/* look for first buffer to map */\n\tfor (first = 0; first < VIDEO_MAX_FRAME; first++) {\n\t\tif (NULL == q->bufs[first])\n\t\t\tcontinue;\n\n\t\tif (V4L2_MEMORY_MMAP != q->bufs[first]->memory)\n\t\t\tcontinue;\n\t\tif (q->bufs[first]->boff == offset)\n\t\t\tbreak;\n\t}\n\tif (VIDEO_MAX_FRAME == first) {\n\t\tdprintk(1,\"mmap app bug: offset invalid [offset=0x%lx]\\n\",\n\t\t\t(vma->vm_pgoff << PAGE_SHIFT));\n\t\treturn -EINVAL;\n\t}\n\n\t/* create mapping + update buffer list */\n\tmap = q->bufs[first]->map = kzalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);\n\tif (NULL == map)\n\t\treturn -ENOMEM;\n\n\tmap->start = vma->vm_start;\n\tmap->end   = vma->vm_end;\n\tmap->q     = q;\n\n\tq->bufs[first]->baddr = vma->vm_start;\n\n\tvma->vm_ops          = &videobuf_vm_ops;\n\tvma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;\n\tvma->vm_private_data = map;\n\n\tmem=q->bufs[first]->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\t/* Try to remap memory */\n\tretval=remap_vmalloc_range(vma, mem->vmalloc,0);\n\tif (retval<0) {\n\t\tdprintk(1,\"mmap: postponing remap_vmalloc_range\\n\");\n\n\t\tmem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);\n\t\tif (!mem->vma) {\n\t\t\tkfree(map);\n\t\t\tq->bufs[first]->map=NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(mem->vma,vma,sizeof(*vma));\n\t}\n\n\tdprintk(1,\"mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\\n\",\n\t\tmap,q,vma->vm_start,vma->vm_end,\n\t\t(long int) q->bufs[first]->bsize,\n\t\tvma->vm_pgoff,first);\n\n\tvideobuf_vm_open(vma);\n\n\treturn (0);\n}\n\nstatic int __videobuf_copy_to_user ( struct videobuf_queue *q,\n\t\t\t\tchar __user *data, size_t count,\n\t\t\t\tint nonblocking )\n{\n\tstruct videbuf_vmalloc_memory *mem=q->read_buf->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\tBUG_ON (!mem->vmalloc);\n\n\t/* copy to userspace */\n\tif (count > q->read_buf->size - q->read_off)\n\t\tcount = q->read_buf->size - q->read_off;\n\n\tif (copy_to_user(data, mem->vmalloc+q->read_off, count))\n\t\treturn -EFAULT;\n\n\treturn count;\n}\n\nstatic int __videobuf_copy_stream ( struct videobuf_queue *q,\n\t\t\t\tchar __user *data, size_t count, size_t pos,\n\t\t\t\tint vbihack, int nonblocking )\n{\n\tunsigned int  *fc;\n\tstruct videbuf_vmalloc_memory *mem=q->read_buf->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\tif (vbihack) {\n\t\t/* dirty, undocumented hack -- pass the frame counter\n\t\t\t* within the last four bytes of each vbi data block.\n\t\t\t* We need that one to maintain backward compatibility\n\t\t\t* to all vbi decoding software out there ... */\n\t\tfc  = (unsigned int*)mem->vmalloc;\n\t\tfc += (q->read_buf->size>>2) -1;\n\t\t*fc = q->read_buf->field_count >> 1;\n\t\tdprintk(1,\"vbihack: %d\\n\",*fc);\n\t}\n\n\t/* copy stuff using the common method */\n\tcount = __videobuf_copy_to_user (q,data,count,nonblocking);\n\n\tif ( (count==-EFAULT) && (0 == pos) )\n\t\treturn -EFAULT;\n\n\treturn count;\n}\n\nstatic struct videobuf_qtype_ops qops = {\n\t.magic        = MAGIC_QTYPE_OPS,\n\n\t.alloc        = __videobuf_alloc,\n\t.iolock       = __videobuf_iolock,\n\t.sync         = __videobuf_sync,\n\t.mmap_free    = __videobuf_mmap_free,\n\t.mmap_mapper  = __videobuf_mmap_mapper,\n\t.video_copy_to_user = __videobuf_copy_to_user,\n\t.copy_stream  = __videobuf_copy_stream,\n};\n\nvoid videobuf_queue_vmalloc_init(struct videobuf_queue* q,\n\t\t\t struct videobuf_queue_ops *ops,\n\t\t\t void *dev,\n\t\t\t spinlock_t *irqlock,\n\t\t\t enum v4l2_buf_type type,\n\t\t\t enum v4l2_field field,\n\t\t\t unsigned int msize,\n\t\t\t void *priv)\n{\n\tvideobuf_queue_core_init(q, ops, dev, irqlock, type, field, msize,\n\t\t\t\t priv, &qops);\n}\n\nEXPORT_SYMBOL_GPL(videobuf_queue_vmalloc_init);\n\nvoid *videobuf_to_vmalloc (struct videobuf_buffer *buf)\n{\n\tstruct videbuf_vmalloc_memory *mem=buf->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\treturn mem->vmalloc;\n}\nEXPORT_SYMBOL_GPL(videobuf_to_vmalloc);\n\nvoid videobuf_vmalloc_free (struct videobuf_buffer *buf)\n{\n\tstruct videbuf_vmalloc_memory *mem=buf->priv;\n\tBUG_ON (!mem);\n\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\tvfree(mem->vmalloc);\n\tmem->vmalloc=NULL;\n\n\treturn;\n}\nEXPORT_SYMBOL_GPL(videobuf_vmalloc_free);\n\n/*\n * Local variables:\n * c-basic-offset: 8\n * End:\n */\n"], "filenames": ["drivers/media/video/videobuf-vmalloc.c"], "buggy_code_start_loc": [54], "buggy_code_end_loc": [225], "fixing_code_start_loc": [54], "fixing_code_end_loc": [225], "type": "CWE-119", "message": "drivers/media/video/videobuf-vmalloc.c in the Linux kernel before 2.6.24 does not initialize videobuf_mapping data structures, which allows local users to trigger an incorrect count value and videobuf leak via unspecified vectors, a different vulnerability than CVE-2010-5321.", "other": {"cve": {"id": "CVE-2007-6761", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-24T06:59:00.163", "lastModified": "2017-04-27T19:13:06.870", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "drivers/media/video/videobuf-vmalloc.c in the Linux kernel before 2.6.24 does not initialize videobuf_mapping data structures, which allows local users to trigger an incorrect count value and videobuf leak via unspecified vectors, a different vulnerability than CVE-2010-5321."}, {"lang": "es", "value": "drivers/media/video/videobuf-vmalloc.c en el kernel de Linux en versiones anteriores a 2.6.24 no inicializa las estructuras de datos videobuf_mapping, lo que permite a usuarios locales desencadenar un valor de recuento incorrecto y una filtraci\u00f3n de videobuf a trav\u00e9s de vectores no especificados, una vulnerabilidad diferente a CVE-2010 -5321."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.23", "matchCriteriaId": "6FA8C05E-B944-46CF-9F21-9A5B9FF9A586"}]}]}], "references": [{"url": "http://www.linuxgrill.com/anonymous/kernel/v2.6/ChangeLog-2.6.24", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "http://www.securityfocus.com/bid/98001", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=827340", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=0b29669c065f60501e7289e1950fa2a618962358", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/0b29669c065f60501e7289e1950fa2a618962358", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/0b29669c065f60501e7289e1950fa2a618962358"}}