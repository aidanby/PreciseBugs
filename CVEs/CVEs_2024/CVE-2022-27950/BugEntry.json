{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * HID driver for ELO usb touchscreen 4000/4500\n *\n * Copyright (c) 2013 Jiri Slaby\n *\n * Data parsing taken from elousb driver by Vojtech Pavlik.\n */\n\n#include <linux/hid.h>\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/workqueue.h>\n\n#include \"hid-ids.h\"\n\n#define ELO_PERIODIC_READ_INTERVAL\tHZ\n#define ELO_SMARTSET_CMD_TIMEOUT\t2000 /* msec */\n\n/* Elo SmartSet commands */\n#define ELO_FLUSH_SMARTSET_RESPONSES\t0x02 /* Flush all pending smartset responses */\n#define ELO_SEND_SMARTSET_COMMAND\t0x05 /* Send a smartset command */\n#define ELO_GET_SMARTSET_RESPONSE\t0x06 /* Get a smartset response */\n#define ELO_DIAG\t\t\t0x64 /* Diagnostics command */\n#define ELO_SMARTSET_PACKET_SIZE\t8\n\nstruct elo_priv {\n\tstruct usb_device *usbdev;\n\tstruct delayed_work work;\n\tunsigned char buffer[ELO_SMARTSET_PACKET_SIZE];\n};\n\nstatic struct workqueue_struct *wq;\nstatic bool use_fw_quirk = true;\nmodule_param(use_fw_quirk, bool, S_IRUGO);\nMODULE_PARM_DESC(use_fw_quirk, \"Do periodic pokes for broken M firmwares (default = true)\");\n\nstatic int elo_input_configured(struct hid_device *hdev,\n\t\tstruct hid_input *hidinput)\n{\n\tstruct input_dev *input = hidinput->input;\n\n\t/*\n\t * ELO devices have one Button usage in GenDesk field, which makes\n\t * hid-input map it to BTN_LEFT; that confuses userspace, which then\n\t * considers the device to be a mouse/touchpad instead of touchscreen.\n\t */\n\tclear_bit(BTN_LEFT, input->keybit);\n\tset_bit(BTN_TOUCH, input->keybit);\n\tset_bit(ABS_PRESSURE, input->absbit);\n\tinput_set_abs_params(input, ABS_PRESSURE, 0, 256, 0, 0);\n\n\treturn 0;\n}\n\nstatic void elo_process_data(struct input_dev *input, const u8 *data, int size)\n{\n\tint press;\n\n\tinput_report_abs(input, ABS_X, (data[3] << 8) | data[2]);\n\tinput_report_abs(input, ABS_Y, (data[5] << 8) | data[4]);\n\n\tpress = 0;\n\tif (data[1] & 0x80)\n\t\tpress = (data[7] << 8) | data[6];\n\tinput_report_abs(input, ABS_PRESSURE, press);\n\n\tif (data[1] & 0x03) {\n\t\tinput_report_key(input, BTN_TOUCH, 1);\n\t\tinput_sync(input);\n\t}\n\n\tif (data[1] & 0x04)\n\t\tinput_report_key(input, BTN_TOUCH, 0);\n\n\tinput_sync(input);\n}\n\nstatic int elo_raw_event(struct hid_device *hdev, struct hid_report *report,\n\t u8 *data, int size)\n{\n\tstruct hid_input *hidinput;\n\n\tif (!(hdev->claimed & HID_CLAIMED_INPUT) || list_empty(&hdev->inputs))\n\t\treturn 0;\n\n\thidinput = list_first_entry(&hdev->inputs, struct hid_input, list);\n\n\tswitch (report->id) {\n\tcase 0:\n\t\tif (data[0] == 'T') {\t/* Mandatory ELO packet marker */\n\t\t\telo_process_data(hidinput->input, data, size);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tdefault:\t/* unknown report */\n\t\t/* Unknown report type; pass upstream */\n\t\thid_info(hdev, \"unknown report type %d\\n\", report->id);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int elo_smartset_send_get(struct usb_device *dev, u8 command,\n\t\tvoid *data)\n{\n\tunsigned int pipe;\n\tu8 dir;\n\n\tif (command == ELO_SEND_SMARTSET_COMMAND) {\n\t\tpipe = usb_sndctrlpipe(dev, 0);\n\t\tdir = USB_DIR_OUT;\n\t} else if (command == ELO_GET_SMARTSET_RESPONSE) {\n\t\tpipe = usb_rcvctrlpipe(dev, 0);\n\t\tdir = USB_DIR_IN;\n\t} else\n\t\treturn -EINVAL;\n\n\treturn usb_control_msg(dev, pipe, command,\n\t\t\tdir | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, 0, data, ELO_SMARTSET_PACKET_SIZE,\n\t\t\tELO_SMARTSET_CMD_TIMEOUT);\n}\n\nstatic int elo_flush_smartset_responses(struct usb_device *dev)\n{\n\treturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\tELO_FLUSH_SMARTSET_RESPONSES,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, 0, NULL, 0, USB_CTRL_SET_TIMEOUT);\n}\n\nstatic void elo_work(struct work_struct *work)\n{\n\tstruct elo_priv *priv = container_of(work, struct elo_priv, work.work);\n\tstruct usb_device *dev = priv->usbdev;\n\tunsigned char *buffer = priv->buffer;\n\tint ret;\n\n\tret = elo_flush_smartset_responses(dev);\n\tif (ret < 0) {\n\t\tdev_err(&dev->dev, \"initial FLUSH_SMARTSET_RESPONSES failed, error %d\\n\",\n\t\t\t\tret);\n\t\tgoto fail;\n\t}\n\n\t/* send Diagnostics command */\n\t*buffer = ELO_DIAG;\n\tret = elo_smartset_send_get(dev, ELO_SEND_SMARTSET_COMMAND, buffer);\n\tif (ret < 0) {\n\t\tdev_err(&dev->dev, \"send Diagnostics Command failed, error %d\\n\",\n\t\t\t\tret);\n\t\tgoto fail;\n\t}\n\n\t/* get the result */\n\tret = elo_smartset_send_get(dev, ELO_GET_SMARTSET_RESPONSE, buffer);\n\tif (ret < 0) {\n\t\tdev_err(&dev->dev, \"get Diagnostics Command response failed, error %d\\n\",\n\t\t\t\tret);\n\t\tgoto fail;\n\t}\n\n\t/* read the ack */\n\tif (*buffer != 'A') {\n\t\tret = elo_smartset_send_get(dev, ELO_GET_SMARTSET_RESPONSE,\n\t\t\t\tbuffer);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&dev->dev, \"get acknowledge response failed, error %d\\n\",\n\t\t\t\t\tret);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\nfail:\n\tret = elo_flush_smartset_responses(dev);\n\tif (ret < 0)\n\t\tdev_err(&dev->dev, \"final FLUSH_SMARTSET_RESPONSES failed, error %d\\n\",\n\t\t\t\tret);\n\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n}\n\n/*\n * Not all Elo devices need the periodic HID descriptor reads.\n * Only firmware version M needs this.\n */\nstatic bool elo_broken_firmware(struct usb_device *dev)\n{\n\tstruct usb_device *hub = dev->parent;\n\tstruct usb_device *child = NULL;\n\tu16 fw_lvl = le16_to_cpu(dev->descriptor.bcdDevice);\n\tu16 child_vid, child_pid;\n\tint i;\n    \n\tif (!use_fw_quirk)\n\t\treturn false;\n\tif (fw_lvl != 0x10d)\n\t\treturn false;\n\n\t/* iterate sibling devices of the touch controller */\n\tusb_hub_for_each_child(hub, i, child) {\n\t\tchild_vid = le16_to_cpu(child->descriptor.idVendor);\n\t\tchild_pid = le16_to_cpu(child->descriptor.idProduct);\n\n\t\t/*\n\t\t * If one of the devices below is present attached as a sibling of \n\t\t * the touch controller then  this is a newer IBM 4820 monitor that \n\t\t * does not need the IBM-requested workaround if fw level is\n\t\t * 0x010d - aka 'M'.\n\t\t * No other HW can have this combination.\n\t\t */\n\t\tif (child_vid==0x04b3) {\n\t\t\tswitch (child_pid) {\n\t\t\tcase 0x4676: /* 4820 21x Video */\n\t\t\tcase 0x4677: /* 4820 51x Video */\n\t\t\tcase 0x4678: /* 4820 2Lx Video */\n\t\t\tcase 0x4679: /* 4820 5Lx Video */\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct elo_priv *priv;\n\tint ret;\n\tstruct usb_device *udev;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tINIT_DELAYED_WORK(&priv->work, elo_work);\n\tudev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\n\tpriv->usbdev = usb_get_dev(udev);\n\n\thid_set_drvdata(hdev, priv);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (elo_broken_firmware(priv->usbdev)) {\n\t\thid_info(hdev, \"broken firmware found, installing workaround\\n\");\n\t\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n\t}\n\n\treturn 0;\nerr_free:\n\tkfree(priv);\n\treturn ret;\n}\n\nstatic void elo_remove(struct hid_device *hdev)\n{\n\tstruct elo_priv *priv = hid_get_drvdata(hdev);\n\n\tusb_put_dev(priv->usbdev);\n\n\thid_hw_stop(hdev);\n\tcancel_delayed_work_sync(&priv->work);\n\tkfree(priv);\n}\n\nstatic const struct hid_device_id elo_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ELO, 0x0009), },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ELO, 0x0030), },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, elo_devices);\n\nstatic struct hid_driver elo_driver = {\n\t.name = \"elo\",\n\t.id_table = elo_devices,\n\t.probe = elo_probe,\n\t.remove = elo_remove,\n\t.raw_event = elo_raw_event,\n\t.input_configured = elo_input_configured,\n};\n\nstatic int __init elo_driver_init(void)\n{\n\tint ret;\n\n\twq = create_singlethread_workqueue(\"elousb\");\n\tif (!wq)\n\t\treturn -ENOMEM;\n\n\tret = hid_register_driver(&elo_driver);\n\tif (ret)\n\t\tdestroy_workqueue(wq);\n\n\treturn ret;\n}\nmodule_init(elo_driver_init);\n\nstatic void __exit elo_driver_exit(void)\n{\n\thid_unregister_driver(&elo_driver);\n\tdestroy_workqueue(wq);\n}\nmodule_exit(elo_driver_exit);\n\nMODULE_AUTHOR(\"Jiri Slaby <jslaby@suse.cz>\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * HID driver for ELO usb touchscreen 4000/4500\n *\n * Copyright (c) 2013 Jiri Slaby\n *\n * Data parsing taken from elousb driver by Vojtech Pavlik.\n */\n\n#include <linux/hid.h>\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/workqueue.h>\n\n#include \"hid-ids.h\"\n\n#define ELO_PERIODIC_READ_INTERVAL\tHZ\n#define ELO_SMARTSET_CMD_TIMEOUT\t2000 /* msec */\n\n/* Elo SmartSet commands */\n#define ELO_FLUSH_SMARTSET_RESPONSES\t0x02 /* Flush all pending smartset responses */\n#define ELO_SEND_SMARTSET_COMMAND\t0x05 /* Send a smartset command */\n#define ELO_GET_SMARTSET_RESPONSE\t0x06 /* Get a smartset response */\n#define ELO_DIAG\t\t\t0x64 /* Diagnostics command */\n#define ELO_SMARTSET_PACKET_SIZE\t8\n\nstruct elo_priv {\n\tstruct usb_device *usbdev;\n\tstruct delayed_work work;\n\tunsigned char buffer[ELO_SMARTSET_PACKET_SIZE];\n};\n\nstatic struct workqueue_struct *wq;\nstatic bool use_fw_quirk = true;\nmodule_param(use_fw_quirk, bool, S_IRUGO);\nMODULE_PARM_DESC(use_fw_quirk, \"Do periodic pokes for broken M firmwares (default = true)\");\n\nstatic int elo_input_configured(struct hid_device *hdev,\n\t\tstruct hid_input *hidinput)\n{\n\tstruct input_dev *input = hidinput->input;\n\n\t/*\n\t * ELO devices have one Button usage in GenDesk field, which makes\n\t * hid-input map it to BTN_LEFT; that confuses userspace, which then\n\t * considers the device to be a mouse/touchpad instead of touchscreen.\n\t */\n\tclear_bit(BTN_LEFT, input->keybit);\n\tset_bit(BTN_TOUCH, input->keybit);\n\tset_bit(ABS_PRESSURE, input->absbit);\n\tinput_set_abs_params(input, ABS_PRESSURE, 0, 256, 0, 0);\n\n\treturn 0;\n}\n\nstatic void elo_process_data(struct input_dev *input, const u8 *data, int size)\n{\n\tint press;\n\n\tinput_report_abs(input, ABS_X, (data[3] << 8) | data[2]);\n\tinput_report_abs(input, ABS_Y, (data[5] << 8) | data[4]);\n\n\tpress = 0;\n\tif (data[1] & 0x80)\n\t\tpress = (data[7] << 8) | data[6];\n\tinput_report_abs(input, ABS_PRESSURE, press);\n\n\tif (data[1] & 0x03) {\n\t\tinput_report_key(input, BTN_TOUCH, 1);\n\t\tinput_sync(input);\n\t}\n\n\tif (data[1] & 0x04)\n\t\tinput_report_key(input, BTN_TOUCH, 0);\n\n\tinput_sync(input);\n}\n\nstatic int elo_raw_event(struct hid_device *hdev, struct hid_report *report,\n\t u8 *data, int size)\n{\n\tstruct hid_input *hidinput;\n\n\tif (!(hdev->claimed & HID_CLAIMED_INPUT) || list_empty(&hdev->inputs))\n\t\treturn 0;\n\n\thidinput = list_first_entry(&hdev->inputs, struct hid_input, list);\n\n\tswitch (report->id) {\n\tcase 0:\n\t\tif (data[0] == 'T') {\t/* Mandatory ELO packet marker */\n\t\t\telo_process_data(hidinput->input, data, size);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tdefault:\t/* unknown report */\n\t\t/* Unknown report type; pass upstream */\n\t\thid_info(hdev, \"unknown report type %d\\n\", report->id);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int elo_smartset_send_get(struct usb_device *dev, u8 command,\n\t\tvoid *data)\n{\n\tunsigned int pipe;\n\tu8 dir;\n\n\tif (command == ELO_SEND_SMARTSET_COMMAND) {\n\t\tpipe = usb_sndctrlpipe(dev, 0);\n\t\tdir = USB_DIR_OUT;\n\t} else if (command == ELO_GET_SMARTSET_RESPONSE) {\n\t\tpipe = usb_rcvctrlpipe(dev, 0);\n\t\tdir = USB_DIR_IN;\n\t} else\n\t\treturn -EINVAL;\n\n\treturn usb_control_msg(dev, pipe, command,\n\t\t\tdir | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, 0, data, ELO_SMARTSET_PACKET_SIZE,\n\t\t\tELO_SMARTSET_CMD_TIMEOUT);\n}\n\nstatic int elo_flush_smartset_responses(struct usb_device *dev)\n{\n\treturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\tELO_FLUSH_SMARTSET_RESPONSES,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, 0, NULL, 0, USB_CTRL_SET_TIMEOUT);\n}\n\nstatic void elo_work(struct work_struct *work)\n{\n\tstruct elo_priv *priv = container_of(work, struct elo_priv, work.work);\n\tstruct usb_device *dev = priv->usbdev;\n\tunsigned char *buffer = priv->buffer;\n\tint ret;\n\n\tret = elo_flush_smartset_responses(dev);\n\tif (ret < 0) {\n\t\tdev_err(&dev->dev, \"initial FLUSH_SMARTSET_RESPONSES failed, error %d\\n\",\n\t\t\t\tret);\n\t\tgoto fail;\n\t}\n\n\t/* send Diagnostics command */\n\t*buffer = ELO_DIAG;\n\tret = elo_smartset_send_get(dev, ELO_SEND_SMARTSET_COMMAND, buffer);\n\tif (ret < 0) {\n\t\tdev_err(&dev->dev, \"send Diagnostics Command failed, error %d\\n\",\n\t\t\t\tret);\n\t\tgoto fail;\n\t}\n\n\t/* get the result */\n\tret = elo_smartset_send_get(dev, ELO_GET_SMARTSET_RESPONSE, buffer);\n\tif (ret < 0) {\n\t\tdev_err(&dev->dev, \"get Diagnostics Command response failed, error %d\\n\",\n\t\t\t\tret);\n\t\tgoto fail;\n\t}\n\n\t/* read the ack */\n\tif (*buffer != 'A') {\n\t\tret = elo_smartset_send_get(dev, ELO_GET_SMARTSET_RESPONSE,\n\t\t\t\tbuffer);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&dev->dev, \"get acknowledge response failed, error %d\\n\",\n\t\t\t\t\tret);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\nfail:\n\tret = elo_flush_smartset_responses(dev);\n\tif (ret < 0)\n\t\tdev_err(&dev->dev, \"final FLUSH_SMARTSET_RESPONSES failed, error %d\\n\",\n\t\t\t\tret);\n\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n}\n\n/*\n * Not all Elo devices need the periodic HID descriptor reads.\n * Only firmware version M needs this.\n */\nstatic bool elo_broken_firmware(struct usb_device *dev)\n{\n\tstruct usb_device *hub = dev->parent;\n\tstruct usb_device *child = NULL;\n\tu16 fw_lvl = le16_to_cpu(dev->descriptor.bcdDevice);\n\tu16 child_vid, child_pid;\n\tint i;\n    \n\tif (!use_fw_quirk)\n\t\treturn false;\n\tif (fw_lvl != 0x10d)\n\t\treturn false;\n\n\t/* iterate sibling devices of the touch controller */\n\tusb_hub_for_each_child(hub, i, child) {\n\t\tchild_vid = le16_to_cpu(child->descriptor.idVendor);\n\t\tchild_pid = le16_to_cpu(child->descriptor.idProduct);\n\n\t\t/*\n\t\t * If one of the devices below is present attached as a sibling of \n\t\t * the touch controller then  this is a newer IBM 4820 monitor that \n\t\t * does not need the IBM-requested workaround if fw level is\n\t\t * 0x010d - aka 'M'.\n\t\t * No other HW can have this combination.\n\t\t */\n\t\tif (child_vid==0x04b3) {\n\t\t\tswitch (child_pid) {\n\t\t\tcase 0x4676: /* 4820 21x Video */\n\t\t\tcase 0x4677: /* 4820 51x Video */\n\t\t\tcase 0x4678: /* 4820 2Lx Video */\n\t\t\tcase 0x4679: /* 4820 5Lx Video */\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct elo_priv *priv;\n\tint ret;\n\tstruct usb_device *udev;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tINIT_DELAYED_WORK(&priv->work, elo_work);\n\tudev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\n\tpriv->usbdev = usb_get_dev(udev);\n\n\thid_set_drvdata(hdev, priv);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (elo_broken_firmware(priv->usbdev)) {\n\t\thid_info(hdev, \"broken firmware found, installing workaround\\n\");\n\t\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n\t}\n\n\treturn 0;\nerr_free:\n\tusb_put_dev(udev);\n\tkfree(priv);\n\treturn ret;\n}\n\nstatic void elo_remove(struct hid_device *hdev)\n{\n\tstruct elo_priv *priv = hid_get_drvdata(hdev);\n\n\tusb_put_dev(priv->usbdev);\n\n\thid_hw_stop(hdev);\n\tcancel_delayed_work_sync(&priv->work);\n\tkfree(priv);\n}\n\nstatic const struct hid_device_id elo_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ELO, 0x0009), },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ELO, 0x0030), },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, elo_devices);\n\nstatic struct hid_driver elo_driver = {\n\t.name = \"elo\",\n\t.id_table = elo_devices,\n\t.probe = elo_probe,\n\t.remove = elo_remove,\n\t.raw_event = elo_raw_event,\n\t.input_configured = elo_input_configured,\n};\n\nstatic int __init elo_driver_init(void)\n{\n\tint ret;\n\n\twq = create_singlethread_workqueue(\"elousb\");\n\tif (!wq)\n\t\treturn -ENOMEM;\n\n\tret = hid_register_driver(&elo_driver);\n\tif (ret)\n\t\tdestroy_workqueue(wq);\n\n\treturn ret;\n}\nmodule_init(elo_driver_init);\n\nstatic void __exit elo_driver_exit(void)\n{\n\thid_unregister_driver(&elo_driver);\n\tdestroy_workqueue(wq);\n}\nmodule_exit(elo_driver_exit);\n\nMODULE_AUTHOR(\"Jiri Slaby <jslaby@suse.cz>\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/hid/hid-elo.c"], "buggy_code_start_loc": [264], "buggy_code_end_loc": [264], "fixing_code_start_loc": [265], "fixing_code_end_loc": [266], "type": "CWE-401", "message": "In drivers/hid/hid-elo.c in the Linux kernel before 5.16.11, a memory leak exists for a certain hid_parse error condition.", "other": {"cve": {"id": "CVE-2022-27950", "sourceIdentifier": "cve@mitre.org", "published": "2022-03-28T04:15:16.957", "lastModified": "2022-04-05T13:08:56.440", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In drivers/hid/hid-elo.c in the Linux kernel before 5.16.11, a memory leak exists for a certain hid_parse error condition."}, {"lang": "es", "value": "En el archivo drivers/hid/hid-elo.c en el kernel de Linux versiones anteriores a 5.16.11, se presenta una p\u00e9rdida de memoria para una determinada condici\u00f3n de error hid_parse"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.16.11", "matchCriteriaId": "39C8CB1A-21A4-4CCE-B9A5-EAD87C374974"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.16.11", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=817b8b9c5396d2b2d92311b46719aad5d3339dbe", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/817b8b9c5396d2b2d92311b46719aad5d3339dbe", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2022/03/13/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/817b8b9c5396d2b2d92311b46719aad5d3339dbe"}}