{"buggy_code": ["/*\n * Copyright 1999-2017 Alibaba Group.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.fastjson.parser;\n\nimport java.io.*;\nimport java.lang.ref.SoftReference;\nimport java.lang.ref.WeakReference;\nimport java.lang.reflect.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.Inet4Address;\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.security.AccessControlException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.atomic.AtomicLongArray;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.regex.Pattern;\n\nimport com.alibaba.fastjson.*;\nimport com.alibaba.fastjson.annotation.JSONCreator;\nimport com.alibaba.fastjson.annotation.JSONField;\nimport com.alibaba.fastjson.annotation.JSONType;\nimport com.alibaba.fastjson.asm.ClassReader;\nimport com.alibaba.fastjson.asm.TypeCollector;\nimport com.alibaba.fastjson.parser.deserializer.*;\nimport com.alibaba.fastjson.serializer.*;\nimport com.alibaba.fastjson.spi.Module;\nimport com.alibaba.fastjson.support.moneta.MonetaCodec;\nimport com.alibaba.fastjson.util.*;\nimport com.alibaba.fastjson.util.IdentityHashMap;\nimport com.alibaba.fastjson.util.ServiceLoader;\n\nimport javax.xml.datatype.XMLGregorianCalendar;\n\nimport static com.alibaba.fastjson.util.TypeUtils.fnv1a_64_magic_hashcode;\nimport static com.alibaba.fastjson.util.TypeUtils.fnv1a_64_magic_prime;\n\n/**\n * @author wenshao[szujobs@hotmail.com]\n */\npublic class ParserConfig {\n\n    public static final String    DENY_PROPERTY_INTERNAL    = \"fastjson.parser.deny.internal\";\n    public static final String    DENY_PROPERTY             = \"fastjson.parser.deny\";\n    public static final String    AUTOTYPE_ACCEPT           = \"fastjson.parser.autoTypeAccept\";\n    public static final String    AUTOTYPE_SUPPORT_PROPERTY = \"fastjson.parser.autoTypeSupport\";\n    public static final String    SAFE_MODE_PROPERTY        = \"fastjson.parser.safeMode\";\n\n    public static  final String[] DENYS_INTERNAL;\n    public static  final String[] DENYS;\n    private static final String[] AUTO_TYPE_ACCEPT_LIST;\n    public static  final boolean  AUTO_SUPPORT;\n    public static  final boolean  SAFE_MODE;\n    private static final long[]   INTERNAL_WHITELIST_HASHCODES;\n\n    static  {\n        {\n            String property = IOUtils.getStringProperty(DENY_PROPERTY_INTERNAL);\n            DENYS_INTERNAL = splitItemsFormProperty(property);\n        }\n        {\n            String property = IOUtils.getStringProperty(DENY_PROPERTY);\n            DENYS = splitItemsFormProperty(property);\n        }\n        {\n            String property = IOUtils.getStringProperty(AUTOTYPE_SUPPORT_PROPERTY);\n            AUTO_SUPPORT = \"true\".equals(property);\n        }\n        {\n            String property = IOUtils.getStringProperty(SAFE_MODE_PROPERTY);\n            SAFE_MODE = \"true\".equals(property);\n        }\n        {\n            String property = IOUtils.getStringProperty(AUTOTYPE_ACCEPT);\n            String[] items = splitItemsFormProperty(property);\n            if (items == null) {\n                items = new String[0];\n            }\n            AUTO_TYPE_ACCEPT_LIST = items;\n        }\n\n        INTERNAL_WHITELIST_HASHCODES = new long[] {\n                0x82E8E13016B73F9EL,\n                0x863D2DD1E82B9ED9L,\n                0x8B2081CB3A50BD44L,\n                0x90003416F28ACD89L,\n                0x92F252C398C02946L,\n                0x9E404E583F254FD4L,\n                0x9F2E20FB6049A371L,\n                0xA8AAA929446FFCE4L,\n                0xAB9B8D073948CA9DL,\n                0xAFCB539973CEA3F7L,\n                0xB5114C70135C4538L,\n                0xC0FE32B8DC897DE9L,\n                0xC59AA84D9A94C640L,\n                0xC92D8F9129AF339BL,\n                0xCC720543DC5E7090L,\n                0xD0E71A6E155603C1L,\n                0xD11D2A941337A7BCL,\n                0xDB7BFFC197369352L,\n                0xDC9583F0087CC2C7L,\n                0xDDAAA11FECA77B5EL,\n                0xE08EE874A26F5EAFL,\n                0xE794F5F7DCD3AC85L,\n                0xEB7D4786C473368DL,\n                0xF4AA683928027CDAL,\n                0xF8C7EF9B13231FB6L,\n                0xD45D6F8C9017FAL,\n                0x6B949CE6C2FE009L,\n                0x76566C052E83815L,\n                0x9DF9341F0C76702L,\n                0xB81BA299273D4E6L,\n                0xD4788669A13AE74L,\n                0x111D12921C5466DAL,\n                0x178B0E2DC3AE9FE5L,\n                0x19DCAF4ADC37D6D4L,\n                0x1F10A70EE4065963L,\n                0x21082DFBF63FBCC1L,\n                0x24AE2D07FB5D7497L,\n                0x26C5D923AF21E2E1L,\n                0x34CC8E52316FA0CBL,\n                0x3F64BC3933A6A2DFL,\n                0x42646E60EC7E5189L,\n                0x44D57A1B1EF53451L,\n                0x4A39C6C7ACB6AA18L,\n                0x4BB3C59964A2FC50L,\n                0x4F0C3688E8A18F9FL,\n                0x5449EC9B0280B9EFL,\n                0x54DC66A59269BAE1L,\n                0x552D9FB02FFC9DEFL,\n                0x557F642131553498L,\n                0x604D6657082C1EE9L,\n                0x61D10AF54471E5DEL,\n                0x64DC636F343516DCL,\n                0x73A0BE903F2BCBF4L,\n                0x73FBA1E41C4C3553L,\n                0x7B606F16A261E1E6L,\n                0x7F36112F218143B6L,\n                0x7FE2B8E675DA0CEFL\n        };\n    }\n\n    public static ParserConfig getGlobalInstance() {\n        return global;\n    }\n    public static ParserConfig                              global                = new ParserConfig();\n\n    private final IdentityHashMap<Type, ObjectDeserializer> deserializers         = new IdentityHashMap<Type, ObjectDeserializer>();\n    private final IdentityHashMap<Type, IdentityHashMap<Type, ObjectDeserializer>> mixInDeserializers = new IdentityHashMap<Type, IdentityHashMap<Type, ObjectDeserializer>>(16);\n    private final ConcurrentMap<String,Class<?>>            typeMapping           = new ConcurrentHashMap<String,Class<?>>(16, 0.75f, 1);\n\n    private boolean                                         asmEnable             = !ASMUtils.IS_ANDROID;\n\n    public final SymbolTable                                symbolTable           = new SymbolTable(4096);\n\n    public PropertyNamingStrategy                           propertyNamingStrategy;\n\n    protected ClassLoader                                   defaultClassLoader;\n\n    protected ASMDeserializerFactory                        asmFactory;\n\n    private static boolean                                  awtError              = false;\n    private static boolean                                  jdk8Error             = false;\n    private static boolean                                  jodaError             = false;\n    private static boolean                                  guavaError            = false;\n\n    private boolean                                         autoTypeSupport       = AUTO_SUPPORT;\n    private long[]                                          internalDenyHashCodes;\n    private long[]                                          denyHashCodes;\n    private long[]                                          acceptHashCodes;\n\n\n    public final boolean                                    fieldBased;\n    private boolean                                         jacksonCompatible     = false;\n\n    public boolean                                          compatibleWithJavaBean = TypeUtils.compatibleWithJavaBean;\n    private List<Module>                                    modules                = new ArrayList<Module>();\n    private volatile List<AutoTypeCheckHandler>             autoTypeCheckHandlers;\n    private boolean                                         safeMode               = SAFE_MODE;\n\n    {\n        denyHashCodes = new long[]{\n                0x80D0C70BCC2FEA02L,\n                0x86FC2BF9BEAF7AEFL,\n                0x87F52A1B07EA33A6L,\n                0x8EADD40CB2A94443L,\n                0x8F75F9FA0DF03F80L,\n                0x9172A53F157930AFL,\n                0x92122D710E364FB8L,\n                0x941866E73BEFF4C9L,\n                0x94305C26580F73C5L,\n                0x9437792831DF7D3FL,\n                0xA123A62F93178B20L,\n                0xA85882CE1044C450L,\n                0xAA3DAFFDB10C4937L,\n                0xAAA9E6B7C1E1C6A7L,\n                0xAAAA0826487A3737L,\n                0xAC6262F52C98AA39L,\n                0xAD937A449831E8A0L,\n                0xAE50DA1FAD60A096L,\n                0xAFF6FF23388E225AL,\n                0xAFFF4C95B99A334DL,\n                0xB40F341C746EC94FL,\n                0xB7E8ED757F5D13A2L,\n                0xB98B6B5396932FE9L,\n                0xBCDD9DC12766F0CEL,\n                0xBCE0DEE34E726499L,\n                0xBEBA72FB1CCBA426L,\n                0xC00BE1DEBAF2808BL,\n                0xC1086AFAE32E6258L,\n                0xC2664D0958ECFE4CL,\n                0xC41FF7C9C87C7C05L,\n                0xC664B363BACA050AL,\n                0xC7599EBFE3E72406L,\n                0xC8D49E5601E661A9L,\n                0xC8F04B3A28909935L,\n                0xC963695082FD728EL,\n                0xD1EFCDF4B3316D34L,\n                0xD54B91CC77B239EDL,\n                0xD59EE91F0B09EA01L,\n                0xD66F68AB92E7FEF5L,\n                0xD8CA3D595E982BACL,\n                0xDCD8D615A6449E3EL,\n                0xDE23A0809A8B9BD6L,\n                0xDEFC208F237D4104L,\n                0xDF2DDFF310CDB375L,\n                0xE09AE4604842582FL,\n                0xE1919804D5BF468FL,\n                0xE2EB3AC7E56C467EL,\n                0xE603D6A51FAD692BL,\n                0xE9184BE55B1D962AL,\n                0xE9F20BAD25F60807L,\n                0xF2983D099D29B477L,\n                0xF3702A4A5490B8E8L,\n                0xF474E44518F26736L,\n                0xF5D77DCF8E4D71E6L,\n                0xF6C0340E73A36A69L,\n                0xF7E96E74DFA58DBCL,\n                0xFC773AE20C827691L,\n                0xFCF3E78644B98BD8L,\n                0xFD5BFC610056D720L,\n                0xFFA15BF021F1E37CL,\n                0xFFDD1A80F1ED3405L,\n                0x10E067CD55C5E5L,\n                0x761619136CC13EL,\n                0x22BAA234C5BFB8AL,\n                0x3085068CB7201B8L,\n                0x45B11BC78A3ABA3L,\n                0x55CFCA0F2281C07L,\n                0xA555C74FE3A5155L,\n                0xB6E292FA5955ADEL,\n                0xEE6511B66FD5EF0L,\n                0x100150A253996624L,\n                0x10B2BDCA849D9B3EL,\n                0x10DBC48446E0DAE5L,\n                0x144277B467723158L,\n                0x14DB2E6FEAD04AF0L,\n                0x154B6CB22D294CFAL,\n                0x17924CCA5227622AL,\n                0x193B2697EAAED41AL,\n                0x1CD6F11C6A358BB7L,\n                0x1E0A8C3358FF3DAEL,\n                0x24652CE717E713BBL,\n                0x24D2F6048FEF4E49L,\n                0x24EC99D5E7DC5571L,\n                0x25E962F1C28F71A2L,\n                0x275D0732B877AF29L,\n                0x28AC82E44E933606L,\n                0x2AD1CE3A112F015DL,\n                0x2ADFEFBBFE29D931L,\n                0x2B3A37467A344CDFL,\n                0x2B6DD8B3229D6837L,\n                0x2D308DBBC851B0D8L,\n                0x2FE950D3EA52AE0DL,\n                0x313BB4ABD8D4554CL,\n                0x327C8ED7C8706905L,\n                0x332F0B5369A18310L,\n                0x339A3E0B6BEEBEE9L,\n                0x33C64B921F523F2FL,\n                0x34A81EE78429FDF1L,\n                0x378307CB0111E878L,\n                0x3826F4B2380C8B9BL,\n                0x398F942E01920CF0L,\n                0x3A31412DBB05C7FFL,\n                0x3ADBA40367F73264L,\n                0x3B0B51ECBF6DB221L,\n                0x42D11A560FC9FBA9L,\n                0x43320DC9D2AE0892L,\n                0x440E89208F445FB9L,\n                0x46C808A4B5841F57L,\n                0x49312BDAFB0077D9L,\n                0x4A3797B30328202CL,\n                0x4BA3E254E758D70DL,\n                0x4BF881E49D37F530L,\n                0x4CF54EEC05E3E818L,\n                0x4DA972745FEB30C1L,\n                0x4EF08C90FF16C675L,\n                0x4FD10DDC6D13821FL,\n                0x527DB6B46CE3BCBCL,\n                0x535E552D6F9700C1L,\n                0x5728504A6D454FFCL,\n                0x599B5C1213A099ACL,\n                0x5A5BD85C072E5EFEL,\n                0x5AB0CB3071AB40D1L,\n                0x5B6149820275EA42L,\n                0x5D74D3E5B9370476L,\n                0x5D92E6DDDE40ED84L,\n                0x5E61093EF8CDDDBBL,\n                0x5F215622FB630753L,\n                0x61C5BDD721385107L,\n                0x62DB241274397C34L,\n                0x63A220E60A17C7B9L,\n                0x647AB0224E149EBEL,\n                0x65F81B84C1D920CDL,\n                0x665C53C311193973L,\n                0x6749835432E0F0D2L,\n                0x69B6E0175084B377L,\n                0x6A47501EBB2AFDB2L,\n                0x6FCABF6FA54CAFFFL,\n                0x6FE92D83FC0A4628L,\n                0x746BD4A53EC195FBL,\n                0x74B50BB9260E31FFL,\n                0x75CC60F5871D0FD3L,\n                0x767A586A5107FEEFL,\n                0x7AA7EE3627A19CF3L,\n                0x7ED9311D28BF1A65L,\n                0x7ED9481D28BF417AL\n        };\n\n        long[] hashCodes = new long[AUTO_TYPE_ACCEPT_LIST.length];\n        for (int i = 0; i < AUTO_TYPE_ACCEPT_LIST.length; i++) {\n            hashCodes[i] = TypeUtils.fnv1a_64(AUTO_TYPE_ACCEPT_LIST[i]);\n        }\n\n        Arrays.sort(hashCodes);\n        acceptHashCodes = hashCodes;\n    }\n\n    public ParserConfig(){\n        this(false);\n    }\n\n    public ParserConfig(boolean fieldBase){\n        this(null, null, fieldBase);\n    }\n\n    public ParserConfig(ClassLoader parentClassLoader){\n        this(null, parentClassLoader, false);\n    }\n\n    public ParserConfig(ASMDeserializerFactory asmFactory){\n        this(asmFactory, null, false);\n    }\n\n    private ParserConfig(ASMDeserializerFactory asmFactory, ClassLoader parentClassLoader, boolean fieldBased){\n        this.fieldBased = fieldBased;\n        if (asmFactory == null && !ASMUtils.IS_ANDROID) {\n            try {\n                if (parentClassLoader == null) {\n                    asmFactory = new ASMDeserializerFactory(new ASMClassLoader());\n                } else {\n                    asmFactory = new ASMDeserializerFactory(parentClassLoader);\n                }\n            } catch (ExceptionInInitializerError error) {\n                // skip\n            } catch (AccessControlException error) {\n                // skip\n            } catch (NoClassDefFoundError error) {\n                // skip\n            }\n        }\n\n        this.asmFactory = asmFactory;\n\n        if (asmFactory == null) {\n            asmEnable = false;\n        }\n\n        initDeserializers();\n\n        addItemsToDeny(DENYS);\n        addItemsToDeny0(DENYS_INTERNAL);\n        addItemsToAccept(AUTO_TYPE_ACCEPT_LIST);\n\n    }\n\n    private final Callable<Void> initDeserializersWithJavaSql = new Callable<Void>() {\n        public Void call() {\n            deserializers.put(java.sql.Timestamp.class, SqlDateDeserializer.instance_timestamp);\n            deserializers.put(java.sql.Date.class, SqlDateDeserializer.instance);\n            deserializers.put(java.sql.Time.class, TimeDeserializer.instance);\n            deserializers.put(java.util.Date.class, DateCodec.instance);\n            return null;\n        }\n    };\n\n    private void initDeserializers() {\n        deserializers.put(SimpleDateFormat.class, MiscCodec.instance);\n        deserializers.put(Calendar.class, CalendarCodec.instance);\n        deserializers.put(XMLGregorianCalendar.class, CalendarCodec.instance);\n\n        deserializers.put(JSONObject.class, MapDeserializer.instance);\n        deserializers.put(JSONArray.class, CollectionCodec.instance);\n\n        deserializers.put(Map.class, MapDeserializer.instance);\n        deserializers.put(HashMap.class, MapDeserializer.instance);\n        deserializers.put(LinkedHashMap.class, MapDeserializer.instance);\n        deserializers.put(TreeMap.class, MapDeserializer.instance);\n        deserializers.put(ConcurrentMap.class, MapDeserializer.instance);\n        deserializers.put(ConcurrentHashMap.class, MapDeserializer.instance);\n\n        deserializers.put(Collection.class, CollectionCodec.instance);\n        deserializers.put(List.class, CollectionCodec.instance);\n        deserializers.put(ArrayList.class, CollectionCodec.instance);\n\n        deserializers.put(Object.class, JavaObjectDeserializer.instance);\n        deserializers.put(String.class, StringCodec.instance);\n        deserializers.put(StringBuffer.class, StringCodec.instance);\n        deserializers.put(StringBuilder.class, StringCodec.instance);\n        deserializers.put(char.class, CharacterCodec.instance);\n        deserializers.put(Character.class, CharacterCodec.instance);\n        deserializers.put(byte.class, NumberDeserializer.instance);\n        deserializers.put(Byte.class, NumberDeserializer.instance);\n        deserializers.put(short.class, NumberDeserializer.instance);\n        deserializers.put(Short.class, NumberDeserializer.instance);\n        deserializers.put(int.class, IntegerCodec.instance);\n        deserializers.put(Integer.class, IntegerCodec.instance);\n        deserializers.put(long.class, LongCodec.instance);\n        deserializers.put(Long.class, LongCodec.instance);\n        deserializers.put(BigInteger.class, BigIntegerCodec.instance);\n        deserializers.put(BigDecimal.class, BigDecimalCodec.instance);\n        deserializers.put(float.class, FloatCodec.instance);\n        deserializers.put(Float.class, FloatCodec.instance);\n        deserializers.put(double.class, NumberDeserializer.instance);\n        deserializers.put(Double.class, NumberDeserializer.instance);\n        deserializers.put(boolean.class, BooleanCodec.instance);\n        deserializers.put(Boolean.class, BooleanCodec.instance);\n        deserializers.put(Class.class, MiscCodec.instance);\n        deserializers.put(char[].class, new CharArrayCodec());\n\n        deserializers.put(AtomicBoolean.class, BooleanCodec.instance);\n        deserializers.put(AtomicInteger.class, IntegerCodec.instance);\n        deserializers.put(AtomicLong.class, LongCodec.instance);\n        deserializers.put(AtomicReference.class, ReferenceCodec.instance);\n\n        deserializers.put(WeakReference.class, ReferenceCodec.instance);\n        deserializers.put(SoftReference.class, ReferenceCodec.instance);\n\n        deserializers.put(UUID.class, MiscCodec.instance);\n        deserializers.put(TimeZone.class, MiscCodec.instance);\n        deserializers.put(Locale.class, MiscCodec.instance);\n        deserializers.put(Currency.class, MiscCodec.instance);\n\n        deserializers.put(Inet4Address.class, MiscCodec.instance);\n        deserializers.put(Inet6Address.class, MiscCodec.instance);\n        deserializers.put(InetSocketAddress.class, MiscCodec.instance);\n        deserializers.put(File.class, MiscCodec.instance);\n        deserializers.put(URI.class, MiscCodec.instance);\n        deserializers.put(URL.class, MiscCodec.instance);\n        deserializers.put(Pattern.class, MiscCodec.instance);\n        deserializers.put(Charset.class, MiscCodec.instance);\n        deserializers.put(JSONPath.class, MiscCodec.instance);\n        deserializers.put(Number.class, NumberDeserializer.instance);\n        deserializers.put(AtomicIntegerArray.class, AtomicCodec.instance);\n        deserializers.put(AtomicLongArray.class, AtomicCodec.instance);\n        deserializers.put(StackTraceElement.class, StackTraceElementDeserializer.instance);\n\n        deserializers.put(Serializable.class, JavaObjectDeserializer.instance);\n        deserializers.put(Cloneable.class, JavaObjectDeserializer.instance);\n        deserializers.put(Comparable.class, JavaObjectDeserializer.instance);\n        deserializers.put(Closeable.class, JavaObjectDeserializer.instance);\n\n        deserializers.put(JSONPObject.class, new JSONPDeserializer());\n        ModuleUtil.callWhenHasJavaSql(initDeserializersWithJavaSql);\n    }\n\n    private static String[] splitItemsFormProperty(final String property ){\n        if (property != null && property.length() > 0) {\n            return property.split(\",\");\n        }\n        return null;\n    }\n\n    public void configFromPropety(Properties properties) {\n        {\n            String property = properties.getProperty(DENY_PROPERTY);\n            String[] items = splitItemsFormProperty(property);\n            addItemsToDeny(items);\n        }\n        {\n            String property = properties.getProperty(AUTOTYPE_ACCEPT);\n            String[] items = splitItemsFormProperty(property);\n            addItemsToAccept(items);\n        }\n        {\n            String property = properties.getProperty(AUTOTYPE_SUPPORT_PROPERTY);\n            if (\"true\".equals(property)) {\n                this.autoTypeSupport = true;\n            } else if (\"false\".equals(property)) {\n                this.autoTypeSupport = false;\n            }\n        }\n    }\n\n    private void addItemsToDeny0(final String[] items){\n        if (items == null){\n            return;\n        }\n\n        for (int i = 0; i < items.length; ++i) {\n            String item = items[i];\n            this.addDenyInternal(item);\n        }\n    }\n\n    private void addItemsToDeny(final String[] items){\n        if (items == null){\n            return;\n        }\n\n        for (int i = 0; i < items.length; ++i) {\n            String item = items[i];\n            this.addDeny(item);\n        }\n    }\n\n    private void addItemsToAccept(final String[] items){\n        if (items == null){\n            return;\n        }\n\n        for (int i = 0; i < items.length; ++i) {\n            String item = items[i];\n            this.addAccept(item);\n        }\n    }\n\n    /**\n     * @since 1.2.68\n     */\n    public boolean isSafeMode() {\n        return safeMode;\n    }\n\n    /**\n     * @since 1.2.68\n     */\n    public void setSafeMode(boolean safeMode) {\n        this.safeMode = safeMode;\n    }\n\n    public boolean isAutoTypeSupport() {\n        return autoTypeSupport;\n    }\n\n    public void setAutoTypeSupport(boolean autoTypeSupport) {\n        this.autoTypeSupport = autoTypeSupport;\n    }\n\n    public boolean isAsmEnable() {\n        return asmEnable;\n    }\n\n    public void setAsmEnable(boolean asmEnable) {\n        this.asmEnable = asmEnable;\n    }\n\n    /**\n     * @deprecated\n     */\n    public IdentityHashMap<Type, ObjectDeserializer> getDerializers() {\n        return deserializers;\n    }\n\n    public IdentityHashMap<Type, ObjectDeserializer> getDeserializers() {\n        return deserializers;\n    }\n\n    public ObjectDeserializer getDeserializer(Type type) {\n        ObjectDeserializer deserializer = get(type);\n        if (deserializer != null) {\n            return deserializer;\n        }\n\n        if (type instanceof Class<?>) {\n            return getDeserializer((Class<?>) type, type);\n        }\n\n        if (type instanceof ParameterizedType) {\n            Type rawType = ((ParameterizedType) type).getRawType();\n            if (rawType instanceof Class<?>) {\n                return getDeserializer((Class<?>) rawType, type);\n            } else {\n                return getDeserializer(rawType);\n            }\n        }\n\n        if (type instanceof WildcardType) {\n            WildcardType wildcardType = (WildcardType) type;\n            Type[] upperBounds = wildcardType.getUpperBounds();\n            if (upperBounds.length == 1) {\n                Type upperBoundType = upperBounds[0];\n                return getDeserializer(upperBoundType);\n            }\n        }\n\n        return JavaObjectDeserializer.instance;\n    }\n\n    public ObjectDeserializer getDeserializer(Class<?> clazz, Type type) {\n        ObjectDeserializer deserializer = get(type);\n        if (deserializer == null && type instanceof ParameterizedTypeImpl) {\n            Type innerType = TypeReference.intern((ParameterizedTypeImpl) type);\n            deserializer = get(innerType);\n        }\n\n        if (deserializer != null) {\n            return deserializer;\n        }\n\n        if (type == null) {\n            type = clazz;\n        }\n\n        deserializer = get(type);\n        if (deserializer != null) {\n            return deserializer;\n        }\n\n        {\n            JSONType annotation = TypeUtils.getAnnotation(clazz,JSONType.class);\n            if (annotation != null) {\n                Class<?> mappingTo = annotation.mappingTo();\n                if (mappingTo != Void.class) {\n                    return getDeserializer(mappingTo, mappingTo);\n                }\n            }\n        }\n\n        if (type instanceof WildcardType || type instanceof TypeVariable || type instanceof ParameterizedType) {\n            deserializer = get(clazz);\n        }\n\n        if (deserializer != null) {\n            return deserializer;\n        }\n\n        for (Module module : modules) {\n            deserializer = module.createDeserializer(this, clazz);\n            if (deserializer != null) {\n                putDeserializer(type, deserializer);\n                return deserializer;\n            }\n        }\n\n        String className = clazz.getName();\n        className = className.replace('$', '.');\n\n        if (className.startsWith(\"java.awt.\") //\n            && AwtCodec.support(clazz)) {\n            if (!awtError) {\n                String[] names = new String[] {\n                        \"java.awt.Point\",\n                        \"java.awt.Font\",\n                        \"java.awt.Rectangle\",\n                        \"java.awt.Color\"\n                };\n\n                try {\n                    for (String name : names) {\n                        if (name.equals(className)) {\n                            putDeserializer(Class.forName(name), deserializer = AwtCodec.instance);\n                            return deserializer;\n                        }\n                    }\n                } catch (Throwable e) {\n                    // skip\n                    awtError = true;\n                }\n\n                deserializer = AwtCodec.instance;\n            }\n        }\n\n        if (!jdk8Error) {\n            try {\n                if (className.startsWith(\"java.time.\")) {\n                    String[] names = new String[] {\n                            \"java.time.LocalDateTime\",\n                            \"java.time.LocalDate\",\n                            \"java.time.LocalTime\",\n                            \"java.time.ZonedDateTime\",\n                            \"java.time.OffsetDateTime\",\n                            \"java.time.OffsetTime\",\n                            \"java.time.ZoneOffset\",\n                            \"java.time.ZoneRegion\",\n                            \"java.time.ZoneId\",\n                            \"java.time.Period\",\n                            \"java.time.Duration\",\n                            \"java.time.Instant\"\n                    };\n\n                    for (String name : names) {\n                        if (name.equals(className)) {\n                            putDeserializer(Class.forName(name), deserializer = Jdk8DateCodec.instance);\n                            return deserializer;\n                        }\n                    }\n                } else if (className.startsWith(\"java.util.Optional\")) {\n                    String[] names = new String[] {\n                            \"java.util.Optional\",\n                            \"java.util.OptionalDouble\",\n                            \"java.util.OptionalInt\",\n                            \"java.util.OptionalLong\"\n                    };\n                    for (String name : names) {\n                        if (name.equals(className)) {\n                            putDeserializer(Class.forName(name), deserializer = OptionalCodec.instance);\n                            return deserializer;\n                        }\n                    }\n                }\n            } catch (Throwable e) {\n                // skip\n                jdk8Error = true;\n            }\n        }\n\n        if (!jodaError) {\n            try {\n                if (className.startsWith(\"org.joda.time.\")) {\n                    String[] names = new String[] {\n                            \"org.joda.time.DateTime\",\n                            \"org.joda.time.LocalDate\",\n                            \"org.joda.time.LocalDateTime\",\n                            \"org.joda.time.LocalTime\",\n                            \"org.joda.time.Instant\",\n                            \"org.joda.time.Period\",\n                            \"org.joda.time.Duration\",\n                            \"org.joda.time.DateTimeZone\",\n                            \"org.joda.time.format.DateTimeFormatter\"\n                    };\n\n                    for (String name : names) {\n                        if (name.equals(className)) {\n                            putDeserializer(Class.forName(name), deserializer = JodaCodec.instance);\n                            return deserializer;\n                        }\n                    }\n                }\n            } catch (Throwable e) {\n                // skip\n                jodaError = true;\n            }\n        }\n\n        if ((!guavaError) //\n                && className.startsWith(\"com.google.common.collect.\")) {\n            try {\n                String[] names = new String[] {\n                        \"com.google.common.collect.HashMultimap\",\n                        \"com.google.common.collect.LinkedListMultimap\",\n                        \"com.google.common.collect.LinkedHashMultimap\",\n                        \"com.google.common.collect.ArrayListMultimap\",\n                        \"com.google.common.collect.TreeMultimap\"\n                };\n\n                for (String name : names) {\n                    if (name.equals(className)) {\n                        putDeserializer(Class.forName(name), deserializer = GuavaCodec.instance);\n                        return deserializer;\n                    }\n                }\n            } catch (ClassNotFoundException e) {\n                // skip\n                guavaError = true;\n            }\n        }\n\n        if (className.equals(\"java.nio.ByteBuffer\")) {\n            putDeserializer(clazz, deserializer = ByteBufferCodec.instance);\n        }\n\n        if (className.equals(\"java.nio.file.Path\")) {\n            putDeserializer(clazz, deserializer = MiscCodec.instance);\n        }\n\n        if (clazz == Map.Entry.class) {\n            putDeserializer(clazz, deserializer = MiscCodec.instance);\n        }\n\n        if (className.equals(\"org.javamoney.moneta.Money\")) {\n            putDeserializer(clazz, deserializer = MonetaCodec.instance);\n        }\n\n        final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        try {\n            for (AutowiredObjectDeserializer autowired : ServiceLoader.load(AutowiredObjectDeserializer.class,\n                                                                            classLoader)) {\n                for (Type forType : autowired.getAutowiredFor()) {\n                    putDeserializer(forType, autowired);\n                }\n            }\n        } catch (Exception ex) {\n            // skip\n        }\n\n        if (deserializer == null) {\n            deserializer = get(type);\n        }\n\n        if (deserializer != null) {\n            return deserializer;\n        }\n\n        if (clazz.isEnum()) {\n            if (jacksonCompatible) {\n                Method[] methods = clazz.getMethods();\n                for (Method method : methods) {\n                    if (TypeUtils.isJacksonCreator(method)) {\n                        deserializer = createJavaBeanDeserializer(clazz, type);\n                        putDeserializer(type, deserializer);\n                        return deserializer;\n                    }\n                }\n            }\n\n            Class mixInType = (Class) JSON.getMixInAnnotations(clazz);\n\n            Class<?> deserClass = null;\n            JSONType jsonType = TypeUtils.getAnnotation(mixInType != null ? mixInType : clazz, JSONType.class);\n\n            if (jsonType != null) {\n                deserClass = jsonType.deserializer();\n                try {\n                    deserializer = (ObjectDeserializer) deserClass.newInstance();\n                    putDeserializer(clazz, deserializer);\n                    return deserializer;\n                } catch (Throwable error) {\n                    // skip\n                }\n            }\n\n            Method jsonCreatorMethod = null;\n            if (mixInType != null) {\n                Method mixedCreator = getEnumCreator(mixInType, clazz);\n                if (mixedCreator != null) {\n                    try {\n                        jsonCreatorMethod = clazz.getMethod(mixedCreator.getName(), mixedCreator.getParameterTypes());\n                    } catch (Exception e) {\n                        // skip\n                    }\n                }\n            } else {\n                jsonCreatorMethod = getEnumCreator(clazz, clazz);\n            }\n\n            if (jsonCreatorMethod != null) {\n                deserializer = new EnumCreatorDeserializer(jsonCreatorMethod);\n                putDeserializer(clazz, deserializer);\n                return deserializer;\n            }\n\n            deserializer = getEnumDeserializer(clazz);\n        } else if (clazz.isArray()) {\n            deserializer = ObjectArrayCodec.instance;\n        } else if (clazz == Set.class || clazz == HashSet.class || clazz == Collection.class || clazz == List.class\n                   || clazz == ArrayList.class) {\n            deserializer = CollectionCodec.instance;\n        } else if (Collection.class.isAssignableFrom(clazz)) {\n            deserializer = CollectionCodec.instance;\n        } else if (Map.class.isAssignableFrom(clazz)) {\n            deserializer = MapDeserializer.instance;\n        } else if (Throwable.class.isAssignableFrom(clazz)) {\n            deserializer = new ThrowableDeserializer(this, clazz);\n        } else if (PropertyProcessable.class.isAssignableFrom(clazz)) {\n            deserializer = new PropertyProcessableDeserializer((Class<PropertyProcessable>) clazz);\n        } else if (clazz == InetAddress.class) {\n            deserializer = MiscCodec.instance;\n        } else {\n            deserializer = createJavaBeanDeserializer(clazz, type);\n        }\n\n        putDeserializer(type, deserializer);\n\n        return deserializer;\n    }\n\n    private static Method getEnumCreator(Class clazz, Class enumClass) {\n        Method[] methods = clazz.getMethods();\n        Method jsonCreatorMethod = null;\n        for (Method method : methods) {\n            if (Modifier.isStatic(method.getModifiers())\n                    && method.getReturnType() == enumClass\n                    && method.getParameterTypes().length == 1\n            ) {\n                JSONCreator jsonCreator = method.getAnnotation(JSONCreator.class);\n                if (jsonCreator != null) {\n                    jsonCreatorMethod = method;\n                    break;\n                }\n            }\n        }\n\n        return jsonCreatorMethod;\n    }\n\n    /**\n     * \u53ef\u4ee5\u901a\u8fc7\u91cd\u5199\u8fd9\u4e2a\u65b9\u6cd5\uff0c\u5b9a\u4e49\u81ea\u5df1\u7684\u679a\u4e3e\u53cd\u5e8f\u5217\u5316\u5b9e\u73b0\n     * @param clazz \u8f6c\u6362\u7684\u7c7b\u578b\n     * @return \u8fd4\u56de\u4e00\u4e2a\u679a\u4e3e\u7684\u53cd\u5e8f\u5217\u5316\u5b9e\u73b0\n     * @author zhu.xiaojie\n     * @time 2020-4-5\n     */\n    protected ObjectDeserializer getEnumDeserializer(Class<?> clazz){\n        return new EnumDeserializer(clazz);\n    }\n\n    /**\n     *\n     * @since 1.2.25\n     */\n    public void initJavaBeanDeserializers(Class<?>... classes) {\n        if (classes == null) {\n            return;\n        }\n\n        for (Class<?> type : classes) {\n            if (type == null) {\n                continue;\n            }\n            ObjectDeserializer deserializer = createJavaBeanDeserializer(type, type);\n            putDeserializer(type, deserializer);\n        }\n    }\n\n    public ObjectDeserializer createJavaBeanDeserializer(Class<?> clazz, Type type) {\n        boolean asmEnable = this.asmEnable & !this.fieldBased;\n        if (asmEnable) {\n            JSONType jsonType = TypeUtils.getAnnotation(clazz,JSONType.class);\n\n            if (jsonType != null) {\n                Class<?> deserializerClass = jsonType.deserializer();\n                if (deserializerClass != Void.class) {\n                    try {\n                        Object deseralizer = deserializerClass.newInstance();\n                        if (deseralizer instanceof ObjectDeserializer) {\n                            return (ObjectDeserializer) deseralizer;\n                        }\n                    } catch (Throwable e) {\n                        // skip\n                    }\n                }\n\n                asmEnable = jsonType.asm()\n                        && jsonType.parseFeatures().length == 0;\n            }\n\n            if (asmEnable) {\n                Class<?> superClass = JavaBeanInfo.getBuilderClass(clazz, jsonType);\n                if (superClass == null) {\n                    superClass = clazz;\n                }\n\n                for (;;) {\n                    if (!Modifier.isPublic(superClass.getModifiers())) {\n                        asmEnable = false;\n                        break;\n                    }\n\n                    superClass = superClass.getSuperclass();\n                    if (superClass == Object.class || superClass == null) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (clazz.getTypeParameters().length != 0) {\n            asmEnable = false;\n        }\n\n        if (asmEnable && asmFactory != null && asmFactory.classLoader.isExternalClass(clazz)) {\n            asmEnable = false;\n        }\n\n        if (asmEnable) {\n            asmEnable = ASMUtils.checkName(clazz.getSimpleName());\n        }\n\n        if (asmEnable) {\n            if (clazz.isInterface()) {\n                asmEnable = false;\n            }\n            JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz\n                    , type\n                    , propertyNamingStrategy\n                    ,false\n                    , TypeUtils.compatibleWithJavaBean\n                    , jacksonCompatible\n            );\n\n            if (asmEnable && beanInfo.fields.length > 200) {\n                asmEnable = false;\n            }\n\n            Constructor<?> defaultConstructor = beanInfo.defaultConstructor;\n            if (asmEnable && defaultConstructor == null && !clazz.isInterface()) {\n                asmEnable = false;\n            }\n\n            for (FieldInfo fieldInfo : beanInfo.fields) {\n                if (fieldInfo.getOnly) {\n                    asmEnable = false;\n                    break;\n                }\n\n                Class<?> fieldClass = fieldInfo.fieldClass;\n                if (!Modifier.isPublic(fieldClass.getModifiers())) {\n                    asmEnable = false;\n                    break;\n                }\n\n                if (fieldClass.isMemberClass() && !Modifier.isStatic(fieldClass.getModifiers())) {\n                    asmEnable = false;\n                    break;\n                }\n\n                if (fieldInfo.getMember() != null //\n                    && !ASMUtils.checkName(fieldInfo.getMember().getName())) {\n                    asmEnable = false;\n                    break;\n                }\n\n                JSONField annotation = fieldInfo.getAnnotation();\n                if (annotation != null //\n                    && ((!ASMUtils.checkName(annotation.name())) //\n                        || annotation.format().length() != 0 //\n                        || annotation.deserializeUsing() != Void.class //\n                        || annotation.parseFeatures().length != 0 //\n                        || annotation.unwrapped())\n                        || (fieldInfo.method != null && fieldInfo.method.getParameterTypes().length > 1)) {\n                    asmEnable = false;\n                    break;\n                }\n\n                if (fieldClass.isEnum()) { // EnumDeserializer\n                    ObjectDeserializer fieldDeser = this.getDeserializer(fieldClass);\n                    if (!(fieldDeser instanceof EnumDeserializer)) {\n                        asmEnable = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (asmEnable) {\n            if (clazz.isMemberClass() && !Modifier.isStatic(clazz.getModifiers())) {\n                asmEnable = false;\n            }\n        }\n\n        if (asmEnable) {\n            if (TypeUtils.isXmlField(clazz)) {\n                asmEnable = false;\n            }\n        }\n\n        if (!asmEnable) {\n            return new JavaBeanDeserializer(this, clazz, type);\n        }\n\n        JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz, type, propertyNamingStrategy);\n        try {\n            return asmFactory.createJavaBeanDeserializer(this, beanInfo);\n            // } catch (VerifyError e) {\n            // e.printStackTrace();\n            // return new JavaBeanDeserializer(this, clazz, type);\n        } catch (NoSuchMethodException ex) {\n            return new JavaBeanDeserializer(this, clazz, type);\n        } catch (JSONException asmError) {\n            return new JavaBeanDeserializer(this, beanInfo);\n        } catch (Exception e) {\n            throw new JSONException(\"create asm deserializer error, \" + clazz.getName(), e);\n        }\n    }\n\n    public FieldDeserializer createFieldDeserializer(ParserConfig mapping, //\n                                                     JavaBeanInfo beanInfo, //\n                                                     FieldInfo fieldInfo) {\n        Class<?> clazz = beanInfo.clazz;\n        Class<?> fieldClass = fieldInfo.fieldClass;\n\n        Class<?> deserializeUsing = null;\n        JSONField annotation = fieldInfo.getAnnotation();\n        if (annotation != null) {\n            deserializeUsing = annotation.deserializeUsing();\n            if (deserializeUsing == Void.class) {\n                deserializeUsing = null;\n            }\n        }\n\n        if (deserializeUsing == null && (fieldClass == List.class || fieldClass == ArrayList.class)) {\n            return new ArrayListTypeFieldDeserializer(mapping, clazz, fieldInfo);\n        }\n\n        return new DefaultFieldDeserializer(mapping, clazz, fieldInfo);\n    }\n\n    public void putDeserializer(Type type, ObjectDeserializer deserializer) {\n        Type mixin = JSON.getMixInAnnotations(type);\n        if (mixin != null) {\n            IdentityHashMap<Type, ObjectDeserializer> mixInClasses = this.mixInDeserializers.get(type);\n            if (mixInClasses == null) {\n                //\u591a\u7ebf\u7a0b\u4e0b\u53ef\u80fd\u4f1a\u91cd\u590d\u521b\u5efa\uff0c\u4f46\u4e0d\u5f71\u54cd\u6b63\u786e\u6027\n                mixInClasses = new IdentityHashMap<Type, ObjectDeserializer>(4);\n                this.mixInDeserializers.put(type, mixInClasses);\n            }\n            mixInClasses.put(mixin, deserializer);\n        } else {\n            this.deserializers.put(type, deserializer);\n        }\n    }\n\n    public ObjectDeserializer get(Type type) {\n        Type mixin = JSON.getMixInAnnotations(type);\n        if (null == mixin) {\n            return this.deserializers.get(type);\n        }\n        IdentityHashMap<Type, ObjectDeserializer> mixInClasses = this.mixInDeserializers.get(type);\n        if (mixInClasses == null) {\n            return null;\n        }\n        return mixInClasses.get(mixin);\n    }\n\n    public ObjectDeserializer getDeserializer(FieldInfo fieldInfo) {\n        return getDeserializer(fieldInfo.fieldClass, fieldInfo.fieldType);\n    }\n\n    /**\n     * @deprecated  internal method, dont call\n     */\n    public boolean isPrimitive(Class<?> clazz) {\n        return isPrimitive2(clazz);\n    }\n\n    private static Function<Class<?>, Boolean> isPrimitiveFuncation = new Function<Class<?>, Boolean>() {\n        public Boolean apply(Class<?> clazz) {\n            return clazz == java.sql.Date.class //\n                    || clazz == java.sql.Time.class //\n                    || clazz == java.sql.Timestamp.class;\n        }\n    };\n\n    /**\n     * @deprecated  internal method, dont call\n     */\n    public static boolean isPrimitive2(final Class<?> clazz) {\n        Boolean primitive = clazz.isPrimitive() //\n                || clazz == Boolean.class //\n                || clazz == Character.class //\n                || clazz == Byte.class //\n                || clazz == Short.class //\n                || clazz == Integer.class //\n                || clazz == Long.class //\n                || clazz == Float.class //\n                || clazz == Double.class //\n                || clazz == BigInteger.class //\n                || clazz == BigDecimal.class //\n                || clazz == String.class //\n                || clazz == java.util.Date.class //\n                || clazz.isEnum() //\n                ;\n        if (!primitive) {\n            primitive = ModuleUtil.callWhenHasJavaSql(isPrimitiveFuncation, clazz);\n        }\n        return primitive != null ? primitive : false;\n    }\n\n    /**\n     * fieldName,field \uff0c\u5148\u751f\u6210fieldName\u7684\u5feb\u7167\uff0c\u51cf\u5c11\u4e4b\u540e\u7684findField\u7684\u8f6e\u8be2\n     *\n     * @param clazz\n     * @param fieldCacheMap :map&lt;fieldName ,Field&gt;\n     */\n    public static void  parserAllFieldToCache(Class<?> clazz,Map</**fieldName*/String , Field> fieldCacheMap){\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (!fieldCacheMap.containsKey(fieldName)) {\n                fieldCacheMap.put(fieldName, field);\n            }\n        }\n        if (clazz.getSuperclass() != null && clazz.getSuperclass() != Object.class) {\n            parserAllFieldToCache(clazz.getSuperclass(), fieldCacheMap);\n        }\n    }\n\n    public static Field getFieldFromCache(String fieldName, Map<String, Field> fieldCacheMap) {\n        Field field = fieldCacheMap.get(fieldName);\n\n        if (field == null) {\n            field = fieldCacheMap.get(\"_\" + fieldName);\n        }\n\n        if (field == null) {\n            field = fieldCacheMap.get(\"m_\" + fieldName);\n        }\n\n        if (field == null) {\n            char c0 = fieldName.charAt(0);\n            if (c0 >= 'a' && c0 <= 'z') {\n                char[] chars = fieldName.toCharArray();\n                chars[0] -= 32; // lower\n                String fieldNameX = new String(chars);\n                field = fieldCacheMap.get(fieldNameX);\n            }\n\n            if (fieldName.length() > 2) {\n                char c1 = fieldName.charAt(1);\n                if (c0 >= 'a' && c0 <= 'z'\n                        && c1 >= 'A' && c1 <= 'Z') {\n                    for (Map.Entry<String, Field> entry : fieldCacheMap.entrySet()) {\n                        if (fieldName.equalsIgnoreCase(entry.getKey())) {\n                            field = entry.getValue();\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return field;\n    }\n\n    public ClassLoader getDefaultClassLoader() {\n        return defaultClassLoader;\n    }\n\n    public void setDefaultClassLoader(ClassLoader defaultClassLoader) {\n        this.defaultClassLoader = defaultClassLoader;\n    }\n\n    public void addDenyInternal(String name) {\n        if (name == null || name.length() == 0) {\n            return;\n        }\n\n        long hash = TypeUtils.fnv1a_64(name);\n        if (internalDenyHashCodes == null) {\n            this.internalDenyHashCodes = new long[] {hash};\n            return;\n        }\n\n        if (Arrays.binarySearch(this.internalDenyHashCodes, hash) >= 0) {\n            return;\n        }\n\n        long[] hashCodes = new long[this.internalDenyHashCodes.length + 1];\n        hashCodes[hashCodes.length - 1] = hash;\n        System.arraycopy(this.internalDenyHashCodes, 0, hashCodes, 0, this.internalDenyHashCodes.length);\n        Arrays.sort(hashCodes);\n        this.internalDenyHashCodes = hashCodes;\n    }\n\n    public void addDeny(String name) {\n        if (name == null || name.length() == 0) {\n            return;\n        }\n\n        long hash = TypeUtils.fnv1a_64(name);\n        if (Arrays.binarySearch(this.denyHashCodes, hash) >= 0) {\n            return;\n        }\n\n        long[] hashCodes = new long[this.denyHashCodes.length + 1];\n        hashCodes[hashCodes.length - 1] = hash;\n        System.arraycopy(this.denyHashCodes, 0, hashCodes, 0, this.denyHashCodes.length);\n        Arrays.sort(hashCodes);\n        this.denyHashCodes = hashCodes;\n    }\n\n    public void addAccept(String name) {\n        if (name == null || name.length() == 0) {\n            return;\n        }\n\n        long hash = TypeUtils.fnv1a_64(name);\n        if (Arrays.binarySearch(this.acceptHashCodes, hash) >= 0) {\n            return;\n        }\n\n        long[] hashCodes = new long[this.acceptHashCodes.length + 1];\n        hashCodes[hashCodes.length - 1] = hash;\n        System.arraycopy(this.acceptHashCodes, 0, hashCodes, 0, this.acceptHashCodes.length);\n        Arrays.sort(hashCodes);\n        this.acceptHashCodes = hashCodes;\n    }\n\n    public Class<?> checkAutoType(Class type) {\n        if (get(type) != null) {\n            return type;\n        }\n\n        return checkAutoType(type.getName(), null, JSON.DEFAULT_PARSER_FEATURE);\n    }\n\n    public Class<?> checkAutoType(String typeName, Class<?> expectClass) {\n        return checkAutoType(typeName, expectClass, JSON.DEFAULT_PARSER_FEATURE);\n    }\n\n    public Class<?> checkAutoType(String typeName, Class<?> expectClass, int features) {\n        if (typeName == null) {\n            return null;\n        }\n\n        if (autoTypeCheckHandlers != null) {\n            for (AutoTypeCheckHandler h : autoTypeCheckHandlers) {\n                Class<?> type = h.handler(typeName, expectClass, features);\n                if (type != null) {\n                    return type;\n                }\n            }\n        }\n\n        final int safeModeMask = Feature.SafeMode.mask;\n        boolean safeMode = this.safeMode\n                || (features & safeModeMask) != 0\n                || (JSON.DEFAULT_PARSER_FEATURE & safeModeMask) != 0;\n        if (safeMode) {\n            throw new JSONException(\"safeMode not support autoType : \" + typeName);\n        }\n\n        if (typeName.length() >= 192 || typeName.length() < 3) {\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        final boolean expectClassFlag;\n        if (expectClass == null) {\n            expectClassFlag = false;\n        } else {\n            long expectHash = TypeUtils.fnv1a_64(expectClass.getName());\n            if (expectHash == 0x90a25f5baa21529eL\n                    || expectHash == 0x2d10a5801b9d6136L\n                    || expectHash == 0xaf586a571e302c6bL\n                    || expectHash == 0xed007300a7b227c6L\n                    || expectHash == 0x295c4605fd1eaa95L\n                    || expectHash == 0x47ef269aadc650b4L\n                    || expectHash == 0x6439c4dff712ae8bL\n                    || expectHash == 0xe3dd9875a2dc5283L\n                    || expectHash == 0xe2a8ddba03e69e0dL\n                    || expectHash == 0xd734ceb4c3e9d1daL\n            ) {\n                expectClassFlag = false;\n            } else {\n                expectClassFlag = true;\n            }\n        }\n\n        String className = typeName.replace('$', '.');\n        Class<?> clazz;\n\n        final long h1 = (fnv1a_64_magic_hashcode ^ className.charAt(0)) * fnv1a_64_magic_prime;\n        if (h1 == 0xaf64164c86024f1aL) { // [\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        if ((h1 ^ className.charAt(className.length() - 1)) * fnv1a_64_magic_prime == 0x9198507b5af98f0L) {\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        final long h3 = (((((fnv1a_64_magic_hashcode ^ className.charAt(0))\n                * fnv1a_64_magic_prime)\n                ^ className.charAt(1))\n                * fnv1a_64_magic_prime)\n                ^ className.charAt(2))\n                * fnv1a_64_magic_prime;\n\n        long fullHash = TypeUtils.fnv1a_64(className);\n        boolean internalWhite = Arrays.binarySearch(INTERNAL_WHITELIST_HASHCODES,  fullHash) >= 0;\n\n        if (internalDenyHashCodes != null) {\n            long hash = h3;\n            for (int i = 3; i < className.length(); ++i) {\n                hash ^= className.charAt(i);\n                hash *= fnv1a_64_magic_prime;\n                if (Arrays.binarySearch(internalDenyHashCodes, hash) >= 0) {\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n            }\n        }\n\n        if ((!internalWhite) && (autoTypeSupport || expectClassFlag)) {\n            long hash = h3;\n            for (int i = 3; i < className.length(); ++i) {\n                hash ^= className.charAt(i);\n                hash *= fnv1a_64_magic_prime;\n                if (Arrays.binarySearch(acceptHashCodes, hash) >= 0) {\n                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);\n                    if (clazz != null) {\n                        return clazz;\n                    }\n                }\n                if (Arrays.binarySearch(denyHashCodes, hash) >= 0 && TypeUtils.getClassFromMapping(typeName) == null) {\n                    if (Arrays.binarySearch(acceptHashCodes, fullHash) >= 0) {\n                        continue;\n                    }\n\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n            }\n        }\n\n        clazz = TypeUtils.getClassFromMapping(typeName);\n\n        if (clazz == null) {\n            clazz = deserializers.findClass(typeName);\n        }\n\n        if (clazz == null) {\n            clazz = typeMapping.get(typeName);\n        }\n\n        if (internalWhite) {\n            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);\n        }\n\n        if (clazz != null) {\n            if (expectClass != null\n                    && clazz != java.util.HashMap.class\n                    && clazz != java.util.LinkedHashMap.class\n                    && !expectClass.isAssignableFrom(clazz)) {\n                throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n            }\n\n            return clazz;\n        }\n\n        if (!autoTypeSupport) {\n            long hash = h3;\n            for (int i = 3; i < className.length(); ++i) {\n                char c = className.charAt(i);\n                hash ^= c;\n                hash *= fnv1a_64_magic_prime;\n\n                if (Arrays.binarySearch(denyHashCodes, hash) >= 0) {\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n\n                // white list\n                if (Arrays.binarySearch(acceptHashCodes, hash) >= 0) {\n                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);\n\n                    if (clazz == null) {\n                        return expectClass;\n                    }\n\n                    if (expectClass != null && expectClass.isAssignableFrom(clazz)) {\n                        throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n                    }\n\n                    return clazz;\n                }\n            }\n        }\n\n        boolean jsonType = false;\n        InputStream is = null;\n        try {\n            String resource = typeName.replace('.', '/') + \".class\";\n            if (defaultClassLoader != null) {\n                is = defaultClassLoader.getResourceAsStream(resource);\n            } else {\n                is = ParserConfig.class.getClassLoader().getResourceAsStream(resource);\n            }\n            if (is != null) {\n                ClassReader classReader = new ClassReader(is, true);\n                TypeCollector visitor = new TypeCollector(\"<clinit>\", new Class[0]);\n                classReader.accept(visitor);\n                jsonType = visitor.hasJsonType();\n            }\n        } catch (Exception e) {\n            // skip\n        } finally {\n            IOUtils.close(is);\n        }\n\n        final int mask = Feature.SupportAutoType.mask;\n        boolean autoTypeSupport = this.autoTypeSupport\n                || (features & mask) != 0\n                || (JSON.DEFAULT_PARSER_FEATURE & mask) != 0;\n\n        if (autoTypeSupport || jsonType || expectClassFlag) {\n            boolean cacheClass = autoTypeSupport || jsonType;\n            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, cacheClass);\n        }\n\n        if (clazz != null) {\n            if (jsonType) {\n                TypeUtils.addMapping(typeName, clazz);\n                return clazz;\n            }\n\n            if (ClassLoader.class.isAssignableFrom(clazz) // classloader is danger\n                    || javax.sql.DataSource.class.isAssignableFrom(clazz) // dataSource can load jdbc driver\n                    || javax.sql.RowSet.class.isAssignableFrom(clazz) //\n                    ) {\n                throw new JSONException(\"autoType is not support. \" + typeName);\n            }\n\n            if (expectClass != null) {\n                if (expectClass.isAssignableFrom(clazz)) {\n                    TypeUtils.addMapping(typeName, clazz);\n                    return clazz;\n                } else {\n                    throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n                }\n            }\n\n            JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz, clazz, propertyNamingStrategy);\n            if (beanInfo.creatorConstructor != null && autoTypeSupport) {\n                throw new JSONException(\"autoType is not support. \" + typeName);\n            }\n        }\n\n        if (!autoTypeSupport) {\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        if (clazz != null) {\n            TypeUtils.addMapping(typeName, clazz);\n        }\n\n        return clazz;\n    }\n\n    public void clearDeserializers() {\n        this.deserializers.clear();\n        this.initDeserializers();\n    }\n\n    public boolean isJacksonCompatible() {\n        return jacksonCompatible;\n    }\n\n    public void setJacksonCompatible(boolean jacksonCompatible) {\n        this.jacksonCompatible = jacksonCompatible;\n    }\n\n    public void register(String typeName, Class type) {\n        typeMapping.putIfAbsent(typeName, type);\n    }\n\n    public void register(Module module) {\n        this.modules.add(module);\n    }\n\n    public void addAutoTypeCheckHandler(AutoTypeCheckHandler h) {\n        List<AutoTypeCheckHandler> autoTypeCheckHandlers = this.autoTypeCheckHandlers;\n        if (autoTypeCheckHandlers == null) {\n            this.autoTypeCheckHandlers\n                    = autoTypeCheckHandlers\n                    = new CopyOnWriteArrayList();\n        }\n\n        autoTypeCheckHandlers.add(h);\n    }\n\n    /**\n     * @since 1.2.68\n     */\n    public interface AutoTypeCheckHandler {\n        Class<?> handler(String typeName, Class<?> expectClass, int features);\n    }\n}\n", "package com.alibaba.json.bvt.bug;\n\nimport junit.framework.TestCase;\n\nimport com.alibaba.fastjson.JSON;\n\npublic class Bug_for_Exception extends TestCase {\n\tpublic void test_exception() throws Exception {\n\t\tRuntimeException ex = new RuntimeException(\"e1\");\n\t\tString text = JSON.toJSONString(ex);\n\t\tSystem.out.println(text);\n\t\t\n\t\tRuntimeException ex2 = (RuntimeException) JSON.parse(text);\n\t}\n}\n"], "fixing_code": ["/*\n * Copyright 1999-2017 Alibaba Group.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.fastjson.parser;\n\nimport java.io.*;\nimport java.lang.ref.SoftReference;\nimport java.lang.ref.WeakReference;\nimport java.lang.reflect.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.Inet4Address;\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.security.AccessControlException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.atomic.AtomicLongArray;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.regex.Pattern;\n\nimport com.alibaba.fastjson.*;\nimport com.alibaba.fastjson.annotation.JSONCreator;\nimport com.alibaba.fastjson.annotation.JSONField;\nimport com.alibaba.fastjson.annotation.JSONType;\nimport com.alibaba.fastjson.asm.ClassReader;\nimport com.alibaba.fastjson.asm.TypeCollector;\nimport com.alibaba.fastjson.parser.deserializer.*;\nimport com.alibaba.fastjson.serializer.*;\nimport com.alibaba.fastjson.spi.Module;\nimport com.alibaba.fastjson.support.moneta.MonetaCodec;\nimport com.alibaba.fastjson.util.*;\nimport com.alibaba.fastjson.util.IdentityHashMap;\nimport com.alibaba.fastjson.util.ServiceLoader;\n\nimport javax.xml.datatype.XMLGregorianCalendar;\n\nimport static com.alibaba.fastjson.util.TypeUtils.fnv1a_64_magic_hashcode;\nimport static com.alibaba.fastjson.util.TypeUtils.fnv1a_64_magic_prime;\n\n/**\n * @author wenshao[szujobs@hotmail.com]\n */\npublic class ParserConfig {\n\n    public static final String    DENY_PROPERTY_INTERNAL    = \"fastjson.parser.deny.internal\";\n    public static final String    DENY_PROPERTY             = \"fastjson.parser.deny\";\n    public static final String    AUTOTYPE_ACCEPT           = \"fastjson.parser.autoTypeAccept\";\n    public static final String    AUTOTYPE_SUPPORT_PROPERTY = \"fastjson.parser.autoTypeSupport\";\n    public static final String    SAFE_MODE_PROPERTY        = \"fastjson.parser.safeMode\";\n\n    public static  final String[] DENYS_INTERNAL;\n    public static  final String[] DENYS;\n    private static final String[] AUTO_TYPE_ACCEPT_LIST;\n    public static  final boolean  AUTO_SUPPORT;\n    public static  final boolean  SAFE_MODE;\n    private static final long[]   INTERNAL_WHITELIST_HASHCODES;\n\n    static  {\n        {\n            String property = IOUtils.getStringProperty(DENY_PROPERTY_INTERNAL);\n            DENYS_INTERNAL = splitItemsFormProperty(property);\n        }\n        {\n            String property = IOUtils.getStringProperty(DENY_PROPERTY);\n            DENYS = splitItemsFormProperty(property);\n        }\n        {\n            String property = IOUtils.getStringProperty(AUTOTYPE_SUPPORT_PROPERTY);\n            AUTO_SUPPORT = \"true\".equals(property);\n        }\n        {\n            String property = IOUtils.getStringProperty(SAFE_MODE_PROPERTY);\n            SAFE_MODE = \"true\".equals(property);\n        }\n        {\n            String property = IOUtils.getStringProperty(AUTOTYPE_ACCEPT);\n            String[] items = splitItemsFormProperty(property);\n            if (items == null) {\n                items = new String[0];\n            }\n            AUTO_TYPE_ACCEPT_LIST = items;\n        }\n\n        INTERNAL_WHITELIST_HASHCODES = new long[] {\n                0x82E8E13016B73F9EL,\n                0x863D2DD1E82B9ED9L,\n                0x8B2081CB3A50BD44L,\n                0x90003416F28ACD89L,\n                0x92F252C398C02946L,\n                0x9E404E583F254FD4L,\n                0x9F2E20FB6049A371L,\n                0xA8AAA929446FFCE4L,\n                0xAB9B8D073948CA9DL,\n                0xAFCB539973CEA3F7L,\n                0xB5114C70135C4538L,\n                0xC0FE32B8DC897DE9L,\n                0xC59AA84D9A94C640L,\n                0xC92D8F9129AF339BL,\n                0xCC720543DC5E7090L,\n                0xD0E71A6E155603C1L,\n                0xD11D2A941337A7BCL,\n                0xDB7BFFC197369352L,\n                0xDC9583F0087CC2C7L,\n                0xDDAAA11FECA77B5EL,\n                0xE08EE874A26F5EAFL,\n                0xE794F5F7DCD3AC85L,\n                0xEB7D4786C473368DL,\n                0xF4AA683928027CDAL,\n                0xF8C7EF9B13231FB6L,\n                0xD45D6F8C9017FAL,\n                0x6B949CE6C2FE009L,\n                0x76566C052E83815L,\n                0x9DF9341F0C76702L,\n                0xB81BA299273D4E6L,\n                0xD4788669A13AE74L,\n                0x111D12921C5466DAL,\n                0x178B0E2DC3AE9FE5L,\n                0x19DCAF4ADC37D6D4L,\n                0x1F10A70EE4065963L,\n                0x21082DFBF63FBCC1L,\n                0x24AE2D07FB5D7497L,\n                0x26C5D923AF21E2E1L,\n                0x34CC8E52316FA0CBL,\n                0x3F64BC3933A6A2DFL,\n                0x42646E60EC7E5189L,\n                0x44D57A1B1EF53451L,\n                0x4A39C6C7ACB6AA18L,\n                0x4BB3C59964A2FC50L,\n                0x4F0C3688E8A18F9FL,\n                0x5449EC9B0280B9EFL,\n                0x54DC66A59269BAE1L,\n                0x552D9FB02FFC9DEFL,\n                0x557F642131553498L,\n                0x604D6657082C1EE9L,\n                0x61D10AF54471E5DEL,\n                0x64DC636F343516DCL,\n                0x73A0BE903F2BCBF4L,\n                0x73FBA1E41C4C3553L,\n                0x7B606F16A261E1E6L,\n                0x7F36112F218143B6L,\n                0x7FE2B8E675DA0CEFL\n        };\n    }\n\n    public static ParserConfig getGlobalInstance() {\n        return global;\n    }\n    public static ParserConfig                              global                = new ParserConfig();\n\n    private final IdentityHashMap<Type, ObjectDeserializer> deserializers         = new IdentityHashMap<Type, ObjectDeserializer>();\n    private final IdentityHashMap<Type, IdentityHashMap<Type, ObjectDeserializer>> mixInDeserializers = new IdentityHashMap<Type, IdentityHashMap<Type, ObjectDeserializer>>(16);\n    private final ConcurrentMap<String,Class<?>>            typeMapping           = new ConcurrentHashMap<String,Class<?>>(16, 0.75f, 1);\n\n    private boolean                                         asmEnable             = !ASMUtils.IS_ANDROID;\n\n    public final SymbolTable                                symbolTable           = new SymbolTable(4096);\n\n    public PropertyNamingStrategy                           propertyNamingStrategy;\n\n    protected ClassLoader                                   defaultClassLoader;\n\n    protected ASMDeserializerFactory                        asmFactory;\n\n    private static boolean                                  awtError              = false;\n    private static boolean                                  jdk8Error             = false;\n    private static boolean                                  jodaError             = false;\n    private static boolean                                  guavaError            = false;\n\n    private boolean                                         autoTypeSupport       = AUTO_SUPPORT;\n    private long[]                                          internalDenyHashCodes;\n    private long[]                                          denyHashCodes;\n    private long[]                                          acceptHashCodes;\n\n\n    public final boolean                                    fieldBased;\n    private boolean                                         jacksonCompatible     = false;\n\n    public boolean                                          compatibleWithJavaBean = TypeUtils.compatibleWithJavaBean;\n    private List<Module>                                    modules                = new ArrayList<Module>();\n    private volatile List<AutoTypeCheckHandler>             autoTypeCheckHandlers;\n    private boolean                                         safeMode               = SAFE_MODE;\n\n    {\n        denyHashCodes = new long[]{\n                0x80D0C70BCC2FEA02L,\n                0x868385095A22725FL,\n                0x86FC2BF9BEAF7AEFL,\n                0x87F52A1B07EA33A6L,\n                0x8872F29FD0B0B7A7L,\n                0x8BAAEE8F9BF77FA7L,\n                0x8EADD40CB2A94443L,\n                0x8F75F9FA0DF03F80L,\n                0x9172A53F157930AFL,\n                0x92122D710E364FB8L,\n                0x941866E73BEFF4C9L,\n                0x94305C26580F73C5L,\n                0x9437792831DF7D3FL,\n                0xA123A62F93178B20L,\n                0xA85882CE1044C450L,\n                0xAA3DAFFDB10C4937L,\n                0xAAA9E6B7C1E1C6A7L,\n                0xAAAA0826487A3737L,\n                0xAB82562F53E6E48FL,\n                0xAC6262F52C98AA39L,\n                0xAD937A449831E8A0L,\n                0xAE50DA1FAD60A096L,\n                0xAFF6FF23388E225AL,\n                0xAFFF4C95B99A334DL,\n                0xB40F341C746EC94FL,\n                0xB7E8ED757F5D13A2L,\n                0xB98B6B5396932FE9L,\n                0xBCDD9DC12766F0CEL,\n                0xBCE0DEE34E726499L,\n                0xBE4F13E96A6796D0L,\n                0xBEBA72FB1CCBA426L,\n                0xC00BE1DEBAF2808BL,\n                0xC1086AFAE32E6258L,\n                0xC2664D0958ECFE4CL,\n                0xC41FF7C9C87C7C05L,\n                0xC664B363BACA050AL,\n                0xC7599EBFE3E72406L,\n                0xC8D49E5601E661A9L,\n                0xC8F04B3A28909935L,\n                0xC963695082FD728EL,\n                0xCBF29CE484222325L,\n                0xD1EFCDF4B3316D34L,\n                0xD54B91CC77B239EDL,\n                0xD59EE91F0B09EA01L,\n                0xD66F68AB92E7FEF5L,\n                0xD8CA3D595E982BACL,\n                0xDCD8D615A6449E3EL,\n                0xDE23A0809A8B9BD6L,\n                0xDEFC208F237D4104L,\n                0xDF2DDFF310CDB375L,\n                0xE09AE4604842582FL,\n                0xE1919804D5BF468FL,\n                0xE2EB3AC7E56C467EL,\n                0xE603D6A51FAD692BL,\n                0xE704FD19052B2A34L,\n                0xE9184BE55B1D962AL,\n                0xE9F20BAD25F60807L,\n                0xED13653CB45C4BEDL,\n                0xF2983D099D29B477L,\n                0xF3702A4A5490B8E8L,\n                0xF474E44518F26736L,\n                0xF4D93F4FB3E3D991L,\n                0xF5D77DCF8E4D71E6L,\n                0xF6C0340E73A36A69L,\n                0xF7E96E74DFA58DBCL,\n                0xFC773AE20C827691L,\n                0xFCF3E78644B98BD8L,\n                0xFD5BFC610056D720L,\n                0xFFA15BF021F1E37CL,\n                0xFFDD1A80F1ED3405L,\n                0x10E067CD55C5E5L,\n                0x761619136CC13EL,\n                0x22BAA234C5BFB8AL,\n                0x3085068CB7201B8L,\n                0x45B11BC78A3ABA3L,\n                0x55CFCA0F2281C07L,\n                0xA555C74FE3A5155L,\n                0xB6E292FA5955ADEL,\n                0xBEF8514D0B79293L,\n                0xEE6511B66FD5EF0L,\n                0x100150A253996624L,\n                0x10B2BDCA849D9B3EL,\n                0x10DBC48446E0DAE5L,\n                0x119B5B1F10210AFCL,\n                0x144277B467723158L,\n                0x14DB2E6FEAD04AF0L,\n                0x154B6CB22D294CFAL,\n                0x17924CCA5227622AL,\n                0x193B2697EAAED41AL,\n                0x1CD6F11C6A358BB7L,\n                0x1E0A8C3358FF3DAEL,\n                0x24652CE717E713BBL,\n                0x24D2F6048FEF4E49L,\n                0x24EC99D5E7DC5571L,\n                0x25E962F1C28F71A2L,\n                0x275D0732B877AF29L,\n                0x28AC82E44E933606L,\n                0x2A71CE2CC40A710CL,\n                0x2AD1CE3A112F015DL,\n                0x2ADFEFBBFE29D931L,\n                0x2B3A37467A344CDFL,\n                0x2B6DD8B3229D6837L,\n                0x2D308DBBC851B0D8L,\n                0x2FE950D3EA52AE0DL,\n                0x313BB4ABD8D4554CL,\n                0x327C8ED7C8706905L,\n                0x332F0B5369A18310L,\n                0x339A3E0B6BEEBEE9L,\n                0x33C64B921F523F2FL,\n                0x33E7F3E02571B153L,\n                0x34A81EE78429FDF1L,\n                0x37317698DCFCE894L,\n                0x378307CB0111E878L,\n                0x3826F4B2380C8B9BL,\n                0x398F942E01920CF0L,\n                0x3A31412DBB05C7FFL,\n                0x3A7EE0635EB2BC33L,\n                0x3ADBA40367F73264L,\n                0x3B0B51ECBF6DB221L,\n                0x3BF14094A524F0E2L,\n                0x42D11A560FC9FBA9L,\n                0x43320DC9D2AE0892L,\n                0x440E89208F445FB9L,\n                0x46C808A4B5841F57L,\n                0x470FD3A18BB39414L,\n                0x49312BDAFB0077D9L,\n                0x4A3797B30328202CL,\n                0x4BA3E254E758D70DL,\n                0x4BF881E49D37F530L,\n                0x4CF54EEC05E3E818L,\n                0x4DA972745FEB30C1L,\n                0x4EF08C90FF16C675L,\n                0x4FD10DDC6D13821FL,\n                0x521B4F573376DF4AL,\n                0x527DB6B46CE3BCBCL,\n                0x535E552D6F9700C1L,\n                0x54855E265FE1DAD5L,\n                0x5728504A6D454FFCL,\n                0x599B5C1213A099ACL,\n                0x5A5BD85C072E5EFEL,\n                0x5AB0CB3071AB40D1L,\n                0x5B6149820275EA42L,\n                0x5D74D3E5B9370476L,\n                0x5D92E6DDDE40ED84L,\n                0x5E61093EF8CDDDBBL,\n                0x5F215622FB630753L,\n                0x61C5BDD721385107L,\n                0x62DB241274397C34L,\n                0x636ECCA2A131B235L,\n                0x63A220E60A17C7B9L,\n                0x647AB0224E149EBEL,\n                0x65F81B84C1D920CDL,\n                0x665C53C311193973L,\n                0x6749835432E0F0D2L,\n                0x69B6E0175084B377L,\n                0x6A47501EBB2AFDB2L,\n                0x6FCABF6FA54CAFFFL,\n                0x6FE92D83FC0A4628L,\n                0x746BD4A53EC195FBL,\n                0x74B50BB9260E31FFL,\n                0x75CC60F5871D0FD3L,\n                0x767A586A5107FEEFL,\n                0x78E5935826671397L,\n                0x793ADDDED7A967F5L,\n                0x7AA7EE3627A19CF3L,\n                0x7AFA070241B8CC4BL,\n                0x7ED9311D28BF1A65L,\n                0x7ED9481D28BF417AL,\n                0x7EE6C477DA20BBE3L\n        };\n\n        long[] hashCodes = new long[AUTO_TYPE_ACCEPT_LIST.length];\n        for (int i = 0; i < AUTO_TYPE_ACCEPT_LIST.length; i++) {\n            hashCodes[i] = TypeUtils.fnv1a_64(AUTO_TYPE_ACCEPT_LIST[i]);\n        }\n\n        Arrays.sort(hashCodes);\n        acceptHashCodes = hashCodes;\n    }\n\n    public ParserConfig(){\n        this(false);\n    }\n\n    public ParserConfig(boolean fieldBase){\n        this(null, null, fieldBase);\n    }\n\n    public ParserConfig(ClassLoader parentClassLoader){\n        this(null, parentClassLoader, false);\n    }\n\n    public ParserConfig(ASMDeserializerFactory asmFactory){\n        this(asmFactory, null, false);\n    }\n\n    private ParserConfig(ASMDeserializerFactory asmFactory, ClassLoader parentClassLoader, boolean fieldBased){\n        this.fieldBased = fieldBased;\n        if (asmFactory == null && !ASMUtils.IS_ANDROID) {\n            try {\n                if (parentClassLoader == null) {\n                    asmFactory = new ASMDeserializerFactory(new ASMClassLoader());\n                } else {\n                    asmFactory = new ASMDeserializerFactory(parentClassLoader);\n                }\n            } catch (ExceptionInInitializerError error) {\n                // skip\n            } catch (AccessControlException error) {\n                // skip\n            } catch (NoClassDefFoundError error) {\n                // skip\n            }\n        }\n\n        this.asmFactory = asmFactory;\n\n        if (asmFactory == null) {\n            asmEnable = false;\n        }\n\n        initDeserializers();\n\n        addItemsToDeny(DENYS);\n        addItemsToDeny0(DENYS_INTERNAL);\n        addItemsToAccept(AUTO_TYPE_ACCEPT_LIST);\n\n    }\n\n    private final Callable<Void> initDeserializersWithJavaSql = new Callable<Void>() {\n        public Void call() {\n            deserializers.put(java.sql.Timestamp.class, SqlDateDeserializer.instance_timestamp);\n            deserializers.put(java.sql.Date.class, SqlDateDeserializer.instance);\n            deserializers.put(java.sql.Time.class, TimeDeserializer.instance);\n            deserializers.put(java.util.Date.class, DateCodec.instance);\n            return null;\n        }\n    };\n\n    private void initDeserializers() {\n        deserializers.put(SimpleDateFormat.class, MiscCodec.instance);\n        deserializers.put(Calendar.class, CalendarCodec.instance);\n        deserializers.put(XMLGregorianCalendar.class, CalendarCodec.instance);\n\n        deserializers.put(JSONObject.class, MapDeserializer.instance);\n        deserializers.put(JSONArray.class, CollectionCodec.instance);\n\n        deserializers.put(Map.class, MapDeserializer.instance);\n        deserializers.put(HashMap.class, MapDeserializer.instance);\n        deserializers.put(LinkedHashMap.class, MapDeserializer.instance);\n        deserializers.put(TreeMap.class, MapDeserializer.instance);\n        deserializers.put(ConcurrentMap.class, MapDeserializer.instance);\n        deserializers.put(ConcurrentHashMap.class, MapDeserializer.instance);\n\n        deserializers.put(Collection.class, CollectionCodec.instance);\n        deserializers.put(List.class, CollectionCodec.instance);\n        deserializers.put(ArrayList.class, CollectionCodec.instance);\n\n        deserializers.put(Object.class, JavaObjectDeserializer.instance);\n        deserializers.put(String.class, StringCodec.instance);\n        deserializers.put(StringBuffer.class, StringCodec.instance);\n        deserializers.put(StringBuilder.class, StringCodec.instance);\n        deserializers.put(char.class, CharacterCodec.instance);\n        deserializers.put(Character.class, CharacterCodec.instance);\n        deserializers.put(byte.class, NumberDeserializer.instance);\n        deserializers.put(Byte.class, NumberDeserializer.instance);\n        deserializers.put(short.class, NumberDeserializer.instance);\n        deserializers.put(Short.class, NumberDeserializer.instance);\n        deserializers.put(int.class, IntegerCodec.instance);\n        deserializers.put(Integer.class, IntegerCodec.instance);\n        deserializers.put(long.class, LongCodec.instance);\n        deserializers.put(Long.class, LongCodec.instance);\n        deserializers.put(BigInteger.class, BigIntegerCodec.instance);\n        deserializers.put(BigDecimal.class, BigDecimalCodec.instance);\n        deserializers.put(float.class, FloatCodec.instance);\n        deserializers.put(Float.class, FloatCodec.instance);\n        deserializers.put(double.class, NumberDeserializer.instance);\n        deserializers.put(Double.class, NumberDeserializer.instance);\n        deserializers.put(boolean.class, BooleanCodec.instance);\n        deserializers.put(Boolean.class, BooleanCodec.instance);\n        deserializers.put(Class.class, MiscCodec.instance);\n        deserializers.put(char[].class, new CharArrayCodec());\n\n        deserializers.put(AtomicBoolean.class, BooleanCodec.instance);\n        deserializers.put(AtomicInteger.class, IntegerCodec.instance);\n        deserializers.put(AtomicLong.class, LongCodec.instance);\n        deserializers.put(AtomicReference.class, ReferenceCodec.instance);\n\n        deserializers.put(WeakReference.class, ReferenceCodec.instance);\n        deserializers.put(SoftReference.class, ReferenceCodec.instance);\n\n        deserializers.put(UUID.class, MiscCodec.instance);\n        deserializers.put(TimeZone.class, MiscCodec.instance);\n        deserializers.put(Locale.class, MiscCodec.instance);\n        deserializers.put(Currency.class, MiscCodec.instance);\n\n        deserializers.put(Inet4Address.class, MiscCodec.instance);\n        deserializers.put(Inet6Address.class, MiscCodec.instance);\n        deserializers.put(InetSocketAddress.class, MiscCodec.instance);\n        deserializers.put(File.class, MiscCodec.instance);\n        deserializers.put(URI.class, MiscCodec.instance);\n        deserializers.put(URL.class, MiscCodec.instance);\n        deserializers.put(Pattern.class, MiscCodec.instance);\n        deserializers.put(Charset.class, MiscCodec.instance);\n        deserializers.put(JSONPath.class, MiscCodec.instance);\n        deserializers.put(Number.class, NumberDeserializer.instance);\n        deserializers.put(AtomicIntegerArray.class, AtomicCodec.instance);\n        deserializers.put(AtomicLongArray.class, AtomicCodec.instance);\n        deserializers.put(StackTraceElement.class, StackTraceElementDeserializer.instance);\n\n        deserializers.put(Serializable.class, JavaObjectDeserializer.instance);\n        deserializers.put(Cloneable.class, JavaObjectDeserializer.instance);\n        deserializers.put(Comparable.class, JavaObjectDeserializer.instance);\n        deserializers.put(Closeable.class, JavaObjectDeserializer.instance);\n\n        deserializers.put(JSONPObject.class, new JSONPDeserializer());\n        ModuleUtil.callWhenHasJavaSql(initDeserializersWithJavaSql);\n    }\n\n    private static String[] splitItemsFormProperty(final String property ){\n        if (property != null && property.length() > 0) {\n            return property.split(\",\");\n        }\n        return null;\n    }\n\n    public void configFromPropety(Properties properties) {\n        {\n            String property = properties.getProperty(DENY_PROPERTY);\n            String[] items = splitItemsFormProperty(property);\n            addItemsToDeny(items);\n        }\n        {\n            String property = properties.getProperty(AUTOTYPE_ACCEPT);\n            String[] items = splitItemsFormProperty(property);\n            addItemsToAccept(items);\n        }\n        {\n            String property = properties.getProperty(AUTOTYPE_SUPPORT_PROPERTY);\n            if (\"true\".equals(property)) {\n                this.autoTypeSupport = true;\n            } else if (\"false\".equals(property)) {\n                this.autoTypeSupport = false;\n            }\n        }\n    }\n\n    private void addItemsToDeny0(final String[] items){\n        if (items == null){\n            return;\n        }\n\n        for (int i = 0; i < items.length; ++i) {\n            String item = items[i];\n            this.addDenyInternal(item);\n        }\n    }\n\n    private void addItemsToDeny(final String[] items){\n        if (items == null){\n            return;\n        }\n\n        for (int i = 0; i < items.length; ++i) {\n            String item = items[i];\n            this.addDeny(item);\n        }\n    }\n\n    private void addItemsToAccept(final String[] items){\n        if (items == null){\n            return;\n        }\n\n        for (int i = 0; i < items.length; ++i) {\n            String item = items[i];\n            this.addAccept(item);\n        }\n    }\n\n    /**\n     * @since 1.2.68\n     */\n    public boolean isSafeMode() {\n        return safeMode;\n    }\n\n    /**\n     * @since 1.2.68\n     */\n    public void setSafeMode(boolean safeMode) {\n        this.safeMode = safeMode;\n    }\n\n    public boolean isAutoTypeSupport() {\n        return autoTypeSupport;\n    }\n\n    public void setAutoTypeSupport(boolean autoTypeSupport) {\n        this.autoTypeSupport = autoTypeSupport;\n    }\n\n    public boolean isAsmEnable() {\n        return asmEnable;\n    }\n\n    public void setAsmEnable(boolean asmEnable) {\n        this.asmEnable = asmEnable;\n    }\n\n    /**\n     * @deprecated\n     */\n    public IdentityHashMap<Type, ObjectDeserializer> getDerializers() {\n        return deserializers;\n    }\n\n    public IdentityHashMap<Type, ObjectDeserializer> getDeserializers() {\n        return deserializers;\n    }\n\n    public ObjectDeserializer getDeserializer(Type type) {\n        ObjectDeserializer deserializer = get(type);\n        if (deserializer != null) {\n            return deserializer;\n        }\n\n        if (type instanceof Class<?>) {\n            return getDeserializer((Class<?>) type, type);\n        }\n\n        if (type instanceof ParameterizedType) {\n            Type rawType = ((ParameterizedType) type).getRawType();\n            if (rawType instanceof Class<?>) {\n                return getDeserializer((Class<?>) rawType, type);\n            } else {\n                return getDeserializer(rawType);\n            }\n        }\n\n        if (type instanceof WildcardType) {\n            WildcardType wildcardType = (WildcardType) type;\n            Type[] upperBounds = wildcardType.getUpperBounds();\n            if (upperBounds.length == 1) {\n                Type upperBoundType = upperBounds[0];\n                return getDeserializer(upperBoundType);\n            }\n        }\n\n        return JavaObjectDeserializer.instance;\n    }\n\n    public ObjectDeserializer getDeserializer(Class<?> clazz, Type type) {\n        ObjectDeserializer deserializer = get(type);\n        if (deserializer == null && type instanceof ParameterizedTypeImpl) {\n            Type innerType = TypeReference.intern((ParameterizedTypeImpl) type);\n            deserializer = get(innerType);\n        }\n\n        if (deserializer != null) {\n            return deserializer;\n        }\n\n        if (type == null) {\n            type = clazz;\n        }\n\n        deserializer = get(type);\n        if (deserializer != null) {\n            return deserializer;\n        }\n\n        {\n            JSONType annotation = TypeUtils.getAnnotation(clazz,JSONType.class);\n            if (annotation != null) {\n                Class<?> mappingTo = annotation.mappingTo();\n                if (mappingTo != Void.class) {\n                    return getDeserializer(mappingTo, mappingTo);\n                }\n            }\n        }\n\n        if (type instanceof WildcardType || type instanceof TypeVariable || type instanceof ParameterizedType) {\n            deserializer = get(clazz);\n        }\n\n        if (deserializer != null) {\n            return deserializer;\n        }\n\n        for (Module module : modules) {\n            deserializer = module.createDeserializer(this, clazz);\n            if (deserializer != null) {\n                putDeserializer(type, deserializer);\n                return deserializer;\n            }\n        }\n\n        String className = clazz.getName();\n        className = className.replace('$', '.');\n\n        if (className.startsWith(\"java.awt.\") //\n            && AwtCodec.support(clazz)) {\n            if (!awtError) {\n                String[] names = new String[] {\n                        \"java.awt.Point\",\n                        \"java.awt.Font\",\n                        \"java.awt.Rectangle\",\n                        \"java.awt.Color\"\n                };\n\n                try {\n                    for (String name : names) {\n                        if (name.equals(className)) {\n                            putDeserializer(Class.forName(name), deserializer = AwtCodec.instance);\n                            return deserializer;\n                        }\n                    }\n                } catch (Throwable e) {\n                    // skip\n                    awtError = true;\n                }\n\n                deserializer = AwtCodec.instance;\n            }\n        }\n\n        if (!jdk8Error) {\n            try {\n                if (className.startsWith(\"java.time.\")) {\n                    String[] names = new String[] {\n                            \"java.time.LocalDateTime\",\n                            \"java.time.LocalDate\",\n                            \"java.time.LocalTime\",\n                            \"java.time.ZonedDateTime\",\n                            \"java.time.OffsetDateTime\",\n                            \"java.time.OffsetTime\",\n                            \"java.time.ZoneOffset\",\n                            \"java.time.ZoneRegion\",\n                            \"java.time.ZoneId\",\n                            \"java.time.Period\",\n                            \"java.time.Duration\",\n                            \"java.time.Instant\"\n                    };\n\n                    for (String name : names) {\n                        if (name.equals(className)) {\n                            putDeserializer(Class.forName(name), deserializer = Jdk8DateCodec.instance);\n                            return deserializer;\n                        }\n                    }\n                } else if (className.startsWith(\"java.util.Optional\")) {\n                    String[] names = new String[] {\n                            \"java.util.Optional\",\n                            \"java.util.OptionalDouble\",\n                            \"java.util.OptionalInt\",\n                            \"java.util.OptionalLong\"\n                    };\n                    for (String name : names) {\n                        if (name.equals(className)) {\n                            putDeserializer(Class.forName(name), deserializer = OptionalCodec.instance);\n                            return deserializer;\n                        }\n                    }\n                }\n            } catch (Throwable e) {\n                // skip\n                jdk8Error = true;\n            }\n        }\n\n        if (!jodaError) {\n            try {\n                if (className.startsWith(\"org.joda.time.\")) {\n                    String[] names = new String[] {\n                            \"org.joda.time.DateTime\",\n                            \"org.joda.time.LocalDate\",\n                            \"org.joda.time.LocalDateTime\",\n                            \"org.joda.time.LocalTime\",\n                            \"org.joda.time.Instant\",\n                            \"org.joda.time.Period\",\n                            \"org.joda.time.Duration\",\n                            \"org.joda.time.DateTimeZone\",\n                            \"org.joda.time.format.DateTimeFormatter\"\n                    };\n\n                    for (String name : names) {\n                        if (name.equals(className)) {\n                            putDeserializer(Class.forName(name), deserializer = JodaCodec.instance);\n                            return deserializer;\n                        }\n                    }\n                }\n            } catch (Throwable e) {\n                // skip\n                jodaError = true;\n            }\n        }\n\n        if ((!guavaError) //\n                && className.startsWith(\"com.google.common.collect.\")) {\n            try {\n                String[] names = new String[] {\n                        \"com.google.common.collect.HashMultimap\",\n                        \"com.google.common.collect.LinkedListMultimap\",\n                        \"com.google.common.collect.LinkedHashMultimap\",\n                        \"com.google.common.collect.ArrayListMultimap\",\n                        \"com.google.common.collect.TreeMultimap\"\n                };\n\n                for (String name : names) {\n                    if (name.equals(className)) {\n                        putDeserializer(Class.forName(name), deserializer = GuavaCodec.instance);\n                        return deserializer;\n                    }\n                }\n            } catch (ClassNotFoundException e) {\n                // skip\n                guavaError = true;\n            }\n        }\n\n        if (className.equals(\"java.nio.ByteBuffer\")) {\n            putDeserializer(clazz, deserializer = ByteBufferCodec.instance);\n        }\n\n        if (className.equals(\"java.nio.file.Path\")) {\n            putDeserializer(clazz, deserializer = MiscCodec.instance);\n        }\n\n        if (clazz == Map.Entry.class) {\n            putDeserializer(clazz, deserializer = MiscCodec.instance);\n        }\n\n        if (className.equals(\"org.javamoney.moneta.Money\")) {\n            putDeserializer(clazz, deserializer = MonetaCodec.instance);\n        }\n\n        final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        try {\n            for (AutowiredObjectDeserializer autowired : ServiceLoader.load(AutowiredObjectDeserializer.class,\n                                                                            classLoader)) {\n                for (Type forType : autowired.getAutowiredFor()) {\n                    putDeserializer(forType, autowired);\n                }\n            }\n        } catch (Exception ex) {\n            // skip\n        }\n\n        if (deserializer == null) {\n            deserializer = get(type);\n        }\n\n        if (deserializer != null) {\n            return deserializer;\n        }\n\n        if (clazz.isEnum()) {\n            if (jacksonCompatible) {\n                Method[] methods = clazz.getMethods();\n                for (Method method : methods) {\n                    if (TypeUtils.isJacksonCreator(method)) {\n                        deserializer = createJavaBeanDeserializer(clazz, type);\n                        putDeserializer(type, deserializer);\n                        return deserializer;\n                    }\n                }\n            }\n\n            Class mixInType = (Class) JSON.getMixInAnnotations(clazz);\n\n            Class<?> deserClass = null;\n            JSONType jsonType = TypeUtils.getAnnotation(mixInType != null ? mixInType : clazz, JSONType.class);\n\n            if (jsonType != null) {\n                deserClass = jsonType.deserializer();\n                try {\n                    deserializer = (ObjectDeserializer) deserClass.newInstance();\n                    putDeserializer(clazz, deserializer);\n                    return deserializer;\n                } catch (Throwable error) {\n                    // skip\n                }\n            }\n\n            Method jsonCreatorMethod = null;\n            if (mixInType != null) {\n                Method mixedCreator = getEnumCreator(mixInType, clazz);\n                if (mixedCreator != null) {\n                    try {\n                        jsonCreatorMethod = clazz.getMethod(mixedCreator.getName(), mixedCreator.getParameterTypes());\n                    } catch (Exception e) {\n                        // skip\n                    }\n                }\n            } else {\n                jsonCreatorMethod = getEnumCreator(clazz, clazz);\n            }\n\n            if (jsonCreatorMethod != null) {\n                deserializer = new EnumCreatorDeserializer(jsonCreatorMethod);\n                putDeserializer(clazz, deserializer);\n                return deserializer;\n            }\n\n            deserializer = getEnumDeserializer(clazz);\n        } else if (clazz.isArray()) {\n            deserializer = ObjectArrayCodec.instance;\n        } else if (clazz == Set.class || clazz == HashSet.class || clazz == Collection.class || clazz == List.class\n                   || clazz == ArrayList.class) {\n            deserializer = CollectionCodec.instance;\n        } else if (Collection.class.isAssignableFrom(clazz)) {\n            deserializer = CollectionCodec.instance;\n        } else if (Map.class.isAssignableFrom(clazz)) {\n            deserializer = MapDeserializer.instance;\n        } else if (Throwable.class.isAssignableFrom(clazz)) {\n            deserializer = new ThrowableDeserializer(this, clazz);\n        } else if (PropertyProcessable.class.isAssignableFrom(clazz)) {\n            deserializer = new PropertyProcessableDeserializer((Class<PropertyProcessable>) clazz);\n        } else if (clazz == InetAddress.class) {\n            deserializer = MiscCodec.instance;\n        } else {\n            deserializer = createJavaBeanDeserializer(clazz, type);\n        }\n\n        putDeserializer(type, deserializer);\n\n        return deserializer;\n    }\n\n    private static Method getEnumCreator(Class clazz, Class enumClass) {\n        Method[] methods = clazz.getMethods();\n        Method jsonCreatorMethod = null;\n        for (Method method : methods) {\n            if (Modifier.isStatic(method.getModifiers())\n                    && method.getReturnType() == enumClass\n                    && method.getParameterTypes().length == 1\n            ) {\n                JSONCreator jsonCreator = method.getAnnotation(JSONCreator.class);\n                if (jsonCreator != null) {\n                    jsonCreatorMethod = method;\n                    break;\n                }\n            }\n        }\n\n        return jsonCreatorMethod;\n    }\n\n    /**\n     * \u53ef\u4ee5\u901a\u8fc7\u91cd\u5199\u8fd9\u4e2a\u65b9\u6cd5\uff0c\u5b9a\u4e49\u81ea\u5df1\u7684\u679a\u4e3e\u53cd\u5e8f\u5217\u5316\u5b9e\u73b0\n     * @param clazz \u8f6c\u6362\u7684\u7c7b\u578b\n     * @return \u8fd4\u56de\u4e00\u4e2a\u679a\u4e3e\u7684\u53cd\u5e8f\u5217\u5316\u5b9e\u73b0\n     * @author zhu.xiaojie\n     * @time 2020-4-5\n     */\n    protected ObjectDeserializer getEnumDeserializer(Class<?> clazz){\n        return new EnumDeserializer(clazz);\n    }\n\n    /**\n     *\n     * @since 1.2.25\n     */\n    public void initJavaBeanDeserializers(Class<?>... classes) {\n        if (classes == null) {\n            return;\n        }\n\n        for (Class<?> type : classes) {\n            if (type == null) {\n                continue;\n            }\n            ObjectDeserializer deserializer = createJavaBeanDeserializer(type, type);\n            putDeserializer(type, deserializer);\n        }\n    }\n\n    public ObjectDeserializer createJavaBeanDeserializer(Class<?> clazz, Type type) {\n        boolean asmEnable = this.asmEnable & !this.fieldBased;\n        if (asmEnable) {\n            JSONType jsonType = TypeUtils.getAnnotation(clazz,JSONType.class);\n\n            if (jsonType != null) {\n                Class<?> deserializerClass = jsonType.deserializer();\n                if (deserializerClass != Void.class) {\n                    try {\n                        Object deseralizer = deserializerClass.newInstance();\n                        if (deseralizer instanceof ObjectDeserializer) {\n                            return (ObjectDeserializer) deseralizer;\n                        }\n                    } catch (Throwable e) {\n                        // skip\n                    }\n                }\n\n                asmEnable = jsonType.asm()\n                        && jsonType.parseFeatures().length == 0;\n            }\n\n            if (asmEnable) {\n                Class<?> superClass = JavaBeanInfo.getBuilderClass(clazz, jsonType);\n                if (superClass == null) {\n                    superClass = clazz;\n                }\n\n                for (;;) {\n                    if (!Modifier.isPublic(superClass.getModifiers())) {\n                        asmEnable = false;\n                        break;\n                    }\n\n                    superClass = superClass.getSuperclass();\n                    if (superClass == Object.class || superClass == null) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (clazz.getTypeParameters().length != 0) {\n            asmEnable = false;\n        }\n\n        if (asmEnable && asmFactory != null && asmFactory.classLoader.isExternalClass(clazz)) {\n            asmEnable = false;\n        }\n\n        if (asmEnable) {\n            asmEnable = ASMUtils.checkName(clazz.getSimpleName());\n        }\n\n        if (asmEnable) {\n            if (clazz.isInterface()) {\n                asmEnable = false;\n            }\n            JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz\n                    , type\n                    , propertyNamingStrategy\n                    ,false\n                    , TypeUtils.compatibleWithJavaBean\n                    , jacksonCompatible\n            );\n\n            if (asmEnable && beanInfo.fields.length > 200) {\n                asmEnable = false;\n            }\n\n            Constructor<?> defaultConstructor = beanInfo.defaultConstructor;\n            if (asmEnable && defaultConstructor == null && !clazz.isInterface()) {\n                asmEnable = false;\n            }\n\n            for (FieldInfo fieldInfo : beanInfo.fields) {\n                if (fieldInfo.getOnly) {\n                    asmEnable = false;\n                    break;\n                }\n\n                Class<?> fieldClass = fieldInfo.fieldClass;\n                if (!Modifier.isPublic(fieldClass.getModifiers())) {\n                    asmEnable = false;\n                    break;\n                }\n\n                if (fieldClass.isMemberClass() && !Modifier.isStatic(fieldClass.getModifiers())) {\n                    asmEnable = false;\n                    break;\n                }\n\n                if (fieldInfo.getMember() != null //\n                    && !ASMUtils.checkName(fieldInfo.getMember().getName())) {\n                    asmEnable = false;\n                    break;\n                }\n\n                JSONField annotation = fieldInfo.getAnnotation();\n                if (annotation != null //\n                    && ((!ASMUtils.checkName(annotation.name())) //\n                        || annotation.format().length() != 0 //\n                        || annotation.deserializeUsing() != Void.class //\n                        || annotation.parseFeatures().length != 0 //\n                        || annotation.unwrapped())\n                        || (fieldInfo.method != null && fieldInfo.method.getParameterTypes().length > 1)) {\n                    asmEnable = false;\n                    break;\n                }\n\n                if (fieldClass.isEnum()) { // EnumDeserializer\n                    ObjectDeserializer fieldDeser = this.getDeserializer(fieldClass);\n                    if (!(fieldDeser instanceof EnumDeserializer)) {\n                        asmEnable = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (asmEnable) {\n            if (clazz.isMemberClass() && !Modifier.isStatic(clazz.getModifiers())) {\n                asmEnable = false;\n            }\n        }\n\n        if (asmEnable) {\n            if (TypeUtils.isXmlField(clazz)) {\n                asmEnable = false;\n            }\n        }\n\n        if (!asmEnable) {\n            return new JavaBeanDeserializer(this, clazz, type);\n        }\n\n        JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz, type, propertyNamingStrategy);\n        try {\n            return asmFactory.createJavaBeanDeserializer(this, beanInfo);\n            // } catch (VerifyError e) {\n            // e.printStackTrace();\n            // return new JavaBeanDeserializer(this, clazz, type);\n        } catch (NoSuchMethodException ex) {\n            return new JavaBeanDeserializer(this, clazz, type);\n        } catch (JSONException asmError) {\n            return new JavaBeanDeserializer(this, beanInfo);\n        } catch (Exception e) {\n            throw new JSONException(\"create asm deserializer error, \" + clazz.getName(), e);\n        }\n    }\n\n    public FieldDeserializer createFieldDeserializer(ParserConfig mapping, //\n                                                     JavaBeanInfo beanInfo, //\n                                                     FieldInfo fieldInfo) {\n        Class<?> clazz = beanInfo.clazz;\n        Class<?> fieldClass = fieldInfo.fieldClass;\n\n        Class<?> deserializeUsing = null;\n        JSONField annotation = fieldInfo.getAnnotation();\n        if (annotation != null) {\n            deserializeUsing = annotation.deserializeUsing();\n            if (deserializeUsing == Void.class) {\n                deserializeUsing = null;\n            }\n        }\n\n        if (deserializeUsing == null && (fieldClass == List.class || fieldClass == ArrayList.class)) {\n            return new ArrayListTypeFieldDeserializer(mapping, clazz, fieldInfo);\n        }\n\n        return new DefaultFieldDeserializer(mapping, clazz, fieldInfo);\n    }\n\n    public void putDeserializer(Type type, ObjectDeserializer deserializer) {\n        Type mixin = JSON.getMixInAnnotations(type);\n        if (mixin != null) {\n            IdentityHashMap<Type, ObjectDeserializer> mixInClasses = this.mixInDeserializers.get(type);\n            if (mixInClasses == null) {\n                //\u591a\u7ebf\u7a0b\u4e0b\u53ef\u80fd\u4f1a\u91cd\u590d\u521b\u5efa\uff0c\u4f46\u4e0d\u5f71\u54cd\u6b63\u786e\u6027\n                mixInClasses = new IdentityHashMap<Type, ObjectDeserializer>(4);\n                this.mixInDeserializers.put(type, mixInClasses);\n            }\n            mixInClasses.put(mixin, deserializer);\n        } else {\n            this.deserializers.put(type, deserializer);\n        }\n    }\n\n    public ObjectDeserializer get(Type type) {\n        Type mixin = JSON.getMixInAnnotations(type);\n        if (null == mixin) {\n            return this.deserializers.get(type);\n        }\n        IdentityHashMap<Type, ObjectDeserializer> mixInClasses = this.mixInDeserializers.get(type);\n        if (mixInClasses == null) {\n            return null;\n        }\n        return mixInClasses.get(mixin);\n    }\n\n    public ObjectDeserializer getDeserializer(FieldInfo fieldInfo) {\n        return getDeserializer(fieldInfo.fieldClass, fieldInfo.fieldType);\n    }\n\n    /**\n     * @deprecated  internal method, dont call\n     */\n    public boolean isPrimitive(Class<?> clazz) {\n        return isPrimitive2(clazz);\n    }\n\n    private static Function<Class<?>, Boolean> isPrimitiveFuncation = new Function<Class<?>, Boolean>() {\n        public Boolean apply(Class<?> clazz) {\n            return clazz == java.sql.Date.class //\n                    || clazz == java.sql.Time.class //\n                    || clazz == java.sql.Timestamp.class;\n        }\n    };\n\n    /**\n     * @deprecated  internal method, dont call\n     */\n    public static boolean isPrimitive2(final Class<?> clazz) {\n        Boolean primitive = clazz.isPrimitive() //\n                || clazz == Boolean.class //\n                || clazz == Character.class //\n                || clazz == Byte.class //\n                || clazz == Short.class //\n                || clazz == Integer.class //\n                || clazz == Long.class //\n                || clazz == Float.class //\n                || clazz == Double.class //\n                || clazz == BigInteger.class //\n                || clazz == BigDecimal.class //\n                || clazz == String.class //\n                || clazz == java.util.Date.class //\n                || clazz.isEnum() //\n                ;\n        if (!primitive) {\n            primitive = ModuleUtil.callWhenHasJavaSql(isPrimitiveFuncation, clazz);\n        }\n        return primitive != null ? primitive : false;\n    }\n\n    /**\n     * fieldName,field \uff0c\u5148\u751f\u6210fieldName\u7684\u5feb\u7167\uff0c\u51cf\u5c11\u4e4b\u540e\u7684findField\u7684\u8f6e\u8be2\n     *\n     * @param clazz\n     * @param fieldCacheMap :map&lt;fieldName ,Field&gt;\n     */\n    public static void  parserAllFieldToCache(Class<?> clazz,Map</**fieldName*/String , Field> fieldCacheMap){\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (!fieldCacheMap.containsKey(fieldName)) {\n                fieldCacheMap.put(fieldName, field);\n            }\n        }\n        if (clazz.getSuperclass() != null && clazz.getSuperclass() != Object.class) {\n            parserAllFieldToCache(clazz.getSuperclass(), fieldCacheMap);\n        }\n    }\n\n    public static Field getFieldFromCache(String fieldName, Map<String, Field> fieldCacheMap) {\n        Field field = fieldCacheMap.get(fieldName);\n\n        if (field == null) {\n            field = fieldCacheMap.get(\"_\" + fieldName);\n        }\n\n        if (field == null) {\n            field = fieldCacheMap.get(\"m_\" + fieldName);\n        }\n\n        if (field == null) {\n            char c0 = fieldName.charAt(0);\n            if (c0 >= 'a' && c0 <= 'z') {\n                char[] chars = fieldName.toCharArray();\n                chars[0] -= 32; // lower\n                String fieldNameX = new String(chars);\n                field = fieldCacheMap.get(fieldNameX);\n            }\n\n            if (fieldName.length() > 2) {\n                char c1 = fieldName.charAt(1);\n                if (c0 >= 'a' && c0 <= 'z'\n                        && c1 >= 'A' && c1 <= 'Z') {\n                    for (Map.Entry<String, Field> entry : fieldCacheMap.entrySet()) {\n                        if (fieldName.equalsIgnoreCase(entry.getKey())) {\n                            field = entry.getValue();\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return field;\n    }\n\n    public ClassLoader getDefaultClassLoader() {\n        return defaultClassLoader;\n    }\n\n    public void setDefaultClassLoader(ClassLoader defaultClassLoader) {\n        this.defaultClassLoader = defaultClassLoader;\n    }\n\n    public void addDenyInternal(String name) {\n        if (name == null || name.length() == 0) {\n            return;\n        }\n\n        long hash = TypeUtils.fnv1a_64(name);\n        if (internalDenyHashCodes == null) {\n            this.internalDenyHashCodes = new long[] {hash};\n            return;\n        }\n\n        if (Arrays.binarySearch(this.internalDenyHashCodes, hash) >= 0) {\n            return;\n        }\n\n        long[] hashCodes = new long[this.internalDenyHashCodes.length + 1];\n        hashCodes[hashCodes.length - 1] = hash;\n        System.arraycopy(this.internalDenyHashCodes, 0, hashCodes, 0, this.internalDenyHashCodes.length);\n        Arrays.sort(hashCodes);\n        this.internalDenyHashCodes = hashCodes;\n    }\n\n    public void addDeny(String name) {\n        if (name == null || name.length() == 0) {\n            return;\n        }\n\n        long hash = TypeUtils.fnv1a_64(name);\n        if (Arrays.binarySearch(this.denyHashCodes, hash) >= 0) {\n            return;\n        }\n\n        long[] hashCodes = new long[this.denyHashCodes.length + 1];\n        hashCodes[hashCodes.length - 1] = hash;\n        System.arraycopy(this.denyHashCodes, 0, hashCodes, 0, this.denyHashCodes.length);\n        Arrays.sort(hashCodes);\n        this.denyHashCodes = hashCodes;\n    }\n\n    public void addAccept(String name) {\n        if (name == null || name.length() == 0) {\n            return;\n        }\n\n        long hash = TypeUtils.fnv1a_64(name);\n        if (Arrays.binarySearch(this.acceptHashCodes, hash) >= 0) {\n            return;\n        }\n\n        long[] hashCodes = new long[this.acceptHashCodes.length + 1];\n        hashCodes[hashCodes.length - 1] = hash;\n        System.arraycopy(this.acceptHashCodes, 0, hashCodes, 0, this.acceptHashCodes.length);\n        Arrays.sort(hashCodes);\n        this.acceptHashCodes = hashCodes;\n    }\n\n    public Class<?> checkAutoType(Class type) {\n        if (get(type) != null) {\n            return type;\n        }\n\n        return checkAutoType(type.getName(), null, JSON.DEFAULT_PARSER_FEATURE);\n    }\n\n    public Class<?> checkAutoType(String typeName, Class<?> expectClass) {\n        return checkAutoType(typeName, expectClass, JSON.DEFAULT_PARSER_FEATURE);\n    }\n\n    public Class<?> checkAutoType(String typeName, Class<?> expectClass, int features) {\n        if (typeName == null) {\n            return null;\n        }\n\n        if (autoTypeCheckHandlers != null) {\n            for (AutoTypeCheckHandler h : autoTypeCheckHandlers) {\n                Class<?> type = h.handler(typeName, expectClass, features);\n                if (type != null) {\n                    return type;\n                }\n            }\n        }\n\n        final int safeModeMask = Feature.SafeMode.mask;\n        boolean safeMode = this.safeMode\n                || (features & safeModeMask) != 0\n                || (JSON.DEFAULT_PARSER_FEATURE & safeModeMask) != 0;\n        if (safeMode) {\n            throw new JSONException(\"safeMode not support autoType : \" + typeName);\n        }\n\n        if (typeName.length() >= 192 || typeName.length() < 3) {\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        final boolean expectClassFlag;\n        if (expectClass == null) {\n            expectClassFlag = false;\n        } else {\n            long expectHash = TypeUtils.fnv1a_64(expectClass.getName());\n            if (expectHash == 0x90a25f5baa21529eL\n                    || expectHash == 0x2d10a5801b9d6136L\n                    || expectHash == 0xaf586a571e302c6bL\n                    || expectHash == 0xed007300a7b227c6L\n                    || expectHash == 0x295c4605fd1eaa95L\n                    || expectHash == 0x47ef269aadc650b4L\n                    || expectHash == 0x6439c4dff712ae8bL\n                    || expectHash == 0xe3dd9875a2dc5283L\n                    || expectHash == 0xe2a8ddba03e69e0dL\n                    || expectHash == 0xd734ceb4c3e9d1daL\n            ) {\n                expectClassFlag = false;\n            } else {\n                expectClassFlag = true;\n            }\n        }\n\n        String className = typeName.replace('$', '.');\n        Class<?> clazz;\n\n        final long h1 = (fnv1a_64_magic_hashcode ^ className.charAt(0)) * fnv1a_64_magic_prime;\n        if (h1 == 0xaf64164c86024f1aL) { // [\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        if ((h1 ^ className.charAt(className.length() - 1)) * fnv1a_64_magic_prime == 0x9198507b5af98f0L) {\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        final long h3 = (((((fnv1a_64_magic_hashcode ^ className.charAt(0))\n                * fnv1a_64_magic_prime)\n                ^ className.charAt(1))\n                * fnv1a_64_magic_prime)\n                ^ className.charAt(2))\n                * fnv1a_64_magic_prime;\n\n        long fullHash = TypeUtils.fnv1a_64(className);\n        boolean internalWhite = Arrays.binarySearch(INTERNAL_WHITELIST_HASHCODES,  fullHash) >= 0;\n\n        if (internalDenyHashCodes != null) {\n            long hash = h3;\n            for (int i = 3; i < className.length(); ++i) {\n                hash ^= className.charAt(i);\n                hash *= fnv1a_64_magic_prime;\n                if (Arrays.binarySearch(internalDenyHashCodes, hash) >= 0) {\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n            }\n        }\n\n        if ((!internalWhite) && (autoTypeSupport || expectClassFlag)) {\n            long hash = h3;\n            for (int i = 3; i < className.length(); ++i) {\n                hash ^= className.charAt(i);\n                hash *= fnv1a_64_magic_prime;\n                if (Arrays.binarySearch(acceptHashCodes, hash) >= 0) {\n                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);\n                    if (clazz != null) {\n                        return clazz;\n                    }\n                }\n                if (Arrays.binarySearch(denyHashCodes, hash) >= 0 && TypeUtils.getClassFromMapping(typeName) == null) {\n                    if (Arrays.binarySearch(acceptHashCodes, fullHash) >= 0) {\n                        continue;\n                    }\n\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n            }\n        }\n\n        clazz = TypeUtils.getClassFromMapping(typeName);\n\n        if (clazz == null) {\n            clazz = deserializers.findClass(typeName);\n        }\n\n        if (expectClass == null && clazz != null && Throwable.class.isAssignableFrom(clazz) && !autoTypeSupport) {\n            clazz = null;\n        }\n\n        if (clazz == null) {\n            clazz = typeMapping.get(typeName);\n        }\n\n        if (internalWhite) {\n            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);\n        }\n\n        if (clazz != null) {\n            if (expectClass != null\n                    && clazz != java.util.HashMap.class\n                    && clazz != java.util.LinkedHashMap.class\n                    && !expectClass.isAssignableFrom(clazz)) {\n                throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n            }\n\n            return clazz;\n        }\n\n        if (!autoTypeSupport) {\n            long hash = h3;\n            for (int i = 3; i < className.length(); ++i) {\n                char c = className.charAt(i);\n                hash ^= c;\n                hash *= fnv1a_64_magic_prime;\n\n                if (Arrays.binarySearch(denyHashCodes, hash) >= 0) {\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n\n                // white list\n                if (Arrays.binarySearch(acceptHashCodes, hash) >= 0) {\n                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);\n\n                    if (clazz == null) {\n                        return expectClass;\n                    }\n\n                    if (expectClass != null && expectClass.isAssignableFrom(clazz)) {\n                        throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n                    }\n\n                    return clazz;\n                }\n            }\n        }\n\n        boolean jsonType = false;\n        InputStream is = null;\n        try {\n            String resource = typeName.replace('.', '/') + \".class\";\n            if (defaultClassLoader != null) {\n                is = defaultClassLoader.getResourceAsStream(resource);\n            } else {\n                is = ParserConfig.class.getClassLoader().getResourceAsStream(resource);\n            }\n            if (is != null) {\n                ClassReader classReader = new ClassReader(is, true);\n                TypeCollector visitor = new TypeCollector(\"<clinit>\", new Class[0]);\n                classReader.accept(visitor);\n                jsonType = visitor.hasJsonType();\n            }\n        } catch (Exception e) {\n            // skip\n        } finally {\n            IOUtils.close(is);\n        }\n\n        final int mask = Feature.SupportAutoType.mask;\n        boolean autoTypeSupport = this.autoTypeSupport\n                || (features & mask) != 0\n                || (JSON.DEFAULT_PARSER_FEATURE & mask) != 0;\n\n        if (autoTypeSupport || jsonType || expectClassFlag) {\n            boolean cacheClass = autoTypeSupport || jsonType;\n            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, cacheClass);\n        }\n\n        if (clazz != null) {\n            if (jsonType) {\n                TypeUtils.addMapping(typeName, clazz);\n                return clazz;\n            }\n\n            if (ClassLoader.class.isAssignableFrom(clazz) // classloader is danger\n                    || javax.sql.DataSource.class.isAssignableFrom(clazz) // dataSource can load jdbc driver\n                    || javax.sql.RowSet.class.isAssignableFrom(clazz) //\n                    ) {\n                throw new JSONException(\"autoType is not support. \" + typeName);\n            }\n\n            if (expectClass != null) {\n                if (expectClass.isAssignableFrom(clazz)) {\n                    TypeUtils.addMapping(typeName, clazz);\n                    return clazz;\n                } else {\n                    throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n                }\n            }\n\n            JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz, clazz, propertyNamingStrategy);\n            if (beanInfo.creatorConstructor != null && autoTypeSupport) {\n                throw new JSONException(\"autoType is not support. \" + typeName);\n            }\n        }\n\n        if (!autoTypeSupport) {\n            if (typeName.endsWith(\"Exception\")) {\n                return null;\n            }\n\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        if (clazz != null) {\n            TypeUtils.addMapping(typeName, clazz);\n        }\n\n        return clazz;\n    }\n\n    public void clearDeserializers() {\n        this.deserializers.clear();\n        this.initDeserializers();\n    }\n\n    public boolean isJacksonCompatible() {\n        return jacksonCompatible;\n    }\n\n    public void setJacksonCompatible(boolean jacksonCompatible) {\n        this.jacksonCompatible = jacksonCompatible;\n    }\n\n    public void register(String typeName, Class type) {\n        typeMapping.putIfAbsent(typeName, type);\n    }\n\n    public void register(Module module) {\n        this.modules.add(module);\n    }\n\n    public void addAutoTypeCheckHandler(AutoTypeCheckHandler h) {\n        List<AutoTypeCheckHandler> autoTypeCheckHandlers = this.autoTypeCheckHandlers;\n        if (autoTypeCheckHandlers == null) {\n            this.autoTypeCheckHandlers\n                    = autoTypeCheckHandlers\n                    = new CopyOnWriteArrayList();\n        }\n\n        autoTypeCheckHandlers.add(h);\n    }\n\n    /**\n     * @since 1.2.68\n     */\n    public interface AutoTypeCheckHandler {\n        Class<?> handler(String typeName, Class<?> expectClass, int features);\n    }\n}\n", "package com.alibaba.json.bvt.bug;\n\nimport junit.framework.TestCase;\n\nimport com.alibaba.fastjson.JSON;\n\nimport java.util.Map;\n\npublic class Bug_for_Exception extends TestCase {\n\tpublic void test_exception() throws Exception {\n\t\tRuntimeException ex = new RuntimeException(\"e1\");\n\t\tString text = JSON.toJSONString(ex);\n\t\tSystem.out.println(text);\n\n\n\t\tObject obj = JSON.parse(text);\n\t\tassertTrue(obj instanceof Map);\n\n\t\tRuntimeException ex2 = (RuntimeException) JSON.parseObject(text, Throwable.class);\n\t}\n}\n"], "filenames": ["src/main/java/com/alibaba/fastjson/parser/ParserConfig.java", "src/test/java/com/alibaba/json/bvt/bug/Bug_for_Exception.java"], "buggy_code_start_loc": [210, 6], "buggy_code_end_loc": [1554, 14], "fixing_code_start_loc": [211, 7], "fixing_code_end_loc": [1587, 20], "type": "CWE-502", "message": "The package com.alibaba:fastjson before 1.2.83 are vulnerable to Deserialization of Untrusted Data by bypassing the default autoType shutdown restrictions, which is possible under certain conditions. Exploiting this vulnerability allows attacking remote servers. Workaround: If upgrading is not possible, you can enable [safeMode](https://github.com/alibaba/fastjson/wiki/fastjson_safemode).", "other": {"cve": {"id": "CVE-2022-25845", "sourceIdentifier": "report@snyk.io", "published": "2022-06-10T20:15:08.117", "lastModified": "2023-02-23T17:51:57.970", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package com.alibaba:fastjson before 1.2.83 are vulnerable to Deserialization of Untrusted Data by bypassing the default autoType shutdown restrictions, which is possible under certain conditions. Exploiting this vulnerability allows attacking remote servers. Workaround: If upgrading is not possible, you can enable [safeMode](https://github.com/alibaba/fastjson/wiki/fastjson_safemode)."}, {"lang": "es", "value": "El paquete com.alibaba:fastjson versiones anteriores a 1.2.83, es vulnerable a una Deserializaci\u00f3n de Datos No Confiables al omitir las restricciones de cierre de autoType por defecto, lo cual es posible bajo determinadas condiciones. La explotaci\u00f3n de esta vulnerabilidad permite atacar servidores remotos. Mitigaci\u00f3n: Si la actualizaci\u00f3n no es posible, puede habilitar [safeMode](https://github.com/alibaba/fastjson/wiki/fastjson_safemode)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:alibaba:fastjson:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.83", "matchCriteriaId": "0493BADE-C286-47E0-8652-C1C4D39DDAB5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_unified_data_repository:22.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "74810125-09E6-4F27-B541-AFB61112AC56"}]}]}], "references": [{"url": "https://github.com/alibaba/fastjson/commit/35db4adad70c32089542f23c272def1ad920a60d", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/alibaba/fastjson/commit/8f3410f81cbd437f7c459f8868445d50ad301f15", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/alibaba/fastjson/releases/tag/1.2.83", "source": "report@snyk.io", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/alibaba/fastjson/wiki/security_update_20220523", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-COMALIBABA-2859222", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://www.ddosi.org/fastjson-poc/", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujul2022.html", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/alibaba/fastjson/commit/35db4adad70c32089542f23c272def1ad920a60d"}}