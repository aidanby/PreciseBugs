{"buggy_code": ["/* -*- Mode: C++; c-default-style: \"k&r\"; indent-tabs-mode: nil; tab-width: 2; c-basic-offset: 2 -*- */\n\n/* libstaroffice\n* Version: MPL 2.0 / LGPLv2+\n*\n* The contents of this file are subject to the Mozilla Public License Version\n* 2.0 (the \"License\"); you may not use this file except in compliance with\n* the License or as specified alternatively below. You may obtain a copy of\n* the License at http://www.mozilla.org/MPL/\n*\n* Software distributed under the License is distributed on an \"AS IS\" basis,\n* WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n* for the specific language governing rights and limitations under the\n* License.\n*\n* Major Contributor(s):\n* Copyright (C) 2002 William Lachance (wrlach@gmail.com)\n* Copyright (C) 2002,2004 Marc Maurer (uwog@uwog.net)\n* Copyright (C) 2004-2006 Fridrich Strba (fridrich.strba@bluewin.ch)\n* Copyright (C) 2006, 2007 Andrew Ziem\n* Copyright (C) 2011, 2012 Alonso Laurent (alonso@loria.fr)\n*\n*\n* All Rights Reserved.\n*\n* For minor contributions see the git repository.\n*\n* Alternatively, the contents of this file may be used under the terms of\n* the GNU Lesser General Public License Version 2 or later (the \"LGPLv2+\"),\n* in which case the provisions of the LGPLv2+ are applicable\n* instead of those above.\n*/\n\n#include <map>\n#include <string>\n\n#include <librevenge/librevenge.h>\n\n#include \"StarWriterStruct.hxx\"\n\n#include \"StarAttribute.hxx\"\n#include \"StarFormatManager.hxx\"\n#include \"StarObject.hxx\"\n#include \"StarZone.hxx\"\n\n#include \"STOFFDebug.hxx\"\n\nnamespace StarWriterStruct\n{\n////////////////////////////////////////////////////////////\n//  Attribute\n////////////////////////////////////////////////////////////\nAttribute::~Attribute()\n{\n}\n\nbool Attribute::read(StarZone &zone, StarObject &object)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='A' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Attribute::read: can not read a attribute\\n\"));\n    return false;\n  }\n  // sw_sw3fmts.cxx InAttr\n  f << \"Entries(StarAttribute)[SW-\" << zone.getRecordLevel() << \"]:\";\n  int fl=zone.openFlagZone();\n  uint16_t nWhich, nVers, nBegin=0xFFFF, nEnd=0xFFFF;\n  *input >> nWhich >> nVers;\n  if (fl&0x10) *input >> nBegin;\n  if (fl&0x20) *input >> nEnd;\n  m_position=STOFFVec2i(nBegin==0xFFFF ? -1 : int(nBegin), nEnd==0xFFFF ? -1 : int(nEnd));\n\n  int which=int(nWhich);\n  if (which>0x6001 && zone.getDocumentVersion()!=0x0219) // bug correction 0x95500\n    which+=15;\n  if (which>=0x1000 && which<=0x1024) which+=-0x1000+int(StarAttribute::ATTR_CHR_CASEMAP);\n  else if (which>=0x2000 && which<=0x2009) which+=-0x2000+int(StarAttribute::ATTR_TXT_INETFMT);\n  else if (which>=0x3000 && which<=0x3006) which+=-0x3000+int(StarAttribute::ATTR_TXT_FIELD);\n  else if (which>=0x4000 && which<=0x4013) which+=-0x4000+int(StarAttribute::ATTR_PARA_LINESPACING);\n  else if (which>=0x5000 && which<=0x5022) which+=-0x5000+int(StarAttribute::ATTR_FRM_FILL_ORDER);\n  else if (which>=0x6000 && which<=0x6013) which+=-0x6000+int(StarAttribute::ATTR_GRF_MIRRORGRF);\n  else {\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Attribute::read: find unexpected which value\\n\"));\n    which=-1;\n    f << \"###\";\n  }\n  f << \"wh=\" << which << \"[\" << std::hex << nWhich << std::dec << \"],\";\n  if (nVers) f << \"nVers=\" << nVers << \",\";\n  if (nBegin!=0xFFFF) f << \"nBgin=\" << nBegin << \",\";\n  if (nEnd!=0xFFFF) f << \"nEnd=\" << nEnd << \",\";\n  zone.closeFlagZone();\n\n  if (which<=0 || !object.getAttributeManager() ||\n      !(m_attribute=object.getAttributeManager()->readAttribute(zone, which, int(nVers), zone.getRecordLastPosition(), object)))\n    f << \"###\";\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarAttribute\");\n  return true;\n}\n\nbool Attribute::readList(StarZone &zone, std::vector<Attribute> &attribList, StarObject &object)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='S') return false;\n  if (!zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Attribute::readList: can not read a mark\\n\"));\n    return false;\n  }\n  f << \"Entries(StarAttribute)[SWlist-\" << zone.getRecordLevel() << \"]:\";\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  while (input->tell()<zone.getRecordLastPosition()) {\n    pos=input->tell();\n    Attribute attrib;\n    if (!attrib.read(zone, object)) {\n      input->seek(pos, librevenge::RVNG_SEEK_SET);\n      break;\n    }\n    attribList.push_back(attrib);\n  }\n\n  zone.closeSWRecord(type, \"StarAttribute\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, Attribute const &attrib)\n{\n  if (attrib.m_attribute) {\n    libstoff::DebugStream f;\n    attrib.m_attribute->printData(f);\n    o << \"attrib=[\" << f.str() << \"],\";\n  }\n  if (attrib.m_position[0]==0xFFFF) o << \"pos=_,\";\n  else if (attrib.m_position[1]==0xFFFF) o << \"pos=\" << attrib.m_position[0] << \",\";\n  else o << \"pos=\" << attrib.m_position << \",\";\n  return o;\n}\n\n////////////////////////////////////////////////////////////\n//  Bookmark\n////////////////////////////////////////////////////////////\nbool Bookmark::read(StarZone &zone)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='B' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Bookmark::read: can not read a mark\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InBookmark\n  f << \"Entries(StarBookmark)[\" << type << \"-\" << zone.getRecordLevel() << \"]:\";\n  std::vector<uint32_t> text;\n  bool ok=true;\n  for (int i=0; i<2; ++i) {\n    if (!zone.readString(text)) {\n      ok=false;\n      STOFF_DEBUG_MSG((\"StarWriterStruct::Bookmark::read: can not read a name\\n\"));\n      f << \"###short\";\n      break;\n    }\n    else if (i==0)\n      m_shortName=libstoff::getString(text);\n    else\n      m_name=libstoff::getString(text);\n  }\n  if (ok) {\n    zone.openFlagZone();\n    m_offset=int(input->readULong(2));\n    m_key=int(input->readULong(2));\n    m_modifier=int(input->readULong(2));\n    zone.closeFlagZone();\n  }\n  if (ok && input->tell()<zone.getRecordLastPosition()) {\n    for (int i=0; i<4; ++i) { // start[aMac:aLib],end[aMac:Alib]\n      if (!zone.readString(text)) {\n        STOFF_DEBUG_MSG((\"StarWriterStruct::Bookmark::read: can not read macro name\\n\"));\n        f << \"###macro\";\n        break;\n      }\n      else\n        m_macroNames[i]=libstoff::getString(text);\n    }\n  }\n\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarBookmark\");\n  return true;\n}\n\nbool Bookmark::readList(StarZone &zone, std::vector<Bookmark> &markList)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='a') return false;\n  if (!zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Bookmark::readList: can not read a mark\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InBookmarks\n  f << \"Entries(StarBookmark)[list-\" << zone.getRecordLevel() << \"]:\";\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  while (input->tell()<zone.getRecordLastPosition()) {\n    pos=input->tell();\n    Bookmark bookmark;\n    if (!bookmark.read(zone)) {\n      input->seek(pos, librevenge::RVNG_SEEK_SET);\n      break;\n    }\n    markList.push_back(bookmark);\n  }\n\n  zone.closeSWRecord(type, \"StarBookmark\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, Bookmark const &mark)\n{\n  if (!mark.m_shortName.empty()) o << \"shortName=\" << mark.m_shortName.cstr() << \",\";\n  if (!mark.m_name.empty()) o << \"name=\" << mark.m_name.cstr() << \",\";\n  if (mark.m_offset) o << \"offset=\" << mark.m_offset << \",\";\n  if (mark.m_key) o << \"key=\" << mark.m_key << \",\";\n  if (mark.m_modifier) o << \"modifier=\" << mark.m_modifier << \",\";\n  for (int i=0; i<4; i+=2) {\n    if (mark.m_macroNames[i].empty() && mark.m_macroNames[i+1].empty()) continue;\n    o << \"macro[\" << (i==0 ? \"start\" : \"end\") << \"]=\" << mark.m_macroNames[i].cstr() << \":\" << mark.m_macroNames[i+1].cstr() << \",\";\n  }\n  return o;\n}\n\n////////////////////////////////////////////////////////////\n//  DatabaseName\n////////////////////////////////////////////////////////////\nbool DatabaseName::read(StarZone &zone)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='D' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::DatabaseName::read: can not read a databaseName\\n\"));\n    return false;\n  }\n  // sw_sw3num.cxx: InDBName\n  f << \"Entries(StarDatabaseName)[\" << zone.getRecordLevel() << \"]:\";\n  std::vector<uint32_t> text;\n  if (!zone.readString(text)) {\n    STOFF_DEBUG_MSG((\"StarWriterStruct::DatabaseName::read: can not read a string\\n\"));\n    f << \"###string\";\n    ascFile.addPos(pos);\n    ascFile.addNote(f.str().c_str());\n    zone.closeSWRecord('D', \"StarDatabaseName\");\n    return true;\n  }\n  librevenge::RVNGString delim, dbName, tableName;\n  libstoff::appendUnicode(0xff, delim);\n  libstoff::splitString(libstoff::getString(text),delim, dbName, tableName);\n  if (tableName.empty()) {\n    if (zone.isCompatibleWith(0x11,0x22))\n      m_names[0]=dbName;\n    else\n      m_names[1]=dbName;\n  }\n  else {\n    m_names[0]=dbName;\n    m_names[1]=tableName;\n  }\n  if (zone.isCompatibleWith(0xf,0x101)) {\n    if (!zone.readString(text)) {\n      STOFF_DEBUG_MSG((\"StarWriterStruct::DatabaseName::read: can not read a SQL string\\n\"));\n      f << *this << \"###SQL\";\n      ascFile.addPos(pos);\n      ascFile.addNote(f.str().c_str());\n      zone.closeSWRecord('D', \"StarDatabaseName\");\n      return true;\n    }\n    m_sql=libstoff::getString(text);\n  }\n  if (zone.isCompatibleWith(0x11,0x22)) {\n    if (!zone.readString(text)) {\n      STOFF_DEBUG_MSG((\"StarWriterStruct::DatabaseName::read: can not read a table name string\\n\"));\n      f << \"###tableName\";\n      ascFile.addPos(pos);\n      ascFile.addNote(f.str().c_str());\n      zone.closeSWRecord('D', \"StarDatabaseName\");\n      return true;\n    }\n    m_names[1]=libstoff::getString(text);\n  }\n  if (zone.isCompatibleWith(0x12,0x22, 0x101)) {\n    int nCount=int(input->readULong(2));\n    if (nCount>0 && zone.isCompatibleWith(0x28)) {\n      for (int i=0; i<nCount; ++i) {\n        if (input->tell()>=zone.getRecordLastPosition()) {\n          STOFF_DEBUG_MSG((\"StarWriterStruct::DatabaseName::read: can not read a DBData\\n\"));\n          f << \"###\";\n          break;\n        }\n        Data data;\n        if (!zone.readString(text)) {\n          STOFF_DEBUG_MSG((\"StarWriterStruct::DatabaseName::read: can not read a table name string\\n\"));\n          f << \"###dbDataName\";\n          break;\n        }\n        data.m_name=libstoff::getString(text);\n        int positions[2];\n        for (int j=0; j<2; ++j) positions[i]=int(input->readULong(4));\n        data.m_selection=STOFFVec2i(positions[0],positions[1]);\n        m_dataList.push_back(data);\n      }\n    }\n  }\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarDatabaseName\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, DatabaseName const &dbase)\n{\n  for (int i=0; i<2; ++i) {\n    if (dbase.m_names[i].empty()) continue;\n    char const *(wh[])= {\"name[database]\", \"name[table]\"};\n    o << wh[i] << \"=\" << dbase.m_names[i].cstr() << \",\";\n  }\n  if (!dbase.m_sql.empty()) o << \"sql=\" << dbase.m_sql.cstr() << \",\";\n  if (!dbase.m_dataList.empty()) {\n    o << \"data=[\";\n    for (size_t i=0; i<dbase.m_dataList.size(); ++i)\n      o << \"[\" << dbase.m_dataList[i] << \"],\";\n    o << \"],\";\n  }\n  return o;\n}\n\n////////////////////////////////////////////////////////////\n//  Dictionary\n////////////////////////////////////////////////////////////\nbool Dictionary::read(StarZone &zone)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='j' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Dictionary::read: can not read a dictionary\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx: InDictionary\n  f << \"Entries(StarDictionary)[\" << zone.getRecordLevel() << \"]:\";\n  long lastPos=zone.getRecordLastPosition();\n  std::vector<uint32_t> string;\n  while (input->tell()<lastPos) {\n    pos=input->tell();\n    Data data;\n    if (!zone.readString(string)) {\n      STOFF_DEBUG_MSG((\"StarObjectText::readSWDictionary: can not read a string\\n\"));\n      f << \"###string,\";\n      input->seek(pos, librevenge::RVNG_SEEK_SET);\n      break;\n    }\n    data.m_name=libstoff::getString(string);\n    data.m_language=int(input->readULong(2));\n    data.m_id=int(input->readULong(2));\n    *input>>data.m_spellWrong;\n    m_dataList.push_back(data);\n  }\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarDictionary\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, Dictionary const &dbase)\n{\n  if (!dbase.m_dataList.empty()) {\n    o << \"data=[\";\n    for (size_t i=0; i<dbase.m_dataList.size(); ++i)\n      o << \"[\" << dbase.m_dataList[i] << \"],\";\n    o << \"],\";\n  }\n  return o;\n}\n\n////////////////////////////////////////////////////////////\n//  DocStats\n////////////////////////////////////////////////////////////\nbool DocStats::read(StarZone &zone)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='d' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::DocStats::read: can not read a docStats\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx: InDocStats\n  f << \"Entries(StarDocStats)[\" << zone.getRecordLevel() << \"]:\";\n  for (int i=0; i<3; ++i) m_numbers[i]=long(input->readULong(2));\n  if (zone.isCompatibleWith(0x201)) {\n    m_numbers[3]=long(input->readULong(4));\n    m_numbers[4]=long(input->readULong(4));\n  }\n  else {\n    m_numbers[3]=long(input->readULong(2));\n    m_numbers[4]=long(input->readULong(2));\n  }\n  for (int i=5; i<7; ++i) m_numbers[i]=long(input->readULong(4));\n  *input >> m_isModified;\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarDocStats\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, DocStats const &stats)\n{\n  for (int i=0; i<7; ++i) {\n    if (!stats.m_numbers[i]) continue;\n    char const *(wh[])= {\"table\", \"graph\", \"ole\", \"page\", \"paragraph\", \"word\", \"char\"};\n    o << \"num[\" << wh[i] << \"]=\" << stats.m_numbers[i] << \",\";\n  }\n  if (stats.m_isModified) o << \"modified,\";\n  return o;\n}\n////////////////////////////////////////////////////////////\n//  Macro\n////////////////////////////////////////////////////////////\nbool Macro::read(StarZone &zone)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='m' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Macro::read: can not read a macro\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InMacroTable\n  f << \"Entries(StarMacro)[\" << zone.getRecordLevel() << \"]:\";\n  m_key=int(input->readULong(2));\n  bool ok=true;\n  for (int i=0; i<2; ++i) {\n    std::vector<uint32_t> string;\n    if (!zone.readString(string)) {\n      STOFF_DEBUG_MSG((\"StarObjectText::readSWMacroTable: can not read a string\\n\"));\n      f << \"###name,\";\n      ok=false;\n      break;\n    }\n    m_names[i]=libstoff::getString(string);\n  }\n  if (ok && zone.isCompatibleWith(0x102))\n    m_scriptType=int(input->readULong(2));\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarMacro\");\n  return true;\n}\n\nbool Macro::readList(StarZone &zone, std::vector<Macro> &macroList)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='u') return false;\n  if (!zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Macro::readList: can not read a macro\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InMacroTable\n  f << \"Entries(StarMacro)[list-\" << zone.getRecordLevel() << \"]:\";\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  while (input->tell()<zone.getRecordLastPosition()) {\n    pos=input->tell();\n    Macro macro;\n    if (!macro.read(zone)) {\n      input->seek(pos, librevenge::RVNG_SEEK_SET);\n      break;\n    }\n    macroList.push_back(macro);\n  }\n\n  zone.closeSWRecord(type, \"StarMacro\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, Macro const &macro)\n{\n  if (macro.m_key) o << \"key=\" << macro.m_key << \",\";\n  for (int i=0; i<2; ++i) {\n    if (!macro.m_names[i].empty())\n      o << \"name\" << i << \"=\" << macro.m_names[i].cstr() << \",\";\n  }\n  if (macro.m_scriptType) o << \"type[script]=\" << macro.m_scriptType << \",\";\n  return o;\n}\n\n////////////////////////////////////////////////////////////\n//  Mark\n////////////////////////////////////////////////////////////\nbool Mark::read(StarZone &zone)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='K' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Mark::read: can not read a mark\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InNodeMark\n  f << \"Entries(StarMark)[\" << type << \"-\" << zone.getRecordLevel() << \"]:\";\n  m_type=int(input->readULong(1));\n  m_id=int(input->readULong(2));\n  m_offset=int(input->readULong(2));\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarMark\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, Mark const &mark)\n{\n  o << \"type=\" << mark.m_type << \",\";\n  o << \"id=\" << mark.m_id << \",\";\n  o << \"offset=\" << mark.m_offset << \",\";\n  return o;\n}\n\n////////////////////////////////////////////////////////////\n//  NodeRedline\n////////////////////////////////////////////////////////////\nbool NodeRedline::read(StarZone &zone)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='v' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::NodeRedline::read: can not read a nodeRedline\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InNodeNodeRedline\n  f << \"Entries(StarNodeRedline)[\" << type << \"-\" << zone.getRecordLevel() << \"]:\";\n  m_flags=zone.openFlagZone();\n  m_id=int(input->readULong(2));\n  m_offset=int(input->readULong(2));\n  zone.closeFlagZone();\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarNodeRedline\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, NodeRedline const &nodeRedline)\n{\n  o << \"id=\" << nodeRedline.m_id << \",\";\n  o << \"offset=\" << nodeRedline.m_offset << \",\";\n  if (nodeRedline.m_flags)\n    o << \"flags=\" << std::hex << nodeRedline.m_flags << std::dec << \",\";\n  return o;\n}\n\n////////////////////////////////////////////////////////////\n//  NoteInfo\n////////////////////////////////////////////////////////////\nbool NoteInfo::read(StarZone &zone)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!=(m_isFootnote ? '1' : '4') || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::NoteInfo::read: can not read a noteInfo\\n\"));\n    return false;\n  }\n  f << \"Entries(StarNoteInfo)[\" << (m_isFootnote ? \"footnote\" : \"endnote\") << \"-\" << zone.getRecordLevel() << \"]:\";\n  // sw_sw3num.cxx: InFtnInfo and InFntInfo40 InEndNoteInfo\n  bool oldFootnote=m_isFootnote && !zone.isCompatibleWith(0x201);\n  std::vector<uint32_t> text;\n  if (oldFootnote) {\n    for (int i=0; i<2; ++i) {\n      if (!zone.readString(text)) {\n        STOFF_DEBUG_MSG((\"StarWriterStruct::NoteInfo::read: can not read a string\\n\"));\n        f << *this << \"###string\";\n        ascFile.addPos(pos);\n        ascFile.addNote(f.str().c_str());\n        zone.closeSWRecord(type, \"StarNoteInfo\");\n      }\n      m_strings[i+2]=libstoff::getString(text);\n    }\n  }\n  int fl=zone.openFlagZone();\n\n  if (oldFootnote) {\n    m_posType=int(input->readULong(1));\n    m_numType=int(input->readULong(1));\n  }\n  m_type=int(input->readULong(1));\n  for (int i=0; i<2; ++i)\n    m_idx[i]=int(input->readULong(2));\n  if (zone.isCompatibleWith(0xc))\n    m_ftnOffset=int(input->readULong(2));\n  if (zone.isCompatibleWith(0x203))\n    m_idx[2]=int(input->readULong(2));\n  if (zone.isCompatibleWith(0x216) && (fl&0x10))\n    m_idx[3]=int(input->readULong(2));\n  zone.closeFlagZone();\n\n  if (zone.isCompatibleWith(0x203)) {\n    for (int i=0; i<2; ++i) {\n      if (!zone.readString(text)) {\n        STOFF_DEBUG_MSG((\"StarWriterStruct::NoteInfo::read: can not read a string\\n\"));\n        f << *this << \"###string\";\n        ascFile.addPos(pos);\n        ascFile.addNote(f.str().c_str());\n        zone.closeSWRecord(type, \"StarNoteInfo\");\n        return true;\n      }\n      m_strings[i]=libstoff::getString(text);\n    }\n  }\n\n  if (m_isFootnote && !oldFootnote) {\n    zone.openFlagZone();\n    m_posType=int(input->readULong(1));\n    m_numType=int(input->readULong(1));\n    zone.closeFlagZone();\n    for (int i=0; i<2; ++i) {\n      if (!zone.readString(text)) {\n        STOFF_DEBUG_MSG((\"StarWriterStruct::NoteInfo::read: can not read a string\\n\"));\n        f << *this << \"###string\";\n        ascFile.addPos(pos);\n        ascFile.addNote(f.str().c_str());\n        zone.closeSWRecord(type, \"StarNoteInfo\");\n        return true;\n      }\n      m_strings[i+2]=libstoff::getString(text);\n    }\n  }\n\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarNoteInfo\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, NoteInfo const &info)\n{\n  o << (info.m_isFootnote ? \"footnote\" : \"endnote\") << \",\";\n  if (info.m_type) o << \"type=\" << info.m_type << \",\";\n  for (int i=0; i<4; ++i) {\n    if (info.m_idx[i]==0xFFFF) continue;\n    char const *(wh[])= {\"pageId\", \"collIdx\", \"charIdx\", \"anchorCharIdx\"};\n    o << wh[i] << \"=\" << info.m_idx[i] << \",\";\n  }\n  if (info.m_ftnOffset) o << \"ftnOffset=\" << info.m_ftnOffset << \",\";\n  for (int i=0; i<4; ++i) {\n    if (info.m_strings[i].empty()) continue;\n    char const *(wh[])= {\"prefix\", \"suffix\", \"quoValis\", \"ergoSum\"};\n    o << wh[i] << \"=\" << info.m_strings[i].cstr() << \",\";\n  }\n  if (info.m_posType) o << \"type[pos]=\" << info.m_posType << \",\";\n  if (info.m_numType) o << \"type[number]=\" << info.m_numType << \",\";\n  return o;\n}\n\n////////////////////////////////////////////////////////////\n//  PrintData\n////////////////////////////////////////////////////////////\nbool PrintData::read(StarZone &zone)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='8' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::PrintData::read: can not read a printData\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx: InPagePreviewPrintData\n  f << \"Entries(StarPrintData)[\" << zone.getRecordLevel() << \"]:\";\n  m_flags=int(input->readULong(1));\n  int dim[2];\n  for (int i=0; i<2; ++i) dim[i]=int(input->readULong(2));\n  m_colRow=STOFFVec2i(dim[1],dim[0]);\n  for (int i=0; i<6; ++i) m_spacings[i]=int(input->readULong(2));\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarPrintData\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, PrintData const &info)\n{\n  if (info.m_flags) o << \"flags=\" << std::hex << info.m_flags << std::dec;\n  if (info.m_colRow[0]!=1) o << \"columns=\" << info.m_colRow[0] << \",\";\n  if (info.m_colRow[1]!=1) o << \"rows=\" << info.m_colRow[1] << \",\";\n  for (int i=0; i<6; ++i) {\n    if (!info.m_spacings[i]) continue;\n    char const *(wh[])= {\"left\", \"right\", \"top\", \"bottom\", \"horizontal\", \"vertical\"};\n    o << wh[i] << \"=\" << info.m_spacings[i] << \",\";\n  }\n  return o;\n}\n////////////////////////////////////////////////////////////\n//  Redline\n////////////////////////////////////////////////////////////\nbool Redline::read(StarZone &zone)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='D' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Redline::read: can not read a redline\\n\"));\n    return false;\n  }\n  f << \"Entries(StarRedline)[\" << zone.getRecordLevel() << \"]:\";\n  // sw_sw3redline.cxx inRedline\n  zone.openFlagZone();\n  m_type=int(input->readULong(1));\n  m_stringId=int(input->readULong(2));\n  zone.closeFlagZone();\n  m_date=long(input->readULong(4));\n  m_time=long(input->readULong(4));\n  std::vector<uint32_t> text;\n  if (!zone.readString(text)) {\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Redline: can not read the comment\\n\"));\n    f << \"###comment\";\n  }\n  else\n    m_comment=libstoff::getString(text);\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarRedline\");\n  return true;\n}\n\nbool Redline::readList(StarZone &zone, std::vector<Redline> &redlineList)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='R') return false;\n  if (!zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Redline::readList: can not read a mark\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InRedlines\n  f << \"Entries(StarRedline)[list-\" << zone.getRecordLevel() << \"]:\";\n  zone.openFlagZone();\n  int N=int(input->readULong(2));\n  zone.closeFlagZone();\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n\n  for (int i=0; i<N; ++i) {\n    pos=input->tell();\n    Redline redline;\n    if (!redline.read(zone)) {\n      input->seek(pos, librevenge::RVNG_SEEK_SET);\n      break;\n    }\n    redlineList.push_back(redline);\n  }\n\n  zone.closeSWRecord(type, \"StarRedline\");\n  return true;\n}\n\nbool Redline::readListList(StarZone &zone, std::vector<std::vector<Redline> > &redlineListList)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='V') return false;\n  if (!zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Redline::readListList: can not read a mark\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InRedlines\n  f << \"Entries(StarRedline)[listList-\" << zone.getRecordLevel() << \"]:\";\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n\n  while (input->tell() < zone.getRecordLastPosition()) {\n    pos=input->tell();\n    std::vector<Redline> redlineList;\n    if (!readList(zone, redlineList)) {\n      input->seek(pos, librevenge::RVNG_SEEK_SET);\n      break;\n    }\n    redlineListList.push_back(redlineList);\n  }\n\n  zone.closeSWRecord(type, \"StarRedline\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, Redline const &redline)\n{\n  if (redline.m_type) o << \"type=\" << redline.m_type << \",\";\n  if (redline.m_stringId) o << \"stringId=\" << redline.m_stringId << \",\";\n  if (redline.m_date) o << \"date=\" << redline.m_date << \",\";\n  if (redline.m_time) o << \"time=\" << redline.m_time << \",\";\n  if (!redline.m_comment.empty()) o << \"comment=\" << redline.m_comment.cstr() << \",\";\n  return o;\n}\n\n////////////////////////////////////////////////////////////\n//  TOX\n////////////////////////////////////////////////////////////\nTOX::~TOX()\n{\n}\n\nbool TOX::read(StarZone &zone, StarObject &object)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='x' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::TOX::read::read: can not read a nodeRedline\\n\"));\n    return false;\n  }\n  long lastRecordPos=zone.getRecordLastPosition();\n  // sw_sw3misc.cxx: InTOX\n  f << \"Entries(StarTOX)[\" << zone.getRecordLevel() << \"]:\";\n  int fl=zone.openFlagZone();\n  if (fl&0xf0)\n    f << \"fl=\" << (fl>>4) << \",\";\n  m_type=int(input->readULong(2));\n  m_createType=int(input->readULong(2));\n  m_captionDisplay=int(input->readULong(2));\n  for (int i=0; i<2; ++i) m_stringIds[i]=int(input->readULong(2));\n  m_data=int(input->readULong(2));\n  m_formFlags=int(input->readULong(1));\n  zone.closeFlagZone();\n  std::vector<uint32_t> string;\n  for (int i=0; i<2; ++i) {\n    if (!zone.readString(string)) {\n      STOFF_DEBUG_MSG((\"StarWriterStruct::TOX::read: can not read aName\\n\"));\n      f << *this;\n      f << \"###aName\";\n      ascFile.addPos(pos);\n      ascFile.addNote(f.str().c_str());\n      zone.closeSWRecord(type, \"StarTOX\");\n      return true;\n    }\n    if (i==0)\n      m_name=libstoff::getString(string);\n    else\n      m_title=libstoff::getString(string);\n  }\n  if (zone.isCompatibleWith(0x215)) {\n    m_OLEOptions=int(input->readULong(2));\n    m_styleId=int(input->readULong(2));\n  }\n  else {\n    if (!zone.readString(string)) {\n      STOFF_DEBUG_MSG((\"StarWriterStruct::TOX::read: can not read aDummy\\n\"));\n      f << \"###aDummy\";\n      ascFile.addPos(pos);\n      ascFile.addNote(f.str().c_str());\n      zone.closeSWRecord(type, \"StarTOX\");\n      return true;;\n    }\n    if (!string.empty())\n      f << \"aDummy=\" << libstoff::getString(string).cstr() << \",\";\n  }\n\n  int N=int(input->readULong(1));\n  f << \"nPatterns=\" << N << \",\";\n  bool ok=true;\n  for (int i=0; i<N; ++i) { // storeme\n    if (object.getFormatManager()->readSWPatternLCL(zone))\n      continue;\n    ok=false;\n    f << \"###pat\";\n    break;\n  }\n  if (!ok) {\n    f << *this;\n    ascFile.addPos(pos);\n    ascFile.addNote(f.str().c_str());\n    zone.closeSWRecord(type, \"StarTOX\");\n    return true;\n  }\n  N=int(input->readULong(1));\n  for (int i=0; i<N; ++i)\n    m_stringIdList.push_back(int(input->readULong(2)));\n  N=int(input->readULong(1));\n  for (int i=0; i<N; ++i) {\n    Style style;\n    style.m_level=int(input->readULong(1));\n    int nCount=int(input->readULong(2));\n    f << \"nCount=\" << nCount << \",\";\n    if (input->tell()+2*nCount>lastRecordPos) {\n      STOFF_DEBUG_MSG((\"StarWriterStruct::TOX::read: can not read some string id\\n\"));\n      f << \"###styleId\";\n      ok=false;\n      break;\n    }\n    librevenge::RVNGString poolName;\n    for (int j=0; j<nCount; ++j) {\n      int val=int(input->readULong(2));\n      if (!zone.getPoolName(val, poolName))\n        f << \"###nPoolId=\" << val << \",\";\n      else\n        style.m_names.push_back(poolName);\n    }\n  }\n  if (!ok) {\n    f << *this;\n    ascFile.addPos(pos);\n    ascFile.addNote(f.str().c_str());\n    zone.closeSWRecord(type, \"StarTOX\");\n    return true;\n  }\n  fl=zone.openFlagZone();\n  m_stringIds[2]=int(input->readULong(2));\n  m_titleLength=long(input->readULong(4));\n  zone.closeFlagZone();\n\n  if ((fl&0x10)) {\n    while (input->tell()<lastRecordPos && input->peek()=='s') {\n      shared_ptr<StarFormatManagerInternal::FormatDef> format;\n      if (!object.getFormatManager()->readSWFormatDef(zone,'s', format, object)) {\n        STOFF_DEBUG_MSG((\"StarWriterStruct::TOX::read: can not read some format\\n\"));\n        f << \"###format,\";\n        break;\n      }\n      m_formatList.push_back(format);\n    }\n  }\n\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarTOX\");\n  return true;\n}\n\nbool TOX::readList(StarZone &zone, std::vector<TOX> &toxList, StarObject &object)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='u') return false;\n  if (!zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::TOX::readList: can not read a mark\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InTOXs\n  f << \"Entries(StarTOX)[list-\" << zone.getRecordLevel() << \"]:\";\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  while (input->tell()<zone.getRecordLastPosition()) {\n    pos=input->tell();\n    TOX tox;\n    if (!tox.read(zone, object)) {\n      input->seek(pos, librevenge::RVNG_SEEK_SET);\n      break;\n    }\n    toxList.push_back(tox);\n  }\n\n  zone.closeSWRecord(type, \"StarTOX\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, TOX const &tox)\n{\n  if (tox.m_type) o << \"type=\" << tox.m_type << \",\";\n  if (tox.m_createType) o << \"type[create]=\" << tox.m_createType << \",\";\n  if (tox.m_captionDisplay) o << \"captionDisplay=\" << tox.m_captionDisplay << \",\";\n  for (int i=0; i<3; ++i) {\n    if (tox.m_stringIds[i]==0xFFFF) continue;\n    char const *(wh[])= {\"stringId\", \"seqStringId\", \"sectStringId\"};\n    o << wh[i] << \"=\" << tox.m_stringIds[i] << \",\";\n  }\n  if (tox.m_styleId!=0xFFFF) o << \"styleId=\" << tox.m_styleId << \",\";\n  if (tox.m_data) o << \"data=\" << tox.m_data << \",\";\n  if (tox.m_formFlags) o << \"formFlags=\" << std::hex << tox.m_formFlags << std::dec << \",\";\n  if (!tox.m_title.empty()) o << \"title=\" << tox.m_title.cstr() << \",\";\n  if (!tox.m_name.empty()) o << \"name=\" << tox.m_name.cstr() << \",\";\n  if (tox.m_OLEOptions) o << \"OLEOptions=\" << tox.m_OLEOptions << \",\";\n  if (!tox.m_stringIdList.empty()) {\n    o << \"stringIdList=[\";\n    for (size_t i=0; i<tox.m_stringIdList.size(); ++i) {\n      if (tox.m_stringIdList[i]==0xFFFF)\n        o << \"_,\";\n      else\n        o << tox.m_stringIdList[i] << \",\";\n    }\n    o << \"],\";\n  }\n  if (!tox.m_styleList.empty()) {\n    o << \"styleList=[\";\n    for (size_t i=0; i<tox.m_styleList.size(); ++i)\n      o << \"[\" << tox.m_styleList[i] << \"],\";\n    o << \"],\";\n  }\n  if (tox.m_titleLength) o << \"titleLength=\" << tox.m_titleLength << \",\";\n  if (!tox.m_formatList.empty()) o << \"nFormat=\" << tox.m_formatList.size() << \",\";\n  return o;\n}\n\n////////////////////////////////////////////////////////////\n//  TOX51\n////////////////////////////////////////////////////////////\nTOX51::~TOX51()\n{\n}\n\nbool TOX51::read(StarZone &zone, StarObject &/*object*/)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='x' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::TOX51::read: can not read a tox51\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InNodeTOX51\n  f << \"Entries(StarTox51)[\" << type << \"-\" << zone.getRecordLevel() << \"]:\";\n  std::vector<uint32_t> string;\n  if (zone.isCompatibleWith(0x201)) {\n    int strId=int(input->readULong(2));\n    if (strId!=0xFFFF && !zone.getPoolName(strId, m_typeName))\n      f << \"###nPoolId=\" << strId << \",\";\n  }\n  else {\n    if (!zone.readString(string)) {\n      STOFF_DEBUG_MSG((\"StarWriterStruct::TOX51::read: can not read typeName\\n\"));\n      f << *this << \"###typeName\";\n      ascFile.addPos(pos);\n      ascFile.addNote(f.str().c_str());\n      zone.closeSWRecord(type, \"StarTox51\");\n      return true;\n    }\n    m_typeName=libstoff::getString(string);\n  }\n  if (!zone.readString(string)) {\n    STOFF_DEBUG_MSG((\"StarWriterStruct::TOX51::read: can not read aTitle\\n\"));\n    f << *this << \"###aTitle\";\n    ascFile.addPos(pos);\n    ascFile.addNote(f.str().c_str());\n    zone.closeSWRecord(type, \"StarTox51\");\n    return true;\n  }\n  m_title=libstoff::getString(string);\n  int fl=zone.openFlagZone();\n  m_createType=int(input->readULong(2));\n  m_type=int(input->readULong(1));\n  if (zone.isCompatibleWith(0x213) && (fl&0x10))\n    m_firstTabPos=int(input->readULong(2));\n\n  int N=int(input->readULong(1));\n  bool ok=true;\n  for (int i=0; i<N; ++i) {\n    if (!zone.readString(string)) {\n      STOFF_DEBUG_MSG((\"StarWriterStruct::TOX51::read: can not read a pattern name\\n\"));\n      f << \"###pat\";\n      ok=false;\n      break;\n    }\n    m_patternList.push_back(libstoff::getString(string));\n  }\n  if (!ok) {\n    f << *this;\n    ascFile.addPos(pos);\n    ascFile.addNote(f.str().c_str());\n    zone.closeSWRecord(type, \"StarTox51\");\n    return true;\n  }\n  N=int(input->readULong(1));\n  for (int i=0; i<N; ++i)\n    m_stringIdList.push_back(int(input->readULong(2)));\n  m_infLevel=int(input->readULong(2));\n\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarTox51\");\n  return true;\n}\n\n\nbool TOX51::readList(StarZone &zone, std::vector<TOX51> &toxList, StarObject &object)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='y') return false;\n  if (!zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::TOX51::readList: can not read a mark\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InTOX51s\n  f << \"Entries(StarTox51)[list-\" << zone.getRecordLevel() << \"]:\";\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  while (input->tell()<zone.getRecordLastPosition()) {\n    pos=input->tell();\n    TOX51 tox;\n    if (!tox.read(zone, object)) {\n      input->seek(pos, librevenge::RVNG_SEEK_SET);\n      break;\n    }\n    toxList.push_back(tox);\n  }\n\n  zone.closeSWRecord(type, \"StarTox51\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, TOX51 const &tox)\n{\n  if (!tox.m_typeName.empty()) o << \"type[name]=\" << tox.m_typeName.cstr() << \",\";\n  if (tox.m_type) o << \"type=\" << tox.m_type << \",\";\n  if (tox.m_createType) o << \"type[create]=\" << tox.m_createType << \",\";\n  if (tox.m_firstTabPos) o << \"firstTabPos=\" << tox.m_firstTabPos << \",\";\n  if (!tox.m_title.empty()) o << \"title=\" << tox.m_title.cstr() << \",\";\n  if (!tox.m_patternList.empty()) {\n    o << \"patternList=[\";\n    for (size_t i=0; i<tox.m_patternList.size(); ++i)\n      o << tox.m_patternList[i].cstr() << \",\";\n    o << \"],\";\n  }\n  if (!tox.m_stringIdList.empty()) {\n    o << \"stringIdList=[\";\n    for (size_t i=0; i<tox.m_stringIdList.size(); ++i) {\n      if (tox.m_stringIdList[i]==0xFFFF)\n        o << \"_,\";\n      else\n        o << tox.m_stringIdList[i] << \",\";\n    }\n    o << \"],\";\n  }\n  if (tox.m_infLevel) o << \"infLevel=\" << tox.m_infLevel << \",\";\n  return o;\n}\n}\n// vim: set filetype=cpp tabstop=2 shiftwidth=2 cindent autoindent smartindent noexpandtab:\n"], "fixing_code": ["/* -*- Mode: C++; c-default-style: \"k&r\"; indent-tabs-mode: nil; tab-width: 2; c-basic-offset: 2 -*- */\n\n/* libstaroffice\n* Version: MPL 2.0 / LGPLv2+\n*\n* The contents of this file are subject to the Mozilla Public License Version\n* 2.0 (the \"License\"); you may not use this file except in compliance with\n* the License or as specified alternatively below. You may obtain a copy of\n* the License at http://www.mozilla.org/MPL/\n*\n* Software distributed under the License is distributed on an \"AS IS\" basis,\n* WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n* for the specific language governing rights and limitations under the\n* License.\n*\n* Major Contributor(s):\n* Copyright (C) 2002 William Lachance (wrlach@gmail.com)\n* Copyright (C) 2002,2004 Marc Maurer (uwog@uwog.net)\n* Copyright (C) 2004-2006 Fridrich Strba (fridrich.strba@bluewin.ch)\n* Copyright (C) 2006, 2007 Andrew Ziem\n* Copyright (C) 2011, 2012 Alonso Laurent (alonso@loria.fr)\n*\n*\n* All Rights Reserved.\n*\n* For minor contributions see the git repository.\n*\n* Alternatively, the contents of this file may be used under the terms of\n* the GNU Lesser General Public License Version 2 or later (the \"LGPLv2+\"),\n* in which case the provisions of the LGPLv2+ are applicable\n* instead of those above.\n*/\n\n#include <map>\n#include <string>\n\n#include <librevenge/librevenge.h>\n\n#include \"StarWriterStruct.hxx\"\n\n#include \"StarAttribute.hxx\"\n#include \"StarFormatManager.hxx\"\n#include \"StarObject.hxx\"\n#include \"StarZone.hxx\"\n\n#include \"STOFFDebug.hxx\"\n\nnamespace StarWriterStruct\n{\n////////////////////////////////////////////////////////////\n//  Attribute\n////////////////////////////////////////////////////////////\nAttribute::~Attribute()\n{\n}\n\nbool Attribute::read(StarZone &zone, StarObject &object)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='A' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Attribute::read: can not read a attribute\\n\"));\n    return false;\n  }\n  // sw_sw3fmts.cxx InAttr\n  f << \"Entries(StarAttribute)[SW-\" << zone.getRecordLevel() << \"]:\";\n  int fl=zone.openFlagZone();\n  uint16_t nWhich, nVers, nBegin=0xFFFF, nEnd=0xFFFF;\n  *input >> nWhich >> nVers;\n  if (fl&0x10) *input >> nBegin;\n  if (fl&0x20) *input >> nEnd;\n  m_position=STOFFVec2i(nBegin==0xFFFF ? -1 : int(nBegin), nEnd==0xFFFF ? -1 : int(nEnd));\n\n  int which=int(nWhich);\n  if (which>0x6001 && zone.getDocumentVersion()!=0x0219) // bug correction 0x95500\n    which+=15;\n  if (which>=0x1000 && which<=0x1024) which+=-0x1000+int(StarAttribute::ATTR_CHR_CASEMAP);\n  else if (which>=0x2000 && which<=0x2009) which+=-0x2000+int(StarAttribute::ATTR_TXT_INETFMT);\n  else if (which>=0x3000 && which<=0x3006) which+=-0x3000+int(StarAttribute::ATTR_TXT_FIELD);\n  else if (which>=0x4000 && which<=0x4013) which+=-0x4000+int(StarAttribute::ATTR_PARA_LINESPACING);\n  else if (which>=0x5000 && which<=0x5022) which+=-0x5000+int(StarAttribute::ATTR_FRM_FILL_ORDER);\n  else if (which>=0x6000 && which<=0x6013) which+=-0x6000+int(StarAttribute::ATTR_GRF_MIRRORGRF);\n  else {\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Attribute::read: find unexpected which value\\n\"));\n    which=-1;\n    f << \"###\";\n  }\n  f << \"wh=\" << which << \"[\" << std::hex << nWhich << std::dec << \"],\";\n  if (nVers) f << \"nVers=\" << nVers << \",\";\n  if (nBegin!=0xFFFF) f << \"nBgin=\" << nBegin << \",\";\n  if (nEnd!=0xFFFF) f << \"nEnd=\" << nEnd << \",\";\n  zone.closeFlagZone();\n\n  if (which<=0 || !object.getAttributeManager() ||\n      !(m_attribute=object.getAttributeManager()->readAttribute(zone, which, int(nVers), zone.getRecordLastPosition(), object)))\n    f << \"###\";\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarAttribute\");\n  return true;\n}\n\nbool Attribute::readList(StarZone &zone, std::vector<Attribute> &attribList, StarObject &object)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='S') return false;\n  if (!zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Attribute::readList: can not read a mark\\n\"));\n    return false;\n  }\n  f << \"Entries(StarAttribute)[SWlist-\" << zone.getRecordLevel() << \"]:\";\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  while (input->tell()<zone.getRecordLastPosition()) {\n    pos=input->tell();\n    Attribute attrib;\n    if (!attrib.read(zone, object)) {\n      input->seek(pos, librevenge::RVNG_SEEK_SET);\n      break;\n    }\n    attribList.push_back(attrib);\n  }\n\n  zone.closeSWRecord(type, \"StarAttribute\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, Attribute const &attrib)\n{\n  if (attrib.m_attribute) {\n    libstoff::DebugStream f;\n    attrib.m_attribute->printData(f);\n    o << \"attrib=[\" << f.str() << \"],\";\n  }\n  if (attrib.m_position[0]==0xFFFF) o << \"pos=_,\";\n  else if (attrib.m_position[1]==0xFFFF) o << \"pos=\" << attrib.m_position[0] << \",\";\n  else o << \"pos=\" << attrib.m_position << \",\";\n  return o;\n}\n\n////////////////////////////////////////////////////////////\n//  Bookmark\n////////////////////////////////////////////////////////////\nbool Bookmark::read(StarZone &zone)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='B' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Bookmark::read: can not read a mark\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InBookmark\n  f << \"Entries(StarBookmark)[\" << type << \"-\" << zone.getRecordLevel() << \"]:\";\n  std::vector<uint32_t> text;\n  bool ok=true;\n  for (int i=0; i<2; ++i) {\n    if (!zone.readString(text)) {\n      ok=false;\n      STOFF_DEBUG_MSG((\"StarWriterStruct::Bookmark::read: can not read a name\\n\"));\n      f << \"###short\";\n      break;\n    }\n    else if (i==0)\n      m_shortName=libstoff::getString(text);\n    else\n      m_name=libstoff::getString(text);\n  }\n  if (ok) {\n    zone.openFlagZone();\n    m_offset=int(input->readULong(2));\n    m_key=int(input->readULong(2));\n    m_modifier=int(input->readULong(2));\n    zone.closeFlagZone();\n  }\n  if (ok && input->tell()<zone.getRecordLastPosition()) {\n    for (int i=0; i<4; ++i) { // start[aMac:aLib],end[aMac:Alib]\n      if (!zone.readString(text)) {\n        STOFF_DEBUG_MSG((\"StarWriterStruct::Bookmark::read: can not read macro name\\n\"));\n        f << \"###macro\";\n        break;\n      }\n      else\n        m_macroNames[i]=libstoff::getString(text);\n    }\n  }\n\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarBookmark\");\n  return true;\n}\n\nbool Bookmark::readList(StarZone &zone, std::vector<Bookmark> &markList)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='a') return false;\n  if (!zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Bookmark::readList: can not read a mark\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InBookmarks\n  f << \"Entries(StarBookmark)[list-\" << zone.getRecordLevel() << \"]:\";\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  while (input->tell()<zone.getRecordLastPosition()) {\n    pos=input->tell();\n    Bookmark bookmark;\n    if (!bookmark.read(zone)) {\n      input->seek(pos, librevenge::RVNG_SEEK_SET);\n      break;\n    }\n    markList.push_back(bookmark);\n  }\n\n  zone.closeSWRecord(type, \"StarBookmark\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, Bookmark const &mark)\n{\n  if (!mark.m_shortName.empty()) o << \"shortName=\" << mark.m_shortName.cstr() << \",\";\n  if (!mark.m_name.empty()) o << \"name=\" << mark.m_name.cstr() << \",\";\n  if (mark.m_offset) o << \"offset=\" << mark.m_offset << \",\";\n  if (mark.m_key) o << \"key=\" << mark.m_key << \",\";\n  if (mark.m_modifier) o << \"modifier=\" << mark.m_modifier << \",\";\n  for (int i=0; i<4; i+=2) {\n    if (mark.m_macroNames[i].empty() && mark.m_macroNames[i+1].empty()) continue;\n    o << \"macro[\" << (i==0 ? \"start\" : \"end\") << \"]=\" << mark.m_macroNames[i].cstr() << \":\" << mark.m_macroNames[i+1].cstr() << \",\";\n  }\n  return o;\n}\n\n////////////////////////////////////////////////////////////\n//  DatabaseName\n////////////////////////////////////////////////////////////\nbool DatabaseName::read(StarZone &zone)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='D' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::DatabaseName::read: can not read a databaseName\\n\"));\n    return false;\n  }\n  // sw_sw3num.cxx: InDBName\n  f << \"Entries(StarDatabaseName)[\" << zone.getRecordLevel() << \"]:\";\n  std::vector<uint32_t> text;\n  if (!zone.readString(text)) {\n    STOFF_DEBUG_MSG((\"StarWriterStruct::DatabaseName::read: can not read a string\\n\"));\n    f << \"###string\";\n    ascFile.addPos(pos);\n    ascFile.addNote(f.str().c_str());\n    zone.closeSWRecord('D', \"StarDatabaseName\");\n    return true;\n  }\n  librevenge::RVNGString delim, dbName, tableName;\n  libstoff::appendUnicode(0xff, delim);\n  libstoff::splitString(libstoff::getString(text),delim, dbName, tableName);\n  if (tableName.empty()) {\n    if (zone.isCompatibleWith(0x11,0x22))\n      m_names[0]=dbName;\n    else\n      m_names[1]=dbName;\n  }\n  else {\n    m_names[0]=dbName;\n    m_names[1]=tableName;\n  }\n  if (zone.isCompatibleWith(0xf,0x101)) {\n    if (!zone.readString(text)) {\n      STOFF_DEBUG_MSG((\"StarWriterStruct::DatabaseName::read: can not read a SQL string\\n\"));\n      f << *this << \"###SQL\";\n      ascFile.addPos(pos);\n      ascFile.addNote(f.str().c_str());\n      zone.closeSWRecord('D', \"StarDatabaseName\");\n      return true;\n    }\n    m_sql=libstoff::getString(text);\n  }\n  if (zone.isCompatibleWith(0x11,0x22)) {\n    if (!zone.readString(text)) {\n      STOFF_DEBUG_MSG((\"StarWriterStruct::DatabaseName::read: can not read a table name string\\n\"));\n      f << \"###tableName\";\n      ascFile.addPos(pos);\n      ascFile.addNote(f.str().c_str());\n      zone.closeSWRecord('D', \"StarDatabaseName\");\n      return true;\n    }\n    m_names[1]=libstoff::getString(text);\n  }\n  if (zone.isCompatibleWith(0x12,0x22, 0x101)) {\n    int nCount=int(input->readULong(2));\n    if (nCount>0 && zone.isCompatibleWith(0x28)) {\n      for (int i=0; i<nCount; ++i) {\n        if (input->tell()>=zone.getRecordLastPosition()) {\n          STOFF_DEBUG_MSG((\"StarWriterStruct::DatabaseName::read: can not read a DBData\\n\"));\n          f << \"###\";\n          break;\n        }\n        Data data;\n        if (!zone.readString(text)) {\n          STOFF_DEBUG_MSG((\"StarWriterStruct::DatabaseName::read: can not read a table name string\\n\"));\n          f << \"###dbDataName\";\n          break;\n        }\n        data.m_name=libstoff::getString(text);\n        int positions[2];\n        for (int j=0; j<2; ++j) positions[j]=int(input->readULong(4));\n        data.m_selection=STOFFVec2i(positions[0],positions[1]);\n        m_dataList.push_back(data);\n      }\n    }\n  }\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarDatabaseName\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, DatabaseName const &dbase)\n{\n  for (int i=0; i<2; ++i) {\n    if (dbase.m_names[i].empty()) continue;\n    char const *(wh[])= {\"name[database]\", \"name[table]\"};\n    o << wh[i] << \"=\" << dbase.m_names[i].cstr() << \",\";\n  }\n  if (!dbase.m_sql.empty()) o << \"sql=\" << dbase.m_sql.cstr() << \",\";\n  if (!dbase.m_dataList.empty()) {\n    o << \"data=[\";\n    for (size_t i=0; i<dbase.m_dataList.size(); ++i)\n      o << \"[\" << dbase.m_dataList[i] << \"],\";\n    o << \"],\";\n  }\n  return o;\n}\n\n////////////////////////////////////////////////////////////\n//  Dictionary\n////////////////////////////////////////////////////////////\nbool Dictionary::read(StarZone &zone)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='j' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Dictionary::read: can not read a dictionary\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx: InDictionary\n  f << \"Entries(StarDictionary)[\" << zone.getRecordLevel() << \"]:\";\n  long lastPos=zone.getRecordLastPosition();\n  std::vector<uint32_t> string;\n  while (input->tell()<lastPos) {\n    pos=input->tell();\n    Data data;\n    if (!zone.readString(string)) {\n      STOFF_DEBUG_MSG((\"StarObjectText::readSWDictionary: can not read a string\\n\"));\n      f << \"###string,\";\n      input->seek(pos, librevenge::RVNG_SEEK_SET);\n      break;\n    }\n    data.m_name=libstoff::getString(string);\n    data.m_language=int(input->readULong(2));\n    data.m_id=int(input->readULong(2));\n    *input>>data.m_spellWrong;\n    m_dataList.push_back(data);\n  }\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarDictionary\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, Dictionary const &dbase)\n{\n  if (!dbase.m_dataList.empty()) {\n    o << \"data=[\";\n    for (size_t i=0; i<dbase.m_dataList.size(); ++i)\n      o << \"[\" << dbase.m_dataList[i] << \"],\";\n    o << \"],\";\n  }\n  return o;\n}\n\n////////////////////////////////////////////////////////////\n//  DocStats\n////////////////////////////////////////////////////////////\nbool DocStats::read(StarZone &zone)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='d' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::DocStats::read: can not read a docStats\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx: InDocStats\n  f << \"Entries(StarDocStats)[\" << zone.getRecordLevel() << \"]:\";\n  for (int i=0; i<3; ++i) m_numbers[i]=long(input->readULong(2));\n  if (zone.isCompatibleWith(0x201)) {\n    m_numbers[3]=long(input->readULong(4));\n    m_numbers[4]=long(input->readULong(4));\n  }\n  else {\n    m_numbers[3]=long(input->readULong(2));\n    m_numbers[4]=long(input->readULong(2));\n  }\n  for (int i=5; i<7; ++i) m_numbers[i]=long(input->readULong(4));\n  *input >> m_isModified;\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarDocStats\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, DocStats const &stats)\n{\n  for (int i=0; i<7; ++i) {\n    if (!stats.m_numbers[i]) continue;\n    char const *(wh[])= {\"table\", \"graph\", \"ole\", \"page\", \"paragraph\", \"word\", \"char\"};\n    o << \"num[\" << wh[i] << \"]=\" << stats.m_numbers[i] << \",\";\n  }\n  if (stats.m_isModified) o << \"modified,\";\n  return o;\n}\n////////////////////////////////////////////////////////////\n//  Macro\n////////////////////////////////////////////////////////////\nbool Macro::read(StarZone &zone)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='m' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Macro::read: can not read a macro\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InMacroTable\n  f << \"Entries(StarMacro)[\" << zone.getRecordLevel() << \"]:\";\n  m_key=int(input->readULong(2));\n  bool ok=true;\n  for (int i=0; i<2; ++i) {\n    std::vector<uint32_t> string;\n    if (!zone.readString(string)) {\n      STOFF_DEBUG_MSG((\"StarObjectText::readSWMacroTable: can not read a string\\n\"));\n      f << \"###name,\";\n      ok=false;\n      break;\n    }\n    m_names[i]=libstoff::getString(string);\n  }\n  if (ok && zone.isCompatibleWith(0x102))\n    m_scriptType=int(input->readULong(2));\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarMacro\");\n  return true;\n}\n\nbool Macro::readList(StarZone &zone, std::vector<Macro> &macroList)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='u') return false;\n  if (!zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Macro::readList: can not read a macro\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InMacroTable\n  f << \"Entries(StarMacro)[list-\" << zone.getRecordLevel() << \"]:\";\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  while (input->tell()<zone.getRecordLastPosition()) {\n    pos=input->tell();\n    Macro macro;\n    if (!macro.read(zone)) {\n      input->seek(pos, librevenge::RVNG_SEEK_SET);\n      break;\n    }\n    macroList.push_back(macro);\n  }\n\n  zone.closeSWRecord(type, \"StarMacro\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, Macro const &macro)\n{\n  if (macro.m_key) o << \"key=\" << macro.m_key << \",\";\n  for (int i=0; i<2; ++i) {\n    if (!macro.m_names[i].empty())\n      o << \"name\" << i << \"=\" << macro.m_names[i].cstr() << \",\";\n  }\n  if (macro.m_scriptType) o << \"type[script]=\" << macro.m_scriptType << \",\";\n  return o;\n}\n\n////////////////////////////////////////////////////////////\n//  Mark\n////////////////////////////////////////////////////////////\nbool Mark::read(StarZone &zone)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='K' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Mark::read: can not read a mark\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InNodeMark\n  f << \"Entries(StarMark)[\" << type << \"-\" << zone.getRecordLevel() << \"]:\";\n  m_type=int(input->readULong(1));\n  m_id=int(input->readULong(2));\n  m_offset=int(input->readULong(2));\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarMark\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, Mark const &mark)\n{\n  o << \"type=\" << mark.m_type << \",\";\n  o << \"id=\" << mark.m_id << \",\";\n  o << \"offset=\" << mark.m_offset << \",\";\n  return o;\n}\n\n////////////////////////////////////////////////////////////\n//  NodeRedline\n////////////////////////////////////////////////////////////\nbool NodeRedline::read(StarZone &zone)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='v' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::NodeRedline::read: can not read a nodeRedline\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InNodeNodeRedline\n  f << \"Entries(StarNodeRedline)[\" << type << \"-\" << zone.getRecordLevel() << \"]:\";\n  m_flags=zone.openFlagZone();\n  m_id=int(input->readULong(2));\n  m_offset=int(input->readULong(2));\n  zone.closeFlagZone();\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarNodeRedline\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, NodeRedline const &nodeRedline)\n{\n  o << \"id=\" << nodeRedline.m_id << \",\";\n  o << \"offset=\" << nodeRedline.m_offset << \",\";\n  if (nodeRedline.m_flags)\n    o << \"flags=\" << std::hex << nodeRedline.m_flags << std::dec << \",\";\n  return o;\n}\n\n////////////////////////////////////////////////////////////\n//  NoteInfo\n////////////////////////////////////////////////////////////\nbool NoteInfo::read(StarZone &zone)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!=(m_isFootnote ? '1' : '4') || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::NoteInfo::read: can not read a noteInfo\\n\"));\n    return false;\n  }\n  f << \"Entries(StarNoteInfo)[\" << (m_isFootnote ? \"footnote\" : \"endnote\") << \"-\" << zone.getRecordLevel() << \"]:\";\n  // sw_sw3num.cxx: InFtnInfo and InFntInfo40 InEndNoteInfo\n  bool oldFootnote=m_isFootnote && !zone.isCompatibleWith(0x201);\n  std::vector<uint32_t> text;\n  if (oldFootnote) {\n    for (int i=0; i<2; ++i) {\n      if (!zone.readString(text)) {\n        STOFF_DEBUG_MSG((\"StarWriterStruct::NoteInfo::read: can not read a string\\n\"));\n        f << *this << \"###string\";\n        ascFile.addPos(pos);\n        ascFile.addNote(f.str().c_str());\n        zone.closeSWRecord(type, \"StarNoteInfo\");\n      }\n      m_strings[i+2]=libstoff::getString(text);\n    }\n  }\n  int fl=zone.openFlagZone();\n\n  if (oldFootnote) {\n    m_posType=int(input->readULong(1));\n    m_numType=int(input->readULong(1));\n  }\n  m_type=int(input->readULong(1));\n  for (int i=0; i<2; ++i)\n    m_idx[i]=int(input->readULong(2));\n  if (zone.isCompatibleWith(0xc))\n    m_ftnOffset=int(input->readULong(2));\n  if (zone.isCompatibleWith(0x203))\n    m_idx[2]=int(input->readULong(2));\n  if (zone.isCompatibleWith(0x216) && (fl&0x10))\n    m_idx[3]=int(input->readULong(2));\n  zone.closeFlagZone();\n\n  if (zone.isCompatibleWith(0x203)) {\n    for (int i=0; i<2; ++i) {\n      if (!zone.readString(text)) {\n        STOFF_DEBUG_MSG((\"StarWriterStruct::NoteInfo::read: can not read a string\\n\"));\n        f << *this << \"###string\";\n        ascFile.addPos(pos);\n        ascFile.addNote(f.str().c_str());\n        zone.closeSWRecord(type, \"StarNoteInfo\");\n        return true;\n      }\n      m_strings[i]=libstoff::getString(text);\n    }\n  }\n\n  if (m_isFootnote && !oldFootnote) {\n    zone.openFlagZone();\n    m_posType=int(input->readULong(1));\n    m_numType=int(input->readULong(1));\n    zone.closeFlagZone();\n    for (int i=0; i<2; ++i) {\n      if (!zone.readString(text)) {\n        STOFF_DEBUG_MSG((\"StarWriterStruct::NoteInfo::read: can not read a string\\n\"));\n        f << *this << \"###string\";\n        ascFile.addPos(pos);\n        ascFile.addNote(f.str().c_str());\n        zone.closeSWRecord(type, \"StarNoteInfo\");\n        return true;\n      }\n      m_strings[i+2]=libstoff::getString(text);\n    }\n  }\n\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarNoteInfo\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, NoteInfo const &info)\n{\n  o << (info.m_isFootnote ? \"footnote\" : \"endnote\") << \",\";\n  if (info.m_type) o << \"type=\" << info.m_type << \",\";\n  for (int i=0; i<4; ++i) {\n    if (info.m_idx[i]==0xFFFF) continue;\n    char const *(wh[])= {\"pageId\", \"collIdx\", \"charIdx\", \"anchorCharIdx\"};\n    o << wh[i] << \"=\" << info.m_idx[i] << \",\";\n  }\n  if (info.m_ftnOffset) o << \"ftnOffset=\" << info.m_ftnOffset << \",\";\n  for (int i=0; i<4; ++i) {\n    if (info.m_strings[i].empty()) continue;\n    char const *(wh[])= {\"prefix\", \"suffix\", \"quoValis\", \"ergoSum\"};\n    o << wh[i] << \"=\" << info.m_strings[i].cstr() << \",\";\n  }\n  if (info.m_posType) o << \"type[pos]=\" << info.m_posType << \",\";\n  if (info.m_numType) o << \"type[number]=\" << info.m_numType << \",\";\n  return o;\n}\n\n////////////////////////////////////////////////////////////\n//  PrintData\n////////////////////////////////////////////////////////////\nbool PrintData::read(StarZone &zone)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='8' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::PrintData::read: can not read a printData\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx: InPagePreviewPrintData\n  f << \"Entries(StarPrintData)[\" << zone.getRecordLevel() << \"]:\";\n  m_flags=int(input->readULong(1));\n  int dim[2];\n  for (int i=0; i<2; ++i) dim[i]=int(input->readULong(2));\n  m_colRow=STOFFVec2i(dim[1],dim[0]);\n  for (int i=0; i<6; ++i) m_spacings[i]=int(input->readULong(2));\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarPrintData\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, PrintData const &info)\n{\n  if (info.m_flags) o << \"flags=\" << std::hex << info.m_flags << std::dec;\n  if (info.m_colRow[0]!=1) o << \"columns=\" << info.m_colRow[0] << \",\";\n  if (info.m_colRow[1]!=1) o << \"rows=\" << info.m_colRow[1] << \",\";\n  for (int i=0; i<6; ++i) {\n    if (!info.m_spacings[i]) continue;\n    char const *(wh[])= {\"left\", \"right\", \"top\", \"bottom\", \"horizontal\", \"vertical\"};\n    o << wh[i] << \"=\" << info.m_spacings[i] << \",\";\n  }\n  return o;\n}\n////////////////////////////////////////////////////////////\n//  Redline\n////////////////////////////////////////////////////////////\nbool Redline::read(StarZone &zone)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='D' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Redline::read: can not read a redline\\n\"));\n    return false;\n  }\n  f << \"Entries(StarRedline)[\" << zone.getRecordLevel() << \"]:\";\n  // sw_sw3redline.cxx inRedline\n  zone.openFlagZone();\n  m_type=int(input->readULong(1));\n  m_stringId=int(input->readULong(2));\n  zone.closeFlagZone();\n  m_date=long(input->readULong(4));\n  m_time=long(input->readULong(4));\n  std::vector<uint32_t> text;\n  if (!zone.readString(text)) {\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Redline: can not read the comment\\n\"));\n    f << \"###comment\";\n  }\n  else\n    m_comment=libstoff::getString(text);\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarRedline\");\n  return true;\n}\n\nbool Redline::readList(StarZone &zone, std::vector<Redline> &redlineList)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='R') return false;\n  if (!zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Redline::readList: can not read a mark\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InRedlines\n  f << \"Entries(StarRedline)[list-\" << zone.getRecordLevel() << \"]:\";\n  zone.openFlagZone();\n  int N=int(input->readULong(2));\n  zone.closeFlagZone();\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n\n  for (int i=0; i<N; ++i) {\n    pos=input->tell();\n    Redline redline;\n    if (!redline.read(zone)) {\n      input->seek(pos, librevenge::RVNG_SEEK_SET);\n      break;\n    }\n    redlineList.push_back(redline);\n  }\n\n  zone.closeSWRecord(type, \"StarRedline\");\n  return true;\n}\n\nbool Redline::readListList(StarZone &zone, std::vector<std::vector<Redline> > &redlineListList)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='V') return false;\n  if (!zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::Redline::readListList: can not read a mark\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InRedlines\n  f << \"Entries(StarRedline)[listList-\" << zone.getRecordLevel() << \"]:\";\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n\n  while (input->tell() < zone.getRecordLastPosition()) {\n    pos=input->tell();\n    std::vector<Redline> redlineList;\n    if (!readList(zone, redlineList)) {\n      input->seek(pos, librevenge::RVNG_SEEK_SET);\n      break;\n    }\n    redlineListList.push_back(redlineList);\n  }\n\n  zone.closeSWRecord(type, \"StarRedline\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, Redline const &redline)\n{\n  if (redline.m_type) o << \"type=\" << redline.m_type << \",\";\n  if (redline.m_stringId) o << \"stringId=\" << redline.m_stringId << \",\";\n  if (redline.m_date) o << \"date=\" << redline.m_date << \",\";\n  if (redline.m_time) o << \"time=\" << redline.m_time << \",\";\n  if (!redline.m_comment.empty()) o << \"comment=\" << redline.m_comment.cstr() << \",\";\n  return o;\n}\n\n////////////////////////////////////////////////////////////\n//  TOX\n////////////////////////////////////////////////////////////\nTOX::~TOX()\n{\n}\n\nbool TOX::read(StarZone &zone, StarObject &object)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='x' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::TOX::read::read: can not read a nodeRedline\\n\"));\n    return false;\n  }\n  long lastRecordPos=zone.getRecordLastPosition();\n  // sw_sw3misc.cxx: InTOX\n  f << \"Entries(StarTOX)[\" << zone.getRecordLevel() << \"]:\";\n  int fl=zone.openFlagZone();\n  if (fl&0xf0)\n    f << \"fl=\" << (fl>>4) << \",\";\n  m_type=int(input->readULong(2));\n  m_createType=int(input->readULong(2));\n  m_captionDisplay=int(input->readULong(2));\n  for (int i=0; i<2; ++i) m_stringIds[i]=int(input->readULong(2));\n  m_data=int(input->readULong(2));\n  m_formFlags=int(input->readULong(1));\n  zone.closeFlagZone();\n  std::vector<uint32_t> string;\n  for (int i=0; i<2; ++i) {\n    if (!zone.readString(string)) {\n      STOFF_DEBUG_MSG((\"StarWriterStruct::TOX::read: can not read aName\\n\"));\n      f << *this;\n      f << \"###aName\";\n      ascFile.addPos(pos);\n      ascFile.addNote(f.str().c_str());\n      zone.closeSWRecord(type, \"StarTOX\");\n      return true;\n    }\n    if (i==0)\n      m_name=libstoff::getString(string);\n    else\n      m_title=libstoff::getString(string);\n  }\n  if (zone.isCompatibleWith(0x215)) {\n    m_OLEOptions=int(input->readULong(2));\n    m_styleId=int(input->readULong(2));\n  }\n  else {\n    if (!zone.readString(string)) {\n      STOFF_DEBUG_MSG((\"StarWriterStruct::TOX::read: can not read aDummy\\n\"));\n      f << \"###aDummy\";\n      ascFile.addPos(pos);\n      ascFile.addNote(f.str().c_str());\n      zone.closeSWRecord(type, \"StarTOX\");\n      return true;;\n    }\n    if (!string.empty())\n      f << \"aDummy=\" << libstoff::getString(string).cstr() << \",\";\n  }\n\n  int N=int(input->readULong(1));\n  f << \"nPatterns=\" << N << \",\";\n  bool ok=true;\n  for (int i=0; i<N; ++i) { // storeme\n    if (object.getFormatManager()->readSWPatternLCL(zone))\n      continue;\n    ok=false;\n    f << \"###pat\";\n    break;\n  }\n  if (!ok) {\n    f << *this;\n    ascFile.addPos(pos);\n    ascFile.addNote(f.str().c_str());\n    zone.closeSWRecord(type, \"StarTOX\");\n    return true;\n  }\n  N=int(input->readULong(1));\n  for (int i=0; i<N; ++i)\n    m_stringIdList.push_back(int(input->readULong(2)));\n  N=int(input->readULong(1));\n  for (int i=0; i<N; ++i) {\n    Style style;\n    style.m_level=int(input->readULong(1));\n    int nCount=int(input->readULong(2));\n    f << \"nCount=\" << nCount << \",\";\n    if (input->tell()+2*nCount>lastRecordPos) {\n      STOFF_DEBUG_MSG((\"StarWriterStruct::TOX::read: can not read some string id\\n\"));\n      f << \"###styleId\";\n      ok=false;\n      break;\n    }\n    librevenge::RVNGString poolName;\n    for (int j=0; j<nCount; ++j) {\n      int val=int(input->readULong(2));\n      if (!zone.getPoolName(val, poolName))\n        f << \"###nPoolId=\" << val << \",\";\n      else\n        style.m_names.push_back(poolName);\n    }\n  }\n  if (!ok) {\n    f << *this;\n    ascFile.addPos(pos);\n    ascFile.addNote(f.str().c_str());\n    zone.closeSWRecord(type, \"StarTOX\");\n    return true;\n  }\n  fl=zone.openFlagZone();\n  m_stringIds[2]=int(input->readULong(2));\n  m_titleLength=long(input->readULong(4));\n  zone.closeFlagZone();\n\n  if ((fl&0x10)) {\n    while (input->tell()<lastRecordPos && input->peek()=='s') {\n      shared_ptr<StarFormatManagerInternal::FormatDef> format;\n      if (!object.getFormatManager()->readSWFormatDef(zone,'s', format, object)) {\n        STOFF_DEBUG_MSG((\"StarWriterStruct::TOX::read: can not read some format\\n\"));\n        f << \"###format,\";\n        break;\n      }\n      m_formatList.push_back(format);\n    }\n  }\n\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarTOX\");\n  return true;\n}\n\nbool TOX::readList(StarZone &zone, std::vector<TOX> &toxList, StarObject &object)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='u') return false;\n  if (!zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::TOX::readList: can not read a mark\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InTOXs\n  f << \"Entries(StarTOX)[list-\" << zone.getRecordLevel() << \"]:\";\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  while (input->tell()<zone.getRecordLastPosition()) {\n    pos=input->tell();\n    TOX tox;\n    if (!tox.read(zone, object)) {\n      input->seek(pos, librevenge::RVNG_SEEK_SET);\n      break;\n    }\n    toxList.push_back(tox);\n  }\n\n  zone.closeSWRecord(type, \"StarTOX\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, TOX const &tox)\n{\n  if (tox.m_type) o << \"type=\" << tox.m_type << \",\";\n  if (tox.m_createType) o << \"type[create]=\" << tox.m_createType << \",\";\n  if (tox.m_captionDisplay) o << \"captionDisplay=\" << tox.m_captionDisplay << \",\";\n  for (int i=0; i<3; ++i) {\n    if (tox.m_stringIds[i]==0xFFFF) continue;\n    char const *(wh[])= {\"stringId\", \"seqStringId\", \"sectStringId\"};\n    o << wh[i] << \"=\" << tox.m_stringIds[i] << \",\";\n  }\n  if (tox.m_styleId!=0xFFFF) o << \"styleId=\" << tox.m_styleId << \",\";\n  if (tox.m_data) o << \"data=\" << tox.m_data << \",\";\n  if (tox.m_formFlags) o << \"formFlags=\" << std::hex << tox.m_formFlags << std::dec << \",\";\n  if (!tox.m_title.empty()) o << \"title=\" << tox.m_title.cstr() << \",\";\n  if (!tox.m_name.empty()) o << \"name=\" << tox.m_name.cstr() << \",\";\n  if (tox.m_OLEOptions) o << \"OLEOptions=\" << tox.m_OLEOptions << \",\";\n  if (!tox.m_stringIdList.empty()) {\n    o << \"stringIdList=[\";\n    for (size_t i=0; i<tox.m_stringIdList.size(); ++i) {\n      if (tox.m_stringIdList[i]==0xFFFF)\n        o << \"_,\";\n      else\n        o << tox.m_stringIdList[i] << \",\";\n    }\n    o << \"],\";\n  }\n  if (!tox.m_styleList.empty()) {\n    o << \"styleList=[\";\n    for (size_t i=0; i<tox.m_styleList.size(); ++i)\n      o << \"[\" << tox.m_styleList[i] << \"],\";\n    o << \"],\";\n  }\n  if (tox.m_titleLength) o << \"titleLength=\" << tox.m_titleLength << \",\";\n  if (!tox.m_formatList.empty()) o << \"nFormat=\" << tox.m_formatList.size() << \",\";\n  return o;\n}\n\n////////////////////////////////////////////////////////////\n//  TOX51\n////////////////////////////////////////////////////////////\nTOX51::~TOX51()\n{\n}\n\nbool TOX51::read(StarZone &zone, StarObject &/*object*/)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='x' || !zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::TOX51::read: can not read a tox51\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InNodeTOX51\n  f << \"Entries(StarTox51)[\" << type << \"-\" << zone.getRecordLevel() << \"]:\";\n  std::vector<uint32_t> string;\n  if (zone.isCompatibleWith(0x201)) {\n    int strId=int(input->readULong(2));\n    if (strId!=0xFFFF && !zone.getPoolName(strId, m_typeName))\n      f << \"###nPoolId=\" << strId << \",\";\n  }\n  else {\n    if (!zone.readString(string)) {\n      STOFF_DEBUG_MSG((\"StarWriterStruct::TOX51::read: can not read typeName\\n\"));\n      f << *this << \"###typeName\";\n      ascFile.addPos(pos);\n      ascFile.addNote(f.str().c_str());\n      zone.closeSWRecord(type, \"StarTox51\");\n      return true;\n    }\n    m_typeName=libstoff::getString(string);\n  }\n  if (!zone.readString(string)) {\n    STOFF_DEBUG_MSG((\"StarWriterStruct::TOX51::read: can not read aTitle\\n\"));\n    f << *this << \"###aTitle\";\n    ascFile.addPos(pos);\n    ascFile.addNote(f.str().c_str());\n    zone.closeSWRecord(type, \"StarTox51\");\n    return true;\n  }\n  m_title=libstoff::getString(string);\n  int fl=zone.openFlagZone();\n  m_createType=int(input->readULong(2));\n  m_type=int(input->readULong(1));\n  if (zone.isCompatibleWith(0x213) && (fl&0x10))\n    m_firstTabPos=int(input->readULong(2));\n\n  int N=int(input->readULong(1));\n  bool ok=true;\n  for (int i=0; i<N; ++i) {\n    if (!zone.readString(string)) {\n      STOFF_DEBUG_MSG((\"StarWriterStruct::TOX51::read: can not read a pattern name\\n\"));\n      f << \"###pat\";\n      ok=false;\n      break;\n    }\n    m_patternList.push_back(libstoff::getString(string));\n  }\n  if (!ok) {\n    f << *this;\n    ascFile.addPos(pos);\n    ascFile.addNote(f.str().c_str());\n    zone.closeSWRecord(type, \"StarTox51\");\n    return true;\n  }\n  N=int(input->readULong(1));\n  for (int i=0; i<N; ++i)\n    m_stringIdList.push_back(int(input->readULong(2)));\n  m_infLevel=int(input->readULong(2));\n\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarTox51\");\n  return true;\n}\n\n\nbool TOX51::readList(StarZone &zone, std::vector<TOX51> &toxList, StarObject &object)\n{\n  STOFFInputStreamPtr input=zone.input();\n  libstoff::DebugFile &ascFile=zone.ascii();\n  libstoff::DebugStream f;\n  long pos=input->tell();\n  char type;\n  if (input->peek()!='y') return false;\n  if (!zone.openSWRecord(type)) {\n    input->seek(pos, librevenge::RVNG_SEEK_SET);\n    STOFF_DEBUG_MSG((\"StarWriterStruct::TOX51::readList: can not read a mark\\n\"));\n    return false;\n  }\n  // sw_sw3misc.cxx InTOX51s\n  f << \"Entries(StarTox51)[list-\" << zone.getRecordLevel() << \"]:\";\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  while (input->tell()<zone.getRecordLastPosition()) {\n    pos=input->tell();\n    TOX51 tox;\n    if (!tox.read(zone, object)) {\n      input->seek(pos, librevenge::RVNG_SEEK_SET);\n      break;\n    }\n    toxList.push_back(tox);\n  }\n\n  zone.closeSWRecord(type, \"StarTox51\");\n  return true;\n}\n\nstd::ostream &operator<<(std::ostream &o, TOX51 const &tox)\n{\n  if (!tox.m_typeName.empty()) o << \"type[name]=\" << tox.m_typeName.cstr() << \",\";\n  if (tox.m_type) o << \"type=\" << tox.m_type << \",\";\n  if (tox.m_createType) o << \"type[create]=\" << tox.m_createType << \",\";\n  if (tox.m_firstTabPos) o << \"firstTabPos=\" << tox.m_firstTabPos << \",\";\n  if (!tox.m_title.empty()) o << \"title=\" << tox.m_title.cstr() << \",\";\n  if (!tox.m_patternList.empty()) {\n    o << \"patternList=[\";\n    for (size_t i=0; i<tox.m_patternList.size(); ++i)\n      o << tox.m_patternList[i].cstr() << \",\";\n    o << \"],\";\n  }\n  if (!tox.m_stringIdList.empty()) {\n    o << \"stringIdList=[\";\n    for (size_t i=0; i<tox.m_stringIdList.size(); ++i) {\n      if (tox.m_stringIdList[i]==0xFFFF)\n        o << \"_,\";\n      else\n        o << tox.m_stringIdList[i] << \",\";\n    }\n    o << \"],\";\n  }\n  if (tox.m_infLevel) o << \"infLevel=\" << tox.m_infLevel << \",\";\n  return o;\n}\n}\n// vim: set filetype=cpp tabstop=2 shiftwidth=2 cindent autoindent smartindent noexpandtab:\n"], "filenames": ["src/lib/StarWriterStruct.cxx"], "buggy_code_start_loc": [330], "buggy_code_end_loc": [331], "fixing_code_start_loc": [330], "fixing_code_end_loc": [331], "type": "CWE-787", "message": "Document Liberation Project libstaroffice before 2017-04-07 has an out-of-bounds write caused by a stack-based buffer overflow related to the DatabaseName::read function in lib/StarWriterStruct.cxx.", "other": {"cve": {"id": "CVE-2017-9432", "sourceIdentifier": "cve@mitre.org", "published": "2017-06-05T03:29:00.243", "lastModified": "2017-06-12T14:12:48.433", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Document Liberation Project libstaroffice before 2017-04-07 has an out-of-bounds write caused by a stack-based buffer overflow related to the DatabaseName::read function in lib/StarWriterStruct.cxx."}, {"lang": "es", "value": "La biblioteca de importaci\u00f3n libstaroffice antes del 07-04-2017 de Document Liberation Project, presenta una escritura fuera de l\u00edmites causada por un desbordamiento de b\u00fafer en la regi\u00f3n stack de la memoria relacionado con la funci\u00f3n DatabaseName::read en la biblioteca lib/StarWriterStruct.cxx."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libstaroffice_project:libstaroffice:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.0.3", "matchCriteriaId": "06369F32-AE63-44A8-9B79-3950E1F4D5E9"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=1029", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/fosnola/libstaroffice/commit/2d6253c7a692a3d92785dd990fce7256ea05e794", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fosnola/libstaroffice/commit/2d6253c7a692a3d92785dd990fce7256ea05e794"}}