{"buggy_code": ["////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//              Copyright (c) 1998 - 2013 Conifer Software.               //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// pack_utils.c\n\n// This module provides the high-level API for creating WavPack files from\n// audio data. It manages the buffers used to deinterleave the data passed\n// in from the application into the individual streams and it handles the\n// generation of riff headers and the \"fixup\" on the first WavPack block\n// header for the case where the number of samples was unknown (or wrong).\n// The actual audio stream compression is handled in the pack.c module.\n\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#include \"wavpack_local.h\"\n\n///////////////////////////// executable code ////////////////////////////////\n\n// Open context for writing WavPack files. The returned context pointer is used\n// in all following calls to the library. The \"blockout\" function will be used\n// to store the actual completed WavPack blocks and will be called with the id\n// pointers containing user defined data (one for the wv file and one for the\n// wvc file). A return value of NULL indicates that memory could not be\n// allocated for the context.\n\nWavpackContext *WavpackOpenFileOutput (WavpackBlockOutput blockout, void *wv_id, void *wvc_id)\n{\n    WavpackContext *wpc = malloc (sizeof (WavpackContext));\n\n    if (!wpc)\n        return NULL;\n\n    CLEAR (*wpc);\n    wpc->total_samples = -1;\n    wpc->stream_version = CUR_STREAM_VERS;\n    wpc->blockout = blockout;\n    wpc->wv_out = wv_id;\n    wpc->wvc_out = wvc_id;\n    return wpc;\n}\n\nstatic int add_to_metadata (WavpackContext *wpc, void *data, uint32_t bcount, unsigned char id);\n\n// New for version 5.0, this function allows the application to store a file extension and a\n// file_format identification. The extension would be used by the unpacker if the user had not\n// specified the target filename, and specifically handles the case where the original file\n// had the \"wrong\" extension for the file format (e.g., a Wave64 file having a \"wav\" extension)\n// or an alternative (e.g., \"bwf\") or where the file format is not known. Specifying a file\n// format besides the default WP_FORMAT_WAV will ensure that old decoders will not be able to\n// see the non-wav wrapper provided with WavpackAddWrapper() (which they would end up putting\n// on a file with a .wav extension).\n\nvoid WavpackSetFileInformation (WavpackContext *wpc, char *file_extension, unsigned char file_format)\n{\n    if (file_extension && strlen (file_extension) < sizeof (wpc->file_extension)) {\n        add_to_metadata (wpc, file_extension, (uint32_t) strlen (file_extension), ID_ALT_EXTENSION);\n        strcpy (wpc->file_extension, file_extension);\n    }\n\n    wpc->file_format = file_format;\n}\n\n// Set configuration for writing WavPack files. This must be done before\n// sending any actual samples, however it is okay to send wrapper or other\n// metadata before calling this. The \"config\" structure contains the following\n// required information:\n\n// config->bytes_per_sample     see WavpackGetBytesPerSample() for info\n// config->bits_per_sample      see WavpackGetBitsPerSample() for info\n// config->channel_mask         Microsoft standard (mono = 4, stereo = 3)\n// config->num_channels         self evident\n// config->sample_rate          self evident\n\n// In addition, the following fields and flags may be set:\n\n// config->flags:\n// --------------\n// o CONFIG_HYBRID_FLAG         select hybrid mode (must set bitrate)\n// o CONFIG_JOINT_STEREO        select joint stereo (must set override also)\n// o CONFIG_JOINT_OVERRIDE      override default joint stereo selection\n// o CONFIG_HYBRID_SHAPE        select hybrid noise shaping (set override &\n//                                                      shaping_weight != 0.0)\n// o CONFIG_SHAPE_OVERRIDE      override default hybrid noise shaping\n//                               (set CONFIG_HYBRID_SHAPE and shaping_weight)\n// o CONFIG_FAST_FLAG           \"fast\" compression mode\n// o CONFIG_HIGH_FLAG           \"high\" compression mode\n// o CONFIG_BITRATE_KBPS        hybrid bitrate is kbps, not bits / sample\n// o CONFIG_CREATE_WVC          create correction file\n// o CONFIG_OPTIMIZE_WVC        maximize bybrid compression (-cc option)\n// o CONFIG_CALC_NOISE          calc noise in hybrid mode\n// o CONFIG_EXTRA_MODE          extra processing mode (slow!)\n// o CONFIG_SKIP_WVX            no wvx stream for floats & large ints\n// o CONFIG_MD5_CHECKSUM        specify if you plan to store MD5 signature\n// o CONFIG_CREATE_EXE          specify if you plan to prepend sfx module\n// o CONFIG_OPTIMIZE_MONO       detect and optimize for mono files posing as\n//                               stereo (uses a more recent stream format that\n//                               is not compatible with decoders < 4.3)\n\n// config->bitrate              hybrid bitrate in either bits/sample or kbps\n// config->shaping_weight       hybrid noise shaping coefficient override\n// config->block_samples        force samples per WavPack block (0 = use deflt)\n// config->float_norm_exp       select floating-point data (127 for +/-1.0)\n// config->xmode                extra mode processing value override\n\n// If the number of samples to be written is known then it should be passed\n// here. If the duration is not known then pass -1. In the case that the size\n// is not known (or the writing is terminated early) then it is suggested that\n// the application retrieve the first block written and let the library update\n// the total samples indication. A function is provided to do this update and\n// it should be done to the \"correction\" file also. If this cannot be done\n// (because a pipe is being used, for instance) then a valid WavPack will still\n// be created, but when applications want to access that file they will have\n// to seek all the way to the end to determine the actual duration. Also, if\n// a RIFF header has been included then it should be updated as well or the\n// WavPack file will not be directly unpackable to a valid wav file (although\n// it will still be usable by itself). A return of FALSE indicates an error.\n//\n// The enhanced version of this function now allows setting the identities of\n// any channels that are NOT standard Microsoft channels and are therefore not\n// represented in the channel mask. WavPack files require that all the Microsoft\n// channels come first (and in Microsoft order) and these are followed by any\n// other channels (which can be in any order).\n//\n// The identities are provided in a NULL-terminated string (0x00 is not an allowed\n// channel ID). The Microsoft channels may be provided as well (and will be checked)\n// but it is really only necessary to provide the \"unknown\" channels. Any truly\n// unknown channels are indicated with a 0xFF.\n//\n// The channel IDs so far reserved are listed here:\n//\n// 0:           not allowed / terminator\n// 1 - 18:      Microsoft standard channels\n// 30, 31:      Stereo mix from RF64 (not really recommended, but RF64 specifies this)\n// 33 - 44:     Core Audio channels (see Core Audio specification)\n// 127 - 128:   Amio LeftHeight, Amio RightHeight\n// 138 - 142:   Amio BottomFrontLeft/Center/Right, Amio ProximityLeft/Right\n// 200 - 207:   Core Audio channels (see Core Audio specification)\n// 221 - 224:   Core Audio channels 301 - 305 (offset by 80)\n// 255:         Present but unknown or unused channel\n//\n// All other channel IDs are reserved. Ask if something you need is missing.\n\n// Table of channels that will automatically \"pair\" into a single stereo stream\n\nstatic const struct { unsigned char a, b; } stereo_pairs [] = {\n    { 1, 2 },       // FL, FR\n    { 5, 6 },       // BL, BR\n    { 7, 8 },       // FLC, FRC\n    { 10, 11 },     // SL, SR\n    { 13, 15 },     // TFL, TFR\n    { 16, 18 },     // TBL, TBR\n    { 30, 31 },     // stereo mix L,R (RF64)\n    { 33, 34 },     // Rls, Rrs\n    { 35, 36 },     // Lw, Rw\n    { 38, 39 },     // Lt, Rt\n    { 127, 128 },   // Lh, Rh\n    { 138, 140 },   // Bfl, Bfr\n    { 141, 142 },   // Pl, Pr\n    { 200, 201 },   // Amb_W, Amb_X\n    { 202, 203 },   // Amb_Y, Amb_Z\n    { 204, 205 },   // MS_Mid, MS_Side\n    { 206, 207 },   // XY_X, XY_Y\n    { 221, 222 },   // Hph_L, Hph_R\n};\n\n#define NUM_STEREO_PAIRS (sizeof (stereo_pairs) / sizeof (stereo_pairs [0]))\n\n// Legacy version of this function for compatibility with existing applications. Note that this version\n// also generates older streams to be compatible with all decoders back to 4.0, but of course cannot be\n// used with > 2^32 samples or non-Microsoft channels. The older stream version only differs in that it\n// does not support the \"mono optimization\" feature where stereo blocks containing identical audio data\n// in both channels are encoded in mono for better efficiency.\n\nint WavpackSetConfiguration (WavpackContext *wpc, WavpackConfig *config, uint32_t total_samples)\n{\n    config->flags |= CONFIG_COMPATIBLE_WRITE;       // write earlier version streams\n\n    if (total_samples == (uint32_t) -1)\n        return WavpackSetConfiguration64 (wpc, config, -1, NULL);\n    else\n        return WavpackSetConfiguration64 (wpc, config, total_samples, NULL);\n}\n\nint WavpackSetConfiguration64 (WavpackContext *wpc, WavpackConfig *config, int64_t total_samples, const unsigned char *chan_ids)\n{\n    uint32_t flags, bps = 0;\n    uint32_t chan_mask = config->channel_mask;\n    int num_chans = config->num_channels;\n    int i;\n\n    wpc->stream_version = (config->flags & CONFIG_COMPATIBLE_WRITE) ? CUR_STREAM_VERS : MAX_STREAM_VERS;\n\n    if ((config->qmode & QMODE_DSD_AUDIO) && config->bytes_per_sample == 1 && config->bits_per_sample == 8) {\n#ifdef ENABLE_DSD\n        wpc->dsd_multiplier = 1;\n        flags = DSD_FLAG;\n\n        for (i = 14; i >= 0; --i)\n            if (config->sample_rate % sample_rates [i] == 0) {\n                int divisor = config->sample_rate / sample_rates [i];\n\n                if (divisor && (divisor & (divisor - 1)) == 0) {\n                    config->sample_rate /= divisor;\n                    wpc->dsd_multiplier = divisor;\n                    break;\n                }\n            }\n\n        // most options that don't apply to DSD we can simply ignore for now, but NOT hybrid mode!\n        if (config->flags & CONFIG_HYBRID_FLAG) {\n            strcpy (wpc->error_message, \"hybrid mode not available for DSD!\");\n            return FALSE;\n        }\n\n        // with DSD, very few PCM options work (or make sense), so only allow those that do\n        config->flags &= (CONFIG_HIGH_FLAG | CONFIG_MD5_CHECKSUM | CONFIG_PAIR_UNDEF_CHANS);\n        config->float_norm_exp = config->xmode = 0;\n#else\n        strcpy (wpc->error_message, \"libwavpack not configured for DSD!\");\n        return FALSE;\n#endif\n    }\n    else\n        flags = config->bytes_per_sample - 1;\n\n    wpc->total_samples = total_samples;\n    wpc->config.sample_rate = config->sample_rate;\n    wpc->config.num_channels = config->num_channels;\n    wpc->config.channel_mask = config->channel_mask;\n    wpc->config.bits_per_sample = config->bits_per_sample;\n    wpc->config.bytes_per_sample = config->bytes_per_sample;\n    wpc->config.block_samples = config->block_samples;\n    wpc->config.flags = config->flags;\n    wpc->config.qmode = config->qmode;\n\n    if (config->flags & CONFIG_VERY_HIGH_FLAG)\n        wpc->config.flags |= CONFIG_HIGH_FLAG;\n\n    for (i = 0; i < 15; ++i)\n        if (wpc->config.sample_rate == sample_rates [i])\n            break;\n\n    flags |= i << SRATE_LSB;\n\n    // all of this stuff only applies to PCM\n\n    if (!(flags & DSD_FLAG)) {\n        if (config->float_norm_exp) {\n            wpc->config.float_norm_exp = config->float_norm_exp;\n            wpc->config.flags |= CONFIG_FLOAT_DATA;\n            flags |= FLOAT_DATA;\n        }\n        else\n            flags |= ((config->bytes_per_sample * 8) - config->bits_per_sample) << SHIFT_LSB;\n\n        if (config->flags & CONFIG_HYBRID_FLAG) {\n            flags |= HYBRID_FLAG | HYBRID_BITRATE | HYBRID_BALANCE;\n\n            if (!(wpc->config.flags & CONFIG_SHAPE_OVERRIDE)) {\n                wpc->config.flags |= CONFIG_HYBRID_SHAPE | CONFIG_AUTO_SHAPING;\n                flags |= HYBRID_SHAPE | NEW_SHAPING;\n            }\n            else if (wpc->config.flags & CONFIG_HYBRID_SHAPE) {\n                wpc->config.shaping_weight = config->shaping_weight;\n                flags |= HYBRID_SHAPE | NEW_SHAPING;\n            }\n\n            if (wpc->config.flags & (CONFIG_CROSS_DECORR | CONFIG_OPTIMIZE_WVC))\n                flags |= CROSS_DECORR;\n\n            if (config->flags & CONFIG_BITRATE_KBPS) {\n                bps = (uint32_t) floor (config->bitrate * 256000.0 / config->sample_rate / config->num_channels + 0.5);\n\n                if (bps > (64 << 8))\n                    bps = 64 << 8;\n            }\n            else\n                bps = (uint32_t) floor (config->bitrate * 256.0 + 0.5);\n        }\n        else\n            flags |= CROSS_DECORR;\n\n        if (!(config->flags & CONFIG_JOINT_OVERRIDE) || (config->flags & CONFIG_JOINT_STEREO))\n            flags |= JOINT_STEREO;\n\n        if (config->flags & CONFIG_CREATE_WVC)\n            wpc->wvc_flag = TRUE;\n    }\n\n    // if a channel-identities string was specified, process that here, otherwise all channels\n    // not present in the channel mask are considered \"unassigned\"\n\n    if (chan_ids) {\n        int lastchan = 0, mask_copy = chan_mask;\n\n        if ((int) strlen ((char *) chan_ids) > num_chans) {          // can't be more than num channels!\n            strcpy (wpc->error_message, \"chan_ids longer than num channels!\");\n            return FALSE;\n        }\n\n        // skip past channels that are specified in the channel mask (no reason to store those)\n\n        while (*chan_ids)\n            if (*chan_ids <= 32 && *chan_ids > lastchan && (mask_copy & (1 << (*chan_ids-1)))) {\n                mask_copy &= ~(1 << (*chan_ids-1));\n                lastchan = *chan_ids++;\n            }\n            else\n                break;\n\n        // now scan the string for an actually defined channel (and don't store if there aren't any)\n\n        for (i = 0; chan_ids [i]; i++)\n            if (chan_ids [i] != 0xff) {\n                wpc->channel_identities = (unsigned char *) strdup ((char *) chan_ids);\n                break;\n            }\n    }\n\n    // This loop goes through all the channels and creates the Wavpack \"streams\" for them to go in.\n    // A stream can hold either one or two channels, so we have several rules to determine how many\n    // channels will go in each stream.\n\n    for (wpc->current_stream = 0; num_chans; wpc->current_stream++) {\n        WavpackStream *wps = malloc (sizeof (WavpackStream));\n        unsigned char left_chan_id = 0, right_chan_id = 0;\n        int pos, chans = 1;\n\n        // allocate the stream and initialize the pointer to it\n        wpc->streams = realloc (wpc->streams, (wpc->current_stream + 1) * sizeof (wpc->streams [0]));\n        wpc->streams [wpc->current_stream] = wps;\n        CLEAR (*wps);\n\n        // if there are any bits [still] set in the channel_mask, get the next one or two IDs from there\n        if (chan_mask)\n            for (pos = 0; pos < 32; ++pos)\n                if (chan_mask & (1 << pos)) {\n                    if (left_chan_id) {\n                        right_chan_id = pos + 1;\n                        break;\n                    }\n                    else {\n                        chan_mask &= ~(1 << pos);\n                        left_chan_id = pos + 1;\n                    }\n                }\n\n        // next check for any channels identified in the channel-identities string\n        while (!right_chan_id && chan_ids && *chan_ids)\n            if (left_chan_id)\n                right_chan_id = *chan_ids;\n            else\n                left_chan_id = *chan_ids++;\n\n        // assume anything we did not get is \"unassigned\"\n        if (!left_chan_id)\n            left_chan_id = right_chan_id = 0xff;\n        else if (!right_chan_id)\n            right_chan_id = 0xff;\n\n        // if we have 2 channels, this is where we decide if we can combine them into one stream:\n        // 1. they are \"unassigned\" and we've been told to combine unassigned pairs, or\n        // 2. they appear together in the valid \"pairings\" list\n        if (num_chans >= 2) {\n            if ((config->flags & CONFIG_PAIR_UNDEF_CHANS) && left_chan_id == 0xff && right_chan_id == 0xff)\n                chans = 2;\n            else\n                for (i = 0; i < NUM_STEREO_PAIRS; ++i)\n                    if ((left_chan_id == stereo_pairs [i].a && right_chan_id == stereo_pairs [i].b) ||\n                        (left_chan_id == stereo_pairs [i].b && right_chan_id == stereo_pairs [i].a)) {\n                            if (right_chan_id <= 32 && (chan_mask & (1 << (right_chan_id-1))))\n                                chan_mask &= ~(1 << (right_chan_id-1));\n                            else if (chan_ids && *chan_ids == right_chan_id)\n                                chan_ids++;\n\n                            chans = 2;\n                            break;\n                        }\n        }\n\n        num_chans -= chans;\n\n        if (num_chans && wpc->current_stream == NEW_MAX_STREAMS - 1)\n            break;\n\n        memcpy (wps->wphdr.ckID, \"wvpk\", 4);\n        wps->wphdr.ckSize = sizeof (WavpackHeader) - 8;\n        SET_TOTAL_SAMPLES (wps->wphdr, wpc->total_samples);\n        wps->wphdr.version = wpc->stream_version;\n        wps->wphdr.flags = flags;\n        wps->bits = bps;\n\n        if (!wpc->current_stream)\n            wps->wphdr.flags |= INITIAL_BLOCK;\n\n        if (!num_chans)\n            wps->wphdr.flags |= FINAL_BLOCK;\n\n        if (chans == 1) {\n            wps->wphdr.flags &= ~(JOINT_STEREO | CROSS_DECORR | HYBRID_BALANCE);\n            wps->wphdr.flags |= MONO_FLAG;\n        }\n    }\n\n    wpc->num_streams = wpc->current_stream;\n    wpc->current_stream = 0;\n\n    if (num_chans) {\n        strcpy (wpc->error_message, \"too many channels!\");\n        return FALSE;\n    }\n\n    if (config->flags & CONFIG_EXTRA_MODE)\n        wpc->config.xmode = config->xmode ? config->xmode : 1;\n\n    return TRUE;\n}\n\n// This function allows setting the Core Audio File channel layout, many of which do not\n// conform to the Microsoft ordering standard that Wavpack requires internally (at least for\n// those channels present in the \"channel mask\"). In addition to the layout tag, this function\n// allows a reordering string to be stored in the file to allow the unpacker to reorder the\n// channels back to the specified layout (if it is aware of this feature and wants to restore\n// the CAF order). The number of channels in the layout is specified in the lower nybble of\n// the layout word, and if a reorder string is specified it must be that long. Note that all\n// the reordering is actually done outside of this library, and that if reordering is done\n// then the appropriate qmode bit must be set to ensure that any MD5 sum is stored with a new\n// ID so that old decoders don't try to verify it (and to let the decoder know that a reorder\n// might be required).\n//\n// Note: This function should only be used to encode Core Audio files in such a way that a\n// verbatim archive can be created. Applications can just include the chan_ids parameter in\n// the call to WavpackSetConfiguration64() if there are non-Microsoft channels to specify,\n// or do nothing special if only Microsoft channels are present (the vast majority of cases).\n\nint WavpackSetChannelLayout (WavpackContext *wpc, uint32_t layout_tag, const unsigned char *reorder)\n{\n    int nchans = layout_tag & 0xff;\n\n    if ((layout_tag & 0xff00ff00) || nchans > wpc->config.num_channels)\n        return FALSE;\n\n    wpc->channel_layout = layout_tag;\n\n    if (wpc->channel_reordering) {\n        free (wpc->channel_reordering);\n        wpc->channel_reordering = NULL;\n    }\n\n    if (nchans && reorder) {\n        int min_index = 256, i;\n\n        for (i = 0; i < nchans; ++i)\n            if (reorder [i] < min_index)\n                min_index = reorder [i];\n\n        wpc->channel_reordering = malloc (nchans);\n\n        if (wpc->channel_reordering)\n            for (i = 0; i < nchans; ++i)\n                wpc->channel_reordering [i] = reorder [i] - min_index;\n    }\n\n    return TRUE;\n}\n\n// Prepare to actually pack samples by determining the size of the WavPack\n// blocks and allocating sample buffers and initializing each stream. Call\n// after WavpackSetConfiguration() and before WavpackPackSamples(). A return\n// of FALSE indicates an error.\n\nstatic int write_metadata_block (WavpackContext *wpc);\n\nint WavpackPackInit (WavpackContext *wpc)\n{\n    if (wpc->metabytes > 16384)             // 16384 bytes still leaves plenty of room for audio\n        write_metadata_block (wpc);         //  in this block (otherwise write a special one)\n\n    // The default block size is a compromise. Longer blocks provide better encoding efficiency,\n    // but longer blocks adversely affect memory requirements and seeking performance. For WavPack\n    // version 5.0, the default block sizes have been reduced by half from the previous version,\n    // but the difference in encoding efficiency will generally be less than 0.1 percent.\n\n    if (wpc->dsd_multiplier) {\n        wpc->block_samples = (wpc->config.sample_rate % 7) ? 48000 : 44100;\n\n        if (wpc->config.flags & CONFIG_HIGH_FLAG)\n            wpc->block_samples /= 2;\n\n        if (wpc->config.num_channels == 1)\n            wpc->block_samples *= 2;\n\n        while (wpc->block_samples > 12000 && wpc->block_samples * wpc->config.num_channels > 300000)\n            wpc->block_samples /= 2;\n    }\n    else {\n        int divisor = (wpc->config.flags & CONFIG_HIGH_FLAG) ? 2 : 4;\n\n        while (wpc->config.sample_rate % divisor)\n            divisor--;\n\n        wpc->block_samples = wpc->config.sample_rate / divisor;\n\n        while (wpc->block_samples > 12000 && wpc->block_samples * wpc->config.num_channels > 75000)\n            wpc->block_samples /= 2;\n\n        while (wpc->block_samples * wpc->config.num_channels < 20000)\n            wpc->block_samples *= 2;\n    }\n\n    if (wpc->config.block_samples) {\n        if ((wpc->config.flags & CONFIG_MERGE_BLOCKS) &&\n            wpc->block_samples > (uint32_t) wpc->config.block_samples) {\n                wpc->block_boundary = wpc->config.block_samples;\n                wpc->block_samples /= wpc->config.block_samples;\n                wpc->block_samples *= wpc->config.block_samples;\n        }\n        else\n            wpc->block_samples = wpc->config.block_samples;\n    }\n\n    wpc->ave_block_samples = wpc->block_samples;\n    wpc->max_samples = wpc->block_samples + (wpc->block_samples >> 1);\n\n    for (wpc->current_stream = 0; wpc->current_stream < wpc->num_streams; wpc->current_stream++) {\n        WavpackStream *wps = wpc->streams [wpc->current_stream];\n\n        wps->sample_buffer = malloc (wpc->max_samples * (wps->wphdr.flags & MONO_FLAG ? 4 : 8));\n\n#ifdef ENABLE_DSD\n        if (wps->wphdr.flags & DSD_FLAG)\n            pack_dsd_init (wpc);\n        else\n#endif\n            pack_init (wpc);\n    }\n\n    return TRUE;\n}\n\n// Pack the specified samples. Samples must be stored in longs in the native\n// endian format of the executing processor. The number of samples specified\n// indicates composite samples (sometimes called \"frames\"). So, the actual\n// number of data points would be this \"sample_count\" times the number of\n// channels. Note that samples are accumulated here until enough exist to\n// create a complete WavPack block (or several blocks for multichannel audio).\n// If an application wants to break a block at a specific sample, then it must\n// simply call WavpackFlushSamples() to force an early termination. Completed\n// WavPack blocks are send to the function provided in the initial call to\n// WavpackOpenFileOutput(). A return of FALSE indicates an error.\n\nstatic int pack_streams (WavpackContext *wpc, uint32_t block_samples);\nstatic int create_riff_header (WavpackContext *wpc, int64_t total_samples, void *outbuffer);\n\nint WavpackPackSamples (WavpackContext *wpc, int32_t *sample_buffer, uint32_t sample_count)\n{\n    int nch = wpc->config.num_channels;\n\n    while (sample_count) {\n        int32_t *source_pointer = sample_buffer;\n        unsigned int samples_to_copy;\n\n        if (!wpc->riff_header_added && !wpc->riff_header_created && !wpc->file_format) {\n            char riff_header [128];\n\n            if (!add_to_metadata (wpc, riff_header, create_riff_header (wpc, wpc->total_samples, riff_header), ID_RIFF_HEADER))\n                return FALSE;\n        }\n\n        if (wpc->acc_samples + sample_count > wpc->max_samples)\n            samples_to_copy = wpc->max_samples - wpc->acc_samples;\n        else\n            samples_to_copy = sample_count;\n\n        for (wpc->current_stream = 0; wpc->current_stream < wpc->num_streams; wpc->current_stream++) {\n            WavpackStream *wps = wpc->streams [wpc->current_stream];\n            int32_t *dptr, *sptr, cnt;\n\n            dptr = wps->sample_buffer + wpc->acc_samples * (wps->wphdr.flags & MONO_FLAG ? 1 : 2);\n            sptr = source_pointer;\n            cnt = samples_to_copy;\n\n            // This code used to just copy the 32-bit samples regardless of the actual size with the\n            // assumption that the caller had properly sign-extended the values (if they were smaller\n            // than 32 bits). However, several people have discovered that if the data isn't properly\n            // sign extended then ugly things happen (e.g. CRC errors that show up only on decode).\n            // To prevent this, we now explicitly sign-extend samples smaller than 32-bit when we\n            // copy, and the performance hit from doing this is very small (generally < 1%).\n\n            if (wps->wphdr.flags & MONO_FLAG) {\n                switch (wpc->config.bytes_per_sample) {\n                    case 1:\n                        while (cnt--) {\n                            *dptr++ = (signed char) *sptr;\n                            sptr += nch;\n                        }\n\n                        break;\n\n                    case 2:\n                        while (cnt--) {\n                            *dptr++ = (int16_t) *sptr;\n                            sptr += nch;\n                        }\n\n                        break;\n\n                    case 3:\n                        while (cnt--) {\n                            *dptr++ = (*sptr << 8) >> 8;\n                            sptr += nch;\n                        }\n\n                        break;\n\n                    default:\n                        while (cnt--) {\n                            *dptr++ = *sptr;\n                            sptr += nch;\n                        }\n                }\n\n                source_pointer++;\n            }\n            else {\n                switch (wpc->config.bytes_per_sample) {\n                    case 1:\n                        while (cnt--) {\n                            *dptr++ = (signed char) sptr [0];\n                            *dptr++ = (signed char) sptr [1];\n                            sptr += nch;\n                        }\n\n                        break;\n\n                    case 2:\n                        while (cnt--) {\n                            *dptr++ = (int16_t) sptr [0];\n                            *dptr++ = (int16_t) sptr [1];\n                            sptr += nch;\n                        }\n\n                        break;\n\n                    case 3:\n                        while (cnt--) {\n                            *dptr++ = (sptr [0] << 8) >> 8;\n                            *dptr++ = (sptr [1] << 8) >> 8;\n                            sptr += nch;\n                        }\n\n                        break;\n\n                    default:\n                        while (cnt--) {\n                            *dptr++ = sptr [0];\n                            *dptr++ = sptr [1];\n                            sptr += nch;\n                        }\n                }\n\n                source_pointer += 2;\n            }\n        }\n\n        sample_buffer += samples_to_copy * nch;\n        sample_count -= samples_to_copy;\n\n        if ((wpc->acc_samples += samples_to_copy) == wpc->max_samples &&\n            !pack_streams (wpc, wpc->block_samples))\n                return FALSE;\n    }\n\n    return TRUE;\n}\n\n// Flush all accumulated samples into WavPack blocks. This is normally called\n// after all samples have been sent to WavpackPackSamples(), but can also be\n// called to terminate a WavPack block at a specific sample (in other words it\n// is possible to continue after this operation). This is also called to\n// dump non-audio blocks like those holding metadata for various purposes.\n// A return of FALSE indicates an error.\n\nint WavpackFlushSamples (WavpackContext *wpc)\n{\n    while (wpc->acc_samples) {\n        uint32_t block_samples;\n\n        if (wpc->acc_samples > wpc->block_samples)\n            block_samples = wpc->acc_samples / 2;\n        else\n            block_samples = wpc->acc_samples;\n\n        if (!pack_streams (wpc, block_samples))\n            return FALSE;\n    }\n\n    if (wpc->metacount)\n        write_metadata_block (wpc);\n\n    return TRUE;\n}\n\n// Note: The following function is no longer required because a proper wav\n// header is now automatically generated for the application. However, if the\n// application wants to generate its own header or wants to include additional\n// chunks, then this function can still be used in which case the automatic\n// wav header generation is suppressed.\n\n// Add wrapper (currently RIFF only) to WavPack blocks. This should be called\n// before sending any audio samples for the RIFF header or after all samples\n// have been sent for any RIFF trailer. WavpackFlushSamples() should be called\n// between sending the last samples and calling this for trailer data to make\n// sure that headers and trailers don't get mixed up in very short files. If\n// the exact contents of the RIFF header are not known because, for example,\n// the file duration is uncertain or trailing chunks are possible, simply write\n// a \"dummy\" header of the correct length. When all data has been written it\n// will be possible to read the first block written and update the header\n// directly. An example of this can be found in the Audition filter. A\n// return of FALSE indicates an error.\n\nint WavpackAddWrapper (WavpackContext *wpc, void *data, uint32_t bcount)\n{\n    int64_t index = WavpackGetSampleIndex64 (wpc);\n    unsigned char meta_id;\n\n    if (!index || index == -1) {\n        wpc->riff_header_added = TRUE;\n        meta_id = wpc->file_format ? ID_ALT_HEADER : ID_RIFF_HEADER;\n    }\n    else {\n        wpc->riff_trailer_bytes += bcount;\n        meta_id = wpc->file_format ? ID_ALT_TRAILER : ID_RIFF_TRAILER;\n    }\n\n    return add_to_metadata (wpc, data, bcount, meta_id);\n}\n\n// Store computed MD5 sum in WavPack metadata. Note that the user must compute\n// the 16 byte sum; it is not done here. A return of FALSE indicates an error.\n// If any of the lower 8 bits of qmode are set, then this MD5 is stored with\n// a metadata ID that old decoders do not recognize (because they would not\n// interpret the qmode and would therefore fail the verification).\n\nint WavpackStoreMD5Sum (WavpackContext *wpc, unsigned char data [16])\n{\n    return add_to_metadata (wpc, data, 16, (wpc->config.qmode & 0xff) ? ID_ALT_MD5_CHECKSUM : ID_MD5_CHECKSUM);\n}\n\n#pragma pack(push,4)\n\ntypedef struct {\n    char ckID [4];\n    uint64_t chunkSize64;\n} CS64Chunk;\n\ntypedef struct {\n    uint64_t riffSize64, dataSize64, sampleCount64;\n    uint32_t tableLength;\n} DS64Chunk;\n\ntypedef struct {\n    char ckID [4];\n    uint32_t ckSize;\n    char junk [28];\n} JunkChunk;\n\n#pragma pack(pop)\n\n#define DS64ChunkFormat \"DDDL\"\n\nstatic int create_riff_header (WavpackContext *wpc, int64_t total_samples, void *outbuffer)\n{\n    int do_rf64 = 0, write_junk = 1;\n    ChunkHeader ds64hdr, datahdr, fmthdr;\n    char *outptr = outbuffer;\n    RiffChunkHeader riffhdr;\n    DS64Chunk ds64_chunk;\n    JunkChunk junkchunk;\n    WaveHeader wavhdr;\n\n    int64_t total_data_bytes, total_riff_bytes;\n    int32_t channel_mask = wpc->config.channel_mask;\n    int32_t sample_rate = wpc->config.sample_rate;\n    int bytes_per_sample = wpc->config.bytes_per_sample;\n    int bits_per_sample = wpc->config.bits_per_sample;\n    int format = (wpc->config.float_norm_exp) ? 3 : 1;\n    int num_channels = wpc->config.num_channels;\n    int wavhdrsize = 16;\n\n    wpc->riff_header_created = TRUE;\n\n    if (format == 3 && wpc->config.float_norm_exp != 127) {\n        strcpy (wpc->error_message, \"can't create valid RIFF wav header for non-normalized floating data!\");\n        return FALSE;\n    }\n\n    if (total_samples == -1)\n        total_samples = 0x7ffff000 / (bytes_per_sample * num_channels);\n\n    total_data_bytes = total_samples * bytes_per_sample * num_channels;\n\n    if (total_data_bytes > 0xff000000) {\n        write_junk = 0;\n        do_rf64 = 1;\n    }\n\n    CLEAR (wavhdr);\n\n    wavhdr.FormatTag = format;\n    wavhdr.NumChannels = num_channels;\n    wavhdr.SampleRate = sample_rate;\n    wavhdr.BytesPerSecond = sample_rate * num_channels * bytes_per_sample;\n    wavhdr.BlockAlign = bytes_per_sample * num_channels;\n    wavhdr.BitsPerSample = bits_per_sample;\n\n    if (num_channels > 2 || channel_mask != 0x5 - num_channels) {\n        wavhdrsize = sizeof (wavhdr);\n        wavhdr.cbSize = 22;\n        wavhdr.ValidBitsPerSample = bits_per_sample;\n        wavhdr.SubFormat = format;\n        wavhdr.ChannelMask = channel_mask;\n        wavhdr.FormatTag = 0xfffe;\n        wavhdr.BitsPerSample = bytes_per_sample * 8;\n        wavhdr.GUID [4] = 0x10;\n        wavhdr.GUID [6] = 0x80;\n        wavhdr.GUID [9] = 0xaa;\n        wavhdr.GUID [11] = 0x38;\n        wavhdr.GUID [12] = 0x9b;\n        wavhdr.GUID [13] = 0x71;\n    }\n\n    strncpy (riffhdr.ckID, do_rf64 ? \"RF64\" : \"RIFF\", sizeof (riffhdr.ckID));\n    strncpy (riffhdr.formType, \"WAVE\", sizeof (riffhdr.formType));\n    total_riff_bytes = sizeof (riffhdr) + wavhdrsize + sizeof (datahdr) + total_data_bytes + wpc->riff_trailer_bytes;\n    if (do_rf64) total_riff_bytes += sizeof (ds64hdr) + sizeof (ds64_chunk);\n    if (write_junk) total_riff_bytes += sizeof (junkchunk);\n    strncpy (fmthdr.ckID, \"fmt \", sizeof (fmthdr.ckID));\n    strncpy (datahdr.ckID, \"data\", sizeof (datahdr.ckID));\n    fmthdr.ckSize = wavhdrsize;\n\n    if (write_junk) {\n        CLEAR (junkchunk);\n        strncpy (junkchunk.ckID, \"junk\", sizeof (junkchunk.ckID));\n        junkchunk.ckSize = sizeof (junkchunk) - 8;\n        WavpackNativeToLittleEndian (&junkchunk, ChunkHeaderFormat);\n    }\n\n    if (do_rf64) {\n        strncpy (ds64hdr.ckID, \"ds64\", sizeof (ds64hdr.ckID));\n        ds64hdr.ckSize = sizeof (ds64_chunk);\n        CLEAR (ds64_chunk);\n        ds64_chunk.riffSize64 = total_riff_bytes;\n        ds64_chunk.dataSize64 = total_data_bytes;\n        ds64_chunk.sampleCount64 = total_samples;\n        riffhdr.ckSize = (uint32_t) -1;\n        datahdr.ckSize = (uint32_t) -1;\n        WavpackNativeToLittleEndian (&ds64hdr, ChunkHeaderFormat);\n        WavpackNativeToLittleEndian (&ds64_chunk, DS64ChunkFormat);\n    }\n    else {\n        riffhdr.ckSize = (uint32_t) total_riff_bytes;\n        datahdr.ckSize = (uint32_t) total_data_bytes;\n    }\n\n    WavpackNativeToLittleEndian (&riffhdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&fmthdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&wavhdr, WaveHeaderFormat);\n    WavpackNativeToLittleEndian (&datahdr, ChunkHeaderFormat);\n\n    // write the RIFF chunks up to just before the data starts\n\n    outptr = (char *) memcpy (outptr, &riffhdr, sizeof (riffhdr)) + sizeof (riffhdr);\n\n    if (do_rf64) {\n        outptr = (char *) memcpy (outptr, &ds64hdr, sizeof (ds64hdr)) + sizeof (ds64hdr);\n        outptr = (char *) memcpy (outptr, &ds64_chunk, sizeof (ds64_chunk)) + sizeof (ds64_chunk);\n    }\n\n    if (write_junk)\n        outptr = (char *) memcpy (outptr, &junkchunk, sizeof (junkchunk)) + sizeof (junkchunk);\n\n    outptr = (char *) memcpy (outptr, &fmthdr, sizeof (fmthdr)) + sizeof (fmthdr);\n    outptr = (char *) memcpy (outptr, &wavhdr, wavhdrsize) + wavhdrsize;\n    outptr = (char *) memcpy (outptr, &datahdr, sizeof (datahdr)) + sizeof (datahdr);\n\n    return (int)(outptr - (char *) outbuffer);\n}\n\nstatic int block_add_checksum (unsigned char *buffer_start, unsigned char *buffer_end, int bytes);\n\nstatic int pack_streams (WavpackContext *wpc, uint32_t block_samples)\n{\n    uint32_t max_blocksize, max_chans = 1, bcount;\n    unsigned char *outbuff, *outend, *out2buff, *out2end;\n    int result = TRUE, i;\n\n    // for calculating output (block) buffer size, first see if any streams are stereo\n\n    for (i = 0; i < wpc->num_streams; i++)\n        if (!(wpc->streams [i]->wphdr.flags & MONO_FLAG)) {\n            max_chans = 2;\n            break;\n        }\n\n    // then calculate maximum size based on bytes / sample\n\n    max_blocksize = block_samples * max_chans * ((wpc->streams [0]->wphdr.flags & BYTES_STORED) + 1);\n\n    // add margin based on how much \"negative\" compression is possible with pathological audio\n\n    if ((wpc->config.flags & CONFIG_FLOAT_DATA) && !(wpc->config.flags & CONFIG_SKIP_WVX))\n        max_blocksize += max_blocksize;         // 100% margin for lossless float data\n    else\n        max_blocksize += max_blocksize >> 2;    // otherwise 25% margin for everything else\n\n    max_blocksize += wpc->metabytes + 1024;     // finally, add metadata & another 1K margin\n\n    out2buff = (wpc->wvc_flag) ? malloc (max_blocksize) : NULL;\n    out2end = out2buff + max_blocksize;\n    outbuff = malloc (max_blocksize);\n    outend = outbuff + max_blocksize;\n\n    for (wpc->current_stream = 0; wpc->current_stream < wpc->num_streams; wpc->current_stream++) {\n        WavpackStream *wps = wpc->streams [wpc->current_stream];\n        uint32_t flags = wps->wphdr.flags;\n\n        flags &= ~MAG_MASK;\n        flags += (1 << MAG_LSB) * ((flags & BYTES_STORED) * 8 + 7);\n\n        SET_BLOCK_INDEX (wps->wphdr, wps->sample_index);\n        wps->wphdr.block_samples = block_samples;\n        wps->wphdr.flags = flags;\n        wps->block2buff = out2buff;\n        wps->block2end = out2end;\n        wps->blockbuff = outbuff;\n        wps->blockend = outend;\n\n#ifdef ENABLE_DSD\n        if (flags & DSD_FLAG)\n            result = pack_dsd_block (wpc, wps->sample_buffer);\n        else\n#endif\n            result = pack_block (wpc, wps->sample_buffer);\n\n        if (result) {\n            result = block_add_checksum (outbuff, outend, (flags & HYBRID_FLAG) ? 2 : 4);\n\n            if (result && out2buff)\n                result = block_add_checksum (out2buff, out2end, 2);\n        }\n\n        wps->blockbuff = wps->block2buff = NULL;\n\n        if (wps->wphdr.block_samples != block_samples)\n            block_samples = wps->wphdr.block_samples;\n\n        if (!result) {\n            strcpy (wpc->error_message, \"output buffer overflowed!\");\n            break;\n        }\n\n        bcount = ((WavpackHeader *) outbuff)->ckSize + 8;\n        WavpackNativeToLittleEndian ((WavpackHeader *) outbuff, WavpackHeaderFormat);\n        result = wpc->blockout (wpc->wv_out, outbuff, bcount);\n\n        if (!result) {\n            strcpy (wpc->error_message, \"can't write WavPack data, disk probably full!\");\n            break;\n        }\n\n        wpc->filelen += bcount;\n\n        if (out2buff) {\n            bcount = ((WavpackHeader *) out2buff)->ckSize + 8;\n            WavpackNativeToLittleEndian ((WavpackHeader *) out2buff, WavpackHeaderFormat);\n            result = wpc->blockout (wpc->wvc_out, out2buff, bcount);\n\n            if (!result) {\n                strcpy (wpc->error_message, \"can't write WavPack data, disk probably full!\");\n                break;\n            }\n\n            wpc->file2len += bcount;\n        }\n\n        if (wpc->acc_samples != block_samples)\n            memmove (wps->sample_buffer, wps->sample_buffer + block_samples * (flags & MONO_FLAG ? 1 : 2),\n                (wpc->acc_samples - block_samples) * sizeof (int32_t) * (flags & MONO_FLAG ? 1 : 2));\n    }\n\n    wpc->current_stream = 0;\n    wpc->ave_block_samples = (wpc->ave_block_samples * 0x7 + block_samples + 0x4) >> 3;\n    wpc->acc_samples -= block_samples;\n    free (outbuff);\n\n    if (out2buff)\n        free (out2buff);\n\n    return result;\n}\n\n// Given the pointer to the first block written (to either a .wv or .wvc file),\n// update the block with the actual number of samples written. If the wav\n// header was generated by the library, then it is updated also. This should\n// be done if WavpackSetConfiguration() was called with an incorrect number\n// of samples (or -1). It is the responsibility of the application to read and\n// rewrite the block. An example of this can be found in the Audition filter.\n\nstatic void block_update_checksum (unsigned char *buffer_start);\n\nvoid WavpackUpdateNumSamples (WavpackContext *wpc, void *first_block)\n{\n    uint32_t wrapper_size;\n\n    WavpackLittleEndianToNative (first_block, WavpackHeaderFormat);\n    SET_TOTAL_SAMPLES (* (WavpackHeader *) first_block, WavpackGetSampleIndex64 (wpc));\n\n    if (wpc->riff_header_created && WavpackGetWrapperLocation (first_block, &wrapper_size)) {\n        unsigned char riff_header [128];\n\n        if (wrapper_size == create_riff_header (wpc, WavpackGetSampleIndex64 (wpc), riff_header))\n            memcpy (WavpackGetWrapperLocation (first_block, NULL), riff_header, wrapper_size);\n    }\n\n    block_update_checksum (first_block);\n    WavpackNativeToLittleEndian (first_block, WavpackHeaderFormat);\n}\n\n// Note: The following function is no longer required because the wav header\n// automatically generated for the application will also be updated by\n// WavpackUpdateNumSamples (). However, if the application wants to generate\n// its own header or wants to include additional chunks, then this function\n// still must be used to update the application generated header.\n\n// Given the pointer to the first block written to a WavPack file, this\n// function returns the location of the stored RIFF header that was originally\n// written with WavpackAddWrapper(). This would normally be used to update\n// the wav header to indicate that a different number of samples was actually\n// written or if additional RIFF chunks are written at the end of the file.\n// The \"size\" parameter can be set to non-NULL to obtain the exact size of the\n// RIFF header, and the function will return FALSE if the header is not found\n// in the block's metadata (or it is not a valid WavPack block). It is the\n// responsibility of the application to read and rewrite the block. An example\n// of this can be found in the Audition filter.\n\nstatic void *find_metadata (void *wavpack_block, int desired_id, uint32_t *size);\n\nvoid *WavpackGetWrapperLocation (void *first_block, uint32_t *size)\n{\n    void *loc;\n\n    WavpackLittleEndianToNative (first_block, WavpackHeaderFormat);\n    loc = find_metadata (first_block, ID_RIFF_HEADER, size);\n\n    if (!loc)\n        loc = find_metadata (first_block, ID_ALT_HEADER, size);\n\n    WavpackNativeToLittleEndian (first_block, WavpackHeaderFormat);\n\n    return loc;\n}\n\nstatic void *find_metadata (void *wavpack_block, int desired_id, uint32_t *size)\n{\n    WavpackHeader *wphdr = wavpack_block;\n    unsigned char *dp, meta_id, c1, c2;\n    int32_t bcount, meta_bc;\n\n    if (strncmp (wphdr->ckID, \"wvpk\", 4))\n        return NULL;\n\n    bcount = wphdr->ckSize - sizeof (WavpackHeader) + 8;\n    dp = (unsigned char *)(wphdr + 1);\n\n    while (bcount >= 2) {\n        meta_id = *dp++;\n        c1 = *dp++;\n\n        meta_bc = c1 << 1;\n        bcount -= 2;\n\n        if (meta_id & ID_LARGE) {\n            if (bcount < 2)\n                break;\n\n            c1 = *dp++;\n            c2 = *dp++;\n            meta_bc += ((uint32_t) c1 << 9) + ((uint32_t) c2 << 17);\n            bcount -= 2;\n        }\n\n        if ((meta_id & ID_UNIQUE) == desired_id) {\n            if ((bcount - meta_bc) >= 0) {\n                if (size)\n                    *size = meta_bc - ((meta_id & ID_ODD_SIZE) ? 1 : 0);\n\n                return dp;\n            }\n            else\n                return NULL;\n        }\n\n        bcount -= meta_bc;\n        dp += meta_bc;\n    }\n\n    return NULL;\n}\n\nint copy_metadata (WavpackMetadata *wpmd, unsigned char *buffer_start, unsigned char *buffer_end)\n{\n    uint32_t mdsize = wpmd->byte_length + (wpmd->byte_length & 1);\n    WavpackHeader *wphdr = (WavpackHeader *) buffer_start;\n\n    mdsize += (wpmd->byte_length > 510) ? 4 : 2;\n    buffer_start += wphdr->ckSize + 8;\n\n    if (buffer_start + mdsize >= buffer_end)\n        return FALSE;\n\n    buffer_start [0] = wpmd->id | (wpmd->byte_length & 1 ? ID_ODD_SIZE : 0);\n    buffer_start [1] = (wpmd->byte_length + 1) >> 1;\n\n    if (wpmd->byte_length > 510) {\n        buffer_start [0] |= ID_LARGE;\n        buffer_start [2] = (wpmd->byte_length + 1) >> 9;\n        buffer_start [3] = (wpmd->byte_length + 1) >> 17;\n    }\n\n    if (wpmd->data && wpmd->byte_length) {\n        memcpy (buffer_start + (wpmd->byte_length > 510 ? 4 : 2), wpmd->data, wpmd->byte_length);\n\n        if (wpmd->byte_length & 1)          // if size is odd, make sure pad byte is a zero\n            buffer_start [mdsize - 1] = 0;\n    }\n\n    wphdr->ckSize += mdsize;\n    return TRUE;\n}\n\nstatic int add_to_metadata (WavpackContext *wpc, void *data, uint32_t bcount, unsigned char id)\n{\n    WavpackMetadata *mdp;\n    unsigned char *src = data;\n\n    while (bcount) {\n        if (wpc->metacount) {\n            uint32_t bc = bcount;\n\n            mdp = wpc->metadata + wpc->metacount - 1;\n\n            if (mdp->id == id) {\n                if (wpc->metabytes + bcount > 1000000)\n                    bc = 1000000 - wpc->metabytes;\n\n                mdp->data = realloc (mdp->data, mdp->byte_length + bc);\n                memcpy ((char *) mdp->data + mdp->byte_length, src, bc);\n                mdp->byte_length += bc;\n                wpc->metabytes += bc;\n                bcount -= bc;\n                src += bc;\n\n                if (wpc->metabytes >= 1000000 && !write_metadata_block (wpc))\n                    return FALSE;\n            }\n        }\n\n        if (bcount) {\n            wpc->metadata = realloc (wpc->metadata, (wpc->metacount + 1) * sizeof (WavpackMetadata));\n            mdp = wpc->metadata + wpc->metacount++;\n            mdp->byte_length = 0;\n            mdp->data = NULL;\n            mdp->id = id;\n        }\n    }\n\n    return TRUE;\n}\n\nstatic char *write_metadata (WavpackMetadata *wpmd, char *outdata)\n{\n    unsigned char id = wpmd->id, wordlen [3];\n\n    wordlen [0] = (wpmd->byte_length + 1) >> 1;\n    wordlen [1] = (wpmd->byte_length + 1) >> 9;\n    wordlen [2] = (wpmd->byte_length + 1) >> 17;\n\n    if (wpmd->byte_length & 1)\n        id |= ID_ODD_SIZE;\n\n    if (wordlen [1] || wordlen [2])\n        id |= ID_LARGE;\n\n    *outdata++ = id;\n    *outdata++ = wordlen [0];\n\n    if (id & ID_LARGE) {\n        *outdata++ = wordlen [1];\n        *outdata++ = wordlen [2];\n    }\n\n    if (wpmd->data && wpmd->byte_length) {\n        memcpy (outdata, wpmd->data, wpmd->byte_length);\n        outdata += wpmd->byte_length;\n\n        if (wpmd->byte_length & 1)\n            *outdata++ = 0;\n    }\n\n    return outdata;\n}\n\nstatic int write_metadata_block (WavpackContext *wpc)\n{\n    char *block_buff, *block_ptr;\n    WavpackHeader *wphdr;\n\n    if (wpc->metacount) {\n        int metacount = wpc->metacount, block_size = sizeof (WavpackHeader);\n        WavpackMetadata *wpmdp = wpc->metadata;\n\n        while (metacount--) {\n            block_size += wpmdp->byte_length + (wpmdp->byte_length & 1);\n            block_size += (wpmdp->byte_length > 510) ? 4 : 2;\n            wpmdp++;\n        }\n\n        // allocate 6 extra bytes for 4-byte checksum (which we add last)\n        wphdr = (WavpackHeader *) (block_buff = malloc (block_size + 6));\n\n        CLEAR (*wphdr);\n        memcpy (wphdr->ckID, \"wvpk\", 4);\n        SET_TOTAL_SAMPLES (*wphdr, wpc->total_samples);\n        wphdr->version = wpc->stream_version;\n        wphdr->ckSize = block_size - 8;\n        wphdr->block_samples = 0;\n\n        block_ptr = (char *)(wphdr + 1);\n\n        wpmdp = wpc->metadata;\n\n        while (wpc->metacount) {\n            block_ptr = write_metadata (wpmdp, block_ptr);\n            wpc->metabytes -= wpmdp->byte_length;\n            free_metadata (wpmdp++);\n            wpc->metacount--;\n        }\n\n        free (wpc->metadata);\n        wpc->metadata = NULL;\n        // add a 4-byte checksum here (increases block size by 6)\n        block_add_checksum ((unsigned char *) block_buff, (unsigned char *) block_buff + (block_size += 6), 4);\n        WavpackNativeToLittleEndian ((WavpackHeader *) block_buff, WavpackHeaderFormat);\n\n        if (!wpc->blockout (wpc->wv_out, block_buff, block_size)) {\n            free (block_buff);\n            strcpy (wpc->error_message, \"can't write WavPack data, disk probably full!\");\n            return FALSE;\n        }\n\n        free (block_buff);\n    }\n\n    return TRUE;\n}\n\nvoid free_metadata (WavpackMetadata *wpmd)\n{\n    if (wpmd->data) {\n        free (wpmd->data);\n        wpmd->data = NULL;\n    }\n}\n\n// These two functions add or update the block checksums that were introduced in WavPack 5.0.\n// The presence of the checksum is indicated by a flag in the wavpack header (HAS_CHECKSUM)\n// and the actual metadata item should be the last one in the block, and can be either 2 or 4\n// bytes. Of course, older versions of the decoder will simply ignore both of these.\n\nstatic int block_add_checksum (unsigned char *buffer_start, unsigned char *buffer_end, int bytes)\n{\n    WavpackHeader *wphdr = (WavpackHeader *) buffer_start;\n#ifdef BITSTREAM_SHORTS\n    uint16_t *csptr = (uint16_t*) buffer_start;\n#else\n    unsigned char *csptr = buffer_start;\n#endif\n    int bcount = wphdr->ckSize + 8, wcount;\n    uint32_t csum = (uint32_t) -1;\n\n    if (bytes != 2 && bytes != 4)\n        return FALSE;\n\n    if (bcount < sizeof (WavpackHeader) || (bcount & 1) || buffer_start + bcount + 2 + bytes > buffer_end)\n        return FALSE;\n\n    wphdr->flags |= HAS_CHECKSUM;\n    wphdr->ckSize += 2 + bytes;\n    wcount = bcount >> 1;\n\n#ifdef BITSTREAM_SHORTS\n    while (wcount--)\n        csum = (csum * 3) + *csptr++;\n#else\n    WavpackNativeToLittleEndian ((WavpackHeader *) buffer_start, WavpackHeaderFormat);\n\n    while (wcount--) {\n        csum = (csum * 3) + csptr [0] + (csptr [1] << 8);\n        csptr += 2;\n    }\n\n    WavpackLittleEndianToNative ((WavpackHeader *) buffer_start, WavpackHeaderFormat);\n#endif\n\n    buffer_start += bcount;\n    *buffer_start++ = ID_BLOCK_CHECKSUM;\n    *buffer_start++ = bytes >> 1;\n\n    if (bytes == 4) {\n        *buffer_start++ = csum;\n        *buffer_start++ = csum >> 8;\n        *buffer_start++ = csum >> 16;\n        *buffer_start++ = csum >> 24;\n    }\n    else {\n        csum ^= csum >> 16;\n        *buffer_start++ = csum;\n        *buffer_start++ = csum >> 8;\n    }\n\n    return TRUE;\n}\n\nstatic void block_update_checksum (unsigned char *buffer_start)\n{\n    WavpackHeader *wphdr = (WavpackHeader *) buffer_start;\n    unsigned char *dp, meta_id, c1, c2;\n    uint32_t bcount, meta_bc;\n\n    if (!(wphdr->flags & HAS_CHECKSUM))\n        return;\n\n    bcount = wphdr->ckSize - sizeof (WavpackHeader) + 8;\n    dp = (unsigned char *)(wphdr + 1);\n\n    while (bcount >= 2) {\n        meta_id = *dp++;\n        c1 = *dp++;\n\n        meta_bc = c1 << 1;\n        bcount -= 2;\n\n        if (meta_id & ID_LARGE) {\n            if (bcount < 2)\n                return;\n\n            c1 = *dp++;\n            c2 = *dp++;\n            meta_bc += ((uint32_t) c1 << 9) + ((uint32_t) c2 << 17);\n            bcount -= 2;\n        }\n\n        if (bcount < meta_bc)\n            return;\n\n        if ((meta_id & ID_UNIQUE) == ID_BLOCK_CHECKSUM) {\n#ifdef BITSTREAM_SHORTS\n            uint16_t *csptr = (uint16_t*) buffer_start;\n#else\n            unsigned char *csptr = buffer_start;\n#endif\n            int wcount = (int)(dp - 2 - buffer_start) >> 1;\n            uint32_t csum = (uint32_t) -1;\n\n            if ((meta_id & ID_ODD_SIZE) || meta_bc < 2 || meta_bc > 4)\n                return;\n\n#ifdef BITSTREAM_SHORTS\n            while (wcount--)\n                csum = (csum * 3) + *csptr++;\n#else\n            WavpackNativeToLittleEndian ((WavpackHeader *) buffer_start, WavpackHeaderFormat);\n\n            while (wcount--) {\n                csum = (csum * 3) + csptr [0] + (csptr [1] << 8);\n                csptr += 2;\n            }\n\n            WavpackLittleEndianToNative ((WavpackHeader *) buffer_start, WavpackHeaderFormat);\n#endif\n\n            if (meta_bc == 4) {\n                *dp++ = csum;\n                *dp++ = csum >> 8;\n                *dp++ = csum >> 16;\n                *dp++ = csum >> 24;\n                return;\n            }\n            else {\n                csum ^= csum >> 16;\n                *dp++ = csum;\n                *dp++ = csum >> 8;\n                return;\n            }\n        }\n\n        bcount -= meta_bc;\n        dp += meta_bc;\n    }\n}\n"], "fixing_code": ["////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//              Copyright (c) 1998 - 2013 Conifer Software.               //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// pack_utils.c\n\n// This module provides the high-level API for creating WavPack files from\n// audio data. It manages the buffers used to deinterleave the data passed\n// in from the application into the individual streams and it handles the\n// generation of riff headers and the \"fixup\" on the first WavPack block\n// header for the case where the number of samples was unknown (or wrong).\n// The actual audio stream compression is handled in the pack.c module.\n\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#include \"wavpack_local.h\"\n\n///////////////////////////// executable code ////////////////////////////////\n\n// Open context for writing WavPack files. The returned context pointer is used\n// in all following calls to the library. The \"blockout\" function will be used\n// to store the actual completed WavPack blocks and will be called with the id\n// pointers containing user defined data (one for the wv file and one for the\n// wvc file). A return value of NULL indicates that memory could not be\n// allocated for the context.\n\nWavpackContext *WavpackOpenFileOutput (WavpackBlockOutput blockout, void *wv_id, void *wvc_id)\n{\n    WavpackContext *wpc = malloc (sizeof (WavpackContext));\n\n    if (!wpc)\n        return NULL;\n\n    CLEAR (*wpc);\n    wpc->total_samples = -1;\n    wpc->stream_version = CUR_STREAM_VERS;\n    wpc->blockout = blockout;\n    wpc->wv_out = wv_id;\n    wpc->wvc_out = wvc_id;\n    return wpc;\n}\n\nstatic int add_to_metadata (WavpackContext *wpc, void *data, uint32_t bcount, unsigned char id);\n\n// New for version 5.0, this function allows the application to store a file extension and a\n// file_format identification. The extension would be used by the unpacker if the user had not\n// specified the target filename, and specifically handles the case where the original file\n// had the \"wrong\" extension for the file format (e.g., a Wave64 file having a \"wav\" extension)\n// or an alternative (e.g., \"bwf\") or where the file format is not known. Specifying a file\n// format besides the default WP_FORMAT_WAV will ensure that old decoders will not be able to\n// see the non-wav wrapper provided with WavpackAddWrapper() (which they would end up putting\n// on a file with a .wav extension).\n\nvoid WavpackSetFileInformation (WavpackContext *wpc, char *file_extension, unsigned char file_format)\n{\n    if (file_extension && strlen (file_extension) < sizeof (wpc->file_extension)) {\n        add_to_metadata (wpc, file_extension, (uint32_t) strlen (file_extension), ID_ALT_EXTENSION);\n        strcpy (wpc->file_extension, file_extension);\n    }\n\n    wpc->file_format = file_format;\n}\n\n// Set configuration for writing WavPack files. This must be done before\n// sending any actual samples, however it is okay to send wrapper or other\n// metadata before calling this. The \"config\" structure contains the following\n// required information:\n\n// config->bytes_per_sample     see WavpackGetBytesPerSample() for info\n// config->bits_per_sample      see WavpackGetBitsPerSample() for info\n// config->channel_mask         Microsoft standard (mono = 4, stereo = 3)\n// config->num_channels         self evident\n// config->sample_rate          self evident\n\n// In addition, the following fields and flags may be set:\n\n// config->flags:\n// --------------\n// o CONFIG_HYBRID_FLAG         select hybrid mode (must set bitrate)\n// o CONFIG_JOINT_STEREO        select joint stereo (must set override also)\n// o CONFIG_JOINT_OVERRIDE      override default joint stereo selection\n// o CONFIG_HYBRID_SHAPE        select hybrid noise shaping (set override &\n//                                                      shaping_weight != 0.0)\n// o CONFIG_SHAPE_OVERRIDE      override default hybrid noise shaping\n//                               (set CONFIG_HYBRID_SHAPE and shaping_weight)\n// o CONFIG_FAST_FLAG           \"fast\" compression mode\n// o CONFIG_HIGH_FLAG           \"high\" compression mode\n// o CONFIG_BITRATE_KBPS        hybrid bitrate is kbps, not bits / sample\n// o CONFIG_CREATE_WVC          create correction file\n// o CONFIG_OPTIMIZE_WVC        maximize bybrid compression (-cc option)\n// o CONFIG_CALC_NOISE          calc noise in hybrid mode\n// o CONFIG_EXTRA_MODE          extra processing mode (slow!)\n// o CONFIG_SKIP_WVX            no wvx stream for floats & large ints\n// o CONFIG_MD5_CHECKSUM        specify if you plan to store MD5 signature\n// o CONFIG_CREATE_EXE          specify if you plan to prepend sfx module\n// o CONFIG_OPTIMIZE_MONO       detect and optimize for mono files posing as\n//                               stereo (uses a more recent stream format that\n//                               is not compatible with decoders < 4.3)\n\n// config->bitrate              hybrid bitrate in either bits/sample or kbps\n// config->shaping_weight       hybrid noise shaping coefficient override\n// config->block_samples        force samples per WavPack block (0 = use deflt)\n// config->float_norm_exp       select floating-point data (127 for +/-1.0)\n// config->xmode                extra mode processing value override\n\n// If the number of samples to be written is known then it should be passed\n// here. If the duration is not known then pass -1. In the case that the size\n// is not known (or the writing is terminated early) then it is suggested that\n// the application retrieve the first block written and let the library update\n// the total samples indication. A function is provided to do this update and\n// it should be done to the \"correction\" file also. If this cannot be done\n// (because a pipe is being used, for instance) then a valid WavPack will still\n// be created, but when applications want to access that file they will have\n// to seek all the way to the end to determine the actual duration. Also, if\n// a RIFF header has been included then it should be updated as well or the\n// WavPack file will not be directly unpackable to a valid wav file (although\n// it will still be usable by itself). A return of FALSE indicates an error.\n//\n// The enhanced version of this function now allows setting the identities of\n// any channels that are NOT standard Microsoft channels and are therefore not\n// represented in the channel mask. WavPack files require that all the Microsoft\n// channels come first (and in Microsoft order) and these are followed by any\n// other channels (which can be in any order).\n//\n// The identities are provided in a NULL-terminated string (0x00 is not an allowed\n// channel ID). The Microsoft channels may be provided as well (and will be checked)\n// but it is really only necessary to provide the \"unknown\" channels. Any truly\n// unknown channels are indicated with a 0xFF.\n//\n// The channel IDs so far reserved are listed here:\n//\n// 0:           not allowed / terminator\n// 1 - 18:      Microsoft standard channels\n// 30, 31:      Stereo mix from RF64 (not really recommended, but RF64 specifies this)\n// 33 - 44:     Core Audio channels (see Core Audio specification)\n// 127 - 128:   Amio LeftHeight, Amio RightHeight\n// 138 - 142:   Amio BottomFrontLeft/Center/Right, Amio ProximityLeft/Right\n// 200 - 207:   Core Audio channels (see Core Audio specification)\n// 221 - 224:   Core Audio channels 301 - 305 (offset by 80)\n// 255:         Present but unknown or unused channel\n//\n// All other channel IDs are reserved. Ask if something you need is missing.\n\n// Table of channels that will automatically \"pair\" into a single stereo stream\n\nstatic const struct { unsigned char a, b; } stereo_pairs [] = {\n    { 1, 2 },       // FL, FR\n    { 5, 6 },       // BL, BR\n    { 7, 8 },       // FLC, FRC\n    { 10, 11 },     // SL, SR\n    { 13, 15 },     // TFL, TFR\n    { 16, 18 },     // TBL, TBR\n    { 30, 31 },     // stereo mix L,R (RF64)\n    { 33, 34 },     // Rls, Rrs\n    { 35, 36 },     // Lw, Rw\n    { 38, 39 },     // Lt, Rt\n    { 127, 128 },   // Lh, Rh\n    { 138, 140 },   // Bfl, Bfr\n    { 141, 142 },   // Pl, Pr\n    { 200, 201 },   // Amb_W, Amb_X\n    { 202, 203 },   // Amb_Y, Amb_Z\n    { 204, 205 },   // MS_Mid, MS_Side\n    { 206, 207 },   // XY_X, XY_Y\n    { 221, 222 },   // Hph_L, Hph_R\n};\n\n#define NUM_STEREO_PAIRS (sizeof (stereo_pairs) / sizeof (stereo_pairs [0]))\n\n// Legacy version of this function for compatibility with existing applications. Note that this version\n// also generates older streams to be compatible with all decoders back to 4.0, but of course cannot be\n// used with > 2^32 samples or non-Microsoft channels. The older stream version only differs in that it\n// does not support the \"mono optimization\" feature where stereo blocks containing identical audio data\n// in both channels are encoded in mono for better efficiency.\n\nint WavpackSetConfiguration (WavpackContext *wpc, WavpackConfig *config, uint32_t total_samples)\n{\n    config->flags |= CONFIG_COMPATIBLE_WRITE;       // write earlier version streams\n\n    if (total_samples == (uint32_t) -1)\n        return WavpackSetConfiguration64 (wpc, config, -1, NULL);\n    else\n        return WavpackSetConfiguration64 (wpc, config, total_samples, NULL);\n}\n\nint WavpackSetConfiguration64 (WavpackContext *wpc, WavpackConfig *config, int64_t total_samples, const unsigned char *chan_ids)\n{\n    uint32_t flags, bps = 0;\n    uint32_t chan_mask = config->channel_mask;\n    int num_chans = config->num_channels;\n    int i;\n\n    if (!config->sample_rate) {\n        strcpy (wpc->error_message, \"sample rate cannot be zero!\");\n        return FALSE;\n    }\n\n    wpc->stream_version = (config->flags & CONFIG_COMPATIBLE_WRITE) ? CUR_STREAM_VERS : MAX_STREAM_VERS;\n\n    if ((config->qmode & QMODE_DSD_AUDIO) && config->bytes_per_sample == 1 && config->bits_per_sample == 8) {\n#ifdef ENABLE_DSD\n        wpc->dsd_multiplier = 1;\n        flags = DSD_FLAG;\n\n        for (i = 14; i >= 0; --i)\n            if (config->sample_rate % sample_rates [i] == 0) {\n                int divisor = config->sample_rate / sample_rates [i];\n\n                if (divisor && (divisor & (divisor - 1)) == 0) {\n                    config->sample_rate /= divisor;\n                    wpc->dsd_multiplier = divisor;\n                    break;\n                }\n            }\n\n        // most options that don't apply to DSD we can simply ignore for now, but NOT hybrid mode!\n        if (config->flags & CONFIG_HYBRID_FLAG) {\n            strcpy (wpc->error_message, \"hybrid mode not available for DSD!\");\n            return FALSE;\n        }\n\n        // with DSD, very few PCM options work (or make sense), so only allow those that do\n        config->flags &= (CONFIG_HIGH_FLAG | CONFIG_MD5_CHECKSUM | CONFIG_PAIR_UNDEF_CHANS);\n        config->float_norm_exp = config->xmode = 0;\n#else\n        strcpy (wpc->error_message, \"libwavpack not configured for DSD!\");\n        return FALSE;\n#endif\n    }\n    else\n        flags = config->bytes_per_sample - 1;\n\n    wpc->total_samples = total_samples;\n    wpc->config.sample_rate = config->sample_rate;\n    wpc->config.num_channels = config->num_channels;\n    wpc->config.channel_mask = config->channel_mask;\n    wpc->config.bits_per_sample = config->bits_per_sample;\n    wpc->config.bytes_per_sample = config->bytes_per_sample;\n    wpc->config.block_samples = config->block_samples;\n    wpc->config.flags = config->flags;\n    wpc->config.qmode = config->qmode;\n\n    if (config->flags & CONFIG_VERY_HIGH_FLAG)\n        wpc->config.flags |= CONFIG_HIGH_FLAG;\n\n    for (i = 0; i < 15; ++i)\n        if (wpc->config.sample_rate == sample_rates [i])\n            break;\n\n    flags |= i << SRATE_LSB;\n\n    // all of this stuff only applies to PCM\n\n    if (!(flags & DSD_FLAG)) {\n        if (config->float_norm_exp) {\n            wpc->config.float_norm_exp = config->float_norm_exp;\n            wpc->config.flags |= CONFIG_FLOAT_DATA;\n            flags |= FLOAT_DATA;\n        }\n        else\n            flags |= ((config->bytes_per_sample * 8) - config->bits_per_sample) << SHIFT_LSB;\n\n        if (config->flags & CONFIG_HYBRID_FLAG) {\n            flags |= HYBRID_FLAG | HYBRID_BITRATE | HYBRID_BALANCE;\n\n            if (!(wpc->config.flags & CONFIG_SHAPE_OVERRIDE)) {\n                wpc->config.flags |= CONFIG_HYBRID_SHAPE | CONFIG_AUTO_SHAPING;\n                flags |= HYBRID_SHAPE | NEW_SHAPING;\n            }\n            else if (wpc->config.flags & CONFIG_HYBRID_SHAPE) {\n                wpc->config.shaping_weight = config->shaping_weight;\n                flags |= HYBRID_SHAPE | NEW_SHAPING;\n            }\n\n            if (wpc->config.flags & (CONFIG_CROSS_DECORR | CONFIG_OPTIMIZE_WVC))\n                flags |= CROSS_DECORR;\n\n            if (config->flags & CONFIG_BITRATE_KBPS) {\n                bps = (uint32_t) floor (config->bitrate * 256000.0 / config->sample_rate / config->num_channels + 0.5);\n\n                if (bps > (64 << 8))\n                    bps = 64 << 8;\n            }\n            else\n                bps = (uint32_t) floor (config->bitrate * 256.0 + 0.5);\n        }\n        else\n            flags |= CROSS_DECORR;\n\n        if (!(config->flags & CONFIG_JOINT_OVERRIDE) || (config->flags & CONFIG_JOINT_STEREO))\n            flags |= JOINT_STEREO;\n\n        if (config->flags & CONFIG_CREATE_WVC)\n            wpc->wvc_flag = TRUE;\n    }\n\n    // if a channel-identities string was specified, process that here, otherwise all channels\n    // not present in the channel mask are considered \"unassigned\"\n\n    if (chan_ids) {\n        int lastchan = 0, mask_copy = chan_mask;\n\n        if ((int) strlen ((char *) chan_ids) > num_chans) {          // can't be more than num channels!\n            strcpy (wpc->error_message, \"chan_ids longer than num channels!\");\n            return FALSE;\n        }\n\n        // skip past channels that are specified in the channel mask (no reason to store those)\n\n        while (*chan_ids)\n            if (*chan_ids <= 32 && *chan_ids > lastchan && (mask_copy & (1 << (*chan_ids-1)))) {\n                mask_copy &= ~(1 << (*chan_ids-1));\n                lastchan = *chan_ids++;\n            }\n            else\n                break;\n\n        // now scan the string for an actually defined channel (and don't store if there aren't any)\n\n        for (i = 0; chan_ids [i]; i++)\n            if (chan_ids [i] != 0xff) {\n                wpc->channel_identities = (unsigned char *) strdup ((char *) chan_ids);\n                break;\n            }\n    }\n\n    // This loop goes through all the channels and creates the Wavpack \"streams\" for them to go in.\n    // A stream can hold either one or two channels, so we have several rules to determine how many\n    // channels will go in each stream.\n\n    for (wpc->current_stream = 0; num_chans; wpc->current_stream++) {\n        WavpackStream *wps = malloc (sizeof (WavpackStream));\n        unsigned char left_chan_id = 0, right_chan_id = 0;\n        int pos, chans = 1;\n\n        // allocate the stream and initialize the pointer to it\n        wpc->streams = realloc (wpc->streams, (wpc->current_stream + 1) * sizeof (wpc->streams [0]));\n        wpc->streams [wpc->current_stream] = wps;\n        CLEAR (*wps);\n\n        // if there are any bits [still] set in the channel_mask, get the next one or two IDs from there\n        if (chan_mask)\n            for (pos = 0; pos < 32; ++pos)\n                if (chan_mask & (1 << pos)) {\n                    if (left_chan_id) {\n                        right_chan_id = pos + 1;\n                        break;\n                    }\n                    else {\n                        chan_mask &= ~(1 << pos);\n                        left_chan_id = pos + 1;\n                    }\n                }\n\n        // next check for any channels identified in the channel-identities string\n        while (!right_chan_id && chan_ids && *chan_ids)\n            if (left_chan_id)\n                right_chan_id = *chan_ids;\n            else\n                left_chan_id = *chan_ids++;\n\n        // assume anything we did not get is \"unassigned\"\n        if (!left_chan_id)\n            left_chan_id = right_chan_id = 0xff;\n        else if (!right_chan_id)\n            right_chan_id = 0xff;\n\n        // if we have 2 channels, this is where we decide if we can combine them into one stream:\n        // 1. they are \"unassigned\" and we've been told to combine unassigned pairs, or\n        // 2. they appear together in the valid \"pairings\" list\n        if (num_chans >= 2) {\n            if ((config->flags & CONFIG_PAIR_UNDEF_CHANS) && left_chan_id == 0xff && right_chan_id == 0xff)\n                chans = 2;\n            else\n                for (i = 0; i < NUM_STEREO_PAIRS; ++i)\n                    if ((left_chan_id == stereo_pairs [i].a && right_chan_id == stereo_pairs [i].b) ||\n                        (left_chan_id == stereo_pairs [i].b && right_chan_id == stereo_pairs [i].a)) {\n                            if (right_chan_id <= 32 && (chan_mask & (1 << (right_chan_id-1))))\n                                chan_mask &= ~(1 << (right_chan_id-1));\n                            else if (chan_ids && *chan_ids == right_chan_id)\n                                chan_ids++;\n\n                            chans = 2;\n                            break;\n                        }\n        }\n\n        num_chans -= chans;\n\n        if (num_chans && wpc->current_stream == NEW_MAX_STREAMS - 1)\n            break;\n\n        memcpy (wps->wphdr.ckID, \"wvpk\", 4);\n        wps->wphdr.ckSize = sizeof (WavpackHeader) - 8;\n        SET_TOTAL_SAMPLES (wps->wphdr, wpc->total_samples);\n        wps->wphdr.version = wpc->stream_version;\n        wps->wphdr.flags = flags;\n        wps->bits = bps;\n\n        if (!wpc->current_stream)\n            wps->wphdr.flags |= INITIAL_BLOCK;\n\n        if (!num_chans)\n            wps->wphdr.flags |= FINAL_BLOCK;\n\n        if (chans == 1) {\n            wps->wphdr.flags &= ~(JOINT_STEREO | CROSS_DECORR | HYBRID_BALANCE);\n            wps->wphdr.flags |= MONO_FLAG;\n        }\n    }\n\n    wpc->num_streams = wpc->current_stream;\n    wpc->current_stream = 0;\n\n    if (num_chans) {\n        strcpy (wpc->error_message, \"too many channels!\");\n        return FALSE;\n    }\n\n    if (config->flags & CONFIG_EXTRA_MODE)\n        wpc->config.xmode = config->xmode ? config->xmode : 1;\n\n    return TRUE;\n}\n\n// This function allows setting the Core Audio File channel layout, many of which do not\n// conform to the Microsoft ordering standard that Wavpack requires internally (at least for\n// those channels present in the \"channel mask\"). In addition to the layout tag, this function\n// allows a reordering string to be stored in the file to allow the unpacker to reorder the\n// channels back to the specified layout (if it is aware of this feature and wants to restore\n// the CAF order). The number of channels in the layout is specified in the lower nybble of\n// the layout word, and if a reorder string is specified it must be that long. Note that all\n// the reordering is actually done outside of this library, and that if reordering is done\n// then the appropriate qmode bit must be set to ensure that any MD5 sum is stored with a new\n// ID so that old decoders don't try to verify it (and to let the decoder know that a reorder\n// might be required).\n//\n// Note: This function should only be used to encode Core Audio files in such a way that a\n// verbatim archive can be created. Applications can just include the chan_ids parameter in\n// the call to WavpackSetConfiguration64() if there are non-Microsoft channels to specify,\n// or do nothing special if only Microsoft channels are present (the vast majority of cases).\n\nint WavpackSetChannelLayout (WavpackContext *wpc, uint32_t layout_tag, const unsigned char *reorder)\n{\n    int nchans = layout_tag & 0xff;\n\n    if ((layout_tag & 0xff00ff00) || nchans > wpc->config.num_channels)\n        return FALSE;\n\n    wpc->channel_layout = layout_tag;\n\n    if (wpc->channel_reordering) {\n        free (wpc->channel_reordering);\n        wpc->channel_reordering = NULL;\n    }\n\n    if (nchans && reorder) {\n        int min_index = 256, i;\n\n        for (i = 0; i < nchans; ++i)\n            if (reorder [i] < min_index)\n                min_index = reorder [i];\n\n        wpc->channel_reordering = malloc (nchans);\n\n        if (wpc->channel_reordering)\n            for (i = 0; i < nchans; ++i)\n                wpc->channel_reordering [i] = reorder [i] - min_index;\n    }\n\n    return TRUE;\n}\n\n// Prepare to actually pack samples by determining the size of the WavPack\n// blocks and allocating sample buffers and initializing each stream. Call\n// after WavpackSetConfiguration() and before WavpackPackSamples(). A return\n// of FALSE indicates an error.\n\nstatic int write_metadata_block (WavpackContext *wpc);\n\nint WavpackPackInit (WavpackContext *wpc)\n{\n    if (wpc->metabytes > 16384)             // 16384 bytes still leaves plenty of room for audio\n        write_metadata_block (wpc);         //  in this block (otherwise write a special one)\n\n    // The default block size is a compromise. Longer blocks provide better encoding efficiency,\n    // but longer blocks adversely affect memory requirements and seeking performance. For WavPack\n    // version 5.0, the default block sizes have been reduced by half from the previous version,\n    // but the difference in encoding efficiency will generally be less than 0.1 percent.\n\n    if (wpc->dsd_multiplier) {\n        wpc->block_samples = (wpc->config.sample_rate % 7) ? 48000 : 44100;\n\n        if (wpc->config.flags & CONFIG_HIGH_FLAG)\n            wpc->block_samples /= 2;\n\n        if (wpc->config.num_channels == 1)\n            wpc->block_samples *= 2;\n\n        while (wpc->block_samples > 12000 && wpc->block_samples * wpc->config.num_channels > 300000)\n            wpc->block_samples /= 2;\n    }\n    else {\n        int divisor = (wpc->config.flags & CONFIG_HIGH_FLAG) ? 2 : 4;\n\n        while (wpc->config.sample_rate % divisor)\n            divisor--;\n\n        wpc->block_samples = wpc->config.sample_rate / divisor;\n\n        while (wpc->block_samples > 12000 && wpc->block_samples * wpc->config.num_channels > 75000)\n            wpc->block_samples /= 2;\n\n        while (wpc->block_samples * wpc->config.num_channels < 20000)\n            wpc->block_samples *= 2;\n    }\n\n    if (wpc->config.block_samples) {\n        if ((wpc->config.flags & CONFIG_MERGE_BLOCKS) &&\n            wpc->block_samples > (uint32_t) wpc->config.block_samples) {\n                wpc->block_boundary = wpc->config.block_samples;\n                wpc->block_samples /= wpc->config.block_samples;\n                wpc->block_samples *= wpc->config.block_samples;\n        }\n        else\n            wpc->block_samples = wpc->config.block_samples;\n    }\n\n    wpc->ave_block_samples = wpc->block_samples;\n    wpc->max_samples = wpc->block_samples + (wpc->block_samples >> 1);\n\n    for (wpc->current_stream = 0; wpc->current_stream < wpc->num_streams; wpc->current_stream++) {\n        WavpackStream *wps = wpc->streams [wpc->current_stream];\n\n        wps->sample_buffer = malloc (wpc->max_samples * (wps->wphdr.flags & MONO_FLAG ? 4 : 8));\n\n#ifdef ENABLE_DSD\n        if (wps->wphdr.flags & DSD_FLAG)\n            pack_dsd_init (wpc);\n        else\n#endif\n            pack_init (wpc);\n    }\n\n    return TRUE;\n}\n\n// Pack the specified samples. Samples must be stored in longs in the native\n// endian format of the executing processor. The number of samples specified\n// indicates composite samples (sometimes called \"frames\"). So, the actual\n// number of data points would be this \"sample_count\" times the number of\n// channels. Note that samples are accumulated here until enough exist to\n// create a complete WavPack block (or several blocks for multichannel audio).\n// If an application wants to break a block at a specific sample, then it must\n// simply call WavpackFlushSamples() to force an early termination. Completed\n// WavPack blocks are send to the function provided in the initial call to\n// WavpackOpenFileOutput(). A return of FALSE indicates an error.\n\nstatic int pack_streams (WavpackContext *wpc, uint32_t block_samples);\nstatic int create_riff_header (WavpackContext *wpc, int64_t total_samples, void *outbuffer);\n\nint WavpackPackSamples (WavpackContext *wpc, int32_t *sample_buffer, uint32_t sample_count)\n{\n    int nch = wpc->config.num_channels;\n\n    while (sample_count) {\n        int32_t *source_pointer = sample_buffer;\n        unsigned int samples_to_copy;\n\n        if (!wpc->riff_header_added && !wpc->riff_header_created && !wpc->file_format) {\n            char riff_header [128];\n\n            if (!add_to_metadata (wpc, riff_header, create_riff_header (wpc, wpc->total_samples, riff_header), ID_RIFF_HEADER))\n                return FALSE;\n        }\n\n        if (wpc->acc_samples + sample_count > wpc->max_samples)\n            samples_to_copy = wpc->max_samples - wpc->acc_samples;\n        else\n            samples_to_copy = sample_count;\n\n        for (wpc->current_stream = 0; wpc->current_stream < wpc->num_streams; wpc->current_stream++) {\n            WavpackStream *wps = wpc->streams [wpc->current_stream];\n            int32_t *dptr, *sptr, cnt;\n\n            dptr = wps->sample_buffer + wpc->acc_samples * (wps->wphdr.flags & MONO_FLAG ? 1 : 2);\n            sptr = source_pointer;\n            cnt = samples_to_copy;\n\n            // This code used to just copy the 32-bit samples regardless of the actual size with the\n            // assumption that the caller had properly sign-extended the values (if they were smaller\n            // than 32 bits). However, several people have discovered that if the data isn't properly\n            // sign extended then ugly things happen (e.g. CRC errors that show up only on decode).\n            // To prevent this, we now explicitly sign-extend samples smaller than 32-bit when we\n            // copy, and the performance hit from doing this is very small (generally < 1%).\n\n            if (wps->wphdr.flags & MONO_FLAG) {\n                switch (wpc->config.bytes_per_sample) {\n                    case 1:\n                        while (cnt--) {\n                            *dptr++ = (signed char) *sptr;\n                            sptr += nch;\n                        }\n\n                        break;\n\n                    case 2:\n                        while (cnt--) {\n                            *dptr++ = (int16_t) *sptr;\n                            sptr += nch;\n                        }\n\n                        break;\n\n                    case 3:\n                        while (cnt--) {\n                            *dptr++ = (*sptr << 8) >> 8;\n                            sptr += nch;\n                        }\n\n                        break;\n\n                    default:\n                        while (cnt--) {\n                            *dptr++ = *sptr;\n                            sptr += nch;\n                        }\n                }\n\n                source_pointer++;\n            }\n            else {\n                switch (wpc->config.bytes_per_sample) {\n                    case 1:\n                        while (cnt--) {\n                            *dptr++ = (signed char) sptr [0];\n                            *dptr++ = (signed char) sptr [1];\n                            sptr += nch;\n                        }\n\n                        break;\n\n                    case 2:\n                        while (cnt--) {\n                            *dptr++ = (int16_t) sptr [0];\n                            *dptr++ = (int16_t) sptr [1];\n                            sptr += nch;\n                        }\n\n                        break;\n\n                    case 3:\n                        while (cnt--) {\n                            *dptr++ = (sptr [0] << 8) >> 8;\n                            *dptr++ = (sptr [1] << 8) >> 8;\n                            sptr += nch;\n                        }\n\n                        break;\n\n                    default:\n                        while (cnt--) {\n                            *dptr++ = sptr [0];\n                            *dptr++ = sptr [1];\n                            sptr += nch;\n                        }\n                }\n\n                source_pointer += 2;\n            }\n        }\n\n        sample_buffer += samples_to_copy * nch;\n        sample_count -= samples_to_copy;\n\n        if ((wpc->acc_samples += samples_to_copy) == wpc->max_samples &&\n            !pack_streams (wpc, wpc->block_samples))\n                return FALSE;\n    }\n\n    return TRUE;\n}\n\n// Flush all accumulated samples into WavPack blocks. This is normally called\n// after all samples have been sent to WavpackPackSamples(), but can also be\n// called to terminate a WavPack block at a specific sample (in other words it\n// is possible to continue after this operation). This is also called to\n// dump non-audio blocks like those holding metadata for various purposes.\n// A return of FALSE indicates an error.\n\nint WavpackFlushSamples (WavpackContext *wpc)\n{\n    while (wpc->acc_samples) {\n        uint32_t block_samples;\n\n        if (wpc->acc_samples > wpc->block_samples)\n            block_samples = wpc->acc_samples / 2;\n        else\n            block_samples = wpc->acc_samples;\n\n        if (!pack_streams (wpc, block_samples))\n            return FALSE;\n    }\n\n    if (wpc->metacount)\n        write_metadata_block (wpc);\n\n    return TRUE;\n}\n\n// Note: The following function is no longer required because a proper wav\n// header is now automatically generated for the application. However, if the\n// application wants to generate its own header or wants to include additional\n// chunks, then this function can still be used in which case the automatic\n// wav header generation is suppressed.\n\n// Add wrapper (currently RIFF only) to WavPack blocks. This should be called\n// before sending any audio samples for the RIFF header or after all samples\n// have been sent for any RIFF trailer. WavpackFlushSamples() should be called\n// between sending the last samples and calling this for trailer data to make\n// sure that headers and trailers don't get mixed up in very short files. If\n// the exact contents of the RIFF header are not known because, for example,\n// the file duration is uncertain or trailing chunks are possible, simply write\n// a \"dummy\" header of the correct length. When all data has been written it\n// will be possible to read the first block written and update the header\n// directly. An example of this can be found in the Audition filter. A\n// return of FALSE indicates an error.\n\nint WavpackAddWrapper (WavpackContext *wpc, void *data, uint32_t bcount)\n{\n    int64_t index = WavpackGetSampleIndex64 (wpc);\n    unsigned char meta_id;\n\n    if (!index || index == -1) {\n        wpc->riff_header_added = TRUE;\n        meta_id = wpc->file_format ? ID_ALT_HEADER : ID_RIFF_HEADER;\n    }\n    else {\n        wpc->riff_trailer_bytes += bcount;\n        meta_id = wpc->file_format ? ID_ALT_TRAILER : ID_RIFF_TRAILER;\n    }\n\n    return add_to_metadata (wpc, data, bcount, meta_id);\n}\n\n// Store computed MD5 sum in WavPack metadata. Note that the user must compute\n// the 16 byte sum; it is not done here. A return of FALSE indicates an error.\n// If any of the lower 8 bits of qmode are set, then this MD5 is stored with\n// a metadata ID that old decoders do not recognize (because they would not\n// interpret the qmode and would therefore fail the verification).\n\nint WavpackStoreMD5Sum (WavpackContext *wpc, unsigned char data [16])\n{\n    return add_to_metadata (wpc, data, 16, (wpc->config.qmode & 0xff) ? ID_ALT_MD5_CHECKSUM : ID_MD5_CHECKSUM);\n}\n\n#pragma pack(push,4)\n\ntypedef struct {\n    char ckID [4];\n    uint64_t chunkSize64;\n} CS64Chunk;\n\ntypedef struct {\n    uint64_t riffSize64, dataSize64, sampleCount64;\n    uint32_t tableLength;\n} DS64Chunk;\n\ntypedef struct {\n    char ckID [4];\n    uint32_t ckSize;\n    char junk [28];\n} JunkChunk;\n\n#pragma pack(pop)\n\n#define DS64ChunkFormat \"DDDL\"\n\nstatic int create_riff_header (WavpackContext *wpc, int64_t total_samples, void *outbuffer)\n{\n    int do_rf64 = 0, write_junk = 1;\n    ChunkHeader ds64hdr, datahdr, fmthdr;\n    char *outptr = outbuffer;\n    RiffChunkHeader riffhdr;\n    DS64Chunk ds64_chunk;\n    JunkChunk junkchunk;\n    WaveHeader wavhdr;\n\n    int64_t total_data_bytes, total_riff_bytes;\n    int32_t channel_mask = wpc->config.channel_mask;\n    int32_t sample_rate = wpc->config.sample_rate;\n    int bytes_per_sample = wpc->config.bytes_per_sample;\n    int bits_per_sample = wpc->config.bits_per_sample;\n    int format = (wpc->config.float_norm_exp) ? 3 : 1;\n    int num_channels = wpc->config.num_channels;\n    int wavhdrsize = 16;\n\n    wpc->riff_header_created = TRUE;\n\n    if (format == 3 && wpc->config.float_norm_exp != 127) {\n        strcpy (wpc->error_message, \"can't create valid RIFF wav header for non-normalized floating data!\");\n        return FALSE;\n    }\n\n    if (total_samples == -1)\n        total_samples = 0x7ffff000 / (bytes_per_sample * num_channels);\n\n    total_data_bytes = total_samples * bytes_per_sample * num_channels;\n\n    if (total_data_bytes > 0xff000000) {\n        write_junk = 0;\n        do_rf64 = 1;\n    }\n\n    CLEAR (wavhdr);\n\n    wavhdr.FormatTag = format;\n    wavhdr.NumChannels = num_channels;\n    wavhdr.SampleRate = sample_rate;\n    wavhdr.BytesPerSecond = sample_rate * num_channels * bytes_per_sample;\n    wavhdr.BlockAlign = bytes_per_sample * num_channels;\n    wavhdr.BitsPerSample = bits_per_sample;\n\n    if (num_channels > 2 || channel_mask != 0x5 - num_channels) {\n        wavhdrsize = sizeof (wavhdr);\n        wavhdr.cbSize = 22;\n        wavhdr.ValidBitsPerSample = bits_per_sample;\n        wavhdr.SubFormat = format;\n        wavhdr.ChannelMask = channel_mask;\n        wavhdr.FormatTag = 0xfffe;\n        wavhdr.BitsPerSample = bytes_per_sample * 8;\n        wavhdr.GUID [4] = 0x10;\n        wavhdr.GUID [6] = 0x80;\n        wavhdr.GUID [9] = 0xaa;\n        wavhdr.GUID [11] = 0x38;\n        wavhdr.GUID [12] = 0x9b;\n        wavhdr.GUID [13] = 0x71;\n    }\n\n    strncpy (riffhdr.ckID, do_rf64 ? \"RF64\" : \"RIFF\", sizeof (riffhdr.ckID));\n    strncpy (riffhdr.formType, \"WAVE\", sizeof (riffhdr.formType));\n    total_riff_bytes = sizeof (riffhdr) + wavhdrsize + sizeof (datahdr) + total_data_bytes + wpc->riff_trailer_bytes;\n    if (do_rf64) total_riff_bytes += sizeof (ds64hdr) + sizeof (ds64_chunk);\n    if (write_junk) total_riff_bytes += sizeof (junkchunk);\n    strncpy (fmthdr.ckID, \"fmt \", sizeof (fmthdr.ckID));\n    strncpy (datahdr.ckID, \"data\", sizeof (datahdr.ckID));\n    fmthdr.ckSize = wavhdrsize;\n\n    if (write_junk) {\n        CLEAR (junkchunk);\n        strncpy (junkchunk.ckID, \"junk\", sizeof (junkchunk.ckID));\n        junkchunk.ckSize = sizeof (junkchunk) - 8;\n        WavpackNativeToLittleEndian (&junkchunk, ChunkHeaderFormat);\n    }\n\n    if (do_rf64) {\n        strncpy (ds64hdr.ckID, \"ds64\", sizeof (ds64hdr.ckID));\n        ds64hdr.ckSize = sizeof (ds64_chunk);\n        CLEAR (ds64_chunk);\n        ds64_chunk.riffSize64 = total_riff_bytes;\n        ds64_chunk.dataSize64 = total_data_bytes;\n        ds64_chunk.sampleCount64 = total_samples;\n        riffhdr.ckSize = (uint32_t) -1;\n        datahdr.ckSize = (uint32_t) -1;\n        WavpackNativeToLittleEndian (&ds64hdr, ChunkHeaderFormat);\n        WavpackNativeToLittleEndian (&ds64_chunk, DS64ChunkFormat);\n    }\n    else {\n        riffhdr.ckSize = (uint32_t) total_riff_bytes;\n        datahdr.ckSize = (uint32_t) total_data_bytes;\n    }\n\n    WavpackNativeToLittleEndian (&riffhdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&fmthdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&wavhdr, WaveHeaderFormat);\n    WavpackNativeToLittleEndian (&datahdr, ChunkHeaderFormat);\n\n    // write the RIFF chunks up to just before the data starts\n\n    outptr = (char *) memcpy (outptr, &riffhdr, sizeof (riffhdr)) + sizeof (riffhdr);\n\n    if (do_rf64) {\n        outptr = (char *) memcpy (outptr, &ds64hdr, sizeof (ds64hdr)) + sizeof (ds64hdr);\n        outptr = (char *) memcpy (outptr, &ds64_chunk, sizeof (ds64_chunk)) + sizeof (ds64_chunk);\n    }\n\n    if (write_junk)\n        outptr = (char *) memcpy (outptr, &junkchunk, sizeof (junkchunk)) + sizeof (junkchunk);\n\n    outptr = (char *) memcpy (outptr, &fmthdr, sizeof (fmthdr)) + sizeof (fmthdr);\n    outptr = (char *) memcpy (outptr, &wavhdr, wavhdrsize) + wavhdrsize;\n    outptr = (char *) memcpy (outptr, &datahdr, sizeof (datahdr)) + sizeof (datahdr);\n\n    return (int)(outptr - (char *) outbuffer);\n}\n\nstatic int block_add_checksum (unsigned char *buffer_start, unsigned char *buffer_end, int bytes);\n\nstatic int pack_streams (WavpackContext *wpc, uint32_t block_samples)\n{\n    uint32_t max_blocksize, max_chans = 1, bcount;\n    unsigned char *outbuff, *outend, *out2buff, *out2end;\n    int result = TRUE, i;\n\n    // for calculating output (block) buffer size, first see if any streams are stereo\n\n    for (i = 0; i < wpc->num_streams; i++)\n        if (!(wpc->streams [i]->wphdr.flags & MONO_FLAG)) {\n            max_chans = 2;\n            break;\n        }\n\n    // then calculate maximum size based on bytes / sample\n\n    max_blocksize = block_samples * max_chans * ((wpc->streams [0]->wphdr.flags & BYTES_STORED) + 1);\n\n    // add margin based on how much \"negative\" compression is possible with pathological audio\n\n    if ((wpc->config.flags & CONFIG_FLOAT_DATA) && !(wpc->config.flags & CONFIG_SKIP_WVX))\n        max_blocksize += max_blocksize;         // 100% margin for lossless float data\n    else\n        max_blocksize += max_blocksize >> 2;    // otherwise 25% margin for everything else\n\n    max_blocksize += wpc->metabytes + 1024;     // finally, add metadata & another 1K margin\n\n    out2buff = (wpc->wvc_flag) ? malloc (max_blocksize) : NULL;\n    out2end = out2buff + max_blocksize;\n    outbuff = malloc (max_blocksize);\n    outend = outbuff + max_blocksize;\n\n    for (wpc->current_stream = 0; wpc->current_stream < wpc->num_streams; wpc->current_stream++) {\n        WavpackStream *wps = wpc->streams [wpc->current_stream];\n        uint32_t flags = wps->wphdr.flags;\n\n        flags &= ~MAG_MASK;\n        flags += (1 << MAG_LSB) * ((flags & BYTES_STORED) * 8 + 7);\n\n        SET_BLOCK_INDEX (wps->wphdr, wps->sample_index);\n        wps->wphdr.block_samples = block_samples;\n        wps->wphdr.flags = flags;\n        wps->block2buff = out2buff;\n        wps->block2end = out2end;\n        wps->blockbuff = outbuff;\n        wps->blockend = outend;\n\n#ifdef ENABLE_DSD\n        if (flags & DSD_FLAG)\n            result = pack_dsd_block (wpc, wps->sample_buffer);\n        else\n#endif\n            result = pack_block (wpc, wps->sample_buffer);\n\n        if (result) {\n            result = block_add_checksum (outbuff, outend, (flags & HYBRID_FLAG) ? 2 : 4);\n\n            if (result && out2buff)\n                result = block_add_checksum (out2buff, out2end, 2);\n        }\n\n        wps->blockbuff = wps->block2buff = NULL;\n\n        if (wps->wphdr.block_samples != block_samples)\n            block_samples = wps->wphdr.block_samples;\n\n        if (!result) {\n            strcpy (wpc->error_message, \"output buffer overflowed!\");\n            break;\n        }\n\n        bcount = ((WavpackHeader *) outbuff)->ckSize + 8;\n        WavpackNativeToLittleEndian ((WavpackHeader *) outbuff, WavpackHeaderFormat);\n        result = wpc->blockout (wpc->wv_out, outbuff, bcount);\n\n        if (!result) {\n            strcpy (wpc->error_message, \"can't write WavPack data, disk probably full!\");\n            break;\n        }\n\n        wpc->filelen += bcount;\n\n        if (out2buff) {\n            bcount = ((WavpackHeader *) out2buff)->ckSize + 8;\n            WavpackNativeToLittleEndian ((WavpackHeader *) out2buff, WavpackHeaderFormat);\n            result = wpc->blockout (wpc->wvc_out, out2buff, bcount);\n\n            if (!result) {\n                strcpy (wpc->error_message, \"can't write WavPack data, disk probably full!\");\n                break;\n            }\n\n            wpc->file2len += bcount;\n        }\n\n        if (wpc->acc_samples != block_samples)\n            memmove (wps->sample_buffer, wps->sample_buffer + block_samples * (flags & MONO_FLAG ? 1 : 2),\n                (wpc->acc_samples - block_samples) * sizeof (int32_t) * (flags & MONO_FLAG ? 1 : 2));\n    }\n\n    wpc->current_stream = 0;\n    wpc->ave_block_samples = (wpc->ave_block_samples * 0x7 + block_samples + 0x4) >> 3;\n    wpc->acc_samples -= block_samples;\n    free (outbuff);\n\n    if (out2buff)\n        free (out2buff);\n\n    return result;\n}\n\n// Given the pointer to the first block written (to either a .wv or .wvc file),\n// update the block with the actual number of samples written. If the wav\n// header was generated by the library, then it is updated also. This should\n// be done if WavpackSetConfiguration() was called with an incorrect number\n// of samples (or -1). It is the responsibility of the application to read and\n// rewrite the block. An example of this can be found in the Audition filter.\n\nstatic void block_update_checksum (unsigned char *buffer_start);\n\nvoid WavpackUpdateNumSamples (WavpackContext *wpc, void *first_block)\n{\n    uint32_t wrapper_size;\n\n    WavpackLittleEndianToNative (first_block, WavpackHeaderFormat);\n    SET_TOTAL_SAMPLES (* (WavpackHeader *) first_block, WavpackGetSampleIndex64 (wpc));\n\n    if (wpc->riff_header_created && WavpackGetWrapperLocation (first_block, &wrapper_size)) {\n        unsigned char riff_header [128];\n\n        if (wrapper_size == create_riff_header (wpc, WavpackGetSampleIndex64 (wpc), riff_header))\n            memcpy (WavpackGetWrapperLocation (first_block, NULL), riff_header, wrapper_size);\n    }\n\n    block_update_checksum (first_block);\n    WavpackNativeToLittleEndian (first_block, WavpackHeaderFormat);\n}\n\n// Note: The following function is no longer required because the wav header\n// automatically generated for the application will also be updated by\n// WavpackUpdateNumSamples (). However, if the application wants to generate\n// its own header or wants to include additional chunks, then this function\n// still must be used to update the application generated header.\n\n// Given the pointer to the first block written to a WavPack file, this\n// function returns the location of the stored RIFF header that was originally\n// written with WavpackAddWrapper(). This would normally be used to update\n// the wav header to indicate that a different number of samples was actually\n// written or if additional RIFF chunks are written at the end of the file.\n// The \"size\" parameter can be set to non-NULL to obtain the exact size of the\n// RIFF header, and the function will return FALSE if the header is not found\n// in the block's metadata (or it is not a valid WavPack block). It is the\n// responsibility of the application to read and rewrite the block. An example\n// of this can be found in the Audition filter.\n\nstatic void *find_metadata (void *wavpack_block, int desired_id, uint32_t *size);\n\nvoid *WavpackGetWrapperLocation (void *first_block, uint32_t *size)\n{\n    void *loc;\n\n    WavpackLittleEndianToNative (first_block, WavpackHeaderFormat);\n    loc = find_metadata (first_block, ID_RIFF_HEADER, size);\n\n    if (!loc)\n        loc = find_metadata (first_block, ID_ALT_HEADER, size);\n\n    WavpackNativeToLittleEndian (first_block, WavpackHeaderFormat);\n\n    return loc;\n}\n\nstatic void *find_metadata (void *wavpack_block, int desired_id, uint32_t *size)\n{\n    WavpackHeader *wphdr = wavpack_block;\n    unsigned char *dp, meta_id, c1, c2;\n    int32_t bcount, meta_bc;\n\n    if (strncmp (wphdr->ckID, \"wvpk\", 4))\n        return NULL;\n\n    bcount = wphdr->ckSize - sizeof (WavpackHeader) + 8;\n    dp = (unsigned char *)(wphdr + 1);\n\n    while (bcount >= 2) {\n        meta_id = *dp++;\n        c1 = *dp++;\n\n        meta_bc = c1 << 1;\n        bcount -= 2;\n\n        if (meta_id & ID_LARGE) {\n            if (bcount < 2)\n                break;\n\n            c1 = *dp++;\n            c2 = *dp++;\n            meta_bc += ((uint32_t) c1 << 9) + ((uint32_t) c2 << 17);\n            bcount -= 2;\n        }\n\n        if ((meta_id & ID_UNIQUE) == desired_id) {\n            if ((bcount - meta_bc) >= 0) {\n                if (size)\n                    *size = meta_bc - ((meta_id & ID_ODD_SIZE) ? 1 : 0);\n\n                return dp;\n            }\n            else\n                return NULL;\n        }\n\n        bcount -= meta_bc;\n        dp += meta_bc;\n    }\n\n    return NULL;\n}\n\nint copy_metadata (WavpackMetadata *wpmd, unsigned char *buffer_start, unsigned char *buffer_end)\n{\n    uint32_t mdsize = wpmd->byte_length + (wpmd->byte_length & 1);\n    WavpackHeader *wphdr = (WavpackHeader *) buffer_start;\n\n    mdsize += (wpmd->byte_length > 510) ? 4 : 2;\n    buffer_start += wphdr->ckSize + 8;\n\n    if (buffer_start + mdsize >= buffer_end)\n        return FALSE;\n\n    buffer_start [0] = wpmd->id | (wpmd->byte_length & 1 ? ID_ODD_SIZE : 0);\n    buffer_start [1] = (wpmd->byte_length + 1) >> 1;\n\n    if (wpmd->byte_length > 510) {\n        buffer_start [0] |= ID_LARGE;\n        buffer_start [2] = (wpmd->byte_length + 1) >> 9;\n        buffer_start [3] = (wpmd->byte_length + 1) >> 17;\n    }\n\n    if (wpmd->data && wpmd->byte_length) {\n        memcpy (buffer_start + (wpmd->byte_length > 510 ? 4 : 2), wpmd->data, wpmd->byte_length);\n\n        if (wpmd->byte_length & 1)          // if size is odd, make sure pad byte is a zero\n            buffer_start [mdsize - 1] = 0;\n    }\n\n    wphdr->ckSize += mdsize;\n    return TRUE;\n}\n\nstatic int add_to_metadata (WavpackContext *wpc, void *data, uint32_t bcount, unsigned char id)\n{\n    WavpackMetadata *mdp;\n    unsigned char *src = data;\n\n    while (bcount) {\n        if (wpc->metacount) {\n            uint32_t bc = bcount;\n\n            mdp = wpc->metadata + wpc->metacount - 1;\n\n            if (mdp->id == id) {\n                if (wpc->metabytes + bcount > 1000000)\n                    bc = 1000000 - wpc->metabytes;\n\n                mdp->data = realloc (mdp->data, mdp->byte_length + bc);\n                memcpy ((char *) mdp->data + mdp->byte_length, src, bc);\n                mdp->byte_length += bc;\n                wpc->metabytes += bc;\n                bcount -= bc;\n                src += bc;\n\n                if (wpc->metabytes >= 1000000 && !write_metadata_block (wpc))\n                    return FALSE;\n            }\n        }\n\n        if (bcount) {\n            wpc->metadata = realloc (wpc->metadata, (wpc->metacount + 1) * sizeof (WavpackMetadata));\n            mdp = wpc->metadata + wpc->metacount++;\n            mdp->byte_length = 0;\n            mdp->data = NULL;\n            mdp->id = id;\n        }\n    }\n\n    return TRUE;\n}\n\nstatic char *write_metadata (WavpackMetadata *wpmd, char *outdata)\n{\n    unsigned char id = wpmd->id, wordlen [3];\n\n    wordlen [0] = (wpmd->byte_length + 1) >> 1;\n    wordlen [1] = (wpmd->byte_length + 1) >> 9;\n    wordlen [2] = (wpmd->byte_length + 1) >> 17;\n\n    if (wpmd->byte_length & 1)\n        id |= ID_ODD_SIZE;\n\n    if (wordlen [1] || wordlen [2])\n        id |= ID_LARGE;\n\n    *outdata++ = id;\n    *outdata++ = wordlen [0];\n\n    if (id & ID_LARGE) {\n        *outdata++ = wordlen [1];\n        *outdata++ = wordlen [2];\n    }\n\n    if (wpmd->data && wpmd->byte_length) {\n        memcpy (outdata, wpmd->data, wpmd->byte_length);\n        outdata += wpmd->byte_length;\n\n        if (wpmd->byte_length & 1)\n            *outdata++ = 0;\n    }\n\n    return outdata;\n}\n\nstatic int write_metadata_block (WavpackContext *wpc)\n{\n    char *block_buff, *block_ptr;\n    WavpackHeader *wphdr;\n\n    if (wpc->metacount) {\n        int metacount = wpc->metacount, block_size = sizeof (WavpackHeader);\n        WavpackMetadata *wpmdp = wpc->metadata;\n\n        while (metacount--) {\n            block_size += wpmdp->byte_length + (wpmdp->byte_length & 1);\n            block_size += (wpmdp->byte_length > 510) ? 4 : 2;\n            wpmdp++;\n        }\n\n        // allocate 6 extra bytes for 4-byte checksum (which we add last)\n        wphdr = (WavpackHeader *) (block_buff = malloc (block_size + 6));\n\n        CLEAR (*wphdr);\n        memcpy (wphdr->ckID, \"wvpk\", 4);\n        SET_TOTAL_SAMPLES (*wphdr, wpc->total_samples);\n        wphdr->version = wpc->stream_version;\n        wphdr->ckSize = block_size - 8;\n        wphdr->block_samples = 0;\n\n        block_ptr = (char *)(wphdr + 1);\n\n        wpmdp = wpc->metadata;\n\n        while (wpc->metacount) {\n            block_ptr = write_metadata (wpmdp, block_ptr);\n            wpc->metabytes -= wpmdp->byte_length;\n            free_metadata (wpmdp++);\n            wpc->metacount--;\n        }\n\n        free (wpc->metadata);\n        wpc->metadata = NULL;\n        // add a 4-byte checksum here (increases block size by 6)\n        block_add_checksum ((unsigned char *) block_buff, (unsigned char *) block_buff + (block_size += 6), 4);\n        WavpackNativeToLittleEndian ((WavpackHeader *) block_buff, WavpackHeaderFormat);\n\n        if (!wpc->blockout (wpc->wv_out, block_buff, block_size)) {\n            free (block_buff);\n            strcpy (wpc->error_message, \"can't write WavPack data, disk probably full!\");\n            return FALSE;\n        }\n\n        free (block_buff);\n    }\n\n    return TRUE;\n}\n\nvoid free_metadata (WavpackMetadata *wpmd)\n{\n    if (wpmd->data) {\n        free (wpmd->data);\n        wpmd->data = NULL;\n    }\n}\n\n// These two functions add or update the block checksums that were introduced in WavPack 5.0.\n// The presence of the checksum is indicated by a flag in the wavpack header (HAS_CHECKSUM)\n// and the actual metadata item should be the last one in the block, and can be either 2 or 4\n// bytes. Of course, older versions of the decoder will simply ignore both of these.\n\nstatic int block_add_checksum (unsigned char *buffer_start, unsigned char *buffer_end, int bytes)\n{\n    WavpackHeader *wphdr = (WavpackHeader *) buffer_start;\n#ifdef BITSTREAM_SHORTS\n    uint16_t *csptr = (uint16_t*) buffer_start;\n#else\n    unsigned char *csptr = buffer_start;\n#endif\n    int bcount = wphdr->ckSize + 8, wcount;\n    uint32_t csum = (uint32_t) -1;\n\n    if (bytes != 2 && bytes != 4)\n        return FALSE;\n\n    if (bcount < sizeof (WavpackHeader) || (bcount & 1) || buffer_start + bcount + 2 + bytes > buffer_end)\n        return FALSE;\n\n    wphdr->flags |= HAS_CHECKSUM;\n    wphdr->ckSize += 2 + bytes;\n    wcount = bcount >> 1;\n\n#ifdef BITSTREAM_SHORTS\n    while (wcount--)\n        csum = (csum * 3) + *csptr++;\n#else\n    WavpackNativeToLittleEndian ((WavpackHeader *) buffer_start, WavpackHeaderFormat);\n\n    while (wcount--) {\n        csum = (csum * 3) + csptr [0] + (csptr [1] << 8);\n        csptr += 2;\n    }\n\n    WavpackLittleEndianToNative ((WavpackHeader *) buffer_start, WavpackHeaderFormat);\n#endif\n\n    buffer_start += bcount;\n    *buffer_start++ = ID_BLOCK_CHECKSUM;\n    *buffer_start++ = bytes >> 1;\n\n    if (bytes == 4) {\n        *buffer_start++ = csum;\n        *buffer_start++ = csum >> 8;\n        *buffer_start++ = csum >> 16;\n        *buffer_start++ = csum >> 24;\n    }\n    else {\n        csum ^= csum >> 16;\n        *buffer_start++ = csum;\n        *buffer_start++ = csum >> 8;\n    }\n\n    return TRUE;\n}\n\nstatic void block_update_checksum (unsigned char *buffer_start)\n{\n    WavpackHeader *wphdr = (WavpackHeader *) buffer_start;\n    unsigned char *dp, meta_id, c1, c2;\n    uint32_t bcount, meta_bc;\n\n    if (!(wphdr->flags & HAS_CHECKSUM))\n        return;\n\n    bcount = wphdr->ckSize - sizeof (WavpackHeader) + 8;\n    dp = (unsigned char *)(wphdr + 1);\n\n    while (bcount >= 2) {\n        meta_id = *dp++;\n        c1 = *dp++;\n\n        meta_bc = c1 << 1;\n        bcount -= 2;\n\n        if (meta_id & ID_LARGE) {\n            if (bcount < 2)\n                return;\n\n            c1 = *dp++;\n            c2 = *dp++;\n            meta_bc += ((uint32_t) c1 << 9) + ((uint32_t) c2 << 17);\n            bcount -= 2;\n        }\n\n        if (bcount < meta_bc)\n            return;\n\n        if ((meta_id & ID_UNIQUE) == ID_BLOCK_CHECKSUM) {\n#ifdef BITSTREAM_SHORTS\n            uint16_t *csptr = (uint16_t*) buffer_start;\n#else\n            unsigned char *csptr = buffer_start;\n#endif\n            int wcount = (int)(dp - 2 - buffer_start) >> 1;\n            uint32_t csum = (uint32_t) -1;\n\n            if ((meta_id & ID_ODD_SIZE) || meta_bc < 2 || meta_bc > 4)\n                return;\n\n#ifdef BITSTREAM_SHORTS\n            while (wcount--)\n                csum = (csum * 3) + *csptr++;\n#else\n            WavpackNativeToLittleEndian ((WavpackHeader *) buffer_start, WavpackHeaderFormat);\n\n            while (wcount--) {\n                csum = (csum * 3) + csptr [0] + (csptr [1] << 8);\n                csptr += 2;\n            }\n\n            WavpackLittleEndianToNative ((WavpackHeader *) buffer_start, WavpackHeaderFormat);\n#endif\n\n            if (meta_bc == 4) {\n                *dp++ = csum;\n                *dp++ = csum >> 8;\n                *dp++ = csum >> 16;\n                *dp++ = csum >> 24;\n                return;\n            }\n            else {\n                csum ^= csum >> 16;\n                *dp++ = csum;\n                *dp++ = csum >> 8;\n                return;\n            }\n        }\n\n        bcount -= meta_bc;\n        dp += meta_bc;\n    }\n}\n"], "filenames": ["src/pack_utils.c"], "buggy_code_start_loc": [197], "buggy_code_end_loc": [197], "fixing_code_start_loc": [198], "fixing_code_end_loc": [203], "type": "CWE-835", "message": "The function WavpackPackInit in pack_utils.c in libwavpack.a in WavPack through 5.1.0 allows attackers to cause a denial-of-service (resource exhaustion caused by an infinite loop) via a crafted wav audio file because WavpackSetConfiguration64 mishandles a sample rate of zero.", "other": {"cve": {"id": "CVE-2018-19840", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-04T09:29:00.600", "lastModified": "2021-01-15T13:15:12.607", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The function WavpackPackInit in pack_utils.c in libwavpack.a in WavPack through 5.1.0 allows attackers to cause a denial-of-service (resource exhaustion caused by an infinite loop) via a crafted wav audio file because WavpackSetConfiguration64 mishandles a sample rate of zero."}, {"lang": "es", "value": "La funci\u00f3n WavpackPackInit en pack_utils.c en libwavpack.a en WavPack hasta la versi\u00f3n 5.1.0 permite que los atacantes provoquen una denegaci\u00f3n de servicio (agotamiento de recursos provocado por un bucle infinito) mediante un archivo de audio wav manipulado debido a que WavpackSetConfiguration64 gestiona err\u00f3neamente una tasa de ejemplo con valor cero."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wavpack:wavpack:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.1.0", "matchCriteriaId": "A5AF1FF6-17E5-429C-8280-8215E7010571"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:28:*:*:*:*:*:*:*", "matchCriteriaId": "DC1BD7B7-6D88-42B8-878E-F1318CA5FCAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:29:*:*:*:*:*:*:*", "matchCriteriaId": "D100F7CE-FC64-4CC6-852A-6136D72DA419"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-04/msg00029.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://packetstormsecurity.com/files/155743/Slackware-Security-Advisory-wavpack-Updates.html", "source": "cve@mitre.org"}, {"url": "https://github.com/dbry/WavPack/commit/070ef6f138956d9ea9612e69586152339dbefe51", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dbry/WavPack/issues/53", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/01/msg00013.html", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3BLSOEVEKF4VNNVNZ2AN46BJUT4TGVWT/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6CFFFWIWALGQPKINRDW3PRGRD5LOLGZA/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BRWQNE3TH5UF64IKHKKHVCHJHUOVKJUH/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NZGXJUHCGQI6XKLCBUZHXPYIIWMFWA22/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WVVKOBJR5APOB3KWUWJ4UWQHUBZQL6C6/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Dec/37", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/202007-19", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3839-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dbry/WavPack/commit/070ef6f138956d9ea9612e69586152339dbefe51"}}