{"buggy_code": ["import(\"//brave/browser/translate/buildflags/buildflags.gni\")\nimport(\"//brave/components/brave_referrals/buildflags/buildflags.gni\")\nimport(\"//brave/components/brave_webtorrent/browser/buildflags/buildflags.gni\")\nimport(\"//brave/components/ipfs/buildflags/buildflags.gni\")\nimport(\"//build/config/features.gni\")\n\n# Refer to the keyed API spec for more details about the Brave Services Key\ndefines = brave_service_key_defines\n\nsource_set(\"net\") {\n  # Remove when https://github.com/brave/brave-browser/issues/10659 is resolved\n  check_includes = false\n  configs += [ \"//brave/build/geolocation\" ]\n  sources = [\n    \"brave_ad_block_tp_network_delegate_helper.cc\",\n    \"brave_ad_block_tp_network_delegate_helper.h\",\n    \"brave_block_safebrowsing_urls.cc\",\n    \"brave_block_safebrowsing_urls.h\",\n    \"brave_common_static_redirect_network_delegate_helper.cc\",\n    \"brave_common_static_redirect_network_delegate_helper.h\",\n    \"brave_httpse_network_delegate_helper.cc\",\n    \"brave_httpse_network_delegate_helper.h\",\n    \"brave_proxying_url_loader_factory.cc\",\n    \"brave_proxying_url_loader_factory.h\",\n    \"brave_proxying_web_socket.cc\",\n    \"brave_proxying_web_socket.h\",\n    \"brave_request_handler.cc\",\n    \"brave_request_handler.h\",\n    \"brave_site_hacks_network_delegate_helper.cc\",\n    \"brave_site_hacks_network_delegate_helper.h\",\n    \"brave_static_redirect_network_delegate_helper.cc\",\n    \"brave_static_redirect_network_delegate_helper.h\",\n    \"brave_stp_util.cc\",\n    \"brave_stp_util.h\",\n    \"brave_system_request_handler.cc\",\n    \"brave_system_request_handler.h\",\n    \"global_privacy_control_network_delegate_helper.cc\",\n    \"global_privacy_control_network_delegate_helper.h\",\n    \"resource_context_data.cc\",\n    \"resource_context_data.h\",\n    \"url_context.cc\",\n    \"url_context.h\",\n  ]\n\n  deps = [\n    \"//base\",\n    \"//brave/app:brave_generated_resources_grit\",\n    \"//brave/browser/safebrowsing\",\n    \"//brave/browser/translate/buildflags\",\n    \"//brave/common\",\n    \"//brave/components/brave_component_updater/browser\",\n    \"//brave/components/brave_referrals/buildflags\",\n    \"//brave/components/brave_shields/browser\",\n    \"//brave/components/brave_webtorrent/browser/buildflags\",\n    \"//brave/components/ipfs/buildflags\",\n    \"//brave/extensions:common\",\n    \"//components/prefs\",\n    \"//components/user_prefs\",\n    \"//content/public/browser\",\n    \"//content/public/common\",\n    \"//components/content_settings/core/browser\",\n    \"//extensions/common:common_constants\",\n    \"//mojo/public/cpp/bindings\",\n    \"//mojo/public/cpp/system\",\n    \"//net\",\n    \"//services/network/public/cpp\",\n    \"//services/network/public/mojom\",\n    \"//third_party/blink/public/common\",\n    \"//third_party/blink/public/mojom:mojom_platform_headers\",\n    \"//third_party/re2\",\n    \"//url\",\n  ]\n\n  if (ipfs_enabled) {\n    sources += [\n      \"ipfs_redirect_network_delegate_helper.cc\",\n      \"ipfs_redirect_network_delegate_helper.h\",\n    ]\n    deps += [\n      \"//brave/components/ipfs\",\n      \"//chrome/common:channel_info\",\n    ]\n  }\n\n  if (enable_brave_referrals) {\n    sources += [\n      \"brave_referrals_network_delegate_helper.cc\",\n      \"brave_referrals_network_delegate_helper.h\",\n    ]\n\n    deps += [\n      \"//brave/components/brave_referrals/browser\",\n    ]\n  }\n\n  if (enable_brave_webtorrent) {\n    sources += [\n      \"brave_torrent_redirect_network_delegate_helper.cc\",\n      \"brave_torrent_redirect_network_delegate_helper.h\",\n    ]\n\n    deps += [\n      \"//brave/components/brave_webtorrent/browser/\",\n      \"//extensions/browser\",\n    ]\n  }\n\n  if (enable_brave_translate_go) {\n    sources += [\n      \"brave_translate_redirect_network_delegate_helper.cc\",\n      \"brave_translate_redirect_network_delegate_helper.h\",\n    ]\n  }\n}\n", "/* Copyright (c) 2019 The Brave Authors. All rights reserved.\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this file,\n * You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n#include \"brave/browser/net/brave_ad_block_tp_network_delegate_helper.h\"\n\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"base/base64url.h\"\n#include \"base/strings/string_util.h\"\n#include \"brave/browser/brave_browser_process_impl.h\"\n#include \"brave/browser/net/url_context.h\"\n#include \"brave/common/network_constants.h\"\n#include \"brave/components/brave_shields/browser/ad_block_service.h\"\n#include \"brave/components/brave_shields/browser/brave_shields_util.h\"\n#include \"brave/components/brave_shields/browser/brave_shields_web_contents_observer.h\"\n#include \"brave/components/brave_shields/common/brave_shield_constants.h\"\n#include \"brave/grit/brave_generated_resources.h\"\n#include \"content/public/browser/browser_context.h\"\n#include \"content/public/browser/browser_thread.h\"\n#include \"content/public/browser/render_frame_host.h\"\n#include \"content/public/browser/storage_partition.h\"\n#include \"content/public/browser/web_contents.h\"\n#include \"extensions/common/url_pattern.h\"\n#include \"mojo/public/cpp/bindings/remote.h\"\n#include \"services/network/network_context.h\"\n#include \"ui/base/resource/resource_bundle.h\"\n#include \"url/url_canon.h\"\n\nnamespace brave {\n\nnamespace {\n\ncontent::WebContents* GetWebContents(int render_process_id,\n                                     int render_frame_id,\n                                     int frame_tree_node_id) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  content::WebContents* web_contents =\n      content::WebContents::FromFrameTreeNodeId(frame_tree_node_id);\n  if (!web_contents) {\n    content::RenderFrameHost* rfh =\n        content::RenderFrameHost::FromID(render_process_id, render_frame_id);\n    if (!rfh) {\n      return nullptr;\n    }\n    web_contents = content::WebContents::FromRenderFrameHost(rfh);\n  }\n  return web_contents;\n}\n\n}  // namespace\n\nvoid ShouldBlockAdOnTaskRunner(std::shared_ptr<BraveRequestInfo> ctx,\n                               base::Optional<std::string> canonical_name) {\n  bool did_match_rule = false;\n  bool did_match_exception = false;\n  bool did_match_important = false;\n  if (!ctx->initiator_url.is_valid()) {\n    return;\n  }\n  std::string source_host = ctx->initiator_url.host();\n\n  g_brave_browser_process->ad_block_service()->ShouldStartRequest(\n        ctx->request_url, ctx->resource_type, source_host,\n        &did_match_rule, &did_match_exception, &did_match_important,\n        &ctx->mock_data_url);\n  if (did_match_important) {\n    ctx->blocked_by = kAdBlocked;\n    return;\n  }\n\n  if (canonical_name.has_value() && ctx->request_url.host() != *canonical_name\n      && *canonical_name != \"\") {\n    GURL::Replacements replacements = GURL::Replacements();\n    replacements.SetHost(\n        canonical_name->c_str(),\n        url::Component(0, static_cast<int>(canonical_name->length())));\n    const GURL canonical_url = ctx->request_url.ReplaceComponents(replacements);\n\n    g_brave_browser_process->ad_block_service()->ShouldStartRequest(\n        ctx->request_url, ctx->resource_type, source_host,\n        &did_match_rule, &did_match_exception, &did_match_important,\n        &ctx->mock_data_url);\n  }\n\n  if (did_match_important || (did_match_rule && !did_match_exception)) {\n    ctx->blocked_by = kAdBlocked;\n  }\n}\n\nvoid OnShouldBlockAdResult(const ResponseCallback& next_callback,\n                           std::shared_ptr<BraveRequestInfo> ctx) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  if (ctx->blocked_by == kAdBlocked) {\n    brave_shields::DispatchBlockedEvent(\n        ctx->request_url, ctx->render_frame_id, ctx->render_process_id,\n        ctx->frame_tree_node_id, brave_shields::kAds);\n  }\n  next_callback.Run();\n}\n\nvoid ShouldBlockAdWithOptionalCname(\n    scoped_refptr<base::SequencedTaskRunner> task_runner,\n    const ResponseCallback& next_callback,\n    std::shared_ptr<BraveRequestInfo> ctx,\n    const base::Optional<std::string> cname) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  task_runner->PostTaskAndReply(\n      FROM_HERE, base::BindOnce(&ShouldBlockAdOnTaskRunner, ctx, cname),\n      base::BindOnce(&OnShouldBlockAdResult, next_callback, ctx));\n}\n\nclass AdblockCnameResolveHostClient : public network::mojom::ResolveHostClient {\n private:\n  mojo::Receiver<network::mojom::ResolveHostClient> receiver_{this};\n  base::OnceCallback<void(base::Optional<std::string>)> cb_;\n  base::TimeTicks start_time_;\n\n public:\n  AdblockCnameResolveHostClient(\n      const ResponseCallback& next_callback,\n      scoped_refptr<base::SequencedTaskRunner> task_runner,\n      std::shared_ptr<BraveRequestInfo> ctx) {\n    cb_ = base::BindOnce(&ShouldBlockAdWithOptionalCname, task_runner,\n                         std::move(next_callback), ctx);\n\n    auto* web_contents = GetWebContents(\n        ctx->render_process_id, ctx->render_frame_id, ctx->frame_tree_node_id);\n    if (!web_contents) {\n      start_time_ = base::TimeTicks::Now();\n      this->OnComplete(net::ERR_FAILED, net::ResolveErrorInfo(), base::nullopt);\n      return;\n    }\n\n    content::BrowserContext* context = web_contents->GetBrowserContext();\n\n    const auto network_isolation_key = ctx->network_isolation_key;\n\n    network::mojom::ResolveHostParametersPtr optional_parameters =\n        network::mojom::ResolveHostParameters::New();\n    optional_parameters->include_canonical_name = true;\n    // Explicitly specify source to avoid using `HostResolverProc`\n    // which will be handled by system resolver\n    // See https://crbug.com/872665\n    optional_parameters->source = net::HostResolverSource::DNS;\n\n    network::mojom::NetworkContext* network_context =\n        content::BrowserContext::GetDefaultStoragePartition(context)\n            ->GetNetworkContext();\n\n    start_time_ = base::TimeTicks::Now();\n\n    network_context->ResolveHost(\n        net::HostPortPair::FromURL(ctx->request_url), network_isolation_key,\n        std::move(optional_parameters), receiver_.BindNewPipeAndPassRemote());\n\n    receiver_.set_disconnect_handler(\n        base::BindOnce(&AdblockCnameResolveHostClient::OnComplete,\n                       base::Unretained(this), net::ERR_NAME_NOT_RESOLVED,\n                       net::ResolveErrorInfo(net::ERR_FAILED), base::nullopt));\n  }\n\n  void OnComplete(\n      int32_t result,\n      const net::ResolveErrorInfo& resolve_error_info,\n      const base::Optional<net::AddressList>& resolved_addresses) override {\n    UMA_HISTOGRAM_TIMES(\"Brave.ShieldsCNAMEBlocking.TotalResolutionTime\",\n                        base::TimeTicks::Now() - start_time_);\n    if (result == net::OK && resolved_addresses) {\n      DCHECK(resolved_addresses.has_value() && !resolved_addresses->empty());\n      std::move(cb_).Run(\n          base::Optional<std::string>(resolved_addresses->canonical_name()));\n    } else {\n      std::move(cb_).Run(base::nullopt);\n    }\n\n    delete this;\n  }\n\n  // Should not be called\n  void OnTextResults(const std::vector<std::string>& text_results) override {\n    NOTREACHED();\n  }\n\n  // Should not be called\n  void OnHostnameResults(const std::vector<net::HostPortPair>& hosts) override {\n    NOTREACHED();\n  }\n};\n\nvoid OnBeforeURLRequestAdBlockTP(const ResponseCallback& next_callback,\n                                 std::shared_ptr<BraveRequestInfo> ctx) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  // If the following info isn't available, then proper content settings can't\n  // be looked up, so do nothing.\n  if (ctx->tab_origin.is_empty() || !ctx->tab_origin.has_host() ||\n      ctx->request_url.is_empty()) {\n    return;\n  }\n  DCHECK_NE(ctx->request_identifier, 0UL);\n\n  scoped_refptr<base::SequencedTaskRunner> task_runner =\n      g_brave_browser_process->ad_block_service()->GetTaskRunner();\n\n  new AdblockCnameResolveHostClient(std::move(next_callback), task_runner, ctx);\n}\n\nint OnBeforeURLRequest_AdBlockTPPreWork(const ResponseCallback& next_callback,\n                                        std::shared_ptr<BraveRequestInfo> ctx) {\n  if (ctx->request_url.is_empty()) {\n    return net::OK;\n  }\n\n  // If the following info isn't available, then proper content settings can't\n  // be looked up, so do nothing.\n  if (ctx->tab_origin.is_empty() || !ctx->allow_brave_shields ||\n      ctx->allow_ads ||\n      ctx->resource_type == BraveRequestInfo::kInvalidResourceType) {\n    return net::OK;\n  }\n\n  OnBeforeURLRequestAdBlockTP(next_callback, ctx);\n\n  return net::ERR_IO_PENDING;\n}\n\n}  // namespace brave\n"], "fixing_code": ["import(\"//brave/browser/translate/buildflags/buildflags.gni\")\nimport(\"//brave/components/brave_referrals/buildflags/buildflags.gni\")\nimport(\"//brave/components/brave_webtorrent/browser/buildflags/buildflags.gni\")\nimport(\"//brave/components/ipfs/buildflags/buildflags.gni\")\nimport(\"//build/config/features.gni\")\n\n# Refer to the keyed API spec for more details about the Brave Services Key\ndefines = brave_service_key_defines\n\nsource_set(\"net\") {\n  # Remove when https://github.com/brave/brave-browser/issues/10659 is resolved\n  check_includes = false\n  configs += [ \"//brave/build/geolocation\" ]\n  sources = [\n    \"brave_ad_block_tp_network_delegate_helper.cc\",\n    \"brave_ad_block_tp_network_delegate_helper.h\",\n    \"brave_block_safebrowsing_urls.cc\",\n    \"brave_block_safebrowsing_urls.h\",\n    \"brave_common_static_redirect_network_delegate_helper.cc\",\n    \"brave_common_static_redirect_network_delegate_helper.h\",\n    \"brave_httpse_network_delegate_helper.cc\",\n    \"brave_httpse_network_delegate_helper.h\",\n    \"brave_proxying_url_loader_factory.cc\",\n    \"brave_proxying_url_loader_factory.h\",\n    \"brave_proxying_web_socket.cc\",\n    \"brave_proxying_web_socket.h\",\n    \"brave_request_handler.cc\",\n    \"brave_request_handler.h\",\n    \"brave_site_hacks_network_delegate_helper.cc\",\n    \"brave_site_hacks_network_delegate_helper.h\",\n    \"brave_static_redirect_network_delegate_helper.cc\",\n    \"brave_static_redirect_network_delegate_helper.h\",\n    \"brave_stp_util.cc\",\n    \"brave_stp_util.h\",\n    \"brave_system_request_handler.cc\",\n    \"brave_system_request_handler.h\",\n    \"global_privacy_control_network_delegate_helper.cc\",\n    \"global_privacy_control_network_delegate_helper.h\",\n    \"resource_context_data.cc\",\n    \"resource_context_data.h\",\n    \"url_context.cc\",\n    \"url_context.h\",\n  ]\n\n  deps = [\n    \"//base\",\n    \"//brave/app:brave_generated_resources_grit\",\n    \"//brave/browser/safebrowsing\",\n    \"//brave/browser/translate/buildflags\",\n    \"//brave/common\",\n    \"//brave/components/brave_component_updater/browser\",\n    \"//brave/components/brave_referrals/buildflags\",\n    \"//brave/components/brave_shields/browser\",\n    \"//brave/components/brave_webtorrent/browser/buildflags\",\n    \"//brave/components/ipfs/buildflags\",\n    \"//brave/extensions:common\",\n    \"//components/content_settings/core/browser\",\n    \"//components/prefs\",\n    \"//components/user_prefs\",\n    \"//content/public/browser\",\n    \"//content/public/common\",\n    \"//extensions/common:common_constants\",\n    \"//mojo/public/cpp/bindings\",\n    \"//mojo/public/cpp/system\",\n    \"//net\",\n    \"//services/network/public/cpp\",\n    \"//services/network/public/mojom\",\n    \"//third_party/blink/public/common\",\n    \"//third_party/blink/public/mojom:mojom_platform_headers\",\n    \"//third_party/re2\",\n    \"//url\",\n  ]\n\n  if (ipfs_enabled) {\n    sources += [\n      \"ipfs_redirect_network_delegate_helper.cc\",\n      \"ipfs_redirect_network_delegate_helper.h\",\n    ]\n    deps += [\n      \"//brave/components/ipfs\",\n      \"//chrome/common:channel_info\",\n    ]\n  }\n\n  if (enable_brave_referrals) {\n    sources += [\n      \"brave_referrals_network_delegate_helper.cc\",\n      \"brave_referrals_network_delegate_helper.h\",\n    ]\n\n    deps += [ \"//brave/components/brave_referrals/browser\" ]\n  }\n\n  if (enable_brave_webtorrent) {\n    sources += [\n      \"brave_torrent_redirect_network_delegate_helper.cc\",\n      \"brave_torrent_redirect_network_delegate_helper.h\",\n    ]\n\n    deps += [\n      \"//brave/components/brave_webtorrent/browser/\",\n      \"//extensions/browser\",\n    ]\n  }\n\n  if (enable_brave_translate_go) {\n    sources += [\n      \"brave_translate_redirect_network_delegate_helper.cc\",\n      \"brave_translate_redirect_network_delegate_helper.h\",\n    ]\n  }\n}\n", "/* Copyright (c) 2019 The Brave Authors. All rights reserved.\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this file,\n * You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n#include \"brave/browser/net/brave_ad_block_tp_network_delegate_helper.h\"\n\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"base/base64url.h\"\n#include \"base/strings/string_util.h\"\n#include \"brave/browser/brave_browser_process_impl.h\"\n#include \"brave/browser/net/url_context.h\"\n#include \"brave/common/network_constants.h\"\n#include \"brave/components/brave_shields/browser/ad_block_service.h\"\n#include \"brave/components/brave_shields/browser/brave_shields_util.h\"\n#include \"brave/components/brave_shields/browser/brave_shields_web_contents_observer.h\"\n#include \"brave/components/brave_shields/common/brave_shield_constants.h\"\n#include \"brave/grit/brave_generated_resources.h\"\n#include \"content/public/browser/browser_context.h\"\n#include \"content/public/browser/browser_thread.h\"\n#include \"content/public/browser/render_frame_host.h\"\n#include \"content/public/browser/storage_partition.h\"\n#include \"content/public/browser/web_contents.h\"\n#include \"extensions/common/url_pattern.h\"\n#include \"mojo/public/cpp/bindings/remote.h\"\n#include \"services/network/network_context.h\"\n#include \"ui/base/resource/resource_bundle.h\"\n#include \"url/url_canon.h\"\n\nnamespace brave {\n\nnamespace {\n\ncontent::WebContents* GetWebContents(int render_process_id,\n                                     int render_frame_id,\n                                     int frame_tree_node_id) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  content::WebContents* web_contents =\n      content::WebContents::FromFrameTreeNodeId(frame_tree_node_id);\n  if (!web_contents) {\n    content::RenderFrameHost* rfh =\n        content::RenderFrameHost::FromID(render_process_id, render_frame_id);\n    if (!rfh) {\n      return nullptr;\n    }\n    web_contents = content::WebContents::FromRenderFrameHost(rfh);\n  }\n  return web_contents;\n}\n\n}  // namespace\n\nvoid ShouldBlockAdOnTaskRunner(std::shared_ptr<BraveRequestInfo> ctx,\n                               base::Optional<std::string> canonical_name) {\n  bool did_match_rule = false;\n  bool did_match_exception = false;\n  bool did_match_important = false;\n  if (!ctx->initiator_url.is_valid()) {\n    return;\n  }\n  std::string source_host = ctx->initiator_url.host();\n\n  g_brave_browser_process->ad_block_service()->ShouldStartRequest(\n      ctx->request_url, ctx->resource_type, source_host, &did_match_rule,\n      &did_match_exception, &did_match_important, &ctx->mock_data_url);\n  if (did_match_important) {\n    ctx->blocked_by = kAdBlocked;\n    return;\n  }\n\n  if (canonical_name.has_value() &&\n      ctx->request_url.host() != *canonical_name && *canonical_name != \"\") {\n    GURL::Replacements replacements = GURL::Replacements();\n    replacements.SetHost(\n        canonical_name->c_str(),\n        url::Component(0, static_cast<int>(canonical_name->length())));\n    const GURL canonical_url = ctx->request_url.ReplaceComponents(replacements);\n\n    g_brave_browser_process->ad_block_service()->ShouldStartRequest(\n        ctx->request_url, ctx->resource_type, source_host, &did_match_rule,\n        &did_match_exception, &did_match_important, &ctx->mock_data_url);\n  }\n\n  if (did_match_important || (did_match_rule && !did_match_exception)) {\n    ctx->blocked_by = kAdBlocked;\n  }\n}\n\nvoid OnShouldBlockAdResult(const ResponseCallback& next_callback,\n                           std::shared_ptr<BraveRequestInfo> ctx) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  if (ctx->blocked_by == kAdBlocked) {\n    brave_shields::DispatchBlockedEvent(\n        ctx->request_url, ctx->render_frame_id, ctx->render_process_id,\n        ctx->frame_tree_node_id, brave_shields::kAds);\n  }\n  next_callback.Run();\n}\n\nvoid ShouldBlockAdWithOptionalCname(\n    scoped_refptr<base::SequencedTaskRunner> task_runner,\n    const ResponseCallback& next_callback,\n    std::shared_ptr<BraveRequestInfo> ctx,\n    const base::Optional<std::string> cname) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  task_runner->PostTaskAndReply(\n      FROM_HERE, base::BindOnce(&ShouldBlockAdOnTaskRunner, ctx, cname),\n      base::BindOnce(&OnShouldBlockAdResult, next_callback, ctx));\n}\n\nclass AdblockCnameResolveHostClient : public network::mojom::ResolveHostClient {\n private:\n  mojo::Receiver<network::mojom::ResolveHostClient> receiver_{this};\n  base::OnceCallback<void(base::Optional<std::string>)> cb_;\n  base::TimeTicks start_time_;\n\n public:\n  AdblockCnameResolveHostClient(\n      const ResponseCallback& next_callback,\n      scoped_refptr<base::SequencedTaskRunner> task_runner,\n      std::shared_ptr<BraveRequestInfo> ctx) {\n    cb_ = base::BindOnce(&ShouldBlockAdWithOptionalCname, task_runner,\n                         std::move(next_callback), ctx);\n\n    auto* web_contents = GetWebContents(\n        ctx->render_process_id, ctx->render_frame_id, ctx->frame_tree_node_id);\n    if (!web_contents) {\n      start_time_ = base::TimeTicks::Now();\n      this->OnComplete(net::ERR_FAILED, net::ResolveErrorInfo(), base::nullopt);\n      return;\n    }\n\n    content::BrowserContext* context = web_contents->GetBrowserContext();\n\n    const auto network_isolation_key = ctx->network_isolation_key;\n\n    network::mojom::ResolveHostParametersPtr optional_parameters =\n        network::mojom::ResolveHostParameters::New();\n    optional_parameters->include_canonical_name = true;\n    // Explicitly specify source to avoid using `HostResolverProc`\n    // which will be handled by system resolver\n    // See https://crbug.com/872665\n    optional_parameters->source = net::HostResolverSource::DNS;\n\n    network::mojom::NetworkContext* network_context =\n        content::BrowserContext::GetDefaultStoragePartition(context)\n            ->GetNetworkContext();\n\n    start_time_ = base::TimeTicks::Now();\n\n    network_context->ResolveHost(\n        net::HostPortPair::FromURL(ctx->request_url), network_isolation_key,\n        std::move(optional_parameters), receiver_.BindNewPipeAndPassRemote());\n\n    receiver_.set_disconnect_handler(\n        base::BindOnce(&AdblockCnameResolveHostClient::OnComplete,\n                       base::Unretained(this), net::ERR_NAME_NOT_RESOLVED,\n                       net::ResolveErrorInfo(net::ERR_FAILED), base::nullopt));\n  }\n\n  void OnComplete(\n      int32_t result,\n      const net::ResolveErrorInfo& resolve_error_info,\n      const base::Optional<net::AddressList>& resolved_addresses) override {\n    UMA_HISTOGRAM_TIMES(\"Brave.ShieldsCNAMEBlocking.TotalResolutionTime\",\n                        base::TimeTicks::Now() - start_time_);\n    if (result == net::OK && resolved_addresses) {\n      DCHECK(resolved_addresses.has_value() && !resolved_addresses->empty());\n      std::move(cb_).Run(\n          base::Optional<std::string>(resolved_addresses->canonical_name()));\n    } else {\n      std::move(cb_).Run(base::nullopt);\n    }\n\n    delete this;\n  }\n\n  // Should not be called\n  void OnTextResults(const std::vector<std::string>& text_results) override {\n    NOTREACHED();\n  }\n\n  // Should not be called\n  void OnHostnameResults(const std::vector<net::HostPortPair>& hosts) override {\n    NOTREACHED();\n  }\n};\n\nvoid OnBeforeURLRequestAdBlockTP(const ResponseCallback& next_callback,\n                                 std::shared_ptr<BraveRequestInfo> ctx) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  // If the following info isn't available, then proper content settings can't\n  // be looked up, so do nothing.\n  if (ctx->tab_origin.is_empty() || !ctx->tab_origin.has_host() ||\n      ctx->request_url.is_empty()) {\n    return;\n  }\n  DCHECK_NE(ctx->request_identifier, 0UL);\n\n  scoped_refptr<base::SequencedTaskRunner> task_runner =\n      g_brave_browser_process->ad_block_service()->GetTaskRunner();\n\n  DCHECK(ctx->browser_context);\n  // DoH or standard DNS quries won't be routed through Tor, so we need to skip\n  // it.\n  if (ctx->browser_context->IsTor()) {\n    ShouldBlockAdWithOptionalCname(task_runner, std::move(next_callback), ctx,\n                                   base::nullopt);\n  } else {\n    new AdblockCnameResolveHostClient(std::move(next_callback), task_runner,\n                                      ctx);\n  }\n}\n\nint OnBeforeURLRequest_AdBlockTPPreWork(const ResponseCallback& next_callback,\n                                        std::shared_ptr<BraveRequestInfo> ctx) {\n  if (ctx->request_url.is_empty()) {\n    return net::OK;\n  }\n\n  // If the following info isn't available, then proper content settings can't\n  // be looked up, so do nothing.\n  if (ctx->tab_origin.is_empty() || !ctx->allow_brave_shields ||\n      ctx->allow_ads ||\n      ctx->resource_type == BraveRequestInfo::kInvalidResourceType) {\n    return net::OK;\n  }\n\n  OnBeforeURLRequestAdBlockTP(next_callback, ctx);\n\n  return net::ERR_IO_PENDING;\n}\n\n}  // namespace brave\n"], "filenames": ["browser/net/BUILD.gn", "browser/net/brave_ad_block_tp_network_delegate_helper.cc"], "buggy_code_start_loc": [56, 68], "buggy_code_end_loc": [94, 210], "fixing_code_start_loc": [57, 68], "fixing_code_end_loc": [92, 217], "type": "CWE-200", "message": "Brave is an open source web browser with a focus on privacy and security. In Brave versions 1.17.73-1.20.103, the CNAME adblocking feature added in Brave 1.17.73 accidentally initiated DNS requests that bypassed the Brave Tor proxy. Users with adblocking enabled would leak DNS requests from Tor windows to their DNS provider. (DNS requests that were not initiated by CNAME adblocking would go through Tor as expected.) This is fixed in Brave version 1.20.108", "other": {"cve": {"id": "CVE-2021-21323", "sourceIdentifier": "security-advisories@github.com", "published": "2021-02-23T23:15:13.317", "lastModified": "2021-03-01T16:14:07.370", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Brave is an open source web browser with a focus on privacy and security. In Brave versions 1.17.73-1.20.103, the CNAME adblocking feature added in Brave 1.17.73 accidentally initiated DNS requests that bypassed the Brave Tor proxy. Users with adblocking enabled would leak DNS requests from Tor windows to their DNS provider. (DNS requests that were not initiated by CNAME adblocking would go through Tor as expected.) This is fixed in Brave version 1.20.108"}, {"lang": "es", "value": "Brave es un navegador web de c\u00f3digo abierto que se centra en la privacidad y la seguridad.&#xa0;En Brave versiones 1.17.73-1.20.103, la funcionalidad CNAME adblocking agregada en Brave versi\u00f3n 1.17.73, inici\u00f3 accidentalmente peticiones de DNS que omitieron el proxy Brave Tor.&#xa0;Los usuarios con adblocking habilitado filtrar\u00edan las peticiones DNS de las ventanas Tor a su proveedor de DNS.&#xa0;(Las peticiones DNS que no fueron iniciadas por el CNAME adblocking pasar\u00edan por Tor como se esperaba). Esto se corrigi\u00f3 en Brave versi\u00f3n 1.20.108"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:brave:brave:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.17.73", "versionEndIncluding": "1.20.103", "matchCriteriaId": "AD17A757-9D61-4E54-849D-AD603B5001F3"}]}]}], "references": [{"url": "https://github.com/brave/brave-browser/issues/13527", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/brave/brave-browser/security/advisories/GHSA-mqjf-9x5g-2rv6", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/brave/brave-core/commit/12fe321eaad8acc1cbd1d70b4128f687777bcf15", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/brave/brave-core/pull/7769", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/1077022", "source": "security-advisories@github.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/brave/brave-core/commit/12fe321eaad8acc1cbd1d70b4128f687777bcf15"}}