{"buggy_code": ["/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_RMAP_H\n#define _LINUX_RMAP_H\n/*\n * Declarations for Reverse Mapping functions in mm/rmap.c\n */\n\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/rwsem.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n\n/*\n * The anon_vma heads a list of private \"related\" vmas, to scan if\n * an anonymous page pointing to this anon_vma needs to be unmapped:\n * the vmas on the list will be related by forking, or by splitting.\n *\n * Since vmas come and go as they are split and merged (particularly\n * in mprotect), the mapping field of an anonymous page cannot point\n * directly to a vma: instead it points to an anon_vma, on whose list\n * the related vmas can be easily linked or unlinked.\n *\n * After unlinking the last vma on the list, we must garbage collect\n * the anon_vma object itself: we're guaranteed no page can be\n * pointing to this anon_vma once its vma list is empty.\n */\nstruct anon_vma {\n\tstruct anon_vma *root;\t\t/* Root of this anon_vma tree */\n\tstruct rw_semaphore rwsem;\t/* W: modification, R: walking the list */\n\t/*\n\t * The refcount is taken on an anon_vma when there is no\n\t * guarantee that the vma of page tables will exist for\n\t * the duration of the operation. A caller that takes\n\t * the reference is responsible for clearing up the\n\t * anon_vma if they are the last user on release\n\t */\n\tatomic_t refcount;\n\n\t/*\n\t * Count of child anon_vmas and VMAs which points to this anon_vma.\n\t *\n\t * This counter is used for making decision about reusing anon_vma\n\t * instead of forking new one. See comments in function anon_vma_clone.\n\t */\n\tunsigned degree;\n\n\tstruct anon_vma *parent;\t/* Parent of this anon_vma */\n\n\t/*\n\t * NOTE: the LSB of the rb_root.rb_node is set by\n\t * mm_take_all_locks() _after_ taking the above lock. So the\n\t * rb_root must only be read/written after taking the above lock\n\t * to be sure to see a valid next pointer. The LSB bit itself\n\t * is serialized by a system wide lock only visible to\n\t * mm_take_all_locks() (mm_all_locks_mutex).\n\t */\n\n\t/* Interval tree of private \"related\" vmas */\n\tstruct rb_root_cached rb_root;\n};\n\n/*\n * The copy-on-write semantics of fork mean that an anon_vma\n * can become associated with multiple processes. Furthermore,\n * each child process will have its own anon_vma, where new\n * pages for that process are instantiated.\n *\n * This structure allows us to find the anon_vmas associated\n * with a VMA, or the VMAs associated with an anon_vma.\n * The \"same_vma\" list contains the anon_vma_chains linking\n * all the anon_vmas associated with this VMA.\n * The \"rb\" field indexes on an interval tree the anon_vma_chains\n * which link all the VMAs associated with this anon_vma.\n */\nstruct anon_vma_chain {\n\tstruct vm_area_struct *vma;\n\tstruct anon_vma *anon_vma;\n\tstruct list_head same_vma;   /* locked by mmap_lock & page_table_lock */\n\tstruct rb_node rb;\t\t\t/* locked by anon_vma->rwsem */\n\tunsigned long rb_subtree_last;\n#ifdef CONFIG_DEBUG_VM_RB\n\tunsigned long cached_vma_start, cached_vma_last;\n#endif\n};\n\nenum ttu_flags {\n\tTTU_SPLIT_HUGE_PMD\t= 0x4,\t/* split huge PMD if any */\n\tTTU_IGNORE_MLOCK\t= 0x8,\t/* ignore mlock */\n\tTTU_SYNC\t\t= 0x10,\t/* avoid racy checks with PVMW_SYNC */\n\tTTU_IGNORE_HWPOISON\t= 0x20,\t/* corrupted page is recoverable */\n\tTTU_BATCH_FLUSH\t\t= 0x40,\t/* Batch TLB flushes where possible\n\t\t\t\t\t * and caller guarantees they will\n\t\t\t\t\t * do a final flush if necessary */\n\tTTU_RMAP_LOCKED\t\t= 0x80,\t/* do not grab rmap lock:\n\t\t\t\t\t * caller holds it */\n};\n\n#ifdef CONFIG_MMU\nstatic inline void get_anon_vma(struct anon_vma *anon_vma)\n{\n\tatomic_inc(&anon_vma->refcount);\n}\n\nvoid __put_anon_vma(struct anon_vma *anon_vma);\n\nstatic inline void put_anon_vma(struct anon_vma *anon_vma)\n{\n\tif (atomic_dec_and_test(&anon_vma->refcount))\n\t\t__put_anon_vma(anon_vma);\n}\n\nstatic inline void anon_vma_lock_write(struct anon_vma *anon_vma)\n{\n\tdown_write(&anon_vma->root->rwsem);\n}\n\nstatic inline void anon_vma_unlock_write(struct anon_vma *anon_vma)\n{\n\tup_write(&anon_vma->root->rwsem);\n}\n\nstatic inline void anon_vma_lock_read(struct anon_vma *anon_vma)\n{\n\tdown_read(&anon_vma->root->rwsem);\n}\n\nstatic inline int anon_vma_trylock_read(struct anon_vma *anon_vma)\n{\n\treturn down_read_trylock(&anon_vma->root->rwsem);\n}\n\nstatic inline void anon_vma_unlock_read(struct anon_vma *anon_vma)\n{\n\tup_read(&anon_vma->root->rwsem);\n}\n\n\n/*\n * anon_vma helper functions.\n */\nvoid anon_vma_init(void);\t/* create anon_vma_cachep */\nint  __anon_vma_prepare(struct vm_area_struct *);\nvoid unlink_anon_vmas(struct vm_area_struct *);\nint anon_vma_clone(struct vm_area_struct *, struct vm_area_struct *);\nint anon_vma_fork(struct vm_area_struct *, struct vm_area_struct *);\n\nstatic inline int anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tif (likely(vma->anon_vma))\n\t\treturn 0;\n\n\treturn __anon_vma_prepare(vma);\n}\n\nstatic inline void anon_vma_merge(struct vm_area_struct *vma,\n\t\t\t\t  struct vm_area_struct *next)\n{\n\tVM_BUG_ON_VMA(vma->anon_vma != next->anon_vma, vma);\n\tunlink_anon_vmas(next);\n}\n\nstruct anon_vma *page_get_anon_vma(struct page *page);\n\n/* RMAP flags, currently only relevant for some anon rmap operations. */\ntypedef int __bitwise rmap_t;\n\n/*\n * No special request: if the page is a subpage of a compound page, it is\n * mapped via a PTE. The mapped (sub)page is possibly shared between processes.\n */\n#define RMAP_NONE\t\t((__force rmap_t)0)\n\n/* The (sub)page is exclusive to a single process. */\n#define RMAP_EXCLUSIVE\t\t((__force rmap_t)BIT(0))\n\n/*\n * The compound page is not mapped via PTEs, but instead via a single PMD and\n * should be accounted accordingly.\n */\n#define RMAP_COMPOUND\t\t((__force rmap_t)BIT(1))\n\n/*\n * rmap interfaces called when adding or removing pte of page\n */\nvoid page_move_anon_rmap(struct page *, struct vm_area_struct *);\nvoid page_add_anon_rmap(struct page *, struct vm_area_struct *,\n\t\tunsigned long address, rmap_t flags);\nvoid page_add_new_anon_rmap(struct page *, struct vm_area_struct *,\n\t\tunsigned long address);\nvoid page_add_file_rmap(struct page *, struct vm_area_struct *,\n\t\tbool compound);\nvoid page_remove_rmap(struct page *, struct vm_area_struct *,\n\t\tbool compound);\n\nvoid hugepage_add_anon_rmap(struct page *, struct vm_area_struct *,\n\t\tunsigned long address, rmap_t flags);\nvoid hugepage_add_new_anon_rmap(struct page *, struct vm_area_struct *,\n\t\tunsigned long address);\n\nstatic inline void __page_dup_rmap(struct page *page, bool compound)\n{\n\tatomic_inc(compound ? compound_mapcount_ptr(page) : &page->_mapcount);\n}\n\nstatic inline void page_dup_file_rmap(struct page *page, bool compound)\n{\n\t__page_dup_rmap(page, compound);\n}\n\n/**\n * page_try_dup_anon_rmap - try duplicating a mapping of an already mapped\n *\t\t\t    anonymous page\n * @page: the page to duplicate the mapping for\n * @compound: the page is mapped as compound or as a small page\n * @vma: the source vma\n *\n * The caller needs to hold the PT lock and the vma->vma_mm->write_protect_seq.\n *\n * Duplicating the mapping can only fail if the page may be pinned; device\n * private pages cannot get pinned and consequently this function cannot fail.\n *\n * If duplicating the mapping succeeds, the page has to be mapped R/O into\n * the parent and the child. It must *not* get mapped writable after this call.\n *\n * Returns 0 if duplicating the mapping succeeded. Returns -EBUSY otherwise.\n */\nstatic inline int page_try_dup_anon_rmap(struct page *page, bool compound,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(!PageAnon(page), page);\n\n\t/*\n\t * No need to check+clear for already shared pages, including KSM\n\t * pages.\n\t */\n\tif (!PageAnonExclusive(page))\n\t\tgoto dup;\n\n\t/*\n\t * If this page may have been pinned by the parent process,\n\t * don't allow to duplicate the mapping but instead require to e.g.,\n\t * copy the page immediately for the child so that we'll always\n\t * guarantee the pinned page won't be randomly replaced in the\n\t * future on write faults.\n\t */\n\tif (likely(!is_device_private_page(page) &&\n\t    unlikely(page_needs_cow_for_dma(vma, page))))\n\t\treturn -EBUSY;\n\n\tClearPageAnonExclusive(page);\n\t/*\n\t * It's okay to share the anon page between both processes, mapping\n\t * the page R/O into both processes.\n\t */\ndup:\n\t__page_dup_rmap(page, compound);\n\treturn 0;\n}\n\n/**\n * page_try_share_anon_rmap - try marking an exclusive anonymous page possibly\n *\t\t\t      shared to prepare for KSM or temporary unmapping\n * @page: the exclusive anonymous page to try marking possibly shared\n *\n * The caller needs to hold the PT lock and has to have the page table entry\n * cleared/invalidated+flushed, to properly sync against GUP-fast.\n *\n * This is similar to page_try_dup_anon_rmap(), however, not used during fork()\n * to duplicate a mapping, but instead to prepare for KSM or temporarily\n * unmapping a page (swap, migration) via page_remove_rmap().\n *\n * Marking the page shared can only fail if the page may be pinned; device\n * private pages cannot get pinned and consequently this function cannot fail.\n *\n * Returns 0 if marking the page possibly shared succeeded. Returns -EBUSY\n * otherwise.\n */\nstatic inline int page_try_share_anon_rmap(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageAnon(page) || !PageAnonExclusive(page), page);\n\n\t/* See page_try_dup_anon_rmap(). */\n\tif (likely(!is_device_private_page(page) &&\n\t    unlikely(page_maybe_dma_pinned(page))))\n\t\treturn -EBUSY;\n\n\tClearPageAnonExclusive(page);\n\treturn 0;\n}\n\n/*\n * Called from mm/vmscan.c to handle paging out\n */\nint folio_referenced(struct folio *, int is_locked,\n\t\t\tstruct mem_cgroup *memcg, unsigned long *vm_flags);\n\nvoid try_to_migrate(struct folio *folio, enum ttu_flags flags);\nvoid try_to_unmap(struct folio *, enum ttu_flags flags);\n\nint make_device_exclusive_range(struct mm_struct *mm, unsigned long start,\n\t\t\t\tunsigned long end, struct page **pages,\n\t\t\t\tvoid *arg);\n\n/* Avoid racy checks */\n#define PVMW_SYNC\t\t(1 << 0)\n/* Look for migration entries rather than present PTEs */\n#define PVMW_MIGRATION\t\t(1 << 1)\n\nstruct page_vma_mapped_walk {\n\tunsigned long pfn;\n\tunsigned long nr_pages;\n\tpgoff_t pgoff;\n\tstruct vm_area_struct *vma;\n\tunsigned long address;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\tunsigned int flags;\n};\n\n#define DEFINE_PAGE_VMA_WALK(name, _page, _vma, _address, _flags)\t\\\n\tstruct page_vma_mapped_walk name = {\t\t\t\t\\\n\t\t.pfn = page_to_pfn(_page),\t\t\t\t\\\n\t\t.nr_pages = compound_nr(_page),\t\t\t\t\\\n\t\t.pgoff = page_to_pgoff(_page),\t\t\t\t\\\n\t\t.vma = _vma,\t\t\t\t\t\t\\\n\t\t.address = _address,\t\t\t\t\t\\\n\t\t.flags = _flags,\t\t\t\t\t\\\n\t}\n\n#define DEFINE_FOLIO_VMA_WALK(name, _folio, _vma, _address, _flags)\t\\\n\tstruct page_vma_mapped_walk name = {\t\t\t\t\\\n\t\t.pfn = folio_pfn(_folio),\t\t\t\t\\\n\t\t.nr_pages = folio_nr_pages(_folio),\t\t\t\\\n\t\t.pgoff = folio_pgoff(_folio),\t\t\t\t\\\n\t\t.vma = _vma,\t\t\t\t\t\t\\\n\t\t.address = _address,\t\t\t\t\t\\\n\t\t.flags = _flags,\t\t\t\t\t\\\n\t}\n\nstatic inline void page_vma_mapped_walk_done(struct page_vma_mapped_walk *pvmw)\n{\n\t/* HugeTLB pte is set to the relevant page table entry without pte_mapped. */\n\tif (pvmw->pte && !is_vm_hugetlb_page(pvmw->vma))\n\t\tpte_unmap(pvmw->pte);\n\tif (pvmw->ptl)\n\t\tspin_unlock(pvmw->ptl);\n}\n\nbool page_vma_mapped_walk(struct page_vma_mapped_walk *pvmw);\n\n/*\n * Used by swapoff to help locate where page is expected in vma.\n */\nunsigned long page_address_in_vma(struct page *, struct vm_area_struct *);\n\n/*\n * Cleans the PTEs of shared mappings.\n * (and since clean PTEs should also be readonly, write protects them too)\n *\n * returns the number of cleaned PTEs.\n */\nint folio_mkclean(struct folio *);\n\nint pfn_mkclean_range(unsigned long pfn, unsigned long nr_pages, pgoff_t pgoff,\n\t\t      struct vm_area_struct *vma);\n\nvoid remove_migration_ptes(struct folio *src, struct folio *dst, bool locked);\n\nint page_mapped_in_vma(struct page *page, struct vm_area_struct *vma);\n\n/*\n * rmap_walk_control: To control rmap traversing for specific needs\n *\n * arg: passed to rmap_one() and invalid_vma()\n * try_lock: bail out if the rmap lock is contended\n * contended: indicate the rmap traversal bailed out due to lock contention\n * rmap_one: executed on each vma where page is mapped\n * done: for checking traversing termination condition\n * anon_lock: for getting anon_lock by optimized way rather than default\n * invalid_vma: for skipping uninterested vma\n */\nstruct rmap_walk_control {\n\tvoid *arg;\n\tbool try_lock;\n\tbool contended;\n\t/*\n\t * Return false if page table scanning in rmap_walk should be stopped.\n\t * Otherwise, return true.\n\t */\n\tbool (*rmap_one)(struct folio *folio, struct vm_area_struct *vma,\n\t\t\t\t\tunsigned long addr, void *arg);\n\tint (*done)(struct folio *folio);\n\tstruct anon_vma *(*anon_lock)(struct folio *folio,\n\t\t\t\t      struct rmap_walk_control *rwc);\n\tbool (*invalid_vma)(struct vm_area_struct *vma, void *arg);\n};\n\nvoid rmap_walk(struct folio *folio, struct rmap_walk_control *rwc);\nvoid rmap_walk_locked(struct folio *folio, struct rmap_walk_control *rwc);\n\n/*\n * Called by memory-failure.c to kill processes.\n */\nstruct anon_vma *folio_lock_anon_vma_read(struct folio *folio,\n\t\t\t\t\t  struct rmap_walk_control *rwc);\nvoid page_unlock_anon_vma_read(struct anon_vma *anon_vma);\n\n#else\t/* !CONFIG_MMU */\n\n#define anon_vma_init()\t\tdo {} while (0)\n#define anon_vma_prepare(vma)\t(0)\n#define anon_vma_link(vma)\tdo {} while (0)\n\nstatic inline int folio_referenced(struct folio *folio, int is_locked,\n\t\t\t\t  struct mem_cgroup *memcg,\n\t\t\t\t  unsigned long *vm_flags)\n{\n\t*vm_flags = 0;\n\treturn 0;\n}\n\nstatic inline void try_to_unmap(struct folio *folio, enum ttu_flags flags)\n{\n}\n\nstatic inline int folio_mkclean(struct folio *folio)\n{\n\treturn 0;\n}\n#endif\t/* CONFIG_MMU */\n\nstatic inline int page_mkclean(struct page *page)\n{\n\treturn folio_mkclean(page_folio(page));\n}\n#endif\t/* _LINUX_RMAP_H */\n", "/*\n * mm/rmap.c - physical to virtual reverse mappings\n *\n * Copyright 2001, Rik van Riel <riel@conectiva.com.br>\n * Released under the General Public License (GPL).\n *\n * Simple, low overhead reverse mapping scheme.\n * Please try to keep this thing as modular as possible.\n *\n * Provides methods for unmapping each kind of mapped page:\n * the anon methods track anonymous pages, and\n * the file methods track pages belonging to an inode.\n *\n * Original design by Rik van Riel <riel@conectiva.com.br> 2001\n * File methods by Dave McCracken <dmccr@us.ibm.com> 2003, 2004\n * Anonymous methods by Andrea Arcangeli <andrea@suse.de> 2004\n * Contributions by Hugh Dickins 2003, 2004\n */\n\n/*\n * Lock ordering in mm:\n *\n * inode->i_rwsem\t(while writing or truncating, not reading or faulting)\n *   mm->mmap_lock\n *     mapping->invalidate_lock (in filemap_fault)\n *       page->flags PG_locked (lock_page)   * (see hugetlbfs below)\n *         hugetlbfs_i_mmap_rwsem_key (in huge_pmd_share)\n *           mapping->i_mmap_rwsem\n *             hugetlb_fault_mutex (hugetlbfs specific page fault mutex)\n *             anon_vma->rwsem\n *               mm->page_table_lock or pte_lock\n *                 swap_lock (in swap_duplicate, swap_info_get)\n *                   mmlist_lock (in mmput, drain_mmlist and others)\n *                   mapping->private_lock (in block_dirty_folio)\n *                     folio_lock_memcg move_lock (in block_dirty_folio)\n *                       i_pages lock (widely used)\n *                         lruvec->lru_lock (in folio_lruvec_lock_irq)\n *                   inode->i_lock (in set_page_dirty's __mark_inode_dirty)\n *                   bdi.wb->list_lock (in set_page_dirty's __mark_inode_dirty)\n *                     sb_lock (within inode_lock in fs/fs-writeback.c)\n *                     i_pages lock (widely used, in set_page_dirty,\n *                               in arch-dependent flush_dcache_mmap_lock,\n *                               within bdi.wb->list_lock in __sync_single_inode)\n *\n * anon_vma->rwsem,mapping->i_mmap_rwsem   (memory_failure, collect_procs_anon)\n *   ->tasklist_lock\n *     pte map lock\n *\n * * hugetlbfs PageHuge() pages take locks in this order:\n *         mapping->i_mmap_rwsem\n *           hugetlb_fault_mutex (hugetlbfs specific page fault mutex)\n *             page->flags PG_locked (lock_page)\n */\n\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/memcontrol.h>\n#include <linux/mmu_notifier.h>\n#include <linux/migrate.h>\n#include <linux/hugetlb.h>\n#include <linux/huge_mm.h>\n#include <linux/backing-dev.h>\n#include <linux/page_idle.h>\n#include <linux/memremap.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm_inline.h>\n\n#include <asm/tlbflush.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/tlb.h>\n#include <trace/events/migrate.h>\n\n#include \"internal.h\"\n\nstatic struct kmem_cache *anon_vma_cachep;\nstatic struct kmem_cache *anon_vma_chain_cachep;\n\nstatic inline struct anon_vma *anon_vma_alloc(void)\n{\n\tstruct anon_vma *anon_vma;\n\n\tanon_vma = kmem_cache_alloc(anon_vma_cachep, GFP_KERNEL);\n\tif (anon_vma) {\n\t\tatomic_set(&anon_vma->refcount, 1);\n\t\tanon_vma->degree = 1;\t/* Reference for first vma */\n\t\tanon_vma->parent = anon_vma;\n\t\t/*\n\t\t * Initialise the anon_vma root to point to itself. If called\n\t\t * from fork, the root will be reset to the parents anon_vma.\n\t\t */\n\t\tanon_vma->root = anon_vma;\n\t}\n\n\treturn anon_vma;\n}\n\nstatic inline void anon_vma_free(struct anon_vma *anon_vma)\n{\n\tVM_BUG_ON(atomic_read(&anon_vma->refcount));\n\n\t/*\n\t * Synchronize against folio_lock_anon_vma_read() such that\n\t * we can safely hold the lock without the anon_vma getting\n\t * freed.\n\t *\n\t * Relies on the full mb implied by the atomic_dec_and_test() from\n\t * put_anon_vma() against the acquire barrier implied by\n\t * down_read_trylock() from folio_lock_anon_vma_read(). This orders:\n\t *\n\t * folio_lock_anon_vma_read()\tVS\tput_anon_vma()\n\t *   down_read_trylock()\t\t  atomic_dec_and_test()\n\t *   LOCK\t\t\t\t  MB\n\t *   atomic_read()\t\t\t  rwsem_is_locked()\n\t *\n\t * LOCK should suffice since the actual taking of the lock must\n\t * happen _before_ what follows.\n\t */\n\tmight_sleep();\n\tif (rwsem_is_locked(&anon_vma->root->rwsem)) {\n\t\tanon_vma_lock_write(anon_vma);\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n\n\tkmem_cache_free(anon_vma_cachep, anon_vma);\n}\n\nstatic inline struct anon_vma_chain *anon_vma_chain_alloc(gfp_t gfp)\n{\n\treturn kmem_cache_alloc(anon_vma_chain_cachep, gfp);\n}\n\nstatic void anon_vma_chain_free(struct anon_vma_chain *anon_vma_chain)\n{\n\tkmem_cache_free(anon_vma_chain_cachep, anon_vma_chain);\n}\n\nstatic void anon_vma_chain_link(struct vm_area_struct *vma,\n\t\t\t\tstruct anon_vma_chain *avc,\n\t\t\t\tstruct anon_vma *anon_vma)\n{\n\tavc->vma = vma;\n\tavc->anon_vma = anon_vma;\n\tlist_add(&avc->same_vma, &vma->anon_vma_chain);\n\tanon_vma_interval_tree_insert(avc, &anon_vma->rb_root);\n}\n\n/**\n * __anon_vma_prepare - attach an anon_vma to a memory region\n * @vma: the memory region in question\n *\n * This makes sure the memory mapping described by 'vma' has\n * an 'anon_vma' attached to it, so that we can associate the\n * anonymous pages mapped into it with that anon_vma.\n *\n * The common case will be that we already have one, which\n * is handled inline by anon_vma_prepare(). But if\n * not we either need to find an adjacent mapping that we\n * can re-use the anon_vma from (very common when the only\n * reason for splitting a vma has been mprotect()), or we\n * allocate a new one.\n *\n * Anon-vma allocations are very subtle, because we may have\n * optimistically looked up an anon_vma in folio_lock_anon_vma_read()\n * and that may actually touch the rwsem even in the newly\n * allocated vma (it depends on RCU to make sure that the\n * anon_vma isn't actually destroyed).\n *\n * As a result, we need to do proper anon_vma locking even\n * for the new allocation. At the same time, we do not want\n * to do any locking for the common case of already having\n * an anon_vma.\n *\n * This must be called with the mmap_lock held for reading.\n */\nint __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}\n\n/*\n * This is a useful helper function for locking the anon_vma root as\n * we traverse the vma->anon_vma_chain, looping over anon_vma's that\n * have the same vma.\n *\n * Such anon_vma's should have the same root, so you'd expect to see\n * just a single mutex_lock for the whole traversal.\n */\nstatic inline struct anon_vma *lock_anon_vma_root(struct anon_vma *root, struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *new_root = anon_vma->root;\n\tif (new_root != root) {\n\t\tif (WARN_ON_ONCE(root))\n\t\t\tup_write(&root->rwsem);\n\t\troot = new_root;\n\t\tdown_write(&root->rwsem);\n\t}\n\treturn root;\n}\n\nstatic inline void unlock_anon_vma_root(struct anon_vma *root)\n{\n\tif (root)\n\t\tup_write(&root->rwsem);\n}\n\n/*\n * Attach the anon_vmas from src to dst.\n * Returns 0 on success, -ENOMEM on failure.\n *\n * anon_vma_clone() is called by __vma_adjust(), __split_vma(), copy_vma() and\n * anon_vma_fork(). The first three want an exact copy of src, while the last\n * one, anon_vma_fork(), may try to reuse an existing anon_vma to prevent\n * endless growth of anon_vma. Since dst->anon_vma is set to NULL before call,\n * we can identify this case by checking (!dst->anon_vma && src->anon_vma).\n *\n * If (!dst->anon_vma && src->anon_vma) is true, this function tries to find\n * and reuse existing anon_vma which has no vmas and only one child anon_vma.\n * This prevents degradation of anon_vma hierarchy to endless linear chain in\n * case of constantly forking task. On the other hand, an anon_vma with more\n * than one child isn't reused even if there was no alive vma, thus rmap\n * walker has a good chance of avoiding scanning the whole hierarchy when it\n * searches where page is mapped.\n */\nint anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n\tstruct anon_vma_chain *avc, *pavc;\n\tstruct anon_vma *root = NULL;\n\n\tlist_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma;\n\n\t\tavc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!avc)) {\n\t\t\tunlock_anon_vma_root(root);\n\t\t\troot = NULL;\n\t\t\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\t\t\tif (!avc)\n\t\t\t\tgoto enomem_failure;\n\t\t}\n\t\tanon_vma = pavc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_chain_link(dst, avc, anon_vma);\n\n\t\t/*\n\t\t * Reuse existing anon_vma if its degree lower than two,\n\t\t * that means it has no vma and only one anon_vma child.\n\t\t *\n\t\t * Do not choose parent anon_vma, otherwise first child\n\t\t * will always reuse it. Root anon_vma is never reused:\n\t\t * it has self-parent reference and at least one child.\n\t\t */\n\t\tif (!dst->anon_vma && src->anon_vma &&\n\t\t    anon_vma != src->anon_vma && anon_vma->degree < 2)\n\t\t\tdst->anon_vma = anon_vma;\n\t}\n\tif (dst->anon_vma)\n\t\tdst->anon_vma->degree++;\n\tunlock_anon_vma_root(root);\n\treturn 0;\n\n enomem_failure:\n\t/*\n\t * dst->anon_vma is dropped here otherwise its degree can be incorrectly\n\t * decremented in unlink_anon_vmas().\n\t * We can safely do this because callers of anon_vma_clone() don't care\n\t * about dst->anon_vma if anon_vma_clone() failed.\n\t */\n\tdst->anon_vma = NULL;\n\tunlink_anon_vmas(dst);\n\treturn -ENOMEM;\n}\n\n/*\n * Attach vma to its own anon_vma, as well as to the anon_vmas that\n * the corresponding VMA in the parent process is attached to.\n * Returns 0 on success, non-zero on failure.\n */\nint anon_vma_fork(struct vm_area_struct *vma, struct vm_area_struct *pvma)\n{\n\tstruct anon_vma_chain *avc;\n\tstruct anon_vma *anon_vma;\n\tint error;\n\n\t/* Don't bother if the parent process has no anon_vma here. */\n\tif (!pvma->anon_vma)\n\t\treturn 0;\n\n\t/* Drop inherited anon_vma, we'll reuse existing or allocate new. */\n\tvma->anon_vma = NULL;\n\n\t/*\n\t * First, attach the new VMA to the parent VMA's anon_vmas,\n\t * so rmap can find non-COWed pages in child processes.\n\t */\n\terror = anon_vma_clone(vma, pvma);\n\tif (error)\n\t\treturn error;\n\n\t/* An existing anon_vma has been reused, all done then. */\n\tif (vma->anon_vma)\n\t\treturn 0;\n\n\t/* Then add our own anon_vma. */\n\tanon_vma = anon_vma_alloc();\n\tif (!anon_vma)\n\t\tgoto out_error;\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_error_free_anon_vma;\n\n\t/*\n\t * The root anon_vma's rwsem is the lock actually used when we\n\t * lock any of the anon_vmas in this anon_vma tree.\n\t */\n\tanon_vma->root = pvma->anon_vma->root;\n\tanon_vma->parent = pvma->anon_vma;\n\t/*\n\t * With refcounts, an anon_vma can stay around longer than the\n\t * process it belongs to. The root anon_vma needs to be pinned until\n\t * this anon_vma is freed, because the lock lives in the root.\n\t */\n\tget_anon_vma(anon_vma->root);\n\t/* Mark this anon_vma as the one where our new (COWed) pages go. */\n\tvma->anon_vma = anon_vma;\n\tanon_vma_lock_write(anon_vma);\n\tanon_vma_chain_link(vma, avc, anon_vma);\n\tanon_vma->parent->degree++;\n\tanon_vma_unlock_write(anon_vma);\n\n\treturn 0;\n\n out_error_free_anon_vma:\n\tput_anon_vma(anon_vma);\n out_error:\n\tunlink_anon_vmas(vma);\n\treturn -ENOMEM;\n}\n\nvoid unlink_anon_vmas(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc, *next;\n\tstruct anon_vma *root = NULL;\n\n\t/*\n\t * Unlink each anon_vma chained to the VMA.  This list is ordered\n\t * from newest to oldest, ensuring the root anon_vma gets freed last.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_interval_tree_remove(avc, &anon_vma->rb_root);\n\n\t\t/*\n\t\t * Leave empty anon_vmas on the list - we'll need\n\t\t * to free them outside the lock.\n\t\t */\n\t\tif (RB_EMPTY_ROOT(&anon_vma->rb_root.rb_root)) {\n\t\t\tanon_vma->parent->degree--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n\tif (vma->anon_vma) {\n\t\tvma->anon_vma->degree--;\n\n\t\t/*\n\t\t * vma would still be needed after unlink, and anon_vma will be prepared\n\t\t * when handle fault.\n\t\t */\n\t\tvma->anon_vma = NULL;\n\t}\n\tunlock_anon_vma_root(root);\n\n\t/*\n\t * Iterate the list once more, it now only contains empty and unlinked\n\t * anon_vmas, destroy them. Could not do before due to __put_anon_vma()\n\t * needing to write-acquire the anon_vma->root->rwsem.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\tVM_WARN_ON(anon_vma->degree);\n\t\tput_anon_vma(anon_vma);\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n}\n\nstatic void anon_vma_ctor(void *data)\n{\n\tstruct anon_vma *anon_vma = data;\n\n\tinit_rwsem(&anon_vma->rwsem);\n\tatomic_set(&anon_vma->refcount, 0);\n\tanon_vma->rb_root = RB_ROOT_CACHED;\n}\n\nvoid __init anon_vma_init(void)\n{\n\tanon_vma_cachep = kmem_cache_create(\"anon_vma\", sizeof(struct anon_vma),\n\t\t\t0, SLAB_TYPESAFE_BY_RCU|SLAB_PANIC|SLAB_ACCOUNT,\n\t\t\tanon_vma_ctor);\n\tanon_vma_chain_cachep = KMEM_CACHE(anon_vma_chain,\n\t\t\tSLAB_PANIC|SLAB_ACCOUNT);\n}\n\n/*\n * Getting a lock on a stable anon_vma from a page off the LRU is tricky!\n *\n * Since there is no serialization what so ever against page_remove_rmap()\n * the best this function can do is return a refcount increased anon_vma\n * that might have been relevant to this page.\n *\n * The page might have been remapped to a different anon_vma or the anon_vma\n * returned may already be freed (and even reused).\n *\n * In case it was remapped to a different anon_vma, the new anon_vma will be a\n * child of the old anon_vma, and the anon_vma lifetime rules will therefore\n * ensure that any anon_vma obtained from the page will still be valid for as\n * long as we observe page_mapped() [ hence all those page_mapped() tests ].\n *\n * All users of this function must be very careful when walking the anon_vma\n * chain and verify that the page in question is indeed mapped in it\n * [ something equivalent to page_mapped_in_vma() ].\n *\n * Since anon_vma's slab is SLAB_TYPESAFE_BY_RCU and we know from\n * page_remove_rmap() that the anon_vma pointer from page->mapping is valid\n * if there is a mapcount, we can dereference the anon_vma after observing\n * those.\n */\nstruct anon_vma *page_get_anon_vma(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this page is still mapped, then its anon_vma cannot have been\n\t * freed.  But if it has been unmapped, we have no security against the\n\t * anon_vma structure being freed and reused (for another anon_vma:\n\t * SLAB_TYPESAFE_BY_RCU guarantees that - so the atomic_inc_not_zero()\n\t * above cannot corrupt).\n\t */\n\tif (!page_mapped(page)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn anon_vma;\n}\n\n/*\n * Similar to page_get_anon_vma() except it locks the anon_vma.\n *\n * Its a little more complex as it tries to keep the fast path to a single\n * atomic op -- the trylock. If we fail the trylock, we fall back to getting a\n * reference like with page_get_anon_vma() and then block on the mutex\n * on !rwc->try_lock case.\n */\nstruct anon_vma *folio_lock_anon_vma_read(struct folio *folio,\n\t\t\t\t\t  struct rmap_walk_control *rwc)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct anon_vma *root_anon_vma;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(folio->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!folio_mapped(folio))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\troot_anon_vma = READ_ONCE(anon_vma->root);\n\tif (down_read_trylock(&root_anon_vma->rwsem)) {\n\t\t/*\n\t\t * If the folio is still mapped, then this anon_vma is still\n\t\t * its anon_vma, and holding the mutex ensures that it will\n\t\t * not go away, see anon_vma_free().\n\t\t */\n\t\tif (!folio_mapped(folio)) {\n\t\t\tup_read(&root_anon_vma->rwsem);\n\t\t\tanon_vma = NULL;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (rwc && rwc->try_lock) {\n\t\tanon_vma = NULL;\n\t\trwc->contended = true;\n\t\tgoto out;\n\t}\n\n\t/* trylock failed, we got to sleep */\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\tif (!folio_mapped(folio)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\n\n\t/* we pinned the anon_vma, its safe to sleep */\n\trcu_read_unlock();\n\tanon_vma_lock_read(anon_vma);\n\n\tif (atomic_dec_and_test(&anon_vma->refcount)) {\n\t\t/*\n\t\t * Oops, we held the last refcount, release the lock\n\t\t * and bail -- can't simply use put_anon_vma() because\n\t\t * we'll deadlock on the anon_vma_lock_write() recursion.\n\t\t */\n\t\tanon_vma_unlock_read(anon_vma);\n\t\t__put_anon_vma(anon_vma);\n\t\tanon_vma = NULL;\n\t}\n\n\treturn anon_vma;\n\nout:\n\trcu_read_unlock();\n\treturn anon_vma;\n}\n\nvoid page_unlock_anon_vma_read(struct anon_vma *anon_vma)\n{\n\tanon_vma_unlock_read(anon_vma);\n}\n\n#ifdef CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH\n/*\n * Flush TLB entries for recently unmapped pages from remote CPUs. It is\n * important if a PTE was dirty when it was unmapped that it's flushed\n * before any IO is initiated on the page to prevent lost writes. Similarly,\n * it must be flushed before freeing to prevent data leakage.\n */\nvoid try_to_unmap_flush(void)\n{\n\tstruct tlbflush_unmap_batch *tlb_ubc = &current->tlb_ubc;\n\n\tif (!tlb_ubc->flush_required)\n\t\treturn;\n\n\tarch_tlbbatch_flush(&tlb_ubc->arch);\n\ttlb_ubc->flush_required = false;\n\ttlb_ubc->writable = false;\n}\n\n/* Flush iff there are potentially writable TLB entries that can race with IO */\nvoid try_to_unmap_flush_dirty(void)\n{\n\tstruct tlbflush_unmap_batch *tlb_ubc = &current->tlb_ubc;\n\n\tif (tlb_ubc->writable)\n\t\ttry_to_unmap_flush();\n}\n\n/*\n * Bits 0-14 of mm->tlb_flush_batched record pending generations.\n * Bits 16-30 of mm->tlb_flush_batched bit record flushed generations.\n */\n#define TLB_FLUSH_BATCH_FLUSHED_SHIFT\t16\n#define TLB_FLUSH_BATCH_PENDING_MASK\t\t\t\\\n\t((1 << (TLB_FLUSH_BATCH_FLUSHED_SHIFT - 1)) - 1)\n#define TLB_FLUSH_BATCH_PENDING_LARGE\t\t\t\\\n\t(TLB_FLUSH_BATCH_PENDING_MASK / 2)\n\nstatic void set_tlb_ubc_flush_pending(struct mm_struct *mm, bool writable)\n{\n\tstruct tlbflush_unmap_batch *tlb_ubc = &current->tlb_ubc;\n\tint batch, nbatch;\n\n\tarch_tlbbatch_add_mm(&tlb_ubc->arch, mm);\n\ttlb_ubc->flush_required = true;\n\n\t/*\n\t * Ensure compiler does not re-order the setting of tlb_flush_batched\n\t * before the PTE is cleared.\n\t */\n\tbarrier();\n\tbatch = atomic_read(&mm->tlb_flush_batched);\nretry:\n\tif ((batch & TLB_FLUSH_BATCH_PENDING_MASK) > TLB_FLUSH_BATCH_PENDING_LARGE) {\n\t\t/*\n\t\t * Prevent `pending' from catching up with `flushed' because of\n\t\t * overflow.  Reset `pending' and `flushed' to be 1 and 0 if\n\t\t * `pending' becomes large.\n\t\t */\n\t\tnbatch = atomic_cmpxchg(&mm->tlb_flush_batched, batch, 1);\n\t\tif (nbatch != batch) {\n\t\t\tbatch = nbatch;\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\tatomic_inc(&mm->tlb_flush_batched);\n\t}\n\n\t/*\n\t * If the PTE was dirty then it's best to assume it's writable. The\n\t * caller must use try_to_unmap_flush_dirty() or try_to_unmap_flush()\n\t * before the page is queued for IO.\n\t */\n\tif (writable)\n\t\ttlb_ubc->writable = true;\n}\n\n/*\n * Returns true if the TLB flush should be deferred to the end of a batch of\n * unmap operations to reduce IPIs.\n */\nstatic bool should_defer_flush(struct mm_struct *mm, enum ttu_flags flags)\n{\n\tbool should_defer = false;\n\n\tif (!(flags & TTU_BATCH_FLUSH))\n\t\treturn false;\n\n\t/* If remote CPUs need to be flushed then defer batch the flush */\n\tif (cpumask_any_but(mm_cpumask(mm), get_cpu()) < nr_cpu_ids)\n\t\tshould_defer = true;\n\tput_cpu();\n\n\treturn should_defer;\n}\n\n/*\n * Reclaim unmaps pages under the PTL but do not flush the TLB prior to\n * releasing the PTL if TLB flushes are batched. It's possible for a parallel\n * operation such as mprotect or munmap to race between reclaim unmapping\n * the page and flushing the page. If this race occurs, it potentially allows\n * access to data via a stale TLB entry. Tracking all mm's that have TLB\n * batching in flight would be expensive during reclaim so instead track\n * whether TLB batching occurred in the past and if so then do a flush here\n * if required. This will cost one additional flush per reclaim cycle paid\n * by the first operation at risk such as mprotect and mumap.\n *\n * This must be called under the PTL so that an access to tlb_flush_batched\n * that is potentially a \"reclaim vs mprotect/munmap/etc\" race will synchronise\n * via the PTL.\n */\nvoid flush_tlb_batched_pending(struct mm_struct *mm)\n{\n\tint batch = atomic_read(&mm->tlb_flush_batched);\n\tint pending = batch & TLB_FLUSH_BATCH_PENDING_MASK;\n\tint flushed = batch >> TLB_FLUSH_BATCH_FLUSHED_SHIFT;\n\n\tif (pending != flushed) {\n\t\tflush_tlb_mm(mm);\n\t\t/*\n\t\t * If the new TLB flushing is pending during flushing, leave\n\t\t * mm->tlb_flush_batched as is, to avoid losing flushing.\n\t\t */\n\t\tatomic_cmpxchg(&mm->tlb_flush_batched, batch,\n\t\t\t       pending | (pending << TLB_FLUSH_BATCH_FLUSHED_SHIFT));\n\t}\n}\n#else\nstatic void set_tlb_ubc_flush_pending(struct mm_struct *mm, bool writable)\n{\n}\n\nstatic bool should_defer_flush(struct mm_struct *mm, enum ttu_flags flags)\n{\n\treturn false;\n}\n#endif /* CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH */\n\n/*\n * At what user virtual address is page expected in vma?\n * Caller should check the page is actually part of the vma.\n */\nunsigned long page_address_in_vma(struct page *page, struct vm_area_struct *vma)\n{\n\tstruct folio *folio = page_folio(page);\n\tif (folio_test_anon(folio)) {\n\t\tstruct anon_vma *page__anon_vma = folio_anon_vma(folio);\n\t\t/*\n\t\t * Note: swapoff's unuse_vma() is more efficient with this\n\t\t * check, and needs it to match anon_vma when KSM is active.\n\t\t */\n\t\tif (!vma->anon_vma || !page__anon_vma ||\n\t\t    vma->anon_vma->root != page__anon_vma->root)\n\t\t\treturn -EFAULT;\n\t} else if (!vma->vm_file) {\n\t\treturn -EFAULT;\n\t} else if (vma->vm_file->f_mapping != folio->mapping) {\n\t\treturn -EFAULT;\n\t}\n\n\treturn vma_address(page, vma);\n}\n\npmd_t *mm_find_pmd(struct mm_struct *mm, unsigned long address)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd = NULL;\n\tpmd_t pmde;\n\n\tpgd = pgd_offset(mm, address);\n\tif (!pgd_present(*pgd))\n\t\tgoto out;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\tgoto out;\n\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\t/*\n\t * Some THP functions use the sequence pmdp_huge_clear_flush(), set_pmd_at()\n\t * without holding anon_vma lock for write.  So when looking for a\n\t * genuine pmde (in which to find pte), test present and !THP together.\n\t */\n\tpmde = *pmd;\n\tbarrier();\n\tif (!pmd_present(pmde) || pmd_trans_huge(pmde))\n\t\tpmd = NULL;\nout:\n\treturn pmd;\n}\n\nstruct folio_referenced_arg {\n\tint mapcount;\n\tint referenced;\n\tunsigned long vm_flags;\n\tstruct mem_cgroup *memcg;\n};\n/*\n * arg: folio_referenced_arg will be passed\n */\nstatic bool folio_referenced_one(struct folio *folio,\n\t\tstruct vm_area_struct *vma, unsigned long address, void *arg)\n{\n\tstruct folio_referenced_arg *pra = arg;\n\tDEFINE_FOLIO_VMA_WALK(pvmw, folio, vma, address, 0);\n\tint referenced = 0;\n\n\twhile (page_vma_mapped_walk(&pvmw)) {\n\t\taddress = pvmw.address;\n\n\t\tif ((vma->vm_flags & VM_LOCKED) &&\n\t\t    (!folio_test_large(folio) || !pvmw.pte)) {\n\t\t\t/* Restore the mlock which got missed */\n\t\t\tmlock_vma_folio(folio, vma, !pvmw.pte);\n\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\tpra->vm_flags |= VM_LOCKED;\n\t\t\treturn false; /* To break the loop */\n\t\t}\n\n\t\tif (pvmw.pte) {\n\t\t\tif (ptep_clear_flush_young_notify(vma, address,\n\t\t\t\t\t\tpvmw.pte)) {\n\t\t\t\t/*\n\t\t\t\t * Don't treat a reference through\n\t\t\t\t * a sequentially read mapping as such.\n\t\t\t\t * If the folio has been used in another mapping,\n\t\t\t\t * we will catch it; if this other mapping is\n\t\t\t\t * already gone, the unmap path will have set\n\t\t\t\t * the referenced flag or activated the folio.\n\t\t\t\t */\n\t\t\t\tif (likely(!(vma->vm_flags & VM_SEQ_READ)))\n\t\t\t\t\treferenced++;\n\t\t\t}\n\t\t} else if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE)) {\n\t\t\tif (pmdp_clear_flush_young_notify(vma, address,\n\t\t\t\t\t\tpvmw.pmd))\n\t\t\t\treferenced++;\n\t\t} else {\n\t\t\t/* unexpected pmd-mapped folio? */\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\n\t\tpra->mapcount--;\n\t}\n\n\tif (referenced)\n\t\tfolio_clear_idle(folio);\n\tif (folio_test_clear_young(folio))\n\t\treferenced++;\n\n\tif (referenced) {\n\t\tpra->referenced++;\n\t\tpra->vm_flags |= vma->vm_flags & ~VM_LOCKED;\n\t}\n\n\tif (!pra->mapcount)\n\t\treturn false; /* To break the loop */\n\n\treturn true;\n}\n\nstatic bool invalid_folio_referenced_vma(struct vm_area_struct *vma, void *arg)\n{\n\tstruct folio_referenced_arg *pra = arg;\n\tstruct mem_cgroup *memcg = pra->memcg;\n\n\tif (!mm_match_cgroup(vma->vm_mm, memcg))\n\t\treturn true;\n\n\treturn false;\n}\n\n/**\n * folio_referenced() - Test if the folio was referenced.\n * @folio: The folio to test.\n * @is_locked: Caller holds lock on the folio.\n * @memcg: target memory cgroup\n * @vm_flags: A combination of all the vma->vm_flags which referenced the folio.\n *\n * Quick test_and_clear_referenced for all mappings of a folio,\n *\n * Return: The number of mappings which referenced the folio. Return -1 if\n * the function bailed out due to rmap lock contention.\n */\nint folio_referenced(struct folio *folio, int is_locked,\n\t\t     struct mem_cgroup *memcg, unsigned long *vm_flags)\n{\n\tint we_locked = 0;\n\tstruct folio_referenced_arg pra = {\n\t\t.mapcount = folio_mapcount(folio),\n\t\t.memcg = memcg,\n\t};\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = folio_referenced_one,\n\t\t.arg = (void *)&pra,\n\t\t.anon_lock = folio_lock_anon_vma_read,\n\t\t.try_lock = true,\n\t};\n\n\t*vm_flags = 0;\n\tif (!pra.mapcount)\n\t\treturn 0;\n\n\tif (!folio_raw_mapping(folio))\n\t\treturn 0;\n\n\tif (!is_locked && (!folio_test_anon(folio) || folio_test_ksm(folio))) {\n\t\twe_locked = folio_trylock(folio);\n\t\tif (!we_locked)\n\t\t\treturn 1;\n\t}\n\n\t/*\n\t * If we are reclaiming on behalf of a cgroup, skip\n\t * counting on behalf of references from different\n\t * cgroups\n\t */\n\tif (memcg) {\n\t\trwc.invalid_vma = invalid_folio_referenced_vma;\n\t}\n\n\trmap_walk(folio, &rwc);\n\t*vm_flags = pra.vm_flags;\n\n\tif (we_locked)\n\t\tfolio_unlock(folio);\n\n\treturn rwc.contended ? -1 : pra.referenced;\n}\n\nstatic int page_vma_mkclean_one(struct page_vma_mapped_walk *pvmw)\n{\n\tint cleaned = 0;\n\tstruct vm_area_struct *vma = pvmw->vma;\n\tstruct mmu_notifier_range range;\n\tunsigned long address = pvmw->address;\n\n\t/*\n\t * We have to assume the worse case ie pmd for invalidation. Note that\n\t * the folio can not be freed from this function.\n\t */\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_PROTECTION_PAGE,\n\t\t\t\t0, vma, vma->vm_mm, address,\n\t\t\t\tvma_address_end(pvmw));\n\tmmu_notifier_invalidate_range_start(&range);\n\n\twhile (page_vma_mapped_walk(pvmw)) {\n\t\tint ret = 0;\n\n\t\taddress = pvmw->address;\n\t\tif (pvmw->pte) {\n\t\t\tpte_t entry;\n\t\t\tpte_t *pte = pvmw->pte;\n\n\t\t\tif (!pte_dirty(*pte) && !pte_write(*pte))\n\t\t\t\tcontinue;\n\n\t\t\tflush_cache_page(vma, address, pte_pfn(*pte));\n\t\t\tentry = ptep_clear_flush(vma, address, pte);\n\t\t\tentry = pte_wrprotect(entry);\n\t\t\tentry = pte_mkclean(entry);\n\t\t\tset_pte_at(vma->vm_mm, address, pte, entry);\n\t\t\tret = 1;\n\t\t} else {\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tpmd_t *pmd = pvmw->pmd;\n\t\t\tpmd_t entry;\n\n\t\t\tif (!pmd_dirty(*pmd) && !pmd_write(*pmd))\n\t\t\t\tcontinue;\n\n\t\t\tflush_cache_range(vma, address,\n\t\t\t\t\t  address + HPAGE_PMD_SIZE);\n\t\t\tentry = pmdp_invalidate(vma, address, pmd);\n\t\t\tentry = pmd_wrprotect(entry);\n\t\t\tentry = pmd_mkclean(entry);\n\t\t\tset_pmd_at(vma->vm_mm, address, pmd, entry);\n\t\t\tret = 1;\n#else\n\t\t\t/* unexpected pmd-mapped folio? */\n\t\t\tWARN_ON_ONCE(1);\n#endif\n\t\t}\n\n\t\t/*\n\t\t * No need to call mmu_notifier_invalidate_range() as we are\n\t\t * downgrading page table protection not changing it to point\n\t\t * to a new page.\n\t\t *\n\t\t * See Documentation/mm/mmu_notifier.rst\n\t\t */\n\t\tif (ret)\n\t\t\tcleaned++;\n\t}\n\n\tmmu_notifier_invalidate_range_end(&range);\n\n\treturn cleaned;\n}\n\nstatic bool page_mkclean_one(struct folio *folio, struct vm_area_struct *vma,\n\t\t\t     unsigned long address, void *arg)\n{\n\tDEFINE_FOLIO_VMA_WALK(pvmw, folio, vma, address, PVMW_SYNC);\n\tint *cleaned = arg;\n\n\t*cleaned += page_vma_mkclean_one(&pvmw);\n\n\treturn true;\n}\n\nstatic bool invalid_mkclean_vma(struct vm_area_struct *vma, void *arg)\n{\n\tif (vma->vm_flags & VM_SHARED)\n\t\treturn false;\n\n\treturn true;\n}\n\nint folio_mkclean(struct folio *folio)\n{\n\tint cleaned = 0;\n\tstruct address_space *mapping;\n\tstruct rmap_walk_control rwc = {\n\t\t.arg = (void *)&cleaned,\n\t\t.rmap_one = page_mkclean_one,\n\t\t.invalid_vma = invalid_mkclean_vma,\n\t};\n\n\tBUG_ON(!folio_test_locked(folio));\n\n\tif (!folio_mapped(folio))\n\t\treturn 0;\n\n\tmapping = folio_mapping(folio);\n\tif (!mapping)\n\t\treturn 0;\n\n\trmap_walk(folio, &rwc);\n\n\treturn cleaned;\n}\nEXPORT_SYMBOL_GPL(folio_mkclean);\n\n/**\n * pfn_mkclean_range - Cleans the PTEs (including PMDs) mapped with range of\n *                     [@pfn, @pfn + @nr_pages) at the specific offset (@pgoff)\n *                     within the @vma of shared mappings. And since clean PTEs\n *                     should also be readonly, write protects them too.\n * @pfn: start pfn.\n * @nr_pages: number of physically contiguous pages srarting with @pfn.\n * @pgoff: page offset that the @pfn mapped with.\n * @vma: vma that @pfn mapped within.\n *\n * Returns the number of cleaned PTEs (including PMDs).\n */\nint pfn_mkclean_range(unsigned long pfn, unsigned long nr_pages, pgoff_t pgoff,\n\t\t      struct vm_area_struct *vma)\n{\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.pfn\t\t= pfn,\n\t\t.nr_pages\t= nr_pages,\n\t\t.pgoff\t\t= pgoff,\n\t\t.vma\t\t= vma,\n\t\t.flags\t\t= PVMW_SYNC,\n\t};\n\n\tif (invalid_mkclean_vma(vma, NULL))\n\t\treturn 0;\n\n\tpvmw.address = vma_pgoff_address(pgoff, nr_pages, vma);\n\tVM_BUG_ON_VMA(pvmw.address == -EFAULT, vma);\n\n\treturn page_vma_mkclean_one(&pvmw);\n}\n\n/**\n * page_move_anon_rmap - move a page to our anon_vma\n * @page:\tthe page to move to our anon_vma\n * @vma:\tthe vma the page belongs to\n *\n * When a page belongs exclusively to one process after a COW event,\n * that page can be moved into the anon_vma that belongs to just that\n * process, so the rmap code will not search the parent or sibling\n * processes.\n */\nvoid page_move_anon_rmap(struct page *page, struct vm_area_struct *vma)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\tstruct page *subpage = page;\n\n\tpage = compound_head(page);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_VMA(!anon_vma, vma);\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\t/*\n\t * Ensure that anon_vma and the PAGE_MAPPING_ANON bit are written\n\t * simultaneously, so a concurrent reader (eg folio_referenced()'s\n\t * folio_test_anon()) will not see one without the other.\n\t */\n\tWRITE_ONCE(page->mapping, (struct address_space *) anon_vma);\n\tSetPageAnonExclusive(subpage);\n}\n\n/**\n * __page_set_anon_rmap - set up new anonymous rmap\n * @page:\tPage or Hugepage to add to rmap\n * @vma:\tVM area to add page to.\n * @address:\tUser virtual address of the mapping\t\n * @exclusive:\tthe page is exclusively owned by the current process\n */\nstatic void __page_set_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int exclusive)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tBUG_ON(!anon_vma);\n\n\tif (PageAnon(page))\n\t\tgoto out;\n\n\t/*\n\t * If the page isn't exclusively mapped into this vma,\n\t * we must use the _oldest_ possible anon_vma for the\n\t * page mapping!\n\t */\n\tif (!exclusive)\n\t\tanon_vma = anon_vma->root;\n\n\t/*\n\t * page_idle does a lockless/optimistic rmap scan on page->mapping.\n\t * Make sure the compiler doesn't split the stores of anon_vma and\n\t * the PAGE_MAPPING_ANON type identifier, otherwise the rmap code\n\t * could mistake the mapping for a struct address_space and crash.\n\t */\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\tWRITE_ONCE(page->mapping, (struct address_space *) anon_vma);\n\tpage->index = linear_page_index(vma, address);\nout:\n\tif (exclusive)\n\t\tSetPageAnonExclusive(page);\n}\n\n/**\n * __page_check_anon_rmap - sanity check anonymous rmap addition\n * @page:\tthe page to add the mapping to\n * @vma:\tthe vm area in which the mapping is added\n * @address:\tthe user virtual address mapped\n */\nstatic void __page_check_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tstruct folio *folio = page_folio(page);\n\t/*\n\t * The page's anon-rmap details (mapping and index) are guaranteed to\n\t * be set up correctly at this point.\n\t *\n\t * We have exclusion against page_add_anon_rmap because the caller\n\t * always holds the page locked.\n\t *\n\t * We have exclusion against page_add_new_anon_rmap because those pages\n\t * are initially only visible via the pagetables, and the pte is locked\n\t * over the call to page_add_new_anon_rmap.\n\t */\n\tVM_BUG_ON_FOLIO(folio_anon_vma(folio)->root != vma->anon_vma->root,\n\t\t\tfolio);\n\tVM_BUG_ON_PAGE(page_to_pgoff(page) != linear_page_index(vma, address),\n\t\t       page);\n}\n\n/**\n * page_add_anon_rmap - add pte mapping to an anonymous page\n * @page:\tthe page to add the mapping to\n * @vma:\tthe vm area in which the mapping is added\n * @address:\tthe user virtual address mapped\n * @flags:\tthe rmap flags\n *\n * The caller needs to hold the pte lock, and the page must be locked in\n * the anon_vma case: to serialize mapping,index checking after setting,\n * and to ensure that PageAnon is not being upgraded racily to PageKsm\n * (but PageKsm is never downgraded to PageAnon).\n */\nvoid page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, rmap_t flags)\n{\n\tbool compound = flags & RMAP_COMPOUND;\n\tbool first;\n\n\tif (unlikely(PageKsm(page)))\n\t\tlock_page_memcg(page);\n\telse\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (compound) {\n\t\tatomic_t *mapcount;\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\tmapcount = compound_mapcount_ptr(page);\n\t\tfirst = atomic_inc_and_test(mapcount);\n\t} else {\n\t\tfirst = atomic_inc_and_test(&page->_mapcount);\n\t}\n\tVM_BUG_ON_PAGE(!first && (flags & RMAP_EXCLUSIVE), page);\n\tVM_BUG_ON_PAGE(!first && PageAnonExclusive(page), page);\n\n\tif (first) {\n\t\tint nr = compound ? thp_nr_pages(page) : 1;\n\t\t/*\n\t\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t\t * these counters are not modified in interrupt context, and\n\t\t * pte lock(a spinlock) is held, which implies preemption\n\t\t * disabled.\n\t\t */\n\t\tif (compound)\n\t\t\t__mod_lruvec_page_state(page, NR_ANON_THPS, nr);\n\t\t__mod_lruvec_page_state(page, NR_ANON_MAPPED, nr);\n\t}\n\n\tif (unlikely(PageKsm(page)))\n\t\tunlock_page_memcg(page);\n\n\t/* address might be in next vma when migration races vma_adjust */\n\telse if (first)\n\t\t__page_set_anon_rmap(page, vma, address,\n\t\t\t\t     !!(flags & RMAP_EXCLUSIVE));\n\telse\n\t\t__page_check_anon_rmap(page, vma, address);\n\n\tmlock_vma_page(page, vma, compound);\n}\n\n/**\n * page_add_new_anon_rmap - add mapping to a new anonymous page\n * @page:\tthe page to add the mapping to\n * @vma:\tthe vm area in which the mapping is added\n * @address:\tthe user virtual address mapped\n *\n * If it's a compound page, it is accounted as a compound page. As the page\n * is new, it's assume to get mapped exclusively by a single process.\n *\n * Same as page_add_anon_rmap but must only be called on *new* pages.\n * This means the inc-and-test can be bypassed.\n * Page does not have to be locked.\n */\nvoid page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tconst bool compound = PageCompound(page);\n\tint nr = compound ? thp_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\tatomic_set(compound_pincount_ptr(page), 0);\n\n\t\t__mod_lruvec_page_state(page, NR_ANON_THPS, nr);\n\t} else {\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_lruvec_page_state(page, NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}\n\n/**\n * page_add_file_rmap - add pte mapping to a file page\n * @page:\tthe page to add the mapping to\n * @vma:\tthe vm area in which the mapping is added\n * @compound:\tcharge the page as compound or small page\n *\n * The caller needs to hold the pte lock.\n */\nvoid page_add_file_rmap(struct page *page,\n\tstruct vm_area_struct *vma, bool compound)\n{\n\tint i, nr = 0;\n\n\tVM_BUG_ON_PAGE(compound && !PageTransHuge(page), page);\n\tlock_page_memcg(page);\n\tif (compound && PageTransHuge(page)) {\n\t\tint nr_pages = thp_nr_pages(page);\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tif (atomic_inc_and_test(&page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t\tif (!atomic_inc_and_test(compound_mapcount_ptr(page)))\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * It is racy to ClearPageDoubleMap in page_remove_file_rmap();\n\t\t * but page lock is held by all page_add_file_rmap() compound\n\t\t * callers, and SetPageDoubleMap below warns if !PageLocked:\n\t\t * so here is a place that DoubleMap can be safely cleared.\n\t\t */\n\t\tVM_WARN_ON_ONCE(!PageLocked(page));\n\t\tif (nr == nr_pages && PageDoubleMap(page))\n\t\t\tClearPageDoubleMap(page);\n\n\t\tif (PageSwapBacked(page))\n\t\t\t__mod_lruvec_page_state(page, NR_SHMEM_PMDMAPPED,\n\t\t\t\t\t\tnr_pages);\n\t\telse\n\t\t\t__mod_lruvec_page_state(page, NR_FILE_PMDMAPPED,\n\t\t\t\t\t\tnr_pages);\n\t} else {\n\t\tif (PageTransCompound(page) && page_mapping(page)) {\n\t\t\tVM_WARN_ON_ONCE(!PageLocked(page));\n\t\t\tSetPageDoubleMap(compound_head(page));\n\t\t}\n\t\tif (atomic_inc_and_test(&page->_mapcount))\n\t\t\tnr++;\n\t}\nout:\n\tif (nr)\n\t\t__mod_lruvec_page_state(page, NR_FILE_MAPPED, nr);\n\tunlock_page_memcg(page);\n\n\tmlock_vma_page(page, vma, compound);\n}\n\nstatic void page_remove_file_rmap(struct page *page, bool compound)\n{\n\tint i, nr = 0;\n\n\tVM_BUG_ON_PAGE(compound && !PageHead(page), page);\n\n\t/* Hugepages are not counted in NR_FILE_MAPPED for now. */\n\tif (unlikely(PageHuge(page))) {\n\t\t/* hugetlb pages are always mapped with pmds */\n\t\tatomic_dec(compound_mapcount_ptr(page));\n\t\treturn;\n\t}\n\n\t/* page still mapped by someone else? */\n\tif (compound && PageTransHuge(page)) {\n\t\tint nr_pages = thp_nr_pages(page);\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tif (atomic_add_negative(-1, &page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t\tif (!atomic_add_negative(-1, compound_mapcount_ptr(page)))\n\t\t\tgoto out;\n\t\tif (PageSwapBacked(page))\n\t\t\t__mod_lruvec_page_state(page, NR_SHMEM_PMDMAPPED,\n\t\t\t\t\t\t-nr_pages);\n\t\telse\n\t\t\t__mod_lruvec_page_state(page, NR_FILE_PMDMAPPED,\n\t\t\t\t\t\t-nr_pages);\n\t} else {\n\t\tif (atomic_add_negative(-1, &page->_mapcount))\n\t\t\tnr++;\n\t}\nout:\n\tif (nr)\n\t\t__mod_lruvec_page_state(page, NR_FILE_MAPPED, -nr);\n}\n\nstatic void page_remove_anon_compound_rmap(struct page *page)\n{\n\tint i, nr;\n\n\tif (!atomic_add_negative(-1, compound_mapcount_ptr(page)))\n\t\treturn;\n\n\t/* Hugepages are not counted in NR_ANON_PAGES for now. */\n\tif (unlikely(PageHuge(page)))\n\t\treturn;\n\n\tif (!IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE))\n\t\treturn;\n\n\t__mod_lruvec_page_state(page, NR_ANON_THPS, -thp_nr_pages(page));\n\n\tif (TestClearPageDoubleMap(page)) {\n\t\t/*\n\t\t * Subpages can be mapped with PTEs too. Check how many of\n\t\t * them are still mapped.\n\t\t */\n\t\tfor (i = 0, nr = 0; i < thp_nr_pages(page); i++) {\n\t\t\tif (atomic_add_negative(-1, &page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\n\t\t/*\n\t\t * Queue the page for deferred split if at least one small\n\t\t * page of the compound page is unmapped, but at least one\n\t\t * small page is still mapped.\n\t\t */\n\t\tif (nr && nr < thp_nr_pages(page))\n\t\t\tdeferred_split_huge_page(page);\n\t} else {\n\t\tnr = thp_nr_pages(page);\n\t}\n\n\tif (nr)\n\t\t__mod_lruvec_page_state(page, NR_ANON_MAPPED, -nr);\n}\n\n/**\n * page_remove_rmap - take down pte mapping from a page\n * @page:\tpage to remove mapping from\n * @vma:\tthe vm area from which the mapping is removed\n * @compound:\tuncharge the page as compound or small page\n *\n * The caller needs to hold the pte lock.\n */\nvoid page_remove_rmap(struct page *page,\n\tstruct vm_area_struct *vma, bool compound)\n{\n\tlock_page_memcg(page);\n\n\tif (!PageAnon(page)) {\n\t\tpage_remove_file_rmap(page, compound);\n\t\tgoto out;\n\t}\n\n\tif (compound) {\n\t\tpage_remove_anon_compound_rmap(page);\n\t\tgoto out;\n\t}\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\tgoto out;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_lruvec_page_state(page, NR_ANON_MAPPED);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\nout:\n\tunlock_page_memcg(page);\n\n\tmunlock_vma_page(page, vma, compound);\n}\n\n/*\n * @arg: enum ttu_flags will be passed to this argument\n */\nstatic bool try_to_unmap_one(struct folio *folio, struct vm_area_struct *vma,\n\t\t     unsigned long address, void *arg)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tDEFINE_FOLIO_VMA_WALK(pvmw, folio, vma, address, 0);\n\tpte_t pteval;\n\tstruct page *subpage;\n\tbool anon_exclusive, ret = true;\n\tstruct mmu_notifier_range range;\n\tenum ttu_flags flags = (enum ttu_flags)(long)arg;\n\n\t/*\n\t * When racing against e.g. zap_pte_range() on another cpu,\n\t * in between its ptep_get_and_clear_full() and page_remove_rmap(),\n\t * try_to_unmap() may return before page_mapped() has become false,\n\t * if page table locking is skipped: use TTU_SYNC to wait for that.\n\t */\n\tif (flags & TTU_SYNC)\n\t\tpvmw.flags = PVMW_SYNC;\n\n\tif (flags & TTU_SPLIT_HUGE_PMD)\n\t\tsplit_huge_pmd_address(vma, address, false, folio);\n\n\t/*\n\t * For THP, we have to assume the worse case ie pmd for invalidation.\n\t * For hugetlb, it could be much worse if we need to do pud\n\t * invalidation in the case of pmd sharing.\n\t *\n\t * Note that the folio can not be freed in this function as call of\n\t * try_to_unmap() must hold a reference on the folio.\n\t */\n\trange.end = vma_address_end(&pvmw);\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma, vma->vm_mm,\n\t\t\t\taddress, range.end);\n\tif (folio_test_hugetlb(folio)) {\n\t\t/*\n\t\t * If sharing is possible, start and end will be adjusted\n\t\t * accordingly.\n\t\t */\n\t\tadjust_range_if_pmd_sharing_possible(vma, &range.start,\n\t\t\t\t\t\t     &range.end);\n\t}\n\tmmu_notifier_invalidate_range_start(&range);\n\n\twhile (page_vma_mapped_walk(&pvmw)) {\n\t\t/* Unexpected PMD-mapped THP? */\n\t\tVM_BUG_ON_FOLIO(!pvmw.pte, folio);\n\n\t\t/*\n\t\t * If the folio is in an mlock()d vma, we must not swap it out.\n\t\t */\n\t\tif (!(flags & TTU_IGNORE_MLOCK) &&\n\t\t    (vma->vm_flags & VM_LOCKED)) {\n\t\t\t/* Restore the mlock which got missed */\n\t\t\tmlock_vma_folio(folio, vma, false);\n\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tsubpage = folio_page(folio,\n\t\t\t\t\tpte_pfn(*pvmw.pte) - folio_pfn(folio));\n\t\taddress = pvmw.address;\n\t\tanon_exclusive = folio_test_anon(folio) &&\n\t\t\t\t PageAnonExclusive(subpage);\n\n\t\tif (folio_test_hugetlb(folio)) {\n\t\t\tbool anon = folio_test_anon(folio);\n\n\t\t\t/*\n\t\t\t * The try_to_unmap() is only passed a hugetlb page\n\t\t\t * in the case where the hugetlb page is poisoned.\n\t\t\t */\n\t\t\tVM_BUG_ON_PAGE(!PageHWPoison(subpage), subpage);\n\t\t\t/*\n\t\t\t * huge_pmd_unshare may unmap an entire PMD page.\n\t\t\t * There is no way of knowing exactly which PMDs may\n\t\t\t * be cached for this mm, so we must flush them all.\n\t\t\t * start/end were already adjusted above to cover this\n\t\t\t * range.\n\t\t\t */\n\t\t\tflush_cache_range(vma, range.start, range.end);\n\n\t\t\t/*\n\t\t\t * To call huge_pmd_unshare, i_mmap_rwsem must be\n\t\t\t * held in write mode.  Caller needs to explicitly\n\t\t\t * do this outside rmap routines.\n\t\t\t */\n\t\t\tVM_BUG_ON(!anon && !(flags & TTU_RMAP_LOCKED));\n\t\t\tif (!anon && huge_pmd_unshare(mm, vma, address, pvmw.pte)) {\n\t\t\t\tflush_tlb_range(vma, range.start, range.end);\n\t\t\t\tmmu_notifier_invalidate_range(mm, range.start,\n\t\t\t\t\t\t\t      range.end);\n\n\t\t\t\t/*\n\t\t\t\t * The ref count of the PMD page was dropped\n\t\t\t\t * which is part of the way map counting\n\t\t\t\t * is done for shared PMDs.  Return 'true'\n\t\t\t\t * here.  When there is no other sharing,\n\t\t\t\t * huge_pmd_unshare returns false and we will\n\t\t\t\t * unmap the actual page and drop map count\n\t\t\t\t * to zero.\n\t\t\t\t */\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpteval = huge_ptep_clear_flush(vma, address, pvmw.pte);\n\t\t} else {\n\t\t\tflush_cache_page(vma, address, pte_pfn(*pvmw.pte));\n\t\t\t/*\n\t\t\t * Nuke the page table entry. When having to clear\n\t\t\t * PageAnonExclusive(), we always have to flush.\n\t\t\t */\n\t\t\tif (should_defer_flush(mm, flags) && !anon_exclusive) {\n\t\t\t\t/*\n\t\t\t\t * We clear the PTE but do not flush so potentially\n\t\t\t\t * a remote CPU could still be writing to the folio.\n\t\t\t\t * If the entry was previously clean then the\n\t\t\t\t * architecture must guarantee that a clear->dirty\n\t\t\t\t * transition on a cached TLB entry is written through\n\t\t\t\t * and traps if the PTE is unmapped.\n\t\t\t\t */\n\t\t\t\tpteval = ptep_get_and_clear(mm, address, pvmw.pte);\n\n\t\t\t\tset_tlb_ubc_flush_pending(mm, pte_dirty(pteval));\n\t\t\t} else {\n\t\t\t\tpteval = ptep_clear_flush(vma, address, pvmw.pte);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Now the pte is cleared. If this pte was uffd-wp armed,\n\t\t * we may want to replace a none pte with a marker pte if\n\t\t * it's file-backed, so we don't lose the tracking info.\n\t\t */\n\t\tpte_install_uffd_wp_if_needed(vma, address, pvmw.pte, pteval);\n\n\t\t/* Set the dirty flag on the folio now the pte is gone. */\n\t\tif (pte_dirty(pteval))\n\t\t\tfolio_mark_dirty(folio);\n\n\t\t/* Update high watermark before we lower rss */\n\t\tupdate_hiwater_rss(mm);\n\n\t\tif (PageHWPoison(subpage) && !(flags & TTU_IGNORE_HWPOISON)) {\n\t\t\tpteval = swp_entry_to_pte(make_hwpoison_entry(subpage));\n\t\t\tif (folio_test_hugetlb(folio)) {\n\t\t\t\thugetlb_count_sub(folio_nr_pages(folio), mm);\n\t\t\t\tset_huge_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t} else {\n\t\t\t\tdec_mm_counter(mm, mm_counter(&folio->page));\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t}\n\n\t\t} else if (pte_unused(pteval) && !userfaultfd_armed(vma)) {\n\t\t\t/*\n\t\t\t * The guest indicated that the page content is of no\n\t\t\t * interest anymore. Simply discard the pte, vmscan\n\t\t\t * will take care of the rest.\n\t\t\t * A future reference will then fault in a new zero\n\t\t\t * page. When userfaultfd is active, we must not drop\n\t\t\t * this page though, as its main user (postcopy\n\t\t\t * migration) will not expect userfaults on already\n\t\t\t * copied pages.\n\t\t\t */\n\t\t\tdec_mm_counter(mm, mm_counter(&folio->page));\n\t\t\t/* We have to invalidate as we cleared the pte */\n\t\t\tmmu_notifier_invalidate_range(mm, address,\n\t\t\t\t\t\t      address + PAGE_SIZE);\n\t\t} else if (folio_test_anon(folio)) {\n\t\t\tswp_entry_t entry = { .val = page_private(subpage) };\n\t\t\tpte_t swp_pte;\n\t\t\t/*\n\t\t\t * Store the swap location in the pte.\n\t\t\t * See handle_pte_fault() ...\n\t\t\t */\n\t\t\tif (unlikely(folio_test_swapbacked(folio) !=\n\t\t\t\t\tfolio_test_swapcache(folio))) {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tret = false;\n\t\t\t\t/* We have to invalidate as we cleared the pte */\n\t\t\t\tmmu_notifier_invalidate_range(mm, address,\n\t\t\t\t\t\t\taddress + PAGE_SIZE);\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* MADV_FREE page check */\n\t\t\tif (!folio_test_swapbacked(folio)) {\n\t\t\t\tint ref_count, map_count;\n\n\t\t\t\t/*\n\t\t\t\t * Synchronize with gup_pte_range():\n\t\t\t\t * - clear PTE; barrier; read refcount\n\t\t\t\t * - inc refcount; barrier; read PTE\n\t\t\t\t */\n\t\t\t\tsmp_mb();\n\n\t\t\t\tref_count = folio_ref_count(folio);\n\t\t\t\tmap_count = folio_mapcount(folio);\n\n\t\t\t\t/*\n\t\t\t\t * Order reads for page refcount and dirty flag\n\t\t\t\t * (see comments in __remove_mapping()).\n\t\t\t\t */\n\t\t\t\tsmp_rmb();\n\n\t\t\t\t/*\n\t\t\t\t * The only page refs must be one from isolation\n\t\t\t\t * plus the rmap(s) (dropped by discard:).\n\t\t\t\t */\n\t\t\t\tif (ref_count == 1 + map_count &&\n\t\t\t\t    !folio_test_dirty(folio)) {\n\t\t\t\t\t/* Invalidate as we cleared the pte */\n\t\t\t\t\tmmu_notifier_invalidate_range(mm,\n\t\t\t\t\t\taddress, address + PAGE_SIZE);\n\t\t\t\t\tdec_mm_counter(mm, MM_ANONPAGES);\n\t\t\t\t\tgoto discard;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * If the folio was redirtied, it cannot be\n\t\t\t\t * discarded. Remap the page to page table.\n\t\t\t\t */\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\tfolio_set_swapbacked(folio);\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (swap_duplicate(entry) < 0) {\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (arch_unmap_one(mm, vma, address, pteval) < 0) {\n\t\t\t\tswap_free(entry);\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (anon_exclusive &&\n\t\t\t    page_try_share_anon_rmap(subpage)) {\n\t\t\t\tswap_free(entry);\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Note: We *don't* remember if the page was mapped\n\t\t\t * exclusively in the swap pte if the architecture\n\t\t\t * doesn't support __HAVE_ARCH_PTE_SWP_EXCLUSIVE. In\n\t\t\t * that case, swapin code has to re-determine that\n\t\t\t * manually and might detect the page as possibly\n\t\t\t * shared, for example, if there are other references on\n\t\t\t * the page or if the page is under writeback. We made\n\t\t\t * sure that there are no GUP pins on the page that\n\t\t\t * would rely on it, so for GUP pins this is fine.\n\t\t\t */\n\t\t\tif (list_empty(&mm->mmlist)) {\n\t\t\t\tspin_lock(&mmlist_lock);\n\t\t\t\tif (list_empty(&mm->mmlist))\n\t\t\t\t\tlist_add(&mm->mmlist, &init_mm.mmlist);\n\t\t\t\tspin_unlock(&mmlist_lock);\n\t\t\t}\n\t\t\tdec_mm_counter(mm, MM_ANONPAGES);\n\t\t\tinc_mm_counter(mm, MM_SWAPENTS);\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (anon_exclusive)\n\t\t\t\tswp_pte = pte_swp_mkexclusive(swp_pte);\n\t\t\tif (pte_soft_dirty(pteval))\n\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\tif (pte_uffd_wp(pteval))\n\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\tset_pte_at(mm, address, pvmw.pte, swp_pte);\n\t\t\t/* Invalidate as we cleared the pte */\n\t\t\tmmu_notifier_invalidate_range(mm, address,\n\t\t\t\t\t\t      address + PAGE_SIZE);\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is a locked file-backed folio,\n\t\t\t * so it cannot be removed from the page\n\t\t\t * cache and replaced by a new folio before\n\t\t\t * mmu_notifier_invalidate_range_end, so no\n\t\t\t * concurrent thread might update its page table\n\t\t\t * to point at a new folio while a device is\n\t\t\t * still using this folio.\n\t\t\t *\n\t\t\t * See Documentation/mm/mmu_notifier.rst\n\t\t\t */\n\t\t\tdec_mm_counter(mm, mm_counter_file(&folio->page));\n\t\t}\ndiscard:\n\t\t/*\n\t\t * No need to call mmu_notifier_invalidate_range() it has be\n\t\t * done above for all cases requiring it to happen under page\n\t\t * table lock before mmu_notifier_invalidate_range_end()\n\t\t *\n\t\t * See Documentation/mm/mmu_notifier.rst\n\t\t */\n\t\tpage_remove_rmap(subpage, vma, folio_test_hugetlb(folio));\n\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\tmlock_page_drain_local();\n\t\tfolio_put(folio);\n\t}\n\n\tmmu_notifier_invalidate_range_end(&range);\n\n\treturn ret;\n}\n\nstatic bool invalid_migration_vma(struct vm_area_struct *vma, void *arg)\n{\n\treturn vma_is_temporary_stack(vma);\n}\n\nstatic int page_not_mapped(struct folio *folio)\n{\n\treturn !folio_mapped(folio);\n}\n\n/**\n * try_to_unmap - Try to remove all page table mappings to a folio.\n * @folio: The folio to unmap.\n * @flags: action and flags\n *\n * Tries to remove all the page table entries which are mapping this\n * folio.  It is the caller's responsibility to check if the folio is\n * still mapped if needed (use TTU_SYNC to prevent accounting races).\n *\n * Context: Caller must hold the folio lock.\n */\nvoid try_to_unmap(struct folio *folio, enum ttu_flags flags)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_unmap_one,\n\t\t.arg = (void *)flags,\n\t\t.done = page_not_mapped,\n\t\t.anon_lock = folio_lock_anon_vma_read,\n\t};\n\n\tif (flags & TTU_RMAP_LOCKED)\n\t\trmap_walk_locked(folio, &rwc);\n\telse\n\t\trmap_walk(folio, &rwc);\n}\n\n/*\n * @arg: enum ttu_flags will be passed to this argument.\n *\n * If TTU_SPLIT_HUGE_PMD is specified any PMD mappings will be split into PTEs\n * containing migration entries.\n */\nstatic bool try_to_migrate_one(struct folio *folio, struct vm_area_struct *vma,\n\t\t     unsigned long address, void *arg)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tDEFINE_FOLIO_VMA_WALK(pvmw, folio, vma, address, 0);\n\tpte_t pteval;\n\tstruct page *subpage;\n\tbool anon_exclusive, ret = true;\n\tstruct mmu_notifier_range range;\n\tenum ttu_flags flags = (enum ttu_flags)(long)arg;\n\n\t/*\n\t * When racing against e.g. zap_pte_range() on another cpu,\n\t * in between its ptep_get_and_clear_full() and page_remove_rmap(),\n\t * try_to_migrate() may return before page_mapped() has become false,\n\t * if page table locking is skipped: use TTU_SYNC to wait for that.\n\t */\n\tif (flags & TTU_SYNC)\n\t\tpvmw.flags = PVMW_SYNC;\n\n\t/*\n\t * unmap_page() in mm/huge_memory.c is the only user of migration with\n\t * TTU_SPLIT_HUGE_PMD and it wants to freeze.\n\t */\n\tif (flags & TTU_SPLIT_HUGE_PMD)\n\t\tsplit_huge_pmd_address(vma, address, true, folio);\n\n\t/*\n\t * For THP, we have to assume the worse case ie pmd for invalidation.\n\t * For hugetlb, it could be much worse if we need to do pud\n\t * invalidation in the case of pmd sharing.\n\t *\n\t * Note that the page can not be free in this function as call of\n\t * try_to_unmap() must hold a reference on the page.\n\t */\n\trange.end = vma_address_end(&pvmw);\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma, vma->vm_mm,\n\t\t\t\taddress, range.end);\n\tif (folio_test_hugetlb(folio)) {\n\t\t/*\n\t\t * If sharing is possible, start and end will be adjusted\n\t\t * accordingly.\n\t\t */\n\t\tadjust_range_if_pmd_sharing_possible(vma, &range.start,\n\t\t\t\t\t\t     &range.end);\n\t}\n\tmmu_notifier_invalidate_range_start(&range);\n\n\twhile (page_vma_mapped_walk(&pvmw)) {\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\t\t/* PMD-mapped THP migration entry */\n\t\tif (!pvmw.pte) {\n\t\t\tsubpage = folio_page(folio,\n\t\t\t\tpmd_pfn(*pvmw.pmd) - folio_pfn(folio));\n\t\t\tVM_BUG_ON_FOLIO(folio_test_hugetlb(folio) ||\n\t\t\t\t\t!folio_test_pmd_mappable(folio), folio);\n\n\t\t\tif (set_pmd_migration_entry(&pvmw, subpage)) {\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\t/* Unexpected PMD-mapped THP? */\n\t\tVM_BUG_ON_FOLIO(!pvmw.pte, folio);\n\n\t\tif (folio_is_zone_device(folio)) {\n\t\t\t/*\n\t\t\t * Our PTE is a non-present device exclusive entry and\n\t\t\t * calculating the subpage as for the common case would\n\t\t\t * result in an invalid pointer.\n\t\t\t *\n\t\t\t * Since only PAGE_SIZE pages can currently be\n\t\t\t * migrated, just set it to page. This will need to be\n\t\t\t * changed when hugepage migrations to device private\n\t\t\t * memory are supported.\n\t\t\t */\n\t\t\tVM_BUG_ON_FOLIO(folio_nr_pages(folio) > 1, folio);\n\t\t\tsubpage = &folio->page;\n\t\t} else {\n\t\t\tsubpage = folio_page(folio,\n\t\t\t\t\tpte_pfn(*pvmw.pte) - folio_pfn(folio));\n\t\t}\n\t\taddress = pvmw.address;\n\t\tanon_exclusive = folio_test_anon(folio) &&\n\t\t\t\t PageAnonExclusive(subpage);\n\n\t\tif (folio_test_hugetlb(folio)) {\n\t\t\tbool anon = folio_test_anon(folio);\n\n\t\t\t/*\n\t\t\t * huge_pmd_unshare may unmap an entire PMD page.\n\t\t\t * There is no way of knowing exactly which PMDs may\n\t\t\t * be cached for this mm, so we must flush them all.\n\t\t\t * start/end were already adjusted above to cover this\n\t\t\t * range.\n\t\t\t */\n\t\t\tflush_cache_range(vma, range.start, range.end);\n\n\t\t\t/*\n\t\t\t * To call huge_pmd_unshare, i_mmap_rwsem must be\n\t\t\t * held in write mode.  Caller needs to explicitly\n\t\t\t * do this outside rmap routines.\n\t\t\t */\n\t\t\tVM_BUG_ON(!anon && !(flags & TTU_RMAP_LOCKED));\n\t\t\tif (!anon && huge_pmd_unshare(mm, vma, address, pvmw.pte)) {\n\t\t\t\tflush_tlb_range(vma, range.start, range.end);\n\t\t\t\tmmu_notifier_invalidate_range(mm, range.start,\n\t\t\t\t\t\t\t      range.end);\n\n\t\t\t\t/*\n\t\t\t\t * The ref count of the PMD page was dropped\n\t\t\t\t * which is part of the way map counting\n\t\t\t\t * is done for shared PMDs.  Return 'true'\n\t\t\t\t * here.  When there is no other sharing,\n\t\t\t\t * huge_pmd_unshare returns false and we will\n\t\t\t\t * unmap the actual page and drop map count\n\t\t\t\t * to zero.\n\t\t\t\t */\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Nuke the hugetlb page table entry */\n\t\t\tpteval = huge_ptep_clear_flush(vma, address, pvmw.pte);\n\t\t} else {\n\t\t\tflush_cache_page(vma, address, pte_pfn(*pvmw.pte));\n\t\t\t/* Nuke the page table entry. */\n\t\t\tpteval = ptep_clear_flush(vma, address, pvmw.pte);\n\t\t}\n\n\t\t/* Set the dirty flag on the folio now the pte is gone. */\n\t\tif (pte_dirty(pteval))\n\t\t\tfolio_mark_dirty(folio);\n\n\t\t/* Update high watermark before we lower rss */\n\t\tupdate_hiwater_rss(mm);\n\n\t\tif (folio_is_device_private(folio)) {\n\t\t\tunsigned long pfn = folio_pfn(folio);\n\t\t\tswp_entry_t entry;\n\t\t\tpte_t swp_pte;\n\n\t\t\tif (anon_exclusive)\n\t\t\t\tBUG_ON(page_try_share_anon_rmap(subpage));\n\n\t\t\t/*\n\t\t\t * Store the pfn of the page in a special migration\n\t\t\t * pte. do_swap_page() will wait until the migration\n\t\t\t * pte is removed and then restart fault handling.\n\t\t\t */\n\t\t\tentry = pte_to_swp_entry(pteval);\n\t\t\tif (is_writable_device_private_entry(entry))\n\t\t\t\tentry = make_writable_migration_entry(pfn);\n\t\t\telse if (anon_exclusive)\n\t\t\t\tentry = make_readable_exclusive_migration_entry(pfn);\n\t\t\telse\n\t\t\t\tentry = make_readable_migration_entry(pfn);\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\n\t\t\t/*\n\t\t\t * pteval maps a zone device page and is therefore\n\t\t\t * a swap pte.\n\t\t\t */\n\t\t\tif (pte_swp_soft_dirty(pteval))\n\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\tif (pte_swp_uffd_wp(pteval))\n\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\tset_pte_at(mm, pvmw.address, pvmw.pte, swp_pte);\n\t\t\ttrace_set_migration_pte(pvmw.address, pte_val(swp_pte),\n\t\t\t\t\t\tcompound_order(&folio->page));\n\t\t\t/*\n\t\t\t * No need to invalidate here it will synchronize on\n\t\t\t * against the special swap migration pte.\n\t\t\t */\n\t\t} else if (PageHWPoison(subpage)) {\n\t\t\tpteval = swp_entry_to_pte(make_hwpoison_entry(subpage));\n\t\t\tif (folio_test_hugetlb(folio)) {\n\t\t\t\thugetlb_count_sub(folio_nr_pages(folio), mm);\n\t\t\t\tset_huge_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t} else {\n\t\t\t\tdec_mm_counter(mm, mm_counter(&folio->page));\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t}\n\n\t\t} else if (pte_unused(pteval) && !userfaultfd_armed(vma)) {\n\t\t\t/*\n\t\t\t * The guest indicated that the page content is of no\n\t\t\t * interest anymore. Simply discard the pte, vmscan\n\t\t\t * will take care of the rest.\n\t\t\t * A future reference will then fault in a new zero\n\t\t\t * page. When userfaultfd is active, we must not drop\n\t\t\t * this page though, as its main user (postcopy\n\t\t\t * migration) will not expect userfaults on already\n\t\t\t * copied pages.\n\t\t\t */\n\t\t\tdec_mm_counter(mm, mm_counter(&folio->page));\n\t\t\t/* We have to invalidate as we cleared the pte */\n\t\t\tmmu_notifier_invalidate_range(mm, address,\n\t\t\t\t\t\t      address + PAGE_SIZE);\n\t\t} else {\n\t\t\tswp_entry_t entry;\n\t\t\tpte_t swp_pte;\n\n\t\t\tif (arch_unmap_one(mm, vma, address, pteval) < 0) {\n\t\t\t\tif (folio_test_hugetlb(folio))\n\t\t\t\t\tset_huge_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\telse\n\t\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVM_BUG_ON_PAGE(pte_write(pteval) && folio_test_anon(folio) &&\n\t\t\t\t       !anon_exclusive, subpage);\n\t\t\tif (anon_exclusive &&\n\t\t\t    page_try_share_anon_rmap(subpage)) {\n\t\t\t\tif (folio_test_hugetlb(folio))\n\t\t\t\t\tset_huge_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\telse\n\t\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Store the pfn of the page in a special migration\n\t\t\t * pte. do_swap_page() will wait until the migration\n\t\t\t * pte is removed and then restart fault handling.\n\t\t\t */\n\t\t\tif (pte_write(pteval))\n\t\t\t\tentry = make_writable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(subpage));\n\t\t\telse if (anon_exclusive)\n\t\t\t\tentry = make_readable_exclusive_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(subpage));\n\t\t\telse\n\t\t\t\tentry = make_readable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(subpage));\n\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_soft_dirty(pteval))\n\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\tif (pte_uffd_wp(pteval))\n\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\tif (folio_test_hugetlb(folio))\n\t\t\t\tset_huge_pte_at(mm, address, pvmw.pte, swp_pte);\n\t\t\telse\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, swp_pte);\n\t\t\ttrace_set_migration_pte(address, pte_val(swp_pte),\n\t\t\t\t\t\tcompound_order(&folio->page));\n\t\t\t/*\n\t\t\t * No need to invalidate here it will synchronize on\n\t\t\t * against the special swap migration pte.\n\t\t\t */\n\t\t}\n\n\t\t/*\n\t\t * No need to call mmu_notifier_invalidate_range() it has be\n\t\t * done above for all cases requiring it to happen under page\n\t\t * table lock before mmu_notifier_invalidate_range_end()\n\t\t *\n\t\t * See Documentation/mm/mmu_notifier.rst\n\t\t */\n\t\tpage_remove_rmap(subpage, vma, folio_test_hugetlb(folio));\n\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\tmlock_page_drain_local();\n\t\tfolio_put(folio);\n\t}\n\n\tmmu_notifier_invalidate_range_end(&range);\n\n\treturn ret;\n}\n\n/**\n * try_to_migrate - try to replace all page table mappings with swap entries\n * @folio: the folio to replace page table entries for\n * @flags: action and flags\n *\n * Tries to remove all the page table entries which are mapping this folio and\n * replace them with special swap entries. Caller must hold the folio lock.\n */\nvoid try_to_migrate(struct folio *folio, enum ttu_flags flags)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_migrate_one,\n\t\t.arg = (void *)flags,\n\t\t.done = page_not_mapped,\n\t\t.anon_lock = folio_lock_anon_vma_read,\n\t};\n\n\t/*\n\t * Migration always ignores mlock and only supports TTU_RMAP_LOCKED and\n\t * TTU_SPLIT_HUGE_PMD and TTU_SYNC flags.\n\t */\n\tif (WARN_ON_ONCE(flags & ~(TTU_RMAP_LOCKED | TTU_SPLIT_HUGE_PMD |\n\t\t\t\t\tTTU_SYNC)))\n\t\treturn;\n\n\tif (folio_is_zone_device(folio) &&\n\t    (!folio_is_device_private(folio) && !folio_is_device_coherent(folio)))\n\t\treturn;\n\n\t/*\n\t * During exec, a temporary VMA is setup and later moved.\n\t * The VMA is moved under the anon_vma lock but not the\n\t * page tables leading to a race where migration cannot\n\t * find the migration ptes. Rather than increasing the\n\t * locking requirements of exec(), migration skips\n\t * temporary VMAs until after exec() completes.\n\t */\n\tif (!folio_test_ksm(folio) && folio_test_anon(folio))\n\t\trwc.invalid_vma = invalid_migration_vma;\n\n\tif (flags & TTU_RMAP_LOCKED)\n\t\trmap_walk_locked(folio, &rwc);\n\telse\n\t\trmap_walk(folio, &rwc);\n}\n\n#ifdef CONFIG_DEVICE_PRIVATE\nstruct make_exclusive_args {\n\tstruct mm_struct *mm;\n\tunsigned long address;\n\tvoid *owner;\n\tbool valid;\n};\n\nstatic bool page_make_device_exclusive_one(struct folio *folio,\n\t\tstruct vm_area_struct *vma, unsigned long address, void *priv)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tDEFINE_FOLIO_VMA_WALK(pvmw, folio, vma, address, 0);\n\tstruct make_exclusive_args *args = priv;\n\tpte_t pteval;\n\tstruct page *subpage;\n\tbool ret = true;\n\tstruct mmu_notifier_range range;\n\tswp_entry_t entry;\n\tpte_t swp_pte;\n\n\tmmu_notifier_range_init_owner(&range, MMU_NOTIFY_EXCLUSIVE, 0, vma,\n\t\t\t\t      vma->vm_mm, address, min(vma->vm_end,\n\t\t\t\t      address + folio_size(folio)),\n\t\t\t\t      args->owner);\n\tmmu_notifier_invalidate_range_start(&range);\n\n\twhile (page_vma_mapped_walk(&pvmw)) {\n\t\t/* Unexpected PMD-mapped THP? */\n\t\tVM_BUG_ON_FOLIO(!pvmw.pte, folio);\n\n\t\tif (!pte_present(*pvmw.pte)) {\n\t\t\tret = false;\n\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\tbreak;\n\t\t}\n\n\t\tsubpage = folio_page(folio,\n\t\t\t\tpte_pfn(*pvmw.pte) - folio_pfn(folio));\n\t\taddress = pvmw.address;\n\n\t\t/* Nuke the page table entry. */\n\t\tflush_cache_page(vma, address, pte_pfn(*pvmw.pte));\n\t\tpteval = ptep_clear_flush(vma, address, pvmw.pte);\n\n\t\t/* Set the dirty flag on the folio now the pte is gone. */\n\t\tif (pte_dirty(pteval))\n\t\t\tfolio_mark_dirty(folio);\n\n\t\t/*\n\t\t * Check that our target page is still mapped at the expected\n\t\t * address.\n\t\t */\n\t\tif (args->mm == mm && args->address == address &&\n\t\t    pte_write(pteval))\n\t\t\targs->valid = true;\n\n\t\t/*\n\t\t * Store the pfn of the page in a special migration\n\t\t * pte. do_swap_page() will wait until the migration\n\t\t * pte is removed and then restart fault handling.\n\t\t */\n\t\tif (pte_write(pteval))\n\t\t\tentry = make_writable_device_exclusive_entry(\n\t\t\t\t\t\t\tpage_to_pfn(subpage));\n\t\telse\n\t\t\tentry = make_readable_device_exclusive_entry(\n\t\t\t\t\t\t\tpage_to_pfn(subpage));\n\t\tswp_pte = swp_entry_to_pte(entry);\n\t\tif (pte_soft_dirty(pteval))\n\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\tif (pte_uffd_wp(pteval))\n\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\n\t\tset_pte_at(mm, address, pvmw.pte, swp_pte);\n\n\t\t/*\n\t\t * There is a reference on the page for the swap entry which has\n\t\t * been removed, so shouldn't take another.\n\t\t */\n\t\tpage_remove_rmap(subpage, vma, false);\n\t}\n\n\tmmu_notifier_invalidate_range_end(&range);\n\n\treturn ret;\n}\n\n/**\n * folio_make_device_exclusive - Mark the folio exclusively owned by a device.\n * @folio: The folio to replace page table entries for.\n * @mm: The mm_struct where the folio is expected to be mapped.\n * @address: Address where the folio is expected to be mapped.\n * @owner: passed to MMU_NOTIFY_EXCLUSIVE range notifier callbacks\n *\n * Tries to remove all the page table entries which are mapping this\n * folio and replace them with special device exclusive swap entries to\n * grant a device exclusive access to the folio.\n *\n * Context: Caller must hold the folio lock.\n * Return: false if the page is still mapped, or if it could not be unmapped\n * from the expected address. Otherwise returns true (success).\n */\nstatic bool folio_make_device_exclusive(struct folio *folio,\n\t\tstruct mm_struct *mm, unsigned long address, void *owner)\n{\n\tstruct make_exclusive_args args = {\n\t\t.mm = mm,\n\t\t.address = address,\n\t\t.owner = owner,\n\t\t.valid = false,\n\t};\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = page_make_device_exclusive_one,\n\t\t.done = page_not_mapped,\n\t\t.anon_lock = folio_lock_anon_vma_read,\n\t\t.arg = &args,\n\t};\n\n\t/*\n\t * Restrict to anonymous folios for now to avoid potential writeback\n\t * issues.\n\t */\n\tif (!folio_test_anon(folio))\n\t\treturn false;\n\n\trmap_walk(folio, &rwc);\n\n\treturn args.valid && !folio_mapcount(folio);\n}\n\n/**\n * make_device_exclusive_range() - Mark a range for exclusive use by a device\n * @mm: mm_struct of associated target process\n * @start: start of the region to mark for exclusive device access\n * @end: end address of region\n * @pages: returns the pages which were successfully marked for exclusive access\n * @owner: passed to MMU_NOTIFY_EXCLUSIVE range notifier to allow filtering\n *\n * Returns: number of pages found in the range by GUP. A page is marked for\n * exclusive access only if the page pointer is non-NULL.\n *\n * This function finds ptes mapping page(s) to the given address range, locks\n * them and replaces mappings with special swap entries preventing userspace CPU\n * access. On fault these entries are replaced with the original mapping after\n * calling MMU notifiers.\n *\n * A driver using this to program access from a device must use a mmu notifier\n * critical section to hold a device specific lock during programming. Once\n * programming is complete it should drop the page lock and reference after\n * which point CPU access to the page will revoke the exclusive access.\n */\nint make_device_exclusive_range(struct mm_struct *mm, unsigned long start,\n\t\t\t\tunsigned long end, struct page **pages,\n\t\t\t\tvoid *owner)\n{\n\tlong npages = (end - start) >> PAGE_SHIFT;\n\tlong i;\n\n\tnpages = get_user_pages_remote(mm, start, npages,\n\t\t\t\t       FOLL_GET | FOLL_WRITE | FOLL_SPLIT_PMD,\n\t\t\t\t       pages, NULL, NULL);\n\tif (npages < 0)\n\t\treturn npages;\n\n\tfor (i = 0; i < npages; i++, start += PAGE_SIZE) {\n\t\tstruct folio *folio = page_folio(pages[i]);\n\t\tif (PageTail(pages[i]) || !folio_trylock(folio)) {\n\t\t\tfolio_put(folio);\n\t\t\tpages[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!folio_make_device_exclusive(folio, mm, start, owner)) {\n\t\t\tfolio_unlock(folio);\n\t\t\tfolio_put(folio);\n\t\t\tpages[i] = NULL;\n\t\t}\n\t}\n\n\treturn npages;\n}\nEXPORT_SYMBOL_GPL(make_device_exclusive_range);\n#endif\n\nvoid __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}\n\nstatic struct anon_vma *rmap_walk_anon_lock(struct folio *folio,\n\t\t\t\t\t    struct rmap_walk_control *rwc)\n{\n\tstruct anon_vma *anon_vma;\n\n\tif (rwc->anon_lock)\n\t\treturn rwc->anon_lock(folio, rwc);\n\n\t/*\n\t * Note: remove_migration_ptes() cannot use folio_lock_anon_vma_read()\n\t * because that depends on page_mapped(); but not all its usages\n\t * are holding mmap_lock. Users without mmap_lock are required to\n\t * take a reference count to prevent the anon_vma disappearing\n\t */\n\tanon_vma = folio_anon_vma(folio);\n\tif (!anon_vma)\n\t\treturn NULL;\n\n\tif (anon_vma_trylock_read(anon_vma))\n\t\tgoto out;\n\n\tif (rwc->try_lock) {\n\t\tanon_vma = NULL;\n\t\trwc->contended = true;\n\t\tgoto out;\n\t}\n\n\tanon_vma_lock_read(anon_vma);\nout:\n\treturn anon_vma;\n}\n\n/*\n * rmap_walk_anon - do something to anonymous page using the object-based\n * rmap method\n * @page: the page to be handled\n * @rwc: control variable according to each walk type\n *\n * Find all the mappings of a page using the mapping pointer and the vma chains\n * contained in the anon_vma struct it points to.\n */\nstatic void rmap_walk_anon(struct folio *folio,\n\t\tstruct rmap_walk_control *rwc, bool locked)\n{\n\tstruct anon_vma *anon_vma;\n\tpgoff_t pgoff_start, pgoff_end;\n\tstruct anon_vma_chain *avc;\n\n\tif (locked) {\n\t\tanon_vma = folio_anon_vma(folio);\n\t\t/* anon_vma disappear under us? */\n\t\tVM_BUG_ON_FOLIO(!anon_vma, folio);\n\t} else {\n\t\tanon_vma = rmap_walk_anon_lock(folio, rwc);\n\t}\n\tif (!anon_vma)\n\t\treturn;\n\n\tpgoff_start = folio_pgoff(folio);\n\tpgoff_end = pgoff_start + folio_nr_pages(folio) - 1;\n\tanon_vma_interval_tree_foreach(avc, &anon_vma->rb_root,\n\t\t\tpgoff_start, pgoff_end) {\n\t\tstruct vm_area_struct *vma = avc->vma;\n\t\tunsigned long address = vma_address(&folio->page, vma);\n\n\t\tVM_BUG_ON_VMA(address == -EFAULT, vma);\n\t\tcond_resched();\n\n\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\tcontinue;\n\n\t\tif (!rwc->rmap_one(folio, vma, address, rwc->arg))\n\t\t\tbreak;\n\t\tif (rwc->done && rwc->done(folio))\n\t\t\tbreak;\n\t}\n\n\tif (!locked)\n\t\tanon_vma_unlock_read(anon_vma);\n}\n\n/*\n * rmap_walk_file - do something to file page using the object-based rmap method\n * @page: the page to be handled\n * @rwc: control variable according to each walk type\n *\n * Find all the mappings of a page using the mapping pointer and the vma chains\n * contained in the address_space struct it points to.\n */\nstatic void rmap_walk_file(struct folio *folio,\n\t\tstruct rmap_walk_control *rwc, bool locked)\n{\n\tstruct address_space *mapping = folio_mapping(folio);\n\tpgoff_t pgoff_start, pgoff_end;\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * The page lock not only makes sure that page->mapping cannot\n\t * suddenly be NULLified by truncation, it makes sure that the\n\t * structure at mapping cannot be freed and reused yet,\n\t * so we can safely take mapping->i_mmap_rwsem.\n\t */\n\tVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);\n\n\tif (!mapping)\n\t\treturn;\n\n\tpgoff_start = folio_pgoff(folio);\n\tpgoff_end = pgoff_start + folio_nr_pages(folio) - 1;\n\tif (!locked) {\n\t\tif (i_mmap_trylock_read(mapping))\n\t\t\tgoto lookup;\n\n\t\tif (rwc->try_lock) {\n\t\t\trwc->contended = true;\n\t\t\treturn;\n\t\t}\n\n\t\ti_mmap_lock_read(mapping);\n\t}\nlookup:\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap,\n\t\t\tpgoff_start, pgoff_end) {\n\t\tunsigned long address = vma_address(&folio->page, vma);\n\n\t\tVM_BUG_ON_VMA(address == -EFAULT, vma);\n\t\tcond_resched();\n\n\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\tcontinue;\n\n\t\tif (!rwc->rmap_one(folio, vma, address, rwc->arg))\n\t\t\tgoto done;\n\t\tif (rwc->done && rwc->done(folio))\n\t\t\tgoto done;\n\t}\n\ndone:\n\tif (!locked)\n\t\ti_mmap_unlock_read(mapping);\n}\n\nvoid rmap_walk(struct folio *folio, struct rmap_walk_control *rwc)\n{\n\tif (unlikely(folio_test_ksm(folio)))\n\t\trmap_walk_ksm(folio, rwc);\n\telse if (folio_test_anon(folio))\n\t\trmap_walk_anon(folio, rwc, false);\n\telse\n\t\trmap_walk_file(folio, rwc, false);\n}\n\n/* Like rmap_walk, but caller holds relevant rmap lock */\nvoid rmap_walk_locked(struct folio *folio, struct rmap_walk_control *rwc)\n{\n\t/* no ksm support for now */\n\tVM_BUG_ON_FOLIO(folio_test_ksm(folio), folio);\n\tif (folio_test_anon(folio))\n\t\trmap_walk_anon(folio, rwc, true);\n\telse\n\t\trmap_walk_file(folio, rwc, true);\n}\n\n#ifdef CONFIG_HUGETLB_PAGE\n/*\n * The following two functions are for anonymous (private mapped) hugepages.\n * Unlike common anonymous pages, anonymous hugepages have no accounting code\n * and no lru code, because we handle hugepages differently from common pages.\n *\n * RMAP_COMPOUND is ignored.\n */\nvoid hugepage_add_anon_rmap(struct page *page, struct vm_area_struct *vma,\n\t\t\t    unsigned long address, rmap_t flags)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\tint first;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!anon_vma);\n\t/* address might be in next vma when migration races vma_adjust */\n\tfirst = atomic_inc_and_test(compound_mapcount_ptr(page));\n\tVM_BUG_ON_PAGE(!first && (flags & RMAP_EXCLUSIVE), page);\n\tVM_BUG_ON_PAGE(!first && PageAnonExclusive(page), page);\n\tif (first)\n\t\t__page_set_anon_rmap(page, vma, address,\n\t\t\t\t     !!(flags & RMAP_EXCLUSIVE));\n}\n\nvoid hugepage_add_new_anon_rmap(struct page *page,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tBUG_ON(address < vma->vm_start || address >= vma->vm_end);\n\tatomic_set(compound_mapcount_ptr(page), 0);\n\tatomic_set(compound_pincount_ptr(page), 0);\n\n\t__page_set_anon_rmap(page, vma, address, 1);\n}\n#endif /* CONFIG_HUGETLB_PAGE */\n"], "fixing_code": ["/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_RMAP_H\n#define _LINUX_RMAP_H\n/*\n * Declarations for Reverse Mapping functions in mm/rmap.c\n */\n\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/rwsem.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n\n/*\n * The anon_vma heads a list of private \"related\" vmas, to scan if\n * an anonymous page pointing to this anon_vma needs to be unmapped:\n * the vmas on the list will be related by forking, or by splitting.\n *\n * Since vmas come and go as they are split and merged (particularly\n * in mprotect), the mapping field of an anonymous page cannot point\n * directly to a vma: instead it points to an anon_vma, on whose list\n * the related vmas can be easily linked or unlinked.\n *\n * After unlinking the last vma on the list, we must garbage collect\n * the anon_vma object itself: we're guaranteed no page can be\n * pointing to this anon_vma once its vma list is empty.\n */\nstruct anon_vma {\n\tstruct anon_vma *root;\t\t/* Root of this anon_vma tree */\n\tstruct rw_semaphore rwsem;\t/* W: modification, R: walking the list */\n\t/*\n\t * The refcount is taken on an anon_vma when there is no\n\t * guarantee that the vma of page tables will exist for\n\t * the duration of the operation. A caller that takes\n\t * the reference is responsible for clearing up the\n\t * anon_vma if they are the last user on release\n\t */\n\tatomic_t refcount;\n\n\t/*\n\t * Count of child anon_vmas. Equals to the count of all anon_vmas that\n\t * have ->parent pointing to this one, including itself.\n\t *\n\t * This counter is used for making decision about reusing anon_vma\n\t * instead of forking new one. See comments in function anon_vma_clone.\n\t */\n\tunsigned long num_children;\n\t/* Count of VMAs whose ->anon_vma pointer points to this object. */\n\tunsigned long num_active_vmas;\n\n\tstruct anon_vma *parent;\t/* Parent of this anon_vma */\n\n\t/*\n\t * NOTE: the LSB of the rb_root.rb_node is set by\n\t * mm_take_all_locks() _after_ taking the above lock. So the\n\t * rb_root must only be read/written after taking the above lock\n\t * to be sure to see a valid next pointer. The LSB bit itself\n\t * is serialized by a system wide lock only visible to\n\t * mm_take_all_locks() (mm_all_locks_mutex).\n\t */\n\n\t/* Interval tree of private \"related\" vmas */\n\tstruct rb_root_cached rb_root;\n};\n\n/*\n * The copy-on-write semantics of fork mean that an anon_vma\n * can become associated with multiple processes. Furthermore,\n * each child process will have its own anon_vma, where new\n * pages for that process are instantiated.\n *\n * This structure allows us to find the anon_vmas associated\n * with a VMA, or the VMAs associated with an anon_vma.\n * The \"same_vma\" list contains the anon_vma_chains linking\n * all the anon_vmas associated with this VMA.\n * The \"rb\" field indexes on an interval tree the anon_vma_chains\n * which link all the VMAs associated with this anon_vma.\n */\nstruct anon_vma_chain {\n\tstruct vm_area_struct *vma;\n\tstruct anon_vma *anon_vma;\n\tstruct list_head same_vma;   /* locked by mmap_lock & page_table_lock */\n\tstruct rb_node rb;\t\t\t/* locked by anon_vma->rwsem */\n\tunsigned long rb_subtree_last;\n#ifdef CONFIG_DEBUG_VM_RB\n\tunsigned long cached_vma_start, cached_vma_last;\n#endif\n};\n\nenum ttu_flags {\n\tTTU_SPLIT_HUGE_PMD\t= 0x4,\t/* split huge PMD if any */\n\tTTU_IGNORE_MLOCK\t= 0x8,\t/* ignore mlock */\n\tTTU_SYNC\t\t= 0x10,\t/* avoid racy checks with PVMW_SYNC */\n\tTTU_IGNORE_HWPOISON\t= 0x20,\t/* corrupted page is recoverable */\n\tTTU_BATCH_FLUSH\t\t= 0x40,\t/* Batch TLB flushes where possible\n\t\t\t\t\t * and caller guarantees they will\n\t\t\t\t\t * do a final flush if necessary */\n\tTTU_RMAP_LOCKED\t\t= 0x80,\t/* do not grab rmap lock:\n\t\t\t\t\t * caller holds it */\n};\n\n#ifdef CONFIG_MMU\nstatic inline void get_anon_vma(struct anon_vma *anon_vma)\n{\n\tatomic_inc(&anon_vma->refcount);\n}\n\nvoid __put_anon_vma(struct anon_vma *anon_vma);\n\nstatic inline void put_anon_vma(struct anon_vma *anon_vma)\n{\n\tif (atomic_dec_and_test(&anon_vma->refcount))\n\t\t__put_anon_vma(anon_vma);\n}\n\nstatic inline void anon_vma_lock_write(struct anon_vma *anon_vma)\n{\n\tdown_write(&anon_vma->root->rwsem);\n}\n\nstatic inline void anon_vma_unlock_write(struct anon_vma *anon_vma)\n{\n\tup_write(&anon_vma->root->rwsem);\n}\n\nstatic inline void anon_vma_lock_read(struct anon_vma *anon_vma)\n{\n\tdown_read(&anon_vma->root->rwsem);\n}\n\nstatic inline int anon_vma_trylock_read(struct anon_vma *anon_vma)\n{\n\treturn down_read_trylock(&anon_vma->root->rwsem);\n}\n\nstatic inline void anon_vma_unlock_read(struct anon_vma *anon_vma)\n{\n\tup_read(&anon_vma->root->rwsem);\n}\n\n\n/*\n * anon_vma helper functions.\n */\nvoid anon_vma_init(void);\t/* create anon_vma_cachep */\nint  __anon_vma_prepare(struct vm_area_struct *);\nvoid unlink_anon_vmas(struct vm_area_struct *);\nint anon_vma_clone(struct vm_area_struct *, struct vm_area_struct *);\nint anon_vma_fork(struct vm_area_struct *, struct vm_area_struct *);\n\nstatic inline int anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tif (likely(vma->anon_vma))\n\t\treturn 0;\n\n\treturn __anon_vma_prepare(vma);\n}\n\nstatic inline void anon_vma_merge(struct vm_area_struct *vma,\n\t\t\t\t  struct vm_area_struct *next)\n{\n\tVM_BUG_ON_VMA(vma->anon_vma != next->anon_vma, vma);\n\tunlink_anon_vmas(next);\n}\n\nstruct anon_vma *page_get_anon_vma(struct page *page);\n\n/* RMAP flags, currently only relevant for some anon rmap operations. */\ntypedef int __bitwise rmap_t;\n\n/*\n * No special request: if the page is a subpage of a compound page, it is\n * mapped via a PTE. The mapped (sub)page is possibly shared between processes.\n */\n#define RMAP_NONE\t\t((__force rmap_t)0)\n\n/* The (sub)page is exclusive to a single process. */\n#define RMAP_EXCLUSIVE\t\t((__force rmap_t)BIT(0))\n\n/*\n * The compound page is not mapped via PTEs, but instead via a single PMD and\n * should be accounted accordingly.\n */\n#define RMAP_COMPOUND\t\t((__force rmap_t)BIT(1))\n\n/*\n * rmap interfaces called when adding or removing pte of page\n */\nvoid page_move_anon_rmap(struct page *, struct vm_area_struct *);\nvoid page_add_anon_rmap(struct page *, struct vm_area_struct *,\n\t\tunsigned long address, rmap_t flags);\nvoid page_add_new_anon_rmap(struct page *, struct vm_area_struct *,\n\t\tunsigned long address);\nvoid page_add_file_rmap(struct page *, struct vm_area_struct *,\n\t\tbool compound);\nvoid page_remove_rmap(struct page *, struct vm_area_struct *,\n\t\tbool compound);\n\nvoid hugepage_add_anon_rmap(struct page *, struct vm_area_struct *,\n\t\tunsigned long address, rmap_t flags);\nvoid hugepage_add_new_anon_rmap(struct page *, struct vm_area_struct *,\n\t\tunsigned long address);\n\nstatic inline void __page_dup_rmap(struct page *page, bool compound)\n{\n\tatomic_inc(compound ? compound_mapcount_ptr(page) : &page->_mapcount);\n}\n\nstatic inline void page_dup_file_rmap(struct page *page, bool compound)\n{\n\t__page_dup_rmap(page, compound);\n}\n\n/**\n * page_try_dup_anon_rmap - try duplicating a mapping of an already mapped\n *\t\t\t    anonymous page\n * @page: the page to duplicate the mapping for\n * @compound: the page is mapped as compound or as a small page\n * @vma: the source vma\n *\n * The caller needs to hold the PT lock and the vma->vma_mm->write_protect_seq.\n *\n * Duplicating the mapping can only fail if the page may be pinned; device\n * private pages cannot get pinned and consequently this function cannot fail.\n *\n * If duplicating the mapping succeeds, the page has to be mapped R/O into\n * the parent and the child. It must *not* get mapped writable after this call.\n *\n * Returns 0 if duplicating the mapping succeeded. Returns -EBUSY otherwise.\n */\nstatic inline int page_try_dup_anon_rmap(struct page *page, bool compound,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(!PageAnon(page), page);\n\n\t/*\n\t * No need to check+clear for already shared pages, including KSM\n\t * pages.\n\t */\n\tif (!PageAnonExclusive(page))\n\t\tgoto dup;\n\n\t/*\n\t * If this page may have been pinned by the parent process,\n\t * don't allow to duplicate the mapping but instead require to e.g.,\n\t * copy the page immediately for the child so that we'll always\n\t * guarantee the pinned page won't be randomly replaced in the\n\t * future on write faults.\n\t */\n\tif (likely(!is_device_private_page(page) &&\n\t    unlikely(page_needs_cow_for_dma(vma, page))))\n\t\treturn -EBUSY;\n\n\tClearPageAnonExclusive(page);\n\t/*\n\t * It's okay to share the anon page between both processes, mapping\n\t * the page R/O into both processes.\n\t */\ndup:\n\t__page_dup_rmap(page, compound);\n\treturn 0;\n}\n\n/**\n * page_try_share_anon_rmap - try marking an exclusive anonymous page possibly\n *\t\t\t      shared to prepare for KSM or temporary unmapping\n * @page: the exclusive anonymous page to try marking possibly shared\n *\n * The caller needs to hold the PT lock and has to have the page table entry\n * cleared/invalidated+flushed, to properly sync against GUP-fast.\n *\n * This is similar to page_try_dup_anon_rmap(), however, not used during fork()\n * to duplicate a mapping, but instead to prepare for KSM or temporarily\n * unmapping a page (swap, migration) via page_remove_rmap().\n *\n * Marking the page shared can only fail if the page may be pinned; device\n * private pages cannot get pinned and consequently this function cannot fail.\n *\n * Returns 0 if marking the page possibly shared succeeded. Returns -EBUSY\n * otherwise.\n */\nstatic inline int page_try_share_anon_rmap(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageAnon(page) || !PageAnonExclusive(page), page);\n\n\t/* See page_try_dup_anon_rmap(). */\n\tif (likely(!is_device_private_page(page) &&\n\t    unlikely(page_maybe_dma_pinned(page))))\n\t\treturn -EBUSY;\n\n\tClearPageAnonExclusive(page);\n\treturn 0;\n}\n\n/*\n * Called from mm/vmscan.c to handle paging out\n */\nint folio_referenced(struct folio *, int is_locked,\n\t\t\tstruct mem_cgroup *memcg, unsigned long *vm_flags);\n\nvoid try_to_migrate(struct folio *folio, enum ttu_flags flags);\nvoid try_to_unmap(struct folio *, enum ttu_flags flags);\n\nint make_device_exclusive_range(struct mm_struct *mm, unsigned long start,\n\t\t\t\tunsigned long end, struct page **pages,\n\t\t\t\tvoid *arg);\n\n/* Avoid racy checks */\n#define PVMW_SYNC\t\t(1 << 0)\n/* Look for migration entries rather than present PTEs */\n#define PVMW_MIGRATION\t\t(1 << 1)\n\nstruct page_vma_mapped_walk {\n\tunsigned long pfn;\n\tunsigned long nr_pages;\n\tpgoff_t pgoff;\n\tstruct vm_area_struct *vma;\n\tunsigned long address;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\tunsigned int flags;\n};\n\n#define DEFINE_PAGE_VMA_WALK(name, _page, _vma, _address, _flags)\t\\\n\tstruct page_vma_mapped_walk name = {\t\t\t\t\\\n\t\t.pfn = page_to_pfn(_page),\t\t\t\t\\\n\t\t.nr_pages = compound_nr(_page),\t\t\t\t\\\n\t\t.pgoff = page_to_pgoff(_page),\t\t\t\t\\\n\t\t.vma = _vma,\t\t\t\t\t\t\\\n\t\t.address = _address,\t\t\t\t\t\\\n\t\t.flags = _flags,\t\t\t\t\t\\\n\t}\n\n#define DEFINE_FOLIO_VMA_WALK(name, _folio, _vma, _address, _flags)\t\\\n\tstruct page_vma_mapped_walk name = {\t\t\t\t\\\n\t\t.pfn = folio_pfn(_folio),\t\t\t\t\\\n\t\t.nr_pages = folio_nr_pages(_folio),\t\t\t\\\n\t\t.pgoff = folio_pgoff(_folio),\t\t\t\t\\\n\t\t.vma = _vma,\t\t\t\t\t\t\\\n\t\t.address = _address,\t\t\t\t\t\\\n\t\t.flags = _flags,\t\t\t\t\t\\\n\t}\n\nstatic inline void page_vma_mapped_walk_done(struct page_vma_mapped_walk *pvmw)\n{\n\t/* HugeTLB pte is set to the relevant page table entry without pte_mapped. */\n\tif (pvmw->pte && !is_vm_hugetlb_page(pvmw->vma))\n\t\tpte_unmap(pvmw->pte);\n\tif (pvmw->ptl)\n\t\tspin_unlock(pvmw->ptl);\n}\n\nbool page_vma_mapped_walk(struct page_vma_mapped_walk *pvmw);\n\n/*\n * Used by swapoff to help locate where page is expected in vma.\n */\nunsigned long page_address_in_vma(struct page *, struct vm_area_struct *);\n\n/*\n * Cleans the PTEs of shared mappings.\n * (and since clean PTEs should also be readonly, write protects them too)\n *\n * returns the number of cleaned PTEs.\n */\nint folio_mkclean(struct folio *);\n\nint pfn_mkclean_range(unsigned long pfn, unsigned long nr_pages, pgoff_t pgoff,\n\t\t      struct vm_area_struct *vma);\n\nvoid remove_migration_ptes(struct folio *src, struct folio *dst, bool locked);\n\nint page_mapped_in_vma(struct page *page, struct vm_area_struct *vma);\n\n/*\n * rmap_walk_control: To control rmap traversing for specific needs\n *\n * arg: passed to rmap_one() and invalid_vma()\n * try_lock: bail out if the rmap lock is contended\n * contended: indicate the rmap traversal bailed out due to lock contention\n * rmap_one: executed on each vma where page is mapped\n * done: for checking traversing termination condition\n * anon_lock: for getting anon_lock by optimized way rather than default\n * invalid_vma: for skipping uninterested vma\n */\nstruct rmap_walk_control {\n\tvoid *arg;\n\tbool try_lock;\n\tbool contended;\n\t/*\n\t * Return false if page table scanning in rmap_walk should be stopped.\n\t * Otherwise, return true.\n\t */\n\tbool (*rmap_one)(struct folio *folio, struct vm_area_struct *vma,\n\t\t\t\t\tunsigned long addr, void *arg);\n\tint (*done)(struct folio *folio);\n\tstruct anon_vma *(*anon_lock)(struct folio *folio,\n\t\t\t\t      struct rmap_walk_control *rwc);\n\tbool (*invalid_vma)(struct vm_area_struct *vma, void *arg);\n};\n\nvoid rmap_walk(struct folio *folio, struct rmap_walk_control *rwc);\nvoid rmap_walk_locked(struct folio *folio, struct rmap_walk_control *rwc);\n\n/*\n * Called by memory-failure.c to kill processes.\n */\nstruct anon_vma *folio_lock_anon_vma_read(struct folio *folio,\n\t\t\t\t\t  struct rmap_walk_control *rwc);\nvoid page_unlock_anon_vma_read(struct anon_vma *anon_vma);\n\n#else\t/* !CONFIG_MMU */\n\n#define anon_vma_init()\t\tdo {} while (0)\n#define anon_vma_prepare(vma)\t(0)\n#define anon_vma_link(vma)\tdo {} while (0)\n\nstatic inline int folio_referenced(struct folio *folio, int is_locked,\n\t\t\t\t  struct mem_cgroup *memcg,\n\t\t\t\t  unsigned long *vm_flags)\n{\n\t*vm_flags = 0;\n\treturn 0;\n}\n\nstatic inline void try_to_unmap(struct folio *folio, enum ttu_flags flags)\n{\n}\n\nstatic inline int folio_mkclean(struct folio *folio)\n{\n\treturn 0;\n}\n#endif\t/* CONFIG_MMU */\n\nstatic inline int page_mkclean(struct page *page)\n{\n\treturn folio_mkclean(page_folio(page));\n}\n#endif\t/* _LINUX_RMAP_H */\n", "/*\n * mm/rmap.c - physical to virtual reverse mappings\n *\n * Copyright 2001, Rik van Riel <riel@conectiva.com.br>\n * Released under the General Public License (GPL).\n *\n * Simple, low overhead reverse mapping scheme.\n * Please try to keep this thing as modular as possible.\n *\n * Provides methods for unmapping each kind of mapped page:\n * the anon methods track anonymous pages, and\n * the file methods track pages belonging to an inode.\n *\n * Original design by Rik van Riel <riel@conectiva.com.br> 2001\n * File methods by Dave McCracken <dmccr@us.ibm.com> 2003, 2004\n * Anonymous methods by Andrea Arcangeli <andrea@suse.de> 2004\n * Contributions by Hugh Dickins 2003, 2004\n */\n\n/*\n * Lock ordering in mm:\n *\n * inode->i_rwsem\t(while writing or truncating, not reading or faulting)\n *   mm->mmap_lock\n *     mapping->invalidate_lock (in filemap_fault)\n *       page->flags PG_locked (lock_page)   * (see hugetlbfs below)\n *         hugetlbfs_i_mmap_rwsem_key (in huge_pmd_share)\n *           mapping->i_mmap_rwsem\n *             hugetlb_fault_mutex (hugetlbfs specific page fault mutex)\n *             anon_vma->rwsem\n *               mm->page_table_lock or pte_lock\n *                 swap_lock (in swap_duplicate, swap_info_get)\n *                   mmlist_lock (in mmput, drain_mmlist and others)\n *                   mapping->private_lock (in block_dirty_folio)\n *                     folio_lock_memcg move_lock (in block_dirty_folio)\n *                       i_pages lock (widely used)\n *                         lruvec->lru_lock (in folio_lruvec_lock_irq)\n *                   inode->i_lock (in set_page_dirty's __mark_inode_dirty)\n *                   bdi.wb->list_lock (in set_page_dirty's __mark_inode_dirty)\n *                     sb_lock (within inode_lock in fs/fs-writeback.c)\n *                     i_pages lock (widely used, in set_page_dirty,\n *                               in arch-dependent flush_dcache_mmap_lock,\n *                               within bdi.wb->list_lock in __sync_single_inode)\n *\n * anon_vma->rwsem,mapping->i_mmap_rwsem   (memory_failure, collect_procs_anon)\n *   ->tasklist_lock\n *     pte map lock\n *\n * * hugetlbfs PageHuge() pages take locks in this order:\n *         mapping->i_mmap_rwsem\n *           hugetlb_fault_mutex (hugetlbfs specific page fault mutex)\n *             page->flags PG_locked (lock_page)\n */\n\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/memcontrol.h>\n#include <linux/mmu_notifier.h>\n#include <linux/migrate.h>\n#include <linux/hugetlb.h>\n#include <linux/huge_mm.h>\n#include <linux/backing-dev.h>\n#include <linux/page_idle.h>\n#include <linux/memremap.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm_inline.h>\n\n#include <asm/tlbflush.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/tlb.h>\n#include <trace/events/migrate.h>\n\n#include \"internal.h\"\n\nstatic struct kmem_cache *anon_vma_cachep;\nstatic struct kmem_cache *anon_vma_chain_cachep;\n\nstatic inline struct anon_vma *anon_vma_alloc(void)\n{\n\tstruct anon_vma *anon_vma;\n\n\tanon_vma = kmem_cache_alloc(anon_vma_cachep, GFP_KERNEL);\n\tif (anon_vma) {\n\t\tatomic_set(&anon_vma->refcount, 1);\n\t\tanon_vma->num_children = 0;\n\t\tanon_vma->num_active_vmas = 0;\n\t\tanon_vma->parent = anon_vma;\n\t\t/*\n\t\t * Initialise the anon_vma root to point to itself. If called\n\t\t * from fork, the root will be reset to the parents anon_vma.\n\t\t */\n\t\tanon_vma->root = anon_vma;\n\t}\n\n\treturn anon_vma;\n}\n\nstatic inline void anon_vma_free(struct anon_vma *anon_vma)\n{\n\tVM_BUG_ON(atomic_read(&anon_vma->refcount));\n\n\t/*\n\t * Synchronize against folio_lock_anon_vma_read() such that\n\t * we can safely hold the lock without the anon_vma getting\n\t * freed.\n\t *\n\t * Relies on the full mb implied by the atomic_dec_and_test() from\n\t * put_anon_vma() against the acquire barrier implied by\n\t * down_read_trylock() from folio_lock_anon_vma_read(). This orders:\n\t *\n\t * folio_lock_anon_vma_read()\tVS\tput_anon_vma()\n\t *   down_read_trylock()\t\t  atomic_dec_and_test()\n\t *   LOCK\t\t\t\t  MB\n\t *   atomic_read()\t\t\t  rwsem_is_locked()\n\t *\n\t * LOCK should suffice since the actual taking of the lock must\n\t * happen _before_ what follows.\n\t */\n\tmight_sleep();\n\tif (rwsem_is_locked(&anon_vma->root->rwsem)) {\n\t\tanon_vma_lock_write(anon_vma);\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n\n\tkmem_cache_free(anon_vma_cachep, anon_vma);\n}\n\nstatic inline struct anon_vma_chain *anon_vma_chain_alloc(gfp_t gfp)\n{\n\treturn kmem_cache_alloc(anon_vma_chain_cachep, gfp);\n}\n\nstatic void anon_vma_chain_free(struct anon_vma_chain *anon_vma_chain)\n{\n\tkmem_cache_free(anon_vma_chain_cachep, anon_vma_chain);\n}\n\nstatic void anon_vma_chain_link(struct vm_area_struct *vma,\n\t\t\t\tstruct anon_vma_chain *avc,\n\t\t\t\tstruct anon_vma *anon_vma)\n{\n\tavc->vma = vma;\n\tavc->anon_vma = anon_vma;\n\tlist_add(&avc->same_vma, &vma->anon_vma_chain);\n\tanon_vma_interval_tree_insert(avc, &anon_vma->rb_root);\n}\n\n/**\n * __anon_vma_prepare - attach an anon_vma to a memory region\n * @vma: the memory region in question\n *\n * This makes sure the memory mapping described by 'vma' has\n * an 'anon_vma' attached to it, so that we can associate the\n * anonymous pages mapped into it with that anon_vma.\n *\n * The common case will be that we already have one, which\n * is handled inline by anon_vma_prepare(). But if\n * not we either need to find an adjacent mapping that we\n * can re-use the anon_vma from (very common when the only\n * reason for splitting a vma has been mprotect()), or we\n * allocate a new one.\n *\n * Anon-vma allocations are very subtle, because we may have\n * optimistically looked up an anon_vma in folio_lock_anon_vma_read()\n * and that may actually touch the rwsem even in the newly\n * allocated vma (it depends on RCU to make sure that the\n * anon_vma isn't actually destroyed).\n *\n * As a result, we need to do proper anon_vma locking even\n * for the new allocation. At the same time, we do not want\n * to do any locking for the common case of already having\n * an anon_vma.\n *\n * This must be called with the mmap_lock held for reading.\n */\nint __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tanon_vma->num_children++; /* self-parent link for new root */\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\tanon_vma->num_active_vmas++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}\n\n/*\n * This is a useful helper function for locking the anon_vma root as\n * we traverse the vma->anon_vma_chain, looping over anon_vma's that\n * have the same vma.\n *\n * Such anon_vma's should have the same root, so you'd expect to see\n * just a single mutex_lock for the whole traversal.\n */\nstatic inline struct anon_vma *lock_anon_vma_root(struct anon_vma *root, struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *new_root = anon_vma->root;\n\tif (new_root != root) {\n\t\tif (WARN_ON_ONCE(root))\n\t\t\tup_write(&root->rwsem);\n\t\troot = new_root;\n\t\tdown_write(&root->rwsem);\n\t}\n\treturn root;\n}\n\nstatic inline void unlock_anon_vma_root(struct anon_vma *root)\n{\n\tif (root)\n\t\tup_write(&root->rwsem);\n}\n\n/*\n * Attach the anon_vmas from src to dst.\n * Returns 0 on success, -ENOMEM on failure.\n *\n * anon_vma_clone() is called by __vma_adjust(), __split_vma(), copy_vma() and\n * anon_vma_fork(). The first three want an exact copy of src, while the last\n * one, anon_vma_fork(), may try to reuse an existing anon_vma to prevent\n * endless growth of anon_vma. Since dst->anon_vma is set to NULL before call,\n * we can identify this case by checking (!dst->anon_vma && src->anon_vma).\n *\n * If (!dst->anon_vma && src->anon_vma) is true, this function tries to find\n * and reuse existing anon_vma which has no vmas and only one child anon_vma.\n * This prevents degradation of anon_vma hierarchy to endless linear chain in\n * case of constantly forking task. On the other hand, an anon_vma with more\n * than one child isn't reused even if there was no alive vma, thus rmap\n * walker has a good chance of avoiding scanning the whole hierarchy when it\n * searches where page is mapped.\n */\nint anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n\tstruct anon_vma_chain *avc, *pavc;\n\tstruct anon_vma *root = NULL;\n\n\tlist_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma;\n\n\t\tavc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!avc)) {\n\t\t\tunlock_anon_vma_root(root);\n\t\t\troot = NULL;\n\t\t\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\t\t\tif (!avc)\n\t\t\t\tgoto enomem_failure;\n\t\t}\n\t\tanon_vma = pavc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_chain_link(dst, avc, anon_vma);\n\n\t\t/*\n\t\t * Reuse existing anon_vma if it has no vma and only one\n\t\t * anon_vma child.\n\t\t *\n\t\t * Root anon_vma is never reused:\n\t\t * it has self-parent reference and at least one child.\n\t\t */\n\t\tif (!dst->anon_vma && src->anon_vma &&\n\t\t    anon_vma->num_children < 2 &&\n\t\t    anon_vma->num_active_vmas == 0)\n\t\t\tdst->anon_vma = anon_vma;\n\t}\n\tif (dst->anon_vma)\n\t\tdst->anon_vma->num_active_vmas++;\n\tunlock_anon_vma_root(root);\n\treturn 0;\n\n enomem_failure:\n\t/*\n\t * dst->anon_vma is dropped here otherwise its degree can be incorrectly\n\t * decremented in unlink_anon_vmas().\n\t * We can safely do this because callers of anon_vma_clone() don't care\n\t * about dst->anon_vma if anon_vma_clone() failed.\n\t */\n\tdst->anon_vma = NULL;\n\tunlink_anon_vmas(dst);\n\treturn -ENOMEM;\n}\n\n/*\n * Attach vma to its own anon_vma, as well as to the anon_vmas that\n * the corresponding VMA in the parent process is attached to.\n * Returns 0 on success, non-zero on failure.\n */\nint anon_vma_fork(struct vm_area_struct *vma, struct vm_area_struct *pvma)\n{\n\tstruct anon_vma_chain *avc;\n\tstruct anon_vma *anon_vma;\n\tint error;\n\n\t/* Don't bother if the parent process has no anon_vma here. */\n\tif (!pvma->anon_vma)\n\t\treturn 0;\n\n\t/* Drop inherited anon_vma, we'll reuse existing or allocate new. */\n\tvma->anon_vma = NULL;\n\n\t/*\n\t * First, attach the new VMA to the parent VMA's anon_vmas,\n\t * so rmap can find non-COWed pages in child processes.\n\t */\n\terror = anon_vma_clone(vma, pvma);\n\tif (error)\n\t\treturn error;\n\n\t/* An existing anon_vma has been reused, all done then. */\n\tif (vma->anon_vma)\n\t\treturn 0;\n\n\t/* Then add our own anon_vma. */\n\tanon_vma = anon_vma_alloc();\n\tif (!anon_vma)\n\t\tgoto out_error;\n\tanon_vma->num_active_vmas++;\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_error_free_anon_vma;\n\n\t/*\n\t * The root anon_vma's rwsem is the lock actually used when we\n\t * lock any of the anon_vmas in this anon_vma tree.\n\t */\n\tanon_vma->root = pvma->anon_vma->root;\n\tanon_vma->parent = pvma->anon_vma;\n\t/*\n\t * With refcounts, an anon_vma can stay around longer than the\n\t * process it belongs to. The root anon_vma needs to be pinned until\n\t * this anon_vma is freed, because the lock lives in the root.\n\t */\n\tget_anon_vma(anon_vma->root);\n\t/* Mark this anon_vma as the one where our new (COWed) pages go. */\n\tvma->anon_vma = anon_vma;\n\tanon_vma_lock_write(anon_vma);\n\tanon_vma_chain_link(vma, avc, anon_vma);\n\tanon_vma->parent->num_children++;\n\tanon_vma_unlock_write(anon_vma);\n\n\treturn 0;\n\n out_error_free_anon_vma:\n\tput_anon_vma(anon_vma);\n out_error:\n\tunlink_anon_vmas(vma);\n\treturn -ENOMEM;\n}\n\nvoid unlink_anon_vmas(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc, *next;\n\tstruct anon_vma *root = NULL;\n\n\t/*\n\t * Unlink each anon_vma chained to the VMA.  This list is ordered\n\t * from newest to oldest, ensuring the root anon_vma gets freed last.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_interval_tree_remove(avc, &anon_vma->rb_root);\n\n\t\t/*\n\t\t * Leave empty anon_vmas on the list - we'll need\n\t\t * to free them outside the lock.\n\t\t */\n\t\tif (RB_EMPTY_ROOT(&anon_vma->rb_root.rb_root)) {\n\t\t\tanon_vma->parent->num_children--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n\tif (vma->anon_vma) {\n\t\tvma->anon_vma->num_active_vmas--;\n\n\t\t/*\n\t\t * vma would still be needed after unlink, and anon_vma will be prepared\n\t\t * when handle fault.\n\t\t */\n\t\tvma->anon_vma = NULL;\n\t}\n\tunlock_anon_vma_root(root);\n\n\t/*\n\t * Iterate the list once more, it now only contains empty and unlinked\n\t * anon_vmas, destroy them. Could not do before due to __put_anon_vma()\n\t * needing to write-acquire the anon_vma->root->rwsem.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\tVM_WARN_ON(anon_vma->num_children);\n\t\tVM_WARN_ON(anon_vma->num_active_vmas);\n\t\tput_anon_vma(anon_vma);\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n}\n\nstatic void anon_vma_ctor(void *data)\n{\n\tstruct anon_vma *anon_vma = data;\n\n\tinit_rwsem(&anon_vma->rwsem);\n\tatomic_set(&anon_vma->refcount, 0);\n\tanon_vma->rb_root = RB_ROOT_CACHED;\n}\n\nvoid __init anon_vma_init(void)\n{\n\tanon_vma_cachep = kmem_cache_create(\"anon_vma\", sizeof(struct anon_vma),\n\t\t\t0, SLAB_TYPESAFE_BY_RCU|SLAB_PANIC|SLAB_ACCOUNT,\n\t\t\tanon_vma_ctor);\n\tanon_vma_chain_cachep = KMEM_CACHE(anon_vma_chain,\n\t\t\tSLAB_PANIC|SLAB_ACCOUNT);\n}\n\n/*\n * Getting a lock on a stable anon_vma from a page off the LRU is tricky!\n *\n * Since there is no serialization what so ever against page_remove_rmap()\n * the best this function can do is return a refcount increased anon_vma\n * that might have been relevant to this page.\n *\n * The page might have been remapped to a different anon_vma or the anon_vma\n * returned may already be freed (and even reused).\n *\n * In case it was remapped to a different anon_vma, the new anon_vma will be a\n * child of the old anon_vma, and the anon_vma lifetime rules will therefore\n * ensure that any anon_vma obtained from the page will still be valid for as\n * long as we observe page_mapped() [ hence all those page_mapped() tests ].\n *\n * All users of this function must be very careful when walking the anon_vma\n * chain and verify that the page in question is indeed mapped in it\n * [ something equivalent to page_mapped_in_vma() ].\n *\n * Since anon_vma's slab is SLAB_TYPESAFE_BY_RCU and we know from\n * page_remove_rmap() that the anon_vma pointer from page->mapping is valid\n * if there is a mapcount, we can dereference the anon_vma after observing\n * those.\n */\nstruct anon_vma *page_get_anon_vma(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this page is still mapped, then its anon_vma cannot have been\n\t * freed.  But if it has been unmapped, we have no security against the\n\t * anon_vma structure being freed and reused (for another anon_vma:\n\t * SLAB_TYPESAFE_BY_RCU guarantees that - so the atomic_inc_not_zero()\n\t * above cannot corrupt).\n\t */\n\tif (!page_mapped(page)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn anon_vma;\n}\n\n/*\n * Similar to page_get_anon_vma() except it locks the anon_vma.\n *\n * Its a little more complex as it tries to keep the fast path to a single\n * atomic op -- the trylock. If we fail the trylock, we fall back to getting a\n * reference like with page_get_anon_vma() and then block on the mutex\n * on !rwc->try_lock case.\n */\nstruct anon_vma *folio_lock_anon_vma_read(struct folio *folio,\n\t\t\t\t\t  struct rmap_walk_control *rwc)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct anon_vma *root_anon_vma;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(folio->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!folio_mapped(folio))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\troot_anon_vma = READ_ONCE(anon_vma->root);\n\tif (down_read_trylock(&root_anon_vma->rwsem)) {\n\t\t/*\n\t\t * If the folio is still mapped, then this anon_vma is still\n\t\t * its anon_vma, and holding the mutex ensures that it will\n\t\t * not go away, see anon_vma_free().\n\t\t */\n\t\tif (!folio_mapped(folio)) {\n\t\t\tup_read(&root_anon_vma->rwsem);\n\t\t\tanon_vma = NULL;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (rwc && rwc->try_lock) {\n\t\tanon_vma = NULL;\n\t\trwc->contended = true;\n\t\tgoto out;\n\t}\n\n\t/* trylock failed, we got to sleep */\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\tif (!folio_mapped(folio)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\n\n\t/* we pinned the anon_vma, its safe to sleep */\n\trcu_read_unlock();\n\tanon_vma_lock_read(anon_vma);\n\n\tif (atomic_dec_and_test(&anon_vma->refcount)) {\n\t\t/*\n\t\t * Oops, we held the last refcount, release the lock\n\t\t * and bail -- can't simply use put_anon_vma() because\n\t\t * we'll deadlock on the anon_vma_lock_write() recursion.\n\t\t */\n\t\tanon_vma_unlock_read(anon_vma);\n\t\t__put_anon_vma(anon_vma);\n\t\tanon_vma = NULL;\n\t}\n\n\treturn anon_vma;\n\nout:\n\trcu_read_unlock();\n\treturn anon_vma;\n}\n\nvoid page_unlock_anon_vma_read(struct anon_vma *anon_vma)\n{\n\tanon_vma_unlock_read(anon_vma);\n}\n\n#ifdef CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH\n/*\n * Flush TLB entries for recently unmapped pages from remote CPUs. It is\n * important if a PTE was dirty when it was unmapped that it's flushed\n * before any IO is initiated on the page to prevent lost writes. Similarly,\n * it must be flushed before freeing to prevent data leakage.\n */\nvoid try_to_unmap_flush(void)\n{\n\tstruct tlbflush_unmap_batch *tlb_ubc = &current->tlb_ubc;\n\n\tif (!tlb_ubc->flush_required)\n\t\treturn;\n\n\tarch_tlbbatch_flush(&tlb_ubc->arch);\n\ttlb_ubc->flush_required = false;\n\ttlb_ubc->writable = false;\n}\n\n/* Flush iff there are potentially writable TLB entries that can race with IO */\nvoid try_to_unmap_flush_dirty(void)\n{\n\tstruct tlbflush_unmap_batch *tlb_ubc = &current->tlb_ubc;\n\n\tif (tlb_ubc->writable)\n\t\ttry_to_unmap_flush();\n}\n\n/*\n * Bits 0-14 of mm->tlb_flush_batched record pending generations.\n * Bits 16-30 of mm->tlb_flush_batched bit record flushed generations.\n */\n#define TLB_FLUSH_BATCH_FLUSHED_SHIFT\t16\n#define TLB_FLUSH_BATCH_PENDING_MASK\t\t\t\\\n\t((1 << (TLB_FLUSH_BATCH_FLUSHED_SHIFT - 1)) - 1)\n#define TLB_FLUSH_BATCH_PENDING_LARGE\t\t\t\\\n\t(TLB_FLUSH_BATCH_PENDING_MASK / 2)\n\nstatic void set_tlb_ubc_flush_pending(struct mm_struct *mm, bool writable)\n{\n\tstruct tlbflush_unmap_batch *tlb_ubc = &current->tlb_ubc;\n\tint batch, nbatch;\n\n\tarch_tlbbatch_add_mm(&tlb_ubc->arch, mm);\n\ttlb_ubc->flush_required = true;\n\n\t/*\n\t * Ensure compiler does not re-order the setting of tlb_flush_batched\n\t * before the PTE is cleared.\n\t */\n\tbarrier();\n\tbatch = atomic_read(&mm->tlb_flush_batched);\nretry:\n\tif ((batch & TLB_FLUSH_BATCH_PENDING_MASK) > TLB_FLUSH_BATCH_PENDING_LARGE) {\n\t\t/*\n\t\t * Prevent `pending' from catching up with `flushed' because of\n\t\t * overflow.  Reset `pending' and `flushed' to be 1 and 0 if\n\t\t * `pending' becomes large.\n\t\t */\n\t\tnbatch = atomic_cmpxchg(&mm->tlb_flush_batched, batch, 1);\n\t\tif (nbatch != batch) {\n\t\t\tbatch = nbatch;\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\tatomic_inc(&mm->tlb_flush_batched);\n\t}\n\n\t/*\n\t * If the PTE was dirty then it's best to assume it's writable. The\n\t * caller must use try_to_unmap_flush_dirty() or try_to_unmap_flush()\n\t * before the page is queued for IO.\n\t */\n\tif (writable)\n\t\ttlb_ubc->writable = true;\n}\n\n/*\n * Returns true if the TLB flush should be deferred to the end of a batch of\n * unmap operations to reduce IPIs.\n */\nstatic bool should_defer_flush(struct mm_struct *mm, enum ttu_flags flags)\n{\n\tbool should_defer = false;\n\n\tif (!(flags & TTU_BATCH_FLUSH))\n\t\treturn false;\n\n\t/* If remote CPUs need to be flushed then defer batch the flush */\n\tif (cpumask_any_but(mm_cpumask(mm), get_cpu()) < nr_cpu_ids)\n\t\tshould_defer = true;\n\tput_cpu();\n\n\treturn should_defer;\n}\n\n/*\n * Reclaim unmaps pages under the PTL but do not flush the TLB prior to\n * releasing the PTL if TLB flushes are batched. It's possible for a parallel\n * operation such as mprotect or munmap to race between reclaim unmapping\n * the page and flushing the page. If this race occurs, it potentially allows\n * access to data via a stale TLB entry. Tracking all mm's that have TLB\n * batching in flight would be expensive during reclaim so instead track\n * whether TLB batching occurred in the past and if so then do a flush here\n * if required. This will cost one additional flush per reclaim cycle paid\n * by the first operation at risk such as mprotect and mumap.\n *\n * This must be called under the PTL so that an access to tlb_flush_batched\n * that is potentially a \"reclaim vs mprotect/munmap/etc\" race will synchronise\n * via the PTL.\n */\nvoid flush_tlb_batched_pending(struct mm_struct *mm)\n{\n\tint batch = atomic_read(&mm->tlb_flush_batched);\n\tint pending = batch & TLB_FLUSH_BATCH_PENDING_MASK;\n\tint flushed = batch >> TLB_FLUSH_BATCH_FLUSHED_SHIFT;\n\n\tif (pending != flushed) {\n\t\tflush_tlb_mm(mm);\n\t\t/*\n\t\t * If the new TLB flushing is pending during flushing, leave\n\t\t * mm->tlb_flush_batched as is, to avoid losing flushing.\n\t\t */\n\t\tatomic_cmpxchg(&mm->tlb_flush_batched, batch,\n\t\t\t       pending | (pending << TLB_FLUSH_BATCH_FLUSHED_SHIFT));\n\t}\n}\n#else\nstatic void set_tlb_ubc_flush_pending(struct mm_struct *mm, bool writable)\n{\n}\n\nstatic bool should_defer_flush(struct mm_struct *mm, enum ttu_flags flags)\n{\n\treturn false;\n}\n#endif /* CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH */\n\n/*\n * At what user virtual address is page expected in vma?\n * Caller should check the page is actually part of the vma.\n */\nunsigned long page_address_in_vma(struct page *page, struct vm_area_struct *vma)\n{\n\tstruct folio *folio = page_folio(page);\n\tif (folio_test_anon(folio)) {\n\t\tstruct anon_vma *page__anon_vma = folio_anon_vma(folio);\n\t\t/*\n\t\t * Note: swapoff's unuse_vma() is more efficient with this\n\t\t * check, and needs it to match anon_vma when KSM is active.\n\t\t */\n\t\tif (!vma->anon_vma || !page__anon_vma ||\n\t\t    vma->anon_vma->root != page__anon_vma->root)\n\t\t\treturn -EFAULT;\n\t} else if (!vma->vm_file) {\n\t\treturn -EFAULT;\n\t} else if (vma->vm_file->f_mapping != folio->mapping) {\n\t\treturn -EFAULT;\n\t}\n\n\treturn vma_address(page, vma);\n}\n\npmd_t *mm_find_pmd(struct mm_struct *mm, unsigned long address)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd = NULL;\n\tpmd_t pmde;\n\n\tpgd = pgd_offset(mm, address);\n\tif (!pgd_present(*pgd))\n\t\tgoto out;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\tgoto out;\n\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\t/*\n\t * Some THP functions use the sequence pmdp_huge_clear_flush(), set_pmd_at()\n\t * without holding anon_vma lock for write.  So when looking for a\n\t * genuine pmde (in which to find pte), test present and !THP together.\n\t */\n\tpmde = *pmd;\n\tbarrier();\n\tif (!pmd_present(pmde) || pmd_trans_huge(pmde))\n\t\tpmd = NULL;\nout:\n\treturn pmd;\n}\n\nstruct folio_referenced_arg {\n\tint mapcount;\n\tint referenced;\n\tunsigned long vm_flags;\n\tstruct mem_cgroup *memcg;\n};\n/*\n * arg: folio_referenced_arg will be passed\n */\nstatic bool folio_referenced_one(struct folio *folio,\n\t\tstruct vm_area_struct *vma, unsigned long address, void *arg)\n{\n\tstruct folio_referenced_arg *pra = arg;\n\tDEFINE_FOLIO_VMA_WALK(pvmw, folio, vma, address, 0);\n\tint referenced = 0;\n\n\twhile (page_vma_mapped_walk(&pvmw)) {\n\t\taddress = pvmw.address;\n\n\t\tif ((vma->vm_flags & VM_LOCKED) &&\n\t\t    (!folio_test_large(folio) || !pvmw.pte)) {\n\t\t\t/* Restore the mlock which got missed */\n\t\t\tmlock_vma_folio(folio, vma, !pvmw.pte);\n\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\tpra->vm_flags |= VM_LOCKED;\n\t\t\treturn false; /* To break the loop */\n\t\t}\n\n\t\tif (pvmw.pte) {\n\t\t\tif (ptep_clear_flush_young_notify(vma, address,\n\t\t\t\t\t\tpvmw.pte)) {\n\t\t\t\t/*\n\t\t\t\t * Don't treat a reference through\n\t\t\t\t * a sequentially read mapping as such.\n\t\t\t\t * If the folio has been used in another mapping,\n\t\t\t\t * we will catch it; if this other mapping is\n\t\t\t\t * already gone, the unmap path will have set\n\t\t\t\t * the referenced flag or activated the folio.\n\t\t\t\t */\n\t\t\t\tif (likely(!(vma->vm_flags & VM_SEQ_READ)))\n\t\t\t\t\treferenced++;\n\t\t\t}\n\t\t} else if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE)) {\n\t\t\tif (pmdp_clear_flush_young_notify(vma, address,\n\t\t\t\t\t\tpvmw.pmd))\n\t\t\t\treferenced++;\n\t\t} else {\n\t\t\t/* unexpected pmd-mapped folio? */\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\n\t\tpra->mapcount--;\n\t}\n\n\tif (referenced)\n\t\tfolio_clear_idle(folio);\n\tif (folio_test_clear_young(folio))\n\t\treferenced++;\n\n\tif (referenced) {\n\t\tpra->referenced++;\n\t\tpra->vm_flags |= vma->vm_flags & ~VM_LOCKED;\n\t}\n\n\tif (!pra->mapcount)\n\t\treturn false; /* To break the loop */\n\n\treturn true;\n}\n\nstatic bool invalid_folio_referenced_vma(struct vm_area_struct *vma, void *arg)\n{\n\tstruct folio_referenced_arg *pra = arg;\n\tstruct mem_cgroup *memcg = pra->memcg;\n\n\tif (!mm_match_cgroup(vma->vm_mm, memcg))\n\t\treturn true;\n\n\treturn false;\n}\n\n/**\n * folio_referenced() - Test if the folio was referenced.\n * @folio: The folio to test.\n * @is_locked: Caller holds lock on the folio.\n * @memcg: target memory cgroup\n * @vm_flags: A combination of all the vma->vm_flags which referenced the folio.\n *\n * Quick test_and_clear_referenced for all mappings of a folio,\n *\n * Return: The number of mappings which referenced the folio. Return -1 if\n * the function bailed out due to rmap lock contention.\n */\nint folio_referenced(struct folio *folio, int is_locked,\n\t\t     struct mem_cgroup *memcg, unsigned long *vm_flags)\n{\n\tint we_locked = 0;\n\tstruct folio_referenced_arg pra = {\n\t\t.mapcount = folio_mapcount(folio),\n\t\t.memcg = memcg,\n\t};\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = folio_referenced_one,\n\t\t.arg = (void *)&pra,\n\t\t.anon_lock = folio_lock_anon_vma_read,\n\t\t.try_lock = true,\n\t};\n\n\t*vm_flags = 0;\n\tif (!pra.mapcount)\n\t\treturn 0;\n\n\tif (!folio_raw_mapping(folio))\n\t\treturn 0;\n\n\tif (!is_locked && (!folio_test_anon(folio) || folio_test_ksm(folio))) {\n\t\twe_locked = folio_trylock(folio);\n\t\tif (!we_locked)\n\t\t\treturn 1;\n\t}\n\n\t/*\n\t * If we are reclaiming on behalf of a cgroup, skip\n\t * counting on behalf of references from different\n\t * cgroups\n\t */\n\tif (memcg) {\n\t\trwc.invalid_vma = invalid_folio_referenced_vma;\n\t}\n\n\trmap_walk(folio, &rwc);\n\t*vm_flags = pra.vm_flags;\n\n\tif (we_locked)\n\t\tfolio_unlock(folio);\n\n\treturn rwc.contended ? -1 : pra.referenced;\n}\n\nstatic int page_vma_mkclean_one(struct page_vma_mapped_walk *pvmw)\n{\n\tint cleaned = 0;\n\tstruct vm_area_struct *vma = pvmw->vma;\n\tstruct mmu_notifier_range range;\n\tunsigned long address = pvmw->address;\n\n\t/*\n\t * We have to assume the worse case ie pmd for invalidation. Note that\n\t * the folio can not be freed from this function.\n\t */\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_PROTECTION_PAGE,\n\t\t\t\t0, vma, vma->vm_mm, address,\n\t\t\t\tvma_address_end(pvmw));\n\tmmu_notifier_invalidate_range_start(&range);\n\n\twhile (page_vma_mapped_walk(pvmw)) {\n\t\tint ret = 0;\n\n\t\taddress = pvmw->address;\n\t\tif (pvmw->pte) {\n\t\t\tpte_t entry;\n\t\t\tpte_t *pte = pvmw->pte;\n\n\t\t\tif (!pte_dirty(*pte) && !pte_write(*pte))\n\t\t\t\tcontinue;\n\n\t\t\tflush_cache_page(vma, address, pte_pfn(*pte));\n\t\t\tentry = ptep_clear_flush(vma, address, pte);\n\t\t\tentry = pte_wrprotect(entry);\n\t\t\tentry = pte_mkclean(entry);\n\t\t\tset_pte_at(vma->vm_mm, address, pte, entry);\n\t\t\tret = 1;\n\t\t} else {\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tpmd_t *pmd = pvmw->pmd;\n\t\t\tpmd_t entry;\n\n\t\t\tif (!pmd_dirty(*pmd) && !pmd_write(*pmd))\n\t\t\t\tcontinue;\n\n\t\t\tflush_cache_range(vma, address,\n\t\t\t\t\t  address + HPAGE_PMD_SIZE);\n\t\t\tentry = pmdp_invalidate(vma, address, pmd);\n\t\t\tentry = pmd_wrprotect(entry);\n\t\t\tentry = pmd_mkclean(entry);\n\t\t\tset_pmd_at(vma->vm_mm, address, pmd, entry);\n\t\t\tret = 1;\n#else\n\t\t\t/* unexpected pmd-mapped folio? */\n\t\t\tWARN_ON_ONCE(1);\n#endif\n\t\t}\n\n\t\t/*\n\t\t * No need to call mmu_notifier_invalidate_range() as we are\n\t\t * downgrading page table protection not changing it to point\n\t\t * to a new page.\n\t\t *\n\t\t * See Documentation/mm/mmu_notifier.rst\n\t\t */\n\t\tif (ret)\n\t\t\tcleaned++;\n\t}\n\n\tmmu_notifier_invalidate_range_end(&range);\n\n\treturn cleaned;\n}\n\nstatic bool page_mkclean_one(struct folio *folio, struct vm_area_struct *vma,\n\t\t\t     unsigned long address, void *arg)\n{\n\tDEFINE_FOLIO_VMA_WALK(pvmw, folio, vma, address, PVMW_SYNC);\n\tint *cleaned = arg;\n\n\t*cleaned += page_vma_mkclean_one(&pvmw);\n\n\treturn true;\n}\n\nstatic bool invalid_mkclean_vma(struct vm_area_struct *vma, void *arg)\n{\n\tif (vma->vm_flags & VM_SHARED)\n\t\treturn false;\n\n\treturn true;\n}\n\nint folio_mkclean(struct folio *folio)\n{\n\tint cleaned = 0;\n\tstruct address_space *mapping;\n\tstruct rmap_walk_control rwc = {\n\t\t.arg = (void *)&cleaned,\n\t\t.rmap_one = page_mkclean_one,\n\t\t.invalid_vma = invalid_mkclean_vma,\n\t};\n\n\tBUG_ON(!folio_test_locked(folio));\n\n\tif (!folio_mapped(folio))\n\t\treturn 0;\n\n\tmapping = folio_mapping(folio);\n\tif (!mapping)\n\t\treturn 0;\n\n\trmap_walk(folio, &rwc);\n\n\treturn cleaned;\n}\nEXPORT_SYMBOL_GPL(folio_mkclean);\n\n/**\n * pfn_mkclean_range - Cleans the PTEs (including PMDs) mapped with range of\n *                     [@pfn, @pfn + @nr_pages) at the specific offset (@pgoff)\n *                     within the @vma of shared mappings. And since clean PTEs\n *                     should also be readonly, write protects them too.\n * @pfn: start pfn.\n * @nr_pages: number of physically contiguous pages srarting with @pfn.\n * @pgoff: page offset that the @pfn mapped with.\n * @vma: vma that @pfn mapped within.\n *\n * Returns the number of cleaned PTEs (including PMDs).\n */\nint pfn_mkclean_range(unsigned long pfn, unsigned long nr_pages, pgoff_t pgoff,\n\t\t      struct vm_area_struct *vma)\n{\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.pfn\t\t= pfn,\n\t\t.nr_pages\t= nr_pages,\n\t\t.pgoff\t\t= pgoff,\n\t\t.vma\t\t= vma,\n\t\t.flags\t\t= PVMW_SYNC,\n\t};\n\n\tif (invalid_mkclean_vma(vma, NULL))\n\t\treturn 0;\n\n\tpvmw.address = vma_pgoff_address(pgoff, nr_pages, vma);\n\tVM_BUG_ON_VMA(pvmw.address == -EFAULT, vma);\n\n\treturn page_vma_mkclean_one(&pvmw);\n}\n\n/**\n * page_move_anon_rmap - move a page to our anon_vma\n * @page:\tthe page to move to our anon_vma\n * @vma:\tthe vma the page belongs to\n *\n * When a page belongs exclusively to one process after a COW event,\n * that page can be moved into the anon_vma that belongs to just that\n * process, so the rmap code will not search the parent or sibling\n * processes.\n */\nvoid page_move_anon_rmap(struct page *page, struct vm_area_struct *vma)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\tstruct page *subpage = page;\n\n\tpage = compound_head(page);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_VMA(!anon_vma, vma);\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\t/*\n\t * Ensure that anon_vma and the PAGE_MAPPING_ANON bit are written\n\t * simultaneously, so a concurrent reader (eg folio_referenced()'s\n\t * folio_test_anon()) will not see one without the other.\n\t */\n\tWRITE_ONCE(page->mapping, (struct address_space *) anon_vma);\n\tSetPageAnonExclusive(subpage);\n}\n\n/**\n * __page_set_anon_rmap - set up new anonymous rmap\n * @page:\tPage or Hugepage to add to rmap\n * @vma:\tVM area to add page to.\n * @address:\tUser virtual address of the mapping\t\n * @exclusive:\tthe page is exclusively owned by the current process\n */\nstatic void __page_set_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int exclusive)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tBUG_ON(!anon_vma);\n\n\tif (PageAnon(page))\n\t\tgoto out;\n\n\t/*\n\t * If the page isn't exclusively mapped into this vma,\n\t * we must use the _oldest_ possible anon_vma for the\n\t * page mapping!\n\t */\n\tif (!exclusive)\n\t\tanon_vma = anon_vma->root;\n\n\t/*\n\t * page_idle does a lockless/optimistic rmap scan on page->mapping.\n\t * Make sure the compiler doesn't split the stores of anon_vma and\n\t * the PAGE_MAPPING_ANON type identifier, otherwise the rmap code\n\t * could mistake the mapping for a struct address_space and crash.\n\t */\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\tWRITE_ONCE(page->mapping, (struct address_space *) anon_vma);\n\tpage->index = linear_page_index(vma, address);\nout:\n\tif (exclusive)\n\t\tSetPageAnonExclusive(page);\n}\n\n/**\n * __page_check_anon_rmap - sanity check anonymous rmap addition\n * @page:\tthe page to add the mapping to\n * @vma:\tthe vm area in which the mapping is added\n * @address:\tthe user virtual address mapped\n */\nstatic void __page_check_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tstruct folio *folio = page_folio(page);\n\t/*\n\t * The page's anon-rmap details (mapping and index) are guaranteed to\n\t * be set up correctly at this point.\n\t *\n\t * We have exclusion against page_add_anon_rmap because the caller\n\t * always holds the page locked.\n\t *\n\t * We have exclusion against page_add_new_anon_rmap because those pages\n\t * are initially only visible via the pagetables, and the pte is locked\n\t * over the call to page_add_new_anon_rmap.\n\t */\n\tVM_BUG_ON_FOLIO(folio_anon_vma(folio)->root != vma->anon_vma->root,\n\t\t\tfolio);\n\tVM_BUG_ON_PAGE(page_to_pgoff(page) != linear_page_index(vma, address),\n\t\t       page);\n}\n\n/**\n * page_add_anon_rmap - add pte mapping to an anonymous page\n * @page:\tthe page to add the mapping to\n * @vma:\tthe vm area in which the mapping is added\n * @address:\tthe user virtual address mapped\n * @flags:\tthe rmap flags\n *\n * The caller needs to hold the pte lock, and the page must be locked in\n * the anon_vma case: to serialize mapping,index checking after setting,\n * and to ensure that PageAnon is not being upgraded racily to PageKsm\n * (but PageKsm is never downgraded to PageAnon).\n */\nvoid page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, rmap_t flags)\n{\n\tbool compound = flags & RMAP_COMPOUND;\n\tbool first;\n\n\tif (unlikely(PageKsm(page)))\n\t\tlock_page_memcg(page);\n\telse\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (compound) {\n\t\tatomic_t *mapcount;\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\tmapcount = compound_mapcount_ptr(page);\n\t\tfirst = atomic_inc_and_test(mapcount);\n\t} else {\n\t\tfirst = atomic_inc_and_test(&page->_mapcount);\n\t}\n\tVM_BUG_ON_PAGE(!first && (flags & RMAP_EXCLUSIVE), page);\n\tVM_BUG_ON_PAGE(!first && PageAnonExclusive(page), page);\n\n\tif (first) {\n\t\tint nr = compound ? thp_nr_pages(page) : 1;\n\t\t/*\n\t\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t\t * these counters are not modified in interrupt context, and\n\t\t * pte lock(a spinlock) is held, which implies preemption\n\t\t * disabled.\n\t\t */\n\t\tif (compound)\n\t\t\t__mod_lruvec_page_state(page, NR_ANON_THPS, nr);\n\t\t__mod_lruvec_page_state(page, NR_ANON_MAPPED, nr);\n\t}\n\n\tif (unlikely(PageKsm(page)))\n\t\tunlock_page_memcg(page);\n\n\t/* address might be in next vma when migration races vma_adjust */\n\telse if (first)\n\t\t__page_set_anon_rmap(page, vma, address,\n\t\t\t\t     !!(flags & RMAP_EXCLUSIVE));\n\telse\n\t\t__page_check_anon_rmap(page, vma, address);\n\n\tmlock_vma_page(page, vma, compound);\n}\n\n/**\n * page_add_new_anon_rmap - add mapping to a new anonymous page\n * @page:\tthe page to add the mapping to\n * @vma:\tthe vm area in which the mapping is added\n * @address:\tthe user virtual address mapped\n *\n * If it's a compound page, it is accounted as a compound page. As the page\n * is new, it's assume to get mapped exclusively by a single process.\n *\n * Same as page_add_anon_rmap but must only be called on *new* pages.\n * This means the inc-and-test can be bypassed.\n * Page does not have to be locked.\n */\nvoid page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tconst bool compound = PageCompound(page);\n\tint nr = compound ? thp_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\tatomic_set(compound_pincount_ptr(page), 0);\n\n\t\t__mod_lruvec_page_state(page, NR_ANON_THPS, nr);\n\t} else {\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_lruvec_page_state(page, NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}\n\n/**\n * page_add_file_rmap - add pte mapping to a file page\n * @page:\tthe page to add the mapping to\n * @vma:\tthe vm area in which the mapping is added\n * @compound:\tcharge the page as compound or small page\n *\n * The caller needs to hold the pte lock.\n */\nvoid page_add_file_rmap(struct page *page,\n\tstruct vm_area_struct *vma, bool compound)\n{\n\tint i, nr = 0;\n\n\tVM_BUG_ON_PAGE(compound && !PageTransHuge(page), page);\n\tlock_page_memcg(page);\n\tif (compound && PageTransHuge(page)) {\n\t\tint nr_pages = thp_nr_pages(page);\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tif (atomic_inc_and_test(&page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t\tif (!atomic_inc_and_test(compound_mapcount_ptr(page)))\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * It is racy to ClearPageDoubleMap in page_remove_file_rmap();\n\t\t * but page lock is held by all page_add_file_rmap() compound\n\t\t * callers, and SetPageDoubleMap below warns if !PageLocked:\n\t\t * so here is a place that DoubleMap can be safely cleared.\n\t\t */\n\t\tVM_WARN_ON_ONCE(!PageLocked(page));\n\t\tif (nr == nr_pages && PageDoubleMap(page))\n\t\t\tClearPageDoubleMap(page);\n\n\t\tif (PageSwapBacked(page))\n\t\t\t__mod_lruvec_page_state(page, NR_SHMEM_PMDMAPPED,\n\t\t\t\t\t\tnr_pages);\n\t\telse\n\t\t\t__mod_lruvec_page_state(page, NR_FILE_PMDMAPPED,\n\t\t\t\t\t\tnr_pages);\n\t} else {\n\t\tif (PageTransCompound(page) && page_mapping(page)) {\n\t\t\tVM_WARN_ON_ONCE(!PageLocked(page));\n\t\t\tSetPageDoubleMap(compound_head(page));\n\t\t}\n\t\tif (atomic_inc_and_test(&page->_mapcount))\n\t\t\tnr++;\n\t}\nout:\n\tif (nr)\n\t\t__mod_lruvec_page_state(page, NR_FILE_MAPPED, nr);\n\tunlock_page_memcg(page);\n\n\tmlock_vma_page(page, vma, compound);\n}\n\nstatic void page_remove_file_rmap(struct page *page, bool compound)\n{\n\tint i, nr = 0;\n\n\tVM_BUG_ON_PAGE(compound && !PageHead(page), page);\n\n\t/* Hugepages are not counted in NR_FILE_MAPPED for now. */\n\tif (unlikely(PageHuge(page))) {\n\t\t/* hugetlb pages are always mapped with pmds */\n\t\tatomic_dec(compound_mapcount_ptr(page));\n\t\treturn;\n\t}\n\n\t/* page still mapped by someone else? */\n\tif (compound && PageTransHuge(page)) {\n\t\tint nr_pages = thp_nr_pages(page);\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tif (atomic_add_negative(-1, &page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t\tif (!atomic_add_negative(-1, compound_mapcount_ptr(page)))\n\t\t\tgoto out;\n\t\tif (PageSwapBacked(page))\n\t\t\t__mod_lruvec_page_state(page, NR_SHMEM_PMDMAPPED,\n\t\t\t\t\t\t-nr_pages);\n\t\telse\n\t\t\t__mod_lruvec_page_state(page, NR_FILE_PMDMAPPED,\n\t\t\t\t\t\t-nr_pages);\n\t} else {\n\t\tif (atomic_add_negative(-1, &page->_mapcount))\n\t\t\tnr++;\n\t}\nout:\n\tif (nr)\n\t\t__mod_lruvec_page_state(page, NR_FILE_MAPPED, -nr);\n}\n\nstatic void page_remove_anon_compound_rmap(struct page *page)\n{\n\tint i, nr;\n\n\tif (!atomic_add_negative(-1, compound_mapcount_ptr(page)))\n\t\treturn;\n\n\t/* Hugepages are not counted in NR_ANON_PAGES for now. */\n\tif (unlikely(PageHuge(page)))\n\t\treturn;\n\n\tif (!IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE))\n\t\treturn;\n\n\t__mod_lruvec_page_state(page, NR_ANON_THPS, -thp_nr_pages(page));\n\n\tif (TestClearPageDoubleMap(page)) {\n\t\t/*\n\t\t * Subpages can be mapped with PTEs too. Check how many of\n\t\t * them are still mapped.\n\t\t */\n\t\tfor (i = 0, nr = 0; i < thp_nr_pages(page); i++) {\n\t\t\tif (atomic_add_negative(-1, &page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\n\t\t/*\n\t\t * Queue the page for deferred split if at least one small\n\t\t * page of the compound page is unmapped, but at least one\n\t\t * small page is still mapped.\n\t\t */\n\t\tif (nr && nr < thp_nr_pages(page))\n\t\t\tdeferred_split_huge_page(page);\n\t} else {\n\t\tnr = thp_nr_pages(page);\n\t}\n\n\tif (nr)\n\t\t__mod_lruvec_page_state(page, NR_ANON_MAPPED, -nr);\n}\n\n/**\n * page_remove_rmap - take down pte mapping from a page\n * @page:\tpage to remove mapping from\n * @vma:\tthe vm area from which the mapping is removed\n * @compound:\tuncharge the page as compound or small page\n *\n * The caller needs to hold the pte lock.\n */\nvoid page_remove_rmap(struct page *page,\n\tstruct vm_area_struct *vma, bool compound)\n{\n\tlock_page_memcg(page);\n\n\tif (!PageAnon(page)) {\n\t\tpage_remove_file_rmap(page, compound);\n\t\tgoto out;\n\t}\n\n\tif (compound) {\n\t\tpage_remove_anon_compound_rmap(page);\n\t\tgoto out;\n\t}\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\tgoto out;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_lruvec_page_state(page, NR_ANON_MAPPED);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\nout:\n\tunlock_page_memcg(page);\n\n\tmunlock_vma_page(page, vma, compound);\n}\n\n/*\n * @arg: enum ttu_flags will be passed to this argument\n */\nstatic bool try_to_unmap_one(struct folio *folio, struct vm_area_struct *vma,\n\t\t     unsigned long address, void *arg)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tDEFINE_FOLIO_VMA_WALK(pvmw, folio, vma, address, 0);\n\tpte_t pteval;\n\tstruct page *subpage;\n\tbool anon_exclusive, ret = true;\n\tstruct mmu_notifier_range range;\n\tenum ttu_flags flags = (enum ttu_flags)(long)arg;\n\n\t/*\n\t * When racing against e.g. zap_pte_range() on another cpu,\n\t * in between its ptep_get_and_clear_full() and page_remove_rmap(),\n\t * try_to_unmap() may return before page_mapped() has become false,\n\t * if page table locking is skipped: use TTU_SYNC to wait for that.\n\t */\n\tif (flags & TTU_SYNC)\n\t\tpvmw.flags = PVMW_SYNC;\n\n\tif (flags & TTU_SPLIT_HUGE_PMD)\n\t\tsplit_huge_pmd_address(vma, address, false, folio);\n\n\t/*\n\t * For THP, we have to assume the worse case ie pmd for invalidation.\n\t * For hugetlb, it could be much worse if we need to do pud\n\t * invalidation in the case of pmd sharing.\n\t *\n\t * Note that the folio can not be freed in this function as call of\n\t * try_to_unmap() must hold a reference on the folio.\n\t */\n\trange.end = vma_address_end(&pvmw);\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma, vma->vm_mm,\n\t\t\t\taddress, range.end);\n\tif (folio_test_hugetlb(folio)) {\n\t\t/*\n\t\t * If sharing is possible, start and end will be adjusted\n\t\t * accordingly.\n\t\t */\n\t\tadjust_range_if_pmd_sharing_possible(vma, &range.start,\n\t\t\t\t\t\t     &range.end);\n\t}\n\tmmu_notifier_invalidate_range_start(&range);\n\n\twhile (page_vma_mapped_walk(&pvmw)) {\n\t\t/* Unexpected PMD-mapped THP? */\n\t\tVM_BUG_ON_FOLIO(!pvmw.pte, folio);\n\n\t\t/*\n\t\t * If the folio is in an mlock()d vma, we must not swap it out.\n\t\t */\n\t\tif (!(flags & TTU_IGNORE_MLOCK) &&\n\t\t    (vma->vm_flags & VM_LOCKED)) {\n\t\t\t/* Restore the mlock which got missed */\n\t\t\tmlock_vma_folio(folio, vma, false);\n\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tsubpage = folio_page(folio,\n\t\t\t\t\tpte_pfn(*pvmw.pte) - folio_pfn(folio));\n\t\taddress = pvmw.address;\n\t\tanon_exclusive = folio_test_anon(folio) &&\n\t\t\t\t PageAnonExclusive(subpage);\n\n\t\tif (folio_test_hugetlb(folio)) {\n\t\t\tbool anon = folio_test_anon(folio);\n\n\t\t\t/*\n\t\t\t * The try_to_unmap() is only passed a hugetlb page\n\t\t\t * in the case where the hugetlb page is poisoned.\n\t\t\t */\n\t\t\tVM_BUG_ON_PAGE(!PageHWPoison(subpage), subpage);\n\t\t\t/*\n\t\t\t * huge_pmd_unshare may unmap an entire PMD page.\n\t\t\t * There is no way of knowing exactly which PMDs may\n\t\t\t * be cached for this mm, so we must flush them all.\n\t\t\t * start/end were already adjusted above to cover this\n\t\t\t * range.\n\t\t\t */\n\t\t\tflush_cache_range(vma, range.start, range.end);\n\n\t\t\t/*\n\t\t\t * To call huge_pmd_unshare, i_mmap_rwsem must be\n\t\t\t * held in write mode.  Caller needs to explicitly\n\t\t\t * do this outside rmap routines.\n\t\t\t */\n\t\t\tVM_BUG_ON(!anon && !(flags & TTU_RMAP_LOCKED));\n\t\t\tif (!anon && huge_pmd_unshare(mm, vma, address, pvmw.pte)) {\n\t\t\t\tflush_tlb_range(vma, range.start, range.end);\n\t\t\t\tmmu_notifier_invalidate_range(mm, range.start,\n\t\t\t\t\t\t\t      range.end);\n\n\t\t\t\t/*\n\t\t\t\t * The ref count of the PMD page was dropped\n\t\t\t\t * which is part of the way map counting\n\t\t\t\t * is done for shared PMDs.  Return 'true'\n\t\t\t\t * here.  When there is no other sharing,\n\t\t\t\t * huge_pmd_unshare returns false and we will\n\t\t\t\t * unmap the actual page and drop map count\n\t\t\t\t * to zero.\n\t\t\t\t */\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpteval = huge_ptep_clear_flush(vma, address, pvmw.pte);\n\t\t} else {\n\t\t\tflush_cache_page(vma, address, pte_pfn(*pvmw.pte));\n\t\t\t/*\n\t\t\t * Nuke the page table entry. When having to clear\n\t\t\t * PageAnonExclusive(), we always have to flush.\n\t\t\t */\n\t\t\tif (should_defer_flush(mm, flags) && !anon_exclusive) {\n\t\t\t\t/*\n\t\t\t\t * We clear the PTE but do not flush so potentially\n\t\t\t\t * a remote CPU could still be writing to the folio.\n\t\t\t\t * If the entry was previously clean then the\n\t\t\t\t * architecture must guarantee that a clear->dirty\n\t\t\t\t * transition on a cached TLB entry is written through\n\t\t\t\t * and traps if the PTE is unmapped.\n\t\t\t\t */\n\t\t\t\tpteval = ptep_get_and_clear(mm, address, pvmw.pte);\n\n\t\t\t\tset_tlb_ubc_flush_pending(mm, pte_dirty(pteval));\n\t\t\t} else {\n\t\t\t\tpteval = ptep_clear_flush(vma, address, pvmw.pte);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Now the pte is cleared. If this pte was uffd-wp armed,\n\t\t * we may want to replace a none pte with a marker pte if\n\t\t * it's file-backed, so we don't lose the tracking info.\n\t\t */\n\t\tpte_install_uffd_wp_if_needed(vma, address, pvmw.pte, pteval);\n\n\t\t/* Set the dirty flag on the folio now the pte is gone. */\n\t\tif (pte_dirty(pteval))\n\t\t\tfolio_mark_dirty(folio);\n\n\t\t/* Update high watermark before we lower rss */\n\t\tupdate_hiwater_rss(mm);\n\n\t\tif (PageHWPoison(subpage) && !(flags & TTU_IGNORE_HWPOISON)) {\n\t\t\tpteval = swp_entry_to_pte(make_hwpoison_entry(subpage));\n\t\t\tif (folio_test_hugetlb(folio)) {\n\t\t\t\thugetlb_count_sub(folio_nr_pages(folio), mm);\n\t\t\t\tset_huge_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t} else {\n\t\t\t\tdec_mm_counter(mm, mm_counter(&folio->page));\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t}\n\n\t\t} else if (pte_unused(pteval) && !userfaultfd_armed(vma)) {\n\t\t\t/*\n\t\t\t * The guest indicated that the page content is of no\n\t\t\t * interest anymore. Simply discard the pte, vmscan\n\t\t\t * will take care of the rest.\n\t\t\t * A future reference will then fault in a new zero\n\t\t\t * page. When userfaultfd is active, we must not drop\n\t\t\t * this page though, as its main user (postcopy\n\t\t\t * migration) will not expect userfaults on already\n\t\t\t * copied pages.\n\t\t\t */\n\t\t\tdec_mm_counter(mm, mm_counter(&folio->page));\n\t\t\t/* We have to invalidate as we cleared the pte */\n\t\t\tmmu_notifier_invalidate_range(mm, address,\n\t\t\t\t\t\t      address + PAGE_SIZE);\n\t\t} else if (folio_test_anon(folio)) {\n\t\t\tswp_entry_t entry = { .val = page_private(subpage) };\n\t\t\tpte_t swp_pte;\n\t\t\t/*\n\t\t\t * Store the swap location in the pte.\n\t\t\t * See handle_pte_fault() ...\n\t\t\t */\n\t\t\tif (unlikely(folio_test_swapbacked(folio) !=\n\t\t\t\t\tfolio_test_swapcache(folio))) {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tret = false;\n\t\t\t\t/* We have to invalidate as we cleared the pte */\n\t\t\t\tmmu_notifier_invalidate_range(mm, address,\n\t\t\t\t\t\t\taddress + PAGE_SIZE);\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* MADV_FREE page check */\n\t\t\tif (!folio_test_swapbacked(folio)) {\n\t\t\t\tint ref_count, map_count;\n\n\t\t\t\t/*\n\t\t\t\t * Synchronize with gup_pte_range():\n\t\t\t\t * - clear PTE; barrier; read refcount\n\t\t\t\t * - inc refcount; barrier; read PTE\n\t\t\t\t */\n\t\t\t\tsmp_mb();\n\n\t\t\t\tref_count = folio_ref_count(folio);\n\t\t\t\tmap_count = folio_mapcount(folio);\n\n\t\t\t\t/*\n\t\t\t\t * Order reads for page refcount and dirty flag\n\t\t\t\t * (see comments in __remove_mapping()).\n\t\t\t\t */\n\t\t\t\tsmp_rmb();\n\n\t\t\t\t/*\n\t\t\t\t * The only page refs must be one from isolation\n\t\t\t\t * plus the rmap(s) (dropped by discard:).\n\t\t\t\t */\n\t\t\t\tif (ref_count == 1 + map_count &&\n\t\t\t\t    !folio_test_dirty(folio)) {\n\t\t\t\t\t/* Invalidate as we cleared the pte */\n\t\t\t\t\tmmu_notifier_invalidate_range(mm,\n\t\t\t\t\t\taddress, address + PAGE_SIZE);\n\t\t\t\t\tdec_mm_counter(mm, MM_ANONPAGES);\n\t\t\t\t\tgoto discard;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * If the folio was redirtied, it cannot be\n\t\t\t\t * discarded. Remap the page to page table.\n\t\t\t\t */\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\tfolio_set_swapbacked(folio);\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (swap_duplicate(entry) < 0) {\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (arch_unmap_one(mm, vma, address, pteval) < 0) {\n\t\t\t\tswap_free(entry);\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (anon_exclusive &&\n\t\t\t    page_try_share_anon_rmap(subpage)) {\n\t\t\t\tswap_free(entry);\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Note: We *don't* remember if the page was mapped\n\t\t\t * exclusively in the swap pte if the architecture\n\t\t\t * doesn't support __HAVE_ARCH_PTE_SWP_EXCLUSIVE. In\n\t\t\t * that case, swapin code has to re-determine that\n\t\t\t * manually and might detect the page as possibly\n\t\t\t * shared, for example, if there are other references on\n\t\t\t * the page or if the page is under writeback. We made\n\t\t\t * sure that there are no GUP pins on the page that\n\t\t\t * would rely on it, so for GUP pins this is fine.\n\t\t\t */\n\t\t\tif (list_empty(&mm->mmlist)) {\n\t\t\t\tspin_lock(&mmlist_lock);\n\t\t\t\tif (list_empty(&mm->mmlist))\n\t\t\t\t\tlist_add(&mm->mmlist, &init_mm.mmlist);\n\t\t\t\tspin_unlock(&mmlist_lock);\n\t\t\t}\n\t\t\tdec_mm_counter(mm, MM_ANONPAGES);\n\t\t\tinc_mm_counter(mm, MM_SWAPENTS);\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (anon_exclusive)\n\t\t\t\tswp_pte = pte_swp_mkexclusive(swp_pte);\n\t\t\tif (pte_soft_dirty(pteval))\n\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\tif (pte_uffd_wp(pteval))\n\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\tset_pte_at(mm, address, pvmw.pte, swp_pte);\n\t\t\t/* Invalidate as we cleared the pte */\n\t\t\tmmu_notifier_invalidate_range(mm, address,\n\t\t\t\t\t\t      address + PAGE_SIZE);\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is a locked file-backed folio,\n\t\t\t * so it cannot be removed from the page\n\t\t\t * cache and replaced by a new folio before\n\t\t\t * mmu_notifier_invalidate_range_end, so no\n\t\t\t * concurrent thread might update its page table\n\t\t\t * to point at a new folio while a device is\n\t\t\t * still using this folio.\n\t\t\t *\n\t\t\t * See Documentation/mm/mmu_notifier.rst\n\t\t\t */\n\t\t\tdec_mm_counter(mm, mm_counter_file(&folio->page));\n\t\t}\ndiscard:\n\t\t/*\n\t\t * No need to call mmu_notifier_invalidate_range() it has be\n\t\t * done above for all cases requiring it to happen under page\n\t\t * table lock before mmu_notifier_invalidate_range_end()\n\t\t *\n\t\t * See Documentation/mm/mmu_notifier.rst\n\t\t */\n\t\tpage_remove_rmap(subpage, vma, folio_test_hugetlb(folio));\n\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\tmlock_page_drain_local();\n\t\tfolio_put(folio);\n\t}\n\n\tmmu_notifier_invalidate_range_end(&range);\n\n\treturn ret;\n}\n\nstatic bool invalid_migration_vma(struct vm_area_struct *vma, void *arg)\n{\n\treturn vma_is_temporary_stack(vma);\n}\n\nstatic int page_not_mapped(struct folio *folio)\n{\n\treturn !folio_mapped(folio);\n}\n\n/**\n * try_to_unmap - Try to remove all page table mappings to a folio.\n * @folio: The folio to unmap.\n * @flags: action and flags\n *\n * Tries to remove all the page table entries which are mapping this\n * folio.  It is the caller's responsibility to check if the folio is\n * still mapped if needed (use TTU_SYNC to prevent accounting races).\n *\n * Context: Caller must hold the folio lock.\n */\nvoid try_to_unmap(struct folio *folio, enum ttu_flags flags)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_unmap_one,\n\t\t.arg = (void *)flags,\n\t\t.done = page_not_mapped,\n\t\t.anon_lock = folio_lock_anon_vma_read,\n\t};\n\n\tif (flags & TTU_RMAP_LOCKED)\n\t\trmap_walk_locked(folio, &rwc);\n\telse\n\t\trmap_walk(folio, &rwc);\n}\n\n/*\n * @arg: enum ttu_flags will be passed to this argument.\n *\n * If TTU_SPLIT_HUGE_PMD is specified any PMD mappings will be split into PTEs\n * containing migration entries.\n */\nstatic bool try_to_migrate_one(struct folio *folio, struct vm_area_struct *vma,\n\t\t     unsigned long address, void *arg)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tDEFINE_FOLIO_VMA_WALK(pvmw, folio, vma, address, 0);\n\tpte_t pteval;\n\tstruct page *subpage;\n\tbool anon_exclusive, ret = true;\n\tstruct mmu_notifier_range range;\n\tenum ttu_flags flags = (enum ttu_flags)(long)arg;\n\n\t/*\n\t * When racing against e.g. zap_pte_range() on another cpu,\n\t * in between its ptep_get_and_clear_full() and page_remove_rmap(),\n\t * try_to_migrate() may return before page_mapped() has become false,\n\t * if page table locking is skipped: use TTU_SYNC to wait for that.\n\t */\n\tif (flags & TTU_SYNC)\n\t\tpvmw.flags = PVMW_SYNC;\n\n\t/*\n\t * unmap_page() in mm/huge_memory.c is the only user of migration with\n\t * TTU_SPLIT_HUGE_PMD and it wants to freeze.\n\t */\n\tif (flags & TTU_SPLIT_HUGE_PMD)\n\t\tsplit_huge_pmd_address(vma, address, true, folio);\n\n\t/*\n\t * For THP, we have to assume the worse case ie pmd for invalidation.\n\t * For hugetlb, it could be much worse if we need to do pud\n\t * invalidation in the case of pmd sharing.\n\t *\n\t * Note that the page can not be free in this function as call of\n\t * try_to_unmap() must hold a reference on the page.\n\t */\n\trange.end = vma_address_end(&pvmw);\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma, vma->vm_mm,\n\t\t\t\taddress, range.end);\n\tif (folio_test_hugetlb(folio)) {\n\t\t/*\n\t\t * If sharing is possible, start and end will be adjusted\n\t\t * accordingly.\n\t\t */\n\t\tadjust_range_if_pmd_sharing_possible(vma, &range.start,\n\t\t\t\t\t\t     &range.end);\n\t}\n\tmmu_notifier_invalidate_range_start(&range);\n\n\twhile (page_vma_mapped_walk(&pvmw)) {\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\t\t/* PMD-mapped THP migration entry */\n\t\tif (!pvmw.pte) {\n\t\t\tsubpage = folio_page(folio,\n\t\t\t\tpmd_pfn(*pvmw.pmd) - folio_pfn(folio));\n\t\t\tVM_BUG_ON_FOLIO(folio_test_hugetlb(folio) ||\n\t\t\t\t\t!folio_test_pmd_mappable(folio), folio);\n\n\t\t\tif (set_pmd_migration_entry(&pvmw, subpage)) {\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\t/* Unexpected PMD-mapped THP? */\n\t\tVM_BUG_ON_FOLIO(!pvmw.pte, folio);\n\n\t\tif (folio_is_zone_device(folio)) {\n\t\t\t/*\n\t\t\t * Our PTE is a non-present device exclusive entry and\n\t\t\t * calculating the subpage as for the common case would\n\t\t\t * result in an invalid pointer.\n\t\t\t *\n\t\t\t * Since only PAGE_SIZE pages can currently be\n\t\t\t * migrated, just set it to page. This will need to be\n\t\t\t * changed when hugepage migrations to device private\n\t\t\t * memory are supported.\n\t\t\t */\n\t\t\tVM_BUG_ON_FOLIO(folio_nr_pages(folio) > 1, folio);\n\t\t\tsubpage = &folio->page;\n\t\t} else {\n\t\t\tsubpage = folio_page(folio,\n\t\t\t\t\tpte_pfn(*pvmw.pte) - folio_pfn(folio));\n\t\t}\n\t\taddress = pvmw.address;\n\t\tanon_exclusive = folio_test_anon(folio) &&\n\t\t\t\t PageAnonExclusive(subpage);\n\n\t\tif (folio_test_hugetlb(folio)) {\n\t\t\tbool anon = folio_test_anon(folio);\n\n\t\t\t/*\n\t\t\t * huge_pmd_unshare may unmap an entire PMD page.\n\t\t\t * There is no way of knowing exactly which PMDs may\n\t\t\t * be cached for this mm, so we must flush them all.\n\t\t\t * start/end were already adjusted above to cover this\n\t\t\t * range.\n\t\t\t */\n\t\t\tflush_cache_range(vma, range.start, range.end);\n\n\t\t\t/*\n\t\t\t * To call huge_pmd_unshare, i_mmap_rwsem must be\n\t\t\t * held in write mode.  Caller needs to explicitly\n\t\t\t * do this outside rmap routines.\n\t\t\t */\n\t\t\tVM_BUG_ON(!anon && !(flags & TTU_RMAP_LOCKED));\n\t\t\tif (!anon && huge_pmd_unshare(mm, vma, address, pvmw.pte)) {\n\t\t\t\tflush_tlb_range(vma, range.start, range.end);\n\t\t\t\tmmu_notifier_invalidate_range(mm, range.start,\n\t\t\t\t\t\t\t      range.end);\n\n\t\t\t\t/*\n\t\t\t\t * The ref count of the PMD page was dropped\n\t\t\t\t * which is part of the way map counting\n\t\t\t\t * is done for shared PMDs.  Return 'true'\n\t\t\t\t * here.  When there is no other sharing,\n\t\t\t\t * huge_pmd_unshare returns false and we will\n\t\t\t\t * unmap the actual page and drop map count\n\t\t\t\t * to zero.\n\t\t\t\t */\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Nuke the hugetlb page table entry */\n\t\t\tpteval = huge_ptep_clear_flush(vma, address, pvmw.pte);\n\t\t} else {\n\t\t\tflush_cache_page(vma, address, pte_pfn(*pvmw.pte));\n\t\t\t/* Nuke the page table entry. */\n\t\t\tpteval = ptep_clear_flush(vma, address, pvmw.pte);\n\t\t}\n\n\t\t/* Set the dirty flag on the folio now the pte is gone. */\n\t\tif (pte_dirty(pteval))\n\t\t\tfolio_mark_dirty(folio);\n\n\t\t/* Update high watermark before we lower rss */\n\t\tupdate_hiwater_rss(mm);\n\n\t\tif (folio_is_device_private(folio)) {\n\t\t\tunsigned long pfn = folio_pfn(folio);\n\t\t\tswp_entry_t entry;\n\t\t\tpte_t swp_pte;\n\n\t\t\tif (anon_exclusive)\n\t\t\t\tBUG_ON(page_try_share_anon_rmap(subpage));\n\n\t\t\t/*\n\t\t\t * Store the pfn of the page in a special migration\n\t\t\t * pte. do_swap_page() will wait until the migration\n\t\t\t * pte is removed and then restart fault handling.\n\t\t\t */\n\t\t\tentry = pte_to_swp_entry(pteval);\n\t\t\tif (is_writable_device_private_entry(entry))\n\t\t\t\tentry = make_writable_migration_entry(pfn);\n\t\t\telse if (anon_exclusive)\n\t\t\t\tentry = make_readable_exclusive_migration_entry(pfn);\n\t\t\telse\n\t\t\t\tentry = make_readable_migration_entry(pfn);\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\n\t\t\t/*\n\t\t\t * pteval maps a zone device page and is therefore\n\t\t\t * a swap pte.\n\t\t\t */\n\t\t\tif (pte_swp_soft_dirty(pteval))\n\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\tif (pte_swp_uffd_wp(pteval))\n\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\tset_pte_at(mm, pvmw.address, pvmw.pte, swp_pte);\n\t\t\ttrace_set_migration_pte(pvmw.address, pte_val(swp_pte),\n\t\t\t\t\t\tcompound_order(&folio->page));\n\t\t\t/*\n\t\t\t * No need to invalidate here it will synchronize on\n\t\t\t * against the special swap migration pte.\n\t\t\t */\n\t\t} else if (PageHWPoison(subpage)) {\n\t\t\tpteval = swp_entry_to_pte(make_hwpoison_entry(subpage));\n\t\t\tif (folio_test_hugetlb(folio)) {\n\t\t\t\thugetlb_count_sub(folio_nr_pages(folio), mm);\n\t\t\t\tset_huge_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t} else {\n\t\t\t\tdec_mm_counter(mm, mm_counter(&folio->page));\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t}\n\n\t\t} else if (pte_unused(pteval) && !userfaultfd_armed(vma)) {\n\t\t\t/*\n\t\t\t * The guest indicated that the page content is of no\n\t\t\t * interest anymore. Simply discard the pte, vmscan\n\t\t\t * will take care of the rest.\n\t\t\t * A future reference will then fault in a new zero\n\t\t\t * page. When userfaultfd is active, we must not drop\n\t\t\t * this page though, as its main user (postcopy\n\t\t\t * migration) will not expect userfaults on already\n\t\t\t * copied pages.\n\t\t\t */\n\t\t\tdec_mm_counter(mm, mm_counter(&folio->page));\n\t\t\t/* We have to invalidate as we cleared the pte */\n\t\t\tmmu_notifier_invalidate_range(mm, address,\n\t\t\t\t\t\t      address + PAGE_SIZE);\n\t\t} else {\n\t\t\tswp_entry_t entry;\n\t\t\tpte_t swp_pte;\n\n\t\t\tif (arch_unmap_one(mm, vma, address, pteval) < 0) {\n\t\t\t\tif (folio_test_hugetlb(folio))\n\t\t\t\t\tset_huge_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\telse\n\t\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVM_BUG_ON_PAGE(pte_write(pteval) && folio_test_anon(folio) &&\n\t\t\t\t       !anon_exclusive, subpage);\n\t\t\tif (anon_exclusive &&\n\t\t\t    page_try_share_anon_rmap(subpage)) {\n\t\t\t\tif (folio_test_hugetlb(folio))\n\t\t\t\t\tset_huge_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\telse\n\t\t\t\t\tset_pte_at(mm, address, pvmw.pte, pteval);\n\t\t\t\tret = false;\n\t\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Store the pfn of the page in a special migration\n\t\t\t * pte. do_swap_page() will wait until the migration\n\t\t\t * pte is removed and then restart fault handling.\n\t\t\t */\n\t\t\tif (pte_write(pteval))\n\t\t\t\tentry = make_writable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(subpage));\n\t\t\telse if (anon_exclusive)\n\t\t\t\tentry = make_readable_exclusive_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(subpage));\n\t\t\telse\n\t\t\t\tentry = make_readable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(subpage));\n\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_soft_dirty(pteval))\n\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\tif (pte_uffd_wp(pteval))\n\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\tif (folio_test_hugetlb(folio))\n\t\t\t\tset_huge_pte_at(mm, address, pvmw.pte, swp_pte);\n\t\t\telse\n\t\t\t\tset_pte_at(mm, address, pvmw.pte, swp_pte);\n\t\t\ttrace_set_migration_pte(address, pte_val(swp_pte),\n\t\t\t\t\t\tcompound_order(&folio->page));\n\t\t\t/*\n\t\t\t * No need to invalidate here it will synchronize on\n\t\t\t * against the special swap migration pte.\n\t\t\t */\n\t\t}\n\n\t\t/*\n\t\t * No need to call mmu_notifier_invalidate_range() it has be\n\t\t * done above for all cases requiring it to happen under page\n\t\t * table lock before mmu_notifier_invalidate_range_end()\n\t\t *\n\t\t * See Documentation/mm/mmu_notifier.rst\n\t\t */\n\t\tpage_remove_rmap(subpage, vma, folio_test_hugetlb(folio));\n\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\tmlock_page_drain_local();\n\t\tfolio_put(folio);\n\t}\n\n\tmmu_notifier_invalidate_range_end(&range);\n\n\treturn ret;\n}\n\n/**\n * try_to_migrate - try to replace all page table mappings with swap entries\n * @folio: the folio to replace page table entries for\n * @flags: action and flags\n *\n * Tries to remove all the page table entries which are mapping this folio and\n * replace them with special swap entries. Caller must hold the folio lock.\n */\nvoid try_to_migrate(struct folio *folio, enum ttu_flags flags)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_migrate_one,\n\t\t.arg = (void *)flags,\n\t\t.done = page_not_mapped,\n\t\t.anon_lock = folio_lock_anon_vma_read,\n\t};\n\n\t/*\n\t * Migration always ignores mlock and only supports TTU_RMAP_LOCKED and\n\t * TTU_SPLIT_HUGE_PMD and TTU_SYNC flags.\n\t */\n\tif (WARN_ON_ONCE(flags & ~(TTU_RMAP_LOCKED | TTU_SPLIT_HUGE_PMD |\n\t\t\t\t\tTTU_SYNC)))\n\t\treturn;\n\n\tif (folio_is_zone_device(folio) &&\n\t    (!folio_is_device_private(folio) && !folio_is_device_coherent(folio)))\n\t\treturn;\n\n\t/*\n\t * During exec, a temporary VMA is setup and later moved.\n\t * The VMA is moved under the anon_vma lock but not the\n\t * page tables leading to a race where migration cannot\n\t * find the migration ptes. Rather than increasing the\n\t * locking requirements of exec(), migration skips\n\t * temporary VMAs until after exec() completes.\n\t */\n\tif (!folio_test_ksm(folio) && folio_test_anon(folio))\n\t\trwc.invalid_vma = invalid_migration_vma;\n\n\tif (flags & TTU_RMAP_LOCKED)\n\t\trmap_walk_locked(folio, &rwc);\n\telse\n\t\trmap_walk(folio, &rwc);\n}\n\n#ifdef CONFIG_DEVICE_PRIVATE\nstruct make_exclusive_args {\n\tstruct mm_struct *mm;\n\tunsigned long address;\n\tvoid *owner;\n\tbool valid;\n};\n\nstatic bool page_make_device_exclusive_one(struct folio *folio,\n\t\tstruct vm_area_struct *vma, unsigned long address, void *priv)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tDEFINE_FOLIO_VMA_WALK(pvmw, folio, vma, address, 0);\n\tstruct make_exclusive_args *args = priv;\n\tpte_t pteval;\n\tstruct page *subpage;\n\tbool ret = true;\n\tstruct mmu_notifier_range range;\n\tswp_entry_t entry;\n\tpte_t swp_pte;\n\n\tmmu_notifier_range_init_owner(&range, MMU_NOTIFY_EXCLUSIVE, 0, vma,\n\t\t\t\t      vma->vm_mm, address, min(vma->vm_end,\n\t\t\t\t      address + folio_size(folio)),\n\t\t\t\t      args->owner);\n\tmmu_notifier_invalidate_range_start(&range);\n\n\twhile (page_vma_mapped_walk(&pvmw)) {\n\t\t/* Unexpected PMD-mapped THP? */\n\t\tVM_BUG_ON_FOLIO(!pvmw.pte, folio);\n\n\t\tif (!pte_present(*pvmw.pte)) {\n\t\t\tret = false;\n\t\t\tpage_vma_mapped_walk_done(&pvmw);\n\t\t\tbreak;\n\t\t}\n\n\t\tsubpage = folio_page(folio,\n\t\t\t\tpte_pfn(*pvmw.pte) - folio_pfn(folio));\n\t\taddress = pvmw.address;\n\n\t\t/* Nuke the page table entry. */\n\t\tflush_cache_page(vma, address, pte_pfn(*pvmw.pte));\n\t\tpteval = ptep_clear_flush(vma, address, pvmw.pte);\n\n\t\t/* Set the dirty flag on the folio now the pte is gone. */\n\t\tif (pte_dirty(pteval))\n\t\t\tfolio_mark_dirty(folio);\n\n\t\t/*\n\t\t * Check that our target page is still mapped at the expected\n\t\t * address.\n\t\t */\n\t\tif (args->mm == mm && args->address == address &&\n\t\t    pte_write(pteval))\n\t\t\targs->valid = true;\n\n\t\t/*\n\t\t * Store the pfn of the page in a special migration\n\t\t * pte. do_swap_page() will wait until the migration\n\t\t * pte is removed and then restart fault handling.\n\t\t */\n\t\tif (pte_write(pteval))\n\t\t\tentry = make_writable_device_exclusive_entry(\n\t\t\t\t\t\t\tpage_to_pfn(subpage));\n\t\telse\n\t\t\tentry = make_readable_device_exclusive_entry(\n\t\t\t\t\t\t\tpage_to_pfn(subpage));\n\t\tswp_pte = swp_entry_to_pte(entry);\n\t\tif (pte_soft_dirty(pteval))\n\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\tif (pte_uffd_wp(pteval))\n\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\n\t\tset_pte_at(mm, address, pvmw.pte, swp_pte);\n\n\t\t/*\n\t\t * There is a reference on the page for the swap entry which has\n\t\t * been removed, so shouldn't take another.\n\t\t */\n\t\tpage_remove_rmap(subpage, vma, false);\n\t}\n\n\tmmu_notifier_invalidate_range_end(&range);\n\n\treturn ret;\n}\n\n/**\n * folio_make_device_exclusive - Mark the folio exclusively owned by a device.\n * @folio: The folio to replace page table entries for.\n * @mm: The mm_struct where the folio is expected to be mapped.\n * @address: Address where the folio is expected to be mapped.\n * @owner: passed to MMU_NOTIFY_EXCLUSIVE range notifier callbacks\n *\n * Tries to remove all the page table entries which are mapping this\n * folio and replace them with special device exclusive swap entries to\n * grant a device exclusive access to the folio.\n *\n * Context: Caller must hold the folio lock.\n * Return: false if the page is still mapped, or if it could not be unmapped\n * from the expected address. Otherwise returns true (success).\n */\nstatic bool folio_make_device_exclusive(struct folio *folio,\n\t\tstruct mm_struct *mm, unsigned long address, void *owner)\n{\n\tstruct make_exclusive_args args = {\n\t\t.mm = mm,\n\t\t.address = address,\n\t\t.owner = owner,\n\t\t.valid = false,\n\t};\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = page_make_device_exclusive_one,\n\t\t.done = page_not_mapped,\n\t\t.anon_lock = folio_lock_anon_vma_read,\n\t\t.arg = &args,\n\t};\n\n\t/*\n\t * Restrict to anonymous folios for now to avoid potential writeback\n\t * issues.\n\t */\n\tif (!folio_test_anon(folio))\n\t\treturn false;\n\n\trmap_walk(folio, &rwc);\n\n\treturn args.valid && !folio_mapcount(folio);\n}\n\n/**\n * make_device_exclusive_range() - Mark a range for exclusive use by a device\n * @mm: mm_struct of associated target process\n * @start: start of the region to mark for exclusive device access\n * @end: end address of region\n * @pages: returns the pages which were successfully marked for exclusive access\n * @owner: passed to MMU_NOTIFY_EXCLUSIVE range notifier to allow filtering\n *\n * Returns: number of pages found in the range by GUP. A page is marked for\n * exclusive access only if the page pointer is non-NULL.\n *\n * This function finds ptes mapping page(s) to the given address range, locks\n * them and replaces mappings with special swap entries preventing userspace CPU\n * access. On fault these entries are replaced with the original mapping after\n * calling MMU notifiers.\n *\n * A driver using this to program access from a device must use a mmu notifier\n * critical section to hold a device specific lock during programming. Once\n * programming is complete it should drop the page lock and reference after\n * which point CPU access to the page will revoke the exclusive access.\n */\nint make_device_exclusive_range(struct mm_struct *mm, unsigned long start,\n\t\t\t\tunsigned long end, struct page **pages,\n\t\t\t\tvoid *owner)\n{\n\tlong npages = (end - start) >> PAGE_SHIFT;\n\tlong i;\n\n\tnpages = get_user_pages_remote(mm, start, npages,\n\t\t\t\t       FOLL_GET | FOLL_WRITE | FOLL_SPLIT_PMD,\n\t\t\t\t       pages, NULL, NULL);\n\tif (npages < 0)\n\t\treturn npages;\n\n\tfor (i = 0; i < npages; i++, start += PAGE_SIZE) {\n\t\tstruct folio *folio = page_folio(pages[i]);\n\t\tif (PageTail(pages[i]) || !folio_trylock(folio)) {\n\t\t\tfolio_put(folio);\n\t\t\tpages[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!folio_make_device_exclusive(folio, mm, start, owner)) {\n\t\t\tfolio_unlock(folio);\n\t\t\tfolio_put(folio);\n\t\t\tpages[i] = NULL;\n\t\t}\n\t}\n\n\treturn npages;\n}\nEXPORT_SYMBOL_GPL(make_device_exclusive_range);\n#endif\n\nvoid __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}\n\nstatic struct anon_vma *rmap_walk_anon_lock(struct folio *folio,\n\t\t\t\t\t    struct rmap_walk_control *rwc)\n{\n\tstruct anon_vma *anon_vma;\n\n\tif (rwc->anon_lock)\n\t\treturn rwc->anon_lock(folio, rwc);\n\n\t/*\n\t * Note: remove_migration_ptes() cannot use folio_lock_anon_vma_read()\n\t * because that depends on page_mapped(); but not all its usages\n\t * are holding mmap_lock. Users without mmap_lock are required to\n\t * take a reference count to prevent the anon_vma disappearing\n\t */\n\tanon_vma = folio_anon_vma(folio);\n\tif (!anon_vma)\n\t\treturn NULL;\n\n\tif (anon_vma_trylock_read(anon_vma))\n\t\tgoto out;\n\n\tif (rwc->try_lock) {\n\t\tanon_vma = NULL;\n\t\trwc->contended = true;\n\t\tgoto out;\n\t}\n\n\tanon_vma_lock_read(anon_vma);\nout:\n\treturn anon_vma;\n}\n\n/*\n * rmap_walk_anon - do something to anonymous page using the object-based\n * rmap method\n * @page: the page to be handled\n * @rwc: control variable according to each walk type\n *\n * Find all the mappings of a page using the mapping pointer and the vma chains\n * contained in the anon_vma struct it points to.\n */\nstatic void rmap_walk_anon(struct folio *folio,\n\t\tstruct rmap_walk_control *rwc, bool locked)\n{\n\tstruct anon_vma *anon_vma;\n\tpgoff_t pgoff_start, pgoff_end;\n\tstruct anon_vma_chain *avc;\n\n\tif (locked) {\n\t\tanon_vma = folio_anon_vma(folio);\n\t\t/* anon_vma disappear under us? */\n\t\tVM_BUG_ON_FOLIO(!anon_vma, folio);\n\t} else {\n\t\tanon_vma = rmap_walk_anon_lock(folio, rwc);\n\t}\n\tif (!anon_vma)\n\t\treturn;\n\n\tpgoff_start = folio_pgoff(folio);\n\tpgoff_end = pgoff_start + folio_nr_pages(folio) - 1;\n\tanon_vma_interval_tree_foreach(avc, &anon_vma->rb_root,\n\t\t\tpgoff_start, pgoff_end) {\n\t\tstruct vm_area_struct *vma = avc->vma;\n\t\tunsigned long address = vma_address(&folio->page, vma);\n\n\t\tVM_BUG_ON_VMA(address == -EFAULT, vma);\n\t\tcond_resched();\n\n\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\tcontinue;\n\n\t\tif (!rwc->rmap_one(folio, vma, address, rwc->arg))\n\t\t\tbreak;\n\t\tif (rwc->done && rwc->done(folio))\n\t\t\tbreak;\n\t}\n\n\tif (!locked)\n\t\tanon_vma_unlock_read(anon_vma);\n}\n\n/*\n * rmap_walk_file - do something to file page using the object-based rmap method\n * @page: the page to be handled\n * @rwc: control variable according to each walk type\n *\n * Find all the mappings of a page using the mapping pointer and the vma chains\n * contained in the address_space struct it points to.\n */\nstatic void rmap_walk_file(struct folio *folio,\n\t\tstruct rmap_walk_control *rwc, bool locked)\n{\n\tstruct address_space *mapping = folio_mapping(folio);\n\tpgoff_t pgoff_start, pgoff_end;\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * The page lock not only makes sure that page->mapping cannot\n\t * suddenly be NULLified by truncation, it makes sure that the\n\t * structure at mapping cannot be freed and reused yet,\n\t * so we can safely take mapping->i_mmap_rwsem.\n\t */\n\tVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);\n\n\tif (!mapping)\n\t\treturn;\n\n\tpgoff_start = folio_pgoff(folio);\n\tpgoff_end = pgoff_start + folio_nr_pages(folio) - 1;\n\tif (!locked) {\n\t\tif (i_mmap_trylock_read(mapping))\n\t\t\tgoto lookup;\n\n\t\tif (rwc->try_lock) {\n\t\t\trwc->contended = true;\n\t\t\treturn;\n\t\t}\n\n\t\ti_mmap_lock_read(mapping);\n\t}\nlookup:\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap,\n\t\t\tpgoff_start, pgoff_end) {\n\t\tunsigned long address = vma_address(&folio->page, vma);\n\n\t\tVM_BUG_ON_VMA(address == -EFAULT, vma);\n\t\tcond_resched();\n\n\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\tcontinue;\n\n\t\tif (!rwc->rmap_one(folio, vma, address, rwc->arg))\n\t\t\tgoto done;\n\t\tif (rwc->done && rwc->done(folio))\n\t\t\tgoto done;\n\t}\n\ndone:\n\tif (!locked)\n\t\ti_mmap_unlock_read(mapping);\n}\n\nvoid rmap_walk(struct folio *folio, struct rmap_walk_control *rwc)\n{\n\tif (unlikely(folio_test_ksm(folio)))\n\t\trmap_walk_ksm(folio, rwc);\n\telse if (folio_test_anon(folio))\n\t\trmap_walk_anon(folio, rwc, false);\n\telse\n\t\trmap_walk_file(folio, rwc, false);\n}\n\n/* Like rmap_walk, but caller holds relevant rmap lock */\nvoid rmap_walk_locked(struct folio *folio, struct rmap_walk_control *rwc)\n{\n\t/* no ksm support for now */\n\tVM_BUG_ON_FOLIO(folio_test_ksm(folio), folio);\n\tif (folio_test_anon(folio))\n\t\trmap_walk_anon(folio, rwc, true);\n\telse\n\t\trmap_walk_file(folio, rwc, true);\n}\n\n#ifdef CONFIG_HUGETLB_PAGE\n/*\n * The following two functions are for anonymous (private mapped) hugepages.\n * Unlike common anonymous pages, anonymous hugepages have no accounting code\n * and no lru code, because we handle hugepages differently from common pages.\n *\n * RMAP_COMPOUND is ignored.\n */\nvoid hugepage_add_anon_rmap(struct page *page, struct vm_area_struct *vma,\n\t\t\t    unsigned long address, rmap_t flags)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\tint first;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!anon_vma);\n\t/* address might be in next vma when migration races vma_adjust */\n\tfirst = atomic_inc_and_test(compound_mapcount_ptr(page));\n\tVM_BUG_ON_PAGE(!first && (flags & RMAP_EXCLUSIVE), page);\n\tVM_BUG_ON_PAGE(!first && PageAnonExclusive(page), page);\n\tif (first)\n\t\t__page_set_anon_rmap(page, vma, address,\n\t\t\t\t     !!(flags & RMAP_EXCLUSIVE));\n}\n\nvoid hugepage_add_new_anon_rmap(struct page *page,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tBUG_ON(address < vma->vm_start || address >= vma->vm_end);\n\tatomic_set(compound_mapcount_ptr(page), 0);\n\tatomic_set(compound_pincount_ptr(page), 0);\n\n\t__page_set_anon_rmap(page, vma, address, 1);\n}\n#endif /* CONFIG_HUGETLB_PAGE */\n"], "filenames": ["include/linux/rmap.h", "mm/rmap.c"], "buggy_code_start_loc": [44, 96], "buggy_code_end_loc": [50, 440], "fixing_code_start_loc": [44, 96], "fixing_code_end_loc": [53, 443], "type": "CWE-416", "message": "mm/rmap.c in the Linux kernel before 5.19.7 has a use-after-free related to leaf anon_vma double reuse.", "other": {"cve": {"id": "CVE-2022-42703", "sourceIdentifier": "cve@mitre.org", "published": "2022-10-09T23:15:09.523", "lastModified": "2023-02-03T20:29:39.273", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "mm/rmap.c in the Linux kernel before 5.19.7 has a use-after-free related to leaf anon_vma double reuse."}, {"lang": "es", "value": "El archivo mm/rmap.c en el kernel de Linux versiones anteriores a 5.19.7, presenta un uso de memoria previamente liberada relacionado con un doble re\u00faso de la hoja anon_vma"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.19.7", "matchCriteriaId": "6A68E1F8-6957-46BF-A921-09842AEFCA7C"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/project-zero/issues/detail?id=2351", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.19.7", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=2555283eb40df89945557273121e9393ef9b542b", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/2555283eb40df89945557273121e9393ef9b542b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://googleprojectzero.blogspot.com/2022/12/exploiting-CVE-2022-42703-bringing-back-the-stack-attack.html", "source": "cve@mitre.org", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2555283eb40df89945557273121e9393ef9b542b"}}