{"buggy_code": ["// Pitchfork ctx defines the context that is passed through Pitchfork pertaining primarily to the logged in, selected user/group\npackage pitchfork\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"net\"\n\t\"strconv\"\n\t\"strings\"\n\n\tuseragent \"github.com/mssola/user_agent\"\n\ti18n \"github.com/nicksnyder/go-i18n/i18n\"\n)\n\n// ErrLoginIncorrect is used when a login is incorrect, this to hide more specific reasons\nvar ErrLoginIncorrect = errors.New(\"Login incorrect\")\n\n// PfNewUserI, NewGroupI, PfMenuI, PfAppPermsI, PfPostBecomeI are function definitions to allow overriding of these functions by application code\ntype PfNewUserI func() (user PfUser)\ntype PfNewGroupI func() (user PfGroup)\ntype PfMenuI func(ctx PfCtx, menu *PfMenu)\ntype PfAppPermsI func(ctx PfCtx, what string, perms Perm) (final bool, ok bool, err error)\ntype PfPostBecomeI func(ctx PfCtx)\n\n// PfModOptsI is the interface that is implemented by PfModOptsS allowing the latter to be extended with more details\ntype PfModOptsI interface {\n\tIsModOpts() bool\n}\n\n// PfModOptsS is the base structure used to impleent PfModOptsI\ntype PfModOptsS struct {\n\t// CLI command prefix, eg 'group wiki'\n\tCmdpfx string\n\n\t// URL prefix, typically System_Get().PublicURL()\n\tURLpfx string\n\n\t// Path Root\n\tPathroot string\n\n\t// URL root, inside the hostname, eg '/group/name/wiki/'\n\tURLroot string\n}\n\n// IsModOpts is a simple fakeish function to cause PfModOptsS to be of type PfModOptsI\n// as it requires this function to be present, which other structures will not satisfy.\nfunc (m PfModOptsS) IsModOpts() bool {\n\treturn true\n}\n\n// PfModOpts can be used to easily initialize a PfModOptsS.\n//\n// The arguments match the variables in the PfModOpts structure.\n//\n// The function ensures that the web_root ends in a slash ('/').\nfunc PfModOpts(ctx PfCtx, cmdpfx string, path_root string, web_root string) PfModOptsS {\n\turlpfx := System_Get().PublicURL\n\n\tweb_root = URL_EnsureSlash(web_root)\n\n\treturn PfModOptsS{cmdpfx, urlpfx, path_root, web_root}\n}\n\n// PfCtx is the Context Interface.\n//\n// PfCtxS is the default implementation.\n//\n// This interface is primarily intended to allow extension by an application.\n\n// See the individual functions in PfCtxS for per function details.\ntype PfCtx interface {\n\tGetAbort() <-chan bool\n\tSetAbort(abort <-chan bool)\n\tSetTx(tx *Tx)\n\tGetTx() (tx *Tx)\n\tErr(message string)\n\tErrf(format string, a ...interface{})\n\tLog(message string)\n\tLogf(format string, a ...interface{})\n\tDbg(message string)\n\tDbgf(format string, a ...interface{})\n\tInit() (err error)\n\tSetStatus(code int)\n\tGetStatus() (code int)\n\tSetReturnCode(rc int)\n\tGetReturnCode() (rc int)\n\tGetLoc() string\n\tGetLastPart() string\n\tBecome(user PfUser)\n\tGetToken() (tok string)\n\tNewToken() (err error)\n\tLoginToken(tok string) (expsoon bool, err error)\n\tLogin(username string, password string, twofactor string) (err error)\n\tLogout()\n\tIsLoggedIn() bool\n\tIsGroupMember() bool\n\tIAmGroupAdmin() bool\n\tIAmGroupMember() bool\n\tGroupHasWiki() bool\n\tGroupHasFile() bool\n\tGroupHasCalendar() bool\n\tSwapSysAdmin() bool\n\tIsSysAdmin() bool\n\tCheckPerms(what string, perms Perm) (ok bool, err error)\n\tCheckPermsT(what string, permstr string) (ok bool, err error)\n\tTheUser() (user PfUser)\n\tSelectedSelf() bool\n\tSelectedUser() (user PfUser)\n\tSelectedGroup() (grp PfGroup)\n\tSelectedML() (ml PfML)\n\tSelectedEmail() (email PfUserEmail)\n\tHasSelectedUser() bool\n\tHasSelectedGroup() bool\n\tHasSelectedML() bool\n\tSelectMe()\n\tSelectUser(username string, perms Perm) (err error)\n\tSelectGroup(gr_name string, perms Perm) (err error)\n\tSelectML(ml_name string, perms Perm) (err error)\n\tSelectEmail(email string) (err error)\n\tSetModOpts(opts PfModOptsI)\n\tGetModOpts() (opts interface{})\n\tPDbgf(what string, perm Perm, format string, a ...interface{})\n\tOut(txt string)\n\tOutf(format string, a ...interface{})\n\tOutLn(format string, a ...interface{})\n\tSetOutUnbuffered(obj interface{}, fun string)\n\tOutBuffered(on bool)\n\tIsBuffered() bool\n\tBuffered() (o string)\n\tGetRemote() (remote string)\n\tSetClient(clientip net.IP, remote string, ua string)\n\tGetClientIP() net.IP\n\tGetUserAgent() (string, string, string)\n\tSelectObject(obj *interface{})\n\tSelectedObject() (obj *interface{})\n\tGetLanguage() string\n\tSetLanguage(name string)\n\tGetTfunc() i18n.TranslateFunc\n\n\t// User and Group creation overrides\n\tNewUser() (user PfUser)\n\tNewUserI() (i interface{})\n\tNewGroup() (user PfGroup)\n\tNewGroupI() (i interface{})\n\n\t// Menu Overrides\n\tMenuOverride(menu *PfMenu)\n\n\t// Menu Related (menu.go)\n\tMenu(args []string, menu PfMenu) (err error)\n\tWalkMenu(args []string) (menu *PfMEntry, err error)\n\tCmd(args []string) (err error)\n\tCmdOut(cmd string, args []string) (msg string, err error)\n\tBatch(filename string) (err error)\n\n\t// Application Data\n\tSetAppData(data interface{})\n\tGetAppData() interface{}\n}\n\n// SessionClaims describe claims for a session\ntype SessionClaims struct {\n\tJWTClaims\n\tUserDesc   string `json:\"userdesc\"`\n\tIsSysAdmin bool   `json:\"issysadmin\"`\n}\n\n// PfCtxS is the default implementation of PfCtx\ntype PfCtxS struct {\n\tabort          <-chan bool        /* Abort the request */\n\tstatus         int                /* HTTP Status code */\n\treturncode     int                /* Command Line return code */\n\tloc            string             /* Command tree location */\n\toutput         string             /* Output buffer */\n\tmode_buffered  bool               /* Buffering of output in effect */\n\tuser           PfUser             /* Authenticated User */\n\tis_sysadmin    bool               /* Whether the user's sysadmin priveleges are enabled */\n\ttoken          string             /* The authentication token */\n\ttoken_claims   SessionClaims      /* Parsed Token Claims */\n\tremote         string             /* The address of the client, including X-Forwarded-For */\n\tclient_ip      net.IP             /* Client's IP addresses */\n\tua_full        string             /* The HTTP User Agent */\n\tua_browser     string             /* HTTP User Agent: Browser */\n\tua_os          string             /* HTTP User Agent: Operating System */\n\tlanguage       string             /* User's chosen language (TODO: Allow user to select it) */\n\ttfunc          i18n.TranslateFunc /* Translation function populated with current language */\n\tsel_user       PfUser             /* Selected User */\n\tsel_group      PfGroup            /* Selected Group */\n\tsel_ml         *PfML              /* Selected Mailing List */\n\tsel_email      *PfUserEmail       /* Selected User email address */\n\tsel_obj        *interface{}       /* Selected Object (ctx + struct only) */\n\tmod_opts       interface{}        /* Module Options for Messages/Wiki/Files etc */\n\tf_newuser      PfNewUserI         /* Create a new User */\n\tf_newgroup     PfNewGroupI        /* Create a new Group */\n\tf_menuoverride PfMenuI            /* Override a menu */\n\tf_appperms     PfAppPermsI        /* Application Permission Check */\n\tf_postbecome   PfPostBecomeI      /* Post Become() */\n\n\t// Unbuffered Output */\n\toutunbuf_fun string   // Function name that handles unbuffered output */\n\toutunbuf_obj ObjFuncI // Object where the function lives */\n\n\t// Database internal\n\tdb_Tx *Tx // Used for database transactions\n\n\t// Menu internal values (menu.go)\n\tmenu_walkonly bool      // Set to 'true' to indicate that only walk, do not execute; used for figuring out what arguments are needed\n\tmenu_args     []string  // Which arguments are currently requested\n\tmenu_menu     *PfMEntry // Current menu entry being attempted\n\n\t/* Application Data */\n\tappdata interface{} // Application specific data\n}\n\n// PfNewCtx allows overriding the NewCtx function, thus allowing extending PfCtx\ntype PfNewCtx func() PfCtx\n\n// NewPfCtx is used to initialize a new Pitchfork Context.\n//\n// The various arguments are all to provide the ability to replace\n// standard Pitchfork functions with application specific ones that\n// likely extends the Pitchfork functionality or that carry extra details.\n//\n// newuser is used as a function for creating new users.\n//\n// newgroup is used as a function for creating new groups.\n//\n// menuoverride is used as a function to override menu entries.\n//\n// appperms is used as a function to verify application specific permissions.\n//\n// postbecome is used as a callback after a user has changed (eg when logging in).\n//\n// All overrides are optional, and will be defaulted to the Pitchfork versions\n// when they are provided as 'nil'.\n//\n// NewPfCtx is called from the constructors of PfUI and, except for testing\n// should rarely be called directly as the context is already handed to a function.\nfunc NewPfCtx(newuser PfNewUserI, newgroup PfNewGroupI, menuoverride PfMenuI, appperms PfAppPermsI, postbecome PfPostBecomeI) PfCtx {\n\tif newuser == nil {\n\t\tnewuser = NewPfUserA\n\t}\n\n\tif newgroup == nil {\n\t\tnewgroup = NewPfGroup\n\t}\n\n\ttfunc, err := i18n.Tfunc(Config.TransDefault)\n\tif err != nil {\n\t\ttfunc = nil\n\t}\n\n\treturn &PfCtxS{f_newuser: newuser,\n\t\tf_newgroup: newgroup, f_menuoverride: menuoverride, f_appperms: appperms,\n\t\tf_postbecome: postbecome,\n\t\tlanguage:     Config.TransDefault, mode_buffered: true, tfunc: tfunc}\n}\n\n// GetAbort is used to retrieve the abort channel (as used/passed-down from the HTTP handler)\n//\n// This channel is used to indicate, by the HTTP library, that the HTTP client has\n// disconnected and that the request can be aborted as the client will never receive\n// the answer of the query.\n//\n// Used amongst others by the search infrastructure.\nfunc (ctx *PfCtxS) GetAbort() <-chan bool {\n\treturn ctx.abort\n}\n\n// SetAbort is used to set the abort channel (as used/passed-down from the HTTP handler).\n//\n// SetAbort is called from H_root() to configure the abort channel as passed down\n// from the Golang HTTP package.\nfunc (ctx *PfCtxS) SetAbort(abort <-chan bool) {\n\tctx.abort = abort\n}\n\n// GetLanguage is used to retrieve the user-selected language setting\n//\n// The returned string is in the form of a RFC2616 Accept-Language header.\n// Typically it will be 'en-us', or sometimes 'de', 'de-DE', 'de-CH' or 'es'.\nfunc (ctx *PfCtxS) GetLanguage() string {\n\treturn ctx.language\n}\n\n// SetLanguage accepts a RFC2616 style Accept-Language string\n// it then uses that information to determine the best language\n// to return.\nfunc (ctx *PfCtxS) SetLanguage(name string) {\n\tctx.language = name\n\ttfunc, err := i18n.Tfunc(name, Config.TransDefault)\n\tif err != nil {\n\t\t// XXX: Handle properly, this crashes the goproc based on invalid Accept-Language header\n\t\t// The panic might expose information to the enduser\n\t\tpanic(err.Error())\n\t}\n\tctx.tfunc = tfunc\n}\n\n// GetTfunc returns the translation function\nfunc (ctx *PfCtxS) GetTfunc() i18n.TranslateFunc {\n\treturn ctx.tfunc\n}\n\n// SetAppData can be used to set the appdata of a context.\n//\n// Typically this is used by an application's edition of a context to store\n// itself in the pitchfork context. This given that Golang does not support\n// polymorphism and thus needs a place to hide the full version of itself.\nfunc (ctx *PfCtxS) SetAppData(appdata interface{}) {\n\tctx.appdata = appdata\n}\n\n// GetAppData is used for getting application specific data inside the context.\n//\n// Typically this is used by an application's edition of a context to retrieve\n// itself from the pitchfork context. This given that Golang does not support\n// polymorphism and it needs to retrieve itself from the embedded edition of itself.\nfunc (ctx *PfCtxS) GetAppData() interface{} {\n\treturn ctx.appdata\n}\n\n// NewUser causes a new PfUser (or extended edition) to be created.\n//\n// The override for NewUser, as configured at Ctx creation time is used\n// thus allowing the application specific Ctx to be returned.\nfunc (ctx *PfCtxS) NewUser() PfUser {\n\treturn ctx.f_newuser()\n}\n\n// NewUserI is like NewUser() but returns a generic interface */\nfunc (ctx *PfCtxS) NewUserI() interface{} {\n\treturn ctx.f_newuser()\n}\n\n// NewGroup causes a new PfGroup to be created by calling the\n// application defined edition of a NewGroup function.\nfunc (ctx *PfCtxS) NewGroup() PfGroup {\n\treturn ctx.f_newgroup()\n}\n\n// NewGroupI is like NewGroup() but returns a generic interface\nfunc (ctx *PfCtxS) NewGroupI() interface{} {\n\treturn ctx.f_newgroup()\n}\n\n// MenuOverride is called before a menu is further processed,\n// allowing entries to be modified by calling the callback.\n//\n// As noted, it is an optional override.\nfunc (ctx *PfCtxS) MenuOverride(menu *PfMenu) {\n\tif ctx.f_menuoverride != nil {\n\t\tctx.f_menuoverride(ctx, menu)\n\t}\n}\n\n// SetTx is used by the database code to select the current transaction\nfunc (ctx *PfCtxS) SetTx(tx *Tx) {\n\tctx.db_Tx = tx\n}\n\n// GetTx is used by the database code to get the current transaction\nfunc (ctx *PfCtxS) GetTx() (tx *Tx) {\n\treturn ctx.db_Tx\n}\n\n// GetRemote retrieves the remote address of the user/connection.\n//\n// The address is a IPv4 or IPv6 textual representation.\nfunc (ctx *PfCtxS) GetRemote() (remote string) {\n\treturn ctx.remote\n}\n\n// SetClient is used for configuring the client IP, remote address and Full User Agent strings.\n//\n// Typically not called from an application, but from cui's SetClientIP()\n// which in turn gets called from the H_root.\n//\n// The clientip is a pre-parsed IP address and XFF-filtered hops.\n//\n// Remote contains the full IP address string (including X-Forwarded-For hops).\n//\n// Fullua contains the HTTP User-Agent header.\n//\n// This function sets the variables of the Ctx (client_ip, remote) and parses\n// the Fullua (Full User-Agent) variable, storing the details in Ctx.\nfunc (ctx *PfCtxS) SetClient(clientip net.IP, remote string, fullua string) {\n\tctx.client_ip = clientip\n\tctx.remote = remote\n\n\t/* Split the UA in several parts */\n\tua := useragent.New(fullua)\n\tctx.ua_full = fullua\n\tif ua != nil {\n\t\tctx.ua_browser, _ = ua.Browser()\n\t\tctx.ua_os = ua.OS()\n\t} else {\n\t\t/* Did not parse as it is the CLI */\n\t\tif clientip.IsLoopback() {\n\t\t\tctx.ua_browser = \"Tickly\"\n\t\t\tctx.ua_os = \"Trident\"\n\t\t} else {\n\t\t\tctx.ua_browser = \"unknown\"\n\t\t\tctx.ua_os = \"unknown\"\n\t\t}\n\t}\n}\n\n// GetClientIP is used to get the client's IP address\nfunc (ctx *PfCtxS) GetClientIP() net.IP {\n\treturn ctx.client_ip\n}\n\n// GetUserAgent is used for retrieving the parsed User Agent; see also SetClient()\nfunc (ctx *PfCtxS) GetUserAgent() (string, string, string) {\n\treturn ctx.ua_full, ctx.ua_browser, ctx.ua_os\n}\n\n// SelectObject is used by the struct code (lib/struct.go) to set the\n// object that it wants to keep track of during parsing.\nfunc (ctx *PfCtxS) SelectObject(obj *interface{}) {\n\tctx.sel_obj = obj\n}\n\n// SelectedObject is used by the struct code to retrieve\n// the object it is currently parsing.\nfunc (ctx *PfCtxS) SelectedObject() (obj *interface{}) {\n\treturn ctx.sel_obj\n}\n\n// SetModOpts allows setting the options for the wiki and file modules\nfunc (ctx *PfCtxS) SetModOpts(opts PfModOptsI) {\n\tctx.mod_opts = opts\n}\n\n// GetModOpts allows getting the options for the wiki and file modules\nfunc (ctx *PfCtxS) GetModOpts() (opts interface{}) {\n\treturn ctx.mod_opts\n}\n\n// Perm is used for storing the OR value of permissions\n//\n// Note: Keep in sync with permnames && ui/ui (convenience for all the menus there).\n//\n// It is used as a bitfield, hence multiple perms are possible by ORing them together.\n// Check access using the CheckPerms() function.\n//\n// The perms use the context's sel_{user|group|ml|*} variables to check if those permissions match.\n//\n// Being a SysAdmin overrides almost all permissions!\n//\n// Change the 'false' in PDbg to 'true' to see what permission decisions are being made.\n//\n// Application permissions are fully handled by the application.\n// See the CheckPerms function for more details.\ntype Perm uint64\n\n// PERM_* define the permissions in the system.\n//\n// Each permission tests as true when the given condition is met.\n// See the per permission desciption for what condition they test for.\n//\n// The permissions are listed from weak (NONE) to strong (NOBODY).\n//\n// Permissions can be ORed together, the strongest are tested first.\n//\n// Not all combinations will make sense. eg combining PERM_GUEST|PERM_USER\n// means that both not-loggedin and loggedin users have access, at which\n// point the check can just be replaced with PERM_NONE.\n//\n// Application permissions our application specific.\n//\n// The PERM_'s marked 'Flag' are not used for checking permissions\n// but used for modifying the behavior of a menu entry.\n\nconst (\n\tPERM_NOTHING        Perm = 0         // Nothing / empty permissions, primarily used for initialization, should not be found in code as it indicates that the Permission was not configured and thus should normally not be used\n\tPERM_NONE           Perm = 1 << iota // No permissions needed (authenticated or unauthenticated is okay), typically combined with the a Flag like PERM_HIDDEN or PERM_NOSUBS\n\tPERM_GUEST                           // Tests that the user is not authenticated: The user is a Guest of the system; does not accept authenticated sessions\n\tPERM_USER                            // Tests that the user is logged in: the user has authenticated\n\tPERM_USER_SELF                       // Tests that the selected user matches the logged in user\n\tPERM_USER_NOMINATE                   // Tests that the user can nominate the selected user\n\tPERM_USER_VIEW                       // Tests that the user can view the selected user\n\tPERM_GROUP_MEMBER                    // Tests that the selected user is an active member of the selected group that can see the group\n\tPERM_GROUP_ADMIN                     // Tests that the selected user is an Admin of the selected group\n\tPERM_GROUP_WIKI                      // Tests that the selected Group has the Wiki section enabled\n\tPERM_GROUP_FILE                      // Tests that the selected Group has the File section enabled\n\tPERM_GROUP_CALENDAR                  // Tests that the selected Group has the Calendar section enabled\n\tPERM_SYS_ADMIN                       // Tests that the user is a System Administrator\n\tPERM_SYS_ADMIN_CAN                   // Can be a System Administrator\n\tPERM_CLI                             // Tests when the CLI option is enabled in system settings\n\tPERM_API                             // Tests when the API option is enabled in system settings\n\tPERM_OAUTH                           // Tests when the OAUTH option is enabled in system settings\n\tPERM_LOOPBACK                        // Tests that the connection comes from loopback (127.0.0.1 / ::1 as the Client/Remote IP address)\n\tPERM_HIDDEN                          // Flag: The menu option is hidden\n\tPERM_NOCRUMB                         // Flag: Don't add a crumb for this menu\n\tPERM_NOSUBS                          // Flag: No sub menus for this menu entry. See the NoSubs function for more details.\n\tPERM_NOBODY                          // Absolutely nobody has access (highest priority, first checked)\n\n\t// Application permissions - defined by the application\n\tPERM_APP_0\n\tPERM_APP_1\n\tPERM_APP_2\n\tPERM_APP_3\n\tPERM_APP_4\n\tPERM_APP_5\n\tPERM_APP_6\n\tPERM_APP_7\n\tPERM_APP_8\n\tPERM_APP_9\n)\n\n// permnames contains the human readable names matching the permissions\nvar permnames []string\n\n// init is used to initialize permnames and verify that they are correct, at least in count\nfunc init() {\n\tpermnames = []string{\n\t\t\"nothing\",\n\t\t\"none\",\n\t\t\"guest\",\n\t\t\"user\",\n\t\t\"self\",\n\t\t\"user_nominate\",\n\t\t\"user_view\",\n\t\t\"group_member\",\n\t\t\"group_admin\",\n\t\t\"group_wiki\",\n\t\t\"group_file\",\n\t\t\"group_calendar\",\n\t\t\"sysadmin\",\n\t\t\"sysadmin_can\",\n\t\t\"cli\",\n\t\t\"api\",\n\t\t\"oauth\",\n\t\t\"loopback\",\n\t\t\"hidden\",\n\t\t\"nocrumb\",\n\t\t\"nosubs\",\n\t\t\"nobody\",\n\t\t\"app_0\",\n\t\t\"app_1\",\n\t\t\"app_2\",\n\t\t\"app_3\",\n\t\t\"app_4\",\n\t\t\"app_5\",\n\t\t\"app_6\",\n\t\t\"app_7\",\n\t\t\"app_9\",\n\t}\n\n\t// Verify that the correct amount of permissions is present\n\tmax := uint64(1 << uint64(len(permnames)))\n\tif max != uint64(PERM_APP_9) {\n\t\tfmt.Printf(\"Expected %d got %d\\n\", max, PERM_APP_9)\n\t\tpanic(\"Invalid permnames\")\n\t}\n}\n\n// Shortcutted commonly used HTTP error codes\nconst (\n\tStatusOK           = 200\n\tStatusUnauthorized = 401\n)\n\n// Debug is a Global Debug flag, used primarily for determining if debug messages should be output. Typically toggled by flags\nvar Debug = false\n\n// Init is the \"constructor\" for Pitchfork Contexts\nfunc (ctx *PfCtxS) Init() (err error) {\n\t// Default HTTP status\n\tctx.status = StatusOK\n\n\t// Default Shell Return Code to 0\n\tctx.returncode = 0\n\n\treturn err\n}\n\n// SetStatus can be used by a h_* function to set the status of the context.\n//\n// The status typically matches a HTTP error (eg StatusNotFound from golang HTTP library).\n//\n// The final status is flushed out during UI's Flush() time.\n//\n// The status code is tracked in lib instead of the UI layer to allow a generic\n// status code system inside Pitchfork.\nfunc (ctx *PfCtxS) SetStatus(code int) {\n\tctx.status = code\n}\n\n// GetStatus can be used to get the status of the context.\n//\n// Typically only called by UI Flush(), but in theory could be used\n// by an application/function to check the current error code too.\nfunc (ctx *PfCtxS) GetStatus() (code int) {\n\treturn ctx.status\n}\n\n// SetReturnCode is used by the CLI edition of tools to return a Shell Return Code.\nfunc (ctx *PfCtxS) SetReturnCode(rc int) {\n\tctx.returncode = rc\n}\n\n// GetReturnCode is used by the CLI edition of tools to fetch the set Shell Return Code.\n//\n// During UI Flush() this error code is fetched and when not-0 reported as X-ReturnCode.\nfunc (ctx *PfCtxS) GetReturnCode() (rc int) {\n\treturn ctx.returncode\n}\n\n// GetLoc returns where in the CLI menu system our code is located (XXX: Improve naming).\n//\n// This function is typically called by MenuOverrides so that they can determine\n// where they are and thus what they might want to change.\nfunc (ctx *PfCtxS) GetLoc() string {\n\treturn ctx.loc\n}\n\n// GetLastPart is used to get the last portion of the location (XXX: Improve naming).\nfunc (ctx *PfCtxS) GetLastPart() string {\n\tfa := strings.Split(ctx.loc, \" \")\n\treturn fa[len(fa)-1]\n}\n\n// Become can be used to become the given user.\n//\n// The context code that logs in a user uses this.\n// This can be used for a 'sudo' type mechanism as is cmd/setup/sudo.go.\n//\n// After changing users, the PostBecome function is called when configured.\n// This allows an application to for instance update state or other such\n// properties when the user changes.\n//\n// Use sparingly and after properly checking permissions to see if\n// the user is really supposed to be able to become that user.\nfunc (ctx *PfCtxS) Become(user PfUser) {\n\t// Use the details from the user\n\tctx.user = user\n\n\t// Select one-self\n\tctx.sel_user = user\n\n\t// Post Become() hook if configured\n\tif ctx.f_postbecome != nil {\n\t\tctx.f_postbecome(ctx)\n\t}\n}\n\n// GetToken retrieves the authentication token (JWT) provided by the user, if any\nfunc (ctx *PfCtxS) GetToken() (tok string) {\n\treturn ctx.token\n}\n\n// NewToken causes a new JWT websession token to be generated for loggedin users\nfunc (ctx *PfCtxS) NewToken() (err error) {\n\tif !ctx.IsLoggedIn() {\n\t\treturn errors.New(\"Not authenticated\")\n\t}\n\n\ttheuser := ctx.TheUser()\n\n\t// Set some claims\n\tctx.token_claims.UserDesc = theuser.GetFullName()\n\tctx.token_claims.IsSysAdmin = ctx.is_sysadmin\n\n\tusername := theuser.GetUserName()\n\n\t// Create the token\n\ttoken := Token_New(\"websession\", username, TOKEN_EXPIRATIONMINUTES, &ctx.token_claims)\n\n\t// Sign and get the complete encoded token as a string\n\tctx.token, err = token.Sign()\n\tif err != nil {\n\t\t// Invalid token when something went wrong\n\t\tctx.token = \"\"\n\t}\n\n\treturn\n}\n\n// LoginToken can be used to log in using a token.\n//\n// It takes a JWT encoded as a string.\n// It returns a boolean indicating if the token is going to expire soon\n// (and thus indicating that a new token should be sent out to the user)\n// and/or an error to indicate failure.\nfunc (ctx *PfCtxS) LoginToken(tok string) (expsoon bool, err error) {\n\t// No valid token\n\tctx.token = \"\"\n\n\t// Not a SysAdmin\n\tctx.is_sysadmin = false\n\n\t// Parse the provided token\n\texpsoon, err = Token_Parse(tok, \"websession\", &ctx.token_claims)\n\tif err != nil {\n\t\treturn expsoon, err\n\t}\n\n\t// Who they claim they are\n\tuser := ctx.NewUser()\n\tuser.SetUserName(ctx.token_claims.Subject)\n\tuser.SetFullName(ctx.token_claims.UserDesc)\n\tctx.is_sysadmin = ctx.token_claims.IsSysAdmin\n\n\t// Fetch the details\n\terr = user.Refresh(ctx)\n\tif err == ErrNoRows {\n\t\tctx.Dbgf(\"No such user %q\", ctx.token_claims.Subject)\n\t\treturn false, errors.New(\"No such user\")\n\t} else if err != nil {\n\t\tctx.Dbgf(\"Fetch of user %q failed: %s\", ctx.token_claims.Subject, err.Error())\n\t\treturn false, err\n\t}\n\n\t// Looking good, become the user\n\tctx.Become(user)\n\n\t// Valid Token\n\tctx.token = tok\n\n\treturn expsoon, nil\n}\n\n// Login can be used to login using a username, password\n// and optionally, when configured, a twofactor code.\n//\n// A userevent is logged when this function was succesful.\nfunc (ctx *PfCtxS) Login(username string, password string, twofactor string) (err error) {\n\t// The new user */\n\tuser := ctx.NewUser()\n\n\terr = user.CheckAuth(ctx, username, password, twofactor)\n\tif err != nil {\n\t\t/* Log the error, so that it can be looked up in the log */\n\t\tctx.Errf(\"CheckAuth(%s): %s\", username, err)\n\n\t\t/* Overwrite the error so that we do not leak too much detail */\n\t\terr = ErrLoginIncorrect\n\t\treturn\n\t}\n\n\t// Force generation of a new token\n\tctx.token = \"\"\n\n\t// Not a sysadmin till they swapadmin\n\tctx.is_sysadmin = false\n\n\tctx.Become(user)\n\n\tuserevent(ctx, \"login\")\n\treturn nil\n}\n\n// Logout can be used to log the authenticated user out of the system.\n//\n// The JWT token that was previously in use is added to the JWT Invalidated list\n// thus denying the further use of that token.\nfunc (ctx *PfCtxS) Logout() {\n\tif ctx.token != \"\" {\n\t\tJwt_invalidate(ctx.token, &ctx.token_claims)\n\t}\n\n\t/* Invalidate user + token */\n\tctx.user = nil\n\tctx.token = \"\"\n\tctx.token_claims = SessionClaims{}\n}\n\n// IsLoggedIn can be used to check if the context has a properly logged in user.\nfunc (ctx *PfCtxS) IsLoggedIn() bool {\n\tif ctx.user == nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// IsGroupMember can be used to check if the selected user\n// is a member of the selected group and whether the user\n// can see the group.\nfunc (ctx *PfCtxS) IsGroupMember() bool {\n\tif !ctx.HasSelectedUser() {\n\t\treturn false\n\t}\n\n\tif !ctx.HasSelectedGroup() {\n\t\treturn false\n\t}\n\n\tismember, _, state, err := ctx.sel_group.IsMember(ctx.user.GetUserName())\n\tif err != nil {\n\t\tctx.Log(\"IsGroupMember: \" + err.Error())\n\t\treturn false\n\t}\n\n\tif !ismember {\n\t\treturn false\n\t}\n\n\t/* Group Admins can always select users, even when blocked */\n\tif ctx.IAmGroupAdmin() {\n\t\treturn true\n\t}\n\n\t/* Normal group users, it depends on whether they can see them */\n\treturn state.can_see\n}\n\n// IAmGroupAdmin can be used to ask if the logged in user\n// is a groupadmin of the selected group.\nfunc (ctx *PfCtxS) IAmGroupAdmin() bool {\n\tif !ctx.IsLoggedIn() {\n\t\treturn false\n\t}\n\n\tif !ctx.HasSelectedGroup() {\n\t\treturn false\n\t}\n\n\tif ctx.IsSysAdmin() {\n\t\treturn true\n\t}\n\n\t_, isadmin, _, err := ctx.sel_group.IsMember(ctx.user.GetUserName())\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn isadmin\n}\n\n// IAmGroupMember can be used to check if the logged in user is a groupmember\nfunc (ctx *PfCtxS) IAmGroupMember() bool {\n\tif !ctx.IsLoggedIn() {\n\t\treturn false\n\t}\n\n\tif !ctx.HasSelectedGroup() {\n\t\treturn false\n\t}\n\n\tismember, _, _, err := ctx.sel_group.IsMember(ctx.user.GetUserName())\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn ismember\n}\n\n// GroupHasWiki can be used to check if the selected group has a wiki module enabled\nfunc (ctx *PfCtxS) GroupHasWiki() bool {\n\tif !ctx.HasSelectedGroup() {\n\t\treturn false\n\t}\n\n\treturn ctx.sel_group.HasWiki()\n}\n\n// GroupHasFile can be used to check if the selected group has a file module enabled\nfunc (ctx *PfCtxS) GroupHasFile() bool {\n\tif !ctx.HasSelectedGroup() {\n\t\treturn false\n\t}\n\n\treturn ctx.sel_group.HasFile()\n}\n\n// GroupHasCalendar can be used to check if the selected group has a calendar module enabled\nfunc (ctx *PfCtxS) GroupHasCalendar() bool {\n\tif !ctx.HasSelectedGroup() {\n\t\treturn false\n\t}\n\n\treturn ctx.sel_group.HasCalendar()\n}\n\n// SwapSysAdmin swaps a user's privilege between normal user and sysadmin.\nfunc (ctx *PfCtxS) SwapSysAdmin() bool {\n\t/* Not logged, can't be SysAdmin */\n\tif !ctx.IsLoggedIn() {\n\t\treturn false\n\t}\n\n\t/* If they cannot be one, then do not toggle either */\n\tif !ctx.TheUser().CanBeSysAdmin() {\n\t\treturn false\n\t}\n\n\t/* Toggle state: SysAdmin <> Regular */\n\tctx.is_sysadmin = !ctx.is_sysadmin\n\n\t/* Force generation of a new token */\n\tctx.token = \"\"\n\n\treturn true\n}\n\n// IsSysAdmin indicates if the current user is a sysadmin\n// and has swapped to it, see SwapSysAdmin.\n//\n// The SAR (System Administation Restrictions) are checked.\n// When the SAR is enabled/configured, one can only become/be\n// a sysadmin when coming from the correct IP address as\n// configured in th SAR list.\nfunc (ctx *PfCtxS) IsSysAdmin() bool {\n\tif !ctx.IsLoggedIn() {\n\t\treturn false\n\t}\n\n\t/* Not a SysAdmin, easy */\n\tif !ctx.is_sysadmin {\n\t\treturn false\n\t}\n\n\tsys := System_Get()\n\n\t/*\n\t * SysAdmin IP Restriction in effect?\n\t *\n\t * Loopback (127.0.0.1 / ::1) are excluded from this restriction\n\t */\n\tif sys.sar_cache == nil || ctx.client_ip.IsLoopback() {\n\t\treturn true\n\t}\n\n\t/* Check all the prefixes */\n\tfor _, n := range sys.sar_cache {\n\t\tif n.Contains(ctx.client_ip) {\n\t\t\t/* It is valid */\n\t\t\treturn true\n\t\t}\n\t}\n\n\t/* Not in the SARestrict list */\n\treturn false\n}\n\n// FromString can be used to parse a string into a Perm object.\n//\n// str can be in the formats:\n//  perm1\n//  perm1,perm2\n//  perm1,perm2,perm3\n//\n// When an unknown permission is encountered, this function will return an error.\nfunc (perm Perm) FromString(str string) (err error) {\n\tstr = strings.ToLower(str)\n\n\tperm = PERM_NOTHING\n\n\tp := strings.Split(str, \",\")\n\tfor _, pm := range p {\n\t\tif pm == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tfound := false\n\t\tvar i uint\n\t\ti = 0\n\t\tfor _, n := range permnames {\n\t\t\tif pm == n {\n\t\t\t\tperm += 1 << i\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ti++\n\t\t}\n\n\t\tif !found {\n\t\t\terr = errors.New(\"Unknown permission: '\" + pm + \"'\")\n\t\t\treturn\n\t\t}\n\t\tbreak\n\t}\n\n\terr = nil\n\treturn\n}\n\n// String returns the string representation of a Perm.\n//\n// This can be used for in for instance debug output.\nfunc (perm Perm) String() (str string) {\n\n\tfor i := 0; i < len(permnames); i++ {\n\t\tp := uint64(math.Pow(float64(2), float64(i)))\n\n\t\tif uint64(perm)&p == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tif str != \"\" {\n\t\t\tstr += \",\"\n\t\t}\n\n\t\tstr += permnames[i]\n\t}\n\n\treturn str\n}\n\n/* IsPerm returns whether the provided Perm is the same Perm as given */\nfunc (perm Perm) IsPerm(perms Perm) bool {\n\treturn perms == perm\n}\n\n/* IsSet checks if the perm is in the given set of Perms */\nfunc (perm Perm) IsSet(perms Perm) bool {\n\treturn perms&perm > 0\n}\n\n// CheckPerms can verify if the given permissions string is valied for the provided Perms.\n//\n// One of multiple permissions can be specified by OR-ing the permissions together\n// thus test from least to most to see if any of them allows access.\n//\n// To debug permissions, toggle the code-level switch in PDbg and PDbgf().\n//\n// Application permissions are tested at the end when all pitchfork permissions\n// still allow it to proceed.\n//\n// The what parameter indicates the piece of code wanting to see the permissions\n// verified, this thus primarily serves as a debug help.\nfunc (ctx *PfCtxS) CheckPerms(what string, perms Perm) (ok bool, err error) {\n\t/* No error yet */\n\tsys := System_Get()\n\n\tctx.PDbgf(what, perms, \"Text: %s\", perms.String())\n\n\tif ctx.IsLoggedIn() {\n\t\tctx.PDbgf(what, perms, \"user = %s\", ctx.user.GetUserName())\n\t} else {\n\t\tctx.PDbgf(what, perms, \"user = ::NONE::\")\n\t}\n\n\tif ctx.HasSelectedUser() {\n\t\tctx.PDbgf(what, perms, \"sel_user = %s\", ctx.sel_user.GetUserName())\n\t} else {\n\t\tctx.PDbgf(what, perms, \"sel_user = ::NONE::\")\n\t}\n\n\tif ctx.HasSelectedGroup() {\n\t\tctx.PDbgf(what, perms, \"sel_group = %s\", ctx.sel_group.GetGroupName())\n\t} else {\n\t\tctx.PDbgf(what, perms, \"sel_group = ::NONE::\")\n\t}\n\n\t/* Nobody? */\n\tif perms.IsSet(PERM_NOBODY) {\n\t\tctx.PDbgf(what, perms, \"Nobody\")\n\t\treturn false, errors.New(\"Nobody is allowed\")\n\t}\n\n\t/* No permissions? */\n\tif perms.IsPerm(PERM_NOTHING) {\n\t\tctx.PDbgf(what, perms, \"Nothing\")\n\t\treturn true, nil\n\t}\n\n\t/* CLI when enabled and user is authenticated */\n\tif perms.IsSet(PERM_CLI) {\n\t\tctx.PDbgf(what, perms, \"CLI\")\n\t\tif ctx.IsLoggedIn() && sys.CLIEnabled {\n\t\t\tctx.PDbgf(what, perms, \"CLI - Enabled\")\n\t\t\treturn true, nil\n\t\t} else {\n\t\t\terr = errors.New(\"CLI is not enabled\")\n\t\t}\n\t}\n\n\t/* Loopback calls can always access the API (for tcli) */\n\tif perms.IsSet(PERM_API) {\n\t\tctx.PDbgf(what, perms, \"API\")\n\t\tif sys.APIEnabled {\n\t\t\tctx.PDbgf(what, perms, \"API - Enabled\")\n\t\t\treturn true, nil\n\t\t} else {\n\t\t\terr = errors.New(\"API is not enabled\")\n\t\t}\n\t}\n\n\t/* Is OAuth enabled? */\n\tif perms.IsSet(PERM_OAUTH) {\n\t\tctx.PDbgf(what, perms, \"OAuth\")\n\t\tif sys.OAuthEnabled {\n\t\t\tctx.PDbgf(what, perms, \"OAuth - Enabled\")\n\t\t\treturn true, nil\n\t\t} else {\n\t\t\terr = errors.New(\"OAuth is not enabled\")\n\t\t}\n\t}\n\n\t/* Loopback? */\n\tif perms.IsSet(PERM_LOOPBACK) {\n\t\tctx.PDbgf(what, perms, \"Loopback\")\n\t\tif ctx.client_ip.IsLoopback() {\n\t\t\tctx.PDbgf(what, perms, \"Is Loopback\")\n\t\t\treturn true, nil\n\t\t} else {\n\t\t\terr = errors.New(\"Not a Loopback\")\n\t\t}\n\t}\n\n\t/* User must not be authenticated */\n\tif perms.IsSet(PERM_GUEST) {\n\t\tctx.PDbgf(what, perms, \"Guest\")\n\t\tif !ctx.IsLoggedIn() {\n\t\t\tctx.PDbgf(what, perms, \"Guest - Not Logged In\")\n\t\t\treturn true, nil\n\t\t}\n\n\t\tctx.PDbgf(what, perms, \"Guest - Logged In\")\n\t\treturn false, errors.New(\"Must not be authenticated\")\n\t}\n\n\t/* User has to have selected themselves */\n\tif perms.IsSet(PERM_USER_SELF) {\n\t\tctx.PDbgf(what, perms, \"User Self\")\n\t\tif ctx.IsLoggedIn() {\n\t\t\tctx.PDbgf(what, perms, \"User Self - Logged In\")\n\t\t\tif ctx.HasSelectedUser() {\n\t\t\t\tctx.PDbgf(what, perms, \"User Self - Has selected user\")\n\t\t\t\tif ctx.sel_user.GetUserName() == ctx.user.GetUserName() {\n\t\t\t\t\t/* Passed the test */\n\t\t\t\t\tctx.PDbgf(what, perms, \"User Self - It is me\")\n\t\t\t\t\treturn true, nil\n\t\t\t\t} else {\n\t\t\t\t\tctx.PDbgf(what, perms, \"User Self - Other user\")\n\t\t\t\t\terr = errors.New(\"Different user selected\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = errors.New(\"No user selected\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = errors.New(\"Not Authenticated\")\n\t\t}\n\t}\n\n\t/* User has to have selected themselves */\n\tif perms.IsSet(PERM_USER_VIEW) {\n\t\tctx.PDbgf(what, perms, \"User View\")\n\t\tif ctx.IsLoggedIn() {\n\t\t\tctx.PDbgf(what, perms, \"User View - Logged In\")\n\t\t\tif ctx.HasSelectedUser() {\n\t\t\t\tctx.PDbgf(what, perms, \"User View - Has selected user\")\n\t\t\t\tif ctx.sel_user.GetUserName() == ctx.user.GetUserName() {\n\t\t\t\t\t/* Passed the test */\n\t\t\t\t\tctx.PDbgf(what, perms, \"User View - It is me\")\n\t\t\t\t\treturn true, nil\n\t\t\t\t} else {\n\t\t\t\t\tok, err = ctx.sel_user.SharedGroups(ctx, ctx.user)\n\t\t\t\t\tif ok {\n\t\t\t\t\t\t/* Passed the test */\n\t\t\t\t\t\tctx.PDbgf(what, perms, \"User View - It is in my group\")\n\t\t\t\t\t\treturn true, nil\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.PDbgf(what, perms, \"User View - Other user\")\n\t\t\t\t\t\terr = errors.New(\"Different user selected\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = errors.New(\"No user selected\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = errors.New(\"Not Authenticated\")\n\t\t}\n\t}\n\n\t/* User has to be a group member + Wiki enabled */\n\tif perms.IsSet(PERM_GROUP_WIKI) {\n\t\tctx.PDbgf(what, perms, \"Group Wiki?\")\n\t\tif ctx.GroupHasWiki() {\n\t\t\tctx.PDbgf(what, perms, \"HasWiki - ok\")\n\t\t\tif ctx.IsGroupMember() {\n\t\t\t\tctx.PDbgf(what, perms, \"Group member - ok\")\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t\terr = errors.New(\"Not a group member\")\n\t\t} else {\n\t\t\terr = errors.New(\"Group does not have a Wiki\")\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\t/* User has to be a group member + File enabled */\n\tif perms.IsSet(PERM_GROUP_FILE) {\n\t\tctx.PDbgf(what, perms, \"Group File?\")\n\t\tif ctx.GroupHasFile() {\n\t\t\tctx.PDbgf(what, perms, \"HasFile - ok\")\n\t\t\tif ctx.IsGroupMember() {\n\t\t\t\tctx.PDbgf(what, perms, \"Group member - ok\")\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t\terr = errors.New(\"Not a group member\")\n\t\t} else {\n\t\t\terr = errors.New(\"Group does not have a File\")\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\t/* User has to be a group member + Calendar enabled */\n\tif perms.IsSet(PERM_GROUP_CALENDAR) {\n\t\tctx.PDbgf(what, perms, \"Group Calendar?\")\n\t\tif ctx.GroupHasCalendar() {\n\t\t\tctx.PDbgf(what, perms, \"HasCalendar - ok\")\n\t\t\tif ctx.IsGroupMember() {\n\t\t\t\tctx.PDbgf(what, perms, \"Group member - ok\")\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t\terr = errors.New(\"Not a group member\")\n\t\t} else {\n\t\t\terr = errors.New(\"Group does not have a Calendar\")\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\t/* No permissions needed */\n\tif perms.IsSet(PERM_NONE) {\n\t\tctx.PDbgf(what, perms, \"None\")\n\t\t/* Always succeeds */\n\t\treturn true, nil\n\t}\n\n\t/* Everything else requires a login */\n\tif !ctx.IsLoggedIn() {\n\t\tctx.PDbgf(what, perms, \"Not Authenticated\")\n\t\terr = errors.New(\"Not authenticated\")\n\t\treturn false, err\n\t}\n\n\t/*\n\t * SysAdmin can get away with almost anything\n\t *\n\t * The perms only has the PERM_SYS_ADMIN bit set for clarity\n\t * that that one only has access for sysadmins\n\t */\n\tif ctx.IsSysAdmin() {\n\t\tctx.PDbgf(what, perms, \"SysAdmin?\")\n\t\treturn true, nil\n\t}\n\terr = errors.New(\"Not a SysAdmin\")\n\n\t/* User has to be authenticated */\n\tif perms.IsSet(PERM_USER) {\n\t\tctx.PDbgf(what, perms, \"User?\")\n\t\tif ctx.IsLoggedIn() {\n\t\t\tctx.PDbgf(what, perms, \"User - Logged In\")\n\t\t\treturn true, nil\n\t\t}\n\n\t\terr = errors.New(\"Not Authenticated\")\n\t}\n\n\t/* User has to be a group admin */\n\tif perms.IsSet(PERM_GROUP_ADMIN) {\n\t\tctx.PDbgf(what, perms, \"Group admin?\")\n\t\tif ctx.IAmGroupAdmin() {\n\t\t\tctx.PDbgf(what, perms, \"Group admin - ok\")\n\t\t\treturn true, nil\n\t\t}\n\n\t\terr = errors.New(\"Not a group admin\")\n\t}\n\n\t/* User has to be a group member */\n\tif perms.IsSet(PERM_GROUP_MEMBER) {\n\t\tctx.PDbgf(what, perms, \"Group member?\")\n\t\tif ctx.IsGroupMember() {\n\t\t\tctx.PDbgf(what, perms, \"Group member - ok\")\n\t\t\treturn true, nil\n\t\t}\n\n\t\terr = errors.New(\"Not a group member\")\n\t}\n\n\t/* User wants to nominate somebody (even themselves) */\n\tif perms.IsSet(PERM_USER_NOMINATE) {\n\t\tctx.PDbgf(what, perms, \"User Nominate\")\n\t\tif ctx.IsLoggedIn() {\n\t\t\tctx.PDbgf(what, perms, \"User Nominate - Logged In\")\n\t\t\tif ctx.HasSelectedUser() {\n\t\t\t\tctx.PDbgf(what, perms, \"User Nominate - User Selected\")\n\t\t\t\t/* Passed the test */\n\t\t\t\treturn true, nil\n\t\t\t} else {\n\t\t\t\terr = errors.New(\"No user selected\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = errors.New(\"Not Authenticated\")\n\t\t}\n\t}\n\n\t/* Can the user become a SysAdmin? */\n\tif perms.IsSet(PERM_SYS_ADMIN_CAN) {\n\t\tif ctx.IsLoggedIn() {\n\t\t\tctx.PDbgf(what, perms, \"Sys Admin Can - Logged In\")\n\t\t\tif ctx.TheUser().CanBeSysAdmin() {\n\t\t\t\tctx.PDbgf(what, perms, \"Sys Admin Can\")\n\t\t\t\t/* Passed the test */\n\t\t\t\treturn true, nil\n\t\t\t} else {\n\t\t\t\terr = errors.New(\"Can't become SysAdmin\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = errors.New(\"Not Authenticated\")\n\t\t}\n\t}\n\n\t/* Let the App Check permissions */\n\tif ctx.f_appperms != nil {\n\t\tfinal, _ok, _err := ctx.f_appperms(ctx, what, perms)\n\t\tif final {\n\t\t\treturn _ok, _err\n\t\t}\n\n\t\t/* Otherwise we ignore the result as it is not a final decision */\n\t}\n\n\tif err == nil {\n\t\t/* Should not happen */\n\t\tpanic(\"Invalid permission bits\")\n\t}\n\n\t/* Default Deny + report error */\n\treturn false, err\n}\n\n// CheckPermsT can be used to check a Textual version of permissions.\n//\n// Used when the caller has the textual representation of the permissions.\nfunc (ctx *PfCtxS) CheckPermsT(what string, permstr string) (ok bool, err error) {\n\tvar perms Perm\n\n\terr = perms.FromString(permstr)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn ctx.CheckPerms(what, perms)\n}\n\n// TheUser returns the currently selected user\nfunc (ctx *PfCtxS) TheUser() (user PfUser) {\n\t/* Return a copy, not a reference */\n\treturn ctx.user\n}\n\n// SelectedSelf checks if the logged in user and the selected user are the same.\nfunc (ctx *PfCtxS) SelectedSelf() bool {\n\treturn ctx.IsLoggedIn() &&\n\t\tctx.HasSelectedUser() &&\n\t\tctx.user.GetUserName() == ctx.sel_user.GetUserName()\n}\n\n// SelectedUser returns the selected user.\nfunc (ctx *PfCtxS) SelectedUser() (user PfUser) {\n\t/* Return a copy, not a reference */\n\treturn ctx.sel_user\n}\n\n// SelectedGroup returns the selected group.\nfunc (ctx *PfCtxS) SelectedGroup() (grp PfGroup) {\n\t/* Return a copy, not a reference */\n\treturn ctx.sel_group\n}\n\n// SelectedML returns the selected mailinglist.\nfunc (ctx *PfCtxS) SelectedML() (ml PfML) {\n\t/* Return a copy, not a reference */\n\treturn *ctx.sel_ml\n}\n\n// SelectedEmail returns the selected email address.\nfunc (ctx *PfCtxS) SelectedEmail() (email PfUserEmail) {\n\t/* Return a copy, not a reference */\n\treturn *ctx.sel_email\n}\n\n// HasSelectedUser returns whether a user was selected.\nfunc (ctx *PfCtxS) HasSelectedUser() bool {\n\treturn ctx.sel_user != nil\n}\n\n// HasSelectedGroup returns whether a group was selected.\nfunc (ctx *PfCtxS) HasSelectedGroup() bool {\n\treturn ctx.sel_group != nil\n}\n\n// HasSelectedML returns whether a mailinglist was selected.\nfunc (ctx *PfCtxS) HasSelectedML() bool {\n\treturn ctx.sel_ml != nil\n}\n\n// SelectMe caused the user to select themselves.\nfunc (ctx *PfCtxS) SelectMe() {\n\tctx.sel_user = ctx.user\n}\n\n// SelectUser selects the user if the given permissions are matched.\nfunc (ctx *PfCtxS) SelectUser(username string, perms Perm) (err error) {\n\tctx.PDbgf(\"PfCtxS::SelectUser\", perms, \"%q\", username)\n\n\t/* Nothing to select, always works */\n\tif username == \"\" {\n\t\tctx.sel_user = nil\n\t\treturn nil\n\t}\n\n\t/* Selecting own user? */\n\ttheuser := ctx.TheUser()\n\tif theuser != nil && theuser.GetUserName() == username {\n\t\t/* Re-use and pass no username to indicate no refresh */\n\t\tctx.sel_user = theuser\n\t\tusername = \"\"\n\t} else {\n\t\tctx.sel_user = ctx.NewUser()\n\t}\n\n\terr = ctx.sel_user.Select(ctx, username, perms)\n\tif err != nil {\n\t\tctx.sel_user = nil\n\t}\n\n\treturn\n}\n\n// SelectGroup selects the group, depending on the permission bits provided.\n//\n// After succesfully selecting, SelectedGroup can be used to retrieve the group.\nfunc (ctx *PfCtxS) SelectGroup(gr_name string, perms Perm) (err error) {\n\tctx.PDbgf(\"SelectGroup\", perms, \"%q\", gr_name)\n\n\t/* Nothing to select */\n\tif gr_name == \"\" {\n\t\tctx.sel_group = nil\n\t\treturn nil\n\t}\n\n\tctx.sel_group = ctx.NewGroup()\n\terr = ctx.sel_group.Select(ctx, gr_name, perms)\n\tif err != nil {\n\t\tctx.sel_group = nil\n\t}\n\n\treturn\n}\n\n// SelectML selects a mailinglist depending on the permissions of the logged in user\nfunc (ctx *PfCtxS) SelectML(ml_name string, perms Perm) (err error) {\n\tctx.PDbgf(\"SelectUserML\", perms, \"%q\", ml_name)\n\n\tif !ctx.HasSelectedGroup() {\n\t\treturn errors.New(\"No group selected\")\n\t}\n\n\t/* Nothing to select */\n\tif ml_name == \"\" {\n\t\tctx.sel_ml = nil\n\t\treturn nil\n\t}\n\n\tctx.sel_ml = NewPfML()\n\terr = ctx.sel_ml.Select(ctx, ctx.sel_group, ml_name, perms)\n\n\tif err != nil {\n\t\tctx.sel_ml = nil\n\t}\n\n\treturn\n}\n\n// SelectEmail selects an email address.\n//\n// Users can only select their own email addresses (PERM_USER_SELF).\nfunc (ctx *PfCtxS) SelectEmail(email string) (err error) {\n\tperms := PERM_USER_SELF\n\n\tctx.PDbgf(\"SelectEmail\", perms, \"%q\", email)\n\n\t/* Nothing to select */\n\tif email == \"\" {\n\t\tctx.sel_email = nil\n\t\treturn nil\n\t}\n\n\t/* Fetch email details */\n\tctx.sel_email = NewPfUserEmail()\n\terr = ctx.sel_email.Fetch(email)\n\tif err != nil {\n\t\t/* Did not work */\n\t\tctx.sel_email = nil\n\t\treturn\n\t}\n\n\t/* Check Permissions */\n\tvar ok bool\n\tok, _ = ctx.CheckPerms(\"SelectEmail\", perms)\n\tif !ok {\n\t\t/* Nope, no access */\n\t\tctx.sel_email = nil\n\t}\n\n\treturn\n}\n\n// Err allows printing error messages (syslog/stdout) with details from the context.\nfunc (ctx *PfCtxS) Err(message string) {\n\tErrA(1, message)\n}\n\n// Errf allows printing formatted error messages (syslog/stdout) with details from the context.\nfunc (ctx *PfCtxS) Errf(format string, a ...interface{}) {\n\tErrA(1, format, a...)\n}\n\n// Log allows printing log messages (syslog/stdout) with details from the context\nfunc (ctx *PfCtxS) Log(message string) {\n\tLogA(1, message)\n}\n\n// Logf allows printing formatted log messages (syslog/stdout) with details from the context\nfunc (ctx *PfCtxS) Logf(format string, a ...interface{}) {\n\tLogA(1, format, a...)\n}\n\n// Dbg allows printing debug messages (syslog/stdout) with details from the context\nfunc (ctx *PfCtxS) Dbg(message string) {\n\tDbgA(1, message)\n}\n\n// Dbgf allows printing formatted debug messages (syslog/stdout) with details from the context\nfunc (ctx *PfCtxS) Dbgf(format string, a ...interface{}) {\n\tDbgA(1, format, a...)\n}\n\n// PDbgf is used for permission debugging.\n//\n// It needs to be enabled with a Code level Debug option.\n// Change the 'false' to 'true' and every permission decision will be listed.\n// Remember: sysadmin overrules most permissions, thus test with normal user.\nfunc (ctx *PfCtxS) PDbgf(what string, perm Perm, format string, a ...interface{}) {\n\tif false {\n\t\tctx.Dbgf(\"Perms(\\\"\"+what+\"\\\"/\"+strconv.Itoa(int(perm))+\"): \"+format, a...)\n\t}\n}\n\n// Out can be used to print a line to the output for the context (CLI or HTTP).\n//\n// When buffering is disabled, the txt is directly forwarded to a special\n// direct output function.\n//\n// When buffering is enabled, the txt is accumulatd in the output buffer.\nfunc (ctx *PfCtxS) Out(txt string) {\n\tif !ctx.mode_buffered {\n\t\t/* Call the function that takes care of Direct output */\n\t\t_, err := ObjFunc(ctx.outunbuf_obj, ctx.outunbuf_fun, txt)\n\t\tif err != nil {\n\t\t\tctx.Errf(\"Unbuffered output failed: %s\", err.Error())\n\t\t}\n\t} else {\n\t\t/* Buffered output */\n\t\tctx.output += txt\n\t}\n}\n\n// Outf can be used to let the Out string be formatted first.\nfunc (ctx *PfCtxS) Outf(format string, a ...interface{}) {\n\tctx.Out(fmt.Sprintf(format, a...))\n}\n\n// OutLn ensure that the Out outputted message ends in a newline\nfunc (ctx *PfCtxS) OutLn(format string, a ...interface{}) {\n\tctx.Outf(format+\"\\n\", a...)\n}\n\n// SetOutUnbuffered causes the Out* functions to become unbuffered.\n//\n// The object and function passed in are then later used for calling\n// and acually performing the output of the txt with the Out() function.\nfunc (ctx *PfCtxS) SetOutUnbuffered(obj interface{}, fun string) {\n\tobjtrail := []interface{}{obj}\n\tok, obji := ObjHasFunc(objtrail, fun)\n\tif !ok {\n\t\tpanic(\"Unbuffered function \" + fun + \" is missing\")\n\t}\n\n\tctx.outunbuf_obj = obji\n\tctx.outunbuf_fun = fun\n}\n\n// OutBuffered causes the Out* functions to become buffered.\nfunc (ctx *PfCtxS) OutBuffered(on bool) {\n\tif !on && ctx.outunbuf_fun == \"\" {\n\t\tpanic(\"Can't enable buffered mode without unbuffered function\")\n\t}\n\n\tctx.mode_buffered = on\n}\n\n// IsBuffered can be used to check if output is being buffered or directly outputted.\nfunc (ctx *PfCtxS) IsBuffered() bool {\n\treturn ctx.mode_buffered\n}\n\n// Buffered can be used to return the buffered string.\nfunc (ctx *PfCtxS) Buffered() (o string) {\n\to = ctx.output\n\tctx.output = \"\"\n\treturn\n}\n", "// Pitchfork struct provides access functions to various ways to inspect or modify contents of structs.\npackage pitchfork\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// PTypeField wraps the relect StructField for ease of use in various Struct related functions.\ntype PTypeField struct {\n\treflect.StructField\n}\n\n// PTypeWrap simply wraps the relect.StructField into our own PTypField.\nfunc PTypeWrap(f reflect.StructField) PTypeField {\n\treturn PTypeField{f}\n}\n\n// PType is used to define the CRUD option.\ntype PType int\n\n/* CRUD */\nconst (\n\tPTYPE_CREATE PType = iota /* Create */\n\tPTYPE_READ                /* Read */\n\tPTYPE_UPDATE              /* Update */\n\tPTYPE_DELETE              /* Delete */\n)\n\n// PfType is used to get the datatype from either the pftype tag\n// or by basing it on the actual type of the field using reflection.\n//\n// PfType determines if a datatype needs to be recursed and if it\n// is a compound structure.\n//\n// If 'doignore' is set, for some types the return type is 'ignore' to\n// indicate that the field does not need to be processd.\n// This option is for instance used for set/get purposes where\n// 'note' and 'widenote' cannot be changed and thus can be ignored\n// for that purpose.\n//\n// This is primarily a helper function for other functions that\n// parse structs and thus want to adhere to the types and tags.\nfunc PfType(f reflect.StructField, v reflect.Value, doignore bool) (ttype string, dorecurse bool, compound bool) {\n\t/* Forced type */\n\tttype = f.Tag.Get(\"pftype\")\n\n\t/* Detected type */\n\tif ttype == \"\" {\n\t\t/* Always ignore functions */\n\t\tif f.Type.Kind() == reflect.Func {\n\t\t\tttype = \"ignore\"\n\t\t\treturn\n\t\t}\n\n\t\t/* When the package path is not empty, we ignore the field as it is not exported */\n\t\tif f.PkgPath != \"\" {\n\t\t\t// Dbg(\"Skipping %s (pkg: %#v) - unexported\", f.Name, f.PkgPath)\n\t\t\tttype = \"ignore\"\n\t\t\treturn\n\t\t}\n\n\t\tswitch f.Type.Kind() {\n\t\tcase reflect.String:\n\t\t\tttype = \"string\"\n\t\t\tbreak\n\n\t\tcase reflect.Bool:\n\t\t\tttype = \"bool\"\n\t\t\tbreak\n\n\t\t/* We consider everything just a number, we call it a 'int' out of convienience */\n\t\tcase reflect.Int, reflect.Int64, reflect.Float64, reflect.Uint, reflect.Uint64:\n\t\t\tttype = \"int\"\n\t\t\tbreak\n\n\t\tcase reflect.Struct:\n\t\t\tty := StructNameT(f.Type)\n\n\t\t\tswitch ty {\n\t\t\tcase \"time.Time\":\n\t\t\t\tttype = \"time\"\n\t\t\t\tbreak\n\n\t\t\tcase \"database/sql.NullString\":\n\t\t\t\tttype = \"string\"\n\t\t\t\tbreak\n\n\t\t\tcase \"database/sql.NullInt64\", \"database/sql.NullFloat64\":\n\t\t\t\tttype = \"int\"\n\t\t\t\tbreak\n\n\t\t\tcase \"database/sql.NullBool\":\n\t\t\t\tttype = \"bool\"\n\t\t\t\tbreak\n\n\t\t\tdefault:\n\t\t\t\t/* Generic struct */\n\t\t\t\tttype = \"struct\"\n\n\t\t\t\to := StructRecurse(v)\n\n\t\t\t\ttfunc := \"TreatAsString\"\n\t\t\t\tobjtrail := []interface{}{o}\n\t\t\t\tok, _ := ObjHasFunc(objtrail, tfunc)\n\t\t\t\tif ok {\n\t\t\t\t\t/* Really, it is a string, believe me */\n\t\t\t\t\tttype = \"string\"\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tbreak\n\n\t\tcase reflect.Interface:\n\t\t\tttype = \"interface\"\n\t\t\tbreak\n\n\t\tcase reflect.Slice:\n\t\t\tttype = \"slice\"\n\t\t\tbreak\n\n\t\tcase reflect.Map:\n\t\t\tttype = \"map\"\n\t\t\tbreak\n\n\t\tcase reflect.Ptr:\n\t\t\tttype = \"ptr\"\n\t\t\tbreak\n\n\t\tcase reflect.Func:\n\t\t\tttype = \"ignore\"\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\tpanic(\"Unsupported Reflection Type \" + f.Type.Kind().String() + \": \" + StructNameT(f.Type))\n\t\t}\n\t}\n\n\tif doignore {\n\t\t/* Ignore submit buttons and notes */\n\t\tif ttype == \"submit\" || ttype == \"note\" || ttype == \"widenote\" {\n\t\t\tttype = \"ignore\"\n\t\t}\n\t}\n\n\t/* Recurse if it is a interface or a generic struct */\n\tif ttype == \"interface\" || ttype == \"struct\" {\n\t\tcompound = true\n\n\t\tif ttype != \"struct\" || v.NumField() > 0 {\n\t\t\tdorecurse = true\n\t\t}\n\t}\n\n\treturn\n}\n\n// StructRecurse is used to recurse through a structure\n// this in the case it is wrapped or embedded.\n//\n// Check CanAddr() so that we do a recurse while\n// we can with ability to set, but recurse otherwise\n// in readonly version.\n//\n// This function is primarily used by other struct related functions\n// and should rarely be called otherwise.\nfunc StructRecurse(v reflect.Value) interface{} {\n\tif v.Kind() != reflect.Interface && v.CanAddr() {\n\t\treturn v.Addr().Interface()\n\t}\n\n\treturn v.Interface()\n}\n\n// StructNameT returns the name of a structure from a type (T).\n//\n// This function is primarily used by other struct related functions.\nfunc StructNameT(t reflect.Type) string {\n\tif t.Kind() == reflect.Ptr {\n\t\tt = t.Elem()\n\t}\n\n\tn := t.PkgPath() + \".\" + t.Name()\n\tif n == \".\" {\n\t\tDbgf(\"StructNameT() = %s\", n)\n\t\tpanic(\"StructNameT() could not find a name\")\n\t}\n\treturn n\n}\n\n// StructNameObj returns the name of the object (Obj).\n//\n// This function is primarily used by other struct related functions.\nfunc StructNameObj(obj interface{}) string {\n\ts, _ := StructReflect(obj)\n\tn := s.PkgPath() + \".\" + s.Name()\n\tif n == \".\" {\n\t\tDbgf(\"StructNameObj(%s) obj = %#v\", n, obj)\n\t\tpanic(\"StructNameObj() could not find a name\")\n\t}\n\treturn n\n}\n\n// StructNameObjTrail returns the full trail of objects as a name.\n//\n// This function is primarily used by other struct related functions.\nfunc StructNameObjTrail(objtrail []interface{}) (oname string) {\n\tfor _, obj := range objtrail {\n\t\tif oname != \"\" {\n\t\t\toname = oname + \"->\"\n\t\t}\n\t\toname = StructNameObj(obj) + oname\n\t}\n\n\treturn\n}\n\n// StructReflect performs reflection, getting out the type\n// and the value, dereferencing the pointer where needed.\n//\n// This function is primarily used by other struct related functions.\nfunc StructReflect(obj interface{}) (s reflect.Type, va reflect.Value) {\n\ts = reflect.TypeOf(obj)\n\n\tif s.Kind() == reflect.Ptr {\n\t\t// Dereference the pointer\n\t\ts = reflect.ValueOf(obj).Type().Elem()\n\t}\n\n\t/* Values (Indirect() takes care of pointer to structs) */\n\tva = reflect.Indirect(reflect.ValueOf(obj))\n\n\treturn s, va\n}\n\n// StructFetchFields builds a SELECT SQL query to retrieve\n// all the fields in a structure from a database\n//\n// The object passed is in parsed, each structure field in-order.\n// The table is used in the FROM query.\n// The q parameter is where the composed SQL query is returned.\n// The ifs parameter is where space for the storage of the to-be-retrieved\n// data is stored.\n//\n// A caller thus calls this with a pointer to an empty query string\n// and an empty ifs array and StructFetchFields then builds the query\n// and returns that in the query argument and in the ifs array.\n//\n// The intermediary 'ifs' is thus used for temporary storage in a way\n// that the SQL library wants to receive it.\n// It also allows for multiple objects to be queried and later stored.\n//\n// This function cooperates with the StructFetchStore function which,\n// after executing the query, can then store the result in the actual structure.\n//\n// This function is typically called from StructFetch or StructFetchMulti\n// which calls StructFetchFields and StructFetchStore.\nfunc StructFetchFields(obj interface{}, table string, q *string, ifs *[]interface{}) (err error) {\n\tfun := \"StructFetchFields() \"\n\n\ts, va := StructReflect(obj)\n\n\tif s.Kind() == reflect.Interface {\n\t\treturn StructFetchFields(StructRecurse(va), table, q, ifs)\n\t}\n\n\tfor i := 0; i < s.NumField(); i++ {\n\t\tf := s.Field(i)\n\t\tv := va.Field(i)\n\n\t\tttype, dorecurse, compound := PfType(f, v, true)\n\t\tif ttype == \"ignore\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif dorecurse {\n\t\t\terr = StructFetchFields(StructRecurse(v), table, q, ifs)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif compound {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* No tags, then ignore it */\n\t\tif f.Tag == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Column/fieldname in SQL Table */\n\t\tfname := f.Tag.Get(\"pfcol\")\n\t\tif fname == \"\" {\n\t\t\tfname = strings.ToLower(f.Name)\n\t\t}\n\n\t\t/* Custom table to take it from? */\n\t\ttname := f.Tag.Get(\"pftable\")\n\t\tif tname == \"\" {\n\t\t\ttname = table\n\t\t}\n\n\t\tfname = tname + \".\" + fname\n\n\t\tif !v.CanSet() {\n\t\t\terr = errors.New(\"Can't set field '\" + fname + \"' (\" + fun + \")\")\n\t\t\treturn\n\t\t}\n\n\t\t/* Start or continue the SELECT statement */\n\t\tif *q == \"\" {\n\t\t\t*q = \"SELECT \"\n\t\t} else {\n\t\t\t*q += \", \"\n\t\t}\n\n\t\tcoalesce := f.Tag.Get(\"coalesce\")\n\n\t\tftype := f.Type.Kind()\n\n\t\t/* Handle 'nil's in the database */\n\t\tswitch ftype {\n\t\tcase reflect.String:\n\t\t\t*q += \"COALESCE(\" + fname + \", '\" + coalesce + \"')\"\n\t\t\tbreak\n\n\t\tcase reflect.Int, reflect.Int64, reflect.Float64:\n\t\t\t*q += \"COALESCE(\" + fname + \", 0)\"\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\t/* Don't COALESCE as we do not know the type */\n\t\t\t*q += fname\n\t\t\tbreak\n\t\t}\n\n\t\tvar vr interface{}\n\n\t\tswitch ftype {\n\t\tcase reflect.String:\n\t\t\tvr = new(string)\n\t\t\tbreak\n\n\t\tcase reflect.Bool:\n\t\t\tvr = new(bool)\n\t\t\tbreak\n\n\t\tcase reflect.Int, reflect.Int64, reflect.Float64:\n\t\t\tvr = new(int64)\n\t\t\tbreak\n\n\t\tcase reflect.Struct:\n\t\t\tty := StructNameT(f.Type)\n\n\t\t\tswitch ty {\n\t\t\tcase \"time.Time\":\n\t\t\t\tvr = new(time.Time)\n\t\t\t\tbreak\n\n\t\t\tcase \"database/sql.NullString\":\n\t\t\t\tvr = new(sql.NullString)\n\t\t\t\tbreak\n\n\t\t\tcase \"database/sql.NullInt64\":\n\t\t\t\tvr = new(sql.NullInt64)\n\t\t\t\tbreak\n\n\t\t\tcase \"database/sql.NullFloat64\":\n\t\t\t\tvr = new(sql.NullFloat64)\n\t\t\t\tbreak\n\n\t\t\tcase \"database/sql.NullBool\":\n\t\t\t\tvr = new(sql.NullBool)\n\t\t\t\tbreak\n\n\t\t\tdefault:\n\t\t\t\tif ttype == \"string\" {\n\t\t\t\t\tvr = new(string)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\treturn errors.New(fun + \"Variable '\" + fname + \"' is an unknown struct: \" + ty)\n\t\t\t}\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\tvar k reflect.Kind\n\t\t\tk = f.Type.Kind()\n\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Unknown type: \" + k.String())\n\t\t}\n\n\t\t*ifs = append(*ifs, vr)\n\t}\n\n\treturn nil\n}\n\n// StructFetchStore stores the result of a StructFetchFields build query into\n// the object that is passed in.\n//\n// The obj argument represents the object we want the results to be stored in.\n// The ifs argument is the result returned from StructFetchFields, and where\n// the SQL QueryRow/QueryRows call has stored it's result.\n//\n// This function is typically called from StructFetch or StructFetchMulti\n// which calls StructFetchFields and StructFetchStore.\nfunc StructFetchStore(obj interface{}, ifs []interface{}, ifs_n *int) (err error) {\n\tfun := \"StructFetch() \"\n\n\ts, va := StructReflect(obj)\n\n\tfor i := 0; i < s.NumField(); i++ {\n\t\tf := s.Field(i)\n\t\tv := va.Field(i)\n\n\t\tttype, dorecurse, compound := PfType(f, v, true)\n\t\tif ttype == \"ignore\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif dorecurse {\n\t\t\terr = StructFetchStore(StructRecurse(v), ifs, ifs_n)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif compound {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* No tags, then ignore it */\n\t\tif f.Tag == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Column/fieldname in SQL Table */\n\t\tfname := f.Tag.Get(\"pfcol\")\n\t\tif fname == \"\" {\n\t\t\tfname = strings.ToLower(f.Name)\n\t\t}\n\n\t\tn := *ifs_n\n\n\t\tswitch f.Type.Kind() {\n\t\tcase reflect.String:\n\t\t\tv.SetString(*(ifs[n].(*string)))\n\t\t\tbreak\n\n\t\tcase reflect.Bool:\n\t\t\tv.SetBool(*(ifs[n].(*bool)))\n\t\t\tbreak\n\n\t\tcase reflect.Int, reflect.Int64:\n\t\t\tv.SetInt(*(ifs[n].(*int64)))\n\t\t\tbreak\n\n\t\tcase reflect.Float64:\n\t\t\tv.SetFloat(*(ifs[n].(*float64)))\n\t\t\tbreak\n\n\t\tcase reflect.Struct:\n\t\t\tty := StructNameT(f.Type)\n\n\t\t\tswitch ty {\n\t\t\tcase \"time.Time\":\n\t\t\t\tv.Set(reflect.ValueOf(*(ifs[n].(*time.Time))))\n\t\t\t\tbreak\n\n\t\t\tcase \"database/sql.NullString\":\n\t\t\t\tv.Set(reflect.ValueOf(*(ifs[n].(*sql.NullString))))\n\t\t\t\treturn\n\n\t\t\tcase \"database/sql.NullInt64\":\n\t\t\t\tv.Set(reflect.ValueOf(*(ifs[n].(*sql.NullInt64))))\n\t\t\t\treturn\n\n\t\t\tcase \"database/sql.NullFloat64\":\n\t\t\t\tv.Set(reflect.ValueOf(*(ifs[n].(*sql.NullFloat64))))\n\t\t\t\treturn\n\n\t\t\tcase \"database/sql.NullBool\":\n\t\t\t\tv.Set(reflect.ValueOf(*(ifs[n].(*sql.NullBool))))\n\t\t\t\treturn\n\n\t\t\tdefault:\n\t\t\t\treturn errors.New(fun + \"Variable '\" + fname + \"' is an unknown struct: \" + ty)\n\t\t\t}\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\tvar k reflect.Kind\n\t\t\tk = f.Type.Kind()\n\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Unknown type: \" + k.String())\n\t\t}\n\n\t\t/* Next Field */\n\t\tn++\n\t\t*ifs_n = n\n\t}\n\n\treturn nil\n}\n\n// StructFetchWhere allows filtering the fields returned with StructFetchFields\n//\n// StructFetch/StructFetchMulti use this to append the 'where' clause portion\n// of the SQL query.\n//\n// The starting query (qi), containing the \"SELECT <field>, <field>\" is passed in.\n// StructFetchWhere adds the FROM portion and any SQL table joins, from the join argument,\n// and then, based on the params and the andor setting creates a WHERE query.\n//\n// andor defines if the where query should be composed of AND or OR statements\n// params defines the parameters that should be verified\n// matchopts defines the way the match in the WHERE should work (LIKE, =, etc)\n// matches defines what should be matched against.\n//\n// The order argument then is additionally used for determining the order of the output.\n//\n// To illustrate the arguments:\n//\n// {qi} FROM {table} {join}\n//\n// and then followed per pair of params/matchopts/matches:\n// {andor} {params} {matchopt} {matches}\n// eg: AND param LIKE '%match%'\n//\n// appended by the {order}.\nfunc StructFetchWhere(qi string, table string, join string, andor DB_AndOr, params []string, matchopts []DB_Op, matches []interface{}, order string) (q string, vals []interface{}) {\n\tq = qi\n\n\t/* From which table */\n\tq += \" FROM \" + DB.QI(table)\n\n\tif join != \"\" {\n\t\tq += \" \" + join\n\t}\n\n\twhere := \"\"\n\tvals = nil\n\n\tfor n, p := range params {\n\t\tif where == \"\" {\n\t\t\twhere += \" WHERE \"\n\t\t} else {\n\t\t\tswitch andor {\n\t\t\tcase DB_OP_AND:\n\t\t\t\twhere += \" AND \"\n\t\t\t\tbreak\n\n\t\t\tcase DB_OP_OR:\n\t\t\t\twhere += \" OR \"\n\t\t\t\tbreak\n\n\t\t\tdefault:\n\t\t\t\tpanic(\"Invalid andor\")\n\t\t\t}\n\t\t}\n\n\t\tpp := strings.Split(p, \".\")\n\t\tif len(pp) == 2 {\n\t\t\twhere += DB.QI(pp[0]) + \".\" + DB.QI(pp[1])\n\t\t} else {\n\t\t\twhere += DB.QI(p)\n\t\t}\n\n\t\tswitch matchopts[n] {\n\t\tcase DB_OP_LIKE:\n\t\t\twhere += \" LIKE \"\n\t\t\tbreak\n\n\t\tcase DB_OP_ILIKE:\n\t\t\twhere += \" ILIKE \"\n\t\t\tbreak\n\n\t\tcase DB_OP_EQ:\n\t\t\twhere += \" = \"\n\t\t\tbreak\n\n\t\tcase DB_OP_NE:\n\t\t\twhere += \" <> \"\n\t\t\tbreak\n\n\t\tcase DB_OP_LE:\n\t\t\twhere += \" <= \"\n\t\t\tbreak\n\n\t\tcase DB_OP_GE:\n\t\t\twhere += \" >= \"\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\tpanic(\"Unsupported Match option\")\n\t\t}\n\n\t\twhere += \"$\" + strconv.Itoa(n+1)\n\t\tvals = append(vals, matches[n])\n\t}\n\n\t/* Append the WHERE portion */\n\tq += where\n\n\tq += \" \" + strings.TrimSpace(order)\n\n\treturn\n}\n\n// StructFetchMulti returns multiple objects using StructFetchFields.\n//\n// The newobject function is called to create a new object to be filled in.\n// Any type of object can be returned. These objects are returned in the objs parameter.\n//\n// See StructFetchWhere for the table/jon/andor/params/matchops/matches/order arguments.\n//\n// The limit argument can be used to add a LIMIT to the SQL query.\n// The offset argument can be used to add a OFFSET to the SQL query.\nfunc StructFetchMulti(newobject func() interface{}, table string, join string, andor DB_AndOr, params []string, matchopts []DB_Op, matches []interface{}, order string, offset int, limit int) (objs []interface{}, err error) {\n\tvar ifs []interface{} = nil\n\n\tq := \"\"\n\tobjs = nil\n\n\tobj := newobject()\n\n\terr = StructFetchFields(obj, table, &q, &ifs)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif q == \"\" {\n\t\treturn nil, errors.New(\"No fields to retrieve\")\n\t}\n\n\tq, vals := StructFetchWhere(q, table, join, andor, params, matchopts, matches, order)\n\n\tif limit != 0 {\n\t\tq += \" LIMIT \"\n\t\tDB.Q_AddArg(&q, &vals, limit)\n\t}\n\n\tif offset != 0 {\n\t\tq += \" OFFSET \"\n\t\tDB.Q_AddArg(&q, &vals, offset)\n\t}\n\n\t/* Execute the query & scan it */\n\tvar rows *Rows\n\trows, err = DB.Query(q, vals...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tdefer rows.Close()\n\n\t/* There should be one */\n\tfor rows.Next() {\n\t\terr = rows.Scan(ifs...)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\to := newobject()\n\t\tn := 0\n\n\t\terr = StructFetchStore(o, ifs, &n)\n\t\tobjs = append(objs, o)\n\t}\n\n\treturn objs, nil\n}\n\n// StructFetchA exposes extra options than the simpler StructFetch\n// it is used to fetch data from a database directly into a structure\n// based on the fields in that structure and the parameters given.\n//\n// See StructFetchWhere for the table/jon/andor/params/matchops/matches/order arguments.\n//\n// The notfoundok boolean is used to return ErrNoRows when set to true.\n// Otherwise it returns a string 'not found' error.\n// This toggle primarily exists to ease the difference between programmatically\n// calling this function, and wanting to process the ErrNoRows further or\n// wanting to return the result to the CLI or other human readable error construct.\nfunc StructFetchA(obj interface{}, table string, join string, params []string, matches []string, order string, notfoundok bool) (err error) {\n\tq := \"\"\n\n\tvar ifs []interface{} = nil\n\n\terr = StructFetchFields(obj, table, &q, &ifs)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif q == \"\" {\n\t\terr = errors.New(\"No fields to retrieve\")\n\t\treturn\n\t}\n\n\tvar matchopts []DB_Op\n\tfor _, _ = range params {\n\t\tmatchopts = append(matchopts, DB_OP_EQ)\n\t}\n\n\tvar imatches []interface{}\n\tfor _, m := range matches {\n\t\timatches = append(imatches, m)\n\t}\n\n\tq, vals := StructFetchWhere(q, table, join, DB_OP_AND, params, matchopts, imatches, order)\n\n\t/* Only want one back */\n\tq += \" LIMIT 1\"\n\n\t/* Execute the query & scan it */\n\tvar rows *Rows\n\trows, err = DB.Query(q, vals...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tdefer rows.Close()\n\n\t/* There should be one */\n\tif !rows.Next() {\n\t\tif !notfoundok {\n\t\t\terr = errors.New(\"No entry in \" + table + \" with that ID\")\n\t\t\treturn\n\t\t}\n\n\t\treturn ErrNoRows\n\t}\n\n\terr = rows.Scan(ifs...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tn := 0\n\terr = StructFetchStore(obj, ifs, &n)\n\n\treturn\n}\n\n// StructFetch calls StructFetchA() but avoids the need to specify a few\n// parameters that are not always needed (join and ordering).\n//\n// See StructFetchA for the details to the arguments.\nfunc StructFetch(obj interface{}, table string, params []string, matches []string) (err error) {\n\treturn StructFetchA(obj, table, \"\", params, matches, \"\", false)\n}\n\n// StructOp defines what operation to perform on a structure\ntype StructOp uint\n\nconst (\n\tSTRUCTOP_SET    StructOp = iota /* Set the item */\n\tSTRUCTOP_ADD                    /* Add the item */\n\tSTRUCTOP_REMOVE                 /* Remove the item */\n)\n\n// StructFieldMod allows changing a field identified by fname to a new value.\n//\n// Set/add/remove are possible depending on datatype: set for non-slice, add/remove are slice only.\n//\n// This function is typically called through StructMod().\nfunc StructFieldMod(op StructOp, fname string, f reflect.StructField, v reflect.Value, value interface{}) (err error) {\n\tfun := \"StructFieldMod() \"\n\n\t/* What kind of object is this? */\n\tkind := f.Type.Kind()\n\n\t/* Check that this type of operand is actually allowed */\n\tswitch op {\n\tcase STRUCTOP_SET:\n\t\tif kind == reflect.Slice {\n\t\t\treturn errors.New(\"Can't 'set' a slice type: \" + StructNameT(f.Type))\n\t\t}\n\t\tbreak\n\n\tcase STRUCTOP_ADD:\n\t\tif kind != reflect.Slice {\n\t\t\treturn errors.New(\"Can't add to non-slice type: \" + StructNameT(f.Type))\n\t\t}\n\t\tbreak\n\n\tcase STRUCTOP_REMOVE:\n\t\tif kind != reflect.Slice {\n\t\t\treturn errors.New(\"Can't remove from non-slice type: \" + StructNameT(f.Type))\n\t\t}\n\t\tbreak\n\n\tdefault:\n\t\treturn errors.New(\"Unknown STRUCTOP\")\n\t}\n\n\tvo := reflect.ValueOf(value)\n\n\tswitch kind {\n\tcase reflect.String:\n\t\tv.SetString(value.(string))\n\t\treturn nil\n\n\tcase reflect.Bool:\n\t\tswitch vo.Kind() {\n\t\tcase reflect.String:\n\t\t\tv.SetBool(IsTrue(value.(string)))\n\t\t\tbreak\n\n\t\tcase reflect.Bool:\n\t\t\tv.SetBool(value.(bool))\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Unknown source type: \" + vo.Kind().String())\n\t\t}\n\t\treturn nil\n\n\tcase reflect.Int, reflect.Int64:\n\t\tswitch vo.Kind() {\n\t\tcase reflect.String:\n\t\t\tnumber, err := strconv.ParseInt(value.(string), 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid number encountered: '\" + value.(string) + \"'\")\n\t\t\t}\n\t\t\tv.SetInt(number)\n\t\t\tbreak\n\n\t\tcase reflect.Int, reflect.Int64:\n\t\t\tv.SetInt(value.(int64))\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid Type\")\n\t\t}\n\t\treturn nil\n\n\tcase reflect.Uint, reflect.Uint64:\n\t\tswitch vo.Kind() {\n\t\tcase reflect.String:\n\t\t\tnumber, err := strconv.Atoi(value.(string))\n\t\t\tif err != nil {\n\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid number encountered: '\" + value.(string) + \"'\")\n\t\t\t}\n\t\t\tv.SetUint(uint64(number))\n\t\t\tbreak\n\n\t\tcase reflect.Int, reflect.Int64:\n\t\t\tv.SetUint(value.(uint64))\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid Type\")\n\t\t}\n\t\treturn nil\n\n\tcase reflect.Float64:\n\t\tswitch vo.Kind() {\n\t\tcase reflect.String:\n\t\t\tnumber, err := strconv.ParseFloat(value.(string), 64)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid floating number encountered: '\" + value.(string) + \"'\")\n\t\t\t}\n\t\t\tv.SetFloat(number)\n\t\t\tbreak\n\n\t\tcase reflect.Float64:\n\t\t\tv.SetFloat(value.(float64))\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid Type\")\n\t\t}\n\t\treturn nil\n\n\tcase reflect.Struct:\n\t\tty := StructNameT(f.Type)\n\t\tswitch ty {\n\t\tcase \"time.Time\":\n\t\t\tvar no time.Time\n\t\t\tno, err = time.Parse(Config.TimeFormat, value.(string))\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv.Set(reflect.ValueOf(no))\n\t\t\treturn\n\n\t\tcase \"database/sql.NullString\":\n\t\t\tswitch vo.Kind() {\n\t\t\tcase reflect.String:\n\t\t\t\tno := sql.NullString{String: value.(string), Valid: true}\n\t\t\t\tv.Set(reflect.ValueOf(no))\n\t\t\t\tbreak\n\n\t\t\tdefault:\n\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid Type\")\n\t\t\t}\n\t\t\treturn\n\n\t\tcase \"database/sql.NullInt64\":\n\t\t\tswitch vo.Kind() {\n\t\t\tcase reflect.String:\n\t\t\t\tvalid := true\n\t\t\t\tvar number int64 = 0\n\t\t\t\tif value.(string) == \"\" {\n\t\t\t\t\tvalid = false\n\t\t\t\t} else {\n\t\t\t\t\tnumber, err = strconv.ParseInt(value.(string), 10, 64)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid number encountered: '\" + value.(string) + \"'\")\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tno := sql.NullInt64{Int64: number, Valid: valid}\n\t\t\t\tv.Set(reflect.ValueOf(no))\n\t\t\t\tbreak\n\n\t\t\tcase reflect.Int, reflect.Int64:\n\t\t\t\tno := ToNullInt64(value.(int64))\n\t\t\t\tv.Set(reflect.ValueOf(no))\n\t\t\t\tbreak\n\n\t\t\tdefault:\n\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid Type\")\n\t\t\t}\n\t\t\treturn\n\n\t\tcase \"database/sql.NullFloat64\":\n\t\t\tswitch vo.Kind() {\n\t\t\tcase reflect.String:\n\t\t\t\tvalid := true\n\t\t\t\tvar number float64\n\t\t\t\tif value.(string) == \"\" {\n\t\t\t\t\tvalid = false\n\t\t\t\t} else {\n\t\t\t\t\tnumber, err = strconv.ParseFloat(value.(string), 64)\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid floating number encountered: '\" + value.(string) + \"'\")\n\t\t\t\t}\n\t\t\t\tno := sql.NullFloat64{Float64: number, Valid: valid}\n\t\t\t\tv.Set(reflect.ValueOf(no))\n\t\t\t\tbreak\n\n\t\t\tcase reflect.Float64:\n\t\t\t\tno := sql.NullFloat64{Float64: value.(float64), Valid: true}\n\t\t\t\tv.Set(reflect.ValueOf(no))\n\t\t\t\tbreak\n\n\t\t\tdefault:\n\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid Type\")\n\t\t\t}\n\t\t\treturn\n\n\t\tcase \"database/sql.NullBool\":\n\t\t\tswitch vo.Kind() {\n\t\t\tcase reflect.String:\n\t\t\t\tyesno := IsTrue(value.(string))\n\t\t\t\tno := sql.NullBool{Bool: yesno, Valid: true}\n\t\t\t\tv.Set(reflect.ValueOf(no))\n\t\t\t\tbreak\n\n\t\t\tcase reflect.Bool:\n\t\t\t\tno := sql.NullBool{Bool: value.(bool), Valid: true}\n\t\t\t\tv.Set(reflect.ValueOf(no))\n\t\t\t\tbreak\n\n\t\t\tdefault:\n\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid Type\")\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\t/* Check if the object supports the Scan interface */\n\t\to := StructRecurse(v)\n\t\ttfunc := \"Scan\"\n\t\tobjtrail := []interface{}{o}\n\t\tok, obj := ObjHasFunc(objtrail, tfunc)\n\t\tif ok {\n\t\t\t/* Scan() the value in */\n\t\t\tres, err2 := ObjFunc(obj, tfunc, value)\n\t\t\tif err2 == nil {\n\t\t\t\terr2, ok := res[0].Interface().(error)\n\t\t\t\tif ok {\n\t\t\t\t\terr = err2\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\treturn errors.New(fun + \"Variable '\" + fname + \"' is an unknown struct: \" + ty)\n\n\tcase reflect.Slice:\n\t\tswitch op {\n\t\tcase STRUCTOP_ADD:\n\t\t\t/* What do we store here? */\n\t\t\tvn := v.Type().String()\n\n\t\t\tswitch vn {\n\t\t\tcase \"[]string\":\n\t\t\t\tbreak\n\n\t\t\tcase \"[]int\":\n\t\t\t\t/* Input a string or a int? */\n\t\t\t\tswitch vo.Kind() {\n\t\t\t\tcase reflect.String:\n\t\t\t\t\tnumber, err := strconv.Atoi(value.(string))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid number encountered: '\" + value.(string) + \"'\")\n\t\t\t\t\t}\n\t\t\t\t\tvo = reflect.ValueOf(number)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase reflect.Uint, reflect.Uint64:\n\t\t\t\t\tvo = reflect.ValueOf(value.(uint64))\n\t\t\t\t\tbreak\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn errors.New(fun + \" detected a unsupported type for \" + fname)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tn := reflect.Append(v, vo)\n\t\t\tv.Set(n)\n\t\t\treturn nil\n\n\t\tcase STRUCTOP_REMOVE:\n\t\t\t/* What do we store here? */\n\t\t\tvn := v.Type().String()\n\n\t\t\t/* Found it? */\n\t\t\tfound := -1\n\n\t\t\t/* First, find the item we want to remove */\n\t\t\tfor k := 0; found == -1 && k < v.Len(); k += 1 {\n\t\t\t\tswitch vn {\n\t\t\t\tcase \"[]string\":\n\t\t\t\t\tov := v.Index(k).Interface().(string)\n\t\t\t\t\tif ov == value.(string) {\n\t\t\t\t\t\tfound = k\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\n\t\t\t\tcase \"[]int\", \"[]uint64\":\n\t\t\t\t\tvar ov uint64\n\n\t\t\t\t\tswitch vn {\n\t\t\t\t\tcase \"[]int\":\n\t\t\t\t\t\tov = uint64(v.Index(k).Interface().(int))\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"[]uint64\":\n\t\t\t\t\t\tov = v.Index(k).Interface().(uint64)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn errors.New(\"Unsupported integer?\")\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Input a string or a int? */\n\t\t\t\t\tswitch vo.Kind() {\n\t\t\t\t\tcase reflect.String:\n\t\t\t\t\t\tnumber, err := strconv.Atoi(value.(string))\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" invalid number encountered: '\" + value.(string) + \"'\")\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif uint64(number) == ov {\n\t\t\t\t\t\t\tfound = k\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase reflect.Uint:\n\t\t\t\t\t\tnumber := value.(int)\n\n\t\t\t\t\t\tif uint64(number) == ov {\n\t\t\t\t\t\t\tfound = k\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase reflect.Uint64:\n\t\t\t\t\t\tnumber := value.(uint64)\n\t\t\t\t\t\tif number == ov {\n\t\t\t\t\t\t\tfound = k\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn errors.New(fun + \" detected a unsupported type for \" + fname)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn errors.New(\"Do not support removing from slice of type \" + vn)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif found == -1 {\n\t\t\t\treturn errors.New(\"Item not found, thus cannot remove\")\n\t\t\t}\n\n\t\t\t/* Create a new slice with all elements except the found one */\n\t\t\tn := v.Slice(0, found)\n\t\t\tn = reflect.AppendSlice(n, v.Slice(found+1, v.Len()))\n\n\t\t\t/* Set the slice to the new one, which does not have the item */\n\t\t\tv.Set(n)\n\t\t\treturn nil\n\t\t}\n\n\t\t/* Handled nicer above */\n\t\tpanic(\"Cannot apply STRUCTOP_SET to a Slice\")\n\n\t/* TODO support reflect.Map */\n\n\tdefault:\n\t\tvar k reflect.Kind\n\t\tk = f.Type.Kind()\n\t\treturn errors.New(fun + \"Variable \" + fname + \" Unknown type: \" + k.String())\n\t}\n}\n\n// structModA modifies a single field.\n//\n// This is called by StructMod, recursively to be able to support nested structs.\nfunc StructModA(op StructOp, obj interface{}, field string, value interface{}) (done bool, err error) {\n\tfun := \"StructMod() \"\n\n\tdone = false\n\n\tfield = strings.ToLower(field)\n\n\ts, va := StructReflect(obj)\n\n\tfor i := 0; i < s.NumField(); i++ {\n\t\tf := s.Field(i)\n\t\tv := va.Field(i)\n\n\t\tttype, dorecurse, compound := PfType(f, v, true)\n\t\tif ttype == \"ignore\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif dorecurse {\n\t\t\tdone, err = StructModA(op, StructRecurse(v), field, value)\n\t\t\tif done || err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif compound {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* No tags, then ignore it */\n\t\tif f.Tag == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Column/fieldname in SQL Table */\n\t\tfname := f.Tag.Get(\"pfcol\")\n\t\tif fname == \"\" {\n\t\t\tfname = strings.ToLower(f.Name)\n\t\t}\n\n\t\t/* Not this field? */\n\t\tif fname != field {\n\t\t\tcontinue\n\t\t}\n\n\t\tif !v.CanSet() {\n\t\t\terr = errors.New(fun + \"Can't set field '\" + fname + \"'\")\n\t\t\treturn\n\t\t}\n\n\t\tdone = true\n\t\terr = StructFieldMod(op, fname, f, v, value)\n\t\treturn\n\t}\n\n\treturn\n}\n\n// StructMod modifies a single field of a object.\n//\n// Given the object obj, it finds the 'field' in the structure and sets it to the given value.\n//\n// ErrNoRows is returned when no such field was found.\n// Other errors, eg permission errors or inability to set a field can also be returned.\n// An error of nil is returned if the change of the value succeeded.\nfunc StructMod(op StructOp, obj interface{}, field string, value interface{}) (err error) {\n\tdone, err := StructModA(op, obj, field, value)\n\tif err == nil && !done {\n\t\terr = ErrNoRows\n\t\treturn\n\t}\n\n\treturn\n}\n\n// structVarsA is the recursive portion of StructVars and thus only called by that function\nfunc StructVars(ctx PfCtx, obj interface{}, ptype PType, doignore bool) (vars map[string]string, err error) {\n\tobjtrail := []interface{}{}\n\tvars = make(map[string]string)\n\terr = StructVarsA(ctx, objtrail, obj, ptype, doignore, vars)\n\treturn vars, err\n}\n\n// StructVars returns all fields in a struct that can be retrieved or modified, returning a map of strings.\n//\n// StructVars takes an object to inspect and a ptype indicating what permissions the field should satisfy for them to be included.\n//\n// The map consists out of the key being the fieldname and the value being the ToString()'d value of the field.\n//\n// Permissions are tested against the provided ptype and the context.\nfunc StructVarsA(ctx PfCtx, objtrail []interface{}, obj interface{}, ptype PType, doignore bool, vars map[string]string) (err error) {\n\ts, va := StructReflect(obj)\n\n\tobjtrail = append([]interface{}{obj}, objtrail...)\n\n\tfor i := 0; i < s.NumField(); i++ {\n\t\tf := s.Field(i)\n\t\tv := va.Field(i)\n\n\t\t// ctx.Dbgf(\"StructVars: %s [%s]\", f.Name, f.Type.Kind().String())\n\n\t\tttype, dorecurse, compound := PfType(f, v, true)\n\t\tif ttype == \"ignore\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif dorecurse {\n\t\t\terr = StructVarsA(ctx, objtrail, StructRecurse(v), ptype, doignore, vars)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif compound {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* No tags, then ignore it */\n\t\tif f.Tag == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Column/fieldname in SQL Table */\n\t\tfname := f.Tag.Get(\"pfcol\")\n\t\tif fname == \"\" {\n\t\t\tfname = strings.ToLower(f.Name)\n\t\t}\n\n\t\tvar ok bool\n\n\t\tok, _, err = StructPermCheck(ctx, ptype, objtrail, PTypeWrap(f))\n\t\t// ctx.Dbgf(\"StructVars: %s - permcheck: %s, err: %v\", f.Name, YesNo(ok), err)\n\t\tif err != nil {\n\t\t\tskipfailperm := f.Tag.Get(\"pfskipfailperm\")\n\t\t\tif skipfailperm == \"\" {\n\t\t\t\tctx.Dbgf(\"StructVars: %s - permcheck: %s, err: %s\", f.Name, YesNo(ok), err.Error())\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif !ok && ttype != \"ptr\" && ttype != \"struct\" {\n\t\t\t// oname := StructNameObjTrail(objtrail)\n\t\t\t// ctx.Dbg(\"NOT SHOWING: field = %s, ttype = %s\", oname+\":\"+fname, ttype)\n\t\t\tcontinue\n\t\t}\n\n\t\tvars[fname] = ttype\n\t}\n\n\terr = nil\n\treturn\n}\n\n// StructDetails_Options defines options to apply when checking StructDetails\ntype StructDetails_Options int\n\nconst (\n\tSD_None                               = 0         /* No Options */\n\tSD_Perms_Check  StructDetails_Options = 0 << iota /* Check Permissions */\n\tSD_Perms_Ignore                                   /* Ignore Permissions */\n\tSD_Tags_Require                                   /* Require Tags */\n\tSD_Tags_Ignore                                    /* Ignore Tags */\n)\n\n// structDetailsA is the recursive portion of StructDetails, see that function for more details\nfunc StructDetailsA(ctx PfCtx, obj interface{}, field string, opts StructDetails_Options) (ftype string, fname string, fvalue string, err error) {\n\tcheckperms := false\n\tif opts&SD_Perms_Check > 0 {\n\t\tcheckperms = true\n\t}\n\n\trequiretags := false\n\tif opts&SD_Tags_Require > 0 {\n\t\trequiretags = true\n\t}\n\n\ts, va := StructReflect(obj)\n\n\tfor i := 0; i < s.NumField(); i++ {\n\t\tf := s.Field(i)\n\t\tv := va.Field(i)\n\n\t\t/* Column/fieldname in SQL Table */\n\t\tfname = f.Tag.Get(\"pfcol\")\n\t\tif fname == \"\" {\n\t\t\tfname = strings.ToLower(f.Name)\n\t\t}\n\n\t\t/* Ignore the field completely? */\n\t\tttype, dorecurse, compound := PfType(f, v, true)\n\t\tif ttype == \"ignore\" {\n\t\t\tif fname == field {\n\t\t\t\treturn \"ignore\", \"\", \"\", errors.New(\"Field is ignored\")\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif dorecurse {\n\t\t\tftype, fname, fvalue, err = StructDetailsA(ctx, StructRecurse(v), field, opts)\n\t\t\tif ftype != \"\" || err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif compound {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* No tags, then ignore it */\n\t\tif requiretags && f.Tag == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Wrong field, skip it */\n\t\tif fname != field {\n\t\t\tcontinue\n\t\t}\n\n\t\tif checkperms {\n\t\t\tok := true\n\t\t\tpermstr := f.Tag.Get(\"pfset\")\n\t\t\tok, err = ctx.CheckPermsT(\"StructDetails(\"+fname+\")\", permstr)\n\t\t\tif !ok {\n\t\t\t\treturn \"\", \"\", \"\", err\n\t\t\t}\n\t\t}\n\n\t\treturn \"string\", fname, ToString(v.Interface()), nil\n\t}\n\n\treturn \"\", \"\", \"\", nil\n}\n\n// StructDetails returns the details of a structure's field.\n//\n// It determines the type of the field and the string value of the field.\n//\n// The opts can be used to influence if permission checking needs to be done\n// and if tags are required to be present for the field to be checked.\nfunc StructDetails(ctx PfCtx, obj interface{}, field string, opts StructDetails_Options) (ftype string, fname string, fvalue string, err error) {\n\tfield = strings.ToLower(field)\n\n\tftype, fname, fvalue, err = StructDetailsA(ctx, obj, field, opts)\n\tif err == nil && ftype == \"\" {\n\t\treturn \"unknown\", \"\", \"\", errors.New(\"Unknown Field: \" + field + \" (StructDetails)\")\n\t}\n\n\treturn\n}\n\n// structTagA is the recursive portion of StructTag, see that function for details\nfunc StructTagA(obj interface{}, field string, tag string) (val string, err error) {\n\ts, va := StructReflect(obj)\n\n\tfor i := 0; i < s.NumField(); i++ {\n\t\tf := s.Field(i)\n\t\tv := va.Field(i)\n\n\t\tttype, dorecurse, compound := PfType(f, v, true)\n\t\tif ttype == \"ignore\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif dorecurse {\n\t\t\tval, err = StructTagA(StructRecurse(v), field, tag)\n\t\t\tif err != nil || val != \"\" {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif compound {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* No tags, then ignore it */\n\t\tif f.Tag == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Column/fieldname in SQL Table */\n\t\tfname := f.Tag.Get(\"pfcol\")\n\t\tif fname == \"\" {\n\t\t\tfname = strings.ToLower(f.Name)\n\t\t}\n\n\t\tif fname != field {\n\t\t\tcontinue\n\t\t}\n\n\t\tval = f.Tag.Get(tag)\n\t\treturn\n\t}\n\n\treturn \"\", nil\n}\n\n// StructTag retrieves the requested tag from a field in a structure.\n//\n// Any type of object can be provided, it will be recursed incase of embedded structs.\n//\n// The field indicates the name of the structure's field.\n// The tag indicates which tag to get for that field.\n//\n// The value returned is the content of the tag for the requested field.\nfunc StructTag(obj interface{}, field string, tag string) (val string, err error) {\n\tfield = strings.ToLower(field)\n\n\tval, err = StructTagA(obj, field, tag)\n\tif err == nil && val == \"\" {\n\t\treturn \"\", errors.New(\"Unknown Field: \" + field + \" (StructTag)\")\n\t}\n\n\treturn\n}\n\n// structMenuA is the recursive portion of StructMenu\n//\n// See StructMenu for more details.\nfunc StructMenuA(ctx PfCtx, subjects []string, objtrail []interface{}, obj interface{}, onlyslices bool, fun PfFunc, isedit bool, nargs int) (menu PfMenu, err error) {\n\t/* Prepend this object to the trail */\n\tobjtrail = append([]interface{}{obj}, objtrail...)\n\n\ts, va := StructReflect(obj)\n\n\tfor i := 0; i < s.NumField(); i++ {\n\t\tf := s.Field(i)\n\t\tv := va.Field(i)\n\n\t\tttype, dorecurse, compound := PfType(f, v, true)\n\t\tif ttype == \"ignore\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif dorecurse {\n\t\t\tm, err := StructMenuA(ctx, subjects, objtrail, StructRecurse(v), onlyslices, fun, isedit, nargs)\n\t\t\tif err != nil {\n\t\t\t\treturn PfMenu{}, err\n\t\t\t}\n\n\t\t\tmenu.Add(m.M...)\n\t\t}\n\n\t\tif compound {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* No tags, then ignore it */\n\t\tif f.Tag == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Ignore slices when we don't want them, others if we only want slices */\n\t\tif (ttype == \"slice\" && onlyslices == false) || (ttype != \"slice\" && onlyslices == true) {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Column/fieldname in SQL Table */\n\t\tfname := f.Tag.Get(\"pfcol\")\n\t\tif fname == \"\" {\n\t\t\tfname = strings.ToLower(f.Name)\n\t\t}\n\n\t\t/* Options from the Tag of the structure */\n\t\tlabel := f.Tag.Get(\"label\")\n\t\tif label != \"\" {\n\t\t\t/* Only translate when the label is specifically set */\n\t\t\tlabel = TranslateObj(ctx, objtrail, label)\n\t\t} else {\n\t\t\tlabel = f.Name\n\t\t}\n\n\t\thint := f.Tag.Get(\"hint\")\n\t\tif hint != \"\" {\n\t\t\t/* Only translate when the hint is specifically set */\n\t\t\thint = TranslateObj(ctx, objtrail, hint)\n\t\t}\n\n\t\t/* Default description to the label */\n\t\tdesc := label\n\n\t\t/* Append the hint to the description */\n\t\tif hint != \"\" {\n\t\t\tdesc += \" - \" + hint\n\t\t}\n\n\t\t/* Ignore the field completely? */\n\t\tignore := f.Tag.Get(\"pfignore\")\n\t\tif ignore == \"yes\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tvar perms Perm\n\t\tvar tag string\n\n\t\tif isedit {\n\t\t\ttag = \"pfset\"\n\t\t} else {\n\t\t\ttag = \"pfget\"\n\t\t}\n\n\t\tset := f.Tag.Get(tag)\n\t\terr = perms.FromString(set)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tif perms == PERM_NOTHING {\n\t\t\t/* Default permissions is to allow getting/setting of anything */\n\t\t\tperms = PERM_NONE\n\t\t}\n\n\t\tvar ok bool\n\t\tok, _ = ctx.CheckPerms(\"StructMenu(\"+fname+\")\", perms)\n\t\tif !ok {\n\t\t\t/* Also change to 'ok, err' above */\n\t\t\t/* Dbgf(\"StructMenu(%s) Skipping (tag: %s), err: %s\", fname, tag, err.Error()) */\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Initial subjects */\n\t\tsubj := subjects\n\n\t\tif isedit {\n\t\t\totype := \"\"\n\n\t\t\tswitch ttype {\n\t\t\tcase \"bool\":\n\t\t\t\totype = \"#bool\"\n\t\t\t\tbreak\n\n\t\t\tcase \"int\":\n\t\t\t\totype = \"#int\"\n\t\t\t\tbreak\n\n\t\t\tcase \"file\":\n\t\t\t\totype = \"#file\"\n\t\t\t\totype += \"#\" + f.Tag.Get(\"pfmaximagesize\")\n\n\t\t\t\tb64 := f.Tag.Get(\"pfb64\")\n\t\t\t\totype += \"#\" + NormalizeBoolean(b64)\n\t\t\t\tbreak\n\n\t\t\tcase \"string\", \"text\", \"tel\":\n\t\t\t\totype = \"#string\"\n\t\t\t\tbreak\n\n\t\t\tcase \"time\":\n\t\t\t\totype = \"#time\"\n\t\t\t\tbreak\n\n\t\t\tcase \"struct\":\n\t\t\t\tbreak\n\n\t\t\tcase \"slice\":\n\t\t\t\tbreak\n\n\t\t\tcase \"map\":\n\t\t\t\tbreak\n\n\t\t\tcase \"ptr\":\n\t\t\t\tbreak\n\n\t\t\tdefault:\n\t\t\t\tpanic(\"Unknown Type for field \" + fname + \", type \" + ttype)\n\t\t\t}\n\n\t\t\tsubj = append(subj, fname+otype)\n\t\t}\n\n\t\tvar m PfMEntry\n\t\tm.Cmd = fname\n\t\tm.Fun = fun\n\t\tm.Args_min = nargs\n\t\tm.Args_max = nargs\n\t\tm.Args = subj\n\t\tm.Perms = perms\n\t\tm.Desc = desc\n\n\t\tmenu.Add(m)\n\t}\n\n\treturn menu, nil\n}\n\n// StructMenu can create \"get\", \"set\", \"add\" and \"remove\" CLI menus\n// from a given structure.\n//\n// The subjects parameter indicates the field(s) that indicates what\n// should be provided as an argument to select that specific object.\n//\n// The object is an example object (just the structure, no values needed)\n// that has a set of fields with tags. The tags are used to retrieve the\n// labels and descriptions for the field, but also the permissions needed\n// to configure that field.\n//\n// onlyslices is used to switch between a 'get'/'set' menu and a 'add'/'remove' menu.\n// When onlyslices is true only fields that are slices are listed, these will\n// require an 'add'/'remove' construct instead of being able to be directly 'set' or 'get'.\n//\n// When a function is provided, the menu becomes a 'set' or add/remove menu (for slices).\n// When no function is provided the resulting menu is a 'get' menu.\n// The permissions for set/get are adhered to.\n//\n// See the example for a minimal example. The User portion of Pitchfork makes a good\n// full example on how this code is used, see lib/user.go user_get/user_set etc.\nfunc StructMenu(ctx PfCtx, subjects []string, obj interface{}, onlyslices bool, fun PfFunc) (menu PfMenu, err error) {\n\tvar isedit bool\n\n\t/* Select the Object */\n\tctx.SelectObject(&obj)\n\n\t/* Number of subjects */\n\tnargs := len(subjects)\n\n\t/* Edit or not? */\n\tif fun != nil {\n\t\tisedit = true\n\n\t\t/* Edit's require one more argument */\n\t\tnargs++\n\t} else {\n\t\tfun = structGet\n\t}\n\n\t/* Recursive call */\n\tobjtrail := []interface{}{}\n\treturn StructMenuA(ctx, subjects, objtrail, obj, onlyslices, fun, isedit, nargs)\n}\n\n// structGetA is the recursive part of StructGet.\nfunc structGetA(ctx PfCtx, obj interface{}, field string) (done bool, err error) {\n\ts, va := StructReflect(obj)\n\n\tdone = false\n\n\tif s.Kind() == reflect.Interface {\n\t\treturn structGetA(ctx, StructRecurse(va), field)\n\t}\n\n\tif s.Kind() != reflect.Struct {\n\t\terr = errors.New(\"Error: parameter is not a struct/interface but \" + s.String() + \" (structGet)\")\n\t\treturn\n\t}\n\n\tfor i := 0; i < s.NumField(); i++ {\n\t\tf := s.Field(i)\n\t\tv := va.Field(i)\n\n\t\tttype, dorecurse, compound := PfType(f, v, true)\n\t\tif ttype == \"ignore\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif dorecurse {\n\t\t\tdone, err = structGetA(ctx, StructRecurse(v), field)\n\t\t\tif done || err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif compound {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* No tags, then ignore it */\n\t\tif f.Tag == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Column/fieldname in SQL Table */\n\t\tfname := f.Tag.Get(\"pfcol\")\n\t\tif fname == \"\" {\n\t\t\tfname = strings.ToLower(f.Name)\n\t\t}\n\n\t\t/* Wrong field -> next! */\n\t\tif fname != field {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Ignore the field completely? */\n\t\tignore := f.Tag.Get(\"pfignore\")\n\t\tif ignore == \"yes\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t/*\n\t\t * Note: structGet does not check permissions,\n\t\t * it is only used by StructMenu() which does\n\t\t * check for permissions\n\t\t */\n\t\tstr := ToString(v.Interface())\n\t\tctx.OutLn(str)\n\n\t\tdone = true\n\t\terr = nil\n\t\treturn\n\t}\n\n\treturn\n}\n\n// Create a \"get\" menu from a struct -- helper function of StructMenu.\nfunc structGet(ctx PfCtx, args []string) (err error) {\n\tobj := ctx.SelectedObject()\n\n\tif obj == nil {\n\t\treturn errors.New(\"No object selected\")\n\t}\n\n\tfield := ctx.GetLastPart()\n\n\tdone, err := structGetA(ctx, obj, field)\n\tif err == nil && !done {\n\t\terr = errors.New(\"Unknown property\")\n\t}\n\n\treturn\n}\n\n// ToString converts any type of object to a string representation.\nfunc ToString(v interface{}) (str string) {\n\ts, _ := StructReflect(v)\n\n\tswitch s.Kind() {\n\n\tcase reflect.String:\n\t\treturn v.(string)\n\n\tcase reflect.Bool:\n\t\treturn YesNo(v.(bool))\n\n\tcase reflect.Int:\n\t\treturn strconv.Itoa(v.(int))\n\n\tcase reflect.Uint:\n\t\treturn strconv.FormatUint(uint64(v.(uint)), 10)\n\n\tcase reflect.Int64:\n\t\treturn strconv.FormatInt(v.(int64), 10)\n\n\tcase reflect.Uint64:\n\t\treturn strconv.FormatUint(v.(uint64), 10)\n\n\tcase reflect.Float64:\n\t\treturn strconv.FormatFloat(v.(float64), 'E', -1, 64)\n\n\tcase reflect.Struct:\n\t\tty := StructNameT(s)\n\n\t\tswitch ty {\n\t\tcase \"time.Time\":\n\t\t\tno := v.(time.Time)\n\t\t\treturn no.Format(Config.TimeFormat)\n\n\t\tcase \"database/sql.NullString\":\n\t\t\tno := v.(sql.NullString)\n\t\t\tif !no.Valid {\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\treturn ToString(no.String)\n\n\t\tcase \"database/sql.NullInt64\":\n\t\t\tno := v.(sql.NullInt64)\n\t\t\tif !no.Valid {\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\treturn ToString(no.Int64)\n\n\t\tcase \"database/sql.NullFloat64\":\n\t\t\tno := v.(sql.NullFloat64)\n\t\t\tif !no.Valid {\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\treturn ToString(no.Float64)\n\n\t\tcase \"database/sql.NullBool\":\n\t\t\tno := v.(sql.NullBool)\n\t\t\tif !no.Valid {\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\treturn ToString(no.Bool)\n\n\t\tdefault:\n\t\t\t/* Try if the object has a String() function */\n\t\t\ttfunc := \"String\"\n\t\t\tobjtrail := []interface{}{v}\n\t\t\tok, obj := ObjHasFunc(objtrail, tfunc)\n\t\t\tif ok {\n\t\t\t\ts, err := ObjFuncStr(obj, tfunc)\n\t\t\t\tif err == nil {\n\t\t\t\t\treturn s\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpanic(\"ToString() Unhandled Struct Type '\" + ty + \"' : \" + s.String())\n\t\t}\n\t}\n\n\tpanic(\"ToString() Unhandled Type: \" + s.String())\n}\n\n// ObjFuncI retains a object.\ntype ObjFuncI struct {\n\tobj interface{}\n}\n\n// ObjHasFunc is used to determine of an object has the given function,\n// returning the (embedded) object that has the function\n//\n// An objecttrail consisting of one or more objects is passed in, thus\n// allowing a function to be found in a nested set of objects.\n//\n// This call should be used before ObjFunc to ensure the function\n// has the given object, and to select the correct object.\nfunc ObjHasFunc(objtrail []interface{}, fun string) (ok bool, obj ObjFuncI) {\n\tok = false\n\n\tfor _, ob := range objtrail {\n\t\to := reflect.ValueOf(ob)\n\n\t\tif o.IsValid() {\n\t\t\tf := o.MethodByName(fun)\n\t\t\tif f.IsValid() {\n\t\t\t\tok = true\n\t\t\t\tobj.obj = ob\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tErrf(\"Not a valid object: %#v\", obj)\n\t\t}\n\t}\n\n\treturn\n}\n\n// ObjFunc calls, when available, a function in an object and returns it's result\n//\n// The 'fun' is retrieved from the given object, as typically found with ObjHasFunc.\n// The function is then verified to be able to accept the parameters specified by params.\n// And the function is then called dynamically.\n//\n// One major use-case is the Translate function of objects, where we typically do\n// not know what object we will be calling that function on.\nfunc ObjFunc(obj ObjFuncI, fun string, params ...interface{}) (result []reflect.Value, err error) {\n\tresult = nil\n\terr = nil\n\n\to := reflect.ValueOf(obj.obj)\n\tif !o.IsValid() {\n\t\terr = errors.New(\"Not a valid object\")\n\t\treturn\n\t}\n\n\tf := o.MethodByName(fun)\n\tif !f.IsValid() {\n\t\terr = errors.New(\"Unknown Function \" + fun)\n\t\treturn\n\t}\n\n\tpnum := f.Type().NumIn()\n\tif (f.Type().IsVariadic() && len(params) < pnum) || (!f.Type().IsVariadic() && len(params) != pnum) {\n\t\tvtxt := \"\"\n\t\tif f.Type().IsVariadic() {\n\t\t\tvtxt = \" [note: variadic]\"\n\t\t}\n\t\terr = errors.New(\"Wrong amount of parameters, got: \" + strconv.Itoa(len(params)) + \", need: \" + strconv.Itoa(pnum) + vtxt)\n\t\tpanic(\"Need more\")\n\t}\n\n\tin := make([]reflect.Value, len(params))\n\n\tfor k, param := range params {\n\t\t/* Avoid a null Value */\n\t\tif param == nil {\n\t\t\tin[k] = reflect.ValueOf(&param).Elem()\n\t\t} else {\n\t\t\tin[k] = reflect.ValueOf(param)\n\t\t}\n\t}\n\n\tresult = f.Call(in)\n\treturn\n}\n\n// ObjFuncIface calls a function of an object and returns the result of an interface.\n//\n// See ObjFunc for more details on the parameters.\nfunc ObjFuncIface(obj ObjFuncI, fun string, params ...interface{}) (iface interface{}, err error) {\n\tres, err := ObjFunc(obj, fun, params...)\n\n\tif err == nil {\n\t\tiface = res[0].Interface()\n\t} else {\n\t\tiface = nil\n\t}\n\n\treturn\n}\n\n// ObjFuncStr calls a function of an object and returns a string.\n//\n// When the returned type of the called function is not a string,\n// this code will return a string indicating that in the string.\n// Similary the string will be filled with a notion that the call failed.\n// Next to having a non-nil error return.\n//\n// See ObjFunc for more details on the parameters.\nfunc ObjFuncStr(obj ObjFuncI, fun string, params ...interface{}) (str string, err error) {\n\tres, err := ObjFunc(obj, fun, params...)\n\n\tif err == nil {\n\t\tif res[0].Kind() == reflect.String {\n\t\t\tstr = res[0].String()\n\t\t} else {\n\t\t\tstr = fun + \"()-not-a-string\"\n\t\t}\n\t} else {\n\t\tstr = fun + \"()-failed\"\n\t}\n\n\treturn\n}\n\n// objPermCheck calls custom PermCheck function on an object and determines\n// if one has access and is allowed to edit or not.\n//\n// The ptype is used for the permission check to determine if read or write access is needed.\n// Per-application permissions could be more strict and be full CRUD-style.\n//\n// The return of 'ok' indicates that it is allowed to access the field.\n// The allowedit indicates if the field is allowed to be edited/modified.\n// The error indicates whether anything failed, nil indicates success.\n//\n// This function is used by StructPermCheck.\nfunc ObjPermCheck(ctx PfCtx, obj ObjFuncI, ptype PType, f PTypeField) (ok bool, allowedit bool, err error) {\n\tres, err := ObjFunc(obj, \"PermCheck\", ctx, ptype, f)\n\n\tif err == nil {\n\t\tvar varok bool\n\n\t\tok = res[0].Interface().(bool)\n\t\tallowedit = res[1].Interface().(bool)\n\t\terr, varok = res[2].Interface().(error)\n\t\tif !varok {\n\t\t\terr = nil\n\t\t}\n\t} else {\n\t\tok = false\n\t\tallowedit = false\n\t}\n\n\treturn\n}\n\n// StructPermCheck checks the permissions of a struct,\n// and determines if one has acccess and is allowed to edit.\n//\n// The ptype allows specifying of CRUD-style (Create/Read/Update/Delete) permissions to check for.\n// The objtrail is passed in, to allow a surrounding object to be used for Permission checking.\n// The PermCheck function of the first object in the trail is used for permission checks next to\n// the pitchfork pfget/pfset permissions.\n//\n// The f parameter is the field we are checking permissions for.\n//\n// The return of 'ok' indicates that it is allowed to access the field.\n// The allowedit indicates if the field is allowed to be edited/modified.\n// The error indicates whether anything failed, nil indicates success.\nfunc StructPermCheck(ctx PfCtx, ptype PType, objtrail []interface{}, f PTypeField) (ok bool, allowedit bool, err error) {\n\tswitch ptype {\n\tcase PTYPE_CREATE, PTYPE_UPDATE:\n\t\tallowedit = true\n\t\tbreak\n\n\tcase PTYPE_READ, PTYPE_DELETE:\n\t\tallowedit = false\n\t\tbreak\n\n\tdefault:\n\t\tpanic(\"Unknown ptype\")\n\t}\n\n\t/* Check Application specific permissions */\n\tapp_perms, obj := ObjHasFunc(objtrail, \"PermCheck\")\n\tif app_perms {\n\t\tok, allowedit, err = ObjPermCheck(ctx, obj, ptype, f)\n\n\t\tif err == nil && !ok && allowedit {\n\t\t\t/* Retry in read mode */\n\t\t\tptype = PTYPE_READ\n\t\t\tok, allowedit, err = ObjPermCheck(ctx, obj, ptype, f)\n\t\t}\n\n\t\t/* Errors or denies give a direct answer */\n\t\tif err != nil || !ok {\n\t\t\treturn\n\t\t}\n\t}\n\n\t/* If there is a Pitchfork tag it also gets to make a decision */\n\ttag := \"pfget\"\n\tif allowedit {\n\t\ttag = \"pfset\"\n\t}\n\n\tpermstr := f.Tag.Get(tag)\n\n\tif !app_perms || permstr != \"\" {\n\t\tok, err = ctx.CheckPermsT(\"StructPermCheck(\"+f.Name+\"/\"+tag+\"/\"+permstr+\")\", permstr)\n\t\tif !ok && allowedit {\n\t\t\tallowedit = false\n\t\t\ttag = \"pfget\"\n\t\t\tpermstr := f.Tag.Get(tag)\n\n\t\t\t/* Use the fail for pfset, if no pfget is defined and pfset errored */\n\t\t\tif permstr == \"\" && err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t/* Fall back */\n\t\t\tok, err = ctx.CheckPermsT(\"StructPermCheck(\"+f.Name+\"/get/\"+permstr+\")\", permstr)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\treturn\n}\n"], "fixing_code": ["// Pitchfork ctx defines the context that is passed through Pitchfork pertaining primarily to the logged in, selected user/group\npackage pitchfork\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"net\"\n\t\"strconv\"\n\t\"strings\"\n\n\tuseragent \"github.com/mssola/user_agent\"\n\ti18n \"github.com/nicksnyder/go-i18n/i18n\"\n)\n\n// ErrLoginIncorrect is used when a login is incorrect, this to hide more specific reasons\nvar ErrLoginIncorrect = errors.New(\"Login incorrect\")\n\n// PfNewUserI, NewGroupI, PfMenuI, PfAppPermsI, PfPostBecomeI are function definitions to allow overriding of these functions by application code\ntype PfNewUserI func() (user PfUser)\ntype PfNewGroupI func() (user PfGroup)\ntype PfMenuI func(ctx PfCtx, menu *PfMenu)\ntype PfAppPermsI func(ctx PfCtx, what string, perms Perm) (final bool, ok bool, err error)\ntype PfPostBecomeI func(ctx PfCtx)\n\n// PfModOptsI is the interface that is implemented by PfModOptsS allowing the latter to be extended with more details\ntype PfModOptsI interface {\n\tIsModOpts() bool\n}\n\n// PfModOptsS is the base structure used to impleent PfModOptsI\ntype PfModOptsS struct {\n\t// CLI command prefix, eg 'group wiki'\n\tCmdpfx string\n\n\t// URL prefix, typically System_Get().PublicURL()\n\tURLpfx string\n\n\t// Path Root\n\tPathroot string\n\n\t// URL root, inside the hostname, eg '/group/name/wiki/'\n\tURLroot string\n}\n\n// IsModOpts is a simple fakeish function to cause PfModOptsS to be of type PfModOptsI\n// as it requires this function to be present, which other structures will not satisfy.\nfunc (m PfModOptsS) IsModOpts() bool {\n\treturn true\n}\n\n// PfModOpts can be used to easily initialize a PfModOptsS.\n//\n// The arguments match the variables in the PfModOpts structure.\n//\n// The function ensures that the web_root ends in a slash ('/').\nfunc PfModOpts(ctx PfCtx, cmdpfx string, path_root string, web_root string) PfModOptsS {\n\turlpfx := System_Get().PublicURL\n\n\tweb_root = URL_EnsureSlash(web_root)\n\n\treturn PfModOptsS{cmdpfx, urlpfx, path_root, web_root}\n}\n\n// PfCtx is the Context Interface.\n//\n// PfCtxS is the default implementation.\n//\n// This interface is primarily intended to allow extension by an application.\n\n// See the individual functions in PfCtxS for per function details.\ntype PfCtx interface {\n\tGetAbort() <-chan bool\n\tSetAbort(abort <-chan bool)\n\tSetTx(tx *Tx)\n\tGetTx() (tx *Tx)\n\tErr(message string)\n\tErrf(format string, a ...interface{})\n\tLog(message string)\n\tLogf(format string, a ...interface{})\n\tDbg(message string)\n\tDbgf(format string, a ...interface{})\n\tInit() (err error)\n\tSetStatus(code int)\n\tGetStatus() (code int)\n\tSetReturnCode(rc int)\n\tGetReturnCode() (rc int)\n\tGetLoc() string\n\tGetLastPart() string\n\tBecome(user PfUser)\n\tGetToken() (tok string)\n\tNewToken() (err error)\n\tLoginToken(tok string) (expsoon bool, err error)\n\tLogin(username string, password string, twofactor string) (err error)\n\tLogout()\n\tIsLoggedIn() bool\n\tIsGroupMember() bool\n\tIAmGroupAdmin() bool\n\tIAmGroupMember() bool\n\tGroupHasWiki() bool\n\tGroupHasFile() bool\n\tGroupHasCalendar() bool\n\tSwapSysAdmin() bool\n\tIsSysAdmin() bool\n\tCheckPerms(what string, perms Perm) (ok bool, err error)\n\tCheckPermsT(what string, permstr string) (ok bool, err error)\n\tTheUser() (user PfUser)\n\tSelectedSelf() bool\n\tSelectedUser() (user PfUser)\n\tSelectedGroup() (grp PfGroup)\n\tSelectedML() (ml PfML)\n\tSelectedEmail() (email PfUserEmail)\n\tHasSelectedUser() bool\n\tHasSelectedGroup() bool\n\tHasSelectedML() bool\n\tSelectMe()\n\tSelectUser(username string, perms Perm) (err error)\n\tSelectGroup(gr_name string, perms Perm) (err error)\n\tSelectML(ml_name string, perms Perm) (err error)\n\tSelectEmail(email string) (err error)\n\tSetModOpts(opts PfModOptsI)\n\tGetModOpts() (opts interface{})\n\tPDbgf(what string, perm Perm, format string, a ...interface{})\n\tOut(txt string)\n\tOutf(format string, a ...interface{})\n\tOutLn(format string, a ...interface{})\n\tSetOutUnbuffered(obj interface{}, fun string)\n\tOutBuffered(on bool)\n\tIsBuffered() bool\n\tBuffered() (o string)\n\tGetRemote() (remote string)\n\tSetClient(clientip net.IP, remote string, ua string)\n\tGetClientIP() net.IP\n\tGetUserAgent() (string, string, string)\n\tSelectObject(obj *interface{})\n\tSelectedObject() (obj *interface{})\n\tGetLanguage() string\n\tSetLanguage(name string)\n\tGetTfunc() i18n.TranslateFunc\n\n\t// User and Group creation overrides\n\tNewUser() (user PfUser)\n\tNewUserI() (i interface{})\n\tNewGroup() (user PfGroup)\n\tNewGroupI() (i interface{})\n\n\t// Menu Overrides\n\tMenuOverride(menu *PfMenu)\n\n\t// Menu Related (menu.go)\n\tMenu(args []string, menu PfMenu) (err error)\n\tWalkMenu(args []string) (menu *PfMEntry, err error)\n\tCmd(args []string) (err error)\n\tCmdOut(cmd string, args []string) (msg string, err error)\n\tBatch(filename string) (err error)\n\n\t// Application Data\n\tSetAppData(data interface{})\n\tGetAppData() interface{}\n}\n\n// SessionClaims describe claims for a session\ntype SessionClaims struct {\n\tJWTClaims\n\tUserDesc   string `json:\"userdesc\"`\n\tIsSysAdmin bool   `json:\"issysadmin\"`\n}\n\n// PfCtxS is the default implementation of PfCtx\ntype PfCtxS struct {\n\tabort          <-chan bool        /* Abort the request */\n\tstatus         int                /* HTTP Status code */\n\treturncode     int                /* Command Line return code */\n\tloc            string             /* Command tree location */\n\toutput         string             /* Output buffer */\n\tmode_buffered  bool               /* Buffering of output in effect */\n\tuser           PfUser             /* Authenticated User */\n\tis_sysadmin    bool               /* Whether the user's sysadmin priveleges are enabled */\n\ttoken          string             /* The authentication token */\n\ttoken_claims   SessionClaims      /* Parsed Token Claims */\n\tremote         string             /* The address of the client, including X-Forwarded-For */\n\tclient_ip      net.IP             /* Client's IP addresses */\n\tua_full        string             /* The HTTP User Agent */\n\tua_browser     string             /* HTTP User Agent: Browser */\n\tua_os          string             /* HTTP User Agent: Operating System */\n\tlanguage       string             /* User's chosen language (TODO: Allow user to select it) */\n\ttfunc          i18n.TranslateFunc /* Translation function populated with current language */\n\tsel_user       PfUser             /* Selected User */\n\tsel_group      PfGroup            /* Selected Group */\n\tsel_ml         *PfML              /* Selected Mailing List */\n\tsel_email      *PfUserEmail       /* Selected User email address */\n\tsel_obj        *interface{}       /* Selected Object (ctx + struct only) */\n\tmod_opts       interface{}        /* Module Options for Messages/Wiki/Files etc */\n\tf_newuser      PfNewUserI         /* Create a new User */\n\tf_newgroup     PfNewGroupI        /* Create a new Group */\n\tf_menuoverride PfMenuI            /* Override a menu */\n\tf_appperms     PfAppPermsI        /* Application Permission Check */\n\tf_postbecome   PfPostBecomeI      /* Post Become() */\n\n\t// Unbuffered Output */\n\toutunbuf_fun string   // Function name that handles unbuffered output */\n\toutunbuf_obj ObjFuncI // Object where the function lives */\n\n\t// Database internal\n\tdb_Tx *Tx // Used for database transactions\n\n\t// Menu internal values (menu.go)\n\tmenu_walkonly bool      // Set to 'true' to indicate that only walk, do not execute; used for figuring out what arguments are needed\n\tmenu_args     []string  // Which arguments are currently requested\n\tmenu_menu     *PfMEntry // Current menu entry being attempted\n\n\t/* Application Data */\n\tappdata interface{} // Application specific data\n}\n\n// PfNewCtx allows overriding the NewCtx function, thus allowing extending PfCtx\ntype PfNewCtx func() PfCtx\n\n// NewPfCtx is used to initialize a new Pitchfork Context.\n//\n// The various arguments are all to provide the ability to replace\n// standard Pitchfork functions with application specific ones that\n// likely extends the Pitchfork functionality or that carry extra details.\n//\n// newuser is used as a function for creating new users.\n//\n// newgroup is used as a function for creating new groups.\n//\n// menuoverride is used as a function to override menu entries.\n//\n// appperms is used as a function to verify application specific permissions.\n//\n// postbecome is used as a callback after a user has changed (eg when logging in).\n//\n// All overrides are optional, and will be defaulted to the Pitchfork versions\n// when they are provided as 'nil'.\n//\n// NewPfCtx is called from the constructors of PfUI and, except for testing\n// should rarely be called directly as the context is already handed to a function.\nfunc NewPfCtx(newuser PfNewUserI, newgroup PfNewGroupI, menuoverride PfMenuI, appperms PfAppPermsI, postbecome PfPostBecomeI) PfCtx {\n\tif newuser == nil {\n\t\tnewuser = NewPfUserA\n\t}\n\n\tif newgroup == nil {\n\t\tnewgroup = NewPfGroup\n\t}\n\n\ttfunc, err := i18n.Tfunc(Config.TransDefault)\n\tif err != nil {\n\t\ttfunc = nil\n\t}\n\n\treturn &PfCtxS{f_newuser: newuser,\n\t\tf_newgroup: newgroup, f_menuoverride: menuoverride, f_appperms: appperms,\n\t\tf_postbecome: postbecome,\n\t\tlanguage:     Config.TransDefault, mode_buffered: true, tfunc: tfunc}\n}\n\n// GetAbort is used to retrieve the abort channel (as used/passed-down from the HTTP handler)\n//\n// This channel is used to indicate, by the HTTP library, that the HTTP client has\n// disconnected and that the request can be aborted as the client will never receive\n// the answer of the query.\n//\n// Used amongst others by the search infrastructure.\nfunc (ctx *PfCtxS) GetAbort() <-chan bool {\n\treturn ctx.abort\n}\n\n// SetAbort is used to set the abort channel (as used/passed-down from the HTTP handler).\n//\n// SetAbort is called from H_root() to configure the abort channel as passed down\n// from the Golang HTTP package.\nfunc (ctx *PfCtxS) SetAbort(abort <-chan bool) {\n\tctx.abort = abort\n}\n\n// GetLanguage is used to retrieve the user-selected language setting\n//\n// The returned string is in the form of a RFC2616 Accept-Language header.\n// Typically it will be 'en-us', or sometimes 'de', 'de-DE', 'de-CH' or 'es'.\nfunc (ctx *PfCtxS) GetLanguage() string {\n\treturn ctx.language\n}\n\n// SetLanguage accepts a RFC2616 style Accept-Language string\n// it then uses that information to determine the best language\n// to return.\nfunc (ctx *PfCtxS) SetLanguage(name string) {\n\tctx.language = name\n\ttfunc, err := i18n.Tfunc(name, Config.TransDefault)\n\tif err != nil {\n\t\t// XXX: Handle properly, this crashes the goproc based on invalid Accept-Language header\n\t\t// The panic might expose information to the enduser\n\t\tpanic(err.Error())\n\t}\n\tctx.tfunc = tfunc\n}\n\n// GetTfunc returns the translation function\nfunc (ctx *PfCtxS) GetTfunc() i18n.TranslateFunc {\n\treturn ctx.tfunc\n}\n\n// SetAppData can be used to set the appdata of a context.\n//\n// Typically this is used by an application's edition of a context to store\n// itself in the pitchfork context. This given that Golang does not support\n// polymorphism and thus needs a place to hide the full version of itself.\nfunc (ctx *PfCtxS) SetAppData(appdata interface{}) {\n\tctx.appdata = appdata\n}\n\n// GetAppData is used for getting application specific data inside the context.\n//\n// Typically this is used by an application's edition of a context to retrieve\n// itself from the pitchfork context. This given that Golang does not support\n// polymorphism and it needs to retrieve itself from the embedded edition of itself.\nfunc (ctx *PfCtxS) GetAppData() interface{} {\n\treturn ctx.appdata\n}\n\n// NewUser causes a new PfUser (or extended edition) to be created.\n//\n// The override for NewUser, as configured at Ctx creation time is used\n// thus allowing the application specific Ctx to be returned.\nfunc (ctx *PfCtxS) NewUser() PfUser {\n\treturn ctx.f_newuser()\n}\n\n// NewUserI is like NewUser() but returns a generic interface */\nfunc (ctx *PfCtxS) NewUserI() interface{} {\n\treturn ctx.f_newuser()\n}\n\n// NewGroup causes a new PfGroup to be created by calling the\n// application defined edition of a NewGroup function.\nfunc (ctx *PfCtxS) NewGroup() PfGroup {\n\treturn ctx.f_newgroup()\n}\n\n// NewGroupI is like NewGroup() but returns a generic interface\nfunc (ctx *PfCtxS) NewGroupI() interface{} {\n\treturn ctx.f_newgroup()\n}\n\n// MenuOverride is called before a menu is further processed,\n// allowing entries to be modified by calling the callback.\n//\n// As noted, it is an optional override.\nfunc (ctx *PfCtxS) MenuOverride(menu *PfMenu) {\n\tif ctx.f_menuoverride != nil {\n\t\tctx.f_menuoverride(ctx, menu)\n\t}\n}\n\n// SetTx is used by the database code to select the current transaction\nfunc (ctx *PfCtxS) SetTx(tx *Tx) {\n\tctx.db_Tx = tx\n}\n\n// GetTx is used by the database code to get the current transaction\nfunc (ctx *PfCtxS) GetTx() (tx *Tx) {\n\treturn ctx.db_Tx\n}\n\n// GetRemote retrieves the remote address of the user/connection.\n//\n// The address is a IPv4 or IPv6 textual representation.\nfunc (ctx *PfCtxS) GetRemote() (remote string) {\n\treturn ctx.remote\n}\n\n// SetClient is used for configuring the client IP, remote address and Full User Agent strings.\n//\n// Typically not called from an application, but from cui's SetClientIP()\n// which in turn gets called from the H_root.\n//\n// The clientip is a pre-parsed IP address and XFF-filtered hops.\n//\n// Remote contains the full IP address string (including X-Forwarded-For hops).\n//\n// Fullua contains the HTTP User-Agent header.\n//\n// This function sets the variables of the Ctx (client_ip, remote) and parses\n// the Fullua (Full User-Agent) variable, storing the details in Ctx.\nfunc (ctx *PfCtxS) SetClient(clientip net.IP, remote string, fullua string) {\n\tctx.client_ip = clientip\n\tctx.remote = remote\n\n\t/* Split the UA in several parts */\n\tua := useragent.New(fullua)\n\tctx.ua_full = fullua\n\tif ua != nil {\n\t\tctx.ua_browser, _ = ua.Browser()\n\t\tctx.ua_os = ua.OS()\n\t} else {\n\t\t/* Did not parse as it is the CLI */\n\t\tif clientip.IsLoopback() {\n\t\t\tctx.ua_browser = \"Tickly\"\n\t\t\tctx.ua_os = \"Trident\"\n\t\t} else {\n\t\t\tctx.ua_browser = \"unknown\"\n\t\t\tctx.ua_os = \"unknown\"\n\t\t}\n\t}\n}\n\n// GetClientIP is used to get the client's IP address\nfunc (ctx *PfCtxS) GetClientIP() net.IP {\n\treturn ctx.client_ip\n}\n\n// GetUserAgent is used for retrieving the parsed User Agent; see also SetClient()\nfunc (ctx *PfCtxS) GetUserAgent() (string, string, string) {\n\treturn ctx.ua_full, ctx.ua_browser, ctx.ua_os\n}\n\n// SelectObject is used by the struct code (lib/struct.go) to set the\n// object that it wants to keep track of during parsing.\nfunc (ctx *PfCtxS) SelectObject(obj *interface{}) {\n\tctx.sel_obj = obj\n}\n\n// SelectedObject is used by the struct code to retrieve\n// the object it is currently parsing.\nfunc (ctx *PfCtxS) SelectedObject() (obj *interface{}) {\n\treturn ctx.sel_obj\n}\n\n// SetModOpts allows setting the options for the wiki and file modules\nfunc (ctx *PfCtxS) SetModOpts(opts PfModOptsI) {\n\tctx.mod_opts = opts\n}\n\n// GetModOpts allows getting the options for the wiki and file modules\nfunc (ctx *PfCtxS) GetModOpts() (opts interface{}) {\n\treturn ctx.mod_opts\n}\n\n// Perm is used for storing the OR value of permissions\n//\n// Note: Keep in sync with permnames && ui/ui (convenience for all the menus there).\n//\n// It is used as a bitfield, hence multiple perms are possible by ORing them together.\n// Check access using the CheckPerms() function.\n//\n// The perms use the context's sel_{user|group|ml|*} variables to check if those permissions match.\n//\n// Being a SysAdmin overrides almost all permissions!\n//\n// Change the 'false' in PDbg to 'true' to see what permission decisions are being made.\n//\n// Application permissions are fully handled by the application.\n// See the CheckPerms function for more details.\ntype Perm uint64\n\n// PERM_* define the permissions in the system.\n//\n// Each permission tests as true when the given condition is met.\n// See the per permission desciption for what condition they test for.\n//\n// The permissions are listed from weak (NONE) to strong (NOBODY).\n//\n// Permissions can be ORed together, the strongest are tested first.\n//\n// Not all combinations will make sense. eg combining PERM_GUEST|PERM_USER\n// means that both not-loggedin and loggedin users have access, at which\n// point the check can just be replaced with PERM_NONE.\n//\n// Application permissions our application specific.\n//\n// The PERM_'s marked 'Flag' are not used for checking permissions\n// but used for modifying the behavior of a menu entry.\n\nconst (\n\tPERM_NOTHING        Perm = 0         // Nothing / empty permissions, primarily used for initialization, should not be found in code as it indicates that the Permission was not configured and thus should normally not be used\n\tPERM_NONE           Perm = 1 << iota // No permissions needed (authenticated or unauthenticated is okay), typically combined with the a Flag like PERM_HIDDEN or PERM_NOSUBS\n\tPERM_GUEST                           // Tests that the user is not authenticated: The user is a Guest of the system; does not accept authenticated sessions\n\tPERM_USER                            // Tests that the user is logged in: the user has authenticated\n\tPERM_USER_SELF                       // Tests that the selected user matches the logged in user\n\tPERM_USER_NOMINATE                   // Tests that the user can nominate the selected user\n\tPERM_USER_VIEW                       // Tests that the user can view the selected user\n\tPERM_GROUP_MEMBER                    // Tests that the selected user is an active member of the selected group that can see the group\n\tPERM_GROUP_ADMIN                     // Tests that the selected user is an Admin of the selected group\n\tPERM_GROUP_WIKI                      // Tests that the selected Group has the Wiki section enabled\n\tPERM_GROUP_FILE                      // Tests that the selected Group has the File section enabled\n\tPERM_GROUP_CALENDAR                  // Tests that the selected Group has the Calendar section enabled\n\tPERM_SYS_ADMIN                       // Tests that the user is a System Administrator\n\tPERM_SYS_ADMIN_CAN                   // Can be a System Administrator\n\tPERM_CLI                             // Tests when the CLI option is enabled in system settings\n\tPERM_API                             // Tests when the API option is enabled in system settings\n\tPERM_OAUTH                           // Tests when the OAUTH option is enabled in system settings\n\tPERM_LOOPBACK                        // Tests that the connection comes from loopback (127.0.0.1 / ::1 as the Client/Remote IP address)\n\tPERM_HIDDEN                          // Flag: The menu option is hidden\n\tPERM_NOCRUMB                         // Flag: Don't add a crumb for this menu\n\tPERM_NOSUBS                          // Flag: No sub menus for this menu entry. See the NoSubs function for more details.\n\tPERM_NOBODY                          // Absolutely nobody has access (highest priority, first checked)\n\n\t// Application permissions - defined by the application\n\tPERM_APP_0\n\tPERM_APP_1\n\tPERM_APP_2\n\tPERM_APP_3\n\tPERM_APP_4\n\tPERM_APP_5\n\tPERM_APP_6\n\tPERM_APP_7\n\tPERM_APP_8\n\tPERM_APP_9\n)\n\n// permnames contains the human readable names matching the permissions\nvar permnames []string\n\n// init is used to initialize permnames and verify that they are correct, at least in count\nfunc init() {\n\tpermnames = []string{\n\t\t\"nothing\",\n\t\t\"none\",\n\t\t\"guest\",\n\t\t\"user\",\n\t\t\"self\",\n\t\t\"user_nominate\",\n\t\t\"user_view\",\n\t\t\"group_member\",\n\t\t\"group_admin\",\n\t\t\"group_wiki\",\n\t\t\"group_file\",\n\t\t\"group_calendar\",\n\t\t\"sysadmin\",\n\t\t\"sysadmin_can\",\n\t\t\"cli\",\n\t\t\"api\",\n\t\t\"oauth\",\n\t\t\"loopback\",\n\t\t\"hidden\",\n\t\t\"nocrumb\",\n\t\t\"nosubs\",\n\t\t\"nobody\",\n\t\t\"app_0\",\n\t\t\"app_1\",\n\t\t\"app_2\",\n\t\t\"app_3\",\n\t\t\"app_4\",\n\t\t\"app_5\",\n\t\t\"app_6\",\n\t\t\"app_7\",\n\t\t\"app_9\",\n\t}\n\n\t// Verify that the correct amount of permissions is present\n\tmax := uint64(1 << uint64(len(permnames)))\n\tif max != uint64(PERM_APP_9) {\n\t\tfmt.Printf(\"Expected %d got %d\\n\", max, PERM_APP_9)\n\t\tpanic(\"Invalid permnames\")\n\t}\n}\n\n// Shortcutted commonly used HTTP error codes\nconst (\n\tStatusOK           = 200\n\tStatusUnauthorized = 401\n)\n\n// Debug is a Global Debug flag, used primarily for determining if debug messages should be output. Typically toggled by flags\nvar Debug = false\n\n// Init is the \"constructor\" for Pitchfork Contexts\nfunc (ctx *PfCtxS) Init() (err error) {\n\t// Default HTTP status\n\tctx.status = StatusOK\n\n\t// Default Shell Return Code to 0\n\tctx.returncode = 0\n\n\treturn err\n}\n\n// SetStatus can be used by a h_* function to set the status of the context.\n//\n// The status typically matches a HTTP error (eg StatusNotFound from golang HTTP library).\n//\n// The final status is flushed out during UI's Flush() time.\n//\n// The status code is tracked in lib instead of the UI layer to allow a generic\n// status code system inside Pitchfork.\nfunc (ctx *PfCtxS) SetStatus(code int) {\n\tctx.status = code\n}\n\n// GetStatus can be used to get the status of the context.\n//\n// Typically only called by UI Flush(), but in theory could be used\n// by an application/function to check the current error code too.\nfunc (ctx *PfCtxS) GetStatus() (code int) {\n\treturn ctx.status\n}\n\n// SetReturnCode is used by the CLI edition of tools to return a Shell Return Code.\nfunc (ctx *PfCtxS) SetReturnCode(rc int) {\n\tctx.returncode = rc\n}\n\n// GetReturnCode is used by the CLI edition of tools to fetch the set Shell Return Code.\n//\n// During UI Flush() this error code is fetched and when not-0 reported as X-ReturnCode.\nfunc (ctx *PfCtxS) GetReturnCode() (rc int) {\n\treturn ctx.returncode\n}\n\n// GetLoc returns where in the CLI menu system our code is located (XXX: Improve naming).\n//\n// This function is typically called by MenuOverrides so that they can determine\n// where they are and thus what they might want to change.\nfunc (ctx *PfCtxS) GetLoc() string {\n\treturn ctx.loc\n}\n\n// GetLastPart is used to get the last portion of the location (XXX: Improve naming).\nfunc (ctx *PfCtxS) GetLastPart() string {\n\tfa := strings.Split(ctx.loc, \" \")\n\treturn fa[len(fa)-1]\n}\n\n// Become can be used to become the given user.\n//\n// The context code that logs in a user uses this.\n// This can be used for a 'sudo' type mechanism as is cmd/setup/sudo.go.\n//\n// After changing users, the PostBecome function is called when configured.\n// This allows an application to for instance update state or other such\n// properties when the user changes.\n//\n// Use sparingly and after properly checking permissions to see if\n// the user is really supposed to be able to become that user.\nfunc (ctx *PfCtxS) Become(user PfUser) {\n\t// Use the details from the user\n\tctx.user = user\n\n\t// Select one-self\n\tctx.sel_user = user\n\n\t// Post Become() hook if configured\n\tif ctx.f_postbecome != nil {\n\t\tctx.f_postbecome(ctx)\n\t}\n}\n\n// GetToken retrieves the authentication token (JWT) provided by the user, if any\nfunc (ctx *PfCtxS) GetToken() (tok string) {\n\treturn ctx.token\n}\n\n// NewToken causes a new JWT websession token to be generated for loggedin users\nfunc (ctx *PfCtxS) NewToken() (err error) {\n\tif !ctx.IsLoggedIn() {\n\t\treturn errors.New(\"Not authenticated\")\n\t}\n\n\ttheuser := ctx.TheUser()\n\n\t// Set some claims\n\tctx.token_claims.UserDesc = theuser.GetFullName()\n\tctx.token_claims.IsSysAdmin = ctx.is_sysadmin\n\n\tusername := theuser.GetUserName()\n\n\t// Create the token\n\ttoken := Token_New(\"websession\", username, TOKEN_EXPIRATIONMINUTES, &ctx.token_claims)\n\n\t// Sign and get the complete encoded token as a string\n\tctx.token, err = token.Sign()\n\tif err != nil {\n\t\t// Invalid token when something went wrong\n\t\tctx.token = \"\"\n\t}\n\n\treturn\n}\n\n// LoginToken can be used to log in using a token.\n//\n// It takes a JWT encoded as a string.\n// It returns a boolean indicating if the token is going to expire soon\n// (and thus indicating that a new token should be sent out to the user)\n// and/or an error to indicate failure.\nfunc (ctx *PfCtxS) LoginToken(tok string) (expsoon bool, err error) {\n\t// No valid token\n\tctx.token = \"\"\n\n\t// Not a SysAdmin\n\tctx.is_sysadmin = false\n\n\t// Parse the provided token\n\texpsoon, err = Token_Parse(tok, \"websession\", &ctx.token_claims)\n\tif err != nil {\n\t\treturn expsoon, err\n\t}\n\n\t// Who they claim they are\n\tuser := ctx.NewUser()\n\tuser.SetUserName(ctx.token_claims.Subject)\n\tuser.SetFullName(ctx.token_claims.UserDesc)\n\tctx.is_sysadmin = ctx.token_claims.IsSysAdmin\n\n\t// Fetch the details\n\terr = user.Refresh(ctx)\n\tif err == ErrNoRows {\n\t\tctx.Dbgf(\"No such user %q\", ctx.token_claims.Subject)\n\t\treturn false, errors.New(\"No such user\")\n\t} else if err != nil {\n\t\tctx.Dbgf(\"Fetch of user %q failed: %s\", ctx.token_claims.Subject, err.Error())\n\t\treturn false, err\n\t}\n\n\t// Looking good, become the user\n\tctx.Become(user)\n\n\t// Valid Token\n\tctx.token = tok\n\n\treturn expsoon, nil\n}\n\n// Login can be used to login using a username, password\n// and optionally, when configured, a twofactor code.\n//\n// A userevent is logged when this function was succesful.\nfunc (ctx *PfCtxS) Login(username string, password string, twofactor string) (err error) {\n\t// The new user */\n\tuser := ctx.NewUser()\n\n\terr = user.CheckAuth(ctx, username, password, twofactor)\n\tif err != nil {\n\t\t/* Log the error, so that it can be looked up in the log */\n\t\tctx.Errf(\"CheckAuth(%s): %s\", username, err)\n\n\t\t/* Overwrite the error so that we do not leak too much detail */\n\t\terr = ErrLoginIncorrect\n\t\treturn\n\t}\n\n\t// Force generation of a new token\n\tctx.token = \"\"\n\n\t// Not a sysadmin till they swapadmin\n\tctx.is_sysadmin = false\n\n\tctx.Become(user)\n\n\tuserevent(ctx, \"login\")\n\treturn nil\n}\n\n// Logout can be used to log the authenticated user out of the system.\n//\n// The JWT token that was previously in use is added to the JWT Invalidated list\n// thus denying the further use of that token.\nfunc (ctx *PfCtxS) Logout() {\n\tif ctx.token != \"\" {\n\t\tJwt_invalidate(ctx.token, &ctx.token_claims)\n\t}\n\n\t/* Invalidate user + token */\n\tctx.user = nil\n\tctx.token = \"\"\n\tctx.token_claims = SessionClaims{}\n}\n\n// IsLoggedIn can be used to check if the context has a properly logged in user.\nfunc (ctx *PfCtxS) IsLoggedIn() bool {\n\tif ctx.user == nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// IsGroupMember can be used to check if the selected user\n// is a member of the selected group and whether the user\n// can see the group.\nfunc (ctx *PfCtxS) IsGroupMember() bool {\n\tif !ctx.HasSelectedUser() {\n\t\treturn false\n\t}\n\n\tif !ctx.HasSelectedGroup() {\n\t\treturn false\n\t}\n\n\tismember, _, state, err := ctx.sel_group.IsMember(ctx.user.GetUserName())\n\tif err != nil {\n\t\tctx.Log(\"IsGroupMember: \" + err.Error())\n\t\treturn false\n\t}\n\n\tif !ismember {\n\t\treturn false\n\t}\n\n\t/* Group Admins can always select users, even when blocked */\n\tif ctx.IAmGroupAdmin() {\n\t\treturn true\n\t}\n\n\t/* Normal group users, it depends on whether they can see them */\n\treturn state.can_see\n}\n\n// IAmGroupAdmin can be used to ask if the logged in user\n// is a groupadmin of the selected group.\nfunc (ctx *PfCtxS) IAmGroupAdmin() bool {\n\tif !ctx.IsLoggedIn() {\n\t\treturn false\n\t}\n\n\tif !ctx.HasSelectedGroup() {\n\t\treturn false\n\t}\n\n\tif ctx.IsSysAdmin() {\n\t\treturn true\n\t}\n\n\t_, isadmin, _, err := ctx.sel_group.IsMember(ctx.user.GetUserName())\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn isadmin\n}\n\n// IAmGroupMember can be used to check if the logged in user is a groupmember\nfunc (ctx *PfCtxS) IAmGroupMember() bool {\n\tif !ctx.IsLoggedIn() {\n\t\treturn false\n\t}\n\n\tif !ctx.HasSelectedGroup() {\n\t\treturn false\n\t}\n\n\tismember, _, _, err := ctx.sel_group.IsMember(ctx.user.GetUserName())\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn ismember\n}\n\n// GroupHasWiki can be used to check if the selected group has a wiki module enabled\nfunc (ctx *PfCtxS) GroupHasWiki() bool {\n\tif !ctx.HasSelectedGroup() {\n\t\treturn false\n\t}\n\n\treturn ctx.sel_group.HasWiki()\n}\n\n// GroupHasFile can be used to check if the selected group has a file module enabled\nfunc (ctx *PfCtxS) GroupHasFile() bool {\n\tif !ctx.HasSelectedGroup() {\n\t\treturn false\n\t}\n\n\treturn ctx.sel_group.HasFile()\n}\n\n// GroupHasCalendar can be used to check if the selected group has a calendar module enabled\nfunc (ctx *PfCtxS) GroupHasCalendar() bool {\n\tif !ctx.HasSelectedGroup() {\n\t\treturn false\n\t}\n\n\treturn ctx.sel_group.HasCalendar()\n}\n\n// SwapSysAdmin swaps a user's privilege between normal user and sysadmin.\nfunc (ctx *PfCtxS) SwapSysAdmin() bool {\n\t/* Not logged, can't be SysAdmin */\n\tif !ctx.IsLoggedIn() {\n\t\treturn false\n\t}\n\n\t/* If they cannot be one, then do not toggle either */\n\tif !ctx.TheUser().CanBeSysAdmin() {\n\t\treturn false\n\t}\n\n\t/* Toggle state: SysAdmin <> Regular */\n\tctx.is_sysadmin = !ctx.is_sysadmin\n\n\t/* Force generation of a new token */\n\tctx.token = \"\"\n\n\treturn true\n}\n\n// IsSysAdmin indicates if the current user is a sysadmin\n// and has swapped to it, see SwapSysAdmin.\n//\n// The SAR (System Administation Restrictions) are checked.\n// When the SAR is enabled/configured, one can only become/be\n// a sysadmin when coming from the correct IP address as\n// configured in th SAR list.\nfunc (ctx *PfCtxS) IsSysAdmin() bool {\n\tif !ctx.IsLoggedIn() {\n\t\treturn false\n\t}\n\n\t/* Not a SysAdmin, easy */\n\tif !ctx.is_sysadmin {\n\t\treturn false\n\t}\n\n\tsys := System_Get()\n\n\t/*\n\t * SysAdmin IP Restriction in effect?\n\t *\n\t * Loopback (127.0.0.1 / ::1) are excluded from this restriction\n\t */\n\tif sys.sar_cache == nil || ctx.client_ip.IsLoopback() {\n\t\treturn true\n\t}\n\n\t/* Check all the prefixes */\n\tfor _, n := range sys.sar_cache {\n\t\tif n.Contains(ctx.client_ip) {\n\t\t\t/* It is valid */\n\t\t\treturn true\n\t\t}\n\t}\n\n\t/* Not in the SARestrict list */\n\treturn false\n}\n\n// FromString can be used to parse a string into a Perm object.\n//\n// str can be in the formats:\n//  perm1\n//  perm1,perm2\n//  perm1,perm2,perm3\n//\n// When an unknown permission is encountered, this function will return an error.\nfunc FromString(str string) (perm Perm,err error) {\n\tstr = strings.ToLower(str)\n\n\tperm = PERM_NOTHING\n\n\tp := strings.Split(str, \",\")\n\tfor _, pm := range p {\n\t\tif pm == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tfound := false\n\t\tvar i uint\n\t\ti = 0\n\t\tfor _, n := range permnames {\n\t\t\tif pm == n {\n\t\t\t\tperm += 1 << i\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ti++\n\t\t}\n\n\t\tif !found {\n\t\t\terr = errors.New(\"Unknown permission: '\" + pm + \"'\")\n\t\t\treturn\n\t\t}\n\t\tbreak\n\t}\n\n\terr = nil\n\treturn\n}\n\n// String returns the string representation of a Perm.\n//\n// This can be used for in for instance debug output.\nfunc (perm Perm) String() (str string) {\n\n\tfor i := 0; i < len(permnames); i++ {\n\t\tp := uint64(math.Pow(float64(2), float64(i)))\n\n\t\tif uint64(perm)&p == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tif str != \"\" {\n\t\t\tstr += \",\"\n\t\t}\n\n\t\tstr += permnames[i]\n\t}\n\n\treturn str\n}\n\n/* IsPerm returns whether the provided Perm is the same Perm as given */\nfunc (perm Perm) IsPerm(perms Perm) bool {\n\treturn perms == perm\n}\n\n/* IsSet checks if the perm is in the given set of Perms */\nfunc (perm Perm) IsSet(perms Perm) bool {\n\treturn perms&perm > 0\n}\n\n// CheckPerms can verify if the given permissions string is valied for the provided Perms.\n//\n// One of multiple permissions can be specified by OR-ing the permissions together\n// thus test from least to most to see if any of them allows access.\n//\n// To debug permissions, toggle the code-level switch in PDbg and PDbgf().\n//\n// Application permissions are tested at the end when all pitchfork permissions\n// still allow it to proceed.\n//\n// The what parameter indicates the piece of code wanting to see the permissions\n// verified, this thus primarily serves as a debug help.\nfunc (ctx *PfCtxS) CheckPerms(what string, perms Perm) (ok bool, err error) {\n\t/* No error yet */\n\tsys := System_Get()\n\n\tctx.PDbgf(what, perms, \"Text: %s\", perms.String())\n\n\tif ctx.IsLoggedIn() {\n\t\tctx.PDbgf(what, perms, \"user = %s\", ctx.user.GetUserName())\n\t} else {\n\t\tctx.PDbgf(what, perms, \"user = ::NONE::\")\n\t}\n\n\tif ctx.HasSelectedUser() {\n\t\tctx.PDbgf(what, perms, \"sel_user = %s\", ctx.sel_user.GetUserName())\n\t} else {\n\t\tctx.PDbgf(what, perms, \"sel_user = ::NONE::\")\n\t}\n\n\tif ctx.HasSelectedGroup() {\n\t\tctx.PDbgf(what, perms, \"sel_group = %s\", ctx.sel_group.GetGroupName())\n\t} else {\n\t\tctx.PDbgf(what, perms, \"sel_group = ::NONE::\")\n\t}\n\n\t/* Nobody? */\n\tif perms.IsSet(PERM_NOBODY) {\n\t\tctx.PDbgf(what, perms, \"Nobody\")\n\t\treturn false, errors.New(\"Nobody is allowed\")\n\t}\n\n\t/* No permissions? */\n\tif perms.IsPerm(PERM_NOTHING) {\n\t\tctx.PDbgf(what, perms, \"Nothing\")\n\t\treturn true, nil\n\t}\n\n\t/* CLI when enabled and user is authenticated */\n\tif perms.IsSet(PERM_CLI) {\n\t\tctx.PDbgf(what, perms, \"CLI\")\n\t\tif ctx.IsLoggedIn() && sys.CLIEnabled {\n\t\t\tctx.PDbgf(what, perms, \"CLI - Enabled\")\n\t\t\treturn true, nil\n\t\t} else {\n\t\t\terr = errors.New(\"CLI is not enabled\")\n\t\t}\n\t}\n\n\t/* Loopback calls can always access the API (for tcli) */\n\tif perms.IsSet(PERM_API) {\n\t\tctx.PDbgf(what, perms, \"API\")\n\t\tif sys.APIEnabled {\n\t\t\tctx.PDbgf(what, perms, \"API - Enabled\")\n\t\t\treturn true, nil\n\t\t} else {\n\t\t\terr = errors.New(\"API is not enabled\")\n\t\t}\n\t}\n\n\t/* Is OAuth enabled? */\n\tif perms.IsSet(PERM_OAUTH) {\n\t\tctx.PDbgf(what, perms, \"OAuth\")\n\t\tif sys.OAuthEnabled {\n\t\t\tctx.PDbgf(what, perms, \"OAuth - Enabled\")\n\t\t\treturn true, nil\n\t\t} else {\n\t\t\terr = errors.New(\"OAuth is not enabled\")\n\t\t}\n\t}\n\n\t/* Loopback? */\n\tif perms.IsSet(PERM_LOOPBACK) {\n\t\tctx.PDbgf(what, perms, \"Loopback\")\n\t\tif ctx.client_ip.IsLoopback() {\n\t\t\tctx.PDbgf(what, perms, \"Is Loopback\")\n\t\t\treturn true, nil\n\t\t} else {\n\t\t\terr = errors.New(\"Not a Loopback\")\n\t\t}\n\t}\n\n\t/* User must not be authenticated */\n\tif perms.IsSet(PERM_GUEST) {\n\t\tctx.PDbgf(what, perms, \"Guest\")\n\t\tif !ctx.IsLoggedIn() {\n\t\t\tctx.PDbgf(what, perms, \"Guest - Not Logged In\")\n\t\t\treturn true, nil\n\t\t}\n\n\t\tctx.PDbgf(what, perms, \"Guest - Logged In\")\n\t\treturn false, errors.New(\"Must not be authenticated\")\n\t}\n\n\t/* User has to have selected themselves */\n\tif perms.IsSet(PERM_USER_SELF) {\n\t\tctx.PDbgf(what, perms, \"User Self\")\n\t\tif ctx.IsLoggedIn() {\n\t\t\tctx.PDbgf(what, perms, \"User Self - Logged In\")\n\t\t\tif ctx.HasSelectedUser() {\n\t\t\t\tctx.PDbgf(what, perms, \"User Self - Has selected user\")\n\t\t\t\tif ctx.sel_user.GetUserName() == ctx.user.GetUserName() {\n\t\t\t\t\t/* Passed the test */\n\t\t\t\t\tctx.PDbgf(what, perms, \"User Self - It is me\")\n\t\t\t\t\treturn true, nil\n\t\t\t\t} else {\n\t\t\t\t\tctx.PDbgf(what, perms, \"User Self - Other user\")\n\t\t\t\t\terr = errors.New(\"Different user selected\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = errors.New(\"No user selected\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = errors.New(\"Not Authenticated\")\n\t\t}\n\t}\n\n\t/* User has to have selected themselves */\n\tif perms.IsSet(PERM_USER_VIEW) {\n\t\tctx.PDbgf(what, perms, \"User View\")\n\t\tif ctx.IsLoggedIn() {\n\t\t\tctx.PDbgf(what, perms, \"User View - Logged In\")\n\t\t\tif ctx.HasSelectedUser() {\n\t\t\t\tctx.PDbgf(what, perms, \"User View - Has selected user\")\n\t\t\t\tif ctx.sel_user.GetUserName() == ctx.user.GetUserName() {\n\t\t\t\t\t/* Passed the test */\n\t\t\t\t\tctx.PDbgf(what, perms, \"User View - It is me\")\n\t\t\t\t\treturn true, nil\n\t\t\t\t} else {\n\t\t\t\t\tok, err = ctx.sel_user.SharedGroups(ctx, ctx.user)\n\t\t\t\t\tif ok {\n\t\t\t\t\t\t/* Passed the test */\n\t\t\t\t\t\tctx.PDbgf(what, perms, \"User View - It is in my group\")\n\t\t\t\t\t\treturn true, nil\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.PDbgf(what, perms, \"User View - Other user\")\n\t\t\t\t\t\terr = errors.New(\"Different user selected\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = errors.New(\"No user selected\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = errors.New(\"Not Authenticated\")\n\t\t}\n\t}\n\n\t/* User has to be a group member + Wiki enabled */\n\tif perms.IsSet(PERM_GROUP_WIKI) {\n\t\tctx.PDbgf(what, perms, \"Group Wiki?\")\n\t\tif ctx.GroupHasWiki() {\n\t\t\tctx.PDbgf(what, perms, \"HasWiki - ok\")\n\t\t\tif ctx.IsGroupMember() {\n\t\t\t\tctx.PDbgf(what, perms, \"Group member - ok\")\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t\terr = errors.New(\"Not a group member\")\n\t\t} else {\n\t\t\terr = errors.New(\"Group does not have a Wiki\")\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\t/* User has to be a group member + File enabled */\n\tif perms.IsSet(PERM_GROUP_FILE) {\n\t\tctx.PDbgf(what, perms, \"Group File?\")\n\t\tif ctx.GroupHasFile() {\n\t\t\tctx.PDbgf(what, perms, \"HasFile - ok\")\n\t\t\tif ctx.IsGroupMember() {\n\t\t\t\tctx.PDbgf(what, perms, \"Group member - ok\")\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t\terr = errors.New(\"Not a group member\")\n\t\t} else {\n\t\t\terr = errors.New(\"Group does not have a File\")\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\t/* User has to be a group member + Calendar enabled */\n\tif perms.IsSet(PERM_GROUP_CALENDAR) {\n\t\tctx.PDbgf(what, perms, \"Group Calendar?\")\n\t\tif ctx.GroupHasCalendar() {\n\t\t\tctx.PDbgf(what, perms, \"HasCalendar - ok\")\n\t\t\tif ctx.IsGroupMember() {\n\t\t\t\tctx.PDbgf(what, perms, \"Group member - ok\")\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t\terr = errors.New(\"Not a group member\")\n\t\t} else {\n\t\t\terr = errors.New(\"Group does not have a Calendar\")\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\t/* No permissions needed */\n\tif perms.IsSet(PERM_NONE) {\n\t\tctx.PDbgf(what, perms, \"None\")\n\t\t/* Always succeeds */\n\t\treturn true, nil\n\t}\n\n\t/* Everything else requires a login */\n\tif !ctx.IsLoggedIn() {\n\t\tctx.PDbgf(what, perms, \"Not Authenticated\")\n\t\terr = errors.New(\"Not authenticated\")\n\t\treturn false, err\n\t}\n\n\t/*\n\t * SysAdmin can get away with almost anything\n\t *\n\t * The perms only has the PERM_SYS_ADMIN bit set for clarity\n\t * that that one only has access for sysadmins\n\t */\n\tif ctx.IsSysAdmin() {\n\t\tctx.PDbgf(what, perms, \"SysAdmin?\")\n\t\treturn true, nil\n\t}\n\terr = errors.New(\"Not a SysAdmin\")\n\n\t/* User has to be authenticated */\n\tif perms.IsSet(PERM_USER) {\n\t\tctx.PDbgf(what, perms, \"User?\")\n\t\tif ctx.IsLoggedIn() {\n\t\t\tctx.PDbgf(what, perms, \"User - Logged In\")\n\t\t\treturn true, nil\n\t\t}\n\n\t\terr = errors.New(\"Not Authenticated\")\n\t}\n\n\t/* User has to be a group admin */\n\tif perms.IsSet(PERM_GROUP_ADMIN) {\n\t\tctx.PDbgf(what, perms, \"Group admin?\")\n\t\tif ctx.IAmGroupAdmin() {\n\t\t\tctx.PDbgf(what, perms, \"Group admin - ok\")\n\t\t\treturn true, nil\n\t\t}\n\n\t\terr = errors.New(\"Not a group admin\")\n\t}\n\n\t/* User has to be a group member */\n\tif perms.IsSet(PERM_GROUP_MEMBER) {\n\t\tctx.PDbgf(what, perms, \"Group member?\")\n\t\tif ctx.IsGroupMember() {\n\t\t\tctx.PDbgf(what, perms, \"Group member - ok\")\n\t\t\treturn true, nil\n\t\t}\n\n\t\terr = errors.New(\"Not a group member\")\n\t}\n\n\t/* User wants to nominate somebody (even themselves) */\n\tif perms.IsSet(PERM_USER_NOMINATE) {\n\t\tctx.PDbgf(what, perms, \"User Nominate\")\n\t\tif ctx.IsLoggedIn() {\n\t\t\tctx.PDbgf(what, perms, \"User Nominate - Logged In\")\n\t\t\tif ctx.HasSelectedUser() {\n\t\t\t\tctx.PDbgf(what, perms, \"User Nominate - User Selected\")\n\t\t\t\t/* Passed the test */\n\t\t\t\treturn true, nil\n\t\t\t} else {\n\t\t\t\terr = errors.New(\"No user selected\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = errors.New(\"Not Authenticated\")\n\t\t}\n\t}\n\n\t/* Can the user become a SysAdmin? */\n\tif perms.IsSet(PERM_SYS_ADMIN_CAN) {\n\t\tif ctx.IsLoggedIn() {\n\t\t\tctx.PDbgf(what, perms, \"Sys Admin Can - Logged In\")\n\t\t\tif ctx.TheUser().CanBeSysAdmin() {\n\t\t\t\tctx.PDbgf(what, perms, \"Sys Admin Can\")\n\t\t\t\t/* Passed the test */\n\t\t\t\treturn true, nil\n\t\t\t} else {\n\t\t\t\terr = errors.New(\"Can't become SysAdmin\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = errors.New(\"Not Authenticated\")\n\t\t}\n\t}\n\n\t/* Let the App Check permissions */\n\tif ctx.f_appperms != nil {\n\t\tfinal, _ok, _err := ctx.f_appperms(ctx, what, perms)\n\t\tif final {\n\t\t\treturn _ok, _err\n\t\t}\n\n\t\t/* Otherwise we ignore the result as it is not a final decision */\n\t}\n\n\tif err == nil {\n\t\t/* Should not happen */\n\t\tpanic(\"Invalid permission bits\")\n\t}\n\n\t/* Default Deny + report error */\n\treturn false, err\n}\n\n// CheckPermsT can be used to check a Textual version of permissions.\n//\n// Used when the caller has the textual representation of the permissions.\nfunc (ctx *PfCtxS) CheckPermsT(what string, permstr string) (ok bool, err error) {\n\tvar perms Perm\n\n\tperms,err = FromString(permstr)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn ctx.CheckPerms(what, perms)\n}\n\n// TheUser returns the currently selected user\nfunc (ctx *PfCtxS) TheUser() (user PfUser) {\n\t/* Return a copy, not a reference */\n\treturn ctx.user\n}\n\n// SelectedSelf checks if the logged in user and the selected user are the same.\nfunc (ctx *PfCtxS) SelectedSelf() bool {\n\treturn ctx.IsLoggedIn() &&\n\t\tctx.HasSelectedUser() &&\n\t\tctx.user.GetUserName() == ctx.sel_user.GetUserName()\n}\n\n// SelectedUser returns the selected user.\nfunc (ctx *PfCtxS) SelectedUser() (user PfUser) {\n\t/* Return a copy, not a reference */\n\treturn ctx.sel_user\n}\n\n// SelectedGroup returns the selected group.\nfunc (ctx *PfCtxS) SelectedGroup() (grp PfGroup) {\n\t/* Return a copy, not a reference */\n\treturn ctx.sel_group\n}\n\n// SelectedML returns the selected mailinglist.\nfunc (ctx *PfCtxS) SelectedML() (ml PfML) {\n\t/* Return a copy, not a reference */\n\treturn *ctx.sel_ml\n}\n\n// SelectedEmail returns the selected email address.\nfunc (ctx *PfCtxS) SelectedEmail() (email PfUserEmail) {\n\t/* Return a copy, not a reference */\n\treturn *ctx.sel_email\n}\n\n// HasSelectedUser returns whether a user was selected.\nfunc (ctx *PfCtxS) HasSelectedUser() bool {\n\treturn ctx.sel_user != nil\n}\n\n// HasSelectedGroup returns whether a group was selected.\nfunc (ctx *PfCtxS) HasSelectedGroup() bool {\n\treturn ctx.sel_group != nil\n}\n\n// HasSelectedML returns whether a mailinglist was selected.\nfunc (ctx *PfCtxS) HasSelectedML() bool {\n\treturn ctx.sel_ml != nil\n}\n\n// SelectMe caused the user to select themselves.\nfunc (ctx *PfCtxS) SelectMe() {\n\tctx.sel_user = ctx.user\n}\n\n// SelectUser selects the user if the given permissions are matched.\nfunc (ctx *PfCtxS) SelectUser(username string, perms Perm) (err error) {\n\tctx.PDbgf(\"PfCtxS::SelectUser\", perms, \"%q\", username)\n\n\t/* Nothing to select, always works */\n\tif username == \"\" {\n\t\tctx.sel_user = nil\n\t\treturn nil\n\t}\n\n\t/* Selecting own user? */\n\ttheuser := ctx.TheUser()\n\tif theuser != nil && theuser.GetUserName() == username {\n\t\t/* Re-use and pass no username to indicate no refresh */\n\t\tctx.sel_user = theuser\n\t\tusername = \"\"\n\t} else {\n\t\tctx.sel_user = ctx.NewUser()\n\t}\n\n\terr = ctx.sel_user.Select(ctx, username, perms)\n\tif err != nil {\n\t\tctx.sel_user = nil\n\t}\n\n\treturn\n}\n\n// SelectGroup selects the group, depending on the permission bits provided.\n//\n// After succesfully selecting, SelectedGroup can be used to retrieve the group.\nfunc (ctx *PfCtxS) SelectGroup(gr_name string, perms Perm) (err error) {\n\tctx.PDbgf(\"SelectGroup\", perms, \"%q\", gr_name)\n\n\t/* Nothing to select */\n\tif gr_name == \"\" {\n\t\tctx.sel_group = nil\n\t\treturn nil\n\t}\n\n\tctx.sel_group = ctx.NewGroup()\n\terr = ctx.sel_group.Select(ctx, gr_name, perms)\n\tif err != nil {\n\t\tctx.sel_group = nil\n\t}\n\n\treturn\n}\n\n// SelectML selects a mailinglist depending on the permissions of the logged in user\nfunc (ctx *PfCtxS) SelectML(ml_name string, perms Perm) (err error) {\n\tctx.PDbgf(\"SelectUserML\", perms, \"%q\", ml_name)\n\n\tif !ctx.HasSelectedGroup() {\n\t\treturn errors.New(\"No group selected\")\n\t}\n\n\t/* Nothing to select */\n\tif ml_name == \"\" {\n\t\tctx.sel_ml = nil\n\t\treturn nil\n\t}\n\n\tctx.sel_ml = NewPfML()\n\terr = ctx.sel_ml.Select(ctx, ctx.sel_group, ml_name, perms)\n\n\tif err != nil {\n\t\tctx.sel_ml = nil\n\t}\n\n\treturn\n}\n\n// SelectEmail selects an email address.\n//\n// Users can only select their own email addresses (PERM_USER_SELF).\nfunc (ctx *PfCtxS) SelectEmail(email string) (err error) {\n\tperms := PERM_USER_SELF\n\n\tctx.PDbgf(\"SelectEmail\", perms, \"%q\", email)\n\n\t/* Nothing to select */\n\tif email == \"\" {\n\t\tctx.sel_email = nil\n\t\treturn nil\n\t}\n\n\t/* Fetch email details */\n\tctx.sel_email = NewPfUserEmail()\n\terr = ctx.sel_email.Fetch(email)\n\tif err != nil {\n\t\t/* Did not work */\n\t\tctx.sel_email = nil\n\t\treturn\n\t}\n\n\t/* Check Permissions */\n\tvar ok bool\n\tok, _ = ctx.CheckPerms(\"SelectEmail\", perms)\n\tif !ok {\n\t\t/* Nope, no access */\n\t\tctx.sel_email = nil\n\t}\n\n\treturn\n}\n\n// Err allows printing error messages (syslog/stdout) with details from the context.\nfunc (ctx *PfCtxS) Err(message string) {\n\tErrA(1, message)\n}\n\n// Errf allows printing formatted error messages (syslog/stdout) with details from the context.\nfunc (ctx *PfCtxS) Errf(format string, a ...interface{}) {\n\tErrA(1, format, a...)\n}\n\n// Log allows printing log messages (syslog/stdout) with details from the context\nfunc (ctx *PfCtxS) Log(message string) {\n\tLogA(1, message)\n}\n\n// Logf allows printing formatted log messages (syslog/stdout) with details from the context\nfunc (ctx *PfCtxS) Logf(format string, a ...interface{}) {\n\tLogA(1, format, a...)\n}\n\n// Dbg allows printing debug messages (syslog/stdout) with details from the context\nfunc (ctx *PfCtxS) Dbg(message string) {\n\tDbgA(1, message)\n}\n\n// Dbgf allows printing formatted debug messages (syslog/stdout) with details from the context\nfunc (ctx *PfCtxS) Dbgf(format string, a ...interface{}) {\n\tDbgA(1, format, a...)\n}\n\n// PDbgf is used for permission debugging.\n//\n// It needs to be enabled with a Code level Debug option.\n// Change the 'false' to 'true' and every permission decision will be listed.\n// Remember: sysadmin overrules most permissions, thus test with normal user.\nfunc (ctx *PfCtxS) PDbgf(what string, perm Perm, format string, a ...interface{}) {\n\tif false {\n\t\tctx.Dbgf(\"Perms(\\\"\"+what+\"\\\"/\"+strconv.Itoa(int(perm))+\"): \"+format, a...)\n\t}\n}\n\n// Out can be used to print a line to the output for the context (CLI or HTTP).\n//\n// When buffering is disabled, the txt is directly forwarded to a special\n// direct output function.\n//\n// When buffering is enabled, the txt is accumulatd in the output buffer.\nfunc (ctx *PfCtxS) Out(txt string) {\n\tif !ctx.mode_buffered {\n\t\t/* Call the function that takes care of Direct output */\n\t\t_, err := ObjFunc(ctx.outunbuf_obj, ctx.outunbuf_fun, txt)\n\t\tif err != nil {\n\t\t\tctx.Errf(\"Unbuffered output failed: %s\", err.Error())\n\t\t}\n\t} else {\n\t\t/* Buffered output */\n\t\tctx.output += txt\n\t}\n}\n\n// Outf can be used to let the Out string be formatted first.\nfunc (ctx *PfCtxS) Outf(format string, a ...interface{}) {\n\tctx.Out(fmt.Sprintf(format, a...))\n}\n\n// OutLn ensure that the Out outputted message ends in a newline\nfunc (ctx *PfCtxS) OutLn(format string, a ...interface{}) {\n\tctx.Outf(format+\"\\n\", a...)\n}\n\n// SetOutUnbuffered causes the Out* functions to become unbuffered.\n//\n// The object and function passed in are then later used for calling\n// and acually performing the output of the txt with the Out() function.\nfunc (ctx *PfCtxS) SetOutUnbuffered(obj interface{}, fun string) {\n\tobjtrail := []interface{}{obj}\n\tok, obji := ObjHasFunc(objtrail, fun)\n\tif !ok {\n\t\tpanic(\"Unbuffered function \" + fun + \" is missing\")\n\t}\n\n\tctx.outunbuf_obj = obji\n\tctx.outunbuf_fun = fun\n}\n\n// OutBuffered causes the Out* functions to become buffered.\nfunc (ctx *PfCtxS) OutBuffered(on bool) {\n\tif !on && ctx.outunbuf_fun == \"\" {\n\t\tpanic(\"Can't enable buffered mode without unbuffered function\")\n\t}\n\n\tctx.mode_buffered = on\n}\n\n// IsBuffered can be used to check if output is being buffered or directly outputted.\nfunc (ctx *PfCtxS) IsBuffered() bool {\n\treturn ctx.mode_buffered\n}\n\n// Buffered can be used to return the buffered string.\nfunc (ctx *PfCtxS) Buffered() (o string) {\n\to = ctx.output\n\tctx.output = \"\"\n\treturn\n}\n", "// Pitchfork struct provides access functions to various ways to inspect or modify contents of structs.\npackage pitchfork\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// PTypeField wraps the relect StructField for ease of use in various Struct related functions.\ntype PTypeField struct {\n\treflect.StructField\n}\n\n// PTypeWrap simply wraps the relect.StructField into our own PTypField.\nfunc PTypeWrap(f reflect.StructField) PTypeField {\n\treturn PTypeField{f}\n}\n\n// PType is used to define the CRUD option.\ntype PType int\n\n/* CRUD */\nconst (\n\tPTYPE_CREATE PType = iota /* Create */\n\tPTYPE_READ                /* Read */\n\tPTYPE_UPDATE              /* Update */\n\tPTYPE_DELETE              /* Delete */\n)\n\n// PfType is used to get the datatype from either the pftype tag\n// or by basing it on the actual type of the field using reflection.\n//\n// PfType determines if a datatype needs to be recursed and if it\n// is a compound structure.\n//\n// If 'doignore' is set, for some types the return type is 'ignore' to\n// indicate that the field does not need to be processd.\n// This option is for instance used for set/get purposes where\n// 'note' and 'widenote' cannot be changed and thus can be ignored\n// for that purpose.\n//\n// This is primarily a helper function for other functions that\n// parse structs and thus want to adhere to the types and tags.\nfunc PfType(f reflect.StructField, v reflect.Value, doignore bool) (ttype string, dorecurse bool, compound bool) {\n\t/* Forced type */\n\tttype = f.Tag.Get(\"pftype\")\n\n\t/* Detected type */\n\tif ttype == \"\" {\n\t\t/* Always ignore functions */\n\t\tif f.Type.Kind() == reflect.Func {\n\t\t\tttype = \"ignore\"\n\t\t\treturn\n\t\t}\n\n\t\t/* When the package path is not empty, we ignore the field as it is not exported */\n\t\tif f.PkgPath != \"\" {\n\t\t\t// Dbg(\"Skipping %s (pkg: %#v) - unexported\", f.Name, f.PkgPath)\n\t\t\tttype = \"ignore\"\n\t\t\treturn\n\t\t}\n\n\t\tswitch f.Type.Kind() {\n\t\tcase reflect.String:\n\t\t\tttype = \"string\"\n\t\t\tbreak\n\n\t\tcase reflect.Bool:\n\t\t\tttype = \"bool\"\n\t\t\tbreak\n\n\t\t/* We consider everything just a number, we call it a 'int' out of convienience */\n\t\tcase reflect.Int, reflect.Int64, reflect.Float64, reflect.Uint, reflect.Uint64:\n\t\t\tttype = \"int\"\n\t\t\tbreak\n\n\t\tcase reflect.Struct:\n\t\t\tty := StructNameT(f.Type)\n\n\t\t\tswitch ty {\n\t\t\tcase \"time.Time\":\n\t\t\t\tttype = \"time\"\n\t\t\t\tbreak\n\n\t\t\tcase \"database/sql.NullString\":\n\t\t\t\tttype = \"string\"\n\t\t\t\tbreak\n\n\t\t\tcase \"database/sql.NullInt64\", \"database/sql.NullFloat64\":\n\t\t\t\tttype = \"int\"\n\t\t\t\tbreak\n\n\t\t\tcase \"database/sql.NullBool\":\n\t\t\t\tttype = \"bool\"\n\t\t\t\tbreak\n\n\t\t\tdefault:\n\t\t\t\t/* Generic struct */\n\t\t\t\tttype = \"struct\"\n\n\t\t\t\to := StructRecurse(v)\n\n\t\t\t\ttfunc := \"TreatAsString\"\n\t\t\t\tobjtrail := []interface{}{o}\n\t\t\t\tok, _ := ObjHasFunc(objtrail, tfunc)\n\t\t\t\tif ok {\n\t\t\t\t\t/* Really, it is a string, believe me */\n\t\t\t\t\tttype = \"string\"\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tbreak\n\n\t\tcase reflect.Interface:\n\t\t\tttype = \"interface\"\n\t\t\tbreak\n\n\t\tcase reflect.Slice:\n\t\t\tttype = \"slice\"\n\t\t\tbreak\n\n\t\tcase reflect.Map:\n\t\t\tttype = \"map\"\n\t\t\tbreak\n\n\t\tcase reflect.Ptr:\n\t\t\tttype = \"ptr\"\n\t\t\tbreak\n\n\t\tcase reflect.Func:\n\t\t\tttype = \"ignore\"\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\tpanic(\"Unsupported Reflection Type \" + f.Type.Kind().String() + \": \" + StructNameT(f.Type))\n\t\t}\n\t}\n\n\tif doignore {\n\t\t/* Ignore submit buttons and notes */\n\t\tif ttype == \"submit\" || ttype == \"note\" || ttype == \"widenote\" {\n\t\t\tttype = \"ignore\"\n\t\t}\n\t}\n\n\t/* Recurse if it is a interface or a generic struct */\n\tif ttype == \"interface\" || ttype == \"struct\" {\n\t\tcompound = true\n\n\t\tif ttype != \"struct\" || v.NumField() > 0 {\n\t\t\tdorecurse = true\n\t\t}\n\t}\n\n\treturn\n}\n\n// StructRecurse is used to recurse through a structure\n// this in the case it is wrapped or embedded.\n//\n// Check CanAddr() so that we do a recurse while\n// we can with ability to set, but recurse otherwise\n// in readonly version.\n//\n// This function is primarily used by other struct related functions\n// and should rarely be called otherwise.\nfunc StructRecurse(v reflect.Value) interface{} {\n\tif v.Kind() != reflect.Interface && v.CanAddr() {\n\t\treturn v.Addr().Interface()\n\t}\n\n\treturn v.Interface()\n}\n\n// StructNameT returns the name of a structure from a type (T).\n//\n// This function is primarily used by other struct related functions.\nfunc StructNameT(t reflect.Type) string {\n\tif t.Kind() == reflect.Ptr {\n\t\tt = t.Elem()\n\t}\n\n\tn := t.PkgPath() + \".\" + t.Name()\n\tif n == \".\" {\n\t\tDbgf(\"StructNameT() = %s\", n)\n\t\tpanic(\"StructNameT() could not find a name\")\n\t}\n\treturn n\n}\n\n// StructNameObj returns the name of the object (Obj).\n//\n// This function is primarily used by other struct related functions.\nfunc StructNameObj(obj interface{}) string {\n\ts, _ := StructReflect(obj)\n\tn := s.PkgPath() + \".\" + s.Name()\n\tif n == \".\" {\n\t\tDbgf(\"StructNameObj(%s) obj = %#v\", n, obj)\n\t\tpanic(\"StructNameObj() could not find a name\")\n\t}\n\treturn n\n}\n\n// StructNameObjTrail returns the full trail of objects as a name.\n//\n// This function is primarily used by other struct related functions.\nfunc StructNameObjTrail(objtrail []interface{}) (oname string) {\n\tfor _, obj := range objtrail {\n\t\tif oname != \"\" {\n\t\t\toname = oname + \"->\"\n\t\t}\n\t\toname = StructNameObj(obj) + oname\n\t}\n\n\treturn\n}\n\n// StructReflect performs reflection, getting out the type\n// and the value, dereferencing the pointer where needed.\n//\n// This function is primarily used by other struct related functions.\nfunc StructReflect(obj interface{}) (s reflect.Type, va reflect.Value) {\n\ts = reflect.TypeOf(obj)\n\n\tif s.Kind() == reflect.Ptr {\n\t\t// Dereference the pointer\n\t\ts = reflect.ValueOf(obj).Type().Elem()\n\t}\n\n\t/* Values (Indirect() takes care of pointer to structs) */\n\tva = reflect.Indirect(reflect.ValueOf(obj))\n\n\treturn s, va\n}\n\n// StructFetchFields builds a SELECT SQL query to retrieve\n// all the fields in a structure from a database\n//\n// The object passed is in parsed, each structure field in-order.\n// The table is used in the FROM query.\n// The q parameter is where the composed SQL query is returned.\n// The ifs parameter is where space for the storage of the to-be-retrieved\n// data is stored.\n//\n// A caller thus calls this with a pointer to an empty query string\n// and an empty ifs array and StructFetchFields then builds the query\n// and returns that in the query argument and in the ifs array.\n//\n// The intermediary 'ifs' is thus used for temporary storage in a way\n// that the SQL library wants to receive it.\n// It also allows for multiple objects to be queried and later stored.\n//\n// This function cooperates with the StructFetchStore function which,\n// after executing the query, can then store the result in the actual structure.\n//\n// This function is typically called from StructFetch or StructFetchMulti\n// which calls StructFetchFields and StructFetchStore.\nfunc StructFetchFields(obj interface{}, table string, q *string, ifs *[]interface{}) (err error) {\n\tfun := \"StructFetchFields() \"\n\n\ts, va := StructReflect(obj)\n\n\tif s.Kind() == reflect.Interface {\n\t\treturn StructFetchFields(StructRecurse(va), table, q, ifs)\n\t}\n\n\tfor i := 0; i < s.NumField(); i++ {\n\t\tf := s.Field(i)\n\t\tv := va.Field(i)\n\n\t\tttype, dorecurse, compound := PfType(f, v, true)\n\t\tif ttype == \"ignore\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif dorecurse {\n\t\t\terr = StructFetchFields(StructRecurse(v), table, q, ifs)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif compound {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* No tags, then ignore it */\n\t\tif f.Tag == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Column/fieldname in SQL Table */\n\t\tfname := f.Tag.Get(\"pfcol\")\n\t\tif fname == \"\" {\n\t\t\tfname = strings.ToLower(f.Name)\n\t\t}\n\n\t\t/* Custom table to take it from? */\n\t\ttname := f.Tag.Get(\"pftable\")\n\t\tif tname == \"\" {\n\t\t\ttname = table\n\t\t}\n\n\t\tfname = tname + \".\" + fname\n\n\t\tif !v.CanSet() {\n\t\t\terr = errors.New(\"Can't set field '\" + fname + \"' (\" + fun + \")\")\n\t\t\treturn\n\t\t}\n\n\t\t/* Start or continue the SELECT statement */\n\t\tif *q == \"\" {\n\t\t\t*q = \"SELECT \"\n\t\t} else {\n\t\t\t*q += \", \"\n\t\t}\n\n\t\tcoalesce := f.Tag.Get(\"coalesce\")\n\n\t\tftype := f.Type.Kind()\n\n\t\t/* Handle 'nil's in the database */\n\t\tswitch ftype {\n\t\tcase reflect.String:\n\t\t\t*q += \"COALESCE(\" + fname + \", '\" + coalesce + \"')\"\n\t\t\tbreak\n\n\t\tcase reflect.Int, reflect.Int64, reflect.Float64:\n\t\t\t*q += \"COALESCE(\" + fname + \", 0)\"\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\t/* Don't COALESCE as we do not know the type */\n\t\t\t*q += fname\n\t\t\tbreak\n\t\t}\n\n\t\tvar vr interface{}\n\n\t\tswitch ftype {\n\t\tcase reflect.String:\n\t\t\tvr = new(string)\n\t\t\tbreak\n\n\t\tcase reflect.Bool:\n\t\t\tvr = new(bool)\n\t\t\tbreak\n\n\t\tcase reflect.Int, reflect.Int64, reflect.Float64:\n\t\t\tvr = new(int64)\n\t\t\tbreak\n\n\t\tcase reflect.Struct:\n\t\t\tty := StructNameT(f.Type)\n\n\t\t\tswitch ty {\n\t\t\tcase \"time.Time\":\n\t\t\t\tvr = new(time.Time)\n\t\t\t\tbreak\n\n\t\t\tcase \"database/sql.NullString\":\n\t\t\t\tvr = new(sql.NullString)\n\t\t\t\tbreak\n\n\t\t\tcase \"database/sql.NullInt64\":\n\t\t\t\tvr = new(sql.NullInt64)\n\t\t\t\tbreak\n\n\t\t\tcase \"database/sql.NullFloat64\":\n\t\t\t\tvr = new(sql.NullFloat64)\n\t\t\t\tbreak\n\n\t\t\tcase \"database/sql.NullBool\":\n\t\t\t\tvr = new(sql.NullBool)\n\t\t\t\tbreak\n\n\t\t\tdefault:\n\t\t\t\tif ttype == \"string\" {\n\t\t\t\t\tvr = new(string)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\treturn errors.New(fun + \"Variable '\" + fname + \"' is an unknown struct: \" + ty)\n\t\t\t}\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\tvar k reflect.Kind\n\t\t\tk = f.Type.Kind()\n\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Unknown type: \" + k.String())\n\t\t}\n\n\t\t*ifs = append(*ifs, vr)\n\t}\n\n\treturn nil\n}\n\n// StructFetchStore stores the result of a StructFetchFields build query into\n// the object that is passed in.\n//\n// The obj argument represents the object we want the results to be stored in.\n// The ifs argument is the result returned from StructFetchFields, and where\n// the SQL QueryRow/QueryRows call has stored it's result.\n//\n// This function is typically called from StructFetch or StructFetchMulti\n// which calls StructFetchFields and StructFetchStore.\nfunc StructFetchStore(obj interface{}, ifs []interface{}, ifs_n *int) (err error) {\n\tfun := \"StructFetch() \"\n\n\ts, va := StructReflect(obj)\n\n\tfor i := 0; i < s.NumField(); i++ {\n\t\tf := s.Field(i)\n\t\tv := va.Field(i)\n\n\t\tttype, dorecurse, compound := PfType(f, v, true)\n\t\tif ttype == \"ignore\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif dorecurse {\n\t\t\terr = StructFetchStore(StructRecurse(v), ifs, ifs_n)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif compound {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* No tags, then ignore it */\n\t\tif f.Tag == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Column/fieldname in SQL Table */\n\t\tfname := f.Tag.Get(\"pfcol\")\n\t\tif fname == \"\" {\n\t\t\tfname = strings.ToLower(f.Name)\n\t\t}\n\n\t\tn := *ifs_n\n\n\t\tswitch f.Type.Kind() {\n\t\tcase reflect.String:\n\t\t\tv.SetString(*(ifs[n].(*string)))\n\t\t\tbreak\n\n\t\tcase reflect.Bool:\n\t\t\tv.SetBool(*(ifs[n].(*bool)))\n\t\t\tbreak\n\n\t\tcase reflect.Int, reflect.Int64:\n\t\t\tv.SetInt(*(ifs[n].(*int64)))\n\t\t\tbreak\n\n\t\tcase reflect.Float64:\n\t\t\tv.SetFloat(*(ifs[n].(*float64)))\n\t\t\tbreak\n\n\t\tcase reflect.Struct:\n\t\t\tty := StructNameT(f.Type)\n\n\t\t\tswitch ty {\n\t\t\tcase \"time.Time\":\n\t\t\t\tv.Set(reflect.ValueOf(*(ifs[n].(*time.Time))))\n\t\t\t\tbreak\n\n\t\t\tcase \"database/sql.NullString\":\n\t\t\t\tv.Set(reflect.ValueOf(*(ifs[n].(*sql.NullString))))\n\t\t\t\treturn\n\n\t\t\tcase \"database/sql.NullInt64\":\n\t\t\t\tv.Set(reflect.ValueOf(*(ifs[n].(*sql.NullInt64))))\n\t\t\t\treturn\n\n\t\t\tcase \"database/sql.NullFloat64\":\n\t\t\t\tv.Set(reflect.ValueOf(*(ifs[n].(*sql.NullFloat64))))\n\t\t\t\treturn\n\n\t\t\tcase \"database/sql.NullBool\":\n\t\t\t\tv.Set(reflect.ValueOf(*(ifs[n].(*sql.NullBool))))\n\t\t\t\treturn\n\n\t\t\tdefault:\n\t\t\t\treturn errors.New(fun + \"Variable '\" + fname + \"' is an unknown struct: \" + ty)\n\t\t\t}\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\tvar k reflect.Kind\n\t\t\tk = f.Type.Kind()\n\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Unknown type: \" + k.String())\n\t\t}\n\n\t\t/* Next Field */\n\t\tn++\n\t\t*ifs_n = n\n\t}\n\n\treturn nil\n}\n\n// StructFetchWhere allows filtering the fields returned with StructFetchFields\n//\n// StructFetch/StructFetchMulti use this to append the 'where' clause portion\n// of the SQL query.\n//\n// The starting query (qi), containing the \"SELECT <field>, <field>\" is passed in.\n// StructFetchWhere adds the FROM portion and any SQL table joins, from the join argument,\n// and then, based on the params and the andor setting creates a WHERE query.\n//\n// andor defines if the where query should be composed of AND or OR statements\n// params defines the parameters that should be verified\n// matchopts defines the way the match in the WHERE should work (LIKE, =, etc)\n// matches defines what should be matched against.\n//\n// The order argument then is additionally used for determining the order of the output.\n//\n// To illustrate the arguments:\n//\n// {qi} FROM {table} {join}\n//\n// and then followed per pair of params/matchopts/matches:\n// {andor} {params} {matchopt} {matches}\n// eg: AND param LIKE '%match%'\n//\n// appended by the {order}.\nfunc StructFetchWhere(qi string, table string, join string, andor DB_AndOr, params []string, matchopts []DB_Op, matches []interface{}, order string) (q string, vals []interface{}) {\n\tq = qi\n\n\t/* From which table */\n\tq += \" FROM \" + DB.QI(table)\n\n\tif join != \"\" {\n\t\tq += \" \" + join\n\t}\n\n\twhere := \"\"\n\tvals = nil\n\n\tfor n, p := range params {\n\t\tif where == \"\" {\n\t\t\twhere += \" WHERE \"\n\t\t} else {\n\t\t\tswitch andor {\n\t\t\tcase DB_OP_AND:\n\t\t\t\twhere += \" AND \"\n\t\t\t\tbreak\n\n\t\t\tcase DB_OP_OR:\n\t\t\t\twhere += \" OR \"\n\t\t\t\tbreak\n\n\t\t\tdefault:\n\t\t\t\tpanic(\"Invalid andor\")\n\t\t\t}\n\t\t}\n\n\t\tpp := strings.Split(p, \".\")\n\t\tif len(pp) == 2 {\n\t\t\twhere += DB.QI(pp[0]) + \".\" + DB.QI(pp[1])\n\t\t} else {\n\t\t\twhere += DB.QI(p)\n\t\t}\n\n\t\tswitch matchopts[n] {\n\t\tcase DB_OP_LIKE:\n\t\t\twhere += \" LIKE \"\n\t\t\tbreak\n\n\t\tcase DB_OP_ILIKE:\n\t\t\twhere += \" ILIKE \"\n\t\t\tbreak\n\n\t\tcase DB_OP_EQ:\n\t\t\twhere += \" = \"\n\t\t\tbreak\n\n\t\tcase DB_OP_NE:\n\t\t\twhere += \" <> \"\n\t\t\tbreak\n\n\t\tcase DB_OP_LE:\n\t\t\twhere += \" <= \"\n\t\t\tbreak\n\n\t\tcase DB_OP_GE:\n\t\t\twhere += \" >= \"\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\tpanic(\"Unsupported Match option\")\n\t\t}\n\n\t\twhere += \"$\" + strconv.Itoa(n+1)\n\t\tvals = append(vals, matches[n])\n\t}\n\n\t/* Append the WHERE portion */\n\tq += where\n\n\tq += \" \" + strings.TrimSpace(order)\n\n\treturn\n}\n\n// StructFetchMulti returns multiple objects using StructFetchFields.\n//\n// The newobject function is called to create a new object to be filled in.\n// Any type of object can be returned. These objects are returned in the objs parameter.\n//\n// See StructFetchWhere for the table/jon/andor/params/matchops/matches/order arguments.\n//\n// The limit argument can be used to add a LIMIT to the SQL query.\n// The offset argument can be used to add a OFFSET to the SQL query.\nfunc StructFetchMulti(newobject func() interface{}, table string, join string, andor DB_AndOr, params []string, matchopts []DB_Op, matches []interface{}, order string, offset int, limit int) (objs []interface{}, err error) {\n\tvar ifs []interface{} = nil\n\n\tq := \"\"\n\tobjs = nil\n\n\tobj := newobject()\n\n\terr = StructFetchFields(obj, table, &q, &ifs)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif q == \"\" {\n\t\treturn nil, errors.New(\"No fields to retrieve\")\n\t}\n\n\tq, vals := StructFetchWhere(q, table, join, andor, params, matchopts, matches, order)\n\n\tif limit != 0 {\n\t\tq += \" LIMIT \"\n\t\tDB.Q_AddArg(&q, &vals, limit)\n\t}\n\n\tif offset != 0 {\n\t\tq += \" OFFSET \"\n\t\tDB.Q_AddArg(&q, &vals, offset)\n\t}\n\n\t/* Execute the query & scan it */\n\tvar rows *Rows\n\trows, err = DB.Query(q, vals...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tdefer rows.Close()\n\n\t/* There should be one */\n\tfor rows.Next() {\n\t\terr = rows.Scan(ifs...)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\to := newobject()\n\t\tn := 0\n\n\t\terr = StructFetchStore(o, ifs, &n)\n\t\tobjs = append(objs, o)\n\t}\n\n\treturn objs, nil\n}\n\n// StructFetchA exposes extra options than the simpler StructFetch\n// it is used to fetch data from a database directly into a structure\n// based on the fields in that structure and the parameters given.\n//\n// See StructFetchWhere for the table/jon/andor/params/matchops/matches/order arguments.\n//\n// The notfoundok boolean is used to return ErrNoRows when set to true.\n// Otherwise it returns a string 'not found' error.\n// This toggle primarily exists to ease the difference between programmatically\n// calling this function, and wanting to process the ErrNoRows further or\n// wanting to return the result to the CLI or other human readable error construct.\nfunc StructFetchA(obj interface{}, table string, join string, params []string, matches []string, order string, notfoundok bool) (err error) {\n\tq := \"\"\n\n\tvar ifs []interface{} = nil\n\n\terr = StructFetchFields(obj, table, &q, &ifs)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif q == \"\" {\n\t\terr = errors.New(\"No fields to retrieve\")\n\t\treturn\n\t}\n\n\tvar matchopts []DB_Op\n\tfor _, _ = range params {\n\t\tmatchopts = append(matchopts, DB_OP_EQ)\n\t}\n\n\tvar imatches []interface{}\n\tfor _, m := range matches {\n\t\timatches = append(imatches, m)\n\t}\n\n\tq, vals := StructFetchWhere(q, table, join, DB_OP_AND, params, matchopts, imatches, order)\n\n\t/* Only want one back */\n\tq += \" LIMIT 1\"\n\n\t/* Execute the query & scan it */\n\tvar rows *Rows\n\trows, err = DB.Query(q, vals...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tdefer rows.Close()\n\n\t/* There should be one */\n\tif !rows.Next() {\n\t\tif !notfoundok {\n\t\t\terr = errors.New(\"No entry in \" + table + \" with that ID\")\n\t\t\treturn\n\t\t}\n\n\t\treturn ErrNoRows\n\t}\n\n\terr = rows.Scan(ifs...)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tn := 0\n\terr = StructFetchStore(obj, ifs, &n)\n\n\treturn\n}\n\n// StructFetch calls StructFetchA() but avoids the need to specify a few\n// parameters that are not always needed (join and ordering).\n//\n// See StructFetchA for the details to the arguments.\nfunc StructFetch(obj interface{}, table string, params []string, matches []string) (err error) {\n\treturn StructFetchA(obj, table, \"\", params, matches, \"\", false)\n}\n\n// StructOp defines what operation to perform on a structure\ntype StructOp uint\n\nconst (\n\tSTRUCTOP_SET    StructOp = iota /* Set the item */\n\tSTRUCTOP_ADD                    /* Add the item */\n\tSTRUCTOP_REMOVE                 /* Remove the item */\n)\n\n// StructFieldMod allows changing a field identified by fname to a new value.\n//\n// Set/add/remove are possible depending on datatype: set for non-slice, add/remove are slice only.\n//\n// This function is typically called through StructMod().\nfunc StructFieldMod(op StructOp, fname string, f reflect.StructField, v reflect.Value, value interface{}) (err error) {\n\tfun := \"StructFieldMod() \"\n\n\t/* What kind of object is this? */\n\tkind := f.Type.Kind()\n\n\t/* Check that this type of operand is actually allowed */\n\tswitch op {\n\tcase STRUCTOP_SET:\n\t\tif kind == reflect.Slice {\n\t\t\treturn errors.New(\"Can't 'set' a slice type: \" + StructNameT(f.Type))\n\t\t}\n\t\tbreak\n\n\tcase STRUCTOP_ADD:\n\t\tif kind != reflect.Slice {\n\t\t\treturn errors.New(\"Can't add to non-slice type: \" + StructNameT(f.Type))\n\t\t}\n\t\tbreak\n\n\tcase STRUCTOP_REMOVE:\n\t\tif kind != reflect.Slice {\n\t\t\treturn errors.New(\"Can't remove from non-slice type: \" + StructNameT(f.Type))\n\t\t}\n\t\tbreak\n\n\tdefault:\n\t\treturn errors.New(\"Unknown STRUCTOP\")\n\t}\n\n\tvo := reflect.ValueOf(value)\n\n\tswitch kind {\n\tcase reflect.String:\n\t\tv.SetString(value.(string))\n\t\treturn nil\n\n\tcase reflect.Bool:\n\t\tswitch vo.Kind() {\n\t\tcase reflect.String:\n\t\t\tv.SetBool(IsTrue(value.(string)))\n\t\t\tbreak\n\n\t\tcase reflect.Bool:\n\t\t\tv.SetBool(value.(bool))\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Unknown source type: \" + vo.Kind().String())\n\t\t}\n\t\treturn nil\n\n\tcase reflect.Int, reflect.Int64:\n\t\tswitch vo.Kind() {\n\t\tcase reflect.String:\n\t\t\tnumber, err := strconv.ParseInt(value.(string), 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid number encountered: '\" + value.(string) + \"'\")\n\t\t\t}\n\t\t\tv.SetInt(number)\n\t\t\tbreak\n\n\t\tcase reflect.Int, reflect.Int64:\n\t\t\tv.SetInt(value.(int64))\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid Type\")\n\t\t}\n\t\treturn nil\n\n\tcase reflect.Uint, reflect.Uint64:\n\t\tswitch vo.Kind() {\n\t\tcase reflect.String:\n\t\t\tnumber, err := strconv.Atoi(value.(string))\n\t\t\tif err != nil {\n\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid number encountered: '\" + value.(string) + \"'\")\n\t\t\t}\n\t\t\tv.SetUint(uint64(number))\n\t\t\tbreak\n\n\t\tcase reflect.Int, reflect.Int64:\n\t\t\tv.SetUint(value.(uint64))\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid Type\")\n\t\t}\n\t\treturn nil\n\n\tcase reflect.Float64:\n\t\tswitch vo.Kind() {\n\t\tcase reflect.String:\n\t\t\tnumber, err := strconv.ParseFloat(value.(string), 64)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid floating number encountered: '\" + value.(string) + \"'\")\n\t\t\t}\n\t\t\tv.SetFloat(number)\n\t\t\tbreak\n\n\t\tcase reflect.Float64:\n\t\t\tv.SetFloat(value.(float64))\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid Type\")\n\t\t}\n\t\treturn nil\n\n\tcase reflect.Struct:\n\t\tty := StructNameT(f.Type)\n\t\tswitch ty {\n\t\tcase \"time.Time\":\n\t\t\tvar no time.Time\n\t\t\tno, err = time.Parse(Config.TimeFormat, value.(string))\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv.Set(reflect.ValueOf(no))\n\t\t\treturn\n\n\t\tcase \"database/sql.NullString\":\n\t\t\tswitch vo.Kind() {\n\t\t\tcase reflect.String:\n\t\t\t\tno := sql.NullString{String: value.(string), Valid: true}\n\t\t\t\tv.Set(reflect.ValueOf(no))\n\t\t\t\tbreak\n\n\t\t\tdefault:\n\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid Type\")\n\t\t\t}\n\t\t\treturn\n\n\t\tcase \"database/sql.NullInt64\":\n\t\t\tswitch vo.Kind() {\n\t\t\tcase reflect.String:\n\t\t\t\tvalid := true\n\t\t\t\tvar number int64 = 0\n\t\t\t\tif value.(string) == \"\" {\n\t\t\t\t\tvalid = false\n\t\t\t\t} else {\n\t\t\t\t\tnumber, err = strconv.ParseInt(value.(string), 10, 64)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid number encountered: '\" + value.(string) + \"'\")\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tno := sql.NullInt64{Int64: number, Valid: valid}\n\t\t\t\tv.Set(reflect.ValueOf(no))\n\t\t\t\tbreak\n\n\t\t\tcase reflect.Int, reflect.Int64:\n\t\t\t\tno := ToNullInt64(value.(int64))\n\t\t\t\tv.Set(reflect.ValueOf(no))\n\t\t\t\tbreak\n\n\t\t\tdefault:\n\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid Type\")\n\t\t\t}\n\t\t\treturn\n\n\t\tcase \"database/sql.NullFloat64\":\n\t\t\tswitch vo.Kind() {\n\t\t\tcase reflect.String:\n\t\t\t\tvalid := true\n\t\t\t\tvar number float64\n\t\t\t\tif value.(string) == \"\" {\n\t\t\t\t\tvalid = false\n\t\t\t\t} else {\n\t\t\t\t\tnumber, err = strconv.ParseFloat(value.(string), 64)\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid floating number encountered: '\" + value.(string) + \"'\")\n\t\t\t\t}\n\t\t\t\tno := sql.NullFloat64{Float64: number, Valid: valid}\n\t\t\t\tv.Set(reflect.ValueOf(no))\n\t\t\t\tbreak\n\n\t\t\tcase reflect.Float64:\n\t\t\t\tno := sql.NullFloat64{Float64: value.(float64), Valid: true}\n\t\t\t\tv.Set(reflect.ValueOf(no))\n\t\t\t\tbreak\n\n\t\t\tdefault:\n\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid Type\")\n\t\t\t}\n\t\t\treturn\n\n\t\tcase \"database/sql.NullBool\":\n\t\t\tswitch vo.Kind() {\n\t\t\tcase reflect.String:\n\t\t\t\tyesno := IsTrue(value.(string))\n\t\t\t\tno := sql.NullBool{Bool: yesno, Valid: true}\n\t\t\t\tv.Set(reflect.ValueOf(no))\n\t\t\t\tbreak\n\n\t\t\tcase reflect.Bool:\n\t\t\t\tno := sql.NullBool{Bool: value.(bool), Valid: true}\n\t\t\t\tv.Set(reflect.ValueOf(no))\n\t\t\t\tbreak\n\n\t\t\tdefault:\n\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid Type\")\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\t/* Check if the object supports the Scan interface */\n\t\to := StructRecurse(v)\n\t\ttfunc := \"Scan\"\n\t\tobjtrail := []interface{}{o}\n\t\tok, obj := ObjHasFunc(objtrail, tfunc)\n\t\tif ok {\n\t\t\t/* Scan() the value in */\n\t\t\tres, err2 := ObjFunc(obj, tfunc, value)\n\t\t\tif err2 == nil {\n\t\t\t\terr2, ok := res[0].Interface().(error)\n\t\t\t\tif ok {\n\t\t\t\t\terr = err2\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\treturn errors.New(fun + \"Variable '\" + fname + \"' is an unknown struct: \" + ty)\n\n\tcase reflect.Slice:\n\t\tswitch op {\n\t\tcase STRUCTOP_ADD:\n\t\t\t/* What do we store here? */\n\t\t\tvn := v.Type().String()\n\n\t\t\tswitch vn {\n\t\t\tcase \"[]string\":\n\t\t\t\tbreak\n\n\t\t\tcase \"[]int\":\n\t\t\t\t/* Input a string or a int? */\n\t\t\t\tswitch vo.Kind() {\n\t\t\t\tcase reflect.String:\n\t\t\t\t\tnumber, err := strconv.Atoi(value.(string))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" Invalid number encountered: '\" + value.(string) + \"'\")\n\t\t\t\t\t}\n\t\t\t\t\tvo = reflect.ValueOf(number)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase reflect.Uint, reflect.Uint64:\n\t\t\t\t\tvo = reflect.ValueOf(value.(uint64))\n\t\t\t\t\tbreak\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn errors.New(fun + \" detected a unsupported type for \" + fname)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tn := reflect.Append(v, vo)\n\t\t\tv.Set(n)\n\t\t\treturn nil\n\n\t\tcase STRUCTOP_REMOVE:\n\t\t\t/* What do we store here? */\n\t\t\tvn := v.Type().String()\n\n\t\t\t/* Found it? */\n\t\t\tfound := -1\n\n\t\t\t/* First, find the item we want to remove */\n\t\t\tfor k := 0; found == -1 && k < v.Len(); k += 1 {\n\t\t\t\tswitch vn {\n\t\t\t\tcase \"[]string\":\n\t\t\t\t\tov := v.Index(k).Interface().(string)\n\t\t\t\t\tif ov == value.(string) {\n\t\t\t\t\t\tfound = k\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\n\t\t\t\tcase \"[]int\", \"[]uint64\":\n\t\t\t\t\tvar ov uint64\n\n\t\t\t\t\tswitch vn {\n\t\t\t\t\tcase \"[]int\":\n\t\t\t\t\t\tov = uint64(v.Index(k).Interface().(int))\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"[]uint64\":\n\t\t\t\t\t\tov = v.Index(k).Interface().(uint64)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn errors.New(\"Unsupported integer?\")\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Input a string or a int? */\n\t\t\t\t\tswitch vo.Kind() {\n\t\t\t\t\tcase reflect.String:\n\t\t\t\t\t\tnumber, err := strconv.Atoi(value.(string))\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn errors.New(fun + \"Variable \" + fname + \" invalid number encountered: '\" + value.(string) + \"'\")\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif uint64(number) == ov {\n\t\t\t\t\t\t\tfound = k\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase reflect.Uint:\n\t\t\t\t\t\tnumber := value.(int)\n\n\t\t\t\t\t\tif uint64(number) == ov {\n\t\t\t\t\t\t\tfound = k\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase reflect.Uint64:\n\t\t\t\t\t\tnumber := value.(uint64)\n\t\t\t\t\t\tif number == ov {\n\t\t\t\t\t\t\tfound = k\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn errors.New(fun + \" detected a unsupported type for \" + fname)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn errors.New(\"Do not support removing from slice of type \" + vn)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif found == -1 {\n\t\t\t\treturn errors.New(\"Item not found, thus cannot remove\")\n\t\t\t}\n\n\t\t\t/* Create a new slice with all elements except the found one */\n\t\t\tn := v.Slice(0, found)\n\t\t\tn = reflect.AppendSlice(n, v.Slice(found+1, v.Len()))\n\n\t\t\t/* Set the slice to the new one, which does not have the item */\n\t\t\tv.Set(n)\n\t\t\treturn nil\n\t\t}\n\n\t\t/* Handled nicer above */\n\t\tpanic(\"Cannot apply STRUCTOP_SET to a Slice\")\n\n\t/* TODO support reflect.Map */\n\n\tdefault:\n\t\tvar k reflect.Kind\n\t\tk = f.Type.Kind()\n\t\treturn errors.New(fun + \"Variable \" + fname + \" Unknown type: \" + k.String())\n\t}\n}\n\n// structModA modifies a single field.\n//\n// This is called by StructMod, recursively to be able to support nested structs.\nfunc StructModA(op StructOp, obj interface{}, field string, value interface{}) (done bool, err error) {\n\tfun := \"StructMod() \"\n\n\tdone = false\n\n\tfield = strings.ToLower(field)\n\n\ts, va := StructReflect(obj)\n\n\tfor i := 0; i < s.NumField(); i++ {\n\t\tf := s.Field(i)\n\t\tv := va.Field(i)\n\n\t\tttype, dorecurse, compound := PfType(f, v, true)\n\t\tif ttype == \"ignore\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif dorecurse {\n\t\t\tdone, err = StructModA(op, StructRecurse(v), field, value)\n\t\t\tif done || err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif compound {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* No tags, then ignore it */\n\t\tif f.Tag == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Column/fieldname in SQL Table */\n\t\tfname := f.Tag.Get(\"pfcol\")\n\t\tif fname == \"\" {\n\t\t\tfname = strings.ToLower(f.Name)\n\t\t}\n\n\t\t/* Not this field? */\n\t\tif fname != field {\n\t\t\tcontinue\n\t\t}\n\n\t\tif !v.CanSet() {\n\t\t\terr = errors.New(fun + \"Can't set field '\" + fname + \"'\")\n\t\t\treturn\n\t\t}\n\n\t\tdone = true\n\t\terr = StructFieldMod(op, fname, f, v, value)\n\t\treturn\n\t}\n\n\treturn\n}\n\n// StructMod modifies a single field of a object.\n//\n// Given the object obj, it finds the 'field' in the structure and sets it to the given value.\n//\n// ErrNoRows is returned when no such field was found.\n// Other errors, eg permission errors or inability to set a field can also be returned.\n// An error of nil is returned if the change of the value succeeded.\nfunc StructMod(op StructOp, obj interface{}, field string, value interface{}) (err error) {\n\tdone, err := StructModA(op, obj, field, value)\n\tif err == nil && !done {\n\t\terr = ErrNoRows\n\t\treturn\n\t}\n\n\treturn\n}\n\n// structVarsA is the recursive portion of StructVars and thus only called by that function\nfunc StructVars(ctx PfCtx, obj interface{}, ptype PType, doignore bool) (vars map[string]string, err error) {\n\tobjtrail := []interface{}{}\n\tvars = make(map[string]string)\n\terr = StructVarsA(ctx, objtrail, obj, ptype, doignore, vars)\n\treturn vars, err\n}\n\n// StructVars returns all fields in a struct that can be retrieved or modified, returning a map of strings.\n//\n// StructVars takes an object to inspect and a ptype indicating what permissions the field should satisfy for them to be included.\n//\n// The map consists out of the key being the fieldname and the value being the ToString()'d value of the field.\n//\n// Permissions are tested against the provided ptype and the context.\nfunc StructVarsA(ctx PfCtx, objtrail []interface{}, obj interface{}, ptype PType, doignore bool, vars map[string]string) (err error) {\n\ts, va := StructReflect(obj)\n\n\tobjtrail = append([]interface{}{obj}, objtrail...)\n\n\tfor i := 0; i < s.NumField(); i++ {\n\t\tf := s.Field(i)\n\t\tv := va.Field(i)\n\n\t\t// ctx.Dbgf(\"StructVars: %s [%s]\", f.Name, f.Type.Kind().String())\n\n\t\tttype, dorecurse, compound := PfType(f, v, true)\n\t\tif ttype == \"ignore\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif dorecurse {\n\t\t\terr = StructVarsA(ctx, objtrail, StructRecurse(v), ptype, doignore, vars)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif compound {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* No tags, then ignore it */\n\t\tif f.Tag == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Column/fieldname in SQL Table */\n\t\tfname := f.Tag.Get(\"pfcol\")\n\t\tif fname == \"\" {\n\t\t\tfname = strings.ToLower(f.Name)\n\t\t}\n\n\t\tvar ok bool\n\n\t\tok, _, err = StructPermCheck(ctx, ptype, objtrail, PTypeWrap(f))\n\t\t// ctx.Dbgf(\"StructVars: %s - permcheck: %s, err: %v\", f.Name, YesNo(ok), err)\n\t\tif err != nil {\n\t\t\tskipfailperm := f.Tag.Get(\"pfskipfailperm\")\n\t\t\tif skipfailperm == \"\" {\n\t\t\t\tctx.Dbgf(\"StructVars: %s - permcheck: %s, err: %s\", f.Name, YesNo(ok), err.Error())\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif !ok && ttype != \"ptr\" && ttype != \"struct\" {\n\t\t\t// oname := StructNameObjTrail(objtrail)\n\t\t\t// ctx.Dbg(\"NOT SHOWING: field = %s, ttype = %s\", oname+\":\"+fname, ttype)\n\t\t\tcontinue\n\t\t}\n\n\t\tvars[fname] = ttype\n\t}\n\n\terr = nil\n\treturn\n}\n\n// StructDetails_Options defines options to apply when checking StructDetails\ntype StructDetails_Options int\n\nconst (\n\tSD_None                               = 0         /* No Options */\n\tSD_Perms_Check  StructDetails_Options = 0 << iota /* Check Permissions */\n\tSD_Perms_Ignore                                   /* Ignore Permissions */\n\tSD_Tags_Require                                   /* Require Tags */\n\tSD_Tags_Ignore                                    /* Ignore Tags */\n)\n\n// structDetailsA is the recursive portion of StructDetails, see that function for more details\nfunc StructDetailsA(ctx PfCtx, obj interface{}, field string, opts StructDetails_Options) (ftype string, fname string, fvalue string, err error) {\n\tcheckperms := false\n\tif opts&SD_Perms_Check > 0 {\n\t\tcheckperms = true\n\t}\n\n\trequiretags := false\n\tif opts&SD_Tags_Require > 0 {\n\t\trequiretags = true\n\t}\n\n\ts, va := StructReflect(obj)\n\n\tfor i := 0; i < s.NumField(); i++ {\n\t\tf := s.Field(i)\n\t\tv := va.Field(i)\n\n\t\t/* Column/fieldname in SQL Table */\n\t\tfname = f.Tag.Get(\"pfcol\")\n\t\tif fname == \"\" {\n\t\t\tfname = strings.ToLower(f.Name)\n\t\t}\n\n\t\t/* Ignore the field completely? */\n\t\tttype, dorecurse, compound := PfType(f, v, true)\n\t\tif ttype == \"ignore\" {\n\t\t\tif fname == field {\n\t\t\t\treturn \"ignore\", \"\", \"\", errors.New(\"Field is ignored\")\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif dorecurse {\n\t\t\tftype, fname, fvalue, err = StructDetailsA(ctx, StructRecurse(v), field, opts)\n\t\t\tif ftype != \"\" || err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif compound {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* No tags, then ignore it */\n\t\tif requiretags && f.Tag == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Wrong field, skip it */\n\t\tif fname != field {\n\t\t\tcontinue\n\t\t}\n\n\t\tif checkperms {\n\t\t\tok := true\n\t\t\tpermstr := f.Tag.Get(\"pfset\")\n\n\t\t\tok, err = ctx.CheckPermsT(\"StructDetails(\"+fname+\")\", permstr)\n\t\t\tif !ok {\n\t\t\t\treturn \"\", \"\", \"\", err\n\t\t\t}\n\t\t}\n\n\t\treturn \"string\", fname, ToString(v.Interface()), nil\n\t}\n\n\treturn \"\", \"\", \"\", nil\n}\n\n// StructDetails returns the details of a structure's field.\n//\n// It determines the type of the field and the string value of the field.\n//\n// The opts can be used to influence if permission checking needs to be done\n// and if tags are required to be present for the field to be checked.\nfunc StructDetails(ctx PfCtx, obj interface{}, field string, opts StructDetails_Options) (ftype string, fname string, fvalue string, err error) {\n\tfield = strings.ToLower(field)\n\n\tftype, fname, fvalue, err = StructDetailsA(ctx, obj, field, opts)\n\tif err == nil && ftype == \"\" {\n\t\treturn \"unknown\", \"\", \"\", errors.New(\"Unknown Field: \" + field + \" (StructDetails)\")\n\t}\n\n\treturn\n}\n\n// structTagA is the recursive portion of StructTag, see that function for details\nfunc StructTagA(obj interface{}, field string, tag string) (val string, err error) {\n\ts, va := StructReflect(obj)\n\n\tfor i := 0; i < s.NumField(); i++ {\n\t\tf := s.Field(i)\n\t\tv := va.Field(i)\n\n\t\tttype, dorecurse, compound := PfType(f, v, true)\n\t\tif ttype == \"ignore\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif dorecurse {\n\t\t\tval, err = StructTagA(StructRecurse(v), field, tag)\n\t\t\tif err != nil || val != \"\" {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif compound {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* No tags, then ignore it */\n\t\tif f.Tag == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Column/fieldname in SQL Table */\n\t\tfname := f.Tag.Get(\"pfcol\")\n\t\tif fname == \"\" {\n\t\t\tfname = strings.ToLower(f.Name)\n\t\t}\n\n\t\tif fname != field {\n\t\t\tcontinue\n\t\t}\n\n\t\tval = f.Tag.Get(tag)\n\t\treturn\n\t}\n\n\treturn \"\", nil\n}\n\n// StructTag retrieves the requested tag from a field in a structure.\n//\n// Any type of object can be provided, it will be recursed incase of embedded structs.\n//\n// The field indicates the name of the structure's field.\n// The tag indicates which tag to get for that field.\n//\n// The value returned is the content of the tag for the requested field.\nfunc StructTag(obj interface{}, field string, tag string) (val string, err error) {\n\tfield = strings.ToLower(field)\n\n\tval, err = StructTagA(obj, field, tag)\n\tif err == nil && val == \"\" {\n\t\treturn \"\", errors.New(\"Unknown Field: \" + field + \" (StructTag)\")\n\t}\n\n\treturn\n}\n\n// structMenuA is the recursive portion of StructMenu\n//\n// See StructMenu for more details.\nfunc StructMenuA(ctx PfCtx, subjects []string, objtrail []interface{}, obj interface{}, onlyslices bool, fun PfFunc, isedit bool, nargs int) (menu PfMenu, err error) {\n\t/* Prepend this object to the trail */\n\tobjtrail = append([]interface{}{obj}, objtrail...)\n\n\ts, va := StructReflect(obj)\n\n\tfor i := 0; i < s.NumField(); i++ {\n\t\tf := s.Field(i)\n\t\tv := va.Field(i)\n\n\t\tttype, dorecurse, compound := PfType(f, v, true)\n\t\tif ttype == \"ignore\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif dorecurse {\n\t\t\tm, err := StructMenuA(ctx, subjects, objtrail, StructRecurse(v), onlyslices, fun, isedit, nargs)\n\t\t\tif err != nil {\n\t\t\t\treturn PfMenu{}, err\n\t\t\t}\n\n\t\t\tmenu.Add(m.M...)\n\t\t}\n\n\t\tif compound {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* No tags, then ignore it */\n\t\tif f.Tag == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Ignore slices when we don't want them, others if we only want slices */\n\t\tif (ttype == \"slice\" && onlyslices == false) || (ttype != \"slice\" && onlyslices == true) {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Column/fieldname in SQL Table */\n\t\tfname := f.Tag.Get(\"pfcol\")\n\t\tif fname == \"\" {\n\t\t\tfname = strings.ToLower(f.Name)\n\t\t}\n\n\t\t/* Options from the Tag of the structure */\n\t\tlabel := f.Tag.Get(\"label\")\n\t\tif label != \"\" {\n\t\t\t/* Only translate when the label is specifically set */\n\t\t\tlabel = TranslateObj(ctx, objtrail, label)\n\t\t} else {\n\t\t\tlabel = f.Name\n\t\t}\n\n\t\thint := f.Tag.Get(\"hint\")\n\t\tif hint != \"\" {\n\t\t\t/* Only translate when the hint is specifically set */\n\t\t\thint = TranslateObj(ctx, objtrail, hint)\n\t\t}\n\n\t\t/* Default description to the label */\n\t\tdesc := label\n\n\t\t/* Append the hint to the description */\n\t\tif hint != \"\" {\n\t\t\tdesc += \" - \" + hint\n\t\t}\n\n\t\t/* Ignore the field completely? */\n\t\tignore := f.Tag.Get(\"pfignore\")\n\t\tif ignore == \"yes\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tvar perms Perm\n\t\tvar tag string\n\n\t\tif isedit {\n\t\t\ttag = \"pfset\"\n\t\t} else {\n\t\t\ttag = \"pfget\"\n\t\t}\n\n\t\tset := f.Tag.Get(tag)\n\t\tperms,err = FromString(set)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tif perms == PERM_NOTHING {\n\t\t\t/* Default permissions is to allow getting/setting of anything */\n\t\t\tperms = PERM_NONE\n\t\t}\n\n\t\tvar ok bool\n\t\tok, _ = ctx.CheckPerms(\"StructMenu(\"+fname+\")\", perms)\n\t\tif !ok {\n\t\t\t/* Also change to 'ok, err' above */\n\t\t\t/* Dbgf(\"StructMenu(%s) Skipping (tag: %s), err: %s\", fname, tag, err.Error()) */\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Initial subjects */\n\t\tsubj := subjects\n\n\t\tif isedit {\n\t\t\totype := \"\"\n\n\t\t\tswitch ttype {\n\t\t\tcase \"bool\":\n\t\t\t\totype = \"#bool\"\n\t\t\t\tbreak\n\n\t\t\tcase \"int\":\n\t\t\t\totype = \"#int\"\n\t\t\t\tbreak\n\n\t\t\tcase \"file\":\n\t\t\t\totype = \"#file\"\n\t\t\t\totype += \"#\" + f.Tag.Get(\"pfmaximagesize\")\n\n\t\t\t\tb64 := f.Tag.Get(\"pfb64\")\n\t\t\t\totype += \"#\" + NormalizeBoolean(b64)\n\t\t\t\tbreak\n\n\t\t\tcase \"string\", \"text\", \"tel\":\n\t\t\t\totype = \"#string\"\n\t\t\t\tbreak\n\n\t\t\tcase \"time\":\n\t\t\t\totype = \"#time\"\n\t\t\t\tbreak\n\n\t\t\tcase \"struct\":\n\t\t\t\tbreak\n\n\t\t\tcase \"slice\":\n\t\t\t\tbreak\n\n\t\t\tcase \"map\":\n\t\t\t\tbreak\n\n\t\t\tcase \"ptr\":\n\t\t\t\tbreak\n\n\t\t\tdefault:\n\t\t\t\tpanic(\"Unknown Type for field \" + fname + \", type \" + ttype)\n\t\t\t}\n\n\t\t\tsubj = append(subj, fname+otype)\n\t\t}\n\n\t\tvar m PfMEntry\n\t\tm.Cmd = fname\n\t\tm.Fun = fun\n\t\tm.Args_min = nargs\n\t\tm.Args_max = nargs\n\t\tm.Args = subj\n\t\tm.Perms = perms\n\t\tm.Desc = desc\n\n\t\tmenu.Add(m)\n\t}\n\n\treturn menu, nil\n}\n\n// StructMenu can create \"get\", \"set\", \"add\" and \"remove\" CLI menus\n// from a given structure.\n//\n// The subjects parameter indicates the field(s) that indicates what\n// should be provided as an argument to select that specific object.\n//\n// The object is an example object (just the structure, no values needed)\n// that has a set of fields with tags. The tags are used to retrieve the\n// labels and descriptions for the field, but also the permissions needed\n// to configure that field.\n//\n// onlyslices is used to switch between a 'get'/'set' menu and a 'add'/'remove' menu.\n// When onlyslices is true only fields that are slices are listed, these will\n// require an 'add'/'remove' construct instead of being able to be directly 'set' or 'get'.\n//\n// When a function is provided, the menu becomes a 'set' or add/remove menu (for slices).\n// When no function is provided the resulting menu is a 'get' menu.\n// The permissions for set/get are adhered to.\n//\n// See the example for a minimal example. The User portion of Pitchfork makes a good\n// full example on how this code is used, see lib/user.go user_get/user_set etc.\nfunc StructMenu(ctx PfCtx, subjects []string, obj interface{}, onlyslices bool, fun PfFunc) (menu PfMenu, err error) {\n\tvar isedit bool\n\n\t/* Select the Object */\n\tctx.SelectObject(&obj)\n\n\t/* Number of subjects */\n\tnargs := len(subjects)\n\n\t/* Edit or not? */\n\tif fun != nil {\n\t\tisedit = true\n\n\t\t/* Edit's require one more argument */\n\t\tnargs++\n\t} else {\n\t\tfun = structGet\n\t}\n\n\t/* Recursive call */\n\tobjtrail := []interface{}{}\n\treturn StructMenuA(ctx, subjects, objtrail, obj, onlyslices, fun, isedit, nargs)\n}\n\n// structGetA is the recursive part of StructGet.\nfunc structGetA(ctx PfCtx, obj interface{}, field string) (done bool, err error) {\n\ts, va := StructReflect(obj)\n\n\tdone = false\n\n\tif s.Kind() == reflect.Interface {\n\t\treturn structGetA(ctx, StructRecurse(va), field)\n\t}\n\n\tif s.Kind() != reflect.Struct {\n\t\terr = errors.New(\"Error: parameter is not a struct/interface but \" + s.String() + \" (structGet)\")\n\t\treturn\n\t}\n\n\tfor i := 0; i < s.NumField(); i++ {\n\t\tf := s.Field(i)\n\t\tv := va.Field(i)\n\n\t\tttype, dorecurse, compound := PfType(f, v, true)\n\t\tif ttype == \"ignore\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif dorecurse {\n\t\t\tdone, err = structGetA(ctx, StructRecurse(v), field)\n\t\t\tif done || err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif compound {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* No tags, then ignore it */\n\t\tif f.Tag == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Column/fieldname in SQL Table */\n\t\tfname := f.Tag.Get(\"pfcol\")\n\t\tif fname == \"\" {\n\t\t\tfname = strings.ToLower(f.Name)\n\t\t}\n\n\t\t/* Wrong field -> next! */\n\t\tif fname != field {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* Ignore the field completely? */\n\t\tignore := f.Tag.Get(\"pfignore\")\n\t\tif ignore == \"yes\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t/*\n\t\t * Note: structGet does not check permissions,\n\t\t * it is only used by StructMenu() which does\n\t\t * check for permissions\n\t\t */\n\t\tstr := ToString(v.Interface())\n\t\tctx.OutLn(str)\n\n\t\tdone = true\n\t\terr = nil\n\t\treturn\n\t}\n\n\treturn\n}\n\n// Create a \"get\" menu from a struct -- helper function of StructMenu.\nfunc structGet(ctx PfCtx, args []string) (err error) {\n\tobj := ctx.SelectedObject()\n\n\tif obj == nil {\n\t\treturn errors.New(\"No object selected\")\n\t}\n\n\tfield := ctx.GetLastPart()\n\n\tdone, err := structGetA(ctx, obj, field)\n\tif err == nil && !done {\n\t\terr = errors.New(\"Unknown property\")\n\t}\n\n\treturn\n}\n\n// ToString converts any type of object to a string representation.\nfunc ToString(v interface{}) (str string) {\n\ts, _ := StructReflect(v)\n\n\tswitch s.Kind() {\n\n\tcase reflect.String:\n\t\treturn v.(string)\n\n\tcase reflect.Bool:\n\t\treturn YesNo(v.(bool))\n\n\tcase reflect.Int:\n\t\treturn strconv.Itoa(v.(int))\n\n\tcase reflect.Uint:\n\t\treturn strconv.FormatUint(uint64(v.(uint)), 10)\n\n\tcase reflect.Int64:\n\t\treturn strconv.FormatInt(v.(int64), 10)\n\n\tcase reflect.Uint64:\n\t\treturn strconv.FormatUint(v.(uint64), 10)\n\n\tcase reflect.Float64:\n\t\treturn strconv.FormatFloat(v.(float64), 'E', -1, 64)\n\n\tcase reflect.Struct:\n\t\tty := StructNameT(s)\n\n\t\tswitch ty {\n\t\tcase \"time.Time\":\n\t\t\tno := v.(time.Time)\n\t\t\treturn no.Format(Config.TimeFormat)\n\n\t\tcase \"database/sql.NullString\":\n\t\t\tno := v.(sql.NullString)\n\t\t\tif !no.Valid {\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\treturn ToString(no.String)\n\n\t\tcase \"database/sql.NullInt64\":\n\t\t\tno := v.(sql.NullInt64)\n\t\t\tif !no.Valid {\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\treturn ToString(no.Int64)\n\n\t\tcase \"database/sql.NullFloat64\":\n\t\t\tno := v.(sql.NullFloat64)\n\t\t\tif !no.Valid {\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\treturn ToString(no.Float64)\n\n\t\tcase \"database/sql.NullBool\":\n\t\t\tno := v.(sql.NullBool)\n\t\t\tif !no.Valid {\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\treturn ToString(no.Bool)\n\n\t\tdefault:\n\t\t\t/* Try if the object has a String() function */\n\t\t\ttfunc := \"String\"\n\t\t\tobjtrail := []interface{}{v}\n\t\t\tok, obj := ObjHasFunc(objtrail, tfunc)\n\t\t\tif ok {\n\t\t\t\ts, err := ObjFuncStr(obj, tfunc)\n\t\t\t\tif err == nil {\n\t\t\t\t\treturn s\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpanic(\"ToString() Unhandled Struct Type '\" + ty + \"' : \" + s.String())\n\t\t}\n\t}\n\n\tpanic(\"ToString() Unhandled Type: \" + s.String())\n}\n\n// ObjFuncI retains a object.\ntype ObjFuncI struct {\n\tobj interface{}\n}\n\n// ObjHasFunc is used to determine of an object has the given function,\n// returning the (embedded) object that has the function\n//\n// An objecttrail consisting of one or more objects is passed in, thus\n// allowing a function to be found in a nested set of objects.\n//\n// This call should be used before ObjFunc to ensure the function\n// has the given object, and to select the correct object.\nfunc ObjHasFunc(objtrail []interface{}, fun string) (ok bool, obj ObjFuncI) {\n\tok = false\n\n\tfor _, ob := range objtrail {\n\t\to := reflect.ValueOf(ob)\n\n\t\tif o.IsValid() {\n\t\t\tf := o.MethodByName(fun)\n\t\t\tif f.IsValid() {\n\t\t\t\tok = true\n\t\t\t\tobj.obj = ob\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tErrf(\"Not a valid object: %#v\", obj)\n\t\t}\n\t}\n\n\treturn\n}\n\n// ObjFunc calls, when available, a function in an object and returns it's result\n//\n// The 'fun' is retrieved from the given object, as typically found with ObjHasFunc.\n// The function is then verified to be able to accept the parameters specified by params.\n// And the function is then called dynamically.\n//\n// One major use-case is the Translate function of objects, where we typically do\n// not know what object we will be calling that function on.\nfunc ObjFunc(obj ObjFuncI, fun string, params ...interface{}) (result []reflect.Value, err error) {\n\tresult = nil\n\terr = nil\n\n\to := reflect.ValueOf(obj.obj)\n\tif !o.IsValid() {\n\t\terr = errors.New(\"Not a valid object\")\n\t\treturn\n\t}\n\n\tf := o.MethodByName(fun)\n\tif !f.IsValid() {\n\t\terr = errors.New(\"Unknown Function \" + fun)\n\t\treturn\n\t}\n\n\tpnum := f.Type().NumIn()\n\tif (f.Type().IsVariadic() && len(params) < pnum) || (!f.Type().IsVariadic() && len(params) != pnum) {\n\t\tvtxt := \"\"\n\t\tif f.Type().IsVariadic() {\n\t\t\tvtxt = \" [note: variadic]\"\n\t\t}\n\t\terr = errors.New(\"Wrong amount of parameters, got: \" + strconv.Itoa(len(params)) + \", need: \" + strconv.Itoa(pnum) + vtxt)\n\t\tpanic(\"Need more\")\n\t}\n\n\tin := make([]reflect.Value, len(params))\n\n\tfor k, param := range params {\n\t\t/* Avoid a null Value */\n\t\tif param == nil {\n\t\t\tin[k] = reflect.ValueOf(&param).Elem()\n\t\t} else {\n\t\t\tin[k] = reflect.ValueOf(param)\n\t\t}\n\t}\n\n\tresult = f.Call(in)\n\treturn\n}\n\n// ObjFuncIface calls a function of an object and returns the result of an interface.\n//\n// See ObjFunc for more details on the parameters.\nfunc ObjFuncIface(obj ObjFuncI, fun string, params ...interface{}) (iface interface{}, err error) {\n\tres, err := ObjFunc(obj, fun, params...)\n\n\tif err == nil {\n\t\tiface = res[0].Interface()\n\t} else {\n\t\tiface = nil\n\t}\n\n\treturn\n}\n\n// ObjFuncStr calls a function of an object and returns a string.\n//\n// When the returned type of the called function is not a string,\n// this code will return a string indicating that in the string.\n// Similary the string will be filled with a notion that the call failed.\n// Next to having a non-nil error return.\n//\n// See ObjFunc for more details on the parameters.\nfunc ObjFuncStr(obj ObjFuncI, fun string, params ...interface{}) (str string, err error) {\n\tres, err := ObjFunc(obj, fun, params...)\n\n\tif err == nil {\n\t\tif res[0].Kind() == reflect.String {\n\t\t\tstr = res[0].String()\n\t\t} else {\n\t\t\tstr = fun + \"()-not-a-string\"\n\t\t}\n\t} else {\n\t\tstr = fun + \"()-failed\"\n\t}\n\n\treturn\n}\n\n// objPermCheck calls custom PermCheck function on an object and determines\n// if one has access and is allowed to edit or not.\n//\n// The ptype is used for the permission check to determine if read or write access is needed.\n// Per-application permissions could be more strict and be full CRUD-style.\n//\n// The return of 'ok' indicates that it is allowed to access the field.\n// The allowedit indicates if the field is allowed to be edited/modified.\n// The error indicates whether anything failed, nil indicates success.\n//\n// This function is used by StructPermCheck.\nfunc ObjPermCheck(ctx PfCtx, obj ObjFuncI, ptype PType, f PTypeField) (ok bool, allowedit bool, err error) {\n\tres, err := ObjFunc(obj, \"PermCheck\", ctx, ptype, f)\n\n\tif err == nil {\n\t\tvar varok bool\n\n\t\tok = res[0].Interface().(bool)\n\t\tallowedit = res[1].Interface().(bool)\n\t\terr, varok = res[2].Interface().(error)\n\t\tif !varok {\n\t\t\terr = nil\n\t\t}\n\t} else {\n\t\tok = false\n\t\tallowedit = false\n\t}\n\n\treturn\n}\n\n// StructPermCheck checks the permissions of a struct,\n// and determines if one has acccess and is allowed to edit.\n//\n// The ptype allows specifying of CRUD-style (Create/Read/Update/Delete) permissions to check for.\n// The objtrail is passed in, to allow a surrounding object to be used for Permission checking.\n// The PermCheck function of the first object in the trail is used for permission checks next to\n// the pitchfork pfget/pfset permissions.\n//\n// The f parameter is the field we are checking permissions for.\n//\n// The return of 'ok' indicates that it is allowed to access the field.\n// The allowedit indicates if the field is allowed to be edited/modified.\n// The error indicates whether anything failed, nil indicates success.\nfunc StructPermCheck(ctx PfCtx, ptype PType, objtrail []interface{}, f PTypeField) (ok bool, allowedit bool, err error) {\n\tswitch ptype {\n\tcase PTYPE_CREATE, PTYPE_UPDATE:\n\t\tallowedit = true\n\t\tbreak\n\n\tcase PTYPE_READ, PTYPE_DELETE:\n\t\tallowedit = false\n\t\tbreak\n\n\tdefault:\n\t\tpanic(\"Unknown ptype\")\n\t}\n\n\t/* Check Application specific permissions */\n\tapp_perms, obj := ObjHasFunc(objtrail, \"PermCheck\")\n\tif app_perms {\n\t\tok, allowedit, err = ObjPermCheck(ctx, obj, ptype, f)\n\n\t\tif err == nil && !ok && allowedit {\n\t\t\t/* Retry in read mode */\n\t\t\tptype = PTYPE_READ\n\t\t\tok, allowedit, err = ObjPermCheck(ctx, obj, ptype, f)\n\t\t}\n\n\t\t/* Errors or denies give a direct answer */\n\t\tif err != nil || !ok {\n\t\t\treturn\n\t\t}\n\t}\n\n\t/* If there is a Pitchfork tag it also gets to make a decision */\n\ttag := \"pfget\"\n\tif allowedit {\n\t\ttag = \"pfset\"\n\t}\n\n\tpermstr := f.Tag.Get(tag)\n\n\tif !app_perms || permstr != \"\" {\n\t\tok, err = ctx.CheckPermsT(\"StructPermCheck(\"+f.Name+\"/\"+tag+\"/\"+permstr+\")\", permstr)\n\t\tif !ok && allowedit {\n\t\t\tallowedit = false\n\t\t\ttag = \"pfget\"\n\t\t\tpermstr := f.Tag.Get(tag)\n\n\t\t\t/* Use the fail for pfset, if no pfget is defined and pfset errored */\n\t\t\tif permstr == \"\" && err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t/* Fall back */\n\t\t\tok, err = ctx.CheckPermsT(\"StructPermCheck(\"+f.Name+\"/get/\"+permstr+\")\", permstr)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\treturn\n}\n"], "filenames": ["lib/ctx.go", "lib/struct.go"], "buggy_code_start_loc": [947, 1355], "buggy_code_end_loc": [1336, 1537], "fixing_code_start_loc": [947, 1356], "fixing_code_end_loc": [1336, 1538], "type": "CWE-269", "message": "Pitchfork version 1.4.6 RC1 contains an Improper Privilege Management vulnerability in Trident Pitchfork components that can result in A standard unprivileged user could gain system administrator permissions within the web portal.. This attack appear to be exploitable via The user must be able to login, and could edit their profile and set the \"System Administrator\" permission to \"yes\" on themselves.. This vulnerability appears to have been fixed in 1.4.6 RC2.", "other": {"cve": {"id": "CVE-2018-1000133", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-16T14:29:44.847", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Pitchfork version 1.4.6 RC1 contains an Improper Privilege Management vulnerability in Trident Pitchfork components that can result in A standard unprivileged user could gain system administrator permissions within the web portal.. This attack appear to be exploitable via The user must be able to login, and could edit their profile and set the \"System Administrator\" permission to \"yes\" on themselves.. This vulnerability appears to have been fixed in 1.4.6 RC2."}, {"lang": "es", "value": "Pitchfork, en su versi\u00f3n 1.4.6 RC1, contiene una vulnerabilidad de gesti\u00f3n incorrecta de privilegios en los componentes Trident Pitchfork que puede resultar en que un usuario est\u00e1ndar sin privilegios obtenga permisos de administrador en el portal web. El usuario debe ser capaz de iniciar sesi\u00f3n y podr\u00eda editar su perfil y establecer el permiso \"System Administrator\" en \"yes\" para s\u00ed mismo. La vulnerabilidad parece haber sido solucionada en la versi\u00f3n 1.4.6 RC2."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:secluded:trident:1.4.6:rc1:*:*:*:*:*:*", "matchCriteriaId": "52F21E24-C1E2-4E41-B00C-FB5441CCD7CF"}]}]}], "references": [{"url": "https://github.com/tridentli/pitchfork/commit/33549f15707801099e1253dd5e79369bd48eb59b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tridentli/pitchfork/commit/9fd07cbe4f93e1367e142016e9a205366680dd54", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tridentli/pitchfork/issues/168", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/tridentli/trident/releases/tag/DEV_1.4.6-RC2", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://thomas-ward.net/security-advisories/trident-trusted-communications-platform-privilege-escalation-issue-advisory/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tridentli/pitchfork/commit/33549f15707801099e1253dd5e79369bd48eb59b"}}