{"buggy_code": ["/*\t$OpenBSD: httpd.h,v 1.126 2017/01/31 12:21:27 reyk Exp $\t*/\n\n/*\n * Copyright (c) 2006 - 2015 Reyk Floeter <reyk@openbsd.org>\n * Copyright (c) 2006, 2007 Pierre-Yves Ritschard <pyr@openbsd.org>\n * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#ifndef _HTTPD_H\n#define _HTTPD_H\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/queue.h>\n#include <sys/tree.h>\n#include <sys/time.h>\n\n#include <net/if.h>\n\n#include <stdarg.h>\n#include <limits.h>\n#include <event.h>\n#include <imsg.h>\n#include <tls.h>\n#include <vis.h>\n\n#include \"patterns.h\"\n\n#ifndef nitems\n#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))\n#endif\n\n#define CONF_FILE\t\t\"/etc/httpd.conf\"\n#define HTTPD_SOCKET\t\t\"/var/run/httpd.sock\"\n#define HTTPD_USER\t\t\"www\"\n#define HTTPD_SERVERNAME\t\"OpenBSD httpd\"\n#define HTTPD_DOCROOT\t\t\"/htdocs\"\n#define HTTPD_INDEX\t\t\"index.html\"\n#define HTTPD_FCGI_SOCKET\t\"/run/slowcgi.sock\"\n#define HTTPD_LOGROOT\t\t\"/logs\"\n#define HTTPD_ACCESS_LOG\t\"access.log\"\n#define HTTPD_ERROR_LOG\t\t\"error.log\"\n#define HTTPD_DEFAULT_TYPE\t{ \"bin\", \"application\", \"octet-stream\", NULL }\n#define HTTPD_LOGVIS\t\tVIS_NL|VIS_TAB|VIS_CSTYLE\n#define HTTPD_TLS_CERT\t\t\"/etc/ssl/server.crt\"\n#define HTTPD_TLS_KEY\t\t\"/etc/ssl/private/server.key\"\n#define HTTPD_TLS_CIPHERS\t\"compat\"\n#define HTTPD_TLS_DHE_PARAMS\t\"none\"\n#define HTTPD_TLS_ECDHE_CURVE\t\"auto\"\n#define FD_RESERVE\t\t5\n\n#define SERVER_MAX_CLIENTS\t1024\n#define SERVER_TIMEOUT\t\t600\n#define SERVER_CACHESIZE\t-1\t/* use default size */\n#define SERVER_NUMPROC\t\t3\n#define SERVER_MAXHEADERLENGTH\t8192\n#define SERVER_MAXREQUESTS\t100\t/* max requests per connection */\n#define SERVER_MAXREQUESTBODY\t1048576\t/* 1M */\n#define SERVER_BACKLOG\t\t10\n#define SERVER_OUTOF_FD_RETRIES\t5\n#define SERVER_MAX_PREFETCH\t256\n#define SERVER_MIN_PREFETCHED\t32\n#define SERVER_HSTS_DEFAULT_AGE\t31536000\n\n#define MEDIATYPE_NAMEMAX\t128\t/* file name extension */\n#define MEDIATYPE_TYPEMAX\t64\t/* length of type/subtype */\n\n#define CONFIG_RELOAD\t\t0x00\n#define CONFIG_MEDIA\t\t0x01\n#define CONFIG_SERVERS\t\t0x02\n#define CONFIG_AUTH\t\t0x04\n#define CONFIG_ALL\t\t0xff\n\n#define FCGI_CONTENT_SIZE\t65535\n\n#define PROC_PARENT_SOCK_FILENO\t3\n#define PROC_MAX_INSTANCES\t32\n\nenum httpchunk {\n\tTOREAD_UNLIMITED\t\t= -1,\n\tTOREAD_HTTP_HEADER\t\t= -2,\n\tTOREAD_HTTP_CHUNK_LENGTH\t= -3,\n\tTOREAD_HTTP_CHUNK_TRAILER\t= -4,\n\tTOREAD_HTTP_NONE\t\t= -5\n};\n\n#if DEBUG\n#define DPRINTF\t\tlog_debug\n#else\n#define DPRINTF(x...)\tdo {} while(0)\n#endif\n\nstruct ctl_flags {\n\tuint8_t\t\t cf_opts;\n\tuint32_t\t cf_flags;\n};\n\nenum key_type {\n\tKEY_TYPE_NONE\t\t= 0,\n\tKEY_TYPE_COOKIE,\n\tKEY_TYPE_HEADER,\n\tKEY_TYPE_PATH,\n\tKEY_TYPE_QUERY,\n\tKEY_TYPE_URL,\n\tKEY_TYPE_MAX\n};\n\nTAILQ_HEAD(kvlist, kv);\nRB_HEAD(kvtree, kv);\n\nstruct kv {\n\tchar\t\t\t*kv_key;\n\tchar\t\t\t*kv_value;\n\n\tenum key_type\t\t kv_type;\n\n#define KV_FLAG_INVALID\t\t 0x01\n#define KV_FLAG_GLOBBING\t 0x02\n\tuint8_t\t\t\t kv_flags;\n\n\tstruct kvlist\t\t kv_children;\n\tstruct kv\t\t*kv_parent;\n\tTAILQ_ENTRY(kv)\t\t kv_entry;\n\n\tRB_ENTRY(kv)\t\t kv_node;\n};\n\nstruct portrange {\n\tin_port_t\t\t val[2];\n\tuint8_t\t\t\t op;\n};\n\nstruct address {\n\tstruct sockaddr_storage\t ss;\n\tint\t\t\t ipproto;\n\tint\t\t\t prefixlen;\n\tstruct portrange\t port;\n\tchar\t\t\t ifname[IFNAMSIZ];\n\tTAILQ_ENTRY(address)\t entry;\n};\nTAILQ_HEAD(addresslist, address);\n\n/* initially control.h */\nstruct control_sock {\n\tconst char\t*cs_name;\n\tstruct event\t cs_ev;\n\tstruct event\t cs_evt;\n\tint\t\t cs_fd;\n\tint\t\t cs_restricted;\n\tvoid\t\t*cs_env;\n\n\tTAILQ_ENTRY(control_sock) cs_entry;\n};\nTAILQ_HEAD(control_socks, control_sock);\n\nstruct {\n\tstruct event\t ev;\n\tint\t\t fd;\n} control_state;\n\nstruct imsgev {\n\tstruct imsgbuf\t\t ibuf;\n\tvoid\t\t\t(*handler)(int, short, void *);\n\tstruct event\t\t ev;\n\tstruct privsep_proc\t*proc;\n\tvoid\t\t\t*data;\n\tshort\t\t\t events;\n};\n\n#define IMSG_SIZE_CHECK(imsg, p) do {\t\t\t\t\\\n\tif (IMSG_DATA_SIZE(imsg) < sizeof(*p))\t\t\t\\\n\t\tfatalx(\"bad length imsg received\");\t\t\\\n} while (0)\n#define IMSG_DATA_SIZE(imsg)\t((imsg)->hdr.len - IMSG_HEADER_SIZE)\n\nstruct ctl_conn {\n\tTAILQ_ENTRY(ctl_conn)\t entry;\n\tuint8_t\t\t\t flags;\n\tunsigned int\t\t waiting;\n#define CTL_CONN_NOTIFY\t\t 0x01\n\tstruct imsgev\t\t iev;\n\n};\nTAILQ_HEAD(ctl_connlist, ctl_conn);\n\nenum imsg_type {\n\tIMSG_NONE,\n\tIMSG_CTL_OK,\n\tIMSG_CTL_FAIL,\n\tIMSG_CTL_VERBOSE,\n\tIMSG_CTL_PROCFD,\n\tIMSG_CTL_RESET,\n\tIMSG_CTL_SHUTDOWN,\n\tIMSG_CTL_RELOAD,\n\tIMSG_CTL_NOTIFY,\n\tIMSG_CTL_END,\n\tIMSG_CTL_START,\n\tIMSG_CTL_REOPEN,\n\tIMSG_CFG_SERVER,\n\tIMSG_CFG_TLS,\n\tIMSG_CFG_MEDIA,\n\tIMSG_CFG_AUTH,\n\tIMSG_CFG_DONE,\n\tIMSG_LOG_ACCESS,\n\tIMSG_LOG_ERROR,\n\tIMSG_LOG_OPEN\n};\n\nenum privsep_procid {\n\tPROC_ALL\t= -1,\n\tPROC_PARENT\t= 0,\n\tPROC_SERVER,\n\tPROC_LOGGER,\n\tPROC_MAX\n} privsep_process;\n\n/* Attach the control socket to the following process */\n#define PROC_CONTROL\tPROC_LOGGER\n\nstruct privsep_pipes {\n\tint\t\t\t\t*pp_pipes[PROC_MAX];\n};\n\nstruct privsep {\n\tstruct privsep_pipes\t\t*ps_pipes[PROC_MAX];\n\tstruct privsep_pipes\t\t*ps_pp;\n\n\tstruct imsgev\t\t\t*ps_ievs[PROC_MAX];\n\tconst char\t\t\t*ps_title[PROC_MAX];\n\tuint8_t\t\t\t\t ps_what[PROC_MAX];\n\n\tunsigned int\t\t\t ps_instances[PROC_MAX];\n\tunsigned int\t\t\t ps_instance;\n\n\tstruct control_sock\t\t ps_csock;\n\tstruct control_socks\t\t ps_rcsocks;\n\n\t/* Event and signal handlers */\n\tstruct event\t\t\t ps_evsigint;\n\tstruct event\t\t\t ps_evsigterm;\n\tstruct event\t\t\t ps_evsigchld;\n\tstruct event\t\t\t ps_evsighup;\n\tstruct event\t\t\t ps_evsigpipe;\n\tstruct event\t\t\t ps_evsigusr1;\n\n\tint\t\t\t\t ps_noaction;\n\tstruct passwd\t\t\t*ps_pw;\n\tstruct httpd\t\t\t*ps_env;\n};\n\nstruct privsep_proc {\n\tconst char\t\t*p_title;\n\tenum privsep_procid\t p_id;\n\tint\t\t\t(*p_cb)(int, struct privsep_proc *,\n\t\t\t\t    struct imsg *);\n\tvoid\t\t\t(*p_init)(struct privsep *,\n\t\t\t\t    struct privsep_proc *);\n\tconst char\t\t*p_chroot;\n\tstruct privsep\t\t*p_ps;\n\tvoid\t\t\t(*p_shutdown)(void);\n\tstruct passwd\t\t*p_pw;\n};\n\nstruct privsep_fd {\n\tenum privsep_procid\t\t pf_procid;\n\tunsigned int\t\t\t pf_instance;\n};\n\nenum fcgistate {\n\tFCGI_READ_HEADER,\n\tFCGI_READ_CONTENT,\n\tFCGI_READ_PADDING\n};\n\nstruct fcgi_data {\n\tenum fcgistate\t\t state;\n\tint\t\t\t toread;\n\tint\t\t\t padding_len;\n\tint\t\t\t type;\n\tint\t\t\t chunked;\n\tint\t\t\t end;\n\tint\t\t\t status;\n\tint\t\t\t headersdone;\n};\n\nstruct client {\n\tuint32_t\t\t clt_id;\n\tpid_t\t\t\t clt_pid;\n\tvoid\t\t\t*clt_srv;\n\tvoid\t\t\t*clt_srv_conf;\n\tuint32_t\t\t clt_srv_id;\n\tstruct sockaddr_storage\t clt_srv_ss;\n\tstruct str_match\t clt_srv_match;\n\n\tint\t\t\t clt_s;\n\tin_port_t\t\t clt_port;\n\tstruct sockaddr_storage\t clt_ss;\n\tstruct bufferevent\t*clt_bev;\n\tstruct evbuffer\t\t*clt_output;\n\tstruct event\t\t clt_ev;\n\tvoid\t\t\t*clt_descreq;\n\tvoid\t\t\t*clt_descresp;\n\tint\t\t\t clt_sndbufsiz;\n\n\tint\t\t\t clt_fd;\n\tstruct tls\t\t*clt_tls_ctx;\n\tstruct bufferevent\t*clt_srvbev;\n\tint\t\t\t clt_srvbev_throttled;\n\n\toff_t\t\t\t clt_toread;\n\tsize_t\t\t\t clt_headerlen;\n\tint\t\t\t clt_headersdone;\n\tunsigned int\t\t clt_persist;\n\tint\t\t\t clt_line;\n\tint\t\t\t clt_done;\n\tint\t\t\t clt_chunk;\n\tint\t\t\t clt_inflight;\n\tstruct fcgi_data\t clt_fcgi;\n\tchar\t\t\t*clt_remote_user;\n\tstruct evbuffer\t\t*clt_srvevb;\n\n\tstruct evbuffer\t\t*clt_log;\n\tstruct timeval\t\t clt_timeout;\n\tstruct timeval\t\t clt_tv_start;\n\tstruct timeval\t\t clt_tv_last;\n\tstruct event\t\t clt_inflightevt;\n\n\tSPLAY_ENTRY(client)\t clt_nodes;\n};\nSPLAY_HEAD(client_tree, client);\n\n#define SRVFLAG_INDEX\t\t0x00000001\n#define SRVFLAG_NO_INDEX\t0x00000002\n#define SRVFLAG_AUTO_INDEX\t0x00000004\n#define SRVFLAG_NO_AUTO_INDEX\t0x00000008\n#define SRVFLAG_ROOT\t\t0x00000010\n#define SRVFLAG_LOCATION\t0x00000020\n#define SRVFLAG_FCGI\t\t0x00000040\n#define SRVFLAG_NO_FCGI\t\t0x00000080\n#define SRVFLAG_LOG\t\t0x00000100\n#define SRVFLAG_NO_LOG\t\t0x00000200\n#define SRVFLAG_SOCKET\t\t0x00000400\n#define SRVFLAG_SYSLOG\t\t0x00000800\n#define SRVFLAG_NO_SYSLOG\t0x00001000\n#define SRVFLAG_TLS\t\t0x00002000\n#define SRVFLAG_ACCESS_LOG\t0x00004000\n#define SRVFLAG_ERROR_LOG\t0x00008000\n#define SRVFLAG_AUTH\t\t0x00010000\n#define SRVFLAG_NO_AUTH\t\t0x00020000\n#define SRVFLAG_BLOCK\t\t0x00040000\n#define SRVFLAG_NO_BLOCK\t0x00080000\n#define SRVFLAG_LOCATION_MATCH\t0x00100000\n#define SRVFLAG_SERVER_MATCH\t0x00200000\n#define SRVFLAG_SERVER_HSTS\t0x00400000\n#define SRVFLAG_DEFAULT_TYPE\t0x00800000\n\n#define SRVFLAG_BITS\t\t\t\t\t\t\t\\\n\t\"\\10\\01INDEX\\02NO_INDEX\\03AUTO_INDEX\\04NO_AUTO_INDEX\"\t\t\\\n\t\"\\05ROOT\\06LOCATION\\07FCGI\\10NO_FCGI\\11LOG\\12NO_LOG\\13SOCKET\"\t\\\n\t\"\\14SYSLOG\\15NO_SYSLOG\\16TLS\\17ACCESS_LOG\\20ERROR_LOG\"\t\t\\\n\t\"\\21AUTH\\22NO_AUTH\\23BLOCK\\24NO_BLOCK\\25LOCATION_MATCH\"\t\t\\\n\t\"\\26SERVER_MATCH\\27SERVER_HSTS\\30DEFAULT_TYPE\"\n\n#define TCPFLAG_NODELAY\t\t0x01\n#define TCPFLAG_NNODELAY\t0x02\n#define TCPFLAG_SACK\t\t0x04\n#define TCPFLAG_NSACK\t\t0x08\n#define TCPFLAG_BUFSIZ\t\t0x10\n#define TCPFLAG_IPTTL\t\t0x20\n#define TCPFLAG_IPMINTTL\t0x40\n#define TCPFLAG_NSPLICE\t\t0x80\n#define TCPFLAG_DEFAULT\t\t0x00\n\n#define TCPFLAG_BITS\t\t\t\t\t\t\\\n\t\"\\10\\01NODELAY\\02NO_NODELAY\\03SACK\\04NO_SACK\"\t\t\\\n\t\"\\05SOCKET_BUFFER_SIZE\\06IP_TTL\\07IP_MINTTL\\10NO_SPLICE\"\n\n#define HSTSFLAG_SUBDOMAINS\t0x01\n#define HSTSFLAG_PRELOAD\t0x02\n#define HSTSFLAG_BITS\t\t\"\\10\\01SUBDOMAINS\\02PRELOAD\"\n\nenum log_format {\n\tLOG_FORMAT_COMMON,\n\tLOG_FORMAT_COMBINED,\n\tLOG_FORMAT_CONNECTION\n};\n\nstruct log_file {\n\tchar\t\t\tlog_name[NAME_MAX];\n\tint\t\t\tlog_fd;\n\tuint32_t\t\tlog_id;\n\tTAILQ_ENTRY(log_file)\tlog_entry;\n};\nTAILQ_HEAD(log_files, log_file) log_files;\n\nstruct media_type {\n\tchar\t\t\t media_name[MEDIATYPE_NAMEMAX];\n\tchar\t\t\t media_type[MEDIATYPE_TYPEMAX];\n\tchar\t\t\t media_subtype[MEDIATYPE_TYPEMAX];\n\tchar\t\t\t*media_encoding;\n\tRB_ENTRY(media_type)\t media_entry;\n};\nRB_HEAD(mediatypes, media_type);\n\nstruct auth {\n\tchar\t\t\t auth_htpasswd[PATH_MAX];\n\tuint32_t\t\t auth_id;\n\tTAILQ_ENTRY(auth)\t auth_entry;\n};\nTAILQ_HEAD(serverauth, auth);\n\nstruct server_config {\n\tuint32_t\t\t id;\n\tuint32_t\t\t parent_id;\n\tchar\t\t\t name[HOST_NAME_MAX+1];\n\tchar\t\t\t location[NAME_MAX];\n\tchar\t\t\t index[NAME_MAX];\n\tchar\t\t\t root[PATH_MAX];\n\tchar\t\t\t socket[PATH_MAX];\n\tchar\t\t\t accesslog[NAME_MAX];\n\tchar\t\t\t errorlog[NAME_MAX];\n\tstruct media_type\t default_type;\n\n\tin_port_t\t\t port;\n\tstruct sockaddr_storage\t ss;\n\tint\t\t\t prefixlen;\n\tstruct timeval\t\t timeout;\n\tuint32_t\t\t maxrequests;\n\tsize_t\t\t\t maxrequestbody;\n\n\tuint8_t\t\t\t*tls_cert;\n\tsize_t\t\t\t tls_cert_len;\n\tchar\t\t\t*tls_cert_file;\n\tchar\t\t\t tls_ciphers[NAME_MAX];\n\tchar\t\t\t tls_dhe_params[NAME_MAX];\n\tchar\t\t\t tls_ecdhe_curve[NAME_MAX];\n\tuint8_t\t\t\t*tls_key;\n\tsize_t\t\t\t tls_key_len;\n\tchar\t\t\t*tls_key_file;\n\tuint32_t\t\t tls_protocols;\n\tuint8_t\t\t\t*tls_ocsp_staple;\n\tsize_t\t\t\t tls_ocsp_staple_len;\n\tchar\t\t\t*tls_ocsp_staple_file;\n\n\tuint32_t\t\t flags;\n\tint\t\t\t strip;\n\tuint8_t\t\t\t tcpflags;\n\tint\t\t\t tcpbufsiz;\n\tint\t\t\t tcpbacklog;\n\tuint8_t\t\t\t tcpipttl;\n\tuint8_t\t\t\t tcpipminttl;\n\n\tenum log_format\t\t logformat;\n\tstruct log_file\t\t*logaccess;\n\tstruct log_file\t\t*logerror;\n\n\tchar\t\t\t auth_realm[NAME_MAX];\n\tuint32_t\t\t auth_id;\n\tconst struct auth\t*auth;\n\n\tint\t\t\t return_code;\n\tchar\t\t\t*return_uri;\n\toff_t\t\t\t return_uri_len;\n\n\tint\t\t\t hsts_max_age;\n\tuint8_t\t\t\t hsts_flags;\n\n\tTAILQ_ENTRY(server_config) entry;\n};\nTAILQ_HEAD(serverhosts, server_config);\n\nstruct tls_config {\n\tuint32_t\t\t id;\n\n\tsize_t\t\t\t tls_cert_len;\n\tsize_t\t\t\t tls_key_len;\n\tsize_t\t\t\t tls_ocsp_staple_len;\n};\n\nstruct server {\n\tTAILQ_ENTRY(server)\t srv_entry;\n\tstruct server_config\t srv_conf;\n\tstruct serverhosts\t srv_hosts;\n\n\tint\t\t\t srv_s;\n\tstruct event\t\t srv_ev;\n\tstruct event\t\t srv_evt;\n\n\tstruct tls\t\t *srv_tls_ctx;\n\tstruct tls_config\t *srv_tls_config;\n\n\tstruct client_tree\t srv_clients;\n};\nTAILQ_HEAD(serverlist, server);\n\nstruct httpd {\n\tuint8_t\t\t\t sc_opts;\n\tuint32_t\t\t sc_flags;\n\tconst char\t\t*sc_conffile;\n\tstruct event\t\t sc_ev;\n\tuint16_t\t\t sc_prefork_server;\n\tuint16_t\t\t sc_id;\n\tint\t\t\t sc_paused;\n\tchar\t\t\t*sc_chroot;\n\tchar\t\t\t*sc_logdir;\n\n\tstruct serverlist\t*sc_servers;\n\tstruct mediatypes\t*sc_mediatypes;\n\tstruct media_type\t sc_default_type;\n\tstruct serverauth\t*sc_auth;\n\n\tstruct privsep\t\t*sc_ps;\n\tint\t\t\t sc_reload;\n};\n\n#define HTTPD_OPT_VERBOSE\t\t0x01\n#define HTTPD_OPT_NOACTION\t\t0x04\n\n/* control.c */\nint\t control_init(struct privsep *, struct control_sock *);\nint\t control_listen(struct control_sock *);\nvoid\t control_cleanup(struct control_sock *);\nvoid\t control_dispatch_imsg(int, short, void *);\nvoid\t control_imsg_forward(struct privsep *, struct imsg *);\nstruct ctl_conn\t*\n\t control_connbyfd(int);\n\nextern  struct ctl_connlist ctl_conns;\n\n/* parse.y */\nint\t parse_config(const char *, struct httpd *);\nint\t load_config(const char *, struct httpd *);\nint\t cmdline_symset(char *);\n\n/* server.c */\nvoid\t server(struct privsep *, struct privsep_proc *);\nint\t server_tls_cmp(struct server *, struct server *, int);\nint\t server_tls_load_keypair(struct server *);\nint\t server_tls_load_ocsp(struct server *);\nint\t server_privinit(struct server *);\nvoid\t server_purge(struct server *);\nvoid\t serverconfig_free(struct server_config *);\nvoid\t serverconfig_reset(struct server_config *);\nint\t server_socket_af(struct sockaddr_storage *, in_port_t);\nin_port_t\n\t server_socket_getport(struct sockaddr_storage *);\nint\t server_socket_connect(struct sockaddr_storage *, in_port_t,\n\t    struct server_config *);\nvoid\t server_write(struct bufferevent *, void *);\nvoid\t server_read(struct bufferevent *, void *);\nvoid\t server_error(struct bufferevent *, short, void *);\nvoid\t server_log(struct client *, const char *);\nvoid\t server_sendlog(struct server_config *, int, const char *, ...)\n\t    __attribute__((__format__ (printf, 3, 4)));\nvoid\t server_close(struct client *, const char *);\nvoid\t server_dump(struct client *, const void *, size_t);\nint\t server_client_cmp(struct client *, struct client *);\nint\t server_bufferevent_printf(struct client *, const char *, ...)\n\t    __attribute__((__format__ (printf, 2, 3)));\nint\t server_bufferevent_print(struct client *, const char *);\nint\t server_bufferevent_write_buffer(struct client *,\n\t    struct evbuffer *);\nint\t server_bufferevent_write_chunk(struct client *,\n\t    struct evbuffer *, size_t);\nint\t server_bufferevent_add(struct event *, int);\nint\t server_bufferevent_write(struct client *, void *, size_t);\nstruct server *\n\t server_byaddr(struct sockaddr *, in_port_t);\nstruct server_config *\n\t serverconfig_byid(uint32_t);\nint\t server_foreach(int (*)(struct server *,\n\t    struct server_config *, void *), void *);\nstruct server *\n\t server_match(struct server *, int);\n\nSPLAY_PROTOTYPE(client_tree, client, clt_nodes, server_client_cmp);\n\n/* server_http.c */\nvoid\t server_http_init(struct server *);\nvoid\t server_http(void);\nint\t server_httpdesc_init(struct client *);\nvoid\t server_read_http(struct bufferevent *, void *);\nvoid\t server_abort_http(struct client *, unsigned int, const char *);\nunsigned int\n\t server_httpmethod_byname(const char *);\nconst char\n\t*server_httpmethod_byid(unsigned int);\nconst char\n\t*server_httperror_byid(unsigned int);\nvoid\t server_read_httpcontent(struct bufferevent *, void *);\nvoid\t server_read_httpchunks(struct bufferevent *, void *);\nint\t server_writeheader_http(struct client *clt, struct kv *, void *);\nint\t server_headers(struct client *, void *,\n\t    int (*)(struct client *, struct kv *, void *), void *);\nint\t server_writeresponse_http(struct client *);\nint\t server_response_http(struct client *, unsigned int, struct media_type *,\n\t    off_t, time_t);\nvoid\t server_reset_http(struct client *);\nvoid\t server_close_http(struct client *);\nint\t server_response(struct httpd *, struct client *);\nconst char *\n\t server_root_strip(const char *, int);\nstruct server_config *\n\t server_getlocation(struct client *, const char *);\nconst char *\n\t server_http_host(struct sockaddr_storage *, char *, size_t);\nchar\t*server_http_parsehost(char *, char *, size_t, int *);\nssize_t\t server_http_time(time_t, char *, size_t);\nint\t server_log_http(struct client *, unsigned int, size_t);\n\n/* server_file.c */\nint\t server_file(struct httpd *, struct client *);\nvoid\t server_file_error(struct bufferevent *, short, void *);\n\n/* server_fcgi.c */\nint\t server_fcgi(struct httpd *, struct client *);\nint\t fcgi_add_stdin(struct client *, struct evbuffer *);\n\n/* httpd.c */\nvoid\t\t event_again(struct event *, int, short,\n\t\t    void (*)(int, short, void *),\n\t\t    struct timeval *, struct timeval *, void *);\nint\t\t expand_string(char *, size_t, const char *, const char *);\nconst char\t*url_decode(char *);\nchar\t\t*url_encode(const char *);\nconst char\t*canonicalize_host(const char *, char *, size_t);\nconst char\t*canonicalize_path(const char *, char *, size_t);\nsize_t\t\t path_info(char *);\nchar\t\t*escape_html(const char *);\nvoid\t\t socket_rlimit(int);\nchar\t\t*evbuffer_getline(struct evbuffer *);\nchar\t\t*get_string(uint8_t *, size_t);\nvoid\t\t*get_data(uint8_t *, size_t);\nint\t\t sockaddr_cmp(struct sockaddr *, struct sockaddr *, int);\nstruct in6_addr *prefixlen2mask6(uint8_t, uint32_t *);\nuint32_t\t prefixlen2mask(uint8_t);\nint\t\t accept_reserve(int, struct sockaddr *, socklen_t *, int,\n\t\t    volatile int *);\nstruct kv\t*kv_add(struct kvtree *, char *, char *);\nint\t\t kv_set(struct kv *, char *, ...)\n\t\t    __attribute__((__format__ (printf, 2, 3)));\nint\t\t kv_setkey(struct kv *, char *, ...)\n\t\t    __attribute__((__format__ (printf, 2, 3)));\nvoid\t\t kv_delete(struct kvtree *, struct kv *);\nstruct kv\t*kv_extend(struct kvtree *, struct kv *, char *);\nvoid\t\t kv_purge(struct kvtree *);\nvoid\t\t kv_free(struct kv *);\nstruct kv\t*kv_inherit(struct kv *, struct kv *);\nint\t\t kv_log(struct evbuffer *, struct kv *);\nstruct kv\t*kv_find(struct kvtree *, struct kv *);\nint\t\t kv_cmp(struct kv *, struct kv *);\nstruct media_type\n\t\t*media_add(struct mediatypes *, struct media_type *);\nvoid\t\t media_delete(struct mediatypes *, struct media_type *);\nvoid\t\t media_purge(struct mediatypes *);\nstruct media_type *\n\t\t media_find(struct mediatypes *, const char *);\nstruct media_type *\n\t\t media_find_config(struct httpd *, struct server_config *,\n\t\t    const char *);\nint\t\t media_cmp(struct media_type *, struct media_type *);\nRB_PROTOTYPE(kvtree, kv, kv_node, kv_cmp);\nRB_PROTOTYPE(mediatypes, media_type, media_entry, media_cmp);\nstruct auth\t*auth_add(struct serverauth *, struct auth *);\nstruct auth\t*auth_byid(struct serverauth *, uint32_t);\nvoid\t\t auth_free(struct serverauth *, struct auth *);\nconst char\t*print_host(struct sockaddr_storage *, char *, size_t);\nconst char\t*print_time(struct timeval *, struct timeval *, char *, size_t);\nconst char\t*printb_flags(const uint32_t, const char *);\nvoid\t\t getmonotime(struct timeval *);\n\nextern struct httpd *httpd_env;\n\n/* log.c */\nvoid\tlog_init(int, int);\nvoid\tlog_procinit(const char *);\nvoid\tlog_setverbose(int);\nint\tlog_getverbose(void);\nvoid\tlog_warn(const char *, ...)\n\t    __attribute__((__format__ (printf, 1, 2)));\nvoid\tlog_warnx(const char *, ...)\n\t    __attribute__((__format__ (printf, 1, 2)));\nvoid\tlog_info(const char *, ...)\n\t    __attribute__((__format__ (printf, 1, 2)));\nvoid\tlog_debug(const char *, ...)\n\t    __attribute__((__format__ (printf, 1, 2)));\nvoid\tlogit(int, const char *, ...)\n\t    __attribute__((__format__ (printf, 2, 3)));\nvoid\tvlog(int, const char *, va_list)\n\t    __attribute__((__format__ (printf, 2, 0)));\n__dead void fatal(const char *, ...)\n\t    __attribute__((__format__ (printf, 1, 2)));\n__dead void fatalx(const char *, ...)\n\t    __attribute__((__format__ (printf, 1, 2)));\n\n/* proc.c */\nenum privsep_procid\n\t    proc_getid(struct privsep_proc *, unsigned int, const char *);\nvoid\t proc_init(struct privsep *, struct privsep_proc *, unsigned int,\n\t    int, char **, enum privsep_procid);\nvoid\t proc_kill(struct privsep *);\nvoid\t proc_connect(struct privsep *);\nvoid\t proc_dispatch(int, short event, void *);\nvoid\t proc_run(struct privsep *, struct privsep_proc *,\n\t    struct privsep_proc *, unsigned int,\n\t    void (*)(struct privsep *, struct privsep_proc *, void *), void *);\nvoid\t proc_range(struct privsep *, enum privsep_procid, int *, int *);\nint\t proc_compose_imsg(struct privsep *, enum privsep_procid, int,\n\t    u_int16_t, u_int32_t, int, void *, u_int16_t);\nint\t proc_compose(struct privsep *, enum privsep_procid,\n\t    uint16_t, void *, uint16_t);\nint\t proc_composev_imsg(struct privsep *, enum privsep_procid, int,\n\t    u_int16_t, u_int32_t, int, const struct iovec *, int);\nint\t proc_composev(struct privsep *, enum privsep_procid,\n\t    uint16_t, const struct iovec *, int);\nint\t proc_forward_imsg(struct privsep *, struct imsg *,\n\t    enum privsep_procid, int);\nstruct imsgbuf *\n\t proc_ibuf(struct privsep *, enum privsep_procid, int);\nstruct imsgev *\n\t proc_iev(struct privsep *, enum privsep_procid, int);\nint\t proc_flush_imsg(struct privsep *, enum privsep_procid, int);\nvoid\t imsg_event_add(struct imsgev *);\nint\t imsg_compose_event(struct imsgev *, uint16_t, uint32_t,\n\t    pid_t, int, void *, uint16_t);\nint\t imsg_composev_event(struct imsgev *, uint16_t, uint32_t,\n\t    pid_t, int, const struct iovec *, int);\n\n/* config.c */\nint\t config_init(struct httpd *);\nvoid\t config_purge(struct httpd *, unsigned int);\nint\t config_setreset(struct httpd *, unsigned int);\nint\t config_getreset(struct httpd *, struct imsg *);\nint\t config_getcfg(struct httpd *, struct imsg *);\nint\t config_setserver(struct httpd *, struct server *);\nint\t config_settls(struct httpd *, struct server *);\nint\t config_getserver(struct httpd *, struct imsg *);\nint\t config_gettls(struct httpd *, struct imsg *);\nint\t config_setmedia(struct httpd *, struct media_type *);\nint\t config_getmedia(struct httpd *, struct imsg *);\nint\t config_setauth(struct httpd *, struct auth *);\nint\t config_getauth(struct httpd *, struct imsg *);\n\n/* logger.c */\nvoid\t logger(struct privsep *, struct privsep_proc *);\nint\t logger_open_priv(struct imsg *);\n\n#endif /* _HTTPD_H */\n", "/*\t$OpenBSD: server_file.c,v 1.63 2017/01/30 09:54:41 reyk Exp $\t*/\n\n/*\n * Copyright (c) 2006 - 2015 Reyk Floeter <reyk@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n\n#include <limits.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <dirent.h>\n#include <time.h>\n#include <event.h>\n\n#include \"httpd.h\"\n#include \"http.h\"\n\n#define MINIMUM(a, b)\t(((a) < (b)) ? (a) : (b))\n#define MAXIMUM(a, b)\t(((a) > (b)) ? (a) : (b))\n#define MAX_RANGES\t4\n\nstruct range {\n\toff_t\tstart;\n\toff_t\tend;\n};\n\nint\t\t server_file_access(struct httpd *, struct client *,\n\t\t    char *, size_t);\nint\t\t server_file_request(struct httpd *, struct client *,\n\t\t    char *, struct stat *);\nint\t\t server_partial_file_request(struct httpd *, struct client *,\n\t\t    char *, struct stat *, char *);\nint\t\t server_file_index(struct httpd *, struct client *,\n\t\t    struct stat *);\nint\t\t server_file_modified_since(struct http_descriptor *,\n\t\t    struct stat *);\nint\t\t server_file_method(struct client *);\nint\t\t parse_range_spec(char *, size_t, struct range *);\nstruct range\t*parse_range(char *, size_t, int *);\nint\t\t buffer_add_range(int, struct evbuffer *, struct range *);\n\nint\nserver_file_access(struct httpd *env, struct client *clt,\n    char *path, size_t len)\n{\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tstruct stat\t\t st;\n\tstruct kv\t\t*r, key;\n\tchar\t\t\t*newpath, *encodedpath;\n\tint\t\t\t ret;\n\n\terrno = 0;\n\n\tif (access(path, R_OK) == -1) {\n\t\tgoto fail;\n\t} else if (stat(path, &st) == -1) {\n\t\tgoto fail;\n\t} else if (S_ISDIR(st.st_mode)) {\n\t\t/* Deny access if directory indexing is disabled */\n\t\tif (srv_conf->flags & SRVFLAG_NO_INDEX) {\n\t\t\terrno = EACCES;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (desc->http_path_alias != NULL) {\n\t\t\t/* Recursion - the index \"file\" is a directory? */\n\t\t\terrno = EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* Redirect to path with trailing \"/\" */\n\t\tif (path[strlen(path) - 1] != '/') {\n\t\t\tif ((encodedpath = url_encode(desc->http_path)) == NULL)\n\t\t\t\treturn (500);\n\t\t\tif (asprintf(&newpath, \"http%s://%s%s/\",\n\t\t\t    srv_conf->flags & SRVFLAG_TLS ? \"s\" : \"\",\n\t\t\t    desc->http_host, encodedpath) == -1) {\n\t\t\t\tfree(encodedpath);\n\t\t\t\treturn (500);\n\t\t\t}\n\t\t\tfree(encodedpath);\n\n\t\t\t/* Path alias will be used for the redirection */\n\t\t\tdesc->http_path_alias = newpath;\n\n\t\t\t/* Indicate that the file has been moved */\n\t\t\treturn (301);\n\t\t}\n\n\t\t/* Append the default index file to the location */\n\t\tif (asprintf(&newpath, \"%s%s\", desc->http_path,\n\t\t    srv_conf->index) == -1)\n\t\t\treturn (500);\n\t\tdesc->http_path_alias = newpath;\n\t\tif (server_getlocation(clt, newpath) != srv_conf) {\n\t\t\t/* The location has changed */\n\t\t\treturn (server_file(env, clt));\n\t\t}\n\n\t\t/* Otherwise append the default index file to the path */\n\t\tif (strlcat(path, srv_conf->index, len) >= len) {\n\t\t\terrno = EACCES;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tret = server_file_access(env, clt, path, len);\n\t\tif (ret == 404) {\n\t\t\t/*\n\t\t\t * Index file not found; fail if auto-indexing is\n\t\t\t * not enabled, otherwise return success but\n\t\t\t * indicate directory with S_ISDIR of the previous\n\t\t\t * stat.\n\t\t\t */\n\t\t\tif ((srv_conf->flags & SRVFLAG_AUTO_INDEX) == 0) {\n\t\t\t\terrno = EACCES;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\treturn (server_file_index(env, clt, &st));\n\t\t}\n\t\treturn (ret);\n\t} else if (!S_ISREG(st.st_mode)) {\n\t\t/* Don't follow symlinks and ignore special files */\n\t\terrno = EACCES;\n\t\tgoto fail;\n\t}\n\n\tkey.kv_key = \"Range\";\n\tr = kv_find(&desc->http_headers, &key);\n\tif (r != NULL)\n\t\treturn (server_partial_file_request(env, clt, path, &st,\n\t\t    r->kv_value));\n\telse\n\t\treturn (server_file_request(env, clt, path, &st));\n\n fail:\n\tswitch (errno) {\n\tcase ENOENT:\n\tcase ENOTDIR:\n\t\treturn (404);\n\tcase EACCES:\n\t\treturn (403);\n\tdefault:\n\t\treturn (500);\n\t}\n\n\t/* NOTREACHED */\n}\n\nint\nserver_file(struct httpd *env, struct client *clt)\n{\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tchar\t\t\t path[PATH_MAX];\n\tconst char\t\t*stripped, *errstr = NULL;\n\tint\t\t\t ret = 500;\n\n\tif (srv_conf->flags & SRVFLAG_FCGI)\n\t\treturn (server_fcgi(env, clt));\n\n\t/* Request path is already canonicalized */\n\tstripped = server_root_strip(\n\t    desc->http_path_alias != NULL ?\n\t    desc->http_path_alias : desc->http_path,\n\t    srv_conf->strip);\n\tif ((size_t)snprintf(path, sizeof(path), \"%s%s\",\n\t    srv_conf->root, stripped) >= sizeof(path)) {\n\t\terrstr = desc->http_path;\n\t\tgoto abort;\n\t}\n\n\t/* Returns HTTP status code on error */\n\tif ((ret = server_file_access(env, clt, path, sizeof(path))) > 0) {\n\t\terrstr = desc->http_path_alias != NULL ?\n\t\t    desc->http_path_alias : desc->http_path;\n\t\tgoto abort;\n\t}\n\n\treturn (ret);\n\n abort:\n\tif (errstr == NULL)\n\t\terrstr = strerror(errno);\n\tserver_abort_http(clt, ret, errstr);\n\treturn (-1);\n}\n\nint\nserver_file_method(struct client *clt)\n{\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\n\tswitch (desc->http_method) {\n\tcase HTTP_METHOD_GET:\n\tcase HTTP_METHOD_HEAD:\n\t\treturn (0);\n\tdefault:\n\t\t/* Other methods are not allowed */\n\t\terrno = EACCES;\n\t\treturn (405);\n\t}\n\t/* NOTREACHED */\n}\n\nint\nserver_file_request(struct httpd *env, struct client *clt, char *path,\n    struct stat *st)\n{\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tstruct media_type\t*media;\n\tconst char\t\t*errstr = NULL;\n\tint\t\t\t fd = -1, ret, code = 500;\n\n\tif ((ret = server_file_method(clt)) != 0) {\n\t\tcode = ret;\n\t\tgoto abort;\n\t}\n\n\tif ((ret = server_file_modified_since(clt->clt_descreq, st)) != -1)\n\t\treturn (ret);\n\n\t/* Now open the file, should be readable or we have another problem */\n\tif ((fd = open(path, O_RDONLY)) == -1)\n\t\tgoto abort;\n\n\tmedia = media_find_config(env, srv_conf, path);\n\tret = server_response_http(clt, 200, media, st->st_size,\n\t    MINIMUM(time(NULL), st->st_mtim.tv_sec));\n\tswitch (ret) {\n\tcase -1:\n\t\tgoto fail;\n\tcase 0:\n\t\t/* Connection is already finished */\n\t\tclose(fd);\n\t\tgoto done;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tclt->clt_fd = fd;\n\tif (clt->clt_srvbev != NULL)\n\t\tbufferevent_free(clt->clt_srvbev);\n\n\tclt->clt_srvbev_throttled = 0;\n\tclt->clt_srvbev = bufferevent_new(clt->clt_fd, server_read,\n\t    server_write, server_file_error, clt);\n\tif (clt->clt_srvbev == NULL) {\n\t\terrstr = \"failed to allocate file buffer event\";\n\t\tgoto fail;\n\t}\n\n\t/* Adjust read watermark to the socket output buffer size */\n\tbufferevent_setwatermark(clt->clt_srvbev, EV_READ, 0,\n\t    clt->clt_sndbufsiz);\n\n\tbufferevent_settimeout(clt->clt_srvbev,\n\t    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);\n\tbufferevent_enable(clt->clt_srvbev, EV_READ);\n\tbufferevent_disable(clt->clt_bev, EV_READ);\n\n done:\n\tserver_reset_http(clt);\n\treturn (0);\n fail:\n\tbufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);\n\tbufferevent_free(clt->clt_bev);\n\tclt->clt_bev = NULL;\n abort:\n\tif (fd != -1)\n\t\tclose(fd);\n\tif (errstr == NULL)\n\t\terrstr = strerror(errno);\n\tserver_abort_http(clt, code, errstr);\n\treturn (-1);\n}\n\nint\nserver_partial_file_request(struct httpd *env, struct client *clt, char *path,\n    struct stat *st, char *range_str)\n{\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct media_type\t*media, multipart_media;\n\tstruct range\t\t*range;\n\tstruct evbuffer\t\t*evb = NULL;\n\tsize_t\t\t\t content_length;\n\tint\t\t\t code = 500, fd = -1, i, nranges, ret;\n\tuint32_t\t\t boundary;\n\tchar\t\t\t content_range[64];\n\tconst char\t\t*errstr = NULL;\n\n\t/* Ignore range request for methods other than GET */\n\tif (desc->http_method != HTTP_METHOD_GET)\n\t\treturn server_file_request(env, clt, path, st);\n\n\tif ((range = parse_range(range_str, st->st_size, &nranges)) == NULL) {\n\t\tcode = 416;\n\t\t(void)snprintf(content_range, sizeof(content_range),\n\t\t    \"bytes */%lld\", st->st_size);\n\t\terrstr = content_range;\n\t\tgoto abort;\n\t}\n\n\t/* Now open the file, should be readable or we have another problem */\n\tif ((fd = open(path, O_RDONLY)) == -1)\n\t\tgoto abort;\n\n\tmedia = media_find_config(env, srv_conf, path);\n\tif ((evb = evbuffer_new()) == NULL) {\n\t\terrstr = \"failed to allocate file buffer\";\n\t\tgoto abort;\n\t}\n\n\tif (nranges == 1) {\n\t\t(void)snprintf(content_range, sizeof(content_range),\n\t\t    \"bytes %lld-%lld/%lld\", range->start, range->end,\n\t\t    st->st_size);\n\t\tif (kv_add(&resp->http_headers, \"Content-Range\",\n\t\t    content_range) == NULL)\n\t\t\tgoto abort;\n\n\t\tcontent_length = range->end - range->start + 1;\n\t\tif (buffer_add_range(fd, evb, range) == 0)\n\t\t\tgoto abort;\n\n\t} else {\n\t\tcontent_length = 0;\n\t\tboundary = arc4random();\n\t\t/* Generate a multipart payload of byteranges */\n\t\twhile (nranges--) {\n\t\t\tif ((i = evbuffer_add_printf(evb, \"\\r\\n--%ud\\r\\n\",\n\t\t\t    boundary)) == -1)\n\t\t\t\tgoto abort;\n\n\t\t\tcontent_length += i;\n\t\t\tif ((i = evbuffer_add_printf(evb,\n\t\t\t    \"Content-Type: %s/%s\\r\\n\",\n\t\t\t    media->media_type, media->media_subtype)) == -1)\n\t\t\t\tgoto abort;\n\n\t\t\tcontent_length += i;\n\t\t\tif ((i = evbuffer_add_printf(evb,\n\t\t\t    \"Content-Range: bytes %lld-%lld/%lld\\r\\n\\r\\n\",\n\t\t\t    range->start, range->end, st->st_size)) == -1)\n\t\t\t\tgoto abort;\n\n\t\t\tcontent_length += i;\n\t\t\tif (buffer_add_range(fd, evb, range) == 0)\n\t\t\t\tgoto abort;\n\n\t\t\tcontent_length += range->end - range->start + 1;\n\t\t\trange++;\n\t\t}\n\n\t\tif ((i = evbuffer_add_printf(evb, \"\\r\\n--%ud--\\r\\n\",\n\t\t    boundary)) == -1)\n\t\t\tgoto abort;\n\n\t\tcontent_length += i;\n\n\t\t/* prepare multipart/byteranges media type */\n\t\t(void)strlcpy(multipart_media.media_type, \"multipart\",\n\t\t    sizeof(multipart_media.media_type));\n\t\t(void)snprintf(multipart_media.media_subtype,\n\t\t    sizeof(multipart_media.media_subtype),\n\t\t    \"byteranges; boundary=%ud\", boundary);\n\t\tmedia = &multipart_media;\n\t}\n\n\tclose(fd);\n\tfd = -1;\n\n\tret = server_response_http(clt, 206, media, content_length,\n\t    MINIMUM(time(NULL), st->st_mtim.tv_sec));\n\tswitch (ret) {\n\tcase -1:\n\t\tgoto fail;\n\tcase 0:\n\t\t/* Connection is already finished */\n\t\tgoto done;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (server_bufferevent_write_buffer(clt, evb) == -1)\n\t\tgoto fail;\n\n\tbufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);\n\tif (clt->clt_persist)\n\t\tclt->clt_toread = TOREAD_HTTP_HEADER;\n\telse\n\t\tclt->clt_toread = TOREAD_HTTP_NONE;\n\tclt->clt_done = 0;\n\n done:\n\tevbuffer_free(evb);\n\tserver_reset_http(clt);\n\treturn (0);\n fail:\n\tbufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);\n\tbufferevent_free(clt->clt_bev);\n\tclt->clt_bev = NULL;\n abort:\n\tif (evb != NULL)\n\t\tevbuffer_free(evb);\n\tif (fd != -1)\n\t\tclose(fd);\n\tif (errstr == NULL)\n\t\terrstr = strerror(errno);\n\tserver_abort_http(clt, code, errstr);\n\treturn (-1);\n}\n\nint\nserver_file_index(struct httpd *env, struct client *clt, struct stat *st)\n{\n\tchar\t\t\t  path[PATH_MAX];\n\tchar\t\t\t  tmstr[21];\n\tstruct http_descriptor\t *desc = clt->clt_descreq;\n\tstruct server_config\t *srv_conf = clt->clt_srv_conf;\n\tstruct dirent\t\t**namelist, *dp;\n\tint\t\t\t  namesize, i, ret, fd = -1, namewidth, skip;\n\tint\t\t\t  code = 500;\n\tstruct evbuffer\t\t *evb = NULL;\n\tstruct media_type\t *media;\n\tconst char\t\t *stripped, *style;\n\tchar\t\t\t *escapeduri, *escapedhtml, *escapedpath;\n\tstruct tm\t\t  tm;\n\ttime_t\t\t\t  t, dir_mtime;\n\n\tif ((ret = server_file_method(clt)) != 0) {\n\t\tcode = ret;\n\t\tgoto abort;\n\t}\n\n\t/* Request path is already canonicalized */\n\tstripped = server_root_strip(desc->http_path, srv_conf->strip);\n\tif ((size_t)snprintf(path, sizeof(path), \"%s%s\",\n\t    srv_conf->root, stripped) >= sizeof(path))\n\t\tgoto abort;\n\n\t/* Now open the file, should be readable or we have another problem */\n\tif ((fd = open(path, O_RDONLY)) == -1)\n\t\tgoto abort;\n\n\t/* Save last modification time */\n\tdir_mtime = MINIMUM(time(NULL), st->st_mtim.tv_sec);\n\n\tif ((evb = evbuffer_new()) == NULL)\n\t\tgoto abort;\n\n\tif ((namesize = scandir(path, &namelist, NULL, alphasort)) == -1)\n\t\tgoto abort;\n\n\t/* Indicate failure but continue going through the list */\n\tskip = 0;\n\n\tif ((escapedpath = escape_html(desc->http_path)) == NULL)\n\t\tgoto fail;\n\n\t/* A CSS stylesheet allows minimal customization by the user */\n\tstyle = \"body { background-color: white; color: black; font-family: \"\n\t    \"sans-serif; }\\nhr { border: 0; border-bottom: 1px dashed; }\\n\";\n\t/* Generate simple HTML index document */\n\tif (evbuffer_add_printf(evb,\n\t    \"<!DOCTYPE html>\\n\"\n\t    \"<html>\\n\"\n\t    \"<head>\\n\"\n\t    \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; \"\n\t    \"charset=utf-8\\\"/>\\n\"\n\t    \"<title>Index of %s</title>\\n\"\n\t    \"<style type=\\\"text/css\\\"><!--\\n%s\\n--></style>\\n\"\n\t    \"</head>\\n\"\n\t    \"<body>\\n\"\n\t    \"<h1>Index of %s</h1>\\n\"\n\t    \"<hr>\\n<pre>\\n\",\n\t    escapedpath, style, escapedpath) == -1)\n\t\tskip = 1;\n\n\tfree(escapedpath);\n\n\tfor (i = 0; i < namesize; i++) {\n\t\tdp = namelist[i];\n\n\t\tif (skip ||\n\t\t    fstatat(fd, dp->d_name, st, 0) == -1) {\n\t\t\tfree(dp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tt = st->st_mtime;\n\t\tlocaltime_r(&t, &tm);\n\t\tstrftime(tmstr, sizeof(tmstr), \"%d-%h-%Y %R\", &tm);\n\t\tnamewidth = 51 - strlen(dp->d_name);\n\n\t\tif ((escapeduri = url_encode(dp->d_name)) == NULL)\n\t\t\tgoto fail;\n\t\tif ((escapedhtml = escape_html(dp->d_name)) == NULL)\n\t\t\tgoto fail;\n\n\t\tif (dp->d_name[0] == '.' &&\n\t\t    !(dp->d_name[1] == '.' && dp->d_name[2] == '\\0')) {\n\t\t\t/* ignore hidden files starting with a dot */\n\t\t} else if (S_ISDIR(st->st_mode)) {\n\t\t\tnamewidth -= 1; /* trailing slash */\n\t\t\tif (evbuffer_add_printf(evb,\n\t\t\t    \"<a href=\\\"%s%s/\\\">%s/</a>%*s%s%20s\\n\",\n\t\t\t    strchr(escapeduri, ':') != NULL ? \"./\" : \"\",\n\t\t\t    escapeduri, escapedhtml,\n\t\t\t    MAXIMUM(namewidth, 0), \" \", tmstr, \"-\") == -1)\n\t\t\t\tskip = 1;\n\t\t} else if (S_ISREG(st->st_mode)) {\n\t\t\tif (evbuffer_add_printf(evb,\n\t\t\t    \"<a href=\\\"%s%s\\\">%s</a>%*s%s%20llu\\n\",\n\t\t\t    strchr(escapeduri, ':') != NULL ? \"./\" : \"\",\n\t\t\t    escapeduri, escapedhtml,\n\t\t\t    MAXIMUM(namewidth, 0), \" \",\n\t\t\t    tmstr, st->st_size) == -1)\n\t\t\t\tskip = 1;\n\t\t}\n\t\tfree(escapeduri);\n\t\tfree(escapedhtml);\n\t\tfree(dp);\n\t}\n\tfree(namelist);\n\n\tif (skip ||\n\t    evbuffer_add_printf(evb,\n\t    \"</pre>\\n<hr>\\n</body>\\n</html>\\n\") == -1)\n\t\tgoto abort;\n\n\tclose(fd);\n\tfd = -1;\n\n\tmedia = media_find_config(env, srv_conf, \"index.html\");\n\tret = server_response_http(clt, 200, media, EVBUFFER_LENGTH(evb),\n\t    dir_mtime);\n\tswitch (ret) {\n\tcase -1:\n\t\tgoto fail;\n\tcase 0:\n\t\t/* Connection is already finished */\n\t\tevbuffer_free(evb);\n\t\tgoto done;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (server_bufferevent_write_buffer(clt, evb) == -1)\n\t\tgoto fail;\n\tevbuffer_free(evb);\n\tevb = NULL;\n\n\tbufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);\n\tif (clt->clt_persist)\n\t\tclt->clt_toread = TOREAD_HTTP_HEADER;\n\telse\n\t\tclt->clt_toread = TOREAD_HTTP_NONE;\n\tclt->clt_done = 0;\n\n done:\n\tserver_reset_http(clt);\n\treturn (0);\n fail:\n\tbufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);\n\tbufferevent_free(clt->clt_bev);\n\tclt->clt_bev = NULL;\n abort:\n\tif (fd != -1)\n\t\tclose(fd);\n\tif (evb != NULL)\n\t\tevbuffer_free(evb);\n\tserver_abort_http(clt, code, desc->http_path);\n\treturn (-1);\n}\n\nvoid\nserver_file_error(struct bufferevent *bev, short error, void *arg)\n{\n\tstruct client\t\t*clt = arg;\n\tstruct evbuffer\t\t*dst;\n\n\tif (error & EVBUFFER_TIMEOUT) {\n\t\tserver_close(clt, \"buffer event timeout\");\n\t\treturn;\n\t}\n\tif (error & EVBUFFER_ERROR) {\n\t\tif (errno == EFBIG) {\n\t\t\tbufferevent_enable(bev, EV_READ);\n\t\t\treturn;\n\t\t}\n\t\tserver_close(clt, \"buffer event error\");\n\t\treturn;\n\t}\n\tif (error & (EVBUFFER_READ|EVBUFFER_WRITE|EVBUFFER_EOF)) {\n\t\tbufferevent_disable(bev, EV_READ|EV_WRITE);\n\n\t\tclt->clt_done = 1;\n\n\t\tif (clt->clt_persist) {\n\t\t\t/* Close input file and wait for next HTTP request */\n\t\t\tif (clt->clt_fd != -1)\n\t\t\t\tclose(clt->clt_fd);\n\t\t\tclt->clt_fd = -1;\n\t\t\tclt->clt_toread = TOREAD_HTTP_HEADER;\n\t\t\tserver_reset_http(clt);\n\t\t\tbufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);\n\t\t\treturn;\n\t\t}\n\n\t\tdst = EVBUFFER_OUTPUT(clt->clt_bev);\n\t\tif (EVBUFFER_LENGTH(dst)) {\n\t\t\t/* Finish writing all data first */\n\t\t\tbufferevent_enable(clt->clt_bev, EV_WRITE);\n\t\t\treturn;\n\t\t}\n\n\t\tserver_close(clt, \"done\");\n\t\treturn;\n\t}\n\tserver_close(clt, \"unknown event error\");\n\treturn;\n}\n\nint\nserver_file_modified_since(struct http_descriptor *desc, struct stat *st)\n{\n\tstruct kv\t key, *since;\n\tstruct tm\t tm;\n\n\tkey.kv_key = \"If-Modified-Since\";\n\tif ((since = kv_find(&desc->http_headers, &key)) != NULL &&\n\t    since->kv_value != NULL) {\n\t\tmemset(&tm, 0, sizeof(struct tm));\n\n\t\t/*\n\t\t * Return \"Not modified\" if the file hasn't changed since\n\t\t * the requested time.\n\t\t */\n\t\tif (strptime(since->kv_value,\n\t\t    \"%a, %d %h %Y %T %Z\", &tm) != NULL &&\n\t\t    timegm(&tm) >= st->st_mtim.tv_sec)\n\t\t\treturn (304);\n\t}\n\n\treturn (-1);\n}\n\nstruct range *\nparse_range(char *str, size_t file_sz, int *nranges)\n{\n\tstatic struct range\t ranges[MAX_RANGES];\n\tint\t\t\t i = 0;\n\tchar\t\t\t*p, *q;\n\n\t/* Extract range unit */\n\tif ((p = strchr(str, '=')) == NULL)\n\t\treturn (NULL);\n\n\t*p++ = '\\0';\n\t/* Check if it's a bytes range spec */\n\tif (strcmp(str, \"bytes\") != 0)\n\t\treturn (NULL);\n\n\twhile ((q = strchr(p, ',')) != NULL) {\n\t\t*q++ = '\\0';\n\n\t\t/* Extract start and end positions */\n\t\tif (parse_range_spec(p, file_sz, &ranges[i]) == 0)\n\t\t\tcontinue;\n\n\t\ti++;\n\t\tif (i == MAX_RANGES)\n\t\t\treturn (NULL);\n\n\t\tp = q;\n\t}\n\n\tif (parse_range_spec(p, file_sz, &ranges[i]) != 0)\n\t\ti++;\n\n\t*nranges = i;\n\treturn (i ? ranges : NULL);\n}\n\nint\nparse_range_spec(char *str, size_t size, struct range *r)\n{\n\tsize_t\t\t start_str_len, end_str_len;\n\tchar\t\t*p, *start_str, *end_str;\n\tconst char\t*errstr;\n\n\tif ((p = strchr(str, '-')) == NULL)\n\t\treturn (0);\n\n\t*p++ = '\\0';\n\tstart_str = str;\n\tend_str = p;\n\tstart_str_len = strlen(start_str);\n\tend_str_len = strlen(end_str);\n\n\t/* Either 'start' or 'end' is optional but not both */\n\tif ((start_str_len == 0) && (end_str_len == 0))\n\t\treturn (0);\n\n\tif (end_str_len) {\n\t\tr->end = strtonum(end_str, 0, LLONG_MAX, &errstr);\n\t\tif (errstr)\n\t\t\treturn (0);\n\n\t\tif ((size_t)r->end >= size)\n\t\t\tr->end = size - 1;\n\t} else\n\t\tr->end = size - 1;\n\n\tif (start_str_len) {\n\t\tr->start = strtonum(start_str, 0, LLONG_MAX, &errstr);\n\t\tif (errstr)\n\t\t\treturn (0);\n\n\t\tif ((size_t)r->start >= size)\n\t\t\treturn (0);\n\t} else {\n\t\tr->start = size - r->end;\n\t\tr->end = size - 1;\n\t}\n\n\tif (r->end < r->start)\n\t\treturn (0);\n\n\treturn (1);\n}\n\nint\nbuffer_add_range(int fd, struct evbuffer *evb, struct range *range)\n{\n\tchar\tbuf[BUFSIZ];\n\tsize_t\tn, range_sz;\n\tssize_t\tnread;\n\n\tif (lseek(fd, range->start, SEEK_SET) == -1)\n\t\treturn (0);\n\n\trange_sz = range->end - range->start + 1;\n\twhile (range_sz) {\n\t\tn = MINIMUM(range_sz, sizeof(buf));\n\t\tif ((nread = read(fd, buf, n)) == -1)\n\t\t\treturn (0);\n\n\t\tevbuffer_add(evb, buf, nread);\n\t\trange_sz -= nread;\n\t}\n\n\treturn (1);\n}\n", "/*\t$OpenBSD: server_http.c,v 1.111 2017/01/31 12:21:27 reyk Exp $\t*/\n\n/*\n * Copyright (c) 2006 - 2015 Reyk Floeter <reyk@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/queue.h>\n#include <sys/socket.h>\n#include <sys/tree.h>\n\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n#include <fnmatch.h>\n#include <stdio.h>\n#include <time.h>\n#include <resolv.h>\n#include <event.h>\n#include <ctype.h>\n#include <vis.h>\n\n#include \"httpd.h\"\n#include \"http.h\"\n#include \"patterns.h\"\n\nstatic int\t server_httpmethod_cmp(const void *, const void *);\nstatic int\t server_httperror_cmp(const void *, const void *);\nvoid\t\t server_httpdesc_free(struct http_descriptor *);\nint\t\t server_http_authenticate(struct server_config *,\n\t\t    struct client *);\nchar\t\t*server_expand_http(struct client *, const char *,\n\t\t    char *, size_t);\n\nstatic struct http_method\t http_methods[] = HTTP_METHODS;\nstatic struct http_error\t http_errors[] = HTTP_ERRORS;\n\nvoid\nserver_http(void)\n{\n\tDPRINTF(\"%s: sorting lookup tables, pid %d\", __func__, getpid());\n\n\t/* Sort the HTTP lookup arrays */\n\tqsort(http_methods, sizeof(http_methods) /\n\t    sizeof(http_methods[0]) - 1,\n\t    sizeof(http_methods[0]), server_httpmethod_cmp);\n\tqsort(http_errors, sizeof(http_errors) /\n\t    sizeof(http_errors[0]) - 1,\n\t    sizeof(http_errors[0]), server_httperror_cmp);\n}\n\nvoid\nserver_http_init(struct server *srv)\n{\n\t/* nothing */\n}\n\nint\nserver_httpdesc_init(struct client *clt)\n{\n\tstruct http_descriptor\t*desc;\n\n\tif ((desc = calloc(1, sizeof(*desc))) == NULL)\n\t\treturn (-1);\n\tRB_INIT(&desc->http_headers);\n\tclt->clt_descreq = desc;\n\n\tif ((desc = calloc(1, sizeof(*desc))) == NULL) {\n\t\t/* req will be cleaned up later */\n\t\treturn (-1);\n\t}\n\tRB_INIT(&desc->http_headers);\n\tclt->clt_descresp = desc;\n\n\treturn (0);\n}\n\nvoid\nserver_httpdesc_free(struct http_descriptor *desc)\n{\n\tif (desc == NULL)\n\t\treturn;\n\n\tfree(desc->http_path);\n\tdesc->http_path = NULL;\n\tfree(desc->http_path_alias);\n\tdesc->http_path_alias = NULL;\n\tfree(desc->http_query);\n\tdesc->http_query = NULL;\n\tfree(desc->http_version);\n\tdesc->http_version = NULL;\n\tfree(desc->http_host);\n\tdesc->http_host = NULL;\n\n\tkv_purge(&desc->http_headers);\n\tdesc->http_lastheader = NULL;\n\tdesc->http_method = 0;\n\tdesc->http_chunked = 0;\n}\n\nint\nserver_http_authenticate(struct server_config *srv_conf, struct client *clt)\n{\n\tchar\t\t\t decoded[1024];\n\tFILE\t\t\t*fp = NULL;\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tconst struct auth\t*auth = srv_conf->auth;\n\tstruct kv\t\t*ba, key;\n\tsize_t\t\t\t linesize = 0;\n\tssize_t\t\t\t linelen;\n\tint\t\t\t ret = -1;\n\tchar\t\t\t*line = NULL, *user = NULL, *pass = NULL;\n\tchar\t\t\t*clt_user = NULL, *clt_pass = NULL;\n\n\tmemset(decoded, 0, sizeof(decoded));\n\tkey.kv_key = \"Authorization\";\n\n\tif ((ba = kv_find(&desc->http_headers, &key)) == NULL ||\n\t    ba->kv_value == NULL)\n\t\tgoto done;\n\n\tif (strncmp(ba->kv_value, \"Basic \", strlen(\"Basic \")) != 0)\n\t\tgoto done;\n\n\tif (b64_pton(strchr(ba->kv_value, ' ') + 1, (uint8_t *)decoded,\n\t    sizeof(decoded)) <= 0)\n\t\tgoto done;\n\n\tif ((clt_pass = strchr(decoded, ':')) == NULL)\n\t\tgoto done;\n\n\tclt_user = decoded;\n\t*clt_pass++ = '\\0';\n\tif ((clt->clt_remote_user = strdup(clt_user)) == NULL)\n\t\tgoto done;\n\n\tif (clt_pass == NULL)\n\t\tgoto done;\n\n\tif ((fp = fopen(auth->auth_htpasswd, \"r\")) == NULL)\n\t\tgoto done;\n\n\twhile ((linelen = getline(&line, &linesize, fp)) != -1) {\n\t\tif (line[linelen - 1] == '\\n')\n\t\t\tline[linelen - 1] = '\\0';\n\t\tuser = line;\n\t\tpass = strchr(line, ':');\n\n\t\tif (pass == NULL) {\n\t\t\texplicit_bzero(line, linelen);\n\t\t\tcontinue;\n\t\t}\n\n\t\t*pass++ = '\\0';\n\n\t\tif (strcmp(clt_user, user) != 0) {\n\t\t\texplicit_bzero(line, linelen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (crypt_checkpass(clt_pass, pass) == 0) {\n\t\t\texplicit_bzero(line, linelen);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\tfree(line);\n\tif (fp != NULL)\n\t\tfclose(fp);\n\n\tif (ba != NULL && ba->kv_value != NULL) {\n\t\texplicit_bzero(ba->kv_value, strlen(ba->kv_value));\n\t\texplicit_bzero(decoded, sizeof(decoded));\n\t}\n\n\treturn (ret);\n}\n\nvoid\nserver_read_http(struct bufferevent *bev, void *arg)\n{\n\tstruct client\t\t*clt = arg;\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct evbuffer\t\t*src = EVBUFFER_INPUT(bev);\n\tchar\t\t\t*line = NULL, *key, *value;\n\tconst char\t\t*errstr;\n\tsize_t\t\t\t size, linelen;\n\tstruct kv\t\t*hdr = NULL;\n\n\tgetmonotime(&clt->clt_tv_last);\n\n\tsize = EVBUFFER_LENGTH(src);\n\tDPRINTF(\"%s: session %d: size %lu, to read %lld\",\n\t    __func__, clt->clt_id, size, clt->clt_toread);\n\tif (!size) {\n\t\tclt->clt_toread = TOREAD_HTTP_HEADER;\n\t\tgoto done;\n\t}\n\n\twhile (!clt->clt_headersdone && (line =\n\t    evbuffer_readln(src, NULL, EVBUFFER_EOL_CRLF_STRICT)) != NULL) {\n\t\tlinelen = strlen(line);\n\n\t\t/*\n\t\t * An empty line indicates the end of the request.\n\t\t * libevent already stripped the \\r\\n for us.\n\t\t */\n\t\tif (!linelen) {\n\t\t\tclt->clt_headersdone = 1;\n\t\t\tfree(line);\n\t\t\tbreak;\n\t\t}\n\t\tkey = line;\n\n\t\t/* Limit the total header length minus \\r\\n */\n\t\tclt->clt_headerlen += linelen;\n\t\tif (clt->clt_headerlen > SERVER_MAXHEADERLENGTH) {\n\t\t\tserver_abort_http(clt, 413, \"request too large\");\n\t\t\tgoto abort;\n\t\t}\n\n\t\t/*\n\t\t * The first line is the GET/POST/PUT/... request,\n\t\t * subsequent lines are HTTP headers.\n\t\t */\n\t\tif (++clt->clt_line == 1)\n\t\t\tvalue = strchr(key, ' ');\n\t\telse if (*key == ' ' || *key == '\\t')\n\t\t\t/* Multiline headers wrap with a space or tab */\n\t\t\tvalue = NULL;\n\t\telse\n\t\t\tvalue = strchr(key, ':');\n\t\tif (value == NULL) {\n\t\t\tif (clt->clt_line == 1) {\n\t\t\t\tserver_abort_http(clt, 400, \"malformed\");\n\t\t\t\tgoto abort;\n\t\t\t}\n\n\t\t\t/* Append line to the last header, if present */\n\t\t\tif (kv_extend(&desc->http_headers,\n\t\t\t    desc->http_lastheader, line) == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\tfree(line);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*value == ':') {\n\t\t\t*value++ = '\\0';\n\t\t\tvalue += strspn(value, \" \\t\\r\\n\");\n\t\t} else {\n\t\t\t*value++ = '\\0';\n\t\t}\n\n\t\tDPRINTF(\"%s: session %d: header '%s: %s'\", __func__,\n\t\t    clt->clt_id, key, value);\n\n\t\t/*\n\t\t * Identify and handle specific HTTP request methods\n\t\t */\n\t\tif (clt->clt_line == 1) {\n\t\t\tif ((desc->http_method = server_httpmethod_byname(key))\n\t\t\t    == HTTP_METHOD_NONE) {\n\t\t\t\tserver_abort_http(clt, 400, \"malformed\");\n\t\t\t\tgoto abort;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Decode request path and query\n\t\t\t */\n\t\t\tdesc->http_path = strdup(value);\n\t\t\tif (desc->http_path == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\tdesc->http_version = strchr(desc->http_path, ' ');\n\t\t\tif (desc->http_version == NULL) {\n\t\t\t\tserver_abort_http(clt, 400, \"malformed\");\n\t\t\t\tgoto abort;\n\t\t\t}\n\n\t\t\t*desc->http_version++ = '\\0';\n\t\t\tdesc->http_query = strchr(desc->http_path, '?');\n\t\t\tif (desc->http_query != NULL)\n\t\t\t\t*desc->http_query++ = '\\0';\n\n\t\t\t/*\n\t\t\t * Have to allocate the strings because they could\n\t\t\t * be changed independently by the filters later.\n\t\t\t */\n\t\t\tif ((desc->http_version =\n\t\t\t    strdup(desc->http_version)) == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\tif (desc->http_query != NULL &&\n\t\t\t    (desc->http_query =\n\t\t\t    strdup(desc->http_query)) == NULL)\n\t\t\t\tgoto fail;\n\n\t\t} else if (desc->http_method != HTTP_METHOD_NONE &&\n\t\t    strcasecmp(\"Content-Length\", key) == 0) {\n\t\t\tif (desc->http_method == HTTP_METHOD_TRACE ||\n\t\t\t    desc->http_method == HTTP_METHOD_CONNECT) {\n\t\t\t\t/*\n\t\t\t\t * These method should not have a body\n\t\t\t\t * and thus no Content-Length header.\n\t\t\t\t */\n\t\t\t\tserver_abort_http(clt, 400, \"malformed\");\n\t\t\t\tgoto abort;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Need to read data from the client after the\n\t\t\t * HTTP header.\n\t\t\t * XXX What about non-standard clients not using\n\t\t\t * the carriage return? And some browsers seem to\n\t\t\t * include the line length in the content-length.\n\t\t\t */\n\t\t\tclt->clt_toread = strtonum(value, 0, LLONG_MAX,\n\t\t\t    &errstr);\n\t\t\tif (errstr) {\n\t\t\t\tserver_abort_http(clt, 500, errstr);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tif ((size_t)clt->clt_toread >\n\t\t\t    srv_conf->maxrequestbody) {\n\t\t\t\tserver_abort_http(clt, 413, NULL);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\n\t\tif (strcasecmp(\"Transfer-Encoding\", key) == 0 &&\n\t\t    strcasecmp(\"chunked\", value) == 0)\n\t\t\tdesc->http_chunked = 1;\n\n\t\tif (clt->clt_line != 1) {\n\t\t\tif ((hdr = kv_add(&desc->http_headers, key,\n\t\t\t    value)) == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\tdesc->http_lastheader = hdr;\n\t\t}\n\n\t\tfree(line);\n\t}\n\tif (clt->clt_headersdone) {\n\t\tif (desc->http_method == HTTP_METHOD_NONE) {\n\t\t\tserver_abort_http(clt, 406, \"no method\");\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (desc->http_method) {\n\t\tcase HTTP_METHOD_CONNECT:\n\t\t\t/* Data stream */\n\t\t\tclt->clt_toread = TOREAD_UNLIMITED;\n\t\t\tbev->readcb = server_read;\n\t\t\tbreak;\n\t\tcase HTTP_METHOD_DELETE:\n\t\tcase HTTP_METHOD_GET:\n\t\tcase HTTP_METHOD_HEAD:\n\t\t/* WebDAV methods */\n\t\tcase HTTP_METHOD_COPY:\n\t\tcase HTTP_METHOD_MOVE:\n\t\t\tclt->clt_toread = 0;\n\t\t\tbreak;\n\t\tcase HTTP_METHOD_OPTIONS:\n\t\tcase HTTP_METHOD_POST:\n\t\tcase HTTP_METHOD_PUT:\n\t\tcase HTTP_METHOD_RESPONSE:\n\t\t/* WebDAV methods */\n\t\tcase HTTP_METHOD_PROPFIND:\n\t\tcase HTTP_METHOD_PROPPATCH:\n\t\tcase HTTP_METHOD_MKCOL:\n\t\tcase HTTP_METHOD_LOCK:\n\t\tcase HTTP_METHOD_UNLOCK:\n\t\tcase HTTP_METHOD_VERSION_CONTROL:\n\t\tcase HTTP_METHOD_REPORT:\n\t\tcase HTTP_METHOD_CHECKOUT:\n\t\tcase HTTP_METHOD_CHECKIN:\n\t\tcase HTTP_METHOD_UNCHECKOUT:\n\t\tcase HTTP_METHOD_MKWORKSPACE:\n\t\tcase HTTP_METHOD_UPDATE:\n\t\tcase HTTP_METHOD_LABEL:\n\t\tcase HTTP_METHOD_MERGE:\n\t\tcase HTTP_METHOD_BASELINE_CONTROL:\n\t\tcase HTTP_METHOD_MKACTIVITY:\n\t\tcase HTTP_METHOD_ORDERPATCH:\n\t\tcase HTTP_METHOD_ACL:\n\t\tcase HTTP_METHOD_MKREDIRECTREF:\n\t\tcase HTTP_METHOD_UPDATEREDIRECTREF:\n\t\tcase HTTP_METHOD_SEARCH:\n\t\tcase HTTP_METHOD_PATCH:\n\t\t\t/* HTTP request payload */\n\t\t\tif (clt->clt_toread > 0)\n\t\t\t\tbev->readcb = server_read_httpcontent;\n\n\t\t\t/* Single-pass HTTP body */\n\t\t\tif (clt->clt_toread < 0) {\n\t\t\t\tclt->clt_toread = TOREAD_UNLIMITED;\n\t\t\t\tbev->readcb = server_read;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tserver_abort_http(clt, 405, \"method not allowed\");\n\t\t\treturn;\n\t\t}\n\t\tif (desc->http_chunked) {\n\t\t\t/* Chunked transfer encoding */\n\t\t\tclt->clt_toread = TOREAD_HTTP_CHUNK_LENGTH;\n\t\t\tbev->readcb = server_read_httpchunks;\n\t\t}\n\n done:\n\t\tif (clt->clt_toread != 0)\n\t\t\tbufferevent_disable(bev, EV_READ);\n\t\tserver_response(httpd_env, clt);\n\t\treturn;\n\t}\n\tif (clt->clt_done) {\n\t\tserver_close(clt, \"done\");\n\t\treturn;\n\t}\n\tif (EVBUFFER_LENGTH(src) && bev->readcb != server_read_http)\n\t\tbev->readcb(bev, arg);\n\tbufferevent_enable(bev, EV_READ);\n\treturn;\n fail:\n\tserver_abort_http(clt, 500, strerror(errno));\n abort:\n\tfree(line);\n}\n\nvoid\nserver_read_httpcontent(struct bufferevent *bev, void *arg)\n{\n\tstruct client\t\t*clt = arg;\n\tstruct evbuffer\t\t*src = EVBUFFER_INPUT(bev);\n\tsize_t\t\t\t size;\n\n\tgetmonotime(&clt->clt_tv_last);\n\n\tsize = EVBUFFER_LENGTH(src);\n\tDPRINTF(\"%s: session %d: size %lu, to read %lld\", __func__,\n\t    clt->clt_id, size, clt->clt_toread);\n\tif (!size)\n\t\treturn;\n\n\tif (clt->clt_toread > 0) {\n\t\t/* Read content data */\n\t\tif ((off_t)size > clt->clt_toread) {\n\t\t\tsize = clt->clt_toread;\n\t\t\tif (fcgi_add_stdin(clt, src) == -1)\n\t\t\t\tgoto fail;\n\t\t\tclt->clt_toread = 0;\n\t\t} else {\n\t\t\tif (fcgi_add_stdin(clt, src) == -1)\n\t\t\t\tgoto fail;\n\t\t\tclt->clt_toread -= size;\n\t\t}\n\t\tDPRINTF(\"%s: done, size %lu, to read %lld\", __func__,\n\t\t    size, clt->clt_toread);\n\t}\n\tif (clt->clt_toread == 0) {\n\t\tfcgi_add_stdin(clt, NULL);\n\t\tclt->clt_toread = TOREAD_HTTP_HEADER;\n\t\tbufferevent_disable(bev, EV_READ);\n\t\tbev->readcb = server_read_http;\n\t\treturn;\n\t}\n\tif (clt->clt_done)\n\t\tgoto done;\n\tif (bev->readcb != server_read_httpcontent)\n\t\tbev->readcb(bev, arg);\n\n\treturn;\n done:\n\treturn;\n fail:\n\tserver_close(clt, strerror(errno));\n}\n\nvoid\nserver_read_httpchunks(struct bufferevent *bev, void *arg)\n{\n\tstruct client\t\t*clt = arg;\n\tstruct evbuffer\t\t*src = EVBUFFER_INPUT(bev);\n\tchar\t\t\t*line;\n\tlong long\t\t llval;\n\tsize_t\t\t\t size;\n\n\tgetmonotime(&clt->clt_tv_last);\n\n\tsize = EVBUFFER_LENGTH(src);\n\tDPRINTF(\"%s: session %d: size %lu, to read %lld\", __func__,\n\t    clt->clt_id, size, clt->clt_toread);\n\tif (!size)\n\t\treturn;\n\n\tif (clt->clt_toread > 0) {\n\t\t/* Read chunk data */\n\t\tif ((off_t)size > clt->clt_toread) {\n\t\t\tsize = clt->clt_toread;\n\t\t\tif (server_bufferevent_write_chunk(clt, src, size)\n\t\t\t    == -1)\n\t\t\t\tgoto fail;\n\t\t\tclt->clt_toread = 0;\n\t\t} else {\n\t\t\tif (server_bufferevent_write_buffer(clt, src) == -1)\n\t\t\t\tgoto fail;\n\t\t\tclt->clt_toread -= size;\n\t\t}\n\t\tDPRINTF(\"%s: done, size %lu, to read %lld\", __func__,\n\t\t    size, clt->clt_toread);\n\t}\n\tswitch (clt->clt_toread) {\n\tcase TOREAD_HTTP_CHUNK_LENGTH:\n\t\tline = evbuffer_readln(src, NULL, EVBUFFER_EOL_CRLF_STRICT);\n\t\tif (line == NULL) {\n\t\t\t/* Ignore empty line, continue */\n\t\t\tbufferevent_enable(bev, EV_READ);\n\t\t\treturn;\n\t\t}\n\t\tif (strlen(line) == 0) {\n\t\t\tfree(line);\n\t\t\tgoto next;\n\t\t}\n\n\t\t/*\n\t\t * Read prepended chunk size in hex, ignore the trailer.\n\t\t * The returned signed value must not be negative.\n\t\t */\n\t\tif (sscanf(line, \"%llx\", &llval) != 1 || llval < 0) {\n\t\t\tfree(line);\n\t\t\tserver_close(clt, \"invalid chunk size\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (server_bufferevent_print(clt, line) == -1 ||\n\t\t    server_bufferevent_print(clt, \"\\r\\n\") == -1) {\n\t\t\tfree(line);\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(line);\n\n\t\tif ((clt->clt_toread = llval) == 0) {\n\t\t\tDPRINTF(\"%s: last chunk\", __func__);\n\t\t\tclt->clt_toread = TOREAD_HTTP_CHUNK_TRAILER;\n\t\t}\n\t\tbreak;\n\tcase TOREAD_HTTP_CHUNK_TRAILER:\n\t\t/* Last chunk is 0 bytes followed by trailer and empty line */\n\t\tline = evbuffer_readln(src, NULL, EVBUFFER_EOL_CRLF_STRICT);\n\t\tif (line == NULL) {\n\t\t\t/* Ignore empty line, continue */\n\t\t\tbufferevent_enable(bev, EV_READ);\n\t\t\treturn;\n\t\t}\n\t\tif (server_bufferevent_print(clt, line) == -1 ||\n\t\t    server_bufferevent_print(clt, \"\\r\\n\") == -1) {\n\t\t\tfree(line);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (strlen(line) == 0) {\n\t\t\t/* Switch to HTTP header mode */\n\t\t\tclt->clt_toread = TOREAD_HTTP_HEADER;\n\t\t\tbev->readcb = server_read_http;\n\t\t}\n\t\tfree(line);\n\t\tbreak;\n\tcase 0:\n\t\t/* Chunk is terminated by an empty newline */\n\t\tline = evbuffer_readln(src, NULL, EVBUFFER_EOL_CRLF_STRICT);\n\t\tfree(line);\n\t\tif (server_bufferevent_print(clt, \"\\r\\n\") == -1)\n\t\t\tgoto fail;\n\t\tclt->clt_toread = TOREAD_HTTP_CHUNK_LENGTH;\n\t\tbreak;\n\t}\n\n next:\n\tif (clt->clt_done)\n\t\tgoto done;\n\tif (EVBUFFER_LENGTH(src))\n\t\tbev->readcb(bev, arg);\n\tbufferevent_enable(bev, EV_READ);\n\treturn;\n\n done:\n\tserver_close(clt, \"last http chunk read (done)\");\n\treturn;\n fail:\n\tserver_close(clt, strerror(errno));\n}\n\nvoid\nserver_reset_http(struct client *clt)\n{\n\tstruct server\t\t*srv = clt->clt_srv;\n\n\tserver_log(clt, NULL);\n\n\tserver_httpdesc_free(clt->clt_descreq);\n\tserver_httpdesc_free(clt->clt_descresp);\n\tclt->clt_headerlen = 0;\n\tclt->clt_headersdone = 0;\n\tclt->clt_done = 0;\n\tclt->clt_line = 0;\n\tclt->clt_chunk = 0;\n\tfree(clt->clt_remote_user);\n\tclt->clt_remote_user = NULL;\n\tclt->clt_bev->readcb = server_read_http;\n\tclt->clt_srv_conf = &srv->srv_conf;\n\tstr_match_free(&clt->clt_srv_match);\n}\n\nssize_t\nserver_http_time(time_t t, char *tmbuf, size_t len)\n{\n\tstruct tm\t\t tm;\n\n\t/* New HTTP/1.1 RFC 7231 prefers IMF-fixdate from RFC 5322 */\n\tif (t == -1 || gmtime_r(&t, &tm) == NULL)\n\t\treturn (-1);\n\telse\n\t\treturn (strftime(tmbuf, len, \"%a, %d %h %Y %T %Z\", &tm));\n}\n\nconst char *\nserver_http_host(struct sockaddr_storage *ss, char *buf, size_t len)\n{\n\tchar\t\thbuf[HOST_NAME_MAX+1];\n\tin_port_t\tport;\n\n\tif (print_host(ss, buf, len) == NULL)\n\t\treturn (NULL);\n\n\tport = ntohs(server_socket_getport(ss));\n\tif (port == HTTP_PORT)\n\t\treturn (buf);\n\n\tswitch (ss->ss_family) {\n\tcase AF_INET:\n\t\tif ((size_t)snprintf(hbuf, sizeof(hbuf),\n\t\t    \"%s:%u\", buf, port) >= sizeof(hbuf))\n\t\t\treturn (NULL);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif ((size_t)snprintf(hbuf, sizeof(hbuf),\n\t\t    \"[%s]:%u\", buf, port) >= sizeof(hbuf))\n\t\t\treturn (NULL);\n\t\tbreak;\n\t}\n\n\tif (strlcpy(buf, hbuf, len) >= len)\n\t\treturn (NULL);\n\n\treturn (buf);\n}\n\nchar *\nserver_http_parsehost(char *host, char *buf, size_t len, int *portval)\n{\n\tchar\t\t*start, *end, *port;\n\tconst char\t*errstr = NULL;\n\n\tif (strlcpy(buf, host, len) >= len) {\n\t\tlog_debug(\"%s: host name too long\", __func__);\n\t\treturn (NULL);\n\t}\n\n\tstart = buf;\n\tend = port = NULL;\n\n\tif (*start == '[' && (end = strchr(start, ']')) != NULL) {\n\t\t/* Address enclosed in [] with port, eg. [2001:db8::1]:80 */\n\t\tstart++;\n\t\t*end++ = '\\0';\n\t\tif ((port = strchr(end, ':')) == NULL || *port == '\\0')\n\t\t\tport = NULL;\n\t\telse\n\t\t\tport++;\n\t\tmemmove(buf, start, strlen(start) + 1);\n\t} else if ((end = strchr(start, ':')) != NULL) {\n\t\t/* Name or address with port, eg. www.example.com:80 */\n\t\t*end++ = '\\0';\n\t\tport = end;\n\t} else {\n\t\t/* Name or address with default port, eg. www.example.com */\n\t\tport = NULL;\n\t}\n\n\tif (port != NULL) {\n\t\t/* Save the requested port */\n\t\t*portval = strtonum(port, 0, 0xffff, &errstr);\n\t\tif (errstr != NULL) {\n\t\t\tlog_debug(\"%s: invalid port: %s\", __func__,\n\t\t\t    strerror(errno));\n\t\t\treturn (NULL);\n\t\t}\n\t\t*portval = htons(*portval);\n\t} else {\n\t\t/* Port not given, indicate the default port */\n\t\t*portval = -1;\n\t}\n\n\treturn (start);\n}\n\nvoid\nserver_abort_http(struct client *clt, unsigned int code, const char *msg)\n{\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tstruct bufferevent\t*bev = clt->clt_bev;\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tconst char\t\t*httperr = NULL, *style;\n\tchar\t\t\t*httpmsg, *body = NULL, *extraheader = NULL;\n\tchar\t\t\t tmbuf[32], hbuf[128], *hstsheader = NULL;\n\tchar\t\t\t buf[IBUF_READ_SIZE];\n\tchar\t\t\t*escapedmsg = NULL;\n\tint\t\t\t bodylen;\n\n\tif (code == 0) {\n\t\tserver_close(clt, \"dropped\");\n\t\treturn;\n\t}\n\n\tif ((httperr = server_httperror_byid(code)) == NULL)\n\t\thttperr = \"Unknown Error\";\n\n\tif (bev == NULL)\n\t\tgoto done;\n\n\tif (server_log_http(clt, code, 0) == -1)\n\t\tgoto done;\n\n\t/* Some system information */\n\tif (print_host(&srv_conf->ss, hbuf, sizeof(hbuf)) == NULL)\n\t\tgoto done;\n\n\tif (server_http_time(time(NULL), tmbuf, sizeof(tmbuf)) <= 0)\n\t\tgoto done;\n\n\t/* Do not send details of the Internal Server Error */\n\tswitch (code) {\n\tcase 301:\n\tcase 302:\n\tcase 303:\n\t\tif (msg == NULL)\n\t\t\tbreak;\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tif (server_expand_http(clt, msg, buf, sizeof(buf)) == NULL)\n\t\t\tgoto done;\n\t\tif (asprintf(&extraheader, \"Location: %s\\r\\n\", buf) == -1) {\n\t\t\tcode = 500;\n\t\t\textraheader = NULL;\n\t\t}\n\t\tmsg = buf;\n\t\tbreak;\n\tcase 401:\n\t\tif (stravis(&escapedmsg, msg, VIS_DQ) == -1) {\n\t\t\tcode = 500;\n\t\t\textraheader = NULL;\n\t\t} else if (asprintf(&extraheader,\n\t\t    \"WWW-Authenticate: Basic realm=\\\"%s\\\"\\r\\n\", escapedmsg)\n\t\t    == -1) {\n\t\t\tcode = 500;\n\t\t\textraheader = NULL;\n\t\t}\n\t\tbreak;\n\tcase 416:\n\t\tif (asprintf(&extraheader,\n\t\t    \"Content-Range: %s\\r\\n\", msg) == -1) {\n\t\t\tcode = 500;\n\t\t\textraheader = NULL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Do not send details of the error.  Traditionally,\n\t\t * web servers responsed with the request path on 40x\n\t\t * errors which could be abused to inject JavaScript etc.\n\t\t * Instead of sanitizing the path here, we just don't\n\t\t * reprint it.\n\t\t */\n\t\tbreak;\n\t}\n\n\tfree(escapedmsg);\n\n\t/* A CSS stylesheet allows minimal customization by the user */\n\tstyle = \"body { background-color: white; color: black; font-family: \"\n\t    \"'Comic Sans MS', 'Chalkboard SE', 'Comic Neue', sans-serif; }\\n\"\n\t    \"hr { border: 0; border-bottom: 1px dashed; }\\n\";\n\n\t/* Generate simple HTML error document */\n\tif ((bodylen = asprintf(&body,\n\t    \"<!DOCTYPE html>\\n\"\n\t    \"<html>\\n\"\n\t    \"<head>\\n\"\n\t    \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; \"\n\t    \"charset=utf-8\\\"/>\\n\"\n\t    \"<title>%03d %s</title>\\n\"\n\t    \"<style type=\\\"text/css\\\"><!--\\n%s\\n--></style>\\n\"\n\t    \"</head>\\n\"\n\t    \"<body>\\n\"\n\t    \"<h1>%03d %s</h1>\\n\"\n\t    \"<hr>\\n<address>%s</address>\\n\"\n\t    \"</body>\\n\"\n\t    \"</html>\\n\",\n\t    code, httperr, style, code, httperr, HTTPD_SERVERNAME)) == -1) {\n\t\tbody = NULL;\n\t\tgoto done;\n\t}\n\n\tif (srv_conf->flags & SRVFLAG_SERVER_HSTS) {\n\t\tif (asprintf(&hstsheader, \"Strict-Transport-Security: \"\n\t\t    \"max-age=%d%s%s\\r\\n\", srv_conf->hsts_max_age,\n\t\t    srv_conf->hsts_flags & HSTSFLAG_SUBDOMAINS ?\n\t\t    \"; includeSubDomains\" : \"\",\n\t\t    srv_conf->hsts_flags & HSTSFLAG_PRELOAD ?\n\t\t    \"; preload\" : \"\") == -1) {\n\t\t\thstsheader = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Add basic HTTP headers */\n\tif (asprintf(&httpmsg,\n\t    \"HTTP/1.0 %03d %s\\r\\n\"\n\t    \"Date: %s\\r\\n\"\n\t    \"Server: %s\\r\\n\"\n\t    \"Connection: close\\r\\n\"\n\t    \"Content-Type: text/html\\r\\n\"\n\t    \"Content-Length: %d\\r\\n\"\n\t    \"%s\"\n\t    \"%s\"\n\t    \"\\r\\n\"\n\t    \"%s\",\n\t    code, httperr, tmbuf, HTTPD_SERVERNAME, bodylen,\n\t    extraheader == NULL ? \"\" : extraheader,\n\t    hstsheader == NULL ? \"\" : hstsheader,\n\t    desc->http_method == HTTP_METHOD_HEAD ? \"\" : body) == -1)\n\t\tgoto done;\n\n\t/* Dump the message without checking for success */\n\tserver_dump(clt, httpmsg, strlen(httpmsg));\n\tfree(httpmsg);\n\n done:\n\tfree(body);\n\tfree(extraheader);\n\tfree(hstsheader);\n\tif (msg == NULL)\n\t\tmsg = \"\\\"\\\"\";\n\tif (asprintf(&httpmsg, \"%s (%03d %s)\", msg, code, httperr) == -1) {\n\t\tserver_close(clt, msg);\n\t} else {\n\t\tserver_close(clt, httpmsg);\n\t\tfree(httpmsg);\n\t}\n}\n\nvoid\nserver_close_http(struct client *clt)\n{\n\tstruct http_descriptor *desc;\n\n\tdesc = clt->clt_descreq;\n\tserver_httpdesc_free(desc);\n\tfree(desc);\n\tclt->clt_descreq = NULL;\n\n\tdesc = clt->clt_descresp;\n\tserver_httpdesc_free(desc);\n\tfree(desc);\n\tclt->clt_descresp = NULL;\n\tfree(clt->clt_remote_user);\n\tclt->clt_remote_user = NULL;\n\n\tstr_match_free(&clt->clt_srv_match);\n}\n\nchar *\nserver_expand_http(struct client *clt, const char *val, char *buf,\n    size_t len)\n{\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tchar\t\t\t ibuf[128], *str, *path, *query;\n\tconst char\t\t*errstr = NULL, *p;\n\tsize_t\t\t\t size;\n\tint\t\t\t n, ret;\n\n\tif (strlcpy(buf, val, len) >= len)\n\t\treturn (NULL);\n\n\t/* Find previously matched substrings by index */\n\tfor (p = val; clt->clt_srv_match.sm_nmatch &&\n\t    (p = strstr(p, \"%\")) != NULL; p++) {\n\t\tif (!isdigit((unsigned char)*(p + 1)))\n\t\t\tcontinue;\n\n\t\t/* Copy number, leading '%' char and add trailing \\0 */\n\t\tsize = strspn(p + 1, \"0123456789\") + 2;\n\t\tif (size  >= sizeof(ibuf))\n\t\t\treturn (NULL);\n\t\t(void)strlcpy(ibuf, p, size);\n\t\tn = strtonum(ibuf + 1, 0,\n\t\t    clt->clt_srv_match.sm_nmatch - 1, &errstr);\n\t\tif (errstr != NULL)\n\t\t\treturn (NULL);\n\n\t\t/* Expand variable with matched value */\n\t\tif ((str = url_encode(clt->clt_srv_match.sm_match[n])) == NULL)\n\t\t\treturn (NULL);\n\t\tret = expand_string(buf, len, ibuf, str);\n\t\tfree(str);\n\t\tif (ret != 0)\n\t\t\treturn (NULL);\n\t}\n\tif (strstr(val, \"$DOCUMENT_URI\") != NULL) {\n\t\tif ((path = url_encode(desc->http_path)) == NULL)\n\t\t\treturn (NULL);\n\t\tret = expand_string(buf, len, \"$DOCUMENT_URI\", path);\n\t\tfree(path);\n\t\tif (ret != 0)\n\t\t\treturn (NULL);\n\t}\n\tif (strstr(val, \"$QUERY_STRING\") != NULL) {\n\t\tif (desc->http_query == NULL) {\n\t\t\tret = expand_string(buf, len, \"$QUERY_STRING\", \"\");\n\t\t} else {\n\t\t\tif ((query = url_encode(desc->http_query)) == NULL)\n\t\t\t\treturn (NULL);\n\t\t\tret = expand_string(buf, len, \"$QUERY_STRING\", query);\n\t\t\tfree(query);\n\t\t}\n\t\tif (ret != 0)\n\t\t\treturn (NULL);\n\t}\n\tif (strstr(val, \"$REMOTE_\") != NULL) {\n\t\tif (strstr(val, \"$REMOTE_ADDR\") != NULL) {\n\t\t\tif (print_host(&clt->clt_ss,\n\t\t\t    ibuf, sizeof(ibuf)) == NULL)\n\t\t\t\treturn (NULL);\n\t\t\tif (expand_string(buf, len,\n\t\t\t    \"$REMOTE_ADDR\", ibuf) != 0)\n\t\t\t\treturn (NULL);\n\t\t}\n\t\tif (strstr(val, \"$REMOTE_PORT\") != NULL) {\n\t\t\tsnprintf(ibuf, sizeof(ibuf),\n\t\t\t    \"%u\", ntohs(clt->clt_port));\n\t\t\tif (expand_string(buf, len,\n\t\t\t    \"$REMOTE_PORT\", ibuf) != 0)\n\t\t\t\treturn (NULL);\n\t\t}\n\t\tif (strstr(val, \"$REMOTE_USER\") != NULL) {\n\t\t\tif ((srv_conf->flags & SRVFLAG_AUTH) &&\n\t\t\t    clt->clt_remote_user != NULL) {\n\t\t\t\tif ((str = url_encode(clt->clt_remote_user))\n\t\t\t\t    == NULL)\n\t\t\t\t\treturn (NULL);\n\t\t\t} else\n\t\t\t\tstr = strdup(\"\");\n\t\t\tret = expand_string(buf, len, \"$REMOTE_USER\", str);\n\t\t\tfree(str);\n\t\t\tif (ret != 0)\n\t\t\t\treturn (NULL);\n\t\t}\n\t}\n\tif (strstr(val, \"$REQUEST_URI\") != NULL) {\n\t\tif ((path = url_encode(desc->http_path)) == NULL)\n\t\t\treturn (NULL);\n\t\tif (desc->http_query == NULL) {\n\t\t\tstr = path;\n\t\t} else {\n\t\t\tif ((query = url_encode(desc->http_query)) == NULL) {\n\t\t\t\tfree(path);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tret = asprintf(&str, \"%s?%s\", path, query);\n\t\t\tfree(path);\n\t\t\tfree(query);\n\t\t\tif (ret == -1)\n\t\t\t\treturn (NULL);\n\t\t}\n\n\t\tret = expand_string(buf, len, \"$REQUEST_URI\", str);\n\t\tfree(str);\n\t\tif (ret != 0)\n\t\t\treturn (NULL);\n\t}\n\tif (strstr(val, \"$SERVER_\") != NULL) {\n\t\tif (strstr(val, \"$SERVER_ADDR\") != NULL) {\n\t\t\tif (print_host(&srv_conf->ss,\n\t\t\t    ibuf, sizeof(ibuf)) == NULL)\n\t\t\t\treturn (NULL);\n\t\t\tif (expand_string(buf, len,\n\t\t\t    \"$SERVER_ADDR\", ibuf) != 0)\n\t\t\t\treturn (NULL);\n\t\t}\n\t\tif (strstr(val, \"$SERVER_PORT\") != NULL) {\n\t\t\tsnprintf(ibuf, sizeof(ibuf), \"%u\",\n\t\t\t    ntohs(srv_conf->port));\n\t\t\tif (expand_string(buf, len,\n\t\t\t    \"$SERVER_PORT\", ibuf) != 0)\n\t\t\t\treturn (NULL);\n\t\t}\n\t\tif (strstr(val, \"$SERVER_NAME\") != NULL) {\n\t\t\tif ((str = url_encode(srv_conf->name))\n\t\t\t     == NULL)\n\t\t\t\treturn (NULL);\n\t\t\tret = expand_string(buf, len, \"$SERVER_NAME\", str);\n\t\t\tfree(str);\n\t\t\tif (ret != 0)\n\t\t\t\treturn (NULL);\n\t\t}\n\t}\n\n\treturn (buf);\n}\n\nint\nserver_response(struct httpd *httpd, struct client *clt)\n{\n\tchar\t\t\t path[PATH_MAX];\n\tchar\t\t\t hostname[HOST_NAME_MAX+1];\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct server\t\t*srv = clt->clt_srv;\n\tstruct server_config\t*srv_conf = &srv->srv_conf;\n\tstruct kv\t\t*kv, key, *host;\n\tstruct str_find\t\t sm;\n\tint\t\t\t portval = -1, ret;\n\tchar\t\t\t*hostval;\n\tconst char\t\t*errstr = NULL;\n\n\t/* Canonicalize the request path */\n\tif (desc->http_path == NULL ||\n\t    url_decode(desc->http_path) == NULL ||\n\t    canonicalize_path(desc->http_path, path, sizeof(path)) == NULL)\n\t\tgoto fail;\n\tfree(desc->http_path);\n\tif ((desc->http_path = strdup(path)) == NULL)\n\t\tgoto fail;\n\n\tkey.kv_key = \"Host\";\n\tif ((host = kv_find(&desc->http_headers, &key)) != NULL &&\n\t    host->kv_value == NULL)\n\t\thost = NULL;\n\n\tif (strcmp(desc->http_version, \"HTTP/1.1\") == 0) {\n\t\t/* Host header is mandatory */\n\t\tif (host == NULL)\n\t\t\tgoto fail;\n\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"close\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist = 0;\n\t\telse\n\t\t\tclt->clt_persist++;\n\t} else {\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"keep-alive\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist++;\n\t\telse\n\t\t\tclt->clt_persist = 0;\n\t}\n\n\tif (clt->clt_persist >= srv_conf->maxrequests)\n\t\tclt->clt_persist = 0;\n\n\t/*\n\t * Do we have a Host header and matching configuration?\n\t * XXX the Host can also appear in the URL path.\n\t */\n\tif (host != NULL) {\n\t\tif ((hostval = server_http_parsehost(host->kv_value,\n\t\t    hostname, sizeof(hostname), &portval)) == NULL)\n\t\t\tgoto fail;\n\n\t\tTAILQ_FOREACH(srv_conf, &srv->srv_hosts, entry) {\n#ifdef DEBUG\n\t\t\tif ((srv_conf->flags & SRVFLAG_LOCATION) == 0) {\n\t\t\t\tDPRINTF(\"%s: virtual host \\\"%s:%u\\\"\"\n\t\t\t\t    \" host \\\"%s\\\" (\\\"%s\\\")\",\n\t\t\t\t    __func__, srv_conf->name,\n\t\t\t\t    ntohs(srv_conf->port), host->kv_value,\n\t\t\t\t    hostname);\n\t\t\t}\n#endif\n\t\t\tif (srv_conf->flags & SRVFLAG_LOCATION)\n\t\t\t\tcontinue;\n\t\t\telse if (srv_conf->flags & SRVFLAG_SERVER_MATCH) {\n\t\t\t\tstr_find(hostname, srv_conf->name,\n\t\t\t\t    &sm, 1, &errstr);\n\t\t\t\tret = errstr == NULL ? 0 : -1;\n\t\t\t} else {\n\t\t\t\tret = fnmatch(srv_conf->name,\n\t\t\t\t    hostname, FNM_CASEFOLD);\n\t\t\t}\n\t\t\tif (ret == 0 &&\n\t\t\t    (portval == -1 ||\n\t\t\t    (portval != -1 && portval == srv_conf->port))) {\n\t\t\t\t/* Replace host configuration */\n\t\t\t\tclt->clt_srv_conf = srv_conf;\n\t\t\t\tsrv_conf = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (srv_conf != NULL) {\n\t\t/* Use the actual server IP address */\n\t\tif (server_http_host(&clt->clt_srv_ss, hostname,\n\t\t    sizeof(hostname)) == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\t/* Host header was valid and found */\n\t\tif (strlcpy(hostname, host->kv_value, sizeof(hostname)) >=\n\t\t    sizeof(hostname))\n\t\t\tgoto fail;\n\t\tsrv_conf = clt->clt_srv_conf;\n\t}\n\n\tif ((desc->http_host = strdup(hostname)) == NULL)\n\t\tgoto fail;\n\n\t/* Now fill in the mandatory parts of the response descriptor */\n\tresp->http_method = desc->http_method;\n\tif ((resp->http_version = strdup(desc->http_version)) == NULL)\n\t\tgoto fail;\n\n\t/* Now search for the location */\n\tsrv_conf = server_getlocation(clt, desc->http_path);\n\n\tif (srv_conf->flags & SRVFLAG_BLOCK) {\n\t\tserver_abort_http(clt, srv_conf->return_code,\n\t\t    srv_conf->return_uri);\n\t\treturn (-1);\n\t} else if (srv_conf->flags & SRVFLAG_AUTH &&\n\t    server_http_authenticate(srv_conf, clt) == -1) {\n\t\tserver_abort_http(clt, 401, srv_conf->auth_realm);\n\t\treturn (-1);\n\t} else\n\t\treturn (server_file(httpd, clt));\n fail:\n\tserver_abort_http(clt, 400, \"bad request\");\n\treturn (-1);\n}\n\nconst char *\nserver_root_strip(const char *path, int n)\n{\n\tconst char *p;\n\n\t/* Strip strip leading directories. Leading '/' is ignored. */\n\tfor (; n > 0 && *path != '\\0'; n--)\n\t\tif ((p = strchr(++path, '/')) == NULL)\n\t\t\tpath = strchr(path, '\\0');\n\t\telse\n\t\t\tpath = p;\n\n\treturn (path);\n}\n\nstruct server_config *\nserver_getlocation(struct client *clt, const char *path)\n{\n\tstruct server\t\t*srv = clt->clt_srv;\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf, *location;\n\tconst char\t\t*errstr = NULL;\n\tint\t\t\t ret;\n\n\t/* Now search for the location */\n\tTAILQ_FOREACH(location, &srv->srv_hosts, entry) {\n#ifdef DEBUG\n\t\tif (location->flags & SRVFLAG_LOCATION) {\n\t\t\tDPRINTF(\"%s: location \\\"%s\\\" path \\\"%s\\\"\",\n\t\t\t    __func__, location->location, path);\n\t\t}\n#endif\n\t\tif ((location->flags & SRVFLAG_LOCATION) &&\n\t\t    location->parent_id == srv_conf->parent_id) {\n\t\t\terrstr = NULL;\n\t\t\tif (location->flags & SRVFLAG_LOCATION_MATCH) {\n\t\t\t\tret = str_match(path, location->location,\n\t\t\t\t    &clt->clt_srv_match, &errstr);\n\t\t\t} else {\n\t\t\t\tret = fnmatch(location->location,\n\t\t\t\t    path, FNM_CASEFOLD);\n\t\t\t}\n\t\t\tif (ret == 0 && errstr == NULL) {\n\t\t\t\t/* Replace host configuration */\n\t\t\t\tclt->clt_srv_conf = srv_conf = location;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (srv_conf);\n}\n\nint\nserver_response_http(struct client *clt, unsigned int code,\n    struct media_type *media, off_t size, time_t mtime)\n{\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tconst char\t\t*error;\n\tstruct kv\t\t*ct, *cl;\n\tchar\t\t\t tmbuf[32];\n\n\tif (desc == NULL || media == NULL ||\n\t    (error = server_httperror_byid(code)) == NULL)\n\t\treturn (-1);\n\n\tif (server_log_http(clt, code, size) == -1)\n\t\treturn (-1);\n\n\t/* Add error codes */\n\tif (kv_setkey(&resp->http_pathquery, \"%u\", code) == -1 ||\n\t    kv_set(&resp->http_pathquery, \"%s\", error) == -1)\n\t\treturn (-1);\n\n\t/* Add headers */\n\tif (kv_add(&resp->http_headers, \"Server\", HTTPD_SERVERNAME) == NULL)\n\t\treturn (-1);\n\n\t/* Is it a persistent connection? */\n\tif (clt->clt_persist) {\n\t\tif (kv_add(&resp->http_headers,\n\t\t    \"Connection\", \"keep-alive\") == NULL)\n\t\t\treturn (-1);\n\t} else if (kv_add(&resp->http_headers, \"Connection\", \"close\") == NULL)\n\t\treturn (-1);\n\n\t/* Set media type */\n\tif ((ct = kv_add(&resp->http_headers, \"Content-Type\", NULL)) == NULL ||\n\t    kv_set(ct, \"%s/%s\", media->media_type, media->media_subtype) == -1)\n\t\treturn (-1);\n\n\t/* Set content length, if specified */\n\tif ((cl =\n\t    kv_add(&resp->http_headers, \"Content-Length\", NULL)) == NULL ||\n\t    kv_set(cl, \"%lld\", (long long)size) == -1)\n\t\treturn (-1);\n\n\t/* Set last modification time */\n\tif (server_http_time(mtime, tmbuf, sizeof(tmbuf)) <= 0 ||\n\t    kv_add(&resp->http_headers, \"Last-Modified\", tmbuf) == NULL)\n\t\treturn (-1);\n\n\t/* HSTS header */\n\tif (srv_conf->flags & SRVFLAG_SERVER_HSTS) {\n\t\tif ((cl =\n\t\t    kv_add(&resp->http_headers, \"Strict-Transport-Security\",\n\t\t    NULL)) == NULL ||\n\t\t    kv_set(cl, \"max-age=%d%s%s\", srv_conf->hsts_max_age,\n\t\t    srv_conf->hsts_flags & HSTSFLAG_SUBDOMAINS ?\n\t\t    \"; includeSubDomains\" : \"\",\n\t\t    srv_conf->hsts_flags & HSTSFLAG_PRELOAD ?\n\t\t    \"; preload\" : \"\") == -1)\n\t\t\treturn (-1);\n\t}\n\n\t/* Date header is mandatory and should be added as late as possible */\n\tif (server_http_time(time(NULL), tmbuf, sizeof(tmbuf)) <= 0 ||\n\t    kv_add(&resp->http_headers, \"Date\", tmbuf) == NULL)\n\t\treturn (-1);\n\n\t/* Write completed header */\n\tif (server_writeresponse_http(clt) == -1 ||\n\t    server_bufferevent_print(clt, \"\\r\\n\") == -1 ||\n\t    server_headers(clt, resp, server_writeheader_http, NULL) == -1 ||\n\t    server_bufferevent_print(clt, \"\\r\\n\") == -1)\n\t\treturn (-1);\n\n\tif (size == 0 || resp->http_method == HTTP_METHOD_HEAD) {\n\t\tbufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);\n\t\tif (clt->clt_persist)\n\t\t\tclt->clt_toread = TOREAD_HTTP_HEADER;\n\t\telse\n\t\t\tclt->clt_toread = TOREAD_HTTP_NONE;\n\t\tclt->clt_done = 0;\n\t\treturn (0);\n\t}\n\n\treturn (1);\n}\n\nint\nserver_writeresponse_http(struct client *clt)\n{\n\tstruct http_descriptor\t*desc = clt->clt_descresp;\n\n\tDPRINTF(\"version: %s rescode: %s resmsg: %s\", desc->http_version,\n\t    desc->http_rescode, desc->http_resmesg);\n\n\tif (server_bufferevent_print(clt, desc->http_version) == -1 ||\n\t    server_bufferevent_print(clt, \" \") == -1 ||\n\t    server_bufferevent_print(clt, desc->http_rescode) == -1 ||\n\t    server_bufferevent_print(clt, \" \") == -1 ||\n\t    server_bufferevent_print(clt, desc->http_resmesg) == -1)\n\t\treturn (-1);\n\n\treturn (0);\n}\n\nint\nserver_writeheader_http(struct client *clt, struct kv *hdr, void *arg)\n{\n\tchar\t\t\t*ptr;\n\tconst char\t\t*key;\n\n\tif (hdr->kv_flags & KV_FLAG_INVALID)\n\t\treturn (0);\n\n\t/* The key might have been updated in the parent */\n\tif (hdr->kv_parent != NULL && hdr->kv_parent->kv_key != NULL)\n\t\tkey = hdr->kv_parent->kv_key;\n\telse\n\t\tkey = hdr->kv_key;\n\n\tptr = hdr->kv_value;\n\tif (server_bufferevent_print(clt, key) == -1 ||\n\t    (ptr != NULL &&\n\t    (server_bufferevent_print(clt, \": \") == -1 ||\n\t    server_bufferevent_print(clt, ptr) == -1 ||\n\t    server_bufferevent_print(clt, \"\\r\\n\") == -1)))\n\t\treturn (-1);\n\tDPRINTF(\"%s: %s: %s\", __func__, key,\n\t    hdr->kv_value == NULL ? \"\" : hdr->kv_value);\n\n\treturn (0);\n}\n\nint\nserver_headers(struct client *clt, void *descp,\n    int (*hdr_cb)(struct client *, struct kv *, void *), void *arg)\n{\n\tstruct kv\t\t*hdr, *kv;\n\tstruct http_descriptor\t*desc = descp;\n\n\tRB_FOREACH(hdr, kvtree, &desc->http_headers) {\n\t\tif ((hdr_cb)(clt, hdr, arg) == -1)\n\t\t\treturn (-1);\n\t\tTAILQ_FOREACH(kv, &hdr->kv_children, kv_entry) {\n\t\t\tif ((hdr_cb)(clt, kv, arg) == -1)\n\t\t\t\treturn (-1);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nenum httpmethod\nserver_httpmethod_byname(const char *name)\n{\n\tenum httpmethod\t\t id = HTTP_METHOD_NONE;\n\tstruct http_method\t method, *res = NULL;\n\n\t/* Set up key */\n\tmethod.method_name = name;\n\n\tif ((res = bsearch(&method, http_methods,\n\t    sizeof(http_methods) / sizeof(http_methods[0]) - 1,\n\t    sizeof(http_methods[0]), server_httpmethod_cmp)) != NULL)\n\t\tid = res->method_id;\n\n\treturn (id);\n}\n\nconst char *\nserver_httpmethod_byid(unsigned int id)\n{\n\tconst char\t*name = \"<UNKNOWN>\";\n\tint\t\t i;\n\n\tfor (i = 0; http_methods[i].method_name != NULL; i++) {\n\t\tif (http_methods[i].method_id == id) {\n\t\t\tname = http_methods[i].method_name;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (name);\n}\n\nstatic int\nserver_httpmethod_cmp(const void *a, const void *b)\n{\n\tconst struct http_method *ma = a;\n\tconst struct http_method *mb = b;\n\n\t/*\n\t * RFC 2616 section 5.1.1 says that the method is case\n\t * sensitive so we don't do a strcasecmp here.\n\t */\n\treturn (strcmp(ma->method_name, mb->method_name));\n}\n\nconst char *\nserver_httperror_byid(unsigned int id)\n{\n\tstruct http_error\t error, *res;\n\n\t/* Set up key */\n\terror.error_code = (int)id;\n\n\tif ((res = bsearch(&error, http_errors,\n\t    sizeof(http_errors) / sizeof(http_errors[0]) - 1,\n\t    sizeof(http_errors[0]), server_httperror_cmp)) != NULL)\n\t\treturn (res->error_name);\n\n\treturn (NULL);\n}\n\nstatic int\nserver_httperror_cmp(const void *a, const void *b)\n{\n\tconst struct http_error *ea = a;\n\tconst struct http_error *eb = b;\n\treturn (ea->error_code - eb->error_code);\n}\n\nint\nserver_log_http(struct client *clt, unsigned int code, size_t len)\n{\n\tstatic char\t\t tstamp[64];\n\tstatic char\t\t ip[INET6_ADDRSTRLEN];\n\ttime_t\t\t\t t;\n\tstruct kv\t\t key, *agent, *referrer;\n\tstruct tm\t\t*tm;\n\tstruct server_config\t*srv_conf;\n\tstruct http_descriptor\t*desc;\n\tint\t\t\t ret = -1;\n\tchar\t\t\t*user = NULL;\n\tchar\t\t\t*path = NULL;\n\tchar\t\t\t*query = NULL;\n\tchar\t\t\t*version = NULL;\n\tchar\t\t\t*referrer_v = NULL;\n\tchar\t\t\t*agent_v = NULL;\n\n\tif ((srv_conf = clt->clt_srv_conf) == NULL)\n\t\treturn (-1);\n\tif ((srv_conf->flags & SRVFLAG_LOG) == 0)\n\t\treturn (0);\n\tif ((desc = clt->clt_descreq) == NULL)\n\t\treturn (-1);\n\n\tif ((t = time(NULL)) == -1)\n\t\treturn (-1);\n\tif ((tm = localtime(&t)) == NULL)\n\t\treturn (-1);\n\tif (strftime(tstamp, sizeof(tstamp), \"%d/%b/%Y:%H:%M:%S %z\", tm) == 0)\n\t\treturn (-1);\n\n\tif (print_host(&clt->clt_ss, ip, sizeof(ip)) == NULL)\n\t\treturn (-1);\n\n\t/*\n\t * For details on common log format, see:\n\t * https://httpd.apache.org/docs/current/mod/mod_log_config.html\n\t *\n\t * httpd's format is similar to these Apache LogFormats:\n\t * \"%v %h %l %u %t \\\"%r\\\" %>s %B\"\n\t * \"%v %h %l %u %t \\\"%r\\\" %>s %B \\\"%{Referer}i\\\" \\\"%{User-agent}i\\\"\"\n\t */\n\tswitch (srv_conf->logformat) {\n\tcase LOG_FORMAT_COMMON:\n\t\t/* Use vis to encode input values from the header */\n\t\tif (clt->clt_remote_user &&\n\t\t    stravis(&user, clt->clt_remote_user, HTTPD_LOGVIS) == -1)\n\t\t\tgoto done;\n\t\tif (desc->http_version &&\n\t\t    stravis(&version, desc->http_version, HTTPD_LOGVIS) == -1)\n\t\t\tgoto done;\n\n\t\t/* The following should be URL-encoded */\n\t\tif (desc->http_path &&\n\t\t    (path = url_encode(desc->http_path)) == NULL)\n\t\t\tgoto done;\n\t\tif (desc->http_query &&\n\t\t    (query = url_encode(desc->http_query)) == NULL)\n\t\t\tgoto done;\n\n\t\tret = evbuffer_add_printf(clt->clt_log,\n\t\t    \"%s %s - %s [%s] \\\"%s %s%s%s%s%s\\\" %03d %zu\\n\",\n\t\t    srv_conf->name, ip, clt->clt_remote_user == NULL ? \"-\" :\n\t\t    user, tstamp,\n\t\t    server_httpmethod_byid(desc->http_method),\n\t\t    desc->http_path == NULL ? \"\" : path,\n\t\t    desc->http_query == NULL ? \"\" : \"?\",\n\t\t    desc->http_query == NULL ? \"\" : query,\n\t\t    desc->http_version == NULL ? \"\" : \" \",\n\t\t    desc->http_version == NULL ? \"\" : version,\n\t\t    code, len);\n\n\t\tbreak;\n\n\tcase LOG_FORMAT_COMBINED:\n\t\tkey.kv_key = \"Referer\"; /* sic */\n\t\tif ((referrer = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    referrer->kv_value == NULL)\n\t\t\treferrer = NULL;\n\n\t\tkey.kv_key = \"User-Agent\";\n\t\tif ((agent = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    agent->kv_value == NULL)\n\t\t\tagent = NULL;\n\n\t\t/* Use vis to encode input values from the header */\n\t\tif (clt->clt_remote_user &&\n\t\t    stravis(&user, clt->clt_remote_user, HTTPD_LOGVIS) == -1)\n\t\t\tgoto done;\n\t\tif (desc->http_version &&\n\t\t    stravis(&version, desc->http_version, HTTPD_LOGVIS) == -1)\n\t\t\tgoto done;\n\t\tif (agent &&\n\t\t    stravis(&agent_v, agent->kv_value, HTTPD_LOGVIS) == -1)\n\t\t\tgoto done;\n\n\t\t/* The following should be URL-encoded */\n\t\tif (desc->http_path &&\n\t\t    (path = url_encode(desc->http_path)) == NULL)\n\t\t\tgoto done;\n\t\tif (desc->http_query &&\n\t\t    (query = url_encode(desc->http_query)) == NULL)\n\t\t\tgoto done;\n\t\tif (referrer &&\n\t\t    (referrer_v = url_encode(referrer->kv_value)) == NULL)\n\t\t\tgoto done;\n\n\t\tret = evbuffer_add_printf(clt->clt_log,\n\t\t    \"%s %s - %s [%s] \\\"%s %s%s%s%s%s\\\"\"\n\t\t    \" %03d %zu \\\"%s\\\" \\\"%s\\\"\\n\",\n\t\t    srv_conf->name, ip, clt->clt_remote_user == NULL ? \"-\" :\n\t\t    user, tstamp,\n\t\t    server_httpmethod_byid(desc->http_method),\n\t\t    desc->http_path == NULL ? \"\" : path,\n\t\t    desc->http_query == NULL ? \"\" : \"?\",\n\t\t    desc->http_query == NULL ? \"\" : query,\n\t\t    desc->http_version == NULL ? \"\" : \" \",\n\t\t    desc->http_version == NULL ? \"\" : version,\n\t\t    code, len,\n\t\t    referrer == NULL ? \"\" : referrer_v,\n\t\t    agent == NULL ? \"\" : agent_v);\n\n\t\tbreak;\n\n\tcase LOG_FORMAT_CONNECTION:\n\t\t/* URL-encode the path */\n\t\tif (desc->http_path &&\n\t\t    (path = url_encode(desc->http_path)) == NULL)\n\t\t\tgoto done;\n\n\t\tret = evbuffer_add_printf(clt->clt_log, \" [%s]\",\n\t\t    desc->http_path == NULL ? \"\" : path);\n\n\t\tbreak;\n\t}\n\ndone:\n\tfree(user);\n\tfree(path);\n\tfree(query);\n\tfree(version);\n\tfree(referrer_v);\n\tfree(agent_v);\n\n\treturn (ret);\n}\n"], "fixing_code": ["/*\t$OpenBSD: httpd.h,v 1.127 2017/01/31 14:39:47 reyk Exp $\t*/\n\n/*\n * Copyright (c) 2006 - 2015 Reyk Floeter <reyk@openbsd.org>\n * Copyright (c) 2006, 2007 Pierre-Yves Ritschard <pyr@openbsd.org>\n * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#ifndef _HTTPD_H\n#define _HTTPD_H\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/queue.h>\n#include <sys/tree.h>\n#include <sys/time.h>\n\n#include <net/if.h>\n\n#include <stdarg.h>\n#include <limits.h>\n#include <event.h>\n#include <imsg.h>\n#include <tls.h>\n#include <vis.h>\n\n#include \"patterns.h\"\n\n#ifndef nitems\n#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))\n#endif\n\n#define CONF_FILE\t\t\"/etc/httpd.conf\"\n#define HTTPD_SOCKET\t\t\"/var/run/httpd.sock\"\n#define HTTPD_USER\t\t\"www\"\n#define HTTPD_SERVERNAME\t\"OpenBSD httpd\"\n#define HTTPD_DOCROOT\t\t\"/htdocs\"\n#define HTTPD_INDEX\t\t\"index.html\"\n#define HTTPD_FCGI_SOCKET\t\"/run/slowcgi.sock\"\n#define HTTPD_LOGROOT\t\t\"/logs\"\n#define HTTPD_ACCESS_LOG\t\"access.log\"\n#define HTTPD_ERROR_LOG\t\t\"error.log\"\n#define HTTPD_DEFAULT_TYPE\t{ \"bin\", \"application\", \"octet-stream\", NULL }\n#define HTTPD_LOGVIS\t\tVIS_NL|VIS_TAB|VIS_CSTYLE\n#define HTTPD_TLS_CERT\t\t\"/etc/ssl/server.crt\"\n#define HTTPD_TLS_KEY\t\t\"/etc/ssl/private/server.key\"\n#define HTTPD_TLS_CIPHERS\t\"compat\"\n#define HTTPD_TLS_DHE_PARAMS\t\"none\"\n#define HTTPD_TLS_ECDHE_CURVE\t\"auto\"\n#define FD_RESERVE\t\t5\n\n#define SERVER_MAX_CLIENTS\t1024\n#define SERVER_TIMEOUT\t\t600\n#define SERVER_CACHESIZE\t-1\t/* use default size */\n#define SERVER_NUMPROC\t\t3\n#define SERVER_MAXHEADERLENGTH\t8192\n#define SERVER_MAXREQUESTS\t100\t/* max requests per connection */\n#define SERVER_MAXREQUESTBODY\t1048576\t/* 1M */\n#define SERVER_BACKLOG\t\t10\n#define SERVER_OUTOF_FD_RETRIES\t5\n#define SERVER_MAX_PREFETCH\t256\n#define SERVER_MIN_PREFETCHED\t32\n#define SERVER_HSTS_DEFAULT_AGE\t31536000\n#define SERVER_MAX_RANGES\t4\n\n#define MEDIATYPE_NAMEMAX\t128\t/* file name extension */\n#define MEDIATYPE_TYPEMAX\t64\t/* length of type/subtype */\n\n#define CONFIG_RELOAD\t\t0x00\n#define CONFIG_MEDIA\t\t0x01\n#define CONFIG_SERVERS\t\t0x02\n#define CONFIG_AUTH\t\t0x04\n#define CONFIG_ALL\t\t0xff\n\n#define FCGI_CONTENT_SIZE\t65535\n\n#define PROC_PARENT_SOCK_FILENO\t3\n#define PROC_MAX_INSTANCES\t32\n\nenum httpchunk {\n\tTOREAD_UNLIMITED\t\t= -1,\n\tTOREAD_HTTP_HEADER\t\t= -2,\n\tTOREAD_HTTP_CHUNK_LENGTH\t= -3,\n\tTOREAD_HTTP_CHUNK_TRAILER\t= -4,\n\tTOREAD_HTTP_NONE\t\t= -5,\n\tTOREAD_HTTP_RANGE\t\t= TOREAD_HTTP_CHUNK_LENGTH\n};\n\n#if DEBUG\n#define DPRINTF\t\tlog_debug\n#else\n#define DPRINTF(x...)\tdo {} while(0)\n#endif\n\nstruct ctl_flags {\n\tuint8_t\t\t cf_opts;\n\tuint32_t\t cf_flags;\n};\n\nenum key_type {\n\tKEY_TYPE_NONE\t\t= 0,\n\tKEY_TYPE_COOKIE,\n\tKEY_TYPE_HEADER,\n\tKEY_TYPE_PATH,\n\tKEY_TYPE_QUERY,\n\tKEY_TYPE_URL,\n\tKEY_TYPE_MAX\n};\n\nTAILQ_HEAD(kvlist, kv);\nRB_HEAD(kvtree, kv);\n\nstruct kv {\n\tchar\t\t\t*kv_key;\n\tchar\t\t\t*kv_value;\n\n\tenum key_type\t\t kv_type;\n\n#define KV_FLAG_INVALID\t\t 0x01\n#define KV_FLAG_GLOBBING\t 0x02\n\tuint8_t\t\t\t kv_flags;\n\n\tstruct kvlist\t\t kv_children;\n\tstruct kv\t\t*kv_parent;\n\tTAILQ_ENTRY(kv)\t\t kv_entry;\n\n\tRB_ENTRY(kv)\t\t kv_node;\n};\n\nstruct portrange {\n\tin_port_t\t\t val[2];\n\tuint8_t\t\t\t op;\n};\n\nstruct address {\n\tstruct sockaddr_storage\t ss;\n\tint\t\t\t ipproto;\n\tint\t\t\t prefixlen;\n\tstruct portrange\t port;\n\tchar\t\t\t ifname[IFNAMSIZ];\n\tTAILQ_ENTRY(address)\t entry;\n};\nTAILQ_HEAD(addresslist, address);\n\n/* initially control.h */\nstruct control_sock {\n\tconst char\t*cs_name;\n\tstruct event\t cs_ev;\n\tstruct event\t cs_evt;\n\tint\t\t cs_fd;\n\tint\t\t cs_restricted;\n\tvoid\t\t*cs_env;\n\n\tTAILQ_ENTRY(control_sock) cs_entry;\n};\nTAILQ_HEAD(control_socks, control_sock);\n\nstruct {\n\tstruct event\t ev;\n\tint\t\t fd;\n} control_state;\n\nstruct imsgev {\n\tstruct imsgbuf\t\t ibuf;\n\tvoid\t\t\t(*handler)(int, short, void *);\n\tstruct event\t\t ev;\n\tstruct privsep_proc\t*proc;\n\tvoid\t\t\t*data;\n\tshort\t\t\t events;\n};\n\n#define IMSG_SIZE_CHECK(imsg, p) do {\t\t\t\t\\\n\tif (IMSG_DATA_SIZE(imsg) < sizeof(*p))\t\t\t\\\n\t\tfatalx(\"bad length imsg received\");\t\t\\\n} while (0)\n#define IMSG_DATA_SIZE(imsg)\t((imsg)->hdr.len - IMSG_HEADER_SIZE)\n\nstruct ctl_conn {\n\tTAILQ_ENTRY(ctl_conn)\t entry;\n\tuint8_t\t\t\t flags;\n\tunsigned int\t\t waiting;\n#define CTL_CONN_NOTIFY\t\t 0x01\n\tstruct imsgev\t\t iev;\n\n};\nTAILQ_HEAD(ctl_connlist, ctl_conn);\n\nenum imsg_type {\n\tIMSG_NONE,\n\tIMSG_CTL_OK,\n\tIMSG_CTL_FAIL,\n\tIMSG_CTL_VERBOSE,\n\tIMSG_CTL_PROCFD,\n\tIMSG_CTL_RESET,\n\tIMSG_CTL_SHUTDOWN,\n\tIMSG_CTL_RELOAD,\n\tIMSG_CTL_NOTIFY,\n\tIMSG_CTL_END,\n\tIMSG_CTL_START,\n\tIMSG_CTL_REOPEN,\n\tIMSG_CFG_SERVER,\n\tIMSG_CFG_TLS,\n\tIMSG_CFG_MEDIA,\n\tIMSG_CFG_AUTH,\n\tIMSG_CFG_DONE,\n\tIMSG_LOG_ACCESS,\n\tIMSG_LOG_ERROR,\n\tIMSG_LOG_OPEN\n};\n\nenum privsep_procid {\n\tPROC_ALL\t= -1,\n\tPROC_PARENT\t= 0,\n\tPROC_SERVER,\n\tPROC_LOGGER,\n\tPROC_MAX\n} privsep_process;\n\n/* Attach the control socket to the following process */\n#define PROC_CONTROL\tPROC_LOGGER\n\nstruct privsep_pipes {\n\tint\t\t\t\t*pp_pipes[PROC_MAX];\n};\n\nstruct privsep {\n\tstruct privsep_pipes\t\t*ps_pipes[PROC_MAX];\n\tstruct privsep_pipes\t\t*ps_pp;\n\n\tstruct imsgev\t\t\t*ps_ievs[PROC_MAX];\n\tconst char\t\t\t*ps_title[PROC_MAX];\n\tuint8_t\t\t\t\t ps_what[PROC_MAX];\n\n\tunsigned int\t\t\t ps_instances[PROC_MAX];\n\tunsigned int\t\t\t ps_instance;\n\n\tstruct control_sock\t\t ps_csock;\n\tstruct control_socks\t\t ps_rcsocks;\n\n\t/* Event and signal handlers */\n\tstruct event\t\t\t ps_evsigint;\n\tstruct event\t\t\t ps_evsigterm;\n\tstruct event\t\t\t ps_evsigchld;\n\tstruct event\t\t\t ps_evsighup;\n\tstruct event\t\t\t ps_evsigpipe;\n\tstruct event\t\t\t ps_evsigusr1;\n\n\tint\t\t\t\t ps_noaction;\n\tstruct passwd\t\t\t*ps_pw;\n\tstruct httpd\t\t\t*ps_env;\n};\n\nstruct privsep_proc {\n\tconst char\t\t*p_title;\n\tenum privsep_procid\t p_id;\n\tint\t\t\t(*p_cb)(int, struct privsep_proc *,\n\t\t\t\t    struct imsg *);\n\tvoid\t\t\t(*p_init)(struct privsep *,\n\t\t\t\t    struct privsep_proc *);\n\tconst char\t\t*p_chroot;\n\tstruct privsep\t\t*p_ps;\n\tvoid\t\t\t(*p_shutdown)(void);\n\tstruct passwd\t\t*p_pw;\n};\n\nstruct privsep_fd {\n\tenum privsep_procid\t\t pf_procid;\n\tunsigned int\t\t\t pf_instance;\n};\n\nenum fcgistate {\n\tFCGI_READ_HEADER,\n\tFCGI_READ_CONTENT,\n\tFCGI_READ_PADDING\n};\n\nstruct fcgi_data {\n\tenum fcgistate\t\t state;\n\tint\t\t\t toread;\n\tint\t\t\t padding_len;\n\tint\t\t\t type;\n\tint\t\t\t chunked;\n\tint\t\t\t end;\n\tint\t\t\t status;\n\tint\t\t\t headersdone;\n};\n\nstruct range {\n\toff_t\tstart;\n\toff_t\tend;\n};\n\nstruct range_data {\n\tstruct range\t\t range[SERVER_MAX_RANGES];\n\tint\t\t\t range_count;\n\tint\t\t\t range_index;\n\toff_t\t\t\t range_toread;\n\n\t/* For the Content headers in each part */\n\tstruct media_type\t*range_media;\n\tsize_t\t\t\t range_total;\n};\n\nstruct client {\n\tuint32_t\t\t clt_id;\n\tpid_t\t\t\t clt_pid;\n\tvoid\t\t\t*clt_srv;\n\tvoid\t\t\t*clt_srv_conf;\n\tuint32_t\t\t clt_srv_id;\n\tstruct sockaddr_storage\t clt_srv_ss;\n\tstruct str_match\t clt_srv_match;\n\n\tint\t\t\t clt_s;\n\tin_port_t\t\t clt_port;\n\tstruct sockaddr_storage\t clt_ss;\n\tstruct bufferevent\t*clt_bev;\n\tstruct evbuffer\t\t*clt_output;\n\tstruct event\t\t clt_ev;\n\tvoid\t\t\t*clt_descreq;\n\tvoid\t\t\t*clt_descresp;\n\tint\t\t\t clt_sndbufsiz;\n\tuint64_t\t\t clt_boundary;\n\n\tint\t\t\t clt_fd;\n\tstruct tls\t\t*clt_tls_ctx;\n\tstruct bufferevent\t*clt_srvbev;\n\tint\t\t\t clt_srvbev_throttled;\n\n\toff_t\t\t\t clt_toread;\n\tsize_t\t\t\t clt_headerlen;\n\tint\t\t\t clt_headersdone;\n\tunsigned int\t\t clt_persist;\n\tint\t\t\t clt_line;\n\tint\t\t\t clt_done;\n\tint\t\t\t clt_chunk;\n\tint\t\t\t clt_inflight;\n\tstruct range_data\t clt_ranges;\n\tstruct fcgi_data\t clt_fcgi;\n\tchar\t\t\t*clt_remote_user;\n\tstruct evbuffer\t\t*clt_srvevb;\n\n\tstruct evbuffer\t\t*clt_log;\n\tstruct timeval\t\t clt_timeout;\n\tstruct timeval\t\t clt_tv_start;\n\tstruct timeval\t\t clt_tv_last;\n\tstruct event\t\t clt_inflightevt;\n\n\tSPLAY_ENTRY(client)\t clt_nodes;\n};\nSPLAY_HEAD(client_tree, client);\n\n#define SRVFLAG_INDEX\t\t0x00000001\n#define SRVFLAG_NO_INDEX\t0x00000002\n#define SRVFLAG_AUTO_INDEX\t0x00000004\n#define SRVFLAG_NO_AUTO_INDEX\t0x00000008\n#define SRVFLAG_ROOT\t\t0x00000010\n#define SRVFLAG_LOCATION\t0x00000020\n#define SRVFLAG_FCGI\t\t0x00000040\n#define SRVFLAG_NO_FCGI\t\t0x00000080\n#define SRVFLAG_LOG\t\t0x00000100\n#define SRVFLAG_NO_LOG\t\t0x00000200\n#define SRVFLAG_SOCKET\t\t0x00000400\n#define SRVFLAG_SYSLOG\t\t0x00000800\n#define SRVFLAG_NO_SYSLOG\t0x00001000\n#define SRVFLAG_TLS\t\t0x00002000\n#define SRVFLAG_ACCESS_LOG\t0x00004000\n#define SRVFLAG_ERROR_LOG\t0x00008000\n#define SRVFLAG_AUTH\t\t0x00010000\n#define SRVFLAG_NO_AUTH\t\t0x00020000\n#define SRVFLAG_BLOCK\t\t0x00040000\n#define SRVFLAG_NO_BLOCK\t0x00080000\n#define SRVFLAG_LOCATION_MATCH\t0x00100000\n#define SRVFLAG_SERVER_MATCH\t0x00200000\n#define SRVFLAG_SERVER_HSTS\t0x00400000\n#define SRVFLAG_DEFAULT_TYPE\t0x00800000\n\n#define SRVFLAG_BITS\t\t\t\t\t\t\t\\\n\t\"\\10\\01INDEX\\02NO_INDEX\\03AUTO_INDEX\\04NO_AUTO_INDEX\"\t\t\\\n\t\"\\05ROOT\\06LOCATION\\07FCGI\\10NO_FCGI\\11LOG\\12NO_LOG\\13SOCKET\"\t\\\n\t\"\\14SYSLOG\\15NO_SYSLOG\\16TLS\\17ACCESS_LOG\\20ERROR_LOG\"\t\t\\\n\t\"\\21AUTH\\22NO_AUTH\\23BLOCK\\24NO_BLOCK\\25LOCATION_MATCH\"\t\t\\\n\t\"\\26SERVER_MATCH\\27SERVER_HSTS\\30DEFAULT_TYPE\"\n\n#define TCPFLAG_NODELAY\t\t0x01\n#define TCPFLAG_NNODELAY\t0x02\n#define TCPFLAG_SACK\t\t0x04\n#define TCPFLAG_NSACK\t\t0x08\n#define TCPFLAG_BUFSIZ\t\t0x10\n#define TCPFLAG_IPTTL\t\t0x20\n#define TCPFLAG_IPMINTTL\t0x40\n#define TCPFLAG_NSPLICE\t\t0x80\n#define TCPFLAG_DEFAULT\t\t0x00\n\n#define TCPFLAG_BITS\t\t\t\t\t\t\\\n\t\"\\10\\01NODELAY\\02NO_NODELAY\\03SACK\\04NO_SACK\"\t\t\\\n\t\"\\05SOCKET_BUFFER_SIZE\\06IP_TTL\\07IP_MINTTL\\10NO_SPLICE\"\n\n#define HSTSFLAG_SUBDOMAINS\t0x01\n#define HSTSFLAG_PRELOAD\t0x02\n#define HSTSFLAG_BITS\t\t\"\\10\\01SUBDOMAINS\\02PRELOAD\"\n\nenum log_format {\n\tLOG_FORMAT_COMMON,\n\tLOG_FORMAT_COMBINED,\n\tLOG_FORMAT_CONNECTION\n};\n\nstruct log_file {\n\tchar\t\t\tlog_name[NAME_MAX];\n\tint\t\t\tlog_fd;\n\tuint32_t\t\tlog_id;\n\tTAILQ_ENTRY(log_file)\tlog_entry;\n};\nTAILQ_HEAD(log_files, log_file) log_files;\n\nstruct media_type {\n\tchar\t\t\t media_name[MEDIATYPE_NAMEMAX];\n\tchar\t\t\t media_type[MEDIATYPE_TYPEMAX];\n\tchar\t\t\t media_subtype[MEDIATYPE_TYPEMAX];\n\tchar\t\t\t*media_encoding;\n\tRB_ENTRY(media_type)\t media_entry;\n};\nRB_HEAD(mediatypes, media_type);\n\nstruct auth {\n\tchar\t\t\t auth_htpasswd[PATH_MAX];\n\tuint32_t\t\t auth_id;\n\tTAILQ_ENTRY(auth)\t auth_entry;\n};\nTAILQ_HEAD(serverauth, auth);\n\nstruct server_config {\n\tuint32_t\t\t id;\n\tuint32_t\t\t parent_id;\n\tchar\t\t\t name[HOST_NAME_MAX+1];\n\tchar\t\t\t location[NAME_MAX];\n\tchar\t\t\t index[NAME_MAX];\n\tchar\t\t\t root[PATH_MAX];\n\tchar\t\t\t socket[PATH_MAX];\n\tchar\t\t\t accesslog[NAME_MAX];\n\tchar\t\t\t errorlog[NAME_MAX];\n\tstruct media_type\t default_type;\n\n\tin_port_t\t\t port;\n\tstruct sockaddr_storage\t ss;\n\tint\t\t\t prefixlen;\n\tstruct timeval\t\t timeout;\n\tuint32_t\t\t maxrequests;\n\tsize_t\t\t\t maxrequestbody;\n\n\tuint8_t\t\t\t*tls_cert;\n\tsize_t\t\t\t tls_cert_len;\n\tchar\t\t\t*tls_cert_file;\n\tchar\t\t\t tls_ciphers[NAME_MAX];\n\tchar\t\t\t tls_dhe_params[NAME_MAX];\n\tchar\t\t\t tls_ecdhe_curve[NAME_MAX];\n\tuint8_t\t\t\t*tls_key;\n\tsize_t\t\t\t tls_key_len;\n\tchar\t\t\t*tls_key_file;\n\tuint32_t\t\t tls_protocols;\n\tuint8_t\t\t\t*tls_ocsp_staple;\n\tsize_t\t\t\t tls_ocsp_staple_len;\n\tchar\t\t\t*tls_ocsp_staple_file;\n\n\tuint32_t\t\t flags;\n\tint\t\t\t strip;\n\tuint8_t\t\t\t tcpflags;\n\tint\t\t\t tcpbufsiz;\n\tint\t\t\t tcpbacklog;\n\tuint8_t\t\t\t tcpipttl;\n\tuint8_t\t\t\t tcpipminttl;\n\n\tenum log_format\t\t logformat;\n\tstruct log_file\t\t*logaccess;\n\tstruct log_file\t\t*logerror;\n\n\tchar\t\t\t auth_realm[NAME_MAX];\n\tuint32_t\t\t auth_id;\n\tconst struct auth\t*auth;\n\n\tint\t\t\t return_code;\n\tchar\t\t\t*return_uri;\n\toff_t\t\t\t return_uri_len;\n\n\tint\t\t\t hsts_max_age;\n\tuint8_t\t\t\t hsts_flags;\n\n\tTAILQ_ENTRY(server_config) entry;\n};\nTAILQ_HEAD(serverhosts, server_config);\n\nstruct tls_config {\n\tuint32_t\t\t id;\n\n\tsize_t\t\t\t tls_cert_len;\n\tsize_t\t\t\t tls_key_len;\n\tsize_t\t\t\t tls_ocsp_staple_len;\n};\n\nstruct server {\n\tTAILQ_ENTRY(server)\t srv_entry;\n\tstruct server_config\t srv_conf;\n\tstruct serverhosts\t srv_hosts;\n\n\tint\t\t\t srv_s;\n\tstruct event\t\t srv_ev;\n\tstruct event\t\t srv_evt;\n\n\tstruct tls\t\t *srv_tls_ctx;\n\tstruct tls_config\t *srv_tls_config;\n\n\tstruct client_tree\t srv_clients;\n};\nTAILQ_HEAD(serverlist, server);\n\nstruct httpd {\n\tuint8_t\t\t\t sc_opts;\n\tuint32_t\t\t sc_flags;\n\tconst char\t\t*sc_conffile;\n\tstruct event\t\t sc_ev;\n\tuint16_t\t\t sc_prefork_server;\n\tuint16_t\t\t sc_id;\n\tint\t\t\t sc_paused;\n\tchar\t\t\t*sc_chroot;\n\tchar\t\t\t*sc_logdir;\n\n\tstruct serverlist\t*sc_servers;\n\tstruct mediatypes\t*sc_mediatypes;\n\tstruct media_type\t sc_default_type;\n\tstruct serverauth\t*sc_auth;\n\n\tstruct privsep\t\t*sc_ps;\n\tint\t\t\t sc_reload;\n};\n\n#define HTTPD_OPT_VERBOSE\t\t0x01\n#define HTTPD_OPT_NOACTION\t\t0x04\n\n/* control.c */\nint\t control_init(struct privsep *, struct control_sock *);\nint\t control_listen(struct control_sock *);\nvoid\t control_cleanup(struct control_sock *);\nvoid\t control_dispatch_imsg(int, short, void *);\nvoid\t control_imsg_forward(struct privsep *, struct imsg *);\nstruct ctl_conn\t*\n\t control_connbyfd(int);\n\nextern  struct ctl_connlist ctl_conns;\n\n/* parse.y */\nint\t parse_config(const char *, struct httpd *);\nint\t load_config(const char *, struct httpd *);\nint\t cmdline_symset(char *);\n\n/* server.c */\nvoid\t server(struct privsep *, struct privsep_proc *);\nint\t server_tls_cmp(struct server *, struct server *, int);\nint\t server_tls_load_keypair(struct server *);\nint\t server_tls_load_ocsp(struct server *);\nint\t server_privinit(struct server *);\nvoid\t server_purge(struct server *);\nvoid\t serverconfig_free(struct server_config *);\nvoid\t serverconfig_reset(struct server_config *);\nint\t server_socket_af(struct sockaddr_storage *, in_port_t);\nin_port_t\n\t server_socket_getport(struct sockaddr_storage *);\nint\t server_socket_connect(struct sockaddr_storage *, in_port_t,\n\t    struct server_config *);\nvoid\t server_write(struct bufferevent *, void *);\nvoid\t server_read(struct bufferevent *, void *);\nvoid\t server_error(struct bufferevent *, short, void *);\nvoid\t server_log(struct client *, const char *);\nvoid\t server_sendlog(struct server_config *, int, const char *, ...)\n\t    __attribute__((__format__ (printf, 3, 4)));\nvoid\t server_close(struct client *, const char *);\nvoid\t server_dump(struct client *, const void *, size_t);\nint\t server_client_cmp(struct client *, struct client *);\nint\t server_bufferevent_printf(struct client *, const char *, ...)\n\t    __attribute__((__format__ (printf, 2, 3)));\nint\t server_bufferevent_print(struct client *, const char *);\nint\t server_bufferevent_write_buffer(struct client *,\n\t    struct evbuffer *);\nint\t server_bufferevent_write_chunk(struct client *,\n\t    struct evbuffer *, size_t);\nint\t server_bufferevent_add(struct event *, int);\nint\t server_bufferevent_write(struct client *, void *, size_t);\nstruct server *\n\t server_byaddr(struct sockaddr *, in_port_t);\nstruct server_config *\n\t serverconfig_byid(uint32_t);\nint\t server_foreach(int (*)(struct server *,\n\t    struct server_config *, void *), void *);\nstruct server *\n\t server_match(struct server *, int);\n\nSPLAY_PROTOTYPE(client_tree, client, clt_nodes, server_client_cmp);\n\n/* server_http.c */\nvoid\t server_http_init(struct server *);\nvoid\t server_http(void);\nint\t server_httpdesc_init(struct client *);\nvoid\t server_read_http(struct bufferevent *, void *);\nvoid\t server_abort_http(struct client *, unsigned int, const char *);\nunsigned int\n\t server_httpmethod_byname(const char *);\nconst char\n\t*server_httpmethod_byid(unsigned int);\nconst char\n\t*server_httperror_byid(unsigned int);\nvoid\t server_read_httpcontent(struct bufferevent *, void *);\nvoid\t server_read_httpchunks(struct bufferevent *, void *);\nvoid\t server_read_httprange(struct bufferevent *, void *);\nint\t server_writeheader_http(struct client *clt, struct kv *, void *);\nint\t server_headers(struct client *, void *,\n\t    int (*)(struct client *, struct kv *, void *), void *);\nint\t server_writeresponse_http(struct client *);\nint\t server_response_http(struct client *, unsigned int, struct media_type *,\n\t    off_t, time_t);\nvoid\t server_reset_http(struct client *);\nvoid\t server_close_http(struct client *);\nint\t server_response(struct httpd *, struct client *);\nconst char *\n\t server_root_strip(const char *, int);\nstruct server_config *\n\t server_getlocation(struct client *, const char *);\nconst char *\n\t server_http_host(struct sockaddr_storage *, char *, size_t);\nchar\t*server_http_parsehost(char *, char *, size_t, int *);\nssize_t\t server_http_time(time_t, char *, size_t);\nint\t server_log_http(struct client *, unsigned int, size_t);\n\n/* server_file.c */\nint\t server_file(struct httpd *, struct client *);\nvoid\t server_file_error(struct bufferevent *, short, void *);\n\n/* server_fcgi.c */\nint\t server_fcgi(struct httpd *, struct client *);\nint\t fcgi_add_stdin(struct client *, struct evbuffer *);\n\n/* httpd.c */\nvoid\t\t event_again(struct event *, int, short,\n\t\t    void (*)(int, short, void *),\n\t\t    struct timeval *, struct timeval *, void *);\nint\t\t expand_string(char *, size_t, const char *, const char *);\nconst char\t*url_decode(char *);\nchar\t\t*url_encode(const char *);\nconst char\t*canonicalize_host(const char *, char *, size_t);\nconst char\t*canonicalize_path(const char *, char *, size_t);\nsize_t\t\t path_info(char *);\nchar\t\t*escape_html(const char *);\nvoid\t\t socket_rlimit(int);\nchar\t\t*evbuffer_getline(struct evbuffer *);\nchar\t\t*get_string(uint8_t *, size_t);\nvoid\t\t*get_data(uint8_t *, size_t);\nint\t\t sockaddr_cmp(struct sockaddr *, struct sockaddr *, int);\nstruct in6_addr *prefixlen2mask6(uint8_t, uint32_t *);\nuint32_t\t prefixlen2mask(uint8_t);\nint\t\t accept_reserve(int, struct sockaddr *, socklen_t *, int,\n\t\t    volatile int *);\nstruct kv\t*kv_add(struct kvtree *, char *, char *);\nint\t\t kv_set(struct kv *, char *, ...)\n\t\t    __attribute__((__format__ (printf, 2, 3)));\nint\t\t kv_setkey(struct kv *, char *, ...)\n\t\t    __attribute__((__format__ (printf, 2, 3)));\nvoid\t\t kv_delete(struct kvtree *, struct kv *);\nstruct kv\t*kv_extend(struct kvtree *, struct kv *, char *);\nvoid\t\t kv_purge(struct kvtree *);\nvoid\t\t kv_free(struct kv *);\nstruct kv\t*kv_inherit(struct kv *, struct kv *);\nint\t\t kv_log(struct evbuffer *, struct kv *);\nstruct kv\t*kv_find(struct kvtree *, struct kv *);\nint\t\t kv_cmp(struct kv *, struct kv *);\nstruct media_type\n\t\t*media_add(struct mediatypes *, struct media_type *);\nvoid\t\t media_delete(struct mediatypes *, struct media_type *);\nvoid\t\t media_purge(struct mediatypes *);\nstruct media_type *\n\t\t media_find(struct mediatypes *, const char *);\nstruct media_type *\n\t\t media_find_config(struct httpd *, struct server_config *,\n\t\t    const char *);\nint\t\t media_cmp(struct media_type *, struct media_type *);\nRB_PROTOTYPE(kvtree, kv, kv_node, kv_cmp);\nRB_PROTOTYPE(mediatypes, media_type, media_entry, media_cmp);\nstruct auth\t*auth_add(struct serverauth *, struct auth *);\nstruct auth\t*auth_byid(struct serverauth *, uint32_t);\nvoid\t\t auth_free(struct serverauth *, struct auth *);\nconst char\t*print_host(struct sockaddr_storage *, char *, size_t);\nconst char\t*print_time(struct timeval *, struct timeval *, char *, size_t);\nconst char\t*printb_flags(const uint32_t, const char *);\nvoid\t\t getmonotime(struct timeval *);\n\nextern struct httpd *httpd_env;\n\n/* log.c */\nvoid\tlog_init(int, int);\nvoid\tlog_procinit(const char *);\nvoid\tlog_setverbose(int);\nint\tlog_getverbose(void);\nvoid\tlog_warn(const char *, ...)\n\t    __attribute__((__format__ (printf, 1, 2)));\nvoid\tlog_warnx(const char *, ...)\n\t    __attribute__((__format__ (printf, 1, 2)));\nvoid\tlog_info(const char *, ...)\n\t    __attribute__((__format__ (printf, 1, 2)));\nvoid\tlog_debug(const char *, ...)\n\t    __attribute__((__format__ (printf, 1, 2)));\nvoid\tlogit(int, const char *, ...)\n\t    __attribute__((__format__ (printf, 2, 3)));\nvoid\tvlog(int, const char *, va_list)\n\t    __attribute__((__format__ (printf, 2, 0)));\n__dead void fatal(const char *, ...)\n\t    __attribute__((__format__ (printf, 1, 2)));\n__dead void fatalx(const char *, ...)\n\t    __attribute__((__format__ (printf, 1, 2)));\n\n/* proc.c */\nenum privsep_procid\n\t    proc_getid(struct privsep_proc *, unsigned int, const char *);\nvoid\t proc_init(struct privsep *, struct privsep_proc *, unsigned int,\n\t    int, char **, enum privsep_procid);\nvoid\t proc_kill(struct privsep *);\nvoid\t proc_connect(struct privsep *);\nvoid\t proc_dispatch(int, short event, void *);\nvoid\t proc_run(struct privsep *, struct privsep_proc *,\n\t    struct privsep_proc *, unsigned int,\n\t    void (*)(struct privsep *, struct privsep_proc *, void *), void *);\nvoid\t proc_range(struct privsep *, enum privsep_procid, int *, int *);\nint\t proc_compose_imsg(struct privsep *, enum privsep_procid, int,\n\t    u_int16_t, u_int32_t, int, void *, u_int16_t);\nint\t proc_compose(struct privsep *, enum privsep_procid,\n\t    uint16_t, void *, uint16_t);\nint\t proc_composev_imsg(struct privsep *, enum privsep_procid, int,\n\t    u_int16_t, u_int32_t, int, const struct iovec *, int);\nint\t proc_composev(struct privsep *, enum privsep_procid,\n\t    uint16_t, const struct iovec *, int);\nint\t proc_forward_imsg(struct privsep *, struct imsg *,\n\t    enum privsep_procid, int);\nstruct imsgbuf *\n\t proc_ibuf(struct privsep *, enum privsep_procid, int);\nstruct imsgev *\n\t proc_iev(struct privsep *, enum privsep_procid, int);\nint\t proc_flush_imsg(struct privsep *, enum privsep_procid, int);\nvoid\t imsg_event_add(struct imsgev *);\nint\t imsg_compose_event(struct imsgev *, uint16_t, uint32_t,\n\t    pid_t, int, void *, uint16_t);\nint\t imsg_composev_event(struct imsgev *, uint16_t, uint32_t,\n\t    pid_t, int, const struct iovec *, int);\n\n/* config.c */\nint\t config_init(struct httpd *);\nvoid\t config_purge(struct httpd *, unsigned int);\nint\t config_setreset(struct httpd *, unsigned int);\nint\t config_getreset(struct httpd *, struct imsg *);\nint\t config_getcfg(struct httpd *, struct imsg *);\nint\t config_setserver(struct httpd *, struct server *);\nint\t config_settls(struct httpd *, struct server *);\nint\t config_getserver(struct httpd *, struct imsg *);\nint\t config_gettls(struct httpd *, struct imsg *);\nint\t config_setmedia(struct httpd *, struct media_type *);\nint\t config_getmedia(struct httpd *, struct imsg *);\nint\t config_setauth(struct httpd *, struct auth *);\nint\t config_getauth(struct httpd *, struct imsg *);\n\n/* logger.c */\nvoid\t logger(struct privsep *, struct privsep_proc *);\nint\t logger_open_priv(struct imsg *);\n\n#endif /* _HTTPD_H */\n", "/*\t$OpenBSD: server_file.c,v 1.64 2017/01/31 14:39:47 reyk Exp $\t*/\n\n/*\n * Copyright (c) 2006 - 2017 Reyk Floeter <reyk@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n\n#include <limits.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <dirent.h>\n#include <time.h>\n#include <event.h>\n\n#include \"httpd.h\"\n#include \"http.h\"\n\n#define MINIMUM(a, b)\t(((a) < (b)) ? (a) : (b))\n#define MAXIMUM(a, b)\t(((a) > (b)) ? (a) : (b))\n\nint\t\t server_file_access(struct httpd *, struct client *,\n\t\t    char *, size_t);\nint\t\t server_file_request(struct httpd *, struct client *,\n\t\t    char *, struct stat *);\nint\t\t server_partial_file_request(struct httpd *, struct client *,\n\t\t    char *, struct stat *, char *);\nint\t\t server_file_index(struct httpd *, struct client *,\n\t\t    struct stat *);\nint\t\t server_file_modified_since(struct http_descriptor *,\n\t\t    struct stat *);\nint\t\t server_file_method(struct client *);\nint\t\t parse_range_spec(char *, size_t, struct range *);\nint\t\t parse_ranges(struct client *, char *, size_t);\n\nint\nserver_file_access(struct httpd *env, struct client *clt,\n    char *path, size_t len)\n{\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tstruct stat\t\t st;\n\tstruct kv\t\t*r, key;\n\tchar\t\t\t*newpath, *encodedpath;\n\tint\t\t\t ret;\n\n\terrno = 0;\n\n\tif (access(path, R_OK) == -1) {\n\t\tgoto fail;\n\t} else if (stat(path, &st) == -1) {\n\t\tgoto fail;\n\t} else if (S_ISDIR(st.st_mode)) {\n\t\t/* Deny access if directory indexing is disabled */\n\t\tif (srv_conf->flags & SRVFLAG_NO_INDEX) {\n\t\t\terrno = EACCES;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (desc->http_path_alias != NULL) {\n\t\t\t/* Recursion - the index \"file\" is a directory? */\n\t\t\terrno = EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* Redirect to path with trailing \"/\" */\n\t\tif (path[strlen(path) - 1] != '/') {\n\t\t\tif ((encodedpath = url_encode(desc->http_path)) == NULL)\n\t\t\t\treturn (500);\n\t\t\tif (asprintf(&newpath, \"http%s://%s%s/\",\n\t\t\t    srv_conf->flags & SRVFLAG_TLS ? \"s\" : \"\",\n\t\t\t    desc->http_host, encodedpath) == -1) {\n\t\t\t\tfree(encodedpath);\n\t\t\t\treturn (500);\n\t\t\t}\n\t\t\tfree(encodedpath);\n\n\t\t\t/* Path alias will be used for the redirection */\n\t\t\tdesc->http_path_alias = newpath;\n\n\t\t\t/* Indicate that the file has been moved */\n\t\t\treturn (301);\n\t\t}\n\n\t\t/* Append the default index file to the location */\n\t\tif (asprintf(&newpath, \"%s%s\", desc->http_path,\n\t\t    srv_conf->index) == -1)\n\t\t\treturn (500);\n\t\tdesc->http_path_alias = newpath;\n\t\tif (server_getlocation(clt, newpath) != srv_conf) {\n\t\t\t/* The location has changed */\n\t\t\treturn (server_file(env, clt));\n\t\t}\n\n\t\t/* Otherwise append the default index file to the path */\n\t\tif (strlcat(path, srv_conf->index, len) >= len) {\n\t\t\terrno = EACCES;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tret = server_file_access(env, clt, path, len);\n\t\tif (ret == 404) {\n\t\t\t/*\n\t\t\t * Index file not found; fail if auto-indexing is\n\t\t\t * not enabled, otherwise return success but\n\t\t\t * indicate directory with S_ISDIR of the previous\n\t\t\t * stat.\n\t\t\t */\n\t\t\tif ((srv_conf->flags & SRVFLAG_AUTO_INDEX) == 0) {\n\t\t\t\terrno = EACCES;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\treturn (server_file_index(env, clt, &st));\n\t\t}\n\t\treturn (ret);\n\t} else if (!S_ISREG(st.st_mode)) {\n\t\t/* Don't follow symlinks and ignore special files */\n\t\terrno = EACCES;\n\t\tgoto fail;\n\t}\n\n\tkey.kv_key = \"Range\";\n\tr = kv_find(&desc->http_headers, &key);\n\tif (r != NULL)\n\t\treturn (server_partial_file_request(env, clt, path, &st,\n\t\t    r->kv_value));\n\telse\n\t\treturn (server_file_request(env, clt, path, &st));\n\n fail:\n\tswitch (errno) {\n\tcase ENOENT:\n\tcase ENOTDIR:\n\t\treturn (404);\n\tcase EACCES:\n\t\treturn (403);\n\tdefault:\n\t\treturn (500);\n\t}\n\n\t/* NOTREACHED */\n}\n\nint\nserver_file(struct httpd *env, struct client *clt)\n{\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tchar\t\t\t path[PATH_MAX];\n\tconst char\t\t*stripped, *errstr = NULL;\n\tint\t\t\t ret = 500;\n\n\tif (srv_conf->flags & SRVFLAG_FCGI)\n\t\treturn (server_fcgi(env, clt));\n\n\t/* Request path is already canonicalized */\n\tstripped = server_root_strip(\n\t    desc->http_path_alias != NULL ?\n\t    desc->http_path_alias : desc->http_path,\n\t    srv_conf->strip);\n\tif ((size_t)snprintf(path, sizeof(path), \"%s%s\",\n\t    srv_conf->root, stripped) >= sizeof(path)) {\n\t\terrstr = desc->http_path;\n\t\tgoto abort;\n\t}\n\n\t/* Returns HTTP status code on error */\n\tif ((ret = server_file_access(env, clt, path, sizeof(path))) > 0) {\n\t\terrstr = desc->http_path_alias != NULL ?\n\t\t    desc->http_path_alias : desc->http_path;\n\t\tgoto abort;\n\t}\n\n\treturn (ret);\n\n abort:\n\tif (errstr == NULL)\n\t\terrstr = strerror(errno);\n\tserver_abort_http(clt, ret, errstr);\n\treturn (-1);\n}\n\nint\nserver_file_method(struct client *clt)\n{\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\n\tswitch (desc->http_method) {\n\tcase HTTP_METHOD_GET:\n\tcase HTTP_METHOD_HEAD:\n\t\treturn (0);\n\tdefault:\n\t\t/* Other methods are not allowed */\n\t\terrno = EACCES;\n\t\treturn (405);\n\t}\n\t/* NOTREACHED */\n}\n\nint\nserver_file_request(struct httpd *env, struct client *clt, char *path,\n    struct stat *st)\n{\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tstruct media_type\t*media;\n\tconst char\t\t*errstr = NULL;\n\tint\t\t\t fd = -1, ret, code = 500;\n\n\tif ((ret = server_file_method(clt)) != 0) {\n\t\tcode = ret;\n\t\tgoto abort;\n\t}\n\n\tif ((ret = server_file_modified_since(clt->clt_descreq, st)) != -1)\n\t\treturn (ret);\n\n\t/* Now open the file, should be readable or we have another problem */\n\tif ((fd = open(path, O_RDONLY)) == -1)\n\t\tgoto abort;\n\n\tmedia = media_find_config(env, srv_conf, path);\n\tret = server_response_http(clt, 200, media, st->st_size,\n\t    MINIMUM(time(NULL), st->st_mtim.tv_sec));\n\tswitch (ret) {\n\tcase -1:\n\t\tgoto fail;\n\tcase 0:\n\t\t/* Connection is already finished */\n\t\tclose(fd);\n\t\tgoto done;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tclt->clt_fd = fd;\n\tif (clt->clt_srvbev != NULL)\n\t\tbufferevent_free(clt->clt_srvbev);\n\n\tclt->clt_srvbev_throttled = 0;\n\tclt->clt_srvbev = bufferevent_new(clt->clt_fd, server_read,\n\t    server_write, server_file_error, clt);\n\tif (clt->clt_srvbev == NULL) {\n\t\terrstr = \"failed to allocate file buffer event\";\n\t\tgoto fail;\n\t}\n\n\t/* Adjust read watermark to the socket output buffer size */\n\tbufferevent_setwatermark(clt->clt_srvbev, EV_READ, 0,\n\t    clt->clt_sndbufsiz);\n\n\tbufferevent_settimeout(clt->clt_srvbev,\n\t    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);\n\tbufferevent_enable(clt->clt_srvbev, EV_READ);\n\tbufferevent_disable(clt->clt_bev, EV_READ);\n\n done:\n\tserver_reset_http(clt);\n\treturn (0);\n fail:\n\tbufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);\n\tbufferevent_free(clt->clt_bev);\n\tclt->clt_bev = NULL;\n abort:\n\tif (fd != -1)\n\t\tclose(fd);\n\tif (errstr == NULL)\n\t\terrstr = strerror(errno);\n\tserver_abort_http(clt, code, errstr);\n\treturn (-1);\n}\n\nint\nserver_partial_file_request(struct httpd *env, struct client *clt, char *path,\n    struct stat *st, char *range_str)\n{\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct media_type\t*media, multipart_media;\n\tstruct range_data\t*r = &clt->clt_ranges;\n\tstruct range\t\t*range;\n\tsize_t\t\t\t content_length = 0;\n\tint\t\t\t code = 500, fd = -1, i, nranges, ret;\n\tchar\t\t\t content_range[64];\n\tconst char\t\t*errstr = NULL;\n\n\t/* Ignore range request for methods other than GET */\n\tif (desc->http_method != HTTP_METHOD_GET)\n\t\treturn server_file_request(env, clt, path, st);\n\n\tif ((nranges = parse_ranges(clt, range_str, st->st_size)) < 1) {\n\t\tcode = 416;\n\t\t(void)snprintf(content_range, sizeof(content_range),\n\t\t    \"bytes */%lld\", st->st_size);\n\t\terrstr = content_range;\n\t\tgoto abort;\n\t}\n\n\t/* Now open the file, should be readable or we have another problem */\n\tif ((fd = open(path, O_RDONLY)) == -1)\n\t\tgoto abort;\n\n\tmedia = media_find_config(env, srv_conf, path);\n\tr->range_media = media;\n\n\tif (nranges == 1) {\n\t\trange = &r->range[0];\n\t\t(void)snprintf(content_range, sizeof(content_range),\n\t\t    \"bytes %lld-%lld/%lld\", range->start, range->end,\n\t\t    st->st_size);\n\t\tif (kv_add(&resp->http_headers, \"Content-Range\",\n\t\t    content_range) == NULL)\n\t\t\tgoto abort;\n\n\t\trange = &r->range[0];\n\t\tcontent_length += range->end - range->start + 1;\n\t} else {\n\t\t/* Add boundary, all parts will be handled by the callback */\n\t\tarc4random_buf(&clt->clt_boundary, sizeof(clt->clt_boundary));\n\n\t\t/* Calculate Content-Length of the complete multipart body */\n\t\tfor (i = 0; i < nranges; i++) {\n\t\t\trange = &r->range[i];\n\n\t\t\t/* calculate Content-Length of the complete body */\n\t\t\tif ((ret = snprintf(NULL, 0,\n\t\t\t    \"\\r\\n--%llu\\r\\n\"\n\t\t\t    \"Content-Type: %s/%s\\r\\n\"\n\t\t\t    \"Content-Range: bytes %lld-%lld/%lld\\r\\n\\r\\n\",\n\t\t\t    clt->clt_boundary,\n\t\t\t    media->media_type, media->media_subtype,\n\t\t\t    range->start, range->end, st->st_size)) < 0)\n\t\t\t\tgoto abort;\n\n\t\t\t/* Add data length */\n\t\t\tcontent_length += ret + range->end - range->start + 1;\n\n\t\t}\n\t\tif ((ret = snprintf(NULL, 0, \"\\r\\n--%llu--\\r\\n\",\n\t\t    clt->clt_boundary)) < 0)\n\t\t\tgoto abort;\n\t\tcontent_length += ret;\n\n\t\t/* prepare multipart/byteranges media type */\n\t\t(void)strlcpy(multipart_media.media_type, \"multipart\",\n\t\t    sizeof(multipart_media.media_type));\n\t\t(void)snprintf(multipart_media.media_subtype,\n\t\t    sizeof(multipart_media.media_subtype),\n\t\t    \"byteranges; boundary=%llu\", clt->clt_boundary);\n\t\tmedia = &multipart_media;\n\t}\n\n\t/* Start with first range */\n\tr->range_toread = TOREAD_HTTP_RANGE;\n\n\tret = server_response_http(clt, 206, media, content_length,\n\t    MINIMUM(time(NULL), st->st_mtim.tv_sec));\n\tswitch (ret) {\n\tcase -1:\n\t\tgoto fail;\n\tcase 0:\n\t\t/* Connection is already finished */\n\t\tclose(fd);\n\t\tgoto done;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tclt->clt_fd = fd;\n\tif (clt->clt_srvbev != NULL)\n\t\tbufferevent_free(clt->clt_srvbev);\n\n\tclt->clt_srvbev_throttled = 0;\n\tclt->clt_srvbev = bufferevent_new(clt->clt_fd, server_read_httprange,\n\t    server_write, server_file_error, clt);\n\tif (clt->clt_srvbev == NULL) {\n\t\terrstr = \"failed to allocate file buffer event\";\n\t\tgoto fail;\n\t}\n\n\t/* Adjust read watermark to the socket output buffer size */\n\tbufferevent_setwatermark(clt->clt_srvbev, EV_READ, 0,\n\t    clt->clt_sndbufsiz);\n\n\tbufferevent_settimeout(clt->clt_srvbev,\n\t    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);\n\tbufferevent_enable(clt->clt_srvbev, EV_READ);\n\tbufferevent_disable(clt->clt_bev, EV_READ);\n\n done:\n\tserver_reset_http(clt);\n\treturn (0);\n fail:\n\tbufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);\n\tbufferevent_free(clt->clt_bev);\n\tclt->clt_bev = NULL;\n abort:\n\tif (fd != -1)\n\t\tclose(fd);\n\tif (errstr == NULL)\n\t\terrstr = strerror(errno);\n\tserver_abort_http(clt, code, errstr);\n\treturn (-1);\n}\n\nint\nserver_file_index(struct httpd *env, struct client *clt, struct stat *st)\n{\n\tchar\t\t\t  path[PATH_MAX];\n\tchar\t\t\t  tmstr[21];\n\tstruct http_descriptor\t *desc = clt->clt_descreq;\n\tstruct server_config\t *srv_conf = clt->clt_srv_conf;\n\tstruct dirent\t\t**namelist, *dp;\n\tint\t\t\t  namesize, i, ret, fd = -1, namewidth, skip;\n\tint\t\t\t  code = 500;\n\tstruct evbuffer\t\t *evb = NULL;\n\tstruct media_type\t *media;\n\tconst char\t\t *stripped, *style;\n\tchar\t\t\t *escapeduri, *escapedhtml, *escapedpath;\n\tstruct tm\t\t  tm;\n\ttime_t\t\t\t  t, dir_mtime;\n\n\tif ((ret = server_file_method(clt)) != 0) {\n\t\tcode = ret;\n\t\tgoto abort;\n\t}\n\n\t/* Request path is already canonicalized */\n\tstripped = server_root_strip(desc->http_path, srv_conf->strip);\n\tif ((size_t)snprintf(path, sizeof(path), \"%s%s\",\n\t    srv_conf->root, stripped) >= sizeof(path))\n\t\tgoto abort;\n\n\t/* Now open the file, should be readable or we have another problem */\n\tif ((fd = open(path, O_RDONLY)) == -1)\n\t\tgoto abort;\n\n\t/* Save last modification time */\n\tdir_mtime = MINIMUM(time(NULL), st->st_mtim.tv_sec);\n\n\tif ((evb = evbuffer_new()) == NULL)\n\t\tgoto abort;\n\n\tif ((namesize = scandir(path, &namelist, NULL, alphasort)) == -1)\n\t\tgoto abort;\n\n\t/* Indicate failure but continue going through the list */\n\tskip = 0;\n\n\tif ((escapedpath = escape_html(desc->http_path)) == NULL)\n\t\tgoto fail;\n\n\t/* A CSS stylesheet allows minimal customization by the user */\n\tstyle = \"body { background-color: white; color: black; font-family: \"\n\t    \"sans-serif; }\\nhr { border: 0; border-bottom: 1px dashed; }\\n\";\n\t/* Generate simple HTML index document */\n\tif (evbuffer_add_printf(evb,\n\t    \"<!DOCTYPE html>\\n\"\n\t    \"<html>\\n\"\n\t    \"<head>\\n\"\n\t    \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; \"\n\t    \"charset=utf-8\\\"/>\\n\"\n\t    \"<title>Index of %s</title>\\n\"\n\t    \"<style type=\\\"text/css\\\"><!--\\n%s\\n--></style>\\n\"\n\t    \"</head>\\n\"\n\t    \"<body>\\n\"\n\t    \"<h1>Index of %s</h1>\\n\"\n\t    \"<hr>\\n<pre>\\n\",\n\t    escapedpath, style, escapedpath) == -1)\n\t\tskip = 1;\n\n\tfree(escapedpath);\n\n\tfor (i = 0; i < namesize; i++) {\n\t\tdp = namelist[i];\n\n\t\tif (skip ||\n\t\t    fstatat(fd, dp->d_name, st, 0) == -1) {\n\t\t\tfree(dp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tt = st->st_mtime;\n\t\tlocaltime_r(&t, &tm);\n\t\tstrftime(tmstr, sizeof(tmstr), \"%d-%h-%Y %R\", &tm);\n\t\tnamewidth = 51 - strlen(dp->d_name);\n\n\t\tif ((escapeduri = url_encode(dp->d_name)) == NULL)\n\t\t\tgoto fail;\n\t\tif ((escapedhtml = escape_html(dp->d_name)) == NULL)\n\t\t\tgoto fail;\n\n\t\tif (dp->d_name[0] == '.' &&\n\t\t    !(dp->d_name[1] == '.' && dp->d_name[2] == '\\0')) {\n\t\t\t/* ignore hidden files starting with a dot */\n\t\t} else if (S_ISDIR(st->st_mode)) {\n\t\t\tnamewidth -= 1; /* trailing slash */\n\t\t\tif (evbuffer_add_printf(evb,\n\t\t\t    \"<a href=\\\"%s%s/\\\">%s/</a>%*s%s%20s\\n\",\n\t\t\t    strchr(escapeduri, ':') != NULL ? \"./\" : \"\",\n\t\t\t    escapeduri, escapedhtml,\n\t\t\t    MAXIMUM(namewidth, 0), \" \", tmstr, \"-\") == -1)\n\t\t\t\tskip = 1;\n\t\t} else if (S_ISREG(st->st_mode)) {\n\t\t\tif (evbuffer_add_printf(evb,\n\t\t\t    \"<a href=\\\"%s%s\\\">%s</a>%*s%s%20llu\\n\",\n\t\t\t    strchr(escapeduri, ':') != NULL ? \"./\" : \"\",\n\t\t\t    escapeduri, escapedhtml,\n\t\t\t    MAXIMUM(namewidth, 0), \" \",\n\t\t\t    tmstr, st->st_size) == -1)\n\t\t\t\tskip = 1;\n\t\t}\n\t\tfree(escapeduri);\n\t\tfree(escapedhtml);\n\t\tfree(dp);\n\t}\n\tfree(namelist);\n\n\tif (skip ||\n\t    evbuffer_add_printf(evb,\n\t    \"</pre>\\n<hr>\\n</body>\\n</html>\\n\") == -1)\n\t\tgoto abort;\n\n\tclose(fd);\n\tfd = -1;\n\n\tmedia = media_find_config(env, srv_conf, \"index.html\");\n\tret = server_response_http(clt, 200, media, EVBUFFER_LENGTH(evb),\n\t    dir_mtime);\n\tswitch (ret) {\n\tcase -1:\n\t\tgoto fail;\n\tcase 0:\n\t\t/* Connection is already finished */\n\t\tevbuffer_free(evb);\n\t\tgoto done;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (server_bufferevent_write_buffer(clt, evb) == -1)\n\t\tgoto fail;\n\tevbuffer_free(evb);\n\tevb = NULL;\n\n\tbufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);\n\tif (clt->clt_persist)\n\t\tclt->clt_toread = TOREAD_HTTP_HEADER;\n\telse\n\t\tclt->clt_toread = TOREAD_HTTP_NONE;\n\tclt->clt_done = 0;\n\n done:\n\tserver_reset_http(clt);\n\treturn (0);\n fail:\n\tbufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);\n\tbufferevent_free(clt->clt_bev);\n\tclt->clt_bev = NULL;\n abort:\n\tif (fd != -1)\n\t\tclose(fd);\n\tif (evb != NULL)\n\t\tevbuffer_free(evb);\n\tserver_abort_http(clt, code, desc->http_path);\n\treturn (-1);\n}\n\nvoid\nserver_file_error(struct bufferevent *bev, short error, void *arg)\n{\n\tstruct client\t\t*clt = arg;\n\tstruct evbuffer\t\t*dst;\n\n\tif (error & EVBUFFER_TIMEOUT) {\n\t\tserver_close(clt, \"buffer event timeout\");\n\t\treturn;\n\t}\n\tif (error & EVBUFFER_ERROR) {\n\t\tif (errno == EFBIG) {\n\t\t\tbufferevent_enable(bev, EV_READ);\n\t\t\treturn;\n\t\t}\n\t\tserver_close(clt, \"buffer event error\");\n\t\treturn;\n\t}\n\tif (error & (EVBUFFER_READ|EVBUFFER_WRITE|EVBUFFER_EOF)) {\n\t\tbufferevent_disable(bev, EV_READ|EV_WRITE);\n\n\t\tclt->clt_done = 1;\n\n\t\tif (clt->clt_persist) {\n\t\t\t/* Close input file and wait for next HTTP request */\n\t\t\tif (clt->clt_fd != -1)\n\t\t\t\tclose(clt->clt_fd);\n\t\t\tclt->clt_fd = -1;\n\t\t\tclt->clt_toread = TOREAD_HTTP_HEADER;\n\t\t\tserver_reset_http(clt);\n\t\t\tbufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);\n\t\t\treturn;\n\t\t}\n\n\t\tdst = EVBUFFER_OUTPUT(clt->clt_bev);\n\t\tif (EVBUFFER_LENGTH(dst)) {\n\t\t\t/* Finish writing all data first */\n\t\t\tbufferevent_enable(clt->clt_bev, EV_WRITE);\n\t\t\treturn;\n\t\t}\n\n\t\tserver_close(clt, \"done\");\n\t\treturn;\n\t}\n\tserver_close(clt, \"unknown event error\");\n\treturn;\n}\n\nint\nserver_file_modified_since(struct http_descriptor *desc, struct stat *st)\n{\n\tstruct kv\t key, *since;\n\tstruct tm\t tm;\n\n\tkey.kv_key = \"If-Modified-Since\";\n\tif ((since = kv_find(&desc->http_headers, &key)) != NULL &&\n\t    since->kv_value != NULL) {\n\t\tmemset(&tm, 0, sizeof(struct tm));\n\n\t\t/*\n\t\t * Return \"Not modified\" if the file hasn't changed since\n\t\t * the requested time.\n\t\t */\n\t\tif (strptime(since->kv_value,\n\t\t    \"%a, %d %h %Y %T %Z\", &tm) != NULL &&\n\t\t    timegm(&tm) >= st->st_mtim.tv_sec)\n\t\t\treturn (304);\n\t}\n\n\treturn (-1);\n}\n\nint\nparse_ranges(struct client *clt, char *str, size_t file_sz)\n{\n\tint\t\t\t i = 0;\n\tchar\t\t\t*p, *q;\n\tstruct range_data\t*r = &clt->clt_ranges;\n\n\tmemset(r, 0, sizeof(*r));\n\n\t/* Extract range unit */\n\tif ((p = strchr(str, '=')) == NULL)\n\t\treturn (-1);\n\n\t*p++ = '\\0';\n\t/* Check if it's a bytes range spec */\n\tif (strcmp(str, \"bytes\") != 0)\n\t\treturn (-1);\n\n\twhile ((q = strchr(p, ',')) != NULL) {\n\t\t*q++ = '\\0';\n\n\t\t/* Extract start and end positions */\n\t\tif (parse_range_spec(p, file_sz, &r->range[i]) == 0)\n\t\t\tcontinue;\n\n\t\ti++;\n\t\tif (i == SERVER_MAX_RANGES)\n\t\t\treturn (-1);\n\n\t\tp = q;\n\t}\n\n\tif (parse_range_spec(p, file_sz, &r->range[i]) != 0)\n\t\ti++;\n\n\tr->range_total = file_sz;\n\tr->range_count = i;\n\treturn (i);\n}\n\nint\nparse_range_spec(char *str, size_t size, struct range *r)\n{\n\tsize_t\t\t start_str_len, end_str_len;\n\tchar\t\t*p, *start_str, *end_str;\n\tconst char\t*errstr;\n\n\tif ((p = strchr(str, '-')) == NULL)\n\t\treturn (0);\n\n\t*p++ = '\\0';\n\tstart_str = str;\n\tend_str = p;\n\tstart_str_len = strlen(start_str);\n\tend_str_len = strlen(end_str);\n\n\t/* Either 'start' or 'end' is optional but not both */\n\tif ((start_str_len == 0) && (end_str_len == 0))\n\t\treturn (0);\n\n\tif (end_str_len) {\n\t\tr->end = strtonum(end_str, 0, LLONG_MAX, &errstr);\n\t\tif (errstr)\n\t\t\treturn (0);\n\n\t\tif ((size_t)r->end >= size)\n\t\t\tr->end = size - 1;\n\t} else\n\t\tr->end = size - 1;\n\n\tif (start_str_len) {\n\t\tr->start = strtonum(start_str, 0, LLONG_MAX, &errstr);\n\t\tif (errstr)\n\t\t\treturn (0);\n\n\t\tif ((size_t)r->start >= size)\n\t\t\treturn (0);\n\t} else {\n\t\tr->start = size - r->end;\n\t\tr->end = size - 1;\n\t}\n\n\tif (r->end < r->start)\n\t\treturn (0);\n\n\treturn (1);\n}\n", "/*\t$OpenBSD: server_http.c,v 1.112 2017/01/31 14:39:47 reyk Exp $\t*/\n\n/*\n * Copyright (c) 2006 - 2017 Reyk Floeter <reyk@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/queue.h>\n#include <sys/socket.h>\n#include <sys/tree.h>\n\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n#include <fnmatch.h>\n#include <stdio.h>\n#include <time.h>\n#include <resolv.h>\n#include <event.h>\n#include <ctype.h>\n#include <vis.h>\n\n#include \"httpd.h\"\n#include \"http.h\"\n#include \"patterns.h\"\n\nstatic int\t server_httpmethod_cmp(const void *, const void *);\nstatic int\t server_httperror_cmp(const void *, const void *);\nvoid\t\t server_httpdesc_free(struct http_descriptor *);\nint\t\t server_http_authenticate(struct server_config *,\n\t\t    struct client *);\nchar\t\t*server_expand_http(struct client *, const char *,\n\t\t    char *, size_t);\n\nstatic struct http_method\t http_methods[] = HTTP_METHODS;\nstatic struct http_error\t http_errors[] = HTTP_ERRORS;\n\nvoid\nserver_http(void)\n{\n\tDPRINTF(\"%s: sorting lookup tables, pid %d\", __func__, getpid());\n\n\t/* Sort the HTTP lookup arrays */\n\tqsort(http_methods, sizeof(http_methods) /\n\t    sizeof(http_methods[0]) - 1,\n\t    sizeof(http_methods[0]), server_httpmethod_cmp);\n\tqsort(http_errors, sizeof(http_errors) /\n\t    sizeof(http_errors[0]) - 1,\n\t    sizeof(http_errors[0]), server_httperror_cmp);\n}\n\nvoid\nserver_http_init(struct server *srv)\n{\n\t/* nothing */\n}\n\nint\nserver_httpdesc_init(struct client *clt)\n{\n\tstruct http_descriptor\t*desc;\n\n\tif ((desc = calloc(1, sizeof(*desc))) == NULL)\n\t\treturn (-1);\n\tRB_INIT(&desc->http_headers);\n\tclt->clt_descreq = desc;\n\n\tif ((desc = calloc(1, sizeof(*desc))) == NULL) {\n\t\t/* req will be cleaned up later */\n\t\treturn (-1);\n\t}\n\tRB_INIT(&desc->http_headers);\n\tclt->clt_descresp = desc;\n\n\treturn (0);\n}\n\nvoid\nserver_httpdesc_free(struct http_descriptor *desc)\n{\n\tif (desc == NULL)\n\t\treturn;\n\n\tfree(desc->http_path);\n\tdesc->http_path = NULL;\n\tfree(desc->http_path_alias);\n\tdesc->http_path_alias = NULL;\n\tfree(desc->http_query);\n\tdesc->http_query = NULL;\n\tfree(desc->http_version);\n\tdesc->http_version = NULL;\n\tfree(desc->http_host);\n\tdesc->http_host = NULL;\n\n\tkv_purge(&desc->http_headers);\n\tdesc->http_lastheader = NULL;\n\tdesc->http_method = 0;\n\tdesc->http_chunked = 0;\n}\n\nint\nserver_http_authenticate(struct server_config *srv_conf, struct client *clt)\n{\n\tchar\t\t\t decoded[1024];\n\tFILE\t\t\t*fp = NULL;\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tconst struct auth\t*auth = srv_conf->auth;\n\tstruct kv\t\t*ba, key;\n\tsize_t\t\t\t linesize = 0;\n\tssize_t\t\t\t linelen;\n\tint\t\t\t ret = -1;\n\tchar\t\t\t*line = NULL, *user = NULL, *pass = NULL;\n\tchar\t\t\t*clt_user = NULL, *clt_pass = NULL;\n\n\tmemset(decoded, 0, sizeof(decoded));\n\tkey.kv_key = \"Authorization\";\n\n\tif ((ba = kv_find(&desc->http_headers, &key)) == NULL ||\n\t    ba->kv_value == NULL)\n\t\tgoto done;\n\n\tif (strncmp(ba->kv_value, \"Basic \", strlen(\"Basic \")) != 0)\n\t\tgoto done;\n\n\tif (b64_pton(strchr(ba->kv_value, ' ') + 1, (uint8_t *)decoded,\n\t    sizeof(decoded)) <= 0)\n\t\tgoto done;\n\n\tif ((clt_pass = strchr(decoded, ':')) == NULL)\n\t\tgoto done;\n\n\tclt_user = decoded;\n\t*clt_pass++ = '\\0';\n\tif ((clt->clt_remote_user = strdup(clt_user)) == NULL)\n\t\tgoto done;\n\n\tif (clt_pass == NULL)\n\t\tgoto done;\n\n\tif ((fp = fopen(auth->auth_htpasswd, \"r\")) == NULL)\n\t\tgoto done;\n\n\twhile ((linelen = getline(&line, &linesize, fp)) != -1) {\n\t\tif (line[linelen - 1] == '\\n')\n\t\t\tline[linelen - 1] = '\\0';\n\t\tuser = line;\n\t\tpass = strchr(line, ':');\n\n\t\tif (pass == NULL) {\n\t\t\texplicit_bzero(line, linelen);\n\t\t\tcontinue;\n\t\t}\n\n\t\t*pass++ = '\\0';\n\n\t\tif (strcmp(clt_user, user) != 0) {\n\t\t\texplicit_bzero(line, linelen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (crypt_checkpass(clt_pass, pass) == 0) {\n\t\t\texplicit_bzero(line, linelen);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\tfree(line);\n\tif (fp != NULL)\n\t\tfclose(fp);\n\n\tif (ba != NULL && ba->kv_value != NULL) {\n\t\texplicit_bzero(ba->kv_value, strlen(ba->kv_value));\n\t\texplicit_bzero(decoded, sizeof(decoded));\n\t}\n\n\treturn (ret);\n}\n\nvoid\nserver_read_http(struct bufferevent *bev, void *arg)\n{\n\tstruct client\t\t*clt = arg;\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct evbuffer\t\t*src = EVBUFFER_INPUT(bev);\n\tchar\t\t\t*line = NULL, *key, *value;\n\tconst char\t\t*errstr;\n\tsize_t\t\t\t size, linelen;\n\tstruct kv\t\t*hdr = NULL;\n\n\tgetmonotime(&clt->clt_tv_last);\n\n\tsize = EVBUFFER_LENGTH(src);\n\tDPRINTF(\"%s: session %d: size %lu, to read %lld\",\n\t    __func__, clt->clt_id, size, clt->clt_toread);\n\tif (!size) {\n\t\tclt->clt_toread = TOREAD_HTTP_HEADER;\n\t\tgoto done;\n\t}\n\n\twhile (!clt->clt_headersdone && (line =\n\t    evbuffer_readln(src, NULL, EVBUFFER_EOL_CRLF_STRICT)) != NULL) {\n\t\tlinelen = strlen(line);\n\n\t\t/*\n\t\t * An empty line indicates the end of the request.\n\t\t * libevent already stripped the \\r\\n for us.\n\t\t */\n\t\tif (!linelen) {\n\t\t\tclt->clt_headersdone = 1;\n\t\t\tfree(line);\n\t\t\tbreak;\n\t\t}\n\t\tkey = line;\n\n\t\t/* Limit the total header length minus \\r\\n */\n\t\tclt->clt_headerlen += linelen;\n\t\tif (clt->clt_headerlen > SERVER_MAXHEADERLENGTH) {\n\t\t\tserver_abort_http(clt, 413, \"request too large\");\n\t\t\tgoto abort;\n\t\t}\n\n\t\t/*\n\t\t * The first line is the GET/POST/PUT/... request,\n\t\t * subsequent lines are HTTP headers.\n\t\t */\n\t\tif (++clt->clt_line == 1)\n\t\t\tvalue = strchr(key, ' ');\n\t\telse if (*key == ' ' || *key == '\\t')\n\t\t\t/* Multiline headers wrap with a space or tab */\n\t\t\tvalue = NULL;\n\t\telse\n\t\t\tvalue = strchr(key, ':');\n\t\tif (value == NULL) {\n\t\t\tif (clt->clt_line == 1) {\n\t\t\t\tserver_abort_http(clt, 400, \"malformed\");\n\t\t\t\tgoto abort;\n\t\t\t}\n\n\t\t\t/* Append line to the last header, if present */\n\t\t\tif (kv_extend(&desc->http_headers,\n\t\t\t    desc->http_lastheader, line) == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\tfree(line);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*value == ':') {\n\t\t\t*value++ = '\\0';\n\t\t\tvalue += strspn(value, \" \\t\\r\\n\");\n\t\t} else {\n\t\t\t*value++ = '\\0';\n\t\t}\n\n\t\tDPRINTF(\"%s: session %d: header '%s: %s'\", __func__,\n\t\t    clt->clt_id, key, value);\n\n\t\t/*\n\t\t * Identify and handle specific HTTP request methods\n\t\t */\n\t\tif (clt->clt_line == 1) {\n\t\t\tif ((desc->http_method = server_httpmethod_byname(key))\n\t\t\t    == HTTP_METHOD_NONE) {\n\t\t\t\tserver_abort_http(clt, 400, \"malformed\");\n\t\t\t\tgoto abort;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Decode request path and query\n\t\t\t */\n\t\t\tdesc->http_path = strdup(value);\n\t\t\tif (desc->http_path == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\tdesc->http_version = strchr(desc->http_path, ' ');\n\t\t\tif (desc->http_version == NULL) {\n\t\t\t\tserver_abort_http(clt, 400, \"malformed\");\n\t\t\t\tgoto abort;\n\t\t\t}\n\n\t\t\t*desc->http_version++ = '\\0';\n\t\t\tdesc->http_query = strchr(desc->http_path, '?');\n\t\t\tif (desc->http_query != NULL)\n\t\t\t\t*desc->http_query++ = '\\0';\n\n\t\t\t/*\n\t\t\t * Have to allocate the strings because they could\n\t\t\t * be changed independently by the filters later.\n\t\t\t */\n\t\t\tif ((desc->http_version =\n\t\t\t    strdup(desc->http_version)) == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\tif (desc->http_query != NULL &&\n\t\t\t    (desc->http_query =\n\t\t\t    strdup(desc->http_query)) == NULL)\n\t\t\t\tgoto fail;\n\n\t\t} else if (desc->http_method != HTTP_METHOD_NONE &&\n\t\t    strcasecmp(\"Content-Length\", key) == 0) {\n\t\t\tif (desc->http_method == HTTP_METHOD_TRACE ||\n\t\t\t    desc->http_method == HTTP_METHOD_CONNECT) {\n\t\t\t\t/*\n\t\t\t\t * These method should not have a body\n\t\t\t\t * and thus no Content-Length header.\n\t\t\t\t */\n\t\t\t\tserver_abort_http(clt, 400, \"malformed\");\n\t\t\t\tgoto abort;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Need to read data from the client after the\n\t\t\t * HTTP header.\n\t\t\t * XXX What about non-standard clients not using\n\t\t\t * the carriage return? And some browsers seem to\n\t\t\t * include the line length in the content-length.\n\t\t\t */\n\t\t\tclt->clt_toread = strtonum(value, 0, LLONG_MAX,\n\t\t\t    &errstr);\n\t\t\tif (errstr) {\n\t\t\t\tserver_abort_http(clt, 500, errstr);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tif ((size_t)clt->clt_toread >\n\t\t\t    srv_conf->maxrequestbody) {\n\t\t\t\tserver_abort_http(clt, 413, NULL);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\n\t\tif (strcasecmp(\"Transfer-Encoding\", key) == 0 &&\n\t\t    strcasecmp(\"chunked\", value) == 0)\n\t\t\tdesc->http_chunked = 1;\n\n\t\tif (clt->clt_line != 1) {\n\t\t\tif ((hdr = kv_add(&desc->http_headers, key,\n\t\t\t    value)) == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\tdesc->http_lastheader = hdr;\n\t\t}\n\n\t\tfree(line);\n\t}\n\tif (clt->clt_headersdone) {\n\t\tif (desc->http_method == HTTP_METHOD_NONE) {\n\t\t\tserver_abort_http(clt, 406, \"no method\");\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (desc->http_method) {\n\t\tcase HTTP_METHOD_CONNECT:\n\t\t\t/* Data stream */\n\t\t\tclt->clt_toread = TOREAD_UNLIMITED;\n\t\t\tbev->readcb = server_read;\n\t\t\tbreak;\n\t\tcase HTTP_METHOD_DELETE:\n\t\tcase HTTP_METHOD_GET:\n\t\tcase HTTP_METHOD_HEAD:\n\t\t/* WebDAV methods */\n\t\tcase HTTP_METHOD_COPY:\n\t\tcase HTTP_METHOD_MOVE:\n\t\t\tclt->clt_toread = 0;\n\t\t\tbreak;\n\t\tcase HTTP_METHOD_OPTIONS:\n\t\tcase HTTP_METHOD_POST:\n\t\tcase HTTP_METHOD_PUT:\n\t\tcase HTTP_METHOD_RESPONSE:\n\t\t/* WebDAV methods */\n\t\tcase HTTP_METHOD_PROPFIND:\n\t\tcase HTTP_METHOD_PROPPATCH:\n\t\tcase HTTP_METHOD_MKCOL:\n\t\tcase HTTP_METHOD_LOCK:\n\t\tcase HTTP_METHOD_UNLOCK:\n\t\tcase HTTP_METHOD_VERSION_CONTROL:\n\t\tcase HTTP_METHOD_REPORT:\n\t\tcase HTTP_METHOD_CHECKOUT:\n\t\tcase HTTP_METHOD_CHECKIN:\n\t\tcase HTTP_METHOD_UNCHECKOUT:\n\t\tcase HTTP_METHOD_MKWORKSPACE:\n\t\tcase HTTP_METHOD_UPDATE:\n\t\tcase HTTP_METHOD_LABEL:\n\t\tcase HTTP_METHOD_MERGE:\n\t\tcase HTTP_METHOD_BASELINE_CONTROL:\n\t\tcase HTTP_METHOD_MKACTIVITY:\n\t\tcase HTTP_METHOD_ORDERPATCH:\n\t\tcase HTTP_METHOD_ACL:\n\t\tcase HTTP_METHOD_MKREDIRECTREF:\n\t\tcase HTTP_METHOD_UPDATEREDIRECTREF:\n\t\tcase HTTP_METHOD_SEARCH:\n\t\tcase HTTP_METHOD_PATCH:\n\t\t\t/* HTTP request payload */\n\t\t\tif (clt->clt_toread > 0)\n\t\t\t\tbev->readcb = server_read_httpcontent;\n\n\t\t\t/* Single-pass HTTP body */\n\t\t\tif (clt->clt_toread < 0) {\n\t\t\t\tclt->clt_toread = TOREAD_UNLIMITED;\n\t\t\t\tbev->readcb = server_read;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tserver_abort_http(clt, 405, \"method not allowed\");\n\t\t\treturn;\n\t\t}\n\t\tif (desc->http_chunked) {\n\t\t\t/* Chunked transfer encoding */\n\t\t\tclt->clt_toread = TOREAD_HTTP_CHUNK_LENGTH;\n\t\t\tbev->readcb = server_read_httpchunks;\n\t\t}\n\n done:\n\t\tif (clt->clt_toread != 0)\n\t\t\tbufferevent_disable(bev, EV_READ);\n\t\tserver_response(httpd_env, clt);\n\t\treturn;\n\t}\n\tif (clt->clt_done) {\n\t\tserver_close(clt, \"done\");\n\t\treturn;\n\t}\n\tif (EVBUFFER_LENGTH(src) && bev->readcb != server_read_http)\n\t\tbev->readcb(bev, arg);\n\tbufferevent_enable(bev, EV_READ);\n\treturn;\n fail:\n\tserver_abort_http(clt, 500, strerror(errno));\n abort:\n\tfree(line);\n}\n\nvoid\nserver_read_httpcontent(struct bufferevent *bev, void *arg)\n{\n\tstruct client\t\t*clt = arg;\n\tstruct evbuffer\t\t*src = EVBUFFER_INPUT(bev);\n\tsize_t\t\t\t size;\n\n\tgetmonotime(&clt->clt_tv_last);\n\n\tsize = EVBUFFER_LENGTH(src);\n\tDPRINTF(\"%s: session %d: size %lu, to read %lld\", __func__,\n\t    clt->clt_id, size, clt->clt_toread);\n\tif (!size)\n\t\treturn;\n\n\tif (clt->clt_toread > 0) {\n\t\t/* Read content data */\n\t\tif ((off_t)size > clt->clt_toread) {\n\t\t\tsize = clt->clt_toread;\n\t\t\tif (fcgi_add_stdin(clt, src) == -1)\n\t\t\t\tgoto fail;\n\t\t\tclt->clt_toread = 0;\n\t\t} else {\n\t\t\tif (fcgi_add_stdin(clt, src) == -1)\n\t\t\t\tgoto fail;\n\t\t\tclt->clt_toread -= size;\n\t\t}\n\t\tDPRINTF(\"%s: done, size %lu, to read %lld\", __func__,\n\t\t    size, clt->clt_toread);\n\t}\n\tif (clt->clt_toread == 0) {\n\t\tfcgi_add_stdin(clt, NULL);\n\t\tclt->clt_toread = TOREAD_HTTP_HEADER;\n\t\tbufferevent_disable(bev, EV_READ);\n\t\tbev->readcb = server_read_http;\n\t\treturn;\n\t}\n\tif (clt->clt_done)\n\t\tgoto done;\n\tif (bev->readcb != server_read_httpcontent)\n\t\tbev->readcb(bev, arg);\n\n\treturn;\n done:\n\treturn;\n fail:\n\tserver_close(clt, strerror(errno));\n}\n\nvoid\nserver_read_httpchunks(struct bufferevent *bev, void *arg)\n{\n\tstruct client\t\t*clt = arg;\n\tstruct evbuffer\t\t*src = EVBUFFER_INPUT(bev);\n\tchar\t\t\t*line;\n\tlong long\t\t llval;\n\tsize_t\t\t\t size;\n\n\tgetmonotime(&clt->clt_tv_last);\n\n\tsize = EVBUFFER_LENGTH(src);\n\tDPRINTF(\"%s: session %d: size %lu, to read %lld\", __func__,\n\t    clt->clt_id, size, clt->clt_toread);\n\tif (!size)\n\t\treturn;\n\n\tif (clt->clt_toread > 0) {\n\t\t/* Read chunk data */\n\t\tif ((off_t)size > clt->clt_toread) {\n\t\t\tsize = clt->clt_toread;\n\t\t\tif (server_bufferevent_write_chunk(clt, src, size)\n\t\t\t    == -1)\n\t\t\t\tgoto fail;\n\t\t\tclt->clt_toread = 0;\n\t\t} else {\n\t\t\tif (server_bufferevent_write_buffer(clt, src) == -1)\n\t\t\t\tgoto fail;\n\t\t\tclt->clt_toread -= size;\n\t\t}\n\t\tDPRINTF(\"%s: done, size %lu, to read %lld\", __func__,\n\t\t    size, clt->clt_toread);\n\t}\n\tswitch (clt->clt_toread) {\n\tcase TOREAD_HTTP_CHUNK_LENGTH:\n\t\tline = evbuffer_readln(src, NULL, EVBUFFER_EOL_CRLF_STRICT);\n\t\tif (line == NULL) {\n\t\t\t/* Ignore empty line, continue */\n\t\t\tbufferevent_enable(bev, EV_READ);\n\t\t\treturn;\n\t\t}\n\t\tif (strlen(line) == 0) {\n\t\t\tfree(line);\n\t\t\tgoto next;\n\t\t}\n\n\t\t/*\n\t\t * Read prepended chunk size in hex, ignore the trailer.\n\t\t * The returned signed value must not be negative.\n\t\t */\n\t\tif (sscanf(line, \"%llx\", &llval) != 1 || llval < 0) {\n\t\t\tfree(line);\n\t\t\tserver_close(clt, \"invalid chunk size\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (server_bufferevent_print(clt, line) == -1 ||\n\t\t    server_bufferevent_print(clt, \"\\r\\n\") == -1) {\n\t\t\tfree(line);\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(line);\n\n\t\tif ((clt->clt_toread = llval) == 0) {\n\t\t\tDPRINTF(\"%s: last chunk\", __func__);\n\t\t\tclt->clt_toread = TOREAD_HTTP_CHUNK_TRAILER;\n\t\t}\n\t\tbreak;\n\tcase TOREAD_HTTP_CHUNK_TRAILER:\n\t\t/* Last chunk is 0 bytes followed by trailer and empty line */\n\t\tline = evbuffer_readln(src, NULL, EVBUFFER_EOL_CRLF_STRICT);\n\t\tif (line == NULL) {\n\t\t\t/* Ignore empty line, continue */\n\t\t\tbufferevent_enable(bev, EV_READ);\n\t\t\treturn;\n\t\t}\n\t\tif (server_bufferevent_print(clt, line) == -1 ||\n\t\t    server_bufferevent_print(clt, \"\\r\\n\") == -1) {\n\t\t\tfree(line);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (strlen(line) == 0) {\n\t\t\t/* Switch to HTTP header mode */\n\t\t\tclt->clt_toread = TOREAD_HTTP_HEADER;\n\t\t\tbev->readcb = server_read_http;\n\t\t}\n\t\tfree(line);\n\t\tbreak;\n\tcase 0:\n\t\t/* Chunk is terminated by an empty newline */\n\t\tline = evbuffer_readln(src, NULL, EVBUFFER_EOL_CRLF_STRICT);\n\t\tfree(line);\n\t\tif (server_bufferevent_print(clt, \"\\r\\n\") == -1)\n\t\t\tgoto fail;\n\t\tclt->clt_toread = TOREAD_HTTP_CHUNK_LENGTH;\n\t\tbreak;\n\t}\n\n next:\n\tif (clt->clt_done)\n\t\tgoto done;\n\tif (EVBUFFER_LENGTH(src))\n\t\tbev->readcb(bev, arg);\n\tbufferevent_enable(bev, EV_READ);\n\treturn;\n\n done:\n\tserver_close(clt, \"last http chunk read (done)\");\n\treturn;\n fail:\n\tserver_close(clt, strerror(errno));\n}\n\nvoid\nserver_read_httprange(struct bufferevent *bev, void *arg)\n{\n\tstruct client\t\t*clt = arg;\n\tstruct evbuffer\t\t*src = EVBUFFER_INPUT(bev);\n\tsize_t\t\t\t size;\n\tstruct media_type\t*media;\n\tstruct range_data\t*r = &clt->clt_ranges;\n\tstruct range\t\t*range;\n\n\tgetmonotime(&clt->clt_tv_last);\n\n\tif (r->range_toread > 0) {\n\t\tsize = EVBUFFER_LENGTH(src);\n\t\tif (!size)\n\t\t\treturn;\n\n\t\t/* Read chunk data */\n\t\tif ((off_t)size > r->range_toread) {\n\t\t\tsize = r->range_toread;\n\t\t\tif (server_bufferevent_write_chunk(clt, src, size)\n\t\t\t    == -1)\n\t\t\t\tgoto fail;\n\t\t\tr->range_toread = 0;\n\t\t} else {\n\t\t\tif (server_bufferevent_write_buffer(clt, src) == -1)\n\t\t\t\tgoto fail;\n\t\t\tr->range_toread -= size;\n\t\t}\n\t\tif (r->range_toread < 1)\n\t\t\tr->range_toread = TOREAD_HTTP_RANGE;\n\t\tDPRINTF(\"%s: done, size %lu, to read %lld\", __func__,\n\t\t    size, r->range_toread);\n\t}\n\n\tswitch (r->range_toread) {\n\tcase TOREAD_HTTP_RANGE:\n\t\tif (r->range_index >= r->range_count) {\n\t\t\tif (r->range_count > 1) {\n\t\t\t\t/* Add end marker */\n\t\t\t\tif (server_bufferevent_printf(clt,\n\t\t\t\t    \"\\r\\n--%llu--\\r\\n\",\n\t\t\t\t    clt->clt_boundary) == -1)\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tr->range_toread = TOREAD_HTTP_NONE;\n\t\t\tbreak;\n\t\t}\n\n\t\trange = &r->range[r->range_index];\n\n\t\tif (r->range_count > 1) {\n\t\t\tmedia = r->range_media;\n\t\t\tif (server_bufferevent_printf(clt,\n\t\t\t    \"\\r\\n--%llu\\r\\n\"\n\t\t\t    \"Content-Type: %s/%s\\r\\n\"\n\t\t\t    \"Content-Range: bytes %lld-%lld/%zu\\r\\n\\r\\n\",\n\t\t\t    clt->clt_boundary,\n\t\t\t    media->media_type, media->media_subtype,\n\t\t\t    range->start, range->end, r->range_total) == -1)\n\t\t\t\tgoto fail;\n\t\t}\n\t\tr->range_toread = range->end - range->start + 1;\n\n\t\tif (lseek(clt->clt_fd, range->start, SEEK_SET) == -1)\n\t\t\tgoto fail;\n\n\t\t/* Throw away bytes that are already in the input buffer */\n\t\tevbuffer_drain(src, EVBUFFER_LENGTH(src));\n\n\t\t/* Increment for the next part */\n\t\tr->range_index++;\n\t\tbreak;\n\tcase TOREAD_HTTP_NONE:\n\tcase 0:\n\t\tbreak;\n\t}\n\n\tif (clt->clt_done)\n\t\tgoto done;\n\n\tif (EVBUFFER_LENGTH(EVBUFFER_OUTPUT(clt->clt_bev)) > (size_t)\n\t    SERVER_MAX_PREFETCH * clt->clt_sndbufsiz) {\n\t\tbufferevent_disable(clt->clt_srvbev, EV_READ);\n\t\tclt->clt_srvbev_throttled = 1;\n\t}\n\n\treturn;\n done:\n\t(*bev->errorcb)(bev, EVBUFFER_READ, bev->cbarg);\n\treturn;\n fail:\n\tserver_close(clt, strerror(errno));\n}\n\nvoid\nserver_reset_http(struct client *clt)\n{\n\tstruct server\t\t*srv = clt->clt_srv;\n\n\tserver_log(clt, NULL);\n\n\tserver_httpdesc_free(clt->clt_descreq);\n\tserver_httpdesc_free(clt->clt_descresp);\n\tclt->clt_headerlen = 0;\n\tclt->clt_headersdone = 0;\n\tclt->clt_done = 0;\n\tclt->clt_line = 0;\n\tclt->clt_chunk = 0;\n\tfree(clt->clt_remote_user);\n\tclt->clt_remote_user = NULL;\n\tclt->clt_bev->readcb = server_read_http;\n\tclt->clt_srv_conf = &srv->srv_conf;\n\tstr_match_free(&clt->clt_srv_match);\n}\n\nssize_t\nserver_http_time(time_t t, char *tmbuf, size_t len)\n{\n\tstruct tm\t\t tm;\n\n\t/* New HTTP/1.1 RFC 7231 prefers IMF-fixdate from RFC 5322 */\n\tif (t == -1 || gmtime_r(&t, &tm) == NULL)\n\t\treturn (-1);\n\telse\n\t\treturn (strftime(tmbuf, len, \"%a, %d %h %Y %T %Z\", &tm));\n}\n\nconst char *\nserver_http_host(struct sockaddr_storage *ss, char *buf, size_t len)\n{\n\tchar\t\thbuf[HOST_NAME_MAX+1];\n\tin_port_t\tport;\n\n\tif (print_host(ss, buf, len) == NULL)\n\t\treturn (NULL);\n\n\tport = ntohs(server_socket_getport(ss));\n\tif (port == HTTP_PORT)\n\t\treturn (buf);\n\n\tswitch (ss->ss_family) {\n\tcase AF_INET:\n\t\tif ((size_t)snprintf(hbuf, sizeof(hbuf),\n\t\t    \"%s:%u\", buf, port) >= sizeof(hbuf))\n\t\t\treturn (NULL);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif ((size_t)snprintf(hbuf, sizeof(hbuf),\n\t\t    \"[%s]:%u\", buf, port) >= sizeof(hbuf))\n\t\t\treturn (NULL);\n\t\tbreak;\n\t}\n\n\tif (strlcpy(buf, hbuf, len) >= len)\n\t\treturn (NULL);\n\n\treturn (buf);\n}\n\nchar *\nserver_http_parsehost(char *host, char *buf, size_t len, int *portval)\n{\n\tchar\t\t*start, *end, *port;\n\tconst char\t*errstr = NULL;\n\n\tif (strlcpy(buf, host, len) >= len) {\n\t\tlog_debug(\"%s: host name too long\", __func__);\n\t\treturn (NULL);\n\t}\n\n\tstart = buf;\n\tend = port = NULL;\n\n\tif (*start == '[' && (end = strchr(start, ']')) != NULL) {\n\t\t/* Address enclosed in [] with port, eg. [2001:db8::1]:80 */\n\t\tstart++;\n\t\t*end++ = '\\0';\n\t\tif ((port = strchr(end, ':')) == NULL || *port == '\\0')\n\t\t\tport = NULL;\n\t\telse\n\t\t\tport++;\n\t\tmemmove(buf, start, strlen(start) + 1);\n\t} else if ((end = strchr(start, ':')) != NULL) {\n\t\t/* Name or address with port, eg. www.example.com:80 */\n\t\t*end++ = '\\0';\n\t\tport = end;\n\t} else {\n\t\t/* Name or address with default port, eg. www.example.com */\n\t\tport = NULL;\n\t}\n\n\tif (port != NULL) {\n\t\t/* Save the requested port */\n\t\t*portval = strtonum(port, 0, 0xffff, &errstr);\n\t\tif (errstr != NULL) {\n\t\t\tlog_debug(\"%s: invalid port: %s\", __func__,\n\t\t\t    strerror(errno));\n\t\t\treturn (NULL);\n\t\t}\n\t\t*portval = htons(*portval);\n\t} else {\n\t\t/* Port not given, indicate the default port */\n\t\t*portval = -1;\n\t}\n\n\treturn (start);\n}\n\nvoid\nserver_abort_http(struct client *clt, unsigned int code, const char *msg)\n{\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tstruct bufferevent\t*bev = clt->clt_bev;\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tconst char\t\t*httperr = NULL, *style;\n\tchar\t\t\t*httpmsg, *body = NULL, *extraheader = NULL;\n\tchar\t\t\t tmbuf[32], hbuf[128], *hstsheader = NULL;\n\tchar\t\t\t buf[IBUF_READ_SIZE];\n\tchar\t\t\t*escapedmsg = NULL;\n\tint\t\t\t bodylen;\n\n\tif (code == 0) {\n\t\tserver_close(clt, \"dropped\");\n\t\treturn;\n\t}\n\n\tif ((httperr = server_httperror_byid(code)) == NULL)\n\t\thttperr = \"Unknown Error\";\n\n\tif (bev == NULL)\n\t\tgoto done;\n\n\tif (server_log_http(clt, code, 0) == -1)\n\t\tgoto done;\n\n\t/* Some system information */\n\tif (print_host(&srv_conf->ss, hbuf, sizeof(hbuf)) == NULL)\n\t\tgoto done;\n\n\tif (server_http_time(time(NULL), tmbuf, sizeof(tmbuf)) <= 0)\n\t\tgoto done;\n\n\t/* Do not send details of the Internal Server Error */\n\tswitch (code) {\n\tcase 301:\n\tcase 302:\n\tcase 303:\n\t\tif (msg == NULL)\n\t\t\tbreak;\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tif (server_expand_http(clt, msg, buf, sizeof(buf)) == NULL)\n\t\t\tgoto done;\n\t\tif (asprintf(&extraheader, \"Location: %s\\r\\n\", buf) == -1) {\n\t\t\tcode = 500;\n\t\t\textraheader = NULL;\n\t\t}\n\t\tmsg = buf;\n\t\tbreak;\n\tcase 401:\n\t\tif (stravis(&escapedmsg, msg, VIS_DQ) == -1) {\n\t\t\tcode = 500;\n\t\t\textraheader = NULL;\n\t\t} else if (asprintf(&extraheader,\n\t\t    \"WWW-Authenticate: Basic realm=\\\"%s\\\"\\r\\n\", escapedmsg)\n\t\t    == -1) {\n\t\t\tcode = 500;\n\t\t\textraheader = NULL;\n\t\t}\n\t\tbreak;\n\tcase 416:\n\t\tif (asprintf(&extraheader,\n\t\t    \"Content-Range: %s\\r\\n\", msg) == -1) {\n\t\t\tcode = 500;\n\t\t\textraheader = NULL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Do not send details of the error.  Traditionally,\n\t\t * web servers responsed with the request path on 40x\n\t\t * errors which could be abused to inject JavaScript etc.\n\t\t * Instead of sanitizing the path here, we just don't\n\t\t * reprint it.\n\t\t */\n\t\tbreak;\n\t}\n\n\tfree(escapedmsg);\n\n\t/* A CSS stylesheet allows minimal customization by the user */\n\tstyle = \"body { background-color: white; color: black; font-family: \"\n\t    \"'Comic Sans MS', 'Chalkboard SE', 'Comic Neue', sans-serif; }\\n\"\n\t    \"hr { border: 0; border-bottom: 1px dashed; }\\n\";\n\n\t/* Generate simple HTML error document */\n\tif ((bodylen = asprintf(&body,\n\t    \"<!DOCTYPE html>\\n\"\n\t    \"<html>\\n\"\n\t    \"<head>\\n\"\n\t    \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; \"\n\t    \"charset=utf-8\\\"/>\\n\"\n\t    \"<title>%03d %s</title>\\n\"\n\t    \"<style type=\\\"text/css\\\"><!--\\n%s\\n--></style>\\n\"\n\t    \"</head>\\n\"\n\t    \"<body>\\n\"\n\t    \"<h1>%03d %s</h1>\\n\"\n\t    \"<hr>\\n<address>%s</address>\\n\"\n\t    \"</body>\\n\"\n\t    \"</html>\\n\",\n\t    code, httperr, style, code, httperr, HTTPD_SERVERNAME)) == -1) {\n\t\tbody = NULL;\n\t\tgoto done;\n\t}\n\n\tif (srv_conf->flags & SRVFLAG_SERVER_HSTS) {\n\t\tif (asprintf(&hstsheader, \"Strict-Transport-Security: \"\n\t\t    \"max-age=%d%s%s\\r\\n\", srv_conf->hsts_max_age,\n\t\t    srv_conf->hsts_flags & HSTSFLAG_SUBDOMAINS ?\n\t\t    \"; includeSubDomains\" : \"\",\n\t\t    srv_conf->hsts_flags & HSTSFLAG_PRELOAD ?\n\t\t    \"; preload\" : \"\") == -1) {\n\t\t\thstsheader = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Add basic HTTP headers */\n\tif (asprintf(&httpmsg,\n\t    \"HTTP/1.0 %03d %s\\r\\n\"\n\t    \"Date: %s\\r\\n\"\n\t    \"Server: %s\\r\\n\"\n\t    \"Connection: close\\r\\n\"\n\t    \"Content-Type: text/html\\r\\n\"\n\t    \"Content-Length: %d\\r\\n\"\n\t    \"%s\"\n\t    \"%s\"\n\t    \"\\r\\n\"\n\t    \"%s\",\n\t    code, httperr, tmbuf, HTTPD_SERVERNAME, bodylen,\n\t    extraheader == NULL ? \"\" : extraheader,\n\t    hstsheader == NULL ? \"\" : hstsheader,\n\t    desc->http_method == HTTP_METHOD_HEAD ? \"\" : body) == -1)\n\t\tgoto done;\n\n\t/* Dump the message without checking for success */\n\tserver_dump(clt, httpmsg, strlen(httpmsg));\n\tfree(httpmsg);\n\n done:\n\tfree(body);\n\tfree(extraheader);\n\tfree(hstsheader);\n\tif (msg == NULL)\n\t\tmsg = \"\\\"\\\"\";\n\tif (asprintf(&httpmsg, \"%s (%03d %s)\", msg, code, httperr) == -1) {\n\t\tserver_close(clt, msg);\n\t} else {\n\t\tserver_close(clt, httpmsg);\n\t\tfree(httpmsg);\n\t}\n}\n\nvoid\nserver_close_http(struct client *clt)\n{\n\tstruct http_descriptor *desc;\n\n\tdesc = clt->clt_descreq;\n\tserver_httpdesc_free(desc);\n\tfree(desc);\n\tclt->clt_descreq = NULL;\n\n\tdesc = clt->clt_descresp;\n\tserver_httpdesc_free(desc);\n\tfree(desc);\n\tclt->clt_descresp = NULL;\n\tfree(clt->clt_remote_user);\n\tclt->clt_remote_user = NULL;\n\n\tstr_match_free(&clt->clt_srv_match);\n}\n\nchar *\nserver_expand_http(struct client *clt, const char *val, char *buf,\n    size_t len)\n{\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tchar\t\t\t ibuf[128], *str, *path, *query;\n\tconst char\t\t*errstr = NULL, *p;\n\tsize_t\t\t\t size;\n\tint\t\t\t n, ret;\n\n\tif (strlcpy(buf, val, len) >= len)\n\t\treturn (NULL);\n\n\t/* Find previously matched substrings by index */\n\tfor (p = val; clt->clt_srv_match.sm_nmatch &&\n\t    (p = strstr(p, \"%\")) != NULL; p++) {\n\t\tif (!isdigit((unsigned char)*(p + 1)))\n\t\t\tcontinue;\n\n\t\t/* Copy number, leading '%' char and add trailing \\0 */\n\t\tsize = strspn(p + 1, \"0123456789\") + 2;\n\t\tif (size  >= sizeof(ibuf))\n\t\t\treturn (NULL);\n\t\t(void)strlcpy(ibuf, p, size);\n\t\tn = strtonum(ibuf + 1, 0,\n\t\t    clt->clt_srv_match.sm_nmatch - 1, &errstr);\n\t\tif (errstr != NULL)\n\t\t\treturn (NULL);\n\n\t\t/* Expand variable with matched value */\n\t\tif ((str = url_encode(clt->clt_srv_match.sm_match[n])) == NULL)\n\t\t\treturn (NULL);\n\t\tret = expand_string(buf, len, ibuf, str);\n\t\tfree(str);\n\t\tif (ret != 0)\n\t\t\treturn (NULL);\n\t}\n\tif (strstr(val, \"$DOCUMENT_URI\") != NULL) {\n\t\tif ((path = url_encode(desc->http_path)) == NULL)\n\t\t\treturn (NULL);\n\t\tret = expand_string(buf, len, \"$DOCUMENT_URI\", path);\n\t\tfree(path);\n\t\tif (ret != 0)\n\t\t\treturn (NULL);\n\t}\n\tif (strstr(val, \"$QUERY_STRING\") != NULL) {\n\t\tif (desc->http_query == NULL) {\n\t\t\tret = expand_string(buf, len, \"$QUERY_STRING\", \"\");\n\t\t} else {\n\t\t\tif ((query = url_encode(desc->http_query)) == NULL)\n\t\t\t\treturn (NULL);\n\t\t\tret = expand_string(buf, len, \"$QUERY_STRING\", query);\n\t\t\tfree(query);\n\t\t}\n\t\tif (ret != 0)\n\t\t\treturn (NULL);\n\t}\n\tif (strstr(val, \"$REMOTE_\") != NULL) {\n\t\tif (strstr(val, \"$REMOTE_ADDR\") != NULL) {\n\t\t\tif (print_host(&clt->clt_ss,\n\t\t\t    ibuf, sizeof(ibuf)) == NULL)\n\t\t\t\treturn (NULL);\n\t\t\tif (expand_string(buf, len,\n\t\t\t    \"$REMOTE_ADDR\", ibuf) != 0)\n\t\t\t\treturn (NULL);\n\t\t}\n\t\tif (strstr(val, \"$REMOTE_PORT\") != NULL) {\n\t\t\tsnprintf(ibuf, sizeof(ibuf),\n\t\t\t    \"%u\", ntohs(clt->clt_port));\n\t\t\tif (expand_string(buf, len,\n\t\t\t    \"$REMOTE_PORT\", ibuf) != 0)\n\t\t\t\treturn (NULL);\n\t\t}\n\t\tif (strstr(val, \"$REMOTE_USER\") != NULL) {\n\t\t\tif ((srv_conf->flags & SRVFLAG_AUTH) &&\n\t\t\t    clt->clt_remote_user != NULL) {\n\t\t\t\tif ((str = url_encode(clt->clt_remote_user))\n\t\t\t\t    == NULL)\n\t\t\t\t\treturn (NULL);\n\t\t\t} else\n\t\t\t\tstr = strdup(\"\");\n\t\t\tret = expand_string(buf, len, \"$REMOTE_USER\", str);\n\t\t\tfree(str);\n\t\t\tif (ret != 0)\n\t\t\t\treturn (NULL);\n\t\t}\n\t}\n\tif (strstr(val, \"$REQUEST_URI\") != NULL) {\n\t\tif ((path = url_encode(desc->http_path)) == NULL)\n\t\t\treturn (NULL);\n\t\tif (desc->http_query == NULL) {\n\t\t\tstr = path;\n\t\t} else {\n\t\t\tif ((query = url_encode(desc->http_query)) == NULL) {\n\t\t\t\tfree(path);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tret = asprintf(&str, \"%s?%s\", path, query);\n\t\t\tfree(path);\n\t\t\tfree(query);\n\t\t\tif (ret == -1)\n\t\t\t\treturn (NULL);\n\t\t}\n\n\t\tret = expand_string(buf, len, \"$REQUEST_URI\", str);\n\t\tfree(str);\n\t\tif (ret != 0)\n\t\t\treturn (NULL);\n\t}\n\tif (strstr(val, \"$SERVER_\") != NULL) {\n\t\tif (strstr(val, \"$SERVER_ADDR\") != NULL) {\n\t\t\tif (print_host(&srv_conf->ss,\n\t\t\t    ibuf, sizeof(ibuf)) == NULL)\n\t\t\t\treturn (NULL);\n\t\t\tif (expand_string(buf, len,\n\t\t\t    \"$SERVER_ADDR\", ibuf) != 0)\n\t\t\t\treturn (NULL);\n\t\t}\n\t\tif (strstr(val, \"$SERVER_PORT\") != NULL) {\n\t\t\tsnprintf(ibuf, sizeof(ibuf), \"%u\",\n\t\t\t    ntohs(srv_conf->port));\n\t\t\tif (expand_string(buf, len,\n\t\t\t    \"$SERVER_PORT\", ibuf) != 0)\n\t\t\t\treturn (NULL);\n\t\t}\n\t\tif (strstr(val, \"$SERVER_NAME\") != NULL) {\n\t\t\tif ((str = url_encode(srv_conf->name))\n\t\t\t     == NULL)\n\t\t\t\treturn (NULL);\n\t\t\tret = expand_string(buf, len, \"$SERVER_NAME\", str);\n\t\t\tfree(str);\n\t\t\tif (ret != 0)\n\t\t\t\treturn (NULL);\n\t\t}\n\t}\n\n\treturn (buf);\n}\n\nint\nserver_response(struct httpd *httpd, struct client *clt)\n{\n\tchar\t\t\t path[PATH_MAX];\n\tchar\t\t\t hostname[HOST_NAME_MAX+1];\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct server\t\t*srv = clt->clt_srv;\n\tstruct server_config\t*srv_conf = &srv->srv_conf;\n\tstruct kv\t\t*kv, key, *host;\n\tstruct str_find\t\t sm;\n\tint\t\t\t portval = -1, ret;\n\tchar\t\t\t*hostval;\n\tconst char\t\t*errstr = NULL;\n\n\t/* Canonicalize the request path */\n\tif (desc->http_path == NULL ||\n\t    url_decode(desc->http_path) == NULL ||\n\t    canonicalize_path(desc->http_path, path, sizeof(path)) == NULL)\n\t\tgoto fail;\n\tfree(desc->http_path);\n\tif ((desc->http_path = strdup(path)) == NULL)\n\t\tgoto fail;\n\n\tkey.kv_key = \"Host\";\n\tif ((host = kv_find(&desc->http_headers, &key)) != NULL &&\n\t    host->kv_value == NULL)\n\t\thost = NULL;\n\n\tif (strcmp(desc->http_version, \"HTTP/1.1\") == 0) {\n\t\t/* Host header is mandatory */\n\t\tif (host == NULL)\n\t\t\tgoto fail;\n\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"close\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist = 0;\n\t\telse\n\t\t\tclt->clt_persist++;\n\t} else {\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"keep-alive\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist++;\n\t\telse\n\t\t\tclt->clt_persist = 0;\n\t}\n\n\tif (clt->clt_persist >= srv_conf->maxrequests)\n\t\tclt->clt_persist = 0;\n\n\t/*\n\t * Do we have a Host header and matching configuration?\n\t * XXX the Host can also appear in the URL path.\n\t */\n\tif (host != NULL) {\n\t\tif ((hostval = server_http_parsehost(host->kv_value,\n\t\t    hostname, sizeof(hostname), &portval)) == NULL)\n\t\t\tgoto fail;\n\n\t\tTAILQ_FOREACH(srv_conf, &srv->srv_hosts, entry) {\n#ifdef DEBUG\n\t\t\tif ((srv_conf->flags & SRVFLAG_LOCATION) == 0) {\n\t\t\t\tDPRINTF(\"%s: virtual host \\\"%s:%u\\\"\"\n\t\t\t\t    \" host \\\"%s\\\" (\\\"%s\\\")\",\n\t\t\t\t    __func__, srv_conf->name,\n\t\t\t\t    ntohs(srv_conf->port), host->kv_value,\n\t\t\t\t    hostname);\n\t\t\t}\n#endif\n\t\t\tif (srv_conf->flags & SRVFLAG_LOCATION)\n\t\t\t\tcontinue;\n\t\t\telse if (srv_conf->flags & SRVFLAG_SERVER_MATCH) {\n\t\t\t\tstr_find(hostname, srv_conf->name,\n\t\t\t\t    &sm, 1, &errstr);\n\t\t\t\tret = errstr == NULL ? 0 : -1;\n\t\t\t} else {\n\t\t\t\tret = fnmatch(srv_conf->name,\n\t\t\t\t    hostname, FNM_CASEFOLD);\n\t\t\t}\n\t\t\tif (ret == 0 &&\n\t\t\t    (portval == -1 ||\n\t\t\t    (portval != -1 && portval == srv_conf->port))) {\n\t\t\t\t/* Replace host configuration */\n\t\t\t\tclt->clt_srv_conf = srv_conf;\n\t\t\t\tsrv_conf = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (srv_conf != NULL) {\n\t\t/* Use the actual server IP address */\n\t\tif (server_http_host(&clt->clt_srv_ss, hostname,\n\t\t    sizeof(hostname)) == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\t/* Host header was valid and found */\n\t\tif (strlcpy(hostname, host->kv_value, sizeof(hostname)) >=\n\t\t    sizeof(hostname))\n\t\t\tgoto fail;\n\t\tsrv_conf = clt->clt_srv_conf;\n\t}\n\n\tif ((desc->http_host = strdup(hostname)) == NULL)\n\t\tgoto fail;\n\n\t/* Now fill in the mandatory parts of the response descriptor */\n\tresp->http_method = desc->http_method;\n\tif ((resp->http_version = strdup(desc->http_version)) == NULL)\n\t\tgoto fail;\n\n\t/* Now search for the location */\n\tsrv_conf = server_getlocation(clt, desc->http_path);\n\n\tif (srv_conf->flags & SRVFLAG_BLOCK) {\n\t\tserver_abort_http(clt, srv_conf->return_code,\n\t\t    srv_conf->return_uri);\n\t\treturn (-1);\n\t} else if (srv_conf->flags & SRVFLAG_AUTH &&\n\t    server_http_authenticate(srv_conf, clt) == -1) {\n\t\tserver_abort_http(clt, 401, srv_conf->auth_realm);\n\t\treturn (-1);\n\t} else\n\t\treturn (server_file(httpd, clt));\n fail:\n\tserver_abort_http(clt, 400, \"bad request\");\n\treturn (-1);\n}\n\nconst char *\nserver_root_strip(const char *path, int n)\n{\n\tconst char *p;\n\n\t/* Strip strip leading directories. Leading '/' is ignored. */\n\tfor (; n > 0 && *path != '\\0'; n--)\n\t\tif ((p = strchr(++path, '/')) == NULL)\n\t\t\tpath = strchr(path, '\\0');\n\t\telse\n\t\t\tpath = p;\n\n\treturn (path);\n}\n\nstruct server_config *\nserver_getlocation(struct client *clt, const char *path)\n{\n\tstruct server\t\t*srv = clt->clt_srv;\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf, *location;\n\tconst char\t\t*errstr = NULL;\n\tint\t\t\t ret;\n\n\t/* Now search for the location */\n\tTAILQ_FOREACH(location, &srv->srv_hosts, entry) {\n#ifdef DEBUG\n\t\tif (location->flags & SRVFLAG_LOCATION) {\n\t\t\tDPRINTF(\"%s: location \\\"%s\\\" path \\\"%s\\\"\",\n\t\t\t    __func__, location->location, path);\n\t\t}\n#endif\n\t\tif ((location->flags & SRVFLAG_LOCATION) &&\n\t\t    location->parent_id == srv_conf->parent_id) {\n\t\t\terrstr = NULL;\n\t\t\tif (location->flags & SRVFLAG_LOCATION_MATCH) {\n\t\t\t\tret = str_match(path, location->location,\n\t\t\t\t    &clt->clt_srv_match, &errstr);\n\t\t\t} else {\n\t\t\t\tret = fnmatch(location->location,\n\t\t\t\t    path, FNM_CASEFOLD);\n\t\t\t}\n\t\t\tif (ret == 0 && errstr == NULL) {\n\t\t\t\t/* Replace host configuration */\n\t\t\t\tclt->clt_srv_conf = srv_conf = location;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (srv_conf);\n}\n\nint\nserver_response_http(struct client *clt, unsigned int code,\n    struct media_type *media, off_t size, time_t mtime)\n{\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tconst char\t\t*error;\n\tstruct kv\t\t*ct, *cl;\n\tchar\t\t\t tmbuf[32];\n\n\tif (desc == NULL || media == NULL ||\n\t    (error = server_httperror_byid(code)) == NULL)\n\t\treturn (-1);\n\n\tif (server_log_http(clt, code, size) == -1)\n\t\treturn (-1);\n\n\t/* Add error codes */\n\tif (kv_setkey(&resp->http_pathquery, \"%u\", code) == -1 ||\n\t    kv_set(&resp->http_pathquery, \"%s\", error) == -1)\n\t\treturn (-1);\n\n\t/* Add headers */\n\tif (kv_add(&resp->http_headers, \"Server\", HTTPD_SERVERNAME) == NULL)\n\t\treturn (-1);\n\n\t/* Is it a persistent connection? */\n\tif (clt->clt_persist) {\n\t\tif (kv_add(&resp->http_headers,\n\t\t    \"Connection\", \"keep-alive\") == NULL)\n\t\t\treturn (-1);\n\t} else if (kv_add(&resp->http_headers, \"Connection\", \"close\") == NULL)\n\t\treturn (-1);\n\n\t/* Set media type */\n\tif ((ct = kv_add(&resp->http_headers, \"Content-Type\", NULL)) == NULL ||\n\t    kv_set(ct, \"%s/%s\", media->media_type, media->media_subtype) == -1)\n\t\treturn (-1);\n\n\t/* Set content length, if specified */\n\tif ((cl =\n\t    kv_add(&resp->http_headers, \"Content-Length\", NULL)) == NULL ||\n\t    kv_set(cl, \"%lld\", (long long)size) == -1)\n\t\treturn (-1);\n\n\t/* Set last modification time */\n\tif (server_http_time(mtime, tmbuf, sizeof(tmbuf)) <= 0 ||\n\t    kv_add(&resp->http_headers, \"Last-Modified\", tmbuf) == NULL)\n\t\treturn (-1);\n\n\t/* HSTS header */\n\tif (srv_conf->flags & SRVFLAG_SERVER_HSTS) {\n\t\tif ((cl =\n\t\t    kv_add(&resp->http_headers, \"Strict-Transport-Security\",\n\t\t    NULL)) == NULL ||\n\t\t    kv_set(cl, \"max-age=%d%s%s\", srv_conf->hsts_max_age,\n\t\t    srv_conf->hsts_flags & HSTSFLAG_SUBDOMAINS ?\n\t\t    \"; includeSubDomains\" : \"\",\n\t\t    srv_conf->hsts_flags & HSTSFLAG_PRELOAD ?\n\t\t    \"; preload\" : \"\") == -1)\n\t\t\treturn (-1);\n\t}\n\n\t/* Date header is mandatory and should be added as late as possible */\n\tif (server_http_time(time(NULL), tmbuf, sizeof(tmbuf)) <= 0 ||\n\t    kv_add(&resp->http_headers, \"Date\", tmbuf) == NULL)\n\t\treturn (-1);\n\n\t/* Write completed header */\n\tif (server_writeresponse_http(clt) == -1 ||\n\t    server_bufferevent_print(clt, \"\\r\\n\") == -1 ||\n\t    server_headers(clt, resp, server_writeheader_http, NULL) == -1 ||\n\t    server_bufferevent_print(clt, \"\\r\\n\") == -1)\n\t\treturn (-1);\n\n\tif (size == 0 || resp->http_method == HTTP_METHOD_HEAD) {\n\t\tbufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);\n\t\tif (clt->clt_persist)\n\t\t\tclt->clt_toread = TOREAD_HTTP_HEADER;\n\t\telse\n\t\t\tclt->clt_toread = TOREAD_HTTP_NONE;\n\t\tclt->clt_done = 0;\n\t\treturn (0);\n\t}\n\n\treturn (1);\n}\n\nint\nserver_writeresponse_http(struct client *clt)\n{\n\tstruct http_descriptor\t*desc = clt->clt_descresp;\n\n\tDPRINTF(\"version: %s rescode: %s resmsg: %s\", desc->http_version,\n\t    desc->http_rescode, desc->http_resmesg);\n\n\tif (server_bufferevent_print(clt, desc->http_version) == -1 ||\n\t    server_bufferevent_print(clt, \" \") == -1 ||\n\t    server_bufferevent_print(clt, desc->http_rescode) == -1 ||\n\t    server_bufferevent_print(clt, \" \") == -1 ||\n\t    server_bufferevent_print(clt, desc->http_resmesg) == -1)\n\t\treturn (-1);\n\n\treturn (0);\n}\n\nint\nserver_writeheader_http(struct client *clt, struct kv *hdr, void *arg)\n{\n\tchar\t\t\t*ptr;\n\tconst char\t\t*key;\n\n\tif (hdr->kv_flags & KV_FLAG_INVALID)\n\t\treturn (0);\n\n\t/* The key might have been updated in the parent */\n\tif (hdr->kv_parent != NULL && hdr->kv_parent->kv_key != NULL)\n\t\tkey = hdr->kv_parent->kv_key;\n\telse\n\t\tkey = hdr->kv_key;\n\n\tptr = hdr->kv_value;\n\tif (server_bufferevent_print(clt, key) == -1 ||\n\t    (ptr != NULL &&\n\t    (server_bufferevent_print(clt, \": \") == -1 ||\n\t    server_bufferevent_print(clt, ptr) == -1 ||\n\t    server_bufferevent_print(clt, \"\\r\\n\") == -1)))\n\t\treturn (-1);\n\tDPRINTF(\"%s: %s: %s\", __func__, key,\n\t    hdr->kv_value == NULL ? \"\" : hdr->kv_value);\n\n\treturn (0);\n}\n\nint\nserver_headers(struct client *clt, void *descp,\n    int (*hdr_cb)(struct client *, struct kv *, void *), void *arg)\n{\n\tstruct kv\t\t*hdr, *kv;\n\tstruct http_descriptor\t*desc = descp;\n\n\tRB_FOREACH(hdr, kvtree, &desc->http_headers) {\n\t\tif ((hdr_cb)(clt, hdr, arg) == -1)\n\t\t\treturn (-1);\n\t\tTAILQ_FOREACH(kv, &hdr->kv_children, kv_entry) {\n\t\t\tif ((hdr_cb)(clt, kv, arg) == -1)\n\t\t\t\treturn (-1);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nenum httpmethod\nserver_httpmethod_byname(const char *name)\n{\n\tenum httpmethod\t\t id = HTTP_METHOD_NONE;\n\tstruct http_method\t method, *res = NULL;\n\n\t/* Set up key */\n\tmethod.method_name = name;\n\n\tif ((res = bsearch(&method, http_methods,\n\t    sizeof(http_methods) / sizeof(http_methods[0]) - 1,\n\t    sizeof(http_methods[0]), server_httpmethod_cmp)) != NULL)\n\t\tid = res->method_id;\n\n\treturn (id);\n}\n\nconst char *\nserver_httpmethod_byid(unsigned int id)\n{\n\tconst char\t*name = \"<UNKNOWN>\";\n\tint\t\t i;\n\n\tfor (i = 0; http_methods[i].method_name != NULL; i++) {\n\t\tif (http_methods[i].method_id == id) {\n\t\t\tname = http_methods[i].method_name;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (name);\n}\n\nstatic int\nserver_httpmethod_cmp(const void *a, const void *b)\n{\n\tconst struct http_method *ma = a;\n\tconst struct http_method *mb = b;\n\n\t/*\n\t * RFC 2616 section 5.1.1 says that the method is case\n\t * sensitive so we don't do a strcasecmp here.\n\t */\n\treturn (strcmp(ma->method_name, mb->method_name));\n}\n\nconst char *\nserver_httperror_byid(unsigned int id)\n{\n\tstruct http_error\t error, *res;\n\n\t/* Set up key */\n\terror.error_code = (int)id;\n\n\tif ((res = bsearch(&error, http_errors,\n\t    sizeof(http_errors) / sizeof(http_errors[0]) - 1,\n\t    sizeof(http_errors[0]), server_httperror_cmp)) != NULL)\n\t\treturn (res->error_name);\n\n\treturn (NULL);\n}\n\nstatic int\nserver_httperror_cmp(const void *a, const void *b)\n{\n\tconst struct http_error *ea = a;\n\tconst struct http_error *eb = b;\n\treturn (ea->error_code - eb->error_code);\n}\n\nint\nserver_log_http(struct client *clt, unsigned int code, size_t len)\n{\n\tstatic char\t\t tstamp[64];\n\tstatic char\t\t ip[INET6_ADDRSTRLEN];\n\ttime_t\t\t\t t;\n\tstruct kv\t\t key, *agent, *referrer;\n\tstruct tm\t\t*tm;\n\tstruct server_config\t*srv_conf;\n\tstruct http_descriptor\t*desc;\n\tint\t\t\t ret = -1;\n\tchar\t\t\t*user = NULL;\n\tchar\t\t\t*path = NULL;\n\tchar\t\t\t*query = NULL;\n\tchar\t\t\t*version = NULL;\n\tchar\t\t\t*referrer_v = NULL;\n\tchar\t\t\t*agent_v = NULL;\n\n\tif ((srv_conf = clt->clt_srv_conf) == NULL)\n\t\treturn (-1);\n\tif ((srv_conf->flags & SRVFLAG_LOG) == 0)\n\t\treturn (0);\n\tif ((desc = clt->clt_descreq) == NULL)\n\t\treturn (-1);\n\n\tif ((t = time(NULL)) == -1)\n\t\treturn (-1);\n\tif ((tm = localtime(&t)) == NULL)\n\t\treturn (-1);\n\tif (strftime(tstamp, sizeof(tstamp), \"%d/%b/%Y:%H:%M:%S %z\", tm) == 0)\n\t\treturn (-1);\n\n\tif (print_host(&clt->clt_ss, ip, sizeof(ip)) == NULL)\n\t\treturn (-1);\n\n\t/*\n\t * For details on common log format, see:\n\t * https://httpd.apache.org/docs/current/mod/mod_log_config.html\n\t *\n\t * httpd's format is similar to these Apache LogFormats:\n\t * \"%v %h %l %u %t \\\"%r\\\" %>s %B\"\n\t * \"%v %h %l %u %t \\\"%r\\\" %>s %B \\\"%{Referer}i\\\" \\\"%{User-agent}i\\\"\"\n\t */\n\tswitch (srv_conf->logformat) {\n\tcase LOG_FORMAT_COMMON:\n\t\t/* Use vis to encode input values from the header */\n\t\tif (clt->clt_remote_user &&\n\t\t    stravis(&user, clt->clt_remote_user, HTTPD_LOGVIS) == -1)\n\t\t\tgoto done;\n\t\tif (desc->http_version &&\n\t\t    stravis(&version, desc->http_version, HTTPD_LOGVIS) == -1)\n\t\t\tgoto done;\n\n\t\t/* The following should be URL-encoded */\n\t\tif (desc->http_path &&\n\t\t    (path = url_encode(desc->http_path)) == NULL)\n\t\t\tgoto done;\n\t\tif (desc->http_query &&\n\t\t    (query = url_encode(desc->http_query)) == NULL)\n\t\t\tgoto done;\n\n\t\tret = evbuffer_add_printf(clt->clt_log,\n\t\t    \"%s %s - %s [%s] \\\"%s %s%s%s%s%s\\\" %03d %zu\\n\",\n\t\t    srv_conf->name, ip, clt->clt_remote_user == NULL ? \"-\" :\n\t\t    user, tstamp,\n\t\t    server_httpmethod_byid(desc->http_method),\n\t\t    desc->http_path == NULL ? \"\" : path,\n\t\t    desc->http_query == NULL ? \"\" : \"?\",\n\t\t    desc->http_query == NULL ? \"\" : query,\n\t\t    desc->http_version == NULL ? \"\" : \" \",\n\t\t    desc->http_version == NULL ? \"\" : version,\n\t\t    code, len);\n\n\t\tbreak;\n\n\tcase LOG_FORMAT_COMBINED:\n\t\tkey.kv_key = \"Referer\"; /* sic */\n\t\tif ((referrer = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    referrer->kv_value == NULL)\n\t\t\treferrer = NULL;\n\n\t\tkey.kv_key = \"User-Agent\";\n\t\tif ((agent = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    agent->kv_value == NULL)\n\t\t\tagent = NULL;\n\n\t\t/* Use vis to encode input values from the header */\n\t\tif (clt->clt_remote_user &&\n\t\t    stravis(&user, clt->clt_remote_user, HTTPD_LOGVIS) == -1)\n\t\t\tgoto done;\n\t\tif (desc->http_version &&\n\t\t    stravis(&version, desc->http_version, HTTPD_LOGVIS) == -1)\n\t\t\tgoto done;\n\t\tif (agent &&\n\t\t    stravis(&agent_v, agent->kv_value, HTTPD_LOGVIS) == -1)\n\t\t\tgoto done;\n\n\t\t/* The following should be URL-encoded */\n\t\tif (desc->http_path &&\n\t\t    (path = url_encode(desc->http_path)) == NULL)\n\t\t\tgoto done;\n\t\tif (desc->http_query &&\n\t\t    (query = url_encode(desc->http_query)) == NULL)\n\t\t\tgoto done;\n\t\tif (referrer &&\n\t\t    (referrer_v = url_encode(referrer->kv_value)) == NULL)\n\t\t\tgoto done;\n\n\t\tret = evbuffer_add_printf(clt->clt_log,\n\t\t    \"%s %s - %s [%s] \\\"%s %s%s%s%s%s\\\"\"\n\t\t    \" %03d %zu \\\"%s\\\" \\\"%s\\\"\\n\",\n\t\t    srv_conf->name, ip, clt->clt_remote_user == NULL ? \"-\" :\n\t\t    user, tstamp,\n\t\t    server_httpmethod_byid(desc->http_method),\n\t\t    desc->http_path == NULL ? \"\" : path,\n\t\t    desc->http_query == NULL ? \"\" : \"?\",\n\t\t    desc->http_query == NULL ? \"\" : query,\n\t\t    desc->http_version == NULL ? \"\" : \" \",\n\t\t    desc->http_version == NULL ? \"\" : version,\n\t\t    code, len,\n\t\t    referrer == NULL ? \"\" : referrer_v,\n\t\t    agent == NULL ? \"\" : agent_v);\n\n\t\tbreak;\n\n\tcase LOG_FORMAT_CONNECTION:\n\t\t/* URL-encode the path */\n\t\tif (desc->http_path &&\n\t\t    (path = url_encode(desc->http_path)) == NULL)\n\t\t\tgoto done;\n\n\t\tret = evbuffer_add_printf(clt->clt_log, \" [%s]\",\n\t\t    desc->http_path == NULL ? \"\" : path);\n\n\t\tbreak;\n\t}\n\ndone:\n\tfree(user);\n\tfree(path);\n\tfree(query);\n\tfree(version);\n\tfree(referrer_v);\n\tfree(agent_v);\n\n\treturn (ret);\n}\n"], "filenames": ["usr.sbin/httpd/httpd.h", "usr.sbin/httpd/server_file.c", "usr.sbin/httpd/server_http.c"], "buggy_code_start_loc": [1, 1, 1], "buggy_code_end_loc": [603, 778, 612], "fixing_code_start_loc": [1, 1, 1], "fixing_code_end_loc": [625, 746, 708], "type": "CWE-770", "message": "httpd in OpenBSD allows remote attackers to cause a denial of service (memory consumption) via a series of requests for a large file using an HTTP Range header.", "other": {"cve": {"id": "CVE-2017-5850", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-27T15:59:00.437", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "httpd in OpenBSD allows remote attackers to cause a denial of service (memory consumption) via a series of requests for a large file using an HTTP Range header."}, {"lang": "es", "value": "httpd en OpenBSD permite a atacantes remotos provocar una denegaci\u00f3n de servicio (consumo de memoria) a trav\u00e9s de una serie de peticiones para un archivo grande utilizando un encabezado HTTP Range."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:openbsd:openbsd:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "4A300948-662F-4728-B6C1-69A6A4CF61BE"}]}]}], "references": [{"url": "http://marc.info/?l=openbsd-cvs&m=148587359420912&w=2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://packetstormsecurity.com/files/140944/OpenBSD-HTTP-Server-6.0-Denial-Of-Service.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "http://seclists.org/fulldisclosure/2017/Feb/15", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/02/02/6", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95997", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1037758", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://ftp.openbsd.org/pub/OpenBSD/patches/5.9/common/034_httpd.patch.sig", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://ftp.openbsd.org/pub/OpenBSD/patches/6.0/common/017_httpd.patch.sig", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/openbsd/src/commit/142cfc82b932bc211218fbd7bdda8c7ce83f19df", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://pierrekim.github.io/blog/2017-02-07-openbsd-httpd-CVE-2017-5850.html", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/41278/", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/openbsd/src/commit/142cfc82b932bc211218fbd7bdda8c7ce83f19df"}}