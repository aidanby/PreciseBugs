{"buggy_code": ["\"\"\"Generic utility methods not part of main API.\"\"\"\n\nimport builtins\nfrom collections.abc import Hashable, Iterable, Mapping, Sequence\nfrom decimal import Decimal\nfrom functools import wraps\nimport inspect\nfrom inspect import getfullargspec\nimport warnings\n\nimport pydash as pyd\n\n\n#: Singleton object that differentiates between an explicit ``None`` value and an unset value.\nUNSET = object()\n\n#: Tuple of number types.\nNUMBER_TYPES = (int, float, Decimal)\n\n#: Dictionary of builtins with keys as the builtin function and values as the string name.\nBUILTINS = {value: key for key, value in builtins.__dict__.items() if isinstance(value, Hashable)}\n\n\ndef callit(iteratee, *args, **kwargs):\n    \"\"\"Inspect argspec of `iteratee` function and only pass the supported arguments when calling\n    it.\"\"\"\n    maxargs = len(args)\n    argcount = kwargs[\"argcount\"] if \"argcount\" in kwargs else getargcount(iteratee, maxargs)\n    argstop = min([maxargs, argcount])\n\n    return iteratee(*args[:argstop])\n\n\ndef getargcount(iteratee, maxargs):\n    \"\"\"Return argument count of iteratee function.\"\"\"\n    if hasattr(iteratee, \"_argcount\"):\n        # Optimization feature where argcount of iteratee is known and properly\n        # set by initiator.\n        return iteratee._argcount\n\n    if isinstance(iteratee, type) or pyd.is_builtin(iteratee):\n        # Only pass single argument to type iteratees or builtins.\n        argcount = 1\n    else:\n        argcount = 1\n\n        try:\n            argcount = _getargcount(iteratee, maxargs)\n        except TypeError:  # pragma: no cover\n            pass\n\n    return argcount\n\n\ndef _getargcount(iteratee, maxargs):\n    argcount = None\n\n    try:\n        # PY2: inspect.signature was added in Python 3.\n        # Try to use inspect.signature when possible since it works better for our purpose of\n        # getting the iteratee argcount since it takes into account the \"self\" argument in callable\n        # classes.\n        sig = inspect.signature(iteratee)\n    except (TypeError, ValueError, AttributeError):\n        pass\n    else:  # pragma: no cover\n        if not any(\n            param.kind == inspect.Parameter.VAR_POSITIONAL for param in sig.parameters.values()\n        ):\n            argcount = len(sig.parameters)\n\n    if argcount is None:\n        argspec = getfullargspec(iteratee)\n        if argspec and not argspec.varargs:  # pragma: no cover\n            # Use inspected arg count.\n            argcount = len(argspec.args)\n\n    if argcount is None:\n        # Assume all args are handleable.\n        argcount = maxargs\n\n    return argcount\n\n\ndef iteriteratee(obj, iteratee=None, reverse=False):\n    \"\"\"Return iterative iteratee based on collection type.\"\"\"\n    if iteratee is None:\n        cbk = pyd.identity\n        argcount = 1\n    else:\n        cbk = pyd.iteratee(iteratee)\n        argcount = getargcount(cbk, maxargs=3)\n\n    items = iterator(obj)\n\n    if reverse:\n        items = reversed(tuple(items))\n\n    for key, item in items:\n        yield callit(cbk, item, key, obj, argcount=argcount), item, key, obj\n\n\ndef iterator(obj):\n    \"\"\"Return iterative based on object type.\"\"\"\n    if isinstance(obj, Mapping):\n        return obj.items()\n    elif hasattr(obj, \"iteritems\"):\n        return obj.iteritems()  # noqa: B301\n    elif hasattr(obj, \"items\"):\n        return iter(obj.items())\n    elif isinstance(obj, Iterable):\n        return enumerate(obj)\n    else:\n        return getattr(obj, \"__dict__\", {}).items()\n\n\ndef base_get(obj, key, default=UNSET):\n    \"\"\"\n    Safely get an item by `key` from a sequence or mapping object when `default` provided.\n\n    Args:\n        obj (list|dict): Sequence or mapping to retrieve item from.\n        key (mixed): Key or index identifying which item to retrieve.\n        default (mixed, optional): Default value to return if `key` not found in `obj`.\n\n    Returns:\n        mixed: `obj[key]`, `obj.key`, or `default`.\n\n    Raises:\n        KeyError: If `obj` is missing key, index, or attribute and no default value provided.\n    \"\"\"\n    if isinstance(obj, dict):\n        value = _base_get_dict(obj, key, default=default)\n    elif not isinstance(obj, (Mapping, Sequence)) or (\n        isinstance(obj, tuple) and hasattr(obj, \"_fields\")\n    ):\n        # Don't use getattr for dict/list objects since we don't want class methods/attributes\n        # returned for them but do allow getattr for namedtuple.\n        value = _base_get_object(obj, key, default=default)\n    else:\n        value = _base_get_item(obj, key, default=default)\n\n    if value is UNSET:\n        # Raise if there's no default provided.\n        raise KeyError(f'Object \"{repr(obj)}\" does not have key \"{key}\"')\n\n    return value\n\n\ndef _base_get_dict(obj, key, default=UNSET):\n    value = obj.get(key, UNSET)\n    if value is UNSET:\n        value = default\n        if not isinstance(key, int):\n            # Try integer key fallback.\n            try:\n                value = obj.get(int(key), default)\n            except Exception:\n                pass\n    return value\n\n\ndef _base_get_item(obj, key, default=UNSET):\n    try:\n        return obj[key]\n    except Exception:\n        pass\n\n    if not isinstance(key, int):\n        try:\n            return obj[int(key)]\n        except Exception:\n            pass\n\n    return default\n\n\ndef _base_get_object(obj, key, default=UNSET):\n    value = _base_get_item(obj, key, default=UNSET)\n    if value is UNSET:\n        value = default\n        try:\n            value = getattr(obj, key)\n        except Exception:\n            pass\n    return value\n\n\ndef base_set(obj, key, value, allow_override=True):\n    \"\"\"\n    Set an object's `key` to `value`. If `obj` is a ``list`` and the `key` is the next available\n    index position, append to list; otherwise, pad the list of ``None`` and then append to the list.\n\n    Args:\n        obj (list|dict): Object to assign value to.\n        key (mixed): Key or index to assign to.\n        value (mixed): Value to assign.\n        allow_override (bool): Whether to allow overriding a previously set key.\n    \"\"\"\n    if isinstance(obj, dict):\n        if allow_override or key not in obj:\n            obj[key] = value\n    elif isinstance(obj, list):\n        key = int(key)\n\n        if key < len(obj):\n            if allow_override:\n                obj[key] = value\n        else:\n            if key > len(obj):\n                # Pad list object with None values up to the index key so we can append the value\n                # into the key index.\n                obj[:] = (obj + [None] * key)[:key]\n            obj.append(value)\n    elif (allow_override or not hasattr(obj, key)) and obj is not None:\n        setattr(obj, key, value)\n\n    return obj\n\n\ndef cmp(a, b):  # pragma: no cover\n    \"\"\"\n    Replacement for built-in function ``cmp`` that was removed in Python 3.\n\n    Note: Mainly used for comparison during sorting.\n    \"\"\"\n    if a is None and b is None:\n        return 0\n    elif a is None:\n        return -1\n    elif b is None:\n        return 1\n    return (a > b) - (a < b)\n\n\ndef parse_iteratee(iteratee_keyword, *args, **kwargs):\n    \"\"\"Try to find iteratee function passed in either as a keyword argument or as the last\n    positional argument in `args`.\"\"\"\n    iteratee = kwargs.get(iteratee_keyword)\n    last_arg = args[-1]\n\n    if iteratee is None and (\n        callable(last_arg)\n        or isinstance(last_arg, str)\n        or isinstance(last_arg, dict)\n        or last_arg is None\n    ):\n        iteratee = last_arg\n        args = args[:-1]\n\n    return iteratee, args\n\n\nclass iterator_with_default(object):\n    \"\"\"A wrapper around an iterator object that provides a default.\"\"\"\n\n    def __init__(self, collection, default):\n        self.iter = iter(collection)\n        self.default = default\n\n    def __iter__(self):\n        return self\n\n    def next_default(self):\n        ret = self.default\n        self.default = UNSET\n        return ret\n\n    def __next__(self):\n        ret = next(self.iter, self.next_default())\n        if ret is UNSET:\n            raise StopIteration\n        return ret\n\n    next = __next__\n\n\ndef deprecated(func):  # pragma: no cover\n    \"\"\"\n    This is a decorator which can be used to mark functions as deprecated.\n\n    It will result in a warning being emitted when the function is used.\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        warnings.warn(\n            f\"Call to deprecated function {func.__name__}.\",\n            category=DeprecationWarning,\n            stacklevel=3,\n        )\n        return func(*args, **kwargs)\n\n    return wrapper\n", "from argparse import Namespace\nfrom collections import defaultdict, namedtuple\nimport datetime as dt\n\nimport pytest\n\nimport pydash as _\n\nfrom . import helpers\n\n\nparametrize = pytest.mark.parametrize\n\ntoday = dt.date.today()\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"name\": \"fred\"}, {\"employer\": \"slate\"}), {\"name\": \"fred\", \"employer\": \"slate\"}),\n        (\n            ({\"name\": \"fred\"}, {\"employer\": \"slate\"}, {\"employer\": \"medium\"}),\n            {\"name\": \"fred\", \"employer\": \"medium\"},\n        ),\n    ],\n)\ndef test_assign(case, expected):\n    assert _.assign(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"name\": \"fred\"}, {\"age\": 26}, lambda obj, src: src + 1), {\"name\": \"fred\", \"age\": 27}),\n    ],\n)\ndef test_assign_with(case, expected):\n    assert _.assign_with(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"name\": \"fred\", \"greet\": lambda: \"Hello, world!\"},), [\"greet\"]),\n        (([\"fred\", lambda: \"Hello, world!\"],), [1]),\n    ],\n)\ndef test_callables(case, expected):\n    assert _.callables(*case) == expected\n\n\n@parametrize(\n    \"case\",\n    [\n        {\"a\": {\"d\": 1}, \"b\": {\"c\": 2}},\n        [{\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}],\n    ],\n)\ndef test_clone(case):\n    result = _.clone(case)\n\n    assert result is not case\n\n    for key, value in _.helpers.iterator(result):\n        assert value is case[key]\n\n\n@parametrize(\n    \"case,iteratee,expected\",\n    [\n        ({\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}, lambda v: v, {\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}),\n        (\n            {\"a\": 1, \"b\": 2, \"c\": {\"d\": 3}},\n            lambda v, k: v + 2 if isinstance(v, int) and k else None,\n            {\"a\": 3, \"b\": 4, \"c\": {\"d\": 3}},\n        ),\n    ],\n)\ndef test_clone_with(case, iteratee, expected):\n    result = _.clone_with(case, iteratee)\n\n    assert result == expected\n\n\n@parametrize(\n    \"case\",\n    [\n        {\"a\": {\"d\": 1}, \"b\": {\"c\": 2}},\n        {\"a\": {\"d\": 1}, \"b\": {\"c\": 2}},\n        [{\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}],\n    ],\n)\ndef test_clone_deep(case):\n    result = _.clone_deep(case)\n\n    assert result is not case\n\n    for key, value in _.helpers.iterator(result):\n        assert value is not case[key]\n\n\n@parametrize(\n    \"case,iteratee,expected\",\n    [\n        ({\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}, lambda v: v, {\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}),\n        (\n            {\"a\": 1, \"b\": 2, \"c\": {\"d\": 3}},\n            lambda v, k: v + 2 if isinstance(v, int) and k else None,\n            {\"a\": 3, \"b\": 4, \"c\": {\"d\": 5}},\n        ),\n        ([\"a\"], lambda a: None, [\"a\"]),\n        (\"a\", lambda a: None, \"a\"),\n    ],\n)\ndef test_clone_deep_with(case, iteratee, expected):\n    result = _.clone_deep_with(case, iteratee)\n\n    assert result == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            ({\"name\": \"barney\"}, {\"name\": \"fred\", \"employer\": \"slate\"}),\n            {\"name\": \"barney\", \"employer\": \"slate\"},\n        ),\n    ],\n)\ndef test_defaults(case, expected):\n    assert _.defaults(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            ({\"user\": {\"name\": \"barney\"}}, {\"user\": {\"name\": \"fred\", \"age\": 36}}),\n            {\"user\": {\"name\": \"barney\", \"age\": 36}},\n        ),\n        (({}, {\"a\": {\"b\": [\"c\"]}}, {\"a\": {\"b\": [\"d\"]}}), {\"a\": {\"b\": [\"c\"]}}),\n        (\n            ({\"a\": {\"b\": [{\"d\": \"e\"}]}}, {\"a\": {\"b\": [{\"d\": \"f\"}]}}, {\"a\": {\"b\": [{\"g\": \"h\"}]}}),\n            {\"a\": {\"b\": [{\"d\": \"e\", \"g\": \"h\"}]}},\n        ),\n        (\n            (\n                {\"a\": {\"b\": [{\"d\": \"e\"}]}},\n                {\"a\": {\"b\": [{\"d\": \"f\"}, {\"g\": \"h\"}]}},\n                {\"a\": {\"b\": [{\"i\": \"j\"}]}},\n            ),\n            {\"a\": {\"b\": [{\"d\": \"e\", \"i\": \"j\"}]}},\n        ),\n        (\n            (\n                {\"a\": {\"b\": [{\"d\": \"e\"}, {\"x\": \"y\"}]}},\n                {\"a\": {\"b\": [{\"d\": \"f\"}, {\"g\": \"h\"}]}},\n                {\"a\": {\"b\": [{\"i\": \"j\"}]}},\n            ),\n            {\"a\": {\"b\": [{\"d\": \"e\", \"i\": \"j\"}, {\"x\": \"y\", \"g\": \"h\"}]}},\n        ),\n    ],\n)\ndef test_defaults_deep(case, expected):\n    assert _.defaults_deep(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        ([1, 2, 3], {0: 1, 1: 2, 2: 3}),\n        ({0: 1, 1: 2, 2: 3}, {0: 1, 1: 2, 2: 3}),\n    ],\n)\ndef test_to_dict(case, expected):\n    assert _.to_dict(case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        ({\"a\": 1, \"b\": 2, \"c\": 3}, {1: \"a\", 2: \"b\", 3: \"c\"}),\n        ([1, 2, 3], {1: 0, 2: 1, 3: 2}),\n    ],\n)\ndef test_invert(case, expected):\n    assert _.invert(case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (([1, 2, 3],), {1: [0], 2: [1], 3: [2]}),\n        (\n            ({\"first\": \"fred\", \"second\": \"barney\", \"third\": \"fred\"},),\n            {\"fred\": [\"first\", \"third\"], \"barney\": [\"second\"]},\n        ),\n        (({\"a\": 1, \"b\": 2}, lambda val: val * 2), {2: [\"a\"], 4: [\"b\"]}),\n    ],\n)\ndef test_invert_by(case, expected):\n    result = _.invert_by(*case)\n    for key in result:\n        assert set(result[key]) == set(expected[key])\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2}, \"get\", \"a\"), 1),\n        (({\"a\": {\"b\": {\"c\": [1, 2, 3, 3]}}}, \"a.b.c.count\", 3), 2),\n        (({}, \"count\"), None),\n    ],\n)\ndef test_invoke(case, expected):\n    assert _.invoke(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        # NOTE: The expected is a list of values but find_key returns only a single\n        # value. However, since dicts do not have an order, it's unknown what the\n        # \"first\" returned value will be.\n        (\n            (\n                {\n                    \"barney\": {\"age\": 36, \"blocked\": False},\n                    \"fred\": {\"age\": 40, \"blocked\": True},\n                    \"pebbles\": {\"age\": 1, \"blocked\": False},\n                },\n                lambda obj: obj[\"age\"] < 40,\n            ),\n            [\"pebbles\", \"barney\"],\n        ),\n        (\n            (\n                {\n                    \"barney\": {\"age\": 36, \"blocked\": False},\n                    \"fred\": {\"age\": 40, \"blocked\": True},\n                    \"pebbles\": {\"age\": 1, \"blocked\": False},\n                },\n            ),\n            [\"barney\", \"fred\", \"pebbles\"],\n        ),\n        (([1, 2, 3],), [0]),\n    ],\n)\ndef test_find_key(case, expected):\n    assert _.find_key(*case) in expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        # NOTE: The expected is a list of values but find_last_key returns only a\n        # single value. However, since dicts do not have an order, it's unknown\n        # what the \"first\" returned value will be.\n        (\n            (\n                {\n                    \"barney\": {\"age\": 36, \"blocked\": False},\n                    \"fred\": {\"age\": 40, \"blocked\": True},\n                    \"pebbles\": {\"age\": 1, \"blocked\": False},\n                },\n                lambda obj: obj[\"age\"] < 40,\n            ),\n            [\"pebbles\", \"barney\"],\n        ),\n        (\n            (\n                {\n                    \"barney\": {\"age\": 36, \"blocked\": False},\n                    \"fred\": {\"age\": 40, \"blocked\": True},\n                    \"pebbles\": {\"age\": 1, \"blocked\": False},\n                },\n            ),\n            [\"barney\", \"fred\", \"pebbles\"],\n        ),\n        (([1, 2, 3],), [2]),\n    ],\n)\ndef test_find_last_key(case, expected):\n    assert _.find_last_key(*case) in expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            ({\"name\": \"fred\", \"employer\": \"slate\"}, helpers.for_in_iteratee0),\n            ({\"name\": \"fredfred\", \"employer\": \"slateslate\"},),\n        ),\n        (\n            ({\"name\": \"fred\", \"employer\": \"slate\"}, helpers.for_in_iteratee1),\n            ({\"name\": \"fredfred\", \"employer\": \"slate\"}, {\"name\": \"fred\", \"employer\": \"slateslate\"}),\n        ),\n        (([1, 2, 3], helpers.for_in_iteratee2), ([False, True, 3],)),\n    ],\n)\ndef test_for_in(case, expected):\n    assert _.for_in(*case) in expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            ({\"name\": \"fred\", \"employer\": \"slate\"}, helpers.for_in_iteratee0),\n            ({\"name\": \"fredfred\", \"employer\": \"slateslate\"},),\n        ),\n        (\n            ({\"name\": \"fred\", \"employer\": \"slate\"}, helpers.for_in_iteratee1),\n            ({\"name\": \"fredfred\", \"employer\": \"slate\"}, {\"name\": \"fred\", \"employer\": \"slateslate\"}),\n        ),\n        (([1, 2, 3], helpers.for_in_iteratee2), ([1, True, \"index:2\"],)),\n    ],\n)\ndef test_for_in_right(case, expected):\n    assert _.for_in_right(*case) in expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.two\"), {\"three\": 4}),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.two.three\"), 4),\n        (({\"one\": {\"two\": {\"three\": 4}}}, [\"one\", \"two\"]), {\"three\": 4}),\n        (({\"one\": {\"two\": {\"three\": 4}}}, [\"one\", \"two\", \"three\"]), 4),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four\"), None),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\", []), []),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.0.a\", [{\"a\": 1}]), [{\"a\": 1}]),\n        (({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\", []), []),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\"), None),\n        (({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\"), None),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\", 2), 2),\n        (({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\", 2), 2),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\", {\"test\": \"value\"}), {\"test\": \"value\"}),\n        (\n            ({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\", {\"test\": \"value\"}),\n            {\"test\": \"value\"},\n        ),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\", \"haha\"), \"haha\"),\n        (({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\", \"haha\"), \"haha\"),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"five\"), None),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, [\"one\", 1, \"three\", 1]), 5),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, \"one.[1].three.[1]\"), 5),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, \"one.1.three.1\"), 5),\n        (([\"one\", {\"two\": {\"three\": [4, 5]}}], \"[1].two.three.[0]\"), 4),\n        (([\"one\", {\"two\": {\"three\": [4, [{\"four\": [5]}]]}}], \"[1].two.three[1][0].four[0]\"), 5),\n        ((range(50), \"[42]\"), 42),\n        (([[[[[[[[[[42]]]]]]]]]], \"[0][0][0][0][0][0][0][0][0][0]\"), 42),\n        (([range(50)], \"[0][42]\"), 42),\n        (({\"a\": [{\"b\": range(50)}]}, \"a[0].b[42]\"), 42),\n        (\n            ({\"lev.el1\": {\"lev\\\\el2\": {\"level3\": [\"value\"]}}}, \"lev\\\\.el1.lev\\\\\\\\el2.level3.[0]\"),\n            \"value\",\n        ),\n        (({\"one\": [\"hello\", \"there\"]}, \"one.bad.hello\", []), []),\n        (({\"one\": [\"hello\", None]}, \"one.1.hello\"), None),\n        ((namedtuple(\"a\", [\"a\", \"b\"])(1, 2), \"a\"), 1),\n        ((namedtuple(\"a\", [\"a\", \"b\"])(1, 2), 0), 1),\n        ((namedtuple(\"a\", [\"a\", \"b\"])({\"c\": {\"d\": 1}}, 2), \"a.c.d\"), 1),\n        (({}, \"update\"), None),\n        (([], \"extend\"), None),\n        (({(1,): {(2,): 3}}, (1,)), {(2,): 3}),\n        (({(1,): {(2,): 3}}, [(1,), (2,)]), 3),\n        (({object: 1}, object), 1),\n        (({object: {object: 1}}, [object, object]), 1),\n        (({1: {\"name\": \"John Doe\"}}, \"1.name\"), \"John Doe\"),\n    ],\n)\ndef test_get(case, expected):\n    assert _.get(*case) == expected\n\n\ndef test_get__should_not_populate_defaultdict():\n    data = defaultdict(list)\n    _.get(data, \"a\")\n    assert data == {}\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"b\"), True),\n        (([1, 2, 3], 0), True),\n        (([1, 2, 3], 1), True),\n        (([1, 2, 3], 3), False),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"b\"), True),\n        (([1, 2, 3], 0), True),\n        (([1, 2, 3], 1), True),\n        (([1, 2, 3], 3), False),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.two\"), True),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.two.three\"), True),\n        (({\"one\": {\"two\": {\"three\": 4}}}, [\"one\", \"two\"]), True),\n        (({\"one\": {\"two\": {\"three\": 4}}}, [\"one\", \"two\", \"three\"]), True),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four\"), False),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"five\"), False),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\"), False),\n        (({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\"), False),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, [\"one\", 1, \"three\", 1]), True),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, \"one.[1].three.[1]\"), True),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, \"one.1.three.1\"), True),\n        (([\"one\", {\"two\": {\"three\": [4, 5]}}], \"[1].two.three.[0]\"), True),\n        (({\"lev.el1\": {r\"lev\\el2\": {\"level3\": [\"value\"]}}}, r\"lev\\.el1.lev\\\\el2.level3.[0]\"), True),\n    ],\n)\ndef test_has(case, expected):\n    assert _.has(*case) == expected\n\n\ndef test_has__should_not_populate_defaultdict():\n    data = defaultdict(list)\n    _.has(data, \"a\")\n    assert data == {}\n\n\n@parametrize(\"case,expected\", [({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\", \"b\", \"c\"]), ([1, 2, 3], [0, 1, 2])])\ndef test_keys(case, expected):\n    assert set(_.keys(case)) == set(expected)\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, lambda num: num * 3), {\"a\": 3, \"b\": 6, \"c\": 9}),\n        (\n            (\n                {\"fred\": {\"name\": \"fred\", \"age\": 40}, \"pebbles\": {\"name\": \"pebbles\", \"age\": 1}},\n                \"age\",\n            ),\n            {\"fred\": 40, \"pebbles\": 1},\n        ),\n    ],\n)\ndef test_map_values(case, expected):\n    assert _.map_values(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            (\n                {\n                    \"level1\": {\n                        \"value\": \"value 1\",\n                        \"level2\": {\"value\": \"value 2\", \"level3\": {\"value\": \"value 3\"}},\n                    }\n                },\n                lambda value, property_path: \".\".join(property_path) + \"==\" + value,\n            ),\n            {\n                \"level1\": {\n                    \"value\": \"level1.value==value 1\",\n                    \"level2\": {\n                        \"value\": \"level1.level2.value==value 2\",\n                        \"level3\": {\"value\": \"level1.level2.level3.value==value 3\"},\n                    },\n                }\n            },\n        ),\n        (\n            (\n                [[\"value 1\", [[\"value 2\", [\"value 3\"]]]]],\n                lambda value, property_path: (_.join(property_path, \".\") + \"==\" + value),\n            ),\n            [[\"0.0==value 1\", [[\"0.1.0.0==value 2\", [\"0.1.0.1.0==value 3\"]]]]],\n        ),\n    ],\n)\ndef test_map_values_deep(case, expected):\n    assert _.map_values_deep(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            (\n                {\"characters\": [{\"name\": \"barney\"}, {\"name\": \"fred\"}]},\n                {\"characters\": [{\"age\": 36}, {\"age\": 40}]},\n            ),\n            {\"characters\": [{\"name\": \"barney\", \"age\": 36}, {\"name\": \"fred\", \"age\": 40}]},\n        ),\n        (\n            (\n                {\"characters\": [{\"name\": \"barney\"}, {\"name\": \"fred\"}, {}]},\n                {\"characters\": [{\"age\": 36}, {\"age\": 40}]},\n            ),\n            {\"characters\": [{\"name\": \"barney\", \"age\": 36}, {\"name\": \"fred\", \"age\": 40}, {}]},\n        ),\n        (\n            (\n                {\"characters\": [{\"name\": \"barney\"}, {\"name\": \"fred\"}]},\n                {\"characters\": [{\"age\": 36}, {\"age\": 40}, {}]},\n            ),\n            {\"characters\": [{\"name\": \"barney\", \"age\": 36}, {\"name\": \"fred\", \"age\": 40}, {}]},\n        ),\n        (\n            (\n                {\"characters\": [{\"name\": \"barney\"}, {\"name\": \"fred\"}]},\n                {\"characters\": [{\"age\": 36}, {\"age\": 40}]},\n                {\"characters\": [{\"score\": 5}, {\"score\": 7}]},\n            ),\n            {\n                \"characters\": [\n                    {\"name\": \"barney\", \"age\": 36, \"score\": 5},\n                    {\"name\": \"fred\", \"age\": 40, \"score\": 7},\n                ]\n            },\n        ),\n        (\n            (\n                {\"characters\": {\"barney\": {\"age\": 36}, \"fred\": {\"score\": 7}}},\n                {\"characters\": {\"barney\": {\"score\": 5}, \"fred\": {\"age\": 40}}},\n            ),\n            {\"characters\": {\"barney\": {\"age\": 36, \"score\": 5}, \"fred\": {\"age\": 40, \"score\": 7}}},\n        ),\n        (\n            (\n                {\"characters\": {\"barney\": {\"age\": 36}, \"fred\": {\"score\": 7}}},\n                {\"characters\": {\"barney\": [5], \"fred\": 7}},\n            ),\n            {\"characters\": {\"barney\": [5], \"fred\": 7}},\n        ),\n        (\n            (\n                {\"characters\": {\"barney\": {\"age\": 36}, \"fred\": {\"score\": 7}}},\n                {\"foo\": {\"barney\": [5], \"fred\": 7}},\n            ),\n            {\n                \"characters\": {\"barney\": {\"age\": 36}, \"fred\": {\"score\": 7}},\n                \"foo\": {\"barney\": [5], \"fred\": 7},\n            },\n        ),\n        (({\"foo\": {\"bar\": 1}}, {\"foo\": {}}), {\"foo\": {\"bar\": 1}}),\n        (({},), {}),\n        (([],), []),\n        ((None,), None),\n        ((None, {\"a\": 1}), None),\n        ((None, None, None, {\"a\": 1}), None),\n        (({\"a\": 1}, None), {\"a\": 1}),\n        (({\"a\": 1}, None, None, None, {\"b\": 2}), {\"a\": 1, \"b\": 2}),\n        (({\"a\": None}, None, None, None, {\"b\": None}), {\"a\": None, \"b\": None}),\n    ],\n)\ndef test_merge(case, expected):\n    assert _.merge(*case) == expected\n\n\ndef test_merge_no_link_dict():\n    case1 = {\"foo\": {\"bar\": None}}\n    case2 = {\"foo\": {\"bar\": False}}\n    result = _.merge({}, case1, case2)\n    result[\"foo\"][\"bar\"] = True\n\n    assert case1 == {\"foo\": {\"bar\": None}}\n    assert case2 == {\"foo\": {\"bar\": False}}\n\n\ndef test_merge_no_link_list():\n    case = {\"foo\": [{}]}\n    result = _.merge({}, case)\n    result[\"foo\"][0][\"bar\"] = True\n\n    assert case == {\"foo\": [{}]}\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            (\n                {\"fruits\": [\"apple\"], \"others\": {\"vegetables\": [\"beet\"]}},\n                {\"fruits\": [\"banana\"], \"others\": {\"vegetables\": [\"carrot\"]}},\n                lambda a, b: a + b if isinstance(a, list) else None,\n            ),\n            {\"fruits\": [\"apple\", \"banana\"], \"others\": {\"vegetables\": [\"beet\", \"carrot\"]}},\n        ),\n    ],\n)\ndef test_merge_with(case, expected):\n    assert _.merge_with(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"a\"), {\"b\": 2, \"c\": 3}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"a\", \"b\"), {\"c\": 3}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\", \"b\"]), {\"c\": 3}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\"], [\"b\"]), {\"c\": 3}),\n        (([1, 2, 3],), {0: 1, 1: 2, 2: 3}),\n        (([1, 2, 3], 0), {1: 2, 2: 3}),\n        (([1, 2, 3], 0, 1), {2: 3}),\n        (({\"a\": {\"b\": {\"c\": \"d\"}}, \"e\": \"f\"}, \"a.b.c\", \"e\"), {\"a\": {\"b\": {}}}),\n        (({\"a\": [{\"b\": 1, \"c\": 2}, {\"d\": 3}]}, \"a[0].c\", \"a[1].d\"), {\"a\": [{\"b\": 1}, {}]}),\n    ],\n)\ndef test_omit(case, expected):\n    assert _.omit(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\", \"b\"]), {\"c\": 3}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, lambda value, key: key == \"a\"), {\"b\": 2, \"c\": 3}),\n        (([1, 2, 3],), {0: 1, 1: 2, 2: 3}),\n        (([1, 2, 3], [0]), {1: 2, 2: 3}),\n    ],\n)\ndef test_omit_by(case, expected):\n    assert _.omit_by(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        ((1,), 1),\n        ((1.0,), 1),\n        ((\"1\",), 1),\n        ((\"00001\",), 1),\n        ((13, 8), 11),\n        ((\"0A\",), 10),\n        ((\"08\",), 8),\n        ((\"10\",), 16),\n        ((\"10\", 10), 10),\n        ((\"xyz\",), None),\n    ],\n)\ndef test_parse_int(case, expected):\n    assert _.parse_int(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"a\"), {\"a\": 1}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"a\", \"b\"), {\"a\": 1, \"b\": 2}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\", \"b\"]), {\"a\": 1, \"b\": 2}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\"], [\"b\"]), {\"a\": 1, \"b\": 2}),\n        (([1, 2, 3],), {}),\n        (([1, 2, 3], 0), {0: 1}),\n        ((helpers.Object(a=1, b=2, c=3), \"a\"), {\"a\": 1}),\n        ((helpers.ItemsObject({\"a\": 1, \"b\": 2, \"c\": 3}), \"a\"), {\"a\": 1}),\n        ((helpers.IteritemsObject({\"a\": 1, \"b\": 2, \"c\": 3}), \"a\"), {\"a\": 1}),\n        (({\"a\": {\"b\": 1, \"c\": 2, \"d\": 3}}, \"a.b\", \"a.d\"), {\"a\": {\"b\": 1, \"d\": 3}}),\n        (\n            ({\"a\": [{\"b\": 1}, {\"c\": 2}, {\"d\": 3}]}, \"a[0]\", \"a[2]\"),\n            {\"a\": [{\"b\": 1}, None, {\"d\": 3}]},\n        ),\n    ],\n)\ndef test_pick(case, expected):\n    assert _.pick(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\", \"b\"]), {\"a\": 1, \"b\": 2}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, lambda value, key: key in [\"a\"]), {\"a\": 1}),\n        (([1, 2, 3],), {0: 1, 1: 2, 2: 3}),\n        (([1, 2, 3], [0]), {0: 1}),\n        ((helpers.Object(a=1, b=2, c=3), \"a\"), {\"a\": 1}),\n        ((helpers.ItemsObject({\"a\": 1, \"b\": 2, \"c\": 3}), \"a\"), {\"a\": 1}),\n        ((helpers.IteritemsObject({\"a\": 1, \"b\": 2, \"c\": 3}), \"a\"), {\"a\": 1}),\n    ],\n)\ndef test_pick_by(case, expected):\n    assert _.pick_by(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2}, {\"a\": \"A\", \"b\": \"B\"}), {\"A\": 1, \"B\": 2}),\n        (({\"a\": 1, \"b\": 2}, {\"a\": \"A\"}), {\"A\": 1, \"b\": 2}),\n        (({\"a\": 1, \"b\": 2}, {\"c\": \"C\", \"b\": \"B\"}), {\"a\": 1, \"B\": 2}),\n    ],\n)\ndef test_rename_keys(case, expected):\n    assert _.rename_keys(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({}, [\"one\", \"two\", \"three\", \"four\"], 1), {\"one\": {\"two\": {\"three\": {\"four\": 1}}}}),\n        (({}, \"one.two.three.four\", 1), {\"one\": {\"two\": {\"three\": {\"four\": 1}}}}),\n        (\n            ({\"one\": {\"two\": {}, \"three\": {}}}, [\"one\", \"two\", \"three\", \"four\"], 1),\n            {\"one\": {\"two\": {\"three\": {\"four\": 1}}, \"three\": {}}},\n        ),\n        (\n            ({\"one\": {\"two\": {}, \"three\": {}}}, \"one.two.three.four\", 1),\n            {\"one\": {\"two\": {\"three\": {\"four\": 1}}, \"three\": {}}},\n        ),\n        (({}, \"one\", 1), {\"one\": 1}),\n        (([], [0, 0, 0], 1), [[[1]]]),\n        (([], \"[0].[0].[0]\", 1), [[[1]]]),\n        (([1, 2, [3, 4, [5, 6]]], [2, 2, 1], 7), [1, 2, [3, 4, [5, 7]]]),\n        (([1, 2, [3, 4, [5, 6]]], \"[2].[2].[1]\", 7), [1, 2, [3, 4, [5, 7]]]),\n        (([1, 2, [3, 4, [5, 6]]], [2, 2, 2], 7), [1, 2, [3, 4, [5, 6, 7]]]),\n        (([1, 2, [3, 4, [5, 6]]], \"[2].[2].[2]\", 7), [1, 2, [3, 4, [5, 6, 7]]]),\n        (({}, \"a.b[0].c\", 1), {\"a\": {\"b\": [{\"c\": 1}]}}),\n        (({}, \"a.b[0][0].c\", 1), {\"a\": {\"b\": [[{\"c\": 1}]]}}),\n        (({}, \"a\", tuple), {\"a\": tuple}),\n        (({}, r\"a.b\\.c.d\", 1), {\"a\": {\"b.c\": {\"d\": 1}}}),\n    ],\n)\ndef test_set_(case, expected):\n    assert _.set_(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({}, \"[0][1]\", \"a\", lambda: {}), {0: {1: \"a\"}}),\n        (({}, \"[0][1]\", dict, lambda: {}), {0: {1: dict}}),\n        ((Namespace(), \"a.b\", 5, lambda: Namespace()), Namespace(a=Namespace(b=5))),\n        (\n            (Namespace(a=Namespace(b=5)), \"a.c.d\", 55, lambda: Namespace()),\n            Namespace(a=Namespace(b=5, c=Namespace(d=55))),\n        ),\n    ],\n)\ndef test_set_with(case, expected):\n    assert _.set_with(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        ((\"1\",), True),\n        ((\"0\",), False),\n        ((\"true\",), True),\n        ((\"True\",), True),\n        ((\"false\",), False),\n        ((\"False\",), False),\n        ((\"\",), None),\n        ((\"a\",), None),\n        ((0,), False),\n        ((1,), True),\n        (([],), False),\n        ((True,), True),\n        ((False,), False),\n        ((None,), False),\n        ((\"Truthy\", [\"truthy\"]), True),\n        ((\"Falsey\", [], [\"falsey\"]), False),\n        ((\"foobar\", [\"^[f]\"]), True),\n        ((\"ofobar\", [\"^[f]\"]), None),\n        ((\"foobar\", [], [\".+[r]$\"]), False),\n        ((\"foobra\", [], [\".+[r]$\"]), None),\n    ],\n)\ndef test_to_boolean(case, expected):\n    assert _.to_boolean(*case) is expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (1.4, 1),\n        (1.9, 1),\n        (\"1.4\", 1),\n        (\"1.9\", 1),\n        (\"foo\", 0),\n        (None, 0),\n        (True, 1),\n        (False, 0),\n        ({}, 0),\n        ([], 0),\n        ((), 0),\n    ],\n)\ndef test_to_integer(case, expected):\n    assert _.to_integer(case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [((\"2.556\",), 3.0), ((\"2.556\", 1), 2.6), ((\"999.999\", -1), 990.0), ((\"foo\",), None)],\n)\ndef test_to_number(case, expected):\n    assert _.to_number(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        ({\"a\": 1, \"b\": 2, \"c\": 3}, [[\"a\", 1], [\"b\", 2], [\"c\", 3]]),\n        ([1, 2, 3], [[0, 1], [1, 2], [2, 3]]),\n    ],\n)\ndef test_to_pairs(case, expected):\n    assert dict(_.to_pairs(case)) == dict(expected)\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (1, \"1\"),\n        (1.25, \"1.25\"),\n        (True, \"True\"),\n        ([1], \"[1]\"),\n        (\"d\\xc3\\xa9j\\xc3\\xa0 vu\", \"d\\xc3\\xa9j\\xc3\\xa0 vu\"),\n        (\"\", \"\"),\n        (None, \"\"),\n        (today, str(today)),\n    ],\n)\ndef test_to_string(case, expected):\n    assert _.to_string(case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            ([1, 2, 3, 4, 5], lambda acc, value, key: acc.append((key, value))),\n            [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)],\n        ),\n        (([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], helpers.transform_iteratee0), [1, 9, 25]),\n        (([1, 2, 3, 4, 5],), []),\n    ],\n)\ndef test_transform(case, expected):\n    assert _.transform(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            (\n                {\"rome\": \"Republic\"},\n                [\"rome\"],\n                lambda value: \"Empire\" if value == \"Republic\" else value,\n            ),\n            {\"rome\": \"Empire\"},\n        ),\n        (({}, [\"rome\"], lambda value: \"Empire\" if value == \"Republic\" else value), {\"rome\": None}),\n        (\n            (\n                {\"earth\": {\"rome\": \"Republic\"}},\n                [\"earth\", \"rome\"],\n                lambda value: \"Empire\" if value == \"Republic\" else value,\n            ),\n            {\"earth\": {\"rome\": \"Empire\"}},\n        ),\n    ],\n)\ndef test_update(case, expected):\n    assert _.update(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({}, \"[0][1]\", _.constant(\"a\"), lambda *_: {}), {0: {1: \"a\"}}),\n        (({}, \"[0][1]\", _.constant(\"a\"), {}), {0: {1: \"a\"}}),\n        (({}, \"[0][1]\", \"a\", {}), {0: {1: \"a\"}}),\n    ],\n)\ndef test_update_with(case, expected):\n    assert _.update_with(*case) == expected\n\n\n@parametrize(\n    \"obj,path,expected,new_obj\",\n    [\n        ({\"a\": [{\"b\": {\"c\": 7}}]}, \"a.0.b.c\", True, {\"a\": [{\"b\": {}}]}),\n        ([1, 2, 3], \"1\", True, [1, 3]),\n        ([1, 2, 3], 1, True, [1, 3]),\n        ([1, [2, 3]], [1, 1], True, [1, [2]]),\n        ([1, 2, 3], \"[0][0]\", False, [1, 2, 3]),\n        ([1, 2, 3], \"[0][0][0]\", False, [1, 2, 3]),\n    ],\n)\ndef test_unset(obj, path, expected, new_obj):\n    assert _.unset(obj, path) == expected\n    assert obj == new_obj\n\n\n@parametrize(\"case,expected\", [({\"a\": 1, \"b\": 2, \"c\": 3}, [1, 2, 3]), ([1, 2, 3], [1, 2, 3])])\ndef test_values(case, expected):\n    assert set(_.values(case)) == set(expected)\n"], "fixing_code": ["\"\"\"Generic utility methods not part of main API.\"\"\"\n\nimport builtins\nfrom collections.abc import Hashable, Iterable, Mapping, Sequence\nfrom decimal import Decimal\nfrom functools import wraps\nimport inspect\nfrom inspect import getfullargspec\nimport warnings\n\nimport pydash as pyd\n\n\n#: Singleton object that differentiates between an explicit ``None`` value and an unset value.\nUNSET = object()\n\n#: Tuple of number types.\nNUMBER_TYPES = (int, float, Decimal)\n\n#: Dictionary of builtins with keys as the builtin function and values as the string name.\nBUILTINS = {value: key for key, value in builtins.__dict__.items() if isinstance(value, Hashable)}\n\n\ndef callit(iteratee, *args, **kwargs):\n    \"\"\"Inspect argspec of `iteratee` function and only pass the supported arguments when calling\n    it.\"\"\"\n    maxargs = len(args)\n    argcount = kwargs[\"argcount\"] if \"argcount\" in kwargs else getargcount(iteratee, maxargs)\n    argstop = min([maxargs, argcount])\n\n    return iteratee(*args[:argstop])\n\n\ndef getargcount(iteratee, maxargs):\n    \"\"\"Return argument count of iteratee function.\"\"\"\n    if hasattr(iteratee, \"_argcount\"):\n        # Optimization feature where argcount of iteratee is known and properly\n        # set by initiator.\n        return iteratee._argcount\n\n    if isinstance(iteratee, type) or pyd.is_builtin(iteratee):\n        # Only pass single argument to type iteratees or builtins.\n        argcount = 1\n    else:\n        argcount = 1\n\n        try:\n            argcount = _getargcount(iteratee, maxargs)\n        except TypeError:  # pragma: no cover\n            pass\n\n    return argcount\n\n\ndef _getargcount(iteratee, maxargs):\n    argcount = None\n\n    try:\n        # PY2: inspect.signature was added in Python 3.\n        # Try to use inspect.signature when possible since it works better for our purpose of\n        # getting the iteratee argcount since it takes into account the \"self\" argument in callable\n        # classes.\n        sig = inspect.signature(iteratee)\n    except (TypeError, ValueError, AttributeError):\n        pass\n    else:  # pragma: no cover\n        if not any(\n            param.kind == inspect.Parameter.VAR_POSITIONAL for param in sig.parameters.values()\n        ):\n            argcount = len(sig.parameters)\n\n    if argcount is None:\n        argspec = getfullargspec(iteratee)\n        if argspec and not argspec.varargs:  # pragma: no cover\n            # Use inspected arg count.\n            argcount = len(argspec.args)\n\n    if argcount is None:\n        # Assume all args are handleable.\n        argcount = maxargs\n\n    return argcount\n\n\ndef iteriteratee(obj, iteratee=None, reverse=False):\n    \"\"\"Return iterative iteratee based on collection type.\"\"\"\n    if iteratee is None:\n        cbk = pyd.identity\n        argcount = 1\n    else:\n        cbk = pyd.iteratee(iteratee)\n        argcount = getargcount(cbk, maxargs=3)\n\n    items = iterator(obj)\n\n    if reverse:\n        items = reversed(tuple(items))\n\n    for key, item in items:\n        yield callit(cbk, item, key, obj, argcount=argcount), item, key, obj\n\n\ndef iterator(obj):\n    \"\"\"Return iterative based on object type.\"\"\"\n    if isinstance(obj, Mapping):\n        return obj.items()\n    elif hasattr(obj, \"iteritems\"):\n        return obj.iteritems()  # noqa: B301\n    elif hasattr(obj, \"items\"):\n        return iter(obj.items())\n    elif isinstance(obj, Iterable):\n        return enumerate(obj)\n    else:\n        return getattr(obj, \"__dict__\", {}).items()\n\n\ndef base_get(obj, key, default=UNSET):\n    \"\"\"\n    Safely get an item by `key` from a sequence or mapping object when `default` provided.\n\n    Args:\n        obj (list|dict): Sequence or mapping to retrieve item from.\n        key (mixed): Key or index identifying which item to retrieve.\n        default (mixed, optional): Default value to return if `key` not found in `obj`.\n\n    Returns:\n        mixed: `obj[key]`, `obj.key`, or `default`.\n\n    Raises:\n        KeyError: If `obj` is missing key, index, or attribute and no default value provided.\n    \"\"\"\n    if isinstance(obj, dict):\n        value = _base_get_dict(obj, key, default=default)\n    elif not isinstance(obj, (Mapping, Sequence)) or (\n        isinstance(obj, tuple) and hasattr(obj, \"_fields\")\n    ):\n        # Don't use getattr for dict/list objects since we don't want class methods/attributes\n        # returned for them but do allow getattr for namedtuple.\n        value = _base_get_object(obj, key, default=default)\n    else:\n        value = _base_get_item(obj, key, default=default)\n\n    if value is UNSET:\n        # Raise if there's no default provided.\n        raise KeyError(f'Object \"{repr(obj)}\" does not have key \"{key}\"')\n\n    return value\n\n\ndef _base_get_dict(obj, key, default=UNSET):\n    value = obj.get(key, UNSET)\n    if value is UNSET:\n        value = default\n        if not isinstance(key, int):\n            # Try integer key fallback.\n            try:\n                value = obj.get(int(key), default)\n            except Exception:\n                pass\n    return value\n\n\ndef _base_get_item(obj, key, default=UNSET):\n    try:\n        return obj[key]\n    except Exception:\n        pass\n\n    if not isinstance(key, int):\n        try:\n            return obj[int(key)]\n        except Exception:\n            pass\n\n    return default\n\n\ndef _base_get_object(obj, key, default=UNSET):\n    value = _base_get_item(obj, key, default=UNSET)\n    if value is UNSET:\n        _raise_if_restricted_key(key)\n        value = default\n        try:\n            value = getattr(obj, key)\n        except Exception:\n            pass\n    return value\n\n\ndef _raise_if_restricted_key(key):\n    # Prevent access to dunder-methods since this could expose access to globals through leaky\n    # attributes such as obj.__init__.__globals__.\n    if len(key) > 4 and key.isascii() and key.startswith(\"__\") and key.endswith(\"__\"):\n        raise KeyError(f\"access to restricted key {key!r} is not allowed\")\n\n\ndef base_set(obj, key, value, allow_override=True):\n    \"\"\"\n    Set an object's `key` to `value`. If `obj` is a ``list`` and the `key` is the next available\n    index position, append to list; otherwise, pad the list of ``None`` and then append to the list.\n\n    Args:\n        obj (list|dict): Object to assign value to.\n        key (mixed): Key or index to assign to.\n        value (mixed): Value to assign.\n        allow_override (bool): Whether to allow overriding a previously set key.\n    \"\"\"\n    if isinstance(obj, dict):\n        if allow_override or key not in obj:\n            obj[key] = value\n    elif isinstance(obj, list):\n        key = int(key)\n\n        if key < len(obj):\n            if allow_override:\n                obj[key] = value\n        else:\n            if key > len(obj):\n                # Pad list object with None values up to the index key so we can append the value\n                # into the key index.\n                obj[:] = (obj + [None] * key)[:key]\n            obj.append(value)\n    elif (allow_override or not hasattr(obj, key)) and obj is not None:\n        _raise_if_restricted_key(key)\n        setattr(obj, key, value)\n\n    return obj\n\n\ndef cmp(a, b):  # pragma: no cover\n    \"\"\"\n    Replacement for built-in function ``cmp`` that was removed in Python 3.\n\n    Note: Mainly used for comparison during sorting.\n    \"\"\"\n    if a is None and b is None:\n        return 0\n    elif a is None:\n        return -1\n    elif b is None:\n        return 1\n    return (a > b) - (a < b)\n\n\ndef parse_iteratee(iteratee_keyword, *args, **kwargs):\n    \"\"\"Try to find iteratee function passed in either as a keyword argument or as the last\n    positional argument in `args`.\"\"\"\n    iteratee = kwargs.get(iteratee_keyword)\n    last_arg = args[-1]\n\n    if iteratee is None and (\n        callable(last_arg)\n        or isinstance(last_arg, str)\n        or isinstance(last_arg, dict)\n        or last_arg is None\n    ):\n        iteratee = last_arg\n        args = args[:-1]\n\n    return iteratee, args\n\n\nclass iterator_with_default(object):\n    \"\"\"A wrapper around an iterator object that provides a default.\"\"\"\n\n    def __init__(self, collection, default):\n        self.iter = iter(collection)\n        self.default = default\n\n    def __iter__(self):\n        return self\n\n    def next_default(self):\n        ret = self.default\n        self.default = UNSET\n        return ret\n\n    def __next__(self):\n        ret = next(self.iter, self.next_default())\n        if ret is UNSET:\n            raise StopIteration\n        return ret\n\n    next = __next__\n\n\ndef deprecated(func):  # pragma: no cover\n    \"\"\"\n    This is a decorator which can be used to mark functions as deprecated.\n\n    It will result in a warning being emitted when the function is used.\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        warnings.warn(\n            f\"Call to deprecated function {func.__name__}.\",\n            category=DeprecationWarning,\n            stacklevel=3,\n        )\n        return func(*args, **kwargs)\n\n    return wrapper\n", "from argparse import Namespace\nfrom collections import defaultdict, namedtuple\nimport datetime as dt\n\nimport pytest\n\nimport pydash as _\n\nfrom . import helpers\n\n\nparametrize = pytest.mark.parametrize\n\ntoday = dt.date.today()\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"name\": \"fred\"}, {\"employer\": \"slate\"}), {\"name\": \"fred\", \"employer\": \"slate\"}),\n        (\n            ({\"name\": \"fred\"}, {\"employer\": \"slate\"}, {\"employer\": \"medium\"}),\n            {\"name\": \"fred\", \"employer\": \"medium\"},\n        ),\n    ],\n)\ndef test_assign(case, expected):\n    assert _.assign(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"name\": \"fred\"}, {\"age\": 26}, lambda obj, src: src + 1), {\"name\": \"fred\", \"age\": 27}),\n    ],\n)\ndef test_assign_with(case, expected):\n    assert _.assign_with(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"name\": \"fred\", \"greet\": lambda: \"Hello, world!\"},), [\"greet\"]),\n        (([\"fred\", lambda: \"Hello, world!\"],), [1]),\n    ],\n)\ndef test_callables(case, expected):\n    assert _.callables(*case) == expected\n\n\n@parametrize(\n    \"case\",\n    [\n        {\"a\": {\"d\": 1}, \"b\": {\"c\": 2}},\n        [{\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}],\n    ],\n)\ndef test_clone(case):\n    result = _.clone(case)\n\n    assert result is not case\n\n    for key, value in _.helpers.iterator(result):\n        assert value is case[key]\n\n\n@parametrize(\n    \"case,iteratee,expected\",\n    [\n        ({\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}, lambda v: v, {\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}),\n        (\n            {\"a\": 1, \"b\": 2, \"c\": {\"d\": 3}},\n            lambda v, k: v + 2 if isinstance(v, int) and k else None,\n            {\"a\": 3, \"b\": 4, \"c\": {\"d\": 3}},\n        ),\n    ],\n)\ndef test_clone_with(case, iteratee, expected):\n    result = _.clone_with(case, iteratee)\n\n    assert result == expected\n\n\n@parametrize(\n    \"case\",\n    [\n        {\"a\": {\"d\": 1}, \"b\": {\"c\": 2}},\n        {\"a\": {\"d\": 1}, \"b\": {\"c\": 2}},\n        [{\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}],\n    ],\n)\ndef test_clone_deep(case):\n    result = _.clone_deep(case)\n\n    assert result is not case\n\n    for key, value in _.helpers.iterator(result):\n        assert value is not case[key]\n\n\n@parametrize(\n    \"case,iteratee,expected\",\n    [\n        ({\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}, lambda v: v, {\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}),\n        (\n            {\"a\": 1, \"b\": 2, \"c\": {\"d\": 3}},\n            lambda v, k: v + 2 if isinstance(v, int) and k else None,\n            {\"a\": 3, \"b\": 4, \"c\": {\"d\": 5}},\n        ),\n        ([\"a\"], lambda a: None, [\"a\"]),\n        (\"a\", lambda a: None, \"a\"),\n    ],\n)\ndef test_clone_deep_with(case, iteratee, expected):\n    result = _.clone_deep_with(case, iteratee)\n\n    assert result == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            ({\"name\": \"barney\"}, {\"name\": \"fred\", \"employer\": \"slate\"}),\n            {\"name\": \"barney\", \"employer\": \"slate\"},\n        ),\n    ],\n)\ndef test_defaults(case, expected):\n    assert _.defaults(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            ({\"user\": {\"name\": \"barney\"}}, {\"user\": {\"name\": \"fred\", \"age\": 36}}),\n            {\"user\": {\"name\": \"barney\", \"age\": 36}},\n        ),\n        (({}, {\"a\": {\"b\": [\"c\"]}}, {\"a\": {\"b\": [\"d\"]}}), {\"a\": {\"b\": [\"c\"]}}),\n        (\n            ({\"a\": {\"b\": [{\"d\": \"e\"}]}}, {\"a\": {\"b\": [{\"d\": \"f\"}]}}, {\"a\": {\"b\": [{\"g\": \"h\"}]}}),\n            {\"a\": {\"b\": [{\"d\": \"e\", \"g\": \"h\"}]}},\n        ),\n        (\n            (\n                {\"a\": {\"b\": [{\"d\": \"e\"}]}},\n                {\"a\": {\"b\": [{\"d\": \"f\"}, {\"g\": \"h\"}]}},\n                {\"a\": {\"b\": [{\"i\": \"j\"}]}},\n            ),\n            {\"a\": {\"b\": [{\"d\": \"e\", \"i\": \"j\"}]}},\n        ),\n        (\n            (\n                {\"a\": {\"b\": [{\"d\": \"e\"}, {\"x\": \"y\"}]}},\n                {\"a\": {\"b\": [{\"d\": \"f\"}, {\"g\": \"h\"}]}},\n                {\"a\": {\"b\": [{\"i\": \"j\"}]}},\n            ),\n            {\"a\": {\"b\": [{\"d\": \"e\", \"i\": \"j\"}, {\"x\": \"y\", \"g\": \"h\"}]}},\n        ),\n    ],\n)\ndef test_defaults_deep(case, expected):\n    assert _.defaults_deep(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        ([1, 2, 3], {0: 1, 1: 2, 2: 3}),\n        ({0: 1, 1: 2, 2: 3}, {0: 1, 1: 2, 2: 3}),\n    ],\n)\ndef test_to_dict(case, expected):\n    assert _.to_dict(case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        ({\"a\": 1, \"b\": 2, \"c\": 3}, {1: \"a\", 2: \"b\", 3: \"c\"}),\n        ([1, 2, 3], {1: 0, 2: 1, 3: 2}),\n    ],\n)\ndef test_invert(case, expected):\n    assert _.invert(case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (([1, 2, 3],), {1: [0], 2: [1], 3: [2]}),\n        (\n            ({\"first\": \"fred\", \"second\": \"barney\", \"third\": \"fred\"},),\n            {\"fred\": [\"first\", \"third\"], \"barney\": [\"second\"]},\n        ),\n        (({\"a\": 1, \"b\": 2}, lambda val: val * 2), {2: [\"a\"], 4: [\"b\"]}),\n    ],\n)\ndef test_invert_by(case, expected):\n    result = _.invert_by(*case)\n    for key in result:\n        assert set(result[key]) == set(expected[key])\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2}, \"get\", \"a\"), 1),\n        (({\"a\": {\"b\": {\"c\": [1, 2, 3, 3]}}}, \"a.b.c.count\", 3), 2),\n        (({}, \"count\"), None),\n    ],\n)\ndef test_invoke(case, expected):\n    assert _.invoke(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        # NOTE: The expected is a list of values but find_key returns only a single\n        # value. However, since dicts do not have an order, it's unknown what the\n        # \"first\" returned value will be.\n        (\n            (\n                {\n                    \"barney\": {\"age\": 36, \"blocked\": False},\n                    \"fred\": {\"age\": 40, \"blocked\": True},\n                    \"pebbles\": {\"age\": 1, \"blocked\": False},\n                },\n                lambda obj: obj[\"age\"] < 40,\n            ),\n            [\"pebbles\", \"barney\"],\n        ),\n        (\n            (\n                {\n                    \"barney\": {\"age\": 36, \"blocked\": False},\n                    \"fred\": {\"age\": 40, \"blocked\": True},\n                    \"pebbles\": {\"age\": 1, \"blocked\": False},\n                },\n            ),\n            [\"barney\", \"fred\", \"pebbles\"],\n        ),\n        (([1, 2, 3],), [0]),\n    ],\n)\ndef test_find_key(case, expected):\n    assert _.find_key(*case) in expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        # NOTE: The expected is a list of values but find_last_key returns only a\n        # single value. However, since dicts do not have an order, it's unknown\n        # what the \"first\" returned value will be.\n        (\n            (\n                {\n                    \"barney\": {\"age\": 36, \"blocked\": False},\n                    \"fred\": {\"age\": 40, \"blocked\": True},\n                    \"pebbles\": {\"age\": 1, \"blocked\": False},\n                },\n                lambda obj: obj[\"age\"] < 40,\n            ),\n            [\"pebbles\", \"barney\"],\n        ),\n        (\n            (\n                {\n                    \"barney\": {\"age\": 36, \"blocked\": False},\n                    \"fred\": {\"age\": 40, \"blocked\": True},\n                    \"pebbles\": {\"age\": 1, \"blocked\": False},\n                },\n            ),\n            [\"barney\", \"fred\", \"pebbles\"],\n        ),\n        (([1, 2, 3],), [2]),\n    ],\n)\ndef test_find_last_key(case, expected):\n    assert _.find_last_key(*case) in expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            ({\"name\": \"fred\", \"employer\": \"slate\"}, helpers.for_in_iteratee0),\n            ({\"name\": \"fredfred\", \"employer\": \"slateslate\"},),\n        ),\n        (\n            ({\"name\": \"fred\", \"employer\": \"slate\"}, helpers.for_in_iteratee1),\n            ({\"name\": \"fredfred\", \"employer\": \"slate\"}, {\"name\": \"fred\", \"employer\": \"slateslate\"}),\n        ),\n        (([1, 2, 3], helpers.for_in_iteratee2), ([False, True, 3],)),\n    ],\n)\ndef test_for_in(case, expected):\n    assert _.for_in(*case) in expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            ({\"name\": \"fred\", \"employer\": \"slate\"}, helpers.for_in_iteratee0),\n            ({\"name\": \"fredfred\", \"employer\": \"slateslate\"},),\n        ),\n        (\n            ({\"name\": \"fred\", \"employer\": \"slate\"}, helpers.for_in_iteratee1),\n            ({\"name\": \"fredfred\", \"employer\": \"slate\"}, {\"name\": \"fred\", \"employer\": \"slateslate\"}),\n        ),\n        (([1, 2, 3], helpers.for_in_iteratee2), ([1, True, \"index:2\"],)),\n    ],\n)\ndef test_for_in_right(case, expected):\n    assert _.for_in_right(*case) in expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.two\"), {\"three\": 4}),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.two.three\"), 4),\n        (({\"one\": {\"two\": {\"three\": 4}}}, [\"one\", \"two\"]), {\"three\": 4}),\n        (({\"one\": {\"two\": {\"three\": 4}}}, [\"one\", \"two\", \"three\"]), 4),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four\"), None),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\", []), []),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.0.a\", [{\"a\": 1}]), [{\"a\": 1}]),\n        (({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\", []), []),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\"), None),\n        (({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\"), None),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\", 2), 2),\n        (({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\", 2), 2),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\", {\"test\": \"value\"}), {\"test\": \"value\"}),\n        (\n            ({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\", {\"test\": \"value\"}),\n            {\"test\": \"value\"},\n        ),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\", \"haha\"), \"haha\"),\n        (({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\", \"haha\"), \"haha\"),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"five\"), None),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, [\"one\", 1, \"three\", 1]), 5),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, \"one.[1].three.[1]\"), 5),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, \"one.1.three.1\"), 5),\n        (([\"one\", {\"two\": {\"three\": [4, 5]}}], \"[1].two.three.[0]\"), 4),\n        (([\"one\", {\"two\": {\"three\": [4, [{\"four\": [5]}]]}}], \"[1].two.three[1][0].four[0]\"), 5),\n        ((range(50), \"[42]\"), 42),\n        (([[[[[[[[[[42]]]]]]]]]], \"[0][0][0][0][0][0][0][0][0][0]\"), 42),\n        (([range(50)], \"[0][42]\"), 42),\n        (({\"a\": [{\"b\": range(50)}]}, \"a[0].b[42]\"), 42),\n        (\n            ({\"lev.el1\": {\"lev\\\\el2\": {\"level3\": [\"value\"]}}}, \"lev\\\\.el1.lev\\\\\\\\el2.level3.[0]\"),\n            \"value\",\n        ),\n        (({\"one\": [\"hello\", \"there\"]}, \"one.bad.hello\", []), []),\n        (({\"one\": [\"hello\", None]}, \"one.1.hello\"), None),\n        ((namedtuple(\"a\", [\"a\", \"b\"])(1, 2), \"a\"), 1),\n        ((namedtuple(\"a\", [\"a\", \"b\"])(1, 2), 0), 1),\n        ((namedtuple(\"a\", [\"a\", \"b\"])({\"c\": {\"d\": 1}}, 2), \"a.c.d\"), 1),\n        (({}, \"update\"), None),\n        (([], \"extend\"), None),\n        (({(1,): {(2,): 3}}, (1,)), {(2,): 3}),\n        (({(1,): {(2,): 3}}, [(1,), (2,)]), 3),\n        (({object: 1}, object), 1),\n        (({object: {object: 1}}, [object, object]), 1),\n        (({1: {\"name\": \"John Doe\"}}, \"1.name\"), \"John Doe\"),\n    ],\n)\ndef test_get(case, expected):\n    assert _.get(*case) == expected\n\n\ndef test_get__should_not_populate_defaultdict():\n    data = defaultdict(list)\n    _.get(data, \"a\")\n    assert data == {}\n\n\n@parametrize(\n    \"obj,path\",\n    [\n        (helpers.Object(), \"__init__\"),\n        (helpers.Object(subobj=helpers.Object()), \"subobj.__init__\"),\n        (namedtuple(\"a\", [\"a\"])(a=1), \"__len__\"),\n    ],\n)\ndef test_get__raises_for_objects_when_path_restricted(obj, path):\n    with pytest.raises(KeyError, match=\"access to restricted key\"):\n        _.get(obj, path)\n\n\n@parametrize(\n    \"obj,path\",\n    [\n        ({}, \"__init__\"),\n        ([], \"__contains__\"),\n    ],\n)\ndef test_get__does_not_raise_for_dict_or_list_when_path_restricted(obj, path):\n    assert _.get(obj, path) is None\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"b\"), True),\n        (([1, 2, 3], 0), True),\n        (([1, 2, 3], 1), True),\n        (([1, 2, 3], 3), False),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"b\"), True),\n        (([1, 2, 3], 0), True),\n        (([1, 2, 3], 1), True),\n        (([1, 2, 3], 3), False),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.two\"), True),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.two.three\"), True),\n        (({\"one\": {\"two\": {\"three\": 4}}}, [\"one\", \"two\"]), True),\n        (({\"one\": {\"two\": {\"three\": 4}}}, [\"one\", \"two\", \"three\"]), True),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four\"), False),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"five\"), False),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\"), False),\n        (({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\"), False),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, [\"one\", 1, \"three\", 1]), True),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, \"one.[1].three.[1]\"), True),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, \"one.1.three.1\"), True),\n        (([\"one\", {\"two\": {\"three\": [4, 5]}}], \"[1].two.three.[0]\"), True),\n        (({\"lev.el1\": {r\"lev\\el2\": {\"level3\": [\"value\"]}}}, r\"lev\\.el1.lev\\\\el2.level3.[0]\"), True),\n    ],\n)\ndef test_has(case, expected):\n    assert _.has(*case) == expected\n\n\ndef test_has__should_not_populate_defaultdict():\n    data = defaultdict(list)\n    _.has(data, \"a\")\n    assert data == {}\n\n\n@parametrize(\"case,expected\", [({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\", \"b\", \"c\"]), ([1, 2, 3], [0, 1, 2])])\ndef test_keys(case, expected):\n    assert set(_.keys(case)) == set(expected)\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, lambda num: num * 3), {\"a\": 3, \"b\": 6, \"c\": 9}),\n        (\n            (\n                {\"fred\": {\"name\": \"fred\", \"age\": 40}, \"pebbles\": {\"name\": \"pebbles\", \"age\": 1}},\n                \"age\",\n            ),\n            {\"fred\": 40, \"pebbles\": 1},\n        ),\n    ],\n)\ndef test_map_values(case, expected):\n    assert _.map_values(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            (\n                {\n                    \"level1\": {\n                        \"value\": \"value 1\",\n                        \"level2\": {\"value\": \"value 2\", \"level3\": {\"value\": \"value 3\"}},\n                    }\n                },\n                lambda value, property_path: \".\".join(property_path) + \"==\" + value,\n            ),\n            {\n                \"level1\": {\n                    \"value\": \"level1.value==value 1\",\n                    \"level2\": {\n                        \"value\": \"level1.level2.value==value 2\",\n                        \"level3\": {\"value\": \"level1.level2.level3.value==value 3\"},\n                    },\n                }\n            },\n        ),\n        (\n            (\n                [[\"value 1\", [[\"value 2\", [\"value 3\"]]]]],\n                lambda value, property_path: (_.join(property_path, \".\") + \"==\" + value),\n            ),\n            [[\"0.0==value 1\", [[\"0.1.0.0==value 2\", [\"0.1.0.1.0==value 3\"]]]]],\n        ),\n    ],\n)\ndef test_map_values_deep(case, expected):\n    assert _.map_values_deep(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            (\n                {\"characters\": [{\"name\": \"barney\"}, {\"name\": \"fred\"}]},\n                {\"characters\": [{\"age\": 36}, {\"age\": 40}]},\n            ),\n            {\"characters\": [{\"name\": \"barney\", \"age\": 36}, {\"name\": \"fred\", \"age\": 40}]},\n        ),\n        (\n            (\n                {\"characters\": [{\"name\": \"barney\"}, {\"name\": \"fred\"}, {}]},\n                {\"characters\": [{\"age\": 36}, {\"age\": 40}]},\n            ),\n            {\"characters\": [{\"name\": \"barney\", \"age\": 36}, {\"name\": \"fred\", \"age\": 40}, {}]},\n        ),\n        (\n            (\n                {\"characters\": [{\"name\": \"barney\"}, {\"name\": \"fred\"}]},\n                {\"characters\": [{\"age\": 36}, {\"age\": 40}, {}]},\n            ),\n            {\"characters\": [{\"name\": \"barney\", \"age\": 36}, {\"name\": \"fred\", \"age\": 40}, {}]},\n        ),\n        (\n            (\n                {\"characters\": [{\"name\": \"barney\"}, {\"name\": \"fred\"}]},\n                {\"characters\": [{\"age\": 36}, {\"age\": 40}]},\n                {\"characters\": [{\"score\": 5}, {\"score\": 7}]},\n            ),\n            {\n                \"characters\": [\n                    {\"name\": \"barney\", \"age\": 36, \"score\": 5},\n                    {\"name\": \"fred\", \"age\": 40, \"score\": 7},\n                ]\n            },\n        ),\n        (\n            (\n                {\"characters\": {\"barney\": {\"age\": 36}, \"fred\": {\"score\": 7}}},\n                {\"characters\": {\"barney\": {\"score\": 5}, \"fred\": {\"age\": 40}}},\n            ),\n            {\"characters\": {\"barney\": {\"age\": 36, \"score\": 5}, \"fred\": {\"age\": 40, \"score\": 7}}},\n        ),\n        (\n            (\n                {\"characters\": {\"barney\": {\"age\": 36}, \"fred\": {\"score\": 7}}},\n                {\"characters\": {\"barney\": [5], \"fred\": 7}},\n            ),\n            {\"characters\": {\"barney\": [5], \"fred\": 7}},\n        ),\n        (\n            (\n                {\"characters\": {\"barney\": {\"age\": 36}, \"fred\": {\"score\": 7}}},\n                {\"foo\": {\"barney\": [5], \"fred\": 7}},\n            ),\n            {\n                \"characters\": {\"barney\": {\"age\": 36}, \"fred\": {\"score\": 7}},\n                \"foo\": {\"barney\": [5], \"fred\": 7},\n            },\n        ),\n        (({\"foo\": {\"bar\": 1}}, {\"foo\": {}}), {\"foo\": {\"bar\": 1}}),\n        (({},), {}),\n        (([],), []),\n        ((None,), None),\n        ((None, {\"a\": 1}), None),\n        ((None, None, None, {\"a\": 1}), None),\n        (({\"a\": 1}, None), {\"a\": 1}),\n        (({\"a\": 1}, None, None, None, {\"b\": 2}), {\"a\": 1, \"b\": 2}),\n        (({\"a\": None}, None, None, None, {\"b\": None}), {\"a\": None, \"b\": None}),\n    ],\n)\ndef test_merge(case, expected):\n    assert _.merge(*case) == expected\n\n\ndef test_merge_no_link_dict():\n    case1 = {\"foo\": {\"bar\": None}}\n    case2 = {\"foo\": {\"bar\": False}}\n    result = _.merge({}, case1, case2)\n    result[\"foo\"][\"bar\"] = True\n\n    assert case1 == {\"foo\": {\"bar\": None}}\n    assert case2 == {\"foo\": {\"bar\": False}}\n\n\ndef test_merge_no_link_list():\n    case = {\"foo\": [{}]}\n    result = _.merge({}, case)\n    result[\"foo\"][0][\"bar\"] = True\n\n    assert case == {\"foo\": [{}]}\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            (\n                {\"fruits\": [\"apple\"], \"others\": {\"vegetables\": [\"beet\"]}},\n                {\"fruits\": [\"banana\"], \"others\": {\"vegetables\": [\"carrot\"]}},\n                lambda a, b: a + b if isinstance(a, list) else None,\n            ),\n            {\"fruits\": [\"apple\", \"banana\"], \"others\": {\"vegetables\": [\"beet\", \"carrot\"]}},\n        ),\n    ],\n)\ndef test_merge_with(case, expected):\n    assert _.merge_with(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"a\"), {\"b\": 2, \"c\": 3}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"a\", \"b\"), {\"c\": 3}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\", \"b\"]), {\"c\": 3}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\"], [\"b\"]), {\"c\": 3}),\n        (([1, 2, 3],), {0: 1, 1: 2, 2: 3}),\n        (([1, 2, 3], 0), {1: 2, 2: 3}),\n        (([1, 2, 3], 0, 1), {2: 3}),\n        (({\"a\": {\"b\": {\"c\": \"d\"}}, \"e\": \"f\"}, \"a.b.c\", \"e\"), {\"a\": {\"b\": {}}}),\n        (({\"a\": [{\"b\": 1, \"c\": 2}, {\"d\": 3}]}, \"a[0].c\", \"a[1].d\"), {\"a\": [{\"b\": 1}, {}]}),\n    ],\n)\ndef test_omit(case, expected):\n    assert _.omit(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\", \"b\"]), {\"c\": 3}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, lambda value, key: key == \"a\"), {\"b\": 2, \"c\": 3}),\n        (([1, 2, 3],), {0: 1, 1: 2, 2: 3}),\n        (([1, 2, 3], [0]), {1: 2, 2: 3}),\n    ],\n)\ndef test_omit_by(case, expected):\n    assert _.omit_by(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        ((1,), 1),\n        ((1.0,), 1),\n        ((\"1\",), 1),\n        ((\"00001\",), 1),\n        ((13, 8), 11),\n        ((\"0A\",), 10),\n        ((\"08\",), 8),\n        ((\"10\",), 16),\n        ((\"10\", 10), 10),\n        ((\"xyz\",), None),\n    ],\n)\ndef test_parse_int(case, expected):\n    assert _.parse_int(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"a\"), {\"a\": 1}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"a\", \"b\"), {\"a\": 1, \"b\": 2}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\", \"b\"]), {\"a\": 1, \"b\": 2}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\"], [\"b\"]), {\"a\": 1, \"b\": 2}),\n        (([1, 2, 3],), {}),\n        (([1, 2, 3], 0), {0: 1}),\n        ((helpers.Object(a=1, b=2, c=3), \"a\"), {\"a\": 1}),\n        ((helpers.ItemsObject({\"a\": 1, \"b\": 2, \"c\": 3}), \"a\"), {\"a\": 1}),\n        ((helpers.IteritemsObject({\"a\": 1, \"b\": 2, \"c\": 3}), \"a\"), {\"a\": 1}),\n        (({\"a\": {\"b\": 1, \"c\": 2, \"d\": 3}}, \"a.b\", \"a.d\"), {\"a\": {\"b\": 1, \"d\": 3}}),\n        (\n            ({\"a\": [{\"b\": 1}, {\"c\": 2}, {\"d\": 3}]}, \"a[0]\", \"a[2]\"),\n            {\"a\": [{\"b\": 1}, None, {\"d\": 3}]},\n        ),\n    ],\n)\ndef test_pick(case, expected):\n    assert _.pick(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\", \"b\"]), {\"a\": 1, \"b\": 2}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, lambda value, key: key in [\"a\"]), {\"a\": 1}),\n        (([1, 2, 3],), {0: 1, 1: 2, 2: 3}),\n        (([1, 2, 3], [0]), {0: 1}),\n        ((helpers.Object(a=1, b=2, c=3), \"a\"), {\"a\": 1}),\n        ((helpers.ItemsObject({\"a\": 1, \"b\": 2, \"c\": 3}), \"a\"), {\"a\": 1}),\n        ((helpers.IteritemsObject({\"a\": 1, \"b\": 2, \"c\": 3}), \"a\"), {\"a\": 1}),\n    ],\n)\ndef test_pick_by(case, expected):\n    assert _.pick_by(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2}, {\"a\": \"A\", \"b\": \"B\"}), {\"A\": 1, \"B\": 2}),\n        (({\"a\": 1, \"b\": 2}, {\"a\": \"A\"}), {\"A\": 1, \"b\": 2}),\n        (({\"a\": 1, \"b\": 2}, {\"c\": \"C\", \"b\": \"B\"}), {\"a\": 1, \"B\": 2}),\n    ],\n)\ndef test_rename_keys(case, expected):\n    assert _.rename_keys(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({}, [\"one\", \"two\", \"three\", \"four\"], 1), {\"one\": {\"two\": {\"three\": {\"four\": 1}}}}),\n        (({}, \"one.two.three.four\", 1), {\"one\": {\"two\": {\"three\": {\"four\": 1}}}}),\n        (\n            ({\"one\": {\"two\": {}, \"three\": {}}}, [\"one\", \"two\", \"three\", \"four\"], 1),\n            {\"one\": {\"two\": {\"three\": {\"four\": 1}}, \"three\": {}}},\n        ),\n        (\n            ({\"one\": {\"two\": {}, \"three\": {}}}, \"one.two.three.four\", 1),\n            {\"one\": {\"two\": {\"three\": {\"four\": 1}}, \"three\": {}}},\n        ),\n        (({}, \"one\", 1), {\"one\": 1}),\n        (([], [0, 0, 0], 1), [[[1]]]),\n        (([], \"[0].[0].[0]\", 1), [[[1]]]),\n        (([1, 2, [3, 4, [5, 6]]], [2, 2, 1], 7), [1, 2, [3, 4, [5, 7]]]),\n        (([1, 2, [3, 4, [5, 6]]], \"[2].[2].[1]\", 7), [1, 2, [3, 4, [5, 7]]]),\n        (([1, 2, [3, 4, [5, 6]]], [2, 2, 2], 7), [1, 2, [3, 4, [5, 6, 7]]]),\n        (([1, 2, [3, 4, [5, 6]]], \"[2].[2].[2]\", 7), [1, 2, [3, 4, [5, 6, 7]]]),\n        (({}, \"a.b[0].c\", 1), {\"a\": {\"b\": [{\"c\": 1}]}}),\n        (({}, \"a.b[0][0].c\", 1), {\"a\": {\"b\": [[{\"c\": 1}]]}}),\n        (({}, \"a\", tuple), {\"a\": tuple}),\n        (({}, r\"a.b\\.c.d\", 1), {\"a\": {\"b.c\": {\"d\": 1}}}),\n    ],\n)\ndef test_set_(case, expected):\n    assert _.set_(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({}, \"[0][1]\", \"a\", lambda: {}), {0: {1: \"a\"}}),\n        (({}, \"[0][1]\", dict, lambda: {}), {0: {1: dict}}),\n        ((Namespace(), \"a.b\", 5, lambda: Namespace()), Namespace(a=Namespace(b=5))),\n        (\n            (Namespace(a=Namespace(b=5)), \"a.c.d\", 55, lambda: Namespace()),\n            Namespace(a=Namespace(b=5, c=Namespace(d=55))),\n        ),\n    ],\n)\ndef test_set_with(case, expected):\n    assert _.set_with(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        ((\"1\",), True),\n        ((\"0\",), False),\n        ((\"true\",), True),\n        ((\"True\",), True),\n        ((\"false\",), False),\n        ((\"False\",), False),\n        ((\"\",), None),\n        ((\"a\",), None),\n        ((0,), False),\n        ((1,), True),\n        (([],), False),\n        ((True,), True),\n        ((False,), False),\n        ((None,), False),\n        ((\"Truthy\", [\"truthy\"]), True),\n        ((\"Falsey\", [], [\"falsey\"]), False),\n        ((\"foobar\", [\"^[f]\"]), True),\n        ((\"ofobar\", [\"^[f]\"]), None),\n        ((\"foobar\", [], [\".+[r]$\"]), False),\n        ((\"foobra\", [], [\".+[r]$\"]), None),\n    ],\n)\ndef test_to_boolean(case, expected):\n    assert _.to_boolean(*case) is expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (1.4, 1),\n        (1.9, 1),\n        (\"1.4\", 1),\n        (\"1.9\", 1),\n        (\"foo\", 0),\n        (None, 0),\n        (True, 1),\n        (False, 0),\n        ({}, 0),\n        ([], 0),\n        ((), 0),\n    ],\n)\ndef test_to_integer(case, expected):\n    assert _.to_integer(case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [((\"2.556\",), 3.0), ((\"2.556\", 1), 2.6), ((\"999.999\", -1), 990.0), ((\"foo\",), None)],\n)\ndef test_to_number(case, expected):\n    assert _.to_number(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        ({\"a\": 1, \"b\": 2, \"c\": 3}, [[\"a\", 1], [\"b\", 2], [\"c\", 3]]),\n        ([1, 2, 3], [[0, 1], [1, 2], [2, 3]]),\n    ],\n)\ndef test_to_pairs(case, expected):\n    assert dict(_.to_pairs(case)) == dict(expected)\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (1, \"1\"),\n        (1.25, \"1.25\"),\n        (True, \"True\"),\n        ([1], \"[1]\"),\n        (\"d\\xc3\\xa9j\\xc3\\xa0 vu\", \"d\\xc3\\xa9j\\xc3\\xa0 vu\"),\n        (\"\", \"\"),\n        (None, \"\"),\n        (today, str(today)),\n    ],\n)\ndef test_to_string(case, expected):\n    assert _.to_string(case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            ([1, 2, 3, 4, 5], lambda acc, value, key: acc.append((key, value))),\n            [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)],\n        ),\n        (([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], helpers.transform_iteratee0), [1, 9, 25]),\n        (([1, 2, 3, 4, 5],), []),\n    ],\n)\ndef test_transform(case, expected):\n    assert _.transform(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            (\n                {\"rome\": \"Republic\"},\n                [\"rome\"],\n                lambda value: \"Empire\" if value == \"Republic\" else value,\n            ),\n            {\"rome\": \"Empire\"},\n        ),\n        (({}, [\"rome\"], lambda value: \"Empire\" if value == \"Republic\" else value), {\"rome\": None}),\n        (\n            (\n                {\"earth\": {\"rome\": \"Republic\"}},\n                [\"earth\", \"rome\"],\n                lambda value: \"Empire\" if value == \"Republic\" else value,\n            ),\n            {\"earth\": {\"rome\": \"Empire\"}},\n        ),\n    ],\n)\ndef test_update(case, expected):\n    assert _.update(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({}, \"[0][1]\", _.constant(\"a\"), lambda *_: {}), {0: {1: \"a\"}}),\n        (({}, \"[0][1]\", _.constant(\"a\"), {}), {0: {1: \"a\"}}),\n        (({}, \"[0][1]\", \"a\", {}), {0: {1: \"a\"}}),\n    ],\n)\ndef test_update_with(case, expected):\n    assert _.update_with(*case) == expected\n\n\n@parametrize(\n    \"obj,path,expected,new_obj\",\n    [\n        ({\"a\": [{\"b\": {\"c\": 7}}]}, \"a.0.b.c\", True, {\"a\": [{\"b\": {}}]}),\n        ([1, 2, 3], \"1\", True, [1, 3]),\n        ([1, 2, 3], 1, True, [1, 3]),\n        ([1, [2, 3]], [1, 1], True, [1, [2]]),\n        ([1, 2, 3], \"[0][0]\", False, [1, 2, 3]),\n        ([1, 2, 3], \"[0][0][0]\", False, [1, 2, 3]),\n    ],\n)\ndef test_unset(obj, path, expected, new_obj):\n    assert _.unset(obj, path) == expected\n    assert obj == new_obj\n\n\n@parametrize(\"case,expected\", [({\"a\": 1, \"b\": 2, \"c\": 3}, [1, 2, 3]), ([1, 2, 3], [1, 2, 3])])\ndef test_values(case, expected):\n    assert set(_.values(case)) == set(expected)\n"], "filenames": ["src/pydash/helpers.py", "tests/test_objects.py"], "buggy_code_start_loc": [180, 380], "buggy_code_end_loc": [215, 380], "fixing_code_start_loc": [181, 381], "fixing_code_end_loc": [225, 405], "type": "CWE-77", "message": "This affects versions of the package pydash before 6.0.0. A number of pydash methods such as pydash.objects.invoke() and pydash.collections.invoke_map() accept dotted paths (Deep Path Strings) to target a nested Python object, relative to the original source object. These paths can be used to target internal class attributes and dict items, to retrieve, modify or invoke nested Python objects.\r\r**Note:**\r\rThe pydash.objects.invoke() method is vulnerable to Command Injection when the following prerequisites are satisfied:\r\r1) The source object (argument 1) is not a built-in object such as list/dict (otherwise, the __init__.__globals__ path is not accessible)\r\r2) The attacker has control over argument 2 (the path string) and argument 3 (the argument to pass to the invoked method)\r\r\rThe pydash.collections.invoke_map() method is also vulnerable, but is harder to exploit as the attacker does not have direct control over the argument to be passed to the invoked function.", "other": {"cve": {"id": "CVE-2023-26145", "sourceIdentifier": "report@snyk.io", "published": "2023-09-28T05:15:45.843", "lastModified": "2023-11-07T04:09:28.020", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "This affects versions of the package pydash before 6.0.0. A number of pydash methods such as pydash.objects.invoke() and pydash.collections.invoke_map() accept dotted paths (Deep Path Strings) to target a nested Python object, relative to the original source object. These paths can be used to target internal class attributes and dict items, to retrieve, modify or invoke nested Python objects.\r\r**Note:**\r\rThe pydash.objects.invoke() method is vulnerable to Command Injection when the following prerequisites are satisfied:\r\r1) The source object (argument 1) is not a built-in object such as list/dict (otherwise, the __init__.__globals__ path is not accessible)\r\r2) The attacker has control over argument 2 (the path string) and argument 3 (the argument to pass to the invoked method)\r\r\rThe pydash.collections.invoke_map() method is also vulnerable, but is harder to exploit as the attacker does not have direct control over the argument to be passed to the invoked function."}, {"lang": "es", "value": "Esto afecta a las versiones del paquete pydash anteriores a la 6.0.0. Varios m\u00e9todos de pydash, como pydash.objects.invoke() y pydash.collections.invoke_map(), aceptan rutas de puntos (Deep Path Strings) para apuntar a un objeto Python anidado, en relaci\u00f3n con el objeto fuente original. Estas rutas se pueden utilizar para apuntar a atributos internos de clase y elementos de dictado, para recuperar, modificar o invocar objetos Python anidados. **Nota:** El m\u00e9todo pydash.objects.invoke() es vulnerable a la inyecci\u00f3n de comandos cuando se cumplen los siguientes requisitos previos: \n1) El objeto fuente (argumento 1) no es un objeto integrado como list/dict (de lo contrario, the __init__.__globals__ path no es accesible) \n2) El atacante tiene control sobre el argumento 2 (la cadena de ruta)\n3) El argumento (el argumento para pasar al m\u00e9todo invocado) \nEl m\u00e9todo pydash.collections.invoke_map() tambi\u00e9n es vulnerable, pero es m\u00e1s dif\u00edcil de explotar ya que el atacante no tiene control directo sobre el argumento que se pasar\u00e1 a la funci\u00f3n invocada.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}, {"lang": "en", "value": "CWE-94"}]}, {"source": "report@snyk.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:derrickgilland:pydash:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.0.0", "matchCriteriaId": "78227353-EE51-4D4E-8B42-A4ADE5B179BF"}]}]}], "references": [{"url": "https://gist.github.com/CalumHutton/45d33e9ea55bf4953b3b31c84703dfca", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/dgilland/pydash/commit/6ff0831ad285fff937cafd2a853f20cc9ae92021", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://security.snyk.io/vuln/SNYK-PYTHON-PYDASH-5916518", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dgilland/pydash/commit/6ff0831ad285fff937cafd2a853f20cc9ae92021"}}