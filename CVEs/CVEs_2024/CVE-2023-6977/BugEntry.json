{"buggy_code": ["import os\nimport pathlib\nimport posixpath\nimport re\nimport urllib.parse\nimport uuid\nfrom typing import Any, Tuple\n\nfrom mlflow.exceptions import MlflowException\nfrom mlflow.protos.databricks_pb2 import INVALID_PARAMETER_VALUE\nfrom mlflow.store.db.db_types import DATABASE_ENGINES\nfrom mlflow.utils.os import is_windows\nfrom mlflow.utils.validation import _validate_db_type_string\n\n_INVALID_DB_URI_MSG = (\n    \"Please refer to https://mlflow.org/docs/latest/tracking.html#storage for \"\n    \"format specifications.\"\n)\n\n_DBFS_FUSE_PREFIX = \"/dbfs/\"\n_DBFS_HDFS_URI_PREFIX = \"dbfs:/\"\n_UC_VOLUMES_URI_PREFIX = \"/Volumes/\"\n_UC_DBFS_SYMLINK_PREFIX = \"/.fuse-mounts/\"\n_DATABRICKS_UNITY_CATALOG_SCHEME = \"databricks-uc\"\n\n\ndef is_local_uri(uri, is_tracking_or_registry_uri=True):\n    \"\"\"\n    Returns true if the specified URI is a local file path (/foo or file:/foo).\n\n    :param uri: The URI.\n    :param is_tracking_uri: Whether or not the specified URI is an MLflow Tracking or MLflow\n                            Model Registry URI. Examples of other URIs are MLflow artifact URIs,\n                            filesystem paths, etc.\n    \"\"\"\n    if uri == \"databricks\" and is_tracking_or_registry_uri:\n        return False\n\n    if is_windows() and uri.startswith(\"\\\\\\\\\"):\n        # windows network drive path looks like: \"\\\\<server name>\\path\\...\"\n        return False\n\n    parsed_uri = urllib.parse.urlparse(uri)\n    if parsed_uri.hostname and not (\n        parsed_uri.hostname == \".\"\n        or parsed_uri.hostname.startswith(\"localhost\")\n        or parsed_uri.hostname.startswith(\"127.0.0.1\")\n    ):\n        return False\n\n    scheme = parsed_uri.scheme\n    if scheme == \"\" or scheme == \"file\":\n        return True\n\n    if is_windows() and len(scheme) == 1 and scheme.lower() == pathlib.Path(uri).drive.lower()[0]:\n        return True\n\n    return False\n\n\ndef is_file_uri(uri):\n    return urllib.parse.urlparse(uri).scheme == \"file\"\n\n\ndef is_http_uri(uri):\n    scheme = urllib.parse.urlparse(uri).scheme\n    return scheme == \"http\" or scheme == \"https\"\n\n\ndef is_databricks_uri(uri):\n    \"\"\"\n    Databricks URIs look like 'databricks' (default profile) or 'databricks://profile'\n    or 'databricks://secret_scope:secret_key_prefix'.\n    \"\"\"\n    scheme = urllib.parse.urlparse(uri).scheme\n    return scheme == \"databricks\" or uri == \"databricks\"\n\n\ndef is_fuse_or_uc_volumes_uri(uri):\n    \"\"\"\n    Validates whether a provided URI is directed to a FUSE mount point or a UC volumes mount point.\n    Multiple directory paths are collapsed into a single designator for root path validation.\n    example:\n    \"////Volumes/\" will resolve to \"/Volumes/\" for validation purposes.\n    \"\"\"\n    resolved_uri = re.sub(\"/+\", \"/\", uri)\n    return any(\n        resolved_uri.startswith(x)\n        for x in [\n            _DBFS_FUSE_PREFIX,\n            _DBFS_HDFS_URI_PREFIX,\n            _UC_VOLUMES_URI_PREFIX,\n            _UC_DBFS_SYMLINK_PREFIX,\n        ]\n    )\n\n\ndef is_databricks_unity_catalog_uri(uri):\n    scheme = urllib.parse.urlparse(uri).scheme\n    return scheme == _DATABRICKS_UNITY_CATALOG_SCHEME or uri == _DATABRICKS_UNITY_CATALOG_SCHEME\n\n\ndef construct_db_uri_from_profile(profile):\n    if profile:\n        return \"databricks://\" + profile\n\n\n# Both scope and key_prefix should not contain special chars for URIs, like '/'\n# and ':'.\ndef validate_db_scope_prefix_info(scope, prefix):\n    for c in [\"/\", \":\", \" \"]:\n        if c in scope:\n            raise MlflowException(\n                f\"Unsupported Databricks profile name: {scope}.\"\n                f\" Profile names cannot contain '{c}'.\"\n            )\n        if prefix and c in prefix:\n            raise MlflowException(\n                f\"Unsupported Databricks profile key prefix: {prefix}.\"\n                f\" Key prefixes cannot contain '{c}'.\"\n            )\n    if prefix is not None and prefix.strip() == \"\":\n        raise MlflowException(\n            f\"Unsupported Databricks profile key prefix: '{prefix}'.\"\n            \" Key prefixes cannot be empty.\"\n        )\n\n\ndef get_db_info_from_uri(uri):\n    \"\"\"\n    Get the Databricks profile specified by the tracking URI (if any), otherwise\n    returns None.\n    \"\"\"\n    parsed_uri = urllib.parse.urlparse(uri)\n    if parsed_uri.scheme == \"databricks\" or parsed_uri.scheme == _DATABRICKS_UNITY_CATALOG_SCHEME:\n        # netloc should not be an empty string unless URI is formatted incorrectly.\n        if parsed_uri.netloc == \"\":\n            raise MlflowException(\n                f\"URI is formatted incorrectly: no netloc in URI '{uri}'.\"\n                \" This may be the case if there is only one slash in the URI.\"\n            )\n        profile_tokens = parsed_uri.netloc.split(\":\")\n        parsed_scope = profile_tokens[0]\n        if len(profile_tokens) == 1:\n            parsed_key_prefix = None\n        elif len(profile_tokens) == 2:\n            parsed_key_prefix = profile_tokens[1]\n        else:\n            # parse the content before the first colon as the profile.\n            parsed_key_prefix = \":\".join(profile_tokens[1:])\n        validate_db_scope_prefix_info(parsed_scope, parsed_key_prefix)\n        return parsed_scope, parsed_key_prefix\n    return None, None\n\n\ndef get_databricks_profile_uri_from_artifact_uri(uri, result_scheme=\"databricks\"):\n    \"\"\"\n    Retrieves the netloc portion of the URI as a ``databricks://`` or `databricks-uc://` URI,\n    if it is a proper Databricks profile specification, e.g.\n    ``profile@databricks`` or ``secret_scope:key_prefix@databricks``.\n    \"\"\"\n    parsed = urllib.parse.urlparse(uri)\n    if not parsed.netloc or parsed.hostname != result_scheme:\n        return None\n    if not parsed.username:  # no profile or scope:key\n        return result_scheme  # the default tracking/registry URI\n    validate_db_scope_prefix_info(parsed.username, parsed.password)\n    key_prefix = \":\" + parsed.password if parsed.password else \"\"\n    return f\"{result_scheme}://\" + parsed.username + key_prefix\n\n\ndef remove_databricks_profile_info_from_artifact_uri(artifact_uri):\n    \"\"\"\n    Only removes the netloc portion of the URI if it is a Databricks\n    profile specification, e.g.\n    ``profile@databricks`` or ``secret_scope:key_prefix@databricks``.\n    \"\"\"\n    parsed = urllib.parse.urlparse(artifact_uri)\n    if not parsed.netloc or parsed.hostname != \"databricks\":\n        return artifact_uri\n    return urllib.parse.urlunparse(parsed._replace(netloc=\"\"))\n\n\ndef add_databricks_profile_info_to_artifact_uri(artifact_uri, databricks_profile_uri):\n    \"\"\"\n    Throws an exception if ``databricks_profile_uri`` is not valid.\n    \"\"\"\n    if not databricks_profile_uri or not is_databricks_uri(databricks_profile_uri):\n        return artifact_uri\n    artifact_uri_parsed = urllib.parse.urlparse(artifact_uri)\n    # Do not overwrite the authority section if there is already one\n    if artifact_uri_parsed.netloc:\n        return artifact_uri\n\n    scheme = artifact_uri_parsed.scheme\n    if scheme == \"dbfs\" or scheme == \"runs\" or scheme == \"models\":\n        if databricks_profile_uri == \"databricks\":\n            netloc = \"databricks\"\n        else:\n            (profile, key_prefix) = get_db_info_from_uri(databricks_profile_uri)\n            prefix = \":\" + key_prefix if key_prefix else \"\"\n            netloc = profile + prefix + \"@databricks\"\n        new_parsed = artifact_uri_parsed._replace(netloc=netloc)\n        return urllib.parse.urlunparse(new_parsed)\n    else:\n        return artifact_uri\n\n\ndef extract_db_type_from_uri(db_uri):\n    \"\"\"\n    Parse the specified DB URI to extract the database type. Confirm the database type is\n    supported. If a driver is specified, confirm it passes a plausible regex.\n    \"\"\"\n    scheme = urllib.parse.urlparse(db_uri).scheme\n    scheme_plus_count = scheme.count(\"+\")\n\n    if scheme_plus_count == 0:\n        db_type = scheme\n    elif scheme_plus_count == 1:\n        db_type, _ = scheme.split(\"+\")\n    else:\n        error_msg = f\"Invalid database URI: '{db_uri}'. {_INVALID_DB_URI_MSG}\"\n        raise MlflowException(error_msg, INVALID_PARAMETER_VALUE)\n\n    _validate_db_type_string(db_type)\n\n    return db_type\n\n\ndef get_uri_scheme(uri_or_path):\n    scheme = urllib.parse.urlparse(uri_or_path).scheme\n    if any(scheme.lower().startswith(db) for db in DATABASE_ENGINES):\n        return extract_db_type_from_uri(uri_or_path)\n    return scheme\n\n\ndef extract_and_normalize_path(uri):\n    parsed_uri_path = urllib.parse.urlparse(uri).path\n    normalized_path = posixpath.normpath(parsed_uri_path)\n    return normalized_path.lstrip(\"/\")\n\n\ndef append_to_uri_path(uri, *paths):\n    \"\"\"\n    Appends the specified POSIX `paths` to the path component of the specified `uri`.\n\n    :param uri: The input URI, represented as a string.\n    :param paths: The POSIX paths to append to the specified `uri`'s path component.\n    :return: A new URI with a path component consisting of the specified `paths` appended to\n             the path component of the specified `uri`.\n\n    >>> uri1 = \"s3://root/base/path?param=value\"\n    >>> uri1 = append_to_uri_path(uri1, \"some/subpath\", \"/anotherpath\")\n    >>> assert uri1 == \"s3://root/base/path/some/subpath/anotherpath?param=value\"\n    >>> uri2 = \"a/posix/path\"\n    >>> uri2 = append_to_uri_path(uri2, \"/some\", \"subpath\")\n    >>> assert uri2 == \"a/posixpath/some/subpath\"\n    \"\"\"\n    path = \"\"\n    for subpath in paths:\n        path = _join_posixpaths_and_append_absolute_suffixes(path, subpath)\n\n    parsed_uri = urllib.parse.urlparse(uri)\n    if len(parsed_uri.scheme) == 0:\n        # If the input URI does not define a scheme, we assume that it is a POSIX path\n        # and join it with the specified input paths\n        return _join_posixpaths_and_append_absolute_suffixes(uri, path)\n\n    prefix = \"\"\n    if not parsed_uri.path.startswith(\"/\"):\n        # For certain URI schemes (e.g., \"file:\"), urllib's unparse routine does\n        # not preserve the relative URI path component properly. In certain cases,\n        # urlunparse converts relative paths to absolute paths. We introduce this logic\n        # to circumvent urlunparse's erroneous conversion\n        prefix = parsed_uri.scheme + \":\"\n        parsed_uri = parsed_uri._replace(scheme=\"\")\n\n    new_uri_path = _join_posixpaths_and_append_absolute_suffixes(parsed_uri.path, path)\n    new_parsed_uri = parsed_uri._replace(path=new_uri_path)\n    return prefix + urllib.parse.urlunparse(new_parsed_uri)\n\n\ndef append_to_uri_query_params(uri, *query_params: Tuple[str, Any]) -> str:\n    \"\"\"\n    Appends the specified query parameters to an existing URI.\n\n    :param uri: The URI to which to append query parameters.\n    :param query_params: Query parameters to append. Each parameter should\n                         be a 2-element tuple. For example, ``(\"key\", \"value\")``.\n    \"\"\"\n    parsed_uri = urllib.parse.urlparse(uri)\n    parsed_query = urllib.parse.parse_qsl(parsed_uri.query)\n    new_parsed_query = parsed_query + list(query_params)\n    new_query = urllib.parse.urlencode(new_parsed_query)\n    new_parsed_uri = parsed_uri._replace(query=new_query)\n    return urllib.parse.urlunparse(new_parsed_uri)\n\n\ndef _join_posixpaths_and_append_absolute_suffixes(prefix_path, suffix_path):\n    \"\"\"\n    Joins the POSIX path `prefix_path` with the POSIX path `suffix_path`. Unlike posixpath.join(),\n    if `suffix_path` is an absolute path, it is appended to prefix_path.\n\n    >>> result1 = _join_posixpaths_and_append_absolute_suffixes(\"relpath1\", \"relpath2\")\n    >>> assert result1 == \"relpath1/relpath2\"\n    >>> result2 = _join_posixpaths_and_append_absolute_suffixes(\"relpath\", \"/absolutepath\")\n    >>> assert result2 == \"relpath/absolutepath\"\n    >>> result3 = _join_posixpaths_and_append_absolute_suffixes(\"/absolutepath\", \"relpath\")\n    >>> assert result3 == \"/absolutepath/relpath\"\n    >>> result4 = _join_posixpaths_and_append_absolute_suffixes(\"/absolutepath1\", \"/absolutepath2\")\n    >>> assert result4 == \"/absolutepath1/absolutepath2\"\n    \"\"\"\n    if len(prefix_path) == 0:\n        return suffix_path\n\n    # If the specified prefix path is non-empty, we must relativize the suffix path by removing\n    # the leading slash, if present. Otherwise, posixpath.join() would omit the prefix from the\n    # joined path\n    suffix_path = suffix_path.lstrip(posixpath.sep)\n    return posixpath.join(prefix_path, suffix_path)\n\n\ndef is_databricks_acled_artifacts_uri(artifact_uri):\n    _ACLED_ARTIFACT_URI = \"databricks/mlflow-tracking/\"\n    artifact_uri_path = extract_and_normalize_path(artifact_uri)\n    return artifact_uri_path.startswith(_ACLED_ARTIFACT_URI)\n\n\ndef is_databricks_model_registry_artifacts_uri(artifact_uri):\n    _MODEL_REGISTRY_ARTIFACT_URI = \"databricks/mlflow-registry/\"\n    artifact_uri_path = extract_and_normalize_path(artifact_uri)\n    return artifact_uri_path.startswith(_MODEL_REGISTRY_ARTIFACT_URI)\n\n\ndef is_valid_dbfs_uri(uri):\n    parsed = urllib.parse.urlparse(uri)\n    if parsed.scheme != \"dbfs\":\n        return False\n    try:\n        db_profile_uri = get_databricks_profile_uri_from_artifact_uri(uri)\n    except MlflowException:\n        db_profile_uri = None\n    return not parsed.netloc or db_profile_uri is not None\n\n\ndef dbfs_hdfs_uri_to_fuse_path(dbfs_uri):\n    \"\"\"\n    Converts the provided DBFS URI into a DBFS FUSE path\n    :param dbfs_uri: A DBFS URI like \"dbfs:/my-directory\". Can also be a scheme-less URI like\n                     \"/my-directory\" if running in an environment where the default HDFS filesystem\n                     is \"dbfs:/\" (e.g. Databricks)\n    :return A DBFS FUSE-style path, e.g. \"/dbfs/my-directory\"\n    \"\"\"\n    if not is_valid_dbfs_uri(dbfs_uri) and dbfs_uri == posixpath.abspath(dbfs_uri):\n        # Convert posixpaths (e.g. \"/tmp/mlflow\") to DBFS URIs by adding \"dbfs:/\" as a prefix\n        dbfs_uri = \"dbfs:\" + dbfs_uri\n    if not dbfs_uri.startswith(_DBFS_HDFS_URI_PREFIX):\n        raise MlflowException(\n            f\"Path '{dbfs_uri}' did not start with expected DBFS URI \"\n            f\"prefix '{_DBFS_HDFS_URI_PREFIX}'\",\n        )\n\n    return _DBFS_FUSE_PREFIX + dbfs_uri[len(_DBFS_HDFS_URI_PREFIX) :]\n\n\ndef resolve_uri_if_local(local_uri):\n    \"\"\"\n    if `local_uri` is passed in as a relative local path, this function\n    resolves it to absolute path relative to current working directory.\n\n    :param local_uri: Relative or absolute path or local file uri\n\n    :return: a fully-formed absolute uri path or an absolute filesystem path\n    \"\"\"\n    from mlflow.utils.file_utils import local_file_uri_to_path\n\n    if local_uri is not None and is_local_uri(local_uri):\n        scheme = get_uri_scheme(local_uri)\n        cwd = pathlib.Path.cwd()\n        local_path = local_file_uri_to_path(local_uri)\n        if not pathlib.Path(local_path).is_absolute():\n            if scheme == \"\":\n                if is_windows():\n                    return urllib.parse.urlunsplit(\n                        (\n                            \"file\",\n                            None,\n                            cwd.joinpath(local_path).as_posix(),\n                            None,\n                            None,\n                        )\n                    )\n                return cwd.joinpath(local_path).as_posix()\n            local_uri_split = urllib.parse.urlsplit(local_uri)\n            return urllib.parse.urlunsplit(\n                (\n                    local_uri_split.scheme,\n                    None,\n                    cwd.joinpath(local_path).as_posix(),\n                    local_uri_split.query,\n                    local_uri_split.fragment,\n                )\n            )\n    return local_uri\n\n\ndef generate_tmp_dfs_path(dfs_tmp):\n    return posixpath.join(dfs_tmp, str(uuid.uuid4()))\n\n\ndef join_paths(*paths: str) -> str:\n    stripped = (p.strip(\"/\") for p in paths)\n    return \"/\" + posixpath.normpath(posixpath.join(*stripped))\n\n\n_OS_ALT_SEPS = [sep for sep in [os.sep, os.path.altsep] if sep is not None and sep != \"/\"]\n\n\ndef validate_path_is_safe(path):\n    \"\"\"\n    Validates that the specified path is safe to join with a trusted prefix. This is a security\n    measure to prevent path traversal attacks.\n    A valid path should:\n        not contain separators other than '/'\n        not contain .. to navigate to parent dir in path\n        not be an absolute path\n    \"\"\"\n    from mlflow.utils.file_utils import local_file_uri_to_path\n\n    exc = MlflowException(f\"Invalid path: {path}\", error_code=INVALID_PARAMETER_VALUE)\n    if any((s in path) for s in (\"#\", \"%23\")):\n        raise exc\n\n    if is_file_uri(path):\n        path = local_file_uri_to_path(path)\n    if (\n        any((s in path) for s in _OS_ALT_SEPS)\n        or \"..\" in path.split(\"/\")\n        or pathlib.PureWindowsPath(path).is_absolute()\n        or pathlib.PurePosixPath(path).is_absolute()\n        or (is_windows() and len(path) >= 2 and path[1] == \":\")\n    ):\n        raise exc\n", "import pathlib\nimport posixpath\n\nimport pytest\n\nfrom mlflow.exceptions import MlflowException\nfrom mlflow.store.db.db_types import DATABASE_ENGINES\nfrom mlflow.utils.os import is_windows\nfrom mlflow.utils.uri import (\n    add_databricks_profile_info_to_artifact_uri,\n    append_to_uri_path,\n    append_to_uri_query_params,\n    dbfs_hdfs_uri_to_fuse_path,\n    extract_and_normalize_path,\n    extract_db_type_from_uri,\n    get_databricks_profile_uri_from_artifact_uri,\n    get_db_info_from_uri,\n    get_uri_scheme,\n    is_databricks_acled_artifacts_uri,\n    is_databricks_uri,\n    is_fuse_or_uc_volumes_uri,\n    is_http_uri,\n    is_local_uri,\n    is_valid_dbfs_uri,\n    remove_databricks_profile_info_from_artifact_uri,\n    resolve_uri_if_local,\n)\n\n\ndef test_extract_db_type_from_uri():\n    uri = \"{}://username:password@host:port/database\"\n    for legit_db in DATABASE_ENGINES:\n        assert legit_db == extract_db_type_from_uri(uri.format(legit_db))\n        assert legit_db == get_uri_scheme(uri.format(legit_db))\n\n        with_driver = legit_db + \"+driver-string\"\n        assert legit_db == extract_db_type_from_uri(uri.format(with_driver))\n        assert legit_db == get_uri_scheme(uri.format(with_driver))\n\n    for unsupported_db in [\"a\", \"aa\", \"sql\"]:\n        with pytest.raises(MlflowException, match=\"Invalid database engine\"):\n            extract_db_type_from_uri(unsupported_db)\n\n\n@pytest.mark.parametrize(\n    (\"server_uri\", \"result\"),\n    [\n        (\"databricks://aAbB\", (\"aAbB\", None)),\n        (\"databricks://aAbB/\", (\"aAbB\", None)),\n        (\"databricks://aAbB/path\", (\"aAbB\", None)),\n        (\"databricks://profile:prefix\", (\"profile\", \"prefix\")),\n        (\"databricks://profile:prefix/extra\", (\"profile\", \"prefix\")),\n        (\"nondatabricks://profile:prefix\", (None, None)),\n        (\"databricks://profile\", (\"profile\", None)),\n        (\"databricks://profile/\", (\"profile\", None)),\n        (\"databricks-uc://profile:prefix\", (\"profile\", \"prefix\")),\n        (\"databricks-uc://profile:prefix/extra\", (\"profile\", \"prefix\")),\n        (\"databricks-uc://profile\", (\"profile\", None)),\n        (\"databricks-uc://profile/\", (\"profile\", None)),\n    ],\n)\ndef test_get_db_info_from_uri(server_uri, result):\n    assert get_db_info_from_uri(server_uri) == result\n\n\n@pytest.mark.parametrize(\n    \"server_uri\",\n    [\"databricks:/profile:prefix\", \"databricks:/\", \"databricks://\"],\n)\ndef test_get_db_info_from_uri_errors_no_netloc(server_uri):\n    with pytest.raises(MlflowException, match=\"URI is formatted incorrectly\"):\n        get_db_info_from_uri(server_uri)\n\n\n@pytest.mark.parametrize(\n    \"server_uri\",\n    [\n        \"databricks://profile:prefix:extra\",\n        \"databricks://profile:prefix:extra  \",\n        \"databricks://profile:prefix extra\",\n        \"databricks://profile:prefix  \",\n        \"databricks://profile \",\n        \"databricks://profile:\",\n        \"databricks://profile: \",\n    ],\n)\ndef test_get_db_info_from_uri_errors_invalid_profile(server_uri):\n    with pytest.raises(MlflowException, match=\"Unsupported Databricks profile\"):\n        get_db_info_from_uri(server_uri)\n\n\ndef test_is_local_uri():\n    assert is_local_uri(\"mlruns\")\n    assert is_local_uri(\"./mlruns\")\n    assert is_local_uri(\"file:///foo/mlruns\")\n    assert is_local_uri(\"file:foo/mlruns\")\n    assert is_local_uri(\"file://./mlruns\")\n    assert is_local_uri(\"file://localhost/mlruns\")\n    assert is_local_uri(\"file://localhost:5000/mlruns\")\n    assert is_local_uri(\"file://127.0.0.1/mlruns\")\n    assert is_local_uri(\"file://127.0.0.1:5000/mlruns\")\n\n    assert not is_local_uri(\"file://myhostname/path/to/file\")\n    assert not is_local_uri(\"https://whatever\")\n    assert not is_local_uri(\"http://whatever\")\n    assert not is_local_uri(\"databricks\")\n    assert not is_local_uri(\"databricks:whatever\")\n    assert not is_local_uri(\"databricks://whatever\")\n\n\n@pytest.mark.skipif(not is_windows(), reason=\"Windows-only test\")\ndef test_is_local_uri_windows():\n    assert is_local_uri(\"C:\\\\foo\\\\mlruns\")\n    assert is_local_uri(\"C:/foo/mlruns\")\n    assert is_local_uri(\"file:///C:\\\\foo\\\\mlruns\")\n    assert not is_local_uri(\"\\\\\\\\server\\\\aa\\\\bb\")\n\n\ndef test_is_databricks_uri():\n    assert is_databricks_uri(\"databricks\")\n    assert is_databricks_uri(\"databricks:whatever\")\n    assert is_databricks_uri(\"databricks://whatever\")\n    assert not is_databricks_uri(\"mlruns\")\n    assert not is_databricks_uri(\"http://whatever\")\n\n\ndef test_is_http_uri():\n    assert is_http_uri(\"http://whatever\")\n    assert is_http_uri(\"https://whatever\")\n    assert not is_http_uri(\"file://whatever\")\n    assert not is_http_uri(\"databricks://whatever\")\n    assert not is_http_uri(\"mlruns\")\n\n\ndef validate_append_to_uri_path_test_cases(cases):\n    for input_uri, input_path, expected_output_uri in cases:\n        assert append_to_uri_path(input_uri, input_path) == expected_output_uri\n        assert append_to_uri_path(input_uri, *posixpath.split(input_path)) == expected_output_uri\n\n\ndef test_append_to_uri_path_joins_uri_paths_and_posixpaths_correctly():\n    validate_append_to_uri_path_test_cases(\n        [\n            (\"\", \"path\", \"path\"),\n            (\"\", \"/path\", \"/path\"),\n            (\"path\", \"\", \"path/\"),\n            (\"path\", \"subpath\", \"path/subpath\"),\n            (\"path/\", \"subpath\", \"path/subpath\"),\n            (\"path/\", \"/subpath\", \"path/subpath\"),\n            (\"path\", \"/subpath\", \"path/subpath\"),\n            (\"/path\", \"/subpath\", \"/path/subpath\"),\n            (\"//path\", \"/subpath\", \"//path/subpath\"),\n            (\"///path\", \"/subpath\", \"///path/subpath\"),\n            (\"/path\", \"/subpath/subdir\", \"/path/subpath/subdir\"),\n            (\"file:path\", \"\", \"file:path/\"),\n            (\"file:path/\", \"\", \"file:path/\"),\n            (\"file:path\", \"subpath\", \"file:path/subpath\"),\n            (\"file:path\", \"/subpath\", \"file:path/subpath\"),\n            (\"file:/\", \"\", \"file:///\"),\n            (\"file:/path\", \"/subpath\", \"file:///path/subpath\"),\n            (\"file:///\", \"\", \"file:///\"),\n            (\"file:///\", \"subpath\", \"file:///subpath\"),\n            (\"file:///path\", \"/subpath\", \"file:///path/subpath\"),\n            (\"file:///path/\", \"subpath\", \"file:///path/subpath\"),\n            (\"file:///path\", \"subpath\", \"file:///path/subpath\"),\n            (\"s3://\", \"\", \"s3:\"),\n            (\"s3://\", \"subpath\", \"s3:subpath\"),\n            (\"s3://\", \"/subpath\", \"s3:/subpath\"),\n            (\"s3://host\", \"subpath\", \"s3://host/subpath\"),\n            (\"s3://host\", \"/subpath\", \"s3://host/subpath\"),\n            (\"s3://host/\", \"subpath\", \"s3://host/subpath\"),\n            (\"s3://host/\", \"/subpath\", \"s3://host/subpath\"),\n            (\"s3://host\", \"subpath/subdir\", \"s3://host/subpath/subdir\"),\n        ]\n    )\n\n\ndef test_append_to_uri_path_handles_special_uri_characters_in_posixpaths():\n    \"\"\"\n    Certain characters are treated specially when parsing and interpreting URIs. However, in the\n    case where a URI input for `append_to_uri_path` is simply a POSIX path, these characters should\n    not receive special treatment. This test case verifies that `append_to_uri_path` properly joins\n    POSIX paths containing these characters.\n    \"\"\"\n\n    def create_char_case(special_char):\n        def char_case(*case_args):\n            return tuple([item.format(c=special_char) for item in case_args])\n\n        return char_case\n\n    for special_char in [\n        \".\",\n        \"-\",\n        \"+\",\n        \":\",\n        \"?\",\n        \"@\",\n        \"&\",\n        \"$\",\n        \"%\",\n        \"/\",\n        \"[\",\n        \"]\",\n        \"(\",\n        \")\",\n        \"*\",\n        \"'\",\n        \",\",\n    ]:\n        char_case = create_char_case(special_char)\n        validate_append_to_uri_path_test_cases(\n            [\n                char_case(\"\", \"{c}subpath\", \"{c}subpath\"),\n                char_case(\"\", \"/{c}subpath\", \"/{c}subpath\"),\n                char_case(\"dirwith{c}{c}chars\", \"\", \"dirwith{c}{c}chars/\"),\n                char_case(\"dirwith{c}{c}chars\", \"subpath\", \"dirwith{c}{c}chars/subpath\"),\n                char_case(\"{c}{c}charsdir\", \"\", \"{c}{c}charsdir/\"),\n                char_case(\"/{c}{c}charsdir\", \"\", \"/{c}{c}charsdir/\"),\n                char_case(\"/{c}{c}charsdir\", \"subpath\", \"/{c}{c}charsdir/subpath\"),\n                char_case(\"/{c}{c}charsdir\", \"subpath\", \"/{c}{c}charsdir/subpath\"),\n            ]\n        )\n\n    validate_append_to_uri_path_test_cases(\n        [\n            (\"#?charsdir:\", \":?subpath#\", \"#?charsdir:/:?subpath#\"),\n            (\"/#--+charsdir.//:\", \"/../:?subpath#\", \"/#--+charsdir.//:/../:?subpath#\"),\n            (\"$@''(,\", \")]*%\", \"$@''(,/)]*%\"),\n        ]\n    )\n\n\n@pytest.mark.parametrize(\n    (\"uri\", \"existing_query_params\", \"query_params\", \"expected\"),\n    [\n        (\"https://example.com\", \"\", [(\"key\", \"value\")], \"https://example.com?key=value\"),\n        (\n            \"https://example.com\",\n            \"existing_key=existing_value\",\n            [(\"new_key\", \"new_value\")],\n            \"https://example.com?existing_key=existing_value&new_key=new_value\",\n        ),\n        (\n            \"https://example.com\",\n            \"\",\n            [(\"key1\", \"value1\"), (\"key2\", \"value2\"), (\"key3\", \"value3\")],\n            \"https://example.com?key1=value1&key2=value2&key3=value3\",\n        ),\n        (\n            \"https://example.com\",\n            \"\",\n            [(\"key\", \"value with spaces\"), (\"key2\", \"special#characters\")],\n            \"https://example.com?key=value+with+spaces&key2=special%23characters\",\n        ),\n        (\"\", \"\", [(\"key\", \"value\")], \"?key=value\"),\n        (\"https://example.com\", \"\", [], \"https://example.com\"),\n        (\n            \"https://example.com\",\n            \"\",\n            [(\"key1\", 123), (\"key2\", 456)],\n            \"https://example.com?key1=123&key2=456\",\n        ),\n        (\n            \"https://example.com?existing_key=existing_value\",\n            \"\",\n            [(\"existing_key\", \"new_value\"), (\"existing_key\", \"new_value_2\")],\n            \"https://example.com?existing_key=existing_value&existing_key=new_value&existing_key=new_value_2\",\n        ),\n        (\n            \"s3://bucket/key\",\n            \"prev1=foo&prev2=bar\",\n            [(\"param1\", \"value1\"), (\"param2\", \"value2\")],\n            \"s3://bucket/key?prev1=foo&prev2=bar&param1=value1&param2=value2\",\n        ),\n        (\n            \"s3://bucket/key?existing_param=existing_value\",\n            \"\",\n            [(\"new_param\", \"new_value\")],\n            \"s3://bucket/key?existing_param=existing_value&new_param=new_value\",\n        ),\n    ],\n)\ndef test_append_to_uri_query_params_appends_as_expected(\n    uri, existing_query_params, query_params, expected\n):\n    if existing_query_params:\n        uri += f\"?{existing_query_params}\"\n\n    result = append_to_uri_query_params(uri, *query_params)\n    assert result == expected\n\n\ndef test_append_to_uri_path_preserves_uri_schemes_hosts_queries_and_fragments():\n    validate_append_to_uri_path_test_cases(\n        [\n            (\"dbscheme+dbdriver:\", \"\", \"dbscheme+dbdriver:\"),\n            (\"dbscheme+dbdriver:\", \"subpath\", \"dbscheme+dbdriver:subpath\"),\n            (\"dbscheme+dbdriver:path\", \"subpath\", \"dbscheme+dbdriver:path/subpath\"),\n            (\"dbscheme+dbdriver://host/path\", \"/subpath\", \"dbscheme+dbdriver://host/path/subpath\"),\n            (\"dbscheme+dbdriver:///path\", \"subpath\", \"dbscheme+dbdriver:/path/subpath\"),\n            (\"dbscheme+dbdriver:?somequery\", \"subpath\", \"dbscheme+dbdriver:subpath?somequery\"),\n            (\"dbscheme+dbdriver:?somequery\", \"/subpath\", \"dbscheme+dbdriver:/subpath?somequery\"),\n            (\"dbscheme+dbdriver:/?somequery\", \"subpath\", \"dbscheme+dbdriver:/subpath?somequery\"),\n            (\"dbscheme+dbdriver://?somequery\", \"subpath\", \"dbscheme+dbdriver:subpath?somequery\"),\n            (\"dbscheme+dbdriver:///?somequery\", \"/subpath\", \"dbscheme+dbdriver:/subpath?somequery\"),\n            (\"dbscheme+dbdriver:#somefrag\", \"subpath\", \"dbscheme+dbdriver:subpath#somefrag\"),\n            (\"dbscheme+dbdriver:#somefrag\", \"/subpath\", \"dbscheme+dbdriver:/subpath#somefrag\"),\n            (\"dbscheme+dbdriver:/#somefrag\", \"subpath\", \"dbscheme+dbdriver:/subpath#somefrag\"),\n            (\"dbscheme+dbdriver://#somefrag\", \"subpath\", \"dbscheme+dbdriver:subpath#somefrag\"),\n            (\"dbscheme+dbdriver:///#somefrag\", \"/subpath\", \"dbscheme+dbdriver:/subpath#somefrag\"),\n            (\n                \"dbscheme+dbdriver://root:password?creds=creds\",\n                \"subpath\",\n                \"dbscheme+dbdriver://root:password/subpath?creds=creds\",\n            ),\n            (\n                \"dbscheme+dbdriver://root:password/path/?creds=creds\",\n                \"/subpath/anotherpath\",\n                \"dbscheme+dbdriver://root:password/path/subpath/anotherpath?creds=creds\",\n            ),\n            (\n                \"dbscheme+dbdriver://root:password///path/?creds=creds\",\n                \"subpath/anotherpath\",\n                \"dbscheme+dbdriver://root:password///path/subpath/anotherpath?creds=creds\",\n            ),\n            (\n                \"dbscheme+dbdriver://root:password///path/?creds=creds\",\n                \"/subpath\",\n                \"dbscheme+dbdriver://root:password///path/subpath?creds=creds\",\n            ),\n            (\n                \"dbscheme+dbdriver://root:password#myfragment\",\n                \"/subpath\",\n                \"dbscheme+dbdriver://root:password/subpath#myfragment\",\n            ),\n            (\n                \"dbscheme+dbdriver://root:password//path/#fragmentwith$pecial@\",\n                \"subpath/anotherpath\",\n                \"dbscheme+dbdriver://root:password//path/subpath/anotherpath#fragmentwith$pecial@\",\n            ),\n            (\n                \"dbscheme+dbdriver://root:password@host?creds=creds#fragmentwith$pecial@\",\n                \"subpath\",\n                \"dbscheme+dbdriver://root:password@host/subpath?creds=creds#fragmentwith$pecial@\",\n            ),\n            (\n                \"dbscheme+dbdriver://root:password@host.com/path?creds=creds#*frag@*\",\n                \"subpath/dir\",\n                \"dbscheme+dbdriver://root:password@host.com/path/subpath/dir?creds=creds#*frag@*\",\n            ),\n            (\n                \"dbscheme-dbdriver://root:password@host.com/path?creds=creds#*frag@*\",\n                \"subpath/dir\",\n                \"dbscheme-dbdriver://root:password@host.com/path/subpath/dir?creds=creds#*frag@*\",\n            ),\n            (\n                \"dbscheme+dbdriver://root:password@host.com/path?creds=creds,param=value#*frag@*\",\n                \"subpath/dir\",\n                \"dbscheme+dbdriver://root:password@host.com/path/subpath/dir?\"\n                \"creds=creds,param=value#*frag@*\",\n            ),\n        ]\n    )\n\n\ndef test_extract_and_normalize_path():\n    base_uri = \"databricks/mlflow-tracking/EXP_ID/RUN_ID/artifacts\"\n    assert (\n        extract_and_normalize_path(\"dbfs:databricks/mlflow-tracking/EXP_ID/RUN_ID/artifacts\")\n        == base_uri\n    )\n    assert (\n        extract_and_normalize_path(\"dbfs:/databricks/mlflow-tracking/EXP_ID/RUN_ID/artifacts\")\n        == base_uri\n    )\n    assert (\n        extract_and_normalize_path(\"dbfs:///databricks/mlflow-tracking/EXP_ID/RUN_ID/artifacts\")\n        == base_uri\n    )\n    assert (\n        extract_and_normalize_path(\n            \"dbfs:/databricks///mlflow-tracking///EXP_ID///RUN_ID///artifacts/\"\n        )\n        == base_uri\n    )\n    assert (\n        extract_and_normalize_path(\n            \"dbfs:///databricks///mlflow-tracking//EXP_ID//RUN_ID///artifacts//\"\n        )\n        == base_uri\n    )\n    assert (\n        extract_and_normalize_path(\n            \"dbfs:databricks///mlflow-tracking//EXP_ID//RUN_ID///artifacts//\"\n        )\n        == base_uri\n    )\n\n\ndef test_is_databricks_acled_artifacts_uri():\n    assert is_databricks_acled_artifacts_uri(\n        \"dbfs:databricks/mlflow-tracking/EXP_ID/RUN_ID/artifacts\"\n    )\n    assert is_databricks_acled_artifacts_uri(\n        \"dbfs:/databricks/mlflow-tracking/EXP_ID/RUN_ID/artifacts\"\n    )\n    assert is_databricks_acled_artifacts_uri(\n        \"dbfs:///databricks/mlflow-tracking/EXP_ID/RUN_ID/artifacts\"\n    )\n    assert is_databricks_acled_artifacts_uri(\n        \"dbfs:/databricks///mlflow-tracking///EXP_ID///RUN_ID///artifacts/\"\n    )\n    assert is_databricks_acled_artifacts_uri(\n        \"dbfs:///databricks///mlflow-tracking//EXP_ID//RUN_ID///artifacts//\"\n    )\n    assert is_databricks_acled_artifacts_uri(\n        \"dbfs:databricks///mlflow-tracking//EXP_ID//RUN_ID///artifacts//\"\n    )\n    assert not is_databricks_acled_artifacts_uri(\n        \"dbfs:/databricks/mlflow//EXP_ID//RUN_ID///artifacts//\"\n    )\n\n\ndef _get_databricks_profile_uri_test_cases():\n    # Each test case is (uri, result, result_scheme)\n    test_case_groups = [\n        [\n            # URIs with no databricks profile info -> return None\n            (\"ftp://user:pass@realhost:port/path/to/nowhere\", None, result_scheme),\n            (\"dbfs:/path/to/nowhere\", None, result_scheme),\n            (\"dbfs://nondatabricks/path/to/nowhere\", None, result_scheme),\n            (\"dbfs://incorrect:netloc:format/path/to/nowhere\", None, result_scheme),\n            # URIs with legit databricks profile info\n            (f\"dbfs://{result_scheme}\", result_scheme, result_scheme),\n            (f\"dbfs://{result_scheme}/\", result_scheme, result_scheme),\n            (f\"dbfs://{result_scheme}/path/to/nowhere\", result_scheme, result_scheme),\n            (f\"dbfs://{result_scheme}:port/path/to/nowhere\", result_scheme, result_scheme),\n            (f\"dbfs://@{result_scheme}/path/to/nowhere\", result_scheme, result_scheme),\n            (f\"dbfs://@{result_scheme}:port/path/to/nowhere\", result_scheme, result_scheme),\n            (\n                f\"dbfs://profile@{result_scheme}/path/to/nowhere\",\n                f\"{result_scheme}://profile\",\n                result_scheme,\n            ),\n            (\n                f\"dbfs://profile@{result_scheme}:port/path/to/nowhere\",\n                f\"{result_scheme}://profile\",\n                result_scheme,\n            ),\n            (\n                f\"dbfs://scope:key_prefix@{result_scheme}/path/abc\",\n                f\"{result_scheme}://scope:key_prefix\",\n                result_scheme,\n            ),\n            (\n                f\"dbfs://scope:key_prefix@{result_scheme}:port/path/abc\",\n                f\"{result_scheme}://scope:key_prefix\",\n                result_scheme,\n            ),\n            # Doesn't care about the scheme of the artifact URI\n            (\n                f\"runs://scope:key_prefix@{result_scheme}/path/abc\",\n                f\"{result_scheme}://scope:key_prefix\",\n                result_scheme,\n            ),\n            (\n                f\"models://scope:key_prefix@{result_scheme}/path/abc\",\n                f\"{result_scheme}://scope:key_prefix\",\n                result_scheme,\n            ),\n            (\n                f\"s3://scope:key_prefix@{result_scheme}/path/abc\",\n                f\"{result_scheme}://scope:key_prefix\",\n                result_scheme,\n            ),\n        ]\n        for result_scheme in [\"databricks\", \"databricks-uc\"]\n    ]\n    return [test_case for test_case_group in test_case_groups for test_case in test_case_group]\n\n\n@pytest.mark.parametrize(\n    (\"uri\", \"result\", \"result_scheme\"), _get_databricks_profile_uri_test_cases()\n)\ndef test_get_databricks_profile_uri_from_artifact_uri(uri, result, result_scheme):\n    assert get_databricks_profile_uri_from_artifact_uri(uri, result_scheme=result_scheme) == result\n\n\n@pytest.mark.parametrize(\n    \"uri\",\n    [\n        # Treats secret key prefixes with \":\" to be invalid\n        \"dbfs://incorrect:netloc:format@databricks/path/a\",\n        \"dbfs://scope::key_prefix@databricks/path/abc\",\n        \"dbfs://scope:key_prefix:@databricks/path/abc\",\n    ],\n)\ndef test_get_databricks_profile_uri_from_artifact_uri_error_cases(uri):\n    with pytest.raises(MlflowException, match=\"Unsupported Databricks profile\"):\n        get_databricks_profile_uri_from_artifact_uri(uri)\n\n\n@pytest.mark.parametrize(\n    (\"uri\", \"result\"),\n    [\n        # URIs with no databricks profile info should stay the same\n        (\n            \"ftp://user:pass@realhost:port/path/nowhere\",\n            \"ftp://user:pass@realhost:port/path/nowhere\",\n        ),\n        (\"dbfs:/path/to/nowhere\", \"dbfs:/path/to/nowhere\"),\n        (\"dbfs://nondatabricks/path/to/nowhere\", \"dbfs://nondatabricks/path/to/nowhere\"),\n        (\"dbfs://incorrect:netloc:format/path/\", \"dbfs://incorrect:netloc:format/path/\"),\n        # URIs with legit databricks profile info\n        (\"dbfs://databricks\", \"dbfs:\"),\n        (\"dbfs://databricks/\", \"dbfs:/\"),\n        (\"dbfs://databricks/path/to/nowhere\", \"dbfs:/path/to/nowhere\"),\n        (\"dbfs://databricks:port/path/to/nowhere\", \"dbfs:/path/to/nowhere\"),\n        (\"dbfs://@databricks/path/to/nowhere\", \"dbfs:/path/to/nowhere\"),\n        (\"dbfs://@databricks:port/path/to/nowhere\", \"dbfs:/path/to/nowhere\"),\n        (\"dbfs://profile@databricks/path/to/nowhere\", \"dbfs:/path/to/nowhere\"),\n        (\"dbfs://profile@databricks:port/path/to/nowhere\", \"dbfs:/path/to/nowhere\"),\n        (\"dbfs://scope:key_prefix@databricks/path/abc\", \"dbfs:/path/abc\"),\n        (\"dbfs://scope:key_prefix@databricks:port/path/abc\", \"dbfs:/path/abc\"),\n        # Treats secret key prefixes with \":\" to be valid\n        (\"dbfs://incorrect:netloc:format@databricks/path/to/nowhere\", \"dbfs:/path/to/nowhere\"),\n        # Doesn't care about the scheme of the artifact URI\n        (\"runs://scope:key_prefix@databricks/path/abc\", \"runs:/path/abc\"),\n        (\"models://scope:key_prefix@databricks/path/abc\", \"models:/path/abc\"),\n        (\"s3://scope:key_prefix@databricks/path/abc\", \"s3:/path/abc\"),\n    ],\n)\ndef test_remove_databricks_profile_info_from_artifact_uri(uri, result):\n    assert remove_databricks_profile_info_from_artifact_uri(uri) == result\n\n\n@pytest.mark.parametrize(\n    (\"artifact_uri\", \"profile_uri\", \"result\"),\n    [\n        # test various profile URIs\n        (\"dbfs:/path/a/b\", \"databricks\", \"dbfs://databricks/path/a/b\"),\n        (\"dbfs:/path/a/b/\", \"databricks\", \"dbfs://databricks/path/a/b/\"),\n        (\"dbfs:/path/a/b/\", \"databricks://Profile\", \"dbfs://Profile@databricks/path/a/b/\"),\n        (\"dbfs:/path/a/b/\", \"databricks://profile/\", \"dbfs://profile@databricks/path/a/b/\"),\n        (\"dbfs:/path/a/b/\", \"databricks://scope:key\", \"dbfs://scope:key@databricks/path/a/b/\"),\n        (\n            \"dbfs:/path/a/b/\",\n            \"databricks://scope:key/random_stuff\",\n            \"dbfs://scope:key@databricks/path/a/b/\",\n        ),\n        (\"dbfs:/path/a/b/\", \"nondatabricks://profile\", \"dbfs:/path/a/b/\"),\n        # test various artifact schemes\n        (\"runs:/path/a/b/\", \"databricks://Profile\", \"runs://Profile@databricks/path/a/b/\"),\n        (\"runs:/path/a/b/\", \"nondatabricks://profile\", \"runs:/path/a/b/\"),\n        (\"models:/path/a/b/\", \"databricks://profile\", \"models://profile@databricks/path/a/b/\"),\n        (\"models:/path/a/b/\", \"nondatabricks://Profile\", \"models:/path/a/b/\"),\n        (\"s3:/path/a/b/\", \"databricks://Profile\", \"s3:/path/a/b/\"),\n        (\"s3:/path/a/b/\", \"nondatabricks://profile\", \"s3:/path/a/b/\"),\n        (\"ftp:/path/a/b/\", \"databricks://profile\", \"ftp:/path/a/b/\"),\n        (\"ftp:/path/a/b/\", \"nondatabricks://Profile\", \"ftp:/path/a/b/\"),\n        # test artifact URIs already with authority\n        (\"ftp://user:pass@host:port/a/b\", \"databricks://Profile\", \"ftp://user:pass@host:port/a/b\"),\n        (\"ftp://user:pass@host:port/a/b\", \"nothing://Profile\", \"ftp://user:pass@host:port/a/b\"),\n        (\"dbfs://databricks\", \"databricks://OtherProfile\", \"dbfs://databricks\"),\n        (\"dbfs://databricks\", \"nondatabricks://Profile\", \"dbfs://databricks\"),\n        (\"dbfs://databricks/path/a/b\", \"databricks://OtherProfile\", \"dbfs://databricks/path/a/b\"),\n        (\"dbfs://databricks/path/a/b\", \"nondatabricks://Profile\", \"dbfs://databricks/path/a/b\"),\n        (\"dbfs://@databricks/path/a/b\", \"databricks://OtherProfile\", \"dbfs://@databricks/path/a/b\"),\n        (\"dbfs://@databricks/path/a/b\", \"nondatabricks://Profile\", \"dbfs://@databricks/path/a/b\"),\n        (\n            \"dbfs://profile@databricks/pp\",\n            \"databricks://OtherProfile\",\n            \"dbfs://profile@databricks/pp\",\n        ),\n        (\n            \"dbfs://profile@databricks/path\",\n            \"databricks://profile\",\n            \"dbfs://profile@databricks/path\",\n        ),\n        (\n            \"dbfs://profile@databricks/path\",\n            \"nondatabricks://Profile\",\n            \"dbfs://profile@databricks/path\",\n        ),\n    ],\n)\ndef test_add_databricks_profile_info_to_artifact_uri(artifact_uri, profile_uri, result):\n    assert add_databricks_profile_info_to_artifact_uri(artifact_uri, profile_uri) == result\n\n\n@pytest.mark.parametrize(\n    (\"artifact_uri\", \"profile_uri\"),\n    [\n        (\"dbfs:/path/a/b\", \"databricks://not:legit:auth\"),\n        (\"dbfs:/path/a/b/\", \"databricks://scope::key\"),\n        (\"dbfs:/path/a/b/\", \"databricks://scope:key:/\"),\n        (\"dbfs:/path/a/b/\", \"databricks://scope:key \"),\n    ],\n)\ndef test_add_databricks_profile_info_to_artifact_uri_errors(artifact_uri, profile_uri):\n    with pytest.raises(MlflowException, match=\"Unsupported Databricks profile\"):\n        add_databricks_profile_info_to_artifact_uri(artifact_uri, profile_uri)\n\n\n@pytest.mark.parametrize(\n    (\"uri\", \"result\"),\n    [\n        (\"dbfs:/path/a/b\", True),\n        (\"dbfs://databricks/a/b\", True),\n        (\"dbfs://@databricks/a/b\", True),\n        (\"dbfs://profile@databricks/a/b\", True),\n        (\"dbfs://scope:key@databricks/a/b\", True),\n        (\"dbfs://scope:key:@databricks/a/b\", False),\n        (\"dbfs://scope::key@databricks/a/b\", False),\n        (\"dbfs://profile@notdatabricks/a/b\", False),\n        (\"dbfs://scope:key@notdatabricks/a/b\", False),\n        (\"dbfs://scope:key/a/b\", False),\n        (\"dbfs://notdatabricks/a/b\", False),\n        (\"s3:/path/a/b\", False),\n        (\"ftp://user:pass@host:port/path/a/b\", False),\n        (\"ftp://user:pass@databricks/path/a/b\", False),\n    ],\n)\ndef test_is_valid_dbfs_uri(uri, result):\n    assert is_valid_dbfs_uri(uri) == result\n\n\n@pytest.mark.parametrize(\n    (\"uri\", \"result\"),\n    [\n        (\"/tmp/path\", \"/dbfs/tmp/path\"),\n        (\"dbfs:/path\", \"/dbfs/path\"),\n        (\"dbfs:/path/a/b\", \"/dbfs/path/a/b\"),\n        (\"dbfs:/dbfs/123/abc\", \"/dbfs/dbfs/123/abc\"),\n    ],\n)\ndef test_dbfs_hdfs_uri_to_fuse_path(uri, result):\n    assert dbfs_hdfs_uri_to_fuse_path(uri) == result\n\n\n@pytest.mark.parametrize(\n    \"path\",\n    [\"some/relative/local/path\", \"s3:/some/s3/path\", \"C:/cool/windows/path\"],\n)\ndef test_dbfs_hdfs_uri_to_fuse_path_raises(path):\n    with pytest.raises(MlflowException, match=\"did not start with expected DBFS URI prefix\"):\n        dbfs_hdfs_uri_to_fuse_path(path)\n\n\ndef _assert_resolve_uri_if_local(input_uri, expected_uri):\n    cwd = pathlib.Path.cwd().as_posix()\n    drive = pathlib.Path.cwd().drive\n    if is_windows():\n        cwd = f\"/{cwd}\"\n        drive = f\"{drive}/\"\n    assert resolve_uri_if_local(input_uri) == expected_uri.format(cwd=cwd, drive=drive)\n\n\n@pytest.mark.skipif(is_windows(), reason=\"This test fails on Windows\")\n@pytest.mark.parametrize(\n    (\"input_uri\", \"expected_uri\"),\n    [\n        (\"my/path\", \"{cwd}/my/path\"),\n        (\"#my/path?a=b\", \"{cwd}/#my/path?a=b\"),\n        (\"file://myhostname/my/path\", \"file://myhostname/my/path\"),\n        (\"file:///my/path\", \"file:///{drive}my/path\"),\n        (\"file:my/path\", \"file://{cwd}/my/path\"),\n        (\"/home/my/path\", \"/home/my/path\"),\n        (\"dbfs://databricks/a/b\", \"dbfs://databricks/a/b\"),\n        (\"s3://host/my/path\", \"s3://host/my/path\"),\n    ],\n)\ndef test_resolve_uri_if_local(input_uri, expected_uri):\n    _assert_resolve_uri_if_local(input_uri, expected_uri)\n\n\n@pytest.mark.skipif(not is_windows(), reason=\"This test only passes on Windows\")\n@pytest.mark.parametrize(\n    (\"input_uri\", \"expected_uri\"),\n    [\n        (\"my/path\", \"file://{cwd}/my/path\"),\n        (\"#my/path?a=b\", \"file://{cwd}/#my/path?a=b\"),\n        (\"file://myhostname/my/path\", \"file://myhostname/my/path\"),\n        (\"file:///my/path\", \"file:///{drive}my/path\"),\n        (\"file:my/path\", \"file://{cwd}/my/path\"),\n        (\"/home/my/path\", \"file:///{drive}home/my/path\"),\n        (\"dbfs://databricks/a/b\", \"dbfs://databricks/a/b\"),\n        (\"s3://host/my/path\", \"s3://host/my/path\"),\n    ],\n)\ndef test_resolve_uri_if_local_on_windows(input_uri, expected_uri):\n    _assert_resolve_uri_if_local(input_uri, expected_uri)\n\n\n@pytest.mark.parametrize(\n    \"uri\",\n    [\n        \"/dbfs/my_path\",\n        \"dbfs:/my_path\",\n        \"/Volumes/my_path\",\n        \"/.fuse-mounts/my_path\",\n        \"//dbfs////my_path\",\n        \"///Volumes/\",\n        \"dbfs://my///path\",\n    ],\n)\ndef test_correctly_detect_fuse_and_uc_uris(uri):\n    assert is_fuse_or_uc_volumes_uri(uri)\n\n\n@pytest.mark.parametrize(\n    \"uri\",\n    [\n        \"/My_Volumes/my_path\",\n        \"s3a:/my_path\",\n        \"Volumes/my_path\",\n        \"Volume:/my_path\",\n        \"dbfs/my_path\",\n        \"/fuse-mounts/my_path\",\n    ],\n)\ndef test_negative_detection(uri):\n    assert not is_fuse_or_uc_volumes_uri(uri)\n"], "fixing_code": ["import os\nimport pathlib\nimport posixpath\nimport re\nimport urllib.parse\nimport uuid\nfrom typing import Any, Tuple\n\nfrom mlflow.exceptions import MlflowException\nfrom mlflow.protos.databricks_pb2 import INVALID_PARAMETER_VALUE\nfrom mlflow.store.db.db_types import DATABASE_ENGINES\nfrom mlflow.utils.os import is_windows\nfrom mlflow.utils.validation import _validate_db_type_string\n\n_INVALID_DB_URI_MSG = (\n    \"Please refer to https://mlflow.org/docs/latest/tracking.html#storage for \"\n    \"format specifications.\"\n)\n\n_DBFS_FUSE_PREFIX = \"/dbfs/\"\n_DBFS_HDFS_URI_PREFIX = \"dbfs:/\"\n_UC_VOLUMES_URI_PREFIX = \"/Volumes/\"\n_UC_DBFS_SYMLINK_PREFIX = \"/.fuse-mounts/\"\n_DATABRICKS_UNITY_CATALOG_SCHEME = \"databricks-uc\"\n\n\ndef is_local_uri(uri, is_tracking_or_registry_uri=True):\n    \"\"\"\n    Returns true if the specified URI is a local file path (/foo or file:/foo).\n\n    :param uri: The URI.\n    :param is_tracking_uri: Whether or not the specified URI is an MLflow Tracking or MLflow\n                            Model Registry URI. Examples of other URIs are MLflow artifact URIs,\n                            filesystem paths, etc.\n    \"\"\"\n    if uri == \"databricks\" and is_tracking_or_registry_uri:\n        return False\n\n    if is_windows() and uri.startswith(\"\\\\\\\\\"):\n        # windows network drive path looks like: \"\\\\<server name>\\path\\...\"\n        return False\n\n    parsed_uri = urllib.parse.urlparse(uri)\n    scheme = parsed_uri.scheme\n    if scheme == \"\":\n        return True\n\n    if parsed_uri.hostname and not (\n        parsed_uri.hostname == \".\"\n        or parsed_uri.hostname.startswith(\"localhost\")\n        or parsed_uri.hostname.startswith(\"127.0.0.1\")\n    ):\n        return False\n\n    if scheme == \"file\":\n        return True\n\n    if is_windows() and len(scheme) == 1 and scheme.lower() == pathlib.Path(uri).drive.lower()[0]:\n        return True\n\n    return False\n\n\ndef is_file_uri(uri):\n    return urllib.parse.urlparse(uri).scheme == \"file\"\n\n\ndef is_http_uri(uri):\n    scheme = urllib.parse.urlparse(uri).scheme\n    return scheme == \"http\" or scheme == \"https\"\n\n\ndef is_databricks_uri(uri):\n    \"\"\"\n    Databricks URIs look like 'databricks' (default profile) or 'databricks://profile'\n    or 'databricks://secret_scope:secret_key_prefix'.\n    \"\"\"\n    scheme = urllib.parse.urlparse(uri).scheme\n    return scheme == \"databricks\" or uri == \"databricks\"\n\n\ndef is_fuse_or_uc_volumes_uri(uri):\n    \"\"\"\n    Validates whether a provided URI is directed to a FUSE mount point or a UC volumes mount point.\n    Multiple directory paths are collapsed into a single designator for root path validation.\n    example:\n    \"////Volumes/\" will resolve to \"/Volumes/\" for validation purposes.\n    \"\"\"\n    resolved_uri = re.sub(\"/+\", \"/\", uri)\n    return any(\n        resolved_uri.startswith(x)\n        for x in [\n            _DBFS_FUSE_PREFIX,\n            _DBFS_HDFS_URI_PREFIX,\n            _UC_VOLUMES_URI_PREFIX,\n            _UC_DBFS_SYMLINK_PREFIX,\n        ]\n    )\n\n\ndef is_databricks_unity_catalog_uri(uri):\n    scheme = urllib.parse.urlparse(uri).scheme\n    return scheme == _DATABRICKS_UNITY_CATALOG_SCHEME or uri == _DATABRICKS_UNITY_CATALOG_SCHEME\n\n\ndef construct_db_uri_from_profile(profile):\n    if profile:\n        return \"databricks://\" + profile\n\n\n# Both scope and key_prefix should not contain special chars for URIs, like '/'\n# and ':'.\ndef validate_db_scope_prefix_info(scope, prefix):\n    for c in [\"/\", \":\", \" \"]:\n        if c in scope:\n            raise MlflowException(\n                f\"Unsupported Databricks profile name: {scope}.\"\n                f\" Profile names cannot contain '{c}'.\"\n            )\n        if prefix and c in prefix:\n            raise MlflowException(\n                f\"Unsupported Databricks profile key prefix: {prefix}.\"\n                f\" Key prefixes cannot contain '{c}'.\"\n            )\n    if prefix is not None and prefix.strip() == \"\":\n        raise MlflowException(\n            f\"Unsupported Databricks profile key prefix: '{prefix}'.\"\n            \" Key prefixes cannot be empty.\"\n        )\n\n\ndef get_db_info_from_uri(uri):\n    \"\"\"\n    Get the Databricks profile specified by the tracking URI (if any), otherwise\n    returns None.\n    \"\"\"\n    parsed_uri = urllib.parse.urlparse(uri)\n    if parsed_uri.scheme == \"databricks\" or parsed_uri.scheme == _DATABRICKS_UNITY_CATALOG_SCHEME:\n        # netloc should not be an empty string unless URI is formatted incorrectly.\n        if parsed_uri.netloc == \"\":\n            raise MlflowException(\n                f\"URI is formatted incorrectly: no netloc in URI '{uri}'.\"\n                \" This may be the case if there is only one slash in the URI.\"\n            )\n        profile_tokens = parsed_uri.netloc.split(\":\")\n        parsed_scope = profile_tokens[0]\n        if len(profile_tokens) == 1:\n            parsed_key_prefix = None\n        elif len(profile_tokens) == 2:\n            parsed_key_prefix = profile_tokens[1]\n        else:\n            # parse the content before the first colon as the profile.\n            parsed_key_prefix = \":\".join(profile_tokens[1:])\n        validate_db_scope_prefix_info(parsed_scope, parsed_key_prefix)\n        return parsed_scope, parsed_key_prefix\n    return None, None\n\n\ndef get_databricks_profile_uri_from_artifact_uri(uri, result_scheme=\"databricks\"):\n    \"\"\"\n    Retrieves the netloc portion of the URI as a ``databricks://`` or `databricks-uc://` URI,\n    if it is a proper Databricks profile specification, e.g.\n    ``profile@databricks`` or ``secret_scope:key_prefix@databricks``.\n    \"\"\"\n    parsed = urllib.parse.urlparse(uri)\n    if not parsed.netloc or parsed.hostname != result_scheme:\n        return None\n    if not parsed.username:  # no profile or scope:key\n        return result_scheme  # the default tracking/registry URI\n    validate_db_scope_prefix_info(parsed.username, parsed.password)\n    key_prefix = \":\" + parsed.password if parsed.password else \"\"\n    return f\"{result_scheme}://\" + parsed.username + key_prefix\n\n\ndef remove_databricks_profile_info_from_artifact_uri(artifact_uri):\n    \"\"\"\n    Only removes the netloc portion of the URI if it is a Databricks\n    profile specification, e.g.\n    ``profile@databricks`` or ``secret_scope:key_prefix@databricks``.\n    \"\"\"\n    parsed = urllib.parse.urlparse(artifact_uri)\n    if not parsed.netloc or parsed.hostname != \"databricks\":\n        return artifact_uri\n    return urllib.parse.urlunparse(parsed._replace(netloc=\"\"))\n\n\ndef add_databricks_profile_info_to_artifact_uri(artifact_uri, databricks_profile_uri):\n    \"\"\"\n    Throws an exception if ``databricks_profile_uri`` is not valid.\n    \"\"\"\n    if not databricks_profile_uri or not is_databricks_uri(databricks_profile_uri):\n        return artifact_uri\n    artifact_uri_parsed = urllib.parse.urlparse(artifact_uri)\n    # Do not overwrite the authority section if there is already one\n    if artifact_uri_parsed.netloc:\n        return artifact_uri\n\n    scheme = artifact_uri_parsed.scheme\n    if scheme == \"dbfs\" or scheme == \"runs\" or scheme == \"models\":\n        if databricks_profile_uri == \"databricks\":\n            netloc = \"databricks\"\n        else:\n            (profile, key_prefix) = get_db_info_from_uri(databricks_profile_uri)\n            prefix = \":\" + key_prefix if key_prefix else \"\"\n            netloc = profile + prefix + \"@databricks\"\n        new_parsed = artifact_uri_parsed._replace(netloc=netloc)\n        return urllib.parse.urlunparse(new_parsed)\n    else:\n        return artifact_uri\n\n\ndef extract_db_type_from_uri(db_uri):\n    \"\"\"\n    Parse the specified DB URI to extract the database type. Confirm the database type is\n    supported. If a driver is specified, confirm it passes a plausible regex.\n    \"\"\"\n    scheme = urllib.parse.urlparse(db_uri).scheme\n    scheme_plus_count = scheme.count(\"+\")\n\n    if scheme_plus_count == 0:\n        db_type = scheme\n    elif scheme_plus_count == 1:\n        db_type, _ = scheme.split(\"+\")\n    else:\n        error_msg = f\"Invalid database URI: '{db_uri}'. {_INVALID_DB_URI_MSG}\"\n        raise MlflowException(error_msg, INVALID_PARAMETER_VALUE)\n\n    _validate_db_type_string(db_type)\n\n    return db_type\n\n\ndef get_uri_scheme(uri_or_path):\n    scheme = urllib.parse.urlparse(uri_or_path).scheme\n    if any(scheme.lower().startswith(db) for db in DATABASE_ENGINES):\n        return extract_db_type_from_uri(uri_or_path)\n    return scheme\n\n\ndef extract_and_normalize_path(uri):\n    parsed_uri_path = urllib.parse.urlparse(uri).path\n    normalized_path = posixpath.normpath(parsed_uri_path)\n    return normalized_path.lstrip(\"/\")\n\n\ndef append_to_uri_path(uri, *paths):\n    \"\"\"\n    Appends the specified POSIX `paths` to the path component of the specified `uri`.\n\n    :param uri: The input URI, represented as a string.\n    :param paths: The POSIX paths to append to the specified `uri`'s path component.\n    :return: A new URI with a path component consisting of the specified `paths` appended to\n             the path component of the specified `uri`.\n\n    >>> uri1 = \"s3://root/base/path?param=value\"\n    >>> uri1 = append_to_uri_path(uri1, \"some/subpath\", \"/anotherpath\")\n    >>> assert uri1 == \"s3://root/base/path/some/subpath/anotherpath?param=value\"\n    >>> uri2 = \"a/posix/path\"\n    >>> uri2 = append_to_uri_path(uri2, \"/some\", \"subpath\")\n    >>> assert uri2 == \"a/posixpath/some/subpath\"\n    \"\"\"\n    path = \"\"\n    for subpath in paths:\n        path = _join_posixpaths_and_append_absolute_suffixes(path, subpath)\n\n    parsed_uri = urllib.parse.urlparse(uri)\n    if len(parsed_uri.scheme) == 0:\n        # If the input URI does not define a scheme, we assume that it is a POSIX path\n        # and join it with the specified input paths\n        return _join_posixpaths_and_append_absolute_suffixes(uri, path)\n\n    prefix = \"\"\n    if not parsed_uri.path.startswith(\"/\"):\n        # For certain URI schemes (e.g., \"file:\"), urllib's unparse routine does\n        # not preserve the relative URI path component properly. In certain cases,\n        # urlunparse converts relative paths to absolute paths. We introduce this logic\n        # to circumvent urlunparse's erroneous conversion\n        prefix = parsed_uri.scheme + \":\"\n        parsed_uri = parsed_uri._replace(scheme=\"\")\n\n    new_uri_path = _join_posixpaths_and_append_absolute_suffixes(parsed_uri.path, path)\n    new_parsed_uri = parsed_uri._replace(path=new_uri_path)\n    return prefix + urllib.parse.urlunparse(new_parsed_uri)\n\n\ndef append_to_uri_query_params(uri, *query_params: Tuple[str, Any]) -> str:\n    \"\"\"\n    Appends the specified query parameters to an existing URI.\n\n    :param uri: The URI to which to append query parameters.\n    :param query_params: Query parameters to append. Each parameter should\n                         be a 2-element tuple. For example, ``(\"key\", \"value\")``.\n    \"\"\"\n    parsed_uri = urllib.parse.urlparse(uri)\n    parsed_query = urllib.parse.parse_qsl(parsed_uri.query)\n    new_parsed_query = parsed_query + list(query_params)\n    new_query = urllib.parse.urlencode(new_parsed_query)\n    new_parsed_uri = parsed_uri._replace(query=new_query)\n    return urllib.parse.urlunparse(new_parsed_uri)\n\n\ndef _join_posixpaths_and_append_absolute_suffixes(prefix_path, suffix_path):\n    \"\"\"\n    Joins the POSIX path `prefix_path` with the POSIX path `suffix_path`. Unlike posixpath.join(),\n    if `suffix_path` is an absolute path, it is appended to prefix_path.\n\n    >>> result1 = _join_posixpaths_and_append_absolute_suffixes(\"relpath1\", \"relpath2\")\n    >>> assert result1 == \"relpath1/relpath2\"\n    >>> result2 = _join_posixpaths_and_append_absolute_suffixes(\"relpath\", \"/absolutepath\")\n    >>> assert result2 == \"relpath/absolutepath\"\n    >>> result3 = _join_posixpaths_and_append_absolute_suffixes(\"/absolutepath\", \"relpath\")\n    >>> assert result3 == \"/absolutepath/relpath\"\n    >>> result4 = _join_posixpaths_and_append_absolute_suffixes(\"/absolutepath1\", \"/absolutepath2\")\n    >>> assert result4 == \"/absolutepath1/absolutepath2\"\n    \"\"\"\n    if len(prefix_path) == 0:\n        return suffix_path\n\n    # If the specified prefix path is non-empty, we must relativize the suffix path by removing\n    # the leading slash, if present. Otherwise, posixpath.join() would omit the prefix from the\n    # joined path\n    suffix_path = suffix_path.lstrip(posixpath.sep)\n    return posixpath.join(prefix_path, suffix_path)\n\n\ndef is_databricks_acled_artifacts_uri(artifact_uri):\n    _ACLED_ARTIFACT_URI = \"databricks/mlflow-tracking/\"\n    artifact_uri_path = extract_and_normalize_path(artifact_uri)\n    return artifact_uri_path.startswith(_ACLED_ARTIFACT_URI)\n\n\ndef is_databricks_model_registry_artifacts_uri(artifact_uri):\n    _MODEL_REGISTRY_ARTIFACT_URI = \"databricks/mlflow-registry/\"\n    artifact_uri_path = extract_and_normalize_path(artifact_uri)\n    return artifact_uri_path.startswith(_MODEL_REGISTRY_ARTIFACT_URI)\n\n\ndef is_valid_dbfs_uri(uri):\n    parsed = urllib.parse.urlparse(uri)\n    if parsed.scheme != \"dbfs\":\n        return False\n    try:\n        db_profile_uri = get_databricks_profile_uri_from_artifact_uri(uri)\n    except MlflowException:\n        db_profile_uri = None\n    return not parsed.netloc or db_profile_uri is not None\n\n\ndef dbfs_hdfs_uri_to_fuse_path(dbfs_uri):\n    \"\"\"\n    Converts the provided DBFS URI into a DBFS FUSE path\n    :param dbfs_uri: A DBFS URI like \"dbfs:/my-directory\". Can also be a scheme-less URI like\n                     \"/my-directory\" if running in an environment where the default HDFS filesystem\n                     is \"dbfs:/\" (e.g. Databricks)\n    :return A DBFS FUSE-style path, e.g. \"/dbfs/my-directory\"\n    \"\"\"\n    if not is_valid_dbfs_uri(dbfs_uri) and dbfs_uri == posixpath.abspath(dbfs_uri):\n        # Convert posixpaths (e.g. \"/tmp/mlflow\") to DBFS URIs by adding \"dbfs:/\" as a prefix\n        dbfs_uri = \"dbfs:\" + dbfs_uri\n    if not dbfs_uri.startswith(_DBFS_HDFS_URI_PREFIX):\n        raise MlflowException(\n            f\"Path '{dbfs_uri}' did not start with expected DBFS URI \"\n            f\"prefix '{_DBFS_HDFS_URI_PREFIX}'\",\n        )\n\n    return _DBFS_FUSE_PREFIX + dbfs_uri[len(_DBFS_HDFS_URI_PREFIX) :]\n\n\ndef resolve_uri_if_local(local_uri):\n    \"\"\"\n    if `local_uri` is passed in as a relative local path, this function\n    resolves it to absolute path relative to current working directory.\n\n    :param local_uri: Relative or absolute path or local file uri\n\n    :return: a fully-formed absolute uri path or an absolute filesystem path\n    \"\"\"\n    from mlflow.utils.file_utils import local_file_uri_to_path\n\n    if local_uri is not None and is_local_uri(local_uri):\n        scheme = get_uri_scheme(local_uri)\n        cwd = pathlib.Path.cwd()\n        local_path = local_file_uri_to_path(local_uri)\n        if not pathlib.Path(local_path).is_absolute():\n            if scheme == \"\":\n                if is_windows():\n                    return urllib.parse.urlunsplit(\n                        (\n                            \"file\",\n                            None,\n                            cwd.joinpath(local_path).as_posix(),\n                            None,\n                            None,\n                        )\n                    )\n                return cwd.joinpath(local_path).as_posix()\n            local_uri_split = urllib.parse.urlsplit(local_uri)\n            return urllib.parse.urlunsplit(\n                (\n                    local_uri_split.scheme,\n                    None,\n                    cwd.joinpath(local_path).as_posix(),\n                    local_uri_split.query,\n                    local_uri_split.fragment,\n                )\n            )\n    return local_uri\n\n\ndef generate_tmp_dfs_path(dfs_tmp):\n    return posixpath.join(dfs_tmp, str(uuid.uuid4()))\n\n\ndef join_paths(*paths: str) -> str:\n    stripped = (p.strip(\"/\") for p in paths)\n    return \"/\" + posixpath.normpath(posixpath.join(*stripped))\n\n\n_OS_ALT_SEPS = [sep for sep in [os.sep, os.path.altsep] if sep is not None and sep != \"/\"]\n\n\ndef validate_path_is_safe(path):\n    \"\"\"\n    Validates that the specified path is safe to join with a trusted prefix. This is a security\n    measure to prevent path traversal attacks.\n    A valid path should:\n        not contain separators other than '/'\n        not contain .. to navigate to parent dir in path\n        not be an absolute path\n    \"\"\"\n    from mlflow.utils.file_utils import local_file_uri_to_path\n\n    exc = MlflowException(f\"Invalid path: {path}\", error_code=INVALID_PARAMETER_VALUE)\n    if any((s in path) for s in (\"#\", \"%23\")):\n        raise exc\n\n    if is_file_uri(path):\n        path = local_file_uri_to_path(path)\n    if (\n        any((s in path) for s in _OS_ALT_SEPS)\n        or \"..\" in path.split(\"/\")\n        or pathlib.PureWindowsPath(path).is_absolute()\n        or pathlib.PurePosixPath(path).is_absolute()\n        or (is_windows() and len(path) >= 2 and path[1] == \":\")\n    ):\n        raise exc\n", "import pathlib\nimport posixpath\n\nimport pytest\n\nfrom mlflow.exceptions import MlflowException\nfrom mlflow.store.db.db_types import DATABASE_ENGINES\nfrom mlflow.utils.os import is_windows\nfrom mlflow.utils.uri import (\n    add_databricks_profile_info_to_artifact_uri,\n    append_to_uri_path,\n    append_to_uri_query_params,\n    dbfs_hdfs_uri_to_fuse_path,\n    extract_and_normalize_path,\n    extract_db_type_from_uri,\n    get_databricks_profile_uri_from_artifact_uri,\n    get_db_info_from_uri,\n    get_uri_scheme,\n    is_databricks_acled_artifacts_uri,\n    is_databricks_uri,\n    is_fuse_or_uc_volumes_uri,\n    is_http_uri,\n    is_local_uri,\n    is_valid_dbfs_uri,\n    remove_databricks_profile_info_from_artifact_uri,\n    resolve_uri_if_local,\n)\n\n\ndef test_extract_db_type_from_uri():\n    uri = \"{}://username:password@host:port/database\"\n    for legit_db in DATABASE_ENGINES:\n        assert legit_db == extract_db_type_from_uri(uri.format(legit_db))\n        assert legit_db == get_uri_scheme(uri.format(legit_db))\n\n        with_driver = legit_db + \"+driver-string\"\n        assert legit_db == extract_db_type_from_uri(uri.format(with_driver))\n        assert legit_db == get_uri_scheme(uri.format(with_driver))\n\n    for unsupported_db in [\"a\", \"aa\", \"sql\"]:\n        with pytest.raises(MlflowException, match=\"Invalid database engine\"):\n            extract_db_type_from_uri(unsupported_db)\n\n\n@pytest.mark.parametrize(\n    (\"server_uri\", \"result\"),\n    [\n        (\"databricks://aAbB\", (\"aAbB\", None)),\n        (\"databricks://aAbB/\", (\"aAbB\", None)),\n        (\"databricks://aAbB/path\", (\"aAbB\", None)),\n        (\"databricks://profile:prefix\", (\"profile\", \"prefix\")),\n        (\"databricks://profile:prefix/extra\", (\"profile\", \"prefix\")),\n        (\"nondatabricks://profile:prefix\", (None, None)),\n        (\"databricks://profile\", (\"profile\", None)),\n        (\"databricks://profile/\", (\"profile\", None)),\n        (\"databricks-uc://profile:prefix\", (\"profile\", \"prefix\")),\n        (\"databricks-uc://profile:prefix/extra\", (\"profile\", \"prefix\")),\n        (\"databricks-uc://profile\", (\"profile\", None)),\n        (\"databricks-uc://profile/\", (\"profile\", None)),\n    ],\n)\ndef test_get_db_info_from_uri(server_uri, result):\n    assert get_db_info_from_uri(server_uri) == result\n\n\n@pytest.mark.parametrize(\n    \"server_uri\",\n    [\"databricks:/profile:prefix\", \"databricks:/\", \"databricks://\"],\n)\ndef test_get_db_info_from_uri_errors_no_netloc(server_uri):\n    with pytest.raises(MlflowException, match=\"URI is formatted incorrectly\"):\n        get_db_info_from_uri(server_uri)\n\n\n@pytest.mark.parametrize(\n    \"server_uri\",\n    [\n        \"databricks://profile:prefix:extra\",\n        \"databricks://profile:prefix:extra  \",\n        \"databricks://profile:prefix extra\",\n        \"databricks://profile:prefix  \",\n        \"databricks://profile \",\n        \"databricks://profile:\",\n        \"databricks://profile: \",\n    ],\n)\ndef test_get_db_info_from_uri_errors_invalid_profile(server_uri):\n    with pytest.raises(MlflowException, match=\"Unsupported Databricks profile\"):\n        get_db_info_from_uri(server_uri)\n\n\ndef test_is_local_uri():\n    assert is_local_uri(\"mlruns\")\n    assert is_local_uri(\"./mlruns\")\n    assert is_local_uri(\"file:///foo/mlruns\")\n    assert is_local_uri(\"file:foo/mlruns\")\n    assert is_local_uri(\"file://./mlruns\")\n    assert is_local_uri(\"file://localhost/mlruns\")\n    assert is_local_uri(\"file://localhost:5000/mlruns\")\n    assert is_local_uri(\"file://127.0.0.1/mlruns\")\n    assert is_local_uri(\"file://127.0.0.1:5000/mlruns\")\n    assert is_local_uri(\"//proc/self/root\")\n    assert is_local_uri(\"/proc/self/root\")\n\n    assert not is_local_uri(\"file://myhostname/path/to/file\")\n    assert not is_local_uri(\"https://whatever\")\n    assert not is_local_uri(\"http://whatever\")\n    assert not is_local_uri(\"databricks\")\n    assert not is_local_uri(\"databricks:whatever\")\n    assert not is_local_uri(\"databricks://whatever\")\n\n\n@pytest.mark.skipif(not is_windows(), reason=\"Windows-only test\")\ndef test_is_local_uri_windows():\n    assert is_local_uri(\"C:\\\\foo\\\\mlruns\")\n    assert is_local_uri(\"C:/foo/mlruns\")\n    assert is_local_uri(\"file:///C:\\\\foo\\\\mlruns\")\n    assert not is_local_uri(\"\\\\\\\\server\\\\aa\\\\bb\")\n\n\ndef test_is_databricks_uri():\n    assert is_databricks_uri(\"databricks\")\n    assert is_databricks_uri(\"databricks:whatever\")\n    assert is_databricks_uri(\"databricks://whatever\")\n    assert not is_databricks_uri(\"mlruns\")\n    assert not is_databricks_uri(\"http://whatever\")\n\n\ndef test_is_http_uri():\n    assert is_http_uri(\"http://whatever\")\n    assert is_http_uri(\"https://whatever\")\n    assert not is_http_uri(\"file://whatever\")\n    assert not is_http_uri(\"databricks://whatever\")\n    assert not is_http_uri(\"mlruns\")\n\n\ndef validate_append_to_uri_path_test_cases(cases):\n    for input_uri, input_path, expected_output_uri in cases:\n        assert append_to_uri_path(input_uri, input_path) == expected_output_uri\n        assert append_to_uri_path(input_uri, *posixpath.split(input_path)) == expected_output_uri\n\n\ndef test_append_to_uri_path_joins_uri_paths_and_posixpaths_correctly():\n    validate_append_to_uri_path_test_cases(\n        [\n            (\"\", \"path\", \"path\"),\n            (\"\", \"/path\", \"/path\"),\n            (\"path\", \"\", \"path/\"),\n            (\"path\", \"subpath\", \"path/subpath\"),\n            (\"path/\", \"subpath\", \"path/subpath\"),\n            (\"path/\", \"/subpath\", \"path/subpath\"),\n            (\"path\", \"/subpath\", \"path/subpath\"),\n            (\"/path\", \"/subpath\", \"/path/subpath\"),\n            (\"//path\", \"/subpath\", \"//path/subpath\"),\n            (\"///path\", \"/subpath\", \"///path/subpath\"),\n            (\"/path\", \"/subpath/subdir\", \"/path/subpath/subdir\"),\n            (\"file:path\", \"\", \"file:path/\"),\n            (\"file:path/\", \"\", \"file:path/\"),\n            (\"file:path\", \"subpath\", \"file:path/subpath\"),\n            (\"file:path\", \"/subpath\", \"file:path/subpath\"),\n            (\"file:/\", \"\", \"file:///\"),\n            (\"file:/path\", \"/subpath\", \"file:///path/subpath\"),\n            (\"file:///\", \"\", \"file:///\"),\n            (\"file:///\", \"subpath\", \"file:///subpath\"),\n            (\"file:///path\", \"/subpath\", \"file:///path/subpath\"),\n            (\"file:///path/\", \"subpath\", \"file:///path/subpath\"),\n            (\"file:///path\", \"subpath\", \"file:///path/subpath\"),\n            (\"s3://\", \"\", \"s3:\"),\n            (\"s3://\", \"subpath\", \"s3:subpath\"),\n            (\"s3://\", \"/subpath\", \"s3:/subpath\"),\n            (\"s3://host\", \"subpath\", \"s3://host/subpath\"),\n            (\"s3://host\", \"/subpath\", \"s3://host/subpath\"),\n            (\"s3://host/\", \"subpath\", \"s3://host/subpath\"),\n            (\"s3://host/\", \"/subpath\", \"s3://host/subpath\"),\n            (\"s3://host\", \"subpath/subdir\", \"s3://host/subpath/subdir\"),\n        ]\n    )\n\n\ndef test_append_to_uri_path_handles_special_uri_characters_in_posixpaths():\n    \"\"\"\n    Certain characters are treated specially when parsing and interpreting URIs. However, in the\n    case where a URI input for `append_to_uri_path` is simply a POSIX path, these characters should\n    not receive special treatment. This test case verifies that `append_to_uri_path` properly joins\n    POSIX paths containing these characters.\n    \"\"\"\n\n    def create_char_case(special_char):\n        def char_case(*case_args):\n            return tuple([item.format(c=special_char) for item in case_args])\n\n        return char_case\n\n    for special_char in [\n        \".\",\n        \"-\",\n        \"+\",\n        \":\",\n        \"?\",\n        \"@\",\n        \"&\",\n        \"$\",\n        \"%\",\n        \"/\",\n        \"[\",\n        \"]\",\n        \"(\",\n        \")\",\n        \"*\",\n        \"'\",\n        \",\",\n    ]:\n        char_case = create_char_case(special_char)\n        validate_append_to_uri_path_test_cases(\n            [\n                char_case(\"\", \"{c}subpath\", \"{c}subpath\"),\n                char_case(\"\", \"/{c}subpath\", \"/{c}subpath\"),\n                char_case(\"dirwith{c}{c}chars\", \"\", \"dirwith{c}{c}chars/\"),\n                char_case(\"dirwith{c}{c}chars\", \"subpath\", \"dirwith{c}{c}chars/subpath\"),\n                char_case(\"{c}{c}charsdir\", \"\", \"{c}{c}charsdir/\"),\n                char_case(\"/{c}{c}charsdir\", \"\", \"/{c}{c}charsdir/\"),\n                char_case(\"/{c}{c}charsdir\", \"subpath\", \"/{c}{c}charsdir/subpath\"),\n                char_case(\"/{c}{c}charsdir\", \"subpath\", \"/{c}{c}charsdir/subpath\"),\n            ]\n        )\n\n    validate_append_to_uri_path_test_cases(\n        [\n            (\"#?charsdir:\", \":?subpath#\", \"#?charsdir:/:?subpath#\"),\n            (\"/#--+charsdir.//:\", \"/../:?subpath#\", \"/#--+charsdir.//:/../:?subpath#\"),\n            (\"$@''(,\", \")]*%\", \"$@''(,/)]*%\"),\n        ]\n    )\n\n\n@pytest.mark.parametrize(\n    (\"uri\", \"existing_query_params\", \"query_params\", \"expected\"),\n    [\n        (\"https://example.com\", \"\", [(\"key\", \"value\")], \"https://example.com?key=value\"),\n        (\n            \"https://example.com\",\n            \"existing_key=existing_value\",\n            [(\"new_key\", \"new_value\")],\n            \"https://example.com?existing_key=existing_value&new_key=new_value\",\n        ),\n        (\n            \"https://example.com\",\n            \"\",\n            [(\"key1\", \"value1\"), (\"key2\", \"value2\"), (\"key3\", \"value3\")],\n            \"https://example.com?key1=value1&key2=value2&key3=value3\",\n        ),\n        (\n            \"https://example.com\",\n            \"\",\n            [(\"key\", \"value with spaces\"), (\"key2\", \"special#characters\")],\n            \"https://example.com?key=value+with+spaces&key2=special%23characters\",\n        ),\n        (\"\", \"\", [(\"key\", \"value\")], \"?key=value\"),\n        (\"https://example.com\", \"\", [], \"https://example.com\"),\n        (\n            \"https://example.com\",\n            \"\",\n            [(\"key1\", 123), (\"key2\", 456)],\n            \"https://example.com?key1=123&key2=456\",\n        ),\n        (\n            \"https://example.com?existing_key=existing_value\",\n            \"\",\n            [(\"existing_key\", \"new_value\"), (\"existing_key\", \"new_value_2\")],\n            \"https://example.com?existing_key=existing_value&existing_key=new_value&existing_key=new_value_2\",\n        ),\n        (\n            \"s3://bucket/key\",\n            \"prev1=foo&prev2=bar\",\n            [(\"param1\", \"value1\"), (\"param2\", \"value2\")],\n            \"s3://bucket/key?prev1=foo&prev2=bar&param1=value1&param2=value2\",\n        ),\n        (\n            \"s3://bucket/key?existing_param=existing_value\",\n            \"\",\n            [(\"new_param\", \"new_value\")],\n            \"s3://bucket/key?existing_param=existing_value&new_param=new_value\",\n        ),\n    ],\n)\ndef test_append_to_uri_query_params_appends_as_expected(\n    uri, existing_query_params, query_params, expected\n):\n    if existing_query_params:\n        uri += f\"?{existing_query_params}\"\n\n    result = append_to_uri_query_params(uri, *query_params)\n    assert result == expected\n\n\ndef test_append_to_uri_path_preserves_uri_schemes_hosts_queries_and_fragments():\n    validate_append_to_uri_path_test_cases(\n        [\n            (\"dbscheme+dbdriver:\", \"\", \"dbscheme+dbdriver:\"),\n            (\"dbscheme+dbdriver:\", \"subpath\", \"dbscheme+dbdriver:subpath\"),\n            (\"dbscheme+dbdriver:path\", \"subpath\", \"dbscheme+dbdriver:path/subpath\"),\n            (\"dbscheme+dbdriver://host/path\", \"/subpath\", \"dbscheme+dbdriver://host/path/subpath\"),\n            (\"dbscheme+dbdriver:///path\", \"subpath\", \"dbscheme+dbdriver:/path/subpath\"),\n            (\"dbscheme+dbdriver:?somequery\", \"subpath\", \"dbscheme+dbdriver:subpath?somequery\"),\n            (\"dbscheme+dbdriver:?somequery\", \"/subpath\", \"dbscheme+dbdriver:/subpath?somequery\"),\n            (\"dbscheme+dbdriver:/?somequery\", \"subpath\", \"dbscheme+dbdriver:/subpath?somequery\"),\n            (\"dbscheme+dbdriver://?somequery\", \"subpath\", \"dbscheme+dbdriver:subpath?somequery\"),\n            (\"dbscheme+dbdriver:///?somequery\", \"/subpath\", \"dbscheme+dbdriver:/subpath?somequery\"),\n            (\"dbscheme+dbdriver:#somefrag\", \"subpath\", \"dbscheme+dbdriver:subpath#somefrag\"),\n            (\"dbscheme+dbdriver:#somefrag\", \"/subpath\", \"dbscheme+dbdriver:/subpath#somefrag\"),\n            (\"dbscheme+dbdriver:/#somefrag\", \"subpath\", \"dbscheme+dbdriver:/subpath#somefrag\"),\n            (\"dbscheme+dbdriver://#somefrag\", \"subpath\", \"dbscheme+dbdriver:subpath#somefrag\"),\n            (\"dbscheme+dbdriver:///#somefrag\", \"/subpath\", \"dbscheme+dbdriver:/subpath#somefrag\"),\n            (\n                \"dbscheme+dbdriver://root:password?creds=creds\",\n                \"subpath\",\n                \"dbscheme+dbdriver://root:password/subpath?creds=creds\",\n            ),\n            (\n                \"dbscheme+dbdriver://root:password/path/?creds=creds\",\n                \"/subpath/anotherpath\",\n                \"dbscheme+dbdriver://root:password/path/subpath/anotherpath?creds=creds\",\n            ),\n            (\n                \"dbscheme+dbdriver://root:password///path/?creds=creds\",\n                \"subpath/anotherpath\",\n                \"dbscheme+dbdriver://root:password///path/subpath/anotherpath?creds=creds\",\n            ),\n            (\n                \"dbscheme+dbdriver://root:password///path/?creds=creds\",\n                \"/subpath\",\n                \"dbscheme+dbdriver://root:password///path/subpath?creds=creds\",\n            ),\n            (\n                \"dbscheme+dbdriver://root:password#myfragment\",\n                \"/subpath\",\n                \"dbscheme+dbdriver://root:password/subpath#myfragment\",\n            ),\n            (\n                \"dbscheme+dbdriver://root:password//path/#fragmentwith$pecial@\",\n                \"subpath/anotherpath\",\n                \"dbscheme+dbdriver://root:password//path/subpath/anotherpath#fragmentwith$pecial@\",\n            ),\n            (\n                \"dbscheme+dbdriver://root:password@host?creds=creds#fragmentwith$pecial@\",\n                \"subpath\",\n                \"dbscheme+dbdriver://root:password@host/subpath?creds=creds#fragmentwith$pecial@\",\n            ),\n            (\n                \"dbscheme+dbdriver://root:password@host.com/path?creds=creds#*frag@*\",\n                \"subpath/dir\",\n                \"dbscheme+dbdriver://root:password@host.com/path/subpath/dir?creds=creds#*frag@*\",\n            ),\n            (\n                \"dbscheme-dbdriver://root:password@host.com/path?creds=creds#*frag@*\",\n                \"subpath/dir\",\n                \"dbscheme-dbdriver://root:password@host.com/path/subpath/dir?creds=creds#*frag@*\",\n            ),\n            (\n                \"dbscheme+dbdriver://root:password@host.com/path?creds=creds,param=value#*frag@*\",\n                \"subpath/dir\",\n                \"dbscheme+dbdriver://root:password@host.com/path/subpath/dir?\"\n                \"creds=creds,param=value#*frag@*\",\n            ),\n        ]\n    )\n\n\ndef test_extract_and_normalize_path():\n    base_uri = \"databricks/mlflow-tracking/EXP_ID/RUN_ID/artifacts\"\n    assert (\n        extract_and_normalize_path(\"dbfs:databricks/mlflow-tracking/EXP_ID/RUN_ID/artifacts\")\n        == base_uri\n    )\n    assert (\n        extract_and_normalize_path(\"dbfs:/databricks/mlflow-tracking/EXP_ID/RUN_ID/artifacts\")\n        == base_uri\n    )\n    assert (\n        extract_and_normalize_path(\"dbfs:///databricks/mlflow-tracking/EXP_ID/RUN_ID/artifacts\")\n        == base_uri\n    )\n    assert (\n        extract_and_normalize_path(\n            \"dbfs:/databricks///mlflow-tracking///EXP_ID///RUN_ID///artifacts/\"\n        )\n        == base_uri\n    )\n    assert (\n        extract_and_normalize_path(\n            \"dbfs:///databricks///mlflow-tracking//EXP_ID//RUN_ID///artifacts//\"\n        )\n        == base_uri\n    )\n    assert (\n        extract_and_normalize_path(\n            \"dbfs:databricks///mlflow-tracking//EXP_ID//RUN_ID///artifacts//\"\n        )\n        == base_uri\n    )\n\n\ndef test_is_databricks_acled_artifacts_uri():\n    assert is_databricks_acled_artifacts_uri(\n        \"dbfs:databricks/mlflow-tracking/EXP_ID/RUN_ID/artifacts\"\n    )\n    assert is_databricks_acled_artifacts_uri(\n        \"dbfs:/databricks/mlflow-tracking/EXP_ID/RUN_ID/artifacts\"\n    )\n    assert is_databricks_acled_artifacts_uri(\n        \"dbfs:///databricks/mlflow-tracking/EXP_ID/RUN_ID/artifacts\"\n    )\n    assert is_databricks_acled_artifacts_uri(\n        \"dbfs:/databricks///mlflow-tracking///EXP_ID///RUN_ID///artifacts/\"\n    )\n    assert is_databricks_acled_artifacts_uri(\n        \"dbfs:///databricks///mlflow-tracking//EXP_ID//RUN_ID///artifacts//\"\n    )\n    assert is_databricks_acled_artifacts_uri(\n        \"dbfs:databricks///mlflow-tracking//EXP_ID//RUN_ID///artifacts//\"\n    )\n    assert not is_databricks_acled_artifacts_uri(\n        \"dbfs:/databricks/mlflow//EXP_ID//RUN_ID///artifacts//\"\n    )\n\n\ndef _get_databricks_profile_uri_test_cases():\n    # Each test case is (uri, result, result_scheme)\n    test_case_groups = [\n        [\n            # URIs with no databricks profile info -> return None\n            (\"ftp://user:pass@realhost:port/path/to/nowhere\", None, result_scheme),\n            (\"dbfs:/path/to/nowhere\", None, result_scheme),\n            (\"dbfs://nondatabricks/path/to/nowhere\", None, result_scheme),\n            (\"dbfs://incorrect:netloc:format/path/to/nowhere\", None, result_scheme),\n            # URIs with legit databricks profile info\n            (f\"dbfs://{result_scheme}\", result_scheme, result_scheme),\n            (f\"dbfs://{result_scheme}/\", result_scheme, result_scheme),\n            (f\"dbfs://{result_scheme}/path/to/nowhere\", result_scheme, result_scheme),\n            (f\"dbfs://{result_scheme}:port/path/to/nowhere\", result_scheme, result_scheme),\n            (f\"dbfs://@{result_scheme}/path/to/nowhere\", result_scheme, result_scheme),\n            (f\"dbfs://@{result_scheme}:port/path/to/nowhere\", result_scheme, result_scheme),\n            (\n                f\"dbfs://profile@{result_scheme}/path/to/nowhere\",\n                f\"{result_scheme}://profile\",\n                result_scheme,\n            ),\n            (\n                f\"dbfs://profile@{result_scheme}:port/path/to/nowhere\",\n                f\"{result_scheme}://profile\",\n                result_scheme,\n            ),\n            (\n                f\"dbfs://scope:key_prefix@{result_scheme}/path/abc\",\n                f\"{result_scheme}://scope:key_prefix\",\n                result_scheme,\n            ),\n            (\n                f\"dbfs://scope:key_prefix@{result_scheme}:port/path/abc\",\n                f\"{result_scheme}://scope:key_prefix\",\n                result_scheme,\n            ),\n            # Doesn't care about the scheme of the artifact URI\n            (\n                f\"runs://scope:key_prefix@{result_scheme}/path/abc\",\n                f\"{result_scheme}://scope:key_prefix\",\n                result_scheme,\n            ),\n            (\n                f\"models://scope:key_prefix@{result_scheme}/path/abc\",\n                f\"{result_scheme}://scope:key_prefix\",\n                result_scheme,\n            ),\n            (\n                f\"s3://scope:key_prefix@{result_scheme}/path/abc\",\n                f\"{result_scheme}://scope:key_prefix\",\n                result_scheme,\n            ),\n        ]\n        for result_scheme in [\"databricks\", \"databricks-uc\"]\n    ]\n    return [test_case for test_case_group in test_case_groups for test_case in test_case_group]\n\n\n@pytest.mark.parametrize(\n    (\"uri\", \"result\", \"result_scheme\"), _get_databricks_profile_uri_test_cases()\n)\ndef test_get_databricks_profile_uri_from_artifact_uri(uri, result, result_scheme):\n    assert get_databricks_profile_uri_from_artifact_uri(uri, result_scheme=result_scheme) == result\n\n\n@pytest.mark.parametrize(\n    \"uri\",\n    [\n        # Treats secret key prefixes with \":\" to be invalid\n        \"dbfs://incorrect:netloc:format@databricks/path/a\",\n        \"dbfs://scope::key_prefix@databricks/path/abc\",\n        \"dbfs://scope:key_prefix:@databricks/path/abc\",\n    ],\n)\ndef test_get_databricks_profile_uri_from_artifact_uri_error_cases(uri):\n    with pytest.raises(MlflowException, match=\"Unsupported Databricks profile\"):\n        get_databricks_profile_uri_from_artifact_uri(uri)\n\n\n@pytest.mark.parametrize(\n    (\"uri\", \"result\"),\n    [\n        # URIs with no databricks profile info should stay the same\n        (\n            \"ftp://user:pass@realhost:port/path/nowhere\",\n            \"ftp://user:pass@realhost:port/path/nowhere\",\n        ),\n        (\"dbfs:/path/to/nowhere\", \"dbfs:/path/to/nowhere\"),\n        (\"dbfs://nondatabricks/path/to/nowhere\", \"dbfs://nondatabricks/path/to/nowhere\"),\n        (\"dbfs://incorrect:netloc:format/path/\", \"dbfs://incorrect:netloc:format/path/\"),\n        # URIs with legit databricks profile info\n        (\"dbfs://databricks\", \"dbfs:\"),\n        (\"dbfs://databricks/\", \"dbfs:/\"),\n        (\"dbfs://databricks/path/to/nowhere\", \"dbfs:/path/to/nowhere\"),\n        (\"dbfs://databricks:port/path/to/nowhere\", \"dbfs:/path/to/nowhere\"),\n        (\"dbfs://@databricks/path/to/nowhere\", \"dbfs:/path/to/nowhere\"),\n        (\"dbfs://@databricks:port/path/to/nowhere\", \"dbfs:/path/to/nowhere\"),\n        (\"dbfs://profile@databricks/path/to/nowhere\", \"dbfs:/path/to/nowhere\"),\n        (\"dbfs://profile@databricks:port/path/to/nowhere\", \"dbfs:/path/to/nowhere\"),\n        (\"dbfs://scope:key_prefix@databricks/path/abc\", \"dbfs:/path/abc\"),\n        (\"dbfs://scope:key_prefix@databricks:port/path/abc\", \"dbfs:/path/abc\"),\n        # Treats secret key prefixes with \":\" to be valid\n        (\"dbfs://incorrect:netloc:format@databricks/path/to/nowhere\", \"dbfs:/path/to/nowhere\"),\n        # Doesn't care about the scheme of the artifact URI\n        (\"runs://scope:key_prefix@databricks/path/abc\", \"runs:/path/abc\"),\n        (\"models://scope:key_prefix@databricks/path/abc\", \"models:/path/abc\"),\n        (\"s3://scope:key_prefix@databricks/path/abc\", \"s3:/path/abc\"),\n    ],\n)\ndef test_remove_databricks_profile_info_from_artifact_uri(uri, result):\n    assert remove_databricks_profile_info_from_artifact_uri(uri) == result\n\n\n@pytest.mark.parametrize(\n    (\"artifact_uri\", \"profile_uri\", \"result\"),\n    [\n        # test various profile URIs\n        (\"dbfs:/path/a/b\", \"databricks\", \"dbfs://databricks/path/a/b\"),\n        (\"dbfs:/path/a/b/\", \"databricks\", \"dbfs://databricks/path/a/b/\"),\n        (\"dbfs:/path/a/b/\", \"databricks://Profile\", \"dbfs://Profile@databricks/path/a/b/\"),\n        (\"dbfs:/path/a/b/\", \"databricks://profile/\", \"dbfs://profile@databricks/path/a/b/\"),\n        (\"dbfs:/path/a/b/\", \"databricks://scope:key\", \"dbfs://scope:key@databricks/path/a/b/\"),\n        (\n            \"dbfs:/path/a/b/\",\n            \"databricks://scope:key/random_stuff\",\n            \"dbfs://scope:key@databricks/path/a/b/\",\n        ),\n        (\"dbfs:/path/a/b/\", \"nondatabricks://profile\", \"dbfs:/path/a/b/\"),\n        # test various artifact schemes\n        (\"runs:/path/a/b/\", \"databricks://Profile\", \"runs://Profile@databricks/path/a/b/\"),\n        (\"runs:/path/a/b/\", \"nondatabricks://profile\", \"runs:/path/a/b/\"),\n        (\"models:/path/a/b/\", \"databricks://profile\", \"models://profile@databricks/path/a/b/\"),\n        (\"models:/path/a/b/\", \"nondatabricks://Profile\", \"models:/path/a/b/\"),\n        (\"s3:/path/a/b/\", \"databricks://Profile\", \"s3:/path/a/b/\"),\n        (\"s3:/path/a/b/\", \"nondatabricks://profile\", \"s3:/path/a/b/\"),\n        (\"ftp:/path/a/b/\", \"databricks://profile\", \"ftp:/path/a/b/\"),\n        (\"ftp:/path/a/b/\", \"nondatabricks://Profile\", \"ftp:/path/a/b/\"),\n        # test artifact URIs already with authority\n        (\"ftp://user:pass@host:port/a/b\", \"databricks://Profile\", \"ftp://user:pass@host:port/a/b\"),\n        (\"ftp://user:pass@host:port/a/b\", \"nothing://Profile\", \"ftp://user:pass@host:port/a/b\"),\n        (\"dbfs://databricks\", \"databricks://OtherProfile\", \"dbfs://databricks\"),\n        (\"dbfs://databricks\", \"nondatabricks://Profile\", \"dbfs://databricks\"),\n        (\"dbfs://databricks/path/a/b\", \"databricks://OtherProfile\", \"dbfs://databricks/path/a/b\"),\n        (\"dbfs://databricks/path/a/b\", \"nondatabricks://Profile\", \"dbfs://databricks/path/a/b\"),\n        (\"dbfs://@databricks/path/a/b\", \"databricks://OtherProfile\", \"dbfs://@databricks/path/a/b\"),\n        (\"dbfs://@databricks/path/a/b\", \"nondatabricks://Profile\", \"dbfs://@databricks/path/a/b\"),\n        (\n            \"dbfs://profile@databricks/pp\",\n            \"databricks://OtherProfile\",\n            \"dbfs://profile@databricks/pp\",\n        ),\n        (\n            \"dbfs://profile@databricks/path\",\n            \"databricks://profile\",\n            \"dbfs://profile@databricks/path\",\n        ),\n        (\n            \"dbfs://profile@databricks/path\",\n            \"nondatabricks://Profile\",\n            \"dbfs://profile@databricks/path\",\n        ),\n    ],\n)\ndef test_add_databricks_profile_info_to_artifact_uri(artifact_uri, profile_uri, result):\n    assert add_databricks_profile_info_to_artifact_uri(artifact_uri, profile_uri) == result\n\n\n@pytest.mark.parametrize(\n    (\"artifact_uri\", \"profile_uri\"),\n    [\n        (\"dbfs:/path/a/b\", \"databricks://not:legit:auth\"),\n        (\"dbfs:/path/a/b/\", \"databricks://scope::key\"),\n        (\"dbfs:/path/a/b/\", \"databricks://scope:key:/\"),\n        (\"dbfs:/path/a/b/\", \"databricks://scope:key \"),\n    ],\n)\ndef test_add_databricks_profile_info_to_artifact_uri_errors(artifact_uri, profile_uri):\n    with pytest.raises(MlflowException, match=\"Unsupported Databricks profile\"):\n        add_databricks_profile_info_to_artifact_uri(artifact_uri, profile_uri)\n\n\n@pytest.mark.parametrize(\n    (\"uri\", \"result\"),\n    [\n        (\"dbfs:/path/a/b\", True),\n        (\"dbfs://databricks/a/b\", True),\n        (\"dbfs://@databricks/a/b\", True),\n        (\"dbfs://profile@databricks/a/b\", True),\n        (\"dbfs://scope:key@databricks/a/b\", True),\n        (\"dbfs://scope:key:@databricks/a/b\", False),\n        (\"dbfs://scope::key@databricks/a/b\", False),\n        (\"dbfs://profile@notdatabricks/a/b\", False),\n        (\"dbfs://scope:key@notdatabricks/a/b\", False),\n        (\"dbfs://scope:key/a/b\", False),\n        (\"dbfs://notdatabricks/a/b\", False),\n        (\"s3:/path/a/b\", False),\n        (\"ftp://user:pass@host:port/path/a/b\", False),\n        (\"ftp://user:pass@databricks/path/a/b\", False),\n    ],\n)\ndef test_is_valid_dbfs_uri(uri, result):\n    assert is_valid_dbfs_uri(uri) == result\n\n\n@pytest.mark.parametrize(\n    (\"uri\", \"result\"),\n    [\n        (\"/tmp/path\", \"/dbfs/tmp/path\"),\n        (\"dbfs:/path\", \"/dbfs/path\"),\n        (\"dbfs:/path/a/b\", \"/dbfs/path/a/b\"),\n        (\"dbfs:/dbfs/123/abc\", \"/dbfs/dbfs/123/abc\"),\n    ],\n)\ndef test_dbfs_hdfs_uri_to_fuse_path(uri, result):\n    assert dbfs_hdfs_uri_to_fuse_path(uri) == result\n\n\n@pytest.mark.parametrize(\n    \"path\",\n    [\"some/relative/local/path\", \"s3:/some/s3/path\", \"C:/cool/windows/path\"],\n)\ndef test_dbfs_hdfs_uri_to_fuse_path_raises(path):\n    with pytest.raises(MlflowException, match=\"did not start with expected DBFS URI prefix\"):\n        dbfs_hdfs_uri_to_fuse_path(path)\n\n\ndef _assert_resolve_uri_if_local(input_uri, expected_uri):\n    cwd = pathlib.Path.cwd().as_posix()\n    drive = pathlib.Path.cwd().drive\n    if is_windows():\n        cwd = f\"/{cwd}\"\n        drive = f\"{drive}/\"\n    assert resolve_uri_if_local(input_uri) == expected_uri.format(cwd=cwd, drive=drive)\n\n\n@pytest.mark.skipif(is_windows(), reason=\"This test fails on Windows\")\n@pytest.mark.parametrize(\n    (\"input_uri\", \"expected_uri\"),\n    [\n        (\"my/path\", \"{cwd}/my/path\"),\n        (\"#my/path?a=b\", \"{cwd}/#my/path?a=b\"),\n        (\"file://myhostname/my/path\", \"file://myhostname/my/path\"),\n        (\"file:///my/path\", \"file:///{drive}my/path\"),\n        (\"file:my/path\", \"file://{cwd}/my/path\"),\n        (\"/home/my/path\", \"/home/my/path\"),\n        (\"dbfs://databricks/a/b\", \"dbfs://databricks/a/b\"),\n        (\"s3://host/my/path\", \"s3://host/my/path\"),\n    ],\n)\ndef test_resolve_uri_if_local(input_uri, expected_uri):\n    _assert_resolve_uri_if_local(input_uri, expected_uri)\n\n\n@pytest.mark.skipif(not is_windows(), reason=\"This test only passes on Windows\")\n@pytest.mark.parametrize(\n    (\"input_uri\", \"expected_uri\"),\n    [\n        (\"my/path\", \"file://{cwd}/my/path\"),\n        (\"#my/path?a=b\", \"file://{cwd}/#my/path?a=b\"),\n        (\"file://myhostname/my/path\", \"file://myhostname/my/path\"),\n        (\"file:///my/path\", \"file:///{drive}my/path\"),\n        (\"file:my/path\", \"file://{cwd}/my/path\"),\n        (\"/home/my/path\", \"file:///{drive}home/my/path\"),\n        (\"dbfs://databricks/a/b\", \"dbfs://databricks/a/b\"),\n        (\"s3://host/my/path\", \"s3://host/my/path\"),\n    ],\n)\ndef test_resolve_uri_if_local_on_windows(input_uri, expected_uri):\n    _assert_resolve_uri_if_local(input_uri, expected_uri)\n\n\n@pytest.mark.parametrize(\n    \"uri\",\n    [\n        \"/dbfs/my_path\",\n        \"dbfs:/my_path\",\n        \"/Volumes/my_path\",\n        \"/.fuse-mounts/my_path\",\n        \"//dbfs////my_path\",\n        \"///Volumes/\",\n        \"dbfs://my///path\",\n    ],\n)\ndef test_correctly_detect_fuse_and_uc_uris(uri):\n    assert is_fuse_or_uc_volumes_uri(uri)\n\n\n@pytest.mark.parametrize(\n    \"uri\",\n    [\n        \"/My_Volumes/my_path\",\n        \"s3a:/my_path\",\n        \"Volumes/my_path\",\n        \"Volume:/my_path\",\n        \"dbfs/my_path\",\n        \"/fuse-mounts/my_path\",\n    ],\n)\ndef test_negative_detection(uri):\n    assert not is_fuse_or_uc_volumes_uri(uri)\n"], "filenames": ["mlflow/utils/uri.py", "tests/utils/test_uri.py"], "buggy_code_start_loc": [43, 101], "buggy_code_end_loc": [53, 101], "fixing_code_start_loc": [44, 102], "fixing_code_end_loc": [56, 104], "type": "CWE-29", "message": "This vulnerability enables malicious users to read sensitive files on the server.", "other": {"cve": {"id": "CVE-2023-6977", "sourceIdentifier": "security@huntr.dev", "published": "2023-12-20T06:15:45.907", "lastModified": "2023-12-29T16:45:44.597", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This vulnerability enables malicious users to read sensitive files on the server."}, {"lang": "es", "value": "Esta vulnerabilidad permite a usuarios malintencionados leer archivos confidenciales en el servidor."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-29"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lfprojects:mlflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0.0", "versionEndExcluding": "2.9.2", "matchCriteriaId": "64A68D74-E30A-4AA7-9564-63E4967604E1"}]}]}], "references": [{"url": "https://github.com/mlflow/mlflow/commit/4bd7f27c810ba7487d53ed5ef1038fca0f8dc28c", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.com/bounties/fe53bf71-3687-4711-90df-c26172880aaf", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mlflow/mlflow/commit/4bd7f27c810ba7487d53ed5ef1038fca0f8dc28c"}}