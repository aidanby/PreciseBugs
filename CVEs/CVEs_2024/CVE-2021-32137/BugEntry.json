{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2019\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n#include <gpac/avparse.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\nGF_Err Media_GetSampleDesc(GF_MediaBox *mdia, u32 SampleDescIndex, GF_SampleEntryBox **out_entry, u32 *dataRefIndex)\n{\n\tGF_SampleDescriptionBox *stsd;\n\tGF_SampleEntryBox *entry = NULL;\n\n\tif (!mdia) return GF_ISOM_INVALID_FILE;\n\n\tstsd = mdia->information->sampleTable->SampleDescription;\n\tif (!stsd) return GF_ISOM_INVALID_FILE;\n\tif (!SampleDescIndex || (SampleDescIndex > gf_list_count(stsd->child_boxes)) ) return GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, SampleDescIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\n\tif (out_entry) *out_entry = entry;\n\tif (dataRefIndex) *dataRefIndex = entry->dataReferenceIndex;\n\treturn GF_OK;\n}\n\nGF_Err Media_GetSampleDescIndex(GF_MediaBox *mdia, u64 DTS, u32 *sampleDescIndex)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber, num;\n\tu64 offset;\n\tif (sampleDescIndex == NULL) return GF_BAD_PARAM;\n\n\t//find the sample for this time\n\te = stbl_findEntryForTime(mdia->information->sampleTable, (u32) DTS, 0, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\t//we have to assume the track was created to be used... If we have a sampleDesc, OK\n\t\tif (gf_list_count(mdia->information->sampleTable->SampleDescription->child_boxes)) {\n\t\t\t(*sampleDescIndex) = 1;\n\t\t\treturn GF_OK;\n\t\t}\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn stbl_GetSampleInfos(mdia->information->sampleTable, ( sampleNumber ? sampleNumber : prevSampleNumber), &offset, &num, sampleDescIndex, NULL);\n}\n\nstatic GF_Err gf_isom_get_3gpp_audio_esd(GF_SampleTableBox *stbl, u32 type, GF_GenericAudioSampleEntryBox *entry, GF_ESD **out_esd)\n{\n\t(*out_esd) = gf_odf_desc_esd_new(2);\n\t(*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t/*official mapping to MPEG-4*/\n\tswitch (type) {\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_EVRC;\n\t\treturn GF_OK;\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t{\n\t\tu32 block_size, sample_rate, sample_size, i;\n\t\tGF_SttsEntry *ent;\n\t\tGF_BitStream *bs;\n\t\tchar szName[80];\n\t\t/*only map CBR*/\n\t\tsample_size = stbl->SampleSize->sampleSize;\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_QCELP;\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_data(bs, \"QLCMfmt \", 8);\n\t\tgf_bs_write_u32_le(bs, 150);/*fmt chunk size*/\n\t\tgf_bs_write_u8(bs, 1);\n\t\tgf_bs_write_u8(bs, 0);\n\t\t/*QCELP GUID*/\n\t\tgf_bs_write_data(bs, \"\\x41\\x6D\\x7F\\x5E\\x15\\xB1\\xD0\\x11\\xBA\\x91\\x00\\x80\\x5F\\xB4\\xB9\\x7E\", 16);\n\t\tgf_bs_write_u16_le(bs, 1);\n\t\tmemset(szName, 0, 80);\n\t\tstrcpy(szName, \"QCELP-13K(GPAC-emulated)\");\n\t\tgf_bs_write_data(bs, szName, 80);\n\t\tent = &stbl->TimeToSample->entries[0];\n\t\tsample_rate = entry->samplerate_hi;\n\t\tblock_size = ent ? ent->sampleDelta : 160;\n\t\tgf_bs_write_u16_le(bs, 8*sample_size*sample_rate/block_size);\n\t\tgf_bs_write_u16_le(bs, sample_size);\n\t\tgf_bs_write_u16_le(bs, block_size);\n\t\tgf_bs_write_u16_le(bs, sample_rate);\n\t\tgf_bs_write_u16_le(bs, entry->bitspersample);\n\t\tgf_bs_write_u32_le(bs, sample_size ? 0 : 7);\n\t\t/**/\n\t\tfor (i=0; i<7; i++) {\n\t\t\tstatic const u32 qcelp_r2s [] = {0, 1, 1, 4, 2, 8, 3, 17, 4, 35, 5, 8, 14, 1};\n\t\t\tif (sample_size) {\n\t\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, qcelp_r2s[2*i+1]);\n\t\t\t\tgf_bs_write_u8(bs, qcelp_r2s[2*i]);\n\t\t\t}\n\t\t}\n\t\tgf_bs_write_u16(bs, 0);\n\t\tmemset(szName, 0, 80);\n\t\tgf_bs_write_data(bs, szName, 20);/*reserved*/\n\t\tgf_bs_get_content(bs, & (*out_esd)->decoderConfig->decoderSpecificInfo->data, & (*out_esd)->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_bs_del(bs);\n\t}\n\treturn GF_OK;\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_SMV;\n\t\treturn GF_OK;\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_AMR;\n\t\treturn GF_OK;\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_AMR_WB;\n\t\treturn GF_OK;\n\tdefault:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] unsupported sample description type %s\\n\", gf_4cc_to_str(entry->type)));\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err Media_GetESD(GF_MediaBox *mdia, u32 sampleDescIndex, GF_ESD **out_esd, Bool true_desc_only)\n{\n\tu32 type;\n\tGF_ESD *esd;\n\tGF_MPEGSampleEntryBox *entry = NULL;\n\tGF_ESDBox *ESDa;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\tGF_SampleDescriptionBox *stsd = mdia->information->sampleTable->SampleDescription;\n\n\t*out_esd = NULL;\n\tif (!stsd || !stsd->child_boxes || !sampleDescIndex || (sampleDescIndex > gf_list_count(stsd->child_boxes)) )\n\t\treturn GF_BAD_PARAM;\n\n\tesd = NULL;\n\tentry = (GF_MPEGSampleEntryBox*)gf_list_get(stsd->child_boxes, sampleDescIndex - 1);\n\tif (! entry) return GF_ISOM_INVALID_MEDIA;\n\n\t*out_esd = NULL;\n\tESDa = NULL;\n\ttype = entry->type;\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\tcase GF_ISOM_BOX_TYPE_ENCF:\n\tcase GF_ISOM_BOX_TYPE_ENCM:\n\tcase GF_ISOM_BOX_TYPE_ENCT:\n\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\tif (sinf && sinf->original_format) {\n\t\t\ttype = sinf->original_format->data_format;\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RINF);\n\t\tif (sinf && sinf->original_format) {\n\t\t\ttype = sinf->original_format->data_format;\n\t\t}\n\t\tbreak;\n\t}\n\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tESDa = ((GF_MPEGVisualSampleEntryBox*)entry)->esd;\n\t\tif (ESDa) esd = (GF_ESD *) ESDa->desc;\n\t\t/*avc1 encrypted*/\n\t\telse esd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\tcase GF_ISOM_BOX_TYPE_264B:\n\tcase GF_ISOM_BOX_TYPE_265B:\n\tcase GF_ISOM_BOX_TYPE_DVHE:\n\tcase GF_ISOM_BOX_TYPE_VVC1:\n\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif ((mdia->mediaTrack->extractor_mode & 0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT)\n\t\t\tAVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, mdia);\n\t\telse\n\t\t\tAVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, NULL);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif ((mdia->mediaTrack->extractor_mode & 0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT)\n\t\t\tHEVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, mdia);\n\t\telse\n\t\t\tHEVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, NULL);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tAV1_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*)entry, mdia);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*)entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VP08:\n\tcase GF_ISOM_BOX_TYPE_VP09:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tVP9_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*)entry, mdia);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*)entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n        {\n            GF_MPEGAudioSampleEntryBox *ase = (GF_MPEGAudioSampleEntryBox*)entry;\n            ESDa = ase->esd;\n            if (ESDa) {\n\t\t\t\tesd = (GF_ESD *) ESDa->desc;\n            } else if (!true_desc_only) {\n\t\t\t\tBool make_mp4a = GF_FALSE;\n\t\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\t\t\tif (sinf && sinf->original_format) {\n\t\t\t\t\tif (sinf->original_format->data_format==GF_ISOM_BOX_TYPE_MP4A) {\n\t\t\t\t\t\tmake_mp4a = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Assuming that if no ESD is provided the stream is Basic MPEG-4 AAC LC\n\t\t\t\t\tmake_mp4a = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (make_mp4a) {\n\t\t\t\t\tGF_M4ADecSpecInfo aacinfo;\n\t\t\t\t\tmemset(&aacinfo, 0, sizeof(GF_M4ADecSpecInfo));\n\t\t\t\t\taacinfo.nb_chan = ase->channel_count;\n\t\t\t\t\taacinfo.base_object_type = GF_M4A_AAC_LC;\n\t\t\t\t\taacinfo.base_sr = ase->samplerate_hi;\n\t\t\t\t\t*out_esd = gf_odf_desc_esd_new(0);\n\t\t\t\t\t(*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t\t\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_AAC_MPEG4;\n\t\t\t\t\tgf_m4a_write_config(&aacinfo, &(*out_esd)->decoderConfig->decoderSpecificInfo->data, &(*out_esd)->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\t\t}\n            }\n        }\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (entry->internal_type==GF_ISOM_SAMPLE_ENTRY_MP4S) {\n\t\t\tESDa = entry->esd;\n\t\t\tif (ESDa) esd = (GF_ESD *) ESDa->desc;\n\t\t}\n\t\tbreak;\n#ifndef GPAC_DISABLE_TTXT\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_MP4S)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\n\t\tif (!true_desc_only && mdia->mediaTrack->moov->mov->convert_streaming_text) {\n\t\t\tGF_Err e = gf_isom_get_ttxt_esd(mdia, out_esd);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n#endif\n#ifndef GPAC_DISABLE_VTT\n\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_MP4S)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t{\n\t\tGF_WebVTTSampleEntryBox*vtte = (GF_WebVTTSampleEntryBox*)entry;\n\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t*out_esd = esd;\n\t\tesd->decoderConfig->streamType = GF_STREAM_TEXT;\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_WEBVTT;\n\t\tif (vtte->config) {\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = (u32) strlen(vtte->config->string);\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = gf_malloc(sizeof(char)*esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tmemcpy(esd->decoderConfig->decoderSpecificInfo->data, vtte->config->string, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t}\n\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STPP:\n\tcase GF_ISOM_BOX_TYPE_SBTT:\n\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\tbreak;\n#endif\n\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (!true_desc_only) {\n\t\t\tGF_Err e = gf_isom_get_3gpp_audio_esd(mdia->information->sampleTable, type, (GF_GenericAudioSampleEntryBox*)entry, out_esd);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t} else return GF_ISOM_INVALID_MEDIA;\n\n\tcase GF_ISOM_SUBTYPE_OPUS:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t{\n\t\tGF_OpusSpecificBox *e = ((GF_MPEGAudioSampleEntryBox*)entry)->cfg_opus;\n\t\tGF_BitStream *bs_out;\n\t\tif (!e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"ESD not found for Opus\\n)\"));\n\t\t\tbreak;\n\t\t}\n\n\t\t*out_esd = gf_odf_desc_esd_new(2);\n\t\t(*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_OPUS;\n\n\t\t//serialize box with header - compatibility with ffmpeg\n\t\tbs_out = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_isom_box_size((GF_Box *) e);\n\t\tgf_isom_box_write((GF_Box *) e, bs_out);\n\t\tgf_bs_get_content(bs_out, & (*out_esd)->decoderConfig->decoderSpecificInfo->data, & (*out_esd)->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_bs_del(bs_out);\n\t\tbreak;\n\t}\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_H263;\n\t\t\tbreak;\n\t\t}\n\n\tcase GF_ISOM_SUBTYPE_MP3:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_MPEG_AUDIO;\n\t\t\tbreak;\n\t\t}\n\n\tcase GF_ISOM_SUBTYPE_LSR1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_MP4S)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tGF_LASeRSampleEntryBox*ptr = (GF_LASeRSampleEntryBox*)entry;\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_SCENE;\n\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_LASER;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = ptr->lsr_config->hdr_size;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = gf_malloc(sizeof(char)*ptr->lsr_config->hdr_size);\n\t\t\tif (!esd->decoderConfig->decoderSpecificInfo->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(esd->decoderConfig->decoderSpecificInfo->data, ptr->lsr_config->hdr, sizeof(char)*ptr->lsr_config->hdr_size);\n\t\t\tbreak;\n\t\t}\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA2:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM2:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tGF_MPEGAudioSampleEntryBox*ptr = (GF_MPEGAudioSampleEntryBox*)entry;\n\t\t\tesd = gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t\tif ((type==GF_ISOM_SUBTYPE_MH3D_MHA1) || (type==GF_ISOM_SUBTYPE_MH3D_MHA2))\n\t\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_MPHA;\n\t\t\telse\n\t\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_MHAS;\n\t\t\tif (ptr->cfg_mha) {\n\t\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\tgf_bs_write_u8(bs, ptr->cfg_mha->configuration_version);\n\t\t\t\tgf_bs_write_u8(bs, ptr->cfg_mha->mha_pl_indication);\n\t\t\t\tgf_bs_write_u8(bs, ptr->cfg_mha->reference_channel_layout);\n\t\t\t\tgf_bs_write_u16(bs, ptr->cfg_mha->mha_config ? ptr->cfg_mha->mha_config_size : 0);\n\t\t\t\tif (ptr->cfg_mha->mha_config && ptr->cfg_mha->mha_config_size)\n\t\t\t\t\tgf_bs_write_data(bs, ptr->cfg_mha->mha_config, ptr->cfg_mha->mha_config_size);\n\n\t\t\t\tgf_bs_get_content(bs, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn GF_ISOM_INVALID_MEDIA;\n\t}\n\n\tif (true_desc_only) {\n\t\tif (!esd) return GF_ISOM_INVALID_MEDIA;\n\t\t*out_esd = esd;\n\t\treturn GF_OK;\n\t} else {\n\t\tif (!esd && !*out_esd) return GF_ISOM_INVALID_MEDIA;\n\t\tif (*out_esd == NULL) return gf_odf_desc_copy((GF_Descriptor *)esd, (GF_Descriptor **)out_esd);\n\t}\n\treturn GF_OK;\n}\n\nBool Media_IsSampleSyncShadow(GF_ShadowSyncBox *stsh, u32 sampleNumber)\n{\n\tu32 i;\n\tGF_StshEntry *ent;\n\tif (!stsh) return 0;\n\ti=0;\n\twhile ((ent = (GF_StshEntry*)gf_list_enum(stsh->entries, &i))) {\n\t\tif ((u32) ent->syncSampleNumber == sampleNumber) return 1;\n\t\telse if ((u32) ent->syncSampleNumber > sampleNumber) return 0;\n\t}\n\treturn 0;\n}\n\nGF_Err Media_GetSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample **samp, u32 *sIDX, Bool no_data, u64 *out_offset)\n{\n\tGF_Err e;\n\tu32 bytesRead;\n\tu32 dataRefIndex, chunkNumber;\n\tu64 offset, new_size;\n\tu32 sdesc_idx;\n\tGF_SampleEntryBox *entry;\n\tGF_StscEntry *stsc_entry;\n\n\tif (!mdia || !mdia->information->sampleTable) return GF_BAD_PARAM;\n\tif (!mdia->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\t//OK, here we go....\n\tif (sampleNumber > mdia->information->sampleTable->SampleSize->sampleCount) return GF_BAD_PARAM;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n\n\te = stbl_GetSampleInfos(mdia->information->sampleTable, sampleNumber, &offset, &chunkNumber, &sdesc_idx, &stsc_entry);\n\tif (e) return e;\n\tif (sIDX) (*sIDX) = sdesc_idx;\n\n\tif (out_offset) *out_offset = offset;\n\tif (!samp ) return GF_OK;\n\n\tif (mdia->information->sampleTable->TimeToSample) {\n\t\t//get the DTS\n\t\te = stbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber, &(*samp)->DTS);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->DTS=0;\n\t}\n\t//the CTS offset\n\tif (mdia->information->sampleTable->CompositionOffset) {\n\t\te = stbl_GetSampleCTS(mdia->information->sampleTable->CompositionOffset , sampleNumber, &(*samp)->CTS_Offset);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->CTS_Offset = 0;\n\t}\n\t//the size\n\te = stbl_GetSampleSize(mdia->information->sampleTable->SampleSize, sampleNumber, &(*samp)->dataLength);\n\tif (e) return e;\n\t//the RAP\n\tif (mdia->information->sampleTable->SyncSample) {\n\t\te = stbl_GetSampleRAP(mdia->information->sampleTable->SyncSample, sampleNumber, &(*samp)->IsRAP, NULL, NULL);\n\t\tif (e) return e;\n\t} else {\n\t\t//if no SyncSample, all samples are sync (cf spec)\n\t\t(*samp)->IsRAP = RAP;\n\t}\n\n\tif (mdia->information->sampleTable->SampleDep) {\n\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\t\te = stbl_GetSampleDepType(mdia->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\tif (!e) {\n\t\t\tif (dependsOn==1) (*samp)->IsRAP = RAP_NO;\n\t\t\t//commenting following code since it is wrong - an I frame is not always a SAP1, it can be a SAP2 or SAP3.\n\t\t\t//Keeping this code breaks AVC / HEVC openGOP import when writing sample dependencies\n\t\t\t//else if (dependsOn==2) (*samp)->IsRAP = RAP;\n\n\t\t\t/*if not depended upon and redundant, mark as carousel sample*/\n\t\t\tif ((dependedOn==2) && (redundant==1)) (*samp)->IsRAP = RAP_REDUNDANT;\n\t\t\t/*TODO FIXME - we must enhance the IsRAP semantics to carry disposable info ... */\n\t\t}\n\t}\n\n\t/*get sync shadow*/\n\tif (Media_IsSampleSyncShadow(mdia->information->sampleTable->ShadowSync, sampleNumber)) (*samp)->IsRAP = RAP_REDUNDANT;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n\tif (!sIDX && !out_offset) return GF_OK;\n\tif (!sIDX) return GF_OK;\n\n\t(*sIDX) = sdesc_idx;\n//\te = stbl_GetSampleInfos(mdia->information->sampleTable, sampleNumber, &offset, &chunkNumber, sIDX, &stsc_entry);\n//\tif (e) return e;\n\n\t//then get the DataRef\n\te = Media_GetSampleDesc(mdia, sdesc_idx, &entry, &dataRefIndex);\n\tif (e) return e;\n\n\t//if moov is compressed, remove offset if sample is after moov in this file\n\tif (mdia->mediaTrack->moov->compressed_diff) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1) && (offset>=mdia->mediaTrack->moov->file_offset)) {\n\t\t\toffset -= mdia->mediaTrack->moov->compressed_diff;\n\t\t}\n\t}\n\n\n\tif (no_data) {\n\t\tif ( ((*samp)->dataLength != 0) && mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\t(*samp)->dataLength *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t// Open the data handler - check our mode, don't reopen in read only if this is\n\t//the same entry. In other modes we have no choice because the main data map is\n\t//divided into the original and the edition files\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_READ) {\n\t\t//same as last call in read mode\n\t\tif (!mdia->information->dataHandler) {\n\t\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\t\tif (e) return e;\n\t\t}\n\t\tmdia->information->dataEntryIndex = dataRefIndex;\n\t} else {\n\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\tif (e) return e;\n\t}\n\n\tif ( mdia->mediaTrack->moov->mov->read_byte_offset || mdia->mediaTrack->moov->mov->bytes_removed) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1)) {\n\t\t\tu64 real_offset = mdia->mediaTrack->moov->mov->read_byte_offset + mdia->mediaTrack->moov->mov->bytes_removed;\n\t\t\tif (offset < real_offset)\n\t\t\t\treturn GF_IO_ERR;\n\n\t\t\tif (mdia->information->dataHandler->last_read_offset != mdia->mediaTrack->moov->mov->read_byte_offset) {\n\t\t\t\tmdia->information->dataHandler->last_read_offset = mdia->mediaTrack->moov->mov->read_byte_offset;\n\t\t\t\tgf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\t}\n\n\t\t\toffset -= real_offset;\n\t\t}\n\t}\n\tif ((*samp)->dataLength != 0) {\n\t\tif (mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\t(*samp)->dataLength *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\n\t\t/*and finally get the data, include padding if needed*/\n\t\tif ((*samp)->alloc_size) {\n\t\t\tif ((*samp)->alloc_size < (*samp)->dataLength + mdia->mediaTrack->padding_bytes) {\n\t\t\t\t(*samp)->data = (char *) gf_realloc((*samp)->data, sizeof(char) * ( (*samp)->dataLength + mdia->mediaTrack->padding_bytes) );\n\t\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\n\t\t\t\t(*samp)->alloc_size = (*samp)->dataLength + mdia->mediaTrack->padding_bytes;\n\t\t\t}\n\t\t} else {\n\t\t\t(*samp)->data = (char *) gf_malloc(sizeof(char) * ( (*samp)->dataLength + mdia->mediaTrack->padding_bytes) );\n\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (mdia->mediaTrack->padding_bytes)\n\t\t\tmemset((*samp)->data + (*samp)->dataLength, 0, sizeof(char) * mdia->mediaTrack->padding_bytes);\n\n\t\t//check if we can get the sample (make sure we have enougth data...)\n\t\tnew_size = gf_bs_get_size(mdia->information->dataHandler->bs);\n\t\tif (offset + (*samp)->dataLength > new_size) {\n\t\t\t//always refresh the size to avoid wrong info on http/ftp\n\t\t\tnew_size = gf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\tif (offset + (*samp)->dataLength > new_size) {\n\t\t\t\tmdia->BytesMissing = offset + (*samp)->dataLength - new_size;\n\t\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t\t}\n\t\t}\n\n\t\tbytesRead = gf_isom_datamap_get_data(mdia->information->dataHandler, (*samp)->data, (*samp)->dataLength, offset);\n\t\t//if bytesRead != sampleSize, we have an IO err\n\t\tif (bytesRead < (*samp)->dataLength) {\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tmdia->BytesMissing = 0;\n\t}\n\n\t//finally rewrite the sample if this is an OD Access Unit or NAL-based one\n\t//we do this even if sample size is zero because of sample implicit reconstruction rules (especially tile tracks)\n\tif (mdia->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tif (!mdia->mediaTrack->moov->mov->disable_odf_translate) {\n\t\t\te = Media_RewriteODFrame(mdia, *samp);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\telse if (gf_isom_is_nalu_based_entry(mdia, entry)\n\t\t&& !gf_isom_is_encrypted_entry(entry->type)\n\t) {\n\t\te = gf_isom_nalu_sample_rewrite(mdia, *samp, sampleNumber, (GF_MPEGVisualSampleEntryBox *)entry);\n\t\tif (e) return e;\n\t}\n\telse if (mdia->mediaTrack->moov->mov->convert_streaming_text\n\t         && ((mdia->handler->handlerType == GF_ISOM_MEDIA_TEXT) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SCENE) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SUBT))\n\t         && (entry->type == GF_ISOM_BOX_TYPE_TX3G || entry->type == GF_ISOM_BOX_TYPE_TEXT)\n\t        ) {\n\t\tu64 dur;\n\t\tif (sampleNumber == mdia->information->sampleTable->SampleSize->sampleCount) {\n\t\t\tdur = mdia->mediaHeader->duration - (*samp)->DTS;\n\t\t} else {\n\t\t\tstbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber+1, &dur);\n\t\t\tdur -= (*samp)->DTS;\n\t\t}\n\t\te = gf_isom_rewrite_text_sample(*samp, sdesc_idx, (u32) dur);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n\n\nGF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex)\n{\n\n\tGF_DataEntryURLBox *entry;\n\tGF_DataMap *map;\n\tGF_Err e;\n\tif (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM;\n\n\tentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\tif (entry->flags == 1) return GF_OK;\n\n\t//ok, not self contained, let's go for it...\n\t//we don't know what's a URN yet\n\tif (entry->type == GF_ISOM_BOX_TYPE_URN) return GF_NOT_SUPPORTED;\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) {\n\t\te = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map);\n\t} else {\n\t\te = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map);\n\t}\n\tif (e) return e;\n\tgf_isom_datamap_del(map);\n\treturn GF_OK;\n}\n\n\nBool Media_IsSelfContained(GF_MediaBox *mdia, u32 StreamDescIndex)\n{\n\tu32 drefIndex=0;\n\tGF_FullBox *a=NULL;\n\tGF_SampleEntryBox *se = NULL;\n\n\tMedia_GetSampleDesc(mdia, StreamDescIndex, &se, &drefIndex);\n\tif (!drefIndex) return 0;\n\tif (mdia\n\t\t&& mdia->information\n\t\t&& mdia->information->dataInformation\n\t\t&& mdia->information->dataInformation->dref\n\t) {\n\t\ta = (GF_FullBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, drefIndex - 1);\n\t}\n\tif (!a) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] broken file: Data reference index set to %d but no data reference entry found\\n\", drefIndex));\n\t\treturn 1;\n\t}\n\tif (a->flags & 1) return 1;\n\t/*QT specific*/\n\tif (a->type == GF_QT_BOX_TYPE_ALIS) return 1;\n\treturn 0;\n}\n\nGF_ISOMDataRefAllType Media_SelfContainedType(GF_MediaBox *mdia)\n{\n\tu32 nb_ext, nb_self;\n\tu32 i, count;\n\n\tnb_ext = nb_self = 0;\n\tcount = mdia->information->sampleTable->SampleDescription ? gf_list_count(mdia->information->sampleTable->SampleDescription->child_boxes) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tif (Media_IsSelfContained(mdia, i+1)) nb_self++;\n\t\telse nb_ext++;\n\t}\n\tif (nb_ext==count) return ISOM_DREF_EXT;\n\tif (nb_self==count) return ISOM_DREF_SELF;\n\treturn ISOM_DREF_MIXED;\n}\n\n\n\n//look for a sync sample from a given point in media time\nGF_Err Media_FindSyncSample(GF_SampleTableBox *stbl, u32 searchFromSample, u32 *sampleNumber, u8 mode)\n{\n\tGF_ISOSAPType isRAP;\n\tu32 next, prev, next_in_sap, prev_in_sap;\n\tif (!stbl || !stbl->SyncSample) return GF_BAD_PARAM;\n\n\t//set to current sample if we don't find a RAP\n\t*sampleNumber = searchFromSample;\n\n\t//this is not the exact sample, but the prev move to next sample if enough samples....\n\tif ( (mode == GF_ISOM_SEARCH_SYNC_FORWARD) && (searchFromSample == stbl->SampleSize->sampleCount) ) {\n\t\treturn GF_OK;\n\t}\n\tif ( (mode == GF_ISOM_SEARCH_SYNC_BACKWARD) && !searchFromSample) {\n\t\t*sampleNumber = 1;\n\t\treturn GF_OK;\n\t}\n\t//get the entry\n\tstbl_GetSampleRAP(stbl->SyncSample, searchFromSample, &isRAP, &prev, &next);\n\tif (isRAP) {\n\t\t(*sampleNumber) = searchFromSample;\n\t\treturn GF_OK;\n\t}\n\n\t/*check sample groups - prev & next are overwritten if RAP group is found, but are not re-initialized otherwise*/\n\tstbl_SearchSAPs(stbl, searchFromSample, &isRAP, &prev_in_sap, &next_in_sap);\n\tif (isRAP) {\n\t\t(*sampleNumber) = searchFromSample;\n\t\treturn GF_OK;\n\t}\n\n\tif (prev_in_sap > prev)\n\t\tprev = prev_in_sap;\n\tif (next_in_sap && next_in_sap < next)\n\t\tnext = next_in_sap;\n\n\t//nothing yet, go for next time...\n\tif (mode == GF_ISOM_SEARCH_SYNC_FORWARD) {\n\t\tif (next) *sampleNumber = next;\n\t} else {\n\t\tif (prev) *sampleNumber = prev;\n\t}\n\n\treturn GF_OK;\n}\n\n//create a DataReference if not existing (only for WRITE-edit mode)\nGF_Err Media_FindDataRef(GF_DataReferenceBox *dref, char *URLname, char *URNname, u32 *dataRefIndex)\n{\n\tu32 i;\n\tGF_DataEntryURLBox *entry;\n\n\tif (!dref) return GF_BAD_PARAM;\n\t*dataRefIndex = 0;\n\ti=0;\n\twhile ((entry = (GF_DataEntryURLBox*)gf_list_enum(dref->child_boxes, &i))) {\n\t\tif (entry->type == GF_ISOM_BOX_TYPE_URL) {\n\t\t\t//self-contained case\n\t\t\tif (entry->flags == 1) {\n\t\t\t\t//if nothing specified, get the dataRef\n\t\t\t\tif (!URLname && !URNname) {\n\t\t\t\t\t*dataRefIndex = i;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//OK, check if we have URL\n\t\t\t\tif (URLname && !strcmp(URLname, entry->location)) {\n\t\t\t\t\t*dataRefIndex = i;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t//this is a URN one, only check the URN name (URL optional)\n\t\t\tif (URNname && !strcmp(URNname, ((GF_DataEntryURNBox *)entry)->nameURN)) {\n\t\t\t\t*dataRefIndex = i;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n//Get the total media duration based on the TimeToSample table\nGF_Err Media_SetDuration(GF_TrackBox *trak)\n{\n\tGF_Err e;\n\tGF_ESD *esd;\n\tu64 DTS;\n\tGF_SttsEntry *ent;\n\tu32 nbSamp;\n\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tif (!trak->Media->information->sampleTable->SampleSize || !trak->Media->information->sampleTable->TimeToSample)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tnbSamp = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\n\t//we need to check how many samples we have.\n\t// == 1 -> last sample duration == default duration\n\t// > 1 -> last sample duration == prev sample duration\n\tswitch (nbSamp) {\n\tcase 0:\n\t\ttrak->Media->mediaHeader->duration = 0;\n\t\tif (Track_IsMPEG4Stream(trak->Media->handler->handlerType)) {\n\t\t\tMedia_GetESD(trak->Media, 1, &esd, 1);\n\t\t\tif (esd && esd->URLString) trak->Media->mediaHeader->duration = (u64) -1;\n\n\t\t}\n\t\treturn GF_OK;\n\n//\tcase 1:\n//\t\ttrak->Media->mediaHeader->duration = trak->Media->mediaHeader->timeScale;\n//\t\treturn GF_OK;\n\n\tdefault:\n\t\t//we assume a constant frame rate for the media and assume the last sample\n\t\t//will be hold the same time as the prev one\n\t\te = stbl_GetSampleDTS(trak->Media->information->sampleTable->TimeToSample, nbSamp, &DTS);\n\t\tif (e < 0) {\n\t\t\treturn e;\n\t\t}\n\t\tif (trak->Media->information->sampleTable->TimeToSample->nb_entries > 0) {\n\t\t\tent = &trak->Media->information->sampleTable->TimeToSample->entries[trak->Media->information->sampleTable->TimeToSample->nb_entries-1];\n\t\t} else {\n\t\t\tent = NULL;\n\t\t}\n\t\ttrak->Media->mediaHeader->duration = DTS;\n\n\n#if 1\n\t\tif (ent) trak->Media->mediaHeader->duration += ent->sampleDelta;\n#else\n\t\tif (!ent) {\n\t\t\tu64 DTSprev;\n\t\t\tstbl_GetSampleDTS(trak->Media->information->sampleTable->TimeToSample, nbSamp-1, &DTSprev);\n\t\t\ttrak->Media->mediaHeader->duration += (DTS - DTSprev);\n\t\t} else {\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\t\tif (trak->moov->mov->editFileMap && trak->Media->information->sampleTable->CompositionOffset) {\n\t\t\t\tu32 count, i;\n\t\t\t\tu64 max_ts;\n\t\t\t\tGF_DttsEntry *cts_ent;\n\t\t\t\tGF_CompositionOffsetBox *ctts = trak->Media->information->sampleTable->CompositionOffset;\n\t\t\t\tif (ctts->w_LastSampleNumber==nbSamp) {\n\t\t\t\t\tcount = gf_list_count(ctts->entryList);\n\t\t\t\t\tmax_ts = trak->Media->mediaHeader->duration;\n\t\t\t\t\twhile (count) {\n\t\t\t\t\t\tcount -= 1;\n\t\t\t\t\t\tcts_ent = gf_list_get(ctts->entryList, count);\n\t\t\t\t\t\tif (nbSamp<cts_ent->sampleCount) break;\n\n\t\t\t\t\t\tfor (i=0; i<cts_ent->sampleCount; i++) {\n\t\t\t\t\t\t\tstbl_GetSampleDTS(trak->Media->information->sampleTable->TimeToSample, nbSamp-i, &DTS);\n\t\t\t\t\t\t\tif ((s32) cts_ent->decodingOffset < 0) max_ts = DTS;\n\t\t\t\t\t\t\telse max_ts = DTS + cts_ent->decodingOffset;\n\t\t\t\t\t\t\tif (max_ts>=trak->Media->mediaHeader->duration) {\n\t\t\t\t\t\t\t\ttrak->Media->mediaHeader->duration = max_ts;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (max_ts<trak->Media->mediaHeader->duration) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnbSamp-=cts_ent->sampleCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\t\t\ttrak->Media->mediaHeader->duration += ent->sampleDelta;\n\t\t}\n#endif\n\t\treturn GF_OK;\n\t}\n}\n\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err Media_SetDrefURL(GF_DataEntryURLBox *dref_entry, const char *origName, const char *finalName)\n{\n\t//for now we only support dref created in same folder for relative URLs\n\tif (strstr(origName, \"://\") || ((origName[1]==':') && (origName[2]=='\\\\'))\n\t\t|| (origName[0]=='/') || (origName[0]=='\\\\')\n\t) {\n\t\tdref_entry->location = gf_strdup(origName);\n\t} else {\n\t\tchar *fname = strrchr(origName, '/');\n\t\tif (!fname) fname = strrchr(origName, '\\\\');\n\t\tif (fname) fname++;\n\n\t\tif (!fname) {\n\t\t\tdref_entry->location = gf_strdup(origName);\n\t\t} else {\n\t\t\tu32 len = (u32) (fname - origName);\n\t\t\tif (!finalName || strncmp(origName, finalName, len)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Concatenation of relative path %s with relative path %s not supported, use absolute URLs\\n\", origName, finalName));\n\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t} else {\n\t\t\t\tdref_entry->location = gf_strdup(fname);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err Media_CreateDataRef(GF_ISOFile *movie, GF_DataReferenceBox *dref, char *URLname, char *URNname, u32 *dataRefIndex)\n{\n\tGF_Err e;\n\tBool use_alis=GF_FALSE;\n\tGF_DataEntryURLBox *entry;\n\n\tif (URLname && !strcmp(URLname, \"alis\")) {\n\t\tURLname = NULL;\n\t\tuse_alis=GF_TRUE;\n\t}\n\n\tif (!URLname && !URNname) {\n\t\t//THIS IS SELF CONTAIN, create a regular entry if needed\n\t\tentry = (GF_DataEntryURLBox *) gf_isom_box_new_parent(&dref->child_boxes, use_alis ? GF_QT_BOX_TYPE_ALIS : GF_ISOM_BOX_TYPE_URL);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\tentry->flags = 1;\n\t\t*dataRefIndex = gf_list_count(dref->child_boxes);\n\t\treturn GF_OK;\n\t} else if (!URNname && URLname) {\n\t\t//THIS IS URL\n\t\tentry = (GF_DataEntryURLBox *) gf_isom_box_new_parent(&dref->child_boxes, GF_ISOM_BOX_TYPE_URL);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\tentry->flags = 0;\n\n\t\te = Media_SetDrefURL(entry, URLname, movie->fileName ? movie->fileName : movie->finalName);\n\t\tif (! entry->location) {\n\t\t\tgf_isom_box_del_parent(&dref->child_boxes, (GF_Box *)entry);\n\t\t\treturn e ? e : GF_OUT_OF_MEM;\n\t\t}\n\t\t*dataRefIndex = gf_list_count(dref->child_boxes);\n\t\treturn GF_OK;\n\t} else {\n\t\t//THIS IS URN\n\t\tentry = (GF_DataEntryURLBox *) gf_isom_box_new_parent(&dref->child_boxes, GF_ISOM_BOX_TYPE_URN);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t((GF_DataEntryURNBox *)entry)->flags = 0;\n\t\t((GF_DataEntryURNBox *)entry)->nameURN = (char*)gf_malloc(strlen(URNname)+1);\n\t\tif (! ((GF_DataEntryURNBox *)entry)->nameURN) {\n\t\t\tgf_isom_box_del_parent(&dref->child_boxes, (GF_Box *)entry);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tstrcpy(((GF_DataEntryURNBox *)entry)->nameURN, URNname);\n\t\t//check for URL\n\t\tif (URLname) {\n\t\t\t((GF_DataEntryURNBox *)entry)->location = (char*)gf_malloc(strlen(URLname)+1);\n\t\t\tif (! ((GF_DataEntryURNBox *)entry)->location) {\n\t\t\t\tgf_isom_box_del_parent(&dref->child_boxes, (GF_Box *)entry);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tstrcpy(((GF_DataEntryURNBox *)entry)->location, URLname);\n\t\t}\n\t\t*dataRefIndex = gf_list_count(dref->child_boxes);\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err Media_AddSample(GF_MediaBox *mdia, u64 data_offset, const GF_ISOSample *sample, u32 StreamDescIndex, u32 syncShadowNumber)\n{\n\tGF_Err e;\n\tGF_SampleTableBox *stbl;\n\tu32 sampleNumber, i;\n\tif (!mdia || !sample) return GF_BAD_PARAM;\n\n\tstbl = mdia->information->sampleTable;\n\n\t//get a valid sampleNumber for this new guy\n\te = stbl_AddDTS(stbl, sample->DTS, &sampleNumber, mdia->mediaHeader->timeScale, sample->nb_pack);\n\tif (e) return e;\n\n\t//add size\n\te = stbl_AddSize(stbl->SampleSize, sampleNumber, sample->dataLength, sample->nb_pack);\n\tif (e) return e;\n\n\t//adds CTS offset\n\tif (sample->CTS_Offset) {\n\t\t//if we don't have a CTS table, add it...\n\t\tif (!stbl->CompositionOffset) {\n\t\t\tstbl->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\t\t\tif (!stbl->CompositionOffset) return GF_OUT_OF_MEM;\n\t\t}\n\t\t//then add our CTS (the prev samples with no CTS offset will be automatically added...\n\t\te = stbl_AddCTS(stbl, sampleNumber, sample->CTS_Offset);\n\t\tif (e) return e;\n\t} else if (stbl->CompositionOffset) {\n\t\te = stbl_AddCTS(stbl, sampleNumber, sample->CTS_Offset);\n\t\tif (e) return e;\n\t}\n\n\t//The first non sync sample we see must create a syncTable\n\tif (sample->IsRAP) {\n\t\t//insert it only if we have a sync table and if we have an IDR slice\n\t\tif (stbl->SyncSample && (sample->IsRAP == RAP)) {\n\t\t\te = stbl_AddRAP(stbl->SyncSample, sampleNumber);\n\t\t\tif (e) return e;\n\t\t}\n\t} else {\n\t\t//non-sync sample. Create a SyncSample table if needed\n\t\tif (!stbl->SyncSample) {\n\t\t\tstbl->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\t\t\tif (!stbl->SyncSample) return GF_OUT_OF_MEM;\n\t\t\t//all the prev samples are sync\n\t\t\tfor (i=0; i<stbl->SampleSize->sampleCount; i++) {\n\t\t\t\tif (i+1 != sampleNumber) {\n\t\t\t\t\te = stbl_AddRAP(stbl->SyncSample, i+1);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (sample->IsRAP==RAP_REDUNDANT) {\n\t\te = stbl_AddRedundant(stbl, sampleNumber);\n\t\tif (e) return e;\n\t}\n\n\tif (!mdia->mediaTrack->chunk_cache) {\n\t\t//and update the chunks\n\t\te = stbl_AddChunkOffset(mdia, sampleNumber, StreamDescIndex, data_offset, sample->nb_pack);\n\t\tif (e) return e;\n\t}\n\t\n\tif (!syncShadowNumber) return GF_OK;\n\tif (!stbl->ShadowSync) {\n\t\tstbl->ShadowSync = (GF_ShadowSyncBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSH);\n\t\tif (!stbl->ShadowSync) return GF_OUT_OF_MEM;\n\t}\n\treturn stbl_AddShadow(mdia->information->sampleTable->ShadowSync, sampleNumber, syncShadowNumber);\n}\n\n\nstatic GF_Err UpdateSample(GF_MediaBox *mdia, u32 sampleNumber, u32 size, s32 CTS, u64 offset, u8 isRap)\n{\n\tu32 i;\n\tGF_SampleTableBox *stbl = mdia->information->sampleTable;\n\n\t//set size, offset, RAP, CTS ...\n\tstbl_SetSampleSize(stbl->SampleSize, sampleNumber, size);\n\tstbl_SetChunkOffset(mdia, sampleNumber, offset);\n\n\t//do we have a CTS?\n\tif (stbl->CompositionOffset) {\n\t\tstbl_SetSampleCTS(stbl, sampleNumber, CTS);\n\t} else {\n\t\t//do we need one ??\n\t\tif (CTS) {\n\t\t\tstbl->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\t\t\tif (!stbl->CompositionOffset) return GF_OUT_OF_MEM;\n\t\t\tstbl_AddCTS(stbl, sampleNumber, CTS);\n\t\t}\n\t}\n\t//do we have a sync ???\n\tif (stbl->SyncSample) {\n\t\tstbl_SetSampleRAP(stbl->SyncSample, sampleNumber, isRap);\n\t} else {\n\t\t//do we need one\n\t\tif (! isRap) {\n\t\t\tstbl->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\t\t\tif (!stbl->SyncSample) return GF_OUT_OF_MEM;\n\t\t\t//what a pain: all the sample we had have to be sync ...\n\t\t\tfor (i=0; i<stbl->SampleSize->sampleCount; i++) {\n\t\t\t\tif (i+1 != sampleNumber) stbl_AddRAP(stbl->SyncSample, i+1);\n\t\t\t}\n\t\t}\n\t}\n\tif (isRap==2) {\n\t\tstbl_SetRedundant(stbl, sampleNumber);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err Media_UpdateSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample *sample, Bool data_only)\n{\n\tGF_Err e;\n\tu32 drefIndex, chunkNum, descIndex;\n\tu64 newOffset, DTS;\n\tGF_DataEntryURLBox *Dentry;\n\tGF_SampleTableBox *stbl;\n\n\tif (!mdia || !sample || !sampleNumber || !mdia->mediaTrack->moov->mov->editFileMap)\n\t\treturn GF_BAD_PARAM;\n\n\tstbl = mdia->information->sampleTable;\n\n\tif (!data_only) {\n\t\t//check we have the sampe dts\n\t\te = stbl_GetSampleDTS(stbl->TimeToSample, sampleNumber, &DTS);\n\t\tif (e) return e;\n\t\tif (DTS != sample->DTS) return GF_BAD_PARAM;\n\t}\n\n\t//get our infos\n\tstbl_GetSampleInfos(stbl, sampleNumber, &newOffset, &chunkNum, &descIndex, NULL);\n\n\t//then check the data ref\n\te = Media_GetSampleDesc(mdia, descIndex, NULL, &drefIndex);\n\tif (e) return e;\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, drefIndex - 1);\n\tif (!Dentry) return GF_ISOM_INVALID_FILE;\n\n\tif (Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//MEDIA DATA EDIT: write this new sample to the edit temp file\n\tnewOffset = gf_isom_datamap_get_offset(mdia->mediaTrack->moov->mov->editFileMap);\n\tif (sample->dataLength) {\n\t\te = gf_isom_datamap_add_data(mdia->mediaTrack->moov->mov->editFileMap, sample->data, sample->dataLength);\n\t\tif (e) return e;\n\t}\n\n\tif (data_only) {\n\t\tstbl_SetSampleSize(stbl->SampleSize, sampleNumber, sample->dataLength);\n\t\treturn stbl_SetChunkOffset(mdia, sampleNumber, newOffset);\n\t}\n\treturn UpdateSample(mdia, sampleNumber, sample->dataLength, sample->CTS_Offset, newOffset, sample->IsRAP);\n}\n\nGF_Err Media_UpdateSampleReference(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample *sample, u64 data_offset)\n{\n\tGF_Err e;\n\tu32 drefIndex, chunkNum, descIndex;\n\tu64 off, DTS;\n\tGF_DataEntryURLBox *Dentry;\n\tGF_SampleTableBox *stbl;\n\n\tif (!mdia) return GF_BAD_PARAM;\n\tstbl = mdia->information->sampleTable;\n\n\t//check we have the sampe dts\n\te = stbl_GetSampleDTS(stbl->TimeToSample, sampleNumber, &DTS);\n\tif (e) return e;\n\tif (DTS != sample->DTS) return GF_BAD_PARAM;\n\n\t//get our infos\n\tstbl_GetSampleInfos(stbl, sampleNumber, &off, &chunkNum, &descIndex, NULL);\n\n\t//then check the data ref\n\te = Media_GetSampleDesc(mdia, descIndex, NULL, &drefIndex);\n\tif (e) return e;\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, drefIndex - 1);\n\tif (!Dentry) return GF_ISOM_INVALID_FILE;\n\n\t//we only modify self-contained data\n\tif (Dentry->flags == 1) return GF_ISOM_INVALID_MODE;\n\n\t//and we don't modify the media data\n\treturn UpdateSample(mdia, sampleNumber, sample->dataLength, sample->CTS_Offset, data_offset, sample->IsRAP);\n}\n\n\n#endif\t/*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2019\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n#include <gpac/avparse.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\nGF_Err Media_GetSampleDesc(GF_MediaBox *mdia, u32 SampleDescIndex, GF_SampleEntryBox **out_entry, u32 *dataRefIndex)\n{\n\tGF_SampleDescriptionBox *stsd;\n\tGF_SampleEntryBox *entry = NULL;\n\n\tif (!mdia) return GF_ISOM_INVALID_FILE;\n\n\tstsd = mdia->information->sampleTable->SampleDescription;\n\tif (!stsd) return GF_ISOM_INVALID_FILE;\n\tif (!SampleDescIndex || (SampleDescIndex > gf_list_count(stsd->child_boxes)) ) return GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, SampleDescIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\n\tif (out_entry) *out_entry = entry;\n\tif (dataRefIndex) *dataRefIndex = entry->dataReferenceIndex;\n\treturn GF_OK;\n}\n\nGF_Err Media_GetSampleDescIndex(GF_MediaBox *mdia, u64 DTS, u32 *sampleDescIndex)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber, num;\n\tu64 offset;\n\tif (sampleDescIndex == NULL) return GF_BAD_PARAM;\n\n\t//find the sample for this time\n\te = stbl_findEntryForTime(mdia->information->sampleTable, (u32) DTS, 0, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\t//we have to assume the track was created to be used... If we have a sampleDesc, OK\n\t\tif (gf_list_count(mdia->information->sampleTable->SampleDescription->child_boxes)) {\n\t\t\t(*sampleDescIndex) = 1;\n\t\t\treturn GF_OK;\n\t\t}\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn stbl_GetSampleInfos(mdia->information->sampleTable, ( sampleNumber ? sampleNumber : prevSampleNumber), &offset, &num, sampleDescIndex, NULL);\n}\n\nstatic GF_Err gf_isom_get_3gpp_audio_esd(GF_SampleTableBox *stbl, u32 type, GF_GenericAudioSampleEntryBox *entry, GF_ESD **out_esd)\n{\n\t(*out_esd) = gf_odf_desc_esd_new(2);\n\t(*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t/*official mapping to MPEG-4*/\n\tswitch (type) {\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_EVRC;\n\t\treturn GF_OK;\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t{\n\t\tu32 block_size, sample_rate, sample_size, i;\n\t\tGF_SttsEntry *ent;\n\t\tGF_BitStream *bs;\n\t\tchar szName[80];\n\t\t/*only map CBR*/\n\t\tsample_size = stbl->SampleSize->sampleSize;\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_QCELP;\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_data(bs, \"QLCMfmt \", 8);\n\t\tgf_bs_write_u32_le(bs, 150);/*fmt chunk size*/\n\t\tgf_bs_write_u8(bs, 1);\n\t\tgf_bs_write_u8(bs, 0);\n\t\t/*QCELP GUID*/\n\t\tgf_bs_write_data(bs, \"\\x41\\x6D\\x7F\\x5E\\x15\\xB1\\xD0\\x11\\xBA\\x91\\x00\\x80\\x5F\\xB4\\xB9\\x7E\", 16);\n\t\tgf_bs_write_u16_le(bs, 1);\n\t\tmemset(szName, 0, 80);\n\t\tstrcpy(szName, \"QCELP-13K(GPAC-emulated)\");\n\t\tgf_bs_write_data(bs, szName, 80);\n\t\tent = &stbl->TimeToSample->entries[0];\n\t\tsample_rate = entry->samplerate_hi;\n\t\tblock_size = ent ? ent->sampleDelta : 160;\n\t\tgf_bs_write_u16_le(bs, 8*sample_size*sample_rate/block_size);\n\t\tgf_bs_write_u16_le(bs, sample_size);\n\t\tgf_bs_write_u16_le(bs, block_size);\n\t\tgf_bs_write_u16_le(bs, sample_rate);\n\t\tgf_bs_write_u16_le(bs, entry->bitspersample);\n\t\tgf_bs_write_u32_le(bs, sample_size ? 0 : 7);\n\t\t/**/\n\t\tfor (i=0; i<7; i++) {\n\t\t\tstatic const u32 qcelp_r2s [] = {0, 1, 1, 4, 2, 8, 3, 17, 4, 35, 5, 8, 14, 1};\n\t\t\tif (sample_size) {\n\t\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, qcelp_r2s[2*i+1]);\n\t\t\t\tgf_bs_write_u8(bs, qcelp_r2s[2*i]);\n\t\t\t}\n\t\t}\n\t\tgf_bs_write_u16(bs, 0);\n\t\tmemset(szName, 0, 80);\n\t\tgf_bs_write_data(bs, szName, 20);/*reserved*/\n\t\tgf_bs_get_content(bs, & (*out_esd)->decoderConfig->decoderSpecificInfo->data, & (*out_esd)->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_bs_del(bs);\n\t}\n\treturn GF_OK;\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_SMV;\n\t\treturn GF_OK;\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_AMR;\n\t\treturn GF_OK;\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_AMR_WB;\n\t\treturn GF_OK;\n\tdefault:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] unsupported sample description type %s\\n\", gf_4cc_to_str(entry->type)));\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err Media_GetESD(GF_MediaBox *mdia, u32 sampleDescIndex, GF_ESD **out_esd, Bool true_desc_only)\n{\n\tu32 type;\n\tGF_ESD *esd;\n\tGF_MPEGSampleEntryBox *entry = NULL;\n\tGF_ESDBox *ESDa;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\tGF_SampleDescriptionBox *stsd = mdia->information->sampleTable->SampleDescription;\n\n\t*out_esd = NULL;\n\tif (!stsd || !stsd->child_boxes || !sampleDescIndex || (sampleDescIndex > gf_list_count(stsd->child_boxes)) )\n\t\treturn GF_BAD_PARAM;\n\n\tesd = NULL;\n\tentry = (GF_MPEGSampleEntryBox*)gf_list_get(stsd->child_boxes, sampleDescIndex - 1);\n\tif (! entry) return GF_ISOM_INVALID_MEDIA;\n\n\t*out_esd = NULL;\n\tESDa = NULL;\n\ttype = entry->type;\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\tcase GF_ISOM_BOX_TYPE_ENCF:\n\tcase GF_ISOM_BOX_TYPE_ENCM:\n\tcase GF_ISOM_BOX_TYPE_ENCT:\n\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\tif (sinf && sinf->original_format) {\n\t\t\ttype = sinf->original_format->data_format;\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RINF);\n\t\tif (sinf && sinf->original_format) {\n\t\t\ttype = sinf->original_format->data_format;\n\t\t}\n\t\tbreak;\n\t}\n\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tESDa = ((GF_MPEGVisualSampleEntryBox*)entry)->esd;\n\t\tif (ESDa) esd = (GF_ESD *) ESDa->desc;\n\t\t/*avc1 encrypted*/\n\t\telse esd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\tcase GF_ISOM_BOX_TYPE_264B:\n\tcase GF_ISOM_BOX_TYPE_265B:\n\tcase GF_ISOM_BOX_TYPE_DVHE:\n\tcase GF_ISOM_BOX_TYPE_VVC1:\n\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif ((mdia->mediaTrack->extractor_mode & 0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT)\n\t\t\tAVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, mdia);\n\t\telse\n\t\t\tAVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, NULL);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif ((mdia->mediaTrack->extractor_mode & 0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT)\n\t\t\tHEVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, mdia);\n\t\telse\n\t\t\tHEVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, NULL);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tAV1_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*)entry, mdia);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*)entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VP08:\n\tcase GF_ISOM_BOX_TYPE_VP09:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tVP9_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*)entry, mdia);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*)entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n        {\n            GF_MPEGAudioSampleEntryBox *ase = (GF_MPEGAudioSampleEntryBox*)entry;\n            ESDa = ase->esd;\n            if (ESDa) {\n\t\t\t\tesd = (GF_ESD *) ESDa->desc;\n            } else if (!true_desc_only) {\n\t\t\t\tBool make_mp4a = GF_FALSE;\n\t\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\t\t\tif (sinf && sinf->original_format) {\n\t\t\t\t\tif (sinf->original_format->data_format==GF_ISOM_BOX_TYPE_MP4A) {\n\t\t\t\t\t\tmake_mp4a = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Assuming that if no ESD is provided the stream is Basic MPEG-4 AAC LC\n\t\t\t\t\tmake_mp4a = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (make_mp4a) {\n\t\t\t\t\tGF_M4ADecSpecInfo aacinfo;\n\t\t\t\t\tmemset(&aacinfo, 0, sizeof(GF_M4ADecSpecInfo));\n\t\t\t\t\taacinfo.nb_chan = ase->channel_count;\n\t\t\t\t\taacinfo.base_object_type = GF_M4A_AAC_LC;\n\t\t\t\t\taacinfo.base_sr = ase->samplerate_hi;\n\t\t\t\t\t*out_esd = gf_odf_desc_esd_new(0);\n\t\t\t\t\t(*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t\t\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_AAC_MPEG4;\n\t\t\t\t\tgf_m4a_write_config(&aacinfo, &(*out_esd)->decoderConfig->decoderSpecificInfo->data, &(*out_esd)->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\t\t}\n            }\n        }\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (entry->internal_type==GF_ISOM_SAMPLE_ENTRY_MP4S) {\n\t\t\tESDa = entry->esd;\n\t\t\tif (ESDa) esd = (GF_ESD *) ESDa->desc;\n\t\t}\n\t\tbreak;\n#ifndef GPAC_DISABLE_TTXT\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_MP4S)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\n\t\tif (!true_desc_only && mdia->mediaTrack->moov->mov->convert_streaming_text) {\n\t\t\tGF_Err e = gf_isom_get_ttxt_esd(mdia, out_esd);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n#endif\n#ifndef GPAC_DISABLE_VTT\n\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_MP4S)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t{\n\t\tGF_WebVTTSampleEntryBox*vtte = (GF_WebVTTSampleEntryBox*)entry;\n\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t*out_esd = esd;\n\t\tesd->decoderConfig->streamType = GF_STREAM_TEXT;\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_WEBVTT;\n\t\tif (vtte->config) {\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = (u32) strlen(vtte->config->string);\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = gf_malloc(sizeof(char)*esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tmemcpy(esd->decoderConfig->decoderSpecificInfo->data, vtte->config->string, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t}\n\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STPP:\n\tcase GF_ISOM_BOX_TYPE_SBTT:\n\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\tbreak;\n#endif\n\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (!true_desc_only) {\n\t\t\tGF_Err e = gf_isom_get_3gpp_audio_esd(mdia->information->sampleTable, type, (GF_GenericAudioSampleEntryBox*)entry, out_esd);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t} else return GF_ISOM_INVALID_MEDIA;\n\n\tcase GF_ISOM_SUBTYPE_OPUS:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t{\n\t\tGF_OpusSpecificBox *e = ((GF_MPEGAudioSampleEntryBox*)entry)->cfg_opus;\n\t\tGF_BitStream *bs_out;\n\t\tif (!e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"ESD not found for Opus\\n)\"));\n\t\t\tbreak;\n\t\t}\n\n\t\t*out_esd = gf_odf_desc_esd_new(2);\n\t\t(*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_OPUS;\n\n\t\t//serialize box with header - compatibility with ffmpeg\n\t\tbs_out = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_isom_box_size((GF_Box *) e);\n\t\tgf_isom_box_write((GF_Box *) e, bs_out);\n\t\tgf_bs_get_content(bs_out, & (*out_esd)->decoderConfig->decoderSpecificInfo->data, & (*out_esd)->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_bs_del(bs_out);\n\t\tbreak;\n\t}\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_H263;\n\t\t\tbreak;\n\t\t}\n\n\tcase GF_ISOM_SUBTYPE_MP3:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_MPEG_AUDIO;\n\t\t\tbreak;\n\t\t}\n\n\tcase GF_ISOM_SUBTYPE_LSR1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_MP4S)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tGF_LASeRSampleEntryBox*ptr = (GF_LASeRSampleEntryBox*)entry;\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_SCENE;\n\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_LASER;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = ptr->lsr_config->hdr_size;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = gf_malloc(sizeof(char)*ptr->lsr_config->hdr_size);\n\t\t\tif (!esd->decoderConfig->decoderSpecificInfo->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(esd->decoderConfig->decoderSpecificInfo->data, ptr->lsr_config->hdr, sizeof(char)*ptr->lsr_config->hdr_size);\n\t\t\tbreak;\n\t\t}\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA2:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM2:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tGF_MPEGAudioSampleEntryBox*ptr = (GF_MPEGAudioSampleEntryBox*)entry;\n\t\t\tesd = gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t\tif ((type==GF_ISOM_SUBTYPE_MH3D_MHA1) || (type==GF_ISOM_SUBTYPE_MH3D_MHA2))\n\t\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_MPHA;\n\t\t\telse\n\t\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_MHAS;\n\t\t\tif (ptr->cfg_mha) {\n\t\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\tgf_bs_write_u8(bs, ptr->cfg_mha->configuration_version);\n\t\t\t\tgf_bs_write_u8(bs, ptr->cfg_mha->mha_pl_indication);\n\t\t\t\tgf_bs_write_u8(bs, ptr->cfg_mha->reference_channel_layout);\n\t\t\t\tgf_bs_write_u16(bs, ptr->cfg_mha->mha_config ? ptr->cfg_mha->mha_config_size : 0);\n\t\t\t\tif (ptr->cfg_mha->mha_config && ptr->cfg_mha->mha_config_size)\n\t\t\t\t\tgf_bs_write_data(bs, ptr->cfg_mha->mha_config, ptr->cfg_mha->mha_config_size);\n\n\t\t\t\tgf_bs_get_content(bs, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn GF_ISOM_INVALID_MEDIA;\n\t}\n\n\tif (true_desc_only) {\n\t\tif (!esd) return GF_ISOM_INVALID_MEDIA;\n\t\t*out_esd = esd;\n\t\treturn GF_OK;\n\t} else {\n\t\tif (!esd && !*out_esd) return GF_ISOM_INVALID_MEDIA;\n\t\tif (*out_esd == NULL) return gf_odf_desc_copy((GF_Descriptor *)esd, (GF_Descriptor **)out_esd);\n\t}\n\treturn GF_OK;\n}\n\nBool Media_IsSampleSyncShadow(GF_ShadowSyncBox *stsh, u32 sampleNumber)\n{\n\tu32 i;\n\tGF_StshEntry *ent;\n\tif (!stsh) return 0;\n\ti=0;\n\twhile ((ent = (GF_StshEntry*)gf_list_enum(stsh->entries, &i))) {\n\t\tif ((u32) ent->syncSampleNumber == sampleNumber) return 1;\n\t\telse if ((u32) ent->syncSampleNumber > sampleNumber) return 0;\n\t}\n\treturn 0;\n}\n\nGF_Err Media_GetSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample **samp, u32 *sIDX, Bool no_data, u64 *out_offset)\n{\n\tGF_Err e;\n\tu32 bytesRead;\n\tu32 dataRefIndex, chunkNumber;\n\tu64 offset, new_size;\n\tu32 sdesc_idx;\n\tGF_SampleEntryBox *entry;\n\tGF_StscEntry *stsc_entry;\n\n\tif (!mdia || !mdia->information->sampleTable) return GF_BAD_PARAM;\n\tif (!mdia->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\t//OK, here we go....\n\tif (sampleNumber > mdia->information->sampleTable->SampleSize->sampleCount) return GF_BAD_PARAM;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n\n\te = stbl_GetSampleInfos(mdia->information->sampleTable, sampleNumber, &offset, &chunkNumber, &sdesc_idx, &stsc_entry);\n\tif (e) return e;\n\tif (sIDX) (*sIDX) = sdesc_idx;\n\n\tif (out_offset) *out_offset = offset;\n\tif (!samp ) return GF_OK;\n\n\tif (mdia->information->sampleTable->TimeToSample) {\n\t\t//get the DTS\n\t\te = stbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber, &(*samp)->DTS);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->DTS=0;\n\t}\n\t//the CTS offset\n\tif (mdia->information->sampleTable->CompositionOffset) {\n\t\te = stbl_GetSampleCTS(mdia->information->sampleTable->CompositionOffset , sampleNumber, &(*samp)->CTS_Offset);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->CTS_Offset = 0;\n\t}\n\t//the size\n\te = stbl_GetSampleSize(mdia->information->sampleTable->SampleSize, sampleNumber, &(*samp)->dataLength);\n\tif (e) return e;\n\t//the RAP\n\tif (mdia->information->sampleTable->SyncSample) {\n\t\te = stbl_GetSampleRAP(mdia->information->sampleTable->SyncSample, sampleNumber, &(*samp)->IsRAP, NULL, NULL);\n\t\tif (e) return e;\n\t} else {\n\t\t//if no SyncSample, all samples are sync (cf spec)\n\t\t(*samp)->IsRAP = RAP;\n\t}\n\n\tif (mdia->information->sampleTable->SampleDep) {\n\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\t\te = stbl_GetSampleDepType(mdia->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\tif (!e) {\n\t\t\tif (dependsOn==1) (*samp)->IsRAP = RAP_NO;\n\t\t\t//commenting following code since it is wrong - an I frame is not always a SAP1, it can be a SAP2 or SAP3.\n\t\t\t//Keeping this code breaks AVC / HEVC openGOP import when writing sample dependencies\n\t\t\t//else if (dependsOn==2) (*samp)->IsRAP = RAP;\n\n\t\t\t/*if not depended upon and redundant, mark as carousel sample*/\n\t\t\tif ((dependedOn==2) && (redundant==1)) (*samp)->IsRAP = RAP_REDUNDANT;\n\t\t\t/*TODO FIXME - we must enhance the IsRAP semantics to carry disposable info ... */\n\t\t}\n\t}\n\n\t/*get sync shadow*/\n\tif (Media_IsSampleSyncShadow(mdia->information->sampleTable->ShadowSync, sampleNumber)) (*samp)->IsRAP = RAP_REDUNDANT;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n\tif (!sIDX && !out_offset) return GF_OK;\n\tif (!sIDX) return GF_OK;\n\n\t(*sIDX) = sdesc_idx;\n//\te = stbl_GetSampleInfos(mdia->information->sampleTable, sampleNumber, &offset, &chunkNumber, sIDX, &stsc_entry);\n//\tif (e) return e;\n\n\t//then get the DataRef\n\te = Media_GetSampleDesc(mdia, sdesc_idx, &entry, &dataRefIndex);\n\tif (e) return e;\n\n\t//if moov is compressed, remove offset if sample is after moov in this file\n\tif (mdia->mediaTrack->moov->compressed_diff) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1) && (offset>=mdia->mediaTrack->moov->file_offset)) {\n\t\t\toffset -= mdia->mediaTrack->moov->compressed_diff;\n\t\t}\n\t}\n\n\n\tif (no_data) {\n\t\tif ( ((*samp)->dataLength != 0) && mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\t(*samp)->dataLength *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t// Open the data handler - check our mode, don't reopen in read only if this is\n\t//the same entry. In other modes we have no choice because the main data map is\n\t//divided into the original and the edition files\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_READ) {\n\t\t//same as last call in read mode\n\t\tif (!mdia->information->dataHandler) {\n\t\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\t\tif (e) return e;\n\t\t}\n\t\tmdia->information->dataEntryIndex = dataRefIndex;\n\t} else {\n\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\tif (e) return e;\n\t}\n\n\tif ( mdia->mediaTrack->moov->mov->read_byte_offset || mdia->mediaTrack->moov->mov->bytes_removed) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1)) {\n\t\t\tu64 real_offset = mdia->mediaTrack->moov->mov->read_byte_offset + mdia->mediaTrack->moov->mov->bytes_removed;\n\t\t\tif (offset < real_offset)\n\t\t\t\treturn GF_IO_ERR;\n\n\t\t\tif (mdia->information->dataHandler->last_read_offset != mdia->mediaTrack->moov->mov->read_byte_offset) {\n\t\t\t\tmdia->information->dataHandler->last_read_offset = mdia->mediaTrack->moov->mov->read_byte_offset;\n\t\t\t\tgf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\t}\n\n\t\t\toffset -= real_offset;\n\t\t}\n\t}\n\tif ((*samp)->dataLength != 0) {\n\t\tif (mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\t(*samp)->dataLength *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\n\t\t/*and finally get the data, include padding if needed*/\n\t\tif ((*samp)->alloc_size) {\n\t\t\tif ((*samp)->alloc_size < (*samp)->dataLength + mdia->mediaTrack->padding_bytes) {\n\t\t\t\t(*samp)->data = (char *) gf_realloc((*samp)->data, sizeof(char) * ( (*samp)->dataLength + mdia->mediaTrack->padding_bytes) );\n\t\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\n\t\t\t\t(*samp)->alloc_size = (*samp)->dataLength + mdia->mediaTrack->padding_bytes;\n\t\t\t}\n\t\t} else {\n\t\t\t(*samp)->data = (char *) gf_malloc(sizeof(char) * ( (*samp)->dataLength + mdia->mediaTrack->padding_bytes) );\n\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (mdia->mediaTrack->padding_bytes)\n\t\t\tmemset((*samp)->data + (*samp)->dataLength, 0, sizeof(char) * mdia->mediaTrack->padding_bytes);\n\n\t\t//check if we can get the sample (make sure we have enougth data...)\n\t\tnew_size = gf_bs_get_size(mdia->information->dataHandler->bs);\n\t\tif (offset + (*samp)->dataLength > new_size) {\n\t\t\t//always refresh the size to avoid wrong info on http/ftp\n\t\t\tnew_size = gf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\tif (offset + (*samp)->dataLength > new_size) {\n\t\t\t\tmdia->BytesMissing = offset + (*samp)->dataLength - new_size;\n\t\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t\t}\n\t\t}\n\n\t\tbytesRead = gf_isom_datamap_get_data(mdia->information->dataHandler, (*samp)->data, (*samp)->dataLength, offset);\n\t\t//if bytesRead != sampleSize, we have an IO err\n\t\tif (bytesRead < (*samp)->dataLength) {\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tmdia->BytesMissing = 0;\n\t}\n\n\t//finally rewrite the sample if this is an OD Access Unit or NAL-based one\n\t//we do this even if sample size is zero because of sample implicit reconstruction rules (especially tile tracks)\n\tif (mdia->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tif (!mdia->mediaTrack->moov->mov->disable_odf_translate) {\n\t\t\te = Media_RewriteODFrame(mdia, *samp);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\telse if (gf_isom_is_nalu_based_entry(mdia, entry)\n\t\t&& !gf_isom_is_encrypted_entry(entry->type)\n\t) {\n\t\te = gf_isom_nalu_sample_rewrite(mdia, *samp, sampleNumber, (GF_MPEGVisualSampleEntryBox *)entry);\n\t\tif (e) return e;\n\t}\n\telse if (mdia->mediaTrack->moov->mov->convert_streaming_text\n\t         && ((mdia->handler->handlerType == GF_ISOM_MEDIA_TEXT) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SCENE) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SUBT))\n\t         && (entry->type == GF_ISOM_BOX_TYPE_TX3G || entry->type == GF_ISOM_BOX_TYPE_TEXT)\n\t        ) {\n\t\tu64 dur;\n\t\tif (sampleNumber == mdia->information->sampleTable->SampleSize->sampleCount) {\n\t\t\tdur = mdia->mediaHeader->duration - (*samp)->DTS;\n\t\t} else {\n\t\t\tstbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber+1, &dur);\n\t\t\tdur -= (*samp)->DTS;\n\t\t}\n\t\te = gf_isom_rewrite_text_sample(*samp, sdesc_idx, (u32) dur);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n\n\nGF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex)\n{\n\tGF_DataEntryURLBox *entry;\n\tGF_DataMap *map;\n\tGF_Err e;\n\tif (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM;\n\n\tentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\tif (entry->flags == 1) return GF_OK;\n\n\t//ok, not self contained, let's go for it...\n\t//we only support alias and URL boxes\n\tif ((entry->type != GF_ISOM_BOX_TYPE_URL) && (entry->type != GF_QT_BOX_TYPE_ALIS) )\n\t\treturn GF_NOT_SUPPORTED;\n\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) {\n\t\te = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map);\n\t} else {\n\t\te = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map);\n\t}\n\tif (e) return e;\n\tgf_isom_datamap_del(map);\n\treturn GF_OK;\n}\n\n\nBool Media_IsSelfContained(GF_MediaBox *mdia, u32 StreamDescIndex)\n{\n\tu32 drefIndex=0;\n\tGF_FullBox *a=NULL;\n\tGF_SampleEntryBox *se = NULL;\n\n\tMedia_GetSampleDesc(mdia, StreamDescIndex, &se, &drefIndex);\n\tif (!drefIndex) return 0;\n\tif (mdia\n\t\t&& mdia->information\n\t\t&& mdia->information->dataInformation\n\t\t&& mdia->information->dataInformation->dref\n\t) {\n\t\ta = (GF_FullBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, drefIndex - 1);\n\t}\n\tif (!a) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] broken file: Data reference index set to %d but no data reference entry found\\n\", drefIndex));\n\t\treturn 1;\n\t}\n\tif (a->flags & 1) return 1;\n\t/*QT specific*/\n\tif (a->type == GF_QT_BOX_TYPE_ALIS) return 1;\n\treturn 0;\n}\n\nGF_ISOMDataRefAllType Media_SelfContainedType(GF_MediaBox *mdia)\n{\n\tu32 nb_ext, nb_self;\n\tu32 i, count;\n\n\tnb_ext = nb_self = 0;\n\tcount = mdia->information->sampleTable->SampleDescription ? gf_list_count(mdia->information->sampleTable->SampleDescription->child_boxes) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tif (Media_IsSelfContained(mdia, i+1)) nb_self++;\n\t\telse nb_ext++;\n\t}\n\tif (nb_ext==count) return ISOM_DREF_EXT;\n\tif (nb_self==count) return ISOM_DREF_SELF;\n\treturn ISOM_DREF_MIXED;\n}\n\n\n\n//look for a sync sample from a given point in media time\nGF_Err Media_FindSyncSample(GF_SampleTableBox *stbl, u32 searchFromSample, u32 *sampleNumber, u8 mode)\n{\n\tGF_ISOSAPType isRAP;\n\tu32 next, prev, next_in_sap, prev_in_sap;\n\tif (!stbl || !stbl->SyncSample) return GF_BAD_PARAM;\n\n\t//set to current sample if we don't find a RAP\n\t*sampleNumber = searchFromSample;\n\n\t//this is not the exact sample, but the prev move to next sample if enough samples....\n\tif ( (mode == GF_ISOM_SEARCH_SYNC_FORWARD) && (searchFromSample == stbl->SampleSize->sampleCount) ) {\n\t\treturn GF_OK;\n\t}\n\tif ( (mode == GF_ISOM_SEARCH_SYNC_BACKWARD) && !searchFromSample) {\n\t\t*sampleNumber = 1;\n\t\treturn GF_OK;\n\t}\n\t//get the entry\n\tstbl_GetSampleRAP(stbl->SyncSample, searchFromSample, &isRAP, &prev, &next);\n\tif (isRAP) {\n\t\t(*sampleNumber) = searchFromSample;\n\t\treturn GF_OK;\n\t}\n\n\t/*check sample groups - prev & next are overwritten if RAP group is found, but are not re-initialized otherwise*/\n\tstbl_SearchSAPs(stbl, searchFromSample, &isRAP, &prev_in_sap, &next_in_sap);\n\tif (isRAP) {\n\t\t(*sampleNumber) = searchFromSample;\n\t\treturn GF_OK;\n\t}\n\n\tif (prev_in_sap > prev)\n\t\tprev = prev_in_sap;\n\tif (next_in_sap && next_in_sap < next)\n\t\tnext = next_in_sap;\n\n\t//nothing yet, go for next time...\n\tif (mode == GF_ISOM_SEARCH_SYNC_FORWARD) {\n\t\tif (next) *sampleNumber = next;\n\t} else {\n\t\tif (prev) *sampleNumber = prev;\n\t}\n\n\treturn GF_OK;\n}\n\n//create a DataReference if not existing (only for WRITE-edit mode)\nGF_Err Media_FindDataRef(GF_DataReferenceBox *dref, char *URLname, char *URNname, u32 *dataRefIndex)\n{\n\tu32 i;\n\tGF_DataEntryURLBox *entry;\n\n\tif (!dref) return GF_BAD_PARAM;\n\t*dataRefIndex = 0;\n\ti=0;\n\twhile ((entry = (GF_DataEntryURLBox*)gf_list_enum(dref->child_boxes, &i))) {\n\t\tif (entry->type == GF_ISOM_BOX_TYPE_URL) {\n\t\t\t//self-contained case\n\t\t\tif (entry->flags == 1) {\n\t\t\t\t//if nothing specified, get the dataRef\n\t\t\t\tif (!URLname && !URNname) {\n\t\t\t\t\t*dataRefIndex = i;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//OK, check if we have URL\n\t\t\t\tif (URLname && !strcmp(URLname, entry->location)) {\n\t\t\t\t\t*dataRefIndex = i;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t//this is a URN one, only check the URN name (URL optional)\n\t\t\tif (URNname && !strcmp(URNname, ((GF_DataEntryURNBox *)entry)->nameURN)) {\n\t\t\t\t*dataRefIndex = i;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n//Get the total media duration based on the TimeToSample table\nGF_Err Media_SetDuration(GF_TrackBox *trak)\n{\n\tGF_Err e;\n\tGF_ESD *esd;\n\tu64 DTS;\n\tGF_SttsEntry *ent;\n\tu32 nbSamp;\n\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tif (!trak->Media->information->sampleTable->SampleSize || !trak->Media->information->sampleTable->TimeToSample)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tnbSamp = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\n\t//we need to check how many samples we have.\n\t// == 1 -> last sample duration == default duration\n\t// > 1 -> last sample duration == prev sample duration\n\tswitch (nbSamp) {\n\tcase 0:\n\t\ttrak->Media->mediaHeader->duration = 0;\n\t\tif (Track_IsMPEG4Stream(trak->Media->handler->handlerType)) {\n\t\t\tMedia_GetESD(trak->Media, 1, &esd, 1);\n\t\t\tif (esd && esd->URLString) trak->Media->mediaHeader->duration = (u64) -1;\n\n\t\t}\n\t\treturn GF_OK;\n\n//\tcase 1:\n//\t\ttrak->Media->mediaHeader->duration = trak->Media->mediaHeader->timeScale;\n//\t\treturn GF_OK;\n\n\tdefault:\n\t\t//we assume a constant frame rate for the media and assume the last sample\n\t\t//will be hold the same time as the prev one\n\t\te = stbl_GetSampleDTS(trak->Media->information->sampleTable->TimeToSample, nbSamp, &DTS);\n\t\tif (e < 0) {\n\t\t\treturn e;\n\t\t}\n\t\tif (trak->Media->information->sampleTable->TimeToSample->nb_entries > 0) {\n\t\t\tent = &trak->Media->information->sampleTable->TimeToSample->entries[trak->Media->information->sampleTable->TimeToSample->nb_entries-1];\n\t\t} else {\n\t\t\tent = NULL;\n\t\t}\n\t\ttrak->Media->mediaHeader->duration = DTS;\n\n\n#if 1\n\t\tif (ent) trak->Media->mediaHeader->duration += ent->sampleDelta;\n#else\n\t\tif (!ent) {\n\t\t\tu64 DTSprev;\n\t\t\tstbl_GetSampleDTS(trak->Media->information->sampleTable->TimeToSample, nbSamp-1, &DTSprev);\n\t\t\ttrak->Media->mediaHeader->duration += (DTS - DTSprev);\n\t\t} else {\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\t\tif (trak->moov->mov->editFileMap && trak->Media->information->sampleTable->CompositionOffset) {\n\t\t\t\tu32 count, i;\n\t\t\t\tu64 max_ts;\n\t\t\t\tGF_DttsEntry *cts_ent;\n\t\t\t\tGF_CompositionOffsetBox *ctts = trak->Media->information->sampleTable->CompositionOffset;\n\t\t\t\tif (ctts->w_LastSampleNumber==nbSamp) {\n\t\t\t\t\tcount = gf_list_count(ctts->entryList);\n\t\t\t\t\tmax_ts = trak->Media->mediaHeader->duration;\n\t\t\t\t\twhile (count) {\n\t\t\t\t\t\tcount -= 1;\n\t\t\t\t\t\tcts_ent = gf_list_get(ctts->entryList, count);\n\t\t\t\t\t\tif (nbSamp<cts_ent->sampleCount) break;\n\n\t\t\t\t\t\tfor (i=0; i<cts_ent->sampleCount; i++) {\n\t\t\t\t\t\t\tstbl_GetSampleDTS(trak->Media->information->sampleTable->TimeToSample, nbSamp-i, &DTS);\n\t\t\t\t\t\t\tif ((s32) cts_ent->decodingOffset < 0) max_ts = DTS;\n\t\t\t\t\t\t\telse max_ts = DTS + cts_ent->decodingOffset;\n\t\t\t\t\t\t\tif (max_ts>=trak->Media->mediaHeader->duration) {\n\t\t\t\t\t\t\t\ttrak->Media->mediaHeader->duration = max_ts;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (max_ts<trak->Media->mediaHeader->duration) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnbSamp-=cts_ent->sampleCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\t\t\ttrak->Media->mediaHeader->duration += ent->sampleDelta;\n\t\t}\n#endif\n\t\treturn GF_OK;\n\t}\n}\n\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err Media_SetDrefURL(GF_DataEntryURLBox *dref_entry, const char *origName, const char *finalName)\n{\n\t//for now we only support dref created in same folder for relative URLs\n\tif (strstr(origName, \"://\") || ((origName[1]==':') && (origName[2]=='\\\\'))\n\t\t|| (origName[0]=='/') || (origName[0]=='\\\\')\n\t) {\n\t\tdref_entry->location = gf_strdup(origName);\n\t} else {\n\t\tchar *fname = strrchr(origName, '/');\n\t\tif (!fname) fname = strrchr(origName, '\\\\');\n\t\tif (fname) fname++;\n\n\t\tif (!fname) {\n\t\t\tdref_entry->location = gf_strdup(origName);\n\t\t} else {\n\t\t\tu32 len = (u32) (fname - origName);\n\t\t\tif (!finalName || strncmp(origName, finalName, len)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Concatenation of relative path %s with relative path %s not supported, use absolute URLs\\n\", origName, finalName));\n\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t} else {\n\t\t\t\tdref_entry->location = gf_strdup(fname);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err Media_CreateDataRef(GF_ISOFile *movie, GF_DataReferenceBox *dref, char *URLname, char *URNname, u32 *dataRefIndex)\n{\n\tGF_Err e;\n\tBool use_alis=GF_FALSE;\n\tGF_DataEntryURLBox *entry;\n\n\tif (URLname && !strcmp(URLname, \"alis\")) {\n\t\tURLname = NULL;\n\t\tuse_alis=GF_TRUE;\n\t}\n\n\tif (!URLname && !URNname) {\n\t\t//THIS IS SELF CONTAIN, create a regular entry if needed\n\t\tentry = (GF_DataEntryURLBox *) gf_isom_box_new_parent(&dref->child_boxes, use_alis ? GF_QT_BOX_TYPE_ALIS : GF_ISOM_BOX_TYPE_URL);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\tentry->flags = 1;\n\t\t*dataRefIndex = gf_list_count(dref->child_boxes);\n\t\treturn GF_OK;\n\t} else if (!URNname && URLname) {\n\t\t//THIS IS URL\n\t\tentry = (GF_DataEntryURLBox *) gf_isom_box_new_parent(&dref->child_boxes, GF_ISOM_BOX_TYPE_URL);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\tentry->flags = 0;\n\n\t\te = Media_SetDrefURL(entry, URLname, movie->fileName ? movie->fileName : movie->finalName);\n\t\tif (! entry->location) {\n\t\t\tgf_isom_box_del_parent(&dref->child_boxes, (GF_Box *)entry);\n\t\t\treturn e ? e : GF_OUT_OF_MEM;\n\t\t}\n\t\t*dataRefIndex = gf_list_count(dref->child_boxes);\n\t\treturn GF_OK;\n\t} else {\n\t\t//THIS IS URN\n\t\tentry = (GF_DataEntryURLBox *) gf_isom_box_new_parent(&dref->child_boxes, GF_ISOM_BOX_TYPE_URN);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t((GF_DataEntryURNBox *)entry)->flags = 0;\n\t\t((GF_DataEntryURNBox *)entry)->nameURN = (char*)gf_malloc(strlen(URNname)+1);\n\t\tif (! ((GF_DataEntryURNBox *)entry)->nameURN) {\n\t\t\tgf_isom_box_del_parent(&dref->child_boxes, (GF_Box *)entry);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tstrcpy(((GF_DataEntryURNBox *)entry)->nameURN, URNname);\n\t\t//check for URL\n\t\tif (URLname) {\n\t\t\t((GF_DataEntryURNBox *)entry)->location = (char*)gf_malloc(strlen(URLname)+1);\n\t\t\tif (! ((GF_DataEntryURNBox *)entry)->location) {\n\t\t\t\tgf_isom_box_del_parent(&dref->child_boxes, (GF_Box *)entry);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tstrcpy(((GF_DataEntryURNBox *)entry)->location, URLname);\n\t\t}\n\t\t*dataRefIndex = gf_list_count(dref->child_boxes);\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err Media_AddSample(GF_MediaBox *mdia, u64 data_offset, const GF_ISOSample *sample, u32 StreamDescIndex, u32 syncShadowNumber)\n{\n\tGF_Err e;\n\tGF_SampleTableBox *stbl;\n\tu32 sampleNumber, i;\n\tif (!mdia || !sample) return GF_BAD_PARAM;\n\n\tstbl = mdia->information->sampleTable;\n\n\t//get a valid sampleNumber for this new guy\n\te = stbl_AddDTS(stbl, sample->DTS, &sampleNumber, mdia->mediaHeader->timeScale, sample->nb_pack);\n\tif (e) return e;\n\n\t//add size\n\te = stbl_AddSize(stbl->SampleSize, sampleNumber, sample->dataLength, sample->nb_pack);\n\tif (e) return e;\n\n\t//adds CTS offset\n\tif (sample->CTS_Offset) {\n\t\t//if we don't have a CTS table, add it...\n\t\tif (!stbl->CompositionOffset) {\n\t\t\tstbl->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\t\t\tif (!stbl->CompositionOffset) return GF_OUT_OF_MEM;\n\t\t}\n\t\t//then add our CTS (the prev samples with no CTS offset will be automatically added...\n\t\te = stbl_AddCTS(stbl, sampleNumber, sample->CTS_Offset);\n\t\tif (e) return e;\n\t} else if (stbl->CompositionOffset) {\n\t\te = stbl_AddCTS(stbl, sampleNumber, sample->CTS_Offset);\n\t\tif (e) return e;\n\t}\n\n\t//The first non sync sample we see must create a syncTable\n\tif (sample->IsRAP) {\n\t\t//insert it only if we have a sync table and if we have an IDR slice\n\t\tif (stbl->SyncSample && (sample->IsRAP == RAP)) {\n\t\t\te = stbl_AddRAP(stbl->SyncSample, sampleNumber);\n\t\t\tif (e) return e;\n\t\t}\n\t} else {\n\t\t//non-sync sample. Create a SyncSample table if needed\n\t\tif (!stbl->SyncSample) {\n\t\t\tstbl->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\t\t\tif (!stbl->SyncSample) return GF_OUT_OF_MEM;\n\t\t\t//all the prev samples are sync\n\t\t\tfor (i=0; i<stbl->SampleSize->sampleCount; i++) {\n\t\t\t\tif (i+1 != sampleNumber) {\n\t\t\t\t\te = stbl_AddRAP(stbl->SyncSample, i+1);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (sample->IsRAP==RAP_REDUNDANT) {\n\t\te = stbl_AddRedundant(stbl, sampleNumber);\n\t\tif (e) return e;\n\t}\n\n\tif (!mdia->mediaTrack->chunk_cache) {\n\t\t//and update the chunks\n\t\te = stbl_AddChunkOffset(mdia, sampleNumber, StreamDescIndex, data_offset, sample->nb_pack);\n\t\tif (e) return e;\n\t}\n\t\n\tif (!syncShadowNumber) return GF_OK;\n\tif (!stbl->ShadowSync) {\n\t\tstbl->ShadowSync = (GF_ShadowSyncBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSH);\n\t\tif (!stbl->ShadowSync) return GF_OUT_OF_MEM;\n\t}\n\treturn stbl_AddShadow(mdia->information->sampleTable->ShadowSync, sampleNumber, syncShadowNumber);\n}\n\n\nstatic GF_Err UpdateSample(GF_MediaBox *mdia, u32 sampleNumber, u32 size, s32 CTS, u64 offset, u8 isRap)\n{\n\tu32 i;\n\tGF_SampleTableBox *stbl = mdia->information->sampleTable;\n\n\t//set size, offset, RAP, CTS ...\n\tstbl_SetSampleSize(stbl->SampleSize, sampleNumber, size);\n\tstbl_SetChunkOffset(mdia, sampleNumber, offset);\n\n\t//do we have a CTS?\n\tif (stbl->CompositionOffset) {\n\t\tstbl_SetSampleCTS(stbl, sampleNumber, CTS);\n\t} else {\n\t\t//do we need one ??\n\t\tif (CTS) {\n\t\t\tstbl->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\t\t\tif (!stbl->CompositionOffset) return GF_OUT_OF_MEM;\n\t\t\tstbl_AddCTS(stbl, sampleNumber, CTS);\n\t\t}\n\t}\n\t//do we have a sync ???\n\tif (stbl->SyncSample) {\n\t\tstbl_SetSampleRAP(stbl->SyncSample, sampleNumber, isRap);\n\t} else {\n\t\t//do we need one\n\t\tif (! isRap) {\n\t\t\tstbl->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\t\t\tif (!stbl->SyncSample) return GF_OUT_OF_MEM;\n\t\t\t//what a pain: all the sample we had have to be sync ...\n\t\t\tfor (i=0; i<stbl->SampleSize->sampleCount; i++) {\n\t\t\t\tif (i+1 != sampleNumber) stbl_AddRAP(stbl->SyncSample, i+1);\n\t\t\t}\n\t\t}\n\t}\n\tif (isRap==2) {\n\t\tstbl_SetRedundant(stbl, sampleNumber);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err Media_UpdateSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample *sample, Bool data_only)\n{\n\tGF_Err e;\n\tu32 drefIndex, chunkNum, descIndex;\n\tu64 newOffset, DTS;\n\tGF_DataEntryURLBox *Dentry;\n\tGF_SampleTableBox *stbl;\n\n\tif (!mdia || !sample || !sampleNumber || !mdia->mediaTrack->moov->mov->editFileMap)\n\t\treturn GF_BAD_PARAM;\n\n\tstbl = mdia->information->sampleTable;\n\n\tif (!data_only) {\n\t\t//check we have the sampe dts\n\t\te = stbl_GetSampleDTS(stbl->TimeToSample, sampleNumber, &DTS);\n\t\tif (e) return e;\n\t\tif (DTS != sample->DTS) return GF_BAD_PARAM;\n\t}\n\n\t//get our infos\n\tstbl_GetSampleInfos(stbl, sampleNumber, &newOffset, &chunkNum, &descIndex, NULL);\n\n\t//then check the data ref\n\te = Media_GetSampleDesc(mdia, descIndex, NULL, &drefIndex);\n\tif (e) return e;\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, drefIndex - 1);\n\tif (!Dentry) return GF_ISOM_INVALID_FILE;\n\n\tif (Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//MEDIA DATA EDIT: write this new sample to the edit temp file\n\tnewOffset = gf_isom_datamap_get_offset(mdia->mediaTrack->moov->mov->editFileMap);\n\tif (sample->dataLength) {\n\t\te = gf_isom_datamap_add_data(mdia->mediaTrack->moov->mov->editFileMap, sample->data, sample->dataLength);\n\t\tif (e) return e;\n\t}\n\n\tif (data_only) {\n\t\tstbl_SetSampleSize(stbl->SampleSize, sampleNumber, sample->dataLength);\n\t\treturn stbl_SetChunkOffset(mdia, sampleNumber, newOffset);\n\t}\n\treturn UpdateSample(mdia, sampleNumber, sample->dataLength, sample->CTS_Offset, newOffset, sample->IsRAP);\n}\n\nGF_Err Media_UpdateSampleReference(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample *sample, u64 data_offset)\n{\n\tGF_Err e;\n\tu32 drefIndex, chunkNum, descIndex;\n\tu64 off, DTS;\n\tGF_DataEntryURLBox *Dentry;\n\tGF_SampleTableBox *stbl;\n\n\tif (!mdia) return GF_BAD_PARAM;\n\tstbl = mdia->information->sampleTable;\n\n\t//check we have the sampe dts\n\te = stbl_GetSampleDTS(stbl->TimeToSample, sampleNumber, &DTS);\n\tif (e) return e;\n\tif (DTS != sample->DTS) return GF_BAD_PARAM;\n\n\t//get our infos\n\tstbl_GetSampleInfos(stbl, sampleNumber, &off, &chunkNum, &descIndex, NULL);\n\n\t//then check the data ref\n\te = Media_GetSampleDesc(mdia, descIndex, NULL, &drefIndex);\n\tif (e) return e;\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, drefIndex - 1);\n\tif (!Dentry) return GF_ISOM_INVALID_FILE;\n\n\t//we only modify self-contained data\n\tif (Dentry->flags == 1) return GF_ISOM_INVALID_MODE;\n\n\t//and we don't modify the media data\n\treturn UpdateSample(mdia, sampleNumber, sample->dataLength, sample->CTS_Offset, data_offset, sample->IsRAP);\n}\n\n\n#endif\t/*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["src/isomedia/media.c"], "buggy_code_start_loc": [677], "buggy_code_end_loc": [690], "fixing_code_start_loc": [676], "fixing_code_end_loc": [691], "type": "CWE-787", "message": "Heap buffer overflow in the URL_GetProtocolType function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.", "other": {"cve": {"id": "CVE-2021-32137", "sourceIdentifier": "cve@mitre.org", "published": "2021-09-13T14:15:09.640", "lastModified": "2021-09-22T19:05:20.213", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap buffer overflow in the URL_GetProtocolType function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file."}, {"lang": "es", "value": "Un desbordamiento de b\u00fafer de la pila en la funci\u00f3n URL_GetProtocolType en MP4Box en GPAC versi\u00f3n 1.0.1, permite a atacantes causar una denegaci\u00f3n de servicio o ejecutar c\u00f3digo arbitrario por medio de un archivo dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/328def7d3b93847d64ecb6e9e0399684e57c3eca", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1766", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/328def7d3b93847d64ecb6e9e0399684e57c3eca"}}