{"buggy_code": ["/*\n *  linux/kernel/exit.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/completion.h>\n#include <linux/personality.h>\n#include <linux/tty.h>\n#include <linux/mnt_namespace.h>\n#include <linux/iocontext.h>\n#include <linux/key.h>\n#include <linux/security.h>\n#include <linux/cpu.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/binfmts.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/ptrace.h>\n#include <linux/profile.h>\n#include <linux/mount.h>\n#include <linux/proc_fs.h>\n#include <linux/kthread.h>\n#include <linux/mempolicy.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/signal.h>\n#include <linux/posix-timers.h>\n#include <linux/cn_proc.h>\n#include <linux/mutex.h>\n#include <linux/futex.h>\n#include <linux/compat.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/resource.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/tracehook.h>\n#include <trace/sched.h>\n\n#include <asm/uaccess.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n\nstatic void exit_mm(struct task_struct * tsk);\n\nstatic inline int task_detached(struct task_struct *p)\n{\n\treturn p->exit_signal == -1;\n}\n\nstatic void __unhash_process(struct task_struct *p)\n{\n\tnr_threads--;\n\tdetach_pid(p, PIDTYPE_PID);\n\tif (thread_group_leader(p)) {\n\t\tdetach_pid(p, PIDTYPE_PGID);\n\t\tdetach_pid(p, PIDTYPE_SID);\n\n\t\tlist_del_rcu(&p->tasks);\n\t\t__get_cpu_var(process_counts)--;\n\t}\n\tlist_del_rcu(&p->thread_group);\n\tlist_del_init(&p->sibling);\n}\n\n/*\n * This function expects the tasklist_lock write-locked.\n */\nstatic void __exit_signal(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tstruct sighand_struct *sighand;\n\n\tBUG_ON(!sig);\n\tBUG_ON(!atomic_read(&sig->count));\n\n\tsighand = rcu_dereference(tsk->sighand);\n\tspin_lock(&sighand->siglock);\n\n\tposix_cpu_timers_exit(tsk);\n\tif (atomic_dec_and_test(&sig->count))\n\t\tposix_cpu_timers_exit_group(tsk);\n\telse {\n\t\t/*\n\t\t * If there is any task waiting for the group exit\n\t\t * then notify it:\n\t\t */\n\t\tif (sig->group_exit_task && atomic_read(&sig->count) == sig->notify_count)\n\t\t\twake_up_process(sig->group_exit_task);\n\n\t\tif (tsk == sig->curr_target)\n\t\t\tsig->curr_target = next_thread(tsk);\n\t\t/*\n\t\t * Accumulate here the counters for all threads but the\n\t\t * group leader as they die, so they can be added into\n\t\t * the process-wide totals when those are taken.\n\t\t * The group leader stays around as a zombie as long\n\t\t * as there are other threads.  When it gets reaped,\n\t\t * the exit.c code will add its counts into these totals.\n\t\t * We won't ever get here for the group leader, since it\n\t\t * will have been the last reference on the signal_struct.\n\t\t */\n\t\tsig->gtime = cputime_add(sig->gtime, task_gtime(tsk));\n\t\tsig->min_flt += tsk->min_flt;\n\t\tsig->maj_flt += tsk->maj_flt;\n\t\tsig->nvcsw += tsk->nvcsw;\n\t\tsig->nivcsw += tsk->nivcsw;\n\t\tsig->inblock += task_io_get_inblock(tsk);\n\t\tsig->oublock += task_io_get_oublock(tsk);\n\t\ttask_io_accounting_add(&sig->ioac, &tsk->ioac);\n\t\tsig = NULL; /* Marker for below. */\n\t}\n\n\t__unhash_process(tsk);\n\n\t/*\n\t * Do this under ->siglock, we can race with another thread\n\t * doing sigqueue_free() if we have SIGQUEUE_PREALLOC signals.\n\t */\n\tflush_sigqueue(&tsk->pending);\n\n\ttsk->signal = NULL;\n\ttsk->sighand = NULL;\n\tspin_unlock(&sighand->siglock);\n\n\t__cleanup_sighand(sighand);\n\tclear_tsk_thread_flag(tsk,TIF_SIGPENDING);\n\tif (sig) {\n\t\tflush_sigqueue(&sig->shared_pending);\n\t\ttaskstats_tgid_free(sig);\n\t\t/*\n\t\t * Make sure ->signal can't go away under rq->lock,\n\t\t * see account_group_exec_runtime().\n\t\t */\n\t\ttask_rq_unlock_wait(tsk);\n\t\t__cleanup_signal(sig);\n\t}\n}\n\nstatic void delayed_put_task_struct(struct rcu_head *rhp)\n{\n\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);\n\n\ttrace_sched_process_free(tsk);\n\tput_task_struct(tsk);\n}\n\n\nvoid release_task(struct task_struct * p)\n{\n\tstruct task_struct *leader;\n\tint zap_leader;\nrepeat:\n\ttracehook_prepare_release_task(p);\n\tatomic_dec(&p->user->processes);\n\tproc_flush_task(p);\n\twrite_lock_irq(&tasklist_lock);\n\ttracehook_finish_release_task(p);\n\t__exit_signal(p);\n\n\t/*\n\t * If we are the last non-leader member of the thread\n\t * group, and the leader is zombie, then notify the\n\t * group leader's parent process. (if it wants notification.)\n\t */\n\tzap_leader = 0;\n\tleader = p->group_leader;\n\tif (leader != p && thread_group_empty(leader) && leader->exit_state == EXIT_ZOMBIE) {\n\t\tBUG_ON(task_detached(leader));\n\t\tdo_notify_parent(leader, leader->exit_signal);\n\t\t/*\n\t\t * If we were the last child thread and the leader has\n\t\t * exited already, and the leader's parent ignores SIGCHLD,\n\t\t * then we are the one who should release the leader.\n\t\t *\n\t\t * do_notify_parent() will have marked it self-reaping in\n\t\t * that case.\n\t\t */\n\t\tzap_leader = task_detached(leader);\n\n\t\t/*\n\t\t * This maintains the invariant that release_task()\n\t\t * only runs on a task in EXIT_DEAD, just for sanity.\n\t\t */\n\t\tif (zap_leader)\n\t\t\tleader->exit_state = EXIT_DEAD;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\trelease_thread(p);\n\tcall_rcu(&p->rcu, delayed_put_task_struct);\n\n\tp = leader;\n\tif (unlikely(zap_leader))\n\t\tgoto repeat;\n}\n\n/*\n * This checks not only the pgrp, but falls back on the pid if no\n * satisfactory pgrp is found. I dunno - gdb doesn't work correctly\n * without this...\n *\n * The caller must hold rcu lock or the tasklist lock.\n */\nstruct pid *session_of_pgrp(struct pid *pgrp)\n{\n\tstruct task_struct *p;\n\tstruct pid *sid = NULL;\n\n\tp = pid_task(pgrp, PIDTYPE_PGID);\n\tif (p == NULL)\n\t\tp = pid_task(pgrp, PIDTYPE_PID);\n\tif (p != NULL)\n\t\tsid = task_session(p);\n\n\treturn sid;\n}\n\n/*\n * Determine if a process group is \"orphaned\", according to the POSIX\n * definition in 2.2.2.52.  Orphaned process groups are not to be affected\n * by terminal-generated stop signals.  Newly orphaned process groups are\n * to receive a SIGHUP and a SIGCONT.\n *\n * \"I ask you, have you ever known what it is to be an orphan?\"\n */\nstatic int will_become_orphaned_pgrp(struct pid *pgrp, struct task_struct *ignored_task)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif ((p == ignored_task) ||\n\t\t    (p->exit_state && thread_group_empty(p)) ||\n\t\t    is_global_init(p->real_parent))\n\t\t\tcontinue;\n\n\t\tif (task_pgrp(p->real_parent) != pgrp &&\n\t\t    task_session(p->real_parent) == task_session(p))\n\t\t\treturn 0;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn 1;\n}\n\nint is_current_pgrp_orphaned(void)\n{\n\tint retval;\n\n\tread_lock(&tasklist_lock);\n\tretval = will_become_orphaned_pgrp(task_pgrp(current), NULL);\n\tread_unlock(&tasklist_lock);\n\n\treturn retval;\n}\n\nstatic int has_stopped_jobs(struct pid *pgrp)\n{\n\tint retval = 0;\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif (!task_is_stopped(p))\n\t\t\tcontinue;\n\t\tretval = 1;\n\t\tbreak;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn retval;\n}\n\n/*\n * Check to see if any process groups have become orphaned as\n * a result of our exiting, and if they have any stopped jobs,\n * send them a SIGHUP and then a SIGCONT. (POSIX 3.2.2.2)\n */\nstatic void\nkill_orphaned_pgrp(struct task_struct *tsk, struct task_struct *parent)\n{\n\tstruct pid *pgrp = task_pgrp(tsk);\n\tstruct task_struct *ignored_task = tsk;\n\n\tif (!parent)\n\t\t /* exit: our father is in a different pgrp than\n\t\t  * we are and we were the only connection outside.\n\t\t  */\n\t\tparent = tsk->real_parent;\n\telse\n\t\t/* reparent: our child is in a different pgrp than\n\t\t * we are, and it was the only connection outside.\n\t\t */\n\t\tignored_task = NULL;\n\n\tif (task_pgrp(parent) != pgrp &&\n\t    task_session(parent) == task_session(tsk) &&\n\t    will_become_orphaned_pgrp(pgrp, ignored_task) &&\n\t    has_stopped_jobs(pgrp)) {\n\t\t__kill_pgrp_info(SIGHUP, SEND_SIG_PRIV, pgrp);\n\t\t__kill_pgrp_info(SIGCONT, SEND_SIG_PRIV, pgrp);\n\t}\n}\n\n/**\n * reparent_to_kthreadd - Reparent the calling kernel thread to kthreadd\n *\n * If a kernel thread is launched as a result of a system call, or if\n * it ever exits, it should generally reparent itself to kthreadd so it\n * isn't in the way of other processes and is correctly cleaned up on exit.\n *\n * The various task state such as scheduling policy and priority may have\n * been inherited from a user process, so we reset them to sane values here.\n *\n * NOTE that reparent_to_kthreadd() gives the caller full capabilities.\n */\nstatic void reparent_to_kthreadd(void)\n{\n\twrite_lock_irq(&tasklist_lock);\n\n\tptrace_unlink(current);\n\t/* Reparent to init */\n\tcurrent->real_parent = current->parent = kthreadd_task;\n\tlist_move_tail(&current->sibling, &current->real_parent->children);\n\n\t/* Set the exit signal to SIGCHLD so we signal init on exit */\n\tcurrent->exit_signal = SIGCHLD;\n\n\tif (task_nice(current) < 0)\n\t\tset_user_nice(current, 0);\n\t/* cpus_allowed? */\n\t/* rt_priority? */\n\t/* signals? */\n\tsecurity_task_reparent_to_init(current);\n\tmemcpy(current->signal->rlim, init_task.signal->rlim,\n\t       sizeof(current->signal->rlim));\n\tatomic_inc(&(INIT_USER->__count));\n\twrite_unlock_irq(&tasklist_lock);\n\tswitch_uid(INIT_USER);\n}\n\nvoid __set_special_pids(struct pid *pid)\n{\n\tstruct task_struct *curr = current->group_leader;\n\tpid_t nr = pid_nr(pid);\n\n\tif (task_session(curr) != pid) {\n\t\tchange_pid(curr, PIDTYPE_SID, pid);\n\t\tset_task_session(curr, nr);\n\t}\n\tif (task_pgrp(curr) != pid) {\n\t\tchange_pid(curr, PIDTYPE_PGID, pid);\n\t\tset_task_pgrp(curr, nr);\n\t}\n}\n\nstatic void set_special_pids(struct pid *pid)\n{\n\twrite_lock_irq(&tasklist_lock);\n\t__set_special_pids(pid);\n\twrite_unlock_irq(&tasklist_lock);\n}\n\n/*\n * Let kernel threads use this to say that they\n * allow a certain signal (since daemonize() will\n * have disabled all of them by default).\n */\nint allow_signal(int sig)\n{\n\tif (!valid_signal(sig) || sig < 1)\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tsigdelset(&current->blocked, sig);\n\tif (!current->mm) {\n\t\t/* Kernel threads handle their own signals.\n\t\t   Let the signal code know it'll be handled, so\n\t\t   that they don't get converted to SIGKILL or\n\t\t   just silently dropped */\n\t\tcurrent->sighand->action[(sig)-1].sa.sa_handler = (void __user *)2;\n\t}\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(allow_signal);\n\nint disallow_signal(int sig)\n{\n\tif (!valid_signal(sig) || sig < 1)\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->sighand->action[(sig)-1].sa.sa_handler = SIG_IGN;\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(disallow_signal);\n\n/*\n *\tPut all the gunge required to become a kernel thread without\n *\tattached user resources in one place where it belongs.\n */\n\nvoid daemonize(const char *name, ...)\n{\n\tva_list args;\n\tstruct fs_struct *fs;\n\tsigset_t blocked;\n\n\tva_start(args, name);\n\tvsnprintf(current->comm, sizeof(current->comm), name, args);\n\tva_end(args);\n\n\t/*\n\t * If we were started as result of loading a module, close all of the\n\t * user space pages.  We don't need them, and if we didn't close them\n\t * they would be locked into memory.\n\t */\n\texit_mm(current);\n\t/*\n\t * We don't want to have TIF_FREEZE set if the system-wide hibernation\n\t * or suspend transition begins right now.\n\t */\n\tcurrent->flags |= (PF_NOFREEZE | PF_KTHREAD);\n\n\tif (current->nsproxy != &init_nsproxy) {\n\t\tget_nsproxy(&init_nsproxy);\n\t\tswitch_task_namespaces(current, &init_nsproxy);\n\t}\n\tset_special_pids(&init_struct_pid);\n\tproc_clear_tty(current);\n\n\t/* Block and flush all signals */\n\tsigfillset(&blocked);\n\tsigprocmask(SIG_BLOCK, &blocked, NULL);\n\tflush_signals(current);\n\n\t/* Become as one with the init task */\n\n\texit_fs(current);\t/* current->fs->count--; */\n\tfs = init_task.fs;\n\tcurrent->fs = fs;\n\tatomic_inc(&fs->count);\n\n\texit_files(current);\n\tcurrent->files = init_task.files;\n\tatomic_inc(&current->files->count);\n\n\treparent_to_kthreadd();\n}\n\nEXPORT_SYMBOL(daemonize);\n\nstatic void close_files(struct files_struct * files)\n{\n\tint i, j;\n\tstruct fdtable *fdt;\n\n\tj = 0;\n\n\t/*\n\t * It is safe to dereference the fd table without RCU or\n\t * ->file_lock because this is the last reference to the\n\t * files structure.\n\t */\n\tfdt = files_fdtable(files);\n\tfor (;;) {\n\t\tunsigned long set;\n\t\ti = j * __NFDBITS;\n\t\tif (i >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->open_fds->fds_bits[j++];\n\t\twhile (set) {\n\t\t\tif (set & 1) {\n\t\t\t\tstruct file * file = xchg(&fdt->fd[i], NULL);\n\t\t\t\tif (file) {\n\t\t\t\t\tfilp_close(file, files);\n\t\t\t\t\tcond_resched();\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\tset >>= 1;\n\t\t}\n\t}\n}\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}\n\nvoid put_files_struct(struct files_struct *files)\n{\n\tstruct fdtable *fdt;\n\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tclose_files(files);\n\t\t/*\n\t\t * Free the fd and fdset arrays if we expanded them.\n\t\t * If the fdtable was embedded, pass files for freeing\n\t\t * at the end of the RCU grace period. Otherwise,\n\t\t * you can free files immediately.\n\t\t */\n\t\tfdt = files_fdtable(files);\n\t\tif (fdt != &files->fdtab)\n\t\t\tkmem_cache_free(files_cachep, files);\n\t\tfree_fdtable(fdt);\n\t}\n}\n\nvoid reset_files_struct(struct files_struct *files)\n{\n\tstruct task_struct *tsk = current;\n\tstruct files_struct *old;\n\n\told = tsk->files;\n\ttask_lock(tsk);\n\ttsk->files = files;\n\ttask_unlock(tsk);\n\tput_files_struct(old);\n}\n\nvoid exit_files(struct task_struct *tsk)\n{\n\tstruct files_struct * files = tsk->files;\n\n\tif (files) {\n\t\ttask_lock(tsk);\n\t\ttsk->files = NULL;\n\t\ttask_unlock(tsk);\n\t\tput_files_struct(files);\n\t}\n}\n\nvoid put_fs_struct(struct fs_struct *fs)\n{\n\t/* No need to hold fs->lock if we are killing it */\n\tif (atomic_dec_and_test(&fs->count)) {\n\t\tpath_put(&fs->root);\n\t\tpath_put(&fs->pwd);\n\t\tkmem_cache_free(fs_cachep, fs);\n\t}\n}\n\nvoid exit_fs(struct task_struct *tsk)\n{\n\tstruct fs_struct * fs = tsk->fs;\n\n\tif (fs) {\n\t\ttask_lock(tsk);\n\t\ttsk->fs = NULL;\n\t\ttask_unlock(tsk);\n\t\tput_fs_struct(fs);\n\t}\n}\n\nEXPORT_SYMBOL_GPL(exit_fs);\n\n#ifdef CONFIG_MM_OWNER\n/*\n * Task p is exiting and it owned mm, lets find a new owner for it\n */\nstatic inline int\nmm_need_new_owner(struct mm_struct *mm, struct task_struct *p)\n{\n\t/*\n\t * If there are other users of the mm and the owner (us) is exiting\n\t * we need to find a new owner to take on the responsibility.\n\t */\n\tif (atomic_read(&mm->mm_users) <= 1)\n\t\treturn 0;\n\tif (mm->owner != p)\n\t\treturn 0;\n\treturn 1;\n}\n\nvoid mm_update_next_owner(struct mm_struct *mm)\n{\n\tstruct task_struct *c, *g, *p = current;\n\nretry:\n\tif (!mm_need_new_owner(mm, p))\n\t\treturn;\n\n\tread_lock(&tasklist_lock);\n\t/*\n\t * Search in the children\n\t */\n\tlist_for_each_entry(c, &p->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t/*\n\t * Search in the siblings\n\t */\n\tlist_for_each_entry(c, &p->parent->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t/*\n\t * Search through everything else. We should not get\n\t * here often\n\t */\n\tdo_each_thread(g, c) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t} while_each_thread(g, c);\n\n\tread_unlock(&tasklist_lock);\n\t/*\n\t * We found no owner yet mm_users > 1: this implies that we are\n\t * most likely racing with swapoff (try_to_unuse()) or /proc or\n\t * ptrace or page migration (get_task_mm()).  Mark owner as NULL,\n\t * so that subsystems can understand the callback and take action.\n\t */\n\tdown_write(&mm->mmap_sem);\n\tcgroup_mm_owner_callbacks(mm->owner, NULL);\n\tmm->owner = NULL;\n\tup_write(&mm->mmap_sem);\n\treturn;\n\nassign_new_owner:\n\tBUG_ON(c == p);\n\tget_task_struct(c);\n\tread_unlock(&tasklist_lock);\n\tdown_write(&mm->mmap_sem);\n\t/*\n\t * The task_lock protects c->mm from changing.\n\t * We always want mm->owner->mm == mm\n\t */\n\ttask_lock(c);\n\tif (c->mm != mm) {\n\t\ttask_unlock(c);\n\t\tup_write(&mm->mmap_sem);\n\t\tput_task_struct(c);\n\t\tgoto retry;\n\t}\n\tcgroup_mm_owner_callbacks(mm->owner, c);\n\tmm->owner = c;\n\ttask_unlock(c);\n\tup_write(&mm->mmap_sem);\n\tput_task_struct(c);\n}\n#endif /* CONFIG_MM_OWNER */\n\n/*\n * Turn us into a lazy TLB process if we\n * aren't already..\n */\nstatic void exit_mm(struct task_struct * tsk)\n{\n\tstruct mm_struct *mm = tsk->mm;\n\tstruct core_state *core_state;\n\n\tmm_release(tsk, mm);\n\tif (!mm)\n\t\treturn;\n\t/*\n\t * Serialize with any possible pending coredump.\n\t * We must hold mmap_sem around checking core_state\n\t * and clearing tsk->mm.  The core-inducing thread\n\t * will increment ->nr_threads for each thread in the\n\t * group with ->mm != NULL.\n\t */\n\tdown_read(&mm->mmap_sem);\n\tcore_state = mm->core_state;\n\tif (core_state) {\n\t\tstruct core_thread self;\n\t\tup_read(&mm->mmap_sem);\n\n\t\tself.task = tsk;\n\t\tself.next = xchg(&core_state->dumper.next, &self);\n\t\t/*\n\t\t * Implies mb(), the result of xchg() must be visible\n\t\t * to core_state->dumper.\n\t\t */\n\t\tif (atomic_dec_and_test(&core_state->nr_threads))\n\t\t\tcomplete(&core_state->startup);\n\n\t\tfor (;;) {\n\t\t\tset_task_state(tsk, TASK_UNINTERRUPTIBLE);\n\t\t\tif (!self.task) /* see coredump_finish() */\n\t\t\t\tbreak;\n\t\t\tschedule();\n\t\t}\n\t\t__set_task_state(tsk, TASK_RUNNING);\n\t\tdown_read(&mm->mmap_sem);\n\t}\n\tatomic_inc(&mm->mm_count);\n\tBUG_ON(mm != tsk->active_mm);\n\t/* more a memory barrier than a real lock */\n\ttask_lock(tsk);\n\ttsk->mm = NULL;\n\tup_read(&mm->mmap_sem);\n\tenter_lazy_tlb(mm, current);\n\t/* We don't want this task to be frozen prematurely */\n\tclear_freeze_flag(tsk);\n\ttask_unlock(tsk);\n\tmm_update_next_owner(mm);\n\tmmput(mm);\n}\n\n/*\n * Return nonzero if @parent's children should reap themselves.\n *\n * Called with write_lock_irq(&tasklist_lock) held.\n */\nstatic int ignoring_children(struct task_struct *parent)\n{\n\tint ret;\n\tstruct sighand_struct *psig = parent->sighand;\n\tunsigned long flags;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tret = (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t       (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT));\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\treturn ret;\n}\n\n/*\n * Detach all tasks we were using ptrace on.\n * Any that need to be release_task'd are put on the @dead list.\n *\n * Called with write_lock(&tasklist_lock) held.\n */\nstatic void ptrace_exit(struct task_struct *parent, struct list_head *dead)\n{\n\tstruct task_struct *p, *n;\n\tint ign = -1;\n\n\tlist_for_each_entry_safe(p, n, &parent->ptraced, ptrace_entry) {\n\t\t__ptrace_unlink(p);\n\n\t\tif (p->exit_state != EXIT_ZOMBIE)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If it's a zombie, our attachedness prevented normal\n\t\t * parent notification or self-reaping.  Do notification\n\t\t * now if it would have happened earlier.  If it should\n\t\t * reap itself, add it to the @dead list.  We can't call\n\t\t * release_task() here because we already hold tasklist_lock.\n\t\t *\n\t\t * If it's our own child, there is no notification to do.\n\t\t * But if our normal children self-reap, then this child\n\t\t * was prevented by ptrace and we must reap it now.\n\t\t */\n\t\tif (!task_detached(p) && thread_group_empty(p)) {\n\t\t\tif (!same_thread_group(p->real_parent, parent))\n\t\t\t\tdo_notify_parent(p, p->exit_signal);\n\t\t\telse {\n\t\t\t\tif (ign < 0)\n\t\t\t\t\tign = ignoring_children(parent);\n\t\t\t\tif (ign)\n\t\t\t\t\tp->exit_signal = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (task_detached(p)) {\n\t\t\t/*\n\t\t\t * Mark it as in the process of being reaped.\n\t\t\t */\n\t\t\tp->exit_state = EXIT_DEAD;\n\t\t\tlist_add(&p->ptrace_entry, dead);\n\t\t}\n\t}\n}\n\n/*\n * Finish up exit-time ptrace cleanup.\n *\n * Called without locks.\n */\nstatic void ptrace_exit_finish(struct task_struct *parent,\n\t\t\t       struct list_head *dead)\n{\n\tstruct task_struct *p, *n;\n\n\tBUG_ON(!list_empty(&parent->ptraced));\n\n\tlist_for_each_entry_safe(p, n, dead, ptrace_entry) {\n\t\tlist_del_init(&p->ptrace_entry);\n\t\trelease_task(p);\n\t}\n}\n\nstatic void reparent_thread(struct task_struct *p, struct task_struct *father)\n{\n\tif (p->pdeath_signal)\n\t\t/* We already hold the tasklist_lock here.  */\n\t\tgroup_send_sig_info(p->pdeath_signal, SEND_SIG_NOINFO, p);\n\n\tlist_move_tail(&p->sibling, &p->real_parent->children);\n\n\t/* If this is a threaded reparent there is no need to\n\t * notify anyone anything has happened.\n\t */\n\tif (same_thread_group(p->real_parent, father))\n\t\treturn;\n\n\t/* We don't want people slaying init.  */\n\tif (!task_detached(p))\n\t\tp->exit_signal = SIGCHLD;\n\n\t/* If we'd notified the old parent about this child's death,\n\t * also notify the new parent.\n\t */\n\tif (!ptrace_reparented(p) &&\n\t    p->exit_state == EXIT_ZOMBIE &&\n\t    !task_detached(p) && thread_group_empty(p))\n\t\tdo_notify_parent(p, p->exit_signal);\n\n\tkill_orphaned_pgrp(p, father);\n}\n\n/*\n * When we die, we re-parent all our children.\n * Try to give them to another thread in our thread\n * group, and if no such member exists, give it to\n * the child reaper process (ie \"init\") in our pid\n * space.\n */\nstatic struct task_struct *find_new_reaper(struct task_struct *father)\n{\n\tstruct pid_namespace *pid_ns = task_active_pid_ns(father);\n\tstruct task_struct *thread;\n\n\tthread = father;\n\twhile_each_thread(father, thread) {\n\t\tif (thread->flags & PF_EXITING)\n\t\t\tcontinue;\n\t\tif (unlikely(pid_ns->child_reaper == father))\n\t\t\tpid_ns->child_reaper = thread;\n\t\treturn thread;\n\t}\n\n\tif (unlikely(pid_ns->child_reaper == father)) {\n\t\twrite_unlock_irq(&tasklist_lock);\n\t\tif (unlikely(pid_ns == &init_pid_ns))\n\t\t\tpanic(\"Attempted to kill init!\");\n\n\t\tzap_pid_ns_processes(pid_ns);\n\t\twrite_lock_irq(&tasklist_lock);\n\t\t/*\n\t\t * We can not clear ->child_reaper or leave it alone.\n\t\t * There may by stealth EXIT_DEAD tasks on ->children,\n\t\t * forget_original_parent() must move them somewhere.\n\t\t */\n\t\tpid_ns->child_reaper = init_pid_ns.child_reaper;\n\t}\n\n\treturn pid_ns->child_reaper;\n}\n\nstatic void forget_original_parent(struct task_struct *father)\n{\n\tstruct task_struct *p, *n, *reaper;\n\tLIST_HEAD(ptrace_dead);\n\n\twrite_lock_irq(&tasklist_lock);\n\treaper = find_new_reaper(father);\n\t/*\n\t * First clean up ptrace if we were using it.\n\t */\n\tptrace_exit(father, &ptrace_dead);\n\n\tlist_for_each_entry_safe(p, n, &father->children, sibling) {\n\t\tp->real_parent = reaper;\n\t\tif (p->parent == father) {\n\t\t\tBUG_ON(p->ptrace);\n\t\t\tp->parent = p->real_parent;\n\t\t}\n\t\treparent_thread(p, father);\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\tBUG_ON(!list_empty(&father->children));\n\n\tptrace_exit_finish(father, &ptrace_dead);\n}\n\n/*\n * Send signals to all our closest relatives so that they know\n * to properly mourn us..\n */\nstatic void exit_notify(struct task_struct *tsk, int group_dead)\n{\n\tint signal;\n\tvoid *cookie;\n\n\t/*\n\t * This does two things:\n\t *\n  \t * A.  Make init inherit all the child processes\n\t * B.  Check to see if any process groups have become orphaned\n\t *\tas a result of our exiting, and if they have any stopped\n\t *\tjobs, send them a SIGHUP and then a SIGCONT.  (POSIX 3.2.2.2)\n\t */\n\tforget_original_parent(tsk);\n\texit_task_namespaces(tsk);\n\n\twrite_lock_irq(&tasklist_lock);\n\tif (group_dead)\n\t\tkill_orphaned_pgrp(tsk->group_leader, NULL);\n\n\t/* Let father know we died\n\t *\n\t * Thread signals are configurable, but you aren't going to use\n\t * that to send signals to arbitary processes.\n\t * That stops right now.\n\t *\n\t * If the parent exec id doesn't match the exec id we saved\n\t * when we started then we know the parent has changed security\n\t * domain.\n\t *\n\t * If our self_exec id doesn't match our parent_exec_id then\n\t * we have changed execution domain as these two values started\n\t * the same after a fork.\n\t */\n\tif (tsk->exit_signal != SIGCHLD && !task_detached(tsk) &&\n\t    (tsk->parent_exec_id != tsk->real_parent->self_exec_id ||\n\t     tsk->self_exec_id != tsk->parent_exec_id) &&\n\t    !capable(CAP_KILL))\n\t\ttsk->exit_signal = SIGCHLD;\n\n\tsignal = tracehook_notify_death(tsk, &cookie, group_dead);\n\tif (signal >= 0)\n\t\tsignal = do_notify_parent(tsk, signal);\n\n\ttsk->exit_state = signal == DEATH_REAP ? EXIT_DEAD : EXIT_ZOMBIE;\n\n\t/* mt-exec, de_thread() is waiting for us */\n\tif (thread_group_leader(tsk) &&\n\t    tsk->signal->group_exit_task &&\n\t    tsk->signal->notify_count < 0)\n\t\twake_up_process(tsk->signal->group_exit_task);\n\n\twrite_unlock_irq(&tasklist_lock);\n\n\ttracehook_report_death(tsk, signal, cookie, group_dead);\n\n\t/* If the process is dead, release it - nobody will wait for it */\n\tif (signal == DEATH_REAP)\n\t\trelease_task(tsk);\n}\n\n#ifdef CONFIG_DEBUG_STACK_USAGE\nstatic void check_stack_usage(void)\n{\n\tstatic DEFINE_SPINLOCK(low_water_lock);\n\tstatic int lowest_to_date = THREAD_SIZE;\n\tunsigned long *n = end_of_stack(current);\n\tunsigned long free;\n\n\twhile (*n == 0)\n\t\tn++;\n\tfree = (unsigned long)n - (unsigned long)end_of_stack(current);\n\n\tif (free >= lowest_to_date)\n\t\treturn;\n\n\tspin_lock(&low_water_lock);\n\tif (free < lowest_to_date) {\n\t\tprintk(KERN_WARNING \"%s used greatest stack depth: %lu bytes \"\n\t\t\t\t\"left\\n\",\n\t\t\t\tcurrent->comm, free);\n\t\tlowest_to_date = free;\n\t}\n\tspin_unlock(&low_water_lock);\n}\n#else\nstatic inline void check_stack_usage(void) {}\n#endif\n\nNORET_TYPE void do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tprofile_task_exit(tsk);\n\n\tWARN_ON(atomic_read(&tsk->fs_excl));\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"Aiee, killing interrupt handler!\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"Attempted to kill the idle task!\");\n\n\ttracehook_report_exit(&code);\n\n\t/*\n\t * We're taking recursive faults here in do_exit. Safest is to just\n\t * leave this task alone and wait for reboot.\n\t */\n\tif (unlikely(tsk->flags & PF_EXITING)) {\n\t\tprintk(KERN_ALERT\n\t\t\t\"Fixing recursive fault but reboot is needed!\\n\");\n\t\t/*\n\t\t * We can do this unlocked here. The futex code uses\n\t\t * this flag just to verify whether the pi state\n\t\t * cleanup has been done or not. In the worst case it\n\t\t * loops once more. We pretend that the cleanup was\n\t\t * done as there is no way to return. Either the\n\t\t * OWNER_DIED bit is set by now or we push the blocked\n\t\t * task into the wait for ever nirwana as well.\n\t\t */\n\t\ttsk->flags |= PF_EXITPIDONE;\n\t\tif (tsk->io_context)\n\t\t\texit_io_context();\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule();\n\t}\n\n\texit_signals(tsk);  /* sets PF_EXITING */\n\t/*\n\t * tsk->flags are checked in the futex code to protect against\n\t * an exiting task cleaning up the robust pi futexes.\n\t */\n\tsmp_mb();\n\tspin_unlock_wait(&tsk->pi_lock);\n\n\tif (unlikely(in_atomic()))\n\t\tprintk(KERN_INFO \"note: %s[%d] exited with preempt_count %d\\n\",\n\t\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\t\tpreempt_count());\n\n\tacct_update_integrals(tsk);\n\tif (tsk->mm) {\n\t\tupdate_hiwater_rss(tsk->mm);\n\t\tupdate_hiwater_vm(tsk->mm);\n\t}\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n\t}\n\tacct_collect(code, group_dead);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(tsk->robust_list))\n\t\texit_robust_list(tsk);\n#ifdef CONFIG_COMPAT\n\tif (unlikely(tsk->compat_robust_list))\n\t\tcompat_exit_robust_list(tsk);\n#endif\n#endif\n\tif (group_dead)\n\t\ttty_audit_exit();\n\tif (unlikely(tsk->audit_context))\n\t\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm(tsk);\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tcheck_stack_usage();\n\texit_thread();\n\tcgroup_exit(tsk, 1);\n\texit_keys(tsk);\n\n\tif (group_dead && tsk->signal->leader)\n\t\tdisassociate_ctty(1);\n\n\tmodule_put(task_thread_info(tsk)->exec_domain->module);\n\tif (tsk->binfmt)\n\t\tmodule_put(tsk->binfmt->module);\n\n\tproc_exit_connector(tsk);\n\texit_notify(tsk, group_dead);\n#ifdef CONFIG_NUMA\n\tmpol_put(tsk->mempolicy);\n\ttsk->mempolicy = NULL;\n#endif\n#ifdef CONFIG_FUTEX\n\t/*\n\t * This must happen late, after the PID is not\n\t * hashed anymore:\n\t */\n\tif (unlikely(!list_empty(&tsk->pi_state_list)))\n\t\texit_pi_state_list(tsk);\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held(tsk);\n\t/*\n\t * We can do this unlocked here. The futex code uses this flag\n\t * just to verify whether the pi state cleanup has been done\n\t * or not. In the worst case it loops once more.\n\t */\n\ttsk->flags |= PF_EXITPIDONE;\n\n\tif (tsk->io_context)\n\t\texit_io_context();\n\n\tif (tsk->splice_pipe)\n\t\t__free_pipe_info(tsk->splice_pipe);\n\n\tpreempt_disable();\n\t/* causes final put_task_struct in finish_task_switch(). */\n\ttsk->state = TASK_DEAD;\n\n\tschedule();\n\tBUG();\n\t/* Avoid \"noreturn function does return\".  */\n\tfor (;;)\n\t\tcpu_relax();\t/* For when BUG is null */\n}\n\nEXPORT_SYMBOL_GPL(do_exit);\n\nNORET_TYPE void complete_and_exit(struct completion *comp, long code)\n{\n\tif (comp)\n\t\tcomplete(comp);\n\n\tdo_exit(code);\n}\n\nEXPORT_SYMBOL(complete_and_exit);\n\nasmlinkage long sys_exit(int error_code)\n{\n\tdo_exit((error_code&0xff)<<8);\n}\n\n/*\n * Take down every thread in the group.  This is called by fatal signals\n * as well as by sys_exit_group (below).\n */\nNORET_TYPE void\ndo_group_exit(int exit_code)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tBUG_ON(exit_code & 0x80); /* core dumps don't get here */\n\n\tif (signal_group_exit(sig))\n\t\texit_code = sig->group_exit_code;\n\telse if (!thread_group_empty(current)) {\n\t\tstruct sighand_struct *const sighand = current->sighand;\n\t\tspin_lock_irq(&sighand->siglock);\n\t\tif (signal_group_exit(sig))\n\t\t\t/* Another thread got here before we took the lock.  */\n\t\t\texit_code = sig->group_exit_code;\n\t\telse {\n\t\t\tsig->group_exit_code = exit_code;\n\t\t\tsig->flags = SIGNAL_GROUP_EXIT;\n\t\t\tzap_other_threads(current);\n\t\t}\n\t\tspin_unlock_irq(&sighand->siglock);\n\t}\n\n\tdo_exit(exit_code);\n\t/* NOTREACHED */\n}\n\n/*\n * this kills every thread in the thread group. Note that any externally\n * wait4()-ing process will get the correct exit code - even if this\n * thread is not the thread group leader.\n */\nasmlinkage void sys_exit_group(int error_code)\n{\n\tdo_group_exit((error_code & 0xff) << 8);\n}\n\nstatic struct pid *task_pid_type(struct task_struct *task, enum pid_type type)\n{\n\tstruct pid *pid = NULL;\n\tif (type == PIDTYPE_PID)\n\t\tpid = task->pids[type].pid;\n\telse if (type < PIDTYPE_MAX)\n\t\tpid = task->group_leader->pids[type].pid;\n\treturn pid;\n}\n\nstatic int eligible_child(enum pid_type type, struct pid *pid, int options,\n\t\t\t  struct task_struct *p)\n{\n\tint err;\n\n\tif (type < PIDTYPE_MAX) {\n\t\tif (task_pid_type(p, type) != pid)\n\t\t\treturn 0;\n\t}\n\n\t/* Wait for all children (clone and not) if __WALL is set;\n\t * otherwise, wait for clone children *only* if __WCLONE is\n\t * set; otherwise, wait for non-clone children *only*.  (Note:\n\t * A \"clone\" child here is one that reports to its parent\n\t * using a signal other than SIGCHLD.) */\n\tif (((p->exit_signal != SIGCHLD) ^ ((options & __WCLONE) != 0))\n\t    && !(options & __WALL))\n\t\treturn 0;\n\n\terr = security_task_wait(p);\n\tif (err)\n\t\treturn err;\n\n\treturn 1;\n}\n\nstatic int wait_noreap_copyout(struct task_struct *p, pid_t pid, uid_t uid,\n\t\t\t       int why, int status,\n\t\t\t       struct siginfo __user *infop,\n\t\t\t       struct rusage __user *rusagep)\n{\n\tint retval = rusagep ? getrusage(p, RUSAGE_BOTH, rusagep) : 0;\n\n\tput_task_struct(p);\n\tif (!retval)\n\t\tretval = put_user(SIGCHLD, &infop->si_signo);\n\tif (!retval)\n\t\tretval = put_user(0, &infop->si_errno);\n\tif (!retval)\n\t\tretval = put_user((short)why, &infop->si_code);\n\tif (!retval)\n\t\tretval = put_user(pid, &infop->si_pid);\n\tif (!retval)\n\t\tretval = put_user(uid, &infop->si_uid);\n\tif (!retval)\n\t\tretval = put_user(status, &infop->si_status);\n\tif (!retval)\n\t\tretval = pid;\n\treturn retval;\n}\n\n/*\n * Handle sys_wait4 work for one task in state EXIT_ZOMBIE.  We hold\n * read_lock(&tasklist_lock) on entry.  If we return zero, we still hold\n * the lock and this task is uninteresting.  If we return nonzero, we have\n * released the lock and the system call should return.\n */\nstatic int wait_task_zombie(struct task_struct *p, int options,\n\t\t\t    struct siginfo __user *infop,\n\t\t\t    int __user *stat_addr, struct rusage __user *ru)\n{\n\tunsigned long state;\n\tint retval, status, traced;\n\tpid_t pid = task_pid_vnr(p);\n\n\tif (!likely(options & WEXITED))\n\t\treturn 0;\n\n\tif (unlikely(options & WNOWAIT)) {\n\t\tuid_t uid = p->uid;\n\t\tint exit_code = p->exit_code;\n\t\tint why, status;\n\n\t\tget_task_struct(p);\n\t\tread_unlock(&tasklist_lock);\n\t\tif ((exit_code & 0x7f) == 0) {\n\t\t\twhy = CLD_EXITED;\n\t\t\tstatus = exit_code >> 8;\n\t\t} else {\n\t\t\twhy = (exit_code & 0x80) ? CLD_DUMPED : CLD_KILLED;\n\t\t\tstatus = exit_code & 0x7f;\n\t\t}\n\t\treturn wait_noreap_copyout(p, pid, uid, why,\n\t\t\t\t\t   status, infop, ru);\n\t}\n\n\t/*\n\t * Try to move the task's state to DEAD\n\t * only one thread is allowed to do this:\n\t */\n\tstate = xchg(&p->exit_state, EXIT_DEAD);\n\tif (state != EXIT_ZOMBIE) {\n\t\tBUG_ON(state != EXIT_DEAD);\n\t\treturn 0;\n\t}\n\n\ttraced = ptrace_reparented(p);\n\n\tif (likely(!traced)) {\n\t\tstruct signal_struct *psig;\n\t\tstruct signal_struct *sig;\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * The resource counters for the group leader are in its\n\t\t * own task_struct.  Those for dead threads in the group\n\t\t * are in its signal_struct, as are those for the child\n\t\t * processes it has previously reaped.  All these\n\t\t * accumulate in the parent's signal_struct c* fields.\n\t\t *\n\t\t * We don't bother to take a lock here to protect these\n\t\t * p->signal fields, because they are only touched by\n\t\t * __exit_signal, which runs with tasklist_lock\n\t\t * write-locked anyway, and so is excluded here.  We do\n\t\t * need to protect the access to p->parent->signal fields,\n\t\t * as other threads in the parent group can be right\n\t\t * here reaping other children at the same time.\n\t\t *\n\t\t * We use thread_group_cputime() to get times for the thread\n\t\t * group, which consolidates times for all threads in the\n\t\t * group including the group leader.\n\t\t */\n\t\tspin_lock_irq(&p->parent->sighand->siglock);\n\t\tpsig = p->parent->signal;\n\t\tsig = p->signal;\n\t\tthread_group_cputime(p, &cputime);\n\t\tpsig->cutime =\n\t\t\tcputime_add(psig->cutime,\n\t\t\tcputime_add(cputime.utime,\n\t\t\t\t    sig->cutime));\n\t\tpsig->cstime =\n\t\t\tcputime_add(psig->cstime,\n\t\t\tcputime_add(cputime.stime,\n\t\t\t\t    sig->cstime));\n\t\tpsig->cgtime =\n\t\t\tcputime_add(psig->cgtime,\n\t\t\tcputime_add(p->gtime,\n\t\t\tcputime_add(sig->gtime,\n\t\t\t\t    sig->cgtime)));\n\t\tpsig->cmin_flt +=\n\t\t\tp->min_flt + sig->min_flt + sig->cmin_flt;\n\t\tpsig->cmaj_flt +=\n\t\t\tp->maj_flt + sig->maj_flt + sig->cmaj_flt;\n\t\tpsig->cnvcsw +=\n\t\t\tp->nvcsw + sig->nvcsw + sig->cnvcsw;\n\t\tpsig->cnivcsw +=\n\t\t\tp->nivcsw + sig->nivcsw + sig->cnivcsw;\n\t\tpsig->cinblock +=\n\t\t\ttask_io_get_inblock(p) +\n\t\t\tsig->inblock + sig->cinblock;\n\t\tpsig->coublock +=\n\t\t\ttask_io_get_oublock(p) +\n\t\t\tsig->oublock + sig->coublock;\n\t\ttask_io_accounting_add(&psig->ioac, &p->ioac);\n\t\ttask_io_accounting_add(&psig->ioac, &sig->ioac);\n\t\tspin_unlock_irq(&p->parent->sighand->siglock);\n\t}\n\n\t/*\n\t * Now we are sure this task is interesting, and no other\n\t * thread can reap it because we set its state to EXIT_DEAD.\n\t */\n\tread_unlock(&tasklist_lock);\n\n\tretval = ru ? getrusage(p, RUSAGE_BOTH, ru) : 0;\n\tstatus = (p->signal->flags & SIGNAL_GROUP_EXIT)\n\t\t? p->signal->group_exit_code : p->exit_code;\n\tif (!retval && stat_addr)\n\t\tretval = put_user(status, stat_addr);\n\tif (!retval && infop)\n\t\tretval = put_user(SIGCHLD, &infop->si_signo);\n\tif (!retval && infop)\n\t\tretval = put_user(0, &infop->si_errno);\n\tif (!retval && infop) {\n\t\tint why;\n\n\t\tif ((status & 0x7f) == 0) {\n\t\t\twhy = CLD_EXITED;\n\t\t\tstatus >>= 8;\n\t\t} else {\n\t\t\twhy = (status & 0x80) ? CLD_DUMPED : CLD_KILLED;\n\t\t\tstatus &= 0x7f;\n\t\t}\n\t\tretval = put_user((short)why, &infop->si_code);\n\t\tif (!retval)\n\t\t\tretval = put_user(status, &infop->si_status);\n\t}\n\tif (!retval && infop)\n\t\tretval = put_user(pid, &infop->si_pid);\n\tif (!retval && infop)\n\t\tretval = put_user(p->uid, &infop->si_uid);\n\tif (!retval)\n\t\tretval = pid;\n\n\tif (traced) {\n\t\twrite_lock_irq(&tasklist_lock);\n\t\t/* We dropped tasklist, ptracer could die and untrace */\n\t\tptrace_unlink(p);\n\t\t/*\n\t\t * If this is not a detached task, notify the parent.\n\t\t * If it's still not detached after that, don't release\n\t\t * it now.\n\t\t */\n\t\tif (!task_detached(p)) {\n\t\t\tdo_notify_parent(p, p->exit_signal);\n\t\t\tif (!task_detached(p)) {\n\t\t\t\tp->exit_state = EXIT_ZOMBIE;\n\t\t\t\tp = NULL;\n\t\t\t}\n\t\t}\n\t\twrite_unlock_irq(&tasklist_lock);\n\t}\n\tif (p != NULL)\n\t\trelease_task(p);\n\n\treturn retval;\n}\n\n/*\n * Handle sys_wait4 work for one task in state TASK_STOPPED.  We hold\n * read_lock(&tasklist_lock) on entry.  If we return zero, we still hold\n * the lock and this task is uninteresting.  If we return nonzero, we have\n * released the lock and the system call should return.\n */\nstatic int wait_task_stopped(int ptrace, struct task_struct *p,\n\t\t\t     int options, struct siginfo __user *infop,\n\t\t\t     int __user *stat_addr, struct rusage __user *ru)\n{\n\tint retval, exit_code, why;\n\tuid_t uid = 0; /* unneeded, required by compiler */\n\tpid_t pid;\n\n\tif (!(options & WUNTRACED))\n\t\treturn 0;\n\n\texit_code = 0;\n\tspin_lock_irq(&p->sighand->siglock);\n\n\tif (unlikely(!task_is_stopped_or_traced(p)))\n\t\tgoto unlock_sig;\n\n\tif (!ptrace && p->signal->group_stop_count > 0)\n\t\t/*\n\t\t * A group stop is in progress and this is the group leader.\n\t\t * We won't report until all threads have stopped.\n\t\t */\n\t\tgoto unlock_sig;\n\n\texit_code = p->exit_code;\n\tif (!exit_code)\n\t\tgoto unlock_sig;\n\n\tif (!unlikely(options & WNOWAIT))\n\t\tp->exit_code = 0;\n\n\tuid = p->uid;\nunlock_sig:\n\tspin_unlock_irq(&p->sighand->siglock);\n\tif (!exit_code)\n\t\treturn 0;\n\n\t/*\n\t * Now we are pretty sure this task is interesting.\n\t * Make sure it doesn't get reaped out from under us while we\n\t * give up the lock and then examine it below.  We don't want to\n\t * keep holding onto the tasklist_lock while we call getrusage and\n\t * possibly take page faults for user memory.\n\t */\n\tget_task_struct(p);\n\tpid = task_pid_vnr(p);\n\twhy = ptrace ? CLD_TRAPPED : CLD_STOPPED;\n\tread_unlock(&tasklist_lock);\n\n\tif (unlikely(options & WNOWAIT))\n\t\treturn wait_noreap_copyout(p, pid, uid,\n\t\t\t\t\t   why, exit_code,\n\t\t\t\t\t   infop, ru);\n\n\tretval = ru ? getrusage(p, RUSAGE_BOTH, ru) : 0;\n\tif (!retval && stat_addr)\n\t\tretval = put_user((exit_code << 8) | 0x7f, stat_addr);\n\tif (!retval && infop)\n\t\tretval = put_user(SIGCHLD, &infop->si_signo);\n\tif (!retval && infop)\n\t\tretval = put_user(0, &infop->si_errno);\n\tif (!retval && infop)\n\t\tretval = put_user((short)why, &infop->si_code);\n\tif (!retval && infop)\n\t\tretval = put_user(exit_code, &infop->si_status);\n\tif (!retval && infop)\n\t\tretval = put_user(pid, &infop->si_pid);\n\tif (!retval && infop)\n\t\tretval = put_user(uid, &infop->si_uid);\n\tif (!retval)\n\t\tretval = pid;\n\tput_task_struct(p);\n\n\tBUG_ON(!retval);\n\treturn retval;\n}\n\n/*\n * Handle do_wait work for one task in a live, non-stopped state.\n * read_lock(&tasklist_lock) on entry.  If we return zero, we still hold\n * the lock and this task is uninteresting.  If we return nonzero, we have\n * released the lock and the system call should return.\n */\nstatic int wait_task_continued(struct task_struct *p, int options,\n\t\t\t       struct siginfo __user *infop,\n\t\t\t       int __user *stat_addr, struct rusage __user *ru)\n{\n\tint retval;\n\tpid_t pid;\n\tuid_t uid;\n\n\tif (!unlikely(options & WCONTINUED))\n\t\treturn 0;\n\n\tif (!(p->signal->flags & SIGNAL_STOP_CONTINUED))\n\t\treturn 0;\n\n\tspin_lock_irq(&p->sighand->siglock);\n\t/* Re-check with the lock held.  */\n\tif (!(p->signal->flags & SIGNAL_STOP_CONTINUED)) {\n\t\tspin_unlock_irq(&p->sighand->siglock);\n\t\treturn 0;\n\t}\n\tif (!unlikely(options & WNOWAIT))\n\t\tp->signal->flags &= ~SIGNAL_STOP_CONTINUED;\n\tspin_unlock_irq(&p->sighand->siglock);\n\n\tpid = task_pid_vnr(p);\n\tuid = p->uid;\n\tget_task_struct(p);\n\tread_unlock(&tasklist_lock);\n\n\tif (!infop) {\n\t\tretval = ru ? getrusage(p, RUSAGE_BOTH, ru) : 0;\n\t\tput_task_struct(p);\n\t\tif (!retval && stat_addr)\n\t\t\tretval = put_user(0xffff, stat_addr);\n\t\tif (!retval)\n\t\t\tretval = pid;\n\t} else {\n\t\tretval = wait_noreap_copyout(p, pid, uid,\n\t\t\t\t\t     CLD_CONTINUED, SIGCONT,\n\t\t\t\t\t     infop, ru);\n\t\tBUG_ON(retval == 0);\n\t}\n\n\treturn retval;\n}\n\n/*\n * Consider @p for a wait by @parent.\n *\n * -ECHILD should be in *@notask_error before the first call.\n * Returns nonzero for a final return, when we have unlocked tasklist_lock.\n * Returns zero if the search for a child should continue;\n * then *@notask_error is 0 if @p is an eligible child,\n * or another error from security_task_wait(), or still -ECHILD.\n */\nstatic int wait_consider_task(struct task_struct *parent, int ptrace,\n\t\t\t      struct task_struct *p, int *notask_error,\n\t\t\t      enum pid_type type, struct pid *pid, int options,\n\t\t\t      struct siginfo __user *infop,\n\t\t\t      int __user *stat_addr, struct rusage __user *ru)\n{\n\tint ret = eligible_child(type, pid, options, p);\n\tif (!ret)\n\t\treturn ret;\n\n\tif (unlikely(ret < 0)) {\n\t\t/*\n\t\t * If we have not yet seen any eligible child,\n\t\t * then let this error code replace -ECHILD.\n\t\t * A permission error will give the user a clue\n\t\t * to look for security policy problems, rather\n\t\t * than for mysterious wait bugs.\n\t\t */\n\t\tif (*notask_error)\n\t\t\t*notask_error = ret;\n\t}\n\n\tif (likely(!ptrace) && unlikely(p->ptrace)) {\n\t\t/*\n\t\t * This child is hidden by ptrace.\n\t\t * We aren't allowed to see it now, but eventually we will.\n\t\t */\n\t\t*notask_error = 0;\n\t\treturn 0;\n\t}\n\n\tif (p->exit_state == EXIT_DEAD)\n\t\treturn 0;\n\n\t/*\n\t * We don't reap group leaders with subthreads.\n\t */\n\tif (p->exit_state == EXIT_ZOMBIE && !delay_group_leader(p))\n\t\treturn wait_task_zombie(p, options, infop, stat_addr, ru);\n\n\t/*\n\t * It's stopped or running now, so it might\n\t * later continue, exit, or stop again.\n\t */\n\t*notask_error = 0;\n\n\tif (task_is_stopped_or_traced(p))\n\t\treturn wait_task_stopped(ptrace, p, options,\n\t\t\t\t\t infop, stat_addr, ru);\n\n\treturn wait_task_continued(p, options, infop, stat_addr, ru);\n}\n\n/*\n * Do the work of do_wait() for one thread in the group, @tsk.\n *\n * -ECHILD should be in *@notask_error before the first call.\n * Returns nonzero for a final return, when we have unlocked tasklist_lock.\n * Returns zero if the search for a child should continue; then\n * *@notask_error is 0 if there were any eligible children,\n * or another error from security_task_wait(), or still -ECHILD.\n */\nstatic int do_wait_thread(struct task_struct *tsk, int *notask_error,\n\t\t\t  enum pid_type type, struct pid *pid, int options,\n\t\t\t  struct siginfo __user *infop, int __user *stat_addr,\n\t\t\t  struct rusage __user *ru)\n{\n\tstruct task_struct *p;\n\n\tlist_for_each_entry(p, &tsk->children, sibling) {\n\t\t/*\n\t\t * Do not consider detached threads.\n\t\t */\n\t\tif (!task_detached(p)) {\n\t\t\tint ret = wait_consider_task(tsk, 0, p, notask_error,\n\t\t\t\t\t\t     type, pid, options,\n\t\t\t\t\t\t     infop, stat_addr, ru);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ptrace_do_wait(struct task_struct *tsk, int *notask_error,\n\t\t\t  enum pid_type type, struct pid *pid, int options,\n\t\t\t  struct siginfo __user *infop, int __user *stat_addr,\n\t\t\t  struct rusage __user *ru)\n{\n\tstruct task_struct *p;\n\n\t/*\n\t * Traditionally we see ptrace'd stopped tasks regardless of options.\n\t */\n\toptions |= WUNTRACED;\n\n\tlist_for_each_entry(p, &tsk->ptraced, ptrace_entry) {\n\t\tint ret = wait_consider_task(tsk, 1, p, notask_error,\n\t\t\t\t\t     type, pid, options,\n\t\t\t\t\t     infop, stat_addr, ru);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic long do_wait(enum pid_type type, struct pid *pid, int options,\n\t\t    struct siginfo __user *infop, int __user *stat_addr,\n\t\t    struct rusage __user *ru)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct task_struct *tsk;\n\tint retval;\n\n\ttrace_sched_process_wait(pid);\n\n\tadd_wait_queue(&current->signal->wait_chldexit,&wait);\nrepeat:\n\t/*\n\t * If there is nothing that can match our critiera just get out.\n\t * We will clear @retval to zero if we see any child that might later\n\t * match our criteria, even if we are not able to reap it yet.\n\t */\n\tretval = -ECHILD;\n\tif ((type < PIDTYPE_MAX) && (!pid || hlist_empty(&pid->tasks[type])))\n\t\tgoto end;\n\n\tcurrent->state = TASK_INTERRUPTIBLE;\n\tread_lock(&tasklist_lock);\n\ttsk = current;\n\tdo {\n\t\tint tsk_result = do_wait_thread(tsk, &retval,\n\t\t\t\t\t\ttype, pid, options,\n\t\t\t\t\t\tinfop, stat_addr, ru);\n\t\tif (!tsk_result)\n\t\t\ttsk_result = ptrace_do_wait(tsk, &retval,\n\t\t\t\t\t\t    type, pid, options,\n\t\t\t\t\t\t    infop, stat_addr, ru);\n\t\tif (tsk_result) {\n\t\t\t/*\n\t\t\t * tasklist_lock is unlocked and we have a final result.\n\t\t\t */\n\t\t\tretval = tsk_result;\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (options & __WNOTHREAD)\n\t\t\tbreak;\n\t\ttsk = next_thread(tsk);\n\t\tBUG_ON(tsk->signal != current->signal);\n\t} while (tsk != current);\n\tread_unlock(&tasklist_lock);\n\n\tif (!retval && !(options & WNOHANG)) {\n\t\tretval = -ERESTARTSYS;\n\t\tif (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tgoto repeat;\n\t\t}\n\t}\n\nend:\n\tcurrent->state = TASK_RUNNING;\n\tremove_wait_queue(&current->signal->wait_chldexit,&wait);\n\tif (infop) {\n\t\tif (retval > 0)\n\t\t\tretval = 0;\n\t\telse {\n\t\t\t/*\n\t\t\t * For a WNOHANG return, clear out all the fields\n\t\t\t * we would set so the user can easily tell the\n\t\t\t * difference.\n\t\t\t */\n\t\t\tif (!retval)\n\t\t\t\tretval = put_user(0, &infop->si_signo);\n\t\t\tif (!retval)\n\t\t\t\tretval = put_user(0, &infop->si_errno);\n\t\t\tif (!retval)\n\t\t\t\tretval = put_user(0, &infop->si_code);\n\t\t\tif (!retval)\n\t\t\t\tretval = put_user(0, &infop->si_pid);\n\t\t\tif (!retval)\n\t\t\t\tretval = put_user(0, &infop->si_uid);\n\t\t\tif (!retval)\n\t\t\t\tretval = put_user(0, &infop->si_status);\n\t\t}\n\t}\n\treturn retval;\n}\n\nasmlinkage long sys_waitid(int which, pid_t upid,\n\t\t\t   struct siginfo __user *infop, int options,\n\t\t\t   struct rusage __user *ru)\n{\n\tstruct pid *pid = NULL;\n\tenum pid_type type;\n\tlong ret;\n\n\tif (options & ~(WNOHANG|WNOWAIT|WEXITED|WSTOPPED|WCONTINUED))\n\t\treturn -EINVAL;\n\tif (!(options & (WEXITED|WSTOPPED|WCONTINUED)))\n\t\treturn -EINVAL;\n\n\tswitch (which) {\n\tcase P_ALL:\n\t\ttype = PIDTYPE_MAX;\n\t\tbreak;\n\tcase P_PID:\n\t\ttype = PIDTYPE_PID;\n\t\tif (upid <= 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase P_PGID:\n\t\ttype = PIDTYPE_PGID;\n\t\tif (upid <= 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (type < PIDTYPE_MAX)\n\t\tpid = find_get_pid(upid);\n\tret = do_wait(type, pid, options, infop, NULL, ru);\n\tput_pid(pid);\n\n\t/* avoid REGPARM breakage on x86: */\n\tasmlinkage_protect(5, ret, which, upid, infop, options, ru);\n\treturn ret;\n}\n\nasmlinkage long sys_wait4(pid_t upid, int __user *stat_addr,\n\t\t\t  int options, struct rusage __user *ru)\n{\n\tstruct pid *pid = NULL;\n\tenum pid_type type;\n\tlong ret;\n\n\tif (options & ~(WNOHANG|WUNTRACED|WCONTINUED|\n\t\t\t__WNOTHREAD|__WCLONE|__WALL))\n\t\treturn -EINVAL;\n\n\tif (upid == -1)\n\t\ttype = PIDTYPE_MAX;\n\telse if (upid < 0) {\n\t\ttype = PIDTYPE_PGID;\n\t\tpid = find_get_pid(-upid);\n\t} else if (upid == 0) {\n\t\ttype = PIDTYPE_PGID;\n\t\tpid = get_pid(task_pgrp(current));\n\t} else /* upid > 0 */ {\n\t\ttype = PIDTYPE_PID;\n\t\tpid = find_get_pid(upid);\n\t}\n\n\tret = do_wait(type, pid, options | WEXITED, NULL, stat_addr, ru);\n\tput_pid(pid);\n\n\t/* avoid REGPARM breakage on x86: */\n\tasmlinkage_protect(4, ret, upid, stat_addr, options, ru);\n\treturn ret;\n}\n\n#ifdef __ARCH_WANT_SYS_WAITPID\n\n/*\n * sys_waitpid() remains for compatibility. waitpid() should be\n * implemented by calling sys_wait4() from libc.a.\n */\nasmlinkage long sys_waitpid(pid_t pid, int __user *stat_addr, int options)\n{\n\treturn sys_wait4(pid, stat_addr, options, NULL);\n}\n\n#endif\n", "/*\n *  linux/kernel/fork.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n/*\n *  'fork.c' contains the help-routines for the 'fork' system call\n * (see also entry.S and others).\n * Fork is rather simple, once you get the hang of it, but the memory\n * management can be a bitch. See 'mm/memory.c': 'copy_page_range()'\n */\n\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/unistd.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/completion.h>\n#include <linux/mnt_namespace.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/sem.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/iocontext.h>\n#include <linux/key.h>\n#include <linux/binfmts.h>\n#include <linux/mman.h>\n#include <linux/mmu_notifier.h>\n#include <linux/fs.h>\n#include <linux/nsproxy.h>\n#include <linux/capability.h>\n#include <linux/cpu.h>\n#include <linux/cgroup.h>\n#include <linux/security.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/jiffies.h>\n#include <linux/tracehook.h>\n#include <linux/futex.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/rcupdate.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/audit.h>\n#include <linux/memcontrol.h>\n#include <linux/profile.h>\n#include <linux/rmap.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/cn_proc.h>\n#include <linux/freezer.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/random.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/blkdev.h>\n#include <trace/sched.h>\n\n#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/uaccess.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/tlbflush.h>\n\n/*\n * Protected counters by write_lock_irq(&tasklist_lock)\n */\nunsigned long total_forks;\t/* Handle normal Linux uptimes. */\nint nr_threads; \t\t/* The idle threads do not count.. */\n\nint max_threads;\t\t/* tunable limit on nr_threads */\n\nDEFINE_PER_CPU(unsigned long, process_counts) = 0;\n\n__cacheline_aligned DEFINE_RWLOCK(tasklist_lock);  /* outer */\n\nint nr_processes(void)\n{\n\tint cpu;\n\tint total = 0;\n\n\tfor_each_online_cpu(cpu)\n\t\ttotal += per_cpu(process_counts, cpu);\n\n\treturn total;\n}\n\n#ifndef __HAVE_ARCH_TASK_STRUCT_ALLOCATOR\n# define alloc_task_struct()\tkmem_cache_alloc(task_struct_cachep, GFP_KERNEL)\n# define free_task_struct(tsk)\tkmem_cache_free(task_struct_cachep, (tsk))\nstatic struct kmem_cache *task_struct_cachep;\n#endif\n\n#ifndef __HAVE_ARCH_THREAD_INFO_ALLOCATOR\nstatic inline struct thread_info *alloc_thread_info(struct task_struct *tsk)\n{\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tgfp_t mask = GFP_KERNEL | __GFP_ZERO;\n#else\n\tgfp_t mask = GFP_KERNEL;\n#endif\n\treturn (struct thread_info *)__get_free_pages(mask, THREAD_SIZE_ORDER);\n}\n\nstatic inline void free_thread_info(struct thread_info *ti)\n{\n\tfree_pages((unsigned long)ti, THREAD_SIZE_ORDER);\n}\n#endif\n\n/* SLAB cache for signal_struct structures (tsk->signal) */\nstatic struct kmem_cache *signal_cachep;\n\n/* SLAB cache for sighand_struct structures (tsk->sighand) */\nstruct kmem_cache *sighand_cachep;\n\n/* SLAB cache for files_struct structures (tsk->files) */\nstruct kmem_cache *files_cachep;\n\n/* SLAB cache for fs_struct structures (tsk->fs) */\nstruct kmem_cache *fs_cachep;\n\n/* SLAB cache for vm_area_struct structures */\nstruct kmem_cache *vm_area_cachep;\n\n/* SLAB cache for mm_struct structures (tsk->mm) */\nstatic struct kmem_cache *mm_cachep;\n\nvoid free_task(struct task_struct *tsk)\n{\n\tprop_local_destroy_single(&tsk->dirties);\n\tfree_thread_info(tsk->stack);\n\trt_mutex_debug_task_free(tsk);\n\tfree_task_struct(tsk);\n}\nEXPORT_SYMBOL(free_task);\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tsecurity_task_free(tsk);\n\tfree_uid(tsk->user);\n\tput_group_info(tsk->group_info);\n\tdelayacct_tsk_free(tsk);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}\n\n/*\n * macro override instead of weak attribute alias, to workaround\n * gcc 4.1.0 and 4.1.1 bugs with weak attribute and empty functions.\n */\n#ifndef arch_task_cache_init\n#define arch_task_cache_init()\n#endif\n\nvoid __init fork_init(unsigned long mempages)\n{\n#ifndef __HAVE_ARCH_TASK_STRUCT_ALLOCATOR\n#ifndef ARCH_MIN_TASKALIGN\n#define ARCH_MIN_TASKALIGN\tL1_CACHE_BYTES\n#endif\n\t/* create a slab on which task_structs can be allocated */\n\ttask_struct_cachep =\n\t\tkmem_cache_create(\"task_struct\", sizeof(struct task_struct),\n\t\t\tARCH_MIN_TASKALIGN, SLAB_PANIC, NULL);\n#endif\n\n\t/* do the arch specific task caches init */\n\tarch_task_cache_init();\n\n\t/*\n\t * The default maximum number of threads is set to a safe\n\t * value: the thread structures can take up at most half\n\t * of memory.\n\t */\n\tmax_threads = mempages / (8 * THREAD_SIZE / PAGE_SIZE);\n\n\t/*\n\t * we need to allow at least 20 threads to boot a system\n\t */\n\tif(max_threads < 20)\n\t\tmax_threads = 20;\n\n\tinit_task.signal->rlim[RLIMIT_NPROC].rlim_cur = max_threads/2;\n\tinit_task.signal->rlim[RLIMIT_NPROC].rlim_max = max_threads/2;\n\tinit_task.signal->rlim[RLIMIT_SIGPENDING] =\n\t\tinit_task.signal->rlim[RLIMIT_NPROC];\n}\n\nint __attribute__((weak)) arch_dup_task_struct(struct task_struct *dst,\n\t\t\t\t\t       struct task_struct *src)\n{\n\t*dst = *src;\n\treturn 0;\n}\n\nstatic struct task_struct *dup_task_struct(struct task_struct *orig)\n{\n\tstruct task_struct *tsk;\n\tstruct thread_info *ti;\n\tint err;\n\n\tprepare_to_copy(orig);\n\n\ttsk = alloc_task_struct();\n\tif (!tsk)\n\t\treturn NULL;\n\n\tti = alloc_thread_info(tsk);\n\tif (!ti) {\n\t\tfree_task_struct(tsk);\n\t\treturn NULL;\n\t}\n\n \terr = arch_dup_task_struct(tsk, orig);\n\tif (err)\n\t\tgoto out;\n\n\ttsk->stack = ti;\n\n\terr = prop_local_init_single(&tsk->dirties);\n\tif (err)\n\t\tgoto out;\n\n\tsetup_thread_stack(tsk, orig);\n\n#ifdef CONFIG_CC_STACKPROTECTOR\n\ttsk->stack_canary = get_random_int();\n#endif\n\n\t/* One for us, one for whoever does the \"release_task()\" (usually parent) */\n\tatomic_set(&tsk->usage,2);\n\tatomic_set(&tsk->fs_excl, 0);\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n\ttsk->btrace_seq = 0;\n#endif\n\ttsk->splice_pipe = NULL;\n\treturn tsk;\n\nout:\n\tfree_thread_info(ti);\n\tfree_task_struct(tsk);\n\treturn NULL;\n}\n\n#ifdef CONFIG_MMU\nstatic int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)\n{\n\tstruct vm_area_struct *mpnt, *tmp, **pprev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tint retval;\n\tunsigned long charge;\n\tstruct mempolicy *pol;\n\n\tdown_write(&oldmm->mmap_sem);\n\tflush_cache_dup_mm(oldmm);\n\t/*\n\t * Not linked in yet - no deadlock potential:\n\t */\n\tdown_write_nested(&mm->mmap_sem, SINGLE_DEPTH_NESTING);\n\n\tmm->locked_vm = 0;\n\tmm->mmap = NULL;\n\tmm->mmap_cache = NULL;\n\tmm->free_area_cache = oldmm->mmap_base;\n\tmm->cached_hole_size = ~0UL;\n\tmm->map_count = 0;\n\tcpus_clear(mm->cpu_vm_mask);\n\tmm->mm_rb = RB_ROOT;\n\trb_link = &mm->mm_rb.rb_node;\n\trb_parent = NULL;\n\tpprev = &mm->mmap;\n\n\tfor (mpnt = oldmm->mmap; mpnt; mpnt = mpnt->vm_next) {\n\t\tstruct file *file;\n\n\t\tif (mpnt->vm_flags & VM_DONTCOPY) {\n\t\t\tlong pages = vma_pages(mpnt);\n\t\t\tmm->total_vm -= pages;\n\t\t\tvm_stat_account(mm, mpnt->vm_flags, mpnt->vm_file,\n\t\t\t\t\t\t\t\t-pages);\n\t\t\tcontinue;\n\t\t}\n\t\tcharge = 0;\n\t\tif (mpnt->vm_flags & VM_ACCOUNT) {\n\t\t\tunsigned int len = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;\n\t\t\tif (security_vm_enough_memory(len))\n\t\t\t\tgoto fail_nomem;\n\t\t\tcharge = len;\n\t\t}\n\t\ttmp = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n\t\tif (!tmp)\n\t\t\tgoto fail_nomem;\n\t\t*tmp = *mpnt;\n\t\tpol = mpol_dup(vma_policy(mpnt));\n\t\tretval = PTR_ERR(pol);\n\t\tif (IS_ERR(pol))\n\t\t\tgoto fail_nomem_policy;\n\t\tvma_set_policy(tmp, pol);\n\t\ttmp->vm_flags &= ~VM_LOCKED;\n\t\ttmp->vm_mm = mm;\n\t\ttmp->vm_next = NULL;\n\t\tanon_vma_link(tmp);\n\t\tfile = tmp->vm_file;\n\t\tif (file) {\n\t\t\tstruct inode *inode = file->f_path.dentry->d_inode;\n\t\t\tget_file(file);\n\t\t\tif (tmp->vm_flags & VM_DENYWRITE)\n\t\t\t\tatomic_dec(&inode->i_writecount);\n\n\t\t\t/* insert tmp into the share list, just after mpnt */\n\t\t\tspin_lock(&file->f_mapping->i_mmap_lock);\n\t\t\ttmp->vm_truncate_count = mpnt->vm_truncate_count;\n\t\t\tflush_dcache_mmap_lock(file->f_mapping);\n\t\t\tvma_prio_tree_add(tmp, mpnt);\n\t\t\tflush_dcache_mmap_unlock(file->f_mapping);\n\t\t\tspin_unlock(&file->f_mapping->i_mmap_lock);\n\t\t}\n\n\t\t/*\n\t\t * Clear hugetlb-related page reserves for children. This only\n\t\t * affects MAP_PRIVATE mappings. Faults generated by the child\n\t\t * are not guaranteed to succeed, even if read-only\n\t\t */\n\t\tif (is_vm_hugetlb_page(tmp))\n\t\t\treset_vma_resv_huge_pages(tmp);\n\n\t\t/*\n\t\t * Link in the new vma and copy the page table entries.\n\t\t */\n\t\t*pprev = tmp;\n\t\tpprev = &tmp->vm_next;\n\n\t\t__vma_link_rb(mm, tmp, rb_link, rb_parent);\n\t\trb_link = &tmp->vm_rb.rb_right;\n\t\trb_parent = &tmp->vm_rb;\n\n\t\tmm->map_count++;\n\t\tretval = copy_page_range(mm, oldmm, mpnt);\n\n\t\tif (tmp->vm_ops && tmp->vm_ops->open)\n\t\t\ttmp->vm_ops->open(tmp);\n\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\t/* a new mm has just been created */\n\tarch_dup_mmap(oldmm, mm);\n\tretval = 0;\nout:\n\tup_write(&mm->mmap_sem);\n\tflush_tlb_mm(oldmm);\n\tup_write(&oldmm->mmap_sem);\n\treturn retval;\nfail_nomem_policy:\n\tkmem_cache_free(vm_area_cachep, tmp);\nfail_nomem:\n\tretval = -ENOMEM;\n\tvm_unacct_memory(charge);\n\tgoto out;\n}\n\nstatic inline int mm_alloc_pgd(struct mm_struct * mm)\n{\n\tmm->pgd = pgd_alloc(mm);\n\tif (unlikely(!mm->pgd))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic inline void mm_free_pgd(struct mm_struct * mm)\n{\n\tpgd_free(mm, mm->pgd);\n}\n#else\n#define dup_mmap(mm, oldmm)\t(0)\n#define mm_alloc_pgd(mm)\t(0)\n#define mm_free_pgd(mm)\n#endif /* CONFIG_MMU */\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(mmlist_lock);\n\n#define allocate_mm()\t(kmem_cache_alloc(mm_cachep, GFP_KERNEL))\n#define free_mm(mm)\t(kmem_cache_free(mm_cachep, (mm)))\n\n#include <linux/init_task.h>\n\nstatic struct mm_struct * mm_init(struct mm_struct * mm, struct task_struct *p)\n{\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->flags = (current->mm) ? current->mm->flags\n\t\t\t\t  : MMF_DUMP_FILTER_DEFAULT;\n\tmm->core_state = NULL;\n\tmm->nr_ptes = 0;\n\tset_mm_counter(mm, file_rss, 0);\n\tset_mm_counter(mm, anon_rss, 0);\n\tspin_lock_init(&mm->page_table_lock);\n\trwlock_init(&mm->ioctx_list_lock);\n\tmm->ioctx_list = NULL;\n\tmm->free_area_cache = TASK_UNMAPPED_BASE;\n\tmm->cached_hole_size = ~0UL;\n\tmm_init_owner(mm, p);\n\n\tif (likely(!mm_alloc_pgd(mm))) {\n\t\tmm->def_flags = 0;\n\t\tmmu_notifier_mm_init(mm);\n\t\treturn mm;\n\t}\n\n\tfree_mm(mm);\n\treturn NULL;\n}\n\n/*\n * Allocate and initialize an mm_struct.\n */\nstruct mm_struct * mm_alloc(void)\n{\n\tstruct mm_struct * mm;\n\n\tmm = allocate_mm();\n\tif (mm) {\n\t\tmemset(mm, 0, sizeof(*mm));\n\t\tmm = mm_init(mm, current);\n\t}\n\treturn mm;\n}\n\n/*\n * Called when the last reference to the mm\n * is dropped: either by a lazy thread or by\n * mmput. Free the page directory and the mm.\n */\nvoid __mmdrop(struct mm_struct *mm)\n{\n\tBUG_ON(mm == &init_mm);\n\tmm_free_pgd(mm);\n\tdestroy_context(mm);\n\tmmu_notifier_mm_destroy(mm);\n\tfree_mm(mm);\n}\nEXPORT_SYMBOL_GPL(__mmdrop);\n\n/*\n * Decrement the use count and release all resources for an mm.\n */\nvoid mmput(struct mm_struct *mm)\n{\n\tmight_sleep();\n\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\texit_aio(mm);\n\t\texit_mmap(mm);\n\t\tset_mm_exe_file(mm, NULL);\n\t\tif (!list_empty(&mm->mmlist)) {\n\t\t\tspin_lock(&mmlist_lock);\n\t\t\tlist_del(&mm->mmlist);\n\t\t\tspin_unlock(&mmlist_lock);\n\t\t}\n\t\tput_swap_token(mm);\n\t\tmmdrop(mm);\n\t}\n}\nEXPORT_SYMBOL_GPL(mmput);\n\n/**\n * get_task_mm - acquire a reference to the task's mm\n *\n * Returns %NULL if the task has no mm.  Checks PF_KTHREAD (meaning\n * this kernel workthread has transiently adopted a user mm with use_mm,\n * to do its AIO) is not set and if so returns a reference to it, after\n * bumping up the use count.  User must release the mm via mmput()\n * after use.  Typically used by /proc and ptrace.\n */\nstruct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tatomic_inc(&mm->mm_users);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}\nEXPORT_SYMBOL_GPL(get_task_mm);\n\n/* Please note the differences between mmput and mm_release.\n * mmput is called whenever we stop holding onto a mm_struct,\n * error success whatever.\n *\n * mm_release is called after a mm_struct has been removed\n * from the current process.\n *\n * This difference is important for error handling, when we\n * only half set up a mm_struct for a new process and need to restore\n * the old one.  Because we mmput the new mm_struct before\n * restoring the old one. . .\n * Eric Biederman 10 January 1998\n */\nvoid mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct completion *vfork_done = tsk->vfork_done;\n\n\t/* Get rid of any cached register state */\n\tdeactivate_mm(tsk, mm);\n\n\t/* notify parent sleeping on vfork() */\n\tif (vfork_done) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork_done);\n\t}\n\n\t/*\n\t * If we're exiting normally, clear a user-space tid field if\n\t * requested.  We leave this alone when dying by signal, to leave\n\t * the value intact in a core dump, and to save the unnecessary\n\t * trouble otherwise.  Userland only wants this done for a sys_exit.\n\t */\n\tif (tsk->clear_child_tid\n\t    && !(tsk->flags & PF_SIGNALED)\n\t    && atomic_read(&mm->mm_users) > 1) {\n\t\tu32 __user * tidptr = tsk->clear_child_tid;\n\t\ttsk->clear_child_tid = NULL;\n\n\t\t/*\n\t\t * We don't check the error code - if userspace has\n\t\t * not set up a proper pointer then tough luck.\n\t\t */\n\t\tput_user(0, tidptr);\n\t\tsys_futex(tidptr, FUTEX_WAKE, 1, NULL, NULL, 0);\n\t}\n}\n\n/*\n * Allocate a new mm structure and copy contents from the\n * mm structure of the passed in task structure.\n */\nstruct mm_struct *dup_mm(struct task_struct *tsk)\n{\n\tstruct mm_struct *mm, *oldmm = current->mm;\n\tint err;\n\n\tif (!oldmm)\n\t\treturn NULL;\n\n\tmm = allocate_mm();\n\tif (!mm)\n\t\tgoto fail_nomem;\n\n\tmemcpy(mm, oldmm, sizeof(*mm));\n\n\t/* Initializing for Swap token stuff */\n\tmm->token_priority = 0;\n\tmm->last_interval = 0;\n\n\tif (!mm_init(mm, tsk))\n\t\tgoto fail_nomem;\n\n\tif (init_new_context(tsk, mm))\n\t\tgoto fail_nocontext;\n\n\tdup_mm_exe_file(oldmm, mm);\n\n\terr = dup_mmap(mm, oldmm);\n\tif (err)\n\t\tgoto free_pt;\n\n\tmm->hiwater_rss = get_mm_rss(mm);\n\tmm->hiwater_vm = mm->total_vm;\n\n\treturn mm;\n\nfree_pt:\n\tmmput(mm);\n\nfail_nomem:\n\treturn NULL;\n\nfail_nocontext:\n\t/*\n\t * If init_new_context() failed, we cannot use mmput() to free the mm\n\t * because it calls destroy_context()\n\t */\n\tmm_free_pgd(mm);\n\tfree_mm(mm);\n\treturn NULL;\n}\n\nstatic int copy_mm(unsigned long clone_flags, struct task_struct * tsk)\n{\n\tstruct mm_struct * mm, *oldmm;\n\tint retval;\n\n\ttsk->min_flt = tsk->maj_flt = 0;\n\ttsk->nvcsw = tsk->nivcsw = 0;\n\n\ttsk->mm = NULL;\n\ttsk->active_mm = NULL;\n\n\t/*\n\t * Are we cloning a kernel thread?\n\t *\n\t * We need to steal a active VM for that..\n\t */\n\toldmm = current->mm;\n\tif (!oldmm)\n\t\treturn 0;\n\n\tif (clone_flags & CLONE_VM) {\n\t\tatomic_inc(&oldmm->mm_users);\n\t\tmm = oldmm;\n\t\tgoto good_mm;\n\t}\n\n\tretval = -ENOMEM;\n\tmm = dup_mm(tsk);\n\tif (!mm)\n\t\tgoto fail_nomem;\n\ngood_mm:\n\t/* Initializing for Swap token stuff */\n\tmm->token_priority = 0;\n\tmm->last_interval = 0;\n\n\ttsk->mm = mm;\n\ttsk->active_mm = mm;\n\treturn 0;\n\nfail_nomem:\n\treturn retval;\n}\n\nstatic struct fs_struct *__copy_fs_struct(struct fs_struct *old)\n{\n\tstruct fs_struct *fs = kmem_cache_alloc(fs_cachep, GFP_KERNEL);\n\t/* We don't need to lock fs - think why ;-) */\n\tif (fs) {\n\t\tatomic_set(&fs->count, 1);\n\t\trwlock_init(&fs->lock);\n\t\tfs->umask = old->umask;\n\t\tread_lock(&old->lock);\n\t\tfs->root = old->root;\n\t\tpath_get(&old->root);\n\t\tfs->pwd = old->pwd;\n\t\tpath_get(&old->pwd);\n\t\tread_unlock(&old->lock);\n\t}\n\treturn fs;\n}\n\nstruct fs_struct *copy_fs_struct(struct fs_struct *old)\n{\n\treturn __copy_fs_struct(old);\n}\n\nEXPORT_SYMBOL_GPL(copy_fs_struct);\n\nstatic int copy_fs(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tif (clone_flags & CLONE_FS) {\n\t\tatomic_inc(&current->fs->count);\n\t\treturn 0;\n\t}\n\ttsk->fs = __copy_fs_struct(current->fs);\n\tif (!tsk->fs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int copy_files(unsigned long clone_flags, struct task_struct * tsk)\n{\n\tstruct files_struct *oldf, *newf;\n\tint error = 0;\n\n\t/*\n\t * A background process may not have any files ...\n\t */\n\toldf = current->files;\n\tif (!oldf)\n\t\tgoto out;\n\n\tif (clone_flags & CLONE_FILES) {\n\t\tatomic_inc(&oldf->count);\n\t\tgoto out;\n\t}\n\n\tnewf = dup_fd(oldf, &error);\n\tif (!newf)\n\t\tgoto out;\n\n\ttsk->files = newf;\n\terror = 0;\nout:\n\treturn error;\n}\n\nstatic int copy_io(unsigned long clone_flags, struct task_struct *tsk)\n{\n#ifdef CONFIG_BLOCK\n\tstruct io_context *ioc = current->io_context;\n\n\tif (!ioc)\n\t\treturn 0;\n\t/*\n\t * Share io context with parent, if CLONE_IO is set\n\t */\n\tif (clone_flags & CLONE_IO) {\n\t\ttsk->io_context = ioc_task_link(ioc);\n\t\tif (unlikely(!tsk->io_context))\n\t\t\treturn -ENOMEM;\n\t} else if (ioprio_valid(ioc->ioprio)) {\n\t\ttsk->io_context = alloc_io_context(GFP_KERNEL, -1);\n\t\tif (unlikely(!tsk->io_context))\n\t\t\treturn -ENOMEM;\n\n\t\ttsk->io_context->ioprio = ioc->ioprio;\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int copy_sighand(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct sighand_struct *sig;\n\n\tif (clone_flags & (CLONE_SIGHAND | CLONE_THREAD)) {\n\t\tatomic_inc(&current->sighand->count);\n\t\treturn 0;\n\t}\n\tsig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\trcu_assign_pointer(tsk->sighand, sig);\n\tif (!sig)\n\t\treturn -ENOMEM;\n\tatomic_set(&sig->count, 1);\n\tmemcpy(sig->action, current->sighand->action, sizeof(sig->action));\n\treturn 0;\n}\n\nvoid __cleanup_sighand(struct sighand_struct *sighand)\n{\n\tif (atomic_dec_and_test(&sighand->count))\n\t\tkmem_cache_free(sighand_cachep, sighand);\n}\n\n\n/*\n * Initialize POSIX timer handling for a thread group.\n */\nstatic void posix_cpu_timers_init_group(struct signal_struct *sig)\n{\n\t/* Thread group counters. */\n\tthread_group_cputime_init(sig);\n\n\t/* Expiration times and increments. */\n\tsig->it_virt_expires = cputime_zero;\n\tsig->it_virt_incr = cputime_zero;\n\tsig->it_prof_expires = cputime_zero;\n\tsig->it_prof_incr = cputime_zero;\n\n\t/* Cached expiration times. */\n\tsig->cputime_expires.prof_exp = cputime_zero;\n\tsig->cputime_expires.virt_exp = cputime_zero;\n\tsig->cputime_expires.sched_exp = 0;\n\n\t/* The timer lists. */\n\tINIT_LIST_HEAD(&sig->cpu_timers[0]);\n\tINIT_LIST_HEAD(&sig->cpu_timers[1]);\n\tINIT_LIST_HEAD(&sig->cpu_timers[2]);\n}\n\nstatic int copy_signal(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct signal_struct *sig;\n\tint ret;\n\n\tif (clone_flags & CLONE_THREAD) {\n\t\tret = thread_group_cputime_clone_thread(current);\n\t\tif (likely(!ret)) {\n\t\t\tatomic_inc(&current->signal->count);\n\t\t\tatomic_inc(&current->signal->live);\n\t\t}\n\t\treturn ret;\n\t}\n\tsig = kmem_cache_alloc(signal_cachep, GFP_KERNEL);\n\ttsk->signal = sig;\n\tif (!sig)\n\t\treturn -ENOMEM;\n\n\tret = copy_thread_group_keys(tsk);\n\tif (ret < 0) {\n\t\tkmem_cache_free(signal_cachep, sig);\n\t\treturn ret;\n\t}\n\n\tatomic_set(&sig->count, 1);\n\tatomic_set(&sig->live, 1);\n\tinit_waitqueue_head(&sig->wait_chldexit);\n\tsig->flags = 0;\n\tsig->group_exit_code = 0;\n\tsig->group_exit_task = NULL;\n\tsig->group_stop_count = 0;\n\tsig->curr_target = tsk;\n\tinit_sigpending(&sig->shared_pending);\n\tINIT_LIST_HEAD(&sig->posix_timers);\n\n\thrtimer_init(&sig->real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tsig->it_real_incr.tv64 = 0;\n\tsig->real_timer.function = it_real_fn;\n\n\tsig->leader = 0;\t/* session leadership doesn't inherit */\n\tsig->tty_old_pgrp = NULL;\n\tsig->tty = NULL;\n\n\tsig->cutime = sig->cstime = cputime_zero;\n\tsig->gtime = cputime_zero;\n\tsig->cgtime = cputime_zero;\n\tsig->nvcsw = sig->nivcsw = sig->cnvcsw = sig->cnivcsw = 0;\n\tsig->min_flt = sig->maj_flt = sig->cmin_flt = sig->cmaj_flt = 0;\n\tsig->inblock = sig->oublock = sig->cinblock = sig->coublock = 0;\n\ttask_io_accounting_init(&sig->ioac);\n\ttaskstats_tgid_init(sig);\n\n\ttask_lock(current->group_leader);\n\tmemcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);\n\ttask_unlock(current->group_leader);\n\n\tposix_cpu_timers_init_group(sig);\n\n\tacct_init_pacct(&sig->pacct);\n\n\ttty_audit_fork(sig);\n\n\treturn 0;\n}\n\nvoid __cleanup_signal(struct signal_struct *sig)\n{\n\tthread_group_cputime_free(sig);\n\texit_thread_group_keys(sig);\n\ttty_kref_put(sig->tty);\n\tkmem_cache_free(signal_cachep, sig);\n}\n\nstatic void cleanup_signal(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\n\tatomic_dec(&sig->live);\n\n\tif (atomic_dec_and_test(&sig->count))\n\t\t__cleanup_signal(sig);\n}\n\nstatic void copy_flags(unsigned long clone_flags, struct task_struct *p)\n{\n\tunsigned long new_flags = p->flags;\n\n\tnew_flags &= ~PF_SUPERPRIV;\n\tnew_flags |= PF_FORKNOEXEC;\n\tnew_flags |= PF_STARTING;\n\tp->flags = new_flags;\n\tclear_freeze_flag(p);\n}\n\nasmlinkage long sys_set_tid_address(int __user *tidptr)\n{\n\tcurrent->clear_child_tid = tidptr;\n\n\treturn task_pid_vnr(current);\n}\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\tspin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tplist_head_init(&p->pi_waiters, &p->pi_lock);\n\tp->pi_blocked_on = NULL;\n#endif\n}\n\n#ifdef CONFIG_MM_OWNER\nvoid mm_init_owner(struct mm_struct *mm, struct task_struct *p)\n{\n\tmm->owner = p;\n}\n#endif /* CONFIG_MM_OWNER */\n\n/*\n * Initialize POSIX timer handling for a single task.\n */\nstatic void posix_cpu_timers_init(struct task_struct *tsk)\n{\n\ttsk->cputime_expires.prof_exp = cputime_zero;\n\ttsk->cputime_expires.virt_exp = cputime_zero;\n\ttsk->cputime_expires.sched_exp = 0;\n\tINIT_LIST_HEAD(&tsk->cpu_timers[0]);\n\tINIT_LIST_HEAD(&tsk->cpu_timers[1]);\n\tINIT_LIST_HEAD(&tsk->cpu_timers[2]);\n}\n\n/*\n * This creates a new process as a copy of the old one,\n * but does not actually start it yet.\n *\n * It copies the registers, and all the appropriate\n * parts of the process environment (as per the clone\n * flags). The actual kick-off is left to the caller.\n */\nstatic struct task_struct *copy_process(unsigned long clone_flags,\n\t\t\t\t\tunsigned long stack_start,\n\t\t\t\t\tstruct pt_regs *regs,\n\t\t\t\t\tunsigned long stack_size,\n\t\t\t\t\tint __user *child_tidptr,\n\t\t\t\t\tstruct pid *pid,\n\t\t\t\t\tint trace)\n{\n\tint retval;\n\tstruct task_struct *p;\n\tint cgroup_callbacks_done = 0;\n\n\tif ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Thread groups must share signals as well, and detached threads\n\t * can only be started up within the thread group.\n\t */\n\tif ((clone_flags & CLONE_THREAD) && !(clone_flags & CLONE_SIGHAND))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Shared signal handlers imply shared VM. By way of the above,\n\t * thread groups also imply shared VM. Blocking this case allows\n\t * for various simplifications in other code.\n\t */\n\tif ((clone_flags & CLONE_SIGHAND) && !(clone_flags & CLONE_VM))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tretval = security_task_create(clone_flags);\n\tif (retval)\n\t\tgoto fork_out;\n\n\tretval = -ENOMEM;\n\tp = dup_task_struct(current);\n\tif (!p)\n\t\tgoto fork_out;\n\n\trt_mutex_init_task(p);\n\n#ifdef CONFIG_PROVE_LOCKING\n\tDEBUG_LOCKS_WARN_ON(!p->hardirqs_enabled);\n\tDEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);\n#endif\n\tretval = -EAGAIN;\n\tif (atomic_read(&p->user->processes) >=\n\t\t\tp->signal->rlim[RLIMIT_NPROC].rlim_cur) {\n\t\tif (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE) &&\n\t\t    p->user != current->nsproxy->user_ns->root_user)\n\t\t\tgoto bad_fork_free;\n\t}\n\n\tatomic_inc(&p->user->__count);\n\tatomic_inc(&p->user->processes);\n\tget_group_info(p->group_info);\n\n\t/*\n\t * If multiple threads are within copy_process(), then this check\n\t * triggers too late. This doesn't hurt, the check is only there\n\t * to stop root fork bombs.\n\t */\n\tif (nr_threads >= max_threads)\n\t\tgoto bad_fork_cleanup_count;\n\n\tif (!try_module_get(task_thread_info(p)->exec_domain->module))\n\t\tgoto bad_fork_cleanup_count;\n\n\tif (p->binfmt && !try_module_get(p->binfmt->module))\n\t\tgoto bad_fork_cleanup_put_domain;\n\n\tp->did_exec = 0;\n\tdelayacct_tsk_init(p);\t/* Must remain after dup_task_struct() */\n\tcopy_flags(clone_flags, p);\n\tINIT_LIST_HEAD(&p->children);\n\tINIT_LIST_HEAD(&p->sibling);\n#ifdef CONFIG_PREEMPT_RCU\n\tp->rcu_read_lock_nesting = 0;\n\tp->rcu_flipctr_idx = 0;\n#endif /* #ifdef CONFIG_PREEMPT_RCU */\n\tp->vfork_done = NULL;\n\tspin_lock_init(&p->alloc_lock);\n\n\tclear_tsk_thread_flag(p, TIF_SIGPENDING);\n\tinit_sigpending(&p->pending);\n\n\tp->utime = cputime_zero;\n\tp->stime = cputime_zero;\n\tp->gtime = cputime_zero;\n\tp->utimescaled = cputime_zero;\n\tp->stimescaled = cputime_zero;\n\tp->prev_utime = cputime_zero;\n\tp->prev_stime = cputime_zero;\n\n\tp->default_timer_slack_ns = current->timer_slack_ns;\n\n#ifdef CONFIG_DETECT_SOFTLOCKUP\n\tp->last_switch_count = 0;\n\tp->last_switch_timestamp = 0;\n#endif\n\n\ttask_io_accounting_init(&p->ioac);\n\tacct_clear_integrals(p);\n\n\tposix_cpu_timers_init(p);\n\n\tp->lock_depth = -1;\t\t/* -1 = no lock */\n\tdo_posix_clock_monotonic_gettime(&p->start_time);\n\tp->real_start_time = p->start_time;\n\tmonotonic_to_bootbased(&p->real_start_time);\n#ifdef CONFIG_SECURITY\n\tp->security = NULL;\n#endif\n\tp->cap_bset = current->cap_bset;\n\tp->io_context = NULL;\n\tp->audit_context = NULL;\n\tcgroup_fork(p);\n#ifdef CONFIG_NUMA\n\tp->mempolicy = mpol_dup(p->mempolicy);\n \tif (IS_ERR(p->mempolicy)) {\n \t\tretval = PTR_ERR(p->mempolicy);\n \t\tp->mempolicy = NULL;\n \t\tgoto bad_fork_cleanup_cgroup;\n \t}\n\tmpol_fix_fork_child_flag(p);\n#endif\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tp->irq_events = 0;\n#ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW\n\tp->hardirqs_enabled = 1;\n#else\n\tp->hardirqs_enabled = 0;\n#endif\n\tp->hardirq_enable_ip = 0;\n\tp->hardirq_enable_event = 0;\n\tp->hardirq_disable_ip = _THIS_IP_;\n\tp->hardirq_disable_event = 0;\n\tp->softirqs_enabled = 1;\n\tp->softirq_enable_ip = _THIS_IP_;\n\tp->softirq_enable_event = 0;\n\tp->softirq_disable_ip = 0;\n\tp->softirq_disable_event = 0;\n\tp->hardirq_context = 0;\n\tp->softirq_context = 0;\n#endif\n#ifdef CONFIG_LOCKDEP\n\tp->lockdep_depth = 0; /* no locks held yet */\n\tp->curr_chain_key = 0;\n\tp->lockdep_recursion = 0;\n#endif\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tp->blocked_on = NULL; /* not blocked yet */\n#endif\n\n\t/* Perform scheduler related setup. Assign this task to a CPU. */\n\tsched_fork(p, clone_flags);\n\n\tif ((retval = security_task_alloc(p)))\n\t\tgoto bad_fork_cleanup_policy;\n\tif ((retval = audit_alloc(p)))\n\t\tgoto bad_fork_cleanup_security;\n\t/* copy all the process information */\n\tif ((retval = copy_semundo(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_audit;\n\tif ((retval = copy_files(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_semundo;\n\tif ((retval = copy_fs(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_files;\n\tif ((retval = copy_sighand(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_fs;\n\tif ((retval = copy_signal(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_sighand;\n\tif ((retval = copy_mm(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_signal;\n\tif ((retval = copy_keys(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_mm;\n\tif ((retval = copy_namespaces(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_keys;\n\tif ((retval = copy_io(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_namespaces;\n\tretval = copy_thread(0, clone_flags, stack_start, stack_size, p, regs);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_io;\n\n\tif (pid != &init_struct_pid) {\n\t\tretval = -ENOMEM;\n\t\tpid = alloc_pid(task_active_pid_ns(p));\n\t\tif (!pid)\n\t\t\tgoto bad_fork_cleanup_io;\n\n\t\tif (clone_flags & CLONE_NEWPID) {\n\t\t\tretval = pid_ns_prepare_proc(task_active_pid_ns(p));\n\t\t\tif (retval < 0)\n\t\t\t\tgoto bad_fork_free_pid;\n\t\t}\n\t}\n\n\tp->pid = pid_nr(pid);\n\tp->tgid = p->pid;\n\tif (clone_flags & CLONE_THREAD)\n\t\tp->tgid = current->tgid;\n\n\tif (current->nsproxy != p->nsproxy) {\n\t\tretval = ns_cgroup_clone(p, pid);\n\t\tif (retval)\n\t\t\tgoto bad_fork_free_pid;\n\t}\n\n\tp->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? child_tidptr : NULL;\n\t/*\n\t * Clear TID on mm_release()?\n\t */\n\tp->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? child_tidptr: NULL;\n#ifdef CONFIG_FUTEX\n\tp->robust_list = NULL;\n#ifdef CONFIG_COMPAT\n\tp->compat_robust_list = NULL;\n#endif\n\tINIT_LIST_HEAD(&p->pi_state_list);\n\tp->pi_state_cache = NULL;\n#endif\n\t/*\n\t * sigaltstack should be cleared when sharing the same VM\n\t */\n\tif ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n\t\tp->sas_ss_sp = p->sas_ss_size = 0;\n\n\t/*\n\t * Syscall tracing should be turned off in the child regardless\n\t * of CLONE_PTRACE.\n\t */\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);\n#ifdef TIF_SYSCALL_EMU\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_EMU);\n#endif\n\tclear_all_latency_tracing(p);\n\n\t/* Our parent execution domain becomes current domain\n\t   These must match for thread signalling to apply */\n\tp->parent_exec_id = p->self_exec_id;\n\n\t/* ok, now we should be set up.. */\n\tp->exit_signal = (clone_flags & CLONE_THREAD) ? -1 : (clone_flags & CSIGNAL);\n\tp->pdeath_signal = 0;\n\tp->exit_state = 0;\n\n\t/*\n\t * Ok, make it visible to the rest of the system.\n\t * We dont wake it up yet.\n\t */\n\tp->group_leader = p;\n\tINIT_LIST_HEAD(&p->thread_group);\n\n\t/* Now that the task is set up, run cgroup callbacks if\n\t * necessary. We need to run them before the task is visible\n\t * on the tasklist. */\n\tcgroup_fork_callbacks(p);\n\tcgroup_callbacks_done = 1;\n\n\t/* Need tasklist lock for parent etc handling! */\n\twrite_lock_irq(&tasklist_lock);\n\n\t/*\n\t * The task hasn't been attached yet, so its cpus_allowed mask will\n\t * not be changed, nor will its assigned CPU.\n\t *\n\t * The cpus_allowed mask of the parent may have changed after it was\n\t * copied first time - so re-copy it here, then check the child's CPU\n\t * to ensure it is on a valid CPU (and if not, just force it back to\n\t * parent's CPU). This avoids alot of nasty races.\n\t */\n\tp->cpus_allowed = current->cpus_allowed;\n\tp->rt.nr_cpus_allowed = current->rt.nr_cpus_allowed;\n\tif (unlikely(!cpu_isset(task_cpu(p), p->cpus_allowed) ||\n\t\t\t!cpu_online(task_cpu(p))))\n\t\tset_task_cpu(p, smp_processor_id());\n\n\t/* CLONE_PARENT re-uses the old parent */\n\tif (clone_flags & (CLONE_PARENT|CLONE_THREAD))\n\t\tp->real_parent = current->real_parent;\n\telse\n\t\tp->real_parent = current;\n\n\tspin_lock(&current->sighand->siglock);\n\n\t/*\n\t * Process group and session signals need to be delivered to just the\n\t * parent before the fork or both the parent and the child after the\n\t * fork. Restart if a signal comes in before we add the new process to\n\t * it's process group.\n\t * A fatal signal pending means that current will exit, so the new\n\t * thread can't slip out of an OOM kill (or normal SIGKILL).\n \t */\n\trecalc_sigpending();\n\tif (signal_pending(current)) {\n\t\tspin_unlock(&current->sighand->siglock);\n\t\twrite_unlock_irq(&tasklist_lock);\n\t\tretval = -ERESTARTNOINTR;\n\t\tgoto bad_fork_free_pid;\n\t}\n\n\tif (clone_flags & CLONE_THREAD) {\n\t\tp->group_leader = current->group_leader;\n\t\tlist_add_tail_rcu(&p->thread_group, &p->group_leader->thread_group);\n\t}\n\n\tif (likely(p->pid)) {\n\t\tlist_add_tail(&p->sibling, &p->real_parent->children);\n\t\ttracehook_finish_clone(p, clone_flags, trace);\n\n\t\tif (thread_group_leader(p)) {\n\t\t\tif (clone_flags & CLONE_NEWPID)\n\t\t\t\tp->nsproxy->pid_ns->child_reaper = p;\n\n\t\t\tp->signal->leader_pid = pid;\n\t\t\ttty_kref_put(p->signal->tty);\n\t\t\tp->signal->tty = tty_kref_get(current->signal->tty);\n\t\t\tset_task_pgrp(p, task_pgrp_nr(current));\n\t\t\tset_task_session(p, task_session_nr(current));\n\t\t\tattach_pid(p, PIDTYPE_PGID, task_pgrp(current));\n\t\t\tattach_pid(p, PIDTYPE_SID, task_session(current));\n\t\t\tlist_add_tail_rcu(&p->tasks, &init_task.tasks);\n\t\t\t__get_cpu_var(process_counts)++;\n\t\t}\n\t\tattach_pid(p, PIDTYPE_PID, pid);\n\t\tnr_threads++;\n\t}\n\n\ttotal_forks++;\n\tspin_unlock(&current->sighand->siglock);\n\twrite_unlock_irq(&tasklist_lock);\n\tproc_fork_connector(p);\n\tcgroup_post_fork(p);\n\treturn p;\n\nbad_fork_free_pid:\n\tif (pid != &init_struct_pid)\n\t\tfree_pid(pid);\nbad_fork_cleanup_io:\n\tput_io_context(p->io_context);\nbad_fork_cleanup_namespaces:\n\texit_task_namespaces(p);\nbad_fork_cleanup_keys:\n\texit_keys(p);\nbad_fork_cleanup_mm:\n\tif (p->mm)\n\t\tmmput(p->mm);\nbad_fork_cleanup_signal:\n\tcleanup_signal(p);\nbad_fork_cleanup_sighand:\n\t__cleanup_sighand(p->sighand);\nbad_fork_cleanup_fs:\n\texit_fs(p); /* blocking */\nbad_fork_cleanup_files:\n\texit_files(p); /* blocking */\nbad_fork_cleanup_semundo:\n\texit_sem(p);\nbad_fork_cleanup_audit:\n\taudit_free(p);\nbad_fork_cleanup_security:\n\tsecurity_task_free(p);\nbad_fork_cleanup_policy:\n#ifdef CONFIG_NUMA\n\tmpol_put(p->mempolicy);\nbad_fork_cleanup_cgroup:\n#endif\n\tcgroup_exit(p, cgroup_callbacks_done);\n\tdelayacct_tsk_free(p);\n\tif (p->binfmt)\n\t\tmodule_put(p->binfmt->module);\nbad_fork_cleanup_put_domain:\n\tmodule_put(task_thread_info(p)->exec_domain->module);\nbad_fork_cleanup_count:\n\tput_group_info(p->group_info);\n\tatomic_dec(&p->user->processes);\n\tfree_uid(p->user);\nbad_fork_free:\n\tfree_task(p);\nfork_out:\n\treturn ERR_PTR(retval);\n}\n\nnoinline struct pt_regs * __cpuinit __attribute__((weak)) idle_regs(struct pt_regs *regs)\n{\n\tmemset(regs, 0, sizeof(struct pt_regs));\n\treturn regs;\n}\n\nstruct task_struct * __cpuinit fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct pt_regs regs;\n\n\ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n\t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task))\n\t\tinit_idle(task, cpu);\n\n\treturn task;\n}\n\n/*\n *  Ok, this is the main fork-routine.\n *\n * It copies the process, and if successful kick-starts\n * it and waits for it to finish using the VM if required.\n */\nlong do_fork(unsigned long clone_flags,\n\t      unsigned long stack_start,\n\t      struct pt_regs *regs,\n\t      unsigned long stack_size,\n\t      int __user *parent_tidptr,\n\t      int __user *child_tidptr)\n{\n\tstruct task_struct *p;\n\tint trace = 0;\n\tlong nr;\n\n\t/*\n\t * We hope to recycle these flags after 2.6.26\n\t */\n\tif (unlikely(clone_flags & CLONE_STOPPED)) {\n\t\tstatic int __read_mostly count = 100;\n\n\t\tif (count > 0 && printk_ratelimit()) {\n\t\t\tchar comm[TASK_COMM_LEN];\n\n\t\t\tcount--;\n\t\t\tprintk(KERN_INFO \"fork(): process `%s' used deprecated \"\n\t\t\t\t\t\"clone flags 0x%lx\\n\",\n\t\t\t\tget_task_comm(comm, current),\n\t\t\t\tclone_flags & CLONE_STOPPED);\n\t\t}\n\t}\n\n\t/*\n\t * When called from kernel_thread, don't do user tracing stuff.\n\t */\n\tif (likely(user_mode(regs)))\n\t\ttrace = tracehook_prepare_clone(clone_flags);\n\n\tp = copy_process(clone_flags, stack_start, regs, stack_size,\n\t\t\t child_tidptr, NULL, trace);\n\t/*\n\t * Do this prior waking up the new thread - the thread pointer\n\t * might get invalid after that point, if the thread exits quickly.\n\t */\n\tif (!IS_ERR(p)) {\n\t\tstruct completion vfork;\n\n\t\ttrace_sched_process_fork(current, p);\n\n\t\tnr = task_pid_vnr(p);\n\n\t\tif (clone_flags & CLONE_PARENT_SETTID)\n\t\t\tput_user(nr, parent_tidptr);\n\n\t\tif (clone_flags & CLONE_VFORK) {\n\t\t\tp->vfork_done = &vfork;\n\t\t\tinit_completion(&vfork);\n\t\t}\n\n\t\ttracehook_report_clone(trace, regs, clone_flags, nr, p);\n\n\t\t/*\n\t\t * We set PF_STARTING at creation in case tracing wants to\n\t\t * use this to distinguish a fully live task from one that\n\t\t * hasn't gotten to tracehook_report_clone() yet.  Now we\n\t\t * clear it and set the child going.\n\t\t */\n\t\tp->flags &= ~PF_STARTING;\n\n\t\tif (unlikely(clone_flags & CLONE_STOPPED)) {\n\t\t\t/*\n\t\t\t * We'll start up with an immediate SIGSTOP.\n\t\t\t */\n\t\t\tsigaddset(&p->pending.signal, SIGSTOP);\n\t\t\tset_tsk_thread_flag(p, TIF_SIGPENDING);\n\t\t\t__set_task_state(p, TASK_STOPPED);\n\t\t} else {\n\t\t\twake_up_new_task(p, clone_flags);\n\t\t}\n\n\t\ttracehook_report_clone_complete(trace, regs,\n\t\t\t\t\t\tclone_flags, nr, p);\n\n\t\tif (clone_flags & CLONE_VFORK) {\n\t\t\tfreezer_do_not_count();\n\t\t\twait_for_completion(&vfork);\n\t\t\tfreezer_count();\n\t\t\ttracehook_report_vfork_done(p, nr);\n\t\t}\n\t} else {\n\t\tnr = PTR_ERR(p);\n\t}\n\treturn nr;\n}\n\n#ifndef ARCH_MIN_MMSTRUCT_ALIGN\n#define ARCH_MIN_MMSTRUCT_ALIGN 0\n#endif\n\nstatic void sighand_ctor(void *data)\n{\n\tstruct sighand_struct *sighand = data;\n\n\tspin_lock_init(&sighand->siglock);\n\tinit_waitqueue_head(&sighand->signalfd_wqh);\n}\n\nvoid __init proc_caches_init(void)\n{\n\tsighand_cachep = kmem_cache_create(\"sighand_cache\",\n\t\t\tsizeof(struct sighand_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_DESTROY_BY_RCU,\n\t\t\tsighand_ctor);\n\tsignal_cachep = kmem_cache_create(\"signal_cache\",\n\t\t\tsizeof(struct signal_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\tfiles_cachep = kmem_cache_create(\"files_cache\",\n\t\t\tsizeof(struct files_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\tfs_cachep = kmem_cache_create(\"fs_cache\",\n\t\t\tsizeof(struct fs_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\tvm_area_cachep = kmem_cache_create(\"vm_area_struct\",\n\t\t\tsizeof(struct vm_area_struct), 0,\n\t\t\tSLAB_PANIC, NULL);\n\tmm_cachep = kmem_cache_create(\"mm_struct\",\n\t\t\tsizeof(struct mm_struct), ARCH_MIN_MMSTRUCT_ALIGN,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n}\n\n/*\n * Check constraints on flags passed to the unshare system call and\n * force unsharing of additional process context as appropriate.\n */\nstatic void check_unshare_flags(unsigned long *flags_ptr)\n{\n\t/*\n\t * If unsharing a thread from a thread group, must also\n\t * unshare vm.\n\t */\n\tif (*flags_ptr & CLONE_THREAD)\n\t\t*flags_ptr |= CLONE_VM;\n\n\t/*\n\t * If unsharing vm, must also unshare signal handlers.\n\t */\n\tif (*flags_ptr & CLONE_VM)\n\t\t*flags_ptr |= CLONE_SIGHAND;\n\n\t/*\n\t * If unsharing signal handlers and the task was created\n\t * using CLONE_THREAD, then must unshare the thread\n\t */\n\tif ((*flags_ptr & CLONE_SIGHAND) &&\n\t    (atomic_read(&current->signal->count) > 1))\n\t\t*flags_ptr |= CLONE_THREAD;\n\n\t/*\n\t * If unsharing namespace, must also unshare filesystem information.\n\t */\n\tif (*flags_ptr & CLONE_NEWNS)\n\t\t*flags_ptr |= CLONE_FS;\n}\n\n/*\n * Unsharing of tasks created with CLONE_THREAD is not supported yet\n */\nstatic int unshare_thread(unsigned long unshare_flags)\n{\n\tif (unshare_flags & CLONE_THREAD)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/*\n * Unshare the filesystem structure if it is being shared\n */\nstatic int unshare_fs(unsigned long unshare_flags, struct fs_struct **new_fsp)\n{\n\tstruct fs_struct *fs = current->fs;\n\n\tif ((unshare_flags & CLONE_FS) &&\n\t    (fs && atomic_read(&fs->count) > 1)) {\n\t\t*new_fsp = __copy_fs_struct(current->fs);\n\t\tif (!*new_fsp)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Unsharing of sighand is not supported yet\n */\nstatic int unshare_sighand(unsigned long unshare_flags, struct sighand_struct **new_sighp)\n{\n\tstruct sighand_struct *sigh = current->sighand;\n\n\tif ((unshare_flags & CLONE_SIGHAND) && atomic_read(&sigh->count) > 1)\n\t\treturn -EINVAL;\n\telse\n\t\treturn 0;\n}\n\n/*\n * Unshare vm if it is being shared\n */\nstatic int unshare_vm(unsigned long unshare_flags, struct mm_struct **new_mmp)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif ((unshare_flags & CLONE_VM) &&\n\t    (mm && atomic_read(&mm->mm_users) > 1)) {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Unshare file descriptor table if it is being shared\n */\nstatic int unshare_fd(unsigned long unshare_flags, struct files_struct **new_fdp)\n{\n\tstruct files_struct *fd = current->files;\n\tint error = 0;\n\n\tif ((unshare_flags & CLONE_FILES) &&\n\t    (fd && atomic_read(&fd->count) > 1)) {\n\t\t*new_fdp = dup_fd(fd, &error);\n\t\tif (!*new_fdp)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n/*\n * unshare allows a process to 'unshare' part of the process\n * context which was originally shared using clone.  copy_*\n * functions used by do_fork() cannot be used here directly\n * because they modify an inactive task_struct that is being\n * constructed. Here we are modifying the current, active,\n * task_struct.\n */\nasmlinkage long sys_unshare(unsigned long unshare_flags)\n{\n\tint err = 0;\n\tstruct fs_struct *fs, *new_fs = NULL;\n\tstruct sighand_struct *new_sigh = NULL;\n\tstruct mm_struct *mm, *new_mm = NULL, *active_mm = NULL;\n\tstruct files_struct *fd, *new_fd = NULL;\n\tstruct nsproxy *new_nsproxy = NULL;\n\tint do_sysvsem = 0;\n\n\tcheck_unshare_flags(&unshare_flags);\n\n\t/* Return -EINVAL for all unsupported flags */\n\terr = -EINVAL;\n\tif (unshare_flags & ~(CLONE_THREAD|CLONE_FS|CLONE_NEWNS|CLONE_SIGHAND|\n\t\t\t\tCLONE_VM|CLONE_FILES|CLONE_SYSVSEM|\n\t\t\t\tCLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWUSER|\n\t\t\t\tCLONE_NEWNET))\n\t\tgoto bad_unshare_out;\n\n\t/*\n\t * CLONE_NEWIPC must also detach from the undolist: after switching\n\t * to a new ipc namespace, the semaphore arrays from the old\n\t * namespace are unreachable.\n\t */\n\tif (unshare_flags & (CLONE_NEWIPC|CLONE_SYSVSEM))\n\t\tdo_sysvsem = 1;\n\tif ((err = unshare_thread(unshare_flags)))\n\t\tgoto bad_unshare_out;\n\tif ((err = unshare_fs(unshare_flags, &new_fs)))\n\t\tgoto bad_unshare_cleanup_thread;\n\tif ((err = unshare_sighand(unshare_flags, &new_sigh)))\n\t\tgoto bad_unshare_cleanup_fs;\n\tif ((err = unshare_vm(unshare_flags, &new_mm)))\n\t\tgoto bad_unshare_cleanup_sigh;\n\tif ((err = unshare_fd(unshare_flags, &new_fd)))\n\t\tgoto bad_unshare_cleanup_vm;\n\tif ((err = unshare_nsproxy_namespaces(unshare_flags, &new_nsproxy,\n\t\t\tnew_fs)))\n\t\tgoto bad_unshare_cleanup_fd;\n\n\tif (new_fs ||  new_mm || new_fd || do_sysvsem || new_nsproxy) {\n\t\tif (do_sysvsem) {\n\t\t\t/*\n\t\t\t * CLONE_SYSVSEM is equivalent to sys_exit().\n\t\t\t */\n\t\t\texit_sem(current);\n\t\t}\n\n\t\tif (new_nsproxy) {\n\t\t\tswitch_task_namespaces(current, new_nsproxy);\n\t\t\tnew_nsproxy = NULL;\n\t\t}\n\n\t\ttask_lock(current);\n\n\t\tif (new_fs) {\n\t\t\tfs = current->fs;\n\t\t\tcurrent->fs = new_fs;\n\t\t\tnew_fs = fs;\n\t\t}\n\n\t\tif (new_mm) {\n\t\t\tmm = current->mm;\n\t\t\tactive_mm = current->active_mm;\n\t\t\tcurrent->mm = new_mm;\n\t\t\tcurrent->active_mm = new_mm;\n\t\t\tactivate_mm(active_mm, new_mm);\n\t\t\tnew_mm = mm;\n\t\t}\n\n\t\tif (new_fd) {\n\t\t\tfd = current->files;\n\t\t\tcurrent->files = new_fd;\n\t\t\tnew_fd = fd;\n\t\t}\n\n\t\ttask_unlock(current);\n\t}\n\n\tif (new_nsproxy)\n\t\tput_nsproxy(new_nsproxy);\n\nbad_unshare_cleanup_fd:\n\tif (new_fd)\n\t\tput_files_struct(new_fd);\n\nbad_unshare_cleanup_vm:\n\tif (new_mm)\n\t\tmmput(new_mm);\n\nbad_unshare_cleanup_sigh:\n\tif (new_sigh)\n\t\tif (atomic_dec_and_test(&new_sigh->count))\n\t\t\tkmem_cache_free(sighand_cachep, new_sigh);\n\nbad_unshare_cleanup_fs:\n\tif (new_fs)\n\t\tput_fs_struct(new_fs);\n\nbad_unshare_cleanup_thread:\nbad_unshare_out:\n\treturn err;\n}\n\n/*\n *\tHelper to unshare the files of the current task.\n *\tWe don't want to expose copy_files internals to\n *\tthe exec layer of the kernel.\n */\n\nint unshare_files(struct files_struct **displaced)\n{\n\tstruct task_struct *task = current;\n\tstruct files_struct *copy = NULL;\n\tint error;\n\n\terror = unshare_fd(CLONE_FILES, &copy);\n\tif (error || !copy) {\n\t\t*displaced = NULL;\n\t\treturn error;\n\t}\n\t*displaced = task->files;\n\ttask_lock(task);\n\ttask->files = copy;\n\ttask_unlock(task);\n\treturn 0;\n}\n"], "fixing_code": ["/*\n *  linux/kernel/exit.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/completion.h>\n#include <linux/personality.h>\n#include <linux/tty.h>\n#include <linux/mnt_namespace.h>\n#include <linux/iocontext.h>\n#include <linux/key.h>\n#include <linux/security.h>\n#include <linux/cpu.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/binfmts.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/ptrace.h>\n#include <linux/profile.h>\n#include <linux/mount.h>\n#include <linux/proc_fs.h>\n#include <linux/kthread.h>\n#include <linux/mempolicy.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/signal.h>\n#include <linux/posix-timers.h>\n#include <linux/cn_proc.h>\n#include <linux/mutex.h>\n#include <linux/futex.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/resource.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/tracehook.h>\n#include <trace/sched.h>\n\n#include <asm/uaccess.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n\nstatic void exit_mm(struct task_struct * tsk);\n\nstatic inline int task_detached(struct task_struct *p)\n{\n\treturn p->exit_signal == -1;\n}\n\nstatic void __unhash_process(struct task_struct *p)\n{\n\tnr_threads--;\n\tdetach_pid(p, PIDTYPE_PID);\n\tif (thread_group_leader(p)) {\n\t\tdetach_pid(p, PIDTYPE_PGID);\n\t\tdetach_pid(p, PIDTYPE_SID);\n\n\t\tlist_del_rcu(&p->tasks);\n\t\t__get_cpu_var(process_counts)--;\n\t}\n\tlist_del_rcu(&p->thread_group);\n\tlist_del_init(&p->sibling);\n}\n\n/*\n * This function expects the tasklist_lock write-locked.\n */\nstatic void __exit_signal(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tstruct sighand_struct *sighand;\n\n\tBUG_ON(!sig);\n\tBUG_ON(!atomic_read(&sig->count));\n\n\tsighand = rcu_dereference(tsk->sighand);\n\tspin_lock(&sighand->siglock);\n\n\tposix_cpu_timers_exit(tsk);\n\tif (atomic_dec_and_test(&sig->count))\n\t\tposix_cpu_timers_exit_group(tsk);\n\telse {\n\t\t/*\n\t\t * If there is any task waiting for the group exit\n\t\t * then notify it:\n\t\t */\n\t\tif (sig->group_exit_task && atomic_read(&sig->count) == sig->notify_count)\n\t\t\twake_up_process(sig->group_exit_task);\n\n\t\tif (tsk == sig->curr_target)\n\t\t\tsig->curr_target = next_thread(tsk);\n\t\t/*\n\t\t * Accumulate here the counters for all threads but the\n\t\t * group leader as they die, so they can be added into\n\t\t * the process-wide totals when those are taken.\n\t\t * The group leader stays around as a zombie as long\n\t\t * as there are other threads.  When it gets reaped,\n\t\t * the exit.c code will add its counts into these totals.\n\t\t * We won't ever get here for the group leader, since it\n\t\t * will have been the last reference on the signal_struct.\n\t\t */\n\t\tsig->gtime = cputime_add(sig->gtime, task_gtime(tsk));\n\t\tsig->min_flt += tsk->min_flt;\n\t\tsig->maj_flt += tsk->maj_flt;\n\t\tsig->nvcsw += tsk->nvcsw;\n\t\tsig->nivcsw += tsk->nivcsw;\n\t\tsig->inblock += task_io_get_inblock(tsk);\n\t\tsig->oublock += task_io_get_oublock(tsk);\n\t\ttask_io_accounting_add(&sig->ioac, &tsk->ioac);\n\t\tsig = NULL; /* Marker for below. */\n\t}\n\n\t__unhash_process(tsk);\n\n\t/*\n\t * Do this under ->siglock, we can race with another thread\n\t * doing sigqueue_free() if we have SIGQUEUE_PREALLOC signals.\n\t */\n\tflush_sigqueue(&tsk->pending);\n\n\ttsk->signal = NULL;\n\ttsk->sighand = NULL;\n\tspin_unlock(&sighand->siglock);\n\n\t__cleanup_sighand(sighand);\n\tclear_tsk_thread_flag(tsk,TIF_SIGPENDING);\n\tif (sig) {\n\t\tflush_sigqueue(&sig->shared_pending);\n\t\ttaskstats_tgid_free(sig);\n\t\t/*\n\t\t * Make sure ->signal can't go away under rq->lock,\n\t\t * see account_group_exec_runtime().\n\t\t */\n\t\ttask_rq_unlock_wait(tsk);\n\t\t__cleanup_signal(sig);\n\t}\n}\n\nstatic void delayed_put_task_struct(struct rcu_head *rhp)\n{\n\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);\n\n\ttrace_sched_process_free(tsk);\n\tput_task_struct(tsk);\n}\n\n\nvoid release_task(struct task_struct * p)\n{\n\tstruct task_struct *leader;\n\tint zap_leader;\nrepeat:\n\ttracehook_prepare_release_task(p);\n\tatomic_dec(&p->user->processes);\n\tproc_flush_task(p);\n\twrite_lock_irq(&tasklist_lock);\n\ttracehook_finish_release_task(p);\n\t__exit_signal(p);\n\n\t/*\n\t * If we are the last non-leader member of the thread\n\t * group, and the leader is zombie, then notify the\n\t * group leader's parent process. (if it wants notification.)\n\t */\n\tzap_leader = 0;\n\tleader = p->group_leader;\n\tif (leader != p && thread_group_empty(leader) && leader->exit_state == EXIT_ZOMBIE) {\n\t\tBUG_ON(task_detached(leader));\n\t\tdo_notify_parent(leader, leader->exit_signal);\n\t\t/*\n\t\t * If we were the last child thread and the leader has\n\t\t * exited already, and the leader's parent ignores SIGCHLD,\n\t\t * then we are the one who should release the leader.\n\t\t *\n\t\t * do_notify_parent() will have marked it self-reaping in\n\t\t * that case.\n\t\t */\n\t\tzap_leader = task_detached(leader);\n\n\t\t/*\n\t\t * This maintains the invariant that release_task()\n\t\t * only runs on a task in EXIT_DEAD, just for sanity.\n\t\t */\n\t\tif (zap_leader)\n\t\t\tleader->exit_state = EXIT_DEAD;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\trelease_thread(p);\n\tcall_rcu(&p->rcu, delayed_put_task_struct);\n\n\tp = leader;\n\tif (unlikely(zap_leader))\n\t\tgoto repeat;\n}\n\n/*\n * This checks not only the pgrp, but falls back on the pid if no\n * satisfactory pgrp is found. I dunno - gdb doesn't work correctly\n * without this...\n *\n * The caller must hold rcu lock or the tasklist lock.\n */\nstruct pid *session_of_pgrp(struct pid *pgrp)\n{\n\tstruct task_struct *p;\n\tstruct pid *sid = NULL;\n\n\tp = pid_task(pgrp, PIDTYPE_PGID);\n\tif (p == NULL)\n\t\tp = pid_task(pgrp, PIDTYPE_PID);\n\tif (p != NULL)\n\t\tsid = task_session(p);\n\n\treturn sid;\n}\n\n/*\n * Determine if a process group is \"orphaned\", according to the POSIX\n * definition in 2.2.2.52.  Orphaned process groups are not to be affected\n * by terminal-generated stop signals.  Newly orphaned process groups are\n * to receive a SIGHUP and a SIGCONT.\n *\n * \"I ask you, have you ever known what it is to be an orphan?\"\n */\nstatic int will_become_orphaned_pgrp(struct pid *pgrp, struct task_struct *ignored_task)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif ((p == ignored_task) ||\n\t\t    (p->exit_state && thread_group_empty(p)) ||\n\t\t    is_global_init(p->real_parent))\n\t\t\tcontinue;\n\n\t\tif (task_pgrp(p->real_parent) != pgrp &&\n\t\t    task_session(p->real_parent) == task_session(p))\n\t\t\treturn 0;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn 1;\n}\n\nint is_current_pgrp_orphaned(void)\n{\n\tint retval;\n\n\tread_lock(&tasklist_lock);\n\tretval = will_become_orphaned_pgrp(task_pgrp(current), NULL);\n\tread_unlock(&tasklist_lock);\n\n\treturn retval;\n}\n\nstatic int has_stopped_jobs(struct pid *pgrp)\n{\n\tint retval = 0;\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif (!task_is_stopped(p))\n\t\t\tcontinue;\n\t\tretval = 1;\n\t\tbreak;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn retval;\n}\n\n/*\n * Check to see if any process groups have become orphaned as\n * a result of our exiting, and if they have any stopped jobs,\n * send them a SIGHUP and then a SIGCONT. (POSIX 3.2.2.2)\n */\nstatic void\nkill_orphaned_pgrp(struct task_struct *tsk, struct task_struct *parent)\n{\n\tstruct pid *pgrp = task_pgrp(tsk);\n\tstruct task_struct *ignored_task = tsk;\n\n\tif (!parent)\n\t\t /* exit: our father is in a different pgrp than\n\t\t  * we are and we were the only connection outside.\n\t\t  */\n\t\tparent = tsk->real_parent;\n\telse\n\t\t/* reparent: our child is in a different pgrp than\n\t\t * we are, and it was the only connection outside.\n\t\t */\n\t\tignored_task = NULL;\n\n\tif (task_pgrp(parent) != pgrp &&\n\t    task_session(parent) == task_session(tsk) &&\n\t    will_become_orphaned_pgrp(pgrp, ignored_task) &&\n\t    has_stopped_jobs(pgrp)) {\n\t\t__kill_pgrp_info(SIGHUP, SEND_SIG_PRIV, pgrp);\n\t\t__kill_pgrp_info(SIGCONT, SEND_SIG_PRIV, pgrp);\n\t}\n}\n\n/**\n * reparent_to_kthreadd - Reparent the calling kernel thread to kthreadd\n *\n * If a kernel thread is launched as a result of a system call, or if\n * it ever exits, it should generally reparent itself to kthreadd so it\n * isn't in the way of other processes and is correctly cleaned up on exit.\n *\n * The various task state such as scheduling policy and priority may have\n * been inherited from a user process, so we reset them to sane values here.\n *\n * NOTE that reparent_to_kthreadd() gives the caller full capabilities.\n */\nstatic void reparent_to_kthreadd(void)\n{\n\twrite_lock_irq(&tasklist_lock);\n\n\tptrace_unlink(current);\n\t/* Reparent to init */\n\tcurrent->real_parent = current->parent = kthreadd_task;\n\tlist_move_tail(&current->sibling, &current->real_parent->children);\n\n\t/* Set the exit signal to SIGCHLD so we signal init on exit */\n\tcurrent->exit_signal = SIGCHLD;\n\n\tif (task_nice(current) < 0)\n\t\tset_user_nice(current, 0);\n\t/* cpus_allowed? */\n\t/* rt_priority? */\n\t/* signals? */\n\tsecurity_task_reparent_to_init(current);\n\tmemcpy(current->signal->rlim, init_task.signal->rlim,\n\t       sizeof(current->signal->rlim));\n\tatomic_inc(&(INIT_USER->__count));\n\twrite_unlock_irq(&tasklist_lock);\n\tswitch_uid(INIT_USER);\n}\n\nvoid __set_special_pids(struct pid *pid)\n{\n\tstruct task_struct *curr = current->group_leader;\n\tpid_t nr = pid_nr(pid);\n\n\tif (task_session(curr) != pid) {\n\t\tchange_pid(curr, PIDTYPE_SID, pid);\n\t\tset_task_session(curr, nr);\n\t}\n\tif (task_pgrp(curr) != pid) {\n\t\tchange_pid(curr, PIDTYPE_PGID, pid);\n\t\tset_task_pgrp(curr, nr);\n\t}\n}\n\nstatic void set_special_pids(struct pid *pid)\n{\n\twrite_lock_irq(&tasklist_lock);\n\t__set_special_pids(pid);\n\twrite_unlock_irq(&tasklist_lock);\n}\n\n/*\n * Let kernel threads use this to say that they\n * allow a certain signal (since daemonize() will\n * have disabled all of them by default).\n */\nint allow_signal(int sig)\n{\n\tif (!valid_signal(sig) || sig < 1)\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tsigdelset(&current->blocked, sig);\n\tif (!current->mm) {\n\t\t/* Kernel threads handle their own signals.\n\t\t   Let the signal code know it'll be handled, so\n\t\t   that they don't get converted to SIGKILL or\n\t\t   just silently dropped */\n\t\tcurrent->sighand->action[(sig)-1].sa.sa_handler = (void __user *)2;\n\t}\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(allow_signal);\n\nint disallow_signal(int sig)\n{\n\tif (!valid_signal(sig) || sig < 1)\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->sighand->action[(sig)-1].sa.sa_handler = SIG_IGN;\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(disallow_signal);\n\n/*\n *\tPut all the gunge required to become a kernel thread without\n *\tattached user resources in one place where it belongs.\n */\n\nvoid daemonize(const char *name, ...)\n{\n\tva_list args;\n\tstruct fs_struct *fs;\n\tsigset_t blocked;\n\n\tva_start(args, name);\n\tvsnprintf(current->comm, sizeof(current->comm), name, args);\n\tva_end(args);\n\n\t/*\n\t * If we were started as result of loading a module, close all of the\n\t * user space pages.  We don't need them, and if we didn't close them\n\t * they would be locked into memory.\n\t */\n\texit_mm(current);\n\t/*\n\t * We don't want to have TIF_FREEZE set if the system-wide hibernation\n\t * or suspend transition begins right now.\n\t */\n\tcurrent->flags |= (PF_NOFREEZE | PF_KTHREAD);\n\n\tif (current->nsproxy != &init_nsproxy) {\n\t\tget_nsproxy(&init_nsproxy);\n\t\tswitch_task_namespaces(current, &init_nsproxy);\n\t}\n\tset_special_pids(&init_struct_pid);\n\tproc_clear_tty(current);\n\n\t/* Block and flush all signals */\n\tsigfillset(&blocked);\n\tsigprocmask(SIG_BLOCK, &blocked, NULL);\n\tflush_signals(current);\n\n\t/* Become as one with the init task */\n\n\texit_fs(current);\t/* current->fs->count--; */\n\tfs = init_task.fs;\n\tcurrent->fs = fs;\n\tatomic_inc(&fs->count);\n\n\texit_files(current);\n\tcurrent->files = init_task.files;\n\tatomic_inc(&current->files->count);\n\n\treparent_to_kthreadd();\n}\n\nEXPORT_SYMBOL(daemonize);\n\nstatic void close_files(struct files_struct * files)\n{\n\tint i, j;\n\tstruct fdtable *fdt;\n\n\tj = 0;\n\n\t/*\n\t * It is safe to dereference the fd table without RCU or\n\t * ->file_lock because this is the last reference to the\n\t * files structure.\n\t */\n\tfdt = files_fdtable(files);\n\tfor (;;) {\n\t\tunsigned long set;\n\t\ti = j * __NFDBITS;\n\t\tif (i >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->open_fds->fds_bits[j++];\n\t\twhile (set) {\n\t\t\tif (set & 1) {\n\t\t\t\tstruct file * file = xchg(&fdt->fd[i], NULL);\n\t\t\t\tif (file) {\n\t\t\t\t\tfilp_close(file, files);\n\t\t\t\t\tcond_resched();\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\tset >>= 1;\n\t\t}\n\t}\n}\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}\n\nvoid put_files_struct(struct files_struct *files)\n{\n\tstruct fdtable *fdt;\n\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tclose_files(files);\n\t\t/*\n\t\t * Free the fd and fdset arrays if we expanded them.\n\t\t * If the fdtable was embedded, pass files for freeing\n\t\t * at the end of the RCU grace period. Otherwise,\n\t\t * you can free files immediately.\n\t\t */\n\t\tfdt = files_fdtable(files);\n\t\tif (fdt != &files->fdtab)\n\t\t\tkmem_cache_free(files_cachep, files);\n\t\tfree_fdtable(fdt);\n\t}\n}\n\nvoid reset_files_struct(struct files_struct *files)\n{\n\tstruct task_struct *tsk = current;\n\tstruct files_struct *old;\n\n\told = tsk->files;\n\ttask_lock(tsk);\n\ttsk->files = files;\n\ttask_unlock(tsk);\n\tput_files_struct(old);\n}\n\nvoid exit_files(struct task_struct *tsk)\n{\n\tstruct files_struct * files = tsk->files;\n\n\tif (files) {\n\t\ttask_lock(tsk);\n\t\ttsk->files = NULL;\n\t\ttask_unlock(tsk);\n\t\tput_files_struct(files);\n\t}\n}\n\nvoid put_fs_struct(struct fs_struct *fs)\n{\n\t/* No need to hold fs->lock if we are killing it */\n\tif (atomic_dec_and_test(&fs->count)) {\n\t\tpath_put(&fs->root);\n\t\tpath_put(&fs->pwd);\n\t\tkmem_cache_free(fs_cachep, fs);\n\t}\n}\n\nvoid exit_fs(struct task_struct *tsk)\n{\n\tstruct fs_struct * fs = tsk->fs;\n\n\tif (fs) {\n\t\ttask_lock(tsk);\n\t\ttsk->fs = NULL;\n\t\ttask_unlock(tsk);\n\t\tput_fs_struct(fs);\n\t}\n}\n\nEXPORT_SYMBOL_GPL(exit_fs);\n\n#ifdef CONFIG_MM_OWNER\n/*\n * Task p is exiting and it owned mm, lets find a new owner for it\n */\nstatic inline int\nmm_need_new_owner(struct mm_struct *mm, struct task_struct *p)\n{\n\t/*\n\t * If there are other users of the mm and the owner (us) is exiting\n\t * we need to find a new owner to take on the responsibility.\n\t */\n\tif (atomic_read(&mm->mm_users) <= 1)\n\t\treturn 0;\n\tif (mm->owner != p)\n\t\treturn 0;\n\treturn 1;\n}\n\nvoid mm_update_next_owner(struct mm_struct *mm)\n{\n\tstruct task_struct *c, *g, *p = current;\n\nretry:\n\tif (!mm_need_new_owner(mm, p))\n\t\treturn;\n\n\tread_lock(&tasklist_lock);\n\t/*\n\t * Search in the children\n\t */\n\tlist_for_each_entry(c, &p->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t/*\n\t * Search in the siblings\n\t */\n\tlist_for_each_entry(c, &p->parent->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t/*\n\t * Search through everything else. We should not get\n\t * here often\n\t */\n\tdo_each_thread(g, c) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t} while_each_thread(g, c);\n\n\tread_unlock(&tasklist_lock);\n\t/*\n\t * We found no owner yet mm_users > 1: this implies that we are\n\t * most likely racing with swapoff (try_to_unuse()) or /proc or\n\t * ptrace or page migration (get_task_mm()).  Mark owner as NULL,\n\t * so that subsystems can understand the callback and take action.\n\t */\n\tdown_write(&mm->mmap_sem);\n\tcgroup_mm_owner_callbacks(mm->owner, NULL);\n\tmm->owner = NULL;\n\tup_write(&mm->mmap_sem);\n\treturn;\n\nassign_new_owner:\n\tBUG_ON(c == p);\n\tget_task_struct(c);\n\tread_unlock(&tasklist_lock);\n\tdown_write(&mm->mmap_sem);\n\t/*\n\t * The task_lock protects c->mm from changing.\n\t * We always want mm->owner->mm == mm\n\t */\n\ttask_lock(c);\n\tif (c->mm != mm) {\n\t\ttask_unlock(c);\n\t\tup_write(&mm->mmap_sem);\n\t\tput_task_struct(c);\n\t\tgoto retry;\n\t}\n\tcgroup_mm_owner_callbacks(mm->owner, c);\n\tmm->owner = c;\n\ttask_unlock(c);\n\tup_write(&mm->mmap_sem);\n\tput_task_struct(c);\n}\n#endif /* CONFIG_MM_OWNER */\n\n/*\n * Turn us into a lazy TLB process if we\n * aren't already..\n */\nstatic void exit_mm(struct task_struct * tsk)\n{\n\tstruct mm_struct *mm = tsk->mm;\n\tstruct core_state *core_state;\n\n\tmm_release(tsk, mm);\n\tif (!mm)\n\t\treturn;\n\t/*\n\t * Serialize with any possible pending coredump.\n\t * We must hold mmap_sem around checking core_state\n\t * and clearing tsk->mm.  The core-inducing thread\n\t * will increment ->nr_threads for each thread in the\n\t * group with ->mm != NULL.\n\t */\n\tdown_read(&mm->mmap_sem);\n\tcore_state = mm->core_state;\n\tif (core_state) {\n\t\tstruct core_thread self;\n\t\tup_read(&mm->mmap_sem);\n\n\t\tself.task = tsk;\n\t\tself.next = xchg(&core_state->dumper.next, &self);\n\t\t/*\n\t\t * Implies mb(), the result of xchg() must be visible\n\t\t * to core_state->dumper.\n\t\t */\n\t\tif (atomic_dec_and_test(&core_state->nr_threads))\n\t\t\tcomplete(&core_state->startup);\n\n\t\tfor (;;) {\n\t\t\tset_task_state(tsk, TASK_UNINTERRUPTIBLE);\n\t\t\tif (!self.task) /* see coredump_finish() */\n\t\t\t\tbreak;\n\t\t\tschedule();\n\t\t}\n\t\t__set_task_state(tsk, TASK_RUNNING);\n\t\tdown_read(&mm->mmap_sem);\n\t}\n\tatomic_inc(&mm->mm_count);\n\tBUG_ON(mm != tsk->active_mm);\n\t/* more a memory barrier than a real lock */\n\ttask_lock(tsk);\n\ttsk->mm = NULL;\n\tup_read(&mm->mmap_sem);\n\tenter_lazy_tlb(mm, current);\n\t/* We don't want this task to be frozen prematurely */\n\tclear_freeze_flag(tsk);\n\ttask_unlock(tsk);\n\tmm_update_next_owner(mm);\n\tmmput(mm);\n}\n\n/*\n * Return nonzero if @parent's children should reap themselves.\n *\n * Called with write_lock_irq(&tasklist_lock) held.\n */\nstatic int ignoring_children(struct task_struct *parent)\n{\n\tint ret;\n\tstruct sighand_struct *psig = parent->sighand;\n\tunsigned long flags;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tret = (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t       (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT));\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\treturn ret;\n}\n\n/*\n * Detach all tasks we were using ptrace on.\n * Any that need to be release_task'd are put on the @dead list.\n *\n * Called with write_lock(&tasklist_lock) held.\n */\nstatic void ptrace_exit(struct task_struct *parent, struct list_head *dead)\n{\n\tstruct task_struct *p, *n;\n\tint ign = -1;\n\n\tlist_for_each_entry_safe(p, n, &parent->ptraced, ptrace_entry) {\n\t\t__ptrace_unlink(p);\n\n\t\tif (p->exit_state != EXIT_ZOMBIE)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If it's a zombie, our attachedness prevented normal\n\t\t * parent notification or self-reaping.  Do notification\n\t\t * now if it would have happened earlier.  If it should\n\t\t * reap itself, add it to the @dead list.  We can't call\n\t\t * release_task() here because we already hold tasklist_lock.\n\t\t *\n\t\t * If it's our own child, there is no notification to do.\n\t\t * But if our normal children self-reap, then this child\n\t\t * was prevented by ptrace and we must reap it now.\n\t\t */\n\t\tif (!task_detached(p) && thread_group_empty(p)) {\n\t\t\tif (!same_thread_group(p->real_parent, parent))\n\t\t\t\tdo_notify_parent(p, p->exit_signal);\n\t\t\telse {\n\t\t\t\tif (ign < 0)\n\t\t\t\t\tign = ignoring_children(parent);\n\t\t\t\tif (ign)\n\t\t\t\t\tp->exit_signal = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (task_detached(p)) {\n\t\t\t/*\n\t\t\t * Mark it as in the process of being reaped.\n\t\t\t */\n\t\t\tp->exit_state = EXIT_DEAD;\n\t\t\tlist_add(&p->ptrace_entry, dead);\n\t\t}\n\t}\n}\n\n/*\n * Finish up exit-time ptrace cleanup.\n *\n * Called without locks.\n */\nstatic void ptrace_exit_finish(struct task_struct *parent,\n\t\t\t       struct list_head *dead)\n{\n\tstruct task_struct *p, *n;\n\n\tBUG_ON(!list_empty(&parent->ptraced));\n\n\tlist_for_each_entry_safe(p, n, dead, ptrace_entry) {\n\t\tlist_del_init(&p->ptrace_entry);\n\t\trelease_task(p);\n\t}\n}\n\nstatic void reparent_thread(struct task_struct *p, struct task_struct *father)\n{\n\tif (p->pdeath_signal)\n\t\t/* We already hold the tasklist_lock here.  */\n\t\tgroup_send_sig_info(p->pdeath_signal, SEND_SIG_NOINFO, p);\n\n\tlist_move_tail(&p->sibling, &p->real_parent->children);\n\n\t/* If this is a threaded reparent there is no need to\n\t * notify anyone anything has happened.\n\t */\n\tif (same_thread_group(p->real_parent, father))\n\t\treturn;\n\n\t/* We don't want people slaying init.  */\n\tif (!task_detached(p))\n\t\tp->exit_signal = SIGCHLD;\n\n\t/* If we'd notified the old parent about this child's death,\n\t * also notify the new parent.\n\t */\n\tif (!ptrace_reparented(p) &&\n\t    p->exit_state == EXIT_ZOMBIE &&\n\t    !task_detached(p) && thread_group_empty(p))\n\t\tdo_notify_parent(p, p->exit_signal);\n\n\tkill_orphaned_pgrp(p, father);\n}\n\n/*\n * When we die, we re-parent all our children.\n * Try to give them to another thread in our thread\n * group, and if no such member exists, give it to\n * the child reaper process (ie \"init\") in our pid\n * space.\n */\nstatic struct task_struct *find_new_reaper(struct task_struct *father)\n{\n\tstruct pid_namespace *pid_ns = task_active_pid_ns(father);\n\tstruct task_struct *thread;\n\n\tthread = father;\n\twhile_each_thread(father, thread) {\n\t\tif (thread->flags & PF_EXITING)\n\t\t\tcontinue;\n\t\tif (unlikely(pid_ns->child_reaper == father))\n\t\t\tpid_ns->child_reaper = thread;\n\t\treturn thread;\n\t}\n\n\tif (unlikely(pid_ns->child_reaper == father)) {\n\t\twrite_unlock_irq(&tasklist_lock);\n\t\tif (unlikely(pid_ns == &init_pid_ns))\n\t\t\tpanic(\"Attempted to kill init!\");\n\n\t\tzap_pid_ns_processes(pid_ns);\n\t\twrite_lock_irq(&tasklist_lock);\n\t\t/*\n\t\t * We can not clear ->child_reaper or leave it alone.\n\t\t * There may by stealth EXIT_DEAD tasks on ->children,\n\t\t * forget_original_parent() must move them somewhere.\n\t\t */\n\t\tpid_ns->child_reaper = init_pid_ns.child_reaper;\n\t}\n\n\treturn pid_ns->child_reaper;\n}\n\nstatic void forget_original_parent(struct task_struct *father)\n{\n\tstruct task_struct *p, *n, *reaper;\n\tLIST_HEAD(ptrace_dead);\n\n\twrite_lock_irq(&tasklist_lock);\n\treaper = find_new_reaper(father);\n\t/*\n\t * First clean up ptrace if we were using it.\n\t */\n\tptrace_exit(father, &ptrace_dead);\n\n\tlist_for_each_entry_safe(p, n, &father->children, sibling) {\n\t\tp->real_parent = reaper;\n\t\tif (p->parent == father) {\n\t\t\tBUG_ON(p->ptrace);\n\t\t\tp->parent = p->real_parent;\n\t\t}\n\t\treparent_thread(p, father);\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\tBUG_ON(!list_empty(&father->children));\n\n\tptrace_exit_finish(father, &ptrace_dead);\n}\n\n/*\n * Send signals to all our closest relatives so that they know\n * to properly mourn us..\n */\nstatic void exit_notify(struct task_struct *tsk, int group_dead)\n{\n\tint signal;\n\tvoid *cookie;\n\n\t/*\n\t * This does two things:\n\t *\n  \t * A.  Make init inherit all the child processes\n\t * B.  Check to see if any process groups have become orphaned\n\t *\tas a result of our exiting, and if they have any stopped\n\t *\tjobs, send them a SIGHUP and then a SIGCONT.  (POSIX 3.2.2.2)\n\t */\n\tforget_original_parent(tsk);\n\texit_task_namespaces(tsk);\n\n\twrite_lock_irq(&tasklist_lock);\n\tif (group_dead)\n\t\tkill_orphaned_pgrp(tsk->group_leader, NULL);\n\n\t/* Let father know we died\n\t *\n\t * Thread signals are configurable, but you aren't going to use\n\t * that to send signals to arbitary processes.\n\t * That stops right now.\n\t *\n\t * If the parent exec id doesn't match the exec id we saved\n\t * when we started then we know the parent has changed security\n\t * domain.\n\t *\n\t * If our self_exec id doesn't match our parent_exec_id then\n\t * we have changed execution domain as these two values started\n\t * the same after a fork.\n\t */\n\tif (tsk->exit_signal != SIGCHLD && !task_detached(tsk) &&\n\t    (tsk->parent_exec_id != tsk->real_parent->self_exec_id ||\n\t     tsk->self_exec_id != tsk->parent_exec_id) &&\n\t    !capable(CAP_KILL))\n\t\ttsk->exit_signal = SIGCHLD;\n\n\tsignal = tracehook_notify_death(tsk, &cookie, group_dead);\n\tif (signal >= 0)\n\t\tsignal = do_notify_parent(tsk, signal);\n\n\ttsk->exit_state = signal == DEATH_REAP ? EXIT_DEAD : EXIT_ZOMBIE;\n\n\t/* mt-exec, de_thread() is waiting for us */\n\tif (thread_group_leader(tsk) &&\n\t    tsk->signal->group_exit_task &&\n\t    tsk->signal->notify_count < 0)\n\t\twake_up_process(tsk->signal->group_exit_task);\n\n\twrite_unlock_irq(&tasklist_lock);\n\n\ttracehook_report_death(tsk, signal, cookie, group_dead);\n\n\t/* If the process is dead, release it - nobody will wait for it */\n\tif (signal == DEATH_REAP)\n\t\trelease_task(tsk);\n}\n\n#ifdef CONFIG_DEBUG_STACK_USAGE\nstatic void check_stack_usage(void)\n{\n\tstatic DEFINE_SPINLOCK(low_water_lock);\n\tstatic int lowest_to_date = THREAD_SIZE;\n\tunsigned long *n = end_of_stack(current);\n\tunsigned long free;\n\n\twhile (*n == 0)\n\t\tn++;\n\tfree = (unsigned long)n - (unsigned long)end_of_stack(current);\n\n\tif (free >= lowest_to_date)\n\t\treturn;\n\n\tspin_lock(&low_water_lock);\n\tif (free < lowest_to_date) {\n\t\tprintk(KERN_WARNING \"%s used greatest stack depth: %lu bytes \"\n\t\t\t\t\"left\\n\",\n\t\t\t\tcurrent->comm, free);\n\t\tlowest_to_date = free;\n\t}\n\tspin_unlock(&low_water_lock);\n}\n#else\nstatic inline void check_stack_usage(void) {}\n#endif\n\nNORET_TYPE void do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tprofile_task_exit(tsk);\n\n\tWARN_ON(atomic_read(&tsk->fs_excl));\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"Aiee, killing interrupt handler!\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"Attempted to kill the idle task!\");\n\n\ttracehook_report_exit(&code);\n\n\t/*\n\t * We're taking recursive faults here in do_exit. Safest is to just\n\t * leave this task alone and wait for reboot.\n\t */\n\tif (unlikely(tsk->flags & PF_EXITING)) {\n\t\tprintk(KERN_ALERT\n\t\t\t\"Fixing recursive fault but reboot is needed!\\n\");\n\t\t/*\n\t\t * We can do this unlocked here. The futex code uses\n\t\t * this flag just to verify whether the pi state\n\t\t * cleanup has been done or not. In the worst case it\n\t\t * loops once more. We pretend that the cleanup was\n\t\t * done as there is no way to return. Either the\n\t\t * OWNER_DIED bit is set by now or we push the blocked\n\t\t * task into the wait for ever nirwana as well.\n\t\t */\n\t\ttsk->flags |= PF_EXITPIDONE;\n\t\tif (tsk->io_context)\n\t\t\texit_io_context();\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule();\n\t}\n\n\texit_signals(tsk);  /* sets PF_EXITING */\n\t/*\n\t * tsk->flags are checked in the futex code to protect against\n\t * an exiting task cleaning up the robust pi futexes.\n\t */\n\tsmp_mb();\n\tspin_unlock_wait(&tsk->pi_lock);\n\n\tif (unlikely(in_atomic()))\n\t\tprintk(KERN_INFO \"note: %s[%d] exited with preempt_count %d\\n\",\n\t\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\t\tpreempt_count());\n\n\tacct_update_integrals(tsk);\n\tif (tsk->mm) {\n\t\tupdate_hiwater_rss(tsk->mm);\n\t\tupdate_hiwater_vm(tsk->mm);\n\t}\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\tif (unlikely(tsk->audit_context))\n\t\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm(tsk);\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tcheck_stack_usage();\n\texit_thread();\n\tcgroup_exit(tsk, 1);\n\texit_keys(tsk);\n\n\tif (group_dead && tsk->signal->leader)\n\t\tdisassociate_ctty(1);\n\n\tmodule_put(task_thread_info(tsk)->exec_domain->module);\n\tif (tsk->binfmt)\n\t\tmodule_put(tsk->binfmt->module);\n\n\tproc_exit_connector(tsk);\n\texit_notify(tsk, group_dead);\n#ifdef CONFIG_NUMA\n\tmpol_put(tsk->mempolicy);\n\ttsk->mempolicy = NULL;\n#endif\n#ifdef CONFIG_FUTEX\n\t/*\n\t * This must happen late, after the PID is not\n\t * hashed anymore:\n\t */\n\tif (unlikely(!list_empty(&tsk->pi_state_list)))\n\t\texit_pi_state_list(tsk);\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held(tsk);\n\t/*\n\t * We can do this unlocked here. The futex code uses this flag\n\t * just to verify whether the pi state cleanup has been done\n\t * or not. In the worst case it loops once more.\n\t */\n\ttsk->flags |= PF_EXITPIDONE;\n\n\tif (tsk->io_context)\n\t\texit_io_context();\n\n\tif (tsk->splice_pipe)\n\t\t__free_pipe_info(tsk->splice_pipe);\n\n\tpreempt_disable();\n\t/* causes final put_task_struct in finish_task_switch(). */\n\ttsk->state = TASK_DEAD;\n\n\tschedule();\n\tBUG();\n\t/* Avoid \"noreturn function does return\".  */\n\tfor (;;)\n\t\tcpu_relax();\t/* For when BUG is null */\n}\n\nEXPORT_SYMBOL_GPL(do_exit);\n\nNORET_TYPE void complete_and_exit(struct completion *comp, long code)\n{\n\tif (comp)\n\t\tcomplete(comp);\n\n\tdo_exit(code);\n}\n\nEXPORT_SYMBOL(complete_and_exit);\n\nasmlinkage long sys_exit(int error_code)\n{\n\tdo_exit((error_code&0xff)<<8);\n}\n\n/*\n * Take down every thread in the group.  This is called by fatal signals\n * as well as by sys_exit_group (below).\n */\nNORET_TYPE void\ndo_group_exit(int exit_code)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tBUG_ON(exit_code & 0x80); /* core dumps don't get here */\n\n\tif (signal_group_exit(sig))\n\t\texit_code = sig->group_exit_code;\n\telse if (!thread_group_empty(current)) {\n\t\tstruct sighand_struct *const sighand = current->sighand;\n\t\tspin_lock_irq(&sighand->siglock);\n\t\tif (signal_group_exit(sig))\n\t\t\t/* Another thread got here before we took the lock.  */\n\t\t\texit_code = sig->group_exit_code;\n\t\telse {\n\t\t\tsig->group_exit_code = exit_code;\n\t\t\tsig->flags = SIGNAL_GROUP_EXIT;\n\t\t\tzap_other_threads(current);\n\t\t}\n\t\tspin_unlock_irq(&sighand->siglock);\n\t}\n\n\tdo_exit(exit_code);\n\t/* NOTREACHED */\n}\n\n/*\n * this kills every thread in the thread group. Note that any externally\n * wait4()-ing process will get the correct exit code - even if this\n * thread is not the thread group leader.\n */\nasmlinkage void sys_exit_group(int error_code)\n{\n\tdo_group_exit((error_code & 0xff) << 8);\n}\n\nstatic struct pid *task_pid_type(struct task_struct *task, enum pid_type type)\n{\n\tstruct pid *pid = NULL;\n\tif (type == PIDTYPE_PID)\n\t\tpid = task->pids[type].pid;\n\telse if (type < PIDTYPE_MAX)\n\t\tpid = task->group_leader->pids[type].pid;\n\treturn pid;\n}\n\nstatic int eligible_child(enum pid_type type, struct pid *pid, int options,\n\t\t\t  struct task_struct *p)\n{\n\tint err;\n\n\tif (type < PIDTYPE_MAX) {\n\t\tif (task_pid_type(p, type) != pid)\n\t\t\treturn 0;\n\t}\n\n\t/* Wait for all children (clone and not) if __WALL is set;\n\t * otherwise, wait for clone children *only* if __WCLONE is\n\t * set; otherwise, wait for non-clone children *only*.  (Note:\n\t * A \"clone\" child here is one that reports to its parent\n\t * using a signal other than SIGCHLD.) */\n\tif (((p->exit_signal != SIGCHLD) ^ ((options & __WCLONE) != 0))\n\t    && !(options & __WALL))\n\t\treturn 0;\n\n\terr = security_task_wait(p);\n\tif (err)\n\t\treturn err;\n\n\treturn 1;\n}\n\nstatic int wait_noreap_copyout(struct task_struct *p, pid_t pid, uid_t uid,\n\t\t\t       int why, int status,\n\t\t\t       struct siginfo __user *infop,\n\t\t\t       struct rusage __user *rusagep)\n{\n\tint retval = rusagep ? getrusage(p, RUSAGE_BOTH, rusagep) : 0;\n\n\tput_task_struct(p);\n\tif (!retval)\n\t\tretval = put_user(SIGCHLD, &infop->si_signo);\n\tif (!retval)\n\t\tretval = put_user(0, &infop->si_errno);\n\tif (!retval)\n\t\tretval = put_user((short)why, &infop->si_code);\n\tif (!retval)\n\t\tretval = put_user(pid, &infop->si_pid);\n\tif (!retval)\n\t\tretval = put_user(uid, &infop->si_uid);\n\tif (!retval)\n\t\tretval = put_user(status, &infop->si_status);\n\tif (!retval)\n\t\tretval = pid;\n\treturn retval;\n}\n\n/*\n * Handle sys_wait4 work for one task in state EXIT_ZOMBIE.  We hold\n * read_lock(&tasklist_lock) on entry.  If we return zero, we still hold\n * the lock and this task is uninteresting.  If we return nonzero, we have\n * released the lock and the system call should return.\n */\nstatic int wait_task_zombie(struct task_struct *p, int options,\n\t\t\t    struct siginfo __user *infop,\n\t\t\t    int __user *stat_addr, struct rusage __user *ru)\n{\n\tunsigned long state;\n\tint retval, status, traced;\n\tpid_t pid = task_pid_vnr(p);\n\n\tif (!likely(options & WEXITED))\n\t\treturn 0;\n\n\tif (unlikely(options & WNOWAIT)) {\n\t\tuid_t uid = p->uid;\n\t\tint exit_code = p->exit_code;\n\t\tint why, status;\n\n\t\tget_task_struct(p);\n\t\tread_unlock(&tasklist_lock);\n\t\tif ((exit_code & 0x7f) == 0) {\n\t\t\twhy = CLD_EXITED;\n\t\t\tstatus = exit_code >> 8;\n\t\t} else {\n\t\t\twhy = (exit_code & 0x80) ? CLD_DUMPED : CLD_KILLED;\n\t\t\tstatus = exit_code & 0x7f;\n\t\t}\n\t\treturn wait_noreap_copyout(p, pid, uid, why,\n\t\t\t\t\t   status, infop, ru);\n\t}\n\n\t/*\n\t * Try to move the task's state to DEAD\n\t * only one thread is allowed to do this:\n\t */\n\tstate = xchg(&p->exit_state, EXIT_DEAD);\n\tif (state != EXIT_ZOMBIE) {\n\t\tBUG_ON(state != EXIT_DEAD);\n\t\treturn 0;\n\t}\n\n\ttraced = ptrace_reparented(p);\n\n\tif (likely(!traced)) {\n\t\tstruct signal_struct *psig;\n\t\tstruct signal_struct *sig;\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * The resource counters for the group leader are in its\n\t\t * own task_struct.  Those for dead threads in the group\n\t\t * are in its signal_struct, as are those for the child\n\t\t * processes it has previously reaped.  All these\n\t\t * accumulate in the parent's signal_struct c* fields.\n\t\t *\n\t\t * We don't bother to take a lock here to protect these\n\t\t * p->signal fields, because they are only touched by\n\t\t * __exit_signal, which runs with tasklist_lock\n\t\t * write-locked anyway, and so is excluded here.  We do\n\t\t * need to protect the access to p->parent->signal fields,\n\t\t * as other threads in the parent group can be right\n\t\t * here reaping other children at the same time.\n\t\t *\n\t\t * We use thread_group_cputime() to get times for the thread\n\t\t * group, which consolidates times for all threads in the\n\t\t * group including the group leader.\n\t\t */\n\t\tspin_lock_irq(&p->parent->sighand->siglock);\n\t\tpsig = p->parent->signal;\n\t\tsig = p->signal;\n\t\tthread_group_cputime(p, &cputime);\n\t\tpsig->cutime =\n\t\t\tcputime_add(psig->cutime,\n\t\t\tcputime_add(cputime.utime,\n\t\t\t\t    sig->cutime));\n\t\tpsig->cstime =\n\t\t\tcputime_add(psig->cstime,\n\t\t\tcputime_add(cputime.stime,\n\t\t\t\t    sig->cstime));\n\t\tpsig->cgtime =\n\t\t\tcputime_add(psig->cgtime,\n\t\t\tcputime_add(p->gtime,\n\t\t\tcputime_add(sig->gtime,\n\t\t\t\t    sig->cgtime)));\n\t\tpsig->cmin_flt +=\n\t\t\tp->min_flt + sig->min_flt + sig->cmin_flt;\n\t\tpsig->cmaj_flt +=\n\t\t\tp->maj_flt + sig->maj_flt + sig->cmaj_flt;\n\t\tpsig->cnvcsw +=\n\t\t\tp->nvcsw + sig->nvcsw + sig->cnvcsw;\n\t\tpsig->cnivcsw +=\n\t\t\tp->nivcsw + sig->nivcsw + sig->cnivcsw;\n\t\tpsig->cinblock +=\n\t\t\ttask_io_get_inblock(p) +\n\t\t\tsig->inblock + sig->cinblock;\n\t\tpsig->coublock +=\n\t\t\ttask_io_get_oublock(p) +\n\t\t\tsig->oublock + sig->coublock;\n\t\ttask_io_accounting_add(&psig->ioac, &p->ioac);\n\t\ttask_io_accounting_add(&psig->ioac, &sig->ioac);\n\t\tspin_unlock_irq(&p->parent->sighand->siglock);\n\t}\n\n\t/*\n\t * Now we are sure this task is interesting, and no other\n\t * thread can reap it because we set its state to EXIT_DEAD.\n\t */\n\tread_unlock(&tasklist_lock);\n\n\tretval = ru ? getrusage(p, RUSAGE_BOTH, ru) : 0;\n\tstatus = (p->signal->flags & SIGNAL_GROUP_EXIT)\n\t\t? p->signal->group_exit_code : p->exit_code;\n\tif (!retval && stat_addr)\n\t\tretval = put_user(status, stat_addr);\n\tif (!retval && infop)\n\t\tretval = put_user(SIGCHLD, &infop->si_signo);\n\tif (!retval && infop)\n\t\tretval = put_user(0, &infop->si_errno);\n\tif (!retval && infop) {\n\t\tint why;\n\n\t\tif ((status & 0x7f) == 0) {\n\t\t\twhy = CLD_EXITED;\n\t\t\tstatus >>= 8;\n\t\t} else {\n\t\t\twhy = (status & 0x80) ? CLD_DUMPED : CLD_KILLED;\n\t\t\tstatus &= 0x7f;\n\t\t}\n\t\tretval = put_user((short)why, &infop->si_code);\n\t\tif (!retval)\n\t\t\tretval = put_user(status, &infop->si_status);\n\t}\n\tif (!retval && infop)\n\t\tretval = put_user(pid, &infop->si_pid);\n\tif (!retval && infop)\n\t\tretval = put_user(p->uid, &infop->si_uid);\n\tif (!retval)\n\t\tretval = pid;\n\n\tif (traced) {\n\t\twrite_lock_irq(&tasklist_lock);\n\t\t/* We dropped tasklist, ptracer could die and untrace */\n\t\tptrace_unlink(p);\n\t\t/*\n\t\t * If this is not a detached task, notify the parent.\n\t\t * If it's still not detached after that, don't release\n\t\t * it now.\n\t\t */\n\t\tif (!task_detached(p)) {\n\t\t\tdo_notify_parent(p, p->exit_signal);\n\t\t\tif (!task_detached(p)) {\n\t\t\t\tp->exit_state = EXIT_ZOMBIE;\n\t\t\t\tp = NULL;\n\t\t\t}\n\t\t}\n\t\twrite_unlock_irq(&tasklist_lock);\n\t}\n\tif (p != NULL)\n\t\trelease_task(p);\n\n\treturn retval;\n}\n\n/*\n * Handle sys_wait4 work for one task in state TASK_STOPPED.  We hold\n * read_lock(&tasklist_lock) on entry.  If we return zero, we still hold\n * the lock and this task is uninteresting.  If we return nonzero, we have\n * released the lock and the system call should return.\n */\nstatic int wait_task_stopped(int ptrace, struct task_struct *p,\n\t\t\t     int options, struct siginfo __user *infop,\n\t\t\t     int __user *stat_addr, struct rusage __user *ru)\n{\n\tint retval, exit_code, why;\n\tuid_t uid = 0; /* unneeded, required by compiler */\n\tpid_t pid;\n\n\tif (!(options & WUNTRACED))\n\t\treturn 0;\n\n\texit_code = 0;\n\tspin_lock_irq(&p->sighand->siglock);\n\n\tif (unlikely(!task_is_stopped_or_traced(p)))\n\t\tgoto unlock_sig;\n\n\tif (!ptrace && p->signal->group_stop_count > 0)\n\t\t/*\n\t\t * A group stop is in progress and this is the group leader.\n\t\t * We won't report until all threads have stopped.\n\t\t */\n\t\tgoto unlock_sig;\n\n\texit_code = p->exit_code;\n\tif (!exit_code)\n\t\tgoto unlock_sig;\n\n\tif (!unlikely(options & WNOWAIT))\n\t\tp->exit_code = 0;\n\n\tuid = p->uid;\nunlock_sig:\n\tspin_unlock_irq(&p->sighand->siglock);\n\tif (!exit_code)\n\t\treturn 0;\n\n\t/*\n\t * Now we are pretty sure this task is interesting.\n\t * Make sure it doesn't get reaped out from under us while we\n\t * give up the lock and then examine it below.  We don't want to\n\t * keep holding onto the tasklist_lock while we call getrusage and\n\t * possibly take page faults for user memory.\n\t */\n\tget_task_struct(p);\n\tpid = task_pid_vnr(p);\n\twhy = ptrace ? CLD_TRAPPED : CLD_STOPPED;\n\tread_unlock(&tasklist_lock);\n\n\tif (unlikely(options & WNOWAIT))\n\t\treturn wait_noreap_copyout(p, pid, uid,\n\t\t\t\t\t   why, exit_code,\n\t\t\t\t\t   infop, ru);\n\n\tretval = ru ? getrusage(p, RUSAGE_BOTH, ru) : 0;\n\tif (!retval && stat_addr)\n\t\tretval = put_user((exit_code << 8) | 0x7f, stat_addr);\n\tif (!retval && infop)\n\t\tretval = put_user(SIGCHLD, &infop->si_signo);\n\tif (!retval && infop)\n\t\tretval = put_user(0, &infop->si_errno);\n\tif (!retval && infop)\n\t\tretval = put_user((short)why, &infop->si_code);\n\tif (!retval && infop)\n\t\tretval = put_user(exit_code, &infop->si_status);\n\tif (!retval && infop)\n\t\tretval = put_user(pid, &infop->si_pid);\n\tif (!retval && infop)\n\t\tretval = put_user(uid, &infop->si_uid);\n\tif (!retval)\n\t\tretval = pid;\n\tput_task_struct(p);\n\n\tBUG_ON(!retval);\n\treturn retval;\n}\n\n/*\n * Handle do_wait work for one task in a live, non-stopped state.\n * read_lock(&tasklist_lock) on entry.  If we return zero, we still hold\n * the lock and this task is uninteresting.  If we return nonzero, we have\n * released the lock and the system call should return.\n */\nstatic int wait_task_continued(struct task_struct *p, int options,\n\t\t\t       struct siginfo __user *infop,\n\t\t\t       int __user *stat_addr, struct rusage __user *ru)\n{\n\tint retval;\n\tpid_t pid;\n\tuid_t uid;\n\n\tif (!unlikely(options & WCONTINUED))\n\t\treturn 0;\n\n\tif (!(p->signal->flags & SIGNAL_STOP_CONTINUED))\n\t\treturn 0;\n\n\tspin_lock_irq(&p->sighand->siglock);\n\t/* Re-check with the lock held.  */\n\tif (!(p->signal->flags & SIGNAL_STOP_CONTINUED)) {\n\t\tspin_unlock_irq(&p->sighand->siglock);\n\t\treturn 0;\n\t}\n\tif (!unlikely(options & WNOWAIT))\n\t\tp->signal->flags &= ~SIGNAL_STOP_CONTINUED;\n\tspin_unlock_irq(&p->sighand->siglock);\n\n\tpid = task_pid_vnr(p);\n\tuid = p->uid;\n\tget_task_struct(p);\n\tread_unlock(&tasklist_lock);\n\n\tif (!infop) {\n\t\tretval = ru ? getrusage(p, RUSAGE_BOTH, ru) : 0;\n\t\tput_task_struct(p);\n\t\tif (!retval && stat_addr)\n\t\t\tretval = put_user(0xffff, stat_addr);\n\t\tif (!retval)\n\t\t\tretval = pid;\n\t} else {\n\t\tretval = wait_noreap_copyout(p, pid, uid,\n\t\t\t\t\t     CLD_CONTINUED, SIGCONT,\n\t\t\t\t\t     infop, ru);\n\t\tBUG_ON(retval == 0);\n\t}\n\n\treturn retval;\n}\n\n/*\n * Consider @p for a wait by @parent.\n *\n * -ECHILD should be in *@notask_error before the first call.\n * Returns nonzero for a final return, when we have unlocked tasklist_lock.\n * Returns zero if the search for a child should continue;\n * then *@notask_error is 0 if @p is an eligible child,\n * or another error from security_task_wait(), or still -ECHILD.\n */\nstatic int wait_consider_task(struct task_struct *parent, int ptrace,\n\t\t\t      struct task_struct *p, int *notask_error,\n\t\t\t      enum pid_type type, struct pid *pid, int options,\n\t\t\t      struct siginfo __user *infop,\n\t\t\t      int __user *stat_addr, struct rusage __user *ru)\n{\n\tint ret = eligible_child(type, pid, options, p);\n\tif (!ret)\n\t\treturn ret;\n\n\tif (unlikely(ret < 0)) {\n\t\t/*\n\t\t * If we have not yet seen any eligible child,\n\t\t * then let this error code replace -ECHILD.\n\t\t * A permission error will give the user a clue\n\t\t * to look for security policy problems, rather\n\t\t * than for mysterious wait bugs.\n\t\t */\n\t\tif (*notask_error)\n\t\t\t*notask_error = ret;\n\t}\n\n\tif (likely(!ptrace) && unlikely(p->ptrace)) {\n\t\t/*\n\t\t * This child is hidden by ptrace.\n\t\t * We aren't allowed to see it now, but eventually we will.\n\t\t */\n\t\t*notask_error = 0;\n\t\treturn 0;\n\t}\n\n\tif (p->exit_state == EXIT_DEAD)\n\t\treturn 0;\n\n\t/*\n\t * We don't reap group leaders with subthreads.\n\t */\n\tif (p->exit_state == EXIT_ZOMBIE && !delay_group_leader(p))\n\t\treturn wait_task_zombie(p, options, infop, stat_addr, ru);\n\n\t/*\n\t * It's stopped or running now, so it might\n\t * later continue, exit, or stop again.\n\t */\n\t*notask_error = 0;\n\n\tif (task_is_stopped_or_traced(p))\n\t\treturn wait_task_stopped(ptrace, p, options,\n\t\t\t\t\t infop, stat_addr, ru);\n\n\treturn wait_task_continued(p, options, infop, stat_addr, ru);\n}\n\n/*\n * Do the work of do_wait() for one thread in the group, @tsk.\n *\n * -ECHILD should be in *@notask_error before the first call.\n * Returns nonzero for a final return, when we have unlocked tasklist_lock.\n * Returns zero if the search for a child should continue; then\n * *@notask_error is 0 if there were any eligible children,\n * or another error from security_task_wait(), or still -ECHILD.\n */\nstatic int do_wait_thread(struct task_struct *tsk, int *notask_error,\n\t\t\t  enum pid_type type, struct pid *pid, int options,\n\t\t\t  struct siginfo __user *infop, int __user *stat_addr,\n\t\t\t  struct rusage __user *ru)\n{\n\tstruct task_struct *p;\n\n\tlist_for_each_entry(p, &tsk->children, sibling) {\n\t\t/*\n\t\t * Do not consider detached threads.\n\t\t */\n\t\tif (!task_detached(p)) {\n\t\t\tint ret = wait_consider_task(tsk, 0, p, notask_error,\n\t\t\t\t\t\t     type, pid, options,\n\t\t\t\t\t\t     infop, stat_addr, ru);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ptrace_do_wait(struct task_struct *tsk, int *notask_error,\n\t\t\t  enum pid_type type, struct pid *pid, int options,\n\t\t\t  struct siginfo __user *infop, int __user *stat_addr,\n\t\t\t  struct rusage __user *ru)\n{\n\tstruct task_struct *p;\n\n\t/*\n\t * Traditionally we see ptrace'd stopped tasks regardless of options.\n\t */\n\toptions |= WUNTRACED;\n\n\tlist_for_each_entry(p, &tsk->ptraced, ptrace_entry) {\n\t\tint ret = wait_consider_task(tsk, 1, p, notask_error,\n\t\t\t\t\t     type, pid, options,\n\t\t\t\t\t     infop, stat_addr, ru);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic long do_wait(enum pid_type type, struct pid *pid, int options,\n\t\t    struct siginfo __user *infop, int __user *stat_addr,\n\t\t    struct rusage __user *ru)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct task_struct *tsk;\n\tint retval;\n\n\ttrace_sched_process_wait(pid);\n\n\tadd_wait_queue(&current->signal->wait_chldexit,&wait);\nrepeat:\n\t/*\n\t * If there is nothing that can match our critiera just get out.\n\t * We will clear @retval to zero if we see any child that might later\n\t * match our criteria, even if we are not able to reap it yet.\n\t */\n\tretval = -ECHILD;\n\tif ((type < PIDTYPE_MAX) && (!pid || hlist_empty(&pid->tasks[type])))\n\t\tgoto end;\n\n\tcurrent->state = TASK_INTERRUPTIBLE;\n\tread_lock(&tasklist_lock);\n\ttsk = current;\n\tdo {\n\t\tint tsk_result = do_wait_thread(tsk, &retval,\n\t\t\t\t\t\ttype, pid, options,\n\t\t\t\t\t\tinfop, stat_addr, ru);\n\t\tif (!tsk_result)\n\t\t\ttsk_result = ptrace_do_wait(tsk, &retval,\n\t\t\t\t\t\t    type, pid, options,\n\t\t\t\t\t\t    infop, stat_addr, ru);\n\t\tif (tsk_result) {\n\t\t\t/*\n\t\t\t * tasklist_lock is unlocked and we have a final result.\n\t\t\t */\n\t\t\tretval = tsk_result;\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (options & __WNOTHREAD)\n\t\t\tbreak;\n\t\ttsk = next_thread(tsk);\n\t\tBUG_ON(tsk->signal != current->signal);\n\t} while (tsk != current);\n\tread_unlock(&tasklist_lock);\n\n\tif (!retval && !(options & WNOHANG)) {\n\t\tretval = -ERESTARTSYS;\n\t\tif (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tgoto repeat;\n\t\t}\n\t}\n\nend:\n\tcurrent->state = TASK_RUNNING;\n\tremove_wait_queue(&current->signal->wait_chldexit,&wait);\n\tif (infop) {\n\t\tif (retval > 0)\n\t\t\tretval = 0;\n\t\telse {\n\t\t\t/*\n\t\t\t * For a WNOHANG return, clear out all the fields\n\t\t\t * we would set so the user can easily tell the\n\t\t\t * difference.\n\t\t\t */\n\t\t\tif (!retval)\n\t\t\t\tretval = put_user(0, &infop->si_signo);\n\t\t\tif (!retval)\n\t\t\t\tretval = put_user(0, &infop->si_errno);\n\t\t\tif (!retval)\n\t\t\t\tretval = put_user(0, &infop->si_code);\n\t\t\tif (!retval)\n\t\t\t\tretval = put_user(0, &infop->si_pid);\n\t\t\tif (!retval)\n\t\t\t\tretval = put_user(0, &infop->si_uid);\n\t\t\tif (!retval)\n\t\t\t\tretval = put_user(0, &infop->si_status);\n\t\t}\n\t}\n\treturn retval;\n}\n\nasmlinkage long sys_waitid(int which, pid_t upid,\n\t\t\t   struct siginfo __user *infop, int options,\n\t\t\t   struct rusage __user *ru)\n{\n\tstruct pid *pid = NULL;\n\tenum pid_type type;\n\tlong ret;\n\n\tif (options & ~(WNOHANG|WNOWAIT|WEXITED|WSTOPPED|WCONTINUED))\n\t\treturn -EINVAL;\n\tif (!(options & (WEXITED|WSTOPPED|WCONTINUED)))\n\t\treturn -EINVAL;\n\n\tswitch (which) {\n\tcase P_ALL:\n\t\ttype = PIDTYPE_MAX;\n\t\tbreak;\n\tcase P_PID:\n\t\ttype = PIDTYPE_PID;\n\t\tif (upid <= 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase P_PGID:\n\t\ttype = PIDTYPE_PGID;\n\t\tif (upid <= 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (type < PIDTYPE_MAX)\n\t\tpid = find_get_pid(upid);\n\tret = do_wait(type, pid, options, infop, NULL, ru);\n\tput_pid(pid);\n\n\t/* avoid REGPARM breakage on x86: */\n\tasmlinkage_protect(5, ret, which, upid, infop, options, ru);\n\treturn ret;\n}\n\nasmlinkage long sys_wait4(pid_t upid, int __user *stat_addr,\n\t\t\t  int options, struct rusage __user *ru)\n{\n\tstruct pid *pid = NULL;\n\tenum pid_type type;\n\tlong ret;\n\n\tif (options & ~(WNOHANG|WUNTRACED|WCONTINUED|\n\t\t\t__WNOTHREAD|__WCLONE|__WALL))\n\t\treturn -EINVAL;\n\n\tif (upid == -1)\n\t\ttype = PIDTYPE_MAX;\n\telse if (upid < 0) {\n\t\ttype = PIDTYPE_PGID;\n\t\tpid = find_get_pid(-upid);\n\t} else if (upid == 0) {\n\t\ttype = PIDTYPE_PGID;\n\t\tpid = get_pid(task_pgrp(current));\n\t} else /* upid > 0 */ {\n\t\ttype = PIDTYPE_PID;\n\t\tpid = find_get_pid(upid);\n\t}\n\n\tret = do_wait(type, pid, options | WEXITED, NULL, stat_addr, ru);\n\tput_pid(pid);\n\n\t/* avoid REGPARM breakage on x86: */\n\tasmlinkage_protect(4, ret, upid, stat_addr, options, ru);\n\treturn ret;\n}\n\n#ifdef __ARCH_WANT_SYS_WAITPID\n\n/*\n * sys_waitpid() remains for compatibility. waitpid() should be\n * implemented by calling sys_wait4() from libc.a.\n */\nasmlinkage long sys_waitpid(pid_t pid, int __user *stat_addr, int options)\n{\n\treturn sys_wait4(pid, stat_addr, options, NULL);\n}\n\n#endif\n", "/*\n *  linux/kernel/fork.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n/*\n *  'fork.c' contains the help-routines for the 'fork' system call\n * (see also entry.S and others).\n * Fork is rather simple, once you get the hang of it, but the memory\n * management can be a bitch. See 'mm/memory.c': 'copy_page_range()'\n */\n\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/unistd.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/completion.h>\n#include <linux/mnt_namespace.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/sem.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/iocontext.h>\n#include <linux/key.h>\n#include <linux/binfmts.h>\n#include <linux/mman.h>\n#include <linux/mmu_notifier.h>\n#include <linux/fs.h>\n#include <linux/nsproxy.h>\n#include <linux/capability.h>\n#include <linux/cpu.h>\n#include <linux/cgroup.h>\n#include <linux/security.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/jiffies.h>\n#include <linux/tracehook.h>\n#include <linux/futex.h>\n#include <linux/compat.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/rcupdate.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/audit.h>\n#include <linux/memcontrol.h>\n#include <linux/profile.h>\n#include <linux/rmap.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/cn_proc.h>\n#include <linux/freezer.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/random.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/blkdev.h>\n#include <trace/sched.h>\n\n#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/uaccess.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/tlbflush.h>\n\n/*\n * Protected counters by write_lock_irq(&tasklist_lock)\n */\nunsigned long total_forks;\t/* Handle normal Linux uptimes. */\nint nr_threads; \t\t/* The idle threads do not count.. */\n\nint max_threads;\t\t/* tunable limit on nr_threads */\n\nDEFINE_PER_CPU(unsigned long, process_counts) = 0;\n\n__cacheline_aligned DEFINE_RWLOCK(tasklist_lock);  /* outer */\n\nint nr_processes(void)\n{\n\tint cpu;\n\tint total = 0;\n\n\tfor_each_online_cpu(cpu)\n\t\ttotal += per_cpu(process_counts, cpu);\n\n\treturn total;\n}\n\n#ifndef __HAVE_ARCH_TASK_STRUCT_ALLOCATOR\n# define alloc_task_struct()\tkmem_cache_alloc(task_struct_cachep, GFP_KERNEL)\n# define free_task_struct(tsk)\tkmem_cache_free(task_struct_cachep, (tsk))\nstatic struct kmem_cache *task_struct_cachep;\n#endif\n\n#ifndef __HAVE_ARCH_THREAD_INFO_ALLOCATOR\nstatic inline struct thread_info *alloc_thread_info(struct task_struct *tsk)\n{\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tgfp_t mask = GFP_KERNEL | __GFP_ZERO;\n#else\n\tgfp_t mask = GFP_KERNEL;\n#endif\n\treturn (struct thread_info *)__get_free_pages(mask, THREAD_SIZE_ORDER);\n}\n\nstatic inline void free_thread_info(struct thread_info *ti)\n{\n\tfree_pages((unsigned long)ti, THREAD_SIZE_ORDER);\n}\n#endif\n\n/* SLAB cache for signal_struct structures (tsk->signal) */\nstatic struct kmem_cache *signal_cachep;\n\n/* SLAB cache for sighand_struct structures (tsk->sighand) */\nstruct kmem_cache *sighand_cachep;\n\n/* SLAB cache for files_struct structures (tsk->files) */\nstruct kmem_cache *files_cachep;\n\n/* SLAB cache for fs_struct structures (tsk->fs) */\nstruct kmem_cache *fs_cachep;\n\n/* SLAB cache for vm_area_struct structures */\nstruct kmem_cache *vm_area_cachep;\n\n/* SLAB cache for mm_struct structures (tsk->mm) */\nstatic struct kmem_cache *mm_cachep;\n\nvoid free_task(struct task_struct *tsk)\n{\n\tprop_local_destroy_single(&tsk->dirties);\n\tfree_thread_info(tsk->stack);\n\trt_mutex_debug_task_free(tsk);\n\tfree_task_struct(tsk);\n}\nEXPORT_SYMBOL(free_task);\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tsecurity_task_free(tsk);\n\tfree_uid(tsk->user);\n\tput_group_info(tsk->group_info);\n\tdelayacct_tsk_free(tsk);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}\n\n/*\n * macro override instead of weak attribute alias, to workaround\n * gcc 4.1.0 and 4.1.1 bugs with weak attribute and empty functions.\n */\n#ifndef arch_task_cache_init\n#define arch_task_cache_init()\n#endif\n\nvoid __init fork_init(unsigned long mempages)\n{\n#ifndef __HAVE_ARCH_TASK_STRUCT_ALLOCATOR\n#ifndef ARCH_MIN_TASKALIGN\n#define ARCH_MIN_TASKALIGN\tL1_CACHE_BYTES\n#endif\n\t/* create a slab on which task_structs can be allocated */\n\ttask_struct_cachep =\n\t\tkmem_cache_create(\"task_struct\", sizeof(struct task_struct),\n\t\t\tARCH_MIN_TASKALIGN, SLAB_PANIC, NULL);\n#endif\n\n\t/* do the arch specific task caches init */\n\tarch_task_cache_init();\n\n\t/*\n\t * The default maximum number of threads is set to a safe\n\t * value: the thread structures can take up at most half\n\t * of memory.\n\t */\n\tmax_threads = mempages / (8 * THREAD_SIZE / PAGE_SIZE);\n\n\t/*\n\t * we need to allow at least 20 threads to boot a system\n\t */\n\tif(max_threads < 20)\n\t\tmax_threads = 20;\n\n\tinit_task.signal->rlim[RLIMIT_NPROC].rlim_cur = max_threads/2;\n\tinit_task.signal->rlim[RLIMIT_NPROC].rlim_max = max_threads/2;\n\tinit_task.signal->rlim[RLIMIT_SIGPENDING] =\n\t\tinit_task.signal->rlim[RLIMIT_NPROC];\n}\n\nint __attribute__((weak)) arch_dup_task_struct(struct task_struct *dst,\n\t\t\t\t\t       struct task_struct *src)\n{\n\t*dst = *src;\n\treturn 0;\n}\n\nstatic struct task_struct *dup_task_struct(struct task_struct *orig)\n{\n\tstruct task_struct *tsk;\n\tstruct thread_info *ti;\n\tint err;\n\n\tprepare_to_copy(orig);\n\n\ttsk = alloc_task_struct();\n\tif (!tsk)\n\t\treturn NULL;\n\n\tti = alloc_thread_info(tsk);\n\tif (!ti) {\n\t\tfree_task_struct(tsk);\n\t\treturn NULL;\n\t}\n\n \terr = arch_dup_task_struct(tsk, orig);\n\tif (err)\n\t\tgoto out;\n\n\ttsk->stack = ti;\n\n\terr = prop_local_init_single(&tsk->dirties);\n\tif (err)\n\t\tgoto out;\n\n\tsetup_thread_stack(tsk, orig);\n\n#ifdef CONFIG_CC_STACKPROTECTOR\n\ttsk->stack_canary = get_random_int();\n#endif\n\n\t/* One for us, one for whoever does the \"release_task()\" (usually parent) */\n\tatomic_set(&tsk->usage,2);\n\tatomic_set(&tsk->fs_excl, 0);\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n\ttsk->btrace_seq = 0;\n#endif\n\ttsk->splice_pipe = NULL;\n\treturn tsk;\n\nout:\n\tfree_thread_info(ti);\n\tfree_task_struct(tsk);\n\treturn NULL;\n}\n\n#ifdef CONFIG_MMU\nstatic int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)\n{\n\tstruct vm_area_struct *mpnt, *tmp, **pprev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tint retval;\n\tunsigned long charge;\n\tstruct mempolicy *pol;\n\n\tdown_write(&oldmm->mmap_sem);\n\tflush_cache_dup_mm(oldmm);\n\t/*\n\t * Not linked in yet - no deadlock potential:\n\t */\n\tdown_write_nested(&mm->mmap_sem, SINGLE_DEPTH_NESTING);\n\n\tmm->locked_vm = 0;\n\tmm->mmap = NULL;\n\tmm->mmap_cache = NULL;\n\tmm->free_area_cache = oldmm->mmap_base;\n\tmm->cached_hole_size = ~0UL;\n\tmm->map_count = 0;\n\tcpus_clear(mm->cpu_vm_mask);\n\tmm->mm_rb = RB_ROOT;\n\trb_link = &mm->mm_rb.rb_node;\n\trb_parent = NULL;\n\tpprev = &mm->mmap;\n\n\tfor (mpnt = oldmm->mmap; mpnt; mpnt = mpnt->vm_next) {\n\t\tstruct file *file;\n\n\t\tif (mpnt->vm_flags & VM_DONTCOPY) {\n\t\t\tlong pages = vma_pages(mpnt);\n\t\t\tmm->total_vm -= pages;\n\t\t\tvm_stat_account(mm, mpnt->vm_flags, mpnt->vm_file,\n\t\t\t\t\t\t\t\t-pages);\n\t\t\tcontinue;\n\t\t}\n\t\tcharge = 0;\n\t\tif (mpnt->vm_flags & VM_ACCOUNT) {\n\t\t\tunsigned int len = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;\n\t\t\tif (security_vm_enough_memory(len))\n\t\t\t\tgoto fail_nomem;\n\t\t\tcharge = len;\n\t\t}\n\t\ttmp = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n\t\tif (!tmp)\n\t\t\tgoto fail_nomem;\n\t\t*tmp = *mpnt;\n\t\tpol = mpol_dup(vma_policy(mpnt));\n\t\tretval = PTR_ERR(pol);\n\t\tif (IS_ERR(pol))\n\t\t\tgoto fail_nomem_policy;\n\t\tvma_set_policy(tmp, pol);\n\t\ttmp->vm_flags &= ~VM_LOCKED;\n\t\ttmp->vm_mm = mm;\n\t\ttmp->vm_next = NULL;\n\t\tanon_vma_link(tmp);\n\t\tfile = tmp->vm_file;\n\t\tif (file) {\n\t\t\tstruct inode *inode = file->f_path.dentry->d_inode;\n\t\t\tget_file(file);\n\t\t\tif (tmp->vm_flags & VM_DENYWRITE)\n\t\t\t\tatomic_dec(&inode->i_writecount);\n\n\t\t\t/* insert tmp into the share list, just after mpnt */\n\t\t\tspin_lock(&file->f_mapping->i_mmap_lock);\n\t\t\ttmp->vm_truncate_count = mpnt->vm_truncate_count;\n\t\t\tflush_dcache_mmap_lock(file->f_mapping);\n\t\t\tvma_prio_tree_add(tmp, mpnt);\n\t\t\tflush_dcache_mmap_unlock(file->f_mapping);\n\t\t\tspin_unlock(&file->f_mapping->i_mmap_lock);\n\t\t}\n\n\t\t/*\n\t\t * Clear hugetlb-related page reserves for children. This only\n\t\t * affects MAP_PRIVATE mappings. Faults generated by the child\n\t\t * are not guaranteed to succeed, even if read-only\n\t\t */\n\t\tif (is_vm_hugetlb_page(tmp))\n\t\t\treset_vma_resv_huge_pages(tmp);\n\n\t\t/*\n\t\t * Link in the new vma and copy the page table entries.\n\t\t */\n\t\t*pprev = tmp;\n\t\tpprev = &tmp->vm_next;\n\n\t\t__vma_link_rb(mm, tmp, rb_link, rb_parent);\n\t\trb_link = &tmp->vm_rb.rb_right;\n\t\trb_parent = &tmp->vm_rb;\n\n\t\tmm->map_count++;\n\t\tretval = copy_page_range(mm, oldmm, mpnt);\n\n\t\tif (tmp->vm_ops && tmp->vm_ops->open)\n\t\t\ttmp->vm_ops->open(tmp);\n\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\t/* a new mm has just been created */\n\tarch_dup_mmap(oldmm, mm);\n\tretval = 0;\nout:\n\tup_write(&mm->mmap_sem);\n\tflush_tlb_mm(oldmm);\n\tup_write(&oldmm->mmap_sem);\n\treturn retval;\nfail_nomem_policy:\n\tkmem_cache_free(vm_area_cachep, tmp);\nfail_nomem:\n\tretval = -ENOMEM;\n\tvm_unacct_memory(charge);\n\tgoto out;\n}\n\nstatic inline int mm_alloc_pgd(struct mm_struct * mm)\n{\n\tmm->pgd = pgd_alloc(mm);\n\tif (unlikely(!mm->pgd))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic inline void mm_free_pgd(struct mm_struct * mm)\n{\n\tpgd_free(mm, mm->pgd);\n}\n#else\n#define dup_mmap(mm, oldmm)\t(0)\n#define mm_alloc_pgd(mm)\t(0)\n#define mm_free_pgd(mm)\n#endif /* CONFIG_MMU */\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(mmlist_lock);\n\n#define allocate_mm()\t(kmem_cache_alloc(mm_cachep, GFP_KERNEL))\n#define free_mm(mm)\t(kmem_cache_free(mm_cachep, (mm)))\n\n#include <linux/init_task.h>\n\nstatic struct mm_struct * mm_init(struct mm_struct * mm, struct task_struct *p)\n{\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->flags = (current->mm) ? current->mm->flags\n\t\t\t\t  : MMF_DUMP_FILTER_DEFAULT;\n\tmm->core_state = NULL;\n\tmm->nr_ptes = 0;\n\tset_mm_counter(mm, file_rss, 0);\n\tset_mm_counter(mm, anon_rss, 0);\n\tspin_lock_init(&mm->page_table_lock);\n\trwlock_init(&mm->ioctx_list_lock);\n\tmm->ioctx_list = NULL;\n\tmm->free_area_cache = TASK_UNMAPPED_BASE;\n\tmm->cached_hole_size = ~0UL;\n\tmm_init_owner(mm, p);\n\n\tif (likely(!mm_alloc_pgd(mm))) {\n\t\tmm->def_flags = 0;\n\t\tmmu_notifier_mm_init(mm);\n\t\treturn mm;\n\t}\n\n\tfree_mm(mm);\n\treturn NULL;\n}\n\n/*\n * Allocate and initialize an mm_struct.\n */\nstruct mm_struct * mm_alloc(void)\n{\n\tstruct mm_struct * mm;\n\n\tmm = allocate_mm();\n\tif (mm) {\n\t\tmemset(mm, 0, sizeof(*mm));\n\t\tmm = mm_init(mm, current);\n\t}\n\treturn mm;\n}\n\n/*\n * Called when the last reference to the mm\n * is dropped: either by a lazy thread or by\n * mmput. Free the page directory and the mm.\n */\nvoid __mmdrop(struct mm_struct *mm)\n{\n\tBUG_ON(mm == &init_mm);\n\tmm_free_pgd(mm);\n\tdestroy_context(mm);\n\tmmu_notifier_mm_destroy(mm);\n\tfree_mm(mm);\n}\nEXPORT_SYMBOL_GPL(__mmdrop);\n\n/*\n * Decrement the use count and release all resources for an mm.\n */\nvoid mmput(struct mm_struct *mm)\n{\n\tmight_sleep();\n\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\texit_aio(mm);\n\t\texit_mmap(mm);\n\t\tset_mm_exe_file(mm, NULL);\n\t\tif (!list_empty(&mm->mmlist)) {\n\t\t\tspin_lock(&mmlist_lock);\n\t\t\tlist_del(&mm->mmlist);\n\t\t\tspin_unlock(&mmlist_lock);\n\t\t}\n\t\tput_swap_token(mm);\n\t\tmmdrop(mm);\n\t}\n}\nEXPORT_SYMBOL_GPL(mmput);\n\n/**\n * get_task_mm - acquire a reference to the task's mm\n *\n * Returns %NULL if the task has no mm.  Checks PF_KTHREAD (meaning\n * this kernel workthread has transiently adopted a user mm with use_mm,\n * to do its AIO) is not set and if so returns a reference to it, after\n * bumping up the use count.  User must release the mm via mmput()\n * after use.  Typically used by /proc and ptrace.\n */\nstruct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tatomic_inc(&mm->mm_users);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}\nEXPORT_SYMBOL_GPL(get_task_mm);\n\n/* Please note the differences between mmput and mm_release.\n * mmput is called whenever we stop holding onto a mm_struct,\n * error success whatever.\n *\n * mm_release is called after a mm_struct has been removed\n * from the current process.\n *\n * This difference is important for error handling, when we\n * only half set up a mm_struct for a new process and need to restore\n * the old one.  Because we mmput the new mm_struct before\n * restoring the old one. . .\n * Eric Biederman 10 January 1998\n */\nvoid mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct completion *vfork_done = tsk->vfork_done;\n\n\t/* Get rid of any futexes when releasing the mm */\n#ifdef CONFIG_FUTEX\n\tif (unlikely(tsk->robust_list))\n\t\texit_robust_list(tsk);\n#ifdef CONFIG_COMPAT\n\tif (unlikely(tsk->compat_robust_list))\n\t\tcompat_exit_robust_list(tsk);\n#endif\n#endif\n\n\t/* Get rid of any cached register state */\n\tdeactivate_mm(tsk, mm);\n\n\t/* notify parent sleeping on vfork() */\n\tif (vfork_done) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork_done);\n\t}\n\n\t/*\n\t * If we're exiting normally, clear a user-space tid field if\n\t * requested.  We leave this alone when dying by signal, to leave\n\t * the value intact in a core dump, and to save the unnecessary\n\t * trouble otherwise.  Userland only wants this done for a sys_exit.\n\t */\n\tif (tsk->clear_child_tid\n\t    && !(tsk->flags & PF_SIGNALED)\n\t    && atomic_read(&mm->mm_users) > 1) {\n\t\tu32 __user * tidptr = tsk->clear_child_tid;\n\t\ttsk->clear_child_tid = NULL;\n\n\t\t/*\n\t\t * We don't check the error code - if userspace has\n\t\t * not set up a proper pointer then tough luck.\n\t\t */\n\t\tput_user(0, tidptr);\n\t\tsys_futex(tidptr, FUTEX_WAKE, 1, NULL, NULL, 0);\n\t}\n}\n\n/*\n * Allocate a new mm structure and copy contents from the\n * mm structure of the passed in task structure.\n */\nstruct mm_struct *dup_mm(struct task_struct *tsk)\n{\n\tstruct mm_struct *mm, *oldmm = current->mm;\n\tint err;\n\n\tif (!oldmm)\n\t\treturn NULL;\n\n\tmm = allocate_mm();\n\tif (!mm)\n\t\tgoto fail_nomem;\n\n\tmemcpy(mm, oldmm, sizeof(*mm));\n\n\t/* Initializing for Swap token stuff */\n\tmm->token_priority = 0;\n\tmm->last_interval = 0;\n\n\tif (!mm_init(mm, tsk))\n\t\tgoto fail_nomem;\n\n\tif (init_new_context(tsk, mm))\n\t\tgoto fail_nocontext;\n\n\tdup_mm_exe_file(oldmm, mm);\n\n\terr = dup_mmap(mm, oldmm);\n\tif (err)\n\t\tgoto free_pt;\n\n\tmm->hiwater_rss = get_mm_rss(mm);\n\tmm->hiwater_vm = mm->total_vm;\n\n\treturn mm;\n\nfree_pt:\n\tmmput(mm);\n\nfail_nomem:\n\treturn NULL;\n\nfail_nocontext:\n\t/*\n\t * If init_new_context() failed, we cannot use mmput() to free the mm\n\t * because it calls destroy_context()\n\t */\n\tmm_free_pgd(mm);\n\tfree_mm(mm);\n\treturn NULL;\n}\n\nstatic int copy_mm(unsigned long clone_flags, struct task_struct * tsk)\n{\n\tstruct mm_struct * mm, *oldmm;\n\tint retval;\n\n\ttsk->min_flt = tsk->maj_flt = 0;\n\ttsk->nvcsw = tsk->nivcsw = 0;\n\n\ttsk->mm = NULL;\n\ttsk->active_mm = NULL;\n\n\t/*\n\t * Are we cloning a kernel thread?\n\t *\n\t * We need to steal a active VM for that..\n\t */\n\toldmm = current->mm;\n\tif (!oldmm)\n\t\treturn 0;\n\n\tif (clone_flags & CLONE_VM) {\n\t\tatomic_inc(&oldmm->mm_users);\n\t\tmm = oldmm;\n\t\tgoto good_mm;\n\t}\n\n\tretval = -ENOMEM;\n\tmm = dup_mm(tsk);\n\tif (!mm)\n\t\tgoto fail_nomem;\n\ngood_mm:\n\t/* Initializing for Swap token stuff */\n\tmm->token_priority = 0;\n\tmm->last_interval = 0;\n\n\ttsk->mm = mm;\n\ttsk->active_mm = mm;\n\treturn 0;\n\nfail_nomem:\n\treturn retval;\n}\n\nstatic struct fs_struct *__copy_fs_struct(struct fs_struct *old)\n{\n\tstruct fs_struct *fs = kmem_cache_alloc(fs_cachep, GFP_KERNEL);\n\t/* We don't need to lock fs - think why ;-) */\n\tif (fs) {\n\t\tatomic_set(&fs->count, 1);\n\t\trwlock_init(&fs->lock);\n\t\tfs->umask = old->umask;\n\t\tread_lock(&old->lock);\n\t\tfs->root = old->root;\n\t\tpath_get(&old->root);\n\t\tfs->pwd = old->pwd;\n\t\tpath_get(&old->pwd);\n\t\tread_unlock(&old->lock);\n\t}\n\treturn fs;\n}\n\nstruct fs_struct *copy_fs_struct(struct fs_struct *old)\n{\n\treturn __copy_fs_struct(old);\n}\n\nEXPORT_SYMBOL_GPL(copy_fs_struct);\n\nstatic int copy_fs(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tif (clone_flags & CLONE_FS) {\n\t\tatomic_inc(&current->fs->count);\n\t\treturn 0;\n\t}\n\ttsk->fs = __copy_fs_struct(current->fs);\n\tif (!tsk->fs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int copy_files(unsigned long clone_flags, struct task_struct * tsk)\n{\n\tstruct files_struct *oldf, *newf;\n\tint error = 0;\n\n\t/*\n\t * A background process may not have any files ...\n\t */\n\toldf = current->files;\n\tif (!oldf)\n\t\tgoto out;\n\n\tif (clone_flags & CLONE_FILES) {\n\t\tatomic_inc(&oldf->count);\n\t\tgoto out;\n\t}\n\n\tnewf = dup_fd(oldf, &error);\n\tif (!newf)\n\t\tgoto out;\n\n\ttsk->files = newf;\n\terror = 0;\nout:\n\treturn error;\n}\n\nstatic int copy_io(unsigned long clone_flags, struct task_struct *tsk)\n{\n#ifdef CONFIG_BLOCK\n\tstruct io_context *ioc = current->io_context;\n\n\tif (!ioc)\n\t\treturn 0;\n\t/*\n\t * Share io context with parent, if CLONE_IO is set\n\t */\n\tif (clone_flags & CLONE_IO) {\n\t\ttsk->io_context = ioc_task_link(ioc);\n\t\tif (unlikely(!tsk->io_context))\n\t\t\treturn -ENOMEM;\n\t} else if (ioprio_valid(ioc->ioprio)) {\n\t\ttsk->io_context = alloc_io_context(GFP_KERNEL, -1);\n\t\tif (unlikely(!tsk->io_context))\n\t\t\treturn -ENOMEM;\n\n\t\ttsk->io_context->ioprio = ioc->ioprio;\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int copy_sighand(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct sighand_struct *sig;\n\n\tif (clone_flags & (CLONE_SIGHAND | CLONE_THREAD)) {\n\t\tatomic_inc(&current->sighand->count);\n\t\treturn 0;\n\t}\n\tsig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\trcu_assign_pointer(tsk->sighand, sig);\n\tif (!sig)\n\t\treturn -ENOMEM;\n\tatomic_set(&sig->count, 1);\n\tmemcpy(sig->action, current->sighand->action, sizeof(sig->action));\n\treturn 0;\n}\n\nvoid __cleanup_sighand(struct sighand_struct *sighand)\n{\n\tif (atomic_dec_and_test(&sighand->count))\n\t\tkmem_cache_free(sighand_cachep, sighand);\n}\n\n\n/*\n * Initialize POSIX timer handling for a thread group.\n */\nstatic void posix_cpu_timers_init_group(struct signal_struct *sig)\n{\n\t/* Thread group counters. */\n\tthread_group_cputime_init(sig);\n\n\t/* Expiration times and increments. */\n\tsig->it_virt_expires = cputime_zero;\n\tsig->it_virt_incr = cputime_zero;\n\tsig->it_prof_expires = cputime_zero;\n\tsig->it_prof_incr = cputime_zero;\n\n\t/* Cached expiration times. */\n\tsig->cputime_expires.prof_exp = cputime_zero;\n\tsig->cputime_expires.virt_exp = cputime_zero;\n\tsig->cputime_expires.sched_exp = 0;\n\n\t/* The timer lists. */\n\tINIT_LIST_HEAD(&sig->cpu_timers[0]);\n\tINIT_LIST_HEAD(&sig->cpu_timers[1]);\n\tINIT_LIST_HEAD(&sig->cpu_timers[2]);\n}\n\nstatic int copy_signal(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct signal_struct *sig;\n\tint ret;\n\n\tif (clone_flags & CLONE_THREAD) {\n\t\tret = thread_group_cputime_clone_thread(current);\n\t\tif (likely(!ret)) {\n\t\t\tatomic_inc(&current->signal->count);\n\t\t\tatomic_inc(&current->signal->live);\n\t\t}\n\t\treturn ret;\n\t}\n\tsig = kmem_cache_alloc(signal_cachep, GFP_KERNEL);\n\ttsk->signal = sig;\n\tif (!sig)\n\t\treturn -ENOMEM;\n\n\tret = copy_thread_group_keys(tsk);\n\tif (ret < 0) {\n\t\tkmem_cache_free(signal_cachep, sig);\n\t\treturn ret;\n\t}\n\n\tatomic_set(&sig->count, 1);\n\tatomic_set(&sig->live, 1);\n\tinit_waitqueue_head(&sig->wait_chldexit);\n\tsig->flags = 0;\n\tsig->group_exit_code = 0;\n\tsig->group_exit_task = NULL;\n\tsig->group_stop_count = 0;\n\tsig->curr_target = tsk;\n\tinit_sigpending(&sig->shared_pending);\n\tINIT_LIST_HEAD(&sig->posix_timers);\n\n\thrtimer_init(&sig->real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tsig->it_real_incr.tv64 = 0;\n\tsig->real_timer.function = it_real_fn;\n\n\tsig->leader = 0;\t/* session leadership doesn't inherit */\n\tsig->tty_old_pgrp = NULL;\n\tsig->tty = NULL;\n\n\tsig->cutime = sig->cstime = cputime_zero;\n\tsig->gtime = cputime_zero;\n\tsig->cgtime = cputime_zero;\n\tsig->nvcsw = sig->nivcsw = sig->cnvcsw = sig->cnivcsw = 0;\n\tsig->min_flt = sig->maj_flt = sig->cmin_flt = sig->cmaj_flt = 0;\n\tsig->inblock = sig->oublock = sig->cinblock = sig->coublock = 0;\n\ttask_io_accounting_init(&sig->ioac);\n\ttaskstats_tgid_init(sig);\n\n\ttask_lock(current->group_leader);\n\tmemcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);\n\ttask_unlock(current->group_leader);\n\n\tposix_cpu_timers_init_group(sig);\n\n\tacct_init_pacct(&sig->pacct);\n\n\ttty_audit_fork(sig);\n\n\treturn 0;\n}\n\nvoid __cleanup_signal(struct signal_struct *sig)\n{\n\tthread_group_cputime_free(sig);\n\texit_thread_group_keys(sig);\n\ttty_kref_put(sig->tty);\n\tkmem_cache_free(signal_cachep, sig);\n}\n\nstatic void cleanup_signal(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\n\tatomic_dec(&sig->live);\n\n\tif (atomic_dec_and_test(&sig->count))\n\t\t__cleanup_signal(sig);\n}\n\nstatic void copy_flags(unsigned long clone_flags, struct task_struct *p)\n{\n\tunsigned long new_flags = p->flags;\n\n\tnew_flags &= ~PF_SUPERPRIV;\n\tnew_flags |= PF_FORKNOEXEC;\n\tnew_flags |= PF_STARTING;\n\tp->flags = new_flags;\n\tclear_freeze_flag(p);\n}\n\nasmlinkage long sys_set_tid_address(int __user *tidptr)\n{\n\tcurrent->clear_child_tid = tidptr;\n\n\treturn task_pid_vnr(current);\n}\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\tspin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tplist_head_init(&p->pi_waiters, &p->pi_lock);\n\tp->pi_blocked_on = NULL;\n#endif\n}\n\n#ifdef CONFIG_MM_OWNER\nvoid mm_init_owner(struct mm_struct *mm, struct task_struct *p)\n{\n\tmm->owner = p;\n}\n#endif /* CONFIG_MM_OWNER */\n\n/*\n * Initialize POSIX timer handling for a single task.\n */\nstatic void posix_cpu_timers_init(struct task_struct *tsk)\n{\n\ttsk->cputime_expires.prof_exp = cputime_zero;\n\ttsk->cputime_expires.virt_exp = cputime_zero;\n\ttsk->cputime_expires.sched_exp = 0;\n\tINIT_LIST_HEAD(&tsk->cpu_timers[0]);\n\tINIT_LIST_HEAD(&tsk->cpu_timers[1]);\n\tINIT_LIST_HEAD(&tsk->cpu_timers[2]);\n}\n\n/*\n * This creates a new process as a copy of the old one,\n * but does not actually start it yet.\n *\n * It copies the registers, and all the appropriate\n * parts of the process environment (as per the clone\n * flags). The actual kick-off is left to the caller.\n */\nstatic struct task_struct *copy_process(unsigned long clone_flags,\n\t\t\t\t\tunsigned long stack_start,\n\t\t\t\t\tstruct pt_regs *regs,\n\t\t\t\t\tunsigned long stack_size,\n\t\t\t\t\tint __user *child_tidptr,\n\t\t\t\t\tstruct pid *pid,\n\t\t\t\t\tint trace)\n{\n\tint retval;\n\tstruct task_struct *p;\n\tint cgroup_callbacks_done = 0;\n\n\tif ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Thread groups must share signals as well, and detached threads\n\t * can only be started up within the thread group.\n\t */\n\tif ((clone_flags & CLONE_THREAD) && !(clone_flags & CLONE_SIGHAND))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Shared signal handlers imply shared VM. By way of the above,\n\t * thread groups also imply shared VM. Blocking this case allows\n\t * for various simplifications in other code.\n\t */\n\tif ((clone_flags & CLONE_SIGHAND) && !(clone_flags & CLONE_VM))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tretval = security_task_create(clone_flags);\n\tif (retval)\n\t\tgoto fork_out;\n\n\tretval = -ENOMEM;\n\tp = dup_task_struct(current);\n\tif (!p)\n\t\tgoto fork_out;\n\n\trt_mutex_init_task(p);\n\n#ifdef CONFIG_PROVE_LOCKING\n\tDEBUG_LOCKS_WARN_ON(!p->hardirqs_enabled);\n\tDEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);\n#endif\n\tretval = -EAGAIN;\n\tif (atomic_read(&p->user->processes) >=\n\t\t\tp->signal->rlim[RLIMIT_NPROC].rlim_cur) {\n\t\tif (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE) &&\n\t\t    p->user != current->nsproxy->user_ns->root_user)\n\t\t\tgoto bad_fork_free;\n\t}\n\n\tatomic_inc(&p->user->__count);\n\tatomic_inc(&p->user->processes);\n\tget_group_info(p->group_info);\n\n\t/*\n\t * If multiple threads are within copy_process(), then this check\n\t * triggers too late. This doesn't hurt, the check is only there\n\t * to stop root fork bombs.\n\t */\n\tif (nr_threads >= max_threads)\n\t\tgoto bad_fork_cleanup_count;\n\n\tif (!try_module_get(task_thread_info(p)->exec_domain->module))\n\t\tgoto bad_fork_cleanup_count;\n\n\tif (p->binfmt && !try_module_get(p->binfmt->module))\n\t\tgoto bad_fork_cleanup_put_domain;\n\n\tp->did_exec = 0;\n\tdelayacct_tsk_init(p);\t/* Must remain after dup_task_struct() */\n\tcopy_flags(clone_flags, p);\n\tINIT_LIST_HEAD(&p->children);\n\tINIT_LIST_HEAD(&p->sibling);\n#ifdef CONFIG_PREEMPT_RCU\n\tp->rcu_read_lock_nesting = 0;\n\tp->rcu_flipctr_idx = 0;\n#endif /* #ifdef CONFIG_PREEMPT_RCU */\n\tp->vfork_done = NULL;\n\tspin_lock_init(&p->alloc_lock);\n\n\tclear_tsk_thread_flag(p, TIF_SIGPENDING);\n\tinit_sigpending(&p->pending);\n\n\tp->utime = cputime_zero;\n\tp->stime = cputime_zero;\n\tp->gtime = cputime_zero;\n\tp->utimescaled = cputime_zero;\n\tp->stimescaled = cputime_zero;\n\tp->prev_utime = cputime_zero;\n\tp->prev_stime = cputime_zero;\n\n\tp->default_timer_slack_ns = current->timer_slack_ns;\n\n#ifdef CONFIG_DETECT_SOFTLOCKUP\n\tp->last_switch_count = 0;\n\tp->last_switch_timestamp = 0;\n#endif\n\n\ttask_io_accounting_init(&p->ioac);\n\tacct_clear_integrals(p);\n\n\tposix_cpu_timers_init(p);\n\n\tp->lock_depth = -1;\t\t/* -1 = no lock */\n\tdo_posix_clock_monotonic_gettime(&p->start_time);\n\tp->real_start_time = p->start_time;\n\tmonotonic_to_bootbased(&p->real_start_time);\n#ifdef CONFIG_SECURITY\n\tp->security = NULL;\n#endif\n\tp->cap_bset = current->cap_bset;\n\tp->io_context = NULL;\n\tp->audit_context = NULL;\n\tcgroup_fork(p);\n#ifdef CONFIG_NUMA\n\tp->mempolicy = mpol_dup(p->mempolicy);\n \tif (IS_ERR(p->mempolicy)) {\n \t\tretval = PTR_ERR(p->mempolicy);\n \t\tp->mempolicy = NULL;\n \t\tgoto bad_fork_cleanup_cgroup;\n \t}\n\tmpol_fix_fork_child_flag(p);\n#endif\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tp->irq_events = 0;\n#ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW\n\tp->hardirqs_enabled = 1;\n#else\n\tp->hardirqs_enabled = 0;\n#endif\n\tp->hardirq_enable_ip = 0;\n\tp->hardirq_enable_event = 0;\n\tp->hardirq_disable_ip = _THIS_IP_;\n\tp->hardirq_disable_event = 0;\n\tp->softirqs_enabled = 1;\n\tp->softirq_enable_ip = _THIS_IP_;\n\tp->softirq_enable_event = 0;\n\tp->softirq_disable_ip = 0;\n\tp->softirq_disable_event = 0;\n\tp->hardirq_context = 0;\n\tp->softirq_context = 0;\n#endif\n#ifdef CONFIG_LOCKDEP\n\tp->lockdep_depth = 0; /* no locks held yet */\n\tp->curr_chain_key = 0;\n\tp->lockdep_recursion = 0;\n#endif\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tp->blocked_on = NULL; /* not blocked yet */\n#endif\n\n\t/* Perform scheduler related setup. Assign this task to a CPU. */\n\tsched_fork(p, clone_flags);\n\n\tif ((retval = security_task_alloc(p)))\n\t\tgoto bad_fork_cleanup_policy;\n\tif ((retval = audit_alloc(p)))\n\t\tgoto bad_fork_cleanup_security;\n\t/* copy all the process information */\n\tif ((retval = copy_semundo(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_audit;\n\tif ((retval = copy_files(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_semundo;\n\tif ((retval = copy_fs(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_files;\n\tif ((retval = copy_sighand(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_fs;\n\tif ((retval = copy_signal(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_sighand;\n\tif ((retval = copy_mm(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_signal;\n\tif ((retval = copy_keys(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_mm;\n\tif ((retval = copy_namespaces(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_keys;\n\tif ((retval = copy_io(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_namespaces;\n\tretval = copy_thread(0, clone_flags, stack_start, stack_size, p, regs);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_io;\n\n\tif (pid != &init_struct_pid) {\n\t\tretval = -ENOMEM;\n\t\tpid = alloc_pid(task_active_pid_ns(p));\n\t\tif (!pid)\n\t\t\tgoto bad_fork_cleanup_io;\n\n\t\tif (clone_flags & CLONE_NEWPID) {\n\t\t\tretval = pid_ns_prepare_proc(task_active_pid_ns(p));\n\t\t\tif (retval < 0)\n\t\t\t\tgoto bad_fork_free_pid;\n\t\t}\n\t}\n\n\tp->pid = pid_nr(pid);\n\tp->tgid = p->pid;\n\tif (clone_flags & CLONE_THREAD)\n\t\tp->tgid = current->tgid;\n\n\tif (current->nsproxy != p->nsproxy) {\n\t\tretval = ns_cgroup_clone(p, pid);\n\t\tif (retval)\n\t\t\tgoto bad_fork_free_pid;\n\t}\n\n\tp->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? child_tidptr : NULL;\n\t/*\n\t * Clear TID on mm_release()?\n\t */\n\tp->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? child_tidptr: NULL;\n#ifdef CONFIG_FUTEX\n\tp->robust_list = NULL;\n#ifdef CONFIG_COMPAT\n\tp->compat_robust_list = NULL;\n#endif\n\tINIT_LIST_HEAD(&p->pi_state_list);\n\tp->pi_state_cache = NULL;\n#endif\n\t/*\n\t * sigaltstack should be cleared when sharing the same VM\n\t */\n\tif ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n\t\tp->sas_ss_sp = p->sas_ss_size = 0;\n\n\t/*\n\t * Syscall tracing should be turned off in the child regardless\n\t * of CLONE_PTRACE.\n\t */\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);\n#ifdef TIF_SYSCALL_EMU\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_EMU);\n#endif\n\tclear_all_latency_tracing(p);\n\n\t/* Our parent execution domain becomes current domain\n\t   These must match for thread signalling to apply */\n\tp->parent_exec_id = p->self_exec_id;\n\n\t/* ok, now we should be set up.. */\n\tp->exit_signal = (clone_flags & CLONE_THREAD) ? -1 : (clone_flags & CSIGNAL);\n\tp->pdeath_signal = 0;\n\tp->exit_state = 0;\n\n\t/*\n\t * Ok, make it visible to the rest of the system.\n\t * We dont wake it up yet.\n\t */\n\tp->group_leader = p;\n\tINIT_LIST_HEAD(&p->thread_group);\n\n\t/* Now that the task is set up, run cgroup callbacks if\n\t * necessary. We need to run them before the task is visible\n\t * on the tasklist. */\n\tcgroup_fork_callbacks(p);\n\tcgroup_callbacks_done = 1;\n\n\t/* Need tasklist lock for parent etc handling! */\n\twrite_lock_irq(&tasklist_lock);\n\n\t/*\n\t * The task hasn't been attached yet, so its cpus_allowed mask will\n\t * not be changed, nor will its assigned CPU.\n\t *\n\t * The cpus_allowed mask of the parent may have changed after it was\n\t * copied first time - so re-copy it here, then check the child's CPU\n\t * to ensure it is on a valid CPU (and if not, just force it back to\n\t * parent's CPU). This avoids alot of nasty races.\n\t */\n\tp->cpus_allowed = current->cpus_allowed;\n\tp->rt.nr_cpus_allowed = current->rt.nr_cpus_allowed;\n\tif (unlikely(!cpu_isset(task_cpu(p), p->cpus_allowed) ||\n\t\t\t!cpu_online(task_cpu(p))))\n\t\tset_task_cpu(p, smp_processor_id());\n\n\t/* CLONE_PARENT re-uses the old parent */\n\tif (clone_flags & (CLONE_PARENT|CLONE_THREAD))\n\t\tp->real_parent = current->real_parent;\n\telse\n\t\tp->real_parent = current;\n\n\tspin_lock(&current->sighand->siglock);\n\n\t/*\n\t * Process group and session signals need to be delivered to just the\n\t * parent before the fork or both the parent and the child after the\n\t * fork. Restart if a signal comes in before we add the new process to\n\t * it's process group.\n\t * A fatal signal pending means that current will exit, so the new\n\t * thread can't slip out of an OOM kill (or normal SIGKILL).\n \t */\n\trecalc_sigpending();\n\tif (signal_pending(current)) {\n\t\tspin_unlock(&current->sighand->siglock);\n\t\twrite_unlock_irq(&tasklist_lock);\n\t\tretval = -ERESTARTNOINTR;\n\t\tgoto bad_fork_free_pid;\n\t}\n\n\tif (clone_flags & CLONE_THREAD) {\n\t\tp->group_leader = current->group_leader;\n\t\tlist_add_tail_rcu(&p->thread_group, &p->group_leader->thread_group);\n\t}\n\n\tif (likely(p->pid)) {\n\t\tlist_add_tail(&p->sibling, &p->real_parent->children);\n\t\ttracehook_finish_clone(p, clone_flags, trace);\n\n\t\tif (thread_group_leader(p)) {\n\t\t\tif (clone_flags & CLONE_NEWPID)\n\t\t\t\tp->nsproxy->pid_ns->child_reaper = p;\n\n\t\t\tp->signal->leader_pid = pid;\n\t\t\ttty_kref_put(p->signal->tty);\n\t\t\tp->signal->tty = tty_kref_get(current->signal->tty);\n\t\t\tset_task_pgrp(p, task_pgrp_nr(current));\n\t\t\tset_task_session(p, task_session_nr(current));\n\t\t\tattach_pid(p, PIDTYPE_PGID, task_pgrp(current));\n\t\t\tattach_pid(p, PIDTYPE_SID, task_session(current));\n\t\t\tlist_add_tail_rcu(&p->tasks, &init_task.tasks);\n\t\t\t__get_cpu_var(process_counts)++;\n\t\t}\n\t\tattach_pid(p, PIDTYPE_PID, pid);\n\t\tnr_threads++;\n\t}\n\n\ttotal_forks++;\n\tspin_unlock(&current->sighand->siglock);\n\twrite_unlock_irq(&tasklist_lock);\n\tproc_fork_connector(p);\n\tcgroup_post_fork(p);\n\treturn p;\n\nbad_fork_free_pid:\n\tif (pid != &init_struct_pid)\n\t\tfree_pid(pid);\nbad_fork_cleanup_io:\n\tput_io_context(p->io_context);\nbad_fork_cleanup_namespaces:\n\texit_task_namespaces(p);\nbad_fork_cleanup_keys:\n\texit_keys(p);\nbad_fork_cleanup_mm:\n\tif (p->mm)\n\t\tmmput(p->mm);\nbad_fork_cleanup_signal:\n\tcleanup_signal(p);\nbad_fork_cleanup_sighand:\n\t__cleanup_sighand(p->sighand);\nbad_fork_cleanup_fs:\n\texit_fs(p); /* blocking */\nbad_fork_cleanup_files:\n\texit_files(p); /* blocking */\nbad_fork_cleanup_semundo:\n\texit_sem(p);\nbad_fork_cleanup_audit:\n\taudit_free(p);\nbad_fork_cleanup_security:\n\tsecurity_task_free(p);\nbad_fork_cleanup_policy:\n#ifdef CONFIG_NUMA\n\tmpol_put(p->mempolicy);\nbad_fork_cleanup_cgroup:\n#endif\n\tcgroup_exit(p, cgroup_callbacks_done);\n\tdelayacct_tsk_free(p);\n\tif (p->binfmt)\n\t\tmodule_put(p->binfmt->module);\nbad_fork_cleanup_put_domain:\n\tmodule_put(task_thread_info(p)->exec_domain->module);\nbad_fork_cleanup_count:\n\tput_group_info(p->group_info);\n\tatomic_dec(&p->user->processes);\n\tfree_uid(p->user);\nbad_fork_free:\n\tfree_task(p);\nfork_out:\n\treturn ERR_PTR(retval);\n}\n\nnoinline struct pt_regs * __cpuinit __attribute__((weak)) idle_regs(struct pt_regs *regs)\n{\n\tmemset(regs, 0, sizeof(struct pt_regs));\n\treturn regs;\n}\n\nstruct task_struct * __cpuinit fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct pt_regs regs;\n\n\ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n\t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task))\n\t\tinit_idle(task, cpu);\n\n\treturn task;\n}\n\n/*\n *  Ok, this is the main fork-routine.\n *\n * It copies the process, and if successful kick-starts\n * it and waits for it to finish using the VM if required.\n */\nlong do_fork(unsigned long clone_flags,\n\t      unsigned long stack_start,\n\t      struct pt_regs *regs,\n\t      unsigned long stack_size,\n\t      int __user *parent_tidptr,\n\t      int __user *child_tidptr)\n{\n\tstruct task_struct *p;\n\tint trace = 0;\n\tlong nr;\n\n\t/*\n\t * We hope to recycle these flags after 2.6.26\n\t */\n\tif (unlikely(clone_flags & CLONE_STOPPED)) {\n\t\tstatic int __read_mostly count = 100;\n\n\t\tif (count > 0 && printk_ratelimit()) {\n\t\t\tchar comm[TASK_COMM_LEN];\n\n\t\t\tcount--;\n\t\t\tprintk(KERN_INFO \"fork(): process `%s' used deprecated \"\n\t\t\t\t\t\"clone flags 0x%lx\\n\",\n\t\t\t\tget_task_comm(comm, current),\n\t\t\t\tclone_flags & CLONE_STOPPED);\n\t\t}\n\t}\n\n\t/*\n\t * When called from kernel_thread, don't do user tracing stuff.\n\t */\n\tif (likely(user_mode(regs)))\n\t\ttrace = tracehook_prepare_clone(clone_flags);\n\n\tp = copy_process(clone_flags, stack_start, regs, stack_size,\n\t\t\t child_tidptr, NULL, trace);\n\t/*\n\t * Do this prior waking up the new thread - the thread pointer\n\t * might get invalid after that point, if the thread exits quickly.\n\t */\n\tif (!IS_ERR(p)) {\n\t\tstruct completion vfork;\n\n\t\ttrace_sched_process_fork(current, p);\n\n\t\tnr = task_pid_vnr(p);\n\n\t\tif (clone_flags & CLONE_PARENT_SETTID)\n\t\t\tput_user(nr, parent_tidptr);\n\n\t\tif (clone_flags & CLONE_VFORK) {\n\t\t\tp->vfork_done = &vfork;\n\t\t\tinit_completion(&vfork);\n\t\t}\n\n\t\ttracehook_report_clone(trace, regs, clone_flags, nr, p);\n\n\t\t/*\n\t\t * We set PF_STARTING at creation in case tracing wants to\n\t\t * use this to distinguish a fully live task from one that\n\t\t * hasn't gotten to tracehook_report_clone() yet.  Now we\n\t\t * clear it and set the child going.\n\t\t */\n\t\tp->flags &= ~PF_STARTING;\n\n\t\tif (unlikely(clone_flags & CLONE_STOPPED)) {\n\t\t\t/*\n\t\t\t * We'll start up with an immediate SIGSTOP.\n\t\t\t */\n\t\t\tsigaddset(&p->pending.signal, SIGSTOP);\n\t\t\tset_tsk_thread_flag(p, TIF_SIGPENDING);\n\t\t\t__set_task_state(p, TASK_STOPPED);\n\t\t} else {\n\t\t\twake_up_new_task(p, clone_flags);\n\t\t}\n\n\t\ttracehook_report_clone_complete(trace, regs,\n\t\t\t\t\t\tclone_flags, nr, p);\n\n\t\tif (clone_flags & CLONE_VFORK) {\n\t\t\tfreezer_do_not_count();\n\t\t\twait_for_completion(&vfork);\n\t\t\tfreezer_count();\n\t\t\ttracehook_report_vfork_done(p, nr);\n\t\t}\n\t} else {\n\t\tnr = PTR_ERR(p);\n\t}\n\treturn nr;\n}\n\n#ifndef ARCH_MIN_MMSTRUCT_ALIGN\n#define ARCH_MIN_MMSTRUCT_ALIGN 0\n#endif\n\nstatic void sighand_ctor(void *data)\n{\n\tstruct sighand_struct *sighand = data;\n\n\tspin_lock_init(&sighand->siglock);\n\tinit_waitqueue_head(&sighand->signalfd_wqh);\n}\n\nvoid __init proc_caches_init(void)\n{\n\tsighand_cachep = kmem_cache_create(\"sighand_cache\",\n\t\t\tsizeof(struct sighand_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_DESTROY_BY_RCU,\n\t\t\tsighand_ctor);\n\tsignal_cachep = kmem_cache_create(\"signal_cache\",\n\t\t\tsizeof(struct signal_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\tfiles_cachep = kmem_cache_create(\"files_cache\",\n\t\t\tsizeof(struct files_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\tfs_cachep = kmem_cache_create(\"fs_cache\",\n\t\t\tsizeof(struct fs_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\tvm_area_cachep = kmem_cache_create(\"vm_area_struct\",\n\t\t\tsizeof(struct vm_area_struct), 0,\n\t\t\tSLAB_PANIC, NULL);\n\tmm_cachep = kmem_cache_create(\"mm_struct\",\n\t\t\tsizeof(struct mm_struct), ARCH_MIN_MMSTRUCT_ALIGN,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n}\n\n/*\n * Check constraints on flags passed to the unshare system call and\n * force unsharing of additional process context as appropriate.\n */\nstatic void check_unshare_flags(unsigned long *flags_ptr)\n{\n\t/*\n\t * If unsharing a thread from a thread group, must also\n\t * unshare vm.\n\t */\n\tif (*flags_ptr & CLONE_THREAD)\n\t\t*flags_ptr |= CLONE_VM;\n\n\t/*\n\t * If unsharing vm, must also unshare signal handlers.\n\t */\n\tif (*flags_ptr & CLONE_VM)\n\t\t*flags_ptr |= CLONE_SIGHAND;\n\n\t/*\n\t * If unsharing signal handlers and the task was created\n\t * using CLONE_THREAD, then must unshare the thread\n\t */\n\tif ((*flags_ptr & CLONE_SIGHAND) &&\n\t    (atomic_read(&current->signal->count) > 1))\n\t\t*flags_ptr |= CLONE_THREAD;\n\n\t/*\n\t * If unsharing namespace, must also unshare filesystem information.\n\t */\n\tif (*flags_ptr & CLONE_NEWNS)\n\t\t*flags_ptr |= CLONE_FS;\n}\n\n/*\n * Unsharing of tasks created with CLONE_THREAD is not supported yet\n */\nstatic int unshare_thread(unsigned long unshare_flags)\n{\n\tif (unshare_flags & CLONE_THREAD)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/*\n * Unshare the filesystem structure if it is being shared\n */\nstatic int unshare_fs(unsigned long unshare_flags, struct fs_struct **new_fsp)\n{\n\tstruct fs_struct *fs = current->fs;\n\n\tif ((unshare_flags & CLONE_FS) &&\n\t    (fs && atomic_read(&fs->count) > 1)) {\n\t\t*new_fsp = __copy_fs_struct(current->fs);\n\t\tif (!*new_fsp)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Unsharing of sighand is not supported yet\n */\nstatic int unshare_sighand(unsigned long unshare_flags, struct sighand_struct **new_sighp)\n{\n\tstruct sighand_struct *sigh = current->sighand;\n\n\tif ((unshare_flags & CLONE_SIGHAND) && atomic_read(&sigh->count) > 1)\n\t\treturn -EINVAL;\n\telse\n\t\treturn 0;\n}\n\n/*\n * Unshare vm if it is being shared\n */\nstatic int unshare_vm(unsigned long unshare_flags, struct mm_struct **new_mmp)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif ((unshare_flags & CLONE_VM) &&\n\t    (mm && atomic_read(&mm->mm_users) > 1)) {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Unshare file descriptor table if it is being shared\n */\nstatic int unshare_fd(unsigned long unshare_flags, struct files_struct **new_fdp)\n{\n\tstruct files_struct *fd = current->files;\n\tint error = 0;\n\n\tif ((unshare_flags & CLONE_FILES) &&\n\t    (fd && atomic_read(&fd->count) > 1)) {\n\t\t*new_fdp = dup_fd(fd, &error);\n\t\tif (!*new_fdp)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n/*\n * unshare allows a process to 'unshare' part of the process\n * context which was originally shared using clone.  copy_*\n * functions used by do_fork() cannot be used here directly\n * because they modify an inactive task_struct that is being\n * constructed. Here we are modifying the current, active,\n * task_struct.\n */\nasmlinkage long sys_unshare(unsigned long unshare_flags)\n{\n\tint err = 0;\n\tstruct fs_struct *fs, *new_fs = NULL;\n\tstruct sighand_struct *new_sigh = NULL;\n\tstruct mm_struct *mm, *new_mm = NULL, *active_mm = NULL;\n\tstruct files_struct *fd, *new_fd = NULL;\n\tstruct nsproxy *new_nsproxy = NULL;\n\tint do_sysvsem = 0;\n\n\tcheck_unshare_flags(&unshare_flags);\n\n\t/* Return -EINVAL for all unsupported flags */\n\terr = -EINVAL;\n\tif (unshare_flags & ~(CLONE_THREAD|CLONE_FS|CLONE_NEWNS|CLONE_SIGHAND|\n\t\t\t\tCLONE_VM|CLONE_FILES|CLONE_SYSVSEM|\n\t\t\t\tCLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWUSER|\n\t\t\t\tCLONE_NEWNET))\n\t\tgoto bad_unshare_out;\n\n\t/*\n\t * CLONE_NEWIPC must also detach from the undolist: after switching\n\t * to a new ipc namespace, the semaphore arrays from the old\n\t * namespace are unreachable.\n\t */\n\tif (unshare_flags & (CLONE_NEWIPC|CLONE_SYSVSEM))\n\t\tdo_sysvsem = 1;\n\tif ((err = unshare_thread(unshare_flags)))\n\t\tgoto bad_unshare_out;\n\tif ((err = unshare_fs(unshare_flags, &new_fs)))\n\t\tgoto bad_unshare_cleanup_thread;\n\tif ((err = unshare_sighand(unshare_flags, &new_sigh)))\n\t\tgoto bad_unshare_cleanup_fs;\n\tif ((err = unshare_vm(unshare_flags, &new_mm)))\n\t\tgoto bad_unshare_cleanup_sigh;\n\tif ((err = unshare_fd(unshare_flags, &new_fd)))\n\t\tgoto bad_unshare_cleanup_vm;\n\tif ((err = unshare_nsproxy_namespaces(unshare_flags, &new_nsproxy,\n\t\t\tnew_fs)))\n\t\tgoto bad_unshare_cleanup_fd;\n\n\tif (new_fs ||  new_mm || new_fd || do_sysvsem || new_nsproxy) {\n\t\tif (do_sysvsem) {\n\t\t\t/*\n\t\t\t * CLONE_SYSVSEM is equivalent to sys_exit().\n\t\t\t */\n\t\t\texit_sem(current);\n\t\t}\n\n\t\tif (new_nsproxy) {\n\t\t\tswitch_task_namespaces(current, new_nsproxy);\n\t\t\tnew_nsproxy = NULL;\n\t\t}\n\n\t\ttask_lock(current);\n\n\t\tif (new_fs) {\n\t\t\tfs = current->fs;\n\t\t\tcurrent->fs = new_fs;\n\t\t\tnew_fs = fs;\n\t\t}\n\n\t\tif (new_mm) {\n\t\t\tmm = current->mm;\n\t\t\tactive_mm = current->active_mm;\n\t\t\tcurrent->mm = new_mm;\n\t\t\tcurrent->active_mm = new_mm;\n\t\t\tactivate_mm(active_mm, new_mm);\n\t\t\tnew_mm = mm;\n\t\t}\n\n\t\tif (new_fd) {\n\t\t\tfd = current->files;\n\t\t\tcurrent->files = new_fd;\n\t\t\tnew_fd = fd;\n\t\t}\n\n\t\ttask_unlock(current);\n\t}\n\n\tif (new_nsproxy)\n\t\tput_nsproxy(new_nsproxy);\n\nbad_unshare_cleanup_fd:\n\tif (new_fd)\n\t\tput_files_struct(new_fd);\n\nbad_unshare_cleanup_vm:\n\tif (new_mm)\n\t\tmmput(new_mm);\n\nbad_unshare_cleanup_sigh:\n\tif (new_sigh)\n\t\tif (atomic_dec_and_test(&new_sigh->count))\n\t\t\tkmem_cache_free(sighand_cachep, new_sigh);\n\nbad_unshare_cleanup_fs:\n\tif (new_fs)\n\t\tput_fs_struct(new_fs);\n\nbad_unshare_cleanup_thread:\nbad_unshare_out:\n\treturn err;\n}\n\n/*\n *\tHelper to unshare the files of the current task.\n *\tWe don't want to expose copy_files internals to\n *\tthe exec layer of the kernel.\n */\n\nint unshare_files(struct files_struct **displaced)\n{\n\tstruct task_struct *task = current;\n\tstruct files_struct *copy = NULL;\n\tint error;\n\n\terror = unshare_fd(CLONE_FILES, &copy);\n\tif (error || !copy) {\n\t\t*displaced = NULL;\n\t\treturn error;\n\t}\n\t*displaced = task->files;\n\ttask_lock(task);\n\ttask->files = copy;\n\ttask_unlock(task);\n\treturn 0;\n}\n"], "filenames": ["kernel/exit.c", "kernel/fork.c"], "buggy_code_start_loc": [43, 42], "buggy_code_end_loc": [1070, 521], "fixing_code_start_loc": [42, 43], "fixing_code_end_loc": [1060, 533], "type": "CWE-264", "message": "The robust futex implementation in the Linux kernel before 2.6.28 does not properly handle processes that make exec system calls, which allows local users to cause a denial of service or possibly gain privileges by writing to a memory location in a child process.", "other": {"cve": {"id": "CVE-2012-0028", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-21T23:55:02.520", "lastModified": "2023-02-13T03:24:05.763", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The robust futex implementation in the Linux kernel before 2.6.28 does not properly handle processes that make exec system calls, which allows local users to cause a denial of service or possibly gain privileges by writing to a memory location in a child process."}, {"lang": "es", "value": "La implementaci\u00f3n de robust futex en el kernel de Linux antes de v2.6.28 no maneja adecuadamente los procesos que realizan llamadas Exec System Recovery, lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio o posiblemente obtener privilegios escribiendo en una ubicaci\u00f3n de memoria en un proceso hijo."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.27.62", "matchCriteriaId": "B80BC5D0-5596-44BA-90F2-261360893E55"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27:*:*:*:*:*:*:*", "matchCriteriaId": "856FE78A-29B5-4411-98A0-4B0281C17EB9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.1:*:*:*:*:*:*:*", "matchCriteriaId": "324B5A3E-FA65-4F02-9B8F-872F38CD1808"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.2:*:*:*:*:*:*:*", "matchCriteriaId": "C75A8FC4-58D2-4B6A-9D8E-FF12DF52E249"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.3:*:*:*:*:*:*:*", "matchCriteriaId": "DE21E2AE-9E01-471C-A419-6AB40A49C2F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.4:*:*:*:*:*:*:*", "matchCriteriaId": "ADFC2D46-65D0-426F-9AF8-8C910AE91D49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.5:*:*:*:*:*:*:*", "matchCriteriaId": "11795F8E-7ACD-4597-9194-FC7241DCE057"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.6:*:*:*:*:*:*:*", "matchCriteriaId": "60F381E1-F3C5-49BE-B094-4D90E7B108F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.7:*:*:*:*:*:*:*", "matchCriteriaId": "D82A6217-CFA6-4E72-8BED-0297E13EABF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.8:*:*:*:*:*:*:*", "matchCriteriaId": "7CEA1AF2-2DE7-4B38-987D-15FFA70F06B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.9:*:*:*:*:*:*:*", "matchCriteriaId": "7954A701-1671-4080-B1E6-47E0208FD28C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.10:*:*:*:*:*:*:*", "matchCriteriaId": "63D06512-EAF0-48C6-98F0-066E63FF07EC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.11:*:*:*:*:*:*:*", "matchCriteriaId": "7F35DA6B-C6D4-47CC-97E7-9659DCFDD162"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.12:*:*:*:*:*:*:*", "matchCriteriaId": "D75B48F1-623A-4B96-9E08-4AA2DE748490"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.13:*:*:*:*:*:*:*", "matchCriteriaId": "9E6EB7C3-D9AB-43E7-8B78-2C36AE920935"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.14:*:*:*:*:*:*:*", "matchCriteriaId": "7FC87A28-C6A1-4E90-BD9F-A5BE1985DB50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.15:*:*:*:*:*:*:*", "matchCriteriaId": "0383E2A5-60EE-47F3-9DA8-BF75028D511F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.16:*:*:*:*:*:*:*", "matchCriteriaId": "E8B0C229-2A79-47E0-856A-2AE0FF97B967"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.17:*:*:*:*:*:*:*", "matchCriteriaId": "FB27B247-D6BF-49C4-B113-76C9A47B7DCD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.18:*:*:*:*:*:*:*", "matchCriteriaId": "F94BA1B0-52B9-4303-9C41-3ACC3AC1945E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.19:*:*:*:*:*:*:*", "matchCriteriaId": "1ACBB194-1D24-464A-B79C-44B8127EAD52"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.20:*:*:*:*:*:*:*", "matchCriteriaId": "83E5F269-7711-447D-B798-0F5478E36299"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.21:*:*:*:*:*:*:*", "matchCriteriaId": "A0138807-6313-4A3F-AB5A-4B7D4A9BE287"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.22:*:*:*:*:*:*:*", "matchCriteriaId": "D4BA2227-F259-499D-BF50-5074B1E7DD3E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.23:*:*:*:*:*:*:*", "matchCriteriaId": "78A896D0-032C-4467-9D57-E47E8C612704"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.24:*:*:*:*:*:*:*", "matchCriteriaId": "3D1D4C8F-8C09-4A49-AFFD-33093AE7A437"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.25:*:*:*:*:*:*:*", "matchCriteriaId": "A415FECF-89CC-4D71-B1BF-6A678D32599D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.26:*:*:*:*:*:*:*", "matchCriteriaId": "98F77E54-5F4A-4D47-8DE8-097B4BBC7944"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.27:*:*:*:*:*:*:*", "matchCriteriaId": "752148FC-1594-4108-AE0F-C5145B978454"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.28:*:*:*:*:*:*:*", "matchCriteriaId": "09546671-E75D-4F50-9D86-DFDDAC9DC5DE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.29:*:*:*:*:*:*:*", "matchCriteriaId": "EDC7A2D7-ACB4-4871-B7C0-02711A53DF1C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.30:*:*:*:*:*:*:*", "matchCriteriaId": "6964925C-4394-4E82-976B-770A99E74F1D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.31:*:*:*:*:*:*:*", "matchCriteriaId": "2E8C909E-02D7-4B29-AA68-897BD0200B7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.32:*:*:*:*:*:*:*", "matchCriteriaId": "AA036609-ADD3-4903-AB9D-E8BF81CFC776"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.33:*:*:*:*:*:*:*", "matchCriteriaId": "38F9E122-994B-4276-9FCF-A8E4D2D06D4E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.34:*:*:*:*:*:*:*", "matchCriteriaId": "7A15720C-3BDF-4343-B270-2575978293EE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.35:*:*:*:*:*:*:*", "matchCriteriaId": "FB5ADCFA-2CD8-4A00-AFEC-B84F7E0015A6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.36:*:*:*:*:*:*:*", "matchCriteriaId": "6EA2EE9B-27FD-49FE-8665-159DABA0E3C6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.37:*:*:*:*:*:*:*", "matchCriteriaId": "4C81C5F8-2224-4D84-B7C0-E18421276AFF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.38:*:*:*:*:*:*:*", "matchCriteriaId": "B44A2C76-174E-40A5-9603-3B84D0D35557"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.39:*:*:*:*:*:*:*", "matchCriteriaId": "42ACE154-0709-4AA1-82E3-1B7F34E63187"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.40:*:*:*:*:*:*:*", "matchCriteriaId": "3022E902-9F0D-49FF-9279-71E0E1E8A873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.41:*:*:*:*:*:*:*", "matchCriteriaId": "DDF77B26-91FA-4245-BFEC-43FD021A28E7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.42:*:*:*:*:*:*:*", "matchCriteriaId": "601B4C93-9A9C-40E8-A9D0-DA9D71C745EA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.43:*:*:*:*:*:*:*", "matchCriteriaId": "FF7CE35A-87A4-4D95-86F9-211D50E30482"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.44:*:*:*:*:*:*:*", "matchCriteriaId": "CEA8675A-A37C-4658-9D26-3359EBA277B1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.45:*:*:*:*:*:*:*", "matchCriteriaId": "00E8CB86-ECEE-4435-BEFC-B8D209B2C5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.46:*:*:*:*:*:*:*", "matchCriteriaId": "B373DEAE-8F8B-44AA-BAE5-3A0120A541F9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.47:*:*:*:*:*:*:*", "matchCriteriaId": "7D40063F-13D0-4897-AE71-1C7B617C8855"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.48:*:*:*:*:*:*:*", "matchCriteriaId": "AC7E89C8-CF89-4FA8-A9F1-F0B415E5FE10"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.49:*:*:*:*:*:*:*", "matchCriteriaId": "4034EFE6-449D-4749-9265-B47D44AA4EC6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.50:*:*:*:*:*:*:*", "matchCriteriaId": "1F835D17-ACF9-4AE6-8C38-B74BE448B8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.51:*:*:*:*:*:*:*", "matchCriteriaId": "21A12676-7EBE-4D83-83BD-D46CC7A1773A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.52:*:*:*:*:*:*:*", "matchCriteriaId": "2FB112DB-891D-4FDB-8772-2E233A39A7BA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.53:*:*:*:*:*:*:*", "matchCriteriaId": "4B3A0794-B10C-4DFD-9CAD-202CA1DC9250"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.54:*:*:*:*:*:*:*", "matchCriteriaId": "76E86CE6-CD1C-4412-939F-B45867068D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.55:*:*:*:*:*:*:*", "matchCriteriaId": "1F6896A4-16E0-46B6-B90C-5C002C526478"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.56:*:*:*:*:*:*:*", "matchCriteriaId": "469534AB-2D0F-4B31-8121-05A792FA9332"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.57:*:*:*:*:*:*:*", "matchCriteriaId": "C2820354-F25B-485D-9FA7-E32B38DDBB1D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.58:*:*:*:*:*:*:*", "matchCriteriaId": "EF88BEB3-9EA4-47AA-B24E-DE9AD879382A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.59:*:*:*:*:*:*:*", "matchCriteriaId": "C4209B4C-4901-4235-B35E-B0085AF1952F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.60:*:*:*:*:*:*:*", "matchCriteriaId": "5D748A69-4A93-421E-AD83-2B63B2460A2D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.27.61:*:*:*:*:*:*:*", "matchCriteriaId": "2727A6AE-A1B6-4158-BB73-49D7C86104F4"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.28", "source": "secalert@redhat.com"}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=8141c7f3e7aee618312fa1c15109e1219de784a7", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/05/08/1", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=771764", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/8141c7f3e7aee618312fa1c15109e1219de784a7", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/8141c7f3e7aee618312fa1c15109e1219de784a7"}}