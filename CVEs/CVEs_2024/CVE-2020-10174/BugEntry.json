{"buggy_code": ["/*\n * Main.vala\n *\n * Copyright 2012-2018 Tony George <teejeetech@gmail.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n * MA 02110-1301, USA.\n *\n *\n */\n\nusing GLib;\nusing Gtk;\nusing Gee;\nusing Json;\n\nusing TeeJee.Logging;\nusing TeeJee.FileSystem;\nusing TeeJee.JsonHelper;\nusing TeeJee.ProcessHelper;\nusing TeeJee.GtkHelper;\nusing TeeJee.System;\nusing TeeJee.Misc;\n\npublic bool GTK_INITIALIZED = false;\n\npublic class Main : GLib.Object{\n\t\n\tpublic string app_path = \"\";\n\tpublic string share_folder = \"\";\n\tpublic string rsnapshot_conf_path = \"\";\n\tpublic string app_conf_path = \"\";\n\tpublic string app_conf_path_default = \"\";\n\tpublic bool first_run = false;\n\t\n\tpublic string backup_uuid = \"\";\n\tpublic string backup_parent_uuid = \"\";\n\n\tpublic bool btrfs_mode = true;\n\tpublic bool include_btrfs_home_for_backup = false;\n\tpublic bool include_btrfs_home_for_restore = false;\n\t\n\tpublic bool stop_cron_emails = true;\n\t\n\tpublic Gee.ArrayList<Device> partitions;\n\n\tpublic Gee.ArrayList<string> exclude_list_user;\n\tpublic Gee.ArrayList<string> exclude_list_default;\n\tpublic Gee.ArrayList<string> exclude_list_default_extra;\n\tpublic Gee.ArrayList<string> exclude_list_home;\n\tpublic Gee.ArrayList<string> exclude_list_restore;\n\tpublic Gee.ArrayList<AppExcludeEntry> exclude_list_apps;\n\tpublic Gee.ArrayList<MountEntry> mount_list;\n\tpublic Gee.ArrayList<string> exclude_app_names;\n\t\n\tpublic SnapshotRepo repo; \n\n\t//temp\n\t//private Gee.ArrayList<Device> grub_device_list;\n\n\tpublic Device sys_root;\n\tpublic Device sys_boot;\n\tpublic Device sys_efi;\n\tpublic Device sys_home;\n\tpublic Gee.HashMap<string, Subvolume> sys_subvolumes;\n\n\tpublic string mount_point_restore = \"\";\n\tpublic string mount_point_app = \"/run/timeshift\";\n\n\tpublic LinuxDistro current_distro;\n\tpublic bool mirror_system = false;\n\n\tpublic bool schedule_monthly = false;\n\tpublic bool schedule_weekly = false;\n\tpublic bool schedule_daily = false;\n\tpublic bool schedule_hourly = false;\n\tpublic bool schedule_boot = false;\n\tpublic int count_monthly = 2;\n\tpublic int count_weekly = 3;\n\tpublic int count_daily = 5;\n\tpublic int count_hourly = 6;\n\tpublic int count_boot = 5;\n\n\tpublic bool btrfs_use_qgroup = true;\n\n\tpublic string app_mode = \"\";\n\n\tpublic bool dry_run = false;\n\n\t//global vars for controlling threads\n\tpublic bool thr_success = false;\n\t\n\tpublic bool thread_estimate_running = false;\n\tpublic bool thread_estimate_success = false;\n\t\n\tpublic bool thread_restore_running = false;\n\tpublic bool thread_restore_success = false;\n\n\tpublic bool thread_delete_running = false;\n\tpublic bool thread_delete_success = false;\n\n\tpublic bool thread_subvol_info_running = false;\n\tpublic bool thread_subvol_info_success = false;\n\t\t\n\tpublic int thr_retval = -1;\n\tpublic string thr_arg1 = \"\";\n\tpublic bool thr_timeout_active = false;\n\tpublic string thr_timeout_cmd = \"\";\n\n\tpublic int startup_delay_interval_mins = 10;\n\tpublic int retain_snapshots_max_days = 200;\n\t\n\tpublic int64 snapshot_location_free_space = 0;\n\n\tpublic const uint64 MIN_FREE_SPACE = 1 * GB;\n\tpublic static uint64 first_snapshot_size = 0;\n\tpublic static int64 first_snapshot_count = 0;\n\t\n\tpublic string log_dir = \"\";\n\tpublic string log_file = \"\";\n\tpublic AppLock app_lock;\n\n\tpublic string date_format = \"%Y-%m-%d %H:%M:%S\";\n\tpublic const string date_format_default = \"%Y-%m-%d %H:%M:%S\";\n\n\tpublic Gee.ArrayList<Snapshot> delete_list;\n\t\n\tpublic Snapshot snapshot_to_delete;\n\tpublic Snapshot snapshot_to_restore;\n\t//public Device restore_target;\n\tpublic bool reinstall_grub2 = true;\n\tpublic bool update_initramfs = false;\n\tpublic bool update_grub = true;\n\tpublic string grub_device = \"\";\n\tpublic bool use_option_raw = true;\n\n\tpublic bool cmd_skip_grub = false;\n\tpublic string cmd_grub_device = \"\";\n\tpublic string cmd_target_device = \"\";\n\tpublic string cmd_backup_device = \"\";\n\tpublic string cmd_snapshot = \"\";\n\tpublic bool cmd_confirm = false;\n\tpublic bool cmd_verbose = true;\n\tpublic bool cmd_scripted = false;\n\tpublic string cmd_comments = \"\";\n\tpublic string cmd_tags = \"\";\n\tpublic bool? cmd_btrfs_mode = null;\n\t\n\tpublic string progress_text = \"\";\n\n\tpublic Gtk.Window? parent_window = null;\n\t\n\tpublic RsyncTask task;\n\tpublic DeleteFileTask delete_file_task;\n\n\tpublic Gee.HashMap<string, SystemUser> current_system_users;\n\tpublic string users_with_encrypted_home = \"\";\n\tpublic string encrypted_home_dirs = \"\";\n\tpublic bool encrypted_home_warning_shown = false;\n\n\tpublic string encrypted_private_dirs = \"\";\n\tpublic bool encrypted_private_warning_shown = false;\n\n\tpublic Main(string[] args, bool gui_mode){\n\n\t\tparse_some_arguments(args);\n\t\n\t\tif (gui_mode){\n\t\t\tapp_mode = \"\";\n\t\t\tparent_window = new Gtk.Window(); // dummy\n\t\t}\n\n\t\tlog_debug(\"Main()\");\n\n\t\tif (LOG_DEBUG || gui_mode){\n\t\t\tlog_debug(\"\");\n\t\t\tlog_debug(_(\"Running\") + \" %s v%s\".printf(AppName, AppVersion));\n\t\t\tlog_debug(\"\");\n\t\t}\n\n\t\tcheck_and_remove_timeshift_btrfs();\n\t\t\n\t\t// init log ------------------\n\n\t\ttry {\n\t\t\tstring suffix = gui_mode ? \"gui\" : app_mode;\n\t\t\t\n\t\t\tDateTime now = new DateTime.now_local();\n\t\t\tlog_dir = \"/var/log/timeshift\";\n\t\t\tlog_file = path_combine(log_dir,\n\t\t\t\t\"%s_%s.log\".printf(now.format(\"%Y-%m-%d_%H-%M-%S\"), suffix));\n\n\t\t\tvar file = File.new_for_path (log_dir);\n\t\t\tif (!file.query_exists ()) {\n\t\t\t\tfile.make_directory_with_parents();\n\t\t\t}\n\n\t\t\tfile = File.new_for_path (log_file);\n\t\t\tif (file.query_exists ()) {\n\t\t\t\tfile.delete ();\n\t\t\t}\n\n\t\t\tdos_log = new DataOutputStream (file.create(FileCreateFlags.REPLACE_DESTINATION));\n\t\t\tif (LOG_DEBUG || gui_mode){\n\t\t\t\tlog_debug(_(\"Session log file\") + \": %s\".printf(log_file));\n\t\t\t}\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tlog_error (e.message);\n\t\t}\n\t\t\n\t\t// get Linux distribution info -----------------------\n\t\t\n\t\tthis.current_distro = LinuxDistro.get_dist_info(\"/\");\n\n\t\tif (LOG_DEBUG || gui_mode){\n\t\t\tlog_debug(_(\"Distribution\") + \": \" + current_distro.full_name());\n\t\t\tlog_debug(\"DIST_ID\" + \": \" + current_distro.dist_id);\n\t\t}\n\n\t\t// check dependencies ---------------------\n\n\t\tstring message;\n\t\tif (!check_dependencies(out message)){\n\t\t\tif (gui_mode){\n\t\t\t\tstring title = _(\"Missing Dependencies\");\n\t\t\t\tgtk_messagebox(title, message, null, true);\n\t\t\t}\n\t\t\texit_app(1);\n\t\t}\n\n\t\t// check and create lock ----------------------------\n\n\t\tapp_lock = new AppLock();\n\t\t\n\t\tif (!app_lock.create(\"timeshift\", app_mode)){\n\t\t\tif (gui_mode){\n\t\t\t\tstring msg = \"\";\n\t\t\t\tif (app_lock.lock_message == \"backup\"){\n\t\t\t\t\tmsg = _(\"Another instance of Timeshift is creating a snapshot.\") + \"\\n\";\n\t\t\t\t\tmsg += _(\"Please wait a few minutes and try again.\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmsg = _(\"Another instance of timeshift is currently running!\") + \"\\n\";\n\t\t\t\t\tmsg += _(\"Please check if you have multiple windows open.\") + \"\\n\";\n\t\t\t\t}\n\n\t\t\t\tstring title = _(\"Scheduled snapshot in progress...\");\n\t\t\t\tgtk_messagebox(title, msg, null, true);\n\t\t\t}\n\t\t\telse{\n\t\t\t\t//already logged - do nothing\n\t\t\t}\n\t\t\texit(1);\n\t\t}\n\n\t\t// initialize variables -------------------------------\n\n\t\tthis.app_path = (File.new_for_path (args[0])).get_parent().get_path ();\n\t\tthis.share_folder = \"/usr/share\";\n\t\tthis.app_conf_path = \"/etc/timeshift.json\";\n\t\tthis.app_conf_path_default = \"/etc/default/timeshift.json\";\n\t\t//sys_root and sys_home will be initalized by update_partition_list()\n\n\t\t// check if running locally ------------------------\n\n\t\tstring local_exec = args[0];\n\t\tstring local_conf = app_path + \"/timeshift.json\";\n\t\tstring local_share = app_path + \"/share\";\n\n\t\tvar f_local_exec = File.new_for_path(local_exec);\n\t\tif (f_local_exec.query_exists()){\n\n\t\t\tvar f_local_conf = File.new_for_path(local_conf);\n\t\t\tif (f_local_conf.query_exists()){\n\t\t\t\tthis.app_conf_path = local_conf;\n\t\t\t}\n\n\t\t\tvar f_local_share = File.new_for_path(local_share);\n\t\t\tif (f_local_share.query_exists()){\n\t\t\t\tthis.share_folder = local_share;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\t//timeshift is running from system directory - update app_path\n\t\t\tthis.app_path = get_cmd_path(\"timeshift\");\n\t\t}\n\n\t\t// initialize lists -----------------\n\n\t\trepo = new SnapshotRepo();\n\t\tmount_list = new Gee.ArrayList<MountEntry>();\n\t\tdelete_list = new Gee.ArrayList<Snapshot>();\n\t\tsys_subvolumes = new Gee.HashMap<string, Subvolume>();\n\t\texclude_app_names = new Gee.ArrayList<string>();\n\t\tadd_default_exclude_entries();\n\t\t//add_app_exclude_entries();\n\t\ttask = new RsyncTask();\n\t\tdelete_file_task = new DeleteFileTask();\n\n\t\tupdate_partitions();\n\t\t\n\t\tdetect_system_devices();\n\n\t\tdetect_encrypted_dirs();\n\n\t\t// set settings from config file ---------------------\n\n\t\tload_app_config();\n\n\t\tIconManager.init(args, AppShortName);\n\t\t\n\t\tlog_debug(\"Main(): ok\");\n\t}\n\n\tpublic void initialize(){\n\t\t\n\t\tinitialize_repo();\n\t}\n\n\tpublic bool check_dependencies(out string msg){\n\t\t\n\t\tmsg = \"\";\n\n\t\tlog_debug(\"Main: check_dependencies()\");\n\t\t\n\t\tstring[] dependencies = { \"rsync\",\"/sbin/blkid\",\"df\",\"mount\",\"umount\",\"fuser\",\"crontab\",\"cp\",\"rm\",\"touch\",\"ln\",\"sync\"}; //\"shutdown\",\"chroot\",\n\n\t\tstring path;\n\t\tforeach(string cmd_tool in dependencies){\n\t\t\tpath = get_cmd_path (cmd_tool);\n\t\t\tif ((path == null) || (path.length == 0)){\n\t\t\t\tmsg += \" * \" + cmd_tool + \"\\n\";\n\t\t\t}\n\t\t}\n\n\t\tif (msg.length > 0){\n\t\t\tmsg = _(\"Commands listed below are not available on this system\") + \":\\n\\n\" + msg + \"\\n\";\n\t\t\tmsg += _(\"Please install required packages and try running TimeShift again\");\n\t\t\tlog_error(msg);\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tpublic void check_and_remove_timeshift_btrfs(){\n\t\t\n\t\tif (cmd_exists(\"timeshift-btrfs\")){\n\t\t\tstring std_out, std_err;\n\t\t\texec_sync(\"timeshift-btrfs-uninstall\", out std_out, out std_err);\n\t\t\tlog_msg(_(\"** Uninstalled Timeshift BTRFS **\"));\n\t\t}\n\t}\n\t\n\tpublic bool check_btrfs_layout_system(Gtk.Window? win = null){\n\n\t\tlog_debug(\"check_btrfs_layout_system()\");\n\n\t\tbool supported = sys_subvolumes.has_key(\"@\");\n\t\tif (include_btrfs_home_for_backup){\n\t\t\tsupported =  supported && sys_subvolumes.has_key(\"@home\");\n\t\t}\n\n\t\tif (!supported){\n\t\t\tstring msg = _(\"The system partition has an unsupported subvolume layout.\") + \" \";\n\t\t\tmsg += _(\"Only ubuntu-type layouts with @ and @home subvolumes are currently supported.\") + \"\\n\\n\";\n\t\t\tmsg += _(\"Application will exit.\") + \"\\n\\n\";\n\t\t\tstring title = _(\"Not Supported\");\n\t\t\t\n\t\t\tif (app_mode == \"\"){\n\t\t\t\tgtk_set_busy(false, win);\n\t\t\t\tgtk_messagebox(title, msg, win, true);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_error(msg);\n\t\t\t}\n\t\t}\n\n\t\treturn supported;\n\t}\n\n\tpublic bool check_btrfs_layout(Device? dev_root, Device? dev_home, bool unlock){\n\t\t\n\t\tbool supported = true; // keep true for non-btrfs systems\n\n\t\tif ((dev_root != null) && (dev_root.fstype == \"btrfs\")){\n\t\t\t\n\t\t\tif ((dev_home != null) && (dev_home.fstype == \"btrfs\")){\n\n\t\t\t\tif (dev_home != dev_root){\n\t\t\t\t\t\n\t\t\t\t\tsupported = supported && check_btrfs_volume(dev_root, \"@\", unlock);\n\n\t\t\t\t\tif (include_btrfs_home_for_backup){\n\t\t\t\t\t\tsupported = supported && check_btrfs_volume(dev_home, \"@home\", unlock);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (include_btrfs_home_for_backup){\n\t\t\t\t\t\tsupported = supported && check_btrfs_volume(dev_root, \"@,@home\", unlock);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tsupported = supported && check_btrfs_volume(dev_root, \"@\", unlock);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn supported;\n\t}\n\n\tprivate void parse_some_arguments(string[] args){\n\t\t\n\t\tfor (int k = 1; k < args.length; k++) // Oth arg is app path\n\t\t{\n\t\t\tswitch (args[k].down()){\n\t\t\t\tcase \"--debug\":\n\t\t\t\t\tLOG_COMMANDS = true;\n\t\t\t\t\tLOG_DEBUG = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"--btrfs\":\n\t\t\t\t\tbtrfs_mode = true;\n\t\t\t\t\tcmd_btrfs_mode = btrfs_mode;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"--rsync\":\n\t\t\t\t\tbtrfs_mode = false;\n\t\t\t\t\tcmd_btrfs_mode = btrfs_mode;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase \"--check\":\n\t\t\t\t\tapp_mode = \"backup\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"--delete\":\n\t\t\t\t\tapp_mode = \"delete\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"--delete-all\":\n\t\t\t\t\tapp_mode = \"delete-all\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"--restore\":\n\t\t\t\t\tapp_mode = \"restore\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"--clone\":\n\t\t\t\t\tapp_mode = \"restore\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"--create\":\n\t\t\t\t\tapp_mode = \"ondemand\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"--list\":\n\t\t\t\tcase \"--list-snapshots\":\n\t\t\t\t\tapp_mode = \"list-snapshots\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"--list-devices\":\n\t\t\t\t\tapp_mode = \"list-devices\";\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void detect_encrypted_dirs(){\n\t\t\n\t\tcurrent_system_users = SystemUser.read_users_from_file(\"/etc/passwd\",\"\",\"\");\n\n\t\tstring txt = \"\";\n\t\tusers_with_encrypted_home = \"\";\n\t\tencrypted_home_dirs = \"\";\n\t\tencrypted_private_dirs = \"\";\n\t\t\n\t\tforeach(var user in current_system_users.values){\n\t\t\t\n\t\t\tif (user.is_system) { continue; }\n\t\t\t\n\t\t\tif (txt.length > 0) { txt += \" \"; }\n\t\t\ttxt += \"%s\".printf(user.name);\n\n\t\t\tif (user.has_encrypted_home){\n\t\t\t\t\n\t\t\t\tusers_with_encrypted_home += \" %s\".printf(user.name);\n\n\t\t\t\tencrypted_home_dirs += \"%s\\n\".printf(user.home_path);\n\t\t\t}\n\n\t\t\tif (user.has_encrypted_private_dirs){\n\n\t\t\t\tforeach(string enc_path in user.encrypted_private_dirs){\n\t\t\t\t\tencrypted_private_dirs += \"%s\\n\".printf(enc_path);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusers_with_encrypted_home = users_with_encrypted_home.strip();\n\t\t\n\t\tlog_debug(\"Users: %s\".printf(txt));\n\t\tlog_debug(\"Encrypted home users: %s\".printf(users_with_encrypted_home));\n\t\tlog_debug(\"Encrypted home dirs:\\n%s\".printf(encrypted_home_dirs));\n\t\tlog_debug(\"Encrypted private dirs:\\n%s\".printf(encrypted_private_dirs));\n\t}\n\t\n\t// exclude lists\n\t\n\tpublic void add_default_exclude_entries(){\n\n\t\tlog_debug(\"Main: add_default_exclude_entries()\");\n\t\t\n\t\texclude_list_user = new Gee.ArrayList<string>();\n\t\texclude_list_default = new Gee.ArrayList<string>();\n\t\texclude_list_default_extra = new Gee.ArrayList<string>();\n\t\texclude_list_home = new Gee.ArrayList<string>();\n\t\texclude_list_restore = new Gee.ArrayList<string>();\n\t\texclude_list_apps = new Gee.ArrayList<AppExcludeEntry>();\n\t\t\n\t\tpartitions = new Gee.ArrayList<Device>();\n\n\t\t// default exclude entries -------------------\n\n\t\texclude_list_default.add(\"/dev/*\");\n\t\texclude_list_default.add(\"/proc/*\");\n\t\texclude_list_default.add(\"/sys/*\");\n\t\texclude_list_default.add(\"/media/*\");\n\t\texclude_list_default.add(\"/mnt/*\");\n\t\texclude_list_default.add(\"/tmp/*\");\n\t\texclude_list_default.add(\"/run/*\");\n\t\texclude_list_default.add(\"/var/run/*\");\n\t\texclude_list_default.add(\"/var/lock/*\");\n\t\t//exclude_list_default.add(\"/var/spool/*\");\n\t\texclude_list_default.add(\"/var/lib/docker/*\");\n\t\texclude_list_default.add(\"/var/lib/schroot/*\");\n\t\texclude_list_default.add(\"/lost+found\");\n\t\texclude_list_default.add(\"/timeshift/*\");\n\t\texclude_list_default.add(\"/timeshift-btrfs/*\");\n\t\texclude_list_default.add(\"/data/*\");\n\t\texclude_list_default.add(\"/DATA/*\");\n\t\texclude_list_default.add(\"/cdrom/*\");\n\t\texclude_list_default.add(\"/sdcard/*\");\n\t\texclude_list_default.add(\"/system/*\");\n\t\texclude_list_default.add(\"/etc/timeshift.json\");\n\t\texclude_list_default.add(\"/var/log/timeshift/*\");\n\t\texclude_list_default.add(\"/var/log/timeshift-btrfs/*\");\n\t\texclude_list_default.add(\"/swapfile\");\n\t\texclude_list_default.add(\"/snap/*\");\n\n\t\tforeach(var entry in FsTabEntry.read_file(\"/etc/fstab\")){\n\n\t\t\tif (!entry.mount_point.has_prefix(\"/\")){ continue; }\n\n\t\t\t// ignore standard system folders\n\t\t\tif (entry.mount_point == \"/\"){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/bin\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/boot\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/cdrom\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/dev\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/etc\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/home\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/lib\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/lib64\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/media\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/mnt\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/opt\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/proc\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/root\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/run\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/sbin\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/snap\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/srv\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/sys\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/system\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/tmp\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/usr\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/var\")){ continue; }\n\n\t\t\t// add exclude entry for devices mounted to non-standard locations\n\n\t\t\texclude_list_default_extra.add(entry.mount_point + \"/*\");\n\t\t}\n\n\t\texclude_list_default.add(\"/root/.thumbnails\");\n\t\texclude_list_default.add(\"/root/.cache\");\n\t\texclude_list_default.add(\"/root/.dbus\");\n\t\texclude_list_default.add(\"/root/.gvfs\");\n\t\texclude_list_default.add(\"/root/.local/share/[Tt]rash\");\n\n\t\texclude_list_default.add(\"/home/*/.thumbnails\");\n\t\texclude_list_default.add(\"/home/*/.cache\");\n\t\texclude_list_default.add(\"/home/*/.dbus\");\n\t\texclude_list_default.add(\"/home/*/.gvfs\");\n\t\texclude_list_default.add(\"/home/*/.local/share/[Tt]rash\");\n\n\t\t// default extra ------------------\n\n\t\texclude_list_default_extra.add(\"/root/.mozilla/firefox/*.default/Cache\");\n\t\texclude_list_default_extra.add(\"/root/.mozilla/firefox/*.default/OfflineCache\");\n\t\texclude_list_default_extra.add(\"/root/.opera/cache\");\n\t\texclude_list_default_extra.add(\"/root/.kde/share/apps/kio_http/cache\");\n\t\texclude_list_default_extra.add(\"/root/.kde/share/cache/http\");\n\n\t\texclude_list_default_extra.add(\"/home/*/.mozilla/firefox/*.default/Cache\");\n\t\texclude_list_default_extra.add(\"/home/*/.mozilla/firefox/*.default/OfflineCache\");\n\t\texclude_list_default_extra.add(\"/home/*/.opera/cache\");\n\t\texclude_list_default_extra.add(\"/home/*/.kde/share/apps/kio_http/cache\");\n\t\texclude_list_default_extra.add(\"/home/*/.kde/share/cache/http\");\n\n\t\texclude_list_default_extra.add(\"/var/cache/apt/archives/*\");\n\t\texclude_list_default_extra.add(\"/var/cache/pacman/pkg/*\");\n\t\texclude_list_default_extra.add(\"/var/cache/yum/*\");\n\t\texclude_list_default_extra.add(\"/var/cache/dnf/*\");\n\t\texclude_list_default_extra.add(\"/var/cache/eopkg/*\");\n\t\texclude_list_default_extra.add(\"/var/cache/xbps/*\");\n\t\texclude_list_default_extra.add(\"/var/cache/zypp/*\");\n\t\texclude_list_default_extra.add(\"/var/cache/edb/*\");\n\t\t\n\t\t// default home ----------------\n\n\t\t//exclude_list_home.add(\"+ /root/.**\");\n\t\t//exclude_list_home.add(\"+ /home/*/.**\");\n\t\texclude_list_home.add(\"/root/**\");\n\t\texclude_list_home.add(\"/home/*/**\"); // Note: /home/** ignores include filters under /home\n\n\t\t/*\n\t\tMost web browsers store their cache under ~/.cache and /tmp\n\t\tThese files will be excluded by the entries for ~/.cache and /tmp\n\t\tThere is no need to add special entries.\n\n\t\t~/.cache/google-chrome\t\t\t-- Google Chrome\n\t\t~/.cache/chromium\t\t\t\t-- Chromium\n\t\t~/.cache/epiphany-browser\t\t-- Epiphany\n\t\t~/.cache/midori/web\t\t\t\t-- Midori\n\t\t/var/tmp/kdecache-$USER/http\t-- Rekonq\n\t\t*/\n\n\t\tlog_debug(\"Main: add_default_exclude_entries(): exit\");\n\t}\n\n\tpublic void add_app_exclude_entries(){\n\n\t\tlog_debug(\"Main: add_app_exclude_entries()\");\n\t\t\n\t\tAppExcludeEntry.clear();\n\t\t\n\t\tif (snapshot_to_restore != null){\n\t\t\tadd_app_exclude_entries_for_prefix(path_combine(snapshot_to_restore.path, \"localhost\"));\n\t\t}\n\n\t\t//if (!restore_current_system){\n\t\t//\tadd_app_exclude_entries_for_prefix(mount_point_restore);\n\t\t//}\n\n\t\texclude_list_apps = AppExcludeEntry.get_apps_list(exclude_app_names);\n\n\t\tlog_debug(\"Main: add_app_exclude_entries(): exit\");\n\t}\n\n\tprivate void add_app_exclude_entries_for_prefix(string path_prefix){\n\t\t\n\t\tstring path = \"\";\n\n\t\tpath = path_combine(path_prefix, \"root\");\n\t\tAppExcludeEntry.add_app_exclude_entries_from_path(path);\n\n\t\tpath = path_combine(path_prefix, \"home\");\n\t\tAppExcludeEntry.add_app_exclude_entries_from_home(path);\n\t}\n\t\n\n\tpublic Gee.ArrayList<string> create_exclude_list_for_backup(){\n\n\t\tlog_debug(\"Main: create_exclude_list_for_backup()\");\n\t\t\n\t\tvar list = new Gee.ArrayList<string>();\n\n\t\t// add default entries ---------------------------\n\t\t\n\t\tforeach(string path in exclude_list_default){\n\t\t\tif (!list.contains(path)){\n\t\t\t\tlist.add(path);\n\t\t\t}\n\t\t}\n\n\t\t// add default extra entries ---------------------------\n\t\t\n\t\tforeach(string path in exclude_list_default_extra){\n\t\t\tif (!list.contains(path)){\n\t\t\t\tlist.add(path);\n\t\t\t}\n\t\t}\n\n\t\t// add entries to exclude **decrypted** contents in $HOME\n\t\t// decrypted contents should never be backed-up or restored\n\t\t// this overrides all other user entries in exclude_list_user\n\t\t//  -------------------------------------------------------\n\t\t\n\t\tforeach(var user in current_system_users.values){\n\t\t\t\n\t\t\tif (user.is_system){ continue; }\n\t\t\t\n\t\t\tif (user.has_encrypted_home){\n\t\t\t\t\n\t\t\t\t// exclude decrypted contents in user's home ($HOME)\n\t\t\t\tstring path = \"%s/**\".printf(user.home_path);\n\t\t\t\tlist.add(path);\n\t\t\t}\n\t\t\t\n\t\t\tif (user.has_encrypted_private_dirs){\n\n\t\t\t\tforeach(string enc_path in user.encrypted_private_dirs){\n\t\t\t\t\t\n\t\t\t\t\t// exclude decrypted contents in private dirs ($HOME/Private)\n\t\t\t\t\tstring path = \"%s/**\".printf(enc_path);\n\t\t\t\t\tlist.add(path);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// exclude each user individually if not included in exclude_list_user\n\n\t\tforeach(var user in current_system_users.values){\n\n\t\t\tif (user.is_system){ continue; }\n\n\t\t\tstring exc_pattern = \"%s/**\".printf(user.home_path);\n\t\t\tstring inc_pattern = \"+ %s/**\".printf(user.home_path);\n\t\t\tstring inc_hidden_pattern = \"+ %s/.**\".printf(user.home_path);\n\n\t\t\tif (user.has_encrypted_home){\n\t\t\t\tinc_pattern = \"+ /home/.ecryptfs/%s/***\".printf(user.name);\n\t\t\t\texc_pattern = \"/home/.ecryptfs/%s/***\".printf(user.name);\n\t\t\t}\n\t\t\t\n\t\t\tbool include_hidden = exclude_list_user.contains(inc_hidden_pattern);\n\t\t\tbool include_all = exclude_list_user.contains(inc_pattern);\n\t\t\tbool exclude_all = !include_hidden && !include_all;\n\n\t\t\tif (exclude_all){\n\t\t\t\tif (!exclude_list_user.contains(exc_pattern)){\n\t\t\t\t\texclude_list_user.add(exc_pattern);\n\t\t\t\t}\n\t\t\t\tif (exclude_list_user.contains(inc_pattern)){\n\t\t\t\t\texclude_list_user.remove(inc_pattern);\n\t\t\t\t}\n\t\t\t\tif (exclude_list_user.contains(inc_hidden_pattern)){\n\t\t\t\t\texclude_list_user.remove(inc_hidden_pattern);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// add user entries from current settings ----------\n\t\t\n\t\tforeach(string path in exclude_list_user){\n\t\t\tif (!list.contains(path)){\n\t\t\t\tlist.add(path);\n\t\t\t}\n\t\t}\n\n\t\t// add common entries for excluding home folders for all users --------\n\t\t\n\t\tforeach(string path in exclude_list_home){\n\t\t\tif (!list.contains(path)){\n\t\t\t\tlist.add(path);\n\t\t\t}\n\t\t}\n\n\t\tstring timeshift_path = \"/timeshift/*\";\n\t\tif (!list.contains(timeshift_path)){\n\t\t\tlist.add(timeshift_path);\n\t\t}\n\n\t\tlog_debug(\"Main: create_exclude_list_for_backup(): exit\");\n\t\t\n\t\treturn list;\n\t}\n\n\tpublic Gee.ArrayList<string> create_exclude_list_for_restore(){\n\n\t\tlog_debug(\"Main: create_exclude_list_for_restore()\");\n\t\t\n\t\texclude_list_restore.clear();\n\t\t\n\t\t//add default entries\n\t\tforeach(string path in exclude_list_default){\n\t\t\tif (!exclude_list_restore.contains(path)){\n\t\t\t\texclude_list_restore.add(path);\n\t\t\t}\n\t\t}\n\n\t\tif (!mirror_system){\n\t\t\t//add default_extra entries\n\t\t\tforeach(string path in exclude_list_default_extra){\n\t\t\t\tif (!exclude_list_restore.contains(path)){\n\t\t\t\t\texclude_list_restore.add(path);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//add app entries\n\t\tforeach(var entry in exclude_list_apps){\n\t\t\tif (entry.enabled){\n\t\t\t\tforeach(var pattern in entry.patterns){\n\t\t\t\t\tif (!exclude_list_restore.contains(pattern)){\n\t\t\t\t\t\texclude_list_restore.add(pattern);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//add user entries from current settings\n\t\tforeach(string path in exclude_list_user){\n\n\t\t\t// skip include filters for restore\n\t\t\tif (path.strip().has_prefix(\"+\")){ continue; }\n\t\t\t\n\t\t\tif (!exclude_list_restore.contains(path) && !exclude_list_home.contains(path)){\n\t\t\t\texclude_list_restore.add(path);\n\t\t\t}\n\t\t}\n\n\t\t//add user entries from snapshot exclude list\n\t\tif (snapshot_to_restore != null){\n\t\t\tstring list_file = path_combine(snapshot_to_restore.path, \"exclude.list\");\n\t\t\tif (file_exists(list_file)){\n\t\t\t\tforeach(string path in file_read(list_file).split(\"\\n\")){\n\t\t\t\t\tif (!exclude_list_restore.contains(path) && !exclude_list_home.contains(path)){\n\t\t\t\t\t\texclude_list_restore.add(path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//add home entries\n\t\tforeach(string path in exclude_list_home){\n\t\t\tif (!exclude_list_restore.contains(path)){\n\t\t\t\texclude_list_restore.add(path);\n\t\t\t}\n\t\t}\n\n\t\tstring timeshift_path = \"/timeshift/*\";\n\t\tif (!exclude_list_restore.contains(timeshift_path)){\n\t\t\texclude_list_restore.add(timeshift_path);\n\t\t}\n\n\t\tlog_debug(\"Main: create_exclude_list_for_restore(): exit\");\n\t\t\n\t\treturn exclude_list_restore;\n\t}\n\n\n\tpublic bool save_exclude_list_for_backup(string output_path){\n\n\t\tlog_debug(\"Main: save_exclude_list_for_backup()\");\n\t\t\n\t\tvar list = create_exclude_list_for_backup();\n\t\t\n\t\tvar txt = \"\";\n\t\tforeach(var pattern in list){\n\t\t\tif (pattern.strip().length > 0){\n\t\t\t\ttxt += \"%s\\n\".printf(pattern);\n\t\t\t}\n\t\t}\n\t\t\n\t\tstring list_file = path_combine(output_path, \"exclude.list\");\n\t\treturn file_write(list_file, txt);\n\t}\n\n\tpublic bool save_exclude_list_for_restore(string output_path){\n\n\t\tlog_debug(\"Main: save_exclude_list_for_restore()\");\n\t\t\n\t\tvar list = create_exclude_list_for_restore();\n\n\t\tlog_debug(\"Exclude list -------------\");\n\t\t\n\t\tvar txt = \"\";\n\t\tforeach(var pattern in list){\n\t\t\tif (pattern.strip().length > 0){\n\t\t\t\ttxt += \"%s\\n\".printf(pattern);\n\t\t\t\tlog_debug(pattern);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn file_write(restore_exclude_file, txt);\n\t}\n\n\tpublic void save_exclude_list_selections(){\n\n\t\tlog_debug(\"Main: save_exclude_list_selections()\");\n\t\t\n\t\t// add new selected items\n\t\tforeach(var entry in exclude_list_apps){\n\t\t\tif (entry.enabled && !exclude_app_names.contains(entry.name)){\n\t\t\t\texclude_app_names.add(entry.name);\n\t\t\t\tlog_debug(\"add app name: %s\".printf(entry.name));\n\t\t\t}\n\t\t}\n\n\t\t// remove item only if present in current list and un-selected\n\t\tforeach(var entry in exclude_list_apps){\n\t\t\tif (!entry.enabled && exclude_app_names.contains(entry.name)){\n\t\t\t\texclude_app_names.remove(entry.name);\n\t\t\t\tlog_debug(\"remove app name: %s\".printf(entry.name));\n\t\t\t}\n\t\t}\n\n\t\texclude_app_names.sort((a,b) => {\n\t\t\treturn Posix.strcmp(a,b);\n\t\t});\n\t}\n\n\t//properties\n\t\n\tpublic bool scheduled{\n\t\tget{\n\t\t\treturn !live_system()\n\t\t\t&& (schedule_boot || schedule_hourly || schedule_daily ||\n\t\t\t\tschedule_weekly || schedule_monthly);\n\t\t}\n\t}\n\n\tpublic bool live_system(){\n\t\t//return true;\n\t\treturn (sys_root == null);\n\t}\n\n\t// backup\n\n\tpublic bool create_snapshot (bool is_ondemand, Gtk.Window? parent_win){\n\n\t\tlog_debug(\"Main: create_snapshot()\");\n\t\t\n\t\tbool status = true;\n\t\tbool update_symlinks = false;\n\n\t\tstring sys_uuid = (sys_root == null) ? \"\" : sys_root.uuid;\n\t\t\n\t\ttry\n\t\t{\n\t\t\tif (btrfs_mode && (check_btrfs_layout_system() == false)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\n\t\t\t// create a timestamp\n\t\t\tDateTime now = new DateTime.now_local();\n\n\t\t\t// check space\n\t\t\tif (!repo.has_space()){\n\n\t\t\t\tlog_error(repo.status_message);\n\t\t\t\tlog_error(repo.status_details + \"\\n\");\n\t\t\t\t\n\t\t\t\t// remove invalid snapshots\n\t\t\t\tif (app_mode.length != 0){\n\t\t\t\t\trepo.auto_remove();\n\t\t\t\t}\n\n\t\t\t\t// check again ------------\n\n\t\t\t\tif (!repo.has_space()){\n\t\t\t\t\tlog_error(repo.status_message);\n\t\t\t\t\tlog_error(repo.status_details + \"\\n\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create snapshot root if missing\n\t\t\tvar f = File.new_for_path(repo.snapshots_path);\n\t\t\tif (!f.query_exists()){\n\t\t\t\tlog_debug(\"mkdir: %s\".printf(repo.snapshots_path));\n\t\t\t\tf.make_directory_with_parents();\n\t\t\t}\n\n\t\t\t// ondemand\n\t\t\tif (is_ondemand){\n\t\t\t\tbool ok = create_snapshot_for_tag (\"ondemand\",now); \n\t\t\t\tif(!ok){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tupdate_symlinks = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (scheduled){\n\t\t\t\tSnapshot last_snapshot_boot = repo.get_latest_snapshot(\"boot\", sys_uuid);\n\t\t\t\tSnapshot last_snapshot_hourly = repo.get_latest_snapshot(\"hourly\", sys_uuid);\n\t\t\t\tSnapshot last_snapshot_daily = repo.get_latest_snapshot(\"daily\", sys_uuid);\n\t\t\t\tSnapshot last_snapshot_weekly = repo.get_latest_snapshot(\"weekly\", sys_uuid);\n\t\t\t\tSnapshot last_snapshot_monthly = repo.get_latest_snapshot(\"monthly\", sys_uuid);\n\n\t\t\t\tDateTime dt_sys_boot = now.add_seconds((-1) * get_system_uptime_seconds());\n\t\t\t\tbool take_new = false;\n\n\t\t\t\tif (schedule_boot){\n\n\t\t\t\t\tlog_msg(_(\"Boot snapshots are enabled\"));\n\n\t\t\t\t\tif (last_snapshot_boot == null){\n\t\t\t\t\t\tlog_msg(_(\"Last boot snapshot not found\"));\n\t\t\t\t\t\ttake_new = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (last_snapshot_boot.date.compare(dt_sys_boot) < 0){\n\t\t\t\t\t\tlog_msg(_(\"Last boot snapshot is older than system start time\"));\n\t\t\t\t\t\ttake_new = true;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tint hours = (int) ((float) now.difference(last_snapshot_boot.date) / TimeSpan.HOUR);\n\t\t\t\t\t\tlog_msg(_(\"Last boot snapshot is %d hours old\").printf(hours));\n\t\t\t\t\t\ttake_new = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (take_new){\n\t\t\t\t\t\tstatus = create_snapshot_for_tag (\"boot\",now);\n\t\t\t\t\t\tif(!status){\n\t\t\t\t\t\t\tlog_error(_(\"Boot snapshot failed!\"));\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tupdate_symlinks = true;\n\t\t\t\t\t\t\trepo.load_snapshots();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (schedule_hourly){\n\n\t\t\t\t\tlog_msg(_(\"Hourly snapshots are enabled\"));\n\n\t\t\t\t\tif (last_snapshot_hourly == null){\n\t\t\t\t\t\tlog_msg(_(\"Last hourly snapshot not found\"));\n\t\t\t\t\t\ttake_new = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (last_snapshot_hourly.date.compare(now.add_hours(-1).add_minutes(1)) < 0){\n\t\t\t\t\t\tlog_msg(_(\"Last hourly snapshot is more than 1 hour old\"));\n\t\t\t\t\t\ttake_new = true;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tint mins = (int) ((float) now.difference(last_snapshot_hourly.date) / TimeSpan.MINUTE);\n\t\t\t\t\t\tlog_msg(_(\"Last hourly snapshot is %d minutes old\").printf(mins));\n\t\t\t\t\t\ttake_new = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (take_new){\n\t\t\t\t\t\tstatus = create_snapshot_for_tag (\"hourly\",now);\n\t\t\t\t\t\tif(!status){\n\t\t\t\t\t\t\tlog_error(_(\"Hourly snapshot failed!\"));\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tupdate_symlinks = true;\n\t\t\t\t\t\t\trepo.load_snapshots();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (schedule_daily){\n\n\t\t\t\t\tlog_msg(_(\"Daily snapshots are enabled\"));\n\n\t\t\t\t\tif (last_snapshot_daily == null){\n\t\t\t\t\t\tlog_msg(_(\"Last daily snapshot not found\"));\n\t\t\t\t\t\ttake_new = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (last_snapshot_daily.date.compare(now.add_days(-1).add_minutes(1)) < 0){\n\t\t\t\t\t\tlog_msg(_(\"Last daily snapshot is more than 1 day old\"));\n\t\t\t\t\t\ttake_new = true;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tint hours = (int) ((float) now.difference(last_snapshot_daily.date) / TimeSpan.HOUR);\n\t\t\t\t\t\tlog_msg(_(\"Last daily snapshot is %d hours old\").printf(hours));\n\t\t\t\t\t\ttake_new = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (take_new){\n\t\t\t\t\t\tstatus = create_snapshot_for_tag (\"daily\",now);\n\t\t\t\t\t\tif(!status){\n\t\t\t\t\t\t\tlog_error(_(\"Daily snapshot failed!\"));\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tupdate_symlinks = true;\n\t\t\t\t\t\t\trepo.load_snapshots();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (schedule_weekly){\n\n\t\t\t\t\tlog_msg(_(\"Weekly snapshots are enabled\"));\n\n\t\t\t\t\tif (last_snapshot_weekly == null){\n\t\t\t\t\t\tlog_msg(_(\"Last weekly snapshot not found\"));\n\t\t\t\t\t\ttake_new = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (last_snapshot_weekly.date.compare(now.add_weeks(-1).add_minutes(1)) < 0){\n\t\t\t\t\t\tlog_msg(_(\"Last weekly snapshot is more than 1 week old\"));\n\t\t\t\t\t\ttake_new = true;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tint days = (int) ((float) now.difference(last_snapshot_weekly.date) / TimeSpan.DAY);\n\t\t\t\t\t\tlog_msg(_(\"Last weekly snapshot is %d days old\").printf(days));\n\t\t\t\t\t\ttake_new = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (take_new){\n\t\t\t\t\t\tstatus = create_snapshot_for_tag (\"weekly\",now);\n\t\t\t\t\t\tif(!status){\n\t\t\t\t\t\t\tlog_error(_(\"Weekly snapshot failed!\"));\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tupdate_symlinks = true;\n\t\t\t\t\t\t\trepo.load_snapshots();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (schedule_monthly){\n\n\t\t\t\t\tlog_msg(_(\"Monthly snapshot are enabled\"));\n\n\t\t\t\t\tif (last_snapshot_monthly == null){\n\t\t\t\t\t\tlog_msg(_(\"Last monthly snapshot not found\"));\n\t\t\t\t\t\ttake_new = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (last_snapshot_monthly.date.compare(now.add_months(-1).add_minutes(1)) < 0){\n\t\t\t\t\t\tlog_msg(_(\"Last monthly snapshot is more than 1 month old\"));\n\t\t\t\t\t\ttake_new = true;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tint days = (int) ((float) now.difference(last_snapshot_monthly.date) / TimeSpan.DAY);\n\t\t\t\t\t\tlog_msg(_(\"Last monthly snapshot is %d days old\").printf(days));\n\t\t\t\t\t\ttake_new = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (take_new){\n\t\t\t\t\t\tstatus = create_snapshot_for_tag (\"monthly\",now);\n\t\t\t\t\t\tif(!status){\n\t\t\t\t\t\t\tlog_error(_(\"Monthly snapshot failed!\"));\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tupdate_symlinks = true;\n\t\t\t\t\t\t\trepo.load_snapshots();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_msg(_(\"Scheduled snapshots are disabled\") + \" - \" + _(\"Nothing to do!\"));\n\t\t\t\tcron_job_update();\n\t\t\t}\n\t\t\t\n\t\t\tlog_msg(string.nfill(78, '-'));\n\n\t\t\trepo.load_snapshots(); // reload list for new snapshot\n\t\t\t\n\t\t\tif (app_mode.length != 0){\n\t\t\t\trepo.auto_remove();\n\t\t\t\trepo.load_snapshots();\n\t\t\t}\n\n\t\t\tif (update_symlinks){\n\t\t\t\trepo.create_symlinks();\n\t\t\t}\n\t\t\t\n\t\t\t//log_msg(\"OK\");\n\t\t}\n\t\tcatch(Error e){\n\t\t\tlog_error (e.message);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn status;\n\t}\n\n\tprivate bool create_snapshot_for_tag(string tag, DateTime dt_created){\n\n\t\tlog_debug(\"Main: backup_and_rotate()\");\n\t\t\n\t\t// save start time\n\t\tvar dt_begin = new DateTime.now_local();\n\t\tbool status = true;\n\t\t\n\t\ttry{\n\t\t\t// get system boot time\n\t\t\tDateTime now = new DateTime.now_local();\n\t\t\tDateTime dt_sys_boot = now.add_seconds((-1) * get_system_uptime_seconds());\n\n\t\t\t// check if we can rotate an existing backup -------------\n\n\t\t\tDateTime dt_filter = null;\n\n\t\t\tif (tag != \"ondemand\"){\n\t\t\t\tswitch(tag){\n\t\t\t\t\tcase \"boot\":\n\t\t\t\t\t\tdt_filter = dt_sys_boot;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"hourly\":\n\t\t\t\t\tcase \"daily\":\n\t\t\t\t\tcase \"weekly\":\n\t\t\t\t\tcase \"monthly\":\n\t\t\t\t\t\tdt_filter = now.add_hours(-1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tlog_error(_(\"Unknown snapshot type\") + \": %s\".printf(tag));\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// find a recent backup that can be used\n\t\t\t\tSnapshot backup_to_rotate = null;\n\t\t\t\tforeach(var bak in repo.snapshots){\n\t\t\t\t\tif (bak.date.compare(dt_filter) > 0){\n\t\t\t\t\t\tbackup_to_rotate = bak;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (backup_to_rotate != null){\n\t\t\t\t\t\n\t\t\t\t\t// tag the backup\n\t\t\t\t\tbackup_to_rotate.add_tag(tag);\n\t\n\t\t\t\t\tvar message = _(\"Tagged snapshot\") + \" '%s': %s\".printf(backup_to_rotate.name, tag);\n\t\t\t\t\tlog_msg(message);\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!repo.available() || !repo.has_space()){\n\t\t\t\tlog_error(repo.status_message);\n\t\t\t\tlog_error(repo.status_details);\n\t\t\t\texit_app();\n\t\t\t}\n\t\t\t\n\t\t\t// create new snapshot -----------------------\n\n\t\t\tSnapshot new_snapshot = null;\n\t\t\tif (btrfs_mode){\n\t\t\t\tnew_snapshot = create_snapshot_with_btrfs(tag, dt_created);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnew_snapshot = create_snapshot_with_rsync(tag, dt_created);\n\t\t\t}\n\t\t\t\n\t\t\t// finish ------------------------------\n\t\t\n\t\t\tvar dt_end = new DateTime.now_local();\n\t\t\tTimeSpan elapsed = dt_end.difference(dt_begin);\n\t\t\tlong seconds = (long)(elapsed * 1.0 / TimeSpan.SECOND);\n\t\t\t\n\t\t\tvar message = \"\";\n\t\t\tif (new_snapshot != null){\n\t\t\t\tmessage = \"%s %s (%lds)\".printf((btrfs_mode ? \"BTRFS\" : \"RSYNC\"), _(\"Snapshot saved successfully\"), seconds);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmessage = _(\"Failed to create snapshot\");\n\t\t\t}\n\n\t\t\tlog_msg(message);\n\t\t\tOSDNotify.notify_send(\"TimeShift\", message, 10000, \"low\");\n\n\t\t\tif (new_snapshot != null){\n\t\t\t\tmessage = _(\"Tagged snapshot\") + \" '%s': %s\".printf(new_snapshot.name, tag);\n\t\t\t\tlog_msg(message);\n\t\t\t}\n\t\t}\n\t\tcatch(Error e){\n\t\t\tlog_error (e.message);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn status;\n\t}\n\n\tprivate Snapshot? create_snapshot_with_rsync(string tag, DateTime dt_created){\n\n\t\tlog_msg(string.nfill(78, '-'));\n\n\t\tif (first_snapshot_size == 0){\n\t\t\tlog_msg(_(\"Estimating system size...\"));\n\t\t\testimate_system_size();\n\t\t}\n\t\t\n\t\tlog_msg(_(\"Creating new snapshot...\") + \"(RSYNC)\");\n\n\t\tlog_msg(_(\"Saving to device\") + \": %s\".printf(repo.device.device) + \", \" + _(\"mounted at path\") + \": %s\".printf(repo.mount_path));\n\t\t\n\t\t// take new backup ---------------------------------\n\n\t\tif (repo.mount_path.length == 0){\n\t\t\tlog_error(\"Backup location not mounted\");\n\t\t\texit_app();\n\t\t}\n\n\t\tstring time_stamp = dt_created.format(\"%Y-%m-%d_%H-%M-%S\");\n\t\tstring snapshot_dir = repo.snapshots_path;\n\t\tstring snapshot_name = time_stamp;\n\t\tstring snapshot_path = path_combine(snapshot_dir, snapshot_name);\n\t\tdir_create(snapshot_path);\n\t\tstring localhost_path = path_combine(snapshot_path, \"localhost\");\n\t\tdir_create(localhost_path);\n\t\t\n\t\tstring sys_uuid = (sys_root == null) ? \"\" : sys_root.uuid;\n\n\t\tSnapshot snapshot_to_link = null;\n\n\t\t// check if a snapshot was restored recently and use it for linking ---------\n\n\t\ttry{\n\t\t\t\n\t\t\tstring ctl_path = path_combine(snapshot_dir, \".sync-restore\");\n\t\t\tvar f = File.new_for_path(ctl_path);\n\t\t\t\n\t\t\tif (f.query_exists()){\n\n\t\t\t\t// read snapshot name from file\n\t\t\t\tstring snap_path = file_read(ctl_path);\n\t\t\t\tstring snap_name = file_basename(snap_path);\n\t\t\t\t\n\t\t\t\t// find the snapshot that was restored\n\t\t\t\tforeach(var bak in repo.snapshots){\n\t\t\t\t\tif ((bak.name == snap_name) && (bak.sys_uuid == sys_uuid)){\n\t\t\t\t\t\t// use for linking\n\t\t\t\t\t\tsnapshot_to_link = bak;\n\t\t\t\t\t\t// delete the restore-control-file\n\t\t\t\t\t\tf.delete();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch(Error e){\n\t\t\tlog_error (e.message);\n\t\t\treturn null;\n\t\t}\n\n\t\t// get latest snapshot to link if not set -------\n\n\t\tif (snapshot_to_link == null){\n\t\t\tsnapshot_to_link = repo.get_latest_snapshot(\"\", sys_uuid);\n\t\t}\n\n\t\tstring link_from_path = \"\";\n\t\tif (snapshot_to_link != null){\n\t\t\tlog_msg(\"%s: %s\".printf(_(\"Linking from snapshot\"), snapshot_to_link.name));\n\t\t\tlink_from_path = \"%s/localhost/\".printf(snapshot_to_link.path);\n\t\t}\n\n\t\t// save exclude list ----------------\n\n\t\tbool ok = save_exclude_list_for_backup(snapshot_path);\n\t\t\n\t\tstring exclude_from_file = path_combine(snapshot_path, \"exclude.list\");\n\n\t\tif (!ok){\n\t\t\tlog_error(_(\"Failed to save exclude list\"));\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t// rsync file system -------------------\n\t\t\n\t\tprogress_text = _(\"Synching files with rsync...\");\n\t\tlog_msg(progress_text);\n\n\t\tvar log_file = snapshot_path + \"/rsync-log\";\n\t\tfile_delete(log_file);\n\n\t\ttask = new RsyncTask();\n\n\t\ttask.source_path = \"\";\n\t\ttask.dest_path = snapshot_path + \"/localhost/\";\n\t\ttask.link_from_path = link_from_path;\n\t\ttask.exclude_from_file = exclude_from_file;\n\t\ttask.rsync_log_file = log_file;\n\t\ttask.prg_count_total = Main.first_snapshot_count;\n\n\t\ttask.relative = true;\n\t\ttask.verbose = true;\n\t\ttask.delete_extra = true;\n\t\ttask.delete_excluded = true;\n\t\ttask.delete_after = false;\n\t\t\t\n\t\tif (app_mode.length > 0){\n\t\t\t// console mode\n\t\t\ttask.io_nice = true;\n\t\t}\n\n\t\ttask.execute();\n\n\t\twhile (task.status == AppStatus.RUNNING){\n\t\t\tsleep(1000);\n\t\t\tgtk_do_events();\n\n\t\t\tstdout.printf(\"%6.2f%% %s (%s %s)\\r\".printf(task.progress * 100.0, _(\"complete\"), task.stat_time_remaining, _(\"remaining\")));\n\t\t\tstdout.flush();\n\t\t}\n\n\t\tstdout.printf(string.nfill(80, ' '));\n\t\tstdout.flush();\n\n\t\tstdout.printf(\"\\r\");\n\t\tstdout.flush();\n\t\t\n\t\tif (task.total_size == 0){\n\t\t\tlog_error(_(\"rsync returned an error\"));\n\t\t\tlog_error(_(\"Failed to create new snapshot\"));\n\t\t\treturn null;\n\t\t}\n\n\t\tstring initial_tags = (tag == \"ondemand\") ? \"\" : tag;\n\t\t\n\t\t// write control file\n\t\t// this step is redundant - just in case if app crashes while parsing log file in next step\n\t\t//Snapshot.write_control_file(\n\t\t//\tsnapshot_path, dt_created, sys_uuid, current_distro.full_name(),\n\t\t//\tinitial_tags, cmd_comments, 0, false, false, repo);\n\n\t\t// parse log file\n\t\t//progress_text = _(\"Parsing log file...\");\n\t\t//log_msg(progress_text);\n\t\t//var task = new RsyncTask();\n\t\t//task.parse_log(log_file);\n\n\t\tint64 fcount = file_line_count(log_file);\n\n\t\t// write control file (final - with file count after parsing log)\n\t\tvar snapshot = Snapshot.write_control_file(\n\t\t\tsnapshot_path, dt_created, sys_uuid, current_distro.full_name(),\n\t\t\tinitial_tags, cmd_comments, fcount, false, false, repo);\n\n\t\tset_tags(snapshot); // set_tags() will update the control file\n\n\t\treturn snapshot;\n\t}\n\n\tprivate Snapshot? create_snapshot_with_btrfs(string tag, DateTime dt_created){\n\n\t\tlog_msg(_(\"Creating new backup...\") + \"(BTRFS)\");\n\n\t\tlog_msg(_(\"Saving to device\") + \": %s\".printf(repo.device.device) + \", \" + _(\"mounted at path\") + \": %s\".printf(repo.mount_paths[\"@\"]));\n\t\tif ((repo.device_home != null) && (repo.device_home.uuid != repo.device.uuid)){\n\t\t\tlog_msg(_(\"Saving to device\") + \": %s\".printf(repo.device_home.device) + \", \" + _(\"mounted at path\") + \": %s\".printf(repo.mount_paths[\"@home\"]));\n\t\t}\n\n\t\t// take new backup ---------------------------------\n\n\t\tif (repo.mount_path.length == 0){\n\t\t\tlog_error(\"Snapshot device not mounted\");\n\t\t\texit_app();\n\t\t}\n\n\t\tstring time_stamp = dt_created.format(\"%Y-%m-%d_%H-%M-%S\");\n\t\tstring snapshot_name = time_stamp;\n\t\tstring sys_uuid = (sys_root == null) ? \"\" : sys_root.uuid;\n\t\tstring snapshot_path = \"\";\n\t\t\n\t\t// create subvolume snapshots\n\n\t\tvar subvol_names = new string[] { \"@\" };\n\t\t\n\t\tif (include_btrfs_home_for_backup){\n\t\t\t\n\t\t\tsubvol_names = new string[] { \"@\",\"@home\" };\n\t\t}\n\t\t\n\t\tforeach(var subvol_name in subvol_names){\n\n\t\t\tsnapshot_path = path_combine(repo.mount_paths[subvol_name], \"timeshift-btrfs/snapshots/%s\".printf(snapshot_name));\n\t\t\t\n\t\t\tdir_create(snapshot_path, true);\n\t\t\t\n\t\t\tstring src_path = path_combine(repo.mount_paths[subvol_name], subvol_name);\n\t\t\t\n\t\t\tstring dst_path = path_combine(snapshot_path, subvol_name);\n\n\t\t\t// Dirty hack to fix the nested subvilumes issue (cause of issue is unknown)\n\t\t\tif (dst_path.has_suffix(\"/@/@\")){\n\t\t\t\tdst_path = dst_path.replace(\"/@/@\", \"/@\");\n\t\t\t}\n\t\t\telse if (dst_path.has_suffix(\"/@home/@home\")){\n\t\t\t\tdst_path = dst_path.replace(\"/@home/@home\", \"/@home\");\n\t\t\t}\n\t\t\t\n\t\t\tstring cmd = \"btrfs subvolume snapshot '%s' '%s' \\n\".printf(src_path, dst_path);\n\t\t\t\n\t\t\tif (LOG_COMMANDS) { log_debug(cmd); }\n\n\t\t\tstring std_out, std_err;\n\t\t\t\n\t\t\tint ret_val = exec_sync(cmd, out std_out, out std_err);\n\t\t\t\n\t\t\tif (ret_val != 0){\n\t\t\t\t\n\t\t\t\tlog_error (std_err);\n\t\t\t\tlog_error(_(\"btrfs returned an error\") + \": %d\".printf(ret_val));\n\t\t\t\tlog_error(_(\"Failed to create subvolume snapshot\") + \": %s\".printf(subvol_name));\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_msg(_(\"Created subvolume snapshot\") + \": %s\".printf(dst_path));\n\t\t\t}\n\t\t}\n\n\t\t//log_msg(_(\"Writing control file...\"));\n\n\t\tsnapshot_path = path_combine(repo.mount_paths[\"@\"], \"timeshift-btrfs/snapshots/%s\".printf(snapshot_name));\n\n\t\tstring initial_tags = (tag == \"ondemand\") ? \"\" : tag;\n\t\t\n\t\t// write control file\n\t\tvar snapshot = Snapshot.write_control_file(\n\t\t\tsnapshot_path, dt_created, sys_uuid, current_distro.full_name(),\n\t\t\tinitial_tags, cmd_comments, 0, true, false, repo);\n\n\t\t// write subvolume info\n\t\tforeach(var subvol in sys_subvolumes.values){\n\t\t\tsnapshot.subvolumes.set(subvol.name, subvol);\n\t\t}\n\t\tsnapshot.update_control_file(); // save subvolume info\n\n\t\tset_tags(snapshot); // set_tags() will update the control file\n\t\t\n\t\treturn snapshot;\n\t}\n\n\tprivate void set_tags(Snapshot snapshot){\n\n\t\t// add tags passed on commandline for both --check and --create\n\t\t\n\t\tforeach(string tag in cmd_tags.split(\",\")){\n\t\t\tswitch(tag.strip().up()){\n\t\t\tcase \"B\":\n\t\t\t\tsnapshot.add_tag(\"boot\");\n\t\t\t\tbreak;\n\t\t\tcase \"H\":\n\t\t\t\tsnapshot.add_tag(\"hourly\");\n\t\t\t\tbreak;\n\t\t\tcase \"D\":\n\t\t\t\tsnapshot.add_tag(\"daily\");\n\t\t\t\tbreak;\n\t\t\tcase \"W\":\n\t\t\t\tsnapshot.add_tag(\"weekly\");\n\t\t\t\tbreak;\n\t\t\tcase \"M\":\n\t\t\t\tsnapshot.add_tag(\"monthly\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// add tag as ondemand if no other tag is specified\n\t\t\n\t\tif (snapshot.tags.size == 0){\n\t\t\tsnapshot.add_tag(\"ondemand\");\n\t\t}\n\t}\n\n\tpublic void validate_cmd_tags(){\n\t\tforeach(string tag in cmd_tags.split(\",\")){\n\t\t\tswitch(tag.strip().up()){\n\t\t\tcase \"B\":\n\t\t\tcase \"H\":\n\t\t\tcase \"D\":\n\t\t\tcase \"W\":\n\t\t\tcase \"M\":\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlog_error(_(\"Unknown value specified for option --tags\") + \" (%s).\".printf(tag));\n\t\t\t\tlog_error(_(\"Expected values: O, B, H, D, W, M\"));\n\t\t\t\texit_app(1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// gui delete\n\n\tpublic void delete_begin(){\n\n\t\tlog_debug(\"Main: delete_begin()\");\n\t\tprogress_text = _(\"Preparing...\");\n\t\t\n\t\ttry {\n\t\t\tthread_delete_running = true;\n\t\t\tthread_delete_success = false;\n\t\t\tThread.create<void> (delete_thread, true);\n\n\t\t\t//new Thread<bool> (\"\", delete_thread);\n\n\t\t\tlog_debug(\"delete_begin(): thread created\");\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tthread_delete_running = false;\n\t\t\tthread_delete_success = false;\n\t\t\tlog_error (e.message);\n\t\t}\n\n\t\tlog_debug(\"Main: delete_begin(): exit\");\n\t}\n\n\tpublic void delete_thread(){\n\n\t\tlog_debug(\"delete_thread()\");\n\n\t\tbool status = true;\n\n\t\tforeach(var bak in delete_list){\n\t\t\tbak.mark_for_deletion();\n\t\t}\n\t\t\n\t\twhile (delete_list.size > 0){\n\n\t\t\tvar bak = delete_list[0];\n\t\t\tbak.mark_for_deletion(); // mark for deletion again since initial list may have changed\n\n\t\t\tif (btrfs_mode){\n\t\t\t\tstatus = bak.remove(true); // wait till complete\n\n\t\t\t\tvar message = \"%s '%s'\".printf(_(\"Removed\"), bak.name);\n\t\t\t\tOSDNotify.notify_send(\"TimeShift\", message, 10000, \"low\");\n\t\t\t}\n\t\t\telse{\n\n\t\t\t\tdelete_file_task = bak.delete_file_task;\n\t\t\t\tdelete_file_task.prg_count_total = (int64) Main.first_snapshot_count;\n\t\t\t\n\t\t\t\tstatus = bak.remove(true); // wait till complete\n\n\t\t\t\tif (delete_file_task.status != AppStatus.CANCELLED){\n\t\t\t\t\tvar message = \"%s '%s' (%s)\".printf(_(\"Removed\"), bak.name, delete_file_task.stat_time_elapsed);\n\t\t\t\t\tOSDNotify.notify_send(\"TimeShift\", message, 10000, \"low\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdelete_list.remove(bak);\n\t\t}\n\n\t\tthread_delete_running = false;\n\t\tthread_delete_success = status;\n\t}\n\t\n\t// restore  - properties\n\n\tpublic Device? dst_root{\n\t\tget {\n\t\t\tforeach(var mnt in mount_list){\n\t\t\t\tif (mnt.mount_point == \"/\"){\n\t\t\t\t\treturn mnt.device;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tset{\n\t\t\tforeach(var mnt in mount_list){\n\t\t\t\tif (mnt.mount_point == \"/\"){\n\t\t\t\t\tmnt.device = value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic Device? dst_boot{\n\t\tget {\n\t\t\tforeach(var mnt in mount_list){\n\t\t\t\tif (mnt.mount_point == \"/boot\"){\n\t\t\t\t\treturn mnt.device;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tset{\n\t\t\tforeach(var mnt in mount_list){\n\t\t\t\tif (mnt.mount_point == \"/boot\"){\n\t\t\t\t\tmnt.device = value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic Device? dst_efi{\n\t\tget {\n\t\t\tforeach(var mnt in mount_list){\n\t\t\t\tif (mnt.mount_point == \"/boot/efi\"){\n\t\t\t\t\treturn mnt.device;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tset{\n\t\t\tforeach(var mnt in mount_list){\n\t\t\t\tif (mnt.mount_point == \"/boot/efi\"){\n\t\t\t\t\tmnt.device = value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic Device? dst_home{\n\t\tget {\n\t\t\tforeach(var mnt in mount_list){\n\t\t\t\tif (mnt.mount_point == \"/home\"){\n\t\t\t\t\treturn mnt.device;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tset{\n\t\t\tforeach(var mnt in mount_list){\n\t\t\t\tif (mnt.mount_point == \"/home\"){\n\t\t\t\t\tmnt.device = value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic bool restore_current_system{\n\t\tget {\n\t\t\tif ((sys_root != null) &&\n\t\t\t\t((dst_root.device == sys_root.device) || (dst_root.uuid == sys_root.uuid))){\n\t\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic string restore_source_path{\n\t\towned get {\n\t\t\tif (mirror_system){\n\t\t\t\tstring source_path = \"/tmp/timeshift\";\n\t\t\t\tdir_create(source_path);\n\t\t\t\treturn source_path;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn snapshot_to_restore.path;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic string restore_target_path{\n\t\towned get {\n\t\t\tif (restore_current_system){\n\t\t\t\treturn \"/\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn mount_point_restore + \"/\";\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic string restore_log_file{\n\t\towned get {\n\t\t\treturn restore_source_path + \"/rsync-log-restore\";\n\t\t}\n\t}\n\n\tpublic string restore_exclude_file{\n\t\towned get {\n\t\t\treturn restore_source_path + \"/exclude-restore.list\";\n\t\t}\n\t}\n\n\t// restore\n\t \n\tpublic void init_mount_list(){\n\n\t\tlog_debug(\"Main: init_mount_list()\");\n\t\t\n\t\tmount_list.clear();\n\n\t\tGee.ArrayList<FsTabEntry> fstab_list = null;\n\t\tGee.ArrayList<CryptTabEntry> crypttab_list = null;\n\t\t\n\t\tif (mirror_system){\n\t\t\tstring fstab_path = \"/etc/fstab\";\n\t\t\tfstab_list = FsTabEntry.read_file(fstab_path);\n\t\t\tstring cryttab_path = \"/etc/crypttab\";\n\t\t\tcrypttab_list = CryptTabEntry.read_file(cryttab_path);\n\t\t}\n\t\telse{\n\t\t\tfstab_list = snapshot_to_restore.fstab_list;\n\t\t\tcrypttab_list = snapshot_to_restore.cryttab_list;\n\t\t}\n\n\t\tbool root_found = false;\n\t\tbool boot_found = false;\n\t\tbool home_found = false;\n\t\tdst_root = null;\n\t\t\n\t\tforeach(var fs_entry in fstab_list){\n\n\t\t\t// skip mounting for non-system devices ----------\n\t\t\t\n\t\t\tif (!fs_entry.is_for_system_directory()){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// skip mounting excluded devices -----------------------\n\t\t\t\n\t\t\tstring p1 = \"%s/*\".printf(fs_entry.mount_point);\n\t\t\tstring p2 = \"%s/**\".printf(fs_entry.mount_point);\n\t\t\tstring p3 = \"%s/***\".printf(fs_entry.mount_point);\n\t\t\t\n\t\t\tif (exclude_list_default.contains(p1) || exclude_list_user.contains(p1)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (exclude_list_default.contains(p2) || exclude_list_user.contains(p2)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (exclude_list_default.contains(p3) || exclude_list_user.contains(p3)){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// find device by name or uuid --------------------------\n\t\t\t\n\t\t\tDevice dev_fstab = null;\n\t\t\tif (fs_entry.device_uuid.length > 0){\n\t\t\t\tdev_fstab = Device.get_device_by_uuid(fs_entry.device_uuid);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdev_fstab = Device.get_device_by_name(fs_entry.device_string);\n\t\t\t}\n\n\t\t\tif (dev_fstab == null){\n\n\t\t\t\t/*\n\t\t\t\tCheck if the device mentioned in fstab entry is a mapped device.\n\t\t\t\tIf it is, then try finding the parent device which may be available on the current system.\n\t\t\t\tPrompt user to unlock it if found.\n\t\t\t\t\n\t\t\t\tNote:\n\t\t\t\tMapped name may be different on running system, or it may be same.\n\t\t\t\tSince it is not reliable, we will try to identify the parent intead of the mapped device.\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\tif (fs_entry.device_string.has_prefix(\"/dev/mapper/\")){\n\t\t\t\t\t\n\t\t\t\t\tstring mapped_name = fs_entry.device_string.replace(\"/dev/mapper/\",\"\");\n\t\t\t\t\t\n\t\t\t\t\tforeach(var crypt_entry in crypttab_list){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (crypt_entry.mapped_name == mapped_name){\n\n\t\t\t\t\t\t\t// we found the entry for the mapped device\n\t\t\t\t\t\t\tfs_entry.device_string = crypt_entry.device_string;\n\n\t\t\t\t\t\t\tif (fs_entry.device_uuid.length > 0){\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// we have the parent's uuid. get the luks device and prompt user to unlock it.\n\t\t\t\t\t\t\t\tvar dev_luks = Device.get_device_by_uuid(fs_entry.device_uuid);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (dev_luks != null){\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tstring msg_out, msg_err;\n\t\t\t\t\t\t\t\t\tvar dev_unlocked = Device.luks_unlock(\n\t\t\t\t\t\t\t\t\t\tdev_luks, \"\", \"\", parent_window, out msg_out, out msg_err);\n\n\t\t\t\t\t\t\t\t\tif (dev_unlocked != null){\n\t\t\t\t\t\t\t\t\t\tdev_fstab = dev_unlocked;\n\t\t\t\t\t\t\t\t\t\tupdate_partitions();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tdev_fstab = dev_luks; // map to parent\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t// nothing to do: we don't have the parent's uuid\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dev_fstab != null){\n\t\t\t\t\n\t\t\t\tlog_debug(\"added: dev: %s, path: %s, options: %s\".printf(\n\t\t\t\t\tdev_fstab.device, fs_entry.mount_point, fs_entry.options));\n\t\t\t\t\t\n\t\t\t\tmount_list.add(new MountEntry(dev_fstab, fs_entry.mount_point, fs_entry.options));\n\t\t\t\t\n\t\t\t\tif (fs_entry.mount_point == \"/\"){\n\t\t\t\t\tdst_root = dev_fstab;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_debug(\"missing: dev: %s, path: %s, options: %s\".printf(\n\t\t\t\t\tfs_entry.device_string, fs_entry.mount_point, fs_entry.options));\n\n\t\t\t\tmount_list.add(new MountEntry(null, fs_entry.mount_point, fs_entry.options));\n\t\t\t}\n\n\t\t\tif (fs_entry.mount_point == \"/\"){\n\t\t\t\troot_found = true;\n\t\t\t}\n\t\t\tif (fs_entry.mount_point == \"/boot\"){\n\t\t\t\tboot_found = true;\n\t\t\t}\n\t\t\tif (fs_entry.mount_point == \"/home\"){\n\t\t\t\thome_found = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!root_found){\n\t\t\tlog_debug(\"added null entry: /\");\n\t\t\tmount_list.add(new MountEntry(null, \"/\", \"\")); // add root entry\n\t\t}\n\n\t\tif (!boot_found){\n\t\t\tlog_debug(\"added null entry: /boot\");\n\t\t\tmount_list.add(new MountEntry(null, \"/boot\", \"\")); // add boot entry\n\t\t}\n\n\t\tif (!home_found){\n\t\t\tlog_debug(\"added null entry: /home\");\n\t\t\tmount_list.add(new MountEntry(null, \"/home\", \"\")); // add home entry\n\t\t}\n\n\t\t/*\n\t\tWhile cloning the system, /boot is the only mount point that\n\t\twe will leave unchanged (to avoid encrypted systems from breaking).\n\t\tAll other mounts like /home will be defaulted to target device\n\t\t(to prevent the \"cloned\" system from using the original device)\n\t\t*/\n\t\t\n\t\tif (mirror_system){\n\t\t\tdst_root = null;\n\t\t\tforeach (var entry in mount_list){\n\t\t\t\t// user should select another device\n\t\t\t\tentry.device = null; \n\t\t\t}\n\t\t}\n\n\t\tforeach(var mnt in mount_list){\n\t\t\tif (mnt.device != null){\n\t\t\t\tlog_debug(\"Entry: %s -> %s\".printf(mnt.device.device, mnt.mount_point));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_debug(\"Entry: null -> %s\".printf(mnt.mount_point));\n\t\t\t}\n\t\t}\n\n\t\t// sort - parent mountpoints will be placed above children\n\t\tmount_list.sort((a,b) => {\n\t\t\treturn strcmp(a.mount_point, b.mount_point);\n\t\t});\n\n\t\tinit_boot_options(); // boot options depend on the mount list\n\t\t\n\t\tlog_debug(\"Main: init_mount_list(): exit\");\n\t}\n\n\tpublic void init_boot_options(){\n\n\t\tvar grub_dev = dst_root;\n\t\tif(grub_dev != null){\n\t\t\tgrub_device = grub_dev.device;\n\t\t}\n\n\t\twhile ((grub_dev != null) && grub_dev.has_parent()){\n\t\t\tgrub_dev = grub_dev.parent;\n\t\t\tgrub_device = grub_dev.device;\n\t\t}\n\n\t\tif (mirror_system){\n\t\t\t// bootloader must be re-installed\n\t\t\treinstall_grub2 = true;\n\t\t\tupdate_initramfs = true;\n\t\t\tupdate_grub = true;\n\t\t}\n\t\telse{\n\t\t\tif (snapshot_to_restore.distro.dist_id == \"fedora\"){\n\t\t\t\t// grub2-install should never be run on EFI fedora systems\n\t\t\t\treinstall_grub2 = false;\n\t\t\t\tupdate_initramfs = false;\n\t\t\t\tupdate_grub = true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treinstall_grub2 = true;\n\t\t\t\tupdate_initramfs = false;\n\t\t\t\tupdate_grub = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic bool restore_snapshot(Gtk.Window? parent_win){\n\n\t\tlog_debug(\"Main: restore_snapshot()\");\n\t\t\n\t\tparent_window = parent_win;\n\n\t\t// remove mount points which will remain on root fs\n\t\t\n\t\tfor(int i = mount_list.size-1; i >= 0; i--){\n\t\t\tvar entry = mount_list[i];\n\t\t\tif (entry.device == null){\n\t\t\t\tmount_list.remove(entry);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t// check if we have all required inputs and abort on error\n\t\t\n\t\tif (!mirror_system){\n\t\t\t\n\t\t\tif (repo.device == null){\n\t\t\t\tlog_error(_(\"Backup device not specified!\"));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_msg(string.nfill(78, '*'));\n\t\t\t\tlog_msg(_(\"Backup Device\") + \": %s\".printf(repo.device.device));\n\t\t\t\tlog_msg(string.nfill(78, '*'));\n\t\t\t}\n\t\t\t\n\t\t\tif (snapshot_to_restore == null){\n\t\t\t\tlog_error(_(\"Snapshot to restore not specified!\"));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if ((snapshot_to_restore != null) && (snapshot_to_restore.marked_for_deletion)){\n\t\t\t\tlog_error(_(\"Invalid Snapshot\"));\n\t\t\t\tlog_error(_(\"Selected snapshot is marked for deletion\"));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlog_msg(string.nfill(78, '*'));\n\t\t\t\tlog_msg(\"%s: %s ~ %s\".printf(_(\"Snapshot\"), snapshot_to_restore.name, snapshot_to_restore.description));\n\t\t\t\tlog_msg(string.nfill(78, '*'));\n\t\t\t}\n\t\t}\n\t\t\n\t\t// final check - check if target root device is mounted\n\n\t\tif (btrfs_mode){\n\t\t\tif (repo.mount_paths[\"@\"].length == 0){\n\t\t\t\tlog_error(_(\"BTRFS device is not mounted\") + \": @\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (include_btrfs_home_for_restore && (repo.mount_paths[\"@home\"].length == 0)){\n\t\t\t\tlog_error(_(\"BTRFS device is not mounted\") + \": @home\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif (dst_root == null){\n\t\t\t\tlog_error(_(\"Target device not specified!\"));\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!restore_current_system){\n\t\t\t\tif (mount_point_restore.strip().length == 0){\n\t\t\t\t\tlog_error(_(\"Target device is not mounted\"));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tthread_restore_running = true;\n\t\t\tthr_success = false;\n\t\t\t\n\t\t\tif (btrfs_mode){\n\t\t\t\tThread.create<bool> (restore_execute_btrfs, true);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tThread.create<bool> (restore_execute_rsync, true);\n\t\t\t}\n\t\t}\n\t\tcatch (ThreadError e) {\n\t\t\tthread_restore_running = false;\n\t\t\tthr_success = false;\n\t\t\tlog_error (e.message);\n\t\t}\n\n\t\twhile (thread_restore_running){\n\t\t\tgtk_do_events ();\n\t\t\tThread.usleep((ulong) GLib.TimeSpan.MILLISECOND * 100);\n\t\t}\n\n\t\tif (!dry_run){\n\t\t\tsnapshot_to_restore = null;\n\t\t}\n\n\t\tlog_debug(\"Main: restore_snapshot(): exit\");\n\t\t\n\t\treturn thr_success;\n\t}\n\n\tpublic void get_restore_messages(bool formatted,\n\t\tout string msg_devices, out string msg_reboot, out string msg_disclaimer){\n\t\t\t\n\t\tstring msg = \"\";\n\n\t\tlog_debug(\"Main: get_restore_messages()\");\n\n\t\t// msg_devices -----------------------------------------\n\t\t\n\t\tif (!formatted){\n\t\t\tmsg += \"\\n%s\\n%s\\n%s\\n\".printf(\n\t\t\t\tstring.nfill(70,'='),\n\t\t\t\t_(\"Warning\").up(),\n\t\t\t\tstring.nfill(70,'=')\n\t\t\t);\n\t\t}\n\t\t\n\t\tmsg += _(\"Data will be modified on following devices:\") + \"\\n\\n\";\n\n\t\tint max_mount = _(\"Mount\").length;\n\t\tint max_dev = _(\"Device\").length;\n\n\t\tforeach(var entry in mount_list){\n\t\t\t\n\t\t\tif (entry.device == null){ continue; }\n\n\t\t\tif (btrfs_mode){\n\t\t\t\t\n\t\t\t\tif (entry.subvolume_name().length == 0){ continue; }\n\t\t\t\t\n\t\t\t\tif (!App.snapshot_to_restore.subvolumes.has_key(entry.subvolume_name())){ continue; }\n\n\t\t\t\tif ((entry.subvolume_name() == \"@home\") && !include_btrfs_home_for_restore){ continue; }\n\t\t\t}\n\t\t\t\n\t\t\tstring dev_name = entry.device.full_name_with_parent;\n\t\t\tif (entry.subvolume_name().length > 0){\n\t\t\t\tdev_name = dev_name + \"(%s)\".printf(entry.subvolume_name());\n\t\t\t}\n\t\t\telse if (entry.lvm_name().length > 0){\n\t\t\t\tdev_name = dev_name + \"(%s)\".printf(entry.lvm_name());\n\t\t\t}\n\t\t\t\n\t\t\tif (dev_name.length > max_dev){\n\t\t\t\tmax_dev = dev_name.length;\n\t\t\t}\n\t\t\tif (entry.mount_point.length > max_mount){\n\t\t\t\tmax_mount = entry.mount_point.length;\n\t\t\t}\n\t\t}\n\n\t\tvar txt = (\"%%-%ds  %%-%ds\".printf(max_dev, max_mount))\n\t\t\t.printf(_(\"Device\"),_(\"Mount\"));\n\t\ttxt += \"\\n\";\n\n\t\ttxt += string.nfill(max_dev, '-') + \"  \" + string.nfill(max_mount, '-');\n\t\ttxt += \"\\n\";\n\t\t\n\t\tforeach(var entry in mount_list){\n\t\t\t\n\t\t\tif (entry.device == null){ continue; }\n\n\t\t\tif (btrfs_mode){\n\n\t\t\t\tif (entry.subvolume_name().length == 0){ continue; }\n\t\t\t\t\n\t\t\t\tif (!App.snapshot_to_restore.subvolumes.has_key(entry.subvolume_name())){ continue; }\n\n\t\t\t\tif ((entry.subvolume_name() == \"@home\") && !include_btrfs_home_for_restore){ continue; }\n\t\t\t}\n\t\t\t\n\t\t\tstring dev_name = entry.device.full_name_with_parent;\n\t\t\tif (entry.subvolume_name().length > 0){\n\t\t\t\tdev_name = dev_name + \"(%s)\".printf(entry.subvolume_name());\n\t\t\t}\n\t\t\telse if (entry.lvm_name().length > 0){\n\t\t\t\tdev_name = dev_name + \"(%s)\".printf(entry.lvm_name());\n\t\t\t}\n\t\t\t\n\t\t\ttxt += (\"%%-%ds  %%-%ds\".printf(max_dev, max_mount)).printf(dev_name, entry.mount_point);\n\n\t\t\ttxt += \"\\n\";\n\t\t}\n\n\t\tif (formatted){\n\t\t\tmsg += \"<span size=\\\"medium\\\"><tt>%s</tt></span>\".printf(txt);\n\t\t}\n\t\telse{\n\t\t\tmsg += \"%s\\n\".printf(txt);\n\t\t}\n\n\t\tmsg_devices = msg;\n\n\t\t//msg += _(\"Files will be overwritten on the target device!\") + \"\\n\";\n\t\t//msg += _(\"If restore fails and you are unable to boot the system, then boot from the Live CD, install Timeshift, and try to restore again.\") + \"\\n\";\n\n\t\t// msg_reboot -----------------------\n\t\t\n\t\tmsg = \"\";\n\t\tif (restore_current_system){\t\n\t\t\tmsg += _(\"Please save your work and close all applications.\") + \"\\n\";\n\t\t\tmsg += _(\"System will reboot after files are restored.\");\n\t\t}\n\n\t\tmsg_reboot = msg;\n\n\t\t// msg_disclaimer --------------------------------------\n\n\t\tmsg = \"\";\n\t\tif (!formatted){\n\t\t\tmsg += \"\\n%s\\n%s\\n%s\\n\".printf(\n\t\t\t\tstring.nfill(70,'='),\n\t\t\t\t_(\"Disclaimer\").up(),\n\t\t\t\tstring.nfill(70,'=')\n\t\t\t);\n\t\t}\n\t\t\n\t\tmsg += _(\"This software comes without absolutely NO warranty and the author takes no responsibility for any damage arising from the use of this program.\");\n\t\tmsg += \" \" + _(\"If these terms are not acceptable to you, please do not proceed beyond this point!\");\n\n\t\tif (!formatted){\n\t\t\tmsg += \"\\n\";\n\t\t}\n\t\t\n\t\tmsg_disclaimer = msg;\n\n\t\t// display messages in console mode\n\t\t\n\t\tif (app_mode.length > 0){\n\t\t\tlog_msg(msg_devices);\n\t\t\tlog_msg(msg_reboot);\n\t\t\tlog_msg(msg_disclaimer);\n\t\t}\n\n\t\tlog_debug(\"Main: get_restore_messages(): exit\");\n\t}\n\n\tprivate void create_restore_scripts(out string sh_sync, out string sh_finish){\n\n\t\tlog_debug(\"Main: create_restore_scripts()\");\n\t\t\n\t\tstring sh = \"\";\n\n\t\t// create scripts --------------------------------------\n\n\t\tsh = \"\";\n\t\tsh += \"echo ''\\n\";\n\t\tif (restore_current_system){\n\t\t\tlog_debug(\"restoring current system\");\n\t\t\t\n\t\t\tsh += \"echo '\" + _(\"Please do not interrupt the restore process!\") + \"'\\n\";\n\t\t\tsh += \"echo '\" + _(\"System will reboot after files are restored\") + \"'\\n\";\n\t\t}\n\t\tsh += \"echo ''\\n\";\n\t\tsh += \"sleep 3s\\n\";\n\n\t\t// run rsync ---------------------------------------\n\n\t\tsh += \"rsync -avir --force --delete --delete-after\";\n\n\t\tif (dry_run){\n\t\t\tsh += \" --dry-run\";\n\t\t}\n\t\t\n\t\tsh += \" --log-file=\\\"%s\\\"\".printf(restore_log_file);\n\t\tsh += \" --exclude-from=\\\"%s\\\"\".printf(restore_exclude_file);\n\n\t\tif (mirror_system){\n\t\t\tsh += \" \\\"%s\\\" \\\"%s\\\" \\n\".printf(\"/\", restore_target_path);\n\t\t}\n\t\telse{\n\t\t\tsh += \" \\\"%s\\\" \\\"%s\\\" \\n\".printf(restore_source_path + \"/localhost/\", restore_target_path);\n\t\t}\n\n\t\tif (dry_run){\n\t\t\tsh_sync = sh;\n\t\t\tsh_finish = \"\";\n\t\t\treturn; // no need to continue\n\t\t}\n\n\t\tsh += \"sync \\n\"; // sync file system\n\n\t\tlog_debug(\"rsync script:\");\n\t\tlog_debug(sh);\n\n\t\tsh_sync = sh;\n\t\t\n\t\t// chroot and re-install grub2 ---------------------\n\n\t\tlog_debug(\"reinstall_grub2=%s\".printf(reinstall_grub2.to_string()));\n\t\tlog_debug(\"grub_device=%s\".printf((grub_device == null) ? \"null\" : grub_device));\n\n\t\tvar target_distro = LinuxDistro.get_dist_info(restore_target_path);\n\t\t\n\t\tsh = \"\";\n\n\t\tstring chroot = \"\";\n\t\tif (!restore_current_system){\n\t\t\t//if ((current_distro.dist_type == \"arch\") && cmd_exists(\"arch-chroot\")){\n\t\t\t\t//chroot += \"arch-chroot \\\"%s\\\"\".printf(restore_target_path);\n\t\t\t//}\n\t\t\t//else{\n\t\t\t\tchroot += \"chroot \\\"%s\\\"\".printf(restore_target_path);\n\t\t\t//}\n\n\t\t\t// bind system directories for chrooted system\n\t\t\tsh += \"for i in dev dev/pts proc run sys; do mount --bind \\\"/$i\\\" \\\"%s$i\\\"; done \\n\".printf(restore_target_path);\n\t\t}\n\n\t\tif (reinstall_grub2 && (grub_device != null) && (grub_device.length > 0)){\n\t\t\t\n\t\t\tsh += \"sync \\n\";\n\t\t\tsh += \"echo '' \\n\";\n\t\t\tsh += \"echo '\" + _(\"Re-installing GRUB2 bootloader...\") + \"' \\n\";\n\n\t\t\t// search for other operating systems\n\t\t\t//sh += \"chroot \\\"%s\\\" os-prober \\n\".printf(restore_target_path);\n\t\t\t\n\t\t\t// re-install grub ---------------\n\n\t\t\tif (target_distro.dist_type == \"redhat\"){\n\n\t\t\t\t// this will run only in clone mode\n\t\t\t\t//sh += \"%s grub2-install %s \\n\".printf(chroot, grub_device);\n\t\t\t\tsh += \"%s grub2-install --recheck --force %s \\n\".printf(chroot, grub_device);\n\n\t\t\t\t/* NOTE:\n\t\t\t\t * grub2-install should NOT be run on Fedora EFI systems \n\t\t\t\t * https://fedoraproject.org/wiki/GRUB_2\n\t\t\t\t * Instead following packages should be reinstalled:\n\t\t\t\t * dnf reinstall grub2-efi grub2-efi-modules shim\n\t\t\t\t *\n\t\t\t\t * Bootloader installation will be skipped while restoring in GUI mode.\n\t\t\t\t * Fedora seems to boot correctly even after installing new\n\t\t\t\t * kernels and restoring a snapshot with an older kernel.\n\t\t\t\t*/\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//sh += \"%s grub-install %s \\n\".printf(chroot, grub_device);\n\t\t\t\tsh += \"%s grub-install --recheck --force %s \\n\".printf(chroot, grub_device);\n\t\t\t}\n\n\t\t\t// create new grub menu\n\t\t\t//sh += \"chroot \\\"%s\\\" grub-mkconfig -o /boot/grub/grub.cfg \\n\".printf(restore_target_path);\n\t\t}\n\t\telse{\n\t\t\tlog_debug(\"skipping sh_grub: reinstall_grub2=%s, grub_device=%s\".printf(\n\t\t\t\treinstall_grub2.to_string(), (grub_device == null) ? \"null\" : grub_device));\n\t\t}\n\n\t\t// update initramfs --------------\n\n\t\tif (update_initramfs){\n\t\t\tsh += \"echo '' \\n\";\n\t\t\tsh += \"echo '\" + _(\"Generating initramfs...\") + \"' \\n\";\n\t\t\t\n\t\t\tif (target_distro.dist_type == \"redhat\"){\n\t\t\t\tsh += \"%s dracut -f -v \\n\".printf(chroot);\n\t\t\t}\n\t\t\telse if (target_distro.dist_type == \"arch\"){\n\t\t\t\tsh += \"%s mkinitcpio -p /etc/mkinitcpio.d/*.preset\\n\".printf(chroot);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsh += \"%s update-initramfs -u -k all \\n\".printf(chroot);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// update grub menu --------------\n\n\t\tif (update_grub){\n\t\t\tsh += \"echo '' \\n\";\n\t\t\tsh += \"echo '\" + _(\"Updating GRUB menu...\") + \"' \\n\";\n\t\t\t\n\t\t\tif (target_distro.dist_type == \"redhat\"){\n\t\t\t\tsh += \"%s grub2-mkconfig -o /boot/grub2/grub.cfg \\n\".printf(chroot);\n\t\t\t}\n\t\t\tif (target_distro.dist_type == \"arch\"){\n\t\t\t\tsh += \"%s grub-mkconfig -o /boot/grub/grub.cfg \\n\".printf(chroot);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsh += \"%s update-grub \\n\".printf(chroot);\n\t\t\t}\n\n\t\t\tsh += \"sync \\n\";\n\t\t\tsh += \"echo '' \\n\";\n\t\t}\n\t\t\n\t\t// sync file systems\n\t\tsh += \"echo '\" + _(\"Synching file systems...\") + \"' \\n\";\n\t\tsh += \"sync ; sleep 10s; \\n\";\n\t\tsh += \"echo '' \\n\";\n\t\t\n\t\tif (!restore_current_system){\n\t\t\t// unmount chrooted system\n\t\t\tsh += \"echo '\" + _(\"Cleaning up...\") + \"' \\n\";\n\t\t\tsh += \"for i in dev/pts dev proc run sys; do umount -f \\\"%s$i\\\"; done \\n\".printf(restore_target_path);\n\t\t\tsh += \"sync \\n\";\n\t\t}\n\n\t\tlog_debug(\"GRUB2 install script:\");\n\t\tlog_debug(sh);\n\n\t\t// reboot if required -----------------------------------\n\n\t\tif (restore_current_system){\n\t\t\tsh += \"echo '' \\n\";\n\t\t\tsh += \"echo '\" + _(\"Rebooting system...\") + \"' \\n\";\n\t\t\tsh += \"reboot -f \\n\";\n\t\t\t//sh_reboot += \"shutdown -r now \\n\";\n\t\t}\n\n\t\tsh_finish = sh;\n\t}\n\n\tprivate bool restore_current_console(string sh_sync, string sh_finish){\n\n\t\tlog_debug(\"Main: restore_current_console()\");\n\t\t\n\t\tstring script = sh_sync + sh_finish;\n\t\tint ret_val = -1;\n\t\t\n\t\tif (cmd_verbose){\n\t\t\t//current/other system, console, verbose\n\t\t\tret_val = exec_script_sync(script, null, null, false, false, false, true);\n\t\t\tlog_msg(\"\");\n\t\t}\n\t\telse{\n\t\t\t//current/other system, console, quiet\n\t\t\tstring std_out, std_err;\n\t\t\tret_val = exec_script_sync(script, out std_out, out std_err);\n\t\t\tlog_to_file(std_out);\n\t\t\tlog_to_file(std_err);\n\t\t}\n\n\t\treturn (ret_val == 0);\n\t}\n\n\tprivate bool restore_current_gui(string sh_sync, string sh_finish){\n\n\t\tlog_debug(\"Main: restore_current_gui()\");\n\t\t\n\t\tstring script = sh_sync + sh_finish;\n\t\tstring temp_script = save_bash_script_temp(script);\n\n\t\tvar dlg = new TerminalWindow.with_parent(parent_window);\n\t\tdlg.execute_script(temp_script, true);\n\n\t\treturn true;\n\t}\n\n\tprivate bool restore_other_console(string sh_sync, string sh_finish){\n\n\t\tlog_debug(\"Main: restore_other_console()\");\n\t\t\n\t\t// execute sh_sync --------------------\n\t\t\n\t\tstring script = sh_sync;\n\t\tint ret_val = -1;\n\t\t\n\t\tif (cmd_verbose){\n\t\t\tret_val = exec_script_sync(script, null, null, false, false, false, true);\n\t\t\tlog_msg(\"\");\n\t\t}\n\t\telse{\n\t\t\tstring std_out, std_err;\n\t\t\tret_val = exec_script_sync(script, out std_out, out std_err);\n\t\t\tlog_to_file(std_out);\n\t\t\tlog_to_file(std_err);\n\t\t}\n\n\t\t// update files -------------------\n\t\t\n\t\tfix_fstab_file(restore_target_path);\n\t\tfix_crypttab_file(restore_target_path);\n\n\t\tprogress_text = _(\"Parsing log file...\");\n\t\tlog_msg(progress_text);\n\t\tvar task = new RsyncTask();\n\t\ttask.parse_log(restore_log_file);\n\n\t\t// execute sh_finish --------------------\n\n\t\tlog_debug(\"executing sh_finish: \");\n\t\tlog_debug(sh_finish);\n\t\t\n\t\tscript = sh_finish;\n\n\t\tif (cmd_verbose){\n\t\t\tret_val = exec_script_sync(script, null, null, false, false, false, true);\n\t\t\tlog_msg(\"\");\n\t\t}\n\t\telse{\n\t\t\tstring std_out, std_err;\n\t\t\tret_val = exec_script_sync(script, out std_out, out std_err);\n\t\t\tlog_to_file(std_out);\n\t\t\tlog_to_file(std_err);\n\t\t}\n\n\t\treturn (ret_val == 0);\n\t}\n\n\tprivate bool restore_other_gui(string sh_sync, string sh_finish){\n\n\t\tlog_debug(\"Main: restore_other_gui()\");\n\t\t\n\t\tprogress_text = _(\"Building file list...\");\n\n\t\ttask = new RsyncTask();\n\t\ttask.relative = false;\n\t\ttask.verbose = true;\n\t\ttask.delete_extra = true;\n\t\ttask.delete_excluded = false;\n\t\ttask.delete_after = true;\n\n\t\ttask.dry_run = dry_run;\n\t\n\t\tif (mirror_system){\n\t\t\ttask.source_path = \"/\";\n\t\t}\n\t\telse{\n\t\t\ttask.source_path = path_combine(snapshot_to_restore.path, \"localhost\");\n\t\t}\n\n\t\ttask.dest_path = restore_target_path;\n\t\t\n\t\ttask.exclude_from_file = restore_exclude_file;\n\n\t\ttask.rsync_log_file = restore_log_file;\n\n\t\tif ((snapshot_to_restore != null) && (snapshot_to_restore.file_count > 0)){\n\t\t\ttask.prg_count_total = snapshot_to_restore.file_count;\n\t\t}\n\t\telse if (Main.first_snapshot_count > 0){\n\t\t\ttask.prg_count_total = Main.first_snapshot_count;\n\t\t}\n\t\telse{\n\t\t\ttask.prg_count_total = 500000;\n\t\t}\n\n\t\ttask.execute();\n\n\t\twhile (task.status == AppStatus.RUNNING){\n\t\t\tsleep(1000);\n\n\t\t\tif (task.status_line.length > 0){\n\n\t\t\t\tif (dry_run){\n\t\t\t\t\tprogress_text = _(\"Comparing files with rsync...\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tprogress_text = _(\"Synching files with rsync...\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tgtk_do_events();\n\t\t}\n\n\t\tif (dry_run){\n\t\t\treturn true; // no need to continue\n\t\t}\n\n\t\t// update files after sync --------------------\n\n\t\tfix_fstab_file(restore_target_path);\n\t\tfix_crypttab_file(restore_target_path);\n\n\t\tprogress_text = _(\"Parsing log file...\");\n\t\tlog_msg(progress_text);\n\t\tvar task = new RsyncTask();\n\t\ttask.parse_log(restore_log_file);\n\n\t\t// execute sh_finish ------------\n\n\t\tif (reinstall_grub2 || update_initramfs || update_grub){\n\t\t\tprogress_text = _(\"Updating bootloader configuration...\");\n\t\t}\n\n\t\tlog_debug(\"executing sh_finish: \");\n\t\tlog_debug(sh_finish);\n\t\t\n\t\tint ret_val = exec_script_sync(sh_finish, null, null, false, false, false, true);\n\n\t\tlog_debug(\"script exit code: %d\".printf(ret_val));\n\n\t\treturn (ret_val == 0);\n\t}\n\n\tprivate void fix_fstab_file(string target_path){\n\n\t\tlog_debug(\"Main: fix_fstab_file()\");\n\t\t\n\t\tstring fstab_path = path_combine(target_path, \"etc/fstab\");\n\n\t\tif (!file_exists(fstab_path)){\n\t\t\tlog_debug(\"File not found: %s\".printf(fstab_path));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar fstab_list = FsTabEntry.read_file(fstab_path);\n\n\t\tlog_debug(\"updating entries (1/2)...\");\n\t\t\n\t\tforeach(var mnt in mount_list){\n\t\t\t// find existing\n\t\t\tvar entry = FsTabEntry.find_entry_by_mount_point(fstab_list, mnt.mount_point);\n\n\t\t\t// add if missing\n\t\t\tif (entry == null){\n\t\t\t\tentry = new FsTabEntry();\n\t\t\t\tentry.mount_point = mnt.mount_point;\n\t\t\t\tfstab_list.add(entry);\n\t\t\t}\n\n\t\t\t//update fstab entry\n\t\t\tentry.device_string = \"UUID=%s\".printf(mnt.device.uuid);\n\t\t\tentry.type = mnt.device.fstype;\n\n\t\t\t// fix mount options for non-btrfs device\n\t\t\tif (mnt.device.fstype != \"btrfs\"){\n\t\t\t\t// remove subvol option\n\t\t\t\tentry.remove_option(\"subvol=%s\".printf(entry.subvolume_name()));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Remove fstab entries for any system directories that\n\t\t * the user has not explicitly mapped before restore/clone\n\t\t * This ensures that the cloned/restored system does not mount\n\t\t * any devices to system paths that the user has not explicitly specified\n\t\t * */\n\n\t\tlog_debug(\"updating entries(2/2)...\");\n\t\t\n\t\tfor(int i = fstab_list.size - 1; i >= 0; i--){\n\t\t\tvar entry = fstab_list[i];\n\t\t\t\n\t\t\tif (!entry.is_for_system_directory()){ continue; }\n\t\t\t\n\t\t\tvar mnt = MountEntry.find_entry_by_mount_point(mount_list, entry.mount_point);\n\t\t\tif (mnt == null){\n\t\t\t\tfstab_list.remove(entry);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// write the updated file\n\n\t\tlog_debug(\"writing updated file...\");\n\n\t\tFsTabEntry.write_file(fstab_list, fstab_path, false);\n\n\t\tlog_msg(_(\"Updated /etc/fstab on target device\") + \": %s\".printf(fstab_path));\n\n\t\t// create directories on disk for mount points in /etc/fstab\n\n\t\tforeach(var entry in fstab_list){\n\t\t\tif (entry.mount_point.length == 0){ continue; }\n\t\t\tif (!entry.mount_point.has_prefix(\"/\")){ continue; }\n\t\t\t\n\t\t\tstring mount_path = path_combine(\n\t\t\t\ttarget_path, entry.mount_point);\n\t\t\t\t\n\t\t\tif (entry.is_comment\n\t\t\t\t|| entry.is_empty_line\n\t\t\t\t|| (mount_path.length == 0)){\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!dir_exists(mount_path)){\n\t\t\t\t\n\t\t\t\tlog_msg(\"Created mount point on target device: %s\".printf(\n\t\t\t\t\tentry.mount_point));\n\t\t\t\t\t\n\t\t\t\tdir_create(mount_path);\n\t\t\t}\n\t\t}\n\n\t\tlog_debug(\"Main: fix_fstab_file(): exit\");\n\t}\n\n\tprivate void fix_crypttab_file(string target_path){\n\n\t\tlog_debug(\"Main: fix_crypttab_file()\");\n\t\t\n\t\tstring crypttab_path = path_combine(target_path, \"etc/crypttab\");\n\n\t\tif (!file_exists(crypttab_path)){\n\t\t\tlog_debug(\"File not found: %s\".printf(crypttab_path));\n\t\t\treturn;\n\t\t}\n\n\t\tvar crypttab_list = CryptTabEntry.read_file(crypttab_path);\n\t\t\n\t\t// add option \"nofail\" to existing entries\n\n\t\tlog_debug(\"checking for 'nofail' option...\");\n\t\t\n\t\tforeach(var entry in crypttab_list){\n\t\t\tentry.append_option(\"nofail\");\n\t\t}\n\n\t\tlog_debug(\"updating entries...\");\n\n\t\t// check and add entries for mapped devices which are encrypted\n\t\t\n\t\tforeach(var mnt in mount_list){\n\t\t\tif ((mnt.device != null) && (mnt.device.parent != null) && (mnt.device.is_on_encrypted_partition())){\n\t\t\t\t\n\t\t\t\t// find existing\n\t\t\t\tvar entry = CryptTabEntry.find_entry_by_uuid(\n\t\t\t\t\tcrypttab_list, mnt.device.parent.uuid);\n\n\t\t\t\t// add if missing\n\t\t\t\tif (entry == null){\n\t\t\t\t\tentry = new CryptTabEntry();\n\t\t\t\t\tcrypttab_list.add(entry);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// set custom values\n\t\t\t\tentry.device_uuid = mnt.device.parent.uuid;\n\t\t\t\tentry.mapped_name = \"luks-%s\".printf(mnt.device.parent.uuid);\n\t\t\t\tentry.keyfile = \"none\";\n\t\t\t\tentry.options = \"luks,nofail\";\n\t\t\t}\n\t\t}\n\n\t\tlog_debug(\"writing updated file...\");\n\n\t\tCryptTabEntry.write_file(crypttab_list, crypttab_path, false);\n\n\t\tlog_msg(_(\"Updated /etc/crypttab on target device\") + \": %s\".printf(crypttab_path));\n\n\t\tlog_debug(\"Main: fix_crypttab_file(): exit\");\n\t}\n\n\tprivate void check_and_repair_filesystems(){\n\t\t\n\t\tif (!restore_current_system){\n\t\t\tstring sh_fsck = \"echo '\" + _(\"Checking file systems for errors...\") + \"' \\n\";\n\t\t\tforeach(var mnt in mount_list){\n\t\t\t\tif (mnt.device != null) {\n\t\t\t\t\tsh_fsck += \"fsck -y %s \\n\".printf(mnt.device.device);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsh_fsck += \"echo '' \\n\";\n\t\t\tint ret_val = exec_script_sync(sh_fsck, null, null, false, false, false, true);\n\t\t}\n\t}\n\n\tpublic bool restore_execute_rsync(){\n\t\t\n\t\tlog_debug(\"Main: restore_execute_rsync()\");\n\n\t\ttry{\n\t\t\tlog_debug(\"source_path=%s\".printf(restore_source_path));\n\t\t\tlog_debug(\"target_path=%s\".printf(restore_target_path));\n\t\t\t\n\t\t\tstring sh_sync, sh_finish;\n\t\t\tcreate_restore_scripts(out sh_sync, out sh_finish);\n\t\t\t\n\t\t\tsave_exclude_list_for_restore(restore_source_path);\n\n\t\t\tfile_delete(restore_log_file);\n\t\t\tfile_delete(restore_log_file + \"-changes\");\n\t\t\tfile_delete(restore_log_file + \".gz\");\n\t\t\t\n\t\t\tif (restore_current_system){\n\t\t\t\tstring control_file_path = path_combine(snapshot_to_restore.path,\".sync-restore\");\n\n\t\t\t\tvar f = File.new_for_path(control_file_path);\n\t\t\t\tif(f.query_exists()){\n\t\t\t\t\tf.delete(); //delete existing file\n\t\t\t\t}\n\n\t\t\t\tfile_write(control_file_path, snapshot_to_restore.path); //save snapshot name\n\t\t\t}\n\n\t\t\t// run the scripts --------------------\n\t\t\n\t\t\tif (snapshot_to_restore != null){\n\t\t\t\tif (dry_run){\n\t\t\t\t\tlog_msg(_(\"Comparing Files (Dry Run)...\"));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlog_msg(_(\"Restoring snapshot...\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_msg(_(\"Cloning system...\"));\n\t\t\t}\n\n\t\t\tprogress_text = _(\"Synching files with rsync...\");\n\t\t\tlog_msg(progress_text);\n\n\t\t\tbool ok = true;\n\t\t\t\n\t\t\tif (app_mode == \"\"){ // GUI\n\t\t\t\tif (!restore_current_system || dry_run){\n\t\t\t\t\tok = restore_other_gui(sh_sync, sh_finish);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tok = restore_current_gui(sh_sync, sh_finish);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (restore_current_system){\n\t\t\t\t\tok = restore_current_console(sh_sync, sh_finish);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tok = restore_other_console(sh_sync, sh_finish);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!dry_run){\n\n\t\t\t\tlog_msg(_(\"Restore completed\"));\n\t\t\t\tthr_success = true;\n\n\t\t\t\tlog_msg(string.nfill(78, '-'));\n\n\t\t\t\tunmount_target_device(false);\n\n\t\t\t\tcheck_and_repair_filesystems();\n\t\t\t}\n\t\t}\n\t\tcatch(Error e){\n\t\t\tlog_error (e.message);\n\t\t\tthr_success = false;\n\t\t}\n\n\t\tthread_restore_running = false;\n\t\treturn thr_success;\n\t}\n\t\n\tpublic bool restore_execute_btrfs(){\n\n\t\tlog_debug(\"Main: restore_execute_btrfs()\");\n\t\t\n\t\tbool ok = create_pre_restore_snapshot_btrfs();\n\n\t\tlog_msg(string.nfill(78, '-'));\n\t\t\n\t\tif (!ok){\n\t\t\tthread_restore_running = false;\n\t\t\tthr_success = false;\n\t\t\treturn thr_success;\n\t\t}\n\t\t\n\t\t// restore snapshot subvolumes by creating new subvolume snapshots\n\n\t\tforeach(var subvol in snapshot_to_restore.subvolumes.values){\n\n\t\t\tif ((subvol.name == \"@home\") && !include_btrfs_home_for_restore){ continue; }\n\t\t\t\n\t\t\tsubvol.restore();\n\t\t}\n\n\t\tlog_msg(_(\"Restore completed\"));\n\t\tthr_success = true;\n\t\t\n\t\tif (restore_current_system){\n\t\t\tlog_msg(_(\"Snapshot will become active after system is rebooted.\"));\n\t\t}\n\n\t\tlog_msg(string.nfill(78, '-'));\n\n\t\tquery_subvolume_quotas();\n\n\t\tthread_restore_running = false;\n\t\treturn thr_success;\n\t}\n\n\tpublic bool create_pre_restore_snapshot_btrfs(){\n\n\t\tlog_debug(\"Main: create_pre_restore_snapshot_btrfs()\");\n\t\t\n\t\tstring cmd, std_out, std_err;\n\t\tDateTime dt_created = new DateTime.now_local();\n\t\tstring time_stamp = dt_created.format(\"%Y-%m-%d_%H-%M-%S\");\n\t\tstring snapshot_name = time_stamp;\n\t\tstring snapshot_path = \"\";\n\t\t\n\t\t/* Note:\n\t\t * The @ and @home subvolumes need to be backed-up only if they are in use by the system.\n\t\t * If user restores a snapshot and then tries to restore another snapshot before the next reboot\n\t\t * then the @ and @home subvolumes are the ones that were previously restored and need to be deleted.\n\t\t * */\n\n\t\tbool create_pre_restore_backup = false;\n\n\t\tif (restore_current_system){\n\t\t\t\n\t\t\t// check for an existing pre-restore backup\n\n\t\t\tSnapshot snap_prev = null;\n\t\t\tbool found = false;\n\t\t\tforeach(var bak in repo.snapshots){\n\t\t\t\tif (bak.live){\n\t\t\t\t\tfound = true;\n\t\t\t\t\tsnap_prev = bak;\n\t\t\t\t\tlog_msg(_(\"Found existing pre-restore snapshot\") + \": %s\".printf(bak.name));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (found){\n\t\t\t\t//delete system subvolumes\n\t\t\t\tif (sys_subvolumes.has_key(\"@\") && snapshot_to_restore.subvolumes.has_key(\"@\")){\n\t\t\t\t\tsys_subvolumes[\"@\"].remove();\n\t\t\t\t\tlog_msg(_(\"Deleted subvolume\") + \": @\");\n\t\t\t\t}\n\t\t\t\tif (include_btrfs_home_for_restore && sys_subvolumes.has_key(\"@home\") && snapshot_to_restore.subvolumes.has_key(\"@home\")){\n\t\t\t\t\tsys_subvolumes[\"@home\"].remove();\n\t\t\t\t\tlog_msg(_(\"Deleted subvolume\") + \": @home\");\n\t\t\t\t}\n\n\t\t\t\t//update description for pre-restore backup\n\t\t\t\tsnap_prev.description = \"Before restoring '%s'\".printf(snapshot_to_restore.date_formatted);\n\t\t\t\tsnap_prev.update_control_file();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcreate_pre_restore_backup = true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tcreate_pre_restore_backup = true;\n\t\t}\n\n\t\tif (create_pre_restore_backup){\n\n\t\t\tlog_msg(_(\"Creating pre-restore snapshot from system subvolumes...\"));\n\t\t\t\n\t\t\tdir_create(snapshot_path);\n\n\t\t\t// move subvolumes ----------------\n\t\t\t\n\t\t\tbool no_subvolumes_found = true;\n\n\t\t\tvar subvol_list = new Gee.ArrayList<Subvolume>();\n\n\t\t\tvar subvol_names = new string[] { \"@\" };\n\t\t\tif (include_btrfs_home_for_restore){\n\t\t\t\tsubvol_names = new string[] { \"@\",\"@home\" };\n\t\t\t}\n\t\t\t\n\t\t\tforeach(string subvol_name in subvol_names){\n\n\t\t\t\tsnapshot_path = path_combine(repo.mount_paths[subvol_name], \"timeshift-btrfs/snapshots/%s\".printf(snapshot_name));\n\t\t\t\tdir_create(snapshot_path, true);\n\t\t\t\n\t\t\t\tstring src_path = path_combine(repo.mount_paths[subvol_name], subvol_name);\n\t\t\t\tif (!dir_exists(src_path)){\n\t\t\t\t\tlog_error(_(\"Could not find system subvolume\") + \": %s\".printf(subvol_name));\n\t\t\t\t\tdir_delete(snapshot_path);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tno_subvolumes_found = false;\n\n\t\t\t\tstring dst_path = path_combine(snapshot_path, subvol_name);\n\t\t\t\tcmd = \"mv '%s' '%s'\".printf(src_path, dst_path);\n\t\t\t\tlog_debug(cmd);\n\t\t\t\t\n\t\t\t\tint status = exec_sync(cmd, out std_out, out std_err);\n\t\t\t\t\n\t\t\t\tif (status != 0){\n\t\t\t\t\tlog_error (std_err);\n\t\t\t\t\tlog_error(_(\"Failed to move system subvolume to snapshot directory\") + \": %s\".printf(subvol_name));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvar subvol_dev = (subvol_name == \"@\") ? repo.device : repo.device_home;\n\t\t\t\t\tsubvol_list.add(new Subvolume(subvol_name, dst_path, subvol_dev.uuid, repo));\n\t\t\t\t\t\n\t\t\t\t\tlog_msg(_(\"Moved system subvolume to snapshot directory\") + \": %s\".printf(subvol_name));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (no_subvolumes_found){\n\t\t\t\t//could not find system subvolumes for backing up(!)\n\t\t\t\tlog_error(_(\"Could not find system subvolumes for creating pre-restore snapshot\"));\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// write control file -----------\n\n\t\t\t\tsnapshot_path = path_combine(repo.mount_paths[\"@\"], \"timeshift-btrfs/snapshots/%s\".printf(snapshot_name));\n\t\t\t\t\n\t\t\t\tvar snap = Snapshot.write_control_file(\n\t\t\t\t\tsnapshot_path, dt_created, repo.device.uuid,\n\t\t\t\t\tLinuxDistro.get_dist_info(path_combine(snapshot_path,\"@\")).full_name(),\n\t\t\t\t\t\"ondemand\", \"\", 0, true, false, repo);\n\n\t\t\t\tsnap.description = \"Before restoring '%s'\".printf(snapshot_to_restore.date_formatted);\n\t\t\t\tsnap.live = true;\n\t\t\t\t\n\t\t\t\t// write subvolume info\n\t\t\t\tforeach(var subvol in subvol_list){\n\t\t\t\t\tsnap.subvolumes.set(subvol.name, subvol);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsnap.update_control_file(); // save subvolume info\n\n\t\t\t\tlog_msg(_(\"Created pre-restore snapshot\") + \": %s\".printf(snap.name));\n\t\t\t\t\n\t\t\t\trepo.load_snapshots();\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\t\n\t//app config\n\n\tpublic void save_app_config(){\n\n\t\tlog_debug(\"Main: save_app_config()\");\n\t\t\n\t\tvar config = new Json.Object();\n\t\t\n\t\tif ((repo != null) && repo.available()){\n\t\t\t// save backup device uuid\n\t\t\tconfig.set_string_member(\"backup_device_uuid\",\n\t\t\t\t(repo.device == null) ? \"\" : repo.device.uuid);\n\t\t\t\n\t\t\t// save parent uuid if backup device has parent\n\t\t\tconfig.set_string_member(\"parent_device_uuid\",\n\t\t\t\t(repo.device.has_parent()) ? repo.device.parent.uuid : \"\");\n\t\t}\n\t\telse{\n\t\t\t// retain values for next run\n\t\t\tconfig.set_string_member(\"backup_device_uuid\", backup_uuid);\n\t\t\tconfig.set_string_member(\"parent_device_uuid\", backup_parent_uuid); \n\t\t}\n\n\t\tconfig.set_string_member(\"do_first_run\", false.to_string());\n\t\tconfig.set_string_member(\"btrfs_mode\", btrfs_mode.to_string());\n\t\tconfig.set_string_member(\"include_btrfs_home_for_backup\", include_btrfs_home_for_backup.to_string());\n\t\tconfig.set_string_member(\"include_btrfs_home_for_restore\", include_btrfs_home_for_restore.to_string());\n\t\tconfig.set_string_member(\"stop_cron_emails\", stop_cron_emails.to_string());\n\t\tconfig.set_string_member(\"btrfs_use_qgroup\", btrfs_use_qgroup.to_string());\n\n\t\tconfig.set_string_member(\"schedule_monthly\", schedule_monthly.to_string());\n\t\tconfig.set_string_member(\"schedule_weekly\", schedule_weekly.to_string());\n\t\tconfig.set_string_member(\"schedule_daily\", schedule_daily.to_string());\n\t\tconfig.set_string_member(\"schedule_hourly\", schedule_hourly.to_string());\n\t\tconfig.set_string_member(\"schedule_boot\", schedule_boot.to_string());\n\n\t\tconfig.set_string_member(\"count_monthly\", count_monthly.to_string());\n\t\tconfig.set_string_member(\"count_weekly\", count_weekly.to_string());\n\t\tconfig.set_string_member(\"count_daily\", count_daily.to_string());\n\t\tconfig.set_string_member(\"count_hourly\", count_hourly.to_string());\n\t\tconfig.set_string_member(\"count_boot\", count_boot.to_string());\n\n\t\tconfig.set_string_member(\"snapshot_size\", first_snapshot_size.to_string());\n\t\tconfig.set_string_member(\"snapshot_count\", first_snapshot_count.to_string());\n\n\t\tconfig.set_string_member(\"date_format\", date_format);\n\t\t\n\t\tJson.Array arr = new Json.Array();\n\t\tforeach(string path in exclude_list_user){\n\t\t\tarr.add_string_element(path);\n\t\t}\n\t\tconfig.set_array_member(\"exclude\",arr);\n\n\t\tarr = new Json.Array();\n\t\tforeach(var name in exclude_app_names){\n\t\t\tarr.add_string_element(name);\n\t\t}\n\t\tconfig.set_array_member(\"exclude-apps\",arr);\n\n\t\tvar json = new Json.Generator();\n\t\tjson.pretty = true;\n\t\tjson.indent = 2;\n\t\tvar node = new Json.Node(NodeType.OBJECT);\n\t\tnode.set_object(config);\n\t\tjson.set_root(node);\n\n\t\ttry{\n\t\t\tjson.to_file(this.app_conf_path);\n\t\t} catch (Error e) {\n\t        log_error (e.message);\n\t    }\n\n\t    if ((app_mode == \"\")||(LOG_DEBUG)){\n\t\t\tlog_msg(_(\"App config saved\") + \": %s\".printf(this.app_conf_path));\n\t\t}\n\t}\n\n\tpublic void load_app_config(){\n\n\t\tlog_debug(\"Main: load_app_config()\");\n\n\t\t// check if first run -----------------------\n\t\t\n\t\tvar f = File.new_for_path(this.app_conf_path);\n\t\tif (!f.query_exists()) {\n\t\t\tfile_copy(app_conf_path_default, app_conf_path);\n\t\t}\n\t\tif (!f.query_exists()) {\n\t\t\tset_first_run_flag();\n\t\t\treturn;\n\t\t}\n\n\t\t// load settings from config file --------------------------\n\t\t\n\t\tvar parser = new Json.Parser();\n        try{\n\t\t\tparser.load_from_file(this.app_conf_path);\n\t\t} catch (Error e) {\n\t        log_error (e.message);\n\t    }\n        var node = parser.get_root();\n        var config = node.get_object();\n\n\t\tbool do_first_run = json_get_bool(config, \"do_first_run\", false); // false as default\n\t\t\n\t\tif (do_first_run){\n\t\t\tset_first_run_flag();\n\t\t}\n\n\t\tbtrfs_mode = json_get_bool(config, \"btrfs_mode\", false); // false as default\n\n\t\tif (config.has_member(\"include_btrfs_home\")){\n\t\t\tinclude_btrfs_home_for_backup = json_get_bool(config, \"include_btrfs_home\", include_btrfs_home_for_backup);\n\t\t}\n\t\telse{\n\t\t\tinclude_btrfs_home_for_backup = json_get_bool(config, \"include_btrfs_home_for_backup\", include_btrfs_home_for_backup);\n\t\t}\n\t\t\n\t\tinclude_btrfs_home_for_restore = json_get_bool(config, \"include_btrfs_home_for_restore\", include_btrfs_home_for_restore);\n\t\tstop_cron_emails = json_get_bool(config, \"stop_cron_emails\", stop_cron_emails);\n\t\tbtrfs_use_qgroup = json_get_bool(config, \"btrfs_use_qgroup\", btrfs_use_qgroup);\n\t\t\n\t\tif (cmd_btrfs_mode != null){\n\t\t\tbtrfs_mode = cmd_btrfs_mode; //override\n\t\t}\n\t\t\n\t\tbackup_uuid = json_get_string(config,\"backup_device_uuid\", backup_uuid);\n\t\tbackup_parent_uuid = json_get_string(config,\"parent_device_uuid\", backup_parent_uuid);\n\t\t\n        this.schedule_monthly = json_get_bool(config,\"schedule_monthly\",schedule_monthly);\n\t\tthis.schedule_weekly = json_get_bool(config,\"schedule_weekly\",schedule_weekly);\n\t\tthis.schedule_daily = json_get_bool(config,\"schedule_daily\",schedule_daily);\n\t\tthis.schedule_hourly = json_get_bool(config,\"schedule_hourly\",schedule_hourly);\n\t\tthis.schedule_boot = json_get_bool(config,\"schedule_boot\",schedule_boot);\n\n\t\tthis.count_monthly = json_get_int(config,\"count_monthly\",count_monthly);\n\t\tthis.count_weekly = json_get_int(config,\"count_weekly\",count_weekly);\n\t\tthis.count_daily = json_get_int(config,\"count_daily\",count_daily);\n\t\tthis.count_hourly = json_get_int(config,\"count_hourly\",count_hourly);\n\t\tthis.count_boot = json_get_int(config,\"count_boot\",count_boot);\n\n\t\tthis.date_format = json_get_string(config, \"date_format\", date_format_default);\n\n\t\tMain.first_snapshot_size = json_get_uint64(config,\"snapshot_size\", Main.first_snapshot_size);\n\t\t\t\n\t\tMain.first_snapshot_count = (int64) json_get_uint64(config,\"snapshot_count\", Main.first_snapshot_count);\n\t\t\n\t\texclude_list_user.clear();\n\t\t\n\t\tif (config.has_member (\"exclude\")){\n\t\t\tforeach (Json.Node jnode in config.get_array_member (\"exclude\").get_elements()) {\n\t\t\t\t\n\t\t\t\tstring path = jnode.get_string();\n\t\t\t\t\n\t\t\t\tif (!exclude_list_user.contains(path)\n\t\t\t\t\t&& !exclude_list_default.contains(path)\n\t\t\t\t\t&& !exclude_list_home.contains(path)){\n\t\t\t\t\t\t\n\t\t\t\t\texclude_list_user.add(path);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\texclude_app_names.clear();\n\n\t\tif (config.has_member (\"exclude-apps\")){\n\t\t\tvar apps = config.get_array_member(\"exclude-apps\");\n\t\t\tforeach (Json.Node jnode in apps.get_elements()) {\n\t\t\t\t\n\t\t\t\tstring name = jnode.get_string();\n\t\t\t\t\n\t\t\t\tif (!exclude_app_names.contains(name)){\n\t\t\t\t\texclude_app_names.add(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((app_mode == \"\")||(LOG_DEBUG)){\n\t\t\tlog_msg(_(\"App config loaded\") + \": %s\".printf(this.app_conf_path));\n\t\t}\n\t}\n\n\tpublic void set_first_run_flag(){\n\t\t\n\t\tfirst_run = true;\n\t\t\n\t\tlog_msg(\"First run mode (config file not found)\");\n\n\t\t// load some defaults for first-run based on user's system type\n\t\t\n\t\tbool supported = sys_subvolumes.has_key(\"@\") && cmd_exists(\"btrfs\"); // && sys_subvolumes.has_key(\"@home\")\n\t\tif (supported || (cmd_btrfs_mode == true)){\n\t\t\tlog_msg(_(\"Selected default snapshot type\") + \": %s\".printf(\"BTRFS\"));\n\t\t\tbtrfs_mode = true;\n\t\t}\n\t\telse{\n\t\t\tlog_msg(_(\"Selected default snapshot type\") + \": %s\".printf(\"RSYNC\"));\n\t\t\tbtrfs_mode = false;\n\t\t}\n\t}\n\t\n\tpublic void initialize_repo(){\n\n\t\tlog_debug(\"Main: initialize_repo()\");\n\t\t\n\t\tlog_debug(\"backup_uuid=%s\".printf(backup_uuid));\n\t\tlog_debug(\"backup_parent_uuid=%s\".printf(backup_parent_uuid));\n\n\t\t// use system disk as snapshot device in btrfs mode for backup\n\t\tif (((app_mode == \"backup\")||((app_mode == \"ondemand\"))) && btrfs_mode){\n\t\t\tif (sys_root != null){\n\t\t\t\tlog_msg(\"Using system disk as snapshot device for creating snapshots in BTRFS mode\");\n\t\t\t\tif (cmd_backup_device.length > 0){\n\t\t\t\t\tlog_msg(_(\"Option --snapshot-device should not be specified for creating snapshots in BTRFS mode\"));\n\t\t\t\t}\n\t\t\t\trepo = new SnapshotRepo.from_device(sys_root, parent_window, btrfs_mode);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_error(\"System disk not found!\");\n\t\t\t\texit_app(1);\n\t\t\t}\n\t\t}\n\t\t// initialize repo using command line parameter if specified\n\t\telse if (cmd_backup_device.length > 0){\n\t\t\tvar cmd_dev = Device.get_device_by_name(cmd_backup_device);\n\t\t\tif (cmd_dev != null){\n\t\t\t\tlog_debug(\"Using snapshot device specified as command argument: %s\".printf(cmd_backup_device));\n\t\t\t\trepo = new SnapshotRepo.from_device(cmd_dev, parent_window, btrfs_mode);\n\t\t\t\t// TODO: move this code to main window\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_error(_(\"Device not found\") + \": '%s'\".printf(cmd_backup_device));\n\t\t\t\texit_app(1);\n\t\t\t}\n\t\t}\n\t\t// select default device for first run mode\n\t\telse if (first_run && (backup_uuid.length == 0)){\n\t\t\t\n\t\t\ttry_select_default_device_for_backup(parent_window);\n\n\t\t\tif ((repo != null) && (repo.device != null)){\n\t\t\t\tlog_msg(_(\"Selected default snapshot device\") + \": %s\".printf(repo.device.device));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlog_debug(\"Setting snapshot device from config file\");\n\t\t\t\n\t\t\t// find devices from uuid\n\t\t\tDevice dev = null;\n\t\t\tDevice dev_parent = null;\n\t\t\tif (backup_uuid.length > 0){\n\t\t\t\tdev = Device.get_device_by_uuid(backup_uuid);\n\t\t\t}\n\t\t\tif (backup_parent_uuid.length > 0){\n\t\t\t\tdev_parent = Device.get_device_by_uuid(backup_parent_uuid);\n\t\t\t}\n\n\t\t\t// try unlocking encrypted parent\n\t\t\tif ((dev_parent != null) && dev_parent.is_encrypted_partition() && !dev_parent.has_children()){\n\t\t\t\tlog_debug(\"Snapshot device is on an encrypted partition\");\n\t\t\t\trepo = new SnapshotRepo.from_uuid(backup_parent_uuid, parent_window, btrfs_mode);\n\t\t\t}\n\t\t\t// try device\t\n\t\t\telse if (dev != null){\n\t\t\t\tlog_debug(\"repo: creating from uuid\");\n\t\t\t\trepo = new SnapshotRepo.from_uuid(backup_uuid, parent_window, btrfs_mode);\n\t\t\t}\n\t\t\t// try system disk\n\t\t\t/*else {\n\t\t\t\tlog_debug(\"Could not find device with UUID\" + \": %s\".printf(backup_uuid));\n\t\t\t\tif (sys_root != null){\n\t\t\t\t\tlog_debug(\"Using system disk as snapshot device\");\n\t\t\t\t\trepo = new SnapshotRepo.from_device(sys_root, parent_window, btrfs_mode);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlog_debug(\"System disk not found\");\n\t\t\t\t\trepo = new SnapshotRepo.from_null();\n\t\t\t\t}\n\t\t\t}*/\n\t\t}\n\n\t\t/* Note: In command-line mode, user will be prompted for backup device */\n\n\t\t/* The backup device specified in config file will be mounted at this point if:\n\t\t * 1) app is running in GUI mode, OR\n\t\t * 2) app is running command mode without backup device argument\n\t\t * */\n\n\t\t log_debug(\"Main: initialize_repo(): exit\");\n\t}\n\t\n\t//core functions\n\n\tpublic void update_partitions(){\n\n\t\tlog_debug(\"update_partitions()\");\n\t\t\n\t\tpartitions.clear();\n\t\t\n\t\tpartitions = Device.get_filesystems();\n\n\t\tforeach(var pi in partitions){\n\n\t\t\t// sys_root and sys_home will be detected by detect_system_devices()\n\t\t\tif ((repo != null) && (repo.device != null) && (pi.uuid == repo.device.uuid)){\n\t\t\t\trepo.device = pi;\n\t\t\t}\n\t\t\t\n\t\t\tif (pi.is_mounted){\n\t\t\t\tpi.dist_info = LinuxDistro.get_dist_info(pi.mount_points[0].mount_point).full_name();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (partitions.size == 0){\n\t\t\tlog_error(\"ts: \" + _(\"Failed to get partition list.\"));\n\t\t}\n\n\t\tlog_debug(\"partition list updated\");\n\t}\n\n\tpublic void detect_system_devices(){\n\n\t\tlog_debug(\"detect_system_devices()\");\n\n\t\tsys_root = null;\n\t\tsys_boot = null;\n\t\tsys_efi = null;\n\t\tsys_home = null;\n\n\t\tforeach(var pi in partitions){\n\t\t\t\n\t\t\tforeach(var mp in pi.mount_points){\n\t\t\t\t\n\t\t\t\t// skip loop devices - Fedora Live uses loop devices containing ext4-formatted lvm volumes\n\t\t\t\tif ((pi.type == \"loop\") || (pi.has_parent() && (pi.parent.type == \"loop\"))){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (mp.mount_point == \"/\"){\n\t\t\t\t\tsys_root = pi;\n\t\t\t\t\tif ((app_mode == \"\")||(LOG_DEBUG)){\n\t\t\t\t\t\tstring txt = _(\"/ is mapped to device\") + \": %s, UUID=%s\".printf(pi.device,pi.uuid);\n\t\t\t\t\t\tif (mp.subvolume_name().length > 0){\n\t\t\t\t\t\t\ttxt += \", subvol=%s\".printf(mp.subvolume_name());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlog_debug(txt);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (mp.mount_point == \"/home\"){\n\t\t\t\t\tsys_home = pi;\n\t\t\t\t\tif ((app_mode == \"\")||(LOG_DEBUG)){\n\t\t\t\t\t\tstring txt = _(\"/home is mapped to device\") + \": %s, UUID=%s\".printf(pi.device,pi.uuid);\n\t\t\t\t\t\tif (mp.subvolume_name().length > 0){\n\t\t\t\t\t\t\ttxt += \", subvol=%s\".printf(mp.subvolume_name());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlog_debug(txt);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (mp.mount_point == \"/boot\"){\n\t\t\t\t\tsys_boot = pi;\n\t\t\t\t\tif ((app_mode == \"\")||(LOG_DEBUG)){\n\t\t\t\t\t\tstring txt = _(\"/boot is mapped to device\") + \": %s, UUID=%s\".printf(pi.device,pi.uuid);\n\t\t\t\t\t\tif (mp.subvolume_name().length > 0){\n\t\t\t\t\t\t\ttxt += \", subvol=%s\".printf(mp.subvolume_name());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlog_debug(txt);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (mp.mount_point == \"/boot/efi\"){\n\t\t\t\t\tsys_efi = pi;\n\t\t\t\t\tif ((app_mode == \"\")||(LOG_DEBUG)){\n\t\t\t\t\t\tstring txt = _(\"/boot/efi is mapped to device\") + \": %s, UUID=%s\".printf(pi.device,pi.uuid);\n\t\t\t\t\t\tif (mp.subvolume_name().length > 0){\n\t\t\t\t\t\t\ttxt += \", subvol=%s\".printf(mp.subvolume_name());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlog_debug(txt);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tsys_subvolumes = Subvolume.detect_subvolumes_for_system_by_path(\"/\", null, parent_window);\n\t}\n\n\tpublic bool mount_target_devices(Gtk.Window? parent_win = null){\n\t\t/* Note:\n\t\t * Target device will be mounted explicitly to /mnt/timeshift/restore\n\t\t * Existing mount points are not used since we need to mount other devices in sub-directories\n\t\t * */\n\n\t\tlog_debug(\"mount_target_device()\");\n\t\t\n\t\tif (dst_root == null){\n\t\t\treturn false;\n\t\t}\n\t\n\t\t//check and create restore mount point for restore\n\t\tmount_point_restore = mount_point_app + \"/restore\";\n\t\tdir_create(mount_point_restore);\n\n\t\t/*var already_mounted = false;\n\t\tvar dev_mounted = Device.get_device_by_path(mount_point_restore);\n\t\tif ((dev_mounted != null)\n\t\t\t&& (dev_mounted.uuid == dst_root.uuid)){\n\n\t\t\tforeach(var mp in dev_mounted.mount_points){\n\t\t\t\tif ((mp.mount_point == mount_point_restore)\n\t\t\t\t\t&& (mp.mount_options == \"subvol=@\")){\n\t\t\t\t\t\t\n\t\t\t\t\t = true;\n\t\t\t\t\treturn; //already_mounted\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\t\n\t\t// unmount\n\t\tunmount_target_device();\n\n\t\t// mount root device\n\t\tif (dst_root.fstype == \"btrfs\"){\n\n\t\t\t//check subvolume layout\n\n\t\t\tbool supported = check_btrfs_layout(dst_root, dst_home, false);\n\t\t\t\n\t\t\tif (!supported && snapshot_to_restore.has_subvolumes()){\n\t\t\t\tstring msg = _(\"The target partition has an unsupported subvolume layout.\") + \"\\n\";\n\t\t\t\tmsg += _(\"Only ubuntu-type layouts with @ and @home subvolumes are currently supported.\");\n\n\t\t\t\tif (app_mode == \"\"){\n\t\t\t\t\tstring title = _(\"Unsupported Subvolume Layout\");\n\t\t\t\t\tgtk_messagebox(title, msg, null, true);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlog_error(\"\\n\" + msg);\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// mount all devices\n\t\tforeach (var mnt in mount_list) {\n\n\t\t\tif (mnt.device == null){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// unlock encrypted device\n\t\t\tif (mnt.device.is_encrypted_partition()){\n\n\t\t\t\t// check if unlocked\n\t\t\t\tif (mnt.device.has_children()){\n\t\t\t\t\tmnt.device = mnt.device.children[0];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// prompt user\n\t\t\t\t\tstring msg_out, msg_err;\n\t\t\t\n\t\t\t\t\tvar dev_unlocked = Device.luks_unlock(\n\t\t\t\t\t\tmnt.device, \"\", \"\", parent_win, out msg_out, out msg_err);\n\n\t\t\t\t\t//exit if not found\n\t\t\t\t\tif (dev_unlocked == null){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tmnt.device = dev_unlocked;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring mount_options = \"\";\n\t\t\t\n\t\t\tif (mnt.device.fstype == \"btrfs\"){\n\t\t\t\tif (mnt.mount_point == \"/\"){\n\t\t\t\t\tmount_options = \"subvol=@\";\n\t\t\t\t}\n\t\t\t\tif (include_btrfs_home_for_restore){\n\t\t\t\t\tif (mnt.mount_point == \"/home\"){\n\t\t\t\t\t\tmount_options = \"subvol=@home\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!Device.mount(mnt.device.uuid, mount_point_restore + mnt.mount_point, mount_options)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic void unmount_target_device(bool exit_on_error = true){\n\t\t\n\t\tif (mount_point_restore == null) { return; }\n\n\t\tlog_debug(\"unmount_target_device()\");\n\t\t\n\t\t//unmount the target device only if it was mounted by application\n\t\tif (mount_point_restore.has_prefix(mount_point_app)){   //always true\n\t\t\tunmount_device(mount_point_restore, exit_on_error);\n\t\t}\n\t\telse{\n\t\t\t//don't unmount\n\t\t}\n\t}\n\n\tpublic bool unmount_device(string mount_point, bool exit_on_error = true){\n\t\tbool is_unmounted = Device.unmount(mount_point);\n\t\tif (!is_unmounted){\n\t\t\tif (exit_on_error){\n\t\t\t\tif (app_mode == \"\"){\n\t\t\t\t\tstring title = _(\"Critical Error\");\n\t\t\t\t\tstring msg = _(\"Failed to unmount device!\") + \"\\n\" + _(\"Application will exit\");\n\t\t\t\t\tgtk_messagebox(title, msg, null, true);\n\t\t\t\t}\n\t\t\t\texit_app(1);\n\t\t\t}\n\t\t}\n\t\treturn is_unmounted;\n\t}\n\n\tpublic SnapshotLocationStatus check_backup_location(out string message, out string details){\n\t\trepo.check_status();\n\t\tmessage = repo.status_message;\n\t\tdetails = repo.status_details;\n\t\treturn repo.status_code;\n\t}\n\n\tpublic bool check_btrfs_volume(Device dev, string subvol_names, bool unlock){\n\n\t\tlog_debug(\"check_btrfs_volume():%s\".printf(subvol_names));\n\t\t\n\t\tstring mnt_btrfs = mount_point_app + \"/btrfs\";\n\t\tdir_create(mnt_btrfs);\n\n\t\tif (!dev.is_mounted_at_path(\"\", mnt_btrfs)){\n\t\t\t\n\t\t\tDevice.unmount(mnt_btrfs);\n\n\t\t\t// unlock encrypted device\n\t\t\tif (dev.is_encrypted_partition()){\n\n\t\t\t\tif (unlock){\n\t\t\t\t\t\n\t\t\t\t\tstring msg_out, msg_err;\n\t\t\t\t\tvar dev_unlocked = Device.luks_unlock(\n\t\t\t\t\t\tdev, \"\", \"\", parent_window, out msg_out, out msg_err);\n\t\t\t\t\n\t\t\t\t\tif (dev_unlocked == null){\n\t\t\t\t\t\tlog_debug(\"device is null\");\n\t\t\t\t\t\tlog_debug(\"SnapshotRepo: check_btrfs_volume(): exit\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tDevice.mount(dev_unlocked.uuid, mnt_btrfs, \"\", true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tDevice.mount(dev.uuid, mnt_btrfs, \"\", true);\n\t\t\t}\n\t\t}\n\n\t\tbool supported = true;\n\n\t\tforeach(string subvol_name in subvol_names.split(\",\")){\n\t\t\tsupported = supported && dir_exists(path_combine(mnt_btrfs,subvol_name));\n\t\t}\n\n\t\tif (Device.unmount(mnt_btrfs)){\n\t\t\tif (dir_exists(mnt_btrfs) && (dir_count(mnt_btrfs) == 0)){\n\t\t\t\tdir_delete(mnt_btrfs);\n\t\t\t\tlog_debug(_(\"Removed mount directory: '%s'\").printf(mnt_btrfs));\n\t\t\t}\n\t\t}\n\n\t\treturn supported;\n\t}\n\n\tpublic void try_select_default_device_for_backup(Gtk.Window? parent_win){\n\n\t\tlog_debug(\"try_select_default_device_for_backup()\");\n\n\t\t// check if currently selected device can be used\n\t\tif (repo.available()){\n\t\t\tif (check_device_for_backup(repo.device, false)){\n\t\t\t\tif (repo.btrfs_mode != btrfs_mode){\n\t\t\t\t\t// reinitialize\n\t\t\t\t\trepo = new SnapshotRepo.from_device(repo.device, parent_win, btrfs_mode);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse{\n\t\t\t\trepo = new SnapshotRepo.from_null();\n\t\t\t}\n\t\t}\n\t\t\n\t\tupdate_partitions();\n\n\t\t// In BTRFS mode, select the system disk if system disk is BTRFS\n\t\tif (btrfs_mode && sys_subvolumes.has_key(\"@\")){\n\t\t\tvar subvol_root = sys_subvolumes[\"@\"];\n\t\t\trepo = new SnapshotRepo.from_device(subvol_root.get_device(), parent_win, btrfs_mode);\n\t\t\treturn;\n\t\t}\n\t\t\t\n\t\tforeach(var dev in partitions){\n\t\t\tif (check_device_for_backup(dev, false)){\n\t\t\t\trepo = new SnapshotRepo.from_device(dev, parent_win, btrfs_mode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic bool check_device_for_backup(Device dev, bool unlock){\n\t\tbool ok = false;\n\n\t\tif (dev.type == \"disk\") { return false; }\n\t\tif (dev.has_children()) { return false; }\n\t\t\n\t\tif (btrfs_mode && ((dev.fstype == \"btrfs\")||(dev.fstype == \"luks\"))){\n\t\t\tif (check_btrfs_volume(dev, \"@\", unlock)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse if (!btrfs_mode && dev.has_linux_filesystem()){\n\t\t\t// TODO: check free space\n\t\t\treturn true;\n\t\t}\n\n\t\treturn ok;\n\t}\n\t\n\tpublic uint64 estimate_system_size(){\n\n\t\tlog_debug(\"estimate_system_size()\");\n\t\t\n\t\tif (Main.first_snapshot_size > 0){\n\t\t\treturn Main.first_snapshot_size;\n\t\t}\n\t\telse if (live_system()){\n\t\t\treturn 0;\n\t\t}\n\n\t\ttry {\n\t\t\tthread_estimate_running = true;\n\t\t\tthr_success = false;\n\t\t\tThread.create<void> (estimate_system_size_thread, true);\n\t\t} catch (ThreadError e) {\n\t\t\tthread_estimate_running = false;\n\t\t\tthr_success = false;\n\t\t\tlog_error (e.message);\n\t\t}\n\n\t\twhile (thread_estimate_running){\n\t\t\tgtk_do_events ();\n\t\t\tThread.usleep((ulong) GLib.TimeSpan.MILLISECOND * 100);\n\t\t}\n\n\t\tsave_app_config();\n\n\t\tlog_debug(\"estimate_system_size(): ok\");\n\t\t\n\t\treturn Main.first_snapshot_size;\n\t}\n\n\tpublic void estimate_system_size_thread(){\n\t\tthread_estimate_running = true;\n\n\t\tstring cmd = \"\";\n\t\tstring std_out;\n\t\tstring std_err;\n\t\tint ret_val;\n\t\tuint64 required_space = 0;\n\t\tint64 file_count = 0;\n\n\t\ttry{\n\n\t\t\tlog_debug(\"Using temp dir '%s'\".printf(TEMP_DIR));\n\n\t\t\tstring file_exclude_list = path_combine(TEMP_DIR, \"exclude.list\");\n\t\t\tvar f = File.new_for_path(file_exclude_list);\n\t\t\tif (f.query_exists()){\n\t\t\t\tf.delete();\n\t\t\t}\n\n\t\t\tstring file_log = path_combine(TEMP_DIR, \"rsync.log\");\n\t\t\tf = File.new_for_path(file_log);\n\t\t\tif (f.query_exists()){\n\t\t\t\tf.delete();\n\t\t\t}\n\n\t\t\tstring dir_empty = path_combine(TEMP_DIR, \"empty\");\n\t\t\tf = File.new_for_path(dir_empty);\n\t\t\tif (!f.query_exists()){\n\t\t\t\tdir_create(dir_empty);\n\t\t\t}\n\n\t\t\tsave_exclude_list_for_backup(TEMP_DIR);\n\t\t\t\n\t\t\tcmd  = \"LC_ALL=C ; rsync -ai --delete --numeric-ids --relative --stats --dry-run --delete-excluded --exclude-from='%s' /. '%s' &> '%s'\".printf(file_exclude_list, dir_empty, file_log);\n\n\t\t\tlog_debug(cmd);\n\t\t\tret_val = exec_script_sync(cmd, out std_out, out std_err);\n\n\t\t\tif (file_exists(file_log)){\n\t\t\t\tcmd = \"cat '%s' | awk '/Total file size/ {print $4}'\".printf(file_log);\n\t\t\t\tret_val = exec_script_sync(cmd, out std_out, out std_err);\n\t\t\t\tif (ret_val == 0){\n\t\t\t\t\trequired_space = long.parse(std_out.replace(\",\",\"\").strip());\n\n\t\t\t\t\tcmd = \"wc -l '%s'\".printf(escape_single_quote(file_log));\n\t\t\t\t\tret_val = exec_script_sync(cmd, out std_out, out std_err);\n\t\t\t\t\tif (ret_val == 0){\n\t\t\t\t\t\tfile_count = long.parse(std_out.split(\" \")[0].strip());\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthr_success = true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlog_error (_(\"Failed to estimate system size\"));\n\t\t\t\t\tlog_error (std_err);\n\t\t\t\t\tthr_success = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_error (_(\"Failed to estimate system size\"));\n\t\t\t\tlog_error (std_err);\n\t\t\t\tlog_error (std_out);\n\t\t\t\tthr_success = false;\n\t\t\t}\n\t\t}\n\t\tcatch(Error e){\n\t\t\tlog_error (e.message);\n\t\t\tthr_success = false;\n\t\t}\n\n\t\tif ((required_space == 0) && (sys_root != null)){\n\t\t\trequired_space = sys_root.used_bytes;\n\t\t}\n\n\t\tMain.first_snapshot_size = required_space;\n\t\tMain.first_snapshot_count = file_count;\n\n\t\tlog_debug(\"First snapshot size: %s\".printf(format_file_size(required_space)));\n\t\tlog_debug(\"File count: %lld\".printf(first_snapshot_count));\n\n\t\tthread_estimate_running = false;\n\t}\n\n\t// btrfs\n\n\tpublic void query_subvolume_info(SnapshotRepo parent_repo){\n\n\t\t// SnapshotRepo contructor calls this code in load_snapshots()\n\t\t// save the new object reference to repo since repo still holds previous object\n\t\trepo = parent_repo;\n\n\t\t// TODO: move query_subvolume_info() and related methods to SnapshotRepo\n\t\t\n\t\tif ((repo == null) || !repo.btrfs_mode){\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlog_debug(_(\"Querying subvolume info...\"));\n\t\t\n\t\ttry {\n\t\t\tthread_subvol_info_running = true;\n\t\t\tthread_subvol_info_success = false;\n\t\t\tThread.create<void> (query_subvolume_info_thread, true);\n\t\t} catch (ThreadError e) {\n\t\t\tthread_subvol_info_running = false;\n\t\t\tthread_subvol_info_success = false;\n\t\t\tlog_error (e.message);\n\t\t}\n\n\t\twhile (thread_subvol_info_running){\n\t\t\tgtk_do_events ();\n\t\t\tThread.usleep((ulong) GLib.TimeSpan.MILLISECOND * 100);\n\t\t}\n\n\t\tlog_debug(_(\"Query completed\"));\n\t}\n\n\tpublic void query_subvolume_info_thread(){\n\t\t\n\t\tthread_subvol_info_running = true;\n\n\t\t//query IDs\n\t\tbool ok = query_subvolume_ids();\n\t\t\n\t\tif (!ok){\n\t\t\tthread_subvol_info_success = false;\n\t\t\tthread_subvol_info_running = false;\n\t\t\treturn;\n\t\t}\n\n\t\t//query quota\n\t\tok = query_subvolume_quotas();\n\t\t\n\t\tif (!ok){\n\n\t\t\tif (btrfs_use_qgroup){\n\t\t\t\t\n\t\t\t\t//try enabling quota\n\t\t\t\tok = enable_subvolume_quotas();\n\t\t\t\tif (!ok){\n\t\t\t\t\tthread_subvol_info_success = false;\n\t\t\t\t\tthread_subvol_info_running = false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//query quota again\n\t\t\t\tok = query_subvolume_quotas();\n\t\t\t\tif (!ok){\n\t\t\t\t\tthread_subvol_info_success = false;\n\t\t\t\t\tthread_subvol_info_running = false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthread_subvol_info_success = true;\n\t\tthread_subvol_info_running = false;\n\t\treturn;\n\t}\n\n\tpublic bool query_subvolume_ids(){\n\t\tbool ok = query_subvolume_id(\"@\");\n\t\tif ((repo.device_home != null) && (repo.device.uuid != repo.device_home.uuid)){\n\t\t\tok = ok && query_subvolume_id(\"@home\");\n\t\t}\n\t\treturn ok;\n\t}\n\t\n\tpublic bool query_subvolume_id(string subvol_name){\n\n\t\tlog_debug(\"query_subvolume_id():%s\".printf(subvol_name));\n\t\t\n\t\tstring cmd = \"\";\n\t\tstring std_out;\n\t\tstring std_err;\n\t\tint ret_val;\n\n\t\tcmd = \"btrfs subvolume list '%s'\".printf(repo.mount_paths[subvol_name]);\n\t\tlog_debug(cmd);\n\t\tret_val = exec_sync(cmd, out std_out, out std_err);\n\t\tif (ret_val != 0){\n\t\t\tlog_error (std_err);\n\t\t\tlog_error(_(\"btrfs returned an error\") + \": %d\".printf(ret_val));\n\t\t\tlog_error(_(\"Failed to query subvolume list\"));\n\t\t\treturn false;\n\t\t}\n\n\t\t/* Sample Output:\n\t\t *\n\t\tID 257 gen 56 top level 5 path timeshift-btrfs/snapshots/2014-09-26_23-34-08/@\n\t\tID 258 gen 52 top level 5 path timeshift-btrfs/snapshots/2014-09-26_23-34-08/@home\n\t\t* */\n\n\t\tforeach(string line in std_out.split(\"\\n\")){\n\t\t\tif (line == null) { continue; }\n\n\t\t\tstring[] parts = line.split(\" \");\n\t\t\tif (parts.length < 2) { continue; }\n\n\t\t\tSubvolume subvol = null;\n\n\t\t\tif ((sys_subvolumes.size > 0) && line.has_suffix(sys_subvolumes[\"@\"].path.replace(repo.mount_paths[\"@\"] + \"/\",\" \"))){\n\t\t\t\tsubvol = sys_subvolumes[\"@\"];\n\t\t\t}\n\t\t\telse if ((sys_subvolumes.size > 0)\n\t\t\t\t&& sys_subvolumes.has_key(\"@home\")\n\t\t\t\t&& line.has_suffix(sys_subvolumes[\"@home\"].path.replace(repo.mount_paths[\"@home\"] + \"/\",\" \"))){\n\t\t\t\t\t\n\t\t\t\tsubvol = sys_subvolumes[\"@home\"];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tforeach(var bak in repo.snapshots){\n\t\t\t\t\tforeach(var sub in bak.subvolumes.values){\n\t\t\t\t\t\tif (line.has_suffix(sub.path.replace(repo.mount_paths[sub.name] + \"/\",\"\"))){\n\t\t\t\t\t\t\tsubvol = sub;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (subvol != null){\n\t\t\t\tsubvol.id = long.parse(parts[1]);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic bool query_subvolume_quotas(){\n\n\t\tbool ok = query_subvolume_quota(\"@\");\n\t\tif (repo.device.uuid != repo.device_home.uuid){\n\t\t\tok = ok && query_subvolume_quota(\"@home\");\n\t\t}\n\t\treturn ok;\n\t}\n\t\n\tpublic bool query_subvolume_quota(string subvol_name){\n\n\t\tlog_debug(\"query_subvolume_quota():%s\".printf(subvol_name));\n\t\t\n\t\tstring cmd = \"\";\n\t\tstring std_out;\n\t\tstring std_err;\n\t\tint ret_val;\n\n\t\tstring options = use_option_raw ? \"--raw\" : \"\";\n\t\t\n\t\tcmd = \"btrfs qgroup show %s '%s'\".printf(options, repo.mount_paths[subvol_name]);\n\t\tlog_debug(cmd);\n\t\tret_val = exec_sync(cmd, out std_out, out std_err);\n\t\t\n\t\tif (ret_val != 0){\n\t\t\t\n\t\t\tif (use_option_raw){\n\t\t\t\tuse_option_raw = false;\n\n\t\t\t\t// try again without --raw option\n\t\t\t\tcmd = \"btrfs qgroup show '%s'\".printf(repo.mount_paths[subvol_name]);\n\t\t\t\tlog_debug(cmd);\n\t\t\t\tret_val = exec_sync(cmd, out std_out, out std_err);\n\t\t\t}\t\n\t\t\t\n\t\t\tif (ret_val != 0){\n\t\t\t\tlog_error (std_err);\n\t\t\t\tlog_error(_(\"btrfs returned an error\") + \": %d\".printf(ret_val));\n\t\t\t\tlog_error(_(\"Failed to query subvolume quota\"));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t/* Sample Output:\n\t\t *\n\t\tqgroupid rfer       excl\n\t\t-------- ----       ----\n\t\t0/5      106496     106496\n\t\t0/257    3825262592 557056\n\t\t0/258    12689408   49152\n\t\t * */\n\n\t\tforeach(string line in std_out.split(\"\\n\")){\n\t\t\tif (line == null) { continue; }\n\n\t\t\tstring[] parts = line.split(\" \");\n\t\t\tif (parts.length < 3) { continue; }\n\t\t\tif (parts[0].split(\"/\").length < 2) { continue; }\n\n\t\t\tint subvol_id = int.parse(parts[0].split(\"/\")[1]);\n\n\t\t\tSubvolume subvol = null;\n\n\t\t\tif ((sys_subvolumes.size > 0) && (sys_subvolumes[\"@\"].id == subvol_id)){\n\t\t\t\t\n\t\t\t\tsubvol = sys_subvolumes[\"@\"];\n\t\t\t}\n\t\t\telse if ((sys_subvolumes.size > 0)\n\t\t\t\t&& sys_subvolumes.has_key(\"@home\")\n\t\t\t\t&& (sys_subvolumes[\"@home\"].id == subvol_id)){\n\t\t\t\t\t\n\t\t\t\tsubvol = sys_subvolumes[\"@home\"];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tforeach(var bak in repo.snapshots){\n\t\t\t\t\tforeach(var sub in bak.subvolumes.values){\n\t\t\t\t\t\tif (sub.id == subvol_id){\n\t\t\t\t\t\t\tsubvol = sub;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (subvol != null){\n\t\t\t\tint part_num = -1;\n\t\t\t\tforeach(string part in parts){\n\t\t\t\t\tif (part.strip().length > 0){\n\t\t\t\t\t\tpart_num ++;\n\t\t\t\t\t\tswitch (part_num){\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tsubvol.total_bytes = int64.parse(part);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tsubvol.unshared_bytes = int64.parse(part);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t//ignore\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tforeach(var bak in repo.snapshots){\n\t\t\tbak.update_control_file();\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic bool enable_subvolume_quotas(){\n\n\t\tif (!btrfs_use_qgroup){ return false; }\n\t\t\n\t\tbool ok = enable_subvolume_quota(\"@\");\n\t\t\n\t\tif (repo.device.uuid != repo.device_home.uuid){\n\t\t\tok = ok && enable_subvolume_quota(\"@home\");\n\t\t}\n\t\tif (ok){\n\t\t\tlog_msg(_(\"Enabled subvolume quota support\"));\n\t\t}\n\t\t\n\t\treturn ok;\n\t}\n\t\n\tpublic bool enable_subvolume_quota(string subvol_name){\n\n\t\tif (!btrfs_use_qgroup){ return false; }\n\t\t\n\t\tlog_debug(\"enable_subvolume_quota():%s\".printf(subvol_name));\n\t\t\n\t\tstring cmd = \"\";\n\t\tstring std_out;\n\t\tstring std_err;\n\t\tint ret_val;\n\n\t\tcmd = \"btrfs quota enable '%s'\".printf(repo.mount_paths[subvol_name]);\n\t\tlog_debug(cmd);\n\t\t\n\t\tret_val = exec_sync(cmd, out std_out, out std_err);\n\t\t\n\t\tif (ret_val != 0){\n\t\t\tlog_error (std_err);\n\t\t\tlog_error(_(\"btrfs returned an error\") + \": %d\".printf(ret_val));\n\t\t\tlog_error(_(\"Failed to enable subvolume quota\"));\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic bool rescan_subvolume_quotas(){\n\t\t\n\t\tbool ok = rescan_subvolume_quota(\"@\");\n\t\t\n\t\tif (repo.device.uuid != repo.device_home.uuid){\n\t\t\tok = ok && rescan_subvolume_quota(\"@home\");\n\t\t}\n\t\tif (ok){\n\t\t\tlog_msg(_(\"Enabled subvolume quota support\"));\n\t\t}\n\t\t\n\t\treturn ok;\n\t}\n\t\n\tpublic bool rescan_subvolume_quota(string subvol_name){\n\n\t\tlog_debug(\"rescan_subvolume_quota():%s\".printf(subvol_name));\n\t\t\n\t\tstring cmd = \"\";\n\t\tstring std_out;\n\t\tstring std_err;\n\t\tint ret_val;\n\n\t\tcmd = \"btrfs quota rescan '%s'\".printf(repo.mount_paths[subvol_name]);\n\t\tlog_debug(cmd);\n\t\t\n\t\tret_val = exec_sync(cmd, out std_out, out std_err);\n\t\t\n\t\tif (ret_val != 0){\n\t\t\t\n\t\t\tlog_error (std_err);\n\t\t\tlog_error(_(\"btrfs returned an error\") + \": %d\".printf(ret_val));\n\t\t\tlog_error(_(\"Failed to rescan subvolume quota\"));\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t// cron jobs\n\n\tpublic void cron_job_update(){\n\t\t\n\t\tif (live_system()) { return; }\n\n\t\t// remove entries created by previous versions -----------\n\t\t\n\t\tstring entry = \"timeshift --backup\";\n\n\t\tint count = 0;\n\t\twhile (CronTab.has_job(entry, true, false)){\n\t\t\t\n\t\t\tCronTab.remove_job(entry, true, true);\n\t\t\t\n\t\t\tif (++count == 100){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tentry = \"timeshift-btrfs --backup\";\n\n\t\tcount = 0;\n\t\twhile (CronTab.has_job(entry, true, false)){\n\t\t\t\n\t\t\tCronTab.remove_job(entry, true, true);\n\t\t\t\n\t\t\tif (++count == 100){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tCronTab.remove_script_file(\"timeshift-hourly\", \"hourly\");\n\t\t\t\n\t\t// start update ---------------------------\n\t\t\n\t\tif (scheduled){\n\t\t\t\n\t\t\t//hourly\n\t\t\tCronTab.add_script_file(\"timeshift-hourly\", \"d\", \"0 * * * * root timeshift --check --scripted\", stop_cron_emails);\n\t\t\t\n\t\t\t//boot\n\t\t\tif (schedule_boot){\n\t\t\t\tCronTab.add_script_file(\"timeshift-boot\", \"d\", \"@reboot root sleep 10m && timeshift --create --scripted --tags B\", stop_cron_emails);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tCronTab.remove_script_file(\"timeshift-boot\", \"d\");\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tCronTab.remove_script_file(\"timeshift-hourly\", \"d\");\n\t\t\tCronTab.remove_script_file(\"timeshift-boot\", \"d\");\n\t\t}\n\t}\n\t\n\t// cleanup\n\n\tpublic void clean_logs(){\n\n\t\tlog_debug(\"clean_logs()\");\n\t\t\n\t\tGee.ArrayList<string> list = new Gee.ArrayList<string>();\n\n\t\ttry{\n\t\t\tvar dir = File.new_for_path (log_dir);\n\t\t\tvar enumerator = dir.enumerate_children (\"*\", 0);\n\n\t\t\tvar info = enumerator.next_file ();\n\t\t\tstring path;\n\n\t\t\twhile (info != null) {\n\t\t\t\tif (info.get_file_type() == FileType.REGULAR) {\n\t\t\t\t\tpath = log_dir + \"/\" + info.get_name();\n\t\t\t\t\tif (path != log_file) {\n\t\t\t\t\t\tlist.add(path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinfo = enumerator.next_file ();\n\t\t\t}\n\n\t\t\tCompareDataFunc<string> compare_func = (a, b) => {\n\t\t\t\treturn strcmp(a,b);\n\t\t\t};\n\n\t\t\tlist.sort((owned) compare_func);\n\n\t\t\tif (list.size > 500){\n\n\t\t\t\t// delete oldest 100 files ---------------\n\n\t\t\t\tfor(int k = 0; k < 100; k++){\n\t\t\t\t\t\n\t\t\t\t\tvar file = File.new_for_path (list[k]);\n\t\t\t\t\t \n\t\t\t\t\tif (file.query_exists()){ \n\t\t\t\t\t\tfile.delete();\n\t\t\t\t\t\tlog_msg(\"%s: %s\".printf(_(\"Removed\"), list[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n            \n\t\t\t\tlog_msg(_(\"Older log files removed\"));\n\t\t\t}\n\t\t}\n\t\tcatch(Error e){\n\t\t\tlog_error (e.message);\n\t\t}\n\t}\n\n\tpublic void exit_app (int exit_code = 0){\n\n\t\tlog_debug(\"exit_app()\");\n\t\t\n\t\tif (app_mode == \"\"){\n\t\t\t//update app config only in GUI mode\n\t\t\tsave_app_config();\n\t\t}\n\n\t\tcron_job_update();\n\n\t\tunmount_target_device(false);\n\n\t\tclean_logs();\n\n\t\tapp_lock.remove();\n\n\t\texit(exit_code);\n\n\t\t//Gtk.main_quit ();\n\t}\n}\n\n\n\n\n", "\n/*\n * TeeJee.FileSystem.vala\n *\n * Copyright 2012-2018 Tony George <teejeetech@gmail.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n * MA 02110-1301, USA.\n *\n *\n */\n \nnamespace TeeJee.FileSystem{\n\n\t/* Convenience functions for handling files and directories */\n\n\tusing TeeJee.Logging;\n\tusing TeeJee.ProcessHelper;\n\tusing TeeJee.Misc;\n\n\n\tpublic const int64 KB = 1000;\n\tpublic const int64 MB = 1000 * KB;\n\tpublic const int64 GB = 1000 * MB;\n\tpublic const int64 TB = 1000 * GB;\n\tpublic const int64 KiB = 1024;\n\tpublic const int64 MiB = 1024 * KiB;\n\tpublic const int64 GiB = 1024 * MiB;\n\tpublic const int64 TiB = 1024 * GiB;\n\t\n\t// path helpers ----------------------------\n\t\n\tpublic string file_parent(string file_path){\n\t\treturn File.new_for_path(file_path).get_parent().get_path();\n\t}\n\n\tpublic string file_basename(string file_path){\n\t\treturn File.new_for_path(file_path).get_basename();\n\t}\n\n\tpublic string path_combine(string path1, string path2){\n\t\treturn GLib.Path.build_path(\"/\", path1, path2);\n\t}\n\n\tpublic string remove_trailing_slash(string path){\n\t\tif (path.has_suffix(\"/\")){\n\t\t\treturn path[0:path.length - 1];\n\t\t}\n\t\telse{\n\t\t\treturn path;\n\t\t}\n\t}\n\t\n\t// file helpers -----------------------------\n\n\tpublic bool file_or_dir_exists(string item_path){\n\t\t\n\t\t/* check if item exists on disk*/\n\n\t\tvar item = File.parse_name(item_path);\n\t\treturn item.query_exists();\n\t}\n\t\n\tpublic bool file_exists (string file_path){\n\t\t/* Check if file exists */\n\t\treturn (FileUtils.test(file_path, GLib.FileTest.EXISTS)\n\t\t\t&& !FileUtils.test(file_path, GLib.FileTest.IS_DIR));\n\t}\n\n\tpublic bool file_exists_regular (string file_path){\n\t\t/* Check if file exists */\n\t\treturn ( FileUtils.test(file_path, GLib.FileTest.EXISTS)\n\t\t&& FileUtils.test(file_path, GLib.FileTest.IS_REGULAR));\n\t}\n\n\tpublic bool file_delete(string file_path){\n\n\t\t/* Check and delete file */\n\n\t\ttry {\n\t\t\tvar file = File.new_for_path (file_path);\n\t\t\tif (file.query_exists ()) {\n\t\t\t\tfile.delete ();\n\t\t\t}\n\t\t\treturn true;\n\t\t} catch (Error e) {\n\t        log_error (e.message);\n\t        log_error(_(\"Failed to delete file\") + \": %s\".printf(file_path));\n\t        return false;\n\t    }\n\t}\n\n\tpublic bool file_move_to_trash(string file_path){\n\n\t\t/* Check and delete file */\n\n\t\tvar file = File.new_for_path (file_path);\n\t\tif (file.query_exists ()) {\n\t\t\tPosix.system(\"gvfs-trash '%s'\".printf(escape_single_quote(file_path)));\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic bool file_shred(string file_path){\n\n\t\t/* Check and delete file */\n\n\t\tvar file = File.new_for_path (file_path);\n\t\tif (file.query_exists ()) {\n\t\t\tPosix.system(\"shred -u '%s'\".printf(escape_single_quote(file_path)));\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic int64 file_line_count (string file_path){\n\t\t/* Count number of lines in text file */\n\t\tstring cmd = \"wc -l '%s'\".printf(escape_single_quote(file_path));\n\t\tstring std_out, std_err;\n\t\texec_sync(cmd, out std_out, out std_err);\n\t\treturn long.parse(std_out.split(\"\\t\")[0]);\n\t}\n\n\tpublic string? file_read (string file_path){\n\n\t\t/* Reads text from file */\n\n\t\tstring txt;\n\t\tsize_t size;\n\n\t\ttry{\n\t\t\tGLib.FileUtils.get_contents (file_path, out txt, out size);\n\t\t\treturn txt;\n\t\t}\n\t\tcatch (Error e){\n\t        log_error (e.message);\n\t        log_error(_(\"Failed to read file\") + \": %s\".printf(file_path));\n\t    }\n\n\t    return null;\n\t}\n\n\tpublic bool file_write (string file_path, string contents){\n\n\t\t/* Write text to file */\n\n\t\ttry{\n\n\t\t\tdir_create(file_parent(file_path));\n\t\t\t\n\t\t\tvar file = File.new_for_path (file_path);\n\t\t\tif (file.query_exists ()) {\n\t\t\t\tfile.delete ();\n\t\t\t}\n\t\t\t\n\t\t\tvar file_stream = file.create (FileCreateFlags.REPLACE_DESTINATION);\n\t\t\tvar data_stream = new DataOutputStream (file_stream);\n\t\t\tdata_stream.put_string (contents);\n\t\t\tdata_stream.close();\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tlog_error (e.message);\n\t\t\tlog_error(_(\"Failed to write file\") + \": %s\".printf(file_path));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic bool file_copy (string src_file, string dest_file){\n\t\ttry{\n\t\t\tvar file_src = File.new_for_path (src_file);\n\t\t\tif (file_src.query_exists()) {\n\t\t\t\tvar file_dest = File.new_for_path (dest_file);\n\t\t\t\tfile_src.copy(file_dest,FileCopyFlags.OVERWRITE,null,null);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch(Error e){\n\t        log_error (e.message);\n\t        log_error(_(\"Failed to copy file\") + \": '%s', '%s'\".printf(src_file, dest_file));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic void file_move (string src_file, string dest_file){\n\t\ttry{\n\t\t\tvar file_src = File.new_for_path (src_file);\n\t\t\tif (file_src.query_exists()) {\n\t\t\t\tvar file_dest = File.new_for_path (dest_file);\n\t\t\t\tfile_src.move(file_dest,FileCopyFlags.OVERWRITE,null,null);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_error(_(\"File not found\") + \": '%s'\".printf(src_file));\n\t\t\t}\n\t\t}\n\t\tcatch(Error e){\n\t        log_error (e.message);\n\t        log_error(_(\"Failed to move file\") + \": '%s', '%s'\".printf(src_file, dest_file));\n\t\t}\n\t}\n\n\tpublic bool file_is_symlink(string file_path){\n\n\t\ttry {\n\t\t\tvar file = File.new_for_path (file_path);\n\t\t\t\n\t\t\tif (file.query_exists()) {\n\n\t\t\t\tvar info = file.query_info(\"%s\".printf(FileAttribute.STANDARD_TYPE), FileQueryInfoFlags.NOFOLLOW_SYMLINKS); // don't follow symlinks\n\n\t\t\t\tvar file_type = info.get_file_type();\n\n\t\t\t\treturn (file_type == FileType.SYMBOLIC_LINK);\n\t\t\t}\n\t\t}\n\t\tcatch (Error e) {\n\t        log_error (e.message);\n\t    }\n\t    \n\t\treturn false;\n\t}\n\n\tpublic bool file_gzip (string src_file){\n\t\t\n\t\tstring dst_file = src_file + \".gz\";\n\t\tfile_delete(dst_file);\n\t\t\n\t\tstring cmd = \"gzip '%s'\".printf(escape_single_quote(src_file));\n\t\tstring std_out, std_err;\n\t\texec_sync(cmd, out std_out, out std_err);\n\t\t\n\t\treturn file_exists(dst_file);\n\t}\n\n\tpublic bool file_gunzip (string src_file){\n\t\t\n\t\tstring dst_file = src_file;\n\t\tfile_delete(dst_file);\n\t\t\n\t\tstring cmd = \"gunzip '%s'\".printf(escape_single_quote(src_file));\n\t\tstring std_out, std_err;\n\t\texec_sync(cmd, out std_out, out std_err);\n\t\t\n\t\treturn file_exists(dst_file);\n\t}\n\n\tpublic string file_resolve_executable_path(string file_path){\n\n\t\tif (file_path.has_prefix(\"/\")){\n\t\t\treturn file_path;\n\t\t}\n\t\telse if (!file_path.contains(\"/\")){\n\t\t\treturn GLib.Environment.find_program_in_path(file_path);\n\t\t}\n\t\telse if (file_path.has_prefix(\"./\")){\n\t\t\treturn path_combine(GLib.Environment.get_current_dir(), file_path[2:file_path.length]);\n\t\t}\n\t\telse if (file_path.has_prefix(\"../\")){\n\t\t\treturn path_combine(file_parent(GLib.Environment.get_current_dir()), file_path[3:file_path.length]);\n\t\t}\n\t\telse {\n\t\t\treturn path_combine(GLib.Environment.get_current_dir(), file_path);\n\t\t}\n\t}\n\t\n\t// file info -----------------\n\n\tpublic int64 file_get_size(string file_path){\n\t\t\n\t\ttry{\n\t\t\t\n\t\t\tFile file = File.parse_name (file_path);\n\t\t\t\n\t\t\tif (FileUtils.test(file_path, GLib.FileTest.EXISTS)){\n\t\t\t\t\n\t\t\t\tif (FileUtils.test(file_path, GLib.FileTest.IS_REGULAR)\n\t\t\t\t\t&& !FileUtils.test(file_path, GLib.FileTest.IS_SYMLINK)){\n\t\t\t\t\t\t\n\t\t\t\t\treturn file.query_info(\"standard::size\",0).get_size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch(Error e){\n\t\t\tlog_error (e.message);\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tpublic DateTime file_get_modified_date(string file_path){\n\t\ttry{\n\t\t\tFileInfo info;\n\t\t\tFile file = File.parse_name (file_path);\n\t\t\tif (file.query_exists()) {\n\t\t\t\tinfo = file.query_info(\"%s\".printf(FileAttribute.TIME_MODIFIED), 0);\n\t\t\t\treturn (new DateTime.from_timeval_utc(info.get_modification_time())).to_local();\n\t\t\t}\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tlog_error (e.message);\n\t\t}\n\t\t\n\t\treturn (new DateTime.from_unix_utc(0)); //1970\n\t}\n\t\n\tpublic string file_get_symlink_target(string file_path){\n\t\ttry{\n\t\t\tFileInfo info;\n\t\t\tFile file = File.parse_name (file_path);\n\t\t\tif (file.query_exists()) {\n\t\t\t\tinfo = file.query_info(\"%s\".printf(FileAttribute.STANDARD_SYMLINK_TARGET), 0);\n\t\t\t\treturn info.get_symlink_target();\n\t\t\t}\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tlog_error (e.message);\n\t\t}\n\t\t\n\t\treturn \"\";\n\t}\n\n\t// directory helpers ----------------------\n\t\n\tpublic bool dir_exists (string dir_path){\n\t\t/* Check if directory exists */\n\t\treturn ( FileUtils.test(dir_path, GLib.FileTest.EXISTS) && FileUtils.test(dir_path, GLib.FileTest.IS_DIR));\n\t}\n\t\n\tpublic bool dir_create (string dir_path, bool show_message = false){\n\n\t\t/* Creates a directory along with parents */\n\n\t\ttry{\n\t\t\tvar dir = File.parse_name (dir_path);\n\t\t\tif (dir.query_exists () == false) {\n\t\t\t\tbool ok = dir.make_directory_with_parents (null);\n\t\t\t\tif (show_message){\n\t\t\t\t\tif (ok){\n\t\t\t\t\t\tlog_msg(_(\"Created directory\") + \": %s\".printf(dir_path));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlog_error(_(\"Failed to create directory\") + \": %s\".printf(dir_path));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tlog_error (e.message);\n\t\t\tlog_error(_(\"Failed to create directory\") + \": %s\".printf(dir_path));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic bool dir_delete (string dir_path, bool show_message = false){\n\t\t\n\t\t/* Recursively deletes directory along with contents */\n\t\t\n\t\tif (!dir_exists(dir_path)){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tstring cmd = \"rm -rf '%s'\".printf(escape_single_quote(dir_path));\n\t\tlog_debug(cmd);\n\t\tstring std_out, std_err;\n\t\tint status = exec_sync(cmd, out std_out, out std_err);\n\t\tif (show_message){\n\t\t\tif (status == 0){\n\t\t\t\tlog_msg(_(\"Deleted directory\") + \": %s\".printf(dir_path));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_error(_(\"Failed to delete directory\") + \": %s\".printf(dir_path));\n\t\t\t\tlog_error(std_out);\n\t\t\t\tlog_error(std_err);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn (status == 0);\n\t}\n\n\tpublic bool dir_move_to_trash (string dir_path){\n\t\treturn file_move_to_trash(dir_path);\n\t}\n\t\n\tpublic bool dir_is_empty (string dir_path){\n\n\t\t/* Check if directory is empty */\n\n\t\ttry{\n\t\t\tbool is_empty = true;\n\t\t\tvar dir = File.parse_name (dir_path);\n\t\t\tif (dir.query_exists()) {\n\t\t\t\tFileInfo info;\n\t\t\t\tvar enu = dir.enumerate_children (\"%s\".printf(FileAttribute.STANDARD_NAME), 0);\n\t\t\t\twhile ((info = enu.next_file()) != null) {\n\t\t\t\t\tis_empty = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn is_empty;\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tlog_error (e.message);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic bool filesystem_supports_hardlinks(string path, out bool is_readonly){\n\t\tbool supports_hardlinks = false;\n\t\tis_readonly = false;\n\t\t\n\t\tvar test_file = path_combine(path, random_string() + \"~\");\n\t\t\n\t\tif (file_write(test_file,\"\")){\n\t\t\t\n\t\t\tvar test_file2 = path_combine(path, random_string() + \"~\");\n\n\t\t\tvar cmd = \"ln '%s' '%s'\".printf(\n\t\t\t\tescape_single_quote(test_file),\n\t\t\t\tescape_single_quote(test_file2));\n\t\t\t\t\n\t\t\tlog_debug(cmd);\n\n\t\t\tint status = exec_sync(cmd);\n\n\t\t\tcmd = \"stat --printf '%%h' '%s'\".printf(\n\t\t\t\tescape_single_quote(test_file));\n\n\t\t\tlog_debug(cmd);\n\t\t\t\n\t\t\tstring std_out, std_err;\n\t\t\tstatus = exec_sync(cmd, out std_out, out std_err);\n\t\t\tlog_debug(\"stdout: %s\".printf(std_out));\n\t\t\t\n\t\t\tint64 count = 0;\n\t\t\tif (int64.try_parse(std_out, out count)){\n\t\t\t\tif (count > 1){\n\t\t\t\t\tsupports_hardlinks = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfile_delete(test_file2); // delete if exists\n\t\t\tfile_delete(test_file);\n\t\t}\n\t\telse{\n\t\t\tis_readonly = true;\n\t\t}\n\n\t\treturn supports_hardlinks;\n\t}\n\n\tpublic Gee.ArrayList<string> dir_list_names(string path){\n\t\tvar list = new Gee.ArrayList<string>();\n\t\t\n\t\ttry\n\t\t{\n\t\t\tFile f_home = File.new_for_path (path);\n\t\t\tFileEnumerator enumerator = f_home.enumerate_children (\"%s\".printf(FileAttribute.STANDARD_NAME), 0);\n\t\t\tFileInfo file;\n\t\t\twhile ((file = enumerator.next_file ()) != null) {\n\t\t\t\tstring name = file.get_name();\n\t\t\t\tlist.add(name);\n\t\t\t}\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tlog_error (e.message);\n\t\t}\n\n\t\t//sort the list\n\t\tCompareDataFunc<string> entry_compare = (a, b) => {\n\t\t\treturn strcmp(a,b);\n\t\t};\n\t\tlist.sort((owned) entry_compare);\n\n\t\treturn list;\n\t}\n\t\n\tpublic bool dir_tar (string src_dir, string tar_file, bool recursion = true){\n\t\tif (dir_exists(src_dir)) {\n\t\t\t\n\t\t\tif (file_exists(tar_file)){\n\t\t\t\tfile_delete(tar_file);\n\t\t\t}\n\n\t\t\tvar src_parent = file_parent(src_dir);\n\t\t\tvar src_name = file_basename(src_dir);\n\t\t\t\n\t\t\tstring cmd = \"tar cvf '%s' --overwrite --%srecursion -C '%s' '%s'\\n\".printf(\n\t\t\t\tescape_single_quote(tar_file),\n\t\t\t\t(recursion ? \"\" : \"no-\"),\n\t\t\t\tescape_single_quote(src_parent),\n\t\t\t\tescape_single_quote(src_name));\n\n\t\t\tlog_debug(cmd);\n\t\t\t\n\t\t\tstring stdout, stderr;\n\t\t\tint status = exec_script_sync(cmd, out stdout, out stderr);\n\t\t\tif (status == 0){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_msg(stderr);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tlog_error(_(\"Dir not found\") + \": %s\".printf(src_dir));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic bool dir_untar (string tar_file, string dst_dir){\n\t\tif (file_exists(tar_file)) {\n\n\t\t\tif (!dir_exists(dst_dir)){\n\t\t\t\tdir_create(dst_dir);\n\t\t\t}\n\t\t\t\n\t\t\tstring cmd = \"tar xvf '%s' --overwrite --same-permissions -C '%s'\\n\".printf(\n\t\t\t\tescape_single_quote(tar_file),\n\t\t\t\tescape_single_quote(dst_dir));\n\n\t\t\tlog_debug(cmd);\n\t\t\t\n\t\t\tstring stdout, stderr;\n\t\t\tint status = exec_script_sync(cmd, out stdout, out stderr);\n\t\t\tif (status == 0){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_msg(stderr);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tlog_error(_(\"File not found\") + \": %s\".printf(tar_file));\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tpublic bool chown(string dir_path, string user, string group = user){\n\t\tstring cmd = \"chown %s:%s -R '%s'\".printf(user, group, escape_single_quote(dir_path));\n\t\tint status = exec_sync(cmd, null, null);\n\t\treturn (status == 0);\n\t}\n\t\n\t// dir info -------------------\n\t\n\t// dep: find wc    TODO: rewrite\n\tpublic long dir_count(string path){\n\n\t\t/* Return total count of files and directories */\n\n\t\tstring cmd = \"\";\n\t\tstring std_out;\n\t\tstring std_err;\n\t\tint ret_val;\n\n\t\tcmd = \"find '%s' | wc -l\".printf(escape_single_quote(path));\n\t\tret_val = exec_script_sync(cmd, out std_out, out std_err);\n\t\treturn long.parse(std_out);\n\t}\n\n\t// dep: du\n\tpublic long dir_size(string path){\n\n\t\t/* Returns size of files and directories in KB*/\n\n\t\tstring cmd = \"du -s -b '%s'\".printf(escape_single_quote(path));\n\t\tstring std_out, std_err;\n\t\texec_sync(cmd, out std_out, out std_err);\n\t\treturn long.parse(std_out.split(\"\\t\")[0]);\n\t}\n\n\t// dep: du\n\tpublic long dir_size_kb(string path){\n\n\t\t/* Returns size of files and directories in KB*/\n\n\t\treturn (long)(dir_size(path) / 1024.0);\n\t}\n\n\t// archiving and encryption ----------------\n\n\t// dep: tar gzip gpg\n\tpublic bool file_tar_encrypt (string src_file, string dst_file, string password){\n\t\tif (file_exists(src_file)) {\n\t\t\tif (file_exists(dst_file)){\n\t\t\t\tfile_delete(dst_file);\n\t\t\t}\n\n\t\t\tvar src_dir = file_parent(src_file);\n\t\t\tvar src_name = file_basename(src_file);\n\n\t\t\tvar dst_dir = file_parent(dst_file);\n\t\t\tvar dst_name = file_basename(dst_file);\n\t\t\tvar tar_name = dst_name[0 : dst_name.index_of(\".gpg\")];\n\t\t\tvar tar_file = \"%s/%s\".printf(dst_dir, tar_name);\n\t\t\t\n\t\t\tstring cmd = \"tar cvf '%s' --overwrite -C '%s' '%s'\\n\".printf(\n\t\t\t\tescape_single_quote(tar_file),\n\t\t\t\tescape_single_quote(src_dir),\n\t\t\t\tescape_single_quote(src_name));\n\t\t\t\t\n\t\t\tcmd += \"gpg --passphrase '%s' -o '%s' --symmetric '%s'\\n\".printf(\n\t\t\t\tpassword,\n\t\t\t\tescape_single_quote(dst_file),\n\t\t\t\tescape_single_quote(tar_file));\n\t\t\t\t\n\t\t\tcmd += \"rm -f '%s'\\n\".printf(escape_single_quote(tar_file));\n\n\t\t\tlog_debug(cmd);\n\t\t\t\n\t\t\tstring stdout, stderr;\n\t\t\tint status = exec_script_sync(cmd, out stdout, out stderr);\n\t\t\tif (status == 0){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_msg(stderr);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// dep: tar gzip gpg\n\tpublic string file_decrypt_untar_read (string src_file, string password){\n\t\t\n\t\tif (file_exists(src_file)) {\n\t\t\t\n\t\t\t//var src_name = file_basename(src_file);\n\t\t\t//var tar_name = src_name[0 : src_name.index_of(\".gpg\")];\n\t\t\t//var tar_file = \"%s/%s\".printf(TEMP_DIR, tar_name);\n\t\t\t//var temp_file = \"%s/%s\".printf(TEMP_DIR, random_string());\n\n\t\t\tstring cmd = \"\";\n\t\t\t\n\t\t\tcmd += \"gpg --quiet --no-verbose --passphrase '%s' -o- --decrypt '%s'\".printf(\n\t\t\t\tpassword,\n\t\t\t\tescape_single_quote(src_file));\n\t\t\t\t\n\t\t\tcmd += \" | tar xf - --to-stdout 2>/dev/null\\n\";\n\t\t\tcmd += \"exit $?\\n\";\n\t\t\t\n\t\t\tlog_debug(cmd);\n\t\t\t\n\t\t\tstring std_out, std_err;\n\t\t\tint status = exec_script_sync(cmd, out std_out, out std_err);\n\t\t\tif (status == 0){\n\t\t\t\treturn std_out;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_error(std_err);\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tlog_error(_(\"File is missing\") + \": %s\".printf(src_file));\n\t\t}\n\n\t\treturn \"\";\n\t}\n\n\t// dep: tar gzip gpg\n\tpublic bool decrypt_and_untar (string src_file, string dst_file, string password){\n\t\tif (file_exists(src_file)) {\n\t\t\tif (file_exists(dst_file)){\n\t\t\t\tfile_delete(dst_file);\n\t\t\t}\n\n\t\t\tvar src_dir = file_parent(src_file);\n\t\t\tvar src_name = file_basename(src_file);\n\t\t\tvar tar_name = src_name[0 : src_name.index_of(\".gpg\")];\n\t\t\tvar tar_file = \"%s/%s\".printf(src_dir, tar_name);\n\n\t\t\tstring cmd = \"\";\n\t\t\t\n\t\t\t// gpg cannot overwrite - remove tar file if it exists\n\t\t\tcmd += \"rm -f '%s'\\n\".printf(escape_single_quote(tar_file));\n\t\t\t\n\t\t\tcmd += \"gpg --passphrase '%s' -o '%s' --decrypt '%s'\\n\".printf(\n\t\t\t\tpassword,\n\t\t\t\tescape_single_quote(tar_file),\n\t\t\t\tescape_single_quote(src_file));\n\t\t\t\t\n\t\t\tcmd += \"status=$?; if [ $status -ne 0 ]; then exit $status; fi\\n\";\n\t\t\t\n\t\t\tcmd += \"tar xvf '%s' --overwrite --same-permissions -C '%s'\\n\".printf(\n\t\t\t\tescape_single_quote(tar_file),\n\t\t\t\tescape_single_quote(file_parent(dst_file)));\n\t\t\t\t\n\t\t\tcmd += \"rm -f '%s'\\n\".printf(escape_single_quote(tar_file));\n\n\t\t\tlog_debug(cmd);\n\t\t\t\n\t\t\tstring stdout, stderr;\n\t\t\tint status = exec_script_sync(cmd, out stdout, out stderr);\n\t\t\tif (status == 0){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_error(stderr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tlog_error(_(\"File is missing\") + \": %s\".printf(src_file));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// hashing -----------\n\t\n\tprivate string hash_md5(string path){\n\t\tChecksum checksum = new Checksum (ChecksumType.MD5);\n\t\tFileStream stream = FileStream.open (path, \"rb\");\n\n\t\tuint8 fbuf[100];\n\t\tsize_t size;\n\t\twhile ((size = stream.read (fbuf)) > 0){\n\t\t  checksum.update (fbuf, size);\n\t\t}\n\t\t\n\t\tunowned string digest = checksum.get_string();\n\n\t\treturn digest;\n\t}\n\n\t// misc --------------------\n\n\tpublic string format_file_size (\n\t\tuint64 size, bool binary_units = false,\n\t\tstring unit = \"\", bool show_units = true, int decimals = 1){\n\t\t\t\n\t\tuint64 unit_k = binary_units ? 1024 : 1000;\n\t\tuint64 unit_m = binary_units ? 1024 * unit_k : 1000 * unit_k;\n\t\tuint64 unit_g = binary_units ? 1024 * unit_m : 1000 * unit_m;\n\t\tuint64 unit_t = binary_units ? 1024 * unit_g : 1000 * unit_g;\n\n\t\t//log_debug(\"size: %'lld\".printf(size));\n\n\t\tstring txt = \"\";\n\t\t\n\t\tif ((size > unit_t) && ((unit.length == 0) || (unit == \"t\"))){\n\t\t\ttxt += (\"%%'0.%df\".printf(decimals)).printf(size / (1.0 * unit_t));\n\t\t\tif (show_units){\n\t\t\t\ttxt += \" %sB\".printf(binary_units ? \"Ti\" : \"T\");\n\t\t\t}\n\t\t}\n\t\telse if ((size > unit_g) && ((unit.length == 0) || (unit == \"g\"))){\n\t\t\ttxt += (\"%%'0.%df\".printf(decimals)).printf(size / (1.0 * unit_g));\n\t\t\tif (show_units){\n\t\t\t\ttxt += \" %sB\".printf(binary_units ? \"Gi\" : \"G\");\n\t\t\t}\n\t\t}\n\t\telse if ((size > unit_m) && ((unit.length == 0) || (unit == \"m\"))){\n\t\t\ttxt += (\"%%'0.%df\".printf(decimals)).printf(size / (1.0 * unit_m));\n\t\t\tif (show_units){\n\t\t\t\ttxt += \" %sB\".printf(binary_units ? \"Mi\" : \"M\");\n\t\t\t}\n\t\t}\n\t\telse if ((size > unit_k) && ((unit.length == 0) || (unit == \"k\"))){\n\t\t\ttxt += (\"%%'0.%df\".printf(decimals)).printf(size / (1.0 * unit_k));\n\t\t\tif (show_units){\n\t\t\t\ttxt += \" %sB\".printf(binary_units ? \"Ki\" : \"K\");\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\ttxt += \"%'0lld\".printf(size);\n\t\t\tif (show_units){\n\t\t\t\ttxt += \" B\";\n\t\t\t}\n\t\t}\n\n\t\t//log_debug(\"converted: %s\".printf(txt));\n\n\t\treturn txt;\n\t}\n\n\tpublic string escape_single_quote(string file_path){\n\t\treturn file_path.replace(\"'\",\"'\\\\''\");\n\t}\n\n\n\t// dep: chmod\n\tpublic int chmod (string file, string permission){\n\n\t\t/* Change file permissions */\n\t\tstring cmd = \"chmod %s '%s'\".printf(permission, escape_single_quote(file));\n\t\treturn exec_sync (cmd, null, null);\n\t}\n\n\t// dep: realpath\n\tpublic string resolve_relative_path (string filePath){\n\n\t\t/* Resolve the full path of given file using 'realpath' command */\n\n\t\tstring filePath2 = filePath;\n\t\tif (filePath2.has_prefix (\"~\")){\n\t\t\tfilePath2 = Environment.get_home_dir () + \"/\" + filePath2[2:filePath2.length];\n\t\t}\n\n\t\ttry {\n\t\t\tstring output = \"\";\n\t\t\tstring cmd = \"realpath '%s'\".printf(escape_single_quote(filePath2));\n\t\t\tProcess.spawn_command_line_sync(cmd, out output);\n\t\t\toutput = output.strip ();\n\t\t\tif (FileUtils.test(output, GLib.FileTest.EXISTS)){\n\t\t\t\treturn output;\n\t\t\t}\n\t\t}\n\t\tcatch(Error e){\n\t        log_error (e.message);\n\t    }\n\n\t    return filePath2;\n\t}\n\n\tpublic int rsync (string sourceDirectory, string destDirectory, bool updateExisting, bool deleteExtra){\n\n\t\t/* Sync files with rsync */\n\n\t\tstring cmd = \"rsync -avh\";\n\t\tcmd += updateExisting ? \"\" : \" --ignore-existing\";\n\t\tcmd += deleteExtra ? \" --delete\" : \"\";\n\t\tcmd += \" '%s'\".printf(escape_single_quote(sourceDirectory) + \"//\");\n\t\tcmd += \" '%s'\".printf(escape_single_quote(destDirectory));\n\t\treturn exec_sync (cmd, null, null);\n\t}\n}\n", "\n/*\n * TeeJee.ProcessHelper.vala\n *\n * Copyright 2012-2018 Tony George <teejeetech@gmail.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n * MA 02110-1301, USA.\n *\n *\n */\n \nnamespace TeeJee.ProcessHelper{\n\tusing TeeJee.Logging;\n\tusing TeeJee.FileSystem;\n\tusing TeeJee.Misc;\n\n\tpublic string TEMP_DIR;\n\t\n\t/* Convenience functions for executing commands and managing processes */\n\n\t// execute process ---------------------------------\n\t\n    public static void init_tmp(string subdir_name){\n\t\tstring std_out, std_err;\n\n\t\tTEMP_DIR = Environment.get_tmp_dir() + \"/\" + subdir_name + \"/\" + random_string();\n\t\tdir_create(TEMP_DIR);\n\n\t\texec_script_sync(\"echo 'ok'\",out std_out,out std_err, true);\n\t\tif ((std_out == null)||(std_out.strip() != \"ok\")){\n\t\t\tTEMP_DIR = Environment.get_home_dir() + \"/.temp/\" + subdir_name + \"/\" + random_string();\n\t\t\texec_sync(\"rm -rf '%s'\".printf(TEMP_DIR), null, null);\n\t\t\tdir_create(TEMP_DIR);\n\t\t}\n\n\t\t//log_debug(\"TEMP_DIR=\" + TEMP_DIR);\n\t}\n\n\tpublic string create_temp_subdir(){\n\t\tvar temp = \"%s/%s\".printf(TEMP_DIR, random_string());\n\t\tdir_create(temp);\n\t\treturn temp;\n\t}\n\t\n\tpublic int exec_sync (string cmd, out string? std_out = null, out string? std_err = null){\n\n\t\t/* Executes single command synchronously.\n\t\t * Pipes and multiple commands are not supported.\n\t\t * std_out, std_err can be null. Output will be written to terminal if null. */\n\n\t\ttry {\n\t\t\tint status;\n\t\t\tProcess.spawn_command_line_sync(cmd, out std_out, out std_err, out status);\n\t        return status;\n\t\t}\n\t\tcatch (Error e){\n\t        log_error (e.message);\n\t        return -1;\n\t    }\n\t}\n\t\n\tpublic int exec_script_sync (string script,\n\t\tout string? std_out = null, out string? std_err = null,\n\t\tbool supress_errors = false, bool run_as_admin = false,\n\t\tbool cleanup_tmp = true, bool print_to_terminal = false){\n\n\t\t/* Executes commands synchronously.\n\t\t * Pipes and multiple commands are fully supported.\n\t\t * Commands are written to a temporary bash script and executed.\n\t\t * std_out, std_err can be null. Output will be written to terminal if null.\n\t\t * */\n\n\t\tstring sh_file = save_bash_script_temp(script, null, true, supress_errors);\n\t\tstring sh_file_admin = \"\";\n\t\t\n\t\tif (run_as_admin){\n\t\t\t\n\t\t\tvar script_admin = \"#!/bin/bash\\n\";\n\t\t\tscript_admin += \"pkexec env DISPLAY=$DISPLAY XAUTHORITY=$XAUTHORITY\";\n\t\t\tscript_admin += \" '%s'\".printf(escape_single_quote(sh_file));\n\t\t\t\n\t\t\tsh_file_admin = GLib.Path.build_filename(file_parent(sh_file),\"script-admin.sh\");\n\n\t\t\tsave_bash_script_temp(script_admin, sh_file_admin, true, supress_errors);\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tstring[] argv = new string[1];\n\t\t\tif (run_as_admin){\n\t\t\t\targv[0] = sh_file_admin;\n\t\t\t}\n\t\t\telse{\n\t\t\t\targv[0] = sh_file;\n\t\t\t}\n\n\t\t\tstring[] env = Environ.get();\n\n\t\t\tint exit_code;\n\n\t\t\tif (print_to_terminal){\n\t\t\t\t\n\t\t\t\tProcess.spawn_sync (\n\t\t\t\t\tTEMP_DIR, //working dir\n\t\t\t\t\targv, //argv\n\t\t\t\t\tenv, //environment\n\t\t\t\t\tSpawnFlags.SEARCH_PATH,\n\t\t\t\t\tnull,   // child_setup\n\t\t\t\t\tnull,\n\t\t\t\t\tnull,\n\t\t\t\t\tout exit_code\n\t\t\t\t\t);\n\t\t\t}\n\t\t\telse{\n\t\t\n\t\t\t\tProcess.spawn_sync (\n\t\t\t\t\tTEMP_DIR, //working dir\n\t\t\t\t\targv, //argv\n\t\t\t\t\tenv, //environment\n\t\t\t\t\tSpawnFlags.SEARCH_PATH,\n\t\t\t\t\tnull,   // child_setup\n\t\t\t\t\tout std_out,\n\t\t\t\t\tout std_err,\n\t\t\t\t\tout exit_code\n\t\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (cleanup_tmp){\n\t\t\t\tfile_delete(sh_file);\n\t\t\t\tif (run_as_admin){\n\t\t\t\t\tfile_delete(sh_file_admin);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn exit_code;\n\t\t}\n\t\tcatch (Error e){\n\t\t\tif (!supress_errors){\n\t\t\t\tlog_error (e.message);\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tpublic int exec_script_async (string script){\n\n\t\t/* Executes commands synchronously.\n\t\t * Pipes and multiple commands are fully supported.\n\t\t * Commands are written to a temporary bash script and executed.\n\t\t * Return value indicates if script was started successfully.\n\t\t *  */\n\n\t\ttry {\n\n\t\t\tstring scriptfile = save_bash_script_temp (script);\n\n\t\t\tstring[] argv = new string[1];\n\t\t\targv[0] = scriptfile;\n\n\t\t\tstring[] env = Environ.get();\n\t\t\t\n\t\t\tPid child_pid;\n\t\t\tProcess.spawn_async_with_pipes(\n\t\t\t    TEMP_DIR, //working dir\n\t\t\t    argv, //argv\n\t\t\t    env, //environment\n\t\t\t    SpawnFlags.SEARCH_PATH,\n\t\t\t    null,\n\t\t\t    out child_pid);\n\n\t\t\treturn 0;\n\t\t}\n\t\tcatch (Error e){\n\t        log_error (e.message);\n\t        return 1;\n\t    }\n\t}\n\n\tpublic string? save_bash_script_temp (string commands, string? script_path = null,\n\t\tbool force_locale = true, bool supress_errors = false){\n\n\t\tstring sh_path = script_path;\n\t\t\n\t\t/* Creates a temporary bash script with given commands\n\t\t * Returns the script file path */\n\n\t\tvar script = new StringBuilder();\n\t\tscript.append (\"#!/bin/bash\\n\");\n\t\tscript.append (\"\\n\");\n\t\tif (force_locale){\n\t\t\tscript.append (\"LANG=C\\n\");\n\t\t}\n\t\tscript.append (\"\\n\");\n\t\tscript.append (\"%s\\n\".printf(commands));\n\t\tscript.append (\"\\n\\nexitCode=$?\\n\");\n\t\tscript.append (\"echo ${exitCode} > ${exitCode}\\n\");\n\t\tscript.append (\"echo ${exitCode} > status\\n\");\n\n\t\tif ((sh_path == null) || (sh_path.length == 0)){\n\t\t\tsh_path = get_temp_file_path() + \".sh\";\n\t\t}\n\n\t\ttry{\n\t\t\t//write script file\n\t\t\tvar file = File.new_for_path (sh_path);\n\t\t\tif (file.query_exists ()) {\n\t\t\t\tfile.delete ();\n\t\t\t}\n\t\t\tvar file_stream = file.create (FileCreateFlags.REPLACE_DESTINATION);\n\t\t\tvar data_stream = new DataOutputStream (file_stream);\n\t\t\tdata_stream.put_string (script.str);\n\t\t\tdata_stream.close();\n\n\t\t\t// set execute permission\n\t\t\tchmod (sh_path, \"u+x\");\n\n\t\t\treturn sh_path;\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tif (!supress_errors){\n\t\t\t\tlog_error (e.message);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic string get_temp_file_path(){\n\n\t\t/* Generates temporary file path */\n\n\t\treturn TEMP_DIR + \"/\" + timestamp_numeric() + (new Rand()).next_int().to_string();\n\t}\n\n\tpublic void exec_process_new_session(string command){\n\t\texec_script_async(\"setsid %s &\".printf(command));\n\t}\n\t\n\t// find process -------------------------------\n\t\n\t// dep: which\n\tpublic string get_cmd_path (string cmd_tool){\n\n\t\t/* Returns the full path to a command */\n\n\t\ttry {\n\t\t\tint exitCode;\n\t\t\tstring stdout, stderr;\n\t\t\tProcess.spawn_command_line_sync(\"which \" + cmd_tool, out stdout, out stderr, out exitCode);\n\t        return stdout;\n\t\t}\n\t\tcatch (Error e){\n\t        log_error (e.message);\n\t        return \"\";\n\t    }\n\t}\n\n\tpublic bool cmd_exists(string cmd_tool){\n\t\tstring path = get_cmd_path (cmd_tool);\n\t\tif ((path == null) || (path.length == 0)){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// dep: pidof, TODO: Rewrite using /proc\n\tpublic int get_pid_by_name (string name){\n\n\t\t/* Get the process ID for a process with given name */\n\n\t\tstring std_out, std_err;\n\t\texec_sync(\"pidof \\\"%s\\\"\".printf(name), out std_out, out std_err);\n\t\t\n\t\tif (std_out != null){\n\t\t\tstring[] arr = std_out.split (\"\\n\");\n\t\t\tif (arr.length > 0){\n\t\t\t\treturn int.parse (arr[0]);\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tpublic int get_pid_by_command(string cmdline){\n\n\t\t/* Searches for process using the command line used to start the process.\n\t\t * Returns the process id if found.\n\t\t * */\n\t\t \n\t\ttry {\n\t\t\tFileEnumerator enumerator;\n\t\t\tFileInfo info;\n\t\t\tFile file = File.parse_name (\"/proc\");\n\n\t\t\tenumerator = file.enumerate_children (\"standard::name\", 0);\n\t\t\twhile ((info = enumerator.next_file()) != null) {\n\t\t\t\ttry {\n\t\t\t\t\tstring io_stat_file_path = \"/proc/%s/cmdline\".printf(info.get_name());\n\t\t\t\t\tvar io_stat_file = File.new_for_path(io_stat_file_path);\n\t\t\t\t\tif (file.query_exists()){\n\t\t\t\t\t\tvar dis = new DataInputStream (io_stat_file.read());\n\n\t\t\t\t\t\tstring line;\n\t\t\t\t\t\tstring text = \"\";\n\t\t\t\t\t\tsize_t length;\n\t\t\t\t\t\twhile((line = dis.read_until (\"\\0\", out length)) != null){\n\t\t\t\t\t\t\ttext += \" \" + line;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ((text != null) && text.contains(cmdline)){\n\t\t\t\t\t\t\treturn int.parse(info.get_name());\n\t\t\t\t\t\t}\n\t\t\t\t\t} //stream closed\n\t\t\t\t}\n\t\t\t\tcatch(Error e){\n\t\t\t\t\t// do not log\n\t\t\t\t\t// some processes cannot be accessed by non-admin user\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch(Error e){\n\t\t  log_error (e.message);\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tpublic void get_proc_io_stats(int pid, out int64 read_bytes, out int64 write_bytes){\n\n\t\t/* Returns the number of bytes read and written by a process to disk */\n\t\t\n\t\tstring io_stat_file_path = \"/proc/%d/io\".printf(pid);\n\t\tvar file = File.new_for_path(io_stat_file_path);\n\n\t\tread_bytes = 0;\n\t\twrite_bytes = 0;\n\n\t\ttry {\n\t\t\tif (file.query_exists()){\n\t\t\t\tvar dis = new DataInputStream (file.read());\n\t\t\t\tstring line;\n\t\t\t\twhile ((line = dis.read_line (null)) != null) {\n\t\t\t\t\tif(line.has_prefix(\"rchar:\")){\n\t\t\t\t\t\tread_bytes = int64.parse(line.replace(\"rchar:\",\"\").strip());\n\t\t\t\t\t}\n\t\t\t\t\telse if(line.has_prefix(\"wchar:\")){\n\t\t\t\t\t\twrite_bytes = int64.parse(line.replace(\"wchar:\",\"\").strip());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} //stream closed\n\t\t}\n\t\tcatch(Error e){\n\t\t\tlog_error (e.message);\n\t\t}\n\t}\n\n\t// dep: ps TODO: Rewrite using /proc\n\tpublic bool process_is_running(long pid){\n\n\t\t/* Checks if given process is running */\n\n\t\tstring cmd = \"\";\n\t\tstring std_out;\n\t\tstring std_err;\n\t\tint ret_val;\n\n\t\ttry{\n\t\t\tcmd = \"ps --pid %ld\".printf(pid);\n\t\t\tProcess.spawn_command_line_sync(cmd, out std_out, out std_err, out ret_val);\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tlog_error (e.message);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn (ret_val == 0);\n\t}\n\n\t// dep: pgrep TODO: Rewrite using /proc\n\tpublic bool process_is_running_by_name(string proc_name){\n\n\t\t/* Checks if given process is running */\n\n\t\tstring cmd = \"\";\n\t\tstring std_out;\n\t\tstring std_err;\n\t\tint ret_val;\n\n\t\ttry{\n\t\t\tcmd = \"pgrep -f '%s'\".printf(proc_name);\n\t\t\tProcess.spawn_command_line_sync(cmd, out std_out, out std_err, out ret_val);\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tlog_error (e.message);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn (ret_val == 0);\n\t}\n\t\n\t// dep: ps TODO: Rewrite using /proc\n\tpublic int[] get_process_children (Pid parent_pid){\n\n\t\t/* Returns the list of child processes spawned by given process */\n\n\t\tstring std_out, std_err;\n\t\texec_sync(\"ps --ppid %d\".printf(parent_pid), out std_out, out std_err);\n\n\t\tint pid;\n\t\tint[] procList = {};\n\t\tstring[] arr;\n\n\t\tforeach (string line in std_out.split (\"\\n\")){\n\t\t\tarr = line.strip().split (\" \");\n\t\t\tif (arr.length < 1) { continue; }\n\n\t\t\tpid = 0;\n\t\t\tpid = int.parse (arr[0]);\n\n\t\t\tif (pid != 0){\n\t\t\t\tprocList += pid;\n\t\t\t}\n\t\t}\n\t\treturn procList;\n\t}\n\n\t// manage process ---------------------------------\n\t\n\tpublic void process_quit(Pid process_pid, bool killChildren = true){\n\n\t\t/* Kills specified process and its children (optional).\n\t\t * Sends signal SIGTERM to the process to allow it to quit gracefully.\n\t\t * */\n\n\t\tint[] child_pids = get_process_children (process_pid);\n\t\tPosix.kill (process_pid, Posix.SIGTERM);\n\n\t\tif (killChildren){\n\t\t\tPid childPid;\n\t\t\tforeach (long pid in child_pids){\n\t\t\t\tchildPid = (Pid) pid;\n\t\t\t\tPosix.kill (childPid, Posix.SIGTERM);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void process_kill(Pid process_pid, bool killChildren = true){\n\n\t\t/* Kills specified process and its children (optional).\n\t\t * Sends signal SIGKILL to the process to kill it forcefully.\n\t\t * It is recommended to use the function process_quit() instead.\n\t\t * */\n\t\t\n\t\tint[] child_pids = get_process_children (process_pid);\n\t\tPosix.kill (process_pid, Posix.SIGKILL);\n\n\t\tif (killChildren){\n\t\t\tPid childPid;\n\t\t\tforeach (long pid in child_pids){\n\t\t\t\tchildPid = (Pid) pid;\n\t\t\t\tPosix.kill (childPid, Posix.SIGKILL);\n\t\t\t}\n\t\t}\n\t}\n\n\t// dep: kill\n\tpublic int process_pause (Pid procID){\n\n\t\t/* Pause/Freeze a process */\n\n\t\treturn exec_sync (\"kill -STOP %d\".printf(procID), null, null);\n\t}\n\n\t// dep: kill\n\tpublic int process_resume (Pid procID){\n\n\t\t/* Resume/Un-freeze a process*/\n\n\t\treturn exec_sync (\"kill -CONT %d\".printf(procID), null, null);\n\t}\n\n\t// dep: ps TODO: Rewrite using /proc\n\tpublic void process_quit_by_name(string cmd_name, string cmd_to_match, bool exact_match){\n\n\t\t/* Kills a specific command */\n\t\t\n\t\tstring std_out, std_err;\n\t\texec_sync (\"ps w -C '%s'\".printf(cmd_name), out std_out, out std_err);\n\t\t//use 'ps ew -C conky' for all users\n\n\t\tstring pid = \"\";\n\t\tforeach(string line in std_out.split(\"\\n\")){\n\t\t\tif ((exact_match && line.has_suffix(\" \" + cmd_to_match))\n\t\t\t|| (!exact_match && (line.index_of(cmd_to_match) != -1))){\n\t\t\t\tpid = line.strip().split(\" \")[0];\n\t\t\t\tPosix.kill ((Pid) int.parse(pid), 15);\n\t\t\t\tlog_debug(_(\"Stopped\") + \": [PID=\" + pid + \"] \");\n\t\t\t}\n\t\t}\n\t}\n\n\t// process priority ---------------------------------------\n\t\n\tpublic void process_set_priority (Pid procID, int prio){\n\n\t\t/* Set process priority */\n\n\t\tif (Posix.getpriority (Posix.PRIO_PROCESS, procID) != prio)\n\t\t\tPosix.setpriority (Posix.PRIO_PROCESS, procID, prio);\n\t}\n\n\tpublic int process_get_priority (Pid procID){\n\n\t\t/* Get process priority */\n\n\t\treturn Posix.getpriority (Posix.PRIO_PROCESS, procID);\n\t}\n\n\tpublic void process_set_priority_normal (Pid procID){\n\n\t\t/* Set normal priority for process */\n\n\t\tprocess_set_priority (procID, 0);\n\t}\n\n\tpublic void process_set_priority_low (Pid procID){\n\n\t\t/* Set low priority for process */\n\n\t\tprocess_set_priority (procID, 5);\n\t}\n}\n"], "fixing_code": ["/*\n * Main.vala\n *\n * Copyright 2012-2018 Tony George <teejeetech@gmail.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n * MA 02110-1301, USA.\n *\n *\n */\n\nusing GLib;\nusing Gtk;\nusing Gee;\nusing Json;\n\nusing TeeJee.Logging;\nusing TeeJee.FileSystem;\nusing TeeJee.JsonHelper;\nusing TeeJee.ProcessHelper;\nusing TeeJee.GtkHelper;\nusing TeeJee.System;\nusing TeeJee.Misc;\n\npublic bool GTK_INITIALIZED = false;\n\npublic class Main : GLib.Object{\n\t\n\tpublic string app_path = \"\";\n\tpublic string share_folder = \"\";\n\tpublic string rsnapshot_conf_path = \"\";\n\tpublic string app_conf_path = \"\";\n\tpublic string app_conf_path_default = \"\";\n\tpublic bool first_run = false;\n\t\n\tpublic string backup_uuid = \"\";\n\tpublic string backup_parent_uuid = \"\";\n\n\tpublic bool btrfs_mode = true;\n\tpublic bool include_btrfs_home_for_backup = false;\n\tpublic bool include_btrfs_home_for_restore = false;\n\t\n\tpublic bool stop_cron_emails = true;\n\t\n\tpublic Gee.ArrayList<Device> partitions;\n\n\tpublic Gee.ArrayList<string> exclude_list_user;\n\tpublic Gee.ArrayList<string> exclude_list_default;\n\tpublic Gee.ArrayList<string> exclude_list_default_extra;\n\tpublic Gee.ArrayList<string> exclude_list_home;\n\tpublic Gee.ArrayList<string> exclude_list_restore;\n\tpublic Gee.ArrayList<AppExcludeEntry> exclude_list_apps;\n\tpublic Gee.ArrayList<MountEntry> mount_list;\n\tpublic Gee.ArrayList<string> exclude_app_names;\n\t\n\tpublic SnapshotRepo repo; \n\n\t//temp\n\t//private Gee.ArrayList<Device> grub_device_list;\n\n\tpublic Device sys_root;\n\tpublic Device sys_boot;\n\tpublic Device sys_efi;\n\tpublic Device sys_home;\n\tpublic Gee.HashMap<string, Subvolume> sys_subvolumes;\n\n\tpublic string mount_point_restore = \"\";\n\tpublic string mount_point_app = \"/run/timeshift\";\n\n\tpublic LinuxDistro current_distro;\n\tpublic bool mirror_system = false;\n\n\tpublic bool schedule_monthly = false;\n\tpublic bool schedule_weekly = false;\n\tpublic bool schedule_daily = false;\n\tpublic bool schedule_hourly = false;\n\tpublic bool schedule_boot = false;\n\tpublic int count_monthly = 2;\n\tpublic int count_weekly = 3;\n\tpublic int count_daily = 5;\n\tpublic int count_hourly = 6;\n\tpublic int count_boot = 5;\n\n\tpublic bool btrfs_use_qgroup = true;\n\n\tpublic string app_mode = \"\";\n\n\tpublic bool dry_run = false;\n\n\t//global vars for controlling threads\n\tpublic bool thr_success = false;\n\t\n\tpublic bool thread_estimate_running = false;\n\tpublic bool thread_estimate_success = false;\n\t\n\tpublic bool thread_restore_running = false;\n\tpublic bool thread_restore_success = false;\n\n\tpublic bool thread_delete_running = false;\n\tpublic bool thread_delete_success = false;\n\n\tpublic bool thread_subvol_info_running = false;\n\tpublic bool thread_subvol_info_success = false;\n\t\t\n\tpublic int thr_retval = -1;\n\tpublic string thr_arg1 = \"\";\n\tpublic bool thr_timeout_active = false;\n\tpublic string thr_timeout_cmd = \"\";\n\n\tpublic int startup_delay_interval_mins = 10;\n\tpublic int retain_snapshots_max_days = 200;\n\t\n\tpublic int64 snapshot_location_free_space = 0;\n\n\tpublic const uint64 MIN_FREE_SPACE = 1 * GB;\n\tpublic static uint64 first_snapshot_size = 0;\n\tpublic static int64 first_snapshot_count = 0;\n\t\n\tpublic string log_dir = \"\";\n\tpublic string log_file = \"\";\n\tpublic AppLock app_lock;\n\n\tpublic string date_format = \"%Y-%m-%d %H:%M:%S\";\n\tpublic const string date_format_default = \"%Y-%m-%d %H:%M:%S\";\n\n\tpublic Gee.ArrayList<Snapshot> delete_list;\n\t\n\tpublic Snapshot snapshot_to_delete;\n\tpublic Snapshot snapshot_to_restore;\n\t//public Device restore_target;\n\tpublic bool reinstall_grub2 = true;\n\tpublic bool update_initramfs = false;\n\tpublic bool update_grub = true;\n\tpublic string grub_device = \"\";\n\tpublic bool use_option_raw = true;\n\n\tpublic bool cmd_skip_grub = false;\n\tpublic string cmd_grub_device = \"\";\n\tpublic string cmd_target_device = \"\";\n\tpublic string cmd_backup_device = \"\";\n\tpublic string cmd_snapshot = \"\";\n\tpublic bool cmd_confirm = false;\n\tpublic bool cmd_verbose = true;\n\tpublic bool cmd_scripted = false;\n\tpublic string cmd_comments = \"\";\n\tpublic string cmd_tags = \"\";\n\tpublic bool? cmd_btrfs_mode = null;\n\t\n\tpublic string progress_text = \"\";\n\n\tpublic Gtk.Window? parent_window = null;\n\t\n\tpublic RsyncTask task;\n\tpublic DeleteFileTask delete_file_task;\n\n\tpublic Gee.HashMap<string, SystemUser> current_system_users;\n\tpublic string users_with_encrypted_home = \"\";\n\tpublic string encrypted_home_dirs = \"\";\n\tpublic bool encrypted_home_warning_shown = false;\n\n\tpublic string encrypted_private_dirs = \"\";\n\tpublic bool encrypted_private_warning_shown = false;\n\n\tpublic Main(string[] args, bool gui_mode){\n\n\t\tparse_some_arguments(args);\n\t\n\t\tif (gui_mode){\n\t\t\tapp_mode = \"\";\n\t\t\tparent_window = new Gtk.Window(); // dummy\n\t\t}\n\n\t\tlog_debug(\"Main()\");\n\n\t\tif (LOG_DEBUG || gui_mode){\n\t\t\tlog_debug(\"\");\n\t\t\tlog_debug(_(\"Running\") + \" %s v%s\".printf(AppName, AppVersion));\n\t\t\tlog_debug(\"\");\n\t\t}\n\n\t\tcheck_and_remove_timeshift_btrfs();\n\t\t\n\t\t// init log ------------------\n\n\t\ttry {\n\t\t\tstring suffix = gui_mode ? \"gui\" : app_mode;\n\t\t\t\n\t\t\tDateTime now = new DateTime.now_local();\n\t\t\tlog_dir = \"/var/log/timeshift\";\n\t\t\tlog_file = path_combine(log_dir,\n\t\t\t\t\"%s_%s.log\".printf(now.format(\"%Y-%m-%d_%H-%M-%S\"), suffix));\n\n\t\t\tvar file = File.new_for_path (log_dir);\n\t\t\tif (!file.query_exists ()) {\n\t\t\t\tfile.make_directory_with_parents();\n\t\t\t}\n\n\t\t\tfile = File.new_for_path (log_file);\n\t\t\tif (file.query_exists ()) {\n\t\t\t\tfile.delete ();\n\t\t\t}\n\n\t\t\tdos_log = new DataOutputStream (file.create(FileCreateFlags.REPLACE_DESTINATION));\n\t\t\tif (LOG_DEBUG || gui_mode){\n\t\t\t\tlog_debug(_(\"Session log file\") + \": %s\".printf(log_file));\n\t\t\t}\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tlog_error (e.message);\n\t\t}\n\t\t\n\t\t// get Linux distribution info -----------------------\n\t\t\n\t\tthis.current_distro = LinuxDistro.get_dist_info(\"/\");\n\n\t\tif (LOG_DEBUG || gui_mode){\n\t\t\tlog_debug(_(\"Distribution\") + \": \" + current_distro.full_name());\n\t\t\tlog_debug(\"DIST_ID\" + \": \" + current_distro.dist_id);\n\t\t}\n\n\t\t// check dependencies ---------------------\n\n\t\tstring message;\n\t\tif (!check_dependencies(out message)){\n\t\t\tif (gui_mode){\n\t\t\t\tstring title = _(\"Missing Dependencies\");\n\t\t\t\tgtk_messagebox(title, message, null, true);\n\t\t\t}\n\t\t\texit_app(1);\n\t\t}\n\n\t\t// check and create lock ----------------------------\n\n\t\tapp_lock = new AppLock();\n\t\t\n\t\tif (!app_lock.create(\"timeshift\", app_mode)){\n\t\t\tif (gui_mode){\n\t\t\t\tstring msg = \"\";\n\t\t\t\tif (app_lock.lock_message == \"backup\"){\n\t\t\t\t\tmsg = _(\"Another instance of Timeshift is creating a snapshot.\") + \"\\n\";\n\t\t\t\t\tmsg += _(\"Please wait a few minutes and try again.\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmsg = _(\"Another instance of timeshift is currently running!\") + \"\\n\";\n\t\t\t\t\tmsg += _(\"Please check if you have multiple windows open.\") + \"\\n\";\n\t\t\t\t}\n\n\t\t\t\tstring title = _(\"Scheduled snapshot in progress...\");\n\t\t\t\tgtk_messagebox(title, msg, null, true);\n\t\t\t}\n\t\t\telse{\n\t\t\t\t//already logged - do nothing\n\t\t\t}\n\t\t\texit(1);\n\t\t}\n\n\t\t// initialize variables -------------------------------\n\n\t\tthis.app_path = (File.new_for_path (args[0])).get_parent().get_path ();\n\t\tthis.share_folder = \"/usr/share\";\n\t\tthis.app_conf_path = \"/etc/timeshift.json\";\n\t\tthis.app_conf_path_default = \"/etc/default/timeshift.json\";\n\t\t//sys_root and sys_home will be initalized by update_partition_list()\n\n\t\t// check if running locally ------------------------\n\n\t\tstring local_exec = args[0];\n\t\tstring local_conf = app_path + \"/timeshift.json\";\n\t\tstring local_share = app_path + \"/share\";\n\n\t\tvar f_local_exec = File.new_for_path(local_exec);\n\t\tif (f_local_exec.query_exists()){\n\n\t\t\tvar f_local_conf = File.new_for_path(local_conf);\n\t\t\tif (f_local_conf.query_exists()){\n\t\t\t\tthis.app_conf_path = local_conf;\n\t\t\t}\n\n\t\t\tvar f_local_share = File.new_for_path(local_share);\n\t\t\tif (f_local_share.query_exists()){\n\t\t\t\tthis.share_folder = local_share;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\t//timeshift is running from system directory - update app_path\n\t\t\tthis.app_path = get_cmd_path(\"timeshift\");\n\t\t}\n\n\t\t// initialize lists -----------------\n\n\t\trepo = new SnapshotRepo();\n\t\tmount_list = new Gee.ArrayList<MountEntry>();\n\t\tdelete_list = new Gee.ArrayList<Snapshot>();\n\t\tsys_subvolumes = new Gee.HashMap<string, Subvolume>();\n\t\texclude_app_names = new Gee.ArrayList<string>();\n\t\tadd_default_exclude_entries();\n\t\t//add_app_exclude_entries();\n\t\ttask = new RsyncTask();\n\t\tdelete_file_task = new DeleteFileTask();\n\n\t\tupdate_partitions();\n\t\t\n\t\tdetect_system_devices();\n\n\t\tdetect_encrypted_dirs();\n\n\t\t// set settings from config file ---------------------\n\n\t\tload_app_config();\n\n\t\tIconManager.init(args, AppShortName);\n\t\t\n\t\tlog_debug(\"Main(): ok\");\n\t}\n\n\tpublic void initialize(){\n\t\t\n\t\tinitialize_repo();\n\t}\n\n\tpublic bool check_dependencies(out string msg){\n\t\t\n\t\tmsg = \"\";\n\n\t\tlog_debug(\"Main: check_dependencies()\");\n\t\t\n\t\tstring[] dependencies = { \"rsync\",\"/sbin/blkid\",\"df\",\"mount\",\"umount\",\"fuser\",\"crontab\",\"cp\",\"rm\",\"touch\",\"ln\",\"sync\"}; //\"shutdown\",\"chroot\",\n\n\t\tstring path;\n\t\tforeach(string cmd_tool in dependencies){\n\t\t\tpath = get_cmd_path (cmd_tool);\n\t\t\tif ((path == null) || (path.length == 0)){\n\t\t\t\tmsg += \" * \" + cmd_tool + \"\\n\";\n\t\t\t}\n\t\t}\n\n\t\tif (msg.length > 0){\n\t\t\tmsg = _(\"Commands listed below are not available on this system\") + \":\\n\\n\" + msg + \"\\n\";\n\t\t\tmsg += _(\"Please install required packages and try running TimeShift again\");\n\t\t\tlog_error(msg);\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tpublic void check_and_remove_timeshift_btrfs(){\n\t\t\n\t\tif (cmd_exists(\"timeshift-btrfs\")){\n\t\t\tstring std_out, std_err;\n\t\t\texec_sync(\"timeshift-btrfs-uninstall\", out std_out, out std_err);\n\t\t\tlog_msg(_(\"** Uninstalled Timeshift BTRFS **\"));\n\t\t}\n\t}\n\t\n\tpublic bool check_btrfs_layout_system(Gtk.Window? win = null){\n\n\t\tlog_debug(\"check_btrfs_layout_system()\");\n\n\t\tbool supported = sys_subvolumes.has_key(\"@\");\n\t\tif (include_btrfs_home_for_backup){\n\t\t\tsupported =  supported && sys_subvolumes.has_key(\"@home\");\n\t\t}\n\n\t\tif (!supported){\n\t\t\tstring msg = _(\"The system partition has an unsupported subvolume layout.\") + \" \";\n\t\t\tmsg += _(\"Only ubuntu-type layouts with @ and @home subvolumes are currently supported.\") + \"\\n\\n\";\n\t\t\tmsg += _(\"Application will exit.\") + \"\\n\\n\";\n\t\t\tstring title = _(\"Not Supported\");\n\t\t\t\n\t\t\tif (app_mode == \"\"){\n\t\t\t\tgtk_set_busy(false, win);\n\t\t\t\tgtk_messagebox(title, msg, win, true);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_error(msg);\n\t\t\t}\n\t\t}\n\n\t\treturn supported;\n\t}\n\n\tpublic bool check_btrfs_layout(Device? dev_root, Device? dev_home, bool unlock){\n\t\t\n\t\tbool supported = true; // keep true for non-btrfs systems\n\n\t\tif ((dev_root != null) && (dev_root.fstype == \"btrfs\")){\n\t\t\t\n\t\t\tif ((dev_home != null) && (dev_home.fstype == \"btrfs\")){\n\n\t\t\t\tif (dev_home != dev_root){\n\t\t\t\t\t\n\t\t\t\t\tsupported = supported && check_btrfs_volume(dev_root, \"@\", unlock);\n\n\t\t\t\t\tif (include_btrfs_home_for_backup){\n\t\t\t\t\t\tsupported = supported && check_btrfs_volume(dev_home, \"@home\", unlock);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (include_btrfs_home_for_backup){\n\t\t\t\t\t\tsupported = supported && check_btrfs_volume(dev_root, \"@,@home\", unlock);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tsupported = supported && check_btrfs_volume(dev_root, \"@\", unlock);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn supported;\n\t}\n\n\tprivate void parse_some_arguments(string[] args){\n\t\t\n\t\tfor (int k = 1; k < args.length; k++) // Oth arg is app path\n\t\t{\n\t\t\tswitch (args[k].down()){\n\t\t\t\tcase \"--debug\":\n\t\t\t\t\tLOG_COMMANDS = true;\n\t\t\t\t\tLOG_DEBUG = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"--btrfs\":\n\t\t\t\t\tbtrfs_mode = true;\n\t\t\t\t\tcmd_btrfs_mode = btrfs_mode;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"--rsync\":\n\t\t\t\t\tbtrfs_mode = false;\n\t\t\t\t\tcmd_btrfs_mode = btrfs_mode;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase \"--check\":\n\t\t\t\t\tapp_mode = \"backup\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"--delete\":\n\t\t\t\t\tapp_mode = \"delete\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"--delete-all\":\n\t\t\t\t\tapp_mode = \"delete-all\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"--restore\":\n\t\t\t\t\tapp_mode = \"restore\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"--clone\":\n\t\t\t\t\tapp_mode = \"restore\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"--create\":\n\t\t\t\t\tapp_mode = \"ondemand\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"--list\":\n\t\t\t\tcase \"--list-snapshots\":\n\t\t\t\t\tapp_mode = \"list-snapshots\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"--list-devices\":\n\t\t\t\t\tapp_mode = \"list-devices\";\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void detect_encrypted_dirs(){\n\t\t\n\t\tcurrent_system_users = SystemUser.read_users_from_file(\"/etc/passwd\",\"\",\"\");\n\n\t\tstring txt = \"\";\n\t\tusers_with_encrypted_home = \"\";\n\t\tencrypted_home_dirs = \"\";\n\t\tencrypted_private_dirs = \"\";\n\t\t\n\t\tforeach(var user in current_system_users.values){\n\t\t\t\n\t\t\tif (user.is_system) { continue; }\n\t\t\t\n\t\t\tif (txt.length > 0) { txt += \" \"; }\n\t\t\ttxt += \"%s\".printf(user.name);\n\n\t\t\tif (user.has_encrypted_home){\n\t\t\t\t\n\t\t\t\tusers_with_encrypted_home += \" %s\".printf(user.name);\n\n\t\t\t\tencrypted_home_dirs += \"%s\\n\".printf(user.home_path);\n\t\t\t}\n\n\t\t\tif (user.has_encrypted_private_dirs){\n\n\t\t\t\tforeach(string enc_path in user.encrypted_private_dirs){\n\t\t\t\t\tencrypted_private_dirs += \"%s\\n\".printf(enc_path);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusers_with_encrypted_home = users_with_encrypted_home.strip();\n\t\t\n\t\tlog_debug(\"Users: %s\".printf(txt));\n\t\tlog_debug(\"Encrypted home users: %s\".printf(users_with_encrypted_home));\n\t\tlog_debug(\"Encrypted home dirs:\\n%s\".printf(encrypted_home_dirs));\n\t\tlog_debug(\"Encrypted private dirs:\\n%s\".printf(encrypted_private_dirs));\n\t}\n\t\n\t// exclude lists\n\t\n\tpublic void add_default_exclude_entries(){\n\n\t\tlog_debug(\"Main: add_default_exclude_entries()\");\n\t\t\n\t\texclude_list_user = new Gee.ArrayList<string>();\n\t\texclude_list_default = new Gee.ArrayList<string>();\n\t\texclude_list_default_extra = new Gee.ArrayList<string>();\n\t\texclude_list_home = new Gee.ArrayList<string>();\n\t\texclude_list_restore = new Gee.ArrayList<string>();\n\t\texclude_list_apps = new Gee.ArrayList<AppExcludeEntry>();\n\t\t\n\t\tpartitions = new Gee.ArrayList<Device>();\n\n\t\t// default exclude entries -------------------\n\n\t\texclude_list_default.add(\"/dev/*\");\n\t\texclude_list_default.add(\"/proc/*\");\n\t\texclude_list_default.add(\"/sys/*\");\n\t\texclude_list_default.add(\"/media/*\");\n\t\texclude_list_default.add(\"/mnt/*\");\n\t\texclude_list_default.add(\"/tmp/*\");\n\t\texclude_list_default.add(\"/run/*\");\n\t\texclude_list_default.add(\"/var/run/*\");\n\t\texclude_list_default.add(\"/var/lock/*\");\n\t\t//exclude_list_default.add(\"/var/spool/*\");\n\t\texclude_list_default.add(\"/var/lib/docker/*\");\n\t\texclude_list_default.add(\"/var/lib/schroot/*\");\n\t\texclude_list_default.add(\"/lost+found\");\n\t\texclude_list_default.add(\"/timeshift/*\");\n\t\texclude_list_default.add(\"/timeshift-btrfs/*\");\n\t\texclude_list_default.add(\"/data/*\");\n\t\texclude_list_default.add(\"/DATA/*\");\n\t\texclude_list_default.add(\"/cdrom/*\");\n\t\texclude_list_default.add(\"/sdcard/*\");\n\t\texclude_list_default.add(\"/system/*\");\n\t\texclude_list_default.add(\"/etc/timeshift.json\");\n\t\texclude_list_default.add(\"/var/log/timeshift/*\");\n\t\texclude_list_default.add(\"/var/log/timeshift-btrfs/*\");\n\t\texclude_list_default.add(\"/swapfile\");\n\t\texclude_list_default.add(\"/snap/*\");\n\n\t\tforeach(var entry in FsTabEntry.read_file(\"/etc/fstab\")){\n\n\t\t\tif (!entry.mount_point.has_prefix(\"/\")){ continue; }\n\n\t\t\t// ignore standard system folders\n\t\t\tif (entry.mount_point == \"/\"){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/bin\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/boot\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/cdrom\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/dev\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/etc\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/home\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/lib\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/lib64\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/media\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/mnt\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/opt\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/proc\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/root\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/run\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/sbin\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/snap\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/srv\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/sys\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/system\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/tmp\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/usr\")){ continue; }\n\t\t\tif (entry.mount_point.has_prefix(\"/var\")){ continue; }\n\n\t\t\t// add exclude entry for devices mounted to non-standard locations\n\n\t\t\texclude_list_default_extra.add(entry.mount_point + \"/*\");\n\t\t}\n\n\t\texclude_list_default.add(\"/root/.thumbnails\");\n\t\texclude_list_default.add(\"/root/.cache\");\n\t\texclude_list_default.add(\"/root/.dbus\");\n\t\texclude_list_default.add(\"/root/.gvfs\");\n\t\texclude_list_default.add(\"/root/.local/share/[Tt]rash\");\n\n\t\texclude_list_default.add(\"/home/*/.thumbnails\");\n\t\texclude_list_default.add(\"/home/*/.cache\");\n\t\texclude_list_default.add(\"/home/*/.dbus\");\n\t\texclude_list_default.add(\"/home/*/.gvfs\");\n\t\texclude_list_default.add(\"/home/*/.local/share/[Tt]rash\");\n\n\t\t// default extra ------------------\n\n\t\texclude_list_default_extra.add(\"/root/.mozilla/firefox/*.default/Cache\");\n\t\texclude_list_default_extra.add(\"/root/.mozilla/firefox/*.default/OfflineCache\");\n\t\texclude_list_default_extra.add(\"/root/.opera/cache\");\n\t\texclude_list_default_extra.add(\"/root/.kde/share/apps/kio_http/cache\");\n\t\texclude_list_default_extra.add(\"/root/.kde/share/cache/http\");\n\n\t\texclude_list_default_extra.add(\"/home/*/.mozilla/firefox/*.default/Cache\");\n\t\texclude_list_default_extra.add(\"/home/*/.mozilla/firefox/*.default/OfflineCache\");\n\t\texclude_list_default_extra.add(\"/home/*/.opera/cache\");\n\t\texclude_list_default_extra.add(\"/home/*/.kde/share/apps/kio_http/cache\");\n\t\texclude_list_default_extra.add(\"/home/*/.kde/share/cache/http\");\n\n\t\texclude_list_default_extra.add(\"/var/cache/apt/archives/*\");\n\t\texclude_list_default_extra.add(\"/var/cache/pacman/pkg/*\");\n\t\texclude_list_default_extra.add(\"/var/cache/yum/*\");\n\t\texclude_list_default_extra.add(\"/var/cache/dnf/*\");\n\t\texclude_list_default_extra.add(\"/var/cache/eopkg/*\");\n\t\texclude_list_default_extra.add(\"/var/cache/xbps/*\");\n\t\texclude_list_default_extra.add(\"/var/cache/zypp/*\");\n\t\texclude_list_default_extra.add(\"/var/cache/edb/*\");\n\t\t\n\t\t// default home ----------------\n\n\t\t//exclude_list_home.add(\"+ /root/.**\");\n\t\t//exclude_list_home.add(\"+ /home/*/.**\");\n\t\texclude_list_home.add(\"/root/**\");\n\t\texclude_list_home.add(\"/home/*/**\"); // Note: /home/** ignores include filters under /home\n\n\t\t/*\n\t\tMost web browsers store their cache under ~/.cache and /tmp\n\t\tThese files will be excluded by the entries for ~/.cache and /tmp\n\t\tThere is no need to add special entries.\n\n\t\t~/.cache/google-chrome\t\t\t-- Google Chrome\n\t\t~/.cache/chromium\t\t\t\t-- Chromium\n\t\t~/.cache/epiphany-browser\t\t-- Epiphany\n\t\t~/.cache/midori/web\t\t\t\t-- Midori\n\t\t/var/tmp/kdecache-$USER/http\t-- Rekonq\n\t\t*/\n\n\t\tlog_debug(\"Main: add_default_exclude_entries(): exit\");\n\t}\n\n\tpublic void add_app_exclude_entries(){\n\n\t\tlog_debug(\"Main: add_app_exclude_entries()\");\n\t\t\n\t\tAppExcludeEntry.clear();\n\t\t\n\t\tif (snapshot_to_restore != null){\n\t\t\tadd_app_exclude_entries_for_prefix(path_combine(snapshot_to_restore.path, \"localhost\"));\n\t\t}\n\n\t\t//if (!restore_current_system){\n\t\t//\tadd_app_exclude_entries_for_prefix(mount_point_restore);\n\t\t//}\n\n\t\texclude_list_apps = AppExcludeEntry.get_apps_list(exclude_app_names);\n\n\t\tlog_debug(\"Main: add_app_exclude_entries(): exit\");\n\t}\n\n\tprivate void add_app_exclude_entries_for_prefix(string path_prefix){\n\t\t\n\t\tstring path = \"\";\n\n\t\tpath = path_combine(path_prefix, \"root\");\n\t\tAppExcludeEntry.add_app_exclude_entries_from_path(path);\n\n\t\tpath = path_combine(path_prefix, \"home\");\n\t\tAppExcludeEntry.add_app_exclude_entries_from_home(path);\n\t}\n\t\n\n\tpublic Gee.ArrayList<string> create_exclude_list_for_backup(){\n\n\t\tlog_debug(\"Main: create_exclude_list_for_backup()\");\n\t\t\n\t\tvar list = new Gee.ArrayList<string>();\n\n\t\t// add default entries ---------------------------\n\t\t\n\t\tforeach(string path in exclude_list_default){\n\t\t\tif (!list.contains(path)){\n\t\t\t\tlist.add(path);\n\t\t\t}\n\t\t}\n\n\t\t// add default extra entries ---------------------------\n\t\t\n\t\tforeach(string path in exclude_list_default_extra){\n\t\t\tif (!list.contains(path)){\n\t\t\t\tlist.add(path);\n\t\t\t}\n\t\t}\n\n\t\t// add entries to exclude **decrypted** contents in $HOME\n\t\t// decrypted contents should never be backed-up or restored\n\t\t// this overrides all other user entries in exclude_list_user\n\t\t//  -------------------------------------------------------\n\t\t\n\t\tforeach(var user in current_system_users.values){\n\t\t\t\n\t\t\tif (user.is_system){ continue; }\n\t\t\t\n\t\t\tif (user.has_encrypted_home){\n\t\t\t\t\n\t\t\t\t// exclude decrypted contents in user's home ($HOME)\n\t\t\t\tstring path = \"%s/**\".printf(user.home_path);\n\t\t\t\tlist.add(path);\n\t\t\t}\n\t\t\t\n\t\t\tif (user.has_encrypted_private_dirs){\n\n\t\t\t\tforeach(string enc_path in user.encrypted_private_dirs){\n\t\t\t\t\t\n\t\t\t\t\t// exclude decrypted contents in private dirs ($HOME/Private)\n\t\t\t\t\tstring path = \"%s/**\".printf(enc_path);\n\t\t\t\t\tlist.add(path);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// exclude each user individually if not included in exclude_list_user\n\n\t\tforeach(var user in current_system_users.values){\n\n\t\t\tif (user.is_system){ continue; }\n\n\t\t\tstring exc_pattern = \"%s/**\".printf(user.home_path);\n\t\t\tstring inc_pattern = \"+ %s/**\".printf(user.home_path);\n\t\t\tstring inc_hidden_pattern = \"+ %s/.**\".printf(user.home_path);\n\n\t\t\tif (user.has_encrypted_home){\n\t\t\t\tinc_pattern = \"+ /home/.ecryptfs/%s/***\".printf(user.name);\n\t\t\t\texc_pattern = \"/home/.ecryptfs/%s/***\".printf(user.name);\n\t\t\t}\n\t\t\t\n\t\t\tbool include_hidden = exclude_list_user.contains(inc_hidden_pattern);\n\t\t\tbool include_all = exclude_list_user.contains(inc_pattern);\n\t\t\tbool exclude_all = !include_hidden && !include_all;\n\n\t\t\tif (exclude_all){\n\t\t\t\tif (!exclude_list_user.contains(exc_pattern)){\n\t\t\t\t\texclude_list_user.add(exc_pattern);\n\t\t\t\t}\n\t\t\t\tif (exclude_list_user.contains(inc_pattern)){\n\t\t\t\t\texclude_list_user.remove(inc_pattern);\n\t\t\t\t}\n\t\t\t\tif (exclude_list_user.contains(inc_hidden_pattern)){\n\t\t\t\t\texclude_list_user.remove(inc_hidden_pattern);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// add user entries from current settings ----------\n\t\t\n\t\tforeach(string path in exclude_list_user){\n\t\t\tif (!list.contains(path)){\n\t\t\t\tlist.add(path);\n\t\t\t}\n\t\t}\n\n\t\t// add common entries for excluding home folders for all users --------\n\t\t\n\t\tforeach(string path in exclude_list_home){\n\t\t\tif (!list.contains(path)){\n\t\t\t\tlist.add(path);\n\t\t\t}\n\t\t}\n\n\t\tstring timeshift_path = \"/timeshift/*\";\n\t\tif (!list.contains(timeshift_path)){\n\t\t\tlist.add(timeshift_path);\n\t\t}\n\n\t\tlog_debug(\"Main: create_exclude_list_for_backup(): exit\");\n\t\t\n\t\treturn list;\n\t}\n\n\tpublic Gee.ArrayList<string> create_exclude_list_for_restore(){\n\n\t\tlog_debug(\"Main: create_exclude_list_for_restore()\");\n\t\t\n\t\texclude_list_restore.clear();\n\t\t\n\t\t//add default entries\n\t\tforeach(string path in exclude_list_default){\n\t\t\tif (!exclude_list_restore.contains(path)){\n\t\t\t\texclude_list_restore.add(path);\n\t\t\t}\n\t\t}\n\n\t\tif (!mirror_system){\n\t\t\t//add default_extra entries\n\t\t\tforeach(string path in exclude_list_default_extra){\n\t\t\t\tif (!exclude_list_restore.contains(path)){\n\t\t\t\t\texclude_list_restore.add(path);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//add app entries\n\t\tforeach(var entry in exclude_list_apps){\n\t\t\tif (entry.enabled){\n\t\t\t\tforeach(var pattern in entry.patterns){\n\t\t\t\t\tif (!exclude_list_restore.contains(pattern)){\n\t\t\t\t\t\texclude_list_restore.add(pattern);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//add user entries from current settings\n\t\tforeach(string path in exclude_list_user){\n\n\t\t\t// skip include filters for restore\n\t\t\tif (path.strip().has_prefix(\"+\")){ continue; }\n\t\t\t\n\t\t\tif (!exclude_list_restore.contains(path) && !exclude_list_home.contains(path)){\n\t\t\t\texclude_list_restore.add(path);\n\t\t\t}\n\t\t}\n\n\t\t//add user entries from snapshot exclude list\n\t\tif (snapshot_to_restore != null){\n\t\t\tstring list_file = path_combine(snapshot_to_restore.path, \"exclude.list\");\n\t\t\tif (file_exists(list_file)){\n\t\t\t\tforeach(string path in file_read(list_file).split(\"\\n\")){\n\t\t\t\t\tif (!exclude_list_restore.contains(path) && !exclude_list_home.contains(path)){\n\t\t\t\t\t\texclude_list_restore.add(path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//add home entries\n\t\tforeach(string path in exclude_list_home){\n\t\t\tif (!exclude_list_restore.contains(path)){\n\t\t\t\texclude_list_restore.add(path);\n\t\t\t}\n\t\t}\n\n\t\tstring timeshift_path = \"/timeshift/*\";\n\t\tif (!exclude_list_restore.contains(timeshift_path)){\n\t\t\texclude_list_restore.add(timeshift_path);\n\t\t}\n\n\t\tlog_debug(\"Main: create_exclude_list_for_restore(): exit\");\n\t\t\n\t\treturn exclude_list_restore;\n\t}\n\n\n\tpublic bool save_exclude_list_for_backup(string output_path){\n\n\t\tlog_debug(\"Main: save_exclude_list_for_backup()\");\n\t\t\n\t\tvar list = create_exclude_list_for_backup();\n\t\t\n\t\tvar txt = \"\";\n\t\tforeach(var pattern in list){\n\t\t\tif (pattern.strip().length > 0){\n\t\t\t\ttxt += \"%s\\n\".printf(pattern);\n\t\t\t}\n\t\t}\n\t\t\n\t\tstring list_file = path_combine(output_path, \"exclude.list\");\n\t\treturn file_write(list_file, txt);\n\t}\n\n\tpublic bool save_exclude_list_for_restore(string output_path){\n\n\t\tlog_debug(\"Main: save_exclude_list_for_restore()\");\n\t\t\n\t\tvar list = create_exclude_list_for_restore();\n\n\t\tlog_debug(\"Exclude list -------------\");\n\t\t\n\t\tvar txt = \"\";\n\t\tforeach(var pattern in list){\n\t\t\tif (pattern.strip().length > 0){\n\t\t\t\ttxt += \"%s\\n\".printf(pattern);\n\t\t\t\tlog_debug(pattern);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn file_write(restore_exclude_file, txt);\n\t}\n\n\tpublic void save_exclude_list_selections(){\n\n\t\tlog_debug(\"Main: save_exclude_list_selections()\");\n\t\t\n\t\t// add new selected items\n\t\tforeach(var entry in exclude_list_apps){\n\t\t\tif (entry.enabled && !exclude_app_names.contains(entry.name)){\n\t\t\t\texclude_app_names.add(entry.name);\n\t\t\t\tlog_debug(\"add app name: %s\".printf(entry.name));\n\t\t\t}\n\t\t}\n\n\t\t// remove item only if present in current list and un-selected\n\t\tforeach(var entry in exclude_list_apps){\n\t\t\tif (!entry.enabled && exclude_app_names.contains(entry.name)){\n\t\t\t\texclude_app_names.remove(entry.name);\n\t\t\t\tlog_debug(\"remove app name: %s\".printf(entry.name));\n\t\t\t}\n\t\t}\n\n\t\texclude_app_names.sort((a,b) => {\n\t\t\treturn Posix.strcmp(a,b);\n\t\t});\n\t}\n\n\t//properties\n\t\n\tpublic bool scheduled{\n\t\tget{\n\t\t\treturn !live_system()\n\t\t\t&& (schedule_boot || schedule_hourly || schedule_daily ||\n\t\t\t\tschedule_weekly || schedule_monthly);\n\t\t}\n\t}\n\n\tpublic bool live_system(){\n\t\t//return true;\n\t\treturn (sys_root == null);\n\t}\n\n\t// backup\n\n\tpublic bool create_snapshot (bool is_ondemand, Gtk.Window? parent_win){\n\n\t\tlog_debug(\"Main: create_snapshot()\");\n\t\t\n\t\tbool status = true;\n\t\tbool update_symlinks = false;\n\n\t\tstring sys_uuid = (sys_root == null) ? \"\" : sys_root.uuid;\n\t\t\n\t\ttry\n\t\t{\n\t\t\tif (btrfs_mode && (check_btrfs_layout_system() == false)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\n\t\t\t// create a timestamp\n\t\t\tDateTime now = new DateTime.now_local();\n\n\t\t\t// check space\n\t\t\tif (!repo.has_space()){\n\n\t\t\t\tlog_error(repo.status_message);\n\t\t\t\tlog_error(repo.status_details + \"\\n\");\n\t\t\t\t\n\t\t\t\t// remove invalid snapshots\n\t\t\t\tif (app_mode.length != 0){\n\t\t\t\t\trepo.auto_remove();\n\t\t\t\t}\n\n\t\t\t\t// check again ------------\n\n\t\t\t\tif (!repo.has_space()){\n\t\t\t\t\tlog_error(repo.status_message);\n\t\t\t\t\tlog_error(repo.status_details + \"\\n\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create snapshot root if missing\n\t\t\tvar f = File.new_for_path(repo.snapshots_path);\n\t\t\tif (!f.query_exists()){\n\t\t\t\tlog_debug(\"mkdir: %s\".printf(repo.snapshots_path));\n\t\t\t\tf.make_directory_with_parents();\n\t\t\t}\n\n\t\t\t// ondemand\n\t\t\tif (is_ondemand){\n\t\t\t\tbool ok = create_snapshot_for_tag (\"ondemand\",now); \n\t\t\t\tif(!ok){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tupdate_symlinks = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (scheduled){\n\t\t\t\tSnapshot last_snapshot_boot = repo.get_latest_snapshot(\"boot\", sys_uuid);\n\t\t\t\tSnapshot last_snapshot_hourly = repo.get_latest_snapshot(\"hourly\", sys_uuid);\n\t\t\t\tSnapshot last_snapshot_daily = repo.get_latest_snapshot(\"daily\", sys_uuid);\n\t\t\t\tSnapshot last_snapshot_weekly = repo.get_latest_snapshot(\"weekly\", sys_uuid);\n\t\t\t\tSnapshot last_snapshot_monthly = repo.get_latest_snapshot(\"monthly\", sys_uuid);\n\n\t\t\t\tDateTime dt_sys_boot = now.add_seconds((-1) * get_system_uptime_seconds());\n\t\t\t\tbool take_new = false;\n\n\t\t\t\tif (schedule_boot){\n\n\t\t\t\t\tlog_msg(_(\"Boot snapshots are enabled\"));\n\n\t\t\t\t\tif (last_snapshot_boot == null){\n\t\t\t\t\t\tlog_msg(_(\"Last boot snapshot not found\"));\n\t\t\t\t\t\ttake_new = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (last_snapshot_boot.date.compare(dt_sys_boot) < 0){\n\t\t\t\t\t\tlog_msg(_(\"Last boot snapshot is older than system start time\"));\n\t\t\t\t\t\ttake_new = true;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tint hours = (int) ((float) now.difference(last_snapshot_boot.date) / TimeSpan.HOUR);\n\t\t\t\t\t\tlog_msg(_(\"Last boot snapshot is %d hours old\").printf(hours));\n\t\t\t\t\t\ttake_new = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (take_new){\n\t\t\t\t\t\tstatus = create_snapshot_for_tag (\"boot\",now);\n\t\t\t\t\t\tif(!status){\n\t\t\t\t\t\t\tlog_error(_(\"Boot snapshot failed!\"));\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tupdate_symlinks = true;\n\t\t\t\t\t\t\trepo.load_snapshots();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (schedule_hourly){\n\n\t\t\t\t\tlog_msg(_(\"Hourly snapshots are enabled\"));\n\n\t\t\t\t\tif (last_snapshot_hourly == null){\n\t\t\t\t\t\tlog_msg(_(\"Last hourly snapshot not found\"));\n\t\t\t\t\t\ttake_new = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (last_snapshot_hourly.date.compare(now.add_hours(-1).add_minutes(1)) < 0){\n\t\t\t\t\t\tlog_msg(_(\"Last hourly snapshot is more than 1 hour old\"));\n\t\t\t\t\t\ttake_new = true;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tint mins = (int) ((float) now.difference(last_snapshot_hourly.date) / TimeSpan.MINUTE);\n\t\t\t\t\t\tlog_msg(_(\"Last hourly snapshot is %d minutes old\").printf(mins));\n\t\t\t\t\t\ttake_new = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (take_new){\n\t\t\t\t\t\tstatus = create_snapshot_for_tag (\"hourly\",now);\n\t\t\t\t\t\tif(!status){\n\t\t\t\t\t\t\tlog_error(_(\"Hourly snapshot failed!\"));\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tupdate_symlinks = true;\n\t\t\t\t\t\t\trepo.load_snapshots();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (schedule_daily){\n\n\t\t\t\t\tlog_msg(_(\"Daily snapshots are enabled\"));\n\n\t\t\t\t\tif (last_snapshot_daily == null){\n\t\t\t\t\t\tlog_msg(_(\"Last daily snapshot not found\"));\n\t\t\t\t\t\ttake_new = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (last_snapshot_daily.date.compare(now.add_days(-1).add_minutes(1)) < 0){\n\t\t\t\t\t\tlog_msg(_(\"Last daily snapshot is more than 1 day old\"));\n\t\t\t\t\t\ttake_new = true;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tint hours = (int) ((float) now.difference(last_snapshot_daily.date) / TimeSpan.HOUR);\n\t\t\t\t\t\tlog_msg(_(\"Last daily snapshot is %d hours old\").printf(hours));\n\t\t\t\t\t\ttake_new = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (take_new){\n\t\t\t\t\t\tstatus = create_snapshot_for_tag (\"daily\",now);\n\t\t\t\t\t\tif(!status){\n\t\t\t\t\t\t\tlog_error(_(\"Daily snapshot failed!\"));\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tupdate_symlinks = true;\n\t\t\t\t\t\t\trepo.load_snapshots();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (schedule_weekly){\n\n\t\t\t\t\tlog_msg(_(\"Weekly snapshots are enabled\"));\n\n\t\t\t\t\tif (last_snapshot_weekly == null){\n\t\t\t\t\t\tlog_msg(_(\"Last weekly snapshot not found\"));\n\t\t\t\t\t\ttake_new = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (last_snapshot_weekly.date.compare(now.add_weeks(-1).add_minutes(1)) < 0){\n\t\t\t\t\t\tlog_msg(_(\"Last weekly snapshot is more than 1 week old\"));\n\t\t\t\t\t\ttake_new = true;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tint days = (int) ((float) now.difference(last_snapshot_weekly.date) / TimeSpan.DAY);\n\t\t\t\t\t\tlog_msg(_(\"Last weekly snapshot is %d days old\").printf(days));\n\t\t\t\t\t\ttake_new = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (take_new){\n\t\t\t\t\t\tstatus = create_snapshot_for_tag (\"weekly\",now);\n\t\t\t\t\t\tif(!status){\n\t\t\t\t\t\t\tlog_error(_(\"Weekly snapshot failed!\"));\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tupdate_symlinks = true;\n\t\t\t\t\t\t\trepo.load_snapshots();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (schedule_monthly){\n\n\t\t\t\t\tlog_msg(_(\"Monthly snapshot are enabled\"));\n\n\t\t\t\t\tif (last_snapshot_monthly == null){\n\t\t\t\t\t\tlog_msg(_(\"Last monthly snapshot not found\"));\n\t\t\t\t\t\ttake_new = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (last_snapshot_monthly.date.compare(now.add_months(-1).add_minutes(1)) < 0){\n\t\t\t\t\t\tlog_msg(_(\"Last monthly snapshot is more than 1 month old\"));\n\t\t\t\t\t\ttake_new = true;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tint days = (int) ((float) now.difference(last_snapshot_monthly.date) / TimeSpan.DAY);\n\t\t\t\t\t\tlog_msg(_(\"Last monthly snapshot is %d days old\").printf(days));\n\t\t\t\t\t\ttake_new = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (take_new){\n\t\t\t\t\t\tstatus = create_snapshot_for_tag (\"monthly\",now);\n\t\t\t\t\t\tif(!status){\n\t\t\t\t\t\t\tlog_error(_(\"Monthly snapshot failed!\"));\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tupdate_symlinks = true;\n\t\t\t\t\t\t\trepo.load_snapshots();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_msg(_(\"Scheduled snapshots are disabled\") + \" - \" + _(\"Nothing to do!\"));\n\t\t\t\tcron_job_update();\n\t\t\t}\n\t\t\t\n\t\t\tlog_msg(string.nfill(78, '-'));\n\n\t\t\trepo.load_snapshots(); // reload list for new snapshot\n\t\t\t\n\t\t\tif (app_mode.length != 0){\n\t\t\t\trepo.auto_remove();\n\t\t\t\trepo.load_snapshots();\n\t\t\t}\n\n\t\t\tif (update_symlinks){\n\t\t\t\trepo.create_symlinks();\n\t\t\t}\n\t\t\t\n\t\t\t//log_msg(\"OK\");\n\t\t}\n\t\tcatch(Error e){\n\t\t\tlog_error (e.message);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn status;\n\t}\n\n\tprivate bool create_snapshot_for_tag(string tag, DateTime dt_created){\n\n\t\tlog_debug(\"Main: backup_and_rotate()\");\n\t\t\n\t\t// save start time\n\t\tvar dt_begin = new DateTime.now_local();\n\t\tbool status = true;\n\t\t\n\t\ttry{\n\t\t\t// get system boot time\n\t\t\tDateTime now = new DateTime.now_local();\n\t\t\tDateTime dt_sys_boot = now.add_seconds((-1) * get_system_uptime_seconds());\n\n\t\t\t// check if we can rotate an existing backup -------------\n\n\t\t\tDateTime dt_filter = null;\n\n\t\t\tif (tag != \"ondemand\"){\n\t\t\t\tswitch(tag){\n\t\t\t\t\tcase \"boot\":\n\t\t\t\t\t\tdt_filter = dt_sys_boot;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"hourly\":\n\t\t\t\t\tcase \"daily\":\n\t\t\t\t\tcase \"weekly\":\n\t\t\t\t\tcase \"monthly\":\n\t\t\t\t\t\tdt_filter = now.add_hours(-1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tlog_error(_(\"Unknown snapshot type\") + \": %s\".printf(tag));\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// find a recent backup that can be used\n\t\t\t\tSnapshot backup_to_rotate = null;\n\t\t\t\tforeach(var bak in repo.snapshots){\n\t\t\t\t\tif (bak.date.compare(dt_filter) > 0){\n\t\t\t\t\t\tbackup_to_rotate = bak;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (backup_to_rotate != null){\n\t\t\t\t\t\n\t\t\t\t\t// tag the backup\n\t\t\t\t\tbackup_to_rotate.add_tag(tag);\n\t\n\t\t\t\t\tvar message = _(\"Tagged snapshot\") + \" '%s': %s\".printf(backup_to_rotate.name, tag);\n\t\t\t\t\tlog_msg(message);\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!repo.available() || !repo.has_space()){\n\t\t\t\tlog_error(repo.status_message);\n\t\t\t\tlog_error(repo.status_details);\n\t\t\t\texit_app();\n\t\t\t}\n\t\t\t\n\t\t\t// create new snapshot -----------------------\n\n\t\t\tSnapshot new_snapshot = null;\n\t\t\tif (btrfs_mode){\n\t\t\t\tnew_snapshot = create_snapshot_with_btrfs(tag, dt_created);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnew_snapshot = create_snapshot_with_rsync(tag, dt_created);\n\t\t\t}\n\t\t\t\n\t\t\t// finish ------------------------------\n\t\t\n\t\t\tvar dt_end = new DateTime.now_local();\n\t\t\tTimeSpan elapsed = dt_end.difference(dt_begin);\n\t\t\tlong seconds = (long)(elapsed * 1.0 / TimeSpan.SECOND);\n\t\t\t\n\t\t\tvar message = \"\";\n\t\t\tif (new_snapshot != null){\n\t\t\t\tmessage = \"%s %s (%lds)\".printf((btrfs_mode ? \"BTRFS\" : \"RSYNC\"), _(\"Snapshot saved successfully\"), seconds);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmessage = _(\"Failed to create snapshot\");\n\t\t\t}\n\n\t\t\tlog_msg(message);\n\t\t\tOSDNotify.notify_send(\"TimeShift\", message, 10000, \"low\");\n\n\t\t\tif (new_snapshot != null){\n\t\t\t\tmessage = _(\"Tagged snapshot\") + \" '%s': %s\".printf(new_snapshot.name, tag);\n\t\t\t\tlog_msg(message);\n\t\t\t}\n\t\t}\n\t\tcatch(Error e){\n\t\t\tlog_error (e.message);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn status;\n\t}\n\n\tprivate Snapshot? create_snapshot_with_rsync(string tag, DateTime dt_created){\n\n\t\tlog_msg(string.nfill(78, '-'));\n\n\t\tif (first_snapshot_size == 0){\n\t\t\tlog_msg(_(\"Estimating system size...\"));\n\t\t\testimate_system_size();\n\t\t}\n\t\t\n\t\tlog_msg(_(\"Creating new snapshot...\") + \"(RSYNC)\");\n\n\t\tlog_msg(_(\"Saving to device\") + \": %s\".printf(repo.device.device) + \", \" + _(\"mounted at path\") + \": %s\".printf(repo.mount_path));\n\t\t\n\t\t// take new backup ---------------------------------\n\n\t\tif (repo.mount_path.length == 0){\n\t\t\tlog_error(\"Backup location not mounted\");\n\t\t\texit_app();\n\t\t}\n\n\t\tstring time_stamp = dt_created.format(\"%Y-%m-%d_%H-%M-%S\");\n\t\tstring snapshot_dir = repo.snapshots_path;\n\t\tstring snapshot_name = time_stamp;\n\t\tstring snapshot_path = path_combine(snapshot_dir, snapshot_name);\n\t\tdir_create(snapshot_path);\n\t\tstring localhost_path = path_combine(snapshot_path, \"localhost\");\n\t\tdir_create(localhost_path);\n\t\t\n\t\tstring sys_uuid = (sys_root == null) ? \"\" : sys_root.uuid;\n\n\t\tSnapshot snapshot_to_link = null;\n\n\t\t// check if a snapshot was restored recently and use it for linking ---------\n\n\t\ttry{\n\t\t\t\n\t\t\tstring ctl_path = path_combine(snapshot_dir, \".sync-restore\");\n\t\t\tvar f = File.new_for_path(ctl_path);\n\t\t\t\n\t\t\tif (f.query_exists()){\n\n\t\t\t\t// read snapshot name from file\n\t\t\t\tstring snap_path = file_read(ctl_path);\n\t\t\t\tstring snap_name = file_basename(snap_path);\n\t\t\t\t\n\t\t\t\t// find the snapshot that was restored\n\t\t\t\tforeach(var bak in repo.snapshots){\n\t\t\t\t\tif ((bak.name == snap_name) && (bak.sys_uuid == sys_uuid)){\n\t\t\t\t\t\t// use for linking\n\t\t\t\t\t\tsnapshot_to_link = bak;\n\t\t\t\t\t\t// delete the restore-control-file\n\t\t\t\t\t\tf.delete();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch(Error e){\n\t\t\tlog_error (e.message);\n\t\t\treturn null;\n\t\t}\n\n\t\t// get latest snapshot to link if not set -------\n\n\t\tif (snapshot_to_link == null){\n\t\t\tsnapshot_to_link = repo.get_latest_snapshot(\"\", sys_uuid);\n\t\t}\n\n\t\tstring link_from_path = \"\";\n\t\tif (snapshot_to_link != null){\n\t\t\tlog_msg(\"%s: %s\".printf(_(\"Linking from snapshot\"), snapshot_to_link.name));\n\t\t\tlink_from_path = \"%s/localhost/\".printf(snapshot_to_link.path);\n\t\t}\n\n\t\t// save exclude list ----------------\n\n\t\tbool ok = save_exclude_list_for_backup(snapshot_path);\n\t\t\n\t\tstring exclude_from_file = path_combine(snapshot_path, \"exclude.list\");\n\n\t\tif (!ok){\n\t\t\tlog_error(_(\"Failed to save exclude list\"));\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t// rsync file system -------------------\n\t\t\n\t\tprogress_text = _(\"Synching files with rsync...\");\n\t\tlog_msg(progress_text);\n\n\t\tvar log_file = snapshot_path + \"/rsync-log\";\n\t\tfile_delete(log_file);\n\n\t\ttask = new RsyncTask();\n\n\t\ttask.source_path = \"\";\n\t\ttask.dest_path = snapshot_path + \"/localhost/\";\n\t\ttask.link_from_path = link_from_path;\n\t\ttask.exclude_from_file = exclude_from_file;\n\t\ttask.rsync_log_file = log_file;\n\t\ttask.prg_count_total = Main.first_snapshot_count;\n\n\t\ttask.relative = true;\n\t\ttask.verbose = true;\n\t\ttask.delete_extra = true;\n\t\ttask.delete_excluded = true;\n\t\ttask.delete_after = false;\n\t\t\t\n\t\tif (app_mode.length > 0){\n\t\t\t// console mode\n\t\t\ttask.io_nice = true;\n\t\t}\n\n\t\ttask.execute();\n\n\t\twhile (task.status == AppStatus.RUNNING){\n\t\t\tsleep(1000);\n\t\t\tgtk_do_events();\n\n\t\t\tstdout.printf(\"%6.2f%% %s (%s %s)\\r\".printf(task.progress * 100.0, _(\"complete\"), task.stat_time_remaining, _(\"remaining\")));\n\t\t\tstdout.flush();\n\t\t}\n\n\t\tstdout.printf(string.nfill(80, ' '));\n\t\tstdout.flush();\n\n\t\tstdout.printf(\"\\r\");\n\t\tstdout.flush();\n\t\t\n\t\tif (task.total_size == 0){\n\t\t\tlog_error(_(\"rsync returned an error\"));\n\t\t\tlog_error(_(\"Failed to create new snapshot\"));\n\t\t\treturn null;\n\t\t}\n\n\t\tstring initial_tags = (tag == \"ondemand\") ? \"\" : tag;\n\t\t\n\t\t// write control file\n\t\t// this step is redundant - just in case if app crashes while parsing log file in next step\n\t\t//Snapshot.write_control_file(\n\t\t//\tsnapshot_path, dt_created, sys_uuid, current_distro.full_name(),\n\t\t//\tinitial_tags, cmd_comments, 0, false, false, repo);\n\n\t\t// parse log file\n\t\t//progress_text = _(\"Parsing log file...\");\n\t\t//log_msg(progress_text);\n\t\t//var task = new RsyncTask();\n\t\t//task.parse_log(log_file);\n\n\t\tint64 fcount = file_line_count(log_file);\n\n\t\t// write control file (final - with file count after parsing log)\n\t\tvar snapshot = Snapshot.write_control_file(\n\t\t\tsnapshot_path, dt_created, sys_uuid, current_distro.full_name(),\n\t\t\tinitial_tags, cmd_comments, fcount, false, false, repo);\n\n\t\tset_tags(snapshot); // set_tags() will update the control file\n\n\t\treturn snapshot;\n\t}\n\n\tprivate Snapshot? create_snapshot_with_btrfs(string tag, DateTime dt_created){\n\n\t\tlog_msg(_(\"Creating new backup...\") + \"(BTRFS)\");\n\n\t\tlog_msg(_(\"Saving to device\") + \": %s\".printf(repo.device.device) + \", \" + _(\"mounted at path\") + \": %s\".printf(repo.mount_paths[\"@\"]));\n\t\tif ((repo.device_home != null) && (repo.device_home.uuid != repo.device.uuid)){\n\t\t\tlog_msg(_(\"Saving to device\") + \": %s\".printf(repo.device_home.device) + \", \" + _(\"mounted at path\") + \": %s\".printf(repo.mount_paths[\"@home\"]));\n\t\t}\n\n\t\t// take new backup ---------------------------------\n\n\t\tif (repo.mount_path.length == 0){\n\t\t\tlog_error(\"Snapshot device not mounted\");\n\t\t\texit_app();\n\t\t}\n\n\t\tstring time_stamp = dt_created.format(\"%Y-%m-%d_%H-%M-%S\");\n\t\tstring snapshot_name = time_stamp;\n\t\tstring sys_uuid = (sys_root == null) ? \"\" : sys_root.uuid;\n\t\tstring snapshot_path = \"\";\n\t\t\n\t\t// create subvolume snapshots\n\n\t\tvar subvol_names = new string[] { \"@\" };\n\t\t\n\t\tif (include_btrfs_home_for_backup){\n\t\t\t\n\t\t\tsubvol_names = new string[] { \"@\",\"@home\" };\n\t\t}\n\t\t\n\t\tforeach(var subvol_name in subvol_names){\n\n\t\t\tsnapshot_path = path_combine(repo.mount_paths[subvol_name], \"timeshift-btrfs/snapshots/%s\".printf(snapshot_name));\n\t\t\t\n\t\t\tdir_create(snapshot_path, true);\n\t\t\t\n\t\t\tstring src_path = path_combine(repo.mount_paths[subvol_name], subvol_name);\n\t\t\t\n\t\t\tstring dst_path = path_combine(snapshot_path, subvol_name);\n\n\t\t\t// Dirty hack to fix the nested subvilumes issue (cause of issue is unknown)\n\t\t\tif (dst_path.has_suffix(\"/@/@\")){\n\t\t\t\tdst_path = dst_path.replace(\"/@/@\", \"/@\");\n\t\t\t}\n\t\t\telse if (dst_path.has_suffix(\"/@home/@home\")){\n\t\t\t\tdst_path = dst_path.replace(\"/@home/@home\", \"/@home\");\n\t\t\t}\n\t\t\t\n\t\t\tstring cmd = \"btrfs subvolume snapshot '%s' '%s' \\n\".printf(src_path, dst_path);\n\t\t\t\n\t\t\tif (LOG_COMMANDS) { log_debug(cmd); }\n\n\t\t\tstring std_out, std_err;\n\t\t\t\n\t\t\tint ret_val = exec_sync(cmd, out std_out, out std_err);\n\t\t\t\n\t\t\tif (ret_val != 0){\n\t\t\t\t\n\t\t\t\tlog_error (std_err);\n\t\t\t\tlog_error(_(\"btrfs returned an error\") + \": %d\".printf(ret_val));\n\t\t\t\tlog_error(_(\"Failed to create subvolume snapshot\") + \": %s\".printf(subvol_name));\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_msg(_(\"Created subvolume snapshot\") + \": %s\".printf(dst_path));\n\t\t\t}\n\t\t}\n\n\t\t//log_msg(_(\"Writing control file...\"));\n\n\t\tsnapshot_path = path_combine(repo.mount_paths[\"@\"], \"timeshift-btrfs/snapshots/%s\".printf(snapshot_name));\n\n\t\tstring initial_tags = (tag == \"ondemand\") ? \"\" : tag;\n\t\t\n\t\t// write control file\n\t\tvar snapshot = Snapshot.write_control_file(\n\t\t\tsnapshot_path, dt_created, sys_uuid, current_distro.full_name(),\n\t\t\tinitial_tags, cmd_comments, 0, true, false, repo);\n\n\t\t// write subvolume info\n\t\tforeach(var subvol in sys_subvolumes.values){\n\t\t\tsnapshot.subvolumes.set(subvol.name, subvol);\n\t\t}\n\t\tsnapshot.update_control_file(); // save subvolume info\n\n\t\tset_tags(snapshot); // set_tags() will update the control file\n\t\t\n\t\treturn snapshot;\n\t}\n\n\tprivate void set_tags(Snapshot snapshot){\n\n\t\t// add tags passed on commandline for both --check and --create\n\t\t\n\t\tforeach(string tag in cmd_tags.split(\",\")){\n\t\t\tswitch(tag.strip().up()){\n\t\t\tcase \"B\":\n\t\t\t\tsnapshot.add_tag(\"boot\");\n\t\t\t\tbreak;\n\t\t\tcase \"H\":\n\t\t\t\tsnapshot.add_tag(\"hourly\");\n\t\t\t\tbreak;\n\t\t\tcase \"D\":\n\t\t\t\tsnapshot.add_tag(\"daily\");\n\t\t\t\tbreak;\n\t\t\tcase \"W\":\n\t\t\t\tsnapshot.add_tag(\"weekly\");\n\t\t\t\tbreak;\n\t\t\tcase \"M\":\n\t\t\t\tsnapshot.add_tag(\"monthly\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// add tag as ondemand if no other tag is specified\n\t\t\n\t\tif (snapshot.tags.size == 0){\n\t\t\tsnapshot.add_tag(\"ondemand\");\n\t\t}\n\t}\n\n\tpublic void validate_cmd_tags(){\n\t\tforeach(string tag in cmd_tags.split(\",\")){\n\t\t\tswitch(tag.strip().up()){\n\t\t\tcase \"B\":\n\t\t\tcase \"H\":\n\t\t\tcase \"D\":\n\t\t\tcase \"W\":\n\t\t\tcase \"M\":\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlog_error(_(\"Unknown value specified for option --tags\") + \" (%s).\".printf(tag));\n\t\t\t\tlog_error(_(\"Expected values: O, B, H, D, W, M\"));\n\t\t\t\texit_app(1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// gui delete\n\n\tpublic void delete_begin(){\n\n\t\tlog_debug(\"Main: delete_begin()\");\n\t\tprogress_text = _(\"Preparing...\");\n\t\t\n\t\ttry {\n\t\t\tthread_delete_running = true;\n\t\t\tthread_delete_success = false;\n\t\t\tThread.create<void> (delete_thread, true);\n\n\t\t\t//new Thread<bool> (\"\", delete_thread);\n\n\t\t\tlog_debug(\"delete_begin(): thread created\");\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tthread_delete_running = false;\n\t\t\tthread_delete_success = false;\n\t\t\tlog_error (e.message);\n\t\t}\n\n\t\tlog_debug(\"Main: delete_begin(): exit\");\n\t}\n\n\tpublic void delete_thread(){\n\n\t\tlog_debug(\"delete_thread()\");\n\n\t\tbool status = true;\n\n\t\tforeach(var bak in delete_list){\n\t\t\tbak.mark_for_deletion();\n\t\t}\n\t\t\n\t\twhile (delete_list.size > 0){\n\n\t\t\tvar bak = delete_list[0];\n\t\t\tbak.mark_for_deletion(); // mark for deletion again since initial list may have changed\n\n\t\t\tif (btrfs_mode){\n\t\t\t\tstatus = bak.remove(true); // wait till complete\n\n\t\t\t\tvar message = \"%s '%s'\".printf(_(\"Removed\"), bak.name);\n\t\t\t\tOSDNotify.notify_send(\"TimeShift\", message, 10000, \"low\");\n\t\t\t}\n\t\t\telse{\n\n\t\t\t\tdelete_file_task = bak.delete_file_task;\n\t\t\t\tdelete_file_task.prg_count_total = (int64) Main.first_snapshot_count;\n\t\t\t\n\t\t\t\tstatus = bak.remove(true); // wait till complete\n\n\t\t\t\tif (delete_file_task.status != AppStatus.CANCELLED){\n\t\t\t\t\tvar message = \"%s '%s' (%s)\".printf(_(\"Removed\"), bak.name, delete_file_task.stat_time_elapsed);\n\t\t\t\t\tOSDNotify.notify_send(\"TimeShift\", message, 10000, \"low\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdelete_list.remove(bak);\n\t\t}\n\n\t\tthread_delete_running = false;\n\t\tthread_delete_success = status;\n\t}\n\t\n\t// restore  - properties\n\n\tpublic Device? dst_root{\n\t\tget {\n\t\t\tforeach(var mnt in mount_list){\n\t\t\t\tif (mnt.mount_point == \"/\"){\n\t\t\t\t\treturn mnt.device;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tset{\n\t\t\tforeach(var mnt in mount_list){\n\t\t\t\tif (mnt.mount_point == \"/\"){\n\t\t\t\t\tmnt.device = value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic Device? dst_boot{\n\t\tget {\n\t\t\tforeach(var mnt in mount_list){\n\t\t\t\tif (mnt.mount_point == \"/boot\"){\n\t\t\t\t\treturn mnt.device;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tset{\n\t\t\tforeach(var mnt in mount_list){\n\t\t\t\tif (mnt.mount_point == \"/boot\"){\n\t\t\t\t\tmnt.device = value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic Device? dst_efi{\n\t\tget {\n\t\t\tforeach(var mnt in mount_list){\n\t\t\t\tif (mnt.mount_point == \"/boot/efi\"){\n\t\t\t\t\treturn mnt.device;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tset{\n\t\t\tforeach(var mnt in mount_list){\n\t\t\t\tif (mnt.mount_point == \"/boot/efi\"){\n\t\t\t\t\tmnt.device = value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic Device? dst_home{\n\t\tget {\n\t\t\tforeach(var mnt in mount_list){\n\t\t\t\tif (mnt.mount_point == \"/home\"){\n\t\t\t\t\treturn mnt.device;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tset{\n\t\t\tforeach(var mnt in mount_list){\n\t\t\t\tif (mnt.mount_point == \"/home\"){\n\t\t\t\t\tmnt.device = value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic bool restore_current_system{\n\t\tget {\n\t\t\tif ((sys_root != null) &&\n\t\t\t\t((dst_root.device == sys_root.device) || (dst_root.uuid == sys_root.uuid))){\n\t\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic string restore_source_path{\n\t\towned get {\n\t\t\tif (mirror_system){\n\t\t\t\tstring source_path = \"/tmp/timeshift\";\n\t\t\t\tdir_create(source_path);\n\t\t\t\treturn source_path;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn snapshot_to_restore.path;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic string restore_target_path{\n\t\towned get {\n\t\t\tif (restore_current_system){\n\t\t\t\treturn \"/\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn mount_point_restore + \"/\";\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic string restore_log_file{\n\t\towned get {\n\t\t\treturn restore_source_path + \"/rsync-log-restore\";\n\t\t}\n\t}\n\n\tpublic string restore_exclude_file{\n\t\towned get {\n\t\t\treturn restore_source_path + \"/exclude-restore.list\";\n\t\t}\n\t}\n\n\t// restore\n\t \n\tpublic void init_mount_list(){\n\n\t\tlog_debug(\"Main: init_mount_list()\");\n\t\t\n\t\tmount_list.clear();\n\n\t\tGee.ArrayList<FsTabEntry> fstab_list = null;\n\t\tGee.ArrayList<CryptTabEntry> crypttab_list = null;\n\t\t\n\t\tif (mirror_system){\n\t\t\tstring fstab_path = \"/etc/fstab\";\n\t\t\tfstab_list = FsTabEntry.read_file(fstab_path);\n\t\t\tstring cryttab_path = \"/etc/crypttab\";\n\t\t\tcrypttab_list = CryptTabEntry.read_file(cryttab_path);\n\t\t}\n\t\telse{\n\t\t\tfstab_list = snapshot_to_restore.fstab_list;\n\t\t\tcrypttab_list = snapshot_to_restore.cryttab_list;\n\t\t}\n\n\t\tbool root_found = false;\n\t\tbool boot_found = false;\n\t\tbool home_found = false;\n\t\tdst_root = null;\n\t\t\n\t\tforeach(var fs_entry in fstab_list){\n\n\t\t\t// skip mounting for non-system devices ----------\n\t\t\t\n\t\t\tif (!fs_entry.is_for_system_directory()){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// skip mounting excluded devices -----------------------\n\t\t\t\n\t\t\tstring p1 = \"%s/*\".printf(fs_entry.mount_point);\n\t\t\tstring p2 = \"%s/**\".printf(fs_entry.mount_point);\n\t\t\tstring p3 = \"%s/***\".printf(fs_entry.mount_point);\n\t\t\t\n\t\t\tif (exclude_list_default.contains(p1) || exclude_list_user.contains(p1)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (exclude_list_default.contains(p2) || exclude_list_user.contains(p2)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (exclude_list_default.contains(p3) || exclude_list_user.contains(p3)){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// find device by name or uuid --------------------------\n\t\t\t\n\t\t\tDevice dev_fstab = null;\n\t\t\tif (fs_entry.device_uuid.length > 0){\n\t\t\t\tdev_fstab = Device.get_device_by_uuid(fs_entry.device_uuid);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdev_fstab = Device.get_device_by_name(fs_entry.device_string);\n\t\t\t}\n\n\t\t\tif (dev_fstab == null){\n\n\t\t\t\t/*\n\t\t\t\tCheck if the device mentioned in fstab entry is a mapped device.\n\t\t\t\tIf it is, then try finding the parent device which may be available on the current system.\n\t\t\t\tPrompt user to unlock it if found.\n\t\t\t\t\n\t\t\t\tNote:\n\t\t\t\tMapped name may be different on running system, or it may be same.\n\t\t\t\tSince it is not reliable, we will try to identify the parent intead of the mapped device.\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\tif (fs_entry.device_string.has_prefix(\"/dev/mapper/\")){\n\t\t\t\t\t\n\t\t\t\t\tstring mapped_name = fs_entry.device_string.replace(\"/dev/mapper/\",\"\");\n\t\t\t\t\t\n\t\t\t\t\tforeach(var crypt_entry in crypttab_list){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (crypt_entry.mapped_name == mapped_name){\n\n\t\t\t\t\t\t\t// we found the entry for the mapped device\n\t\t\t\t\t\t\tfs_entry.device_string = crypt_entry.device_string;\n\n\t\t\t\t\t\t\tif (fs_entry.device_uuid.length > 0){\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// we have the parent's uuid. get the luks device and prompt user to unlock it.\n\t\t\t\t\t\t\t\tvar dev_luks = Device.get_device_by_uuid(fs_entry.device_uuid);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (dev_luks != null){\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tstring msg_out, msg_err;\n\t\t\t\t\t\t\t\t\tvar dev_unlocked = Device.luks_unlock(\n\t\t\t\t\t\t\t\t\t\tdev_luks, \"\", \"\", parent_window, out msg_out, out msg_err);\n\n\t\t\t\t\t\t\t\t\tif (dev_unlocked != null){\n\t\t\t\t\t\t\t\t\t\tdev_fstab = dev_unlocked;\n\t\t\t\t\t\t\t\t\t\tupdate_partitions();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tdev_fstab = dev_luks; // map to parent\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t// nothing to do: we don't have the parent's uuid\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dev_fstab != null){\n\t\t\t\t\n\t\t\t\tlog_debug(\"added: dev: %s, path: %s, options: %s\".printf(\n\t\t\t\t\tdev_fstab.device, fs_entry.mount_point, fs_entry.options));\n\t\t\t\t\t\n\t\t\t\tmount_list.add(new MountEntry(dev_fstab, fs_entry.mount_point, fs_entry.options));\n\t\t\t\t\n\t\t\t\tif (fs_entry.mount_point == \"/\"){\n\t\t\t\t\tdst_root = dev_fstab;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_debug(\"missing: dev: %s, path: %s, options: %s\".printf(\n\t\t\t\t\tfs_entry.device_string, fs_entry.mount_point, fs_entry.options));\n\n\t\t\t\tmount_list.add(new MountEntry(null, fs_entry.mount_point, fs_entry.options));\n\t\t\t}\n\n\t\t\tif (fs_entry.mount_point == \"/\"){\n\t\t\t\troot_found = true;\n\t\t\t}\n\t\t\tif (fs_entry.mount_point == \"/boot\"){\n\t\t\t\tboot_found = true;\n\t\t\t}\n\t\t\tif (fs_entry.mount_point == \"/home\"){\n\t\t\t\thome_found = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!root_found){\n\t\t\tlog_debug(\"added null entry: /\");\n\t\t\tmount_list.add(new MountEntry(null, \"/\", \"\")); // add root entry\n\t\t}\n\n\t\tif (!boot_found){\n\t\t\tlog_debug(\"added null entry: /boot\");\n\t\t\tmount_list.add(new MountEntry(null, \"/boot\", \"\")); // add boot entry\n\t\t}\n\n\t\tif (!home_found){\n\t\t\tlog_debug(\"added null entry: /home\");\n\t\t\tmount_list.add(new MountEntry(null, \"/home\", \"\")); // add home entry\n\t\t}\n\n\t\t/*\n\t\tWhile cloning the system, /boot is the only mount point that\n\t\twe will leave unchanged (to avoid encrypted systems from breaking).\n\t\tAll other mounts like /home will be defaulted to target device\n\t\t(to prevent the \"cloned\" system from using the original device)\n\t\t*/\n\t\t\n\t\tif (mirror_system){\n\t\t\tdst_root = null;\n\t\t\tforeach (var entry in mount_list){\n\t\t\t\t// user should select another device\n\t\t\t\tentry.device = null; \n\t\t\t}\n\t\t}\n\n\t\tforeach(var mnt in mount_list){\n\t\t\tif (mnt.device != null){\n\t\t\t\tlog_debug(\"Entry: %s -> %s\".printf(mnt.device.device, mnt.mount_point));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_debug(\"Entry: null -> %s\".printf(mnt.mount_point));\n\t\t\t}\n\t\t}\n\n\t\t// sort - parent mountpoints will be placed above children\n\t\tmount_list.sort((a,b) => {\n\t\t\treturn strcmp(a.mount_point, b.mount_point);\n\t\t});\n\n\t\tinit_boot_options(); // boot options depend on the mount list\n\t\t\n\t\tlog_debug(\"Main: init_mount_list(): exit\");\n\t}\n\n\tpublic void init_boot_options(){\n\n\t\tvar grub_dev = dst_root;\n\t\tif(grub_dev != null){\n\t\t\tgrub_device = grub_dev.device;\n\t\t}\n\n\t\twhile ((grub_dev != null) && grub_dev.has_parent()){\n\t\t\tgrub_dev = grub_dev.parent;\n\t\t\tgrub_device = grub_dev.device;\n\t\t}\n\n\t\tif (mirror_system){\n\t\t\t// bootloader must be re-installed\n\t\t\treinstall_grub2 = true;\n\t\t\tupdate_initramfs = true;\n\t\t\tupdate_grub = true;\n\t\t}\n\t\telse{\n\t\t\tif (snapshot_to_restore.distro.dist_id == \"fedora\"){\n\t\t\t\t// grub2-install should never be run on EFI fedora systems\n\t\t\t\treinstall_grub2 = false;\n\t\t\t\tupdate_initramfs = false;\n\t\t\t\tupdate_grub = true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treinstall_grub2 = true;\n\t\t\t\tupdate_initramfs = false;\n\t\t\t\tupdate_grub = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic bool restore_snapshot(Gtk.Window? parent_win){\n\n\t\tlog_debug(\"Main: restore_snapshot()\");\n\t\t\n\t\tparent_window = parent_win;\n\n\t\t// remove mount points which will remain on root fs\n\t\t\n\t\tfor(int i = mount_list.size-1; i >= 0; i--){\n\t\t\tvar entry = mount_list[i];\n\t\t\tif (entry.device == null){\n\t\t\t\tmount_list.remove(entry);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t// check if we have all required inputs and abort on error\n\t\t\n\t\tif (!mirror_system){\n\t\t\t\n\t\t\tif (repo.device == null){\n\t\t\t\tlog_error(_(\"Backup device not specified!\"));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_msg(string.nfill(78, '*'));\n\t\t\t\tlog_msg(_(\"Backup Device\") + \": %s\".printf(repo.device.device));\n\t\t\t\tlog_msg(string.nfill(78, '*'));\n\t\t\t}\n\t\t\t\n\t\t\tif (snapshot_to_restore == null){\n\t\t\t\tlog_error(_(\"Snapshot to restore not specified!\"));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if ((snapshot_to_restore != null) && (snapshot_to_restore.marked_for_deletion)){\n\t\t\t\tlog_error(_(\"Invalid Snapshot\"));\n\t\t\t\tlog_error(_(\"Selected snapshot is marked for deletion\"));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlog_msg(string.nfill(78, '*'));\n\t\t\t\tlog_msg(\"%s: %s ~ %s\".printf(_(\"Snapshot\"), snapshot_to_restore.name, snapshot_to_restore.description));\n\t\t\t\tlog_msg(string.nfill(78, '*'));\n\t\t\t}\n\t\t}\n\t\t\n\t\t// final check - check if target root device is mounted\n\n\t\tif (btrfs_mode){\n\t\t\tif (repo.mount_paths[\"@\"].length == 0){\n\t\t\t\tlog_error(_(\"BTRFS device is not mounted\") + \": @\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (include_btrfs_home_for_restore && (repo.mount_paths[\"@home\"].length == 0)){\n\t\t\t\tlog_error(_(\"BTRFS device is not mounted\") + \": @home\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif (dst_root == null){\n\t\t\t\tlog_error(_(\"Target device not specified!\"));\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!restore_current_system){\n\t\t\t\tif (mount_point_restore.strip().length == 0){\n\t\t\t\t\tlog_error(_(\"Target device is not mounted\"));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tthread_restore_running = true;\n\t\t\tthr_success = false;\n\t\t\t\n\t\t\tif (btrfs_mode){\n\t\t\t\tThread.create<bool> (restore_execute_btrfs, true);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tThread.create<bool> (restore_execute_rsync, true);\n\t\t\t}\n\t\t}\n\t\tcatch (ThreadError e) {\n\t\t\tthread_restore_running = false;\n\t\t\tthr_success = false;\n\t\t\tlog_error (e.message);\n\t\t}\n\n\t\twhile (thread_restore_running){\n\t\t\tgtk_do_events ();\n\t\t\tThread.usleep((ulong) GLib.TimeSpan.MILLISECOND * 100);\n\t\t}\n\n\t\tif (!dry_run){\n\t\t\tsnapshot_to_restore = null;\n\t\t}\n\n\t\tlog_debug(\"Main: restore_snapshot(): exit\");\n\t\t\n\t\treturn thr_success;\n\t}\n\n\tpublic void get_restore_messages(bool formatted,\n\t\tout string msg_devices, out string msg_reboot, out string msg_disclaimer){\n\t\t\t\n\t\tstring msg = \"\";\n\n\t\tlog_debug(\"Main: get_restore_messages()\");\n\n\t\t// msg_devices -----------------------------------------\n\t\t\n\t\tif (!formatted){\n\t\t\tmsg += \"\\n%s\\n%s\\n%s\\n\".printf(\n\t\t\t\tstring.nfill(70,'='),\n\t\t\t\t_(\"Warning\").up(),\n\t\t\t\tstring.nfill(70,'=')\n\t\t\t);\n\t\t}\n\t\t\n\t\tmsg += _(\"Data will be modified on following devices:\") + \"\\n\\n\";\n\n\t\tint max_mount = _(\"Mount\").length;\n\t\tint max_dev = _(\"Device\").length;\n\n\t\tforeach(var entry in mount_list){\n\t\t\t\n\t\t\tif (entry.device == null){ continue; }\n\n\t\t\tif (btrfs_mode){\n\t\t\t\t\n\t\t\t\tif (entry.subvolume_name().length == 0){ continue; }\n\t\t\t\t\n\t\t\t\tif (!App.snapshot_to_restore.subvolumes.has_key(entry.subvolume_name())){ continue; }\n\n\t\t\t\tif ((entry.subvolume_name() == \"@home\") && !include_btrfs_home_for_restore){ continue; }\n\t\t\t}\n\t\t\t\n\t\t\tstring dev_name = entry.device.full_name_with_parent;\n\t\t\tif (entry.subvolume_name().length > 0){\n\t\t\t\tdev_name = dev_name + \"(%s)\".printf(entry.subvolume_name());\n\t\t\t}\n\t\t\telse if (entry.lvm_name().length > 0){\n\t\t\t\tdev_name = dev_name + \"(%s)\".printf(entry.lvm_name());\n\t\t\t}\n\t\t\t\n\t\t\tif (dev_name.length > max_dev){\n\t\t\t\tmax_dev = dev_name.length;\n\t\t\t}\n\t\t\tif (entry.mount_point.length > max_mount){\n\t\t\t\tmax_mount = entry.mount_point.length;\n\t\t\t}\n\t\t}\n\n\t\tvar txt = (\"%%-%ds  %%-%ds\".printf(max_dev, max_mount))\n\t\t\t.printf(_(\"Device\"),_(\"Mount\"));\n\t\ttxt += \"\\n\";\n\n\t\ttxt += string.nfill(max_dev, '-') + \"  \" + string.nfill(max_mount, '-');\n\t\ttxt += \"\\n\";\n\t\t\n\t\tforeach(var entry in mount_list){\n\t\t\t\n\t\t\tif (entry.device == null){ continue; }\n\n\t\t\tif (btrfs_mode){\n\n\t\t\t\tif (entry.subvolume_name().length == 0){ continue; }\n\t\t\t\t\n\t\t\t\tif (!App.snapshot_to_restore.subvolumes.has_key(entry.subvolume_name())){ continue; }\n\n\t\t\t\tif ((entry.subvolume_name() == \"@home\") && !include_btrfs_home_for_restore){ continue; }\n\t\t\t}\n\t\t\t\n\t\t\tstring dev_name = entry.device.full_name_with_parent;\n\t\t\tif (entry.subvolume_name().length > 0){\n\t\t\t\tdev_name = dev_name + \"(%s)\".printf(entry.subvolume_name());\n\t\t\t}\n\t\t\telse if (entry.lvm_name().length > 0){\n\t\t\t\tdev_name = dev_name + \"(%s)\".printf(entry.lvm_name());\n\t\t\t}\n\t\t\t\n\t\t\ttxt += (\"%%-%ds  %%-%ds\".printf(max_dev, max_mount)).printf(dev_name, entry.mount_point);\n\n\t\t\ttxt += \"\\n\";\n\t\t}\n\n\t\tif (formatted){\n\t\t\tmsg += \"<span size=\\\"medium\\\"><tt>%s</tt></span>\".printf(txt);\n\t\t}\n\t\telse{\n\t\t\tmsg += \"%s\\n\".printf(txt);\n\t\t}\n\n\t\tmsg_devices = msg;\n\n\t\t//msg += _(\"Files will be overwritten on the target device!\") + \"\\n\";\n\t\t//msg += _(\"If restore fails and you are unable to boot the system, then boot from the Live CD, install Timeshift, and try to restore again.\") + \"\\n\";\n\n\t\t// msg_reboot -----------------------\n\t\t\n\t\tmsg = \"\";\n\t\tif (restore_current_system){\t\n\t\t\tmsg += _(\"Please save your work and close all applications.\") + \"\\n\";\n\t\t\tmsg += _(\"System will reboot after files are restored.\");\n\t\t}\n\n\t\tmsg_reboot = msg;\n\n\t\t// msg_disclaimer --------------------------------------\n\n\t\tmsg = \"\";\n\t\tif (!formatted){\n\t\t\tmsg += \"\\n%s\\n%s\\n%s\\n\".printf(\n\t\t\t\tstring.nfill(70,'='),\n\t\t\t\t_(\"Disclaimer\").up(),\n\t\t\t\tstring.nfill(70,'=')\n\t\t\t);\n\t\t}\n\t\t\n\t\tmsg += _(\"This software comes without absolutely NO warranty and the author takes no responsibility for any damage arising from the use of this program.\");\n\t\tmsg += \" \" + _(\"If these terms are not acceptable to you, please do not proceed beyond this point!\");\n\n\t\tif (!formatted){\n\t\t\tmsg += \"\\n\";\n\t\t}\n\t\t\n\t\tmsg_disclaimer = msg;\n\n\t\t// display messages in console mode\n\t\t\n\t\tif (app_mode.length > 0){\n\t\t\tlog_msg(msg_devices);\n\t\t\tlog_msg(msg_reboot);\n\t\t\tlog_msg(msg_disclaimer);\n\t\t}\n\n\t\tlog_debug(\"Main: get_restore_messages(): exit\");\n\t}\n\n\tprivate void create_restore_scripts(out string sh_sync, out string sh_finish){\n\n\t\tlog_debug(\"Main: create_restore_scripts()\");\n\t\t\n\t\tstring sh = \"\";\n\n\t\t// create scripts --------------------------------------\n\n\t\tsh = \"\";\n\t\tsh += \"echo ''\\n\";\n\t\tif (restore_current_system){\n\t\t\tlog_debug(\"restoring current system\");\n\t\t\t\n\t\t\tsh += \"echo '\" + _(\"Please do not interrupt the restore process!\") + \"'\\n\";\n\t\t\tsh += \"echo '\" + _(\"System will reboot after files are restored\") + \"'\\n\";\n\t\t}\n\t\tsh += \"echo ''\\n\";\n\t\tsh += \"sleep 3s\\n\";\n\n\t\t// run rsync ---------------------------------------\n\n\t\tsh += \"rsync -avir --force --delete --delete-after\";\n\n\t\tif (dry_run){\n\t\t\tsh += \" --dry-run\";\n\t\t}\n\t\t\n\t\tsh += \" --log-file=\\\"%s\\\"\".printf(restore_log_file);\n\t\tsh += \" --exclude-from=\\\"%s\\\"\".printf(restore_exclude_file);\n\n\t\tif (mirror_system){\n\t\t\tsh += \" \\\"%s\\\" \\\"%s\\\" \\n\".printf(\"/\", restore_target_path);\n\t\t}\n\t\telse{\n\t\t\tsh += \" \\\"%s\\\" \\\"%s\\\" \\n\".printf(restore_source_path + \"/localhost/\", restore_target_path);\n\t\t}\n\n\t\tif (dry_run){\n\t\t\tsh_sync = sh;\n\t\t\tsh_finish = \"\";\n\t\t\treturn; // no need to continue\n\t\t}\n\n\t\tsh += \"sync \\n\"; // sync file system\n\n\t\tlog_debug(\"rsync script:\");\n\t\tlog_debug(sh);\n\n\t\tsh_sync = sh;\n\t\t\n\t\t// chroot and re-install grub2 ---------------------\n\n\t\tlog_debug(\"reinstall_grub2=%s\".printf(reinstall_grub2.to_string()));\n\t\tlog_debug(\"grub_device=%s\".printf((grub_device == null) ? \"null\" : grub_device));\n\n\t\tvar target_distro = LinuxDistro.get_dist_info(restore_target_path);\n\t\t\n\t\tsh = \"\";\n\n\t\tstring chroot = \"\";\n\t\tif (!restore_current_system){\n\t\t\t//if ((current_distro.dist_type == \"arch\") && cmd_exists(\"arch-chroot\")){\n\t\t\t\t//chroot += \"arch-chroot \\\"%s\\\"\".printf(restore_target_path);\n\t\t\t//}\n\t\t\t//else{\n\t\t\t\tchroot += \"chroot \\\"%s\\\"\".printf(restore_target_path);\n\t\t\t//}\n\n\t\t\t// bind system directories for chrooted system\n\t\t\tsh += \"for i in dev dev/pts proc run sys; do mount --bind \\\"/$i\\\" \\\"%s$i\\\"; done \\n\".printf(restore_target_path);\n\t\t}\n\n\t\tif (reinstall_grub2 && (grub_device != null) && (grub_device.length > 0)){\n\t\t\t\n\t\t\tsh += \"sync \\n\";\n\t\t\tsh += \"echo '' \\n\";\n\t\t\tsh += \"echo '\" + _(\"Re-installing GRUB2 bootloader...\") + \"' \\n\";\n\n\t\t\t// search for other operating systems\n\t\t\t//sh += \"chroot \\\"%s\\\" os-prober \\n\".printf(restore_target_path);\n\t\t\t\n\t\t\t// re-install grub ---------------\n\n\t\t\tif (target_distro.dist_type == \"redhat\"){\n\n\t\t\t\t// this will run only in clone mode\n\t\t\t\t//sh += \"%s grub2-install %s \\n\".printf(chroot, grub_device);\n\t\t\t\tsh += \"%s grub2-install --recheck --force %s \\n\".printf(chroot, grub_device);\n\n\t\t\t\t/* NOTE:\n\t\t\t\t * grub2-install should NOT be run on Fedora EFI systems \n\t\t\t\t * https://fedoraproject.org/wiki/GRUB_2\n\t\t\t\t * Instead following packages should be reinstalled:\n\t\t\t\t * dnf reinstall grub2-efi grub2-efi-modules shim\n\t\t\t\t *\n\t\t\t\t * Bootloader installation will be skipped while restoring in GUI mode.\n\t\t\t\t * Fedora seems to boot correctly even after installing new\n\t\t\t\t * kernels and restoring a snapshot with an older kernel.\n\t\t\t\t*/\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//sh += \"%s grub-install %s \\n\".printf(chroot, grub_device);\n\t\t\t\tsh += \"%s grub-install --recheck --force %s \\n\".printf(chroot, grub_device);\n\t\t\t}\n\n\t\t\t// create new grub menu\n\t\t\t//sh += \"chroot \\\"%s\\\" grub-mkconfig -o /boot/grub/grub.cfg \\n\".printf(restore_target_path);\n\t\t}\n\t\telse{\n\t\t\tlog_debug(\"skipping sh_grub: reinstall_grub2=%s, grub_device=%s\".printf(\n\t\t\t\treinstall_grub2.to_string(), (grub_device == null) ? \"null\" : grub_device));\n\t\t}\n\n\t\t// update initramfs --------------\n\n\t\tif (update_initramfs){\n\t\t\tsh += \"echo '' \\n\";\n\t\t\tsh += \"echo '\" + _(\"Generating initramfs...\") + \"' \\n\";\n\t\t\t\n\t\t\tif (target_distro.dist_type == \"redhat\"){\n\t\t\t\tsh += \"%s dracut -f -v \\n\".printf(chroot);\n\t\t\t}\n\t\t\telse if (target_distro.dist_type == \"arch\"){\n\t\t\t\tsh += \"%s mkinitcpio -p /etc/mkinitcpio.d/*.preset\\n\".printf(chroot);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsh += \"%s update-initramfs -u -k all \\n\".printf(chroot);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// update grub menu --------------\n\n\t\tif (update_grub){\n\t\t\tsh += \"echo '' \\n\";\n\t\t\tsh += \"echo '\" + _(\"Updating GRUB menu...\") + \"' \\n\";\n\t\t\t\n\t\t\tif (target_distro.dist_type == \"redhat\"){\n\t\t\t\tsh += \"%s grub2-mkconfig -o /boot/grub2/grub.cfg \\n\".printf(chroot);\n\t\t\t}\n\t\t\tif (target_distro.dist_type == \"arch\"){\n\t\t\t\tsh += \"%s grub-mkconfig -o /boot/grub/grub.cfg \\n\".printf(chroot);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsh += \"%s update-grub \\n\".printf(chroot);\n\t\t\t}\n\n\t\t\tsh += \"sync \\n\";\n\t\t\tsh += \"echo '' \\n\";\n\t\t}\n\t\t\n\t\t// sync file systems\n\t\tsh += \"echo '\" + _(\"Synching file systems...\") + \"' \\n\";\n\t\tsh += \"sync ; sleep 10s; \\n\";\n\t\tsh += \"echo '' \\n\";\n\t\t\n\t\tif (!restore_current_system){\n\t\t\t// unmount chrooted system\n\t\t\tsh += \"echo '\" + _(\"Cleaning up...\") + \"' \\n\";\n\t\t\tsh += \"for i in dev/pts dev proc run sys; do umount -f \\\"%s$i\\\"; done \\n\".printf(restore_target_path);\n\t\t\tsh += \"sync \\n\";\n\t\t}\n\n\t\tlog_debug(\"GRUB2 install script:\");\n\t\tlog_debug(sh);\n\n\t\t// reboot if required -----------------------------------\n\n\t\tif (restore_current_system){\n\t\t\tsh += \"echo '' \\n\";\n\t\t\tsh += \"echo '\" + _(\"Rebooting system...\") + \"' \\n\";\n\t\t\tsh += \"reboot -f \\n\";\n\t\t\t//sh_reboot += \"shutdown -r now \\n\";\n\t\t}\n\n\t\tsh_finish = sh;\n\t}\n\n\tprivate bool restore_current_console(string sh_sync, string sh_finish){\n\n\t\tlog_debug(\"Main: restore_current_console()\");\n\t\t\n\t\tstring script = sh_sync + sh_finish;\n\t\tint ret_val = -1;\n\t\t\n\t\tif (cmd_verbose){\n\t\t\t//current/other system, console, verbose\n\t\t\tret_val = exec_script_sync(script, null, null, false, false, false, true);\n\t\t\tlog_msg(\"\");\n\t\t}\n\t\telse{\n\t\t\t//current/other system, console, quiet\n\t\t\tstring std_out, std_err;\n\t\t\tret_val = exec_script_sync(script, out std_out, out std_err);\n\t\t\tlog_to_file(std_out);\n\t\t\tlog_to_file(std_err);\n\t\t}\n\n\t\treturn (ret_val == 0);\n\t}\n\n\tprivate bool restore_current_gui(string sh_sync, string sh_finish){\n\n\t\tlog_debug(\"Main: restore_current_gui()\");\n\t\t\n\t\tstring script = sh_sync + sh_finish;\n\t\tstring temp_script = save_bash_script_temp(script);\n\n\t\tvar dlg = new TerminalWindow.with_parent(parent_window);\n\t\tdlg.execute_script(temp_script, true);\n\n\t\treturn true;\n\t}\n\n\tprivate bool restore_other_console(string sh_sync, string sh_finish){\n\n\t\tlog_debug(\"Main: restore_other_console()\");\n\t\t\n\t\t// execute sh_sync --------------------\n\t\t\n\t\tstring script = sh_sync;\n\t\tint ret_val = -1;\n\t\t\n\t\tif (cmd_verbose){\n\t\t\tret_val = exec_script_sync(script, null, null, false, false, false, true);\n\t\t\tlog_msg(\"\");\n\t\t}\n\t\telse{\n\t\t\tstring std_out, std_err;\n\t\t\tret_val = exec_script_sync(script, out std_out, out std_err);\n\t\t\tlog_to_file(std_out);\n\t\t\tlog_to_file(std_err);\n\t\t}\n\n\t\t// update files -------------------\n\t\t\n\t\tfix_fstab_file(restore_target_path);\n\t\tfix_crypttab_file(restore_target_path);\n\n\t\tprogress_text = _(\"Parsing log file...\");\n\t\tlog_msg(progress_text);\n\t\tvar task = new RsyncTask();\n\t\ttask.parse_log(restore_log_file);\n\n\t\t// execute sh_finish --------------------\n\n\t\tlog_debug(\"executing sh_finish: \");\n\t\tlog_debug(sh_finish);\n\t\t\n\t\tscript = sh_finish;\n\n\t\tif (cmd_verbose){\n\t\t\tret_val = exec_script_sync(script, null, null, false, false, false, true);\n\t\t\tlog_msg(\"\");\n\t\t}\n\t\telse{\n\t\t\tstring std_out, std_err;\n\t\t\tret_val = exec_script_sync(script, out std_out, out std_err);\n\t\t\tlog_to_file(std_out);\n\t\t\tlog_to_file(std_err);\n\t\t}\n\n\t\treturn (ret_val == 0);\n\t}\n\n\tprivate bool restore_other_gui(string sh_sync, string sh_finish){\n\n\t\tlog_debug(\"Main: restore_other_gui()\");\n\t\t\n\t\tprogress_text = _(\"Building file list...\");\n\n\t\ttask = new RsyncTask();\n\t\ttask.relative = false;\n\t\ttask.verbose = true;\n\t\ttask.delete_extra = true;\n\t\ttask.delete_excluded = false;\n\t\ttask.delete_after = true;\n\n\t\ttask.dry_run = dry_run;\n\t\n\t\tif (mirror_system){\n\t\t\ttask.source_path = \"/\";\n\t\t}\n\t\telse{\n\t\t\ttask.source_path = path_combine(snapshot_to_restore.path, \"localhost\");\n\t\t}\n\n\t\ttask.dest_path = restore_target_path;\n\t\t\n\t\ttask.exclude_from_file = restore_exclude_file;\n\n\t\ttask.rsync_log_file = restore_log_file;\n\n\t\tif ((snapshot_to_restore != null) && (snapshot_to_restore.file_count > 0)){\n\t\t\ttask.prg_count_total = snapshot_to_restore.file_count;\n\t\t}\n\t\telse if (Main.first_snapshot_count > 0){\n\t\t\ttask.prg_count_total = Main.first_snapshot_count;\n\t\t}\n\t\telse{\n\t\t\ttask.prg_count_total = 500000;\n\t\t}\n\n\t\ttask.execute();\n\n\t\twhile (task.status == AppStatus.RUNNING){\n\t\t\tsleep(1000);\n\n\t\t\tif (task.status_line.length > 0){\n\n\t\t\t\tif (dry_run){\n\t\t\t\t\tprogress_text = _(\"Comparing files with rsync...\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tprogress_text = _(\"Synching files with rsync...\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tgtk_do_events();\n\t\t}\n\n\t\tif (dry_run){\n\t\t\treturn true; // no need to continue\n\t\t}\n\n\t\t// update files after sync --------------------\n\n\t\tfix_fstab_file(restore_target_path);\n\t\tfix_crypttab_file(restore_target_path);\n\n\t\tprogress_text = _(\"Parsing log file...\");\n\t\tlog_msg(progress_text);\n\t\tvar task = new RsyncTask();\n\t\ttask.parse_log(restore_log_file);\n\n\t\t// execute sh_finish ------------\n\n\t\tif (reinstall_grub2 || update_initramfs || update_grub){\n\t\t\tprogress_text = _(\"Updating bootloader configuration...\");\n\t\t}\n\n\t\tlog_debug(\"executing sh_finish: \");\n\t\tlog_debug(sh_finish);\n\t\t\n\t\tint ret_val = exec_script_sync(sh_finish, null, null, false, false, false, true);\n\n\t\tlog_debug(\"script exit code: %d\".printf(ret_val));\n\n\t\treturn (ret_val == 0);\n\t}\n\n\tprivate void fix_fstab_file(string target_path){\n\n\t\tlog_debug(\"Main: fix_fstab_file()\");\n\t\t\n\t\tstring fstab_path = path_combine(target_path, \"etc/fstab\");\n\n\t\tif (!file_exists(fstab_path)){\n\t\t\tlog_debug(\"File not found: %s\".printf(fstab_path));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar fstab_list = FsTabEntry.read_file(fstab_path);\n\n\t\tlog_debug(\"updating entries (1/2)...\");\n\t\t\n\t\tforeach(var mnt in mount_list){\n\t\t\t// find existing\n\t\t\tvar entry = FsTabEntry.find_entry_by_mount_point(fstab_list, mnt.mount_point);\n\n\t\t\t// add if missing\n\t\t\tif (entry == null){\n\t\t\t\tentry = new FsTabEntry();\n\t\t\t\tentry.mount_point = mnt.mount_point;\n\t\t\t\tfstab_list.add(entry);\n\t\t\t}\n\n\t\t\t//update fstab entry\n\t\t\tentry.device_string = \"UUID=%s\".printf(mnt.device.uuid);\n\t\t\tentry.type = mnt.device.fstype;\n\n\t\t\t// fix mount options for non-btrfs device\n\t\t\tif (mnt.device.fstype != \"btrfs\"){\n\t\t\t\t// remove subvol option\n\t\t\t\tentry.remove_option(\"subvol=%s\".printf(entry.subvolume_name()));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Remove fstab entries for any system directories that\n\t\t * the user has not explicitly mapped before restore/clone\n\t\t * This ensures that the cloned/restored system does not mount\n\t\t * any devices to system paths that the user has not explicitly specified\n\t\t * */\n\n\t\tlog_debug(\"updating entries(2/2)...\");\n\t\t\n\t\tfor(int i = fstab_list.size - 1; i >= 0; i--){\n\t\t\tvar entry = fstab_list[i];\n\t\t\t\n\t\t\tif (!entry.is_for_system_directory()){ continue; }\n\t\t\t\n\t\t\tvar mnt = MountEntry.find_entry_by_mount_point(mount_list, entry.mount_point);\n\t\t\tif (mnt == null){\n\t\t\t\tfstab_list.remove(entry);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// write the updated file\n\n\t\tlog_debug(\"writing updated file...\");\n\n\t\tFsTabEntry.write_file(fstab_list, fstab_path, false);\n\n\t\tlog_msg(_(\"Updated /etc/fstab on target device\") + \": %s\".printf(fstab_path));\n\n\t\t// create directories on disk for mount points in /etc/fstab\n\n\t\tforeach(var entry in fstab_list){\n\t\t\tif (entry.mount_point.length == 0){ continue; }\n\t\t\tif (!entry.mount_point.has_prefix(\"/\")){ continue; }\n\t\t\t\n\t\t\tstring mount_path = path_combine(\n\t\t\t\ttarget_path, entry.mount_point);\n\t\t\t\t\n\t\t\tif (entry.is_comment\n\t\t\t\t|| entry.is_empty_line\n\t\t\t\t|| (mount_path.length == 0)){\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!dir_exists(mount_path)){\n\t\t\t\t\n\t\t\t\tlog_msg(\"Created mount point on target device: %s\".printf(\n\t\t\t\t\tentry.mount_point));\n\t\t\t\t\t\n\t\t\t\tdir_create(mount_path);\n\t\t\t}\n\t\t}\n\n\t\tlog_debug(\"Main: fix_fstab_file(): exit\");\n\t}\n\n\tprivate void fix_crypttab_file(string target_path){\n\n\t\tlog_debug(\"Main: fix_crypttab_file()\");\n\t\t\n\t\tstring crypttab_path = path_combine(target_path, \"etc/crypttab\");\n\n\t\tif (!file_exists(crypttab_path)){\n\t\t\tlog_debug(\"File not found: %s\".printf(crypttab_path));\n\t\t\treturn;\n\t\t}\n\n\t\tvar crypttab_list = CryptTabEntry.read_file(crypttab_path);\n\t\t\n\t\t// add option \"nofail\" to existing entries\n\n\t\tlog_debug(\"checking for 'nofail' option...\");\n\t\t\n\t\tforeach(var entry in crypttab_list){\n\t\t\tentry.append_option(\"nofail\");\n\t\t}\n\n\t\tlog_debug(\"updating entries...\");\n\n\t\t// check and add entries for mapped devices which are encrypted\n\t\t\n\t\tforeach(var mnt in mount_list){\n\t\t\tif ((mnt.device != null) && (mnt.device.parent != null) && (mnt.device.is_on_encrypted_partition())){\n\t\t\t\t\n\t\t\t\t// find existing\n\t\t\t\tvar entry = CryptTabEntry.find_entry_by_uuid(\n\t\t\t\t\tcrypttab_list, mnt.device.parent.uuid);\n\n\t\t\t\t// add if missing\n\t\t\t\tif (entry == null){\n\t\t\t\t\tentry = new CryptTabEntry();\n\t\t\t\t\tcrypttab_list.add(entry);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// set custom values\n\t\t\t\tentry.device_uuid = mnt.device.parent.uuid;\n\t\t\t\tentry.mapped_name = \"luks-%s\".printf(mnt.device.parent.uuid);\n\t\t\t\tentry.keyfile = \"none\";\n\t\t\t\tentry.options = \"luks,nofail\";\n\t\t\t}\n\t\t}\n\n\t\tlog_debug(\"writing updated file...\");\n\n\t\tCryptTabEntry.write_file(crypttab_list, crypttab_path, false);\n\n\t\tlog_msg(_(\"Updated /etc/crypttab on target device\") + \": %s\".printf(crypttab_path));\n\n\t\tlog_debug(\"Main: fix_crypttab_file(): exit\");\n\t}\n\n\tprivate void check_and_repair_filesystems(){\n\t\t\n\t\tif (!restore_current_system){\n\t\t\tstring sh_fsck = \"echo '\" + _(\"Checking file systems for errors...\") + \"' \\n\";\n\t\t\tforeach(var mnt in mount_list){\n\t\t\t\tif (mnt.device != null) {\n\t\t\t\t\tsh_fsck += \"fsck -y %s \\n\".printf(mnt.device.device);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsh_fsck += \"echo '' \\n\";\n\t\t\tint ret_val = exec_script_sync(sh_fsck, null, null, false, false, false, true);\n\t\t}\n\t}\n\n\tpublic bool restore_execute_rsync(){\n\t\t\n\t\tlog_debug(\"Main: restore_execute_rsync()\");\n\n\t\ttry{\n\t\t\tlog_debug(\"source_path=%s\".printf(restore_source_path));\n\t\t\tlog_debug(\"target_path=%s\".printf(restore_target_path));\n\t\t\t\n\t\t\tstring sh_sync, sh_finish;\n\t\t\tcreate_restore_scripts(out sh_sync, out sh_finish);\n\t\t\t\n\t\t\tsave_exclude_list_for_restore(restore_source_path);\n\n\t\t\tfile_delete(restore_log_file);\n\t\t\tfile_delete(restore_log_file + \"-changes\");\n\t\t\tfile_delete(restore_log_file + \".gz\");\n\t\t\t\n\t\t\tif (restore_current_system){\n\t\t\t\tstring control_file_path = path_combine(snapshot_to_restore.path,\".sync-restore\");\n\n\t\t\t\tvar f = File.new_for_path(control_file_path);\n\t\t\t\tif(f.query_exists()){\n\t\t\t\t\tf.delete(); //delete existing file\n\t\t\t\t}\n\n\t\t\t\tfile_write(control_file_path, snapshot_to_restore.path); //save snapshot name\n\t\t\t}\n\n\t\t\t// run the scripts --------------------\n\t\t\n\t\t\tif (snapshot_to_restore != null){\n\t\t\t\tif (dry_run){\n\t\t\t\t\tlog_msg(_(\"Comparing Files (Dry Run)...\"));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlog_msg(_(\"Restoring snapshot...\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_msg(_(\"Cloning system...\"));\n\t\t\t}\n\n\t\t\tprogress_text = _(\"Synching files with rsync...\");\n\t\t\tlog_msg(progress_text);\n\n\t\t\tbool ok = true;\n\t\t\t\n\t\t\tif (app_mode == \"\"){ // GUI\n\t\t\t\tif (!restore_current_system || dry_run){\n\t\t\t\t\tok = restore_other_gui(sh_sync, sh_finish);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tok = restore_current_gui(sh_sync, sh_finish);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (restore_current_system){\n\t\t\t\t\tok = restore_current_console(sh_sync, sh_finish);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tok = restore_other_console(sh_sync, sh_finish);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!dry_run){\n\n\t\t\t\tlog_msg(_(\"Restore completed\"));\n\t\t\t\tthr_success = true;\n\n\t\t\t\tlog_msg(string.nfill(78, '-'));\n\n\t\t\t\tunmount_target_device(false);\n\n\t\t\t\tcheck_and_repair_filesystems();\n\t\t\t}\n\t\t}\n\t\tcatch(Error e){\n\t\t\tlog_error (e.message);\n\t\t\tthr_success = false;\n\t\t}\n\n\t\tthread_restore_running = false;\n\t\treturn thr_success;\n\t}\n\t\n\tpublic bool restore_execute_btrfs(){\n\n\t\tlog_debug(\"Main: restore_execute_btrfs()\");\n\t\t\n\t\tbool ok = create_pre_restore_snapshot_btrfs();\n\n\t\tlog_msg(string.nfill(78, '-'));\n\t\t\n\t\tif (!ok){\n\t\t\tthread_restore_running = false;\n\t\t\tthr_success = false;\n\t\t\treturn thr_success;\n\t\t}\n\t\t\n\t\t// restore snapshot subvolumes by creating new subvolume snapshots\n\n\t\tforeach(var subvol in snapshot_to_restore.subvolumes.values){\n\n\t\t\tif ((subvol.name == \"@home\") && !include_btrfs_home_for_restore){ continue; }\n\t\t\t\n\t\t\tsubvol.restore();\n\t\t}\n\n\t\tlog_msg(_(\"Restore completed\"));\n\t\tthr_success = true;\n\t\t\n\t\tif (restore_current_system){\n\t\t\tlog_msg(_(\"Snapshot will become active after system is rebooted.\"));\n\t\t}\n\n\t\tlog_msg(string.nfill(78, '-'));\n\n\t\tquery_subvolume_quotas();\n\n\t\tthread_restore_running = false;\n\t\treturn thr_success;\n\t}\n\n\tpublic bool create_pre_restore_snapshot_btrfs(){\n\n\t\tlog_debug(\"Main: create_pre_restore_snapshot_btrfs()\");\n\t\t\n\t\tstring cmd, std_out, std_err;\n\t\tDateTime dt_created = new DateTime.now_local();\n\t\tstring time_stamp = dt_created.format(\"%Y-%m-%d_%H-%M-%S\");\n\t\tstring snapshot_name = time_stamp;\n\t\tstring snapshot_path = \"\";\n\t\t\n\t\t/* Note:\n\t\t * The @ and @home subvolumes need to be backed-up only if they are in use by the system.\n\t\t * If user restores a snapshot and then tries to restore another snapshot before the next reboot\n\t\t * then the @ and @home subvolumes are the ones that were previously restored and need to be deleted.\n\t\t * */\n\n\t\tbool create_pre_restore_backup = false;\n\n\t\tif (restore_current_system){\n\t\t\t\n\t\t\t// check for an existing pre-restore backup\n\n\t\t\tSnapshot snap_prev = null;\n\t\t\tbool found = false;\n\t\t\tforeach(var bak in repo.snapshots){\n\t\t\t\tif (bak.live){\n\t\t\t\t\tfound = true;\n\t\t\t\t\tsnap_prev = bak;\n\t\t\t\t\tlog_msg(_(\"Found existing pre-restore snapshot\") + \": %s\".printf(bak.name));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (found){\n\t\t\t\t//delete system subvolumes\n\t\t\t\tif (sys_subvolumes.has_key(\"@\") && snapshot_to_restore.subvolumes.has_key(\"@\")){\n\t\t\t\t\tsys_subvolumes[\"@\"].remove();\n\t\t\t\t\tlog_msg(_(\"Deleted subvolume\") + \": @\");\n\t\t\t\t}\n\t\t\t\tif (include_btrfs_home_for_restore && sys_subvolumes.has_key(\"@home\") && snapshot_to_restore.subvolumes.has_key(\"@home\")){\n\t\t\t\t\tsys_subvolumes[\"@home\"].remove();\n\t\t\t\t\tlog_msg(_(\"Deleted subvolume\") + \": @home\");\n\t\t\t\t}\n\n\t\t\t\t//update description for pre-restore backup\n\t\t\t\tsnap_prev.description = \"Before restoring '%s'\".printf(snapshot_to_restore.date_formatted);\n\t\t\t\tsnap_prev.update_control_file();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcreate_pre_restore_backup = true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tcreate_pre_restore_backup = true;\n\t\t}\n\n\t\tif (create_pre_restore_backup){\n\n\t\t\tlog_msg(_(\"Creating pre-restore snapshot from system subvolumes...\"));\n\t\t\t\n\t\t\tdir_create(snapshot_path);\n\n\t\t\t// move subvolumes ----------------\n\t\t\t\n\t\t\tbool no_subvolumes_found = true;\n\n\t\t\tvar subvol_list = new Gee.ArrayList<Subvolume>();\n\n\t\t\tvar subvol_names = new string[] { \"@\" };\n\t\t\tif (include_btrfs_home_for_restore){\n\t\t\t\tsubvol_names = new string[] { \"@\",\"@home\" };\n\t\t\t}\n\t\t\t\n\t\t\tforeach(string subvol_name in subvol_names){\n\n\t\t\t\tsnapshot_path = path_combine(repo.mount_paths[subvol_name], \"timeshift-btrfs/snapshots/%s\".printf(snapshot_name));\n\t\t\t\tdir_create(snapshot_path, true);\n\t\t\t\n\t\t\t\tstring src_path = path_combine(repo.mount_paths[subvol_name], subvol_name);\n\t\t\t\tif (!dir_exists(src_path)){\n\t\t\t\t\tlog_error(_(\"Could not find system subvolume\") + \": %s\".printf(subvol_name));\n\t\t\t\t\tdir_delete(snapshot_path);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tno_subvolumes_found = false;\n\n\t\t\t\tstring dst_path = path_combine(snapshot_path, subvol_name);\n\t\t\t\tcmd = \"mv '%s' '%s'\".printf(src_path, dst_path);\n\t\t\t\tlog_debug(cmd);\n\t\t\t\t\n\t\t\t\tint status = exec_sync(cmd, out std_out, out std_err);\n\t\t\t\t\n\t\t\t\tif (status != 0){\n\t\t\t\t\tlog_error (std_err);\n\t\t\t\t\tlog_error(_(\"Failed to move system subvolume to snapshot directory\") + \": %s\".printf(subvol_name));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvar subvol_dev = (subvol_name == \"@\") ? repo.device : repo.device_home;\n\t\t\t\t\tsubvol_list.add(new Subvolume(subvol_name, dst_path, subvol_dev.uuid, repo));\n\t\t\t\t\t\n\t\t\t\t\tlog_msg(_(\"Moved system subvolume to snapshot directory\") + \": %s\".printf(subvol_name));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (no_subvolumes_found){\n\t\t\t\t//could not find system subvolumes for backing up(!)\n\t\t\t\tlog_error(_(\"Could not find system subvolumes for creating pre-restore snapshot\"));\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// write control file -----------\n\n\t\t\t\tsnapshot_path = path_combine(repo.mount_paths[\"@\"], \"timeshift-btrfs/snapshots/%s\".printf(snapshot_name));\n\t\t\t\t\n\t\t\t\tvar snap = Snapshot.write_control_file(\n\t\t\t\t\tsnapshot_path, dt_created, repo.device.uuid,\n\t\t\t\t\tLinuxDistro.get_dist_info(path_combine(snapshot_path,\"@\")).full_name(),\n\t\t\t\t\t\"ondemand\", \"\", 0, true, false, repo);\n\n\t\t\t\tsnap.description = \"Before restoring '%s'\".printf(snapshot_to_restore.date_formatted);\n\t\t\t\tsnap.live = true;\n\t\t\t\t\n\t\t\t\t// write subvolume info\n\t\t\t\tforeach(var subvol in subvol_list){\n\t\t\t\t\tsnap.subvolumes.set(subvol.name, subvol);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsnap.update_control_file(); // save subvolume info\n\n\t\t\t\tlog_msg(_(\"Created pre-restore snapshot\") + \": %s\".printf(snap.name));\n\t\t\t\t\n\t\t\t\trepo.load_snapshots();\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\t\n\t//app config\n\n\tpublic void save_app_config(){\n\n\t\tlog_debug(\"Main: save_app_config()\");\n\t\t\n\t\tvar config = new Json.Object();\n\t\t\n\t\tif ((repo != null) && repo.available()){\n\t\t\t// save backup device uuid\n\t\t\tconfig.set_string_member(\"backup_device_uuid\",\n\t\t\t\t(repo.device == null) ? \"\" : repo.device.uuid);\n\t\t\t\n\t\t\t// save parent uuid if backup device has parent\n\t\t\tconfig.set_string_member(\"parent_device_uuid\",\n\t\t\t\t(repo.device.has_parent()) ? repo.device.parent.uuid : \"\");\n\t\t}\n\t\telse{\n\t\t\t// retain values for next run\n\t\t\tconfig.set_string_member(\"backup_device_uuid\", backup_uuid);\n\t\t\tconfig.set_string_member(\"parent_device_uuid\", backup_parent_uuid); \n\t\t}\n\n\t\tconfig.set_string_member(\"do_first_run\", false.to_string());\n\t\tconfig.set_string_member(\"btrfs_mode\", btrfs_mode.to_string());\n\t\tconfig.set_string_member(\"include_btrfs_home_for_backup\", include_btrfs_home_for_backup.to_string());\n\t\tconfig.set_string_member(\"include_btrfs_home_for_restore\", include_btrfs_home_for_restore.to_string());\n\t\tconfig.set_string_member(\"stop_cron_emails\", stop_cron_emails.to_string());\n\t\tconfig.set_string_member(\"btrfs_use_qgroup\", btrfs_use_qgroup.to_string());\n\n\t\tconfig.set_string_member(\"schedule_monthly\", schedule_monthly.to_string());\n\t\tconfig.set_string_member(\"schedule_weekly\", schedule_weekly.to_string());\n\t\tconfig.set_string_member(\"schedule_daily\", schedule_daily.to_string());\n\t\tconfig.set_string_member(\"schedule_hourly\", schedule_hourly.to_string());\n\t\tconfig.set_string_member(\"schedule_boot\", schedule_boot.to_string());\n\n\t\tconfig.set_string_member(\"count_monthly\", count_monthly.to_string());\n\t\tconfig.set_string_member(\"count_weekly\", count_weekly.to_string());\n\t\tconfig.set_string_member(\"count_daily\", count_daily.to_string());\n\t\tconfig.set_string_member(\"count_hourly\", count_hourly.to_string());\n\t\tconfig.set_string_member(\"count_boot\", count_boot.to_string());\n\n\t\tconfig.set_string_member(\"snapshot_size\", first_snapshot_size.to_string());\n\t\tconfig.set_string_member(\"snapshot_count\", first_snapshot_count.to_string());\n\n\t\tconfig.set_string_member(\"date_format\", date_format);\n\t\t\n\t\tJson.Array arr = new Json.Array();\n\t\tforeach(string path in exclude_list_user){\n\t\t\tarr.add_string_element(path);\n\t\t}\n\t\tconfig.set_array_member(\"exclude\",arr);\n\n\t\tarr = new Json.Array();\n\t\tforeach(var name in exclude_app_names){\n\t\t\tarr.add_string_element(name);\n\t\t}\n\t\tconfig.set_array_member(\"exclude-apps\",arr);\n\n\t\tvar json = new Json.Generator();\n\t\tjson.pretty = true;\n\t\tjson.indent = 2;\n\t\tvar node = new Json.Node(NodeType.OBJECT);\n\t\tnode.set_object(config);\n\t\tjson.set_root(node);\n\n\t\ttry{\n\t\t\tjson.to_file(this.app_conf_path);\n\t\t} catch (Error e) {\n\t        log_error (e.message);\n\t    }\n\n\t    if ((app_mode == \"\")||(LOG_DEBUG)){\n\t\t\tlog_msg(_(\"App config saved\") + \": %s\".printf(this.app_conf_path));\n\t\t}\n\t}\n\n\tpublic void load_app_config(){\n\n\t\tlog_debug(\"Main: load_app_config()\");\n\n\t\t// check if first run -----------------------\n\t\t\n\t\tvar f = File.new_for_path(this.app_conf_path);\n\t\tif (!f.query_exists()) {\n\t\t\tfile_copy(app_conf_path_default, app_conf_path);\n\t\t}\n\t\tif (!f.query_exists()) {\n\t\t\tset_first_run_flag();\n\t\t\treturn;\n\t\t}\n\n\t\t// load settings from config file --------------------------\n\t\t\n\t\tvar parser = new Json.Parser();\n        try{\n\t\t\tparser.load_from_file(this.app_conf_path);\n\t\t} catch (Error e) {\n\t        log_error (e.message);\n\t    }\n        var node = parser.get_root();\n        var config = node.get_object();\n\n\t\tbool do_first_run = json_get_bool(config, \"do_first_run\", false); // false as default\n\t\t\n\t\tif (do_first_run){\n\t\t\tset_first_run_flag();\n\t\t}\n\n\t\tbtrfs_mode = json_get_bool(config, \"btrfs_mode\", false); // false as default\n\n\t\tif (config.has_member(\"include_btrfs_home\")){\n\t\t\tinclude_btrfs_home_for_backup = json_get_bool(config, \"include_btrfs_home\", include_btrfs_home_for_backup);\n\t\t}\n\t\telse{\n\t\t\tinclude_btrfs_home_for_backup = json_get_bool(config, \"include_btrfs_home_for_backup\", include_btrfs_home_for_backup);\n\t\t}\n\t\t\n\t\tinclude_btrfs_home_for_restore = json_get_bool(config, \"include_btrfs_home_for_restore\", include_btrfs_home_for_restore);\n\t\tstop_cron_emails = json_get_bool(config, \"stop_cron_emails\", stop_cron_emails);\n\t\tbtrfs_use_qgroup = json_get_bool(config, \"btrfs_use_qgroup\", btrfs_use_qgroup);\n\t\t\n\t\tif (cmd_btrfs_mode != null){\n\t\t\tbtrfs_mode = cmd_btrfs_mode; //override\n\t\t}\n\t\t\n\t\tbackup_uuid = json_get_string(config,\"backup_device_uuid\", backup_uuid);\n\t\tbackup_parent_uuid = json_get_string(config,\"parent_device_uuid\", backup_parent_uuid);\n\t\t\n        this.schedule_monthly = json_get_bool(config,\"schedule_monthly\",schedule_monthly);\n\t\tthis.schedule_weekly = json_get_bool(config,\"schedule_weekly\",schedule_weekly);\n\t\tthis.schedule_daily = json_get_bool(config,\"schedule_daily\",schedule_daily);\n\t\tthis.schedule_hourly = json_get_bool(config,\"schedule_hourly\",schedule_hourly);\n\t\tthis.schedule_boot = json_get_bool(config,\"schedule_boot\",schedule_boot);\n\n\t\tthis.count_monthly = json_get_int(config,\"count_monthly\",count_monthly);\n\t\tthis.count_weekly = json_get_int(config,\"count_weekly\",count_weekly);\n\t\tthis.count_daily = json_get_int(config,\"count_daily\",count_daily);\n\t\tthis.count_hourly = json_get_int(config,\"count_hourly\",count_hourly);\n\t\tthis.count_boot = json_get_int(config,\"count_boot\",count_boot);\n\n\t\tthis.date_format = json_get_string(config, \"date_format\", date_format_default);\n\n\t\tMain.first_snapshot_size = json_get_uint64(config,\"snapshot_size\", Main.first_snapshot_size);\n\t\t\t\n\t\tMain.first_snapshot_count = (int64) json_get_uint64(config,\"snapshot_count\", Main.first_snapshot_count);\n\t\t\n\t\texclude_list_user.clear();\n\t\t\n\t\tif (config.has_member (\"exclude\")){\n\t\t\tforeach (Json.Node jnode in config.get_array_member (\"exclude\").get_elements()) {\n\t\t\t\t\n\t\t\t\tstring path = jnode.get_string();\n\t\t\t\t\n\t\t\t\tif (!exclude_list_user.contains(path)\n\t\t\t\t\t&& !exclude_list_default.contains(path)\n\t\t\t\t\t&& !exclude_list_home.contains(path)){\n\t\t\t\t\t\t\n\t\t\t\t\texclude_list_user.add(path);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\texclude_app_names.clear();\n\n\t\tif (config.has_member (\"exclude-apps\")){\n\t\t\tvar apps = config.get_array_member(\"exclude-apps\");\n\t\t\tforeach (Json.Node jnode in apps.get_elements()) {\n\t\t\t\t\n\t\t\t\tstring name = jnode.get_string();\n\t\t\t\t\n\t\t\t\tif (!exclude_app_names.contains(name)){\n\t\t\t\t\texclude_app_names.add(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((app_mode == \"\")||(LOG_DEBUG)){\n\t\t\tlog_msg(_(\"App config loaded\") + \": %s\".printf(this.app_conf_path));\n\t\t}\n\t}\n\n\tpublic void set_first_run_flag(){\n\t\t\n\t\tfirst_run = true;\n\t\t\n\t\tlog_msg(\"First run mode (config file not found)\");\n\n\t\t// load some defaults for first-run based on user's system type\n\t\t\n\t\tbool supported = sys_subvolumes.has_key(\"@\") && cmd_exists(\"btrfs\"); // && sys_subvolumes.has_key(\"@home\")\n\t\tif (supported || (cmd_btrfs_mode == true)){\n\t\t\tlog_msg(_(\"Selected default snapshot type\") + \": %s\".printf(\"BTRFS\"));\n\t\t\tbtrfs_mode = true;\n\t\t}\n\t\telse{\n\t\t\tlog_msg(_(\"Selected default snapshot type\") + \": %s\".printf(\"RSYNC\"));\n\t\t\tbtrfs_mode = false;\n\t\t}\n\t}\n\t\n\tpublic void initialize_repo(){\n\n\t\tlog_debug(\"Main: initialize_repo()\");\n\t\t\n\t\tlog_debug(\"backup_uuid=%s\".printf(backup_uuid));\n\t\tlog_debug(\"backup_parent_uuid=%s\".printf(backup_parent_uuid));\n\n\t\t// use system disk as snapshot device in btrfs mode for backup\n\t\tif (((app_mode == \"backup\")||((app_mode == \"ondemand\"))) && btrfs_mode){\n\t\t\tif (sys_root != null){\n\t\t\t\tlog_msg(\"Using system disk as snapshot device for creating snapshots in BTRFS mode\");\n\t\t\t\tif (cmd_backup_device.length > 0){\n\t\t\t\t\tlog_msg(_(\"Option --snapshot-device should not be specified for creating snapshots in BTRFS mode\"));\n\t\t\t\t}\n\t\t\t\trepo = new SnapshotRepo.from_device(sys_root, parent_window, btrfs_mode);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_error(\"System disk not found!\");\n\t\t\t\texit_app(1);\n\t\t\t}\n\t\t}\n\t\t// initialize repo using command line parameter if specified\n\t\telse if (cmd_backup_device.length > 0){\n\t\t\tvar cmd_dev = Device.get_device_by_name(cmd_backup_device);\n\t\t\tif (cmd_dev != null){\n\t\t\t\tlog_debug(\"Using snapshot device specified as command argument: %s\".printf(cmd_backup_device));\n\t\t\t\trepo = new SnapshotRepo.from_device(cmd_dev, parent_window, btrfs_mode);\n\t\t\t\t// TODO: move this code to main window\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_error(_(\"Device not found\") + \": '%s'\".printf(cmd_backup_device));\n\t\t\t\texit_app(1);\n\t\t\t}\n\t\t}\n\t\t// select default device for first run mode\n\t\telse if (first_run && (backup_uuid.length == 0)){\n\t\t\t\n\t\t\ttry_select_default_device_for_backup(parent_window);\n\n\t\t\tif ((repo != null) && (repo.device != null)){\n\t\t\t\tlog_msg(_(\"Selected default snapshot device\") + \": %s\".printf(repo.device.device));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlog_debug(\"Setting snapshot device from config file\");\n\t\t\t\n\t\t\t// find devices from uuid\n\t\t\tDevice dev = null;\n\t\t\tDevice dev_parent = null;\n\t\t\tif (backup_uuid.length > 0){\n\t\t\t\tdev = Device.get_device_by_uuid(backup_uuid);\n\t\t\t}\n\t\t\tif (backup_parent_uuid.length > 0){\n\t\t\t\tdev_parent = Device.get_device_by_uuid(backup_parent_uuid);\n\t\t\t}\n\n\t\t\t// try unlocking encrypted parent\n\t\t\tif ((dev_parent != null) && dev_parent.is_encrypted_partition() && !dev_parent.has_children()){\n\t\t\t\tlog_debug(\"Snapshot device is on an encrypted partition\");\n\t\t\t\trepo = new SnapshotRepo.from_uuid(backup_parent_uuid, parent_window, btrfs_mode);\n\t\t\t}\n\t\t\t// try device\t\n\t\t\telse if (dev != null){\n\t\t\t\tlog_debug(\"repo: creating from uuid\");\n\t\t\t\trepo = new SnapshotRepo.from_uuid(backup_uuid, parent_window, btrfs_mode);\n\t\t\t}\n\t\t\t// try system disk\n\t\t\t/*else {\n\t\t\t\tlog_debug(\"Could not find device with UUID\" + \": %s\".printf(backup_uuid));\n\t\t\t\tif (sys_root != null){\n\t\t\t\t\tlog_debug(\"Using system disk as snapshot device\");\n\t\t\t\t\trepo = new SnapshotRepo.from_device(sys_root, parent_window, btrfs_mode);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlog_debug(\"System disk not found\");\n\t\t\t\t\trepo = new SnapshotRepo.from_null();\n\t\t\t\t}\n\t\t\t}*/\n\t\t}\n\n\t\t/* Note: In command-line mode, user will be prompted for backup device */\n\n\t\t/* The backup device specified in config file will be mounted at this point if:\n\t\t * 1) app is running in GUI mode, OR\n\t\t * 2) app is running command mode without backup device argument\n\t\t * */\n\n\t\t log_debug(\"Main: initialize_repo(): exit\");\n\t}\n\t\n\t//core functions\n\n\tpublic void update_partitions(){\n\n\t\tlog_debug(\"update_partitions()\");\n\t\t\n\t\tpartitions.clear();\n\t\t\n\t\tpartitions = Device.get_filesystems();\n\n\t\tforeach(var pi in partitions){\n\n\t\t\t// sys_root and sys_home will be detected by detect_system_devices()\n\t\t\tif ((repo != null) && (repo.device != null) && (pi.uuid == repo.device.uuid)){\n\t\t\t\trepo.device = pi;\n\t\t\t}\n\t\t\t\n\t\t\tif (pi.is_mounted){\n\t\t\t\tpi.dist_info = LinuxDistro.get_dist_info(pi.mount_points[0].mount_point).full_name();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (partitions.size == 0){\n\t\t\tlog_error(\"ts: \" + _(\"Failed to get partition list.\"));\n\t\t}\n\n\t\tlog_debug(\"partition list updated\");\n\t}\n\n\tpublic void detect_system_devices(){\n\n\t\tlog_debug(\"detect_system_devices()\");\n\n\t\tsys_root = null;\n\t\tsys_boot = null;\n\t\tsys_efi = null;\n\t\tsys_home = null;\n\n\t\tforeach(var pi in partitions){\n\t\t\t\n\t\t\tforeach(var mp in pi.mount_points){\n\t\t\t\t\n\t\t\t\t// skip loop devices - Fedora Live uses loop devices containing ext4-formatted lvm volumes\n\t\t\t\tif ((pi.type == \"loop\") || (pi.has_parent() && (pi.parent.type == \"loop\"))){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (mp.mount_point == \"/\"){\n\t\t\t\t\tsys_root = pi;\n\t\t\t\t\tif ((app_mode == \"\")||(LOG_DEBUG)){\n\t\t\t\t\t\tstring txt = _(\"/ is mapped to device\") + \": %s, UUID=%s\".printf(pi.device,pi.uuid);\n\t\t\t\t\t\tif (mp.subvolume_name().length > 0){\n\t\t\t\t\t\t\ttxt += \", subvol=%s\".printf(mp.subvolume_name());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlog_debug(txt);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (mp.mount_point == \"/home\"){\n\t\t\t\t\tsys_home = pi;\n\t\t\t\t\tif ((app_mode == \"\")||(LOG_DEBUG)){\n\t\t\t\t\t\tstring txt = _(\"/home is mapped to device\") + \": %s, UUID=%s\".printf(pi.device,pi.uuid);\n\t\t\t\t\t\tif (mp.subvolume_name().length > 0){\n\t\t\t\t\t\t\ttxt += \", subvol=%s\".printf(mp.subvolume_name());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlog_debug(txt);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (mp.mount_point == \"/boot\"){\n\t\t\t\t\tsys_boot = pi;\n\t\t\t\t\tif ((app_mode == \"\")||(LOG_DEBUG)){\n\t\t\t\t\t\tstring txt = _(\"/boot is mapped to device\") + \": %s, UUID=%s\".printf(pi.device,pi.uuid);\n\t\t\t\t\t\tif (mp.subvolume_name().length > 0){\n\t\t\t\t\t\t\ttxt += \", subvol=%s\".printf(mp.subvolume_name());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlog_debug(txt);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (mp.mount_point == \"/boot/efi\"){\n\t\t\t\t\tsys_efi = pi;\n\t\t\t\t\tif ((app_mode == \"\")||(LOG_DEBUG)){\n\t\t\t\t\t\tstring txt = _(\"/boot/efi is mapped to device\") + \": %s, UUID=%s\".printf(pi.device,pi.uuid);\n\t\t\t\t\t\tif (mp.subvolume_name().length > 0){\n\t\t\t\t\t\t\ttxt += \", subvol=%s\".printf(mp.subvolume_name());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlog_debug(txt);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tsys_subvolumes = Subvolume.detect_subvolumes_for_system_by_path(\"/\", null, parent_window);\n\t}\n\n\tpublic bool mount_target_devices(Gtk.Window? parent_win = null){\n\t\t/* Note:\n\t\t * Target device will be mounted explicitly to /mnt/timeshift/restore\n\t\t * Existing mount points are not used since we need to mount other devices in sub-directories\n\t\t * */\n\n\t\tlog_debug(\"mount_target_device()\");\n\t\t\n\t\tif (dst_root == null){\n\t\t\treturn false;\n\t\t}\n\t\n\t\t//check and create restore mount point for restore\n\t\tmount_point_restore = mount_point_app + \"/restore\";\n\t\tdir_create(mount_point_restore);\n\n\t\t/*var already_mounted = false;\n\t\tvar dev_mounted = Device.get_device_by_path(mount_point_restore);\n\t\tif ((dev_mounted != null)\n\t\t\t&& (dev_mounted.uuid == dst_root.uuid)){\n\n\t\t\tforeach(var mp in dev_mounted.mount_points){\n\t\t\t\tif ((mp.mount_point == mount_point_restore)\n\t\t\t\t\t&& (mp.mount_options == \"subvol=@\")){\n\t\t\t\t\t\t\n\t\t\t\t\t = true;\n\t\t\t\t\treturn; //already_mounted\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\t\n\t\t// unmount\n\t\tunmount_target_device();\n\n\t\t// mount root device\n\t\tif (dst_root.fstype == \"btrfs\"){\n\n\t\t\t//check subvolume layout\n\n\t\t\tbool supported = check_btrfs_layout(dst_root, dst_home, false);\n\t\t\t\n\t\t\tif (!supported && snapshot_to_restore.has_subvolumes()){\n\t\t\t\tstring msg = _(\"The target partition has an unsupported subvolume layout.\") + \"\\n\";\n\t\t\t\tmsg += _(\"Only ubuntu-type layouts with @ and @home subvolumes are currently supported.\");\n\n\t\t\t\tif (app_mode == \"\"){\n\t\t\t\t\tstring title = _(\"Unsupported Subvolume Layout\");\n\t\t\t\t\tgtk_messagebox(title, msg, null, true);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlog_error(\"\\n\" + msg);\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// mount all devices\n\t\tforeach (var mnt in mount_list) {\n\n\t\t\tif (mnt.device == null){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// unlock encrypted device\n\t\t\tif (mnt.device.is_encrypted_partition()){\n\n\t\t\t\t// check if unlocked\n\t\t\t\tif (mnt.device.has_children()){\n\t\t\t\t\tmnt.device = mnt.device.children[0];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// prompt user\n\t\t\t\t\tstring msg_out, msg_err;\n\t\t\t\n\t\t\t\t\tvar dev_unlocked = Device.luks_unlock(\n\t\t\t\t\t\tmnt.device, \"\", \"\", parent_win, out msg_out, out msg_err);\n\n\t\t\t\t\t//exit if not found\n\t\t\t\t\tif (dev_unlocked == null){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tmnt.device = dev_unlocked;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring mount_options = \"\";\n\t\t\t\n\t\t\tif (mnt.device.fstype == \"btrfs\"){\n\t\t\t\tif (mnt.mount_point == \"/\"){\n\t\t\t\t\tmount_options = \"subvol=@\";\n\t\t\t\t}\n\t\t\t\tif (include_btrfs_home_for_restore){\n\t\t\t\t\tif (mnt.mount_point == \"/home\"){\n\t\t\t\t\t\tmount_options = \"subvol=@home\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!Device.mount(mnt.device.uuid, mount_point_restore + mnt.mount_point, mount_options)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic void unmount_target_device(bool exit_on_error = true){\n\t\t\n\t\tif (mount_point_restore == null) { return; }\n\n\t\tlog_debug(\"unmount_target_device()\");\n\t\t\n\t\t//unmount the target device only if it was mounted by application\n\t\tif (mount_point_restore.has_prefix(mount_point_app)){   //always true\n\t\t\tunmount_device(mount_point_restore, exit_on_error);\n\t\t}\n\t\telse{\n\t\t\t//don't unmount\n\t\t}\n\t}\n\n\tpublic bool unmount_device(string mount_point, bool exit_on_error = true){\n\t\tbool is_unmounted = Device.unmount(mount_point);\n\t\tif (!is_unmounted){\n\t\t\tif (exit_on_error){\n\t\t\t\tif (app_mode == \"\"){\n\t\t\t\t\tstring title = _(\"Critical Error\");\n\t\t\t\t\tstring msg = _(\"Failed to unmount device!\") + \"\\n\" + _(\"Application will exit\");\n\t\t\t\t\tgtk_messagebox(title, msg, null, true);\n\t\t\t\t}\n\t\t\t\texit_app(1);\n\t\t\t}\n\t\t}\n\t\treturn is_unmounted;\n\t}\n\n\tpublic SnapshotLocationStatus check_backup_location(out string message, out string details){\n\t\trepo.check_status();\n\t\tmessage = repo.status_message;\n\t\tdetails = repo.status_details;\n\t\treturn repo.status_code;\n\t}\n\n\tpublic bool check_btrfs_volume(Device dev, string subvol_names, bool unlock){\n\n\t\tlog_debug(\"check_btrfs_volume():%s\".printf(subvol_names));\n\t\t\n\t\tstring mnt_btrfs = mount_point_app + \"/btrfs\";\n\t\tdir_create(mnt_btrfs);\n\n\t\tif (!dev.is_mounted_at_path(\"\", mnt_btrfs)){\n\t\t\t\n\t\t\tDevice.unmount(mnt_btrfs);\n\n\t\t\t// unlock encrypted device\n\t\t\tif (dev.is_encrypted_partition()){\n\n\t\t\t\tif (unlock){\n\t\t\t\t\t\n\t\t\t\t\tstring msg_out, msg_err;\n\t\t\t\t\tvar dev_unlocked = Device.luks_unlock(\n\t\t\t\t\t\tdev, \"\", \"\", parent_window, out msg_out, out msg_err);\n\t\t\t\t\n\t\t\t\t\tif (dev_unlocked == null){\n\t\t\t\t\t\tlog_debug(\"device is null\");\n\t\t\t\t\t\tlog_debug(\"SnapshotRepo: check_btrfs_volume(): exit\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tDevice.mount(dev_unlocked.uuid, mnt_btrfs, \"\", true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tDevice.mount(dev.uuid, mnt_btrfs, \"\", true);\n\t\t\t}\n\t\t}\n\n\t\tbool supported = true;\n\n\t\tforeach(string subvol_name in subvol_names.split(\",\")){\n\t\t\tsupported = supported && dir_exists(path_combine(mnt_btrfs,subvol_name));\n\t\t}\n\n\t\tif (Device.unmount(mnt_btrfs)){\n\t\t\tif (dir_exists(mnt_btrfs) && (dir_count(mnt_btrfs) == 0)){\n\t\t\t\tdir_delete(mnt_btrfs);\n\t\t\t\tlog_debug(_(\"Removed mount directory: '%s'\").printf(mnt_btrfs));\n\t\t\t}\n\t\t}\n\n\t\treturn supported;\n\t}\n\n\tpublic void try_select_default_device_for_backup(Gtk.Window? parent_win){\n\n\t\tlog_debug(\"try_select_default_device_for_backup()\");\n\n\t\t// check if currently selected device can be used\n\t\tif (repo.available()){\n\t\t\tif (check_device_for_backup(repo.device, false)){\n\t\t\t\tif (repo.btrfs_mode != btrfs_mode){\n\t\t\t\t\t// reinitialize\n\t\t\t\t\trepo = new SnapshotRepo.from_device(repo.device, parent_win, btrfs_mode);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse{\n\t\t\t\trepo = new SnapshotRepo.from_null();\n\t\t\t}\n\t\t}\n\t\t\n\t\tupdate_partitions();\n\n\t\t// In BTRFS mode, select the system disk if system disk is BTRFS\n\t\tif (btrfs_mode && sys_subvolumes.has_key(\"@\")){\n\t\t\tvar subvol_root = sys_subvolumes[\"@\"];\n\t\t\trepo = new SnapshotRepo.from_device(subvol_root.get_device(), parent_win, btrfs_mode);\n\t\t\treturn;\n\t\t}\n\t\t\t\n\t\tforeach(var dev in partitions){\n\t\t\tif (check_device_for_backup(dev, false)){\n\t\t\t\trepo = new SnapshotRepo.from_device(dev, parent_win, btrfs_mode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic bool check_device_for_backup(Device dev, bool unlock){\n\t\tbool ok = false;\n\n\t\tif (dev.type == \"disk\") { return false; }\n\t\tif (dev.has_children()) { return false; }\n\t\t\n\t\tif (btrfs_mode && ((dev.fstype == \"btrfs\")||(dev.fstype == \"luks\"))){\n\t\t\tif (check_btrfs_volume(dev, \"@\", unlock)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse if (!btrfs_mode && dev.has_linux_filesystem()){\n\t\t\t// TODO: check free space\n\t\t\treturn true;\n\t\t}\n\n\t\treturn ok;\n\t}\n\t\n\tpublic uint64 estimate_system_size(){\n\n\t\tlog_debug(\"estimate_system_size()\");\n\t\t\n\t\tif (Main.first_snapshot_size > 0){\n\t\t\treturn Main.first_snapshot_size;\n\t\t}\n\t\telse if (live_system()){\n\t\t\treturn 0;\n\t\t}\n\n\t\ttry {\n\t\t\tthread_estimate_running = true;\n\t\t\tthr_success = false;\n\t\t\tThread.create<void> (estimate_system_size_thread, true);\n\t\t} catch (ThreadError e) {\n\t\t\tthread_estimate_running = false;\n\t\t\tthr_success = false;\n\t\t\tlog_error (e.message);\n\t\t}\n\n\t\twhile (thread_estimate_running){\n\t\t\tgtk_do_events ();\n\t\t\tThread.usleep((ulong) GLib.TimeSpan.MILLISECOND * 100);\n\t\t}\n\n\t\tsave_app_config();\n\n\t\tlog_debug(\"estimate_system_size(): ok\");\n\t\t\n\t\treturn Main.first_snapshot_size;\n\t}\n\n\tpublic void estimate_system_size_thread(){\n\t\tthread_estimate_running = true;\n\n\t\tstring cmd = \"\";\n\t\tstring std_out;\n\t\tstring std_err;\n\t\tint ret_val;\n\t\tuint64 required_space = 0;\n\t\tint64 file_count = 0;\n\n\t\ttry{\n\n\t\t\tlog_debug(\"Using temp dir '%s'\".printf(TEMP_DIR));\n\n\t\t\tstring file_exclude_list = path_combine(TEMP_DIR, \"exclude.list\");\n\t\t\tvar f = File.new_for_path(file_exclude_list);\n\t\t\tif (f.query_exists()){\n\t\t\t\tf.delete();\n\t\t\t}\n\n\t\t\tstring file_log = path_combine(TEMP_DIR, \"rsync.log\");\n\t\t\tf = File.new_for_path(file_log);\n\t\t\tif (f.query_exists()){\n\t\t\t\tf.delete();\n\t\t\t}\n\n\t\t\tstring dir_empty = path_combine(TEMP_DIR, \"empty\");\n\t\t\tf = File.new_for_path(dir_empty);\n\t\t\tif (!f.query_exists()){\n\t\t\t\tdir_create(dir_empty);\n\t\t\t}\n\n\t\t\tsave_exclude_list_for_backup(TEMP_DIR);\n\t\t\t\n\t\t\tcmd  = \"LC_ALL=C ; rsync -ai --delete --numeric-ids --relative --stats --dry-run --delete-excluded --exclude-from='%s' /. '%s' &> '%s'\".printf(file_exclude_list, dir_empty, file_log);\n\n\t\t\tlog_debug(cmd);\n\t\t\tret_val = exec_script_sync(cmd, out std_out, out std_err);\n\n\t\t\tif (file_exists(file_log)){\n\t\t\t\tcmd = \"cat '%s' | awk '/Total file size/ {print $4}'\".printf(file_log);\n\t\t\t\tret_val = exec_script_sync(cmd, out std_out, out std_err);\n\t\t\t\tif (ret_val == 0){\n\t\t\t\t\trequired_space = long.parse(std_out.replace(\",\",\"\").strip());\n\n\t\t\t\t\tcmd = \"wc -l '%s'\".printf(escape_single_quote(file_log));\n\t\t\t\t\tret_val = exec_script_sync(cmd, out std_out, out std_err);\n\t\t\t\t\tif (ret_val == 0){\n\t\t\t\t\t\tfile_count = long.parse(std_out.split(\" \")[0].strip());\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthr_success = true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlog_error (_(\"Failed to estimate system size\"));\n\t\t\t\t\tlog_error (std_err);\n\t\t\t\t\tthr_success = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_error (_(\"Failed to estimate system size\"));\n\t\t\t\tlog_error (std_err);\n\t\t\t\tlog_error (std_out);\n\t\t\t\tthr_success = false;\n\t\t\t}\n\t\t}\n\t\tcatch(Error e){\n\t\t\tlog_error (e.message);\n\t\t\tthr_success = false;\n\t\t}\n\n\t\tif ((required_space == 0) && (sys_root != null)){\n\t\t\trequired_space = sys_root.used_bytes;\n\t\t}\n\n\t\tMain.first_snapshot_size = required_space;\n\t\tMain.first_snapshot_count = file_count;\n\n\t\tlog_debug(\"First snapshot size: %s\".printf(format_file_size(required_space)));\n\t\tlog_debug(\"File count: %lld\".printf(first_snapshot_count));\n\n\t\tthread_estimate_running = false;\n\t}\n\n\t// btrfs\n\n\tpublic void query_subvolume_info(SnapshotRepo parent_repo){\n\n\t\t// SnapshotRepo contructor calls this code in load_snapshots()\n\t\t// save the new object reference to repo since repo still holds previous object\n\t\trepo = parent_repo;\n\n\t\t// TODO: move query_subvolume_info() and related methods to SnapshotRepo\n\t\t\n\t\tif ((repo == null) || !repo.btrfs_mode){\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlog_debug(_(\"Querying subvolume info...\"));\n\t\t\n\t\ttry {\n\t\t\tthread_subvol_info_running = true;\n\t\t\tthread_subvol_info_success = false;\n\t\t\tThread.create<void> (query_subvolume_info_thread, true);\n\t\t} catch (ThreadError e) {\n\t\t\tthread_subvol_info_running = false;\n\t\t\tthread_subvol_info_success = false;\n\t\t\tlog_error (e.message);\n\t\t}\n\n\t\twhile (thread_subvol_info_running){\n\t\t\tgtk_do_events ();\n\t\t\tThread.usleep((ulong) GLib.TimeSpan.MILLISECOND * 100);\n\t\t}\n\n\t\tlog_debug(_(\"Query completed\"));\n\t}\n\n\tpublic void query_subvolume_info_thread(){\n\t\t\n\t\tthread_subvol_info_running = true;\n\n\t\t//query IDs\n\t\tbool ok = query_subvolume_ids();\n\t\t\n\t\tif (!ok){\n\t\t\tthread_subvol_info_success = false;\n\t\t\tthread_subvol_info_running = false;\n\t\t\treturn;\n\t\t}\n\n\t\t//query quota\n\t\tok = query_subvolume_quotas();\n\t\t\n\t\tif (!ok){\n\n\t\t\tif (btrfs_use_qgroup){\n\t\t\t\t\n\t\t\t\t//try enabling quota\n\t\t\t\tok = enable_subvolume_quotas();\n\t\t\t\tif (!ok){\n\t\t\t\t\tthread_subvol_info_success = false;\n\t\t\t\t\tthread_subvol_info_running = false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//query quota again\n\t\t\t\tok = query_subvolume_quotas();\n\t\t\t\tif (!ok){\n\t\t\t\t\tthread_subvol_info_success = false;\n\t\t\t\t\tthread_subvol_info_running = false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthread_subvol_info_success = true;\n\t\tthread_subvol_info_running = false;\n\t\treturn;\n\t}\n\n\tpublic bool query_subvolume_ids(){\n\t\tbool ok = query_subvolume_id(\"@\");\n\t\tif ((repo.device_home != null) && (repo.device.uuid != repo.device_home.uuid)){\n\t\t\tok = ok && query_subvolume_id(\"@home\");\n\t\t}\n\t\treturn ok;\n\t}\n\t\n\tpublic bool query_subvolume_id(string subvol_name){\n\n\t\tlog_debug(\"query_subvolume_id():%s\".printf(subvol_name));\n\t\t\n\t\tstring cmd = \"\";\n\t\tstring std_out;\n\t\tstring std_err;\n\t\tint ret_val;\n\n\t\tcmd = \"btrfs subvolume list '%s'\".printf(repo.mount_paths[subvol_name]);\n\t\tlog_debug(cmd);\n\t\tret_val = exec_sync(cmd, out std_out, out std_err);\n\t\tif (ret_val != 0){\n\t\t\tlog_error (std_err);\n\t\t\tlog_error(_(\"btrfs returned an error\") + \": %d\".printf(ret_val));\n\t\t\tlog_error(_(\"Failed to query subvolume list\"));\n\t\t\treturn false;\n\t\t}\n\n\t\t/* Sample Output:\n\t\t *\n\t\tID 257 gen 56 top level 5 path timeshift-btrfs/snapshots/2014-09-26_23-34-08/@\n\t\tID 258 gen 52 top level 5 path timeshift-btrfs/snapshots/2014-09-26_23-34-08/@home\n\t\t* */\n\n\t\tforeach(string line in std_out.split(\"\\n\")){\n\t\t\tif (line == null) { continue; }\n\n\t\t\tstring[] parts = line.split(\" \");\n\t\t\tif (parts.length < 2) { continue; }\n\n\t\t\tSubvolume subvol = null;\n\n\t\t\tif ((sys_subvolumes.size > 0) && line.has_suffix(sys_subvolumes[\"@\"].path.replace(repo.mount_paths[\"@\"] + \"/\",\" \"))){\n\t\t\t\tsubvol = sys_subvolumes[\"@\"];\n\t\t\t}\n\t\t\telse if ((sys_subvolumes.size > 0)\n\t\t\t\t&& sys_subvolumes.has_key(\"@home\")\n\t\t\t\t&& line.has_suffix(sys_subvolumes[\"@home\"].path.replace(repo.mount_paths[\"@home\"] + \"/\",\" \"))){\n\t\t\t\t\t\n\t\t\t\tsubvol = sys_subvolumes[\"@home\"];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tforeach(var bak in repo.snapshots){\n\t\t\t\t\tforeach(var sub in bak.subvolumes.values){\n\t\t\t\t\t\tif (line.has_suffix(sub.path.replace(repo.mount_paths[sub.name] + \"/\",\"\"))){\n\t\t\t\t\t\t\tsubvol = sub;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (subvol != null){\n\t\t\t\tsubvol.id = long.parse(parts[1]);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic bool query_subvolume_quotas(){\n\n\t\tbool ok = query_subvolume_quota(\"@\");\n\t\tif (repo.device.uuid != repo.device_home.uuid){\n\t\t\tok = ok && query_subvolume_quota(\"@home\");\n\t\t}\n\t\treturn ok;\n\t}\n\t\n\tpublic bool query_subvolume_quota(string subvol_name){\n\n\t\tlog_debug(\"query_subvolume_quota():%s\".printf(subvol_name));\n\t\t\n\t\tstring cmd = \"\";\n\t\tstring std_out;\n\t\tstring std_err;\n\t\tint ret_val;\n\n\t\tstring options = use_option_raw ? \"--raw\" : \"\";\n\t\t\n\t\tcmd = \"btrfs qgroup show %s '%s'\".printf(options, repo.mount_paths[subvol_name]);\n\t\tlog_debug(cmd);\n\t\tret_val = exec_sync(cmd, out std_out, out std_err);\n\t\t\n\t\tif (ret_val != 0){\n\t\t\t\n\t\t\tif (use_option_raw){\n\t\t\t\tuse_option_raw = false;\n\n\t\t\t\t// try again without --raw option\n\t\t\t\tcmd = \"btrfs qgroup show '%s'\".printf(repo.mount_paths[subvol_name]);\n\t\t\t\tlog_debug(cmd);\n\t\t\t\tret_val = exec_sync(cmd, out std_out, out std_err);\n\t\t\t}\t\n\t\t\t\n\t\t\tif (ret_val != 0){\n\t\t\t\tlog_error (std_err);\n\t\t\t\tlog_error(_(\"btrfs returned an error\") + \": %d\".printf(ret_val));\n\t\t\t\tlog_error(_(\"Failed to query subvolume quota\"));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t/* Sample Output:\n\t\t *\n\t\tqgroupid rfer       excl\n\t\t-------- ----       ----\n\t\t0/5      106496     106496\n\t\t0/257    3825262592 557056\n\t\t0/258    12689408   49152\n\t\t * */\n\n\t\tforeach(string line in std_out.split(\"\\n\")){\n\t\t\tif (line == null) { continue; }\n\n\t\t\tstring[] parts = line.split(\" \");\n\t\t\tif (parts.length < 3) { continue; }\n\t\t\tif (parts[0].split(\"/\").length < 2) { continue; }\n\n\t\t\tint subvol_id = int.parse(parts[0].split(\"/\")[1]);\n\n\t\t\tSubvolume subvol = null;\n\n\t\t\tif ((sys_subvolumes.size > 0) && (sys_subvolumes[\"@\"].id == subvol_id)){\n\t\t\t\t\n\t\t\t\tsubvol = sys_subvolumes[\"@\"];\n\t\t\t}\n\t\t\telse if ((sys_subvolumes.size > 0)\n\t\t\t\t&& sys_subvolumes.has_key(\"@home\")\n\t\t\t\t&& (sys_subvolumes[\"@home\"].id == subvol_id)){\n\t\t\t\t\t\n\t\t\t\tsubvol = sys_subvolumes[\"@home\"];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tforeach(var bak in repo.snapshots){\n\t\t\t\t\tforeach(var sub in bak.subvolumes.values){\n\t\t\t\t\t\tif (sub.id == subvol_id){\n\t\t\t\t\t\t\tsubvol = sub;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (subvol != null){\n\t\t\t\tint part_num = -1;\n\t\t\t\tforeach(string part in parts){\n\t\t\t\t\tif (part.strip().length > 0){\n\t\t\t\t\t\tpart_num ++;\n\t\t\t\t\t\tswitch (part_num){\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tsubvol.total_bytes = int64.parse(part);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tsubvol.unshared_bytes = int64.parse(part);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t//ignore\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tforeach(var bak in repo.snapshots){\n\t\t\tbak.update_control_file();\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic bool enable_subvolume_quotas(){\n\n\t\tif (!btrfs_use_qgroup){ return false; }\n\t\t\n\t\tbool ok = enable_subvolume_quota(\"@\");\n\t\t\n\t\tif (repo.device.uuid != repo.device_home.uuid){\n\t\t\tok = ok && enable_subvolume_quota(\"@home\");\n\t\t}\n\t\tif (ok){\n\t\t\tlog_msg(_(\"Enabled subvolume quota support\"));\n\t\t}\n\t\t\n\t\treturn ok;\n\t}\n\t\n\tpublic bool enable_subvolume_quota(string subvol_name){\n\n\t\tif (!btrfs_use_qgroup){ return false; }\n\t\t\n\t\tlog_debug(\"enable_subvolume_quota():%s\".printf(subvol_name));\n\t\t\n\t\tstring cmd = \"\";\n\t\tstring std_out;\n\t\tstring std_err;\n\t\tint ret_val;\n\n\t\tcmd = \"btrfs quota enable '%s'\".printf(repo.mount_paths[subvol_name]);\n\t\tlog_debug(cmd);\n\t\t\n\t\tret_val = exec_sync(cmd, out std_out, out std_err);\n\t\t\n\t\tif (ret_val != 0){\n\t\t\tlog_error (std_err);\n\t\t\tlog_error(_(\"btrfs returned an error\") + \": %d\".printf(ret_val));\n\t\t\tlog_error(_(\"Failed to enable subvolume quota\"));\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic bool rescan_subvolume_quotas(){\n\t\t\n\t\tbool ok = rescan_subvolume_quota(\"@\");\n\t\t\n\t\tif (repo.device.uuid != repo.device_home.uuid){\n\t\t\tok = ok && rescan_subvolume_quota(\"@home\");\n\t\t}\n\t\tif (ok){\n\t\t\tlog_msg(_(\"Enabled subvolume quota support\"));\n\t\t}\n\t\t\n\t\treturn ok;\n\t}\n\t\n\tpublic bool rescan_subvolume_quota(string subvol_name){\n\n\t\tlog_debug(\"rescan_subvolume_quota():%s\".printf(subvol_name));\n\t\t\n\t\tstring cmd = \"\";\n\t\tstring std_out;\n\t\tstring std_err;\n\t\tint ret_val;\n\n\t\tcmd = \"btrfs quota rescan '%s'\".printf(repo.mount_paths[subvol_name]);\n\t\tlog_debug(cmd);\n\t\t\n\t\tret_val = exec_sync(cmd, out std_out, out std_err);\n\t\t\n\t\tif (ret_val != 0){\n\t\t\t\n\t\t\tlog_error (std_err);\n\t\t\tlog_error(_(\"btrfs returned an error\") + \": %d\".printf(ret_val));\n\t\t\tlog_error(_(\"Failed to rescan subvolume quota\"));\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t// cron jobs\n\n\tpublic void cron_job_update(){\n\t\t\n\t\tif (live_system()) { return; }\n\n\t\t// remove entries created by previous versions -----------\n\t\t\n\t\tstring entry = \"timeshift --backup\";\n\n\t\tint count = 0;\n\t\twhile (CronTab.has_job(entry, true, false)){\n\t\t\t\n\t\t\tCronTab.remove_job(entry, true, true);\n\t\t\t\n\t\t\tif (++count == 100){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tentry = \"timeshift-btrfs --backup\";\n\n\t\tcount = 0;\n\t\twhile (CronTab.has_job(entry, true, false)){\n\t\t\t\n\t\t\tCronTab.remove_job(entry, true, true);\n\t\t\t\n\t\t\tif (++count == 100){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tCronTab.remove_script_file(\"timeshift-hourly\", \"hourly\");\n\t\t\t\n\t\t// start update ---------------------------\n\t\t\n\t\tif (scheduled){\n\t\t\t\n\t\t\t//hourly\n\t\t\tCronTab.add_script_file(\"timeshift-hourly\", \"d\", \"0 * * * * root timeshift --check --scripted\", stop_cron_emails);\n\t\t\t\n\t\t\t//boot\n\t\t\tif (schedule_boot){\n\t\t\t\tCronTab.add_script_file(\"timeshift-boot\", \"d\", \"@reboot root sleep 10m && timeshift --create --scripted --tags B\", stop_cron_emails);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tCronTab.remove_script_file(\"timeshift-boot\", \"d\");\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tCronTab.remove_script_file(\"timeshift-hourly\", \"d\");\n\t\t\tCronTab.remove_script_file(\"timeshift-boot\", \"d\");\n\t\t}\n\t}\n\t\n\t// cleanup\n\n\tpublic void clean_logs(){\n\n\t\tlog_debug(\"clean_logs()\");\n\t\t\n\t\tGee.ArrayList<string> list = new Gee.ArrayList<string>();\n\n\t\ttry{\n\t\t\tvar dir = File.new_for_path (log_dir);\n\t\t\tvar enumerator = dir.enumerate_children (\"*\", 0);\n\n\t\t\tvar info = enumerator.next_file ();\n\t\t\tstring path;\n\n\t\t\twhile (info != null) {\n\t\t\t\tif (info.get_file_type() == FileType.REGULAR) {\n\t\t\t\t\tpath = log_dir + \"/\" + info.get_name();\n\t\t\t\t\tif (path != log_file) {\n\t\t\t\t\t\tlist.add(path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinfo = enumerator.next_file ();\n\t\t\t}\n\n\t\t\tCompareDataFunc<string> compare_func = (a, b) => {\n\t\t\t\treturn strcmp(a,b);\n\t\t\t};\n\n\t\t\tlist.sort((owned) compare_func);\n\n\t\t\tif (list.size > 500){\n\n\t\t\t\t// delete oldest 100 files ---------------\n\n\t\t\t\tfor(int k = 0; k < 100; k++){\n\t\t\t\t\t\n\t\t\t\t\tvar file = File.new_for_path (list[k]);\n\t\t\t\t\t \n\t\t\t\t\tif (file.query_exists()){ \n\t\t\t\t\t\tfile.delete();\n\t\t\t\t\t\tlog_msg(\"%s: %s\".printf(_(\"Removed\"), list[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n            \n\t\t\t\tlog_msg(_(\"Older log files removed\"));\n\t\t\t}\n\t\t}\n\t\tcatch(Error e){\n\t\t\tlog_error (e.message);\n\t\t}\n\t}\n\n\tpublic void exit_app (int exit_code = 0){\n\n\t\tlog_debug(\"exit_app()\");\n\t\t\n\t\tif (app_mode == \"\"){\n\t\t\t//update app config only in GUI mode\n\t\t\tsave_app_config();\n\t\t}\n\n\t\tcron_job_update();\n\n\t\tunmount_target_device(false);\n\n\t\tclean_logs();\n\n\t\tapp_lock.remove();\n\t\t\n\t\tdir_delete(TEMP_DIR);\n\n\t\texit(exit_code);\n\n\t\t//Gtk.main_quit ();\n\t}\n}\n\n\n\n\n", "\n/*\n * TeeJee.FileSystem.vala\n *\n * Copyright 2012-2018 Tony George <teejeetech@gmail.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n * MA 02110-1301, USA.\n *\n *\n */\n \nnamespace TeeJee.FileSystem{\n\n\t/* Convenience functions for handling files and directories */\n\n\tusing TeeJee.Logging;\n\tusing TeeJee.ProcessHelper;\n\tusing TeeJee.Misc;\n\n\n\tpublic const int64 KB = 1000;\n\tpublic const int64 MB = 1000 * KB;\n\tpublic const int64 GB = 1000 * MB;\n\tpublic const int64 TB = 1000 * GB;\n\tpublic const int64 KiB = 1024;\n\tpublic const int64 MiB = 1024 * KiB;\n\tpublic const int64 GiB = 1024 * MiB;\n\tpublic const int64 TiB = 1024 * GiB;\n\t\n\t// path helpers ----------------------------\n\t\n\tpublic string file_parent(string file_path){\n\t\treturn File.new_for_path(file_path).get_parent().get_path();\n\t}\n\n\tpublic string file_basename(string file_path){\n\t\treturn File.new_for_path(file_path).get_basename();\n\t}\n\n\tpublic string path_combine(string path1, string path2){\n\t\treturn GLib.Path.build_path(\"/\", path1, path2);\n\t}\n\n\tpublic string remove_trailing_slash(string path){\n\t\tif (path.has_suffix(\"/\")){\n\t\t\treturn path[0:path.length - 1];\n\t\t}\n\t\telse{\n\t\t\treturn path;\n\t\t}\n\t}\n\t\n\t// file helpers -----------------------------\n\n\tpublic bool file_or_dir_exists(string item_path){\n\t\t\n\t\t/* check if item exists on disk*/\n\n\t\tvar item = File.parse_name(item_path);\n\t\treturn item.query_exists();\n\t}\n\t\n\tpublic bool file_exists (string file_path){\n\t\t/* Check if file exists */\n\t\treturn (FileUtils.test(file_path, GLib.FileTest.EXISTS)\n\t\t\t&& !FileUtils.test(file_path, GLib.FileTest.IS_DIR));\n\t}\n\n\tpublic bool file_exists_regular (string file_path){\n\t\t/* Check if file exists */\n\t\treturn ( FileUtils.test(file_path, GLib.FileTest.EXISTS)\n\t\t&& FileUtils.test(file_path, GLib.FileTest.IS_REGULAR));\n\t}\n\n\tpublic bool file_delete(string file_path){\n\n\t\t/* Check and delete file */\n\n\t\ttry {\n\t\t\tvar file = File.new_for_path (file_path);\n\t\t\tif (file.query_exists ()) {\n\t\t\t\tfile.delete ();\n\t\t\t}\n\t\t\treturn true;\n\t\t} catch (Error e) {\n\t        log_error (e.message);\n\t        log_error(_(\"Failed to delete file\") + \": %s\".printf(file_path));\n\t        return false;\n\t    }\n\t}\n\n\tpublic bool file_move_to_trash(string file_path){\n\n\t\t/* Check and delete file */\n\n\t\tvar file = File.new_for_path (file_path);\n\t\tif (file.query_exists ()) {\n\t\t\tPosix.system(\"gvfs-trash '%s'\".printf(escape_single_quote(file_path)));\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic bool file_shred(string file_path){\n\n\t\t/* Check and delete file */\n\n\t\tvar file = File.new_for_path (file_path);\n\t\tif (file.query_exists ()) {\n\t\t\tPosix.system(\"shred -u '%s'\".printf(escape_single_quote(file_path)));\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic int64 file_line_count (string file_path){\n\t\t/* Count number of lines in text file */\n\t\tstring cmd = \"wc -l '%s'\".printf(escape_single_quote(file_path));\n\t\tstring std_out, std_err;\n\t\texec_sync(cmd, out std_out, out std_err);\n\t\treturn long.parse(std_out.split(\"\\t\")[0]);\n\t}\n\n\tpublic string? file_read (string file_path){\n\n\t\t/* Reads text from file */\n\n\t\tstring txt;\n\t\tsize_t size;\n\n\t\ttry{\n\t\t\tGLib.FileUtils.get_contents (file_path, out txt, out size);\n\t\t\treturn txt;\n\t\t}\n\t\tcatch (Error e){\n\t        log_error (e.message);\n\t        log_error(_(\"Failed to read file\") + \": %s\".printf(file_path));\n\t    }\n\n\t    return null;\n\t}\n\n\tpublic bool file_write (string file_path, string contents){\n\n\t\t/* Write text to file */\n\n\t\ttry{\n\n\t\t\tdir_create(file_parent(file_path));\n\t\t\t\n\t\t\tvar file = File.new_for_path (file_path);\n\t\t\tif (file.query_exists ()) {\n\t\t\t\tfile.delete ();\n\t\t\t}\n\t\t\t\n\t\t\tvar file_stream = file.create (FileCreateFlags.REPLACE_DESTINATION);\n\t\t\tvar data_stream = new DataOutputStream (file_stream);\n\t\t\tdata_stream.put_string (contents);\n\t\t\tdata_stream.close();\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tlog_error (e.message);\n\t\t\tlog_error(_(\"Failed to write file\") + \": %s\".printf(file_path));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic bool file_copy (string src_file, string dest_file){\n\t\ttry{\n\t\t\tvar file_src = File.new_for_path (src_file);\n\t\t\tif (file_src.query_exists()) {\n\t\t\t\tvar file_dest = File.new_for_path (dest_file);\n\t\t\t\tfile_src.copy(file_dest,FileCopyFlags.OVERWRITE,null,null);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch(Error e){\n\t        log_error (e.message);\n\t        log_error(_(\"Failed to copy file\") + \": '%s', '%s'\".printf(src_file, dest_file));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic void file_move (string src_file, string dest_file){\n\t\ttry{\n\t\t\tvar file_src = File.new_for_path (src_file);\n\t\t\tif (file_src.query_exists()) {\n\t\t\t\tvar file_dest = File.new_for_path (dest_file);\n\t\t\t\tfile_src.move(file_dest,FileCopyFlags.OVERWRITE,null,null);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_error(_(\"File not found\") + \": '%s'\".printf(src_file));\n\t\t\t}\n\t\t}\n\t\tcatch(Error e){\n\t        log_error (e.message);\n\t        log_error(_(\"Failed to move file\") + \": '%s', '%s'\".printf(src_file, dest_file));\n\t\t}\n\t}\n\n\tpublic bool file_is_symlink(string file_path){\n\n\t\ttry {\n\t\t\tvar file = File.new_for_path (file_path);\n\t\t\t\n\t\t\tif (file.query_exists()) {\n\n\t\t\t\tvar info = file.query_info(\"%s\".printf(FileAttribute.STANDARD_TYPE), FileQueryInfoFlags.NOFOLLOW_SYMLINKS); // don't follow symlinks\n\n\t\t\t\tvar file_type = info.get_file_type();\n\n\t\t\t\treturn (file_type == FileType.SYMBOLIC_LINK);\n\t\t\t}\n\t\t}\n\t\tcatch (Error e) {\n\t        log_error (e.message);\n\t    }\n\t    \n\t\treturn false;\n\t}\n\n\tpublic bool file_gzip (string src_file){\n\t\t\n\t\tstring dst_file = src_file + \".gz\";\n\t\tfile_delete(dst_file);\n\t\t\n\t\tstring cmd = \"gzip '%s'\".printf(escape_single_quote(src_file));\n\t\tstring std_out, std_err;\n\t\texec_sync(cmd, out std_out, out std_err);\n\t\t\n\t\treturn file_exists(dst_file);\n\t}\n\n\tpublic bool file_gunzip (string src_file){\n\t\t\n\t\tstring dst_file = src_file;\n\t\tfile_delete(dst_file);\n\t\t\n\t\tstring cmd = \"gunzip '%s'\".printf(escape_single_quote(src_file));\n\t\tstring std_out, std_err;\n\t\texec_sync(cmd, out std_out, out std_err);\n\t\t\n\t\treturn file_exists(dst_file);\n\t}\n\n\tpublic string file_resolve_executable_path(string file_path){\n\n\t\tif (file_path.has_prefix(\"/\")){\n\t\t\treturn file_path;\n\t\t}\n\t\telse if (!file_path.contains(\"/\")){\n\t\t\treturn GLib.Environment.find_program_in_path(file_path);\n\t\t}\n\t\telse if (file_path.has_prefix(\"./\")){\n\t\t\treturn path_combine(GLib.Environment.get_current_dir(), file_path[2:file_path.length]);\n\t\t}\n\t\telse if (file_path.has_prefix(\"../\")){\n\t\t\treturn path_combine(file_parent(GLib.Environment.get_current_dir()), file_path[3:file_path.length]);\n\t\t}\n\t\telse {\n\t\t\treturn path_combine(GLib.Environment.get_current_dir(), file_path);\n\t\t}\n\t}\n\t\n\t// file info -----------------\n\n\tpublic int64 file_get_size(string file_path){\n\t\t\n\t\ttry{\n\t\t\t\n\t\t\tFile file = File.parse_name (file_path);\n\t\t\t\n\t\t\tif (FileUtils.test(file_path, GLib.FileTest.EXISTS)){\n\t\t\t\t\n\t\t\t\tif (FileUtils.test(file_path, GLib.FileTest.IS_REGULAR)\n\t\t\t\t\t&& !FileUtils.test(file_path, GLib.FileTest.IS_SYMLINK)){\n\t\t\t\t\t\t\n\t\t\t\t\treturn file.query_info(\"standard::size\",0).get_size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch(Error e){\n\t\t\tlog_error (e.message);\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tpublic DateTime file_get_modified_date(string file_path){\n\t\ttry{\n\t\t\tFileInfo info;\n\t\t\tFile file = File.parse_name (file_path);\n\t\t\tif (file.query_exists()) {\n\t\t\t\tinfo = file.query_info(\"%s\".printf(FileAttribute.TIME_MODIFIED), 0);\n\t\t\t\treturn (new DateTime.from_timeval_utc(info.get_modification_time())).to_local();\n\t\t\t}\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tlog_error (e.message);\n\t\t}\n\t\t\n\t\treturn (new DateTime.from_unix_utc(0)); //1970\n\t}\n\t\n\tpublic string file_get_symlink_target(string file_path){\n\t\ttry{\n\t\t\tFileInfo info;\n\t\t\tFile file = File.parse_name (file_path);\n\t\t\tif (file.query_exists()) {\n\t\t\t\tinfo = file.query_info(\"%s\".printf(FileAttribute.STANDARD_SYMLINK_TARGET), 0);\n\t\t\t\treturn info.get_symlink_target();\n\t\t\t}\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tlog_error (e.message);\n\t\t}\n\t\t\n\t\treturn \"\";\n\t}\n\n\t// directory helpers ----------------------\n\t\n\tpublic bool dir_exists (string dir_path){\n\t\t/* Check if directory exists */\n\t\treturn ( FileUtils.test(dir_path, GLib.FileTest.EXISTS) && FileUtils.test(dir_path, GLib.FileTest.IS_DIR));\n\t}\n\t\n\tpublic bool dir_create (string dir_path, bool show_message = false){\n\n\t\t/* Creates a directory along with parents */\n\n\t\ttry{\n\t\t\tvar dir = File.parse_name (dir_path);\n\t\t\t\n\t\t\tif (dir.query_exists () == false) {\n\t\t\t\t\n\t\t\t\tbool ok = dir.make_directory_with_parents (null);\n\t\t\t\t\n\t\t\t\tif (show_message){\n\t\t\t\t\tif (ok){\n\t\t\t\t\t\tlog_msg(_(\"Created directory\") + \": %s\".printf(dir_path));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlog_error(_(\"Failed to create directory\") + \": %s\".printf(dir_path));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tlog_error (e.message);\n\t\t\tlog_error(_(\"Failed to create directory\") + \": %s\".printf(dir_path));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic bool dir_delete (string dir_path, bool show_message = false){\n\t\t\n\t\t/* Recursively deletes directory along with contents */\n\t\t\n\t\tif (!dir_exists(dir_path)){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tstring cmd = \"rm -rf '%s'\".printf(escape_single_quote(dir_path));\n\t\t\n\t\tlog_debug(cmd);\n\t\t\n\t\tstring std_out, std_err;\n\t\tint status = exec_sync(cmd, out std_out, out std_err);\n\t\t\n\t\tif (show_message){\n\t\t\tif (status == 0){\n\t\t\t\tlog_msg(_(\"Deleted directory\") + \": %s\".printf(dir_path));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_error(_(\"Failed to delete directory\") + \": %s\".printf(dir_path));\n\t\t\t\tlog_error(std_out);\n\t\t\t\tlog_error(std_err);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn (status == 0);\n\t}\n\n\tpublic bool dir_move_to_trash (string dir_path){\n\t\treturn file_move_to_trash(dir_path);\n\t}\n\t\n\tpublic bool dir_is_empty (string dir_path){\n\n\t\t/* Check if directory is empty */\n\n\t\ttry{\n\t\t\tbool is_empty = true;\n\t\t\tvar dir = File.parse_name (dir_path);\n\t\t\tif (dir.query_exists()) {\n\t\t\t\tFileInfo info;\n\t\t\t\tvar enu = dir.enumerate_children (\"%s\".printf(FileAttribute.STANDARD_NAME), 0);\n\t\t\t\twhile ((info = enu.next_file()) != null) {\n\t\t\t\t\tis_empty = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn is_empty;\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tlog_error (e.message);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic bool filesystem_supports_hardlinks(string path, out bool is_readonly){\n\t\tbool supports_hardlinks = false;\n\t\tis_readonly = false;\n\t\t\n\t\tvar test_file = path_combine(path, random_string() + \"~\");\n\t\t\n\t\tif (file_write(test_file,\"\")){\n\t\t\t\n\t\t\tvar test_file2 = path_combine(path, random_string() + \"~\");\n\n\t\t\tvar cmd = \"ln '%s' '%s'\".printf(\n\t\t\t\tescape_single_quote(test_file),\n\t\t\t\tescape_single_quote(test_file2));\n\t\t\t\t\n\t\t\tlog_debug(cmd);\n\n\t\t\tint status = exec_sync(cmd);\n\n\t\t\tcmd = \"stat --printf '%%h' '%s'\".printf(\n\t\t\t\tescape_single_quote(test_file));\n\n\t\t\tlog_debug(cmd);\n\t\t\t\n\t\t\tstring std_out, std_err;\n\t\t\tstatus = exec_sync(cmd, out std_out, out std_err);\n\t\t\tlog_debug(\"stdout: %s\".printf(std_out));\n\t\t\t\n\t\t\tint64 count = 0;\n\t\t\tif (int64.try_parse(std_out, out count)){\n\t\t\t\tif (count > 1){\n\t\t\t\t\tsupports_hardlinks = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfile_delete(test_file2); // delete if exists\n\t\t\tfile_delete(test_file);\n\t\t}\n\t\telse{\n\t\t\tis_readonly = true;\n\t\t}\n\n\t\treturn supports_hardlinks;\n\t}\n\n\tpublic Gee.ArrayList<string> dir_list_names(string path){\n\t\tvar list = new Gee.ArrayList<string>();\n\t\t\n\t\ttry\n\t\t{\n\t\t\tFile f_home = File.new_for_path (path);\n\t\t\tFileEnumerator enumerator = f_home.enumerate_children (\"%s\".printf(FileAttribute.STANDARD_NAME), 0);\n\t\t\tFileInfo file;\n\t\t\twhile ((file = enumerator.next_file ()) != null) {\n\t\t\t\tstring name = file.get_name();\n\t\t\t\tlist.add(name);\n\t\t\t}\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tlog_error (e.message);\n\t\t}\n\n\t\t//sort the list\n\t\tCompareDataFunc<string> entry_compare = (a, b) => {\n\t\t\treturn strcmp(a,b);\n\t\t};\n\t\tlist.sort((owned) entry_compare);\n\n\t\treturn list;\n\t}\n\t\n\tpublic bool dir_tar (string src_dir, string tar_file, bool recursion = true){\n\t\tif (dir_exists(src_dir)) {\n\t\t\t\n\t\t\tif (file_exists(tar_file)){\n\t\t\t\tfile_delete(tar_file);\n\t\t\t}\n\n\t\t\tvar src_parent = file_parent(src_dir);\n\t\t\tvar src_name = file_basename(src_dir);\n\t\t\t\n\t\t\tstring cmd = \"tar cvf '%s' --overwrite --%srecursion -C '%s' '%s'\\n\".printf(\n\t\t\t\tescape_single_quote(tar_file),\n\t\t\t\t(recursion ? \"\" : \"no-\"),\n\t\t\t\tescape_single_quote(src_parent),\n\t\t\t\tescape_single_quote(src_name));\n\n\t\t\tlog_debug(cmd);\n\t\t\t\n\t\t\tstring stdout, stderr;\n\t\t\tint status = exec_script_sync(cmd, out stdout, out stderr);\n\t\t\tif (status == 0){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_msg(stderr);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tlog_error(_(\"Dir not found\") + \": %s\".printf(src_dir));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic bool dir_untar (string tar_file, string dst_dir){\n\t\tif (file_exists(tar_file)) {\n\n\t\t\tif (!dir_exists(dst_dir)){\n\t\t\t\tdir_create(dst_dir);\n\t\t\t}\n\t\t\t\n\t\t\tstring cmd = \"tar xvf '%s' --overwrite --same-permissions -C '%s'\\n\".printf(\n\t\t\t\tescape_single_quote(tar_file),\n\t\t\t\tescape_single_quote(dst_dir));\n\n\t\t\tlog_debug(cmd);\n\t\t\t\n\t\t\tstring stdout, stderr;\n\t\t\tint status = exec_script_sync(cmd, out stdout, out stderr);\n\t\t\tif (status == 0){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_msg(stderr);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tlog_error(_(\"File not found\") + \": %s\".printf(tar_file));\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tpublic bool chown(string dir_path, string user, string group = user){\n\t\tstring cmd = \"chown %s:%s -R '%s'\".printf(user, group, escape_single_quote(dir_path));\n\t\tint status = exec_sync(cmd, null, null);\n\t\treturn (status == 0);\n\t}\n\t\n\t// dir info -------------------\n\t\n\t// dep: find wc    TODO: rewrite\n\tpublic long dir_count(string path){\n\n\t\t/* Return total count of files and directories */\n\n\t\tstring cmd = \"\";\n\t\tstring std_out;\n\t\tstring std_err;\n\t\tint ret_val;\n\n\t\tcmd = \"find '%s' | wc -l\".printf(escape_single_quote(path));\n\t\tret_val = exec_script_sync(cmd, out std_out, out std_err);\n\t\treturn long.parse(std_out);\n\t}\n\n\t// dep: du\n\tpublic long dir_size(string path){\n\n\t\t/* Returns size of files and directories in KB*/\n\n\t\tstring cmd = \"du -s -b '%s'\".printf(escape_single_quote(path));\n\t\tstring std_out, std_err;\n\t\texec_sync(cmd, out std_out, out std_err);\n\t\treturn long.parse(std_out.split(\"\\t\")[0]);\n\t}\n\n\t// dep: du\n\tpublic long dir_size_kb(string path){\n\n\t\t/* Returns size of files and directories in KB*/\n\n\t\treturn (long)(dir_size(path) / 1024.0);\n\t}\n\n\t// archiving and encryption ----------------\n\n\t// dep: tar gzip gpg\n\tpublic bool file_tar_encrypt (string src_file, string dst_file, string password){\n\t\tif (file_exists(src_file)) {\n\t\t\tif (file_exists(dst_file)){\n\t\t\t\tfile_delete(dst_file);\n\t\t\t}\n\n\t\t\tvar src_dir = file_parent(src_file);\n\t\t\tvar src_name = file_basename(src_file);\n\n\t\t\tvar dst_dir = file_parent(dst_file);\n\t\t\tvar dst_name = file_basename(dst_file);\n\t\t\tvar tar_name = dst_name[0 : dst_name.index_of(\".gpg\")];\n\t\t\tvar tar_file = \"%s/%s\".printf(dst_dir, tar_name);\n\t\t\t\n\t\t\tstring cmd = \"tar cvf '%s' --overwrite -C '%s' '%s'\\n\".printf(\n\t\t\t\tescape_single_quote(tar_file),\n\t\t\t\tescape_single_quote(src_dir),\n\t\t\t\tescape_single_quote(src_name));\n\t\t\t\t\n\t\t\tcmd += \"gpg --passphrase '%s' -o '%s' --symmetric '%s'\\n\".printf(\n\t\t\t\tpassword,\n\t\t\t\tescape_single_quote(dst_file),\n\t\t\t\tescape_single_quote(tar_file));\n\t\t\t\t\n\t\t\tcmd += \"rm -f '%s'\\n\".printf(escape_single_quote(tar_file));\n\n\t\t\tlog_debug(cmd);\n\t\t\t\n\t\t\tstring stdout, stderr;\n\t\t\tint status = exec_script_sync(cmd, out stdout, out stderr);\n\t\t\tif (status == 0){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_msg(stderr);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// dep: tar gzip gpg\n\tpublic string file_decrypt_untar_read (string src_file, string password){\n\t\t\n\t\tif (file_exists(src_file)) {\n\t\t\t\n\t\t\t//var src_name = file_basename(src_file);\n\t\t\t//var tar_name = src_name[0 : src_name.index_of(\".gpg\")];\n\t\t\t//var tar_file = \"%s/%s\".printf(TEMP_DIR, tar_name);\n\t\t\t//var temp_file = \"%s/%s\".printf(TEMP_DIR, random_string());\n\n\t\t\tstring cmd = \"\";\n\t\t\t\n\t\t\tcmd += \"gpg --quiet --no-verbose --passphrase '%s' -o- --decrypt '%s'\".printf(\n\t\t\t\tpassword,\n\t\t\t\tescape_single_quote(src_file));\n\t\t\t\t\n\t\t\tcmd += \" | tar xf - --to-stdout 2>/dev/null\\n\";\n\t\t\tcmd += \"exit $?\\n\";\n\t\t\t\n\t\t\tlog_debug(cmd);\n\t\t\t\n\t\t\tstring std_out, std_err;\n\t\t\tint status = exec_script_sync(cmd, out std_out, out std_err);\n\t\t\tif (status == 0){\n\t\t\t\treturn std_out;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_error(std_err);\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tlog_error(_(\"File is missing\") + \": %s\".printf(src_file));\n\t\t}\n\n\t\treturn \"\";\n\t}\n\n\t// dep: tar gzip gpg\n\tpublic bool decrypt_and_untar (string src_file, string dst_file, string password){\n\t\tif (file_exists(src_file)) {\n\t\t\tif (file_exists(dst_file)){\n\t\t\t\tfile_delete(dst_file);\n\t\t\t}\n\n\t\t\tvar src_dir = file_parent(src_file);\n\t\t\tvar src_name = file_basename(src_file);\n\t\t\tvar tar_name = src_name[0 : src_name.index_of(\".gpg\")];\n\t\t\tvar tar_file = \"%s/%s\".printf(src_dir, tar_name);\n\n\t\t\tstring cmd = \"\";\n\t\t\t\n\t\t\t// gpg cannot overwrite - remove tar file if it exists\n\t\t\tcmd += \"rm -f '%s'\\n\".printf(escape_single_quote(tar_file));\n\t\t\t\n\t\t\tcmd += \"gpg --passphrase '%s' -o '%s' --decrypt '%s'\\n\".printf(\n\t\t\t\tpassword,\n\t\t\t\tescape_single_quote(tar_file),\n\t\t\t\tescape_single_quote(src_file));\n\t\t\t\t\n\t\t\tcmd += \"status=$?; if [ $status -ne 0 ]; then exit $status; fi\\n\";\n\t\t\t\n\t\t\tcmd += \"tar xvf '%s' --overwrite --same-permissions -C '%s'\\n\".printf(\n\t\t\t\tescape_single_quote(tar_file),\n\t\t\t\tescape_single_quote(file_parent(dst_file)));\n\t\t\t\t\n\t\t\tcmd += \"rm -f '%s'\\n\".printf(escape_single_quote(tar_file));\n\n\t\t\tlog_debug(cmd);\n\t\t\t\n\t\t\tstring stdout, stderr;\n\t\t\tint status = exec_script_sync(cmd, out stdout, out stderr);\n\t\t\tif (status == 0){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlog_error(stderr);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tlog_error(_(\"File is missing\") + \": %s\".printf(src_file));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// hashing -----------\n\t\n\tprivate string hash_md5(string path){\n\t\tChecksum checksum = new Checksum (ChecksumType.MD5);\n\t\tFileStream stream = FileStream.open (path, \"rb\");\n\n\t\tuint8 fbuf[100];\n\t\tsize_t size;\n\t\twhile ((size = stream.read (fbuf)) > 0){\n\t\t  checksum.update (fbuf, size);\n\t\t}\n\t\t\n\t\tunowned string digest = checksum.get_string();\n\n\t\treturn digest;\n\t}\n\n\t// misc --------------------\n\n\tpublic string format_file_size (\n\t\tuint64 size, bool binary_units = false,\n\t\tstring unit = \"\", bool show_units = true, int decimals = 1){\n\t\t\t\n\t\tuint64 unit_k = binary_units ? 1024 : 1000;\n\t\tuint64 unit_m = binary_units ? 1024 * unit_k : 1000 * unit_k;\n\t\tuint64 unit_g = binary_units ? 1024 * unit_m : 1000 * unit_m;\n\t\tuint64 unit_t = binary_units ? 1024 * unit_g : 1000 * unit_g;\n\n\t\t//log_debug(\"size: %'lld\".printf(size));\n\n\t\tstring txt = \"\";\n\t\t\n\t\tif ((size > unit_t) && ((unit.length == 0) || (unit == \"t\"))){\n\t\t\ttxt += (\"%%'0.%df\".printf(decimals)).printf(size / (1.0 * unit_t));\n\t\t\tif (show_units){\n\t\t\t\ttxt += \" %sB\".printf(binary_units ? \"Ti\" : \"T\");\n\t\t\t}\n\t\t}\n\t\telse if ((size > unit_g) && ((unit.length == 0) || (unit == \"g\"))){\n\t\t\ttxt += (\"%%'0.%df\".printf(decimals)).printf(size / (1.0 * unit_g));\n\t\t\tif (show_units){\n\t\t\t\ttxt += \" %sB\".printf(binary_units ? \"Gi\" : \"G\");\n\t\t\t}\n\t\t}\n\t\telse if ((size > unit_m) && ((unit.length == 0) || (unit == \"m\"))){\n\t\t\ttxt += (\"%%'0.%df\".printf(decimals)).printf(size / (1.0 * unit_m));\n\t\t\tif (show_units){\n\t\t\t\ttxt += \" %sB\".printf(binary_units ? \"Mi\" : \"M\");\n\t\t\t}\n\t\t}\n\t\telse if ((size > unit_k) && ((unit.length == 0) || (unit == \"k\"))){\n\t\t\ttxt += (\"%%'0.%df\".printf(decimals)).printf(size / (1.0 * unit_k));\n\t\t\tif (show_units){\n\t\t\t\ttxt += \" %sB\".printf(binary_units ? \"Ki\" : \"K\");\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\ttxt += \"%'0lld\".printf(size);\n\t\t\tif (show_units){\n\t\t\t\ttxt += \" B\";\n\t\t\t}\n\t\t}\n\n\t\t//log_debug(\"converted: %s\".printf(txt));\n\n\t\treturn txt;\n\t}\n\n\tpublic string escape_single_quote(string file_path){\n\t\treturn file_path.replace(\"'\",\"'\\\\''\");\n\t}\n\n\n\t// dep: chmod\n\tpublic int chmod (string file, string permission){\n\n\t\t/* Change file permissions */\n\t\tstring cmd = \"chmod %s '%s'\".printf(permission, escape_single_quote(file));\n\t\treturn exec_sync (cmd, null, null);\n\t}\n\n\t// dep: realpath\n\tpublic string resolve_relative_path (string filePath){\n\n\t\t/* Resolve the full path of given file using 'realpath' command */\n\n\t\tstring filePath2 = filePath;\n\t\tif (filePath2.has_prefix (\"~\")){\n\t\t\tfilePath2 = Environment.get_home_dir () + \"/\" + filePath2[2:filePath2.length];\n\t\t}\n\n\t\ttry {\n\t\t\tstring output = \"\";\n\t\t\tstring cmd = \"realpath '%s'\".printf(escape_single_quote(filePath2));\n\t\t\tProcess.spawn_command_line_sync(cmd, out output);\n\t\t\toutput = output.strip ();\n\t\t\tif (FileUtils.test(output, GLib.FileTest.EXISTS)){\n\t\t\t\treturn output;\n\t\t\t}\n\t\t}\n\t\tcatch(Error e){\n\t        log_error (e.message);\n\t    }\n\n\t    return filePath2;\n\t}\n\n\tpublic int rsync (string sourceDirectory, string destDirectory, bool updateExisting, bool deleteExtra){\n\n\t\t/* Sync files with rsync */\n\n\t\tstring cmd = \"rsync -avh\";\n\t\tcmd += updateExisting ? \"\" : \" --ignore-existing\";\n\t\tcmd += deleteExtra ? \" --delete\" : \"\";\n\t\tcmd += \" '%s'\".printf(escape_single_quote(sourceDirectory) + \"//\");\n\t\tcmd += \" '%s'\".printf(escape_single_quote(destDirectory));\n\t\treturn exec_sync (cmd, null, null);\n\t}\n}\n", "\n/*\n * TeeJee.ProcessHelper.vala\n *\n * Copyright 2012-2018 Tony George <teejeetech@gmail.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n * MA 02110-1301, USA.\n *\n *\n */\n \nnamespace TeeJee.ProcessHelper{\n\tusing TeeJee.Logging;\n\tusing TeeJee.FileSystem;\n\tusing TeeJee.Misc;\n\n\tpublic string TEMP_DIR;\n\t\n\t/* Convenience functions for executing commands and managing processes */\n\n\t// execute process ---------------------------------\n\t\n    public static void init_tmp(string subdir_name){\n\t\tstring std_out, std_err;\n\n\t\tTEMP_DIR = Environment.get_tmp_dir() + \"/\" + random_string();\n\t\tdir_create(TEMP_DIR);\n\t\tchmod(TEMP_DIR, \"0750\");\n\t\t\n\t\texec_script_sync(\"echo 'ok'\",out std_out,out std_err, true);\n\t\t\n\t\tif ((std_out == null) || (std_out.strip() != \"ok\")){\n\t\t\t\n\t\t\tTEMP_DIR = Environment.get_home_dir() + \"/.temp/\" + random_string();\n\t\t\tdir_create(TEMP_DIR);\n\t\t\tchmod(TEMP_DIR, \"0750\");\n\t\t}\n\n\t\t//log_debug(\"TEMP_DIR=\" + TEMP_DIR);\n\t}\n\n\tpublic string create_temp_subdir(){\n\t\tvar temp = \"%s/%s\".printf(TEMP_DIR, random_string());\n\t\tdir_create(temp);\n\t\treturn temp;\n\t}\n\t\n\tpublic int exec_sync (string cmd, out string? std_out = null, out string? std_err = null){\n\n\t\t/* Executes single command synchronously.\n\t\t * Pipes and multiple commands are not supported.\n\t\t * std_out, std_err can be null. Output will be written to terminal if null. */\n\n\t\ttry {\n\t\t\tint status;\n\t\t\tProcess.spawn_command_line_sync(cmd, out std_out, out std_err, out status);\n\t        return status;\n\t\t}\n\t\tcatch (Error e){\n\t        log_error (e.message);\n\t        return -1;\n\t    }\n\t}\n\t\n\tpublic int exec_script_sync (string script,\n\t\tout string? std_out = null, out string? std_err = null,\n\t\tbool supress_errors = false, bool run_as_admin = false,\n\t\tbool cleanup_tmp = true, bool print_to_terminal = false){\n\n\t\t/* Executes commands synchronously.\n\t\t * Pipes and multiple commands are fully supported.\n\t\t * Commands are written to a temporary bash script and executed.\n\t\t * std_out, std_err can be null. Output will be written to terminal if null.\n\t\t * */\n\n\t\tstring sh_file = save_bash_script_temp(script, null, true, supress_errors);\n\t\tstring sh_file_admin = \"\";\n\t\t\n\t\tif (run_as_admin){\n\t\t\t\n\t\t\tvar script_admin = \"#!/bin/bash\\n\";\n\t\t\tscript_admin += \"pkexec env DISPLAY=$DISPLAY XAUTHORITY=$XAUTHORITY\";\n\t\t\tscript_admin += \" '%s'\".printf(escape_single_quote(sh_file));\n\t\t\t\n\t\t\tsh_file_admin = GLib.Path.build_filename(file_parent(sh_file),\"script-admin.sh\");\n\n\t\t\tsave_bash_script_temp(script_admin, sh_file_admin, true, supress_errors);\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tstring[] argv = new string[1];\n\t\t\tif (run_as_admin){\n\t\t\t\targv[0] = sh_file_admin;\n\t\t\t}\n\t\t\telse{\n\t\t\t\targv[0] = sh_file;\n\t\t\t}\n\n\t\t\tstring[] env = Environ.get();\n\n\t\t\tint exit_code;\n\n\t\t\tif (print_to_terminal){\n\t\t\t\t\n\t\t\t\tProcess.spawn_sync (\n\t\t\t\t\tTEMP_DIR, //working dir\n\t\t\t\t\targv, //argv\n\t\t\t\t\tenv, //environment\n\t\t\t\t\tSpawnFlags.SEARCH_PATH,\n\t\t\t\t\tnull,   // child_setup\n\t\t\t\t\tnull,\n\t\t\t\t\tnull,\n\t\t\t\t\tout exit_code\n\t\t\t\t\t);\n\t\t\t}\n\t\t\telse{\n\t\t\n\t\t\t\tProcess.spawn_sync (\n\t\t\t\t\tTEMP_DIR, //working dir\n\t\t\t\t\targv, //argv\n\t\t\t\t\tenv, //environment\n\t\t\t\t\tSpawnFlags.SEARCH_PATH,\n\t\t\t\t\tnull,   // child_setup\n\t\t\t\t\tout std_out,\n\t\t\t\t\tout std_err,\n\t\t\t\t\tout exit_code\n\t\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (cleanup_tmp){\n\t\t\t\tfile_delete(sh_file);\n\t\t\t\tif (run_as_admin){\n\t\t\t\t\tfile_delete(sh_file_admin);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn exit_code;\n\t\t}\n\t\tcatch (Error e){\n\t\t\tif (!supress_errors){\n\t\t\t\tlog_error (e.message);\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tpublic int exec_script_async (string script){\n\n\t\t/* Executes commands synchronously.\n\t\t * Pipes and multiple commands are fully supported.\n\t\t * Commands are written to a temporary bash script and executed.\n\t\t * Return value indicates if script was started successfully.\n\t\t *  */\n\n\t\ttry {\n\n\t\t\tstring scriptfile = save_bash_script_temp (script);\n\n\t\t\tstring[] argv = new string[1];\n\t\t\targv[0] = scriptfile;\n\n\t\t\tstring[] env = Environ.get();\n\t\t\t\n\t\t\tPid child_pid;\n\t\t\tProcess.spawn_async_with_pipes(\n\t\t\t    TEMP_DIR, //working dir\n\t\t\t    argv, //argv\n\t\t\t    env, //environment\n\t\t\t    SpawnFlags.SEARCH_PATH,\n\t\t\t    null,\n\t\t\t    out child_pid);\n\n\t\t\treturn 0;\n\t\t}\n\t\tcatch (Error e){\n\t        log_error (e.message);\n\t        return 1;\n\t    }\n\t}\n\n\tpublic string? save_bash_script_temp (string commands, string? script_path = null,\n\t\tbool force_locale = true, bool supress_errors = false){\n\n\t\tstring sh_path = script_path;\n\t\t\n\t\t/* Creates a temporary bash script with given commands\n\t\t * Returns the script file path */\n\n\t\tvar script = new StringBuilder();\n\t\tscript.append (\"#!/bin/bash\\n\");\n\t\tscript.append (\"\\n\");\n\t\tif (force_locale){\n\t\t\tscript.append (\"LANG=C\\n\");\n\t\t}\n\t\tscript.append (\"\\n\");\n\t\tscript.append (\"%s\\n\".printf(commands));\n\t\tscript.append (\"\\n\\nexitCode=$?\\n\");\n\t\tscript.append (\"echo ${exitCode} > ${exitCode}\\n\");\n\t\tscript.append (\"echo ${exitCode} > status\\n\");\n\n\t\tif ((sh_path == null) || (sh_path.length == 0)){\n\t\t\tsh_path = get_temp_file_path() + \".sh\";\n\t\t}\n\n\t\ttry{\n\t\t\t//write script file\n\t\t\tvar file = File.new_for_path (sh_path);\n\t\t\tif (file.query_exists ()) {\n\t\t\t\tfile.delete ();\n\t\t\t}\n\t\t\tvar file_stream = file.create (FileCreateFlags.REPLACE_DESTINATION);\n\t\t\tvar data_stream = new DataOutputStream (file_stream);\n\t\t\tdata_stream.put_string (script.str);\n\t\t\tdata_stream.close();\n\n\t\t\t// set execute permission\n\t\t\tchmod (sh_path, \"u+x\");\n\n\t\t\treturn sh_path;\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tif (!supress_errors){\n\t\t\t\tlog_error (e.message);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic string get_temp_file_path(){\n\n\t\t/* Generates temporary file path */\n\n\t\treturn TEMP_DIR + \"/\" + timestamp_numeric() + (new Rand()).next_int().to_string();\n\t}\n\n\tpublic void exec_process_new_session(string command){\n\t\texec_script_async(\"setsid %s &\".printf(command));\n\t}\n\t\n\t// find process -------------------------------\n\t\n\t// dep: which\n\tpublic string get_cmd_path (string cmd_tool){\n\n\t\t/* Returns the full path to a command */\n\n\t\ttry {\n\t\t\tint exitCode;\n\t\t\tstring stdout, stderr;\n\t\t\tProcess.spawn_command_line_sync(\"which \" + cmd_tool, out stdout, out stderr, out exitCode);\n\t        return stdout;\n\t\t}\n\t\tcatch (Error e){\n\t        log_error (e.message);\n\t        return \"\";\n\t    }\n\t}\n\n\tpublic bool cmd_exists(string cmd_tool){\n\t\tstring path = get_cmd_path (cmd_tool);\n\t\tif ((path == null) || (path.length == 0)){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// dep: pidof, TODO: Rewrite using /proc\n\tpublic int get_pid_by_name (string name){\n\n\t\t/* Get the process ID for a process with given name */\n\n\t\tstring std_out, std_err;\n\t\texec_sync(\"pidof \\\"%s\\\"\".printf(name), out std_out, out std_err);\n\t\t\n\t\tif (std_out != null){\n\t\t\tstring[] arr = std_out.split (\"\\n\");\n\t\t\tif (arr.length > 0){\n\t\t\t\treturn int.parse (arr[0]);\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tpublic int get_pid_by_command(string cmdline){\n\n\t\t/* Searches for process using the command line used to start the process.\n\t\t * Returns the process id if found.\n\t\t * */\n\t\t \n\t\ttry {\n\t\t\tFileEnumerator enumerator;\n\t\t\tFileInfo info;\n\t\t\tFile file = File.parse_name (\"/proc\");\n\n\t\t\tenumerator = file.enumerate_children (\"standard::name\", 0);\n\t\t\twhile ((info = enumerator.next_file()) != null) {\n\t\t\t\ttry {\n\t\t\t\t\tstring io_stat_file_path = \"/proc/%s/cmdline\".printf(info.get_name());\n\t\t\t\t\tvar io_stat_file = File.new_for_path(io_stat_file_path);\n\t\t\t\t\tif (file.query_exists()){\n\t\t\t\t\t\tvar dis = new DataInputStream (io_stat_file.read());\n\n\t\t\t\t\t\tstring line;\n\t\t\t\t\t\tstring text = \"\";\n\t\t\t\t\t\tsize_t length;\n\t\t\t\t\t\twhile((line = dis.read_until (\"\\0\", out length)) != null){\n\t\t\t\t\t\t\ttext += \" \" + line;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ((text != null) && text.contains(cmdline)){\n\t\t\t\t\t\t\treturn int.parse(info.get_name());\n\t\t\t\t\t\t}\n\t\t\t\t\t} //stream closed\n\t\t\t\t}\n\t\t\t\tcatch(Error e){\n\t\t\t\t\t// do not log\n\t\t\t\t\t// some processes cannot be accessed by non-admin user\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch(Error e){\n\t\t  log_error (e.message);\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tpublic void get_proc_io_stats(int pid, out int64 read_bytes, out int64 write_bytes){\n\n\t\t/* Returns the number of bytes read and written by a process to disk */\n\t\t\n\t\tstring io_stat_file_path = \"/proc/%d/io\".printf(pid);\n\t\tvar file = File.new_for_path(io_stat_file_path);\n\n\t\tread_bytes = 0;\n\t\twrite_bytes = 0;\n\n\t\ttry {\n\t\t\tif (file.query_exists()){\n\t\t\t\tvar dis = new DataInputStream (file.read());\n\t\t\t\tstring line;\n\t\t\t\twhile ((line = dis.read_line (null)) != null) {\n\t\t\t\t\tif(line.has_prefix(\"rchar:\")){\n\t\t\t\t\t\tread_bytes = int64.parse(line.replace(\"rchar:\",\"\").strip());\n\t\t\t\t\t}\n\t\t\t\t\telse if(line.has_prefix(\"wchar:\")){\n\t\t\t\t\t\twrite_bytes = int64.parse(line.replace(\"wchar:\",\"\").strip());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} //stream closed\n\t\t}\n\t\tcatch(Error e){\n\t\t\tlog_error (e.message);\n\t\t}\n\t}\n\n\t// dep: ps TODO: Rewrite using /proc\n\tpublic bool process_is_running(long pid){\n\n\t\t/* Checks if given process is running */\n\n\t\tstring cmd = \"\";\n\t\tstring std_out;\n\t\tstring std_err;\n\t\tint ret_val;\n\n\t\ttry{\n\t\t\tcmd = \"ps --pid %ld\".printf(pid);\n\t\t\tProcess.spawn_command_line_sync(cmd, out std_out, out std_err, out ret_val);\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tlog_error (e.message);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn (ret_val == 0);\n\t}\n\n\t// dep: pgrep TODO: Rewrite using /proc\n\tpublic bool process_is_running_by_name(string proc_name){\n\n\t\t/* Checks if given process is running */\n\n\t\tstring cmd = \"\";\n\t\tstring std_out;\n\t\tstring std_err;\n\t\tint ret_val;\n\n\t\ttry{\n\t\t\tcmd = \"pgrep -f '%s'\".printf(proc_name);\n\t\t\tProcess.spawn_command_line_sync(cmd, out std_out, out std_err, out ret_val);\n\t\t}\n\t\tcatch (Error e) {\n\t\t\tlog_error (e.message);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn (ret_val == 0);\n\t}\n\t\n\t// dep: ps TODO: Rewrite using /proc\n\tpublic int[] get_process_children (Pid parent_pid){\n\n\t\t/* Returns the list of child processes spawned by given process */\n\n\t\tstring std_out, std_err;\n\t\texec_sync(\"ps --ppid %d\".printf(parent_pid), out std_out, out std_err);\n\n\t\tint pid;\n\t\tint[] procList = {};\n\t\tstring[] arr;\n\n\t\tforeach (string line in std_out.split (\"\\n\")){\n\t\t\tarr = line.strip().split (\" \");\n\t\t\tif (arr.length < 1) { continue; }\n\n\t\t\tpid = 0;\n\t\t\tpid = int.parse (arr[0]);\n\n\t\t\tif (pid != 0){\n\t\t\t\tprocList += pid;\n\t\t\t}\n\t\t}\n\t\treturn procList;\n\t}\n\n\t// manage process ---------------------------------\n\t\n\tpublic void process_quit(Pid process_pid, bool killChildren = true){\n\n\t\t/* Kills specified process and its children (optional).\n\t\t * Sends signal SIGTERM to the process to allow it to quit gracefully.\n\t\t * */\n\n\t\tint[] child_pids = get_process_children (process_pid);\n\t\tPosix.kill (process_pid, Posix.SIGTERM);\n\n\t\tif (killChildren){\n\t\t\tPid childPid;\n\t\t\tforeach (long pid in child_pids){\n\t\t\t\tchildPid = (Pid) pid;\n\t\t\t\tPosix.kill (childPid, Posix.SIGTERM);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void process_kill(Pid process_pid, bool killChildren = true){\n\n\t\t/* Kills specified process and its children (optional).\n\t\t * Sends signal SIGKILL to the process to kill it forcefully.\n\t\t * It is recommended to use the function process_quit() instead.\n\t\t * */\n\t\t\n\t\tint[] child_pids = get_process_children (process_pid);\n\t\tPosix.kill (process_pid, Posix.SIGKILL);\n\n\t\tif (killChildren){\n\t\t\tPid childPid;\n\t\t\tforeach (long pid in child_pids){\n\t\t\t\tchildPid = (Pid) pid;\n\t\t\t\tPosix.kill (childPid, Posix.SIGKILL);\n\t\t\t}\n\t\t}\n\t}\n\n\t// dep: kill\n\tpublic int process_pause (Pid procID){\n\n\t\t/* Pause/Freeze a process */\n\n\t\treturn exec_sync (\"kill -STOP %d\".printf(procID), null, null);\n\t}\n\n\t// dep: kill\n\tpublic int process_resume (Pid procID){\n\n\t\t/* Resume/Un-freeze a process*/\n\n\t\treturn exec_sync (\"kill -CONT %d\".printf(procID), null, null);\n\t}\n\n\t// dep: ps TODO: Rewrite using /proc\n\tpublic void process_quit_by_name(string cmd_name, string cmd_to_match, bool exact_match){\n\n\t\t/* Kills a specific command */\n\t\t\n\t\tstring std_out, std_err;\n\t\texec_sync (\"ps w -C '%s'\".printf(cmd_name), out std_out, out std_err);\n\t\t//use 'ps ew -C conky' for all users\n\n\t\tstring pid = \"\";\n\t\tforeach(string line in std_out.split(\"\\n\")){\n\t\t\tif ((exact_match && line.has_suffix(\" \" + cmd_to_match))\n\t\t\t|| (!exact_match && (line.index_of(cmd_to_match) != -1))){\n\t\t\t\tpid = line.strip().split(\" \")[0];\n\t\t\t\tPosix.kill ((Pid) int.parse(pid), 15);\n\t\t\t\tlog_debug(_(\"Stopped\") + \": [PID=\" + pid + \"] \");\n\t\t\t}\n\t\t}\n\t}\n\n\t// process priority ---------------------------------------\n\t\n\tpublic void process_set_priority (Pid procID, int prio){\n\n\t\t/* Set process priority */\n\n\t\tif (Posix.getpriority (Posix.PRIO_PROCESS, procID) != prio)\n\t\t\tPosix.setpriority (Posix.PRIO_PROCESS, procID, prio);\n\t}\n\n\tpublic int process_get_priority (Pid procID){\n\n\t\t/* Get process priority */\n\n\t\treturn Posix.getpriority (Posix.PRIO_PROCESS, procID);\n\t}\n\n\tpublic void process_set_priority_normal (Pid procID){\n\n\t\t/* Set normal priority for process */\n\n\t\tprocess_set_priority (procID, 0);\n\t}\n\n\tpublic void process_set_priority_low (Pid procID){\n\n\t\t/* Set low priority for process */\n\n\t\tprocess_set_priority (procID, 5);\n\t}\n}\n"], "filenames": ["src/Core/Main.vala", "src/Utility/TeeJee.FileSystem.vala", "src/Utility/TeeJee.Process.vala"], "buggy_code_start_loc": [4246, 346, 39], "buggy_code_end_loc": [4246, 378, 46], "fixing_code_start_loc": [4247, 347, 39], "fixing_code_end_loc": [4249, 386, 50], "type": "CWE-362", "message": "init_tmp in TeeJee.FileSystem.vala in Timeshift before 20.03 unsafely reuses a preexisting temporary directory in the predictable location /tmp/timeshift. It follows symlinks in this location or uses directories owned by unprivileged users. Because Timeshift also executes scripts under this location, an attacker can attempt to win a race condition to replace scripts created by Timeshift with attacker-controlled scripts. Upon success, an attacker-controlled script is executed with full root privileges. This logic is practically always triggered when Timeshift runs regardless of the command-line arguments used.", "other": {"cve": {"id": "CVE-2020-10174", "sourceIdentifier": "cve@mitre.org", "published": "2020-03-05T16:15:11.940", "lastModified": "2022-01-01T19:36:09.030", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "init_tmp in TeeJee.FileSystem.vala in Timeshift before 20.03 unsafely reuses a preexisting temporary directory in the predictable location /tmp/timeshift. It follows symlinks in this location or uses directories owned by unprivileged users. Because Timeshift also executes scripts under this location, an attacker can attempt to win a race condition to replace scripts created by Timeshift with attacker-controlled scripts. Upon success, an attacker-controlled script is executed with full root privileges. This logic is practically always triggered when Timeshift runs regardless of the command-line arguments used."}, {"lang": "es", "value": "init_tmp en TeeJee.FileSystem.vala en Timeshift versiones anteriores a 20.03, reutiliza de forma no segura un directorio temporal preexistente en la ubicaci\u00f3n predecible /tmp/timeshift. Sigue los enlaces simb\u00f3licos en esta ubicaci\u00f3n o usa directorios propiedad de los usuarios sin privilegios. Debido a que Timeshift tambi\u00e9n ejecuta scripts bajo esta ubicaci\u00f3n, un atacante puede intentar ganar una condici\u00f3n de carrera para sustituir los scripts creados mediante Timeshift con scripts controlados por el atacante. Tras el \u00e9xito, un script controlado por el atacante es ejecutado con todos los privilegios root. Esta l\u00f3gica es siempre activada pr\u00e1cticamente cuando Timeshift se ejecuta independientemente de los argumentos de l\u00ednea de comando utilizados."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}, {"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:timeshift_project:timeshift:*:*:*:*:*:*:*:*", "versionEndExcluding": "20.03", "matchCriteriaId": "CDDB2FCE-E8A1-46AA-8682-F6FB21557BC1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2020/03/06/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1165802", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/teejee2008/timeshift/commit/335b3d5398079278b8f7094c77bfd148b315b462", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/teejee2008/timeshift/releases/tag/v20.03", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/AAOFXT64CEUMJE3723JDJWTEQWQUCYMD/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/SXDEPC52G46U6I7GLQNFLZXVSM7V2HYY/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TXXYQFSZ5P6ZMNFIDBAQKBFZIR2T7ZLL/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4312-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/teejee2008/timeshift/commit/335b3d5398079278b8f7094c77bfd148b315b462"}}