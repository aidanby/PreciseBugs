{"buggy_code": ["// Copyright 2017 HootSuite Media Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the License);\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//    http://www.apache.org/licenses/LICENSE-2.0\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an AS IS BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// Modified hereafter by contributors to runatlantis/atlantis.\n\npackage events\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\n\tgitlab \"github.com/xanzy/go-gitlab\"\n)\n\nconst secretHeader = \"X-Gitlab-Token\" // #nosec\n\n//go:generate pegomock generate -m --use-experimental-model-gen --package mocks -o mocks/mock_gitlab_request_parser_validator.go GitlabRequestParserValidator\n\n// GitlabRequestParserValidator parses and validates GitLab requests.\ntype GitlabRequestParserValidator interface {\n\t// ParseAndValidate validates that the request has a token header matching secret.\n\t// If the secret does not match it returns an error.\n\t// If secret is empty it does not check the token header.\n\t// It then parses the request as a GitLab object depending on the header\n\t// provided by GitLab identifying the webhook type. If the webhook type\n\t// is not recognized it will return nil but will not return an error.\n\t// Usage:\n\t//\tevent, err := GitlabRequestParserValidator.ParseAndValidate(r, secret)\n\t//\tif err != nil {\n\t//\t\treturn\n\t//\t}\n\t//\tswitch event := event.(type) {\n\t//\tcase gitlab.MergeCommentEvent:\n\t//\t\t// handle\n\t//\tcase gitlab.MergeEvent:\n\t//\t\t// handle\n\t//\tdefault:\n\t//\t\t// unsupported event\n\t//\t}\n\tParseAndValidate(r *http.Request, secret []byte) (interface{}, error)\n}\n\n// DefaultGitlabRequestParserValidator parses and validates GitLab requests.\ntype DefaultGitlabRequestParserValidator struct{}\n\n// ParseAndValidate returns the JSON payload of the request.\n// See GitlabRequestParserValidator.ParseAndValidate().\nfunc (d *DefaultGitlabRequestParserValidator) ParseAndValidate(r *http.Request, secret []byte) (interface{}, error) {\n\tconst mergeEventHeader = \"Merge Request Hook\"\n\tconst noteEventHeader = \"Note Hook\"\n\n\t// Validate secret if specified.\n\theaderSecret := r.Header.Get(secretHeader)\n\tsecretStr := string(secret)\n\tif len(secret) != 0 && headerSecret != secretStr {\n\t\treturn nil, fmt.Errorf(\"header %s=%s did not match expected secret\", secretHeader, headerSecret)\n\t}\n\n\t// Parse request into a gitlab object based on the object type specified\n\t// in the gitlabHeader.\n\tbytes, err := io.ReadAll(r.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tswitch r.Header.Get(gitlabHeader) {\n\tcase mergeEventHeader:\n\t\tvar m gitlab.MergeEvent\n\t\tif err := json.Unmarshal(bytes, &m); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn m, nil\n\tcase noteEventHeader:\n\t\t// First, parse a small part of the json to determine if this is a\n\t\t// comment on a merge request or a commit.\n\t\tvar subset struct {\n\t\t\tObjectAttributes struct {\n\t\t\t\tNoteableType string `json:\"noteable_type\"`\n\t\t\t} `json:\"object_attributes\"`\n\t\t}\n\t\tif err := json.Unmarshal(bytes, &subset); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// We then parse into the correct comment event type.\n\t\tswitch subset.ObjectAttributes.NoteableType {\n\t\tcase \"Commit\":\n\t\t\tvar e gitlab.CommitCommentEvent\n\t\t\terr := json.Unmarshal(bytes, &e)\n\t\t\treturn e, err\n\t\tcase \"MergeRequest\":\n\t\t\tvar e gitlab.MergeCommentEvent\n\t\t\terr := json.Unmarshal(bytes, &e)\n\t\t\treturn e, err\n\t\t}\n\t}\n\treturn nil, nil\n}\n"], "fixing_code": ["// Copyright 2017 HootSuite Media Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the License);\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//    http://www.apache.org/licenses/LICENSE-2.0\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an AS IS BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// Modified hereafter by contributors to runatlantis/atlantis.\n\npackage events\n\nimport (\n\t\"crypto/subtle\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\n\tgitlab \"github.com/xanzy/go-gitlab\"\n)\n\nconst secretHeader = \"X-Gitlab-Token\" // #nosec\n\n//go:generate pegomock generate -m --use-experimental-model-gen --package mocks -o mocks/mock_gitlab_request_parser_validator.go GitlabRequestParserValidator\n\n// GitlabRequestParserValidator parses and validates GitLab requests.\ntype GitlabRequestParserValidator interface {\n\t// ParseAndValidate validates that the request has a token header matching secret.\n\t// If the secret does not match it returns an error.\n\t// If secret is empty it does not check the token header.\n\t// It then parses the request as a GitLab object depending on the header\n\t// provided by GitLab identifying the webhook type. If the webhook type\n\t// is not recognized it will return nil but will not return an error.\n\t// Usage:\n\t//\tevent, err := GitlabRequestParserValidator.ParseAndValidate(r, secret)\n\t//\tif err != nil {\n\t//\t\treturn\n\t//\t}\n\t//\tswitch event := event.(type) {\n\t//\tcase gitlab.MergeCommentEvent:\n\t//\t\t// handle\n\t//\tcase gitlab.MergeEvent:\n\t//\t\t// handle\n\t//\tdefault:\n\t//\t\t// unsupported event\n\t//\t}\n\tParseAndValidate(r *http.Request, secret []byte) (interface{}, error)\n}\n\n// DefaultGitlabRequestParserValidator parses and validates GitLab requests.\ntype DefaultGitlabRequestParserValidator struct{}\n\n// ParseAndValidate returns the JSON payload of the request.\n// See GitlabRequestParserValidator.ParseAndValidate().\nfunc (d *DefaultGitlabRequestParserValidator) ParseAndValidate(r *http.Request, secret []byte) (interface{}, error) {\n\tconst mergeEventHeader = \"Merge Request Hook\"\n\tconst noteEventHeader = \"Note Hook\"\n\n\t// Validate secret if specified.\n\theaderSecret := r.Header.Get(secretHeader)\n\tif len(secret) != 0 && subtle.ConstantTimeCompare(secret, []byte(headerSecret)) != 1 {\n\t\treturn nil, fmt.Errorf(\"header %s=%s did not match expected secret\", secretHeader, headerSecret)\n\t}\n\n\t// Parse request into a gitlab object based on the object type specified\n\t// in the gitlabHeader.\n\tbytes, err := io.ReadAll(r.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tswitch r.Header.Get(gitlabHeader) {\n\tcase mergeEventHeader:\n\t\tvar m gitlab.MergeEvent\n\t\tif err := json.Unmarshal(bytes, &m); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn m, nil\n\tcase noteEventHeader:\n\t\t// First, parse a small part of the json to determine if this is a\n\t\t// comment on a merge request or a commit.\n\t\tvar subset struct {\n\t\t\tObjectAttributes struct {\n\t\t\t\tNoteableType string `json:\"noteable_type\"`\n\t\t\t} `json:\"object_attributes\"`\n\t\t}\n\t\tif err := json.Unmarshal(bytes, &subset); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// We then parse into the correct comment event type.\n\t\tswitch subset.ObjectAttributes.NoteableType {\n\t\tcase \"Commit\":\n\t\t\tvar e gitlab.CommitCommentEvent\n\t\t\terr := json.Unmarshal(bytes, &e)\n\t\t\treturn e, err\n\t\tcase \"MergeRequest\":\n\t\t\tvar e gitlab.MergeCommentEvent\n\t\t\terr := json.Unmarshal(bytes, &e)\n\t\t\treturn e, err\n\t\t}\n\t}\n\treturn nil, nil\n}\n"], "filenames": ["server/controllers/events/gitlab_request_parser_validator.go"], "buggy_code_start_loc": [16], "buggy_code_end_loc": [66], "fixing_code_start_loc": [17], "fixing_code_end_loc": [66], "type": "CWE-203", "message": "The package github.com/runatlantis/atlantis/server/controllers/events before 0.19.7 are vulnerable to Timing Attack in the webhook event validator code, which does not use a constant-time comparison function to validate the webhook secret. It can allow an attacker to recover this secret as an attacker and then forge webhook events.", "other": {"cve": {"id": "CVE-2022-24912", "sourceIdentifier": "report@snyk.io", "published": "2022-07-29T10:15:12.557", "lastModified": "2022-08-08T17:40:13.390", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package github.com/runatlantis/atlantis/server/controllers/events before 0.19.7 are vulnerable to Timing Attack in the webhook event validator code, which does not use a constant-time comparison function to validate the webhook secret. It can allow an attacker to recover this secret as an attacker and then forge webhook events."}, {"lang": "es", "value": "El paquete github.com/runatlantis/atlantis/server/controllers/events versiones anteriores a 0.19.7, es vulnerable a un Timing Attack en el c\u00f3digo comprobador de eventos de webhook, que no usa una funci\u00f3n de comparaci\u00f3n en tiempo constante para comprobar el secreto del webhook. Esto puede permitir a un atacante recuperar este secreto como atacante y luego falsificar los eventos webhook"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:runatlantis:atlantis:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.19.7", "matchCriteriaId": "2A014E6F-1372-471F-AF98-47142E0BA350"}]}]}], "references": [{"url": "https://github.com/runatlantis/atlantis/commit/48870911974adddaa4c99c8089e79b7d787fa820", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/runatlantis/atlantis/issues/2391", "source": "report@snyk.io", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-GOLANG-GITHUBCOMRUNATLANTISATLANTISSERVERCONTROLLERSEVENTS-2950851", "source": "report@snyk.io", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/runatlantis/atlantis/commit/48870911974adddaa4c99c8089e79b7d787fa820"}}