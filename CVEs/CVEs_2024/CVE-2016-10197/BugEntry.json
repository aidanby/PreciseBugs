{"buggy_code": ["/* Copyright 2006-2007 Niels Provos\n * Copyright 2007-2012 Nick Mathewson and Niels Provos\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* Based on software by Adam Langly. Adam's original message:\n *\n * Async DNS Library\n * Adam Langley <agl@imperialviolet.org>\n * http://www.imperialviolet.org/eventdns.html\n * Public Domain code\n *\n * This software is Public Domain. To view a copy of the public domain dedication,\n * visit http://creativecommons.org/licenses/publicdomain/ or send a letter to\n * Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.\n *\n * I ask and expect, but do not require, that all derivative works contain an\n * attribution similar to:\n *\tParts developed by Adam Langley <agl@imperialviolet.org>\n *\n * You may wish to replace the word \"Parts\" with something else depending on\n * the amount of original code.\n *\n * (Derivative works does not include programs which link against, run or include\n * the source verbatim in their source distributions)\n *\n * Version: 0.1b\n */\n\n#include \"event2/event-config.h\"\n#include \"evconfig-private.h\"\n\n#include <sys/types.h>\n\n#ifndef _FORTIFY_SOURCE\n#define _FORTIFY_SOURCE 3\n#endif\n\n#include <string.h>\n#include <fcntl.h>\n#ifdef EVENT__HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#ifdef EVENT__HAVE_STDINT_H\n#include <stdint.h>\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#ifdef EVENT__HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <limits.h>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <stdarg.h>\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#ifndef _WIN32_IE\n#define _WIN32_IE 0x400\n#endif\n#include <shlobj.h>\n#endif\n\n#include \"event2/dns.h\"\n#include \"event2/dns_struct.h\"\n#include \"event2/dns_compat.h\"\n#include \"event2/util.h\"\n#include \"event2/event.h\"\n#include \"event2/event_struct.h\"\n#include \"event2/thread.h\"\n\n#include \"defer-internal.h\"\n#include \"log-internal.h\"\n#include \"mm-internal.h\"\n#include \"strlcpy-internal.h\"\n#include \"ipv6-internal.h\"\n#include \"util-internal.h\"\n#include \"evthread-internal.h\"\n#ifdef _WIN32\n#include <ctype.h>\n#include <winsock2.h>\n#include <windows.h>\n#include <iphlpapi.h>\n#include <io.h>\n#else\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#endif\n\n#ifdef EVENT__HAVE_NETINET_IN6_H\n#include <netinet/in6.h>\n#endif\n\n#define EVDNS_LOG_DEBUG EVENT_LOG_DEBUG\n#define EVDNS_LOG_WARN EVENT_LOG_WARN\n#define EVDNS_LOG_MSG EVENT_LOG_MSG\n\n#ifndef HOST_NAME_MAX\n#define HOST_NAME_MAX 255\n#endif\n\n#include <stdio.h>\n\n#undef MIN\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\n#define ASSERT_VALID_REQUEST(req) \\\n\tEVUTIL_ASSERT((req)->handle && (req)->handle->current_req == (req))\n\n#define u64 ev_uint64_t\n#define u32 ev_uint32_t\n#define u16 ev_uint16_t\n#define u8  ev_uint8_t\n\n/* maximum number of addresses from a single packet */\n/* that we bother recording */\n#define MAX_V4_ADDRS 32\n#define MAX_V6_ADDRS 32\n\n\n#define TYPE_A\t       EVDNS_TYPE_A\n#define TYPE_CNAME     5\n#define TYPE_PTR       EVDNS_TYPE_PTR\n#define TYPE_SOA       EVDNS_TYPE_SOA\n#define TYPE_AAAA      EVDNS_TYPE_AAAA\n\n#define CLASS_INET     EVDNS_CLASS_INET\n\n/* Persistent handle.  We keep this separate from 'struct request' since we\n * need some object to last for as long as an evdns_request is outstanding so\n * that it can be canceled, whereas a search request can lead to multiple\n * 'struct request' instances being created over its lifetime. */\nstruct evdns_request {\n\tstruct request *current_req;\n\tstruct evdns_base *base;\n\n\tint pending_cb; /* Waiting for its callback to be invoked; not\n\t\t\t * owned by event base any more. */\n\n\t/* elements used by the searching code */\n\tint search_index;\n\tstruct search_state *search_state;\n\tchar *search_origname;\t/* needs to be free()ed */\n\tint search_flags;\n};\n\nstruct request {\n\tu8 *request;  /* the dns packet data */\n\tu8 request_type; /* TYPE_PTR or TYPE_A or TYPE_AAAA */\n\tunsigned int request_len;\n\tint reissue_count;\n\tint tx_count;  /* the number of times that this packet has been sent */\n\tvoid *user_pointer;  /* the pointer given to us for this request */\n\tevdns_callback_type user_callback;\n\tstruct nameserver *ns;\t/* the server which we last sent it */\n\n\t/* these objects are kept in a circular list */\n\t/* XXX We could turn this into a CIRCLEQ. */\n\tstruct request *next, *prev;\n\n\tstruct event timeout_event;\n\n\tu16 trans_id;  /* the transaction id */\n\tunsigned request_appended :1;\t/* true if the request pointer is data which follows this struct */\n\tunsigned transmit_me :1;  /* needs to be transmitted */\n\n\t/* XXXX This is a horrible hack. */\n\tchar **put_cname_in_ptr; /* store the cname here if we get one. */\n\n\tstruct evdns_base *base;\n\n\tstruct evdns_request *handle;\n};\n\nstruct reply {\n\tunsigned int type;\n\tunsigned int have_answer : 1;\n\tunion {\n\t\tstruct {\n\t\t\tu32 addrcount;\n\t\t\tu32 addresses[MAX_V4_ADDRS];\n\t\t} a;\n\t\tstruct {\n\t\t\tu32 addrcount;\n\t\t\tstruct in6_addr addresses[MAX_V6_ADDRS];\n\t\t} aaaa;\n\t\tstruct {\n\t\t\tchar name[HOST_NAME_MAX];\n\t\t} ptr;\n\t} data;\n};\n\nstruct nameserver {\n\tevutil_socket_t socket;\t /* a connected UDP socket */\n\tstruct sockaddr_storage address;\n\tev_socklen_t addrlen;\n\tint failed_times;  /* number of times which we have given this server a chance */\n\tint timedout;  /* number of times in a row a request has timed out */\n\tstruct event event;\n\t/* these objects are kept in a circular list */\n\tstruct nameserver *next, *prev;\n\tstruct event timeout_event;  /* used to keep the timeout for */\n\t\t\t\t     /* when we next probe this server. */\n\t\t\t\t     /* Valid if state == 0 */\n\t/* Outstanding probe request for this nameserver, if any */\n\tstruct evdns_request *probe_request;\n\tchar state;  /* zero if we think that this server is down */\n\tchar choked;  /* true if we have an EAGAIN from this server's socket */\n\tchar write_waiting;  /* true if we are waiting for EV_WRITE events */\n\tstruct evdns_base *base;\n\n\t/* Number of currently inflight requests: used\n\t * to track when we should add/del the event. */\n\tint requests_inflight;\n};\n\n\n/* Represents a local port where we're listening for DNS requests. Right now, */\n/* only UDP is supported. */\nstruct evdns_server_port {\n\tevutil_socket_t socket; /* socket we use to read queries and write replies. */\n\tint refcnt; /* reference count. */\n\tchar choked; /* Are we currently blocked from writing? */\n\tchar closing; /* Are we trying to close this port, pending writes? */\n\tevdns_request_callback_fn_type user_callback; /* Fn to handle requests */\n\tvoid *user_data; /* Opaque pointer passed to user_callback */\n\tstruct event event; /* Read/write event */\n\t/* circular list of replies that we want to write. */\n\tstruct server_request *pending_replies;\n\tstruct event_base *event_base;\n\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\n\tvoid *lock;\n#endif\n};\n\n/* Represents part of a reply being built.\t(That is, a single RR.) */\nstruct server_reply_item {\n\tstruct server_reply_item *next; /* next item in sequence. */\n\tchar *name; /* name part of the RR */\n\tu16 type; /* The RR type */\n\tu16 class; /* The RR class (usually CLASS_INET) */\n\tu32 ttl; /* The RR TTL */\n\tchar is_name; /* True iff data is a label */\n\tu16 datalen; /* Length of data; -1 if data is a label */\n\tvoid *data; /* The contents of the RR */\n};\n\n/* Represents a request that we've received as a DNS server, and holds */\n/* the components of the reply as we're constructing it. */\nstruct server_request {\n\t/* Pointers to the next and previous entries on the list of replies */\n\t/* that we're waiting to write.\t Only set if we have tried to respond */\n\t/* and gotten EAGAIN. */\n\tstruct server_request *next_pending;\n\tstruct server_request *prev_pending;\n\n\tu16 trans_id; /* Transaction id. */\n\tstruct evdns_server_port *port; /* Which port received this request on? */\n\tstruct sockaddr_storage addr; /* Where to send the response */\n\tev_socklen_t addrlen; /* length of addr */\n\n\tint n_answer; /* how many answer RRs have been set? */\n\tint n_authority; /* how many authority RRs have been set? */\n\tint n_additional; /* how many additional RRs have been set? */\n\n\tstruct server_reply_item *answer; /* linked list of answer RRs */\n\tstruct server_reply_item *authority; /* linked list of authority RRs */\n\tstruct server_reply_item *additional; /* linked list of additional RRs */\n\n\t/* Constructed response.  Only set once we're ready to send a reply. */\n\t/* Once this is set, the RR fields are cleared, and no more should be set. */\n\tchar *response;\n\tsize_t response_len;\n\n\t/* Caller-visible fields: flags, questions. */\n\tstruct evdns_server_request base;\n};\n\nstruct evdns_base {\n\t/* An array of n_req_heads circular lists for inflight requests.\n\t * Each inflight request req is in req_heads[req->trans_id % n_req_heads].\n\t */\n\tstruct request **req_heads;\n\t/* A circular list of requests that we're waiting to send, but haven't\n\t * sent yet because there are too many requests inflight */\n\tstruct request *req_waiting_head;\n\t/* A circular list of nameservers. */\n\tstruct nameserver *server_head;\n\tint n_req_heads;\n\n\tstruct event_base *event_base;\n\n\t/* The number of good nameservers that we have */\n\tint global_good_nameservers;\n\n\t/* inflight requests are contained in the req_head list */\n\t/* and are actually going out across the network */\n\tint global_requests_inflight;\n\t/* requests which aren't inflight are in the waiting list */\n\t/* and are counted here */\n\tint global_requests_waiting;\n\n\tint global_max_requests_inflight;\n\n\tstruct timeval global_timeout;\t/* 5 seconds by default */\n\tint global_max_reissues;  /* a reissue occurs when we get some errors from the server */\n\tint global_max_retransmits;  /* number of times we'll retransmit a request which timed out */\n\t/* number of timeouts in a row before we consider this server to be down */\n\tint global_max_nameserver_timeout;\n\t/* true iff we will use the 0x20 hack to prevent poisoning attacks. */\n\tint global_randomize_case;\n\n\t/* The first time that a nameserver fails, how long do we wait before\n\t * probing to see if it has returned?  */\n\tstruct timeval global_nameserver_probe_initial_timeout;\n\n\t/** Port to bind to for outgoing DNS packets. */\n\tstruct sockaddr_storage global_outgoing_address;\n\t/** ev_socklen_t for global_outgoing_address. 0 if it isn't set. */\n\tev_socklen_t global_outgoing_addrlen;\n\n\tstruct timeval global_getaddrinfo_allow_skew;\n\n\tint getaddrinfo_ipv4_timeouts;\n\tint getaddrinfo_ipv6_timeouts;\n\tint getaddrinfo_ipv4_answered;\n\tint getaddrinfo_ipv6_answered;\n\n\tstruct search_state *global_search_state;\n\n\tTAILQ_HEAD(hosts_list, hosts_entry) hostsdb;\n\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\n\tvoid *lock;\n#endif\n\n\tint disable_when_inactive;\n};\n\nstruct hosts_entry {\n\tTAILQ_ENTRY(hosts_entry) next;\n\tunion {\n\t\tstruct sockaddr sa;\n\t\tstruct sockaddr_in sin;\n\t\tstruct sockaddr_in6 sin6;\n\t} addr;\n\tint addrlen;\n\tchar hostname[1];\n};\n\nstatic struct evdns_base *current_base = NULL;\n\nstruct evdns_base *\nevdns_get_global_base(void)\n{\n\treturn current_base;\n}\n\n/* Given a pointer to an evdns_server_request, get the corresponding */\n/* server_request. */\n#define TO_SERVER_REQUEST(base_ptr)\t\t\t\t\t\\\n\t((struct server_request*)\t\t\t\t\t\\\n\t  (((char*)(base_ptr) - evutil_offsetof(struct server_request, base))))\n\n#define REQ_HEAD(base, id) ((base)->req_heads[id % (base)->n_req_heads])\n\nstatic struct nameserver *nameserver_pick(struct evdns_base *base);\nstatic void evdns_request_insert(struct request *req, struct request **head);\nstatic void evdns_request_remove(struct request *req, struct request **head);\nstatic void nameserver_ready_callback(evutil_socket_t fd, short events, void *arg);\nstatic int evdns_transmit(struct evdns_base *base);\nstatic int evdns_request_transmit(struct request *req);\nstatic void nameserver_send_probe(struct nameserver *const ns);\nstatic void search_request_finished(struct evdns_request *const);\nstatic int search_try_next(struct evdns_request *const req);\nstatic struct request *search_request_new(struct evdns_base *base, struct evdns_request *handle, int type, const char *const name, int flags, evdns_callback_type user_callback, void *user_arg);\nstatic void evdns_requests_pump_waiting_queue(struct evdns_base *base);\nstatic u16 transaction_id_pick(struct evdns_base *base);\nstatic struct request *request_new(struct evdns_base *base, struct evdns_request *handle, int type, const char *name, int flags, evdns_callback_type callback, void *ptr);\nstatic void request_submit(struct request *const req);\n\nstatic int server_request_free(struct server_request *req);\nstatic void server_request_free_answers(struct server_request *req);\nstatic void server_port_free(struct evdns_server_port *port);\nstatic void server_port_ready_callback(evutil_socket_t fd, short events, void *arg);\nstatic int evdns_base_resolv_conf_parse_impl(struct evdns_base *base, int flags, const char *const filename);\nstatic int evdns_base_set_option_impl(struct evdns_base *base,\n    const char *option, const char *val, int flags);\nstatic void evdns_base_free_and_unlock(struct evdns_base *base, int fail_requests);\nstatic void evdns_request_timeout_callback(evutil_socket_t fd, short events, void *arg);\n\nstatic int strtoint(const char *const str);\n\n#ifdef EVENT__DISABLE_THREAD_SUPPORT\n#define EVDNS_LOCK(base)  EVUTIL_NIL_STMT_\n#define EVDNS_UNLOCK(base) EVUTIL_NIL_STMT_\n#define ASSERT_LOCKED(base) EVUTIL_NIL_STMT_\n#else\n#define EVDNS_LOCK(base)\t\t\t\\\n\tEVLOCK_LOCK((base)->lock, 0)\n#define EVDNS_UNLOCK(base)\t\t\t\\\n\tEVLOCK_UNLOCK((base)->lock, 0)\n#define ASSERT_LOCKED(base)\t\t\t\\\n\tEVLOCK_ASSERT_LOCKED((base)->lock)\n#endif\n\nstatic evdns_debug_log_fn_type evdns_log_fn = NULL;\n\nvoid\nevdns_set_log_fn(evdns_debug_log_fn_type fn)\n{\n\tevdns_log_fn = fn;\n}\n\n#ifdef __GNUC__\n#define EVDNS_LOG_CHECK\t __attribute__ ((format(printf, 2, 3)))\n#else\n#define EVDNS_LOG_CHECK\n#endif\n\nstatic void evdns_log_(int severity, const char *fmt, ...) EVDNS_LOG_CHECK;\nstatic void\nevdns_log_(int severity, const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args,fmt);\n\tif (evdns_log_fn) {\n\t\tchar buf[512];\n\t\tint is_warn = (severity == EVDNS_LOG_WARN);\n\t\tevutil_vsnprintf(buf, sizeof(buf), fmt, args);\n\t\tevdns_log_fn(is_warn, buf);\n\t} else {\n\t\tevent_logv_(severity, NULL, fmt, args);\n\t}\n\tva_end(args);\n}\n\n#define log evdns_log_\n\n/* This walks the list of inflight requests to find the */\n/* one with a matching transaction id. Returns NULL on */\n/* failure */\nstatic struct request *\nrequest_find_from_trans_id(struct evdns_base *base, u16 trans_id) {\n\tstruct request *req = REQ_HEAD(base, trans_id);\n\tstruct request *const started_at = req;\n\n\tASSERT_LOCKED(base);\n\n\tif (req) {\n\t\tdo {\n\t\t\tif (req->trans_id == trans_id) return req;\n\t\t\treq = req->next;\n\t\t} while (req != started_at);\n\t}\n\n\treturn NULL;\n}\n\n/* a libevent callback function which is called when a nameserver */\n/* has gone down and we want to test if it has came back to life yet */\nstatic void\nnameserver_prod_callback(evutil_socket_t fd, short events, void *arg) {\n\tstruct nameserver *const ns = (struct nameserver *) arg;\n\t(void)fd;\n\t(void)events;\n\n\tEVDNS_LOCK(ns->base);\n\tnameserver_send_probe(ns);\n\tEVDNS_UNLOCK(ns->base);\n}\n\n/* a libevent callback which is called when a nameserver probe (to see if */\n/* it has come back to life) times out. We increment the count of failed_times */\n/* and wait longer to send the next probe packet. */\nstatic void\nnameserver_probe_failed(struct nameserver *const ns) {\n\tstruct timeval timeout;\n\tint i;\n\n\tASSERT_LOCKED(ns->base);\n\t(void) evtimer_del(&ns->timeout_event);\n\tif (ns->state == 1) {\n\t\t/* This can happen if the nameserver acts in a way which makes us mark */\n\t\t/* it as bad and then starts sending good replies. */\n\t\treturn;\n\t}\n\n#define MAX_PROBE_TIMEOUT 3600\n#define TIMEOUT_BACKOFF_FACTOR 3\n\n\tmemcpy(&timeout, &ns->base->global_nameserver_probe_initial_timeout,\n\t    sizeof(struct timeval));\n\tfor (i=ns->failed_times; i > 0 && timeout.tv_sec < MAX_PROBE_TIMEOUT; --i) {\n\t\ttimeout.tv_sec *= TIMEOUT_BACKOFF_FACTOR;\n\t\ttimeout.tv_usec *= TIMEOUT_BACKOFF_FACTOR;\n\t\tif (timeout.tv_usec > 1000000) {\n\t\t\ttimeout.tv_sec += timeout.tv_usec / 1000000;\n\t\t\ttimeout.tv_usec %= 1000000;\n\t\t}\n\t}\n\tif (timeout.tv_sec > MAX_PROBE_TIMEOUT) {\n\t\ttimeout.tv_sec = MAX_PROBE_TIMEOUT;\n\t\ttimeout.tv_usec = 0;\n\t}\n\n\tns->failed_times++;\n\n\tif (evtimer_add(&ns->timeout_event, &timeout) < 0) {\n\t\tchar addrbuf[128];\n\t\tlog(EVDNS_LOG_WARN,\n\t\t    \"Error from libevent when adding timer event for %s\",\n\t\t    evutil_format_sockaddr_port_(\n\t\t\t    (struct sockaddr *)&ns->address,\n\t\t\t    addrbuf, sizeof(addrbuf)));\n\t}\n}\n\nstatic void\nrequest_swap_ns(struct request *req, struct nameserver *ns) {\n\tif (ns && req->ns != ns) {\n\t\tEVUTIL_ASSERT(req->ns->requests_inflight > 0);\n\t\treq->ns->requests_inflight--;\n\t\tns->requests_inflight++;\n\n\t\treq->ns = ns;\n\t}\n}\n\n/* called when a nameserver has been deemed to have failed. For example, too */\n/* many packets have timed out etc */\nstatic void\nnameserver_failed(struct nameserver *const ns, const char *msg) {\n\tstruct request *req, *started_at;\n\tstruct evdns_base *base = ns->base;\n\tint i;\n\tchar addrbuf[128];\n\n\tASSERT_LOCKED(base);\n\t/* if this nameserver has already been marked as failed */\n\t/* then don't do anything */\n\tif (!ns->state) return;\n\n\tlog(EVDNS_LOG_MSG, \"Nameserver %s has failed: %s\",\n\t    evutil_format_sockaddr_port_(\n\t\t    (struct sockaddr *)&ns->address,\n\t\t    addrbuf, sizeof(addrbuf)),\n\t    msg);\n\n\tbase->global_good_nameservers--;\n\tEVUTIL_ASSERT(base->global_good_nameservers >= 0);\n\tif (base->global_good_nameservers == 0) {\n\t\tlog(EVDNS_LOG_MSG, \"All nameservers have failed\");\n\t}\n\n\tns->state = 0;\n\tns->failed_times = 1;\n\n\tif (evtimer_add(&ns->timeout_event,\n\t\t&base->global_nameserver_probe_initial_timeout) < 0) {\n\t\tlog(EVDNS_LOG_WARN,\n\t\t    \"Error from libevent when adding timer event for %s\",\n\t\t    evutil_format_sockaddr_port_(\n\t\t\t    (struct sockaddr *)&ns->address,\n\t\t\t    addrbuf, sizeof(addrbuf)));\n\t\t/* ???? Do more? */\n\t}\n\n\t/* walk the list of inflight requests to see if any can be reassigned to */\n\t/* a different server. Requests in the waiting queue don't have a */\n\t/* nameserver assigned yet */\n\n\t/* if we don't have *any* good nameservers then there's no point */\n\t/* trying to reassign requests to one */\n\tif (!base->global_good_nameservers) return;\n\n\tfor (i = 0; i < base->n_req_heads; ++i) {\n\t\treq = started_at = base->req_heads[i];\n\t\tif (req) {\n\t\t\tdo {\n\t\t\t\tif (req->tx_count == 0 && req->ns == ns) {\n\t\t\t\t\t/* still waiting to go out, can be moved */\n\t\t\t\t\t/* to another server */\n\t\t\t\t\trequest_swap_ns(req, nameserver_pick(base));\n\t\t\t\t}\n\t\t\t\treq = req->next;\n\t\t\t} while (req != started_at);\n\t\t}\n\t}\n}\n\nstatic void\nnameserver_up(struct nameserver *const ns)\n{\n\tchar addrbuf[128];\n\tASSERT_LOCKED(ns->base);\n\tif (ns->state) return;\n\tlog(EVDNS_LOG_MSG, \"Nameserver %s is back up\",\n\t    evutil_format_sockaddr_port_(\n\t\t    (struct sockaddr *)&ns->address,\n\t\t    addrbuf, sizeof(addrbuf)));\n\tevtimer_del(&ns->timeout_event);\n\tif (ns->probe_request) {\n\t\tevdns_cancel_request(ns->base, ns->probe_request);\n\t\tns->probe_request = NULL;\n\t}\n\tns->state = 1;\n\tns->failed_times = 0;\n\tns->timedout = 0;\n\tns->base->global_good_nameservers++;\n}\n\nstatic void\nrequest_trans_id_set(struct request *const req, const u16 trans_id) {\n\treq->trans_id = trans_id;\n\t*((u16 *) req->request) = htons(trans_id);\n}\n\n/* Called to remove a request from a list and dealloc it. */\n/* head is a pointer to the head of the list it should be */\n/* removed from or NULL if the request isn't in a list. */\n/* when free_handle is one, free the handle as well. */\nstatic void\nrequest_finished(struct request *const req, struct request **head, int free_handle) {\n\tstruct evdns_base *base = req->base;\n\tint was_inflight = (head != &base->req_waiting_head);\n\tEVDNS_LOCK(base);\n\tASSERT_VALID_REQUEST(req);\n\n\tif (head)\n\t\tevdns_request_remove(req, head);\n\n\tlog(EVDNS_LOG_DEBUG, \"Removing timeout for request %p\", req);\n\tif (was_inflight) {\n\t\tevtimer_del(&req->timeout_event);\n\t\tbase->global_requests_inflight--;\n\t\treq->ns->requests_inflight--;\n\t} else {\n\t\tbase->global_requests_waiting--;\n\t}\n\t/* it was initialized during request_new / evtimer_assign */\n\tevent_debug_unassign(&req->timeout_event);\n\n\tif (req->ns &&\n\t    req->ns->requests_inflight == 0 &&\n\t    req->base->disable_when_inactive) {\n\t\tevent_del(&req->ns->event);\n\t\tevtimer_del(&req->ns->timeout_event);\n\t}\n\n\tif (!req->request_appended) {\n\t\t/* need to free the request data on it's own */\n\t\tmm_free(req->request);\n\t} else {\n\t\t/* the request data is appended onto the header */\n\t\t/* so everything gets free()ed when we: */\n\t}\n\n\tif (req->handle) {\n\t\tEVUTIL_ASSERT(req->handle->current_req == req);\n\n\t\tif (free_handle) {\n\t\t\tsearch_request_finished(req->handle);\n\t\t\treq->handle->current_req = NULL;\n\t\t\tif (! req->handle->pending_cb) {\n\t\t\t\t/* If we're planning to run the callback,\n\t\t\t\t * don't free the handle until later. */\n\t\t\t\tmm_free(req->handle);\n\t\t\t}\n\t\t\treq->handle = NULL; /* If we have a bug, let's crash\n\t\t\t\t\t     * early */\n\t\t} else {\n\t\t\treq->handle->current_req = NULL;\n\t\t}\n\t}\n\n\tmm_free(req);\n\n\tevdns_requests_pump_waiting_queue(base);\n\tEVDNS_UNLOCK(base);\n}\n\n/* This is called when a server returns a funny error code. */\n/* We try the request again with another server. */\n/* */\n/* return: */\n/*   0 ok */\n/*   1 failed/reissue is pointless */\nstatic int\nrequest_reissue(struct request *req) {\n\tconst struct nameserver *const last_ns = req->ns;\n\tASSERT_LOCKED(req->base);\n\tASSERT_VALID_REQUEST(req);\n\t/* the last nameserver should have been marked as failing */\n\t/* by the caller of this function, therefore pick will try */\n\t/* not to return it */\n\trequest_swap_ns(req, nameserver_pick(req->base));\n\tif (req->ns == last_ns) {\n\t\t/* ... but pick did return it */\n\t\t/* not a lot of point in trying again with the */\n\t\t/* same server */\n\t\treturn 1;\n\t}\n\n\treq->reissue_count++;\n\treq->tx_count = 0;\n\treq->transmit_me = 1;\n\n\treturn 0;\n}\n\n/* this function looks for space on the inflight queue and promotes */\n/* requests from the waiting queue if it can. */\n/* */\n/* TODO: */\n/* add return code, see at nameserver_pick() and other functions. */\nstatic void\nevdns_requests_pump_waiting_queue(struct evdns_base *base) {\n\tASSERT_LOCKED(base);\n\twhile (base->global_requests_inflight < base->global_max_requests_inflight &&\n\t\t   base->global_requests_waiting) {\n\t\tstruct request *req;\n\n\t\tEVUTIL_ASSERT(base->req_waiting_head);\n\t\treq = base->req_waiting_head;\n\n\t\treq->ns = nameserver_pick(base);\n\t\tif (!req->ns)\n\t\t\treturn;\n\n\t\t/* move a request from the waiting queue to the inflight queue */\n\t\treq->ns->requests_inflight++;\n\n\t\tevdns_request_remove(req, &base->req_waiting_head);\n\n\t\tbase->global_requests_waiting--;\n\t\tbase->global_requests_inflight++;\n\n\t\trequest_trans_id_set(req, transaction_id_pick(base));\n\n\t\tevdns_request_insert(req, &REQ_HEAD(base, req->trans_id));\n\t\tevdns_request_transmit(req);\n\t\tevdns_transmit(base);\n\t}\n}\n\n/* TODO(nickm) document */\nstruct deferred_reply_callback {\n\tstruct event_callback deferred;\n\tstruct evdns_request *handle;\n\tu8 request_type;\n\tu8 have_reply;\n\tu32 ttl;\n\tu32 err;\n\tevdns_callback_type user_callback;\n\tstruct reply reply;\n};\n\nstatic void\nreply_run_callback(struct event_callback *d, void *user_pointer)\n{\n\tstruct deferred_reply_callback *cb =\n\t    EVUTIL_UPCAST(d, struct deferred_reply_callback, deferred);\n\n\tswitch (cb->request_type) {\n\tcase TYPE_A:\n\t\tif (cb->have_reply)\n\t\t\tcb->user_callback(DNS_ERR_NONE, DNS_IPv4_A,\n\t\t\t    cb->reply.data.a.addrcount, cb->ttl,\n\t\t\t    cb->reply.data.a.addresses,\n\t\t\t    user_pointer);\n\t\telse\n\t\t\tcb->user_callback(cb->err, 0, 0, cb->ttl, NULL, user_pointer);\n\t\tbreak;\n\tcase TYPE_PTR:\n\t\tif (cb->have_reply) {\n\t\t\tchar *name = cb->reply.data.ptr.name;\n\t\t\tcb->user_callback(DNS_ERR_NONE, DNS_PTR, 1, cb->ttl,\n\t\t\t    &name, user_pointer);\n\t\t} else {\n\t\t\tcb->user_callback(cb->err, 0, 0, cb->ttl, NULL, user_pointer);\n\t\t}\n\t\tbreak;\n\tcase TYPE_AAAA:\n\t\tif (cb->have_reply)\n\t\t\tcb->user_callback(DNS_ERR_NONE, DNS_IPv6_AAAA,\n\t\t\t    cb->reply.data.aaaa.addrcount, cb->ttl,\n\t\t\t    cb->reply.data.aaaa.addresses,\n\t\t\t    user_pointer);\n\t\telse\n\t\t\tcb->user_callback(cb->err, 0, 0, cb->ttl, NULL, user_pointer);\n\t\tbreak;\n\tdefault:\n\t\tEVUTIL_ASSERT(0);\n\t}\n\n\tif (cb->handle && cb->handle->pending_cb) {\n\t\tmm_free(cb->handle);\n\t}\n\n\tmm_free(cb);\n}\n\nstatic void\nreply_schedule_callback(struct request *const req, u32 ttl, u32 err, struct reply *reply)\n{\n\tstruct deferred_reply_callback *d = mm_calloc(1, sizeof(*d));\n\n\tif (!d) {\n\t\tevent_warn(\"%s: Couldn't allocate space for deferred callback.\",\n\t\t    __func__);\n\t\treturn;\n\t}\n\n\tASSERT_LOCKED(req->base);\n\n\td->request_type = req->request_type;\n\td->user_callback = req->user_callback;\n\td->ttl = ttl;\n\td->err = err;\n\tif (reply) {\n\t\td->have_reply = 1;\n\t\tmemcpy(&d->reply, reply, sizeof(struct reply));\n\t}\n\n\tif (req->handle) {\n\t\treq->handle->pending_cb = 1;\n\t\td->handle = req->handle;\n\t}\n\n\tevent_deferred_cb_init_(\n\t    &d->deferred,\n\t    event_get_priority(&req->timeout_event),\n\t    reply_run_callback,\n\t    req->user_pointer);\n\tevent_deferred_cb_schedule_(\n\t\treq->base->event_base,\n\t\t&d->deferred);\n}\n\n/* this processes a parsed reply packet */\nstatic void\nreply_handle(struct request *const req, u16 flags, u32 ttl, struct reply *reply) {\n\tint error;\n\tchar addrbuf[128];\n\tstatic const int error_codes[] = {\n\t\tDNS_ERR_FORMAT, DNS_ERR_SERVERFAILED, DNS_ERR_NOTEXIST,\n\t\tDNS_ERR_NOTIMPL, DNS_ERR_REFUSED\n\t};\n\n\tASSERT_LOCKED(req->base);\n\tASSERT_VALID_REQUEST(req);\n\n\tif (flags & 0x020f || !reply || !reply->have_answer) {\n\t\t/* there was an error */\n\t\tif (flags & 0x0200) {\n\t\t\terror = DNS_ERR_TRUNCATED;\n\t\t} else if (flags & 0x000f) {\n\t\t\tu16 error_code = (flags & 0x000f) - 1;\n\t\t\tif (error_code > 4) {\n\t\t\t\terror = DNS_ERR_UNKNOWN;\n\t\t\t} else {\n\t\t\t\terror = error_codes[error_code];\n\t\t\t}\n\t\t} else if (reply && !reply->have_answer) {\n\t\t\terror = DNS_ERR_NODATA;\n\t\t} else {\n\t\t\terror = DNS_ERR_UNKNOWN;\n\t\t}\n\n\t\tswitch (error) {\n\t\tcase DNS_ERR_NOTIMPL:\n\t\tcase DNS_ERR_REFUSED:\n\t\t\t/* we regard these errors as marking a bad nameserver */\n\t\t\tif (req->reissue_count < req->base->global_max_reissues) {\n\t\t\t\tchar msg[64];\n\t\t\t\tevutil_snprintf(msg, sizeof(msg), \"Bad response %d (%s)\",\n\t\t\t\t\t error, evdns_err_to_string(error));\n\t\t\t\tnameserver_failed(req->ns, msg);\n\t\t\t\tif (!request_reissue(req)) return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_ERR_SERVERFAILED:\n\t\t\t/* rcode 2 (servfailed) sometimes means \"we\n\t\t\t * are broken\" and sometimes (with some binds)\n\t\t\t * means \"that request was very confusing.\"\n\t\t\t * Treat this as a timeout, not a failure.\n\t\t\t */\n\t\t\tlog(EVDNS_LOG_DEBUG, \"Got a SERVERFAILED from nameserver\"\n\t\t\t\t\"at %s; will allow the request to time out.\",\n\t\t\t    evutil_format_sockaddr_port_(\n\t\t\t\t    (struct sockaddr *)&req->ns->address,\n\t\t\t\t    addrbuf, sizeof(addrbuf)));\n\t\t\t/* Call the timeout function */\n\t\t\tevdns_request_timeout_callback(0, 0, req);\n\t\t\treturn;\n\t\tdefault:\n\t\t\t/* we got a good reply from the nameserver: it is up. */\n\t\t\tif (req->handle == req->ns->probe_request) {\n\t\t\t\t/* Avoid double-free */\n\t\t\t\treq->ns->probe_request = NULL;\n\t\t\t}\n\n\t\t\tnameserver_up(req->ns);\n\t\t}\n\n\t\tif (req->handle->search_state &&\n\t\t    req->request_type != TYPE_PTR) {\n\t\t\t/* if we have a list of domains to search in,\n\t\t\t * try the next one */\n\t\t\tif (!search_try_next(req->handle)) {\n\t\t\t\t/* a new request was issued so this\n\t\t\t\t * request is finished and */\n\t\t\t\t/* the user callback will be made when\n\t\t\t\t * that request (or a */\n\t\t\t\t/* child of it) finishes. */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* all else failed. Pass the failure up */\n\t\treply_schedule_callback(req, ttl, error, NULL);\n\t\trequest_finished(req, &REQ_HEAD(req->base, req->trans_id), 1);\n\t} else {\n\t\t/* all ok, tell the user */\n\t\treply_schedule_callback(req, ttl, 0, reply);\n\t\tif (req->handle == req->ns->probe_request)\n\t\t\treq->ns->probe_request = NULL; /* Avoid double-free */\n\t\tnameserver_up(req->ns);\n\t\trequest_finished(req, &REQ_HEAD(req->base, req->trans_id), 1);\n\t}\n}\n\nstatic int\nname_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {\n\tint name_end = -1;\n\tint j = *idx;\n\tint ptr_count = 0;\n#define GET32(x) do { if (j + 4 > length) goto err; memcpy(&t32_, packet + j, 4); j += 4; x = ntohl(t32_); } while (0)\n#define GET16(x) do { if (j + 2 > length) goto err; memcpy(&t_, packet + j, 2); j += 2; x = ntohs(t_); } while (0)\n#define GET8(x) do { if (j >= length) goto err; x = packet[j++]; } while (0)\n\n\tchar *cp = name_out;\n\tconst char *const end = name_out + name_out_len;\n\n\t/* Normally, names are a series of length prefixed strings terminated */\n\t/* with a length of 0 (the lengths are u8's < 63). */\n\t/* However, the length can start with a pair of 1 bits and that */\n\t/* means that the next 14 bits are a pointer within the current */\n\t/* packet. */\n\n\tfor (;;) {\n\t\tu8 label_len;\n\t\tGET8(label_len);\n\t\tif (!label_len) break;\n\t\tif (label_len & 0xc0) {\n\t\t\tu8 ptr_low;\n\t\t\tGET8(ptr_low);\n\t\t\tif (name_end < 0) name_end = j;\n\t\t\tj = (((int)label_len & 0x3f) << 8) + ptr_low;\n\t\t\t/* Make sure that the target offset is in-bounds. */\n\t\t\tif (j < 0 || j >= length) return -1;\n\t\t\t/* If we've jumped more times than there are characters in the\n\t\t\t * message, we must have a loop. */\n\t\t\tif (++ptr_count > length) return -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (label_len > 63) return -1;\n\t\tif (cp != name_out) {\n\t\t\tif (cp + 1 >= end) return -1;\n\t\t\t*cp++ = '.';\n\t\t}\n\t\tif (cp + label_len >= end) return -1;\n\t\tif (j + label_len > length) return -1;\n\t\tmemcpy(cp, packet + j, label_len);\n\t\tcp += label_len;\n\t\tj += label_len;\n\t}\n\tif (cp >= end) return -1;\n\t*cp = '\\0';\n\tif (name_end < 0)\n\t\t*idx = j;\n\telse\n\t\t*idx = name_end;\n\treturn 0;\n err:\n\treturn -1;\n}\n\n/* parses a raw request from a nameserver */\nstatic int\nreply_parse(struct evdns_base *base, u8 *packet, int length) {\n\tint j = 0, k = 0;  /* index into packet */\n\tu16 t_;\t /* used by the macros */\n\tu32 t32_;  /* used by the macros */\n\tchar tmp_name[256], cmp_name[256]; /* used by the macros */\n\tint name_matches = 0;\n\n\tu16 trans_id, questions, answers, authority, additional, datalength;\n\tu16 flags = 0;\n\tu32 ttl, ttl_r = 0xffffffff;\n\tstruct reply reply;\n\tstruct request *req = NULL;\n\tunsigned int i;\n\n\tASSERT_LOCKED(base);\n\n\tGET16(trans_id);\n\tGET16(flags);\n\tGET16(questions);\n\tGET16(answers);\n\tGET16(authority);\n\tGET16(additional);\n\t(void) authority; /* suppress \"unused variable\" warnings. */\n\t(void) additional; /* suppress \"unused variable\" warnings. */\n\n\treq = request_find_from_trans_id(base, trans_id);\n\tif (!req) return -1;\n\tEVUTIL_ASSERT(req->base == base);\n\n\tmemset(&reply, 0, sizeof(reply));\n\n\t/* If it's not an answer, it doesn't correspond to any request. */\n\tif (!(flags & 0x8000)) return -1;  /* must be an answer */\n\tif ((flags & 0x020f) && (flags & 0x020f) != DNS_ERR_NOTEXIST) {\n\t\t/* there was an error and it's not NXDOMAIN */\n\t\tgoto err;\n\t}\n\t/* if (!answers) return; */  /* must have an answer of some form */\n\n\t/* This macro skips a name in the DNS reply. */\n#define SKIP_NAME\t\t\t\t\t\t\\\n\tdo { tmp_name[0] = '\\0';\t\t\t\t\\\n\t\tif (name_parse(packet, length, &j, tmp_name,\t\\\n\t\t\tsizeof(tmp_name))<0)\t\t\t\\\n\t\t\tgoto err;\t\t\t\t\\\n\t} while (0)\n\n\treply.type = req->request_type;\n\n\t/* skip over each question in the reply */\n\tfor (i = 0; i < questions; ++i) {\n\t\t/* the question looks like\n\t\t *   <label:name><u16:type><u16:class>\n\t\t */\n\t\ttmp_name[0] = '\\0';\n\t\tcmp_name[0] = '\\0';\n\t\tk = j;\n\t\tif (name_parse(packet, length, &j, tmp_name, sizeof(tmp_name)) < 0)\n\t\t\tgoto err;\n\t\tif (name_parse(req->request, req->request_len, &k,\n\t\t\tcmp_name, sizeof(cmp_name))<0)\n\t\t\tgoto err;\n\t\tif (!base->global_randomize_case) {\n\t\t\tif (strcmp(tmp_name, cmp_name) == 0)\n\t\t\t\tname_matches = 1;\n\t\t} else {\n\t\t\tif (evutil_ascii_strcasecmp(tmp_name, cmp_name) == 0)\n\t\t\t\tname_matches = 1;\n\t\t}\n\n\t\tj += 4;\n\t\tif (j > length)\n\t\t\tgoto err;\n\t}\n\n\tif (!name_matches)\n\t\tgoto err;\n\n\t/* now we have the answer section which looks like\n\t * <label:name><u16:type><u16:class><u32:ttl><u16:len><data...>\n\t */\n\n\tfor (i = 0; i < answers; ++i) {\n\t\tu16 type, class;\n\n\t\tSKIP_NAME;\n\t\tGET16(type);\n\t\tGET16(class);\n\t\tGET32(ttl);\n\t\tGET16(datalength);\n\n\t\tif (type == TYPE_A && class == CLASS_INET) {\n\t\t\tint addrcount, addrtocopy;\n\t\t\tif (req->request_type != TYPE_A) {\n\t\t\t\tj += datalength; continue;\n\t\t\t}\n\t\t\tif ((datalength & 3) != 0) /* not an even number of As. */\n\t\t\t    goto err;\n\t\t\taddrcount = datalength >> 2;\n\t\t\taddrtocopy = MIN(MAX_V4_ADDRS - reply.data.a.addrcount, (unsigned)addrcount);\n\n\t\t\tttl_r = MIN(ttl_r, ttl);\n\t\t\t/* we only bother with the first four addresses. */\n\t\t\tif (j + 4*addrtocopy > length) goto err;\n\t\t\tmemcpy(&reply.data.a.addresses[reply.data.a.addrcount],\n\t\t\t\t   packet + j, 4*addrtocopy);\n\t\t\tj += 4*addrtocopy;\n\t\t\treply.data.a.addrcount += addrtocopy;\n\t\t\treply.have_answer = 1;\n\t\t\tif (reply.data.a.addrcount == MAX_V4_ADDRS) break;\n\t\t} else if (type == TYPE_PTR && class == CLASS_INET) {\n\t\t\tif (req->request_type != TYPE_PTR) {\n\t\t\t\tj += datalength; continue;\n\t\t\t}\n\t\t\tif (name_parse(packet, length, &j, reply.data.ptr.name,\n\t\t\t\t\t\t   sizeof(reply.data.ptr.name))<0)\n\t\t\t\tgoto err;\n\t\t\tttl_r = MIN(ttl_r, ttl);\n\t\t\treply.have_answer = 1;\n\t\t\tbreak;\n\t\t} else if (type == TYPE_CNAME) {\n\t\t\tchar cname[HOST_NAME_MAX];\n\t\t\tif (!req->put_cname_in_ptr || *req->put_cname_in_ptr) {\n\t\t\t\tj += datalength; continue;\n\t\t\t}\n\t\t\tif (name_parse(packet, length, &j, cname,\n\t\t\t\tsizeof(cname))<0)\n\t\t\t\tgoto err;\n\t\t\t*req->put_cname_in_ptr = mm_strdup(cname);\n\t\t} else if (type == TYPE_AAAA && class == CLASS_INET) {\n\t\t\tint addrcount, addrtocopy;\n\t\t\tif (req->request_type != TYPE_AAAA) {\n\t\t\t\tj += datalength; continue;\n\t\t\t}\n\t\t\tif ((datalength & 15) != 0) /* not an even number of AAAAs. */\n\t\t\t\tgoto err;\n\t\t\taddrcount = datalength >> 4;  /* each address is 16 bytes long */\n\t\t\taddrtocopy = MIN(MAX_V6_ADDRS - reply.data.aaaa.addrcount, (unsigned)addrcount);\n\t\t\tttl_r = MIN(ttl_r, ttl);\n\n\t\t\t/* we only bother with the first four addresses. */\n\t\t\tif (j + 16*addrtocopy > length) goto err;\n\t\t\tmemcpy(&reply.data.aaaa.addresses[reply.data.aaaa.addrcount],\n\t\t\t\t   packet + j, 16*addrtocopy);\n\t\t\treply.data.aaaa.addrcount += addrtocopy;\n\t\t\tj += 16*addrtocopy;\n\t\t\treply.have_answer = 1;\n\t\t\tif (reply.data.aaaa.addrcount == MAX_V6_ADDRS) break;\n\t\t} else {\n\t\t\t/* skip over any other type of resource */\n\t\t\tj += datalength;\n\t\t}\n\t}\n\n\tif (!reply.have_answer) {\n\t\tfor (i = 0; i < authority; ++i) {\n\t\t\tu16 type, class;\n\t\t\tSKIP_NAME;\n\t\t\tGET16(type);\n\t\t\tGET16(class);\n\t\t\tGET32(ttl);\n\t\t\tGET16(datalength);\n\t\t\tif (type == TYPE_SOA && class == CLASS_INET) {\n\t\t\t\tu32 serial, refresh, retry, expire, minimum;\n\t\t\t\tSKIP_NAME;\n\t\t\t\tSKIP_NAME;\n\t\t\t\tGET32(serial);\n\t\t\t\tGET32(refresh);\n\t\t\t\tGET32(retry);\n\t\t\t\tGET32(expire);\n\t\t\t\tGET32(minimum);\n\t\t\t\t(void)expire;\n\t\t\t\t(void)retry;\n\t\t\t\t(void)refresh;\n\t\t\t\t(void)serial;\n\t\t\t\tttl_r = MIN(ttl_r, ttl);\n\t\t\t\tttl_r = MIN(ttl_r, minimum);\n\t\t\t} else {\n\t\t\t\t/* skip over any other type of resource */\n\t\t\t\tj += datalength;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ttl_r == 0xffffffff)\n\t\tttl_r = 0;\n\n\treply_handle(req, flags, ttl_r, &reply);\n\treturn 0;\n err:\n\tif (req)\n\t\treply_handle(req, flags, 0, NULL);\n\treturn -1;\n}\n\n/* Parse a raw request (packet,length) sent to a nameserver port (port) from */\n/* a DNS client (addr,addrlen), and if it's well-formed, call the corresponding */\n/* callback. */\nstatic int\nrequest_parse(u8 *packet, int length, struct evdns_server_port *port, struct sockaddr *addr, ev_socklen_t addrlen)\n{\n\tint j = 0;\t/* index into packet */\n\tu16 t_;\t /* used by the macros */\n\tchar tmp_name[256]; /* used by the macros */\n\n\tint i;\n\tu16 trans_id, flags, questions, answers, authority, additional;\n\tstruct server_request *server_req = NULL;\n\n\tASSERT_LOCKED(port);\n\n\t/* Get the header fields */\n\tGET16(trans_id);\n\tGET16(flags);\n\tGET16(questions);\n\tGET16(answers);\n\tGET16(authority);\n\tGET16(additional);\n\t(void)answers;\n\t(void)additional;\n\t(void)authority;\n\n\tif (flags & 0x8000) return -1; /* Must not be an answer. */\n\tflags &= 0x0110; /* Only RD and CD get preserved. */\n\n\tserver_req = mm_malloc(sizeof(struct server_request));\n\tif (server_req == NULL) return -1;\n\tmemset(server_req, 0, sizeof(struct server_request));\n\n\tserver_req->trans_id = trans_id;\n\tmemcpy(&server_req->addr, addr, addrlen);\n\tserver_req->addrlen = addrlen;\n\n\tserver_req->base.flags = flags;\n\tserver_req->base.nquestions = 0;\n\tserver_req->base.questions = mm_calloc(sizeof(struct evdns_server_question *), questions);\n\tif (server_req->base.questions == NULL)\n\t\tgoto err;\n\n\tfor (i = 0; i < questions; ++i) {\n\t\tu16 type, class;\n\t\tstruct evdns_server_question *q;\n\t\tint namelen;\n\t\tif (name_parse(packet, length, &j, tmp_name, sizeof(tmp_name))<0)\n\t\t\tgoto err;\n\t\tGET16(type);\n\t\tGET16(class);\n\t\tnamelen = (int)strlen(tmp_name);\n\t\tq = mm_malloc(sizeof(struct evdns_server_question) + namelen);\n\t\tif (!q)\n\t\t\tgoto err;\n\t\tq->type = type;\n\t\tq->dns_question_class = class;\n\t\tmemcpy(q->name, tmp_name, namelen+1);\n\t\tserver_req->base.questions[server_req->base.nquestions++] = q;\n\t}\n\n\t/* Ignore answers, authority, and additional. */\n\n\tserver_req->port = port;\n\tport->refcnt++;\n\n\t/* Only standard queries are supported. */\n\tif (flags & 0x7800) {\n\t\tevdns_server_request_respond(&(server_req->base), DNS_ERR_NOTIMPL);\n\t\treturn -1;\n\t}\n\n\tport->user_callback(&(server_req->base), port->user_data);\n\n\treturn 0;\nerr:\n\tif (server_req) {\n\t\tif (server_req->base.questions) {\n\t\t\tfor (i = 0; i < server_req->base.nquestions; ++i)\n\t\t\t\tmm_free(server_req->base.questions[i]);\n\t\t\tmm_free(server_req->base.questions);\n\t\t}\n\t\tmm_free(server_req);\n\t}\n\treturn -1;\n\n#undef SKIP_NAME\n#undef GET32\n#undef GET16\n#undef GET8\n}\n\n\nvoid\nevdns_set_transaction_id_fn(ev_uint16_t (*fn)(void))\n{\n}\n\nvoid\nevdns_set_random_bytes_fn(void (*fn)(char *, size_t))\n{\n}\n\n/* Try to choose a strong transaction id which isn't already in flight */\nstatic u16\ntransaction_id_pick(struct evdns_base *base) {\n\tASSERT_LOCKED(base);\n\tfor (;;) {\n\t\tu16 trans_id;\n\t\tevutil_secure_rng_get_bytes(&trans_id, sizeof(trans_id));\n\n\t\tif (trans_id == 0xffff) continue;\n\t\t/* now check to see if that id is already inflight */\n\t\tif (request_find_from_trans_id(base, trans_id) == NULL)\n\t\t\treturn trans_id;\n\t}\n}\n\n/* choose a namesever to use. This function will try to ignore */\n/* nameservers which we think are down and load balance across the rest */\n/* by updating the server_head global each time. */\nstatic struct nameserver *\nnameserver_pick(struct evdns_base *base) {\n\tstruct nameserver *started_at = base->server_head, *picked;\n\tASSERT_LOCKED(base);\n\tif (!base->server_head) return NULL;\n\n\t/* if we don't have any good nameservers then there's no */\n\t/* point in trying to find one. */\n\tif (!base->global_good_nameservers) {\n\t\tbase->server_head = base->server_head->next;\n\t\treturn base->server_head;\n\t}\n\n\t/* remember that nameservers are in a circular list */\n\tfor (;;) {\n\t\tif (base->server_head->state) {\n\t\t\t/* we think this server is currently good */\n\t\t\tpicked = base->server_head;\n\t\t\tbase->server_head = base->server_head->next;\n\t\t\treturn picked;\n\t\t}\n\n\t\tbase->server_head = base->server_head->next;\n\t\tif (base->server_head == started_at) {\n\t\t\t/* all the nameservers seem to be down */\n\t\t\t/* so we just return this one and hope for the */\n\t\t\t/* best */\n\t\t\tEVUTIL_ASSERT(base->global_good_nameservers == 0);\n\t\t\tpicked = base->server_head;\n\t\t\tbase->server_head = base->server_head->next;\n\t\t\treturn picked;\n\t\t}\n\t}\n}\n\n/* this is called when a namesever socket is ready for reading */\nstatic void\nnameserver_read(struct nameserver *ns) {\n\tstruct sockaddr_storage ss;\n\tev_socklen_t addrlen = sizeof(ss);\n\tu8 packet[1500];\n\tchar addrbuf[128];\n\tASSERT_LOCKED(ns->base);\n\n\tfor (;;) {\n\t\tconst int r = recvfrom(ns->socket, (void*)packet,\n\t\t    sizeof(packet), 0,\n\t\t    (struct sockaddr*)&ss, &addrlen);\n\t\tif (r < 0) {\n\t\t\tint err = evutil_socket_geterror(ns->socket);\n\t\t\tif (EVUTIL_ERR_RW_RETRIABLE(err))\n\t\t\t\treturn;\n\t\t\tnameserver_failed(ns,\n\t\t\t    evutil_socket_error_to_string(err));\n\t\t\treturn;\n\t\t}\n\t\tif (evutil_sockaddr_cmp((struct sockaddr*)&ss,\n\t\t\t(struct sockaddr*)&ns->address, 0)) {\n\t\t\tlog(EVDNS_LOG_WARN, \"Address mismatch on received \"\n\t\t\t    \"DNS packet.  Apparent source was %s\",\n\t\t\t    evutil_format_sockaddr_port_(\n\t\t\t\t    (struct sockaddr *)&ss,\n\t\t\t\t    addrbuf, sizeof(addrbuf)));\n\t\t\treturn;\n\t\t}\n\n\t\tns->timedout = 0;\n\t\treply_parse(ns->base, packet, r);\n\t}\n}\n\n/* Read a packet from a DNS client on a server port s, parse it, and */\n/* act accordingly. */\nstatic void\nserver_port_read(struct evdns_server_port *s) {\n\tu8 packet[1500];\n\tstruct sockaddr_storage addr;\n\tev_socklen_t addrlen;\n\tint r;\n\tASSERT_LOCKED(s);\n\n\tfor (;;) {\n\t\taddrlen = sizeof(struct sockaddr_storage);\n\t\tr = recvfrom(s->socket, (void*)packet, sizeof(packet), 0,\n\t\t\t\t\t (struct sockaddr*) &addr, &addrlen);\n\t\tif (r < 0) {\n\t\t\tint err = evutil_socket_geterror(s->socket);\n\t\t\tif (EVUTIL_ERR_RW_RETRIABLE(err))\n\t\t\t\treturn;\n\t\t\tlog(EVDNS_LOG_WARN,\n\t\t\t    \"Error %s (%d) while reading request.\",\n\t\t\t    evutil_socket_error_to_string(err), err);\n\t\t\treturn;\n\t\t}\n\t\trequest_parse(packet, r, s, (struct sockaddr*) &addr, addrlen);\n\t}\n}\n\n/* Try to write all pending replies on a given DNS server port. */\nstatic void\nserver_port_flush(struct evdns_server_port *port)\n{\n\tstruct server_request *req = port->pending_replies;\n\tASSERT_LOCKED(port);\n\twhile (req) {\n\t\tint r = sendto(port->socket, req->response, (int)req->response_len, 0,\n\t\t\t   (struct sockaddr*) &req->addr, (ev_socklen_t)req->addrlen);\n\t\tif (r < 0) {\n\t\t\tint err = evutil_socket_geterror(port->socket);\n\t\t\tif (EVUTIL_ERR_RW_RETRIABLE(err))\n\t\t\t\treturn;\n\t\t\tlog(EVDNS_LOG_WARN, \"Error %s (%d) while writing response to port; dropping\", evutil_socket_error_to_string(err), err);\n\t\t}\n\t\tif (server_request_free(req)) {\n\t\t\t/* we released the last reference to req->port. */\n\t\t\treturn;\n\t\t} else {\n\t\t\tEVUTIL_ASSERT(req != port->pending_replies);\n\t\t\treq = port->pending_replies;\n\t\t}\n\t}\n\n\t/* We have no more pending requests; stop listening for 'writeable' events. */\n\t(void) event_del(&port->event);\n\tevent_assign(&port->event, port->event_base,\n\t\t\t\t port->socket, EV_READ | EV_PERSIST,\n\t\t\t\t server_port_ready_callback, port);\n\n\tif (event_add(&port->event, NULL) < 0) {\n\t\tlog(EVDNS_LOG_WARN, \"Error from libevent when adding event for DNS server.\");\n\t\t/* ???? Do more? */\n\t}\n}\n\n/* set if we are waiting for the ability to write to this server. */\n/* if waiting is true then we ask libevent for EV_WRITE events, otherwise */\n/* we stop these events. */\nstatic void\nnameserver_write_waiting(struct nameserver *ns, char waiting) {\n\tASSERT_LOCKED(ns->base);\n\tif (ns->write_waiting == waiting) return;\n\n\tns->write_waiting = waiting;\n\t(void) event_del(&ns->event);\n\tevent_assign(&ns->event, ns->base->event_base,\n\t    ns->socket, EV_READ | (waiting ? EV_WRITE : 0) | EV_PERSIST,\n\t    nameserver_ready_callback, ns);\n\tif (event_add(&ns->event, NULL) < 0) {\n\t\tchar addrbuf[128];\n\t\tlog(EVDNS_LOG_WARN, \"Error from libevent when adding event for %s\",\n\t\t    evutil_format_sockaddr_port_(\n\t\t\t    (struct sockaddr *)&ns->address,\n\t\t\t    addrbuf, sizeof(addrbuf)));\n\t\t/* ???? Do more? */\n\t}\n}\n\n/* a callback function. Called by libevent when the kernel says that */\n/* a nameserver socket is ready for writing or reading */\nstatic void\nnameserver_ready_callback(evutil_socket_t fd, short events, void *arg) {\n\tstruct nameserver *ns = (struct nameserver *) arg;\n\t(void)fd;\n\n\tEVDNS_LOCK(ns->base);\n\tif (events & EV_WRITE) {\n\t\tns->choked = 0;\n\t\tif (!evdns_transmit(ns->base)) {\n\t\t\tnameserver_write_waiting(ns, 0);\n\t\t}\n\t}\n\tif (events & EV_READ) {\n\t\tnameserver_read(ns);\n\t}\n\tEVDNS_UNLOCK(ns->base);\n}\n\n/* a callback function. Called by libevent when the kernel says that */\n/* a server socket is ready for writing or reading. */\nstatic void\nserver_port_ready_callback(evutil_socket_t fd, short events, void *arg) {\n\tstruct evdns_server_port *port = (struct evdns_server_port *) arg;\n\t(void) fd;\n\n\tEVDNS_LOCK(port);\n\tif (events & EV_WRITE) {\n\t\tport->choked = 0;\n\t\tserver_port_flush(port);\n\t}\n\tif (events & EV_READ) {\n\t\tserver_port_read(port);\n\t}\n\tEVDNS_UNLOCK(port);\n}\n\n/* This is an inefficient representation; only use it via the dnslabel_table_*\n * functions, so that is can be safely replaced with something smarter later. */\n#define MAX_LABELS 128\n/* Structures used to implement name compression */\nstruct dnslabel_entry { char *v; off_t pos; };\nstruct dnslabel_table {\n\tint n_labels; /* number of current entries */\n\t/* map from name to position in message */\n\tstruct dnslabel_entry labels[MAX_LABELS];\n};\n\n/* Initialize dnslabel_table. */\nstatic void\ndnslabel_table_init(struct dnslabel_table *table)\n{\n\ttable->n_labels = 0;\n}\n\n/* Free all storage held by table, but not the table itself. */\nstatic void\ndnslabel_clear(struct dnslabel_table *table)\n{\n\tint i;\n\tfor (i = 0; i < table->n_labels; ++i)\n\t\tmm_free(table->labels[i].v);\n\ttable->n_labels = 0;\n}\n\n/* return the position of the label in the current message, or -1 if the label */\n/* hasn't been used yet. */\nstatic int\ndnslabel_table_get_pos(const struct dnslabel_table *table, const char *label)\n{\n\tint i;\n\tfor (i = 0; i < table->n_labels; ++i) {\n\t\tif (!strcmp(label, table->labels[i].v))\n\t\t\treturn table->labels[i].pos;\n\t}\n\treturn -1;\n}\n\n/* remember that we've used the label at position pos */\nstatic int\ndnslabel_table_add(struct dnslabel_table *table, const char *label, off_t pos)\n{\n\tchar *v;\n\tint p;\n\tif (table->n_labels == MAX_LABELS)\n\t\treturn (-1);\n\tv = mm_strdup(label);\n\tif (v == NULL)\n\t\treturn (-1);\n\tp = table->n_labels++;\n\ttable->labels[p].v = v;\n\ttable->labels[p].pos = pos;\n\n\treturn (0);\n}\n\n/* Converts a string to a length-prefixed set of DNS labels, starting */\n/* at buf[j]. name and buf must not overlap. name_len should be the length */\n/* of name.\t table is optional, and is used for compression. */\n/* */\n/* Input: abc.def */\n/* Output: <3>abc<3>def<0> */\n/* */\n/* Returns the first index after the encoded name, or negative on error. */\n/*\t -1\t label was > 63 bytes */\n/*\t -2\t name too long to fit in buffer. */\n/* */\nstatic off_t\ndnsname_to_labels(u8 *const buf, size_t buf_len, off_t j,\n\t\t\t\t  const char *name, const size_t name_len,\n\t\t\t\t  struct dnslabel_table *table) {\n\tconst char *end = name + name_len;\n\tint ref = 0;\n\tu16 t_;\n\n#define APPEND16(x) do {\t\t\t\t\t\t\\\n\t\tif (j + 2 > (off_t)buf_len)\t\t\t\t\\\n\t\t\tgoto overflow;\t\t\t\t\t\\\n\t\tt_ = htons(x);\t\t\t\t\t\t\\\n\t\tmemcpy(buf + j, &t_, 2);\t\t\t\t\\\n\t\tj += 2;\t\t\t\t\t\t\t\\\n\t} while (0)\n#define APPEND32(x) do {\t\t\t\t\t\t\\\n\t\tif (j + 4 > (off_t)buf_len)\t\t\t\t\\\n\t\t\tgoto overflow;\t\t\t\t\t\\\n\t\tt32_ = htonl(x);\t\t\t\t\t\\\n\t\tmemcpy(buf + j, &t32_, 4);\t\t\t\t\\\n\t\tj += 4;\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\tif (name_len > 255) return -2;\n\n\tfor (;;) {\n\t\tconst char *const start = name;\n\t\tif (table && (ref = dnslabel_table_get_pos(table, name)) >= 0) {\n\t\t\tAPPEND16(ref | 0xc000);\n\t\t\treturn j;\n\t\t}\n\t\tname = strchr(name, '.');\n\t\tif (!name) {\n\t\t\tconst size_t label_len = end - start;\n\t\t\tif (label_len > 63) return -1;\n\t\t\tif ((size_t)(j+label_len+1) > buf_len) return -2;\n\t\t\tif (table) dnslabel_table_add(table, start, j);\n\t\t\tbuf[j++] = (ev_uint8_t)label_len;\n\n\t\t\tmemcpy(buf + j, start, label_len);\n\t\t\tj += (int) label_len;\n\t\t\tbreak;\n\t\t} else {\n\t\t\t/* append length of the label. */\n\t\t\tconst size_t label_len = name - start;\n\t\t\tif (label_len > 63) return -1;\n\t\t\tif ((size_t)(j+label_len+1) > buf_len) return -2;\n\t\t\tif (table) dnslabel_table_add(table, start, j);\n\t\t\tbuf[j++] = (ev_uint8_t)label_len;\n\n\t\t\tmemcpy(buf + j, start, label_len);\n\t\t\tj += (int) label_len;\n\t\t\t/* hop over the '.' */\n\t\t\tname++;\n\t\t}\n\t}\n\n\t/* the labels must be terminated by a 0. */\n\t/* It's possible that the name ended in a . */\n\t/* in which case the zero is already there */\n\tif (!j || buf[j-1]) buf[j++] = 0;\n\treturn j;\n overflow:\n\treturn (-2);\n}\n\n/* Finds the length of a dns request for a DNS name of the given */\n/* length. The actual request may be smaller than the value returned */\n/* here */\nstatic size_t\nevdns_request_len(const size_t name_len) {\n\treturn 96 + /* length of the DNS standard header */\n\t\tname_len + 2 +\n\t\t4;  /* space for the resource type */\n}\n\n/* build a dns request packet into buf. buf should be at least as long */\n/* as evdns_request_len told you it should be. */\n/* */\n/* Returns the amount of space used. Negative on error. */\nstatic int\nevdns_request_data_build(const char *const name, const size_t name_len,\n    const u16 trans_id, const u16 type, const u16 class,\n    u8 *const buf, size_t buf_len) {\n\toff_t j = 0;  /* current offset into buf */\n\tu16 t_;\t /* used by the macros */\n\n\tAPPEND16(trans_id);\n\tAPPEND16(0x0100);  /* standard query, recusion needed */\n\tAPPEND16(1);  /* one question */\n\tAPPEND16(0);  /* no answers */\n\tAPPEND16(0);  /* no authority */\n\tAPPEND16(0);  /* no additional */\n\n\tj = dnsname_to_labels(buf, buf_len, j, name, name_len, NULL);\n\tif (j < 0) {\n\t\treturn (int)j;\n\t}\n\n\tAPPEND16(type);\n\tAPPEND16(class);\n\n\treturn (int)j;\n overflow:\n\treturn (-1);\n}\n\n/* exported function */\nstruct evdns_server_port *\nevdns_add_server_port_with_base(struct event_base *base, evutil_socket_t socket, int flags, evdns_request_callback_fn_type cb, void *user_data)\n{\n\tstruct evdns_server_port *port;\n\tif (flags)\n\t\treturn NULL; /* flags not yet implemented */\n\tif (!(port = mm_malloc(sizeof(struct evdns_server_port))))\n\t\treturn NULL;\n\tmemset(port, 0, sizeof(struct evdns_server_port));\n\n\n\tport->socket = socket;\n\tport->refcnt = 1;\n\tport->choked = 0;\n\tport->closing = 0;\n\tport->user_callback = cb;\n\tport->user_data = user_data;\n\tport->pending_replies = NULL;\n\tport->event_base = base;\n\n\tevent_assign(&port->event, port->event_base,\n\t\t\t\t port->socket, EV_READ | EV_PERSIST,\n\t\t\t\t server_port_ready_callback, port);\n\tif (event_add(&port->event, NULL) < 0) {\n\t\tmm_free(port);\n\t\treturn NULL;\n\t}\n\tEVTHREAD_ALLOC_LOCK(port->lock, EVTHREAD_LOCKTYPE_RECURSIVE);\n\treturn port;\n}\n\nstruct evdns_server_port *\nevdns_add_server_port(evutil_socket_t socket, int flags, evdns_request_callback_fn_type cb, void *user_data)\n{\n\treturn evdns_add_server_port_with_base(NULL, socket, flags, cb, user_data);\n}\n\n/* exported function */\nvoid\nevdns_close_server_port(struct evdns_server_port *port)\n{\n\tEVDNS_LOCK(port);\n\tif (--port->refcnt == 0) {\n\t\tEVDNS_UNLOCK(port);\n\t\tserver_port_free(port);\n\t} else {\n\t\tport->closing = 1;\n\t}\n}\n\n/* exported function */\nint\nevdns_server_request_add_reply(struct evdns_server_request *req_, int section, const char *name, int type, int class, int ttl, int datalen, int is_name, const char *data)\n{\n\tstruct server_request *req = TO_SERVER_REQUEST(req_);\n\tstruct server_reply_item **itemp, *item;\n\tint *countp;\n\tint result = -1;\n\n\tEVDNS_LOCK(req->port);\n\tif (req->response) /* have we already answered? */\n\t\tgoto done;\n\n\tswitch (section) {\n\tcase EVDNS_ANSWER_SECTION:\n\t\titemp = &req->answer;\n\t\tcountp = &req->n_answer;\n\t\tbreak;\n\tcase EVDNS_AUTHORITY_SECTION:\n\t\titemp = &req->authority;\n\t\tcountp = &req->n_authority;\n\t\tbreak;\n\tcase EVDNS_ADDITIONAL_SECTION:\n\t\titemp = &req->additional;\n\t\tcountp = &req->n_additional;\n\t\tbreak;\n\tdefault:\n\t\tgoto done;\n\t}\n\twhile (*itemp) {\n\t\titemp = &((*itemp)->next);\n\t}\n\titem = mm_malloc(sizeof(struct server_reply_item));\n\tif (!item)\n\t\tgoto done;\n\titem->next = NULL;\n\tif (!(item->name = mm_strdup(name))) {\n\t\tmm_free(item);\n\t\tgoto done;\n\t}\n\titem->type = type;\n\titem->dns_question_class = class;\n\titem->ttl = ttl;\n\titem->is_name = is_name != 0;\n\titem->datalen = 0;\n\titem->data = NULL;\n\tif (data) {\n\t\tif (item->is_name) {\n\t\t\tif (!(item->data = mm_strdup(data))) {\n\t\t\t\tmm_free(item->name);\n\t\t\t\tmm_free(item);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\titem->datalen = (u16)-1;\n\t\t} else {\n\t\t\tif (!(item->data = mm_malloc(datalen))) {\n\t\t\t\tmm_free(item->name);\n\t\t\t\tmm_free(item);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\titem->datalen = datalen;\n\t\t\tmemcpy(item->data, data, datalen);\n\t\t}\n\t}\n\n\t*itemp = item;\n\t++(*countp);\n\tresult = 0;\ndone:\n\tEVDNS_UNLOCK(req->port);\n\treturn result;\n}\n\n/* exported function */\nint\nevdns_server_request_add_a_reply(struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl)\n{\n\treturn evdns_server_request_add_reply(\n\t\t  req, EVDNS_ANSWER_SECTION, name, TYPE_A, CLASS_INET,\n\t\t  ttl, n*4, 0, addrs);\n}\n\n/* exported function */\nint\nevdns_server_request_add_aaaa_reply(struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl)\n{\n\treturn evdns_server_request_add_reply(\n\t\t  req, EVDNS_ANSWER_SECTION, name, TYPE_AAAA, CLASS_INET,\n\t\t  ttl, n*16, 0, addrs);\n}\n\n/* exported function */\nint\nevdns_server_request_add_ptr_reply(struct evdns_server_request *req, struct in_addr *in, const char *inaddr_name, const char *hostname, int ttl)\n{\n\tu32 a;\n\tchar buf[32];\n\tif (in && inaddr_name)\n\t\treturn -1;\n\telse if (!in && !inaddr_name)\n\t\treturn -1;\n\tif (in) {\n\t\ta = ntohl(in->s_addr);\n\t\tevutil_snprintf(buf, sizeof(buf), \"%d.%d.%d.%d.in-addr.arpa\",\n\t\t\t\t(int)(u8)((a\t)&0xff),\n\t\t\t\t(int)(u8)((a>>8 )&0xff),\n\t\t\t\t(int)(u8)((a>>16)&0xff),\n\t\t\t\t(int)(u8)((a>>24)&0xff));\n\t\tinaddr_name = buf;\n\t}\n\treturn evdns_server_request_add_reply(\n\t\t  req, EVDNS_ANSWER_SECTION, inaddr_name, TYPE_PTR, CLASS_INET,\n\t\t  ttl, -1, 1, hostname);\n}\n\n/* exported function */\nint\nevdns_server_request_add_cname_reply(struct evdns_server_request *req, const char *name, const char *cname, int ttl)\n{\n\treturn evdns_server_request_add_reply(\n\t\t  req, EVDNS_ANSWER_SECTION, name, TYPE_CNAME, CLASS_INET,\n\t\t  ttl, -1, 1, cname);\n}\n\n/* exported function */\nvoid\nevdns_server_request_set_flags(struct evdns_server_request *exreq, int flags)\n{\n\tstruct server_request *req = TO_SERVER_REQUEST(exreq);\n\treq->base.flags &= ~(EVDNS_FLAGS_AA|EVDNS_FLAGS_RD);\n\treq->base.flags |= flags;\n}\n\nstatic int\nevdns_server_request_format_response(struct server_request *req, int err)\n{\n\tunsigned char buf[1500];\n\tsize_t buf_len = sizeof(buf);\n\toff_t j = 0, r;\n\tu16 t_;\n\tu32 t32_;\n\tint i;\n\tu16 flags;\n\tstruct dnslabel_table table;\n\n\tif (err < 0 || err > 15) return -1;\n\n\t/* Set response bit and error code; copy OPCODE and RD fields from\n\t * question; copy RA and AA if set by caller. */\n\tflags = req->base.flags;\n\tflags |= (0x8000 | err);\n\n\tdnslabel_table_init(&table);\n\tAPPEND16(req->trans_id);\n\tAPPEND16(flags);\n\tAPPEND16(req->base.nquestions);\n\tAPPEND16(req->n_answer);\n\tAPPEND16(req->n_authority);\n\tAPPEND16(req->n_additional);\n\n\t/* Add questions. */\n\tfor (i=0; i < req->base.nquestions; ++i) {\n\t\tconst char *s = req->base.questions[i]->name;\n\t\tj = dnsname_to_labels(buf, buf_len, j, s, strlen(s), &table);\n\t\tif (j < 0) {\n\t\t\tdnslabel_clear(&table);\n\t\t\treturn (int) j;\n\t\t}\n\t\tAPPEND16(req->base.questions[i]->type);\n\t\tAPPEND16(req->base.questions[i]->dns_question_class);\n\t}\n\n\t/* Add answer, authority, and additional sections. */\n\tfor (i=0; i<3; ++i) {\n\t\tstruct server_reply_item *item;\n\t\tif (i==0)\n\t\t\titem = req->answer;\n\t\telse if (i==1)\n\t\t\titem = req->authority;\n\t\telse\n\t\t\titem = req->additional;\n\t\twhile (item) {\n\t\t\tr = dnsname_to_labels(buf, buf_len, j, item->name, strlen(item->name), &table);\n\t\t\tif (r < 0)\n\t\t\t\tgoto overflow;\n\t\t\tj = r;\n\n\t\t\tAPPEND16(item->type);\n\t\t\tAPPEND16(item->dns_question_class);\n\t\t\tAPPEND32(item->ttl);\n\t\t\tif (item->is_name) {\n\t\t\t\toff_t len_idx = j, name_start;\n\t\t\t\tj += 2;\n\t\t\t\tname_start = j;\n\t\t\t\tr = dnsname_to_labels(buf, buf_len, j, item->data, strlen(item->data), &table);\n\t\t\t\tif (r < 0)\n\t\t\t\t\tgoto overflow;\n\t\t\t\tj = r;\n\t\t\t\tt_ = htons( (short) (j-name_start) );\n\t\t\t\tmemcpy(buf+len_idx, &t_, 2);\n\t\t\t} else {\n\t\t\t\tAPPEND16(item->datalen);\n\t\t\t\tif (j+item->datalen > (off_t)buf_len)\n\t\t\t\t\tgoto overflow;\n\t\t\t\tmemcpy(buf+j, item->data, item->datalen);\n\t\t\t\tj += item->datalen;\n\t\t\t}\n\t\t\titem = item->next;\n\t\t}\n\t}\n\n\tif (j > 512) {\noverflow:\n\t\tj = 512;\n\t\tbuf[2] |= 0x02; /* set the truncated bit. */\n\t}\n\n\treq->response_len = j;\n\n\tif (!(req->response = mm_malloc(req->response_len))) {\n\t\tserver_request_free_answers(req);\n\t\tdnslabel_clear(&table);\n\t\treturn (-1);\n\t}\n\tmemcpy(req->response, buf, req->response_len);\n\tserver_request_free_answers(req);\n\tdnslabel_clear(&table);\n\treturn (0);\n}\n\n/* exported function */\nint\nevdns_server_request_respond(struct evdns_server_request *req_, int err)\n{\n\tstruct server_request *req = TO_SERVER_REQUEST(req_);\n\tstruct evdns_server_port *port = req->port;\n\tint r = -1;\n\n\tEVDNS_LOCK(port);\n\tif (!req->response) {\n\t\tif ((r = evdns_server_request_format_response(req, err))<0)\n\t\t\tgoto done;\n\t}\n\n\tr = sendto(port->socket, req->response, (int)req->response_len, 0,\n\t\t\t   (struct sockaddr*) &req->addr, (ev_socklen_t)req->addrlen);\n\tif (r<0) {\n\t\tint sock_err = evutil_socket_geterror(port->socket);\n\t\tif (EVUTIL_ERR_RW_RETRIABLE(sock_err))\n\t\t\tgoto done;\n\n\t\tif (port->pending_replies) {\n\t\t\treq->prev_pending = port->pending_replies->prev_pending;\n\t\t\treq->next_pending = port->pending_replies;\n\t\t\treq->prev_pending->next_pending =\n\t\t\t\treq->next_pending->prev_pending = req;\n\t\t} else {\n\t\t\treq->prev_pending = req->next_pending = req;\n\t\t\tport->pending_replies = req;\n\t\t\tport->choked = 1;\n\n\t\t\t(void) event_del(&port->event);\n\t\t\tevent_assign(&port->event, port->event_base, port->socket, (port->closing?0:EV_READ) | EV_WRITE | EV_PERSIST, server_port_ready_callback, port);\n\n\t\t\tif (event_add(&port->event, NULL) < 0) {\n\t\t\t\tlog(EVDNS_LOG_WARN, \"Error from libevent when adding event for DNS server\");\n\t\t\t}\n\n\t\t}\n\n\t\tr = 1;\n\t\tgoto done;\n\t}\n\tif (server_request_free(req)) {\n\t\tr = 0;\n\t\tgoto done;\n\t}\n\n\tif (port->pending_replies)\n\t\tserver_port_flush(port);\n\n\tr = 0;\ndone:\n\tEVDNS_UNLOCK(port);\n\treturn r;\n}\n\n/* Free all storage held by RRs in req. */\nstatic void\nserver_request_free_answers(struct server_request *req)\n{\n\tstruct server_reply_item *victim, *next, **list;\n\tint i;\n\tfor (i = 0; i < 3; ++i) {\n\t\tif (i==0)\n\t\t\tlist = &req->answer;\n\t\telse if (i==1)\n\t\t\tlist = &req->authority;\n\t\telse\n\t\t\tlist = &req->additional;\n\n\t\tvictim = *list;\n\t\twhile (victim) {\n\t\t\tnext = victim->next;\n\t\t\tmm_free(victim->name);\n\t\t\tif (victim->data)\n\t\t\t\tmm_free(victim->data);\n\t\t\tmm_free(victim);\n\t\t\tvictim = next;\n\t\t}\n\t\t*list = NULL;\n\t}\n}\n\n/* Free all storage held by req, and remove links to it. */\n/* return true iff we just wound up freeing the server_port. */\nstatic int\nserver_request_free(struct server_request *req)\n{\n\tint i, rc=1, lock=0;\n\tif (req->base.questions) {\n\t\tfor (i = 0; i < req->base.nquestions; ++i)\n\t\t\tmm_free(req->base.questions[i]);\n\t\tmm_free(req->base.questions);\n\t}\n\n\tif (req->port) {\n\t\tEVDNS_LOCK(req->port);\n\t\tlock=1;\n\t\tif (req->port->pending_replies == req) {\n\t\t\tif (req->next_pending && req->next_pending != req)\n\t\t\t\treq->port->pending_replies = req->next_pending;\n\t\t\telse\n\t\t\t\treq->port->pending_replies = NULL;\n\t\t}\n\t\trc = --req->port->refcnt;\n\t}\n\n\tif (req->response) {\n\t\tmm_free(req->response);\n\t}\n\n\tserver_request_free_answers(req);\n\n\tif (req->next_pending && req->next_pending != req) {\n\t\treq->next_pending->prev_pending = req->prev_pending;\n\t\treq->prev_pending->next_pending = req->next_pending;\n\t}\n\n\tif (rc == 0) {\n\t\tEVDNS_UNLOCK(req->port); /* ????? nickm */\n\t\tserver_port_free(req->port);\n\t\tmm_free(req);\n\t\treturn (1);\n\t}\n\tif (lock)\n\t\tEVDNS_UNLOCK(req->port);\n\tmm_free(req);\n\treturn (0);\n}\n\n/* Free all storage held by an evdns_server_port.  Only called when  */\nstatic void\nserver_port_free(struct evdns_server_port *port)\n{\n\tEVUTIL_ASSERT(port);\n\tEVUTIL_ASSERT(!port->refcnt);\n\tEVUTIL_ASSERT(!port->pending_replies);\n\tif (port->socket > 0) {\n\t\tevutil_closesocket(port->socket);\n\t\tport->socket = -1;\n\t}\n\t(void) event_del(&port->event);\n\tevent_debug_unassign(&port->event);\n\tEVTHREAD_FREE_LOCK(port->lock, EVTHREAD_LOCKTYPE_RECURSIVE);\n\tmm_free(port);\n}\n\n/* exported function */\nint\nevdns_server_request_drop(struct evdns_server_request *req_)\n{\n\tstruct server_request *req = TO_SERVER_REQUEST(req_);\n\tserver_request_free(req);\n\treturn 0;\n}\n\n/* exported function */\nint\nevdns_server_request_get_requesting_addr(struct evdns_server_request *req_, struct sockaddr *sa, int addr_len)\n{\n\tstruct server_request *req = TO_SERVER_REQUEST(req_);\n\tif (addr_len < (int)req->addrlen)\n\t\treturn -1;\n\tmemcpy(sa, &(req->addr), req->addrlen);\n\treturn req->addrlen;\n}\n\n#undef APPEND16\n#undef APPEND32\n\n/* this is a libevent callback function which is called when a request */\n/* has timed out. */\nstatic void\nevdns_request_timeout_callback(evutil_socket_t fd, short events, void *arg) {\n\tstruct request *const req = (struct request *) arg;\n\tstruct evdns_base *base = req->base;\n\n\t(void) fd;\n\t(void) events;\n\n\tlog(EVDNS_LOG_DEBUG, \"Request %p timed out\", arg);\n\tEVDNS_LOCK(base);\n\n\tif (req->tx_count >= req->base->global_max_retransmits) {\n\t\tstruct nameserver *ns = req->ns;\n\t\t/* this request has failed */\n\t\tlog(EVDNS_LOG_DEBUG, \"Giving up on request %p; tx_count==%d\",\n\t\t    arg, req->tx_count);\n\t\treply_schedule_callback(req, 0, DNS_ERR_TIMEOUT, NULL);\n\n\t\trequest_finished(req, &REQ_HEAD(req->base, req->trans_id), 1);\n\t\tnameserver_failed(ns, \"request timed out.\");\n\t} else {\n\t\t/* retransmit it */\n\t\tlog(EVDNS_LOG_DEBUG, \"Retransmitting request %p; tx_count==%d\",\n\t\t    arg, req->tx_count);\n\t\t(void) evtimer_del(&req->timeout_event);\n\t\trequest_swap_ns(req, nameserver_pick(base));\n\t\tevdns_request_transmit(req);\n\n\t\treq->ns->timedout++;\n\t\tif (req->ns->timedout > req->base->global_max_nameserver_timeout) {\n\t\t\treq->ns->timedout = 0;\n\t\t\tnameserver_failed(req->ns, \"request timed out.\");\n\t\t}\n\t}\n\n\tEVDNS_UNLOCK(base);\n}\n\n/* try to send a request to a given server. */\n/* */\n/* return: */\n/*   0 ok */\n/*   1 temporary failure */\n/*   2 other failure */\nstatic int\nevdns_request_transmit_to(struct request *req, struct nameserver *server) {\n\tint r;\n\tASSERT_LOCKED(req->base);\n\tASSERT_VALID_REQUEST(req);\n\n\tif (server->requests_inflight == 1 &&\n\t\treq->base->disable_when_inactive &&\n\t\tevent_add(&server->event, NULL) < 0) {\n\t\treturn 1;\n\t}\n\n\tr = sendto(server->socket, (void*)req->request, req->request_len, 0,\n\t    (struct sockaddr *)&server->address, server->addrlen);\n\tif (r < 0) {\n\t\tint err = evutil_socket_geterror(server->socket);\n\t\tif (EVUTIL_ERR_RW_RETRIABLE(err))\n\t\t\treturn 1;\n\t\tnameserver_failed(req->ns, evutil_socket_error_to_string(err));\n\t\treturn 2;\n\t} else if (r != (int)req->request_len) {\n\t\treturn 1;  /* short write */\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n/* try to send a request, updating the fields of the request */\n/* as needed */\n/* */\n/* return: */\n/*   0 ok */\n/*   1 failed */\nstatic int\nevdns_request_transmit(struct request *req) {\n\tint retcode = 0, r;\n\n\tASSERT_LOCKED(req->base);\n\tASSERT_VALID_REQUEST(req);\n\t/* if we fail to send this packet then this flag marks it */\n\t/* for evdns_transmit */\n\treq->transmit_me = 1;\n\tEVUTIL_ASSERT(req->trans_id != 0xffff);\n\n\tif (!req->ns)\n\t{\n\t\t/* unable to transmit request if no nameservers */\n\t\treturn 1;\n\t}\n\n\tif (req->ns->choked) {\n\t\t/* don't bother trying to write to a socket */\n\t\t/* which we have had EAGAIN from */\n\t\treturn 1;\n\t}\n\n\tr = evdns_request_transmit_to(req, req->ns);\n\tswitch (r) {\n\tcase 1:\n\t\t/* temp failure */\n\t\treq->ns->choked = 1;\n\t\tnameserver_write_waiting(req->ns, 1);\n\t\treturn 1;\n\tcase 2:\n\t\t/* failed to transmit the request entirely. */\n\t\tretcode = 1;\n\t\t/* fall through: we'll set a timeout, which will time out,\n\t\t * and make us retransmit the request anyway. */\n\tdefault:\n\t\t/* all ok */\n\t\tlog(EVDNS_LOG_DEBUG,\n\t\t    \"Setting timeout for request %p, sent to nameserver %p\", req, req->ns);\n\t\tif (evtimer_add(&req->timeout_event, &req->base->global_timeout) < 0) {\n\t\t\tlog(EVDNS_LOG_WARN,\n\t\t      \"Error from libevent when adding timer for request %p\",\n\t\t\t    req);\n\t\t\t/* ???? Do more? */\n\t\t}\n\t\treq->tx_count++;\n\t\treq->transmit_me = 0;\n\t\treturn retcode;\n\t}\n}\n\nstatic void\nnameserver_probe_callback(int result, char type, int count, int ttl, void *addresses, void *arg) {\n\tstruct nameserver *const ns = (struct nameserver *) arg;\n\t(void) type;\n\t(void) count;\n\t(void) ttl;\n\t(void) addresses;\n\n\tif (result == DNS_ERR_CANCEL) {\n\t\t/* We canceled this request because the nameserver came up\n\t\t * for some other reason.  Do not change our opinion about\n\t\t * the nameserver. */\n\t\treturn;\n\t}\n\n\tEVDNS_LOCK(ns->base);\n\tns->probe_request = NULL;\n\tif (result == DNS_ERR_NONE || result == DNS_ERR_NOTEXIST) {\n\t\t/* this is a good reply */\n\t\tnameserver_up(ns);\n\t} else {\n\t\tnameserver_probe_failed(ns);\n\t}\n\tEVDNS_UNLOCK(ns->base);\n}\n\nstatic void\nnameserver_send_probe(struct nameserver *const ns) {\n\tstruct evdns_request *handle;\n\tstruct request *req;\n\tchar addrbuf[128];\n\t/* here we need to send a probe to a given nameserver */\n\t/* in the hope that it is up now. */\n\n\tASSERT_LOCKED(ns->base);\n\tlog(EVDNS_LOG_DEBUG, \"Sending probe to %s\",\n\t    evutil_format_sockaddr_port_(\n\t\t    (struct sockaddr *)&ns->address,\n\t\t    addrbuf, sizeof(addrbuf)));\n\thandle = mm_calloc(1, sizeof(*handle));\n\tif (!handle) return;\n\treq = request_new(ns->base, handle, TYPE_A, \"google.com\", DNS_QUERY_NO_SEARCH, nameserver_probe_callback, ns);\n\tif (!req) {\n\t\tmm_free(handle);\n\t\treturn;\n\t}\n\tns->probe_request = handle;\n\t/* we force this into the inflight queue no matter what */\n\trequest_trans_id_set(req, transaction_id_pick(ns->base));\n\treq->ns = ns;\n\trequest_submit(req);\n}\n\n/* returns: */\n/*   0 didn't try to transmit anything */\n/*   1 tried to transmit something */\nstatic int\nevdns_transmit(struct evdns_base *base) {\n\tchar did_try_to_transmit = 0;\n\tint i;\n\n\tASSERT_LOCKED(base);\n\tfor (i = 0; i < base->n_req_heads; ++i) {\n\t\tif (base->req_heads[i]) {\n\t\t\tstruct request *const started_at = base->req_heads[i], *req = started_at;\n\t\t\t/* first transmit all the requests which are currently waiting */\n\t\t\tdo {\n\t\t\t\tif (req->transmit_me) {\n\t\t\t\t\tdid_try_to_transmit = 1;\n\t\t\t\t\tevdns_request_transmit(req);\n\t\t\t\t}\n\n\t\t\t\treq = req->next;\n\t\t\t} while (req != started_at);\n\t\t}\n\t}\n\n\treturn did_try_to_transmit;\n}\n\n/* exported function */\nint\nevdns_base_count_nameservers(struct evdns_base *base)\n{\n\tconst struct nameserver *server;\n\tint n = 0;\n\n\tEVDNS_LOCK(base);\n\tserver = base->server_head;\n\tif (!server)\n\t\tgoto done;\n\tdo {\n\t\t++n;\n\t\tserver = server->next;\n\t} while (server != base->server_head);\ndone:\n\tEVDNS_UNLOCK(base);\n\treturn n;\n}\n\nint\nevdns_count_nameservers(void)\n{\n\treturn evdns_base_count_nameservers(current_base);\n}\n\n/* exported function */\nint\nevdns_base_clear_nameservers_and_suspend(struct evdns_base *base)\n{\n\tstruct nameserver *server, *started_at;\n\tint i;\n\n\tEVDNS_LOCK(base);\n\tserver = base->server_head;\n\tstarted_at = base->server_head;\n\tif (!server) {\n\t\tEVDNS_UNLOCK(base);\n\t\treturn 0;\n\t}\n\twhile (1) {\n\t\tstruct nameserver *next = server->next;\n\t\t(void) event_del(&server->event);\n\t\tif (evtimer_initialized(&server->timeout_event))\n\t\t\t(void) evtimer_del(&server->timeout_event);\n\t\tif (server->probe_request) {\n\t\t\tevdns_cancel_request(server->base, server->probe_request);\n\t\t\tserver->probe_request = NULL;\n\t\t}\n\t\tif (server->socket >= 0)\n\t\t\tevutil_closesocket(server->socket);\n\t\tmm_free(server);\n\t\tif (next == started_at)\n\t\t\tbreak;\n\t\tserver = next;\n\t}\n\tbase->server_head = NULL;\n\tbase->global_good_nameservers = 0;\n\n\tfor (i = 0; i < base->n_req_heads; ++i) {\n\t\tstruct request *req, *req_started_at;\n\t\treq = req_started_at = base->req_heads[i];\n\t\twhile (req) {\n\t\t\tstruct request *next = req->next;\n\t\t\treq->tx_count = req->reissue_count = 0;\n\t\t\treq->ns = NULL;\n\t\t\t/* ???? What to do about searches? */\n\t\t\t(void) evtimer_del(&req->timeout_event);\n\t\t\treq->trans_id = 0;\n\t\t\treq->transmit_me = 0;\n\n\t\t\tbase->global_requests_waiting++;\n\t\t\tevdns_request_insert(req, &base->req_waiting_head);\n\t\t\t/* We want to insert these suspended elements at the front of\n\t\t\t * the waiting queue, since they were pending before any of\n\t\t\t * the waiting entries were added.  This is a circular list,\n\t\t\t * so we can just shift the start back by one.*/\n\t\t\tbase->req_waiting_head = base->req_waiting_head->prev;\n\n\t\t\tif (next == req_started_at)\n\t\t\t\tbreak;\n\t\t\treq = next;\n\t\t}\n\t\tbase->req_heads[i] = NULL;\n\t}\n\n\tbase->global_requests_inflight = 0;\n\n\tEVDNS_UNLOCK(base);\n\treturn 0;\n}\n\nint\nevdns_clear_nameservers_and_suspend(void)\n{\n\treturn evdns_base_clear_nameservers_and_suspend(current_base);\n}\n\n\n/* exported function */\nint\nevdns_base_resume(struct evdns_base *base)\n{\n\tEVDNS_LOCK(base);\n\tevdns_requests_pump_waiting_queue(base);\n\tEVDNS_UNLOCK(base);\n\n\treturn 0;\n}\n\nint\nevdns_resume(void)\n{\n\treturn evdns_base_resume(current_base);\n}\n\nstatic int\nevdns_nameserver_add_impl_(struct evdns_base *base, const struct sockaddr *address, int addrlen) {\n\t/* first check to see if we already have this nameserver */\n\n\tconst struct nameserver *server = base->server_head, *const started_at = base->server_head;\n\tstruct nameserver *ns;\n\tint err = 0;\n\tchar addrbuf[128];\n\n\tASSERT_LOCKED(base);\n\tif (server) {\n\t\tdo {\n\t\t\tif (!evutil_sockaddr_cmp((struct sockaddr*)&server->address, address, 1)) return 3;\n\t\t\tserver = server->next;\n\t\t} while (server != started_at);\n\t}\n\tif (addrlen > (int)sizeof(ns->address)) {\n\t\tlog(EVDNS_LOG_DEBUG, \"Addrlen %d too long.\", (int)addrlen);\n\t\treturn 2;\n\t}\n\n\tns = (struct nameserver *) mm_malloc(sizeof(struct nameserver));\n\tif (!ns) return -1;\n\n\tmemset(ns, 0, sizeof(struct nameserver));\n\tns->base = base;\n\n\tevtimer_assign(&ns->timeout_event, ns->base->event_base, nameserver_prod_callback, ns);\n\n\tns->socket = evutil_socket_(address->sa_family,\n\t    SOCK_DGRAM|EVUTIL_SOCK_NONBLOCK|EVUTIL_SOCK_CLOEXEC, 0);\n\tif (ns->socket < 0) { err = 1; goto out1; }\n\n\tif (base->global_outgoing_addrlen &&\n\t    !evutil_sockaddr_is_loopback_(address)) {\n\t\tif (bind(ns->socket,\n\t\t\t(struct sockaddr*)&base->global_outgoing_address,\n\t\t\tbase->global_outgoing_addrlen) < 0) {\n\t\t\tlog(EVDNS_LOG_WARN,\"Couldn't bind to outgoing address\");\n\t\t\terr = 2;\n\t\t\tgoto out2;\n\t\t}\n\t}\n\n\tmemcpy(&ns->address, address, addrlen);\n\tns->addrlen = addrlen;\n\tns->state = 1;\n\tevent_assign(&ns->event, ns->base->event_base, ns->socket,\n\t\t\t\t EV_READ | EV_PERSIST, nameserver_ready_callback, ns);\n\tif (!base->disable_when_inactive && event_add(&ns->event, NULL) < 0) {\n\t\terr = 2;\n\t\tgoto out2;\n\t}\n\n\tlog(EVDNS_LOG_DEBUG, \"Added nameserver %s as %p\",\n\t    evutil_format_sockaddr_port_(address, addrbuf, sizeof(addrbuf)), ns);\n\n\t/* insert this nameserver into the list of them */\n\tif (!base->server_head) {\n\t\tns->next = ns->prev = ns;\n\t\tbase->server_head = ns;\n\t} else {\n\t\tns->next = base->server_head->next;\n\t\tns->prev = base->server_head;\n\t\tbase->server_head->next = ns;\n\t\tns->next->prev = ns;\n\t}\n\n\tbase->global_good_nameservers++;\n\n\treturn 0;\n\nout2:\n\tevutil_closesocket(ns->socket);\nout1:\n\tevent_debug_unassign(&ns->event);\n\tmm_free(ns);\n\tlog(EVDNS_LOG_WARN, \"Unable to add nameserver %s: error %d\",\n\t    evutil_format_sockaddr_port_(address, addrbuf, sizeof(addrbuf)), err);\n\treturn err;\n}\n\n/* exported function */\nint\nevdns_base_nameserver_add(struct evdns_base *base, unsigned long int address)\n{\n\tstruct sockaddr_in sin;\n\tint res;\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_addr.s_addr = address;\n\tsin.sin_port = htons(53);\n\tsin.sin_family = AF_INET;\n\tEVDNS_LOCK(base);\n\tres = evdns_nameserver_add_impl_(base, (struct sockaddr*)&sin, sizeof(sin));\n\tEVDNS_UNLOCK(base);\n\treturn res;\n}\n\nint\nevdns_nameserver_add(unsigned long int address) {\n\tif (!current_base)\n\t\tcurrent_base = evdns_base_new(NULL, 0);\n\treturn evdns_base_nameserver_add(current_base, address);\n}\n\nstatic void\nsockaddr_setport(struct sockaddr *sa, ev_uint16_t port)\n{\n\tif (sa->sa_family == AF_INET) {\n\t\t((struct sockaddr_in *)sa)->sin_port = htons(port);\n\t} else if (sa->sa_family == AF_INET6) {\n\t\t((struct sockaddr_in6 *)sa)->sin6_port = htons(port);\n\t}\n}\n\nstatic ev_uint16_t\nsockaddr_getport(struct sockaddr *sa)\n{\n\tif (sa->sa_family == AF_INET) {\n\t\treturn ntohs(((struct sockaddr_in *)sa)->sin_port);\n\t} else if (sa->sa_family == AF_INET6) {\n\t\treturn ntohs(((struct sockaddr_in6 *)sa)->sin6_port);\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n/* exported function */\nint\nevdns_base_nameserver_ip_add(struct evdns_base *base, const char *ip_as_string) {\n\tstruct sockaddr_storage ss;\n\tstruct sockaddr *sa;\n\tint len = sizeof(ss);\n\tint res;\n\tif (evutil_parse_sockaddr_port(ip_as_string, (struct sockaddr *)&ss,\n\t\t&len)) {\n\t\tlog(EVDNS_LOG_WARN, \"Unable to parse nameserver address %s\",\n\t\t\tip_as_string);\n\t\treturn 4;\n\t}\n\tsa = (struct sockaddr *) &ss;\n\tif (sockaddr_getport(sa) == 0)\n\t\tsockaddr_setport(sa, 53);\n\n\tEVDNS_LOCK(base);\n\tres = evdns_nameserver_add_impl_(base, sa, len);\n\tEVDNS_UNLOCK(base);\n\treturn res;\n}\n\nint\nevdns_nameserver_ip_add(const char *ip_as_string) {\n\tif (!current_base)\n\t\tcurrent_base = evdns_base_new(NULL, 0);\n\treturn evdns_base_nameserver_ip_add(current_base, ip_as_string);\n}\n\nint\nevdns_base_nameserver_sockaddr_add(struct evdns_base *base,\n    const struct sockaddr *sa, ev_socklen_t len, unsigned flags)\n{\n\tint res;\n\tEVUTIL_ASSERT(base);\n\tEVDNS_LOCK(base);\n\tres = evdns_nameserver_add_impl_(base, sa, len);\n\tEVDNS_UNLOCK(base);\n\treturn res;\n}\n\nint\nevdns_base_get_nameserver_addr(struct evdns_base *base, int idx,\n    struct sockaddr *sa, ev_socklen_t len)\n{\n\tint result = -1;\n\tint i;\n\tstruct nameserver *server;\n\tEVDNS_LOCK(base);\n\tserver = base->server_head;\n\tfor (i = 0; i < idx && server; ++i, server = server->next) {\n\t\tif (server->next == base->server_head)\n\t\t\tgoto done;\n\t}\n\tif (! server)\n\t\tgoto done;\n\n\tif (server->addrlen > len) {\n\t\tresult = (int) server->addrlen;\n\t\tgoto done;\n\t}\n\n\tmemcpy(sa, &server->address, server->addrlen);\n\tresult = (int) server->addrlen;\ndone:\n\tEVDNS_UNLOCK(base);\n\treturn result;\n}\n\n/* remove from the queue */\nstatic void\nevdns_request_remove(struct request *req, struct request **head)\n{\n\tASSERT_LOCKED(req->base);\n\tASSERT_VALID_REQUEST(req);\n\n#if 0\n\t{\n\t\tstruct request *ptr;\n\t\tint found = 0;\n\t\tEVUTIL_ASSERT(*head != NULL);\n\n\t\tptr = *head;\n\t\tdo {\n\t\t\tif (ptr == req) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr->next;\n\t\t} while (ptr != *head);\n\t\tEVUTIL_ASSERT(found);\n\n\t\tEVUTIL_ASSERT(req->next);\n\t}\n#endif\n\n\tif (req->next == req) {\n\t\t/* only item in the list */\n\t\t*head = NULL;\n\t} else {\n\t\treq->next->prev = req->prev;\n\t\treq->prev->next = req->next;\n\t\tif (*head == req) *head = req->next;\n\t}\n\treq->next = req->prev = NULL;\n}\n\n/* insert into the tail of the queue */\nstatic void\nevdns_request_insert(struct request *req, struct request **head) {\n\tASSERT_LOCKED(req->base);\n\tASSERT_VALID_REQUEST(req);\n\tif (!*head) {\n\t\t*head = req;\n\t\treq->next = req->prev = req;\n\t\treturn;\n\t}\n\n\treq->prev = (*head)->prev;\n\treq->prev->next = req;\n\treq->next = *head;\n\t(*head)->prev = req;\n}\n\nstatic int\nstring_num_dots(const char *s) {\n\tint count = 0;\n\twhile ((s = strchr(s, '.'))) {\n\t\ts++;\n\t\tcount++;\n\t}\n\treturn count;\n}\n\nstatic struct request *\nrequest_new(struct evdns_base *base, struct evdns_request *handle, int type,\n\t    const char *name, int flags, evdns_callback_type callback,\n\t    void *user_ptr) {\n\n\tconst char issuing_now =\n\t    (base->global_requests_inflight < base->global_max_requests_inflight) ? 1 : 0;\n\n\tconst size_t name_len = strlen(name);\n\tconst size_t request_max_len = evdns_request_len(name_len);\n\tconst u16 trans_id = issuing_now ? transaction_id_pick(base) : 0xffff;\n\t/* the request data is alloced in a single block with the header */\n\tstruct request *const req =\n\t    mm_malloc(sizeof(struct request) + request_max_len);\n\tint rlen;\n\tchar namebuf[256];\n\t(void) flags;\n\n\tASSERT_LOCKED(base);\n\n\tif (!req) return NULL;\n\n\tif (name_len >= sizeof(namebuf)) {\n\t\tmm_free(req);\n\t\treturn NULL;\n\t}\n\n\tmemset(req, 0, sizeof(struct request));\n\treq->base = base;\n\n\tevtimer_assign(&req->timeout_event, req->base->event_base, evdns_request_timeout_callback, req);\n\n\tif (base->global_randomize_case) {\n\t\tunsigned i;\n\t\tchar randbits[(sizeof(namebuf)+7)/8];\n\t\tstrlcpy(namebuf, name, sizeof(namebuf));\n\t\tevutil_secure_rng_get_bytes(randbits, (name_len+7)/8);\n\t\tfor (i = 0; i < name_len; ++i) {\n\t\t\tif (EVUTIL_ISALPHA_(namebuf[i])) {\n\t\t\t\tif ((randbits[i >> 3] & (1<<(i & 7))))\n\t\t\t\t\tnamebuf[i] |= 0x20;\n\t\t\t\telse\n\t\t\t\t\tnamebuf[i] &= ~0x20;\n\t\t\t}\n\t\t}\n\t\tname = namebuf;\n\t}\n\n\t/* request data lives just after the header */\n\treq->request = ((u8 *) req) + sizeof(struct request);\n\t/* denotes that the request data shouldn't be free()ed */\n\treq->request_appended = 1;\n\trlen = evdns_request_data_build(name, name_len, trans_id,\n\t    type, CLASS_INET, req->request, request_max_len);\n\tif (rlen < 0)\n\t\tgoto err1;\n\n\treq->request_len = rlen;\n\treq->trans_id = trans_id;\n\treq->tx_count = 0;\n\treq->request_type = type;\n\treq->user_pointer = user_ptr;\n\treq->user_callback = callback;\n\treq->ns = issuing_now ? nameserver_pick(base) : NULL;\n\treq->next = req->prev = NULL;\n\treq->handle = handle;\n\tif (handle) {\n\t\thandle->current_req = req;\n\t\thandle->base = base;\n\t}\n\n\treturn req;\nerr1:\n\tmm_free(req);\n\treturn NULL;\n}\n\nstatic void\nrequest_submit(struct request *const req) {\n\tstruct evdns_base *base = req->base;\n\tASSERT_LOCKED(base);\n\tASSERT_VALID_REQUEST(req);\n\tif (req->ns) {\n\t\t/* if it has a nameserver assigned then this is going */\n\t\t/* straight into the inflight queue */\n\t\tevdns_request_insert(req, &REQ_HEAD(base, req->trans_id));\n\n\t\tbase->global_requests_inflight++;\n\t\treq->ns->requests_inflight++;\n\n\t\tevdns_request_transmit(req);\n\t} else {\n\t\tevdns_request_insert(req, &base->req_waiting_head);\n\t\tbase->global_requests_waiting++;\n\t}\n}\n\n/* exported function */\nvoid\nevdns_cancel_request(struct evdns_base *base, struct evdns_request *handle)\n{\n\tstruct request *req;\n\n\tif (!handle->current_req)\n\t\treturn;\n\n\tif (!base) {\n\t\t/* This redundancy is silly; can we fix it? (Not for 2.0) XXXX */\n\t\tbase = handle->base;\n\t\tif (!base)\n\t\t\tbase = handle->current_req->base;\n\t}\n\n\tEVDNS_LOCK(base);\n\tif (handle->pending_cb) {\n\t\tEVDNS_UNLOCK(base);\n\t\treturn;\n\t}\n\n\treq = handle->current_req;\n\tASSERT_VALID_REQUEST(req);\n\n\treply_schedule_callback(req, 0, DNS_ERR_CANCEL, NULL);\n\tif (req->ns) {\n\t\t/* remove from inflight queue */\n\t\trequest_finished(req, &REQ_HEAD(base, req->trans_id), 1);\n\t} else {\n\t\t/* remove from global_waiting head */\n\t\trequest_finished(req, &base->req_waiting_head, 1);\n\t}\n\tEVDNS_UNLOCK(base);\n}\n\n/* exported function */\nstruct evdns_request *\nevdns_base_resolve_ipv4(struct evdns_base *base, const char *name, int flags,\n    evdns_callback_type callback, void *ptr) {\n\tstruct evdns_request *handle;\n\tstruct request *req;\n\tlog(EVDNS_LOG_DEBUG, \"Resolve requested for %s\", name);\n\thandle = mm_calloc(1, sizeof(*handle));\n\tif (handle == NULL)\n\t\treturn NULL;\n\tEVDNS_LOCK(base);\n\tif (flags & DNS_QUERY_NO_SEARCH) {\n\t\treq =\n\t\t\trequest_new(base, handle, TYPE_A, name, flags,\n\t\t\t\t    callback, ptr);\n\t\tif (req)\n\t\t\trequest_submit(req);\n\t} else {\n\t\tsearch_request_new(base, handle, TYPE_A, name, flags,\n\t\t    callback, ptr);\n\t}\n\tif (handle->current_req == NULL) {\n\t\tmm_free(handle);\n\t\thandle = NULL;\n\t}\n\tEVDNS_UNLOCK(base);\n\treturn handle;\n}\n\nint evdns_resolve_ipv4(const char *name, int flags,\n\t\t\t\t\t   evdns_callback_type callback, void *ptr)\n{\n\treturn evdns_base_resolve_ipv4(current_base, name, flags, callback, ptr)\n\t\t? 0 : -1;\n}\n\n\n/* exported function */\nstruct evdns_request *\nevdns_base_resolve_ipv6(struct evdns_base *base,\n    const char *name, int flags,\n    evdns_callback_type callback, void *ptr)\n{\n\tstruct evdns_request *handle;\n\tstruct request *req;\n\tlog(EVDNS_LOG_DEBUG, \"Resolve requested for %s\", name);\n\thandle = mm_calloc(1, sizeof(*handle));\n\tif (handle == NULL)\n\t\treturn NULL;\n\tEVDNS_LOCK(base);\n\tif (flags & DNS_QUERY_NO_SEARCH) {\n\t\treq = request_new(base, handle, TYPE_AAAA, name, flags,\n\t\t\t\t  callback, ptr);\n\t\tif (req)\n\t\t\trequest_submit(req);\n\t} else {\n\t\tsearch_request_new(base, handle, TYPE_AAAA, name, flags,\n\t\t    callback, ptr);\n\t}\n\tif (handle->current_req == NULL) {\n\t\tmm_free(handle);\n\t\thandle = NULL;\n\t}\n\tEVDNS_UNLOCK(base);\n\treturn handle;\n}\n\nint evdns_resolve_ipv6(const char *name, int flags,\n    evdns_callback_type callback, void *ptr) {\n\treturn evdns_base_resolve_ipv6(current_base, name, flags, callback, ptr)\n\t\t? 0 : -1;\n}\n\nstruct evdns_request *\nevdns_base_resolve_reverse(struct evdns_base *base, const struct in_addr *in, int flags, evdns_callback_type callback, void *ptr) {\n\tchar buf[32];\n\tstruct evdns_request *handle;\n\tstruct request *req;\n\tu32 a;\n\tEVUTIL_ASSERT(in);\n\ta = ntohl(in->s_addr);\n\tevutil_snprintf(buf, sizeof(buf), \"%d.%d.%d.%d.in-addr.arpa\",\n\t\t\t(int)(u8)((a\t)&0xff),\n\t\t\t(int)(u8)((a>>8 )&0xff),\n\t\t\t(int)(u8)((a>>16)&0xff),\n\t\t\t(int)(u8)((a>>24)&0xff));\n\thandle = mm_calloc(1, sizeof(*handle));\n\tif (handle == NULL)\n\t\treturn NULL;\n\tlog(EVDNS_LOG_DEBUG, \"Resolve requested for %s (reverse)\", buf);\n\tEVDNS_LOCK(base);\n\treq = request_new(base, handle, TYPE_PTR, buf, flags, callback, ptr);\n\tif (req)\n\t\trequest_submit(req);\n\tif (handle->current_req == NULL) {\n\t\tmm_free(handle);\n\t\thandle = NULL;\n\t}\n\tEVDNS_UNLOCK(base);\n\treturn (handle);\n}\n\nint evdns_resolve_reverse(const struct in_addr *in, int flags, evdns_callback_type callback, void *ptr) {\n\treturn evdns_base_resolve_reverse(current_base, in, flags, callback, ptr)\n\t\t? 0 : -1;\n}\n\nstruct evdns_request *\nevdns_base_resolve_reverse_ipv6(struct evdns_base *base, const struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr) {\n\t/* 32 nybbles, 32 periods, \"ip6.arpa\", NUL. */\n\tchar buf[73];\n\tchar *cp;\n\tstruct evdns_request *handle;\n\tstruct request *req;\n\tint i;\n\tEVUTIL_ASSERT(in);\n\tcp = buf;\n\tfor (i=15; i >= 0; --i) {\n\t\tu8 byte = in->s6_addr[i];\n\t\t*cp++ = \"0123456789abcdef\"[byte & 0x0f];\n\t\t*cp++ = '.';\n\t\t*cp++ = \"0123456789abcdef\"[byte >> 4];\n\t\t*cp++ = '.';\n\t}\n\tEVUTIL_ASSERT(cp + strlen(\"ip6.arpa\") < buf+sizeof(buf));\n\tmemcpy(cp, \"ip6.arpa\", strlen(\"ip6.arpa\")+1);\n\thandle = mm_calloc(1, sizeof(*handle));\n\tif (handle == NULL)\n\t\treturn NULL;\n\tlog(EVDNS_LOG_DEBUG, \"Resolve requested for %s (reverse)\", buf);\n\tEVDNS_LOCK(base);\n\treq = request_new(base, handle, TYPE_PTR, buf, flags, callback, ptr);\n\tif (req)\n\t\trequest_submit(req);\n\tif (handle->current_req == NULL) {\n\t\tmm_free(handle);\n\t\thandle = NULL;\n\t}\n\tEVDNS_UNLOCK(base);\n\treturn (handle);\n}\n\nint evdns_resolve_reverse_ipv6(const struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr) {\n\treturn evdns_base_resolve_reverse_ipv6(current_base, in, flags, callback, ptr)\n\t\t? 0 : -1;\n}\n\n/* ================================================================= */\n/* Search support */\n/* */\n/* the libc resolver has support for searching a number of domains */\n/* to find a name. If nothing else then it takes the single domain */\n/* from the gethostname() call. */\n/* */\n/* It can also be configured via the domain and search options in a */\n/* resolv.conf. */\n/* */\n/* The ndots option controls how many dots it takes for the resolver */\n/* to decide that a name is non-local and so try a raw lookup first. */\n\nstruct search_domain {\n\tint len;\n\tstruct search_domain *next;\n\t/* the text string is appended to this structure */\n};\n\nstruct search_state {\n\tint refcount;\n\tint ndots;\n\tint num_domains;\n\tstruct search_domain *head;\n};\n\nstatic void\nsearch_state_decref(struct search_state *const state) {\n\tif (!state) return;\n\tstate->refcount--;\n\tif (!state->refcount) {\n\t\tstruct search_domain *next, *dom;\n\t\tfor (dom = state->head; dom; dom = next) {\n\t\t\tnext = dom->next;\n\t\t\tmm_free(dom);\n\t\t}\n\t\tmm_free(state);\n\t}\n}\n\nstatic struct search_state *\nsearch_state_new(void) {\n\tstruct search_state *state = (struct search_state *) mm_malloc(sizeof(struct search_state));\n\tif (!state) return NULL;\n\tmemset(state, 0, sizeof(struct search_state));\n\tstate->refcount = 1;\n\tstate->ndots = 1;\n\n\treturn state;\n}\n\nstatic void\nsearch_postfix_clear(struct evdns_base *base) {\n\tsearch_state_decref(base->global_search_state);\n\n\tbase->global_search_state = search_state_new();\n}\n\n/* exported function */\nvoid\nevdns_base_search_clear(struct evdns_base *base)\n{\n\tEVDNS_LOCK(base);\n\tsearch_postfix_clear(base);\n\tEVDNS_UNLOCK(base);\n}\n\nvoid\nevdns_search_clear(void) {\n\tevdns_base_search_clear(current_base);\n}\n\nstatic void\nsearch_postfix_add(struct evdns_base *base, const char *domain) {\n\tsize_t domain_len;\n\tstruct search_domain *sdomain;\n\twhile (domain[0] == '.') domain++;\n\tdomain_len = strlen(domain);\n\n\tASSERT_LOCKED(base);\n\tif (!base->global_search_state) base->global_search_state = search_state_new();\n\tif (!base->global_search_state) return;\n\tbase->global_search_state->num_domains++;\n\n\tsdomain = (struct search_domain *) mm_malloc(sizeof(struct search_domain) + domain_len);\n\tif (!sdomain) return;\n\tmemcpy( ((u8 *) sdomain) + sizeof(struct search_domain), domain, domain_len);\n\tsdomain->next = base->global_search_state->head;\n\tsdomain->len = (int) domain_len;\n\n\tbase->global_search_state->head = sdomain;\n}\n\n/* reverse the order of members in the postfix list. This is needed because, */\n/* when parsing resolv.conf we push elements in the wrong order */\nstatic void\nsearch_reverse(struct evdns_base *base) {\n\tstruct search_domain *cur, *prev = NULL, *next;\n\tASSERT_LOCKED(base);\n\tcur = base->global_search_state->head;\n\twhile (cur) {\n\t\tnext = cur->next;\n\t\tcur->next = prev;\n\t\tprev = cur;\n\t\tcur = next;\n\t}\n\n\tbase->global_search_state->head = prev;\n}\n\n/* exported function */\nvoid\nevdns_base_search_add(struct evdns_base *base, const char *domain) {\n\tEVDNS_LOCK(base);\n\tsearch_postfix_add(base, domain);\n\tEVDNS_UNLOCK(base);\n}\nvoid\nevdns_search_add(const char *domain) {\n\tevdns_base_search_add(current_base, domain);\n}\n\n/* exported function */\nvoid\nevdns_base_search_ndots_set(struct evdns_base *base, const int ndots) {\n\tEVDNS_LOCK(base);\n\tif (!base->global_search_state) base->global_search_state = search_state_new();\n\tif (base->global_search_state)\n\t\tbase->global_search_state->ndots = ndots;\n\tEVDNS_UNLOCK(base);\n}\nvoid\nevdns_search_ndots_set(const int ndots) {\n\tevdns_base_search_ndots_set(current_base, ndots);\n}\n\nstatic void\nsearch_set_from_hostname(struct evdns_base *base) {\n\tchar hostname[HOST_NAME_MAX + 1], *domainname;\n\n\tASSERT_LOCKED(base);\n\tsearch_postfix_clear(base);\n\tif (gethostname(hostname, sizeof(hostname))) return;\n\tdomainname = strchr(hostname, '.');\n\tif (!domainname) return;\n\tsearch_postfix_add(base, domainname);\n}\n\n/* warning: returns malloced string */\nstatic char *\nsearch_make_new(const struct search_state *const state, int n, const char *const base_name) {\n\tconst size_t base_len = strlen(base_name);\n\tconst char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n\tstruct search_domain *dom;\n\n\tfor (dom = state->head; dom; dom = dom->next) {\n\t\tif (!n--) {\n\t\t\t/* this is the postfix we want */\n\t\t\t/* the actual postfix string is kept at the end of the structure */\n\t\t\tconst u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);\n\t\t\tconst int postfix_len = dom->len;\n\t\t\tchar *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1);\n\t\t\tif (!newname) return NULL;\n\t\t\tmemcpy(newname, base_name, base_len);\n\t\t\tif (need_to_append_dot) newname[base_len] = '.';\n\t\t\tmemcpy(newname + base_len + need_to_append_dot, postfix, postfix_len);\n\t\t\tnewname[base_len + need_to_append_dot + postfix_len] = 0;\n\t\t\treturn newname;\n\t\t}\n\t}\n\n\t/* we ran off the end of the list and still didn't find the requested string */\n\tEVUTIL_ASSERT(0);\n\treturn NULL; /* unreachable; stops warnings in some compilers. */\n}\n\nstatic struct request *\nsearch_request_new(struct evdns_base *base, struct evdns_request *handle,\n\t\t   int type, const char *const name, int flags,\n\t\t   evdns_callback_type user_callback, void *user_arg) {\n\tASSERT_LOCKED(base);\n\tEVUTIL_ASSERT(type == TYPE_A || type == TYPE_AAAA);\n\tEVUTIL_ASSERT(handle->current_req == NULL);\n\tif ( ((flags & DNS_QUERY_NO_SEARCH) == 0) &&\n\t     base->global_search_state &&\n\t\t base->global_search_state->num_domains) {\n\t\t/* we have some domains to search */\n\t\tstruct request *req;\n\t\tif (string_num_dots(name) >= base->global_search_state->ndots) {\n\t\t\treq = request_new(base, handle, type, name, flags, user_callback, user_arg);\n\t\t\tif (!req) return NULL;\n\t\t\thandle->search_index = -1;\n\t\t} else {\n\t\t\tchar *const new_name = search_make_new(base->global_search_state, 0, name);\n\t\t\tif (!new_name) return NULL;\n\t\t\treq = request_new(base, handle, type, new_name, flags, user_callback, user_arg);\n\t\t\tmm_free(new_name);\n\t\t\tif (!req) return NULL;\n\t\t\thandle->search_index = 0;\n\t\t}\n\t\tEVUTIL_ASSERT(handle->search_origname == NULL);\n\t\thandle->search_origname = mm_strdup(name);\n\t\tif (handle->search_origname == NULL) {\n\t\t\t/* XXX Should we dealloc req? If yes, how? */\n\t\t\tif (req)\n\t\t\t\tmm_free(req);\n\t\t\treturn NULL;\n\t\t}\n\t\thandle->search_state = base->global_search_state;\n\t\thandle->search_flags = flags;\n\t\tbase->global_search_state->refcount++;\n\t\trequest_submit(req);\n\t\treturn req;\n\t} else {\n\t\tstruct request *const req = request_new(base, handle, type, name, flags, user_callback, user_arg);\n\t\tif (!req) return NULL;\n\t\trequest_submit(req);\n\t\treturn req;\n\t}\n}\n\n/* this is called when a request has failed to find a name. We need to check */\n/* if it is part of a search and, if so, try the next name in the list */\n/* returns: */\n/*   0 another request has been submitted */\n/*   1 no more requests needed */\nstatic int\nsearch_try_next(struct evdns_request *const handle) {\n\tstruct request *req = handle->current_req;\n\tstruct evdns_base *base = req->base;\n\tstruct request *newreq;\n\tASSERT_LOCKED(base);\n\tif (handle->search_state) {\n\t\t/* it is part of a search */\n\t\tchar *new_name;\n\t\thandle->search_index++;\n\t\tif (handle->search_index >= handle->search_state->num_domains) {\n\t\t\t/* no more postfixes to try, however we may need to try */\n\t\t\t/* this name without a postfix */\n\t\t\tif (string_num_dots(handle->search_origname) < handle->search_state->ndots) {\n\t\t\t\t/* yep, we need to try it raw */\n\t\t\t\tnewreq = request_new(base, NULL, req->request_type, handle->search_origname, handle->search_flags, req->user_callback, req->user_pointer);\n\t\t\t\tlog(EVDNS_LOG_DEBUG, \"Search: trying raw query %s\", handle->search_origname);\n\t\t\t\tif (newreq) {\n\t\t\t\t\tsearch_request_finished(handle);\n\t\t\t\t\tgoto submit_next;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\n\t\tnew_name = search_make_new(handle->search_state, handle->search_index, handle->search_origname);\n\t\tif (!new_name) return 1;\n\t\tlog(EVDNS_LOG_DEBUG, \"Search: now trying %s (%d)\", new_name, handle->search_index);\n\t\tnewreq = request_new(base, NULL, req->request_type, new_name, handle->search_flags, req->user_callback, req->user_pointer);\n\t\tmm_free(new_name);\n\t\tif (!newreq) return 1;\n\t\tgoto submit_next;\n\t}\n\treturn 1;\n\nsubmit_next:\n\trequest_finished(req, &REQ_HEAD(req->base, req->trans_id), 0);\n\thandle->current_req = newreq;\n\tnewreq->handle = handle;\n\trequest_submit(newreq);\n\treturn 0;\n}\n\nstatic void\nsearch_request_finished(struct evdns_request *const handle) {\n\tASSERT_LOCKED(handle->current_req->base);\n\tif (handle->search_state) {\n\t\tsearch_state_decref(handle->search_state);\n\t\thandle->search_state = NULL;\n\t}\n\tif (handle->search_origname) {\n\t\tmm_free(handle->search_origname);\n\t\thandle->search_origname = NULL;\n\t}\n}\n\n/* ================================================================= */\n/* Parsing resolv.conf files */\n\nstatic void\nevdns_resolv_set_defaults(struct evdns_base *base, int flags) {\n\t/* if the file isn't found then we assume a local resolver */\n\tASSERT_LOCKED(base);\n\tif (flags & DNS_OPTION_SEARCH) search_set_from_hostname(base);\n\tif (flags & DNS_OPTION_NAMESERVERS) evdns_base_nameserver_ip_add(base,\"127.0.0.1\");\n}\n\n#ifndef EVENT__HAVE_STRTOK_R\nstatic char *\nstrtok_r(char *s, const char *delim, char **state) {\n\tchar *cp, *start;\n\tstart = cp = s ? s : *state;\n\tif (!cp)\n\t\treturn NULL;\n\twhile (*cp && !strchr(delim, *cp))\n\t\t++cp;\n\tif (!*cp) {\n\t\tif (cp == start)\n\t\t\treturn NULL;\n\t\t*state = NULL;\n\t\treturn start;\n\t} else {\n\t\t*cp++ = '\\0';\n\t\t*state = cp;\n\t\treturn start;\n\t}\n}\n#endif\n\n/* helper version of atoi which returns -1 on error */\nstatic int\nstrtoint(const char *const str)\n{\n\tchar *endptr;\n\tconst int r = strtol(str, &endptr, 10);\n\tif (*endptr) return -1;\n\treturn r;\n}\n\n/* Parse a number of seconds into a timeval; return -1 on error. */\nstatic int\nevdns_strtotimeval(const char *const str, struct timeval *out)\n{\n\tdouble d;\n\tchar *endptr;\n\td = strtod(str, &endptr);\n\tif (*endptr) return -1;\n\tif (d < 0) return -1;\n\tout->tv_sec = (int) d;\n\tout->tv_usec = (int) ((d - (int) d)*1000000);\n\tif (out->tv_sec == 0 && out->tv_usec < 1000) /* less than 1 msec */\n\t\treturn -1;\n\treturn 0;\n}\n\n/* helper version of atoi that returns -1 on error and clips to bounds. */\nstatic int\nstrtoint_clipped(const char *const str, int min, int max)\n{\n\tint r = strtoint(str);\n\tif (r == -1)\n\t\treturn r;\n\telse if (r<min)\n\t\treturn min;\n\telse if (r>max)\n\t\treturn max;\n\telse\n\t\treturn r;\n}\n\nstatic int\nevdns_base_set_max_requests_inflight(struct evdns_base *base, int maxinflight)\n{\n\tint old_n_heads = base->n_req_heads, n_heads;\n\tstruct request **old_heads = base->req_heads, **new_heads, *req;\n\tint i;\n\n\tASSERT_LOCKED(base);\n\tif (maxinflight < 1)\n\t\tmaxinflight = 1;\n\tn_heads = (maxinflight+4) / 5;\n\tEVUTIL_ASSERT(n_heads > 0);\n\tnew_heads = mm_calloc(n_heads, sizeof(struct request*));\n\tif (!new_heads)\n\t\treturn (-1);\n\tif (old_heads) {\n\t\tfor (i = 0; i < old_n_heads; ++i) {\n\t\t\twhile (old_heads[i]) {\n\t\t\t\treq = old_heads[i];\n\t\t\t\tevdns_request_remove(req, &old_heads[i]);\n\t\t\t\tevdns_request_insert(req, &new_heads[req->trans_id % n_heads]);\n\t\t\t}\n\t\t}\n\t\tmm_free(old_heads);\n\t}\n\tbase->req_heads = new_heads;\n\tbase->n_req_heads = n_heads;\n\tbase->global_max_requests_inflight = maxinflight;\n\treturn (0);\n}\n\n/* exported function */\nint\nevdns_base_set_option(struct evdns_base *base,\n    const char *option, const char *val)\n{\n\tint res;\n\tEVDNS_LOCK(base);\n\tres = evdns_base_set_option_impl(base, option, val, DNS_OPTIONS_ALL);\n\tEVDNS_UNLOCK(base);\n\treturn res;\n}\n\nstatic inline int\nstr_matches_option(const char *s1, const char *optionname)\n{\n\t/* Option names are given as \"option:\" We accept either 'option' in\n\t * s1, or 'option:randomjunk'.  The latter form is to implement the\n\t * resolv.conf parser. */\n\tsize_t optlen = strlen(optionname);\n\tsize_t slen = strlen(s1);\n\tif (slen == optlen || slen == optlen - 1)\n\t\treturn !strncmp(s1, optionname, slen);\n\telse if (slen > optlen)\n\t\treturn !strncmp(s1, optionname, optlen);\n\telse\n\t\treturn 0;\n}\n\nstatic int\nevdns_base_set_option_impl(struct evdns_base *base,\n    const char *option, const char *val, int flags)\n{\n\tASSERT_LOCKED(base);\n\tif (str_matches_option(option, \"ndots:\")) {\n\t\tconst int ndots = strtoint(val);\n\t\tif (ndots == -1) return -1;\n\t\tif (!(flags & DNS_OPTION_SEARCH)) return 0;\n\t\tlog(EVDNS_LOG_DEBUG, \"Setting ndots to %d\", ndots);\n\t\tif (!base->global_search_state) base->global_search_state = search_state_new();\n\t\tif (!base->global_search_state) return -1;\n\t\tbase->global_search_state->ndots = ndots;\n\t} else if (str_matches_option(option, \"timeout:\")) {\n\t\tstruct timeval tv;\n\t\tif (evdns_strtotimeval(val, &tv) == -1) return -1;\n\t\tif (!(flags & DNS_OPTION_MISC)) return 0;\n\t\tlog(EVDNS_LOG_DEBUG, \"Setting timeout to %s\", val);\n\t\tmemcpy(&base->global_timeout, &tv, sizeof(struct timeval));\n\t} else if (str_matches_option(option, \"getaddrinfo-allow-skew:\")) {\n\t\tstruct timeval tv;\n\t\tif (evdns_strtotimeval(val, &tv) == -1) return -1;\n\t\tif (!(flags & DNS_OPTION_MISC)) return 0;\n\t\tlog(EVDNS_LOG_DEBUG, \"Setting getaddrinfo-allow-skew to %s\",\n\t\t    val);\n\t\tmemcpy(&base->global_getaddrinfo_allow_skew, &tv,\n\t\t    sizeof(struct timeval));\n\t} else if (str_matches_option(option, \"max-timeouts:\")) {\n\t\tconst int maxtimeout = strtoint_clipped(val, 1, 255);\n\t\tif (maxtimeout == -1) return -1;\n\t\tif (!(flags & DNS_OPTION_MISC)) return 0;\n\t\tlog(EVDNS_LOG_DEBUG, \"Setting maximum allowed timeouts to %d\",\n\t\t\tmaxtimeout);\n\t\tbase->global_max_nameserver_timeout = maxtimeout;\n\t} else if (str_matches_option(option, \"max-inflight:\")) {\n\t\tconst int maxinflight = strtoint_clipped(val, 1, 65000);\n\t\tif (maxinflight == -1) return -1;\n\t\tif (!(flags & DNS_OPTION_MISC)) return 0;\n\t\tlog(EVDNS_LOG_DEBUG, \"Setting maximum inflight requests to %d\",\n\t\t\tmaxinflight);\n\t\tevdns_base_set_max_requests_inflight(base, maxinflight);\n\t} else if (str_matches_option(option, \"attempts:\")) {\n\t\tint retries = strtoint(val);\n\t\tif (retries == -1) return -1;\n\t\tif (retries > 255) retries = 255;\n\t\tif (!(flags & DNS_OPTION_MISC)) return 0;\n\t\tlog(EVDNS_LOG_DEBUG, \"Setting retries to %d\", retries);\n\t\tbase->global_max_retransmits = retries;\n\t} else if (str_matches_option(option, \"randomize-case:\")) {\n\t\tint randcase = strtoint(val);\n\t\tif (!(flags & DNS_OPTION_MISC)) return 0;\n\t\tbase->global_randomize_case = randcase;\n\t} else if (str_matches_option(option, \"bind-to:\")) {\n\t\t/* XXX This only applies to successive nameservers, not\n\t\t * to already-configured ones.\tWe might want to fix that. */\n\t\tint len = sizeof(base->global_outgoing_address);\n\t\tif (!(flags & DNS_OPTION_NAMESERVERS)) return 0;\n\t\tif (evutil_parse_sockaddr_port(val,\n\t\t\t(struct sockaddr*)&base->global_outgoing_address, &len))\n\t\t\treturn -1;\n\t\tbase->global_outgoing_addrlen = len;\n\t} else if (str_matches_option(option, \"initial-probe-timeout:\")) {\n\t\tstruct timeval tv;\n\t\tif (evdns_strtotimeval(val, &tv) == -1) return -1;\n\t\tif (tv.tv_sec > 3600)\n\t\t\ttv.tv_sec = 3600;\n\t\tif (!(flags & DNS_OPTION_MISC)) return 0;\n\t\tlog(EVDNS_LOG_DEBUG, \"Setting initial probe timeout to %s\",\n\t\t    val);\n\t\tmemcpy(&base->global_nameserver_probe_initial_timeout, &tv,\n\t\t    sizeof(tv));\n\t}\n\treturn 0;\n}\n\nint\nevdns_set_option(const char *option, const char *val, int flags)\n{\n\tif (!current_base)\n\t\tcurrent_base = evdns_base_new(NULL, 0);\n\treturn evdns_base_set_option(current_base, option, val);\n}\n\nstatic void\nresolv_conf_parse_line(struct evdns_base *base, char *const start, int flags) {\n\tchar *strtok_state;\n\tstatic const char *const delims = \" \\t\";\n#define NEXT_TOKEN strtok_r(NULL, delims, &strtok_state)\n\n\n\tchar *const first_token = strtok_r(start, delims, &strtok_state);\n\tASSERT_LOCKED(base);\n\tif (!first_token) return;\n\n\tif (!strcmp(first_token, \"nameserver\") && (flags & DNS_OPTION_NAMESERVERS)) {\n\t\tconst char *const nameserver = NEXT_TOKEN;\n\n\t\tif (nameserver)\n\t\t\tevdns_base_nameserver_ip_add(base, nameserver);\n\t} else if (!strcmp(first_token, \"domain\") && (flags & DNS_OPTION_SEARCH)) {\n\t\tconst char *const domain = NEXT_TOKEN;\n\t\tif (domain) {\n\t\t\tsearch_postfix_clear(base);\n\t\t\tsearch_postfix_add(base, domain);\n\t\t}\n\t} else if (!strcmp(first_token, \"search\") && (flags & DNS_OPTION_SEARCH)) {\n\t\tconst char *domain;\n\t\tsearch_postfix_clear(base);\n\n\t\twhile ((domain = NEXT_TOKEN)) {\n\t\t\tsearch_postfix_add(base, domain);\n\t\t}\n\t\tsearch_reverse(base);\n\t} else if (!strcmp(first_token, \"options\")) {\n\t\tconst char *option;\n\t\twhile ((option = NEXT_TOKEN)) {\n\t\t\tconst char *val = strchr(option, ':');\n\t\t\tevdns_base_set_option_impl(base, option, val ? val+1 : \"\", flags);\n\t\t}\n\t}\n#undef NEXT_TOKEN\n}\n\n/* exported function */\n/* returns: */\n/*   0 no errors */\n/*   1 failed to open file */\n/*   2 failed to stat file */\n/*   3 file too large */\n/*   4 out of memory */\n/*   5 short read from file */\nint\nevdns_base_resolv_conf_parse(struct evdns_base *base, int flags, const char *const filename) {\n\tint res;\n\tEVDNS_LOCK(base);\n\tres = evdns_base_resolv_conf_parse_impl(base, flags, filename);\n\tEVDNS_UNLOCK(base);\n\treturn res;\n}\n\nstatic char *\nevdns_get_default_hosts_filename(void)\n{\n#ifdef _WIN32\n\t/* Windows is a little coy about where it puts its configuration\n\t * files.  Sure, they're _usually_ in C:\\windows\\system32, but\n\t * there's no reason in principle they couldn't be in\n\t * W:\\hoboken chicken emergency\\\n\t */\n\tchar path[MAX_PATH+1];\n\tstatic const char hostfile[] = \"\\\\drivers\\\\etc\\\\hosts\";\n\tchar *path_out;\n\tsize_t len_out;\n\n\tif (! SHGetSpecialFolderPathA(NULL, path, CSIDL_SYSTEM, 0))\n\t\treturn NULL;\n\tlen_out = strlen(path)+strlen(hostfile)+1;\n\tpath_out = mm_malloc(len_out);\n\tevutil_snprintf(path_out, len_out, \"%s%s\", path, hostfile);\n\treturn path_out;\n#else\n\treturn mm_strdup(\"/etc/hosts\");\n#endif\n}\n\nstatic int\nevdns_base_resolv_conf_parse_impl(struct evdns_base *base, int flags, const char *const filename) {\n\tsize_t n;\n\tchar *resolv;\n\tchar *start;\n\tint err = 0;\n\n\tlog(EVDNS_LOG_DEBUG, \"Parsing resolv.conf file %s\", filename);\n\n\tif (flags & DNS_OPTION_HOSTSFILE) {\n\t\tchar *fname = evdns_get_default_hosts_filename();\n\t\tevdns_base_load_hosts(base, fname);\n\t\tif (fname)\n\t\t\tmm_free(fname);\n\t}\n\n\tif ((err = evutil_read_file_(filename, &resolv, &n, 0)) < 0) {\n\t\tif (err == -1) {\n\t\t\t/* No file. */\n\t\t\tevdns_resolv_set_defaults(base, flags);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\tstart = resolv;\n\tfor (;;) {\n\t\tchar *const newline = strchr(start, '\\n');\n\t\tif (!newline) {\n\t\t\tresolv_conf_parse_line(base, start, flags);\n\t\t\tbreak;\n\t\t} else {\n\t\t\t*newline = 0;\n\t\t\tresolv_conf_parse_line(base, start, flags);\n\t\t\tstart = newline + 1;\n\t\t}\n\t}\n\n\tif (!base->server_head && (flags & DNS_OPTION_NAMESERVERS)) {\n\t\t/* no nameservers were configured. */\n\t\tevdns_base_nameserver_ip_add(base, \"127.0.0.1\");\n\t\terr = 6;\n\t}\n\tif (flags & DNS_OPTION_SEARCH && (!base->global_search_state || base->global_search_state->num_domains == 0)) {\n\t\tsearch_set_from_hostname(base);\n\t}\n\n\tmm_free(resolv);\n\treturn err;\n}\n\nint\nevdns_resolv_conf_parse(int flags, const char *const filename) {\n\tif (!current_base)\n\t\tcurrent_base = evdns_base_new(NULL, 0);\n\treturn evdns_base_resolv_conf_parse(current_base, flags, filename);\n}\n\n\n#ifdef _WIN32\n/* Add multiple nameservers from a space-or-comma-separated list. */\nstatic int\nevdns_nameserver_ip_add_line(struct evdns_base *base, const char *ips) {\n\tconst char *addr;\n\tchar *buf;\n\tint r;\n\tASSERT_LOCKED(base);\n\twhile (*ips) {\n\t\twhile (isspace(*ips) || *ips == ',' || *ips == '\\t')\n\t\t\t++ips;\n\t\taddr = ips;\n\t\twhile (isdigit(*ips) || *ips == '.' || *ips == ':' ||\n\t\t    *ips=='[' || *ips==']')\n\t\t\t++ips;\n\t\tbuf = mm_malloc(ips-addr+1);\n\t\tif (!buf) return 4;\n\t\tmemcpy(buf, addr, ips-addr);\n\t\tbuf[ips-addr] = '\\0';\n\t\tr = evdns_base_nameserver_ip_add(base, buf);\n\t\tmm_free(buf);\n\t\tif (r) return r;\n\t}\n\treturn 0;\n}\n\ntypedef DWORD(WINAPI *GetNetworkParams_fn_t)(FIXED_INFO *, DWORD*);\n\n/* Use the windows GetNetworkParams interface in iphlpapi.dll to */\n/* figure out what our nameservers are. */\nstatic int\nload_nameservers_with_getnetworkparams(struct evdns_base *base)\n{\n\t/* Based on MSDN examples and inspection of  c-ares code. */\n\tFIXED_INFO *fixed;\n\tHMODULE handle = 0;\n\tULONG size = sizeof(FIXED_INFO);\n\tvoid *buf = NULL;\n\tint status = 0, r, added_any;\n\tIP_ADDR_STRING *ns;\n\tGetNetworkParams_fn_t fn;\n\n\tASSERT_LOCKED(base);\n\tif (!(handle = evutil_load_windows_system_library_(\n\t\t\tTEXT(\"iphlpapi.dll\")))) {\n\t\tlog(EVDNS_LOG_WARN, \"Could not open iphlpapi.dll\");\n\t\tstatus = -1;\n\t\tgoto done;\n\t}\n\tif (!(fn = (GetNetworkParams_fn_t) GetProcAddress(handle, \"GetNetworkParams\"))) {\n\t\tlog(EVDNS_LOG_WARN, \"Could not get address of function.\");\n\t\tstatus = -1;\n\t\tgoto done;\n\t}\n\n\tbuf = mm_malloc(size);\n\tif (!buf) { status = 4; goto done; }\n\tfixed = buf;\n\tr = fn(fixed, &size);\n\tif (r != ERROR_SUCCESS && r != ERROR_BUFFER_OVERFLOW) {\n\t\tstatus = -1;\n\t\tgoto done;\n\t}\n\tif (r != ERROR_SUCCESS) {\n\t\tmm_free(buf);\n\t\tbuf = mm_malloc(size);\n\t\tif (!buf) { status = 4; goto done; }\n\t\tfixed = buf;\n\t\tr = fn(fixed, &size);\n\t\tif (r != ERROR_SUCCESS) {\n\t\t\tlog(EVDNS_LOG_DEBUG, \"fn() failed.\");\n\t\t\tstatus = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tEVUTIL_ASSERT(fixed);\n\tadded_any = 0;\n\tns = &(fixed->DnsServerList);\n\twhile (ns) {\n\t\tr = evdns_nameserver_ip_add_line(base, ns->IpAddress.String);\n\t\tif (r) {\n\t\t\tlog(EVDNS_LOG_DEBUG,\"Could not add nameserver %s to list,error: %d\",\n\t\t\t\t(ns->IpAddress.String),(int)GetLastError());\n\t\t\tstatus = r;\n\t\t} else {\n\t\t\t++added_any;\n\t\t\tlog(EVDNS_LOG_DEBUG,\"Successfully added %s as nameserver\",ns->IpAddress.String);\n\t\t}\n\n\t\tns = ns->Next;\n\t}\n\n\tif (!added_any) {\n\t\tlog(EVDNS_LOG_DEBUG, \"No nameservers added.\");\n\t\tif (status == 0)\n\t\t\tstatus = -1;\n\t} else {\n\t\tstatus = 0;\n\t}\n\n done:\n\tif (buf)\n\t\tmm_free(buf);\n\tif (handle)\n\t\tFreeLibrary(handle);\n\treturn status;\n}\n\nstatic int\nconfig_nameserver_from_reg_key(struct evdns_base *base, HKEY key, const TCHAR *subkey)\n{\n\tchar *buf;\n\tDWORD bufsz = 0, type = 0;\n\tint status = 0;\n\n\tASSERT_LOCKED(base);\n\tif (RegQueryValueEx(key, subkey, 0, &type, NULL, &bufsz)\n\t    != ERROR_MORE_DATA)\n\t\treturn -1;\n\tif (!(buf = mm_malloc(bufsz)))\n\t\treturn -1;\n\n\tif (RegQueryValueEx(key, subkey, 0, &type, (LPBYTE)buf, &bufsz)\n\t    == ERROR_SUCCESS && bufsz > 1) {\n\t\tstatus = evdns_nameserver_ip_add_line(base,buf);\n\t}\n\n\tmm_free(buf);\n\treturn status;\n}\n\n#define SERVICES_KEY TEXT(\"System\\\\CurrentControlSet\\\\Services\\\\\")\n#define WIN_NS_9X_KEY  SERVICES_KEY TEXT(\"VxD\\\\MSTCP\")\n#define WIN_NS_NT_KEY  SERVICES_KEY TEXT(\"Tcpip\\\\Parameters\")\n\nstatic int\nload_nameservers_from_registry(struct evdns_base *base)\n{\n\tint found = 0;\n\tint r;\n#define TRY(k, name) \\\n\tif (!found && config_nameserver_from_reg_key(base,k,TEXT(name)) == 0) { \\\n\t\tlog(EVDNS_LOG_DEBUG,\"Found nameservers in %s/%s\",#k,name); \\\n\t\tfound = 1;\t\t\t\t\t\t\\\n\t} else if (!found) {\t\t\t\t\t\t\\\n\t\tlog(EVDNS_LOG_DEBUG,\"Didn't find nameservers in %s/%s\", \\\n\t\t    #k,#name);\t\t\t\t\t\t\\\n\t}\n\n\tASSERT_LOCKED(base);\n\n\tif (((int)GetVersion()) > 0) { /* NT */\n\t\tHKEY nt_key = 0, interfaces_key = 0;\n\n\t\tif (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY, 0,\n\t\t\t\t KEY_READ, &nt_key) != ERROR_SUCCESS) {\n\t\t\tlog(EVDNS_LOG_DEBUG,\"Couldn't open nt key, %d\",(int)GetLastError());\n\t\t\treturn -1;\n\t\t}\n\t\tr = RegOpenKeyEx(nt_key, TEXT(\"Interfaces\"), 0,\n\t\t\t     KEY_QUERY_VALUE|KEY_ENUMERATE_SUB_KEYS,\n\t\t\t     &interfaces_key);\n\t\tif (r != ERROR_SUCCESS) {\n\t\t\tlog(EVDNS_LOG_DEBUG,\"Couldn't open interfaces key, %d\",(int)GetLastError());\n\t\t\treturn -1;\n\t\t}\n\t\tTRY(nt_key, \"NameServer\");\n\t\tTRY(nt_key, \"DhcpNameServer\");\n\t\tTRY(interfaces_key, \"NameServer\");\n\t\tTRY(interfaces_key, \"DhcpNameServer\");\n\t\tRegCloseKey(interfaces_key);\n\t\tRegCloseKey(nt_key);\n\t} else {\n\t\tHKEY win_key = 0;\n\t\tif (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WIN_NS_9X_KEY, 0,\n\t\t\t\t KEY_READ, &win_key) != ERROR_SUCCESS) {\n\t\t\tlog(EVDNS_LOG_DEBUG, \"Couldn't open registry key, %d\", (int)GetLastError());\n\t\t\treturn -1;\n\t\t}\n\t\tTRY(win_key, \"NameServer\");\n\t\tRegCloseKey(win_key);\n\t}\n\n\tif (found == 0) {\n\t\tlog(EVDNS_LOG_WARN,\"Didn't find any nameservers.\");\n\t}\n\n\treturn found ? 0 : -1;\n#undef TRY\n}\n\nint\nevdns_base_config_windows_nameservers(struct evdns_base *base)\n{\n\tint r;\n\tchar *fname;\n\tif (base == NULL)\n\t\tbase = current_base;\n\tif (base == NULL)\n\t\treturn -1;\n\tEVDNS_LOCK(base);\n\tfname = evdns_get_default_hosts_filename();\n\tlog(EVDNS_LOG_DEBUG, \"Loading hosts entries from %s\", fname);\n\tevdns_base_load_hosts(base, fname);\n\tif (fname)\n\t\tmm_free(fname);\n\n\tif (load_nameservers_with_getnetworkparams(base) == 0) {\n\t\tEVDNS_UNLOCK(base);\n\t\treturn 0;\n\t}\n\tr = load_nameservers_from_registry(base);\n\n\tEVDNS_UNLOCK(base);\n\treturn r;\n}\n\nint\nevdns_config_windows_nameservers(void)\n{\n\tif (!current_base) {\n\t\tcurrent_base = evdns_base_new(NULL, 1);\n\t\treturn current_base == NULL ? -1 : 0;\n\t} else {\n\t\treturn evdns_base_config_windows_nameservers(current_base);\n\t}\n}\n#endif\n\nstruct evdns_base *\nevdns_base_new(struct event_base *event_base, int flags)\n{\n\tstruct evdns_base *base;\n\n\tif (evutil_secure_rng_init() < 0) {\n\t\tlog(EVDNS_LOG_WARN, \"Unable to seed random number generator; \"\n\t\t    \"DNS can't run.\");\n\t\treturn NULL;\n\t}\n\n\t/* Give the evutil library a hook into its evdns-enabled\n\t * functionality.  We can't just call evdns_getaddrinfo directly or\n\t * else libevent-core will depend on libevent-extras. */\n\tevutil_set_evdns_getaddrinfo_fn_(evdns_getaddrinfo);\n\tevutil_set_evdns_getaddrinfo_cancel_fn_(evdns_getaddrinfo_cancel);\n\n\tbase = mm_malloc(sizeof(struct evdns_base));\n\tif (base == NULL)\n\t\treturn (NULL);\n\tmemset(base, 0, sizeof(struct evdns_base));\n\tbase->req_waiting_head = NULL;\n\n\tEVTHREAD_ALLOC_LOCK(base->lock, EVTHREAD_LOCKTYPE_RECURSIVE);\n\tEVDNS_LOCK(base);\n\n\t/* Set max requests inflight and allocate req_heads. */\n\tbase->req_heads = NULL;\n\n\tevdns_base_set_max_requests_inflight(base, 64);\n\n\tbase->server_head = NULL;\n\tbase->event_base = event_base;\n\tbase->global_good_nameservers = base->global_requests_inflight =\n\t\tbase->global_requests_waiting = 0;\n\n\tbase->global_timeout.tv_sec = 5;\n\tbase->global_timeout.tv_usec = 0;\n\tbase->global_max_reissues = 1;\n\tbase->global_max_retransmits = 3;\n\tbase->global_max_nameserver_timeout = 3;\n\tbase->global_search_state = NULL;\n\tbase->global_randomize_case = 1;\n\tbase->global_getaddrinfo_allow_skew.tv_sec = 3;\n\tbase->global_getaddrinfo_allow_skew.tv_usec = 0;\n\tbase->global_nameserver_probe_initial_timeout.tv_sec = 10;\n\tbase->global_nameserver_probe_initial_timeout.tv_usec = 0;\n\n\tTAILQ_INIT(&base->hostsdb);\n\n#define EVDNS_BASE_ALL_FLAGS (0x8001)\n\tif (flags & ~EVDNS_BASE_ALL_FLAGS) {\n\t\tflags = EVDNS_BASE_INITIALIZE_NAMESERVERS;\n\t\tlog(EVDNS_LOG_WARN,\n\t\t    \"Unrecognized flag passed to evdns_base_new(). Assuming \"\n\t\t    \"you meant EVDNS_BASE_INITIALIZE_NAMESERVERS.\");\n\t}\n#undef EVDNS_BASE_ALL_FLAGS\n\n\tif (flags & EVDNS_BASE_INITIALIZE_NAMESERVERS) {\n\t\tint r;\n#ifdef _WIN32\n\t\tr = evdns_base_config_windows_nameservers(base);\n#else\n\t\tr = evdns_base_resolv_conf_parse(base, DNS_OPTIONS_ALL, \"/etc/resolv.conf\");\n#endif\n\t\tif (r == -1) {\n\t\t\tevdns_base_free_and_unlock(base, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (flags & EVDNS_BASE_DISABLE_WHEN_INACTIVE) {\n\t\tbase->disable_when_inactive = 1;\n\t}\n\n\tEVDNS_UNLOCK(base);\n\treturn base;\n}\n\nint\nevdns_init(void)\n{\n\tstruct evdns_base *base = evdns_base_new(NULL, 1);\n\tif (base) {\n\t\tcurrent_base = base;\n\t\treturn 0;\n\t} else {\n\t\treturn -1;\n\t}\n}\n\nconst char *\nevdns_err_to_string(int err)\n{\n    switch (err) {\n\tcase DNS_ERR_NONE: return \"no error\";\n\tcase DNS_ERR_FORMAT: return \"misformatted query\";\n\tcase DNS_ERR_SERVERFAILED: return \"server failed\";\n\tcase DNS_ERR_NOTEXIST: return \"name does not exist\";\n\tcase DNS_ERR_NOTIMPL: return \"query not implemented\";\n\tcase DNS_ERR_REFUSED: return \"refused\";\n\n\tcase DNS_ERR_TRUNCATED: return \"reply truncated or ill-formed\";\n\tcase DNS_ERR_UNKNOWN: return \"unknown\";\n\tcase DNS_ERR_TIMEOUT: return \"request timed out\";\n\tcase DNS_ERR_SHUTDOWN: return \"dns subsystem shut down\";\n\tcase DNS_ERR_CANCEL: return \"dns request canceled\";\n\tcase DNS_ERR_NODATA: return \"no records in the reply\";\n\tdefault: return \"[Unknown error code]\";\n    }\n}\n\nstatic void\nevdns_nameserver_free(struct nameserver *server)\n{\n\tif (server->socket >= 0)\n\t\tevutil_closesocket(server->socket);\n\t(void) event_del(&server->event);\n\tevent_debug_unassign(&server->event);\n\tif (server->state == 0)\n\t\t(void) event_del(&server->timeout_event);\n\tif (server->probe_request) {\n\t\tevdns_cancel_request(server->base, server->probe_request);\n\t\tserver->probe_request = NULL;\n\t}\n\tevent_debug_unassign(&server->timeout_event);\n\tmm_free(server);\n}\n\nstatic void\nevdns_base_free_and_unlock(struct evdns_base *base, int fail_requests)\n{\n\tstruct nameserver *server, *server_next;\n\tstruct search_domain *dom, *dom_next;\n\tint i;\n\n\t/* Requires that we hold the lock. */\n\n\t/* TODO(nickm) we might need to refcount here. */\n\n\tfor (i = 0; i < base->n_req_heads; ++i) {\n\t\twhile (base->req_heads[i]) {\n\t\t\tif (fail_requests)\n\t\t\t\treply_schedule_callback(base->req_heads[i], 0, DNS_ERR_SHUTDOWN, NULL);\n\t\t\trequest_finished(base->req_heads[i], &REQ_HEAD(base, base->req_heads[i]->trans_id), 1);\n\t\t}\n\t}\n\twhile (base->req_waiting_head) {\n\t\tif (fail_requests)\n\t\t\treply_schedule_callback(base->req_waiting_head, 0, DNS_ERR_SHUTDOWN, NULL);\n\t\trequest_finished(base->req_waiting_head, &base->req_waiting_head, 1);\n\t}\n\tbase->global_requests_inflight = base->global_requests_waiting = 0;\n\n\tfor (server = base->server_head; server; server = server_next) {\n\t\tserver_next = server->next;\n\t\t/** already done something before */\n\t\tserver->probe_request = NULL;\n\t\tevdns_nameserver_free(server);\n\t\tif (server_next == base->server_head)\n\t\t\tbreak;\n\t}\n\tbase->server_head = NULL;\n\tbase->global_good_nameservers = 0;\n\n\tif (base->global_search_state) {\n\t\tfor (dom = base->global_search_state->head; dom; dom = dom_next) {\n\t\t\tdom_next = dom->next;\n\t\t\tmm_free(dom);\n\t\t}\n\t\tmm_free(base->global_search_state);\n\t\tbase->global_search_state = NULL;\n\t}\n\n\t{\n\t\tstruct hosts_entry *victim;\n\t\twhile ((victim = TAILQ_FIRST(&base->hostsdb))) {\n\t\t\tTAILQ_REMOVE(&base->hostsdb, victim, next);\n\t\t\tmm_free(victim);\n\t\t}\n\t}\n\n\tmm_free(base->req_heads);\n\n\tEVDNS_UNLOCK(base);\n\tEVTHREAD_FREE_LOCK(base->lock, EVTHREAD_LOCKTYPE_RECURSIVE);\n\n\tmm_free(base);\n}\n\nvoid\nevdns_base_free(struct evdns_base *base, int fail_requests)\n{\n\tEVDNS_LOCK(base);\n\tevdns_base_free_and_unlock(base, fail_requests);\n}\n\nvoid\nevdns_base_clear_host_addresses(struct evdns_base *base)\n{\n\tstruct hosts_entry *victim;\n\tEVDNS_LOCK(base);\n\twhile ((victim = TAILQ_FIRST(&base->hostsdb))) {\n\t\tTAILQ_REMOVE(&base->hostsdb, victim, next);\n\t\tmm_free(victim);\n\t}\n\tEVDNS_UNLOCK(base);\n}\n\nvoid\nevdns_shutdown(int fail_requests)\n{\n\tif (current_base) {\n\t\tstruct evdns_base *b = current_base;\n\t\tcurrent_base = NULL;\n\t\tevdns_base_free(b, fail_requests);\n\t}\n\tevdns_log_fn = NULL;\n}\n\nstatic int\nevdns_base_parse_hosts_line(struct evdns_base *base, char *line)\n{\n\tchar *strtok_state;\n\tstatic const char *const delims = \" \\t\";\n\tchar *const addr = strtok_r(line, delims, &strtok_state);\n\tchar *hostname, *hash;\n\tstruct sockaddr_storage ss;\n\tint socklen = sizeof(ss);\n\tASSERT_LOCKED(base);\n\n#define NEXT_TOKEN strtok_r(NULL, delims, &strtok_state)\n\n\tif (!addr || *addr == '#')\n\t\treturn 0;\n\n\tmemset(&ss, 0, sizeof(ss));\n\tif (evutil_parse_sockaddr_port(addr, (struct sockaddr*)&ss, &socklen)<0)\n\t\treturn -1;\n\tif (socklen > (int)sizeof(struct sockaddr_in6))\n\t\treturn -1;\n\n\tif (sockaddr_getport((struct sockaddr*)&ss))\n\t\treturn -1;\n\n\twhile ((hostname = NEXT_TOKEN)) {\n\t\tstruct hosts_entry *he;\n\t\tsize_t namelen;\n\t\tif ((hash = strchr(hostname, '#'))) {\n\t\t\tif (hash == hostname)\n\t\t\t\treturn 0;\n\t\t\t*hash = '\\0';\n\t\t}\n\n\t\tnamelen = strlen(hostname);\n\n\t\the = mm_calloc(1, sizeof(struct hosts_entry)+namelen);\n\t\tif (!he)\n\t\t\treturn -1;\n\t\tEVUTIL_ASSERT(socklen <= (int)sizeof(he->addr));\n\t\tmemcpy(&he->addr, &ss, socklen);\n\t\tmemcpy(he->hostname, hostname, namelen+1);\n\t\the->addrlen = socklen;\n\n\t\tTAILQ_INSERT_TAIL(&base->hostsdb, he, next);\n\n\t\tif (hash)\n\t\t\treturn 0;\n\t}\n\n\treturn 0;\n#undef NEXT_TOKEN\n}\n\nstatic int\nevdns_base_load_hosts_impl(struct evdns_base *base, const char *hosts_fname)\n{\n\tchar *str=NULL, *cp, *eol;\n\tsize_t len;\n\tint err=0;\n\n\tASSERT_LOCKED(base);\n\n\tif (hosts_fname == NULL ||\n\t    (err = evutil_read_file_(hosts_fname, &str, &len, 0)) < 0) {\n\t\tchar tmp[64];\n\t\tstrlcpy(tmp, \"127.0.0.1   localhost\", sizeof(tmp));\n\t\tevdns_base_parse_hosts_line(base, tmp);\n\t\tstrlcpy(tmp, \"::1   localhost\", sizeof(tmp));\n\t\tevdns_base_parse_hosts_line(base, tmp);\n\t\treturn err ? -1 : 0;\n\t}\n\n\t/* This will break early if there is a NUL in the hosts file.\n\t * Probably not a problem.*/\n\tcp = str;\n\tfor (;;) {\n\t\teol = strchr(cp, '\\n');\n\n\t\tif (eol) {\n\t\t\t*eol = '\\0';\n\t\t\tevdns_base_parse_hosts_line(base, cp);\n\t\t\tcp = eol+1;\n\t\t} else {\n\t\t\tevdns_base_parse_hosts_line(base, cp);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmm_free(str);\n\treturn 0;\n}\n\nint\nevdns_base_load_hosts(struct evdns_base *base, const char *hosts_fname)\n{\n\tint res;\n\tif (!base)\n\t\tbase = current_base;\n\tEVDNS_LOCK(base);\n\tres = evdns_base_load_hosts_impl(base, hosts_fname);\n\tEVDNS_UNLOCK(base);\n\treturn res;\n}\n\n/* A single request for a getaddrinfo, either v4 or v6. */\nstruct getaddrinfo_subrequest {\n\tstruct evdns_request *r;\n\tev_uint32_t type;\n};\n\n/* State data used to implement an in-progress getaddrinfo. */\nstruct evdns_getaddrinfo_request {\n\tstruct evdns_base *evdns_base;\n\t/* Copy of the modified 'hints' data that we'll use to build\n\t * answers. */\n\tstruct evutil_addrinfo hints;\n\t/* The callback to invoke when we're done */\n\tevdns_getaddrinfo_cb user_cb;\n\t/* User-supplied data to give to the callback. */\n\tvoid *user_data;\n\t/* The port to use when building sockaddrs. */\n\tev_uint16_t port;\n\t/* The sub_request for an A record (if any) */\n\tstruct getaddrinfo_subrequest ipv4_request;\n\t/* The sub_request for an AAAA record (if any) */\n\tstruct getaddrinfo_subrequest ipv6_request;\n\n\t/* The cname result that we were told (if any) */\n\tchar *cname_result;\n\n\t/* If we have one request answered and one request still inflight,\n\t * then this field holds the answer from the first request... */\n\tstruct evutil_addrinfo *pending_result;\n\t/* And this event is a timeout that will tell us to cancel the second\n\t * request if it's taking a long time. */\n\tstruct event timeout;\n\n\t/* And this field holds the error code from the first request... */\n\tint pending_error;\n\t/* If this is set, the user canceled this request. */\n\tunsigned user_canceled : 1;\n\t/* If this is set, the user can no longer cancel this request; we're\n\t * just waiting for the free. */\n\tunsigned request_done : 1;\n};\n\n/* Convert an evdns errors to the equivalent getaddrinfo error. */\nstatic int\nevdns_err_to_getaddrinfo_err(int e1)\n{\n\t/* XXX Do this better! */\n\tif (e1 == DNS_ERR_NONE)\n\t\treturn 0;\n\telse if (e1 == DNS_ERR_NOTEXIST)\n\t\treturn EVUTIL_EAI_NONAME;\n\telse\n\t\treturn EVUTIL_EAI_FAIL;\n}\n\n/* Return the more informative of two getaddrinfo errors. */\nstatic int\ngetaddrinfo_merge_err(int e1, int e2)\n{\n\t/* XXXX be cleverer here. */\n\tif (e1 == 0)\n\t\treturn e2;\n\telse\n\t\treturn e1;\n}\n\nstatic void\nfree_getaddrinfo_request(struct evdns_getaddrinfo_request *data)\n{\n\t/* DO NOT CALL this if either of the requests is pending.  Only once\n\t * both callbacks have been invoked is it safe to free the request */\n\tif (data->pending_result)\n\t\tevutil_freeaddrinfo(data->pending_result);\n\tif (data->cname_result)\n\t\tmm_free(data->cname_result);\n\tevent_del(&data->timeout);\n\tmm_free(data);\n\treturn;\n}\n\nstatic void\nadd_cname_to_reply(struct evdns_getaddrinfo_request *data,\n    struct evutil_addrinfo *ai)\n{\n\tif (data->cname_result && ai) {\n\t\tai->ai_canonname = data->cname_result;\n\t\tdata->cname_result = NULL;\n\t}\n}\n\n/* Callback: invoked when one request in a mixed-format A/AAAA getaddrinfo\n * request has finished, but the other one took too long to answer. Pass\n * along the answer we got, and cancel the other request.\n */\nstatic void\nevdns_getaddrinfo_timeout_cb(evutil_socket_t fd, short what, void *ptr)\n{\n\tint v4_timedout = 0, v6_timedout = 0;\n\tstruct evdns_getaddrinfo_request *data = ptr;\n\n\t/* Cancel any pending requests, and note which one */\n\tif (data->ipv4_request.r) {\n\t\t/* XXXX This does nothing if the request's callback is already\n\t\t * running (pending_cb is set). */\n\t\tevdns_cancel_request(NULL, data->ipv4_request.r);\n\t\tv4_timedout = 1;\n\t\tEVDNS_LOCK(data->evdns_base);\n\t\t++data->evdns_base->getaddrinfo_ipv4_timeouts;\n\t\tEVDNS_UNLOCK(data->evdns_base);\n\t}\n\tif (data->ipv6_request.r) {\n\t\t/* XXXX This does nothing if the request's callback is already\n\t\t * running (pending_cb is set). */\n\t\tevdns_cancel_request(NULL, data->ipv6_request.r);\n\t\tv6_timedout = 1;\n\t\tEVDNS_LOCK(data->evdns_base);\n\t\t++data->evdns_base->getaddrinfo_ipv6_timeouts;\n\t\tEVDNS_UNLOCK(data->evdns_base);\n\t}\n\n\t/* We only use this timeout callback when we have an answer for\n\t * one address. */\n\tEVUTIL_ASSERT(!v4_timedout || !v6_timedout);\n\n\t/* Report the outcome of the other request that didn't time out. */\n\tif (data->pending_result) {\n\t\tadd_cname_to_reply(data, data->pending_result);\n\t\tdata->user_cb(0, data->pending_result, data->user_data);\n\t\tdata->pending_result = NULL;\n\t} else {\n\t\tint e = data->pending_error;\n\t\tif (!e)\n\t\t\te = EVUTIL_EAI_AGAIN;\n\t\tdata->user_cb(e, NULL, data->user_data);\n\t}\n\n\tdata->user_cb = NULL; /* prevent double-call if evdns callbacks are\n\t\t\t       * in-progress. XXXX It would be better if this\n\t\t\t       * weren't necessary. */\n\n\tif (!v4_timedout && !v6_timedout) {\n\t\t/* should be impossible? XXXX */\n\t\tfree_getaddrinfo_request(data);\n\t}\n}\n\nstatic int\nevdns_getaddrinfo_set_timeout(struct evdns_base *evdns_base,\n    struct evdns_getaddrinfo_request *data)\n{\n\treturn event_add(&data->timeout, &evdns_base->global_getaddrinfo_allow_skew);\n}\n\nstatic inline int\nevdns_result_is_answer(int result)\n{\n\treturn (result != DNS_ERR_NOTIMPL && result != DNS_ERR_REFUSED &&\n\t    result != DNS_ERR_SERVERFAILED && result != DNS_ERR_CANCEL);\n}\n\nstatic void\nevdns_getaddrinfo_gotresolve(int result, char type, int count,\n    int ttl, void *addresses, void *arg)\n{\n\tint i;\n\tstruct getaddrinfo_subrequest *req = arg;\n\tstruct getaddrinfo_subrequest *other_req;\n\tstruct evdns_getaddrinfo_request *data;\n\n\tstruct evutil_addrinfo *res;\n\n\tstruct sockaddr_in sin;\n\tstruct sockaddr_in6 sin6;\n\tstruct sockaddr *sa;\n\tint socklen, addrlen;\n\tvoid *addrp;\n\tint err;\n\tint user_canceled;\n\n\tEVUTIL_ASSERT(req->type == DNS_IPv4_A || req->type == DNS_IPv6_AAAA);\n\tif (req->type == DNS_IPv4_A) {\n\t\tdata = EVUTIL_UPCAST(req, struct evdns_getaddrinfo_request, ipv4_request);\n\t\tother_req = &data->ipv6_request;\n\t} else {\n\t\tdata = EVUTIL_UPCAST(req, struct evdns_getaddrinfo_request, ipv6_request);\n\t\tother_req = &data->ipv4_request;\n\t}\n\n\t/** Called from evdns_base_free() with @fail_requests == 1 */\n\tif (result != DNS_ERR_SHUTDOWN) {\n\t\tEVDNS_LOCK(data->evdns_base);\n\t\tif (evdns_result_is_answer(result)) {\n\t\t\tif (req->type == DNS_IPv4_A)\n\t\t\t\t++data->evdns_base->getaddrinfo_ipv4_answered;\n\t\t\telse\n\t\t\t\t++data->evdns_base->getaddrinfo_ipv6_answered;\n\t\t}\n\t\tuser_canceled = data->user_canceled;\n\t\tif (other_req->r == NULL)\n\t\t\tdata->request_done = 1;\n\t\tEVDNS_UNLOCK(data->evdns_base);\n\t} else {\n\t\tdata->evdns_base = NULL;\n\t\tuser_canceled = data->user_canceled;\n\t}\n\n\treq->r = NULL;\n\n\tif (result == DNS_ERR_CANCEL && ! user_canceled) {\n\t\t/* Internal cancel request from timeout or internal error.\n\t\t * we already answered the user. */\n\t\tif (other_req->r == NULL)\n\t\t\tfree_getaddrinfo_request(data);\n\t\treturn;\n\t}\n\n\tif (data->user_cb == NULL) {\n\t\t/* We already answered.  XXXX This shouldn't be needed; see\n\t\t * comments in evdns_getaddrinfo_timeout_cb */\n\t\tfree_getaddrinfo_request(data);\n\t\treturn;\n\t}\n\n\tif (result == DNS_ERR_NONE) {\n\t\tif (count == 0)\n\t\t\terr = EVUTIL_EAI_NODATA;\n\t\telse\n\t\t\terr = 0;\n\t} else {\n\t\terr = evdns_err_to_getaddrinfo_err(result);\n\t}\n\n\tif (err) {\n\t\t/* Looks like we got an error. */\n\t\tif (other_req->r) {\n\t\t\t/* The other request is still working; maybe it will\n\t\t\t * succeed. */\n\t\t\t/* XXXX handle failure from set_timeout */\n\t\t\tif (result != DNS_ERR_SHUTDOWN) {\n\t\t\t\tevdns_getaddrinfo_set_timeout(data->evdns_base, data);\n\t\t\t}\n\t\t\tdata->pending_error = err;\n\t\t\treturn;\n\t\t}\n\n\t\tif (user_canceled) {\n\t\t\tdata->user_cb(EVUTIL_EAI_CANCEL, NULL, data->user_data);\n\t\t} else if (data->pending_result) {\n\t\t\t/* If we have an answer waiting, and we weren't\n\t\t\t * canceled, ignore this error. */\n\t\t\tadd_cname_to_reply(data, data->pending_result);\n\t\t\tdata->user_cb(0, data->pending_result, data->user_data);\n\t\t\tdata->pending_result = NULL;\n\t\t} else {\n\t\t\tif (data->pending_error)\n\t\t\t\terr = getaddrinfo_merge_err(err,\n\t\t\t\t    data->pending_error);\n\t\t\tdata->user_cb(err, NULL, data->user_data);\n\t\t}\n\t\tfree_getaddrinfo_request(data);\n\t\treturn;\n\t} else if (user_canceled) {\n\t\tif (other_req->r) {\n\t\t\t/* The other request is still working; let it hit this\n\t\t\t * callback with EVUTIL_EAI_CANCEL callback and report\n\t\t\t * the failure. */\n\t\t\treturn;\n\t\t}\n\t\tdata->user_cb(EVUTIL_EAI_CANCEL, NULL, data->user_data);\n\t\tfree_getaddrinfo_request(data);\n\t\treturn;\n\t}\n\n\t/* Looks like we got some answers. We should turn them into addrinfos\n\t * and then either queue those or return them all. */\n\tEVUTIL_ASSERT(type == DNS_IPv4_A || type == DNS_IPv6_AAAA);\n\n\tif (type == DNS_IPv4_A) {\n\t\tmemset(&sin, 0, sizeof(sin));\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = htons(data->port);\n\n\t\tsa = (struct sockaddr *)&sin;\n\t\tsocklen = sizeof(sin);\n\t\taddrlen = 4;\n\t\taddrp = &sin.sin_addr.s_addr;\n\t} else {\n\t\tmemset(&sin6, 0, sizeof(sin6));\n\t\tsin6.sin6_family = AF_INET6;\n\t\tsin6.sin6_port = htons(data->port);\n\n\t\tsa = (struct sockaddr *)&sin6;\n\t\tsocklen = sizeof(sin6);\n\t\taddrlen = 16;\n\t\taddrp = &sin6.sin6_addr.s6_addr;\n\t}\n\n\tres = NULL;\n\tfor (i=0; i < count; ++i) {\n\t\tstruct evutil_addrinfo *ai;\n\t\tmemcpy(addrp, ((char*)addresses)+i*addrlen, addrlen);\n\t\tai = evutil_new_addrinfo_(sa, socklen, &data->hints);\n\t\tif (!ai) {\n\t\t\tif (other_req->r) {\n\t\t\t\tevdns_cancel_request(NULL, other_req->r);\n\t\t\t}\n\t\t\tdata->user_cb(EVUTIL_EAI_MEMORY, NULL, data->user_data);\n\t\t\tif (res)\n\t\t\t\tevutil_freeaddrinfo(res);\n\n\t\t\tif (other_req->r == NULL)\n\t\t\t\tfree_getaddrinfo_request(data);\n\t\t\treturn;\n\t\t}\n\t\tres = evutil_addrinfo_append_(res, ai);\n\t}\n\n\tif (other_req->r) {\n\t\t/* The other request is still in progress; wait for it */\n\t\t/* XXXX handle failure from set_timeout */\n\t\tevdns_getaddrinfo_set_timeout(data->evdns_base, data);\n\t\tdata->pending_result = res;\n\t\treturn;\n\t} else {\n\t\t/* The other request is done or never started; append its\n\t\t * results (if any) and return them. */\n\t\tif (data->pending_result) {\n\t\t\tif (req->type == DNS_IPv4_A)\n\t\t\t\tres = evutil_addrinfo_append_(res,\n\t\t\t\t    data->pending_result);\n\t\t\telse\n\t\t\t\tres = evutil_addrinfo_append_(\n\t\t\t\t    data->pending_result, res);\n\t\t\tdata->pending_result = NULL;\n\t\t}\n\n\t\t/* Call the user callback. */\n\t\tadd_cname_to_reply(data, res);\n\t\tdata->user_cb(0, res, data->user_data);\n\n\t\t/* Free data. */\n\t\tfree_getaddrinfo_request(data);\n\t}\n}\n\nstatic struct hosts_entry *\nfind_hosts_entry(struct evdns_base *base, const char *hostname,\n    struct hosts_entry *find_after)\n{\n\tstruct hosts_entry *e;\n\n\tif (find_after)\n\t\te = TAILQ_NEXT(find_after, next);\n\telse\n\t\te = TAILQ_FIRST(&base->hostsdb);\n\n\tfor (; e; e = TAILQ_NEXT(e, next)) {\n\t\tif (!evutil_ascii_strcasecmp(e->hostname, hostname))\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}\n\nstatic int\nevdns_getaddrinfo_fromhosts(struct evdns_base *base,\n    const char *nodename, struct evutil_addrinfo *hints, ev_uint16_t port,\n    struct evutil_addrinfo **res)\n{\n\tint n_found = 0;\n\tstruct hosts_entry *e;\n\tstruct evutil_addrinfo *ai=NULL;\n\tint f = hints->ai_family;\n\n\tEVDNS_LOCK(base);\n\tfor (e = find_hosts_entry(base, nodename, NULL); e;\n\t    e = find_hosts_entry(base, nodename, e)) {\n\t\tstruct evutil_addrinfo *ai_new;\n\t\t++n_found;\n\t\tif ((e->addr.sa.sa_family == AF_INET && f == PF_INET6) ||\n\t\t    (e->addr.sa.sa_family == AF_INET6 && f == PF_INET))\n\t\t\tcontinue;\n\t\tai_new = evutil_new_addrinfo_(&e->addr.sa, e->addrlen, hints);\n\t\tif (!ai_new) {\n\t\t\tn_found = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tsockaddr_setport(ai_new->ai_addr, port);\n\t\tai = evutil_addrinfo_append_(ai, ai_new);\n\t}\n\tEVDNS_UNLOCK(base);\nout:\n\tif (n_found) {\n\t\t/* Note that we return an empty answer if we found entries for\n\t\t * this hostname but none were of the right address type. */\n\t\t*res = ai;\n\t\treturn 0;\n\t} else {\n\t\tif (ai)\n\t\t\tevutil_freeaddrinfo(ai);\n\t\treturn -1;\n\t}\n}\n\nstruct evdns_getaddrinfo_request *\nevdns_getaddrinfo(struct evdns_base *dns_base,\n    const char *nodename, const char *servname,\n    const struct evutil_addrinfo *hints_in,\n    evdns_getaddrinfo_cb cb, void *arg)\n{\n\tstruct evdns_getaddrinfo_request *data;\n\tstruct evutil_addrinfo hints;\n\tstruct evutil_addrinfo *res = NULL;\n\tint err;\n\tint port = 0;\n\tint want_cname = 0;\n\n\tif (!dns_base) {\n\t\tdns_base = current_base;\n\t\tif (!dns_base) {\n\t\t\tlog(EVDNS_LOG_WARN,\n\t\t\t    \"Call to getaddrinfo_async with no \"\n\t\t\t    \"evdns_base configured.\");\n\t\t\tcb(EVUTIL_EAI_FAIL, NULL, arg); /* ??? better error? */\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* If we _must_ answer this immediately, do so. */\n\tif ((hints_in && (hints_in->ai_flags & EVUTIL_AI_NUMERICHOST))) {\n\t\tres = NULL;\n\t\terr = evutil_getaddrinfo(nodename, servname, hints_in, &res);\n\t\tcb(err, res, arg);\n\t\treturn NULL;\n\t}\n\n\tif (hints_in) {\n\t\tmemcpy(&hints, hints_in, sizeof(hints));\n\t} else {\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = PF_UNSPEC;\n\t}\n\n\tevutil_adjust_hints_for_addrconfig_(&hints);\n\n\t/* Now try to see if we _can_ answer immediately. */\n\t/* (It would be nice to do this by calling getaddrinfo directly, with\n\t * AI_NUMERICHOST, on plaforms that have it, but we can't: there isn't\n\t * a reliable way to distinguish the \"that wasn't a numeric host!\" case\n\t * from any other EAI_NONAME cases.) */\n\terr = evutil_getaddrinfo_common_(nodename, servname, &hints, &res, &port);\n\tif (err != EVUTIL_EAI_NEED_RESOLVE) {\n\t\tcb(err, res, arg);\n\t\treturn NULL;\n\t}\n\n\t/* If there is an entry in the hosts file, we should give it now. */\n\tif (!evdns_getaddrinfo_fromhosts(dns_base, nodename, &hints, port, &res)) {\n\t\tcb(0, res, arg);\n\t\treturn NULL;\n\t}\n\n\t/* Okay, things are serious now. We're going to need to actually\n\t * launch a request.\n\t */\n\tdata = mm_calloc(1,sizeof(struct evdns_getaddrinfo_request));\n\tif (!data) {\n\t\tcb(EVUTIL_EAI_MEMORY, NULL, arg);\n\t\treturn NULL;\n\t}\n\n\tmemcpy(&data->hints, &hints, sizeof(data->hints));\n\tdata->port = (ev_uint16_t)port;\n\tdata->ipv4_request.type = DNS_IPv4_A;\n\tdata->ipv6_request.type = DNS_IPv6_AAAA;\n\tdata->user_cb = cb;\n\tdata->user_data = arg;\n\tdata->evdns_base = dns_base;\n\n\twant_cname = (hints.ai_flags & EVUTIL_AI_CANONNAME);\n\n\t/* If we are asked for a PF_UNSPEC address, we launch two requests in\n\t * parallel: one for an A address and one for an AAAA address.  We\n\t * can't send just one request, since many servers only answer one\n\t * question per DNS request.\n\t *\n\t * Once we have the answer to one request, we allow for a short\n\t * timeout before we report it, to see if the other one arrives.  If\n\t * they both show up in time, then we report both the answers.\n\t *\n\t * If too many addresses of one type time out or fail, we should stop\n\t * launching those requests. (XXX we don't do that yet.)\n\t */\n\n\tif (hints.ai_family != PF_INET6) {\n\t\tlog(EVDNS_LOG_DEBUG, \"Sending request for %s on ipv4 as %p\",\n\t\t    nodename, &data->ipv4_request);\n\n\t\tdata->ipv4_request.r = evdns_base_resolve_ipv4(dns_base,\n\t\t    nodename, 0, evdns_getaddrinfo_gotresolve,\n\t\t    &data->ipv4_request);\n\t\tif (want_cname && data->ipv4_request.r)\n\t\t\tdata->ipv4_request.r->current_req->put_cname_in_ptr =\n\t\t\t    &data->cname_result;\n\t}\n\tif (hints.ai_family != PF_INET) {\n\t\tlog(EVDNS_LOG_DEBUG, \"Sending request for %s on ipv6 as %p\",\n\t\t    nodename, &data->ipv6_request);\n\n\t\tdata->ipv6_request.r = evdns_base_resolve_ipv6(dns_base,\n\t\t    nodename, 0, evdns_getaddrinfo_gotresolve,\n\t\t    &data->ipv6_request);\n\t\tif (want_cname && data->ipv6_request.r)\n\t\t\tdata->ipv6_request.r->current_req->put_cname_in_ptr =\n\t\t\t    &data->cname_result;\n\t}\n\n\tevtimer_assign(&data->timeout, dns_base->event_base,\n\t    evdns_getaddrinfo_timeout_cb, data);\n\n\tif (data->ipv4_request.r || data->ipv6_request.r) {\n\t\treturn data;\n\t} else {\n\t\tmm_free(data);\n\t\tcb(EVUTIL_EAI_FAIL, NULL, arg);\n\t\treturn NULL;\n\t}\n}\n\nvoid\nevdns_getaddrinfo_cancel(struct evdns_getaddrinfo_request *data)\n{\n\tEVDNS_LOCK(data->evdns_base);\n\tif (data->request_done) {\n\t\tEVDNS_UNLOCK(data->evdns_base);\n\t\treturn;\n\t}\n\tevent_del(&data->timeout);\n\tdata->user_canceled = 1;\n\tif (data->ipv4_request.r)\n\t\tevdns_cancel_request(data->evdns_base, data->ipv4_request.r);\n\tif (data->ipv6_request.r)\n\t\tevdns_cancel_request(data->evdns_base, data->ipv6_request.r);\n\tEVDNS_UNLOCK(data->evdns_base);\n}\n"], "fixing_code": ["/* Copyright 2006-2007 Niels Provos\n * Copyright 2007-2012 Nick Mathewson and Niels Provos\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* Based on software by Adam Langly. Adam's original message:\n *\n * Async DNS Library\n * Adam Langley <agl@imperialviolet.org>\n * http://www.imperialviolet.org/eventdns.html\n * Public Domain code\n *\n * This software is Public Domain. To view a copy of the public domain dedication,\n * visit http://creativecommons.org/licenses/publicdomain/ or send a letter to\n * Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.\n *\n * I ask and expect, but do not require, that all derivative works contain an\n * attribution similar to:\n *\tParts developed by Adam Langley <agl@imperialviolet.org>\n *\n * You may wish to replace the word \"Parts\" with something else depending on\n * the amount of original code.\n *\n * (Derivative works does not include programs which link against, run or include\n * the source verbatim in their source distributions)\n *\n * Version: 0.1b\n */\n\n#include \"event2/event-config.h\"\n#include \"evconfig-private.h\"\n\n#include <sys/types.h>\n\n#ifndef _FORTIFY_SOURCE\n#define _FORTIFY_SOURCE 3\n#endif\n\n#include <string.h>\n#include <fcntl.h>\n#ifdef EVENT__HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#ifdef EVENT__HAVE_STDINT_H\n#include <stdint.h>\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#ifdef EVENT__HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <limits.h>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <stdarg.h>\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#ifndef _WIN32_IE\n#define _WIN32_IE 0x400\n#endif\n#include <shlobj.h>\n#endif\n\n#include \"event2/dns.h\"\n#include \"event2/dns_struct.h\"\n#include \"event2/dns_compat.h\"\n#include \"event2/util.h\"\n#include \"event2/event.h\"\n#include \"event2/event_struct.h\"\n#include \"event2/thread.h\"\n\n#include \"defer-internal.h\"\n#include \"log-internal.h\"\n#include \"mm-internal.h\"\n#include \"strlcpy-internal.h\"\n#include \"ipv6-internal.h\"\n#include \"util-internal.h\"\n#include \"evthread-internal.h\"\n#ifdef _WIN32\n#include <ctype.h>\n#include <winsock2.h>\n#include <windows.h>\n#include <iphlpapi.h>\n#include <io.h>\n#else\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#endif\n\n#ifdef EVENT__HAVE_NETINET_IN6_H\n#include <netinet/in6.h>\n#endif\n\n#define EVDNS_LOG_DEBUG EVENT_LOG_DEBUG\n#define EVDNS_LOG_WARN EVENT_LOG_WARN\n#define EVDNS_LOG_MSG EVENT_LOG_MSG\n\n#ifndef HOST_NAME_MAX\n#define HOST_NAME_MAX 255\n#endif\n\n#include <stdio.h>\n\n#undef MIN\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\n#define ASSERT_VALID_REQUEST(req) \\\n\tEVUTIL_ASSERT((req)->handle && (req)->handle->current_req == (req))\n\n#define u64 ev_uint64_t\n#define u32 ev_uint32_t\n#define u16 ev_uint16_t\n#define u8  ev_uint8_t\n\n/* maximum number of addresses from a single packet */\n/* that we bother recording */\n#define MAX_V4_ADDRS 32\n#define MAX_V6_ADDRS 32\n\n\n#define TYPE_A\t       EVDNS_TYPE_A\n#define TYPE_CNAME     5\n#define TYPE_PTR       EVDNS_TYPE_PTR\n#define TYPE_SOA       EVDNS_TYPE_SOA\n#define TYPE_AAAA      EVDNS_TYPE_AAAA\n\n#define CLASS_INET     EVDNS_CLASS_INET\n\n/* Persistent handle.  We keep this separate from 'struct request' since we\n * need some object to last for as long as an evdns_request is outstanding so\n * that it can be canceled, whereas a search request can lead to multiple\n * 'struct request' instances being created over its lifetime. */\nstruct evdns_request {\n\tstruct request *current_req;\n\tstruct evdns_base *base;\n\n\tint pending_cb; /* Waiting for its callback to be invoked; not\n\t\t\t * owned by event base any more. */\n\n\t/* elements used by the searching code */\n\tint search_index;\n\tstruct search_state *search_state;\n\tchar *search_origname;\t/* needs to be free()ed */\n\tint search_flags;\n};\n\nstruct request {\n\tu8 *request;  /* the dns packet data */\n\tu8 request_type; /* TYPE_PTR or TYPE_A or TYPE_AAAA */\n\tunsigned int request_len;\n\tint reissue_count;\n\tint tx_count;  /* the number of times that this packet has been sent */\n\tvoid *user_pointer;  /* the pointer given to us for this request */\n\tevdns_callback_type user_callback;\n\tstruct nameserver *ns;\t/* the server which we last sent it */\n\n\t/* these objects are kept in a circular list */\n\t/* XXX We could turn this into a CIRCLEQ. */\n\tstruct request *next, *prev;\n\n\tstruct event timeout_event;\n\n\tu16 trans_id;  /* the transaction id */\n\tunsigned request_appended :1;\t/* true if the request pointer is data which follows this struct */\n\tunsigned transmit_me :1;  /* needs to be transmitted */\n\n\t/* XXXX This is a horrible hack. */\n\tchar **put_cname_in_ptr; /* store the cname here if we get one. */\n\n\tstruct evdns_base *base;\n\n\tstruct evdns_request *handle;\n};\n\nstruct reply {\n\tunsigned int type;\n\tunsigned int have_answer : 1;\n\tunion {\n\t\tstruct {\n\t\t\tu32 addrcount;\n\t\t\tu32 addresses[MAX_V4_ADDRS];\n\t\t} a;\n\t\tstruct {\n\t\t\tu32 addrcount;\n\t\t\tstruct in6_addr addresses[MAX_V6_ADDRS];\n\t\t} aaaa;\n\t\tstruct {\n\t\t\tchar name[HOST_NAME_MAX];\n\t\t} ptr;\n\t} data;\n};\n\nstruct nameserver {\n\tevutil_socket_t socket;\t /* a connected UDP socket */\n\tstruct sockaddr_storage address;\n\tev_socklen_t addrlen;\n\tint failed_times;  /* number of times which we have given this server a chance */\n\tint timedout;  /* number of times in a row a request has timed out */\n\tstruct event event;\n\t/* these objects are kept in a circular list */\n\tstruct nameserver *next, *prev;\n\tstruct event timeout_event;  /* used to keep the timeout for */\n\t\t\t\t     /* when we next probe this server. */\n\t\t\t\t     /* Valid if state == 0 */\n\t/* Outstanding probe request for this nameserver, if any */\n\tstruct evdns_request *probe_request;\n\tchar state;  /* zero if we think that this server is down */\n\tchar choked;  /* true if we have an EAGAIN from this server's socket */\n\tchar write_waiting;  /* true if we are waiting for EV_WRITE events */\n\tstruct evdns_base *base;\n\n\t/* Number of currently inflight requests: used\n\t * to track when we should add/del the event. */\n\tint requests_inflight;\n};\n\n\n/* Represents a local port where we're listening for DNS requests. Right now, */\n/* only UDP is supported. */\nstruct evdns_server_port {\n\tevutil_socket_t socket; /* socket we use to read queries and write replies. */\n\tint refcnt; /* reference count. */\n\tchar choked; /* Are we currently blocked from writing? */\n\tchar closing; /* Are we trying to close this port, pending writes? */\n\tevdns_request_callback_fn_type user_callback; /* Fn to handle requests */\n\tvoid *user_data; /* Opaque pointer passed to user_callback */\n\tstruct event event; /* Read/write event */\n\t/* circular list of replies that we want to write. */\n\tstruct server_request *pending_replies;\n\tstruct event_base *event_base;\n\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\n\tvoid *lock;\n#endif\n};\n\n/* Represents part of a reply being built.\t(That is, a single RR.) */\nstruct server_reply_item {\n\tstruct server_reply_item *next; /* next item in sequence. */\n\tchar *name; /* name part of the RR */\n\tu16 type; /* The RR type */\n\tu16 class; /* The RR class (usually CLASS_INET) */\n\tu32 ttl; /* The RR TTL */\n\tchar is_name; /* True iff data is a label */\n\tu16 datalen; /* Length of data; -1 if data is a label */\n\tvoid *data; /* The contents of the RR */\n};\n\n/* Represents a request that we've received as a DNS server, and holds */\n/* the components of the reply as we're constructing it. */\nstruct server_request {\n\t/* Pointers to the next and previous entries on the list of replies */\n\t/* that we're waiting to write.\t Only set if we have tried to respond */\n\t/* and gotten EAGAIN. */\n\tstruct server_request *next_pending;\n\tstruct server_request *prev_pending;\n\n\tu16 trans_id; /* Transaction id. */\n\tstruct evdns_server_port *port; /* Which port received this request on? */\n\tstruct sockaddr_storage addr; /* Where to send the response */\n\tev_socklen_t addrlen; /* length of addr */\n\n\tint n_answer; /* how many answer RRs have been set? */\n\tint n_authority; /* how many authority RRs have been set? */\n\tint n_additional; /* how many additional RRs have been set? */\n\n\tstruct server_reply_item *answer; /* linked list of answer RRs */\n\tstruct server_reply_item *authority; /* linked list of authority RRs */\n\tstruct server_reply_item *additional; /* linked list of additional RRs */\n\n\t/* Constructed response.  Only set once we're ready to send a reply. */\n\t/* Once this is set, the RR fields are cleared, and no more should be set. */\n\tchar *response;\n\tsize_t response_len;\n\n\t/* Caller-visible fields: flags, questions. */\n\tstruct evdns_server_request base;\n};\n\nstruct evdns_base {\n\t/* An array of n_req_heads circular lists for inflight requests.\n\t * Each inflight request req is in req_heads[req->trans_id % n_req_heads].\n\t */\n\tstruct request **req_heads;\n\t/* A circular list of requests that we're waiting to send, but haven't\n\t * sent yet because there are too many requests inflight */\n\tstruct request *req_waiting_head;\n\t/* A circular list of nameservers. */\n\tstruct nameserver *server_head;\n\tint n_req_heads;\n\n\tstruct event_base *event_base;\n\n\t/* The number of good nameservers that we have */\n\tint global_good_nameservers;\n\n\t/* inflight requests are contained in the req_head list */\n\t/* and are actually going out across the network */\n\tint global_requests_inflight;\n\t/* requests which aren't inflight are in the waiting list */\n\t/* and are counted here */\n\tint global_requests_waiting;\n\n\tint global_max_requests_inflight;\n\n\tstruct timeval global_timeout;\t/* 5 seconds by default */\n\tint global_max_reissues;  /* a reissue occurs when we get some errors from the server */\n\tint global_max_retransmits;  /* number of times we'll retransmit a request which timed out */\n\t/* number of timeouts in a row before we consider this server to be down */\n\tint global_max_nameserver_timeout;\n\t/* true iff we will use the 0x20 hack to prevent poisoning attacks. */\n\tint global_randomize_case;\n\n\t/* The first time that a nameserver fails, how long do we wait before\n\t * probing to see if it has returned?  */\n\tstruct timeval global_nameserver_probe_initial_timeout;\n\n\t/** Port to bind to for outgoing DNS packets. */\n\tstruct sockaddr_storage global_outgoing_address;\n\t/** ev_socklen_t for global_outgoing_address. 0 if it isn't set. */\n\tev_socklen_t global_outgoing_addrlen;\n\n\tstruct timeval global_getaddrinfo_allow_skew;\n\n\tint getaddrinfo_ipv4_timeouts;\n\tint getaddrinfo_ipv6_timeouts;\n\tint getaddrinfo_ipv4_answered;\n\tint getaddrinfo_ipv6_answered;\n\n\tstruct search_state *global_search_state;\n\n\tTAILQ_HEAD(hosts_list, hosts_entry) hostsdb;\n\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\n\tvoid *lock;\n#endif\n\n\tint disable_when_inactive;\n};\n\nstruct hosts_entry {\n\tTAILQ_ENTRY(hosts_entry) next;\n\tunion {\n\t\tstruct sockaddr sa;\n\t\tstruct sockaddr_in sin;\n\t\tstruct sockaddr_in6 sin6;\n\t} addr;\n\tint addrlen;\n\tchar hostname[1];\n};\n\nstatic struct evdns_base *current_base = NULL;\n\nstruct evdns_base *\nevdns_get_global_base(void)\n{\n\treturn current_base;\n}\n\n/* Given a pointer to an evdns_server_request, get the corresponding */\n/* server_request. */\n#define TO_SERVER_REQUEST(base_ptr)\t\t\t\t\t\\\n\t((struct server_request*)\t\t\t\t\t\\\n\t  (((char*)(base_ptr) - evutil_offsetof(struct server_request, base))))\n\n#define REQ_HEAD(base, id) ((base)->req_heads[id % (base)->n_req_heads])\n\nstatic struct nameserver *nameserver_pick(struct evdns_base *base);\nstatic void evdns_request_insert(struct request *req, struct request **head);\nstatic void evdns_request_remove(struct request *req, struct request **head);\nstatic void nameserver_ready_callback(evutil_socket_t fd, short events, void *arg);\nstatic int evdns_transmit(struct evdns_base *base);\nstatic int evdns_request_transmit(struct request *req);\nstatic void nameserver_send_probe(struct nameserver *const ns);\nstatic void search_request_finished(struct evdns_request *const);\nstatic int search_try_next(struct evdns_request *const req);\nstatic struct request *search_request_new(struct evdns_base *base, struct evdns_request *handle, int type, const char *const name, int flags, evdns_callback_type user_callback, void *user_arg);\nstatic void evdns_requests_pump_waiting_queue(struct evdns_base *base);\nstatic u16 transaction_id_pick(struct evdns_base *base);\nstatic struct request *request_new(struct evdns_base *base, struct evdns_request *handle, int type, const char *name, int flags, evdns_callback_type callback, void *ptr);\nstatic void request_submit(struct request *const req);\n\nstatic int server_request_free(struct server_request *req);\nstatic void server_request_free_answers(struct server_request *req);\nstatic void server_port_free(struct evdns_server_port *port);\nstatic void server_port_ready_callback(evutil_socket_t fd, short events, void *arg);\nstatic int evdns_base_resolv_conf_parse_impl(struct evdns_base *base, int flags, const char *const filename);\nstatic int evdns_base_set_option_impl(struct evdns_base *base,\n    const char *option, const char *val, int flags);\nstatic void evdns_base_free_and_unlock(struct evdns_base *base, int fail_requests);\nstatic void evdns_request_timeout_callback(evutil_socket_t fd, short events, void *arg);\n\nstatic int strtoint(const char *const str);\n\n#ifdef EVENT__DISABLE_THREAD_SUPPORT\n#define EVDNS_LOCK(base)  EVUTIL_NIL_STMT_\n#define EVDNS_UNLOCK(base) EVUTIL_NIL_STMT_\n#define ASSERT_LOCKED(base) EVUTIL_NIL_STMT_\n#else\n#define EVDNS_LOCK(base)\t\t\t\\\n\tEVLOCK_LOCK((base)->lock, 0)\n#define EVDNS_UNLOCK(base)\t\t\t\\\n\tEVLOCK_UNLOCK((base)->lock, 0)\n#define ASSERT_LOCKED(base)\t\t\t\\\n\tEVLOCK_ASSERT_LOCKED((base)->lock)\n#endif\n\nstatic evdns_debug_log_fn_type evdns_log_fn = NULL;\n\nvoid\nevdns_set_log_fn(evdns_debug_log_fn_type fn)\n{\n\tevdns_log_fn = fn;\n}\n\n#ifdef __GNUC__\n#define EVDNS_LOG_CHECK\t __attribute__ ((format(printf, 2, 3)))\n#else\n#define EVDNS_LOG_CHECK\n#endif\n\nstatic void evdns_log_(int severity, const char *fmt, ...) EVDNS_LOG_CHECK;\nstatic void\nevdns_log_(int severity, const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args,fmt);\n\tif (evdns_log_fn) {\n\t\tchar buf[512];\n\t\tint is_warn = (severity == EVDNS_LOG_WARN);\n\t\tevutil_vsnprintf(buf, sizeof(buf), fmt, args);\n\t\tevdns_log_fn(is_warn, buf);\n\t} else {\n\t\tevent_logv_(severity, NULL, fmt, args);\n\t}\n\tva_end(args);\n}\n\n#define log evdns_log_\n\n/* This walks the list of inflight requests to find the */\n/* one with a matching transaction id. Returns NULL on */\n/* failure */\nstatic struct request *\nrequest_find_from_trans_id(struct evdns_base *base, u16 trans_id) {\n\tstruct request *req = REQ_HEAD(base, trans_id);\n\tstruct request *const started_at = req;\n\n\tASSERT_LOCKED(base);\n\n\tif (req) {\n\t\tdo {\n\t\t\tif (req->trans_id == trans_id) return req;\n\t\t\treq = req->next;\n\t\t} while (req != started_at);\n\t}\n\n\treturn NULL;\n}\n\n/* a libevent callback function which is called when a nameserver */\n/* has gone down and we want to test if it has came back to life yet */\nstatic void\nnameserver_prod_callback(evutil_socket_t fd, short events, void *arg) {\n\tstruct nameserver *const ns = (struct nameserver *) arg;\n\t(void)fd;\n\t(void)events;\n\n\tEVDNS_LOCK(ns->base);\n\tnameserver_send_probe(ns);\n\tEVDNS_UNLOCK(ns->base);\n}\n\n/* a libevent callback which is called when a nameserver probe (to see if */\n/* it has come back to life) times out. We increment the count of failed_times */\n/* and wait longer to send the next probe packet. */\nstatic void\nnameserver_probe_failed(struct nameserver *const ns) {\n\tstruct timeval timeout;\n\tint i;\n\n\tASSERT_LOCKED(ns->base);\n\t(void) evtimer_del(&ns->timeout_event);\n\tif (ns->state == 1) {\n\t\t/* This can happen if the nameserver acts in a way which makes us mark */\n\t\t/* it as bad and then starts sending good replies. */\n\t\treturn;\n\t}\n\n#define MAX_PROBE_TIMEOUT 3600\n#define TIMEOUT_BACKOFF_FACTOR 3\n\n\tmemcpy(&timeout, &ns->base->global_nameserver_probe_initial_timeout,\n\t    sizeof(struct timeval));\n\tfor (i=ns->failed_times; i > 0 && timeout.tv_sec < MAX_PROBE_TIMEOUT; --i) {\n\t\ttimeout.tv_sec *= TIMEOUT_BACKOFF_FACTOR;\n\t\ttimeout.tv_usec *= TIMEOUT_BACKOFF_FACTOR;\n\t\tif (timeout.tv_usec > 1000000) {\n\t\t\ttimeout.tv_sec += timeout.tv_usec / 1000000;\n\t\t\ttimeout.tv_usec %= 1000000;\n\t\t}\n\t}\n\tif (timeout.tv_sec > MAX_PROBE_TIMEOUT) {\n\t\ttimeout.tv_sec = MAX_PROBE_TIMEOUT;\n\t\ttimeout.tv_usec = 0;\n\t}\n\n\tns->failed_times++;\n\n\tif (evtimer_add(&ns->timeout_event, &timeout) < 0) {\n\t\tchar addrbuf[128];\n\t\tlog(EVDNS_LOG_WARN,\n\t\t    \"Error from libevent when adding timer event for %s\",\n\t\t    evutil_format_sockaddr_port_(\n\t\t\t    (struct sockaddr *)&ns->address,\n\t\t\t    addrbuf, sizeof(addrbuf)));\n\t}\n}\n\nstatic void\nrequest_swap_ns(struct request *req, struct nameserver *ns) {\n\tif (ns && req->ns != ns) {\n\t\tEVUTIL_ASSERT(req->ns->requests_inflight > 0);\n\t\treq->ns->requests_inflight--;\n\t\tns->requests_inflight++;\n\n\t\treq->ns = ns;\n\t}\n}\n\n/* called when a nameserver has been deemed to have failed. For example, too */\n/* many packets have timed out etc */\nstatic void\nnameserver_failed(struct nameserver *const ns, const char *msg) {\n\tstruct request *req, *started_at;\n\tstruct evdns_base *base = ns->base;\n\tint i;\n\tchar addrbuf[128];\n\n\tASSERT_LOCKED(base);\n\t/* if this nameserver has already been marked as failed */\n\t/* then don't do anything */\n\tif (!ns->state) return;\n\n\tlog(EVDNS_LOG_MSG, \"Nameserver %s has failed: %s\",\n\t    evutil_format_sockaddr_port_(\n\t\t    (struct sockaddr *)&ns->address,\n\t\t    addrbuf, sizeof(addrbuf)),\n\t    msg);\n\n\tbase->global_good_nameservers--;\n\tEVUTIL_ASSERT(base->global_good_nameservers >= 0);\n\tif (base->global_good_nameservers == 0) {\n\t\tlog(EVDNS_LOG_MSG, \"All nameservers have failed\");\n\t}\n\n\tns->state = 0;\n\tns->failed_times = 1;\n\n\tif (evtimer_add(&ns->timeout_event,\n\t\t&base->global_nameserver_probe_initial_timeout) < 0) {\n\t\tlog(EVDNS_LOG_WARN,\n\t\t    \"Error from libevent when adding timer event for %s\",\n\t\t    evutil_format_sockaddr_port_(\n\t\t\t    (struct sockaddr *)&ns->address,\n\t\t\t    addrbuf, sizeof(addrbuf)));\n\t\t/* ???? Do more? */\n\t}\n\n\t/* walk the list of inflight requests to see if any can be reassigned to */\n\t/* a different server. Requests in the waiting queue don't have a */\n\t/* nameserver assigned yet */\n\n\t/* if we don't have *any* good nameservers then there's no point */\n\t/* trying to reassign requests to one */\n\tif (!base->global_good_nameservers) return;\n\n\tfor (i = 0; i < base->n_req_heads; ++i) {\n\t\treq = started_at = base->req_heads[i];\n\t\tif (req) {\n\t\t\tdo {\n\t\t\t\tif (req->tx_count == 0 && req->ns == ns) {\n\t\t\t\t\t/* still waiting to go out, can be moved */\n\t\t\t\t\t/* to another server */\n\t\t\t\t\trequest_swap_ns(req, nameserver_pick(base));\n\t\t\t\t}\n\t\t\t\treq = req->next;\n\t\t\t} while (req != started_at);\n\t\t}\n\t}\n}\n\nstatic void\nnameserver_up(struct nameserver *const ns)\n{\n\tchar addrbuf[128];\n\tASSERT_LOCKED(ns->base);\n\tif (ns->state) return;\n\tlog(EVDNS_LOG_MSG, \"Nameserver %s is back up\",\n\t    evutil_format_sockaddr_port_(\n\t\t    (struct sockaddr *)&ns->address,\n\t\t    addrbuf, sizeof(addrbuf)));\n\tevtimer_del(&ns->timeout_event);\n\tif (ns->probe_request) {\n\t\tevdns_cancel_request(ns->base, ns->probe_request);\n\t\tns->probe_request = NULL;\n\t}\n\tns->state = 1;\n\tns->failed_times = 0;\n\tns->timedout = 0;\n\tns->base->global_good_nameservers++;\n}\n\nstatic void\nrequest_trans_id_set(struct request *const req, const u16 trans_id) {\n\treq->trans_id = trans_id;\n\t*((u16 *) req->request) = htons(trans_id);\n}\n\n/* Called to remove a request from a list and dealloc it. */\n/* head is a pointer to the head of the list it should be */\n/* removed from or NULL if the request isn't in a list. */\n/* when free_handle is one, free the handle as well. */\nstatic void\nrequest_finished(struct request *const req, struct request **head, int free_handle) {\n\tstruct evdns_base *base = req->base;\n\tint was_inflight = (head != &base->req_waiting_head);\n\tEVDNS_LOCK(base);\n\tASSERT_VALID_REQUEST(req);\n\n\tif (head)\n\t\tevdns_request_remove(req, head);\n\n\tlog(EVDNS_LOG_DEBUG, \"Removing timeout for request %p\", req);\n\tif (was_inflight) {\n\t\tevtimer_del(&req->timeout_event);\n\t\tbase->global_requests_inflight--;\n\t\treq->ns->requests_inflight--;\n\t} else {\n\t\tbase->global_requests_waiting--;\n\t}\n\t/* it was initialized during request_new / evtimer_assign */\n\tevent_debug_unassign(&req->timeout_event);\n\n\tif (req->ns &&\n\t    req->ns->requests_inflight == 0 &&\n\t    req->base->disable_when_inactive) {\n\t\tevent_del(&req->ns->event);\n\t\tevtimer_del(&req->ns->timeout_event);\n\t}\n\n\tif (!req->request_appended) {\n\t\t/* need to free the request data on it's own */\n\t\tmm_free(req->request);\n\t} else {\n\t\t/* the request data is appended onto the header */\n\t\t/* so everything gets free()ed when we: */\n\t}\n\n\tif (req->handle) {\n\t\tEVUTIL_ASSERT(req->handle->current_req == req);\n\n\t\tif (free_handle) {\n\t\t\tsearch_request_finished(req->handle);\n\t\t\treq->handle->current_req = NULL;\n\t\t\tif (! req->handle->pending_cb) {\n\t\t\t\t/* If we're planning to run the callback,\n\t\t\t\t * don't free the handle until later. */\n\t\t\t\tmm_free(req->handle);\n\t\t\t}\n\t\t\treq->handle = NULL; /* If we have a bug, let's crash\n\t\t\t\t\t     * early */\n\t\t} else {\n\t\t\treq->handle->current_req = NULL;\n\t\t}\n\t}\n\n\tmm_free(req);\n\n\tevdns_requests_pump_waiting_queue(base);\n\tEVDNS_UNLOCK(base);\n}\n\n/* This is called when a server returns a funny error code. */\n/* We try the request again with another server. */\n/* */\n/* return: */\n/*   0 ok */\n/*   1 failed/reissue is pointless */\nstatic int\nrequest_reissue(struct request *req) {\n\tconst struct nameserver *const last_ns = req->ns;\n\tASSERT_LOCKED(req->base);\n\tASSERT_VALID_REQUEST(req);\n\t/* the last nameserver should have been marked as failing */\n\t/* by the caller of this function, therefore pick will try */\n\t/* not to return it */\n\trequest_swap_ns(req, nameserver_pick(req->base));\n\tif (req->ns == last_ns) {\n\t\t/* ... but pick did return it */\n\t\t/* not a lot of point in trying again with the */\n\t\t/* same server */\n\t\treturn 1;\n\t}\n\n\treq->reissue_count++;\n\treq->tx_count = 0;\n\treq->transmit_me = 1;\n\n\treturn 0;\n}\n\n/* this function looks for space on the inflight queue and promotes */\n/* requests from the waiting queue if it can. */\n/* */\n/* TODO: */\n/* add return code, see at nameserver_pick() and other functions. */\nstatic void\nevdns_requests_pump_waiting_queue(struct evdns_base *base) {\n\tASSERT_LOCKED(base);\n\twhile (base->global_requests_inflight < base->global_max_requests_inflight &&\n\t\t   base->global_requests_waiting) {\n\t\tstruct request *req;\n\n\t\tEVUTIL_ASSERT(base->req_waiting_head);\n\t\treq = base->req_waiting_head;\n\n\t\treq->ns = nameserver_pick(base);\n\t\tif (!req->ns)\n\t\t\treturn;\n\n\t\t/* move a request from the waiting queue to the inflight queue */\n\t\treq->ns->requests_inflight++;\n\n\t\tevdns_request_remove(req, &base->req_waiting_head);\n\n\t\tbase->global_requests_waiting--;\n\t\tbase->global_requests_inflight++;\n\n\t\trequest_trans_id_set(req, transaction_id_pick(base));\n\n\t\tevdns_request_insert(req, &REQ_HEAD(base, req->trans_id));\n\t\tevdns_request_transmit(req);\n\t\tevdns_transmit(base);\n\t}\n}\n\n/* TODO(nickm) document */\nstruct deferred_reply_callback {\n\tstruct event_callback deferred;\n\tstruct evdns_request *handle;\n\tu8 request_type;\n\tu8 have_reply;\n\tu32 ttl;\n\tu32 err;\n\tevdns_callback_type user_callback;\n\tstruct reply reply;\n};\n\nstatic void\nreply_run_callback(struct event_callback *d, void *user_pointer)\n{\n\tstruct deferred_reply_callback *cb =\n\t    EVUTIL_UPCAST(d, struct deferred_reply_callback, deferred);\n\n\tswitch (cb->request_type) {\n\tcase TYPE_A:\n\t\tif (cb->have_reply)\n\t\t\tcb->user_callback(DNS_ERR_NONE, DNS_IPv4_A,\n\t\t\t    cb->reply.data.a.addrcount, cb->ttl,\n\t\t\t    cb->reply.data.a.addresses,\n\t\t\t    user_pointer);\n\t\telse\n\t\t\tcb->user_callback(cb->err, 0, 0, cb->ttl, NULL, user_pointer);\n\t\tbreak;\n\tcase TYPE_PTR:\n\t\tif (cb->have_reply) {\n\t\t\tchar *name = cb->reply.data.ptr.name;\n\t\t\tcb->user_callback(DNS_ERR_NONE, DNS_PTR, 1, cb->ttl,\n\t\t\t    &name, user_pointer);\n\t\t} else {\n\t\t\tcb->user_callback(cb->err, 0, 0, cb->ttl, NULL, user_pointer);\n\t\t}\n\t\tbreak;\n\tcase TYPE_AAAA:\n\t\tif (cb->have_reply)\n\t\t\tcb->user_callback(DNS_ERR_NONE, DNS_IPv6_AAAA,\n\t\t\t    cb->reply.data.aaaa.addrcount, cb->ttl,\n\t\t\t    cb->reply.data.aaaa.addresses,\n\t\t\t    user_pointer);\n\t\telse\n\t\t\tcb->user_callback(cb->err, 0, 0, cb->ttl, NULL, user_pointer);\n\t\tbreak;\n\tdefault:\n\t\tEVUTIL_ASSERT(0);\n\t}\n\n\tif (cb->handle && cb->handle->pending_cb) {\n\t\tmm_free(cb->handle);\n\t}\n\n\tmm_free(cb);\n}\n\nstatic void\nreply_schedule_callback(struct request *const req, u32 ttl, u32 err, struct reply *reply)\n{\n\tstruct deferred_reply_callback *d = mm_calloc(1, sizeof(*d));\n\n\tif (!d) {\n\t\tevent_warn(\"%s: Couldn't allocate space for deferred callback.\",\n\t\t    __func__);\n\t\treturn;\n\t}\n\n\tASSERT_LOCKED(req->base);\n\n\td->request_type = req->request_type;\n\td->user_callback = req->user_callback;\n\td->ttl = ttl;\n\td->err = err;\n\tif (reply) {\n\t\td->have_reply = 1;\n\t\tmemcpy(&d->reply, reply, sizeof(struct reply));\n\t}\n\n\tif (req->handle) {\n\t\treq->handle->pending_cb = 1;\n\t\td->handle = req->handle;\n\t}\n\n\tevent_deferred_cb_init_(\n\t    &d->deferred,\n\t    event_get_priority(&req->timeout_event),\n\t    reply_run_callback,\n\t    req->user_pointer);\n\tevent_deferred_cb_schedule_(\n\t\treq->base->event_base,\n\t\t&d->deferred);\n}\n\n/* this processes a parsed reply packet */\nstatic void\nreply_handle(struct request *const req, u16 flags, u32 ttl, struct reply *reply) {\n\tint error;\n\tchar addrbuf[128];\n\tstatic const int error_codes[] = {\n\t\tDNS_ERR_FORMAT, DNS_ERR_SERVERFAILED, DNS_ERR_NOTEXIST,\n\t\tDNS_ERR_NOTIMPL, DNS_ERR_REFUSED\n\t};\n\n\tASSERT_LOCKED(req->base);\n\tASSERT_VALID_REQUEST(req);\n\n\tif (flags & 0x020f || !reply || !reply->have_answer) {\n\t\t/* there was an error */\n\t\tif (flags & 0x0200) {\n\t\t\terror = DNS_ERR_TRUNCATED;\n\t\t} else if (flags & 0x000f) {\n\t\t\tu16 error_code = (flags & 0x000f) - 1;\n\t\t\tif (error_code > 4) {\n\t\t\t\terror = DNS_ERR_UNKNOWN;\n\t\t\t} else {\n\t\t\t\terror = error_codes[error_code];\n\t\t\t}\n\t\t} else if (reply && !reply->have_answer) {\n\t\t\terror = DNS_ERR_NODATA;\n\t\t} else {\n\t\t\terror = DNS_ERR_UNKNOWN;\n\t\t}\n\n\t\tswitch (error) {\n\t\tcase DNS_ERR_NOTIMPL:\n\t\tcase DNS_ERR_REFUSED:\n\t\t\t/* we regard these errors as marking a bad nameserver */\n\t\t\tif (req->reissue_count < req->base->global_max_reissues) {\n\t\t\t\tchar msg[64];\n\t\t\t\tevutil_snprintf(msg, sizeof(msg), \"Bad response %d (%s)\",\n\t\t\t\t\t error, evdns_err_to_string(error));\n\t\t\t\tnameserver_failed(req->ns, msg);\n\t\t\t\tif (!request_reissue(req)) return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_ERR_SERVERFAILED:\n\t\t\t/* rcode 2 (servfailed) sometimes means \"we\n\t\t\t * are broken\" and sometimes (with some binds)\n\t\t\t * means \"that request was very confusing.\"\n\t\t\t * Treat this as a timeout, not a failure.\n\t\t\t */\n\t\t\tlog(EVDNS_LOG_DEBUG, \"Got a SERVERFAILED from nameserver\"\n\t\t\t\t\"at %s; will allow the request to time out.\",\n\t\t\t    evutil_format_sockaddr_port_(\n\t\t\t\t    (struct sockaddr *)&req->ns->address,\n\t\t\t\t    addrbuf, sizeof(addrbuf)));\n\t\t\t/* Call the timeout function */\n\t\t\tevdns_request_timeout_callback(0, 0, req);\n\t\t\treturn;\n\t\tdefault:\n\t\t\t/* we got a good reply from the nameserver: it is up. */\n\t\t\tif (req->handle == req->ns->probe_request) {\n\t\t\t\t/* Avoid double-free */\n\t\t\t\treq->ns->probe_request = NULL;\n\t\t\t}\n\n\t\t\tnameserver_up(req->ns);\n\t\t}\n\n\t\tif (req->handle->search_state &&\n\t\t    req->request_type != TYPE_PTR) {\n\t\t\t/* if we have a list of domains to search in,\n\t\t\t * try the next one */\n\t\t\tif (!search_try_next(req->handle)) {\n\t\t\t\t/* a new request was issued so this\n\t\t\t\t * request is finished and */\n\t\t\t\t/* the user callback will be made when\n\t\t\t\t * that request (or a */\n\t\t\t\t/* child of it) finishes. */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* all else failed. Pass the failure up */\n\t\treply_schedule_callback(req, ttl, error, NULL);\n\t\trequest_finished(req, &REQ_HEAD(req->base, req->trans_id), 1);\n\t} else {\n\t\t/* all ok, tell the user */\n\t\treply_schedule_callback(req, ttl, 0, reply);\n\t\tif (req->handle == req->ns->probe_request)\n\t\t\treq->ns->probe_request = NULL; /* Avoid double-free */\n\t\tnameserver_up(req->ns);\n\t\trequest_finished(req, &REQ_HEAD(req->base, req->trans_id), 1);\n\t}\n}\n\nstatic int\nname_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {\n\tint name_end = -1;\n\tint j = *idx;\n\tint ptr_count = 0;\n#define GET32(x) do { if (j + 4 > length) goto err; memcpy(&t32_, packet + j, 4); j += 4; x = ntohl(t32_); } while (0)\n#define GET16(x) do { if (j + 2 > length) goto err; memcpy(&t_, packet + j, 2); j += 2; x = ntohs(t_); } while (0)\n#define GET8(x) do { if (j >= length) goto err; x = packet[j++]; } while (0)\n\n\tchar *cp = name_out;\n\tconst char *const end = name_out + name_out_len;\n\n\t/* Normally, names are a series of length prefixed strings terminated */\n\t/* with a length of 0 (the lengths are u8's < 63). */\n\t/* However, the length can start with a pair of 1 bits and that */\n\t/* means that the next 14 bits are a pointer within the current */\n\t/* packet. */\n\n\tfor (;;) {\n\t\tu8 label_len;\n\t\tGET8(label_len);\n\t\tif (!label_len) break;\n\t\tif (label_len & 0xc0) {\n\t\t\tu8 ptr_low;\n\t\t\tGET8(ptr_low);\n\t\t\tif (name_end < 0) name_end = j;\n\t\t\tj = (((int)label_len & 0x3f) << 8) + ptr_low;\n\t\t\t/* Make sure that the target offset is in-bounds. */\n\t\t\tif (j < 0 || j >= length) return -1;\n\t\t\t/* If we've jumped more times than there are characters in the\n\t\t\t * message, we must have a loop. */\n\t\t\tif (++ptr_count > length) return -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (label_len > 63) return -1;\n\t\tif (cp != name_out) {\n\t\t\tif (cp + 1 >= end) return -1;\n\t\t\t*cp++ = '.';\n\t\t}\n\t\tif (cp + label_len >= end) return -1;\n\t\tif (j + label_len > length) return -1;\n\t\tmemcpy(cp, packet + j, label_len);\n\t\tcp += label_len;\n\t\tj += label_len;\n\t}\n\tif (cp >= end) return -1;\n\t*cp = '\\0';\n\tif (name_end < 0)\n\t\t*idx = j;\n\telse\n\t\t*idx = name_end;\n\treturn 0;\n err:\n\treturn -1;\n}\n\n/* parses a raw request from a nameserver */\nstatic int\nreply_parse(struct evdns_base *base, u8 *packet, int length) {\n\tint j = 0, k = 0;  /* index into packet */\n\tu16 t_;\t /* used by the macros */\n\tu32 t32_;  /* used by the macros */\n\tchar tmp_name[256], cmp_name[256]; /* used by the macros */\n\tint name_matches = 0;\n\n\tu16 trans_id, questions, answers, authority, additional, datalength;\n\tu16 flags = 0;\n\tu32 ttl, ttl_r = 0xffffffff;\n\tstruct reply reply;\n\tstruct request *req = NULL;\n\tunsigned int i;\n\n\tASSERT_LOCKED(base);\n\n\tGET16(trans_id);\n\tGET16(flags);\n\tGET16(questions);\n\tGET16(answers);\n\tGET16(authority);\n\tGET16(additional);\n\t(void) authority; /* suppress \"unused variable\" warnings. */\n\t(void) additional; /* suppress \"unused variable\" warnings. */\n\n\treq = request_find_from_trans_id(base, trans_id);\n\tif (!req) return -1;\n\tEVUTIL_ASSERT(req->base == base);\n\n\tmemset(&reply, 0, sizeof(reply));\n\n\t/* If it's not an answer, it doesn't correspond to any request. */\n\tif (!(flags & 0x8000)) return -1;  /* must be an answer */\n\tif ((flags & 0x020f) && (flags & 0x020f) != DNS_ERR_NOTEXIST) {\n\t\t/* there was an error and it's not NXDOMAIN */\n\t\tgoto err;\n\t}\n\t/* if (!answers) return; */  /* must have an answer of some form */\n\n\t/* This macro skips a name in the DNS reply. */\n#define SKIP_NAME\t\t\t\t\t\t\\\n\tdo { tmp_name[0] = '\\0';\t\t\t\t\\\n\t\tif (name_parse(packet, length, &j, tmp_name,\t\\\n\t\t\tsizeof(tmp_name))<0)\t\t\t\\\n\t\t\tgoto err;\t\t\t\t\\\n\t} while (0)\n\n\treply.type = req->request_type;\n\n\t/* skip over each question in the reply */\n\tfor (i = 0; i < questions; ++i) {\n\t\t/* the question looks like\n\t\t *   <label:name><u16:type><u16:class>\n\t\t */\n\t\ttmp_name[0] = '\\0';\n\t\tcmp_name[0] = '\\0';\n\t\tk = j;\n\t\tif (name_parse(packet, length, &j, tmp_name, sizeof(tmp_name)) < 0)\n\t\t\tgoto err;\n\t\tif (name_parse(req->request, req->request_len, &k,\n\t\t\tcmp_name, sizeof(cmp_name))<0)\n\t\t\tgoto err;\n\t\tif (!base->global_randomize_case) {\n\t\t\tif (strcmp(tmp_name, cmp_name) == 0)\n\t\t\t\tname_matches = 1;\n\t\t} else {\n\t\t\tif (evutil_ascii_strcasecmp(tmp_name, cmp_name) == 0)\n\t\t\t\tname_matches = 1;\n\t\t}\n\n\t\tj += 4;\n\t\tif (j > length)\n\t\t\tgoto err;\n\t}\n\n\tif (!name_matches)\n\t\tgoto err;\n\n\t/* now we have the answer section which looks like\n\t * <label:name><u16:type><u16:class><u32:ttl><u16:len><data...>\n\t */\n\n\tfor (i = 0; i < answers; ++i) {\n\t\tu16 type, class;\n\n\t\tSKIP_NAME;\n\t\tGET16(type);\n\t\tGET16(class);\n\t\tGET32(ttl);\n\t\tGET16(datalength);\n\n\t\tif (type == TYPE_A && class == CLASS_INET) {\n\t\t\tint addrcount, addrtocopy;\n\t\t\tif (req->request_type != TYPE_A) {\n\t\t\t\tj += datalength; continue;\n\t\t\t}\n\t\t\tif ((datalength & 3) != 0) /* not an even number of As. */\n\t\t\t    goto err;\n\t\t\taddrcount = datalength >> 2;\n\t\t\taddrtocopy = MIN(MAX_V4_ADDRS - reply.data.a.addrcount, (unsigned)addrcount);\n\n\t\t\tttl_r = MIN(ttl_r, ttl);\n\t\t\t/* we only bother with the first four addresses. */\n\t\t\tif (j + 4*addrtocopy > length) goto err;\n\t\t\tmemcpy(&reply.data.a.addresses[reply.data.a.addrcount],\n\t\t\t\t   packet + j, 4*addrtocopy);\n\t\t\tj += 4*addrtocopy;\n\t\t\treply.data.a.addrcount += addrtocopy;\n\t\t\treply.have_answer = 1;\n\t\t\tif (reply.data.a.addrcount == MAX_V4_ADDRS) break;\n\t\t} else if (type == TYPE_PTR && class == CLASS_INET) {\n\t\t\tif (req->request_type != TYPE_PTR) {\n\t\t\t\tj += datalength; continue;\n\t\t\t}\n\t\t\tif (name_parse(packet, length, &j, reply.data.ptr.name,\n\t\t\t\t\t\t   sizeof(reply.data.ptr.name))<0)\n\t\t\t\tgoto err;\n\t\t\tttl_r = MIN(ttl_r, ttl);\n\t\t\treply.have_answer = 1;\n\t\t\tbreak;\n\t\t} else if (type == TYPE_CNAME) {\n\t\t\tchar cname[HOST_NAME_MAX];\n\t\t\tif (!req->put_cname_in_ptr || *req->put_cname_in_ptr) {\n\t\t\t\tj += datalength; continue;\n\t\t\t}\n\t\t\tif (name_parse(packet, length, &j, cname,\n\t\t\t\tsizeof(cname))<0)\n\t\t\t\tgoto err;\n\t\t\t*req->put_cname_in_ptr = mm_strdup(cname);\n\t\t} else if (type == TYPE_AAAA && class == CLASS_INET) {\n\t\t\tint addrcount, addrtocopy;\n\t\t\tif (req->request_type != TYPE_AAAA) {\n\t\t\t\tj += datalength; continue;\n\t\t\t}\n\t\t\tif ((datalength & 15) != 0) /* not an even number of AAAAs. */\n\t\t\t\tgoto err;\n\t\t\taddrcount = datalength >> 4;  /* each address is 16 bytes long */\n\t\t\taddrtocopy = MIN(MAX_V6_ADDRS - reply.data.aaaa.addrcount, (unsigned)addrcount);\n\t\t\tttl_r = MIN(ttl_r, ttl);\n\n\t\t\t/* we only bother with the first four addresses. */\n\t\t\tif (j + 16*addrtocopy > length) goto err;\n\t\t\tmemcpy(&reply.data.aaaa.addresses[reply.data.aaaa.addrcount],\n\t\t\t\t   packet + j, 16*addrtocopy);\n\t\t\treply.data.aaaa.addrcount += addrtocopy;\n\t\t\tj += 16*addrtocopy;\n\t\t\treply.have_answer = 1;\n\t\t\tif (reply.data.aaaa.addrcount == MAX_V6_ADDRS) break;\n\t\t} else {\n\t\t\t/* skip over any other type of resource */\n\t\t\tj += datalength;\n\t\t}\n\t}\n\n\tif (!reply.have_answer) {\n\t\tfor (i = 0; i < authority; ++i) {\n\t\t\tu16 type, class;\n\t\t\tSKIP_NAME;\n\t\t\tGET16(type);\n\t\t\tGET16(class);\n\t\t\tGET32(ttl);\n\t\t\tGET16(datalength);\n\t\t\tif (type == TYPE_SOA && class == CLASS_INET) {\n\t\t\t\tu32 serial, refresh, retry, expire, minimum;\n\t\t\t\tSKIP_NAME;\n\t\t\t\tSKIP_NAME;\n\t\t\t\tGET32(serial);\n\t\t\t\tGET32(refresh);\n\t\t\t\tGET32(retry);\n\t\t\t\tGET32(expire);\n\t\t\t\tGET32(minimum);\n\t\t\t\t(void)expire;\n\t\t\t\t(void)retry;\n\t\t\t\t(void)refresh;\n\t\t\t\t(void)serial;\n\t\t\t\tttl_r = MIN(ttl_r, ttl);\n\t\t\t\tttl_r = MIN(ttl_r, minimum);\n\t\t\t} else {\n\t\t\t\t/* skip over any other type of resource */\n\t\t\t\tj += datalength;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ttl_r == 0xffffffff)\n\t\tttl_r = 0;\n\n\treply_handle(req, flags, ttl_r, &reply);\n\treturn 0;\n err:\n\tif (req)\n\t\treply_handle(req, flags, 0, NULL);\n\treturn -1;\n}\n\n/* Parse a raw request (packet,length) sent to a nameserver port (port) from */\n/* a DNS client (addr,addrlen), and if it's well-formed, call the corresponding */\n/* callback. */\nstatic int\nrequest_parse(u8 *packet, int length, struct evdns_server_port *port, struct sockaddr *addr, ev_socklen_t addrlen)\n{\n\tint j = 0;\t/* index into packet */\n\tu16 t_;\t /* used by the macros */\n\tchar tmp_name[256]; /* used by the macros */\n\n\tint i;\n\tu16 trans_id, flags, questions, answers, authority, additional;\n\tstruct server_request *server_req = NULL;\n\n\tASSERT_LOCKED(port);\n\n\t/* Get the header fields */\n\tGET16(trans_id);\n\tGET16(flags);\n\tGET16(questions);\n\tGET16(answers);\n\tGET16(authority);\n\tGET16(additional);\n\t(void)answers;\n\t(void)additional;\n\t(void)authority;\n\n\tif (flags & 0x8000) return -1; /* Must not be an answer. */\n\tflags &= 0x0110; /* Only RD and CD get preserved. */\n\n\tserver_req = mm_malloc(sizeof(struct server_request));\n\tif (server_req == NULL) return -1;\n\tmemset(server_req, 0, sizeof(struct server_request));\n\n\tserver_req->trans_id = trans_id;\n\tmemcpy(&server_req->addr, addr, addrlen);\n\tserver_req->addrlen = addrlen;\n\n\tserver_req->base.flags = flags;\n\tserver_req->base.nquestions = 0;\n\tserver_req->base.questions = mm_calloc(sizeof(struct evdns_server_question *), questions);\n\tif (server_req->base.questions == NULL)\n\t\tgoto err;\n\n\tfor (i = 0; i < questions; ++i) {\n\t\tu16 type, class;\n\t\tstruct evdns_server_question *q;\n\t\tint namelen;\n\t\tif (name_parse(packet, length, &j, tmp_name, sizeof(tmp_name))<0)\n\t\t\tgoto err;\n\t\tGET16(type);\n\t\tGET16(class);\n\t\tnamelen = (int)strlen(tmp_name);\n\t\tq = mm_malloc(sizeof(struct evdns_server_question) + namelen);\n\t\tif (!q)\n\t\t\tgoto err;\n\t\tq->type = type;\n\t\tq->dns_question_class = class;\n\t\tmemcpy(q->name, tmp_name, namelen+1);\n\t\tserver_req->base.questions[server_req->base.nquestions++] = q;\n\t}\n\n\t/* Ignore answers, authority, and additional. */\n\n\tserver_req->port = port;\n\tport->refcnt++;\n\n\t/* Only standard queries are supported. */\n\tif (flags & 0x7800) {\n\t\tevdns_server_request_respond(&(server_req->base), DNS_ERR_NOTIMPL);\n\t\treturn -1;\n\t}\n\n\tport->user_callback(&(server_req->base), port->user_data);\n\n\treturn 0;\nerr:\n\tif (server_req) {\n\t\tif (server_req->base.questions) {\n\t\t\tfor (i = 0; i < server_req->base.nquestions; ++i)\n\t\t\t\tmm_free(server_req->base.questions[i]);\n\t\t\tmm_free(server_req->base.questions);\n\t\t}\n\t\tmm_free(server_req);\n\t}\n\treturn -1;\n\n#undef SKIP_NAME\n#undef GET32\n#undef GET16\n#undef GET8\n}\n\n\nvoid\nevdns_set_transaction_id_fn(ev_uint16_t (*fn)(void))\n{\n}\n\nvoid\nevdns_set_random_bytes_fn(void (*fn)(char *, size_t))\n{\n}\n\n/* Try to choose a strong transaction id which isn't already in flight */\nstatic u16\ntransaction_id_pick(struct evdns_base *base) {\n\tASSERT_LOCKED(base);\n\tfor (;;) {\n\t\tu16 trans_id;\n\t\tevutil_secure_rng_get_bytes(&trans_id, sizeof(trans_id));\n\n\t\tif (trans_id == 0xffff) continue;\n\t\t/* now check to see if that id is already inflight */\n\t\tif (request_find_from_trans_id(base, trans_id) == NULL)\n\t\t\treturn trans_id;\n\t}\n}\n\n/* choose a namesever to use. This function will try to ignore */\n/* nameservers which we think are down and load balance across the rest */\n/* by updating the server_head global each time. */\nstatic struct nameserver *\nnameserver_pick(struct evdns_base *base) {\n\tstruct nameserver *started_at = base->server_head, *picked;\n\tASSERT_LOCKED(base);\n\tif (!base->server_head) return NULL;\n\n\t/* if we don't have any good nameservers then there's no */\n\t/* point in trying to find one. */\n\tif (!base->global_good_nameservers) {\n\t\tbase->server_head = base->server_head->next;\n\t\treturn base->server_head;\n\t}\n\n\t/* remember that nameservers are in a circular list */\n\tfor (;;) {\n\t\tif (base->server_head->state) {\n\t\t\t/* we think this server is currently good */\n\t\t\tpicked = base->server_head;\n\t\t\tbase->server_head = base->server_head->next;\n\t\t\treturn picked;\n\t\t}\n\n\t\tbase->server_head = base->server_head->next;\n\t\tif (base->server_head == started_at) {\n\t\t\t/* all the nameservers seem to be down */\n\t\t\t/* so we just return this one and hope for the */\n\t\t\t/* best */\n\t\t\tEVUTIL_ASSERT(base->global_good_nameservers == 0);\n\t\t\tpicked = base->server_head;\n\t\t\tbase->server_head = base->server_head->next;\n\t\t\treturn picked;\n\t\t}\n\t}\n}\n\n/* this is called when a namesever socket is ready for reading */\nstatic void\nnameserver_read(struct nameserver *ns) {\n\tstruct sockaddr_storage ss;\n\tev_socklen_t addrlen = sizeof(ss);\n\tu8 packet[1500];\n\tchar addrbuf[128];\n\tASSERT_LOCKED(ns->base);\n\n\tfor (;;) {\n\t\tconst int r = recvfrom(ns->socket, (void*)packet,\n\t\t    sizeof(packet), 0,\n\t\t    (struct sockaddr*)&ss, &addrlen);\n\t\tif (r < 0) {\n\t\t\tint err = evutil_socket_geterror(ns->socket);\n\t\t\tif (EVUTIL_ERR_RW_RETRIABLE(err))\n\t\t\t\treturn;\n\t\t\tnameserver_failed(ns,\n\t\t\t    evutil_socket_error_to_string(err));\n\t\t\treturn;\n\t\t}\n\t\tif (evutil_sockaddr_cmp((struct sockaddr*)&ss,\n\t\t\t(struct sockaddr*)&ns->address, 0)) {\n\t\t\tlog(EVDNS_LOG_WARN, \"Address mismatch on received \"\n\t\t\t    \"DNS packet.  Apparent source was %s\",\n\t\t\t    evutil_format_sockaddr_port_(\n\t\t\t\t    (struct sockaddr *)&ss,\n\t\t\t\t    addrbuf, sizeof(addrbuf)));\n\t\t\treturn;\n\t\t}\n\n\t\tns->timedout = 0;\n\t\treply_parse(ns->base, packet, r);\n\t}\n}\n\n/* Read a packet from a DNS client on a server port s, parse it, and */\n/* act accordingly. */\nstatic void\nserver_port_read(struct evdns_server_port *s) {\n\tu8 packet[1500];\n\tstruct sockaddr_storage addr;\n\tev_socklen_t addrlen;\n\tint r;\n\tASSERT_LOCKED(s);\n\n\tfor (;;) {\n\t\taddrlen = sizeof(struct sockaddr_storage);\n\t\tr = recvfrom(s->socket, (void*)packet, sizeof(packet), 0,\n\t\t\t\t\t (struct sockaddr*) &addr, &addrlen);\n\t\tif (r < 0) {\n\t\t\tint err = evutil_socket_geterror(s->socket);\n\t\t\tif (EVUTIL_ERR_RW_RETRIABLE(err))\n\t\t\t\treturn;\n\t\t\tlog(EVDNS_LOG_WARN,\n\t\t\t    \"Error %s (%d) while reading request.\",\n\t\t\t    evutil_socket_error_to_string(err), err);\n\t\t\treturn;\n\t\t}\n\t\trequest_parse(packet, r, s, (struct sockaddr*) &addr, addrlen);\n\t}\n}\n\n/* Try to write all pending replies on a given DNS server port. */\nstatic void\nserver_port_flush(struct evdns_server_port *port)\n{\n\tstruct server_request *req = port->pending_replies;\n\tASSERT_LOCKED(port);\n\twhile (req) {\n\t\tint r = sendto(port->socket, req->response, (int)req->response_len, 0,\n\t\t\t   (struct sockaddr*) &req->addr, (ev_socklen_t)req->addrlen);\n\t\tif (r < 0) {\n\t\t\tint err = evutil_socket_geterror(port->socket);\n\t\t\tif (EVUTIL_ERR_RW_RETRIABLE(err))\n\t\t\t\treturn;\n\t\t\tlog(EVDNS_LOG_WARN, \"Error %s (%d) while writing response to port; dropping\", evutil_socket_error_to_string(err), err);\n\t\t}\n\t\tif (server_request_free(req)) {\n\t\t\t/* we released the last reference to req->port. */\n\t\t\treturn;\n\t\t} else {\n\t\t\tEVUTIL_ASSERT(req != port->pending_replies);\n\t\t\treq = port->pending_replies;\n\t\t}\n\t}\n\n\t/* We have no more pending requests; stop listening for 'writeable' events. */\n\t(void) event_del(&port->event);\n\tevent_assign(&port->event, port->event_base,\n\t\t\t\t port->socket, EV_READ | EV_PERSIST,\n\t\t\t\t server_port_ready_callback, port);\n\n\tif (event_add(&port->event, NULL) < 0) {\n\t\tlog(EVDNS_LOG_WARN, \"Error from libevent when adding event for DNS server.\");\n\t\t/* ???? Do more? */\n\t}\n}\n\n/* set if we are waiting for the ability to write to this server. */\n/* if waiting is true then we ask libevent for EV_WRITE events, otherwise */\n/* we stop these events. */\nstatic void\nnameserver_write_waiting(struct nameserver *ns, char waiting) {\n\tASSERT_LOCKED(ns->base);\n\tif (ns->write_waiting == waiting) return;\n\n\tns->write_waiting = waiting;\n\t(void) event_del(&ns->event);\n\tevent_assign(&ns->event, ns->base->event_base,\n\t    ns->socket, EV_READ | (waiting ? EV_WRITE : 0) | EV_PERSIST,\n\t    nameserver_ready_callback, ns);\n\tif (event_add(&ns->event, NULL) < 0) {\n\t\tchar addrbuf[128];\n\t\tlog(EVDNS_LOG_WARN, \"Error from libevent when adding event for %s\",\n\t\t    evutil_format_sockaddr_port_(\n\t\t\t    (struct sockaddr *)&ns->address,\n\t\t\t    addrbuf, sizeof(addrbuf)));\n\t\t/* ???? Do more? */\n\t}\n}\n\n/* a callback function. Called by libevent when the kernel says that */\n/* a nameserver socket is ready for writing or reading */\nstatic void\nnameserver_ready_callback(evutil_socket_t fd, short events, void *arg) {\n\tstruct nameserver *ns = (struct nameserver *) arg;\n\t(void)fd;\n\n\tEVDNS_LOCK(ns->base);\n\tif (events & EV_WRITE) {\n\t\tns->choked = 0;\n\t\tif (!evdns_transmit(ns->base)) {\n\t\t\tnameserver_write_waiting(ns, 0);\n\t\t}\n\t}\n\tif (events & EV_READ) {\n\t\tnameserver_read(ns);\n\t}\n\tEVDNS_UNLOCK(ns->base);\n}\n\n/* a callback function. Called by libevent when the kernel says that */\n/* a server socket is ready for writing or reading. */\nstatic void\nserver_port_ready_callback(evutil_socket_t fd, short events, void *arg) {\n\tstruct evdns_server_port *port = (struct evdns_server_port *) arg;\n\t(void) fd;\n\n\tEVDNS_LOCK(port);\n\tif (events & EV_WRITE) {\n\t\tport->choked = 0;\n\t\tserver_port_flush(port);\n\t}\n\tif (events & EV_READ) {\n\t\tserver_port_read(port);\n\t}\n\tEVDNS_UNLOCK(port);\n}\n\n/* This is an inefficient representation; only use it via the dnslabel_table_*\n * functions, so that is can be safely replaced with something smarter later. */\n#define MAX_LABELS 128\n/* Structures used to implement name compression */\nstruct dnslabel_entry { char *v; off_t pos; };\nstruct dnslabel_table {\n\tint n_labels; /* number of current entries */\n\t/* map from name to position in message */\n\tstruct dnslabel_entry labels[MAX_LABELS];\n};\n\n/* Initialize dnslabel_table. */\nstatic void\ndnslabel_table_init(struct dnslabel_table *table)\n{\n\ttable->n_labels = 0;\n}\n\n/* Free all storage held by table, but not the table itself. */\nstatic void\ndnslabel_clear(struct dnslabel_table *table)\n{\n\tint i;\n\tfor (i = 0; i < table->n_labels; ++i)\n\t\tmm_free(table->labels[i].v);\n\ttable->n_labels = 0;\n}\n\n/* return the position of the label in the current message, or -1 if the label */\n/* hasn't been used yet. */\nstatic int\ndnslabel_table_get_pos(const struct dnslabel_table *table, const char *label)\n{\n\tint i;\n\tfor (i = 0; i < table->n_labels; ++i) {\n\t\tif (!strcmp(label, table->labels[i].v))\n\t\t\treturn table->labels[i].pos;\n\t}\n\treturn -1;\n}\n\n/* remember that we've used the label at position pos */\nstatic int\ndnslabel_table_add(struct dnslabel_table *table, const char *label, off_t pos)\n{\n\tchar *v;\n\tint p;\n\tif (table->n_labels == MAX_LABELS)\n\t\treturn (-1);\n\tv = mm_strdup(label);\n\tif (v == NULL)\n\t\treturn (-1);\n\tp = table->n_labels++;\n\ttable->labels[p].v = v;\n\ttable->labels[p].pos = pos;\n\n\treturn (0);\n}\n\n/* Converts a string to a length-prefixed set of DNS labels, starting */\n/* at buf[j]. name and buf must not overlap. name_len should be the length */\n/* of name.\t table is optional, and is used for compression. */\n/* */\n/* Input: abc.def */\n/* Output: <3>abc<3>def<0> */\n/* */\n/* Returns the first index after the encoded name, or negative on error. */\n/*\t -1\t label was > 63 bytes */\n/*\t -2\t name too long to fit in buffer. */\n/* */\nstatic off_t\ndnsname_to_labels(u8 *const buf, size_t buf_len, off_t j,\n\t\t\t\t  const char *name, const size_t name_len,\n\t\t\t\t  struct dnslabel_table *table) {\n\tconst char *end = name + name_len;\n\tint ref = 0;\n\tu16 t_;\n\n#define APPEND16(x) do {\t\t\t\t\t\t\\\n\t\tif (j + 2 > (off_t)buf_len)\t\t\t\t\\\n\t\t\tgoto overflow;\t\t\t\t\t\\\n\t\tt_ = htons(x);\t\t\t\t\t\t\\\n\t\tmemcpy(buf + j, &t_, 2);\t\t\t\t\\\n\t\tj += 2;\t\t\t\t\t\t\t\\\n\t} while (0)\n#define APPEND32(x) do {\t\t\t\t\t\t\\\n\t\tif (j + 4 > (off_t)buf_len)\t\t\t\t\\\n\t\t\tgoto overflow;\t\t\t\t\t\\\n\t\tt32_ = htonl(x);\t\t\t\t\t\\\n\t\tmemcpy(buf + j, &t32_, 4);\t\t\t\t\\\n\t\tj += 4;\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\tif (name_len > 255) return -2;\n\n\tfor (;;) {\n\t\tconst char *const start = name;\n\t\tif (table && (ref = dnslabel_table_get_pos(table, name)) >= 0) {\n\t\t\tAPPEND16(ref | 0xc000);\n\t\t\treturn j;\n\t\t}\n\t\tname = strchr(name, '.');\n\t\tif (!name) {\n\t\t\tconst size_t label_len = end - start;\n\t\t\tif (label_len > 63) return -1;\n\t\t\tif ((size_t)(j+label_len+1) > buf_len) return -2;\n\t\t\tif (table) dnslabel_table_add(table, start, j);\n\t\t\tbuf[j++] = (ev_uint8_t)label_len;\n\n\t\t\tmemcpy(buf + j, start, label_len);\n\t\t\tj += (int) label_len;\n\t\t\tbreak;\n\t\t} else {\n\t\t\t/* append length of the label. */\n\t\t\tconst size_t label_len = name - start;\n\t\t\tif (label_len > 63) return -1;\n\t\t\tif ((size_t)(j+label_len+1) > buf_len) return -2;\n\t\t\tif (table) dnslabel_table_add(table, start, j);\n\t\t\tbuf[j++] = (ev_uint8_t)label_len;\n\n\t\t\tmemcpy(buf + j, start, label_len);\n\t\t\tj += (int) label_len;\n\t\t\t/* hop over the '.' */\n\t\t\tname++;\n\t\t}\n\t}\n\n\t/* the labels must be terminated by a 0. */\n\t/* It's possible that the name ended in a . */\n\t/* in which case the zero is already there */\n\tif (!j || buf[j-1]) buf[j++] = 0;\n\treturn j;\n overflow:\n\treturn (-2);\n}\n\n/* Finds the length of a dns request for a DNS name of the given */\n/* length. The actual request may be smaller than the value returned */\n/* here */\nstatic size_t\nevdns_request_len(const size_t name_len) {\n\treturn 96 + /* length of the DNS standard header */\n\t\tname_len + 2 +\n\t\t4;  /* space for the resource type */\n}\n\n/* build a dns request packet into buf. buf should be at least as long */\n/* as evdns_request_len told you it should be. */\n/* */\n/* Returns the amount of space used. Negative on error. */\nstatic int\nevdns_request_data_build(const char *const name, const size_t name_len,\n    const u16 trans_id, const u16 type, const u16 class,\n    u8 *const buf, size_t buf_len) {\n\toff_t j = 0;  /* current offset into buf */\n\tu16 t_;\t /* used by the macros */\n\n\tAPPEND16(trans_id);\n\tAPPEND16(0x0100);  /* standard query, recusion needed */\n\tAPPEND16(1);  /* one question */\n\tAPPEND16(0);  /* no answers */\n\tAPPEND16(0);  /* no authority */\n\tAPPEND16(0);  /* no additional */\n\n\tj = dnsname_to_labels(buf, buf_len, j, name, name_len, NULL);\n\tif (j < 0) {\n\t\treturn (int)j;\n\t}\n\n\tAPPEND16(type);\n\tAPPEND16(class);\n\n\treturn (int)j;\n overflow:\n\treturn (-1);\n}\n\n/* exported function */\nstruct evdns_server_port *\nevdns_add_server_port_with_base(struct event_base *base, evutil_socket_t socket, int flags, evdns_request_callback_fn_type cb, void *user_data)\n{\n\tstruct evdns_server_port *port;\n\tif (flags)\n\t\treturn NULL; /* flags not yet implemented */\n\tif (!(port = mm_malloc(sizeof(struct evdns_server_port))))\n\t\treturn NULL;\n\tmemset(port, 0, sizeof(struct evdns_server_port));\n\n\n\tport->socket = socket;\n\tport->refcnt = 1;\n\tport->choked = 0;\n\tport->closing = 0;\n\tport->user_callback = cb;\n\tport->user_data = user_data;\n\tport->pending_replies = NULL;\n\tport->event_base = base;\n\n\tevent_assign(&port->event, port->event_base,\n\t\t\t\t port->socket, EV_READ | EV_PERSIST,\n\t\t\t\t server_port_ready_callback, port);\n\tif (event_add(&port->event, NULL) < 0) {\n\t\tmm_free(port);\n\t\treturn NULL;\n\t}\n\tEVTHREAD_ALLOC_LOCK(port->lock, EVTHREAD_LOCKTYPE_RECURSIVE);\n\treturn port;\n}\n\nstruct evdns_server_port *\nevdns_add_server_port(evutil_socket_t socket, int flags, evdns_request_callback_fn_type cb, void *user_data)\n{\n\treturn evdns_add_server_port_with_base(NULL, socket, flags, cb, user_data);\n}\n\n/* exported function */\nvoid\nevdns_close_server_port(struct evdns_server_port *port)\n{\n\tEVDNS_LOCK(port);\n\tif (--port->refcnt == 0) {\n\t\tEVDNS_UNLOCK(port);\n\t\tserver_port_free(port);\n\t} else {\n\t\tport->closing = 1;\n\t}\n}\n\n/* exported function */\nint\nevdns_server_request_add_reply(struct evdns_server_request *req_, int section, const char *name, int type, int class, int ttl, int datalen, int is_name, const char *data)\n{\n\tstruct server_request *req = TO_SERVER_REQUEST(req_);\n\tstruct server_reply_item **itemp, *item;\n\tint *countp;\n\tint result = -1;\n\n\tEVDNS_LOCK(req->port);\n\tif (req->response) /* have we already answered? */\n\t\tgoto done;\n\n\tswitch (section) {\n\tcase EVDNS_ANSWER_SECTION:\n\t\titemp = &req->answer;\n\t\tcountp = &req->n_answer;\n\t\tbreak;\n\tcase EVDNS_AUTHORITY_SECTION:\n\t\titemp = &req->authority;\n\t\tcountp = &req->n_authority;\n\t\tbreak;\n\tcase EVDNS_ADDITIONAL_SECTION:\n\t\titemp = &req->additional;\n\t\tcountp = &req->n_additional;\n\t\tbreak;\n\tdefault:\n\t\tgoto done;\n\t}\n\twhile (*itemp) {\n\t\titemp = &((*itemp)->next);\n\t}\n\titem = mm_malloc(sizeof(struct server_reply_item));\n\tif (!item)\n\t\tgoto done;\n\titem->next = NULL;\n\tif (!(item->name = mm_strdup(name))) {\n\t\tmm_free(item);\n\t\tgoto done;\n\t}\n\titem->type = type;\n\titem->dns_question_class = class;\n\titem->ttl = ttl;\n\titem->is_name = is_name != 0;\n\titem->datalen = 0;\n\titem->data = NULL;\n\tif (data) {\n\t\tif (item->is_name) {\n\t\t\tif (!(item->data = mm_strdup(data))) {\n\t\t\t\tmm_free(item->name);\n\t\t\t\tmm_free(item);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\titem->datalen = (u16)-1;\n\t\t} else {\n\t\t\tif (!(item->data = mm_malloc(datalen))) {\n\t\t\t\tmm_free(item->name);\n\t\t\t\tmm_free(item);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\titem->datalen = datalen;\n\t\t\tmemcpy(item->data, data, datalen);\n\t\t}\n\t}\n\n\t*itemp = item;\n\t++(*countp);\n\tresult = 0;\ndone:\n\tEVDNS_UNLOCK(req->port);\n\treturn result;\n}\n\n/* exported function */\nint\nevdns_server_request_add_a_reply(struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl)\n{\n\treturn evdns_server_request_add_reply(\n\t\t  req, EVDNS_ANSWER_SECTION, name, TYPE_A, CLASS_INET,\n\t\t  ttl, n*4, 0, addrs);\n}\n\n/* exported function */\nint\nevdns_server_request_add_aaaa_reply(struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl)\n{\n\treturn evdns_server_request_add_reply(\n\t\t  req, EVDNS_ANSWER_SECTION, name, TYPE_AAAA, CLASS_INET,\n\t\t  ttl, n*16, 0, addrs);\n}\n\n/* exported function */\nint\nevdns_server_request_add_ptr_reply(struct evdns_server_request *req, struct in_addr *in, const char *inaddr_name, const char *hostname, int ttl)\n{\n\tu32 a;\n\tchar buf[32];\n\tif (in && inaddr_name)\n\t\treturn -1;\n\telse if (!in && !inaddr_name)\n\t\treturn -1;\n\tif (in) {\n\t\ta = ntohl(in->s_addr);\n\t\tevutil_snprintf(buf, sizeof(buf), \"%d.%d.%d.%d.in-addr.arpa\",\n\t\t\t\t(int)(u8)((a\t)&0xff),\n\t\t\t\t(int)(u8)((a>>8 )&0xff),\n\t\t\t\t(int)(u8)((a>>16)&0xff),\n\t\t\t\t(int)(u8)((a>>24)&0xff));\n\t\tinaddr_name = buf;\n\t}\n\treturn evdns_server_request_add_reply(\n\t\t  req, EVDNS_ANSWER_SECTION, inaddr_name, TYPE_PTR, CLASS_INET,\n\t\t  ttl, -1, 1, hostname);\n}\n\n/* exported function */\nint\nevdns_server_request_add_cname_reply(struct evdns_server_request *req, const char *name, const char *cname, int ttl)\n{\n\treturn evdns_server_request_add_reply(\n\t\t  req, EVDNS_ANSWER_SECTION, name, TYPE_CNAME, CLASS_INET,\n\t\t  ttl, -1, 1, cname);\n}\n\n/* exported function */\nvoid\nevdns_server_request_set_flags(struct evdns_server_request *exreq, int flags)\n{\n\tstruct server_request *req = TO_SERVER_REQUEST(exreq);\n\treq->base.flags &= ~(EVDNS_FLAGS_AA|EVDNS_FLAGS_RD);\n\treq->base.flags |= flags;\n}\n\nstatic int\nevdns_server_request_format_response(struct server_request *req, int err)\n{\n\tunsigned char buf[1500];\n\tsize_t buf_len = sizeof(buf);\n\toff_t j = 0, r;\n\tu16 t_;\n\tu32 t32_;\n\tint i;\n\tu16 flags;\n\tstruct dnslabel_table table;\n\n\tif (err < 0 || err > 15) return -1;\n\n\t/* Set response bit and error code; copy OPCODE and RD fields from\n\t * question; copy RA and AA if set by caller. */\n\tflags = req->base.flags;\n\tflags |= (0x8000 | err);\n\n\tdnslabel_table_init(&table);\n\tAPPEND16(req->trans_id);\n\tAPPEND16(flags);\n\tAPPEND16(req->base.nquestions);\n\tAPPEND16(req->n_answer);\n\tAPPEND16(req->n_authority);\n\tAPPEND16(req->n_additional);\n\n\t/* Add questions. */\n\tfor (i=0; i < req->base.nquestions; ++i) {\n\t\tconst char *s = req->base.questions[i]->name;\n\t\tj = dnsname_to_labels(buf, buf_len, j, s, strlen(s), &table);\n\t\tif (j < 0) {\n\t\t\tdnslabel_clear(&table);\n\t\t\treturn (int) j;\n\t\t}\n\t\tAPPEND16(req->base.questions[i]->type);\n\t\tAPPEND16(req->base.questions[i]->dns_question_class);\n\t}\n\n\t/* Add answer, authority, and additional sections. */\n\tfor (i=0; i<3; ++i) {\n\t\tstruct server_reply_item *item;\n\t\tif (i==0)\n\t\t\titem = req->answer;\n\t\telse if (i==1)\n\t\t\titem = req->authority;\n\t\telse\n\t\t\titem = req->additional;\n\t\twhile (item) {\n\t\t\tr = dnsname_to_labels(buf, buf_len, j, item->name, strlen(item->name), &table);\n\t\t\tif (r < 0)\n\t\t\t\tgoto overflow;\n\t\t\tj = r;\n\n\t\t\tAPPEND16(item->type);\n\t\t\tAPPEND16(item->dns_question_class);\n\t\t\tAPPEND32(item->ttl);\n\t\t\tif (item->is_name) {\n\t\t\t\toff_t len_idx = j, name_start;\n\t\t\t\tj += 2;\n\t\t\t\tname_start = j;\n\t\t\t\tr = dnsname_to_labels(buf, buf_len, j, item->data, strlen(item->data), &table);\n\t\t\t\tif (r < 0)\n\t\t\t\t\tgoto overflow;\n\t\t\t\tj = r;\n\t\t\t\tt_ = htons( (short) (j-name_start) );\n\t\t\t\tmemcpy(buf+len_idx, &t_, 2);\n\t\t\t} else {\n\t\t\t\tAPPEND16(item->datalen);\n\t\t\t\tif (j+item->datalen > (off_t)buf_len)\n\t\t\t\t\tgoto overflow;\n\t\t\t\tmemcpy(buf+j, item->data, item->datalen);\n\t\t\t\tj += item->datalen;\n\t\t\t}\n\t\t\titem = item->next;\n\t\t}\n\t}\n\n\tif (j > 512) {\noverflow:\n\t\tj = 512;\n\t\tbuf[2] |= 0x02; /* set the truncated bit. */\n\t}\n\n\treq->response_len = j;\n\n\tif (!(req->response = mm_malloc(req->response_len))) {\n\t\tserver_request_free_answers(req);\n\t\tdnslabel_clear(&table);\n\t\treturn (-1);\n\t}\n\tmemcpy(req->response, buf, req->response_len);\n\tserver_request_free_answers(req);\n\tdnslabel_clear(&table);\n\treturn (0);\n}\n\n/* exported function */\nint\nevdns_server_request_respond(struct evdns_server_request *req_, int err)\n{\n\tstruct server_request *req = TO_SERVER_REQUEST(req_);\n\tstruct evdns_server_port *port = req->port;\n\tint r = -1;\n\n\tEVDNS_LOCK(port);\n\tif (!req->response) {\n\t\tif ((r = evdns_server_request_format_response(req, err))<0)\n\t\t\tgoto done;\n\t}\n\n\tr = sendto(port->socket, req->response, (int)req->response_len, 0,\n\t\t\t   (struct sockaddr*) &req->addr, (ev_socklen_t)req->addrlen);\n\tif (r<0) {\n\t\tint sock_err = evutil_socket_geterror(port->socket);\n\t\tif (EVUTIL_ERR_RW_RETRIABLE(sock_err))\n\t\t\tgoto done;\n\n\t\tif (port->pending_replies) {\n\t\t\treq->prev_pending = port->pending_replies->prev_pending;\n\t\t\treq->next_pending = port->pending_replies;\n\t\t\treq->prev_pending->next_pending =\n\t\t\t\treq->next_pending->prev_pending = req;\n\t\t} else {\n\t\t\treq->prev_pending = req->next_pending = req;\n\t\t\tport->pending_replies = req;\n\t\t\tport->choked = 1;\n\n\t\t\t(void) event_del(&port->event);\n\t\t\tevent_assign(&port->event, port->event_base, port->socket, (port->closing?0:EV_READ) | EV_WRITE | EV_PERSIST, server_port_ready_callback, port);\n\n\t\t\tif (event_add(&port->event, NULL) < 0) {\n\t\t\t\tlog(EVDNS_LOG_WARN, \"Error from libevent when adding event for DNS server\");\n\t\t\t}\n\n\t\t}\n\n\t\tr = 1;\n\t\tgoto done;\n\t}\n\tif (server_request_free(req)) {\n\t\tr = 0;\n\t\tgoto done;\n\t}\n\n\tif (port->pending_replies)\n\t\tserver_port_flush(port);\n\n\tr = 0;\ndone:\n\tEVDNS_UNLOCK(port);\n\treturn r;\n}\n\n/* Free all storage held by RRs in req. */\nstatic void\nserver_request_free_answers(struct server_request *req)\n{\n\tstruct server_reply_item *victim, *next, **list;\n\tint i;\n\tfor (i = 0; i < 3; ++i) {\n\t\tif (i==0)\n\t\t\tlist = &req->answer;\n\t\telse if (i==1)\n\t\t\tlist = &req->authority;\n\t\telse\n\t\t\tlist = &req->additional;\n\n\t\tvictim = *list;\n\t\twhile (victim) {\n\t\t\tnext = victim->next;\n\t\t\tmm_free(victim->name);\n\t\t\tif (victim->data)\n\t\t\t\tmm_free(victim->data);\n\t\t\tmm_free(victim);\n\t\t\tvictim = next;\n\t\t}\n\t\t*list = NULL;\n\t}\n}\n\n/* Free all storage held by req, and remove links to it. */\n/* return true iff we just wound up freeing the server_port. */\nstatic int\nserver_request_free(struct server_request *req)\n{\n\tint i, rc=1, lock=0;\n\tif (req->base.questions) {\n\t\tfor (i = 0; i < req->base.nquestions; ++i)\n\t\t\tmm_free(req->base.questions[i]);\n\t\tmm_free(req->base.questions);\n\t}\n\n\tif (req->port) {\n\t\tEVDNS_LOCK(req->port);\n\t\tlock=1;\n\t\tif (req->port->pending_replies == req) {\n\t\t\tif (req->next_pending && req->next_pending != req)\n\t\t\t\treq->port->pending_replies = req->next_pending;\n\t\t\telse\n\t\t\t\treq->port->pending_replies = NULL;\n\t\t}\n\t\trc = --req->port->refcnt;\n\t}\n\n\tif (req->response) {\n\t\tmm_free(req->response);\n\t}\n\n\tserver_request_free_answers(req);\n\n\tif (req->next_pending && req->next_pending != req) {\n\t\treq->next_pending->prev_pending = req->prev_pending;\n\t\treq->prev_pending->next_pending = req->next_pending;\n\t}\n\n\tif (rc == 0) {\n\t\tEVDNS_UNLOCK(req->port); /* ????? nickm */\n\t\tserver_port_free(req->port);\n\t\tmm_free(req);\n\t\treturn (1);\n\t}\n\tif (lock)\n\t\tEVDNS_UNLOCK(req->port);\n\tmm_free(req);\n\treturn (0);\n}\n\n/* Free all storage held by an evdns_server_port.  Only called when  */\nstatic void\nserver_port_free(struct evdns_server_port *port)\n{\n\tEVUTIL_ASSERT(port);\n\tEVUTIL_ASSERT(!port->refcnt);\n\tEVUTIL_ASSERT(!port->pending_replies);\n\tif (port->socket > 0) {\n\t\tevutil_closesocket(port->socket);\n\t\tport->socket = -1;\n\t}\n\t(void) event_del(&port->event);\n\tevent_debug_unassign(&port->event);\n\tEVTHREAD_FREE_LOCK(port->lock, EVTHREAD_LOCKTYPE_RECURSIVE);\n\tmm_free(port);\n}\n\n/* exported function */\nint\nevdns_server_request_drop(struct evdns_server_request *req_)\n{\n\tstruct server_request *req = TO_SERVER_REQUEST(req_);\n\tserver_request_free(req);\n\treturn 0;\n}\n\n/* exported function */\nint\nevdns_server_request_get_requesting_addr(struct evdns_server_request *req_, struct sockaddr *sa, int addr_len)\n{\n\tstruct server_request *req = TO_SERVER_REQUEST(req_);\n\tif (addr_len < (int)req->addrlen)\n\t\treturn -1;\n\tmemcpy(sa, &(req->addr), req->addrlen);\n\treturn req->addrlen;\n}\n\n#undef APPEND16\n#undef APPEND32\n\n/* this is a libevent callback function which is called when a request */\n/* has timed out. */\nstatic void\nevdns_request_timeout_callback(evutil_socket_t fd, short events, void *arg) {\n\tstruct request *const req = (struct request *) arg;\n\tstruct evdns_base *base = req->base;\n\n\t(void) fd;\n\t(void) events;\n\n\tlog(EVDNS_LOG_DEBUG, \"Request %p timed out\", arg);\n\tEVDNS_LOCK(base);\n\n\tif (req->tx_count >= req->base->global_max_retransmits) {\n\t\tstruct nameserver *ns = req->ns;\n\t\t/* this request has failed */\n\t\tlog(EVDNS_LOG_DEBUG, \"Giving up on request %p; tx_count==%d\",\n\t\t    arg, req->tx_count);\n\t\treply_schedule_callback(req, 0, DNS_ERR_TIMEOUT, NULL);\n\n\t\trequest_finished(req, &REQ_HEAD(req->base, req->trans_id), 1);\n\t\tnameserver_failed(ns, \"request timed out.\");\n\t} else {\n\t\t/* retransmit it */\n\t\tlog(EVDNS_LOG_DEBUG, \"Retransmitting request %p; tx_count==%d\",\n\t\t    arg, req->tx_count);\n\t\t(void) evtimer_del(&req->timeout_event);\n\t\trequest_swap_ns(req, nameserver_pick(base));\n\t\tevdns_request_transmit(req);\n\n\t\treq->ns->timedout++;\n\t\tif (req->ns->timedout > req->base->global_max_nameserver_timeout) {\n\t\t\treq->ns->timedout = 0;\n\t\t\tnameserver_failed(req->ns, \"request timed out.\");\n\t\t}\n\t}\n\n\tEVDNS_UNLOCK(base);\n}\n\n/* try to send a request to a given server. */\n/* */\n/* return: */\n/*   0 ok */\n/*   1 temporary failure */\n/*   2 other failure */\nstatic int\nevdns_request_transmit_to(struct request *req, struct nameserver *server) {\n\tint r;\n\tASSERT_LOCKED(req->base);\n\tASSERT_VALID_REQUEST(req);\n\n\tif (server->requests_inflight == 1 &&\n\t\treq->base->disable_when_inactive &&\n\t\tevent_add(&server->event, NULL) < 0) {\n\t\treturn 1;\n\t}\n\n\tr = sendto(server->socket, (void*)req->request, req->request_len, 0,\n\t    (struct sockaddr *)&server->address, server->addrlen);\n\tif (r < 0) {\n\t\tint err = evutil_socket_geterror(server->socket);\n\t\tif (EVUTIL_ERR_RW_RETRIABLE(err))\n\t\t\treturn 1;\n\t\tnameserver_failed(req->ns, evutil_socket_error_to_string(err));\n\t\treturn 2;\n\t} else if (r != (int)req->request_len) {\n\t\treturn 1;  /* short write */\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n/* try to send a request, updating the fields of the request */\n/* as needed */\n/* */\n/* return: */\n/*   0 ok */\n/*   1 failed */\nstatic int\nevdns_request_transmit(struct request *req) {\n\tint retcode = 0, r;\n\n\tASSERT_LOCKED(req->base);\n\tASSERT_VALID_REQUEST(req);\n\t/* if we fail to send this packet then this flag marks it */\n\t/* for evdns_transmit */\n\treq->transmit_me = 1;\n\tEVUTIL_ASSERT(req->trans_id != 0xffff);\n\n\tif (!req->ns)\n\t{\n\t\t/* unable to transmit request if no nameservers */\n\t\treturn 1;\n\t}\n\n\tif (req->ns->choked) {\n\t\t/* don't bother trying to write to a socket */\n\t\t/* which we have had EAGAIN from */\n\t\treturn 1;\n\t}\n\n\tr = evdns_request_transmit_to(req, req->ns);\n\tswitch (r) {\n\tcase 1:\n\t\t/* temp failure */\n\t\treq->ns->choked = 1;\n\t\tnameserver_write_waiting(req->ns, 1);\n\t\treturn 1;\n\tcase 2:\n\t\t/* failed to transmit the request entirely. */\n\t\tretcode = 1;\n\t\t/* fall through: we'll set a timeout, which will time out,\n\t\t * and make us retransmit the request anyway. */\n\tdefault:\n\t\t/* all ok */\n\t\tlog(EVDNS_LOG_DEBUG,\n\t\t    \"Setting timeout for request %p, sent to nameserver %p\", req, req->ns);\n\t\tif (evtimer_add(&req->timeout_event, &req->base->global_timeout) < 0) {\n\t\t\tlog(EVDNS_LOG_WARN,\n\t\t      \"Error from libevent when adding timer for request %p\",\n\t\t\t    req);\n\t\t\t/* ???? Do more? */\n\t\t}\n\t\treq->tx_count++;\n\t\treq->transmit_me = 0;\n\t\treturn retcode;\n\t}\n}\n\nstatic void\nnameserver_probe_callback(int result, char type, int count, int ttl, void *addresses, void *arg) {\n\tstruct nameserver *const ns = (struct nameserver *) arg;\n\t(void) type;\n\t(void) count;\n\t(void) ttl;\n\t(void) addresses;\n\n\tif (result == DNS_ERR_CANCEL) {\n\t\t/* We canceled this request because the nameserver came up\n\t\t * for some other reason.  Do not change our opinion about\n\t\t * the nameserver. */\n\t\treturn;\n\t}\n\n\tEVDNS_LOCK(ns->base);\n\tns->probe_request = NULL;\n\tif (result == DNS_ERR_NONE || result == DNS_ERR_NOTEXIST) {\n\t\t/* this is a good reply */\n\t\tnameserver_up(ns);\n\t} else {\n\t\tnameserver_probe_failed(ns);\n\t}\n\tEVDNS_UNLOCK(ns->base);\n}\n\nstatic void\nnameserver_send_probe(struct nameserver *const ns) {\n\tstruct evdns_request *handle;\n\tstruct request *req;\n\tchar addrbuf[128];\n\t/* here we need to send a probe to a given nameserver */\n\t/* in the hope that it is up now. */\n\n\tASSERT_LOCKED(ns->base);\n\tlog(EVDNS_LOG_DEBUG, \"Sending probe to %s\",\n\t    evutil_format_sockaddr_port_(\n\t\t    (struct sockaddr *)&ns->address,\n\t\t    addrbuf, sizeof(addrbuf)));\n\thandle = mm_calloc(1, sizeof(*handle));\n\tif (!handle) return;\n\treq = request_new(ns->base, handle, TYPE_A, \"google.com\", DNS_QUERY_NO_SEARCH, nameserver_probe_callback, ns);\n\tif (!req) {\n\t\tmm_free(handle);\n\t\treturn;\n\t}\n\tns->probe_request = handle;\n\t/* we force this into the inflight queue no matter what */\n\trequest_trans_id_set(req, transaction_id_pick(ns->base));\n\treq->ns = ns;\n\trequest_submit(req);\n}\n\n/* returns: */\n/*   0 didn't try to transmit anything */\n/*   1 tried to transmit something */\nstatic int\nevdns_transmit(struct evdns_base *base) {\n\tchar did_try_to_transmit = 0;\n\tint i;\n\n\tASSERT_LOCKED(base);\n\tfor (i = 0; i < base->n_req_heads; ++i) {\n\t\tif (base->req_heads[i]) {\n\t\t\tstruct request *const started_at = base->req_heads[i], *req = started_at;\n\t\t\t/* first transmit all the requests which are currently waiting */\n\t\t\tdo {\n\t\t\t\tif (req->transmit_me) {\n\t\t\t\t\tdid_try_to_transmit = 1;\n\t\t\t\t\tevdns_request_transmit(req);\n\t\t\t\t}\n\n\t\t\t\treq = req->next;\n\t\t\t} while (req != started_at);\n\t\t}\n\t}\n\n\treturn did_try_to_transmit;\n}\n\n/* exported function */\nint\nevdns_base_count_nameservers(struct evdns_base *base)\n{\n\tconst struct nameserver *server;\n\tint n = 0;\n\n\tEVDNS_LOCK(base);\n\tserver = base->server_head;\n\tif (!server)\n\t\tgoto done;\n\tdo {\n\t\t++n;\n\t\tserver = server->next;\n\t} while (server != base->server_head);\ndone:\n\tEVDNS_UNLOCK(base);\n\treturn n;\n}\n\nint\nevdns_count_nameservers(void)\n{\n\treturn evdns_base_count_nameservers(current_base);\n}\n\n/* exported function */\nint\nevdns_base_clear_nameservers_and_suspend(struct evdns_base *base)\n{\n\tstruct nameserver *server, *started_at;\n\tint i;\n\n\tEVDNS_LOCK(base);\n\tserver = base->server_head;\n\tstarted_at = base->server_head;\n\tif (!server) {\n\t\tEVDNS_UNLOCK(base);\n\t\treturn 0;\n\t}\n\twhile (1) {\n\t\tstruct nameserver *next = server->next;\n\t\t(void) event_del(&server->event);\n\t\tif (evtimer_initialized(&server->timeout_event))\n\t\t\t(void) evtimer_del(&server->timeout_event);\n\t\tif (server->probe_request) {\n\t\t\tevdns_cancel_request(server->base, server->probe_request);\n\t\t\tserver->probe_request = NULL;\n\t\t}\n\t\tif (server->socket >= 0)\n\t\t\tevutil_closesocket(server->socket);\n\t\tmm_free(server);\n\t\tif (next == started_at)\n\t\t\tbreak;\n\t\tserver = next;\n\t}\n\tbase->server_head = NULL;\n\tbase->global_good_nameservers = 0;\n\n\tfor (i = 0; i < base->n_req_heads; ++i) {\n\t\tstruct request *req, *req_started_at;\n\t\treq = req_started_at = base->req_heads[i];\n\t\twhile (req) {\n\t\t\tstruct request *next = req->next;\n\t\t\treq->tx_count = req->reissue_count = 0;\n\t\t\treq->ns = NULL;\n\t\t\t/* ???? What to do about searches? */\n\t\t\t(void) evtimer_del(&req->timeout_event);\n\t\t\treq->trans_id = 0;\n\t\t\treq->transmit_me = 0;\n\n\t\t\tbase->global_requests_waiting++;\n\t\t\tevdns_request_insert(req, &base->req_waiting_head);\n\t\t\t/* We want to insert these suspended elements at the front of\n\t\t\t * the waiting queue, since they were pending before any of\n\t\t\t * the waiting entries were added.  This is a circular list,\n\t\t\t * so we can just shift the start back by one.*/\n\t\t\tbase->req_waiting_head = base->req_waiting_head->prev;\n\n\t\t\tif (next == req_started_at)\n\t\t\t\tbreak;\n\t\t\treq = next;\n\t\t}\n\t\tbase->req_heads[i] = NULL;\n\t}\n\n\tbase->global_requests_inflight = 0;\n\n\tEVDNS_UNLOCK(base);\n\treturn 0;\n}\n\nint\nevdns_clear_nameservers_and_suspend(void)\n{\n\treturn evdns_base_clear_nameservers_and_suspend(current_base);\n}\n\n\n/* exported function */\nint\nevdns_base_resume(struct evdns_base *base)\n{\n\tEVDNS_LOCK(base);\n\tevdns_requests_pump_waiting_queue(base);\n\tEVDNS_UNLOCK(base);\n\n\treturn 0;\n}\n\nint\nevdns_resume(void)\n{\n\treturn evdns_base_resume(current_base);\n}\n\nstatic int\nevdns_nameserver_add_impl_(struct evdns_base *base, const struct sockaddr *address, int addrlen) {\n\t/* first check to see if we already have this nameserver */\n\n\tconst struct nameserver *server = base->server_head, *const started_at = base->server_head;\n\tstruct nameserver *ns;\n\tint err = 0;\n\tchar addrbuf[128];\n\n\tASSERT_LOCKED(base);\n\tif (server) {\n\t\tdo {\n\t\t\tif (!evutil_sockaddr_cmp((struct sockaddr*)&server->address, address, 1)) return 3;\n\t\t\tserver = server->next;\n\t\t} while (server != started_at);\n\t}\n\tif (addrlen > (int)sizeof(ns->address)) {\n\t\tlog(EVDNS_LOG_DEBUG, \"Addrlen %d too long.\", (int)addrlen);\n\t\treturn 2;\n\t}\n\n\tns = (struct nameserver *) mm_malloc(sizeof(struct nameserver));\n\tif (!ns) return -1;\n\n\tmemset(ns, 0, sizeof(struct nameserver));\n\tns->base = base;\n\n\tevtimer_assign(&ns->timeout_event, ns->base->event_base, nameserver_prod_callback, ns);\n\n\tns->socket = evutil_socket_(address->sa_family,\n\t    SOCK_DGRAM|EVUTIL_SOCK_NONBLOCK|EVUTIL_SOCK_CLOEXEC, 0);\n\tif (ns->socket < 0) { err = 1; goto out1; }\n\n\tif (base->global_outgoing_addrlen &&\n\t    !evutil_sockaddr_is_loopback_(address)) {\n\t\tif (bind(ns->socket,\n\t\t\t(struct sockaddr*)&base->global_outgoing_address,\n\t\t\tbase->global_outgoing_addrlen) < 0) {\n\t\t\tlog(EVDNS_LOG_WARN,\"Couldn't bind to outgoing address\");\n\t\t\terr = 2;\n\t\t\tgoto out2;\n\t\t}\n\t}\n\n\tmemcpy(&ns->address, address, addrlen);\n\tns->addrlen = addrlen;\n\tns->state = 1;\n\tevent_assign(&ns->event, ns->base->event_base, ns->socket,\n\t\t\t\t EV_READ | EV_PERSIST, nameserver_ready_callback, ns);\n\tif (!base->disable_when_inactive && event_add(&ns->event, NULL) < 0) {\n\t\terr = 2;\n\t\tgoto out2;\n\t}\n\n\tlog(EVDNS_LOG_DEBUG, \"Added nameserver %s as %p\",\n\t    evutil_format_sockaddr_port_(address, addrbuf, sizeof(addrbuf)), ns);\n\n\t/* insert this nameserver into the list of them */\n\tif (!base->server_head) {\n\t\tns->next = ns->prev = ns;\n\t\tbase->server_head = ns;\n\t} else {\n\t\tns->next = base->server_head->next;\n\t\tns->prev = base->server_head;\n\t\tbase->server_head->next = ns;\n\t\tns->next->prev = ns;\n\t}\n\n\tbase->global_good_nameservers++;\n\n\treturn 0;\n\nout2:\n\tevutil_closesocket(ns->socket);\nout1:\n\tevent_debug_unassign(&ns->event);\n\tmm_free(ns);\n\tlog(EVDNS_LOG_WARN, \"Unable to add nameserver %s: error %d\",\n\t    evutil_format_sockaddr_port_(address, addrbuf, sizeof(addrbuf)), err);\n\treturn err;\n}\n\n/* exported function */\nint\nevdns_base_nameserver_add(struct evdns_base *base, unsigned long int address)\n{\n\tstruct sockaddr_in sin;\n\tint res;\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_addr.s_addr = address;\n\tsin.sin_port = htons(53);\n\tsin.sin_family = AF_INET;\n\tEVDNS_LOCK(base);\n\tres = evdns_nameserver_add_impl_(base, (struct sockaddr*)&sin, sizeof(sin));\n\tEVDNS_UNLOCK(base);\n\treturn res;\n}\n\nint\nevdns_nameserver_add(unsigned long int address) {\n\tif (!current_base)\n\t\tcurrent_base = evdns_base_new(NULL, 0);\n\treturn evdns_base_nameserver_add(current_base, address);\n}\n\nstatic void\nsockaddr_setport(struct sockaddr *sa, ev_uint16_t port)\n{\n\tif (sa->sa_family == AF_INET) {\n\t\t((struct sockaddr_in *)sa)->sin_port = htons(port);\n\t} else if (sa->sa_family == AF_INET6) {\n\t\t((struct sockaddr_in6 *)sa)->sin6_port = htons(port);\n\t}\n}\n\nstatic ev_uint16_t\nsockaddr_getport(struct sockaddr *sa)\n{\n\tif (sa->sa_family == AF_INET) {\n\t\treturn ntohs(((struct sockaddr_in *)sa)->sin_port);\n\t} else if (sa->sa_family == AF_INET6) {\n\t\treturn ntohs(((struct sockaddr_in6 *)sa)->sin6_port);\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n/* exported function */\nint\nevdns_base_nameserver_ip_add(struct evdns_base *base, const char *ip_as_string) {\n\tstruct sockaddr_storage ss;\n\tstruct sockaddr *sa;\n\tint len = sizeof(ss);\n\tint res;\n\tif (evutil_parse_sockaddr_port(ip_as_string, (struct sockaddr *)&ss,\n\t\t&len)) {\n\t\tlog(EVDNS_LOG_WARN, \"Unable to parse nameserver address %s\",\n\t\t\tip_as_string);\n\t\treturn 4;\n\t}\n\tsa = (struct sockaddr *) &ss;\n\tif (sockaddr_getport(sa) == 0)\n\t\tsockaddr_setport(sa, 53);\n\n\tEVDNS_LOCK(base);\n\tres = evdns_nameserver_add_impl_(base, sa, len);\n\tEVDNS_UNLOCK(base);\n\treturn res;\n}\n\nint\nevdns_nameserver_ip_add(const char *ip_as_string) {\n\tif (!current_base)\n\t\tcurrent_base = evdns_base_new(NULL, 0);\n\treturn evdns_base_nameserver_ip_add(current_base, ip_as_string);\n}\n\nint\nevdns_base_nameserver_sockaddr_add(struct evdns_base *base,\n    const struct sockaddr *sa, ev_socklen_t len, unsigned flags)\n{\n\tint res;\n\tEVUTIL_ASSERT(base);\n\tEVDNS_LOCK(base);\n\tres = evdns_nameserver_add_impl_(base, sa, len);\n\tEVDNS_UNLOCK(base);\n\treturn res;\n}\n\nint\nevdns_base_get_nameserver_addr(struct evdns_base *base, int idx,\n    struct sockaddr *sa, ev_socklen_t len)\n{\n\tint result = -1;\n\tint i;\n\tstruct nameserver *server;\n\tEVDNS_LOCK(base);\n\tserver = base->server_head;\n\tfor (i = 0; i < idx && server; ++i, server = server->next) {\n\t\tif (server->next == base->server_head)\n\t\t\tgoto done;\n\t}\n\tif (! server)\n\t\tgoto done;\n\n\tif (server->addrlen > len) {\n\t\tresult = (int) server->addrlen;\n\t\tgoto done;\n\t}\n\n\tmemcpy(sa, &server->address, server->addrlen);\n\tresult = (int) server->addrlen;\ndone:\n\tEVDNS_UNLOCK(base);\n\treturn result;\n}\n\n/* remove from the queue */\nstatic void\nevdns_request_remove(struct request *req, struct request **head)\n{\n\tASSERT_LOCKED(req->base);\n\tASSERT_VALID_REQUEST(req);\n\n#if 0\n\t{\n\t\tstruct request *ptr;\n\t\tint found = 0;\n\t\tEVUTIL_ASSERT(*head != NULL);\n\n\t\tptr = *head;\n\t\tdo {\n\t\t\tif (ptr == req) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr->next;\n\t\t} while (ptr != *head);\n\t\tEVUTIL_ASSERT(found);\n\n\t\tEVUTIL_ASSERT(req->next);\n\t}\n#endif\n\n\tif (req->next == req) {\n\t\t/* only item in the list */\n\t\t*head = NULL;\n\t} else {\n\t\treq->next->prev = req->prev;\n\t\treq->prev->next = req->next;\n\t\tif (*head == req) *head = req->next;\n\t}\n\treq->next = req->prev = NULL;\n}\n\n/* insert into the tail of the queue */\nstatic void\nevdns_request_insert(struct request *req, struct request **head) {\n\tASSERT_LOCKED(req->base);\n\tASSERT_VALID_REQUEST(req);\n\tif (!*head) {\n\t\t*head = req;\n\t\treq->next = req->prev = req;\n\t\treturn;\n\t}\n\n\treq->prev = (*head)->prev;\n\treq->prev->next = req;\n\treq->next = *head;\n\t(*head)->prev = req;\n}\n\nstatic int\nstring_num_dots(const char *s) {\n\tint count = 0;\n\twhile ((s = strchr(s, '.'))) {\n\t\ts++;\n\t\tcount++;\n\t}\n\treturn count;\n}\n\nstatic struct request *\nrequest_new(struct evdns_base *base, struct evdns_request *handle, int type,\n\t    const char *name, int flags, evdns_callback_type callback,\n\t    void *user_ptr) {\n\n\tconst char issuing_now =\n\t    (base->global_requests_inflight < base->global_max_requests_inflight) ? 1 : 0;\n\n\tconst size_t name_len = strlen(name);\n\tconst size_t request_max_len = evdns_request_len(name_len);\n\tconst u16 trans_id = issuing_now ? transaction_id_pick(base) : 0xffff;\n\t/* the request data is alloced in a single block with the header */\n\tstruct request *const req =\n\t    mm_malloc(sizeof(struct request) + request_max_len);\n\tint rlen;\n\tchar namebuf[256];\n\t(void) flags;\n\n\tASSERT_LOCKED(base);\n\n\tif (!req) return NULL;\n\n\tif (name_len >= sizeof(namebuf)) {\n\t\tmm_free(req);\n\t\treturn NULL;\n\t}\n\n\tmemset(req, 0, sizeof(struct request));\n\treq->base = base;\n\n\tevtimer_assign(&req->timeout_event, req->base->event_base, evdns_request_timeout_callback, req);\n\n\tif (base->global_randomize_case) {\n\t\tunsigned i;\n\t\tchar randbits[(sizeof(namebuf)+7)/8];\n\t\tstrlcpy(namebuf, name, sizeof(namebuf));\n\t\tevutil_secure_rng_get_bytes(randbits, (name_len+7)/8);\n\t\tfor (i = 0; i < name_len; ++i) {\n\t\t\tif (EVUTIL_ISALPHA_(namebuf[i])) {\n\t\t\t\tif ((randbits[i >> 3] & (1<<(i & 7))))\n\t\t\t\t\tnamebuf[i] |= 0x20;\n\t\t\t\telse\n\t\t\t\t\tnamebuf[i] &= ~0x20;\n\t\t\t}\n\t\t}\n\t\tname = namebuf;\n\t}\n\n\t/* request data lives just after the header */\n\treq->request = ((u8 *) req) + sizeof(struct request);\n\t/* denotes that the request data shouldn't be free()ed */\n\treq->request_appended = 1;\n\trlen = evdns_request_data_build(name, name_len, trans_id,\n\t    type, CLASS_INET, req->request, request_max_len);\n\tif (rlen < 0)\n\t\tgoto err1;\n\n\treq->request_len = rlen;\n\treq->trans_id = trans_id;\n\treq->tx_count = 0;\n\treq->request_type = type;\n\treq->user_pointer = user_ptr;\n\treq->user_callback = callback;\n\treq->ns = issuing_now ? nameserver_pick(base) : NULL;\n\treq->next = req->prev = NULL;\n\treq->handle = handle;\n\tif (handle) {\n\t\thandle->current_req = req;\n\t\thandle->base = base;\n\t}\n\n\treturn req;\nerr1:\n\tmm_free(req);\n\treturn NULL;\n}\n\nstatic void\nrequest_submit(struct request *const req) {\n\tstruct evdns_base *base = req->base;\n\tASSERT_LOCKED(base);\n\tASSERT_VALID_REQUEST(req);\n\tif (req->ns) {\n\t\t/* if it has a nameserver assigned then this is going */\n\t\t/* straight into the inflight queue */\n\t\tevdns_request_insert(req, &REQ_HEAD(base, req->trans_id));\n\n\t\tbase->global_requests_inflight++;\n\t\treq->ns->requests_inflight++;\n\n\t\tevdns_request_transmit(req);\n\t} else {\n\t\tevdns_request_insert(req, &base->req_waiting_head);\n\t\tbase->global_requests_waiting++;\n\t}\n}\n\n/* exported function */\nvoid\nevdns_cancel_request(struct evdns_base *base, struct evdns_request *handle)\n{\n\tstruct request *req;\n\n\tif (!handle->current_req)\n\t\treturn;\n\n\tif (!base) {\n\t\t/* This redundancy is silly; can we fix it? (Not for 2.0) XXXX */\n\t\tbase = handle->base;\n\t\tif (!base)\n\t\t\tbase = handle->current_req->base;\n\t}\n\n\tEVDNS_LOCK(base);\n\tif (handle->pending_cb) {\n\t\tEVDNS_UNLOCK(base);\n\t\treturn;\n\t}\n\n\treq = handle->current_req;\n\tASSERT_VALID_REQUEST(req);\n\n\treply_schedule_callback(req, 0, DNS_ERR_CANCEL, NULL);\n\tif (req->ns) {\n\t\t/* remove from inflight queue */\n\t\trequest_finished(req, &REQ_HEAD(base, req->trans_id), 1);\n\t} else {\n\t\t/* remove from global_waiting head */\n\t\trequest_finished(req, &base->req_waiting_head, 1);\n\t}\n\tEVDNS_UNLOCK(base);\n}\n\n/* exported function */\nstruct evdns_request *\nevdns_base_resolve_ipv4(struct evdns_base *base, const char *name, int flags,\n    evdns_callback_type callback, void *ptr) {\n\tstruct evdns_request *handle;\n\tstruct request *req;\n\tlog(EVDNS_LOG_DEBUG, \"Resolve requested for %s\", name);\n\thandle = mm_calloc(1, sizeof(*handle));\n\tif (handle == NULL)\n\t\treturn NULL;\n\tEVDNS_LOCK(base);\n\tif (flags & DNS_QUERY_NO_SEARCH) {\n\t\treq =\n\t\t\trequest_new(base, handle, TYPE_A, name, flags,\n\t\t\t\t    callback, ptr);\n\t\tif (req)\n\t\t\trequest_submit(req);\n\t} else {\n\t\tsearch_request_new(base, handle, TYPE_A, name, flags,\n\t\t    callback, ptr);\n\t}\n\tif (handle->current_req == NULL) {\n\t\tmm_free(handle);\n\t\thandle = NULL;\n\t}\n\tEVDNS_UNLOCK(base);\n\treturn handle;\n}\n\nint evdns_resolve_ipv4(const char *name, int flags,\n\t\t\t\t\t   evdns_callback_type callback, void *ptr)\n{\n\treturn evdns_base_resolve_ipv4(current_base, name, flags, callback, ptr)\n\t\t? 0 : -1;\n}\n\n\n/* exported function */\nstruct evdns_request *\nevdns_base_resolve_ipv6(struct evdns_base *base,\n    const char *name, int flags,\n    evdns_callback_type callback, void *ptr)\n{\n\tstruct evdns_request *handle;\n\tstruct request *req;\n\tlog(EVDNS_LOG_DEBUG, \"Resolve requested for %s\", name);\n\thandle = mm_calloc(1, sizeof(*handle));\n\tif (handle == NULL)\n\t\treturn NULL;\n\tEVDNS_LOCK(base);\n\tif (flags & DNS_QUERY_NO_SEARCH) {\n\t\treq = request_new(base, handle, TYPE_AAAA, name, flags,\n\t\t\t\t  callback, ptr);\n\t\tif (req)\n\t\t\trequest_submit(req);\n\t} else {\n\t\tsearch_request_new(base, handle, TYPE_AAAA, name, flags,\n\t\t    callback, ptr);\n\t}\n\tif (handle->current_req == NULL) {\n\t\tmm_free(handle);\n\t\thandle = NULL;\n\t}\n\tEVDNS_UNLOCK(base);\n\treturn handle;\n}\n\nint evdns_resolve_ipv6(const char *name, int flags,\n    evdns_callback_type callback, void *ptr) {\n\treturn evdns_base_resolve_ipv6(current_base, name, flags, callback, ptr)\n\t\t? 0 : -1;\n}\n\nstruct evdns_request *\nevdns_base_resolve_reverse(struct evdns_base *base, const struct in_addr *in, int flags, evdns_callback_type callback, void *ptr) {\n\tchar buf[32];\n\tstruct evdns_request *handle;\n\tstruct request *req;\n\tu32 a;\n\tEVUTIL_ASSERT(in);\n\ta = ntohl(in->s_addr);\n\tevutil_snprintf(buf, sizeof(buf), \"%d.%d.%d.%d.in-addr.arpa\",\n\t\t\t(int)(u8)((a\t)&0xff),\n\t\t\t(int)(u8)((a>>8 )&0xff),\n\t\t\t(int)(u8)((a>>16)&0xff),\n\t\t\t(int)(u8)((a>>24)&0xff));\n\thandle = mm_calloc(1, sizeof(*handle));\n\tif (handle == NULL)\n\t\treturn NULL;\n\tlog(EVDNS_LOG_DEBUG, \"Resolve requested for %s (reverse)\", buf);\n\tEVDNS_LOCK(base);\n\treq = request_new(base, handle, TYPE_PTR, buf, flags, callback, ptr);\n\tif (req)\n\t\trequest_submit(req);\n\tif (handle->current_req == NULL) {\n\t\tmm_free(handle);\n\t\thandle = NULL;\n\t}\n\tEVDNS_UNLOCK(base);\n\treturn (handle);\n}\n\nint evdns_resolve_reverse(const struct in_addr *in, int flags, evdns_callback_type callback, void *ptr) {\n\treturn evdns_base_resolve_reverse(current_base, in, flags, callback, ptr)\n\t\t? 0 : -1;\n}\n\nstruct evdns_request *\nevdns_base_resolve_reverse_ipv6(struct evdns_base *base, const struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr) {\n\t/* 32 nybbles, 32 periods, \"ip6.arpa\", NUL. */\n\tchar buf[73];\n\tchar *cp;\n\tstruct evdns_request *handle;\n\tstruct request *req;\n\tint i;\n\tEVUTIL_ASSERT(in);\n\tcp = buf;\n\tfor (i=15; i >= 0; --i) {\n\t\tu8 byte = in->s6_addr[i];\n\t\t*cp++ = \"0123456789abcdef\"[byte & 0x0f];\n\t\t*cp++ = '.';\n\t\t*cp++ = \"0123456789abcdef\"[byte >> 4];\n\t\t*cp++ = '.';\n\t}\n\tEVUTIL_ASSERT(cp + strlen(\"ip6.arpa\") < buf+sizeof(buf));\n\tmemcpy(cp, \"ip6.arpa\", strlen(\"ip6.arpa\")+1);\n\thandle = mm_calloc(1, sizeof(*handle));\n\tif (handle == NULL)\n\t\treturn NULL;\n\tlog(EVDNS_LOG_DEBUG, \"Resolve requested for %s (reverse)\", buf);\n\tEVDNS_LOCK(base);\n\treq = request_new(base, handle, TYPE_PTR, buf, flags, callback, ptr);\n\tif (req)\n\t\trequest_submit(req);\n\tif (handle->current_req == NULL) {\n\t\tmm_free(handle);\n\t\thandle = NULL;\n\t}\n\tEVDNS_UNLOCK(base);\n\treturn (handle);\n}\n\nint evdns_resolve_reverse_ipv6(const struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr) {\n\treturn evdns_base_resolve_reverse_ipv6(current_base, in, flags, callback, ptr)\n\t\t? 0 : -1;\n}\n\n/* ================================================================= */\n/* Search support */\n/* */\n/* the libc resolver has support for searching a number of domains */\n/* to find a name. If nothing else then it takes the single domain */\n/* from the gethostname() call. */\n/* */\n/* It can also be configured via the domain and search options in a */\n/* resolv.conf. */\n/* */\n/* The ndots option controls how many dots it takes for the resolver */\n/* to decide that a name is non-local and so try a raw lookup first. */\n\nstruct search_domain {\n\tint len;\n\tstruct search_domain *next;\n\t/* the text string is appended to this structure */\n};\n\nstruct search_state {\n\tint refcount;\n\tint ndots;\n\tint num_domains;\n\tstruct search_domain *head;\n};\n\nstatic void\nsearch_state_decref(struct search_state *const state) {\n\tif (!state) return;\n\tstate->refcount--;\n\tif (!state->refcount) {\n\t\tstruct search_domain *next, *dom;\n\t\tfor (dom = state->head; dom; dom = next) {\n\t\t\tnext = dom->next;\n\t\t\tmm_free(dom);\n\t\t}\n\t\tmm_free(state);\n\t}\n}\n\nstatic struct search_state *\nsearch_state_new(void) {\n\tstruct search_state *state = (struct search_state *) mm_malloc(sizeof(struct search_state));\n\tif (!state) return NULL;\n\tmemset(state, 0, sizeof(struct search_state));\n\tstate->refcount = 1;\n\tstate->ndots = 1;\n\n\treturn state;\n}\n\nstatic void\nsearch_postfix_clear(struct evdns_base *base) {\n\tsearch_state_decref(base->global_search_state);\n\n\tbase->global_search_state = search_state_new();\n}\n\n/* exported function */\nvoid\nevdns_base_search_clear(struct evdns_base *base)\n{\n\tEVDNS_LOCK(base);\n\tsearch_postfix_clear(base);\n\tEVDNS_UNLOCK(base);\n}\n\nvoid\nevdns_search_clear(void) {\n\tevdns_base_search_clear(current_base);\n}\n\nstatic void\nsearch_postfix_add(struct evdns_base *base, const char *domain) {\n\tsize_t domain_len;\n\tstruct search_domain *sdomain;\n\twhile (domain[0] == '.') domain++;\n\tdomain_len = strlen(domain);\n\n\tASSERT_LOCKED(base);\n\tif (!base->global_search_state) base->global_search_state = search_state_new();\n\tif (!base->global_search_state) return;\n\tbase->global_search_state->num_domains++;\n\n\tsdomain = (struct search_domain *) mm_malloc(sizeof(struct search_domain) + domain_len);\n\tif (!sdomain) return;\n\tmemcpy( ((u8 *) sdomain) + sizeof(struct search_domain), domain, domain_len);\n\tsdomain->next = base->global_search_state->head;\n\tsdomain->len = (int) domain_len;\n\n\tbase->global_search_state->head = sdomain;\n}\n\n/* reverse the order of members in the postfix list. This is needed because, */\n/* when parsing resolv.conf we push elements in the wrong order */\nstatic void\nsearch_reverse(struct evdns_base *base) {\n\tstruct search_domain *cur, *prev = NULL, *next;\n\tASSERT_LOCKED(base);\n\tcur = base->global_search_state->head;\n\twhile (cur) {\n\t\tnext = cur->next;\n\t\tcur->next = prev;\n\t\tprev = cur;\n\t\tcur = next;\n\t}\n\n\tbase->global_search_state->head = prev;\n}\n\n/* exported function */\nvoid\nevdns_base_search_add(struct evdns_base *base, const char *domain) {\n\tEVDNS_LOCK(base);\n\tsearch_postfix_add(base, domain);\n\tEVDNS_UNLOCK(base);\n}\nvoid\nevdns_search_add(const char *domain) {\n\tevdns_base_search_add(current_base, domain);\n}\n\n/* exported function */\nvoid\nevdns_base_search_ndots_set(struct evdns_base *base, const int ndots) {\n\tEVDNS_LOCK(base);\n\tif (!base->global_search_state) base->global_search_state = search_state_new();\n\tif (base->global_search_state)\n\t\tbase->global_search_state->ndots = ndots;\n\tEVDNS_UNLOCK(base);\n}\nvoid\nevdns_search_ndots_set(const int ndots) {\n\tevdns_base_search_ndots_set(current_base, ndots);\n}\n\nstatic void\nsearch_set_from_hostname(struct evdns_base *base) {\n\tchar hostname[HOST_NAME_MAX + 1], *domainname;\n\n\tASSERT_LOCKED(base);\n\tsearch_postfix_clear(base);\n\tif (gethostname(hostname, sizeof(hostname))) return;\n\tdomainname = strchr(hostname, '.');\n\tif (!domainname) return;\n\tsearch_postfix_add(base, domainname);\n}\n\n/* warning: returns malloced string */\nstatic char *\nsearch_make_new(const struct search_state *const state, int n, const char *const base_name) {\n\tconst size_t base_len = strlen(base_name);\n\tchar need_to_append_dot;\n\tstruct search_domain *dom;\n\n\tif (!base_len) return NULL;\n\tneed_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n\n\tfor (dom = state->head; dom; dom = dom->next) {\n\t\tif (!n--) {\n\t\t\t/* this is the postfix we want */\n\t\t\t/* the actual postfix string is kept at the end of the structure */\n\t\t\tconst u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);\n\t\t\tconst int postfix_len = dom->len;\n\t\t\tchar *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1);\n\t\t\tif (!newname) return NULL;\n\t\t\tmemcpy(newname, base_name, base_len);\n\t\t\tif (need_to_append_dot) newname[base_len] = '.';\n\t\t\tmemcpy(newname + base_len + need_to_append_dot, postfix, postfix_len);\n\t\t\tnewname[base_len + need_to_append_dot + postfix_len] = 0;\n\t\t\treturn newname;\n\t\t}\n\t}\n\n\t/* we ran off the end of the list and still didn't find the requested string */\n\tEVUTIL_ASSERT(0);\n\treturn NULL; /* unreachable; stops warnings in some compilers. */\n}\n\nstatic struct request *\nsearch_request_new(struct evdns_base *base, struct evdns_request *handle,\n\t\t   int type, const char *const name, int flags,\n\t\t   evdns_callback_type user_callback, void *user_arg) {\n\tASSERT_LOCKED(base);\n\tEVUTIL_ASSERT(type == TYPE_A || type == TYPE_AAAA);\n\tEVUTIL_ASSERT(handle->current_req == NULL);\n\tif ( ((flags & DNS_QUERY_NO_SEARCH) == 0) &&\n\t     base->global_search_state &&\n\t\t base->global_search_state->num_domains) {\n\t\t/* we have some domains to search */\n\t\tstruct request *req;\n\t\tif (string_num_dots(name) >= base->global_search_state->ndots) {\n\t\t\treq = request_new(base, handle, type, name, flags, user_callback, user_arg);\n\t\t\tif (!req) return NULL;\n\t\t\thandle->search_index = -1;\n\t\t} else {\n\t\t\tchar *const new_name = search_make_new(base->global_search_state, 0, name);\n\t\t\tif (!new_name) return NULL;\n\t\t\treq = request_new(base, handle, type, new_name, flags, user_callback, user_arg);\n\t\t\tmm_free(new_name);\n\t\t\tif (!req) return NULL;\n\t\t\thandle->search_index = 0;\n\t\t}\n\t\tEVUTIL_ASSERT(handle->search_origname == NULL);\n\t\thandle->search_origname = mm_strdup(name);\n\t\tif (handle->search_origname == NULL) {\n\t\t\t/* XXX Should we dealloc req? If yes, how? */\n\t\t\tif (req)\n\t\t\t\tmm_free(req);\n\t\t\treturn NULL;\n\t\t}\n\t\thandle->search_state = base->global_search_state;\n\t\thandle->search_flags = flags;\n\t\tbase->global_search_state->refcount++;\n\t\trequest_submit(req);\n\t\treturn req;\n\t} else {\n\t\tstruct request *const req = request_new(base, handle, type, name, flags, user_callback, user_arg);\n\t\tif (!req) return NULL;\n\t\trequest_submit(req);\n\t\treturn req;\n\t}\n}\n\n/* this is called when a request has failed to find a name. We need to check */\n/* if it is part of a search and, if so, try the next name in the list */\n/* returns: */\n/*   0 another request has been submitted */\n/*   1 no more requests needed */\nstatic int\nsearch_try_next(struct evdns_request *const handle) {\n\tstruct request *req = handle->current_req;\n\tstruct evdns_base *base = req->base;\n\tstruct request *newreq;\n\tASSERT_LOCKED(base);\n\tif (handle->search_state) {\n\t\t/* it is part of a search */\n\t\tchar *new_name;\n\t\thandle->search_index++;\n\t\tif (handle->search_index >= handle->search_state->num_domains) {\n\t\t\t/* no more postfixes to try, however we may need to try */\n\t\t\t/* this name without a postfix */\n\t\t\tif (string_num_dots(handle->search_origname) < handle->search_state->ndots) {\n\t\t\t\t/* yep, we need to try it raw */\n\t\t\t\tnewreq = request_new(base, NULL, req->request_type, handle->search_origname, handle->search_flags, req->user_callback, req->user_pointer);\n\t\t\t\tlog(EVDNS_LOG_DEBUG, \"Search: trying raw query %s\", handle->search_origname);\n\t\t\t\tif (newreq) {\n\t\t\t\t\tsearch_request_finished(handle);\n\t\t\t\t\tgoto submit_next;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\n\t\tnew_name = search_make_new(handle->search_state, handle->search_index, handle->search_origname);\n\t\tif (!new_name) return 1;\n\t\tlog(EVDNS_LOG_DEBUG, \"Search: now trying %s (%d)\", new_name, handle->search_index);\n\t\tnewreq = request_new(base, NULL, req->request_type, new_name, handle->search_flags, req->user_callback, req->user_pointer);\n\t\tmm_free(new_name);\n\t\tif (!newreq) return 1;\n\t\tgoto submit_next;\n\t}\n\treturn 1;\n\nsubmit_next:\n\trequest_finished(req, &REQ_HEAD(req->base, req->trans_id), 0);\n\thandle->current_req = newreq;\n\tnewreq->handle = handle;\n\trequest_submit(newreq);\n\treturn 0;\n}\n\nstatic void\nsearch_request_finished(struct evdns_request *const handle) {\n\tASSERT_LOCKED(handle->current_req->base);\n\tif (handle->search_state) {\n\t\tsearch_state_decref(handle->search_state);\n\t\thandle->search_state = NULL;\n\t}\n\tif (handle->search_origname) {\n\t\tmm_free(handle->search_origname);\n\t\thandle->search_origname = NULL;\n\t}\n}\n\n/* ================================================================= */\n/* Parsing resolv.conf files */\n\nstatic void\nevdns_resolv_set_defaults(struct evdns_base *base, int flags) {\n\t/* if the file isn't found then we assume a local resolver */\n\tASSERT_LOCKED(base);\n\tif (flags & DNS_OPTION_SEARCH) search_set_from_hostname(base);\n\tif (flags & DNS_OPTION_NAMESERVERS) evdns_base_nameserver_ip_add(base,\"127.0.0.1\");\n}\n\n#ifndef EVENT__HAVE_STRTOK_R\nstatic char *\nstrtok_r(char *s, const char *delim, char **state) {\n\tchar *cp, *start;\n\tstart = cp = s ? s : *state;\n\tif (!cp)\n\t\treturn NULL;\n\twhile (*cp && !strchr(delim, *cp))\n\t\t++cp;\n\tif (!*cp) {\n\t\tif (cp == start)\n\t\t\treturn NULL;\n\t\t*state = NULL;\n\t\treturn start;\n\t} else {\n\t\t*cp++ = '\\0';\n\t\t*state = cp;\n\t\treturn start;\n\t}\n}\n#endif\n\n/* helper version of atoi which returns -1 on error */\nstatic int\nstrtoint(const char *const str)\n{\n\tchar *endptr;\n\tconst int r = strtol(str, &endptr, 10);\n\tif (*endptr) return -1;\n\treturn r;\n}\n\n/* Parse a number of seconds into a timeval; return -1 on error. */\nstatic int\nevdns_strtotimeval(const char *const str, struct timeval *out)\n{\n\tdouble d;\n\tchar *endptr;\n\td = strtod(str, &endptr);\n\tif (*endptr) return -1;\n\tif (d < 0) return -1;\n\tout->tv_sec = (int) d;\n\tout->tv_usec = (int) ((d - (int) d)*1000000);\n\tif (out->tv_sec == 0 && out->tv_usec < 1000) /* less than 1 msec */\n\t\treturn -1;\n\treturn 0;\n}\n\n/* helper version of atoi that returns -1 on error and clips to bounds. */\nstatic int\nstrtoint_clipped(const char *const str, int min, int max)\n{\n\tint r = strtoint(str);\n\tif (r == -1)\n\t\treturn r;\n\telse if (r<min)\n\t\treturn min;\n\telse if (r>max)\n\t\treturn max;\n\telse\n\t\treturn r;\n}\n\nstatic int\nevdns_base_set_max_requests_inflight(struct evdns_base *base, int maxinflight)\n{\n\tint old_n_heads = base->n_req_heads, n_heads;\n\tstruct request **old_heads = base->req_heads, **new_heads, *req;\n\tint i;\n\n\tASSERT_LOCKED(base);\n\tif (maxinflight < 1)\n\t\tmaxinflight = 1;\n\tn_heads = (maxinflight+4) / 5;\n\tEVUTIL_ASSERT(n_heads > 0);\n\tnew_heads = mm_calloc(n_heads, sizeof(struct request*));\n\tif (!new_heads)\n\t\treturn (-1);\n\tif (old_heads) {\n\t\tfor (i = 0; i < old_n_heads; ++i) {\n\t\t\twhile (old_heads[i]) {\n\t\t\t\treq = old_heads[i];\n\t\t\t\tevdns_request_remove(req, &old_heads[i]);\n\t\t\t\tevdns_request_insert(req, &new_heads[req->trans_id % n_heads]);\n\t\t\t}\n\t\t}\n\t\tmm_free(old_heads);\n\t}\n\tbase->req_heads = new_heads;\n\tbase->n_req_heads = n_heads;\n\tbase->global_max_requests_inflight = maxinflight;\n\treturn (0);\n}\n\n/* exported function */\nint\nevdns_base_set_option(struct evdns_base *base,\n    const char *option, const char *val)\n{\n\tint res;\n\tEVDNS_LOCK(base);\n\tres = evdns_base_set_option_impl(base, option, val, DNS_OPTIONS_ALL);\n\tEVDNS_UNLOCK(base);\n\treturn res;\n}\n\nstatic inline int\nstr_matches_option(const char *s1, const char *optionname)\n{\n\t/* Option names are given as \"option:\" We accept either 'option' in\n\t * s1, or 'option:randomjunk'.  The latter form is to implement the\n\t * resolv.conf parser. */\n\tsize_t optlen = strlen(optionname);\n\tsize_t slen = strlen(s1);\n\tif (slen == optlen || slen == optlen - 1)\n\t\treturn !strncmp(s1, optionname, slen);\n\telse if (slen > optlen)\n\t\treturn !strncmp(s1, optionname, optlen);\n\telse\n\t\treturn 0;\n}\n\nstatic int\nevdns_base_set_option_impl(struct evdns_base *base,\n    const char *option, const char *val, int flags)\n{\n\tASSERT_LOCKED(base);\n\tif (str_matches_option(option, \"ndots:\")) {\n\t\tconst int ndots = strtoint(val);\n\t\tif (ndots == -1) return -1;\n\t\tif (!(flags & DNS_OPTION_SEARCH)) return 0;\n\t\tlog(EVDNS_LOG_DEBUG, \"Setting ndots to %d\", ndots);\n\t\tif (!base->global_search_state) base->global_search_state = search_state_new();\n\t\tif (!base->global_search_state) return -1;\n\t\tbase->global_search_state->ndots = ndots;\n\t} else if (str_matches_option(option, \"timeout:\")) {\n\t\tstruct timeval tv;\n\t\tif (evdns_strtotimeval(val, &tv) == -1) return -1;\n\t\tif (!(flags & DNS_OPTION_MISC)) return 0;\n\t\tlog(EVDNS_LOG_DEBUG, \"Setting timeout to %s\", val);\n\t\tmemcpy(&base->global_timeout, &tv, sizeof(struct timeval));\n\t} else if (str_matches_option(option, \"getaddrinfo-allow-skew:\")) {\n\t\tstruct timeval tv;\n\t\tif (evdns_strtotimeval(val, &tv) == -1) return -1;\n\t\tif (!(flags & DNS_OPTION_MISC)) return 0;\n\t\tlog(EVDNS_LOG_DEBUG, \"Setting getaddrinfo-allow-skew to %s\",\n\t\t    val);\n\t\tmemcpy(&base->global_getaddrinfo_allow_skew, &tv,\n\t\t    sizeof(struct timeval));\n\t} else if (str_matches_option(option, \"max-timeouts:\")) {\n\t\tconst int maxtimeout = strtoint_clipped(val, 1, 255);\n\t\tif (maxtimeout == -1) return -1;\n\t\tif (!(flags & DNS_OPTION_MISC)) return 0;\n\t\tlog(EVDNS_LOG_DEBUG, \"Setting maximum allowed timeouts to %d\",\n\t\t\tmaxtimeout);\n\t\tbase->global_max_nameserver_timeout = maxtimeout;\n\t} else if (str_matches_option(option, \"max-inflight:\")) {\n\t\tconst int maxinflight = strtoint_clipped(val, 1, 65000);\n\t\tif (maxinflight == -1) return -1;\n\t\tif (!(flags & DNS_OPTION_MISC)) return 0;\n\t\tlog(EVDNS_LOG_DEBUG, \"Setting maximum inflight requests to %d\",\n\t\t\tmaxinflight);\n\t\tevdns_base_set_max_requests_inflight(base, maxinflight);\n\t} else if (str_matches_option(option, \"attempts:\")) {\n\t\tint retries = strtoint(val);\n\t\tif (retries == -1) return -1;\n\t\tif (retries > 255) retries = 255;\n\t\tif (!(flags & DNS_OPTION_MISC)) return 0;\n\t\tlog(EVDNS_LOG_DEBUG, \"Setting retries to %d\", retries);\n\t\tbase->global_max_retransmits = retries;\n\t} else if (str_matches_option(option, \"randomize-case:\")) {\n\t\tint randcase = strtoint(val);\n\t\tif (!(flags & DNS_OPTION_MISC)) return 0;\n\t\tbase->global_randomize_case = randcase;\n\t} else if (str_matches_option(option, \"bind-to:\")) {\n\t\t/* XXX This only applies to successive nameservers, not\n\t\t * to already-configured ones.\tWe might want to fix that. */\n\t\tint len = sizeof(base->global_outgoing_address);\n\t\tif (!(flags & DNS_OPTION_NAMESERVERS)) return 0;\n\t\tif (evutil_parse_sockaddr_port(val,\n\t\t\t(struct sockaddr*)&base->global_outgoing_address, &len))\n\t\t\treturn -1;\n\t\tbase->global_outgoing_addrlen = len;\n\t} else if (str_matches_option(option, \"initial-probe-timeout:\")) {\n\t\tstruct timeval tv;\n\t\tif (evdns_strtotimeval(val, &tv) == -1) return -1;\n\t\tif (tv.tv_sec > 3600)\n\t\t\ttv.tv_sec = 3600;\n\t\tif (!(flags & DNS_OPTION_MISC)) return 0;\n\t\tlog(EVDNS_LOG_DEBUG, \"Setting initial probe timeout to %s\",\n\t\t    val);\n\t\tmemcpy(&base->global_nameserver_probe_initial_timeout, &tv,\n\t\t    sizeof(tv));\n\t}\n\treturn 0;\n}\n\nint\nevdns_set_option(const char *option, const char *val, int flags)\n{\n\tif (!current_base)\n\t\tcurrent_base = evdns_base_new(NULL, 0);\n\treturn evdns_base_set_option(current_base, option, val);\n}\n\nstatic void\nresolv_conf_parse_line(struct evdns_base *base, char *const start, int flags) {\n\tchar *strtok_state;\n\tstatic const char *const delims = \" \\t\";\n#define NEXT_TOKEN strtok_r(NULL, delims, &strtok_state)\n\n\n\tchar *const first_token = strtok_r(start, delims, &strtok_state);\n\tASSERT_LOCKED(base);\n\tif (!first_token) return;\n\n\tif (!strcmp(first_token, \"nameserver\") && (flags & DNS_OPTION_NAMESERVERS)) {\n\t\tconst char *const nameserver = NEXT_TOKEN;\n\n\t\tif (nameserver)\n\t\t\tevdns_base_nameserver_ip_add(base, nameserver);\n\t} else if (!strcmp(first_token, \"domain\") && (flags & DNS_OPTION_SEARCH)) {\n\t\tconst char *const domain = NEXT_TOKEN;\n\t\tif (domain) {\n\t\t\tsearch_postfix_clear(base);\n\t\t\tsearch_postfix_add(base, domain);\n\t\t}\n\t} else if (!strcmp(first_token, \"search\") && (flags & DNS_OPTION_SEARCH)) {\n\t\tconst char *domain;\n\t\tsearch_postfix_clear(base);\n\n\t\twhile ((domain = NEXT_TOKEN)) {\n\t\t\tsearch_postfix_add(base, domain);\n\t\t}\n\t\tsearch_reverse(base);\n\t} else if (!strcmp(first_token, \"options\")) {\n\t\tconst char *option;\n\t\twhile ((option = NEXT_TOKEN)) {\n\t\t\tconst char *val = strchr(option, ':');\n\t\t\tevdns_base_set_option_impl(base, option, val ? val+1 : \"\", flags);\n\t\t}\n\t}\n#undef NEXT_TOKEN\n}\n\n/* exported function */\n/* returns: */\n/*   0 no errors */\n/*   1 failed to open file */\n/*   2 failed to stat file */\n/*   3 file too large */\n/*   4 out of memory */\n/*   5 short read from file */\nint\nevdns_base_resolv_conf_parse(struct evdns_base *base, int flags, const char *const filename) {\n\tint res;\n\tEVDNS_LOCK(base);\n\tres = evdns_base_resolv_conf_parse_impl(base, flags, filename);\n\tEVDNS_UNLOCK(base);\n\treturn res;\n}\n\nstatic char *\nevdns_get_default_hosts_filename(void)\n{\n#ifdef _WIN32\n\t/* Windows is a little coy about where it puts its configuration\n\t * files.  Sure, they're _usually_ in C:\\windows\\system32, but\n\t * there's no reason in principle they couldn't be in\n\t * W:\\hoboken chicken emergency\\\n\t */\n\tchar path[MAX_PATH+1];\n\tstatic const char hostfile[] = \"\\\\drivers\\\\etc\\\\hosts\";\n\tchar *path_out;\n\tsize_t len_out;\n\n\tif (! SHGetSpecialFolderPathA(NULL, path, CSIDL_SYSTEM, 0))\n\t\treturn NULL;\n\tlen_out = strlen(path)+strlen(hostfile)+1;\n\tpath_out = mm_malloc(len_out);\n\tevutil_snprintf(path_out, len_out, \"%s%s\", path, hostfile);\n\treturn path_out;\n#else\n\treturn mm_strdup(\"/etc/hosts\");\n#endif\n}\n\nstatic int\nevdns_base_resolv_conf_parse_impl(struct evdns_base *base, int flags, const char *const filename) {\n\tsize_t n;\n\tchar *resolv;\n\tchar *start;\n\tint err = 0;\n\n\tlog(EVDNS_LOG_DEBUG, \"Parsing resolv.conf file %s\", filename);\n\n\tif (flags & DNS_OPTION_HOSTSFILE) {\n\t\tchar *fname = evdns_get_default_hosts_filename();\n\t\tevdns_base_load_hosts(base, fname);\n\t\tif (fname)\n\t\t\tmm_free(fname);\n\t}\n\n\tif ((err = evutil_read_file_(filename, &resolv, &n, 0)) < 0) {\n\t\tif (err == -1) {\n\t\t\t/* No file. */\n\t\t\tevdns_resolv_set_defaults(base, flags);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\tstart = resolv;\n\tfor (;;) {\n\t\tchar *const newline = strchr(start, '\\n');\n\t\tif (!newline) {\n\t\t\tresolv_conf_parse_line(base, start, flags);\n\t\t\tbreak;\n\t\t} else {\n\t\t\t*newline = 0;\n\t\t\tresolv_conf_parse_line(base, start, flags);\n\t\t\tstart = newline + 1;\n\t\t}\n\t}\n\n\tif (!base->server_head && (flags & DNS_OPTION_NAMESERVERS)) {\n\t\t/* no nameservers were configured. */\n\t\tevdns_base_nameserver_ip_add(base, \"127.0.0.1\");\n\t\terr = 6;\n\t}\n\tif (flags & DNS_OPTION_SEARCH && (!base->global_search_state || base->global_search_state->num_domains == 0)) {\n\t\tsearch_set_from_hostname(base);\n\t}\n\n\tmm_free(resolv);\n\treturn err;\n}\n\nint\nevdns_resolv_conf_parse(int flags, const char *const filename) {\n\tif (!current_base)\n\t\tcurrent_base = evdns_base_new(NULL, 0);\n\treturn evdns_base_resolv_conf_parse(current_base, flags, filename);\n}\n\n\n#ifdef _WIN32\n/* Add multiple nameservers from a space-or-comma-separated list. */\nstatic int\nevdns_nameserver_ip_add_line(struct evdns_base *base, const char *ips) {\n\tconst char *addr;\n\tchar *buf;\n\tint r;\n\tASSERT_LOCKED(base);\n\twhile (*ips) {\n\t\twhile (isspace(*ips) || *ips == ',' || *ips == '\\t')\n\t\t\t++ips;\n\t\taddr = ips;\n\t\twhile (isdigit(*ips) || *ips == '.' || *ips == ':' ||\n\t\t    *ips=='[' || *ips==']')\n\t\t\t++ips;\n\t\tbuf = mm_malloc(ips-addr+1);\n\t\tif (!buf) return 4;\n\t\tmemcpy(buf, addr, ips-addr);\n\t\tbuf[ips-addr] = '\\0';\n\t\tr = evdns_base_nameserver_ip_add(base, buf);\n\t\tmm_free(buf);\n\t\tif (r) return r;\n\t}\n\treturn 0;\n}\n\ntypedef DWORD(WINAPI *GetNetworkParams_fn_t)(FIXED_INFO *, DWORD*);\n\n/* Use the windows GetNetworkParams interface in iphlpapi.dll to */\n/* figure out what our nameservers are. */\nstatic int\nload_nameservers_with_getnetworkparams(struct evdns_base *base)\n{\n\t/* Based on MSDN examples and inspection of  c-ares code. */\n\tFIXED_INFO *fixed;\n\tHMODULE handle = 0;\n\tULONG size = sizeof(FIXED_INFO);\n\tvoid *buf = NULL;\n\tint status = 0, r, added_any;\n\tIP_ADDR_STRING *ns;\n\tGetNetworkParams_fn_t fn;\n\n\tASSERT_LOCKED(base);\n\tif (!(handle = evutil_load_windows_system_library_(\n\t\t\tTEXT(\"iphlpapi.dll\")))) {\n\t\tlog(EVDNS_LOG_WARN, \"Could not open iphlpapi.dll\");\n\t\tstatus = -1;\n\t\tgoto done;\n\t}\n\tif (!(fn = (GetNetworkParams_fn_t) GetProcAddress(handle, \"GetNetworkParams\"))) {\n\t\tlog(EVDNS_LOG_WARN, \"Could not get address of function.\");\n\t\tstatus = -1;\n\t\tgoto done;\n\t}\n\n\tbuf = mm_malloc(size);\n\tif (!buf) { status = 4; goto done; }\n\tfixed = buf;\n\tr = fn(fixed, &size);\n\tif (r != ERROR_SUCCESS && r != ERROR_BUFFER_OVERFLOW) {\n\t\tstatus = -1;\n\t\tgoto done;\n\t}\n\tif (r != ERROR_SUCCESS) {\n\t\tmm_free(buf);\n\t\tbuf = mm_malloc(size);\n\t\tif (!buf) { status = 4; goto done; }\n\t\tfixed = buf;\n\t\tr = fn(fixed, &size);\n\t\tif (r != ERROR_SUCCESS) {\n\t\t\tlog(EVDNS_LOG_DEBUG, \"fn() failed.\");\n\t\t\tstatus = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tEVUTIL_ASSERT(fixed);\n\tadded_any = 0;\n\tns = &(fixed->DnsServerList);\n\twhile (ns) {\n\t\tr = evdns_nameserver_ip_add_line(base, ns->IpAddress.String);\n\t\tif (r) {\n\t\t\tlog(EVDNS_LOG_DEBUG,\"Could not add nameserver %s to list,error: %d\",\n\t\t\t\t(ns->IpAddress.String),(int)GetLastError());\n\t\t\tstatus = r;\n\t\t} else {\n\t\t\t++added_any;\n\t\t\tlog(EVDNS_LOG_DEBUG,\"Successfully added %s as nameserver\",ns->IpAddress.String);\n\t\t}\n\n\t\tns = ns->Next;\n\t}\n\n\tif (!added_any) {\n\t\tlog(EVDNS_LOG_DEBUG, \"No nameservers added.\");\n\t\tif (status == 0)\n\t\t\tstatus = -1;\n\t} else {\n\t\tstatus = 0;\n\t}\n\n done:\n\tif (buf)\n\t\tmm_free(buf);\n\tif (handle)\n\t\tFreeLibrary(handle);\n\treturn status;\n}\n\nstatic int\nconfig_nameserver_from_reg_key(struct evdns_base *base, HKEY key, const TCHAR *subkey)\n{\n\tchar *buf;\n\tDWORD bufsz = 0, type = 0;\n\tint status = 0;\n\n\tASSERT_LOCKED(base);\n\tif (RegQueryValueEx(key, subkey, 0, &type, NULL, &bufsz)\n\t    != ERROR_MORE_DATA)\n\t\treturn -1;\n\tif (!(buf = mm_malloc(bufsz)))\n\t\treturn -1;\n\n\tif (RegQueryValueEx(key, subkey, 0, &type, (LPBYTE)buf, &bufsz)\n\t    == ERROR_SUCCESS && bufsz > 1) {\n\t\tstatus = evdns_nameserver_ip_add_line(base,buf);\n\t}\n\n\tmm_free(buf);\n\treturn status;\n}\n\n#define SERVICES_KEY TEXT(\"System\\\\CurrentControlSet\\\\Services\\\\\")\n#define WIN_NS_9X_KEY  SERVICES_KEY TEXT(\"VxD\\\\MSTCP\")\n#define WIN_NS_NT_KEY  SERVICES_KEY TEXT(\"Tcpip\\\\Parameters\")\n\nstatic int\nload_nameservers_from_registry(struct evdns_base *base)\n{\n\tint found = 0;\n\tint r;\n#define TRY(k, name) \\\n\tif (!found && config_nameserver_from_reg_key(base,k,TEXT(name)) == 0) { \\\n\t\tlog(EVDNS_LOG_DEBUG,\"Found nameservers in %s/%s\",#k,name); \\\n\t\tfound = 1;\t\t\t\t\t\t\\\n\t} else if (!found) {\t\t\t\t\t\t\\\n\t\tlog(EVDNS_LOG_DEBUG,\"Didn't find nameservers in %s/%s\", \\\n\t\t    #k,#name);\t\t\t\t\t\t\\\n\t}\n\n\tASSERT_LOCKED(base);\n\n\tif (((int)GetVersion()) > 0) { /* NT */\n\t\tHKEY nt_key = 0, interfaces_key = 0;\n\n\t\tif (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY, 0,\n\t\t\t\t KEY_READ, &nt_key) != ERROR_SUCCESS) {\n\t\t\tlog(EVDNS_LOG_DEBUG,\"Couldn't open nt key, %d\",(int)GetLastError());\n\t\t\treturn -1;\n\t\t}\n\t\tr = RegOpenKeyEx(nt_key, TEXT(\"Interfaces\"), 0,\n\t\t\t     KEY_QUERY_VALUE|KEY_ENUMERATE_SUB_KEYS,\n\t\t\t     &interfaces_key);\n\t\tif (r != ERROR_SUCCESS) {\n\t\t\tlog(EVDNS_LOG_DEBUG,\"Couldn't open interfaces key, %d\",(int)GetLastError());\n\t\t\treturn -1;\n\t\t}\n\t\tTRY(nt_key, \"NameServer\");\n\t\tTRY(nt_key, \"DhcpNameServer\");\n\t\tTRY(interfaces_key, \"NameServer\");\n\t\tTRY(interfaces_key, \"DhcpNameServer\");\n\t\tRegCloseKey(interfaces_key);\n\t\tRegCloseKey(nt_key);\n\t} else {\n\t\tHKEY win_key = 0;\n\t\tif (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WIN_NS_9X_KEY, 0,\n\t\t\t\t KEY_READ, &win_key) != ERROR_SUCCESS) {\n\t\t\tlog(EVDNS_LOG_DEBUG, \"Couldn't open registry key, %d\", (int)GetLastError());\n\t\t\treturn -1;\n\t\t}\n\t\tTRY(win_key, \"NameServer\");\n\t\tRegCloseKey(win_key);\n\t}\n\n\tif (found == 0) {\n\t\tlog(EVDNS_LOG_WARN,\"Didn't find any nameservers.\");\n\t}\n\n\treturn found ? 0 : -1;\n#undef TRY\n}\n\nint\nevdns_base_config_windows_nameservers(struct evdns_base *base)\n{\n\tint r;\n\tchar *fname;\n\tif (base == NULL)\n\t\tbase = current_base;\n\tif (base == NULL)\n\t\treturn -1;\n\tEVDNS_LOCK(base);\n\tfname = evdns_get_default_hosts_filename();\n\tlog(EVDNS_LOG_DEBUG, \"Loading hosts entries from %s\", fname);\n\tevdns_base_load_hosts(base, fname);\n\tif (fname)\n\t\tmm_free(fname);\n\n\tif (load_nameservers_with_getnetworkparams(base) == 0) {\n\t\tEVDNS_UNLOCK(base);\n\t\treturn 0;\n\t}\n\tr = load_nameservers_from_registry(base);\n\n\tEVDNS_UNLOCK(base);\n\treturn r;\n}\n\nint\nevdns_config_windows_nameservers(void)\n{\n\tif (!current_base) {\n\t\tcurrent_base = evdns_base_new(NULL, 1);\n\t\treturn current_base == NULL ? -1 : 0;\n\t} else {\n\t\treturn evdns_base_config_windows_nameservers(current_base);\n\t}\n}\n#endif\n\nstruct evdns_base *\nevdns_base_new(struct event_base *event_base, int flags)\n{\n\tstruct evdns_base *base;\n\n\tif (evutil_secure_rng_init() < 0) {\n\t\tlog(EVDNS_LOG_WARN, \"Unable to seed random number generator; \"\n\t\t    \"DNS can't run.\");\n\t\treturn NULL;\n\t}\n\n\t/* Give the evutil library a hook into its evdns-enabled\n\t * functionality.  We can't just call evdns_getaddrinfo directly or\n\t * else libevent-core will depend on libevent-extras. */\n\tevutil_set_evdns_getaddrinfo_fn_(evdns_getaddrinfo);\n\tevutil_set_evdns_getaddrinfo_cancel_fn_(evdns_getaddrinfo_cancel);\n\n\tbase = mm_malloc(sizeof(struct evdns_base));\n\tif (base == NULL)\n\t\treturn (NULL);\n\tmemset(base, 0, sizeof(struct evdns_base));\n\tbase->req_waiting_head = NULL;\n\n\tEVTHREAD_ALLOC_LOCK(base->lock, EVTHREAD_LOCKTYPE_RECURSIVE);\n\tEVDNS_LOCK(base);\n\n\t/* Set max requests inflight and allocate req_heads. */\n\tbase->req_heads = NULL;\n\n\tevdns_base_set_max_requests_inflight(base, 64);\n\n\tbase->server_head = NULL;\n\tbase->event_base = event_base;\n\tbase->global_good_nameservers = base->global_requests_inflight =\n\t\tbase->global_requests_waiting = 0;\n\n\tbase->global_timeout.tv_sec = 5;\n\tbase->global_timeout.tv_usec = 0;\n\tbase->global_max_reissues = 1;\n\tbase->global_max_retransmits = 3;\n\tbase->global_max_nameserver_timeout = 3;\n\tbase->global_search_state = NULL;\n\tbase->global_randomize_case = 1;\n\tbase->global_getaddrinfo_allow_skew.tv_sec = 3;\n\tbase->global_getaddrinfo_allow_skew.tv_usec = 0;\n\tbase->global_nameserver_probe_initial_timeout.tv_sec = 10;\n\tbase->global_nameserver_probe_initial_timeout.tv_usec = 0;\n\n\tTAILQ_INIT(&base->hostsdb);\n\n#define EVDNS_BASE_ALL_FLAGS (0x8001)\n\tif (flags & ~EVDNS_BASE_ALL_FLAGS) {\n\t\tflags = EVDNS_BASE_INITIALIZE_NAMESERVERS;\n\t\tlog(EVDNS_LOG_WARN,\n\t\t    \"Unrecognized flag passed to evdns_base_new(). Assuming \"\n\t\t    \"you meant EVDNS_BASE_INITIALIZE_NAMESERVERS.\");\n\t}\n#undef EVDNS_BASE_ALL_FLAGS\n\n\tif (flags & EVDNS_BASE_INITIALIZE_NAMESERVERS) {\n\t\tint r;\n#ifdef _WIN32\n\t\tr = evdns_base_config_windows_nameservers(base);\n#else\n\t\tr = evdns_base_resolv_conf_parse(base, DNS_OPTIONS_ALL, \"/etc/resolv.conf\");\n#endif\n\t\tif (r == -1) {\n\t\t\tevdns_base_free_and_unlock(base, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (flags & EVDNS_BASE_DISABLE_WHEN_INACTIVE) {\n\t\tbase->disable_when_inactive = 1;\n\t}\n\n\tEVDNS_UNLOCK(base);\n\treturn base;\n}\n\nint\nevdns_init(void)\n{\n\tstruct evdns_base *base = evdns_base_new(NULL, 1);\n\tif (base) {\n\t\tcurrent_base = base;\n\t\treturn 0;\n\t} else {\n\t\treturn -1;\n\t}\n}\n\nconst char *\nevdns_err_to_string(int err)\n{\n    switch (err) {\n\tcase DNS_ERR_NONE: return \"no error\";\n\tcase DNS_ERR_FORMAT: return \"misformatted query\";\n\tcase DNS_ERR_SERVERFAILED: return \"server failed\";\n\tcase DNS_ERR_NOTEXIST: return \"name does not exist\";\n\tcase DNS_ERR_NOTIMPL: return \"query not implemented\";\n\tcase DNS_ERR_REFUSED: return \"refused\";\n\n\tcase DNS_ERR_TRUNCATED: return \"reply truncated or ill-formed\";\n\tcase DNS_ERR_UNKNOWN: return \"unknown\";\n\tcase DNS_ERR_TIMEOUT: return \"request timed out\";\n\tcase DNS_ERR_SHUTDOWN: return \"dns subsystem shut down\";\n\tcase DNS_ERR_CANCEL: return \"dns request canceled\";\n\tcase DNS_ERR_NODATA: return \"no records in the reply\";\n\tdefault: return \"[Unknown error code]\";\n    }\n}\n\nstatic void\nevdns_nameserver_free(struct nameserver *server)\n{\n\tif (server->socket >= 0)\n\t\tevutil_closesocket(server->socket);\n\t(void) event_del(&server->event);\n\tevent_debug_unassign(&server->event);\n\tif (server->state == 0)\n\t\t(void) event_del(&server->timeout_event);\n\tif (server->probe_request) {\n\t\tevdns_cancel_request(server->base, server->probe_request);\n\t\tserver->probe_request = NULL;\n\t}\n\tevent_debug_unassign(&server->timeout_event);\n\tmm_free(server);\n}\n\nstatic void\nevdns_base_free_and_unlock(struct evdns_base *base, int fail_requests)\n{\n\tstruct nameserver *server, *server_next;\n\tstruct search_domain *dom, *dom_next;\n\tint i;\n\n\t/* Requires that we hold the lock. */\n\n\t/* TODO(nickm) we might need to refcount here. */\n\n\tfor (i = 0; i < base->n_req_heads; ++i) {\n\t\twhile (base->req_heads[i]) {\n\t\t\tif (fail_requests)\n\t\t\t\treply_schedule_callback(base->req_heads[i], 0, DNS_ERR_SHUTDOWN, NULL);\n\t\t\trequest_finished(base->req_heads[i], &REQ_HEAD(base, base->req_heads[i]->trans_id), 1);\n\t\t}\n\t}\n\twhile (base->req_waiting_head) {\n\t\tif (fail_requests)\n\t\t\treply_schedule_callback(base->req_waiting_head, 0, DNS_ERR_SHUTDOWN, NULL);\n\t\trequest_finished(base->req_waiting_head, &base->req_waiting_head, 1);\n\t}\n\tbase->global_requests_inflight = base->global_requests_waiting = 0;\n\n\tfor (server = base->server_head; server; server = server_next) {\n\t\tserver_next = server->next;\n\t\t/** already done something before */\n\t\tserver->probe_request = NULL;\n\t\tevdns_nameserver_free(server);\n\t\tif (server_next == base->server_head)\n\t\t\tbreak;\n\t}\n\tbase->server_head = NULL;\n\tbase->global_good_nameservers = 0;\n\n\tif (base->global_search_state) {\n\t\tfor (dom = base->global_search_state->head; dom; dom = dom_next) {\n\t\t\tdom_next = dom->next;\n\t\t\tmm_free(dom);\n\t\t}\n\t\tmm_free(base->global_search_state);\n\t\tbase->global_search_state = NULL;\n\t}\n\n\t{\n\t\tstruct hosts_entry *victim;\n\t\twhile ((victim = TAILQ_FIRST(&base->hostsdb))) {\n\t\t\tTAILQ_REMOVE(&base->hostsdb, victim, next);\n\t\t\tmm_free(victim);\n\t\t}\n\t}\n\n\tmm_free(base->req_heads);\n\n\tEVDNS_UNLOCK(base);\n\tEVTHREAD_FREE_LOCK(base->lock, EVTHREAD_LOCKTYPE_RECURSIVE);\n\n\tmm_free(base);\n}\n\nvoid\nevdns_base_free(struct evdns_base *base, int fail_requests)\n{\n\tEVDNS_LOCK(base);\n\tevdns_base_free_and_unlock(base, fail_requests);\n}\n\nvoid\nevdns_base_clear_host_addresses(struct evdns_base *base)\n{\n\tstruct hosts_entry *victim;\n\tEVDNS_LOCK(base);\n\twhile ((victim = TAILQ_FIRST(&base->hostsdb))) {\n\t\tTAILQ_REMOVE(&base->hostsdb, victim, next);\n\t\tmm_free(victim);\n\t}\n\tEVDNS_UNLOCK(base);\n}\n\nvoid\nevdns_shutdown(int fail_requests)\n{\n\tif (current_base) {\n\t\tstruct evdns_base *b = current_base;\n\t\tcurrent_base = NULL;\n\t\tevdns_base_free(b, fail_requests);\n\t}\n\tevdns_log_fn = NULL;\n}\n\nstatic int\nevdns_base_parse_hosts_line(struct evdns_base *base, char *line)\n{\n\tchar *strtok_state;\n\tstatic const char *const delims = \" \\t\";\n\tchar *const addr = strtok_r(line, delims, &strtok_state);\n\tchar *hostname, *hash;\n\tstruct sockaddr_storage ss;\n\tint socklen = sizeof(ss);\n\tASSERT_LOCKED(base);\n\n#define NEXT_TOKEN strtok_r(NULL, delims, &strtok_state)\n\n\tif (!addr || *addr == '#')\n\t\treturn 0;\n\n\tmemset(&ss, 0, sizeof(ss));\n\tif (evutil_parse_sockaddr_port(addr, (struct sockaddr*)&ss, &socklen)<0)\n\t\treturn -1;\n\tif (socklen > (int)sizeof(struct sockaddr_in6))\n\t\treturn -1;\n\n\tif (sockaddr_getport((struct sockaddr*)&ss))\n\t\treturn -1;\n\n\twhile ((hostname = NEXT_TOKEN)) {\n\t\tstruct hosts_entry *he;\n\t\tsize_t namelen;\n\t\tif ((hash = strchr(hostname, '#'))) {\n\t\t\tif (hash == hostname)\n\t\t\t\treturn 0;\n\t\t\t*hash = '\\0';\n\t\t}\n\n\t\tnamelen = strlen(hostname);\n\n\t\the = mm_calloc(1, sizeof(struct hosts_entry)+namelen);\n\t\tif (!he)\n\t\t\treturn -1;\n\t\tEVUTIL_ASSERT(socklen <= (int)sizeof(he->addr));\n\t\tmemcpy(&he->addr, &ss, socklen);\n\t\tmemcpy(he->hostname, hostname, namelen+1);\n\t\the->addrlen = socklen;\n\n\t\tTAILQ_INSERT_TAIL(&base->hostsdb, he, next);\n\n\t\tif (hash)\n\t\t\treturn 0;\n\t}\n\n\treturn 0;\n#undef NEXT_TOKEN\n}\n\nstatic int\nevdns_base_load_hosts_impl(struct evdns_base *base, const char *hosts_fname)\n{\n\tchar *str=NULL, *cp, *eol;\n\tsize_t len;\n\tint err=0;\n\n\tASSERT_LOCKED(base);\n\n\tif (hosts_fname == NULL ||\n\t    (err = evutil_read_file_(hosts_fname, &str, &len, 0)) < 0) {\n\t\tchar tmp[64];\n\t\tstrlcpy(tmp, \"127.0.0.1   localhost\", sizeof(tmp));\n\t\tevdns_base_parse_hosts_line(base, tmp);\n\t\tstrlcpy(tmp, \"::1   localhost\", sizeof(tmp));\n\t\tevdns_base_parse_hosts_line(base, tmp);\n\t\treturn err ? -1 : 0;\n\t}\n\n\t/* This will break early if there is a NUL in the hosts file.\n\t * Probably not a problem.*/\n\tcp = str;\n\tfor (;;) {\n\t\teol = strchr(cp, '\\n');\n\n\t\tif (eol) {\n\t\t\t*eol = '\\0';\n\t\t\tevdns_base_parse_hosts_line(base, cp);\n\t\t\tcp = eol+1;\n\t\t} else {\n\t\t\tevdns_base_parse_hosts_line(base, cp);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmm_free(str);\n\treturn 0;\n}\n\nint\nevdns_base_load_hosts(struct evdns_base *base, const char *hosts_fname)\n{\n\tint res;\n\tif (!base)\n\t\tbase = current_base;\n\tEVDNS_LOCK(base);\n\tres = evdns_base_load_hosts_impl(base, hosts_fname);\n\tEVDNS_UNLOCK(base);\n\treturn res;\n}\n\n/* A single request for a getaddrinfo, either v4 or v6. */\nstruct getaddrinfo_subrequest {\n\tstruct evdns_request *r;\n\tev_uint32_t type;\n};\n\n/* State data used to implement an in-progress getaddrinfo. */\nstruct evdns_getaddrinfo_request {\n\tstruct evdns_base *evdns_base;\n\t/* Copy of the modified 'hints' data that we'll use to build\n\t * answers. */\n\tstruct evutil_addrinfo hints;\n\t/* The callback to invoke when we're done */\n\tevdns_getaddrinfo_cb user_cb;\n\t/* User-supplied data to give to the callback. */\n\tvoid *user_data;\n\t/* The port to use when building sockaddrs. */\n\tev_uint16_t port;\n\t/* The sub_request for an A record (if any) */\n\tstruct getaddrinfo_subrequest ipv4_request;\n\t/* The sub_request for an AAAA record (if any) */\n\tstruct getaddrinfo_subrequest ipv6_request;\n\n\t/* The cname result that we were told (if any) */\n\tchar *cname_result;\n\n\t/* If we have one request answered and one request still inflight,\n\t * then this field holds the answer from the first request... */\n\tstruct evutil_addrinfo *pending_result;\n\t/* And this event is a timeout that will tell us to cancel the second\n\t * request if it's taking a long time. */\n\tstruct event timeout;\n\n\t/* And this field holds the error code from the first request... */\n\tint pending_error;\n\t/* If this is set, the user canceled this request. */\n\tunsigned user_canceled : 1;\n\t/* If this is set, the user can no longer cancel this request; we're\n\t * just waiting for the free. */\n\tunsigned request_done : 1;\n};\n\n/* Convert an evdns errors to the equivalent getaddrinfo error. */\nstatic int\nevdns_err_to_getaddrinfo_err(int e1)\n{\n\t/* XXX Do this better! */\n\tif (e1 == DNS_ERR_NONE)\n\t\treturn 0;\n\telse if (e1 == DNS_ERR_NOTEXIST)\n\t\treturn EVUTIL_EAI_NONAME;\n\telse\n\t\treturn EVUTIL_EAI_FAIL;\n}\n\n/* Return the more informative of two getaddrinfo errors. */\nstatic int\ngetaddrinfo_merge_err(int e1, int e2)\n{\n\t/* XXXX be cleverer here. */\n\tif (e1 == 0)\n\t\treturn e2;\n\telse\n\t\treturn e1;\n}\n\nstatic void\nfree_getaddrinfo_request(struct evdns_getaddrinfo_request *data)\n{\n\t/* DO NOT CALL this if either of the requests is pending.  Only once\n\t * both callbacks have been invoked is it safe to free the request */\n\tif (data->pending_result)\n\t\tevutil_freeaddrinfo(data->pending_result);\n\tif (data->cname_result)\n\t\tmm_free(data->cname_result);\n\tevent_del(&data->timeout);\n\tmm_free(data);\n\treturn;\n}\n\nstatic void\nadd_cname_to_reply(struct evdns_getaddrinfo_request *data,\n    struct evutil_addrinfo *ai)\n{\n\tif (data->cname_result && ai) {\n\t\tai->ai_canonname = data->cname_result;\n\t\tdata->cname_result = NULL;\n\t}\n}\n\n/* Callback: invoked when one request in a mixed-format A/AAAA getaddrinfo\n * request has finished, but the other one took too long to answer. Pass\n * along the answer we got, and cancel the other request.\n */\nstatic void\nevdns_getaddrinfo_timeout_cb(evutil_socket_t fd, short what, void *ptr)\n{\n\tint v4_timedout = 0, v6_timedout = 0;\n\tstruct evdns_getaddrinfo_request *data = ptr;\n\n\t/* Cancel any pending requests, and note which one */\n\tif (data->ipv4_request.r) {\n\t\t/* XXXX This does nothing if the request's callback is already\n\t\t * running (pending_cb is set). */\n\t\tevdns_cancel_request(NULL, data->ipv4_request.r);\n\t\tv4_timedout = 1;\n\t\tEVDNS_LOCK(data->evdns_base);\n\t\t++data->evdns_base->getaddrinfo_ipv4_timeouts;\n\t\tEVDNS_UNLOCK(data->evdns_base);\n\t}\n\tif (data->ipv6_request.r) {\n\t\t/* XXXX This does nothing if the request's callback is already\n\t\t * running (pending_cb is set). */\n\t\tevdns_cancel_request(NULL, data->ipv6_request.r);\n\t\tv6_timedout = 1;\n\t\tEVDNS_LOCK(data->evdns_base);\n\t\t++data->evdns_base->getaddrinfo_ipv6_timeouts;\n\t\tEVDNS_UNLOCK(data->evdns_base);\n\t}\n\n\t/* We only use this timeout callback when we have an answer for\n\t * one address. */\n\tEVUTIL_ASSERT(!v4_timedout || !v6_timedout);\n\n\t/* Report the outcome of the other request that didn't time out. */\n\tif (data->pending_result) {\n\t\tadd_cname_to_reply(data, data->pending_result);\n\t\tdata->user_cb(0, data->pending_result, data->user_data);\n\t\tdata->pending_result = NULL;\n\t} else {\n\t\tint e = data->pending_error;\n\t\tif (!e)\n\t\t\te = EVUTIL_EAI_AGAIN;\n\t\tdata->user_cb(e, NULL, data->user_data);\n\t}\n\n\tdata->user_cb = NULL; /* prevent double-call if evdns callbacks are\n\t\t\t       * in-progress. XXXX It would be better if this\n\t\t\t       * weren't necessary. */\n\n\tif (!v4_timedout && !v6_timedout) {\n\t\t/* should be impossible? XXXX */\n\t\tfree_getaddrinfo_request(data);\n\t}\n}\n\nstatic int\nevdns_getaddrinfo_set_timeout(struct evdns_base *evdns_base,\n    struct evdns_getaddrinfo_request *data)\n{\n\treturn event_add(&data->timeout, &evdns_base->global_getaddrinfo_allow_skew);\n}\n\nstatic inline int\nevdns_result_is_answer(int result)\n{\n\treturn (result != DNS_ERR_NOTIMPL && result != DNS_ERR_REFUSED &&\n\t    result != DNS_ERR_SERVERFAILED && result != DNS_ERR_CANCEL);\n}\n\nstatic void\nevdns_getaddrinfo_gotresolve(int result, char type, int count,\n    int ttl, void *addresses, void *arg)\n{\n\tint i;\n\tstruct getaddrinfo_subrequest *req = arg;\n\tstruct getaddrinfo_subrequest *other_req;\n\tstruct evdns_getaddrinfo_request *data;\n\n\tstruct evutil_addrinfo *res;\n\n\tstruct sockaddr_in sin;\n\tstruct sockaddr_in6 sin6;\n\tstruct sockaddr *sa;\n\tint socklen, addrlen;\n\tvoid *addrp;\n\tint err;\n\tint user_canceled;\n\n\tEVUTIL_ASSERT(req->type == DNS_IPv4_A || req->type == DNS_IPv6_AAAA);\n\tif (req->type == DNS_IPv4_A) {\n\t\tdata = EVUTIL_UPCAST(req, struct evdns_getaddrinfo_request, ipv4_request);\n\t\tother_req = &data->ipv6_request;\n\t} else {\n\t\tdata = EVUTIL_UPCAST(req, struct evdns_getaddrinfo_request, ipv6_request);\n\t\tother_req = &data->ipv4_request;\n\t}\n\n\t/** Called from evdns_base_free() with @fail_requests == 1 */\n\tif (result != DNS_ERR_SHUTDOWN) {\n\t\tEVDNS_LOCK(data->evdns_base);\n\t\tif (evdns_result_is_answer(result)) {\n\t\t\tif (req->type == DNS_IPv4_A)\n\t\t\t\t++data->evdns_base->getaddrinfo_ipv4_answered;\n\t\t\telse\n\t\t\t\t++data->evdns_base->getaddrinfo_ipv6_answered;\n\t\t}\n\t\tuser_canceled = data->user_canceled;\n\t\tif (other_req->r == NULL)\n\t\t\tdata->request_done = 1;\n\t\tEVDNS_UNLOCK(data->evdns_base);\n\t} else {\n\t\tdata->evdns_base = NULL;\n\t\tuser_canceled = data->user_canceled;\n\t}\n\n\treq->r = NULL;\n\n\tif (result == DNS_ERR_CANCEL && ! user_canceled) {\n\t\t/* Internal cancel request from timeout or internal error.\n\t\t * we already answered the user. */\n\t\tif (other_req->r == NULL)\n\t\t\tfree_getaddrinfo_request(data);\n\t\treturn;\n\t}\n\n\tif (data->user_cb == NULL) {\n\t\t/* We already answered.  XXXX This shouldn't be needed; see\n\t\t * comments in evdns_getaddrinfo_timeout_cb */\n\t\tfree_getaddrinfo_request(data);\n\t\treturn;\n\t}\n\n\tif (result == DNS_ERR_NONE) {\n\t\tif (count == 0)\n\t\t\terr = EVUTIL_EAI_NODATA;\n\t\telse\n\t\t\terr = 0;\n\t} else {\n\t\terr = evdns_err_to_getaddrinfo_err(result);\n\t}\n\n\tif (err) {\n\t\t/* Looks like we got an error. */\n\t\tif (other_req->r) {\n\t\t\t/* The other request is still working; maybe it will\n\t\t\t * succeed. */\n\t\t\t/* XXXX handle failure from set_timeout */\n\t\t\tif (result != DNS_ERR_SHUTDOWN) {\n\t\t\t\tevdns_getaddrinfo_set_timeout(data->evdns_base, data);\n\t\t\t}\n\t\t\tdata->pending_error = err;\n\t\t\treturn;\n\t\t}\n\n\t\tif (user_canceled) {\n\t\t\tdata->user_cb(EVUTIL_EAI_CANCEL, NULL, data->user_data);\n\t\t} else if (data->pending_result) {\n\t\t\t/* If we have an answer waiting, and we weren't\n\t\t\t * canceled, ignore this error. */\n\t\t\tadd_cname_to_reply(data, data->pending_result);\n\t\t\tdata->user_cb(0, data->pending_result, data->user_data);\n\t\t\tdata->pending_result = NULL;\n\t\t} else {\n\t\t\tif (data->pending_error)\n\t\t\t\terr = getaddrinfo_merge_err(err,\n\t\t\t\t    data->pending_error);\n\t\t\tdata->user_cb(err, NULL, data->user_data);\n\t\t}\n\t\tfree_getaddrinfo_request(data);\n\t\treturn;\n\t} else if (user_canceled) {\n\t\tif (other_req->r) {\n\t\t\t/* The other request is still working; let it hit this\n\t\t\t * callback with EVUTIL_EAI_CANCEL callback and report\n\t\t\t * the failure. */\n\t\t\treturn;\n\t\t}\n\t\tdata->user_cb(EVUTIL_EAI_CANCEL, NULL, data->user_data);\n\t\tfree_getaddrinfo_request(data);\n\t\treturn;\n\t}\n\n\t/* Looks like we got some answers. We should turn them into addrinfos\n\t * and then either queue those or return them all. */\n\tEVUTIL_ASSERT(type == DNS_IPv4_A || type == DNS_IPv6_AAAA);\n\n\tif (type == DNS_IPv4_A) {\n\t\tmemset(&sin, 0, sizeof(sin));\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = htons(data->port);\n\n\t\tsa = (struct sockaddr *)&sin;\n\t\tsocklen = sizeof(sin);\n\t\taddrlen = 4;\n\t\taddrp = &sin.sin_addr.s_addr;\n\t} else {\n\t\tmemset(&sin6, 0, sizeof(sin6));\n\t\tsin6.sin6_family = AF_INET6;\n\t\tsin6.sin6_port = htons(data->port);\n\n\t\tsa = (struct sockaddr *)&sin6;\n\t\tsocklen = sizeof(sin6);\n\t\taddrlen = 16;\n\t\taddrp = &sin6.sin6_addr.s6_addr;\n\t}\n\n\tres = NULL;\n\tfor (i=0; i < count; ++i) {\n\t\tstruct evutil_addrinfo *ai;\n\t\tmemcpy(addrp, ((char*)addresses)+i*addrlen, addrlen);\n\t\tai = evutil_new_addrinfo_(sa, socklen, &data->hints);\n\t\tif (!ai) {\n\t\t\tif (other_req->r) {\n\t\t\t\tevdns_cancel_request(NULL, other_req->r);\n\t\t\t}\n\t\t\tdata->user_cb(EVUTIL_EAI_MEMORY, NULL, data->user_data);\n\t\t\tif (res)\n\t\t\t\tevutil_freeaddrinfo(res);\n\n\t\t\tif (other_req->r == NULL)\n\t\t\t\tfree_getaddrinfo_request(data);\n\t\t\treturn;\n\t\t}\n\t\tres = evutil_addrinfo_append_(res, ai);\n\t}\n\n\tif (other_req->r) {\n\t\t/* The other request is still in progress; wait for it */\n\t\t/* XXXX handle failure from set_timeout */\n\t\tevdns_getaddrinfo_set_timeout(data->evdns_base, data);\n\t\tdata->pending_result = res;\n\t\treturn;\n\t} else {\n\t\t/* The other request is done or never started; append its\n\t\t * results (if any) and return them. */\n\t\tif (data->pending_result) {\n\t\t\tif (req->type == DNS_IPv4_A)\n\t\t\t\tres = evutil_addrinfo_append_(res,\n\t\t\t\t    data->pending_result);\n\t\t\telse\n\t\t\t\tres = evutil_addrinfo_append_(\n\t\t\t\t    data->pending_result, res);\n\t\t\tdata->pending_result = NULL;\n\t\t}\n\n\t\t/* Call the user callback. */\n\t\tadd_cname_to_reply(data, res);\n\t\tdata->user_cb(0, res, data->user_data);\n\n\t\t/* Free data. */\n\t\tfree_getaddrinfo_request(data);\n\t}\n}\n\nstatic struct hosts_entry *\nfind_hosts_entry(struct evdns_base *base, const char *hostname,\n    struct hosts_entry *find_after)\n{\n\tstruct hosts_entry *e;\n\n\tif (find_after)\n\t\te = TAILQ_NEXT(find_after, next);\n\telse\n\t\te = TAILQ_FIRST(&base->hostsdb);\n\n\tfor (; e; e = TAILQ_NEXT(e, next)) {\n\t\tif (!evutil_ascii_strcasecmp(e->hostname, hostname))\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}\n\nstatic int\nevdns_getaddrinfo_fromhosts(struct evdns_base *base,\n    const char *nodename, struct evutil_addrinfo *hints, ev_uint16_t port,\n    struct evutil_addrinfo **res)\n{\n\tint n_found = 0;\n\tstruct hosts_entry *e;\n\tstruct evutil_addrinfo *ai=NULL;\n\tint f = hints->ai_family;\n\n\tEVDNS_LOCK(base);\n\tfor (e = find_hosts_entry(base, nodename, NULL); e;\n\t    e = find_hosts_entry(base, nodename, e)) {\n\t\tstruct evutil_addrinfo *ai_new;\n\t\t++n_found;\n\t\tif ((e->addr.sa.sa_family == AF_INET && f == PF_INET6) ||\n\t\t    (e->addr.sa.sa_family == AF_INET6 && f == PF_INET))\n\t\t\tcontinue;\n\t\tai_new = evutil_new_addrinfo_(&e->addr.sa, e->addrlen, hints);\n\t\tif (!ai_new) {\n\t\t\tn_found = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tsockaddr_setport(ai_new->ai_addr, port);\n\t\tai = evutil_addrinfo_append_(ai, ai_new);\n\t}\n\tEVDNS_UNLOCK(base);\nout:\n\tif (n_found) {\n\t\t/* Note that we return an empty answer if we found entries for\n\t\t * this hostname but none were of the right address type. */\n\t\t*res = ai;\n\t\treturn 0;\n\t} else {\n\t\tif (ai)\n\t\t\tevutil_freeaddrinfo(ai);\n\t\treturn -1;\n\t}\n}\n\nstruct evdns_getaddrinfo_request *\nevdns_getaddrinfo(struct evdns_base *dns_base,\n    const char *nodename, const char *servname,\n    const struct evutil_addrinfo *hints_in,\n    evdns_getaddrinfo_cb cb, void *arg)\n{\n\tstruct evdns_getaddrinfo_request *data;\n\tstruct evutil_addrinfo hints;\n\tstruct evutil_addrinfo *res = NULL;\n\tint err;\n\tint port = 0;\n\tint want_cname = 0;\n\n\tif (!dns_base) {\n\t\tdns_base = current_base;\n\t\tif (!dns_base) {\n\t\t\tlog(EVDNS_LOG_WARN,\n\t\t\t    \"Call to getaddrinfo_async with no \"\n\t\t\t    \"evdns_base configured.\");\n\t\t\tcb(EVUTIL_EAI_FAIL, NULL, arg); /* ??? better error? */\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* If we _must_ answer this immediately, do so. */\n\tif ((hints_in && (hints_in->ai_flags & EVUTIL_AI_NUMERICHOST))) {\n\t\tres = NULL;\n\t\terr = evutil_getaddrinfo(nodename, servname, hints_in, &res);\n\t\tcb(err, res, arg);\n\t\treturn NULL;\n\t}\n\n\tif (hints_in) {\n\t\tmemcpy(&hints, hints_in, sizeof(hints));\n\t} else {\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = PF_UNSPEC;\n\t}\n\n\tevutil_adjust_hints_for_addrconfig_(&hints);\n\n\t/* Now try to see if we _can_ answer immediately. */\n\t/* (It would be nice to do this by calling getaddrinfo directly, with\n\t * AI_NUMERICHOST, on plaforms that have it, but we can't: there isn't\n\t * a reliable way to distinguish the \"that wasn't a numeric host!\" case\n\t * from any other EAI_NONAME cases.) */\n\terr = evutil_getaddrinfo_common_(nodename, servname, &hints, &res, &port);\n\tif (err != EVUTIL_EAI_NEED_RESOLVE) {\n\t\tcb(err, res, arg);\n\t\treturn NULL;\n\t}\n\n\t/* If there is an entry in the hosts file, we should give it now. */\n\tif (!evdns_getaddrinfo_fromhosts(dns_base, nodename, &hints, port, &res)) {\n\t\tcb(0, res, arg);\n\t\treturn NULL;\n\t}\n\n\t/* Okay, things are serious now. We're going to need to actually\n\t * launch a request.\n\t */\n\tdata = mm_calloc(1,sizeof(struct evdns_getaddrinfo_request));\n\tif (!data) {\n\t\tcb(EVUTIL_EAI_MEMORY, NULL, arg);\n\t\treturn NULL;\n\t}\n\n\tmemcpy(&data->hints, &hints, sizeof(data->hints));\n\tdata->port = (ev_uint16_t)port;\n\tdata->ipv4_request.type = DNS_IPv4_A;\n\tdata->ipv6_request.type = DNS_IPv6_AAAA;\n\tdata->user_cb = cb;\n\tdata->user_data = arg;\n\tdata->evdns_base = dns_base;\n\n\twant_cname = (hints.ai_flags & EVUTIL_AI_CANONNAME);\n\n\t/* If we are asked for a PF_UNSPEC address, we launch two requests in\n\t * parallel: one for an A address and one for an AAAA address.  We\n\t * can't send just one request, since many servers only answer one\n\t * question per DNS request.\n\t *\n\t * Once we have the answer to one request, we allow for a short\n\t * timeout before we report it, to see if the other one arrives.  If\n\t * they both show up in time, then we report both the answers.\n\t *\n\t * If too many addresses of one type time out or fail, we should stop\n\t * launching those requests. (XXX we don't do that yet.)\n\t */\n\n\tif (hints.ai_family != PF_INET6) {\n\t\tlog(EVDNS_LOG_DEBUG, \"Sending request for %s on ipv4 as %p\",\n\t\t    nodename, &data->ipv4_request);\n\n\t\tdata->ipv4_request.r = evdns_base_resolve_ipv4(dns_base,\n\t\t    nodename, 0, evdns_getaddrinfo_gotresolve,\n\t\t    &data->ipv4_request);\n\t\tif (want_cname && data->ipv4_request.r)\n\t\t\tdata->ipv4_request.r->current_req->put_cname_in_ptr =\n\t\t\t    &data->cname_result;\n\t}\n\tif (hints.ai_family != PF_INET) {\n\t\tlog(EVDNS_LOG_DEBUG, \"Sending request for %s on ipv6 as %p\",\n\t\t    nodename, &data->ipv6_request);\n\n\t\tdata->ipv6_request.r = evdns_base_resolve_ipv6(dns_base,\n\t\t    nodename, 0, evdns_getaddrinfo_gotresolve,\n\t\t    &data->ipv6_request);\n\t\tif (want_cname && data->ipv6_request.r)\n\t\t\tdata->ipv6_request.r->current_req->put_cname_in_ptr =\n\t\t\t    &data->cname_result;\n\t}\n\n\tevtimer_assign(&data->timeout, dns_base->event_base,\n\t    evdns_getaddrinfo_timeout_cb, data);\n\n\tif (data->ipv4_request.r || data->ipv6_request.r) {\n\t\treturn data;\n\t} else {\n\t\tmm_free(data);\n\t\tcb(EVUTIL_EAI_FAIL, NULL, arg);\n\t\treturn NULL;\n\t}\n}\n\nvoid\nevdns_getaddrinfo_cancel(struct evdns_getaddrinfo_request *data)\n{\n\tEVDNS_LOCK(data->evdns_base);\n\tif (data->request_done) {\n\t\tEVDNS_UNLOCK(data->evdns_base);\n\t\treturn;\n\t}\n\tevent_del(&data->timeout);\n\tdata->user_canceled = 1;\n\tif (data->ipv4_request.r)\n\t\tevdns_cancel_request(data->evdns_base, data->ipv4_request.r);\n\tif (data->ipv6_request.r)\n\t\tevdns_cancel_request(data->evdns_base, data->ipv6_request.r);\n\tEVDNS_UNLOCK(data->evdns_base);\n}\n"], "filenames": ["evdns.c"], "buggy_code_start_loc": [3178], "buggy_code_end_loc": [3179], "fixing_code_start_loc": [3178], "fixing_code_end_loc": [3183], "type": "CWE-125", "message": "The search_make_new function in evdns.c in libevent before 2.1.6-beta allows attackers to cause a denial of service (out-of-bounds read) via an empty hostname.", "other": {"cve": {"id": "CVE-2016-10197", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-15T15:59:00.500", "lastModified": "2022-01-31T17:38:48.817", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The search_make_new function in evdns.c in libevent before 2.1.6-beta allows attackers to cause a denial of service (out-of-bounds read) via an empty hostname."}, {"lang": "es", "value": "La funci\u00f3n search_make_new en evdns.c en libevent en versiones anteriores a 2.1.6-beta permite a atacantes provocar una denegaci\u00f3n de servicio (fuera de l\u00edmites de lectura) a trav\u00e9s de un nombre de host vac\u00edo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libevent_project:libevent:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.1.5", "matchCriteriaId": "469B6003-26EE-4332-A275-EB8FB208C484"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3789", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/31/17", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/02/02/7", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96014", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1038320", "source": "cve@mitre.org", "tags": ["Broken Link", "Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1104", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1106", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1201", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/libevent/libevent/blob/release-2.1.6-beta/ChangeLog", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/libevent/libevent/commit/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libevent/libevent/issues/332", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201705-01", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libevent/libevent/commit/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e"}}