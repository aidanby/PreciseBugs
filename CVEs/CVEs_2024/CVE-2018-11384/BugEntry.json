{"buggy_code": ["/* radare - LGPL - Copyright 2010-2013 eloi<limited-entropy.com> */\n\n#include <string.h>\n#include <r_types.h>\n#include <r_lib.h>\n#include <r_asm.h>\n#include <r_anal.h>\n\n#define API static\n\n#define LONG_SIZE 4\n#define WORD_SIZE 2\n#define BYTE_SIZE 1\n\n/* missing opcodes :\n - FPU (opcodes 0xF___)\n - opcodes > SH2E\n - cmp*\n - \"special\" regs : PR, SR, VBR, GBR, MACL, MACH\n - T flag handling\n - 0x0___\n - 0x2___\n - 0x3___ ops : cmp*, div, dmul\n - 0x4___ ops : ld*, st*\n - 0x6___ implement (ext*, pop, swap, ...)\n - 0x8___ implement cmp/eq imm,Rn\n - 0xC___ implement {mova, T flag dest, (disp,GBR) src/dst}\n - 0xF___ FPU: everything\n\n *** complete :\n 0x1___\n 0x5___\n 0x7___\n 0x9___ (XXX verify if @(disp,PC) works)\n 0xA___\n 0xB___\n 0xD___\n 0xE___\n*/\n\n//Macros for different instruction types\n\n#define IS_CLRT(x)\t\t\tx == 0x0008\n#define IS_NOP(x)\t\t\tx == 0x0009\n#define IS_RTS(x)\t\t\tx == 0x000b\n#define IS_SETT(x)\t\t\tx == 0x0018\n#define IS_DIV0U(x)\t\t\tx == 0x0019\n#define IS_SLEEP(x)\t\t\tx == 0x001b\n#define IS_CLRMAC(x)\t\tx == 0x0028\n#define IS_RTE(x)\t\t\tx == 0x002b\n//#define IS_CLRS(x)\n\n#define IS_STCSR1(x)\t\t(((x) & 0xF0CF) == 0x0002)\t\t//mask stc Rn,{SR,GBR,VBR,SSR}\n#define IS_BSRF(x)\t\t\t(x & 0xf0ff) == 0x0003\n#define IS_BRAF(x)\t\t\t(((x) & 0xf0ff) == 0x0023)\n#define IS_MOVB_REG_TO_R0REL(x)\t\t(((x) & 0xF00F) == 0x0004)\n#define IS_MOVW_REG_TO_R0REL(x)\t\t(((x) & 0xF00F) == 0x0005)\n#define IS_MOVL_REG_TO_R0REL(x)\t\t(((x) & 0xF00F) == 0x0006)\n#define IS_MULL(x)\t\t\t(((x) & 0xF00F) == 0x0007)\n#define IS_MOVB_R0REL_TO_REG(x)\t\t(((x) & 0xF00F) == 0x000C)\n#define IS_MOVW_R0REL_TO_REG(x)\t\t(((x) & 0xF00F) == 0x000D)\n#define IS_MOVL_R0REL_TO_REG(x)\t\t(((x) & 0xF00F) == 0x000E)\n//#define IS_MACL(x)\t\t(((x) & 0xF00F) == 0x000F) //complicated !\n#define IS_MOVT(x)\t\t\t(((x) & 0xF0FF) == 0x0029)\n#define IS_STSMAC(x)\t\t(((x) & 0xF0EF) == 0x000A)\t\t//mask sts Rn, MAC*\n#define IS_STSPR(x)\t\t\t(((x) & 0xF0FF) == 0x002A)\n//#define IS_STSFPUL(x)\t\t(((x) & 0xF0FF) == 0x005A)\t\t//FP*: todo maybe someday\n//#define IS_STSFPSCR(x)\t\t(((x) & 0xF0FF) == 0x006A)\n\n#define IS_MOVB_REG_TO_REGREF(x)\t(((x) & 0xF00F) == 0x2000)\n#define IS_MOVW_REG_TO_REGREF(x)\t(((x) & 0xF00F) == 0x2001)\n#define IS_MOVL_REG_TO_REGREF(x)\t(((x) & 0xF00F) == 0x2002)\n//#define invalid?(x)\t(((x) & 0xF00F) == 0x2003)\t//illegal on sh2e\n#define IS_PUSHB(x)\t\t\t(((x) & 0xF00F) == 0x2004)\n#define IS_PUSHW(x)\t\t\t(((x) & 0xF00F) == 0x2005)\n#define IS_PUSHL(x)\t\t\t(((x) & 0xF00F) == 0x2006)\n#define IS_DIV0S(x)\t\t(((x) & 0xF00F) == 0x2007)\n#define IS_TSTRR(x)\t\t\t(((x) & 0xF00F) == 0x2008)\n#define IS_AND_REGS(x)\t\t\t(((x) & 0xF00F) == 0x2009)\n#define IS_XOR_REGS(x)\t\t\t(((x) & 0xF00F) == 0x200A)\n#define IS_OR_REGS(x)\t\t\t(((x) & 0xF00F) == 0x200B)\n#define IS_CMPSTR(x)\t\t\t(((x) & 0xF00F) == 0x200C)\n#define IS_XTRCT(x)\t\t\t(((x) & 0xF00F) == 0x200D)\n#define IS_MULUW(x)\t\t\t(((x) & 0xF00F) == 0x200E)\n#define IS_MULSW(x)\t\t\t(((x) & 0xF00F) == 0x200F)\n\n\n#define IS_CMPEQ(x)\t\t\t(((x) & 0xF00F) == 0x3000)\n//#define invalid?(x)\t\t\t(((x) & 0xF00F) == 0x3001)\n#define IS_CMPHS(x)\t\t\t(((x) & 0xF00F) == 0x3002)\n#define IS_CMPGE(x)\t\t\t(((x) & 0xF00F) == 0x3003)\n#define IS_CMPHI(x)\t\t\t(((x) & 0xF00F) == 0x3006)\n#define IS_CMPGT(x)\t\t\t(((x) & 0xF00F) == 0x3007)\n\n#define IS_DIV1(x)\t\t\t(((x) & 0xF00F) == 0x3004)\n#define IS_DMULU(x)\t\t\t(((x) & 0xF00F) == 0x3005)\n#define IS_DMULS(x)\t\t\t(((x) & 0xF00F) == 0x300D)\n\n#define IS_SUB(x)\t\t\t(((x) & 0xF00F) == 0x3008)\n//#define invalid?(x)\t\t\t(((x) & 0xF00F) == 0x3009)\n#define IS_SUBC(x)\t\t\t(((x) & 0xF00F) == 0x300A)\n#define IS_SUBV(x)\t\t\t(((x) & 0xF00F) == 0x300B)\n#define IS_ADD(x)\t\t\t(((x) & 0xF00F) == 0x300C)\n#define IS_ADDC(x)\t\t\t(((x) & 0xF00F) == 0x300E)\n#define IS_ADDV(x)\t\t\t(((x) & 0xF00F) == 0x300F)\n\n//#define IS_MACW(x)\t\t\t(((x) & 0xF00F) == 0x400F)\t//complex\n#define IS_JSR(x)\t\t\t(((x) & 0xf0ff) == 0x400b)\n#define IS_JMP(x)\t\t\t(((x) & 0xf0ff) == 0x402b)\n#define IS_CMPPL(x)\t\t\t(((x) & 0xf0ff) == 0x4015)\n#define IS_CMPPZ(x)\t\t\t(((x) & 0xf0ff) == 0x4011)\n\n#define IS_LDCSR1(x)\t\t(((x) & 0xF0CF) == 0x400E)\t\t//mask ldc Rn,{SR,GBR,VBR,SSR}\n#define IS_LDCLSR1(x)\t\t(((x) & 0xF0CF) == 0x4007)\t\t//mask ldc.l @Rn+,{SR,GBR,VBR,SSR}\n#define IS_LDSMAC(x)\t\t(((x) & 0xF0EF) == 0x400A)\t\t//mask lds Rn, MAC*\n#define IS_LDSLMAC(x)\t\t(((x) & 0xF0EF) == 0x4006)\t\t//mask lds.l @Rn+, MAC*\n#define IS_LDSPR(x)\t\t\t(((x) & 0xF0FF) == 0x402A)\n#define IS_LDSLPR(x)\t\t(((x) & 0xF0FF) == 0x4026)\n//#define IS_LDSFPUL(x)\t\t(((x) & 0xF0FF) == 0x405A)\t\t//FP*: todo maybe someday\n//#define IS_LDSFPSCR(x)\t\t(((x) & 0xF0FF) == 0x406A)\n//#define IS_LDSLFPUL(x)\t\t(((x) & 0xF0FF) == 0x4066)\n//#define IS_LDSLFPSCR(x)\t\t(((x) & 0xF0FF) == 0x4056)\n#define IS_ROT(x)\t\t\t(((x) & 0xF0DE) == 0x4004)\t\t//mask rot{,c}{l,r}\n//not on sh2e : shad, shld\n\n//#define IS_SHIFT1(x)\t\t(((x) & 0xF0DE) == 0x4000)\t//unused (treated as switch-case)\n//other shl{l,r}{,2,8,16} in switch case also.\n\n#define IS_STSLMAC(x)\t\t(((x) & 0xF0EF) == 0x4002)\t\t//mask sts.l mac*, @-Rn\n#define IS_STCLSR1(x)\t\t(((x) & 0xF0CF) == 0x4003)\t//mask stc.l {SR,GBR,VBR,SSR},@-Rn\n//todo: other stc.l not on sh2e\n#define IS_STSLPR(x)\t\t(((x) & 0xF0FF) == 0x4022)\n//#define IS_STSLFPUL(x)\t\t(((x) & 0xF0FF) == 0x4052)\n//#define IS_STSLFPSCR(x)\t\t(((x) & 0xF0FF) == 0x4062)\n#define IS_TASB(x)\t\t\t(((x) & 0xF0FF) == 0x401B)\n#define IS_DT(x)\t\t\t(((x) & 0xF0FF) == 0x4010)\n\n\n#define IS_MOVB_REGREF_TO_REG(x)\t(((x) & 0xF00F) == 0x6000)\n#define IS_MOVW_REGREF_TO_REG(x)\t(((x) & 0xF00F) == 0x6001)\n#define IS_MOVL_REGREF_TO_REG(x)\t(((x) & 0xF00F) == 0x6002)\n#define IS_MOV_REGS(x)\t\t\t(((x) & 0xf00f) == 0x6003)\n#define IS_MOVB_POP(x)\t\t\t(((x) & 0xF00F) == 0x6004)\n#define IS_MOVW_POP(x)\t\t\t(((x) & 0xF00F) == 0x6005)\n#define IS_MOVL_POP(x)\t\t\t(((x) & 0xF00F) == 0x6006)\n#define IS_NOT(x)\t\t\t(((x) & 0xF00F) == 0x6007)\n#define IS_SWAP(x)\t\t\t(((x) & 0xF00E) == 0x6008)\t//match swap.{b,w}\n#define IS_NEG(x)\t\t\t(((x) & 0xF00E) == 0x600A)\t//match neg{,c}\n#define IS_EXT(x)\t\t(((x) & 0xF00C) == 0x600C)\t//match ext{s,u}.{b,w}\n\n\n#define IS_MOVB_R0_REGDISP(x)\t(((x) & 0xFF00) == 0x8000)\n#define IS_MOVW_R0_REGDISP(x)\t(((x) & 0xFF00) == 0x8100)\n//#define illegal?(x)\t\t(((x) & 0xF900) == 0x8000)\t//match 8{2,3,6,7}00\n#define IS_MOVB_REGDISP_R0(x)\t\t(((x) & 0xFF00) == 0x8400)\n#define IS_MOVW_REGDISP_R0(x)\t\t(((x) & 0xFF00) == 0x8500)\n#define IS_CMPIMM(x)\t\t(((x) & 0xFF00) == 0x8800)\n//#define illegal?(x)\t\t(((x) & 0xFB00) == 0x8A00)\t//match 8{A,E}00\n#define IS_BT(x)\t\t\t(((x) & 0xff00) == 0x8900)\n#define IS_BF(x)\t\t\t(((x) & 0xff00) == 0x8B00)\n#define IS_BTS(x)\t\t\t(((x) & 0xff00) == 0x8D00)\n#define IS_BFS(x)\t\t\t(((x) & 0xff00) == 0x8F00)\n#define IS_BT_OR_BF(x)\t\t\tIS_BT(x)||IS_BTS(x)||IS_BF(x)||IS_BFS(x)\n\n#define IS_MOVB_R0_GBRREF(x)\t(((x) & 0xFF00) == 0xC000)\n#define IS_MOVW_R0_GBRREF(x)\t(((x) & 0xFF00) == 0xC100)\n#define IS_MOVL_R0_GBRREF(x)\t(((x) & 0xFF00) == 0xC200)\n#define IS_TRAP(x)\t\t\t\t(((x) & 0xFF00) == 0xC300)\n#define IS_MOVB_GBRREF_R0(x)\t(((x) & 0xFF00) == 0xC400)\n#define IS_MOVW_GBRREF_R0(x)\t(((x) & 0xFF00) == 0xC500)\n#define IS_MOVL_GBRREF_R0(x)\t(((x) & 0xFF00) == 0xC600)\n#define IS_MOVA_PCREL_R0(x)\t\t(((x) & 0xFF00) == 0xC700)\n#define IS_BINLOGIC_IMM_R0(x)\t(((x) & 0xFC00) == 0xC800)\t//match C{8,9,A,B}00\n#define IS_BINLOGIC_IMM_GBR(x)\t(((x) & 0xFC00) == 0xCC00)\t//match C{C,D,E,F}00 : *.b #imm, @(R0,GBR)\n\n/* Compute PC-relative displacement for branch instructions */\n#define GET_BRA_OFFSET(x)\t((x) & 0x0fff)\n#define GET_BTF_OFFSET(x)\t((x) & 0x00ff)\n\n/* Compute reg nr for BRAF,BSR,BSRF,JMP,JSR */\n#define GET_TARGET_REG(x)\t((x >> 8) & 0x0f)\n#define GET_SOURCE_REG(x)\t((x >> 4) & 0x0f)\n\n/* index of PC reg in regs[] array*/\n#define PC_IDX 16\n\n/* for {bra,bsr} only: (sign-extend 12bit offset)<<1  + PC +4 */\nstatic ut64 disarm_12bit_offset (RAnalOp *op, unsigned int insoff) {\n\tut64 off = insoff;\n\t/* sign extend if higher bit is 1 (0x0800) */\n\tif ((off & 0x0800) == 0x0800)\n\t{\n\t\toff |= ~0xFFF;\n\t}\n\treturn (op->addr) + (off<<1) + 4;\n}\n\n\n/* for bt,bf sign-extended offsets : return PC+4+ (exts.b offset)<<1 */\nstatic ut64 disarm_8bit_offset (ut64 pc, ut32 offs) {\n        /* pc (really, op->addr) is 64 bits, so we need to sign-extend\n         * to 64 bits instead of the 32 the actual CPU does */\n        ut64 off = offs;\n\t/* sign extend if higher bit is 1 (0x08) */\n\tif ((off & 0x80) == 0x80)\n\t{\n\t\toff |= ~0xFF;\n\t}\n\treturn (off<<1) + pc + 4;\n}\n\nstatic char *regs[]={\"r0\",\"r1\",\"r2\",\"r3\",\"r4\",\"r5\",\"r6\",\"r7\",\"r8\",\"r9\",\"r10\",\"r11\",\"r12\",\"r13\",\"r14\",\"r15\",\"pc\"};\n\nstatic RAnalValue *anal_fill_ai_rg(RAnal *anal, int idx) {\n        RAnalValue *ret = r_anal_value_new ();\n        ret->reg = r_reg_get (anal->reg, regs[idx], R_REG_TYPE_GPR);\n        return ret;\n}\n\nstatic RAnalValue *anal_fill_im(RAnal *anal, st32 v) {\n        RAnalValue *ret = r_anal_value_new ();\n        ret->imm = v;\n        return ret;\n}\n\n/* Implements @(disp,Rn) , size=1 for .b, 2 for .w, 4 for .l */\nstatic RAnalValue *anal_fill_reg_disp_mem(RAnal *anal, int reg, st64 delta, st64 size) {\n\tRAnalValue *ret = anal_fill_ai_rg (anal, reg);\n\tret->memref = size;\n\tret->delta = delta*size;\n\treturn ret;\n}\n\n/* Rn */\nstatic RAnalValue *anal_fill_reg_ref(RAnal *anal, int reg, st64 size){\n\tRAnalValue *ret = anal_fill_ai_rg (anal, reg);\n\tret->memref = size;\n\treturn ret;\n}\n\n/* @(R0,Rx) references for all sizes */\nstatic RAnalValue *anal_fill_r0_reg_ref(RAnal *anal, int reg, st64 size){\n\tRAnalValue *ret = anal_fill_ai_rg (anal, 0);\n\tret->regdelta = r_reg_get (anal->reg, regs[reg], R_REG_TYPE_GPR);\n\tret->memref = size;\n\treturn ret;\n}\n\n// @(disp,PC) for size=2(.w), size=4(.l). disp is 0-extended\nstatic RAnalValue *anal_pcrel_disp_mov(RAnal* anal, RAnalOp* op, ut8 disp, int size){\n\tRAnalValue *ret = r_anal_value_new ();\n\tif (size==2) {\n\t\tret->base = op->addr+4;\n\t\tret->delta = disp<<1;\n\t} else {\n\t\tret->base = (op->addr+4) & ~0x03;\n\t\tret->delta = disp<<2;\n\t}\n\n\treturn ret;\n}\n\n//= PC+4+R<reg>\nstatic RAnalValue *anal_regrel_jump(RAnal* anal, RAnalOp* op, ut8 reg){\n\tRAnalValue *ret = r_anal_value_new ();\n\tret->reg = r_reg_get (anal->reg, regs[reg], R_REG_TYPE_GPR);\n\tret->base = op->addr+4;\n\treturn ret;\n}\n\n/* 16 decoder routines, based on 1st nibble value */\nstatic int first_nibble_is_0(RAnal* anal, RAnalOp* op, ut16 code){\n\tif(IS_BSRF(code)) {\n\t\t/* Call 'far' subroutine Rn+PC+4 */\n\t\top->type = R_ANAL_OP_TYPE_UCALL;\n\t\top->delay = 1;\n\t\top->dst = anal_regrel_jump (anal, op, GET_TARGET_REG(code));\n\t} else if (IS_BRAF(code)) {\n\t\t/* Unconditional branch to Rn+PC+4, no delay slot */\n\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\top->dst = anal_regrel_jump (anal, op, GET_TARGET_REG(code));\n\t\top->eob = true;\n\t} else if( IS_RTS(code) ) {\n\t\t/* Ret from subroutine. Returns to pr */\n\t\t//TODO Convert into jump pr?\n\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\top->delay = 1;\n\t\top->eob = true;\n\t} else if (IS_RTE(code)) {\n\t\t//TODO Convert into jmp spc? Indicate ssr->sr as well?\n\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\top->delay = 1;\n\t\top->eob = true;\n\t} else if (IS_MOVB_REG_TO_R0REL(code)) {\t//0000nnnnmmmm0100 mov.b <REG_M>,@(R0,<REG_N>)\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_r0_reg_ref (anal, GET_TARGET_REG(code), BYTE_SIZE);\n\t} else if (IS_MOVW_REG_TO_R0REL(code)) {\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_r0_reg_ref (anal, GET_TARGET_REG(code), WORD_SIZE);\n\t} else if (IS_MOVL_REG_TO_R0REL(code)) {\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_r0_reg_ref(anal, GET_TARGET_REG(code), LONG_SIZE);\n\t} else if (IS_MOVB_R0REL_TO_REG(code)) {\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->src[0] = anal_fill_r0_reg_ref (anal, GET_SOURCE_REG(code), BYTE_SIZE);\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_MOVW_R0REL_TO_REG(code)) {\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->src[0] = anal_fill_r0_reg_ref (anal, GET_SOURCE_REG(code), WORD_SIZE);\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_MOVL_R0REL_TO_REG(code)) {\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->src[0] = anal_fill_r0_reg_ref (anal, GET_SOURCE_REG(code), LONG_SIZE);\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_NOP(code)) {\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t} else if (IS_CLRT(code)) {\n\t\top->type = R_ANAL_OP_TYPE_UNK;\t//TODO : implement flag\n\t} else if (IS_SETT(code)) {\n\t\top->type = R_ANAL_OP_TYPE_UNK;\n\t} else if (IS_CLRMAC(code)) {\n\t\top->type = R_ANAL_OP_TYPE_UNK;\t//TODO : type_mov ?\n\t} else if (IS_DIV0U(code)) {\n\t\top->type = R_ANAL_OP_TYPE_DIV;\n\t} else if (IS_MOVT(code)) {\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t//op->src[0] = \t\t//TODO: figure out how to get T flag from sr reg\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_MULL(code)) {\n\t\top->type = R_ANAL_OP_TYPE_MUL;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\top->src[1] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\t//op->dst = //TODO: figure out how to set MACL + MACH\n\t} else if (IS_SLEEP(code)) {\n\t\top->type = R_ANAL_OP_TYPE_UNK;\n\t} else if (IS_STSMAC(code)) {\t//0000nnnn0000101_ sts MAC*,<REG_N>\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_STCSR1(code)) {\t//0000nnnn00010010 stc {sr,gbr,vbr,ssr},<REG_N>\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\t//todo: plug in src\n\t} else if (IS_STSPR(code)) {\t//0000nnnn00101010 sts PR,<REG_N>\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\t//todo: plug in src\n\t}\n\n\t//TODO Check missing insns, especially STC might be interesting\n\treturn op->size;\n}\n\n//nibble=1; 0001nnnnmmmmi4*4 mov.l <REG_M>,@(<disp>,<REG_N>)\nstatic int movl_reg_rdisp(RAnal* anal, RAnalOp* op, ut16 code){\n\top->type = R_ANAL_OP_TYPE_STORE;\n\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\top->dst = anal_fill_reg_disp_mem (anal, GET_TARGET_REG(code), code&0x0F, LONG_SIZE);\n\treturn op->size;\n}\n\nstatic int first_nibble_is_2(RAnal* anal, RAnalOp* op, ut16 code){\n\tif (IS_MOVB_REG_TO_REGREF(code)) {\t// 0010nnnnmmmm0000 mov.b <REG_M>,@<REG_N>\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_reg_ref (anal, GET_TARGET_REG(code), BYTE_SIZE);\n\t} else if (IS_MOVW_REG_TO_REGREF(code)) {\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_reg_ref (anal, GET_TARGET_REG(code), WORD_SIZE);\n\t} else if (IS_MOVL_REG_TO_REGREF(code)) {\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_reg_ref (anal, GET_TARGET_REG(code), LONG_SIZE);\n\t} else if (IS_AND_REGS(code)) {\n\t\top->type = R_ANAL_OP_TYPE_AND;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_XOR_REGS(code)) {\n\t\top->type = R_ANAL_OP_TYPE_XOR;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_OR_REGS(code)) {\n\t\top->type = R_ANAL_OP_TYPE_OR;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_PUSHB(code) || IS_PUSHW(code) || IS_PUSHL(code)) {\n\t\top->type = R_ANAL_OP_TYPE_PUSH;\n\t\t//TODO Handle 'pushes' (mov Rm,@-Rn)\n\t} else if (IS_TSTRR(code)) {\n\t\top->type = R_ANAL_OP_TYPE_ACMP;\n\t\t//TODO: handle tst reg,reg\n\t} else if (IS_CMPSTR(code)) {\t//0010nnnnmmmm1100 cmp/str <REG_M>,<REG_N>\n\t\top->type = R_ANAL_OP_TYPE_ACMP;\t//maybe not?\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->src[1] = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\t//todo: handle cmp/str byte-per-byte cmp?\n\t} else if (IS_XTRCT(code)) {\t//0010nnnnmmmm1101 xtrct <REG_M>,<REG_N>\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->src[1] = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\t//todo: add details ?\n\t} else if (IS_DIV0S(code)) {\n\t\top->type = R_ANAL_OP_TYPE_DIV;\n\t\t//todo: add details?\n\t} else if (IS_MULUW(code) || IS_MULSW(code)) {\t//0010nnnnmmmm111_ mul{s,u}.w <REG_M>,<REG_N>\n\t\top->type = R_ANAL_OP_TYPE_MUL;\n\t\top->src[0] = anal_fill_ai_rg(anal,GET_SOURCE_REG(code));\n\t\top->src[1] = anal_fill_ai_rg(anal,GET_TARGET_REG(code));\n\t\t//todo: dest=MACL\n\t}\n\n\treturn op->size;\n}\n\n\nstatic int first_nibble_is_3(RAnal* anal, RAnalOp* op, ut16 code){\n\t//TODO Handle carry/overflow , CMP/xx?\n\tif( IS_ADD(code) || IS_ADDC(code) || IS_ADDV(code) ) {\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if ( IS_SUB(code) || IS_SUBC(code) || IS_SUBV(code)) {\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_CMPEQ(code) || IS_CMPGE(code) || IS_CMPGT(code) ||\n\t\t\t\tIS_CMPHI(code) || IS_CMPHS(code)) {\n\t\t//TODO : finish implementing\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\top->src[1] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t} else if (IS_DIV1(code)) {\n\t\top->type = R_ANAL_OP_TYPE_DIV;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\top->src[1] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\t//todo: dest ?\n\t} else if (IS_DMULU(code) || IS_DMULS(code)) {\n\t\top->type = R_ANAL_OP_TYPE_MUL;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->src[1] = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\t//todo: dest=MACL,MACH\n\t}\n\treturn op->size;\n}\n\nstatic int first_nibble_is_4(RAnal* anal, RAnalOp* op, ut16 code){\n\tswitch (code & 0xF0FF) {\n\t\t//todo: implement\n\tcase 0x4020:\t//shal\n\t\top->type = R_ANAL_OP_TYPE_SAL;\n\t\tbreak;\n\tcase 0x4021:\t//shar\n\t\top->type = R_ANAL_OP_TYPE_SAR;\n\t\tbreak;\n\tcase 0x4000:\t//shll\n\tcase 0x4008:\t//shll2\n\tcase 0x4018:\t//shll8\n\tcase 0x4028:\t//shll16\n\t\top->type = R_ANAL_OP_TYPE_SHL;\n\t\tbreak;\n\tcase 0x4001:\t//shlr\n\tcase 0x4009:\t//shlr2\n\tcase 0x4019:\t//shlr8\n\tcase 0x4029:\t//shlr16\n\t\top->type = R_ANAL_OP_TYPE_SHR;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (IS_JSR(code)) {\n\t\top->type = R_ANAL_OP_TYPE_UCALL; //call to reg\n\t\top->delay = 1;\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if ( IS_JMP(code) ) {\n\t\top->type = R_ANAL_OP_TYPE_UJMP; //jmp to reg\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\top->delay = 1;\n\t\top->eob = true;\n\t} else if (IS_CMPPL(code) || IS_CMPPZ(code)) {\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\t//todo: implement\n\t} else if (IS_LDCLSR1(code) || IS_LDSLMAC(code) || IS_LDSLPR(code)) {\n\t\top->type = R_ANAL_OP_TYPE_POP;\n\t\t//todo: implement\n\t} else if (IS_LDCSR1(code) || IS_LDSMAC(code) || IS_LDSPR(code)) {\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t//todo: implement\n\t} else if (IS_ROT(code)) {\n\t\top->type = (code&1)? R_ANAL_OP_TYPE_ROR:R_ANAL_OP_TYPE_ROL;\n\t\t//todo: implement rot* vs rotc*\n\t} else if (IS_STCLSR1(code) || IS_STSLMAC(code) || IS_STSLPR(code)) {\n\t\top->type = R_ANAL_OP_TYPE_PUSH;\n\t\t//todo: implement st*.l *,@-Rn\n\t} else if (IS_TASB(code)) {\n\t\top->type = R_ANAL_OP_TYPE_UNK;\n\t\t//todo: implement\n\t} else if (IS_DT(code)) {\n\t\top->type = R_ANAL_OP_TYPE_UNK;\n\t\t//todo: implement\n\t}\n\treturn op->size;\n}\n\n//nibble=5;  0101nnnnmmmmi4*4 mov.l @(<disp>,<REG_M>),<REG_N>\nstatic int movl_rdisp_reg(RAnal* anal, RAnalOp* op, ut16 code){\n\top->type = R_ANAL_OP_TYPE_LOAD;\n\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\top->src[0] = anal_fill_reg_disp_mem (anal, GET_SOURCE_REG(code), code&0x0F, LONG_SIZE);\n\treturn op->size;\n}\n\n\nstatic int first_nibble_is_6(RAnal* anal, RAnalOp* op, ut16 code){\n\tif (IS_MOV_REGS(code)) {\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_MOVB_REGREF_TO_REG(code)) {\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->src[0] = anal_fill_reg_ref (anal, GET_SOURCE_REG(code), BYTE_SIZE);\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_MOVW_REGREF_TO_REG(code)) {\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->src[0] = anal_fill_reg_ref (anal, GET_SOURCE_REG(code), WORD_SIZE);\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_MOVL_REGREF_TO_REG(code)) {\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->src[0] = anal_fill_reg_ref (anal, GET_SOURCE_REG(code), LONG_SIZE);\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_EXT(code)) {\n\t\t//ext{s,u}.{b,w} instructs. todo : more detail ?\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_MOVB_POP(code) || IS_MOVW_POP(code) || IS_MOVL_POP(code)) {\n\t\t/* 0110nnnnmmmm0100 mov.b @<REG_M>+,<REG_N>*/\n\t\t/* 0110nnnnmmmm0101 mov.w @<REG_M>+,<REG_N>*/\n\t\t/* 0110nnnnmmmm0110 mov.l @<REG_M>+,<REG_N>*/\n\t\top->type = R_ANAL_OP_TYPE_POP;\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\t//todo : op->src for pop = ?\n\t} else if (IS_NEG(code)) {\n\t\t//todo: neg and negc details\n\t\top->type = R_ANAL_OP_TYPE_UNK;\n\t\t/* 0110nnnnmmmm1010 negc*/\n\t\t/* 0110nnnnmmmm1010 neg */\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_NOT(code)) {\n\t\t//todo : details?\n\t\top->type = R_ANAL_OP_TYPE_NOT;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_SWAP(code)) {\n\t\t/* 0110nnnnmmmm1000 swap.b <REG_M>,<REG_N>*/\n\t\t/* 0110nnnnmmmm1001 swap.w <REG_M>,<REG_N>*/\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t//todo : details\n\t}\n\n\treturn op->size;\n}\n\n\n//nibble=7; 0111nnnni8*1.... add #<imm>,<REG_N>\nstatic int add_imm(RAnal* anal, RAnalOp* op, ut16 code){\n\top->type = R_ANAL_OP_TYPE_ADD;\n\top->src[0] = anal_fill_im (anal, (st8)(code&0xFF)); //Casting to (st8) forces sign-extension.\n\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\treturn op->size;\n}\n\nstatic int first_nibble_is_8(RAnal* anal, RAnalOp* op, ut16 code){\n\tif (IS_BT_OR_BF(code)) {\n\t\top->type = R_ANAL_OP_TYPE_CJMP; //Jump if true or jump if false insns\n\t\top->jump = disarm_8bit_offset (op->addr, GET_BTF_OFFSET(code));\n\t\top->fail = op->addr + 2 ;\n\t\top->eob  = true;\n\t\tif (IS_BTS(code) || IS_BFS(code))\n\t\t\top->delay = 1; //Only /S versions have a delay slot\n\t} else if (IS_MOVB_REGDISP_R0(code)) {\n\t\t// 10000100mmmmi4*1 mov.b @(<disp>,<REG_M>),R0\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->dst = anal_fill_ai_rg (anal, 0);\n\t\top->src[0] = anal_fill_reg_disp_mem (anal, GET_SOURCE_REG(code), code&0x0F, BYTE_SIZE);\n\t} else if (IS_MOVW_REGDISP_R0(code)) {\n\t\t// 10000101mmmmi4*2 mov.w @(<disp>,<REG_M>),R0\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->dst = anal_fill_ai_rg (anal, 0);\n\t\top->src[0] = anal_fill_reg_disp_mem (anal, GET_SOURCE_REG(code), code&0x0F, WORD_SIZE);\n\t} else if (IS_CMPIMM(code)) {\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\t//todo : finish implementing\n\t} else if (IS_MOVB_R0_REGDISP(code)) {\n\t\t/* 10000000mmmmi4*1 mov.b R0,@(<disp>,<REG_M>)*/\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, 0);\n\t\top->dst = anal_fill_reg_disp_mem (anal, GET_SOURCE_REG(code), code&0x0F, BYTE_SIZE);\n\t} else if (IS_MOVW_R0_REGDISP(code)) {\n\t\t// 10000001mmmmi4*2 mov.w R0,@(<disp>,<REG_M>))\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, 0);\n\t\top->dst = anal_fill_reg_disp_mem (anal, GET_SOURCE_REG(code), code&0x0F, WORD_SIZE);\n\t}\n\treturn op->size;\n}\n\n//nibble=9; 1001nnnni8p2.... mov.w @(<disp>,PC),<REG_N>\nstatic int movw_pcdisp_reg(RAnal* anal, RAnalOp* op, ut16 code){\n\top->type = R_ANAL_OP_TYPE_LOAD;\n\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t//op->src[0] = anal_fill_reg_disp_mem(anal,PC_IDX,code&0xFF,WORD_SIZE);\t//XXX trash in 2 commits\n\top->src[0] = anal_pcrel_disp_mov (anal, op, code&0xFF, WORD_SIZE);\n\treturn op->size;\n}\n\n//nibble=A;  1010i12......... bra <bdisp12>\nstatic int bra(RAnal* anal, RAnalOp* op, ut16 code){\n\t/* Unconditional branch, relative to PC */\n\top->type = R_ANAL_OP_TYPE_JMP;\n\top->delay = 1;\n\top->jump = disarm_12bit_offset (op, GET_BRA_OFFSET(code));\n\top->eob  = true;\n\treturn op->size;\n}\n\n//nibble=B; 1011i12......... bsr <bdisp12>\nstatic int bsr(RAnal* anal, RAnalOp* op, ut16 code){\n\t/* Subroutine call, relative to PC */\n\top->type = R_ANAL_OP_TYPE_CALL;\n\top->jump = disarm_12bit_offset (op, GET_BRA_OFFSET(code));\n\top->delay = 1;\n\treturn op->size;\n}\n\nstatic int first_nibble_is_c(RAnal* anal, RAnalOp* op, ut16 code){\n\tif (IS_TRAP(code)) {\n\t\top->type = R_ANAL_OP_TYPE_SWI;\n\t\top->val = (ut8)(code&0xFF);\n\t} else if (IS_MOVA_PCREL_R0(code)) {\n\t\t// 11000111i8p4.... mova @(<disp>,PC),R0\n\t\top->type = R_ANAL_OP_TYPE_LEA;\n\t\top->src[0] = anal_pcrel_disp_mov (anal, op, code&0xFF, LONG_SIZE);\t//this is wrong !\n\t\top->dst = anal_fill_ai_rg (anal, 0); //Always R0\n\t} else if (IS_BINLOGIC_IMM_R0(code)) {\t// 110010__i8 (binop) #imm, R0\n\t\top->src[0] = anal_fill_im (anal, code&0xFF);\n\t\top->src[1] = anal_fill_ai_rg (anal, 0);\t//Always R0\n\t\top->dst = anal_fill_ai_rg (anal, 0); //Always R0 except tst #imm, R0\n\t\tswitch (code & 0xFF00) {\n\t\tcase 0xC800:\t//tst\n\t\t\t//TODO : get correct op->dst ! (T flag)\n\t\t\top->type = R_ANAL_OP_TYPE_ACMP;\n\t\t\tbreak;\n\t\tcase 0xC900:\t//and\n\t\t\top->type = R_ANAL_OP_TYPE_AND;\n\t\t\tbreak;\n\t\tcase 0xCA00:\t//xor\n\t\t\top->type = R_ANAL_OP_TYPE_XOR;\n\t\t\tbreak;\n\t\tcase 0xCB00:\t//or\n\t\t\top->type = R_ANAL_OP_TYPE_OR;\n\t\t\tbreak;\n\t\t}\n\t} else if (IS_BINLOGIC_IMM_GBR(code)) {\t//110011__i8 (binop).b #imm, @(R0,GBR)\n\t\top->src[0] = anal_fill_im (anal, code&0xFF);\n\t\tswitch (code & 0xFF00) {\n\t\tcase 0xCC00:\t//tst\n\t\t\t//TODO : get correct op->dst ! (T flag)\n\t\t\top->type = R_ANAL_OP_TYPE_ACMP;\n\t\t\tbreak;\n\t\tcase 0xCD00:\t//and\n\t\t\top->type = R_ANAL_OP_TYPE_AND;\n\t\t\tbreak;\n\t\tcase 0xCE00:\t//xor\n\t\t\top->type = R_ANAL_OP_TYPE_XOR;\n\t\t\tbreak;\n\t\tcase 0xCF00:\t//or\n\t\t\top->type = R_ANAL_OP_TYPE_OR;\n\t\t\tbreak;\n\t\t}\n\t\t//TODO : implement @(R0,GBR) dest and src[1]\n\t} else if (IS_MOVB_R0_GBRREF(code)) {\t//11000000i8*1.... mov.b R0,@(<disp>,GBR)\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, 0);\n\t\t//todo: implement @(disp,GBR) dest\n\t} else if (IS_MOVW_R0_GBRREF(code)) {\t//11000001i8*2.... mov.w R0,@(<disp>,GBR)\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, 0);\n\t\t//todo: implement @(disp,GBR) dest\n\t} else if (IS_MOVL_R0_GBRREF(code)) {\t//11000010i8*4.... mov.l R0,@(<disp>,GBR)\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, 0);\n\t\t//todo: implement @(disp,GBR) dest\n\t} else if (IS_MOVB_GBRREF_R0(code)) {\t//11000100i8*1.... mov.b @(<disp>,GBR),R0\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->dst = anal_fill_ai_rg (anal, 0);\n\t\t//todo: implement @(disp,GBR) src\n\t} else if (IS_MOVW_GBRREF_R0(code)) {\t//11000101i8*2.... mov.w @(<disp>,GBR),R0\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->dst = anal_fill_ai_rg (anal, 0);\n\t\t//todo: implement @(disp,GBR) src\n\t} else if (IS_MOVL_GBRREF_R0(code)) {\t//11000110i8*4.... mov.l @(<disp>,GBR),R0\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->dst = anal_fill_ai_rg (anal, 0);\n\t\t//todo: implement @(disp,GBR) src\n\t}\n\n\treturn op->size;\n}\n\n//nibble=d; 1101nnnni8 : mov.l @(<disp>,PC), Rn\nstatic int movl_pcdisp_reg(RAnal* anal, RAnalOp* op, ut16 code){\n\top->type = R_ANAL_OP_TYPE_LOAD;\n\top->src[0] = anal_pcrel_disp_mov (anal, op, code&0xFF, LONG_SIZE);\n\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\treturn op->size;\n}\n\n//nibble=e; 1110nnnni8*1.... mov #<imm>,<REG_N>\nstatic int mov_imm_reg(RAnal* anal, RAnalOp* op, ut16 code){\n\top->type = R_ANAL_OP_TYPE_MOV;\n\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\top->src[0] = anal_fill_im (anal, (st8)(code & 0xFF));\n\treturn op->size;\n}\n\n//nibble=f;\nstatic int fpu_insn(RAnal* anal, RAnalOp* op, ut16 code){\n\t//Not interested on FPU stuff for now\n\top->family = R_ANAL_OP_FAMILY_FPU;\n\treturn op->size;\n}\n\n/* Table of routines for further analysis based on 1st nibble */\nstatic int (*first_nibble_decode[])(RAnal*,RAnalOp*,ut16) = {\n\tfirst_nibble_is_0,\n\tmovl_reg_rdisp,\n\tfirst_nibble_is_2,\n\tfirst_nibble_is_3,\n\tfirst_nibble_is_4,\n\tmovl_rdisp_reg,\n\tfirst_nibble_is_6,\n\tadd_imm,\n\tfirst_nibble_is_8,\n\tmovw_pcdisp_reg,\n\tbra,\n\tbsr,\n\tfirst_nibble_is_c,\n\tmovl_pcdisp_reg,\n\tmov_imm_reg,\n\tfpu_insn\n};\n\n\n/* This is the basic operation analysis. Just initialize and jump to\n * routines defined in first_nibble_decode table\n */\nstatic int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_MSB,op_LSB;\n\tint ret;\n\tif (!data)\n\t\treturn 0;\n\tmemset (op, '\\0', sizeof (RAnalOp));\n\top->addr = addr;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->jump = op->fail = -1;\n\top->ptr = op->val = -1;\n\n\top->size = 2;\n\n\top_MSB = anal->big_endian? data[0]: data[1];\n\top_LSB = anal->big_endian? data[1]: data[0];\n\tret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));\n\treturn ret;\n}\n\n/* Set the profile register */\nstatic int sh_set_reg_profile(RAnal* anal){\n\t//TODO Add system ( ssr, spc ) + fpu regs\n\tconst char *p =\n\t\t\"=PC    pc\\n\"\n\t\t\"=SP    r15\\n\"\n\t\t\"=BP    r14\\n\"\n\t\t\"gpr\tr0\t.32\t0\t0\\n\"\n\t\t\"gpr\tr1\t.32\t4\t0\\n\"\n\t\t\"gpr\tr2\t.32\t8\t0\\n\"\n\t\t\"gpr\tr3\t.32\t12\t0\\n\"\n\t\t\"gpr\tr4\t.32\t16\t0\\n\"\n\t\t\"gpr\tr5\t.32\t20\t0\\n\"\n\t\t\"gpr\tr6\t.32\t24\t0\\n\"\n\t\t\"gpr\tr7\t.32\t28\t0\\n\"\n\t\t\"gpr\tr8\t.32\t32\t0\\n\"\n\t\t\"gpr\tr9\t.32\t36\t0\\n\"\n\t\t\"gpr\tr10\t.32\t40\t0\\n\"\n\t\t\"gpr\tr11\t.32\t44\t0\\n\"\n\t\t\"gpr\tr12\t.32\t48\t0\\n\"\n\t\t\"gpr\tr13\t.32\t52\t0\\n\"\n\t\t\"gpr\tr14\t.32\t56\t0\\n\"\n\t\t\"gpr\tr15\t.32\t60\t0\\n\"\n\t\t\"gpr\tpc\t.32\t64\t0\\n\"\n\t\t\"gpr\tpr\t.32\t68\t0\\n\"\n\t\t\"gpr\tsr\t.32\t72\t0\\n\"\n\t\t\"gpr\tgbr\t.32\t76\t0\\n\"\n\t\t\"gpr\tmach\t.32\t80\t0\\n\"\n\t\t\"gpr\tmacl\t.32\t84\t0\\n\";\n\treturn r_reg_set_profile_string(anal->reg, p);\n}\n\nstatic int archinfo(RAnal *anal, int q) {\n\treturn 2; /* :) */\n}\n\nRAnalPlugin r_anal_plugin_sh = {\n\t.name = \"sh\",\n\t.desc = \"SH-4 code analysis plugin\",\n\t.license = \"LGPL3\",\n\t.arch = \"sh\",\n\t.archinfo = archinfo,\n\t.bits = 32,\n\t.op = &sh_op,\n\t.set_reg_profile = &sh_set_reg_profile,\n};\n\n#ifndef CORELIB\nRLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_ANAL,\n\t.data = &r_anal_plugin_sh,\n\t.version = R2_VERSION\n};\n#endif\n"], "fixing_code": ["/* radare - LGPL - Copyright 2010-2013 eloi<limited-entropy.com> */\n\n#include <string.h>\n#include <r_types.h>\n#include <r_lib.h>\n#include <r_asm.h>\n#include <r_anal.h>\n\n#define API static\n\n#define LONG_SIZE 4\n#define WORD_SIZE 2\n#define BYTE_SIZE 1\n\n/* missing opcodes :\n - FPU (opcodes 0xF___)\n - opcodes > SH2E\n - cmp*\n - \"special\" regs : PR, SR, VBR, GBR, MACL, MACH\n - T flag handling\n - 0x0___\n - 0x2___\n - 0x3___ ops : cmp*, div, dmul\n - 0x4___ ops : ld*, st*\n - 0x6___ implement (ext*, pop, swap, ...)\n - 0x8___ implement cmp/eq imm,Rn\n - 0xC___ implement {mova, T flag dest, (disp,GBR) src/dst}\n - 0xF___ FPU: everything\n\n *** complete :\n 0x1___\n 0x5___\n 0x7___\n 0x9___ (XXX verify if @(disp,PC) works)\n 0xA___\n 0xB___\n 0xD___\n 0xE___\n*/\n\n//Macros for different instruction types\n\n#define IS_CLRT(x)\t\t\tx == 0x0008\n#define IS_NOP(x)\t\t\tx == 0x0009\n#define IS_RTS(x)\t\t\tx == 0x000b\n#define IS_SETT(x)\t\t\tx == 0x0018\n#define IS_DIV0U(x)\t\t\tx == 0x0019\n#define IS_SLEEP(x)\t\t\tx == 0x001b\n#define IS_CLRMAC(x)\t\tx == 0x0028\n#define IS_RTE(x)\t\t\tx == 0x002b\n//#define IS_CLRS(x)\n\n#define IS_STCSR1(x)\t\t(((x) & 0xF0CF) == 0x0002)\t\t//mask stc Rn,{SR,GBR,VBR,SSR}\n#define IS_BSRF(x)\t\t\t(x & 0xf0ff) == 0x0003\n#define IS_BRAF(x)\t\t\t(((x) & 0xf0ff) == 0x0023)\n#define IS_MOVB_REG_TO_R0REL(x)\t\t(((x) & 0xF00F) == 0x0004)\n#define IS_MOVW_REG_TO_R0REL(x)\t\t(((x) & 0xF00F) == 0x0005)\n#define IS_MOVL_REG_TO_R0REL(x)\t\t(((x) & 0xF00F) == 0x0006)\n#define IS_MULL(x)\t\t\t(((x) & 0xF00F) == 0x0007)\n#define IS_MOVB_R0REL_TO_REG(x)\t\t(((x) & 0xF00F) == 0x000C)\n#define IS_MOVW_R0REL_TO_REG(x)\t\t(((x) & 0xF00F) == 0x000D)\n#define IS_MOVL_R0REL_TO_REG(x)\t\t(((x) & 0xF00F) == 0x000E)\n//#define IS_MACL(x)\t\t(((x) & 0xF00F) == 0x000F) //complicated !\n#define IS_MOVT(x)\t\t\t(((x) & 0xF0FF) == 0x0029)\n#define IS_STSMAC(x)\t\t(((x) & 0xF0EF) == 0x000A)\t\t//mask sts Rn, MAC*\n#define IS_STSPR(x)\t\t\t(((x) & 0xF0FF) == 0x002A)\n//#define IS_STSFPUL(x)\t\t(((x) & 0xF0FF) == 0x005A)\t\t//FP*: todo maybe someday\n//#define IS_STSFPSCR(x)\t\t(((x) & 0xF0FF) == 0x006A)\n\n#define IS_MOVB_REG_TO_REGREF(x)\t(((x) & 0xF00F) == 0x2000)\n#define IS_MOVW_REG_TO_REGREF(x)\t(((x) & 0xF00F) == 0x2001)\n#define IS_MOVL_REG_TO_REGREF(x)\t(((x) & 0xF00F) == 0x2002)\n//#define invalid?(x)\t(((x) & 0xF00F) == 0x2003)\t//illegal on sh2e\n#define IS_PUSHB(x)\t\t\t(((x) & 0xF00F) == 0x2004)\n#define IS_PUSHW(x)\t\t\t(((x) & 0xF00F) == 0x2005)\n#define IS_PUSHL(x)\t\t\t(((x) & 0xF00F) == 0x2006)\n#define IS_DIV0S(x)\t\t(((x) & 0xF00F) == 0x2007)\n#define IS_TSTRR(x)\t\t\t(((x) & 0xF00F) == 0x2008)\n#define IS_AND_REGS(x)\t\t\t(((x) & 0xF00F) == 0x2009)\n#define IS_XOR_REGS(x)\t\t\t(((x) & 0xF00F) == 0x200A)\n#define IS_OR_REGS(x)\t\t\t(((x) & 0xF00F) == 0x200B)\n#define IS_CMPSTR(x)\t\t\t(((x) & 0xF00F) == 0x200C)\n#define IS_XTRCT(x)\t\t\t(((x) & 0xF00F) == 0x200D)\n#define IS_MULUW(x)\t\t\t(((x) & 0xF00F) == 0x200E)\n#define IS_MULSW(x)\t\t\t(((x) & 0xF00F) == 0x200F)\n\n\n#define IS_CMPEQ(x)\t\t\t(((x) & 0xF00F) == 0x3000)\n//#define invalid?(x)\t\t\t(((x) & 0xF00F) == 0x3001)\n#define IS_CMPHS(x)\t\t\t(((x) & 0xF00F) == 0x3002)\n#define IS_CMPGE(x)\t\t\t(((x) & 0xF00F) == 0x3003)\n#define IS_CMPHI(x)\t\t\t(((x) & 0xF00F) == 0x3006)\n#define IS_CMPGT(x)\t\t\t(((x) & 0xF00F) == 0x3007)\n\n#define IS_DIV1(x)\t\t\t(((x) & 0xF00F) == 0x3004)\n#define IS_DMULU(x)\t\t\t(((x) & 0xF00F) == 0x3005)\n#define IS_DMULS(x)\t\t\t(((x) & 0xF00F) == 0x300D)\n\n#define IS_SUB(x)\t\t\t(((x) & 0xF00F) == 0x3008)\n//#define invalid?(x)\t\t\t(((x) & 0xF00F) == 0x3009)\n#define IS_SUBC(x)\t\t\t(((x) & 0xF00F) == 0x300A)\n#define IS_SUBV(x)\t\t\t(((x) & 0xF00F) == 0x300B)\n#define IS_ADD(x)\t\t\t(((x) & 0xF00F) == 0x300C)\n#define IS_ADDC(x)\t\t\t(((x) & 0xF00F) == 0x300E)\n#define IS_ADDV(x)\t\t\t(((x) & 0xF00F) == 0x300F)\n\n//#define IS_MACW(x)\t\t\t(((x) & 0xF00F) == 0x400F)\t//complex\n#define IS_JSR(x)\t\t\t(((x) & 0xf0ff) == 0x400b)\n#define IS_JMP(x)\t\t\t(((x) & 0xf0ff) == 0x402b)\n#define IS_CMPPL(x)\t\t\t(((x) & 0xf0ff) == 0x4015)\n#define IS_CMPPZ(x)\t\t\t(((x) & 0xf0ff) == 0x4011)\n\n#define IS_LDCSR1(x)\t\t(((x) & 0xF0CF) == 0x400E)\t\t//mask ldc Rn,{SR,GBR,VBR,SSR}\n#define IS_LDCLSR1(x)\t\t(((x) & 0xF0CF) == 0x4007)\t\t//mask ldc.l @Rn+,{SR,GBR,VBR,SSR}\n#define IS_LDSMAC(x)\t\t(((x) & 0xF0EF) == 0x400A)\t\t//mask lds Rn, MAC*\n#define IS_LDSLMAC(x)\t\t(((x) & 0xF0EF) == 0x4006)\t\t//mask lds.l @Rn+, MAC*\n#define IS_LDSPR(x)\t\t\t(((x) & 0xF0FF) == 0x402A)\n#define IS_LDSLPR(x)\t\t(((x) & 0xF0FF) == 0x4026)\n//#define IS_LDSFPUL(x)\t\t(((x) & 0xF0FF) == 0x405A)\t\t//FP*: todo maybe someday\n//#define IS_LDSFPSCR(x)\t\t(((x) & 0xF0FF) == 0x406A)\n//#define IS_LDSLFPUL(x)\t\t(((x) & 0xF0FF) == 0x4066)\n//#define IS_LDSLFPSCR(x)\t\t(((x) & 0xF0FF) == 0x4056)\n#define IS_ROT(x)\t\t\t(((x) & 0xF0DE) == 0x4004)\t\t//mask rot{,c}{l,r}\n//not on sh2e : shad, shld\n\n//#define IS_SHIFT1(x)\t\t(((x) & 0xF0DE) == 0x4000)\t//unused (treated as switch-case)\n//other shl{l,r}{,2,8,16} in switch case also.\n\n#define IS_STSLMAC(x)\t\t(((x) & 0xF0EF) == 0x4002)\t\t//mask sts.l mac*, @-Rn\n#define IS_STCLSR1(x)\t\t(((x) & 0xF0CF) == 0x4003)\t//mask stc.l {SR,GBR,VBR,SSR},@-Rn\n//todo: other stc.l not on sh2e\n#define IS_STSLPR(x)\t\t(((x) & 0xF0FF) == 0x4022)\n//#define IS_STSLFPUL(x)\t\t(((x) & 0xF0FF) == 0x4052)\n//#define IS_STSLFPSCR(x)\t\t(((x) & 0xF0FF) == 0x4062)\n#define IS_TASB(x)\t\t\t(((x) & 0xF0FF) == 0x401B)\n#define IS_DT(x)\t\t\t(((x) & 0xF0FF) == 0x4010)\n\n\n#define IS_MOVB_REGREF_TO_REG(x)\t(((x) & 0xF00F) == 0x6000)\n#define IS_MOVW_REGREF_TO_REG(x)\t(((x) & 0xF00F) == 0x6001)\n#define IS_MOVL_REGREF_TO_REG(x)\t(((x) & 0xF00F) == 0x6002)\n#define IS_MOV_REGS(x)\t\t\t(((x) & 0xf00f) == 0x6003)\n#define IS_MOVB_POP(x)\t\t\t(((x) & 0xF00F) == 0x6004)\n#define IS_MOVW_POP(x)\t\t\t(((x) & 0xF00F) == 0x6005)\n#define IS_MOVL_POP(x)\t\t\t(((x) & 0xF00F) == 0x6006)\n#define IS_NOT(x)\t\t\t(((x) & 0xF00F) == 0x6007)\n#define IS_SWAP(x)\t\t\t(((x) & 0xF00E) == 0x6008)\t//match swap.{b,w}\n#define IS_NEG(x)\t\t\t(((x) & 0xF00E) == 0x600A)\t//match neg{,c}\n#define IS_EXT(x)\t\t(((x) & 0xF00C) == 0x600C)\t//match ext{s,u}.{b,w}\n\n\n#define IS_MOVB_R0_REGDISP(x)\t(((x) & 0xFF00) == 0x8000)\n#define IS_MOVW_R0_REGDISP(x)\t(((x) & 0xFF00) == 0x8100)\n//#define illegal?(x)\t\t(((x) & 0xF900) == 0x8000)\t//match 8{2,3,6,7}00\n#define IS_MOVB_REGDISP_R0(x)\t\t(((x) & 0xFF00) == 0x8400)\n#define IS_MOVW_REGDISP_R0(x)\t\t(((x) & 0xFF00) == 0x8500)\n#define IS_CMPIMM(x)\t\t(((x) & 0xFF00) == 0x8800)\n//#define illegal?(x)\t\t(((x) & 0xFB00) == 0x8A00)\t//match 8{A,E}00\n#define IS_BT(x)\t\t\t(((x) & 0xff00) == 0x8900)\n#define IS_BF(x)\t\t\t(((x) & 0xff00) == 0x8B00)\n#define IS_BTS(x)\t\t\t(((x) & 0xff00) == 0x8D00)\n#define IS_BFS(x)\t\t\t(((x) & 0xff00) == 0x8F00)\n#define IS_BT_OR_BF(x)\t\t\tIS_BT(x)||IS_BTS(x)||IS_BF(x)||IS_BFS(x)\n\n#define IS_MOVB_R0_GBRREF(x)\t(((x) & 0xFF00) == 0xC000)\n#define IS_MOVW_R0_GBRREF(x)\t(((x) & 0xFF00) == 0xC100)\n#define IS_MOVL_R0_GBRREF(x)\t(((x) & 0xFF00) == 0xC200)\n#define IS_TRAP(x)\t\t\t\t(((x) & 0xFF00) == 0xC300)\n#define IS_MOVB_GBRREF_R0(x)\t(((x) & 0xFF00) == 0xC400)\n#define IS_MOVW_GBRREF_R0(x)\t(((x) & 0xFF00) == 0xC500)\n#define IS_MOVL_GBRREF_R0(x)\t(((x) & 0xFF00) == 0xC600)\n#define IS_MOVA_PCREL_R0(x)\t\t(((x) & 0xFF00) == 0xC700)\n#define IS_BINLOGIC_IMM_R0(x)\t(((x) & 0xFC00) == 0xC800)\t//match C{8,9,A,B}00\n#define IS_BINLOGIC_IMM_GBR(x)\t(((x) & 0xFC00) == 0xCC00)\t//match C{C,D,E,F}00 : *.b #imm, @(R0,GBR)\n\n/* Compute PC-relative displacement for branch instructions */\n#define GET_BRA_OFFSET(x)\t((x) & 0x0fff)\n#define GET_BTF_OFFSET(x)\t((x) & 0x00ff)\n\n/* Compute reg nr for BRAF,BSR,BSRF,JMP,JSR */\n#define GET_TARGET_REG(x)\t((x >> 8) & 0x0f)\n#define GET_SOURCE_REG(x)\t((x >> 4) & 0x0f)\n\n/* index of PC reg in regs[] array*/\n#define PC_IDX 16\n\n/* for {bra,bsr} only: (sign-extend 12bit offset)<<1  + PC +4 */\nstatic ut64 disarm_12bit_offset (RAnalOp *op, unsigned int insoff) {\n\tut64 off = insoff;\n\t/* sign extend if higher bit is 1 (0x0800) */\n\tif ((off & 0x0800) == 0x0800)\n\t{\n\t\toff |= ~0xFFF;\n\t}\n\treturn (op->addr) + (off<<1) + 4;\n}\n\n\n/* for bt,bf sign-extended offsets : return PC+4+ (exts.b offset)<<1 */\nstatic ut64 disarm_8bit_offset (ut64 pc, ut32 offs) {\n        /* pc (really, op->addr) is 64 bits, so we need to sign-extend\n         * to 64 bits instead of the 32 the actual CPU does */\n        ut64 off = offs;\n\t/* sign extend if higher bit is 1 (0x08) */\n\tif ((off & 0x80) == 0x80)\n\t{\n\t\toff |= ~0xFF;\n\t}\n\treturn (off<<1) + pc + 4;\n}\n\nstatic char *regs[]={\"r0\",\"r1\",\"r2\",\"r3\",\"r4\",\"r5\",\"r6\",\"r7\",\"r8\",\"r9\",\"r10\",\"r11\",\"r12\",\"r13\",\"r14\",\"r15\",\"pc\"};\n\nstatic RAnalValue *anal_fill_ai_rg(RAnal *anal, int idx) {\n        RAnalValue *ret = r_anal_value_new ();\n        ret->reg = r_reg_get (anal->reg, regs[idx], R_REG_TYPE_GPR);\n        return ret;\n}\n\nstatic RAnalValue *anal_fill_im(RAnal *anal, st32 v) {\n        RAnalValue *ret = r_anal_value_new ();\n        ret->imm = v;\n        return ret;\n}\n\n/* Implements @(disp,Rn) , size=1 for .b, 2 for .w, 4 for .l */\nstatic RAnalValue *anal_fill_reg_disp_mem(RAnal *anal, int reg, st64 delta, st64 size) {\n\tRAnalValue *ret = anal_fill_ai_rg (anal, reg);\n\tret->memref = size;\n\tret->delta = delta*size;\n\treturn ret;\n}\n\n/* Rn */\nstatic RAnalValue *anal_fill_reg_ref(RAnal *anal, int reg, st64 size){\n\tRAnalValue *ret = anal_fill_ai_rg (anal, reg);\n\tret->memref = size;\n\treturn ret;\n}\n\n/* @(R0,Rx) references for all sizes */\nstatic RAnalValue *anal_fill_r0_reg_ref(RAnal *anal, int reg, st64 size){\n\tRAnalValue *ret = anal_fill_ai_rg (anal, 0);\n\tret->regdelta = r_reg_get (anal->reg, regs[reg], R_REG_TYPE_GPR);\n\tret->memref = size;\n\treturn ret;\n}\n\n// @(disp,PC) for size=2(.w), size=4(.l). disp is 0-extended\nstatic RAnalValue *anal_pcrel_disp_mov(RAnal* anal, RAnalOp* op, ut8 disp, int size){\n\tRAnalValue *ret = r_anal_value_new ();\n\tif (size==2) {\n\t\tret->base = op->addr+4;\n\t\tret->delta = disp<<1;\n\t} else {\n\t\tret->base = (op->addr+4) & ~0x03;\n\t\tret->delta = disp<<2;\n\t}\n\n\treturn ret;\n}\n\n//= PC+4+R<reg>\nstatic RAnalValue *anal_regrel_jump(RAnal* anal, RAnalOp* op, ut8 reg){\n\tRAnalValue *ret = r_anal_value_new ();\n\tret->reg = r_reg_get (anal->reg, regs[reg], R_REG_TYPE_GPR);\n\tret->base = op->addr+4;\n\treturn ret;\n}\n\n/* 16 decoder routines, based on 1st nibble value */\nstatic int first_nibble_is_0(RAnal* anal, RAnalOp* op, ut16 code){\n\tif(IS_BSRF(code)) {\n\t\t/* Call 'far' subroutine Rn+PC+4 */\n\t\top->type = R_ANAL_OP_TYPE_UCALL;\n\t\top->delay = 1;\n\t\top->dst = anal_regrel_jump (anal, op, GET_TARGET_REG(code));\n\t} else if (IS_BRAF(code)) {\n\t\t/* Unconditional branch to Rn+PC+4, no delay slot */\n\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\top->dst = anal_regrel_jump (anal, op, GET_TARGET_REG(code));\n\t\top->eob = true;\n\t} else if( IS_RTS(code) ) {\n\t\t/* Ret from subroutine. Returns to pr */\n\t\t//TODO Convert into jump pr?\n\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\top->delay = 1;\n\t\top->eob = true;\n\t} else if (IS_RTE(code)) {\n\t\t//TODO Convert into jmp spc? Indicate ssr->sr as well?\n\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\top->delay = 1;\n\t\top->eob = true;\n\t} else if (IS_MOVB_REG_TO_R0REL(code)) {\t//0000nnnnmmmm0100 mov.b <REG_M>,@(R0,<REG_N>)\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_r0_reg_ref (anal, GET_TARGET_REG(code), BYTE_SIZE);\n\t} else if (IS_MOVW_REG_TO_R0REL(code)) {\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_r0_reg_ref (anal, GET_TARGET_REG(code), WORD_SIZE);\n\t} else if (IS_MOVL_REG_TO_R0REL(code)) {\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_r0_reg_ref(anal, GET_TARGET_REG(code), LONG_SIZE);\n\t} else if (IS_MOVB_R0REL_TO_REG(code)) {\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->src[0] = anal_fill_r0_reg_ref (anal, GET_SOURCE_REG(code), BYTE_SIZE);\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_MOVW_R0REL_TO_REG(code)) {\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->src[0] = anal_fill_r0_reg_ref (anal, GET_SOURCE_REG(code), WORD_SIZE);\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_MOVL_R0REL_TO_REG(code)) {\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->src[0] = anal_fill_r0_reg_ref (anal, GET_SOURCE_REG(code), LONG_SIZE);\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_NOP(code)) {\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t} else if (IS_CLRT(code)) {\n\t\top->type = R_ANAL_OP_TYPE_UNK;\t//TODO : implement flag\n\t} else if (IS_SETT(code)) {\n\t\top->type = R_ANAL_OP_TYPE_UNK;\n\t} else if (IS_CLRMAC(code)) {\n\t\top->type = R_ANAL_OP_TYPE_UNK;\t//TODO : type_mov ?\n\t} else if (IS_DIV0U(code)) {\n\t\top->type = R_ANAL_OP_TYPE_DIV;\n\t} else if (IS_MOVT(code)) {\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t//op->src[0] = \t\t//TODO: figure out how to get T flag from sr reg\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_MULL(code)) {\n\t\top->type = R_ANAL_OP_TYPE_MUL;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\top->src[1] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\t//op->dst = //TODO: figure out how to set MACL + MACH\n\t} else if (IS_SLEEP(code)) {\n\t\top->type = R_ANAL_OP_TYPE_UNK;\n\t} else if (IS_STSMAC(code)) {\t//0000nnnn0000101_ sts MAC*,<REG_N>\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_STCSR1(code)) {\t//0000nnnn00010010 stc {sr,gbr,vbr,ssr},<REG_N>\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\t//todo: plug in src\n\t} else if (IS_STSPR(code)) {\t//0000nnnn00101010 sts PR,<REG_N>\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\t//todo: plug in src\n\t}\n\n\t//TODO Check missing insns, especially STC might be interesting\n\treturn op->size;\n}\n\n//nibble=1; 0001nnnnmmmmi4*4 mov.l <REG_M>,@(<disp>,<REG_N>)\nstatic int movl_reg_rdisp(RAnal* anal, RAnalOp* op, ut16 code){\n\top->type = R_ANAL_OP_TYPE_STORE;\n\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\top->dst = anal_fill_reg_disp_mem (anal, GET_TARGET_REG(code), code&0x0F, LONG_SIZE);\n\treturn op->size;\n}\n\nstatic int first_nibble_is_2(RAnal* anal, RAnalOp* op, ut16 code){\n\tif (IS_MOVB_REG_TO_REGREF(code)) {\t// 0010nnnnmmmm0000 mov.b <REG_M>,@<REG_N>\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_reg_ref (anal, GET_TARGET_REG(code), BYTE_SIZE);\n\t} else if (IS_MOVW_REG_TO_REGREF(code)) {\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_reg_ref (anal, GET_TARGET_REG(code), WORD_SIZE);\n\t} else if (IS_MOVL_REG_TO_REGREF(code)) {\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_reg_ref (anal, GET_TARGET_REG(code), LONG_SIZE);\n\t} else if (IS_AND_REGS(code)) {\n\t\top->type = R_ANAL_OP_TYPE_AND;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_XOR_REGS(code)) {\n\t\top->type = R_ANAL_OP_TYPE_XOR;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_OR_REGS(code)) {\n\t\top->type = R_ANAL_OP_TYPE_OR;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_PUSHB(code) || IS_PUSHW(code) || IS_PUSHL(code)) {\n\t\top->type = R_ANAL_OP_TYPE_PUSH;\n\t\t//TODO Handle 'pushes' (mov Rm,@-Rn)\n\t} else if (IS_TSTRR(code)) {\n\t\top->type = R_ANAL_OP_TYPE_ACMP;\n\t\t//TODO: handle tst reg,reg\n\t} else if (IS_CMPSTR(code)) {\t//0010nnnnmmmm1100 cmp/str <REG_M>,<REG_N>\n\t\top->type = R_ANAL_OP_TYPE_ACMP;\t//maybe not?\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->src[1] = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\t//todo: handle cmp/str byte-per-byte cmp?\n\t} else if (IS_XTRCT(code)) {\t//0010nnnnmmmm1101 xtrct <REG_M>,<REG_N>\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->src[1] = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\t//todo: add details ?\n\t} else if (IS_DIV0S(code)) {\n\t\top->type = R_ANAL_OP_TYPE_DIV;\n\t\t//todo: add details?\n\t} else if (IS_MULUW(code) || IS_MULSW(code)) {\t//0010nnnnmmmm111_ mul{s,u}.w <REG_M>,<REG_N>\n\t\top->type = R_ANAL_OP_TYPE_MUL;\n\t\top->src[0] = anal_fill_ai_rg(anal,GET_SOURCE_REG(code));\n\t\top->src[1] = anal_fill_ai_rg(anal,GET_TARGET_REG(code));\n\t\t//todo: dest=MACL\n\t}\n\n\treturn op->size;\n}\n\n\nstatic int first_nibble_is_3(RAnal* anal, RAnalOp* op, ut16 code){\n\t//TODO Handle carry/overflow , CMP/xx?\n\tif( IS_ADD(code) || IS_ADDC(code) || IS_ADDV(code) ) {\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if ( IS_SUB(code) || IS_SUBC(code) || IS_SUBV(code)) {\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_CMPEQ(code) || IS_CMPGE(code) || IS_CMPGT(code) ||\n\t\t\t\tIS_CMPHI(code) || IS_CMPHS(code)) {\n\t\t//TODO : finish implementing\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\top->src[1] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t} else if (IS_DIV1(code)) {\n\t\top->type = R_ANAL_OP_TYPE_DIV;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\top->src[1] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\t//todo: dest ?\n\t} else if (IS_DMULU(code) || IS_DMULS(code)) {\n\t\top->type = R_ANAL_OP_TYPE_MUL;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->src[1] = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\t//todo: dest=MACL,MACH\n\t}\n\treturn op->size;\n}\n\nstatic int first_nibble_is_4(RAnal* anal, RAnalOp* op, ut16 code){\n\tswitch (code & 0xF0FF) {\n\t\t//todo: implement\n\tcase 0x4020:\t//shal\n\t\top->type = R_ANAL_OP_TYPE_SAL;\n\t\tbreak;\n\tcase 0x4021:\t//shar\n\t\top->type = R_ANAL_OP_TYPE_SAR;\n\t\tbreak;\n\tcase 0x4000:\t//shll\n\tcase 0x4008:\t//shll2\n\tcase 0x4018:\t//shll8\n\tcase 0x4028:\t//shll16\n\t\top->type = R_ANAL_OP_TYPE_SHL;\n\t\tbreak;\n\tcase 0x4001:\t//shlr\n\tcase 0x4009:\t//shlr2\n\tcase 0x4019:\t//shlr8\n\tcase 0x4029:\t//shlr16\n\t\top->type = R_ANAL_OP_TYPE_SHR;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (IS_JSR(code)) {\n\t\top->type = R_ANAL_OP_TYPE_UCALL; //call to reg\n\t\top->delay = 1;\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if ( IS_JMP(code) ) {\n\t\top->type = R_ANAL_OP_TYPE_UJMP; //jmp to reg\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\top->delay = 1;\n\t\top->eob = true;\n\t} else if (IS_CMPPL(code) || IS_CMPPZ(code)) {\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\t//todo: implement\n\t} else if (IS_LDCLSR1(code) || IS_LDSLMAC(code) || IS_LDSLPR(code)) {\n\t\top->type = R_ANAL_OP_TYPE_POP;\n\t\t//todo: implement\n\t} else if (IS_LDCSR1(code) || IS_LDSMAC(code) || IS_LDSPR(code)) {\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t//todo: implement\n\t} else if (IS_ROT(code)) {\n\t\top->type = (code&1)? R_ANAL_OP_TYPE_ROR:R_ANAL_OP_TYPE_ROL;\n\t\t//todo: implement rot* vs rotc*\n\t} else if (IS_STCLSR1(code) || IS_STSLMAC(code) || IS_STSLPR(code)) {\n\t\top->type = R_ANAL_OP_TYPE_PUSH;\n\t\t//todo: implement st*.l *,@-Rn\n\t} else if (IS_TASB(code)) {\n\t\top->type = R_ANAL_OP_TYPE_UNK;\n\t\t//todo: implement\n\t} else if (IS_DT(code)) {\n\t\top->type = R_ANAL_OP_TYPE_UNK;\n\t\t//todo: implement\n\t}\n\treturn op->size;\n}\n\n//nibble=5;  0101nnnnmmmmi4*4 mov.l @(<disp>,<REG_M>),<REG_N>\nstatic int movl_rdisp_reg(RAnal* anal, RAnalOp* op, ut16 code){\n\top->type = R_ANAL_OP_TYPE_LOAD;\n\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\top->src[0] = anal_fill_reg_disp_mem (anal, GET_SOURCE_REG(code), code&0x0F, LONG_SIZE);\n\treturn op->size;\n}\n\n\nstatic int first_nibble_is_6(RAnal* anal, RAnalOp* op, ut16 code){\n\tif (IS_MOV_REGS(code)) {\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_MOVB_REGREF_TO_REG(code)) {\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->src[0] = anal_fill_reg_ref (anal, GET_SOURCE_REG(code), BYTE_SIZE);\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_MOVW_REGREF_TO_REG(code)) {\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->src[0] = anal_fill_reg_ref (anal, GET_SOURCE_REG(code), WORD_SIZE);\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_MOVL_REGREF_TO_REG(code)) {\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->src[0] = anal_fill_reg_ref (anal, GET_SOURCE_REG(code), LONG_SIZE);\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_EXT(code)) {\n\t\t//ext{s,u}.{b,w} instructs. todo : more detail ?\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_MOVB_POP(code) || IS_MOVW_POP(code) || IS_MOVL_POP(code)) {\n\t\t/* 0110nnnnmmmm0100 mov.b @<REG_M>+,<REG_N>*/\n\t\t/* 0110nnnnmmmm0101 mov.w @<REG_M>+,<REG_N>*/\n\t\t/* 0110nnnnmmmm0110 mov.l @<REG_M>+,<REG_N>*/\n\t\top->type = R_ANAL_OP_TYPE_POP;\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t\t//todo : op->src for pop = ?\n\t} else if (IS_NEG(code)) {\n\t\t//todo: neg and negc details\n\t\top->type = R_ANAL_OP_TYPE_UNK;\n\t\t/* 0110nnnnmmmm1010 negc*/\n\t\t/* 0110nnnnmmmm1010 neg */\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_NOT(code)) {\n\t\t//todo : details?\n\t\top->type = R_ANAL_OP_TYPE_NOT;\n\t\top->src[0] = anal_fill_ai_rg (anal, GET_SOURCE_REG(code));\n\t\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t} else if (IS_SWAP(code)) {\n\t\t/* 0110nnnnmmmm1000 swap.b <REG_M>,<REG_N>*/\n\t\t/* 0110nnnnmmmm1001 swap.w <REG_M>,<REG_N>*/\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t//todo : details\n\t}\n\n\treturn op->size;\n}\n\n\n//nibble=7; 0111nnnni8*1.... add #<imm>,<REG_N>\nstatic int add_imm(RAnal* anal, RAnalOp* op, ut16 code){\n\top->type = R_ANAL_OP_TYPE_ADD;\n\top->src[0] = anal_fill_im (anal, (st8)(code&0xFF)); //Casting to (st8) forces sign-extension.\n\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\treturn op->size;\n}\n\nstatic int first_nibble_is_8(RAnal* anal, RAnalOp* op, ut16 code){\n\tif (IS_BT_OR_BF(code)) {\n\t\top->type = R_ANAL_OP_TYPE_CJMP; //Jump if true or jump if false insns\n\t\top->jump = disarm_8bit_offset (op->addr, GET_BTF_OFFSET(code));\n\t\top->fail = op->addr + 2 ;\n\t\top->eob  = true;\n\t\tif (IS_BTS(code) || IS_BFS(code))\n\t\t\top->delay = 1; //Only /S versions have a delay slot\n\t} else if (IS_MOVB_REGDISP_R0(code)) {\n\t\t// 10000100mmmmi4*1 mov.b @(<disp>,<REG_M>),R0\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->dst = anal_fill_ai_rg (anal, 0);\n\t\top->src[0] = anal_fill_reg_disp_mem (anal, GET_SOURCE_REG(code), code&0x0F, BYTE_SIZE);\n\t} else if (IS_MOVW_REGDISP_R0(code)) {\n\t\t// 10000101mmmmi4*2 mov.w @(<disp>,<REG_M>),R0\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->dst = anal_fill_ai_rg (anal, 0);\n\t\top->src[0] = anal_fill_reg_disp_mem (anal, GET_SOURCE_REG(code), code&0x0F, WORD_SIZE);\n\t} else if (IS_CMPIMM(code)) {\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\t//todo : finish implementing\n\t} else if (IS_MOVB_R0_REGDISP(code)) {\n\t\t/* 10000000mmmmi4*1 mov.b R0,@(<disp>,<REG_M>)*/\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, 0);\n\t\top->dst = anal_fill_reg_disp_mem (anal, GET_SOURCE_REG(code), code&0x0F, BYTE_SIZE);\n\t} else if (IS_MOVW_R0_REGDISP(code)) {\n\t\t// 10000001mmmmi4*2 mov.w R0,@(<disp>,<REG_M>))\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, 0);\n\t\top->dst = anal_fill_reg_disp_mem (anal, GET_SOURCE_REG(code), code&0x0F, WORD_SIZE);\n\t}\n\treturn op->size;\n}\n\n//nibble=9; 1001nnnni8p2.... mov.w @(<disp>,PC),<REG_N>\nstatic int movw_pcdisp_reg(RAnal* anal, RAnalOp* op, ut16 code){\n\top->type = R_ANAL_OP_TYPE_LOAD;\n\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\t//op->src[0] = anal_fill_reg_disp_mem(anal,PC_IDX,code&0xFF,WORD_SIZE);\t//XXX trash in 2 commits\n\top->src[0] = anal_pcrel_disp_mov (anal, op, code&0xFF, WORD_SIZE);\n\treturn op->size;\n}\n\n//nibble=A;  1010i12......... bra <bdisp12>\nstatic int bra(RAnal* anal, RAnalOp* op, ut16 code){\n\t/* Unconditional branch, relative to PC */\n\top->type = R_ANAL_OP_TYPE_JMP;\n\top->delay = 1;\n\top->jump = disarm_12bit_offset (op, GET_BRA_OFFSET(code));\n\top->eob  = true;\n\treturn op->size;\n}\n\n//nibble=B; 1011i12......... bsr <bdisp12>\nstatic int bsr(RAnal* anal, RAnalOp* op, ut16 code){\n\t/* Subroutine call, relative to PC */\n\top->type = R_ANAL_OP_TYPE_CALL;\n\top->jump = disarm_12bit_offset (op, GET_BRA_OFFSET(code));\n\top->delay = 1;\n\treturn op->size;\n}\n\nstatic int first_nibble_is_c(RAnal* anal, RAnalOp* op, ut16 code){\n\tif (IS_TRAP(code)) {\n\t\top->type = R_ANAL_OP_TYPE_SWI;\n\t\top->val = (ut8)(code&0xFF);\n\t} else if (IS_MOVA_PCREL_R0(code)) {\n\t\t// 11000111i8p4.... mova @(<disp>,PC),R0\n\t\top->type = R_ANAL_OP_TYPE_LEA;\n\t\top->src[0] = anal_pcrel_disp_mov (anal, op, code&0xFF, LONG_SIZE);\t//this is wrong !\n\t\top->dst = anal_fill_ai_rg (anal, 0); //Always R0\n\t} else if (IS_BINLOGIC_IMM_R0(code)) {\t// 110010__i8 (binop) #imm, R0\n\t\top->src[0] = anal_fill_im (anal, code&0xFF);\n\t\top->src[1] = anal_fill_ai_rg (anal, 0);\t//Always R0\n\t\top->dst = anal_fill_ai_rg (anal, 0); //Always R0 except tst #imm, R0\n\t\tswitch (code & 0xFF00) {\n\t\tcase 0xC800:\t//tst\n\t\t\t//TODO : get correct op->dst ! (T flag)\n\t\t\top->type = R_ANAL_OP_TYPE_ACMP;\n\t\t\tbreak;\n\t\tcase 0xC900:\t//and\n\t\t\top->type = R_ANAL_OP_TYPE_AND;\n\t\t\tbreak;\n\t\tcase 0xCA00:\t//xor\n\t\t\top->type = R_ANAL_OP_TYPE_XOR;\n\t\t\tbreak;\n\t\tcase 0xCB00:\t//or\n\t\t\top->type = R_ANAL_OP_TYPE_OR;\n\t\t\tbreak;\n\t\t}\n\t} else if (IS_BINLOGIC_IMM_GBR(code)) {\t//110011__i8 (binop).b #imm, @(R0,GBR)\n\t\top->src[0] = anal_fill_im (anal, code&0xFF);\n\t\tswitch (code & 0xFF00) {\n\t\tcase 0xCC00:\t//tst\n\t\t\t//TODO : get correct op->dst ! (T flag)\n\t\t\top->type = R_ANAL_OP_TYPE_ACMP;\n\t\t\tbreak;\n\t\tcase 0xCD00:\t//and\n\t\t\top->type = R_ANAL_OP_TYPE_AND;\n\t\t\tbreak;\n\t\tcase 0xCE00:\t//xor\n\t\t\top->type = R_ANAL_OP_TYPE_XOR;\n\t\t\tbreak;\n\t\tcase 0xCF00:\t//or\n\t\t\top->type = R_ANAL_OP_TYPE_OR;\n\t\t\tbreak;\n\t\t}\n\t\t//TODO : implement @(R0,GBR) dest and src[1]\n\t} else if (IS_MOVB_R0_GBRREF(code)) {\t//11000000i8*1.... mov.b R0,@(<disp>,GBR)\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, 0);\n\t\t//todo: implement @(disp,GBR) dest\n\t} else if (IS_MOVW_R0_GBRREF(code)) {\t//11000001i8*2.... mov.w R0,@(<disp>,GBR)\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, 0);\n\t\t//todo: implement @(disp,GBR) dest\n\t} else if (IS_MOVL_R0_GBRREF(code)) {\t//11000010i8*4.... mov.l R0,@(<disp>,GBR)\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, 0);\n\t\t//todo: implement @(disp,GBR) dest\n\t} else if (IS_MOVB_GBRREF_R0(code)) {\t//11000100i8*1.... mov.b @(<disp>,GBR),R0\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->dst = anal_fill_ai_rg (anal, 0);\n\t\t//todo: implement @(disp,GBR) src\n\t} else if (IS_MOVW_GBRREF_R0(code)) {\t//11000101i8*2.... mov.w @(<disp>,GBR),R0\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->dst = anal_fill_ai_rg (anal, 0);\n\t\t//todo: implement @(disp,GBR) src\n\t} else if (IS_MOVL_GBRREF_R0(code)) {\t//11000110i8*4.... mov.l @(<disp>,GBR),R0\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->dst = anal_fill_ai_rg (anal, 0);\n\t\t//todo: implement @(disp,GBR) src\n\t}\n\n\treturn op->size;\n}\n\n//nibble=d; 1101nnnni8 : mov.l @(<disp>,PC), Rn\nstatic int movl_pcdisp_reg(RAnal* anal, RAnalOp* op, ut16 code){\n\top->type = R_ANAL_OP_TYPE_LOAD;\n\top->src[0] = anal_pcrel_disp_mov (anal, op, code&0xFF, LONG_SIZE);\n\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\treturn op->size;\n}\n\n//nibble=e; 1110nnnni8*1.... mov #<imm>,<REG_N>\nstatic int mov_imm_reg(RAnal* anal, RAnalOp* op, ut16 code){\n\top->type = R_ANAL_OP_TYPE_MOV;\n\top->dst = anal_fill_ai_rg (anal, GET_TARGET_REG(code));\n\top->src[0] = anal_fill_im (anal, (st8)(code & 0xFF));\n\treturn op->size;\n}\n\n//nibble=f;\nstatic int fpu_insn(RAnal* anal, RAnalOp* op, ut16 code){\n\t//Not interested on FPU stuff for now\n\top->family = R_ANAL_OP_FAMILY_FPU;\n\treturn op->size;\n}\n\n/* Table of routines for further analysis based on 1st nibble */\nstatic int (*first_nibble_decode[])(RAnal*,RAnalOp*,ut16) = {\n\tfirst_nibble_is_0,\n\tmovl_reg_rdisp,\n\tfirst_nibble_is_2,\n\tfirst_nibble_is_3,\n\tfirst_nibble_is_4,\n\tmovl_rdisp_reg,\n\tfirst_nibble_is_6,\n\tadd_imm,\n\tfirst_nibble_is_8,\n\tmovw_pcdisp_reg,\n\tbra,\n\tbsr,\n\tfirst_nibble_is_c,\n\tmovl_pcdisp_reg,\n\tmov_imm_reg,\n\tfpu_insn\n};\n\n\n/* This is the basic operation analysis. Just initialize and jump to\n * routines defined in first_nibble_decode table\n */\nstatic int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_MSB,op_LSB;\n\tint ret;\n\tif (!data || len < 2) {\n\t\treturn 0;\n\t}\n\tmemset (op, '\\0', sizeof (RAnalOp));\n\top->addr = addr;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->jump = op->fail = -1;\n\top->ptr = op->val = -1;\n\n\top->size = 2;\n\n\top_MSB = anal->big_endian? data[0]: data[1];\n\top_LSB = anal->big_endian? data[1]: data[0];\n\tret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));\n\treturn ret;\n}\n\n/* Set the profile register */\nstatic int sh_set_reg_profile(RAnal* anal){\n\t//TODO Add system ( ssr, spc ) + fpu regs\n\tconst char *p =\n\t\t\"=PC    pc\\n\"\n\t\t\"=SP    r15\\n\"\n\t\t\"=BP    r14\\n\"\n\t\t\"gpr\tr0\t.32\t0\t0\\n\"\n\t\t\"gpr\tr1\t.32\t4\t0\\n\"\n\t\t\"gpr\tr2\t.32\t8\t0\\n\"\n\t\t\"gpr\tr3\t.32\t12\t0\\n\"\n\t\t\"gpr\tr4\t.32\t16\t0\\n\"\n\t\t\"gpr\tr5\t.32\t20\t0\\n\"\n\t\t\"gpr\tr6\t.32\t24\t0\\n\"\n\t\t\"gpr\tr7\t.32\t28\t0\\n\"\n\t\t\"gpr\tr8\t.32\t32\t0\\n\"\n\t\t\"gpr\tr9\t.32\t36\t0\\n\"\n\t\t\"gpr\tr10\t.32\t40\t0\\n\"\n\t\t\"gpr\tr11\t.32\t44\t0\\n\"\n\t\t\"gpr\tr12\t.32\t48\t0\\n\"\n\t\t\"gpr\tr13\t.32\t52\t0\\n\"\n\t\t\"gpr\tr14\t.32\t56\t0\\n\"\n\t\t\"gpr\tr15\t.32\t60\t0\\n\"\n\t\t\"gpr\tpc\t.32\t64\t0\\n\"\n\t\t\"gpr\tpr\t.32\t68\t0\\n\"\n\t\t\"gpr\tsr\t.32\t72\t0\\n\"\n\t\t\"gpr\tgbr\t.32\t76\t0\\n\"\n\t\t\"gpr\tmach\t.32\t80\t0\\n\"\n\t\t\"gpr\tmacl\t.32\t84\t0\\n\";\n\treturn r_reg_set_profile_string(anal->reg, p);\n}\n\nstatic int archinfo(RAnal *anal, int q) {\n\treturn 2; /* :) */\n}\n\nRAnalPlugin r_anal_plugin_sh = {\n\t.name = \"sh\",\n\t.desc = \"SH-4 code analysis plugin\",\n\t.license = \"LGPL3\",\n\t.arch = \"sh\",\n\t.archinfo = archinfo,\n\t.bits = 32,\n\t.op = &sh_op,\n\t.set_reg_profile = &sh_set_reg_profile,\n};\n\n#ifndef CORELIB\nRLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_ANAL,\n\t.data = &r_anal_plugin_sh,\n\t.version = R2_VERSION\n};\n#endif\n"], "filenames": ["libr/anal/p/anal_sh.c"], "buggy_code_start_loc": [766], "buggy_code_end_loc": [767], "fixing_code_start_loc": [766], "fixing_code_end_loc": [769], "type": "CWE-125", "message": "The sh_op() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted ELF file.", "other": {"cve": {"id": "CVE-2018-11384", "sourceIdentifier": "cve@mitre.org", "published": "2018-05-22T19:29:00.663", "lastModified": "2018-06-27T15:18:07.577", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The sh_op() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted ELF file."}, {"lang": "es", "value": "La funci\u00f3n sh_op() en radare2 2.5.0 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites basada en memoria din\u00e1mica o heap y cierre inesperado de la aplicaci\u00f3n) mediante un archivo ELF manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:2.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "81E40EFA-5307-45F3-9722-CB499D21141F"}]}]}], "references": [{"url": "https://github.com/radare/radare2/commit/77c47cf873dd55b396da60baa2ca83bbd39e4add", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/9903", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/77c47cf873dd55b396da60baa2ca83bbd39e4add"}}