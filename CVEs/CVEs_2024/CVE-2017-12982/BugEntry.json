{"buggy_code": ["/*\n * The copyright in this software is being made available under the 2-clauses\n * BSD License, included below. This software may be subject to other third\n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux\n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#include \"opj_apps_config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"openjpeg.h\"\n#include \"convert.h\"\n\ntypedef struct {\n    OPJ_UINT16 bfType;      /* 'BM' for Bitmap (19776) */\n    OPJ_UINT32 bfSize;      /* Size of the file        */\n    OPJ_UINT16 bfReserved1; /* Reserved : 0            */\n    OPJ_UINT16 bfReserved2; /* Reserved : 0            */\n    OPJ_UINT32 bfOffBits;   /* Offset                  */\n} OPJ_BITMAPFILEHEADER;\n\ntypedef struct {\n    OPJ_UINT32 biSize;             /* Size of the structure in bytes */\n    OPJ_UINT32 biWidth;            /* Width of the image in pixels */\n    OPJ_UINT32 biHeight;           /* Height of the image in pixels */\n    OPJ_UINT16 biPlanes;           /* 1 */\n    OPJ_UINT16 biBitCount;         /* Number of color bits by pixels */\n    OPJ_UINT32 biCompression;      /* Type of encoding 0: none 1: RLE8 2: RLE4 */\n    OPJ_UINT32 biSizeImage;        /* Size of the image in bytes */\n    OPJ_UINT32 biXpelsPerMeter;    /* Horizontal (X) resolution in pixels/meter */\n    OPJ_UINT32 biYpelsPerMeter;    /* Vertical (Y) resolution in pixels/meter */\n    OPJ_UINT32 biClrUsed;          /* Number of color used in the image (0: ALL) */\n    OPJ_UINT32 biClrImportant;     /* Number of important color (0: ALL) */\n    OPJ_UINT32 biRedMask;          /* Red channel bit mask */\n    OPJ_UINT32 biGreenMask;        /* Green channel bit mask */\n    OPJ_UINT32 biBlueMask;         /* Blue channel bit mask */\n    OPJ_UINT32 biAlphaMask;        /* Alpha channel bit mask */\n    OPJ_UINT32 biColorSpaceType;   /* Color space type */\n    OPJ_UINT8  biColorSpaceEP[36]; /* Color space end points */\n    OPJ_UINT32 biRedGamma;         /* Red channel gamma */\n    OPJ_UINT32 biGreenGamma;       /* Green channel gamma */\n    OPJ_UINT32 biBlueGamma;        /* Blue channel gamma */\n    OPJ_UINT32 biIntent;           /* Intent */\n    OPJ_UINT32 biIccProfileData;   /* ICC profile data */\n    OPJ_UINT32 biIccProfileSize;   /* ICC profile size */\n    OPJ_UINT32 biReserved;         /* Reserved */\n} OPJ_BITMAPINFOHEADER;\n\nstatic void opj_applyLUT8u_8u32s_C1R(\n    OPJ_UINT8 const* pSrc, OPJ_INT32 srcStride,\n    OPJ_INT32* pDst, OPJ_INT32 dstStride,\n    OPJ_UINT8 const* pLUT,\n    OPJ_UINT32 width, OPJ_UINT32 height)\n{\n    OPJ_UINT32 y;\n\n    for (y = height; y != 0U; --y) {\n        OPJ_UINT32 x;\n\n        for (x = 0; x < width; x++) {\n            pDst[x] = (OPJ_INT32)pLUT[pSrc[x]];\n        }\n        pSrc += srcStride;\n        pDst += dstStride;\n    }\n}\n\nstatic void opj_applyLUT8u_8u32s_C1P3R(\n    OPJ_UINT8 const* pSrc, OPJ_INT32 srcStride,\n    OPJ_INT32* const* pDst, OPJ_INT32 const* pDstStride,\n    OPJ_UINT8 const* const* pLUT,\n    OPJ_UINT32 width, OPJ_UINT32 height)\n{\n    OPJ_UINT32 y;\n    OPJ_INT32* pR = pDst[0];\n    OPJ_INT32* pG = pDst[1];\n    OPJ_INT32* pB = pDst[2];\n    OPJ_UINT8 const* pLUT_R = pLUT[0];\n    OPJ_UINT8 const* pLUT_G = pLUT[1];\n    OPJ_UINT8 const* pLUT_B = pLUT[2];\n\n    for (y = height; y != 0U; --y) {\n        OPJ_UINT32 x;\n\n        for (x = 0; x < width; x++) {\n            OPJ_UINT8 idx = pSrc[x];\n            pR[x] = (OPJ_INT32)pLUT_R[idx];\n            pG[x] = (OPJ_INT32)pLUT_G[idx];\n            pB[x] = (OPJ_INT32)pLUT_B[idx];\n        }\n        pSrc += srcStride;\n        pR += pDstStride[0];\n        pG += pDstStride[1];\n        pB += pDstStride[2];\n    }\n}\n\nstatic void bmp24toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride,\n                         opj_image_t* image)\n{\n    int index;\n    OPJ_UINT32 width, height;\n    OPJ_UINT32 x, y;\n    const OPJ_UINT8 *pSrc = NULL;\n\n    width  = image->comps[0].w;\n    height = image->comps[0].h;\n\n    index = 0;\n    pSrc = pData + (height - 1U) * stride;\n    for (y = 0; y < height; y++) {\n        for (x = 0; x < width; x++) {\n            image->comps[0].data[index] = (OPJ_INT32)pSrc[3 * x + 2]; /* R */\n            image->comps[1].data[index] = (OPJ_INT32)pSrc[3 * x + 1]; /* G */\n            image->comps[2].data[index] = (OPJ_INT32)pSrc[3 * x + 0]; /* B */\n            index++;\n        }\n        pSrc -= stride;\n    }\n}\n\nstatic void bmp_mask_get_shift_and_prec(OPJ_UINT32 mask, OPJ_UINT32* shift,\n                                        OPJ_UINT32* prec)\n{\n    OPJ_UINT32 l_shift, l_prec;\n\n    l_shift = l_prec = 0U;\n\n    if (mask != 0U) {\n        while ((mask & 1U) == 0U) {\n            mask >>= 1;\n            l_shift++;\n        }\n        while (mask & 1U) {\n            mask >>= 1;\n            l_prec++;\n        }\n    }\n    *shift = l_shift;\n    *prec = l_prec;\n}\n\nstatic void bmpmask32toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride,\n                             opj_image_t* image, OPJ_UINT32 redMask, OPJ_UINT32 greenMask,\n                             OPJ_UINT32 blueMask, OPJ_UINT32 alphaMask)\n{\n    int index;\n    OPJ_UINT32 width, height;\n    OPJ_UINT32 x, y;\n    const OPJ_UINT8 *pSrc = NULL;\n    OPJ_BOOL hasAlpha;\n    OPJ_UINT32 redShift,   redPrec;\n    OPJ_UINT32 greenShift, greenPrec;\n    OPJ_UINT32 blueShift,  bluePrec;\n    OPJ_UINT32 alphaShift, alphaPrec;\n\n    width  = image->comps[0].w;\n    height = image->comps[0].h;\n\n    hasAlpha = image->numcomps > 3U;\n\n    bmp_mask_get_shift_and_prec(redMask,   &redShift,   &redPrec);\n    bmp_mask_get_shift_and_prec(greenMask, &greenShift, &greenPrec);\n    bmp_mask_get_shift_and_prec(blueMask,  &blueShift,  &bluePrec);\n    bmp_mask_get_shift_and_prec(alphaMask, &alphaShift, &alphaPrec);\n\n    image->comps[0].bpp = redPrec;\n    image->comps[0].prec = redPrec;\n    image->comps[1].bpp = greenPrec;\n    image->comps[1].prec = greenPrec;\n    image->comps[2].bpp = bluePrec;\n    image->comps[2].prec = bluePrec;\n    if (hasAlpha) {\n        image->comps[3].bpp = alphaPrec;\n        image->comps[3].prec = alphaPrec;\n    }\n\n    index = 0;\n    pSrc = pData + (height - 1U) * stride;\n    for (y = 0; y < height; y++) {\n        for (x = 0; x < width; x++) {\n            OPJ_UINT32 value = 0U;\n\n            value |= ((OPJ_UINT32)pSrc[4 * x + 0]) <<  0;\n            value |= ((OPJ_UINT32)pSrc[4 * x + 1]) <<  8;\n            value |= ((OPJ_UINT32)pSrc[4 * x + 2]) << 16;\n            value |= ((OPJ_UINT32)pSrc[4 * x + 3]) << 24;\n\n            image->comps[0].data[index] = (OPJ_INT32)((value & redMask)   >>\n                                          redShift);   /* R */\n            image->comps[1].data[index] = (OPJ_INT32)((value & greenMask) >>\n                                          greenShift); /* G */\n            image->comps[2].data[index] = (OPJ_INT32)((value & blueMask)  >>\n                                          blueShift);  /* B */\n            if (hasAlpha) {\n                image->comps[3].data[index] = (OPJ_INT32)((value & alphaMask)  >>\n                                              alphaShift);  /* A */\n            }\n            index++;\n        }\n        pSrc -= stride;\n    }\n}\n\nstatic void bmpmask16toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride,\n                             opj_image_t* image, OPJ_UINT32 redMask, OPJ_UINT32 greenMask,\n                             OPJ_UINT32 blueMask, OPJ_UINT32 alphaMask)\n{\n    int index;\n    OPJ_UINT32 width, height;\n    OPJ_UINT32 x, y;\n    const OPJ_UINT8 *pSrc = NULL;\n    OPJ_BOOL hasAlpha;\n    OPJ_UINT32 redShift,   redPrec;\n    OPJ_UINT32 greenShift, greenPrec;\n    OPJ_UINT32 blueShift,  bluePrec;\n    OPJ_UINT32 alphaShift, alphaPrec;\n\n    width  = image->comps[0].w;\n    height = image->comps[0].h;\n\n    hasAlpha = image->numcomps > 3U;\n\n    bmp_mask_get_shift_and_prec(redMask,   &redShift,   &redPrec);\n    bmp_mask_get_shift_and_prec(greenMask, &greenShift, &greenPrec);\n    bmp_mask_get_shift_and_prec(blueMask,  &blueShift,  &bluePrec);\n    bmp_mask_get_shift_and_prec(alphaMask, &alphaShift, &alphaPrec);\n\n    image->comps[0].bpp = redPrec;\n    image->comps[0].prec = redPrec;\n    image->comps[1].bpp = greenPrec;\n    image->comps[1].prec = greenPrec;\n    image->comps[2].bpp = bluePrec;\n    image->comps[2].prec = bluePrec;\n    if (hasAlpha) {\n        image->comps[3].bpp = alphaPrec;\n        image->comps[3].prec = alphaPrec;\n    }\n\n    index = 0;\n    pSrc = pData + (height - 1U) * stride;\n    for (y = 0; y < height; y++) {\n        for (x = 0; x < width; x++) {\n            OPJ_UINT32 value = 0U;\n\n            value |= ((OPJ_UINT32)pSrc[2 * x + 0]) <<  0;\n            value |= ((OPJ_UINT32)pSrc[2 * x + 1]) <<  8;\n\n            image->comps[0].data[index] = (OPJ_INT32)((value & redMask)   >>\n                                          redShift);   /* R */\n            image->comps[1].data[index] = (OPJ_INT32)((value & greenMask) >>\n                                          greenShift); /* G */\n            image->comps[2].data[index] = (OPJ_INT32)((value & blueMask)  >>\n                                          blueShift);  /* B */\n            if (hasAlpha) {\n                image->comps[3].data[index] = (OPJ_INT32)((value & alphaMask)  >>\n                                              alphaShift);  /* A */\n            }\n            index++;\n        }\n        pSrc -= stride;\n    }\n}\n\nstatic opj_image_t* bmp8toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride,\n                                opj_image_t* image, OPJ_UINT8 const* const* pLUT)\n{\n    OPJ_UINT32 width, height;\n    const OPJ_UINT8 *pSrc = NULL;\n\n    width  = image->comps[0].w;\n    height = image->comps[0].h;\n\n    pSrc = pData + (height - 1U) * stride;\n    if (image->numcomps == 1U) {\n        opj_applyLUT8u_8u32s_C1R(pSrc, -(OPJ_INT32)stride, image->comps[0].data,\n                                 (OPJ_INT32)width, pLUT[0], width, height);\n    } else {\n        OPJ_INT32* pDst[3];\n        OPJ_INT32  pDstStride[3];\n\n        pDst[0] = image->comps[0].data;\n        pDst[1] = image->comps[1].data;\n        pDst[2] = image->comps[2].data;\n        pDstStride[0] = (OPJ_INT32)width;\n        pDstStride[1] = (OPJ_INT32)width;\n        pDstStride[2] = (OPJ_INT32)width;\n        opj_applyLUT8u_8u32s_C1P3R(pSrc, -(OPJ_INT32)stride, pDst, pDstStride, pLUT,\n                                   width, height);\n    }\n    return image;\n}\n\nstatic OPJ_BOOL bmp_read_file_header(FILE* IN, OPJ_BITMAPFILEHEADER* header)\n{\n    header->bfType  = (OPJ_UINT16)getc(IN);\n    header->bfType |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\n    if (header->bfType != 19778) {\n        fprintf(stderr, \"Error, not a BMP file!\\n\");\n        return OPJ_FALSE;\n    }\n\n    /* FILE HEADER */\n    /* ------------- */\n    header->bfSize  = (OPJ_UINT32)getc(IN);\n    header->bfSize |= (OPJ_UINT32)getc(IN) << 8;\n    header->bfSize |= (OPJ_UINT32)getc(IN) << 16;\n    header->bfSize |= (OPJ_UINT32)getc(IN) << 24;\n\n    header->bfReserved1  = (OPJ_UINT16)getc(IN);\n    header->bfReserved1 |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\n    header->bfReserved2  = (OPJ_UINT16)getc(IN);\n    header->bfReserved2 |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\n    header->bfOffBits  = (OPJ_UINT32)getc(IN);\n    header->bfOffBits |= (OPJ_UINT32)getc(IN) << 8;\n    header->bfOffBits |= (OPJ_UINT32)getc(IN) << 16;\n    header->bfOffBits |= (OPJ_UINT32)getc(IN) << 24;\n    return OPJ_TRUE;\n}\nstatic OPJ_BOOL bmp_read_info_header(FILE* IN, OPJ_BITMAPINFOHEADER* header)\n{\n    memset(header, 0, sizeof(*header));\n    /* INFO HEADER */\n    /* ------------- */\n    header->biSize  = (OPJ_UINT32)getc(IN);\n    header->biSize |= (OPJ_UINT32)getc(IN) << 8;\n    header->biSize |= (OPJ_UINT32)getc(IN) << 16;\n    header->biSize |= (OPJ_UINT32)getc(IN) << 24;\n\n    switch (header->biSize) {\n    case 12U:  /* BITMAPCOREHEADER */\n    case 40U:  /* BITMAPINFOHEADER */\n    case 52U:  /* BITMAPV2INFOHEADER */\n    case 56U:  /* BITMAPV3INFOHEADER */\n    case 108U: /* BITMAPV4HEADER */\n    case 124U: /* BITMAPV5HEADER */\n        break;\n    default:\n        fprintf(stderr, \"Error, unknown BMP header size %d\\n\", header->biSize);\n        return OPJ_FALSE;\n    }\n\n    header->biWidth  = (OPJ_UINT32)getc(IN);\n    header->biWidth |= (OPJ_UINT32)getc(IN) << 8;\n    header->biWidth |= (OPJ_UINT32)getc(IN) << 16;\n    header->biWidth |= (OPJ_UINT32)getc(IN) << 24;\n\n    header->biHeight  = (OPJ_UINT32)getc(IN);\n    header->biHeight |= (OPJ_UINT32)getc(IN) << 8;\n    header->biHeight |= (OPJ_UINT32)getc(IN) << 16;\n    header->biHeight |= (OPJ_UINT32)getc(IN) << 24;\n\n    header->biPlanes  = (OPJ_UINT16)getc(IN);\n    header->biPlanes |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\n    header->biBitCount  = (OPJ_UINT16)getc(IN);\n    header->biBitCount |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\n    if (header->biSize >= 40U) {\n        header->biCompression  = (OPJ_UINT32)getc(IN);\n        header->biCompression |= (OPJ_UINT32)getc(IN) << 8;\n        header->biCompression |= (OPJ_UINT32)getc(IN) << 16;\n        header->biCompression |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biSizeImage  = (OPJ_UINT32)getc(IN);\n        header->biSizeImage |= (OPJ_UINT32)getc(IN) << 8;\n        header->biSizeImage |= (OPJ_UINT32)getc(IN) << 16;\n        header->biSizeImage |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biXpelsPerMeter  = (OPJ_UINT32)getc(IN);\n        header->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 8;\n        header->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 16;\n        header->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biYpelsPerMeter  = (OPJ_UINT32)getc(IN);\n        header->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 8;\n        header->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 16;\n        header->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biClrUsed  = (OPJ_UINT32)getc(IN);\n        header->biClrUsed |= (OPJ_UINT32)getc(IN) << 8;\n        header->biClrUsed |= (OPJ_UINT32)getc(IN) << 16;\n        header->biClrUsed |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biClrImportant  = (OPJ_UINT32)getc(IN);\n        header->biClrImportant |= (OPJ_UINT32)getc(IN) << 8;\n        header->biClrImportant |= (OPJ_UINT32)getc(IN) << 16;\n        header->biClrImportant |= (OPJ_UINT32)getc(IN) << 24;\n    }\n\n    if (header->biSize >= 56U) {\n        header->biRedMask  = (OPJ_UINT32)getc(IN);\n        header->biRedMask |= (OPJ_UINT32)getc(IN) << 8;\n        header->biRedMask |= (OPJ_UINT32)getc(IN) << 16;\n        header->biRedMask |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biGreenMask  = (OPJ_UINT32)getc(IN);\n        header->biGreenMask |= (OPJ_UINT32)getc(IN) << 8;\n        header->biGreenMask |= (OPJ_UINT32)getc(IN) << 16;\n        header->biGreenMask |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biBlueMask  = (OPJ_UINT32)getc(IN);\n        header->biBlueMask |= (OPJ_UINT32)getc(IN) << 8;\n        header->biBlueMask |= (OPJ_UINT32)getc(IN) << 16;\n        header->biBlueMask |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biAlphaMask  = (OPJ_UINT32)getc(IN);\n        header->biAlphaMask |= (OPJ_UINT32)getc(IN) << 8;\n        header->biAlphaMask |= (OPJ_UINT32)getc(IN) << 16;\n        header->biAlphaMask |= (OPJ_UINT32)getc(IN) << 24;\n    }\n\n    if (header->biSize >= 108U) {\n        header->biColorSpaceType  = (OPJ_UINT32)getc(IN);\n        header->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 8;\n        header->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 16;\n        header->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 24;\n\n        if (fread(&(header->biColorSpaceEP), 1U, sizeof(header->biColorSpaceEP),\n                  IN) != sizeof(header->biColorSpaceEP)) {\n            fprintf(stderr, \"Error, can't  read BMP header\\n\");\n            return OPJ_FALSE;\n        }\n\n        header->biRedGamma  = (OPJ_UINT32)getc(IN);\n        header->biRedGamma |= (OPJ_UINT32)getc(IN) << 8;\n        header->biRedGamma |= (OPJ_UINT32)getc(IN) << 16;\n        header->biRedGamma |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biGreenGamma  = (OPJ_UINT32)getc(IN);\n        header->biGreenGamma |= (OPJ_UINT32)getc(IN) << 8;\n        header->biGreenGamma |= (OPJ_UINT32)getc(IN) << 16;\n        header->biGreenGamma |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biBlueGamma  = (OPJ_UINT32)getc(IN);\n        header->biBlueGamma |= (OPJ_UINT32)getc(IN) << 8;\n        header->biBlueGamma |= (OPJ_UINT32)getc(IN) << 16;\n        header->biBlueGamma |= (OPJ_UINT32)getc(IN) << 24;\n    }\n\n    if (header->biSize >= 124U) {\n        header->biIntent  = (OPJ_UINT32)getc(IN);\n        header->biIntent |= (OPJ_UINT32)getc(IN) << 8;\n        header->biIntent |= (OPJ_UINT32)getc(IN) << 16;\n        header->biIntent |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biIccProfileData  = (OPJ_UINT32)getc(IN);\n        header->biIccProfileData |= (OPJ_UINT32)getc(IN) << 8;\n        header->biIccProfileData |= (OPJ_UINT32)getc(IN) << 16;\n        header->biIccProfileData |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biIccProfileSize  = (OPJ_UINT32)getc(IN);\n        header->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 8;\n        header->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 16;\n        header->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biReserved  = (OPJ_UINT32)getc(IN);\n        header->biReserved |= (OPJ_UINT32)getc(IN) << 8;\n        header->biReserved |= (OPJ_UINT32)getc(IN) << 16;\n        header->biReserved |= (OPJ_UINT32)getc(IN) << 24;\n    }\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_raw_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride,\n                                  OPJ_UINT32 width, OPJ_UINT32 height)\n{\n    OPJ_ARG_NOT_USED(width);\n\n    if (fread(pData, sizeof(OPJ_UINT8), stride * height, IN) != (stride * height)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return OPJ_FALSE;\n    }\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,\n                                   OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n    OPJ_UINT32 x, y;\n    OPJ_UINT8 *pix;\n    const OPJ_UINT8 *beyond;\n\n    beyond = pData + stride * height;\n    pix = pData;\n\n    x = y = 0U;\n    while (y < height) {\n        int c = getc(IN);\n\n        if (c) {\n            int j;\n            OPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\n            for (j = 0; (j < c) && (x < width) &&\n                    ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                *pix = c1;\n            }\n        } else {\n            c = getc(IN);\n            if (c == 0x00) { /* EOL */\n                x = 0;\n                ++y;\n                pix = pData + y * stride + x;\n            } else if (c == 0x01) { /* EOP */\n                break;\n            } else if (c == 0x02) { /* MOVE by dxdy */\n                c = getc(IN);\n                x += (OPJ_UINT32)c;\n                c = getc(IN);\n                y += (OPJ_UINT32)c;\n                pix = pData + y * stride + x;\n            } else { /* 03 .. 255 */\n                int j;\n                for (j = 0; (j < c) && (x < width) &&\n                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                    OPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n                    *pix = c1;\n                }\n                if ((OPJ_UINT32)c & 1U) { /* skip padding byte */\n                    getc(IN);\n                }\n            }\n        }\n    }/* while() */\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData,\n                                   OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n    OPJ_UINT32 x, y;\n    OPJ_UINT8 *pix;\n    const OPJ_UINT8 *beyond;\n\n    beyond = pData + stride * height;\n    pix = pData;\n    x = y = 0U;\n    while (y < height) {\n        int c = getc(IN);\n        if (c == EOF) {\n            break;\n        }\n\n        if (c) { /* encoded mode */\n            int j;\n            OPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\n            for (j = 0; (j < c) && (x < width) &&\n                    ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                *pix = (OPJ_UINT8)((j & 1) ? (c1 & 0x0fU) : ((c1 >> 4) & 0x0fU));\n            }\n        } else { /* absolute mode */\n            c = getc(IN);\n            if (c == EOF) {\n                break;\n            }\n\n            if (c == 0x00) { /* EOL */\n                x = 0;\n                y++;\n                pix = pData + y * stride;\n            } else if (c == 0x01) { /* EOP */\n                break;\n            } else if (c == 0x02) { /* MOVE by dxdy */\n                c = getc(IN);\n                x += (OPJ_UINT32)c;\n                c = getc(IN);\n                y += (OPJ_UINT32)c;\n                pix = pData + y * stride + x;\n            } else { /* 03 .. 255 : absolute mode */\n                int j;\n                OPJ_UINT8 c1 = 0U;\n\n                for (j = 0; (j < c) && (x < width) &&\n                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                    if ((j & 1) == 0) {\n                        c1 = (OPJ_UINT8)getc(IN);\n                    }\n                    *pix = (OPJ_UINT8)((j & 1) ? (c1 & 0x0fU) : ((c1 >> 4) & 0x0fU));\n                }\n                if (((c & 3) == 1) || ((c & 3) == 2)) { /* skip padding byte */\n                    getc(IN);\n                }\n            }\n        }\n    }  /* while(y < height) */\n    return OPJ_TRUE;\n}\n\nopj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters)\n{\n    opj_image_cmptparm_t cmptparm[4];   /* maximum of 4 components */\n    OPJ_UINT8 lut_R[256], lut_G[256], lut_B[256];\n    OPJ_UINT8 const* pLUT[3];\n    opj_image_t * image = NULL;\n    FILE *IN;\n    OPJ_BITMAPFILEHEADER File_h;\n    OPJ_BITMAPINFOHEADER Info_h;\n    OPJ_UINT32 i, palette_len, numcmpts = 1U;\n    OPJ_BOOL l_result = OPJ_FALSE;\n    OPJ_UINT8* pData = NULL;\n    OPJ_UINT32 stride;\n\n    pLUT[0] = lut_R;\n    pLUT[1] = lut_G;\n    pLUT[2] = lut_B;\n\n    IN = fopen(filename, \"rb\");\n    if (!IN) {\n        fprintf(stderr, \"Failed to open %s for reading !!\\n\", filename);\n        return NULL;\n    }\n\n    if (!bmp_read_file_header(IN, &File_h)) {\n        fclose(IN);\n        return NULL;\n    }\n    if (!bmp_read_info_header(IN, &Info_h)) {\n        fclose(IN);\n        return NULL;\n    }\n\n    /* Load palette */\n    if (Info_h.biBitCount <= 8U) {\n        memset(&lut_R[0], 0, sizeof(lut_R));\n        memset(&lut_G[0], 0, sizeof(lut_G));\n        memset(&lut_B[0], 0, sizeof(lut_B));\n\n        palette_len = Info_h.biClrUsed;\n        if ((palette_len == 0U) && (Info_h.biBitCount <= 8U)) {\n            palette_len = (1U << Info_h.biBitCount);\n        }\n        if (palette_len > 256U) {\n            palette_len = 256U;\n        }\n        if (palette_len > 0U) {\n            OPJ_UINT8 has_color = 0U;\n            for (i = 0U; i < palette_len; i++) {\n                lut_B[i] = (OPJ_UINT8)getc(IN);\n                lut_G[i] = (OPJ_UINT8)getc(IN);\n                lut_R[i] = (OPJ_UINT8)getc(IN);\n                (void)getc(IN); /* padding */\n                has_color |= (lut_B[i] ^ lut_G[i]) | (lut_G[i] ^ lut_R[i]);\n            }\n            if (has_color) {\n                numcmpts = 3U;\n            }\n        }\n    } else {\n        numcmpts = 3U;\n        if ((Info_h.biCompression == 3) && (Info_h.biAlphaMask != 0U)) {\n            numcmpts++;\n        }\n    }\n\n    if (Info_h.biWidth == 0 || Info_h.biHeight == 0) {\n        fclose(IN);\n        return NULL;\n    }\n\n    if (Info_h.biBitCount > (((OPJ_UINT32) - 1) - 31) / Info_h.biWidth) {\n        fclose(IN);\n        return NULL;\n    }\n    stride = ((Info_h.biWidth * Info_h.biBitCount + 31U) / 32U) *\n             4U; /* rows are aligned on 32bits */\n    if (Info_h.biBitCount == 4 &&\n            Info_h.biCompression == 2) { /* RLE 4 gets decoded as 8 bits data for now... */\n        if (8 > (((OPJ_UINT32) - 1) - 31) / Info_h.biWidth) {\n            fclose(IN);\n            return NULL;\n        }\n        stride = ((Info_h.biWidth * 8U + 31U) / 32U) * 4U;\n    }\n\n    if (stride > ((OPJ_UINT32) - 1) / sizeof(OPJ_UINT8) / Info_h.biHeight) {\n        fclose(IN);\n        return NULL;\n    }\n    pData = (OPJ_UINT8 *) calloc(1, stride * Info_h.biHeight * sizeof(OPJ_UINT8));\n    if (pData == NULL) {\n        fclose(IN);\n        return NULL;\n    }\n    /* Place the cursor at the beginning of the image information */\n    fseek(IN, 0, SEEK_SET);\n    fseek(IN, (long)File_h.bfOffBits, SEEK_SET);\n\n    switch (Info_h.biCompression) {\n    case 0:\n    case 3:\n        /* read raw data */\n        l_result = bmp_read_raw_data(IN, pData, stride, Info_h.biWidth,\n                                     Info_h.biHeight);\n        break;\n    case 1:\n        /* read rle8 data */\n        l_result = bmp_read_rle8_data(IN, pData, stride, Info_h.biWidth,\n                                      Info_h.biHeight);\n        break;\n    case 2:\n        /* read rle4 data */\n        l_result = bmp_read_rle4_data(IN, pData, stride, Info_h.biWidth,\n                                      Info_h.biHeight);\n        break;\n    default:\n        fprintf(stderr, \"Unsupported BMP compression\\n\");\n        l_result = OPJ_FALSE;\n        break;\n    }\n    if (!l_result) {\n        free(pData);\n        fclose(IN);\n        return NULL;\n    }\n\n    /* create the image */\n    memset(&cmptparm[0], 0, sizeof(cmptparm));\n    for (i = 0; i < 4U; i++) {\n        cmptparm[i].prec = 8;\n        cmptparm[i].bpp  = 8;\n        cmptparm[i].sgnd = 0;\n        cmptparm[i].dx   = (OPJ_UINT32)parameters->subsampling_dx;\n        cmptparm[i].dy   = (OPJ_UINT32)parameters->subsampling_dy;\n        cmptparm[i].w    = Info_h.biWidth;\n        cmptparm[i].h    = Info_h.biHeight;\n    }\n\n    image = opj_image_create(numcmpts, &cmptparm[0],\n                             (numcmpts == 1U) ? OPJ_CLRSPC_GRAY : OPJ_CLRSPC_SRGB);\n    if (!image) {\n        fclose(IN);\n        free(pData);\n        return NULL;\n    }\n    if (numcmpts == 4U) {\n        image->comps[3].alpha = 1;\n    }\n\n    /* set image offset and reference grid */\n    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    image->x1 = image->x0 + (Info_h.biWidth  - 1U) * (OPJ_UINT32)\n                parameters->subsampling_dx + 1U;\n    image->y1 = image->y0 + (Info_h.biHeight - 1U) * (OPJ_UINT32)\n                parameters->subsampling_dy + 1U;\n\n    /* Read the data */\n    if (Info_h.biBitCount == 24 && Info_h.biCompression == 0) { /*RGB */\n        bmp24toimage(pData, stride, image);\n    } else if (Info_h.biBitCount == 8 &&\n               Info_h.biCompression == 0) { /* RGB 8bpp Indexed */\n        bmp8toimage(pData, stride, image, pLUT);\n    } else if (Info_h.biBitCount == 8 && Info_h.biCompression == 1) { /*RLE8*/\n        bmp8toimage(pData, stride, image, pLUT);\n    } else if (Info_h.biBitCount == 4 && Info_h.biCompression == 2) { /*RLE4*/\n        bmp8toimage(pData, stride, image,\n                    pLUT); /* RLE 4 gets decoded as 8 bits data for now */\n    } else if (Info_h.biBitCount == 32 && Info_h.biCompression == 0) { /* RGBX */\n        bmpmask32toimage(pData, stride, image, 0x00FF0000U, 0x0000FF00U, 0x000000FFU,\n                         0x00000000U);\n    } else if (Info_h.biBitCount == 32 && Info_h.biCompression == 3) { /* bitmask */\n        bmpmask32toimage(pData, stride, image, Info_h.biRedMask, Info_h.biGreenMask,\n                         Info_h.biBlueMask, Info_h.biAlphaMask);\n    } else if (Info_h.biBitCount == 16 && Info_h.biCompression == 0) { /* RGBX */\n        bmpmask16toimage(pData, stride, image, 0x7C00U, 0x03E0U, 0x001FU, 0x0000U);\n    } else if (Info_h.biBitCount == 16 && Info_h.biCompression == 3) { /* bitmask */\n        if ((Info_h.biRedMask == 0U) && (Info_h.biGreenMask == 0U) &&\n                (Info_h.biBlueMask == 0U)) {\n            Info_h.biRedMask   = 0xF800U;\n            Info_h.biGreenMask = 0x07E0U;\n            Info_h.biBlueMask  = 0x001FU;\n        }\n        bmpmask16toimage(pData, stride, image, Info_h.biRedMask, Info_h.biGreenMask,\n                         Info_h.biBlueMask, Info_h.biAlphaMask);\n    } else {\n        opj_image_destroy(image);\n        image = NULL;\n        fprintf(stderr,\n                \"Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\\n\",\n                Info_h.biBitCount);\n    }\n    free(pData);\n    fclose(IN);\n    return image;\n}\n\nint imagetobmp(opj_image_t * image, const char *outfile)\n{\n    int w, h;\n    int i, pad;\n    FILE *fdest = NULL;\n    int adjustR, adjustG, adjustB;\n\n    if (image->comps[0].prec < 8) {\n        fprintf(stderr, \"imagetobmp: Unsupported precision: %d\\n\",\n                image->comps[0].prec);\n        return 1;\n    }\n    if (image->numcomps >= 3 && image->comps[0].dx == image->comps[1].dx\n            && image->comps[1].dx == image->comps[2].dx\n            && image->comps[0].dy == image->comps[1].dy\n            && image->comps[1].dy == image->comps[2].dy\n            && image->comps[0].prec == image->comps[1].prec\n            && image->comps[1].prec == image->comps[2].prec\n            && image->comps[0].sgnd == image->comps[1].sgnd\n            && image->comps[1].sgnd == image->comps[2].sgnd) {\n\n        /* -->> -->> -->> -->>\n        24 bits color\n        <<-- <<-- <<-- <<-- */\n\n        fdest = fopen(outfile, \"wb\");\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return 1;\n        }\n\n        w = (int)image->comps[0].w;\n        h = (int)image->comps[0].h;\n\n        fprintf(fdest, \"BM\");\n\n        /* FILE HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\",\n                (OPJ_UINT8)(h * w * 3 + 3 * h * (w % 2) + 54) & 0xff,\n                (OPJ_UINT8)((h * w * 3 + 3 * h * (w % 2) + 54) >> 8) & 0xff,\n                (OPJ_UINT8)((h * w * 3 + 3 * h * (w % 2) + 54) >> 16) & 0xff,\n                (OPJ_UINT8)((h * w * 3 + 3 * h * (w % 2) + 54) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff,\n                ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (54) & 0xff, ((54) >> 8) & 0xff, ((54) >> 16) & 0xff,\n                ((54) >> 24) & 0xff);\n\n        /* INFO HEADER   */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (40) & 0xff, ((40) >> 8) & 0xff, ((40) >> 16) & 0xff,\n                ((40) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8)((w) & 0xff),\n                (OPJ_UINT8)((w) >> 8) & 0xff,\n                (OPJ_UINT8)((w) >> 16) & 0xff,\n                (OPJ_UINT8)((w) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8)((h) & 0xff),\n                (OPJ_UINT8)((h) >> 8) & 0xff,\n                (OPJ_UINT8)((h) >> 16) & 0xff,\n                (OPJ_UINT8)((h) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c\", (1) & 0xff, ((1) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c\", (24) & 0xff, ((24) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff,\n                ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8)(3 * h * w + 3 * h * (w % 2)) & 0xff,\n                (OPJ_UINT8)((h * w * 3 + 3 * h * (w % 2)) >> 8) & 0xff,\n                (OPJ_UINT8)((h * w * 3 + 3 * h * (w % 2)) >> 16) & 0xff,\n                (OPJ_UINT8)((h * w * 3 + 3 * h * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\n                ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\n                ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff,\n                ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff,\n                ((0) >> 24) & 0xff);\n\n        if (image->comps[0].prec > 8) {\n            adjustR = (int)image->comps[0].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\\n\",\n                   image->comps[0].prec);\n        } else {\n            adjustR = 0;\n        }\n        if (image->comps[1].prec > 8) {\n            adjustG = (int)image->comps[1].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\\n\",\n                   image->comps[1].prec);\n        } else {\n            adjustG = 0;\n        }\n        if (image->comps[2].prec > 8) {\n            adjustB = (int)image->comps[2].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\\n\",\n                   image->comps[2].prec);\n        } else {\n            adjustB = 0;\n        }\n\n        for (i = 0; i < w * h; i++) {\n            OPJ_UINT8 rc, gc, bc;\n            int r, g, b;\n\n            r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n            if (adjustR > 0) {\n                r = ((r >> adjustR) + ((r >> (adjustR - 1)) % 2));\n            }\n            if (r > 255) {\n                r = 255;\n            } else if (r < 0) {\n                r = 0;\n            }\n            rc = (OPJ_UINT8)r;\n\n            g = image->comps[1].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            g += (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n            if (adjustG > 0) {\n                g = ((g >> adjustG) + ((g >> (adjustG - 1)) % 2));\n            }\n            if (g > 255) {\n                g = 255;\n            } else if (g < 0) {\n                g = 0;\n            }\n            gc = (OPJ_UINT8)g;\n\n            b = image->comps[2].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            b += (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n            if (adjustB > 0) {\n                b = ((b >> adjustB) + ((b >> (adjustB - 1)) % 2));\n            }\n            if (b > 255) {\n                b = 255;\n            } else if (b < 0) {\n                b = 0;\n            }\n            bc = (OPJ_UINT8)b;\n\n            fprintf(fdest, \"%c%c%c\", bc, gc, rc);\n\n            if ((i + 1) % w == 0) {\n                for (pad = ((3 * w) % 4) ? (4 - (3 * w) % 4) : 0; pad > 0; pad--) { /* ADD */\n                    fprintf(fdest, \"%c\", 0);\n                }\n            }\n        }\n        fclose(fdest);\n    } else {            /* Gray-scale */\n\n        /* -->> -->> -->> -->>\n        8 bits non code (Gray scale)\n        <<-- <<-- <<-- <<-- */\n\n        fdest = fopen(outfile, \"wb\");\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return 1;\n        }\n        if (image->numcomps > 1) {\n            fprintf(stderr, \"imagetobmp: only first component of %d is used.\\n\",\n                    image->numcomps);\n        }\n        w = (int)image->comps[0].w;\n        h = (int)image->comps[0].h;\n\n        fprintf(fdest, \"BM\");\n\n        /* FILE HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8)(h * w + 54 + 1024 + h * (w % 2)) & 0xff,\n                (OPJ_UINT8)((h * w + 54 + 1024 + h * (w % 2)) >> 8) & 0xff,\n                (OPJ_UINT8)((h * w + 54 + 1024 + h * (w % 2)) >> 16) & 0xff,\n                (OPJ_UINT8)((h * w + 54 + 1024 + w * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff,\n                ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (54 + 1024) & 0xff, ((54 + 1024) >> 8) & 0xff,\n                ((54 + 1024) >> 16) & 0xff,\n                ((54 + 1024) >> 24) & 0xff);\n\n        /* INFO HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (40) & 0xff, ((40) >> 8) & 0xff, ((40) >> 16) & 0xff,\n                ((40) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8)((w) & 0xff),\n                (OPJ_UINT8)((w) >> 8) & 0xff,\n                (OPJ_UINT8)((w) >> 16) & 0xff,\n                (OPJ_UINT8)((w) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8)((h) & 0xff),\n                (OPJ_UINT8)((h) >> 8) & 0xff,\n                (OPJ_UINT8)((h) >> 16) & 0xff,\n                (OPJ_UINT8)((h) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c\", (1) & 0xff, ((1) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c\", (8) & 0xff, ((8) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff,\n                ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8)(h * w + h * (w % 2)) & 0xff,\n                (OPJ_UINT8)((h * w + h * (w % 2)) >> 8) &  0xff,\n                (OPJ_UINT8)((h * w + h * (w % 2)) >> 16) & 0xff,\n                (OPJ_UINT8)((h * w + h * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\n                ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\n                ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (256) & 0xff, ((256) >> 8) & 0xff,\n                ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (256) & 0xff, ((256) >> 8) & 0xff,\n                ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);\n\n        if (image->comps[0].prec > 8) {\n            adjustR = (int)image->comps[0].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\\n\",\n                   image->comps[0].prec);\n        } else {\n            adjustR = 0;\n        }\n\n        for (i = 0; i < 256; i++) {\n            fprintf(fdest, \"%c%c%c%c\", i, i, i, 0);\n        }\n\n        for (i = 0; i < w * h; i++) {\n            int r;\n\n            r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n            if (adjustR > 0) {\n                r = ((r >> adjustR) + ((r >> (adjustR - 1)) % 2));\n            }\n            if (r > 255) {\n                r = 255;\n            } else if (r < 0) {\n                r = 0;\n            }\n\n            fprintf(fdest, \"%c\", (OPJ_UINT8)r);\n\n            if ((i + 1) % w == 0) {\n                for (pad = (w % 4) ? (4 - w % 4) : 0; pad > 0; pad--) { /* ADD */\n                    fprintf(fdest, \"%c\", 0);\n                }\n            }\n        }\n        fclose(fdest);\n    }\n\n    return 0;\n}\n"], "fixing_code": ["/*\n * The copyright in this software is being made available under the 2-clauses\n * BSD License, included below. This software may be subject to other third\n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux\n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#include \"opj_apps_config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"openjpeg.h\"\n#include \"convert.h\"\n\ntypedef struct {\n    OPJ_UINT16 bfType;      /* 'BM' for Bitmap (19776) */\n    OPJ_UINT32 bfSize;      /* Size of the file        */\n    OPJ_UINT16 bfReserved1; /* Reserved : 0            */\n    OPJ_UINT16 bfReserved2; /* Reserved : 0            */\n    OPJ_UINT32 bfOffBits;   /* Offset                  */\n} OPJ_BITMAPFILEHEADER;\n\ntypedef struct {\n    OPJ_UINT32 biSize;             /* Size of the structure in bytes */\n    OPJ_UINT32 biWidth;            /* Width of the image in pixels */\n    OPJ_UINT32 biHeight;           /* Height of the image in pixels */\n    OPJ_UINT16 biPlanes;           /* 1 */\n    OPJ_UINT16 biBitCount;         /* Number of color bits by pixels */\n    OPJ_UINT32 biCompression;      /* Type of encoding 0: none 1: RLE8 2: RLE4 */\n    OPJ_UINT32 biSizeImage;        /* Size of the image in bytes */\n    OPJ_UINT32 biXpelsPerMeter;    /* Horizontal (X) resolution in pixels/meter */\n    OPJ_UINT32 biYpelsPerMeter;    /* Vertical (Y) resolution in pixels/meter */\n    OPJ_UINT32 biClrUsed;          /* Number of color used in the image (0: ALL) */\n    OPJ_UINT32 biClrImportant;     /* Number of important color (0: ALL) */\n    OPJ_UINT32 biRedMask;          /* Red channel bit mask */\n    OPJ_UINT32 biGreenMask;        /* Green channel bit mask */\n    OPJ_UINT32 biBlueMask;         /* Blue channel bit mask */\n    OPJ_UINT32 biAlphaMask;        /* Alpha channel bit mask */\n    OPJ_UINT32 biColorSpaceType;   /* Color space type */\n    OPJ_UINT8  biColorSpaceEP[36]; /* Color space end points */\n    OPJ_UINT32 biRedGamma;         /* Red channel gamma */\n    OPJ_UINT32 biGreenGamma;       /* Green channel gamma */\n    OPJ_UINT32 biBlueGamma;        /* Blue channel gamma */\n    OPJ_UINT32 biIntent;           /* Intent */\n    OPJ_UINT32 biIccProfileData;   /* ICC profile data */\n    OPJ_UINT32 biIccProfileSize;   /* ICC profile size */\n    OPJ_UINT32 biReserved;         /* Reserved */\n} OPJ_BITMAPINFOHEADER;\n\nstatic void opj_applyLUT8u_8u32s_C1R(\n    OPJ_UINT8 const* pSrc, OPJ_INT32 srcStride,\n    OPJ_INT32* pDst, OPJ_INT32 dstStride,\n    OPJ_UINT8 const* pLUT,\n    OPJ_UINT32 width, OPJ_UINT32 height)\n{\n    OPJ_UINT32 y;\n\n    for (y = height; y != 0U; --y) {\n        OPJ_UINT32 x;\n\n        for (x = 0; x < width; x++) {\n            pDst[x] = (OPJ_INT32)pLUT[pSrc[x]];\n        }\n        pSrc += srcStride;\n        pDst += dstStride;\n    }\n}\n\nstatic void opj_applyLUT8u_8u32s_C1P3R(\n    OPJ_UINT8 const* pSrc, OPJ_INT32 srcStride,\n    OPJ_INT32* const* pDst, OPJ_INT32 const* pDstStride,\n    OPJ_UINT8 const* const* pLUT,\n    OPJ_UINT32 width, OPJ_UINT32 height)\n{\n    OPJ_UINT32 y;\n    OPJ_INT32* pR = pDst[0];\n    OPJ_INT32* pG = pDst[1];\n    OPJ_INT32* pB = pDst[2];\n    OPJ_UINT8 const* pLUT_R = pLUT[0];\n    OPJ_UINT8 const* pLUT_G = pLUT[1];\n    OPJ_UINT8 const* pLUT_B = pLUT[2];\n\n    for (y = height; y != 0U; --y) {\n        OPJ_UINT32 x;\n\n        for (x = 0; x < width; x++) {\n            OPJ_UINT8 idx = pSrc[x];\n            pR[x] = (OPJ_INT32)pLUT_R[idx];\n            pG[x] = (OPJ_INT32)pLUT_G[idx];\n            pB[x] = (OPJ_INT32)pLUT_B[idx];\n        }\n        pSrc += srcStride;\n        pR += pDstStride[0];\n        pG += pDstStride[1];\n        pB += pDstStride[2];\n    }\n}\n\nstatic void bmp24toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride,\n                         opj_image_t* image)\n{\n    int index;\n    OPJ_UINT32 width, height;\n    OPJ_UINT32 x, y;\n    const OPJ_UINT8 *pSrc = NULL;\n\n    width  = image->comps[0].w;\n    height = image->comps[0].h;\n\n    index = 0;\n    pSrc = pData + (height - 1U) * stride;\n    for (y = 0; y < height; y++) {\n        for (x = 0; x < width; x++) {\n            image->comps[0].data[index] = (OPJ_INT32)pSrc[3 * x + 2]; /* R */\n            image->comps[1].data[index] = (OPJ_INT32)pSrc[3 * x + 1]; /* G */\n            image->comps[2].data[index] = (OPJ_INT32)pSrc[3 * x + 0]; /* B */\n            index++;\n        }\n        pSrc -= stride;\n    }\n}\n\nstatic void bmp_mask_get_shift_and_prec(OPJ_UINT32 mask, OPJ_UINT32* shift,\n                                        OPJ_UINT32* prec)\n{\n    OPJ_UINT32 l_shift, l_prec;\n\n    l_shift = l_prec = 0U;\n\n    if (mask != 0U) {\n        while ((mask & 1U) == 0U) {\n            mask >>= 1;\n            l_shift++;\n        }\n        while (mask & 1U) {\n            mask >>= 1;\n            l_prec++;\n        }\n    }\n    *shift = l_shift;\n    *prec = l_prec;\n}\n\nstatic void bmpmask32toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride,\n                             opj_image_t* image, OPJ_UINT32 redMask, OPJ_UINT32 greenMask,\n                             OPJ_UINT32 blueMask, OPJ_UINT32 alphaMask)\n{\n    int index;\n    OPJ_UINT32 width, height;\n    OPJ_UINT32 x, y;\n    const OPJ_UINT8 *pSrc = NULL;\n    OPJ_BOOL hasAlpha;\n    OPJ_UINT32 redShift,   redPrec;\n    OPJ_UINT32 greenShift, greenPrec;\n    OPJ_UINT32 blueShift,  bluePrec;\n    OPJ_UINT32 alphaShift, alphaPrec;\n\n    width  = image->comps[0].w;\n    height = image->comps[0].h;\n\n    hasAlpha = image->numcomps > 3U;\n\n    bmp_mask_get_shift_and_prec(redMask,   &redShift,   &redPrec);\n    bmp_mask_get_shift_and_prec(greenMask, &greenShift, &greenPrec);\n    bmp_mask_get_shift_and_prec(blueMask,  &blueShift,  &bluePrec);\n    bmp_mask_get_shift_and_prec(alphaMask, &alphaShift, &alphaPrec);\n\n    image->comps[0].bpp = redPrec;\n    image->comps[0].prec = redPrec;\n    image->comps[1].bpp = greenPrec;\n    image->comps[1].prec = greenPrec;\n    image->comps[2].bpp = bluePrec;\n    image->comps[2].prec = bluePrec;\n    if (hasAlpha) {\n        image->comps[3].bpp = alphaPrec;\n        image->comps[3].prec = alphaPrec;\n    }\n\n    index = 0;\n    pSrc = pData + (height - 1U) * stride;\n    for (y = 0; y < height; y++) {\n        for (x = 0; x < width; x++) {\n            OPJ_UINT32 value = 0U;\n\n            value |= ((OPJ_UINT32)pSrc[4 * x + 0]) <<  0;\n            value |= ((OPJ_UINT32)pSrc[4 * x + 1]) <<  8;\n            value |= ((OPJ_UINT32)pSrc[4 * x + 2]) << 16;\n            value |= ((OPJ_UINT32)pSrc[4 * x + 3]) << 24;\n\n            image->comps[0].data[index] = (OPJ_INT32)((value & redMask)   >>\n                                          redShift);   /* R */\n            image->comps[1].data[index] = (OPJ_INT32)((value & greenMask) >>\n                                          greenShift); /* G */\n            image->comps[2].data[index] = (OPJ_INT32)((value & blueMask)  >>\n                                          blueShift);  /* B */\n            if (hasAlpha) {\n                image->comps[3].data[index] = (OPJ_INT32)((value & alphaMask)  >>\n                                              alphaShift);  /* A */\n            }\n            index++;\n        }\n        pSrc -= stride;\n    }\n}\n\nstatic void bmpmask16toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride,\n                             opj_image_t* image, OPJ_UINT32 redMask, OPJ_UINT32 greenMask,\n                             OPJ_UINT32 blueMask, OPJ_UINT32 alphaMask)\n{\n    int index;\n    OPJ_UINT32 width, height;\n    OPJ_UINT32 x, y;\n    const OPJ_UINT8 *pSrc = NULL;\n    OPJ_BOOL hasAlpha;\n    OPJ_UINT32 redShift,   redPrec;\n    OPJ_UINT32 greenShift, greenPrec;\n    OPJ_UINT32 blueShift,  bluePrec;\n    OPJ_UINT32 alphaShift, alphaPrec;\n\n    width  = image->comps[0].w;\n    height = image->comps[0].h;\n\n    hasAlpha = image->numcomps > 3U;\n\n    bmp_mask_get_shift_and_prec(redMask,   &redShift,   &redPrec);\n    bmp_mask_get_shift_and_prec(greenMask, &greenShift, &greenPrec);\n    bmp_mask_get_shift_and_prec(blueMask,  &blueShift,  &bluePrec);\n    bmp_mask_get_shift_and_prec(alphaMask, &alphaShift, &alphaPrec);\n\n    image->comps[0].bpp = redPrec;\n    image->comps[0].prec = redPrec;\n    image->comps[1].bpp = greenPrec;\n    image->comps[1].prec = greenPrec;\n    image->comps[2].bpp = bluePrec;\n    image->comps[2].prec = bluePrec;\n    if (hasAlpha) {\n        image->comps[3].bpp = alphaPrec;\n        image->comps[3].prec = alphaPrec;\n    }\n\n    index = 0;\n    pSrc = pData + (height - 1U) * stride;\n    for (y = 0; y < height; y++) {\n        for (x = 0; x < width; x++) {\n            OPJ_UINT32 value = 0U;\n\n            value |= ((OPJ_UINT32)pSrc[2 * x + 0]) <<  0;\n            value |= ((OPJ_UINT32)pSrc[2 * x + 1]) <<  8;\n\n            image->comps[0].data[index] = (OPJ_INT32)((value & redMask)   >>\n                                          redShift);   /* R */\n            image->comps[1].data[index] = (OPJ_INT32)((value & greenMask) >>\n                                          greenShift); /* G */\n            image->comps[2].data[index] = (OPJ_INT32)((value & blueMask)  >>\n                                          blueShift);  /* B */\n            if (hasAlpha) {\n                image->comps[3].data[index] = (OPJ_INT32)((value & alphaMask)  >>\n                                              alphaShift);  /* A */\n            }\n            index++;\n        }\n        pSrc -= stride;\n    }\n}\n\nstatic opj_image_t* bmp8toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride,\n                                opj_image_t* image, OPJ_UINT8 const* const* pLUT)\n{\n    OPJ_UINT32 width, height;\n    const OPJ_UINT8 *pSrc = NULL;\n\n    width  = image->comps[0].w;\n    height = image->comps[0].h;\n\n    pSrc = pData + (height - 1U) * stride;\n    if (image->numcomps == 1U) {\n        opj_applyLUT8u_8u32s_C1R(pSrc, -(OPJ_INT32)stride, image->comps[0].data,\n                                 (OPJ_INT32)width, pLUT[0], width, height);\n    } else {\n        OPJ_INT32* pDst[3];\n        OPJ_INT32  pDstStride[3];\n\n        pDst[0] = image->comps[0].data;\n        pDst[1] = image->comps[1].data;\n        pDst[2] = image->comps[2].data;\n        pDstStride[0] = (OPJ_INT32)width;\n        pDstStride[1] = (OPJ_INT32)width;\n        pDstStride[2] = (OPJ_INT32)width;\n        opj_applyLUT8u_8u32s_C1P3R(pSrc, -(OPJ_INT32)stride, pDst, pDstStride, pLUT,\n                                   width, height);\n    }\n    return image;\n}\n\nstatic OPJ_BOOL bmp_read_file_header(FILE* IN, OPJ_BITMAPFILEHEADER* header)\n{\n    header->bfType  = (OPJ_UINT16)getc(IN);\n    header->bfType |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\n    if (header->bfType != 19778) {\n        fprintf(stderr, \"Error, not a BMP file!\\n\");\n        return OPJ_FALSE;\n    }\n\n    /* FILE HEADER */\n    /* ------------- */\n    header->bfSize  = (OPJ_UINT32)getc(IN);\n    header->bfSize |= (OPJ_UINT32)getc(IN) << 8;\n    header->bfSize |= (OPJ_UINT32)getc(IN) << 16;\n    header->bfSize |= (OPJ_UINT32)getc(IN) << 24;\n\n    header->bfReserved1  = (OPJ_UINT16)getc(IN);\n    header->bfReserved1 |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\n    header->bfReserved2  = (OPJ_UINT16)getc(IN);\n    header->bfReserved2 |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\n    header->bfOffBits  = (OPJ_UINT32)getc(IN);\n    header->bfOffBits |= (OPJ_UINT32)getc(IN) << 8;\n    header->bfOffBits |= (OPJ_UINT32)getc(IN) << 16;\n    header->bfOffBits |= (OPJ_UINT32)getc(IN) << 24;\n    return OPJ_TRUE;\n}\nstatic OPJ_BOOL bmp_read_info_header(FILE* IN, OPJ_BITMAPINFOHEADER* header)\n{\n    memset(header, 0, sizeof(*header));\n    /* INFO HEADER */\n    /* ------------- */\n    header->biSize  = (OPJ_UINT32)getc(IN);\n    header->biSize |= (OPJ_UINT32)getc(IN) << 8;\n    header->biSize |= (OPJ_UINT32)getc(IN) << 16;\n    header->biSize |= (OPJ_UINT32)getc(IN) << 24;\n\n    switch (header->biSize) {\n    case 12U:  /* BITMAPCOREHEADER */\n    case 40U:  /* BITMAPINFOHEADER */\n    case 52U:  /* BITMAPV2INFOHEADER */\n    case 56U:  /* BITMAPV3INFOHEADER */\n    case 108U: /* BITMAPV4HEADER */\n    case 124U: /* BITMAPV5HEADER */\n        break;\n    default:\n        fprintf(stderr, \"Error, unknown BMP header size %d\\n\", header->biSize);\n        return OPJ_FALSE;\n    }\n\n    header->biWidth  = (OPJ_UINT32)getc(IN);\n    header->biWidth |= (OPJ_UINT32)getc(IN) << 8;\n    header->biWidth |= (OPJ_UINT32)getc(IN) << 16;\n    header->biWidth |= (OPJ_UINT32)getc(IN) << 24;\n\n    header->biHeight  = (OPJ_UINT32)getc(IN);\n    header->biHeight |= (OPJ_UINT32)getc(IN) << 8;\n    header->biHeight |= (OPJ_UINT32)getc(IN) << 16;\n    header->biHeight |= (OPJ_UINT32)getc(IN) << 24;\n\n    header->biPlanes  = (OPJ_UINT16)getc(IN);\n    header->biPlanes |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\n    header->biBitCount  = (OPJ_UINT16)getc(IN);\n    header->biBitCount |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n    if (header->biBitCount == 0) {\n        fprintf(stderr, \"Error, invalid biBitCount %d\\n\", 0);\n        return OPJ_FALSE;\n    }\n\n    if (header->biSize >= 40U) {\n        header->biCompression  = (OPJ_UINT32)getc(IN);\n        header->biCompression |= (OPJ_UINT32)getc(IN) << 8;\n        header->biCompression |= (OPJ_UINT32)getc(IN) << 16;\n        header->biCompression |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biSizeImage  = (OPJ_UINT32)getc(IN);\n        header->biSizeImage |= (OPJ_UINT32)getc(IN) << 8;\n        header->biSizeImage |= (OPJ_UINT32)getc(IN) << 16;\n        header->biSizeImage |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biXpelsPerMeter  = (OPJ_UINT32)getc(IN);\n        header->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 8;\n        header->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 16;\n        header->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biYpelsPerMeter  = (OPJ_UINT32)getc(IN);\n        header->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 8;\n        header->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 16;\n        header->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biClrUsed  = (OPJ_UINT32)getc(IN);\n        header->biClrUsed |= (OPJ_UINT32)getc(IN) << 8;\n        header->biClrUsed |= (OPJ_UINT32)getc(IN) << 16;\n        header->biClrUsed |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biClrImportant  = (OPJ_UINT32)getc(IN);\n        header->biClrImportant |= (OPJ_UINT32)getc(IN) << 8;\n        header->biClrImportant |= (OPJ_UINT32)getc(IN) << 16;\n        header->biClrImportant |= (OPJ_UINT32)getc(IN) << 24;\n    }\n\n    if (header->biSize >= 56U) {\n        header->biRedMask  = (OPJ_UINT32)getc(IN);\n        header->biRedMask |= (OPJ_UINT32)getc(IN) << 8;\n        header->biRedMask |= (OPJ_UINT32)getc(IN) << 16;\n        header->biRedMask |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biGreenMask  = (OPJ_UINT32)getc(IN);\n        header->biGreenMask |= (OPJ_UINT32)getc(IN) << 8;\n        header->biGreenMask |= (OPJ_UINT32)getc(IN) << 16;\n        header->biGreenMask |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biBlueMask  = (OPJ_UINT32)getc(IN);\n        header->biBlueMask |= (OPJ_UINT32)getc(IN) << 8;\n        header->biBlueMask |= (OPJ_UINT32)getc(IN) << 16;\n        header->biBlueMask |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biAlphaMask  = (OPJ_UINT32)getc(IN);\n        header->biAlphaMask |= (OPJ_UINT32)getc(IN) << 8;\n        header->biAlphaMask |= (OPJ_UINT32)getc(IN) << 16;\n        header->biAlphaMask |= (OPJ_UINT32)getc(IN) << 24;\n    }\n\n    if (header->biSize >= 108U) {\n        header->biColorSpaceType  = (OPJ_UINT32)getc(IN);\n        header->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 8;\n        header->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 16;\n        header->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 24;\n\n        if (fread(&(header->biColorSpaceEP), 1U, sizeof(header->biColorSpaceEP),\n                  IN) != sizeof(header->biColorSpaceEP)) {\n            fprintf(stderr, \"Error, can't  read BMP header\\n\");\n            return OPJ_FALSE;\n        }\n\n        header->biRedGamma  = (OPJ_UINT32)getc(IN);\n        header->biRedGamma |= (OPJ_UINT32)getc(IN) << 8;\n        header->biRedGamma |= (OPJ_UINT32)getc(IN) << 16;\n        header->biRedGamma |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biGreenGamma  = (OPJ_UINT32)getc(IN);\n        header->biGreenGamma |= (OPJ_UINT32)getc(IN) << 8;\n        header->biGreenGamma |= (OPJ_UINT32)getc(IN) << 16;\n        header->biGreenGamma |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biBlueGamma  = (OPJ_UINT32)getc(IN);\n        header->biBlueGamma |= (OPJ_UINT32)getc(IN) << 8;\n        header->biBlueGamma |= (OPJ_UINT32)getc(IN) << 16;\n        header->biBlueGamma |= (OPJ_UINT32)getc(IN) << 24;\n    }\n\n    if (header->biSize >= 124U) {\n        header->biIntent  = (OPJ_UINT32)getc(IN);\n        header->biIntent |= (OPJ_UINT32)getc(IN) << 8;\n        header->biIntent |= (OPJ_UINT32)getc(IN) << 16;\n        header->biIntent |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biIccProfileData  = (OPJ_UINT32)getc(IN);\n        header->biIccProfileData |= (OPJ_UINT32)getc(IN) << 8;\n        header->biIccProfileData |= (OPJ_UINT32)getc(IN) << 16;\n        header->biIccProfileData |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biIccProfileSize  = (OPJ_UINT32)getc(IN);\n        header->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 8;\n        header->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 16;\n        header->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 24;\n\n        header->biReserved  = (OPJ_UINT32)getc(IN);\n        header->biReserved |= (OPJ_UINT32)getc(IN) << 8;\n        header->biReserved |= (OPJ_UINT32)getc(IN) << 16;\n        header->biReserved |= (OPJ_UINT32)getc(IN) << 24;\n    }\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_raw_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride,\n                                  OPJ_UINT32 width, OPJ_UINT32 height)\n{\n    OPJ_ARG_NOT_USED(width);\n\n    if (fread(pData, sizeof(OPJ_UINT8), stride * height, IN) != (stride * height)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return OPJ_FALSE;\n    }\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,\n                                   OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n    OPJ_UINT32 x, y;\n    OPJ_UINT8 *pix;\n    const OPJ_UINT8 *beyond;\n\n    beyond = pData + stride * height;\n    pix = pData;\n\n    x = y = 0U;\n    while (y < height) {\n        int c = getc(IN);\n\n        if (c) {\n            int j;\n            OPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\n            for (j = 0; (j < c) && (x < width) &&\n                    ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                *pix = c1;\n            }\n        } else {\n            c = getc(IN);\n            if (c == 0x00) { /* EOL */\n                x = 0;\n                ++y;\n                pix = pData + y * stride + x;\n            } else if (c == 0x01) { /* EOP */\n                break;\n            } else if (c == 0x02) { /* MOVE by dxdy */\n                c = getc(IN);\n                x += (OPJ_UINT32)c;\n                c = getc(IN);\n                y += (OPJ_UINT32)c;\n                pix = pData + y * stride + x;\n            } else { /* 03 .. 255 */\n                int j;\n                for (j = 0; (j < c) && (x < width) &&\n                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                    OPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n                    *pix = c1;\n                }\n                if ((OPJ_UINT32)c & 1U) { /* skip padding byte */\n                    getc(IN);\n                }\n            }\n        }\n    }/* while() */\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData,\n                                   OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n    OPJ_UINT32 x, y;\n    OPJ_UINT8 *pix;\n    const OPJ_UINT8 *beyond;\n\n    beyond = pData + stride * height;\n    pix = pData;\n    x = y = 0U;\n    while (y < height) {\n        int c = getc(IN);\n        if (c == EOF) {\n            break;\n        }\n\n        if (c) { /* encoded mode */\n            int j;\n            OPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\n            for (j = 0; (j < c) && (x < width) &&\n                    ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                *pix = (OPJ_UINT8)((j & 1) ? (c1 & 0x0fU) : ((c1 >> 4) & 0x0fU));\n            }\n        } else { /* absolute mode */\n            c = getc(IN);\n            if (c == EOF) {\n                break;\n            }\n\n            if (c == 0x00) { /* EOL */\n                x = 0;\n                y++;\n                pix = pData + y * stride;\n            } else if (c == 0x01) { /* EOP */\n                break;\n            } else if (c == 0x02) { /* MOVE by dxdy */\n                c = getc(IN);\n                x += (OPJ_UINT32)c;\n                c = getc(IN);\n                y += (OPJ_UINT32)c;\n                pix = pData + y * stride + x;\n            } else { /* 03 .. 255 : absolute mode */\n                int j;\n                OPJ_UINT8 c1 = 0U;\n\n                for (j = 0; (j < c) && (x < width) &&\n                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                    if ((j & 1) == 0) {\n                        c1 = (OPJ_UINT8)getc(IN);\n                    }\n                    *pix = (OPJ_UINT8)((j & 1) ? (c1 & 0x0fU) : ((c1 >> 4) & 0x0fU));\n                }\n                if (((c & 3) == 1) || ((c & 3) == 2)) { /* skip padding byte */\n                    getc(IN);\n                }\n            }\n        }\n    }  /* while(y < height) */\n    return OPJ_TRUE;\n}\n\nopj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters)\n{\n    opj_image_cmptparm_t cmptparm[4];   /* maximum of 4 components */\n    OPJ_UINT8 lut_R[256], lut_G[256], lut_B[256];\n    OPJ_UINT8 const* pLUT[3];\n    opj_image_t * image = NULL;\n    FILE *IN;\n    OPJ_BITMAPFILEHEADER File_h;\n    OPJ_BITMAPINFOHEADER Info_h;\n    OPJ_UINT32 i, palette_len, numcmpts = 1U;\n    OPJ_BOOL l_result = OPJ_FALSE;\n    OPJ_UINT8* pData = NULL;\n    OPJ_UINT32 stride;\n\n    pLUT[0] = lut_R;\n    pLUT[1] = lut_G;\n    pLUT[2] = lut_B;\n\n    IN = fopen(filename, \"rb\");\n    if (!IN) {\n        fprintf(stderr, \"Failed to open %s for reading !!\\n\", filename);\n        return NULL;\n    }\n\n    if (!bmp_read_file_header(IN, &File_h)) {\n        fclose(IN);\n        return NULL;\n    }\n    if (!bmp_read_info_header(IN, &Info_h)) {\n        fclose(IN);\n        return NULL;\n    }\n\n    /* Load palette */\n    if (Info_h.biBitCount <= 8U) {\n        memset(&lut_R[0], 0, sizeof(lut_R));\n        memset(&lut_G[0], 0, sizeof(lut_G));\n        memset(&lut_B[0], 0, sizeof(lut_B));\n\n        palette_len = Info_h.biClrUsed;\n        if ((palette_len == 0U) && (Info_h.biBitCount <= 8U)) {\n            palette_len = (1U << Info_h.biBitCount);\n        }\n        if (palette_len > 256U) {\n            palette_len = 256U;\n        }\n        if (palette_len > 0U) {\n            OPJ_UINT8 has_color = 0U;\n            for (i = 0U; i < palette_len; i++) {\n                lut_B[i] = (OPJ_UINT8)getc(IN);\n                lut_G[i] = (OPJ_UINT8)getc(IN);\n                lut_R[i] = (OPJ_UINT8)getc(IN);\n                (void)getc(IN); /* padding */\n                has_color |= (lut_B[i] ^ lut_G[i]) | (lut_G[i] ^ lut_R[i]);\n            }\n            if (has_color) {\n                numcmpts = 3U;\n            }\n        }\n    } else {\n        numcmpts = 3U;\n        if ((Info_h.biCompression == 3) && (Info_h.biAlphaMask != 0U)) {\n            numcmpts++;\n        }\n    }\n\n    if (Info_h.biWidth == 0 || Info_h.biHeight == 0) {\n        fclose(IN);\n        return NULL;\n    }\n\n    if (Info_h.biBitCount > (((OPJ_UINT32) - 1) - 31) / Info_h.biWidth) {\n        fclose(IN);\n        return NULL;\n    }\n    stride = ((Info_h.biWidth * Info_h.biBitCount + 31U) / 32U) *\n             4U; /* rows are aligned on 32bits */\n    if (Info_h.biBitCount == 4 &&\n            Info_h.biCompression == 2) { /* RLE 4 gets decoded as 8 bits data for now... */\n        if (8 > (((OPJ_UINT32) - 1) - 31) / Info_h.biWidth) {\n            fclose(IN);\n            return NULL;\n        }\n        stride = ((Info_h.biWidth * 8U + 31U) / 32U) * 4U;\n    }\n\n    if (stride > ((OPJ_UINT32) - 1) / sizeof(OPJ_UINT8) / Info_h.biHeight) {\n        fclose(IN);\n        return NULL;\n    }\n    pData = (OPJ_UINT8 *) calloc(1, stride * Info_h.biHeight * sizeof(OPJ_UINT8));\n    if (pData == NULL) {\n        fclose(IN);\n        return NULL;\n    }\n    /* Place the cursor at the beginning of the image information */\n    fseek(IN, 0, SEEK_SET);\n    fseek(IN, (long)File_h.bfOffBits, SEEK_SET);\n\n    switch (Info_h.biCompression) {\n    case 0:\n    case 3:\n        /* read raw data */\n        l_result = bmp_read_raw_data(IN, pData, stride, Info_h.biWidth,\n                                     Info_h.biHeight);\n        break;\n    case 1:\n        /* read rle8 data */\n        l_result = bmp_read_rle8_data(IN, pData, stride, Info_h.biWidth,\n                                      Info_h.biHeight);\n        break;\n    case 2:\n        /* read rle4 data */\n        l_result = bmp_read_rle4_data(IN, pData, stride, Info_h.biWidth,\n                                      Info_h.biHeight);\n        break;\n    default:\n        fprintf(stderr, \"Unsupported BMP compression\\n\");\n        l_result = OPJ_FALSE;\n        break;\n    }\n    if (!l_result) {\n        free(pData);\n        fclose(IN);\n        return NULL;\n    }\n\n    /* create the image */\n    memset(&cmptparm[0], 0, sizeof(cmptparm));\n    for (i = 0; i < 4U; i++) {\n        cmptparm[i].prec = 8;\n        cmptparm[i].bpp  = 8;\n        cmptparm[i].sgnd = 0;\n        cmptparm[i].dx   = (OPJ_UINT32)parameters->subsampling_dx;\n        cmptparm[i].dy   = (OPJ_UINT32)parameters->subsampling_dy;\n        cmptparm[i].w    = Info_h.biWidth;\n        cmptparm[i].h    = Info_h.biHeight;\n    }\n\n    image = opj_image_create(numcmpts, &cmptparm[0],\n                             (numcmpts == 1U) ? OPJ_CLRSPC_GRAY : OPJ_CLRSPC_SRGB);\n    if (!image) {\n        fclose(IN);\n        free(pData);\n        return NULL;\n    }\n    if (numcmpts == 4U) {\n        image->comps[3].alpha = 1;\n    }\n\n    /* set image offset and reference grid */\n    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    image->x1 = image->x0 + (Info_h.biWidth  - 1U) * (OPJ_UINT32)\n                parameters->subsampling_dx + 1U;\n    image->y1 = image->y0 + (Info_h.biHeight - 1U) * (OPJ_UINT32)\n                parameters->subsampling_dy + 1U;\n\n    /* Read the data */\n    if (Info_h.biBitCount == 24 && Info_h.biCompression == 0) { /*RGB */\n        bmp24toimage(pData, stride, image);\n    } else if (Info_h.biBitCount == 8 &&\n               Info_h.biCompression == 0) { /* RGB 8bpp Indexed */\n        bmp8toimage(pData, stride, image, pLUT);\n    } else if (Info_h.biBitCount == 8 && Info_h.biCompression == 1) { /*RLE8*/\n        bmp8toimage(pData, stride, image, pLUT);\n    } else if (Info_h.biBitCount == 4 && Info_h.biCompression == 2) { /*RLE4*/\n        bmp8toimage(pData, stride, image,\n                    pLUT); /* RLE 4 gets decoded as 8 bits data for now */\n    } else if (Info_h.biBitCount == 32 && Info_h.biCompression == 0) { /* RGBX */\n        bmpmask32toimage(pData, stride, image, 0x00FF0000U, 0x0000FF00U, 0x000000FFU,\n                         0x00000000U);\n    } else if (Info_h.biBitCount == 32 && Info_h.biCompression == 3) { /* bitmask */\n        bmpmask32toimage(pData, stride, image, Info_h.biRedMask, Info_h.biGreenMask,\n                         Info_h.biBlueMask, Info_h.biAlphaMask);\n    } else if (Info_h.biBitCount == 16 && Info_h.biCompression == 0) { /* RGBX */\n        bmpmask16toimage(pData, stride, image, 0x7C00U, 0x03E0U, 0x001FU, 0x0000U);\n    } else if (Info_h.biBitCount == 16 && Info_h.biCompression == 3) { /* bitmask */\n        if ((Info_h.biRedMask == 0U) && (Info_h.biGreenMask == 0U) &&\n                (Info_h.biBlueMask == 0U)) {\n            Info_h.biRedMask   = 0xF800U;\n            Info_h.biGreenMask = 0x07E0U;\n            Info_h.biBlueMask  = 0x001FU;\n        }\n        bmpmask16toimage(pData, stride, image, Info_h.biRedMask, Info_h.biGreenMask,\n                         Info_h.biBlueMask, Info_h.biAlphaMask);\n    } else {\n        opj_image_destroy(image);\n        image = NULL;\n        fprintf(stderr,\n                \"Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\\n\",\n                Info_h.biBitCount);\n    }\n    free(pData);\n    fclose(IN);\n    return image;\n}\n\nint imagetobmp(opj_image_t * image, const char *outfile)\n{\n    int w, h;\n    int i, pad;\n    FILE *fdest = NULL;\n    int adjustR, adjustG, adjustB;\n\n    if (image->comps[0].prec < 8) {\n        fprintf(stderr, \"imagetobmp: Unsupported precision: %d\\n\",\n                image->comps[0].prec);\n        return 1;\n    }\n    if (image->numcomps >= 3 && image->comps[0].dx == image->comps[1].dx\n            && image->comps[1].dx == image->comps[2].dx\n            && image->comps[0].dy == image->comps[1].dy\n            && image->comps[1].dy == image->comps[2].dy\n            && image->comps[0].prec == image->comps[1].prec\n            && image->comps[1].prec == image->comps[2].prec\n            && image->comps[0].sgnd == image->comps[1].sgnd\n            && image->comps[1].sgnd == image->comps[2].sgnd) {\n\n        /* -->> -->> -->> -->>\n        24 bits color\n        <<-- <<-- <<-- <<-- */\n\n        fdest = fopen(outfile, \"wb\");\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return 1;\n        }\n\n        w = (int)image->comps[0].w;\n        h = (int)image->comps[0].h;\n\n        fprintf(fdest, \"BM\");\n\n        /* FILE HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\",\n                (OPJ_UINT8)(h * w * 3 + 3 * h * (w % 2) + 54) & 0xff,\n                (OPJ_UINT8)((h * w * 3 + 3 * h * (w % 2) + 54) >> 8) & 0xff,\n                (OPJ_UINT8)((h * w * 3 + 3 * h * (w % 2) + 54) >> 16) & 0xff,\n                (OPJ_UINT8)((h * w * 3 + 3 * h * (w % 2) + 54) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff,\n                ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (54) & 0xff, ((54) >> 8) & 0xff, ((54) >> 16) & 0xff,\n                ((54) >> 24) & 0xff);\n\n        /* INFO HEADER   */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (40) & 0xff, ((40) >> 8) & 0xff, ((40) >> 16) & 0xff,\n                ((40) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8)((w) & 0xff),\n                (OPJ_UINT8)((w) >> 8) & 0xff,\n                (OPJ_UINT8)((w) >> 16) & 0xff,\n                (OPJ_UINT8)((w) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8)((h) & 0xff),\n                (OPJ_UINT8)((h) >> 8) & 0xff,\n                (OPJ_UINT8)((h) >> 16) & 0xff,\n                (OPJ_UINT8)((h) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c\", (1) & 0xff, ((1) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c\", (24) & 0xff, ((24) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff,\n                ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8)(3 * h * w + 3 * h * (w % 2)) & 0xff,\n                (OPJ_UINT8)((h * w * 3 + 3 * h * (w % 2)) >> 8) & 0xff,\n                (OPJ_UINT8)((h * w * 3 + 3 * h * (w % 2)) >> 16) & 0xff,\n                (OPJ_UINT8)((h * w * 3 + 3 * h * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\n                ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\n                ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff,\n                ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff,\n                ((0) >> 24) & 0xff);\n\n        if (image->comps[0].prec > 8) {\n            adjustR = (int)image->comps[0].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\\n\",\n                   image->comps[0].prec);\n        } else {\n            adjustR = 0;\n        }\n        if (image->comps[1].prec > 8) {\n            adjustG = (int)image->comps[1].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\\n\",\n                   image->comps[1].prec);\n        } else {\n            adjustG = 0;\n        }\n        if (image->comps[2].prec > 8) {\n            adjustB = (int)image->comps[2].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\\n\",\n                   image->comps[2].prec);\n        } else {\n            adjustB = 0;\n        }\n\n        for (i = 0; i < w * h; i++) {\n            OPJ_UINT8 rc, gc, bc;\n            int r, g, b;\n\n            r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n            if (adjustR > 0) {\n                r = ((r >> adjustR) + ((r >> (adjustR - 1)) % 2));\n            }\n            if (r > 255) {\n                r = 255;\n            } else if (r < 0) {\n                r = 0;\n            }\n            rc = (OPJ_UINT8)r;\n\n            g = image->comps[1].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            g += (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n            if (adjustG > 0) {\n                g = ((g >> adjustG) + ((g >> (adjustG - 1)) % 2));\n            }\n            if (g > 255) {\n                g = 255;\n            } else if (g < 0) {\n                g = 0;\n            }\n            gc = (OPJ_UINT8)g;\n\n            b = image->comps[2].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            b += (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n            if (adjustB > 0) {\n                b = ((b >> adjustB) + ((b >> (adjustB - 1)) % 2));\n            }\n            if (b > 255) {\n                b = 255;\n            } else if (b < 0) {\n                b = 0;\n            }\n            bc = (OPJ_UINT8)b;\n\n            fprintf(fdest, \"%c%c%c\", bc, gc, rc);\n\n            if ((i + 1) % w == 0) {\n                for (pad = ((3 * w) % 4) ? (4 - (3 * w) % 4) : 0; pad > 0; pad--) { /* ADD */\n                    fprintf(fdest, \"%c\", 0);\n                }\n            }\n        }\n        fclose(fdest);\n    } else {            /* Gray-scale */\n\n        /* -->> -->> -->> -->>\n        8 bits non code (Gray scale)\n        <<-- <<-- <<-- <<-- */\n\n        fdest = fopen(outfile, \"wb\");\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return 1;\n        }\n        if (image->numcomps > 1) {\n            fprintf(stderr, \"imagetobmp: only first component of %d is used.\\n\",\n                    image->numcomps);\n        }\n        w = (int)image->comps[0].w;\n        h = (int)image->comps[0].h;\n\n        fprintf(fdest, \"BM\");\n\n        /* FILE HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8)(h * w + 54 + 1024 + h * (w % 2)) & 0xff,\n                (OPJ_UINT8)((h * w + 54 + 1024 + h * (w % 2)) >> 8) & 0xff,\n                (OPJ_UINT8)((h * w + 54 + 1024 + h * (w % 2)) >> 16) & 0xff,\n                (OPJ_UINT8)((h * w + 54 + 1024 + w * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff,\n                ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (54 + 1024) & 0xff, ((54 + 1024) >> 8) & 0xff,\n                ((54 + 1024) >> 16) & 0xff,\n                ((54 + 1024) >> 24) & 0xff);\n\n        /* INFO HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (40) & 0xff, ((40) >> 8) & 0xff, ((40) >> 16) & 0xff,\n                ((40) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8)((w) & 0xff),\n                (OPJ_UINT8)((w) >> 8) & 0xff,\n                (OPJ_UINT8)((w) >> 16) & 0xff,\n                (OPJ_UINT8)((w) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8)((h) & 0xff),\n                (OPJ_UINT8)((h) >> 8) & 0xff,\n                (OPJ_UINT8)((h) >> 16) & 0xff,\n                (OPJ_UINT8)((h) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c\", (1) & 0xff, ((1) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c\", (8) & 0xff, ((8) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff,\n                ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8)(h * w + h * (w % 2)) & 0xff,\n                (OPJ_UINT8)((h * w + h * (w % 2)) >> 8) &  0xff,\n                (OPJ_UINT8)((h * w + h * (w % 2)) >> 16) & 0xff,\n                (OPJ_UINT8)((h * w + h * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\n                ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\n                ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (256) & 0xff, ((256) >> 8) & 0xff,\n                ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (256) & 0xff, ((256) >> 8) & 0xff,\n                ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);\n\n        if (image->comps[0].prec > 8) {\n            adjustR = (int)image->comps[0].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\\n\",\n                   image->comps[0].prec);\n        } else {\n            adjustR = 0;\n        }\n\n        for (i = 0; i < 256; i++) {\n            fprintf(fdest, \"%c%c%c%c\", i, i, i, 0);\n        }\n\n        for (i = 0; i < w * h; i++) {\n            int r;\n\n            r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n            if (adjustR > 0) {\n                r = ((r >> adjustR) + ((r >> (adjustR - 1)) % 2));\n            }\n            if (r > 255) {\n                r = 255;\n            } else if (r < 0) {\n                r = 0;\n            }\n\n            fprintf(fdest, \"%c\", (OPJ_UINT8)r);\n\n            if ((i + 1) % w == 0) {\n                for (pad = (w % 4) ? (4 - w % 4) : 0; pad > 0; pad--) { /* ADD */\n                    fprintf(fdest, \"%c\", 0);\n                }\n            }\n        }\n        fclose(fdest);\n    }\n\n    return 0;\n}\n"], "filenames": ["src/bin/jp2/convertbmp.c"], "buggy_code_start_loc": [394], "buggy_code_end_loc": [394], "fixing_code_start_loc": [395], "fixing_code_end_loc": [399], "type": "CWE-119", "message": "The bmp_read_info_header function in bin/jp2/convertbmp.c in OpenJPEG 2.2.0 does not reject headers with a zero biBitCount, which allows remote attackers to cause a denial of service (memory allocation failure) in the opj_image_create function in lib/openjp2/image.c, related to the opj_aligned_alloc_n function in opj_malloc.c.", "other": {"cve": {"id": "CVE-2017-12982", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-21T07:29:00.373", "lastModified": "2021-02-02T19:56:30.907", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The bmp_read_info_header function in bin/jp2/convertbmp.c in OpenJPEG 2.2.0 does not reject headers with a zero biBitCount, which allows remote attackers to cause a denial of service (memory allocation failure) in the opj_image_create function in lib/openjp2/image.c, related to the opj_aligned_alloc_n function in opj_malloc.c."}, {"lang": "es", "value": "La funci\u00f3n bmp_read_info_header en bin/jp2/convertbmp.c en OpenJPEG 2.2.0 no rechaza encabezados con un biBitCount de cero. Esto permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (fallo de asignaci\u00f3n de memoria) en la funci\u00f3n opj_image_create en lib/openjp2/image.c, relacionado con la funci\u00f3n opj_aligned_alloc_n en opj_malloc.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uclouvain:openjpeg:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.3.0", "matchCriteriaId": "1E370DD2-BCCE-48F1-BB6D-58227282E967"}]}]}], "references": [{"url": "https://blogs.gentoo.org/ago/2017/08/14/openjpeg-memory-allocation-failure-in-opj_aligned_alloc_n-opj_malloc-c/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/uclouvain/openjpeg/commit/baf0c1ad4572daa89caa3b12985bdd93530f0dd7", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/uclouvain/openjpeg/issues/983", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201710-26", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/uclouvain/openjpeg/commit/baf0c1ad4572daa89caa3b12985bdd93530f0dd7"}}