{"buggy_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#include \"k5-int.h\"\n#include <kadm5/admin.h>\n#include <syslog.h>\n#include <adm_proto.h>  /* krb5_klog_syslog */\n#include <stdio.h>\n#include <errno.h>\n\n#include \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n\n#include \"misc.h\"\n\n#ifndef GETSOCKNAME_ARG3_TYPE\n#define GETSOCKNAME_ARG3_TYPE int\n#endif\n\n#define RFC3244_VERSION 0xff80\n\nstatic krb5_error_code\nprocess_chpw_request(krb5_context context, void *server_handle, char *realm,\n                     krb5_keytab keytab, const krb5_fulladdr *local_faddr,\n                     const krb5_fulladdr *remote_faddr, krb5_data *req,\n                     krb5_data *rep)\n{\n    krb5_error_code ret;\n    char *ptr;\n    unsigned int plen, vno;\n    krb5_data ap_req, ap_rep = empty_data();\n    krb5_data cipher = empty_data(), clear = empty_data();\n    krb5_auth_context auth_context = NULL;\n    krb5_principal changepw = NULL;\n    krb5_principal client, target = NULL;\n    krb5_ticket *ticket = NULL;\n    krb5_replay_data replay;\n    krb5_error krberror;\n    int numresult;\n    char strresult[1024];\n    char *clientstr = NULL, *targetstr = NULL;\n    const char *errmsg = NULL;\n    size_t clen;\n    char *cdots;\n    struct sockaddr_storage ss;\n    socklen_t salen;\n    char addrbuf[100];\n    krb5_address *addr = remote_faddr->address;\n\n    *rep = empty_data();\n\n    if (req->length < 4) {\n        /* either this, or the server is printing bad messages,\n           or the caller passed in garbage */\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n        numresult = KRB5_KPASSWD_MALFORMED;\n        strlcpy(strresult, \"Request was truncated\", sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ptr = req->data;\n\n    /* verify length */\n\n    plen = (*ptr++ & 0xff);\n    plen = (plen<<8) | (*ptr++ & 0xff);\n\n    if (plen != req->length) {\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n        numresult = KRB5_KPASSWD_MALFORMED;\n        strlcpy(strresult, \"Request length was inconsistent\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* verify version number */\n\n    vno = (*ptr++ & 0xff) ;\n    vno = (vno<<8) | (*ptr++ & 0xff);\n\n    if (vno != 1 && vno != RFC3244_VERSION) {\n        ret = KRB5KDC_ERR_BAD_PVNO;\n        numresult = KRB5_KPASSWD_BAD_VERSION;\n        snprintf(strresult, sizeof(strresult),\n                 \"Request contained unknown protocol version number %d\", vno);\n        goto chpwfail;\n    }\n\n    /* read, check ap-req length */\n\n    ap_req.length = (*ptr++ & 0xff);\n    ap_req.length = (ap_req.length<<8) | (*ptr++ & 0xff);\n\n    if (ptr + ap_req.length >= req->data + req->length) {\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n        numresult = KRB5_KPASSWD_MALFORMED;\n        strlcpy(strresult, \"Request was truncated in AP-REQ\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* verify ap_req */\n\n    ap_req.data = ptr;\n    ptr += ap_req.length;\n\n    ret = krb5_auth_con_init(context, &auth_context);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed initializing auth context\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_auth_con_setflags(context, auth_context,\n                                 KRB5_AUTH_CONTEXT_DO_SEQUENCE);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed initializing auth context\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_build_principal(context, &changepw, strlen(realm), realm,\n                               \"kadmin\", \"changepw\", NULL);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed building kadmin/changepw principal\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_rd_req(context, &auth_context, &ap_req, changepw, keytab,\n                      NULL, &ticket);\n\n    if (ret) {\n        numresult = KRB5_KPASSWD_AUTHERROR;\n        strlcpy(strresult, \"Failed reading application request\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* construct the ap-rep */\n\n    ret = krb5_mk_rep(context, auth_context, &ap_rep);\n    if (ret) {\n        numresult = KRB5_KPASSWD_AUTHERROR;\n        strlcpy(strresult, \"Failed replying to application request\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* decrypt the ChangePasswdData */\n\n    cipher.length = (req->data + req->length) - ptr;\n    cipher.data = ptr;\n\n    /*\n     * Don't set a remote address in auth_context before calling krb5_rd_priv,\n     * so that we can work against clients behind a NAT.  Reflection attacks\n     * aren't a concern since we use sequence numbers and since our requests\n     * don't look anything like our responses.  Also don't set a local address,\n     * since we don't know what interface the request was received on.\n     */\n\n    ret = krb5_rd_priv(context, auth_context, &cipher, &clear, &replay);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed decrypting request\", sizeof(strresult));\n        goto chpwfail;\n    }\n\n    client = ticket->enc_part2->client;\n\n    /* decode ChangePasswdData for setpw requests */\n    if (vno == RFC3244_VERSION) {\n        krb5_data *clear_data;\n\n        ret = decode_krb5_setpw_req(&clear, &clear_data, &target);\n        if (ret != 0) {\n            numresult = KRB5_KPASSWD_MALFORMED;\n            strlcpy(strresult, \"Failed decoding ChangePasswdData\",\n                    sizeof(strresult));\n            goto chpwfail;\n        }\n\n        zapfree(clear.data, clear.length);\n\n        clear = *clear_data;\n        free(clear_data);\n\n        if (target != NULL) {\n            ret = krb5_unparse_name(context, target, &targetstr);\n            if (ret != 0) {\n                numresult = KRB5_KPASSWD_HARDERROR;\n                strlcpy(strresult, \"Failed unparsing target name for log\",\n                        sizeof(strresult));\n                goto chpwfail;\n            }\n        }\n    }\n\n    ret = krb5_unparse_name(context, client, &clientstr);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed unparsing client name for log\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* for cpw, verify that this is an AS_REQ ticket */\n    if (vno == 1 &&\n        (ticket->enc_part2->flags & TKT_FLG_INITIAL) == 0) {\n        numresult = KRB5_KPASSWD_INITIAL_FLAG_NEEDED;\n        strlcpy(strresult, \"Ticket must be derived from a password\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* change the password */\n\n    ptr = k5memdup0(clear.data, clear.length, &ret);\n    ret = schpw_util_wrapper(server_handle, client, target,\n                             (ticket->enc_part2->flags & TKT_FLG_INITIAL) != 0,\n                             ptr, NULL, strresult, sizeof(strresult));\n    if (ret)\n        errmsg = krb5_get_error_message(context, ret);\n\n    /* zap the password */\n    zapfree(clear.data, clear.length);\n    zapfree(ptr, clear.length);\n    clear = empty_data();\n\n    clen = strlen(clientstr);\n    trunc_name(&clen, &cdots);\n\n    switch (addr->addrtype) {\n    case ADDRTYPE_INET: {\n        struct sockaddr_in *sin = ss2sin(&ss);\n\n        sin->sin_family = AF_INET;\n        memcpy(&sin->sin_addr, addr->contents, addr->length);\n        sin->sin_port = htons(remote_faddr->port);\n        salen = sizeof(*sin);\n        break;\n    }\n    case ADDRTYPE_INET6: {\n        struct sockaddr_in6 *sin6 = ss2sin6(&ss);\n\n        sin6->sin6_family = AF_INET6;\n        memcpy(&sin6->sin6_addr, addr->contents, addr->length);\n        sin6->sin6_port = htons(remote_faddr->port);\n        salen = sizeof(*sin6);\n        break;\n    }\n    default: {\n        struct sockaddr *sa = ss2sa(&ss);\n\n        sa->sa_family = AF_UNSPEC;\n        salen = sizeof(*sa);\n        break;\n    }\n    }\n\n    if (getnameinfo(ss2sa(&ss), salen,\n                    addrbuf, sizeof(addrbuf), NULL, 0,\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0)\n        strlcpy(addrbuf, \"<unprintable>\", sizeof(addrbuf));\n\n    if (vno == RFC3244_VERSION) {\n        size_t tlen;\n        char *tdots;\n        const char *targetp;\n\n        if (target == NULL) {\n            tlen = clen;\n            tdots = cdots;\n            targetp = targetstr;\n        } else {\n            tlen = strlen(targetstr);\n            trunc_name(&tlen, &tdots);\n            targetp = clientstr;\n        }\n\n        krb5_klog_syslog(LOG_NOTICE, _(\"setpw request from %s by %.*s%s for \"\n                                       \"%.*s%s: %s\"), addrbuf, (int) clen,\n                         clientstr, cdots, (int) tlen, targetp, tdots,\n                         errmsg ? errmsg : \"success\");\n    } else {\n        krb5_klog_syslog(LOG_NOTICE, _(\"chpw request from %s for %.*s%s: %s\"),\n                         addrbuf, (int) clen, clientstr, cdots,\n                         errmsg ? errmsg : \"success\");\n    }\n    switch (ret) {\n    case KADM5_AUTH_CHANGEPW:\n        numresult = KRB5_KPASSWD_ACCESSDENIED;\n        break;\n    case KADM5_PASS_Q_TOOSHORT:\n    case KADM5_PASS_REUSE:\n    case KADM5_PASS_Q_CLASS:\n    case KADM5_PASS_Q_DICT:\n    case KADM5_PASS_Q_GENERIC:\n    case KADM5_PASS_TOOSOON:\n        numresult = KRB5_KPASSWD_SOFTERROR;\n        break;\n    case 0:\n        numresult = KRB5_KPASSWD_SUCCESS;\n        strlcpy(strresult, \"\", sizeof(strresult));\n        break;\n    default:\n        numresult = KRB5_KPASSWD_HARDERROR;\n        break;\n    }\n\nchpwfail:\n\n    clear.length = 2 + strlen(strresult);\n    clear.data = (char *) malloc(clear.length);\n\n    ptr = clear.data;\n\n    *ptr++ = (numresult>>8) & 0xff;\n    *ptr++ = numresult & 0xff;\n\n    memcpy(ptr, strresult, strlen(strresult));\n\n    cipher = empty_data();\n\n    if (ap_rep.length) {\n        ret = krb5_auth_con_setaddrs(context, auth_context,\n                                     local_faddr->address, NULL);\n        if (ret) {\n            numresult = KRB5_KPASSWD_HARDERROR;\n            strlcpy(strresult,\n                    \"Failed storing client and server internet addresses\",\n                    sizeof(strresult));\n        } else {\n            ret = krb5_mk_priv(context, auth_context, &clear, &cipher,\n                               &replay);\n            if (ret) {\n                numresult = KRB5_KPASSWD_HARDERROR;\n                strlcpy(strresult, \"Failed encrypting reply\",\n                        sizeof(strresult));\n            }\n        }\n    }\n\n    /* if no KRB-PRIV was constructed, then we need a KRB-ERROR.\n       if this fails, just bail.  there's nothing else we can do. */\n\n    if (cipher.length == 0) {\n        /* clear out ap_rep now, so that it won't be inserted in the\n           reply */\n\n        if (ap_rep.length) {\n            free(ap_rep.data);\n            ap_rep = empty_data();\n        }\n\n        krberror.ctime = 0;\n        krberror.cusec = 0;\n        krberror.susec = 0;\n        ret = krb5_timeofday(context, &krberror.stime);\n        if (ret)\n            goto bailout;\n\n        /* this is really icky.  but it's what all the other callers\n           to mk_error do. */\n        krberror.error = ret;\n        krberror.error -= ERROR_TABLE_BASE_krb5;\n        if (krberror.error < 0 || krberror.error > 128)\n            krberror.error = KRB_ERR_GENERIC;\n\n        krberror.client = NULL;\n\n        ret = krb5_build_principal(context, &krberror.server,\n                                   strlen(realm), realm,\n                                   \"kadmin\", \"changepw\", NULL);\n        if (ret)\n            goto bailout;\n        krberror.text.length = 0;\n        krberror.e_data = clear;\n\n        ret = krb5_mk_error(context, &krberror, &cipher);\n\n        krb5_free_principal(context, krberror.server);\n\n        if (ret)\n            goto bailout;\n    }\n\n    /* construct the reply */\n\n    ret = alloc_data(rep, 6 + ap_rep.length + cipher.length);\n    if (ret)\n        goto bailout;\n    ptr = rep->data;\n\n    /* length */\n\n    *ptr++ = (rep->length>>8) & 0xff;\n    *ptr++ = rep->length & 0xff;\n\n    /* version == 0x0001 big-endian */\n\n    *ptr++ = 0;\n    *ptr++ = 1;\n\n    /* ap_rep length, big-endian */\n\n    *ptr++ = (ap_rep.length>>8) & 0xff;\n    *ptr++ = ap_rep.length & 0xff;\n\n    /* ap-rep data */\n\n    if (ap_rep.length) {\n        memcpy(ptr, ap_rep.data, ap_rep.length);\n        ptr += ap_rep.length;\n    }\n\n    /* krb-priv or krb-error */\n\n    memcpy(ptr, cipher.data, cipher.length);\n\nbailout:\n    krb5_auth_con_free(context, auth_context);\n    krb5_free_principal(context, changepw);\n    krb5_free_ticket(context, ticket);\n    free(ap_rep.data);\n    free(clear.data);\n    free(cipher.data);\n    krb5_free_principal(context, target);\n    krb5_free_unparsed_name(context, targetstr);\n    krb5_free_unparsed_name(context, clientstr);\n    krb5_free_error_message(context, errmsg);\n    return ret;\n}\n\n/* Dispatch routine for set/change password */\nvoid\ndispatch(void *handle, struct sockaddr *local_saddr,\n         const krb5_fulladdr *remote_faddr, krb5_data *request, int is_tcp,\n         verto_ctx *vctx, loop_respond_fn respond, void *arg)\n{\n    krb5_error_code ret;\n    krb5_keytab kt = NULL;\n    kadm5_server_handle_t server_handle = (kadm5_server_handle_t)handle;\n    krb5_fulladdr local_faddr;\n    krb5_address **local_kaddrs = NULL, local_kaddr_buf;\n    krb5_data *response = NULL;\n\n    if (local_saddr == NULL) {\n        ret = krb5_os_localaddr(server_handle->context, &local_kaddrs);\n        if (ret != 0)\n            goto egress;\n\n        local_faddr.address = local_kaddrs[0];\n        local_faddr.port = 0;\n    } else {\n        local_faddr.address = &local_kaddr_buf;\n        init_addr(&local_faddr, local_saddr);\n    }\n\n    ret = krb5_kt_resolve(server_handle->context, \"KDB:\", &kt);\n    if (ret != 0) {\n        krb5_klog_syslog(LOG_ERR, _(\"chpw: Couldn't open admin keytab %s\"),\n                         krb5_get_error_message(server_handle->context, ret));\n        goto egress;\n    }\n\n    response = k5alloc(sizeof(krb5_data), &ret);\n    if (response == NULL)\n        goto egress;\n\n    ret = process_chpw_request(server_handle->context,\n                               handle,\n                               server_handle->params.realm,\n                               kt,\n                               &local_faddr,\n                               remote_faddr,\n                               request,\n                               response);\negress:\n    if (ret)\n        krb5_free_data(server_handle->context, response);\n    krb5_free_addresses(server_handle->context, local_kaddrs);\n    krb5_kt_close(server_handle->context, kt);\n    (*respond)(arg, ret, ret == 0 ? response : NULL);\n}\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#include \"k5-int.h\"\n#include <kadm5/admin.h>\n#include <syslog.h>\n#include <adm_proto.h>  /* krb5_klog_syslog */\n#include <stdio.h>\n#include <errno.h>\n\n#include \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n\n#include \"misc.h\"\n\n#ifndef GETSOCKNAME_ARG3_TYPE\n#define GETSOCKNAME_ARG3_TYPE int\n#endif\n\n#define RFC3244_VERSION 0xff80\n\nstatic krb5_error_code\nprocess_chpw_request(krb5_context context, void *server_handle, char *realm,\n                     krb5_keytab keytab, const krb5_fulladdr *local_faddr,\n                     const krb5_fulladdr *remote_faddr, krb5_data *req,\n                     krb5_data *rep)\n{\n    krb5_error_code ret;\n    char *ptr;\n    unsigned int plen, vno;\n    krb5_data ap_req, ap_rep = empty_data();\n    krb5_data cipher = empty_data(), clear = empty_data();\n    krb5_auth_context auth_context = NULL;\n    krb5_principal changepw = NULL;\n    krb5_principal client, target = NULL;\n    krb5_ticket *ticket = NULL;\n    krb5_replay_data replay;\n    krb5_error krberror;\n    int numresult;\n    char strresult[1024];\n    char *clientstr = NULL, *targetstr = NULL;\n    const char *errmsg = NULL;\n    size_t clen;\n    char *cdots;\n    struct sockaddr_storage ss;\n    socklen_t salen;\n    char addrbuf[100];\n    krb5_address *addr = remote_faddr->address;\n\n    *rep = empty_data();\n\n    if (req->length < 4) {\n        /* either this, or the server is printing bad messages,\n           or the caller passed in garbage */\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n        numresult = KRB5_KPASSWD_MALFORMED;\n        strlcpy(strresult, \"Request was truncated\", sizeof(strresult));\n        goto bailout;\n    }\n\n    ptr = req->data;\n\n    /* verify length */\n\n    plen = (*ptr++ & 0xff);\n    plen = (plen<<8) | (*ptr++ & 0xff);\n\n    if (plen != req->length) {\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n        numresult = KRB5_KPASSWD_MALFORMED;\n        strlcpy(strresult, \"Request length was inconsistent\",\n                sizeof(strresult));\n        goto bailout;\n    }\n\n    /* verify version number */\n\n    vno = (*ptr++ & 0xff) ;\n    vno = (vno<<8) | (*ptr++ & 0xff);\n\n    if (vno != 1 && vno != RFC3244_VERSION) {\n        ret = KRB5KDC_ERR_BAD_PVNO;\n        numresult = KRB5_KPASSWD_BAD_VERSION;\n        snprintf(strresult, sizeof(strresult),\n                 \"Request contained unknown protocol version number %d\", vno);\n        goto bailout;\n    }\n\n    /* read, check ap-req length */\n\n    ap_req.length = (*ptr++ & 0xff);\n    ap_req.length = (ap_req.length<<8) | (*ptr++ & 0xff);\n\n    if (ptr + ap_req.length >= req->data + req->length) {\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n        numresult = KRB5_KPASSWD_MALFORMED;\n        strlcpy(strresult, \"Request was truncated in AP-REQ\",\n                sizeof(strresult));\n        goto bailout;\n    }\n\n    /* verify ap_req */\n\n    ap_req.data = ptr;\n    ptr += ap_req.length;\n\n    ret = krb5_auth_con_init(context, &auth_context);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed initializing auth context\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_auth_con_setflags(context, auth_context,\n                                 KRB5_AUTH_CONTEXT_DO_SEQUENCE);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed initializing auth context\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_build_principal(context, &changepw, strlen(realm), realm,\n                               \"kadmin\", \"changepw\", NULL);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed building kadmin/changepw principal\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_rd_req(context, &auth_context, &ap_req, changepw, keytab,\n                      NULL, &ticket);\n\n    if (ret) {\n        numresult = KRB5_KPASSWD_AUTHERROR;\n        strlcpy(strresult, \"Failed reading application request\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* construct the ap-rep */\n\n    ret = krb5_mk_rep(context, auth_context, &ap_rep);\n    if (ret) {\n        numresult = KRB5_KPASSWD_AUTHERROR;\n        strlcpy(strresult, \"Failed replying to application request\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* decrypt the ChangePasswdData */\n\n    cipher.length = (req->data + req->length) - ptr;\n    cipher.data = ptr;\n\n    /*\n     * Don't set a remote address in auth_context before calling krb5_rd_priv,\n     * so that we can work against clients behind a NAT.  Reflection attacks\n     * aren't a concern since we use sequence numbers and since our requests\n     * don't look anything like our responses.  Also don't set a local address,\n     * since we don't know what interface the request was received on.\n     */\n\n    ret = krb5_rd_priv(context, auth_context, &cipher, &clear, &replay);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed decrypting request\", sizeof(strresult));\n        goto chpwfail;\n    }\n\n    client = ticket->enc_part2->client;\n\n    /* decode ChangePasswdData for setpw requests */\n    if (vno == RFC3244_VERSION) {\n        krb5_data *clear_data;\n\n        ret = decode_krb5_setpw_req(&clear, &clear_data, &target);\n        if (ret != 0) {\n            numresult = KRB5_KPASSWD_MALFORMED;\n            strlcpy(strresult, \"Failed decoding ChangePasswdData\",\n                    sizeof(strresult));\n            goto chpwfail;\n        }\n\n        zapfree(clear.data, clear.length);\n\n        clear = *clear_data;\n        free(clear_data);\n\n        if (target != NULL) {\n            ret = krb5_unparse_name(context, target, &targetstr);\n            if (ret != 0) {\n                numresult = KRB5_KPASSWD_HARDERROR;\n                strlcpy(strresult, \"Failed unparsing target name for log\",\n                        sizeof(strresult));\n                goto chpwfail;\n            }\n        }\n    }\n\n    ret = krb5_unparse_name(context, client, &clientstr);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed unparsing client name for log\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* for cpw, verify that this is an AS_REQ ticket */\n    if (vno == 1 &&\n        (ticket->enc_part2->flags & TKT_FLG_INITIAL) == 0) {\n        numresult = KRB5_KPASSWD_INITIAL_FLAG_NEEDED;\n        strlcpy(strresult, \"Ticket must be derived from a password\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* change the password */\n\n    ptr = k5memdup0(clear.data, clear.length, &ret);\n    ret = schpw_util_wrapper(server_handle, client, target,\n                             (ticket->enc_part2->flags & TKT_FLG_INITIAL) != 0,\n                             ptr, NULL, strresult, sizeof(strresult));\n    if (ret)\n        errmsg = krb5_get_error_message(context, ret);\n\n    /* zap the password */\n    zapfree(clear.data, clear.length);\n    zapfree(ptr, clear.length);\n    clear = empty_data();\n\n    clen = strlen(clientstr);\n    trunc_name(&clen, &cdots);\n\n    switch (addr->addrtype) {\n    case ADDRTYPE_INET: {\n        struct sockaddr_in *sin = ss2sin(&ss);\n\n        sin->sin_family = AF_INET;\n        memcpy(&sin->sin_addr, addr->contents, addr->length);\n        sin->sin_port = htons(remote_faddr->port);\n        salen = sizeof(*sin);\n        break;\n    }\n    case ADDRTYPE_INET6: {\n        struct sockaddr_in6 *sin6 = ss2sin6(&ss);\n\n        sin6->sin6_family = AF_INET6;\n        memcpy(&sin6->sin6_addr, addr->contents, addr->length);\n        sin6->sin6_port = htons(remote_faddr->port);\n        salen = sizeof(*sin6);\n        break;\n    }\n    default: {\n        struct sockaddr *sa = ss2sa(&ss);\n\n        sa->sa_family = AF_UNSPEC;\n        salen = sizeof(*sa);\n        break;\n    }\n    }\n\n    if (getnameinfo(ss2sa(&ss), salen,\n                    addrbuf, sizeof(addrbuf), NULL, 0,\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0)\n        strlcpy(addrbuf, \"<unprintable>\", sizeof(addrbuf));\n\n    if (vno == RFC3244_VERSION) {\n        size_t tlen;\n        char *tdots;\n        const char *targetp;\n\n        if (target == NULL) {\n            tlen = clen;\n            tdots = cdots;\n            targetp = targetstr;\n        } else {\n            tlen = strlen(targetstr);\n            trunc_name(&tlen, &tdots);\n            targetp = clientstr;\n        }\n\n        krb5_klog_syslog(LOG_NOTICE, _(\"setpw request from %s by %.*s%s for \"\n                                       \"%.*s%s: %s\"), addrbuf, (int) clen,\n                         clientstr, cdots, (int) tlen, targetp, tdots,\n                         errmsg ? errmsg : \"success\");\n    } else {\n        krb5_klog_syslog(LOG_NOTICE, _(\"chpw request from %s for %.*s%s: %s\"),\n                         addrbuf, (int) clen, clientstr, cdots,\n                         errmsg ? errmsg : \"success\");\n    }\n    switch (ret) {\n    case KADM5_AUTH_CHANGEPW:\n        numresult = KRB5_KPASSWD_ACCESSDENIED;\n        break;\n    case KADM5_PASS_Q_TOOSHORT:\n    case KADM5_PASS_REUSE:\n    case KADM5_PASS_Q_CLASS:\n    case KADM5_PASS_Q_DICT:\n    case KADM5_PASS_Q_GENERIC:\n    case KADM5_PASS_TOOSOON:\n        numresult = KRB5_KPASSWD_SOFTERROR;\n        break;\n    case 0:\n        numresult = KRB5_KPASSWD_SUCCESS;\n        strlcpy(strresult, \"\", sizeof(strresult));\n        break;\n    default:\n        numresult = KRB5_KPASSWD_HARDERROR;\n        break;\n    }\n\nchpwfail:\n\n    clear.length = 2 + strlen(strresult);\n    clear.data = (char *) malloc(clear.length);\n\n    ptr = clear.data;\n\n    *ptr++ = (numresult>>8) & 0xff;\n    *ptr++ = numresult & 0xff;\n\n    memcpy(ptr, strresult, strlen(strresult));\n\n    cipher = empty_data();\n\n    if (ap_rep.length) {\n        ret = krb5_auth_con_setaddrs(context, auth_context,\n                                     local_faddr->address, NULL);\n        if (ret) {\n            numresult = KRB5_KPASSWD_HARDERROR;\n            strlcpy(strresult,\n                    \"Failed storing client and server internet addresses\",\n                    sizeof(strresult));\n        } else {\n            ret = krb5_mk_priv(context, auth_context, &clear, &cipher,\n                               &replay);\n            if (ret) {\n                numresult = KRB5_KPASSWD_HARDERROR;\n                strlcpy(strresult, \"Failed encrypting reply\",\n                        sizeof(strresult));\n            }\n        }\n    }\n\n    /* if no KRB-PRIV was constructed, then we need a KRB-ERROR.\n       if this fails, just bail.  there's nothing else we can do. */\n\n    if (cipher.length == 0) {\n        /* clear out ap_rep now, so that it won't be inserted in the\n           reply */\n\n        if (ap_rep.length) {\n            free(ap_rep.data);\n            ap_rep = empty_data();\n        }\n\n        krberror.ctime = 0;\n        krberror.cusec = 0;\n        krberror.susec = 0;\n        ret = krb5_timeofday(context, &krberror.stime);\n        if (ret)\n            goto bailout;\n\n        /* this is really icky.  but it's what all the other callers\n           to mk_error do. */\n        krberror.error = ret;\n        krberror.error -= ERROR_TABLE_BASE_krb5;\n        if (krberror.error < 0 || krberror.error > 128)\n            krberror.error = KRB_ERR_GENERIC;\n\n        krberror.client = NULL;\n\n        ret = krb5_build_principal(context, &krberror.server,\n                                   strlen(realm), realm,\n                                   \"kadmin\", \"changepw\", NULL);\n        if (ret)\n            goto bailout;\n        krberror.text.length = 0;\n        krberror.e_data = clear;\n\n        ret = krb5_mk_error(context, &krberror, &cipher);\n\n        krb5_free_principal(context, krberror.server);\n\n        if (ret)\n            goto bailout;\n    }\n\n    /* construct the reply */\n\n    ret = alloc_data(rep, 6 + ap_rep.length + cipher.length);\n    if (ret)\n        goto bailout;\n    ptr = rep->data;\n\n    /* length */\n\n    *ptr++ = (rep->length>>8) & 0xff;\n    *ptr++ = rep->length & 0xff;\n\n    /* version == 0x0001 big-endian */\n\n    *ptr++ = 0;\n    *ptr++ = 1;\n\n    /* ap_rep length, big-endian */\n\n    *ptr++ = (ap_rep.length>>8) & 0xff;\n    *ptr++ = ap_rep.length & 0xff;\n\n    /* ap-rep data */\n\n    if (ap_rep.length) {\n        memcpy(ptr, ap_rep.data, ap_rep.length);\n        ptr += ap_rep.length;\n    }\n\n    /* krb-priv or krb-error */\n\n    memcpy(ptr, cipher.data, cipher.length);\n\nbailout:\n    krb5_auth_con_free(context, auth_context);\n    krb5_free_principal(context, changepw);\n    krb5_free_ticket(context, ticket);\n    free(ap_rep.data);\n    free(clear.data);\n    free(cipher.data);\n    krb5_free_principal(context, target);\n    krb5_free_unparsed_name(context, targetstr);\n    krb5_free_unparsed_name(context, clientstr);\n    krb5_free_error_message(context, errmsg);\n    return ret;\n}\n\n/* Dispatch routine for set/change password */\nvoid\ndispatch(void *handle, struct sockaddr *local_saddr,\n         const krb5_fulladdr *remote_faddr, krb5_data *request, int is_tcp,\n         verto_ctx *vctx, loop_respond_fn respond, void *arg)\n{\n    krb5_error_code ret;\n    krb5_keytab kt = NULL;\n    kadm5_server_handle_t server_handle = (kadm5_server_handle_t)handle;\n    krb5_fulladdr local_faddr;\n    krb5_address **local_kaddrs = NULL, local_kaddr_buf;\n    krb5_data *response = NULL;\n\n    if (local_saddr == NULL) {\n        ret = krb5_os_localaddr(server_handle->context, &local_kaddrs);\n        if (ret != 0)\n            goto egress;\n\n        local_faddr.address = local_kaddrs[0];\n        local_faddr.port = 0;\n    } else {\n        local_faddr.address = &local_kaddr_buf;\n        init_addr(&local_faddr, local_saddr);\n    }\n\n    ret = krb5_kt_resolve(server_handle->context, \"KDB:\", &kt);\n    if (ret != 0) {\n        krb5_klog_syslog(LOG_ERR, _(\"chpw: Couldn't open admin keytab %s\"),\n                         krb5_get_error_message(server_handle->context, ret));\n        goto egress;\n    }\n\n    response = k5alloc(sizeof(krb5_data), &ret);\n    if (response == NULL)\n        goto egress;\n\n    ret = process_chpw_request(server_handle->context,\n                               handle,\n                               server_handle->params.realm,\n                               kt,\n                               &local_faddr,\n                               remote_faddr,\n                               request,\n                               response);\negress:\n    if (ret)\n        krb5_free_data(server_handle->context, response);\n    krb5_free_addresses(server_handle->context, local_kaddrs);\n    krb5_kt_close(server_handle->context, kt);\n    (*respond)(arg, ret, ret == 0 ? response : NULL);\n}\n"], "filenames": ["src/kadmin/server/schpw.c"], "buggy_code_start_loc": [55], "buggy_code_end_loc": [97], "fixing_code_start_loc": [55], "fixing_code_end_loc": [97], "type": "CWE-20", "message": "schpw.c in the kpasswd service in kadmind in MIT Kerberos 5 (aka krb5) before 1.11.3 does not properly validate UDP packets before sending responses, which allows remote attackers to cause a denial of service (CPU and bandwidth consumption) via a forged packet that triggers a communication loop, as demonstrated by krb_pingpong.nasl, a related issue to CVE-1999-0103.", "other": {"cve": {"id": "CVE-2002-2443", "sourceIdentifier": "cve@mitre.org", "published": "2013-05-29T14:29:06.287", "lastModified": "2021-02-02T18:44:21.173", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "schpw.c in the kpasswd service in kadmind in MIT Kerberos 5 (aka krb5) before 1.11.3 does not properly validate UDP packets before sending responses, which allows remote attackers to cause a denial of service (CPU and bandwidth consumption) via a forged packet that triggers a communication loop, as demonstrated by krb_pingpong.nasl, a related issue to CVE-1999-0103."}, {"lang": "es", "value": "schpw.c en el servicio kpasswd en kadmind en MIT Kerberos 5 (conocido como krb5) anterior a v1.11.3 no valida correctamente los paquetes UDP antes de enviar respuestas,  lo que permite a atacantes remotos provocar una denegaci\u00f3n de servicio (consumo de CPU y ancho de banda) a trav\u00e9s de un paquete \"forged\" que activa un circuito de comunicaci\u00f3n, como se demostr\u00f3 en krb_pingpong.nasl, un fallo relacionado con CVE-1999-0103."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.11.3", "matchCriteriaId": "D406116B-5D1C-43FD-BFEC-CCF598AFCBBB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:11.4:*:*:*:*:*:*:*", "matchCriteriaId": "DE554781-1EB9-446E-911F-6C11970C47F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:12.2:*:*:*:*:*:*:*", "matchCriteriaId": "D806A17E-B8F9-466D-807D-3F1E77603DC8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:12.3:*:*:*:*:*:*:*", "matchCriteriaId": "DFBF430B-0832-44B0-AA0E-BA9E467F7668"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:17:*:*:*:*:*:*:*", "matchCriteriaId": "2DA9D861-3EAF-42F5-B0B6-A4CD7BDD6188"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:18:*:*:*:*:*:*:*", "matchCriteriaId": "E14271AE-1309-48F3-B9C6-D7DEEC488279"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:19:*:*:*:*:*:*:*", "matchCriteriaId": "5991814D-CA77-4C25-90D2-DB542B17E0AD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "133AAFA7-AF42-4D7B-8822-AA2E85611BF5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:5.9:*:*:*:*:*:*:*", "matchCriteriaId": "6252E88C-27FF-420D-A64A-C34124CF7E6A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:6.4:*:*:*:*:*:*:*", "matchCriteriaId": "8A8E07B7-3739-4BEB-88F8-C7F62431E889"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "54D669D4-6D7E-449D-80C1-28FA44F06FFE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:6.4:*:*:*:*:*:*:*", "matchCriteriaId": "AF83BB87-B203-48F9-9D06-48A5FE399050"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "D0AC5CD5-6E58-433C-9EB3-6DFE5656463E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "036E8A89-7A16-411F-9D31-676313BB7244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:15.04:*:*:*:*:*:*:*", "matchCriteriaId": "F38D3B7E-8429-473F-BB31-FC3583EE5A5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:15.10:*:*:*:*:*:*:*", "matchCriteriaId": "E88A537F-F4D0-46B9-9E37-965233C2A355"}]}]}], "references": [{"url": "http://krbdev.mit.edu/rt/Ticket/Display.html?id=7637", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-May/105879.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-May/105978.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-May/106698.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-07/msg00004.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-07/msg00007.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-0942.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2013/dsa-2701", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2013:166", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2810-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=962531", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/krb5/krb5/commit/cf1a0c411b2668c57c41e9c4efd15ba17b6b322c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/cf1a0c411b2668c57c41e9c4efd15ba17b6b322c"}}