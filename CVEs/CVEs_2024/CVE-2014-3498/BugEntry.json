{"buggy_code": ["# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n#############################################\n\nimport os\nimport subprocess\nimport ansible.constants as C\nfrom ansible.inventory.host import Host\nfrom ansible.inventory.group import Group\nfrom ansible import utils\nfrom ansible import errors\nimport sys\n\nclass InventoryScript(object):\n    ''' Host inventory parser for ansible using external inventory scripts. '''\n\n    def __init__(self, filename=C.DEFAULT_HOST_LIST):\n\n        # Support inventory scripts that are not prefixed with some\n        # path information but happen to be in the current working\n        # directory when '.' is not in PATH.\n        self.filename = os.path.abspath(filename)\n        cmd = [ self.filename, \"--list\" ]\n        try:\n            sp = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        except OSError, e:\n            raise errors.AnsibleError(\"problem running %s (%s)\" % (' '.join(cmd), e))\n        (stdout, stderr) = sp.communicate()\n        self.data = stdout\n        # see comment about _meta below\n        self.host_vars_from_top = None\n        self.groups = self._parse(stderr)\n\n    def _parse(self, err):\n\n        all_hosts = {}\n        self.raw  = utils.parse_json(self.data)\n        all       = Group('all')\n        groups    = dict(all=all)\n        group     = None\n\n\n        if 'failed' in self.raw:\n            sys.stderr.write(err + \"\\n\")\n            raise errors.AnsibleError(\"failed to parse executable inventory script results: %s\" % self.raw)\n\n        for (group_name, data) in self.raw.items():\n \n            # in Ansible 1.3 and later, a \"_meta\" subelement may contain\n            # a variable \"hostvars\" which contains a hash for each host\n            # if this \"hostvars\" exists at all then do not call --host for each\n            # host.  This is for efficiency and scripts should still return data\n            # if called with --host for backwards compat with 1.2 and earlier.\n\n            if group_name == '_meta':\n                if 'hostvars' in data:\n                    self.host_vars_from_top = data['hostvars']\n                    continue\n\n            if group_name != all.name:\n                group = groups[group_name] = Group(group_name)\n            else:\n                group = all\n            host = None\n\n            if not isinstance(data, dict):\n                data = {'hosts': data}\n            elif not any(k in data for k in ('hosts','vars')):\n                data = {'hosts': [group_name], 'vars': data}\n\n            if 'hosts' in data:\n\n                for hostname in data['hosts']:\n                    if not hostname in all_hosts:\n                        all_hosts[hostname] = Host(hostname)\n                    host = all_hosts[hostname]\n                    group.add_host(host)\n\n            if 'vars' in data:\n                for k, v in data['vars'].iteritems():\n                    if group.name == all.name:\n                        all.set_variable(k, v)\n                    else:\n                        group.set_variable(k, v)\n            if group.name != all.name:\n                all.add_child_group(group)\n\n        # Separate loop to ensure all groups are defined\n        for (group_name, data) in self.raw.items():\n            if group_name == '_meta':\n                continue\n            if isinstance(data, dict) and 'children' in data:\n                for child_name in data['children']:\n                    if child_name in groups:\n                        groups[group_name].add_child_group(groups[child_name])\n        return groups\n\n    def get_host_variables(self, host):\n        \"\"\" Runs <script> --host <hostname> to determine additional host variables \"\"\"\n        if self.host_vars_from_top is not None:\n            got = self.host_vars_from_top.get(host.name, {})\n            return got\n\n\n        cmd = [self.filename, \"--host\", host.name]\n        try:\n            sp = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        except OSError, e:\n            raise errors.AnsibleError(\"problem running %s (%s)\" % (' '.join(cmd), e))\n        (out, err) = sp.communicate()\n        return utils.parse_json(out)\n", "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport multiprocessing\nimport signal\nimport os\nimport pwd\nimport Queue\nimport random\nimport traceback\nimport tempfile\nimport time\nimport collections\nimport socket\nimport base64\nimport sys\nimport pipes\nimport jinja2\nimport subprocess\nimport getpass\n\nimport ansible.constants as C\nimport ansible.inventory\nfrom ansible import utils\nfrom ansible.utils import template\nfrom ansible.utils import check_conditional\nfrom ansible.utils import string_functions\nfrom ansible import errors\nfrom ansible import module_common\nimport poller\nimport connection\nfrom return_data import ReturnData\nfrom ansible.callbacks import DefaultRunnerCallbacks, vv\nfrom ansible.module_common import ModuleReplacer\n\nmodule_replacer = ModuleReplacer(strip_comments=False)\n\nHAS_ATFORK=True\ntry:\n    from Crypto.Random import atfork\nexcept ImportError:\n    HAS_ATFORK=False\n\nmultiprocessing_runner = None\n        \nOUTPUT_LOCKFILE  = tempfile.TemporaryFile()\nPROCESS_LOCKFILE = tempfile.TemporaryFile()\n\n################################################\n\ndef _executor_hook(job_queue, result_queue, new_stdin):\n\n    # attempt workaround of https://github.com/newsapps/beeswithmachineguns/issues/17\n    # this function also not present in CentOS 6\n    if HAS_ATFORK:\n        atfork()\n\n    signal.signal(signal.SIGINT, signal.SIG_IGN)\n    while not job_queue.empty():\n        try:\n            host = job_queue.get(block=False)\n            return_data = multiprocessing_runner._executor(host, new_stdin)\n            result_queue.put(return_data)\n        except Queue.Empty:\n            pass\n        except:\n            traceback.print_exc()\n\nclass HostVars(dict):\n    ''' A special view of vars_cache that adds values from the inventory when needed. '''\n\n    def __init__(self, vars_cache, inventory, vault_password=None):\n        self.vars_cache = vars_cache\n        self.inventory = inventory\n        self.lookup = dict()\n        self.update(vars_cache)\n        self.vault_password = vault_password\n\n    def __getitem__(self, host):\n        if host not in self.lookup:\n            result = self.inventory.get_variables(host, vault_password=self.vault_password).copy()\n            result.update(self.vars_cache.get(host, {}))\n            self.lookup[host] = result\n        return self.lookup[host]\n\n\nclass Runner(object):\n    ''' core API interface to ansible '''\n\n    # see bin/ansible for how this is used...\n\n    def __init__(self,\n        host_list=C.DEFAULT_HOST_LIST,      # ex: /etc/ansible/hosts, legacy usage\n        module_path=None,                   # ex: /usr/share/ansible\n        module_name=C.DEFAULT_MODULE_NAME,  # ex: copy\n        module_args=C.DEFAULT_MODULE_ARGS,  # ex: \"src=/tmp/a dest=/tmp/b\"\n        forks=C.DEFAULT_FORKS,              # parallelism level\n        timeout=C.DEFAULT_TIMEOUT,          # SSH timeout\n        pattern=C.DEFAULT_PATTERN,          # which hosts?  ex: 'all', 'acme.example.org'\n        remote_user=C.DEFAULT_REMOTE_USER,  # ex: 'username'\n        remote_pass=C.DEFAULT_REMOTE_PASS,  # ex: 'password123' or None if using key\n        remote_port=None,                   # if SSH on different ports\n        private_key_file=C.DEFAULT_PRIVATE_KEY_FILE, # if not using keys/passwords\n        sudo_pass=C.DEFAULT_SUDO_PASS,      # ex: 'password123' or None\n        background=0,                       # async poll every X seconds, else 0 for non-async\n        basedir=None,                       # directory of playbook, if applicable\n        setup_cache=None,                   # used to share fact data w/ other tasks\n        vars_cache=None,                    # used to store variables about hosts\n        transport=C.DEFAULT_TRANSPORT,      # 'ssh', 'paramiko', 'local'\n        conditional='True',                 # run only if this fact expression evals to true\n        callbacks=None,                     # used for output\n        sudo=False,                         # whether to run sudo or not\n        sudo_user=C.DEFAULT_SUDO_USER,      # ex: 'root'\n        module_vars=None,                   # a playbooks internals thing\n        default_vars=None,                  # ditto\n        is_playbook=False,                  # running from playbook or not?\n        inventory=None,                     # reference to Inventory object\n        subset=None,                        # subset pattern\n        check=False,                        # don't make any changes, just try to probe for potential changes\n        diff=False,                         # whether to show diffs for template files that change\n        environment=None,                   # environment variables (as dict) to use inside the command\n        complex_args=None,                  # structured data in addition to module_args, must be a dict\n        error_on_undefined_vars=C.DEFAULT_UNDEFINED_VAR_BEHAVIOR, # ex. False\n        accelerate=False,                   # use accelerated connection\n        accelerate_ipv6=False,              # accelerated connection w/ IPv6\n        accelerate_port=None,               # port to use with accelerated connection\n        su=False,                           # Are we running our command via su?\n        su_user=None,                       # User to su to when running command, ex: 'root'\n        su_pass=C.DEFAULT_SU_PASS,\n        vault_pass=None,\n        run_hosts=None,                     # an optional list of pre-calculated hosts to run on\n        no_log=False,                       # option to enable/disable logging for a given task\n        ):\n\n        # used to lock multiprocess inputs and outputs at various levels\n        self.output_lockfile  = OUTPUT_LOCKFILE\n        self.process_lockfile = PROCESS_LOCKFILE\n\n        if not complex_args:\n            complex_args = {}\n\n        # storage & defaults\n        self.check            = check\n        self.diff             = diff\n        self.setup_cache      = utils.default(setup_cache, lambda: collections.defaultdict(dict))\n        self.vars_cache       = utils.default(vars_cache, lambda: collections.defaultdict(dict))\n        self.basedir          = utils.default(basedir, lambda: os.getcwd())\n        self.callbacks        = utils.default(callbacks, lambda: DefaultRunnerCallbacks())\n        self.generated_jid    = str(random.randint(0, 999999999999))\n        self.transport        = transport\n        self.inventory        = utils.default(inventory, lambda: ansible.inventory.Inventory(host_list))\n\n        self.module_vars      = utils.default(module_vars, lambda: {})\n        self.default_vars     = utils.default(default_vars, lambda: {})\n        self.always_run       = None\n        self.connector        = connection.Connector(self)\n        self.conditional      = conditional\n        self.module_name      = module_name\n        self.forks            = int(forks)\n        self.pattern          = pattern\n        self.module_args      = module_args\n        self.timeout          = timeout\n        self.remote_user      = remote_user\n        self.remote_pass      = remote_pass\n        self.remote_port      = remote_port\n        self.private_key_file = private_key_file\n        self.background       = background\n        self.sudo             = sudo\n        self.sudo_user_var    = sudo_user\n        self.sudo_user        = None\n        self.sudo_pass        = sudo_pass\n        self.is_playbook      = is_playbook\n        self.environment      = environment\n        self.complex_args     = complex_args\n        self.error_on_undefined_vars = error_on_undefined_vars\n        self.accelerate       = accelerate\n        self.accelerate_port  = accelerate_port\n        self.accelerate_ipv6  = accelerate_ipv6\n        self.callbacks.runner = self\n        self.su               = su\n        self.su_user_var      = su_user\n        self.su_user          = None\n        self.su_pass          = su_pass\n        self.vault_pass       = vault_pass\n        self.no_log           = no_log\n\n        if self.transport == 'smart':\n            # if the transport is 'smart' see if SSH can support ControlPersist if not use paramiko\n            # 'smart' is the default since 1.2.1/1.3\n            cmd = subprocess.Popen(['ssh','-o','ControlPersist'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            (out, err) = cmd.communicate() \n            if \"Bad configuration option\" in err:\n                self.transport = \"paramiko\"\n            else:\n                self.transport = \"ssh\" \n\n        # save the original transport, in case it gets\n        # changed later via options like accelerate\n        self.original_transport = self.transport\n\n        # misc housekeeping\n        if subset and self.inventory._subset is None:\n            # don't override subset when passed from playbook\n            self.inventory.subset(subset)\n\n        # If we get a pre-built list of hosts to run on, from say a playbook, use them.\n        # Also where we will store the hosts to run on once discovered\n        self.run_hosts = run_hosts\n\n        if self.transport == 'local':\n            self.remote_user = pwd.getpwuid(os.geteuid())[0]\n\n        if module_path is not None:\n            for i in module_path.split(os.pathsep):\n                utils.plugins.module_finder.add_directory(i)\n\n        utils.plugins.push_basedir(self.basedir)\n\n        # ensure we are using unique tmp paths\n        random.seed()\n    # *****************************************************\n\n    def _complex_args_hack(self, complex_args, module_args):\n        \"\"\"\n        ansible-playbook both allows specifying key=value string arguments and complex arguments\n        however not all modules use our python common module system and cannot\n        access these.  An example might be a Bash module.  This hack allows users to still pass \"args\"\n        as a hash of simple scalars to those arguments and is short term.  We could technically\n        just feed JSON to the module, but that makes it hard on Bash consumers.  The way this is implemented\n        it does mean values in 'args' have LOWER priority than those on the key=value line, allowing\n        args to provide yet another way to have pluggable defaults.\n        \"\"\"\n        if complex_args is None:\n            return module_args\n        if not isinstance(complex_args, dict):\n            raise errors.AnsibleError(\"complex arguments are not a dictionary: %s\" % complex_args)\n        for (k,v) in complex_args.iteritems():\n            if isinstance(v, basestring):\n                module_args = \"%s=%s %s\" % (k, pipes.quote(v), module_args)\n        return module_args\n\n    # *****************************************************\n\n    def _transfer_str(self, conn, tmp, name, data):\n        ''' transfer string to remote file '''\n\n        if type(data) == dict:\n            data = utils.jsonify(data)\n\n        afd, afile = tempfile.mkstemp()\n        afo = os.fdopen(afd, 'w')\n        try:\n            if not isinstance(data, unicode):\n                #ensure the data is valid UTF-8\n                data.decode('utf-8')\n            else:\n                data = data.encode('utf-8')\n            afo.write(data)\n        except:\n            raise errors.AnsibleError(\"failure encoding into utf-8\")\n        afo.flush()\n        afo.close()\n\n        remote = conn.shell.join_path(tmp, name)\n        try:\n            conn.put_file(afile, remote)\n        finally:\n            os.unlink(afile)\n        return remote\n\n    # *****************************************************\n\n    def _compute_environment_string(self, conn, inject=None):\n        ''' what environment variables to use when running the command? '''\n\n        enviro = {}\n        if self.environment:\n            enviro = template.template(self.basedir, self.environment, inject, convert_bare=True)\n            enviro = utils.safe_eval(enviro)\n            if type(enviro) != dict:\n                raise errors.AnsibleError(\"environment must be a dictionary, received %s\" % enviro)\n\n        return conn.shell.env_prefix(**enviro)\n\n    # *****************************************************\n\n    def _compute_delegate(self, host, password, remote_inject):\n\n        \"\"\" Build a dictionary of all attributes for the delegate host \"\"\"\n\n        delegate = {}\n\n        # allow delegated host to be templated\n        delegate['host'] = template.template(self.basedir, host, \n                                remote_inject, fail_on_undefined=True)\n\n        delegate['inject'] = remote_inject.copy()\n\n        # set any interpreters\n        interpreters = []\n        for i in delegate['inject']:\n            if i.startswith(\"ansible_\") and i.endswith(\"_interpreter\"):\n                interpreters.append(i)\n        for i in interpreters:\n            del delegate['inject'][i]\n        port = C.DEFAULT_REMOTE_PORT\n\n        this_host = delegate['host']\n\n        # get the vars for the delegate by it's name        \n        try:\n            this_info = delegate['inject']['hostvars'][this_host]\n        except:\n            # make sure the inject is empty for non-inventory hosts\n            this_info = {}\n\n        # get the real ssh_address for the delegate        \n        # and allow ansible_ssh_host to be templated\n        delegate['ssh_host'] = template.template(self.basedir,\n                            this_info.get('ansible_ssh_host', this_host),\n                            this_info, fail_on_undefined=True)\n\n        delegate['port'] = this_info.get('ansible_ssh_port', port)\n\n        delegate['user'] = self._compute_delegate_user(this_host, delegate['inject'])\n\n        delegate['pass'] = this_info.get('ansible_ssh_pass', password)\n        delegate['private_key_file'] = this_info.get('ansible_ssh_private_key_file', \n                                        self.private_key_file)\n        delegate['transport'] = this_info.get('ansible_connection', self.transport)\n        delegate['sudo_pass'] = this_info.get('ansible_sudo_pass', self.sudo_pass)\n\n        # Last chance to get private_key_file from global variables.\n        # this is usefull if delegated host is not defined in the inventory\n        if delegate['private_key_file'] is None:\n            delegate['private_key_file'] = remote_inject.get(\n                'ansible_ssh_private_key_file', None)\n\n        if delegate['private_key_file'] is not None:\n            delegate['private_key_file'] = os.path.expanduser(delegate['private_key_file'])\n\n        for i in this_info:\n            if i.startswith(\"ansible_\") and i.endswith(\"_interpreter\"):\n                delegate['inject'][i] = this_info[i]\n\n        return delegate\n\n    def _compute_delegate_user(self, host, inject):\n\n        \"\"\" Caculate the remote user based on an order of preference \"\"\"\n\n        # inventory > playbook > original_host\n\n        actual_user = inject.get('ansible_ssh_user', self.remote_user)\n        thisuser = None\n\n        if host in inject['hostvars']:\n            if inject['hostvars'][host].get('ansible_ssh_user'):\n                # user for delegate host in inventory\n                thisuser = inject['hostvars'][host].get('ansible_ssh_user')\n\n        if thisuser is None and self.remote_user:\n            # user defined by play/runner\n            thisuser = self.remote_user\n\n        if thisuser is not None:\n            actual_user = thisuser\n        else:\n            # fallback to the inventory user of the play host\n            #actual_user = inject.get('ansible_ssh_user', actual_user)\n            actual_user = inject.get('ansible_ssh_user', self.remote_user)\n\n        return actual_user\n\n\n    # *****************************************************\n\n    def _execute_module(self, conn, tmp, module_name, args,\n        async_jid=None, async_module=None, async_limit=None, inject=None, persist_files=False, complex_args=None, delete_remote_tmp=True):\n\n        ''' transfer and run a module along with its arguments on the remote side'''\n\n        # hack to support fireball mode\n        if module_name == 'fireball':\n            args = \"%s password=%s\" % (args, base64.b64encode(str(utils.key_for_hostname(conn.host))))\n            if 'port' not in args:\n                args += \" port=%s\" % C.ZEROMQ_PORT\n\n        (\n        module_style,\n        shebang,\n        module_data\n        ) = self._configure_module(conn, module_name, args, inject, complex_args)\n\n        # a remote tmp path may be necessary and not already created\n        if self._late_needs_tmp_path(conn, tmp, module_style):\n            tmp = self._make_tmp_path(conn)\n\n        remote_module_path = conn.shell.join_path(tmp, module_name)\n\n        if (module_style != 'new'\n           or async_jid is not None\n           or not conn.has_pipelining\n           or not C.ANSIBLE_SSH_PIPELINING\n           or C.DEFAULT_KEEP_REMOTE_FILES\n           or self.su):\n            self._transfer_str(conn, tmp, module_name, module_data)\n\n        environment_string = self._compute_environment_string(conn, inject)\n\n        if \"tmp\" in tmp and ((self.sudo and self.sudo_user != 'root') or (self.su and self.su_user != 'root')):\n            # deal with possible umask issues once sudo'ed to other user\n            self._remote_chmod(conn, 'a+r', remote_module_path, tmp)\n\n        cmd = \"\"\n        in_data = None\n        if module_style != 'new':\n            if 'CHECKMODE=True' in args:\n                # if module isn't using AnsibleModuleCommon infrastructure we can't be certain it knows how to\n                # do --check mode, so to be safe we will not run it.\n                return ReturnData(conn=conn, result=dict(skipped=True, msg=\"cannot yet run check mode against old-style modules\"))\n            elif 'NO_LOG' in args:\n                return ReturnData(conn=conn, result=dict(skipped=True, msg=\"cannot use no_log: with old-style modules\"))\n\n            args = template.template(self.basedir, args, inject)\n\n            # decide whether we need to transfer JSON or key=value\n            argsfile = None\n            if module_style == 'non_native_want_json':\n                if complex_args:\n                    complex_args.update(utils.parse_kv(args))\n                    argsfile = self._transfer_str(conn, tmp, 'arguments', utils.jsonify(complex_args))\n                else:\n                    argsfile = self._transfer_str(conn, tmp, 'arguments', utils.jsonify(utils.parse_kv(args)))\n\n            else:\n                argsfile = self._transfer_str(conn, tmp, 'arguments', args)\n\n            if (self.sudo and self.sudo_user != 'root') or (self.su and self.su_user != 'root'):\n                # deal with possible umask issues once sudo'ed to other user\n                self._remote_chmod(conn, 'a+r', argsfile, tmp)\n\n            if async_jid is None:\n                cmd = \"%s %s\" % (remote_module_path, argsfile)\n            else:\n                cmd = \" \".join([str(x) for x in [remote_module_path, async_jid, async_limit, async_module, argsfile]])\n        else:\n            if async_jid is None:\n                if conn.has_pipelining and C.ANSIBLE_SSH_PIPELINING and not C.DEFAULT_KEEP_REMOTE_FILES and not self.su:\n                    in_data = module_data\n                else:\n                    cmd = \"%s\" % (remote_module_path)\n            else:\n                cmd = \" \".join([str(x) for x in [remote_module_path, async_jid, async_limit, async_module]])\n\n        if not shebang:\n            raise errors.AnsibleError(\"module is missing interpreter line\")\n\n        rm_tmp = None\n        if \"tmp\" in tmp and not C.DEFAULT_KEEP_REMOTE_FILES and not persist_files and delete_remote_tmp:\n            if not self.sudo or self.su or self.sudo_user == 'root' or self.su_user == 'root':\n                # not sudoing or sudoing to root, so can cleanup files in the same step\n                rm_tmp = tmp\n\n        cmd = conn.shell.build_module_command(environment_string, shebang, cmd, rm_tmp)\n        cmd = cmd.strip()\n\n        sudoable = True\n        if module_name == \"accelerate\":\n            # always run the accelerate module as the user\n            # specified in the play, not the sudo_user\n            sudoable = False\n\n        if self.su:\n            res = self._low_level_exec_command(conn, cmd, tmp, su=True, in_data=in_data)\n        else:\n            res = self._low_level_exec_command(conn, cmd, tmp, sudoable=sudoable, in_data=in_data)\n\n        if \"tmp\" in tmp and not C.DEFAULT_KEEP_REMOTE_FILES and not persist_files and delete_remote_tmp:\n            if (self.sudo and self.sudo_user != 'root') or (self.su and self.su_user != 'root'):\n            # not sudoing to root, so maybe can't delete files as that other user\n            # have to clean up temp files as original user in a second step\n                cmd2 = conn.shell.remove(tmp, recurse=True)\n                self._low_level_exec_command(conn, cmd2, tmp, sudoable=False)\n\n        data = utils.parse_json(res['stdout'])\n        if 'parsed' in data and data['parsed'] == False:\n            data['msg'] += res['stderr']\n        return ReturnData(conn=conn, result=data)\n\n    # *****************************************************\n\n    def _executor(self, host, new_stdin):\n        ''' handler for multiprocessing library '''\n\n        try:\n            fileno = sys.stdin.fileno()\n        except ValueError:\n            fileno = None\n\n        try:\n            self._new_stdin = new_stdin\n            if not new_stdin and fileno is not None:\n                try:\n                    self._new_stdin = os.fdopen(os.dup(fileno))\n                except OSError, e:\n                    # couldn't dupe stdin, most likely because it's\n                    # not a valid file descriptor, so we just rely on\n                    # using the one that was passed in\n                    pass\n\n            exec_rc = self._executor_internal(host, new_stdin)\n            if type(exec_rc) != ReturnData:\n                raise Exception(\"unexpected return type: %s\" % type(exec_rc))\n            # redundant, right?\n            if not exec_rc.comm_ok:\n                self.callbacks.on_unreachable(host, exec_rc.result)\n            return exec_rc\n        except errors.AnsibleError, ae:\n            msg = str(ae)\n            self.callbacks.on_unreachable(host, msg)\n            return ReturnData(host=host, comm_ok=False, result=dict(failed=True, msg=msg))\n        except Exception:\n            msg = traceback.format_exc()\n            self.callbacks.on_unreachable(host, msg)\n            return ReturnData(host=host, comm_ok=False, result=dict(failed=True, msg=msg))\n\n    # *****************************************************\n\n    def _executor_internal(self, host, new_stdin):\n        ''' executes any module one or more times '''\n\n        host_variables = self.inventory.get_variables(host, vault_password=self.vault_pass)\n        host_connection = host_variables.get('ansible_connection', self.transport)\n        if host_connection in [ 'paramiko', 'ssh', 'accelerate' ]:\n            port = host_variables.get('ansible_ssh_port', self.remote_port)\n            if port is None:\n                port = C.DEFAULT_REMOTE_PORT\n        else:\n            # fireball, local, etc\n            port = self.remote_port\n\n        # merge the VARS and SETUP caches for this host\n        combined_cache = self.setup_cache.copy()\n        combined_cache.setdefault(host, {}).update(self.vars_cache.get(host, {}))\n        hostvars = HostVars(combined_cache, self.inventory, vault_password=self.vault_pass)\n\n        # use combined_cache and host_variables to template the module_vars\n        # we update the inject variables with the data we're about to template\n        # since some of the variables we'll be replacing may be contained there too\n        module_vars_inject = utils.combine_vars(host_variables, combined_cache.get(host, {}))\n        module_vars_inject = utils.combine_vars(self.module_vars, module_vars_inject)\n        module_vars = template.template(self.basedir, self.module_vars, module_vars_inject)\n\n        inject = {}\n        inject = utils.combine_vars(inject, self.default_vars)\n        inject = utils.combine_vars(inject, host_variables)\n        inject = utils.combine_vars(inject, module_vars)\n        inject = utils.combine_vars(inject, combined_cache.get(host, {}))\n        inject.setdefault('ansible_ssh_user', self.remote_user)\n        inject['hostvars']    = hostvars\n        inject['group_names'] = host_variables.get('group_names', [])\n        inject['groups']      = self.inventory.groups_list()\n        inject['vars']        = self.module_vars\n        inject['defaults']    = self.default_vars\n        inject['environment'] = self.environment\n        inject['playbook_dir'] = self.basedir\n\n        if self.inventory.basedir() is not None:\n            inject['inventory_dir'] = self.inventory.basedir()\n\n        if self.inventory.src() is not None:\n            inject['inventory_file'] = self.inventory.src()\n\n        # allow with_foo to work in playbooks...\n        items = None\n        items_plugin = self.module_vars.get('items_lookup_plugin', None)\n\n        if items_plugin is not None and items_plugin in utils.plugins.lookup_loader:\n\n            basedir = self.basedir\n            if '_original_file' in inject:\n                basedir = os.path.dirname(inject['_original_file'])\n                filesdir = os.path.join(basedir, '..', 'files')\n                if os.path.exists(filesdir):\n                    basedir = filesdir\n\n            items_terms = self.module_vars.get('items_lookup_terms', '')\n            items_terms = template.template(basedir, items_terms, inject)\n            items = utils.plugins.lookup_loader.get(items_plugin, runner=self, basedir=basedir).run(items_terms, inject=inject)\n            if type(items) != list:\n                raise errors.AnsibleError(\"lookup plugins have to return a list: %r\" % items)\n\n            if len(items) and utils.is_list_of_strings(items) and self.module_name in [ 'apt', 'yum', 'pkgng' ]:\n                # hack for apt, yum, and pkgng so that with_items maps back into a single module call\n                use_these_items = []\n                for x in items:\n                    inject['item'] = x\n                    if not self.conditional or utils.check_conditional(self.conditional, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars):\n                        use_these_items.append(x)\n                inject['item'] = \",\".join(use_these_items)\n                items = None\n\n        # logic to replace complex args if possible\n        complex_args = self.complex_args\n\n        # logic to decide how to run things depends on whether with_items is used\n        if items is None:\n            if isinstance(complex_args, basestring):\n                complex_args = template.template(self.basedir, complex_args, inject, convert_bare=True)\n                complex_args = utils.safe_eval(complex_args)\n                if type(complex_args) != dict:\n                    raise errors.AnsibleError(\"args must be a dictionary, received %s\" % complex_args)\n            return self._executor_internal_inner(host, self.module_name, self.module_args, inject, port, complex_args=complex_args)\n        elif len(items) > 0:\n\n            # executing using with_items, so make multiple calls\n            # TODO: refactor\n\n            if self.background > 0:\n                raise errors.AnsibleError(\"lookup plugins (with_*) cannot be used with async tasks\")\n\n            all_comm_ok = True\n            all_changed = False\n            all_failed = False\n            results = []\n            for x in items:\n                # use a fresh inject for each item\n                this_inject = inject.copy()\n                this_inject['item'] = x\n\n                # TODO: this idiom should be replaced with an up-conversion to a Jinja2 template evaluation\n                if isinstance(self.complex_args, basestring):\n                    complex_args = template.template(self.basedir, self.complex_args, this_inject, convert_bare=True)\n                    complex_args = utils.safe_eval(complex_args)\n                    if type(complex_args) != dict:\n                        raise errors.AnsibleError(\"args must be a dictionary, received %s\" % complex_args)\n                result = self._executor_internal_inner(\n                     host,\n                     self.module_name,\n                     self.module_args,\n                     this_inject,\n                     port,\n                     complex_args=complex_args\n                )\n                results.append(result.result)\n                if result.comm_ok == False:\n                    all_comm_ok = False\n                    all_failed = True\n                    break\n                for x in results:\n                    if x.get('changed') == True:\n                        all_changed = True\n                    if (x.get('failed') == True) or ('failed_when_result' in x and [x['failed_when_result']] or [('rc' in x) and (x['rc'] != 0)])[0]:\n                        all_failed = True\n                        break\n            msg = 'All items completed'\n            if all_failed:\n                msg = \"One or more items failed.\"\n            rd_result = dict(failed=all_failed, changed=all_changed, results=results, msg=msg)\n            if not all_failed:\n                del rd_result['failed']\n            return ReturnData(host=host, comm_ok=all_comm_ok, result=rd_result)\n        else:\n            self.callbacks.on_skipped(host, None)\n            return ReturnData(host=host, comm_ok=True, result=dict(changed=False, skipped=True))\n\n    # *****************************************************\n\n    def _executor_internal_inner(self, host, module_name, module_args, inject, port, is_chained=False, complex_args=None):\n        ''' decides how to invoke a module '''\n\n        # late processing of parameterized sudo_user (with_items,..)\n        if self.sudo_user_var is not None:\n            self.sudo_user = template.template(self.basedir, self.sudo_user_var, inject)\n        if self.su_user_var is not None:\n            self.su_user = template.template(self.basedir, self.su_user_var, inject)\n\n        # allow module args to work as a dictionary\n        # though it is usually a string\n        new_args = \"\"\n        if type(module_args) == dict:\n            for (k,v) in module_args.iteritems():\n                new_args = new_args + \"%s='%s' \" % (k,v)\n            module_args = new_args\n\n        # module_name may be dynamic (but cannot contain {{ ansible_ssh_user }})\n        module_name  = template.template(self.basedir, module_name, inject)\n\n        if module_name in utils.plugins.action_loader:\n            if self.background != 0:\n                raise errors.AnsibleError(\"async mode is not supported with the %s module\" % module_name)\n            handler = utils.plugins.action_loader.get(module_name, self)\n        elif self.background == 0:\n            handler = utils.plugins.action_loader.get('normal', self)\n        else:\n            handler = utils.plugins.action_loader.get('async', self)\n\n        if type(self.conditional) != list:\n            self.conditional = [ self.conditional ]\n\n        for cond in self.conditional:\n\n            if not utils.check_conditional(cond, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars):\n                result = utils.jsonify(dict(changed=False, skipped=True))\n                self.callbacks.on_skipped(host, inject.get('item',None))\n                return ReturnData(host=host, result=result)\n\n        if getattr(handler, 'setup', None) is not None:\n            handler.setup(module_name, inject)\n        conn = None\n        actual_host = inject.get('ansible_ssh_host', host)\n        # allow ansible_ssh_host to be templated\n        actual_host = template.template(self.basedir, actual_host, inject, fail_on_undefined=True)\n        actual_port = port\n        actual_user = inject.get('ansible_ssh_user', self.remote_user)\n        actual_pass = inject.get('ansible_ssh_pass', self.remote_pass)\n        actual_transport = inject.get('ansible_connection', self.transport)\n        actual_private_key_file = inject.get('ansible_ssh_private_key_file', self.private_key_file)\n        actual_private_key_file = template.template(self.basedir, actual_private_key_file, inject, fail_on_undefined=True)\n        self.sudo = utils.boolean(inject.get('ansible_sudo', self.sudo))\n        self.sudo_user = inject.get('ansible_sudo_user', self.sudo_user)\n        self.sudo_pass = inject.get('ansible_sudo_pass', self.sudo_pass)\n        self.su = inject.get('ansible_su', self.su)\n        self.su_pass = inject.get('ansible_su_pass', self.su_pass)\n\n        # select default root user in case self.sudo requested\n        # but no user specified; happens e.g. in host vars when\n        # just ansible_sudo=True is specified\n        if self.sudo and self.sudo_user is None:\n            self.sudo_user = 'root'\n\n        if actual_private_key_file is not None:\n            actual_private_key_file = os.path.expanduser(actual_private_key_file)\n\n        if self.accelerate and actual_transport != 'local':\n            #Fix to get the inventory name of the host to accelerate plugin\n            if inject.get('ansible_ssh_host', None):\n                self.accelerate_inventory_host = host\n            else:\n                self.accelerate_inventory_host = None\n            # if we're using accelerated mode, force the\n            # transport to accelerate\n            actual_transport = \"accelerate\"\n            if not self.accelerate_port:\n                self.accelerate_port = C.ACCELERATE_PORT\n\n        actual_port = inject.get('ansible_ssh_port', port)\n\n        # the delegated host may have different SSH port configured, etc\n        # and we need to transfer those, and only those, variables\n        delegate_to = inject.get('delegate_to', None)\n        if delegate_to is not None:\n            delegate = self._compute_delegate(delegate_to, actual_pass, inject)\n            actual_transport = delegate['transport']\n            actual_host = delegate['ssh_host']\n            actual_port = delegate['port']\n            actual_user = delegate['user']\n            actual_pass = delegate['pass']\n            actual_private_key_file = delegate['private_key_file']\n            self.sudo_pass = delegate['sudo_pass']\n            inject = delegate['inject']\n\n        # user/pass may still contain variables at this stage\n        actual_user = template.template(self.basedir, actual_user, inject)\n        actual_pass = template.template(self.basedir, actual_pass, inject)\n        self.sudo_pass = template.template(self.basedir, self.sudo_pass, inject)\n\n        # make actual_user available as __magic__ ansible_ssh_user variable\n        inject['ansible_ssh_user'] = actual_user\n\n        try:\n            if actual_transport == 'accelerate':\n                # for accelerate, we stuff both ports into a single\n                # variable so that we don't have to mangle other function\n                # calls just to accomodate this one case\n                actual_port = [actual_port, self.accelerate_port]\n            elif actual_port is not None:\n                actual_port = int(template.template(self.basedir, actual_port, inject))\n        except ValueError, e:\n            result = dict(failed=True, msg=\"FAILED: Configured port \\\"%s\\\" is not a valid port, expected integer\" % actual_port)\n            return ReturnData(host=host, comm_ok=False, result=result)\n\n        try:\n            conn = self.connector.connect(actual_host, actual_port, actual_user, actual_pass, actual_transport, actual_private_key_file)\n            if delegate_to or host != actual_host:\n                conn.delegate = host\n\n            default_shell = getattr(conn, 'default_shell', '')\n            shell_type = inject.get('ansible_shell_type')\n            if not shell_type:\n                if default_shell:\n                    shell_type = default_shell\n                else:\n                    shell_type = os.path.basename(C.DEFAULT_EXECUTABLE)\n\n            shell_plugin = utils.plugins.shell_loader.get(shell_type)\n            if shell_plugin is None:\n                shell_plugin = utils.plugins.shell_loader.get('sh')\n            conn.shell = shell_plugin\n\n        except errors.AnsibleConnectionFailed, e:\n            result = dict(failed=True, msg=\"FAILED: %s\" % str(e))\n            return ReturnData(host=host, comm_ok=False, result=result)\n\n        tmp = ''\n        # action plugins may DECLARE via TRANSFERS_FILES = True that they need a remote tmp path working dir\n        if self._early_needs_tmp_path(module_name, handler):\n            tmp = self._make_tmp_path(conn)\n\n        # render module_args and complex_args templates\n        try:\n            module_args = template.template(self.basedir, module_args, inject, fail_on_undefined=self.error_on_undefined_vars)\n            complex_args = template.template(self.basedir, complex_args, inject, fail_on_undefined=self.error_on_undefined_vars)\n        except jinja2.exceptions.UndefinedError, e:\n            raise errors.AnsibleUndefinedVariable(\"One or more undefined variables: %s\" % str(e))\n\n\n        result = handler.run(conn, tmp, module_name, module_args, inject, complex_args)\n        # Code for do until feature\n        until = self.module_vars.get('until', None)\n        if until is not None and result.comm_ok:\n            inject[self.module_vars.get('register')] = result.result\n            cond = template.template(self.basedir, until, inject, expand_lists=False)\n            if not utils.check_conditional(cond,  self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars):\n                retries = self.module_vars.get('retries')\n                delay   = self.module_vars.get('delay')\n                for x in range(1, int(retries) + 1):\n                    # template the delay, cast to float and sleep\n                    delay = template.template(self.basedir, delay, inject, expand_lists=False)\n                    delay = float(delay)\n                    time.sleep(delay)\n                    tmp = ''\n                    if self._early_needs_tmp_path(module_name, handler):\n                        tmp = self._make_tmp_path(conn)\n                    result = handler.run(conn, tmp, module_name, module_args, inject, complex_args)\n                    result.result['attempts'] = x\n                    vv(\"Result from run %i is: %s\" % (x, result.result))\n                    inject[self.module_vars.get('register')] = result.result\n                    cond = template.template(self.basedir, until, inject, expand_lists=False)\n                    if utils.check_conditional(cond, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars):\n                        break\n                if result.result['attempts'] == retries and not utils.check_conditional(cond, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars):\n                    result.result['failed'] = True \n                    result.result['msg'] = \"Task failed as maximum retries was encountered\"\n            else:\n                result.result['attempts'] = 0\n        conn.close()\n\n        if not result.comm_ok:\n            # connection or parsing errors...\n            self.callbacks.on_unreachable(host, result.result)\n        else:\n            data = result.result\n\n            # https://github.com/ansible/ansible/issues/4958\n            if hasattr(sys.stdout, \"isatty\"):\n                if \"stdout\" in data and sys.stdout.isatty():\n                    if not string_functions.isprintable(data['stdout']):\n                        data['stdout'] = ''\n\n            if 'item' in inject:\n                result.result['item'] = inject['item']\n\n            result.result['invocation'] = dict(\n                module_args=module_args,\n                module_name=module_name\n            )\n\n            changed_when = self.module_vars.get('changed_when')\n            failed_when = self.module_vars.get('failed_when')\n            if (changed_when is not None or failed_when is not None) and self.background == 0:\n                register = self.module_vars.get('register')\n                if register is not None:\n                    if 'stdout' in data:\n                        data['stdout_lines'] = data['stdout'].splitlines()\n                    inject[register] = data\n                # only run the final checks if the async_status has finished,\n                # or if we're not running an async_status check at all\n                if (module_name == 'async_status' and \"finished\" in data) or module_name != 'async_status':\n                    if changed_when is not None and 'skipped' not in data:\n                        data['changed'] = utils.check_conditional(changed_when, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars)\n                    if failed_when is not None and 'skipped' not in data:\n                        data['failed_when_result'] = data['failed'] = utils.check_conditional(failed_when, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars)\n\n            if is_chained:\n                # no callbacks\n                return result\n            if 'skipped' in data:\n                self.callbacks.on_skipped(host, inject.get('item',None))\n            elif not result.is_successful():\n                ignore_errors = self.module_vars.get('ignore_errors', False)\n                self.callbacks.on_failed(host, data, ignore_errors)\n            else:\n                if self.diff:\n                    self.callbacks.on_file_diff(conn.host, result.diff)\n                self.callbacks.on_ok(host, data)\n        return result\n\n    def _early_needs_tmp_path(self, module_name, handler):\n        ''' detect if a tmp path should be created before the handler is called '''\n        if module_name in utils.plugins.action_loader:\n          return getattr(handler, 'TRANSFERS_FILES', False)\n        # other modules never need tmp path at early stage\n        return False\n\n    def _late_needs_tmp_path(self, conn, tmp, module_style):\n        if \"tmp\" in tmp:\n            # tmp has already been created\n            return False\n        if not conn.has_pipelining or not C.ANSIBLE_SSH_PIPELINING or C.DEFAULT_KEEP_REMOTE_FILES or self.su:\n            # tmp is necessary to store module source code\n            return True\n        if not conn.has_pipelining:\n            # tmp is necessary to store the module source code\n            # or we want to keep the files on the target system\n            return True\n        if module_style != \"new\":\n            # even when conn has pipelining, old style modules need tmp to store arguments\n            return True\n        return False\n    \n\n    # *****************************************************\n\n    def _low_level_exec_command(self, conn, cmd, tmp, sudoable=False,\n                                executable=None, su=False, in_data=None):\n        ''' execute a command string over SSH, return the output '''\n\n        if not cmd:\n            # this can happen with powershell modules when there is no analog to a Windows command (like chmod)\n            return dict(stdout='', stderr='')\n\n        if executable is None:\n            executable = C.DEFAULT_EXECUTABLE\n\n        sudo_user = self.sudo_user\n        su_user = self.su_user\n\n        # compare connection user to (su|sudo)_user and disable if the same\n        # assume connection type is local if no user attribute\n        this_user = getattr(conn, 'user', getpass.getuser())\n        if (not su and this_user == sudo_user) or (su and this_user == su_user):\n            sudoable = False\n            su = False\n\n        if su:\n            rc, stdin, stdout, stderr = conn.exec_command(cmd,\n                                                          tmp,\n                                                          su=su,\n                                                          su_user=su_user,\n                                                          executable=executable,\n                                                          in_data=in_data)\n        else:\n            rc, stdin, stdout, stderr = conn.exec_command(cmd,\n                                                          tmp,\n                                                          sudo_user,\n                                                          sudoable=sudoable,\n                                                          executable=executable,\n                                                          in_data=in_data)\n\n        if type(stdout) not in [ str, unicode ]:\n            out = ''.join(stdout.readlines())\n        else:\n            out = stdout\n\n        if type(stderr) not in [ str, unicode ]:\n            err = ''.join(stderr.readlines())\n        else:\n            err = stderr\n\n        if rc is not None:\n            return dict(rc=rc, stdout=out, stderr=err)\n        else:\n            return dict(stdout=out, stderr=err)\n\n    # *****************************************************\n\n    def _remote_chmod(self, conn, mode, path, tmp, sudoable=False, su=False):\n        ''' issue a remote chmod command '''\n        cmd = conn.shell.chmod(mode, path)\n        return self._low_level_exec_command(conn, cmd, tmp, sudoable=sudoable, su=su)\n\n    # *****************************************************\n\n    def _remote_md5(self, conn, tmp, path):\n        ''' takes a remote md5sum without requiring python, and returns 1 if no file '''\n        cmd = conn.shell.md5(path)\n        data = self._low_level_exec_command(conn, cmd, tmp, sudoable=True)\n        data2 = utils.last_non_blank_line(data['stdout'])\n        try:\n            if data2 == '':\n                # this may happen if the connection to the remote server\n                # failed, so just return \"INVALIDMD5SUM\" to avoid errors\n                return \"INVALIDMD5SUM\"\n            else:\n                return data2.split()[0]\n        except IndexError:\n            sys.stderr.write(\"warning: md5sum command failed unusually, please report this to the list so it can be fixed\\n\")\n            sys.stderr.write(\"command: %s\\n\" % md5s)\n            sys.stderr.write(\"----\\n\")\n            sys.stderr.write(\"output: %s\\n\" % data)\n            sys.stderr.write(\"----\\n\")\n            # this will signal that it changed and allow things to keep going\n            return \"INVALIDMD5SUM\"\n\n    # *****************************************************\n\n    def _make_tmp_path(self, conn):\n        ''' make and return a temporary path on a remote box '''\n        basefile = 'ansible-tmp-%s-%s' % (time.time(), random.randint(0, 2**48))\n        use_system_tmp = False\n        if (self.sudo and self.sudo_user != 'root') or (self.su and self.su_user != 'root'):\n            use_system_tmp = True\n\n        tmp_mode = None\n        if self.remote_user != 'root' or ((self.sudo and self.sudo_user != 'root') or (self.su and self.su_user != 'root')):\n            tmp_mode = 'a+rx'\n\n        cmd = conn.shell.mkdtemp(basefile, use_system_tmp, tmp_mode)\n        result = self._low_level_exec_command(conn, cmd, None, sudoable=False)\n\n        # error handling on this seems a little aggressive?\n        if result['rc'] != 0:\n            if result['rc'] == 5:\n                output = 'Authentication failure.'\n            elif result['rc'] == 255 and self.transport in ['ssh']:\n                if utils.VERBOSITY > 3:\n                    output = 'SSH encountered an unknown error. The output was:\\n%s' % (result['stdout']+result['stderr'])\n                else:\n                    output = 'SSH encountered an unknown error during the connection. We recommend you re-run the command using -vvvv, which will enable SSH debugging output to help diagnose the issue'\n            else:\n                output = 'Authentication or permission failure.  In some cases, you may have been able to authenticate and did not have permissions on the remote directory. Consider changing the remote temp path in ansible.cfg to a path rooted in \"/tmp\". Failed command was: %s, exited with result %d' % (cmd, result['rc'])\n            if 'stdout' in result and result['stdout'] != '':\n                output = output + \": %s\" % result['stdout']\n            raise errors.AnsibleError(output)\n\n        rc = conn.shell.join_path(utils.last_non_blank_line(result['stdout']).strip(), '')\n        # Catch failure conditions, files should never be\n        # written to locations in /.\n        if rc == '/': \n            raise errors.AnsibleError('failed to resolve remote temporary directory from %s: `%s` returned empty string' % (basetmp, cmd))\n        return rc\n\n    # *****************************************************\n\n    def _remove_tmp_path(self, conn, tmp_path):\n        ''' Remove a tmp_path. '''\n        if \"-tmp-\" in tmp_path:\n            cmd = conn.shell.remove(tmp_path, recurse=True)\n            self._low_level_exec_command(conn, cmd, None, sudoable=False)\n            # If we have gotten here we have a working ssh configuration.\n            # If ssh breaks we could leave tmp directories out on the remote system.\n\n    # *****************************************************\n\n    def _copy_module(self, conn, tmp, module_name, module_args, inject, complex_args=None):\n        ''' transfer a module over SFTP, does not run it '''\n        (\n        module_style,\n        module_shebang,\n        module_data\n        ) = self._configure_module(conn, module_name, module_args, inject, complex_args)\n        module_remote_path = conn.shell.join_path(tmp, module_name)\n        \n        self._transfer_str(conn, tmp, module_name, module_data)\n         \n        return (module_remote_path, module_style, module_shebang)\n\n    # *****************************************************\n\n    def _configure_module(self, conn, module_name, module_args, inject, complex_args=None):\n        ''' find module and configure it '''\n\n        # Search module path(s) for named module.\n        module_suffixes = getattr(conn, 'default_suffixes', None)\n        module_path = utils.plugins.module_finder.find_plugin(module_name, module_suffixes)\n        if module_path is None:\n            raise errors.AnsibleFileNotFound(\"module %s not found in %s\" % (module_name, utils.plugins.module_finder.print_paths()))\n\n\n        # insert shared code and arguments into the module\n        (module_data, module_style, module_shebang) = module_replacer.modify_module(\n            module_path, complex_args, module_args, inject\n        )\n\n        return (module_style, module_shebang, module_data)\n\n\n    # *****************************************************\n\n\n    def _parallel_exec(self, hosts):\n        ''' handles mulitprocessing when more than 1 fork is required '''\n\n        manager = multiprocessing.Manager()\n        job_queue = manager.Queue()\n        for host in hosts:\n            job_queue.put(host)\n        result_queue = manager.Queue()\n\n        try:\n            fileno = sys.stdin.fileno()\n        except ValueError:\n            fileno = None\n\n        workers = []\n        for i in range(self.forks):\n            new_stdin = None\n            if fileno is not None:\n                try:\n                    new_stdin = os.fdopen(os.dup(fileno))\n                except OSError, e:\n                    # couldn't dupe stdin, most likely because it's\n                    # not a valid file descriptor, so we just rely on\n                    # using the one that was passed in\n                    pass\n            prc = multiprocessing.Process(target=_executor_hook,\n                args=(job_queue, result_queue, new_stdin))\n            prc.start()\n            workers.append(prc)\n\n        try:\n            for worker in workers:\n                worker.join()\n        except KeyboardInterrupt:\n            for worker in workers:\n                worker.terminate()\n                worker.join()\n        \n        results = []\n        try:\n            while not result_queue.empty():\n                results.append(result_queue.get(block=False))\n        except socket.error:\n            raise errors.AnsibleError(\"<interrupted>\")\n        return results\n\n    # *****************************************************\n\n    def _partition_results(self, results):\n        ''' separate results by ones we contacted & ones we didn't '''\n\n        if results is None:\n            return None\n        results2 = dict(contacted={}, dark={})\n\n        for result in results:\n            host = result.host\n            if host is None:\n                raise Exception(\"internal error, host not set\")\n            if result.communicated_ok():\n                results2[\"contacted\"][host] = result.result\n            else:\n                results2[\"dark\"][host] = result.result\n\n        # hosts which were contacted but never got a chance to return\n        for host in self.run_hosts:\n            if not (host in results2['dark'] or host in results2['contacted']):\n                results2[\"dark\"][host] = {}\n        return results2\n\n    # *****************************************************\n\n    def run(self):\n        ''' xfer & run module on all matched hosts '''\n\n        # find hosts that match the pattern\n        if not self.run_hosts:\n            self.run_hosts = self.inventory.list_hosts(self.pattern)\n        hosts = self.run_hosts\n        if len(hosts) == 0:\n            self.callbacks.on_no_hosts()\n            return dict(contacted={}, dark={})\n\n        global multiprocessing_runner\n        multiprocessing_runner = self\n        results = None\n\n        # Check if this is an action plugin. Some of them are designed\n        # to be ran once per group of hosts. Example module: pause,\n        # run once per hostgroup, rather than pausing once per each\n        # host.\n        p = utils.plugins.action_loader.get(self.module_name, self)\n\n        if self.forks == 0 or self.forks > len(hosts):\n            self.forks = len(hosts)\n\n        if p and getattr(p, 'BYPASS_HOST_LOOP', None):\n\n            # Expose the current hostgroup to the bypassing plugins\n            self.host_set = hosts\n            # We aren't iterating over all the hosts in this\n            # group. So, just pick the first host in our group to\n            # construct the conn object with.\n            result_data = self._executor(hosts[0], None).result\n            # Create a ResultData item for each host in this group\n            # using the returned result. If we didn't do this we would\n            # get false reports of dark hosts.\n            results = [ ReturnData(host=h, result=result_data, comm_ok=True) \\\n                           for h in hosts ]\n            del self.host_set\n\n        elif self.forks > 1:\n            try:\n                results = self._parallel_exec(hosts)\n            except IOError, ie:\n                print ie.errno\n                if ie.errno == 32:\n                    # broken pipe from Ctrl+C\n                    raise errors.AnsibleError(\"interrupted\")\n                raise\n        else:\n            results = [ self._executor(h, None) for h in hosts ]\n\n        return self._partition_results(results)\n\n    # *****************************************************\n\n    def run_async(self, time_limit):\n        ''' Run this module asynchronously and return a poller. '''\n\n        self.background = time_limit\n        results = self.run()\n        return results, poller.AsyncPoller(results, self)\n\n    # *****************************************************\n\n    def noop_on_check(self, inject):\n        ''' Should the runner run in check mode or not ? '''\n\n        # initialize self.always_run on first call\n        if self.always_run is None:\n            self.always_run = self.module_vars.get('always_run', False)\n            self.always_run = check_conditional(\n                self.always_run, self.basedir, inject, fail_on_undefined=True)\n\n        return (self.check and not self.always_run)\n", "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom ansible import utils\n\nclass ReturnData(object):\n    ''' internal return class for runner execute methods, not part of public API signature '''\n\n    __slots__ = [ 'result', 'comm_ok', 'host', 'diff' ]\n\n    def __init__(self, conn=None, host=None, result=None, \n        comm_ok=True, diff=dict()):\n\n        # which host is this ReturnData about?\n        if conn is not None:\n            self.host = conn.host\n            delegate = getattr(conn, 'delegate', None)\n            if delegate is not None:\n                self.host = delegate\n\n        else:\n            self.host = host\n\n        self.result = result\n        self.comm_ok = comm_ok\n\n        # if these values are set and used with --diff we can show\n        # changes made to particular files\n        self.diff = diff\n\n        if type(self.result) in [ str, unicode ]:\n            self.result = utils.parse_json(self.result)\n\n\n        if self.host is None:\n            raise Exception(\"host not set\")\n        if type(self.result) != dict:\n            raise Exception(\"dictionary result expected\")\n\n    def communicated_ok(self):\n        return self.comm_ok\n\n    def is_successful(self):\n        return self.comm_ok and (self.result.get('failed', False) == False) and ('failed_when_result' in self.result and [not self.result['failed_when_result']] or [self.result.get('rc',0) == 0])[0]\n\n", "# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nimport re\nimport os\nimport shlex\nimport yaml\nimport copy\nimport optparse\nimport operator\nfrom ansible import errors\nfrom ansible import __version__\nfrom ansible.utils import template\nfrom ansible.utils.display_functions import *\nfrom ansible.utils.plugins import *\nfrom ansible.callbacks import display\nimport ansible.constants as C\nimport ast\nimport time\nimport StringIO\nimport stat\nimport termios\nimport tty\nimport pipes\nimport random\nimport difflib\nimport warnings\nimport traceback\nimport getpass\nimport sys\nimport json\n\nfrom vault import VaultLib\n\nVERBOSITY=0\n\nMAX_FILE_SIZE_FOR_DIFF=1*1024*1024\n\ntry:\n    import json\nexcept ImportError:\n    import simplejson as json\n\ntry:\n    from hashlib import md5 as _md5\nexcept ImportError:\n    from md5 import md5 as _md5\n\nPASSLIB_AVAILABLE = False\ntry:\n    import passlib.hash\n    PASSLIB_AVAILABLE = True\nexcept:\n    pass\n\ntry:\n    import builtin\nexcept ImportError:\n    import __builtin__ as builtin\n\nKEYCZAR_AVAILABLE=False\ntry:\n    try:\n        # some versions of pycrypto may not have this?\n        from Crypto.pct_warnings import PowmInsecureWarning\n    except ImportError:\n        PowmInsecureWarning = RuntimeWarning\n\n    with warnings.catch_warnings(record=True) as warning_handler:\n        warnings.simplefilter(\"error\", PowmInsecureWarning)\n        try:\n            import keyczar.errors as key_errors\n            from keyczar.keys import AesKey\n        except PowmInsecureWarning:\n            system_warning(\n                \"The version of gmp you have installed has a known issue regarding \" + \\\n                \"timing vulnerabilities when used with pycrypto. \" + \\\n                \"If possible, you should update it (ie. yum update gmp).\"\n            )\n            warnings.resetwarnings()\n            warnings.simplefilter(\"ignore\")\n            import keyczar.errors as key_errors\n            from keyczar.keys import AesKey\n        KEYCZAR_AVAILABLE=True\nexcept ImportError:\n    pass\n\n###############################################################\n# Abstractions around keyczar\n###############################################################\n\ndef key_for_hostname(hostname):\n    # fireball mode is an implementation of ansible firing up zeromq via SSH\n    # to use no persistent daemons or key management\n\n    if not KEYCZAR_AVAILABLE:\n        raise errors.AnsibleError(\"python-keyczar must be installed on the control machine to use accelerated modes\")\n\n    key_path = os.path.expanduser(C.ACCELERATE_KEYS_DIR)\n    if not os.path.exists(key_path):\n        os.makedirs(key_path, mode=0700)\n        os.chmod(key_path, int(C.ACCELERATE_KEYS_DIR_PERMS, 8))\n    elif not os.path.isdir(key_path):\n        raise errors.AnsibleError('ACCELERATE_KEYS_DIR is not a directory.')\n\n    if stat.S_IMODE(os.stat(key_path).st_mode) != int(C.ACCELERATE_KEYS_DIR_PERMS, 8):\n        raise errors.AnsibleError('Incorrect permissions on the private key directory. Use `chmod 0%o %s` to correct this issue, and make sure any of the keys files contained within that directory are set to 0%o' % (int(C.ACCELERATE_KEYS_DIR_PERMS, 8), C.ACCELERATE_KEYS_DIR, int(C.ACCELERATE_KEYS_FILE_PERMS, 8)))\n\n    key_path = os.path.join(key_path, hostname)\n\n    # use new AES keys every 2 hours, which means fireball must not allow running for longer either\n    if not os.path.exists(key_path) or (time.time() - os.path.getmtime(key_path) > 60*60*2):\n        key = AesKey.Generate()\n        fd = os.open(key_path, os.O_WRONLY | os.O_CREAT, int(C.ACCELERATE_KEYS_FILE_PERMS, 8))\n        fh = os.fdopen(fd, 'w')\n        fh.write(str(key))\n        fh.close()\n        return key\n    else:\n        if stat.S_IMODE(os.stat(key_path).st_mode) != int(C.ACCELERATE_KEYS_FILE_PERMS, 8):\n            raise errors.AnsibleError('Incorrect permissions on the key file for this host. Use `chmod 0%o %s` to correct this issue.' % (int(C.ACCELERATE_KEYS_FILE_PERMS, 8), key_path))\n        fh = open(key_path)\n        key = AesKey.Read(fh.read())\n        fh.close()\n        return key\n\ndef encrypt(key, msg):\n    return key.Encrypt(msg)\n\ndef decrypt(key, msg):\n    try:\n        return key.Decrypt(msg)\n    except key_errors.InvalidSignatureError:\n        raise errors.AnsibleError(\"decryption failed\")\n\n###############################################################\n# UTILITY FUNCTIONS FOR COMMAND LINE TOOLS\n###############################################################\n\ndef err(msg):\n    ''' print an error message to stderr '''\n\n    print >> sys.stderr, msg\n\ndef exit(msg, rc=1):\n    ''' quit with an error to stdout and a failure code '''\n\n    err(msg)\n    sys.exit(rc)\n\ndef jsonify(result, format=False):\n    ''' format JSON output (uncompressed or uncompressed) '''\n\n    if result is None:\n        return \"{}\"\n    result2 = result.copy()\n    for key, value in result2.items():\n        if type(value) is str:\n            result2[key] = value.decode('utf-8', 'ignore')\n    if format:\n        return json.dumps(result2, sort_keys=True, indent=4)\n    else:\n        return json.dumps(result2, sort_keys=True)\n\ndef write_tree_file(tree, hostname, buf):\n    ''' write something into treedir/hostname '''\n\n    # TODO: might be nice to append playbook runs per host in a similar way\n    # in which case, we'd want append mode.\n    path = os.path.join(tree, hostname)\n    fd = open(path, \"w+\")\n    fd.write(buf)\n    fd.close()\n\ndef is_failed(result):\n    ''' is a given JSON result a failed result? '''\n\n    return ((result.get('rc', 0) != 0) or (result.get('failed', False) in [ True, 'True', 'true']))\n\ndef is_changed(result):\n    ''' is a given JSON result a changed result? '''\n\n    return (result.get('changed', False) in [ True, 'True', 'true'])\n\ndef check_conditional(conditional, basedir, inject, fail_on_undefined=False):\n\n    if conditional is None or conditional == '':\n        return True\n\n    if isinstance(conditional, list):\n        for x in conditional:\n            if not check_conditional(x, basedir, inject, fail_on_undefined=fail_on_undefined):\n                return False\n        return True\n\n    if not isinstance(conditional, basestring):\n        return conditional\n\n    conditional = conditional.replace(\"jinja2_compare \",\"\")\n    # allow variable names\n    if conditional in inject and '-' not in str(inject[conditional]):\n        conditional = inject[conditional]\n    conditional = template.template(basedir, conditional, inject, fail_on_undefined=fail_on_undefined)\n    original = str(conditional).replace(\"jinja2_compare \",\"\")\n    # a Jinja2 evaluation that results in something Python can eval!\n    presented = \"{%% if %s %%} True {%% else %%} False {%% endif %%}\" % conditional\n    conditional = template.template(basedir, presented, inject)\n    val = conditional.strip()\n    if val == presented:\n        # the templating failed, meaning most likely a \n        # variable was undefined. If we happened to be \n        # looking for an undefined variable, return True,\n        # otherwise fail\n        if \"is undefined\" in conditional:\n            return True\n        elif \"is defined\" in conditional:\n            return False\n        else:\n            raise errors.AnsibleError(\"error while evaluating conditional: %s\" % original)\n    elif val == \"True\":\n        return True\n    elif val == \"False\":\n        return False\n    else:\n        raise errors.AnsibleError(\"unable to evaluate conditional: %s\" % original)\n\ndef is_executable(path):\n    '''is the given path executable?'''\n    return (stat.S_IXUSR & os.stat(path)[stat.ST_MODE]\n            or stat.S_IXGRP & os.stat(path)[stat.ST_MODE]\n            or stat.S_IXOTH & os.stat(path)[stat.ST_MODE])\n\ndef unfrackpath(path):\n    ''' \n    returns a path that is free of symlinks, environment\n    variables, relative path traversals and symbols (~)\n    example:\n    '$HOME/../../var/mail' becomes '/var/spool/mail'\n    '''\n    return os.path.normpath(os.path.realpath(os.path.expandvars(os.path.expanduser(path))))\n\ndef prepare_writeable_dir(tree,mode=0777):\n    ''' make sure a directory exists and is writeable '''\n\n    # modify the mode to ensure the owner at least\n    # has read/write access to this directory\n    mode |= 0700\n\n    # make sure the tree path is always expanded\n    # and normalized and free of symlinks\n    tree = unfrackpath(tree)\n\n    if not os.path.exists(tree):\n        try:\n            os.makedirs(tree, mode)\n        except (IOError, OSError), e:\n            raise errors.AnsibleError(\"Could not make dir %s: %s\" % (tree, e))\n    if not os.access(tree, os.W_OK):\n        raise errors.AnsibleError(\"Cannot write to path %s\" % tree)\n    return tree\n\ndef path_dwim(basedir, given):\n    '''\n    make relative paths work like folks expect.\n    '''\n\n    if given.startswith(\"/\"):\n        return os.path.abspath(given)\n    elif given.startswith(\"~\"):\n        return os.path.abspath(os.path.expanduser(given))\n    else:\n        if basedir is None:\n            basedir = \".\"\n        return os.path.abspath(os.path.join(basedir, given))\n\ndef path_dwim_relative(original, dirname, source, playbook_base, check=True):\n    ''' find one file in a directory one level up in a dir named dirname relative to current '''\n    # (used by roles code)\n\n    basedir = os.path.dirname(original)\n    if os.path.islink(basedir):\n        basedir = unfrackpath(basedir)\n        template2 = os.path.join(basedir, dirname, source)\n    else:\n        template2 = os.path.join(basedir, '..', dirname, source)\n    source2 = path_dwim(basedir, template2)\n    if os.path.exists(source2):\n        return source2\n    obvious_local_path = path_dwim(playbook_base, source)\n    if os.path.exists(obvious_local_path):\n        return obvious_local_path\n    if check:\n        raise errors.AnsibleError(\"input file not found at %s or %s\" % (source2, obvious_local_path))\n    return source2 # which does not exist\n\ndef json_loads(data):\n    ''' parse a JSON string and return a data structure '''\n\n    return json.loads(data)\n\ndef parse_json(raw_data):\n    ''' this version for module return data only '''\n\n    orig_data = raw_data\n\n    # ignore stuff like tcgetattr spewage or other warnings\n    data = filter_leading_non_json_lines(raw_data)\n\n    try:\n        return json.loads(data)\n    except:\n        # not JSON, but try \"Baby JSON\" which allows many of our modules to not\n        # require JSON and makes writing modules in bash much simpler\n        results = {}\n        try:\n            tokens = shlex.split(data)\n        except:\n            print \"failed to parse json: \"+ data\n            raise\n\n        for t in tokens:\n            if \"=\" not in t:\n                raise errors.AnsibleError(\"failed to parse: %s\" % orig_data)\n            (key,value) = t.split(\"=\", 1)\n            if key == 'changed' or 'failed':\n                if value.lower() in [ 'true', '1' ]:\n                    value = True\n                elif value.lower() in [ 'false', '0' ]:\n                    value = False\n            if key == 'rc':\n                value = int(value)\n            results[key] = value\n        if len(results.keys()) == 0:\n            return { \"failed\" : True, \"parsed\" : False, \"msg\" : orig_data }\n        return results\n\ndef smush_braces(data):\n    ''' smush Jinaj2 braces so unresolved templates like {{ foo }} don't get parsed weird by key=value code '''\n    while '{{ ' in data:\n        data = data.replace('{{ ', '{{')\n    while ' }}' in data:\n        data = data.replace(' }}', '}}')\n    return data\n\ndef smush_ds(data):\n    # things like key={{ foo }} are not handled by shlex.split well, so preprocess any YAML we load\n    # so we do not have to call smush elsewhere\n    if type(data) == list:\n        return [ smush_ds(x) for x in data ]\n    elif type(data) == dict:\n        for (k,v) in data.items():\n            data[k] = smush_ds(v)\n        return data\n    elif isinstance(data, basestring):\n        return smush_braces(data)\n    else:\n        return data\n\ndef parse_yaml(data, path_hint=None):\n    ''' convert a yaml string to a data structure.  Also supports JSON, ssssssh!!!'''\n\n    stripped_data = data.lstrip()\n    loaded = None\n    if stripped_data.startswith(\"{\") or stripped_data.startswith(\"[\"):\n        # since the line starts with { or [ we can infer this is a JSON document.\n        try:\n            loaded = json.loads(data)\n        except ValueError, ve:\n            if path_hint:\n                raise errors.AnsibleError(path_hint + \": \" + str(ve))\n            else:\n                raise errors.AnsibleError(str(ve))\n    else:\n        # else this is pretty sure to be a YAML document\n        loaded = yaml.safe_load(data)\n\n    return smush_ds(loaded)\n\ndef process_common_errors(msg, probline, column):\n    replaced = probline.replace(\" \",\"\")\n\n    if \":{{\" in replaced and \"}}\" in replaced:\n        msg = msg + \"\"\"\nThis one looks easy to fix.  YAML thought it was looking for the start of a \nhash/dictionary and was confused to see a second \"{\".  Most likely this was\nmeant to be an ansible template evaluation instead, so we have to give the \nparser a small hint that we wanted a string instead. The solution here is to \njust quote the entire value.\n\nFor instance, if the original line was:\n\n    app_path: {{ base_path }}/foo\n\nIt should be written as:\n\n    app_path: \"{{ base_path }}/foo\"\n\"\"\"\n        return msg\n\n    elif len(probline) and len(probline) > 1 and len(probline) > column and probline[column] == \":\" and probline.count(':') > 1:\n        msg = msg + \"\"\"\nThis one looks easy to fix.  There seems to be an extra unquoted colon in the line \nand this is confusing the parser. It was only expecting to find one free \ncolon. The solution is just add some quotes around the colon, or quote the \nentire line after the first colon.\n\nFor instance, if the original line was:\n\n    copy: src=file.txt dest=/path/filename:with_colon.txt\n\nIt can be written as:\n\n    copy: src=file.txt dest='/path/filename:with_colon.txt'\n\nOr:\n    \n    copy: 'src=file.txt dest=/path/filename:with_colon.txt'\n\n\n\"\"\"\n        return msg\n    else:\n        parts = probline.split(\":\")\n        if len(parts) > 1:\n            middle = parts[1].strip()\n            match = False\n            unbalanced = False\n            if middle.startswith(\"'\") and not middle.endswith(\"'\"):\n                match = True\n            elif middle.startswith('\"') and not middle.endswith('\"'):\n                match = True\n            if len(middle) > 0 and middle[0] in [ '\"', \"'\" ] and middle[-1] in [ '\"', \"'\" ] and probline.count(\"'\") > 2 or probline.count('\"') > 2:\n                unbalanced = True\n            if match:\n                msg = msg + \"\"\"\nThis one looks easy to fix.  It seems that there is a value started \nwith a quote, and the YAML parser is expecting to see the line ended \nwith the same kind of quote.  For instance:\n\n    when: \"ok\" in result.stdout\n\nCould be written as:\n\n   when: '\"ok\" in result.stdout'\n\nor equivalently:\n\n   when: \"'ok' in result.stdout\"\n\n\"\"\"\n                return msg\n\n            if unbalanced:\n                msg = msg + \"\"\"\nWe could be wrong, but this one looks like it might be an issue with \nunbalanced quotes.  If starting a value with a quote, make sure the \nline ends with the same set of quotes.  For instance this arbitrary \nexample:\n\n    foo: \"bad\" \"wolf\"\n\nCould be written as:\n\n    foo: '\"bad\" \"wolf\"'\n\n\"\"\"\n                return msg\n\n    return msg\n\ndef process_yaml_error(exc, data, path=None, show_content=True):\n    if hasattr(exc, 'problem_mark'):\n        mark = exc.problem_mark\n        if show_content:\n            if mark.line -1 >= 0:\n                before_probline = data.split(\"\\n\")[mark.line-1]\n            else:\n                before_probline = ''\n            probline = data.split(\"\\n\")[mark.line]\n            arrow = \" \" * mark.column + \"^\"\n            msg = \"\"\"Syntax Error while loading YAML script, %s\nNote: The error may actually appear before this position: line %s, column %s\n\n%s\n%s\n%s\"\"\" % (path, mark.line + 1, mark.column + 1, before_probline, probline, arrow)\n\n            unquoted_var = None\n            if '{{' in probline and '}}' in probline:\n                if '\"{{' not in probline or \"'{{\" not in probline:\n                    unquoted_var = True\n\n            if not unquoted_var:\n                msg = process_common_errors(msg, probline, mark.column)\n            else:\n                msg = msg + \"\"\"\nWe could be wrong, but this one looks like it might be an issue with\nmissing quotes.  Always quote template expression brackets when they \nstart a value. For instance:            \n\n    with_items:\n      - {{ foo }}\n\nShould be written as:\n\n    with_items:\n      - \"{{ foo }}\"      \n\n\"\"\"\n        else:\n            # most likely displaying a file with sensitive content,\n            # so don't show any of the actual lines of yaml just the\n            # line number itself\n            msg = \"\"\"Syntax error while loading YAML script, %s\nThe error appears to have been on line %s, column %s, but may actually\nbe before there depending on the exact syntax problem.\n\"\"\" % (path, mark.line + 1, mark.column + 1)\n\n    else:\n        # No problem markers means we have to throw a generic\n        # \"stuff messed up\" type message. Sry bud.\n        if path:\n            msg = \"Could not parse YAML. Check over %s again.\" % path\n        else:\n            msg = \"Could not parse YAML.\"\n    raise errors.AnsibleYAMLValidationFailed(msg)\n\n\ndef parse_yaml_from_file(path, vault_password=None):\n    ''' convert a yaml file to a data structure '''\n\n    data = None\n    show_content = True\n\n    try:\n        data = open(path).read()\n    except IOError:\n        raise errors.AnsibleError(\"file could not read: %s\" % path)\n\n    vault = VaultLib(password=vault_password)\n    if vault.is_encrypted(data):\n        data = vault.decrypt(data)\n        show_content = False\n\n    try:\n        return parse_yaml(data, path_hint=path)\n    except yaml.YAMLError, exc:\n        process_yaml_error(exc, data, path, show_content)\n\ndef parse_kv(args):\n    ''' convert a string of key/value items to a dict '''\n    options = {}\n    if args is not None:\n        # attempting to split a unicode here does bad things\n        args = args.encode('utf-8')\n        try:\n            vargs = shlex.split(args, posix=True)\n        except ValueError, ve:\n            if 'no closing quotation' in str(ve).lower():\n                raise errors.AnsibleError(\"error parsing argument string, try quoting the entire line.\")\n            else:\n                raise\n        vargs = [x.decode('utf-8') for x in vargs]\n        for x in vargs:\n            if \"=\" in x:\n                k, v = x.split(\"=\",1)\n                options[k]=v\n    return options\n\ndef merge_hash(a, b):\n    ''' recursively merges hash b into a\n    keys from b take precedence over keys from a '''\n\n    result = copy.deepcopy(a)\n\n    # next, iterate over b keys and values\n    for k, v in b.iteritems():\n        # if there's already such key in a\n        # and that key contains dict\n        if k in result and isinstance(result[k], dict):\n            # merge those dicts recursively\n            result[k] = merge_hash(a[k], v)\n        else:\n            # otherwise, just copy a value from b to a\n            result[k] = v\n\n    return result\n\ndef md5s(data):\n    ''' Return MD5 hex digest of data. '''\n\n    digest = _md5()\n    try:\n        digest.update(data)\n    except UnicodeEncodeError:\n        digest.update(data.encode('utf-8'))\n    return digest.hexdigest()\n\ndef md5(filename):\n    ''' Return MD5 hex digest of local file, None if file is not present or a directory. '''\n\n    if not os.path.exists(filename) or os.path.isdir(filename):\n        return None\n    digest = _md5()\n    blocksize = 64 * 1024\n    try:\n        infile = open(filename, 'rb')\n        block = infile.read(blocksize)\n        while block:\n            digest.update(block)\n            block = infile.read(blocksize)\n        infile.close()\n    except IOError, e:\n        raise errors.AnsibleError(\"error while accessing the file %s, error was: %s\" % (filename, e))\n    return digest.hexdigest()\n\ndef default(value, function):\n    ''' syntactic sugar around lazy evaluation of defaults '''\n    if value is None:\n        return function()\n    return value\n\ndef _gitinfo():\n    ''' returns a string containing git branch, commit id and commit date '''\n    result = None\n    repo_path = os.path.join(os.path.dirname(__file__), '..', '..', '..', '.git')\n\n    if os.path.exists(repo_path):\n        # Check if the .git is a file. If it is a file, it means that we are in a submodule structure.\n        if os.path.isfile(repo_path):\n            try:\n                gitdir = yaml.safe_load(open(repo_path)).get('gitdir')\n                # There is a posibility the .git file to have an absolute path.\n                if os.path.isabs(gitdir):\n                    repo_path = gitdir\n                else:\n                    repo_path = os.path.join(repo_path.split('.git')[0], gitdir)\n            except (IOError, AttributeError):\n                return ''\n        f = open(os.path.join(repo_path, \"HEAD\"))\n        branch = f.readline().split('/')[-1].rstrip(\"\\n\")\n        f.close()\n        branch_path = os.path.join(repo_path, \"refs\", \"heads\", branch)\n        if os.path.exists(branch_path):\n            f = open(branch_path)\n            commit = f.readline()[:10]\n            f.close()\n            date = time.localtime(os.stat(branch_path).st_mtime)\n            if time.daylight == 0:\n                offset = time.timezone\n            else:\n                offset = time.altzone\n            result = \"({0} {1}) last updated {2} (GMT {3:+04d})\".format(branch, commit,\n                time.strftime(\"%Y/%m/%d %H:%M:%S\", date), offset / -36)\n    else:\n        result = ''\n    return result\n\ndef version(prog):\n    result = \"{0} {1}\".format(prog, __version__)\n    gitinfo = _gitinfo()\n    if gitinfo:\n        result = result + \" {0}\".format(gitinfo)\n    return result\n\ndef getch():\n    ''' read in a single character '''\n    fd = sys.stdin.fileno()\n    old_settings = termios.tcgetattr(fd)\n    try:\n        tty.setraw(sys.stdin.fileno())\n        ch = sys.stdin.read(1)\n    finally:\n        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n    return ch\n\ndef sanitize_output(str):\n    ''' strips private info out of a string '''\n\n    private_keys = ['password', 'login_password']\n\n    filter_re = [\n        # filter out things like user:pass@foo/whatever\n        # and http://username:pass@wherever/foo\n        re.compile('^(?P<before>.*:)(?P<password>.*)(?P<after>\\@.*)$'),\n    ]\n\n    parts = str.split()\n    output = ''\n    for part in parts:\n        try:\n            (k,v) = part.split('=', 1)\n            if k in private_keys:\n                output += \" %s=VALUE_HIDDEN\" % k\n            else:\n                found = False\n                for filter in filter_re:\n                    m = filter.match(v)\n                    if m:\n                        d = m.groupdict()\n                        output += \" %s=%s\" % (k, d['before'] + \"********\" + d['after'])\n                        found = True\n                        break\n                if not found:\n                    output += \" %s\" % part\n        except:\n            output += \" %s\" % part\n\n    return output.strip()\n\n####################################################################\n# option handling code for /usr/bin/ansible and ansible-playbook\n# below this line\n\nclass SortedOptParser(optparse.OptionParser):\n    '''Optparser which sorts the options by opt before outputting --help'''\n\n    def format_help(self, formatter=None):\n        self.option_list.sort(key=operator.methodcaller('get_opt_string'))\n        return optparse.OptionParser.format_help(self, formatter=None)\n\ndef increment_debug(option, opt, value, parser):\n    global VERBOSITY\n    VERBOSITY += 1\n\ndef base_parser(constants=C, usage=\"\", output_opts=False, runas_opts=False,\n    async_opts=False, connect_opts=False, subset_opts=False, check_opts=False, diff_opts=False):\n    ''' create an options parser for any ansible script '''\n\n    parser = SortedOptParser(usage, version=version(\"%prog\"))\n    parser.add_option('-v','--verbose', default=False, action=\"callback\",\n        callback=increment_debug, help=\"verbose mode (-vvv for more, -vvvv to enable connection debugging)\")\n\n    parser.add_option('-f','--forks', dest='forks', default=constants.DEFAULT_FORKS, type='int',\n        help=\"specify number of parallel processes to use (default=%s)\" % constants.DEFAULT_FORKS)\n    parser.add_option('-i', '--inventory-file', dest='inventory',\n        help=\"specify inventory host file (default=%s)\" % constants.DEFAULT_HOST_LIST,\n        default=constants.DEFAULT_HOST_LIST)\n    parser.add_option('-k', '--ask-pass', default=False, dest='ask_pass', action='store_true',\n        help='ask for SSH password')\n    parser.add_option('--private-key', default=C.DEFAULT_PRIVATE_KEY_FILE, dest='private_key_file',\n        help='use this file to authenticate the connection')\n    parser.add_option('-K', '--ask-sudo-pass', default=False, dest='ask_sudo_pass', action='store_true',\n        help='ask for sudo password')\n    parser.add_option('--ask-su-pass', default=False, dest='ask_su_pass', action='store_true', \n        help='ask for su password')\n    parser.add_option('--ask-vault-pass', default=False, dest='ask_vault_pass', action='store_true', \n        help='ask for vault password')\n    parser.add_option('--vault-password-file', default=None, dest='vault_password_file',\n        help=\"vault password file\")\n    parser.add_option('--list-hosts', dest='listhosts', action='store_true',\n        help='outputs a list of matching hosts; does not execute anything else')\n    parser.add_option('-M', '--module-path', dest='module_path',\n        help=\"specify path(s) to module library (default=%s)\" % constants.DEFAULT_MODULE_PATH,\n        default=None)\n\n    if subset_opts:\n        parser.add_option('-l', '--limit', default=constants.DEFAULT_SUBSET, dest='subset',\n            help='further limit selected hosts to an additional pattern')\n\n    parser.add_option('-T', '--timeout', default=constants.DEFAULT_TIMEOUT, type='int',\n        dest='timeout',\n        help=\"override the SSH timeout in seconds (default=%s)\" % constants.DEFAULT_TIMEOUT)\n\n    if output_opts:\n        parser.add_option('-o', '--one-line', dest='one_line', action='store_true',\n            help='condense output')\n        parser.add_option('-t', '--tree', dest='tree', default=None,\n            help='log output to this directory')\n\n    if runas_opts:\n        parser.add_option(\"-s\", \"--sudo\", default=constants.DEFAULT_SUDO, action=\"store_true\",\n            dest='sudo', help=\"run operations with sudo (nopasswd)\")\n        parser.add_option('-U', '--sudo-user', dest='sudo_user', default=None,\n                          help='desired sudo user (default=root)')  # Can't default to root because we need to detect when this option was given\n        parser.add_option('-u', '--user', default=constants.DEFAULT_REMOTE_USER,\n            dest='remote_user', help='connect as this user (default=%s)' % constants.DEFAULT_REMOTE_USER)\n\n        parser.add_option('-S', '--su', default=constants.DEFAULT_SU,\n                          action='store_true', help='run operations with su')\n        parser.add_option('-R', '--su-user', help='run operations with su as this '\n                                                  'user (default=%s)' % constants.DEFAULT_SU_USER)\n\n    if connect_opts:\n        parser.add_option('-c', '--connection', dest='connection',\n                          default=C.DEFAULT_TRANSPORT,\n                          help=\"connection type to use (default=%s)\" % C.DEFAULT_TRANSPORT)\n\n    if async_opts:\n        parser.add_option('-P', '--poll', default=constants.DEFAULT_POLL_INTERVAL, type='int',\n            dest='poll_interval',\n            help=\"set the poll interval if using -B (default=%s)\" % constants.DEFAULT_POLL_INTERVAL)\n        parser.add_option('-B', '--background', dest='seconds', type='int', default=0,\n            help='run asynchronously, failing after X seconds (default=N/A)')\n\n    if check_opts:\n        parser.add_option(\"-C\", \"--check\", default=False, dest='check', action='store_true',\n            help=\"don't make any changes; instead, try to predict some of the changes that may occur\"\n        )\n\n    if diff_opts:\n        parser.add_option(\"-D\", \"--diff\", default=False, dest='diff', action='store_true',\n            help=\"when changing (small) files and templates, show the differences in those files; works great with --check\"\n        )\n\n\n    return parser\n\ndef ask_vault_passwords(ask_vault_pass=False, ask_new_vault_pass=False, confirm_vault=False, confirm_new=False):\n\n    vault_pass = None\n    new_vault_pass = None\n\n    if ask_vault_pass:\n        vault_pass = getpass.getpass(prompt=\"Vault password: \")\n\n    if ask_vault_pass and confirm_vault:\n        vault_pass2 = getpass.getpass(prompt=\"Confirm Vault password: \")\n        if vault_pass != vault_pass2:\n            raise errors.AnsibleError(\"Passwords do not match\")\n\n    if ask_new_vault_pass:\n        new_vault_pass = getpass.getpass(prompt=\"New Vault password: \")\n\n    if ask_new_vault_pass and confirm_new:\n        new_vault_pass2 = getpass.getpass(prompt=\"Confirm New Vault password: \")\n        if new_vault_pass != new_vault_pass2:\n            raise errors.AnsibleError(\"Passwords do not match\")\n\n    # enforce no newline chars at the end of passwords\n    if vault_pass:\n        vault_pass = vault_pass.strip()\n    if new_vault_pass:\n        new_vault_pass = new_vault_pass.strip()\n\n    return vault_pass, new_vault_pass\n\ndef ask_passwords(ask_pass=False, ask_sudo_pass=False, ask_su_pass=False, ask_vault_pass=False):\n    sshpass = None\n    sudopass = None\n    su_pass = None\n    vault_pass = None\n    sudo_prompt = \"sudo password: \"\n    su_prompt = \"su password: \"\n\n    if ask_pass:\n        sshpass = getpass.getpass(prompt=\"SSH password: \")\n        sudo_prompt = \"sudo password [defaults to SSH password]: \"\n\n    if ask_sudo_pass:\n        sudopass = getpass.getpass(prompt=sudo_prompt)\n        if ask_pass and sudopass == '':\n            sudopass = sshpass\n\n    if ask_su_pass:\n        su_pass = getpass.getpass(prompt=su_prompt)\n\n    if ask_vault_pass:\n        vault_pass = getpass.getpass(prompt=\"Vault password: \")\n\n    return (sshpass, sudopass, su_pass, vault_pass)\n\ndef do_encrypt(result, encrypt, salt_size=None, salt=None):\n    if PASSLIB_AVAILABLE:\n        try:\n            crypt = getattr(passlib.hash, encrypt)\n        except:\n            raise errors.AnsibleError(\"passlib does not support '%s' algorithm\" % encrypt)\n\n        if salt_size:\n            result = crypt.encrypt(result, salt_size=salt_size)\n        elif salt:\n            result = crypt.encrypt(result, salt=salt)\n        else:\n            result = crypt.encrypt(result)\n    else:\n        raise errors.AnsibleError(\"passlib must be installed to encrypt vars_prompt values\")\n\n    return result\n\ndef last_non_blank_line(buf):\n\n    all_lines = buf.splitlines()\n    all_lines.reverse()\n    for line in all_lines:\n        if (len(line) > 0):\n            return line\n    # shouldn't occur unless there's no output\n    return \"\"\n\ndef filter_leading_non_json_lines(buf):\n    '''\n    used to avoid random output from SSH at the top of JSON output, like messages from\n    tcagetattr, or where dropbear spews MOTD on every single command (which is nuts).\n\n    need to filter anything which starts not with '{', '[', ', '=' or is an empty line.\n    filter only leading lines since multiline JSON is valid.\n    '''\n\n    kv_regex = re.compile(r'.*\\w+=\\w+.*')\n    filtered_lines = StringIO.StringIO()\n    stop_filtering = False\n    for line in buf.splitlines():\n        if stop_filtering or kv_regex.match(line) or line.startswith('{') or line.startswith('['):\n            stop_filtering = True\n            filtered_lines.write(line + '\\n')\n    return filtered_lines.getvalue()\n\ndef boolean(value):\n    val = str(value)\n    if val.lower() in [ \"true\", \"t\", \"y\", \"1\", \"yes\" ]:\n        return True\n    else:\n        return False\n\ndef make_sudo_cmd(sudo_user, executable, cmd):\n    \"\"\"\n    helper function for connection plugins to create sudo commands\n    \"\"\"\n    # Rather than detect if sudo wants a password this time, -k makes\n    # sudo always ask for a password if one is required.\n    # Passing a quoted compound command to sudo (or sudo -s)\n    # directly doesn't work, so we shellquote it with pipes.quote()\n    # and pass the quoted string to the user's shell.  We loop reading\n    # output until we see the randomly-generated sudo prompt set with\n    # the -p option.\n    randbits = ''.join(chr(random.randint(ord('a'), ord('z'))) for x in xrange(32))\n    prompt = '[sudo via ansible, key=%s] password: ' % randbits\n    success_key = 'SUDO-SUCCESS-%s' % randbits\n    sudocmd = '%s -k && %s %s -S -p \"%s\" -u %s %s -c %s' % (\n        C.DEFAULT_SUDO_EXE, C.DEFAULT_SUDO_EXE, C.DEFAULT_SUDO_FLAGS,\n        prompt, sudo_user, executable or '$SHELL', pipes.quote('echo %s; %s' % (success_key, cmd)))\n    return ('/bin/sh -c ' + pipes.quote(sudocmd), prompt, success_key)\n\n\ndef make_su_cmd(su_user, executable, cmd):\n    \"\"\"\n    Helper function for connection plugins to create direct su commands\n    \"\"\"\n    # TODO: work on this function\n    randbits = ''.join(chr(random.randint(ord('a'), ord('z'))) for x in xrange(32))\n    prompt = '[Pp]assword: ?$'\n    success_key = 'SUDO-SUCCESS-%s' % randbits\n    sudocmd = '%s %s %s -c \"%s -c %s\"' % (\n        C.DEFAULT_SU_EXE, C.DEFAULT_SU_FLAGS, su_user, executable or '$SHELL',\n        pipes.quote('echo %s; %s' % (success_key, cmd))\n    )\n    return ('/bin/sh -c ' + pipes.quote(sudocmd), prompt, success_key)\n\n_TO_UNICODE_TYPES = (unicode, type(None))\n\ndef to_unicode(value):\n    if isinstance(value, _TO_UNICODE_TYPES):\n        return value\n    return value.decode(\"utf-8\")\n\ndef get_diff(diff):\n    # called by --diff usage in playbook and runner via callbacks\n    # include names in diffs 'before' and 'after' and do diff -U 10\n\n    try:\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore')\n            ret = []\n            if 'dst_binary' in diff:\n                ret.append(\"diff skipped: destination file appears to be binary\\n\")\n            if 'src_binary' in diff:\n                ret.append(\"diff skipped: source file appears to be binary\\n\")\n            if 'dst_larger' in diff:\n                ret.append(\"diff skipped: destination file size is greater than %d\\n\" % diff['dst_larger'])\n            if 'src_larger' in diff:\n                ret.append(\"diff skipped: source file size is greater than %d\\n\" % diff['src_larger'])\n            if 'before' in diff and 'after' in diff:\n                if 'before_header' in diff:\n                    before_header = \"before: %s\" % diff['before_header']\n                else:\n                    before_header = 'before'\n                if 'after_header' in diff:\n                    after_header = \"after: %s\" % diff['after_header']\n                else:\n                    after_header = 'after'\n                differ = difflib.unified_diff(to_unicode(diff['before']).splitlines(True), to_unicode(diff['after']).splitlines(True), before_header, after_header, '', '', 10)\n                for line in list(differ):\n                    ret.append(line)\n            return u\"\".join(ret)\n    except UnicodeDecodeError:\n        return \">> the files are different, but the diff library cannot compare unicode strings\"\n\ndef is_list_of_strings(items):\n    for x in items:\n        if not isinstance(x, basestring):\n            return False\n    return True\n\ndef list_union(a, b):\n    result = []\n    for x in a:\n        if x not in result:\n            result.append(x)\n    for x in b:\n        if x not in result:\n            result.append(x)\n    return result\n\ndef list_intersection(a, b):\n    result = []\n    for x in a:\n        if x in b and x not in result:\n            result.append(x)\n    return result\n\ndef safe_eval(expr, locals={}, include_exceptions=False):\n    '''\n    this is intended for allowing things like:\n    with_items: a_list_variable\n    where Jinja2 would return a string\n    but we do not want to allow it to call functions (outside of Jinja2, where\n    the env is constrained)\n\n    Based on:\n    http://stackoverflow.com/questions/12523516/using-ast-and-whitelists-to-make-pythons-eval-safe\n    '''\n\n    # this is the whitelist of AST nodes we are going to \n    # allow in the evaluation. Any node type other than \n    # those listed here will raise an exception in our custom\n    # visitor class defined below.\n    SAFE_NODES = set(\n        (\n            ast.Add,\n            ast.BinOp,\n            ast.Call,\n            ast.Compare,\n            ast.Dict,\n            ast.Div,\n            ast.Expression,\n            ast.List,\n            ast.Load,\n            ast.Mult,\n            ast.Num,\n            ast.Name,\n            ast.Str,\n            ast.Sub,\n            ast.Tuple,\n            ast.UnaryOp,\n        )\n    )\n\n    # AST node types were expanded after 2.6\n    if not sys.version.startswith('2.6'):\n        SAFE_NODES.union(\n            set(\n                (ast.Set,)\n            )\n        )\n\n    filter_list = []\n    for filter in filter_loader.all():\n        filter_list.extend(filter.filters().keys())\n\n    CALL_WHITELIST = C.DEFAULT_CALLABLE_WHITELIST + filter_list\n\n    class CleansingNodeVisitor(ast.NodeVisitor):\n        def generic_visit(self, node, inside_call=False):\n            if type(node) not in SAFE_NODES:\n                raise Exception(\"invalid expression (%s)\" % expr)\n            elif isinstance(node, ast.Call):\n                inside_call = True\n            elif isinstance(node, ast.Name) and inside_call:\n                if hasattr(builtin, node.id) and node.id not in CALL_WHITELIST:\n                    raise Exception(\"invalid function: %s\" % node.id)\n            # iterate over all child nodes\n            for child_node in ast.iter_child_nodes(node):\n                self.generic_visit(child_node, inside_call)\n\n    if not isinstance(expr, basestring):\n        # already templated to a datastructure, perhaps?\n        if include_exceptions:\n            return (expr, None)\n        return expr\n\n    cnv = CleansingNodeVisitor()\n    try:\n        parsed_tree = ast.parse(expr, mode='eval')\n        cnv.visit(parsed_tree)\n        compiled = compile(parsed_tree, expr, 'eval')\n        result = eval(compiled, {}, locals)\n\n        if include_exceptions:\n            return (result, None)\n        else:\n            return result\n    except SyntaxError, e:\n        # special handling for syntax errors, we just return\n        # the expression string back as-is\n        if include_exceptions:\n            return (expr, None)\n        return expr\n    except Exception, e:\n        if include_exceptions:\n            return (expr, e)\n        return expr\n\n\ndef listify_lookup_plugin_terms(terms, basedir, inject):\n\n    if isinstance(terms, basestring):\n        # someone did:\n        #    with_items: alist\n        # OR\n        #    with_items: {{ alist }}\n\n        stripped = terms.strip()\n        if not (stripped.startswith('{') or stripped.startswith('[')) and not stripped.startswith(\"/\") and not stripped.startswith('set(['):\n            # if not already a list, get ready to evaluate with Jinja2\n            # not sure why the \"/\" is in above code :)\n            try:\n                new_terms = template.template(basedir, \"{{ %s }}\" % terms, inject)\n                if isinstance(new_terms, basestring) and \"{{\" in new_terms:\n                    pass\n                else:\n                    terms = new_terms\n            except:\n                pass\n\n        if '{' in terms or '[' in terms:\n            # Jinja2 already evaluated a variable to a list.\n            # Jinja2-ified list needs to be converted back to a real type\n            # TODO: something a bit less heavy than eval\n            return safe_eval(terms)\n\n        if isinstance(terms, basestring):\n            terms = [ terms ]\n\n    return terms\n\ndef combine_vars(a, b):\n\n    if C.DEFAULT_HASH_BEHAVIOUR == \"merge\":\n        return merge_hash(a, b)\n    else:\n        return dict(a.items() + b.items())\n\ndef random_password(length=20, chars=C.DEFAULT_PASSWORD_CHARS):\n    '''Return a random password string of length containing only chars.'''\n\n    password = []\n    while len(password) < length:\n        new_char = os.urandom(1)\n        if new_char in chars:\n            password.append(new_char)\n\n    return ''.join(password)\n\ndef before_comment(msg):\n    ''' what's the part of a string before a comment? '''\n    msg = msg.replace(\"\\#\",\"**NOT_A_COMMENT**\")\n    msg = msg.split(\"#\")[0]\n    msg = msg.replace(\"**NOT_A_COMMENT**\",\"#\")\n    return msg\n\n\n\n", "# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport re\nimport codecs\nimport jinja2\nfrom jinja2.runtime import StrictUndefined\nfrom jinja2.exceptions import TemplateSyntaxError\nimport yaml\nimport json\nfrom ansible import errors\nimport ansible.constants as C\nimport time\nimport subprocess\nimport datetime\nimport pwd\nimport ast\nimport traceback\n\nfrom ansible.utils.string_functions import count_newlines_from_end\n\nclass Globals(object):\n\n    FILTERS = None\n\n    def __init__(self):\n        pass\n\ndef _get_filters():\n    ''' return filter plugin instances '''\n\n    if Globals.FILTERS is not None:\n        return Globals.FILTERS\n\n    from ansible import utils\n    plugins = [ x for x in utils.plugins.filter_loader.all()]\n    filters = {}\n    for fp in plugins:\n        filters.update(fp.filters())\n    Globals.FILTERS = filters\n\n    return Globals.FILTERS\n\ndef _get_extensions():\n    ''' return jinja2 extensions to load '''\n\n    '''\n    if some extensions are set via jinja_extensions in ansible.cfg, we try\n    to load them with the jinja environment\n    '''\n    jinja_exts = []\n    if C.DEFAULT_JINJA2_EXTENSIONS:\n        '''\n        Let's make sure the configuration directive doesn't contain spaces\n        and split extensions in an array\n        '''\n        jinja_exts = C.DEFAULT_JINJA2_EXTENSIONS.replace(\" \", \"\").split(',')\n\n    return jinja_exts\n\nclass Flags:\n    LEGACY_TEMPLATE_WARNING = False\n\n# TODO: refactor this file\n\nFILTER_PLUGINS = None\n_LISTRE = re.compile(r\"(\\w+)\\[(\\d+)\\]\")\nJINJA2_OVERRIDE='#jinja2:'\n\ndef lookup(name, *args, **kwargs):\n    from ansible import utils\n    instance = utils.plugins.lookup_loader.get(name.lower(), basedir=kwargs.get('basedir',None))\n    vars = kwargs.get('vars', None)\n\n    if instance is not None:\n        # safely catch run failures per #5059\n        try:\n            ran = instance.run(*args, inject=vars, **kwargs)\n        except errors.AnsibleError:\n            # Plugin raised this on purpose\n            raise\n        except Exception, e:\n            ran = None\n        if ran:\n            ran = \",\".join(ran)\n        return ran\n    else:\n        raise errors.AnsibleError(\"lookup plugin (%s) not found\" % name)\n\ndef template(basedir, varname, vars, lookup_fatal=True, depth=0, expand_lists=True, convert_bare=False, fail_on_undefined=False, filter_fatal=True):\n    ''' templates a data structure by traversing it and substituting for other data structures '''\n    from ansible import utils\n\n    try:\n        if convert_bare and isinstance(varname, basestring):\n            first_part = varname.split(\".\")[0].split(\"[\")[0]\n            if first_part in vars and '{{' not in varname and '$' not in varname:\n                varname = \"{{%s}}\" % varname\n    \n        if isinstance(varname, basestring):\n            if '{{' in varname or '{%' in varname:\n                varname = template_from_string(basedir, varname, vars, fail_on_undefined)\n\n                if (varname.startswith(\"{\") and not varname.startswith(\"{{\")) or varname.startswith(\"[\"):\n                    eval_results = utils.safe_eval(varname, locals=vars, include_exceptions=True)\n                    if eval_results[1] is None:\n                        varname = eval_results[0]\n\n            return varname\n    \n        elif isinstance(varname, (list, tuple)):\n            return [template(basedir, v, vars, lookup_fatal, depth, expand_lists, fail_on_undefined=fail_on_undefined) for v in varname]\n        elif isinstance(varname, dict):\n            d = {}\n            for (k, v) in varname.iteritems():\n                d[k] = template(basedir, v, vars, lookup_fatal, depth, expand_lists, fail_on_undefined=fail_on_undefined)\n            return d\n        else:\n            return varname\n    except errors.AnsibleFilterError:\n        if filter_fatal:\n            raise\n        else:\n            return varname\n\n\nclass _jinja2_vars(object):\n    '''\n    Helper class to template all variable content before jinja2 sees it.\n    This is done by hijacking the variable storage that jinja2 uses, and\n    overriding __contains__ and __getitem__ to look like a dict. Added bonus\n    is avoiding duplicating the large hashes that inject tends to be.\n    To facilitate using builtin jinja2 things like range, globals are handled\n    here.\n    extras is a list of locals to also search for variables.\n    '''\n\n    def __init__(self, basedir, vars, globals, fail_on_undefined, *extras):\n        self.basedir = basedir\n        self.vars = vars\n        self.globals = globals\n        self.fail_on_undefined = fail_on_undefined\n        self.extras = extras\n\n    def __contains__(self, k):\n        if k in self.vars:\n            return True\n        for i in self.extras:\n            if k in i:\n                return True\n        if k in self.globals:\n            return True\n        return False\n\n    def __getitem__(self, varname):\n        if varname not in self.vars:\n            for i in self.extras:\n                if varname in i:\n                    return i[varname]\n            if varname in self.globals:\n                return self.globals[varname]\n            else:\n                raise KeyError(\"undefined variable: %s\" % varname)\n        var = self.vars[varname]\n        # HostVars is special, return it as-is\n        if isinstance(var, dict) and type(var) != dict:\n            return var\n        else:\n            return template(self.basedir, var, self.vars, fail_on_undefined=self.fail_on_undefined)\n\n    def add_locals(self, locals):\n        '''\n        If locals are provided, create a copy of self containing those\n        locals in addition to what is already in this variable proxy.\n        '''\n        if locals is None:\n            return self\n        return _jinja2_vars(self.basedir, self.vars, self.globals, self.fail_on_undefined, locals, *self.extras)\n\nclass J2Template(jinja2.environment.Template):\n    '''\n    This class prevents Jinja2 from running _jinja2_vars through dict()\n    Without this, {% include %} and similar will create new contexts unlike\n    the special one created in template_from_file. This ensures they are all\n    alike, with the exception of potential locals.\n    '''\n    def new_context(self, vars=None, shared=False, locals=None):\n        return jinja2.runtime.Context(self.environment, vars.add_locals(locals), self.name, self.blocks)\n\ndef template_from_file(basedir, path, vars, vault_password=None):\n    ''' run a file through the templating engine '''\n\n    fail_on_undefined = C.DEFAULT_UNDEFINED_VAR_BEHAVIOR\n\n    from ansible import utils\n    realpath = utils.path_dwim(basedir, path)\n    loader=jinja2.FileSystemLoader([basedir,os.path.dirname(realpath)])\n\n    def my_lookup(*args, **kwargs):\n        kwargs['vars'] = vars\n        return lookup(*args, basedir=basedir, **kwargs)\n    def my_finalize(thing):\n        return thing if thing is not None else ''\n\n    environment = jinja2.Environment(loader=loader, trim_blocks=True, extensions=_get_extensions())\n    environment.filters.update(_get_filters())\n    environment.globals['lookup'] = my_lookup\n    environment.globals['finalize'] = my_finalize\n    if fail_on_undefined:\n        environment.undefined = StrictUndefined\n\n    try:\n        data = codecs.open(realpath, encoding=\"utf8\").read()\n    except UnicodeDecodeError:\n        raise errors.AnsibleError(\"unable to process as utf-8: %s\" % realpath)\n    except:\n        raise errors.AnsibleError(\"unable to read %s\" % realpath)\n\n\n    # Get jinja env overrides from template\n    if data.startswith(JINJA2_OVERRIDE):\n        eol = data.find('\\n')\n        line = data[len(JINJA2_OVERRIDE):eol]\n        data = data[eol+1:]\n        for pair in line.split(','):\n            (key,val) = pair.split(':')\n            setattr(environment,key.strip(),ast.literal_eval(val.strip()))\n\n    environment.template_class = J2Template\n    try:\n        t = environment.from_string(data)\n    except TemplateSyntaxError, e:\n        # Throw an exception which includes a more user friendly error message\n        values = {'name': realpath, 'lineno': e.lineno, 'error': str(e)}\n        msg = 'file: %(name)s, line number: %(lineno)s, error: %(error)s' % \\\n               values\n        error = errors.AnsibleError(msg)\n        raise error\n    vars = vars.copy()\n    try:\n        template_uid = pwd.getpwuid(os.stat(realpath).st_uid).pw_name\n    except:\n        template_uid = os.stat(realpath).st_uid\n    vars['template_host']   = os.uname()[1]\n    vars['template_path']   = realpath\n    vars['template_mtime']  = datetime.datetime.fromtimestamp(os.path.getmtime(realpath))\n    vars['template_uid']    = template_uid\n    vars['template_fullpath'] = os.path.abspath(realpath)\n    vars['template_run_date'] = datetime.datetime.now()\n\n    managed_default = C.DEFAULT_MANAGED_STR\n    managed_str = managed_default.format(\n        host = vars['template_host'],\n        uid  = vars['template_uid'],\n        file = vars['template_path']\n    )\n    vars['ansible_managed'] = time.strftime(\n        managed_str,\n        time.localtime(os.path.getmtime(realpath))\n    )\n\n    # This line performs deep Jinja2 magic that uses the _jinja2_vars object for vars\n    # Ideally, this could use some API where setting shared=True and the object won't get\n    # passed through dict(o), but I have not found that yet.\n    try:\n        res = jinja2.utils.concat(t.root_render_func(t.new_context(_jinja2_vars(basedir, vars, t.globals, fail_on_undefined), shared=True)))\n    except jinja2.exceptions.UndefinedError, e:\n        raise errors.AnsibleUndefinedVariable(\"One or more undefined variables: %s\" % str(e))\n    except jinja2.exceptions.TemplateNotFound, e:\n        # Throw an exception which includes a more user friendly error message\n        # This likely will happen for included sub-template. Not that besides\n        # pure \"file not found\" it may happen due to Jinja2's \"security\"\n        # checks on path.\n        values = {'name': realpath, 'subname': str(e)}\n        msg = 'file: %(name)s, error: Cannot find/not allowed to load (include) template %(subname)s' % \\\n               values\n        error = errors.AnsibleError(msg)\n        raise error\n\n    # The low level calls above do not preserve the newline\n    # characters at the end of the input data, so we use the\n    # calculate the difference in newlines and append them \n    # to the resulting output for parity\n    res_newlines  = count_newlines_from_end(res)\n    data_newlines = count_newlines_from_end(data)\n    if data_newlines > res_newlines:\n        res += '\\n' * (data_newlines - res_newlines)\n\n    if isinstance(res, unicode):\n        # do not try to re-template a unicode string\n        result = res\n    else:\n        result = template(basedir, res, vars)\n\n    return result\n\ndef template_from_string(basedir, data, vars, fail_on_undefined=False):\n    ''' run a string through the (Jinja2) templating engine '''\n\n    try:\n        if type(data) == str:\n            data = unicode(data, 'utf-8')\n\n        def my_finalize(thing):\n            return thing if thing is not None else ''\n\n        environment = jinja2.Environment(trim_blocks=True, undefined=StrictUndefined, extensions=_get_extensions(), finalize=my_finalize)\n        environment.filters.update(_get_filters())\n        environment.template_class = J2Template\n\n        if '_original_file' in vars:\n            basedir = os.path.dirname(vars['_original_file'])\n            filesdir = os.path.abspath(os.path.join(basedir, '..', 'files'))\n            if os.path.exists(filesdir):\n                basedir = filesdir\n\n        # 6227\n        if isinstance(data, unicode):\n            try:\n                data = data.decode('utf-8')\n            except UnicodeEncodeError, e:\n                pass\n\n        try:\n            t = environment.from_string(data)\n        except Exception, e:\n            if 'recursion' in str(e):\n                raise errors.AnsibleError(\"recursive loop detected in template string: %s\" % data)\n            else:\n                return data\n\n        def my_lookup(*args, **kwargs):\n            kwargs['vars'] = vars\n            return lookup(*args, basedir=basedir, **kwargs)\n\n        t.globals['lookup'] = my_lookup\n        t.globals['finalize'] = my_finalize\n        jvars =_jinja2_vars(basedir, vars, t.globals, fail_on_undefined)\n        new_context = t.new_context(jvars, shared=True)\n        rf = t.root_render_func(new_context)\n        try:\n            res = jinja2.utils.concat(rf)\n        except TypeError, te:\n            if 'StrictUndefined' in str(te):\n                raise errors.AnsibleUndefinedVariable(\n                    \"Unable to look up a name or access an attribute in template string. \" + \\\n                    \"Make sure your variable name does not contain invalid characters like '-'.\"\n                )\n            else:\n                raise errors.AnsibleError(\"an unexpected type error occured. Error was %s\" % te)\n        return res\n    except (jinja2.exceptions.UndefinedError, errors.AnsibleUndefinedVariable):\n        if fail_on_undefined:\n            raise\n        else:\n            return data\n\n"], "fixing_code": ["# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n#############################################\n\nimport os\nimport subprocess\nimport ansible.constants as C\nfrom ansible.inventory.host import Host\nfrom ansible.inventory.group import Group\nfrom ansible import utils\nfrom ansible import errors\nimport sys\n\nclass InventoryScript(object):\n    ''' Host inventory parser for ansible using external inventory scripts. '''\n\n    def __init__(self, filename=C.DEFAULT_HOST_LIST):\n\n        # Support inventory scripts that are not prefixed with some\n        # path information but happen to be in the current working\n        # directory when '.' is not in PATH.\n        self.filename = os.path.abspath(filename)\n        cmd = [ self.filename, \"--list\" ]\n        try:\n            sp = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        except OSError, e:\n            raise errors.AnsibleError(\"problem running %s (%s)\" % (' '.join(cmd), e))\n        (stdout, stderr) = sp.communicate()\n        self.data = stdout\n        # see comment about _meta below\n        self.host_vars_from_top = None\n        self.groups = self._parse(stderr)\n\n    def _parse(self, err):\n\n        all_hosts = {}\n        self.raw  = utils.parse_json(self.data, from_remote=True)\n        all       = Group('all')\n        groups    = dict(all=all)\n        group     = None\n\n\n        if 'failed' in self.raw:\n            sys.stderr.write(err + \"\\n\")\n            raise errors.AnsibleError(\"failed to parse executable inventory script results: %s\" % self.raw)\n\n        for (group_name, data) in self.raw.items():\n \n            # in Ansible 1.3 and later, a \"_meta\" subelement may contain\n            # a variable \"hostvars\" which contains a hash for each host\n            # if this \"hostvars\" exists at all then do not call --host for each\n            # host.  This is for efficiency and scripts should still return data\n            # if called with --host for backwards compat with 1.2 and earlier.\n\n            if group_name == '_meta':\n                if 'hostvars' in data:\n                    self.host_vars_from_top = data['hostvars']\n                    continue\n\n            if group_name != all.name:\n                group = groups[group_name] = Group(group_name)\n            else:\n                group = all\n            host = None\n\n            if not isinstance(data, dict):\n                data = {'hosts': data}\n            elif not any(k in data for k in ('hosts','vars')):\n                data = {'hosts': [group_name], 'vars': data}\n\n            if 'hosts' in data:\n\n                for hostname in data['hosts']:\n                    if not hostname in all_hosts:\n                        all_hosts[hostname] = Host(hostname)\n                    host = all_hosts[hostname]\n                    group.add_host(host)\n\n            if 'vars' in data:\n                for k, v in data['vars'].iteritems():\n                    if group.name == all.name:\n                        all.set_variable(k, v)\n                    else:\n                        group.set_variable(k, v)\n            if group.name != all.name:\n                all.add_child_group(group)\n\n        # Separate loop to ensure all groups are defined\n        for (group_name, data) in self.raw.items():\n            if group_name == '_meta':\n                continue\n            if isinstance(data, dict) and 'children' in data:\n                for child_name in data['children']:\n                    if child_name in groups:\n                        groups[group_name].add_child_group(groups[child_name])\n        return groups\n\n    def get_host_variables(self, host):\n        \"\"\" Runs <script> --host <hostname> to determine additional host variables \"\"\"\n        if self.host_vars_from_top is not None:\n            got = self.host_vars_from_top.get(host.name, {})\n            return got\n\n\n        cmd = [self.filename, \"--host\", host.name]\n        try:\n            sp = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        except OSError, e:\n            raise errors.AnsibleError(\"problem running %s (%s)\" % (' '.join(cmd), e))\n        (out, err) = sp.communicate()\n        return utils.parse_json(out)\n", "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport multiprocessing\nimport signal\nimport os\nimport pwd\nimport Queue\nimport random\nimport traceback\nimport tempfile\nimport time\nimport collections\nimport socket\nimport base64\nimport sys\nimport pipes\nimport jinja2\nimport subprocess\nimport getpass\n\nimport ansible.constants as C\nimport ansible.inventory\nfrom ansible import utils\nfrom ansible.utils import template\nfrom ansible.utils import check_conditional\nfrom ansible.utils import string_functions\nfrom ansible import errors\nfrom ansible import module_common\nimport poller\nimport connection\nfrom return_data import ReturnData\nfrom ansible.callbacks import DefaultRunnerCallbacks, vv\nfrom ansible.module_common import ModuleReplacer\n\nmodule_replacer = ModuleReplacer(strip_comments=False)\n\nHAS_ATFORK=True\ntry:\n    from Crypto.Random import atfork\nexcept ImportError:\n    HAS_ATFORK=False\n\nmultiprocessing_runner = None\n        \nOUTPUT_LOCKFILE  = tempfile.TemporaryFile()\nPROCESS_LOCKFILE = tempfile.TemporaryFile()\n\n################################################\n\ndef _executor_hook(job_queue, result_queue, new_stdin):\n\n    # attempt workaround of https://github.com/newsapps/beeswithmachineguns/issues/17\n    # this function also not present in CentOS 6\n    if HAS_ATFORK:\n        atfork()\n\n    signal.signal(signal.SIGINT, signal.SIG_IGN)\n    while not job_queue.empty():\n        try:\n            host = job_queue.get(block=False)\n            return_data = multiprocessing_runner._executor(host, new_stdin)\n            result_queue.put(return_data)\n        except Queue.Empty:\n            pass\n        except:\n            traceback.print_exc()\n\nclass HostVars(dict):\n    ''' A special view of vars_cache that adds values from the inventory when needed. '''\n\n    def __init__(self, vars_cache, inventory, vault_password=None):\n        self.vars_cache = vars_cache\n        self.inventory = inventory\n        self.lookup = dict()\n        self.update(vars_cache)\n        self.vault_password = vault_password\n\n    def __getitem__(self, host):\n        if host not in self.lookup:\n            result = self.inventory.get_variables(host, vault_password=self.vault_password).copy()\n            result.update(self.vars_cache.get(host, {}))\n            self.lookup[host] = result\n        return self.lookup[host]\n\n\nclass Runner(object):\n    ''' core API interface to ansible '''\n\n    # see bin/ansible for how this is used...\n\n    def __init__(self,\n        host_list=C.DEFAULT_HOST_LIST,      # ex: /etc/ansible/hosts, legacy usage\n        module_path=None,                   # ex: /usr/share/ansible\n        module_name=C.DEFAULT_MODULE_NAME,  # ex: copy\n        module_args=C.DEFAULT_MODULE_ARGS,  # ex: \"src=/tmp/a dest=/tmp/b\"\n        forks=C.DEFAULT_FORKS,              # parallelism level\n        timeout=C.DEFAULT_TIMEOUT,          # SSH timeout\n        pattern=C.DEFAULT_PATTERN,          # which hosts?  ex: 'all', 'acme.example.org'\n        remote_user=C.DEFAULT_REMOTE_USER,  # ex: 'username'\n        remote_pass=C.DEFAULT_REMOTE_PASS,  # ex: 'password123' or None if using key\n        remote_port=None,                   # if SSH on different ports\n        private_key_file=C.DEFAULT_PRIVATE_KEY_FILE, # if not using keys/passwords\n        sudo_pass=C.DEFAULT_SUDO_PASS,      # ex: 'password123' or None\n        background=0,                       # async poll every X seconds, else 0 for non-async\n        basedir=None,                       # directory of playbook, if applicable\n        setup_cache=None,                   # used to share fact data w/ other tasks\n        vars_cache=None,                    # used to store variables about hosts\n        transport=C.DEFAULT_TRANSPORT,      # 'ssh', 'paramiko', 'local'\n        conditional='True',                 # run only if this fact expression evals to true\n        callbacks=None,                     # used for output\n        sudo=False,                         # whether to run sudo or not\n        sudo_user=C.DEFAULT_SUDO_USER,      # ex: 'root'\n        module_vars=None,                   # a playbooks internals thing\n        default_vars=None,                  # ditto\n        is_playbook=False,                  # running from playbook or not?\n        inventory=None,                     # reference to Inventory object\n        subset=None,                        # subset pattern\n        check=False,                        # don't make any changes, just try to probe for potential changes\n        diff=False,                         # whether to show diffs for template files that change\n        environment=None,                   # environment variables (as dict) to use inside the command\n        complex_args=None,                  # structured data in addition to module_args, must be a dict\n        error_on_undefined_vars=C.DEFAULT_UNDEFINED_VAR_BEHAVIOR, # ex. False\n        accelerate=False,                   # use accelerated connection\n        accelerate_ipv6=False,              # accelerated connection w/ IPv6\n        accelerate_port=None,               # port to use with accelerated connection\n        su=False,                           # Are we running our command via su?\n        su_user=None,                       # User to su to when running command, ex: 'root'\n        su_pass=C.DEFAULT_SU_PASS,\n        vault_pass=None,\n        run_hosts=None,                     # an optional list of pre-calculated hosts to run on\n        no_log=False,                       # option to enable/disable logging for a given task\n        ):\n\n        # used to lock multiprocess inputs and outputs at various levels\n        self.output_lockfile  = OUTPUT_LOCKFILE\n        self.process_lockfile = PROCESS_LOCKFILE\n\n        if not complex_args:\n            complex_args = {}\n\n        # storage & defaults\n        self.check            = check\n        self.diff             = diff\n        self.setup_cache      = utils.default(setup_cache, lambda: collections.defaultdict(dict))\n        self.vars_cache       = utils.default(vars_cache, lambda: collections.defaultdict(dict))\n        self.basedir          = utils.default(basedir, lambda: os.getcwd())\n        self.callbacks        = utils.default(callbacks, lambda: DefaultRunnerCallbacks())\n        self.generated_jid    = str(random.randint(0, 999999999999))\n        self.transport        = transport\n        self.inventory        = utils.default(inventory, lambda: ansible.inventory.Inventory(host_list))\n\n        self.module_vars      = utils.default(module_vars, lambda: {})\n        self.default_vars     = utils.default(default_vars, lambda: {})\n        self.always_run       = None\n        self.connector        = connection.Connector(self)\n        self.conditional      = conditional\n        self.module_name      = module_name\n        self.forks            = int(forks)\n        self.pattern          = pattern\n        self.module_args      = module_args\n        self.timeout          = timeout\n        self.remote_user      = remote_user\n        self.remote_pass      = remote_pass\n        self.remote_port      = remote_port\n        self.private_key_file = private_key_file\n        self.background       = background\n        self.sudo             = sudo\n        self.sudo_user_var    = sudo_user\n        self.sudo_user        = None\n        self.sudo_pass        = sudo_pass\n        self.is_playbook      = is_playbook\n        self.environment      = environment\n        self.complex_args     = complex_args\n        self.error_on_undefined_vars = error_on_undefined_vars\n        self.accelerate       = accelerate\n        self.accelerate_port  = accelerate_port\n        self.accelerate_ipv6  = accelerate_ipv6\n        self.callbacks.runner = self\n        self.su               = su\n        self.su_user_var      = su_user\n        self.su_user          = None\n        self.su_pass          = su_pass\n        self.vault_pass       = vault_pass\n        self.no_log           = no_log\n\n        if self.transport == 'smart':\n            # if the transport is 'smart' see if SSH can support ControlPersist if not use paramiko\n            # 'smart' is the default since 1.2.1/1.3\n            cmd = subprocess.Popen(['ssh','-o','ControlPersist'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            (out, err) = cmd.communicate() \n            if \"Bad configuration option\" in err:\n                self.transport = \"paramiko\"\n            else:\n                self.transport = \"ssh\" \n\n        # save the original transport, in case it gets\n        # changed later via options like accelerate\n        self.original_transport = self.transport\n\n        # misc housekeeping\n        if subset and self.inventory._subset is None:\n            # don't override subset when passed from playbook\n            self.inventory.subset(subset)\n\n        # If we get a pre-built list of hosts to run on, from say a playbook, use them.\n        # Also where we will store the hosts to run on once discovered\n        self.run_hosts = run_hosts\n\n        if self.transport == 'local':\n            self.remote_user = pwd.getpwuid(os.geteuid())[0]\n\n        if module_path is not None:\n            for i in module_path.split(os.pathsep):\n                utils.plugins.module_finder.add_directory(i)\n\n        utils.plugins.push_basedir(self.basedir)\n\n        # ensure we are using unique tmp paths\n        random.seed()\n    # *****************************************************\n\n    def _complex_args_hack(self, complex_args, module_args):\n        \"\"\"\n        ansible-playbook both allows specifying key=value string arguments and complex arguments\n        however not all modules use our python common module system and cannot\n        access these.  An example might be a Bash module.  This hack allows users to still pass \"args\"\n        as a hash of simple scalars to those arguments and is short term.  We could technically\n        just feed JSON to the module, but that makes it hard on Bash consumers.  The way this is implemented\n        it does mean values in 'args' have LOWER priority than those on the key=value line, allowing\n        args to provide yet another way to have pluggable defaults.\n        \"\"\"\n        if complex_args is None:\n            return module_args\n        if not isinstance(complex_args, dict):\n            raise errors.AnsibleError(\"complex arguments are not a dictionary: %s\" % complex_args)\n        for (k,v) in complex_args.iteritems():\n            if isinstance(v, basestring):\n                module_args = \"%s=%s %s\" % (k, pipes.quote(v), module_args)\n        return module_args\n\n    # *****************************************************\n\n    def _transfer_str(self, conn, tmp, name, data):\n        ''' transfer string to remote file '''\n\n        if type(data) == dict:\n            data = utils.jsonify(data)\n\n        afd, afile = tempfile.mkstemp()\n        afo = os.fdopen(afd, 'w')\n        try:\n            if not isinstance(data, unicode):\n                #ensure the data is valid UTF-8\n                data.decode('utf-8')\n            else:\n                data = data.encode('utf-8')\n            afo.write(data)\n        except:\n            raise errors.AnsibleError(\"failure encoding into utf-8\")\n        afo.flush()\n        afo.close()\n\n        remote = conn.shell.join_path(tmp, name)\n        try:\n            conn.put_file(afile, remote)\n        finally:\n            os.unlink(afile)\n        return remote\n\n    # *****************************************************\n\n    def _compute_environment_string(self, conn, inject=None):\n        ''' what environment variables to use when running the command? '''\n\n        enviro = {}\n        if self.environment:\n            enviro = template.template(self.basedir, self.environment, inject, convert_bare=True)\n            enviro = utils.safe_eval(enviro)\n            if type(enviro) != dict:\n                raise errors.AnsibleError(\"environment must be a dictionary, received %s\" % enviro)\n\n        return conn.shell.env_prefix(**enviro)\n\n    # *****************************************************\n\n    def _compute_delegate(self, host, password, remote_inject):\n\n        \"\"\" Build a dictionary of all attributes for the delegate host \"\"\"\n\n        delegate = {}\n\n        # allow delegated host to be templated\n        delegate['host'] = template.template(self.basedir, host, \n                                remote_inject, fail_on_undefined=True)\n\n        delegate['inject'] = remote_inject.copy()\n\n        # set any interpreters\n        interpreters = []\n        for i in delegate['inject']:\n            if i.startswith(\"ansible_\") and i.endswith(\"_interpreter\"):\n                interpreters.append(i)\n        for i in interpreters:\n            del delegate['inject'][i]\n        port = C.DEFAULT_REMOTE_PORT\n\n        this_host = delegate['host']\n\n        # get the vars for the delegate by it's name        \n        try:\n            this_info = delegate['inject']['hostvars'][this_host]\n        except:\n            # make sure the inject is empty for non-inventory hosts\n            this_info = {}\n\n        # get the real ssh_address for the delegate        \n        # and allow ansible_ssh_host to be templated\n        delegate['ssh_host'] = template.template(self.basedir,\n                            this_info.get('ansible_ssh_host', this_host),\n                            this_info, fail_on_undefined=True)\n\n        delegate['port'] = this_info.get('ansible_ssh_port', port)\n\n        delegate['user'] = self._compute_delegate_user(this_host, delegate['inject'])\n\n        delegate['pass'] = this_info.get('ansible_ssh_pass', password)\n        delegate['private_key_file'] = this_info.get('ansible_ssh_private_key_file', \n                                        self.private_key_file)\n        delegate['transport'] = this_info.get('ansible_connection', self.transport)\n        delegate['sudo_pass'] = this_info.get('ansible_sudo_pass', self.sudo_pass)\n\n        # Last chance to get private_key_file from global variables.\n        # this is usefull if delegated host is not defined in the inventory\n        if delegate['private_key_file'] is None:\n            delegate['private_key_file'] = remote_inject.get(\n                'ansible_ssh_private_key_file', None)\n\n        if delegate['private_key_file'] is not None:\n            delegate['private_key_file'] = os.path.expanduser(delegate['private_key_file'])\n\n        for i in this_info:\n            if i.startswith(\"ansible_\") and i.endswith(\"_interpreter\"):\n                delegate['inject'][i] = this_info[i]\n\n        return delegate\n\n    def _compute_delegate_user(self, host, inject):\n\n        \"\"\" Caculate the remote user based on an order of preference \"\"\"\n\n        # inventory > playbook > original_host\n\n        actual_user = inject.get('ansible_ssh_user', self.remote_user)\n        thisuser = None\n\n        if host in inject['hostvars']:\n            if inject['hostvars'][host].get('ansible_ssh_user'):\n                # user for delegate host in inventory\n                thisuser = inject['hostvars'][host].get('ansible_ssh_user')\n\n        if thisuser is None and self.remote_user:\n            # user defined by play/runner\n            thisuser = self.remote_user\n\n        if thisuser is not None:\n            actual_user = thisuser\n        else:\n            # fallback to the inventory user of the play host\n            #actual_user = inject.get('ansible_ssh_user', actual_user)\n            actual_user = inject.get('ansible_ssh_user', self.remote_user)\n\n        return actual_user\n\n\n    # *****************************************************\n\n    def _execute_module(self, conn, tmp, module_name, args,\n        async_jid=None, async_module=None, async_limit=None, inject=None, persist_files=False, complex_args=None, delete_remote_tmp=True):\n\n        ''' transfer and run a module along with its arguments on the remote side'''\n\n        # hack to support fireball mode\n        if module_name == 'fireball':\n            args = \"%s password=%s\" % (args, base64.b64encode(str(utils.key_for_hostname(conn.host))))\n            if 'port' not in args:\n                args += \" port=%s\" % C.ZEROMQ_PORT\n\n        (\n        module_style,\n        shebang,\n        module_data\n        ) = self._configure_module(conn, module_name, args, inject, complex_args)\n\n        # a remote tmp path may be necessary and not already created\n        if self._late_needs_tmp_path(conn, tmp, module_style):\n            tmp = self._make_tmp_path(conn)\n\n        remote_module_path = conn.shell.join_path(tmp, module_name)\n\n        if (module_style != 'new'\n           or async_jid is not None\n           or not conn.has_pipelining\n           or not C.ANSIBLE_SSH_PIPELINING\n           or C.DEFAULT_KEEP_REMOTE_FILES\n           or self.su):\n            self._transfer_str(conn, tmp, module_name, module_data)\n\n        environment_string = self._compute_environment_string(conn, inject)\n\n        if \"tmp\" in tmp and ((self.sudo and self.sudo_user != 'root') or (self.su and self.su_user != 'root')):\n            # deal with possible umask issues once sudo'ed to other user\n            self._remote_chmod(conn, 'a+r', remote_module_path, tmp)\n\n        cmd = \"\"\n        in_data = None\n        if module_style != 'new':\n            if 'CHECKMODE=True' in args:\n                # if module isn't using AnsibleModuleCommon infrastructure we can't be certain it knows how to\n                # do --check mode, so to be safe we will not run it.\n                return ReturnData(conn=conn, result=dict(skipped=True, msg=\"cannot yet run check mode against old-style modules\"))\n            elif 'NO_LOG' in args:\n                return ReturnData(conn=conn, result=dict(skipped=True, msg=\"cannot use no_log: with old-style modules\"))\n\n            args = template.template(self.basedir, args, inject)\n\n            # decide whether we need to transfer JSON or key=value\n            argsfile = None\n            if module_style == 'non_native_want_json':\n                if complex_args:\n                    complex_args.update(utils.parse_kv(args))\n                    argsfile = self._transfer_str(conn, tmp, 'arguments', utils.jsonify(complex_args))\n                else:\n                    argsfile = self._transfer_str(conn, tmp, 'arguments', utils.jsonify(utils.parse_kv(args)))\n\n            else:\n                argsfile = self._transfer_str(conn, tmp, 'arguments', args)\n\n            if (self.sudo and self.sudo_user != 'root') or (self.su and self.su_user != 'root'):\n                # deal with possible umask issues once sudo'ed to other user\n                self._remote_chmod(conn, 'a+r', argsfile, tmp)\n\n            if async_jid is None:\n                cmd = \"%s %s\" % (remote_module_path, argsfile)\n            else:\n                cmd = \" \".join([str(x) for x in [remote_module_path, async_jid, async_limit, async_module, argsfile]])\n        else:\n            if async_jid is None:\n                if conn.has_pipelining and C.ANSIBLE_SSH_PIPELINING and not C.DEFAULT_KEEP_REMOTE_FILES and not self.su:\n                    in_data = module_data\n                else:\n                    cmd = \"%s\" % (remote_module_path)\n            else:\n                cmd = \" \".join([str(x) for x in [remote_module_path, async_jid, async_limit, async_module]])\n\n        if not shebang:\n            raise errors.AnsibleError(\"module is missing interpreter line\")\n\n        rm_tmp = None\n        if \"tmp\" in tmp and not C.DEFAULT_KEEP_REMOTE_FILES and not persist_files and delete_remote_tmp:\n            if not self.sudo or self.su or self.sudo_user == 'root' or self.su_user == 'root':\n                # not sudoing or sudoing to root, so can cleanup files in the same step\n                rm_tmp = tmp\n\n        cmd = conn.shell.build_module_command(environment_string, shebang, cmd, rm_tmp)\n        cmd = cmd.strip()\n\n        sudoable = True\n        if module_name == \"accelerate\":\n            # always run the accelerate module as the user\n            # specified in the play, not the sudo_user\n            sudoable = False\n\n        if self.su:\n            res = self._low_level_exec_command(conn, cmd, tmp, su=True, in_data=in_data)\n        else:\n            res = self._low_level_exec_command(conn, cmd, tmp, sudoable=sudoable, in_data=in_data)\n\n        if \"tmp\" in tmp and not C.DEFAULT_KEEP_REMOTE_FILES and not persist_files and delete_remote_tmp:\n            if (self.sudo and self.sudo_user != 'root') or (self.su and self.su_user != 'root'):\n            # not sudoing to root, so maybe can't delete files as that other user\n            # have to clean up temp files as original user in a second step\n                cmd2 = conn.shell.remove(tmp, recurse=True)\n                self._low_level_exec_command(conn, cmd2, tmp, sudoable=False)\n\n        data = utils.parse_json(res['stdout'], from_remote=True)\n        if 'parsed' in data and data['parsed'] == False:\n            data['msg'] += res['stderr']\n        return ReturnData(conn=conn, result=data)\n\n    # *****************************************************\n\n    def _executor(self, host, new_stdin):\n        ''' handler for multiprocessing library '''\n\n        try:\n            fileno = sys.stdin.fileno()\n        except ValueError:\n            fileno = None\n\n        try:\n            self._new_stdin = new_stdin\n            if not new_stdin and fileno is not None:\n                try:\n                    self._new_stdin = os.fdopen(os.dup(fileno))\n                except OSError, e:\n                    # couldn't dupe stdin, most likely because it's\n                    # not a valid file descriptor, so we just rely on\n                    # using the one that was passed in\n                    pass\n\n            exec_rc = self._executor_internal(host, new_stdin)\n            if type(exec_rc) != ReturnData:\n                raise Exception(\"unexpected return type: %s\" % type(exec_rc))\n            # redundant, right?\n            if not exec_rc.comm_ok:\n                self.callbacks.on_unreachable(host, exec_rc.result)\n            return exec_rc\n        except errors.AnsibleError, ae:\n            msg = str(ae)\n            self.callbacks.on_unreachable(host, msg)\n            return ReturnData(host=host, comm_ok=False, result=dict(failed=True, msg=msg))\n        except Exception:\n            msg = traceback.format_exc()\n            self.callbacks.on_unreachable(host, msg)\n            return ReturnData(host=host, comm_ok=False, result=dict(failed=True, msg=msg))\n\n    # *****************************************************\n\n    def _executor_internal(self, host, new_stdin):\n        ''' executes any module one or more times '''\n\n        host_variables = self.inventory.get_variables(host, vault_password=self.vault_pass)\n        host_connection = host_variables.get('ansible_connection', self.transport)\n        if host_connection in [ 'paramiko', 'ssh', 'accelerate' ]:\n            port = host_variables.get('ansible_ssh_port', self.remote_port)\n            if port is None:\n                port = C.DEFAULT_REMOTE_PORT\n        else:\n            # fireball, local, etc\n            port = self.remote_port\n\n        # merge the VARS and SETUP caches for this host\n        combined_cache = self.setup_cache.copy()\n        combined_cache.setdefault(host, {}).update(self.vars_cache.get(host, {}))\n        hostvars = HostVars(combined_cache, self.inventory, vault_password=self.vault_pass)\n\n        # use combined_cache and host_variables to template the module_vars\n        # we update the inject variables with the data we're about to template\n        # since some of the variables we'll be replacing may be contained there too\n        module_vars_inject = utils.combine_vars(host_variables, combined_cache.get(host, {}))\n        module_vars_inject = utils.combine_vars(self.module_vars, module_vars_inject)\n        module_vars = template.template(self.basedir, self.module_vars, module_vars_inject)\n\n        inject = {}\n        inject = utils.combine_vars(inject, self.default_vars)\n        inject = utils.combine_vars(inject, host_variables)\n        inject = utils.combine_vars(inject, module_vars)\n        inject = utils.combine_vars(inject, combined_cache.get(host, {}))\n        inject.setdefault('ansible_ssh_user', self.remote_user)\n        inject['hostvars']    = hostvars\n        inject['group_names'] = host_variables.get('group_names', [])\n        inject['groups']      = self.inventory.groups_list()\n        inject['vars']        = self.module_vars\n        inject['defaults']    = self.default_vars\n        inject['environment'] = self.environment\n        inject['playbook_dir'] = self.basedir\n\n        if self.inventory.basedir() is not None:\n            inject['inventory_dir'] = self.inventory.basedir()\n\n        if self.inventory.src() is not None:\n            inject['inventory_file'] = self.inventory.src()\n\n        # allow with_foo to work in playbooks...\n        items = None\n        items_plugin = self.module_vars.get('items_lookup_plugin', None)\n\n        if items_plugin is not None and items_plugin in utils.plugins.lookup_loader:\n\n            basedir = self.basedir\n            if '_original_file' in inject:\n                basedir = os.path.dirname(inject['_original_file'])\n                filesdir = os.path.join(basedir, '..', 'files')\n                if os.path.exists(filesdir):\n                    basedir = filesdir\n\n            items_terms = self.module_vars.get('items_lookup_terms', '')\n            items_terms = template.template(basedir, items_terms, inject)\n            items = utils.plugins.lookup_loader.get(items_plugin, runner=self, basedir=basedir).run(items_terms, inject=inject)\n            if type(items) != list:\n                raise errors.AnsibleError(\"lookup plugins have to return a list: %r\" % items)\n\n            if len(items) and utils.is_list_of_strings(items) and self.module_name in [ 'apt', 'yum', 'pkgng' ]:\n                # hack for apt, yum, and pkgng so that with_items maps back into a single module call\n                use_these_items = []\n                for x in items:\n                    inject['item'] = x\n                    if not self.conditional or utils.check_conditional(self.conditional, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars):\n                        use_these_items.append(x)\n                inject['item'] = \",\".join(use_these_items)\n                items = None\n\n        # logic to replace complex args if possible\n        complex_args = self.complex_args\n\n        # logic to decide how to run things depends on whether with_items is used\n        if items is None:\n            if isinstance(complex_args, basestring):\n                complex_args = template.template(self.basedir, complex_args, inject, convert_bare=True)\n                complex_args = utils.safe_eval(complex_args)\n                if type(complex_args) != dict:\n                    raise errors.AnsibleError(\"args must be a dictionary, received %s\" % complex_args)\n            return self._executor_internal_inner(host, self.module_name, self.module_args, inject, port, complex_args=complex_args)\n        elif len(items) > 0:\n\n            # executing using with_items, so make multiple calls\n            # TODO: refactor\n\n            if self.background > 0:\n                raise errors.AnsibleError(\"lookup plugins (with_*) cannot be used with async tasks\")\n\n            all_comm_ok = True\n            all_changed = False\n            all_failed = False\n            results = []\n            for x in items:\n                # use a fresh inject for each item\n                this_inject = inject.copy()\n                this_inject['item'] = x\n\n                # TODO: this idiom should be replaced with an up-conversion to a Jinja2 template evaluation\n                if isinstance(self.complex_args, basestring):\n                    complex_args = template.template(self.basedir, self.complex_args, this_inject, convert_bare=True)\n                    complex_args = utils.safe_eval(complex_args)\n                    if type(complex_args) != dict:\n                        raise errors.AnsibleError(\"args must be a dictionary, received %s\" % complex_args)\n                result = self._executor_internal_inner(\n                     host,\n                     self.module_name,\n                     self.module_args,\n                     this_inject,\n                     port,\n                     complex_args=complex_args\n                )\n                results.append(result.result)\n                if result.comm_ok == False:\n                    all_comm_ok = False\n                    all_failed = True\n                    break\n                for x in results:\n                    if x.get('changed') == True:\n                        all_changed = True\n                    if (x.get('failed') == True) or ('failed_when_result' in x and [x['failed_when_result']] or [('rc' in x) and (x['rc'] != 0)])[0]:\n                        all_failed = True\n                        break\n            msg = 'All items completed'\n            if all_failed:\n                msg = \"One or more items failed.\"\n            rd_result = dict(failed=all_failed, changed=all_changed, results=results, msg=msg)\n            if not all_failed:\n                del rd_result['failed']\n            return ReturnData(host=host, comm_ok=all_comm_ok, result=rd_result)\n        else:\n            self.callbacks.on_skipped(host, None)\n            return ReturnData(host=host, comm_ok=True, result=dict(changed=False, skipped=True))\n\n    # *****************************************************\n\n    def _executor_internal_inner(self, host, module_name, module_args, inject, port, is_chained=False, complex_args=None):\n        ''' decides how to invoke a module '''\n\n        # late processing of parameterized sudo_user (with_items,..)\n        if self.sudo_user_var is not None:\n            self.sudo_user = template.template(self.basedir, self.sudo_user_var, inject)\n        if self.su_user_var is not None:\n            self.su_user = template.template(self.basedir, self.su_user_var, inject)\n\n        # allow module args to work as a dictionary\n        # though it is usually a string\n        new_args = \"\"\n        if type(module_args) == dict:\n            for (k,v) in module_args.iteritems():\n                new_args = new_args + \"%s='%s' \" % (k,v)\n            module_args = new_args\n\n        # module_name may be dynamic (but cannot contain {{ ansible_ssh_user }})\n        module_name  = template.template(self.basedir, module_name, inject)\n\n        if module_name in utils.plugins.action_loader:\n            if self.background != 0:\n                raise errors.AnsibleError(\"async mode is not supported with the %s module\" % module_name)\n            handler = utils.plugins.action_loader.get(module_name, self)\n        elif self.background == 0:\n            handler = utils.plugins.action_loader.get('normal', self)\n        else:\n            handler = utils.plugins.action_loader.get('async', self)\n\n        if type(self.conditional) != list:\n            self.conditional = [ self.conditional ]\n\n        for cond in self.conditional:\n\n            if not utils.check_conditional(cond, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars):\n                result = utils.jsonify(dict(changed=False, skipped=True))\n                self.callbacks.on_skipped(host, inject.get('item',None))\n                return ReturnData(host=host, result=result)\n\n        if getattr(handler, 'setup', None) is not None:\n            handler.setup(module_name, inject)\n        conn = None\n        actual_host = inject.get('ansible_ssh_host', host)\n        # allow ansible_ssh_host to be templated\n        actual_host = template.template(self.basedir, actual_host, inject, fail_on_undefined=True)\n        actual_port = port\n        actual_user = inject.get('ansible_ssh_user', self.remote_user)\n        actual_pass = inject.get('ansible_ssh_pass', self.remote_pass)\n        actual_transport = inject.get('ansible_connection', self.transport)\n        actual_private_key_file = inject.get('ansible_ssh_private_key_file', self.private_key_file)\n        actual_private_key_file = template.template(self.basedir, actual_private_key_file, inject, fail_on_undefined=True)\n        self.sudo = utils.boolean(inject.get('ansible_sudo', self.sudo))\n        self.sudo_user = inject.get('ansible_sudo_user', self.sudo_user)\n        self.sudo_pass = inject.get('ansible_sudo_pass', self.sudo_pass)\n        self.su = inject.get('ansible_su', self.su)\n        self.su_pass = inject.get('ansible_su_pass', self.su_pass)\n\n        # select default root user in case self.sudo requested\n        # but no user specified; happens e.g. in host vars when\n        # just ansible_sudo=True is specified\n        if self.sudo and self.sudo_user is None:\n            self.sudo_user = 'root'\n\n        if actual_private_key_file is not None:\n            actual_private_key_file = os.path.expanduser(actual_private_key_file)\n\n        if self.accelerate and actual_transport != 'local':\n            #Fix to get the inventory name of the host to accelerate plugin\n            if inject.get('ansible_ssh_host', None):\n                self.accelerate_inventory_host = host\n            else:\n                self.accelerate_inventory_host = None\n            # if we're using accelerated mode, force the\n            # transport to accelerate\n            actual_transport = \"accelerate\"\n            if not self.accelerate_port:\n                self.accelerate_port = C.ACCELERATE_PORT\n\n        actual_port = inject.get('ansible_ssh_port', port)\n\n        # the delegated host may have different SSH port configured, etc\n        # and we need to transfer those, and only those, variables\n        delegate_to = inject.get('delegate_to', None)\n        if delegate_to is not None:\n            delegate = self._compute_delegate(delegate_to, actual_pass, inject)\n            actual_transport = delegate['transport']\n            actual_host = delegate['ssh_host']\n            actual_port = delegate['port']\n            actual_user = delegate['user']\n            actual_pass = delegate['pass']\n            actual_private_key_file = delegate['private_key_file']\n            self.sudo_pass = delegate['sudo_pass']\n            inject = delegate['inject']\n\n        # user/pass may still contain variables at this stage\n        actual_user = template.template(self.basedir, actual_user, inject)\n        actual_pass = template.template(self.basedir, actual_pass, inject)\n        self.sudo_pass = template.template(self.basedir, self.sudo_pass, inject)\n\n        # make actual_user available as __magic__ ansible_ssh_user variable\n        inject['ansible_ssh_user'] = actual_user\n\n        try:\n            if actual_transport == 'accelerate':\n                # for accelerate, we stuff both ports into a single\n                # variable so that we don't have to mangle other function\n                # calls just to accomodate this one case\n                actual_port = [actual_port, self.accelerate_port]\n            elif actual_port is not None:\n                actual_port = int(template.template(self.basedir, actual_port, inject))\n        except ValueError, e:\n            result = dict(failed=True, msg=\"FAILED: Configured port \\\"%s\\\" is not a valid port, expected integer\" % actual_port)\n            return ReturnData(host=host, comm_ok=False, result=result)\n\n        try:\n            conn = self.connector.connect(actual_host, actual_port, actual_user, actual_pass, actual_transport, actual_private_key_file)\n            if delegate_to or host != actual_host:\n                conn.delegate = host\n\n            default_shell = getattr(conn, 'default_shell', '')\n            shell_type = inject.get('ansible_shell_type')\n            if not shell_type:\n                if default_shell:\n                    shell_type = default_shell\n                else:\n                    shell_type = os.path.basename(C.DEFAULT_EXECUTABLE)\n\n            shell_plugin = utils.plugins.shell_loader.get(shell_type)\n            if shell_plugin is None:\n                shell_plugin = utils.plugins.shell_loader.get('sh')\n            conn.shell = shell_plugin\n\n        except errors.AnsibleConnectionFailed, e:\n            result = dict(failed=True, msg=\"FAILED: %s\" % str(e))\n            return ReturnData(host=host, comm_ok=False, result=result)\n\n        tmp = ''\n        # action plugins may DECLARE via TRANSFERS_FILES = True that they need a remote tmp path working dir\n        if self._early_needs_tmp_path(module_name, handler):\n            tmp = self._make_tmp_path(conn)\n\n        # render module_args and complex_args templates\n        try:\n            module_args = template.template(self.basedir, module_args, inject, fail_on_undefined=self.error_on_undefined_vars)\n            complex_args = template.template(self.basedir, complex_args, inject, fail_on_undefined=self.error_on_undefined_vars)\n        except jinja2.exceptions.UndefinedError, e:\n            raise errors.AnsibleUndefinedVariable(\"One or more undefined variables: %s\" % str(e))\n\n\n        result = handler.run(conn, tmp, module_name, module_args, inject, complex_args)\n        # Code for do until feature\n        until = self.module_vars.get('until', None)\n        if until is not None and result.comm_ok:\n            inject[self.module_vars.get('register')] = result.result\n            cond = template.template(self.basedir, until, inject, expand_lists=False)\n            if not utils.check_conditional(cond,  self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars):\n                retries = self.module_vars.get('retries')\n                delay   = self.module_vars.get('delay')\n                for x in range(1, int(retries) + 1):\n                    # template the delay, cast to float and sleep\n                    delay = template.template(self.basedir, delay, inject, expand_lists=False)\n                    delay = float(delay)\n                    time.sleep(delay)\n                    tmp = ''\n                    if self._early_needs_tmp_path(module_name, handler):\n                        tmp = self._make_tmp_path(conn)\n                    result = handler.run(conn, tmp, module_name, module_args, inject, complex_args)\n                    result.result['attempts'] = x\n                    vv(\"Result from run %i is: %s\" % (x, result.result))\n                    inject[self.module_vars.get('register')] = result.result\n                    cond = template.template(self.basedir, until, inject, expand_lists=False)\n                    if utils.check_conditional(cond, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars):\n                        break\n                if result.result['attempts'] == retries and not utils.check_conditional(cond, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars):\n                    result.result['failed'] = True \n                    result.result['msg'] = \"Task failed as maximum retries was encountered\"\n            else:\n                result.result['attempts'] = 0\n        conn.close()\n\n        if not result.comm_ok:\n            # connection or parsing errors...\n            self.callbacks.on_unreachable(host, result.result)\n        else:\n            data = result.result\n\n            # https://github.com/ansible/ansible/issues/4958\n            if hasattr(sys.stdout, \"isatty\"):\n                if \"stdout\" in data and sys.stdout.isatty():\n                    if not string_functions.isprintable(data['stdout']):\n                        data['stdout'] = ''\n\n            if 'item' in inject:\n                result.result['item'] = inject['item']\n\n            result.result['invocation'] = dict(\n                module_args=module_args,\n                module_name=module_name\n            )\n\n            changed_when = self.module_vars.get('changed_when')\n            failed_when = self.module_vars.get('failed_when')\n            if (changed_when is not None or failed_when is not None) and self.background == 0:\n                register = self.module_vars.get('register')\n                if register is not None:\n                    if 'stdout' in data:\n                        data['stdout_lines'] = data['stdout'].splitlines()\n                    inject[register] = data\n                # only run the final checks if the async_status has finished,\n                # or if we're not running an async_status check at all\n                if (module_name == 'async_status' and \"finished\" in data) or module_name != 'async_status':\n                    if changed_when is not None and 'skipped' not in data:\n                        data['changed'] = utils.check_conditional(changed_when, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars)\n                    if failed_when is not None and 'skipped' not in data:\n                        data['failed_when_result'] = data['failed'] = utils.check_conditional(failed_when, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars)\n\n            if is_chained:\n                # no callbacks\n                return result\n            if 'skipped' in data:\n                self.callbacks.on_skipped(host, inject.get('item',None))\n            elif not result.is_successful():\n                ignore_errors = self.module_vars.get('ignore_errors', False)\n                self.callbacks.on_failed(host, data, ignore_errors)\n            else:\n                if self.diff:\n                    self.callbacks.on_file_diff(conn.host, result.diff)\n                self.callbacks.on_ok(host, data)\n        return result\n\n    def _early_needs_tmp_path(self, module_name, handler):\n        ''' detect if a tmp path should be created before the handler is called '''\n        if module_name in utils.plugins.action_loader:\n          return getattr(handler, 'TRANSFERS_FILES', False)\n        # other modules never need tmp path at early stage\n        return False\n\n    def _late_needs_tmp_path(self, conn, tmp, module_style):\n        if \"tmp\" in tmp:\n            # tmp has already been created\n            return False\n        if not conn.has_pipelining or not C.ANSIBLE_SSH_PIPELINING or C.DEFAULT_KEEP_REMOTE_FILES or self.su:\n            # tmp is necessary to store module source code\n            return True\n        if not conn.has_pipelining:\n            # tmp is necessary to store the module source code\n            # or we want to keep the files on the target system\n            return True\n        if module_style != \"new\":\n            # even when conn has pipelining, old style modules need tmp to store arguments\n            return True\n        return False\n    \n\n    # *****************************************************\n\n    def _low_level_exec_command(self, conn, cmd, tmp, sudoable=False,\n                                executable=None, su=False, in_data=None):\n        ''' execute a command string over SSH, return the output '''\n\n        if not cmd:\n            # this can happen with powershell modules when there is no analog to a Windows command (like chmod)\n            return dict(stdout='', stderr='')\n\n        if executable is None:\n            executable = C.DEFAULT_EXECUTABLE\n\n        sudo_user = self.sudo_user\n        su_user = self.su_user\n\n        # compare connection user to (su|sudo)_user and disable if the same\n        # assume connection type is local if no user attribute\n        this_user = getattr(conn, 'user', getpass.getuser())\n        if (not su and this_user == sudo_user) or (su and this_user == su_user):\n            sudoable = False\n            su = False\n\n        if su:\n            rc, stdin, stdout, stderr = conn.exec_command(cmd,\n                                                          tmp,\n                                                          su=su,\n                                                          su_user=su_user,\n                                                          executable=executable,\n                                                          in_data=in_data)\n        else:\n            rc, stdin, stdout, stderr = conn.exec_command(cmd,\n                                                          tmp,\n                                                          sudo_user,\n                                                          sudoable=sudoable,\n                                                          executable=executable,\n                                                          in_data=in_data)\n\n        if type(stdout) not in [ str, unicode ]:\n            out = ''.join(stdout.readlines())\n        else:\n            out = stdout\n\n        if type(stderr) not in [ str, unicode ]:\n            err = ''.join(stderr.readlines())\n        else:\n            err = stderr\n\n        if rc is not None:\n            return dict(rc=rc, stdout=out, stderr=err)\n        else:\n            return dict(stdout=out, stderr=err)\n\n    # *****************************************************\n\n    def _remote_chmod(self, conn, mode, path, tmp, sudoable=False, su=False):\n        ''' issue a remote chmod command '''\n        cmd = conn.shell.chmod(mode, path)\n        return self._low_level_exec_command(conn, cmd, tmp, sudoable=sudoable, su=su)\n\n    # *****************************************************\n\n    def _remote_md5(self, conn, tmp, path):\n        ''' takes a remote md5sum without requiring python, and returns 1 if no file '''\n        cmd = conn.shell.md5(path)\n        data = self._low_level_exec_command(conn, cmd, tmp, sudoable=True)\n        data2 = utils.last_non_blank_line(data['stdout'])\n        try:\n            if data2 == '':\n                # this may happen if the connection to the remote server\n                # failed, so just return \"INVALIDMD5SUM\" to avoid errors\n                return \"INVALIDMD5SUM\"\n            else:\n                return data2.split()[0]\n        except IndexError:\n            sys.stderr.write(\"warning: md5sum command failed unusually, please report this to the list so it can be fixed\\n\")\n            sys.stderr.write(\"command: %s\\n\" % md5s)\n            sys.stderr.write(\"----\\n\")\n            sys.stderr.write(\"output: %s\\n\" % data)\n            sys.stderr.write(\"----\\n\")\n            # this will signal that it changed and allow things to keep going\n            return \"INVALIDMD5SUM\"\n\n    # *****************************************************\n\n    def _make_tmp_path(self, conn):\n        ''' make and return a temporary path on a remote box '''\n        basefile = 'ansible-tmp-%s-%s' % (time.time(), random.randint(0, 2**48))\n        use_system_tmp = False\n        if (self.sudo and self.sudo_user != 'root') or (self.su and self.su_user != 'root'):\n            use_system_tmp = True\n\n        tmp_mode = None\n        if self.remote_user != 'root' or ((self.sudo and self.sudo_user != 'root') or (self.su and self.su_user != 'root')):\n            tmp_mode = 'a+rx'\n\n        cmd = conn.shell.mkdtemp(basefile, use_system_tmp, tmp_mode)\n        result = self._low_level_exec_command(conn, cmd, None, sudoable=False)\n\n        # error handling on this seems a little aggressive?\n        if result['rc'] != 0:\n            if result['rc'] == 5:\n                output = 'Authentication failure.'\n            elif result['rc'] == 255 and self.transport in ['ssh']:\n                if utils.VERBOSITY > 3:\n                    output = 'SSH encountered an unknown error. The output was:\\n%s' % (result['stdout']+result['stderr'])\n                else:\n                    output = 'SSH encountered an unknown error during the connection. We recommend you re-run the command using -vvvv, which will enable SSH debugging output to help diagnose the issue'\n            else:\n                output = 'Authentication or permission failure.  In some cases, you may have been able to authenticate and did not have permissions on the remote directory. Consider changing the remote temp path in ansible.cfg to a path rooted in \"/tmp\". Failed command was: %s, exited with result %d' % (cmd, result['rc'])\n            if 'stdout' in result and result['stdout'] != '':\n                output = output + \": %s\" % result['stdout']\n            raise errors.AnsibleError(output)\n\n        rc = conn.shell.join_path(utils.last_non_blank_line(result['stdout']).strip(), '')\n        # Catch failure conditions, files should never be\n        # written to locations in /.\n        if rc == '/': \n            raise errors.AnsibleError('failed to resolve remote temporary directory from %s: `%s` returned empty string' % (basetmp, cmd))\n        return rc\n\n    # *****************************************************\n\n    def _remove_tmp_path(self, conn, tmp_path):\n        ''' Remove a tmp_path. '''\n        if \"-tmp-\" in tmp_path:\n            cmd = conn.shell.remove(tmp_path, recurse=True)\n            self._low_level_exec_command(conn, cmd, None, sudoable=False)\n            # If we have gotten here we have a working ssh configuration.\n            # If ssh breaks we could leave tmp directories out on the remote system.\n\n    # *****************************************************\n\n    def _copy_module(self, conn, tmp, module_name, module_args, inject, complex_args=None):\n        ''' transfer a module over SFTP, does not run it '''\n        (\n        module_style,\n        module_shebang,\n        module_data\n        ) = self._configure_module(conn, module_name, module_args, inject, complex_args)\n        module_remote_path = conn.shell.join_path(tmp, module_name)\n        \n        self._transfer_str(conn, tmp, module_name, module_data)\n         \n        return (module_remote_path, module_style, module_shebang)\n\n    # *****************************************************\n\n    def _configure_module(self, conn, module_name, module_args, inject, complex_args=None):\n        ''' find module and configure it '''\n\n        # Search module path(s) for named module.\n        module_suffixes = getattr(conn, 'default_suffixes', None)\n        module_path = utils.plugins.module_finder.find_plugin(module_name, module_suffixes)\n        if module_path is None:\n            raise errors.AnsibleFileNotFound(\"module %s not found in %s\" % (module_name, utils.plugins.module_finder.print_paths()))\n\n\n        # insert shared code and arguments into the module\n        (module_data, module_style, module_shebang) = module_replacer.modify_module(\n            module_path, complex_args, module_args, inject\n        )\n\n        return (module_style, module_shebang, module_data)\n\n\n    # *****************************************************\n\n\n    def _parallel_exec(self, hosts):\n        ''' handles mulitprocessing when more than 1 fork is required '''\n\n        manager = multiprocessing.Manager()\n        job_queue = manager.Queue()\n        for host in hosts:\n            job_queue.put(host)\n        result_queue = manager.Queue()\n\n        try:\n            fileno = sys.stdin.fileno()\n        except ValueError:\n            fileno = None\n\n        workers = []\n        for i in range(self.forks):\n            new_stdin = None\n            if fileno is not None:\n                try:\n                    new_stdin = os.fdopen(os.dup(fileno))\n                except OSError, e:\n                    # couldn't dupe stdin, most likely because it's\n                    # not a valid file descriptor, so we just rely on\n                    # using the one that was passed in\n                    pass\n            prc = multiprocessing.Process(target=_executor_hook,\n                args=(job_queue, result_queue, new_stdin))\n            prc.start()\n            workers.append(prc)\n\n        try:\n            for worker in workers:\n                worker.join()\n        except KeyboardInterrupt:\n            for worker in workers:\n                worker.terminate()\n                worker.join()\n        \n        results = []\n        try:\n            while not result_queue.empty():\n                results.append(result_queue.get(block=False))\n        except socket.error:\n            raise errors.AnsibleError(\"<interrupted>\")\n        return results\n\n    # *****************************************************\n\n    def _partition_results(self, results):\n        ''' separate results by ones we contacted & ones we didn't '''\n\n        if results is None:\n            return None\n        results2 = dict(contacted={}, dark={})\n\n        for result in results:\n            host = result.host\n            if host is None:\n                raise Exception(\"internal error, host not set\")\n            if result.communicated_ok():\n                results2[\"contacted\"][host] = result.result\n            else:\n                results2[\"dark\"][host] = result.result\n\n        # hosts which were contacted but never got a chance to return\n        for host in self.run_hosts:\n            if not (host in results2['dark'] or host in results2['contacted']):\n                results2[\"dark\"][host] = {}\n        return results2\n\n    # *****************************************************\n\n    def run(self):\n        ''' xfer & run module on all matched hosts '''\n\n        # find hosts that match the pattern\n        if not self.run_hosts:\n            self.run_hosts = self.inventory.list_hosts(self.pattern)\n        hosts = self.run_hosts\n        if len(hosts) == 0:\n            self.callbacks.on_no_hosts()\n            return dict(contacted={}, dark={})\n\n        global multiprocessing_runner\n        multiprocessing_runner = self\n        results = None\n\n        # Check if this is an action plugin. Some of them are designed\n        # to be ran once per group of hosts. Example module: pause,\n        # run once per hostgroup, rather than pausing once per each\n        # host.\n        p = utils.plugins.action_loader.get(self.module_name, self)\n\n        if self.forks == 0 or self.forks > len(hosts):\n            self.forks = len(hosts)\n\n        if p and getattr(p, 'BYPASS_HOST_LOOP', None):\n\n            # Expose the current hostgroup to the bypassing plugins\n            self.host_set = hosts\n            # We aren't iterating over all the hosts in this\n            # group. So, just pick the first host in our group to\n            # construct the conn object with.\n            result_data = self._executor(hosts[0], None).result\n            # Create a ResultData item for each host in this group\n            # using the returned result. If we didn't do this we would\n            # get false reports of dark hosts.\n            results = [ ReturnData(host=h, result=result_data, comm_ok=True) \\\n                           for h in hosts ]\n            del self.host_set\n\n        elif self.forks > 1:\n            try:\n                results = self._parallel_exec(hosts)\n            except IOError, ie:\n                print ie.errno\n                if ie.errno == 32:\n                    # broken pipe from Ctrl+C\n                    raise errors.AnsibleError(\"interrupted\")\n                raise\n        else:\n            results = [ self._executor(h, None) for h in hosts ]\n\n        return self._partition_results(results)\n\n    # *****************************************************\n\n    def run_async(self, time_limit):\n        ''' Run this module asynchronously and return a poller. '''\n\n        self.background = time_limit\n        results = self.run()\n        return results, poller.AsyncPoller(results, self)\n\n    # *****************************************************\n\n    def noop_on_check(self, inject):\n        ''' Should the runner run in check mode or not ? '''\n\n        # initialize self.always_run on first call\n        if self.always_run is None:\n            self.always_run = self.module_vars.get('always_run', False)\n            self.always_run = check_conditional(\n                self.always_run, self.basedir, inject, fail_on_undefined=True)\n\n        return (self.check and not self.always_run)\n", "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom ansible import utils\n\nclass ReturnData(object):\n    ''' internal return class for runner execute methods, not part of public API signature '''\n\n    __slots__ = [ 'result', 'comm_ok', 'host', 'diff' ]\n\n    def __init__(self, conn=None, host=None, result=None, \n        comm_ok=True, diff=dict()):\n\n        # which host is this ReturnData about?\n        if conn is not None:\n            self.host = conn.host\n            delegate = getattr(conn, 'delegate', None)\n            if delegate is not None:\n                self.host = delegate\n\n        else:\n            self.host = host\n\n        self.result = result\n        self.comm_ok = comm_ok\n\n        # if these values are set and used with --diff we can show\n        # changes made to particular files\n        self.diff = diff\n\n        if type(self.result) in [ str, unicode ]:\n            self.result = utils.parse_json(self.result, from_remote=True)\n\n        if self.host is None:\n            raise Exception(\"host not set\")\n        if type(self.result) != dict:\n            raise Exception(\"dictionary result expected\")\n\n    def communicated_ok(self):\n        return self.comm_ok\n\n    def is_successful(self):\n        return self.comm_ok and (self.result.get('failed', False) == False) and ('failed_when_result' in self.result and [not self.result['failed_when_result']] or [self.result.get('rc',0) == 0])[0]\n\n", "# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nimport re\nimport os\nimport shlex\nimport yaml\nimport copy\nimport optparse\nimport operator\nfrom ansible import errors\nfrom ansible import __version__\nfrom ansible.utils import template\nfrom ansible.utils.display_functions import *\nfrom ansible.utils.plugins import *\nfrom ansible.callbacks import display\nimport ansible.constants as C\nimport ast\nimport time\nimport StringIO\nimport stat\nimport termios\nimport tty\nimport pipes\nimport random\nimport difflib\nimport warnings\nimport traceback\nimport getpass\nimport sys\nimport json\n\nfrom vault import VaultLib\n\nVERBOSITY=0\n\nMAX_FILE_SIZE_FOR_DIFF=1*1024*1024\n\ntry:\n    import json\nexcept ImportError:\n    import simplejson as json\n\ntry:\n    from hashlib import md5 as _md5\nexcept ImportError:\n    from md5 import md5 as _md5\n\nPASSLIB_AVAILABLE = False\ntry:\n    import passlib.hash\n    PASSLIB_AVAILABLE = True\nexcept:\n    pass\n\ntry:\n    import builtin\nexcept ImportError:\n    import __builtin__ as builtin\n\nKEYCZAR_AVAILABLE=False\ntry:\n    try:\n        # some versions of pycrypto may not have this?\n        from Crypto.pct_warnings import PowmInsecureWarning\n    except ImportError:\n        PowmInsecureWarning = RuntimeWarning\n\n    with warnings.catch_warnings(record=True) as warning_handler:\n        warnings.simplefilter(\"error\", PowmInsecureWarning)\n        try:\n            import keyczar.errors as key_errors\n            from keyczar.keys import AesKey\n        except PowmInsecureWarning:\n            system_warning(\n                \"The version of gmp you have installed has a known issue regarding \" + \\\n                \"timing vulnerabilities when used with pycrypto. \" + \\\n                \"If possible, you should update it (ie. yum update gmp).\"\n            )\n            warnings.resetwarnings()\n            warnings.simplefilter(\"ignore\")\n            import keyczar.errors as key_errors\n            from keyczar.keys import AesKey\n        KEYCZAR_AVAILABLE=True\nexcept ImportError:\n    pass\n\n###############################################################\n# Abstractions around keyczar\n###############################################################\n\ndef key_for_hostname(hostname):\n    # fireball mode is an implementation of ansible firing up zeromq via SSH\n    # to use no persistent daemons or key management\n\n    if not KEYCZAR_AVAILABLE:\n        raise errors.AnsibleError(\"python-keyczar must be installed on the control machine to use accelerated modes\")\n\n    key_path = os.path.expanduser(C.ACCELERATE_KEYS_DIR)\n    if not os.path.exists(key_path):\n        os.makedirs(key_path, mode=0700)\n        os.chmod(key_path, int(C.ACCELERATE_KEYS_DIR_PERMS, 8))\n    elif not os.path.isdir(key_path):\n        raise errors.AnsibleError('ACCELERATE_KEYS_DIR is not a directory.')\n\n    if stat.S_IMODE(os.stat(key_path).st_mode) != int(C.ACCELERATE_KEYS_DIR_PERMS, 8):\n        raise errors.AnsibleError('Incorrect permissions on the private key directory. Use `chmod 0%o %s` to correct this issue, and make sure any of the keys files contained within that directory are set to 0%o' % (int(C.ACCELERATE_KEYS_DIR_PERMS, 8), C.ACCELERATE_KEYS_DIR, int(C.ACCELERATE_KEYS_FILE_PERMS, 8)))\n\n    key_path = os.path.join(key_path, hostname)\n\n    # use new AES keys every 2 hours, which means fireball must not allow running for longer either\n    if not os.path.exists(key_path) or (time.time() - os.path.getmtime(key_path) > 60*60*2):\n        key = AesKey.Generate()\n        fd = os.open(key_path, os.O_WRONLY | os.O_CREAT, int(C.ACCELERATE_KEYS_FILE_PERMS, 8))\n        fh = os.fdopen(fd, 'w')\n        fh.write(str(key))\n        fh.close()\n        return key\n    else:\n        if stat.S_IMODE(os.stat(key_path).st_mode) != int(C.ACCELERATE_KEYS_FILE_PERMS, 8):\n            raise errors.AnsibleError('Incorrect permissions on the key file for this host. Use `chmod 0%o %s` to correct this issue.' % (int(C.ACCELERATE_KEYS_FILE_PERMS, 8), key_path))\n        fh = open(key_path)\n        key = AesKey.Read(fh.read())\n        fh.close()\n        return key\n\ndef encrypt(key, msg):\n    return key.Encrypt(msg)\n\ndef decrypt(key, msg):\n    try:\n        return key.Decrypt(msg)\n    except key_errors.InvalidSignatureError:\n        raise errors.AnsibleError(\"decryption failed\")\n\n###############################################################\n# UTILITY FUNCTIONS FOR COMMAND LINE TOOLS\n###############################################################\n\ndef err(msg):\n    ''' print an error message to stderr '''\n\n    print >> sys.stderr, msg\n\ndef exit(msg, rc=1):\n    ''' quit with an error to stdout and a failure code '''\n\n    err(msg)\n    sys.exit(rc)\n\ndef jsonify(result, format=False):\n    ''' format JSON output (uncompressed or uncompressed) '''\n\n    if result is None:\n        return \"{}\"\n    result2 = result.copy()\n    for key, value in result2.items():\n        if type(value) is str:\n            result2[key] = value.decode('utf-8', 'ignore')\n    if format:\n        return json.dumps(result2, sort_keys=True, indent=4)\n    else:\n        return json.dumps(result2, sort_keys=True)\n\ndef write_tree_file(tree, hostname, buf):\n    ''' write something into treedir/hostname '''\n\n    # TODO: might be nice to append playbook runs per host in a similar way\n    # in which case, we'd want append mode.\n    path = os.path.join(tree, hostname)\n    fd = open(path, \"w+\")\n    fd.write(buf)\n    fd.close()\n\ndef is_failed(result):\n    ''' is a given JSON result a failed result? '''\n\n    return ((result.get('rc', 0) != 0) or (result.get('failed', False) in [ True, 'True', 'true']))\n\ndef is_changed(result):\n    ''' is a given JSON result a changed result? '''\n\n    return (result.get('changed', False) in [ True, 'True', 'true'])\n\ndef check_conditional(conditional, basedir, inject, fail_on_undefined=False):\n\n    if conditional is None or conditional == '':\n        return True\n\n    if isinstance(conditional, list):\n        for x in conditional:\n            if not check_conditional(x, basedir, inject, fail_on_undefined=fail_on_undefined):\n                return False\n        return True\n\n    if not isinstance(conditional, basestring):\n        return conditional\n\n    conditional = conditional.replace(\"jinja2_compare \",\"\")\n    # allow variable names\n    if conditional in inject and '-' not in str(inject[conditional]):\n        conditional = inject[conditional]\n    conditional = template.template(basedir, conditional, inject, fail_on_undefined=fail_on_undefined)\n    original = str(conditional).replace(\"jinja2_compare \",\"\")\n    # a Jinja2 evaluation that results in something Python can eval!\n    presented = \"{%% if %s %%} True {%% else %%} False {%% endif %%}\" % conditional\n    conditional = template.template(basedir, presented, inject)\n    val = conditional.strip()\n    if val == presented:\n        # the templating failed, meaning most likely a \n        # variable was undefined. If we happened to be \n        # looking for an undefined variable, return True,\n        # otherwise fail\n        if \"is undefined\" in conditional:\n            return True\n        elif \"is defined\" in conditional:\n            return False\n        else:\n            raise errors.AnsibleError(\"error while evaluating conditional: %s\" % original)\n    elif val == \"True\":\n        return True\n    elif val == \"False\":\n        return False\n    else:\n        raise errors.AnsibleError(\"unable to evaluate conditional: %s\" % original)\n\ndef is_executable(path):\n    '''is the given path executable?'''\n    return (stat.S_IXUSR & os.stat(path)[stat.ST_MODE]\n            or stat.S_IXGRP & os.stat(path)[stat.ST_MODE]\n            or stat.S_IXOTH & os.stat(path)[stat.ST_MODE])\n\ndef unfrackpath(path):\n    ''' \n    returns a path that is free of symlinks, environment\n    variables, relative path traversals and symbols (~)\n    example:\n    '$HOME/../../var/mail' becomes '/var/spool/mail'\n    '''\n    return os.path.normpath(os.path.realpath(os.path.expandvars(os.path.expanduser(path))))\n\ndef prepare_writeable_dir(tree,mode=0777):\n    ''' make sure a directory exists and is writeable '''\n\n    # modify the mode to ensure the owner at least\n    # has read/write access to this directory\n    mode |= 0700\n\n    # make sure the tree path is always expanded\n    # and normalized and free of symlinks\n    tree = unfrackpath(tree)\n\n    if not os.path.exists(tree):\n        try:\n            os.makedirs(tree, mode)\n        except (IOError, OSError), e:\n            raise errors.AnsibleError(\"Could not make dir %s: %s\" % (tree, e))\n    if not os.access(tree, os.W_OK):\n        raise errors.AnsibleError(\"Cannot write to path %s\" % tree)\n    return tree\n\ndef path_dwim(basedir, given):\n    '''\n    make relative paths work like folks expect.\n    '''\n\n    if given.startswith(\"/\"):\n        return os.path.abspath(given)\n    elif given.startswith(\"~\"):\n        return os.path.abspath(os.path.expanduser(given))\n    else:\n        if basedir is None:\n            basedir = \".\"\n        return os.path.abspath(os.path.join(basedir, given))\n\ndef path_dwim_relative(original, dirname, source, playbook_base, check=True):\n    ''' find one file in a directory one level up in a dir named dirname relative to current '''\n    # (used by roles code)\n\n    basedir = os.path.dirname(original)\n    if os.path.islink(basedir):\n        basedir = unfrackpath(basedir)\n        template2 = os.path.join(basedir, dirname, source)\n    else:\n        template2 = os.path.join(basedir, '..', dirname, source)\n    source2 = path_dwim(basedir, template2)\n    if os.path.exists(source2):\n        return source2\n    obvious_local_path = path_dwim(playbook_base, source)\n    if os.path.exists(obvious_local_path):\n        return obvious_local_path\n    if check:\n        raise errors.AnsibleError(\"input file not found at %s or %s\" % (source2, obvious_local_path))\n    return source2 # which does not exist\n\ndef json_loads(data):\n    ''' parse a JSON string and return a data structure '''\n\n    return json.loads(data)\n\ndef _clean_data(orig_data):\n    ''' remove template tags from a string '''\n    data = orig_data\n    if isinstance(orig_data, basestring):\n        for pattern,replacement in (('{{','{#'), ('}}','#}'), ('{%','{#'), ('%}','#}')):\n            data = data.replace(pattern, replacement)\n    return data\n\ndef _clean_data_struct(orig_data):\n    '''\n    walk a complex data structure, and use _clean_data() to\n    remove any template tags that may exist\n    '''\n    if isinstance(orig_data, dict):\n        data = orig_data.copy()\n        for key in data:\n            new_key = _clean_data_struct(key)\n            new_val = _clean_data_struct(data[key])\n            if key != new_key:\n                del data[key]\n            data[new_key] = new_val\n    elif isinstance(orig_data, list):\n        data = orig_data[:]\n        for i in range(0, len(data)):\n            data[i] = _clean_data_struct(data[i])\n    elif isinstance(orig_data, basestring):\n        data = _clean_data(orig_data)\n    else:\n        data = orig_data\n    return data\n\ndef parse_json(raw_data, from_remote=False):\n    ''' this version for module return data only '''\n\n    orig_data = raw_data\n\n    # ignore stuff like tcgetattr spewage or other warnings\n    data = filter_leading_non_json_lines(raw_data)\n\n    try:\n        results = json.loads(data)\n    except:\n        # not JSON, but try \"Baby JSON\" which allows many of our modules to not\n        # require JSON and makes writing modules in bash much simpler\n        results = {}\n        try:\n            tokens = shlex.split(data)\n        except:\n            print \"failed to parse json: \"+ data\n            raise\n        for t in tokens:\n            if \"=\" not in t:\n                raise errors.AnsibleError(\"failed to parse: %s\" % orig_data)\n            (key,value) = t.split(\"=\", 1)\n            if key == 'changed' or 'failed':\n                if value.lower() in [ 'true', '1' ]:\n                    value = True\n                elif value.lower() in [ 'false', '0' ]:\n                    value = False\n            if key == 'rc':\n                value = int(value)\n            results[key] = value\n        if len(results.keys()) == 0:\n            return { \"failed\" : True, \"parsed\" : False, \"msg\" : orig_data }\n\n    if from_remote:\n        results = _clean_data_struct(results)\n\n    return results\n\ndef smush_braces(data):\n    ''' smush Jinaj2 braces so unresolved templates like {{ foo }} don't get parsed weird by key=value code '''\n    while '{{ ' in data:\n        data = data.replace('{{ ', '{{')\n    while ' }}' in data:\n        data = data.replace(' }}', '}}')\n    return data\n\ndef smush_ds(data):\n    # things like key={{ foo }} are not handled by shlex.split well, so preprocess any YAML we load\n    # so we do not have to call smush elsewhere\n    if type(data) == list:\n        return [ smush_ds(x) for x in data ]\n    elif type(data) == dict:\n        for (k,v) in data.items():\n            data[k] = smush_ds(v)\n        return data\n    elif isinstance(data, basestring):\n        return smush_braces(data)\n    else:\n        return data\n\ndef parse_yaml(data, path_hint=None):\n    ''' convert a yaml string to a data structure.  Also supports JSON, ssssssh!!!'''\n\n    stripped_data = data.lstrip()\n    loaded = None\n    if stripped_data.startswith(\"{\") or stripped_data.startswith(\"[\"):\n        # since the line starts with { or [ we can infer this is a JSON document.\n        try:\n            loaded = json.loads(data)\n        except ValueError, ve:\n            if path_hint:\n                raise errors.AnsibleError(path_hint + \": \" + str(ve))\n            else:\n                raise errors.AnsibleError(str(ve))\n    else:\n        # else this is pretty sure to be a YAML document\n        loaded = yaml.safe_load(data)\n\n    return smush_ds(loaded)\n\ndef process_common_errors(msg, probline, column):\n    replaced = probline.replace(\" \",\"\")\n\n    if \":{{\" in replaced and \"}}\" in replaced:\n        msg = msg + \"\"\"\nThis one looks easy to fix.  YAML thought it was looking for the start of a \nhash/dictionary and was confused to see a second \"{\".  Most likely this was\nmeant to be an ansible template evaluation instead, so we have to give the \nparser a small hint that we wanted a string instead. The solution here is to \njust quote the entire value.\n\nFor instance, if the original line was:\n\n    app_path: {{ base_path }}/foo\n\nIt should be written as:\n\n    app_path: \"{{ base_path }}/foo\"\n\"\"\"\n        return msg\n\n    elif len(probline) and len(probline) > 1 and len(probline) > column and probline[column] == \":\" and probline.count(':') > 1:\n        msg = msg + \"\"\"\nThis one looks easy to fix.  There seems to be an extra unquoted colon in the line \nand this is confusing the parser. It was only expecting to find one free \ncolon. The solution is just add some quotes around the colon, or quote the \nentire line after the first colon.\n\nFor instance, if the original line was:\n\n    copy: src=file.txt dest=/path/filename:with_colon.txt\n\nIt can be written as:\n\n    copy: src=file.txt dest='/path/filename:with_colon.txt'\n\nOr:\n    \n    copy: 'src=file.txt dest=/path/filename:with_colon.txt'\n\n\n\"\"\"\n        return msg\n    else:\n        parts = probline.split(\":\")\n        if len(parts) > 1:\n            middle = parts[1].strip()\n            match = False\n            unbalanced = False\n            if middle.startswith(\"'\") and not middle.endswith(\"'\"):\n                match = True\n            elif middle.startswith('\"') and not middle.endswith('\"'):\n                match = True\n            if len(middle) > 0 and middle[0] in [ '\"', \"'\" ] and middle[-1] in [ '\"', \"'\" ] and probline.count(\"'\") > 2 or probline.count('\"') > 2:\n                unbalanced = True\n            if match:\n                msg = msg + \"\"\"\nThis one looks easy to fix.  It seems that there is a value started \nwith a quote, and the YAML parser is expecting to see the line ended \nwith the same kind of quote.  For instance:\n\n    when: \"ok\" in result.stdout\n\nCould be written as:\n\n   when: '\"ok\" in result.stdout'\n\nor equivalently:\n\n   when: \"'ok' in result.stdout\"\n\n\"\"\"\n                return msg\n\n            if unbalanced:\n                msg = msg + \"\"\"\nWe could be wrong, but this one looks like it might be an issue with \nunbalanced quotes.  If starting a value with a quote, make sure the \nline ends with the same set of quotes.  For instance this arbitrary \nexample:\n\n    foo: \"bad\" \"wolf\"\n\nCould be written as:\n\n    foo: '\"bad\" \"wolf\"'\n\n\"\"\"\n                return msg\n\n    return msg\n\ndef process_yaml_error(exc, data, path=None, show_content=True):\n    if hasattr(exc, 'problem_mark'):\n        mark = exc.problem_mark\n        if show_content:\n            if mark.line -1 >= 0:\n                before_probline = data.split(\"\\n\")[mark.line-1]\n            else:\n                before_probline = ''\n            probline = data.split(\"\\n\")[mark.line]\n            arrow = \" \" * mark.column + \"^\"\n            msg = \"\"\"Syntax Error while loading YAML script, %s\nNote: The error may actually appear before this position: line %s, column %s\n\n%s\n%s\n%s\"\"\" % (path, mark.line + 1, mark.column + 1, before_probline, probline, arrow)\n\n            unquoted_var = None\n            if '{{' in probline and '}}' in probline:\n                if '\"{{' not in probline or \"'{{\" not in probline:\n                    unquoted_var = True\n\n            if not unquoted_var:\n                msg = process_common_errors(msg, probline, mark.column)\n            else:\n                msg = msg + \"\"\"\nWe could be wrong, but this one looks like it might be an issue with\nmissing quotes.  Always quote template expression brackets when they \nstart a value. For instance:            \n\n    with_items:\n      - {{ foo }}\n\nShould be written as:\n\n    with_items:\n      - \"{{ foo }}\"      \n\n\"\"\"\n        else:\n            # most likely displaying a file with sensitive content,\n            # so don't show any of the actual lines of yaml just the\n            # line number itself\n            msg = \"\"\"Syntax error while loading YAML script, %s\nThe error appears to have been on line %s, column %s, but may actually\nbe before there depending on the exact syntax problem.\n\"\"\" % (path, mark.line + 1, mark.column + 1)\n\n    else:\n        # No problem markers means we have to throw a generic\n        # \"stuff messed up\" type message. Sry bud.\n        if path:\n            msg = \"Could not parse YAML. Check over %s again.\" % path\n        else:\n            msg = \"Could not parse YAML.\"\n    raise errors.AnsibleYAMLValidationFailed(msg)\n\n\ndef parse_yaml_from_file(path, vault_password=None):\n    ''' convert a yaml file to a data structure '''\n\n    data = None\n    show_content = True\n\n    try:\n        data = open(path).read()\n    except IOError:\n        raise errors.AnsibleError(\"file could not read: %s\" % path)\n\n    vault = VaultLib(password=vault_password)\n    if vault.is_encrypted(data):\n        data = vault.decrypt(data)\n        show_content = False\n\n    try:\n        return parse_yaml(data, path_hint=path)\n    except yaml.YAMLError, exc:\n        process_yaml_error(exc, data, path, show_content)\n\ndef parse_kv(args):\n    ''' convert a string of key/value items to a dict '''\n    options = {}\n    if args is not None:\n        # attempting to split a unicode here does bad things\n        args = args.encode('utf-8')\n        try:\n            vargs = shlex.split(args, posix=True)\n        except ValueError, ve:\n            if 'no closing quotation' in str(ve).lower():\n                raise errors.AnsibleError(\"error parsing argument string, try quoting the entire line.\")\n            else:\n                raise\n        vargs = [x.decode('utf-8') for x in vargs]\n        for x in vargs:\n            if \"=\" in x:\n                k, v = x.split(\"=\",1)\n                options[k]=v\n    return options\n\ndef merge_hash(a, b):\n    ''' recursively merges hash b into a\n    keys from b take precedence over keys from a '''\n\n    result = copy.deepcopy(a)\n\n    # next, iterate over b keys and values\n    for k, v in b.iteritems():\n        # if there's already such key in a\n        # and that key contains dict\n        if k in result and isinstance(result[k], dict):\n            # merge those dicts recursively\n            result[k] = merge_hash(a[k], v)\n        else:\n            # otherwise, just copy a value from b to a\n            result[k] = v\n\n    return result\n\ndef md5s(data):\n    ''' Return MD5 hex digest of data. '''\n\n    digest = _md5()\n    try:\n        digest.update(data)\n    except UnicodeEncodeError:\n        digest.update(data.encode('utf-8'))\n    return digest.hexdigest()\n\ndef md5(filename):\n    ''' Return MD5 hex digest of local file, None if file is not present or a directory. '''\n\n    if not os.path.exists(filename) or os.path.isdir(filename):\n        return None\n    digest = _md5()\n    blocksize = 64 * 1024\n    try:\n        infile = open(filename, 'rb')\n        block = infile.read(blocksize)\n        while block:\n            digest.update(block)\n            block = infile.read(blocksize)\n        infile.close()\n    except IOError, e:\n        raise errors.AnsibleError(\"error while accessing the file %s, error was: %s\" % (filename, e))\n    return digest.hexdigest()\n\ndef default(value, function):\n    ''' syntactic sugar around lazy evaluation of defaults '''\n    if value is None:\n        return function()\n    return value\n\ndef _gitinfo():\n    ''' returns a string containing git branch, commit id and commit date '''\n    result = None\n    repo_path = os.path.join(os.path.dirname(__file__), '..', '..', '..', '.git')\n\n    if os.path.exists(repo_path):\n        # Check if the .git is a file. If it is a file, it means that we are in a submodule structure.\n        if os.path.isfile(repo_path):\n            try:\n                gitdir = yaml.safe_load(open(repo_path)).get('gitdir')\n                # There is a posibility the .git file to have an absolute path.\n                if os.path.isabs(gitdir):\n                    repo_path = gitdir\n                else:\n                    repo_path = os.path.join(repo_path.split('.git')[0], gitdir)\n            except (IOError, AttributeError):\n                return ''\n        f = open(os.path.join(repo_path, \"HEAD\"))\n        branch = f.readline().split('/')[-1].rstrip(\"\\n\")\n        f.close()\n        branch_path = os.path.join(repo_path, \"refs\", \"heads\", branch)\n        if os.path.exists(branch_path):\n            f = open(branch_path)\n            commit = f.readline()[:10]\n            f.close()\n            date = time.localtime(os.stat(branch_path).st_mtime)\n            if time.daylight == 0:\n                offset = time.timezone\n            else:\n                offset = time.altzone\n            result = \"({0} {1}) last updated {2} (GMT {3:+04d})\".format(branch, commit,\n                time.strftime(\"%Y/%m/%d %H:%M:%S\", date), offset / -36)\n    else:\n        result = ''\n    return result\n\ndef version(prog):\n    result = \"{0} {1}\".format(prog, __version__)\n    gitinfo = _gitinfo()\n    if gitinfo:\n        result = result + \" {0}\".format(gitinfo)\n    return result\n\ndef getch():\n    ''' read in a single character '''\n    fd = sys.stdin.fileno()\n    old_settings = termios.tcgetattr(fd)\n    try:\n        tty.setraw(sys.stdin.fileno())\n        ch = sys.stdin.read(1)\n    finally:\n        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n    return ch\n\ndef sanitize_output(str):\n    ''' strips private info out of a string '''\n\n    private_keys = ['password', 'login_password']\n\n    filter_re = [\n        # filter out things like user:pass@foo/whatever\n        # and http://username:pass@wherever/foo\n        re.compile('^(?P<before>.*:)(?P<password>.*)(?P<after>\\@.*)$'),\n    ]\n\n    parts = str.split()\n    output = ''\n    for part in parts:\n        try:\n            (k,v) = part.split('=', 1)\n            if k in private_keys:\n                output += \" %s=VALUE_HIDDEN\" % k\n            else:\n                found = False\n                for filter in filter_re:\n                    m = filter.match(v)\n                    if m:\n                        d = m.groupdict()\n                        output += \" %s=%s\" % (k, d['before'] + \"********\" + d['after'])\n                        found = True\n                        break\n                if not found:\n                    output += \" %s\" % part\n        except:\n            output += \" %s\" % part\n\n    return output.strip()\n\n####################################################################\n# option handling code for /usr/bin/ansible and ansible-playbook\n# below this line\n\nclass SortedOptParser(optparse.OptionParser):\n    '''Optparser which sorts the options by opt before outputting --help'''\n\n    def format_help(self, formatter=None):\n        self.option_list.sort(key=operator.methodcaller('get_opt_string'))\n        return optparse.OptionParser.format_help(self, formatter=None)\n\ndef increment_debug(option, opt, value, parser):\n    global VERBOSITY\n    VERBOSITY += 1\n\ndef base_parser(constants=C, usage=\"\", output_opts=False, runas_opts=False,\n    async_opts=False, connect_opts=False, subset_opts=False, check_opts=False, diff_opts=False):\n    ''' create an options parser for any ansible script '''\n\n    parser = SortedOptParser(usage, version=version(\"%prog\"))\n    parser.add_option('-v','--verbose', default=False, action=\"callback\",\n        callback=increment_debug, help=\"verbose mode (-vvv for more, -vvvv to enable connection debugging)\")\n\n    parser.add_option('-f','--forks', dest='forks', default=constants.DEFAULT_FORKS, type='int',\n        help=\"specify number of parallel processes to use (default=%s)\" % constants.DEFAULT_FORKS)\n    parser.add_option('-i', '--inventory-file', dest='inventory',\n        help=\"specify inventory host file (default=%s)\" % constants.DEFAULT_HOST_LIST,\n        default=constants.DEFAULT_HOST_LIST)\n    parser.add_option('-k', '--ask-pass', default=False, dest='ask_pass', action='store_true',\n        help='ask for SSH password')\n    parser.add_option('--private-key', default=C.DEFAULT_PRIVATE_KEY_FILE, dest='private_key_file',\n        help='use this file to authenticate the connection')\n    parser.add_option('-K', '--ask-sudo-pass', default=False, dest='ask_sudo_pass', action='store_true',\n        help='ask for sudo password')\n    parser.add_option('--ask-su-pass', default=False, dest='ask_su_pass', action='store_true', \n        help='ask for su password')\n    parser.add_option('--ask-vault-pass', default=False, dest='ask_vault_pass', action='store_true', \n        help='ask for vault password')\n    parser.add_option('--vault-password-file', default=None, dest='vault_password_file',\n        help=\"vault password file\")\n    parser.add_option('--list-hosts', dest='listhosts', action='store_true',\n        help='outputs a list of matching hosts; does not execute anything else')\n    parser.add_option('-M', '--module-path', dest='module_path',\n        help=\"specify path(s) to module library (default=%s)\" % constants.DEFAULT_MODULE_PATH,\n        default=None)\n\n    if subset_opts:\n        parser.add_option('-l', '--limit', default=constants.DEFAULT_SUBSET, dest='subset',\n            help='further limit selected hosts to an additional pattern')\n\n    parser.add_option('-T', '--timeout', default=constants.DEFAULT_TIMEOUT, type='int',\n        dest='timeout',\n        help=\"override the SSH timeout in seconds (default=%s)\" % constants.DEFAULT_TIMEOUT)\n\n    if output_opts:\n        parser.add_option('-o', '--one-line', dest='one_line', action='store_true',\n            help='condense output')\n        parser.add_option('-t', '--tree', dest='tree', default=None,\n            help='log output to this directory')\n\n    if runas_opts:\n        parser.add_option(\"-s\", \"--sudo\", default=constants.DEFAULT_SUDO, action=\"store_true\",\n            dest='sudo', help=\"run operations with sudo (nopasswd)\")\n        parser.add_option('-U', '--sudo-user', dest='sudo_user', default=None,\n                          help='desired sudo user (default=root)')  # Can't default to root because we need to detect when this option was given\n        parser.add_option('-u', '--user', default=constants.DEFAULT_REMOTE_USER,\n            dest='remote_user', help='connect as this user (default=%s)' % constants.DEFAULT_REMOTE_USER)\n\n        parser.add_option('-S', '--su', default=constants.DEFAULT_SU,\n                          action='store_true', help='run operations with su')\n        parser.add_option('-R', '--su-user', help='run operations with su as this '\n                                                  'user (default=%s)' % constants.DEFAULT_SU_USER)\n\n    if connect_opts:\n        parser.add_option('-c', '--connection', dest='connection',\n                          default=C.DEFAULT_TRANSPORT,\n                          help=\"connection type to use (default=%s)\" % C.DEFAULT_TRANSPORT)\n\n    if async_opts:\n        parser.add_option('-P', '--poll', default=constants.DEFAULT_POLL_INTERVAL, type='int',\n            dest='poll_interval',\n            help=\"set the poll interval if using -B (default=%s)\" % constants.DEFAULT_POLL_INTERVAL)\n        parser.add_option('-B', '--background', dest='seconds', type='int', default=0,\n            help='run asynchronously, failing after X seconds (default=N/A)')\n\n    if check_opts:\n        parser.add_option(\"-C\", \"--check\", default=False, dest='check', action='store_true',\n            help=\"don't make any changes; instead, try to predict some of the changes that may occur\"\n        )\n\n    if diff_opts:\n        parser.add_option(\"-D\", \"--diff\", default=False, dest='diff', action='store_true',\n            help=\"when changing (small) files and templates, show the differences in those files; works great with --check\"\n        )\n\n\n    return parser\n\ndef ask_vault_passwords(ask_vault_pass=False, ask_new_vault_pass=False, confirm_vault=False, confirm_new=False):\n\n    vault_pass = None\n    new_vault_pass = None\n\n    if ask_vault_pass:\n        vault_pass = getpass.getpass(prompt=\"Vault password: \")\n\n    if ask_vault_pass and confirm_vault:\n        vault_pass2 = getpass.getpass(prompt=\"Confirm Vault password: \")\n        if vault_pass != vault_pass2:\n            raise errors.AnsibleError(\"Passwords do not match\")\n\n    if ask_new_vault_pass:\n        new_vault_pass = getpass.getpass(prompt=\"New Vault password: \")\n\n    if ask_new_vault_pass and confirm_new:\n        new_vault_pass2 = getpass.getpass(prompt=\"Confirm New Vault password: \")\n        if new_vault_pass != new_vault_pass2:\n            raise errors.AnsibleError(\"Passwords do not match\")\n\n    # enforce no newline chars at the end of passwords\n    if vault_pass:\n        vault_pass = vault_pass.strip()\n    if new_vault_pass:\n        new_vault_pass = new_vault_pass.strip()\n\n    return vault_pass, new_vault_pass\n\ndef ask_passwords(ask_pass=False, ask_sudo_pass=False, ask_su_pass=False, ask_vault_pass=False):\n    sshpass = None\n    sudopass = None\n    su_pass = None\n    vault_pass = None\n    sudo_prompt = \"sudo password: \"\n    su_prompt = \"su password: \"\n\n    if ask_pass:\n        sshpass = getpass.getpass(prompt=\"SSH password: \")\n        sudo_prompt = \"sudo password [defaults to SSH password]: \"\n\n    if ask_sudo_pass:\n        sudopass = getpass.getpass(prompt=sudo_prompt)\n        if ask_pass and sudopass == '':\n            sudopass = sshpass\n\n    if ask_su_pass:\n        su_pass = getpass.getpass(prompt=su_prompt)\n\n    if ask_vault_pass:\n        vault_pass = getpass.getpass(prompt=\"Vault password: \")\n\n    return (sshpass, sudopass, su_pass, vault_pass)\n\ndef do_encrypt(result, encrypt, salt_size=None, salt=None):\n    if PASSLIB_AVAILABLE:\n        try:\n            crypt = getattr(passlib.hash, encrypt)\n        except:\n            raise errors.AnsibleError(\"passlib does not support '%s' algorithm\" % encrypt)\n\n        if salt_size:\n            result = crypt.encrypt(result, salt_size=salt_size)\n        elif salt:\n            result = crypt.encrypt(result, salt=salt)\n        else:\n            result = crypt.encrypt(result)\n    else:\n        raise errors.AnsibleError(\"passlib must be installed to encrypt vars_prompt values\")\n\n    return result\n\ndef last_non_blank_line(buf):\n\n    all_lines = buf.splitlines()\n    all_lines.reverse()\n    for line in all_lines:\n        if (len(line) > 0):\n            return line\n    # shouldn't occur unless there's no output\n    return \"\"\n\ndef filter_leading_non_json_lines(buf):\n    '''\n    used to avoid random output from SSH at the top of JSON output, like messages from\n    tcagetattr, or where dropbear spews MOTD on every single command (which is nuts).\n\n    need to filter anything which starts not with '{', '[', ', '=' or is an empty line.\n    filter only leading lines since multiline JSON is valid.\n    '''\n\n    kv_regex = re.compile(r'.*\\w+=\\w+.*')\n    filtered_lines = StringIO.StringIO()\n    stop_filtering = False\n    for line in buf.splitlines():\n        if stop_filtering or kv_regex.match(line) or line.startswith('{') or line.startswith('['):\n            stop_filtering = True\n            filtered_lines.write(line + '\\n')\n    return filtered_lines.getvalue()\n\ndef boolean(value):\n    val = str(value)\n    if val.lower() in [ \"true\", \"t\", \"y\", \"1\", \"yes\" ]:\n        return True\n    else:\n        return False\n\ndef make_sudo_cmd(sudo_user, executable, cmd):\n    \"\"\"\n    helper function for connection plugins to create sudo commands\n    \"\"\"\n    # Rather than detect if sudo wants a password this time, -k makes\n    # sudo always ask for a password if one is required.\n    # Passing a quoted compound command to sudo (or sudo -s)\n    # directly doesn't work, so we shellquote it with pipes.quote()\n    # and pass the quoted string to the user's shell.  We loop reading\n    # output until we see the randomly-generated sudo prompt set with\n    # the -p option.\n    randbits = ''.join(chr(random.randint(ord('a'), ord('z'))) for x in xrange(32))\n    prompt = '[sudo via ansible, key=%s] password: ' % randbits\n    success_key = 'SUDO-SUCCESS-%s' % randbits\n    sudocmd = '%s -k && %s %s -S -p \"%s\" -u %s %s -c %s' % (\n        C.DEFAULT_SUDO_EXE, C.DEFAULT_SUDO_EXE, C.DEFAULT_SUDO_FLAGS,\n        prompt, sudo_user, executable or '$SHELL', pipes.quote('echo %s; %s' % (success_key, cmd)))\n    return ('/bin/sh -c ' + pipes.quote(sudocmd), prompt, success_key)\n\n\ndef make_su_cmd(su_user, executable, cmd):\n    \"\"\"\n    Helper function for connection plugins to create direct su commands\n    \"\"\"\n    # TODO: work on this function\n    randbits = ''.join(chr(random.randint(ord('a'), ord('z'))) for x in xrange(32))\n    prompt = '[Pp]assword: ?$'\n    success_key = 'SUDO-SUCCESS-%s' % randbits\n    sudocmd = '%s %s %s -c \"%s -c %s\"' % (\n        C.DEFAULT_SU_EXE, C.DEFAULT_SU_FLAGS, su_user, executable or '$SHELL',\n        pipes.quote('echo %s; %s' % (success_key, cmd))\n    )\n    return ('/bin/sh -c ' + pipes.quote(sudocmd), prompt, success_key)\n\n_TO_UNICODE_TYPES = (unicode, type(None))\n\ndef to_unicode(value):\n    if isinstance(value, _TO_UNICODE_TYPES):\n        return value\n    return value.decode(\"utf-8\")\n\ndef get_diff(diff):\n    # called by --diff usage in playbook and runner via callbacks\n    # include names in diffs 'before' and 'after' and do diff -U 10\n\n    try:\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore')\n            ret = []\n            if 'dst_binary' in diff:\n                ret.append(\"diff skipped: destination file appears to be binary\\n\")\n            if 'src_binary' in diff:\n                ret.append(\"diff skipped: source file appears to be binary\\n\")\n            if 'dst_larger' in diff:\n                ret.append(\"diff skipped: destination file size is greater than %d\\n\" % diff['dst_larger'])\n            if 'src_larger' in diff:\n                ret.append(\"diff skipped: source file size is greater than %d\\n\" % diff['src_larger'])\n            if 'before' in diff and 'after' in diff:\n                if 'before_header' in diff:\n                    before_header = \"before: %s\" % diff['before_header']\n                else:\n                    before_header = 'before'\n                if 'after_header' in diff:\n                    after_header = \"after: %s\" % diff['after_header']\n                else:\n                    after_header = 'after'\n                differ = difflib.unified_diff(to_unicode(diff['before']).splitlines(True), to_unicode(diff['after']).splitlines(True), before_header, after_header, '', '', 10)\n                for line in list(differ):\n                    ret.append(line)\n            return u\"\".join(ret)\n    except UnicodeDecodeError:\n        return \">> the files are different, but the diff library cannot compare unicode strings\"\n\ndef is_list_of_strings(items):\n    for x in items:\n        if not isinstance(x, basestring):\n            return False\n    return True\n\ndef list_union(a, b):\n    result = []\n    for x in a:\n        if x not in result:\n            result.append(x)\n    for x in b:\n        if x not in result:\n            result.append(x)\n    return result\n\ndef list_intersection(a, b):\n    result = []\n    for x in a:\n        if x in b and x not in result:\n            result.append(x)\n    return result\n\ndef safe_eval(expr, locals={}, include_exceptions=False):\n    '''\n    this is intended for allowing things like:\n    with_items: a_list_variable\n    where Jinja2 would return a string\n    but we do not want to allow it to call functions (outside of Jinja2, where\n    the env is constrained)\n\n    Based on:\n    http://stackoverflow.com/questions/12523516/using-ast-and-whitelists-to-make-pythons-eval-safe\n    '''\n\n    # this is the whitelist of AST nodes we are going to \n    # allow in the evaluation. Any node type other than \n    # those listed here will raise an exception in our custom\n    # visitor class defined below.\n    SAFE_NODES = set(\n        (\n            ast.Add,\n            ast.BinOp,\n            ast.Call,\n            ast.Compare,\n            ast.Dict,\n            ast.Div,\n            ast.Expression,\n            ast.List,\n            ast.Load,\n            ast.Mult,\n            ast.Num,\n            ast.Name,\n            ast.Str,\n            ast.Sub,\n            ast.Tuple,\n            ast.UnaryOp,\n        )\n    )\n\n    # AST node types were expanded after 2.6\n    if not sys.version.startswith('2.6'):\n        SAFE_NODES.union(\n            set(\n                (ast.Set,)\n            )\n        )\n\n    filter_list = []\n    for filter in filter_loader.all():\n        filter_list.extend(filter.filters().keys())\n\n    CALL_WHITELIST = C.DEFAULT_CALLABLE_WHITELIST + filter_list\n\n    class CleansingNodeVisitor(ast.NodeVisitor):\n        def generic_visit(self, node, inside_call=False):\n            if type(node) not in SAFE_NODES:\n                raise Exception(\"invalid expression (%s)\" % expr)\n            elif isinstance(node, ast.Call):\n                inside_call = True\n            elif isinstance(node, ast.Name) and inside_call:\n                if hasattr(builtin, node.id) and node.id not in CALL_WHITELIST:\n                    raise Exception(\"invalid function: %s\" % node.id)\n            # iterate over all child nodes\n            for child_node in ast.iter_child_nodes(node):\n                self.generic_visit(child_node, inside_call)\n\n    if not isinstance(expr, basestring):\n        # already templated to a datastructure, perhaps?\n        if include_exceptions:\n            return (expr, None)\n        return expr\n\n    cnv = CleansingNodeVisitor()\n    try:\n        parsed_tree = ast.parse(expr, mode='eval')\n        cnv.visit(parsed_tree)\n        compiled = compile(parsed_tree, expr, 'eval')\n        result = eval(compiled, {}, locals)\n\n        if include_exceptions:\n            return (result, None)\n        else:\n            return result\n    except SyntaxError, e:\n        # special handling for syntax errors, we just return\n        # the expression string back as-is\n        if include_exceptions:\n            return (expr, None)\n        return expr\n    except Exception, e:\n        if include_exceptions:\n            return (expr, e)\n        return expr\n\n\ndef listify_lookup_plugin_terms(terms, basedir, inject):\n\n    if isinstance(terms, basestring):\n        # someone did:\n        #    with_items: alist\n        # OR\n        #    with_items: {{ alist }}\n\n        stripped = terms.strip()\n        if not (stripped.startswith('{') or stripped.startswith('[')) and not stripped.startswith(\"/\") and not stripped.startswith('set(['):\n            # if not already a list, get ready to evaluate with Jinja2\n            # not sure why the \"/\" is in above code :)\n            try:\n                new_terms = template.template(basedir, \"{{ %s }}\" % terms, inject)\n                if isinstance(new_terms, basestring) and \"{{\" in new_terms:\n                    pass\n                else:\n                    terms = new_terms\n            except:\n                pass\n\n        if '{' in terms or '[' in terms:\n            # Jinja2 already evaluated a variable to a list.\n            # Jinja2-ified list needs to be converted back to a real type\n            # TODO: something a bit less heavy than eval\n            return safe_eval(terms)\n\n        if isinstance(terms, basestring):\n            terms = [ terms ]\n\n    return terms\n\ndef combine_vars(a, b):\n\n    if C.DEFAULT_HASH_BEHAVIOUR == \"merge\":\n        return merge_hash(a, b)\n    else:\n        return dict(a.items() + b.items())\n\ndef random_password(length=20, chars=C.DEFAULT_PASSWORD_CHARS):\n    '''Return a random password string of length containing only chars.'''\n\n    password = []\n    while len(password) < length:\n        new_char = os.urandom(1)\n        if new_char in chars:\n            password.append(new_char)\n\n    return ''.join(password)\n\ndef before_comment(msg):\n    ''' what's the part of a string before a comment? '''\n    msg = msg.replace(\"\\#\",\"**NOT_A_COMMENT**\")\n    msg = msg.split(\"#\")[0]\n    msg = msg.replace(\"**NOT_A_COMMENT**\",\"#\")\n    return msg\n\n\n\n", "# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport re\nimport codecs\nimport jinja2\nfrom jinja2.runtime import StrictUndefined\nfrom jinja2.exceptions import TemplateSyntaxError\nimport yaml\nimport json\nfrom ansible import errors\nimport ansible.constants as C\nimport time\nimport subprocess\nimport datetime\nimport pwd\nimport ast\nimport traceback\n\nfrom ansible.utils.string_functions import count_newlines_from_end\n\nclass Globals(object):\n\n    FILTERS = None\n\n    def __init__(self):\n        pass\n\ndef _get_filters():\n    ''' return filter plugin instances '''\n\n    if Globals.FILTERS is not None:\n        return Globals.FILTERS\n\n    from ansible import utils\n    plugins = [ x for x in utils.plugins.filter_loader.all()]\n    filters = {}\n    for fp in plugins:\n        filters.update(fp.filters())\n    Globals.FILTERS = filters\n\n    return Globals.FILTERS\n\ndef _get_extensions():\n    ''' return jinja2 extensions to load '''\n\n    '''\n    if some extensions are set via jinja_extensions in ansible.cfg, we try\n    to load them with the jinja environment\n    '''\n    jinja_exts = []\n    if C.DEFAULT_JINJA2_EXTENSIONS:\n        '''\n        Let's make sure the configuration directive doesn't contain spaces\n        and split extensions in an array\n        '''\n        jinja_exts = C.DEFAULT_JINJA2_EXTENSIONS.replace(\" \", \"\").split(',')\n\n    return jinja_exts\n\nclass Flags:\n    LEGACY_TEMPLATE_WARNING = False\n\n# TODO: refactor this file\n\nFILTER_PLUGINS = None\n_LISTRE = re.compile(r\"(\\w+)\\[(\\d+)\\]\")\n\ndef lookup(name, *args, **kwargs):\n    from ansible import utils\n    instance = utils.plugins.lookup_loader.get(name.lower(), basedir=kwargs.get('basedir',None))\n    vars = kwargs.get('vars', None)\n\n    if instance is not None:\n        # safely catch run failures per #5059\n        try:\n            ran = instance.run(*args, inject=vars, **kwargs)\n        except errors.AnsibleError:\n            # Plugin raised this on purpose\n            raise\n        except Exception, e:\n            ran = None\n        if ran:\n            ran = \",\".join(ran)\n        return ran\n    else:\n        raise errors.AnsibleError(\"lookup plugin (%s) not found\" % name)\n\ndef template(basedir, varname, vars, lookup_fatal=True, depth=0, expand_lists=True, convert_bare=False, fail_on_undefined=False, filter_fatal=True):\n    ''' templates a data structure by traversing it and substituting for other data structures '''\n    from ansible import utils\n\n    try:\n        if convert_bare and isinstance(varname, basestring):\n            first_part = varname.split(\".\")[0].split(\"[\")[0]\n            if first_part in vars and '{{' not in varname and '$' not in varname:\n                varname = \"{{%s}}\" % varname\n    \n        if isinstance(varname, basestring):\n            if '{{' in varname or '{%' in varname:\n                varname = template_from_string(basedir, varname, vars, fail_on_undefined)\n\n                if (varname.startswith(\"{\") and not varname.startswith(\"{{\")) or varname.startswith(\"[\"):\n                    eval_results = utils.safe_eval(varname, locals=vars, include_exceptions=True)\n                    if eval_results[1] is None:\n                        varname = eval_results[0]\n\n            return varname\n    \n        elif isinstance(varname, (list, tuple)):\n            return [template(basedir, v, vars, lookup_fatal, depth, expand_lists, fail_on_undefined=fail_on_undefined) for v in varname]\n        elif isinstance(varname, dict):\n            d = {}\n            for (k, v) in varname.iteritems():\n                d[k] = template(basedir, v, vars, lookup_fatal, depth, expand_lists, fail_on_undefined=fail_on_undefined)\n            return d\n        else:\n            return varname\n    except errors.AnsibleFilterError:\n        if filter_fatal:\n            raise\n        else:\n            return varname\n\n\nclass _jinja2_vars(object):\n    '''\n    Helper class to template all variable content before jinja2 sees it.\n    This is done by hijacking the variable storage that jinja2 uses, and\n    overriding __contains__ and __getitem__ to look like a dict. Added bonus\n    is avoiding duplicating the large hashes that inject tends to be.\n    To facilitate using builtin jinja2 things like range, globals are handled\n    here.\n    extras is a list of locals to also search for variables.\n    '''\n\n    def __init__(self, basedir, vars, globals, fail_on_undefined, *extras):\n        self.basedir = basedir\n        self.vars = vars\n        self.globals = globals\n        self.fail_on_undefined = fail_on_undefined\n        self.extras = extras\n\n    def __contains__(self, k):\n        if k in self.vars:\n            return True\n        for i in self.extras:\n            if k in i:\n                return True\n        if k in self.globals:\n            return True\n        return False\n\n    def __getitem__(self, varname):\n        if varname not in self.vars:\n            for i in self.extras:\n                if varname in i:\n                    return i[varname]\n            if varname in self.globals:\n                return self.globals[varname]\n            else:\n                raise KeyError(\"undefined variable: %s\" % varname)\n        var = self.vars[varname]\n        # HostVars is special, return it as-is\n        if isinstance(var, dict) and type(var) != dict:\n            return var\n        else:\n            return template(self.basedir, var, self.vars, fail_on_undefined=self.fail_on_undefined)\n\n    def add_locals(self, locals):\n        '''\n        If locals are provided, create a copy of self containing those\n        locals in addition to what is already in this variable proxy.\n        '''\n        if locals is None:\n            return self\n        return _jinja2_vars(self.basedir, self.vars, self.globals, self.fail_on_undefined, locals, *self.extras)\n\nclass J2Template(jinja2.environment.Template):\n    '''\n    This class prevents Jinja2 from running _jinja2_vars through dict()\n    Without this, {% include %} and similar will create new contexts unlike\n    the special one created in template_from_file. This ensures they are all\n    alike, with the exception of potential locals.\n    '''\n    def new_context(self, vars=None, shared=False, locals=None):\n        return jinja2.runtime.Context(self.environment, vars.add_locals(locals), self.name, self.blocks)\n\ndef template_from_file(basedir, path, vars, vault_password=None):\n    ''' run a file through the templating engine '''\n\n    fail_on_undefined = C.DEFAULT_UNDEFINED_VAR_BEHAVIOR\n\n    from ansible import utils\n    realpath = utils.path_dwim(basedir, path)\n    loader=jinja2.FileSystemLoader([basedir,os.path.dirname(realpath)])\n\n    def my_lookup(*args, **kwargs):\n        kwargs['vars'] = vars\n        return lookup(*args, basedir=basedir, **kwargs)\n    def my_finalize(thing):\n        return thing if thing is not None else ''\n\n    environment = jinja2.Environment(loader=loader, trim_blocks=True, extensions=_get_extensions())\n    environment.filters.update(_get_filters())\n    environment.globals['lookup'] = my_lookup\n    environment.globals['finalize'] = my_finalize\n    if fail_on_undefined:\n        environment.undefined = StrictUndefined\n\n    try:\n        data = codecs.open(realpath, encoding=\"utf8\").read()\n    except UnicodeDecodeError:\n        raise errors.AnsibleError(\"unable to process as utf-8: %s\" % realpath)\n    except:\n        raise errors.AnsibleError(\"unable to read %s\" % realpath)\n\n    environment.template_class = J2Template\n    try:\n        t = environment.from_string(data)\n    except TemplateSyntaxError, e:\n        # Throw an exception which includes a more user friendly error message\n        values = {'name': realpath, 'lineno': e.lineno, 'error': str(e)}\n        msg = 'file: %(name)s, line number: %(lineno)s, error: %(error)s' % \\\n               values\n        error = errors.AnsibleError(msg)\n        raise error\n    vars = vars.copy()\n    try:\n        template_uid = pwd.getpwuid(os.stat(realpath).st_uid).pw_name\n    except:\n        template_uid = os.stat(realpath).st_uid\n    vars['template_host']   = os.uname()[1]\n    vars['template_path']   = realpath\n    vars['template_mtime']  = datetime.datetime.fromtimestamp(os.path.getmtime(realpath))\n    vars['template_uid']    = template_uid\n    vars['template_fullpath'] = os.path.abspath(realpath)\n    vars['template_run_date'] = datetime.datetime.now()\n\n    managed_default = C.DEFAULT_MANAGED_STR\n    managed_str = managed_default.format(\n        host = vars['template_host'],\n        uid  = vars['template_uid'],\n        file = vars['template_path']\n    )\n    vars['ansible_managed'] = time.strftime(\n        managed_str,\n        time.localtime(os.path.getmtime(realpath))\n    )\n\n    # This line performs deep Jinja2 magic that uses the _jinja2_vars object for vars\n    # Ideally, this could use some API where setting shared=True and the object won't get\n    # passed through dict(o), but I have not found that yet.\n    try:\n        res = jinja2.utils.concat(t.root_render_func(t.new_context(_jinja2_vars(basedir, vars, t.globals, fail_on_undefined), shared=True)))\n    except jinja2.exceptions.UndefinedError, e:\n        raise errors.AnsibleUndefinedVariable(\"One or more undefined variables: %s\" % str(e))\n    except jinja2.exceptions.TemplateNotFound, e:\n        # Throw an exception which includes a more user friendly error message\n        # This likely will happen for included sub-template. Not that besides\n        # pure \"file not found\" it may happen due to Jinja2's \"security\"\n        # checks on path.\n        values = {'name': realpath, 'subname': str(e)}\n        msg = 'file: %(name)s, error: Cannot find/not allowed to load (include) template %(subname)s' % \\\n               values\n        error = errors.AnsibleError(msg)\n        raise error\n\n    # The low level calls above do not preserve the newline\n    # characters at the end of the input data, so we use the\n    # calculate the difference in newlines and append them \n    # to the resulting output for parity\n    res_newlines  = count_newlines_from_end(res)\n    data_newlines = count_newlines_from_end(data)\n    if data_newlines > res_newlines:\n        res += '\\n' * (data_newlines - res_newlines)\n\n    if isinstance(res, unicode):\n        # do not try to re-template a unicode string\n        result = res\n    else:\n        result = template(basedir, res, vars)\n\n    return result\n\ndef template_from_string(basedir, data, vars, fail_on_undefined=False):\n    ''' run a string through the (Jinja2) templating engine '''\n\n    try:\n        if type(data) == str:\n            data = unicode(data, 'utf-8')\n\n        def my_finalize(thing):\n            return thing if thing is not None else ''\n\n        environment = jinja2.Environment(trim_blocks=True, undefined=StrictUndefined, extensions=_get_extensions(), finalize=my_finalize)\n        environment.filters.update(_get_filters())\n        environment.template_class = J2Template\n\n        if '_original_file' in vars:\n            basedir = os.path.dirname(vars['_original_file'])\n            filesdir = os.path.abspath(os.path.join(basedir, '..', 'files'))\n            if os.path.exists(filesdir):\n                basedir = filesdir\n\n        # 6227\n        if isinstance(data, unicode):\n            try:\n                data = data.decode('utf-8')\n            except UnicodeEncodeError, e:\n                pass\n\n        try:\n            t = environment.from_string(data)\n        except Exception, e:\n            if 'recursion' in str(e):\n                raise errors.AnsibleError(\"recursive loop detected in template string: %s\" % data)\n            else:\n                return data\n\n        def my_lookup(*args, **kwargs):\n            kwargs['vars'] = vars\n            return lookup(*args, basedir=basedir, **kwargs)\n\n        t.globals['lookup'] = my_lookup\n        t.globals['finalize'] = my_finalize\n        jvars =_jinja2_vars(basedir, vars, t.globals, fail_on_undefined)\n        new_context = t.new_context(jvars, shared=True)\n        rf = t.root_render_func(new_context)\n        try:\n            res = jinja2.utils.concat(rf)\n        except TypeError, te:\n            if 'StrictUndefined' in str(te):\n                raise errors.AnsibleUndefinedVariable(\n                    \"Unable to look up a name or access an attribute in template string. \" + \\\n                    \"Make sure your variable name does not contain invalid characters like '-'.\"\n                )\n            else:\n                raise errors.AnsibleError(\"an unexpected type error occured. Error was %s\" % te)\n        return res\n    except (jinja2.exceptions.UndefinedError, errors.AnsibleUndefinedVariable):\n        if fail_on_undefined:\n            raise\n        else:\n            return data\n\n"], "filenames": ["lib/ansible/inventory/script.py", "lib/ansible/runner/__init__.py", "lib/ansible/runner/return_data.py", "lib/ansible/utils/__init__.py", "lib/ansible/utils/template.py"], "buggy_code_start_loc": [52, 500, 46, 316, 83], "buggy_code_end_loc": [53, 501, 48, 351, 243], "fixing_code_start_loc": [52, 500, 46, 316, 82], "fixing_code_end_loc": [53, 501, 47, 385, 231], "type": "CWE-20", "message": "The user module in ansible before 1.6.6 allows remote authenticated users to execute arbitrary commands.", "other": {"cve": {"id": "CVE-2014-3498", "sourceIdentifier": "secalert@redhat.com", "published": "2017-06-08T18:29:00.187", "lastModified": "2018-10-30T16:28:05.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The user module in ansible before 1.6.6 allows remote authenticated users to execute arbitrary commands."}, {"lang": "es", "value": "El m\u00f3dulo de usuario en ansible, versiones anteriores a la 1.6.6, permite a usuarios remotos autenticados ejecutar comandos arbitrarios."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ansible:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.6.5", "matchCriteriaId": "DAF98BB4-0872-4C33-B098-51668EC123E2"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1335551", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/ansible/ansible/commit/8ed6350e65c82292a631f08845dfaacffe7f07f5", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ansible/ansible/commit/8ed6350e65c82292a631f08845dfaacffe7f07f5"}}