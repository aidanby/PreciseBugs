{"buggy_code": ["/*\n * Copyright (c) Dan Harkins, 2012\n *\n *  Copyright holder grants permission for redistribution and use in source\n *  and binary forms, with or without modification, provided that the\n *  following conditions are met:\n *     1. Redistribution of source code must retain the above copyright\n *\tnotice, this list of conditions, and the following disclaimer\n *\tin all source files.\n *     2. Redistribution in binary form must retain the above copyright\n *\tnotice, this list of conditions, and the following disclaimer\n *\tin the documentation and/or other materials provided with the\n *\tdistribution.\n *\n *  \"DISCLAIMER OF LIABILITY\n *\n *  THIS SOFTWARE IS PROVIDED BY DAN HARKINS ``AS IS'' AND\n *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n *  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n *  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INDUSTRIAL LOUNGE BE LIABLE\n *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n *  SUCH DAMAGE.\"\n *\n * This license and distribution terms cannot be changed. In other words,\n * this code cannot simply be copied and put under a different distribution\n * license (including the GNU public license).\n */\n\nRCSID(\"$Id$\")\nUSES_APPLE_DEPRECATED_API\t/* OpenSSL API has been deprecated by Apple */\n\n#include \"eap_pwd.h\"\n\n#include <freeradius-devel/radiusd.h>\n#include <freeradius-devel/modules.h>\n\n/* The random function H(x) = HMAC-SHA256(0^32, x) */\nstatic void H_Init(HMAC_CTX *ctx)\n{\n\tuint8_t allzero[SHA256_DIGEST_LENGTH];\n\n\tmemset(allzero, 0, SHA256_DIGEST_LENGTH);\n\n\tHMAC_Init_ex(ctx, allzero, SHA256_DIGEST_LENGTH, EVP_sha256(), NULL);\n}\n\nstatic void H_Update(HMAC_CTX *ctx, uint8_t const *data, int len)\n{\n\tHMAC_Update(ctx, data, len);\n}\n\nstatic void H_Final(HMAC_CTX *ctx, uint8_t *digest)\n{\n\tunsigned int mdlen = SHA256_DIGEST_LENGTH;\n\n\tHMAC_Final(ctx, digest, &mdlen);\n}\n\n/* a counter-based KDF based on NIST SP800-108 */\nstatic int eap_pwd_kdf(uint8_t *key, int keylen, char const *label, int labellen, uint8_t *result, int resultbitlen)\n{\n\tHMAC_CTX *hctx = NULL;\n\tuint8_t digest[SHA256_DIGEST_LENGTH];\n\tuint16_t i, ctr, L;\n\tint resultbytelen, len = 0;\n\tunsigned int mdlen = SHA256_DIGEST_LENGTH;\n\tuint8_t mask = 0xff;\n\n\thctx = HMAC_CTX_new();\n\tif (hctx == NULL) {\n\t\tDEBUG(\"failed allocating HMAC context\");\n\t\treturn -1;\n\t}\n\tresultbytelen = (resultbitlen + 7)/8;\n\tctr = 0;\n\tL = htons(resultbitlen);\n\twhile (len < resultbytelen) {\n\t\tctr++; i = htons(ctr);\n\t\tHMAC_Init_ex(hctx, key, keylen, EVP_sha256(), NULL);\n\t\tif (ctr > 1) {\n\t\t\tHMAC_Update(hctx, digest, mdlen);\n\t\t}\n\t\tHMAC_Update(hctx, (uint8_t *) &i, sizeof(uint16_t));\n\t\tHMAC_Update(hctx, (uint8_t const *)label, labellen);\n\t\tHMAC_Update(hctx, (uint8_t *) &L, sizeof(uint16_t));\n\t\tHMAC_Final(hctx, digest, &mdlen);\n\t\tif ((len + (int) mdlen) > resultbytelen) {\n\t\t\tmemcpy(result + len, digest, resultbytelen - len);\n\t\t} else {\n\t\t\tmemcpy(result + len, digest, mdlen);\n\t\t}\n\t\tlen += mdlen;\n\t}\n\tHMAC_CTX_free(hctx);\n\n\t/* since we're expanding to a bit length, mask off the excess */\n\tif (resultbitlen % 8) {\n\t\tmask <<= (8 - (resultbitlen % 8));\n\t\tresult[resultbytelen - 1] &= mask;\n\t}\n\n\treturn 0;\n}\n\nint compute_password_element (pwd_session_t *session, uint16_t grp_num,\n\t\t\t      char const *password, int password_len,\n\t\t\t      char const *id_server, int id_server_len,\n\t\t\t      char const *id_peer, int id_peer_len,\n\t\t\t      uint32_t *token)\n{\n\tBIGNUM *x_candidate = NULL, *rnd = NULL, *cofactor = NULL;\n\tHMAC_CTX *ctx = NULL;\n\tuint8_t pwe_digest[SHA256_DIGEST_LENGTH], *prfbuf = NULL, ctr;\n\tint nid, is_odd, primebitlen, primebytelen, ret = 0;\n\n\tctx = HMAC_CTX_new();\n\tif (ctx == NULL) {\n\t\tDEBUG(\"failed allocating HMAC context\");\n\t\tgoto fail;\n\t}\n\n\tswitch (grp_num) { /* from IANA registry for IKE D-H groups */\n\tcase 19:\n\t\tnid = NID_X9_62_prime256v1;\n\t\tbreak;\n\n\tcase 20:\n\t\tnid = NID_secp384r1;\n\t\tbreak;\n\n\tcase 21:\n\t\tnid = NID_secp521r1;\n\t\tbreak;\n\n\tcase 25:\n\t\tnid = NID_X9_62_prime192v1;\n\t\tbreak;\n\n\tcase 26:\n\t\tnid = NID_secp224r1;\n\t\tbreak;\n\n\tdefault:\n\t\tDEBUG(\"unknown group %d\", grp_num);\n\t\tgoto fail;\n\t}\n\n\tsession->pwe = NULL;\n\tsession->order = NULL;\n\tsession->prime = NULL;\n\n\tif ((session->group = EC_GROUP_new_by_curve_name(nid)) == NULL) {\n\t\tDEBUG(\"unable to create EC_GROUP\");\n\t\tgoto fail;\n\t}\n\n\tif (((rnd = BN_new()) == NULL) ||\n\t    ((cofactor = BN_new()) == NULL) ||\n\t    ((session->pwe = EC_POINT_new(session->group)) == NULL) ||\n\t    ((session->order = BN_new()) == NULL) ||\n\t    ((session->prime = BN_new()) == NULL) ||\n\t    ((x_candidate = BN_new()) == NULL)) {\n\t\tDEBUG(\"unable to create bignums\");\n\t\tgoto fail;\n\t}\n\n\tif (!EC_GROUP_get_curve_GFp(session->group, session->prime, NULL, NULL, NULL)) {\n\t\tDEBUG(\"unable to get prime for GFp curve\");\n\t\tgoto fail;\n\t}\n\n\tif (!EC_GROUP_get_order(session->group, session->order, NULL)) {\n\t\tDEBUG(\"unable to get order for curve\");\n\t\tgoto fail;\n\t}\n\n\tif (!EC_GROUP_get_cofactor(session->group, cofactor, NULL)) {\n\t\tDEBUG(\"unable to get cofactor for curve\");\n\t\tgoto fail;\n\t}\n\n\tprimebitlen = BN_num_bits(session->prime);\n\tprimebytelen = BN_num_bytes(session->prime);\n\tif ((prfbuf = talloc_zero_array(session, uint8_t, primebytelen)) == NULL) {\n\t\tDEBUG(\"unable to alloc space for prf buffer\");\n\t\tgoto fail;\n\t}\n\tctr = 0;\n\twhile (1) {\n\t\tif (ctr > 10) {\n\t\t\tDEBUG(\"unable to find random point on curve for group %d, something's fishy\", grp_num);\n\t\t\tgoto fail;\n\t\t}\n\t\tctr++;\n\n\t\t/*\n\t\t * compute counter-mode password value and stretch to prime\n\t\t *    pwd-seed = H(token | peer-id | server-id | password |\n\t\t *\t\t   counter)\n\t\t */\n\t\tH_Init(ctx);\n\t\tH_Update(ctx, (uint8_t *)token, sizeof(*token));\n\t\tH_Update(ctx, (uint8_t const *)id_peer, id_peer_len);\n\t\tH_Update(ctx, (uint8_t const *)id_server, id_server_len);\n\t\tH_Update(ctx, (uint8_t const *)password, password_len);\n\t\tH_Update(ctx, (uint8_t *)&ctr, sizeof(ctr));\n\t\tH_Final(ctx, pwe_digest);\n\n\t\tBN_bin2bn(pwe_digest, SHA256_DIGEST_LENGTH, rnd);\n\t\tif (eap_pwd_kdf(pwe_digest, SHA256_DIGEST_LENGTH, \"EAP-pwd Hunting And Pecking\",\n\t\t\t        strlen(\"EAP-pwd Hunting And Pecking\"), prfbuf, primebitlen) != 0) {\n\t\t\tDEBUG(\"key derivation function failed\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tBN_bin2bn(prfbuf, primebytelen, x_candidate);\n\t\t/*\n\t\t * eap_pwd_kdf() returns a string of bits 0..primebitlen but\n\t\t * BN_bin2bn will treat that string of bits as a big endian\n\t\t * number. If the primebitlen is not an even multiple of 8\n\t\t * then excessive bits-- those _after_ primebitlen-- so now\n\t\t * we have to shift right the amount we masked off.\n\t\t */\n\t\tif (primebitlen % 8) BN_rshift(x_candidate, x_candidate, (8 - (primebitlen % 8)));\n\t\tif (BN_ucmp(x_candidate, session->prime) >= 0) continue;\n\n\t\t/*\n\t\t * need to unambiguously identify the solution, if there is\n\t\t * one...\n\t\t */\n\t\tis_odd = BN_is_odd(rnd) ? 1 : 0;\n\n\t\t/*\n\t\t * solve the quadratic equation, if it's not solvable then we\n\t\t * don't have a point\n\t\t */\n\t\tif (!EC_POINT_set_compressed_coordinates_GFp(session->group, session->pwe, x_candidate, is_odd, NULL)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If there's a solution to the equation then the point must be\n\t\t * on the curve so why check again explicitly? OpenSSL code\n\t\t * says this is required by X9.62. We're not X9.62 but it can't\n\t\t * hurt just to be sure.\n\t\t */\n\t\tif (!EC_POINT_is_on_curve(session->group, session->pwe, NULL)) {\n\t\t\tDEBUG(\"EAP-pwd: point is not on curve\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BN_cmp(cofactor, BN_value_one())) {\n\t\t\t/* make sure the point is not in a small sub-group */\n\t\t\tif (!EC_POINT_mul(session->group, session->pwe, NULL, session->pwe,\n\t\t\t\tcofactor, NULL)) {\n\t\t\t\tDEBUG(\"EAP-pwd: cannot multiply generator by order\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (EC_POINT_is_at_infinity(session->group, session->pwe)) {\n\t\t\t\tDEBUG(\"EAP-pwd: point is at infinity\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/* if we got here then we have a new generator. */\n\t\tbreak;\n\t}\n\n\tsession->group_num = grp_num;\n\tif (0) {\n\t\tfail:\t\t/* DON'T free session, it's in handler->opaque */\n\t\tret = -1;\n\t}\n\n\t/* cleanliness and order.... */\n\tBN_clear_free(cofactor);\n\tBN_clear_free(x_candidate);\n\tBN_clear_free(rnd);\n\ttalloc_free(prfbuf);\n\tHMAC_CTX_free(ctx);\n\n\treturn ret;\n}\n\nint compute_scalar_element (pwd_session_t *session, BN_CTX *bnctx) {\n\tBIGNUM *mask = NULL;\n\tint ret = -1;\n\n\tif (((session->private_value = BN_new()) == NULL) ||\n\t    ((session->my_element = EC_POINT_new(session->group)) == NULL) ||\n\t    ((session->my_scalar = BN_new()) == NULL) ||\n\t    ((mask = BN_new()) == NULL)) {\n\t\tDEBUG2(\"server scalar allocation failed\");\n\t\tgoto fail;\n\t}\n\n\tif (BN_rand_range(session->private_value, session->order) != 1) {\n\t\tDEBUG2(\"Unable to get randomness for private_value\");\n\t\tgoto fail;\n\t}\n\tif (BN_rand_range(mask, session->order) != 1) {\n\t\tDEBUG2(\"Unable to get randomness for mask\");\n\t\tgoto fail;\n\t}\n\tBN_add(session->my_scalar, session->private_value, mask);\n\tBN_mod(session->my_scalar, session->my_scalar, session->order, bnctx);\n\n\tif (!EC_POINT_mul(session->group, session->my_element, NULL, session->pwe, mask, bnctx)) {\n\t\tDEBUG2(\"server element allocation failed\");\n\t\tgoto fail;\n\t}\n\n\tif (!EC_POINT_invert(session->group, session->my_element, bnctx)) {\n\t\tDEBUG2(\"server element inversion failed\");\n\t\tgoto fail;\n\t}\n\n\tret = 0;\n\nfail:\n\tBN_clear_free(mask);\n\n\treturn ret;\n}\n\nint process_peer_commit (pwd_session_t *session, uint8_t *in, size_t in_len, BN_CTX *bnctx)\n{\n\tuint8_t *ptr;\n\tsize_t data_len;\n\tBIGNUM *x = NULL, *y = NULL, *cofactor = NULL;\n\tEC_POINT *K = NULL, *point = NULL;\n\tint res = 1;\n\n\tif (((session->peer_scalar = BN_new()) == NULL) ||\n\t    ((session->k = BN_new()) == NULL) ||\n\t    ((cofactor = BN_new()) == NULL) ||\n\t    ((x = BN_new()) == NULL) ||\n\t    ((y = BN_new()) == NULL) ||\n\t    ((point = EC_POINT_new(session->group)) == NULL) ||\n\t    ((K = EC_POINT_new(session->group)) == NULL) ||\n\t    ((session->peer_element = EC_POINT_new(session->group)) == NULL)) {\n\t\tDEBUG2(\"pwd: failed to allocate room to process peer's commit\");\n\t\tgoto finish;\n\t}\n\n\tif (!EC_GROUP_get_cofactor(session->group, cofactor, NULL)) {\n\t\tDEBUG2(\"pwd: unable to get group co-factor\");\n\t\tgoto finish;\n\t}\n\n\t/* element, x then y, followed by scalar */\n\tptr = (uint8_t *)in;\n\tdata_len = BN_num_bytes(session->prime);\n\n\t/*\n\t *\tDid the peer send enough data?\n\t */\n\tif (in_len < (2 * data_len + BN_num_bytes(session->order))) {\n\t\tDEBUG(\"pwd: Invalid commit packet\");\n\t\tgoto finish;\n\t}\n\n\tBN_bin2bn(ptr, data_len, x);\n\tptr += data_len;\n\tBN_bin2bn(ptr, data_len, y);\n\tptr += data_len;\n\n\tdata_len = BN_num_bytes(session->order);\n\tBN_bin2bn(ptr, data_len, session->peer_scalar);\n\n\t/* validate received scalar */\n\tif (BN_is_zero(session->peer_scalar) ||\n\t    BN_is_one(session->peer_scalar) ||\n\t    BN_cmp(session->peer_scalar, session->order) >= 0) {\n\t\tERROR(\"Peer's scalar is not within the allowed range\");\n\t\tgoto finish;\n\t}\n\n\tif (!EC_POINT_set_affine_coordinates_GFp(session->group, session->peer_element, x, y, bnctx)) {\n\t\tDEBUG2(\"pwd: unable to get coordinates of peer's element\");\n\t\tgoto finish;\n\t}\n\n\t/* validate received element */\n\tif (!EC_POINT_is_on_curve(session->group, session->peer_element, bnctx) ||\n\t    EC_POINT_is_at_infinity(session->group, session->peer_element)) {\n\t\tERROR(\"Peer's element is not a point on the elliptic curve\");\n\t\tgoto finish;\n\t}\n\n\t/* check to ensure peer's element is not in a small sub-group */\n\tif (BN_cmp(cofactor, BN_value_one())) {\n\t\tif (!EC_POINT_mul(session->group, point, NULL, session->peer_element, cofactor, NULL)) {\n\t\t\tDEBUG2(\"pwd: unable to multiply element by co-factor\");\n\t\t\tgoto finish;\n\t\t}\n\n\t\tif (EC_POINT_is_at_infinity(session->group, point)) {\n\t\t\tDEBUG2(\"pwd: peer's element is in small sub-group\");\n\t\t\tgoto finish;\n\t\t}\n\t}\n\n\t/* detect reflection attacks */\n\tif (BN_cmp(session->peer_scalar, session->my_scalar) == 0 ||\n\t    EC_POINT_cmp(session->group, session->peer_element, session->my_element, bnctx) == 0) {\n\t\tERROR(\"Reflection attack detected\");\n\t\tgoto finish;\n\t}\n\n\t/* compute the shared key, k */\n\tif ((!EC_POINT_mul(session->group, K, NULL, session->pwe, session->peer_scalar, bnctx)) ||\n\t    (!EC_POINT_add(session->group, K, K, session->peer_element, bnctx)) ||\n\t    (!EC_POINT_mul(session->group, K, NULL, K, session->private_value, bnctx))) {\n\t\tDEBUG2(\"pwd: unable to compute shared key, k\");\n\t\tgoto finish;\n\t}\n\n\t/* ensure that the shared key isn't in a small sub-group */\n\tif (BN_cmp(cofactor, BN_value_one())) {\n\t\tif (!EC_POINT_mul(session->group, K, NULL, K, cofactor, NULL)) {\n\t\t\tDEBUG2(\"pwd: unable to multiply k by co-factor\");\n\t\t\tgoto finish;\n\t\t}\n\t}\n\n\t/*\n\t * This check is strictly speaking just for the case above where\n\t * co-factor > 1 but it was suggested that even though this is probably\n\t * never going to happen it is a simple and safe check \"just to be\n\t * sure\" so let's be safe.\n\t */\n\tif (EC_POINT_is_at_infinity(session->group, K)) {\n\t\tDEBUG2(\"pwd: k is point-at-infinity!\");\n\t\tgoto finish;\n\t}\n\n\tif (!EC_POINT_get_affine_coordinates_GFp(session->group, K, session->k, NULL, bnctx)) {\n\t\tDEBUG2(\"pwd: unable to get shared secret from K\");\n\t\tgoto finish;\n\t}\n\tres = 0;\n\nfinish:\n\tEC_POINT_clear_free(K);\n\tEC_POINT_clear_free(point);\n\tBN_clear_free(cofactor);\n\tBN_clear_free(x);\n\tBN_clear_free(y);\n\n\treturn res;\n}\n\nint compute_server_confirm (pwd_session_t *session, uint8_t *out, BN_CTX *bnctx)\n{\n\tBIGNUM *x = NULL, *y = NULL;\n\tHMAC_CTX *ctx = NULL;\n\tuint8_t *cruft = NULL;\n\tint offset, req = -1;\n\n\tctx = HMAC_CTX_new();\n\tif (ctx == NULL) {\n\t\tDEBUG2(\"pwd: unable to allocate HMAC context!\");\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * Each component of the cruft will be at most as big as the prime\n\t */\n\tif (((cruft = talloc_zero_array(session, uint8_t, BN_num_bytes(session->prime))) == NULL) ||\n\t    ((x = BN_new()) == NULL) || ((y = BN_new()) == NULL)) {\n\t\tDEBUG2(\"pwd: unable to allocate space to compute confirm!\");\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * commit is H(k | server_element | server_scalar | peer_element |\n\t *\t       peer_scalar | ciphersuite)\n\t */\n\tH_Init(ctx);\n\n\t/*\n\t * Zero the memory each time because this is mod prime math and some\n\t * value may start with a few zeros and the previous one did not.\n\t *\n\t * First is k\n\t */\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(session->k);\n\tBN_bn2bin(session->k, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\t/*\n\t * next is server element: x, y\n\t */\n\tif (!EC_POINT_get_affine_coordinates_GFp(session->group, session->my_element, x, y, bnctx)) {\n\t\tDEBUG2(\"pwd: unable to get coordinates of server element\");\n\t\tgoto finish;\n\t}\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(x);\n\tBN_bn2bin(x, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(y);\n\tBN_bn2bin(y, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\t/*\n\t * and server scalar\n\t */\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->order) - BN_num_bytes(session->my_scalar);\n\tBN_bn2bin(session->my_scalar, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->order));\n\n\t/*\n\t * next is peer element: x, y\n\t */\n\tif (!EC_POINT_get_affine_coordinates_GFp(session->group, session->peer_element, x, y, bnctx)) {\n\t\tDEBUG2(\"pwd: unable to get coordinates of peer's element\");\n\t\tgoto finish;\n\t}\n\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(x);\n\tBN_bn2bin(x, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(y);\n\tBN_bn2bin(y, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\t/*\n\t * and peer scalar\n\t */\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->order) - BN_num_bytes(session->peer_scalar);\n\tBN_bn2bin(session->peer_scalar, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->order));\n\n\t/*\n\t * finally, ciphersuite\n\t */\n\tH_Update(ctx, (uint8_t *)&session->ciphersuite, sizeof(session->ciphersuite));\n\n\tH_Final(ctx, out);\n\n\treq = 0;\nfinish:\n\ttalloc_free(cruft);\n\tBN_free(x);\n\tBN_free(y);\n\tHMAC_CTX_free(ctx);\n\n\treturn req;\n}\n\nint compute_peer_confirm (pwd_session_t *session, uint8_t *out, BN_CTX *bnctx)\n{\n\tBIGNUM *x = NULL, *y = NULL;\n\tHMAC_CTX *ctx = NULL;\n\tuint8_t *cruft = NULL;\n\tint offset, req = -1;\n\n\tctx = HMAC_CTX_new();\n\tif (ctx == NULL) {\n\t\tDEBUG2(\"pwd: unable to allocate HMAC context!\");\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * Each component of the cruft will be at most as big as the prime\n\t */\n\tif (((cruft = talloc_zero_array(session, uint8_t, BN_num_bytes(session->prime))) == NULL) ||\n\t    ((x = BN_new()) == NULL) || ((y = BN_new()) == NULL)) {\n\t\tDEBUG2(\"pwd: unable to allocate space to compute confirm!\");\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * commit is H(k | server_element | server_scalar | peer_element |\n\t *\t       peer_scalar | ciphersuite)\n\t */\n\tH_Init(ctx);\n\n\t/*\n\t * Zero the memory each time because this is mod prime math and some\n\t * value may start with a few zeros and the previous one did not.\n\t *\n\t * First is k\n\t */\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(session->k);\n\tBN_bn2bin(session->k, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\t/*\n\t* then peer element: x, y\n\t*/\n\tif (!EC_POINT_get_affine_coordinates_GFp(session->group, session->peer_element, x, y, bnctx)) {\n\t\tDEBUG2(\"pwd: unable to get coordinates of peer's element\");\n\t\tgoto finish;\n\t}\n\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(x);\n\tBN_bn2bin(x, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(y);\n\tBN_bn2bin(y, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\t/*\n\t * and peer scalar\n\t */\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->order) - BN_num_bytes(session->peer_scalar);\n\tBN_bn2bin(session->peer_scalar, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->order));\n\n\t/*\n\t * then server element: x, y\n\t */\n\tif (!EC_POINT_get_affine_coordinates_GFp(session->group, session->my_element, x, y, bnctx)) {\n\t\tDEBUG2(\"pwd: unable to get coordinates of server element\");\n\t\tgoto finish;\n\t}\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(x);\n\tBN_bn2bin(x, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(y);\n\tBN_bn2bin(y, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\t/*\n\t * and server scalar\n\t */\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->order) - BN_num_bytes(session->my_scalar);\n\tBN_bn2bin(session->my_scalar, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->order));\n\n\t/*\n\t * finally, ciphersuite\n\t */\n\tH_Update(ctx, (uint8_t *)&session->ciphersuite, sizeof(session->ciphersuite));\n\n\tH_Final(ctx, out);\n\n\treq = 0;\nfinish:\n\ttalloc_free(cruft);\n\tBN_free(x);\n\tBN_free(y);\n\tHMAC_CTX_free(ctx);\n\n\treturn req;\n}\n\nint compute_keys (pwd_session_t *session, uint8_t *peer_confirm, uint8_t *msk, uint8_t *emsk)\n{\n\tHMAC_CTX *ctx = NULL;\n\tuint8_t mk[SHA256_DIGEST_LENGTH], *cruft = NULL;\n\tuint8_t session_id[SHA256_DIGEST_LENGTH + 1];\n\tuint8_t msk_emsk[128];\t\t/* 64 each */\n\tint offset, ret = -1;\n\n\tctx = HMAC_CTX_new();\n\tif (ctx == NULL) {\n\t\tDEBUG2(\"pwd: unable to allocate HMAC context!\");\n\t\tgoto finish;\n\t}\n\n\tif ((cruft = talloc_array(session, uint8_t, BN_num_bytes(session->prime))) == NULL) {\n\t\tDEBUG2(\"pwd: unable to allocate space to compute keys\");\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * first compute the session-id = TypeCode | H(ciphersuite | scal_p |\n\t *\tscal_s)\n\t */\n\tsession_id[0] = PW_EAP_PWD;\n\tH_Init(ctx);\n\tH_Update(ctx, (uint8_t *)&session->ciphersuite, sizeof(session->ciphersuite));\n\toffset = BN_num_bytes(session->order) - BN_num_bytes(session->peer_scalar);\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\tBN_bn2bin(session->peer_scalar, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->order));\n\toffset = BN_num_bytes(session->order) - BN_num_bytes(session->my_scalar);\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\tBN_bn2bin(session->my_scalar, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->order));\n\tH_Final(ctx, (uint8_t *)&session_id[1]);\n\n\t/* then compute MK = H(k | commit-peer | commit-server) */\n\tH_Init(ctx);\n\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(session->k);\n\tBN_bn2bin(session->k, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\tH_Update(ctx, peer_confirm, SHA256_DIGEST_LENGTH);\n\n\tH_Update(ctx, session->my_confirm, SHA256_DIGEST_LENGTH);\n\n\tH_Final(ctx, mk);\n\n\t/* stretch the mk with the session-id to get MSK | EMSK */\n\tif (eap_pwd_kdf(mk, SHA256_DIGEST_LENGTH, (char const *)session_id,\n\t\t        SHA256_DIGEST_LENGTH + 1, msk_emsk,\n\t\t\t/* it's bits, ((64 + 64) * 8) */\n\t\t\t1024) != 0) {\n\t\tDEBUG(\"key derivation function failed\");\n\t\tgoto finish;\n\t}\n\n\tmemcpy(msk, msk_emsk, 64);\n\tmemcpy(emsk, msk_emsk + 64, 64);\n\n\tret = 0;\nfinish:\n\ttalloc_free(cruft);\n\tHMAC_CTX_free(ctx);\n\treturn ret;\n}\n\n\n\n\n"], "fixing_code": ["/*\n * Copyright (c) Dan Harkins, 2012\n *\n *  Copyright holder grants permission for redistribution and use in source\n *  and binary forms, with or without modification, provided that the\n *  following conditions are met:\n *     1. Redistribution of source code must retain the above copyright\n *\tnotice, this list of conditions, and the following disclaimer\n *\tin all source files.\n *     2. Redistribution in binary form must retain the above copyright\n *\tnotice, this list of conditions, and the following disclaimer\n *\tin the documentation and/or other materials provided with the\n *\tdistribution.\n *\n *  \"DISCLAIMER OF LIABILITY\n *\n *  THIS SOFTWARE IS PROVIDED BY DAN HARKINS ``AS IS'' AND\n *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n *  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n *  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INDUSTRIAL LOUNGE BE LIABLE\n *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n *  SUCH DAMAGE.\"\n *\n * This license and distribution terms cannot be changed. In other words,\n * this code cannot simply be copied and put under a different distribution\n * license (including the GNU public license).\n */\n\nRCSID(\"$Id$\")\nUSES_APPLE_DEPRECATED_API\t/* OpenSSL API has been deprecated by Apple */\n\n#include \"eap_pwd.h\"\n\n#include <freeradius-devel/radiusd.h>\n#include <freeradius-devel/modules.h>\n\n/* The random function H(x) = HMAC-SHA256(0^32, x) */\nstatic void H_Init(HMAC_CTX *ctx)\n{\n\tuint8_t allzero[SHA256_DIGEST_LENGTH];\n\n\tmemset(allzero, 0, SHA256_DIGEST_LENGTH);\n\n\tHMAC_Init_ex(ctx, allzero, SHA256_DIGEST_LENGTH, EVP_sha256(), NULL);\n}\n\nstatic void H_Update(HMAC_CTX *ctx, uint8_t const *data, int len)\n{\n\tHMAC_Update(ctx, data, len);\n}\n\nstatic void H_Final(HMAC_CTX *ctx, uint8_t *digest)\n{\n\tunsigned int mdlen = SHA256_DIGEST_LENGTH;\n\n\tHMAC_Final(ctx, digest, &mdlen);\n}\n\n/* a counter-based KDF based on NIST SP800-108 */\nstatic int eap_pwd_kdf(uint8_t *key, int keylen, char const *label, int labellen, uint8_t *result, int resultbitlen)\n{\n\tHMAC_CTX *hctx = NULL;\n\tuint8_t digest[SHA256_DIGEST_LENGTH];\n\tuint16_t i, ctr, L;\n\tint resultbytelen, len = 0;\n\tunsigned int mdlen = SHA256_DIGEST_LENGTH;\n\tuint8_t mask = 0xff;\n\n\thctx = HMAC_CTX_new();\n\tif (hctx == NULL) {\n\t\tDEBUG(\"failed allocating HMAC context\");\n\t\treturn -1;\n\t}\n\tresultbytelen = (resultbitlen + 7)/8;\n\tctr = 0;\n\tL = htons(resultbitlen);\n\twhile (len < resultbytelen) {\n\t\tctr++; i = htons(ctr);\n\t\tHMAC_Init_ex(hctx, key, keylen, EVP_sha256(), NULL);\n\t\tif (ctr > 1) {\n\t\t\tHMAC_Update(hctx, digest, mdlen);\n\t\t}\n\t\tHMAC_Update(hctx, (uint8_t *) &i, sizeof(uint16_t));\n\t\tHMAC_Update(hctx, (uint8_t const *)label, labellen);\n\t\tHMAC_Update(hctx, (uint8_t *) &L, sizeof(uint16_t));\n\t\tHMAC_Final(hctx, digest, &mdlen);\n\t\tif ((len + (int) mdlen) > resultbytelen) {\n\t\t\tmemcpy(result + len, digest, resultbytelen - len);\n\t\t} else {\n\t\t\tmemcpy(result + len, digest, mdlen);\n\t\t}\n\t\tlen += mdlen;\n\t}\n\tHMAC_CTX_free(hctx);\n\n\t/* since we're expanding to a bit length, mask off the excess */\n\tif (resultbitlen % 8) {\n\t\tmask <<= (8 - (resultbitlen % 8));\n\t\tresult[resultbytelen - 1] &= mask;\n\t}\n\n\treturn 0;\n}\n\nint compute_password_element (pwd_session_t *session, uint16_t grp_num,\n\t\t\t      char const *password, int password_len,\n\t\t\t      char const *id_server, int id_server_len,\n\t\t\t      char const *id_peer, int id_peer_len,\n\t\t\t      uint32_t *token)\n{\n\tBIGNUM *x_candidate = NULL, *rnd = NULL, *cofactor = NULL;\n\tHMAC_CTX *ctx = NULL;\n\tuint8_t pwe_digest[SHA256_DIGEST_LENGTH], *prfbuf = NULL, ctr;\n\tint nid, is_odd, primebitlen, primebytelen, ret = 0;\n\n\tctx = HMAC_CTX_new();\n\tif (ctx == NULL) {\n\t\tDEBUG(\"failed allocating HMAC context\");\n\t\tgoto fail;\n\t}\n\n\tswitch (grp_num) { /* from IANA registry for IKE D-H groups */\n\tcase 19:\n\t\tnid = NID_X9_62_prime256v1;\n\t\tbreak;\n\n\tcase 20:\n\t\tnid = NID_secp384r1;\n\t\tbreak;\n\n\tcase 21:\n\t\tnid = NID_secp521r1;\n\t\tbreak;\n\n\tcase 25:\n\t\tnid = NID_X9_62_prime192v1;\n\t\tbreak;\n\n\tcase 26:\n\t\tnid = NID_secp224r1;\n\t\tbreak;\n\n\tdefault:\n\t\tDEBUG(\"unknown group %d\", grp_num);\n\t\tgoto fail;\n\t}\n\n\tsession->pwe = NULL;\n\tsession->order = NULL;\n\tsession->prime = NULL;\n\n\tif ((session->group = EC_GROUP_new_by_curve_name(nid)) == NULL) {\n\t\tDEBUG(\"unable to create EC_GROUP\");\n\t\tgoto fail;\n\t}\n\n\tif (((rnd = BN_new()) == NULL) ||\n\t    ((cofactor = BN_new()) == NULL) ||\n\t    ((session->pwe = EC_POINT_new(session->group)) == NULL) ||\n\t    ((session->order = BN_new()) == NULL) ||\n\t    ((session->prime = BN_new()) == NULL) ||\n\t    ((x_candidate = BN_new()) == NULL)) {\n\t\tDEBUG(\"unable to create bignums\");\n\t\tgoto fail;\n\t}\n\n\tif (!EC_GROUP_get_curve_GFp(session->group, session->prime, NULL, NULL, NULL)) {\n\t\tDEBUG(\"unable to get prime for GFp curve\");\n\t\tgoto fail;\n\t}\n\n\tif (!EC_GROUP_get_order(session->group, session->order, NULL)) {\n\t\tDEBUG(\"unable to get order for curve\");\n\t\tgoto fail;\n\t}\n\n\tif (!EC_GROUP_get_cofactor(session->group, cofactor, NULL)) {\n\t\tDEBUG(\"unable to get cofactor for curve\");\n\t\tgoto fail;\n\t}\n\n\tprimebitlen = BN_num_bits(session->prime);\n\tprimebytelen = BN_num_bytes(session->prime);\n\tif ((prfbuf = talloc_zero_array(session, uint8_t, primebytelen)) == NULL) {\n\t\tDEBUG(\"unable to alloc space for prf buffer\");\n\t\tgoto fail;\n\t}\n\tctr = 0;\n\twhile (1) {\n\t\tif (ctr > 100) {\n\t\t\tDEBUG(\"unable to find random point on curve for group %d, something's fishy\", grp_num);\n\t\t\tgoto fail;\n\t\t}\n\t\tctr++;\n\n\t\t/*\n\t\t * compute counter-mode password value and stretch to prime\n\t\t *    pwd-seed = H(token | peer-id | server-id | password |\n\t\t *\t\t   counter)\n\t\t */\n\t\tH_Init(ctx);\n\t\tH_Update(ctx, (uint8_t *)token, sizeof(*token));\n\t\tH_Update(ctx, (uint8_t const *)id_peer, id_peer_len);\n\t\tH_Update(ctx, (uint8_t const *)id_server, id_server_len);\n\t\tH_Update(ctx, (uint8_t const *)password, password_len);\n\t\tH_Update(ctx, (uint8_t *)&ctr, sizeof(ctr));\n\t\tH_Final(ctx, pwe_digest);\n\n\t\tBN_bin2bn(pwe_digest, SHA256_DIGEST_LENGTH, rnd);\n\t\tif (eap_pwd_kdf(pwe_digest, SHA256_DIGEST_LENGTH, \"EAP-pwd Hunting And Pecking\",\n\t\t\t        strlen(\"EAP-pwd Hunting And Pecking\"), prfbuf, primebitlen) != 0) {\n\t\t\tDEBUG(\"key derivation function failed\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tBN_bin2bn(prfbuf, primebytelen, x_candidate);\n\t\t/*\n\t\t * eap_pwd_kdf() returns a string of bits 0..primebitlen but\n\t\t * BN_bin2bn will treat that string of bits as a big endian\n\t\t * number. If the primebitlen is not an even multiple of 8\n\t\t * then excessive bits-- those _after_ primebitlen-- so now\n\t\t * we have to shift right the amount we masked off.\n\t\t */\n\t\tif (primebitlen % 8) BN_rshift(x_candidate, x_candidate, (8 - (primebitlen % 8)));\n\t\tif (BN_ucmp(x_candidate, session->prime) >= 0) continue;\n\n\t\t/*\n\t\t * need to unambiguously identify the solution, if there is\n\t\t * one...\n\t\t */\n\t\tis_odd = BN_is_odd(rnd) ? 1 : 0;\n\n\t\t/*\n\t\t * solve the quadratic equation, if it's not solvable then we\n\t\t * don't have a point\n\t\t */\n\t\tif (!EC_POINT_set_compressed_coordinates_GFp(session->group, session->pwe, x_candidate, is_odd, NULL)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If there's a solution to the equation then the point must be\n\t\t * on the curve so why check again explicitly? OpenSSL code\n\t\t * says this is required by X9.62. We're not X9.62 but it can't\n\t\t * hurt just to be sure.\n\t\t */\n\t\tif (!EC_POINT_is_on_curve(session->group, session->pwe, NULL)) {\n\t\t\tDEBUG(\"EAP-pwd: point is not on curve\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BN_cmp(cofactor, BN_value_one())) {\n\t\t\t/* make sure the point is not in a small sub-group */\n\t\t\tif (!EC_POINT_mul(session->group, session->pwe, NULL, session->pwe,\n\t\t\t\tcofactor, NULL)) {\n\t\t\t\tDEBUG(\"EAP-pwd: cannot multiply generator by order\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (EC_POINT_is_at_infinity(session->group, session->pwe)) {\n\t\t\t\tDEBUG(\"EAP-pwd: point is at infinity\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/* if we got here then we have a new generator. */\n\t\tbreak;\n\t}\n\n\tsession->group_num = grp_num;\n\tif (0) {\n\t\tfail:\t\t/* DON'T free session, it's in handler->opaque */\n\t\tret = -1;\n\t}\n\n\t/* cleanliness and order.... */\n\tBN_clear_free(cofactor);\n\tBN_clear_free(x_candidate);\n\tBN_clear_free(rnd);\n\ttalloc_free(prfbuf);\n\tHMAC_CTX_free(ctx);\n\n\treturn ret;\n}\n\nint compute_scalar_element (pwd_session_t *session, BN_CTX *bnctx) {\n\tBIGNUM *mask = NULL;\n\tint ret = -1;\n\n\tif (((session->private_value = BN_new()) == NULL) ||\n\t    ((session->my_element = EC_POINT_new(session->group)) == NULL) ||\n\t    ((session->my_scalar = BN_new()) == NULL) ||\n\t    ((mask = BN_new()) == NULL)) {\n\t\tDEBUG2(\"server scalar allocation failed\");\n\t\tgoto fail;\n\t}\n\n\tif (BN_rand_range(session->private_value, session->order) != 1) {\n\t\tDEBUG2(\"Unable to get randomness for private_value\");\n\t\tgoto fail;\n\t}\n\tif (BN_rand_range(mask, session->order) != 1) {\n\t\tDEBUG2(\"Unable to get randomness for mask\");\n\t\tgoto fail;\n\t}\n\tBN_add(session->my_scalar, session->private_value, mask);\n\tBN_mod(session->my_scalar, session->my_scalar, session->order, bnctx);\n\n\tif (!EC_POINT_mul(session->group, session->my_element, NULL, session->pwe, mask, bnctx)) {\n\t\tDEBUG2(\"server element allocation failed\");\n\t\tgoto fail;\n\t}\n\n\tif (!EC_POINT_invert(session->group, session->my_element, bnctx)) {\n\t\tDEBUG2(\"server element inversion failed\");\n\t\tgoto fail;\n\t}\n\n\tret = 0;\n\nfail:\n\tBN_clear_free(mask);\n\n\treturn ret;\n}\n\nint process_peer_commit (pwd_session_t *session, uint8_t *in, size_t in_len, BN_CTX *bnctx)\n{\n\tuint8_t *ptr;\n\tsize_t data_len;\n\tBIGNUM *x = NULL, *y = NULL, *cofactor = NULL;\n\tEC_POINT *K = NULL, *point = NULL;\n\tint res = 1;\n\n\tif (((session->peer_scalar = BN_new()) == NULL) ||\n\t    ((session->k = BN_new()) == NULL) ||\n\t    ((cofactor = BN_new()) == NULL) ||\n\t    ((x = BN_new()) == NULL) ||\n\t    ((y = BN_new()) == NULL) ||\n\t    ((point = EC_POINT_new(session->group)) == NULL) ||\n\t    ((K = EC_POINT_new(session->group)) == NULL) ||\n\t    ((session->peer_element = EC_POINT_new(session->group)) == NULL)) {\n\t\tDEBUG2(\"pwd: failed to allocate room to process peer's commit\");\n\t\tgoto finish;\n\t}\n\n\tif (!EC_GROUP_get_cofactor(session->group, cofactor, NULL)) {\n\t\tDEBUG2(\"pwd: unable to get group co-factor\");\n\t\tgoto finish;\n\t}\n\n\t/* element, x then y, followed by scalar */\n\tptr = (uint8_t *)in;\n\tdata_len = BN_num_bytes(session->prime);\n\n\t/*\n\t *\tDid the peer send enough data?\n\t */\n\tif (in_len < (2 * data_len + BN_num_bytes(session->order))) {\n\t\tDEBUG(\"pwd: Invalid commit packet\");\n\t\tgoto finish;\n\t}\n\n\tBN_bin2bn(ptr, data_len, x);\n\tptr += data_len;\n\tBN_bin2bn(ptr, data_len, y);\n\tptr += data_len;\n\n\tdata_len = BN_num_bytes(session->order);\n\tBN_bin2bn(ptr, data_len, session->peer_scalar);\n\n\t/* validate received scalar */\n\tif (BN_is_zero(session->peer_scalar) ||\n\t    BN_is_one(session->peer_scalar) ||\n\t    BN_cmp(session->peer_scalar, session->order) >= 0) {\n\t\tERROR(\"Peer's scalar is not within the allowed range\");\n\t\tgoto finish;\n\t}\n\n\tif (!EC_POINT_set_affine_coordinates_GFp(session->group, session->peer_element, x, y, bnctx)) {\n\t\tDEBUG2(\"pwd: unable to get coordinates of peer's element\");\n\t\tgoto finish;\n\t}\n\n\t/* validate received element */\n\tif (!EC_POINT_is_on_curve(session->group, session->peer_element, bnctx) ||\n\t    EC_POINT_is_at_infinity(session->group, session->peer_element)) {\n\t\tERROR(\"Peer's element is not a point on the elliptic curve\");\n\t\tgoto finish;\n\t}\n\n\t/* check to ensure peer's element is not in a small sub-group */\n\tif (BN_cmp(cofactor, BN_value_one())) {\n\t\tif (!EC_POINT_mul(session->group, point, NULL, session->peer_element, cofactor, NULL)) {\n\t\t\tDEBUG2(\"pwd: unable to multiply element by co-factor\");\n\t\t\tgoto finish;\n\t\t}\n\n\t\tif (EC_POINT_is_at_infinity(session->group, point)) {\n\t\t\tDEBUG2(\"pwd: peer's element is in small sub-group\");\n\t\t\tgoto finish;\n\t\t}\n\t}\n\n\t/* detect reflection attacks */\n\tif (BN_cmp(session->peer_scalar, session->my_scalar) == 0 ||\n\t    EC_POINT_cmp(session->group, session->peer_element, session->my_element, bnctx) == 0) {\n\t\tERROR(\"Reflection attack detected\");\n\t\tgoto finish;\n\t}\n\n\t/* compute the shared key, k */\n\tif ((!EC_POINT_mul(session->group, K, NULL, session->pwe, session->peer_scalar, bnctx)) ||\n\t    (!EC_POINT_add(session->group, K, K, session->peer_element, bnctx)) ||\n\t    (!EC_POINT_mul(session->group, K, NULL, K, session->private_value, bnctx))) {\n\t\tDEBUG2(\"pwd: unable to compute shared key, k\");\n\t\tgoto finish;\n\t}\n\n\t/* ensure that the shared key isn't in a small sub-group */\n\tif (BN_cmp(cofactor, BN_value_one())) {\n\t\tif (!EC_POINT_mul(session->group, K, NULL, K, cofactor, NULL)) {\n\t\t\tDEBUG2(\"pwd: unable to multiply k by co-factor\");\n\t\t\tgoto finish;\n\t\t}\n\t}\n\n\t/*\n\t * This check is strictly speaking just for the case above where\n\t * co-factor > 1 but it was suggested that even though this is probably\n\t * never going to happen it is a simple and safe check \"just to be\n\t * sure\" so let's be safe.\n\t */\n\tif (EC_POINT_is_at_infinity(session->group, K)) {\n\t\tDEBUG2(\"pwd: k is point-at-infinity!\");\n\t\tgoto finish;\n\t}\n\n\tif (!EC_POINT_get_affine_coordinates_GFp(session->group, K, session->k, NULL, bnctx)) {\n\t\tDEBUG2(\"pwd: unable to get shared secret from K\");\n\t\tgoto finish;\n\t}\n\tres = 0;\n\nfinish:\n\tEC_POINT_clear_free(K);\n\tEC_POINT_clear_free(point);\n\tBN_clear_free(cofactor);\n\tBN_clear_free(x);\n\tBN_clear_free(y);\n\n\treturn res;\n}\n\nint compute_server_confirm (pwd_session_t *session, uint8_t *out, BN_CTX *bnctx)\n{\n\tBIGNUM *x = NULL, *y = NULL;\n\tHMAC_CTX *ctx = NULL;\n\tuint8_t *cruft = NULL;\n\tint offset, req = -1;\n\n\tctx = HMAC_CTX_new();\n\tif (ctx == NULL) {\n\t\tDEBUG2(\"pwd: unable to allocate HMAC context!\");\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * Each component of the cruft will be at most as big as the prime\n\t */\n\tif (((cruft = talloc_zero_array(session, uint8_t, BN_num_bytes(session->prime))) == NULL) ||\n\t    ((x = BN_new()) == NULL) || ((y = BN_new()) == NULL)) {\n\t\tDEBUG2(\"pwd: unable to allocate space to compute confirm!\");\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * commit is H(k | server_element | server_scalar | peer_element |\n\t *\t       peer_scalar | ciphersuite)\n\t */\n\tH_Init(ctx);\n\n\t/*\n\t * Zero the memory each time because this is mod prime math and some\n\t * value may start with a few zeros and the previous one did not.\n\t *\n\t * First is k\n\t */\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(session->k);\n\tBN_bn2bin(session->k, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\t/*\n\t * next is server element: x, y\n\t */\n\tif (!EC_POINT_get_affine_coordinates_GFp(session->group, session->my_element, x, y, bnctx)) {\n\t\tDEBUG2(\"pwd: unable to get coordinates of server element\");\n\t\tgoto finish;\n\t}\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(x);\n\tBN_bn2bin(x, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(y);\n\tBN_bn2bin(y, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\t/*\n\t * and server scalar\n\t */\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->order) - BN_num_bytes(session->my_scalar);\n\tBN_bn2bin(session->my_scalar, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->order));\n\n\t/*\n\t * next is peer element: x, y\n\t */\n\tif (!EC_POINT_get_affine_coordinates_GFp(session->group, session->peer_element, x, y, bnctx)) {\n\t\tDEBUG2(\"pwd: unable to get coordinates of peer's element\");\n\t\tgoto finish;\n\t}\n\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(x);\n\tBN_bn2bin(x, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(y);\n\tBN_bn2bin(y, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\t/*\n\t * and peer scalar\n\t */\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->order) - BN_num_bytes(session->peer_scalar);\n\tBN_bn2bin(session->peer_scalar, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->order));\n\n\t/*\n\t * finally, ciphersuite\n\t */\n\tH_Update(ctx, (uint8_t *)&session->ciphersuite, sizeof(session->ciphersuite));\n\n\tH_Final(ctx, out);\n\n\treq = 0;\nfinish:\n\ttalloc_free(cruft);\n\tBN_free(x);\n\tBN_free(y);\n\tHMAC_CTX_free(ctx);\n\n\treturn req;\n}\n\nint compute_peer_confirm (pwd_session_t *session, uint8_t *out, BN_CTX *bnctx)\n{\n\tBIGNUM *x = NULL, *y = NULL;\n\tHMAC_CTX *ctx = NULL;\n\tuint8_t *cruft = NULL;\n\tint offset, req = -1;\n\n\tctx = HMAC_CTX_new();\n\tif (ctx == NULL) {\n\t\tDEBUG2(\"pwd: unable to allocate HMAC context!\");\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * Each component of the cruft will be at most as big as the prime\n\t */\n\tif (((cruft = talloc_zero_array(session, uint8_t, BN_num_bytes(session->prime))) == NULL) ||\n\t    ((x = BN_new()) == NULL) || ((y = BN_new()) == NULL)) {\n\t\tDEBUG2(\"pwd: unable to allocate space to compute confirm!\");\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * commit is H(k | server_element | server_scalar | peer_element |\n\t *\t       peer_scalar | ciphersuite)\n\t */\n\tH_Init(ctx);\n\n\t/*\n\t * Zero the memory each time because this is mod prime math and some\n\t * value may start with a few zeros and the previous one did not.\n\t *\n\t * First is k\n\t */\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(session->k);\n\tBN_bn2bin(session->k, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\t/*\n\t* then peer element: x, y\n\t*/\n\tif (!EC_POINT_get_affine_coordinates_GFp(session->group, session->peer_element, x, y, bnctx)) {\n\t\tDEBUG2(\"pwd: unable to get coordinates of peer's element\");\n\t\tgoto finish;\n\t}\n\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(x);\n\tBN_bn2bin(x, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(y);\n\tBN_bn2bin(y, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\t/*\n\t * and peer scalar\n\t */\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->order) - BN_num_bytes(session->peer_scalar);\n\tBN_bn2bin(session->peer_scalar, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->order));\n\n\t/*\n\t * then server element: x, y\n\t */\n\tif (!EC_POINT_get_affine_coordinates_GFp(session->group, session->my_element, x, y, bnctx)) {\n\t\tDEBUG2(\"pwd: unable to get coordinates of server element\");\n\t\tgoto finish;\n\t}\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(x);\n\tBN_bn2bin(x, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(y);\n\tBN_bn2bin(y, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\t/*\n\t * and server scalar\n\t */\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->order) - BN_num_bytes(session->my_scalar);\n\tBN_bn2bin(session->my_scalar, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->order));\n\n\t/*\n\t * finally, ciphersuite\n\t */\n\tH_Update(ctx, (uint8_t *)&session->ciphersuite, sizeof(session->ciphersuite));\n\n\tH_Final(ctx, out);\n\n\treq = 0;\nfinish:\n\ttalloc_free(cruft);\n\tBN_free(x);\n\tBN_free(y);\n\tHMAC_CTX_free(ctx);\n\n\treturn req;\n}\n\nint compute_keys (pwd_session_t *session, uint8_t *peer_confirm, uint8_t *msk, uint8_t *emsk)\n{\n\tHMAC_CTX *ctx = NULL;\n\tuint8_t mk[SHA256_DIGEST_LENGTH], *cruft = NULL;\n\tuint8_t session_id[SHA256_DIGEST_LENGTH + 1];\n\tuint8_t msk_emsk[128];\t\t/* 64 each */\n\tint offset, ret = -1;\n\n\tctx = HMAC_CTX_new();\n\tif (ctx == NULL) {\n\t\tDEBUG2(\"pwd: unable to allocate HMAC context!\");\n\t\tgoto finish;\n\t}\n\n\tif ((cruft = talloc_array(session, uint8_t, BN_num_bytes(session->prime))) == NULL) {\n\t\tDEBUG2(\"pwd: unable to allocate space to compute keys\");\n\t\tgoto finish;\n\t}\n\n\t/*\n\t * first compute the session-id = TypeCode | H(ciphersuite | scal_p |\n\t *\tscal_s)\n\t */\n\tsession_id[0] = PW_EAP_PWD;\n\tH_Init(ctx);\n\tH_Update(ctx, (uint8_t *)&session->ciphersuite, sizeof(session->ciphersuite));\n\toffset = BN_num_bytes(session->order) - BN_num_bytes(session->peer_scalar);\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\tBN_bn2bin(session->peer_scalar, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->order));\n\toffset = BN_num_bytes(session->order) - BN_num_bytes(session->my_scalar);\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\tBN_bn2bin(session->my_scalar, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->order));\n\tH_Final(ctx, (uint8_t *)&session_id[1]);\n\n\t/* then compute MK = H(k | commit-peer | commit-server) */\n\tH_Init(ctx);\n\n\tmemset(cruft, 0, BN_num_bytes(session->prime));\n\toffset = BN_num_bytes(session->prime) - BN_num_bytes(session->k);\n\tBN_bn2bin(session->k, cruft + offset);\n\tH_Update(ctx, cruft, BN_num_bytes(session->prime));\n\n\tH_Update(ctx, peer_confirm, SHA256_DIGEST_LENGTH);\n\n\tH_Update(ctx, session->my_confirm, SHA256_DIGEST_LENGTH);\n\n\tH_Final(ctx, mk);\n\n\t/* stretch the mk with the session-id to get MSK | EMSK */\n\tif (eap_pwd_kdf(mk, SHA256_DIGEST_LENGTH, (char const *)session_id,\n\t\t        SHA256_DIGEST_LENGTH + 1, msk_emsk,\n\t\t\t/* it's bits, ((64 + 64) * 8) */\n\t\t\t1024) != 0) {\n\t\tDEBUG(\"key derivation function failed\");\n\t\tgoto finish;\n\t}\n\n\tmemcpy(msk, msk_emsk, 64);\n\tmemcpy(emsk, msk_emsk + 64, 64);\n\n\tret = 0;\nfinish:\n\ttalloc_free(cruft);\n\tHMAC_CTX_free(ctx);\n\treturn ret;\n}\n\n\n\n\n"], "filenames": ["src/modules/rlm_eap/types/rlm_eap_pwd/eap_pwd.c"], "buggy_code_start_loc": [195], "buggy_code_end_loc": [196], "fixing_code_start_loc": [195], "fixing_code_end_loc": [196], "type": "CWE-203", "message": "In FreeRADIUS 3.0 through 3.0.19, on average 1 in every 2048 EAP-pwd handshakes fails because the password element cannot be found within 10 iterations of the hunting and pecking loop. This leaks information that an attacker can use to recover the password of any user. This information leakage is similar to the \"Dragonblood\" attack and CVE-2019-9494.", "other": {"cve": {"id": "CVE-2019-13456", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-03T20:15:11.013", "lastModified": "2022-01-01T20:06:20.460", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In FreeRADIUS 3.0 through 3.0.19, on average 1 in every 2048 EAP-pwd handshakes fails because the password element cannot be found within 10 iterations of the hunting and pecking loop. This leaks information that an attacker can use to recover the password of any user. This information leakage is similar to the \"Dragonblood\" attack and CVE-2019-9494."}, {"lang": "es", "value": "En FreeRADIUS versiones 3.0 hasta 3.0.19, en promedio 1 de cada 2048 protocolos de enlace EAP-pwd presenta un fallo porque el elemento de contrase\u00f1a no puede ser encontrado dentro de las 10 iteraciones del bucle de tipo \"hunting and pecking\". Esto filtra informaci\u00f3n que un atacante puede utilizar para recuperar la contrase\u00f1a de cualquier usuario. Este filtrado de informaci\u00f3n es similar al ataque \"Dragonblood\" y al CVE-2019-9494."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.9}, "baseSeverity": "LOW", "exploitabilityScore": 5.5, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndIncluding": "3.0.19", "matchCriteriaId": "B292FDAF-75A6-4B45-B7DA-BD2F624CF165"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:linux:linux_kernel:-:*:*:*:*:*:*:*", "matchCriteriaId": "703AF700-7A70-47E2-BC3A-7FD03B3CA9C1"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-04/msg00039.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1737663", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://freeradius.org/security/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/FreeRADIUS/freeradius-server/commit/3ea2a5a026e73d81cd9a3e9bbd4300c433004bfa", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://wpa3.mathyvanhoef.com", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRADIUS/freeradius-server/commit/3ea2a5a026e73d81cd9a3e9bbd4300c433004bfa"}}