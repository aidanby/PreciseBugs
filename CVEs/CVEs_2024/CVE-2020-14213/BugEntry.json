{"buggy_code": ["# Copyright (C) 2012-2016 Zammad Foundation, http://zammad-foundation.org/\n\nclass TicketsController < ApplicationController\n  include CreatesTicketArticles\n  include ClonesTicketArticleAttachments\n  include ChecksUserAttributesByCurrentUserPermission\n  include TicketStats\n\n  prepend_before_action -> { authorize! }, only: %i[create selector import_example import_start]\n  prepend_before_action :authentication_check\n\n  # GET /api/v1/tickets\n  def index\n    offset = 0\n    per_page = 100\n\n    if params[:page] && params[:per_page]\n      offset = (params[:page].to_i - 1) * params[:per_page].to_i\n      per_page = params[:per_page].to_i\n    end\n\n    if per_page > 100\n      per_page = 100\n    end\n\n    access_condition = Ticket.access_condition(current_user, 'read')\n    tickets = Ticket.where(access_condition).order(id: :asc).offset(offset).limit(per_page)\n\n    if response_expand?\n      list = []\n      tickets.each do |ticket|\n        list.push ticket.attributes_with_association_names\n      end\n      render json: list, status: :ok\n      return\n    end\n\n    if response_full?\n      assets = {}\n      item_ids = []\n      tickets.each do |item|\n        item_ids.push item.id\n        assets = item.assets(assets)\n      end\n      render json: {\n        record_ids: item_ids,\n        assets:     assets,\n      }, status: :ok\n      return\n    end\n\n    render json: tickets\n  end\n\n  # GET /api/v1/tickets/1\n  def show\n    ticket = Ticket.find(params[:id])\n    authorize!(ticket)\n\n    if response_expand?\n      result = ticket.attributes_with_association_names\n      render json: result, status: :ok\n      return\n    end\n\n    if response_full?\n      full = Ticket.full(params[:id])\n      render json: full\n      return\n    end\n\n    if response_all?\n      render json: ticket_all(ticket)\n      return\n    end\n\n    render json: ticket\n  end\n\n  # POST /api/v1/tickets\n  def create\n    customer = {}\n    if params[:customer].class == ActionController::Parameters\n      customer = params[:customer]\n      params.delete(:customer)\n    end\n\n    clean_params = Ticket.association_name_to_id_convert(params)\n\n    # overwrite params\n    if !current_user.permissions?('ticket.agent')\n      %i[owner owner_id customer customer_id organization organization_id preferences].each do |key|\n        clean_params.delete(key)\n      end\n      clean_params[:customer_id] = current_user.id\n    end\n\n    # try to create customer if needed\n    if clean_params[:customer_id].present? && clean_params[:customer_id] =~ /^guess:(.+?)$/\n      email_address = $1\n      email_address_validation = EmailAddressValidation.new(email_address)\n      if !email_address_validation.valid_format?\n        render json: { error: \"Invalid email '#{email_address}' of customer\" }, status: :unprocessable_entity\n        return\n      end\n      local_customer = User.find_by(email: email_address.downcase)\n      if !local_customer\n        role_ids = Role.signup_role_ids\n        local_customer = User.create(\n          firstname: '',\n          lastname:  '',\n          email:     email_address,\n          password:  '',\n          active:    true,\n          role_ids:  role_ids,\n        )\n      end\n      clean_params[:customer_id] = local_customer.id\n    end\n\n    # try to create customer if needed\n    if clean_params[:customer_id].blank? && customer.present?\n      check_attributes_by_current_user_permission(customer)\n      clean_customer = User.association_name_to_id_convert(customer)\n      local_customer = nil\n      if !local_customer && clean_customer[:id].present?\n        local_customer = User.find_by(id: clean_customer[:id])\n      end\n      if !local_customer && clean_customer[:email].present?\n        local_customer = User.find_by(email: clean_customer[:email].downcase)\n      end\n      if !local_customer && clean_customer[:login].present?\n        local_customer = User.find_by(login: clean_customer[:login].downcase)\n      end\n      if !local_customer\n        role_ids = Role.signup_role_ids\n        local_customer = User.new(clean_customer)\n        local_customer.role_ids = role_ids\n        local_customer.save!\n      end\n      clean_params[:customer_id] = local_customer.id\n    end\n\n    clean_params = Ticket.param_cleanup(clean_params, true)\n    ticket = Ticket.new(clean_params)\n\n    # check if article is given\n    if !params[:article]\n      render json: { error: 'article hash is missing' }, status: :unprocessable_entity\n      return\n    end\n\n    # create ticket\n    ticket.save!\n    ticket.with_lock do\n\n      # create tags if given\n      if params[:tags].present?\n        tags = params[:tags].split(/,/)\n        tags.each do |tag|\n          ticket.tag_add(tag)\n        end\n      end\n\n      # create article if given\n      if params[:article]\n        article_create(ticket, params[:article])\n      end\n    end\n    # create links (e. g. in case of ticket split)\n    # links: {\n    #   Ticket: {\n    #     parent: [ticket_id1, ticket_id2, ...]\n    #     normal: [ticket_id1, ticket_id2, ...]\n    #     child: [ticket_id1, ticket_id2, ...]\n    #   },\n    # }\n    if params[:links].present?\n      link = params[:links].permit!.to_h\n      raise Exceptions::UnprocessableEntity, 'Invalid link structure' if !link.is_a? Hash\n\n      link.each do |target_object, link_types_with_object_ids|\n        raise Exceptions::UnprocessableEntity, 'Invalid link structure (Object)' if !link_types_with_object_ids.is_a? Hash\n\n        link_types_with_object_ids.each do |link_type, object_ids|\n          raise Exceptions::UnprocessableEntity, 'Invalid link structure (Object->LinkType)' if !object_ids.is_a? Array\n\n          object_ids.each do |local_object_id|\n            link = Link.add(\n              link_type:                link_type,\n              link_object_target:       target_object,\n              link_object_target_value: local_object_id,\n              link_object_source:       'Ticket',\n              link_object_source_value: ticket.id,\n            )\n          end\n        end\n      end\n    end\n\n    if response_expand?\n      result = ticket.reload.attributes_with_association_names\n      render json: result, status: :created\n      return\n    end\n\n    if response_full?\n      full = Ticket.full(ticket.id)\n      render json: full, status: :created\n      return\n    end\n\n    if response_all?\n      render json: ticket_all(ticket.reload), status: :created\n      return\n    end\n\n    render json: ticket.reload.attributes_with_association_ids, status: :created\n  end\n\n  # PUT /api/v1/tickets/1\n  def update\n    ticket = Ticket.find(params[:id])\n    authorize!(ticket, :follow_up?)\n    authorize!(ticket)\n\n    clean_params = Ticket.association_name_to_id_convert(params)\n    clean_params = Ticket.param_cleanup(clean_params, true)\n\n    # only apply preferences changes (keep not updated keys/values)\n    clean_params = ticket.param_preferences_merge(clean_params)\n\n    # disable changes on ticket number\n    clean_params.delete('number')\n\n    # overwrite params\n    if !current_user.permissions?('ticket.agent')\n      %i[owner owner_id customer customer_id organization organization_id preferences].each do |key|\n        clean_params.delete(key)\n      end\n    end\n\n    ticket.with_lock do\n      ticket.update!(clean_params)\n      if params[:article]\n        article_create(ticket, params[:article])\n      end\n    end\n\n    if response_expand?\n      result = ticket.reload.attributes_with_association_names\n      render json: result, status: :ok\n      return\n    end\n\n    if response_full?\n      full = Ticket.full(params[:id])\n      render json: full, status: :ok\n      return\n    end\n\n    if response_all?\n      render json: ticket_all(ticket.reload), status: :ok\n      return\n    end\n\n    render json: ticket.reload.attributes_with_association_ids, status: :ok\n  end\n\n  # DELETE /api/v1/tickets/1\n  def destroy\n    ticket = Ticket.find(params[:id])\n    authorize!(ticket)\n\n    ticket.destroy!\n\n    head :ok\n  end\n\n  # GET /api/v1/ticket_customer\n  # GET /api/v1/tickets_customer\n  def ticket_customer\n\n    # return result\n    result = Ticket::ScreenOptions.list_by_customer(\n      current_user: current_user,\n      customer_id:  params[:customer_id],\n      limit:        15,\n    )\n    render json: result\n  end\n\n  # GET /api/v1/ticket_history/1\n  def ticket_history\n\n    # get ticket data\n    ticket = Ticket.find(params[:id])\n    authorize!(ticket, :show?)\n\n    # get history of ticket\n    render json: ticket.history_get(true)\n  end\n\n  # GET /api/v1/ticket_related/1\n  def ticket_related\n\n    ticket = Ticket.find(params[:ticket_id])\n    assets = ticket.assets({})\n\n    # open tickets by customer\n    access_condition = Ticket.access_condition(current_user, 'read')\n\n    ticket_lists = Ticket\n                   .where(\n                     customer_id: ticket.customer_id,\n                     state_id:    Ticket::State.by_category(:open).pluck(:id),\n                   )\n                   .where(access_condition)\n                   .where('id != ?', [ ticket.id ])\n                   .order(created_at: :desc)\n                   .limit(6)\n\n    # if we do not have open related tickets, search for any tickets\n    if ticket_lists.blank?\n      ticket_lists = Ticket\n                     .where(\n                       customer_id: ticket.customer_id,\n                     ).where.not(\n                       state_id: Ticket::State.by_category(:merged).pluck(:id),\n                     )\n                     .where(access_condition)\n                     .where('id != ?', [ ticket.id ])\n                     .order(created_at: :desc)\n                     .limit(6)\n    end\n\n    # get related assets\n    ticket_ids_by_customer = []\n    ticket_lists.each do |ticket_list|\n      ticket_ids_by_customer.push ticket_list.id\n      assets = ticket_list.assets(assets)\n    end\n\n    ticket_ids_recent_viewed = []\n    recent_views = RecentView.list(current_user, 8, 'Ticket')\n    recent_views.each do |recent_view|\n      next if recent_view.object.name != 'Ticket'\n      next if recent_view.o_id == ticket.id\n\n      ticket_ids_recent_viewed.push recent_view.o_id\n      recent_view_ticket = Ticket.find(recent_view.o_id)\n      assets = recent_view_ticket.assets(assets)\n    end\n\n    # return result\n    render json: {\n      assets:                   assets,\n      ticket_ids_by_customer:   ticket_ids_by_customer,\n      ticket_ids_recent_viewed: ticket_ids_recent_viewed,\n    }\n  end\n\n  # GET /api/v1/ticket_recent\n  def ticket_recent\n    ticket_ids = RecentView.list(current_user, 10, Ticket.name).map(&:o_id)\n    tickets    = ticket_ids.map { |elem| Ticket.lookup(id: elem) }\n    assets     = ApplicationModel::CanAssets.reduce(tickets)\n\n    render json: {\n      assets:                   assets,\n      ticket_ids_recent_viewed: ticket_ids\n    }\n  end\n\n  # GET /api/v1/ticket_merge/1/1\n  def ticket_merge\n\n    # check master ticket\n    ticket_master = Ticket.find_by(number: params[:master_ticket_number])\n    if !ticket_master\n      render json: {\n        result:  'failed',\n        message: 'No such master ticket number!',\n      }\n      return\n    end\n    authorize!(ticket_master, :update?)\n\n    # check slave ticket\n    ticket_slave = Ticket.find_by(id: params[:slave_ticket_id])\n    if !ticket_slave\n      render json: {\n        result:  'failed',\n        message: 'No such slave ticket!',\n      }\n      return\n    end\n    authorize!(ticket_slave, :update?)\n\n    # merge ticket\n    ticket_slave.merge_to(\n      ticket_id:     ticket_master.id,\n      created_by_id: current_user.id,\n    )\n\n    # return result\n    render json: {\n      result:        'success',\n      master_ticket: ticket_master.attributes,\n      slave_ticket:  ticket_slave.attributes,\n    }\n  end\n\n  # GET /api/v1/ticket_split\n  def ticket_split\n    ticket = Ticket.find(params[:ticket_id])\n    authorize!(ticket, :show?)\n    assets = ticket.assets({})\n\n    article = Ticket::Article.find(params[:article_id])\n    authorize!(article.ticket, :show?)\n    assets = article.assets(assets)\n\n    render json: {\n      assets:      assets,\n      attachments: article_attachments_clone(article),\n    }\n  end\n\n  # GET /api/v1/ticket_create\n  def ticket_create\n\n    # get attributes to update\n    attributes_to_change = Ticket::ScreenOptions.attributes_to_change(\n      current_user: current_user,\n    )\n    render json: attributes_to_change\n  end\n\n  # GET /api/v1/tickets/search\n  def search\n\n    # permit nested conditions\n    if params[:condition]\n      params.require(:condition).permit!\n    end\n\n    per_page = params[:per_page] || params[:limit] || 50\n    per_page = per_page.to_i\n    if per_page > 200\n      per_page = 200\n    end\n    page = params[:page] || 1\n    page = page.to_i\n    offset = (page - 1) * per_page\n\n    query = params[:query]\n    if query.respond_to?(:permit!)\n      query = query.permit!.to_h\n    end\n\n    # build result list\n    tickets = Ticket.search(\n      query:        query,\n      condition:    params[:condition].to_h,\n      limit:        per_page,\n      offset:       offset,\n      order_by:     params[:order_by],\n      sort_by:      params[:sort_by],\n      current_user: current_user,\n    )\n\n    if response_expand?\n      list = []\n      tickets.each do |ticket|\n        list.push ticket.attributes_with_association_names\n      end\n      render json: list, status: :ok\n      return\n    end\n\n    assets = {}\n    ticket_result = []\n    tickets.each do |ticket|\n      ticket_result.push ticket.id\n      assets = ticket.assets(assets)\n    end\n\n    # return result\n    render json: {\n      tickets:       ticket_result,\n      tickets_count: tickets.count,\n      assets:        assets,\n    }\n  end\n\n  # GET /api/v1/tickets/selector\n  def selector\n    ticket_count, tickets = Ticket.selectors(params[:condition], limit: 6, execution_time: true)\n\n    assets = {}\n    ticket_ids = []\n    tickets&.each do |ticket|\n      ticket_ids.push ticket.id\n      assets = ticket.assets(assets)\n    end\n\n    # return result\n    render json: {\n      ticket_ids:   ticket_ids,\n      ticket_count: ticket_count || 0,\n      assets:       assets,\n    }\n  end\n\n  # GET /api/v1/ticket_stats\n  def stats\n\n    if !params[:user_id] && !params[:organization_id]\n      raise 'Need user_id or organization_id as param'\n    end\n\n    # lookup open user tickets\n    limit            = 100\n    assets           = {}\n    access_condition = Ticket.access_condition(current_user, 'read')\n\n    user_tickets = {}\n    if params[:user_id]\n      user = User.lookup(id: params[:user_id])\n      if !user\n        raise \"No such user with id #{params[:user_id]}\"\n      end\n\n      conditions = {\n        closed_ids: {\n          'ticket.state_id'    => {\n            operator: 'is',\n            value:    Ticket::State.by_category(:closed).pluck(:id),\n          },\n          'ticket.customer_id' => {\n            operator: 'is',\n            value:    user.id,\n          },\n        },\n        open_ids:   {\n          'ticket.state_id'    => {\n            operator: 'is',\n            value:    Ticket::State.by_category(:open).pluck(:id),\n          },\n          'ticket.customer_id' => {\n            operator: 'is',\n            value:    user.id,\n          },\n        },\n      }\n      conditions.each do |key, local_condition|\n        user_tickets[key] = ticket_ids_and_assets(local_condition, current_user, limit, assets)\n      end\n\n      # generate stats by user\n      condition = {\n        'tickets.customer_id' => user.id,\n      }\n      user_tickets[:volume_by_year] = ticket_stats_last_year(condition, access_condition)\n\n    end\n\n    # lookup open org tickets\n    org_tickets = {}\n    if params[:organization_id].present?\n      organization = Organization.lookup(id: params[:organization_id])\n      if !organization\n        raise \"No such organization with id #{params[:organization_id]}\"\n      end\n\n      conditions = {\n        closed_ids: {\n          'ticket.state_id'        => {\n            operator: 'is',\n            value:    Ticket::State.by_category(:closed).pluck(:id),\n          },\n          'ticket.organization_id' => {\n            operator: 'is',\n            value:    organization.id,\n          },\n        },\n        open_ids:   {\n          'ticket.state_id'        => {\n            operator: 'is',\n            value:    Ticket::State.by_category(:open).pluck(:id),\n          },\n          'ticket.organization_id' => {\n            operator: 'is',\n            value:    organization.id,\n          },\n        },\n      }\n      conditions.each do |key, local_condition|\n        org_tickets[key] = ticket_ids_and_assets(local_condition, current_user, limit, assets)\n      end\n\n      # generate stats by org\n      condition = {\n        'tickets.organization_id' => organization.id,\n      }\n      org_tickets[:volume_by_year] = ticket_stats_last_year(condition, access_condition)\n    end\n\n    # return result\n    render json: {\n      user:         user_tickets,\n      organization: org_tickets,\n      assets:       assets,\n    }\n  end\n\n  # @path    [GET] /tickets/import_example\n  #\n  # @summary          Download of example CSV file.\n  # @notes            The requester have 'admin' permissions to be able to download it.\n  # @example          curl -u 'me@example.com:test' http://localhost:3000/api/v1/tickets/import_example\n  #\n  # @response_message 200 File download.\n  # @response_message 401 Invalid session.\n  def import_example\n    csv_string = Ticket.csv_example(\n      col_sep: ',',\n    )\n    send_data(\n      csv_string,\n      filename:    'example.csv',\n      type:        'text/csv',\n      disposition: 'attachment'\n    )\n\n  end\n\n  # @path    [POST] /tickets/import\n  #\n  # @summary          Starts import.\n  # @notes            The requester have 'admin' permissions to be create a new import.\n  # @example          curl -u 'me@example.com:test' -F 'file=@/path/to/file/tickets.csv' 'https://your.zammad/api/v1/tickets/import?try=true'\n  # @example          curl -u 'me@example.com:test' -F 'file=@/path/to/file/tickets.csv' 'https://your.zammad/api/v1/tickets/import'\n  #\n  # @response_message 201 Import started.\n  # @response_message 401 Invalid session.\n  def import_start\n    if Setting.get('import_mode') != true\n      raise 'Only can import tickets if system is in import mode.'\n    end\n\n    string = params[:data]\n    if string.blank? && params[:file].present?\n      string = params[:file].read.force_encoding('utf-8')\n    end\n    raise Exceptions::UnprocessableEntity, 'No source data submitted!' if string.blank?\n\n    result = Ticket.csv_import(\n      string:       string,\n      parse_params: {\n        col_sep: params[:col_sep] || ',',\n      },\n      try:          params[:try],\n    )\n    render json: result, status: :ok\n  end\n\n  private\n\n  def ticket_all(ticket)\n\n    # get attributes to update\n    attributes_to_change = Ticket::ScreenOptions.attributes_to_change(\n      current_user: current_user,\n      ticket:       ticket\n    )\n\n    # get related users\n    assets = attributes_to_change[:assets]\n    assets = ticket.assets(assets)\n\n    # get related users\n    article_ids = []\n    ticket.articles.each do |article|\n      next if !authorized?(article, :show?)\n\n      article_ids.push article.id\n      assets = article.assets(assets)\n    end\n\n    # get links\n    links = Link.list(\n      link_object:       'Ticket',\n      link_object_value: ticket.id,\n    )\n\n    assets = Link.reduce_assets(assets, links)\n\n    # get tags\n    tags = ticket.tag_list\n\n    # return result\n    {\n      ticket_id:          ticket.id,\n      ticket_article_ids: article_ids,\n      assets:             assets,\n      links:              links,\n      tags:               tags,\n      form_meta:          attributes_to_change[:form_meta],\n    }\n  end\n\nend\n", "class Controllers::TicketsControllerPolicy < Controllers::ApplicationControllerPolicy\n  permit! %i[import_example import_start], to: 'admin'\n  permit! :selector, to: 'admin.*'\n  permit! :create, to: ['ticket.agent', 'ticket.customer']\nend\n", "require 'rails_helper'\n\nRSpec.describe 'Ticket', type: :request do\n\n  let!(:ticket_group) do\n    create(:group, email_address: create(:email_address) )\n  end\n  let(:admin_user) do\n    create(:admin_user, groups: Group.all, firstname: 'Tickets', lastname: 'Admin')\n  end\n  let!(:agent_user) do\n    create(:agent_user, groups: Group.all, firstname: 'Tickets', lastname: 'Agent')\n  end\n  let!(:customer_user) do\n    create(\n      :customer_user,\n      login:     'tickets-customer1@example.com',\n      firstname: 'Tickets',\n      lastname:  'Customer1',\n      email:     'tickets-customer1@example.com',\n    )\n  end\n\n  describe 'request handling' do\n\n    it 'does ticket create with agent - missing group (01.01)' do\n      params = {\n        title:   'a new ticket #1',\n        article: {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n          sender:       'Customer',\n          type:         'note',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error_human']).to eq('Group can\\'t be blank')\n    end\n\n    it 'does ticket create with agent - wrong group (01.02)' do\n      params = {\n        title:   'a new ticket #2',\n        group:   'not_existing',\n        article: {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n          sender:       'Customer',\n          type:         'note',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('No lookup value found for \\'group\\': \"not_existing\"')\n    end\n\n    it 'does ticket create with agent - missing article.body (01.03)' do\n      params = {\n        title:       'a new ticket #3',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        state:       'new',\n        customer_id: customer_user.id,\n        article:     {},\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Need at least article: { body: \"some text\" }')\n    end\n\n    it 'does ticket create with agent - minimal article (01.03)' do\n      params = {\n        title:       'a new ticket #3',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        state:       'new',\n        customer_id: customer_user.id,\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #3')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n    end\n\n    it 'does ticket create with agent - minimal article and customer.email (01.04)' do\n      params = {\n        title:    'a new ticket #3',\n        group:    ticket_group.name,\n        priority: '2 normal',\n        state:    'new',\n        customer: customer_user.email,\n        article:  {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #3')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n    end\n\n    it 'does ticket create with agent - wrong owner_id - 0 (01.05)' do\n      params = {\n        title:       'a new ticket #4',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        owner_id:    0,\n        state:       'new',\n        customer_id: customer_user.id,\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Invalid value for param \\'owner_id\\': 0')\n    end\n\n    it 'does ticket create with agent - wrong owner_id - \"\" (01.06)' do\n      params = {\n        title:       'a new ticket #5',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        owner_id:    '',\n        state:       'new',\n        customer_id: customer_user.id,\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #5')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n    end\n\n    it 'does ticket create with agent - wrong owner_id - 99999 (01.07)' do\n      params = {\n        title:       'a new ticket #6',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        owner_id:    99_999,\n        state:       'new',\n        customer_id: customer_user.id,\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Invalid value for param \\'owner_id\\': 99999')\n    end\n\n    it 'does ticket create with agent - wrong owner_id - nil (01.08)' do\n      params = {\n        title:       'a new ticket #7',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        owner_id:    nil,\n        state:       'new',\n        customer_id: customer_user.id,\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #7')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n    end\n\n    it 'does ticket create with agent - minimal article with guess customer (01.09)' do\n      params = {\n        title:       'a new ticket #9',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        state:       'new',\n        customer_id: 'guess:some_new_customer@example.com',\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #9')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n    end\n\n    it 'does ticket create with agent - minimal article with guess customer (01.10)' do\n      params = {\n        title:       'a new ticket #10',\n        group:       ticket_group.name,\n        customer_id: 'guess:some_new_customer@example.com',\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #10')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash (01.11)' do\n      params = {\n        title:    'a new ticket #11',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #11')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (01.11)' do\n      params = {\n        title:    'a new ticket #11.1',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          body:      'some test 123',\n          origin_by: 'some_new_customer@example.com',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #11.1')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(agent_user.id)\n      expect(article.created_by_id).to eq(agent_user.id)\n      expect(article.origin_by_id).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('some firstname some lastname')\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (01.11)' do\n      params = {\n        title:    'a new ticket #11.2',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          sender:    'Customer',\n          body:      'some test 123',\n          origin_by: 'some_new_customer@example.com',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #11.2')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(agent_user.id)\n      expect(article.created_by_id).to eq(agent_user.id)\n      expect(article.origin_by_id).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('some firstname some lastname')\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (01.11)' do\n      params = {\n        title:    'a new ticket #11.3',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          sender:    'Agent',\n          from:      'somebody',\n          body:      'some test 123',\n          origin_by: 'some_new_customer@example.com',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #11.3')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(agent_user.id)\n      expect(article.created_by_id).to eq(agent_user.id)\n      expect(article.origin_by_id).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('some firstname some lastname')\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (01.11)' do\n      params = {\n        title:    'a new ticket #11.4',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          sender:    'Customer',\n          body:      'some test 123',\n          origin_by: customer_user.login,\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #11.4')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(agent_user.id)\n      expect(article.created_by_id).to eq(agent_user.id)\n      expect(article.origin_by_id).to eq(customer_user.id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('Tickets Customer1')\n    end\n\n    it 'does ticket create with agent - minimal article with missing body - with customer.id (01.12)' do\n      params = {\n        title:       'a new ticket #12',\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        article:     {\n          subject: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Need at least article: { body: \"some text\" }')\n    end\n\n    it 'does ticket create with agent - minimal article and attachment with customer (01.13)' do\n      params = {\n        title:       'a new ticket #13',\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            'filename'  => 'some_file.txt',\n            'data'      => 'dGVzdCAxMjM=',\n            'mime-type' => 'text/plain',\n          ],\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #13')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(1)\n      file = ticket.articles.first.attachments.first\n      expect(file.content).to eq('test 123')\n      expect(file.filename).to eq('some_file.txt')\n      expect(file.preferences['Mime-Type']).to eq('text/plain')\n      expect(file.preferences['Content-ID']).to be_falsey\n    end\n\n    it 'does ticket create with agent - minimal article and attachment with customer (01.14)' do\n      params = {\n        title:       'a new ticket #14',\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            {\n              'filename'  => 'some_file1.txt',\n              'data'      => 'dGVzdCAxMjM=',\n              'mime-type' => 'text/plain',\n            },\n            {\n              'filename'  => 'some_file2.txt',\n              'data'      => 'w6TDtsO8w58=',\n              'mime-type' => 'text/plain',\n            },\n          ],\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #14')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(2)\n      file = ticket.articles.first.attachments.first\n      expect(file.content).to eq('test 123')\n      expect(file.filename).to eq('some_file1.txt')\n      expect(file.preferences['Mime-Type']).to eq('text/plain')\n      expect(file.preferences['Content-ID']).to be_falsey\n    end\n\n    it 'does ticket create with agent - minimal article and simple invalid base64 attachment with customer (01.15)' do\n      params = {\n        title:       'a new ticket #15',\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            'filename'  => 'some_file.txt',\n            'data'      => 'ABC_INVALID_BASE64',\n            'mime-type' => 'text/plain',\n          ],\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Invalid base64 for attachment with index \\'0\\'')\n    end\n\n    it 'does ticket create with agent - minimal article and large invalid base64 attachment with customer (01.15a)' do\n      params = {\n        title:       'a new ticket #15a',\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            'filename'  => 'some_file.txt',\n            'data'      => \"LARGE_INVALID_BASE64_#{'#' * 20_000_000}\",\n            'mime-type' => 'text/plain',\n          ],\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Invalid base64 for attachment with index \\'0\\'')\n    end\n\n    it 'does ticket create with agent - minimal article and valid multiline base64 with linebreaks attachment with customer (01.15b)' do\n      params = {\n        title:       'a new ticket #15b',\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            'filename'  => 'some_file.txt',\n            'data'      => Base64.encode64('a' * 1_000),\n            'mime-type' => 'text/plain',\n          ],\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response['title']).to eq('a new ticket #15b')\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(1)\n      file = ticket.articles.first.attachments.first\n      expect(file.content).to eq('a' * 1_000)\n    end\n\n    it 'does ticket create with agent - minimal article and valid multiline base64 without linebreaks attachment with customer (01.15c)' do\n      params = {\n        title:       'a new ticket #15c',\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            'filename'  => 'some_file.txt',\n            'data'      => Base64.strict_encode64('a' * 1_000),\n            'mime-type' => 'text/plain',\n          ],\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response['title']).to eq('a new ticket #15c')\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(1)\n      file = ticket.articles.first.attachments.first\n      expect(file.content).to eq('a' * 1_000)\n    end\n\n    it 'does ticket create with agent - minimal article and attachment invalid base64 with customer (01.16)' do\n      params = {\n        title:       'a new ticket #16',\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            'filename' => 'some_file.txt',\n            'data'     => 'dGVzdCAxMjM=',\n          ],\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Attachment needs \\'mime-type\\' param for attachment with index \\'0\\'')\n    end\n\n    it 'does ticket create with agent - minimal article and inline attachments with customer (01.17)' do\n      params = {\n        title:       'a new ticket #17',\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        article:     {\n          content_type: 'text/html',\n          subject:      'some test 123',\n          body:         'some test 123 <img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA\n  AAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO\n  9TXL0Y4OHwAAAABJRU5ErkJggg==\" alt=\"Red dot\" /> <img src=\"data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAJAAD/4QMtaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjMtYzAxMSA2Ni4xNDU2NjEsIDIwMTIvMDIvMDYtMTQ6NTY6MjcgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzYgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QzJCOTE2NzlGQUEwMTFFNjg0M0NGQjU0OUU4MTFEOEIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QzJCOTE2N0FGQUEwMTFFNjg0M0NGQjU0OUU4MTFEOEIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpDMkI5MTY3N0ZBQTAxMUU2ODQzQ0ZCNTQ5RTgxMUQ4QiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpDMkI5MTY3OEZBQTAxMUU2ODQzQ0ZCNTQ5RTgxMUQ4QiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEABQRERoTGioZGSo1KCEoNTEpKCgpMUE4ODg4OEFEREREREREREREREREREREREREREREREREREREREREREREREQBFhoaIh0iKRoaKTkpIik5RDktLTlEREREOERERERERERERERERERERERERERERERERERERERERERERERERERERP/AABEIABAADAMBIgACEQEDEQH/xABbAAEBAAAAAAAAAAAAAAAAAAAEBQEBAQAAAAAAAAAAAAAAAAAABAUQAAEEAgMAAAAAAAAAAAAAAAABAhIDESIxBAURAAICAwAAAAAAAAAAAAAAAAESABNRoQP/2gAMAwEAAhEDEQA/AJDq1rfF3Imeg/1+lFy2oR564DKWWWbweV+Buf/Z\">',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #17')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(2)\n      file = ticket.articles.first.attachments[0]\n      expect(Digest::MD5.hexdigest(file.content)).to eq('d3c1e09bdefb92b6a06b791a24ca9599')\n      expect(file.filename).to eq('image1.png')\n      expect(file.preferences['Mime-Type']).to eq('image/png')\n      expect(file.preferences['Content-ID']).to match(/#{ticket.id}\\..+?@zammad.example.com/)\n      expect(file.preferences['Content-ID']).to be_truthy\n      file = ticket.articles.first.attachments[1]\n      expect(Digest::MD5.hexdigest(file.content)).to eq('006a2ca3793b550c8fe444acdeb39252')\n      expect(file.filename).to eq('image2.jpeg')\n      expect(file.preferences['Mime-Type']).to eq('image/jpeg')\n      expect(file.preferences['Content-ID']).to match(/#{ticket.id}\\..+?@zammad.example.com/)\n      expect(file.preferences['Content-ID']).to be_truthy\n    end\n\n    it 'does ticket create with agent - minimal article and inline attachments with customer (01.18)' do\n      params = {\n        title:       'a new ticket #18',\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        article:     {\n          content_type: 'text/html',\n          subject:      'some test 123',\n          body:         'some test 123 <img src=\"data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAJAAD/4QMtaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjMtYzAxMSA2Ni4xNDU2NjEsIDIwMTIvMDIvMDYtMTQ6NTY6MjcgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzYgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QzJCOTE2NzlGQUEwMTFFNjg0M0NGQjU0OUU4MTFEOEIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QzJCOTE2N0FGQUEwMTFFNjg0M0NGQjU0OUU4MTFEOEIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpDMkI5MTY3N0ZBQTAxMUU2ODQzQ0ZCNTQ5RTgxMUQ4QiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpDMkI5MTY3OEZBQTAxMUU2ODQzQ0ZCNTQ5RTgxMUQ4QiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEABQRERoTGioZGSo1KCEoNTEpKCgpMUE4ODg4OEFEREREREREREREREREREREREREREREREREREREREREREREREQBFhoaIh0iKRoaKTkpIik5RDktLTlEREREOERERERERERERERERERERERERERERERERERERERERERERERERERERP/AABEIABAADAMBIgACEQEDEQH/xABbAAEBAAAAAAAAAAAAAAAAAAAEBQEBAQAAAAAAAAAAAAAAAAAABAUQAAEEAgMAAAAAAAAAAAAAAAABAhIDESIxBAURAAICAwAAAAAAAAAAAAAAAAESABNRoQP/2gAMAwEAAhEDEQA/AJDq1rfF3Imeg/1+lFy2oR564DKWWWbweV+Buf/Z\"\n  >',\n          attachments:  [\n            'filename'  => 'some_file.txt',\n            'data'      => 'dGVzdCAxMjM=',\n            'mime-type' => 'text/plain',\n          ],\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #18')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(2)\n      file = ticket.articles.first.attachments[0]\n      expect(Digest::MD5.hexdigest(file.content)).to eq('006a2ca3793b550c8fe444acdeb39252')\n      expect(file.filename).to eq('image1.jpeg')\n      expect(file.preferences['Mime-Type']).to eq('image/jpeg')\n      expect(file.preferences['Content-ID']).to be_truthy\n      expect(file.preferences['Content-ID']).to match(/#{ticket.id}\\..+?@zammad.example.com/)\n      file = ticket.articles.first.attachments[1]\n      expect(Digest::MD5.hexdigest(file.content)).to eq('39d0d586a701e199389d954f2d592720')\n      expect(file.filename).to eq('some_file.txt')\n      expect(file.preferences['Mime-Type']).to eq('text/plain')\n      expect(file.preferences['Content-ID']).to be_falsey\n    end\n\n    it 'does ticket create with agent (02.02)' do\n      params = {\n        title:    'a new ticket #1',\n        state:    'new',\n        priority: '2 normal',\n        group:    ticket_group.name,\n        customer: 'tickets-customer1@example.com',\n        article:  {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n        },\n        links:    {\n          Ticket: {\n            parent: [1],\n          }\n        }\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #1')\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n      links = Link.list(\n        link_object:       'Ticket',\n        link_object_value: json_response['id'],\n      )\n      expect(links[0]['link_type']).to eq('child')\n      expect(links[0]['link_object']).to eq('Ticket')\n      expect(links[0]['link_object_value']).to eq(1)\n    end\n\n    it 'does ticket with wrong ticket id (02.03)' do\n      group = create(:group)\n      ticket = create(\n        :ticket,\n        title:       'ticket with wrong ticket id',\n        group_id:    group.id,\n        customer_id: customer_user.id,\n      )\n      authenticated_as(agent_user)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n\n      params = {\n        title: 'ticket with wrong ticket id - 2',\n      }\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n\n      delete \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n    end\n\n    it 'does ticket with correct ticket id (02.04)' do\n      title = \"ticket with corret ticket id testagent#{rand(999_999_999)}\"\n      ticket = create(\n        :ticket,\n        title:       title,\n        group:       ticket_group,\n        customer_id: customer_user.id,\n        preferences: {\n          some_key1: 123,\n        },\n      )\n      authenticated_as(agent_user)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(title)\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(1)\n      expect(json_response['created_by_id']).to eq(1)\n      expect(json_response['preferences']['some_key1']).to eq(123)\n\n      params = {\n        title:       \"#{title} - 2\",\n        customer_id: agent_user.id,\n        preferences: {\n          some_key2: 'abc',\n        },\n      }\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(\"#{title} - 2\")\n      expect(json_response['customer_id']).to eq(agent_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(1)\n      expect(json_response['preferences']['some_key1']).to eq(123)\n      expect(json_response['preferences']['some_key2']).to eq('abc')\n\n      params = {\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      article_json_response = json_response\n      expect(article_json_response).to be_a_kind_of(Hash)\n      expect(article_json_response['ticket_id']).to eq(ticket.id)\n      expect(article_json_response['from']).to eq('Tickets Agent')\n      expect(article_json_response['subject']).to eq('some subject')\n      expect(article_json_response['body']).to eq('some body')\n      expect(article_json_response['content_type']).to eq('text/plain')\n      expect(article_json_response['internal']).to eq(false)\n      expect(article_json_response['created_by_id']).to eq(agent_user.id)\n      expect(article_json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(article_json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id)\n\n      Scheduler.worker(true)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(ticket.id)\n      expect(json_response['tickets_count']).to eq(1)\n\n      params = {\n        condition: {\n          'ticket.title' => {\n            operator: 'contains',\n            value:    title,\n          },\n        },\n      }\n      post '/api/v1/tickets/search', params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(ticket.id)\n      expect(json_response['tickets_count']).to eq(1)\n\n      delete \"/api/v1/ticket_articles/#{article_json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      params = {\n        from:      'something which should not be changed on server side',\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n        type:      'email',\n        internal:  true,\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq(%(\"Tickets Agent via #{ticket_group.email_address.realname}\" <#{ticket_group.email_address.email}>))\n      expect(json_response['subject']).to eq('some subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(true)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'email').id)\n\n      params = {\n        subject: 'new subject',\n      }\n      put \"/api/v1/ticket_articles/#{json_response['id']}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq(%(\"Tickets Agent via #{ticket_group.email_address.realname}\" <#{ticket_group.email_address.email}>))\n      expect(json_response['subject']).to eq('new subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(true)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'email').id)\n\n      params = {\n        from:      'something which should not be changed on server side',\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n        type:      'email',\n        internal:  false,\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response['internal']).to eq(false)\n\n      delete \"/api/v1/ticket_articles/#{json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (admin permission required)!')\n\n      delete \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (admin permission required)!')\n    end\n\n    it 'does ticket with correct ticket id (02.05)' do\n      ticket = create(\n        :ticket,\n        title:       'ticket with corret ticket id',\n        group:       ticket_group,\n        customer_id: customer_user.id,\n      )\n      authenticated_as(admin_user)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq('ticket with corret ticket id')\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(1)\n      expect(json_response['created_by_id']).to eq(1)\n\n      params = {\n        title:       'ticket with corret ticket id - 2',\n        customer_id: agent_user.id,\n      }\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq('ticket with corret ticket id - 2')\n      expect(json_response['customer_id']).to eq(agent_user.id)\n      expect(json_response['updated_by_id']).to eq(admin_user.id)\n      expect(json_response['created_by_id']).to eq(1)\n\n      params = {\n        from:      'something which should not be changed on server side',\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq('Tickets Admin')\n      expect(json_response['subject']).to eq('some subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(false)\n      expect(json_response['created_by_id']).to eq(admin_user.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id)\n\n      params = {\n        subject:  'new subject',\n        internal: true,\n      }\n      put \"/api/v1/ticket_articles/#{json_response['id']}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq('Tickets Admin')\n      expect(json_response['subject']).to eq('new subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(true)\n      expect(json_response['created_by_id']).to eq(admin_user.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id)\n\n      delete \"/api/v1/ticket_articles/#{json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      params = {\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n        type:      'email',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq(%(\"Tickets Admin via #{ticket_group.email_address.realname}\" <#{ticket_group.email_address.email}>))\n      expect(json_response['subject']).to eq('some subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(false)\n      expect(json_response['created_by_id']).to eq(admin_user.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'email').id)\n\n      delete \"/api/v1/ticket_articles/#{json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      delete \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n    end\n\n    it 'does ticket pagination (02.05)' do\n      title = \"ticket pagination #{rand(999_999_999)}\"\n      tickets = []\n      (1..20).each do |count|\n        ticket = create(\n          :ticket,\n          title:       \"#{title} - #{count}\",\n          group:       ticket_group,\n          customer_id: customer_user.id,\n        )\n        create(\n          :ticket_article,\n          type:      Ticket::Article::Type.lookup(name: 'note'),\n          sender:    Ticket::Article::Sender.lookup(name: 'Customer'),\n          ticket_id: ticket.id,\n        )\n        tickets.push ticket\n        travel 2.seconds\n      end\n\n      authenticated_as(admin_user)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(tickets[19].id)\n      expect(json_response['tickets'][19]).to eq(tickets[0].id)\n      expect(json_response['tickets_count']).to eq(20)\n\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=10\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(tickets[19].id)\n      expect(json_response['tickets'][9]).to eq(tickets[10].id)\n      expect(json_response['tickets_count']).to eq(10)\n\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40&page=1&per_page=5\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(tickets[19].id)\n      expect(json_response['tickets'][4]).to eq(tickets[15].id)\n      expect(json_response['tickets_count']).to eq(5)\n\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40&page=2&per_page=5\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(tickets[14].id)\n      expect(json_response['tickets'][4]).to eq(tickets[10].id)\n      expect(json_response['tickets_count']).to eq(5)\n\n      get '/api/v1/tickets?limit=40&page=1&per_page=5', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Array)\n      tickets = Ticket.order(:id).limit(5)\n      expect(json_response[0]['id']).to eq(tickets[0].id)\n      expect(json_response[4]['id']).to eq(tickets[4].id)\n      expect(json_response.count).to eq(5)\n\n      get '/api/v1/tickets?limit=40&page=2&per_page=5', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Array)\n      tickets = Ticket.order(:id).limit(10)\n      expect(json_response[0]['id']).to eq(tickets[5].id)\n      expect(json_response[4]['id']).to eq(tickets[9].id)\n      expect(json_response.count).to eq(5)\n\n    end\n\n    it 'does ticket create with customer minimal (03.01)' do\n      params = {\n        title:    'a new ticket #c1',\n        state:    'new',\n        priority: '2 normal',\n        group:    ticket_group.name,\n        article:  {\n          body: 'some body',\n        },\n      }\n      authenticated_as(customer_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #c1')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(customer_user.id)\n      expect(json_response['created_by_id']).to eq(customer_user.id)\n    end\n\n    it 'does ticket create with customer with wrong customer (03.02)' do\n      params = {\n        title:       'a new ticket #c2',\n        state:       'new',\n        priority:    '2 normal',\n        group:       ticket_group.name,\n        customer_id: agent_user.id,\n        article:     {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n          sender:       'System',\n        },\n      }\n      authenticated_as(customer_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #c2')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(customer_user.id)\n      expect(json_response['created_by_id']).to eq(customer_user.id)\n    end\n\n    it 'does ticket create with customer with wrong customer hash (03.03)' do\n      params = {\n        title:    'a new ticket #c2',\n        state:    'new',\n        priority: '2 normal',\n        group:    ticket_group.name,\n        customer: {\n          firstname: agent_user.firstname,\n          lastname:  agent_user.lastname,\n          email:     agent_user.email,\n        },\n        article:  {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n          sender:       'System',\n        },\n      }\n      authenticated_as(customer_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #c2')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(customer_user.id)\n      expect(json_response['created_by_id']).to eq(customer_user.id)\n    end\n\n    it 'does ticket with wrong ticket id (03.04)' do\n      ticket = create(\n        :ticket,\n        title:       'ticket with wrong ticket id',\n        group:       ticket_group,\n        customer_id: agent_user.id,\n      )\n      authenticated_as(customer_user)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n\n      params = {\n        title: 'ticket with wrong ticket id - 2',\n      }\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n\n      delete \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n    end\n\n    it 'does ticket with correct ticket id (03.05)' do\n      title = \"ticket with corret ticket id testme#{rand(999_999_999)}\"\n      ticket = create(\n        :ticket,\n        title:       title,\n        group:       ticket_group,\n        customer_id: customer_user.id,\n      )\n      authenticated_as(customer_user)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(title)\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(1)\n      expect(json_response['created_by_id']).to eq(1)\n\n      params = {\n        title:       \"#{title} - 2\",\n        customer_id: agent_user.id,\n      }\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(\"#{title} - 2\")\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(customer_user.id)\n      expect(json_response['created_by_id']).to eq(1)\n\n      params = {\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      article_json_response = json_response\n      expect(article_json_response).to be_a_kind_of(Hash)\n      expect(article_json_response['ticket_id']).to eq(ticket.id)\n      expect(article_json_response['from']).to eq('Tickets Customer1')\n      expect(article_json_response['subject']).to eq('some subject')\n      expect(article_json_response['body']).to eq('some body')\n      expect(article_json_response['content_type']).to eq('text/plain')\n      expect(article_json_response['created_by_id']).to eq(customer_user.id)\n      expect(article_json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Customer').id)\n      expect(article_json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id)\n\n      Scheduler.worker(true)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(ticket.id)\n      expect(json_response['tickets_count']).to eq(1)\n\n      params = {\n        condition: {\n          'ticket.title' => {\n            operator: 'contains',\n            value:    title,\n          },\n        },\n      }\n      post '/api/v1/tickets/search', params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(ticket.id)\n      expect(json_response['tickets_count']).to eq(1)\n\n      delete \"/api/v1/ticket_articles/#{article_json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (admin permission required)!')\n\n      params = {\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n        type:      'email',\n        sender:    'Agent',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq('Tickets Customer1')\n      expect(json_response['subject']).to eq('some subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['created_by_id']).to eq(customer_user.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Customer').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id)\n\n      delete \"/api/v1/ticket_articles/#{json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (admin permission required)!')\n\n      params = {\n        from:      'something which should not be changed on server side',\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n        type:      'web',\n        sender:    'Agent',\n        internal:  true,\n      }\n\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq('Tickets Customer1 <tickets-customer1@example.com>')\n      expect(json_response['subject']).to eq('some subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(false)\n      expect(json_response['created_by_id']).to eq(customer_user.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Customer').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'web').id)\n\n      params = {\n        subject: 'new subject',\n      }\n      put \"/api/v1/ticket_articles/#{json_response['id']}\", params: params, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (ticket.agent or admin permission required)!')\n\n      delete \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (admin permission required)!')\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (03.6)' do\n      authenticated_as(customer_user)\n      params = {\n        title:    'a new ticket #3.6',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          body:      'some test 123',\n          origin_by: agent_user.login,\n        },\n      }\n\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #3.6')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(customer_user.id)\n      expect(json_response['created_by_id']).to eq(customer_user.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(customer_user.id)\n      expect(article.created_by_id).to eq(customer_user.id)\n      expect(article.origin_by_id).to eq(customer_user.id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('Tickets Customer1')\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (03.6)' do\n      authenticated_as(customer_user)\n      params = {\n        title:    'a new ticket #3.6.1',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          sender:       'Agent',\n          body:         'some test 123',\n          origin_by_id: agent_user.id,\n        },\n      }\n\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #3.6.1')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(customer_user.id)\n      expect(json_response['created_by_id']).to eq(customer_user.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(customer_user.id)\n      expect(article.created_by_id).to eq(customer_user.id)\n      expect(article.origin_by_id).to eq(customer_user.id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('Tickets Customer1')\n    end\n\n    it 'does ticket show and response format (04.01)' do\n      title = \"ticket testagent#{rand(999_999_999)}\"\n      ticket = create(\n        :ticket,\n        title:         title,\n        group:         ticket_group,\n        customer_id:   customer_user.id,\n        updated_by_id: agent_user.id,\n        created_by_id: agent_user.id,\n      )\n      authenticated_as(agent_user)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(ticket.title)\n      expect(json_response['group']).to be_falsey\n      expect(json_response['priority']).to be_falsey\n      expect(json_response['owner']).to be_falsey\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      get \"/api/v1/tickets/#{ticket.id}?expand=true\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(ticket.title)\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['group']).to eq(ticket.group.name)\n      expect(json_response['priority']).to eq(ticket.priority.name)\n      expect(json_response['owner']).to eq(ticket.owner.login)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      get \"/api/v1/tickets/#{ticket.id}?expand=false\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(ticket.title)\n      expect(json_response['group']).to be_falsey\n      expect(json_response['priority']).to be_falsey\n      expect(json_response['owner']).to be_falsey\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      get \"/api/v1/tickets/#{ticket.id}?full=true\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['id']).to eq(ticket.id)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['title']).to eq(ticket.title)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['customer_id']).to eq(ticket.customer_id)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][agent_user.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][agent_user.id.to_s]['id']).to eq(agent_user.id)\n      expect(json_response['assets']['User'][agent_user.id.to_s]['firstname']).to eq(agent_user.firstname)\n      expect(json_response['assets']['User'][agent_user.id.to_s]['lastname']).to eq(agent_user.lastname)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][customer_user.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][customer_user.id.to_s]['id']).to eq(customer_user.id)\n      expect(json_response['assets']['User'][customer_user.id.to_s]['firstname']).to eq(customer_user.firstname)\n      expect(json_response['assets']['User'][customer_user.id.to_s]['lastname']).to eq(customer_user.lastname)\n\n      get \"/api/v1/tickets/#{ticket.id}?full=false\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(ticket.title)\n      expect(json_response['group']).to be_falsey\n      expect(json_response['priority']).to be_falsey\n      expect(json_response['owner']).to be_falsey\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n    end\n\n    it 'does ticket index and response format (04.02)' do\n      title = \"ticket testagent#{rand(999_999_999)}\"\n      ticket = create(\n        :ticket,\n        title:         title,\n        group:         ticket_group,\n        customer_id:   customer_user.id,\n        updated_by_id: agent_user.id,\n        created_by_id: agent_user.id,\n      )\n      authenticated_as(agent_user)\n      get '/api/v1/tickets', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      expect(json_response).to be_a_kind_of(Array)\n      expect(json_response[0]).to be_a_kind_of(Hash)\n      expect(json_response[0]['id']).to eq(1)\n      expect(json_response[1]['id']).to eq(ticket.id)\n      expect(json_response[1]['title']).to eq(ticket.title)\n      expect(json_response[1]['group']).to be_falsey\n      expect(json_response[1]['priority']).to be_falsey\n      expect(json_response[1]['owner']).to be_falsey\n      expect(json_response[1]['customer_id']).to eq(ticket.customer_id)\n      expect(json_response[1]['updated_by_id']).to eq(agent_user.id)\n      expect(json_response[1]['created_by_id']).to eq(agent_user.id)\n\n      get '/api/v1/tickets?expand=true', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Array)\n      expect(json_response[0]).to be_a_kind_of(Hash)\n      expect(json_response[0]['id']).to eq(1)\n      expect(json_response[1]['id']).to eq(ticket.id)\n      expect(json_response[1]['title']).to eq(ticket.title)\n      expect(json_response[1]['customer_id']).to eq(ticket.customer_id)\n      expect(json_response[1]['group']).to eq(ticket.group.name)\n      expect(json_response[1]['priority']).to eq(ticket.priority.name)\n      expect(json_response[1]['owner']).to eq(ticket.owner.login)\n      expect(json_response[1]['updated_by_id']).to eq(agent_user.id)\n      expect(json_response[1]['created_by_id']).to eq(agent_user.id)\n\n      get '/api/v1/tickets?expand=false', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Array)\n      expect(json_response[0]).to be_a_kind_of(Hash)\n      expect(json_response[0]['id']).to eq(1)\n      expect(json_response[1]['id']).to eq(ticket.id)\n      expect(json_response[1]['title']).to eq(ticket.title)\n      expect(json_response[1]['group']).to be_falsey\n      expect(json_response[1]['priority']).to be_falsey\n      expect(json_response[1]['owner']).to be_falsey\n      expect(json_response[1]['customer_id']).to eq(ticket.customer_id)\n      expect(json_response[1]['updated_by_id']).to eq(agent_user.id)\n      expect(json_response[1]['created_by_id']).to eq(agent_user.id)\n\n      get '/api/v1/tickets?full=true', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['record_ids'].class).to eq(Array)\n      expect(json_response['record_ids'][0]).to eq(1)\n      expect(json_response['record_ids'][1]).to eq(ticket.id)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['id']).to eq(ticket.id)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['title']).to eq(ticket.title)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['customer_id']).to eq(ticket.customer_id)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][agent_user.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][agent_user.id.to_s]['id']).to eq(agent_user.id)\n      expect(json_response['assets']['User'][agent_user.id.to_s]['firstname']).to eq(agent_user.firstname)\n      expect(json_response['assets']['User'][agent_user.id.to_s]['lastname']).to eq(agent_user.lastname)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][customer_user.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][customer_user.id.to_s]['id']).to eq(customer_user.id)\n      expect(json_response['assets']['User'][customer_user.id.to_s]['firstname']).to eq(customer_user.firstname)\n      expect(json_response['assets']['User'][customer_user.id.to_s]['lastname']).to eq(customer_user.lastname)\n\n      get '/api/v1/tickets?full=false', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Array)\n      expect(json_response[0]).to be_a_kind_of(Hash)\n      expect(json_response[0]['id']).to eq(1)\n      expect(json_response[1]['id']).to eq(ticket.id)\n      expect(json_response[1]['title']).to eq(ticket.title)\n      expect(json_response[1]['group']).to be_falsey\n      expect(json_response[1]['priority']).to be_falsey\n      expect(json_response[1]['owner']).to be_falsey\n      expect(json_response[1]['customer_id']).to eq(ticket.customer_id)\n      expect(json_response[1]['updated_by_id']).to eq(agent_user.id)\n      expect(json_response[1]['created_by_id']).to eq(agent_user.id)\n    end\n\n    it 'does ticket create and response format (04.03)' do\n      title = \"ticket testagent#{rand(999_999_999)}\"\n      params = {\n        title:       title,\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        state:       'new',\n        priority:    '2 normal',\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['state_id']).to eq(ticket.state_id)\n      expect(json_response['state']).to be_falsey\n      expect(json_response['priority_id']).to eq(ticket.priority_id)\n      expect(json_response['priority']).to be_falsey\n      expect(json_response['group_id']).to eq(ticket.group_id)\n      expect(json_response['group']).to be_falsey\n      expect(json_response['title']).to eq(title)\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      post '/api/v1/tickets?expand=true', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['state_id']).to eq(ticket.state_id)\n      expect(json_response['state']).to eq(ticket.state.name)\n      expect(json_response['priority_id']).to eq(ticket.priority_id)\n      expect(json_response['priority']).to eq(ticket.priority.name)\n      expect(json_response['group_id']).to eq(ticket.group_id)\n      expect(json_response['group']).to eq(ticket.group.name)\n      expect(json_response['title']).to eq(title)\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      post '/api/v1/tickets?full=true', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['id']).to eq(ticket.id)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['title']).to eq(title)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['customer_id']).to eq(ticket.customer_id)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][agent_user.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][agent_user.id.to_s]['id']).to eq(agent_user.id)\n      expect(json_response['assets']['User'][agent_user.id.to_s]['firstname']).to eq(agent_user.firstname)\n      expect(json_response['assets']['User'][agent_user.id.to_s]['lastname']).to eq(agent_user.lastname)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][customer_user.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][customer_user.id.to_s]['id']).to eq(customer_user.id)\n      expect(json_response['assets']['User'][customer_user.id.to_s]['firstname']).to eq(customer_user.firstname)\n      expect(json_response['assets']['User'][customer_user.id.to_s]['lastname']).to eq(customer_user.lastname)\n\n    end\n\n    it 'does ticket update and response formats (04.04)' do\n      title = \"ticket testagent#{rand(999_999_999)}\"\n      ticket = create(\n        :ticket,\n        title:         title,\n        group:         ticket_group,\n        customer_id:   customer_user.id,\n        updated_by_id: agent_user.id,\n        created_by_id: agent_user.id,\n      )\n\n      params = {\n        title: 'a update ticket #1',\n      }\n      authenticated_as(agent_user)\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['state_id']).to eq(ticket.state_id)\n      expect(json_response['state']).to be_falsey\n      expect(json_response['priority_id']).to eq(ticket.priority_id)\n      expect(json_response['priority']).to be_falsey\n      expect(json_response['group_id']).to eq(ticket.group_id)\n      expect(json_response['group']).to be_falsey\n      expect(json_response['title']).to eq('a update ticket #1')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      params = {\n        title: 'a update ticket #2',\n      }\n      put \"/api/v1/tickets/#{ticket.id}?expand=true\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['state_id']).to eq(ticket.state_id)\n      expect(json_response['state']).to eq(ticket.state.name)\n      expect(json_response['priority_id']).to eq(ticket.priority_id)\n      expect(json_response['priority']).to eq(ticket.priority.name)\n      expect(json_response['group_id']).to eq(ticket.group_id)\n      expect(json_response['group']).to eq(ticket.group.name)\n      expect(json_response['title']).to eq('a update ticket #2')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      params = {\n        title: 'a update ticket #3',\n      }\n      put \"/api/v1/tickets/#{ticket.id}?full=true\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['id']).to eq(ticket.id)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['title']).to eq('a update ticket #3')\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['customer_id']).to eq(ticket.customer_id)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][agent_user.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][agent_user.id.to_s]['id']).to eq(agent_user.id)\n      expect(json_response['assets']['User'][agent_user.id.to_s]['firstname']).to eq(agent_user.firstname)\n      expect(json_response['assets']['User'][agent_user.id.to_s]['lastname']).to eq(agent_user.lastname)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][customer_user.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][customer_user.id.to_s]['id']).to eq(customer_user.id)\n      expect(json_response['assets']['User'][customer_user.id.to_s]['firstname']).to eq(customer_user.firstname)\n      expect(json_response['assets']['User'][customer_user.id.to_s]['lastname']).to eq(customer_user.lastname)\n\n      # it should be not possible to modify the ticket number\n      expected_ticket_number = ticket.number\n      params = {\n        title:  'a update ticket #4',\n        number: '77777',\n      }\n      put \"/api/v1/tickets/#{ticket.id}?full=true\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['title']).to eq('a update ticket #4')\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['number']).to eq(expected_ticket_number)\n    end\n\n    it 'does ticket split with html - check attachments (05.01)' do\n      ticket = create(\n        :ticket,\n        title:         'some title',\n        group:         ticket_group,\n        customer_id:   customer_user.id,\n        updated_by_id: agent_user.id,\n        created_by_id: agent_user.id,\n      )\n      article = create(\n        :ticket_article,\n        type:         Ticket::Article::Type.lookup(name: 'note'),\n        sender:       Ticket::Article::Sender.lookup(name: 'Customer'),\n        body:         '<b>test</b> <img src=\"cid:15.274327094.140938@ZAMMAD.example.com\"/> test <img src=\"cid:15.274327094.140938.3@ZAMMAD.example.com\"/>',\n        content_type: 'text/html',\n        ticket_id:    ticket.id,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_image',\n        filename:      'some_file1.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file2_normally_should_be_an_image',\n        filename:      'some_file2.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938.2@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file3_normally_should_be_an_image',\n        filename:      'some_file3.jpg',\n        preferences:   {\n          'Content-Type' => 'image/jpeg',\n          'Mime-Type'    => 'image/jpeg',\n          'Content-ID'   => '15.274327094.140938.3@zammad.example.com',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file4_normally_should_be_an_image',\n        filename:      'some_file4.jpg',\n        preferences:   {\n          'Content-Type' => 'image/jpeg',\n          'Mime-Type'    => 'image/jpeg',\n          'Content-ID'   => '15.274327094.140938.4@zammad.example.com',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_pdf',\n        filename:      'Rechnung_RE-2018-200.pdf',\n        preferences:   {\n          'Content-Type'        => 'application/octet-stream; name=\"Rechnung_RE-2018-200.pdf\"',\n          'Mime-Type'           => 'application/octet-stream',\n          'Content-ID'          => '8AB0BEC88984EE4EBEF643C79C8E0346@zammad.example.com',\n          'Content-Description' => 'Rechnung_RE-2018-200.pdf',\n          'Content-Disposition' => 'attachment',\n        },\n        created_by_id: 1,\n      )\n\n      authenticated_as(agent_user)\n      get \"/api/v1/ticket_split?ticket_id=#{ticket.id}&article_id=#{article.id}&form_id=new_form_id123\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['TicketArticle'][article.id.to_s]).to be_truthy\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(3)\n\n      get \"/api/v1/ticket_split?ticket_id=#{ticket.id}&article_id=#{article.id}&form_id=new_form_id123\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['TicketArticle'][article.id.to_s]).to be_truthy\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(0)\n\n    end\n\n    it 'does ticket split with plain - check attachments (05.02)' do\n      ticket = create(\n        :ticket,\n        title:         'some title',\n        group:         ticket_group,\n        customer_id:   customer_user.id,\n        updated_by_id: agent_user.id,\n        created_by_id: agent_user.id,\n      )\n      article = create(\n        :ticket_article,\n        type:         Ticket::Article::Type.lookup(name: 'note'),\n        sender:       Ticket::Article::Sender.lookup(name: 'Customer'),\n        body:         '<b>test</b> <img src=\"cid:15.274327094.140938@zammad.example.com\"/>',\n        content_type: 'text/plain',\n        ticket_id:    ticket.id,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_image',\n        filename:      'some_file1.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_image',\n        filename:      'some_file2.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938.2@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_pdf',\n        filename:      'Rechnung_RE-2018-200.pdf',\n        preferences:   {\n          'Content-Type'        => 'application/octet-stream; name=\"Rechnung_RE-2018-200.pdf\"',\n          'Mime-Type'           => 'application/octet-stream',\n          'Content-ID'          => '8AB0BEC88984EE4EBEF643C79C8E0346@zammad.example.com',\n          'Content-Description' => 'Rechnung_RE-2018-200.pdf',\n          'Content-Disposition' => 'attachment',\n        },\n        created_by_id: 1,\n      )\n\n      authenticated_as(agent_user)\n      get \"/api/v1/ticket_split?ticket_id=#{ticket.id}&article_id=#{article.id}&form_id=new_form_id123\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['TicketArticle'][article.id.to_s]).to be_truthy\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(3)\n\n      get \"/api/v1/ticket_split?ticket_id=#{ticket.id}&article_id=#{article.id}&form_id=new_form_id123\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['TicketArticle'][article.id.to_s]).to be_truthy\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(0)\n\n    end\n\n    it 'does ticket merge (07.01)' do\n      group_no_permission = create(:group)\n      ticket1 = create(\n        :ticket,\n        title:       'ticket merge1',\n        group:       ticket_group,\n        customer_id: customer_user.id,\n      )\n      ticket2 = create(\n        :ticket,\n        title:       'ticket merge2',\n        group:       ticket_group,\n        customer_id: customer_user.id,\n      )\n      ticket3 = create(\n        :ticket,\n        title:       'ticket merge2',\n        group:       group_no_permission,\n        customer_id: customer_user.id,\n      )\n\n      authenticated_as(agent_user)\n      get \"/api/v1/ticket_merge/#{ticket2.id}/#{ticket1.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['result']).to eq('failed')\n      expect(json_response['message']).to eq('No such master ticket number!')\n\n      get \"/api/v1/ticket_merge/#{ticket3.id}/#{ticket1.number}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n      expect(json_response['error_human']).to eq('Not authorized')\n\n      get \"/api/v1/ticket_merge/#{ticket1.id}/#{ticket3.number}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n      expect(json_response['error_human']).to eq('Not authorized')\n\n      get \"/api/v1/ticket_merge/#{ticket1.id}/#{ticket2.number}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['result']).to eq('success')\n      expect(json_response['master_ticket']['id']).to eq(ticket2.id)\n    end\n\n    it 'does ticket merge - change permission (07.02)' do\n      group_change_permission = Group.create!(\n        name:          'GroupWithChangePermission',\n        active:        true,\n        updated_by_id: 1,\n        created_by_id: 1,\n      )\n      ticket1 = create(\n        :ticket,\n        title:       'ticket merge1',\n        group:       group_change_permission,\n        customer_id: customer_user.id,\n      )\n      ticket2 = create(\n        :ticket,\n        title:       'ticket merge2',\n        group:       group_change_permission,\n        customer_id: customer_user.id,\n      )\n\n      agent_user.group_names_access_map = { group_change_permission.name => %w[read change] }\n\n      authenticated_as(agent_user)\n      get \"/api/v1/ticket_merge/#{ticket1.id}/#{ticket2.number}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['result']).to eq('success')\n      expect(json_response['master_ticket']['id']).to eq(ticket2.id)\n    end\n\n    it 'does ticket search sorted (08.01)' do\n      title = \"ticket pagination #{rand(999_999_999)}\"\n\n      ticket1 = create(\n        :ticket,\n        title:       \"#{title} A\",\n        group:       ticket_group,\n        customer_id: customer_user.id,\n        created_at:  '2018-02-05 17:42:00',\n        updated_at:  '2018-02-05 20:42:00',\n      )\n      create(\n        :ticket_article,\n        type:      Ticket::Article::Type.lookup(name: 'note'),\n        sender:    Ticket::Article::Sender.lookup(name: 'Customer'),\n        ticket_id: ticket1.id,\n      )\n\n      ticket2 = create(\n        :ticket,\n        title:       \"#{title} B\",\n        group:       ticket_group,\n        customer_id: customer_user.id,\n        state:       Ticket::State.lookup(name: 'new'),\n        priority:    Ticket::Priority.lookup(name: '3 hoch'),\n        created_at:  '2018-02-05 19:42:00',\n        updated_at:  '2018-02-05 19:42:00',\n      )\n      create(\n        :ticket_article,\n        type:      Ticket::Article::Type.lookup(name: 'note'),\n        sender:    Ticket::Article::Sender.lookup(name: 'Customer'),\n        ticket_id: ticket2.id,\n      )\n\n      authenticated_as(admin_user)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket2.id, ticket1.id])\n\n      authenticated_as(admin_user)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: { sort_by: 'created_at', order_by: 'asc' }, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket1.id, ticket2.id])\n\n      authenticated_as(admin_user)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: { sort_by: 'title', order_by: 'asc' }, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket1.id, ticket2.id])\n\n      authenticated_as(admin_user)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: { sort_by: 'title', order_by: 'desc' }, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket2.id, ticket1.id])\n\n      authenticated_as(admin_user)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: { sort_by: %w[created_at updated_at], order_by: %w[asc asc] }, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket1.id, ticket2.id])\n\n      authenticated_as(admin_user)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: { sort_by: %w[created_at updated_at], order_by: %w[desc asc]  }, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket2.id, ticket1.id])\n    end\n\n    it 'does ticket history ' do\n      ticket1 = create(\n        :ticket,\n        title:       'some title',\n        group:       ticket_group,\n        customer_id: customer_user.id,\n      )\n      create(\n        :ticket_article,\n        type:      Ticket::Article::Type.lookup(name: 'note'),\n        sender:    Ticket::Article::Sender.lookup(name: 'Customer'),\n        ticket_id: ticket1.id,\n      )\n\n      authenticated_as(agent_user)\n      get \"/api/v1/ticket_history/#{ticket1.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['history'].class).to eq(Array)\n      expect(json_response['assets'].class).to eq(Hash)\n      expect(json_response['assets']['User'][customer_user.id.to_s]).not_to be_nil\n      expect(json_response['assets']['Ticket'][ticket1.id.to_s]).not_to be_nil\n    end\n  end\n\n  describe 'stats' do\n    let(:ticket1) { create(:ticket, customer: customer, organization: organization, group: ticket_group) }\n    let(:ticket2) { create(:ticket, customer: customer, organization: organization, group: ticket_group) }\n    let(:ticket3) { create(:ticket, customer: customer, organization: organization, group: ticket_group) }\n    let(:customer) { create(:customer_user, organization: organization) }\n    let(:organization) { create(:organization, shared: false) }\n\n    before do\n      authenticated_as(admin_user)\n\n      ticket1\n      travel 2.minutes\n      ticket2\n      travel 2.minutes\n      ticket3\n      travel 2.minutes\n      ticket2.touch\n    end\n\n    # https://github.com/zammad/zammad/issues/2296\n    it 'orders tickets by created_at desc (#2296)' do\n      get '/api/v1/ticket_stats', params: { organization_id: organization.id, user_id: customer.id }, as: :json\n\n      expect(response).to have_http_status(:ok)\n      expect(json_response)\n        .to be_a_kind_of(Hash)\n        .and include('user' => hash_including('open_ids' => [ticket3.id, ticket2.id, ticket1.id]))\n        .and include('organization' => hash_including('open_ids' => [ticket3.id, ticket2.id, ticket1.id]))\n    end\n\n  end\n\n  describe '/api/v1/tickets' do\n    subject(:ticket) { create(:ticket, state_name: 'closed') }\n\n    let(:admin) { create(:admin_user, groups: [ticket.group]) }\n    let(:agent) { create(:agent_user, groups: [ticket.group]) }\n    let(:customer) { ticket.customer }\n\n    describe 'reopening a ticket' do\n      shared_examples 'successfully reopen a ticket' do\n        it 'succeeds' do\n          put \"/api/v1/tickets/#{ticket.id}\",\n              params: { state_id: Ticket::State.find_by(name: 'open').id },\n              as:     :json\n\n          expect(response).to have_http_status(:ok)\n          expect(json_response).to include('state_id' => Ticket::State.find_by(name: 'open').id)\n        end\n      end\n\n      shared_examples 'fail to reopen a ticket' do\n        it 'fails' do\n          put \"/api/v1/tickets/#{ticket.id}\",\n              params: { state_id: Ticket::State.find_by(name: 'open').id },\n              as:     :json\n\n          expect(response).to have_http_status(:unprocessable_entity)\n          expect(json_response).to include('error' => 'Cannot follow-up on a closed ticket. Please create a new ticket.')\n        end\n      end\n\n      context 'when ticket.group.follow_up_possible = \"yes\"' do\n        before { ticket.group.update(follow_up_possible: 'yes') }\n\n        context 'as admin', authenticated_as: -> { admin } do\n          include_examples 'successfully reopen a ticket'\n        end\n\n        context 'as agent', authenticated_as: -> { agent } do\n          include_examples 'successfully reopen a ticket'\n        end\n\n        context 'as customer', authenticated_as: -> { customer } do\n          include_examples 'successfully reopen a ticket'\n        end\n      end\n\n      context 'when ticket.group.follow_up_possible = \"new_ticket\"' do\n        before { ticket.group.update(follow_up_possible: 'new_ticket') }\n\n        context 'as admin', authenticated_as: -> { admin } do\n          include_examples 'successfully reopen a ticket'\n        end\n\n        context 'as agent', authenticated_as: -> { agent } do\n          include_examples 'successfully reopen a ticket'\n        end\n\n        context 'as customer', authenticated_as: -> { customer } do\n          include_examples 'fail to reopen a ticket'\n        end\n      end\n    end\n  end\n\n  describe 'GET /api/v1/ticket_customer' do\n\n    subject(:ticket) { create(:ticket, customer: customer_authorized) }\n\n    let(:organization_authorized) { create(:organization) }\n    let(:customer_authorized) { create(:customer_user, organization: organization_authorized) }\n\n    let(:organization_unauthorized) { create(:organization) }\n    let(:customer_unauthorized) { create(:customer_user, organization: organization_unauthorized) }\n\n    let(:agent) { create(:agent_user, groups: [ticket.group]) }\n\n    describe 'listing information' do\n\n      before do\n        ticket\n      end\n\n      shared_examples 'has access' do\n        it 'succeeds' do\n          get '/api/v1/ticket_customer',\n              params: { customer_id: customer_authorized.id },\n              as:     :json\n\n          expect(json_response['ticket_ids_open']).to include(ticket.id)\n          expect(json_response['ticket_ids_closed']).to be_blank\n        end\n      end\n\n      shared_examples 'has no access' do\n        it 'fails' do\n          get '/api/v1/ticket_customer',\n              params: { customer_id: customer_authorized.id },\n              as:     :json\n\n          expect(json_response['ticket_ids_open']).to be_blank\n          expect(json_response['ticket_ids_closed']).to be_blank\n          expect(json_response['assets']).to be_blank\n        end\n      end\n\n      context 'as agent', authenticated_as: -> { agent } do\n        include_examples 'has access'\n      end\n\n      context 'as authorized customer', authenticated_as: -> { customer_authorized } do\n        include_examples 'has access'\n      end\n\n      context 'as unauthorized customer', authenticated_as: -> { customer_unauthorized } do\n        include_examples 'has no access'\n      end\n    end\n  end\nend\n"], "fixing_code": ["# Copyright (C) 2012-2016 Zammad Foundation, http://zammad-foundation.org/\n\nclass TicketsController < ApplicationController\n  include CreatesTicketArticles\n  include ClonesTicketArticleAttachments\n  include ChecksUserAttributesByCurrentUserPermission\n  include TicketStats\n\n  prepend_before_action -> { authorize! }, only: %i[create selector import_example import_start ticket_customer ticket_history ticket_related ticket_recent ticket_merge ticket_split]\n  prepend_before_action :authentication_check\n\n  # GET /api/v1/tickets\n  def index\n    offset = 0\n    per_page = 100\n\n    if params[:page] && params[:per_page]\n      offset = (params[:page].to_i - 1) * params[:per_page].to_i\n      per_page = params[:per_page].to_i\n    end\n\n    if per_page > 100\n      per_page = 100\n    end\n\n    access_condition = Ticket.access_condition(current_user, 'read')\n    tickets = Ticket.where(access_condition).order(id: :asc).offset(offset).limit(per_page)\n\n    if response_expand?\n      list = []\n      tickets.each do |ticket|\n        list.push ticket.attributes_with_association_names\n      end\n      render json: list, status: :ok\n      return\n    end\n\n    if response_full?\n      assets = {}\n      item_ids = []\n      tickets.each do |item|\n        item_ids.push item.id\n        assets = item.assets(assets)\n      end\n      render json: {\n        record_ids: item_ids,\n        assets:     assets,\n      }, status: :ok\n      return\n    end\n\n    render json: tickets\n  end\n\n  # GET /api/v1/tickets/1\n  def show\n    ticket = Ticket.find(params[:id])\n    authorize!(ticket)\n\n    if response_expand?\n      result = ticket.attributes_with_association_names\n      render json: result, status: :ok\n      return\n    end\n\n    if response_full?\n      full = Ticket.full(params[:id])\n      render json: full\n      return\n    end\n\n    if response_all?\n      render json: ticket_all(ticket)\n      return\n    end\n\n    render json: ticket\n  end\n\n  # POST /api/v1/tickets\n  def create\n    customer = {}\n    if params[:customer].class == ActionController::Parameters\n      customer = params[:customer]\n      params.delete(:customer)\n    end\n\n    clean_params = Ticket.association_name_to_id_convert(params)\n\n    # overwrite params\n    if !current_user.permissions?('ticket.agent')\n      %i[owner owner_id customer customer_id organization organization_id preferences].each do |key|\n        clean_params.delete(key)\n      end\n      clean_params[:customer_id] = current_user.id\n    end\n\n    # try to create customer if needed\n    if clean_params[:customer_id].present? && clean_params[:customer_id] =~ /^guess:(.+?)$/\n      email_address = $1\n      email_address_validation = EmailAddressValidation.new(email_address)\n      if !email_address_validation.valid_format?\n        render json: { error: \"Invalid email '#{email_address}' of customer\" }, status: :unprocessable_entity\n        return\n      end\n      local_customer = User.find_by(email: email_address.downcase)\n      if !local_customer\n        role_ids = Role.signup_role_ids\n        local_customer = User.create(\n          firstname: '',\n          lastname:  '',\n          email:     email_address,\n          password:  '',\n          active:    true,\n          role_ids:  role_ids,\n        )\n      end\n      clean_params[:customer_id] = local_customer.id\n    end\n\n    # try to create customer if needed\n    if clean_params[:customer_id].blank? && customer.present?\n      check_attributes_by_current_user_permission(customer)\n      clean_customer = User.association_name_to_id_convert(customer)\n      local_customer = nil\n      if !local_customer && clean_customer[:id].present?\n        local_customer = User.find_by(id: clean_customer[:id])\n      end\n      if !local_customer && clean_customer[:email].present?\n        local_customer = User.find_by(email: clean_customer[:email].downcase)\n      end\n      if !local_customer && clean_customer[:login].present?\n        local_customer = User.find_by(login: clean_customer[:login].downcase)\n      end\n      if !local_customer\n        role_ids = Role.signup_role_ids\n        local_customer = User.new(clean_customer)\n        local_customer.role_ids = role_ids\n        local_customer.save!\n      end\n      clean_params[:customer_id] = local_customer.id\n    end\n\n    clean_params = Ticket.param_cleanup(clean_params, true)\n    ticket = Ticket.new(clean_params)\n\n    # check if article is given\n    if !params[:article]\n      render json: { error: 'article hash is missing' }, status: :unprocessable_entity\n      return\n    end\n\n    # create ticket\n    ticket.save!\n    ticket.with_lock do\n\n      # create tags if given\n      if params[:tags].present?\n        tags = params[:tags].split(/,/)\n        tags.each do |tag|\n          ticket.tag_add(tag)\n        end\n      end\n\n      # create article if given\n      if params[:article]\n        article_create(ticket, params[:article])\n      end\n    end\n    # create links (e. g. in case of ticket split)\n    # links: {\n    #   Ticket: {\n    #     parent: [ticket_id1, ticket_id2, ...]\n    #     normal: [ticket_id1, ticket_id2, ...]\n    #     child: [ticket_id1, ticket_id2, ...]\n    #   },\n    # }\n    if params[:links].present?\n      link = params[:links].permit!.to_h\n      raise Exceptions::UnprocessableEntity, 'Invalid link structure' if !link.is_a? Hash\n\n      link.each do |target_object, link_types_with_object_ids|\n        raise Exceptions::UnprocessableEntity, 'Invalid link structure (Object)' if !link_types_with_object_ids.is_a? Hash\n\n        link_types_with_object_ids.each do |link_type, object_ids|\n          raise Exceptions::UnprocessableEntity, 'Invalid link structure (Object->LinkType)' if !object_ids.is_a? Array\n\n          object_ids.each do |local_object_id|\n            link = Link.add(\n              link_type:                link_type,\n              link_object_target:       target_object,\n              link_object_target_value: local_object_id,\n              link_object_source:       'Ticket',\n              link_object_source_value: ticket.id,\n            )\n          end\n        end\n      end\n    end\n\n    if response_expand?\n      result = ticket.reload.attributes_with_association_names\n      render json: result, status: :created\n      return\n    end\n\n    if response_full?\n      full = Ticket.full(ticket.id)\n      render json: full, status: :created\n      return\n    end\n\n    if response_all?\n      render json: ticket_all(ticket.reload), status: :created\n      return\n    end\n\n    render json: ticket.reload.attributes_with_association_ids, status: :created\n  end\n\n  # PUT /api/v1/tickets/1\n  def update\n    ticket = Ticket.find(params[:id])\n    authorize!(ticket, :follow_up?)\n    authorize!(ticket)\n\n    clean_params = Ticket.association_name_to_id_convert(params)\n    clean_params = Ticket.param_cleanup(clean_params, true)\n\n    # only apply preferences changes (keep not updated keys/values)\n    clean_params = ticket.param_preferences_merge(clean_params)\n\n    # disable changes on ticket number\n    clean_params.delete('number')\n\n    # overwrite params\n    if !current_user.permissions?('ticket.agent')\n      %i[owner owner_id customer customer_id organization organization_id preferences].each do |key|\n        clean_params.delete(key)\n      end\n    end\n\n    ticket.with_lock do\n      ticket.update!(clean_params)\n      if params[:article]\n        article_create(ticket, params[:article])\n      end\n    end\n\n    if response_expand?\n      result = ticket.reload.attributes_with_association_names\n      render json: result, status: :ok\n      return\n    end\n\n    if response_full?\n      full = Ticket.full(params[:id])\n      render json: full, status: :ok\n      return\n    end\n\n    if response_all?\n      render json: ticket_all(ticket.reload), status: :ok\n      return\n    end\n\n    render json: ticket.reload.attributes_with_association_ids, status: :ok\n  end\n\n  # DELETE /api/v1/tickets/1\n  def destroy\n    ticket = Ticket.find(params[:id])\n    authorize!(ticket)\n\n    ticket.destroy!\n\n    head :ok\n  end\n\n  # GET /api/v1/ticket_customer\n  # GET /api/v1/tickets_customer\n  def ticket_customer\n\n    # return result\n    result = Ticket::ScreenOptions.list_by_customer(\n      current_user: current_user,\n      customer_id:  params[:customer_id],\n      limit:        15,\n    )\n    render json: result\n  end\n\n  # GET /api/v1/ticket_history/1\n  def ticket_history\n\n    # get ticket data\n    ticket = Ticket.find(params[:id])\n    authorize!(ticket, :show?)\n\n    # get history of ticket\n    render json: ticket.history_get(true)\n  end\n\n  # GET /api/v1/ticket_related/1\n  def ticket_related\n\n    ticket = Ticket.find(params[:ticket_id])\n    assets = ticket.assets({})\n\n    # open tickets by customer\n    access_condition = Ticket.access_condition(current_user, 'read')\n\n    ticket_lists = Ticket\n                   .where(\n                     customer_id: ticket.customer_id,\n                     state_id:    Ticket::State.by_category(:open).pluck(:id),\n                   )\n                   .where(access_condition)\n                   .where('id != ?', [ ticket.id ])\n                   .order(created_at: :desc)\n                   .limit(6)\n\n    # if we do not have open related tickets, search for any tickets\n    if ticket_lists.blank?\n      ticket_lists = Ticket\n                     .where(\n                       customer_id: ticket.customer_id,\n                     ).where.not(\n                       state_id: Ticket::State.by_category(:merged).pluck(:id),\n                     )\n                     .where(access_condition)\n                     .where('id != ?', [ ticket.id ])\n                     .order(created_at: :desc)\n                     .limit(6)\n    end\n\n    # get related assets\n    ticket_ids_by_customer = []\n    ticket_lists.each do |ticket_list|\n      ticket_ids_by_customer.push ticket_list.id\n      assets = ticket_list.assets(assets)\n    end\n\n    ticket_ids_recent_viewed = []\n    recent_views = RecentView.list(current_user, 8, 'Ticket')\n    recent_views.each do |recent_view|\n      next if recent_view.object.name != 'Ticket'\n      next if recent_view.o_id == ticket.id\n\n      ticket_ids_recent_viewed.push recent_view.o_id\n      recent_view_ticket = Ticket.find(recent_view.o_id)\n      assets = recent_view_ticket.assets(assets)\n    end\n\n    # return result\n    render json: {\n      assets:                   assets,\n      ticket_ids_by_customer:   ticket_ids_by_customer,\n      ticket_ids_recent_viewed: ticket_ids_recent_viewed,\n    }\n  end\n\n  # GET /api/v1/ticket_recent\n  def ticket_recent\n    ticket_ids = RecentView.list(current_user, 10, Ticket.name).map(&:o_id)\n    tickets    = ticket_ids.map { |elem| Ticket.lookup(id: elem) }\n    assets     = ApplicationModel::CanAssets.reduce(tickets)\n\n    render json: {\n      assets:                   assets,\n      ticket_ids_recent_viewed: ticket_ids\n    }\n  end\n\n  # GET /api/v1/ticket_merge/1/1\n  def ticket_merge\n\n    # check master ticket\n    ticket_master = Ticket.find_by(number: params[:master_ticket_number])\n    if !ticket_master\n      render json: {\n        result:  'failed',\n        message: 'No such master ticket number!',\n      }\n      return\n    end\n    authorize!(ticket_master, :update?)\n\n    # check slave ticket\n    ticket_slave = Ticket.find_by(id: params[:slave_ticket_id])\n    if !ticket_slave\n      render json: {\n        result:  'failed',\n        message: 'No such slave ticket!',\n      }\n      return\n    end\n    authorize!(ticket_slave, :update?)\n\n    # merge ticket\n    ticket_slave.merge_to(\n      ticket_id:     ticket_master.id,\n      created_by_id: current_user.id,\n    )\n\n    # return result\n    render json: {\n      result:        'success',\n      master_ticket: ticket_master.attributes,\n      slave_ticket:  ticket_slave.attributes,\n    }\n  end\n\n  # GET /api/v1/ticket_split\n  def ticket_split\n    ticket = Ticket.find(params[:ticket_id])\n    authorize!(ticket, :show?)\n    assets = ticket.assets({})\n\n    article = Ticket::Article.find(params[:article_id])\n    authorize!(article.ticket, :show?)\n    assets = article.assets(assets)\n\n    render json: {\n      assets:      assets,\n      attachments: article_attachments_clone(article),\n    }\n  end\n\n  # GET /api/v1/ticket_create\n  def ticket_create\n\n    # get attributes to update\n    attributes_to_change = Ticket::ScreenOptions.attributes_to_change(\n      current_user: current_user,\n    )\n    render json: attributes_to_change\n  end\n\n  # GET /api/v1/tickets/search\n  def search\n\n    # permit nested conditions\n    if params[:condition]\n      params.require(:condition).permit!\n    end\n\n    per_page = params[:per_page] || params[:limit] || 50\n    per_page = per_page.to_i\n    if per_page > 200\n      per_page = 200\n    end\n    page = params[:page] || 1\n    page = page.to_i\n    offset = (page - 1) * per_page\n\n    query = params[:query]\n    if query.respond_to?(:permit!)\n      query = query.permit!.to_h\n    end\n\n    # build result list\n    tickets = Ticket.search(\n      query:        query,\n      condition:    params[:condition].to_h,\n      limit:        per_page,\n      offset:       offset,\n      order_by:     params[:order_by],\n      sort_by:      params[:sort_by],\n      current_user: current_user,\n    )\n\n    if response_expand?\n      list = []\n      tickets.each do |ticket|\n        list.push ticket.attributes_with_association_names\n      end\n      render json: list, status: :ok\n      return\n    end\n\n    assets = {}\n    ticket_result = []\n    tickets.each do |ticket|\n      ticket_result.push ticket.id\n      assets = ticket.assets(assets)\n    end\n\n    # return result\n    render json: {\n      tickets:       ticket_result,\n      tickets_count: tickets.count,\n      assets:        assets,\n    }\n  end\n\n  # GET /api/v1/tickets/selector\n  def selector\n    ticket_count, tickets = Ticket.selectors(params[:condition], limit: 6, execution_time: true)\n\n    assets = {}\n    ticket_ids = []\n    tickets&.each do |ticket|\n      ticket_ids.push ticket.id\n      assets = ticket.assets(assets)\n    end\n\n    # return result\n    render json: {\n      ticket_ids:   ticket_ids,\n      ticket_count: ticket_count || 0,\n      assets:       assets,\n    }\n  end\n\n  # GET /api/v1/ticket_stats\n  def stats\n\n    if !params[:user_id] && !params[:organization_id]\n      raise 'Need user_id or organization_id as param'\n    end\n\n    # lookup open user tickets\n    limit            = 100\n    assets           = {}\n    access_condition = Ticket.access_condition(current_user, 'read')\n\n    user_tickets = {}\n    if params[:user_id]\n      user = User.lookup(id: params[:user_id])\n      if !user\n        raise \"No such user with id #{params[:user_id]}\"\n      end\n\n      conditions = {\n        closed_ids: {\n          'ticket.state_id'    => {\n            operator: 'is',\n            value:    Ticket::State.by_category(:closed).pluck(:id),\n          },\n          'ticket.customer_id' => {\n            operator: 'is',\n            value:    user.id,\n          },\n        },\n        open_ids:   {\n          'ticket.state_id'    => {\n            operator: 'is',\n            value:    Ticket::State.by_category(:open).pluck(:id),\n          },\n          'ticket.customer_id' => {\n            operator: 'is',\n            value:    user.id,\n          },\n        },\n      }\n      conditions.each do |key, local_condition|\n        user_tickets[key] = ticket_ids_and_assets(local_condition, current_user, limit, assets)\n      end\n\n      # generate stats by user\n      condition = {\n        'tickets.customer_id' => user.id,\n      }\n      user_tickets[:volume_by_year] = ticket_stats_last_year(condition, access_condition)\n\n    end\n\n    # lookup open org tickets\n    org_tickets = {}\n    if params[:organization_id].present?\n      organization = Organization.lookup(id: params[:organization_id])\n      if !organization\n        raise \"No such organization with id #{params[:organization_id]}\"\n      end\n\n      conditions = {\n        closed_ids: {\n          'ticket.state_id'        => {\n            operator: 'is',\n            value:    Ticket::State.by_category(:closed).pluck(:id),\n          },\n          'ticket.organization_id' => {\n            operator: 'is',\n            value:    organization.id,\n          },\n        },\n        open_ids:   {\n          'ticket.state_id'        => {\n            operator: 'is',\n            value:    Ticket::State.by_category(:open).pluck(:id),\n          },\n          'ticket.organization_id' => {\n            operator: 'is',\n            value:    organization.id,\n          },\n        },\n      }\n      conditions.each do |key, local_condition|\n        org_tickets[key] = ticket_ids_and_assets(local_condition, current_user, limit, assets)\n      end\n\n      # generate stats by org\n      condition = {\n        'tickets.organization_id' => organization.id,\n      }\n      org_tickets[:volume_by_year] = ticket_stats_last_year(condition, access_condition)\n    end\n\n    # return result\n    render json: {\n      user:         user_tickets,\n      organization: org_tickets,\n      assets:       assets,\n    }\n  end\n\n  # @path    [GET] /tickets/import_example\n  #\n  # @summary          Download of example CSV file.\n  # @notes            The requester have 'admin' permissions to be able to download it.\n  # @example          curl -u 'me@example.com:test' http://localhost:3000/api/v1/tickets/import_example\n  #\n  # @response_message 200 File download.\n  # @response_message 401 Invalid session.\n  def import_example\n    csv_string = Ticket.csv_example(\n      col_sep: ',',\n    )\n    send_data(\n      csv_string,\n      filename:    'example.csv',\n      type:        'text/csv',\n      disposition: 'attachment'\n    )\n\n  end\n\n  # @path    [POST] /tickets/import\n  #\n  # @summary          Starts import.\n  # @notes            The requester have 'admin' permissions to be create a new import.\n  # @example          curl -u 'me@example.com:test' -F 'file=@/path/to/file/tickets.csv' 'https://your.zammad/api/v1/tickets/import?try=true'\n  # @example          curl -u 'me@example.com:test' -F 'file=@/path/to/file/tickets.csv' 'https://your.zammad/api/v1/tickets/import'\n  #\n  # @response_message 201 Import started.\n  # @response_message 401 Invalid session.\n  def import_start\n    if Setting.get('import_mode') != true\n      raise 'Only can import tickets if system is in import mode.'\n    end\n\n    string = params[:data]\n    if string.blank? && params[:file].present?\n      string = params[:file].read.force_encoding('utf-8')\n    end\n    raise Exceptions::UnprocessableEntity, 'No source data submitted!' if string.blank?\n\n    result = Ticket.csv_import(\n      string:       string,\n      parse_params: {\n        col_sep: params[:col_sep] || ',',\n      },\n      try:          params[:try],\n    )\n    render json: result, status: :ok\n  end\n\n  private\n\n  def ticket_all(ticket)\n\n    # get attributes to update\n    attributes_to_change = Ticket::ScreenOptions.attributes_to_change(\n      current_user: current_user,\n      ticket:       ticket\n    )\n\n    # get related users\n    assets = attributes_to_change[:assets]\n    assets = ticket.assets(assets)\n\n    # get related users\n    article_ids = []\n    ticket.articles.each do |article|\n      next if !authorized?(article, :show?)\n\n      article_ids.push article.id\n      assets = article.assets(assets)\n    end\n\n    # get links\n    links = Link.list(\n      link_object:       'Ticket',\n      link_object_value: ticket.id,\n    )\n\n    assets = Link.reduce_assets(assets, links)\n\n    # get tags\n    tags = ticket.tag_list\n\n    # return result\n    {\n      ticket_id:          ticket.id,\n      ticket_article_ids: article_ids,\n      assets:             assets,\n      links:              links,\n      tags:               tags,\n      form_meta:          attributes_to_change[:form_meta],\n    }\n  end\n\nend\n", "class Controllers::TicketsControllerPolicy < Controllers::ApplicationControllerPolicy\n  permit! %i[import_example import_start], to: 'admin'\n  permit! :selector, to: 'admin.*'\n  permit! %i[ticket_customer ticket_history ticket_related ticket_recent ticket_merge ticket_split], to: 'ticket.agent'\n  permit! :create, to: ['ticket.agent', 'ticket.customer']\nend\n", "require 'rails_helper'\n\nRSpec.describe 'Ticket', type: :request do\n\n  let!(:ticket_group) do\n    create(:group, email_address: create(:email_address) )\n  end\n  let(:admin_user) do\n    create(:admin_user, groups: Group.all, firstname: 'Tickets', lastname: 'Admin')\n  end\n  let!(:agent_user) do\n    create(:agent_user, groups: Group.all, firstname: 'Tickets', lastname: 'Agent')\n  end\n  let!(:customer_user) do\n    create(\n      :customer_user,\n      login:     'tickets-customer1@example.com',\n      firstname: 'Tickets',\n      lastname:  'Customer1',\n      email:     'tickets-customer1@example.com',\n    )\n  end\n\n  describe 'request handling' do\n\n    it 'does ticket create with agent - missing group (01.01)' do\n      params = {\n        title:   'a new ticket #1',\n        article: {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n          sender:       'Customer',\n          type:         'note',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error_human']).to eq('Group can\\'t be blank')\n    end\n\n    it 'does ticket create with agent - wrong group (01.02)' do\n      params = {\n        title:   'a new ticket #2',\n        group:   'not_existing',\n        article: {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n          sender:       'Customer',\n          type:         'note',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('No lookup value found for \\'group\\': \"not_existing\"')\n    end\n\n    it 'does ticket create with agent - missing article.body (01.03)' do\n      params = {\n        title:       'a new ticket #3',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        state:       'new',\n        customer_id: customer_user.id,\n        article:     {},\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Need at least article: { body: \"some text\" }')\n    end\n\n    it 'does ticket create with agent - minimal article (01.03)' do\n      params = {\n        title:       'a new ticket #3',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        state:       'new',\n        customer_id: customer_user.id,\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #3')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n    end\n\n    it 'does ticket create with agent - minimal article and customer.email (01.04)' do\n      params = {\n        title:    'a new ticket #3',\n        group:    ticket_group.name,\n        priority: '2 normal',\n        state:    'new',\n        customer: customer_user.email,\n        article:  {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #3')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n    end\n\n    it 'does ticket create with agent - wrong owner_id - 0 (01.05)' do\n      params = {\n        title:       'a new ticket #4',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        owner_id:    0,\n        state:       'new',\n        customer_id: customer_user.id,\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Invalid value for param \\'owner_id\\': 0')\n    end\n\n    it 'does ticket create with agent - wrong owner_id - \"\" (01.06)' do\n      params = {\n        title:       'a new ticket #5',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        owner_id:    '',\n        state:       'new',\n        customer_id: customer_user.id,\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #5')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n    end\n\n    it 'does ticket create with agent - wrong owner_id - 99999 (01.07)' do\n      params = {\n        title:       'a new ticket #6',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        owner_id:    99_999,\n        state:       'new',\n        customer_id: customer_user.id,\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Invalid value for param \\'owner_id\\': 99999')\n    end\n\n    it 'does ticket create with agent - wrong owner_id - nil (01.08)' do\n      params = {\n        title:       'a new ticket #7',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        owner_id:    nil,\n        state:       'new',\n        customer_id: customer_user.id,\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #7')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n    end\n\n    it 'does ticket create with agent - minimal article with guess customer (01.09)' do\n      params = {\n        title:       'a new ticket #9',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        state:       'new',\n        customer_id: 'guess:some_new_customer@example.com',\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #9')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n    end\n\n    it 'does ticket create with agent - minimal article with guess customer (01.10)' do\n      params = {\n        title:       'a new ticket #10',\n        group:       ticket_group.name,\n        customer_id: 'guess:some_new_customer@example.com',\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #10')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash (01.11)' do\n      params = {\n        title:    'a new ticket #11',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #11')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (01.11)' do\n      params = {\n        title:    'a new ticket #11.1',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          body:      'some test 123',\n          origin_by: 'some_new_customer@example.com',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #11.1')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(agent_user.id)\n      expect(article.created_by_id).to eq(agent_user.id)\n      expect(article.origin_by_id).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('some firstname some lastname')\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (01.11)' do\n      params = {\n        title:    'a new ticket #11.2',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          sender:    'Customer',\n          body:      'some test 123',\n          origin_by: 'some_new_customer@example.com',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #11.2')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(agent_user.id)\n      expect(article.created_by_id).to eq(agent_user.id)\n      expect(article.origin_by_id).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('some firstname some lastname')\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (01.11)' do\n      params = {\n        title:    'a new ticket #11.3',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          sender:    'Agent',\n          from:      'somebody',\n          body:      'some test 123',\n          origin_by: 'some_new_customer@example.com',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #11.3')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(agent_user.id)\n      expect(article.created_by_id).to eq(agent_user.id)\n      expect(article.origin_by_id).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('some firstname some lastname')\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (01.11)' do\n      params = {\n        title:    'a new ticket #11.4',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          sender:    'Customer',\n          body:      'some test 123',\n          origin_by: customer_user.login,\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #11.4')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(agent_user.id)\n      expect(article.created_by_id).to eq(agent_user.id)\n      expect(article.origin_by_id).to eq(customer_user.id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('Tickets Customer1')\n    end\n\n    it 'does ticket create with agent - minimal article with missing body - with customer.id (01.12)' do\n      params = {\n        title:       'a new ticket #12',\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        article:     {\n          subject: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Need at least article: { body: \"some text\" }')\n    end\n\n    it 'does ticket create with agent - minimal article and attachment with customer (01.13)' do\n      params = {\n        title:       'a new ticket #13',\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            'filename'  => 'some_file.txt',\n            'data'      => 'dGVzdCAxMjM=',\n            'mime-type' => 'text/plain',\n          ],\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #13')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(1)\n      file = ticket.articles.first.attachments.first\n      expect(file.content).to eq('test 123')\n      expect(file.filename).to eq('some_file.txt')\n      expect(file.preferences['Mime-Type']).to eq('text/plain')\n      expect(file.preferences['Content-ID']).to be_falsey\n    end\n\n    it 'does ticket create with agent - minimal article and attachment with customer (01.14)' do\n      params = {\n        title:       'a new ticket #14',\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            {\n              'filename'  => 'some_file1.txt',\n              'data'      => 'dGVzdCAxMjM=',\n              'mime-type' => 'text/plain',\n            },\n            {\n              'filename'  => 'some_file2.txt',\n              'data'      => 'w6TDtsO8w58=',\n              'mime-type' => 'text/plain',\n            },\n          ],\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #14')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(2)\n      file = ticket.articles.first.attachments.first\n      expect(file.content).to eq('test 123')\n      expect(file.filename).to eq('some_file1.txt')\n      expect(file.preferences['Mime-Type']).to eq('text/plain')\n      expect(file.preferences['Content-ID']).to be_falsey\n    end\n\n    it 'does ticket create with agent - minimal article and simple invalid base64 attachment with customer (01.15)' do\n      params = {\n        title:       'a new ticket #15',\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            'filename'  => 'some_file.txt',\n            'data'      => 'ABC_INVALID_BASE64',\n            'mime-type' => 'text/plain',\n          ],\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Invalid base64 for attachment with index \\'0\\'')\n    end\n\n    it 'does ticket create with agent - minimal article and large invalid base64 attachment with customer (01.15a)' do\n      params = {\n        title:       'a new ticket #15a',\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            'filename'  => 'some_file.txt',\n            'data'      => \"LARGE_INVALID_BASE64_#{'#' * 20_000_000}\",\n            'mime-type' => 'text/plain',\n          ],\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Invalid base64 for attachment with index \\'0\\'')\n    end\n\n    it 'does ticket create with agent - minimal article and valid multiline base64 with linebreaks attachment with customer (01.15b)' do\n      params = {\n        title:       'a new ticket #15b',\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            'filename'  => 'some_file.txt',\n            'data'      => Base64.encode64('a' * 1_000),\n            'mime-type' => 'text/plain',\n          ],\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response['title']).to eq('a new ticket #15b')\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(1)\n      file = ticket.articles.first.attachments.first\n      expect(file.content).to eq('a' * 1_000)\n    end\n\n    it 'does ticket create with agent - minimal article and valid multiline base64 without linebreaks attachment with customer (01.15c)' do\n      params = {\n        title:       'a new ticket #15c',\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            'filename'  => 'some_file.txt',\n            'data'      => Base64.strict_encode64('a' * 1_000),\n            'mime-type' => 'text/plain',\n          ],\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response['title']).to eq('a new ticket #15c')\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(1)\n      file = ticket.articles.first.attachments.first\n      expect(file.content).to eq('a' * 1_000)\n    end\n\n    it 'does ticket create with agent - minimal article and attachment invalid base64 with customer (01.16)' do\n      params = {\n        title:       'a new ticket #16',\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            'filename' => 'some_file.txt',\n            'data'     => 'dGVzdCAxMjM=',\n          ],\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Attachment needs \\'mime-type\\' param for attachment with index \\'0\\'')\n    end\n\n    it 'does ticket create with agent - minimal article and inline attachments with customer (01.17)' do\n      params = {\n        title:       'a new ticket #17',\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        article:     {\n          content_type: 'text/html',\n          subject:      'some test 123',\n          body:         'some test 123 <img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA\n  AAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO\n  9TXL0Y4OHwAAAABJRU5ErkJggg==\" alt=\"Red dot\" /> <img src=\"data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAJAAD/4QMtaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjMtYzAxMSA2Ni4xNDU2NjEsIDIwMTIvMDIvMDYtMTQ6NTY6MjcgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzYgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QzJCOTE2NzlGQUEwMTFFNjg0M0NGQjU0OUU4MTFEOEIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QzJCOTE2N0FGQUEwMTFFNjg0M0NGQjU0OUU4MTFEOEIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpDMkI5MTY3N0ZBQTAxMUU2ODQzQ0ZCNTQ5RTgxMUQ4QiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpDMkI5MTY3OEZBQTAxMUU2ODQzQ0ZCNTQ5RTgxMUQ4QiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEABQRERoTGioZGSo1KCEoNTEpKCgpMUE4ODg4OEFEREREREREREREREREREREREREREREREREREREREREREREREQBFhoaIh0iKRoaKTkpIik5RDktLTlEREREOERERERERERERERERERERERERERERERERERERERERERERERERERERP/AABEIABAADAMBIgACEQEDEQH/xABbAAEBAAAAAAAAAAAAAAAAAAAEBQEBAQAAAAAAAAAAAAAAAAAABAUQAAEEAgMAAAAAAAAAAAAAAAABAhIDESIxBAURAAICAwAAAAAAAAAAAAAAAAESABNRoQP/2gAMAwEAAhEDEQA/AJDq1rfF3Imeg/1+lFy2oR564DKWWWbweV+Buf/Z\">',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #17')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(2)\n      file = ticket.articles.first.attachments[0]\n      expect(Digest::MD5.hexdigest(file.content)).to eq('d3c1e09bdefb92b6a06b791a24ca9599')\n      expect(file.filename).to eq('image1.png')\n      expect(file.preferences['Mime-Type']).to eq('image/png')\n      expect(file.preferences['Content-ID']).to match(/#{ticket.id}\\..+?@zammad.example.com/)\n      expect(file.preferences['Content-ID']).to be_truthy\n      file = ticket.articles.first.attachments[1]\n      expect(Digest::MD5.hexdigest(file.content)).to eq('006a2ca3793b550c8fe444acdeb39252')\n      expect(file.filename).to eq('image2.jpeg')\n      expect(file.preferences['Mime-Type']).to eq('image/jpeg')\n      expect(file.preferences['Content-ID']).to match(/#{ticket.id}\\..+?@zammad.example.com/)\n      expect(file.preferences['Content-ID']).to be_truthy\n    end\n\n    it 'does ticket create with agent - minimal article and inline attachments with customer (01.18)' do\n      params = {\n        title:       'a new ticket #18',\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        article:     {\n          content_type: 'text/html',\n          subject:      'some test 123',\n          body:         'some test 123 <img src=\"data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAJAAD/4QMtaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjMtYzAxMSA2Ni4xNDU2NjEsIDIwMTIvMDIvMDYtMTQ6NTY6MjcgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzYgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QzJCOTE2NzlGQUEwMTFFNjg0M0NGQjU0OUU4MTFEOEIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QzJCOTE2N0FGQUEwMTFFNjg0M0NGQjU0OUU4MTFEOEIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpDMkI5MTY3N0ZBQTAxMUU2ODQzQ0ZCNTQ5RTgxMUQ4QiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpDMkI5MTY3OEZBQTAxMUU2ODQzQ0ZCNTQ5RTgxMUQ4QiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEABQRERoTGioZGSo1KCEoNTEpKCgpMUE4ODg4OEFEREREREREREREREREREREREREREREREREREREREREREREREQBFhoaIh0iKRoaKTkpIik5RDktLTlEREREOERERERERERERERERERERERERERERERERERERERERERERERERERERP/AABEIABAADAMBIgACEQEDEQH/xABbAAEBAAAAAAAAAAAAAAAAAAAEBQEBAQAAAAAAAAAAAAAAAAAABAUQAAEEAgMAAAAAAAAAAAAAAAABAhIDESIxBAURAAICAwAAAAAAAAAAAAAAAAESABNRoQP/2gAMAwEAAhEDEQA/AJDq1rfF3Imeg/1+lFy2oR564DKWWWbweV+Buf/Z\"\n  >',\n          attachments:  [\n            'filename'  => 'some_file.txt',\n            'data'      => 'dGVzdCAxMjM=',\n            'mime-type' => 'text/plain',\n          ],\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #18')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(2)\n      file = ticket.articles.first.attachments[0]\n      expect(Digest::MD5.hexdigest(file.content)).to eq('006a2ca3793b550c8fe444acdeb39252')\n      expect(file.filename).to eq('image1.jpeg')\n      expect(file.preferences['Mime-Type']).to eq('image/jpeg')\n      expect(file.preferences['Content-ID']).to be_truthy\n      expect(file.preferences['Content-ID']).to match(/#{ticket.id}\\..+?@zammad.example.com/)\n      file = ticket.articles.first.attachments[1]\n      expect(Digest::MD5.hexdigest(file.content)).to eq('39d0d586a701e199389d954f2d592720')\n      expect(file.filename).to eq('some_file.txt')\n      expect(file.preferences['Mime-Type']).to eq('text/plain')\n      expect(file.preferences['Content-ID']).to be_falsey\n    end\n\n    it 'does ticket create with agent (02.02)' do\n      params = {\n        title:    'a new ticket #1',\n        state:    'new',\n        priority: '2 normal',\n        group:    ticket_group.name,\n        customer: 'tickets-customer1@example.com',\n        article:  {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n        },\n        links:    {\n          Ticket: {\n            parent: [1],\n          }\n        }\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #1')\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n      links = Link.list(\n        link_object:       'Ticket',\n        link_object_value: json_response['id'],\n      )\n      expect(links[0]['link_type']).to eq('child')\n      expect(links[0]['link_object']).to eq('Ticket')\n      expect(links[0]['link_object_value']).to eq(1)\n    end\n\n    it 'does ticket with wrong ticket id (02.03)' do\n      group = create(:group)\n      ticket = create(\n        :ticket,\n        title:       'ticket with wrong ticket id',\n        group_id:    group.id,\n        customer_id: customer_user.id,\n      )\n      authenticated_as(agent_user)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n\n      params = {\n        title: 'ticket with wrong ticket id - 2',\n      }\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n\n      delete \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n    end\n\n    it 'does ticket with correct ticket id (02.04)' do\n      title = \"ticket with corret ticket id testagent#{rand(999_999_999)}\"\n      ticket = create(\n        :ticket,\n        title:       title,\n        group:       ticket_group,\n        customer_id: customer_user.id,\n        preferences: {\n          some_key1: 123,\n        },\n      )\n      authenticated_as(agent_user)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(title)\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(1)\n      expect(json_response['created_by_id']).to eq(1)\n      expect(json_response['preferences']['some_key1']).to eq(123)\n\n      params = {\n        title:       \"#{title} - 2\",\n        customer_id: agent_user.id,\n        preferences: {\n          some_key2: 'abc',\n        },\n      }\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(\"#{title} - 2\")\n      expect(json_response['customer_id']).to eq(agent_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(1)\n      expect(json_response['preferences']['some_key1']).to eq(123)\n      expect(json_response['preferences']['some_key2']).to eq('abc')\n\n      params = {\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      article_json_response = json_response\n      expect(article_json_response).to be_a_kind_of(Hash)\n      expect(article_json_response['ticket_id']).to eq(ticket.id)\n      expect(article_json_response['from']).to eq('Tickets Agent')\n      expect(article_json_response['subject']).to eq('some subject')\n      expect(article_json_response['body']).to eq('some body')\n      expect(article_json_response['content_type']).to eq('text/plain')\n      expect(article_json_response['internal']).to eq(false)\n      expect(article_json_response['created_by_id']).to eq(agent_user.id)\n      expect(article_json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(article_json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id)\n\n      Scheduler.worker(true)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(ticket.id)\n      expect(json_response['tickets_count']).to eq(1)\n\n      params = {\n        condition: {\n          'ticket.title' => {\n            operator: 'contains',\n            value:    title,\n          },\n        },\n      }\n      post '/api/v1/tickets/search', params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(ticket.id)\n      expect(json_response['tickets_count']).to eq(1)\n\n      delete \"/api/v1/ticket_articles/#{article_json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      params = {\n        from:      'something which should not be changed on server side',\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n        type:      'email',\n        internal:  true,\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq(%(\"Tickets Agent via #{ticket_group.email_address.realname}\" <#{ticket_group.email_address.email}>))\n      expect(json_response['subject']).to eq('some subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(true)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'email').id)\n\n      params = {\n        subject: 'new subject',\n      }\n      put \"/api/v1/ticket_articles/#{json_response['id']}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq(%(\"Tickets Agent via #{ticket_group.email_address.realname}\" <#{ticket_group.email_address.email}>))\n      expect(json_response['subject']).to eq('new subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(true)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'email').id)\n\n      params = {\n        from:      'something which should not be changed on server side',\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n        type:      'email',\n        internal:  false,\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response['internal']).to eq(false)\n\n      delete \"/api/v1/ticket_articles/#{json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (admin permission required)!')\n\n      delete \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (admin permission required)!')\n    end\n\n    it 'does ticket with correct ticket id (02.05)' do\n      ticket = create(\n        :ticket,\n        title:       'ticket with corret ticket id',\n        group:       ticket_group,\n        customer_id: customer_user.id,\n      )\n      authenticated_as(admin_user)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq('ticket with corret ticket id')\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(1)\n      expect(json_response['created_by_id']).to eq(1)\n\n      params = {\n        title:       'ticket with corret ticket id - 2',\n        customer_id: agent_user.id,\n      }\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq('ticket with corret ticket id - 2')\n      expect(json_response['customer_id']).to eq(agent_user.id)\n      expect(json_response['updated_by_id']).to eq(admin_user.id)\n      expect(json_response['created_by_id']).to eq(1)\n\n      params = {\n        from:      'something which should not be changed on server side',\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq('Tickets Admin')\n      expect(json_response['subject']).to eq('some subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(false)\n      expect(json_response['created_by_id']).to eq(admin_user.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id)\n\n      params = {\n        subject:  'new subject',\n        internal: true,\n      }\n      put \"/api/v1/ticket_articles/#{json_response['id']}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq('Tickets Admin')\n      expect(json_response['subject']).to eq('new subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(true)\n      expect(json_response['created_by_id']).to eq(admin_user.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id)\n\n      delete \"/api/v1/ticket_articles/#{json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      params = {\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n        type:      'email',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq(%(\"Tickets Admin via #{ticket_group.email_address.realname}\" <#{ticket_group.email_address.email}>))\n      expect(json_response['subject']).to eq('some subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(false)\n      expect(json_response['created_by_id']).to eq(admin_user.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'email').id)\n\n      delete \"/api/v1/ticket_articles/#{json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      delete \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n    end\n\n    it 'does ticket pagination (02.05)' do\n      title = \"ticket pagination #{rand(999_999_999)}\"\n      tickets = []\n      (1..20).each do |count|\n        ticket = create(\n          :ticket,\n          title:       \"#{title} - #{count}\",\n          group:       ticket_group,\n          customer_id: customer_user.id,\n        )\n        create(\n          :ticket_article,\n          type:      Ticket::Article::Type.lookup(name: 'note'),\n          sender:    Ticket::Article::Sender.lookup(name: 'Customer'),\n          ticket_id: ticket.id,\n        )\n        tickets.push ticket\n        travel 2.seconds\n      end\n\n      authenticated_as(admin_user)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(tickets[19].id)\n      expect(json_response['tickets'][19]).to eq(tickets[0].id)\n      expect(json_response['tickets_count']).to eq(20)\n\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=10\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(tickets[19].id)\n      expect(json_response['tickets'][9]).to eq(tickets[10].id)\n      expect(json_response['tickets_count']).to eq(10)\n\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40&page=1&per_page=5\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(tickets[19].id)\n      expect(json_response['tickets'][4]).to eq(tickets[15].id)\n      expect(json_response['tickets_count']).to eq(5)\n\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40&page=2&per_page=5\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(tickets[14].id)\n      expect(json_response['tickets'][4]).to eq(tickets[10].id)\n      expect(json_response['tickets_count']).to eq(5)\n\n      get '/api/v1/tickets?limit=40&page=1&per_page=5', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Array)\n      tickets = Ticket.order(:id).limit(5)\n      expect(json_response[0]['id']).to eq(tickets[0].id)\n      expect(json_response[4]['id']).to eq(tickets[4].id)\n      expect(json_response.count).to eq(5)\n\n      get '/api/v1/tickets?limit=40&page=2&per_page=5', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Array)\n      tickets = Ticket.order(:id).limit(10)\n      expect(json_response[0]['id']).to eq(tickets[5].id)\n      expect(json_response[4]['id']).to eq(tickets[9].id)\n      expect(json_response.count).to eq(5)\n\n    end\n\n    it 'does ticket create with customer minimal (03.01)' do\n      params = {\n        title:    'a new ticket #c1',\n        state:    'new',\n        priority: '2 normal',\n        group:    ticket_group.name,\n        article:  {\n          body: 'some body',\n        },\n      }\n      authenticated_as(customer_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #c1')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(customer_user.id)\n      expect(json_response['created_by_id']).to eq(customer_user.id)\n    end\n\n    it 'does ticket create with customer with wrong customer (03.02)' do\n      params = {\n        title:       'a new ticket #c2',\n        state:       'new',\n        priority:    '2 normal',\n        group:       ticket_group.name,\n        customer_id: agent_user.id,\n        article:     {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n          sender:       'System',\n        },\n      }\n      authenticated_as(customer_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #c2')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(customer_user.id)\n      expect(json_response['created_by_id']).to eq(customer_user.id)\n    end\n\n    it 'does ticket create with customer with wrong customer hash (03.03)' do\n      params = {\n        title:    'a new ticket #c2',\n        state:    'new',\n        priority: '2 normal',\n        group:    ticket_group.name,\n        customer: {\n          firstname: agent_user.firstname,\n          lastname:  agent_user.lastname,\n          email:     agent_user.email,\n        },\n        article:  {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n          sender:       'System',\n        },\n      }\n      authenticated_as(customer_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #c2')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(customer_user.id)\n      expect(json_response['created_by_id']).to eq(customer_user.id)\n    end\n\n    it 'does ticket with wrong ticket id (03.04)' do\n      ticket = create(\n        :ticket,\n        title:       'ticket with wrong ticket id',\n        group:       ticket_group,\n        customer_id: agent_user.id,\n      )\n      authenticated_as(customer_user)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n\n      params = {\n        title: 'ticket with wrong ticket id - 2',\n      }\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n\n      delete \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n    end\n\n    it 'does ticket with correct ticket id (03.05)' do\n      title = \"ticket with corret ticket id testme#{rand(999_999_999)}\"\n      ticket = create(\n        :ticket,\n        title:       title,\n        group:       ticket_group,\n        customer_id: customer_user.id,\n      )\n      authenticated_as(customer_user)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(title)\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(1)\n      expect(json_response['created_by_id']).to eq(1)\n\n      params = {\n        title:       \"#{title} - 2\",\n        customer_id: agent_user.id,\n      }\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(\"#{title} - 2\")\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(customer_user.id)\n      expect(json_response['created_by_id']).to eq(1)\n\n      params = {\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      article_json_response = json_response\n      expect(article_json_response).to be_a_kind_of(Hash)\n      expect(article_json_response['ticket_id']).to eq(ticket.id)\n      expect(article_json_response['from']).to eq('Tickets Customer1')\n      expect(article_json_response['subject']).to eq('some subject')\n      expect(article_json_response['body']).to eq('some body')\n      expect(article_json_response['content_type']).to eq('text/plain')\n      expect(article_json_response['created_by_id']).to eq(customer_user.id)\n      expect(article_json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Customer').id)\n      expect(article_json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id)\n\n      Scheduler.worker(true)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(ticket.id)\n      expect(json_response['tickets_count']).to eq(1)\n\n      params = {\n        condition: {\n          'ticket.title' => {\n            operator: 'contains',\n            value:    title,\n          },\n        },\n      }\n      post '/api/v1/tickets/search', params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(ticket.id)\n      expect(json_response['tickets_count']).to eq(1)\n\n      delete \"/api/v1/ticket_articles/#{article_json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (admin permission required)!')\n\n      params = {\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n        type:      'email',\n        sender:    'Agent',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq('Tickets Customer1')\n      expect(json_response['subject']).to eq('some subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['created_by_id']).to eq(customer_user.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Customer').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id)\n\n      delete \"/api/v1/ticket_articles/#{json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (admin permission required)!')\n\n      params = {\n        from:      'something which should not be changed on server side',\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n        type:      'web',\n        sender:    'Agent',\n        internal:  true,\n      }\n\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq('Tickets Customer1 <tickets-customer1@example.com>')\n      expect(json_response['subject']).to eq('some subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(false)\n      expect(json_response['created_by_id']).to eq(customer_user.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Customer').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'web').id)\n\n      params = {\n        subject: 'new subject',\n      }\n      put \"/api/v1/ticket_articles/#{json_response['id']}\", params: params, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (ticket.agent or admin permission required)!')\n\n      delete \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (admin permission required)!')\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (03.6)' do\n      authenticated_as(customer_user)\n      params = {\n        title:    'a new ticket #3.6',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          body:      'some test 123',\n          origin_by: agent_user.login,\n        },\n      }\n\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #3.6')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(customer_user.id)\n      expect(json_response['created_by_id']).to eq(customer_user.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(customer_user.id)\n      expect(article.created_by_id).to eq(customer_user.id)\n      expect(article.origin_by_id).to eq(customer_user.id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('Tickets Customer1')\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (03.6)' do\n      authenticated_as(customer_user)\n      params = {\n        title:    'a new ticket #3.6.1',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          sender:       'Agent',\n          body:         'some test 123',\n          origin_by_id: agent_user.id,\n        },\n      }\n\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #3.6.1')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(customer_user.id)\n      expect(json_response['created_by_id']).to eq(customer_user.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(customer_user.id)\n      expect(article.created_by_id).to eq(customer_user.id)\n      expect(article.origin_by_id).to eq(customer_user.id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('Tickets Customer1')\n    end\n\n    it 'does ticket show and response format (04.01)' do\n      title = \"ticket testagent#{rand(999_999_999)}\"\n      ticket = create(\n        :ticket,\n        title:         title,\n        group:         ticket_group,\n        customer_id:   customer_user.id,\n        updated_by_id: agent_user.id,\n        created_by_id: agent_user.id,\n      )\n      authenticated_as(agent_user)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(ticket.title)\n      expect(json_response['group']).to be_falsey\n      expect(json_response['priority']).to be_falsey\n      expect(json_response['owner']).to be_falsey\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      get \"/api/v1/tickets/#{ticket.id}?expand=true\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(ticket.title)\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['group']).to eq(ticket.group.name)\n      expect(json_response['priority']).to eq(ticket.priority.name)\n      expect(json_response['owner']).to eq(ticket.owner.login)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      get \"/api/v1/tickets/#{ticket.id}?expand=false\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(ticket.title)\n      expect(json_response['group']).to be_falsey\n      expect(json_response['priority']).to be_falsey\n      expect(json_response['owner']).to be_falsey\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      get \"/api/v1/tickets/#{ticket.id}?full=true\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['id']).to eq(ticket.id)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['title']).to eq(ticket.title)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['customer_id']).to eq(ticket.customer_id)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][agent_user.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][agent_user.id.to_s]['id']).to eq(agent_user.id)\n      expect(json_response['assets']['User'][agent_user.id.to_s]['firstname']).to eq(agent_user.firstname)\n      expect(json_response['assets']['User'][agent_user.id.to_s]['lastname']).to eq(agent_user.lastname)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][customer_user.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][customer_user.id.to_s]['id']).to eq(customer_user.id)\n      expect(json_response['assets']['User'][customer_user.id.to_s]['firstname']).to eq(customer_user.firstname)\n      expect(json_response['assets']['User'][customer_user.id.to_s]['lastname']).to eq(customer_user.lastname)\n\n      get \"/api/v1/tickets/#{ticket.id}?full=false\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(ticket.title)\n      expect(json_response['group']).to be_falsey\n      expect(json_response['priority']).to be_falsey\n      expect(json_response['owner']).to be_falsey\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n    end\n\n    it 'does ticket index and response format (04.02)' do\n      title = \"ticket testagent#{rand(999_999_999)}\"\n      ticket = create(\n        :ticket,\n        title:         title,\n        group:         ticket_group,\n        customer_id:   customer_user.id,\n        updated_by_id: agent_user.id,\n        created_by_id: agent_user.id,\n      )\n      authenticated_as(agent_user)\n      get '/api/v1/tickets', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      expect(json_response).to be_a_kind_of(Array)\n      expect(json_response[0]).to be_a_kind_of(Hash)\n      expect(json_response[0]['id']).to eq(1)\n      expect(json_response[1]['id']).to eq(ticket.id)\n      expect(json_response[1]['title']).to eq(ticket.title)\n      expect(json_response[1]['group']).to be_falsey\n      expect(json_response[1]['priority']).to be_falsey\n      expect(json_response[1]['owner']).to be_falsey\n      expect(json_response[1]['customer_id']).to eq(ticket.customer_id)\n      expect(json_response[1]['updated_by_id']).to eq(agent_user.id)\n      expect(json_response[1]['created_by_id']).to eq(agent_user.id)\n\n      get '/api/v1/tickets?expand=true', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Array)\n      expect(json_response[0]).to be_a_kind_of(Hash)\n      expect(json_response[0]['id']).to eq(1)\n      expect(json_response[1]['id']).to eq(ticket.id)\n      expect(json_response[1]['title']).to eq(ticket.title)\n      expect(json_response[1]['customer_id']).to eq(ticket.customer_id)\n      expect(json_response[1]['group']).to eq(ticket.group.name)\n      expect(json_response[1]['priority']).to eq(ticket.priority.name)\n      expect(json_response[1]['owner']).to eq(ticket.owner.login)\n      expect(json_response[1]['updated_by_id']).to eq(agent_user.id)\n      expect(json_response[1]['created_by_id']).to eq(agent_user.id)\n\n      get '/api/v1/tickets?expand=false', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Array)\n      expect(json_response[0]).to be_a_kind_of(Hash)\n      expect(json_response[0]['id']).to eq(1)\n      expect(json_response[1]['id']).to eq(ticket.id)\n      expect(json_response[1]['title']).to eq(ticket.title)\n      expect(json_response[1]['group']).to be_falsey\n      expect(json_response[1]['priority']).to be_falsey\n      expect(json_response[1]['owner']).to be_falsey\n      expect(json_response[1]['customer_id']).to eq(ticket.customer_id)\n      expect(json_response[1]['updated_by_id']).to eq(agent_user.id)\n      expect(json_response[1]['created_by_id']).to eq(agent_user.id)\n\n      get '/api/v1/tickets?full=true', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['record_ids'].class).to eq(Array)\n      expect(json_response['record_ids'][0]).to eq(1)\n      expect(json_response['record_ids'][1]).to eq(ticket.id)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['id']).to eq(ticket.id)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['title']).to eq(ticket.title)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['customer_id']).to eq(ticket.customer_id)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][agent_user.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][agent_user.id.to_s]['id']).to eq(agent_user.id)\n      expect(json_response['assets']['User'][agent_user.id.to_s]['firstname']).to eq(agent_user.firstname)\n      expect(json_response['assets']['User'][agent_user.id.to_s]['lastname']).to eq(agent_user.lastname)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][customer_user.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][customer_user.id.to_s]['id']).to eq(customer_user.id)\n      expect(json_response['assets']['User'][customer_user.id.to_s]['firstname']).to eq(customer_user.firstname)\n      expect(json_response['assets']['User'][customer_user.id.to_s]['lastname']).to eq(customer_user.lastname)\n\n      get '/api/v1/tickets?full=false', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Array)\n      expect(json_response[0]).to be_a_kind_of(Hash)\n      expect(json_response[0]['id']).to eq(1)\n      expect(json_response[1]['id']).to eq(ticket.id)\n      expect(json_response[1]['title']).to eq(ticket.title)\n      expect(json_response[1]['group']).to be_falsey\n      expect(json_response[1]['priority']).to be_falsey\n      expect(json_response[1]['owner']).to be_falsey\n      expect(json_response[1]['customer_id']).to eq(ticket.customer_id)\n      expect(json_response[1]['updated_by_id']).to eq(agent_user.id)\n      expect(json_response[1]['created_by_id']).to eq(agent_user.id)\n    end\n\n    it 'does ticket create and response format (04.03)' do\n      title = \"ticket testagent#{rand(999_999_999)}\"\n      params = {\n        title:       title,\n        group:       ticket_group.name,\n        customer_id: customer_user.id,\n        state:       'new',\n        priority:    '2 normal',\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent_user)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['state_id']).to eq(ticket.state_id)\n      expect(json_response['state']).to be_falsey\n      expect(json_response['priority_id']).to eq(ticket.priority_id)\n      expect(json_response['priority']).to be_falsey\n      expect(json_response['group_id']).to eq(ticket.group_id)\n      expect(json_response['group']).to be_falsey\n      expect(json_response['title']).to eq(title)\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      post '/api/v1/tickets?expand=true', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['state_id']).to eq(ticket.state_id)\n      expect(json_response['state']).to eq(ticket.state.name)\n      expect(json_response['priority_id']).to eq(ticket.priority_id)\n      expect(json_response['priority']).to eq(ticket.priority.name)\n      expect(json_response['group_id']).to eq(ticket.group_id)\n      expect(json_response['group']).to eq(ticket.group.name)\n      expect(json_response['title']).to eq(title)\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      post '/api/v1/tickets?full=true', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['id']).to eq(ticket.id)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['title']).to eq(title)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['customer_id']).to eq(ticket.customer_id)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][agent_user.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][agent_user.id.to_s]['id']).to eq(agent_user.id)\n      expect(json_response['assets']['User'][agent_user.id.to_s]['firstname']).to eq(agent_user.firstname)\n      expect(json_response['assets']['User'][agent_user.id.to_s]['lastname']).to eq(agent_user.lastname)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][customer_user.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][customer_user.id.to_s]['id']).to eq(customer_user.id)\n      expect(json_response['assets']['User'][customer_user.id.to_s]['firstname']).to eq(customer_user.firstname)\n      expect(json_response['assets']['User'][customer_user.id.to_s]['lastname']).to eq(customer_user.lastname)\n\n    end\n\n    it 'does ticket update and response formats (04.04)' do\n      title = \"ticket testagent#{rand(999_999_999)}\"\n      ticket = create(\n        :ticket,\n        title:         title,\n        group:         ticket_group,\n        customer_id:   customer_user.id,\n        updated_by_id: agent_user.id,\n        created_by_id: agent_user.id,\n      )\n\n      params = {\n        title: 'a update ticket #1',\n      }\n      authenticated_as(agent_user)\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['state_id']).to eq(ticket.state_id)\n      expect(json_response['state']).to be_falsey\n      expect(json_response['priority_id']).to eq(ticket.priority_id)\n      expect(json_response['priority']).to be_falsey\n      expect(json_response['group_id']).to eq(ticket.group_id)\n      expect(json_response['group']).to be_falsey\n      expect(json_response['title']).to eq('a update ticket #1')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      params = {\n        title: 'a update ticket #2',\n      }\n      put \"/api/v1/tickets/#{ticket.id}?expand=true\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['state_id']).to eq(ticket.state_id)\n      expect(json_response['state']).to eq(ticket.state.name)\n      expect(json_response['priority_id']).to eq(ticket.priority_id)\n      expect(json_response['priority']).to eq(ticket.priority.name)\n      expect(json_response['group_id']).to eq(ticket.group_id)\n      expect(json_response['group']).to eq(ticket.group.name)\n      expect(json_response['title']).to eq('a update ticket #2')\n      expect(json_response['customer_id']).to eq(customer_user.id)\n      expect(json_response['updated_by_id']).to eq(agent_user.id)\n      expect(json_response['created_by_id']).to eq(agent_user.id)\n\n      params = {\n        title: 'a update ticket #3',\n      }\n      put \"/api/v1/tickets/#{ticket.id}?full=true\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['id']).to eq(ticket.id)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['title']).to eq('a update ticket #3')\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['customer_id']).to eq(ticket.customer_id)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][agent_user.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][agent_user.id.to_s]['id']).to eq(agent_user.id)\n      expect(json_response['assets']['User'][agent_user.id.to_s]['firstname']).to eq(agent_user.firstname)\n      expect(json_response['assets']['User'][agent_user.id.to_s]['lastname']).to eq(agent_user.lastname)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][customer_user.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][customer_user.id.to_s]['id']).to eq(customer_user.id)\n      expect(json_response['assets']['User'][customer_user.id.to_s]['firstname']).to eq(customer_user.firstname)\n      expect(json_response['assets']['User'][customer_user.id.to_s]['lastname']).to eq(customer_user.lastname)\n\n      # it should be not possible to modify the ticket number\n      expected_ticket_number = ticket.number\n      params = {\n        title:  'a update ticket #4',\n        number: '77777',\n      }\n      put \"/api/v1/tickets/#{ticket.id}?full=true\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['title']).to eq('a update ticket #4')\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['number']).to eq(expected_ticket_number)\n    end\n\n    it 'does ticket split with html - check attachments (05.01)' do\n      ticket = create(\n        :ticket,\n        title:         'some title',\n        group:         ticket_group,\n        customer_id:   customer_user.id,\n        updated_by_id: agent_user.id,\n        created_by_id: agent_user.id,\n      )\n      article = create(\n        :ticket_article,\n        type:         Ticket::Article::Type.lookup(name: 'note'),\n        sender:       Ticket::Article::Sender.lookup(name: 'Customer'),\n        body:         '<b>test</b> <img src=\"cid:15.274327094.140938@ZAMMAD.example.com\"/> test <img src=\"cid:15.274327094.140938.3@ZAMMAD.example.com\"/>',\n        content_type: 'text/html',\n        ticket_id:    ticket.id,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_image',\n        filename:      'some_file1.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file2_normally_should_be_an_image',\n        filename:      'some_file2.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938.2@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file3_normally_should_be_an_image',\n        filename:      'some_file3.jpg',\n        preferences:   {\n          'Content-Type' => 'image/jpeg',\n          'Mime-Type'    => 'image/jpeg',\n          'Content-ID'   => '15.274327094.140938.3@zammad.example.com',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file4_normally_should_be_an_image',\n        filename:      'some_file4.jpg',\n        preferences:   {\n          'Content-Type' => 'image/jpeg',\n          'Mime-Type'    => 'image/jpeg',\n          'Content-ID'   => '15.274327094.140938.4@zammad.example.com',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_pdf',\n        filename:      'Rechnung_RE-2018-200.pdf',\n        preferences:   {\n          'Content-Type'        => 'application/octet-stream; name=\"Rechnung_RE-2018-200.pdf\"',\n          'Mime-Type'           => 'application/octet-stream',\n          'Content-ID'          => '8AB0BEC88984EE4EBEF643C79C8E0346@zammad.example.com',\n          'Content-Description' => 'Rechnung_RE-2018-200.pdf',\n          'Content-Disposition' => 'attachment',\n        },\n        created_by_id: 1,\n      )\n\n      authenticated_as(customer_user)\n      get \"/api/v1/ticket_split?ticket_id=#{ticket.id}&article_id=#{article.id}&form_id=new_form_id123\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n\n      authenticated_as(agent_user)\n      get \"/api/v1/ticket_split?ticket_id=#{ticket.id}&article_id=#{article.id}&form_id=new_form_id123\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['TicketArticle'][article.id.to_s]).to be_truthy\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(3)\n\n      get \"/api/v1/ticket_split?ticket_id=#{ticket.id}&article_id=#{article.id}&form_id=new_form_id123\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['TicketArticle'][article.id.to_s]).to be_truthy\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(0)\n\n    end\n\n    it 'does ticket split with plain - check attachments (05.02)' do\n      ticket = create(\n        :ticket,\n        title:         'some title',\n        group:         ticket_group,\n        customer_id:   customer_user.id,\n        updated_by_id: agent_user.id,\n        created_by_id: agent_user.id,\n      )\n      article = create(\n        :ticket_article,\n        type:         Ticket::Article::Type.lookup(name: 'note'),\n        sender:       Ticket::Article::Sender.lookup(name: 'Customer'),\n        body:         '<b>test</b> <img src=\"cid:15.274327094.140938@zammad.example.com\"/>',\n        content_type: 'text/plain',\n        ticket_id:    ticket.id,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_image',\n        filename:      'some_file1.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_image',\n        filename:      'some_file2.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938.2@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_pdf',\n        filename:      'Rechnung_RE-2018-200.pdf',\n        preferences:   {\n          'Content-Type'        => 'application/octet-stream; name=\"Rechnung_RE-2018-200.pdf\"',\n          'Mime-Type'           => 'application/octet-stream',\n          'Content-ID'          => '8AB0BEC88984EE4EBEF643C79C8E0346@zammad.example.com',\n          'Content-Description' => 'Rechnung_RE-2018-200.pdf',\n          'Content-Disposition' => 'attachment',\n        },\n        created_by_id: 1,\n      )\n\n      authenticated_as(agent_user)\n      get \"/api/v1/ticket_split?ticket_id=#{ticket.id}&article_id=#{article.id}&form_id=new_form_id123\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['TicketArticle'][article.id.to_s]).to be_truthy\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(3)\n\n      get \"/api/v1/ticket_split?ticket_id=#{ticket.id}&article_id=#{article.id}&form_id=new_form_id123\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['TicketArticle'][article.id.to_s]).to be_truthy\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(0)\n\n    end\n\n    it 'does ticket merge (07.01)' do\n      group_no_permission = create(:group)\n      ticket1 = create(\n        :ticket,\n        title:       'ticket merge1',\n        group:       ticket_group,\n        customer_id: customer_user.id,\n      )\n      ticket2 = create(\n        :ticket,\n        title:       'ticket merge2',\n        group:       ticket_group,\n        customer_id: customer_user.id,\n      )\n      ticket3 = create(\n        :ticket,\n        title:       'ticket merge2',\n        group:       group_no_permission,\n        customer_id: customer_user.id,\n      )\n\n      authenticated_as(customer_user)\n      get \"/api/v1/ticket_merge/#{ticket2.id}/#{ticket1.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n\n      authenticated_as(agent_user)\n      get \"/api/v1/ticket_merge/#{ticket2.id}/#{ticket1.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['result']).to eq('failed')\n      expect(json_response['message']).to eq('No such master ticket number!')\n\n      get \"/api/v1/ticket_merge/#{ticket3.id}/#{ticket1.number}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n      expect(json_response['error_human']).to eq('Not authorized')\n\n      get \"/api/v1/ticket_merge/#{ticket1.id}/#{ticket3.number}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n      expect(json_response['error_human']).to eq('Not authorized')\n\n      get \"/api/v1/ticket_merge/#{ticket1.id}/#{ticket2.number}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['result']).to eq('success')\n      expect(json_response['master_ticket']['id']).to eq(ticket2.id)\n    end\n\n    it 'does ticket merge - change permission (07.02)' do\n      group_change_permission = Group.create!(\n        name:          'GroupWithChangePermission',\n        active:        true,\n        updated_by_id: 1,\n        created_by_id: 1,\n      )\n      ticket1 = create(\n        :ticket,\n        title:       'ticket merge1',\n        group:       group_change_permission,\n        customer_id: customer_user.id,\n      )\n      ticket2 = create(\n        :ticket,\n        title:       'ticket merge2',\n        group:       group_change_permission,\n        customer_id: customer_user.id,\n      )\n\n      agent_user.group_names_access_map = { group_change_permission.name => %w[read change] }\n\n      authenticated_as(agent_user)\n      get \"/api/v1/ticket_merge/#{ticket1.id}/#{ticket2.number}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['result']).to eq('success')\n      expect(json_response['master_ticket']['id']).to eq(ticket2.id)\n    end\n\n    it 'does ticket search sorted (08.01)' do\n      title = \"ticket pagination #{rand(999_999_999)}\"\n\n      ticket1 = create(\n        :ticket,\n        title:       \"#{title} A\",\n        group:       ticket_group,\n        customer_id: customer_user.id,\n        created_at:  '2018-02-05 17:42:00',\n        updated_at:  '2018-02-05 20:42:00',\n      )\n      create(\n        :ticket_article,\n        type:      Ticket::Article::Type.lookup(name: 'note'),\n        sender:    Ticket::Article::Sender.lookup(name: 'Customer'),\n        ticket_id: ticket1.id,\n      )\n\n      ticket2 = create(\n        :ticket,\n        title:       \"#{title} B\",\n        group:       ticket_group,\n        customer_id: customer_user.id,\n        state:       Ticket::State.lookup(name: 'new'),\n        priority:    Ticket::Priority.lookup(name: '3 hoch'),\n        created_at:  '2018-02-05 19:42:00',\n        updated_at:  '2018-02-05 19:42:00',\n      )\n      create(\n        :ticket_article,\n        type:      Ticket::Article::Type.lookup(name: 'note'),\n        sender:    Ticket::Article::Sender.lookup(name: 'Customer'),\n        ticket_id: ticket2.id,\n      )\n\n      authenticated_as(admin_user)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket2.id, ticket1.id])\n\n      authenticated_as(admin_user)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: { sort_by: 'created_at', order_by: 'asc' }, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket1.id, ticket2.id])\n\n      authenticated_as(admin_user)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: { sort_by: 'title', order_by: 'asc' }, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket1.id, ticket2.id])\n\n      authenticated_as(admin_user)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: { sort_by: 'title', order_by: 'desc' }, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket2.id, ticket1.id])\n\n      authenticated_as(admin_user)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: { sort_by: %w[created_at updated_at], order_by: %w[asc asc] }, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket1.id, ticket2.id])\n\n      authenticated_as(admin_user)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: { sort_by: %w[created_at updated_at], order_by: %w[desc asc]  }, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket2.id, ticket1.id])\n    end\n\n    it 'does ticket history ' do\n      ticket1 = create(\n        :ticket,\n        title:       'some title',\n        group:       ticket_group,\n        customer_id: customer_user.id,\n      )\n      create(\n        :ticket_article,\n        type:      Ticket::Article::Type.lookup(name: 'note'),\n        sender:    Ticket::Article::Sender.lookup(name: 'Customer'),\n        ticket_id: ticket1.id,\n      )\n\n      authenticated_as(agent_user)\n      get \"/api/v1/ticket_history/#{ticket1.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['history'].class).to eq(Array)\n      expect(json_response['assets'].class).to eq(Hash)\n      expect(json_response['assets']['User'][customer_user.id.to_s]).not_to be_nil\n      expect(json_response['assets']['Ticket'][ticket1.id.to_s]).not_to be_nil\n\n      authenticated_as(customer_user)\n      get \"/api/v1/ticket_history/#{ticket1.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n    end\n\n    it 'does ticket related' do\n      ticket1 = create(\n        :ticket,\n        title:       'some title',\n        group:       ticket_group,\n        customer_id: customer_user.id,\n      )\n\n      authenticated_as(agent_user)\n      get \"/api/v1/ticket_related/#{ticket1.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      authenticated_as(customer_user)\n      get \"/api/v1/ticket_related/#{ticket1.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n    end\n\n    it 'does ticket recent' do\n      authenticated_as(agent_user)\n      get '/api/v1/ticket_recent', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      authenticated_as(customer_user)\n      get '/api/v1/ticket_recent', params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n    end\n\n  end\n\n  describe 'stats' do\n    let(:ticket1) { create(:ticket, customer: customer, organization: organization, group: ticket_group) }\n    let(:ticket2) { create(:ticket, customer: customer, organization: organization, group: ticket_group) }\n    let(:ticket3) { create(:ticket, customer: customer, organization: organization, group: ticket_group) }\n    let(:customer) { create(:customer_user, organization: organization) }\n    let(:organization) { create(:organization, shared: false) }\n\n    before do\n      authenticated_as(admin_user)\n\n      ticket1\n      travel 2.minutes\n      ticket2\n      travel 2.minutes\n      ticket3\n      travel 2.minutes\n      ticket2.touch\n    end\n\n    # https://github.com/zammad/zammad/issues/2296\n    it 'orders tickets by created_at desc (#2296)' do\n      get '/api/v1/ticket_stats', params: { organization_id: organization.id, user_id: customer.id }, as: :json\n\n      expect(response).to have_http_status(:ok)\n      expect(json_response)\n        .to be_a_kind_of(Hash)\n        .and include('user' => hash_including('open_ids' => [ticket3.id, ticket2.id, ticket1.id]))\n        .and include('organization' => hash_including('open_ids' => [ticket3.id, ticket2.id, ticket1.id]))\n    end\n\n  end\n\n  describe '/api/v1/tickets' do\n    subject(:ticket) { create(:ticket, state_name: 'closed') }\n\n    let(:admin) { create(:admin_user, groups: [ticket.group]) }\n    let(:agent) { create(:agent_user, groups: [ticket.group]) }\n    let(:customer) { ticket.customer }\n\n    describe 'reopening a ticket' do\n      shared_examples 'successfully reopen a ticket' do\n        it 'succeeds' do\n          put \"/api/v1/tickets/#{ticket.id}\",\n              params: { state_id: Ticket::State.find_by(name: 'open').id },\n              as:     :json\n\n          expect(response).to have_http_status(:ok)\n          expect(json_response).to include('state_id' => Ticket::State.find_by(name: 'open').id)\n        end\n      end\n\n      shared_examples 'fail to reopen a ticket' do\n        it 'fails' do\n          put \"/api/v1/tickets/#{ticket.id}\",\n              params: { state_id: Ticket::State.find_by(name: 'open').id },\n              as:     :json\n\n          expect(response).to have_http_status(:unprocessable_entity)\n          expect(json_response).to include('error' => 'Cannot follow-up on a closed ticket. Please create a new ticket.')\n        end\n      end\n\n      context 'when ticket.group.follow_up_possible = \"yes\"' do\n        before { ticket.group.update(follow_up_possible: 'yes') }\n\n        context 'as admin', authenticated_as: -> { admin } do\n          include_examples 'successfully reopen a ticket'\n        end\n\n        context 'as agent', authenticated_as: -> { agent } do\n          include_examples 'successfully reopen a ticket'\n        end\n\n        context 'as customer', authenticated_as: -> { customer } do\n          include_examples 'successfully reopen a ticket'\n        end\n      end\n\n      context 'when ticket.group.follow_up_possible = \"new_ticket\"' do\n        before { ticket.group.update(follow_up_possible: 'new_ticket') }\n\n        context 'as admin', authenticated_as: -> { admin } do\n          include_examples 'successfully reopen a ticket'\n        end\n\n        context 'as agent', authenticated_as: -> { agent } do\n          include_examples 'successfully reopen a ticket'\n        end\n\n        context 'as customer', authenticated_as: -> { customer } do\n          include_examples 'fail to reopen a ticket'\n        end\n      end\n    end\n  end\n\n  describe 'GET /api/v1/ticket_customer' do\n\n    subject(:ticket) { create(:ticket, customer: customer_authorized) }\n\n    let(:organization_authorized) { create(:organization) }\n    let(:customer_authorized) { create(:customer_user, organization: organization_authorized) }\n\n    let(:organization_unauthorized) { create(:organization) }\n    let(:customer_unauthorized) { create(:customer_user, organization: organization_unauthorized) }\n\n    let(:agent) { create(:agent_user, groups: [ticket.group]) }\n\n    describe 'listing information' do\n\n      before do\n        ticket\n      end\n\n      shared_examples 'has access' do\n        it 'succeeds' do\n          get '/api/v1/ticket_customer',\n              params: { customer_id: customer_authorized.id },\n              as:     :json\n\n          expect(json_response['ticket_ids_open']).to include(ticket.id)\n          expect(json_response['ticket_ids_closed']).to be_blank\n        end\n      end\n\n      shared_examples 'has no access' do\n        it 'fails' do\n          get '/api/v1/ticket_customer',\n              params: { customer_id: customer_authorized.id },\n              as:     :json\n\n          expect(json_response['ticket_ids_open']).to be_blank\n          expect(json_response['ticket_ids_closed']).to be_blank\n          expect(json_response['assets']).to be_blank\n        end\n      end\n\n      context 'as agent', authenticated_as: -> { agent } do\n        include_examples 'has access'\n      end\n\n      context 'as authorized customer', authenticated_as: -> { customer_authorized } do\n        include_examples 'has no access'\n      end\n\n      context 'as unauthorized customer', authenticated_as: -> { customer_unauthorized } do\n        include_examples 'has no access'\n      end\n    end\n  end\nend\n"], "filenames": ["app/controllers/tickets_controller.rb", "app/policies/controllers/tickets_controller_policy.rb", "spec/requests/ticket_spec.rb"], "buggy_code_start_loc": [9, 3, 1795], "buggy_code_end_loc": [10, 3, 2217], "fixing_code_start_loc": [9, 4, 1796], "fixing_code_end_loc": [10, 5, 2257], "type": "CWE-862", "message": "In Zammad before 3.3.1, a Customer has ticket access that should only be available to an Agent (e.g., read internal data, split, or merge).", "other": {"cve": {"id": "CVE-2020-14213", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-16T23:15:11.173", "lastModified": "2020-06-23T01:09:45.830", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Zammad before 3.3.1, a Customer has ticket access that should only be available to an Agent (e.g., read internal data, split, or merge)."}, {"lang": "es", "value": "En Zammad en versiones anteriores a la 3.3.1, un Cliente tiene un acceso de entrada que s\u00f3lo deber\u00eda estar disponible para un Agente (por ejemplo, leer datos internos, dividir o fusionar)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zammad:zammad:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.3.1", "matchCriteriaId": "A382790E-6572-4F7E-91F9-C6F8A67364D7"}]}]}], "references": [{"url": "https://github.com/zammad/zammad/commit/6e56aee25439b7a3211a6704a9d60453ad623ae4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://zammad.com/news/security-advisory-zaa-2020-13", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/zammad/zammad/commit/6e56aee25439b7a3211a6704a9d60453ad623ae4"}}