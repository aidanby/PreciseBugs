{"buggy_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * COPYRIGHT (C) 2006,2007\n * THE REGENTS OF THE UNIVERSITY OF MICHIGAN\n * ALL RIGHTS RESERVED\n *\n * Permission is granted to use, copy, create derivative works\n * and redistribute this software and such derivative works\n * for any purpose, so long as the name of The University of\n * Michigan is not used in any advertising or publicity\n * pertaining to the use of distribution of this software\n * without specific, written prior authorization.  If the\n * above copyright notice or any other identification of the\n * University of Michigan is included in any copy of any\n * portion of this software, then the disclaimer below must\n * also be included.\n *\n * THIS SOFTWARE IS PROVIDED AS IS, WITHOUT REPRESENTATION\n * FROM THE UNIVERSITY OF MICHIGAN AS TO ITS FITNESS FOR ANY\n * PURPOSE, AND WITHOUT WARRANTY BY THE UNIVERSITY OF\n * MICHIGAN OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING\n * WITHOUT LIMITATION THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE\n * REGENTS OF THE UNIVERSITY OF MICHIGAN SHALL NOT BE LIABLE\n * FOR ANY DAMAGES, INCLUDING SPECIAL, INDIRECT, INCIDENTAL, OR\n * CONSEQUENTIAL DAMAGES, WITH RESPECT TO ANY CLAIM ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OF THE SOFTWARE, EVEN\n * IF IT HAS BEEN OR IS HEREAFTER ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGES.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n\n#include <k5-int.h>\n#include \"pkinit.h\"\n\nstatic krb5_error_code\npkinit_init_kdc_req_context(krb5_context, pkinit_kdc_req_context *blob);\n\nstatic void\npkinit_fini_kdc_req_context(krb5_context context, void *blob);\n\nstatic void\npkinit_server_plugin_fini_realm(krb5_context context,\n                                pkinit_kdc_context plgctx);\n\nstatic void\npkinit_server_plugin_fini(krb5_context context,\n                          krb5_kdcpreauth_moddata moddata);\n\nstatic pkinit_kdc_context\npkinit_find_realm_context(krb5_context context,\n                          krb5_kdcpreauth_moddata moddata,\n                          krb5_principal princ);\n\nstatic krb5_error_code\npkinit_create_edata(krb5_context context,\n                    pkinit_plg_crypto_context plg_cryptoctx,\n                    pkinit_req_crypto_context req_cryptoctx,\n                    pkinit_identity_crypto_context id_cryptoctx,\n                    pkinit_plg_opts *opts,\n                    krb5_error_code err_code,\n                    krb5_pa_data ***e_data_out)\n{\n    krb5_error_code retval = KRB5KRB_ERR_GENERIC;\n\n    pkiDebug(\"pkinit_create_edata: creating edata for error %d (%s)\\n\",\n             err_code, error_message(err_code));\n    switch(err_code) {\n    case KRB5KDC_ERR_CANT_VERIFY_CERTIFICATE:\n        retval = pkinit_create_td_trusted_certifiers(context,\n                                                     plg_cryptoctx, req_cryptoctx, id_cryptoctx, e_data_out);\n        break;\n    case KRB5KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED:\n        retval = pkinit_create_td_dh_parameters(context, plg_cryptoctx,\n                                                req_cryptoctx, id_cryptoctx, opts, e_data_out);\n        break;\n    case KRB5KDC_ERR_INVALID_CERTIFICATE:\n    case KRB5KDC_ERR_REVOKED_CERTIFICATE:\n        retval = pkinit_create_td_invalid_certificate(context,\n                                                      plg_cryptoctx, req_cryptoctx, id_cryptoctx, e_data_out);\n        break;\n    default:\n        pkiDebug(\"no edata needed for error %d (%s)\\n\",\n                 err_code, error_message(err_code));\n        retval = 0;\n        goto cleanup;\n    }\n\ncleanup:\n\n    return retval;\n}\n\nstatic void\npkinit_server_get_edata(krb5_context context,\n                        krb5_kdc_req *request,\n                        krb5_kdcpreauth_callbacks cb,\n                        krb5_kdcpreauth_rock rock,\n                        krb5_kdcpreauth_moddata moddata,\n                        krb5_preauthtype pa_type,\n                        krb5_kdcpreauth_edata_respond_fn respond,\n                        void *arg)\n{\n    krb5_error_code retval = 0;\n    pkinit_kdc_context plgctx = NULL;\n\n    pkiDebug(\"pkinit_server_get_edata: entered!\\n\");\n\n\n    /*\n     * If we don't have a realm context for the given realm,\n     * don't tell the client that we support pkinit!\n     */\n    plgctx = pkinit_find_realm_context(context, moddata, request->server);\n    if (plgctx == NULL)\n        retval = EINVAL;\n\n    (*respond)(arg, retval, NULL);\n}\n\nstatic krb5_error_code\nverify_client_san(krb5_context context,\n                  pkinit_kdc_context plgctx,\n                  pkinit_kdc_req_context reqctx,\n                  krb5_principal client,\n                  int *valid_san)\n{\n    krb5_error_code retval;\n    krb5_principal *princs = NULL;\n    krb5_principal *upns = NULL;\n    int i;\n#ifdef DEBUG_SAN_INFO\n    char *client_string = NULL, *san_string;\n#endif\n\n    retval = crypto_retrieve_cert_sans(context, plgctx->cryptoctx,\n                                       reqctx->cryptoctx, plgctx->idctx,\n                                       &princs,\n                                       plgctx->opts->allow_upn ? &upns : NULL,\n                                       NULL);\n    if (retval) {\n        pkiDebug(\"%s: error from retrieve_certificate_sans()\\n\", __FUNCTION__);\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n        goto out;\n    }\n    /* XXX Verify this is consistent with client side XXX */\n#if 0\n    retval = call_san_checking_plugins(context, plgctx, reqctx, princs,\n                                       upns, NULL, &plugin_decision, &ignore);\n    pkiDebug(\"%s: call_san_checking_plugins() returned retval %d\\n\",\n             __FUNCTION__);\n    if (retval) {\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n        goto cleanup;\n    }\n    pkiDebug(\"%s: call_san_checking_plugins() returned decision %d\\n\",\n             __FUNCTION__, plugin_decision);\n    if (plugin_decision != NO_DECISION) {\n        retval = plugin_decision;\n        goto out;\n    }\n#endif\n\n#ifdef DEBUG_SAN_INFO\n    krb5_unparse_name(context, client, &client_string);\n#endif\n    pkiDebug(\"%s: Checking pkinit sans\\n\", __FUNCTION__);\n    for (i = 0; princs != NULL && princs[i] != NULL; i++) {\n#ifdef DEBUG_SAN_INFO\n        krb5_unparse_name(context, princs[i], &san_string);\n        pkiDebug(\"%s: Comparing client '%s' to pkinit san value '%s'\\n\",\n                 __FUNCTION__, client_string, san_string);\n        krb5_free_unparsed_name(context, san_string);\n#endif\n        if (krb5_principal_compare(context, princs[i], client)) {\n            pkiDebug(\"%s: pkinit san match found\\n\", __FUNCTION__);\n            *valid_san = 1;\n            retval = 0;\n            goto out;\n        }\n    }\n    pkiDebug(\"%s: no pkinit san match found\\n\", __FUNCTION__);\n    /*\n     * XXX if cert has names but none match, should we\n     * be returning KRB5KDC_ERR_CLIENT_NAME_MISMATCH here?\n     */\n\n    if (upns == NULL) {\n        pkiDebug(\"%s: no upn sans (or we wouldn't accept them anyway)\\n\",\n                 __FUNCTION__);\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n        goto out;\n    }\n\n    pkiDebug(\"%s: Checking upn sans\\n\", __FUNCTION__);\n    for (i = 0; upns[i] != NULL; i++) {\n#ifdef DEBUG_SAN_INFO\n        krb5_unparse_name(context, upns[i], &san_string);\n        pkiDebug(\"%s: Comparing client '%s' to upn san value '%s'\\n\",\n                 __FUNCTION__, client_string, san_string);\n        krb5_free_unparsed_name(context, san_string);\n#endif\n        if (krb5_principal_compare(context, upns[i], client)) {\n            pkiDebug(\"%s: upn san match found\\n\", __FUNCTION__);\n            *valid_san = 1;\n            retval = 0;\n            goto out;\n        }\n    }\n    pkiDebug(\"%s: no upn san match found\\n\", __FUNCTION__);\n\n    /* We found no match */\n    if (princs != NULL || upns != NULL) {\n        *valid_san = 0;\n        /* XXX ??? If there was one or more name in the cert, but\n         * none matched the client name, then return mismatch? */\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n    }\n    retval = 0;\n\nout:\n    if (princs != NULL) {\n        for (i = 0; princs[i] != NULL; i++)\n            krb5_free_principal(context, princs[i]);\n        free(princs);\n    }\n    if (upns != NULL) {\n        for (i = 0; upns[i] != NULL; i++)\n            krb5_free_principal(context, upns[i]);\n        free(upns);\n    }\n#ifdef DEBUG_SAN_INFO\n    if (client_string != NULL)\n        krb5_free_unparsed_name(context, client_string);\n#endif\n    pkiDebug(\"%s: returning retval %d, valid_san %d\\n\",\n             __FUNCTION__, retval, *valid_san);\n    return retval;\n}\n\nstatic krb5_error_code\nverify_client_eku(krb5_context context,\n                  pkinit_kdc_context plgctx,\n                  pkinit_kdc_req_context reqctx,\n                  int *eku_accepted)\n{\n    krb5_error_code retval;\n\n    *eku_accepted = 0;\n\n    if (plgctx->opts->require_eku == 0) {\n        pkiDebug(\"%s: configuration requests no EKU checking\\n\", __FUNCTION__);\n        *eku_accepted = 1;\n        retval = 0;\n        goto out;\n    }\n\n    retval = crypto_check_cert_eku(context, plgctx->cryptoctx,\n                                   reqctx->cryptoctx, plgctx->idctx,\n                                   0, /* kdc cert */\n                                   plgctx->opts->accept_secondary_eku,\n                                   eku_accepted);\n    if (retval) {\n        pkiDebug(\"%s: Error from crypto_check_cert_eku %d (%s)\\n\",\n                 __FUNCTION__, retval, error_message(retval));\n        goto out;\n    }\n\nout:\n    pkiDebug(\"%s: returning retval %d, eku_accepted %d\\n\",\n             __FUNCTION__, retval, *eku_accepted);\n    return retval;\n}\n\nstatic void\npkinit_server_verify_padata(krb5_context context,\n                            krb5_data *req_pkt,\n                            krb5_kdc_req * request,\n                            krb5_enc_tkt_part * enc_tkt_reply,\n                            krb5_pa_data * data,\n                            krb5_kdcpreauth_callbacks cb,\n                            krb5_kdcpreauth_rock rock,\n                            krb5_kdcpreauth_moddata moddata,\n                            krb5_kdcpreauth_verify_respond_fn respond,\n                            void *arg)\n{\n    krb5_error_code retval = 0;\n    krb5_octet_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};\n    krb5_pa_pk_as_req *reqp = NULL;\n    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;\n    krb5_auth_pack *auth_pack = NULL;\n    krb5_auth_pack_draft9 *auth_pack9 = NULL;\n    pkinit_kdc_context plgctx = NULL;\n    pkinit_kdc_req_context reqctx = NULL;\n    krb5_checksum cksum = {0, 0, 0, NULL};\n    krb5_data *der_req = NULL;\n    int valid_eku = 0, valid_san = 0;\n    krb5_kdc_req *tmp_as_req = NULL;\n    krb5_data k5data;\n    int is_signed = 1;\n    krb5_pa_data **e_data = NULL;\n    krb5_kdcpreauth_modreq modreq = NULL;\n\n    pkiDebug(\"pkinit_verify_padata: entered!\\n\");\n    if (data == NULL || data->length <= 0 || data->contents == NULL) {\n        (*respond)(arg, 0, NULL, NULL, NULL);\n        return;\n    }\n\n\n    if (moddata == NULL) {\n        (*respond)(arg, EINVAL, NULL, NULL, NULL);\n        return;\n    }\n\n    plgctx = pkinit_find_realm_context(context, moddata, request->server);\n    if (plgctx == NULL) {\n        (*respond)(arg, 0, NULL, NULL, NULL);\n        return;\n    }\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(data->contents, data->length, \"/tmp/kdc_as_req\");\n#endif\n    /* create a per-request context */\n    retval = pkinit_init_kdc_req_context(context, &reqctx);\n    if (retval)\n        goto cleanup;\n    reqctx->pa_type = data->pa_type;\n\n    PADATA_TO_KRB5DATA(data, &k5data);\n\n    switch ((int)data->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        pkiDebug(\"processing KRB5_PADATA_PK_AS_REQ\\n\");\n        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);\n        if (retval) {\n            pkiDebug(\"decode_krb5_pa_pk_as_req failed\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin(reqp->signedAuthPack.data,\n                         reqp->signedAuthPack.length,\n                         \"/tmp/kdc_signed_data\");\n#endif\n        retval = cms_signeddata_verify(context, plgctx->cryptoctx,\n                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,\n                                       plgctx->opts->require_crl_checking,\n                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,\n                                       &authp_data.data, &authp_data.length, &krb5_authz.data,\n                                       &krb5_authz.length, &is_signed);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        pkiDebug(\"processing KRB5_PADATA_PK_AS_REQ_OLD\\n\");\n        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);\n        if (retval) {\n            pkiDebug(\"decode_krb5_pa_pk_as_req_draft9 failed\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin(reqp9->signedAuthPack.data,\n                         reqp9->signedAuthPack.length,\n                         \"/tmp/kdc_signed_data_draft9\");\n#endif\n\n        retval = cms_signeddata_verify(context, plgctx->cryptoctx,\n                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,\n                                       plgctx->opts->require_crl_checking,\n                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,\n                                       &authp_data.data, &authp_data.length, &krb5_authz.data,\n                                       &krb5_authz.length, NULL);\n        break;\n    default:\n        pkiDebug(\"unrecognized pa_type = %d\\n\", data->pa_type);\n        retval = EINVAL;\n        goto cleanup;\n    }\n    if (retval) {\n        pkiDebug(\"pkcs7_signeddata_verify failed\\n\");\n        goto cleanup;\n    }\n    if (is_signed) {\n\n        retval = verify_client_san(context, plgctx, reqctx, request->client,\n                                   &valid_san);\n        if (retval)\n            goto cleanup;\n        if (!valid_san) {\n            pkiDebug(\"%s: did not find an acceptable SAN in user \"\n                     \"certificate\\n\", __FUNCTION__);\n            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n            goto cleanup;\n        }\n        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);\n        if (retval)\n            goto cleanup;\n\n        if (!valid_eku) {\n            pkiDebug(\"%s: did not find an acceptable EKU in user \"\n                     \"certificate\\n\", __FUNCTION__);\n            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;\n            goto cleanup;\n        }\n    } else { /* !is_signed */\n        if (!krb5_principal_compare(context, request->client,\n                                    krb5_anonymous_principal())) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            krb5_set_error_message(context, retval,\n                                   _(\"Pkinit request not signed, but client \"\n                                     \"not anonymous.\"));\n            goto cleanup;\n        }\n    }\n#ifdef DEBUG_ASN1\n    print_buffer_bin(authp_data.data, authp_data.length, \"/tmp/kdc_auth_pack\");\n#endif\n\n    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);\n    switch ((int)data->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);\n        if (retval) {\n            pkiDebug(\"failed to decode krb5_auth_pack\\n\");\n            goto cleanup;\n        }\n\n        /* check dh parameters */\n        if (auth_pack->clientPublicValue != NULL) {\n            retval = server_check_dh(context, plgctx->cryptoctx,\n                                     reqctx->cryptoctx, plgctx->idctx,\n                                     &auth_pack->clientPublicValue->algorithm.parameters,\n                                     plgctx->opts->dh_min_bits);\n\n            if (retval) {\n                pkiDebug(\"bad dh parameters\\n\");\n                goto cleanup;\n            }\n        } else if (!is_signed) {\n            /*Anonymous pkinit requires DH*/\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            krb5_set_error_message(context, retval,\n                                   _(\"Anonymous pkinit without DH public \"\n                                     \"value not supported.\"));\n            goto cleanup;\n        }\n        der_req = cb->request_body(context, rock);\n        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,\n                                      0, der_req, &cksum);\n        if (retval) {\n            pkiDebug(\"unable to calculate AS REQ checksum\\n\");\n            goto cleanup;\n        }\n        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||\n            memcmp(cksum.contents,\n                   auth_pack->pkAuthenticator.paChecksum.contents,\n                   cksum.length)) {\n            pkiDebug(\"failed to match the checksum\\n\");\n#ifdef DEBUG_CKSUM\n            pkiDebug(\"calculating checksum on buf size (%d)\\n\",\n                     req_pkt->length);\n            print_buffer(req_pkt->data, req_pkt->length);\n            pkiDebug(\"received checksum type=%d size=%d \",\n                     auth_pack->pkAuthenticator.paChecksum.checksum_type,\n                     auth_pack->pkAuthenticator.paChecksum.length);\n            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,\n                         auth_pack->pkAuthenticator.paChecksum.length);\n            pkiDebug(\"expected checksum type=%d size=%d \",\n                     cksum.checksum_type, cksum.length);\n            print_buffer(cksum.contents, cksum.length);\n#endif\n\n            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;\n            goto cleanup;\n        }\n\n        /* check if kdcPkId present and match KDC's subjectIdentifier */\n        if (reqp->kdcPkId.data != NULL) {\n            int valid_kdcPkId = 0;\n            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,\n                                           reqctx->cryptoctx, plgctx->idctx,\n                                           reqp->kdcPkId.data, reqp->kdcPkId.length, &valid_kdcPkId);\n            if (retval)\n                goto cleanup;\n            if (!valid_kdcPkId)\n                pkiDebug(\"kdcPkId in AS_REQ does not match KDC's cert\"\n                         \"RFC says to ignore and proceed\\n\");\n\n        }\n        /* remember the decoded auth_pack for verify_padata routine */\n        reqctx->rcv_auth_pack = auth_pack;\n        auth_pack = NULL;\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);\n        if (retval) {\n            pkiDebug(\"failed to decode krb5_auth_pack_draft9\\n\");\n            goto cleanup;\n        }\n        if (auth_pack9->clientPublicValue != NULL) {\n            retval = server_check_dh(context, plgctx->cryptoctx,\n                                     reqctx->cryptoctx, plgctx->idctx,\n                                     &auth_pack9->clientPublicValue->algorithm.parameters,\n                                     plgctx->opts->dh_min_bits);\n\n            if (retval) {\n                pkiDebug(\"bad dh parameters\\n\");\n                goto cleanup;\n            }\n        }\n        /* remember the decoded auth_pack for verify_padata routine */\n        reqctx->rcv_auth_pack9 = auth_pack9;\n        auth_pack9 = NULL;\n        break;\n    }\n\n    /* remember to set the PREAUTH flag in the reply */\n    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n    modreq = (krb5_kdcpreauth_modreq)reqctx;\n    reqctx = NULL;\n\ncleanup:\n    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {\n        pkiDebug(\"pkinit_verify_padata failed: creating e-data\\n\");\n        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,\n                                plgctx->idctx, plgctx->opts, retval, &e_data))\n            pkiDebug(\"pkinit_create_edata failed\\n\");\n    }\n\n    switch ((int)data->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        free_krb5_pa_pk_as_req(&reqp);\n        free(cksum.contents);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        free_krb5_pa_pk_as_req_draft9(&reqp9);\n    }\n    if (tmp_as_req != NULL)\n        k5int_krb5_free_kdc_req(context, tmp_as_req);\n    free(authp_data.data);\n    free(krb5_authz.data);\n    if (reqctx != NULL)\n        pkinit_fini_kdc_req_context(context, reqctx);\n    if (auth_pack != NULL)\n        free_krb5_auth_pack(&auth_pack);\n    if (auth_pack9 != NULL)\n        free_krb5_auth_pack_draft9(context, &auth_pack9);\n\n    (*respond)(arg, retval, modreq, e_data, NULL);\n}\nstatic krb5_error_code\nreturn_pkinit_kx(krb5_context context, krb5_kdc_req *request,\n                 krb5_kdc_rep *reply, krb5_keyblock *encrypting_key,\n                 krb5_pa_data **out_padata)\n{\n    krb5_error_code ret = 0;\n    krb5_keyblock *session = reply->ticket->enc_part2->session;\n    krb5_keyblock *new_session = NULL;\n    krb5_pa_data *pa = NULL;\n    krb5_enc_data enc;\n    krb5_data *scratch = NULL;\n\n    *out_padata = NULL;\n    enc.ciphertext.data = NULL;\n    if (!krb5_principal_compare(context, request->client,\n                                krb5_anonymous_principal()))\n        return 0;\n    /*\n     * The KDC contribution key needs to be a fresh key of an enctype supported\n     * by the client and server. The existing session key meets these\n     * requirements so we use it.\n     */\n    ret = krb5_c_fx_cf2_simple(context, session, \"PKINIT\",\n                               encrypting_key, \"KEYEXCHANGE\",\n                               &new_session);\n    if (ret)\n        goto cleanup;\n    ret = encode_krb5_encryption_key( session, &scratch);\n    if (ret)\n        goto cleanup;\n    ret = krb5_encrypt_helper(context, encrypting_key,\n                              KRB5_KEYUSAGE_PA_PKINIT_KX, scratch, &enc);\n    if (ret)\n        goto cleanup;\n    memset(scratch->data, 0, scratch->length);\n    krb5_free_data(context, scratch);\n    scratch = NULL;\n    ret = encode_krb5_enc_data(&enc, &scratch);\n    if (ret)\n        goto cleanup;\n    pa = malloc(sizeof(krb5_pa_data));\n    if (pa == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n    pa->pa_type = KRB5_PADATA_PKINIT_KX;\n    pa->length = scratch->length;\n    pa->contents = (krb5_octet *) scratch->data;\n    *out_padata = pa;\n    scratch->data = NULL;\n    memset(session->contents, 0, session->length);\n    krb5_free_keyblock_contents(context, session);\n    *session = *new_session;\n    new_session->contents = NULL;\ncleanup:\n    krb5_free_data_contents(context, &enc.ciphertext);\n    krb5_free_keyblock(context, new_session);\n    krb5_free_data(context, scratch);\n    return ret;\n}\n\nstatic krb5_error_code\npkinit_pick_kdf_alg(krb5_context context,\n                    krb5_octet_data **kdf_list,\n                    krb5_octet_data **alg_oid)\n{\n    krb5_error_code retval = 0;\n    krb5_octet_data *req_oid = NULL;\n    const krb5_octet_data *supp_oid = NULL;\n    krb5_octet_data *tmp_oid = NULL;\n    int i, j = 0;\n\n    /* if we don't find a match, return NULL value */\n    *alg_oid = NULL;\n\n    /* for each of the OIDs that the server supports... */\n    for (i = 0; NULL != (supp_oid = supported_kdf_alg_ids[i]); i++) {\n        /* if the requested OID is in the client's list, use it. */\n        for (j = 0; NULL != (req_oid = kdf_list[j]); j++) {\n            if ((req_oid->length == supp_oid->length) &&\n                (0 == memcmp(req_oid->data, supp_oid->data, req_oid->length))) {\n                tmp_oid = k5alloc(sizeof(krb5_octet_data), &retval);\n                if (retval)\n                    goto cleanup;\n                tmp_oid->data = k5alloc(supp_oid->length, &retval);\n                if (retval)\n                    goto cleanup;\n                tmp_oid->length = supp_oid->length;\n                memcpy(tmp_oid->data, supp_oid->data, tmp_oid->length);\n                *alg_oid = tmp_oid;\n                /* don't free the OID in clean-up if we are returning it */\n                tmp_oid = NULL;\n                goto cleanup;\n            }\n        }\n    }\ncleanup:\n    if (tmp_oid)\n        krb5_free_octet_data(context, tmp_oid);\n    return retval;\n}\n\nstatic krb5_error_code\npkinit_server_return_padata(krb5_context context,\n                            krb5_pa_data * padata,\n                            krb5_data *req_pkt,\n                            krb5_kdc_req * request,\n                            krb5_kdc_rep * reply,\n                            krb5_keyblock * encrypting_key,\n                            krb5_pa_data ** send_pa,\n                            krb5_kdcpreauth_callbacks cb,\n                            krb5_kdcpreauth_rock rock,\n                            krb5_kdcpreauth_moddata moddata,\n                            krb5_kdcpreauth_modreq modreq)\n{\n    krb5_error_code retval = 0;\n    krb5_data scratch = {0, 0, NULL};\n    krb5_pa_pk_as_req *reqp = NULL;\n    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;\n    int i = 0;\n\n    unsigned char *subjectPublicKey = NULL;\n    unsigned char *dh_pubkey = NULL, *server_key = NULL;\n    unsigned int subjectPublicKey_len = 0;\n    unsigned int server_key_len = 0, dh_pubkey_len = 0;\n\n    krb5_kdc_dh_key_info dhkey_info;\n    krb5_data *encoded_dhkey_info = NULL;\n    krb5_pa_pk_as_rep *rep = NULL;\n    krb5_pa_pk_as_rep_draft9 *rep9 = NULL;\n    krb5_data *out_data = NULL;\n    krb5_octet_data secret;\n\n    krb5_enctype enctype = -1;\n\n    krb5_reply_key_pack *key_pack = NULL;\n    krb5_reply_key_pack_draft9 *key_pack9 = NULL;\n    krb5_data *encoded_key_pack = NULL;\n\n    pkinit_kdc_context plgctx;\n    pkinit_kdc_req_context reqctx;\n\n    int fixed_keypack = 0;\n\n    *send_pa = NULL;\n    if (padata->pa_type == KRB5_PADATA_PKINIT_KX) {\n        return return_pkinit_kx(context, request, reply,\n                                encrypting_key, send_pa);\n    }\n    if (padata->length <= 0 || padata->contents == NULL)\n        return 0;\n\n    if (modreq == NULL) {\n        pkiDebug(\"missing request context \\n\");\n        return EINVAL;\n    }\n\n    plgctx = pkinit_find_realm_context(context, moddata, request->server);\n    if (plgctx == NULL) {\n        pkiDebug(\"Unable to locate correct realm context\\n\");\n        return ENOENT;\n    }\n\n    pkiDebug(\"pkinit_return_padata: entered!\\n\");\n    reqctx = (pkinit_kdc_req_context)modreq;\n\n    if (encrypting_key->contents) {\n        free(encrypting_key->contents);\n        encrypting_key->length = 0;\n        encrypting_key->contents = NULL;\n    }\n\n    for(i = 0; i < request->nktypes; i++) {\n        enctype = request->ktype[i];\n        if (!krb5_c_valid_enctype(enctype))\n            continue;\n        else {\n            pkiDebug(\"KDC picked etype = %d\\n\", enctype);\n            break;\n        }\n    }\n\n    if (i == request->nktypes) {\n        retval = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto cleanup;\n    }\n\n    switch((int)reqctx->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        init_krb5_pa_pk_as_rep(&rep);\n        if (rep == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        /* let's assume it's RSA. we'll reset it to DH if needed */\n        rep->choice = choice_pa_pk_as_rep_encKeyPack;\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        init_krb5_pa_pk_as_rep_draft9(&rep9);\n        if (rep9 == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        rep9->choice = choice_pa_pk_as_rep_draft9_encKeyPack;\n        break;\n    default:\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        goto cleanup;\n    }\n\n    if (reqctx->rcv_auth_pack != NULL &&\n        reqctx->rcv_auth_pack->clientPublicValue != NULL) {\n        subjectPublicKey =\n            reqctx->rcv_auth_pack->clientPublicValue->subjectPublicKey.data;\n        subjectPublicKey_len =\n            reqctx->rcv_auth_pack->clientPublicValue->subjectPublicKey.length;\n        rep->choice = choice_pa_pk_as_rep_dhInfo;\n    } else if (reqctx->rcv_auth_pack9 != NULL &&\n               reqctx->rcv_auth_pack9->clientPublicValue != NULL) {\n        subjectPublicKey =\n            reqctx->rcv_auth_pack9->clientPublicValue->subjectPublicKey.data;\n        subjectPublicKey_len =\n            reqctx->rcv_auth_pack9->clientPublicValue->subjectPublicKey.length;\n        rep9->choice = choice_pa_pk_as_rep_draft9_dhSignedData;\n    }\n\n    /* if this DH, then process finish computing DH key */\n    if (rep != NULL && (rep->choice == choice_pa_pk_as_rep_dhInfo ||\n                        rep->choice == choice_pa_pk_as_rep_draft9_dhSignedData)) {\n        pkiDebug(\"received DH key delivery AS REQ\\n\");\n        retval = server_process_dh(context, plgctx->cryptoctx,\n                                   reqctx->cryptoctx, plgctx->idctx, subjectPublicKey,\n                                   subjectPublicKey_len, &dh_pubkey, &dh_pubkey_len,\n                                   &server_key, &server_key_len);\n        if (retval) {\n            pkiDebug(\"failed to process/create dh paramters\\n\");\n            goto cleanup;\n        }\n    }\n    if ((rep9 != NULL &&\n         rep9->choice == choice_pa_pk_as_rep_draft9_dhSignedData) ||\n        (rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo)) {\n\n        /*\n         * This is DH, so don't generate the key until after we\n         * encode the reply, because the encoded reply is needed\n         * to generate the key in some cases.\n         */\n\n        dhkey_info.subjectPublicKey.length = dh_pubkey_len;\n        dhkey_info.subjectPublicKey.data = dh_pubkey;\n        dhkey_info.nonce = request->nonce;\n        dhkey_info.dhKeyExpiration = 0;\n\n        retval = k5int_encode_krb5_kdc_dh_key_info(&dhkey_info,\n                                                   &encoded_dhkey_info);\n        if (retval) {\n            pkiDebug(\"encode_krb5_kdc_dh_key_info failed\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin((unsigned char *)encoded_dhkey_info->data,\n                         encoded_dhkey_info->length,\n                         \"/tmp/kdc_dh_key_info\");\n#endif\n\n        switch ((int)padata->pa_type) {\n        case KRB5_PADATA_PK_AS_REQ:\n            retval = cms_signeddata_create(context, plgctx->cryptoctx,\n                                           reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_SERVER, 1,\n                                           (unsigned char *)encoded_dhkey_info->data,\n                                           encoded_dhkey_info->length,\n                                           &rep->u.dh_Info.dhSignedData.data,\n                                           &rep->u.dh_Info.dhSignedData.length);\n            if (retval) {\n                pkiDebug(\"failed to create pkcs7 signed data\\n\");\n                goto cleanup;\n            }\n            break;\n        case KRB5_PADATA_PK_AS_REP_OLD:\n        case KRB5_PADATA_PK_AS_REQ_OLD:\n            retval = cms_signeddata_create(context, plgctx->cryptoctx,\n                                           reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9, 1,\n                                           (unsigned char *)encoded_dhkey_info->data,\n                                           encoded_dhkey_info->length,\n                                           &rep9->u.dhSignedData.data,\n                                           &rep9->u.dhSignedData.length);\n            if (retval) {\n                pkiDebug(\"failed to create pkcs7 signed data\\n\");\n                goto cleanup;\n            }\n            break;\n        }\n\n    } else {\n        pkiDebug(\"received RSA key delivery AS REQ\\n\");\n\n        retval = krb5_c_make_random_key(context, enctype, encrypting_key);\n        if (retval) {\n            pkiDebug(\"unable to make a session key\\n\");\n            goto cleanup;\n        }\n\n        /* check if PA_TYPE of 132 is present which means the client is\n         * requesting that a checksum is send back instead of the nonce\n         */\n        for (i = 0; request->padata[i] != NULL; i++) {\n            pkiDebug(\"%s: Checking pa_type 0x%08x\\n\",\n                     __FUNCTION__, request->padata[i]->pa_type);\n            if (request->padata[i]->pa_type == 132)\n                fixed_keypack = 1;\n        }\n        pkiDebug(\"%s: return checksum instead of nonce = %d\\n\",\n                 __FUNCTION__, fixed_keypack);\n\n        /* if this is an RFC reply or draft9 client requested a checksum\n         * in the reply instead of the nonce, create an RFC-style keypack\n         */\n        if ((int)padata->pa_type == KRB5_PADATA_PK_AS_REQ || fixed_keypack) {\n            init_krb5_reply_key_pack(&key_pack);\n            if (key_pack == NULL) {\n                retval = ENOMEM;\n                goto cleanup;\n            }\n\n            retval = krb5_c_make_checksum(context, 0,\n                                          encrypting_key, KRB5_KEYUSAGE_TGS_REQ_AUTH_CKSUM,\n                                          req_pkt, &key_pack->asChecksum);\n            if (retval) {\n                pkiDebug(\"unable to calculate AS REQ checksum\\n\");\n                goto cleanup;\n            }\n#ifdef DEBUG_CKSUM\n            pkiDebug(\"calculating checksum on buf size = %d\\n\", req_pkt->length);\n            print_buffer(req_pkt->data, req_pkt->length);\n            pkiDebug(\"checksum size = %d\\n\", key_pack->asChecksum.length);\n            print_buffer(key_pack->asChecksum.contents,\n                         key_pack->asChecksum.length);\n            pkiDebug(\"encrypting key (%d)\\n\", encrypting_key->length);\n            print_buffer(encrypting_key->contents, encrypting_key->length);\n#endif\n\n            krb5_copy_keyblock_contents(context, encrypting_key,\n                                        &key_pack->replyKey);\n\n            retval = k5int_encode_krb5_reply_key_pack(key_pack,\n                                                      &encoded_key_pack);\n            if (retval) {\n                pkiDebug(\"failed to encode reply_key_pack\\n\");\n                goto cleanup;\n            }\n        }\n\n        switch ((int)padata->pa_type) {\n        case KRB5_PADATA_PK_AS_REQ:\n            rep->choice = choice_pa_pk_as_rep_encKeyPack;\n            retval = cms_envelopeddata_create(context, plgctx->cryptoctx,\n                                              reqctx->cryptoctx, plgctx->idctx, padata->pa_type, 1,\n                                              (unsigned char *)encoded_key_pack->data,\n                                              encoded_key_pack->length,\n                                              &rep->u.encKeyPack.data, &rep->u.encKeyPack.length);\n            break;\n        case KRB5_PADATA_PK_AS_REP_OLD:\n        case KRB5_PADATA_PK_AS_REQ_OLD:\n            /* if the request is from the broken draft9 client that\n             * expects back a nonce, create it now\n             */\n            if (!fixed_keypack) {\n                init_krb5_reply_key_pack_draft9(&key_pack9);\n                if (key_pack9 == NULL) {\n                    retval = ENOMEM;\n                    goto cleanup;\n                }\n                key_pack9->nonce = reqctx->rcv_auth_pack9->pkAuthenticator.nonce;\n                krb5_copy_keyblock_contents(context, encrypting_key,\n                                            &key_pack9->replyKey);\n\n                retval = k5int_encode_krb5_reply_key_pack_draft9(key_pack9,\n                                                                 &encoded_key_pack);\n                if (retval) {\n                    pkiDebug(\"failed to encode reply_key_pack\\n\");\n                    goto cleanup;\n                }\n            }\n\n            rep9->choice = choice_pa_pk_as_rep_draft9_encKeyPack;\n            retval = cms_envelopeddata_create(context, plgctx->cryptoctx,\n                                              reqctx->cryptoctx, plgctx->idctx, padata->pa_type, 1,\n                                              (unsigned char *)encoded_key_pack->data,\n                                              encoded_key_pack->length,\n                                              &rep9->u.encKeyPack.data, &rep9->u.encKeyPack.length);\n            break;\n        }\n        if (retval) {\n            pkiDebug(\"failed to create pkcs7 enveloped data: %s\\n\",\n                     error_message(retval));\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin((unsigned char *)encoded_key_pack->data,\n                         encoded_key_pack->length,\n                         \"/tmp/kdc_key_pack\");\n        switch ((int)padata->pa_type) {\n        case KRB5_PADATA_PK_AS_REQ:\n            print_buffer_bin(rep->u.encKeyPack.data,\n                             rep->u.encKeyPack.length,\n                             \"/tmp/kdc_enc_key_pack\");\n            break;\n        case KRB5_PADATA_PK_AS_REP_OLD:\n        case KRB5_PADATA_PK_AS_REQ_OLD:\n            print_buffer_bin(rep9->u.encKeyPack.data,\n                             rep9->u.encKeyPack.length,\n                             \"/tmp/kdc_enc_key_pack\");\n            break;\n        }\n#endif\n    }\n\n    if ((rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo) &&\n        ((reqctx->rcv_auth_pack != NULL &&\n          reqctx->rcv_auth_pack->supportedKDFs != NULL))) {\n\n        /* If using the alg-agility KDF, put the algorithm in the reply\n         * before encoding it.\n         */\n        if (reqctx->rcv_auth_pack != NULL &&\n            reqctx->rcv_auth_pack->supportedKDFs != NULL) {\n            retval = pkinit_pick_kdf_alg(context, reqctx->rcv_auth_pack->supportedKDFs,\n                                         &(rep->u.dh_Info.kdfID));\n            if (retval) {\n                pkiDebug(\"pkinit_pick_kdf_alg failed: %s\\n\",\n                         error_message(retval));\n                goto cleanup;\n            }\n        }\n    }\n\n    switch ((int)padata->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        retval = k5int_encode_krb5_pa_pk_as_rep(rep, &out_data);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        retval = k5int_encode_krb5_pa_pk_as_rep_draft9(rep9, &out_data);\n        break;\n    }\n    if (retval) {\n        pkiDebug(\"failed to encode AS_REP\\n\");\n        goto cleanup;\n    }\n#ifdef DEBUG_ASN1\n    if (out_data != NULL)\n        print_buffer_bin((unsigned char *)out_data->data, out_data->length,\n                         \"/tmp/kdc_as_rep\");\n#endif\n\n    /* If this is DH, we haven't computed the key yet, so do it now. */\n    if ((rep9 != NULL &&\n         rep9->choice == choice_pa_pk_as_rep_draft9_dhSignedData) ||\n        (rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo)) {\n\n        /* If mutually supported KDFs were found, use the alg agility KDF */\n        if (rep->u.dh_Info.kdfID) {\n            secret.data = server_key;\n            secret.length = server_key_len;\n\n            retval = pkinit_alg_agility_kdf(context, &secret,\n                                            rep->u.dh_Info.kdfID,\n                                            request->client, request->server,\n                                            enctype,\n                                            (krb5_octet_data *)req_pkt,\n                                            (krb5_octet_data *)out_data,\n                                            encrypting_key);\n            if (retval) {\n                pkiDebug(\"pkinit_alg_agility_kdf failed: %s\\n\",\n                         error_message(retval));\n                goto cleanup;\n            }\n\n            /* Otherwise, use the older octetstring2key() function */\n        } else {\n            retval = pkinit_octetstring2key(context, enctype, server_key,\n                                            server_key_len, encrypting_key);\n            if (retval) {\n                pkiDebug(\"pkinit_octetstring2key failed: %s\\n\",\n                         error_message(retval));\n                goto cleanup;\n            }\n        }\n    }\n\n    *send_pa = malloc(sizeof(krb5_pa_data));\n    if (*send_pa == NULL) {\n        retval = ENOMEM;\n        free(out_data->data);\n        free(out_data);\n        out_data = NULL;\n        goto cleanup;\n    }\n    (*send_pa)->magic = KV5M_PA_DATA;\n    switch ((int)padata->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        (*send_pa)->pa_type = KRB5_PADATA_PK_AS_REP;\n        break;\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n    case KRB5_PADATA_PK_AS_REP_OLD:\n        (*send_pa)->pa_type = KRB5_PADATA_PK_AS_REP_OLD;\n        break;\n    }\n    (*send_pa)->length = out_data->length;\n    (*send_pa)->contents = (krb5_octet *) out_data->data;\n\ncleanup:\n    pkinit_fini_kdc_req_context(context, reqctx);\n    free(scratch.data);\n    free(out_data);\n    if (encoded_dhkey_info != NULL)\n        krb5_free_data(context, encoded_dhkey_info);\n    if (encoded_key_pack != NULL)\n        krb5_free_data(context, encoded_key_pack);\n    free(dh_pubkey);\n    free(server_key);\n\n    switch ((int)padata->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        free_krb5_pa_pk_as_req(&reqp);\n        free_krb5_pa_pk_as_rep(&rep);\n        free_krb5_reply_key_pack(&key_pack);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        free_krb5_pa_pk_as_req_draft9(&reqp9);\n        free_krb5_pa_pk_as_rep_draft9(&rep9);\n        if (!fixed_keypack)\n            free_krb5_reply_key_pack_draft9(&key_pack9);\n        else\n            free_krb5_reply_key_pack(&key_pack);\n        break;\n    }\n\n    if (retval)\n        pkiDebug(\"pkinit_verify_padata failure\");\n\n    return retval;\n}\n\nstatic int\npkinit_server_get_flags(krb5_context kcontext, krb5_preauthtype patype)\n{\n    if (patype == KRB5_PADATA_PKINIT_KX)\n        return PA_INFO;\n    return PA_SUFFICIENT | PA_REPLACES_KEY | PA_TYPED_E_DATA;\n}\n\nstatic krb5_preauthtype supported_server_pa_types[] = {\n    KRB5_PADATA_PK_AS_REQ,\n    KRB5_PADATA_PK_AS_REQ_OLD,\n    KRB5_PADATA_PK_AS_REP_OLD,\n    KRB5_PADATA_PKINIT_KX,\n    0\n};\n\nstatic void\npkinit_fini_kdc_profile(krb5_context context, pkinit_kdc_context plgctx)\n{\n    /*\n     * There is nothing currently allocated by pkinit_init_kdc_profile()\n     * which needs to be freed here.\n     */\n}\n\nstatic krb5_error_code\npkinit_init_kdc_profile(krb5_context context, pkinit_kdc_context plgctx)\n{\n    krb5_error_code retval;\n    char *eku_string = NULL;\n\n    pkiDebug(\"%s: entered for realm %s\\n\", __FUNCTION__, plgctx->realmname);\n    retval = pkinit_kdcdefault_string(context, plgctx->realmname,\n                                      KRB5_CONF_PKINIT_IDENTITY,\n                                      &plgctx->idopts->identity);\n    if (retval != 0 || NULL == plgctx->idopts->identity) {\n        retval = EINVAL;\n        krb5_set_error_message(context, retval,\n                               _(\"No pkinit_identity supplied for realm %s\"),\n                               plgctx->realmname);\n        goto errout;\n    }\n\n    retval = pkinit_kdcdefault_strings(context, plgctx->realmname,\n                                       KRB5_CONF_PKINIT_ANCHORS,\n                                       &plgctx->idopts->anchors);\n    if (retval != 0 || NULL == plgctx->idopts->anchors) {\n        retval = EINVAL;\n        krb5_set_error_message(context, retval,\n                               _(\"No pkinit_anchors supplied for realm %s\"),\n                               plgctx->realmname);\n        goto errout;\n    }\n\n    pkinit_kdcdefault_strings(context, plgctx->realmname,\n                              KRB5_CONF_PKINIT_POOL,\n                              &plgctx->idopts->intermediates);\n\n    pkinit_kdcdefault_strings(context, plgctx->realmname,\n                              KRB5_CONF_PKINIT_REVOKE,\n                              &plgctx->idopts->crls);\n\n    pkinit_kdcdefault_string(context, plgctx->realmname,\n                             KRB5_CONF_PKINIT_KDC_OCSP,\n                             &plgctx->idopts->ocsp);\n\n    pkinit_kdcdefault_string(context, plgctx->realmname,\n                             KRB5_CONF_PKINIT_MAPPING_FILE,\n                             &plgctx->idopts->dn_mapping_file);\n\n    pkinit_kdcdefault_integer(context, plgctx->realmname,\n                              KRB5_CONF_PKINIT_DH_MIN_BITS,\n                              PKINIT_DEFAULT_DH_MIN_BITS,\n                              &plgctx->opts->dh_min_bits);\n    if (plgctx->opts->dh_min_bits < PKINIT_DEFAULT_DH_MIN_BITS) {\n        pkiDebug(\"%s: invalid value (%d) for pkinit_dh_min_bits, \"\n                 \"using default value (%d) instead\\n\", __FUNCTION__,\n                 plgctx->opts->dh_min_bits, PKINIT_DEFAULT_DH_MIN_BITS);\n        plgctx->opts->dh_min_bits = PKINIT_DEFAULT_DH_MIN_BITS;\n    }\n\n    pkinit_kdcdefault_boolean(context, plgctx->realmname,\n                              KRB5_CONF_PKINIT_ALLOW_UPN,\n                              0, &plgctx->opts->allow_upn);\n\n    pkinit_kdcdefault_boolean(context, plgctx->realmname,\n                              KRB5_CONF_PKINIT_REQUIRE_CRL_CHECKING,\n                              0, &plgctx->opts->require_crl_checking);\n\n    pkinit_kdcdefault_string(context, plgctx->realmname,\n                             KRB5_CONF_PKINIT_EKU_CHECKING,\n                             &eku_string);\n    if (eku_string != NULL) {\n        if (strcasecmp(eku_string, \"kpClientAuth\") == 0) {\n            plgctx->opts->require_eku = 1;\n            plgctx->opts->accept_secondary_eku = 0;\n        } else if (strcasecmp(eku_string, \"scLogin\") == 0) {\n            plgctx->opts->require_eku = 1;\n            plgctx->opts->accept_secondary_eku = 1;\n        } else if (strcasecmp(eku_string, \"none\") == 0) {\n            plgctx->opts->require_eku = 0;\n            plgctx->opts->accept_secondary_eku = 0;\n        } else {\n            pkiDebug(\"%s: Invalid value for pkinit_eku_checking: '%s'\\n\",\n                     __FUNCTION__, eku_string);\n        }\n        free(eku_string);\n    }\n\n\n    return 0;\nerrout:\n    pkinit_fini_kdc_profile(context, plgctx);\n    return retval;\n}\n\nstatic pkinit_kdc_context\npkinit_find_realm_context(krb5_context context,\n                          krb5_kdcpreauth_moddata moddata,\n                          krb5_principal princ)\n{\n    int i;\n    pkinit_kdc_context *realm_contexts = (pkinit_kdc_context *)moddata;\n\n    if (moddata == NULL)\n        return NULL;\n\n    for (i = 0; realm_contexts[i] != NULL; i++) {\n        pkinit_kdc_context p = realm_contexts[i];\n\n        if ((p->realmname_len == princ->realm.length) &&\n            (strncmp(p->realmname, princ->realm.data, p->realmname_len) == 0)) {\n            pkiDebug(\"%s: returning context at %p for realm '%s'\\n\",\n                     __FUNCTION__, p, p->realmname);\n            return p;\n        }\n    }\n    pkiDebug(\"%s: unable to find realm context for realm '%.*s'\\n\",\n             __FUNCTION__, princ->realm.length, princ->realm.data);\n    return NULL;\n}\n\nstatic int\npkinit_server_plugin_init_realm(krb5_context context, const char *realmname,\n                                pkinit_kdc_context *pplgctx)\n{\n    krb5_error_code retval = ENOMEM;\n    pkinit_kdc_context plgctx = NULL;\n\n    *pplgctx = NULL;\n\n    plgctx = calloc(1, sizeof(*plgctx));\n    if (plgctx == NULL)\n        goto errout;\n\n    pkiDebug(\"%s: initializing context at %p for realm '%s'\\n\",\n             __FUNCTION__, plgctx, realmname);\n    memset(plgctx, 0, sizeof(*plgctx));\n    plgctx->magic = PKINIT_CTX_MAGIC;\n\n    plgctx->realmname = strdup(realmname);\n    if (plgctx->realmname == NULL)\n        goto errout;\n    plgctx->realmname_len = strlen(plgctx->realmname);\n\n    retval = pkinit_init_plg_crypto(&plgctx->cryptoctx);\n    if (retval)\n        goto errout;\n\n    retval = pkinit_init_plg_opts(&plgctx->opts);\n    if (retval)\n        goto errout;\n\n    retval = pkinit_init_identity_crypto(&plgctx->idctx);\n    if (retval)\n        goto errout;\n\n    retval = pkinit_init_identity_opts(&plgctx->idopts);\n    if (retval)\n        goto errout;\n\n    retval = pkinit_init_kdc_profile(context, plgctx);\n    if (retval)\n        goto errout;\n\n    retval = pkinit_identity_initialize(context, plgctx->cryptoctx, NULL,\n                                        plgctx->idopts, plgctx->idctx, 0, NULL);\n    if (retval)\n        goto errout;\n\n    pkiDebug(\"%s: returning context at %p for realm '%s'\\n\",\n             __FUNCTION__, plgctx, realmname);\n    *pplgctx = plgctx;\n    retval = 0;\n\nerrout:\n    if (retval)\n        pkinit_server_plugin_fini_realm(context, plgctx);\n\n    return retval;\n}\n\nstatic int\npkinit_server_plugin_init(krb5_context context,\n                          krb5_kdcpreauth_moddata *moddata_out,\n                          const char **realmnames)\n{\n    krb5_error_code retval = ENOMEM;\n    pkinit_kdc_context plgctx, *realm_contexts = NULL;\n    size_t  i, j;\n    size_t numrealms;\n\n    retval = pkinit_accessor_init();\n    if (retval)\n        return retval;\n\n    /* Determine how many realms we may need to support */\n    for (i = 0; realmnames[i] != NULL; i++) {};\n    numrealms = i;\n\n    realm_contexts = calloc(numrealms+1, sizeof(pkinit_kdc_context));\n    if (realm_contexts == NULL)\n        return ENOMEM;\n\n    for (i = 0, j = 0; i < numrealms; i++) {\n        pkiDebug(\"%s: processing realm '%s'\\n\", __FUNCTION__, realmnames[i]);\n        retval = pkinit_server_plugin_init_realm(context, realmnames[i], &plgctx);\n        if (retval == 0 && plgctx != NULL)\n            realm_contexts[j++] = plgctx;\n    }\n\n    if (j == 0) {\n        retval = EINVAL;\n        krb5_set_error_message(context, retval,\n                               _(\"No realms configured correctly for pkinit \"\n                                 \"support\"));\n        goto errout;\n    }\n\n    *moddata_out = (krb5_kdcpreauth_moddata)realm_contexts;\n    retval = 0;\n    pkiDebug(\"%s: returning context at %p\\n\", __FUNCTION__, realm_contexts);\n\nerrout:\n    if (retval) {\n        pkinit_server_plugin_fini(context,\n                                  (krb5_kdcpreauth_moddata)realm_contexts);\n    }\n\n    return retval;\n}\n\nstatic void\npkinit_server_plugin_fini_realm(krb5_context context, pkinit_kdc_context plgctx)\n{\n    if (plgctx == NULL)\n        return;\n\n    pkinit_fini_kdc_profile(context, plgctx);\n    pkinit_fini_identity_opts(plgctx->idopts);\n    pkinit_fini_identity_crypto(plgctx->idctx);\n    pkinit_fini_plg_crypto(plgctx->cryptoctx);\n    pkinit_fini_plg_opts(plgctx->opts);\n    free(plgctx->realmname);\n    free(plgctx);\n}\n\nstatic void\npkinit_server_plugin_fini(krb5_context context,\n                          krb5_kdcpreauth_moddata moddata)\n{\n    pkinit_kdc_context *realm_contexts = (pkinit_kdc_context *)moddata;\n    int i;\n\n    if (realm_contexts == NULL)\n        return;\n\n    for (i = 0; realm_contexts[i] != NULL; i++) {\n        pkinit_server_plugin_fini_realm(context, realm_contexts[i]);\n    }\n    pkiDebug(\"%s: freeing   context at %p\\n\", __FUNCTION__, realm_contexts);\n    free(realm_contexts);\n}\n\nstatic krb5_error_code\npkinit_init_kdc_req_context(krb5_context context, pkinit_kdc_req_context *ctx)\n{\n    krb5_error_code retval = ENOMEM;\n    pkinit_kdc_req_context reqctx = NULL;\n\n    reqctx = malloc(sizeof(*reqctx));\n    if (reqctx == NULL)\n        return retval;\n    memset(reqctx, 0, sizeof(*reqctx));\n    reqctx->magic = PKINIT_CTX_MAGIC;\n\n    retval = pkinit_init_req_crypto(&reqctx->cryptoctx);\n    if (retval)\n        goto cleanup;\n    reqctx->rcv_auth_pack = NULL;\n    reqctx->rcv_auth_pack9 = NULL;\n\n    pkiDebug(\"%s: returning reqctx at %p\\n\", __FUNCTION__, reqctx);\n    *ctx = reqctx;\n    retval = 0;\ncleanup:\n    if (retval)\n        pkinit_fini_kdc_req_context(context, reqctx);\n\n    return retval;\n}\n\nstatic void\npkinit_fini_kdc_req_context(krb5_context context, void *ctx)\n{\n    pkinit_kdc_req_context reqctx = (pkinit_kdc_req_context)ctx;\n\n    if (reqctx == NULL || reqctx->magic != PKINIT_CTX_MAGIC) {\n        pkiDebug(\"pkinit_fini_kdc_req_context: got bad reqctx (%p)!\\n\", reqctx);\n        return;\n    }\n    pkiDebug(\"%s: freeing   reqctx at %p\\n\", __FUNCTION__, reqctx);\n\n    pkinit_fini_req_crypto(reqctx->cryptoctx);\n    if (reqctx->rcv_auth_pack != NULL)\n        free_krb5_auth_pack(&reqctx->rcv_auth_pack);\n    if (reqctx->rcv_auth_pack9 != NULL)\n        free_krb5_auth_pack_draft9(context, &reqctx->rcv_auth_pack9);\n\n    free(reqctx);\n}\n\nkrb5_error_code\nkdcpreauth_pkinit_initvt(krb5_context context, int maj_ver, int min_ver,\n                         krb5_plugin_vtable vtable);\n\nkrb5_error_code\nkdcpreauth_pkinit_initvt(krb5_context context, int maj_ver, int min_ver,\n                         krb5_plugin_vtable vtable)\n{\n    krb5_kdcpreauth_vtable vt;\n\n    if (maj_ver != 1)\n        return KRB5_PLUGIN_VER_NOTSUPP;\n    vt = (krb5_kdcpreauth_vtable)vtable;\n    vt->name = \"pkinit\";\n    vt->pa_type_list = supported_server_pa_types;\n    vt->init = pkinit_server_plugin_init;\n    vt->fini = pkinit_server_plugin_fini;\n    vt->flags = pkinit_server_get_flags;\n    vt->edata = pkinit_server_get_edata;\n    vt->verify = pkinit_server_verify_padata;\n    vt->return_padata = pkinit_server_return_padata;\n    return 0;\n}\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * COPYRIGHT (C) 2006,2007\n * THE REGENTS OF THE UNIVERSITY OF MICHIGAN\n * ALL RIGHTS RESERVED\n *\n * Permission is granted to use, copy, create derivative works\n * and redistribute this software and such derivative works\n * for any purpose, so long as the name of The University of\n * Michigan is not used in any advertising or publicity\n * pertaining to the use of distribution of this software\n * without specific, written prior authorization.  If the\n * above copyright notice or any other identification of the\n * University of Michigan is included in any copy of any\n * portion of this software, then the disclaimer below must\n * also be included.\n *\n * THIS SOFTWARE IS PROVIDED AS IS, WITHOUT REPRESENTATION\n * FROM THE UNIVERSITY OF MICHIGAN AS TO ITS FITNESS FOR ANY\n * PURPOSE, AND WITHOUT WARRANTY BY THE UNIVERSITY OF\n * MICHIGAN OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING\n * WITHOUT LIMITATION THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE\n * REGENTS OF THE UNIVERSITY OF MICHIGAN SHALL NOT BE LIABLE\n * FOR ANY DAMAGES, INCLUDING SPECIAL, INDIRECT, INCIDENTAL, OR\n * CONSEQUENTIAL DAMAGES, WITH RESPECT TO ANY CLAIM ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OF THE SOFTWARE, EVEN\n * IF IT HAS BEEN OR IS HEREAFTER ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGES.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n\n#include <k5-int.h>\n#include \"pkinit.h\"\n\nstatic krb5_error_code\npkinit_init_kdc_req_context(krb5_context, pkinit_kdc_req_context *blob);\n\nstatic void\npkinit_fini_kdc_req_context(krb5_context context, void *blob);\n\nstatic void\npkinit_server_plugin_fini_realm(krb5_context context,\n                                pkinit_kdc_context plgctx);\n\nstatic void\npkinit_server_plugin_fini(krb5_context context,\n                          krb5_kdcpreauth_moddata moddata);\n\nstatic pkinit_kdc_context\npkinit_find_realm_context(krb5_context context,\n                          krb5_kdcpreauth_moddata moddata,\n                          krb5_principal princ);\n\nstatic krb5_error_code\npkinit_create_edata(krb5_context context,\n                    pkinit_plg_crypto_context plg_cryptoctx,\n                    pkinit_req_crypto_context req_cryptoctx,\n                    pkinit_identity_crypto_context id_cryptoctx,\n                    pkinit_plg_opts *opts,\n                    krb5_error_code err_code,\n                    krb5_pa_data ***e_data_out)\n{\n    krb5_error_code retval = KRB5KRB_ERR_GENERIC;\n\n    pkiDebug(\"pkinit_create_edata: creating edata for error %d (%s)\\n\",\n             err_code, error_message(err_code));\n    switch(err_code) {\n    case KRB5KDC_ERR_CANT_VERIFY_CERTIFICATE:\n        retval = pkinit_create_td_trusted_certifiers(context,\n                                                     plg_cryptoctx, req_cryptoctx, id_cryptoctx, e_data_out);\n        break;\n    case KRB5KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED:\n        retval = pkinit_create_td_dh_parameters(context, plg_cryptoctx,\n                                                req_cryptoctx, id_cryptoctx, opts, e_data_out);\n        break;\n    case KRB5KDC_ERR_INVALID_CERTIFICATE:\n    case KRB5KDC_ERR_REVOKED_CERTIFICATE:\n        retval = pkinit_create_td_invalid_certificate(context,\n                                                      plg_cryptoctx, req_cryptoctx, id_cryptoctx, e_data_out);\n        break;\n    default:\n        pkiDebug(\"no edata needed for error %d (%s)\\n\",\n                 err_code, error_message(err_code));\n        retval = 0;\n        goto cleanup;\n    }\n\ncleanup:\n\n    return retval;\n}\n\nstatic void\npkinit_server_get_edata(krb5_context context,\n                        krb5_kdc_req *request,\n                        krb5_kdcpreauth_callbacks cb,\n                        krb5_kdcpreauth_rock rock,\n                        krb5_kdcpreauth_moddata moddata,\n                        krb5_preauthtype pa_type,\n                        krb5_kdcpreauth_edata_respond_fn respond,\n                        void *arg)\n{\n    krb5_error_code retval = 0;\n    pkinit_kdc_context plgctx = NULL;\n\n    pkiDebug(\"pkinit_server_get_edata: entered!\\n\");\n\n\n    /*\n     * If we don't have a realm context for the given realm,\n     * don't tell the client that we support pkinit!\n     */\n    plgctx = pkinit_find_realm_context(context, moddata, request->server);\n    if (plgctx == NULL)\n        retval = EINVAL;\n\n    (*respond)(arg, retval, NULL);\n}\n\nstatic krb5_error_code\nverify_client_san(krb5_context context,\n                  pkinit_kdc_context plgctx,\n                  pkinit_kdc_req_context reqctx,\n                  krb5_principal client,\n                  int *valid_san)\n{\n    krb5_error_code retval;\n    krb5_principal *princs = NULL;\n    krb5_principal *upns = NULL;\n    int i;\n#ifdef DEBUG_SAN_INFO\n    char *client_string = NULL, *san_string;\n#endif\n\n    retval = crypto_retrieve_cert_sans(context, plgctx->cryptoctx,\n                                       reqctx->cryptoctx, plgctx->idctx,\n                                       &princs,\n                                       plgctx->opts->allow_upn ? &upns : NULL,\n                                       NULL);\n    if (retval) {\n        pkiDebug(\"%s: error from retrieve_certificate_sans()\\n\", __FUNCTION__);\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n        goto out;\n    }\n    /* XXX Verify this is consistent with client side XXX */\n#if 0\n    retval = call_san_checking_plugins(context, plgctx, reqctx, princs,\n                                       upns, NULL, &plugin_decision, &ignore);\n    pkiDebug(\"%s: call_san_checking_plugins() returned retval %d\\n\",\n             __FUNCTION__);\n    if (retval) {\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n        goto cleanup;\n    }\n    pkiDebug(\"%s: call_san_checking_plugins() returned decision %d\\n\",\n             __FUNCTION__, plugin_decision);\n    if (plugin_decision != NO_DECISION) {\n        retval = plugin_decision;\n        goto out;\n    }\n#endif\n\n#ifdef DEBUG_SAN_INFO\n    krb5_unparse_name(context, client, &client_string);\n#endif\n    pkiDebug(\"%s: Checking pkinit sans\\n\", __FUNCTION__);\n    for (i = 0; princs != NULL && princs[i] != NULL; i++) {\n#ifdef DEBUG_SAN_INFO\n        krb5_unparse_name(context, princs[i], &san_string);\n        pkiDebug(\"%s: Comparing client '%s' to pkinit san value '%s'\\n\",\n                 __FUNCTION__, client_string, san_string);\n        krb5_free_unparsed_name(context, san_string);\n#endif\n        if (krb5_principal_compare(context, princs[i], client)) {\n            pkiDebug(\"%s: pkinit san match found\\n\", __FUNCTION__);\n            *valid_san = 1;\n            retval = 0;\n            goto out;\n        }\n    }\n    pkiDebug(\"%s: no pkinit san match found\\n\", __FUNCTION__);\n    /*\n     * XXX if cert has names but none match, should we\n     * be returning KRB5KDC_ERR_CLIENT_NAME_MISMATCH here?\n     */\n\n    if (upns == NULL) {\n        pkiDebug(\"%s: no upn sans (or we wouldn't accept them anyway)\\n\",\n                 __FUNCTION__);\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n        goto out;\n    }\n\n    pkiDebug(\"%s: Checking upn sans\\n\", __FUNCTION__);\n    for (i = 0; upns[i] != NULL; i++) {\n#ifdef DEBUG_SAN_INFO\n        krb5_unparse_name(context, upns[i], &san_string);\n        pkiDebug(\"%s: Comparing client '%s' to upn san value '%s'\\n\",\n                 __FUNCTION__, client_string, san_string);\n        krb5_free_unparsed_name(context, san_string);\n#endif\n        if (krb5_principal_compare(context, upns[i], client)) {\n            pkiDebug(\"%s: upn san match found\\n\", __FUNCTION__);\n            *valid_san = 1;\n            retval = 0;\n            goto out;\n        }\n    }\n    pkiDebug(\"%s: no upn san match found\\n\", __FUNCTION__);\n\n    /* We found no match */\n    if (princs != NULL || upns != NULL) {\n        *valid_san = 0;\n        /* XXX ??? If there was one or more name in the cert, but\n         * none matched the client name, then return mismatch? */\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n    }\n    retval = 0;\n\nout:\n    if (princs != NULL) {\n        for (i = 0; princs[i] != NULL; i++)\n            krb5_free_principal(context, princs[i]);\n        free(princs);\n    }\n    if (upns != NULL) {\n        for (i = 0; upns[i] != NULL; i++)\n            krb5_free_principal(context, upns[i]);\n        free(upns);\n    }\n#ifdef DEBUG_SAN_INFO\n    if (client_string != NULL)\n        krb5_free_unparsed_name(context, client_string);\n#endif\n    pkiDebug(\"%s: returning retval %d, valid_san %d\\n\",\n             __FUNCTION__, retval, *valid_san);\n    return retval;\n}\n\nstatic krb5_error_code\nverify_client_eku(krb5_context context,\n                  pkinit_kdc_context plgctx,\n                  pkinit_kdc_req_context reqctx,\n                  int *eku_accepted)\n{\n    krb5_error_code retval;\n\n    *eku_accepted = 0;\n\n    if (plgctx->opts->require_eku == 0) {\n        pkiDebug(\"%s: configuration requests no EKU checking\\n\", __FUNCTION__);\n        *eku_accepted = 1;\n        retval = 0;\n        goto out;\n    }\n\n    retval = crypto_check_cert_eku(context, plgctx->cryptoctx,\n                                   reqctx->cryptoctx, plgctx->idctx,\n                                   0, /* kdc cert */\n                                   plgctx->opts->accept_secondary_eku,\n                                   eku_accepted);\n    if (retval) {\n        pkiDebug(\"%s: Error from crypto_check_cert_eku %d (%s)\\n\",\n                 __FUNCTION__, retval, error_message(retval));\n        goto out;\n    }\n\nout:\n    pkiDebug(\"%s: returning retval %d, eku_accepted %d\\n\",\n             __FUNCTION__, retval, *eku_accepted);\n    return retval;\n}\n\nstatic void\npkinit_server_verify_padata(krb5_context context,\n                            krb5_data *req_pkt,\n                            krb5_kdc_req * request,\n                            krb5_enc_tkt_part * enc_tkt_reply,\n                            krb5_pa_data * data,\n                            krb5_kdcpreauth_callbacks cb,\n                            krb5_kdcpreauth_rock rock,\n                            krb5_kdcpreauth_moddata moddata,\n                            krb5_kdcpreauth_verify_respond_fn respond,\n                            void *arg)\n{\n    krb5_error_code retval = 0;\n    krb5_octet_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};\n    krb5_pa_pk_as_req *reqp = NULL;\n    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;\n    krb5_auth_pack *auth_pack = NULL;\n    krb5_auth_pack_draft9 *auth_pack9 = NULL;\n    pkinit_kdc_context plgctx = NULL;\n    pkinit_kdc_req_context reqctx = NULL;\n    krb5_checksum cksum = {0, 0, 0, NULL};\n    krb5_data *der_req = NULL;\n    int valid_eku = 0, valid_san = 0;\n    krb5_kdc_req *tmp_as_req = NULL;\n    krb5_data k5data;\n    int is_signed = 1;\n    krb5_pa_data **e_data = NULL;\n    krb5_kdcpreauth_modreq modreq = NULL;\n\n    pkiDebug(\"pkinit_verify_padata: entered!\\n\");\n    if (data == NULL || data->length <= 0 || data->contents == NULL) {\n        (*respond)(arg, 0, NULL, NULL, NULL);\n        return;\n    }\n\n\n    if (moddata == NULL) {\n        (*respond)(arg, EINVAL, NULL, NULL, NULL);\n        return;\n    }\n\n    plgctx = pkinit_find_realm_context(context, moddata, request->server);\n    if (plgctx == NULL) {\n        (*respond)(arg, 0, NULL, NULL, NULL);\n        return;\n    }\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(data->contents, data->length, \"/tmp/kdc_as_req\");\n#endif\n    /* create a per-request context */\n    retval = pkinit_init_kdc_req_context(context, &reqctx);\n    if (retval)\n        goto cleanup;\n    reqctx->pa_type = data->pa_type;\n\n    PADATA_TO_KRB5DATA(data, &k5data);\n\n    switch ((int)data->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        pkiDebug(\"processing KRB5_PADATA_PK_AS_REQ\\n\");\n        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);\n        if (retval) {\n            pkiDebug(\"decode_krb5_pa_pk_as_req failed\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin(reqp->signedAuthPack.data,\n                         reqp->signedAuthPack.length,\n                         \"/tmp/kdc_signed_data\");\n#endif\n        retval = cms_signeddata_verify(context, plgctx->cryptoctx,\n                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,\n                                       plgctx->opts->require_crl_checking,\n                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,\n                                       &authp_data.data, &authp_data.length, &krb5_authz.data,\n                                       &krb5_authz.length, &is_signed);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        pkiDebug(\"processing KRB5_PADATA_PK_AS_REQ_OLD\\n\");\n        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);\n        if (retval) {\n            pkiDebug(\"decode_krb5_pa_pk_as_req_draft9 failed\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin(reqp9->signedAuthPack.data,\n                         reqp9->signedAuthPack.length,\n                         \"/tmp/kdc_signed_data_draft9\");\n#endif\n\n        retval = cms_signeddata_verify(context, plgctx->cryptoctx,\n                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,\n                                       plgctx->opts->require_crl_checking,\n                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,\n                                       &authp_data.data, &authp_data.length, &krb5_authz.data,\n                                       &krb5_authz.length, NULL);\n        break;\n    default:\n        pkiDebug(\"unrecognized pa_type = %d\\n\", data->pa_type);\n        retval = EINVAL;\n        goto cleanup;\n    }\n    if (retval) {\n        pkiDebug(\"pkcs7_signeddata_verify failed\\n\");\n        goto cleanup;\n    }\n    if (is_signed) {\n\n        retval = verify_client_san(context, plgctx, reqctx, request->client,\n                                   &valid_san);\n        if (retval)\n            goto cleanup;\n        if (!valid_san) {\n            pkiDebug(\"%s: did not find an acceptable SAN in user \"\n                     \"certificate\\n\", __FUNCTION__);\n            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n            goto cleanup;\n        }\n        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);\n        if (retval)\n            goto cleanup;\n\n        if (!valid_eku) {\n            pkiDebug(\"%s: did not find an acceptable EKU in user \"\n                     \"certificate\\n\", __FUNCTION__);\n            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;\n            goto cleanup;\n        }\n    } else { /* !is_signed */\n        if (!krb5_principal_compare(context, request->client,\n                                    krb5_anonymous_principal())) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            krb5_set_error_message(context, retval,\n                                   _(\"Pkinit request not signed, but client \"\n                                     \"not anonymous.\"));\n            goto cleanup;\n        }\n    }\n#ifdef DEBUG_ASN1\n    print_buffer_bin(authp_data.data, authp_data.length, \"/tmp/kdc_auth_pack\");\n#endif\n\n    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);\n    switch ((int)data->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);\n        if (retval) {\n            pkiDebug(\"failed to decode krb5_auth_pack\\n\");\n            goto cleanup;\n        }\n\n        /* check dh parameters */\n        if (auth_pack->clientPublicValue != NULL) {\n            retval = server_check_dh(context, plgctx->cryptoctx,\n                                     reqctx->cryptoctx, plgctx->idctx,\n                                     &auth_pack->clientPublicValue->algorithm.parameters,\n                                     plgctx->opts->dh_min_bits);\n\n            if (retval) {\n                pkiDebug(\"bad dh parameters\\n\");\n                goto cleanup;\n            }\n        } else if (!is_signed) {\n            /*Anonymous pkinit requires DH*/\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            krb5_set_error_message(context, retval,\n                                   _(\"Anonymous pkinit without DH public \"\n                                     \"value not supported.\"));\n            goto cleanup;\n        }\n        der_req = cb->request_body(context, rock);\n        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,\n                                      0, der_req, &cksum);\n        if (retval) {\n            pkiDebug(\"unable to calculate AS REQ checksum\\n\");\n            goto cleanup;\n        }\n        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||\n            memcmp(cksum.contents,\n                   auth_pack->pkAuthenticator.paChecksum.contents,\n                   cksum.length)) {\n            pkiDebug(\"failed to match the checksum\\n\");\n#ifdef DEBUG_CKSUM\n            pkiDebug(\"calculating checksum on buf size (%d)\\n\",\n                     req_pkt->length);\n            print_buffer(req_pkt->data, req_pkt->length);\n            pkiDebug(\"received checksum type=%d size=%d \",\n                     auth_pack->pkAuthenticator.paChecksum.checksum_type,\n                     auth_pack->pkAuthenticator.paChecksum.length);\n            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,\n                         auth_pack->pkAuthenticator.paChecksum.length);\n            pkiDebug(\"expected checksum type=%d size=%d \",\n                     cksum.checksum_type, cksum.length);\n            print_buffer(cksum.contents, cksum.length);\n#endif\n\n            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;\n            goto cleanup;\n        }\n\n        /* check if kdcPkId present and match KDC's subjectIdentifier */\n        if (reqp->kdcPkId.data != NULL) {\n            int valid_kdcPkId = 0;\n            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,\n                                           reqctx->cryptoctx, plgctx->idctx,\n                                           reqp->kdcPkId.data, reqp->kdcPkId.length, &valid_kdcPkId);\n            if (retval)\n                goto cleanup;\n            if (!valid_kdcPkId)\n                pkiDebug(\"kdcPkId in AS_REQ does not match KDC's cert\"\n                         \"RFC says to ignore and proceed\\n\");\n\n        }\n        /* remember the decoded auth_pack for verify_padata routine */\n        reqctx->rcv_auth_pack = auth_pack;\n        auth_pack = NULL;\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);\n        if (retval) {\n            pkiDebug(\"failed to decode krb5_auth_pack_draft9\\n\");\n            goto cleanup;\n        }\n        if (auth_pack9->clientPublicValue != NULL) {\n            retval = server_check_dh(context, plgctx->cryptoctx,\n                                     reqctx->cryptoctx, plgctx->idctx,\n                                     &auth_pack9->clientPublicValue->algorithm.parameters,\n                                     plgctx->opts->dh_min_bits);\n\n            if (retval) {\n                pkiDebug(\"bad dh parameters\\n\");\n                goto cleanup;\n            }\n        }\n        /* remember the decoded auth_pack for verify_padata routine */\n        reqctx->rcv_auth_pack9 = auth_pack9;\n        auth_pack9 = NULL;\n        break;\n    }\n\n    /* remember to set the PREAUTH flag in the reply */\n    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n    modreq = (krb5_kdcpreauth_modreq)reqctx;\n    reqctx = NULL;\n\ncleanup:\n    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {\n        pkiDebug(\"pkinit_verify_padata failed: creating e-data\\n\");\n        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,\n                                plgctx->idctx, plgctx->opts, retval, &e_data))\n            pkiDebug(\"pkinit_create_edata failed\\n\");\n    }\n\n    switch ((int)data->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        free_krb5_pa_pk_as_req(&reqp);\n        free(cksum.contents);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        free_krb5_pa_pk_as_req_draft9(&reqp9);\n    }\n    if (tmp_as_req != NULL)\n        k5int_krb5_free_kdc_req(context, tmp_as_req);\n    free(authp_data.data);\n    free(krb5_authz.data);\n    if (reqctx != NULL)\n        pkinit_fini_kdc_req_context(context, reqctx);\n    if (auth_pack != NULL)\n        free_krb5_auth_pack(&auth_pack);\n    if (auth_pack9 != NULL)\n        free_krb5_auth_pack_draft9(context, &auth_pack9);\n\n    (*respond)(arg, retval, modreq, e_data, NULL);\n}\nstatic krb5_error_code\nreturn_pkinit_kx(krb5_context context, krb5_kdc_req *request,\n                 krb5_kdc_rep *reply, krb5_keyblock *encrypting_key,\n                 krb5_pa_data **out_padata)\n{\n    krb5_error_code ret = 0;\n    krb5_keyblock *session = reply->ticket->enc_part2->session;\n    krb5_keyblock *new_session = NULL;\n    krb5_pa_data *pa = NULL;\n    krb5_enc_data enc;\n    krb5_data *scratch = NULL;\n\n    *out_padata = NULL;\n    enc.ciphertext.data = NULL;\n    if (!krb5_principal_compare(context, request->client,\n                                krb5_anonymous_principal()))\n        return 0;\n    /*\n     * The KDC contribution key needs to be a fresh key of an enctype supported\n     * by the client and server. The existing session key meets these\n     * requirements so we use it.\n     */\n    ret = krb5_c_fx_cf2_simple(context, session, \"PKINIT\",\n                               encrypting_key, \"KEYEXCHANGE\",\n                               &new_session);\n    if (ret)\n        goto cleanup;\n    ret = encode_krb5_encryption_key( session, &scratch);\n    if (ret)\n        goto cleanup;\n    ret = krb5_encrypt_helper(context, encrypting_key,\n                              KRB5_KEYUSAGE_PA_PKINIT_KX, scratch, &enc);\n    if (ret)\n        goto cleanup;\n    memset(scratch->data, 0, scratch->length);\n    krb5_free_data(context, scratch);\n    scratch = NULL;\n    ret = encode_krb5_enc_data(&enc, &scratch);\n    if (ret)\n        goto cleanup;\n    pa = malloc(sizeof(krb5_pa_data));\n    if (pa == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n    pa->pa_type = KRB5_PADATA_PKINIT_KX;\n    pa->length = scratch->length;\n    pa->contents = (krb5_octet *) scratch->data;\n    *out_padata = pa;\n    scratch->data = NULL;\n    memset(session->contents, 0, session->length);\n    krb5_free_keyblock_contents(context, session);\n    *session = *new_session;\n    new_session->contents = NULL;\ncleanup:\n    krb5_free_data_contents(context, &enc.ciphertext);\n    krb5_free_keyblock(context, new_session);\n    krb5_free_data(context, scratch);\n    return ret;\n}\n\nstatic krb5_error_code\npkinit_pick_kdf_alg(krb5_context context,\n                    krb5_octet_data **kdf_list,\n                    krb5_octet_data **alg_oid)\n{\n    krb5_error_code retval = 0;\n    krb5_octet_data *req_oid = NULL;\n    const krb5_octet_data *supp_oid = NULL;\n    krb5_octet_data *tmp_oid = NULL;\n    int i, j = 0;\n\n    /* if we don't find a match, return NULL value */\n    *alg_oid = NULL;\n\n    /* for each of the OIDs that the server supports... */\n    for (i = 0; NULL != (supp_oid = supported_kdf_alg_ids[i]); i++) {\n        /* if the requested OID is in the client's list, use it. */\n        for (j = 0; NULL != (req_oid = kdf_list[j]); j++) {\n            if ((req_oid->length == supp_oid->length) &&\n                (0 == memcmp(req_oid->data, supp_oid->data, req_oid->length))) {\n                tmp_oid = k5alloc(sizeof(krb5_octet_data), &retval);\n                if (retval)\n                    goto cleanup;\n                tmp_oid->data = k5alloc(supp_oid->length, &retval);\n                if (retval)\n                    goto cleanup;\n                tmp_oid->length = supp_oid->length;\n                memcpy(tmp_oid->data, supp_oid->data, tmp_oid->length);\n                *alg_oid = tmp_oid;\n                /* don't free the OID in clean-up if we are returning it */\n                tmp_oid = NULL;\n                goto cleanup;\n            }\n        }\n    }\ncleanup:\n    if (tmp_oid)\n        krb5_free_octet_data(context, tmp_oid);\n    return retval;\n}\n\nstatic krb5_error_code\npkinit_server_return_padata(krb5_context context,\n                            krb5_pa_data * padata,\n                            krb5_data *req_pkt,\n                            krb5_kdc_req * request,\n                            krb5_kdc_rep * reply,\n                            krb5_keyblock * encrypting_key,\n                            krb5_pa_data ** send_pa,\n                            krb5_kdcpreauth_callbacks cb,\n                            krb5_kdcpreauth_rock rock,\n                            krb5_kdcpreauth_moddata moddata,\n                            krb5_kdcpreauth_modreq modreq)\n{\n    krb5_error_code retval = 0;\n    krb5_data scratch = {0, 0, NULL};\n    krb5_pa_pk_as_req *reqp = NULL;\n    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;\n    int i = 0;\n\n    unsigned char *subjectPublicKey = NULL;\n    unsigned char *dh_pubkey = NULL, *server_key = NULL;\n    unsigned int subjectPublicKey_len = 0;\n    unsigned int server_key_len = 0, dh_pubkey_len = 0;\n\n    krb5_kdc_dh_key_info dhkey_info;\n    krb5_data *encoded_dhkey_info = NULL;\n    krb5_pa_pk_as_rep *rep = NULL;\n    krb5_pa_pk_as_rep_draft9 *rep9 = NULL;\n    krb5_data *out_data = NULL;\n    krb5_octet_data secret;\n\n    krb5_enctype enctype = -1;\n\n    krb5_reply_key_pack *key_pack = NULL;\n    krb5_reply_key_pack_draft9 *key_pack9 = NULL;\n    krb5_data *encoded_key_pack = NULL;\n\n    pkinit_kdc_context plgctx;\n    pkinit_kdc_req_context reqctx;\n\n    int fixed_keypack = 0;\n\n    *send_pa = NULL;\n    if (padata->pa_type == KRB5_PADATA_PKINIT_KX) {\n        return return_pkinit_kx(context, request, reply,\n                                encrypting_key, send_pa);\n    }\n    if (padata->length <= 0 || padata->contents == NULL)\n        return 0;\n\n    if (modreq == NULL) {\n        pkiDebug(\"missing request context \\n\");\n        return EINVAL;\n    }\n\n    plgctx = pkinit_find_realm_context(context, moddata, request->server);\n    if (plgctx == NULL) {\n        pkiDebug(\"Unable to locate correct realm context\\n\");\n        return ENOENT;\n    }\n\n    pkiDebug(\"pkinit_return_padata: entered!\\n\");\n    reqctx = (pkinit_kdc_req_context)modreq;\n\n    if (encrypting_key->contents) {\n        free(encrypting_key->contents);\n        encrypting_key->length = 0;\n        encrypting_key->contents = NULL;\n    }\n\n    for(i = 0; i < request->nktypes; i++) {\n        enctype = request->ktype[i];\n        if (!krb5_c_valid_enctype(enctype))\n            continue;\n        else {\n            pkiDebug(\"KDC picked etype = %d\\n\", enctype);\n            break;\n        }\n    }\n\n    if (i == request->nktypes) {\n        retval = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto cleanup;\n    }\n\n    switch((int)reqctx->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        init_krb5_pa_pk_as_rep(&rep);\n        if (rep == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        /* let's assume it's RSA. we'll reset it to DH if needed */\n        rep->choice = choice_pa_pk_as_rep_encKeyPack;\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        init_krb5_pa_pk_as_rep_draft9(&rep9);\n        if (rep9 == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        rep9->choice = choice_pa_pk_as_rep_draft9_encKeyPack;\n        break;\n    default:\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        goto cleanup;\n    }\n\n    if (reqctx->rcv_auth_pack != NULL &&\n        reqctx->rcv_auth_pack->clientPublicValue != NULL) {\n        subjectPublicKey =\n            reqctx->rcv_auth_pack->clientPublicValue->subjectPublicKey.data;\n        subjectPublicKey_len =\n            reqctx->rcv_auth_pack->clientPublicValue->subjectPublicKey.length;\n        rep->choice = choice_pa_pk_as_rep_dhInfo;\n    } else if (reqctx->rcv_auth_pack9 != NULL &&\n               reqctx->rcv_auth_pack9->clientPublicValue != NULL) {\n        subjectPublicKey =\n            reqctx->rcv_auth_pack9->clientPublicValue->subjectPublicKey.data;\n        subjectPublicKey_len =\n            reqctx->rcv_auth_pack9->clientPublicValue->subjectPublicKey.length;\n        rep9->choice = choice_pa_pk_as_rep_draft9_dhSignedData;\n    }\n\n    /* if this DH, then process finish computing DH key */\n    if (rep != NULL && (rep->choice == choice_pa_pk_as_rep_dhInfo ||\n                        rep->choice == choice_pa_pk_as_rep_draft9_dhSignedData)) {\n        pkiDebug(\"received DH key delivery AS REQ\\n\");\n        retval = server_process_dh(context, plgctx->cryptoctx,\n                                   reqctx->cryptoctx, plgctx->idctx, subjectPublicKey,\n                                   subjectPublicKey_len, &dh_pubkey, &dh_pubkey_len,\n                                   &server_key, &server_key_len);\n        if (retval) {\n            pkiDebug(\"failed to process/create dh paramters\\n\");\n            goto cleanup;\n        }\n    }\n    if ((rep9 != NULL &&\n         rep9->choice == choice_pa_pk_as_rep_draft9_dhSignedData) ||\n        (rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo)) {\n\n        /*\n         * This is DH, so don't generate the key until after we\n         * encode the reply, because the encoded reply is needed\n         * to generate the key in some cases.\n         */\n\n        dhkey_info.subjectPublicKey.length = dh_pubkey_len;\n        dhkey_info.subjectPublicKey.data = dh_pubkey;\n        dhkey_info.nonce = request->nonce;\n        dhkey_info.dhKeyExpiration = 0;\n\n        retval = k5int_encode_krb5_kdc_dh_key_info(&dhkey_info,\n                                                   &encoded_dhkey_info);\n        if (retval) {\n            pkiDebug(\"encode_krb5_kdc_dh_key_info failed\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin((unsigned char *)encoded_dhkey_info->data,\n                         encoded_dhkey_info->length,\n                         \"/tmp/kdc_dh_key_info\");\n#endif\n\n        switch ((int)padata->pa_type) {\n        case KRB5_PADATA_PK_AS_REQ:\n            retval = cms_signeddata_create(context, plgctx->cryptoctx,\n                                           reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_SERVER, 1,\n                                           (unsigned char *)encoded_dhkey_info->data,\n                                           encoded_dhkey_info->length,\n                                           &rep->u.dh_Info.dhSignedData.data,\n                                           &rep->u.dh_Info.dhSignedData.length);\n            if (retval) {\n                pkiDebug(\"failed to create pkcs7 signed data\\n\");\n                goto cleanup;\n            }\n            break;\n        case KRB5_PADATA_PK_AS_REP_OLD:\n        case KRB5_PADATA_PK_AS_REQ_OLD:\n            retval = cms_signeddata_create(context, plgctx->cryptoctx,\n                                           reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9, 1,\n                                           (unsigned char *)encoded_dhkey_info->data,\n                                           encoded_dhkey_info->length,\n                                           &rep9->u.dhSignedData.data,\n                                           &rep9->u.dhSignedData.length);\n            if (retval) {\n                pkiDebug(\"failed to create pkcs7 signed data\\n\");\n                goto cleanup;\n            }\n            break;\n        }\n\n    } else {\n        pkiDebug(\"received RSA key delivery AS REQ\\n\");\n\n        retval = krb5_c_make_random_key(context, enctype, encrypting_key);\n        if (retval) {\n            pkiDebug(\"unable to make a session key\\n\");\n            goto cleanup;\n        }\n\n        /* check if PA_TYPE of 132 is present which means the client is\n         * requesting that a checksum is send back instead of the nonce\n         */\n        for (i = 0; request->padata[i] != NULL; i++) {\n            pkiDebug(\"%s: Checking pa_type 0x%08x\\n\",\n                     __FUNCTION__, request->padata[i]->pa_type);\n            if (request->padata[i]->pa_type == 132)\n                fixed_keypack = 1;\n        }\n        pkiDebug(\"%s: return checksum instead of nonce = %d\\n\",\n                 __FUNCTION__, fixed_keypack);\n\n        /* if this is an RFC reply or draft9 client requested a checksum\n         * in the reply instead of the nonce, create an RFC-style keypack\n         */\n        if ((int)padata->pa_type == KRB5_PADATA_PK_AS_REQ || fixed_keypack) {\n            init_krb5_reply_key_pack(&key_pack);\n            if (key_pack == NULL) {\n                retval = ENOMEM;\n                goto cleanup;\n            }\n\n            retval = krb5_c_make_checksum(context, 0,\n                                          encrypting_key, KRB5_KEYUSAGE_TGS_REQ_AUTH_CKSUM,\n                                          req_pkt, &key_pack->asChecksum);\n            if (retval) {\n                pkiDebug(\"unable to calculate AS REQ checksum\\n\");\n                goto cleanup;\n            }\n#ifdef DEBUG_CKSUM\n            pkiDebug(\"calculating checksum on buf size = %d\\n\", req_pkt->length);\n            print_buffer(req_pkt->data, req_pkt->length);\n            pkiDebug(\"checksum size = %d\\n\", key_pack->asChecksum.length);\n            print_buffer(key_pack->asChecksum.contents,\n                         key_pack->asChecksum.length);\n            pkiDebug(\"encrypting key (%d)\\n\", encrypting_key->length);\n            print_buffer(encrypting_key->contents, encrypting_key->length);\n#endif\n\n            krb5_copy_keyblock_contents(context, encrypting_key,\n                                        &key_pack->replyKey);\n\n            retval = k5int_encode_krb5_reply_key_pack(key_pack,\n                                                      &encoded_key_pack);\n            if (retval) {\n                pkiDebug(\"failed to encode reply_key_pack\\n\");\n                goto cleanup;\n            }\n        }\n\n        switch ((int)padata->pa_type) {\n        case KRB5_PADATA_PK_AS_REQ:\n            rep->choice = choice_pa_pk_as_rep_encKeyPack;\n            retval = cms_envelopeddata_create(context, plgctx->cryptoctx,\n                                              reqctx->cryptoctx, plgctx->idctx, padata->pa_type, 1,\n                                              (unsigned char *)encoded_key_pack->data,\n                                              encoded_key_pack->length,\n                                              &rep->u.encKeyPack.data, &rep->u.encKeyPack.length);\n            break;\n        case KRB5_PADATA_PK_AS_REP_OLD:\n        case KRB5_PADATA_PK_AS_REQ_OLD:\n            /* if the request is from the broken draft9 client that\n             * expects back a nonce, create it now\n             */\n            if (!fixed_keypack) {\n                init_krb5_reply_key_pack_draft9(&key_pack9);\n                if (key_pack9 == NULL) {\n                    retval = ENOMEM;\n                    goto cleanup;\n                }\n                key_pack9->nonce = reqctx->rcv_auth_pack9->pkAuthenticator.nonce;\n                krb5_copy_keyblock_contents(context, encrypting_key,\n                                            &key_pack9->replyKey);\n\n                retval = k5int_encode_krb5_reply_key_pack_draft9(key_pack9,\n                                                                 &encoded_key_pack);\n                if (retval) {\n                    pkiDebug(\"failed to encode reply_key_pack\\n\");\n                    goto cleanup;\n                }\n            }\n\n            rep9->choice = choice_pa_pk_as_rep_draft9_encKeyPack;\n            retval = cms_envelopeddata_create(context, plgctx->cryptoctx,\n                                              reqctx->cryptoctx, plgctx->idctx, padata->pa_type, 1,\n                                              (unsigned char *)encoded_key_pack->data,\n                                              encoded_key_pack->length,\n                                              &rep9->u.encKeyPack.data, &rep9->u.encKeyPack.length);\n            break;\n        }\n        if (retval) {\n            pkiDebug(\"failed to create pkcs7 enveloped data: %s\\n\",\n                     error_message(retval));\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin((unsigned char *)encoded_key_pack->data,\n                         encoded_key_pack->length,\n                         \"/tmp/kdc_key_pack\");\n        switch ((int)padata->pa_type) {\n        case KRB5_PADATA_PK_AS_REQ:\n            print_buffer_bin(rep->u.encKeyPack.data,\n                             rep->u.encKeyPack.length,\n                             \"/tmp/kdc_enc_key_pack\");\n            break;\n        case KRB5_PADATA_PK_AS_REP_OLD:\n        case KRB5_PADATA_PK_AS_REQ_OLD:\n            print_buffer_bin(rep9->u.encKeyPack.data,\n                             rep9->u.encKeyPack.length,\n                             \"/tmp/kdc_enc_key_pack\");\n            break;\n        }\n#endif\n    }\n\n    if ((rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo) &&\n        ((reqctx->rcv_auth_pack != NULL &&\n          reqctx->rcv_auth_pack->supportedKDFs != NULL))) {\n\n        /* If using the alg-agility KDF, put the algorithm in the reply\n         * before encoding it.\n         */\n        if (reqctx->rcv_auth_pack != NULL &&\n            reqctx->rcv_auth_pack->supportedKDFs != NULL) {\n            retval = pkinit_pick_kdf_alg(context, reqctx->rcv_auth_pack->supportedKDFs,\n                                         &(rep->u.dh_Info.kdfID));\n            if (retval) {\n                pkiDebug(\"pkinit_pick_kdf_alg failed: %s\\n\",\n                         error_message(retval));\n                goto cleanup;\n            }\n        }\n    }\n\n    switch ((int)padata->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        retval = k5int_encode_krb5_pa_pk_as_rep(rep, &out_data);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        retval = k5int_encode_krb5_pa_pk_as_rep_draft9(rep9, &out_data);\n        break;\n    }\n    if (retval) {\n        pkiDebug(\"failed to encode AS_REP\\n\");\n        goto cleanup;\n    }\n#ifdef DEBUG_ASN1\n    if (out_data != NULL)\n        print_buffer_bin((unsigned char *)out_data->data, out_data->length,\n                         \"/tmp/kdc_as_rep\");\n#endif\n\n    /* If this is DH, we haven't computed the key yet, so do it now. */\n    if ((rep9 != NULL &&\n         rep9->choice == choice_pa_pk_as_rep_draft9_dhSignedData) ||\n        (rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo)) {\n\n        /* If we're not doing draft 9, and mutually supported KDFs were found,\n         * use the algorithm agility KDF. */\n        if (rep != NULL && rep->u.dh_Info.kdfID) {\n            secret.data = (char *)server_key;\n            secret.length = server_key_len;\n\n            retval = pkinit_alg_agility_kdf(context, &secret,\n                                            rep->u.dh_Info.kdfID,\n                                            request->client, request->server,\n                                            enctype,\n                                            (krb5_octet_data *)req_pkt,\n                                            (krb5_octet_data *)out_data,\n                                            encrypting_key);\n            if (retval) {\n                pkiDebug(\"pkinit_alg_agility_kdf failed: %s\\n\",\n                         error_message(retval));\n                goto cleanup;\n            }\n\n            /* Otherwise, use the older octetstring2key() function */\n        } else {\n            retval = pkinit_octetstring2key(context, enctype, server_key,\n                                            server_key_len, encrypting_key);\n            if (retval) {\n                pkiDebug(\"pkinit_octetstring2key failed: %s\\n\",\n                         error_message(retval));\n                goto cleanup;\n            }\n        }\n    }\n\n    *send_pa = malloc(sizeof(krb5_pa_data));\n    if (*send_pa == NULL) {\n        retval = ENOMEM;\n        free(out_data->data);\n        free(out_data);\n        out_data = NULL;\n        goto cleanup;\n    }\n    (*send_pa)->magic = KV5M_PA_DATA;\n    switch ((int)padata->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        (*send_pa)->pa_type = KRB5_PADATA_PK_AS_REP;\n        break;\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n    case KRB5_PADATA_PK_AS_REP_OLD:\n        (*send_pa)->pa_type = KRB5_PADATA_PK_AS_REP_OLD;\n        break;\n    }\n    (*send_pa)->length = out_data->length;\n    (*send_pa)->contents = (krb5_octet *) out_data->data;\n\ncleanup:\n    pkinit_fini_kdc_req_context(context, reqctx);\n    free(scratch.data);\n    free(out_data);\n    if (encoded_dhkey_info != NULL)\n        krb5_free_data(context, encoded_dhkey_info);\n    if (encoded_key_pack != NULL)\n        krb5_free_data(context, encoded_key_pack);\n    free(dh_pubkey);\n    free(server_key);\n\n    switch ((int)padata->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        free_krb5_pa_pk_as_req(&reqp);\n        free_krb5_pa_pk_as_rep(&rep);\n        free_krb5_reply_key_pack(&key_pack);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        free_krb5_pa_pk_as_req_draft9(&reqp9);\n        free_krb5_pa_pk_as_rep_draft9(&rep9);\n        if (!fixed_keypack)\n            free_krb5_reply_key_pack_draft9(&key_pack9);\n        else\n            free_krb5_reply_key_pack(&key_pack);\n        break;\n    }\n\n    if (retval)\n        pkiDebug(\"pkinit_verify_padata failure\");\n\n    return retval;\n}\n\nstatic int\npkinit_server_get_flags(krb5_context kcontext, krb5_preauthtype patype)\n{\n    if (patype == KRB5_PADATA_PKINIT_KX)\n        return PA_INFO;\n    return PA_SUFFICIENT | PA_REPLACES_KEY | PA_TYPED_E_DATA;\n}\n\nstatic krb5_preauthtype supported_server_pa_types[] = {\n    KRB5_PADATA_PK_AS_REQ,\n    KRB5_PADATA_PK_AS_REQ_OLD,\n    KRB5_PADATA_PK_AS_REP_OLD,\n    KRB5_PADATA_PKINIT_KX,\n    0\n};\n\nstatic void\npkinit_fini_kdc_profile(krb5_context context, pkinit_kdc_context plgctx)\n{\n    /*\n     * There is nothing currently allocated by pkinit_init_kdc_profile()\n     * which needs to be freed here.\n     */\n}\n\nstatic krb5_error_code\npkinit_init_kdc_profile(krb5_context context, pkinit_kdc_context plgctx)\n{\n    krb5_error_code retval;\n    char *eku_string = NULL;\n\n    pkiDebug(\"%s: entered for realm %s\\n\", __FUNCTION__, plgctx->realmname);\n    retval = pkinit_kdcdefault_string(context, plgctx->realmname,\n                                      KRB5_CONF_PKINIT_IDENTITY,\n                                      &plgctx->idopts->identity);\n    if (retval != 0 || NULL == plgctx->idopts->identity) {\n        retval = EINVAL;\n        krb5_set_error_message(context, retval,\n                               _(\"No pkinit_identity supplied for realm %s\"),\n                               plgctx->realmname);\n        goto errout;\n    }\n\n    retval = pkinit_kdcdefault_strings(context, plgctx->realmname,\n                                       KRB5_CONF_PKINIT_ANCHORS,\n                                       &plgctx->idopts->anchors);\n    if (retval != 0 || NULL == plgctx->idopts->anchors) {\n        retval = EINVAL;\n        krb5_set_error_message(context, retval,\n                               _(\"No pkinit_anchors supplied for realm %s\"),\n                               plgctx->realmname);\n        goto errout;\n    }\n\n    pkinit_kdcdefault_strings(context, plgctx->realmname,\n                              KRB5_CONF_PKINIT_POOL,\n                              &plgctx->idopts->intermediates);\n\n    pkinit_kdcdefault_strings(context, plgctx->realmname,\n                              KRB5_CONF_PKINIT_REVOKE,\n                              &plgctx->idopts->crls);\n\n    pkinit_kdcdefault_string(context, plgctx->realmname,\n                             KRB5_CONF_PKINIT_KDC_OCSP,\n                             &plgctx->idopts->ocsp);\n\n    pkinit_kdcdefault_string(context, plgctx->realmname,\n                             KRB5_CONF_PKINIT_MAPPING_FILE,\n                             &plgctx->idopts->dn_mapping_file);\n\n    pkinit_kdcdefault_integer(context, plgctx->realmname,\n                              KRB5_CONF_PKINIT_DH_MIN_BITS,\n                              PKINIT_DEFAULT_DH_MIN_BITS,\n                              &plgctx->opts->dh_min_bits);\n    if (plgctx->opts->dh_min_bits < PKINIT_DEFAULT_DH_MIN_BITS) {\n        pkiDebug(\"%s: invalid value (%d) for pkinit_dh_min_bits, \"\n                 \"using default value (%d) instead\\n\", __FUNCTION__,\n                 plgctx->opts->dh_min_bits, PKINIT_DEFAULT_DH_MIN_BITS);\n        plgctx->opts->dh_min_bits = PKINIT_DEFAULT_DH_MIN_BITS;\n    }\n\n    pkinit_kdcdefault_boolean(context, plgctx->realmname,\n                              KRB5_CONF_PKINIT_ALLOW_UPN,\n                              0, &plgctx->opts->allow_upn);\n\n    pkinit_kdcdefault_boolean(context, plgctx->realmname,\n                              KRB5_CONF_PKINIT_REQUIRE_CRL_CHECKING,\n                              0, &plgctx->opts->require_crl_checking);\n\n    pkinit_kdcdefault_string(context, plgctx->realmname,\n                             KRB5_CONF_PKINIT_EKU_CHECKING,\n                             &eku_string);\n    if (eku_string != NULL) {\n        if (strcasecmp(eku_string, \"kpClientAuth\") == 0) {\n            plgctx->opts->require_eku = 1;\n            plgctx->opts->accept_secondary_eku = 0;\n        } else if (strcasecmp(eku_string, \"scLogin\") == 0) {\n            plgctx->opts->require_eku = 1;\n            plgctx->opts->accept_secondary_eku = 1;\n        } else if (strcasecmp(eku_string, \"none\") == 0) {\n            plgctx->opts->require_eku = 0;\n            plgctx->opts->accept_secondary_eku = 0;\n        } else {\n            pkiDebug(\"%s: Invalid value for pkinit_eku_checking: '%s'\\n\",\n                     __FUNCTION__, eku_string);\n        }\n        free(eku_string);\n    }\n\n\n    return 0;\nerrout:\n    pkinit_fini_kdc_profile(context, plgctx);\n    return retval;\n}\n\nstatic pkinit_kdc_context\npkinit_find_realm_context(krb5_context context,\n                          krb5_kdcpreauth_moddata moddata,\n                          krb5_principal princ)\n{\n    int i;\n    pkinit_kdc_context *realm_contexts = (pkinit_kdc_context *)moddata;\n\n    if (moddata == NULL)\n        return NULL;\n\n    for (i = 0; realm_contexts[i] != NULL; i++) {\n        pkinit_kdc_context p = realm_contexts[i];\n\n        if ((p->realmname_len == princ->realm.length) &&\n            (strncmp(p->realmname, princ->realm.data, p->realmname_len) == 0)) {\n            pkiDebug(\"%s: returning context at %p for realm '%s'\\n\",\n                     __FUNCTION__, p, p->realmname);\n            return p;\n        }\n    }\n    pkiDebug(\"%s: unable to find realm context for realm '%.*s'\\n\",\n             __FUNCTION__, princ->realm.length, princ->realm.data);\n    return NULL;\n}\n\nstatic int\npkinit_server_plugin_init_realm(krb5_context context, const char *realmname,\n                                pkinit_kdc_context *pplgctx)\n{\n    krb5_error_code retval = ENOMEM;\n    pkinit_kdc_context plgctx = NULL;\n\n    *pplgctx = NULL;\n\n    plgctx = calloc(1, sizeof(*plgctx));\n    if (plgctx == NULL)\n        goto errout;\n\n    pkiDebug(\"%s: initializing context at %p for realm '%s'\\n\",\n             __FUNCTION__, plgctx, realmname);\n    memset(plgctx, 0, sizeof(*plgctx));\n    plgctx->magic = PKINIT_CTX_MAGIC;\n\n    plgctx->realmname = strdup(realmname);\n    if (plgctx->realmname == NULL)\n        goto errout;\n    plgctx->realmname_len = strlen(plgctx->realmname);\n\n    retval = pkinit_init_plg_crypto(&plgctx->cryptoctx);\n    if (retval)\n        goto errout;\n\n    retval = pkinit_init_plg_opts(&plgctx->opts);\n    if (retval)\n        goto errout;\n\n    retval = pkinit_init_identity_crypto(&plgctx->idctx);\n    if (retval)\n        goto errout;\n\n    retval = pkinit_init_identity_opts(&plgctx->idopts);\n    if (retval)\n        goto errout;\n\n    retval = pkinit_init_kdc_profile(context, plgctx);\n    if (retval)\n        goto errout;\n\n    retval = pkinit_identity_initialize(context, plgctx->cryptoctx, NULL,\n                                        plgctx->idopts, plgctx->idctx, 0, NULL);\n    if (retval)\n        goto errout;\n\n    pkiDebug(\"%s: returning context at %p for realm '%s'\\n\",\n             __FUNCTION__, plgctx, realmname);\n    *pplgctx = plgctx;\n    retval = 0;\n\nerrout:\n    if (retval)\n        pkinit_server_plugin_fini_realm(context, plgctx);\n\n    return retval;\n}\n\nstatic int\npkinit_server_plugin_init(krb5_context context,\n                          krb5_kdcpreauth_moddata *moddata_out,\n                          const char **realmnames)\n{\n    krb5_error_code retval = ENOMEM;\n    pkinit_kdc_context plgctx, *realm_contexts = NULL;\n    size_t  i, j;\n    size_t numrealms;\n\n    retval = pkinit_accessor_init();\n    if (retval)\n        return retval;\n\n    /* Determine how many realms we may need to support */\n    for (i = 0; realmnames[i] != NULL; i++) {};\n    numrealms = i;\n\n    realm_contexts = calloc(numrealms+1, sizeof(pkinit_kdc_context));\n    if (realm_contexts == NULL)\n        return ENOMEM;\n\n    for (i = 0, j = 0; i < numrealms; i++) {\n        pkiDebug(\"%s: processing realm '%s'\\n\", __FUNCTION__, realmnames[i]);\n        retval = pkinit_server_plugin_init_realm(context, realmnames[i], &plgctx);\n        if (retval == 0 && plgctx != NULL)\n            realm_contexts[j++] = plgctx;\n    }\n\n    if (j == 0) {\n        retval = EINVAL;\n        krb5_set_error_message(context, retval,\n                               _(\"No realms configured correctly for pkinit \"\n                                 \"support\"));\n        goto errout;\n    }\n\n    *moddata_out = (krb5_kdcpreauth_moddata)realm_contexts;\n    retval = 0;\n    pkiDebug(\"%s: returning context at %p\\n\", __FUNCTION__, realm_contexts);\n\nerrout:\n    if (retval) {\n        pkinit_server_plugin_fini(context,\n                                  (krb5_kdcpreauth_moddata)realm_contexts);\n    }\n\n    return retval;\n}\n\nstatic void\npkinit_server_plugin_fini_realm(krb5_context context, pkinit_kdc_context plgctx)\n{\n    if (plgctx == NULL)\n        return;\n\n    pkinit_fini_kdc_profile(context, plgctx);\n    pkinit_fini_identity_opts(plgctx->idopts);\n    pkinit_fini_identity_crypto(plgctx->idctx);\n    pkinit_fini_plg_crypto(plgctx->cryptoctx);\n    pkinit_fini_plg_opts(plgctx->opts);\n    free(plgctx->realmname);\n    free(plgctx);\n}\n\nstatic void\npkinit_server_plugin_fini(krb5_context context,\n                          krb5_kdcpreauth_moddata moddata)\n{\n    pkinit_kdc_context *realm_contexts = (pkinit_kdc_context *)moddata;\n    int i;\n\n    if (realm_contexts == NULL)\n        return;\n\n    for (i = 0; realm_contexts[i] != NULL; i++) {\n        pkinit_server_plugin_fini_realm(context, realm_contexts[i]);\n    }\n    pkiDebug(\"%s: freeing   context at %p\\n\", __FUNCTION__, realm_contexts);\n    free(realm_contexts);\n}\n\nstatic krb5_error_code\npkinit_init_kdc_req_context(krb5_context context, pkinit_kdc_req_context *ctx)\n{\n    krb5_error_code retval = ENOMEM;\n    pkinit_kdc_req_context reqctx = NULL;\n\n    reqctx = malloc(sizeof(*reqctx));\n    if (reqctx == NULL)\n        return retval;\n    memset(reqctx, 0, sizeof(*reqctx));\n    reqctx->magic = PKINIT_CTX_MAGIC;\n\n    retval = pkinit_init_req_crypto(&reqctx->cryptoctx);\n    if (retval)\n        goto cleanup;\n    reqctx->rcv_auth_pack = NULL;\n    reqctx->rcv_auth_pack9 = NULL;\n\n    pkiDebug(\"%s: returning reqctx at %p\\n\", __FUNCTION__, reqctx);\n    *ctx = reqctx;\n    retval = 0;\ncleanup:\n    if (retval)\n        pkinit_fini_kdc_req_context(context, reqctx);\n\n    return retval;\n}\n\nstatic void\npkinit_fini_kdc_req_context(krb5_context context, void *ctx)\n{\n    pkinit_kdc_req_context reqctx = (pkinit_kdc_req_context)ctx;\n\n    if (reqctx == NULL || reqctx->magic != PKINIT_CTX_MAGIC) {\n        pkiDebug(\"pkinit_fini_kdc_req_context: got bad reqctx (%p)!\\n\", reqctx);\n        return;\n    }\n    pkiDebug(\"%s: freeing   reqctx at %p\\n\", __FUNCTION__, reqctx);\n\n    pkinit_fini_req_crypto(reqctx->cryptoctx);\n    if (reqctx->rcv_auth_pack != NULL)\n        free_krb5_auth_pack(&reqctx->rcv_auth_pack);\n    if (reqctx->rcv_auth_pack9 != NULL)\n        free_krb5_auth_pack_draft9(context, &reqctx->rcv_auth_pack9);\n\n    free(reqctx);\n}\n\nkrb5_error_code\nkdcpreauth_pkinit_initvt(krb5_context context, int maj_ver, int min_ver,\n                         krb5_plugin_vtable vtable);\n\nkrb5_error_code\nkdcpreauth_pkinit_initvt(krb5_context context, int maj_ver, int min_ver,\n                         krb5_plugin_vtable vtable)\n{\n    krb5_kdcpreauth_vtable vt;\n\n    if (maj_ver != 1)\n        return KRB5_PLUGIN_VER_NOTSUPP;\n    vt = (krb5_kdcpreauth_vtable)vtable;\n    vt->name = \"pkinit\";\n    vt->pa_type_list = supported_server_pa_types;\n    vt->init = pkinit_server_plugin_init;\n    vt->fini = pkinit_server_plugin_fini;\n    vt->flags = pkinit_server_get_flags;\n    vt->edata = pkinit_server_get_edata;\n    vt->verify = pkinit_server_verify_padata;\n    vt->return_padata = pkinit_server_return_padata;\n    return 0;\n}\n"], "filenames": ["src/plugins/preauth/pkinit/pkinit_srv.c"], "buggy_code_start_loc": [1019], "buggy_code_end_loc": [1022], "fixing_code_start_loc": [1019], "fixing_code_end_loc": [1023], "type": "CWE-476", "message": "The pkinit_server_return_padata function in plugins/preauth/pkinit/pkinit_srv.c in the PKINIT implementation in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.10.4 attempts to find an agility KDF identifier in inappropriate circumstances, which allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted Draft 9 request.", "other": {"cve": {"id": "CVE-2012-1016", "sourceIdentifier": "cve@mitre.org", "published": "2013-03-05T04:54:02.927", "lastModified": "2021-02-02T18:37:52.757", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The pkinit_server_return_padata function in plugins/preauth/pkinit/pkinit_srv.c in the PKINIT implementation in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.10.4 attempts to find an agility KDF identifier in inappropriate circumstances, which allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted Draft 9 request."}, {"lang": "es", "value": "La funci\u00f3n pkinit_server_return_padata  en plugins/preauth/pkinit/pkinit_srv.c en la implementaci\u00f3n PKINIT en el Key Distribution Center (KDC) en MIT Kerberos 5 (tambi\u00e9n conocido como krb5) anterior a v1.10.4 intenta encontrar un identificador KDF en circunstancias inapropiadas, lo que permite a atacantes remotos provocar una denegaci\u00f3n de servicio (referencia a puntero NULL y ca\u00edda del servicio) a trav\u00e9s de una solicitud Draft especialmente dise\u00f1ada."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.4", "matchCriteriaId": "B945C00A-A9EF-4A3E-98E7-FD655A068319"}]}]}], "references": [{"url": "http://krbdev.mit.edu/rt/Ticket/Display.html?id=7527", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://web.mit.edu/kerberos/www/krb5-1.10/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/krb5/krb5/commit/db64ca25d661a47b996b4e2645998b5d7f0eb52c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/db64ca25d661a47b996b4e2645998b5d7f0eb52c"}}