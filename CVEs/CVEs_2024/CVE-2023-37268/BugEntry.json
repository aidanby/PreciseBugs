{"buggy_code": ["use poem::session::Session;\nuse poem::web::{Data, Form};\nuse poem::Request;\nuse poem_openapi::param::Query;\nuse poem_openapi::payload::{Html, Json, Response};\nuse poem_openapi::{ApiResponse, Enum, Object, OpenApi};\nuse serde::Deserialize;\nuse tracing::*;\nuse warpgate_common::auth::{AuthCredential, AuthResult};\nuse warpgate_core::Services;\nuse warpgate_sso::SsoInternalProviderConfig;\n\nuse super::sso_provider_detail::{SsoContext, SSO_CONTEXT_SESSION_KEY};\nuse crate::common::{authorize_session, get_auth_state_for_request};\n\npub struct Api;\n\n#[derive(Enum)]\npub enum SsoProviderKind {\n    Google,\n    Apple,\n    Azure,\n    Custom,\n}\n\n#[derive(Object)]\npub struct SsoProviderDescription {\n    pub name: String,\n    pub label: String,\n    pub kind: SsoProviderKind,\n}\n\n#[derive(ApiResponse)]\nenum GetSsoProvidersResponse {\n    #[oai(status = 200)]\n    Ok(Json<Vec<SsoProviderDescription>>),\n}\n\n#[allow(clippy::large_enum_variant)]\n#[derive(ApiResponse)]\nenum ReturnToSsoResponse {\n    #[oai(status = 307)]\n    Ok,\n}\n\n#[allow(clippy::large_enum_variant)]\n#[derive(ApiResponse)]\nenum ReturnToSsoPostResponse {\n    #[oai(status = 200)]\n    Redirect(Html<String>),\n}\n\n#[derive(Deserialize)]\npub struct ReturnToSsoFormData {\n    pub code: Option<String>,\n}\n\nfn make_redirect_url(err: &str) -> String {\n    error!(\"SSO error: {err}\");\n    format!(\"/@warpgate?login_error={err}\")\n}\n\n#[OpenApi]\nimpl Api {\n    #[oai(\n        path = \"/sso/providers\",\n        method = \"get\",\n        operation_id = \"get_sso_providers\"\n    )]\n    async fn api_get_all_sso_providers(\n        &self,\n        services: Data<&Services>,\n    ) -> poem::Result<GetSsoProvidersResponse> {\n        let mut providers = services.config.lock().await.store.sso_providers.clone();\n        providers.sort_by(|a, b| a.label().cmp(b.label()));\n        Ok(GetSsoProvidersResponse::Ok(Json(\n            providers\n                .into_iter()\n                .map(|p| SsoProviderDescription {\n                    name: p.name.clone(),\n                    label: p.label().to_string(),\n                    kind: match p.provider {\n                        SsoInternalProviderConfig::Google { .. } => SsoProviderKind::Google,\n                        SsoInternalProviderConfig::Apple { .. } => SsoProviderKind::Apple,\n                        SsoInternalProviderConfig::Azure { .. } => SsoProviderKind::Azure,\n                        SsoInternalProviderConfig::Custom { .. } => SsoProviderKind::Custom,\n                    },\n                })\n                .collect(),\n        )))\n    }\n\n    #[oai(path = \"/sso/return\", method = \"get\", operation_id = \"return_to_sso\")]\n    async fn api_return_to_sso_get(\n        &self,\n        req: &Request,\n        session: &Session,\n        services: Data<&Services>,\n        code: Query<Option<String>>,\n    ) -> poem::Result<Response<ReturnToSsoResponse>> {\n        let url = self\n            .api_return_to_sso_get_common(req, session, services, &code)\n            .await?\n            .unwrap_or_else(|x| make_redirect_url(&x));\n\n        Ok(Response::new(ReturnToSsoResponse::Ok).header(\"Location\", url))\n    }\n\n    #[oai(\n        path = \"/sso/return\",\n        method = \"post\",\n        operation_id = \"return_to_sso_with_form_data\"\n    )]\n    async fn api_return_to_sso_post(\n        &self,\n        req: &Request,\n        session: &Session,\n        services: Data<&Services>,\n        data: Form<ReturnToSsoFormData>,\n    ) -> poem::Result<ReturnToSsoPostResponse> {\n        let url = self\n            .api_return_to_sso_get_common(req, session, services, &data.code)\n            .await?\n            .unwrap_or_else(|x| make_redirect_url(&x));\n        let serialized_url =\n            serde_json::to_string(&url).map_err(poem::error::InternalServerError)?;\n        Ok(ReturnToSsoPostResponse::Redirect(\n            poem_openapi::payload::Html(format!(\n                \"<!doctype html>\\n\n                <html>\n                    <script>\n                        location.href = {serialized_url};\n                    </script>\n                    <body>\n                        Redirecting to <a href='{url}'>{url}</a>...\n                    </body>\n                </html>\n            \"\n            )),\n        ))\n    }\n\n    async fn api_return_to_sso_get_common(\n        &self,\n        req: &Request,\n        session: &Session,\n        services: Data<&Services>,\n        code: &Option<String>,\n    ) -> poem::Result<Result<String, String>> {\n        let Some(context) = session.get::<SsoContext>(SSO_CONTEXT_SESSION_KEY) else {\n            return Ok(Err(\"Not in an active SSO process\".to_string()));\n        };\n\n        let Some(ref code) = *code else {\n            return Ok(Err(\"No authorization code in the return URL request\".to_string()));\n        };\n\n        let response = context\n            .request\n            .verify_code((*code).clone())\n            .await\n            .map_err(poem::error::InternalServerError)?;\n\n        if !response.email_verified.unwrap_or(true) {\n            return Ok(Err(\"The SSO account's e-mail is not verified\".to_string()));\n        }\n\n        let Some(email) = response.email else {\n            return Ok(Err(\"No e-mail information in the SSO response\".to_string()));\n        };\n\n        info!(\"SSO login as {email}\");\n\n        let cred = AuthCredential::Sso {\n            provider: context.provider,\n            email: email.clone(),\n        };\n\n        let username = services\n            .config_provider\n            .lock()\n            .await\n            .username_for_sso_credential(&cred)\n            .await?;\n        let Some(username) = username else {\n            return Ok(Err(format!(\"No user matching {email}\")));\n        };\n\n        let mut auth_state_store = services.auth_state_store.lock().await;\n        let state_arc =\n            get_auth_state_for_request(&username, session, &mut auth_state_store).await?;\n\n        let mut state = state_arc.lock().await;\n        let mut cp = services.config_provider.lock().await;\n\n        if cp.validate_credential(&username, &cred).await? {\n            state.add_valid_credential(cred);\n        }\n\n        if let AuthResult::Accepted { username } = state.verify() {\n            auth_state_store.complete(state.id()).await;\n            authorize_session(req, username).await?;\n        }\n\n        Ok(Ok(context\n            .next_url\n            .as_deref()\n            .unwrap_or(\"/@warpgate#/login\")\n            .to_owned()))\n    }\n}\n"], "fixing_code": ["use poem::session::Session;\nuse poem::web::{Data, Form};\nuse poem::Request;\nuse poem_openapi::param::Query;\nuse poem_openapi::payload::{Html, Json, Response};\nuse poem_openapi::{ApiResponse, Enum, Object, OpenApi};\nuse serde::Deserialize;\nuse tracing::*;\nuse warpgate_common::auth::{AuthCredential, AuthResult};\nuse warpgate_core::Services;\nuse warpgate_sso::SsoInternalProviderConfig;\n\nuse super::sso_provider_detail::{SsoContext, SSO_CONTEXT_SESSION_KEY};\nuse crate::common::{authorize_session, get_auth_state_for_request};\n\npub struct Api;\n\n#[derive(Enum)]\npub enum SsoProviderKind {\n    Google,\n    Apple,\n    Azure,\n    Custom,\n}\n\n#[derive(Object)]\npub struct SsoProviderDescription {\n    pub name: String,\n    pub label: String,\n    pub kind: SsoProviderKind,\n}\n\n#[derive(ApiResponse)]\nenum GetSsoProvidersResponse {\n    #[oai(status = 200)]\n    Ok(Json<Vec<SsoProviderDescription>>),\n}\n\n#[allow(clippy::large_enum_variant)]\n#[derive(ApiResponse)]\nenum ReturnToSsoResponse {\n    #[oai(status = 307)]\n    Ok,\n}\n\n#[allow(clippy::large_enum_variant)]\n#[derive(ApiResponse)]\nenum ReturnToSsoPostResponse {\n    #[oai(status = 200)]\n    Redirect(Html<String>),\n}\n\n#[derive(Deserialize)]\npub struct ReturnToSsoFormData {\n    pub code: Option<String>,\n}\n\nfn make_redirect_url(err: &str) -> String {\n    error!(\"SSO error: {err}\");\n    format!(\"/@warpgate?login_error={err}\")\n}\n\n#[OpenApi]\nimpl Api {\n    #[oai(\n        path = \"/sso/providers\",\n        method = \"get\",\n        operation_id = \"get_sso_providers\"\n    )]\n    async fn api_get_all_sso_providers(\n        &self,\n        services: Data<&Services>,\n    ) -> poem::Result<GetSsoProvidersResponse> {\n        let mut providers = services.config.lock().await.store.sso_providers.clone();\n        providers.sort_by(|a, b| a.label().cmp(b.label()));\n        Ok(GetSsoProvidersResponse::Ok(Json(\n            providers\n                .into_iter()\n                .map(|p| SsoProviderDescription {\n                    name: p.name.clone(),\n                    label: p.label().to_string(),\n                    kind: match p.provider {\n                        SsoInternalProviderConfig::Google { .. } => SsoProviderKind::Google,\n                        SsoInternalProviderConfig::Apple { .. } => SsoProviderKind::Apple,\n                        SsoInternalProviderConfig::Azure { .. } => SsoProviderKind::Azure,\n                        SsoInternalProviderConfig::Custom { .. } => SsoProviderKind::Custom,\n                    },\n                })\n                .collect(),\n        )))\n    }\n\n    #[oai(path = \"/sso/return\", method = \"get\", operation_id = \"return_to_sso\")]\n    async fn api_return_to_sso_get(\n        &self,\n        req: &Request,\n        session: &Session,\n        services: Data<&Services>,\n        code: Query<Option<String>>,\n    ) -> poem::Result<Response<ReturnToSsoResponse>> {\n        let url = self\n            .api_return_to_sso_get_common(req, session, services, &code)\n            .await?\n            .unwrap_or_else(|x| make_redirect_url(&x));\n\n        Ok(Response::new(ReturnToSsoResponse::Ok).header(\"Location\", url))\n    }\n\n    #[oai(\n        path = \"/sso/return\",\n        method = \"post\",\n        operation_id = \"return_to_sso_with_form_data\"\n    )]\n    async fn api_return_to_sso_post(\n        &self,\n        req: &Request,\n        session: &Session,\n        services: Data<&Services>,\n        data: Form<ReturnToSsoFormData>,\n    ) -> poem::Result<ReturnToSsoPostResponse> {\n        let url = self\n            .api_return_to_sso_get_common(req, session, services, &data.code)\n            .await?\n            .unwrap_or_else(|x| make_redirect_url(&x));\n        let serialized_url =\n            serde_json::to_string(&url).map_err(poem::error::InternalServerError)?;\n        Ok(ReturnToSsoPostResponse::Redirect(\n            poem_openapi::payload::Html(format!(\n                \"<!doctype html>\\n\n                <html>\n                    <script>\n                        location.href = {serialized_url};\n                    </script>\n                    <body>\n                        Redirecting to <a href='{url}'>{url}</a>...\n                    </body>\n                </html>\n            \"\n            )),\n        ))\n    }\n\n    async fn api_return_to_sso_get_common(\n        &self,\n        req: &Request,\n        session: &Session,\n        services: Data<&Services>,\n        code: &Option<String>,\n    ) -> poem::Result<Result<String, String>> {\n        let Some(context) = session.get::<SsoContext>(SSO_CONTEXT_SESSION_KEY) else {\n            return Ok(Err(\"Not in an active SSO process\".to_string()));\n        };\n\n        let Some(ref code) = *code else {\n            return Ok(Err(\"No authorization code in the return URL request\".to_string()));\n        };\n\n        let response = context\n            .request\n            .verify_code((*code).clone())\n            .await\n            .map_err(poem::error::InternalServerError)?;\n\n        if !response.email_verified.unwrap_or(true) {\n            return Ok(Err(\"The SSO account's e-mail is not verified\".to_string()));\n        }\n\n        let Some(email) = response.email else {\n            return Ok(Err(\"No e-mail information in the SSO response\".to_string()));\n        };\n\n        info!(\"SSO login as {email}\");\n\n        let cred = AuthCredential::Sso {\n            provider: context.provider,\n            email: email.clone(),\n        };\n\n        let username = services\n            .config_provider\n            .lock()\n            .await\n            .username_for_sso_credential(&cred)\n            .await?;\n        let Some(username) = username else {\n            return Ok(Err(format!(\"No user matching {email}\")));\n        };\n\n        let mut auth_state_store = services.auth_state_store.lock().await;\n        let state_arc =\n            get_auth_state_for_request(&username, session, &mut auth_state_store).await?;\n\n        let mut state = state_arc.lock().await;\n        let mut cp = services.config_provider.lock().await;\n\n        if state.username() != username {\n            return Ok(Err(format!(\n                \"Incorrect account for SSO authentication ({username})\"\n            )));\n        }\n\n        if cp.validate_credential(&username, &cred).await? {\n            state.add_valid_credential(cred);\n        }\n\n        if let AuthResult::Accepted { username } = state.verify() {\n            auth_state_store.complete(state.id()).await;\n            authorize_session(req, username).await?;\n        }\n\n        Ok(Ok(context\n            .next_url\n            .as_deref()\n            .unwrap_or(\"/@warpgate#/login\")\n            .to_owned()))\n    }\n}\n"], "filenames": ["warpgate-protocol-http/src/api/sso_provider_list.rs"], "buggy_code_start_loc": [195], "buggy_code_end_loc": [195], "fixing_code_start_loc": [196], "fixing_code_end_loc": [202], "type": "CWE-287", "message": "Warpgate is an SSH, HTTPS and MySQL bastion host for Linux that doesn't need special client apps. When logging in as a user with SSO enabled an attacker may authenticate as an other user. Any user account which does not have a second factor enabled could be compromised. This issue has been addressed in commit `8173f6512a` and in releases starting with version 0.7.3. Users are advised to upgrade. Users unable to upgrade should require their users to use a second factor in authentication.", "other": {"cve": {"id": "CVE-2023-37268", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-14T22:15:09.317", "lastModified": "2023-07-28T13:40:59.173", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Warpgate is an SSH, HTTPS and MySQL bastion host for Linux that doesn't need special client apps. When logging in as a user with SSO enabled an attacker may authenticate as an other user. Any user account which does not have a second factor enabled could be compromised. This issue has been addressed in commit `8173f6512a` and in releases starting with version 0.7.3. Users are advised to upgrade. Users unable to upgrade should require their users to use a second factor in authentication."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 5.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:warpgate_project:warpgate:0.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "4186EF0A-7EF9-4894-A349-580867C01F9A"}]}]}], "references": [{"url": "https://github.com/warp-tech/warpgate/commit/8173f6512ab6183fa5edc5c9a5f3760b8979271e", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/warp-tech/warpgate/security/advisories/GHSA-868r-97g5-r9g4", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/warp-tech/warpgate/commit/8173f6512ab6183fa5edc5c9a5f3760b8979271e"}}