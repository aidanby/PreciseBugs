{"buggy_code": ["# encoding: utf-8\n\ngem 'mysql2', '~> 0.3.6'\nrequire 'mysql2'\n\nmodule ActiveRecord\n  class Base\n    # Establishes a connection to the database that's used by all Active Record objects.\n    def self.mysql2_connection(config)\n      config[:username] = 'root' if config[:username].nil?\n\n      if Mysql2::Client.const_defined? :FOUND_ROWS\n        config[:flags] = Mysql2::Client::FOUND_ROWS\n      end\n\n      client = Mysql2::Client.new(config.symbolize_keys)\n      options = [config[:host], config[:username], config[:password], config[:database], config[:port], config[:socket], 0]\n      ConnectionAdapters::Mysql2Adapter.new(client, logger, options, config)\n    end\n  end\n\n  module ConnectionAdapters\n    class Mysql2IndexDefinition < Struct.new(:table, :name, :unique, :columns, :lengths) #:nodoc:\n    end\n\n    class Mysql2Column < Column\n      BOOL = \"tinyint(1)\"\n      def extract_default(default)\n        if sql_type =~ /blob/i || type == :text\n          if default.blank?\n            return null ? nil : ''\n          else\n            raise ArgumentError, \"#{type} columns cannot have a default value: #{default.inspect}\"\n          end\n        elsif missing_default_forged_as_empty_string?(default)\n          nil\n        else\n          super\n        end\n      end\n\n      def has_default?\n        return false if sql_type =~ /blob/i || type == :text #mysql forbids defaults on blob and text columns\n        super\n      end\n\n      private\n        def simplified_type(field_type)\n          return :boolean if Mysql2Adapter.emulate_booleans && field_type.downcase.index(BOOL)\n\n          case field_type\n          when /enum/i, /set/i then :string\n          when /year/i         then :integer\n          when /bit/i          then :binary\n          else\n            super\n          end\n        end\n\n        def extract_limit(sql_type)\n          case sql_type\n          when /blob|text/i\n            case sql_type\n            when /tiny/i\n              255\n            when /medium/i\n              16777215\n            when /long/i\n              2147483647 # mysql only allows 2^31-1, not 2^32-1, somewhat inconsistently with the tiny/medium/normal cases\n            else\n              super # we could return 65535 here, but we leave it undecorated by default\n            end\n          when /^bigint/i;    8\n          when /^int/i;       4\n          when /^mediumint/i; 3\n          when /^smallint/i;  2\n          when /^tinyint/i;   1\n          else\n            super\n          end\n        end\n\n        # MySQL misreports NOT NULL column default when none is given.\n        # We can't detect this for columns which may have a legitimate ''\n        # default (string) but we can for others (integer, datetime, boolean,\n        # and the rest).\n        #\n        # Test whether the column has default '', is not null, and is not\n        # a type allowing default ''.\n        def missing_default_forged_as_empty_string?(default)\n          type != :string && !null && default == ''\n        end\n    end\n\n    class Mysql2Adapter < AbstractAdapter\n      cattr_accessor :emulate_booleans\n      self.emulate_booleans = true\n\n      ADAPTER_NAME = 'Mysql2'\n      PRIMARY = \"PRIMARY\"\n\n      LOST_CONNECTION_ERROR_MESSAGES = [\n        \"Server shutdown in progress\",\n        \"Broken pipe\",\n        \"Lost connection to MySQL server during query\",\n        \"MySQL server has gone away\" ]\n\n      QUOTED_TRUE, QUOTED_FALSE = '1', '0'\n\n      NATIVE_DATABASE_TYPES = {\n        :primary_key => \"int(11) DEFAULT NULL auto_increment PRIMARY KEY\",\n        :string      => { :name => \"varchar\", :limit => 255 },\n        :text        => { :name => \"text\" },\n        :integer     => { :name => \"int\", :limit => 4 },\n        :float       => { :name => \"float\" },\n        :decimal     => { :name => \"decimal\" },\n        :datetime    => { :name => \"datetime\" },\n        :timestamp   => { :name => \"datetime\" },\n        :time        => { :name => \"time\" },\n        :date        => { :name => \"date\" },\n        :binary      => { :name => \"blob\" },\n        :boolean     => { :name => \"tinyint\", :limit => 1 }\n      }\n\n      def initialize(connection, logger, connection_options, config)\n        super(connection, logger)\n        @connection_options, @config = connection_options, config\n        @quoted_column_names, @quoted_table_names = {}, {}\n        configure_connection\n      end\n\n      def self.visitor_for(pool) # :nodoc:\n        Arel::Visitors::MySQL.new(pool)\n      end\n\n      def adapter_name\n        ADAPTER_NAME\n      end\n\n      # Returns true, since this connection adapter supports migrations.\n      def supports_migrations?\n        true\n      end\n\n      def supports_primary_key?\n        true\n      end\n\n      # Returns true, since this connection adapter supports savepoints.\n      def supports_savepoints?\n        true\n      end\n\n      def native_database_types\n        NATIVE_DATABASE_TYPES\n      end\n\n      # QUOTING ==================================================\n\n      def quote(value, column = nil)\n        if value.kind_of?(String) && column && column.type == :binary && column.class.respond_to?(:string_to_binary)\n          s = column.class.string_to_binary(value).unpack(\"H*\")[0]\n          \"x'#{s}'\"\n        elsif value.kind_of?(BigDecimal)\n          value.to_s(\"F\")\n        else\n          super\n        end\n      end\n\n      def quote_column_name(name) #:nodoc:\n        @quoted_column_names[name] ||= \"`#{name}`\"\n      end\n\n      def quote_table_name(name) #:nodoc:\n        @quoted_table_names[name] ||= quote_column_name(name).gsub('.', '`.`')\n      end\n\n      def quote_string(string)\n        @connection.escape(string)\n      end\n\n      def quoted_true\n        QUOTED_TRUE\n      end\n\n      def quoted_false\n        QUOTED_FALSE\n      end\n\n      def substitute_at(column, index)\n        Arel.sql \"\\0\"\n      end\n\n      # REFERENTIAL INTEGRITY ====================================\n\n      def disable_referential_integrity(&block) #:nodoc:\n        old = select_value(\"SELECT @@FOREIGN_KEY_CHECKS\")\n\n        begin\n          update(\"SET FOREIGN_KEY_CHECKS = 0\")\n          yield\n        ensure\n          update(\"SET FOREIGN_KEY_CHECKS = #{old}\")\n        end\n      end\n\n      # CONNECTION MANAGEMENT ====================================\n\n      def active?\n        return false unless @connection\n        @connection.ping\n      end\n\n      def reconnect!\n        disconnect!\n        connect\n      end\n\n      # this is set to true in 2.3, but we don't want it to be\n      def requires_reloading?\n        false\n      end\n\n      # Disconnects from the database if already connected.\n      # Otherwise, this method does nothing.\n      def disconnect!\n        unless @connection.nil?\n          @connection.close\n          @connection = nil\n        end\n      end\n\n      def reset!\n        disconnect!\n        connect\n      end\n\n      # DATABASE STATEMENTS ======================================\n\n      # FIXME: re-enable the following once a \"better\" query_cache solution is in core\n      #\n      # The overrides below perform much better than the originals in AbstractAdapter\n      # because we're able to take advantage of mysql2's lazy-loading capabilities\n      #\n      # # Returns a record hash with the column names as keys and column values\n      # # as values.\n      # def select_one(sql, name = nil)\n      #   result = execute(sql, name)\n      #   result.each(:as => :hash) do |r|\n      #     return r\n      #   end\n      # end\n      #\n      # # Returns a single value from a record\n      # def select_value(sql, name = nil)\n      #   result = execute(sql, name)\n      #   if first = result.first\n      #     first.first\n      #   end\n      # end\n      #\n      # # Returns an array of the values of the first column in a select:\n      # #   select_values(\"SELECT id FROM companies LIMIT 3\") => [1,2,3]\n      # def select_values(sql, name = nil)\n      #   execute(sql, name).map { |row| row.first }\n      # end\n\n      # Returns an array of arrays containing the field values.\n      # Order is the same as that returned by +columns+.\n      def select_rows(sql, name = nil)\n        execute(sql, name).to_a\n      end\n\n      # Executes the SQL statement in the context of this connection.\n      def execute(sql, name = nil)\n        # make sure we carry over any changes to ActiveRecord::Base.default_timezone that have been\n        # made since we established the connection\n        @connection.query_options[:database_timezone] = ActiveRecord::Base.default_timezone\n        if name == :skip_logging\n          @connection.query(sql)\n        else\n          log(sql, name) { @connection.query(sql) }\n        end\n      rescue ActiveRecord::StatementInvalid => exception\n        if exception.message.split(\":\").first =~ /Packets out of order/\n          raise ActiveRecord::StatementInvalid, \"'Packets out of order' error was received from the database. Please update your mysql bindings (gem install mysql) and read http://dev.mysql.com/doc/mysql/en/password-hashing.html for more information. If you're on Windows, use the Instant Rails installer to get the updated mysql bindings.\"\n        else\n          raise\n        end\n      end\n\n      def insert_sql(sql, name = nil, pk = nil, id_value = nil, sequence_name = nil)\n        super\n        id_value || @connection.last_id\n      end\n      alias :create :insert_sql\n\n      def exec_insert(sql, name, binds)\n        binds = binds.dup\n\n        # Pretend to support bind parameters\n        execute sql.gsub(\"\\0\") { quote(*binds.shift.reverse) }, name\n      end\n\n      def exec_delete(sql, name, binds)\n        binds = binds.dup\n\n        # Pretend to support bind parameters\n        execute sql.gsub(\"\\0\") { quote(*binds.shift.reverse) }, name\n        @connection.affected_rows\n      end\n      alias :exec_update :exec_delete\n\n      def last_inserted_id(result)\n        @connection.last_id\n      end\n\n      def update_sql(sql, name = nil)\n        super\n        @connection.affected_rows\n      end\n\n      def begin_db_transaction\n        execute \"BEGIN\"\n      rescue Exception\n        # Transactions aren't supported\n      end\n\n      def commit_db_transaction\n        execute \"COMMIT\"\n      rescue Exception\n        # Transactions aren't supported\n      end\n\n      def rollback_db_transaction\n        execute \"ROLLBACK\"\n      rescue Exception\n        # Transactions aren't supported\n      end\n\n      def create_savepoint\n        execute(\"SAVEPOINT #{current_savepoint_name}\")\n      end\n\n      def rollback_to_savepoint\n        execute(\"ROLLBACK TO SAVEPOINT #{current_savepoint_name}\")\n      end\n\n      def release_savepoint\n        execute(\"RELEASE SAVEPOINT #{current_savepoint_name}\")\n      end\n\n      # SCHEMA STATEMENTS ========================================\n\n      def structure_dump\n        if supports_views?\n          sql = \"SHOW FULL TABLES WHERE Table_type = 'BASE TABLE'\"\n        else\n          sql = \"SHOW TABLES\"\n        end\n\n        select_all(sql).inject(\"\") do |structure, table|\n          table.delete('Table_type')\n          structure += select_one(\"SHOW CREATE TABLE #{quote_table_name(table.to_a.first.last)}\")[\"Create Table\"] + \";\\n\\n\"\n        end\n      end\n\n      # Drops the database specified on the +name+ attribute\n      # and creates it again using the provided +options+.\n      def recreate_database(name, options = {})\n        drop_database(name)\n        create_database(name, options)\n      end\n\n      # Create a new MySQL database with optional <tt>:charset</tt> and <tt>:collation</tt>.\n      # Charset defaults to utf8.\n      #\n      # Example:\n      #   create_database 'charset_test', :charset => 'latin1', :collation => 'latin1_bin'\n      #   create_database 'matt_development'\n      #   create_database 'matt_development', :charset => :big5\n      def create_database(name, options = {})\n        if options[:collation]\n          execute \"CREATE DATABASE `#{name}` DEFAULT CHARACTER SET `#{options[:charset] || 'utf8'}` COLLATE `#{options[:collation]}`\"\n        else\n          execute \"CREATE DATABASE `#{name}` DEFAULT CHARACTER SET `#{options[:charset] || 'utf8'}`\"\n        end\n      end\n\n      # Drops a MySQL database.\n      #\n      # Example:\n      #   drop_database('sebastian_development')\n      def drop_database(name) #:nodoc:\n        execute \"DROP DATABASE IF EXISTS `#{name}`\"\n      end\n\n      def current_database\n        select_value 'SELECT DATABASE() as db'\n      end\n\n      # Returns the database character set.\n      def charset\n        show_variable 'character_set_database'\n      end\n\n      # Returns the database collation strategy.\n      def collation\n        show_variable 'collation_database'\n      end\n\n      def tables(name = nil, database = nil) #:nodoc:\n        sql = [\"SHOW TABLES\", database].compact.join(' IN ')\n        execute(sql, 'SCHEMA').collect do |field|\n          field.first\n        end\n      end\n\n      def table_exists?(name)\n        return true if super\n\n        name          = name.to_s\n        schema, table = name.split('.', 2)\n\n        unless table # A table was provided without a schema\n          table  = schema\n          schema = nil\n        end\n\n        tables(nil, schema).include? table\n      end\n\n      # Returns an array of indexes for the given table.\n      def indexes(table_name, name = nil)\n        indexes = []\n        current_index = nil\n        result = execute(\"SHOW KEYS FROM #{quote_table_name(table_name)}\", 'SCHEMA')\n        result.each(:symbolize_keys => true, :as => :hash) do |row|\n          if current_index != row[:Key_name]\n            next if row[:Key_name] == PRIMARY # skip the primary key\n            current_index = row[:Key_name]\n            indexes << Mysql2IndexDefinition.new(row[:Table], row[:Key_name], row[:Non_unique] == 0, [], [])\n          end\n\n          indexes.last.columns << row[:Column_name]\n          indexes.last.lengths << row[:Sub_part]\n        end\n        indexes\n      end\n\n      # Returns an array of +Mysql2Column+ objects for the table specified by +table_name+.\n      def columns(table_name, name = nil)\n        sql = \"SHOW FIELDS FROM #{quote_table_name(table_name)}\"\n        columns = []\n        result = execute(sql, 'SCHEMA')\n        result.each(:symbolize_keys => true, :as => :hash) { |field|\n          columns << Mysql2Column.new(field[:Field], field[:Default], field[:Type], field[:Null] == \"YES\")\n        }\n        columns\n      end\n\n      def create_table(table_name, options = {})\n        super(table_name, options.reverse_merge(:options => \"ENGINE=InnoDB\"))\n      end\n\n      # Renames a table.\n      #\n      # Example:\n      #   rename_table('octopuses', 'octopi')\n      def rename_table(table_name, new_name)\n        execute \"RENAME TABLE #{quote_table_name(table_name)} TO #{quote_table_name(new_name)}\"\n      end\n\n      def add_column(table_name, column_name, type, options = {})\n        add_column_sql = \"ALTER TABLE #{quote_table_name(table_name)} ADD #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}\"\n        add_column_options!(add_column_sql, options)\n        add_column_position!(add_column_sql, options)\n        execute(add_column_sql)\n      end\n\n      def change_column_default(table_name, column_name, default)\n        column = column_for(table_name, column_name)\n        change_column table_name, column_name, column.sql_type, :default => default\n      end\n\n      def change_column_null(table_name, column_name, null, default = nil)\n        column = column_for(table_name, column_name)\n\n        unless null || default.nil?\n          execute(\"UPDATE #{quote_table_name(table_name)} SET #{quote_column_name(column_name)}=#{quote(default)} WHERE #{quote_column_name(column_name)} IS NULL\")\n        end\n\n        change_column table_name, column_name, column.sql_type, :null => null\n      end\n\n      def change_column(table_name, column_name, type, options = {})\n        column = column_for(table_name, column_name)\n\n        unless options_include_default?(options)\n          options[:default] = column.default\n        end\n\n        unless options.has_key?(:null)\n          options[:null] = column.null\n        end\n\n        change_column_sql = \"ALTER TABLE #{quote_table_name(table_name)} CHANGE #{quote_column_name(column_name)} #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}\"\n        add_column_options!(change_column_sql, options)\n        add_column_position!(change_column_sql, options)\n        execute(change_column_sql)\n      end\n\n      def rename_column(table_name, column_name, new_column_name)\n        options = {}\n        if column = columns(table_name).find { |c| c.name == column_name.to_s }\n          options[:default] = column.default\n          options[:null] = column.null\n        else\n          raise ActiveRecordError, \"No such column: #{table_name}.#{column_name}\"\n        end\n        current_type = select_one(\"SHOW COLUMNS FROM #{quote_table_name(table_name)} LIKE '#{column_name}'\")[\"Type\"]\n        rename_column_sql = \"ALTER TABLE #{quote_table_name(table_name)} CHANGE #{quote_column_name(column_name)} #{quote_column_name(new_column_name)} #{current_type}\"\n        add_column_options!(rename_column_sql, options)\n        execute(rename_column_sql)\n      end\n\n      # Maps logical Rails types to MySQL-specific data types.\n      def type_to_sql(type, limit = nil, precision = nil, scale = nil)\n        return super unless type.to_s == 'integer'\n\n        case limit\n        when 1; 'tinyint'\n        when 2; 'smallint'\n        when 3; 'mediumint'\n        when nil, 4, 11; 'int(11)'  # compatibility with MySQL default\n        when 5..8; 'bigint'\n        else raise(ActiveRecordError, \"No integer type has byte size #{limit}\")\n        end\n      end\n\n      def add_column_position!(sql, options)\n        if options[:first]\n          sql << \" FIRST\"\n        elsif options[:after]\n          sql << \" AFTER #{quote_column_name(options[:after])}\"\n        end\n      end\n\n      # SHOW VARIABLES LIKE 'name'.\n      def show_variable(name)\n        variables = select_all(\"SHOW VARIABLES LIKE '#{name}'\")\n        variables.first['Value'] unless variables.empty?\n      end\n\n      # Returns a table's primary key and belonging sequence.\n      def pk_and_sequence_for(table)\n        keys = []\n        result = execute(\"DESCRIBE #{quote_table_name(table)}\", 'SCHEMA')\n        result.each(:symbolize_keys => true, :as => :hash) do |row|\n          keys << row[:Field] if row[:Key] == \"PRI\"\n        end\n        keys.length == 1 ? [keys.first, nil] : nil\n      end\n\n      # Returns just a table's primary key\n      def primary_key(table)\n        pk_and_sequence = pk_and_sequence_for(table)\n        pk_and_sequence && pk_and_sequence.first\n      end\n\n      def case_sensitive_modifier(node)\n        Arel::Nodes::Bin.new(node)\n      end\n\n      def limited_update_conditions(where_sql, quoted_table_name, quoted_primary_key)\n        where_sql\n      end\n\n      # In the simple case, MySQL allows us to place JOINs directly into the UPDATE\n      # query. However, this does not allow for LIMIT, OFFSET and ORDER. To support\n      # these, we must use a subquery. However, MySQL is too stupid to create a\n      # temporary table for this automatically, so we have to give it some prompting\n      # in the form of a subsubquery. Ugh!\n      def join_to_update(update, select) #:nodoc:\n        if select.limit || select.offset || select.orders.any?\n          subsubselect = select.clone\n          subsubselect.projections = [update.key]\n\n          subselect = Arel::SelectManager.new(select.engine)\n          subselect.project Arel.sql(update.key.name)\n          subselect.from subsubselect.as('__active_record_temp')\n\n          update.where update.key.in(subselect)\n        else\n          update.table select.source\n          update.wheres = select.constraints\n        end\n      end\n\n      protected\n        def quoted_columns_for_index(column_names, options = {})\n          length = options[:length] if options.is_a?(Hash)\n\n          case length\n          when Hash\n            column_names.map {|name| length[name] ? \"#{quote_column_name(name)}(#{length[name]})\" : quote_column_name(name) }\n          when Fixnum\n            column_names.map {|name| \"#{quote_column_name(name)}(#{length})\"}\n          else\n            column_names.map {|name| quote_column_name(name) }\n          end\n        end\n\n        def translate_exception(exception, message)\n          return super unless exception.respond_to?(:error_number)\n\n          case exception.error_number\n          when 1062\n            RecordNotUnique.new(message, exception)\n          when 1452\n            InvalidForeignKey.new(message, exception)\n          else\n            super\n          end\n        end\n\n      private\n        def connect\n          @connection = Mysql2::Client.new(@config)\n          configure_connection\n        end\n\n        def configure_connection\n          @connection.query_options.merge!(:as => :array)\n\n          # By default, MySQL 'where id is null' selects the last inserted id.\n          # Turn this off. http://dev.rubyonrails.org/ticket/6778\n          variable_assignments = ['SQL_AUTO_IS_NULL=0']\n          encoding = @config[:encoding]\n\n          # make sure we set the encoding\n          variable_assignments << \"NAMES '#{encoding}'\" if encoding\n\n          # increase timeout so mysql server doesn't disconnect us\n          wait_timeout = @config[:wait_timeout]\n          wait_timeout = 2592000 unless wait_timeout.is_a?(Fixnum)\n          variable_assignments << \"@@wait_timeout = #{wait_timeout}\"\n\n          execute(\"SET #{variable_assignments.join(', ')}\", :skip_logging)\n        end\n\n        # Returns an array of record hashes with the column names as keys and\n        # column values as values.\n        def select(sql, name = nil, binds = [])\n          binds = binds.dup\n          exec_query(sql.gsub(\"\\0\") { quote(*binds.shift.reverse) }, name).to_a\n        end\n\n        def exec_query(sql, name = 'SQL', binds = [])\n          @connection.query_options[:database_timezone] = ActiveRecord::Base.default_timezone\n\n          log(sql, name, binds) do\n            begin\n              result = @connection.query(sql)\n            rescue ActiveRecord::StatementInvalid => exception\n              if exception.message.split(\":\").first =~ /Packets out of order/\n                raise ActiveRecord::StatementInvalid, \"'Packets out of order' error was received from the database. Please update your mysql bindings (gem install mysql) and read http://dev.mysql.com/doc/mysql/en/password-hashing.html for more information. If you're on Windows, use the Instant Rails installer to get the updated mysql bindings.\"\n              else\n                raise\n              end\n            end\n\n            ActiveRecord::Result.new(result.fields, result.to_a)\n          end\n        end\n\n        def supports_views?\n          version[0] >= 5\n        end\n\n        def version\n          @version ||= @connection.info[:version].scan(/^(\\d+)\\.(\\d+)\\.(\\d+)/).flatten.map { |v| v.to_i }\n        end\n\n        def column_for(table_name, column_name)\n          unless column = columns(table_name).find { |c| c.name == column_name.to_s }\n            raise \"No such column: #{table_name}.#{column_name}\"\n          end\n          column\n        end\n    end\n  end\nend\n", "require 'active_record/connection_adapters/abstract_adapter'\nrequire 'active_support/core_ext/object/blank'\nrequire 'set'\n\ngem 'mysql', '~> 2.8.1'\nrequire 'mysql'\n\nclass Mysql\n  class Time\n    ###\n    # This monkey patch is for test_additional_columns_from_join_table\n    def to_date\n      Date.new(year, month, day)\n    end\n  end\n  class Stmt; include Enumerable end\n  class Result; include Enumerable end\nend\n\nmodule ActiveRecord\n  class Base\n    # Establishes a connection to the database that's used by all Active Record objects.\n    def self.mysql_connection(config) # :nodoc:\n      config = config.symbolize_keys\n      host     = config[:host]\n      port     = config[:port]\n      socket   = config[:socket]\n      username = config[:username] ? config[:username].to_s : 'root'\n      password = config[:password].to_s\n      database = config[:database]\n\n      mysql = Mysql.init\n      mysql.ssl_set(config[:sslkey], config[:sslcert], config[:sslca], config[:sslcapath], config[:sslcipher]) if config[:sslca] || config[:sslkey]\n\n      default_flags = Mysql.const_defined?(:CLIENT_MULTI_RESULTS) ? Mysql::CLIENT_MULTI_RESULTS : 0\n      default_flags |= Mysql::CLIENT_FOUND_ROWS if Mysql.const_defined?(:CLIENT_FOUND_ROWS)\n      options = [host, username, password, database, port, socket, default_flags]\n      ConnectionAdapters::MysqlAdapter.new(mysql, logger, options, config)\n    end\n  end\n\n  module ConnectionAdapters\n    class MysqlColumn < Column #:nodoc:\n      class << self\n        def string_to_time(value)\n          return super unless Mysql::Time === value\n          new_time(\n            value.year,\n            value.month,\n            value.day,\n            value.hour,\n            value.minute,\n            value.second,\n            value.second_part)\n        end\n\n        def string_to_dummy_time(v)\n          return super unless Mysql::Time === v\n          new_time(2000, 01, 01, v.hour, v.minute, v.second, v.second_part)\n        end\n\n        def string_to_date(v)\n          return super unless Mysql::Time === v\n          new_date(v.year, v.month, v.day)\n        end\n      end\n\n      def extract_default(default)\n        if sql_type =~ /blob/i || type == :text\n          if default.blank?\n            return null ? nil : ''\n          else\n            raise ArgumentError, \"#{type} columns cannot have a default value: #{default.inspect}\"\n          end\n        elsif missing_default_forged_as_empty_string?(default)\n          nil\n        else\n          super\n        end\n      end\n\n      def has_default?\n        return false if sql_type =~ /blob/i || type == :text #mysql forbids defaults on blob and text columns\n        super\n      end\n\n      private\n        def simplified_type(field_type)\n          return :boolean if MysqlAdapter.emulate_booleans && field_type.downcase.index(\"tinyint(1)\")\n          return :string  if field_type =~ /enum/i\n          super\n        end\n\n        def extract_limit(sql_type)\n          case sql_type\n          when /blob|text/i\n            case sql_type\n            when /tiny/i\n              255\n            when /medium/i\n              16777215\n            when /long/i\n              2147483647 # mysql only allows 2^31-1, not 2^32-1, somewhat inconsistently with the tiny/medium/normal cases\n            else\n              super # we could return 65535 here, but we leave it undecorated by default\n            end\n          when /^bigint/i;    8\n          when /^int/i;       4\n          when /^mediumint/i; 3\n          when /^smallint/i;  2\n          when /^tinyint/i;   1\n          else\n            super\n          end\n        end\n\n        # MySQL misreports NOT NULL column default when none is given.\n        # We can't detect this for columns which may have a legitimate ''\n        # default (string) but we can for others (integer, datetime, boolean,\n        # and the rest).\n        #\n        # Test whether the column has default '', is not null, and is not\n        # a type allowing default ''.\n        def missing_default_forged_as_empty_string?(default)\n          type != :string && !null && default == ''\n        end\n    end\n\n    # The MySQL adapter will work with both Ruby/MySQL, which is a Ruby-based MySQL adapter that comes bundled with Active Record, and with\n    # the faster C-based MySQL/Ruby adapter (available both as a gem and from http://www.tmtm.org/en/mysql/ruby/).\n    #\n    # Options:\n    #\n    # * <tt>:host</tt> - Defaults to \"localhost\".\n    # * <tt>:port</tt> - Defaults to 3306.\n    # * <tt>:socket</tt> - Defaults to \"/tmp/mysql.sock\".\n    # * <tt>:username</tt> - Defaults to \"root\"\n    # * <tt>:password</tt> - Defaults to nothing.\n    # * <tt>:database</tt> - The name of the database. No default, must be provided.\n    # * <tt>:encoding</tt> - (Optional) Sets the client encoding by executing \"SET NAMES <encoding>\" after connection.\n    # * <tt>:reconnect</tt> - Defaults to false (See MySQL documentation: http://dev.mysql.com/doc/refman/5.0/en/auto-reconnect.html).\n    # * <tt>:sslca</tt> - Necessary to use MySQL with an SSL connection.\n    # * <tt>:sslkey</tt> - Necessary to use MySQL with an SSL connection.\n    # * <tt>:sslcert</tt> - Necessary to use MySQL with an SSL connection.\n    # * <tt>:sslcapath</tt> - Necessary to use MySQL with an SSL connection.\n    # * <tt>:sslcipher</tt> - Necessary to use MySQL with an SSL connection.\n    #\n    class MysqlAdapter < AbstractAdapter\n\n      ##\n      # :singleton-method:\n      # By default, the MysqlAdapter will consider all columns of type <tt>tinyint(1)</tt>\n      # as boolean. If you wish to disable this emulation (which was the default\n      # behavior in versions 0.13.1 and earlier) you can add the following line\n      # to your application.rb file:\n      #\n      #   ActiveRecord::ConnectionAdapters::MysqlAdapter.emulate_booleans = false\n      cattr_accessor :emulate_booleans\n      self.emulate_booleans = true\n\n      ADAPTER_NAME = 'MySQL'\n\n      LOST_CONNECTION_ERROR_MESSAGES = [\n        \"Server shutdown in progress\",\n        \"Broken pipe\",\n        \"Lost connection to MySQL server during query\",\n        \"MySQL server has gone away\" ]\n\n      QUOTED_TRUE, QUOTED_FALSE = '1', '0'\n\n      NATIVE_DATABASE_TYPES = {\n        :primary_key => \"int(11) DEFAULT NULL auto_increment PRIMARY KEY\",\n        :string      => { :name => \"varchar\", :limit => 255 },\n        :text        => { :name => \"text\" },\n        :integer     => { :name => \"int\", :limit => 4 },\n        :float       => { :name => \"float\" },\n        :decimal     => { :name => \"decimal\" },\n        :datetime    => { :name => \"datetime\" },\n        :timestamp   => { :name => \"datetime\" },\n        :time        => { :name => \"time\" },\n        :date        => { :name => \"date\" },\n        :binary      => { :name => \"blob\" },\n        :boolean     => { :name => \"tinyint\", :limit => 1 }\n      }\n\n      def initialize(connection, logger, connection_options, config)\n        super(connection, logger)\n        @connection_options, @config = connection_options, config\n        @quoted_column_names, @quoted_table_names = {}, {}\n        @statements = {}\n        @client_encoding = nil\n        connect\n      end\n\n      def self.visitor_for(pool) # :nodoc:\n        Arel::Visitors::MySQL.new(pool)\n      end\n\n      def adapter_name #:nodoc:\n        ADAPTER_NAME\n      end\n\n      def supports_bulk_alter? #:nodoc:\n        true\n      end\n\n      # Returns true, since this connection adapter supports prepared statement\n      # caching.\n      def supports_statement_cache?\n        true\n      end\n\n      # Returns true, since this connection adapter supports migrations.\n      def supports_migrations? #:nodoc:\n        true\n      end\n\n      # Returns true.\n      def supports_primary_key? #:nodoc:\n        true\n      end\n\n      # Returns true, since this connection adapter supports savepoints.\n      def supports_savepoints? #:nodoc:\n        true\n      end\n\n      def native_database_types #:nodoc:\n        NATIVE_DATABASE_TYPES\n      end\n\n\n      # QUOTING ==================================================\n\n      def quote(value, column = nil)\n        if value.kind_of?(String) && column && column.type == :binary && column.class.respond_to?(:string_to_binary)\n          s = column.class.string_to_binary(value).unpack(\"H*\")[0]\n          \"x'#{s}'\"\n        elsif value.kind_of?(BigDecimal)\n          value.to_s(\"F\")\n        else\n          super\n        end\n      end\n\n      def type_cast(value, column)\n        return super unless value == true || value == false\n\n        value ? 1 : 0\n      end\n\n      def quote_column_name(name) #:nodoc:\n        @quoted_column_names[name] ||= \"`#{name}`\"\n      end\n\n      def quote_table_name(name) #:nodoc:\n        @quoted_table_names[name] ||= quote_column_name(name).gsub('.', '`.`')\n      end\n\n      def quote_string(string) #:nodoc:\n        @connection.quote(string)\n      end\n\n      def quoted_true\n        QUOTED_TRUE\n      end\n\n      def quoted_false\n        QUOTED_FALSE\n      end\n\n      # REFERENTIAL INTEGRITY ====================================\n\n      def disable_referential_integrity #:nodoc:\n        old = select_value(\"SELECT @@FOREIGN_KEY_CHECKS\")\n\n        begin\n          update(\"SET FOREIGN_KEY_CHECKS = 0\")\n          yield\n        ensure\n          update(\"SET FOREIGN_KEY_CHECKS = #{old}\")\n        end\n      end\n\n      # CONNECTION MANAGEMENT ====================================\n\n      def active?\n        if @connection.respond_to?(:stat)\n          @connection.stat\n        else\n          @connection.query 'select 1'\n        end\n\n        # mysql-ruby doesn't raise an exception when stat fails.\n        if @connection.respond_to?(:errno)\n          @connection.errno.zero?\n        else\n          true\n        end\n      rescue Mysql::Error\n        false\n      end\n\n      def reconnect!\n        disconnect!\n        clear_cache!\n        connect\n      end\n\n      # Disconnects from the database if already connected. Otherwise, this\n      # method does nothing.\n      def disconnect!\n        @connection.close rescue nil\n      end\n\n      def reset!\n        if @connection.respond_to?(:change_user)\n          # See http://bugs.mysql.com/bug.php?id=33540 -- the workaround way to\n          # reset the connection is to change the user to the same user.\n          @connection.change_user(@config[:username], @config[:password], @config[:database])\n          configure_connection\n        end\n      end\n\n      # DATABASE STATEMENTS ======================================\n\n      def select_rows(sql, name = nil)\n        @connection.query_with_result = true\n        rows = exec_without_stmt(sql, name).rows\n        @connection.more_results && @connection.next_result    # invoking stored procedures with CLIENT_MULTI_RESULTS requires this to tidy up else connection will be dropped\n        rows\n      end\n\n      # Clears the prepared statements cache.\n      def clear_cache!\n        @statements.values.each do |cache|\n          cache[:stmt].close\n        end\n        @statements.clear\n      end\n\n      if \"<3\".respond_to?(:encode)\n        # Taken from here:\n        #   https://github.com/tmtm/ruby-mysql/blob/master/lib/mysql/charset.rb\n        # Author: TOMITA Masahiro <tommy@tmtm.org>\n        ENCODINGS = {\n          \"armscii8\" => nil,\n          \"ascii\"    => Encoding::US_ASCII,\n          \"big5\"     => Encoding::Big5,\n          \"binary\"   => Encoding::ASCII_8BIT,\n          \"cp1250\"   => Encoding::Windows_1250,\n          \"cp1251\"   => Encoding::Windows_1251,\n          \"cp1256\"   => Encoding::Windows_1256,\n          \"cp1257\"   => Encoding::Windows_1257,\n          \"cp850\"    => Encoding::CP850,\n          \"cp852\"    => Encoding::CP852,\n          \"cp866\"    => Encoding::IBM866,\n          \"cp932\"    => Encoding::Windows_31J,\n          \"dec8\"     => nil,\n          \"eucjpms\"  => Encoding::EucJP_ms,\n          \"euckr\"    => Encoding::EUC_KR,\n          \"gb2312\"   => Encoding::EUC_CN,\n          \"gbk\"      => Encoding::GBK,\n          \"geostd8\"  => nil,\n          \"greek\"    => Encoding::ISO_8859_7,\n          \"hebrew\"   => Encoding::ISO_8859_8,\n          \"hp8\"      => nil,\n          \"keybcs2\"  => nil,\n          \"koi8r\"    => Encoding::KOI8_R,\n          \"koi8u\"    => Encoding::KOI8_U,\n          \"latin1\"   => Encoding::ISO_8859_1,\n          \"latin2\"   => Encoding::ISO_8859_2,\n          \"latin5\"   => Encoding::ISO_8859_9,\n          \"latin7\"   => Encoding::ISO_8859_13,\n          \"macce\"    => Encoding::MacCentEuro,\n          \"macroman\" => Encoding::MacRoman,\n          \"sjis\"     => Encoding::SHIFT_JIS,\n          \"swe7\"     => nil,\n          \"tis620\"   => Encoding::TIS_620,\n          \"ucs2\"     => Encoding::UTF_16BE,\n          \"ujis\"     => Encoding::EucJP_ms,\n          \"utf8\"     => Encoding::UTF_8,\n          \"utf8mb4\"  => Encoding::UTF_8,\n        }\n      else\n        ENCODINGS = Hash.new { |h,k| h[k] = k }\n      end\n\n      # Get the client encoding for this database\n      def client_encoding\n        return @client_encoding if @client_encoding\n\n        result = exec_query(\n          \"SHOW VARIABLES WHERE Variable_name = 'character_set_client'\",\n          'SCHEMA')\n        @client_encoding = ENCODINGS[result.rows.last.last]\n      end\n\n      def exec_query(sql, name = 'SQL', binds = [])\n        log(sql, name, binds) do\n          exec_stmt(sql, name, binds) do |cols, stmt|\n            ActiveRecord::Result.new(cols, stmt.to_a) if cols\n          end\n        end\n      end\n\n      def last_inserted_id(result)\n        @connection.insert_id\n      end\n\n      def exec_without_stmt(sql, name = 'SQL') # :nodoc:\n        # Some queries, like SHOW CREATE TABLE don't work through the prepared\n        # statement API. For those queries, we need to use this method. :'(\n        log(sql, name) do\n          result = @connection.query(sql)\n          cols = []\n          rows = []\n\n          if result\n            cols = result.fetch_fields.map { |field| field.name }\n            rows = result.to_a\n            result.free\n          end\n          ActiveRecord::Result.new(cols, rows)\n        end\n      end\n\n      # Executes an SQL query and returns a MySQL::Result object. Note that you have to free\n      # the Result object after you're done using it.\n      def execute(sql, name = nil) #:nodoc:\n        if name == :skip_logging\n          @connection.query(sql)\n        else\n          log(sql, name) { @connection.query(sql) }\n        end\n      rescue ActiveRecord::StatementInvalid => exception\n        if exception.message.split(\":\").first =~ /Packets out of order/\n          raise ActiveRecord::StatementInvalid, \"'Packets out of order' error was received from the database. Please update your mysql bindings (gem install mysql) and read http://dev.mysql.com/doc/mysql/en/password-hashing.html for more information. If you're on Windows, use the Instant Rails installer to get the updated mysql bindings.\"\n        else\n          raise\n        end\n      end\n\n      def insert_sql(sql, name = nil, pk = nil, id_value = nil, sequence_name = nil) #:nodoc:\n        super sql, name\n        id_value || @connection.insert_id\n      end\n      alias :create :insert_sql\n\n      def update_sql(sql, name = nil) #:nodoc:\n        super\n        @connection.affected_rows\n      end\n\n      def exec_delete(sql, name, binds)\n        log(sql, name, binds) do\n          exec_stmt(sql, name, binds) do |cols, stmt|\n            stmt.affected_rows\n          end\n        end\n      end\n      alias :exec_update :exec_delete\n\n      def begin_db_transaction #:nodoc:\n        exec_without_stmt \"BEGIN\"\n      rescue Mysql::Error\n        # Transactions aren't supported\n      end\n\n      def commit_db_transaction #:nodoc:\n        execute \"COMMIT\"\n      rescue Exception\n        # Transactions aren't supported\n      end\n\n      def rollback_db_transaction #:nodoc:\n        execute \"ROLLBACK\"\n      rescue Exception\n        # Transactions aren't supported\n      end\n\n      def create_savepoint\n        execute(\"SAVEPOINT #{current_savepoint_name}\")\n      end\n\n      def rollback_to_savepoint\n        execute(\"ROLLBACK TO SAVEPOINT #{current_savepoint_name}\")\n      end\n\n      def release_savepoint\n        execute(\"RELEASE SAVEPOINT #{current_savepoint_name}\")\n      end\n\n      # In the simple case, MySQL allows us to place JOINs directly into the UPDATE\n      # query. However, this does not allow for LIMIT, OFFSET and ORDER. To support\n      # these, we must use a subquery. However, MySQL is too stupid to create a\n      # temporary table for this automatically, so we have to give it some prompting\n      # in the form of a subsubquery. Ugh!\n      def join_to_update(update, select) #:nodoc:\n        if select.limit || select.offset || select.orders.any?\n          subsubselect = select.clone\n          subsubselect.projections = [update.key]\n\n          subselect = Arel::SelectManager.new(select.engine)\n          subselect.project Arel.sql(update.key.name)\n          subselect.from subsubselect.as('__active_record_temp')\n\n          update.where update.key.in(subselect)\n        else\n          update.table select.source\n          update.wheres = select.constraints\n        end\n      end\n\n      # SCHEMA STATEMENTS ========================================\n\n      def structure_dump #:nodoc:\n        if supports_views?\n          sql = \"SHOW FULL TABLES WHERE Table_type = 'BASE TABLE'\"\n        else\n          sql = \"SHOW TABLES\"\n        end\n\n        select_all(sql).map do |table|\n          table.delete('Table_type')\n          sql = \"SHOW CREATE TABLE #{quote_table_name(table.to_a.first.last)}\"\n          exec_without_stmt(sql).first['Create Table'] + \";\\n\\n\"\n        end.join(\"\")\n      end\n\n      # Drops the database specified on the +name+ attribute\n      # and creates it again using the provided +options+.\n      def recreate_database(name, options = {}) #:nodoc:\n        drop_database(name)\n        create_database(name, options)\n      end\n\n      # Create a new MySQL database with optional <tt>:charset</tt> and <tt>:collation</tt>.\n      # Charset defaults to utf8.\n      #\n      # Example:\n      #   create_database 'charset_test', :charset => 'latin1', :collation => 'latin1_bin'\n      #   create_database 'matt_development'\n      #   create_database 'matt_development', :charset => :big5\n      def create_database(name, options = {})\n        if options[:collation]\n          execute \"CREATE DATABASE `#{name}` DEFAULT CHARACTER SET `#{options[:charset] || 'utf8'}` COLLATE `#{options[:collation]}`\"\n        else\n          execute \"CREATE DATABASE `#{name}` DEFAULT CHARACTER SET `#{options[:charset] || 'utf8'}`\"\n        end\n      end\n\n      # Drops a MySQL database.\n      #\n      # Example:\n      #   drop_database 'sebastian_development'\n      def drop_database(name) #:nodoc:\n        execute \"DROP DATABASE IF EXISTS `#{name}`\"\n      end\n\n      def current_database\n        select_value 'SELECT DATABASE() as db'\n      end\n\n      # Returns the database character set.\n      def charset\n        show_variable 'character_set_database'\n      end\n\n      # Returns the database collation strategy.\n      def collation\n        show_variable 'collation_database'\n      end\n\n      def tables(name = nil, database = nil) #:nodoc:\n        result = execute([\"SHOW TABLES\", database].compact.join(' IN '), 'SCHEMA')\n        tables = result.collect { |field| field[0] }\n        result.free\n        tables\n      end\n\n      def table_exists?(name)\n        return true if super\n\n        name          = name.to_s\n        schema, table = name.split('.', 2)\n\n        unless table # A table was provided without a schema\n          table  = schema\n          schema = nil\n        end\n\n        tables(nil, schema).include? table\n      end\n\n      # Returns an array of indexes for the given table.\n      def indexes(table_name, name = nil)#:nodoc:\n        indexes = []\n        current_index = nil\n        result = execute(\"SHOW KEYS FROM #{quote_table_name(table_name)}\", name)\n        result.each do |row|\n          if current_index != row[2]\n            next if row[2] == \"PRIMARY\" # skip the primary key\n            current_index = row[2]\n            indexes << IndexDefinition.new(row[0], row[2], row[1] == \"0\", [], [])\n          end\n\n          indexes.last.columns << row[4]\n          indexes.last.lengths << row[7]\n        end\n        result.free\n        indexes\n      end\n\n      # Returns an array of +MysqlColumn+ objects for the table specified by +table_name+.\n      def columns(table_name, name = nil)#:nodoc:\n        sql = \"SHOW FIELDS FROM #{quote_table_name(table_name)}\"\n        result = execute(sql, 'SCHEMA')\n        columns = result.collect { |field| MysqlColumn.new(field[0], field[4], field[1], field[2] == \"YES\") }\n        result.free\n        columns\n      end\n\n      def create_table(table_name, options = {}) #:nodoc:\n        super(table_name, options.reverse_merge(:options => \"ENGINE=InnoDB\"))\n      end\n\n      # Renames a table.\n      #\n      # Example:\n      #   rename_table('octopuses', 'octopi')\n      def rename_table(table_name, new_name)\n        execute \"RENAME TABLE #{quote_table_name(table_name)} TO #{quote_table_name(new_name)}\"\n      end\n\n      def bulk_change_table(table_name, operations) #:nodoc:\n        sqls = operations.map do |command, args|\n          table, arguments = args.shift, args\n          method = :\"#{command}_sql\"\n\n          if respond_to?(method)\n            send(method, table, *arguments)\n          else\n            raise \"Unknown method called : #{method}(#{arguments.inspect})\"\n          end\n        end.flatten.join(\", \")\n\n        execute(\"ALTER TABLE #{quote_table_name(table_name)} #{sqls}\")\n      end\n\n      def add_column(table_name, column_name, type, options = {})\n        execute(\"ALTER TABLE #{quote_table_name(table_name)} #{add_column_sql(table_name, column_name, type, options)}\")\n      end\n\n      def change_column_default(table_name, column_name, default) #:nodoc:\n        column = column_for(table_name, column_name)\n        change_column table_name, column_name, column.sql_type, :default => default\n      end\n\n      def change_column_null(table_name, column_name, null, default = nil)\n        column = column_for(table_name, column_name)\n\n        unless null || default.nil?\n          execute(\"UPDATE #{quote_table_name(table_name)} SET #{quote_column_name(column_name)}=#{quote(default)} WHERE #{quote_column_name(column_name)} IS NULL\")\n        end\n\n        change_column table_name, column_name, column.sql_type, :null => null\n      end\n\n      def change_column(table_name, column_name, type, options = {}) #:nodoc:\n        execute(\"ALTER TABLE #{quote_table_name(table_name)} #{change_column_sql(table_name, column_name, type, options)}\")\n      end\n\n      def rename_column(table_name, column_name, new_column_name) #:nodoc:\n        execute(\"ALTER TABLE #{quote_table_name(table_name)} #{rename_column_sql(table_name, column_name, new_column_name)}\")\n      end\n\n      # Maps logical Rails types to MySQL-specific data types.\n      def type_to_sql(type, limit = nil, precision = nil, scale = nil)\n        return super unless type.to_s == 'integer'\n\n        case limit\n        when 1; 'tinyint'\n        when 2; 'smallint'\n        when 3; 'mediumint'\n        when nil, 4, 11; 'int(11)'  # compatibility with MySQL default\n        when 5..8; 'bigint'\n        else raise(ActiveRecordError, \"No integer type has byte size #{limit}\")\n        end\n      end\n\n      def add_column_position!(sql, options)\n        if options[:first]\n          sql << \" FIRST\"\n        elsif options[:after]\n          sql << \" AFTER #{quote_column_name(options[:after])}\"\n        end\n      end\n\n      # SHOW VARIABLES LIKE 'name'\n      def show_variable(name)\n        variables = select_all(\"SHOW VARIABLES LIKE '#{name}'\")\n        variables.first['Value'] unless variables.empty?\n      end\n\n      # Returns a table's primary key and belonging sequence.\n      def pk_and_sequence_for(table) #:nodoc:\n        keys = []\n        result = execute(\"describe #{quote_table_name(table)}\", 'SCHEMA')\n        result.each_hash do |h|\n          keys << h[\"Field\"]if h[\"Key\"] == \"PRI\"\n        end\n        result.free\n        keys.length == 1 ? [keys.first, nil] : nil\n      end\n\n      # Returns just a table's primary key\n      def primary_key(table)\n        pk_and_sequence = pk_and_sequence_for(table)\n        pk_and_sequence && pk_and_sequence.first\n      end\n\n      def case_sensitive_modifier(node)\n        Arel::Nodes::Bin.new(node)\n      end\n\n      def limited_update_conditions(where_sql, quoted_table_name, quoted_primary_key)\n        where_sql\n      end\n\n      protected\n        def quoted_columns_for_index(column_names, options = {})\n          length = options[:length] if options.is_a?(Hash)\n\n          case length\n          when Hash\n            column_names.map {|name| length[name] ? \"#{quote_column_name(name)}(#{length[name]})\" : quote_column_name(name) }\n          when Fixnum\n            column_names.map {|name| \"#{quote_column_name(name)}(#{length})\"}\n          else\n            column_names.map {|name| quote_column_name(name) }\n          end\n        end\n\n        def translate_exception(exception, message)\n          return super unless exception.respond_to?(:errno)\n\n          case exception.errno\n          when 1062\n            RecordNotUnique.new(message, exception)\n          when 1452\n            InvalidForeignKey.new(message, exception)\n          else\n            super\n          end\n        end\n\n        def add_column_sql(table_name, column_name, type, options = {})\n          add_column_sql = \"ADD #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}\"\n          add_column_options!(add_column_sql, options)\n          add_column_position!(add_column_sql, options)\n          add_column_sql\n        end\n\n        def remove_column_sql(table_name, *column_names)\n          columns_for_remove(table_name, *column_names).map {|column_name| \"DROP #{column_name}\" }\n        end\n        alias :remove_columns_sql :remove_column\n\n        def change_column_sql(table_name, column_name, type, options = {})\n          column = column_for(table_name, column_name)\n\n          unless options_include_default?(options)\n            options[:default] = column.default\n          end\n\n          unless options.has_key?(:null)\n            options[:null] = column.null\n          end\n\n          change_column_sql = \"CHANGE #{quote_column_name(column_name)} #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}\"\n          add_column_options!(change_column_sql, options)\n          add_column_position!(change_column_sql, options)\n          change_column_sql\n        end\n\n        def rename_column_sql(table_name, column_name, new_column_name)\n          options = {}\n\n          if column = columns(table_name).find { |c| c.name == column_name.to_s }\n            options[:default] = column.default\n            options[:null] = column.null\n          else\n            raise ActiveRecordError, \"No such column: #{table_name}.#{column_name}\"\n          end\n\n          current_type = select_one(\"SHOW COLUMNS FROM #{quote_table_name(table_name)} LIKE '#{column_name}'\")[\"Type\"]\n          rename_column_sql = \"CHANGE #{quote_column_name(column_name)} #{quote_column_name(new_column_name)} #{current_type}\"\n          add_column_options!(rename_column_sql, options)\n          rename_column_sql\n        end\n\n        def add_index_sql(table_name, column_name, options = {})\n          index_name, index_type, index_columns = add_index_options(table_name, column_name, options)\n          \"ADD #{index_type} INDEX #{index_name} (#{index_columns})\"\n        end\n\n        def remove_index_sql(table_name, options = {})\n          index_name = index_name_for_remove(table_name, options)\n          \"DROP INDEX #{index_name}\"\n        end\n\n        def add_timestamps_sql(table_name)\n          [add_column_sql(table_name, :created_at, :datetime), add_column_sql(table_name, :updated_at, :datetime)]\n        end\n\n        def remove_timestamps_sql(table_name)\n          [remove_column_sql(table_name, :updated_at), remove_column_sql(table_name, :created_at)]\n        end\n\n      private\n      def exec_stmt(sql, name, binds)\n        cache = {}\n        if binds.empty?\n          stmt = @connection.prepare(sql)\n        else\n          cache = @statements[sql] ||= {\n            :stmt => @connection.prepare(sql)\n          }\n          stmt = cache[:stmt]\n        end\n\n\n        begin\n          stmt.execute(*binds.map { |col, val| type_cast(val, col) })\n        rescue Mysql::Error => e\n          # Older versions of MySQL leave the prepared statement in a bad\n          # place when an error occurs. To support older mysql versions, we\n          # need to close the statement and delete the statement from the\n          # cache.\n          stmt.close\n          @statements.delete sql\n          raise e\n        end\n\n        cols = nil\n        if metadata = stmt.result_metadata\n          cols = cache[:cols] ||= metadata.fetch_fields.map { |field|\n            field.name\n          }\n        end\n\n        result = yield [cols, stmt]\n\n        stmt.result_metadata.free if cols\n        stmt.free_result\n        stmt.close if binds.empty?\n\n        result\n      end\n\n        def connect\n          encoding = @config[:encoding]\n          if encoding\n            @connection.options(Mysql::SET_CHARSET_NAME, encoding) rescue nil\n          end\n\n          if @config[:sslca] || @config[:sslkey]\n            @connection.ssl_set(@config[:sslkey], @config[:sslcert], @config[:sslca], @config[:sslcapath], @config[:sslcipher])\n          end\n\n          @connection.options(Mysql::OPT_CONNECT_TIMEOUT, @config[:connect_timeout]) if @config[:connect_timeout]\n          @connection.options(Mysql::OPT_READ_TIMEOUT, @config[:read_timeout]) if @config[:read_timeout]\n          @connection.options(Mysql::OPT_WRITE_TIMEOUT, @config[:write_timeout]) if @config[:write_timeout]\n\n          @connection.real_connect(*@connection_options)\n\n          # reconnect must be set after real_connect is called, because real_connect sets it to false internally\n          @connection.reconnect = !!@config[:reconnect] if @connection.respond_to?(:reconnect=)\n\n          configure_connection\n        end\n\n        def configure_connection\n          encoding = @config[:encoding]\n          execute(\"SET NAMES '#{encoding}'\", :skip_logging) if encoding\n\n          # By default, MySQL 'where id is null' selects the last inserted id.\n          # Turn this off. http://dev.rubyonrails.org/ticket/6778\n          execute(\"SET SQL_AUTO_IS_NULL=0\", :skip_logging)\n        end\n\n        def select(sql, name = nil, binds = [])\n          @connection.query_with_result = true\n          rows = exec_query(sql, name, binds).to_a\n          @connection.more_results && @connection.next_result    # invoking stored procedures with CLIENT_MULTI_RESULTS requires this to tidy up else connection will be dropped\n          rows\n        end\n\n        def supports_views?\n          version[0] >= 5\n        end\n\n        # Returns the version of the connected MySQL server.\n        def version\n          @version ||= @connection.server_info.scan(/^(\\d+)\\.(\\d+)\\.(\\d+)/).flatten.map { |v| v.to_i }\n        end\n\n        def column_for(table_name, column_name)\n          unless column = columns(table_name).find { |c| c.name == column_name.to_s }\n            raise \"No such column: #{table_name}.#{column_name}\"\n          end\n          column\n        end\n    end\n  end\nend\n", "require 'active_record/connection_adapters/abstract_adapter'\n\nmodule ActiveRecord\n  module ConnectionAdapters #:nodoc:\n    class SQLiteColumn < Column #:nodoc:\n      class <<  self\n        def string_to_binary(value)\n          value.gsub(/\\0|\\%/n) do |b|\n            case b\n              when \"\\0\" then \"%00\"\n              when \"%\"  then \"%25\"\n            end\n          end\n        end\n\n        def binary_to_string(value)\n          if value.respond_to?(:force_encoding) && value.encoding != Encoding::ASCII_8BIT\n            value = value.force_encoding(Encoding::ASCII_8BIT)\n          end\n\n          value.gsub(/%00|%25/n) do |b|\n            case b\n              when \"%00\" then \"\\0\"\n              when \"%25\" then \"%\"\n            end\n          end\n        end\n      end\n    end\n\n    # The SQLite adapter works with both the 2.x and 3.x series of SQLite with the sqlite-ruby\n    # drivers (available both as gems and from http://rubyforge.org/projects/sqlite-ruby/).\n    #\n    # Options:\n    #\n    # * <tt>:database</tt> - Path to the database file.\n    class SQLiteAdapter < AbstractAdapter\n      class Version\n        include Comparable\n\n        def initialize(version_string)\n          @version = version_string.split('.').map { |v| v.to_i }\n        end\n\n        def <=>(version_string)\n          @version <=> version_string.split('.').map { |v| v.to_i }\n        end\n      end\n\n      def initialize(connection, logger, config)\n        super(connection, logger)\n        @statements = {}\n        @config = config\n      end\n\n      def self.visitor_for(pool) # :nodoc:\n        Arel::Visitors::SQLite.new(pool)\n      end\n\n      def adapter_name #:nodoc:\n        'SQLite'\n      end\n\n      # Returns true if SQLite version is '2.0.0' or greater, false otherwise.\n      def supports_ddl_transactions?\n        sqlite_version >= '2.0.0'\n      end\n\n      # Returns true if SQLite version is '3.6.8' or greater, false otherwise.\n      def supports_savepoints?\n        sqlite_version >= '3.6.8'\n      end\n\n      # Returns true, since this connection adapter supports prepared statement\n      # caching.\n      def supports_statement_cache?\n        true\n      end\n\n      # Returns true, since this connection adapter supports migrations.\n      def supports_migrations? #:nodoc:\n        true\n      end\n\n      # Returns true.\n      def supports_primary_key? #:nodoc:\n        true\n      end\n\n      def requires_reloading?\n        true\n      end\n\n      # Returns true if SQLite version is '3.1.6' or greater, false otherwise.\n      def supports_add_column?\n        sqlite_version >= '3.1.6'\n      end\n\n      # Disconnects from the database if already connected. Otherwise, this\n      # method does nothing.\n      def disconnect!\n        super\n        clear_cache!\n        @connection.close rescue nil\n      end\n\n      # Clears the prepared statements cache.\n      def clear_cache!\n        @statements.values.map { |hash| hash[:stmt] }.each { |stmt|\n          stmt.close unless stmt.closed?\n        }\n\n        @statements.clear\n      end\n\n      # Returns true if SQLite version is '3.2.6' or greater, false otherwise.\n      def supports_count_distinct? #:nodoc:\n        sqlite_version >= '3.2.6'\n      end\n\n      # Returns true if SQLite version is '3.1.0' or greater, false otherwise.\n      def supports_autoincrement? #:nodoc:\n        sqlite_version >= '3.1.0'\n      end\n\n      def native_database_types #:nodoc:\n        {\n          :primary_key => default_primary_key_type,\n          :string      => { :name => \"varchar\", :limit => 255 },\n          :text        => { :name => \"text\" },\n          :integer     => { :name => \"integer\" },\n          :float       => { :name => \"float\" },\n          :decimal     => { :name => \"decimal\" },\n          :datetime    => { :name => \"datetime\" },\n          :timestamp   => { :name => \"datetime\" },\n          :time        => { :name => \"time\" },\n          :date        => { :name => \"date\" },\n          :binary      => { :name => \"blob\" },\n          :boolean     => { :name => \"boolean\" }\n        }\n      end\n\n\n      # QUOTING ==================================================\n\n      def quote_string(s) #:nodoc:\n        @connection.class.quote(s)\n      end\n\n      def quote_column_name(name) #:nodoc:\n        %Q(\"#{name}\")\n      end\n\n      # Quote date/time values for use in SQL input. Includes microseconds\n      # if the value is a Time responding to usec.\n      def quoted_date(value) #:nodoc:\n        if value.respond_to?(:usec)\n          \"#{super}.#{sprintf(\"%06d\", value.usec)}\"\n        else\n          super\n        end\n      end\n\n      def type_cast(value, column) # :nodoc:\n        return super unless BigDecimal === value\n\n        value.to_f\n      end\n\n      # DATABASE STATEMENTS ======================================\n\n      def exec_query(sql, name = nil, binds = [])\n        log(sql, name, binds) do\n\n          # Don't cache statements without bind values\n          if binds.empty?\n            stmt    = @connection.prepare(sql)\n            cols    = stmt.columns\n            records = stmt.to_a\n            stmt.close\n            stmt = records\n          else\n            cache = @statements[sql] ||= {\n              :stmt => @connection.prepare(sql)\n            }\n            stmt = cache[:stmt]\n            cols = cache[:cols] ||= stmt.columns\n            stmt.reset!\n            stmt.bind_params binds.map { |col, val|\n              type_cast(val, col)\n            }\n          end\n\n          ActiveRecord::Result.new(cols, stmt.to_a)\n        end\n      end\n\n      def exec_delete(sql, name = 'SQL', binds = [])\n        exec_query(sql, name, binds)\n        @connection.changes\n      end\n      alias :exec_update :exec_delete\n\n      def last_inserted_id(result)\n        @connection.last_insert_row_id\n      end\n\n      def execute(sql, name = nil) #:nodoc:\n        log(sql, name) { @connection.execute(sql) }\n      end\n\n      def update_sql(sql, name = nil) #:nodoc:\n        super\n        @connection.changes\n      end\n\n      def delete_sql(sql, name = nil) #:nodoc:\n        sql += \" WHERE 1=1\" unless sql =~ /WHERE/i\n        super sql, name\n      end\n\n      def insert_sql(sql, name = nil, pk = nil, id_value = nil, sequence_name = nil) #:nodoc:\n        super\n        id_value || @connection.last_insert_row_id\n      end\n      alias :create :insert_sql\n\n      def select_rows(sql, name = nil)\n        exec_query(sql, name).rows\n      end\n\n      def create_savepoint\n        execute(\"SAVEPOINT #{current_savepoint_name}\")\n      end\n\n      def rollback_to_savepoint\n        execute(\"ROLLBACK TO SAVEPOINT #{current_savepoint_name}\")\n      end\n\n      def release_savepoint\n        execute(\"RELEASE SAVEPOINT #{current_savepoint_name}\")\n      end\n\n      def begin_db_transaction #:nodoc:\n        log('begin transaction',nil) { @connection.transaction }\n      end\n\n      def commit_db_transaction #:nodoc:\n        log('commit transaction',nil) { @connection.commit }\n      end\n\n      def rollback_db_transaction #:nodoc:\n        log('rollback transaction',nil) { @connection.rollback }\n      end\n\n      # SCHEMA STATEMENTS ========================================\n\n      def tables(name = 'SCHEMA') #:nodoc:\n        sql = <<-SQL\n          SELECT name\n          FROM sqlite_master\n          WHERE type = 'table' AND NOT name = 'sqlite_sequence'\n        SQL\n\n        exec_query(sql, name).map do |row|\n          row['name']\n        end\n      end\n\n      # Returns an array of +SQLiteColumn+ objects for the table specified by +table_name+.\n      def columns(table_name, name = nil) #:nodoc:\n        table_structure(table_name).map do |field|\n          case field[\"dflt_value\"]\n          when /^null$/i\n            field[\"dflt_value\"] = nil\n          when /^'(.*)'$/\n            field[\"dflt_value\"] = $1.gsub(/''/, \"'\")\n          when /^\"(.*)\"$/\n            field[\"dflt_value\"] = $1.gsub(/\"\"/, '\"')\n          end\n\n          SQLiteColumn.new(field['name'], field['dflt_value'], field['type'], field['notnull'].to_i == 0)\n        end\n      end\n\n      # Returns an array of indexes for the given table.\n      def indexes(table_name, name = nil) #:nodoc:\n        exec_query(\"PRAGMA index_list(#{quote_table_name(table_name)})\", name).map do |row|\n          IndexDefinition.new(\n            table_name,\n            row['name'],\n            row['unique'] != 0,\n            exec_query(\"PRAGMA index_info('#{row['name']}')\").map { |col|\n              col['name']\n            })\n        end\n      end\n\n      def primary_key(table_name) #:nodoc:\n        column = table_structure(table_name).find { |field|\n          field['pk'] == 1\n        }\n        column && column['name']\n      end\n\n      def remove_index!(table_name, index_name) #:nodoc:\n        exec_query \"DROP INDEX #{quote_column_name(index_name)}\"\n      end\n\n      # Renames a table.\n      #\n      # Example:\n      #   rename_table('octopuses', 'octopi')\n      def rename_table(name, new_name)\n        exec_query \"ALTER TABLE #{quote_table_name(name)} RENAME TO #{quote_table_name(new_name)}\"\n      end\n\n      # See: http://www.sqlite.org/lang_altertable.html\n      # SQLite has an additional restriction on the ALTER TABLE statement\n      def valid_alter_table_options( type, options)\n        type.to_sym != :primary_key\n      end\n\n      def add_column(table_name, column_name, type, options = {}) #:nodoc:\n        if supports_add_column? && valid_alter_table_options( type, options )\n          super(table_name, column_name, type, options)\n        else\n          alter_table(table_name) do |definition|\n            definition.column(column_name, type, options)\n          end\n        end\n      end\n\n      def remove_column(table_name, *column_names) #:nodoc:\n        raise ArgumentError.new(\"You must specify at least one column name. Example: remove_column(:people, :first_name)\") if column_names.empty?\n        column_names.flatten.each do |column_name|\n          alter_table(table_name) do |definition|\n            definition.columns.delete(definition[column_name])\n          end\n        end\n      end\n      alias :remove_columns :remove_column\n\n      def change_column_default(table_name, column_name, default) #:nodoc:\n        alter_table(table_name) do |definition|\n          definition[column_name].default = default\n        end\n      end\n\n      def change_column_null(table_name, column_name, null, default = nil)\n        unless null || default.nil?\n          exec_query(\"UPDATE #{quote_table_name(table_name)} SET #{quote_column_name(column_name)}=#{quote(default)} WHERE #{quote_column_name(column_name)} IS NULL\")\n        end\n        alter_table(table_name) do |definition|\n          definition[column_name].null = null\n        end\n      end\n\n      def change_column(table_name, column_name, type, options = {}) #:nodoc:\n        alter_table(table_name) do |definition|\n          include_default = options_include_default?(options)\n          definition[column_name].instance_eval do\n            self.type    = type\n            self.limit   = options[:limit] if options.include?(:limit)\n            self.default = options[:default] if include_default\n            self.null    = options[:null] if options.include?(:null)\n          end\n        end\n      end\n\n      def rename_column(table_name, column_name, new_column_name) #:nodoc:\n        unless columns(table_name).detect{|c| c.name == column_name.to_s }\n          raise ActiveRecord::ActiveRecordError, \"Missing column #{table_name}.#{column_name}\"\n        end\n        alter_table(table_name, :rename => {column_name.to_s => new_column_name.to_s})\n      end\n\n      def empty_insert_statement_value\n        \"VALUES(NULL)\"\n      end\n\n      protected\n        def select(sql, name = nil, binds = []) #:nodoc:\n          exec_query(sql, name, binds).to_a\n        end\n\n        def table_structure(table_name)\n          structure = exec_query(\"PRAGMA table_info(#{quote_table_name(table_name)})\", 'SCHEMA').to_hash\n          raise(ActiveRecord::StatementInvalid, \"Could not find table '#{table_name}'\") if structure.empty?\n          structure\n        end\n\n        def alter_table(table_name, options = {}) #:nodoc:\n          altered_table_name = \"altered_#{table_name}\"\n          caller = lambda {|definition| yield definition if block_given?}\n\n          transaction do\n            move_table(table_name, altered_table_name,\n              options.merge(:temporary => true))\n            move_table(altered_table_name, table_name, &caller)\n          end\n        end\n\n        def move_table(from, to, options = {}, &block) #:nodoc:\n          copy_table(from, to, options, &block)\n          drop_table(from)\n        end\n\n        def copy_table(from, to, options = {}) #:nodoc:\n          options = options.merge(:id => (!columns(from).detect{|c| c.name == 'id'}.nil? && 'id' == primary_key(from).to_s))\n          create_table(to, options) do |definition|\n            @definition = definition\n            columns(from).each do |column|\n              column_name = options[:rename] ?\n                (options[:rename][column.name] ||\n                 options[:rename][column.name.to_sym] ||\n                 column.name) : column.name\n\n              @definition.column(column_name, column.type,\n                :limit => column.limit, :default => column.default,\n                :null => column.null)\n            end\n            @definition.primary_key(primary_key(from)) if primary_key(from)\n            yield @definition if block_given?\n          end\n\n          copy_table_indexes(from, to, options[:rename] || {})\n          copy_table_contents(from, to,\n            @definition.columns.map {|column| column.name},\n            options[:rename] || {})\n        end\n\n        def copy_table_indexes(from, to, rename = {}) #:nodoc:\n          indexes(from).each do |index|\n            name = index.name\n            if to == \"altered_#{from}\"\n              name = \"temp_#{name}\"\n            elsif from == \"altered_#{to}\"\n              name = name[5..-1]\n            end\n\n            to_column_names = columns(to).map { |c| c.name }\n            columns = index.columns.map {|c| rename[c] || c }.select do |column|\n              to_column_names.include?(column)\n            end\n\n            unless columns.empty?\n              # index name can't be the same\n              opts = { :name => name.gsub(/_(#{from})_/, \"_#{to}_\") }\n              opts[:unique] = true if index.unique\n              add_index(to, columns, opts)\n            end\n          end\n        end\n\n        def copy_table_contents(from, to, columns, rename = {}) #:nodoc:\n          column_mappings = Hash[columns.map {|name| [name, name]}]\n          rename.each { |a| column_mappings[a.last] = a.first }\n          from_columns = columns(from).collect {|col| col.name}\n          columns = columns.find_all{|col| from_columns.include?(column_mappings[col])}\n          quoted_columns = columns.map { |col| quote_column_name(col) } * ','\n\n          quoted_to = quote_table_name(to)\n          exec_query(\"SELECT * FROM #{quote_table_name(from)}\").each do |row|\n            sql = \"INSERT INTO #{quoted_to} (#{quoted_columns}) VALUES (\"\n            sql << columns.map {|col| quote row[column_mappings[col]]} * ', '\n            sql << ')'\n            exec_query sql\n          end\n        end\n\n        def sqlite_version\n          @sqlite_version ||= SQLiteAdapter::Version.new(select_value('select sqlite_version(*)'))\n        end\n\n        def default_primary_key_type\n          if supports_autoincrement?\n            'INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL'\n          else\n            'INTEGER PRIMARY KEY NOT NULL'\n          end\n        end\n\n        def translate_exception(exception, message)\n          case exception.message\n          when /column(s)? .* (is|are) not unique/\n            RecordNotUnique.new(message, exception)\n          else\n            super\n          end\n        end\n\n    end\n  end\nend\n", "require \"cases/helper\"\nrequire 'models/post'\nrequire 'models/author'\nrequire 'models/topic'\nrequire 'models/reply'\nrequire 'models/category'\nrequire 'models/company'\nrequire 'models/customer'\nrequire 'models/developer'\nrequire 'models/project'\nrequire 'models/default'\nrequire 'models/auto_id'\nrequire 'models/boolean'\nrequire 'models/column_name'\nrequire 'models/subscriber'\nrequire 'models/keyboard'\nrequire 'models/comment'\nrequire 'models/minimalistic'\nrequire 'models/warehouse_thing'\nrequire 'models/parrot'\nrequire 'models/person'\nrequire 'models/edge'\nrequire 'models/joke'\nrequire 'models/bulb'\nrequire 'rexml/document'\nrequire 'active_support/core_ext/exception'\n\nclass Category < ActiveRecord::Base; end\nclass Categorization < ActiveRecord::Base; end\nclass Smarts < ActiveRecord::Base; end\nclass CreditCard < ActiveRecord::Base\n  class PinNumber < ActiveRecord::Base\n    class CvvCode < ActiveRecord::Base; end\n    class SubCvvCode < CvvCode; end\n  end\n  class SubPinNumber < PinNumber; end\n  class Brand < Category; end\nend\nclass MasterCreditCard < ActiveRecord::Base; end\nclass Post < ActiveRecord::Base; end\nclass Computer < ActiveRecord::Base; end\nclass NonExistentTable < ActiveRecord::Base; end\nclass TestOracleDefault < ActiveRecord::Base; end\n\nclass ReadonlyTitlePost < Post\n  attr_readonly :title\nend\n\nclass ProtectedTitlePost < Post\n  attr_protected :title\nend\n\nclass Weird < ActiveRecord::Base; end\n\nclass Boolean < ActiveRecord::Base; end\n\nclass LintTest < ActiveRecord::TestCase\n  include ActiveModel::Lint::Tests\n\n  class LintModel < ActiveRecord::Base; end\n\n  def setup\n    @model = LintModel.new\n  end\nend\n\nclass BasicsTest < ActiveRecord::TestCase\n  fixtures :topics, :companies, :developers, :projects, :computers, :accounts, :minimalistics, 'warehouse-things', :authors, :categorizations, :categories, :posts\n\n  def test_columns_should_obey_set_primary_key\n    pk = Subscriber.columns.find { |x| x.name == 'nick' }\n    assert pk.primary, 'nick should be primary key'\n  end\n\n  def test_primary_key_with_no_id\n    assert_nil Edge.primary_key\n  end\n\n  unless current_adapter?(:PostgreSQLAdapter,:OracleAdapter,:SQLServerAdapter)\n    def test_limit_with_comma\n      assert_nothing_raised do\n        Topic.limit(\"1,2\").all\n      end\n    end\n  end\n\n  def test_limit_without_comma\n    assert_nothing_raised do\n      assert_equal 1, Topic.limit(\"1\").all.length\n    end\n\n    assert_nothing_raised do\n      assert_equal 1, Topic.limit(1).all.length\n    end\n  end\n\n  def test_invalid_limit\n    assert_raises(ArgumentError) do\n      Topic.limit(\"asdfadf\").all\n    end\n  end\n\n  def test_limit_should_sanitize_sql_injection_for_limit_without_comas\n    assert_raises(ArgumentError) do\n      Topic.limit(\"1 select * from schema\").all\n    end\n  end\n\n  def test_limit_should_sanitize_sql_injection_for_limit_with_comas\n    assert_raises(ArgumentError) do\n      Topic.limit(\"1, 7 procedure help()\").all\n    end\n  end\n\n  unless current_adapter?(:MysqlAdapter) || current_adapter?(:Mysql2Adapter)\n    def test_limit_should_allow_sql_literal\n      assert_equal 1, Topic.limit(Arel.sql('2-1')).all.length\n    end\n  end\n\n  def test_select_symbol\n    topic_ids = Topic.select(:id).map(&:id).sort\n    assert_equal Topic.all.map(&:id).sort, topic_ids\n  end\n\n  def test_table_exists\n    assert !NonExistentTable.table_exists?\n    assert Topic.table_exists?\n  end\n\n  def test_preserving_date_objects\n    if current_adapter?(:SybaseAdapter)\n      # Sybase ctlib does not (yet?) support the date type; use datetime instead.\n      assert_kind_of(\n        Time, Topic.find(1).last_read,\n        \"The last_read attribute should be of the Time class\"\n      )\n    else\n      # Oracle enhanced adapter allows to define Date attributes in model class (see topic.rb)\n      assert_kind_of(\n        Date, Topic.find(1).last_read,\n        \"The last_read attribute should be of the Date class\"\n      )\n    end\n  end\n\n  def test_preserving_time_objects\n    assert_kind_of(\n      Time, Topic.find(1).bonus_time,\n      \"The bonus_time attribute should be of the Time class\"\n    )\n\n    assert_kind_of(\n      Time, Topic.find(1).written_on,\n      \"The written_on attribute should be of the Time class\"\n    )\n\n    # For adapters which support microsecond resolution.\n    if current_adapter?(:PostgreSQLAdapter) || current_adapter?(:SQLiteAdapter)\n      assert_equal 11, Topic.find(1).written_on.sec\n      assert_equal 223300, Topic.find(1).written_on.usec\n      assert_equal 9900, Topic.find(2).written_on.usec\n    end\n  end\n\n  def test_preserving_time_objects_with_local_time_conversion_to_default_timezone_utc\n    with_env_tz 'America/New_York' do\n      with_active_record_default_timezone :utc do\n        time = Time.local(2000)\n        topic = Topic.create('written_on' => time)\n        saved_time = Topic.find(topic.id).reload.written_on\n        assert_equal time, saved_time\n        assert_equal [0, 0, 0, 1, 1, 2000, 6, 1, false, \"EST\"], time.to_a\n        assert_equal [0, 0, 5, 1, 1, 2000, 6, 1, false, \"UTC\"], saved_time.to_a\n      end\n    end\n  end\n\n  def test_preserving_time_objects_with_time_with_zone_conversion_to_default_timezone_utc\n    with_env_tz 'America/New_York' do\n      with_active_record_default_timezone :utc do\n        Time.use_zone 'Central Time (US & Canada)' do\n          time = Time.zone.local(2000)\n          topic = Topic.create('written_on' => time)\n          saved_time = Topic.find(topic.id).reload.written_on\n          assert_equal time, saved_time\n          assert_equal [0, 0, 0, 1, 1, 2000, 6, 1, false, \"CST\"], time.to_a\n          assert_equal [0, 0, 6, 1, 1, 2000, 6, 1, false, \"UTC\"], saved_time.to_a\n        end\n      end\n    end\n  end\n\n  def test_preserving_time_objects_with_utc_time_conversion_to_default_timezone_local\n    with_env_tz 'America/New_York' do\n      time = Time.utc(2000)\n      topic = Topic.create('written_on' => time)\n      saved_time = Topic.find(topic.id).reload.written_on\n      assert_equal time, saved_time\n      assert_equal [0, 0, 0, 1, 1, 2000, 6, 1, false, \"UTC\"], time.to_a\n      assert_equal [0, 0, 19, 31, 12, 1999, 5, 365, false, \"EST\"], saved_time.to_a\n    end\n  end\n\n  def test_preserving_time_objects_with_time_with_zone_conversion_to_default_timezone_local\n    with_env_tz 'America/New_York' do\n      with_active_record_default_timezone :local do\n        Time.use_zone 'Central Time (US & Canada)' do\n          time = Time.zone.local(2000)\n          topic = Topic.create('written_on' => time)\n          saved_time = Topic.find(topic.id).reload.written_on\n          assert_equal time, saved_time\n          assert_equal [0, 0, 0, 1, 1, 2000, 6, 1, false, \"CST\"], time.to_a\n          assert_equal [0, 0, 1, 1, 1, 2000, 6, 1, false, \"EST\"], saved_time.to_a\n        end\n      end\n    end\n  end\n\n  def test_custom_mutator\n    topic = Topic.find(1)\n    # This mutator is protected in the class definition\n    topic.send(:approved=, true)\n    assert topic.instance_variable_get(\"@custom_approved\")\n  end\n\n  def test_initialize_with_attributes\n    topic = Topic.new({\n      \"title\" => \"initialized from attributes\", \"written_on\" => \"2003-12-12 23:23\"\n    })\n\n    assert_equal(\"initialized from attributes\", topic.title)\n  end\n\n  def test_initialize_with_invalid_attribute\n    begin\n      Topic.new({ \"title\" => \"test\",\n        \"last_read(1i)\" => \"2005\", \"last_read(2i)\" => \"2\", \"last_read(3i)\" => \"31\"})\n    rescue ActiveRecord::MultiparameterAssignmentErrors => ex\n      assert_equal(1, ex.errors.size)\n      assert_equal(\"last_read\", ex.errors[0].attribute)\n    end\n  end\n\n  def test_create_after_initialize_without_block\n    cb = CustomBulb.create(:name => 'Dude')\n    assert_equal('Dude', cb.name)\n    assert_equal(true, cb.frickinawesome)\n  end\n\n  def test_create_after_initialize_with_block\n    cb = CustomBulb.create {|c| c.name = 'Dude' }\n    assert_equal('Dude', cb.name)\n    assert_equal(true, cb.frickinawesome)\n  end\n\n  def test_load\n    topics = Topic.find(:all, :order => 'id')\n    assert_equal(4, topics.size)\n    assert_equal(topics(:first).title, topics.first.title)\n  end\n\n  def test_load_with_condition\n    topics = Topic.find(:all, :conditions => \"author_name = 'Mary'\")\n\n    assert_equal(1, topics.size)\n    assert_equal(topics(:second).title, topics.first.title)\n  end\n\n  GUESSED_CLASSES = [Category, Smarts, CreditCard, CreditCard::PinNumber, CreditCard::PinNumber::CvvCode, CreditCard::SubPinNumber, CreditCard::Brand, MasterCreditCard]\n\n  def test_table_name_guesses\n    assert_equal \"topics\", Topic.table_name\n\n    assert_equal \"categories\", Category.table_name\n    assert_equal \"smarts\", Smarts.table_name\n    assert_equal \"credit_cards\", CreditCard.table_name\n    assert_equal \"credit_card_pin_numbers\", CreditCard::PinNumber.table_name\n    assert_equal \"credit_card_pin_number_cvv_codes\", CreditCard::PinNumber::CvvCode.table_name\n    assert_equal \"credit_card_pin_numbers\", CreditCard::SubPinNumber.table_name\n    assert_equal \"categories\", CreditCard::Brand.table_name\n    assert_equal \"master_credit_cards\", MasterCreditCard.table_name\n  ensure\n    GUESSED_CLASSES.each(&:reset_table_name)\n  end\n\n  def test_singular_table_name_guesses\n    ActiveRecord::Base.pluralize_table_names = false\n    GUESSED_CLASSES.each(&:reset_table_name)\n\n    assert_equal \"category\", Category.table_name\n    assert_equal \"smarts\", Smarts.table_name\n    assert_equal \"credit_card\", CreditCard.table_name\n    assert_equal \"credit_card_pin_number\", CreditCard::PinNumber.table_name\n    assert_equal \"credit_card_pin_number_cvv_code\", CreditCard::PinNumber::CvvCode.table_name\n    assert_equal \"credit_card_pin_number\", CreditCard::SubPinNumber.table_name\n    assert_equal \"category\", CreditCard::Brand.table_name\n    assert_equal \"master_credit_card\", MasterCreditCard.table_name\n  ensure\n    ActiveRecord::Base.pluralize_table_names = true\n    GUESSED_CLASSES.each(&:reset_table_name)\n  end\n\n  def test_table_name_guesses_with_prefixes_and_suffixes\n    ActiveRecord::Base.table_name_prefix = \"test_\"\n    Category.reset_table_name\n    assert_equal \"test_categories\", Category.table_name\n    ActiveRecord::Base.table_name_suffix = \"_test\"\n    Category.reset_table_name\n    assert_equal \"test_categories_test\", Category.table_name\n    ActiveRecord::Base.table_name_prefix = \"\"\n    Category.reset_table_name\n    assert_equal \"categories_test\", Category.table_name\n    ActiveRecord::Base.table_name_suffix = \"\"\n    Category.reset_table_name\n    assert_equal \"categories\", Category.table_name\n  ensure\n    ActiveRecord::Base.table_name_prefix = \"\"\n    ActiveRecord::Base.table_name_suffix = \"\"\n    GUESSED_CLASSES.each(&:reset_table_name)\n  end\n\n  def test_singular_table_name_guesses_with_prefixes_and_suffixes\n    ActiveRecord::Base.pluralize_table_names = false\n\n    ActiveRecord::Base.table_name_prefix = \"test_\"\n    Category.reset_table_name\n    assert_equal \"test_category\", Category.table_name\n    ActiveRecord::Base.table_name_suffix = \"_test\"\n    Category.reset_table_name\n    assert_equal \"test_category_test\", Category.table_name\n    ActiveRecord::Base.table_name_prefix = \"\"\n    Category.reset_table_name\n    assert_equal \"category_test\", Category.table_name\n    ActiveRecord::Base.table_name_suffix = \"\"\n    Category.reset_table_name\n    assert_equal \"category\", Category.table_name\n  ensure\n    ActiveRecord::Base.pluralize_table_names = true\n    ActiveRecord::Base.table_name_prefix = \"\"\n    ActiveRecord::Base.table_name_suffix = \"\"\n    GUESSED_CLASSES.each(&:reset_table_name)\n  end\n\n  def test_table_name_guesses_with_inherited_prefixes_and_suffixes\n    GUESSED_CLASSES.each(&:reset_table_name)\n\n    CreditCard.table_name_prefix = \"test_\"\n    CreditCard.reset_table_name\n    Category.reset_table_name\n    assert_equal \"test_credit_cards\", CreditCard.table_name\n    assert_equal \"categories\", Category.table_name\n    CreditCard.table_name_suffix = \"_test\"\n    CreditCard.reset_table_name\n    Category.reset_table_name\n    assert_equal \"test_credit_cards_test\", CreditCard.table_name\n    assert_equal \"categories\", Category.table_name\n    CreditCard.table_name_prefix = \"\"\n    CreditCard.reset_table_name\n    Category.reset_table_name\n    assert_equal \"credit_cards_test\", CreditCard.table_name\n    assert_equal \"categories\", Category.table_name\n    CreditCard.table_name_suffix = \"\"\n    CreditCard.reset_table_name\n    Category.reset_table_name\n    assert_equal \"credit_cards\", CreditCard.table_name\n    assert_equal \"categories\", Category.table_name\n  ensure\n    CreditCard.table_name_prefix = \"\"\n    CreditCard.table_name_suffix = \"\"\n    GUESSED_CLASSES.each(&:reset_table_name)\n  end\n\n  def test_singular_table_name_guesses_for_individual_table\n    CreditCard.pluralize_table_names = false\n    CreditCard.reset_table_name\n    assert_equal \"credit_card\", CreditCard.table_name\n    assert_equal \"categories\", Category.table_name\n  ensure\n    CreditCard.pluralize_table_names = true\n    CreditCard.reset_table_name\n  end\n\n  if current_adapter?(:MysqlAdapter) or current_adapter?(:Mysql2Adapter)\n    def test_update_all_with_order_and_limit\n      assert_equal 1, Topic.update_all(\"content = 'bulk updated!'\", nil, :limit => 1, :order => 'id DESC')\n    end\n  end\n\n  def test_null_fields\n    assert_nil Topic.find(1).parent_id\n    assert_nil Topic.create(\"title\" => \"Hey you\").parent_id\n  end\n\n  def test_default_values\n    topic = Topic.new\n    assert topic.approved?\n    assert_nil topic.written_on\n    assert_nil topic.bonus_time\n    assert_nil topic.last_read\n\n    topic.save\n\n    topic = Topic.find(topic.id)\n    assert topic.approved?\n    assert_nil topic.last_read\n\n    # Oracle has some funky default handling, so it requires a bit of\n    # extra testing. See ticket #2788.\n    if current_adapter?(:OracleAdapter)\n      test = TestOracleDefault.new\n      assert_equal \"X\", test.test_char\n      assert_equal \"hello\", test.test_string\n      assert_equal 3, test.test_int\n    end\n  end\n\n  # Oracle, and Sybase do not have a TIME datatype.\n  unless current_adapter?(:OracleAdapter, :SybaseAdapter)\n    def test_utc_as_time_zone\n      Topic.default_timezone = :utc\n      attributes = { \"bonus_time\" => \"5:42:00AM\" }\n      topic = Topic.find(1)\n      topic.attributes = attributes\n      assert_equal Time.utc(2000, 1, 1, 5, 42, 0), topic.bonus_time\n      Topic.default_timezone = :local\n    end\n\n    def test_utc_as_time_zone_and_new\n      Topic.default_timezone = :utc\n      attributes = { \"bonus_time(1i)\"=>\"2000\",\n                     \"bonus_time(2i)\"=>\"1\",\n                     \"bonus_time(3i)\"=>\"1\",\n                     \"bonus_time(4i)\"=>\"10\",\n                     \"bonus_time(5i)\"=>\"35\",\n                     \"bonus_time(6i)\"=>\"50\" }\n      topic = Topic.new(attributes)\n      assert_equal Time.utc(2000, 1, 1, 10, 35, 50), topic.bonus_time\n      Topic.default_timezone = :local\n    end\n  end\n\n  def test_default_values_on_empty_strings\n    topic = Topic.new\n    topic.approved  = nil\n    topic.last_read = nil\n\n    topic.save\n\n    topic = Topic.find(topic.id)\n    assert_nil topic.last_read\n\n    # Sybase adapter does not allow nulls in boolean columns\n    if current_adapter?(:SybaseAdapter)\n      assert topic.approved == false\n    else\n      assert_nil topic.approved\n    end\n  end\n\n  def test_equality\n    assert_equal Topic.find(1), Topic.find(2).topic\n  end\n\n  def test_find_by_slug\n    assert_equal Topic.find('1-meowmeow'), Topic.find(1)\n  end\n\n  def test_equality_of_new_records\n    assert_not_equal Topic.new, Topic.new\n  end\n\n  def test_equality_of_destroyed_records\n    topic_1 = Topic.new(:title => 'test_1')\n    topic_1.save\n    topic_2 = Topic.find(topic_1.id)\n    topic_1.destroy\n    assert_equal topic_1, topic_2\n    assert_equal topic_2, topic_1\n  end\n\n  def test_hashing\n    assert_equal [ Topic.find(1) ], [ Topic.find(2).topic ] & [ Topic.find(1) ]\n  end\n\n  def test_comparison\n    topic_1 = Topic.create!\n    topic_2 = Topic.create!\n\n    assert_equal [topic_2, topic_1].sort, [topic_1, topic_2]\n  end\n\n  def test_comparison_with_different_objects\n    topic = Topic.create\n    category = Category.create(:name => \"comparison\")\n    assert_nil topic <=> category\n  end\n\n  def test_readonly_attributes\n    assert_equal Set.new([ 'title' , 'comments_count' ]), ReadonlyTitlePost.readonly_attributes\n\n    post = ReadonlyTitlePost.create(:title => \"cannot change this\", :body => \"changeable\")\n    post.reload\n    assert_equal \"cannot change this\", post.title\n\n    post.update_attributes(:title => \"try to change\", :body => \"changed\")\n    post.reload\n    assert_equal \"cannot change this\", post.title\n    assert_equal \"changed\", post.body\n  end\n\n  def test_non_valid_identifier_column_name\n    weird = Weird.create('a$b' => 'value')\n    weird.reload\n    assert_equal 'value', weird.send('a$b')\n\n    weird.update_column('a$b', 'value2')\n    weird.reload\n    assert_equal 'value2', weird.send('a$b')\n  end\n\n  def test_multiparameter_attributes_on_date\n    attributes = { \"last_read(1i)\" => \"2004\", \"last_read(2i)\" => \"6\", \"last_read(3i)\" => \"24\" }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    # note that extra #to_date call allows test to pass for Oracle, which\n    # treats dates/times the same\n    assert_date_from_db Date.new(2004, 6, 24), topic.last_read.to_date\n  end\n\n  def test_multiparameter_attributes_on_date_with_empty_year\n    attributes = { \"last_read(1i)\" => \"\", \"last_read(2i)\" => \"6\", \"last_read(3i)\" => \"24\" }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    # note that extra #to_date call allows test to pass for Oracle, which\n    # treats dates/times the same\n    assert_nil topic.last_read\n  end\n\n  def test_multiparameter_attributes_on_date_with_empty_month\n    attributes = { \"last_read(1i)\" => \"2004\", \"last_read(2i)\" => \"\", \"last_read(3i)\" => \"24\" }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    # note that extra #to_date call allows test to pass for Oracle, which\n    # treats dates/times the same\n    assert_nil topic.last_read\n  end\n\n  def test_multiparameter_attributes_on_date_with_empty_day\n    attributes = { \"last_read(1i)\" => \"2004\", \"last_read(2i)\" => \"6\", \"last_read(3i)\" => \"\" }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    # note that extra #to_date call allows test to pass for Oracle, which\n    # treats dates/times the same\n    assert_nil topic.last_read\n  end\n\n  def test_multiparameter_attributes_on_date_with_empty_day_and_year\n    attributes = { \"last_read(1i)\" => \"\", \"last_read(2i)\" => \"6\", \"last_read(3i)\" => \"\" }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    # note that extra #to_date call allows test to pass for Oracle, which\n    # treats dates/times the same\n    assert_nil topic.last_read\n  end\n\n  def test_multiparameter_attributes_on_date_with_empty_day_and_month\n    attributes = { \"last_read(1i)\" => \"2004\", \"last_read(2i)\" => \"\", \"last_read(3i)\" => \"\" }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    # note that extra #to_date call allows test to pass for Oracle, which\n    # treats dates/times the same\n    assert_nil topic.last_read\n  end\n\n  def test_multiparameter_attributes_on_date_with_empty_year_and_month\n    attributes = { \"last_read(1i)\" => \"\", \"last_read(2i)\" => \"\", \"last_read(3i)\" => \"24\" }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    # note that extra #to_date call allows test to pass for Oracle, which\n    # treats dates/times the same\n    assert_nil topic.last_read\n  end\n\n  def test_multiparameter_attributes_on_date_with_all_empty\n    attributes = { \"last_read(1i)\" => \"\", \"last_read(2i)\" => \"\", \"last_read(3i)\" => \"\" }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_nil topic.last_read\n  end\n\n  def test_multiparameter_attributes_on_time\n    attributes = {\n      \"written_on(1i)\" => \"2004\", \"written_on(2i)\" => \"6\", \"written_on(3i)\" => \"24\",\n      \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"24\", \"written_on(6i)\" => \"00\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_equal Time.local(2004, 6, 24, 16, 24, 0), topic.written_on\n  end\n\n  def test_multiparameter_attributes_on_time_with_no_date\n    ex = assert_raise(ActiveRecord::MultiparameterAssignmentErrors) do\n      attributes = {\n        \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"24\", \"written_on(6i)\" => \"00\"\n      }\n      topic = Topic.find(1)\n      topic.attributes = attributes\n    end\n    assert_equal(\"written_on\", ex.errors[0].attribute)\n  end\n\n  def test_multiparameter_attributes_on_time_with_invalid_time_params\n    ex = assert_raise(ActiveRecord::MultiparameterAssignmentErrors) do\n      attributes = {\n        \"written_on(1i)\" => \"2004\", \"written_on(2i)\" => \"6\", \"written_on(3i)\" => \"24\",\n        \"written_on(4i)\" => \"2004\", \"written_on(5i)\" => \"36\", \"written_on(6i)\" => \"64\",\n      }\n      topic = Topic.find(1)\n      topic.attributes = attributes\n    end\n    assert_equal(\"written_on\", ex.errors[0].attribute)\n  end\n\n  def test_multiparameter_attributes_on_time_with_old_date\n    attributes = {\n      \"written_on(1i)\" => \"1850\", \"written_on(2i)\" => \"6\", \"written_on(3i)\" => \"24\",\n      \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"24\", \"written_on(6i)\" => \"00\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    # testing against to_s(:db) representation because either a Time or a DateTime might be returned, depending on platform\n    assert_equal \"1850-06-24 16:24:00\", topic.written_on.to_s(:db)\n  end\n\n  def test_multiparameter_attributes_on_time_will_raise_on_big_time_if_missing_date_parts\n    ex = assert_raise(ActiveRecord::MultiparameterAssignmentErrors) do\n      attributes = {\n        \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"24\"\n      }\n      topic = Topic.find(1)\n      topic.attributes = attributes\n    end\n    assert_equal(\"written_on\", ex.errors[0].attribute)\n  end\n\n  def test_multiparameter_attributes_on_time_with_raise_on_small_time_if_missing_date_parts\n    ex = assert_raise(ActiveRecord::MultiparameterAssignmentErrors) do\n      attributes = {\n        \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"12\", \"written_on(6i)\" => \"02\"\n      }\n      topic = Topic.find(1)\n      topic.attributes = attributes\n    end\n    assert_equal(\"written_on\", ex.errors[0].attribute)\n  end\n\n  def test_multiparameter_attributes_on_time_will_ignore_hour_if_missing\n    attributes = {\n      \"written_on(1i)\" => \"2004\", \"written_on(2i)\" => \"12\", \"written_on(3i)\" => \"12\",\n      \"written_on(5i)\" => \"12\", \"written_on(6i)\" => \"02\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_equal Time.local(2004, 12, 12, 0, 12, 2), topic.written_on\n  end\n\n  def test_multiparameter_attributes_on_time_will_ignore_hour_if_blank\n    attributes = {\n      \"written_on(1i)\" => \"\", \"written_on(2i)\" => \"\", \"written_on(3i)\" => \"\",\n      \"written_on(4i)\" => \"\", \"written_on(5i)\" => \"12\", \"written_on(6i)\" => \"02\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_nil topic.written_on\n  end\n\n  def test_multiparameter_attributes_on_time_will_ignore_date_if_empty\n    attributes = {\n      \"written_on(1i)\" => \"\", \"written_on(2i)\" => \"\", \"written_on(3i)\" => \"\",\n      \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"24\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_nil topic.written_on\n  end\n  def test_multiparameter_attributes_on_time_with_seconds_will_ignore_date_if_empty\n    attributes = {\n      \"written_on(1i)\" => \"\", \"written_on(2i)\" => \"\", \"written_on(3i)\" => \"\",\n      \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"12\", \"written_on(6i)\" => \"02\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_nil topic.written_on\n  end\n\n  def test_multiparameter_attributes_on_time_with_utc\n    ActiveRecord::Base.default_timezone = :utc\n    attributes = {\n      \"written_on(1i)\" => \"2004\", \"written_on(2i)\" => \"6\", \"written_on(3i)\" => \"24\",\n      \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"24\", \"written_on(6i)\" => \"00\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_equal Time.utc(2004, 6, 24, 16, 24, 0), topic.written_on\n  ensure\n    ActiveRecord::Base.default_timezone = :local\n  end\n\n  def test_multiparameter_attributes_on_time_with_time_zone_aware_attributes\n    ActiveRecord::Base.time_zone_aware_attributes = true\n    ActiveRecord::Base.default_timezone = :utc\n    Time.zone = ActiveSupport::TimeZone[-28800]\n    attributes = {\n      \"written_on(1i)\" => \"2004\", \"written_on(2i)\" => \"6\", \"written_on(3i)\" => \"24\",\n      \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"24\", \"written_on(6i)\" => \"00\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_equal Time.utc(2004, 6, 24, 23, 24, 0), topic.written_on\n    assert_equal Time.utc(2004, 6, 24, 16, 24, 0), topic.written_on.time\n    assert_equal Time.zone, topic.written_on.time_zone\n  ensure\n    ActiveRecord::Base.time_zone_aware_attributes = false\n    ActiveRecord::Base.default_timezone = :local\n    Time.zone = nil\n  end\n\n  def test_multiparameter_attributes_on_time_with_time_zone_aware_attributes_false\n    ActiveRecord::Base.time_zone_aware_attributes = false\n    Time.zone = ActiveSupport::TimeZone[-28800]\n    attributes = {\n      \"written_on(1i)\" => \"2004\", \"written_on(2i)\" => \"6\", \"written_on(3i)\" => \"24\",\n      \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"24\", \"written_on(6i)\" => \"00\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_equal Time.local(2004, 6, 24, 16, 24, 0), topic.written_on\n    assert_equal false, topic.written_on.respond_to?(:time_zone)\n  ensure\n    Time.zone = nil\n  end\n\n  def test_multiparameter_attributes_on_time_with_skip_time_zone_conversion_for_attributes\n    ActiveRecord::Base.time_zone_aware_attributes = true\n    ActiveRecord::Base.default_timezone = :utc\n    Time.zone = ActiveSupport::TimeZone[-28800]\n    Topic.skip_time_zone_conversion_for_attributes = [:written_on]\n    attributes = {\n      \"written_on(1i)\" => \"2004\", \"written_on(2i)\" => \"6\", \"written_on(3i)\" => \"24\",\n      \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"24\", \"written_on(6i)\" => \"00\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_equal Time.utc(2004, 6, 24, 16, 24, 0), topic.written_on\n    assert_equal false, topic.written_on.respond_to?(:time_zone)\n  ensure\n    ActiveRecord::Base.time_zone_aware_attributes = false\n    ActiveRecord::Base.default_timezone = :local\n    Time.zone = nil\n    Topic.skip_time_zone_conversion_for_attributes = []\n  end\n\n  # Oracle, and Sybase do not have a TIME datatype.\n  unless current_adapter?(:OracleAdapter, :SybaseAdapter)\n    def test_multiparameter_attributes_on_time_only_column_with_time_zone_aware_attributes_does_not_do_time_zone_conversion\n      ActiveRecord::Base.time_zone_aware_attributes = true\n      ActiveRecord::Base.default_timezone = :utc\n      Time.zone = ActiveSupport::TimeZone[-28800]\n      attributes = {\n        \"bonus_time(1i)\" => \"2000\", \"bonus_time(2i)\" => \"1\", \"bonus_time(3i)\" => \"1\",\n        \"bonus_time(4i)\" => \"16\", \"bonus_time(5i)\" => \"24\"\n      }\n      topic = Topic.find(1)\n      topic.attributes = attributes\n      assert_equal Time.utc(2000, 1, 1, 16, 24, 0), topic.bonus_time\n      assert topic.bonus_time.utc?\n    ensure\n      ActiveRecord::Base.time_zone_aware_attributes = false\n      ActiveRecord::Base.default_timezone = :local\n      Time.zone = nil\n    end\n  end\n\n  def test_multiparameter_attributes_on_time_with_empty_seconds\n    attributes = {\n      \"written_on(1i)\" => \"2004\", \"written_on(2i)\" => \"6\", \"written_on(3i)\" => \"24\",\n      \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"24\", \"written_on(6i)\" => \"\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_equal Time.local(2004, 6, 24, 16, 24, 0), topic.written_on\n  end\n\n  def test_multiparameter_assignment_of_aggregation\n    customer = Customer.new\n    address = Address.new(\"The Street\", \"The City\", \"The Country\")\n    attributes = { \"address(1)\" => address.street, \"address(2)\" => address.city, \"address(3)\" => address.country }\n    customer.attributes = attributes\n    assert_equal address, customer.address\n  end\n\n  def test_multiparameter_assignment_of_aggregation_out_of_order\n    customer = Customer.new\n    address = Address.new(\"The Street\", \"The City\", \"The Country\")\n    attributes = { \"address(3)\" => address.country, \"address(2)\" => address.city, \"address(1)\" => address.street }\n    customer.attributes = attributes\n    assert_equal address, customer.address\n  end\n\n  def test_multiparameter_assignment_of_aggregation_with_missing_values\n    ex = assert_raise(ActiveRecord::MultiparameterAssignmentErrors) do\n      customer = Customer.new\n      address = Address.new(\"The Street\", \"The City\", \"The Country\")\n      attributes = { \"address(2)\" => address.city, \"address(3)\" => address.country }\n      customer.attributes = attributes\n    end\n    assert_equal(\"address\", ex.errors[0].attribute)\n  end\n\n  def test_multiparameter_assignment_of_aggregation_with_blank_values\n    customer = Customer.new\n    address = Address.new(\"The Street\", \"The City\", \"The Country\")\n    attributes = { \"address(1)\" => \"\", \"address(2)\" => address.city, \"address(3)\" => address.country }\n    customer.attributes = attributes\n    assert_equal Address.new(nil, \"The City\", \"The Country\"), customer.address\n  end\n\n  def test_multiparameter_assignment_of_aggregation_with_large_index\n    ex = assert_raise(ActiveRecord::MultiparameterAssignmentErrors) do\n      customer = Customer.new\n      address = Address.new(\"The Street\", \"The City\", \"The Country\")\n      attributes = { \"address(1)\" => \"The Street\", \"address(2)\" => address.city, \"address(3000)\" => address.country }\n      customer.attributes = attributes\n    end\n    assert_equal(\"address\", ex.errors[0].attribute)\n  end\n\n  def test_attributes_on_dummy_time\n    # Oracle, and Sybase do not have a TIME datatype.\n    return true if current_adapter?(:OracleAdapter, :SybaseAdapter)\n\n    attributes = {\n      \"bonus_time\" => \"5:42:00AM\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_equal Time.local(2000, 1, 1, 5, 42, 0), topic.bonus_time\n  end\n\n  def test_boolean\n    b_nil = Boolean.create({ \"value\" => nil })\n    nil_id = b_nil.id\n    b_false = Boolean.create({ \"value\" => false })\n    false_id = b_false.id\n    b_true = Boolean.create({ \"value\" => true })\n    true_id = b_true.id\n\n    b_nil = Boolean.find(nil_id)\n    assert_nil b_nil.value\n    b_false = Boolean.find(false_id)\n    assert !b_false.value?\n    b_true = Boolean.find(true_id)\n    assert b_true.value?\n  end\n\n  def test_boolean_cast_from_string\n    b_blank = Boolean.create({ \"value\" => \"\" })\n    blank_id = b_blank.id\n    b_false = Boolean.create({ \"value\" => \"0\" })\n    false_id = b_false.id\n    b_true = Boolean.create({ \"value\" => \"1\" })\n    true_id = b_true.id\n\n    b_blank = Boolean.find(blank_id)\n    assert_nil b_blank.value\n    b_false = Boolean.find(false_id)\n    assert !b_false.value?\n    b_true = Boolean.find(true_id)\n    assert b_true.value?\n  end\n\n  def test_new_record_returns_boolean\n    assert_equal false, Topic.new.persisted?\n    assert_equal true, Topic.find(1).persisted?\n  end\n\n  def test_dup\n    topic = Topic.find(1)\n    duped_topic = nil\n    assert_nothing_raised { duped_topic = topic.dup }\n    assert_equal topic.title, duped_topic.title\n    assert !duped_topic.persisted?\n\n    # test if the attributes have been duped\n    topic.title = \"a\"\n    duped_topic.title = \"b\"\n    assert_equal \"a\", topic.title\n    assert_equal \"b\", duped_topic.title\n\n    # test if the attribute values have been duped\n    topic.title = {\"a\" => \"b\"}\n    duped_topic = topic.dup\n    duped_topic.title[\"a\"] = \"c\"\n    assert_equal \"b\", topic.title[\"a\"]\n\n    # test if attributes set as part of after_initialize are duped correctly\n    assert_equal topic.author_email_address, duped_topic.author_email_address\n\n    # test if saved clone object differs from original\n    duped_topic.save\n    assert duped_topic.persisted?\n    assert_not_equal duped_topic.id, topic.id\n\n    duped_topic.reload\n    # FIXME: I think this is poor behavior, and will fix it with #5686\n    assert_equal({'a' => 'c'}.to_yaml, duped_topic.title)\n  end\n\n  def test_dup_with_aggregate_of_same_name_as_attribute\n    dev = DeveloperWithAggregate.find(1)\n    assert_kind_of DeveloperSalary, dev.salary\n\n    dup = nil\n    assert_nothing_raised { dup = dev.dup }\n    assert_kind_of DeveloperSalary, dup.salary\n    assert_equal dev.salary.amount, dup.salary.amount\n    assert !dup.persisted?\n\n    # test if the attributes have been dupd\n    original_amount = dup.salary.amount\n    dev.salary.amount = 1\n    assert_equal original_amount, dup.salary.amount\n\n    assert dup.save\n    assert dup.persisted?\n    assert_not_equal dup.id, dev.id\n  end\n\n  def test_dup_does_not_copy_associations\n    author = authors(:david)\n    assert_not_equal [], author.posts\n    author.send(:clear_association_cache)\n\n    author_dup = author.dup\n    assert_equal [], author_dup.posts\n  end\n\n  def test_clone_preserves_subtype\n    clone = nil\n    assert_nothing_raised { clone = Company.find(3).clone }\n    assert_kind_of Client, clone\n  end\n\n  def test_clone_of_new_object_with_defaults\n    developer = Developer.new\n    assert !developer.name_changed?\n    assert !developer.salary_changed?\n\n    cloned_developer = developer.clone\n    assert !cloned_developer.name_changed?\n    assert !cloned_developer.salary_changed?\n  end\n\n  def test_clone_of_new_object_marks_attributes_as_dirty\n    developer = Developer.new :name => 'Bjorn', :salary => 100000\n    assert developer.name_changed?\n    assert developer.salary_changed?\n\n    cloned_developer = developer.clone\n    assert cloned_developer.name_changed?\n    assert cloned_developer.salary_changed?\n  end\n\n  def test_clone_of_new_object_marks_as_dirty_only_changed_attributes\n    developer = Developer.new :name => 'Bjorn'\n    assert developer.name_changed?            # obviously\n    assert !developer.salary_changed?         # attribute has non-nil default value, so treated as not changed\n\n    cloned_developer = developer.clone\n    assert cloned_developer.name_changed?\n    assert !cloned_developer.salary_changed?  # ... and cloned instance should behave same\n  end\n\n  def test_dup_of_saved_object_marks_attributes_as_dirty\n    developer = Developer.create! :name => 'Bjorn', :salary => 100000\n    assert !developer.name_changed?\n    assert !developer.salary_changed?\n\n    cloned_developer = developer.dup\n    assert cloned_developer.name_changed?     # both attributes differ from defaults\n    assert cloned_developer.salary_changed?\n  end\n\n  def test_dup_of_saved_object_marks_as_dirty_only_changed_attributes\n    developer = Developer.create! :name => 'Bjorn'\n    assert !developer.name_changed?           # both attributes of saved object should be treated as not changed\n    assert !developer.salary_changed?\n\n    cloned_developer = developer.dup\n    assert cloned_developer.name_changed?     # ... but on cloned object should be\n    assert !cloned_developer.salary_changed?  # ... BUT salary has non-nil default which should be treated as not changed on cloned instance\n  end\n\n  def test_bignum\n    company = Company.find(1)\n    company.rating = 2147483647\n    company.save\n    company = Company.find(1)\n    assert_equal 2147483647, company.rating\n  end\n\n  # TODO: extend defaults tests to other databases!\n  if current_adapter?(:PostgreSQLAdapter)\n    def test_default\n      default = Default.new\n\n      # fixed dates / times\n      assert_equal Date.new(2004, 1, 1), default.fixed_date\n      assert_equal Time.local(2004, 1,1,0,0,0,0), default.fixed_time\n\n      # char types\n      assert_equal 'Y', default.char1\n      assert_equal 'a varchar field', default.char2\n      assert_equal 'a text field', default.char3\n    end\n\n    class Geometric < ActiveRecord::Base; end\n    def test_geometric_content\n\n      # accepted format notes:\n      # ()'s aren't required\n      # values can be a mix of float or integer\n\n      g = Geometric.new(\n        :a_point        => '(5.0, 6.1)',\n        #:a_line         => '((2.0, 3), (5.5, 7.0))' # line type is currently unsupported in postgresql\n        :a_line_segment => '(2.0, 3), (5.5, 7.0)',\n        :a_box          => '2.0, 3, 5.5, 7.0',\n        :a_path         => '[(2.0, 3), (5.5, 7.0), (8.5, 11.0)]',  # [ ] is an open path\n        :a_polygon      => '((2.0, 3), (5.5, 7.0), (8.5, 11.0))',\n        :a_circle       => '<(5.3, 10.4), 2>'\n      )\n\n      assert g.save\n\n      # Reload and check that we have all the geometric attributes.\n      h = ActiveRecord::IdentityMap.without { Geometric.find(g.id) }\n\n      assert_equal '(5,6.1)', h.a_point\n      assert_equal '[(2,3),(5.5,7)]', h.a_line_segment\n      assert_equal '(5.5,7),(2,3)', h.a_box   # reordered to store upper right corner then bottom left corner\n      assert_equal '[(2,3),(5.5,7),(8.5,11)]', h.a_path\n      assert_equal '((2,3),(5.5,7),(8.5,11))', h.a_polygon\n      assert_equal '<(5.3,10.4),2>', h.a_circle\n\n      # use a geometric function to test for an open path\n      objs = Geometric.find_by_sql [\"select isopen(a_path) from geometrics where id = ?\", g.id]\n      assert_equal objs[0].isopen, 't'\n\n      # test alternate formats when defining the geometric types\n\n      g = Geometric.new(\n        :a_point        => '5.0, 6.1',\n        #:a_line         => '((2.0, 3), (5.5, 7.0))' # line type is currently unsupported in postgresql\n        :a_line_segment => '((2.0, 3), (5.5, 7.0))',\n        :a_box          => '(2.0, 3), (5.5, 7.0)',\n        :a_path         => '((2.0, 3), (5.5, 7.0), (8.5, 11.0))',  # ( ) is a closed path\n        :a_polygon      => '2.0, 3, 5.5, 7.0, 8.5, 11.0',\n        :a_circle       => '((5.3, 10.4), 2)'\n      )\n\n      assert g.save\n\n      # Reload and check that we have all the geometric attributes.\n      h = ActiveRecord::IdentityMap.without { Geometric.find(g.id) }\n\n      assert_equal '(5,6.1)', h.a_point\n      assert_equal '[(2,3),(5.5,7)]', h.a_line_segment\n      assert_equal '(5.5,7),(2,3)', h.a_box   # reordered to store upper right corner then bottom left corner\n      assert_equal '((2,3),(5.5,7),(8.5,11))', h.a_path\n      assert_equal '((2,3),(5.5,7),(8.5,11))', h.a_polygon\n      assert_equal '<(5.3,10.4),2>', h.a_circle\n\n      # use a geometric function to test for an closed path\n      objs = Geometric.find_by_sql [\"select isclosed(a_path) from geometrics where id = ?\", g.id]\n      assert_equal objs[0].isclosed, 't'\n    end\n  end\n\n  class NumericData < ActiveRecord::Base\n    self.table_name = 'numeric_data'\n  end\n\n  def test_big_decimal_conditions\n    m = NumericData.new(\n      :bank_balance => 1586.43,\n      :big_bank_balance => BigDecimal(\"1000234000567.95\"),\n      :world_population => 6000000000,\n      :my_house_population => 3\n    )\n    assert m.save\n    assert_equal 0, NumericData.where(\"bank_balance > ?\", 2000.0).count\n  end\n\n  def test_numeric_fields\n    m = NumericData.new(\n      :bank_balance => 1586.43,\n      :big_bank_balance => BigDecimal(\"1000234000567.95\"),\n      :world_population => 6000000000,\n      :my_house_population => 3\n    )\n    assert m.save\n\n    m1 = NumericData.find(m.id)\n    assert_not_nil m1\n\n    # As with migration_test.rb, we should make world_population >= 2**62\n    # to cover 64-bit platforms and test it is a Bignum, but the main thing\n    # is that it's an Integer.\n    assert_kind_of Integer, m1.world_population\n    assert_equal 6000000000, m1.world_population\n\n    assert_kind_of Fixnum, m1.my_house_population\n    assert_equal 3, m1.my_house_population\n\n    assert_kind_of BigDecimal, m1.bank_balance\n    assert_equal BigDecimal(\"1586.43\"), m1.bank_balance\n\n    assert_kind_of BigDecimal, m1.big_bank_balance\n    assert_equal BigDecimal(\"1000234000567.95\"), m1.big_bank_balance\n  end\n\n  def test_auto_id\n    auto = AutoId.new\n    auto.save\n    assert(auto.id > 0)\n  end\n\n  def quote_column_name(name)\n    \"<#{name}>\"\n  end\n\n  def test_quote_keys\n    ar = AutoId.new\n    source = {\"foo\" => \"bar\", \"baz\" => \"quux\"}\n    actual = ar.send(:quote_columns, self, source)\n    inverted = actual.invert\n    assert_equal(\"<foo>\", inverted[\"bar\"])\n    assert_equal(\"<baz>\", inverted[\"quux\"])\n  end\n\n  def test_sql_injection_via_find\n    assert_raise(ActiveRecord::RecordNotFound, ActiveRecord::StatementInvalid) do\n      Topic.find(\"123456 OR id > 0\")\n    end\n  end\n\n  def test_column_name_properly_quoted\n    col_record = ColumnName.new\n    col_record.references = 40\n    assert col_record.save\n    col_record.references = 41\n    assert col_record.save\n    assert_not_nil c2 = ColumnName.find(col_record.id)\n    assert_equal(41, c2.references)\n  end\n\n  def test_quoting_arrays\n    replies = Reply.find(:all, :conditions => [ \"id IN (?)\", topics(:first).replies.collect(&:id) ])\n    assert_equal topics(:first).replies.size, replies.size\n\n    replies = Reply.find(:all, :conditions => [ \"id IN (?)\", [] ])\n    assert_equal 0, replies.size\n  end\n\n  MyObject = Struct.new :attribute1, :attribute2\n\n  def test_serialized_attribute\n    Topic.serialize(\"content\", MyObject)\n\n    myobj = MyObject.new('value1', 'value2')\n    topic = Topic.create(\"content\" => myobj)\n    assert_equal(myobj, topic.content)\n\n    topic.reload\n    assert_equal(myobj, topic.content)\n  end\n\n  def test_serialized_time_attribute\n    myobj = Time.local(2008,1,1,1,0)\n    topic = Topic.create(\"content\" => myobj).reload\n    assert_equal(myobj, topic.content)\n  end\n\n  def test_serialized_string_attribute\n    myobj = \"Yes\"\n    topic = Topic.create(\"content\" => myobj).reload\n    assert_equal(myobj, topic.content)\n  end\n\n  def test_nil_serialized_attribute_with_class_constraint\n    topic = Topic.new\n    assert_nil topic.content\n  end\n\n  def test_should_raise_exception_on_serialized_attribute_with_type_mismatch\n    myobj = MyObject.new('value1', 'value2')\n    topic = Topic.new(:content => myobj)\n    assert topic.save\n    Topic.serialize(:content, Hash)\n    assert_raise(ActiveRecord::SerializationTypeMismatch) { Topic.find(topic.id).reload.content }\n  ensure\n    Topic.serialize(:content)\n  end\n\n  def test_serialized_attribute_with_class_constraint\n    settings = { \"color\" => \"blue\" }\n    Topic.serialize(:content, Hash)\n    topic = Topic.new(:content => settings)\n    assert topic.save\n    assert_equal(settings, Topic.find(topic.id).content)\n  ensure\n    Topic.serialize(:content)\n  end\n\n  def test_serialized_default_class\n    Topic.serialize(:content, Hash)\n    topic = Topic.new\n    assert_equal Hash, topic.content.class\n    assert_equal Hash, topic.read_attribute(:content).class\n    topic.content[\"beer\"] = \"MadridRb\"\n    assert topic.save\n    topic.reload\n    assert_equal Hash, topic.content.class\n    assert_equal \"MadridRb\", topic.content[\"beer\"]\n  ensure\n    Topic.serialize(:content)\n  end\n\n  def test_serialized_no_default_class_for_object\n    topic = Topic.new\n    assert_nil topic.content\n  end\n\n  def test_serialized_boolean_value_true\n    Topic.serialize(:content)\n    topic = Topic.new(:content => true)\n    assert topic.save\n    topic = topic.reload\n    assert_equal topic.content, true\n  end\n\n  def test_serialized_boolean_value_false\n    Topic.serialize(:content)\n    topic = Topic.new(:content => false)\n    assert topic.save\n    topic = topic.reload\n    assert_equal topic.content, false\n  end\n\n  def test_serialize_with_coder\n    coder = Class.new {\n      # Identity\n      def load(thing)\n        thing\n      end\n\n      # base 64\n      def dump(thing)\n        [thing].pack('m')\n      end\n    }.new\n\n    Topic.serialize(:content, coder)\n    s = 'hello world'\n    topic = Topic.new(:content => s)\n    assert topic.save\n    topic = topic.reload\n    assert_equal [s].pack('m'), topic.content\n  ensure\n    Topic.serialize(:content)\n  end\n\n  def test_serialize_with_bcrypt_coder\n    crypt_coder = Class.new {\n      def load(thing)\n        return unless thing\n        BCrypt::Password.new thing\n      end\n\n      def dump(thing)\n        BCrypt::Password.create(thing).to_s\n      end\n    }.new\n\n    Topic.serialize(:content, crypt_coder)\n    password = 'password'\n    topic = Topic.new(:content => password)\n    assert topic.save\n    topic = topic.reload\n    assert_kind_of BCrypt::Password, topic.content\n    assert_equal(true, topic.content == password, 'password should equal')\n  ensure\n    Topic.serialize(:content)\n  end\n\n  def test_quote\n    author_name = \"\\\\ \\001 ' \\n \\\\n \\\"\"\n    topic = Topic.create('author_name' => author_name)\n    assert_equal author_name, Topic.find(topic.id).author_name\n  end\n\n  if RUBY_VERSION < '1.9'\n    def test_quote_chars\n      with_kcode('UTF8') do\n        str = 'The Narrator'\n        topic = Topic.create(:author_name => str)\n        assert_equal str, topic.author_name\n\n        assert_kind_of ActiveSupport::Multibyte.proxy_class, str.mb_chars\n        topic = Topic.find_by_author_name(str.mb_chars)\n\n        assert_kind_of Topic, topic\n        assert_equal str, topic.author_name, \"The right topic should have been found by name even with name passed as Chars\"\n      end\n    end\n  end\n\n  def test_toggle_attribute\n    assert !topics(:first).approved?\n    topics(:first).toggle!(:approved)\n    assert topics(:first).approved?\n    topic = topics(:first)\n    topic.toggle(:approved)\n    assert !topic.approved?\n    topic.reload\n    assert topic.approved?\n  end\n\n  def test_reload\n    t1 = Topic.find(1)\n    t2 = Topic.find(1)\n    t1.title = \"something else\"\n    t1.save\n    t2.reload\n    assert_equal t1.title, t2.title\n  end\n\n  def test_reload_with_exclusive_scope\n    dev = DeveloperCalledDavid.first\n    dev.update_attributes!( :name => \"NotDavid\" )\n    assert_equal dev, dev.reload\n  end\n\n  def test_define_attr_method_with_value\n    k = Class.new( ActiveRecord::Base )\n    k.send(:define_attr_method, :table_name, \"foo\")\n    assert_equal \"foo\", k.table_name\n  end\n\n  def test_define_attr_method_with_block\n    k = Class.new( ActiveRecord::Base ) do\n      class << self\n        attr_accessor :foo_key\n      end\n    end\n    k.foo_key = \"id\"\n    k.send(:define_attr_method, :foo_key) { \"sys_\" + original_foo_key }\n    assert_equal \"sys_id\", k.foo_key\n  end\n\n  def test_set_table_name_with_value\n    k = Class.new( ActiveRecord::Base )\n    k.table_name = \"foo\"\n    assert_equal \"foo\", k.table_name\n    k.set_table_name \"bar\"\n    assert_equal \"bar\", k.table_name\n  end\n\n  def test_switching_between_table_name\n    assert_difference(\"GoodJoke.count\") do\n      Joke.set_table_name \"cold_jokes\"\n      Joke.create\n\n      Joke.set_table_name \"funny_jokes\"\n      Joke.create\n    end\n  end\n\n  def test_quoted_table_name_after_set_table_name\n    klass = Class.new(ActiveRecord::Base)\n\n    klass.set_table_name \"foo\"\n    assert_equal \"foo\", klass.table_name\n    assert_equal klass.connection.quote_table_name(\"foo\"), klass.quoted_table_name\n\n    klass.set_table_name \"bar\"\n    assert_equal \"bar\", klass.table_name\n    assert_equal klass.connection.quote_table_name(\"bar\"), klass.quoted_table_name\n  end\n\n  def test_set_table_name_with_block\n    k = Class.new( ActiveRecord::Base )\n    k.set_table_name { \"ks\" }\n    assert_equal \"ks\", k.table_name\n  end\n\n  def test_set_primary_key_with_value\n    k = Class.new( ActiveRecord::Base )\n    k.primary_key = \"foo\"\n    assert_equal \"foo\", k.primary_key\n    k.set_primary_key \"bar\"\n    assert_equal \"bar\", k.primary_key\n  end\n\n  def test_set_primary_key_with_block\n    k = Class.new( ActiveRecord::Base )\n    k.primary_key = 'id'\n    k.set_primary_key { \"sys_\" + original_primary_key }\n    assert_equal \"sys_id\", k.primary_key\n  end\n\n  def test_set_inheritance_column_with_value\n    k = Class.new( ActiveRecord::Base )\n    k.inheritance_column = \"foo\"\n    assert_equal \"foo\", k.inheritance_column\n    k.set_inheritance_column \"bar\"\n    assert_equal \"bar\", k.inheritance_column\n  end\n\n  def test_set_inheritance_column_with_block\n    k = Class.new( ActiveRecord::Base )\n    k.set_inheritance_column { original_inheritance_column + \"_id\" }\n    assert_equal \"type_id\", k.inheritance_column\n  end\n\n  def test_count_with_join\n    res = Post.count_by_sql \"SELECT COUNT(*) FROM posts LEFT JOIN comments ON posts.id=comments.post_id WHERE posts.#{QUOTED_TYPE} = 'Post'\"\n\n    res2 = Post.count(:conditions => \"posts.#{QUOTED_TYPE} = 'Post'\", :joins => \"LEFT JOIN comments ON posts.id=comments.post_id\")\n    assert_equal res, res2\n\n    res3 = nil\n    assert_nothing_raised do\n      res3 = Post.count(:conditions => \"posts.#{QUOTED_TYPE} = 'Post'\",\n                        :joins => \"LEFT JOIN comments ON posts.id=comments.post_id\")\n    end\n    assert_equal res, res3\n\n    res4 = Post.count_by_sql \"SELECT COUNT(p.id) FROM posts p, comments co WHERE p.#{QUOTED_TYPE} = 'Post' AND p.id=co.post_id\"\n    res5 = nil\n    assert_nothing_raised do\n      res5 = Post.count(:conditions => \"p.#{QUOTED_TYPE} = 'Post' AND p.id=co.post_id\",\n                        :joins => \"p, comments co\",\n                        :select => \"p.id\")\n    end\n\n    assert_equal res4, res5\n\n    res6 = Post.count_by_sql \"SELECT COUNT(DISTINCT p.id) FROM posts p, comments co WHERE p.#{QUOTED_TYPE} = 'Post' AND p.id=co.post_id\"\n    res7 = nil\n    assert_nothing_raised do\n      res7 = Post.count(:conditions => \"p.#{QUOTED_TYPE} = 'Post' AND p.id=co.post_id\",\n                        :joins => \"p, comments co\",\n                        :select => \"p.id\",\n                        :distinct => true)\n    end\n    assert_equal res6, res7\n  end\n\n  def test_scoped_find_conditions\n    scoped_developers = Developer.send(:with_scope, :find => { :conditions => 'salary > 90000' }) do\n      Developer.find(:all, :conditions => 'id < 5')\n    end\n    assert !scoped_developers.include?(developers(:david)) # David's salary is less than 90,000\n    assert_equal 3, scoped_developers.size\n  end\n\n  def test_no_limit_offset\n    assert_nothing_raised do\n      Developer.find(:all, :offset => 2)\n    end\n  end\n\n  def test_scoped_find_limit_offset\n    scoped_developers = Developer.send(:with_scope, :find => { :limit => 3, :offset => 2 }) do\n      Developer.find(:all, :order => 'id')\n    end\n    assert !scoped_developers.include?(developers(:david))\n    assert !scoped_developers.include?(developers(:jamis))\n    assert_equal 3, scoped_developers.size\n\n    # Test without scoped find conditions to ensure we get the whole thing\n    developers = Developer.find(:all, :order => 'id')\n    assert_equal Developer.count, developers.size\n  end\n\n  def test_scoped_find_order\n    # Test order in scope\n    scoped_developers = Developer.send(:with_scope, :find => { :limit => 1, :order => 'salary DESC' }) do\n      Developer.find(:all)\n    end\n    assert_equal 'Jamis', scoped_developers.first.name\n    assert scoped_developers.include?(developers(:jamis))\n    # Test scope without order and order in find\n    scoped_developers = Developer.send(:with_scope, :find => { :limit => 1 }) do\n      Developer.find(:all, :order => 'salary DESC')\n    end\n    # Test scope order + find order, order has priority\n    scoped_developers = Developer.send(:with_scope, :find => { :limit => 3, :order => 'id DESC' }) do\n      Developer.find(:all, :order => 'salary ASC')\n    end\n    assert scoped_developers.include?(developers(:poor_jamis))\n    assert ! scoped_developers.include?(developers(:david))\n    assert ! scoped_developers.include?(developers(:jamis))\n    assert_equal 3, scoped_developers.size\n\n    # Test without scoped find conditions to ensure we get the right thing\n    assert ! scoped_developers.include?(Developer.find(1))\n    assert scoped_developers.include?(Developer.find(11))\n  end\n\n  def test_scoped_find_limit_offset_including_has_many_association\n    topics = Topic.send(:with_scope, :find => {:limit => 1, :offset => 1, :include => :replies}) do\n      Topic.find(:all, :order => \"topics.id\")\n    end\n    assert_equal 1, topics.size\n    assert_equal 2, topics.first.id\n  end\n\n  def test_scoped_find_order_including_has_many_association\n    developers = Developer.send(:with_scope, :find => { :order => 'developers.salary DESC', :include => :projects }) do\n      Developer.find(:all)\n    end\n    assert developers.size >= 2\n    for i in 1...developers.size\n      assert developers[i-1].salary >= developers[i].salary\n    end\n  end\n\n  def test_scoped_find_with_group_and_having\n    developers = Developer.send(:with_scope, :find => { :group => 'developers.salary', :having => \"SUM(salary) > 10000\", :select => \"SUM(salary) as salary\" }) do\n      Developer.find(:all)\n    end\n    assert_equal 3, developers.size\n  end\n\n  def test_find_last\n    last  = Developer.find :last\n    assert_equal last, Developer.find(:first, :order => 'id desc')\n  end\n\n  def test_last\n    assert_equal Developer.find(:first, :order => 'id desc'), Developer.last\n  end\n\n  def test_all\n    developers = Developer.all\n    assert_kind_of Array, developers\n    assert_equal Developer.find(:all), developers\n  end\n\n  def test_all_with_conditions\n    assert_equal Developer.find(:all, :order => 'id desc'), Developer.order('id desc').all\n  end\n\n  def test_find_ordered_last\n    last  = Developer.find :last, :order => 'developers.salary ASC'\n    assert_equal last, Developer.find(:all, :order => 'developers.salary ASC').last\n  end\n\n  def test_find_reverse_ordered_last\n    last  = Developer.find :last, :order => 'developers.salary DESC'\n    assert_equal last, Developer.find(:all, :order => 'developers.salary DESC').last\n  end\n\n  def test_find_multiple_ordered_last\n    last  = Developer.find :last, :order => 'developers.name, developers.salary DESC'\n    assert_equal last, Developer.find(:all, :order => 'developers.name, developers.salary DESC').last\n  end\n\n  def test_find_keeps_multiple_order_values\n    combined = Developer.find(:all, :order => 'developers.name, developers.salary')\n    assert_equal combined, Developer.find(:all, :order => ['developers.name', 'developers.salary'])\n  end\n\n  def test_find_keeps_multiple_group_values\n    combined = Developer.find(:all, :group => 'developers.name, developers.salary, developers.id, developers.created_at, developers.updated_at')\n    assert_equal combined, Developer.find(:all, :group => ['developers.name', 'developers.salary', 'developers.id', 'developers.created_at', 'developers.updated_at'])\n  end\n\n  def test_find_symbol_ordered_last\n    last  = Developer.find :last, :order => :salary\n    assert_equal last, Developer.find(:all, :order => :salary).last\n  end\n\n  def test_find_scoped_ordered_last\n    last_developer = Developer.send(:with_scope, :find => { :order => 'developers.salary ASC' }) do\n      Developer.find(:last)\n    end\n    assert_equal last_developer, Developer.find(:all, :order => 'developers.salary ASC').last\n  end\n\n  def test_abstract_class\n    assert !ActiveRecord::Base.abstract_class?\n    assert LoosePerson.abstract_class?\n    assert !LooseDescendant.abstract_class?\n  end\n\n  def test_base_class\n    assert_equal LoosePerson,     LoosePerson.base_class\n    assert_equal LooseDescendant, LooseDescendant.base_class\n    assert_equal TightPerson,     TightPerson.base_class\n    assert_equal TightPerson,     TightDescendant.base_class\n\n    assert_equal Post, Post.base_class\n    assert_equal Post, SpecialPost.base_class\n    assert_equal Post, StiPost.base_class\n    assert_equal SubStiPost, SubStiPost.base_class\n  end\n\n  def test_descends_from_active_record\n    # Tries to call Object.abstract_class?\n    assert_raise(NoMethodError) do\n      ActiveRecord::Base.descends_from_active_record?\n    end\n\n    # Abstract subclass of AR::Base.\n    assert LoosePerson.descends_from_active_record?\n\n    # Concrete subclass of an abstract class.\n    assert LooseDescendant.descends_from_active_record?\n\n    # Concrete subclass of AR::Base.\n    assert TightPerson.descends_from_active_record?\n\n    # Concrete subclass of a concrete class but has no type column.\n    assert TightDescendant.descends_from_active_record?\n\n    # Concrete subclass of AR::Base.\n    assert Post.descends_from_active_record?\n\n    # Abstract subclass of a concrete class which has a type column.\n    # This is pathological, as you'll never have Sub < Abstract < Concrete.\n    assert !StiPost.descends_from_active_record?\n\n    # Concrete subclasses an abstract class which has a type column.\n    assert !SubStiPost.descends_from_active_record?\n  end\n\n  def test_find_on_abstract_base_class_doesnt_use_type_condition\n    old_class = LooseDescendant\n    Object.send :remove_const, :LooseDescendant\n\n    descendant = old_class.create! :first_name => 'bob'\n    assert_not_nil LoosePerson.find(descendant.id), \"Should have found instance of LooseDescendant when finding abstract LoosePerson: #{descendant.inspect}\"\n  ensure\n    unless Object.const_defined?(:LooseDescendant)\n      Object.const_set :LooseDescendant, old_class\n    end\n  end\n\n  def test_assert_queries\n    query = lambda { ActiveRecord::Base.connection.execute 'select count(*) from developers' }\n    assert_queries(2) { 2.times { query.call } }\n    assert_queries 1, &query\n    assert_no_queries { assert true }\n  end\n\n  def test_to_param_should_return_string\n    assert_kind_of String, Client.find(:first).to_param\n  end\n\n  def test_inspect_class\n    assert_equal 'ActiveRecord::Base', ActiveRecord::Base.inspect\n    assert_equal 'LoosePerson(abstract)', LoosePerson.inspect\n    assert_match(/^Topic\\(id: integer, title: string/, Topic.inspect)\n  end\n\n  def test_inspect_instance\n    topic = topics(:first)\n    assert_equal %(#<Topic id: 1, title: \"The First Topic\", author_name: \"David\", author_email_address: \"david@loudthinking.com\", written_on: \"#{topic.written_on.to_s(:db)}\", bonus_time: \"#{topic.bonus_time.to_s(:db)}\", last_read: \"#{topic.last_read.to_s(:db)}\", content: \"Have a nice day\", approved: false, replies_count: 1, parent_id: nil, parent_title: nil, type: nil, group: nil, created_at: \"#{topic.created_at.to_s(:db)}\", updated_at: \"#{topic.updated_at.to_s(:db)}\">), topic.inspect\n  end\n\n  def test_inspect_new_instance\n    assert_match(/Topic id: nil/, Topic.new.inspect)\n  end\n\n  def test_inspect_limited_select_instance\n    assert_equal %(#<Topic id: 1>), Topic.find(:first, :select => 'id', :conditions => 'id = 1').inspect\n    assert_equal %(#<Topic id: 1, title: \"The First Topic\">), Topic.find(:first, :select => 'id, title', :conditions => 'id = 1').inspect\n  end\n\n  def test_inspect_class_without_table\n    assert_equal \"NonExistentTable(Table doesn't exist)\", NonExistentTable.inspect\n  end\n\n  def test_attribute_for_inspect\n    t = topics(:first)\n    t.title = \"The First Topic Now Has A Title With\\nNewlines And More Than 50 Characters\"\n\n    assert_equal %(\"#{t.written_on.to_s(:db)}\"), t.attribute_for_inspect(:written_on)\n    assert_equal '\"The First Topic Now Has A Title With\\nNewlines And M...\"', t.attribute_for_inspect(:title)\n  end\n\n  def test_becomes\n    assert_kind_of Reply, topics(:first).becomes(Reply)\n    assert_equal \"The First Topic\", topics(:first).becomes(Reply).title\n  end\n\n  def test_silence_sets_log_level_to_error_in_block\n    original_logger = ActiveRecord::Base.logger\n    log = StringIO.new\n    ActiveRecord::Base.logger = Logger.new(log)\n    ActiveRecord::Base.logger.level = Logger::DEBUG\n    ActiveRecord::Base.silence do\n      ActiveRecord::Base.logger.warn \"warn\"\n      ActiveRecord::Base.logger.error \"error\"\n    end\n    assert_equal \"error\\n\", log.string\n  ensure\n    ActiveRecord::Base.logger = original_logger\n  end\n\n  def test_silence_sets_log_level_back_to_level_before_yield\n    original_logger = ActiveRecord::Base.logger\n    log = StringIO.new\n    ActiveRecord::Base.logger = Logger.new(log)\n    ActiveRecord::Base.logger.level = Logger::WARN\n    ActiveRecord::Base.silence do\n    end\n    assert_equal Logger::WARN, ActiveRecord::Base.logger.level\n  ensure\n    ActiveRecord::Base.logger = original_logger\n  end\n\n  def test_benchmark_with_log_level\n    original_logger = ActiveRecord::Base.logger\n    log = StringIO.new\n    ActiveRecord::Base.logger = Logger.new(log)\n    ActiveRecord::Base.logger.level = Logger::WARN\n    ActiveRecord::Base.benchmark(\"Debug Topic Count\", :level => :debug) { Topic.count }\n    ActiveRecord::Base.benchmark(\"Warn Topic Count\",  :level => :warn)  { Topic.count }\n    ActiveRecord::Base.benchmark(\"Error Topic Count\", :level => :error) { Topic.count }\n    assert_no_match(/Debug Topic Count/, log.string)\n    assert_match(/Warn Topic Count/, log.string)\n    assert_match(/Error Topic Count/, log.string)\n  ensure\n    ActiveRecord::Base.logger = original_logger\n  end\n\n  def test_benchmark_with_use_silence\n    original_logger = ActiveRecord::Base.logger\n    log = StringIO.new\n    ActiveRecord::Base.logger = Logger.new(log)\n    ActiveRecord::Base.benchmark(\"Logging\", :level => :debug, :silence => true) { ActiveRecord::Base.logger.debug \"Loud\" }\n    ActiveRecord::Base.benchmark(\"Logging\", :level => :debug, :silence => false)  { ActiveRecord::Base.logger.debug \"Quiet\" }\n    assert_no_match(/Loud/, log.string)\n    assert_match(/Quiet/, log.string)\n  ensure\n    ActiveRecord::Base.logger = original_logger\n  end\n\n  def test_compute_type_success\n    assert_equal Author, ActiveRecord::Base.send(:compute_type, 'Author')\n  end\n\n  def test_compute_type_nonexistent_constant\n    assert_raises NameError do\n      ActiveRecord::Base.send :compute_type, 'NonexistentModel'\n    end\n  end\n\n  def test_compute_type_no_method_error\n    ActiveSupport::Dependencies.stubs(:constantize).raises(NoMethodError)\n    assert_raises NoMethodError do\n      ActiveRecord::Base.send :compute_type, 'InvalidModel'\n    end\n  end\n\n  def test_compute_type_argument_error\n    ActiveSupport::Dependencies.stubs(:constantize).raises(ArgumentError)\n    assert_raises ArgumentError do\n      ActiveRecord::Base.send :compute_type, 'InvalidModel'\n    end\n  end\n\n  def test_clear_cache!\n    # preheat cache\n    c1 = Post.columns\n    ActiveRecord::Base.clear_cache!\n    c2 = Post.columns\n    assert_not_equal c1, c2\n  end\n\n  def test_current_scope_is_reset\n    Object.const_set :UnloadablePost, Class.new(ActiveRecord::Base)\n    UnloadablePost.send(:current_scope=, UnloadablePost.scoped)\n\n    UnloadablePost.unloadable\n    assert_not_nil Thread.current[:UnloadablePost_current_scope]\n    ActiveSupport::Dependencies.remove_unloadable_constants!\n    assert_nil Thread.current[:UnloadablePost_current_scope]\n  ensure\n    Object.class_eval{ remove_const :UnloadablePost } if defined?(UnloadablePost)\n  end\n\n  def test_marshal_round_trip\n    expected = posts(:welcome)\n    marshalled = Marshal.dump(expected)\n    actual   = Marshal.load(marshalled)\n\n    assert_equal expected.attributes, actual.attributes\n  end\n\n  def test_marshal_new_record_round_trip\n    marshalled = Marshal.dump(Post.new)\n    post       = Marshal.load(marshalled)\n\n    assert post.new_record?, \"should be a new record\"\n  end\n\n  def test_marshalling_with_associations\n    post = Post.new\n    post.comments.build\n\n    marshalled = Marshal.dump(post)\n    post       = Marshal.load(marshalled)\n\n    assert_equal 1, post.comments.length\n  end\n\n  def test_attribute_names\n    assert_equal [\"id\", \"type\", \"ruby_type\", \"firm_id\", \"firm_name\", \"name\", \"client_of\", \"rating\", \"account_id\"],\n                 Company.attribute_names\n  end\n\n  def test_attribute_names_on_table_not_exists\n    assert_equal [], NonExistentTable.attribute_names\n  end\n\n  def test_attribtue_names_on_abstract_class\n    assert_equal [], AbstractCompany.attribute_names\n  end\n\n  def test_cache_key_for_existing_record_is_not_timezone_dependent\n    ActiveRecord::Base.time_zone_aware_attributes = true\n\n    Time.zone = \"UTC\"\n    utc_key = Developer.first.cache_key\n\n    Time.zone = \"EST\"\n    est_key = Developer.first.cache_key\n\n    assert_equal utc_key, est_key\n  ensure\n    ActiveRecord::Base.time_zone_aware_attributes = false\n  end\n\n  def test_cache_key_format_for_existing_record_with_updated_at\n    dev = Developer.first\n    assert_equal \"developers/#{dev.id}-#{dev.updated_at.utc.to_s(:number)}\", dev.cache_key\n  end\n\n  def test_cache_key_format_for_existing_record_with_nil_updated_at\n    dev = Developer.first\n    dev.update_attribute(:updated_at, nil)\n    assert_match(/\\/#{dev.id}$/, dev.cache_key)\n  end\nend\n"], "fixing_code": ["# encoding: utf-8\n\ngem 'mysql2', '~> 0.3.6'\nrequire 'mysql2'\n\nmodule ActiveRecord\n  class Base\n    # Establishes a connection to the database that's used by all Active Record objects.\n    def self.mysql2_connection(config)\n      config[:username] = 'root' if config[:username].nil?\n\n      if Mysql2::Client.const_defined? :FOUND_ROWS\n        config[:flags] = Mysql2::Client::FOUND_ROWS\n      end\n\n      client = Mysql2::Client.new(config.symbolize_keys)\n      options = [config[:host], config[:username], config[:password], config[:database], config[:port], config[:socket], 0]\n      ConnectionAdapters::Mysql2Adapter.new(client, logger, options, config)\n    end\n  end\n\n  module ConnectionAdapters\n    class Mysql2IndexDefinition < Struct.new(:table, :name, :unique, :columns, :lengths) #:nodoc:\n    end\n\n    class Mysql2Column < Column\n      BOOL = \"tinyint(1)\"\n      def extract_default(default)\n        if sql_type =~ /blob/i || type == :text\n          if default.blank?\n            return null ? nil : ''\n          else\n            raise ArgumentError, \"#{type} columns cannot have a default value: #{default.inspect}\"\n          end\n        elsif missing_default_forged_as_empty_string?(default)\n          nil\n        else\n          super\n        end\n      end\n\n      def has_default?\n        return false if sql_type =~ /blob/i || type == :text #mysql forbids defaults on blob and text columns\n        super\n      end\n\n      private\n        def simplified_type(field_type)\n          return :boolean if Mysql2Adapter.emulate_booleans && field_type.downcase.index(BOOL)\n\n          case field_type\n          when /enum/i, /set/i then :string\n          when /year/i         then :integer\n          when /bit/i          then :binary\n          else\n            super\n          end\n        end\n\n        def extract_limit(sql_type)\n          case sql_type\n          when /blob|text/i\n            case sql_type\n            when /tiny/i\n              255\n            when /medium/i\n              16777215\n            when /long/i\n              2147483647 # mysql only allows 2^31-1, not 2^32-1, somewhat inconsistently with the tiny/medium/normal cases\n            else\n              super # we could return 65535 here, but we leave it undecorated by default\n            end\n          when /^bigint/i;    8\n          when /^int/i;       4\n          when /^mediumint/i; 3\n          when /^smallint/i;  2\n          when /^tinyint/i;   1\n          else\n            super\n          end\n        end\n\n        # MySQL misreports NOT NULL column default when none is given.\n        # We can't detect this for columns which may have a legitimate ''\n        # default (string) but we can for others (integer, datetime, boolean,\n        # and the rest).\n        #\n        # Test whether the column has default '', is not null, and is not\n        # a type allowing default ''.\n        def missing_default_forged_as_empty_string?(default)\n          type != :string && !null && default == ''\n        end\n    end\n\n    class Mysql2Adapter < AbstractAdapter\n      cattr_accessor :emulate_booleans\n      self.emulate_booleans = true\n\n      ADAPTER_NAME = 'Mysql2'\n      PRIMARY = \"PRIMARY\"\n\n      LOST_CONNECTION_ERROR_MESSAGES = [\n        \"Server shutdown in progress\",\n        \"Broken pipe\",\n        \"Lost connection to MySQL server during query\",\n        \"MySQL server has gone away\" ]\n\n      QUOTED_TRUE, QUOTED_FALSE = '1', '0'\n\n      NATIVE_DATABASE_TYPES = {\n        :primary_key => \"int(11) DEFAULT NULL auto_increment PRIMARY KEY\",\n        :string      => { :name => \"varchar\", :limit => 255 },\n        :text        => { :name => \"text\" },\n        :integer     => { :name => \"int\", :limit => 4 },\n        :float       => { :name => \"float\" },\n        :decimal     => { :name => \"decimal\" },\n        :datetime    => { :name => \"datetime\" },\n        :timestamp   => { :name => \"datetime\" },\n        :time        => { :name => \"time\" },\n        :date        => { :name => \"date\" },\n        :binary      => { :name => \"blob\" },\n        :boolean     => { :name => \"tinyint\", :limit => 1 }\n      }\n\n      def initialize(connection, logger, connection_options, config)\n        super(connection, logger)\n        @connection_options, @config = connection_options, config\n        @quoted_column_names, @quoted_table_names = {}, {}\n        configure_connection\n      end\n\n      def self.visitor_for(pool) # :nodoc:\n        Arel::Visitors::MySQL.new(pool)\n      end\n\n      def adapter_name\n        ADAPTER_NAME\n      end\n\n      # Returns true, since this connection adapter supports migrations.\n      def supports_migrations?\n        true\n      end\n\n      def supports_primary_key?\n        true\n      end\n\n      # Returns true, since this connection adapter supports savepoints.\n      def supports_savepoints?\n        true\n      end\n\n      def native_database_types\n        NATIVE_DATABASE_TYPES\n      end\n\n      # QUOTING ==================================================\n\n      def quote(value, column = nil)\n        if value.kind_of?(String) && column && column.type == :binary && column.class.respond_to?(:string_to_binary)\n          s = column.class.string_to_binary(value).unpack(\"H*\")[0]\n          \"x'#{s}'\"\n        elsif value.kind_of?(BigDecimal)\n          value.to_s(\"F\")\n        else\n          super\n        end\n      end\n\n      def quote_column_name(name) #:nodoc:\n        @quoted_column_names[name] ||= \"`#{name.to_s.gsub('`', '``')}`\"\n      end\n\n      def quote_table_name(name) #:nodoc:\n        @quoted_table_names[name] ||= quote_column_name(name).gsub('.', '`.`')\n      end\n\n      def quote_string(string)\n        @connection.escape(string)\n      end\n\n      def quoted_true\n        QUOTED_TRUE\n      end\n\n      def quoted_false\n        QUOTED_FALSE\n      end\n\n      def substitute_at(column, index)\n        Arel.sql \"\\0\"\n      end\n\n      # REFERENTIAL INTEGRITY ====================================\n\n      def disable_referential_integrity(&block) #:nodoc:\n        old = select_value(\"SELECT @@FOREIGN_KEY_CHECKS\")\n\n        begin\n          update(\"SET FOREIGN_KEY_CHECKS = 0\")\n          yield\n        ensure\n          update(\"SET FOREIGN_KEY_CHECKS = #{old}\")\n        end\n      end\n\n      # CONNECTION MANAGEMENT ====================================\n\n      def active?\n        return false unless @connection\n        @connection.ping\n      end\n\n      def reconnect!\n        disconnect!\n        connect\n      end\n\n      # this is set to true in 2.3, but we don't want it to be\n      def requires_reloading?\n        false\n      end\n\n      # Disconnects from the database if already connected.\n      # Otherwise, this method does nothing.\n      def disconnect!\n        unless @connection.nil?\n          @connection.close\n          @connection = nil\n        end\n      end\n\n      def reset!\n        disconnect!\n        connect\n      end\n\n      # DATABASE STATEMENTS ======================================\n\n      # FIXME: re-enable the following once a \"better\" query_cache solution is in core\n      #\n      # The overrides below perform much better than the originals in AbstractAdapter\n      # because we're able to take advantage of mysql2's lazy-loading capabilities\n      #\n      # # Returns a record hash with the column names as keys and column values\n      # # as values.\n      # def select_one(sql, name = nil)\n      #   result = execute(sql, name)\n      #   result.each(:as => :hash) do |r|\n      #     return r\n      #   end\n      # end\n      #\n      # # Returns a single value from a record\n      # def select_value(sql, name = nil)\n      #   result = execute(sql, name)\n      #   if first = result.first\n      #     first.first\n      #   end\n      # end\n      #\n      # # Returns an array of the values of the first column in a select:\n      # #   select_values(\"SELECT id FROM companies LIMIT 3\") => [1,2,3]\n      # def select_values(sql, name = nil)\n      #   execute(sql, name).map { |row| row.first }\n      # end\n\n      # Returns an array of arrays containing the field values.\n      # Order is the same as that returned by +columns+.\n      def select_rows(sql, name = nil)\n        execute(sql, name).to_a\n      end\n\n      # Executes the SQL statement in the context of this connection.\n      def execute(sql, name = nil)\n        # make sure we carry over any changes to ActiveRecord::Base.default_timezone that have been\n        # made since we established the connection\n        @connection.query_options[:database_timezone] = ActiveRecord::Base.default_timezone\n        if name == :skip_logging\n          @connection.query(sql)\n        else\n          log(sql, name) { @connection.query(sql) }\n        end\n      rescue ActiveRecord::StatementInvalid => exception\n        if exception.message.split(\":\").first =~ /Packets out of order/\n          raise ActiveRecord::StatementInvalid, \"'Packets out of order' error was received from the database. Please update your mysql bindings (gem install mysql) and read http://dev.mysql.com/doc/mysql/en/password-hashing.html for more information. If you're on Windows, use the Instant Rails installer to get the updated mysql bindings.\"\n        else\n          raise\n        end\n      end\n\n      def insert_sql(sql, name = nil, pk = nil, id_value = nil, sequence_name = nil)\n        super\n        id_value || @connection.last_id\n      end\n      alias :create :insert_sql\n\n      def exec_insert(sql, name, binds)\n        binds = binds.dup\n\n        # Pretend to support bind parameters\n        execute sql.gsub(\"\\0\") { quote(*binds.shift.reverse) }, name\n      end\n\n      def exec_delete(sql, name, binds)\n        binds = binds.dup\n\n        # Pretend to support bind parameters\n        execute sql.gsub(\"\\0\") { quote(*binds.shift.reverse) }, name\n        @connection.affected_rows\n      end\n      alias :exec_update :exec_delete\n\n      def last_inserted_id(result)\n        @connection.last_id\n      end\n\n      def update_sql(sql, name = nil)\n        super\n        @connection.affected_rows\n      end\n\n      def begin_db_transaction\n        execute \"BEGIN\"\n      rescue Exception\n        # Transactions aren't supported\n      end\n\n      def commit_db_transaction\n        execute \"COMMIT\"\n      rescue Exception\n        # Transactions aren't supported\n      end\n\n      def rollback_db_transaction\n        execute \"ROLLBACK\"\n      rescue Exception\n        # Transactions aren't supported\n      end\n\n      def create_savepoint\n        execute(\"SAVEPOINT #{current_savepoint_name}\")\n      end\n\n      def rollback_to_savepoint\n        execute(\"ROLLBACK TO SAVEPOINT #{current_savepoint_name}\")\n      end\n\n      def release_savepoint\n        execute(\"RELEASE SAVEPOINT #{current_savepoint_name}\")\n      end\n\n      # SCHEMA STATEMENTS ========================================\n\n      def structure_dump\n        if supports_views?\n          sql = \"SHOW FULL TABLES WHERE Table_type = 'BASE TABLE'\"\n        else\n          sql = \"SHOW TABLES\"\n        end\n\n        select_all(sql).inject(\"\") do |structure, table|\n          table.delete('Table_type')\n          structure += select_one(\"SHOW CREATE TABLE #{quote_table_name(table.to_a.first.last)}\")[\"Create Table\"] + \";\\n\\n\"\n        end\n      end\n\n      # Drops the database specified on the +name+ attribute\n      # and creates it again using the provided +options+.\n      def recreate_database(name, options = {})\n        drop_database(name)\n        create_database(name, options)\n      end\n\n      # Create a new MySQL database with optional <tt>:charset</tt> and <tt>:collation</tt>.\n      # Charset defaults to utf8.\n      #\n      # Example:\n      #   create_database 'charset_test', :charset => 'latin1', :collation => 'latin1_bin'\n      #   create_database 'matt_development'\n      #   create_database 'matt_development', :charset => :big5\n      def create_database(name, options = {})\n        if options[:collation]\n          execute \"CREATE DATABASE `#{name}` DEFAULT CHARACTER SET `#{options[:charset] || 'utf8'}` COLLATE `#{options[:collation]}`\"\n        else\n          execute \"CREATE DATABASE `#{name}` DEFAULT CHARACTER SET `#{options[:charset] || 'utf8'}`\"\n        end\n      end\n\n      # Drops a MySQL database.\n      #\n      # Example:\n      #   drop_database('sebastian_development')\n      def drop_database(name) #:nodoc:\n        execute \"DROP DATABASE IF EXISTS `#{name}`\"\n      end\n\n      def current_database\n        select_value 'SELECT DATABASE() as db'\n      end\n\n      # Returns the database character set.\n      def charset\n        show_variable 'character_set_database'\n      end\n\n      # Returns the database collation strategy.\n      def collation\n        show_variable 'collation_database'\n      end\n\n      def tables(name = nil, database = nil) #:nodoc:\n        sql = [\"SHOW TABLES\", database].compact.join(' IN ')\n        execute(sql, 'SCHEMA').collect do |field|\n          field.first\n        end\n      end\n\n      def table_exists?(name)\n        return true if super\n\n        name          = name.to_s\n        schema, table = name.split('.', 2)\n\n        unless table # A table was provided without a schema\n          table  = schema\n          schema = nil\n        end\n\n        tables(nil, schema).include? table\n      end\n\n      # Returns an array of indexes for the given table.\n      def indexes(table_name, name = nil)\n        indexes = []\n        current_index = nil\n        result = execute(\"SHOW KEYS FROM #{quote_table_name(table_name)}\", 'SCHEMA')\n        result.each(:symbolize_keys => true, :as => :hash) do |row|\n          if current_index != row[:Key_name]\n            next if row[:Key_name] == PRIMARY # skip the primary key\n            current_index = row[:Key_name]\n            indexes << Mysql2IndexDefinition.new(row[:Table], row[:Key_name], row[:Non_unique] == 0, [], [])\n          end\n\n          indexes.last.columns << row[:Column_name]\n          indexes.last.lengths << row[:Sub_part]\n        end\n        indexes\n      end\n\n      # Returns an array of +Mysql2Column+ objects for the table specified by +table_name+.\n      def columns(table_name, name = nil)\n        sql = \"SHOW FIELDS FROM #{quote_table_name(table_name)}\"\n        columns = []\n        result = execute(sql, 'SCHEMA')\n        result.each(:symbolize_keys => true, :as => :hash) { |field|\n          columns << Mysql2Column.new(field[:Field], field[:Default], field[:Type], field[:Null] == \"YES\")\n        }\n        columns\n      end\n\n      def create_table(table_name, options = {})\n        super(table_name, options.reverse_merge(:options => \"ENGINE=InnoDB\"))\n      end\n\n      # Renames a table.\n      #\n      # Example:\n      #   rename_table('octopuses', 'octopi')\n      def rename_table(table_name, new_name)\n        execute \"RENAME TABLE #{quote_table_name(table_name)} TO #{quote_table_name(new_name)}\"\n      end\n\n      def add_column(table_name, column_name, type, options = {})\n        add_column_sql = \"ALTER TABLE #{quote_table_name(table_name)} ADD #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}\"\n        add_column_options!(add_column_sql, options)\n        add_column_position!(add_column_sql, options)\n        execute(add_column_sql)\n      end\n\n      def change_column_default(table_name, column_name, default)\n        column = column_for(table_name, column_name)\n        change_column table_name, column_name, column.sql_type, :default => default\n      end\n\n      def change_column_null(table_name, column_name, null, default = nil)\n        column = column_for(table_name, column_name)\n\n        unless null || default.nil?\n          execute(\"UPDATE #{quote_table_name(table_name)} SET #{quote_column_name(column_name)}=#{quote(default)} WHERE #{quote_column_name(column_name)} IS NULL\")\n        end\n\n        change_column table_name, column_name, column.sql_type, :null => null\n      end\n\n      def change_column(table_name, column_name, type, options = {})\n        column = column_for(table_name, column_name)\n\n        unless options_include_default?(options)\n          options[:default] = column.default\n        end\n\n        unless options.has_key?(:null)\n          options[:null] = column.null\n        end\n\n        change_column_sql = \"ALTER TABLE #{quote_table_name(table_name)} CHANGE #{quote_column_name(column_name)} #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}\"\n        add_column_options!(change_column_sql, options)\n        add_column_position!(change_column_sql, options)\n        execute(change_column_sql)\n      end\n\n      def rename_column(table_name, column_name, new_column_name)\n        options = {}\n        if column = columns(table_name).find { |c| c.name == column_name.to_s }\n          options[:default] = column.default\n          options[:null] = column.null\n        else\n          raise ActiveRecordError, \"No such column: #{table_name}.#{column_name}\"\n        end\n        current_type = select_one(\"SHOW COLUMNS FROM #{quote_table_name(table_name)} LIKE '#{column_name}'\")[\"Type\"]\n        rename_column_sql = \"ALTER TABLE #{quote_table_name(table_name)} CHANGE #{quote_column_name(column_name)} #{quote_column_name(new_column_name)} #{current_type}\"\n        add_column_options!(rename_column_sql, options)\n        execute(rename_column_sql)\n      end\n\n      # Maps logical Rails types to MySQL-specific data types.\n      def type_to_sql(type, limit = nil, precision = nil, scale = nil)\n        return super unless type.to_s == 'integer'\n\n        case limit\n        when 1; 'tinyint'\n        when 2; 'smallint'\n        when 3; 'mediumint'\n        when nil, 4, 11; 'int(11)'  # compatibility with MySQL default\n        when 5..8; 'bigint'\n        else raise(ActiveRecordError, \"No integer type has byte size #{limit}\")\n        end\n      end\n\n      def add_column_position!(sql, options)\n        if options[:first]\n          sql << \" FIRST\"\n        elsif options[:after]\n          sql << \" AFTER #{quote_column_name(options[:after])}\"\n        end\n      end\n\n      # SHOW VARIABLES LIKE 'name'.\n      def show_variable(name)\n        variables = select_all(\"SHOW VARIABLES LIKE '#{name}'\")\n        variables.first['Value'] unless variables.empty?\n      end\n\n      # Returns a table's primary key and belonging sequence.\n      def pk_and_sequence_for(table)\n        keys = []\n        result = execute(\"DESCRIBE #{quote_table_name(table)}\", 'SCHEMA')\n        result.each(:symbolize_keys => true, :as => :hash) do |row|\n          keys << row[:Field] if row[:Key] == \"PRI\"\n        end\n        keys.length == 1 ? [keys.first, nil] : nil\n      end\n\n      # Returns just a table's primary key\n      def primary_key(table)\n        pk_and_sequence = pk_and_sequence_for(table)\n        pk_and_sequence && pk_and_sequence.first\n      end\n\n      def case_sensitive_modifier(node)\n        Arel::Nodes::Bin.new(node)\n      end\n\n      def limited_update_conditions(where_sql, quoted_table_name, quoted_primary_key)\n        where_sql\n      end\n\n      # In the simple case, MySQL allows us to place JOINs directly into the UPDATE\n      # query. However, this does not allow for LIMIT, OFFSET and ORDER. To support\n      # these, we must use a subquery. However, MySQL is too stupid to create a\n      # temporary table for this automatically, so we have to give it some prompting\n      # in the form of a subsubquery. Ugh!\n      def join_to_update(update, select) #:nodoc:\n        if select.limit || select.offset || select.orders.any?\n          subsubselect = select.clone\n          subsubselect.projections = [update.key]\n\n          subselect = Arel::SelectManager.new(select.engine)\n          subselect.project Arel.sql(update.key.name)\n          subselect.from subsubselect.as('__active_record_temp')\n\n          update.where update.key.in(subselect)\n        else\n          update.table select.source\n          update.wheres = select.constraints\n        end\n      end\n\n      protected\n        def quoted_columns_for_index(column_names, options = {})\n          length = options[:length] if options.is_a?(Hash)\n\n          case length\n          when Hash\n            column_names.map {|name| length[name] ? \"#{quote_column_name(name)}(#{length[name]})\" : quote_column_name(name) }\n          when Fixnum\n            column_names.map {|name| \"#{quote_column_name(name)}(#{length})\"}\n          else\n            column_names.map {|name| quote_column_name(name) }\n          end\n        end\n\n        def translate_exception(exception, message)\n          return super unless exception.respond_to?(:error_number)\n\n          case exception.error_number\n          when 1062\n            RecordNotUnique.new(message, exception)\n          when 1452\n            InvalidForeignKey.new(message, exception)\n          else\n            super\n          end\n        end\n\n      private\n        def connect\n          @connection = Mysql2::Client.new(@config)\n          configure_connection\n        end\n\n        def configure_connection\n          @connection.query_options.merge!(:as => :array)\n\n          # By default, MySQL 'where id is null' selects the last inserted id.\n          # Turn this off. http://dev.rubyonrails.org/ticket/6778\n          variable_assignments = ['SQL_AUTO_IS_NULL=0']\n          encoding = @config[:encoding]\n\n          # make sure we set the encoding\n          variable_assignments << \"NAMES '#{encoding}'\" if encoding\n\n          # increase timeout so mysql server doesn't disconnect us\n          wait_timeout = @config[:wait_timeout]\n          wait_timeout = 2592000 unless wait_timeout.is_a?(Fixnum)\n          variable_assignments << \"@@wait_timeout = #{wait_timeout}\"\n\n          execute(\"SET #{variable_assignments.join(', ')}\", :skip_logging)\n        end\n\n        # Returns an array of record hashes with the column names as keys and\n        # column values as values.\n        def select(sql, name = nil, binds = [])\n          binds = binds.dup\n          exec_query(sql.gsub(\"\\0\") { quote(*binds.shift.reverse) }, name).to_a\n        end\n\n        def exec_query(sql, name = 'SQL', binds = [])\n          @connection.query_options[:database_timezone] = ActiveRecord::Base.default_timezone\n\n          log(sql, name, binds) do\n            begin\n              result = @connection.query(sql)\n            rescue ActiveRecord::StatementInvalid => exception\n              if exception.message.split(\":\").first =~ /Packets out of order/\n                raise ActiveRecord::StatementInvalid, \"'Packets out of order' error was received from the database. Please update your mysql bindings (gem install mysql) and read http://dev.mysql.com/doc/mysql/en/password-hashing.html for more information. If you're on Windows, use the Instant Rails installer to get the updated mysql bindings.\"\n              else\n                raise\n              end\n            end\n\n            ActiveRecord::Result.new(result.fields, result.to_a)\n          end\n        end\n\n        def supports_views?\n          version[0] >= 5\n        end\n\n        def version\n          @version ||= @connection.info[:version].scan(/^(\\d+)\\.(\\d+)\\.(\\d+)/).flatten.map { |v| v.to_i }\n        end\n\n        def column_for(table_name, column_name)\n          unless column = columns(table_name).find { |c| c.name == column_name.to_s }\n            raise \"No such column: #{table_name}.#{column_name}\"\n          end\n          column\n        end\n    end\n  end\nend\n", "require 'active_record/connection_adapters/abstract_adapter'\nrequire 'active_support/core_ext/object/blank'\nrequire 'set'\n\ngem 'mysql', '~> 2.8.1'\nrequire 'mysql'\n\nclass Mysql\n  class Time\n    ###\n    # This monkey patch is for test_additional_columns_from_join_table\n    def to_date\n      Date.new(year, month, day)\n    end\n  end\n  class Stmt; include Enumerable end\n  class Result; include Enumerable end\nend\n\nmodule ActiveRecord\n  class Base\n    # Establishes a connection to the database that's used by all Active Record objects.\n    def self.mysql_connection(config) # :nodoc:\n      config = config.symbolize_keys\n      host     = config[:host]\n      port     = config[:port]\n      socket   = config[:socket]\n      username = config[:username] ? config[:username].to_s : 'root'\n      password = config[:password].to_s\n      database = config[:database]\n\n      mysql = Mysql.init\n      mysql.ssl_set(config[:sslkey], config[:sslcert], config[:sslca], config[:sslcapath], config[:sslcipher]) if config[:sslca] || config[:sslkey]\n\n      default_flags = Mysql.const_defined?(:CLIENT_MULTI_RESULTS) ? Mysql::CLIENT_MULTI_RESULTS : 0\n      default_flags |= Mysql::CLIENT_FOUND_ROWS if Mysql.const_defined?(:CLIENT_FOUND_ROWS)\n      options = [host, username, password, database, port, socket, default_flags]\n      ConnectionAdapters::MysqlAdapter.new(mysql, logger, options, config)\n    end\n  end\n\n  module ConnectionAdapters\n    class MysqlColumn < Column #:nodoc:\n      class << self\n        def string_to_time(value)\n          return super unless Mysql::Time === value\n          new_time(\n            value.year,\n            value.month,\n            value.day,\n            value.hour,\n            value.minute,\n            value.second,\n            value.second_part)\n        end\n\n        def string_to_dummy_time(v)\n          return super unless Mysql::Time === v\n          new_time(2000, 01, 01, v.hour, v.minute, v.second, v.second_part)\n        end\n\n        def string_to_date(v)\n          return super unless Mysql::Time === v\n          new_date(v.year, v.month, v.day)\n        end\n      end\n\n      def extract_default(default)\n        if sql_type =~ /blob/i || type == :text\n          if default.blank?\n            return null ? nil : ''\n          else\n            raise ArgumentError, \"#{type} columns cannot have a default value: #{default.inspect}\"\n          end\n        elsif missing_default_forged_as_empty_string?(default)\n          nil\n        else\n          super\n        end\n      end\n\n      def has_default?\n        return false if sql_type =~ /blob/i || type == :text #mysql forbids defaults on blob and text columns\n        super\n      end\n\n      private\n        def simplified_type(field_type)\n          return :boolean if MysqlAdapter.emulate_booleans && field_type.downcase.index(\"tinyint(1)\")\n          return :string  if field_type =~ /enum/i\n          super\n        end\n\n        def extract_limit(sql_type)\n          case sql_type\n          when /blob|text/i\n            case sql_type\n            when /tiny/i\n              255\n            when /medium/i\n              16777215\n            when /long/i\n              2147483647 # mysql only allows 2^31-1, not 2^32-1, somewhat inconsistently with the tiny/medium/normal cases\n            else\n              super # we could return 65535 here, but we leave it undecorated by default\n            end\n          when /^bigint/i;    8\n          when /^int/i;       4\n          when /^mediumint/i; 3\n          when /^smallint/i;  2\n          when /^tinyint/i;   1\n          else\n            super\n          end\n        end\n\n        # MySQL misreports NOT NULL column default when none is given.\n        # We can't detect this for columns which may have a legitimate ''\n        # default (string) but we can for others (integer, datetime, boolean,\n        # and the rest).\n        #\n        # Test whether the column has default '', is not null, and is not\n        # a type allowing default ''.\n        def missing_default_forged_as_empty_string?(default)\n          type != :string && !null && default == ''\n        end\n    end\n\n    # The MySQL adapter will work with both Ruby/MySQL, which is a Ruby-based MySQL adapter that comes bundled with Active Record, and with\n    # the faster C-based MySQL/Ruby adapter (available both as a gem and from http://www.tmtm.org/en/mysql/ruby/).\n    #\n    # Options:\n    #\n    # * <tt>:host</tt> - Defaults to \"localhost\".\n    # * <tt>:port</tt> - Defaults to 3306.\n    # * <tt>:socket</tt> - Defaults to \"/tmp/mysql.sock\".\n    # * <tt>:username</tt> - Defaults to \"root\"\n    # * <tt>:password</tt> - Defaults to nothing.\n    # * <tt>:database</tt> - The name of the database. No default, must be provided.\n    # * <tt>:encoding</tt> - (Optional) Sets the client encoding by executing \"SET NAMES <encoding>\" after connection.\n    # * <tt>:reconnect</tt> - Defaults to false (See MySQL documentation: http://dev.mysql.com/doc/refman/5.0/en/auto-reconnect.html).\n    # * <tt>:sslca</tt> - Necessary to use MySQL with an SSL connection.\n    # * <tt>:sslkey</tt> - Necessary to use MySQL with an SSL connection.\n    # * <tt>:sslcert</tt> - Necessary to use MySQL with an SSL connection.\n    # * <tt>:sslcapath</tt> - Necessary to use MySQL with an SSL connection.\n    # * <tt>:sslcipher</tt> - Necessary to use MySQL with an SSL connection.\n    #\n    class MysqlAdapter < AbstractAdapter\n\n      ##\n      # :singleton-method:\n      # By default, the MysqlAdapter will consider all columns of type <tt>tinyint(1)</tt>\n      # as boolean. If you wish to disable this emulation (which was the default\n      # behavior in versions 0.13.1 and earlier) you can add the following line\n      # to your application.rb file:\n      #\n      #   ActiveRecord::ConnectionAdapters::MysqlAdapter.emulate_booleans = false\n      cattr_accessor :emulate_booleans\n      self.emulate_booleans = true\n\n      ADAPTER_NAME = 'MySQL'\n\n      LOST_CONNECTION_ERROR_MESSAGES = [\n        \"Server shutdown in progress\",\n        \"Broken pipe\",\n        \"Lost connection to MySQL server during query\",\n        \"MySQL server has gone away\" ]\n\n      QUOTED_TRUE, QUOTED_FALSE = '1', '0'\n\n      NATIVE_DATABASE_TYPES = {\n        :primary_key => \"int(11) DEFAULT NULL auto_increment PRIMARY KEY\",\n        :string      => { :name => \"varchar\", :limit => 255 },\n        :text        => { :name => \"text\" },\n        :integer     => { :name => \"int\", :limit => 4 },\n        :float       => { :name => \"float\" },\n        :decimal     => { :name => \"decimal\" },\n        :datetime    => { :name => \"datetime\" },\n        :timestamp   => { :name => \"datetime\" },\n        :time        => { :name => \"time\" },\n        :date        => { :name => \"date\" },\n        :binary      => { :name => \"blob\" },\n        :boolean     => { :name => \"tinyint\", :limit => 1 }\n      }\n\n      def initialize(connection, logger, connection_options, config)\n        super(connection, logger)\n        @connection_options, @config = connection_options, config\n        @quoted_column_names, @quoted_table_names = {}, {}\n        @statements = {}\n        @client_encoding = nil\n        connect\n      end\n\n      def self.visitor_for(pool) # :nodoc:\n        Arel::Visitors::MySQL.new(pool)\n      end\n\n      def adapter_name #:nodoc:\n        ADAPTER_NAME\n      end\n\n      def supports_bulk_alter? #:nodoc:\n        true\n      end\n\n      # Returns true, since this connection adapter supports prepared statement\n      # caching.\n      def supports_statement_cache?\n        true\n      end\n\n      # Returns true, since this connection adapter supports migrations.\n      def supports_migrations? #:nodoc:\n        true\n      end\n\n      # Returns true.\n      def supports_primary_key? #:nodoc:\n        true\n      end\n\n      # Returns true, since this connection adapter supports savepoints.\n      def supports_savepoints? #:nodoc:\n        true\n      end\n\n      def native_database_types #:nodoc:\n        NATIVE_DATABASE_TYPES\n      end\n\n\n      # QUOTING ==================================================\n\n      def quote(value, column = nil)\n        if value.kind_of?(String) && column && column.type == :binary && column.class.respond_to?(:string_to_binary)\n          s = column.class.string_to_binary(value).unpack(\"H*\")[0]\n          \"x'#{s}'\"\n        elsif value.kind_of?(BigDecimal)\n          value.to_s(\"F\")\n        else\n          super\n        end\n      end\n\n      def type_cast(value, column)\n        return super unless value == true || value == false\n\n        value ? 1 : 0\n      end\n\n      def quote_column_name(name) #:nodoc:\n        @quoted_column_names[name] ||= \"`#{name.to_s.gsub('`', '``')}`\"\n      end\n\n      def quote_table_name(name) #:nodoc:\n        @quoted_table_names[name] ||= quote_column_name(name).gsub('.', '`.`')\n      end\n\n      def quote_string(string) #:nodoc:\n        @connection.quote(string)\n      end\n\n      def quoted_true\n        QUOTED_TRUE\n      end\n\n      def quoted_false\n        QUOTED_FALSE\n      end\n\n      # REFERENTIAL INTEGRITY ====================================\n\n      def disable_referential_integrity #:nodoc:\n        old = select_value(\"SELECT @@FOREIGN_KEY_CHECKS\")\n\n        begin\n          update(\"SET FOREIGN_KEY_CHECKS = 0\")\n          yield\n        ensure\n          update(\"SET FOREIGN_KEY_CHECKS = #{old}\")\n        end\n      end\n\n      # CONNECTION MANAGEMENT ====================================\n\n      def active?\n        if @connection.respond_to?(:stat)\n          @connection.stat\n        else\n          @connection.query 'select 1'\n        end\n\n        # mysql-ruby doesn't raise an exception when stat fails.\n        if @connection.respond_to?(:errno)\n          @connection.errno.zero?\n        else\n          true\n        end\n      rescue Mysql::Error\n        false\n      end\n\n      def reconnect!\n        disconnect!\n        clear_cache!\n        connect\n      end\n\n      # Disconnects from the database if already connected. Otherwise, this\n      # method does nothing.\n      def disconnect!\n        @connection.close rescue nil\n      end\n\n      def reset!\n        if @connection.respond_to?(:change_user)\n          # See http://bugs.mysql.com/bug.php?id=33540 -- the workaround way to\n          # reset the connection is to change the user to the same user.\n          @connection.change_user(@config[:username], @config[:password], @config[:database])\n          configure_connection\n        end\n      end\n\n      # DATABASE STATEMENTS ======================================\n\n      def select_rows(sql, name = nil)\n        @connection.query_with_result = true\n        rows = exec_without_stmt(sql, name).rows\n        @connection.more_results && @connection.next_result    # invoking stored procedures with CLIENT_MULTI_RESULTS requires this to tidy up else connection will be dropped\n        rows\n      end\n\n      # Clears the prepared statements cache.\n      def clear_cache!\n        @statements.values.each do |cache|\n          cache[:stmt].close\n        end\n        @statements.clear\n      end\n\n      if \"<3\".respond_to?(:encode)\n        # Taken from here:\n        #   https://github.com/tmtm/ruby-mysql/blob/master/lib/mysql/charset.rb\n        # Author: TOMITA Masahiro <tommy@tmtm.org>\n        ENCODINGS = {\n          \"armscii8\" => nil,\n          \"ascii\"    => Encoding::US_ASCII,\n          \"big5\"     => Encoding::Big5,\n          \"binary\"   => Encoding::ASCII_8BIT,\n          \"cp1250\"   => Encoding::Windows_1250,\n          \"cp1251\"   => Encoding::Windows_1251,\n          \"cp1256\"   => Encoding::Windows_1256,\n          \"cp1257\"   => Encoding::Windows_1257,\n          \"cp850\"    => Encoding::CP850,\n          \"cp852\"    => Encoding::CP852,\n          \"cp866\"    => Encoding::IBM866,\n          \"cp932\"    => Encoding::Windows_31J,\n          \"dec8\"     => nil,\n          \"eucjpms\"  => Encoding::EucJP_ms,\n          \"euckr\"    => Encoding::EUC_KR,\n          \"gb2312\"   => Encoding::EUC_CN,\n          \"gbk\"      => Encoding::GBK,\n          \"geostd8\"  => nil,\n          \"greek\"    => Encoding::ISO_8859_7,\n          \"hebrew\"   => Encoding::ISO_8859_8,\n          \"hp8\"      => nil,\n          \"keybcs2\"  => nil,\n          \"koi8r\"    => Encoding::KOI8_R,\n          \"koi8u\"    => Encoding::KOI8_U,\n          \"latin1\"   => Encoding::ISO_8859_1,\n          \"latin2\"   => Encoding::ISO_8859_2,\n          \"latin5\"   => Encoding::ISO_8859_9,\n          \"latin7\"   => Encoding::ISO_8859_13,\n          \"macce\"    => Encoding::MacCentEuro,\n          \"macroman\" => Encoding::MacRoman,\n          \"sjis\"     => Encoding::SHIFT_JIS,\n          \"swe7\"     => nil,\n          \"tis620\"   => Encoding::TIS_620,\n          \"ucs2\"     => Encoding::UTF_16BE,\n          \"ujis\"     => Encoding::EucJP_ms,\n          \"utf8\"     => Encoding::UTF_8,\n          \"utf8mb4\"  => Encoding::UTF_8,\n        }\n      else\n        ENCODINGS = Hash.new { |h,k| h[k] = k }\n      end\n\n      # Get the client encoding for this database\n      def client_encoding\n        return @client_encoding if @client_encoding\n\n        result = exec_query(\n          \"SHOW VARIABLES WHERE Variable_name = 'character_set_client'\",\n          'SCHEMA')\n        @client_encoding = ENCODINGS[result.rows.last.last]\n      end\n\n      def exec_query(sql, name = 'SQL', binds = [])\n        log(sql, name, binds) do\n          exec_stmt(sql, name, binds) do |cols, stmt|\n            ActiveRecord::Result.new(cols, stmt.to_a) if cols\n          end\n        end\n      end\n\n      def last_inserted_id(result)\n        @connection.insert_id\n      end\n\n      def exec_without_stmt(sql, name = 'SQL') # :nodoc:\n        # Some queries, like SHOW CREATE TABLE don't work through the prepared\n        # statement API. For those queries, we need to use this method. :'(\n        log(sql, name) do\n          result = @connection.query(sql)\n          cols = []\n          rows = []\n\n          if result\n            cols = result.fetch_fields.map { |field| field.name }\n            rows = result.to_a\n            result.free\n          end\n          ActiveRecord::Result.new(cols, rows)\n        end\n      end\n\n      # Executes an SQL query and returns a MySQL::Result object. Note that you have to free\n      # the Result object after you're done using it.\n      def execute(sql, name = nil) #:nodoc:\n        if name == :skip_logging\n          @connection.query(sql)\n        else\n          log(sql, name) { @connection.query(sql) }\n        end\n      rescue ActiveRecord::StatementInvalid => exception\n        if exception.message.split(\":\").first =~ /Packets out of order/\n          raise ActiveRecord::StatementInvalid, \"'Packets out of order' error was received from the database. Please update your mysql bindings (gem install mysql) and read http://dev.mysql.com/doc/mysql/en/password-hashing.html for more information. If you're on Windows, use the Instant Rails installer to get the updated mysql bindings.\"\n        else\n          raise\n        end\n      end\n\n      def insert_sql(sql, name = nil, pk = nil, id_value = nil, sequence_name = nil) #:nodoc:\n        super sql, name\n        id_value || @connection.insert_id\n      end\n      alias :create :insert_sql\n\n      def update_sql(sql, name = nil) #:nodoc:\n        super\n        @connection.affected_rows\n      end\n\n      def exec_delete(sql, name, binds)\n        log(sql, name, binds) do\n          exec_stmt(sql, name, binds) do |cols, stmt|\n            stmt.affected_rows\n          end\n        end\n      end\n      alias :exec_update :exec_delete\n\n      def begin_db_transaction #:nodoc:\n        exec_without_stmt \"BEGIN\"\n      rescue Mysql::Error\n        # Transactions aren't supported\n      end\n\n      def commit_db_transaction #:nodoc:\n        execute \"COMMIT\"\n      rescue Exception\n        # Transactions aren't supported\n      end\n\n      def rollback_db_transaction #:nodoc:\n        execute \"ROLLBACK\"\n      rescue Exception\n        # Transactions aren't supported\n      end\n\n      def create_savepoint\n        execute(\"SAVEPOINT #{current_savepoint_name}\")\n      end\n\n      def rollback_to_savepoint\n        execute(\"ROLLBACK TO SAVEPOINT #{current_savepoint_name}\")\n      end\n\n      def release_savepoint\n        execute(\"RELEASE SAVEPOINT #{current_savepoint_name}\")\n      end\n\n      # In the simple case, MySQL allows us to place JOINs directly into the UPDATE\n      # query. However, this does not allow for LIMIT, OFFSET and ORDER. To support\n      # these, we must use a subquery. However, MySQL is too stupid to create a\n      # temporary table for this automatically, so we have to give it some prompting\n      # in the form of a subsubquery. Ugh!\n      def join_to_update(update, select) #:nodoc:\n        if select.limit || select.offset || select.orders.any?\n          subsubselect = select.clone\n          subsubselect.projections = [update.key]\n\n          subselect = Arel::SelectManager.new(select.engine)\n          subselect.project Arel.sql(update.key.name)\n          subselect.from subsubselect.as('__active_record_temp')\n\n          update.where update.key.in(subselect)\n        else\n          update.table select.source\n          update.wheres = select.constraints\n        end\n      end\n\n      # SCHEMA STATEMENTS ========================================\n\n      def structure_dump #:nodoc:\n        if supports_views?\n          sql = \"SHOW FULL TABLES WHERE Table_type = 'BASE TABLE'\"\n        else\n          sql = \"SHOW TABLES\"\n        end\n\n        select_all(sql).map do |table|\n          table.delete('Table_type')\n          sql = \"SHOW CREATE TABLE #{quote_table_name(table.to_a.first.last)}\"\n          exec_without_stmt(sql).first['Create Table'] + \";\\n\\n\"\n        end.join(\"\")\n      end\n\n      # Drops the database specified on the +name+ attribute\n      # and creates it again using the provided +options+.\n      def recreate_database(name, options = {}) #:nodoc:\n        drop_database(name)\n        create_database(name, options)\n      end\n\n      # Create a new MySQL database with optional <tt>:charset</tt> and <tt>:collation</tt>.\n      # Charset defaults to utf8.\n      #\n      # Example:\n      #   create_database 'charset_test', :charset => 'latin1', :collation => 'latin1_bin'\n      #   create_database 'matt_development'\n      #   create_database 'matt_development', :charset => :big5\n      def create_database(name, options = {})\n        if options[:collation]\n          execute \"CREATE DATABASE `#{name}` DEFAULT CHARACTER SET `#{options[:charset] || 'utf8'}` COLLATE `#{options[:collation]}`\"\n        else\n          execute \"CREATE DATABASE `#{name}` DEFAULT CHARACTER SET `#{options[:charset] || 'utf8'}`\"\n        end\n      end\n\n      # Drops a MySQL database.\n      #\n      # Example:\n      #   drop_database 'sebastian_development'\n      def drop_database(name) #:nodoc:\n        execute \"DROP DATABASE IF EXISTS `#{name}`\"\n      end\n\n      def current_database\n        select_value 'SELECT DATABASE() as db'\n      end\n\n      # Returns the database character set.\n      def charset\n        show_variable 'character_set_database'\n      end\n\n      # Returns the database collation strategy.\n      def collation\n        show_variable 'collation_database'\n      end\n\n      def tables(name = nil, database = nil) #:nodoc:\n        result = execute([\"SHOW TABLES\", database].compact.join(' IN '), 'SCHEMA')\n        tables = result.collect { |field| field[0] }\n        result.free\n        tables\n      end\n\n      def table_exists?(name)\n        return true if super\n\n        name          = name.to_s\n        schema, table = name.split('.', 2)\n\n        unless table # A table was provided without a schema\n          table  = schema\n          schema = nil\n        end\n\n        tables(nil, schema).include? table\n      end\n\n      # Returns an array of indexes for the given table.\n      def indexes(table_name, name = nil)#:nodoc:\n        indexes = []\n        current_index = nil\n        result = execute(\"SHOW KEYS FROM #{quote_table_name(table_name)}\", name)\n        result.each do |row|\n          if current_index != row[2]\n            next if row[2] == \"PRIMARY\" # skip the primary key\n            current_index = row[2]\n            indexes << IndexDefinition.new(row[0], row[2], row[1] == \"0\", [], [])\n          end\n\n          indexes.last.columns << row[4]\n          indexes.last.lengths << row[7]\n        end\n        result.free\n        indexes\n      end\n\n      # Returns an array of +MysqlColumn+ objects for the table specified by +table_name+.\n      def columns(table_name, name = nil)#:nodoc:\n        sql = \"SHOW FIELDS FROM #{quote_table_name(table_name)}\"\n        result = execute(sql, 'SCHEMA')\n        columns = result.collect { |field| MysqlColumn.new(field[0], field[4], field[1], field[2] == \"YES\") }\n        result.free\n        columns\n      end\n\n      def create_table(table_name, options = {}) #:nodoc:\n        super(table_name, options.reverse_merge(:options => \"ENGINE=InnoDB\"))\n      end\n\n      # Renames a table.\n      #\n      # Example:\n      #   rename_table('octopuses', 'octopi')\n      def rename_table(table_name, new_name)\n        execute \"RENAME TABLE #{quote_table_name(table_name)} TO #{quote_table_name(new_name)}\"\n      end\n\n      def bulk_change_table(table_name, operations) #:nodoc:\n        sqls = operations.map do |command, args|\n          table, arguments = args.shift, args\n          method = :\"#{command}_sql\"\n\n          if respond_to?(method)\n            send(method, table, *arguments)\n          else\n            raise \"Unknown method called : #{method}(#{arguments.inspect})\"\n          end\n        end.flatten.join(\", \")\n\n        execute(\"ALTER TABLE #{quote_table_name(table_name)} #{sqls}\")\n      end\n\n      def add_column(table_name, column_name, type, options = {})\n        execute(\"ALTER TABLE #{quote_table_name(table_name)} #{add_column_sql(table_name, column_name, type, options)}\")\n      end\n\n      def change_column_default(table_name, column_name, default) #:nodoc:\n        column = column_for(table_name, column_name)\n        change_column table_name, column_name, column.sql_type, :default => default\n      end\n\n      def change_column_null(table_name, column_name, null, default = nil)\n        column = column_for(table_name, column_name)\n\n        unless null || default.nil?\n          execute(\"UPDATE #{quote_table_name(table_name)} SET #{quote_column_name(column_name)}=#{quote(default)} WHERE #{quote_column_name(column_name)} IS NULL\")\n        end\n\n        change_column table_name, column_name, column.sql_type, :null => null\n      end\n\n      def change_column(table_name, column_name, type, options = {}) #:nodoc:\n        execute(\"ALTER TABLE #{quote_table_name(table_name)} #{change_column_sql(table_name, column_name, type, options)}\")\n      end\n\n      def rename_column(table_name, column_name, new_column_name) #:nodoc:\n        execute(\"ALTER TABLE #{quote_table_name(table_name)} #{rename_column_sql(table_name, column_name, new_column_name)}\")\n      end\n\n      # Maps logical Rails types to MySQL-specific data types.\n      def type_to_sql(type, limit = nil, precision = nil, scale = nil)\n        return super unless type.to_s == 'integer'\n\n        case limit\n        when 1; 'tinyint'\n        when 2; 'smallint'\n        when 3; 'mediumint'\n        when nil, 4, 11; 'int(11)'  # compatibility with MySQL default\n        when 5..8; 'bigint'\n        else raise(ActiveRecordError, \"No integer type has byte size #{limit}\")\n        end\n      end\n\n      def add_column_position!(sql, options)\n        if options[:first]\n          sql << \" FIRST\"\n        elsif options[:after]\n          sql << \" AFTER #{quote_column_name(options[:after])}\"\n        end\n      end\n\n      # SHOW VARIABLES LIKE 'name'\n      def show_variable(name)\n        variables = select_all(\"SHOW VARIABLES LIKE '#{name}'\")\n        variables.first['Value'] unless variables.empty?\n      end\n\n      # Returns a table's primary key and belonging sequence.\n      def pk_and_sequence_for(table) #:nodoc:\n        keys = []\n        result = execute(\"describe #{quote_table_name(table)}\", 'SCHEMA')\n        result.each_hash do |h|\n          keys << h[\"Field\"]if h[\"Key\"] == \"PRI\"\n        end\n        result.free\n        keys.length == 1 ? [keys.first, nil] : nil\n      end\n\n      # Returns just a table's primary key\n      def primary_key(table)\n        pk_and_sequence = pk_and_sequence_for(table)\n        pk_and_sequence && pk_and_sequence.first\n      end\n\n      def case_sensitive_modifier(node)\n        Arel::Nodes::Bin.new(node)\n      end\n\n      def limited_update_conditions(where_sql, quoted_table_name, quoted_primary_key)\n        where_sql\n      end\n\n      protected\n        def quoted_columns_for_index(column_names, options = {})\n          length = options[:length] if options.is_a?(Hash)\n\n          case length\n          when Hash\n            column_names.map {|name| length[name] ? \"#{quote_column_name(name)}(#{length[name]})\" : quote_column_name(name) }\n          when Fixnum\n            column_names.map {|name| \"#{quote_column_name(name)}(#{length})\"}\n          else\n            column_names.map {|name| quote_column_name(name) }\n          end\n        end\n\n        def translate_exception(exception, message)\n          return super unless exception.respond_to?(:errno)\n\n          case exception.errno\n          when 1062\n            RecordNotUnique.new(message, exception)\n          when 1452\n            InvalidForeignKey.new(message, exception)\n          else\n            super\n          end\n        end\n\n        def add_column_sql(table_name, column_name, type, options = {})\n          add_column_sql = \"ADD #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}\"\n          add_column_options!(add_column_sql, options)\n          add_column_position!(add_column_sql, options)\n          add_column_sql\n        end\n\n        def remove_column_sql(table_name, *column_names)\n          columns_for_remove(table_name, *column_names).map {|column_name| \"DROP #{column_name}\" }\n        end\n        alias :remove_columns_sql :remove_column\n\n        def change_column_sql(table_name, column_name, type, options = {})\n          column = column_for(table_name, column_name)\n\n          unless options_include_default?(options)\n            options[:default] = column.default\n          end\n\n          unless options.has_key?(:null)\n            options[:null] = column.null\n          end\n\n          change_column_sql = \"CHANGE #{quote_column_name(column_name)} #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}\"\n          add_column_options!(change_column_sql, options)\n          add_column_position!(change_column_sql, options)\n          change_column_sql\n        end\n\n        def rename_column_sql(table_name, column_name, new_column_name)\n          options = {}\n\n          if column = columns(table_name).find { |c| c.name == column_name.to_s }\n            options[:default] = column.default\n            options[:null] = column.null\n          else\n            raise ActiveRecordError, \"No such column: #{table_name}.#{column_name}\"\n          end\n\n          current_type = select_one(\"SHOW COLUMNS FROM #{quote_table_name(table_name)} LIKE '#{column_name}'\")[\"Type\"]\n          rename_column_sql = \"CHANGE #{quote_column_name(column_name)} #{quote_column_name(new_column_name)} #{current_type}\"\n          add_column_options!(rename_column_sql, options)\n          rename_column_sql\n        end\n\n        def add_index_sql(table_name, column_name, options = {})\n          index_name, index_type, index_columns = add_index_options(table_name, column_name, options)\n          \"ADD #{index_type} INDEX #{index_name} (#{index_columns})\"\n        end\n\n        def remove_index_sql(table_name, options = {})\n          index_name = index_name_for_remove(table_name, options)\n          \"DROP INDEX #{index_name}\"\n        end\n\n        def add_timestamps_sql(table_name)\n          [add_column_sql(table_name, :created_at, :datetime), add_column_sql(table_name, :updated_at, :datetime)]\n        end\n\n        def remove_timestamps_sql(table_name)\n          [remove_column_sql(table_name, :updated_at), remove_column_sql(table_name, :created_at)]\n        end\n\n      private\n      def exec_stmt(sql, name, binds)\n        cache = {}\n        if binds.empty?\n          stmt = @connection.prepare(sql)\n        else\n          cache = @statements[sql] ||= {\n            :stmt => @connection.prepare(sql)\n          }\n          stmt = cache[:stmt]\n        end\n\n\n        begin\n          stmt.execute(*binds.map { |col, val| type_cast(val, col) })\n        rescue Mysql::Error => e\n          # Older versions of MySQL leave the prepared statement in a bad\n          # place when an error occurs. To support older mysql versions, we\n          # need to close the statement and delete the statement from the\n          # cache.\n          stmt.close\n          @statements.delete sql\n          raise e\n        end\n\n        cols = nil\n        if metadata = stmt.result_metadata\n          cols = cache[:cols] ||= metadata.fetch_fields.map { |field|\n            field.name\n          }\n        end\n\n        result = yield [cols, stmt]\n\n        stmt.result_metadata.free if cols\n        stmt.free_result\n        stmt.close if binds.empty?\n\n        result\n      end\n\n        def connect\n          encoding = @config[:encoding]\n          if encoding\n            @connection.options(Mysql::SET_CHARSET_NAME, encoding) rescue nil\n          end\n\n          if @config[:sslca] || @config[:sslkey]\n            @connection.ssl_set(@config[:sslkey], @config[:sslcert], @config[:sslca], @config[:sslcapath], @config[:sslcipher])\n          end\n\n          @connection.options(Mysql::OPT_CONNECT_TIMEOUT, @config[:connect_timeout]) if @config[:connect_timeout]\n          @connection.options(Mysql::OPT_READ_TIMEOUT, @config[:read_timeout]) if @config[:read_timeout]\n          @connection.options(Mysql::OPT_WRITE_TIMEOUT, @config[:write_timeout]) if @config[:write_timeout]\n\n          @connection.real_connect(*@connection_options)\n\n          # reconnect must be set after real_connect is called, because real_connect sets it to false internally\n          @connection.reconnect = !!@config[:reconnect] if @connection.respond_to?(:reconnect=)\n\n          configure_connection\n        end\n\n        def configure_connection\n          encoding = @config[:encoding]\n          execute(\"SET NAMES '#{encoding}'\", :skip_logging) if encoding\n\n          # By default, MySQL 'where id is null' selects the last inserted id.\n          # Turn this off. http://dev.rubyonrails.org/ticket/6778\n          execute(\"SET SQL_AUTO_IS_NULL=0\", :skip_logging)\n        end\n\n        def select(sql, name = nil, binds = [])\n          @connection.query_with_result = true\n          rows = exec_query(sql, name, binds).to_a\n          @connection.more_results && @connection.next_result    # invoking stored procedures with CLIENT_MULTI_RESULTS requires this to tidy up else connection will be dropped\n          rows\n        end\n\n        def supports_views?\n          version[0] >= 5\n        end\n\n        # Returns the version of the connected MySQL server.\n        def version\n          @version ||= @connection.server_info.scan(/^(\\d+)\\.(\\d+)\\.(\\d+)/).flatten.map { |v| v.to_i }\n        end\n\n        def column_for(table_name, column_name)\n          unless column = columns(table_name).find { |c| c.name == column_name.to_s }\n            raise \"No such column: #{table_name}.#{column_name}\"\n          end\n          column\n        end\n    end\n  end\nend\n", "require 'active_record/connection_adapters/abstract_adapter'\n\nmodule ActiveRecord\n  module ConnectionAdapters #:nodoc:\n    class SQLiteColumn < Column #:nodoc:\n      class <<  self\n        def string_to_binary(value)\n          value.gsub(/\\0|\\%/n) do |b|\n            case b\n              when \"\\0\" then \"%00\"\n              when \"%\"  then \"%25\"\n            end\n          end\n        end\n\n        def binary_to_string(value)\n          if value.respond_to?(:force_encoding) && value.encoding != Encoding::ASCII_8BIT\n            value = value.force_encoding(Encoding::ASCII_8BIT)\n          end\n\n          value.gsub(/%00|%25/n) do |b|\n            case b\n              when \"%00\" then \"\\0\"\n              when \"%25\" then \"%\"\n            end\n          end\n        end\n      end\n    end\n\n    # The SQLite adapter works with both the 2.x and 3.x series of SQLite with the sqlite-ruby\n    # drivers (available both as gems and from http://rubyforge.org/projects/sqlite-ruby/).\n    #\n    # Options:\n    #\n    # * <tt>:database</tt> - Path to the database file.\n    class SQLiteAdapter < AbstractAdapter\n      class Version\n        include Comparable\n\n        def initialize(version_string)\n          @version = version_string.split('.').map { |v| v.to_i }\n        end\n\n        def <=>(version_string)\n          @version <=> version_string.split('.').map { |v| v.to_i }\n        end\n      end\n\n      def initialize(connection, logger, config)\n        super(connection, logger)\n        @statements = {}\n        @config = config\n      end\n\n      def self.visitor_for(pool) # :nodoc:\n        Arel::Visitors::SQLite.new(pool)\n      end\n\n      def adapter_name #:nodoc:\n        'SQLite'\n      end\n\n      # Returns true if SQLite version is '2.0.0' or greater, false otherwise.\n      def supports_ddl_transactions?\n        sqlite_version >= '2.0.0'\n      end\n\n      # Returns true if SQLite version is '3.6.8' or greater, false otherwise.\n      def supports_savepoints?\n        sqlite_version >= '3.6.8'\n      end\n\n      # Returns true, since this connection adapter supports prepared statement\n      # caching.\n      def supports_statement_cache?\n        true\n      end\n\n      # Returns true, since this connection adapter supports migrations.\n      def supports_migrations? #:nodoc:\n        true\n      end\n\n      # Returns true.\n      def supports_primary_key? #:nodoc:\n        true\n      end\n\n      def requires_reloading?\n        true\n      end\n\n      # Returns true if SQLite version is '3.1.6' or greater, false otherwise.\n      def supports_add_column?\n        sqlite_version >= '3.1.6'\n      end\n\n      # Disconnects from the database if already connected. Otherwise, this\n      # method does nothing.\n      def disconnect!\n        super\n        clear_cache!\n        @connection.close rescue nil\n      end\n\n      # Clears the prepared statements cache.\n      def clear_cache!\n        @statements.values.map { |hash| hash[:stmt] }.each { |stmt|\n          stmt.close unless stmt.closed?\n        }\n\n        @statements.clear\n      end\n\n      # Returns true if SQLite version is '3.2.6' or greater, false otherwise.\n      def supports_count_distinct? #:nodoc:\n        sqlite_version >= '3.2.6'\n      end\n\n      # Returns true if SQLite version is '3.1.0' or greater, false otherwise.\n      def supports_autoincrement? #:nodoc:\n        sqlite_version >= '3.1.0'\n      end\n\n      def native_database_types #:nodoc:\n        {\n          :primary_key => default_primary_key_type,\n          :string      => { :name => \"varchar\", :limit => 255 },\n          :text        => { :name => \"text\" },\n          :integer     => { :name => \"integer\" },\n          :float       => { :name => \"float\" },\n          :decimal     => { :name => \"decimal\" },\n          :datetime    => { :name => \"datetime\" },\n          :timestamp   => { :name => \"datetime\" },\n          :time        => { :name => \"time\" },\n          :date        => { :name => \"date\" },\n          :binary      => { :name => \"blob\" },\n          :boolean     => { :name => \"boolean\" }\n        }\n      end\n\n\n      # QUOTING ==================================================\n\n      def quote_string(s) #:nodoc:\n        @connection.class.quote(s)\n      end\n\n      def quote_column_name(name) #:nodoc:\n        %Q(\"#{name.to_s.gsub('\"', '\"\"')}\")\n      end\n\n      # Quote date/time values for use in SQL input. Includes microseconds\n      # if the value is a Time responding to usec.\n      def quoted_date(value) #:nodoc:\n        if value.respond_to?(:usec)\n          \"#{super}.#{sprintf(\"%06d\", value.usec)}\"\n        else\n          super\n        end\n      end\n\n      def type_cast(value, column) # :nodoc:\n        return super unless BigDecimal === value\n\n        value.to_f\n      end\n\n      # DATABASE STATEMENTS ======================================\n\n      def exec_query(sql, name = nil, binds = [])\n        log(sql, name, binds) do\n\n          # Don't cache statements without bind values\n          if binds.empty?\n            stmt    = @connection.prepare(sql)\n            cols    = stmt.columns\n            records = stmt.to_a\n            stmt.close\n            stmt = records\n          else\n            cache = @statements[sql] ||= {\n              :stmt => @connection.prepare(sql)\n            }\n            stmt = cache[:stmt]\n            cols = cache[:cols] ||= stmt.columns\n            stmt.reset!\n            stmt.bind_params binds.map { |col, val|\n              type_cast(val, col)\n            }\n          end\n\n          ActiveRecord::Result.new(cols, stmt.to_a)\n        end\n      end\n\n      def exec_delete(sql, name = 'SQL', binds = [])\n        exec_query(sql, name, binds)\n        @connection.changes\n      end\n      alias :exec_update :exec_delete\n\n      def last_inserted_id(result)\n        @connection.last_insert_row_id\n      end\n\n      def execute(sql, name = nil) #:nodoc:\n        log(sql, name) { @connection.execute(sql) }\n      end\n\n      def update_sql(sql, name = nil) #:nodoc:\n        super\n        @connection.changes\n      end\n\n      def delete_sql(sql, name = nil) #:nodoc:\n        sql += \" WHERE 1=1\" unless sql =~ /WHERE/i\n        super sql, name\n      end\n\n      def insert_sql(sql, name = nil, pk = nil, id_value = nil, sequence_name = nil) #:nodoc:\n        super\n        id_value || @connection.last_insert_row_id\n      end\n      alias :create :insert_sql\n\n      def select_rows(sql, name = nil)\n        exec_query(sql, name).rows\n      end\n\n      def create_savepoint\n        execute(\"SAVEPOINT #{current_savepoint_name}\")\n      end\n\n      def rollback_to_savepoint\n        execute(\"ROLLBACK TO SAVEPOINT #{current_savepoint_name}\")\n      end\n\n      def release_savepoint\n        execute(\"RELEASE SAVEPOINT #{current_savepoint_name}\")\n      end\n\n      def begin_db_transaction #:nodoc:\n        log('begin transaction',nil) { @connection.transaction }\n      end\n\n      def commit_db_transaction #:nodoc:\n        log('commit transaction',nil) { @connection.commit }\n      end\n\n      def rollback_db_transaction #:nodoc:\n        log('rollback transaction',nil) { @connection.rollback }\n      end\n\n      # SCHEMA STATEMENTS ========================================\n\n      def tables(name = 'SCHEMA') #:nodoc:\n        sql = <<-SQL\n          SELECT name\n          FROM sqlite_master\n          WHERE type = 'table' AND NOT name = 'sqlite_sequence'\n        SQL\n\n        exec_query(sql, name).map do |row|\n          row['name']\n        end\n      end\n\n      # Returns an array of +SQLiteColumn+ objects for the table specified by +table_name+.\n      def columns(table_name, name = nil) #:nodoc:\n        table_structure(table_name).map do |field|\n          case field[\"dflt_value\"]\n          when /^null$/i\n            field[\"dflt_value\"] = nil\n          when /^'(.*)'$/\n            field[\"dflt_value\"] = $1.gsub(/''/, \"'\")\n          when /^\"(.*)\"$/\n            field[\"dflt_value\"] = $1.gsub(/\"\"/, '\"')\n          end\n\n          SQLiteColumn.new(field['name'], field['dflt_value'], field['type'], field['notnull'].to_i == 0)\n        end\n      end\n\n      # Returns an array of indexes for the given table.\n      def indexes(table_name, name = nil) #:nodoc:\n        exec_query(\"PRAGMA index_list(#{quote_table_name(table_name)})\", name).map do |row|\n          IndexDefinition.new(\n            table_name,\n            row['name'],\n            row['unique'] != 0,\n            exec_query(\"PRAGMA index_info('#{row['name']}')\").map { |col|\n              col['name']\n            })\n        end\n      end\n\n      def primary_key(table_name) #:nodoc:\n        column = table_structure(table_name).find { |field|\n          field['pk'] == 1\n        }\n        column && column['name']\n      end\n\n      def remove_index!(table_name, index_name) #:nodoc:\n        exec_query \"DROP INDEX #{quote_column_name(index_name)}\"\n      end\n\n      # Renames a table.\n      #\n      # Example:\n      #   rename_table('octopuses', 'octopi')\n      def rename_table(name, new_name)\n        exec_query \"ALTER TABLE #{quote_table_name(name)} RENAME TO #{quote_table_name(new_name)}\"\n      end\n\n      # See: http://www.sqlite.org/lang_altertable.html\n      # SQLite has an additional restriction on the ALTER TABLE statement\n      def valid_alter_table_options( type, options)\n        type.to_sym != :primary_key\n      end\n\n      def add_column(table_name, column_name, type, options = {}) #:nodoc:\n        if supports_add_column? && valid_alter_table_options( type, options )\n          super(table_name, column_name, type, options)\n        else\n          alter_table(table_name) do |definition|\n            definition.column(column_name, type, options)\n          end\n        end\n      end\n\n      def remove_column(table_name, *column_names) #:nodoc:\n        raise ArgumentError.new(\"You must specify at least one column name. Example: remove_column(:people, :first_name)\") if column_names.empty?\n        column_names.flatten.each do |column_name|\n          alter_table(table_name) do |definition|\n            definition.columns.delete(definition[column_name])\n          end\n        end\n      end\n      alias :remove_columns :remove_column\n\n      def change_column_default(table_name, column_name, default) #:nodoc:\n        alter_table(table_name) do |definition|\n          definition[column_name].default = default\n        end\n      end\n\n      def change_column_null(table_name, column_name, null, default = nil)\n        unless null || default.nil?\n          exec_query(\"UPDATE #{quote_table_name(table_name)} SET #{quote_column_name(column_name)}=#{quote(default)} WHERE #{quote_column_name(column_name)} IS NULL\")\n        end\n        alter_table(table_name) do |definition|\n          definition[column_name].null = null\n        end\n      end\n\n      def change_column(table_name, column_name, type, options = {}) #:nodoc:\n        alter_table(table_name) do |definition|\n          include_default = options_include_default?(options)\n          definition[column_name].instance_eval do\n            self.type    = type\n            self.limit   = options[:limit] if options.include?(:limit)\n            self.default = options[:default] if include_default\n            self.null    = options[:null] if options.include?(:null)\n          end\n        end\n      end\n\n      def rename_column(table_name, column_name, new_column_name) #:nodoc:\n        unless columns(table_name).detect{|c| c.name == column_name.to_s }\n          raise ActiveRecord::ActiveRecordError, \"Missing column #{table_name}.#{column_name}\"\n        end\n        alter_table(table_name, :rename => {column_name.to_s => new_column_name.to_s})\n      end\n\n      def empty_insert_statement_value\n        \"VALUES(NULL)\"\n      end\n\n      protected\n        def select(sql, name = nil, binds = []) #:nodoc:\n          exec_query(sql, name, binds).to_a\n        end\n\n        def table_structure(table_name)\n          structure = exec_query(\"PRAGMA table_info(#{quote_table_name(table_name)})\", 'SCHEMA').to_hash\n          raise(ActiveRecord::StatementInvalid, \"Could not find table '#{table_name}'\") if structure.empty?\n          structure\n        end\n\n        def alter_table(table_name, options = {}) #:nodoc:\n          altered_table_name = \"altered_#{table_name}\"\n          caller = lambda {|definition| yield definition if block_given?}\n\n          transaction do\n            move_table(table_name, altered_table_name,\n              options.merge(:temporary => true))\n            move_table(altered_table_name, table_name, &caller)\n          end\n        end\n\n        def move_table(from, to, options = {}, &block) #:nodoc:\n          copy_table(from, to, options, &block)\n          drop_table(from)\n        end\n\n        def copy_table(from, to, options = {}) #:nodoc:\n          options = options.merge(:id => (!columns(from).detect{|c| c.name == 'id'}.nil? && 'id' == primary_key(from).to_s))\n          create_table(to, options) do |definition|\n            @definition = definition\n            columns(from).each do |column|\n              column_name = options[:rename] ?\n                (options[:rename][column.name] ||\n                 options[:rename][column.name.to_sym] ||\n                 column.name) : column.name\n\n              @definition.column(column_name, column.type,\n                :limit => column.limit, :default => column.default,\n                :null => column.null)\n            end\n            @definition.primary_key(primary_key(from)) if primary_key(from)\n            yield @definition if block_given?\n          end\n\n          copy_table_indexes(from, to, options[:rename] || {})\n          copy_table_contents(from, to,\n            @definition.columns.map {|column| column.name},\n            options[:rename] || {})\n        end\n\n        def copy_table_indexes(from, to, rename = {}) #:nodoc:\n          indexes(from).each do |index|\n            name = index.name\n            if to == \"altered_#{from}\"\n              name = \"temp_#{name}\"\n            elsif from == \"altered_#{to}\"\n              name = name[5..-1]\n            end\n\n            to_column_names = columns(to).map { |c| c.name }\n            columns = index.columns.map {|c| rename[c] || c }.select do |column|\n              to_column_names.include?(column)\n            end\n\n            unless columns.empty?\n              # index name can't be the same\n              opts = { :name => name.gsub(/_(#{from})_/, \"_#{to}_\") }\n              opts[:unique] = true if index.unique\n              add_index(to, columns, opts)\n            end\n          end\n        end\n\n        def copy_table_contents(from, to, columns, rename = {}) #:nodoc:\n          column_mappings = Hash[columns.map {|name| [name, name]}]\n          rename.each { |a| column_mappings[a.last] = a.first }\n          from_columns = columns(from).collect {|col| col.name}\n          columns = columns.find_all{|col| from_columns.include?(column_mappings[col])}\n          quoted_columns = columns.map { |col| quote_column_name(col) } * ','\n\n          quoted_to = quote_table_name(to)\n          exec_query(\"SELECT * FROM #{quote_table_name(from)}\").each do |row|\n            sql = \"INSERT INTO #{quoted_to} (#{quoted_columns}) VALUES (\"\n            sql << columns.map {|col| quote row[column_mappings[col]]} * ', '\n            sql << ')'\n            exec_query sql\n          end\n        end\n\n        def sqlite_version\n          @sqlite_version ||= SQLiteAdapter::Version.new(select_value('select sqlite_version(*)'))\n        end\n\n        def default_primary_key_type\n          if supports_autoincrement?\n            'INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL'\n          else\n            'INTEGER PRIMARY KEY NOT NULL'\n          end\n        end\n\n        def translate_exception(exception, message)\n          case exception.message\n          when /column(s)? .* (is|are) not unique/\n            RecordNotUnique.new(message, exception)\n          else\n            super\n          end\n        end\n\n    end\n  end\nend\n", "require \"cases/helper\"\nrequire 'models/post'\nrequire 'models/author'\nrequire 'models/topic'\nrequire 'models/reply'\nrequire 'models/category'\nrequire 'models/company'\nrequire 'models/customer'\nrequire 'models/developer'\nrequire 'models/project'\nrequire 'models/default'\nrequire 'models/auto_id'\nrequire 'models/boolean'\nrequire 'models/column_name'\nrequire 'models/subscriber'\nrequire 'models/keyboard'\nrequire 'models/comment'\nrequire 'models/minimalistic'\nrequire 'models/warehouse_thing'\nrequire 'models/parrot'\nrequire 'models/person'\nrequire 'models/edge'\nrequire 'models/joke'\nrequire 'models/bulb'\nrequire 'rexml/document'\nrequire 'active_support/core_ext/exception'\n\nclass Category < ActiveRecord::Base; end\nclass Categorization < ActiveRecord::Base; end\nclass Smarts < ActiveRecord::Base; end\nclass CreditCard < ActiveRecord::Base\n  class PinNumber < ActiveRecord::Base\n    class CvvCode < ActiveRecord::Base; end\n    class SubCvvCode < CvvCode; end\n  end\n  class SubPinNumber < PinNumber; end\n  class Brand < Category; end\nend\nclass MasterCreditCard < ActiveRecord::Base; end\nclass Post < ActiveRecord::Base; end\nclass Computer < ActiveRecord::Base; end\nclass NonExistentTable < ActiveRecord::Base; end\nclass TestOracleDefault < ActiveRecord::Base; end\n\nclass ReadonlyTitlePost < Post\n  attr_readonly :title\nend\n\nclass ProtectedTitlePost < Post\n  attr_protected :title\nend\n\nclass Weird < ActiveRecord::Base; end\n\nclass Boolean < ActiveRecord::Base; end\n\nclass LintTest < ActiveRecord::TestCase\n  include ActiveModel::Lint::Tests\n\n  class LintModel < ActiveRecord::Base; end\n\n  def setup\n    @model = LintModel.new\n  end\nend\n\nclass BasicsTest < ActiveRecord::TestCase\n  fixtures :topics, :companies, :developers, :projects, :computers, :accounts, :minimalistics, 'warehouse-things', :authors, :categorizations, :categories, :posts\n\n  def test_column_names_are_escaped\n    conn      = ActiveRecord::Base.connection\n    classname = conn.class.name[/[^:]*$/]\n    badchar   = {\n      'SQLite3Adapter'    => '\"',\n      'MysqlAdapter'      => '`',\n      'Mysql2Adapter'     => '`',\n      'PostgreSQLAdapter' => '\"',\n      'OracleAdapter'     => '\"',\n    }.fetch(classname) {\n      raise \"need a bad char for #{classname}\"\n    }\n\n    quoted = conn.quote_column_name \"foo#{badchar}bar\"\n    assert_equal(\"#{badchar}foo#{badchar * 2}bar#{badchar}\", quoted)\n  end\n\n  def test_columns_should_obey_set_primary_key\n    pk = Subscriber.columns.find { |x| x.name == 'nick' }\n    assert pk.primary, 'nick should be primary key'\n  end\n\n  def test_primary_key_with_no_id\n    assert_nil Edge.primary_key\n  end\n\n  unless current_adapter?(:PostgreSQLAdapter,:OracleAdapter,:SQLServerAdapter)\n    def test_limit_with_comma\n      assert_nothing_raised do\n        Topic.limit(\"1,2\").all\n      end\n    end\n  end\n\n  def test_limit_without_comma\n    assert_nothing_raised do\n      assert_equal 1, Topic.limit(\"1\").all.length\n    end\n\n    assert_nothing_raised do\n      assert_equal 1, Topic.limit(1).all.length\n    end\n  end\n\n  def test_invalid_limit\n    assert_raises(ArgumentError) do\n      Topic.limit(\"asdfadf\").all\n    end\n  end\n\n  def test_limit_should_sanitize_sql_injection_for_limit_without_comas\n    assert_raises(ArgumentError) do\n      Topic.limit(\"1 select * from schema\").all\n    end\n  end\n\n  def test_limit_should_sanitize_sql_injection_for_limit_with_comas\n    assert_raises(ArgumentError) do\n      Topic.limit(\"1, 7 procedure help()\").all\n    end\n  end\n\n  unless current_adapter?(:MysqlAdapter) || current_adapter?(:Mysql2Adapter)\n    def test_limit_should_allow_sql_literal\n      assert_equal 1, Topic.limit(Arel.sql('2-1')).all.length\n    end\n  end\n\n  def test_select_symbol\n    topic_ids = Topic.select(:id).map(&:id).sort\n    assert_equal Topic.all.map(&:id).sort, topic_ids\n  end\n\n  def test_table_exists\n    assert !NonExistentTable.table_exists?\n    assert Topic.table_exists?\n  end\n\n  def test_preserving_date_objects\n    if current_adapter?(:SybaseAdapter)\n      # Sybase ctlib does not (yet?) support the date type; use datetime instead.\n      assert_kind_of(\n        Time, Topic.find(1).last_read,\n        \"The last_read attribute should be of the Time class\"\n      )\n    else\n      # Oracle enhanced adapter allows to define Date attributes in model class (see topic.rb)\n      assert_kind_of(\n        Date, Topic.find(1).last_read,\n        \"The last_read attribute should be of the Date class\"\n      )\n    end\n  end\n\n  def test_preserving_time_objects\n    assert_kind_of(\n      Time, Topic.find(1).bonus_time,\n      \"The bonus_time attribute should be of the Time class\"\n    )\n\n    assert_kind_of(\n      Time, Topic.find(1).written_on,\n      \"The written_on attribute should be of the Time class\"\n    )\n\n    # For adapters which support microsecond resolution.\n    if current_adapter?(:PostgreSQLAdapter) || current_adapter?(:SQLiteAdapter)\n      assert_equal 11, Topic.find(1).written_on.sec\n      assert_equal 223300, Topic.find(1).written_on.usec\n      assert_equal 9900, Topic.find(2).written_on.usec\n    end\n  end\n\n  def test_preserving_time_objects_with_local_time_conversion_to_default_timezone_utc\n    with_env_tz 'America/New_York' do\n      with_active_record_default_timezone :utc do\n        time = Time.local(2000)\n        topic = Topic.create('written_on' => time)\n        saved_time = Topic.find(topic.id).reload.written_on\n        assert_equal time, saved_time\n        assert_equal [0, 0, 0, 1, 1, 2000, 6, 1, false, \"EST\"], time.to_a\n        assert_equal [0, 0, 5, 1, 1, 2000, 6, 1, false, \"UTC\"], saved_time.to_a\n      end\n    end\n  end\n\n  def test_preserving_time_objects_with_time_with_zone_conversion_to_default_timezone_utc\n    with_env_tz 'America/New_York' do\n      with_active_record_default_timezone :utc do\n        Time.use_zone 'Central Time (US & Canada)' do\n          time = Time.zone.local(2000)\n          topic = Topic.create('written_on' => time)\n          saved_time = Topic.find(topic.id).reload.written_on\n          assert_equal time, saved_time\n          assert_equal [0, 0, 0, 1, 1, 2000, 6, 1, false, \"CST\"], time.to_a\n          assert_equal [0, 0, 6, 1, 1, 2000, 6, 1, false, \"UTC\"], saved_time.to_a\n        end\n      end\n    end\n  end\n\n  def test_preserving_time_objects_with_utc_time_conversion_to_default_timezone_local\n    with_env_tz 'America/New_York' do\n      time = Time.utc(2000)\n      topic = Topic.create('written_on' => time)\n      saved_time = Topic.find(topic.id).reload.written_on\n      assert_equal time, saved_time\n      assert_equal [0, 0, 0, 1, 1, 2000, 6, 1, false, \"UTC\"], time.to_a\n      assert_equal [0, 0, 19, 31, 12, 1999, 5, 365, false, \"EST\"], saved_time.to_a\n    end\n  end\n\n  def test_preserving_time_objects_with_time_with_zone_conversion_to_default_timezone_local\n    with_env_tz 'America/New_York' do\n      with_active_record_default_timezone :local do\n        Time.use_zone 'Central Time (US & Canada)' do\n          time = Time.zone.local(2000)\n          topic = Topic.create('written_on' => time)\n          saved_time = Topic.find(topic.id).reload.written_on\n          assert_equal time, saved_time\n          assert_equal [0, 0, 0, 1, 1, 2000, 6, 1, false, \"CST\"], time.to_a\n          assert_equal [0, 0, 1, 1, 1, 2000, 6, 1, false, \"EST\"], saved_time.to_a\n        end\n      end\n    end\n  end\n\n  def test_custom_mutator\n    topic = Topic.find(1)\n    # This mutator is protected in the class definition\n    topic.send(:approved=, true)\n    assert topic.instance_variable_get(\"@custom_approved\")\n  end\n\n  def test_initialize_with_attributes\n    topic = Topic.new({\n      \"title\" => \"initialized from attributes\", \"written_on\" => \"2003-12-12 23:23\"\n    })\n\n    assert_equal(\"initialized from attributes\", topic.title)\n  end\n\n  def test_initialize_with_invalid_attribute\n    begin\n      Topic.new({ \"title\" => \"test\",\n        \"last_read(1i)\" => \"2005\", \"last_read(2i)\" => \"2\", \"last_read(3i)\" => \"31\"})\n    rescue ActiveRecord::MultiparameterAssignmentErrors => ex\n      assert_equal(1, ex.errors.size)\n      assert_equal(\"last_read\", ex.errors[0].attribute)\n    end\n  end\n\n  def test_create_after_initialize_without_block\n    cb = CustomBulb.create(:name => 'Dude')\n    assert_equal('Dude', cb.name)\n    assert_equal(true, cb.frickinawesome)\n  end\n\n  def test_create_after_initialize_with_block\n    cb = CustomBulb.create {|c| c.name = 'Dude' }\n    assert_equal('Dude', cb.name)\n    assert_equal(true, cb.frickinawesome)\n  end\n\n  def test_load\n    topics = Topic.find(:all, :order => 'id')\n    assert_equal(4, topics.size)\n    assert_equal(topics(:first).title, topics.first.title)\n  end\n\n  def test_load_with_condition\n    topics = Topic.find(:all, :conditions => \"author_name = 'Mary'\")\n\n    assert_equal(1, topics.size)\n    assert_equal(topics(:second).title, topics.first.title)\n  end\n\n  GUESSED_CLASSES = [Category, Smarts, CreditCard, CreditCard::PinNumber, CreditCard::PinNumber::CvvCode, CreditCard::SubPinNumber, CreditCard::Brand, MasterCreditCard]\n\n  def test_table_name_guesses\n    assert_equal \"topics\", Topic.table_name\n\n    assert_equal \"categories\", Category.table_name\n    assert_equal \"smarts\", Smarts.table_name\n    assert_equal \"credit_cards\", CreditCard.table_name\n    assert_equal \"credit_card_pin_numbers\", CreditCard::PinNumber.table_name\n    assert_equal \"credit_card_pin_number_cvv_codes\", CreditCard::PinNumber::CvvCode.table_name\n    assert_equal \"credit_card_pin_numbers\", CreditCard::SubPinNumber.table_name\n    assert_equal \"categories\", CreditCard::Brand.table_name\n    assert_equal \"master_credit_cards\", MasterCreditCard.table_name\n  ensure\n    GUESSED_CLASSES.each(&:reset_table_name)\n  end\n\n  def test_singular_table_name_guesses\n    ActiveRecord::Base.pluralize_table_names = false\n    GUESSED_CLASSES.each(&:reset_table_name)\n\n    assert_equal \"category\", Category.table_name\n    assert_equal \"smarts\", Smarts.table_name\n    assert_equal \"credit_card\", CreditCard.table_name\n    assert_equal \"credit_card_pin_number\", CreditCard::PinNumber.table_name\n    assert_equal \"credit_card_pin_number_cvv_code\", CreditCard::PinNumber::CvvCode.table_name\n    assert_equal \"credit_card_pin_number\", CreditCard::SubPinNumber.table_name\n    assert_equal \"category\", CreditCard::Brand.table_name\n    assert_equal \"master_credit_card\", MasterCreditCard.table_name\n  ensure\n    ActiveRecord::Base.pluralize_table_names = true\n    GUESSED_CLASSES.each(&:reset_table_name)\n  end\n\n  def test_table_name_guesses_with_prefixes_and_suffixes\n    ActiveRecord::Base.table_name_prefix = \"test_\"\n    Category.reset_table_name\n    assert_equal \"test_categories\", Category.table_name\n    ActiveRecord::Base.table_name_suffix = \"_test\"\n    Category.reset_table_name\n    assert_equal \"test_categories_test\", Category.table_name\n    ActiveRecord::Base.table_name_prefix = \"\"\n    Category.reset_table_name\n    assert_equal \"categories_test\", Category.table_name\n    ActiveRecord::Base.table_name_suffix = \"\"\n    Category.reset_table_name\n    assert_equal \"categories\", Category.table_name\n  ensure\n    ActiveRecord::Base.table_name_prefix = \"\"\n    ActiveRecord::Base.table_name_suffix = \"\"\n    GUESSED_CLASSES.each(&:reset_table_name)\n  end\n\n  def test_singular_table_name_guesses_with_prefixes_and_suffixes\n    ActiveRecord::Base.pluralize_table_names = false\n\n    ActiveRecord::Base.table_name_prefix = \"test_\"\n    Category.reset_table_name\n    assert_equal \"test_category\", Category.table_name\n    ActiveRecord::Base.table_name_suffix = \"_test\"\n    Category.reset_table_name\n    assert_equal \"test_category_test\", Category.table_name\n    ActiveRecord::Base.table_name_prefix = \"\"\n    Category.reset_table_name\n    assert_equal \"category_test\", Category.table_name\n    ActiveRecord::Base.table_name_suffix = \"\"\n    Category.reset_table_name\n    assert_equal \"category\", Category.table_name\n  ensure\n    ActiveRecord::Base.pluralize_table_names = true\n    ActiveRecord::Base.table_name_prefix = \"\"\n    ActiveRecord::Base.table_name_suffix = \"\"\n    GUESSED_CLASSES.each(&:reset_table_name)\n  end\n\n  def test_table_name_guesses_with_inherited_prefixes_and_suffixes\n    GUESSED_CLASSES.each(&:reset_table_name)\n\n    CreditCard.table_name_prefix = \"test_\"\n    CreditCard.reset_table_name\n    Category.reset_table_name\n    assert_equal \"test_credit_cards\", CreditCard.table_name\n    assert_equal \"categories\", Category.table_name\n    CreditCard.table_name_suffix = \"_test\"\n    CreditCard.reset_table_name\n    Category.reset_table_name\n    assert_equal \"test_credit_cards_test\", CreditCard.table_name\n    assert_equal \"categories\", Category.table_name\n    CreditCard.table_name_prefix = \"\"\n    CreditCard.reset_table_name\n    Category.reset_table_name\n    assert_equal \"credit_cards_test\", CreditCard.table_name\n    assert_equal \"categories\", Category.table_name\n    CreditCard.table_name_suffix = \"\"\n    CreditCard.reset_table_name\n    Category.reset_table_name\n    assert_equal \"credit_cards\", CreditCard.table_name\n    assert_equal \"categories\", Category.table_name\n  ensure\n    CreditCard.table_name_prefix = \"\"\n    CreditCard.table_name_suffix = \"\"\n    GUESSED_CLASSES.each(&:reset_table_name)\n  end\n\n  def test_singular_table_name_guesses_for_individual_table\n    CreditCard.pluralize_table_names = false\n    CreditCard.reset_table_name\n    assert_equal \"credit_card\", CreditCard.table_name\n    assert_equal \"categories\", Category.table_name\n  ensure\n    CreditCard.pluralize_table_names = true\n    CreditCard.reset_table_name\n  end\n\n  if current_adapter?(:MysqlAdapter) or current_adapter?(:Mysql2Adapter)\n    def test_update_all_with_order_and_limit\n      assert_equal 1, Topic.update_all(\"content = 'bulk updated!'\", nil, :limit => 1, :order => 'id DESC')\n    end\n  end\n\n  def test_null_fields\n    assert_nil Topic.find(1).parent_id\n    assert_nil Topic.create(\"title\" => \"Hey you\").parent_id\n  end\n\n  def test_default_values\n    topic = Topic.new\n    assert topic.approved?\n    assert_nil topic.written_on\n    assert_nil topic.bonus_time\n    assert_nil topic.last_read\n\n    topic.save\n\n    topic = Topic.find(topic.id)\n    assert topic.approved?\n    assert_nil topic.last_read\n\n    # Oracle has some funky default handling, so it requires a bit of\n    # extra testing. See ticket #2788.\n    if current_adapter?(:OracleAdapter)\n      test = TestOracleDefault.new\n      assert_equal \"X\", test.test_char\n      assert_equal \"hello\", test.test_string\n      assert_equal 3, test.test_int\n    end\n  end\n\n  # Oracle, and Sybase do not have a TIME datatype.\n  unless current_adapter?(:OracleAdapter, :SybaseAdapter)\n    def test_utc_as_time_zone\n      Topic.default_timezone = :utc\n      attributes = { \"bonus_time\" => \"5:42:00AM\" }\n      topic = Topic.find(1)\n      topic.attributes = attributes\n      assert_equal Time.utc(2000, 1, 1, 5, 42, 0), topic.bonus_time\n      Topic.default_timezone = :local\n    end\n\n    def test_utc_as_time_zone_and_new\n      Topic.default_timezone = :utc\n      attributes = { \"bonus_time(1i)\"=>\"2000\",\n                     \"bonus_time(2i)\"=>\"1\",\n                     \"bonus_time(3i)\"=>\"1\",\n                     \"bonus_time(4i)\"=>\"10\",\n                     \"bonus_time(5i)\"=>\"35\",\n                     \"bonus_time(6i)\"=>\"50\" }\n      topic = Topic.new(attributes)\n      assert_equal Time.utc(2000, 1, 1, 10, 35, 50), topic.bonus_time\n      Topic.default_timezone = :local\n    end\n  end\n\n  def test_default_values_on_empty_strings\n    topic = Topic.new\n    topic.approved  = nil\n    topic.last_read = nil\n\n    topic.save\n\n    topic = Topic.find(topic.id)\n    assert_nil topic.last_read\n\n    # Sybase adapter does not allow nulls in boolean columns\n    if current_adapter?(:SybaseAdapter)\n      assert topic.approved == false\n    else\n      assert_nil topic.approved\n    end\n  end\n\n  def test_equality\n    assert_equal Topic.find(1), Topic.find(2).topic\n  end\n\n  def test_find_by_slug\n    assert_equal Topic.find('1-meowmeow'), Topic.find(1)\n  end\n\n  def test_equality_of_new_records\n    assert_not_equal Topic.new, Topic.new\n  end\n\n  def test_equality_of_destroyed_records\n    topic_1 = Topic.new(:title => 'test_1')\n    topic_1.save\n    topic_2 = Topic.find(topic_1.id)\n    topic_1.destroy\n    assert_equal topic_1, topic_2\n    assert_equal topic_2, topic_1\n  end\n\n  def test_hashing\n    assert_equal [ Topic.find(1) ], [ Topic.find(2).topic ] & [ Topic.find(1) ]\n  end\n\n  def test_comparison\n    topic_1 = Topic.create!\n    topic_2 = Topic.create!\n\n    assert_equal [topic_2, topic_1].sort, [topic_1, topic_2]\n  end\n\n  def test_comparison_with_different_objects\n    topic = Topic.create\n    category = Category.create(:name => \"comparison\")\n    assert_nil topic <=> category\n  end\n\n  def test_readonly_attributes\n    assert_equal Set.new([ 'title' , 'comments_count' ]), ReadonlyTitlePost.readonly_attributes\n\n    post = ReadonlyTitlePost.create(:title => \"cannot change this\", :body => \"changeable\")\n    post.reload\n    assert_equal \"cannot change this\", post.title\n\n    post.update_attributes(:title => \"try to change\", :body => \"changed\")\n    post.reload\n    assert_equal \"cannot change this\", post.title\n    assert_equal \"changed\", post.body\n  end\n\n  def test_non_valid_identifier_column_name\n    weird = Weird.create('a$b' => 'value')\n    weird.reload\n    assert_equal 'value', weird.send('a$b')\n\n    weird.update_column('a$b', 'value2')\n    weird.reload\n    assert_equal 'value2', weird.send('a$b')\n  end\n\n  def test_multiparameter_attributes_on_date\n    attributes = { \"last_read(1i)\" => \"2004\", \"last_read(2i)\" => \"6\", \"last_read(3i)\" => \"24\" }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    # note that extra #to_date call allows test to pass for Oracle, which\n    # treats dates/times the same\n    assert_date_from_db Date.new(2004, 6, 24), topic.last_read.to_date\n  end\n\n  def test_multiparameter_attributes_on_date_with_empty_year\n    attributes = { \"last_read(1i)\" => \"\", \"last_read(2i)\" => \"6\", \"last_read(3i)\" => \"24\" }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    # note that extra #to_date call allows test to pass for Oracle, which\n    # treats dates/times the same\n    assert_nil topic.last_read\n  end\n\n  def test_multiparameter_attributes_on_date_with_empty_month\n    attributes = { \"last_read(1i)\" => \"2004\", \"last_read(2i)\" => \"\", \"last_read(3i)\" => \"24\" }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    # note that extra #to_date call allows test to pass for Oracle, which\n    # treats dates/times the same\n    assert_nil topic.last_read\n  end\n\n  def test_multiparameter_attributes_on_date_with_empty_day\n    attributes = { \"last_read(1i)\" => \"2004\", \"last_read(2i)\" => \"6\", \"last_read(3i)\" => \"\" }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    # note that extra #to_date call allows test to pass for Oracle, which\n    # treats dates/times the same\n    assert_nil topic.last_read\n  end\n\n  def test_multiparameter_attributes_on_date_with_empty_day_and_year\n    attributes = { \"last_read(1i)\" => \"\", \"last_read(2i)\" => \"6\", \"last_read(3i)\" => \"\" }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    # note that extra #to_date call allows test to pass for Oracle, which\n    # treats dates/times the same\n    assert_nil topic.last_read\n  end\n\n  def test_multiparameter_attributes_on_date_with_empty_day_and_month\n    attributes = { \"last_read(1i)\" => \"2004\", \"last_read(2i)\" => \"\", \"last_read(3i)\" => \"\" }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    # note that extra #to_date call allows test to pass for Oracle, which\n    # treats dates/times the same\n    assert_nil topic.last_read\n  end\n\n  def test_multiparameter_attributes_on_date_with_empty_year_and_month\n    attributes = { \"last_read(1i)\" => \"\", \"last_read(2i)\" => \"\", \"last_read(3i)\" => \"24\" }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    # note that extra #to_date call allows test to pass for Oracle, which\n    # treats dates/times the same\n    assert_nil topic.last_read\n  end\n\n  def test_multiparameter_attributes_on_date_with_all_empty\n    attributes = { \"last_read(1i)\" => \"\", \"last_read(2i)\" => \"\", \"last_read(3i)\" => \"\" }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_nil topic.last_read\n  end\n\n  def test_multiparameter_attributes_on_time\n    attributes = {\n      \"written_on(1i)\" => \"2004\", \"written_on(2i)\" => \"6\", \"written_on(3i)\" => \"24\",\n      \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"24\", \"written_on(6i)\" => \"00\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_equal Time.local(2004, 6, 24, 16, 24, 0), topic.written_on\n  end\n\n  def test_multiparameter_attributes_on_time_with_no_date\n    ex = assert_raise(ActiveRecord::MultiparameterAssignmentErrors) do\n      attributes = {\n        \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"24\", \"written_on(6i)\" => \"00\"\n      }\n      topic = Topic.find(1)\n      topic.attributes = attributes\n    end\n    assert_equal(\"written_on\", ex.errors[0].attribute)\n  end\n\n  def test_multiparameter_attributes_on_time_with_invalid_time_params\n    ex = assert_raise(ActiveRecord::MultiparameterAssignmentErrors) do\n      attributes = {\n        \"written_on(1i)\" => \"2004\", \"written_on(2i)\" => \"6\", \"written_on(3i)\" => \"24\",\n        \"written_on(4i)\" => \"2004\", \"written_on(5i)\" => \"36\", \"written_on(6i)\" => \"64\",\n      }\n      topic = Topic.find(1)\n      topic.attributes = attributes\n    end\n    assert_equal(\"written_on\", ex.errors[0].attribute)\n  end\n\n  def test_multiparameter_attributes_on_time_with_old_date\n    attributes = {\n      \"written_on(1i)\" => \"1850\", \"written_on(2i)\" => \"6\", \"written_on(3i)\" => \"24\",\n      \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"24\", \"written_on(6i)\" => \"00\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    # testing against to_s(:db) representation because either a Time or a DateTime might be returned, depending on platform\n    assert_equal \"1850-06-24 16:24:00\", topic.written_on.to_s(:db)\n  end\n\n  def test_multiparameter_attributes_on_time_will_raise_on_big_time_if_missing_date_parts\n    ex = assert_raise(ActiveRecord::MultiparameterAssignmentErrors) do\n      attributes = {\n        \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"24\"\n      }\n      topic = Topic.find(1)\n      topic.attributes = attributes\n    end\n    assert_equal(\"written_on\", ex.errors[0].attribute)\n  end\n\n  def test_multiparameter_attributes_on_time_with_raise_on_small_time_if_missing_date_parts\n    ex = assert_raise(ActiveRecord::MultiparameterAssignmentErrors) do\n      attributes = {\n        \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"12\", \"written_on(6i)\" => \"02\"\n      }\n      topic = Topic.find(1)\n      topic.attributes = attributes\n    end\n    assert_equal(\"written_on\", ex.errors[0].attribute)\n  end\n\n  def test_multiparameter_attributes_on_time_will_ignore_hour_if_missing\n    attributes = {\n      \"written_on(1i)\" => \"2004\", \"written_on(2i)\" => \"12\", \"written_on(3i)\" => \"12\",\n      \"written_on(5i)\" => \"12\", \"written_on(6i)\" => \"02\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_equal Time.local(2004, 12, 12, 0, 12, 2), topic.written_on\n  end\n\n  def test_multiparameter_attributes_on_time_will_ignore_hour_if_blank\n    attributes = {\n      \"written_on(1i)\" => \"\", \"written_on(2i)\" => \"\", \"written_on(3i)\" => \"\",\n      \"written_on(4i)\" => \"\", \"written_on(5i)\" => \"12\", \"written_on(6i)\" => \"02\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_nil topic.written_on\n  end\n\n  def test_multiparameter_attributes_on_time_will_ignore_date_if_empty\n    attributes = {\n      \"written_on(1i)\" => \"\", \"written_on(2i)\" => \"\", \"written_on(3i)\" => \"\",\n      \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"24\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_nil topic.written_on\n  end\n  def test_multiparameter_attributes_on_time_with_seconds_will_ignore_date_if_empty\n    attributes = {\n      \"written_on(1i)\" => \"\", \"written_on(2i)\" => \"\", \"written_on(3i)\" => \"\",\n      \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"12\", \"written_on(6i)\" => \"02\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_nil topic.written_on\n  end\n\n  def test_multiparameter_attributes_on_time_with_utc\n    ActiveRecord::Base.default_timezone = :utc\n    attributes = {\n      \"written_on(1i)\" => \"2004\", \"written_on(2i)\" => \"6\", \"written_on(3i)\" => \"24\",\n      \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"24\", \"written_on(6i)\" => \"00\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_equal Time.utc(2004, 6, 24, 16, 24, 0), topic.written_on\n  ensure\n    ActiveRecord::Base.default_timezone = :local\n  end\n\n  def test_multiparameter_attributes_on_time_with_time_zone_aware_attributes\n    ActiveRecord::Base.time_zone_aware_attributes = true\n    ActiveRecord::Base.default_timezone = :utc\n    Time.zone = ActiveSupport::TimeZone[-28800]\n    attributes = {\n      \"written_on(1i)\" => \"2004\", \"written_on(2i)\" => \"6\", \"written_on(3i)\" => \"24\",\n      \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"24\", \"written_on(6i)\" => \"00\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_equal Time.utc(2004, 6, 24, 23, 24, 0), topic.written_on\n    assert_equal Time.utc(2004, 6, 24, 16, 24, 0), topic.written_on.time\n    assert_equal Time.zone, topic.written_on.time_zone\n  ensure\n    ActiveRecord::Base.time_zone_aware_attributes = false\n    ActiveRecord::Base.default_timezone = :local\n    Time.zone = nil\n  end\n\n  def test_multiparameter_attributes_on_time_with_time_zone_aware_attributes_false\n    ActiveRecord::Base.time_zone_aware_attributes = false\n    Time.zone = ActiveSupport::TimeZone[-28800]\n    attributes = {\n      \"written_on(1i)\" => \"2004\", \"written_on(2i)\" => \"6\", \"written_on(3i)\" => \"24\",\n      \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"24\", \"written_on(6i)\" => \"00\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_equal Time.local(2004, 6, 24, 16, 24, 0), topic.written_on\n    assert_equal false, topic.written_on.respond_to?(:time_zone)\n  ensure\n    Time.zone = nil\n  end\n\n  def test_multiparameter_attributes_on_time_with_skip_time_zone_conversion_for_attributes\n    ActiveRecord::Base.time_zone_aware_attributes = true\n    ActiveRecord::Base.default_timezone = :utc\n    Time.zone = ActiveSupport::TimeZone[-28800]\n    Topic.skip_time_zone_conversion_for_attributes = [:written_on]\n    attributes = {\n      \"written_on(1i)\" => \"2004\", \"written_on(2i)\" => \"6\", \"written_on(3i)\" => \"24\",\n      \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"24\", \"written_on(6i)\" => \"00\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_equal Time.utc(2004, 6, 24, 16, 24, 0), topic.written_on\n    assert_equal false, topic.written_on.respond_to?(:time_zone)\n  ensure\n    ActiveRecord::Base.time_zone_aware_attributes = false\n    ActiveRecord::Base.default_timezone = :local\n    Time.zone = nil\n    Topic.skip_time_zone_conversion_for_attributes = []\n  end\n\n  # Oracle, and Sybase do not have a TIME datatype.\n  unless current_adapter?(:OracleAdapter, :SybaseAdapter)\n    def test_multiparameter_attributes_on_time_only_column_with_time_zone_aware_attributes_does_not_do_time_zone_conversion\n      ActiveRecord::Base.time_zone_aware_attributes = true\n      ActiveRecord::Base.default_timezone = :utc\n      Time.zone = ActiveSupport::TimeZone[-28800]\n      attributes = {\n        \"bonus_time(1i)\" => \"2000\", \"bonus_time(2i)\" => \"1\", \"bonus_time(3i)\" => \"1\",\n        \"bonus_time(4i)\" => \"16\", \"bonus_time(5i)\" => \"24\"\n      }\n      topic = Topic.find(1)\n      topic.attributes = attributes\n      assert_equal Time.utc(2000, 1, 1, 16, 24, 0), topic.bonus_time\n      assert topic.bonus_time.utc?\n    ensure\n      ActiveRecord::Base.time_zone_aware_attributes = false\n      ActiveRecord::Base.default_timezone = :local\n      Time.zone = nil\n    end\n  end\n\n  def test_multiparameter_attributes_on_time_with_empty_seconds\n    attributes = {\n      \"written_on(1i)\" => \"2004\", \"written_on(2i)\" => \"6\", \"written_on(3i)\" => \"24\",\n      \"written_on(4i)\" => \"16\", \"written_on(5i)\" => \"24\", \"written_on(6i)\" => \"\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_equal Time.local(2004, 6, 24, 16, 24, 0), topic.written_on\n  end\n\n  def test_multiparameter_assignment_of_aggregation\n    customer = Customer.new\n    address = Address.new(\"The Street\", \"The City\", \"The Country\")\n    attributes = { \"address(1)\" => address.street, \"address(2)\" => address.city, \"address(3)\" => address.country }\n    customer.attributes = attributes\n    assert_equal address, customer.address\n  end\n\n  def test_multiparameter_assignment_of_aggregation_out_of_order\n    customer = Customer.new\n    address = Address.new(\"The Street\", \"The City\", \"The Country\")\n    attributes = { \"address(3)\" => address.country, \"address(2)\" => address.city, \"address(1)\" => address.street }\n    customer.attributes = attributes\n    assert_equal address, customer.address\n  end\n\n  def test_multiparameter_assignment_of_aggregation_with_missing_values\n    ex = assert_raise(ActiveRecord::MultiparameterAssignmentErrors) do\n      customer = Customer.new\n      address = Address.new(\"The Street\", \"The City\", \"The Country\")\n      attributes = { \"address(2)\" => address.city, \"address(3)\" => address.country }\n      customer.attributes = attributes\n    end\n    assert_equal(\"address\", ex.errors[0].attribute)\n  end\n\n  def test_multiparameter_assignment_of_aggregation_with_blank_values\n    customer = Customer.new\n    address = Address.new(\"The Street\", \"The City\", \"The Country\")\n    attributes = { \"address(1)\" => \"\", \"address(2)\" => address.city, \"address(3)\" => address.country }\n    customer.attributes = attributes\n    assert_equal Address.new(nil, \"The City\", \"The Country\"), customer.address\n  end\n\n  def test_multiparameter_assignment_of_aggregation_with_large_index\n    ex = assert_raise(ActiveRecord::MultiparameterAssignmentErrors) do\n      customer = Customer.new\n      address = Address.new(\"The Street\", \"The City\", \"The Country\")\n      attributes = { \"address(1)\" => \"The Street\", \"address(2)\" => address.city, \"address(3000)\" => address.country }\n      customer.attributes = attributes\n    end\n    assert_equal(\"address\", ex.errors[0].attribute)\n  end\n\n  def test_attributes_on_dummy_time\n    # Oracle, and Sybase do not have a TIME datatype.\n    return true if current_adapter?(:OracleAdapter, :SybaseAdapter)\n\n    attributes = {\n      \"bonus_time\" => \"5:42:00AM\"\n    }\n    topic = Topic.find(1)\n    topic.attributes = attributes\n    assert_equal Time.local(2000, 1, 1, 5, 42, 0), topic.bonus_time\n  end\n\n  def test_boolean\n    b_nil = Boolean.create({ \"value\" => nil })\n    nil_id = b_nil.id\n    b_false = Boolean.create({ \"value\" => false })\n    false_id = b_false.id\n    b_true = Boolean.create({ \"value\" => true })\n    true_id = b_true.id\n\n    b_nil = Boolean.find(nil_id)\n    assert_nil b_nil.value\n    b_false = Boolean.find(false_id)\n    assert !b_false.value?\n    b_true = Boolean.find(true_id)\n    assert b_true.value?\n  end\n\n  def test_boolean_cast_from_string\n    b_blank = Boolean.create({ \"value\" => \"\" })\n    blank_id = b_blank.id\n    b_false = Boolean.create({ \"value\" => \"0\" })\n    false_id = b_false.id\n    b_true = Boolean.create({ \"value\" => \"1\" })\n    true_id = b_true.id\n\n    b_blank = Boolean.find(blank_id)\n    assert_nil b_blank.value\n    b_false = Boolean.find(false_id)\n    assert !b_false.value?\n    b_true = Boolean.find(true_id)\n    assert b_true.value?\n  end\n\n  def test_new_record_returns_boolean\n    assert_equal false, Topic.new.persisted?\n    assert_equal true, Topic.find(1).persisted?\n  end\n\n  def test_dup\n    topic = Topic.find(1)\n    duped_topic = nil\n    assert_nothing_raised { duped_topic = topic.dup }\n    assert_equal topic.title, duped_topic.title\n    assert !duped_topic.persisted?\n\n    # test if the attributes have been duped\n    topic.title = \"a\"\n    duped_topic.title = \"b\"\n    assert_equal \"a\", topic.title\n    assert_equal \"b\", duped_topic.title\n\n    # test if the attribute values have been duped\n    topic.title = {\"a\" => \"b\"}\n    duped_topic = topic.dup\n    duped_topic.title[\"a\"] = \"c\"\n    assert_equal \"b\", topic.title[\"a\"]\n\n    # test if attributes set as part of after_initialize are duped correctly\n    assert_equal topic.author_email_address, duped_topic.author_email_address\n\n    # test if saved clone object differs from original\n    duped_topic.save\n    assert duped_topic.persisted?\n    assert_not_equal duped_topic.id, topic.id\n\n    duped_topic.reload\n    # FIXME: I think this is poor behavior, and will fix it with #5686\n    assert_equal({'a' => 'c'}.to_yaml, duped_topic.title)\n  end\n\n  def test_dup_with_aggregate_of_same_name_as_attribute\n    dev = DeveloperWithAggregate.find(1)\n    assert_kind_of DeveloperSalary, dev.salary\n\n    dup = nil\n    assert_nothing_raised { dup = dev.dup }\n    assert_kind_of DeveloperSalary, dup.salary\n    assert_equal dev.salary.amount, dup.salary.amount\n    assert !dup.persisted?\n\n    # test if the attributes have been dupd\n    original_amount = dup.salary.amount\n    dev.salary.amount = 1\n    assert_equal original_amount, dup.salary.amount\n\n    assert dup.save\n    assert dup.persisted?\n    assert_not_equal dup.id, dev.id\n  end\n\n  def test_dup_does_not_copy_associations\n    author = authors(:david)\n    assert_not_equal [], author.posts\n    author.send(:clear_association_cache)\n\n    author_dup = author.dup\n    assert_equal [], author_dup.posts\n  end\n\n  def test_clone_preserves_subtype\n    clone = nil\n    assert_nothing_raised { clone = Company.find(3).clone }\n    assert_kind_of Client, clone\n  end\n\n  def test_clone_of_new_object_with_defaults\n    developer = Developer.new\n    assert !developer.name_changed?\n    assert !developer.salary_changed?\n\n    cloned_developer = developer.clone\n    assert !cloned_developer.name_changed?\n    assert !cloned_developer.salary_changed?\n  end\n\n  def test_clone_of_new_object_marks_attributes_as_dirty\n    developer = Developer.new :name => 'Bjorn', :salary => 100000\n    assert developer.name_changed?\n    assert developer.salary_changed?\n\n    cloned_developer = developer.clone\n    assert cloned_developer.name_changed?\n    assert cloned_developer.salary_changed?\n  end\n\n  def test_clone_of_new_object_marks_as_dirty_only_changed_attributes\n    developer = Developer.new :name => 'Bjorn'\n    assert developer.name_changed?            # obviously\n    assert !developer.salary_changed?         # attribute has non-nil default value, so treated as not changed\n\n    cloned_developer = developer.clone\n    assert cloned_developer.name_changed?\n    assert !cloned_developer.salary_changed?  # ... and cloned instance should behave same\n  end\n\n  def test_dup_of_saved_object_marks_attributes_as_dirty\n    developer = Developer.create! :name => 'Bjorn', :salary => 100000\n    assert !developer.name_changed?\n    assert !developer.salary_changed?\n\n    cloned_developer = developer.dup\n    assert cloned_developer.name_changed?     # both attributes differ from defaults\n    assert cloned_developer.salary_changed?\n  end\n\n  def test_dup_of_saved_object_marks_as_dirty_only_changed_attributes\n    developer = Developer.create! :name => 'Bjorn'\n    assert !developer.name_changed?           # both attributes of saved object should be treated as not changed\n    assert !developer.salary_changed?\n\n    cloned_developer = developer.dup\n    assert cloned_developer.name_changed?     # ... but on cloned object should be\n    assert !cloned_developer.salary_changed?  # ... BUT salary has non-nil default which should be treated as not changed on cloned instance\n  end\n\n  def test_bignum\n    company = Company.find(1)\n    company.rating = 2147483647\n    company.save\n    company = Company.find(1)\n    assert_equal 2147483647, company.rating\n  end\n\n  # TODO: extend defaults tests to other databases!\n  if current_adapter?(:PostgreSQLAdapter)\n    def test_default\n      default = Default.new\n\n      # fixed dates / times\n      assert_equal Date.new(2004, 1, 1), default.fixed_date\n      assert_equal Time.local(2004, 1,1,0,0,0,0), default.fixed_time\n\n      # char types\n      assert_equal 'Y', default.char1\n      assert_equal 'a varchar field', default.char2\n      assert_equal 'a text field', default.char3\n    end\n\n    class Geometric < ActiveRecord::Base; end\n    def test_geometric_content\n\n      # accepted format notes:\n      # ()'s aren't required\n      # values can be a mix of float or integer\n\n      g = Geometric.new(\n        :a_point        => '(5.0, 6.1)',\n        #:a_line         => '((2.0, 3), (5.5, 7.0))' # line type is currently unsupported in postgresql\n        :a_line_segment => '(2.0, 3), (5.5, 7.0)',\n        :a_box          => '2.0, 3, 5.5, 7.0',\n        :a_path         => '[(2.0, 3), (5.5, 7.0), (8.5, 11.0)]',  # [ ] is an open path\n        :a_polygon      => '((2.0, 3), (5.5, 7.0), (8.5, 11.0))',\n        :a_circle       => '<(5.3, 10.4), 2>'\n      )\n\n      assert g.save\n\n      # Reload and check that we have all the geometric attributes.\n      h = ActiveRecord::IdentityMap.without { Geometric.find(g.id) }\n\n      assert_equal '(5,6.1)', h.a_point\n      assert_equal '[(2,3),(5.5,7)]', h.a_line_segment\n      assert_equal '(5.5,7),(2,3)', h.a_box   # reordered to store upper right corner then bottom left corner\n      assert_equal '[(2,3),(5.5,7),(8.5,11)]', h.a_path\n      assert_equal '((2,3),(5.5,7),(8.5,11))', h.a_polygon\n      assert_equal '<(5.3,10.4),2>', h.a_circle\n\n      # use a geometric function to test for an open path\n      objs = Geometric.find_by_sql [\"select isopen(a_path) from geometrics where id = ?\", g.id]\n      assert_equal objs[0].isopen, 't'\n\n      # test alternate formats when defining the geometric types\n\n      g = Geometric.new(\n        :a_point        => '5.0, 6.1',\n        #:a_line         => '((2.0, 3), (5.5, 7.0))' # line type is currently unsupported in postgresql\n        :a_line_segment => '((2.0, 3), (5.5, 7.0))',\n        :a_box          => '(2.0, 3), (5.5, 7.0)',\n        :a_path         => '((2.0, 3), (5.5, 7.0), (8.5, 11.0))',  # ( ) is a closed path\n        :a_polygon      => '2.0, 3, 5.5, 7.0, 8.5, 11.0',\n        :a_circle       => '((5.3, 10.4), 2)'\n      )\n\n      assert g.save\n\n      # Reload and check that we have all the geometric attributes.\n      h = ActiveRecord::IdentityMap.without { Geometric.find(g.id) }\n\n      assert_equal '(5,6.1)', h.a_point\n      assert_equal '[(2,3),(5.5,7)]', h.a_line_segment\n      assert_equal '(5.5,7),(2,3)', h.a_box   # reordered to store upper right corner then bottom left corner\n      assert_equal '((2,3),(5.5,7),(8.5,11))', h.a_path\n      assert_equal '((2,3),(5.5,7),(8.5,11))', h.a_polygon\n      assert_equal '<(5.3,10.4),2>', h.a_circle\n\n      # use a geometric function to test for an closed path\n      objs = Geometric.find_by_sql [\"select isclosed(a_path) from geometrics where id = ?\", g.id]\n      assert_equal objs[0].isclosed, 't'\n    end\n  end\n\n  class NumericData < ActiveRecord::Base\n    self.table_name = 'numeric_data'\n  end\n\n  def test_big_decimal_conditions\n    m = NumericData.new(\n      :bank_balance => 1586.43,\n      :big_bank_balance => BigDecimal(\"1000234000567.95\"),\n      :world_population => 6000000000,\n      :my_house_population => 3\n    )\n    assert m.save\n    assert_equal 0, NumericData.where(\"bank_balance > ?\", 2000.0).count\n  end\n\n  def test_numeric_fields\n    m = NumericData.new(\n      :bank_balance => 1586.43,\n      :big_bank_balance => BigDecimal(\"1000234000567.95\"),\n      :world_population => 6000000000,\n      :my_house_population => 3\n    )\n    assert m.save\n\n    m1 = NumericData.find(m.id)\n    assert_not_nil m1\n\n    # As with migration_test.rb, we should make world_population >= 2**62\n    # to cover 64-bit platforms and test it is a Bignum, but the main thing\n    # is that it's an Integer.\n    assert_kind_of Integer, m1.world_population\n    assert_equal 6000000000, m1.world_population\n\n    assert_kind_of Fixnum, m1.my_house_population\n    assert_equal 3, m1.my_house_population\n\n    assert_kind_of BigDecimal, m1.bank_balance\n    assert_equal BigDecimal(\"1586.43\"), m1.bank_balance\n\n    assert_kind_of BigDecimal, m1.big_bank_balance\n    assert_equal BigDecimal(\"1000234000567.95\"), m1.big_bank_balance\n  end\n\n  def test_auto_id\n    auto = AutoId.new\n    auto.save\n    assert(auto.id > 0)\n  end\n\n  def quote_column_name(name)\n    \"<#{name}>\"\n  end\n\n  def test_quote_keys\n    ar = AutoId.new\n    source = {\"foo\" => \"bar\", \"baz\" => \"quux\"}\n    actual = ar.send(:quote_columns, self, source)\n    inverted = actual.invert\n    assert_equal(\"<foo>\", inverted[\"bar\"])\n    assert_equal(\"<baz>\", inverted[\"quux\"])\n  end\n\n  def test_sql_injection_via_find\n    assert_raise(ActiveRecord::RecordNotFound, ActiveRecord::StatementInvalid) do\n      Topic.find(\"123456 OR id > 0\")\n    end\n  end\n\n  def test_column_name_properly_quoted\n    col_record = ColumnName.new\n    col_record.references = 40\n    assert col_record.save\n    col_record.references = 41\n    assert col_record.save\n    assert_not_nil c2 = ColumnName.find(col_record.id)\n    assert_equal(41, c2.references)\n  end\n\n  def test_quoting_arrays\n    replies = Reply.find(:all, :conditions => [ \"id IN (?)\", topics(:first).replies.collect(&:id) ])\n    assert_equal topics(:first).replies.size, replies.size\n\n    replies = Reply.find(:all, :conditions => [ \"id IN (?)\", [] ])\n    assert_equal 0, replies.size\n  end\n\n  MyObject = Struct.new :attribute1, :attribute2\n\n  def test_serialized_attribute\n    Topic.serialize(\"content\", MyObject)\n\n    myobj = MyObject.new('value1', 'value2')\n    topic = Topic.create(\"content\" => myobj)\n    assert_equal(myobj, topic.content)\n\n    topic.reload\n    assert_equal(myobj, topic.content)\n  end\n\n  def test_serialized_time_attribute\n    myobj = Time.local(2008,1,1,1,0)\n    topic = Topic.create(\"content\" => myobj).reload\n    assert_equal(myobj, topic.content)\n  end\n\n  def test_serialized_string_attribute\n    myobj = \"Yes\"\n    topic = Topic.create(\"content\" => myobj).reload\n    assert_equal(myobj, topic.content)\n  end\n\n  def test_nil_serialized_attribute_with_class_constraint\n    topic = Topic.new\n    assert_nil topic.content\n  end\n\n  def test_should_raise_exception_on_serialized_attribute_with_type_mismatch\n    myobj = MyObject.new('value1', 'value2')\n    topic = Topic.new(:content => myobj)\n    assert topic.save\n    Topic.serialize(:content, Hash)\n    assert_raise(ActiveRecord::SerializationTypeMismatch) { Topic.find(topic.id).reload.content }\n  ensure\n    Topic.serialize(:content)\n  end\n\n  def test_serialized_attribute_with_class_constraint\n    settings = { \"color\" => \"blue\" }\n    Topic.serialize(:content, Hash)\n    topic = Topic.new(:content => settings)\n    assert topic.save\n    assert_equal(settings, Topic.find(topic.id).content)\n  ensure\n    Topic.serialize(:content)\n  end\n\n  def test_serialized_default_class\n    Topic.serialize(:content, Hash)\n    topic = Topic.new\n    assert_equal Hash, topic.content.class\n    assert_equal Hash, topic.read_attribute(:content).class\n    topic.content[\"beer\"] = \"MadridRb\"\n    assert topic.save\n    topic.reload\n    assert_equal Hash, topic.content.class\n    assert_equal \"MadridRb\", topic.content[\"beer\"]\n  ensure\n    Topic.serialize(:content)\n  end\n\n  def test_serialized_no_default_class_for_object\n    topic = Topic.new\n    assert_nil topic.content\n  end\n\n  def test_serialized_boolean_value_true\n    Topic.serialize(:content)\n    topic = Topic.new(:content => true)\n    assert topic.save\n    topic = topic.reload\n    assert_equal topic.content, true\n  end\n\n  def test_serialized_boolean_value_false\n    Topic.serialize(:content)\n    topic = Topic.new(:content => false)\n    assert topic.save\n    topic = topic.reload\n    assert_equal topic.content, false\n  end\n\n  def test_serialize_with_coder\n    coder = Class.new {\n      # Identity\n      def load(thing)\n        thing\n      end\n\n      # base 64\n      def dump(thing)\n        [thing].pack('m')\n      end\n    }.new\n\n    Topic.serialize(:content, coder)\n    s = 'hello world'\n    topic = Topic.new(:content => s)\n    assert topic.save\n    topic = topic.reload\n    assert_equal [s].pack('m'), topic.content\n  ensure\n    Topic.serialize(:content)\n  end\n\n  def test_serialize_with_bcrypt_coder\n    crypt_coder = Class.new {\n      def load(thing)\n        return unless thing\n        BCrypt::Password.new thing\n      end\n\n      def dump(thing)\n        BCrypt::Password.create(thing).to_s\n      end\n    }.new\n\n    Topic.serialize(:content, crypt_coder)\n    password = 'password'\n    topic = Topic.new(:content => password)\n    assert topic.save\n    topic = topic.reload\n    assert_kind_of BCrypt::Password, topic.content\n    assert_equal(true, topic.content == password, 'password should equal')\n  ensure\n    Topic.serialize(:content)\n  end\n\n  def test_quote\n    author_name = \"\\\\ \\001 ' \\n \\\\n \\\"\"\n    topic = Topic.create('author_name' => author_name)\n    assert_equal author_name, Topic.find(topic.id).author_name\n  end\n\n  if RUBY_VERSION < '1.9'\n    def test_quote_chars\n      with_kcode('UTF8') do\n        str = 'The Narrator'\n        topic = Topic.create(:author_name => str)\n        assert_equal str, topic.author_name\n\n        assert_kind_of ActiveSupport::Multibyte.proxy_class, str.mb_chars\n        topic = Topic.find_by_author_name(str.mb_chars)\n\n        assert_kind_of Topic, topic\n        assert_equal str, topic.author_name, \"The right topic should have been found by name even with name passed as Chars\"\n      end\n    end\n  end\n\n  def test_toggle_attribute\n    assert !topics(:first).approved?\n    topics(:first).toggle!(:approved)\n    assert topics(:first).approved?\n    topic = topics(:first)\n    topic.toggle(:approved)\n    assert !topic.approved?\n    topic.reload\n    assert topic.approved?\n  end\n\n  def test_reload\n    t1 = Topic.find(1)\n    t2 = Topic.find(1)\n    t1.title = \"something else\"\n    t1.save\n    t2.reload\n    assert_equal t1.title, t2.title\n  end\n\n  def test_reload_with_exclusive_scope\n    dev = DeveloperCalledDavid.first\n    dev.update_attributes!( :name => \"NotDavid\" )\n    assert_equal dev, dev.reload\n  end\n\n  def test_define_attr_method_with_value\n    k = Class.new( ActiveRecord::Base )\n    k.send(:define_attr_method, :table_name, \"foo\")\n    assert_equal \"foo\", k.table_name\n  end\n\n  def test_define_attr_method_with_block\n    k = Class.new( ActiveRecord::Base ) do\n      class << self\n        attr_accessor :foo_key\n      end\n    end\n    k.foo_key = \"id\"\n    k.send(:define_attr_method, :foo_key) { \"sys_\" + original_foo_key }\n    assert_equal \"sys_id\", k.foo_key\n  end\n\n  def test_set_table_name_with_value\n    k = Class.new( ActiveRecord::Base )\n    k.table_name = \"foo\"\n    assert_equal \"foo\", k.table_name\n    k.set_table_name \"bar\"\n    assert_equal \"bar\", k.table_name\n  end\n\n  def test_switching_between_table_name\n    assert_difference(\"GoodJoke.count\") do\n      Joke.set_table_name \"cold_jokes\"\n      Joke.create\n\n      Joke.set_table_name \"funny_jokes\"\n      Joke.create\n    end\n  end\n\n  def test_quoted_table_name_after_set_table_name\n    klass = Class.new(ActiveRecord::Base)\n\n    klass.set_table_name \"foo\"\n    assert_equal \"foo\", klass.table_name\n    assert_equal klass.connection.quote_table_name(\"foo\"), klass.quoted_table_name\n\n    klass.set_table_name \"bar\"\n    assert_equal \"bar\", klass.table_name\n    assert_equal klass.connection.quote_table_name(\"bar\"), klass.quoted_table_name\n  end\n\n  def test_set_table_name_with_block\n    k = Class.new( ActiveRecord::Base )\n    k.set_table_name { \"ks\" }\n    assert_equal \"ks\", k.table_name\n  end\n\n  def test_set_primary_key_with_value\n    k = Class.new( ActiveRecord::Base )\n    k.primary_key = \"foo\"\n    assert_equal \"foo\", k.primary_key\n    k.set_primary_key \"bar\"\n    assert_equal \"bar\", k.primary_key\n  end\n\n  def test_set_primary_key_with_block\n    k = Class.new( ActiveRecord::Base )\n    k.primary_key = 'id'\n    k.set_primary_key { \"sys_\" + original_primary_key }\n    assert_equal \"sys_id\", k.primary_key\n  end\n\n  def test_set_inheritance_column_with_value\n    k = Class.new( ActiveRecord::Base )\n    k.inheritance_column = \"foo\"\n    assert_equal \"foo\", k.inheritance_column\n    k.set_inheritance_column \"bar\"\n    assert_equal \"bar\", k.inheritance_column\n  end\n\n  def test_set_inheritance_column_with_block\n    k = Class.new( ActiveRecord::Base )\n    k.set_inheritance_column { original_inheritance_column + \"_id\" }\n    assert_equal \"type_id\", k.inheritance_column\n  end\n\n  def test_count_with_join\n    res = Post.count_by_sql \"SELECT COUNT(*) FROM posts LEFT JOIN comments ON posts.id=comments.post_id WHERE posts.#{QUOTED_TYPE} = 'Post'\"\n\n    res2 = Post.count(:conditions => \"posts.#{QUOTED_TYPE} = 'Post'\", :joins => \"LEFT JOIN comments ON posts.id=comments.post_id\")\n    assert_equal res, res2\n\n    res3 = nil\n    assert_nothing_raised do\n      res3 = Post.count(:conditions => \"posts.#{QUOTED_TYPE} = 'Post'\",\n                        :joins => \"LEFT JOIN comments ON posts.id=comments.post_id\")\n    end\n    assert_equal res, res3\n\n    res4 = Post.count_by_sql \"SELECT COUNT(p.id) FROM posts p, comments co WHERE p.#{QUOTED_TYPE} = 'Post' AND p.id=co.post_id\"\n    res5 = nil\n    assert_nothing_raised do\n      res5 = Post.count(:conditions => \"p.#{QUOTED_TYPE} = 'Post' AND p.id=co.post_id\",\n                        :joins => \"p, comments co\",\n                        :select => \"p.id\")\n    end\n\n    assert_equal res4, res5\n\n    res6 = Post.count_by_sql \"SELECT COUNT(DISTINCT p.id) FROM posts p, comments co WHERE p.#{QUOTED_TYPE} = 'Post' AND p.id=co.post_id\"\n    res7 = nil\n    assert_nothing_raised do\n      res7 = Post.count(:conditions => \"p.#{QUOTED_TYPE} = 'Post' AND p.id=co.post_id\",\n                        :joins => \"p, comments co\",\n                        :select => \"p.id\",\n                        :distinct => true)\n    end\n    assert_equal res6, res7\n  end\n\n  def test_scoped_find_conditions\n    scoped_developers = Developer.send(:with_scope, :find => { :conditions => 'salary > 90000' }) do\n      Developer.find(:all, :conditions => 'id < 5')\n    end\n    assert !scoped_developers.include?(developers(:david)) # David's salary is less than 90,000\n    assert_equal 3, scoped_developers.size\n  end\n\n  def test_no_limit_offset\n    assert_nothing_raised do\n      Developer.find(:all, :offset => 2)\n    end\n  end\n\n  def test_scoped_find_limit_offset\n    scoped_developers = Developer.send(:with_scope, :find => { :limit => 3, :offset => 2 }) do\n      Developer.find(:all, :order => 'id')\n    end\n    assert !scoped_developers.include?(developers(:david))\n    assert !scoped_developers.include?(developers(:jamis))\n    assert_equal 3, scoped_developers.size\n\n    # Test without scoped find conditions to ensure we get the whole thing\n    developers = Developer.find(:all, :order => 'id')\n    assert_equal Developer.count, developers.size\n  end\n\n  def test_scoped_find_order\n    # Test order in scope\n    scoped_developers = Developer.send(:with_scope, :find => { :limit => 1, :order => 'salary DESC' }) do\n      Developer.find(:all)\n    end\n    assert_equal 'Jamis', scoped_developers.first.name\n    assert scoped_developers.include?(developers(:jamis))\n    # Test scope without order and order in find\n    scoped_developers = Developer.send(:with_scope, :find => { :limit => 1 }) do\n      Developer.find(:all, :order => 'salary DESC')\n    end\n    # Test scope order + find order, order has priority\n    scoped_developers = Developer.send(:with_scope, :find => { :limit => 3, :order => 'id DESC' }) do\n      Developer.find(:all, :order => 'salary ASC')\n    end\n    assert scoped_developers.include?(developers(:poor_jamis))\n    assert ! scoped_developers.include?(developers(:david))\n    assert ! scoped_developers.include?(developers(:jamis))\n    assert_equal 3, scoped_developers.size\n\n    # Test without scoped find conditions to ensure we get the right thing\n    assert ! scoped_developers.include?(Developer.find(1))\n    assert scoped_developers.include?(Developer.find(11))\n  end\n\n  def test_scoped_find_limit_offset_including_has_many_association\n    topics = Topic.send(:with_scope, :find => {:limit => 1, :offset => 1, :include => :replies}) do\n      Topic.find(:all, :order => \"topics.id\")\n    end\n    assert_equal 1, topics.size\n    assert_equal 2, topics.first.id\n  end\n\n  def test_scoped_find_order_including_has_many_association\n    developers = Developer.send(:with_scope, :find => { :order => 'developers.salary DESC', :include => :projects }) do\n      Developer.find(:all)\n    end\n    assert developers.size >= 2\n    for i in 1...developers.size\n      assert developers[i-1].salary >= developers[i].salary\n    end\n  end\n\n  def test_scoped_find_with_group_and_having\n    developers = Developer.send(:with_scope, :find => { :group => 'developers.salary', :having => \"SUM(salary) > 10000\", :select => \"SUM(salary) as salary\" }) do\n      Developer.find(:all)\n    end\n    assert_equal 3, developers.size\n  end\n\n  def test_find_last\n    last  = Developer.find :last\n    assert_equal last, Developer.find(:first, :order => 'id desc')\n  end\n\n  def test_last\n    assert_equal Developer.find(:first, :order => 'id desc'), Developer.last\n  end\n\n  def test_all\n    developers = Developer.all\n    assert_kind_of Array, developers\n    assert_equal Developer.find(:all), developers\n  end\n\n  def test_all_with_conditions\n    assert_equal Developer.find(:all, :order => 'id desc'), Developer.order('id desc').all\n  end\n\n  def test_find_ordered_last\n    last  = Developer.find :last, :order => 'developers.salary ASC'\n    assert_equal last, Developer.find(:all, :order => 'developers.salary ASC').last\n  end\n\n  def test_find_reverse_ordered_last\n    last  = Developer.find :last, :order => 'developers.salary DESC'\n    assert_equal last, Developer.find(:all, :order => 'developers.salary DESC').last\n  end\n\n  def test_find_multiple_ordered_last\n    last  = Developer.find :last, :order => 'developers.name, developers.salary DESC'\n    assert_equal last, Developer.find(:all, :order => 'developers.name, developers.salary DESC').last\n  end\n\n  def test_find_keeps_multiple_order_values\n    combined = Developer.find(:all, :order => 'developers.name, developers.salary')\n    assert_equal combined, Developer.find(:all, :order => ['developers.name', 'developers.salary'])\n  end\n\n  def test_find_keeps_multiple_group_values\n    combined = Developer.find(:all, :group => 'developers.name, developers.salary, developers.id, developers.created_at, developers.updated_at')\n    assert_equal combined, Developer.find(:all, :group => ['developers.name', 'developers.salary', 'developers.id', 'developers.created_at', 'developers.updated_at'])\n  end\n\n  def test_find_symbol_ordered_last\n    last  = Developer.find :last, :order => :salary\n    assert_equal last, Developer.find(:all, :order => :salary).last\n  end\n\n  def test_find_scoped_ordered_last\n    last_developer = Developer.send(:with_scope, :find => { :order => 'developers.salary ASC' }) do\n      Developer.find(:last)\n    end\n    assert_equal last_developer, Developer.find(:all, :order => 'developers.salary ASC').last\n  end\n\n  def test_abstract_class\n    assert !ActiveRecord::Base.abstract_class?\n    assert LoosePerson.abstract_class?\n    assert !LooseDescendant.abstract_class?\n  end\n\n  def test_base_class\n    assert_equal LoosePerson,     LoosePerson.base_class\n    assert_equal LooseDescendant, LooseDescendant.base_class\n    assert_equal TightPerson,     TightPerson.base_class\n    assert_equal TightPerson,     TightDescendant.base_class\n\n    assert_equal Post, Post.base_class\n    assert_equal Post, SpecialPost.base_class\n    assert_equal Post, StiPost.base_class\n    assert_equal SubStiPost, SubStiPost.base_class\n  end\n\n  def test_descends_from_active_record\n    # Tries to call Object.abstract_class?\n    assert_raise(NoMethodError) do\n      ActiveRecord::Base.descends_from_active_record?\n    end\n\n    # Abstract subclass of AR::Base.\n    assert LoosePerson.descends_from_active_record?\n\n    # Concrete subclass of an abstract class.\n    assert LooseDescendant.descends_from_active_record?\n\n    # Concrete subclass of AR::Base.\n    assert TightPerson.descends_from_active_record?\n\n    # Concrete subclass of a concrete class but has no type column.\n    assert TightDescendant.descends_from_active_record?\n\n    # Concrete subclass of AR::Base.\n    assert Post.descends_from_active_record?\n\n    # Abstract subclass of a concrete class which has a type column.\n    # This is pathological, as you'll never have Sub < Abstract < Concrete.\n    assert !StiPost.descends_from_active_record?\n\n    # Concrete subclasses an abstract class which has a type column.\n    assert !SubStiPost.descends_from_active_record?\n  end\n\n  def test_find_on_abstract_base_class_doesnt_use_type_condition\n    old_class = LooseDescendant\n    Object.send :remove_const, :LooseDescendant\n\n    descendant = old_class.create! :first_name => 'bob'\n    assert_not_nil LoosePerson.find(descendant.id), \"Should have found instance of LooseDescendant when finding abstract LoosePerson: #{descendant.inspect}\"\n  ensure\n    unless Object.const_defined?(:LooseDescendant)\n      Object.const_set :LooseDescendant, old_class\n    end\n  end\n\n  def test_assert_queries\n    query = lambda { ActiveRecord::Base.connection.execute 'select count(*) from developers' }\n    assert_queries(2) { 2.times { query.call } }\n    assert_queries 1, &query\n    assert_no_queries { assert true }\n  end\n\n  def test_to_param_should_return_string\n    assert_kind_of String, Client.find(:first).to_param\n  end\n\n  def test_inspect_class\n    assert_equal 'ActiveRecord::Base', ActiveRecord::Base.inspect\n    assert_equal 'LoosePerson(abstract)', LoosePerson.inspect\n    assert_match(/^Topic\\(id: integer, title: string/, Topic.inspect)\n  end\n\n  def test_inspect_instance\n    topic = topics(:first)\n    assert_equal %(#<Topic id: 1, title: \"The First Topic\", author_name: \"David\", author_email_address: \"david@loudthinking.com\", written_on: \"#{topic.written_on.to_s(:db)}\", bonus_time: \"#{topic.bonus_time.to_s(:db)}\", last_read: \"#{topic.last_read.to_s(:db)}\", content: \"Have a nice day\", approved: false, replies_count: 1, parent_id: nil, parent_title: nil, type: nil, group: nil, created_at: \"#{topic.created_at.to_s(:db)}\", updated_at: \"#{topic.updated_at.to_s(:db)}\">), topic.inspect\n  end\n\n  def test_inspect_new_instance\n    assert_match(/Topic id: nil/, Topic.new.inspect)\n  end\n\n  def test_inspect_limited_select_instance\n    assert_equal %(#<Topic id: 1>), Topic.find(:first, :select => 'id', :conditions => 'id = 1').inspect\n    assert_equal %(#<Topic id: 1, title: \"The First Topic\">), Topic.find(:first, :select => 'id, title', :conditions => 'id = 1').inspect\n  end\n\n  def test_inspect_class_without_table\n    assert_equal \"NonExistentTable(Table doesn't exist)\", NonExistentTable.inspect\n  end\n\n  def test_attribute_for_inspect\n    t = topics(:first)\n    t.title = \"The First Topic Now Has A Title With\\nNewlines And More Than 50 Characters\"\n\n    assert_equal %(\"#{t.written_on.to_s(:db)}\"), t.attribute_for_inspect(:written_on)\n    assert_equal '\"The First Topic Now Has A Title With\\nNewlines And M...\"', t.attribute_for_inspect(:title)\n  end\n\n  def test_becomes\n    assert_kind_of Reply, topics(:first).becomes(Reply)\n    assert_equal \"The First Topic\", topics(:first).becomes(Reply).title\n  end\n\n  def test_silence_sets_log_level_to_error_in_block\n    original_logger = ActiveRecord::Base.logger\n    log = StringIO.new\n    ActiveRecord::Base.logger = Logger.new(log)\n    ActiveRecord::Base.logger.level = Logger::DEBUG\n    ActiveRecord::Base.silence do\n      ActiveRecord::Base.logger.warn \"warn\"\n      ActiveRecord::Base.logger.error \"error\"\n    end\n    assert_equal \"error\\n\", log.string\n  ensure\n    ActiveRecord::Base.logger = original_logger\n  end\n\n  def test_silence_sets_log_level_back_to_level_before_yield\n    original_logger = ActiveRecord::Base.logger\n    log = StringIO.new\n    ActiveRecord::Base.logger = Logger.new(log)\n    ActiveRecord::Base.logger.level = Logger::WARN\n    ActiveRecord::Base.silence do\n    end\n    assert_equal Logger::WARN, ActiveRecord::Base.logger.level\n  ensure\n    ActiveRecord::Base.logger = original_logger\n  end\n\n  def test_benchmark_with_log_level\n    original_logger = ActiveRecord::Base.logger\n    log = StringIO.new\n    ActiveRecord::Base.logger = Logger.new(log)\n    ActiveRecord::Base.logger.level = Logger::WARN\n    ActiveRecord::Base.benchmark(\"Debug Topic Count\", :level => :debug) { Topic.count }\n    ActiveRecord::Base.benchmark(\"Warn Topic Count\",  :level => :warn)  { Topic.count }\n    ActiveRecord::Base.benchmark(\"Error Topic Count\", :level => :error) { Topic.count }\n    assert_no_match(/Debug Topic Count/, log.string)\n    assert_match(/Warn Topic Count/, log.string)\n    assert_match(/Error Topic Count/, log.string)\n  ensure\n    ActiveRecord::Base.logger = original_logger\n  end\n\n  def test_benchmark_with_use_silence\n    original_logger = ActiveRecord::Base.logger\n    log = StringIO.new\n    ActiveRecord::Base.logger = Logger.new(log)\n    ActiveRecord::Base.benchmark(\"Logging\", :level => :debug, :silence => true) { ActiveRecord::Base.logger.debug \"Loud\" }\n    ActiveRecord::Base.benchmark(\"Logging\", :level => :debug, :silence => false)  { ActiveRecord::Base.logger.debug \"Quiet\" }\n    assert_no_match(/Loud/, log.string)\n    assert_match(/Quiet/, log.string)\n  ensure\n    ActiveRecord::Base.logger = original_logger\n  end\n\n  def test_compute_type_success\n    assert_equal Author, ActiveRecord::Base.send(:compute_type, 'Author')\n  end\n\n  def test_compute_type_nonexistent_constant\n    assert_raises NameError do\n      ActiveRecord::Base.send :compute_type, 'NonexistentModel'\n    end\n  end\n\n  def test_compute_type_no_method_error\n    ActiveSupport::Dependencies.stubs(:constantize).raises(NoMethodError)\n    assert_raises NoMethodError do\n      ActiveRecord::Base.send :compute_type, 'InvalidModel'\n    end\n  end\n\n  def test_compute_type_argument_error\n    ActiveSupport::Dependencies.stubs(:constantize).raises(ArgumentError)\n    assert_raises ArgumentError do\n      ActiveRecord::Base.send :compute_type, 'InvalidModel'\n    end\n  end\n\n  def test_clear_cache!\n    # preheat cache\n    c1 = Post.columns\n    ActiveRecord::Base.clear_cache!\n    c2 = Post.columns\n    assert_not_equal c1, c2\n  end\n\n  def test_current_scope_is_reset\n    Object.const_set :UnloadablePost, Class.new(ActiveRecord::Base)\n    UnloadablePost.send(:current_scope=, UnloadablePost.scoped)\n\n    UnloadablePost.unloadable\n    assert_not_nil Thread.current[:UnloadablePost_current_scope]\n    ActiveSupport::Dependencies.remove_unloadable_constants!\n    assert_nil Thread.current[:UnloadablePost_current_scope]\n  ensure\n    Object.class_eval{ remove_const :UnloadablePost } if defined?(UnloadablePost)\n  end\n\n  def test_marshal_round_trip\n    expected = posts(:welcome)\n    marshalled = Marshal.dump(expected)\n    actual   = Marshal.load(marshalled)\n\n    assert_equal expected.attributes, actual.attributes\n  end\n\n  def test_marshal_new_record_round_trip\n    marshalled = Marshal.dump(Post.new)\n    post       = Marshal.load(marshalled)\n\n    assert post.new_record?, \"should be a new record\"\n  end\n\n  def test_marshalling_with_associations\n    post = Post.new\n    post.comments.build\n\n    marshalled = Marshal.dump(post)\n    post       = Marshal.load(marshalled)\n\n    assert_equal 1, post.comments.length\n  end\n\n  def test_attribute_names\n    assert_equal [\"id\", \"type\", \"ruby_type\", \"firm_id\", \"firm_name\", \"name\", \"client_of\", \"rating\", \"account_id\"],\n                 Company.attribute_names\n  end\n\n  def test_attribute_names_on_table_not_exists\n    assert_equal [], NonExistentTable.attribute_names\n  end\n\n  def test_attribtue_names_on_abstract_class\n    assert_equal [], AbstractCompany.attribute_names\n  end\n\n  def test_cache_key_for_existing_record_is_not_timezone_dependent\n    ActiveRecord::Base.time_zone_aware_attributes = true\n\n    Time.zone = \"UTC\"\n    utc_key = Developer.first.cache_key\n\n    Time.zone = \"EST\"\n    est_key = Developer.first.cache_key\n\n    assert_equal utc_key, est_key\n  ensure\n    ActiveRecord::Base.time_zone_aware_attributes = false\n  end\n\n  def test_cache_key_format_for_existing_record_with_updated_at\n    dev = Developer.first\n    assert_equal \"developers/#{dev.id}-#{dev.updated_at.utc.to_s(:number)}\", dev.cache_key\n  end\n\n  def test_cache_key_format_for_existing_record_with_nil_updated_at\n    dev = Developer.first\n    dev.update_attribute(:updated_at, nil)\n    assert_match(/\\/#{dev.id}$/, dev.cache_key)\n  end\nend\n"], "filenames": ["activerecord/lib/active_record/connection_adapters/mysql2_adapter.rb", "activerecord/lib/active_record/connection_adapters/mysql_adapter.rb", "activerecord/lib/active_record/connection_adapters/sqlite_adapter.rb", "activerecord/test/cases/base_test.rb"], "buggy_code_start_loc": [172, 253, 151, 69], "buggy_code_end_loc": [173, 254, 152, 69], "fixing_code_start_loc": [172, 253, 151, 70], "fixing_code_end_loc": [173, 254, 152, 87], "type": "CWE-89", "message": "Multiple SQL injection vulnerabilities in the quote_table_name method in the ActiveRecord adapters in activerecord/lib/active_record/connection_adapters/ in Ruby on Rails before 2.3.13, 3.0.x before 3.0.10, and 3.1.x before 3.1.0.rc5 allow remote attackers to execute arbitrary SQL commands via a crafted column name.", "other": {"cve": {"id": "CVE-2011-2930", "sourceIdentifier": "secalert@redhat.com", "published": "2011-08-29T18:55:01.457", "lastModified": "2019-08-08T15:42:27.043", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Multiple SQL injection vulnerabilities in the quote_table_name method in the ActiveRecord adapters in activerecord/lib/active_record/connection_adapters/ in Ruby on Rails before 2.3.13, 3.0.x before 3.0.10, and 3.1.x before 3.1.0.rc5 allow remote attackers to execute arbitrary SQL commands via a crafted column name."}, {"lang": "es", "value": "M\u00faltiples vulnerabilidades de inyecci\u00f3n SQL en el m\u00e9todo quote_table_name en el adaptador ActiveRecord de activerecord/lib/active_record/connection_adapters/ in Ruby on Rails antes de v2.3.13, v3.0.x antes de v3.0.10, y v3.1.x antes de v3.1.0.rc5, permite a atacantes remotos ejecutar comandos SQL de su elecci\u00f3n a trav\u00e9s de un nombre de columna modificado."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "50EEAFDA-7782-4E1E-9058-205AD4BE9A01"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.0.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "CAC748BB-BFC5-44F7-B633-CEEBB1279889"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "38CF2C31-70BB-41D3-9462-0A8B9869A5F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "F8584B37-7950-4C89-83D2-04E1ACDC60BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "8CB26F65-5CFB-4BF8-BCC4-679327D4A8DB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "EF12EA5D-5EB5-46A8-AC60-65B327D610AD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "87B4B121-94BD-4E0F-8860-6239890043B9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "63CF211C-683E-4F7D-8C62-05B153AC1960"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "456A2F7E-CC66-48C4-B028-353D2976837A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "9B1CDAFA-2AC6-4C46-9E65-0BE9127E770F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "F9806A84-2160-40EA-9960-AE7756CE4E0A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "07EC67D4-3D0F-4FF9-8197-71175DCB2723"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D1467583-23E9-4E2B-982D-80A356174BB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "4DC784C0-5618-4C32-8C17-BE7041656E14"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "CFB9ABB5-1F78-4CF0-BA82-7833E0F7A56E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.9:*:*:*:*:*:*:*", "matchCriteriaId": "AF3ED96F-3EA4-4E47-A559-9DF9A7D3DDE2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.10:*:*:*:*:*:*:*", "matchCriteriaId": "3B38EAA4-E948-45A7-B6E5-7214F2B545E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.11:*:*:*:*:*:*:*", "matchCriteriaId": "6ECC8C49-5A46-4D23-81F9-8243F5D508DB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.12:*:*:*:*:*:*:*", "matchCriteriaId": "312848C5-BA35-4A48-B66D-195A5E1CD00F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "E3BE7DFE-BA20-434B-A1DE-AD038B255C60"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.0:beta:*:*:*:*:*:*", "matchCriteriaId": "DCEE5B21-C990-4705-8239-0D7B29DAEDA1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "65EE33B1-B079-4CDE-B9C2-F1613A4610DC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "5CAAA20B-824F-4448-99DC-9712FE628073"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "D2BEBDFB-0F30-454A-B74C-F820C9D2708B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.0:rc:*:*:*:*:*:*", "matchCriteriaId": "1D7CD8C1-95D1-477E-AD96-6582EC33BA01"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "B6F00D98-3D0F-40AF-AE4F-090B1E6B660C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "9476CE55-69C0-45D3-B723-6F459C90BF05"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.1:pre:*:*:*:*:*:*", "matchCriteriaId": "486F5BA6-BCF7-4691-9754-19D364B4438D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "112FC73B-A8BC-4EEA-9F4B-CCE685EF2838"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.2:pre:*:*:*:*:*:*", "matchCriteriaId": "E4498383-6FCA-4E17-A1FD-B0CE7EE50F85"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "D26565B1-2BA6-4A3C-9264-7FC9A1820B59"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "644EF85E-6D3E-4F5C-96B0-49AD2A2D90CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "392E2D58-CB39-4832-B4D9-9C2E23B8E14C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.5:rc1:*:*:*:*:*:*", "matchCriteriaId": "1F2466EA-7039-46A1-B4A3-8DACD1953A59"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "0CAB4E72-0A15-4B26-9B69-074C278568D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.6:rc1:*:*:*:*:*:*", "matchCriteriaId": "A085E105-9375-440A-80CB-9B23E6D7EB4A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.6:rc2:*:*:*:*:*:*", "matchCriteriaId": "25911E48-C5D7-4ED8-B4DB-7523A74CCF49"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "FE6EC1E5-3A4A-4751-9F77-28EF5AF681E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.7:rc1:*:*:*:*:*:*", "matchCriteriaId": "B29674E3-CC80-446B-9A43-82594AE7A058"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.7:rc2:*:*:*:*:*:*", "matchCriteriaId": "FF34D8CB-2B6D-4CB8-A206-108293BCFFE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "8E5187F6-E3AC-4E0D-B1D0-83DE76C20A4B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.8:rc1:*:*:*:*:*:*", "matchCriteriaId": "272268EE-E3E8-4683-B679-55D748877A7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.8:rc2:*:*:*:*:*:*", "matchCriteriaId": "7B69FD33-61FE-4F10-BBE1-215F59035D30"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.8:rc3:*:*:*:*:*:*", "matchCriteriaId": "08D7CB5D-82EF-4A24-A792-938FAB40863D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.8:rc4:*:*:*:*:*:*", "matchCriteriaId": "8A044B21-47D5-468D-AF4A-06B3B5CC0824"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "2196F3D0-532A-40F9-843A-1DFBC8B63FDC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.9:rc1:*:*:*:*:*:*", "matchCriteriaId": "CBEDA932-6CB5-438C-94E4-824732A91BE0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.9:rc2:*:*:*:*:*:*", "matchCriteriaId": "903E5524-5E45-48CE-A804-EDAEBE3A79AD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.9:rc3:*:*:*:*:*:*", "matchCriteriaId": "08534AF2-F94E-4FB6-A572-4FB9827276D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.9:rc4:*:*:*:*:*:*", "matchCriteriaId": "29E3B4A6-1346-4358-B7BC-84D00ED3ABBE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.9:rc5:*:*:*:*:*:*", "matchCriteriaId": "B52D7A6B-DD93-45F0-9186-18ABEFF28DF4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.0.10:rc1:*:*:*:*:*:*", "matchCriteriaId": "A1CB1B12-99F5-430F-AE19-9A95C17FA123"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "DB51F3E9-4899-49A9-9E7B-0DCA92A91DD8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.1.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "F884F2F4-94F3-46CB-860B-1BCC0EEF408A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.1.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "88DFBB48-1C29-4639-9369-F5B413CA2337"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.1.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "D37696D7-BEE6-4587-9E33-A7FE24780409"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.1.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "E95B5D44-0C8D-47BC-A89D-48A5BDEB84F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:3.1.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "1DFDAF6A-76AA-436F-A4F3-DA69892DE2B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:ruby_on_rails:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "224BD488-0D7E-4F8B-9012-DE872DEB544C"}]}]}], "references": [{"url": "http://groups.google.com/group/rubyonrails-security/msg/b1a85d36b0f9dd30?dmode=source&output=gplain", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2011-September/065212.html", "source": "secalert@redhat.com"}, {"url": "http://weblog.rubyonrails.org/2011/8/16/ann-rails-3-1-0-rc6", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.debian.org/security/2011/dsa-2301", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/08/17/1", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/08/19/11", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/08/20/1", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/08/22/13", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/08/22/14", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/08/22/5", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=731438", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://github.com/rails/rails/commit/8a39f411dc3c806422785b1f4d5c7c9d58e4bf85", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/rails/rails/commit/8a39f411dc3c806422785b1f4d5c7c9d58e4bf85"}}