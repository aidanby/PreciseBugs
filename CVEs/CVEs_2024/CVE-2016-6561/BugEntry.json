{"buggy_code": ["/*\n * This file and its contents are supplied under the terms of the\n * Common Development and Distribution License (\"CDDL\"), version 1.0.\n * You may only use this file in accordance with the terms of version\n * 1.0 of the CDDL.\n *\n * A full copy of the text of the CDDL should have accompanied this\n * source.  A copy of the CDDL is also available via the Internet at\n * http://www.illumos.org/license/CDDL.\n */\n\n/*\n * Copyright 2014 Nexenta Systems, Inc.  All rights reserved.\n */\n\n/*\n * Dispatch function for SMB2_FLUSH\n */\n\n#include <smbsrv/smb2_kproto.h>\n#include <smbsrv/smb_fsops.h>\n\nsmb_sdrc_t\nsmb2_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t *of = NULL;\n\tuint16_t StructSize;\n\tuint16_t reserved1;\n\tuint32_t reserved2;\n\tsmb2fid_t smb2fid;\n\tuint32_t status;\n\tint rc = 0;\n\n\t/*\n\t * SMB2 Flush request\n\t */\n\trc = smb_mbc_decodef(\n\t    &sr->smb_data, \"wwlqq\",\n\t    &StructSize,\t\t/* w */\n\t    &reserved1,\t\t\t/* w */\n\t    &reserved2,\t\t\t/* l */\n\t    &smb2fid.persistent,\t/* q */\n\t    &smb2fid.temporal);\t\t/* q */\n\tif (rc)\n\t\treturn (SDRC_ERROR);\n\tif (StructSize != 24)\n\t\treturn (SDRC_ERROR);\n\n\tstatus = smb2sr_lookup_fid(sr, &smb2fid);\n\tif (status) {\n\t\tsmb2sr_put_error(sr, status);\n\t\treturn (SDRC_SUCCESS);\n\t}\n\tof = sr->fid_ofile;\n\n\t/*\n\t * XXX - todo:\n\t * Flush named pipe should drain writes.\n\t */\n\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n\n\t/*\n\t * SMB2 Flush reply\n\t */\n\t(void) smb_mbc_encodef(\n\t    &sr->reply, \"wwl\",\n\t    4,\t/* StructSize */\t/* w */\n\t    0); /* reserved */\t\t/* w */\n\n\treturn (SDRC_SUCCESS);\n}\n", "/*\n * CDDL HEADER START\n *\n * The contents of this file are subject to the terms of the\n * Common Development and Distribution License (the \"License\").\n * You may not use this file except in compliance with the License.\n *\n * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE\n * or http://www.opensolaris.org/os/licensing.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL HEADER in each\n * file and include the License file at usr/src/OPENSOLARIS.LICENSE.\n * If applicable, add the following below this CDDL HEADER, with the\n * fields enclosed by brackets \"[]\" replaced with your own identifying\n * information: Portions Copyright [yyyy] [name of copyright owner]\n *\n * CDDL HEADER END\n */\n/*\n * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.\n * Use is subject to license terms.\n */\n\n/*\n * The flush SMB is sent to ensure all data and allocation information\n * for the corresponding file has been written to stable storage. This\n * is a synchronous request. The response should not be sent until the\n * writes are complete.\n *\n * The SmbFlush request is described in CIFS/1.0 1996 Section 3.9.14.\n *\n * CIFS/1.0 June 13, 1996\n * Heizer, et al\n * draft-heizer-cifs-v1-spec-00.txt\n */\n\n#include <smbsrv/smb_kproto.h>\n#include <smbsrv/smb_fsops.h>\n\n\nstatic void smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile);\n\n/*\n * smb_com_flush\n *\n * Flush any cached data for a specified file, or for all files that\n * this client has open, to stable storage. If the fid is valid (i.e.\n * not 0xFFFF), we flush only that file. Otherwise we flush all files\n * associated with this client.\n *\n * We need to protect the list because there's a good chance we'll\n * block during the flush operation.\n */\nsmb_sdrc_t\nsmb_pre_flush(smb_request_t *sr)\n{\n\tint rc;\n\n\trc = smbsr_decode_vwv(sr, \"w\", &sr->smb_fid);\n\n\tDTRACE_SMB_1(op__Flush__start, smb_request_t *, sr);\n\n\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n}\n\nvoid\nsmb_post_flush(smb_request_t *sr)\n{\n\tDTRACE_SMB_1(op__Flush__done, smb_request_t *, sr);\n}\n\nsmb_sdrc_t\nsmb_com_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t\t*file;\n\tsmb_llist_t\t*flist;\n\tint\t\trc;\n\n\tif (smb_flush_required == 0) {\n\t\trc = smbsr_encode_empty_result(sr);\n\t\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n\t}\n\n\tif (sr->smb_fid != 0xffff) {\n\t\tsmbsr_lookup_file(sr);\n\t\tif (sr->fid_ofile == NULL) {\n\t\t\tsmbsr_error(sr, NT_STATUS_INVALID_HANDLE,\n\t\t\t    ERRDOS, ERRbadfid);\n\t\t\treturn (SDRC_ERROR);\n\t\t}\n\n\t\tsmb_flush_file(sr, sr->fid_ofile);\n\t} else {\n\t\tflist = &sr->tid_tree->t_ofile_list;\n\t\tsmb_llist_enter(flist, RW_READER);\n\t\tfile = smb_llist_head(flist);\n\t\twhile (file) {\n\t\t\tmutex_enter(&file->f_mutex);\n\t\t\tsmb_flush_file(sr, file);\n\t\t\tmutex_exit(&file->f_mutex);\n\t\t\tfile = smb_llist_next(flist, file);\n\t\t}\n\t\tsmb_llist_exit(flist);\n\t}\n\n\trc = smbsr_encode_empty_result(sr);\n\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n}\n\n\n/*\n * smb_flush_file\n *\n * If writes on this file are not synchronous, flush it using the NFSv3\n * commit interface.\n */\nstatic void\nsmb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)\n{\n\tsr->user_cr = smb_ofile_getcred(ofile);\n\n\tif ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);\n}\n", "/*\n * CDDL HEADER START\n *\n * The contents of this file are subject to the terms of the\n * Common Development and Distribution License (the \"License\").\n * You may not use this file except in compliance with the License.\n *\n * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE\n * or http://www.opensolaris.org/os/licensing.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL HEADER in each\n * file and include the License file at usr/src/OPENSOLARIS.LICENSE.\n * If applicable, add the following below this CDDL HEADER, with the\n * fields enclosed by brackets \"[]\" replaced with your own identifying\n * information: Portions Copyright [yyyy] [name of copyright owner]\n *\n * CDDL HEADER END\n */\n/*\n * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.\n * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.\n */\n\n/*\n * General Structures Layout\n * -------------------------\n *\n * This is a simplified diagram showing the relationship between most of the\n * main structures.\n *\n * +-------------------+\n * |     SMB_INFO      |\n * +-------------------+\n *          |\n *          |\n *          v\n * +-------------------+       +-------------------+      +-------------------+\n * |     SESSION       |<----->|     SESSION       |......|      SESSION      |\n * +-------------------+       +-------------------+      +-------------------+\n *   |          |\n *   |          |\n *   |          v\n *   |  +-------------------+     +-------------------+   +-------------------+\n *   |  |       USER        |<--->|       USER        |...|       USER        |\n *   |  +-------------------+     +-------------------+   +-------------------+\n *   |\n *   |\n *   v\n * +-------------------+       +-------------------+      +-------------------+\n * |       TREE        |<----->|       TREE        |......|       TREE        |\n * +-------------------+       +-------------------+      +-------------------+\n *      |         |\n *      |         |\n *      |         v\n *      |     +-------+       +-------+      +-------+\n *      |     | OFILE |<----->| OFILE |......| OFILE |\n *      |     +-------+       +-------+      +-------+\n *      |\n *      |\n *      v\n *  +-------+       +------+      +------+\n *  | ODIR  |<----->| ODIR |......| ODIR |\n *  +-------+       +------+      +------+\n *\n *\n * Ofile State Machine\n * ------------------\n *\n *    +-------------------------+\t T0\n *    |  SMB_OFILE_STATE_OPEN   |<----------- Creation/Allocation\n *    +-------------------------+\n *\t\t    |\n *\t\t    | T1\n *\t\t    |\n *\t\t    v\n *    +-------------------------+\n *    | SMB_OFILE_STATE_CLOSING |\n *    +-------------------------+\n *\t\t    |\n *\t\t    | T2\n *\t\t    |\n *\t\t    v\n *    +-------------------------+    T3\n *    | SMB_OFILE_STATE_CLOSED  |----------> Deletion/Free\n *    +-------------------------+\n *\n * SMB_OFILE_STATE_OPEN\n *\n *    While in this state:\n *      - The ofile is queued in the list of ofiles of its tree.\n *      - References will be given out if the ofile is looked up.\n *\n * SMB_OFILE_STATE_CLOSING\n *\n *    While in this state:\n *      - The ofile is queued in the list of ofiles of its tree.\n *      - References will not be given out if the ofile is looked up.\n *      - The file is closed and the locks held are being released.\n *      - The resources associated with the ofile remain.\n *\n * SMB_OFILE_STATE_CLOSED\n *\n *    While in this state:\n *      - The ofile is queued in the list of ofiles of its tree.\n *      - References will not be given out if the ofile is looked up.\n *      - The resources associated with the ofile remain.\n *\n * Transition T0\n *\n *    This transition occurs in smb_ofile_open(). A new ofile is created and\n *    added to the list of ofiles of a tree.\n *\n * Transition T1\n *\n *    This transition occurs in smb_ofile_close().\n *\n * Transition T2\n *\n *    This transition occurs in smb_ofile_release(). The resources associated\n *    with the ofile are freed as well as the ofile structure. For the\n *    transition to occur, the ofile must be in the SMB_OFILE_STATE_CLOSED\n *    state and the reference count be zero.\n *\n * Comments\n * --------\n *\n *    The state machine of the ofile structures is controlled by 3 elements:\n *      - The list of ofiles of the tree it belongs to.\n *      - The mutex embedded in the structure itself.\n *      - The reference count.\n *\n *    There's a mutex embedded in the ofile structure used to protect its fields\n *    and there's a lock embedded in the list of ofiles of a tree. To\n *    increment or to decrement the reference count the mutex must be entered.\n *    To insert the ofile into the list of ofiles of the tree and to remove\n *    the ofile from it, the lock must be entered in RW_WRITER mode.\n *\n *    Rules of access to a ofile structure:\n *\n *    1) In order to avoid deadlocks, when both (mutex and lock of the ofile\n *       list) have to be entered, the lock must be entered first.\n *\n *    2) All actions applied to an ofile require a reference count.\n *\n *    3) There are 2 ways of getting a reference count. One is when the ofile\n *       is opened. The other one when the ofile is looked up. This translates\n *       into 2 functions: smb_ofile_open() and smb_ofile_lookup_by_fid().\n *\n *    It should be noted that the reference count of an ofile registers the\n *    number of references to the ofile in other structures (such as an smb\n *    request). The reference count is not incremented in these 2 instances:\n *\n *    1) The ofile is open. An ofile is anchored by his state. If there's\n *       no activity involving an ofile currently open, the reference count\n *       of that ofile is zero.\n *\n *    2) The ofile is queued in the list of ofiles of its tree. The fact of\n *       being queued in that list is NOT registered by incrementing the\n *       reference count.\n */\n#include <smbsrv/smb_kproto.h>\n#include <smbsrv/smb_fsops.h>\n\nstatic boolean_t smb_ofile_is_open_locked(smb_ofile_t *);\nstatic smb_ofile_t *smb_ofile_close_and_next(smb_ofile_t *);\nstatic int smb_ofile_netinfo_encode(smb_ofile_t *, uint8_t *, size_t,\n    uint32_t *);\nstatic int smb_ofile_netinfo_init(smb_ofile_t *, smb_netfileinfo_t *);\nstatic void smb_ofile_netinfo_fini(smb_netfileinfo_t *);\n\n/*\n * smb_ofile_open\n */\nsmb_ofile_t *\nsmb_ofile_open(\n    smb_request_t\t*sr,\n    smb_node_t\t\t*node,\n    struct open_param\t*op,\n    uint16_t\t\tftype,\n    uint32_t\t\tuniqid,\n    smb_error_t\t\t*err)\n{\n\tsmb_tree_t\t*tree = sr->tid_tree;\n\tsmb_ofile_t\t*of;\n\tuint16_t\tfid;\n\tsmb_attr_t\tattr;\n\tint\t\trc;\n\tenum errstates { EMPTY, FIDALLOC, CRHELD, MUTEXINIT };\n\tenum errstates\tstate = EMPTY;\n\n\tif (smb_idpool_alloc(&tree->t_fid_pool, &fid)) {\n\t\terr->status = NT_STATUS_TOO_MANY_OPENED_FILES;\n\t\terr->errcls = ERRDOS;\n\t\terr->errcode = ERROR_TOO_MANY_OPEN_FILES;\n\t\treturn (NULL);\n\t}\n\tstate = FIDALLOC;\n\n\tof = kmem_cache_alloc(smb_cache_ofile, KM_SLEEP);\n\tbzero(of, sizeof (smb_ofile_t));\n\tof->f_magic = SMB_OFILE_MAGIC;\n\tof->f_refcnt = 1;\n\tof->f_fid = fid;\n\tof->f_uniqid = uniqid;\n\tof->f_opened_by_pid = sr->smb_pid;\n\tof->f_granted_access = op->desired_access;\n\tof->f_share_access = op->share_access;\n\tof->f_create_options = op->create_options;\n\tof->f_cr = (op->create_options & FILE_OPEN_FOR_BACKUP_INTENT) ?\n\t    smb_user_getprivcred(sr->uid_user) : sr->uid_user->u_cred;\n\tcrhold(of->f_cr);\n\tstate = CRHELD;\n\tof->f_ftype = ftype;\n\tof->f_server = tree->t_server;\n\tof->f_session = tree->t_session;\n\t/*\n\t * grab a ref for of->f_user\n\t * released in smb_ofile_delete()\n\t */\n\tsmb_user_hold_internal(sr->uid_user);\n\tof->f_user = sr->uid_user;\n\tof->f_tree = tree;\n\tof->f_node = node;\n\n\tmutex_init(&of->f_mutex, NULL, MUTEX_DEFAULT, NULL);\n\tstate = MUTEXINIT;\n\tof->f_state = SMB_OFILE_STATE_OPEN;\n\n\tif (ftype == SMB_FTYPE_MESG_PIPE) {\n\t\t/* See smb_opipe_open. */\n\t\tof->f_pipe = op->pipe;\n\t\tsmb_server_inc_pipes(of->f_server);\n\t} else {\n\t\tASSERT(ftype == SMB_FTYPE_DISK); /* Regular file, not a pipe */\n\t\tASSERT(node);\n\n\t\t/*\n\t\t * Note that the common open path often adds bits like\n\t\t * READ_CONTROL, so the logic \"is this open exec-only\"\n\t\t * needs to look at only the FILE_DATA_ALL bits.\n\t\t */\n\t\tif ((of->f_granted_access & FILE_DATA_ALL) == FILE_EXECUTE)\n\t\t\tof->f_flags |= SMB_OFLAGS_EXECONLY;\n\n\t\tbzero(&attr, sizeof (smb_attr_t));\n\t\tattr.sa_mask = SMB_AT_UID | SMB_AT_DOSATTR;\n\t\trc = smb_node_getattr(NULL, node, of->f_cr, NULL, &attr);\n\t\tif (rc != 0) {\n\t\t\terr->status = NT_STATUS_INTERNAL_ERROR;\n\t\t\terr->errcls = ERRDOS;\n\t\t\terr->errcode = ERROR_INTERNAL_ERROR;\n\t\t\tgoto errout;\n\t\t}\n\t\tif (crgetuid(of->f_cr) == attr.sa_vattr.va_uid) {\n\t\t\t/*\n\t\t\t * Add this bit for the file's owner even if it's not\n\t\t\t * specified in the request (Windows behavior).\n\t\t\t */\n\t\t\tof->f_granted_access |= FILE_READ_ATTRIBUTES;\n\t\t}\n\n\t\tif (smb_node_is_file(node)) {\n\t\t\tof->f_mode =\n\t\t\t    smb_fsop_amask_to_omode(of->f_granted_access);\n\t\t\tif (smb_fsop_open(node, of->f_mode, of->f_cr) != 0) {\n\t\t\t\terr->status = NT_STATUS_ACCESS_DENIED;\n\t\t\t\terr->errcls = ERRDOS;\n\t\t\t\terr->errcode = ERROR_ACCESS_DENIED;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t}\n\n\t\tif (tree->t_flags & SMB_TREE_READONLY)\n\t\t\tof->f_flags |= SMB_OFLAGS_READONLY;\n\n\t\t/*\n\t\t * Note that if we created_readonly, that\n\t\t * will _not_ yet show in attr.sa_dosattr\n\t\t * so creating a readonly file gives the\n\t\t * caller a writable handle as it should.\n\t\t */\n\t\tif (attr.sa_dosattr & FILE_ATTRIBUTE_READONLY)\n\t\t\tof->f_flags |= SMB_OFLAGS_READONLY;\n\n\t\tsmb_node_inc_open_ofiles(node);\n\t\tsmb_node_add_ofile(node, of);\n\t\tsmb_node_ref(node);\n\t\tsmb_server_inc_files(of->f_server);\n\t}\n\tsmb_llist_enter(&tree->t_ofile_list, RW_WRITER);\n\tsmb_llist_insert_tail(&tree->t_ofile_list, of);\n\tsmb_llist_exit(&tree->t_ofile_list);\n\tatomic_inc_32(&tree->t_open_files);\n\tatomic_inc_32(&of->f_session->s_file_cnt);\n\treturn (of);\n\nerrout:\n\tswitch (state) {\n\tcase MUTEXINIT:\n\t\tmutex_destroy(&of->f_mutex);\n\t\tsmb_user_release(of->f_user);\n\t\t/*FALLTHROUGH*/\n\tcase CRHELD:\n\t\tcrfree(of->f_cr);\n\t\tof->f_magic = 0;\n\t\tkmem_cache_free(smb_cache_ofile, of);\n\t\t/*FALLTHROUGH*/\n\tcase FIDALLOC:\n\t\tsmb_idpool_free(&tree->t_fid_pool, fid);\n\t\t/*FALLTHROUGH*/\n\tcase EMPTY:\n\t\tbreak;\n\t}\n\treturn (NULL);\n}\n\n/*\n * smb_ofile_close\n */\nvoid\nsmb_ofile_close(smb_ofile_t *of, int32_t mtime_sec)\n{\n\tsmb_attr_t *pa;\n\ttimestruc_t now;\n\tuint32_t flags = 0;\n\n\tSMB_OFILE_VALID(of);\n\n\tmutex_enter(&of->f_mutex);\n\tASSERT(of->f_refcnt);\n\tif (of->f_state != SMB_OFILE_STATE_OPEN) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn;\n\t}\n\tof->f_state = SMB_OFILE_STATE_CLOSING;\n\tmutex_exit(&of->f_mutex);\n\n\tswitch (of->f_ftype) {\n\tcase SMB_FTYPE_BYTE_PIPE:\n\tcase SMB_FTYPE_MESG_PIPE:\n\t\tsmb_opipe_close(of);\n\t\tsmb_server_dec_pipes(of->f_server);\n\t\tbreak;\n\n\tcase SMB_FTYPE_DISK:\n\tcase SMB_FTYPE_PRINTER:\n\t\t/*\n\t\t * In here we make changes to of->f_pending_attr\n\t\t * while not holding of->f_mutex.  This is OK\n\t\t * because we've changed f_state to CLOSING,\n\t\t * so no more threads will take this path.\n\t\t */\n\t\tpa = &of->f_pending_attr;\n\t\tif (mtime_sec != 0) {\n\t\t\tpa->sa_vattr.va_mtime.tv_sec = mtime_sec;\n\t\t\tpa->sa_mask |= SMB_AT_MTIME;\n\t\t}\n\n\t\t/*\n\t\t * If we have ever modified data via this handle\n\t\t * (write or truncate) and if the mtime was not\n\t\t * set via this handle, update the mtime again\n\t\t * during the close.  Windows expects this.\n\t\t * [ MS-FSA 2.1.5.4 \"Update Timestamps\" ]\n\t\t */\n\t\tif (of->f_written &&\n\t\t    (pa->sa_mask & SMB_AT_MTIME) == 0) {\n\t\t\tpa->sa_mask |= SMB_AT_MTIME;\n\t\t\tgethrestime(&now);\n\t\t\tpa->sa_vattr.va_mtime = now;\n\t\t}\n\n\t\tif (of->f_flags & SMB_OFLAGS_SET_DELETE_ON_CLOSE) {\n\t\t\tif (smb_tree_has_feature(of->f_tree,\n\t\t\t    SMB_TREE_CATIA)) {\n\t\t\t\tflags |= SMB_CATIA;\n\t\t\t}\n\t\t\t(void) smb_node_set_delete_on_close(of->f_node,\n\t\t\t    of->f_cr, flags);\n\t\t}\n\t\tsmb_fsop_unshrlock(of->f_cr, of->f_node, of->f_uniqid);\n\t\tsmb_node_destroy_lock_by_ofile(of->f_node, of);\n\n\t\tif (smb_node_is_file(of->f_node)) {\n\t\t\t(void) smb_fsop_close(of->f_node, of->f_mode,\n\t\t\t    of->f_cr);\n\t\t\tsmb_oplock_release(of->f_node, of);\n\t\t} else {\n\t\t\t/*\n\t\t\t * If there was an odir, close it.\n\t\t\t */\n\t\t\tif (of->f_odir != NULL)\n\t\t\t\tsmb_odir_close(of->f_odir);\n\t\t}\n\t\tif (smb_node_dec_open_ofiles(of->f_node) == 0) {\n\t\t\t/*\n\t\t\t * Last close. The f_pending_attr has\n\t\t\t * only times (atime,ctime,mtime) so\n\t\t\t * we can borrow it to commit the\n\t\t\t * n_pending_dosattr from the node.\n\t\t\t */\n\t\t\tpa->sa_dosattr =\n\t\t\t    of->f_node->n_pending_dosattr;\n\t\t\tif (pa->sa_dosattr != 0)\n\t\t\t\tpa->sa_mask |= SMB_AT_DOSATTR;\n\t\t\t/* Let's leave this zero when not in use. */\n\t\t\tof->f_node->n_allocsz = 0;\n\t\t}\n\t\tif (pa->sa_mask != 0) {\n\t\t\t/*\n\t\t\t * Commit any pending attributes from\n\t\t\t * the ofile we're closing.  Note that\n\t\t\t * we pass NULL as the ofile to setattr\n\t\t\t * so it will write to the file system\n\t\t\t * and not keep anything on the ofile.\n\t\t\t * This clears n_pending_dosattr if\n\t\t\t * there are no opens, otherwise the\n\t\t\t * dosattr will be pending again.\n\t\t\t */\n\t\t\t(void) smb_node_setattr(NULL, of->f_node,\n\t\t\t    of->f_cr, NULL, pa);\n\t\t}\n\n\t\t/*\n\t\t * Cancel any notify change requests that\n\t\t * may be using this open instance.\n\t\t */\n\t\tif (of->f_node->n_fcn.fcn_count)\n\t\t\tsmb_notify_file_closed(of);\n\n\t\tsmb_server_dec_files(of->f_server);\n\t\tbreak;\n\t}\n\tatomic_dec_32(&of->f_tree->t_open_files);\n\n\tmutex_enter(&of->f_mutex);\n\tASSERT(of->f_refcnt);\n\tASSERT(of->f_state == SMB_OFILE_STATE_CLOSING);\n\tof->f_state = SMB_OFILE_STATE_CLOSED;\n\tmutex_exit(&of->f_mutex);\n}\n\n/*\n * smb_ofile_close_all\n *\n *\n */\nvoid\nsmb_ofile_close_all(\n    smb_tree_t\t\t*tree)\n{\n\tsmb_ofile_t\t*of;\n\n\tASSERT(tree);\n\tASSERT(tree->t_magic == SMB_TREE_MAGIC);\n\n\tsmb_llist_enter(&tree->t_ofile_list, RW_READER);\n\tof = smb_llist_head(&tree->t_ofile_list);\n\twhile (of) {\n\t\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\t\tASSERT(of->f_tree == tree);\n\t\tof = smb_ofile_close_and_next(of);\n\t}\n\tsmb_llist_exit(&tree->t_ofile_list);\n}\n\n/*\n * smb_ofiles_close_by_pid\n *\n *\n */\nvoid\nsmb_ofile_close_all_by_pid(\n    smb_tree_t\t\t*tree,\n    uint16_t\t\tpid)\n{\n\tsmb_ofile_t\t*of;\n\n\tASSERT(tree);\n\tASSERT(tree->t_magic == SMB_TREE_MAGIC);\n\n\tsmb_llist_enter(&tree->t_ofile_list, RW_READER);\n\tof = smb_llist_head(&tree->t_ofile_list);\n\twhile (of) {\n\t\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\t\tASSERT(of->f_tree == tree);\n\t\tif (of->f_opened_by_pid == pid) {\n\t\t\tof = smb_ofile_close_and_next(of);\n\t\t} else {\n\t\t\tof = smb_llist_next(&tree->t_ofile_list, of);\n\t\t}\n\t}\n\tsmb_llist_exit(&tree->t_ofile_list);\n}\n\n/*\n * If the enumeration request is for ofile data, handle it here.\n * Otherwise, return.\n *\n * This function should be called with a hold on the ofile.\n */\nint\nsmb_ofile_enum(smb_ofile_t *of, smb_svcenum_t *svcenum)\n{\n\tuint8_t *pb;\n\tuint_t nbytes;\n\tint rc;\n\n\tASSERT(of);\n\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\tASSERT(of->f_refcnt);\n\n\tif (svcenum->se_type != SMB_SVCENUM_TYPE_FILE)\n\t\treturn (0);\n\n\tif (svcenum->se_nskip > 0) {\n\t\tsvcenum->se_nskip--;\n\t\treturn (0);\n\t}\n\n\tif (svcenum->se_nitems >= svcenum->se_nlimit) {\n\t\tsvcenum->se_nitems = svcenum->se_nlimit;\n\t\treturn (0);\n\t}\n\n\tpb = &svcenum->se_buf[svcenum->se_bused];\n\n\trc = smb_ofile_netinfo_encode(of, pb, svcenum->se_bavail,\n\t    &nbytes);\n\tif (rc == 0) {\n\t\tsvcenum->se_bavail -= nbytes;\n\t\tsvcenum->se_bused += nbytes;\n\t\tsvcenum->se_nitems++;\n\t}\n\n\treturn (rc);\n}\n\n/*\n * Take a reference on an open file.\n */\nboolean_t\nsmb_ofile_hold(smb_ofile_t *of)\n{\n\tASSERT(of);\n\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\n\tmutex_enter(&of->f_mutex);\n\n\tif (of->f_state != SMB_OFILE_STATE_OPEN) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (B_FALSE);\n\t}\n\tof->f_refcnt++;\n\n\tmutex_exit(&of->f_mutex);\n\treturn (B_TRUE);\n}\n\n/*\n * Release a reference on a file.  If the reference count falls to\n * zero and the file has been closed, post the object for deletion.\n * Object deletion is deferred to avoid modifying a list while an\n * iteration may be in progress.\n */\nvoid\nsmb_ofile_release(smb_ofile_t *of)\n{\n\tSMB_OFILE_VALID(of);\n\n\tmutex_enter(&of->f_mutex);\n\tASSERT(of->f_refcnt);\n\tof->f_refcnt--;\n\tswitch (of->f_state) {\n\tcase SMB_OFILE_STATE_OPEN:\n\tcase SMB_OFILE_STATE_CLOSING:\n\t\tbreak;\n\n\tcase SMB_OFILE_STATE_CLOSED:\n\t\tif (of->f_refcnt == 0)\n\t\t\tsmb_tree_post_ofile(of->f_tree, of);\n\t\tbreak;\n\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n\tmutex_exit(&of->f_mutex);\n}\n\n/*\n * smb_ofile_request_complete\n *\n * During oplock acquisition, all other oplock requests on the node\n * are blocked until the acquire request completes and the response\n * is on the wire.\n * Call smb_oplock_broadcast to notify the node that the request\n * has completed.\n *\n * THIS MECHANISM RELIES ON THE FACT THAT THE OFILE IS NOT REMOVED\n * FROM THE SR UNTIL REQUEST COMPLETION (when the sr is destroyed)\n */\nvoid\nsmb_ofile_request_complete(smb_ofile_t *of)\n{\n\tSMB_OFILE_VALID(of);\n\n\tswitch (of->f_ftype) {\n\tcase SMB_FTYPE_DISK:\n\t\tASSERT(of->f_node);\n\t\tsmb_oplock_broadcast(of->f_node);\n\t\tbreak;\n\tcase SMB_FTYPE_MESG_PIPE:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/*\n * smb_ofile_lookup_by_fid\n *\n * Find the open file whose fid matches the one specified in the request.\n * If we can't find the fid or the shares (trees) don't match, we have a\n * bad fid.\n */\nsmb_ofile_t *\nsmb_ofile_lookup_by_fid(\n    smb_request_t\t*sr,\n    uint16_t\t\tfid)\n{\n\tsmb_tree_t\t*tree = sr->tid_tree;\n\tsmb_llist_t\t*of_list;\n\tsmb_ofile_t\t*of;\n\n\tASSERT(tree->t_magic == SMB_TREE_MAGIC);\n\n\tof_list = &tree->t_ofile_list;\n\n\tsmb_llist_enter(of_list, RW_READER);\n\tof = smb_llist_head(of_list);\n\twhile (of) {\n\t\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\t\tASSERT(of->f_tree == tree);\n\t\tif (of->f_fid == fid)\n\t\t\tbreak;\n\t\tof = smb_llist_next(of_list, of);\n\t}\n\tif (of == NULL)\n\t\tgoto out;\n\n\t/*\n\t * Only allow use of a given FID with the same UID that\n\t * was used to open it.  MS-CIFS 3.3.5.14\n\t */\n\tif (of->f_user != sr->uid_user) {\n\t\tof = NULL;\n\t\tgoto out;\n\t}\n\n\tmutex_enter(&of->f_mutex);\n\tif (of->f_state != SMB_OFILE_STATE_OPEN) {\n\t\tmutex_exit(&of->f_mutex);\n\t\tof = NULL;\n\t\tgoto out;\n\t}\n\tof->f_refcnt++;\n\tmutex_exit(&of->f_mutex);\n\nout:\n\tsmb_llist_exit(of_list);\n\treturn (of);\n}\n\n/*\n * smb_ofile_lookup_by_uniqid\n *\n * Find the open file whose uniqid matches the one specified in the request.\n */\nsmb_ofile_t *\nsmb_ofile_lookup_by_uniqid(smb_tree_t *tree, uint32_t uniqid)\n{\n\tsmb_llist_t\t*of_list;\n\tsmb_ofile_t\t*of;\n\n\tASSERT(tree->t_magic == SMB_TREE_MAGIC);\n\n\tof_list = &tree->t_ofile_list;\n\tsmb_llist_enter(of_list, RW_READER);\n\tof = smb_llist_head(of_list);\n\n\twhile (of) {\n\t\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\t\tASSERT(of->f_tree == tree);\n\n\t\tif (of->f_uniqid == uniqid) {\n\t\t\tif (smb_ofile_hold(of)) {\n\t\t\t\tsmb_llist_exit(of_list);\n\t\t\t\treturn (of);\n\t\t\t}\n\t\t}\n\n\t\tof = smb_llist_next(of_list, of);\n\t}\n\n\tsmb_llist_exit(of_list);\n\treturn (NULL);\n}\n\n/*\n * Disallow NetFileClose on certain ofiles to avoid side-effects.\n * Closing a tree root is not allowed: use NetSessionDel or NetShareDel.\n * Closing SRVSVC connections is not allowed because this NetFileClose\n * request may depend on this ofile.\n */\nboolean_t\nsmb_ofile_disallow_fclose(smb_ofile_t *of)\n{\n\tASSERT(of);\n\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\tASSERT(of->f_refcnt);\n\n\tswitch (of->f_ftype) {\n\tcase SMB_FTYPE_DISK:\n\t\tASSERT(of->f_tree);\n\t\treturn (of->f_node == of->f_tree->t_snode);\n\n\tcase SMB_FTYPE_MESG_PIPE:\n\t\tASSERT(of->f_pipe);\n\t\tif (smb_strcasecmp(of->f_pipe->p_name, \"SRVSVC\", 0) == 0)\n\t\t\treturn (B_TRUE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn (B_FALSE);\n}\n\n/*\n * smb_ofile_set_flags\n *\n * Return value:\n *\n *\tCurrent flags value\n *\n */\nvoid\nsmb_ofile_set_flags(\n    smb_ofile_t\t\t*of,\n    uint32_t\t\tflags)\n{\n\tASSERT(of);\n\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\tASSERT(of->f_refcnt);\n\n\tmutex_enter(&of->f_mutex);\n\tof->f_flags |= flags;\n\tmutex_exit(&of->f_mutex);\n}\n\n/*\n * smb_ofile_seek\n *\n * Return value:\n *\n *\t0\t\tSuccess\n *\tEINVAL\t\tUnknown mode\n *\tEOVERFLOW\toffset too big\n *\n */\nint\nsmb_ofile_seek(\n    smb_ofile_t\t\t*of,\n    ushort_t\t\tmode,\n    int32_t\t\toff,\n    uint32_t\t\t*retoff)\n{\n\tu_offset_t\tnewoff = 0;\n\tint\t\trc = 0;\n\tsmb_attr_t\tattr;\n\n\tASSERT(of);\n\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\tASSERT(of->f_refcnt);\n\n\tmutex_enter(&of->f_mutex);\n\tswitch (mode) {\n\tcase SMB_SEEK_SET:\n\t\tif (off < 0)\n\t\t\tnewoff = 0;\n\t\telse\n\t\t\tnewoff = (u_offset_t)off;\n\t\tbreak;\n\n\tcase SMB_SEEK_CUR:\n\t\tif (off < 0 && (-off) > of->f_seek_pos)\n\t\t\tnewoff = 0;\n\t\telse\n\t\t\tnewoff = of->f_seek_pos + (u_offset_t)off;\n\t\tbreak;\n\n\tcase SMB_SEEK_END:\n\t\tbzero(&attr, sizeof (smb_attr_t));\n\t\tattr.sa_mask |= SMB_AT_SIZE;\n\t\trc = smb_fsop_getattr(NULL, zone_kcred(), of->f_node, &attr);\n\t\tif (rc != 0) {\n\t\t\tmutex_exit(&of->f_mutex);\n\t\t\treturn (rc);\n\t\t}\n\t\tif (off < 0 && (-off) > attr.sa_vattr.va_size)\n\t\t\tnewoff = 0;\n\t\telse\n\t\t\tnewoff = attr.sa_vattr.va_size + (u_offset_t)off;\n\t\tbreak;\n\n\tdefault:\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (EINVAL);\n\t}\n\n\t/*\n\t * See comments at the beginning of smb_seek.c.\n\t * If the offset is greater than UINT_MAX, we will return an error.\n\t */\n\n\tif (newoff > UINT_MAX) {\n\t\trc = EOVERFLOW;\n\t} else {\n\t\tof->f_seek_pos = newoff;\n\t\t*retoff = (uint32_t)newoff;\n\t}\n\tmutex_exit(&of->f_mutex);\n\treturn (rc);\n}\n\n/*\n * smb_ofile_is_open\n */\nboolean_t\nsmb_ofile_is_open(smb_ofile_t *of)\n{\n\tboolean_t\trc;\n\n\tSMB_OFILE_VALID(of);\n\n\tmutex_enter(&of->f_mutex);\n\trc = smb_ofile_is_open_locked(of);\n\tmutex_exit(&of->f_mutex);\n\treturn (rc);\n}\n\n/* *************************** Static Functions ***************************** */\n\n/*\n * Determine whether or not an ofile is open.\n * This function must be called with the mutex held.\n */\nstatic boolean_t\nsmb_ofile_is_open_locked(smb_ofile_t *of)\n{\n\tswitch (of->f_state) {\n\tcase SMB_OFILE_STATE_OPEN:\n\t\treturn (B_TRUE);\n\n\tcase SMB_OFILE_STATE_CLOSING:\n\tcase SMB_OFILE_STATE_CLOSED:\n\t\treturn (B_FALSE);\n\n\tdefault:\n\t\tASSERT(0);\n\t\treturn (B_FALSE);\n\t}\n}\n\n/*\n * This function closes the file passed in (if appropriate) and returns the\n * next open file in the list of open files of the tree of the open file passed\n * in. It requires that the list of open files of the tree be entered in\n * RW_READER mode before being called.\n */\nstatic smb_ofile_t *\nsmb_ofile_close_and_next(smb_ofile_t *of)\n{\n\tsmb_ofile_t\t*next_of;\n\tsmb_tree_t\t*tree;\n\n\tASSERT(of);\n\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\n\tmutex_enter(&of->f_mutex);\n\tswitch (of->f_state) {\n\tcase SMB_OFILE_STATE_OPEN:\n\t\t/* The file is still open. */\n\t\tof->f_refcnt++;\n\t\tASSERT(of->f_refcnt);\n\t\ttree = of->f_tree;\n\t\tmutex_exit(&of->f_mutex);\n\t\tsmb_llist_exit(&of->f_tree->t_ofile_list);\n\t\tsmb_ofile_close(of, 0);\n\t\tsmb_ofile_release(of);\n\t\tsmb_llist_enter(&tree->t_ofile_list, RW_READER);\n\t\tnext_of = smb_llist_head(&tree->t_ofile_list);\n\t\tbreak;\n\tcase SMB_OFILE_STATE_CLOSING:\n\tcase SMB_OFILE_STATE_CLOSED:\n\t\t/*\n\t\t * The ofile exists but is closed or\n\t\t * in the process being closed.\n\t\t */\n\t\tmutex_exit(&of->f_mutex);\n\t\tnext_of = smb_llist_next(&of->f_tree->t_ofile_list, of);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tmutex_exit(&of->f_mutex);\n\t\tnext_of = smb_llist_next(&of->f_tree->t_ofile_list, of);\n\t\tbreak;\n\t}\n\treturn (next_of);\n}\n\n/*\n * Delete an ofile.\n *\n * Remove the ofile from the tree list before freeing resources\n * associated with the ofile.\n */\nvoid\nsmb_ofile_delete(void *arg)\n{\n\tsmb_tree_t\t*tree;\n\tsmb_ofile_t\t*of = (smb_ofile_t *)arg;\n\n\tSMB_OFILE_VALID(of);\n\tASSERT(of->f_refcnt == 0);\n\tASSERT(of->f_state == SMB_OFILE_STATE_CLOSED);\n\tASSERT(!SMB_OFILE_OPLOCK_GRANTED(of));\n\n\ttree = of->f_tree;\n\tsmb_llist_enter(&tree->t_ofile_list, RW_WRITER);\n\tsmb_llist_remove(&tree->t_ofile_list, of);\n\tsmb_idpool_free(&tree->t_fid_pool, of->f_fid);\n\tatomic_dec_32(&tree->t_session->s_file_cnt);\n\tsmb_llist_exit(&tree->t_ofile_list);\n\n\tmutex_enter(&of->f_mutex);\n\tmutex_exit(&of->f_mutex);\n\n\tswitch (of->f_ftype) {\n\tcase SMB_FTYPE_BYTE_PIPE:\n\tcase SMB_FTYPE_MESG_PIPE:\n\t\tsmb_opipe_dealloc(of->f_pipe);\n\t\tof->f_pipe = NULL;\n\t\tbreak;\n\tcase SMB_FTYPE_DISK:\n\t\tif (of->f_odir != NULL)\n\t\t\tsmb_odir_release(of->f_odir);\n\t\tsmb_node_rem_ofile(of->f_node, of);\n\t\tsmb_node_release(of->f_node);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(!\"f_ftype\");\n\t\tbreak;\n\t}\n\n\tof->f_magic = (uint32_t)~SMB_OFILE_MAGIC;\n\tmutex_destroy(&of->f_mutex);\n\tcrfree(of->f_cr);\n\tsmb_user_release(of->f_user);\n\tkmem_cache_free(smb_cache_ofile, of);\n}\n\n/*\n * smb_ofile_access\n *\n * This function will check to see if the access requested is granted.\n * Returns NT status codes.\n */\nuint32_t\nsmb_ofile_access(smb_ofile_t *of, cred_t *cr, uint32_t access)\n{\n\n\tif ((of == NULL) || (cr == zone_kcred()))\n\t\treturn (NT_STATUS_SUCCESS);\n\n\t/*\n\t * If the request is for something\n\t * I don't grant it is an error\n\t */\n\tif (~(of->f_granted_access) & access) {\n\t\tif (!(of->f_granted_access & ACCESS_SYSTEM_SECURITY) &&\n\t\t    (access & ACCESS_SYSTEM_SECURITY)) {\n\t\t\treturn (NT_STATUS_PRIVILEGE_NOT_HELD);\n\t\t}\n\t\treturn (NT_STATUS_ACCESS_DENIED);\n\t}\n\n\treturn (NT_STATUS_SUCCESS);\n}\n\n/*\n * smb_ofile_share_check\n *\n * Check if ofile was opened with share access NONE (0).\n * Returns: B_TRUE  - share access non-zero\n *          B_FALSE - share access NONE\n */\nboolean_t\nsmb_ofile_share_check(smb_ofile_t *of)\n{\n\treturn (!SMB_DENY_ALL(of->f_share_access));\n}\n\n/*\n * check file sharing rules for current open request\n * against existing open instances of the same file\n *\n * Returns NT_STATUS_SHARING_VIOLATION if there is any\n * sharing conflict, otherwise returns NT_STATUS_SUCCESS.\n */\nuint32_t\nsmb_ofile_open_check(smb_ofile_t *of, uint32_t desired_access,\n    uint32_t share_access)\n{\n\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\n\tmutex_enter(&of->f_mutex);\n\n\tif (of->f_state != SMB_OFILE_STATE_OPEN) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_INVALID_HANDLE);\n\t}\n\n\t/* if it's just meta data */\n\tif ((of->f_granted_access & FILE_DATA_ALL) == 0) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_SUCCESS);\n\t}\n\n\t/*\n\t * Check requested share access against the\n\t * open granted (desired) access\n\t */\n\tif (SMB_DENY_DELETE(share_access) && (of->f_granted_access & DELETE)) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_SHARING_VIOLATION);\n\t}\n\n\tif (SMB_DENY_READ(share_access) &&\n\t    (of->f_granted_access & (FILE_READ_DATA | FILE_EXECUTE))) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_SHARING_VIOLATION);\n\t}\n\n\tif (SMB_DENY_WRITE(share_access) &&\n\t    (of->f_granted_access & (FILE_WRITE_DATA | FILE_APPEND_DATA))) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_SHARING_VIOLATION);\n\t}\n\n\t/* check requested desired access against the open share access */\n\tif (SMB_DENY_DELETE(of->f_share_access) && (desired_access & DELETE)) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_SHARING_VIOLATION);\n\t}\n\n\tif (SMB_DENY_READ(of->f_share_access) &&\n\t    (desired_access & (FILE_READ_DATA | FILE_EXECUTE))) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_SHARING_VIOLATION);\n\t}\n\n\tif (SMB_DENY_WRITE(of->f_share_access) &&\n\t    (desired_access & (FILE_WRITE_DATA | FILE_APPEND_DATA))) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_SHARING_VIOLATION);\n\t}\n\n\tmutex_exit(&of->f_mutex);\n\treturn (NT_STATUS_SUCCESS);\n}\n\n/*\n * smb_ofile_rename_check\n *\n * An open file can be renamed if\n *\n *  1. isn't opened for data writing or deleting\n *\n *  2. Opened with \"Deny Delete\" share mode\n *         But not opened for data reading or executing\n *         (opened for accessing meta data)\n */\n\nuint32_t\nsmb_ofile_rename_check(smb_ofile_t *of)\n{\n\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\n\tmutex_enter(&of->f_mutex);\n\n\tif (of->f_state != SMB_OFILE_STATE_OPEN) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_INVALID_HANDLE);\n\t}\n\n\tif (of->f_granted_access &\n\t    (FILE_WRITE_DATA | FILE_APPEND_DATA | DELETE)) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_SHARING_VIOLATION);\n\t}\n\n\tif ((of->f_share_access & FILE_SHARE_DELETE) == 0) {\n\t\tif (of->f_granted_access &\n\t\t    (FILE_READ_DATA | FILE_EXECUTE)) {\n\t\t\tmutex_exit(&of->f_mutex);\n\t\t\treturn (NT_STATUS_SHARING_VIOLATION);\n\t\t}\n\t}\n\n\tmutex_exit(&of->f_mutex);\n\treturn (NT_STATUS_SUCCESS);\n}\n\n/*\n * smb_ofile_delete_check\n *\n * An open file can be deleted only if opened for\n * accessing meta data. Share modes aren't important\n * in this case.\n *\n * NOTE: there is another mechanism for deleting an\n * open file that NT clients usually use.\n * That's setting \"Delete on close\" flag for an open\n * file.  In this way the file will be deleted after\n * last close. This flag can be set by SmbTrans2SetFileInfo\n * with FILE_DISPOSITION_INFO information level.\n * For setting this flag, the file should be opened by\n * DELETE access in the FID that is passed in the Trans2\n * request.\n */\n\nuint32_t\nsmb_ofile_delete_check(smb_ofile_t *of)\n{\n\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\n\tmutex_enter(&of->f_mutex);\n\n\tif (of->f_state != SMB_OFILE_STATE_OPEN) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_INVALID_HANDLE);\n\t}\n\n\tif (of->f_granted_access &\n\t    (FILE_READ_DATA | FILE_WRITE_DATA |\n\t    FILE_APPEND_DATA | FILE_EXECUTE | DELETE)) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_SHARING_VIOLATION);\n\t}\n\n\tmutex_exit(&of->f_mutex);\n\treturn (NT_STATUS_SUCCESS);\n}\n\ncred_t *\nsmb_ofile_getcred(smb_ofile_t *of)\n{\n\treturn (of->f_cr);\n}\n\n/*\n * smb_ofile_set_delete_on_close\n *\n * Set the DeleteOnClose flag on the smb file. When the file is closed,\n * the flag will be transferred to the smb node, which will commit the\n * delete operation and inhibit subsequent open requests.\n *\n * When DeleteOnClose is set on an smb_node, the common open code will\n * reject subsequent open requests for the file. Observation of Windows\n * 2000 indicates that subsequent opens should be allowed (assuming\n * there would be no sharing violation) until the file is closed using\n * the fid on which the DeleteOnClose was requested.\n */\nvoid\nsmb_ofile_set_delete_on_close(smb_ofile_t *of)\n{\n\tmutex_enter(&of->f_mutex);\n\tof->f_flags |= SMB_OFLAGS_SET_DELETE_ON_CLOSE;\n\tmutex_exit(&of->f_mutex);\n}\n\n/*\n * Encode open file information into a buffer; needed in user space to\n * support RPC requests.\n */\nstatic int\nsmb_ofile_netinfo_encode(smb_ofile_t *of, uint8_t *buf, size_t buflen,\n    uint32_t *nbytes)\n{\n\tsmb_netfileinfo_t\tfi;\n\tint\t\t\trc;\n\n\trc = smb_ofile_netinfo_init(of, &fi);\n\tif (rc == 0) {\n\t\trc = smb_netfileinfo_encode(&fi, buf, buflen, nbytes);\n\t\tsmb_ofile_netinfo_fini(&fi);\n\t}\n\n\treturn (rc);\n}\n\nstatic int\nsmb_ofile_netinfo_init(smb_ofile_t *of, smb_netfileinfo_t *fi)\n{\n\tsmb_user_t\t*user;\n\tsmb_tree_t\t*tree;\n\tsmb_node_t\t*node;\n\tchar\t\t*path;\n\tchar\t\t*buf;\n\tint\t\trc;\n\n\tASSERT(of);\n\tuser = of->f_user;\n\ttree = of->f_tree;\n\tASSERT(user);\n\tASSERT(tree);\n\n\tbuf = kmem_zalloc(MAXPATHLEN, KM_SLEEP);\n\n\tswitch (of->f_ftype) {\n\tcase SMB_FTYPE_DISK:\n\t\tnode = of->f_node;\n\t\tASSERT(node);\n\n\t\tfi->fi_permissions = of->f_granted_access;\n\t\tfi->fi_numlocks = smb_lock_get_lock_count(node, of);\n\n\t\tpath = kmem_zalloc(MAXPATHLEN, KM_SLEEP);\n\n\t\tif (node != tree->t_snode) {\n\t\t\trc = smb_node_getshrpath(node, tree, path, MAXPATHLEN);\n\t\t\tif (rc != 0)\n\t\t\t\t(void) strlcpy(path, node->od_name, MAXPATHLEN);\n\t\t}\n\n\t\t(void) snprintf(buf, MAXPATHLEN, \"%s:%s\", tree->t_sharename,\n\t\t    path);\n\t\tkmem_free(path, MAXPATHLEN);\n\t\tbreak;\n\n\tcase SMB_FTYPE_MESG_PIPE:\n\t\tASSERT(of->f_pipe);\n\n\t\tfi->fi_permissions = FILE_READ_DATA | FILE_WRITE_DATA |\n\t\t    FILE_EXECUTE;\n\t\tfi->fi_numlocks = 0;\n\t\t(void) snprintf(buf, MAXPATHLEN, \"\\\\PIPE\\\\%s\",\n\t\t    of->f_pipe->p_name);\n\t\tbreak;\n\n\tdefault:\n\t\tkmem_free(buf, MAXPATHLEN);\n\t\treturn (-1);\n\t}\n\n\tfi->fi_fid = of->f_fid;\n\tfi->fi_uniqid = of->f_uniqid;\n\tfi->fi_pathlen = strlen(buf) + 1;\n\tfi->fi_path = smb_mem_strdup(buf);\n\tkmem_free(buf, MAXPATHLEN);\n\n\tfi->fi_namelen = user->u_domain_len + user->u_name_len + 2;\n\tfi->fi_username = kmem_alloc(fi->fi_namelen, KM_SLEEP);\n\t(void) snprintf(fi->fi_username, fi->fi_namelen, \"%s\\\\%s\",\n\t    user->u_domain, user->u_name);\n\treturn (0);\n}\n\nstatic void\nsmb_ofile_netinfo_fini(smb_netfileinfo_t *fi)\n{\n\tif (fi == NULL)\n\t\treturn;\n\n\tif (fi->fi_path)\n\t\tsmb_mem_free(fi->fi_path);\n\tif (fi->fi_username)\n\t\tkmem_free(fi->fi_username, fi->fi_namelen);\n\n\tbzero(fi, sizeof (smb_netfileinfo_t));\n}\n\n/*\n * A query of user and group quotas may span multiple requests.\n * f_quota_resume is used to determine where the query should\n * be resumed, in a subsequent request. f_quota_resume contains\n * the SID of the last quota entry returned to the client.\n */\nvoid\nsmb_ofile_set_quota_resume(smb_ofile_t *ofile, char *resume)\n{\n\tASSERT(ofile);\n\tmutex_enter(&ofile->f_mutex);\n\tif (resume == NULL)\n\t\tbzero(ofile->f_quota_resume, SMB_SID_STRSZ);\n\telse\n\t\t(void) strlcpy(ofile->f_quota_resume, resume, SMB_SID_STRSZ);\n\tmutex_exit(&ofile->f_mutex);\n}\n\nvoid\nsmb_ofile_get_quota_resume(smb_ofile_t *ofile, char *buf, int bufsize)\n{\n\tASSERT(ofile);\n\tmutex_enter(&ofile->f_mutex);\n\t(void) strlcpy(buf, ofile->f_quota_resume, bufsize);\n\tmutex_exit(&ofile->f_mutex);\n}\n", "/*\n * CDDL HEADER START\n *\n * The contents of this file are subject to the terms of the\n * Common Development and Distribution License (the \"License\").\n * You may not use this file except in compliance with the License.\n *\n * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE\n * or http://www.opensolaris.org/os/licensing.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL HEADER in each\n * file and include the License file at usr/src/OPENSOLARIS.LICENSE.\n * If applicable, add the following below this CDDL HEADER, with the\n * fields enclosed by brackets \"[]\" replaced with your own identifying\n * information: Portions Copyright [yyyy] [name of copyright owner]\n *\n * CDDL HEADER END\n */\n\n/*\n * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.\n * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.\n */\n\n/*\n * Function prototypes for the SMB module.\n */\n\n#ifndef _SMB_KPROTO_H_\n#define\t_SMB_KPROTO_H_\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/systm.h>\n#include <sys/debug.h>\n#include <sys/kmem.h>\n#include <sys/socket.h>\n#include <sys/ksocket.h>\n#include <sys/cred.h>\n#include <sys/nbmlock.h>\n#include <sys/sunddi.h>\n#include <sys/atomic.h>\n#include <smbsrv/smb.h>\n#include <smbsrv/string.h>\n#include <smbsrv/smb_vops.h>\n#include <smbsrv/smb_xdr.h>\n#include <smbsrv/smb_token.h>\n#include <smbsrv/smb_ktypes.h>\n#include <smbsrv/smb_ioctl.h>\n\n/*\n * DTrace SDT probes have different signatures in userland than they do in\n * kernel.  If we're compiling for user mode (libfksmbsrv) define them as\n * either no-op (for the SMB dtrace provider) or libfksmbsrv functions for\n * the other SDT probe sites.\n */\n#ifndef\t_KERNEL\n\nextern void smb_dtrace1(const char *f, const char *n,\n\t\t\tconst char *t1, long v1);\nextern void smb_dtrace2(const char *f, const char *n,\n\t\t\tconst char *t1, long v1,\n\t\t\tconst char *t2, long v2);\nextern void smb_dtrace3(const char *f, const char *n,\n\t\t\tconst char *t1, long v1,\n\t\t\tconst char *t2, long v2,\n\t\t\tconst char *t3, long v3);\n\n/*\n * These are for the SMB dtrace proivder, which for a user-mode build\n * are largely redundant with the fbt probes so make these no-ops.\n */\n#undef\tDTRACE_SMB_1\n#define\tDTRACE_SMB_1(n, a, b)\t\t\t((void)b)\n#undef\tDTRACE_SMB_2\n#define\tDTRACE_SMB_2(n, a, b, c, d)\t\t((void)b, (void)d)\n\n/*\n * These are for the other (specialized) dtrace SDT probes sprinkled\n * through the smbsrv code.  In libfksmbsrv map these to functions.\n */\n\n#undef\tDTRACE_PROBE1\n#define\tDTRACE_PROBE1(n, a, b) \\\n\tsmb_dtrace1(__func__, #n, #a, (long)b)\n\n#undef\tDTRACE_PROBE2\n#define\tDTRACE_PROBE2(n, a, b, c, d) \\\n\tsmb_dtrace2(__func__, #n, #a, (long)b, #c, (long)d)\n\n#undef\tDTRACE_PROBE3\n#define\tDTRACE_PROBE3(n, a, b, c, d, e, f) \\\n\tsmb_dtrace3(__func__, #n, #a, (long)b, #c, (long)d, #e, (long)f)\n\n#endif\t/* _KERNEL */\n\nextern\tint smb_maxbufsize;\nextern\tint smb_flush_required;\nextern\tint smb_dirsymlink_enable;\nextern\tint smb_oplock_levelII;\nextern\tint smb_oplock_timeout;\nextern\tint smb_oplock_min_timeout;\nextern\tint smb_shortnames;\nextern\tint smb_sign_debug;\nextern\tint smb_raw_mode;\nextern\tuint_t smb_audit_flags;\nextern\tint smb_ssetup_threshold;\nextern\tint smb_tcon_threshold;\nextern\tint smb_opipe_threshold;\nextern\tint smb_ssetup_timeout;\nextern\tint smb_tcon_timeout;\nextern\tint smb_opipe_timeout;\nextern const uint32_t smb_vop_dosattr_settable;\n\n/* Thread priorities - see smb_init.c */\nextern\tint smbsrv_base_pri;\nextern\tint smbsrv_listen_pri;\nextern\tint smbsrv_receive_pri;\nextern\tint smbsrv_worker_pri;\nextern\tint smbsrv_notify_pri;\nextern\tint smbsrv_timer_pri;\n\nextern\tkmem_cache_t\t\t*smb_cache_request;\nextern\tkmem_cache_t\t\t*smb_cache_session;\nextern\tkmem_cache_t\t\t*smb_cache_user;\nextern\tkmem_cache_t\t\t*smb_cache_tree;\nextern\tkmem_cache_t\t\t*smb_cache_ofile;\nextern\tkmem_cache_t\t\t*smb_cache_odir;\nextern\tkmem_cache_t\t\t*smb_cache_opipe;\nextern\tkmem_cache_t\t\t*smb_cache_event;\n\nextern\tkmem_cache_t\t\t*smb_kshare_cache_vfs;\n\ntime_t smb_get_boottime(void);\nint smb_server_lookup(smb_server_t **);\nvoid smb_server_release(smb_server_t *);\n\n/*\n * SMB request handers called from the dispatcher.  Each SMB request\n * is handled in three phases: pre, com (command) and post.\n *\n * The pre-handler is primarily to set things up for the DTrace start\n * probe.  Typically, the SMB request is unmarshalled so that request\n * specific context can be traced.  This is also a useful place to\n * allocate memory that will be used throughout the processing of the\n * command.\n *\n * The com-handler performs the requested operation: request validation,\n * bulk (write) incoming data decode, implementation of the appropriate\n * algorithm and transmission of a response (as appropriate).\n *\n * The post-handler is always called, regardless of success or failure\n * of the pre or com functions, to trigger the DTrace done probe and\n * deallocate memory allocated in the pre-handler.\n */\n#define\tSMB_SDT_OPS(NAME)\t\\\n\tsmb_pre_##NAME,\t\t\\\n\tsmb_com_##NAME,\t\t\\\n\tsmb_post_##NAME\n\n#define\tSMB_COM_DECL(NAME)\t\t\t\t\\\n\tsmb_sdrc_t smb_pre_##NAME(smb_request_t *);\t\\\n\tsmb_sdrc_t smb_com_##NAME(smb_request_t *);\t\\\n\tvoid smb_post_##NAME(smb_request_t *)\n\nSMB_COM_DECL(check_directory);\nSMB_COM_DECL(close);\nSMB_COM_DECL(close_and_tree_disconnect);\nSMB_COM_DECL(close_print_file);\nSMB_COM_DECL(create);\nSMB_COM_DECL(create_directory);\nSMB_COM_DECL(create_new);\nSMB_COM_DECL(create_temporary);\nSMB_COM_DECL(delete);\nSMB_COM_DECL(delete_directory);\nSMB_COM_DECL(echo);\nSMB_COM_DECL(find);\nSMB_COM_DECL(find_close);\nSMB_COM_DECL(find_close2);\nSMB_COM_DECL(find_unique);\nSMB_COM_DECL(flush);\nSMB_COM_DECL(get_print_queue);\nSMB_COM_DECL(invalid);\nSMB_COM_DECL(ioctl);\nSMB_COM_DECL(lock_and_read);\nSMB_COM_DECL(lock_byte_range);\nSMB_COM_DECL(locking_andx);\nSMB_COM_DECL(logoff_andx);\nSMB_COM_DECL(negotiate);\nSMB_COM_DECL(nt_cancel);\nSMB_COM_DECL(nt_create_andx);\nSMB_COM_DECL(nt_rename);\nSMB_COM_DECL(nt_transact);\nSMB_COM_DECL(nt_transact_secondary);\nSMB_COM_DECL(open);\nSMB_COM_DECL(open_andx);\nSMB_COM_DECL(open_print_file);\nSMB_COM_DECL(process_exit);\nSMB_COM_DECL(query_information);\nSMB_COM_DECL(query_information2);\nSMB_COM_DECL(query_information_disk);\nSMB_COM_DECL(read);\nSMB_COM_DECL(read_andx);\nSMB_COM_DECL(read_raw);\nSMB_COM_DECL(rename);\nSMB_COM_DECL(search);\nSMB_COM_DECL(seek);\nSMB_COM_DECL(session_setup_andx);\nSMB_COM_DECL(set_information);\nSMB_COM_DECL(set_information2);\nSMB_COM_DECL(transaction);\nSMB_COM_DECL(transaction2);\nSMB_COM_DECL(transaction2_secondary);\nSMB_COM_DECL(transaction_secondary);\nSMB_COM_DECL(tree_connect);\nSMB_COM_DECL(tree_connect_andx);\nSMB_COM_DECL(tree_disconnect);\nSMB_COM_DECL(unlock_byte_range);\nSMB_COM_DECL(write);\nSMB_COM_DECL(write_and_close);\nSMB_COM_DECL(write_and_unlock);\nSMB_COM_DECL(write_andx);\nSMB_COM_DECL(write_print_file);\nSMB_COM_DECL(write_raw);\n\n#define\tSMB_NT_TRANSACT_DECL(NAME)\t\t\t\t\\\n\tsmb_sdrc_t smb_pre_##NAME(smb_request_t *, smb_xa_t *);\t\\\n\tsmb_sdrc_t smb_##NAME(smb_request_t *, smb_xa_t *);\t\\\n\tvoid smb_post_##NAME(smb_request_t *, smb_xa_t *)\n\nSMB_NT_TRANSACT_DECL(nt_transact_create);\n\nsmb_sdrc_t smb_nt_transact_notify_change(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_nt_transact_query_security_info(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_nt_transact_set_security_info(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_nt_transact_ioctl(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_nt_transact_rename(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_nt_transact_query_quota(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_nt_transact_set_quota(smb_request_t *, smb_xa_t *);\n\nsmb_sdrc_t smb_com_trans2_open2(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_com_trans2_create_directory(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_com_trans2_find_first2(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_com_trans2_find_next2(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_com_trans2_query_fs_information(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_com_trans2_set_fs_information(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_com_trans2_query_path_information(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_com_trans2_query_file_information(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_com_trans2_set_path_information(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_com_trans2_set_file_information(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_com_trans2_get_dfs_referral(smb_request_t *, smb_xa_t *);\n\nuint32_t smb_query_stream_info(smb_request_t *, mbuf_chain_t *,\n    smb_queryinfo_t *);\nint smb_fssize(smb_request_t *, smb_fssize_t *);\n\n/* smb_quota.c */\nuint32_t smb_quota_query_user_quota(smb_request_t *, uid_t, smb_quota_t *);\nint smb_quota_query(smb_server_t *, smb_quota_query_t *,\n    smb_quota_response_t *);\nint smb_quota_set(smb_server_t *, smb_quota_set_t *, uint32_t *);\nuint32_t smb_quota_init_sids(mbuf_chain_t *, smb_quota_query_t *,\n    smb_ofile_t *);\nuint32_t smb_quota_decode_sids(mbuf_chain_t *, list_t *);\nvoid smb_quota_free_sids(smb_quota_query_t *);\nvoid smb_quota_max_quota(mbuf_chain_t *, smb_quota_query_t *);\nuint32_t smb_quota_decode_quotas(mbuf_chain_t *, list_t *);\nuint32_t smb_quota_encode_quotas(mbuf_chain_t *, smb_quota_query_t *,\n    smb_quota_response_t *, smb_ofile_t *);\nvoid smb_quota_free_quotas(list_t *);\n\nvoid smb_query_shortname(smb_node_t *, smb_queryinfo_t *);\n\nuint32_t smb_dfs_get_referrals(smb_request_t *, smb_fsctl_t *);\n\nint smb1_newrq_negotiate(smb_request_t *);\nsmb_sdrc_t smb1_negotiate_smb2(smb_request_t *sr);\n\nuint32_t smb_set_basic_info(smb_request_t *, smb_setinfo_t *);\nuint32_t smb_set_eof_info(smb_request_t *, smb_setinfo_t *);\nuint32_t smb_set_alloc_info(smb_request_t *, smb_setinfo_t *);\nuint32_t smb_set_disposition_info(smb_request_t *, smb_setinfo_t *);\n\nuint32_t smb_setinfo_rename(smb_request_t *, smb_node_t *, char *, int);\nuint32_t smb_common_rename(smb_request_t *, smb_fqi_t *, smb_fqi_t *);\n\nuint32_t smb_setinfo_link(smb_request_t *, smb_node_t *, char *, int);\nuint32_t smb_make_link(smb_request_t *, smb_fqi_t *, smb_fqi_t *);\n\n\n/*\n * Logging functions\n */\nvoid smb_log_flush(void);\nvoid smb_correct_keep_alive_values(uint32_t new_keep_alive);\nvoid smb_close_all_connections(void);\n\nint smb_net_id(uint32_t);\n\n/*\n * oplock functions - node operations\n */\nvoid smb_oplock_acquire(smb_request_t *sr, smb_node_t *, smb_ofile_t *);\nvoid smb_oplock_release(smb_node_t *, smb_ofile_t *);\nint smb_oplock_break(smb_request_t *, smb_node_t *, uint32_t);\nvoid smb_oplock_break_levelII(smb_node_t *);\nvoid smb_oplock_ack(smb_node_t *, smb_ofile_t *, uint8_t);\nvoid smb_oplock_broadcast(smb_node_t *);\n\nvoid smb1_oplock_break_notification(smb_request_t *, uint8_t);\nvoid smb2_oplock_break_notification(smb_request_t *, uint8_t);\n\n/*\n * range lock functions - node operations\n */\nuint32_t smb_lock_get_lock_count(smb_node_t *, smb_ofile_t *);\nuint32_t smb_unlock_range(smb_request_t *, smb_node_t *,\n    uint64_t, uint64_t);\nuint32_t smb_lock_range(smb_request_t *, uint64_t, uint64_t, uint32_t,\n    uint32_t locktype);\nvoid smb_lock_range_error(smb_request_t *, uint32_t);\nDWORD smb_nbl_conflict(smb_node_t *, uint64_t, uint64_t, nbl_op_t);\n\nvoid smb_mangle(const char *, ino64_t, char *, size_t);\nint smb_unmangle(smb_node_t *, char *, char *, int, uint32_t);\nboolean_t smb_needs_mangled(const char *);\nboolean_t smb_maybe_mangled(char *);\nboolean_t smb_is_reserved_dos_name(const char *);\nboolean_t smb_is_invalid_filename(const char *);\n\nvoid smbsr_cleanup(smb_request_t *sr);\n\nint smbsr_connect_tree(smb_request_t *);\n\nint smb_common_create_directory(smb_request_t *);\n\nvoid\tsmb_convert_wildcards(char *);\nboolean_t smb_contains_wildcards(const char *);\nint\tsmb_ascii_or_unicode_strlen(smb_request_t *, char *);\nint\tsmb_ascii_or_unicode_strlen_null(smb_request_t *, char *);\nint\tsmb_ascii_or_unicode_null_len(smb_request_t *);\n\nint\tsmb_search(smb_request_t *);\n\nuint32_t smb_common_create(smb_request_t *);\nuint32_t smb_common_open(smb_request_t *);\nint smb_common_write(smb_request_t *, smb_rw_param_t *);\n\nvoid smb_pathname_init(smb_request_t *, smb_pathname_t *, char *);\nboolean_t smb_pathname_validate(smb_request_t *, smb_pathname_t *);\nboolean_t smb_validate_dirname(smb_request_t *, smb_pathname_t *);\nboolean_t smb_validate_object_name(smb_request_t *, smb_pathname_t *);\nboolean_t smb_validate_stream_name(smb_request_t *, smb_pathname_t *);\nboolean_t smb_is_stream_name(char *);\nvoid smb_stream_parse_name(char *, char *, char *);\n\n\nuint32_t smb_omode_to_amask(uint32_t desired_access);\n\nvoid\tsshow_distribution_info(char *);\n\nuint32_t smb2sr_go_async(smb_request_t *sr,\n\tsmb_sdrc_t (*async_func)(smb_request_t *));\n\nvoid\tsmb_dispatch_stats_init(smb_server_t *);\nvoid\tsmb_dispatch_stats_fini(smb_server_t *);\nvoid\tsmb_dispatch_stats_update(smb_server_t *,\n\t\tsmb_kstat_req_t *, int, int);\n\nint\tsmb1sr_newrq(smb_request_t *);\nvoid\tsmb1sr_work(smb_request_t *);\n\nint\tsmbsr_encode_empty_result(smb_request_t *);\nvoid\tsmbsr_lookup_file(smb_request_t *);\nvoid\tsmbsr_release_file(smb_request_t *);\n\nint\tsmbsr_decode_vwv(smb_request_t *sr, const char *, ...);\nint\tsmbsr_decode_data(smb_request_t *sr, const char *, ...);\nboolean_t smbsr_decode_data_avail(smb_request_t *);\nint\tsmbsr_encode_result(smb_request_t *, int, int, const char *, ...);\nsmb_xa_t *smbsr_lookup_xa(smb_request_t *sr);\nvoid\tsmbsr_send_reply(smb_request_t *);\n\nuint32_t smb_errno2status(int);\nuint16_t smb_status2doserr(uint32_t);\nvoid\tsmbsr_map_errno(int, smb_error_t *);\nvoid\tsmbsr_set_error(smb_request_t *, smb_error_t *);\nvoid\tsmbsr_errno(smb_request_t *, int);\nvoid\tsmbsr_status(smb_request_t *, DWORD, uint16_t, uint16_t);\n#define\tsmbsr_error(SR, ST, CL, CO) \\\n\tsmbsr_status(SR, ST, CL, CO)\n#define\tsmbsr_warn(SR, ST, CL, CO) \\\n\tsmbsr_status(SR, ST, CL, CO)\nvoid\tsmbsr_status_smb2(smb_request_t *, DWORD);\n\nint\tclock_get_milli_uptime(void);\n\nint\tsmb_mbc_vencodef(mbuf_chain_t *, const char *, va_list);\nint\tsmb_mbc_vdecodef(mbuf_chain_t *, const char *, va_list);\nint\tsmb_mbc_decodef(mbuf_chain_t *, const char *, ...);\nint\tsmb_mbc_encodef(mbuf_chain_t *, const char *, ...);\nint\tsmb_mbc_peek(mbuf_chain_t *, int, const char *, ...);\nint\tsmb_mbc_poke(mbuf_chain_t *, int, const char *, ...);\nint\tsmb_mbc_put_mem(mbuf_chain_t *, void *, int);\nint\tsmb_mbc_copy(mbuf_chain_t *, const mbuf_chain_t *, int, int);\n\nvoid\tsmbsr_encode_header(smb_request_t *sr, int wct,\n\t\t    int bcc, const char *fmt, ...);\n\nint smb_lock_range_access(smb_request_t *, smb_node_t *,\n    uint64_t, uint64_t, boolean_t);\n\nvoid smb_encode_sd(mbuf_chain_t *, smb_sd_t *, uint32_t);\nvoid smb_encode_sid(mbuf_chain_t *, smb_sid_t *);\nsmb_sid_t *smb_decode_sid(mbuf_chain_t *, uint32_t);\nuint32_t smb_decode_sd(mbuf_chain_t *, smb_sd_t *);\n\nuint32_t smb_pad_align(uint32_t, uint32_t);\n\n/*\n * Socket functions\n */\nksocket_t smb_socreate(int domain, int type, int protocol);\nvoid smb_soshutdown(ksocket_t so);\nvoid smb_sodestroy(ksocket_t so);\nint smb_sorecv(ksocket_t so, void *msg, size_t len);\nvoid smb_net_txl_constructor(smb_txlst_t *);\nvoid smb_net_txl_destructor(smb_txlst_t *);\nint smb_net_send_uio(smb_session_t *, struct uio *);\n\n/*\n * SMB RPC interface\n */\nvoid smb_opipe_dealloc(smb_opipe_t *);\nint smb_opipe_open(smb_request_t *, uint32_t);\nvoid smb_opipe_close(smb_ofile_t *);\nint smb_opipe_read(smb_request_t *, struct uio *);\nint smb_opipe_write(smb_request_t *, struct uio *);\nint smb_opipe_getattr(smb_ofile_t *, smb_attr_t *);\nint smb_opipe_getname(smb_ofile_t *, char *, size_t);\nuint32_t smb_opipe_fsctl(smb_request_t *, smb_fsctl_t *);\n\nvoid smb_kdoor_init(smb_server_t *);\nvoid smb_kdoor_fini(smb_server_t *);\nint smb_kdoor_open(smb_server_t *, int);\nvoid smb_kdoor_close(smb_server_t *);\nint smb_kdoor_upcall(smb_server_t *, uint32_t,\n\tvoid *, xdrproc_t, void *, xdrproc_t);\nvoid fksmb_kdoor_open(smb_server_t *, void *);\n\n/*\n * SMB server functions (file smb_server.c)\n */\nint smb_server_get_count(void);\nint smb_server_g_init(void);\nvoid smb_server_g_fini(void);\nint smb_server_create(void);\nint smb_server_delete(void);\nint smb_server_configure(smb_ioc_cfg_t *);\nint smb_server_start(smb_ioc_start_t *);\nint smb_server_stop(void);\nboolean_t smb_server_is_stopping(smb_server_t *);\nvoid smb_server_cancel_event(smb_server_t *, uint32_t);\nint smb_server_notify_event(smb_ioc_event_t *);\nuint32_t smb_server_get_session_count(smb_server_t *);\nint smb_server_set_gmtoff(smb_ioc_gmt_t *);\nint smb_server_numopen(smb_ioc_opennum_t *);\nint smb_server_enum(smb_ioc_svcenum_t *);\nint smb_server_session_close(smb_ioc_session_t *);\nint smb_server_file_close(smb_ioc_fileid_t *);\nint smb_server_sharevp(smb_server_t *, const char *, vnode_t **);\nint smb_server_unshare(const char *);\n\nvoid smb_server_get_cfg(smb_server_t *, smb_kmod_cfg_t *);\n\nint smb_server_spooldoc(smb_ioc_spooldoc_t *);\nint smb_spool_add_doc(smb_tree_t *, smb_kspooldoc_t *);\nvoid smb_spool_add_fid(smb_server_t *, uint16_t);\n\nvoid smb_server_inc_nbt_sess(smb_server_t *);\nvoid smb_server_dec_nbt_sess(smb_server_t *);\nvoid smb_server_inc_tcp_sess(smb_server_t *);\nvoid smb_server_dec_tcp_sess(smb_server_t *);\nvoid smb_server_inc_users(smb_server_t *);\nvoid smb_server_dec_users(smb_server_t *);\nvoid smb_server_inc_trees(smb_server_t *);\nvoid smb_server_dec_trees(smb_server_t *);\nvoid smb_server_inc_files(smb_server_t *);\nvoid smb_server_dec_files(smb_server_t *);\nvoid smb_server_inc_pipes(smb_server_t *);\nvoid smb_server_dec_pipes(smb_server_t *);\nvoid smb_server_add_rxb(smb_server_t *, int64_t);\nvoid smb_server_add_txb(smb_server_t *, int64_t);\nvoid smb_server_inc_req(smb_server_t *);\n\nsmb_event_t *smb_event_create(smb_server_t *, int);\nvoid smb_event_destroy(smb_event_t *);\nuint32_t smb_event_txid(smb_event_t *);\nint smb_event_wait(smb_event_t *);\nvoid smb_event_notify(smb_server_t *, uint32_t);\n\n/*\n * SMB node functions (file smb_node.c)\n */\nvoid smb_node_init(void);\nvoid smb_node_fini(void);\nsmb_node_t *smb_node_lookup(smb_request_t *, smb_arg_open_t *,\n    cred_t *, vnode_t *, char *, smb_node_t *, smb_node_t *);\nsmb_node_t *smb_stream_node_lookup(smb_request_t *, cred_t *,\n    smb_node_t *, vnode_t *, vnode_t *, char *);\n\nvoid smb_node_ref(smb_node_t *);\nvoid smb_node_release(smb_node_t *);\nvoid smb_node_rename(smb_node_t *, smb_node_t *, smb_node_t *, char *);\nint smb_node_root_init(smb_server_t *, smb_node_t **);\nvoid smb_node_add_lock(smb_node_t *, smb_lock_t *);\nvoid smb_node_destroy_lock(smb_node_t *, smb_lock_t *);\nvoid smb_node_destroy_lock_by_ofile(smb_node_t *, smb_ofile_t *);\nvoid smb_node_start_crit(smb_node_t *, krw_t);\nvoid smb_node_end_crit(smb_node_t *);\nint smb_node_in_crit(smb_node_t *);\nvoid smb_node_rdlock(smb_node_t *);\nvoid smb_node_wrlock(smb_node_t *);\nvoid smb_node_unlock(smb_node_t *);\nvoid smb_node_add_ofile(smb_node_t *, smb_ofile_t *);\nvoid smb_node_rem_ofile(smb_node_t *, smb_ofile_t *);\nvoid smb_node_inc_open_ofiles(smb_node_t *);\nuint32_t smb_node_dec_open_ofiles(smb_node_t *);\nvoid smb_node_inc_opening_count(smb_node_t *);\nvoid smb_node_dec_opening_count(smb_node_t *);\nboolean_t smb_node_is_file(smb_node_t *);\nboolean_t smb_node_is_dir(smb_node_t *);\nboolean_t smb_node_is_symlink(smb_node_t *);\nboolean_t smb_node_is_dfslink(smb_node_t *);\nboolean_t smb_node_is_reparse(smb_node_t *);\nboolean_t smb_node_is_vfsroot(smb_node_t *);\nboolean_t smb_node_is_system(smb_node_t *);\n\nuint32_t smb_node_open_check(smb_node_t *, uint32_t, uint32_t);\nDWORD smb_node_rename_check(smb_node_t *);\nDWORD smb_node_delete_check(smb_node_t *);\nboolean_t smb_node_share_check(smb_node_t *);\n\nvoid smb_node_fcn_subscribe(smb_node_t *, smb_request_t *);\nvoid smb_node_fcn_unsubscribe(smb_node_t *, smb_request_t *);\nvoid smb_node_notify_change(smb_node_t *, uint_t, const char *);\nvoid smb_node_notify_parents(smb_node_t *);\nint smb_node_getattr(smb_request_t *, smb_node_t *, cred_t *,\n    smb_ofile_t *, smb_attr_t *);\nint smb_node_setattr(smb_request_t *, smb_node_t *, cred_t *,\n    smb_ofile_t *, smb_attr_t *);\nuint32_t smb_node_set_delete_on_close(smb_node_t *, cred_t *, uint32_t);\nvoid smb_node_reset_delete_on_close(smb_node_t *);\nboolean_t smb_node_file_is_readonly(smb_node_t *);\nint smb_node_getpath(smb_node_t *, vnode_t *, char *, uint32_t);\nint smb_node_getmntpath(smb_node_t *, char *, uint32_t);\nint smb_node_getshrpath(smb_node_t *, smb_tree_t *, char *, uint32_t);\n\n/*\n * Pathname functions\n */\n\nint smb_pathname_reduce(smb_request_t *, cred_t *,\n    const char *, smb_node_t *, smb_node_t *, smb_node_t **, char *);\n\nint smb_pathname(smb_request_t *, char *, int, smb_node_t *,\n    smb_node_t *, smb_node_t **, smb_node_t **, cred_t *);\n\n/*\n * smb_vfs functions\n */\n\nint smb_vfs_hold(smb_export_t *, vfs_t *);\nvoid smb_vfs_rele(smb_export_t *, vfs_t *);\nvoid smb_vfs_rele_all(smb_export_t *);\n\n/* NOTIFY CHANGE */\n\nuint32_t smb_notify_common(smb_request_t *, mbuf_chain_t *, uint32_t);\nvoid smb_notify_event(smb_node_t *, uint_t, const char *);\nvoid smb_notify_file_closed(smb_ofile_t *);\n\nint smb_fem_fcn_install(smb_node_t *);\nvoid smb_fem_fcn_uninstall(smb_node_t *);\nint smb_fem_oplock_install(smb_node_t *);\nvoid smb_fem_oplock_uninstall(smb_node_t *);\n\n/* FEM */\n\nint smb_fem_init(void);\nvoid smb_fem_fini(void);\n\nint smb_try_grow(smb_request_t *sr, int64_t new_size);\n\nunsigned short smb_worker_getnum();\n\n/* SMB signing routines smb_signing.c */\nint smb_sign_begin(smb_request_t *, smb_token_t *);\nint smb_sign_check_request(smb_request_t *);\nint smb_sign_check_secondary(smb_request_t *, unsigned int);\nvoid smb_sign_reply(smb_request_t *, mbuf_chain_t *);\n/* SMB2, but here because it's called from common code. */\nint smb2_sign_begin(smb_request_t *, smb_token_t *);\n\nboolean_t smb_sattr_check(uint16_t, uint16_t);\n\nvoid smb_request_cancel(smb_request_t *);\nvoid smb_request_wait(smb_request_t *);\n\n/*\n * authentication support (smb_authenticate.c)\n */\nint smb_authenticate_ext(smb_request_t *);\nint smb_authenticate_old(smb_request_t *);\nvoid smb_authsock_close(smb_user_t *);\n\n/*\n * session functions (file smb_session.c)\n */\nsmb_session_t *smb_session_create(ksocket_t, uint16_t, smb_server_t *, int);\nvoid smb_session_receiver(smb_session_t *);\nvoid smb_session_disconnect(smb_session_t *);\nvoid smb_session_timers(smb_llist_t *);\nvoid smb_session_delete(smb_session_t *session);\nvoid smb_session_cancel_requests(smb_session_t *, smb_tree_t *,\n    smb_request_t *);\nvoid smb_session_config(smb_session_t *session);\nvoid smb_session_disconnect_from_share(smb_llist_t *, char *);\nsmb_user_t *smb_session_dup_user(smb_session_t *, char *, char *);\nsmb_user_t *smb_session_lookup_uid(smb_session_t *, uint16_t);\nsmb_user_t *smb_session_lookup_uid_st(smb_session_t *session,\n    uint16_t uid, smb_user_state_t st);\nvoid smb_session_post_user(smb_session_t *, smb_user_t *);\nvoid smb_session_post_tree(smb_session_t *, smb_tree_t *);\nsmb_tree_t *smb_session_lookup_tree(smb_session_t *, uint16_t);\nsmb_tree_t *smb_session_lookup_share(smb_session_t *, const char *,\n    smb_tree_t *);\nsmb_tree_t *smb_session_lookup_volume(smb_session_t *, const char *,\n    smb_tree_t *);\nvoid smb_session_close_pid(smb_session_t *, uint32_t);\nvoid smb_session_disconnect_owned_trees(smb_session_t *, smb_user_t *);\nvoid smb_session_disconnect_trees(smb_session_t *);\nvoid smb_session_disconnect_share(smb_session_t *, const char *);\nvoid smb_session_getclient(smb_session_t *, char *, size_t);\nboolean_t smb_session_isclient(smb_session_t *, const char *);\nvoid smb_session_correct_keep_alive_values(smb_llist_t *, uint32_t);\nvoid smb_session_oplock_break(smb_request_t *, uint8_t);\nint smb_session_send(smb_session_t *, uint8_t type, mbuf_chain_t *);\nint smb_session_xprt_gethdr(smb_session_t *, smb_xprt_t *);\nboolean_t smb_session_oplocks_enable(smb_session_t *);\nboolean_t smb_session_levelII_oplocks(smb_session_t *);\n\n#define\tSMB_SESSION_GET_ID(s)\t((s)->s_kid)\n\nsmb_request_t *smb_request_alloc(smb_session_t *, int);\nvoid smb_request_free(smb_request_t *);\n\n/*\n * ofile functions (file smb_ofile.c)\n */\nsmb_ofile_t *smb_ofile_lookup_by_fid(smb_request_t *, uint16_t);\nsmb_ofile_t *smb_ofile_lookup_by_uniqid(smb_tree_t *, uint32_t);\nboolean_t smb_ofile_disallow_fclose(smb_ofile_t *);\nsmb_ofile_t *smb_ofile_open(smb_request_t *, smb_node_t *,\n    smb_arg_open_t *, uint16_t, uint32_t, smb_error_t *);\nvoid smb_ofile_close(smb_ofile_t *, int32_t);\nvoid smb_ofile_delete(void *);\nuint32_t smb_ofile_access(smb_ofile_t *, cred_t *, uint32_t);\nint smb_ofile_seek(smb_ofile_t *, ushort_t, int32_t, uint32_t *);\nboolean_t smb_ofile_hold(smb_ofile_t *);\nvoid smb_ofile_release(smb_ofile_t *);\nvoid smb_ofile_request_complete(smb_ofile_t *);\nvoid smb_ofile_close_all(smb_tree_t *);\nvoid smb_ofile_close_all_by_pid(smb_tree_t *, uint16_t);\nvoid smb_ofile_set_flags(smb_ofile_t *, uint32_t);\nboolean_t smb_ofile_is_open(smb_ofile_t *);\nint smb_ofile_enum(smb_ofile_t *, smb_svcenum_t *);\nuint32_t smb_ofile_open_check(smb_ofile_t *, uint32_t, uint32_t);\nuint32_t smb_ofile_rename_check(smb_ofile_t *);\nuint32_t smb_ofile_delete_check(smb_ofile_t *);\nboolean_t smb_ofile_share_check(smb_ofile_t *);\ncred_t *smb_ofile_getcred(smb_ofile_t *);\nvoid smb_ofile_set_delete_on_close(smb_ofile_t *);\nvoid smb_delayed_write_timer(smb_llist_t *);\nvoid smb_ofile_set_quota_resume(smb_ofile_t *, char *);\nvoid smb_ofile_get_quota_resume(smb_ofile_t *, char *, int);\n\n#define\tSMB_OFILE_GET_SESSION(of)\t((of)->f_session)\n#define\tSMB_OFILE_GET_TREE(of)\t\t((of)->f_tree)\n#define\tSMB_OFILE_GET_FID(of)\t\t((of)->f_fid)\n#define\tSMB_OFILE_GET_NODE(of)\t\t((of)->f_node)\n\n#define\tsmb_ofile_granted_access(_of_)\t((_of_)->f_granted_access)\n\n/*\n * odir functions (file smb_odir.c)\n */\nuint32_t smb_odir_openpath(smb_request_t *, char *, uint16_t, uint32_t,\n    smb_odir_t **);\nuint32_t smb_odir_openfh(smb_request_t *, const char *, uint16_t,\n    smb_odir_t **);\nuint32_t smb_odir_openat(smb_request_t *, smb_node_t *, smb_odir_t **);\nvoid smb_odir_reopen(smb_odir_t *, const char *, uint16_t);\nvoid smb_odir_close(smb_odir_t *);\nboolean_t smb_odir_hold(smb_odir_t *);\nvoid smb_odir_release(smb_odir_t *);\nvoid smb_odir_delete(void *);\n\nint smb_odir_read(smb_request_t *, smb_odir_t *,\n    smb_odirent_t *, boolean_t *);\nint smb_odir_read_fileinfo(smb_request_t *, smb_odir_t *,\n    smb_fileinfo_t *, uint16_t *);\nint smb_odir_read_streaminfo(smb_request_t *, smb_odir_t *,\n    smb_streaminfo_t *, boolean_t *);\n\nvoid smb_odir_save_cookie(smb_odir_t *, int, uint32_t cookie);\nvoid smb_odir_save_fname(smb_odir_t *, uint32_t, const char *);\n\nvoid smb_odir_resume_at(smb_odir_t *, smb_odir_resume_t *);\n\n/*\n * SMB user functions (file smb_user.c)\n */\nsmb_user_t *smb_user_new(smb_session_t *);\nint smb_user_logon(smb_user_t *, cred_t *,\n    char *, char *, uint32_t, uint32_t, uint32_t);\nsmb_user_t *smb_user_dup(smb_user_t *);\nvoid smb_user_logoff(smb_user_t *);\nvoid smb_user_delete(void *);\nboolean_t smb_user_is_admin(smb_user_t *);\nboolean_t smb_user_namecmp(smb_user_t *, const char *);\nint smb_user_enum(smb_user_t *, smb_svcenum_t *);\nboolean_t smb_user_hold(smb_user_t *);\nvoid smb_user_hold_internal(smb_user_t *);\nvoid smb_user_release(smb_user_t *);\ncred_t *smb_user_getcred(smb_user_t *);\ncred_t *smb_user_getprivcred(smb_user_t *);\nvoid smb_user_netinfo_init(smb_user_t *, smb_netuserinfo_t *);\nvoid smb_user_netinfo_fini(smb_netuserinfo_t *);\nint smb_user_netinfo_encode(smb_user_t *, uint8_t *, size_t, uint32_t *);\nsmb_token_t *smb_get_token(smb_session_t *, smb_logon_t *);\ncred_t *smb_cred_create(smb_token_t *);\nvoid smb_user_setcred(smb_user_t *, cred_t *, uint32_t);\n\n/*\n * SMB tree functions (file smb_tree.c)\n */\nuint32_t smb_tree_connect(smb_request_t *);\nvoid smb_tree_disconnect(smb_tree_t *, boolean_t);\nvoid smb_tree_dealloc(void *);\nvoid smb_tree_post_ofile(smb_tree_t *, smb_ofile_t *);\nvoid smb_tree_post_odir(smb_tree_t *, smb_odir_t *);\nvoid smb_tree_close_pid(smb_tree_t *, uint32_t);\nboolean_t smb_tree_has_feature(smb_tree_t *, uint_t);\nint smb_tree_enum(smb_tree_t *, smb_svcenum_t *);\nint smb_tree_fclose(smb_tree_t *, uint32_t);\nboolean_t smb_tree_hold(smb_tree_t *);\nvoid smb_tree_hold_internal(smb_tree_t *);\nvoid smb_tree_release(smb_tree_t *);\nsmb_odir_t *smb_tree_lookup_odir(smb_request_t *, uint16_t);\nboolean_t smb_tree_is_connected(smb_tree_t *);\n#define\tSMB_TREE_GET_TID(tree)\t\t((tree)->t_tid)\n\nsmb_xa_t *smb_xa_create(smb_session_t *session, smb_request_t *sr,\n    uint32_t total_parameter_count, uint32_t total_data_count,\n    uint32_t max_parameter_count, uint32_t max_data_count,\n    uint32_t max_setup_count, uint32_t setup_word_count);\nvoid smb_xa_delete(smb_xa_t *xa);\nsmb_xa_t *smb_xa_hold(smb_xa_t *xa);\nvoid smb_xa_rele(smb_session_t *session, smb_xa_t *xa);\nint smb_xa_open(smb_xa_t *xa);\nvoid smb_xa_close(smb_xa_t *xa);\nint smb_xa_complete(smb_xa_t *xa);\nsmb_xa_t *smb_xa_find(smb_session_t *session, uint32_t pid, uint16_t mid);\n\nstruct mbuf *smb_mbuf_get(uchar_t *buf, int nbytes);\nstruct mbuf *smb_mbuf_allocate(struct uio *uio);\nvoid smb_mbuf_trim(struct mbuf *mhead, int nbytes);\n\nvoid smb_check_status(void);\nint smb_handle_write_raw(smb_session_t *session, smb_request_t *sr);\n\nint32_t smb_time_gmt_to_local(smb_request_t *, int32_t);\nint32_t smb_time_local_to_gmt(smb_request_t *, int32_t);\nint32_t\tsmb_time_dos_to_unix(int16_t, int16_t);\nvoid smb_time_unix_to_dos(int32_t, int16_t *, int16_t *);\nvoid smb_time_nt_to_unix(uint64_t nt_time, timestruc_t *unix_time);\nuint64_t smb_time_unix_to_nt(timestruc_t *);\n\nint netbios_name_isvalid(char *in, char *out);\n\nint uioxfer(struct uio *src_uio, struct uio *dst_uio, int n);\n\n/*\n * Pool ID function prototypes\n */\nint\tsmb_idpool_constructor(smb_idpool_t *pool);\nvoid\tsmb_idpool_destructor(smb_idpool_t  *pool);\nint\tsmb_idpool_alloc(smb_idpool_t *pool, uint16_t *id);\nvoid\tsmb_idpool_free(smb_idpool_t *pool, uint16_t id);\n\n/*\n * SMB locked list function prototypes\n */\nvoid\tsmb_llist_init(void);\nvoid\tsmb_llist_fini(void);\nvoid\tsmb_llist_constructor(smb_llist_t *, size_t, size_t);\nvoid\tsmb_llist_destructor(smb_llist_t *);\nvoid\tsmb_llist_exit(smb_llist_t *);\nvoid\tsmb_llist_post(smb_llist_t *, void *, smb_dtorproc_t);\nvoid\tsmb_llist_flush(smb_llist_t *);\nvoid\tsmb_llist_insert_head(smb_llist_t *ll, void *obj);\nvoid\tsmb_llist_insert_tail(smb_llist_t *ll, void *obj);\nvoid\tsmb_llist_remove(smb_llist_t *ll, void *obj);\nint\tsmb_llist_upgrade(smb_llist_t *ll);\nuint32_t smb_llist_get_count(smb_llist_t *ll);\n#define\tsmb_llist_enter(ll, mode)\trw_enter(&(ll)->ll_lock, mode)\n#define\tsmb_llist_head(ll)\t\tlist_head(&(ll)->ll_list)\n#define\tsmb_llist_next(ll, obj)\t\tlist_next(&(ll)->ll_list, obj)\nint\tsmb_account_connected(smb_user_t *user);\n\n/*\n * SMB Synchronized list function prototypes\n */\nvoid\tsmb_slist_constructor(smb_slist_t *, size_t, size_t);\nvoid\tsmb_slist_destructor(smb_slist_t *);\nvoid\tsmb_slist_insert_head(smb_slist_t *sl, void *obj);\nvoid\tsmb_slist_insert_tail(smb_slist_t *sl, void *obj);\nvoid\tsmb_slist_remove(smb_slist_t *sl, void *obj);\nvoid\tsmb_slist_wait_for_empty(smb_slist_t *sl);\nvoid\tsmb_slist_exit(smb_slist_t *sl);\nuint32_t smb_slist_move_tail(list_t *lst, smb_slist_t *sl);\nvoid    smb_slist_obj_move(smb_slist_t *dst, smb_slist_t *src, void *obj);\n#define\tsmb_slist_enter(sl)\t\tmutex_enter(&(sl)->sl_mutex)\n#define\tsmb_slist_head(sl)\t\tlist_head(&(sl)->sl_list)\n#define\tsmb_slist_next(sl, obj)\t\tlist_next(&(sl)->sl_list, obj)\n\nvoid    smb_rwx_init(smb_rwx_t *rwx);\nvoid    smb_rwx_destroy(smb_rwx_t *rwx);\n#define\tsmb_rwx_rwenter(rwx, mode)\trw_enter(&(rwx)->rwx_lock, mode)\nvoid    smb_rwx_rwexit(smb_rwx_t *rwx);\nint\tsmb_rwx_rwwait(smb_rwx_t *rwx, clock_t timeout);\n#define\tsmb_rwx_xenter(rwx)\t\tmutex_enter(&(rwx)->rwx_mutex)\n#define\tsmb_rwx_xexit(rwx)\t\tmutex_exit(&(rwx)->rwx_mutex)\nkrw_t   smb_rwx_rwupgrade(smb_rwx_t *rwx);\nvoid    smb_rwx_rwdowngrade(smb_rwx_t *rwx, krw_t mode);\n\nvoid\tsmb_thread_init(smb_thread_t *, char *, smb_thread_ep_t,\n\t\tvoid *, pri_t);\nvoid\tsmb_thread_destroy(smb_thread_t *);\nint\tsmb_thread_start(smb_thread_t *);\nvoid\tsmb_thread_stop(smb_thread_t *);\nvoid    smb_thread_signal(smb_thread_t *);\nboolean_t smb_thread_continue(smb_thread_t *);\nboolean_t smb_thread_continue_nowait(smb_thread_t *);\nboolean_t smb_thread_continue_timedwait(smb_thread_t *, int /* seconds */);\n\nuint32_t smb_denymode_to_sharemode(uint32_t desired_access, char *fname);\nuint32_t smb_ofun_to_crdisposition(uint16_t ofun);\n\n/* 100's of ns between 1/1/1970 and 1/1/1601 */\n#define\tNT_TIME_BIAS\t(134774LL * 24LL * 60LL * 60LL * 10000000LL)\n\nuint32_t smb_sd_read(smb_request_t *, smb_sd_t *, uint32_t);\nuint32_t smb_sd_write(smb_request_t *, smb_sd_t *, uint32_t);\n\nacl_t *smb_fsacl_inherit(acl_t *, int, int, cred_t *);\nacl_t *smb_fsacl_merge(acl_t *, acl_t *);\nvoid smb_fsacl_split(acl_t *, acl_t **, acl_t **, int);\nacl_t *smb_fsacl_from_vsa(vsecattr_t *, acl_type_t);\nint smb_fsacl_to_vsa(acl_t *, vsecattr_t *, int *);\n\nboolean_t smb_ace_is_generic(int);\nboolean_t smb_ace_is_access(int);\nboolean_t smb_ace_is_audit(int);\n\nuint32_t smb_vss_enum_snapshots(smb_request_t *, smb_fsctl_t *);\nint smb_vss_lookup_nodes(smb_request_t *, smb_node_t *, smb_node_t *,\n    char *, smb_node_t **, smb_node_t **);\nvnode_t *smb_lookuppathvptovp(smb_request_t *, char *, vnode_t *, vnode_t *);\n\nvoid smb_panic(char *, const char *, int);\n#pragma\tdoes_not_return(smb_panic)\n#define\tSMB_PANIC()\tsmb_panic(__FILE__, __func__, __LINE__)\n\nvoid smb_latency_init(smb_latency_t *);\nvoid smb_latency_destroy(smb_latency_t *);\nvoid smb_latency_add_sample(smb_latency_t *, hrtime_t);\nvoid smb_srqueue_init(smb_srqueue_t *);\nvoid smb_srqueue_destroy(smb_srqueue_t *);\nvoid smb_srqueue_waitq_enter(smb_srqueue_t *);\nvoid smb_srqueue_runq_exit(smb_srqueue_t *);\nvoid smb_srqueue_waitq_to_runq(smb_srqueue_t *);\nvoid smb_srqueue_update(smb_srqueue_t *, smb_kstat_utilization_t *);\n\nvoid *smb_mem_alloc(size_t);\nvoid *smb_mem_zalloc(size_t);\nvoid *smb_mem_realloc(void *, size_t);\nvoid *smb_mem_rezalloc(void *, size_t);\nvoid smb_mem_free(void *);\nvoid smb_mem_zfree(void *);\nchar *smb_mem_strdup(const char *);\nvoid smb_srm_init(smb_request_t *);\nvoid smb_srm_fini(smb_request_t *);\nvoid *smb_srm_alloc(smb_request_t *, size_t);\nvoid *smb_srm_zalloc(smb_request_t *, size_t);\nvoid *smb_srm_realloc(smb_request_t *, void *, size_t);\nvoid *smb_srm_rezalloc(smb_request_t *, void *, size_t);\nchar *smb_srm_strdup(smb_request_t *, const char *);\n\nvoid smb_export_start(smb_server_t *);\nvoid smb_export_stop(smb_server_t *);\n\n#ifdef\t_KERNEL\nstruct __door_handle;\nstruct __door_handle *smb_kshare_door_init(int);\nvoid smb_kshare_door_fini(struct __door_handle *);\nint smb_kshare_upcall(struct __door_handle *, void *, boolean_t);\n#endif\t/* _KERNEL */\n\nvoid smb_kshare_g_init(void);\nvoid smb_kshare_g_fini(void);\nvoid smb_kshare_init(smb_server_t *);\nvoid smb_kshare_fini(smb_server_t *);\nint smb_kshare_start(smb_server_t *);\nvoid smb_kshare_stop(smb_server_t *);\n\nint smb_kshare_export_list(smb_ioc_share_t *);\nint smb_kshare_unexport_list(smb_ioc_share_t *);\nint smb_kshare_info(smb_ioc_shareinfo_t *);\nvoid smb_kshare_enum(smb_server_t *, smb_enumshare_info_t *);\nsmb_kshare_t *smb_kshare_lookup(smb_server_t *, const char *);\nvoid smb_kshare_release(smb_server_t *, smb_kshare_t *);\nint smb_kshare_exec(smb_server_t *, smb_shr_execinfo_t *);\nuint32_t smb_kshare_hostaccess(smb_kshare_t *, smb_session_t *);\n\n\nvoid smb_avl_create(smb_avl_t *, size_t, size_t, const smb_avl_nops_t *);\nvoid smb_avl_destroy(smb_avl_t *);\nint smb_avl_add(smb_avl_t *, void *);\nvoid smb_avl_remove(smb_avl_t *, void *);\nvoid *smb_avl_lookup(smb_avl_t *, void *);\nvoid smb_avl_release(smb_avl_t *, void *);\nvoid smb_avl_iterinit(smb_avl_t *, smb_avl_cursor_t *);\nvoid *smb_avl_iterate(smb_avl_t *, smb_avl_cursor_t *);\n\nvoid smb_threshold_init(smb_cmd_threshold_t *,\n    char *, uint_t, uint_t);\nvoid smb_threshold_fini(smb_cmd_threshold_t *);\nint smb_threshold_enter(smb_cmd_threshold_t *);\nvoid smb_threshold_exit(smb_cmd_threshold_t *);\nvoid smb_threshold_wake_all(smb_cmd_threshold_t *);\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif /* _SMB_KPROTO_H_ */\n"], "fixing_code": ["/*\n * This file and its contents are supplied under the terms of the\n * Common Development and Distribution License (\"CDDL\"), version 1.0.\n * You may only use this file in accordance with the terms of version\n * 1.0 of the CDDL.\n *\n * A full copy of the text of the CDDL should have accompanied this\n * source.  A copy of the CDDL is also available via the Internet at\n * http://www.illumos.org/license/CDDL.\n */\n\n/*\n * Copyright 2014 Nexenta Systems, Inc.  All rights reserved.\n * Copyright 2016 Syneto S.R.L. All rights reserved.\n */\n\n/*\n * Dispatch function for SMB2_FLUSH\n */\n\n#include <smbsrv/smb2_kproto.h>\n#include <smbsrv/smb_fsops.h>\n\nsmb_sdrc_t\nsmb2_flush(smb_request_t *sr)\n{\n\tuint16_t StructSize;\n\tuint16_t reserved1;\n\tuint32_t reserved2;\n\tsmb2fid_t smb2fid;\n\tuint32_t status;\n\tint rc = 0;\n\n\t/*\n\t * SMB2 Flush request\n\t */\n\trc = smb_mbc_decodef(\n\t    &sr->smb_data, \"wwlqq\",\n\t    &StructSize,\t\t/* w */\n\t    &reserved1,\t\t\t/* w */\n\t    &reserved2,\t\t\t/* l */\n\t    &smb2fid.persistent,\t/* q */\n\t    &smb2fid.temporal);\t\t/* q */\n\tif (rc)\n\t\treturn (SDRC_ERROR);\n\tif (StructSize != 24)\n\t\treturn (SDRC_ERROR);\n\n\tstatus = smb2sr_lookup_fid(sr, &smb2fid);\n\tif (status) {\n\t\tsmb2sr_put_error(sr, status);\n\t\treturn (SDRC_SUCCESS);\n\t}\n\n\tsmb_ofile_flush(sr, sr->fid_ofile);\n\n\t/*\n\t * SMB2 Flush reply\n\t */\n\t(void) smb_mbc_encodef(\n\t    &sr->reply, \"wwl\",\n\t    4,\t/* StructSize */\t/* w */\n\t    0); /* reserved */\t\t/* w */\n\n\treturn (SDRC_SUCCESS);\n}\n", "/*\n * CDDL HEADER START\n *\n * The contents of this file are subject to the terms of the\n * Common Development and Distribution License (the \"License\").\n * You may not use this file except in compliance with the License.\n *\n * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE\n * or http://www.opensolaris.org/os/licensing.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL HEADER in each\n * file and include the License file at usr/src/OPENSOLARIS.LICENSE.\n * If applicable, add the following below this CDDL HEADER, with the\n * fields enclosed by brackets \"[]\" replaced with your own identifying\n * information: Portions Copyright [yyyy] [name of copyright owner]\n *\n * CDDL HEADER END\n */\n/*\n * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.\n * Use is subject to license terms.\n *\n * Copyright 2016 Syneto S.R.L. All rights reserved.\n */\n\n/*\n * The flush SMB is sent to ensure all data and allocation information\n * for the corresponding file has been written to stable storage. This\n * is a synchronous request. The response should not be sent until the\n * writes are complete.\n *\n * The SmbFlush request is described in CIFS/1.0 1996 Section 3.9.14.\n *\n * CIFS/1.0 June 13, 1996\n * Heizer, et al\n * draft-heizer-cifs-v1-spec-00.txt\n */\n\n#include <smbsrv/smb_kproto.h>\n#include <smbsrv/smb_fsops.h>\n\n\n/*\n * smb_com_flush\n *\n * Flush any cached data for a specified file, or for all files that\n * this client has open, to stable storage. If the fid is valid (i.e.\n * not 0xFFFF), we flush only that file. Otherwise we flush all files\n * associated with this client.\n *\n * We need to protect the list because there's a good chance we'll\n * block during the flush operation.\n */\nsmb_sdrc_t\nsmb_pre_flush(smb_request_t *sr)\n{\n\tint rc;\n\n\trc = smbsr_decode_vwv(sr, \"w\", &sr->smb_fid);\n\n\tDTRACE_SMB_1(op__Flush__start, smb_request_t *, sr);\n\n\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n}\n\nvoid\nsmb_post_flush(smb_request_t *sr)\n{\n\tDTRACE_SMB_1(op__Flush__done, smb_request_t *, sr);\n}\n\nsmb_sdrc_t\nsmb_com_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t\t*file;\n\tsmb_llist_t\t*flist;\n\tint\t\trc;\n\n\tif (smb_flush_required == 0) {\n\t\trc = smbsr_encode_empty_result(sr);\n\t\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n\t}\n\n\tif (sr->smb_fid != 0xffff) {\n\t\tsmbsr_lookup_file(sr);\n\t\tif (sr->fid_ofile == NULL) {\n\t\t\tsmbsr_error(sr, NT_STATUS_INVALID_HANDLE,\n\t\t\t    ERRDOS, ERRbadfid);\n\t\t\treturn (SDRC_ERROR);\n\t\t}\n\t\tsmb_ofile_flush(sr, sr->fid_ofile);\n\t} else {\n\t\tflist = &sr->tid_tree->t_ofile_list;\n\t\tsmb_llist_enter(flist, RW_READER);\n\t\tfile = smb_llist_head(flist);\n\t\twhile (file) {\n\t\t\tmutex_enter(&file->f_mutex);\n\t\t\tsmb_ofile_flush(sr, file);\n\t\t\tmutex_exit(&file->f_mutex);\n\t\t\tfile = smb_llist_next(flist, file);\n\t\t}\n\t\tsmb_llist_exit(flist);\n\t}\n\n\trc = smbsr_encode_empty_result(sr);\n\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n}\n", "/*\n * CDDL HEADER START\n *\n * The contents of this file are subject to the terms of the\n * Common Development and Distribution License (the \"License\").\n * You may not use this file except in compliance with the License.\n *\n * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE\n * or http://www.opensolaris.org/os/licensing.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL HEADER in each\n * file and include the License file at usr/src/OPENSOLARIS.LICENSE.\n * If applicable, add the following below this CDDL HEADER, with the\n * fields enclosed by brackets \"[]\" replaced with your own identifying\n * information: Portions Copyright [yyyy] [name of copyright owner]\n *\n * CDDL HEADER END\n */\n/*\n * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.\n * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.\n * Copyright 2016 Syneto S.R.L. All rights reserved.\n */\n\n/*\n * General Structures Layout\n * -------------------------\n *\n * This is a simplified diagram showing the relationship between most of the\n * main structures.\n *\n * +-------------------+\n * |     SMB_INFO      |\n * +-------------------+\n *          |\n *          |\n *          v\n * +-------------------+       +-------------------+      +-------------------+\n * |     SESSION       |<----->|     SESSION       |......|      SESSION      |\n * +-------------------+       +-------------------+      +-------------------+\n *   |          |\n *   |          |\n *   |          v\n *   |  +-------------------+     +-------------------+   +-------------------+\n *   |  |       USER        |<--->|       USER        |...|       USER        |\n *   |  +-------------------+     +-------------------+   +-------------------+\n *   |\n *   |\n *   v\n * +-------------------+       +-------------------+      +-------------------+\n * |       TREE        |<----->|       TREE        |......|       TREE        |\n * +-------------------+       +-------------------+      +-------------------+\n *      |         |\n *      |         |\n *      |         v\n *      |     +-------+       +-------+      +-------+\n *      |     | OFILE |<----->| OFILE |......| OFILE |\n *      |     +-------+       +-------+      +-------+\n *      |\n *      |\n *      v\n *  +-------+       +------+      +------+\n *  | ODIR  |<----->| ODIR |......| ODIR |\n *  +-------+       +------+      +------+\n *\n *\n * Ofile State Machine\n * ------------------\n *\n *    +-------------------------+\t T0\n *    |  SMB_OFILE_STATE_OPEN   |<----------- Creation/Allocation\n *    +-------------------------+\n *\t\t    |\n *\t\t    | T1\n *\t\t    |\n *\t\t    v\n *    +-------------------------+\n *    | SMB_OFILE_STATE_CLOSING |\n *    +-------------------------+\n *\t\t    |\n *\t\t    | T2\n *\t\t    |\n *\t\t    v\n *    +-------------------------+    T3\n *    | SMB_OFILE_STATE_CLOSED  |----------> Deletion/Free\n *    +-------------------------+\n *\n * SMB_OFILE_STATE_OPEN\n *\n *    While in this state:\n *      - The ofile is queued in the list of ofiles of its tree.\n *      - References will be given out if the ofile is looked up.\n *\n * SMB_OFILE_STATE_CLOSING\n *\n *    While in this state:\n *      - The ofile is queued in the list of ofiles of its tree.\n *      - References will not be given out if the ofile is looked up.\n *      - The file is closed and the locks held are being released.\n *      - The resources associated with the ofile remain.\n *\n * SMB_OFILE_STATE_CLOSED\n *\n *    While in this state:\n *      - The ofile is queued in the list of ofiles of its tree.\n *      - References will not be given out if the ofile is looked up.\n *      - The resources associated with the ofile remain.\n *\n * Transition T0\n *\n *    This transition occurs in smb_ofile_open(). A new ofile is created and\n *    added to the list of ofiles of a tree.\n *\n * Transition T1\n *\n *    This transition occurs in smb_ofile_close().\n *\n * Transition T2\n *\n *    This transition occurs in smb_ofile_release(). The resources associated\n *    with the ofile are freed as well as the ofile structure. For the\n *    transition to occur, the ofile must be in the SMB_OFILE_STATE_CLOSED\n *    state and the reference count be zero.\n *\n * Comments\n * --------\n *\n *    The state machine of the ofile structures is controlled by 3 elements:\n *      - The list of ofiles of the tree it belongs to.\n *      - The mutex embedded in the structure itself.\n *      - The reference count.\n *\n *    There's a mutex embedded in the ofile structure used to protect its fields\n *    and there's a lock embedded in the list of ofiles of a tree. To\n *    increment or to decrement the reference count the mutex must be entered.\n *    To insert the ofile into the list of ofiles of the tree and to remove\n *    the ofile from it, the lock must be entered in RW_WRITER mode.\n *\n *    Rules of access to a ofile structure:\n *\n *    1) In order to avoid deadlocks, when both (mutex and lock of the ofile\n *       list) have to be entered, the lock must be entered first.\n *\n *    2) All actions applied to an ofile require a reference count.\n *\n *    3) There are 2 ways of getting a reference count. One is when the ofile\n *       is opened. The other one when the ofile is looked up. This translates\n *       into 2 functions: smb_ofile_open() and smb_ofile_lookup_by_fid().\n *\n *    It should be noted that the reference count of an ofile registers the\n *    number of references to the ofile in other structures (such as an smb\n *    request). The reference count is not incremented in these 2 instances:\n *\n *    1) The ofile is open. An ofile is anchored by his state. If there's\n *       no activity involving an ofile currently open, the reference count\n *       of that ofile is zero.\n *\n *    2) The ofile is queued in the list of ofiles of its tree. The fact of\n *       being queued in that list is NOT registered by incrementing the\n *       reference count.\n */\n#include <smbsrv/smb_kproto.h>\n#include <smbsrv/smb_fsops.h>\n\nstatic boolean_t smb_ofile_is_open_locked(smb_ofile_t *);\nstatic smb_ofile_t *smb_ofile_close_and_next(smb_ofile_t *);\nstatic int smb_ofile_netinfo_encode(smb_ofile_t *, uint8_t *, size_t,\n    uint32_t *);\nstatic int smb_ofile_netinfo_init(smb_ofile_t *, smb_netfileinfo_t *);\nstatic void smb_ofile_netinfo_fini(smb_netfileinfo_t *);\n\n/*\n * smb_ofile_open\n */\nsmb_ofile_t *\nsmb_ofile_open(\n    smb_request_t\t*sr,\n    smb_node_t\t\t*node,\n    struct open_param\t*op,\n    uint16_t\t\tftype,\n    uint32_t\t\tuniqid,\n    smb_error_t\t\t*err)\n{\n\tsmb_tree_t\t*tree = sr->tid_tree;\n\tsmb_ofile_t\t*of;\n\tuint16_t\tfid;\n\tsmb_attr_t\tattr;\n\tint\t\trc;\n\tenum errstates { EMPTY, FIDALLOC, CRHELD, MUTEXINIT };\n\tenum errstates\tstate = EMPTY;\n\n\tif (smb_idpool_alloc(&tree->t_fid_pool, &fid)) {\n\t\terr->status = NT_STATUS_TOO_MANY_OPENED_FILES;\n\t\terr->errcls = ERRDOS;\n\t\terr->errcode = ERROR_TOO_MANY_OPEN_FILES;\n\t\treturn (NULL);\n\t}\n\tstate = FIDALLOC;\n\n\tof = kmem_cache_alloc(smb_cache_ofile, KM_SLEEP);\n\tbzero(of, sizeof (smb_ofile_t));\n\tof->f_magic = SMB_OFILE_MAGIC;\n\tof->f_refcnt = 1;\n\tof->f_fid = fid;\n\tof->f_uniqid = uniqid;\n\tof->f_opened_by_pid = sr->smb_pid;\n\tof->f_granted_access = op->desired_access;\n\tof->f_share_access = op->share_access;\n\tof->f_create_options = op->create_options;\n\tof->f_cr = (op->create_options & FILE_OPEN_FOR_BACKUP_INTENT) ?\n\t    smb_user_getprivcred(sr->uid_user) : sr->uid_user->u_cred;\n\tcrhold(of->f_cr);\n\tstate = CRHELD;\n\tof->f_ftype = ftype;\n\tof->f_server = tree->t_server;\n\tof->f_session = tree->t_session;\n\t/*\n\t * grab a ref for of->f_user\n\t * released in smb_ofile_delete()\n\t */\n\tsmb_user_hold_internal(sr->uid_user);\n\tof->f_user = sr->uid_user;\n\tof->f_tree = tree;\n\tof->f_node = node;\n\n\tmutex_init(&of->f_mutex, NULL, MUTEX_DEFAULT, NULL);\n\tstate = MUTEXINIT;\n\tof->f_state = SMB_OFILE_STATE_OPEN;\n\n\tif (ftype == SMB_FTYPE_MESG_PIPE) {\n\t\t/* See smb_opipe_open. */\n\t\tof->f_pipe = op->pipe;\n\t\tsmb_server_inc_pipes(of->f_server);\n\t} else {\n\t\tASSERT(ftype == SMB_FTYPE_DISK); /* Regular file, not a pipe */\n\t\tASSERT(node);\n\n\t\t/*\n\t\t * Note that the common open path often adds bits like\n\t\t * READ_CONTROL, so the logic \"is this open exec-only\"\n\t\t * needs to look at only the FILE_DATA_ALL bits.\n\t\t */\n\t\tif ((of->f_granted_access & FILE_DATA_ALL) == FILE_EXECUTE)\n\t\t\tof->f_flags |= SMB_OFLAGS_EXECONLY;\n\n\t\tbzero(&attr, sizeof (smb_attr_t));\n\t\tattr.sa_mask = SMB_AT_UID | SMB_AT_DOSATTR;\n\t\trc = smb_node_getattr(NULL, node, of->f_cr, NULL, &attr);\n\t\tif (rc != 0) {\n\t\t\terr->status = NT_STATUS_INTERNAL_ERROR;\n\t\t\terr->errcls = ERRDOS;\n\t\t\terr->errcode = ERROR_INTERNAL_ERROR;\n\t\t\tgoto errout;\n\t\t}\n\t\tif (crgetuid(of->f_cr) == attr.sa_vattr.va_uid) {\n\t\t\t/*\n\t\t\t * Add this bit for the file's owner even if it's not\n\t\t\t * specified in the request (Windows behavior).\n\t\t\t */\n\t\t\tof->f_granted_access |= FILE_READ_ATTRIBUTES;\n\t\t}\n\n\t\tif (smb_node_is_file(node)) {\n\t\t\tof->f_mode =\n\t\t\t    smb_fsop_amask_to_omode(of->f_granted_access);\n\t\t\tif (smb_fsop_open(node, of->f_mode, of->f_cr) != 0) {\n\t\t\t\terr->status = NT_STATUS_ACCESS_DENIED;\n\t\t\t\terr->errcls = ERRDOS;\n\t\t\t\terr->errcode = ERROR_ACCESS_DENIED;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t}\n\n\t\tif (tree->t_flags & SMB_TREE_READONLY)\n\t\t\tof->f_flags |= SMB_OFLAGS_READONLY;\n\n\t\t/*\n\t\t * Note that if we created_readonly, that\n\t\t * will _not_ yet show in attr.sa_dosattr\n\t\t * so creating a readonly file gives the\n\t\t * caller a writable handle as it should.\n\t\t */\n\t\tif (attr.sa_dosattr & FILE_ATTRIBUTE_READONLY)\n\t\t\tof->f_flags |= SMB_OFLAGS_READONLY;\n\n\t\tsmb_node_inc_open_ofiles(node);\n\t\tsmb_node_add_ofile(node, of);\n\t\tsmb_node_ref(node);\n\t\tsmb_server_inc_files(of->f_server);\n\t}\n\tsmb_llist_enter(&tree->t_ofile_list, RW_WRITER);\n\tsmb_llist_insert_tail(&tree->t_ofile_list, of);\n\tsmb_llist_exit(&tree->t_ofile_list);\n\tatomic_inc_32(&tree->t_open_files);\n\tatomic_inc_32(&of->f_session->s_file_cnt);\n\treturn (of);\n\nerrout:\n\tswitch (state) {\n\tcase MUTEXINIT:\n\t\tmutex_destroy(&of->f_mutex);\n\t\tsmb_user_release(of->f_user);\n\t\t/*FALLTHROUGH*/\n\tcase CRHELD:\n\t\tcrfree(of->f_cr);\n\t\tof->f_magic = 0;\n\t\tkmem_cache_free(smb_cache_ofile, of);\n\t\t/*FALLTHROUGH*/\n\tcase FIDALLOC:\n\t\tsmb_idpool_free(&tree->t_fid_pool, fid);\n\t\t/*FALLTHROUGH*/\n\tcase EMPTY:\n\t\tbreak;\n\t}\n\treturn (NULL);\n}\n\n/*\n * smb_ofile_close\n */\nvoid\nsmb_ofile_close(smb_ofile_t *of, int32_t mtime_sec)\n{\n\tsmb_attr_t *pa;\n\ttimestruc_t now;\n\tuint32_t flags = 0;\n\n\tSMB_OFILE_VALID(of);\n\n\tmutex_enter(&of->f_mutex);\n\tASSERT(of->f_refcnt);\n\tif (of->f_state != SMB_OFILE_STATE_OPEN) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn;\n\t}\n\tof->f_state = SMB_OFILE_STATE_CLOSING;\n\tmutex_exit(&of->f_mutex);\n\n\tswitch (of->f_ftype) {\n\tcase SMB_FTYPE_BYTE_PIPE:\n\tcase SMB_FTYPE_MESG_PIPE:\n\t\tsmb_opipe_close(of);\n\t\tsmb_server_dec_pipes(of->f_server);\n\t\tbreak;\n\n\tcase SMB_FTYPE_DISK:\n\tcase SMB_FTYPE_PRINTER:\n\t\t/*\n\t\t * In here we make changes to of->f_pending_attr\n\t\t * while not holding of->f_mutex.  This is OK\n\t\t * because we've changed f_state to CLOSING,\n\t\t * so no more threads will take this path.\n\t\t */\n\t\tpa = &of->f_pending_attr;\n\t\tif (mtime_sec != 0) {\n\t\t\tpa->sa_vattr.va_mtime.tv_sec = mtime_sec;\n\t\t\tpa->sa_mask |= SMB_AT_MTIME;\n\t\t}\n\n\t\t/*\n\t\t * If we have ever modified data via this handle\n\t\t * (write or truncate) and if the mtime was not\n\t\t * set via this handle, update the mtime again\n\t\t * during the close.  Windows expects this.\n\t\t * [ MS-FSA 2.1.5.4 \"Update Timestamps\" ]\n\t\t */\n\t\tif (of->f_written &&\n\t\t    (pa->sa_mask & SMB_AT_MTIME) == 0) {\n\t\t\tpa->sa_mask |= SMB_AT_MTIME;\n\t\t\tgethrestime(&now);\n\t\t\tpa->sa_vattr.va_mtime = now;\n\t\t}\n\n\t\tif (of->f_flags & SMB_OFLAGS_SET_DELETE_ON_CLOSE) {\n\t\t\tif (smb_tree_has_feature(of->f_tree,\n\t\t\t    SMB_TREE_CATIA)) {\n\t\t\t\tflags |= SMB_CATIA;\n\t\t\t}\n\t\t\t(void) smb_node_set_delete_on_close(of->f_node,\n\t\t\t    of->f_cr, flags);\n\t\t}\n\t\tsmb_fsop_unshrlock(of->f_cr, of->f_node, of->f_uniqid);\n\t\tsmb_node_destroy_lock_by_ofile(of->f_node, of);\n\n\t\tif (smb_node_is_file(of->f_node)) {\n\t\t\t(void) smb_fsop_close(of->f_node, of->f_mode,\n\t\t\t    of->f_cr);\n\t\t\tsmb_oplock_release(of->f_node, of);\n\t\t} else {\n\t\t\t/*\n\t\t\t * If there was an odir, close it.\n\t\t\t */\n\t\t\tif (of->f_odir != NULL)\n\t\t\t\tsmb_odir_close(of->f_odir);\n\t\t}\n\t\tif (smb_node_dec_open_ofiles(of->f_node) == 0) {\n\t\t\t/*\n\t\t\t * Last close. The f_pending_attr has\n\t\t\t * only times (atime,ctime,mtime) so\n\t\t\t * we can borrow it to commit the\n\t\t\t * n_pending_dosattr from the node.\n\t\t\t */\n\t\t\tpa->sa_dosattr =\n\t\t\t    of->f_node->n_pending_dosattr;\n\t\t\tif (pa->sa_dosattr != 0)\n\t\t\t\tpa->sa_mask |= SMB_AT_DOSATTR;\n\t\t\t/* Let's leave this zero when not in use. */\n\t\t\tof->f_node->n_allocsz = 0;\n\t\t}\n\t\tif (pa->sa_mask != 0) {\n\t\t\t/*\n\t\t\t * Commit any pending attributes from\n\t\t\t * the ofile we're closing.  Note that\n\t\t\t * we pass NULL as the ofile to setattr\n\t\t\t * so it will write to the file system\n\t\t\t * and not keep anything on the ofile.\n\t\t\t * This clears n_pending_dosattr if\n\t\t\t * there are no opens, otherwise the\n\t\t\t * dosattr will be pending again.\n\t\t\t */\n\t\t\t(void) smb_node_setattr(NULL, of->f_node,\n\t\t\t    of->f_cr, NULL, pa);\n\t\t}\n\n\t\t/*\n\t\t * Cancel any notify change requests that\n\t\t * may be using this open instance.\n\t\t */\n\t\tif (of->f_node->n_fcn.fcn_count)\n\t\t\tsmb_notify_file_closed(of);\n\n\t\tsmb_server_dec_files(of->f_server);\n\t\tbreak;\n\t}\n\tatomic_dec_32(&of->f_tree->t_open_files);\n\n\tmutex_enter(&of->f_mutex);\n\tASSERT(of->f_refcnt);\n\tASSERT(of->f_state == SMB_OFILE_STATE_CLOSING);\n\tof->f_state = SMB_OFILE_STATE_CLOSED;\n\tmutex_exit(&of->f_mutex);\n}\n\n/*\n * smb_ofile_close_all\n *\n *\n */\nvoid\nsmb_ofile_close_all(\n    smb_tree_t\t\t*tree)\n{\n\tsmb_ofile_t\t*of;\n\n\tASSERT(tree);\n\tASSERT(tree->t_magic == SMB_TREE_MAGIC);\n\n\tsmb_llist_enter(&tree->t_ofile_list, RW_READER);\n\tof = smb_llist_head(&tree->t_ofile_list);\n\twhile (of) {\n\t\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\t\tASSERT(of->f_tree == tree);\n\t\tof = smb_ofile_close_and_next(of);\n\t}\n\tsmb_llist_exit(&tree->t_ofile_list);\n}\n\n/*\n * smb_ofiles_close_by_pid\n *\n *\n */\nvoid\nsmb_ofile_close_all_by_pid(\n    smb_tree_t\t\t*tree,\n    uint16_t\t\tpid)\n{\n\tsmb_ofile_t\t*of;\n\n\tASSERT(tree);\n\tASSERT(tree->t_magic == SMB_TREE_MAGIC);\n\n\tsmb_llist_enter(&tree->t_ofile_list, RW_READER);\n\tof = smb_llist_head(&tree->t_ofile_list);\n\twhile (of) {\n\t\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\t\tASSERT(of->f_tree == tree);\n\t\tif (of->f_opened_by_pid == pid) {\n\t\t\tof = smb_ofile_close_and_next(of);\n\t\t} else {\n\t\t\tof = smb_llist_next(&tree->t_ofile_list, of);\n\t\t}\n\t}\n\tsmb_llist_exit(&tree->t_ofile_list);\n}\n\n/*\n * If the enumeration request is for ofile data, handle it here.\n * Otherwise, return.\n *\n * This function should be called with a hold on the ofile.\n */\nint\nsmb_ofile_enum(smb_ofile_t *of, smb_svcenum_t *svcenum)\n{\n\tuint8_t *pb;\n\tuint_t nbytes;\n\tint rc;\n\n\tASSERT(of);\n\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\tASSERT(of->f_refcnt);\n\n\tif (svcenum->se_type != SMB_SVCENUM_TYPE_FILE)\n\t\treturn (0);\n\n\tif (svcenum->se_nskip > 0) {\n\t\tsvcenum->se_nskip--;\n\t\treturn (0);\n\t}\n\n\tif (svcenum->se_nitems >= svcenum->se_nlimit) {\n\t\tsvcenum->se_nitems = svcenum->se_nlimit;\n\t\treturn (0);\n\t}\n\n\tpb = &svcenum->se_buf[svcenum->se_bused];\n\n\trc = smb_ofile_netinfo_encode(of, pb, svcenum->se_bavail,\n\t    &nbytes);\n\tif (rc == 0) {\n\t\tsvcenum->se_bavail -= nbytes;\n\t\tsvcenum->se_bused += nbytes;\n\t\tsvcenum->se_nitems++;\n\t}\n\n\treturn (rc);\n}\n\n/*\n * Take a reference on an open file.\n */\nboolean_t\nsmb_ofile_hold(smb_ofile_t *of)\n{\n\tASSERT(of);\n\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\n\tmutex_enter(&of->f_mutex);\n\n\tif (of->f_state != SMB_OFILE_STATE_OPEN) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (B_FALSE);\n\t}\n\tof->f_refcnt++;\n\n\tmutex_exit(&of->f_mutex);\n\treturn (B_TRUE);\n}\n\n/*\n * Release a reference on a file.  If the reference count falls to\n * zero and the file has been closed, post the object for deletion.\n * Object deletion is deferred to avoid modifying a list while an\n * iteration may be in progress.\n */\nvoid\nsmb_ofile_release(smb_ofile_t *of)\n{\n\tSMB_OFILE_VALID(of);\n\n\tmutex_enter(&of->f_mutex);\n\tASSERT(of->f_refcnt);\n\tof->f_refcnt--;\n\tswitch (of->f_state) {\n\tcase SMB_OFILE_STATE_OPEN:\n\tcase SMB_OFILE_STATE_CLOSING:\n\t\tbreak;\n\n\tcase SMB_OFILE_STATE_CLOSED:\n\t\tif (of->f_refcnt == 0)\n\t\t\tsmb_tree_post_ofile(of->f_tree, of);\n\t\tbreak;\n\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n\tmutex_exit(&of->f_mutex);\n}\n\n/*\n * smb_ofile_request_complete\n *\n * During oplock acquisition, all other oplock requests on the node\n * are blocked until the acquire request completes and the response\n * is on the wire.\n * Call smb_oplock_broadcast to notify the node that the request\n * has completed.\n *\n * THIS MECHANISM RELIES ON THE FACT THAT THE OFILE IS NOT REMOVED\n * FROM THE SR UNTIL REQUEST COMPLETION (when the sr is destroyed)\n */\nvoid\nsmb_ofile_request_complete(smb_ofile_t *of)\n{\n\tSMB_OFILE_VALID(of);\n\n\tswitch (of->f_ftype) {\n\tcase SMB_FTYPE_DISK:\n\t\tASSERT(of->f_node);\n\t\tsmb_oplock_broadcast(of->f_node);\n\t\tbreak;\n\tcase SMB_FTYPE_MESG_PIPE:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/*\n * smb_ofile_lookup_by_fid\n *\n * Find the open file whose fid matches the one specified in the request.\n * If we can't find the fid or the shares (trees) don't match, we have a\n * bad fid.\n */\nsmb_ofile_t *\nsmb_ofile_lookup_by_fid(\n    smb_request_t\t*sr,\n    uint16_t\t\tfid)\n{\n\tsmb_tree_t\t*tree = sr->tid_tree;\n\tsmb_llist_t\t*of_list;\n\tsmb_ofile_t\t*of;\n\n\tASSERT(tree->t_magic == SMB_TREE_MAGIC);\n\n\tof_list = &tree->t_ofile_list;\n\n\tsmb_llist_enter(of_list, RW_READER);\n\tof = smb_llist_head(of_list);\n\twhile (of) {\n\t\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\t\tASSERT(of->f_tree == tree);\n\t\tif (of->f_fid == fid)\n\t\t\tbreak;\n\t\tof = smb_llist_next(of_list, of);\n\t}\n\tif (of == NULL)\n\t\tgoto out;\n\n\t/*\n\t * Only allow use of a given FID with the same UID that\n\t * was used to open it.  MS-CIFS 3.3.5.14\n\t */\n\tif (of->f_user != sr->uid_user) {\n\t\tof = NULL;\n\t\tgoto out;\n\t}\n\n\tmutex_enter(&of->f_mutex);\n\tif (of->f_state != SMB_OFILE_STATE_OPEN) {\n\t\tmutex_exit(&of->f_mutex);\n\t\tof = NULL;\n\t\tgoto out;\n\t}\n\tof->f_refcnt++;\n\tmutex_exit(&of->f_mutex);\n\nout:\n\tsmb_llist_exit(of_list);\n\treturn (of);\n}\n\n/*\n * smb_ofile_lookup_by_uniqid\n *\n * Find the open file whose uniqid matches the one specified in the request.\n */\nsmb_ofile_t *\nsmb_ofile_lookup_by_uniqid(smb_tree_t *tree, uint32_t uniqid)\n{\n\tsmb_llist_t\t*of_list;\n\tsmb_ofile_t\t*of;\n\n\tASSERT(tree->t_magic == SMB_TREE_MAGIC);\n\n\tof_list = &tree->t_ofile_list;\n\tsmb_llist_enter(of_list, RW_READER);\n\tof = smb_llist_head(of_list);\n\n\twhile (of) {\n\t\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\t\tASSERT(of->f_tree == tree);\n\n\t\tif (of->f_uniqid == uniqid) {\n\t\t\tif (smb_ofile_hold(of)) {\n\t\t\t\tsmb_llist_exit(of_list);\n\t\t\t\treturn (of);\n\t\t\t}\n\t\t}\n\n\t\tof = smb_llist_next(of_list, of);\n\t}\n\n\tsmb_llist_exit(of_list);\n\treturn (NULL);\n}\n\n/*\n * Disallow NetFileClose on certain ofiles to avoid side-effects.\n * Closing a tree root is not allowed: use NetSessionDel or NetShareDel.\n * Closing SRVSVC connections is not allowed because this NetFileClose\n * request may depend on this ofile.\n */\nboolean_t\nsmb_ofile_disallow_fclose(smb_ofile_t *of)\n{\n\tASSERT(of);\n\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\tASSERT(of->f_refcnt);\n\n\tswitch (of->f_ftype) {\n\tcase SMB_FTYPE_DISK:\n\t\tASSERT(of->f_tree);\n\t\treturn (of->f_node == of->f_tree->t_snode);\n\n\tcase SMB_FTYPE_MESG_PIPE:\n\t\tASSERT(of->f_pipe);\n\t\tif (smb_strcasecmp(of->f_pipe->p_name, \"SRVSVC\", 0) == 0)\n\t\t\treturn (B_TRUE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn (B_FALSE);\n}\n\n/*\n * smb_ofile_set_flags\n *\n * Return value:\n *\n *\tCurrent flags value\n *\n */\nvoid\nsmb_ofile_set_flags(\n    smb_ofile_t\t\t*of,\n    uint32_t\t\tflags)\n{\n\tASSERT(of);\n\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\tASSERT(of->f_refcnt);\n\n\tmutex_enter(&of->f_mutex);\n\tof->f_flags |= flags;\n\tmutex_exit(&of->f_mutex);\n}\n\n/*\n * smb_ofile_seek\n *\n * Return value:\n *\n *\t0\t\tSuccess\n *\tEINVAL\t\tUnknown mode\n *\tEOVERFLOW\toffset too big\n *\n */\nint\nsmb_ofile_seek(\n    smb_ofile_t\t\t*of,\n    ushort_t\t\tmode,\n    int32_t\t\toff,\n    uint32_t\t\t*retoff)\n{\n\tu_offset_t\tnewoff = 0;\n\tint\t\trc = 0;\n\tsmb_attr_t\tattr;\n\n\tASSERT(of);\n\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\tASSERT(of->f_refcnt);\n\n\tmutex_enter(&of->f_mutex);\n\tswitch (mode) {\n\tcase SMB_SEEK_SET:\n\t\tif (off < 0)\n\t\t\tnewoff = 0;\n\t\telse\n\t\t\tnewoff = (u_offset_t)off;\n\t\tbreak;\n\n\tcase SMB_SEEK_CUR:\n\t\tif (off < 0 && (-off) > of->f_seek_pos)\n\t\t\tnewoff = 0;\n\t\telse\n\t\t\tnewoff = of->f_seek_pos + (u_offset_t)off;\n\t\tbreak;\n\n\tcase SMB_SEEK_END:\n\t\tbzero(&attr, sizeof (smb_attr_t));\n\t\tattr.sa_mask |= SMB_AT_SIZE;\n\t\trc = smb_fsop_getattr(NULL, zone_kcred(), of->f_node, &attr);\n\t\tif (rc != 0) {\n\t\t\tmutex_exit(&of->f_mutex);\n\t\t\treturn (rc);\n\t\t}\n\t\tif (off < 0 && (-off) > attr.sa_vattr.va_size)\n\t\t\tnewoff = 0;\n\t\telse\n\t\t\tnewoff = attr.sa_vattr.va_size + (u_offset_t)off;\n\t\tbreak;\n\n\tdefault:\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (EINVAL);\n\t}\n\n\t/*\n\t * See comments at the beginning of smb_seek.c.\n\t * If the offset is greater than UINT_MAX, we will return an error.\n\t */\n\n\tif (newoff > UINT_MAX) {\n\t\trc = EOVERFLOW;\n\t} else {\n\t\tof->f_seek_pos = newoff;\n\t\t*retoff = (uint32_t)newoff;\n\t}\n\tmutex_exit(&of->f_mutex);\n\treturn (rc);\n}\n\n/*\n * smb_ofile_flush\n *\n * If writes on this file are not synchronous, flush it using the NFSv3\n * commit interface.\n *\n * XXX - todo: Flush named pipe should drain writes.\n */\nvoid\nsmb_ofile_flush(struct smb_request *sr, struct smb_ofile *of)\n{\n\tswitch (of->f_ftype) {\n\tcase SMB_FTYPE_DISK:\n\t\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/*\n * smb_ofile_is_open\n */\nboolean_t\nsmb_ofile_is_open(smb_ofile_t *of)\n{\n\tboolean_t\trc;\n\n\tSMB_OFILE_VALID(of);\n\n\tmutex_enter(&of->f_mutex);\n\trc = smb_ofile_is_open_locked(of);\n\tmutex_exit(&of->f_mutex);\n\treturn (rc);\n}\n\n/* *************************** Static Functions ***************************** */\n\n/*\n * Determine whether or not an ofile is open.\n * This function must be called with the mutex held.\n */\nstatic boolean_t\nsmb_ofile_is_open_locked(smb_ofile_t *of)\n{\n\tswitch (of->f_state) {\n\tcase SMB_OFILE_STATE_OPEN:\n\t\treturn (B_TRUE);\n\n\tcase SMB_OFILE_STATE_CLOSING:\n\tcase SMB_OFILE_STATE_CLOSED:\n\t\treturn (B_FALSE);\n\n\tdefault:\n\t\tASSERT(0);\n\t\treturn (B_FALSE);\n\t}\n}\n\n/*\n * This function closes the file passed in (if appropriate) and returns the\n * next open file in the list of open files of the tree of the open file passed\n * in. It requires that the list of open files of the tree be entered in\n * RW_READER mode before being called.\n */\nstatic smb_ofile_t *\nsmb_ofile_close_and_next(smb_ofile_t *of)\n{\n\tsmb_ofile_t\t*next_of;\n\tsmb_tree_t\t*tree;\n\n\tASSERT(of);\n\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\n\tmutex_enter(&of->f_mutex);\n\tswitch (of->f_state) {\n\tcase SMB_OFILE_STATE_OPEN:\n\t\t/* The file is still open. */\n\t\tof->f_refcnt++;\n\t\tASSERT(of->f_refcnt);\n\t\ttree = of->f_tree;\n\t\tmutex_exit(&of->f_mutex);\n\t\tsmb_llist_exit(&of->f_tree->t_ofile_list);\n\t\tsmb_ofile_close(of, 0);\n\t\tsmb_ofile_release(of);\n\t\tsmb_llist_enter(&tree->t_ofile_list, RW_READER);\n\t\tnext_of = smb_llist_head(&tree->t_ofile_list);\n\t\tbreak;\n\tcase SMB_OFILE_STATE_CLOSING:\n\tcase SMB_OFILE_STATE_CLOSED:\n\t\t/*\n\t\t * The ofile exists but is closed or\n\t\t * in the process being closed.\n\t\t */\n\t\tmutex_exit(&of->f_mutex);\n\t\tnext_of = smb_llist_next(&of->f_tree->t_ofile_list, of);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tmutex_exit(&of->f_mutex);\n\t\tnext_of = smb_llist_next(&of->f_tree->t_ofile_list, of);\n\t\tbreak;\n\t}\n\treturn (next_of);\n}\n\n/*\n * Delete an ofile.\n *\n * Remove the ofile from the tree list before freeing resources\n * associated with the ofile.\n */\nvoid\nsmb_ofile_delete(void *arg)\n{\n\tsmb_tree_t\t*tree;\n\tsmb_ofile_t\t*of = (smb_ofile_t *)arg;\n\n\tSMB_OFILE_VALID(of);\n\tASSERT(of->f_refcnt == 0);\n\tASSERT(of->f_state == SMB_OFILE_STATE_CLOSED);\n\tASSERT(!SMB_OFILE_OPLOCK_GRANTED(of));\n\n\ttree = of->f_tree;\n\tsmb_llist_enter(&tree->t_ofile_list, RW_WRITER);\n\tsmb_llist_remove(&tree->t_ofile_list, of);\n\tsmb_idpool_free(&tree->t_fid_pool, of->f_fid);\n\tatomic_dec_32(&tree->t_session->s_file_cnt);\n\tsmb_llist_exit(&tree->t_ofile_list);\n\n\tmutex_enter(&of->f_mutex);\n\tmutex_exit(&of->f_mutex);\n\n\tswitch (of->f_ftype) {\n\tcase SMB_FTYPE_BYTE_PIPE:\n\tcase SMB_FTYPE_MESG_PIPE:\n\t\tsmb_opipe_dealloc(of->f_pipe);\n\t\tof->f_pipe = NULL;\n\t\tbreak;\n\tcase SMB_FTYPE_DISK:\n\t\tif (of->f_odir != NULL)\n\t\t\tsmb_odir_release(of->f_odir);\n\t\tsmb_node_rem_ofile(of->f_node, of);\n\t\tsmb_node_release(of->f_node);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(!\"f_ftype\");\n\t\tbreak;\n\t}\n\n\tof->f_magic = (uint32_t)~SMB_OFILE_MAGIC;\n\tmutex_destroy(&of->f_mutex);\n\tcrfree(of->f_cr);\n\tsmb_user_release(of->f_user);\n\tkmem_cache_free(smb_cache_ofile, of);\n}\n\n/*\n * smb_ofile_access\n *\n * This function will check to see if the access requested is granted.\n * Returns NT status codes.\n */\nuint32_t\nsmb_ofile_access(smb_ofile_t *of, cred_t *cr, uint32_t access)\n{\n\n\tif ((of == NULL) || (cr == zone_kcred()))\n\t\treturn (NT_STATUS_SUCCESS);\n\n\t/*\n\t * If the request is for something\n\t * I don't grant it is an error\n\t */\n\tif (~(of->f_granted_access) & access) {\n\t\tif (!(of->f_granted_access & ACCESS_SYSTEM_SECURITY) &&\n\t\t    (access & ACCESS_SYSTEM_SECURITY)) {\n\t\t\treturn (NT_STATUS_PRIVILEGE_NOT_HELD);\n\t\t}\n\t\treturn (NT_STATUS_ACCESS_DENIED);\n\t}\n\n\treturn (NT_STATUS_SUCCESS);\n}\n\n/*\n * smb_ofile_share_check\n *\n * Check if ofile was opened with share access NONE (0).\n * Returns: B_TRUE  - share access non-zero\n *          B_FALSE - share access NONE\n */\nboolean_t\nsmb_ofile_share_check(smb_ofile_t *of)\n{\n\treturn (!SMB_DENY_ALL(of->f_share_access));\n}\n\n/*\n * check file sharing rules for current open request\n * against existing open instances of the same file\n *\n * Returns NT_STATUS_SHARING_VIOLATION if there is any\n * sharing conflict, otherwise returns NT_STATUS_SUCCESS.\n */\nuint32_t\nsmb_ofile_open_check(smb_ofile_t *of, uint32_t desired_access,\n    uint32_t share_access)\n{\n\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\n\tmutex_enter(&of->f_mutex);\n\n\tif (of->f_state != SMB_OFILE_STATE_OPEN) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_INVALID_HANDLE);\n\t}\n\n\t/* if it's just meta data */\n\tif ((of->f_granted_access & FILE_DATA_ALL) == 0) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_SUCCESS);\n\t}\n\n\t/*\n\t * Check requested share access against the\n\t * open granted (desired) access\n\t */\n\tif (SMB_DENY_DELETE(share_access) && (of->f_granted_access & DELETE)) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_SHARING_VIOLATION);\n\t}\n\n\tif (SMB_DENY_READ(share_access) &&\n\t    (of->f_granted_access & (FILE_READ_DATA | FILE_EXECUTE))) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_SHARING_VIOLATION);\n\t}\n\n\tif (SMB_DENY_WRITE(share_access) &&\n\t    (of->f_granted_access & (FILE_WRITE_DATA | FILE_APPEND_DATA))) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_SHARING_VIOLATION);\n\t}\n\n\t/* check requested desired access against the open share access */\n\tif (SMB_DENY_DELETE(of->f_share_access) && (desired_access & DELETE)) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_SHARING_VIOLATION);\n\t}\n\n\tif (SMB_DENY_READ(of->f_share_access) &&\n\t    (desired_access & (FILE_READ_DATA | FILE_EXECUTE))) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_SHARING_VIOLATION);\n\t}\n\n\tif (SMB_DENY_WRITE(of->f_share_access) &&\n\t    (desired_access & (FILE_WRITE_DATA | FILE_APPEND_DATA))) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_SHARING_VIOLATION);\n\t}\n\n\tmutex_exit(&of->f_mutex);\n\treturn (NT_STATUS_SUCCESS);\n}\n\n/*\n * smb_ofile_rename_check\n *\n * An open file can be renamed if\n *\n *  1. isn't opened for data writing or deleting\n *\n *  2. Opened with \"Deny Delete\" share mode\n *         But not opened for data reading or executing\n *         (opened for accessing meta data)\n */\n\nuint32_t\nsmb_ofile_rename_check(smb_ofile_t *of)\n{\n\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\n\tmutex_enter(&of->f_mutex);\n\n\tif (of->f_state != SMB_OFILE_STATE_OPEN) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_INVALID_HANDLE);\n\t}\n\n\tif (of->f_granted_access &\n\t    (FILE_WRITE_DATA | FILE_APPEND_DATA | DELETE)) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_SHARING_VIOLATION);\n\t}\n\n\tif ((of->f_share_access & FILE_SHARE_DELETE) == 0) {\n\t\tif (of->f_granted_access &\n\t\t    (FILE_READ_DATA | FILE_EXECUTE)) {\n\t\t\tmutex_exit(&of->f_mutex);\n\t\t\treturn (NT_STATUS_SHARING_VIOLATION);\n\t\t}\n\t}\n\n\tmutex_exit(&of->f_mutex);\n\treturn (NT_STATUS_SUCCESS);\n}\n\n/*\n * smb_ofile_delete_check\n *\n * An open file can be deleted only if opened for\n * accessing meta data. Share modes aren't important\n * in this case.\n *\n * NOTE: there is another mechanism for deleting an\n * open file that NT clients usually use.\n * That's setting \"Delete on close\" flag for an open\n * file.  In this way the file will be deleted after\n * last close. This flag can be set by SmbTrans2SetFileInfo\n * with FILE_DISPOSITION_INFO information level.\n * For setting this flag, the file should be opened by\n * DELETE access in the FID that is passed in the Trans2\n * request.\n */\n\nuint32_t\nsmb_ofile_delete_check(smb_ofile_t *of)\n{\n\tASSERT(of->f_magic == SMB_OFILE_MAGIC);\n\n\tmutex_enter(&of->f_mutex);\n\n\tif (of->f_state != SMB_OFILE_STATE_OPEN) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_INVALID_HANDLE);\n\t}\n\n\tif (of->f_granted_access &\n\t    (FILE_READ_DATA | FILE_WRITE_DATA |\n\t    FILE_APPEND_DATA | FILE_EXECUTE | DELETE)) {\n\t\tmutex_exit(&of->f_mutex);\n\t\treturn (NT_STATUS_SHARING_VIOLATION);\n\t}\n\n\tmutex_exit(&of->f_mutex);\n\treturn (NT_STATUS_SUCCESS);\n}\n\ncred_t *\nsmb_ofile_getcred(smb_ofile_t *of)\n{\n\treturn (of->f_cr);\n}\n\n/*\n * smb_ofile_set_delete_on_close\n *\n * Set the DeleteOnClose flag on the smb file. When the file is closed,\n * the flag will be transferred to the smb node, which will commit the\n * delete operation and inhibit subsequent open requests.\n *\n * When DeleteOnClose is set on an smb_node, the common open code will\n * reject subsequent open requests for the file. Observation of Windows\n * 2000 indicates that subsequent opens should be allowed (assuming\n * there would be no sharing violation) until the file is closed using\n * the fid on which the DeleteOnClose was requested.\n */\nvoid\nsmb_ofile_set_delete_on_close(smb_ofile_t *of)\n{\n\tmutex_enter(&of->f_mutex);\n\tof->f_flags |= SMB_OFLAGS_SET_DELETE_ON_CLOSE;\n\tmutex_exit(&of->f_mutex);\n}\n\n/*\n * Encode open file information into a buffer; needed in user space to\n * support RPC requests.\n */\nstatic int\nsmb_ofile_netinfo_encode(smb_ofile_t *of, uint8_t *buf, size_t buflen,\n    uint32_t *nbytes)\n{\n\tsmb_netfileinfo_t\tfi;\n\tint\t\t\trc;\n\n\trc = smb_ofile_netinfo_init(of, &fi);\n\tif (rc == 0) {\n\t\trc = smb_netfileinfo_encode(&fi, buf, buflen, nbytes);\n\t\tsmb_ofile_netinfo_fini(&fi);\n\t}\n\n\treturn (rc);\n}\n\nstatic int\nsmb_ofile_netinfo_init(smb_ofile_t *of, smb_netfileinfo_t *fi)\n{\n\tsmb_user_t\t*user;\n\tsmb_tree_t\t*tree;\n\tsmb_node_t\t*node;\n\tchar\t\t*path;\n\tchar\t\t*buf;\n\tint\t\trc;\n\n\tASSERT(of);\n\tuser = of->f_user;\n\ttree = of->f_tree;\n\tASSERT(user);\n\tASSERT(tree);\n\n\tbuf = kmem_zalloc(MAXPATHLEN, KM_SLEEP);\n\n\tswitch (of->f_ftype) {\n\tcase SMB_FTYPE_DISK:\n\t\tnode = of->f_node;\n\t\tASSERT(node);\n\n\t\tfi->fi_permissions = of->f_granted_access;\n\t\tfi->fi_numlocks = smb_lock_get_lock_count(node, of);\n\n\t\tpath = kmem_zalloc(MAXPATHLEN, KM_SLEEP);\n\n\t\tif (node != tree->t_snode) {\n\t\t\trc = smb_node_getshrpath(node, tree, path, MAXPATHLEN);\n\t\t\tif (rc != 0)\n\t\t\t\t(void) strlcpy(path, node->od_name, MAXPATHLEN);\n\t\t}\n\n\t\t(void) snprintf(buf, MAXPATHLEN, \"%s:%s\", tree->t_sharename,\n\t\t    path);\n\t\tkmem_free(path, MAXPATHLEN);\n\t\tbreak;\n\n\tcase SMB_FTYPE_MESG_PIPE:\n\t\tASSERT(of->f_pipe);\n\n\t\tfi->fi_permissions = FILE_READ_DATA | FILE_WRITE_DATA |\n\t\t    FILE_EXECUTE;\n\t\tfi->fi_numlocks = 0;\n\t\t(void) snprintf(buf, MAXPATHLEN, \"\\\\PIPE\\\\%s\",\n\t\t    of->f_pipe->p_name);\n\t\tbreak;\n\n\tdefault:\n\t\tkmem_free(buf, MAXPATHLEN);\n\t\treturn (-1);\n\t}\n\n\tfi->fi_fid = of->f_fid;\n\tfi->fi_uniqid = of->f_uniqid;\n\tfi->fi_pathlen = strlen(buf) + 1;\n\tfi->fi_path = smb_mem_strdup(buf);\n\tkmem_free(buf, MAXPATHLEN);\n\n\tfi->fi_namelen = user->u_domain_len + user->u_name_len + 2;\n\tfi->fi_username = kmem_alloc(fi->fi_namelen, KM_SLEEP);\n\t(void) snprintf(fi->fi_username, fi->fi_namelen, \"%s\\\\%s\",\n\t    user->u_domain, user->u_name);\n\treturn (0);\n}\n\nstatic void\nsmb_ofile_netinfo_fini(smb_netfileinfo_t *fi)\n{\n\tif (fi == NULL)\n\t\treturn;\n\n\tif (fi->fi_path)\n\t\tsmb_mem_free(fi->fi_path);\n\tif (fi->fi_username)\n\t\tkmem_free(fi->fi_username, fi->fi_namelen);\n\n\tbzero(fi, sizeof (smb_netfileinfo_t));\n}\n\n/*\n * A query of user and group quotas may span multiple requests.\n * f_quota_resume is used to determine where the query should\n * be resumed, in a subsequent request. f_quota_resume contains\n * the SID of the last quota entry returned to the client.\n */\nvoid\nsmb_ofile_set_quota_resume(smb_ofile_t *ofile, char *resume)\n{\n\tASSERT(ofile);\n\tmutex_enter(&ofile->f_mutex);\n\tif (resume == NULL)\n\t\tbzero(ofile->f_quota_resume, SMB_SID_STRSZ);\n\telse\n\t\t(void) strlcpy(ofile->f_quota_resume, resume, SMB_SID_STRSZ);\n\tmutex_exit(&ofile->f_mutex);\n}\n\nvoid\nsmb_ofile_get_quota_resume(smb_ofile_t *ofile, char *buf, int bufsize)\n{\n\tASSERT(ofile);\n\tmutex_enter(&ofile->f_mutex);\n\t(void) strlcpy(buf, ofile->f_quota_resume, bufsize);\n\tmutex_exit(&ofile->f_mutex);\n}\n", "/*\n * CDDL HEADER START\n *\n * The contents of this file are subject to the terms of the\n * Common Development and Distribution License (the \"License\").\n * You may not use this file except in compliance with the License.\n *\n * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE\n * or http://www.opensolaris.org/os/licensing.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL HEADER in each\n * file and include the License file at usr/src/OPENSOLARIS.LICENSE.\n * If applicable, add the following below this CDDL HEADER, with the\n * fields enclosed by brackets \"[]\" replaced with your own identifying\n * information: Portions Copyright [yyyy] [name of copyright owner]\n *\n * CDDL HEADER END\n */\n\n/*\n * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.\n * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.\n * Copyright 2016 Syneto S.R.L.  All rights reserved.\n */\n\n/*\n * Function prototypes for the SMB module.\n */\n\n#ifndef _SMB_KPROTO_H_\n#define\t_SMB_KPROTO_H_\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/systm.h>\n#include <sys/debug.h>\n#include <sys/kmem.h>\n#include <sys/socket.h>\n#include <sys/ksocket.h>\n#include <sys/cred.h>\n#include <sys/nbmlock.h>\n#include <sys/sunddi.h>\n#include <sys/atomic.h>\n#include <smbsrv/smb.h>\n#include <smbsrv/string.h>\n#include <smbsrv/smb_vops.h>\n#include <smbsrv/smb_xdr.h>\n#include <smbsrv/smb_token.h>\n#include <smbsrv/smb_ktypes.h>\n#include <smbsrv/smb_ioctl.h>\n\n/*\n * DTrace SDT probes have different signatures in userland than they do in\n * kernel.  If we're compiling for user mode (libfksmbsrv) define them as\n * either no-op (for the SMB dtrace provider) or libfksmbsrv functions for\n * the other SDT probe sites.\n */\n#ifndef\t_KERNEL\n\nextern void smb_dtrace1(const char *f, const char *n,\n\t\t\tconst char *t1, long v1);\nextern void smb_dtrace2(const char *f, const char *n,\n\t\t\tconst char *t1, long v1,\n\t\t\tconst char *t2, long v2);\nextern void smb_dtrace3(const char *f, const char *n,\n\t\t\tconst char *t1, long v1,\n\t\t\tconst char *t2, long v2,\n\t\t\tconst char *t3, long v3);\n\n/*\n * These are for the SMB dtrace proivder, which for a user-mode build\n * are largely redundant with the fbt probes so make these no-ops.\n */\n#undef\tDTRACE_SMB_1\n#define\tDTRACE_SMB_1(n, a, b)\t\t\t((void)b)\n#undef\tDTRACE_SMB_2\n#define\tDTRACE_SMB_2(n, a, b, c, d)\t\t((void)b, (void)d)\n\n/*\n * These are for the other (specialized) dtrace SDT probes sprinkled\n * through the smbsrv code.  In libfksmbsrv map these to functions.\n */\n\n#undef\tDTRACE_PROBE1\n#define\tDTRACE_PROBE1(n, a, b) \\\n\tsmb_dtrace1(__func__, #n, #a, (long)b)\n\n#undef\tDTRACE_PROBE2\n#define\tDTRACE_PROBE2(n, a, b, c, d) \\\n\tsmb_dtrace2(__func__, #n, #a, (long)b, #c, (long)d)\n\n#undef\tDTRACE_PROBE3\n#define\tDTRACE_PROBE3(n, a, b, c, d, e, f) \\\n\tsmb_dtrace3(__func__, #n, #a, (long)b, #c, (long)d, #e, (long)f)\n\n#endif\t/* _KERNEL */\n\nextern\tint smb_maxbufsize;\nextern\tint smb_flush_required;\nextern\tint smb_dirsymlink_enable;\nextern\tint smb_oplock_levelII;\nextern\tint smb_oplock_timeout;\nextern\tint smb_oplock_min_timeout;\nextern\tint smb_shortnames;\nextern\tint smb_sign_debug;\nextern\tint smb_raw_mode;\nextern\tuint_t smb_audit_flags;\nextern\tint smb_ssetup_threshold;\nextern\tint smb_tcon_threshold;\nextern\tint smb_opipe_threshold;\nextern\tint smb_ssetup_timeout;\nextern\tint smb_tcon_timeout;\nextern\tint smb_opipe_timeout;\nextern const uint32_t smb_vop_dosattr_settable;\n\n/* Thread priorities - see smb_init.c */\nextern\tint smbsrv_base_pri;\nextern\tint smbsrv_listen_pri;\nextern\tint smbsrv_receive_pri;\nextern\tint smbsrv_worker_pri;\nextern\tint smbsrv_notify_pri;\nextern\tint smbsrv_timer_pri;\n\nextern\tkmem_cache_t\t\t*smb_cache_request;\nextern\tkmem_cache_t\t\t*smb_cache_session;\nextern\tkmem_cache_t\t\t*smb_cache_user;\nextern\tkmem_cache_t\t\t*smb_cache_tree;\nextern\tkmem_cache_t\t\t*smb_cache_ofile;\nextern\tkmem_cache_t\t\t*smb_cache_odir;\nextern\tkmem_cache_t\t\t*smb_cache_opipe;\nextern\tkmem_cache_t\t\t*smb_cache_event;\n\nextern\tkmem_cache_t\t\t*smb_kshare_cache_vfs;\n\ntime_t smb_get_boottime(void);\nint smb_server_lookup(smb_server_t **);\nvoid smb_server_release(smb_server_t *);\n\n/*\n * SMB request handers called from the dispatcher.  Each SMB request\n * is handled in three phases: pre, com (command) and post.\n *\n * The pre-handler is primarily to set things up for the DTrace start\n * probe.  Typically, the SMB request is unmarshalled so that request\n * specific context can be traced.  This is also a useful place to\n * allocate memory that will be used throughout the processing of the\n * command.\n *\n * The com-handler performs the requested operation: request validation,\n * bulk (write) incoming data decode, implementation of the appropriate\n * algorithm and transmission of a response (as appropriate).\n *\n * The post-handler is always called, regardless of success or failure\n * of the pre or com functions, to trigger the DTrace done probe and\n * deallocate memory allocated in the pre-handler.\n */\n#define\tSMB_SDT_OPS(NAME)\t\\\n\tsmb_pre_##NAME,\t\t\\\n\tsmb_com_##NAME,\t\t\\\n\tsmb_post_##NAME\n\n#define\tSMB_COM_DECL(NAME)\t\t\t\t\\\n\tsmb_sdrc_t smb_pre_##NAME(smb_request_t *);\t\\\n\tsmb_sdrc_t smb_com_##NAME(smb_request_t *);\t\\\n\tvoid smb_post_##NAME(smb_request_t *)\n\nSMB_COM_DECL(check_directory);\nSMB_COM_DECL(close);\nSMB_COM_DECL(close_and_tree_disconnect);\nSMB_COM_DECL(close_print_file);\nSMB_COM_DECL(create);\nSMB_COM_DECL(create_directory);\nSMB_COM_DECL(create_new);\nSMB_COM_DECL(create_temporary);\nSMB_COM_DECL(delete);\nSMB_COM_DECL(delete_directory);\nSMB_COM_DECL(echo);\nSMB_COM_DECL(find);\nSMB_COM_DECL(find_close);\nSMB_COM_DECL(find_close2);\nSMB_COM_DECL(find_unique);\nSMB_COM_DECL(flush);\nSMB_COM_DECL(get_print_queue);\nSMB_COM_DECL(invalid);\nSMB_COM_DECL(ioctl);\nSMB_COM_DECL(lock_and_read);\nSMB_COM_DECL(lock_byte_range);\nSMB_COM_DECL(locking_andx);\nSMB_COM_DECL(logoff_andx);\nSMB_COM_DECL(negotiate);\nSMB_COM_DECL(nt_cancel);\nSMB_COM_DECL(nt_create_andx);\nSMB_COM_DECL(nt_rename);\nSMB_COM_DECL(nt_transact);\nSMB_COM_DECL(nt_transact_secondary);\nSMB_COM_DECL(open);\nSMB_COM_DECL(open_andx);\nSMB_COM_DECL(open_print_file);\nSMB_COM_DECL(process_exit);\nSMB_COM_DECL(query_information);\nSMB_COM_DECL(query_information2);\nSMB_COM_DECL(query_information_disk);\nSMB_COM_DECL(read);\nSMB_COM_DECL(read_andx);\nSMB_COM_DECL(read_raw);\nSMB_COM_DECL(rename);\nSMB_COM_DECL(search);\nSMB_COM_DECL(seek);\nSMB_COM_DECL(session_setup_andx);\nSMB_COM_DECL(set_information);\nSMB_COM_DECL(set_information2);\nSMB_COM_DECL(transaction);\nSMB_COM_DECL(transaction2);\nSMB_COM_DECL(transaction2_secondary);\nSMB_COM_DECL(transaction_secondary);\nSMB_COM_DECL(tree_connect);\nSMB_COM_DECL(tree_connect_andx);\nSMB_COM_DECL(tree_disconnect);\nSMB_COM_DECL(unlock_byte_range);\nSMB_COM_DECL(write);\nSMB_COM_DECL(write_and_close);\nSMB_COM_DECL(write_and_unlock);\nSMB_COM_DECL(write_andx);\nSMB_COM_DECL(write_print_file);\nSMB_COM_DECL(write_raw);\n\n#define\tSMB_NT_TRANSACT_DECL(NAME)\t\t\t\t\\\n\tsmb_sdrc_t smb_pre_##NAME(smb_request_t *, smb_xa_t *);\t\\\n\tsmb_sdrc_t smb_##NAME(smb_request_t *, smb_xa_t *);\t\\\n\tvoid smb_post_##NAME(smb_request_t *, smb_xa_t *)\n\nSMB_NT_TRANSACT_DECL(nt_transact_create);\n\nsmb_sdrc_t smb_nt_transact_notify_change(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_nt_transact_query_security_info(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_nt_transact_set_security_info(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_nt_transact_ioctl(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_nt_transact_rename(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_nt_transact_query_quota(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_nt_transact_set_quota(smb_request_t *, smb_xa_t *);\n\nsmb_sdrc_t smb_com_trans2_open2(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_com_trans2_create_directory(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_com_trans2_find_first2(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_com_trans2_find_next2(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_com_trans2_query_fs_information(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_com_trans2_set_fs_information(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_com_trans2_query_path_information(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_com_trans2_query_file_information(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_com_trans2_set_path_information(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_com_trans2_set_file_information(smb_request_t *, smb_xa_t *);\nsmb_sdrc_t smb_com_trans2_get_dfs_referral(smb_request_t *, smb_xa_t *);\n\nuint32_t smb_query_stream_info(smb_request_t *, mbuf_chain_t *,\n    smb_queryinfo_t *);\nint smb_fssize(smb_request_t *, smb_fssize_t *);\n\n/* smb_quota.c */\nuint32_t smb_quota_query_user_quota(smb_request_t *, uid_t, smb_quota_t *);\nint smb_quota_query(smb_server_t *, smb_quota_query_t *,\n    smb_quota_response_t *);\nint smb_quota_set(smb_server_t *, smb_quota_set_t *, uint32_t *);\nuint32_t smb_quota_init_sids(mbuf_chain_t *, smb_quota_query_t *,\n    smb_ofile_t *);\nuint32_t smb_quota_decode_sids(mbuf_chain_t *, list_t *);\nvoid smb_quota_free_sids(smb_quota_query_t *);\nvoid smb_quota_max_quota(mbuf_chain_t *, smb_quota_query_t *);\nuint32_t smb_quota_decode_quotas(mbuf_chain_t *, list_t *);\nuint32_t smb_quota_encode_quotas(mbuf_chain_t *, smb_quota_query_t *,\n    smb_quota_response_t *, smb_ofile_t *);\nvoid smb_quota_free_quotas(list_t *);\n\nvoid smb_query_shortname(smb_node_t *, smb_queryinfo_t *);\n\nuint32_t smb_dfs_get_referrals(smb_request_t *, smb_fsctl_t *);\n\nint smb1_newrq_negotiate(smb_request_t *);\nsmb_sdrc_t smb1_negotiate_smb2(smb_request_t *sr);\n\nuint32_t smb_set_basic_info(smb_request_t *, smb_setinfo_t *);\nuint32_t smb_set_eof_info(smb_request_t *, smb_setinfo_t *);\nuint32_t smb_set_alloc_info(smb_request_t *, smb_setinfo_t *);\nuint32_t smb_set_disposition_info(smb_request_t *, smb_setinfo_t *);\n\nuint32_t smb_setinfo_rename(smb_request_t *, smb_node_t *, char *, int);\nuint32_t smb_common_rename(smb_request_t *, smb_fqi_t *, smb_fqi_t *);\n\nuint32_t smb_setinfo_link(smb_request_t *, smb_node_t *, char *, int);\nuint32_t smb_make_link(smb_request_t *, smb_fqi_t *, smb_fqi_t *);\n\n\n/*\n * Logging functions\n */\nvoid smb_log_flush(void);\nvoid smb_correct_keep_alive_values(uint32_t new_keep_alive);\nvoid smb_close_all_connections(void);\n\nint smb_net_id(uint32_t);\n\n/*\n * oplock functions - node operations\n */\nvoid smb_oplock_acquire(smb_request_t *sr, smb_node_t *, smb_ofile_t *);\nvoid smb_oplock_release(smb_node_t *, smb_ofile_t *);\nint smb_oplock_break(smb_request_t *, smb_node_t *, uint32_t);\nvoid smb_oplock_break_levelII(smb_node_t *);\nvoid smb_oplock_ack(smb_node_t *, smb_ofile_t *, uint8_t);\nvoid smb_oplock_broadcast(smb_node_t *);\n\nvoid smb1_oplock_break_notification(smb_request_t *, uint8_t);\nvoid smb2_oplock_break_notification(smb_request_t *, uint8_t);\n\n/*\n * range lock functions - node operations\n */\nuint32_t smb_lock_get_lock_count(smb_node_t *, smb_ofile_t *);\nuint32_t smb_unlock_range(smb_request_t *, smb_node_t *,\n    uint64_t, uint64_t);\nuint32_t smb_lock_range(smb_request_t *, uint64_t, uint64_t, uint32_t,\n    uint32_t locktype);\nvoid smb_lock_range_error(smb_request_t *, uint32_t);\nDWORD smb_nbl_conflict(smb_node_t *, uint64_t, uint64_t, nbl_op_t);\n\nvoid smb_mangle(const char *, ino64_t, char *, size_t);\nint smb_unmangle(smb_node_t *, char *, char *, int, uint32_t);\nboolean_t smb_needs_mangled(const char *);\nboolean_t smb_maybe_mangled(char *);\nboolean_t smb_is_reserved_dos_name(const char *);\nboolean_t smb_is_invalid_filename(const char *);\n\nvoid smbsr_cleanup(smb_request_t *sr);\n\nint smbsr_connect_tree(smb_request_t *);\n\nint smb_common_create_directory(smb_request_t *);\n\nvoid\tsmb_convert_wildcards(char *);\nboolean_t smb_contains_wildcards(const char *);\nint\tsmb_ascii_or_unicode_strlen(smb_request_t *, char *);\nint\tsmb_ascii_or_unicode_strlen_null(smb_request_t *, char *);\nint\tsmb_ascii_or_unicode_null_len(smb_request_t *);\n\nint\tsmb_search(smb_request_t *);\n\nuint32_t smb_common_create(smb_request_t *);\nuint32_t smb_common_open(smb_request_t *);\nint smb_common_write(smb_request_t *, smb_rw_param_t *);\n\nvoid smb_pathname_init(smb_request_t *, smb_pathname_t *, char *);\nboolean_t smb_pathname_validate(smb_request_t *, smb_pathname_t *);\nboolean_t smb_validate_dirname(smb_request_t *, smb_pathname_t *);\nboolean_t smb_validate_object_name(smb_request_t *, smb_pathname_t *);\nboolean_t smb_validate_stream_name(smb_request_t *, smb_pathname_t *);\nboolean_t smb_is_stream_name(char *);\nvoid smb_stream_parse_name(char *, char *, char *);\n\n\nuint32_t smb_omode_to_amask(uint32_t desired_access);\n\nvoid\tsshow_distribution_info(char *);\n\nuint32_t smb2sr_go_async(smb_request_t *sr,\n\tsmb_sdrc_t (*async_func)(smb_request_t *));\n\nvoid\tsmb_dispatch_stats_init(smb_server_t *);\nvoid\tsmb_dispatch_stats_fini(smb_server_t *);\nvoid\tsmb_dispatch_stats_update(smb_server_t *,\n\t\tsmb_kstat_req_t *, int, int);\n\nint\tsmb1sr_newrq(smb_request_t *);\nvoid\tsmb1sr_work(smb_request_t *);\n\nint\tsmbsr_encode_empty_result(smb_request_t *);\nvoid\tsmbsr_lookup_file(smb_request_t *);\nvoid\tsmbsr_release_file(smb_request_t *);\n\nint\tsmbsr_decode_vwv(smb_request_t *sr, const char *, ...);\nint\tsmbsr_decode_data(smb_request_t *sr, const char *, ...);\nboolean_t smbsr_decode_data_avail(smb_request_t *);\nint\tsmbsr_encode_result(smb_request_t *, int, int, const char *, ...);\nsmb_xa_t *smbsr_lookup_xa(smb_request_t *sr);\nvoid\tsmbsr_send_reply(smb_request_t *);\n\nuint32_t smb_errno2status(int);\nuint16_t smb_status2doserr(uint32_t);\nvoid\tsmbsr_map_errno(int, smb_error_t *);\nvoid\tsmbsr_set_error(smb_request_t *, smb_error_t *);\nvoid\tsmbsr_errno(smb_request_t *, int);\nvoid\tsmbsr_status(smb_request_t *, DWORD, uint16_t, uint16_t);\n#define\tsmbsr_error(SR, ST, CL, CO) \\\n\tsmbsr_status(SR, ST, CL, CO)\n#define\tsmbsr_warn(SR, ST, CL, CO) \\\n\tsmbsr_status(SR, ST, CL, CO)\nvoid\tsmbsr_status_smb2(smb_request_t *, DWORD);\n\nint\tclock_get_milli_uptime(void);\n\nint\tsmb_mbc_vencodef(mbuf_chain_t *, const char *, va_list);\nint\tsmb_mbc_vdecodef(mbuf_chain_t *, const char *, va_list);\nint\tsmb_mbc_decodef(mbuf_chain_t *, const char *, ...);\nint\tsmb_mbc_encodef(mbuf_chain_t *, const char *, ...);\nint\tsmb_mbc_peek(mbuf_chain_t *, int, const char *, ...);\nint\tsmb_mbc_poke(mbuf_chain_t *, int, const char *, ...);\nint\tsmb_mbc_put_mem(mbuf_chain_t *, void *, int);\nint\tsmb_mbc_copy(mbuf_chain_t *, const mbuf_chain_t *, int, int);\n\nvoid\tsmbsr_encode_header(smb_request_t *sr, int wct,\n\t\t    int bcc, const char *fmt, ...);\n\nint smb_lock_range_access(smb_request_t *, smb_node_t *,\n    uint64_t, uint64_t, boolean_t);\n\nvoid smb_encode_sd(mbuf_chain_t *, smb_sd_t *, uint32_t);\nvoid smb_encode_sid(mbuf_chain_t *, smb_sid_t *);\nsmb_sid_t *smb_decode_sid(mbuf_chain_t *, uint32_t);\nuint32_t smb_decode_sd(mbuf_chain_t *, smb_sd_t *);\n\nuint32_t smb_pad_align(uint32_t, uint32_t);\n\n/*\n * Socket functions\n */\nksocket_t smb_socreate(int domain, int type, int protocol);\nvoid smb_soshutdown(ksocket_t so);\nvoid smb_sodestroy(ksocket_t so);\nint smb_sorecv(ksocket_t so, void *msg, size_t len);\nvoid smb_net_txl_constructor(smb_txlst_t *);\nvoid smb_net_txl_destructor(smb_txlst_t *);\nint smb_net_send_uio(smb_session_t *, struct uio *);\n\n/*\n * SMB RPC interface\n */\nvoid smb_opipe_dealloc(smb_opipe_t *);\nint smb_opipe_open(smb_request_t *, uint32_t);\nvoid smb_opipe_close(smb_ofile_t *);\nint smb_opipe_read(smb_request_t *, struct uio *);\nint smb_opipe_write(smb_request_t *, struct uio *);\nint smb_opipe_getattr(smb_ofile_t *, smb_attr_t *);\nint smb_opipe_getname(smb_ofile_t *, char *, size_t);\nuint32_t smb_opipe_fsctl(smb_request_t *, smb_fsctl_t *);\n\nvoid smb_kdoor_init(smb_server_t *);\nvoid smb_kdoor_fini(smb_server_t *);\nint smb_kdoor_open(smb_server_t *, int);\nvoid smb_kdoor_close(smb_server_t *);\nint smb_kdoor_upcall(smb_server_t *, uint32_t,\n\tvoid *, xdrproc_t, void *, xdrproc_t);\nvoid fksmb_kdoor_open(smb_server_t *, void *);\n\n/*\n * SMB server functions (file smb_server.c)\n */\nint smb_server_get_count(void);\nint smb_server_g_init(void);\nvoid smb_server_g_fini(void);\nint smb_server_create(void);\nint smb_server_delete(void);\nint smb_server_configure(smb_ioc_cfg_t *);\nint smb_server_start(smb_ioc_start_t *);\nint smb_server_stop(void);\nboolean_t smb_server_is_stopping(smb_server_t *);\nvoid smb_server_cancel_event(smb_server_t *, uint32_t);\nint smb_server_notify_event(smb_ioc_event_t *);\nuint32_t smb_server_get_session_count(smb_server_t *);\nint smb_server_set_gmtoff(smb_ioc_gmt_t *);\nint smb_server_numopen(smb_ioc_opennum_t *);\nint smb_server_enum(smb_ioc_svcenum_t *);\nint smb_server_session_close(smb_ioc_session_t *);\nint smb_server_file_close(smb_ioc_fileid_t *);\nint smb_server_sharevp(smb_server_t *, const char *, vnode_t **);\nint smb_server_unshare(const char *);\n\nvoid smb_server_get_cfg(smb_server_t *, smb_kmod_cfg_t *);\n\nint smb_server_spooldoc(smb_ioc_spooldoc_t *);\nint smb_spool_add_doc(smb_tree_t *, smb_kspooldoc_t *);\nvoid smb_spool_add_fid(smb_server_t *, uint16_t);\n\nvoid smb_server_inc_nbt_sess(smb_server_t *);\nvoid smb_server_dec_nbt_sess(smb_server_t *);\nvoid smb_server_inc_tcp_sess(smb_server_t *);\nvoid smb_server_dec_tcp_sess(smb_server_t *);\nvoid smb_server_inc_users(smb_server_t *);\nvoid smb_server_dec_users(smb_server_t *);\nvoid smb_server_inc_trees(smb_server_t *);\nvoid smb_server_dec_trees(smb_server_t *);\nvoid smb_server_inc_files(smb_server_t *);\nvoid smb_server_dec_files(smb_server_t *);\nvoid smb_server_inc_pipes(smb_server_t *);\nvoid smb_server_dec_pipes(smb_server_t *);\nvoid smb_server_add_rxb(smb_server_t *, int64_t);\nvoid smb_server_add_txb(smb_server_t *, int64_t);\nvoid smb_server_inc_req(smb_server_t *);\n\nsmb_event_t *smb_event_create(smb_server_t *, int);\nvoid smb_event_destroy(smb_event_t *);\nuint32_t smb_event_txid(smb_event_t *);\nint smb_event_wait(smb_event_t *);\nvoid smb_event_notify(smb_server_t *, uint32_t);\n\n/*\n * SMB node functions (file smb_node.c)\n */\nvoid smb_node_init(void);\nvoid smb_node_fini(void);\nsmb_node_t *smb_node_lookup(smb_request_t *, smb_arg_open_t *,\n    cred_t *, vnode_t *, char *, smb_node_t *, smb_node_t *);\nsmb_node_t *smb_stream_node_lookup(smb_request_t *, cred_t *,\n    smb_node_t *, vnode_t *, vnode_t *, char *);\n\nvoid smb_node_ref(smb_node_t *);\nvoid smb_node_release(smb_node_t *);\nvoid smb_node_rename(smb_node_t *, smb_node_t *, smb_node_t *, char *);\nint smb_node_root_init(smb_server_t *, smb_node_t **);\nvoid smb_node_add_lock(smb_node_t *, smb_lock_t *);\nvoid smb_node_destroy_lock(smb_node_t *, smb_lock_t *);\nvoid smb_node_destroy_lock_by_ofile(smb_node_t *, smb_ofile_t *);\nvoid smb_node_start_crit(smb_node_t *, krw_t);\nvoid smb_node_end_crit(smb_node_t *);\nint smb_node_in_crit(smb_node_t *);\nvoid smb_node_rdlock(smb_node_t *);\nvoid smb_node_wrlock(smb_node_t *);\nvoid smb_node_unlock(smb_node_t *);\nvoid smb_node_add_ofile(smb_node_t *, smb_ofile_t *);\nvoid smb_node_rem_ofile(smb_node_t *, smb_ofile_t *);\nvoid smb_node_inc_open_ofiles(smb_node_t *);\nuint32_t smb_node_dec_open_ofiles(smb_node_t *);\nvoid smb_node_inc_opening_count(smb_node_t *);\nvoid smb_node_dec_opening_count(smb_node_t *);\nboolean_t smb_node_is_file(smb_node_t *);\nboolean_t smb_node_is_dir(smb_node_t *);\nboolean_t smb_node_is_symlink(smb_node_t *);\nboolean_t smb_node_is_dfslink(smb_node_t *);\nboolean_t smb_node_is_reparse(smb_node_t *);\nboolean_t smb_node_is_vfsroot(smb_node_t *);\nboolean_t smb_node_is_system(smb_node_t *);\n\nuint32_t smb_node_open_check(smb_node_t *, uint32_t, uint32_t);\nDWORD smb_node_rename_check(smb_node_t *);\nDWORD smb_node_delete_check(smb_node_t *);\nboolean_t smb_node_share_check(smb_node_t *);\n\nvoid smb_node_fcn_subscribe(smb_node_t *, smb_request_t *);\nvoid smb_node_fcn_unsubscribe(smb_node_t *, smb_request_t *);\nvoid smb_node_notify_change(smb_node_t *, uint_t, const char *);\nvoid smb_node_notify_parents(smb_node_t *);\nint smb_node_getattr(smb_request_t *, smb_node_t *, cred_t *,\n    smb_ofile_t *, smb_attr_t *);\nint smb_node_setattr(smb_request_t *, smb_node_t *, cred_t *,\n    smb_ofile_t *, smb_attr_t *);\nuint32_t smb_node_set_delete_on_close(smb_node_t *, cred_t *, uint32_t);\nvoid smb_node_reset_delete_on_close(smb_node_t *);\nboolean_t smb_node_file_is_readonly(smb_node_t *);\nint smb_node_getpath(smb_node_t *, vnode_t *, char *, uint32_t);\nint smb_node_getmntpath(smb_node_t *, char *, uint32_t);\nint smb_node_getshrpath(smb_node_t *, smb_tree_t *, char *, uint32_t);\n\n/*\n * Pathname functions\n */\n\nint smb_pathname_reduce(smb_request_t *, cred_t *,\n    const char *, smb_node_t *, smb_node_t *, smb_node_t **, char *);\n\nint smb_pathname(smb_request_t *, char *, int, smb_node_t *,\n    smb_node_t *, smb_node_t **, smb_node_t **, cred_t *);\n\n/*\n * smb_vfs functions\n */\n\nint smb_vfs_hold(smb_export_t *, vfs_t *);\nvoid smb_vfs_rele(smb_export_t *, vfs_t *);\nvoid smb_vfs_rele_all(smb_export_t *);\n\n/* NOTIFY CHANGE */\n\nuint32_t smb_notify_common(smb_request_t *, mbuf_chain_t *, uint32_t);\nvoid smb_notify_event(smb_node_t *, uint_t, const char *);\nvoid smb_notify_file_closed(smb_ofile_t *);\n\nint smb_fem_fcn_install(smb_node_t *);\nvoid smb_fem_fcn_uninstall(smb_node_t *);\nint smb_fem_oplock_install(smb_node_t *);\nvoid smb_fem_oplock_uninstall(smb_node_t *);\n\n/* FEM */\n\nint smb_fem_init(void);\nvoid smb_fem_fini(void);\n\nint smb_try_grow(smb_request_t *sr, int64_t new_size);\n\nunsigned short smb_worker_getnum();\n\n/* SMB signing routines smb_signing.c */\nint smb_sign_begin(smb_request_t *, smb_token_t *);\nint smb_sign_check_request(smb_request_t *);\nint smb_sign_check_secondary(smb_request_t *, unsigned int);\nvoid smb_sign_reply(smb_request_t *, mbuf_chain_t *);\n/* SMB2, but here because it's called from common code. */\nint smb2_sign_begin(smb_request_t *, smb_token_t *);\n\nboolean_t smb_sattr_check(uint16_t, uint16_t);\n\nvoid smb_request_cancel(smb_request_t *);\nvoid smb_request_wait(smb_request_t *);\n\n/*\n * authentication support (smb_authenticate.c)\n */\nint smb_authenticate_ext(smb_request_t *);\nint smb_authenticate_old(smb_request_t *);\nvoid smb_authsock_close(smb_user_t *);\n\n/*\n * session functions (file smb_session.c)\n */\nsmb_session_t *smb_session_create(ksocket_t, uint16_t, smb_server_t *, int);\nvoid smb_session_receiver(smb_session_t *);\nvoid smb_session_disconnect(smb_session_t *);\nvoid smb_session_timers(smb_llist_t *);\nvoid smb_session_delete(smb_session_t *session);\nvoid smb_session_cancel_requests(smb_session_t *, smb_tree_t *,\n    smb_request_t *);\nvoid smb_session_config(smb_session_t *session);\nvoid smb_session_disconnect_from_share(smb_llist_t *, char *);\nsmb_user_t *smb_session_dup_user(smb_session_t *, char *, char *);\nsmb_user_t *smb_session_lookup_uid(smb_session_t *, uint16_t);\nsmb_user_t *smb_session_lookup_uid_st(smb_session_t *session,\n    uint16_t uid, smb_user_state_t st);\nvoid smb_session_post_user(smb_session_t *, smb_user_t *);\nvoid smb_session_post_tree(smb_session_t *, smb_tree_t *);\nsmb_tree_t *smb_session_lookup_tree(smb_session_t *, uint16_t);\nsmb_tree_t *smb_session_lookup_share(smb_session_t *, const char *,\n    smb_tree_t *);\nsmb_tree_t *smb_session_lookup_volume(smb_session_t *, const char *,\n    smb_tree_t *);\nvoid smb_session_close_pid(smb_session_t *, uint32_t);\nvoid smb_session_disconnect_owned_trees(smb_session_t *, smb_user_t *);\nvoid smb_session_disconnect_trees(smb_session_t *);\nvoid smb_session_disconnect_share(smb_session_t *, const char *);\nvoid smb_session_getclient(smb_session_t *, char *, size_t);\nboolean_t smb_session_isclient(smb_session_t *, const char *);\nvoid smb_session_correct_keep_alive_values(smb_llist_t *, uint32_t);\nvoid smb_session_oplock_break(smb_request_t *, uint8_t);\nint smb_session_send(smb_session_t *, uint8_t type, mbuf_chain_t *);\nint smb_session_xprt_gethdr(smb_session_t *, smb_xprt_t *);\nboolean_t smb_session_oplocks_enable(smb_session_t *);\nboolean_t smb_session_levelII_oplocks(smb_session_t *);\n\n#define\tSMB_SESSION_GET_ID(s)\t((s)->s_kid)\n\nsmb_request_t *smb_request_alloc(smb_session_t *, int);\nvoid smb_request_free(smb_request_t *);\n\n/*\n * ofile functions (file smb_ofile.c)\n */\nsmb_ofile_t *smb_ofile_lookup_by_fid(smb_request_t *, uint16_t);\nsmb_ofile_t *smb_ofile_lookup_by_uniqid(smb_tree_t *, uint32_t);\nboolean_t smb_ofile_disallow_fclose(smb_ofile_t *);\nsmb_ofile_t *smb_ofile_open(smb_request_t *, smb_node_t *,\n    smb_arg_open_t *, uint16_t, uint32_t, smb_error_t *);\nvoid smb_ofile_close(smb_ofile_t *, int32_t);\nvoid smb_ofile_delete(void *);\nuint32_t smb_ofile_access(smb_ofile_t *, cred_t *, uint32_t);\nint smb_ofile_seek(smb_ofile_t *, ushort_t, int32_t, uint32_t *);\nvoid smb_ofile_flush(smb_request_t *, smb_ofile_t *);\nboolean_t smb_ofile_hold(smb_ofile_t *);\nvoid smb_ofile_release(smb_ofile_t *);\nvoid smb_ofile_request_complete(smb_ofile_t *);\nvoid smb_ofile_close_all(smb_tree_t *);\nvoid smb_ofile_close_all_by_pid(smb_tree_t *, uint16_t);\nvoid smb_ofile_set_flags(smb_ofile_t *, uint32_t);\nboolean_t smb_ofile_is_open(smb_ofile_t *);\nint smb_ofile_enum(smb_ofile_t *, smb_svcenum_t *);\nuint32_t smb_ofile_open_check(smb_ofile_t *, uint32_t, uint32_t);\nuint32_t smb_ofile_rename_check(smb_ofile_t *);\nuint32_t smb_ofile_delete_check(smb_ofile_t *);\nboolean_t smb_ofile_share_check(smb_ofile_t *);\ncred_t *smb_ofile_getcred(smb_ofile_t *);\nvoid smb_ofile_set_delete_on_close(smb_ofile_t *);\nvoid smb_delayed_write_timer(smb_llist_t *);\nvoid smb_ofile_set_quota_resume(smb_ofile_t *, char *);\nvoid smb_ofile_get_quota_resume(smb_ofile_t *, char *, int);\n\n#define\tSMB_OFILE_GET_SESSION(of)\t((of)->f_session)\n#define\tSMB_OFILE_GET_TREE(of)\t\t((of)->f_tree)\n#define\tSMB_OFILE_GET_FID(of)\t\t((of)->f_fid)\n#define\tSMB_OFILE_GET_NODE(of)\t\t((of)->f_node)\n\n#define\tsmb_ofile_granted_access(_of_)\t((_of_)->f_granted_access)\n\n/*\n * odir functions (file smb_odir.c)\n */\nuint32_t smb_odir_openpath(smb_request_t *, char *, uint16_t, uint32_t,\n    smb_odir_t **);\nuint32_t smb_odir_openfh(smb_request_t *, const char *, uint16_t,\n    smb_odir_t **);\nuint32_t smb_odir_openat(smb_request_t *, smb_node_t *, smb_odir_t **);\nvoid smb_odir_reopen(smb_odir_t *, const char *, uint16_t);\nvoid smb_odir_close(smb_odir_t *);\nboolean_t smb_odir_hold(smb_odir_t *);\nvoid smb_odir_release(smb_odir_t *);\nvoid smb_odir_delete(void *);\n\nint smb_odir_read(smb_request_t *, smb_odir_t *,\n    smb_odirent_t *, boolean_t *);\nint smb_odir_read_fileinfo(smb_request_t *, smb_odir_t *,\n    smb_fileinfo_t *, uint16_t *);\nint smb_odir_read_streaminfo(smb_request_t *, smb_odir_t *,\n    smb_streaminfo_t *, boolean_t *);\n\nvoid smb_odir_save_cookie(smb_odir_t *, int, uint32_t cookie);\nvoid smb_odir_save_fname(smb_odir_t *, uint32_t, const char *);\n\nvoid smb_odir_resume_at(smb_odir_t *, smb_odir_resume_t *);\n\n/*\n * SMB user functions (file smb_user.c)\n */\nsmb_user_t *smb_user_new(smb_session_t *);\nint smb_user_logon(smb_user_t *, cred_t *,\n    char *, char *, uint32_t, uint32_t, uint32_t);\nsmb_user_t *smb_user_dup(smb_user_t *);\nvoid smb_user_logoff(smb_user_t *);\nvoid smb_user_delete(void *);\nboolean_t smb_user_is_admin(smb_user_t *);\nboolean_t smb_user_namecmp(smb_user_t *, const char *);\nint smb_user_enum(smb_user_t *, smb_svcenum_t *);\nboolean_t smb_user_hold(smb_user_t *);\nvoid smb_user_hold_internal(smb_user_t *);\nvoid smb_user_release(smb_user_t *);\ncred_t *smb_user_getcred(smb_user_t *);\ncred_t *smb_user_getprivcred(smb_user_t *);\nvoid smb_user_netinfo_init(smb_user_t *, smb_netuserinfo_t *);\nvoid smb_user_netinfo_fini(smb_netuserinfo_t *);\nint smb_user_netinfo_encode(smb_user_t *, uint8_t *, size_t, uint32_t *);\nsmb_token_t *smb_get_token(smb_session_t *, smb_logon_t *);\ncred_t *smb_cred_create(smb_token_t *);\nvoid smb_user_setcred(smb_user_t *, cred_t *, uint32_t);\n\n/*\n * SMB tree functions (file smb_tree.c)\n */\nuint32_t smb_tree_connect(smb_request_t *);\nvoid smb_tree_disconnect(smb_tree_t *, boolean_t);\nvoid smb_tree_dealloc(void *);\nvoid smb_tree_post_ofile(smb_tree_t *, smb_ofile_t *);\nvoid smb_tree_post_odir(smb_tree_t *, smb_odir_t *);\nvoid smb_tree_close_pid(smb_tree_t *, uint32_t);\nboolean_t smb_tree_has_feature(smb_tree_t *, uint_t);\nint smb_tree_enum(smb_tree_t *, smb_svcenum_t *);\nint smb_tree_fclose(smb_tree_t *, uint32_t);\nboolean_t smb_tree_hold(smb_tree_t *);\nvoid smb_tree_hold_internal(smb_tree_t *);\nvoid smb_tree_release(smb_tree_t *);\nsmb_odir_t *smb_tree_lookup_odir(smb_request_t *, uint16_t);\nboolean_t smb_tree_is_connected(smb_tree_t *);\n#define\tSMB_TREE_GET_TID(tree)\t\t((tree)->t_tid)\n\nsmb_xa_t *smb_xa_create(smb_session_t *session, smb_request_t *sr,\n    uint32_t total_parameter_count, uint32_t total_data_count,\n    uint32_t max_parameter_count, uint32_t max_data_count,\n    uint32_t max_setup_count, uint32_t setup_word_count);\nvoid smb_xa_delete(smb_xa_t *xa);\nsmb_xa_t *smb_xa_hold(smb_xa_t *xa);\nvoid smb_xa_rele(smb_session_t *session, smb_xa_t *xa);\nint smb_xa_open(smb_xa_t *xa);\nvoid smb_xa_close(smb_xa_t *xa);\nint smb_xa_complete(smb_xa_t *xa);\nsmb_xa_t *smb_xa_find(smb_session_t *session, uint32_t pid, uint16_t mid);\n\nstruct mbuf *smb_mbuf_get(uchar_t *buf, int nbytes);\nstruct mbuf *smb_mbuf_allocate(struct uio *uio);\nvoid smb_mbuf_trim(struct mbuf *mhead, int nbytes);\n\nvoid smb_check_status(void);\nint smb_handle_write_raw(smb_session_t *session, smb_request_t *sr);\n\nint32_t smb_time_gmt_to_local(smb_request_t *, int32_t);\nint32_t smb_time_local_to_gmt(smb_request_t *, int32_t);\nint32_t\tsmb_time_dos_to_unix(int16_t, int16_t);\nvoid smb_time_unix_to_dos(int32_t, int16_t *, int16_t *);\nvoid smb_time_nt_to_unix(uint64_t nt_time, timestruc_t *unix_time);\nuint64_t smb_time_unix_to_nt(timestruc_t *);\n\nint netbios_name_isvalid(char *in, char *out);\n\nint uioxfer(struct uio *src_uio, struct uio *dst_uio, int n);\n\n/*\n * Pool ID function prototypes\n */\nint\tsmb_idpool_constructor(smb_idpool_t *pool);\nvoid\tsmb_idpool_destructor(smb_idpool_t  *pool);\nint\tsmb_idpool_alloc(smb_idpool_t *pool, uint16_t *id);\nvoid\tsmb_idpool_free(smb_idpool_t *pool, uint16_t id);\n\n/*\n * SMB locked list function prototypes\n */\nvoid\tsmb_llist_init(void);\nvoid\tsmb_llist_fini(void);\nvoid\tsmb_llist_constructor(smb_llist_t *, size_t, size_t);\nvoid\tsmb_llist_destructor(smb_llist_t *);\nvoid\tsmb_llist_exit(smb_llist_t *);\nvoid\tsmb_llist_post(smb_llist_t *, void *, smb_dtorproc_t);\nvoid\tsmb_llist_flush(smb_llist_t *);\nvoid\tsmb_llist_insert_head(smb_llist_t *ll, void *obj);\nvoid\tsmb_llist_insert_tail(smb_llist_t *ll, void *obj);\nvoid\tsmb_llist_remove(smb_llist_t *ll, void *obj);\nint\tsmb_llist_upgrade(smb_llist_t *ll);\nuint32_t smb_llist_get_count(smb_llist_t *ll);\n#define\tsmb_llist_enter(ll, mode)\trw_enter(&(ll)->ll_lock, mode)\n#define\tsmb_llist_head(ll)\t\tlist_head(&(ll)->ll_list)\n#define\tsmb_llist_next(ll, obj)\t\tlist_next(&(ll)->ll_list, obj)\nint\tsmb_account_connected(smb_user_t *user);\n\n/*\n * SMB Synchronized list function prototypes\n */\nvoid\tsmb_slist_constructor(smb_slist_t *, size_t, size_t);\nvoid\tsmb_slist_destructor(smb_slist_t *);\nvoid\tsmb_slist_insert_head(smb_slist_t *sl, void *obj);\nvoid\tsmb_slist_insert_tail(smb_slist_t *sl, void *obj);\nvoid\tsmb_slist_remove(smb_slist_t *sl, void *obj);\nvoid\tsmb_slist_wait_for_empty(smb_slist_t *sl);\nvoid\tsmb_slist_exit(smb_slist_t *sl);\nuint32_t smb_slist_move_tail(list_t *lst, smb_slist_t *sl);\nvoid    smb_slist_obj_move(smb_slist_t *dst, smb_slist_t *src, void *obj);\n#define\tsmb_slist_enter(sl)\t\tmutex_enter(&(sl)->sl_mutex)\n#define\tsmb_slist_head(sl)\t\tlist_head(&(sl)->sl_list)\n#define\tsmb_slist_next(sl, obj)\t\tlist_next(&(sl)->sl_list, obj)\n\nvoid    smb_rwx_init(smb_rwx_t *rwx);\nvoid    smb_rwx_destroy(smb_rwx_t *rwx);\n#define\tsmb_rwx_rwenter(rwx, mode)\trw_enter(&(rwx)->rwx_lock, mode)\nvoid    smb_rwx_rwexit(smb_rwx_t *rwx);\nint\tsmb_rwx_rwwait(smb_rwx_t *rwx, clock_t timeout);\n#define\tsmb_rwx_xenter(rwx)\t\tmutex_enter(&(rwx)->rwx_mutex)\n#define\tsmb_rwx_xexit(rwx)\t\tmutex_exit(&(rwx)->rwx_mutex)\nkrw_t   smb_rwx_rwupgrade(smb_rwx_t *rwx);\nvoid    smb_rwx_rwdowngrade(smb_rwx_t *rwx, krw_t mode);\n\nvoid\tsmb_thread_init(smb_thread_t *, char *, smb_thread_ep_t,\n\t\tvoid *, pri_t);\nvoid\tsmb_thread_destroy(smb_thread_t *);\nint\tsmb_thread_start(smb_thread_t *);\nvoid\tsmb_thread_stop(smb_thread_t *);\nvoid    smb_thread_signal(smb_thread_t *);\nboolean_t smb_thread_continue(smb_thread_t *);\nboolean_t smb_thread_continue_nowait(smb_thread_t *);\nboolean_t smb_thread_continue_timedwait(smb_thread_t *, int /* seconds */);\n\nuint32_t smb_denymode_to_sharemode(uint32_t desired_access, char *fname);\nuint32_t smb_ofun_to_crdisposition(uint16_t ofun);\n\n/* 100's of ns between 1/1/1970 and 1/1/1601 */\n#define\tNT_TIME_BIAS\t(134774LL * 24LL * 60LL * 60LL * 10000000LL)\n\nuint32_t smb_sd_read(smb_request_t *, smb_sd_t *, uint32_t);\nuint32_t smb_sd_write(smb_request_t *, smb_sd_t *, uint32_t);\n\nacl_t *smb_fsacl_inherit(acl_t *, int, int, cred_t *);\nacl_t *smb_fsacl_merge(acl_t *, acl_t *);\nvoid smb_fsacl_split(acl_t *, acl_t **, acl_t **, int);\nacl_t *smb_fsacl_from_vsa(vsecattr_t *, acl_type_t);\nint smb_fsacl_to_vsa(acl_t *, vsecattr_t *, int *);\n\nboolean_t smb_ace_is_generic(int);\nboolean_t smb_ace_is_access(int);\nboolean_t smb_ace_is_audit(int);\n\nuint32_t smb_vss_enum_snapshots(smb_request_t *, smb_fsctl_t *);\nint smb_vss_lookup_nodes(smb_request_t *, smb_node_t *, smb_node_t *,\n    char *, smb_node_t **, smb_node_t **);\nvnode_t *smb_lookuppathvptovp(smb_request_t *, char *, vnode_t *, vnode_t *);\n\nvoid smb_panic(char *, const char *, int);\n#pragma\tdoes_not_return(smb_panic)\n#define\tSMB_PANIC()\tsmb_panic(__FILE__, __func__, __LINE__)\n\nvoid smb_latency_init(smb_latency_t *);\nvoid smb_latency_destroy(smb_latency_t *);\nvoid smb_latency_add_sample(smb_latency_t *, hrtime_t);\nvoid smb_srqueue_init(smb_srqueue_t *);\nvoid smb_srqueue_destroy(smb_srqueue_t *);\nvoid smb_srqueue_waitq_enter(smb_srqueue_t *);\nvoid smb_srqueue_runq_exit(smb_srqueue_t *);\nvoid smb_srqueue_waitq_to_runq(smb_srqueue_t *);\nvoid smb_srqueue_update(smb_srqueue_t *, smb_kstat_utilization_t *);\n\nvoid *smb_mem_alloc(size_t);\nvoid *smb_mem_zalloc(size_t);\nvoid *smb_mem_realloc(void *, size_t);\nvoid *smb_mem_rezalloc(void *, size_t);\nvoid smb_mem_free(void *);\nvoid smb_mem_zfree(void *);\nchar *smb_mem_strdup(const char *);\nvoid smb_srm_init(smb_request_t *);\nvoid smb_srm_fini(smb_request_t *);\nvoid *smb_srm_alloc(smb_request_t *, size_t);\nvoid *smb_srm_zalloc(smb_request_t *, size_t);\nvoid *smb_srm_realloc(smb_request_t *, void *, size_t);\nvoid *smb_srm_rezalloc(smb_request_t *, void *, size_t);\nchar *smb_srm_strdup(smb_request_t *, const char *);\n\nvoid smb_export_start(smb_server_t *);\nvoid smb_export_stop(smb_server_t *);\n\n#ifdef\t_KERNEL\nstruct __door_handle;\nstruct __door_handle *smb_kshare_door_init(int);\nvoid smb_kshare_door_fini(struct __door_handle *);\nint smb_kshare_upcall(struct __door_handle *, void *, boolean_t);\n#endif\t/* _KERNEL */\n\nvoid smb_kshare_g_init(void);\nvoid smb_kshare_g_fini(void);\nvoid smb_kshare_init(smb_server_t *);\nvoid smb_kshare_fini(smb_server_t *);\nint smb_kshare_start(smb_server_t *);\nvoid smb_kshare_stop(smb_server_t *);\n\nint smb_kshare_export_list(smb_ioc_share_t *);\nint smb_kshare_unexport_list(smb_ioc_share_t *);\nint smb_kshare_info(smb_ioc_shareinfo_t *);\nvoid smb_kshare_enum(smb_server_t *, smb_enumshare_info_t *);\nsmb_kshare_t *smb_kshare_lookup(smb_server_t *, const char *);\nvoid smb_kshare_release(smb_server_t *, smb_kshare_t *);\nint smb_kshare_exec(smb_server_t *, smb_shr_execinfo_t *);\nuint32_t smb_kshare_hostaccess(smb_kshare_t *, smb_session_t *);\n\n\nvoid smb_avl_create(smb_avl_t *, size_t, size_t, const smb_avl_nops_t *);\nvoid smb_avl_destroy(smb_avl_t *);\nint smb_avl_add(smb_avl_t *, void *);\nvoid smb_avl_remove(smb_avl_t *, void *);\nvoid *smb_avl_lookup(smb_avl_t *, void *);\nvoid smb_avl_release(smb_avl_t *, void *);\nvoid smb_avl_iterinit(smb_avl_t *, smb_avl_cursor_t *);\nvoid *smb_avl_iterate(smb_avl_t *, smb_avl_cursor_t *);\n\nvoid smb_threshold_init(smb_cmd_threshold_t *,\n    char *, uint_t, uint_t);\nvoid smb_threshold_fini(smb_cmd_threshold_t *);\nint smb_threshold_enter(smb_cmd_threshold_t *);\nvoid smb_threshold_exit(smb_cmd_threshold_t *);\nvoid smb_threshold_wake_all(smb_cmd_threshold_t *);\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif /* _SMB_KPROTO_H_ */\n"], "filenames": ["usr/src/uts/common/fs/smbsrv/smb2_flush.c", "usr/src/uts/common/fs/smbsrv/smb_flush.c", "usr/src/uts/common/fs/smbsrv/smb_ofile.c", "usr/src/uts/common/smbsrv/smb_kproto.h"], "buggy_code_start_loc": [13, 23, 23, 24], "buggy_code_end_loc": [62, 127, 839, 675], "fixing_code_start_loc": [14, 24, 24, 25], "fixing_code_end_loc": [56, 109, 862, 678], "type": "CWE-476", "message": "illumos smbsrv NULL pointer dereference allows system crash.", "other": {"cve": {"id": "CVE-2016-6561", "sourceIdentifier": "cret@cert.org", "published": "2017-03-31T19:59:00.207", "lastModified": "2017-05-02T01:59:00.453", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "illumos smbsrv NULL pointer dereference allows system crash."}, {"lang": "es", "value": "Desreferencia illumos smbsrv puntero null permite ca\u00edda del sistema."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "cret@cert.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:illumos:illumos:-:*:*:*:*:*:*:*", "matchCriteriaId": "F696284A-497A-411E-994F-F4376162482F"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/98079", "source": "cret@cert.org"}, {"url": "https://github.com/illumos/illumos-gate/commit/6d1c73b5858fefc6161c7d686345f0dc887ea799", "source": "cret@cert.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.illumos.org/issues/7483", "source": "cret@cert.org", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://www.openindiana.org/2016/11/01/cve-2016-6560-cve-2016-6561-security-issues-in-illumos/", "source": "cret@cert.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/illumos/illumos-gate/commit/6d1c73b5858fefc6161c7d686345f0dc887ea799"}}