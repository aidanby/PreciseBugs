{"buggy_code": ["const graphHelper = require('../../helpers/graph')\nconst safeRegex = require('safe-regex')\nconst _ = require('lodash')\nconst gql = require('graphql')\n\n/* global WIKI */\n\nmodule.exports = {\n  Query: {\n    async groups () { return {} }\n  },\n  Mutation: {\n    async groups () { return {} }\n  },\n  GroupQuery: {\n    /**\n     * FETCH ALL GROUPS\n     */\n    async list () {\n      return WIKI.models.groups.query().select(\n        'groups.*',\n        WIKI.models.groups.relatedQuery('users').count().as('userCount')\n      )\n    },\n    /**\n     * FETCH A SINGLE GROUP\n     */\n    async single(obj, args) {\n      return WIKI.models.groups.query().findById(args.id)\n    }\n  },\n  GroupMutation: {\n    /**\n     * ASSIGN USER TO GROUP\n     */\n    async assignUser (obj, args, { req }) {\n      // Check for guest user\n      if (args.userId === 2) {\n        throw new gql.GraphQLError('Cannot assign the Guest user to a group.')\n      }\n\n      // Check for valid group\n      const grp = await WIKI.models.groups.query().findById(args.groupId)\n      if (!grp) {\n        throw new gql.GraphQLError('Invalid Group ID')\n      }\n\n      // Check assigned permissions for write:groups\n      if (\n        WIKI.auth.checkExclusiveAccess(req.user, ['write:groups'], ['manage:groups', 'manage:system']) &&\n        grp.permissions.some(p => {\n          const resType = _.last(p.split(':'))\n          return ['users', 'groups', 'navigation', 'theme', 'api', 'system'].includes(resType)\n        })\n      ) {\n        throw new gql.GraphQLError('You are not authorized to assign a user to this elevated group.')\n      }\n\n      // Check for valid user\n      const usr = await WIKI.models.users.query().findById(args.userId)\n      if (!usr) {\n        throw new gql.GraphQLError('Invalid User ID')\n      }\n\n      // Check for existing relation\n      const relExist = await WIKI.models.knex('userGroups').where({\n        userId: args.userId,\n        groupId: args.groupId\n      }).first()\n      if (relExist) {\n        throw new gql.GraphQLError('User is already assigned to group.')\n      }\n\n      // Assign user to group\n      await grp.$relatedQuery('users').relate(usr.id)\n\n      // Revoke tokens for this user\n      WIKI.auth.revokeUserTokens({ id: usr.id, kind: 'u' })\n      WIKI.events.outbound.emit('addAuthRevoke', { id: usr.id, kind: 'u' })\n\n      return {\n        responseResult: graphHelper.generateSuccess('User has been assigned to group.')\n      }\n    },\n    /**\n     * CREATE NEW GROUP\n     */\n    async create (obj, args, { req }) {\n      const group = await WIKI.models.groups.query().insertAndFetch({\n        name: args.name,\n        permissions: JSON.stringify(WIKI.data.groups.defaultPermissions),\n        pageRules: JSON.stringify(WIKI.data.groups.defaultPageRules),\n        isSystem: false\n      })\n      await WIKI.auth.reloadGroups()\n      WIKI.events.outbound.emit('reloadGroups')\n      return {\n        responseResult: graphHelper.generateSuccess('Group created successfully.'),\n        group\n      }\n    },\n    /**\n     * DELETE GROUP\n     */\n    async delete (obj, args) {\n      if (args.id === 1 || args.id === 2) {\n        throw new gql.GraphQLError('Cannot delete this group.')\n      }\n\n      await WIKI.models.groups.query().deleteById(args.id)\n\n      WIKI.auth.revokeUserTokens({ id: args.id, kind: 'g' })\n      WIKI.events.outbound.emit('addAuthRevoke', { id: args.id, kind: 'g' })\n\n      await WIKI.auth.reloadGroups()\n      WIKI.events.outbound.emit('reloadGroups')\n\n      return {\n        responseResult: graphHelper.generateSuccess('Group has been deleted.')\n      }\n    },\n    /**\n     * UNASSIGN USER FROM GROUP\n     */\n    async unassignUser (obj, args) {\n      if (args.userId === 2) {\n        throw new gql.GraphQLError('Cannot unassign Guest user')\n      }\n      if (args.userId === 1 && args.groupId === 1) {\n        throw new gql.GraphQLError('Cannot unassign Administrator user from Administrators group.')\n      }\n      const grp = await WIKI.models.groups.query().findById(args.groupId)\n      if (!grp) {\n        throw new gql.GraphQLError('Invalid Group ID')\n      }\n      const usr = await WIKI.models.users.query().findById(args.userId)\n      if (!usr) {\n        throw new gql.GraphQLError('Invalid User ID')\n      }\n      await grp.$relatedQuery('users').unrelate().where('userId', usr.id)\n\n      WIKI.auth.revokeUserTokens({ id: usr.id, kind: 'u' })\n      WIKI.events.outbound.emit('addAuthRevoke', { id: usr.id, kind: 'u' })\n\n      return {\n        responseResult: graphHelper.generateSuccess('User has been unassigned from group.')\n      }\n    },\n    /**\n     * UPDATE GROUP\n     */\n    async update (obj, args, { req }) {\n      // Check for unsafe regex page rules\n      if (_.some(args.pageRules, pr => {\n        return pr.match === 'REGEX' && !safeRegex(pr.path)\n      })) {\n        throw new gql.GraphQLError('Some Page Rules contains unsafe or exponential time regex.')\n      }\n\n      // Set default redirect on login value\n      if (_.isEmpty(args.redirectOnLogin)) {\n        args.redirectOnLogin = '/'\n      }\n\n      // Check assigned permissions for write:groups\n      if (\n        WIKI.auth.checkExclusiveAccess(req.user, ['write:groups'], ['manage:groups', 'manage:system']) &&\n        args.permissions.some(p => {\n          const resType = _.last(p.split(':'))\n          return ['users', 'groups', 'navigation', 'theme', 'api', 'system'].includes(resType)\n        })\n      ) {\n        throw new gql.GraphQLError('You are not authorized to manage this group or assign these permissions.')\n      }\n\n      // Update group\n      await WIKI.models.groups.query().patch({\n        name: args.name,\n        redirectOnLogin: args.redirectOnLogin,\n        permissions: JSON.stringify(args.permissions),\n        pageRules: JSON.stringify(args.pageRules)\n      }).where('id', args.id)\n\n      // Revoke tokens for this group\n      WIKI.auth.revokeUserTokens({ id: args.id, kind: 'g' })\n      WIKI.events.outbound.emit('addAuthRevoke', { id: args.id, kind: 'g' })\n\n      // Reload group permissions\n      await WIKI.auth.reloadGroups()\n      WIKI.events.outbound.emit('reloadGroups')\n\n      return {\n        responseResult: graphHelper.generateSuccess('Group has been updated.')\n      }\n    }\n  },\n  Group: {\n    users (grp) {\n      return grp.$relatedQuery('users')\n    }\n  }\n}\n"], "fixing_code": ["const graphHelper = require('../../helpers/graph')\nconst safeRegex = require('safe-regex')\nconst _ = require('lodash')\nconst gql = require('graphql')\n\n/* global WIKI */\n\nmodule.exports = {\n  Query: {\n    async groups () { return {} }\n  },\n  Mutation: {\n    async groups () { return {} }\n  },\n  GroupQuery: {\n    /**\n     * FETCH ALL GROUPS\n     */\n    async list () {\n      return WIKI.models.groups.query().select(\n        'groups.*',\n        WIKI.models.groups.relatedQuery('users').count().as('userCount')\n      )\n    },\n    /**\n     * FETCH A SINGLE GROUP\n     */\n    async single(obj, args) {\n      return WIKI.models.groups.query().findById(args.id)\n    }\n  },\n  GroupMutation: {\n    /**\n     * ASSIGN USER TO GROUP\n     */\n    async assignUser (obj, args, { req }) {\n      // Check for guest user\n      if (args.userId === 2) {\n        throw new gql.GraphQLError('Cannot assign the Guest user to a group.')\n      }\n\n      // Check for valid group\n      const grp = await WIKI.models.groups.query().findById(args.groupId)\n      if (!grp) {\n        throw new gql.GraphQLError('Invalid Group ID')\n      }\n\n      // Check assigned permissions for write:groups\n      if (\n        WIKI.auth.checkExclusiveAccess(req.user, ['write:groups'], ['manage:groups', 'manage:system']) &&\n        grp.permissions.some(p => {\n          const resType = _.last(p.split(':'))\n          return ['users', 'groups', 'navigation', 'theme', 'api', 'system'].includes(resType)\n        })\n      ) {\n        throw new gql.GraphQLError('You are not authorized to assign a user to this elevated group.')\n      }\n\n      // Check for valid user\n      const usr = await WIKI.models.users.query().findById(args.userId)\n      if (!usr) {\n        throw new gql.GraphQLError('Invalid User ID')\n      }\n\n      // Check for existing relation\n      const relExist = await WIKI.models.knex('userGroups').where({\n        userId: args.userId,\n        groupId: args.groupId\n      }).first()\n      if (relExist) {\n        throw new gql.GraphQLError('User is already assigned to group.')\n      }\n\n      // Assign user to group\n      await grp.$relatedQuery('users').relate(usr.id)\n\n      // Revoke tokens for this user\n      WIKI.auth.revokeUserTokens({ id: usr.id, kind: 'u' })\n      WIKI.events.outbound.emit('addAuthRevoke', { id: usr.id, kind: 'u' })\n\n      return {\n        responseResult: graphHelper.generateSuccess('User has been assigned to group.')\n      }\n    },\n    /**\n     * CREATE NEW GROUP\n     */\n    async create (obj, args, { req }) {\n      const group = await WIKI.models.groups.query().insertAndFetch({\n        name: args.name,\n        permissions: JSON.stringify(WIKI.data.groups.defaultPermissions),\n        pageRules: JSON.stringify(WIKI.data.groups.defaultPageRules),\n        isSystem: false\n      })\n      await WIKI.auth.reloadGroups()\n      WIKI.events.outbound.emit('reloadGroups')\n      return {\n        responseResult: graphHelper.generateSuccess('Group created successfully.'),\n        group\n      }\n    },\n    /**\n     * DELETE GROUP\n     */\n    async delete (obj, args) {\n      if (args.id === 1 || args.id === 2) {\n        throw new gql.GraphQLError('Cannot delete this group.')\n      }\n\n      await WIKI.models.groups.query().deleteById(args.id)\n\n      WIKI.auth.revokeUserTokens({ id: args.id, kind: 'g' })\n      WIKI.events.outbound.emit('addAuthRevoke', { id: args.id, kind: 'g' })\n\n      await WIKI.auth.reloadGroups()\n      WIKI.events.outbound.emit('reloadGroups')\n\n      return {\n        responseResult: graphHelper.generateSuccess('Group has been deleted.')\n      }\n    },\n    /**\n     * UNASSIGN USER FROM GROUP\n     */\n    async unassignUser (obj, args) {\n      if (args.userId === 2) {\n        throw new gql.GraphQLError('Cannot unassign Guest user')\n      }\n      if (args.userId === 1 && args.groupId === 1) {\n        throw new gql.GraphQLError('Cannot unassign Administrator user from Administrators group.')\n      }\n      const grp = await WIKI.models.groups.query().findById(args.groupId)\n      if (!grp) {\n        throw new gql.GraphQLError('Invalid Group ID')\n      }\n      const usr = await WIKI.models.users.query().findById(args.userId)\n      if (!usr) {\n        throw new gql.GraphQLError('Invalid User ID')\n      }\n      await grp.$relatedQuery('users').unrelate().where('userId', usr.id)\n\n      WIKI.auth.revokeUserTokens({ id: usr.id, kind: 'u' })\n      WIKI.events.outbound.emit('addAuthRevoke', { id: usr.id, kind: 'u' })\n\n      return {\n        responseResult: graphHelper.generateSuccess('User has been unassigned from group.')\n      }\n    },\n    /**\n     * UPDATE GROUP\n     */\n    async update (obj, args, { req }) {\n      // Check for unsafe regex page rules\n      if (_.some(args.pageRules, pr => {\n        return pr.match === 'REGEX' && !safeRegex(pr.path)\n      })) {\n        throw new gql.GraphQLError('Some Page Rules contains unsafe or exponential time regex.')\n      }\n\n      // Set default redirect on login value\n      if (_.isEmpty(args.redirectOnLogin)) {\n        args.redirectOnLogin = '/'\n      }\n\n      // Check assigned permissions for write:groups\n      if (\n        WIKI.auth.checkExclusiveAccess(req.user, ['write:groups'], ['manage:groups', 'manage:system']) &&\n        args.permissions.some(p => {\n          const resType = _.last(p.split(':'))\n          return ['users', 'groups', 'navigation', 'theme', 'api', 'system'].includes(resType)\n        })\n      ) {\n        throw new gql.GraphQLError('You are not authorized to manage this group or assign these permissions.')\n      }\n\n      // Check assigned permissions for manage:groups\n      if (\n        WIKI.auth.checkExclusiveAccess(req.user, ['manage:groups'], ['manage:system']) &&\n        args.permissions.some(p => _.last(p.split(':')) === 'system')\n      ) {\n        throw new gql.GraphQLError('You are not authorized to manage this group or assign the manage:system permissions.')\n      }\n\n      // Update group\n      await WIKI.models.groups.query().patch({\n        name: args.name,\n        redirectOnLogin: args.redirectOnLogin,\n        permissions: JSON.stringify(args.permissions),\n        pageRules: JSON.stringify(args.pageRules)\n      }).where('id', args.id)\n\n      // Revoke tokens for this group\n      WIKI.auth.revokeUserTokens({ id: args.id, kind: 'g' })\n      WIKI.events.outbound.emit('addAuthRevoke', { id: args.id, kind: 'g' })\n\n      // Reload group permissions\n      await WIKI.auth.reloadGroups()\n      WIKI.events.outbound.emit('reloadGroups')\n\n      return {\n        responseResult: graphHelper.generateSuccess('Group has been updated.')\n      }\n    }\n  },\n  Group: {\n    users (grp) {\n      return grp.$relatedQuery('users')\n    }\n  }\n}\n"], "filenames": ["server/graph/resolvers/group.js"], "buggy_code_start_loc": [175], "buggy_code_end_loc": [175], "fixing_code_start_loc": [176], "fixing_code_end_loc": [184], "type": "CWE-287", "message": "Authentication Bypass Using an Alternate Path or Channel in GitHub repository requarks/wiki prior to 2.5.281. User can get root user permissions", "other": {"cve": {"id": "CVE-2022-1681", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-12T08:15:07.370", "lastModified": "2022-05-20T17:54:44.067", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Authentication Bypass Using an Alternate Path or Channel in GitHub repository requarks/wiki prior to 2.5.281. User can get root user permissions"}, {"lang": "es", "value": "Una Omisi\u00f3n de la Autenticaci\u00f3n Mediante una Ruta o Canal Alternativo en el repositorio de GitHub requarks/wiki versiones anteriores a 2.5.281. El usuario puede conseguir permisos de usuario root"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.0}, "baseSeverity": "HIGH", "exploitabilityScore": 8.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-288"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:requarks:wiki.js:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.5.281", "matchCriteriaId": "349C71DA-8677-45E1-83F2-59C7EAB3E880"}]}]}], "references": [{"url": "https://github.com/requarks/wiki/commit/78d02dc8e5d103d248e5d7632bf7a6facdf4264c", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/591b11e1-7504-4a96-99c6-08f2b419e767", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/requarks/wiki/commit/78d02dc8e5d103d248e5d7632bf7a6facdf4264c"}}