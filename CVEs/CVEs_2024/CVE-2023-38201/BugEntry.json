{"buggy_code": ["import base64\nimport http.server\nimport ipaddress\nimport os\nimport select\nimport signal\nimport socket\nimport ssl\nimport sys\nimport threading\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nfrom ipaddress import IPv6Address, ip_address\nfrom socketserver import ThreadingMixIn\nfrom typing import Any, Dict, Optional, Tuple, Union, cast\n\nfrom cryptography.hazmat.primitives.asymmetric import ec, rsa\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.orm.exc import NoResultFound  # pyright: ignore\n\nfrom keylime import api_version as keylime_api_version\nfrom keylime import cert_utils, config, crypto, json, keylime_logging, web_util\nfrom keylime.common import validators\nfrom keylime.da import record\nfrom keylime.db.keylime_db import DBEngineManager, SessionManager\nfrom keylime.db.registrar_db import RegistrarMain\nfrom keylime.tpm import tpm2_objects\nfrom keylime.tpm.tpm_main import Tpm\n\nlogger = keylime_logging.init_logging(\"registrar\")\n\n\ntry:\n    engine = DBEngineManager().make_engine(\"registrar\")\nexcept SQLAlchemyError as err:\n    logger.error(\"Error creating SQL engine: %s\", err)\n    sys.exit(1)\n\ntry:\n    rmc = record.get_record_mgt_class(config.get(\"registrar\", \"durable_attestation_import\", fallback=\"\"))\n    if rmc:\n        rmc = rmc(\"registrar\")\nexcept record.RecordManagementException as rme:\n    logger.error(\"Error initializing Durable Attestation: %s\", rme)\n    sys.exit(1)\n\n\nclass BaseHandler(BaseHTTPRequestHandler, SessionManager):\n    def _validate_input(\n        self, method: str, respond_on_agent_id_none: bool\n    ) -> Tuple[Optional[Dict[str, Union[str, None]]], Optional[str]]:\n        rest_params = web_util.get_restful_params(self.path)\n        if rest_params is None:\n            web_util.echo_json_response(self, 405, \"Not Implemented: Use /agents/ interface\")\n            return None, None\n\n        if not web_util.validate_api_version(self, cast(str, rest_params[\"api_version\"]), logger):\n            return None, None\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"URI not supported\")\n            logger.warning(\"%s agent returning 400 response. uri not supported: %s\", method, self.path)\n            return None, None\n\n        agent_id = rest_params[\"agents\"]\n\n        if agent_id is None:\n            if respond_on_agent_id_none:\n                web_util.echo_json_response(self, 400, \"agent id not found in uri\")\n                logger.warning(\"%s agent returning 400 response. agent id not found in uri %s\", method, self.path)\n            return rest_params, None\n\n        # If the agent ID is not valid (wrong set of characters), just do nothing.\n        if not validators.valid_agent_id(agent_id):\n            web_util.echo_json_response(self, 400, \"agent_id is not valid\")\n            logger.error(\"%s received an invalid agent ID: %s\", method, agent_id)\n            return None, None\n\n        return rest_params, agent_id\n\n\nclass ProtectedHandler(BaseHandler):\n    def handle(self) -> None:\n        \"\"\"Need to perform SSL handshake here, as\n        do_handshake_on_connect=False for non-blocking SSL socket\"\"\"\n        while True:\n            try:\n                self.request.do_handshake()\n                break\n            except ssl.SSLWantReadError:\n                select.select([self.request], [], [])\n            except ssl.SSLWantWriteError:\n                select.select([], [self.request], [])\n            except ssl.SSLError as e:\n                logger.error(\"SSL connection error: %s\", e)\n                return\n            except Exception as e:\n                logger.error(\"General communication failure: %s\", e)\n                return\n        BaseHTTPRequestHandler.handle(self)\n\n    def do_HEAD(self) -> None:\n        \"\"\"HEAD not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"HEAD not supported\")\n\n    def do_PATCH(self) -> None:\n        \"\"\"PATCH not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"PATCH not supported\")\n\n    def do_GET(self) -> None:\n        \"\"\"This method handles the GET requests to retrieve status on agents from the Registrar Server.\n\n        Currently, only agents resources are available for GETing, i.e. /agents. All other GET uri's\n        will return errors. agents requests require a single agent_id parameter which identifies the\n        agent to be returned. If the agent_id is not found, a 404 response is returned.\n        \"\"\"\n        session = SessionManager().make_session(engine)\n\n        rest_params, agent_id = self._validate_input(\"GET\", False)\n        if not rest_params:\n            return\n\n        if agent_id is not None:\n            try:\n                agent = session.query(RegistrarMain).filter_by(agent_id=agent_id).first()\n            except SQLAlchemyError as e:\n                logger.error(\"SQLAlchemy Error for agent ID %s: %s\", agent_id, e)\n                return\n\n            if agent is None:\n                web_util.echo_json_response(self, 404, f\"agent {agent_id} not found\")\n                logger.warning(\"GET returning 404 response. agent %s not found.\", agent_id)\n                return\n\n            if not bool(agent.active):\n                web_util.echo_json_response(self, 404, f\"agent {agent_id} not yet active\")\n                logger.warning(\"GET returning 404 response. agent %s not yet active.\", agent_id)\n                return\n\n            response = {\n                \"aik_tpm\": agent.aik_tpm,\n                \"ek_tpm\": agent.ek_tpm,\n                \"ekcert\": agent.ekcert,\n                \"mtls_cert\": agent.mtls_cert,\n                \"ip\": agent.ip,\n                \"port\": agent.port,\n                \"regcount\": agent.regcount,\n            }\n\n            if agent.virtual:  # pyright: ignore\n                response[\"provider_keys\"] = agent.provider_keys\n\n            web_util.echo_json_response(self, 200, \"Success\", response)\n            logger.info(\"GET returning 200 response for agent_id: %s\", agent_id)\n        else:\n            # return the available registered uuids from the DB\n            json_response = session.query(RegistrarMain.agent_id).all()\n            return_response = [item[0] for item in json_response]\n            web_util.echo_json_response(self, 200, \"Success\", {\"uuids\": return_response})\n            logger.info(\"GET returning 200 response for agent_id list\")\n\n        return\n\n    def do_POST(self) -> None:\n        \"\"\"POST not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"POST not supported via TLS interface\")\n\n    def do_PUT(self) -> None:\n        \"\"\"PUT not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"PUT not supported via TLS interface\")\n\n    def do_DELETE(self) -> None:\n        \"\"\"This method handles the DELETE requests to remove agents from the Registrar Server.\n\n        Currently, only agents resources are available for DELETEing, i.e. /agents. All other DELETE uri's will return errors.\n        agents requests require a single agent_id parameter which identifies the agent to be deleted.\n        \"\"\"\n        session = SessionManager().make_session(engine)\n\n        rest_params, agent_id = self._validate_input(\"DELETE\", False)\n        if not rest_params:\n            return\n\n        if agent_id is not None:\n            if session.query(RegistrarMain).filter_by(agent_id=agent_id).delete():\n                # send response\n                try:\n                    session.commit()\n                except SQLAlchemyError as e:\n                    logger.error(\"SQLAlchemy Error: %s\", e)\n                web_util.echo_json_response(self, 200, \"Success\")\n                return\n\n            # send response\n            web_util.echo_json_response(self, 404)\n            return\n\n        web_util.echo_json_response(self, 404)\n\n    # pylint: disable=W0622\n    def log_message(self, format: str, *args: Any) -> None:\n        return\n\n\nclass UnprotectedHandler(BaseHandler):\n    def do_HEAD(self) -> None:\n        \"\"\"HEAD not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"HEAD not supported\")\n\n    def do_PATCH(self) -> None:\n        \"\"\"PATCH not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"PATCH not supported\")\n\n    def do_GET(self) -> None:\n        \"\"\"This method handles the GET requests to the unprotected side of the Registrar Server\n\n        Currently the only supported path is /versions which shows the supported API versions\n        \"\"\"\n        rest_params = web_util.get_restful_params(self.path)\n        if rest_params is None:\n            web_util.echo_json_response(self, 405, \"Not Implemented: Use /version/ interface\")\n            return\n\n        if \"version\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"URI not supported\")\n            logger.warning(\"GET agent returning 400 response. URI not supported: %s\", self.path)\n            return\n\n        version_info = {\n            \"current_version\": keylime_api_version.current_version(),\n            \"supported_versions\": keylime_api_version.all_versions(),\n        }\n\n        web_util.echo_json_response(self, 200, \"Success\", version_info)\n\n    @staticmethod\n    def get_network_params(\n        json_body: Dict[str, Any], agent_id: str\n    ) -> Tuple[Optional[str], Optional[int], Optional[str]]:\n        # Validate ip and port\n        ip = json_body.get(\"ip\")\n        if ip is not None:\n            try:\n                ipaddress.ip_address(ip)\n            except ValueError:\n                logger.warning(\"Contact ip for agent %s is not a valid ip got: %s.\", agent_id, ip)\n                ip = None\n\n        port = json_body.get(\"port\")\n        if port is not None:\n            try:\n                port = int(port)\n                if port < 1 or port > 65535:\n                    logger.warning(\"Contact port for agent %s is not a number between 1 and got: %s.\", agent_id, port)\n                    port = None\n            except ValueError:\n                logger.warning(\"Contact port for agent %s is not a valid number got: %s.\", agent_id, port)\n                port = None\n\n        mtls_cert = json_body.get(\"mtls_cert\")\n        if mtls_cert is None or mtls_cert == \"disabled\":\n            logger.warning(\"Agent %s did not send a mTLS certificate. Most operations will not work!\", agent_id)\n\n        return ip, port, mtls_cert\n\n    def do_POST(self) -> None:\n        \"\"\"This method handles the POST requests to add agents to the Registrar Server.\n\n        Currently, only agents resources are available for POSTing, i.e. /agents. All other POST uri's\n        will return errors. POST requests require an an agent_id identifying the agent to add, and json\n        block sent in the body with 2 entries: ek and aik.\n        \"\"\"\n        session = SessionManager().make_session(engine)\n\n        _, agent_id = self._validate_input(\"POST\", True)\n        if not agent_id:\n            return\n\n        try:\n            content_length = int(self.headers.get(\"Content-Length\", 0))\n            if content_length == 0:\n                web_util.echo_json_response(self, 400, \"Expected non zero content length\")\n                logger.warning(\"POST for %s returning 400 response. Expected non zero content length.\", agent_id)\n                return\n\n            post_body = self.rfile.read(content_length)\n            json_body = json.loads(post_body)\n\n            ekcert = json_body[\"ekcert\"]\n            aik_tpm = json_body[\"aik_tpm\"]\n\n            if ekcert is None or ekcert == \"emulator\":\n                logger.warning(\"Agent %s did not submit an ekcert\", agent_id)\n                ek_tpm = json_body[\"ek_tpm\"]\n            else:\n                if \"ek_tpm\" in json_body:\n                    # This would mean the agent submitted both a non-None ekcert, *and*\n                    #  an ek_tpm... We can deal with it by just ignoring the ek_tpm they sent\n                    logger.warning(\"Overriding ek_tpm for agent %s from ekcert\", agent_id)\n                # If there's an EKCert, we just overwrite their ek_tpm\n                # Note, we don't validate the EKCert here, other than the implicit\n                #  \"is it a valid x509 cert\" check. So it's still untrusted.\n                # This will be validated by the tenant.\n                cert = cert_utils.x509_der_cert(base64.b64decode(ekcert))\n                pubkey = cert.public_key()\n                assert isinstance(pubkey, (rsa.RSAPublicKey, ec.EllipticCurvePublicKey))\n                ek_tpm = base64.b64encode(tpm2_objects.ek_low_tpm2b_public_from_pubkey(pubkey)).decode()\n\n            aik_attrs = tpm2_objects.get_tpm2b_public_object_attributes(\n                base64.b64decode(aik_tpm),\n            )\n            if aik_attrs != tpm2_objects.AK_EXPECTED_ATTRS:\n                web_util.echo_json_response(self, 400, \"Invalid AK attributes\")\n                logger.warning(\n                    \"Agent %s submitted AIK with invalid attributes! %s (provided) != %s (expected)\",\n                    agent_id,\n                    tpm2_objects.object_attributes_description(aik_attrs),\n                    tpm2_objects.object_attributes_description(tpm2_objects.AK_EXPECTED_ATTRS),\n                )\n                return\n\n            # try to encrypt the AIK\n            aik_enc = Tpm.encryptAIK(\n                agent_id,\n                base64.b64decode(ek_tpm),\n                base64.b64decode(aik_tpm),\n            )\n            if aik_enc is None:\n                logger.warning(\"Agent %s failed encrypting AIK\", agent_id)\n                web_util.echo_json_response(self, 400, \"Error: failed encrypting AK\")\n                return\n\n            blob, key = aik_enc\n\n            # special behavior if we've registered this uuid before\n            regcount = 1\n            try:\n                agent = session.query(RegistrarMain).filter_by(agent_id=agent_id).first()\n            except NoResultFound:\n                agent = None\n            except SQLAlchemyError as e:\n                logger.error(\"SQLAlchemy Error: %s\", e)\n                raise\n\n            if agent is not None:\n                # keep track of how many ek-ekcerts have registered on this uuid\n                assert isinstance(agent.regcount, int)\n                regcount = agent.regcount\n                if agent.ek_tpm != ek_tpm or agent.ekcert != ekcert:  # pyright: ignore\n                    logger.warning(\"WARNING: Overwriting previous registration for this UUID with new ek-ekcert pair!\")\n                    regcount += 1\n\n                # force overwrite\n                logger.info(\"Overwriting previous registration for this UUID.\")\n                try:\n                    session.query(RegistrarMain).filter_by(agent_id=agent_id).delete()\n                    session.commit()\n                except SQLAlchemyError as e:\n                    logger.error(\"SQLAlchemy Error: %s\", e)\n                    raise\n\n            # Check for ip and port and mTLS cert\n            contact_ip, contact_port, mtls_cert = UnprotectedHandler.get_network_params(json_body, agent_id)\n\n            # Add values to database\n            d: Dict[str, Any] = {\n                \"agent_id\": agent_id,\n                \"ek_tpm\": ek_tpm,\n                \"aik_tpm\": aik_tpm,\n                \"ekcert\": ekcert,\n                \"ip\": contact_ip,\n                \"mtls_cert\": mtls_cert,\n                \"port\": contact_port,\n                \"virtual\": int(ekcert == \"virtual\"),\n                \"active\": int(False),\n                \"key\": key,\n                \"provider_keys\": {},\n                \"regcount\": regcount,\n            }\n\n            try:\n                session.add(RegistrarMain(**d))\n                session.commit()\n            except SQLAlchemyError as e:\n                logger.error(\"SQLAlchemy Error: %s\", e)\n                raise\n\n            if rmc:\n                try:\n                    rmc.record_create(d, None, None)\n\n                except Exception as e:\n                    logger.error(\"Durable Attestation Error: %s\", e)\n                    raise\n\n            response = {\n                \"blob\": blob,\n            }\n            web_util.echo_json_response(self, 200, \"Success\", response)\n\n            logger.info(\"POST returning key blob for agent_id: %s\", agent_id)\n        except Exception as e:\n            web_util.echo_json_response(self, 400, f\"Error: {str(e)}\")\n            logger.warning(\"POST for %s returning 400 response. Error: %s\", agent_id, e)\n            logger.exception(e)\n\n    def do_PUT(self) -> None:\n        \"\"\"This method handles the PUT requests to add agents to the Registrar Server.\n\n        Currently, only agents resources are available for PUTing, i.e. /agents. All other PUT uri's\n        will return errors.\n        \"\"\"\n        session = SessionManager().make_session(engine)\n\n        _, agent_id = self._validate_input(\"PUT\", True)\n        if not agent_id:\n            return\n\n        try:\n            content_length = int(self.headers.get(\"Content-Length\", 0))\n            if content_length == 0:\n                web_util.echo_json_response(self, 400, \"Expected non zero content length\")\n                logger.warning(\"PUT for %s returning 400 response. Expected non zero content length.\", agent_id)\n                return\n\n            post_body = self.rfile.read(content_length)\n            json_body = json.loads(post_body)\n\n            auth_tag = json_body[\"auth_tag\"]\n            try:\n                agent = session.query(RegistrarMain).filter_by(agent_id=agent_id).first()\n            except NoResultFound as e:\n                raise Exception(\"attempting to activate agent before requesting \" f\"registrar for {agent_id}\") from e\n            except SQLAlchemyError as e:\n                logger.error(\"SQLAlchemy Error: %s\", e)\n                raise\n\n            assert agent\n            assert isinstance(agent.key, str)\n            ex_mac = crypto.do_hmac(agent.key.encode(), agent_id)\n            if ex_mac == auth_tag:\n                try:\n                    session.query(RegistrarMain).filter(RegistrarMain.agent_id == agent_id).update(\n                        {\"active\": int(True)}\n                    )\n                    session.commit()\n                except SQLAlchemyError as e:\n                    logger.error(\"SQLAlchemy Error: %s\", e)\n                    raise\n            else:\n                raise Exception(f\"Auth tag {auth_tag} does not match expected value {ex_mac}\")\n\n            web_util.echo_json_response(self, 200, \"Success\")\n            logger.info(\"PUT activated: %s\", agent_id)\n        except Exception as e:\n            web_util.echo_json_response(self, 400, f\"Error: {str(e)}\")\n            logger.warning(\"PUT for %s returning 400 response. Error: %s\", agent_id, e)\n            logger.exception(e)\n            return\n\n    def do_DELETE(self) -> None:\n        \"\"\"DELETE not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"DELETE not supported\")\n\n    # pylint: disable=W0622\n    def log_message(self, format: str, *args: Any) -> None:\n        return\n\n\n# consider using PooledProcessMixIn\n# https://github.com/muayyad-alsadi/python-PooledProcessMixIn\n\n\nclass RegistrarServer(ThreadingMixIn, HTTPServer):\n    \"\"\"Handle requests in a separate thread.\"\"\"\n\n    def __init__(self, server_address: Tuple[str, int], RequestHandlerClass: Any) -> None:\n        \"\"\"Constructor overridden to provide ability to read file\"\"\"\n        bindaddr = server_address[0].strip()\n        if len(bindaddr) > 0 and isinstance(ip_address(bindaddr), IPv6Address):\n            self.address_family = socket.AF_INET6\n        http.server.HTTPServer.__init__(self, server_address, RequestHandlerClass)\n\n    def shutdown(self) -> None:\n        http.server.HTTPServer.shutdown(self)\n\n\ndef start(host: str, tlsport: int, port: int) -> None:\n    \"\"\"Main method of the Registrar Server.  This method is encapsulated in a function for packaging to allow it to be\n    called as a function by an external program.\"\"\"\n\n    # set a conservative general umask\n    os.umask(0o077)\n\n    RegistrarMain.metadata.create_all(engine, checkfirst=True)\n    session = SessionManager().make_session(engine)\n    try:\n        count = session.query(RegistrarMain.agent_id).count()\n        if count > 0:\n            logger.info(\"Loaded %d public keys from database\", count)\n    except SQLAlchemyError as e:\n        logger.error(\"SQLAlchemy Error: %s\", e)\n\n    # Set up the protected registrar server\n    protected_server = RegistrarServer((host, tlsport), ProtectedHandler)\n    context = web_util.init_mtls(\"registrar\", logger=logger)\n    if context is not None:\n        protected_server.socket = context.wrap_socket(\n            protected_server.socket, server_side=True, do_handshake_on_connect=False\n        )\n    thread_protected_server = threading.Thread(target=protected_server.serve_forever)\n\n    # Set up the unprotected registrar server\n    unprotected_server = RegistrarServer((host, port), UnprotectedHandler)\n    thread_unprotected_server = threading.Thread(target=unprotected_server.serve_forever)\n\n    logger.info(\"Starting Cloud Registrar Server on ports %s and %s (TLS) use <Ctrl-C> to stop\", port, tlsport)\n    keylime_api_version.log_api_versions(logger)\n    thread_protected_server.start()\n    thread_unprotected_server.start()\n\n    def signal_handler(signum: int, frame: Any) -> None:\n        del signum, frame\n        logger.info(\"Shutting down Registrar Server...\")\n        protected_server.shutdown()\n        unprotected_server.shutdown()\n        sys.exit(0)\n\n    # Catch these signals.  Note that a SIGKILL cannot be caught, so\n    # killing this process with \"kill -9\" may result in improper shutdown\n    signal.signal(signal.SIGTERM, signal_handler)\n    signal.signal(signal.SIGQUIT, signal_handler)\n    signal.signal(signal.SIGINT, signal_handler)\n\n    thread_protected_server.join()\n    thread_unprotected_server.join()\n"], "fixing_code": ["import base64\nimport http.server\nimport ipaddress\nimport os\nimport select\nimport signal\nimport socket\nimport ssl\nimport sys\nimport threading\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nfrom ipaddress import IPv6Address, ip_address\nfrom socketserver import ThreadingMixIn\nfrom typing import Any, Dict, Optional, Tuple, Union, cast\n\nfrom cryptography.hazmat.primitives.asymmetric import ec, rsa\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.orm.exc import NoResultFound  # pyright: ignore\n\nfrom keylime import api_version as keylime_api_version\nfrom keylime import cert_utils, config, crypto, json, keylime_logging, web_util\nfrom keylime.common import validators\nfrom keylime.da import record\nfrom keylime.db.keylime_db import DBEngineManager, SessionManager\nfrom keylime.db.registrar_db import RegistrarMain\nfrom keylime.tpm import tpm2_objects\nfrom keylime.tpm.tpm_main import Tpm\n\nlogger = keylime_logging.init_logging(\"registrar\")\n\n\ntry:\n    engine = DBEngineManager().make_engine(\"registrar\")\nexcept SQLAlchemyError as err:\n    logger.error(\"Error creating SQL engine: %s\", err)\n    sys.exit(1)\n\ntry:\n    rmc = record.get_record_mgt_class(config.get(\"registrar\", \"durable_attestation_import\", fallback=\"\"))\n    if rmc:\n        rmc = rmc(\"registrar\")\nexcept record.RecordManagementException as rme:\n    logger.error(\"Error initializing Durable Attestation: %s\", rme)\n    sys.exit(1)\n\n\nclass BaseHandler(BaseHTTPRequestHandler, SessionManager):\n    def _validate_input(\n        self, method: str, respond_on_agent_id_none: bool\n    ) -> Tuple[Optional[Dict[str, Union[str, None]]], Optional[str]]:\n        rest_params = web_util.get_restful_params(self.path)\n        if rest_params is None:\n            web_util.echo_json_response(self, 405, \"Not Implemented: Use /agents/ interface\")\n            return None, None\n\n        if not web_util.validate_api_version(self, cast(str, rest_params[\"api_version\"]), logger):\n            return None, None\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"URI not supported\")\n            logger.warning(\"%s agent returning 400 response. uri not supported: %s\", method, self.path)\n            return None, None\n\n        agent_id = rest_params[\"agents\"]\n\n        if agent_id is None:\n            if respond_on_agent_id_none:\n                web_util.echo_json_response(self, 400, \"agent id not found in uri\")\n                logger.warning(\"%s agent returning 400 response. agent id not found in uri %s\", method, self.path)\n            return rest_params, None\n\n        # If the agent ID is not valid (wrong set of characters), just do nothing.\n        if not validators.valid_agent_id(agent_id):\n            web_util.echo_json_response(self, 400, \"agent_id is not valid\")\n            logger.error(\"%s received an invalid agent ID: %s\", method, agent_id)\n            return None, None\n\n        return rest_params, agent_id\n\n\nclass ProtectedHandler(BaseHandler):\n    def handle(self) -> None:\n        \"\"\"Need to perform SSL handshake here, as\n        do_handshake_on_connect=False for non-blocking SSL socket\"\"\"\n        while True:\n            try:\n                self.request.do_handshake()\n                break\n            except ssl.SSLWantReadError:\n                select.select([self.request], [], [])\n            except ssl.SSLWantWriteError:\n                select.select([], [self.request], [])\n            except ssl.SSLError as e:\n                logger.error(\"SSL connection error: %s\", e)\n                return\n            except Exception as e:\n                logger.error(\"General communication failure: %s\", e)\n                return\n        BaseHTTPRequestHandler.handle(self)\n\n    def do_HEAD(self) -> None:\n        \"\"\"HEAD not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"HEAD not supported\")\n\n    def do_PATCH(self) -> None:\n        \"\"\"PATCH not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"PATCH not supported\")\n\n    def do_GET(self) -> None:\n        \"\"\"This method handles the GET requests to retrieve status on agents from the Registrar Server.\n\n        Currently, only agents resources are available for GETing, i.e. /agents. All other GET uri's\n        will return errors. agents requests require a single agent_id parameter which identifies the\n        agent to be returned. If the agent_id is not found, a 404 response is returned.\n        \"\"\"\n        session = SessionManager().make_session(engine)\n\n        rest_params, agent_id = self._validate_input(\"GET\", False)\n        if not rest_params:\n            return\n\n        if agent_id is not None:\n            try:\n                agent = session.query(RegistrarMain).filter_by(agent_id=agent_id).first()\n            except SQLAlchemyError as e:\n                logger.error(\"SQLAlchemy Error for agent ID %s: %s\", agent_id, e)\n                return\n\n            if agent is None:\n                web_util.echo_json_response(self, 404, f\"agent {agent_id} not found\")\n                logger.warning(\"GET returning 404 response. agent %s not found.\", agent_id)\n                return\n\n            if not bool(agent.active):\n                web_util.echo_json_response(self, 404, f\"agent {agent_id} not yet active\")\n                logger.warning(\"GET returning 404 response. agent %s not yet active.\", agent_id)\n                return\n\n            response = {\n                \"aik_tpm\": agent.aik_tpm,\n                \"ek_tpm\": agent.ek_tpm,\n                \"ekcert\": agent.ekcert,\n                \"mtls_cert\": agent.mtls_cert,\n                \"ip\": agent.ip,\n                \"port\": agent.port,\n                \"regcount\": agent.regcount,\n            }\n\n            if agent.virtual:  # pyright: ignore\n                response[\"provider_keys\"] = agent.provider_keys\n\n            web_util.echo_json_response(self, 200, \"Success\", response)\n            logger.info(\"GET returning 200 response for agent_id: %s\", agent_id)\n        else:\n            # return the available registered uuids from the DB\n            json_response = session.query(RegistrarMain.agent_id).all()\n            return_response = [item[0] for item in json_response]\n            web_util.echo_json_response(self, 200, \"Success\", {\"uuids\": return_response})\n            logger.info(\"GET returning 200 response for agent_id list\")\n\n        return\n\n    def do_POST(self) -> None:\n        \"\"\"POST not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"POST not supported via TLS interface\")\n\n    def do_PUT(self) -> None:\n        \"\"\"PUT not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"PUT not supported via TLS interface\")\n\n    def do_DELETE(self) -> None:\n        \"\"\"This method handles the DELETE requests to remove agents from the Registrar Server.\n\n        Currently, only agents resources are available for DELETEing, i.e. /agents. All other DELETE uri's will return errors.\n        agents requests require a single agent_id parameter which identifies the agent to be deleted.\n        \"\"\"\n        session = SessionManager().make_session(engine)\n\n        rest_params, agent_id = self._validate_input(\"DELETE\", False)\n        if not rest_params:\n            return\n\n        if agent_id is not None:\n            if session.query(RegistrarMain).filter_by(agent_id=agent_id).delete():\n                # send response\n                try:\n                    session.commit()\n                except SQLAlchemyError as e:\n                    logger.error(\"SQLAlchemy Error: %s\", e)\n                web_util.echo_json_response(self, 200, \"Success\")\n                return\n\n            # send response\n            web_util.echo_json_response(self, 404)\n            return\n\n        web_util.echo_json_response(self, 404)\n\n    # pylint: disable=W0622\n    def log_message(self, format: str, *args: Any) -> None:\n        return\n\n\nclass UnprotectedHandler(BaseHandler):\n    def do_HEAD(self) -> None:\n        \"\"\"HEAD not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"HEAD not supported\")\n\n    def do_PATCH(self) -> None:\n        \"\"\"PATCH not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"PATCH not supported\")\n\n    def do_GET(self) -> None:\n        \"\"\"This method handles the GET requests to the unprotected side of the Registrar Server\n\n        Currently the only supported path is /versions which shows the supported API versions\n        \"\"\"\n        rest_params = web_util.get_restful_params(self.path)\n        if rest_params is None:\n            web_util.echo_json_response(self, 405, \"Not Implemented: Use /version/ interface\")\n            return\n\n        if \"version\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"URI not supported\")\n            logger.warning(\"GET agent returning 400 response. URI not supported: %s\", self.path)\n            return\n\n        version_info = {\n            \"current_version\": keylime_api_version.current_version(),\n            \"supported_versions\": keylime_api_version.all_versions(),\n        }\n\n        web_util.echo_json_response(self, 200, \"Success\", version_info)\n\n    @staticmethod\n    def get_network_params(\n        json_body: Dict[str, Any], agent_id: str\n    ) -> Tuple[Optional[str], Optional[int], Optional[str]]:\n        # Validate ip and port\n        ip = json_body.get(\"ip\")\n        if ip is not None:\n            try:\n                ipaddress.ip_address(ip)\n            except ValueError:\n                logger.warning(\"Contact ip for agent %s is not a valid ip got: %s.\", agent_id, ip)\n                ip = None\n\n        port = json_body.get(\"port\")\n        if port is not None:\n            try:\n                port = int(port)\n                if port < 1 or port > 65535:\n                    logger.warning(\n                        \"Contact port for agent %s is not a number between 1 and 65535 got: %s.\", agent_id, port\n                    )\n                    port = None\n            except ValueError:\n                logger.warning(\"Contact port for agent %s is not a valid number got: %s.\", agent_id, port)\n                port = None\n\n        mtls_cert = json_body.get(\"mtls_cert\")\n        if mtls_cert is None or mtls_cert == \"disabled\":\n            logger.warning(\"Agent %s did not send a mTLS certificate. Most operations will not work!\", agent_id)\n\n        return ip, port, mtls_cert\n\n    def do_POST(self) -> None:\n        \"\"\"This method handles the POST requests to add agents to the Registrar Server.\n\n        Currently, only agents resources are available for POSTing, i.e. /agents. All other POST uri's\n        will return errors. POST requests require an an agent_id identifying the agent to add, and json\n        block sent in the body with 2 entries: ek and aik.\n        \"\"\"\n        session = SessionManager().make_session(engine)\n\n        _, agent_id = self._validate_input(\"POST\", True)\n        if not agent_id:\n            return\n\n        try:\n            content_length = int(self.headers.get(\"Content-Length\", 0))\n            if content_length == 0:\n                web_util.echo_json_response(self, 400, \"Expected non zero content length\")\n                logger.warning(\"POST for %s returning 400 response. Expected non zero content length.\", agent_id)\n                return\n\n            post_body = self.rfile.read(content_length)\n            json_body = json.loads(post_body)\n\n            ekcert = json_body[\"ekcert\"]\n            aik_tpm = json_body[\"aik_tpm\"]\n\n            if ekcert is None or ekcert == \"emulator\":\n                logger.warning(\"Agent %s did not submit an ekcert\", agent_id)\n                ek_tpm = json_body[\"ek_tpm\"]\n            else:\n                if \"ek_tpm\" in json_body:\n                    # This would mean the agent submitted both a non-None ekcert, *and*\n                    #  an ek_tpm... We can deal with it by just ignoring the ek_tpm they sent\n                    logger.warning(\"Overriding ek_tpm for agent %s from ekcert\", agent_id)\n                # If there's an EKCert, we just overwrite their ek_tpm\n                # Note, we don't validate the EKCert here, other than the implicit\n                #  \"is it a valid x509 cert\" check. So it's still untrusted.\n                # This will be validated by the tenant.\n                cert = cert_utils.x509_der_cert(base64.b64decode(ekcert))\n                pubkey = cert.public_key()\n                assert isinstance(pubkey, (rsa.RSAPublicKey, ec.EllipticCurvePublicKey))\n                ek_tpm = base64.b64encode(tpm2_objects.ek_low_tpm2b_public_from_pubkey(pubkey)).decode()\n\n            aik_attrs = tpm2_objects.get_tpm2b_public_object_attributes(\n                base64.b64decode(aik_tpm),\n            )\n            if aik_attrs != tpm2_objects.AK_EXPECTED_ATTRS:\n                web_util.echo_json_response(self, 400, \"Invalid AK attributes\")\n                logger.warning(\n                    \"Agent %s submitted AIK with invalid attributes! %s (provided) != %s (expected)\",\n                    agent_id,\n                    tpm2_objects.object_attributes_description(aik_attrs),\n                    tpm2_objects.object_attributes_description(tpm2_objects.AK_EXPECTED_ATTRS),\n                )\n                return\n\n            # try to encrypt the AIK\n            aik_enc = Tpm.encryptAIK(\n                agent_id,\n                base64.b64decode(ek_tpm),\n                base64.b64decode(aik_tpm),\n            )\n            if aik_enc is None:\n                logger.warning(\"Agent %s failed encrypting AIK\", agent_id)\n                web_util.echo_json_response(self, 400, \"Error: failed encrypting AK\")\n                return\n\n            blob, key = aik_enc\n\n            # special behavior if we've registered this uuid before\n            regcount = 1\n            try:\n                agent = session.query(RegistrarMain).filter_by(agent_id=agent_id).first()\n            except NoResultFound:\n                agent = None\n            except SQLAlchemyError as e:\n                logger.error(\"SQLAlchemy Error: %s\", e)\n                raise\n\n            if agent is not None:\n                # keep track of how many ek-ekcerts have registered on this uuid\n                assert isinstance(agent.regcount, int)\n                regcount = agent.regcount\n                if agent.ek_tpm != ek_tpm or agent.ekcert != ekcert:  # pyright: ignore\n                    logger.warning(\"WARNING: Overwriting previous registration for this UUID with new ek-ekcert pair!\")\n                    regcount += 1\n\n                # force overwrite\n                logger.info(\"Overwriting previous registration for this UUID.\")\n                try:\n                    session.query(RegistrarMain).filter_by(agent_id=agent_id).delete()\n                    session.commit()\n                except SQLAlchemyError as e:\n                    logger.error(\"SQLAlchemy Error: %s\", e)\n                    raise\n\n            # Check for ip and port and mTLS cert\n            contact_ip, contact_port, mtls_cert = UnprotectedHandler.get_network_params(json_body, agent_id)\n\n            # Add values to database\n            d: Dict[str, Any] = {\n                \"agent_id\": agent_id,\n                \"ek_tpm\": ek_tpm,\n                \"aik_tpm\": aik_tpm,\n                \"ekcert\": ekcert,\n                \"ip\": contact_ip,\n                \"mtls_cert\": mtls_cert,\n                \"port\": contact_port,\n                \"virtual\": int(ekcert == \"virtual\"),\n                \"active\": int(False),\n                \"key\": key,\n                \"provider_keys\": {},\n                \"regcount\": regcount,\n            }\n\n            try:\n                session.add(RegistrarMain(**d))\n                session.commit()\n            except SQLAlchemyError as e:\n                logger.error(\"SQLAlchemy Error: %s\", e)\n                raise\n\n            if rmc:\n                try:\n                    rmc.record_create(d, None, None)\n\n                except Exception as e:\n                    logger.error(\"Durable Attestation Error: %s\", e)\n                    raise\n\n            response = {\n                \"blob\": blob,\n            }\n            web_util.echo_json_response(self, 200, \"Success\", response)\n\n            logger.info(\"POST returning key blob for agent_id: %s\", agent_id)\n        except Exception as e:\n            web_util.echo_json_response(self, 400, f\"Error: {str(e)}\")\n            logger.warning(\"POST for %s returning 400 response. Error: %s\", agent_id, e)\n            logger.exception(e)\n\n    def do_PUT(self) -> None:\n        \"\"\"This method handles the PUT requests to add agents to the Registrar Server.\n\n        Currently, only agents resources are available for PUTing, i.e. /agents. All other PUT uri's\n        will return errors.\n        \"\"\"\n        session = SessionManager().make_session(engine)\n\n        _, agent_id = self._validate_input(\"PUT\", True)\n        if not agent_id:\n            return\n\n        try:\n            content_length = int(self.headers.get(\"Content-Length\", 0))\n            if content_length == 0:\n                web_util.echo_json_response(self, 400, \"Expected non zero content length\")\n                logger.warning(\"PUT for %s returning 400 response. Expected non zero content length.\", agent_id)\n                return\n\n            post_body = self.rfile.read(content_length)\n            json_body = json.loads(post_body)\n\n            auth_tag = json_body[\"auth_tag\"]\n            try:\n                agent = session.query(RegistrarMain).filter_by(agent_id=agent_id).first()\n            except NoResultFound as e:\n                raise Exception(\"attempting to activate agent before requesting \" f\"registrar for {agent_id}\") from e\n            except SQLAlchemyError as e:\n                logger.error(\"SQLAlchemy Error: %s\", e)\n                raise\n\n            assert agent\n            assert isinstance(agent.key, str)\n            ex_mac = crypto.do_hmac(agent.key.encode(), agent_id)\n            if ex_mac == auth_tag:\n                try:\n                    session.query(RegistrarMain).filter(RegistrarMain.agent_id == agent_id).update(\n                        {\"active\": int(True)}\n                    )\n                    session.commit()\n                except SQLAlchemyError as e:\n                    logger.error(\"SQLAlchemy Error: %s\", e)\n                    raise\n            else:\n                if agent_id and session.query(RegistrarMain).filter_by(agent_id=agent_id).delete():\n                    try:\n                        session.commit()\n                    except SQLAlchemyError as e:\n                        logger.error(\"SQLAlchemy Error: %s\", e)\n                        raise\n\n                raise Exception(\n                    f\"Auth tag {auth_tag} for agent {agent_id} does not match expected value. The agent has been deleted from database, and a restart of it will be required\"\n                )\n\n            web_util.echo_json_response(self, 200, \"Success\")\n            logger.info(\"PUT activated: %s\", agent_id)\n        except Exception as e:\n            web_util.echo_json_response(self, 400, f\"Error: {str(e)}\")\n            logger.warning(\"PUT for %s returning 400 response. Error: %s\", agent_id, e)\n            logger.exception(e)\n            return\n\n    def do_DELETE(self) -> None:\n        \"\"\"DELETE not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"DELETE not supported\")\n\n    # pylint: disable=W0622\n    def log_message(self, format: str, *args: Any) -> None:\n        return\n\n\n# consider using PooledProcessMixIn\n# https://github.com/muayyad-alsadi/python-PooledProcessMixIn\n\n\nclass RegistrarServer(ThreadingMixIn, HTTPServer):\n    \"\"\"Handle requests in a separate thread.\"\"\"\n\n    def __init__(self, server_address: Tuple[str, int], RequestHandlerClass: Any) -> None:\n        \"\"\"Constructor overridden to provide ability to read file\"\"\"\n        bindaddr = server_address[0].strip()\n        if len(bindaddr) > 0 and isinstance(ip_address(bindaddr), IPv6Address):\n            self.address_family = socket.AF_INET6\n        http.server.HTTPServer.__init__(self, server_address, RequestHandlerClass)\n\n    def shutdown(self) -> None:\n        http.server.HTTPServer.shutdown(self)\n\n\ndef start(host: str, tlsport: int, port: int) -> None:\n    \"\"\"Main method of the Registrar Server.  This method is encapsulated in a function for packaging to allow it to be\n    called as a function by an external program.\"\"\"\n\n    # set a conservative general umask\n    os.umask(0o077)\n\n    RegistrarMain.metadata.create_all(engine, checkfirst=True)\n    session = SessionManager().make_session(engine)\n    try:\n        count = session.query(RegistrarMain.agent_id).count()\n        if count > 0:\n            logger.info(\"Loaded %d public keys from database\", count)\n    except SQLAlchemyError as e:\n        logger.error(\"SQLAlchemy Error: %s\", e)\n\n    # Set up the protected registrar server\n    protected_server = RegistrarServer((host, tlsport), ProtectedHandler)\n    context = web_util.init_mtls(\"registrar\", logger=logger)\n    if context is not None:\n        protected_server.socket = context.wrap_socket(\n            protected_server.socket, server_side=True, do_handshake_on_connect=False\n        )\n    thread_protected_server = threading.Thread(target=protected_server.serve_forever)\n\n    # Set up the unprotected registrar server\n    unprotected_server = RegistrarServer((host, port), UnprotectedHandler)\n    thread_unprotected_server = threading.Thread(target=unprotected_server.serve_forever)\n\n    logger.info(\"Starting Cloud Registrar Server on ports %s and %s (TLS) use <Ctrl-C> to stop\", port, tlsport)\n    keylime_api_version.log_api_versions(logger)\n    thread_protected_server.start()\n    thread_unprotected_server.start()\n\n    def signal_handler(signum: int, frame: Any) -> None:\n        del signum, frame\n        logger.info(\"Shutting down Registrar Server...\")\n        protected_server.shutdown()\n        unprotected_server.shutdown()\n        sys.exit(0)\n\n    # Catch these signals.  Note that a SIGKILL cannot be caught, so\n    # killing this process with \"kill -9\" may result in improper shutdown\n    signal.signal(signal.SIGTERM, signal_handler)\n    signal.signal(signal.SIGQUIT, signal_handler)\n    signal.signal(signal.SIGINT, signal_handler)\n\n    thread_protected_server.join()\n    thread_unprotected_server.join()\n"], "filenames": ["keylime/registrar_common.py"], "buggy_code_start_loc": [253], "buggy_code_end_loc": [451], "fixing_code_start_loc": [253], "fixing_code_end_loc": [462], "type": "NVD-CWE-noinfo", "message": "A flaw was found in the Keylime registrar that could allow a bypass of the challenge-response protocol during agent registration. This issue may allow an attacker to impersonate an agent and hide the true status of a monitored machine if the fake agent is added to the verifier list by a legitimate user, resulting in a breach of the integrity of the registrar database.", "other": {"cve": {"id": "CVE-2023-38201", "sourceIdentifier": "secalert@redhat.com", "published": "2023-08-25T17:15:08.530", "lastModified": "2024-01-12T22:01:19.793", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in the Keylime registrar that could allow a bypass of the challenge-response protocol during agent registration. This issue may allow an attacker to impersonate an agent and hide the true status of a monitored machine if the fake agent is added to the verifier list by a legitimate user, resulting in a breach of the integrity of the registrar database."}, {"lang": "es", "value": "Se encontr\u00f3 una falla en el registrador de Keylime que podr\u00eda permitir una omisi\u00f3n del protocolo de desaf\u00edo-respuesta durante el registro del agente. Este problema puede permitir a un atacante suplantar a un agente y ocultar el verdadero estado de un equipo supervisado si un usuario leg\u00edtimo agrega el agente falso a la lista de verificadores, lo que provoca una violaci\u00f3n de la integridad de la base de datos del registrador."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-639"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:keylime:keylime:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.5.0", "matchCriteriaId": "6E69DA87-3EED-4E40-A4CA-495ED6046EE8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:9.2:*:*:*:*:*:*:*", "matchCriteriaId": "3C74F6FA-FA6C-4648-9079-91446E45EE47"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_ibm_z_systems:9.0_s390x:*:*:*:*:*:*:*", "matchCriteriaId": "FB056B47-1F45-4CE4-81F6-872F66C24C29"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_ibm_z_systems_eus:9.2_s390x:*:*:*:*:*:*:*", "matchCriteriaId": "26041661-0280-4544-AA0A-BC28FCED4699"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_little_endian:9.0_ppc64le:*:*:*:*:*:*:*", "matchCriteriaId": "E07C1C58-0E5F-4B56-9B8D-5DE67DB00F79"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_little_endian_eus:9.2_ppc64le:*:*:*:*:*:*:*", "matchCriteriaId": "99952557-C766-4B9E-8BF5-DBBA194349FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:9.2:*:*:*:*:*:*:*", "matchCriteriaId": "F32CA554-F9D7-425B-8F1C-89678507F28C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2023:5080", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/security/cve/CVE-2023-38201", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2222693", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/keylime/keylime/commit/9e5ac9f25cd400b16d5969f531cee28290543f2a", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://github.com/keylime/keylime/security/advisories/GHSA-f4r5-q63f-gcww", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZIZZB5NHNCS5D2AEH3ZAO6OQC72IK7WS/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/keylime/keylime/commit/9e5ac9f25cd400b16d5969f531cee28290543f2a"}}