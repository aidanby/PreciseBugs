{"buggy_code": ["<?php\n\n/**\n * This file is part of CodeIgniter 4 framework.\n *\n * (c) CodeIgniter Foundation <admin@codeigniter.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n */\n\nnamespace CodeIgniter\\Session\\Handlers;\n\nuse CodeIgniter\\Database\\BaseBuilder;\nuse CodeIgniter\\Database\\BaseConnection;\nuse CodeIgniter\\Session\\Exceptions\\SessionException;\nuse Config\\App as AppConfig;\nuse Config\\Database;\nuse ReturnTypeWillChange;\n\n/**\n * Base database session handler\n *\n * Do not use this class. Use database specific handler class.\n */\nclass DatabaseHandler extends BaseHandler\n{\n    /**\n     * The database group to use for storage.\n     *\n     * @var string\n     */\n    protected $DBGroup;\n\n    /**\n     * The name of the table to store session info.\n     *\n     * @var string\n     */\n    protected $table;\n\n    /**\n     * The DB Connection instance.\n     *\n     * @var BaseConnection\n     */\n    protected $db;\n\n    /**\n     * The database type\n     *\n     * @var string\n     */\n    protected $platform;\n\n    /**\n     * Row exists flag\n     *\n     * @var bool\n     */\n    protected $rowExists = false;\n\n    /**\n     * @throws SessionException\n     */\n    public function __construct(AppConfig $config, string $ipAddress)\n    {\n        parent::__construct($config, $ipAddress);\n        $this->table = $config->sessionSavePath;\n\n        if (empty($this->table)) {\n            throw SessionException::forMissingDatabaseTable();\n        }\n\n        $this->DBGroup = $config->sessionDBGroup ?? config(Database::class)->defaultGroup;\n\n        $this->db = Database::connect($this->DBGroup);\n\n        $this->platform = $this->db->getPlatform();\n    }\n\n    /**\n     * Re-initialize existing session, or creates a new one.\n     *\n     * @param string $path The path where to store/retrieve the session\n     * @param string $name The session name\n     */\n    public function open($path, $name): bool\n    {\n        if (empty($this->db->connID)) {\n            $this->db->initialize();\n        }\n\n        return true;\n    }\n\n    /**\n     * Reads the session data from the session storage, and returns the results.\n     *\n     * @param string $id The session ID\n     *\n     * @return false|string Returns an encoded string of the read data.\n     *                      If nothing was read, it must return false.\n     */\n    #[ReturnTypeWillChange]\n    public function read($id)\n    {\n        if ($this->lockSession($id) === false) {\n            $this->fingerprint = md5('');\n\n            return '';\n        }\n\n        if (! isset($this->sessionID)) {\n            $this->sessionID = $id;\n        }\n\n        $builder = $this->db->table($this->table)->where('id', $id);\n\n        if ($this->matchIP) {\n            $builder = $builder->where('ip_address', $this->ipAddress);\n        }\n\n        $this->setSelect($builder);\n\n        $result = $builder->get()->getRow();\n\n        if ($result === null) {\n            // PHP7 will reuse the same SessionHandler object after\n            // ID regeneration, so we need to explicitly set this to\n            // FALSE instead of relying on the default ...\n            $this->rowExists   = false;\n            $this->fingerprint = md5('');\n\n            return '';\n        }\n\n        $result = is_bool($result) ? '' : $this->decodeData($result->data);\n\n        $this->fingerprint = md5($result);\n        $this->rowExists   = true;\n\n        return $result;\n    }\n\n    /**\n     * Sets SELECT clause\n     */\n    protected function setSelect(BaseBuilder $builder)\n    {\n        $builder->select('data');\n    }\n\n    /**\n     * Decodes column data\n     *\n     * @param mixed $data\n     *\n     * @return false|string\n     */\n    protected function decodeData($data)\n    {\n        return $data;\n    }\n\n    /**\n     * Writes the session data to the session storage.\n     *\n     * @param string $id   The session ID\n     * @param string $data The encoded session data\n     */\n    public function write($id, $data): bool\n    {\n        if ($this->lock === false) {\n            return $this->fail();\n        }\n\n        if ($this->sessionID !== $id) {\n            $this->rowExists = false;\n            $this->sessionID = $id;\n        }\n\n        if ($this->rowExists === false) {\n            $insertData = [\n                'id'         => $id,\n                'ip_address' => $this->ipAddress,\n                'data'       => $this->prepareData($data),\n            ];\n\n            if (! $this->db->table($this->table)->set('timestamp', 'now()', false)->insert($insertData)) {\n                return $this->fail();\n            }\n\n            $this->fingerprint = md5($data);\n            $this->rowExists   = true;\n\n            return true;\n        }\n\n        $builder = $this->db->table($this->table)->where('id', $id);\n\n        if ($this->matchIP) {\n            $builder = $builder->where('ip_address', $this->ipAddress);\n        }\n\n        $updateData = [];\n\n        if ($this->fingerprint !== md5($data)) {\n            $updateData['data'] = $this->prepareData($data);\n        }\n\n        if (! $builder->set('timestamp', 'now()', false)->update($updateData)) {\n            return $this->fail();\n        }\n\n        $this->fingerprint = md5($data);\n\n        return true;\n    }\n\n    /**\n     * Prepare data to insert/update\n     */\n    protected function prepareData(string $data): string\n    {\n        return $data;\n    }\n\n    /**\n     * Closes the current session.\n     */\n    public function close(): bool\n    {\n        return ($this->lock && ! $this->releaseLock()) ? $this->fail() : true;\n    }\n\n    /**\n     * Destroys a session\n     *\n     * @param string $id The session ID being destroyed\n     */\n    public function destroy($id): bool\n    {\n        if ($this->lock) {\n            $builder = $this->db->table($this->table)->where('id', $id);\n\n            if ($this->matchIP) {\n                $builder = $builder->where('ip_address', $this->ipAddress);\n            }\n\n            if (! $builder->delete()) {\n                return $this->fail();\n            }\n        }\n\n        if ($this->close()) {\n            $this->destroyCookie();\n\n            return true;\n        }\n\n        return $this->fail();\n    }\n\n    /**\n     * Cleans up expired sessions.\n     *\n     * @param int $max_lifetime Sessions that have not updated\n     *                          for the last max_lifetime seconds will be removed.\n     *\n     * @return false|int Returns the number of deleted sessions on success, or false on failure.\n     */\n    #[ReturnTypeWillChange]\n    public function gc($max_lifetime)\n    {\n        $separator = ' ';\n        $interval  = implode($separator, ['', \"{$max_lifetime} second\", '']);\n\n        return $this->db->table($this->table)->where('timestamp <', \"now() - INTERVAL {$interval}\", false)->delete() ? 1 : $this->fail();\n    }\n\n    /**\n     * Releases the lock, if any.\n     */\n    protected function releaseLock(): bool\n    {\n        if (! $this->lock) {\n            return true;\n        }\n\n        // Unsupported DB? Let the parent handle the simple version.\n        return parent::releaseLock();\n    }\n}\n", "<?php\n\n/**\n * This file is part of CodeIgniter 4 framework.\n *\n * (c) CodeIgniter Foundation <admin@codeigniter.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n */\n\nnamespace CodeIgniter\\Session\\Handlers;\n\nuse CodeIgniter\\I18n\\Time;\nuse CodeIgniter\\Session\\Exceptions\\SessionException;\nuse Config\\App as AppConfig;\nuse Memcached;\nuse ReturnTypeWillChange;\n\n/**\n * Session handler using Memcache for persistence\n */\nclass MemcachedHandler extends BaseHandler\n{\n    /**\n     * Memcached instance\n     *\n     * @var Memcached|null\n     */\n    protected $memcached;\n\n    /**\n     * Key prefix\n     *\n     * @var string\n     */\n    protected $keyPrefix = 'ci_session:';\n\n    /**\n     * Lock key\n     *\n     * @var string|null\n     */\n    protected $lockKey;\n\n    /**\n     * Number of seconds until the session ends.\n     *\n     * @var int\n     */\n    protected $sessionExpiration = 7200;\n\n    /**\n     * @throws SessionException\n     */\n    public function __construct(AppConfig $config, string $ipAddress)\n    {\n        parent::__construct($config, $ipAddress);\n\n        if (empty($this->savePath)) {\n            throw SessionException::forEmptySavepath();\n        }\n\n        if ($this->matchIP === true) {\n            $this->keyPrefix .= $this->ipAddress . ':';\n        }\n\n        if (! empty($this->keyPrefix)) {\n            ini_set('memcached.sess_prefix', $this->keyPrefix);\n        }\n\n        $this->sessionExpiration = $config->sessionExpiration;\n    }\n\n    /**\n     * Re-initialize existing session, or creates a new one.\n     *\n     * @param string $path The path where to store/retrieve the session\n     * @param string $name The session name\n     */\n    public function open($path, $name): bool\n    {\n        $this->memcached = new Memcached();\n        $this->memcached->setOption(Memcached::OPT_BINARY_PROTOCOL, true); // required for touch() usage\n\n        $serverList = [];\n\n        foreach ($this->memcached->getServerList() as $server) {\n            $serverList[] = $server['host'] . ':' . $server['port'];\n        }\n\n        if (! preg_match_all('#,?([^,:]+)\\:(\\d{1,5})(?:\\:(\\d+))?#', $this->savePath, $matches, PREG_SET_ORDER)) {\n            $this->memcached = null;\n            $this->logger->error('Session: Invalid Memcached save path format: ' . $this->savePath);\n\n            return false;\n        }\n\n        foreach ($matches as $match) {\n            // If Memcached already has this server (or if the port is invalid), skip it\n            if (in_array($match[1] . ':' . $match[2], $serverList, true)) {\n                $this->logger->debug('Session: Memcached server pool already has ' . $match[1] . ':' . $match[2]);\n\n                continue;\n            }\n\n            if (! $this->memcached->addServer($match[1], (int) $match[2], $match[3] ?? 0)) {\n                $this->logger->error('Could not add ' . $match[1] . ':' . $match[2] . ' to Memcached server pool.');\n            } else {\n                $serverList[] = $match[1] . ':' . $match[2];\n            }\n        }\n\n        if (empty($serverList)) {\n            $this->logger->error('Session: Memcached server pool is empty.');\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Reads the session data from the session storage, and returns the results.\n     *\n     * @param string $id The session ID\n     *\n     * @return false|string Returns an encoded string of the read data.\n     *                      If nothing was read, it must return false.\n     */\n    #[ReturnTypeWillChange]\n    public function read($id)\n    {\n        if (isset($this->memcached) && $this->lockSession($id)) {\n            if (! isset($this->sessionID)) {\n                $this->sessionID = $id;\n            }\n\n            $data = (string) $this->memcached->get($this->keyPrefix . $id);\n\n            $this->fingerprint = md5($data);\n\n            return $data;\n        }\n\n        return '';\n    }\n\n    /**\n     * Writes the session data to the session storage.\n     *\n     * @param string $id   The session ID\n     * @param string $data The encoded session data\n     */\n    public function write($id, $data): bool\n    {\n        if (! isset($this->memcached)) {\n            return false;\n        }\n\n        if ($this->sessionID !== $id) {\n            if (! $this->releaseLock() || ! $this->lockSession($id)) {\n                return false;\n            }\n\n            $this->fingerprint = md5('');\n            $this->sessionID   = $id;\n        }\n\n        if (isset($this->lockKey)) {\n            $this->memcached->replace($this->lockKey, Time::now()->getTimestamp(), 300);\n\n            if ($this->fingerprint !== ($fingerprint = md5($data))) {\n                if ($this->memcached->set($this->keyPrefix . $id, $data, $this->sessionExpiration)) {\n                    $this->fingerprint = $fingerprint;\n\n                    return true;\n                }\n\n                return false;\n            }\n\n            return $this->memcached->touch($this->keyPrefix . $id, $this->sessionExpiration);\n        }\n\n        return false;\n    }\n\n    /**\n     * Closes the current session.\n     */\n    public function close(): bool\n    {\n        if (isset($this->memcached)) {\n            if (isset($this->lockKey)) {\n                $this->memcached->delete($this->lockKey);\n            }\n\n            if (! $this->memcached->quit()) {\n                return false;\n            }\n\n            $this->memcached = null;\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys a session\n     *\n     * @param string $id The session ID being destroyed\n     */\n    public function destroy($id): bool\n    {\n        if (isset($this->memcached, $this->lockKey)) {\n            $this->memcached->delete($this->keyPrefix . $id);\n\n            return $this->destroyCookie();\n        }\n\n        return false;\n    }\n\n    /**\n     * Cleans up expired sessions.\n     *\n     * @param int $max_lifetime Sessions that have not updated\n     *                          for the last max_lifetime seconds will be removed.\n     *\n     * @return false|int Returns the number of deleted sessions on success, or false on failure.\n     */\n    #[ReturnTypeWillChange]\n    public function gc($max_lifetime)\n    {\n        return 1;\n    }\n\n    /**\n     * Acquires an emulated lock.\n     *\n     * @param string $sessionID Session ID\n     */\n    protected function lockSession(string $sessionID): bool\n    {\n        if (isset($this->lockKey)) {\n            return $this->memcached->replace($this->lockKey, Time::now()->getTimestamp(), 300);\n        }\n\n        $lockKey = $this->keyPrefix . $sessionID . ':lock';\n        $attempt = 0;\n\n        do {\n            if ($this->memcached->get($lockKey)) {\n                sleep(1);\n\n                continue;\n            }\n\n            if (! $this->memcached->set($lockKey, Time::now()->getTimestamp(), 300)) {\n                $this->logger->error('Session: Error while trying to obtain lock for ' . $this->keyPrefix . $sessionID);\n\n                return false;\n            }\n\n            $this->lockKey = $lockKey;\n            break;\n        } while (++$attempt < 30);\n\n        if ($attempt === 30) {\n            $this->logger->error('Session: Unable to obtain lock for ' . $this->keyPrefix . $sessionID . ' after 30 attempts, aborting.');\n\n            return false;\n        }\n\n        $this->lock = true;\n\n        return true;\n    }\n\n    /**\n     * Releases a previously acquired lock\n     */\n    protected function releaseLock(): bool\n    {\n        if (isset($this->memcached, $this->lockKey) && $this->lock) {\n            if (\n                ! $this->memcached->delete($this->lockKey)\n                && $this->memcached->getResultCode() !== Memcached::RES_NOTFOUND\n            ) {\n                $this->logger->error('Session: Error while trying to free lock for ' . $this->lockKey);\n\n                return false;\n            }\n\n            $this->lockKey = null;\n            $this->lock    = false;\n        }\n\n        return true;\n    }\n}\n", "<?php\n\n/**\n * This file is part of CodeIgniter 4 framework.\n *\n * (c) CodeIgniter Foundation <admin@codeigniter.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n */\n\nnamespace CodeIgniter\\Session\\Handlers;\n\nuse CodeIgniter\\I18n\\Time;\nuse CodeIgniter\\Session\\Exceptions\\SessionException;\nuse Config\\App as AppConfig;\nuse Redis;\nuse RedisException;\nuse ReturnTypeWillChange;\n\n/**\n * Session handler using Redis for persistence\n */\nclass RedisHandler extends BaseHandler\n{\n    private const DEFAULT_PORT = 6379;\n\n    /**\n     * phpRedis instance\n     *\n     * @var Redis|null\n     */\n    protected $redis;\n\n    /**\n     * Key prefix\n     *\n     * @var string\n     */\n    protected $keyPrefix = 'ci_session:';\n\n    /**\n     * Lock key\n     *\n     * @var string|null\n     */\n    protected $lockKey;\n\n    /**\n     * Key exists flag\n     *\n     * @var bool\n     */\n    protected $keyExists = false;\n\n    /**\n     * Number of seconds until the session ends.\n     *\n     * @var int\n     */\n    protected $sessionExpiration = 7200;\n\n    /**\n     * @param string $ipAddress User's IP address\n     *\n     * @throws SessionException\n     */\n    public function __construct(AppConfig $config, string $ipAddress)\n    {\n        parent::__construct($config, $ipAddress);\n\n        $this->setSavePath();\n\n        if ($this->matchIP === true) {\n            $this->keyPrefix .= $this->ipAddress . ':';\n        }\n\n        $this->sessionExpiration = empty($config->sessionExpiration)\n            ? (int) ini_get('session.gc_maxlifetime')\n            : (int) $config->sessionExpiration;\n    }\n\n    protected function setSavePath(): void\n    {\n        if (empty($this->savePath)) {\n            throw SessionException::forEmptySavepath();\n        }\n\n        if (preg_match('#(?:tcp://)?([^:?]+)(?:\\:(\\d+))?(\\?.+)?#', $this->savePath, $matches)) {\n            if (! isset($matches[3])) {\n                $matches[3] = ''; // Just to avoid undefined index notices below\n            }\n\n            $this->savePath = [\n                'host'     => $matches[1],\n                'port'     => empty($matches[2]) ? self::DEFAULT_PORT : $matches[2],\n                'password' => preg_match('#auth=([^\\s&]+)#', $matches[3], $match) ? $match[1] : null,\n                'database' => preg_match('#database=(\\d+)#', $matches[3], $match) ? (int) $match[1] : 0,\n                'timeout'  => preg_match('#timeout=(\\d+\\.\\d+|\\d+)#', $matches[3], $match) ? (float) $match[1] : 0.0,\n            ];\n\n            preg_match('#prefix=([^\\s&]+)#', $matches[3], $match) && $this->keyPrefix = $match[1];\n        } else {\n            throw SessionException::forInvalidSavePathFormat($this->savePath);\n        }\n    }\n\n    /**\n     * Re-initialize existing session, or creates a new one.\n     *\n     * @param string $path The path where to store/retrieve the session\n     * @param string $name The session name\n     */\n    public function open($path, $name): bool\n    {\n        if (empty($this->savePath)) {\n            return false;\n        }\n\n        $redis = new Redis();\n\n        if (! $redis->connect($this->savePath['host'], ($this->savePath['host'][0] === '/' ? 0 : $this->savePath['port']), $this->savePath['timeout'])) {\n            $this->logger->error('Session: Unable to connect to Redis with the configured settings.');\n        } elseif (isset($this->savePath['password']) && ! $redis->auth($this->savePath['password'])) {\n            $this->logger->error('Session: Unable to authenticate to Redis instance.');\n        } elseif (isset($this->savePath['database']) && ! $redis->select($this->savePath['database'])) {\n            $this->logger->error('Session: Unable to select Redis database with index ' . $this->savePath['database']);\n        } else {\n            $this->redis = $redis;\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Reads the session data from the session storage, and returns the results.\n     *\n     * @param string $id The session ID\n     *\n     * @return false|string Returns an encoded string of the read data.\n     *                      If nothing was read, it must return false.\n     */\n    #[ReturnTypeWillChange]\n    public function read($id)\n    {\n        if (isset($this->redis) && $this->lockSession($id)) {\n            if (! isset($this->sessionID)) {\n                $this->sessionID = $id;\n            }\n\n            $data = $this->redis->get($this->keyPrefix . $id);\n\n            if (is_string($data)) {\n                $this->keyExists = true;\n            } else {\n                $data = '';\n            }\n\n            $this->fingerprint = md5($data);\n\n            return $data;\n        }\n\n        return '';\n    }\n\n    /**\n     * Writes the session data to the session storage.\n     *\n     * @param string $id   The session ID\n     * @param string $data The encoded session data\n     */\n    public function write($id, $data): bool\n    {\n        if (! isset($this->redis)) {\n            return false;\n        }\n\n        if ($this->sessionID !== $id) {\n            if (! $this->releaseLock() || ! $this->lockSession($id)) {\n                return false;\n            }\n\n            $this->keyExists = false;\n            $this->sessionID = $id;\n        }\n\n        if (isset($this->lockKey)) {\n            $this->redis->expire($this->lockKey, 300);\n\n            if ($this->fingerprint !== ($fingerprint = md5($data)) || $this->keyExists === false) {\n                if ($this->redis->set($this->keyPrefix . $id, $data, $this->sessionExpiration)) {\n                    $this->fingerprint = $fingerprint;\n                    $this->keyExists   = true;\n\n                    return true;\n                }\n\n                return false;\n            }\n\n            return $this->redis->expire($this->keyPrefix . $id, $this->sessionExpiration);\n        }\n\n        return false;\n    }\n\n    /**\n     * Closes the current session.\n     */\n    public function close(): bool\n    {\n        if (isset($this->redis)) {\n            try {\n                $pingReply = $this->redis->ping();\n\n                if (($pingReply === true) || ($pingReply === '+PONG')) {\n                    if (isset($this->lockKey)) {\n                        $this->redis->del($this->lockKey);\n                    }\n\n                    if (! $this->redis->close()) {\n                        return false;\n                    }\n                }\n            } catch (RedisException $e) {\n                $this->logger->error('Session: Got RedisException on close(): ' . $e->getMessage());\n            }\n\n            $this->redis = null;\n\n            return true;\n        }\n\n        return true;\n    }\n\n    /**\n     * Destroys a session\n     *\n     * @param string $id The session ID being destroyed\n     */\n    public function destroy($id): bool\n    {\n        if (isset($this->redis, $this->lockKey)) {\n            if (($result = $this->redis->del($this->keyPrefix . $id)) !== 1) {\n                $this->logger->debug('Session: Redis::del() expected to return 1, got ' . var_export($result, true) . ' instead.');\n            }\n\n            return $this->destroyCookie();\n        }\n\n        return false;\n    }\n\n    /**\n     * Cleans up expired sessions.\n     *\n     * @param int $max_lifetime Sessions that have not updated\n     *                          for the last max_lifetime seconds will be removed.\n     *\n     * @return false|int Returns the number of deleted sessions on success, or false on failure.\n     */\n    #[ReturnTypeWillChange]\n    public function gc($max_lifetime)\n    {\n        return 1;\n    }\n\n    /**\n     * Acquires an emulated lock.\n     *\n     * @param string $sessionID Session ID\n     */\n    protected function lockSession(string $sessionID): bool\n    {\n        $lockKey = $this->keyPrefix . $sessionID . ':lock';\n\n        // PHP 7 reuses the SessionHandler object on regeneration,\n        // so we need to check here if the lock key is for the\n        // correct session ID.\n        if ($this->lockKey === $lockKey) {\n            return $this->redis->expire($this->lockKey, 300);\n        }\n\n        $attempt = 0;\n\n        do {\n            if (($ttl = $this->redis->ttl($lockKey)) > 0) {\n                sleep(1);\n\n                continue;\n            }\n\n            if (! $this->redis->setex($lockKey, 300, (string) Time::now()->getTimestamp())) {\n                $this->logger->error('Session: Error while trying to obtain lock for ' . $this->keyPrefix . $sessionID);\n\n                return false;\n            }\n\n            $this->lockKey = $lockKey;\n            break;\n        } while (++$attempt < 30);\n\n        if ($attempt === 30) {\n            log_message('error', 'Session: Unable to obtain lock for ' . $this->keyPrefix . $sessionID . ' after 30 attempts, aborting.');\n\n            return false;\n        }\n\n        if ($ttl === -1) {\n            log_message('debug', 'Session: Lock for ' . $this->keyPrefix . $sessionID . ' had no TTL, overriding.');\n        }\n\n        $this->lock = true;\n\n        return true;\n    }\n\n    /**\n     * Releases a previously acquired lock\n     */\n    protected function releaseLock(): bool\n    {\n        if (isset($this->redis, $this->lockKey) && $this->lock) {\n            if (! $this->redis->del($this->lockKey)) {\n                $this->logger->error('Session: Error while trying to free lock for ' . $this->lockKey);\n\n                return false;\n            }\n\n            $this->lockKey = null;\n            $this->lock    = false;\n        }\n\n        return true;\n    }\n}\n", "Version 4.2.11\n##############\n\nRelease Date: December 21, 2022\n\n**4.2.11 release of CodeIgniter4**\n\n.. contents::\n    :local:\n    :depth: 2\n\nSECURITY\n********\n\n- *Attackers may spoof IP address when using proxy* was fixed. See the `Security advisory GHSA-ghw3-5qvm-3mqc <https://github.com/codeigniter4/CodeIgniter4/security/advisories/GHSA-ghw3-5qvm-3mqc>`_ for more information.\n\nBREAKING\n********\n\n- The ``Config\\App::$proxyIPs`` value format has been changed. See :ref:`Upgrading Guide <upgrade-4211-proxyips>`.\n\nBugs Fixed\n**********\n\n- Fixed a ``FileLocator::locateFile()`` bug where a similar namespace name could be replaced by another, causing a failure to find a file that exists.\n- Fixed a ``RedisHandler`` session class to use the correct config when used with a socket connection.\n\nSee the repo's `CHANGELOG.md <https://github.com/codeigniter4/CodeIgniter4/blob/develop/CHANGELOG.md>`_ for a complete list of bugs fixed.\n", "###############################\nUpgrading from 4.2.10 to 4.2.11\n###############################\n\nPlease refer to the upgrade instructions corresponding to your installation method.\n\n- :ref:`Composer Installation App Starter Upgrading <app-starter-upgrading>`\n- :ref:`Composer Installation Adding CodeIgniter4 to an Existing Project Upgrading <adding-codeigniter4-upgrading>`\n- :ref:`Manual Installation Upgrading <installing-manual-upgrading>`\n\n.. contents::\n    :local:\n    :depth: 2\n\nBreaking Changes\n****************\n\n.. _upgrade-4211-proxyips:\n\nConfig\\\\App::$proxyIPs\n======================\n\nThe config value format has been changed. Now you must set your proxy IP address and the HTTP header name for the client IP address pair as an array::\n\n    public $proxyIPs = [\n            '10.0.1.200'     => 'X-Forwarded-For',\n            '192.168.5.0/24' => 'X-Forwarded-For',\n    ];\n\n``ConfigException`` will be thrown for old format config value.\n\nProject Files\n*************\n\nVersion ``4.2.11`` did not alter any executable code in project files.\n\nAll Changes\n===========\n\nThis is a list of all files in the **project space** that received changes;\nmany will be simple comments or formatting that have no effect on the runtime:\n\n* app/Config/App.php\n* app/Config/Autoload.php\n* app/Config/Logger.php\n* app/Config/Toolbar.php\n* app/Views/welcome_message.php\n* composer.json\n", "###############\nSession Library\n###############\n\nThe Session class permits you to maintain a user's \"state\" and track their\nactivity while they browse your site.\n\nCodeIgniter comes with a few session storage drivers, that you can see\nin the last section of the table of contents:\n\n.. contents::\n    :local:\n    :depth: 2\n\nUsing the Session Class\n***********************\n\nInitializing a Session\n======================\n\nSessions will typically run globally with each page load, so the Session\nclass should be magically initialized.\n\nTo access and initialize the session:\n\n.. literalinclude:: sessions/001.php\n\nThe ``$config`` parameter is optional - your application configuration.\nIf not provided, the services register will instantiate your default\none.\n\nOnce loaded, the Sessions library object will be available using::\n\n    $session\n\nAlternatively, you can use the helper function that will use the default\nconfiguration options. This version is a little friendlier to read,\nbut does not take any configuration options.\n\n.. literalinclude:: sessions/002.php\n\nHow do Sessions work?\n=====================\n\nWhen a page is loaded, the session class will check to see if a valid\nsession cookie is sent by the user's browser. If a sessions cookie does\n**not** exist (or if it doesn't match one stored on the server or has\nexpired) a new session will be created and saved.\n\nIf a valid session does exist, its information will be updated. With each\nupdate, the session ID may be regenerated if configured to do so.\n\nIt's important for you to understand that once initialized, the Session\nclass runs automatically. There is nothing you need to do to cause the\nabove behavior to happen. You can, as you'll see below, work with session\ndata, but the process of reading, writing, and updating a session is\nautomatic.\n\n.. note:: Under CLI, the Session library will automatically halt itself,\n    as this is a concept based entirely on the HTTP protocol.\n\nA note about concurrency\n------------------------\n\nUnless you're developing a website with heavy AJAX usage, you can skip this\nsection. If you are, however, and if you're experiencing performance\nissues, then this note is exactly what you're looking for.\n\nSessions in CodeIgniter v2.x didn't implement locking,\nwhich meant that two HTTP requests using the same session could run exactly\nat the same time. To use a more appropriate technical term - requests were\nnon-blocking.\n\nHowever, non-blocking requests in the context of sessions also means\nunsafe, because, modifications to session data (or session ID regeneration)\nin one request can interfere with the execution of a second, concurrent\nrequest. This detail was at the root of many issues and the main reason why\nCodeIgniter 3 has a completely re-written Session library.\n\nWhy are we telling you this? Because it is likely that after trying to\nfind the reason for your performance issues, you may conclude that locking\nis the issue and therefore look into how to remove the locks ...\n\nDO NOT DO THAT! Removing locks would be **wrong** and it will cause you\nmore problems!\n\nLocking is not the issue, it is a solution. Your issue is that you still\nhave the session open, while you've already processed it and therefore no\nlonger need it. So, what you need is to close the session for the\ncurrent request after you no longer need it.\n\n.. literalinclude:: sessions/003.php\n\nWhat is Session Data?\n=====================\n\nSession data is simply an array associated with a particular session ID\n(cookie).\n\nIf you've used sessions in PHP before, you should be familiar with PHP's\n`$_SESSION superglobal <https://www.php.net/manual/en/reserved.variables.session.php>`_\n(if not, please read the content on that link).\n\nCodeIgniter gives access to its session data through the same means, as it\nuses the session handlers' mechanism provided by PHP. Using session data is\nas simple as manipulating (read, set and unset values) the ``$_SESSION``\narray.\n\n.. note:: In general, it is bad practice to use global variables.\n    So using the superglobal ``$_SESSION`` directly is not recommended.\n\nIn addition, CodeIgniter also provides 2 special types of session data\nthat are further explained below: `Flashdata`_ and `Tempdata`_.\n\n.. note:: For historical reasons, we refer to session data excluding Flashdata and Tempdata as \"userdata\".\n\nRetrieving Session Data\n=======================\n\nAny piece of information from the session array is available through the\n``$_SESSION`` superglobal:\n\n.. literalinclude:: sessions/004.php\n\nOr through the conventional accessor method:\n\n.. literalinclude:: sessions/005.php\n\nOr through the magic getter:\n\n.. literalinclude:: sessions/006.php\n\nOr even through the session helper method:\n\n.. literalinclude:: sessions/007.php\n\nWhere ``item`` is the array key corresponding to the item you wish to fetch.\nFor example, to assign a previously stored ``name`` item to the ``$name``\nvariable, you will do this:\n\n.. literalinclude:: sessions/008.php\n\n.. note:: The ``get()`` method returns null if the item you are trying\n    to access does not exist.\n\nIf you want to retrieve all of the existing session data, you can simply\nomit the item key (magic getter only works for single property values):\n\n.. literalinclude:: sessions/009.php\n\n.. important:: The ``get()`` method WILL return flashdata or tempdata items when\n    retrieving a single item by key. It will not return flashdata or tempdata when\n    grabbing all data from the session, however.\n\nAdding Session Data\n===================\n\nLet's say a particular user logs into your site. Once authenticated, you\ncould add their username and e-mail address to the session, making that\ndata globally available to you without having to run a database query when\nyou need it.\n\nYou can simply assign data to the ``$_SESSION`` array, as with any other\nvariable. Or as a property of ``$session``.\n\nYou can pass an array containing your new session data to the\n``set()`` method:\n\n.. literalinclude:: sessions/010.php\n\nWhere ``$array`` is an associative array containing your new data. Here's\nan example:\n\n.. literalinclude:: sessions/011.php\n\nIf you want to add session data one value at a time, ``set()`` also\nsupports this syntax:\n\n.. literalinclude:: sessions/012.php\n\nIf you want to verify that a session value exists, simply check with\n``isset()``:\n\n.. literalinclude:: sessions/013.php\n\nOr you can call ``has()``:\n\n.. literalinclude:: sessions/014.php\n\nPushing New Value to Session Data\n=================================\n\nThe ``push()`` method is used to push a new value onto a session value that is an array.\nFor instance, if the ``hobbies`` key contains an array of hobbies, you can add a new value onto the array like so:\n\n.. literalinclude:: sessions/015.php\n\nRemoving Session Data\n=====================\n\nJust as with any other variable, unsetting a value in ``$_SESSION`` can be\ndone through ``unset()``:\n\n.. literalinclude:: sessions/016.php\n\nAlso, just as ``set()`` can be used to add information to a\nsession, ``remove()`` can be used to remove it, by passing the\nsession key. For example, if you wanted to remove ``some_name`` from your\nsession data array:\n\n.. literalinclude:: sessions/017.php\n\nThis method also accepts an array of item keys to unset:\n\n.. literalinclude:: sessions/018.php\n\nFlashdata\n=========\n\nCodeIgniter supports \"flashdata\", or session data that will only be\navailable for the next request, and is then automatically cleared.\n\nThis can be very useful, especially for one-time informational, error or\nstatus messages (for example: \"Record 2 deleted\").\n\nIt should be noted that flashdata variables are regular session variables,\nmanaged inside the CodeIgniter session handler.\n\nTo mark an existing item as \"flashdata\":\n\n.. literalinclude:: sessions/019.php\n\nIf you want to mark multiple items as flashdata, simply pass the keys as an\narray:\n\n.. literalinclude:: sessions/020.php\n\nTo add flashdata:\n\n.. literalinclude:: sessions/021.php\n\nOr alternatively, using the ``setFlashdata()`` method:\n\n.. literalinclude:: sessions/022.php\n\nYou can also pass an array to ``setFlashdata()``, in the same manner as\n``set()``.\n\nReading flashdata variables is the same as reading regular session data\nthrough ``$_SESSION``:\n\n.. literalinclude:: sessions/023.php\n\n.. important:: The ``get()`` method WILL return flashdata items when\n    retrieving a single item by key. It will not return flashdata when\n    grabbing all data from the session, however.\n\nHowever, if you want to be sure that you're reading \"flashdata\" (and not\nany other kind), you can also use the ``getFlashdata()`` method:\n\n.. literalinclude:: sessions/024.php\n\n.. note:: The ``getFlashdata()`` method returns null if the item cannot be\n    found.\n\nOr to get an array with all flashdata, simply omit the key parameter:\n\n.. literalinclude:: sessions/025.php\n\n\nIf you find that you need to preserve a flashdata variable through an\nadditional request, you can do so using the ``keepFlashdata()`` method.\nYou can either pass a single item or an array of flashdata items to keep.\n\n.. literalinclude:: sessions/026.php\n\nTempdata\n========\n\nCodeIgniter also supports \"tempdata\", or session data with a specific\nexpiration time. After the value expires, or the session expires or is\ndeleted, the value is automatically removed.\n\nSimilarly to flashdata, tempdata variables are managed internally by the\nCodeIgniter session handler.\n\nTo mark an existing item as \"tempdata\", simply pass its key and expiry time\n(in seconds!) to the ``markAsTempdata()`` method:\n\n.. literalinclude:: sessions/027.php\n\nYou can mark multiple items as tempdata in two ways, depending on whether\nyou want them all to have the same expiry time or not:\n\n.. literalinclude:: sessions/028.php\n\nTo add tempdata:\n\n.. literalinclude:: sessions/029.php\n\nOr alternatively, using the ``setTempdata()`` method:\n\n.. literalinclude:: sessions/030.php\n\nYou can also pass an array to ``setTempdata()``:\n\n.. literalinclude:: sessions/031.php\n\n.. note:: If the expiration is omitted or set to 0, the default\n    time-to-live value of 300 seconds (or 5 minutes) will be used.\n\nTo read a tempdata variable, again you can just access it through the\n``$_SESSION`` superglobal array:\n\n.. literalinclude:: sessions/032.php\n\n.. important:: The ``get()`` method WILL return tempdata items when\n    retrieving a single item by key. It will not return tempdata when\n    grabbing all data from the session, however.\n\nOr if you want to be sure that you're reading \"tempdata\" (and not any\nother kind), you can also use the ``getTempdata()`` method:\n\n.. literalinclude:: sessions/033.php\n\n.. note:: The ``getTempdata()`` method returns null if the item cannot be\n    found.\n\nAnd of course, if you want to retrieve all existing tempdata:\n\n.. literalinclude:: sessions/034.php\n\nIf you need to remove a tempdata value before it expires, you can directly\nunset it from the ``$_SESSION`` array:\n\n.. literalinclude:: sessions/035.php\n\nHowever, this won't remove the marker that makes this specific item to be\ntempdata (it will be invalidated on the next HTTP request), so if you\nintend to reuse that same key in the same request, you'd want to use\n``removeTempdata()``:\n\n.. literalinclude:: sessions/036.php\n\nDestroying a Session\n====================\n\nTo clear the current session (for example, during a logout), you may\nsimply use either PHP's `session_destroy() <https://www.php.net/session_destroy>`_\nfunction, or the library's ``destroy()`` method. Both will work in exactly the\nsame way:\n\n.. literalinclude:: sessions/037.php\n\n.. note:: This must be the last session-related operation that you do\n    during the same request. All session data (including flashdata and\n    tempdata) will be destroyed permanently and functions will be\n    unusable during the same request after you destroy the session.\n\nYou may also use the ``stop()`` method to completely kill the session\nby removing the old session_id, destroying all data, and destroying\nthe cookie that contained the session id:\n\n.. literalinclude:: sessions/038.php\n\nAccessing Session Metadata\n==========================\n\nIn CodeIgniter 2, the session data array included 4 items\nby default: 'session_id', 'ip_address', 'user_agent', 'last_activity'.\n\nThis was due to the specifics of how sessions worked, but is now no longer\nnecessary with our new implementation. However, it may happen that your\napplication relied on these values, so here are alternative methods of\naccessing them:\n\n  - session_id: ``$session->session_id`` or ``session_id()`` (PHP\u2019s built-in function)\n  - ip_address: ``$_SERVER['REMOTE_ADDR']``\n  - user_agent: ``$_SERVER['HTTP_USER_AGENT']`` (unused by sessions)\n  - last_activity: Depends on the storage, no straightforward way. Sorry!\n\nSession Preferences\n*******************\n\nCodeIgniter will usually make everything work out of the box. However,\nSessions are a very sensitive component of any application, so some\ncareful configuration must be done. Please take your time to consider\nall of the options and their effects.\n\nYou'll find the following Session related preferences in your\n**app/Config/App.php** file:\n\n============================== ============================================ ================================================= ============================================================================================\nPreference                     Default                                      Options                                           Description\n============================== ============================================ ================================================= ============================================================================================\n**sessionDriver**              CodeIgniter\\\\Session\\\\Handlers\\\\FileHandler  CodeIgniter\\\\Session\\\\Handlers\\\\FileHandler       The session storage driver to use.\n                                                                            CodeIgniter\\\\Session\\\\Handlers\\\\DatabaseHandler\n                                                                            CodeIgniter\\\\Session\\\\Handlers\\\\MemcachedHandler\n                                                                            CodeIgniter\\\\Session\\\\Handlers\\\\RedisHandler\n                                                                            CodeIgniter\\\\Session\\\\Handlers\\\\ArrayHandler\n**sessionCookieName**          ci_session                                   [A-Za-z\\_-] characters only                       The name used for the session cookie.\n**sessionExpiration**          7200 (2 hours)                               Time in seconds (integer)                         The number of seconds you would like the session to last.\n                                                                                                                              If you would like a non-expiring session (until browser is closed) set the value to zero: 0\n**sessionSavePath**            null                                         None                                              Specifies the storage location, depends on the driver being used.\n**sessionMatchIP**             false                                        true/false (boolean)                              Whether to validate the user's IP address when reading the session cookie.\n                                                                                                                              Note that some ISPs dynamically changes the IP, so if you want a non-expiring session you\n                                                                                                                              will likely set this to false.\n**sessionTimeToUpdate**        300                                          Time in seconds (integer)                         This option controls how often the session class will regenerate itself and create a new\n                                                                                                                              session ID. Setting it to 0 will disable session ID regeneration.\n**sessionRegenerateDestroy**   false                                        true/false (boolean)                              Whether to destroy session data associated with the old session ID when auto-regenerating\n                                                                                                                              the session ID. When set to false, the data will be later deleted by the garbage collector.\n============================== ============================================ ================================================= ============================================================================================\n\n.. note:: As a last resort, the Session library will try to fetch PHP's\n    session related INI settings, as well as legacy CI settings such as\n    'sess_expire_on_close' when any of the above is not configured.\n    However, you should never rely on this behavior as it can cause\n    unexpected results or be changed in the future. Please configure\n    everything properly.\n\n.. note:: If ``sessionExpiration`` is set to ``0``, the ``session.gc_maxlifetime``\n    setting set by PHP in session management will be used as-is\n    (often the default value of ``1440``). This needs to be changed in\n    ``php.ini`` or via ``ini_set()`` as needed.\n\nIn addition to the values above, the cookie and native drivers apply the\nfollowing configuration values shared by the :doc:`IncomingRequest </incoming/incomingrequest>` and\n:doc:`Security <security>` classes:\n\n==================== =============== ===========================================================================\nPreference           Default         Description\n==================== =============== ===========================================================================\n**cookieDomain**     ''              The domain for which the session is applicable\n**cookiePath**       /               The path to which the session is applicable\n**cookieSecure**     false           Whether to create the session cookie only on encrypted (HTTPS) connections\n**cookieSameSite**   Lax             The SameSite setting for the session cookie\n==================== =============== ===========================================================================\n\n.. note:: The 'cookieHTTPOnly' setting doesn't have an effect on sessions.\n    Instead the HttpOnly parameter is always enabled, for security\n    reasons. Additionally, the ``Config\\Cookie::$prefix`` setting is completely\n    ignored.\n\nSession Drivers\n***************\n\nAs already mentioned, the Session library comes with 4 handlers, or storage\nengines, that you can use:\n\n  - CodeIgniter\\\\Session\\\\Handlers\\\\FileHandler\n  - CodeIgniter\\\\Session\\\\Handlers\\\\DatabaseHandler\n  - CodeIgniter\\\\Session\\\\Handlers\\\\MemcachedHandler\n  - CodeIgniter\\\\Session\\\\Handlers\\\\RedisHandler\n  - CodeIgniter\\\\Session\\\\Handlers\\\\ArrayHandler\n\nBy default, the ``FileHandler`` Driver will be used when a session is initialized,\nbecause it is the safest choice and is expected to work everywhere\n(virtually every environment has a file system).\n\nHowever, any other driver may be selected via the ``public $sessionDriver``\nline in your **app/Config/App.php** file, if you chose to do so.\nHave it in mind though, every driver has different caveats, so be sure to\nget yourself familiar with them (below) before you make that choice.\n\n.. note:: The ArrayHandler is used during testing and stores all data within\n    a PHP array, while preventing the data from being persisted.\n\nFileHandler Driver (the default)\n================================\n\nThe 'FileHandler' driver uses your file system for storing session data.\n\nIt can safely be said that it works exactly like PHP's own default session\nimplementation, but in case this is an important detail for you, have it\nmind that it is in fact not the same code and it has some limitations\n(and advantages).\n\nTo be more specific, it doesn't support PHP's `directory level and mode\nformats used in session.save_path\n<https://www.php.net/manual/en/session.configuration.php#ini.session.save-path>`_,\nand it has most of the options hard-coded for safety. Instead, only\nabsolute paths are supported for ``public $sessionSavePath``.\n\nAnother important thing that you should know, is to make sure that you\ndon't use a publicly-readable or shared directory for storing your session\nfiles. Make sure that *only you* have access to see the contents of your\nchosen *sessionSavePath* directory. Otherwise, anybody who can do that, can\nalso steal any of the current sessions (also known as \"session fixation\"\nattack).\n\nOn UNIX-like operating systems, this is usually achieved by setting the\n0700 mode permissions on that directory via the `chmod` command, which\nallows only the directory's owner to perform read and write operations on\nit. But be careful because the system user *running* the script is usually\nnot your own, but something like 'www-data' instead, so only setting those\npermissions will probably break your application.\n\nInstead, you should do something like this, depending on your environment\n::\n\n    mkdir /<path to your application directory>/Writable/sessions/\n    chmod 0700 /<path to your application directory>/Writable/sessions/\n    chown www-data /<path to your application directory>/Writable/sessions/\n\nBonus Tip\n---------\n\nSome of you will probably opt to choose another session driver because\nfile storage is usually slower. This is only half true.\n\nA very basic test will probably trick you into believing that an SQL\ndatabase is faster, but in 99% of the cases, this is only true while you\nonly have a few current sessions. As the sessions count and server loads\nincrease - which is the time when it matters - the file system will\nconsistently outperform almost all relational database setups.\n\nIn addition, if performance is your only concern, you may want to look\ninto using `tmpfs <https://eddmann.com/posts/storing-php-sessions-file-caches-in-memory-using-tmpfs/>`_,\n(warning: external resource), which can make your sessions blazing fast.\n\nDatabaseHandler Driver\n======================\n\nThe 'DatabaseHandler' driver uses a relational database such as MySQL or\nPostgreSQL to store sessions. This is a popular choice among many users,\nbecause it allows the developer easy access to the session data within\nan application - it is just another table in your database.\n\nHowever, there are some conditions that must be met:\n\n  - You can NOT use a persistent connection.\n\nIn order to use the 'DatabaseHandler' session driver, you must also create this\ntable that we already mentioned and then set it as your\n``$sessionSavePath`` value.\nFor example, if you would like to use 'ci_sessions' as your table name,\nyou would do this:\n\n.. literalinclude:: sessions/039.php\n\nAnd then of course, create the database table ...\n\nFor MySQL::\n\n    CREATE TABLE IF NOT EXISTS `ci_sessions` (\n        `id` varchar(128) NOT null,\n        `ip_address` varchar(45) NOT null,\n        `timestamp` timestamp DEFAULT CURRENT_TIMESTAMP NOT null,\n        `data` blob NOT null,\n        KEY `ci_sessions_timestamp` (`timestamp`)\n    );\n\nFor PostgreSQL::\n\n    CREATE TABLE \"ci_sessions\" (\n        \"id\" varchar(128) NOT NULL,\n        \"ip_address\" inet NOT NULL,\n        \"timestamp\" timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL,\n        \"data\" bytea DEFAULT '' NOT NULL\n    );\n\n    CREATE INDEX \"ci_sessions_timestamp\" ON \"ci_sessions\" (\"timestamp\");\n\nYou will also need to add a PRIMARY KEY **depending on your 'sessionMatchIP'\nsetting**. The examples below work both on MySQL and PostgreSQL::\n\n    // When sessionMatchIP = true\n    ALTER TABLE ci_sessions ADD PRIMARY KEY (id, ip_address);\n\n    // When sessionMatchIP = false\n    ALTER TABLE ci_sessions ADD PRIMARY KEY (id);\n\n    // To drop a previously created primary key (use when changing the setting)\n    ALTER TABLE ci_sessions DROP PRIMARY KEY;\n\nYou can choose the Database group to use by adding a new line to the\n**app/Config/App.php** file with the name of the group to use:\n\n.. literalinclude:: sessions/040.php\n\nIf you'd rather not do all of this by hand, you can use the ``make:migration --session`` command\nfrom the cli to generate a migration file for you::\n\n  > php spark make:migration --session\n  > php spark migrate\n\nThis command will take the **sessionSavePath** and **sessionMatchIP** settings into account\nwhen it generates the code.\n\n.. important:: Only MySQL and PostgreSQL databases are officially\n    supported, due to lack of advisory locking mechanisms on other\n    platforms. Using sessions without locks can cause all sorts of\n    problems, especially with heavy usage of AJAX, and we will not\n    support such cases. Use ``session_write_close()`` after you've\n    done processing session data if you're having performance\n    issues.\n\nRedisHandler Driver\n===================\n\n.. note:: Since Redis doesn't have a locking mechanism exposed, locks for\n    this driver are emulated by a separate value that is kept for up\n    to 300 seconds.\n\nRedis is a storage engine typically used for caching and popular because\nof its high performance, which is also probably your reason to use the\n'RedisHandler' session driver.\n\nThe downside is that it is not as ubiquitous as relational databases and\nrequires the `phpredis <https://github.com/phpredis/phpredis>`_ PHP\nextension to be installed on your system, and that one doesn't come\nbundled with PHP.\nChances are, you're only be using the RedisHandler driver only if you're already\nboth familiar with Redis and using it for other purposes.\n\nJust as with the 'FileHandler' and 'DatabaseHandler' drivers, you must also configure\nthe storage location for your sessions via the\n``$sessionSavePath`` setting.\nThe format here is a bit different and complicated at the same time. It is\nbest explained by the *phpredis* extension's README file, so we'll simply\nlink you to it:\n\n    https://github.com/phpredis/phpredis\n\n.. warning:: CodeIgniter's Session library does NOT use the actual 'redis'\n    ``session.save_handler``. Take note **only** of the path format in\n    the link above.\n\nFor the most common case however, a simple ``host:port`` pair should be\nsufficient:\n\n.. literalinclude:: sessions/041.php\n\nMemcachedHandler Driver\n=======================\n\n.. note:: Since Memcached doesn't have a locking mechanism exposed, locks\n    for this driver are emulated by a separate value that is kept for\n    up to 300 seconds.\n\nThe 'MemcachedHandler' driver is very similar to the 'RedisHandler' one in all of its\nproperties, except perhaps for availability, because PHP's `Memcached\n<https://www.php.net/memcached>`_ extension is distributed via PECL and some\nLinux distributions make it available as an easy to install package.\n\nOther than that, and without any intentional bias towards Redis, there's\nnot much different to be said about Memcached - it is also a popular\nproduct that is usually used for caching and famed for its speed.\n\nHowever, it is worth noting that the only guarantee given by Memcached\nis that setting value X to expire after Y seconds will result in it being\ndeleted after Y seconds have passed (but not necessarily that it won't\nexpire earlier than that time). This happens very rarely, but should be\nconsidered as it may result in loss of sessions.\n\nThe ``$sessionSavePath`` format is fairly straightforward here,\nbeing just a ``host:port`` pair:\n\n.. literalinclude:: sessions/042.php\n\nBonus Tip\n---------\n\nMulti-server configuration with an optional *weight* parameter as the\nthird colon-separated (``:weight``) value is also supported, but we have\nto note that we haven't tested if that is reliable.\n\nIf you want to experiment with this feature (on your own risk), simply\nseparate the multiple server paths with commas:\n\n.. literalinclude:: sessions/043.php\n", "<?php\n\nnamespace Config;\n\nuse CodeIgniter\\Config\\BaseConfig;\n\nclass App extends BaseConfig\n{\n    public $sessionDriver   = 'CodeIgniter\\Session\\Handlers\\DatabaseHandler';\n    public $sessionSavePath = 'ci_sessions';\n    // ...\n}\n", "<?php\n\nnamespace Config;\n\nuse CodeIgniter\\Config\\BaseConfig;\n\nclass App extends BaseConfig\n{\n    public $sessionDBGroup = 'groupName';\n    // ...\n}\n", "<?php\n\nnamespace Config;\n\nuse CodeIgniter\\Config\\BaseConfig;\n\nclass App extends BaseConfig\n{\n    public $sessionDiver    = 'CodeIgniter\\Session\\Handlers\\RedisHandler';\n    public $sessionSavePath = 'tcp://localhost:6379';\n    // ...\n}\n", "<?php\n\nnamespace Config;\n\nuse CodeIgniter\\Config\\BaseConfig;\n\nclass App extends BaseConfig\n{\n    public $sessionDriver   = 'CodeIgniter\\Session\\Handlers\\MemcachedHandler';\n    public $sessionSavePath = 'localhost:11211';\n    // ...\n}\n", "<?php\n\nnamespace Config;\n\nuse CodeIgniter\\Config\\BaseConfig;\n\nclass App extends BaseConfig\n{\n    // localhost will be given higher priority (5) here,\n    // compared to 192.0.2.1 with a weight of 1.\n    public $sessionSavePath = 'localhost:11211:5,192.0.2.1:11211:1';\n\n    // ...\n}\n"], "fixing_code": ["<?php\n\n/**\n * This file is part of CodeIgniter 4 framework.\n *\n * (c) CodeIgniter Foundation <admin@codeigniter.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n */\n\nnamespace CodeIgniter\\Session\\Handlers;\n\nuse CodeIgniter\\Database\\BaseBuilder;\nuse CodeIgniter\\Database\\BaseConnection;\nuse CodeIgniter\\Session\\Exceptions\\SessionException;\nuse Config\\App as AppConfig;\nuse Config\\Database;\nuse ReturnTypeWillChange;\n\n/**\n * Base database session handler\n *\n * Do not use this class. Use database specific handler class.\n */\nclass DatabaseHandler extends BaseHandler\n{\n    /**\n     * The database group to use for storage.\n     *\n     * @var string\n     */\n    protected $DBGroup;\n\n    /**\n     * The name of the table to store session info.\n     *\n     * @var string\n     */\n    protected $table;\n\n    /**\n     * The DB Connection instance.\n     *\n     * @var BaseConnection\n     */\n    protected $db;\n\n    /**\n     * The database type\n     *\n     * @var string\n     */\n    protected $platform;\n\n    /**\n     * Row exists flag\n     *\n     * @var bool\n     */\n    protected $rowExists = false;\n\n    /**\n     * ID prefix for multiple session cookies\n     */\n    protected string $idPrefix;\n\n    /**\n     * @throws SessionException\n     */\n    public function __construct(AppConfig $config, string $ipAddress)\n    {\n        parent::__construct($config, $ipAddress);\n\n        $this->table = $config->sessionSavePath;\n\n        if (empty($this->table)) {\n            throw SessionException::forMissingDatabaseTable();\n        }\n\n        $this->DBGroup = $config->sessionDBGroup ?? config(Database::class)->defaultGroup;\n\n        $this->db = Database::connect($this->DBGroup);\n\n        $this->platform = $this->db->getPlatform();\n\n        // Add sessionCookieName for multiple session cookies.\n        $this->idPrefix = $config->sessionCookieName . ':';\n    }\n\n    /**\n     * Re-initialize existing session, or creates a new one.\n     *\n     * @param string $path The path where to store/retrieve the session\n     * @param string $name The session name\n     */\n    public function open($path, $name): bool\n    {\n        if (empty($this->db->connID)) {\n            $this->db->initialize();\n        }\n\n        return true;\n    }\n\n    /**\n     * Reads the session data from the session storage, and returns the results.\n     *\n     * @param string $id The session ID\n     *\n     * @return false|string Returns an encoded string of the read data.\n     *                      If nothing was read, it must return false.\n     */\n    #[ReturnTypeWillChange]\n    public function read($id)\n    {\n        if ($this->lockSession($id) === false) {\n            $this->fingerprint = md5('');\n\n            return '';\n        }\n\n        if (! isset($this->sessionID)) {\n            $this->sessionID = $id;\n        }\n\n        $builder = $this->db->table($this->table)->where('id', $this->idPrefix . $id);\n\n        if ($this->matchIP) {\n            $builder = $builder->where('ip_address', $this->ipAddress);\n        }\n\n        $this->setSelect($builder);\n\n        $result = $builder->get()->getRow();\n\n        if ($result === null) {\n            // PHP7 will reuse the same SessionHandler object after\n            // ID regeneration, so we need to explicitly set this to\n            // FALSE instead of relying on the default ...\n            $this->rowExists   = false;\n            $this->fingerprint = md5('');\n\n            return '';\n        }\n\n        $result = is_bool($result) ? '' : $this->decodeData($result->data);\n\n        $this->fingerprint = md5($result);\n        $this->rowExists   = true;\n\n        return $result;\n    }\n\n    /**\n     * Sets SELECT clause\n     */\n    protected function setSelect(BaseBuilder $builder)\n    {\n        $builder->select('data');\n    }\n\n    /**\n     * Decodes column data\n     *\n     * @param mixed $data\n     *\n     * @return false|string\n     */\n    protected function decodeData($data)\n    {\n        return $data;\n    }\n\n    /**\n     * Writes the session data to the session storage.\n     *\n     * @param string $id   The session ID\n     * @param string $data The encoded session data\n     */\n    public function write($id, $data): bool\n    {\n        if ($this->lock === false) {\n            return $this->fail();\n        }\n\n        if ($this->sessionID !== $id) {\n            $this->rowExists = false;\n            $this->sessionID = $id;\n        }\n\n        if ($this->rowExists === false) {\n            $insertData = [\n                'id'         => $this->idPrefix . $id,\n                'ip_address' => $this->ipAddress,\n                'data'       => $this->prepareData($data),\n            ];\n\n            if (! $this->db->table($this->table)->set('timestamp', 'now()', false)->insert($insertData)) {\n                return $this->fail();\n            }\n\n            $this->fingerprint = md5($data);\n            $this->rowExists   = true;\n\n            return true;\n        }\n\n        $builder = $this->db->table($this->table)->where('id', $this->idPrefix . $id);\n\n        if ($this->matchIP) {\n            $builder = $builder->where('ip_address', $this->ipAddress);\n        }\n\n        $updateData = [];\n\n        if ($this->fingerprint !== md5($data)) {\n            $updateData['data'] = $this->prepareData($data);\n        }\n\n        if (! $builder->set('timestamp', 'now()', false)->update($updateData)) {\n            return $this->fail();\n        }\n\n        $this->fingerprint = md5($data);\n\n        return true;\n    }\n\n    /**\n     * Prepare data to insert/update\n     */\n    protected function prepareData(string $data): string\n    {\n        return $data;\n    }\n\n    /**\n     * Closes the current session.\n     */\n    public function close(): bool\n    {\n        return ($this->lock && ! $this->releaseLock()) ? $this->fail() : true;\n    }\n\n    /**\n     * Destroys a session\n     *\n     * @param string $id The session ID being destroyed\n     */\n    public function destroy($id): bool\n    {\n        if ($this->lock) {\n            $builder = $this->db->table($this->table)->where('id', $this->idPrefix . $id);\n\n            if ($this->matchIP) {\n                $builder = $builder->where('ip_address', $this->ipAddress);\n            }\n\n            if (! $builder->delete()) {\n                return $this->fail();\n            }\n        }\n\n        if ($this->close()) {\n            $this->destroyCookie();\n\n            return true;\n        }\n\n        return $this->fail();\n    }\n\n    /**\n     * Cleans up expired sessions.\n     *\n     * @param int $max_lifetime Sessions that have not updated\n     *                          for the last max_lifetime seconds will be removed.\n     *\n     * @return false|int Returns the number of deleted sessions on success, or false on failure.\n     */\n    #[ReturnTypeWillChange]\n    public function gc($max_lifetime)\n    {\n        $separator = ' ';\n        $interval  = implode($separator, ['', \"{$max_lifetime} second\", '']);\n\n        return $this->db->table($this->table)->where(\n            'timestamp <',\n            \"now() - INTERVAL {$interval}\",\n            false\n        )->delete() ? 1 : $this->fail();\n    }\n\n    /**\n     * Releases the lock, if any.\n     */\n    protected function releaseLock(): bool\n    {\n        if (! $this->lock) {\n            return true;\n        }\n\n        // Unsupported DB? Let the parent handle the simple version.\n        return parent::releaseLock();\n    }\n}\n", "<?php\n\n/**\n * This file is part of CodeIgniter 4 framework.\n *\n * (c) CodeIgniter Foundation <admin@codeigniter.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n */\n\nnamespace CodeIgniter\\Session\\Handlers;\n\nuse CodeIgniter\\I18n\\Time;\nuse CodeIgniter\\Session\\Exceptions\\SessionException;\nuse Config\\App as AppConfig;\nuse Memcached;\nuse ReturnTypeWillChange;\n\n/**\n * Session handler using Memcache for persistence\n */\nclass MemcachedHandler extends BaseHandler\n{\n    /**\n     * Memcached instance\n     *\n     * @var Memcached|null\n     */\n    protected $memcached;\n\n    /**\n     * Key prefix\n     *\n     * @var string\n     */\n    protected $keyPrefix = 'ci_session:';\n\n    /**\n     * Lock key\n     *\n     * @var string|null\n     */\n    protected $lockKey;\n\n    /**\n     * Number of seconds until the session ends.\n     *\n     * @var int\n     */\n    protected $sessionExpiration = 7200;\n\n    /**\n     * @throws SessionException\n     */\n    public function __construct(AppConfig $config, string $ipAddress)\n    {\n        parent::__construct($config, $ipAddress);\n\n        if (empty($this->savePath)) {\n            throw SessionException::forEmptySavepath();\n        }\n\n        // Add sessionCookieName for multiple session cookies.\n        $this->keyPrefix .= $config->sessionCookieName . ':';\n\n        if ($this->matchIP === true) {\n            $this->keyPrefix .= $this->ipAddress . ':';\n        }\n\n        if (! empty($this->keyPrefix)) {\n            ini_set('memcached.sess_prefix', $this->keyPrefix);\n        }\n\n        $this->sessionExpiration = $config->sessionExpiration;\n    }\n\n    /**\n     * Re-initialize existing session, or creates a new one.\n     *\n     * @param string $path The path where to store/retrieve the session\n     * @param string $name The session name\n     */\n    public function open($path, $name): bool\n    {\n        $this->memcached = new Memcached();\n        $this->memcached->setOption(Memcached::OPT_BINARY_PROTOCOL, true); // required for touch() usage\n\n        $serverList = [];\n\n        foreach ($this->memcached->getServerList() as $server) {\n            $serverList[] = $server['host'] . ':' . $server['port'];\n        }\n\n        if (\n            ! preg_match_all(\n                '#,?([^,:]+)\\:(\\d{1,5})(?:\\:(\\d+))?#',\n                $this->savePath,\n                $matches,\n                PREG_SET_ORDER\n            )\n        ) {\n            $this->memcached = null;\n            $this->logger->error('Session: Invalid Memcached save path format: ' . $this->savePath);\n\n            return false;\n        }\n\n        foreach ($matches as $match) {\n            // If Memcached already has this server (or if the port is invalid), skip it\n            if (in_array($match[1] . ':' . $match[2], $serverList, true)) {\n                $this->logger->debug(\n                    'Session: Memcached server pool already has ' . $match[1] . ':' . $match[2]\n                );\n\n                continue;\n            }\n\n            if (! $this->memcached->addServer($match[1], (int) $match[2], $match[3] ?? 0)) {\n                $this->logger->error(\n                    'Could not add ' . $match[1] . ':' . $match[2] . ' to Memcached server pool.'\n                );\n            } else {\n                $serverList[] = $match[1] . ':' . $match[2];\n            }\n        }\n\n        if (empty($serverList)) {\n            $this->logger->error('Session: Memcached server pool is empty.');\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Reads the session data from the session storage, and returns the results.\n     *\n     * @param string $id The session ID\n     *\n     * @return false|string Returns an encoded string of the read data.\n     *                      If nothing was read, it must return false.\n     */\n    #[ReturnTypeWillChange]\n    public function read($id)\n    {\n        if (isset($this->memcached) && $this->lockSession($id)) {\n            if (! isset($this->sessionID)) {\n                $this->sessionID = $id;\n            }\n\n            $data = (string) $this->memcached->get($this->keyPrefix . $id);\n\n            $this->fingerprint = md5($data);\n\n            return $data;\n        }\n\n        return '';\n    }\n\n    /**\n     * Writes the session data to the session storage.\n     *\n     * @param string $id   The session ID\n     * @param string $data The encoded session data\n     */\n    public function write($id, $data): bool\n    {\n        if (! isset($this->memcached)) {\n            return false;\n        }\n\n        if ($this->sessionID !== $id) {\n            if (! $this->releaseLock() || ! $this->lockSession($id)) {\n                return false;\n            }\n\n            $this->fingerprint = md5('');\n            $this->sessionID   = $id;\n        }\n\n        if (isset($this->lockKey)) {\n            $this->memcached->replace($this->lockKey, Time::now()->getTimestamp(), 300);\n\n            if ($this->fingerprint !== ($fingerprint = md5($data))) {\n                if ($this->memcached->set($this->keyPrefix . $id, $data, $this->sessionExpiration)) {\n                    $this->fingerprint = $fingerprint;\n\n                    return true;\n                }\n\n                return false;\n            }\n\n            return $this->memcached->touch($this->keyPrefix . $id, $this->sessionExpiration);\n        }\n\n        return false;\n    }\n\n    /**\n     * Closes the current session.\n     */\n    public function close(): bool\n    {\n        if (isset($this->memcached)) {\n            if (isset($this->lockKey)) {\n                $this->memcached->delete($this->lockKey);\n            }\n\n            if (! $this->memcached->quit()) {\n                return false;\n            }\n\n            $this->memcached = null;\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys a session\n     *\n     * @param string $id The session ID being destroyed\n     */\n    public function destroy($id): bool\n    {\n        if (isset($this->memcached, $this->lockKey)) {\n            $this->memcached->delete($this->keyPrefix . $id);\n\n            return $this->destroyCookie();\n        }\n\n        return false;\n    }\n\n    /**\n     * Cleans up expired sessions.\n     *\n     * @param int $max_lifetime Sessions that have not updated\n     *                          for the last max_lifetime seconds will be removed.\n     *\n     * @return false|int Returns the number of deleted sessions on success, or false on failure.\n     */\n    #[ReturnTypeWillChange]\n    public function gc($max_lifetime)\n    {\n        return 1;\n    }\n\n    /**\n     * Acquires an emulated lock.\n     *\n     * @param string $sessionID Session ID\n     */\n    protected function lockSession(string $sessionID): bool\n    {\n        if (isset($this->lockKey)) {\n            return $this->memcached->replace($this->lockKey, Time::now()->getTimestamp(), 300);\n        }\n\n        $lockKey = $this->keyPrefix . $sessionID . ':lock';\n        $attempt = 0;\n\n        do {\n            if ($this->memcached->get($lockKey)) {\n                sleep(1);\n\n                continue;\n            }\n\n            if (! $this->memcached->set($lockKey, Time::now()->getTimestamp(), 300)) {\n                $this->logger->error(\n                    'Session: Error while trying to obtain lock for ' . $this->keyPrefix . $sessionID\n                );\n\n                return false;\n            }\n\n            $this->lockKey = $lockKey;\n            break;\n        } while (++$attempt < 30);\n\n        if ($attempt === 30) {\n            $this->logger->error(\n                'Session: Unable to obtain lock for ' . $this->keyPrefix . $sessionID . ' after 30 attempts, aborting.'\n            );\n\n            return false;\n        }\n\n        $this->lock = true;\n\n        return true;\n    }\n\n    /**\n     * Releases a previously acquired lock\n     */\n    protected function releaseLock(): bool\n    {\n        if (isset($this->memcached, $this->lockKey) && $this->lock) {\n            if (\n                ! $this->memcached->delete($this->lockKey)\n                && $this->memcached->getResultCode() !== Memcached::RES_NOTFOUND\n            ) {\n                $this->logger->error(\n                    'Session: Error while trying to free lock for ' . $this->lockKey\n                );\n\n                return false;\n            }\n\n            $this->lockKey = null;\n            $this->lock    = false;\n        }\n\n        return true;\n    }\n}\n", "<?php\n\n/**\n * This file is part of CodeIgniter 4 framework.\n *\n * (c) CodeIgniter Foundation <admin@codeigniter.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n */\n\nnamespace CodeIgniter\\Session\\Handlers;\n\nuse CodeIgniter\\I18n\\Time;\nuse CodeIgniter\\Session\\Exceptions\\SessionException;\nuse Config\\App as AppConfig;\nuse Redis;\nuse RedisException;\nuse ReturnTypeWillChange;\n\n/**\n * Session handler using Redis for persistence\n */\nclass RedisHandler extends BaseHandler\n{\n    private const DEFAULT_PORT = 6379;\n\n    /**\n     * phpRedis instance\n     *\n     * @var Redis|null\n     */\n    protected $redis;\n\n    /**\n     * Key prefix\n     *\n     * @var string\n     */\n    protected $keyPrefix = 'ci_session:';\n\n    /**\n     * Lock key\n     *\n     * @var string|null\n     */\n    protected $lockKey;\n\n    /**\n     * Key exists flag\n     *\n     * @var bool\n     */\n    protected $keyExists = false;\n\n    /**\n     * Number of seconds until the session ends.\n     *\n     * @var int\n     */\n    protected $sessionExpiration = 7200;\n\n    /**\n     * @param string $ipAddress User's IP address\n     *\n     * @throws SessionException\n     */\n    public function __construct(AppConfig $config, string $ipAddress)\n    {\n        parent::__construct($config, $ipAddress);\n\n        $this->setSavePath();\n\n        // Add sessionCookieName for multiple session cookies.\n        $this->keyPrefix .= $config->sessionCookieName . ':';\n\n        if ($this->matchIP === true) {\n            $this->keyPrefix .= $this->ipAddress . ':';\n        }\n\n        $this->sessionExpiration = empty($config->sessionExpiration)\n            ? (int) ini_get('session.gc_maxlifetime')\n            : (int) $config->sessionExpiration;\n    }\n\n    protected function setSavePath(): void\n    {\n        if (empty($this->savePath)) {\n            throw SessionException::forEmptySavepath();\n        }\n\n        if (preg_match('#(?:tcp://)?([^:?]+)(?:\\:(\\d+))?(\\?.+)?#', $this->savePath, $matches)) {\n            if (! isset($matches[3])) {\n                $matches[3] = ''; // Just to avoid undefined index notices below\n            }\n\n            $this->savePath = [\n                'host'     => $matches[1],\n                'port'     => empty($matches[2]) ? self::DEFAULT_PORT : $matches[2],\n                'password' => preg_match('#auth=([^\\s&]+)#', $matches[3], $match) ? $match[1] : null,\n                'database' => preg_match('#database=(\\d+)#', $matches[3], $match) ? (int) $match[1] : 0,\n                'timeout'  => preg_match('#timeout=(\\d+\\.\\d+|\\d+)#', $matches[3], $match) ? (float) $match[1] : 0.0,\n            ];\n\n            preg_match('#prefix=([^\\s&]+)#', $matches[3], $match) && $this->keyPrefix = $match[1];\n        } else {\n            throw SessionException::forInvalidSavePathFormat($this->savePath);\n        }\n    }\n\n    /**\n     * Re-initialize existing session, or creates a new one.\n     *\n     * @param string $path The path where to store/retrieve the session\n     * @param string $name The session name\n     */\n    public function open($path, $name): bool\n    {\n        if (empty($this->savePath)) {\n            return false;\n        }\n\n        $redis = new Redis();\n\n        if (! $redis->connect($this->savePath['host'], ($this->savePath['host'][0] === '/' ? 0 : $this->savePath['port']), $this->savePath['timeout'])) {\n            $this->logger->error('Session: Unable to connect to Redis with the configured settings.');\n        } elseif (isset($this->savePath['password']) && ! $redis->auth($this->savePath['password'])) {\n            $this->logger->error('Session: Unable to authenticate to Redis instance.');\n        } elseif (isset($this->savePath['database']) && ! $redis->select($this->savePath['database'])) {\n            $this->logger->error('Session: Unable to select Redis database with index ' . $this->savePath['database']);\n        } else {\n            $this->redis = $redis;\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Reads the session data from the session storage, and returns the results.\n     *\n     * @param string $id The session ID\n     *\n     * @return false|string Returns an encoded string of the read data.\n     *                      If nothing was read, it must return false.\n     */\n    #[ReturnTypeWillChange]\n    public function read($id)\n    {\n        if (isset($this->redis) && $this->lockSession($id)) {\n            if (! isset($this->sessionID)) {\n                $this->sessionID = $id;\n            }\n\n            $data = $this->redis->get($this->keyPrefix . $id);\n\n            if (is_string($data)) {\n                $this->keyExists = true;\n            } else {\n                $data = '';\n            }\n\n            $this->fingerprint = md5($data);\n\n            return $data;\n        }\n\n        return '';\n    }\n\n    /**\n     * Writes the session data to the session storage.\n     *\n     * @param string $id   The session ID\n     * @param string $data The encoded session data\n     */\n    public function write($id, $data): bool\n    {\n        if (! isset($this->redis)) {\n            return false;\n        }\n\n        if ($this->sessionID !== $id) {\n            if (! $this->releaseLock() || ! $this->lockSession($id)) {\n                return false;\n            }\n\n            $this->keyExists = false;\n            $this->sessionID = $id;\n        }\n\n        if (isset($this->lockKey)) {\n            $this->redis->expire($this->lockKey, 300);\n\n            if ($this->fingerprint !== ($fingerprint = md5($data)) || $this->keyExists === false) {\n                if ($this->redis->set($this->keyPrefix . $id, $data, $this->sessionExpiration)) {\n                    $this->fingerprint = $fingerprint;\n                    $this->keyExists   = true;\n\n                    return true;\n                }\n\n                return false;\n            }\n\n            return $this->redis->expire($this->keyPrefix . $id, $this->sessionExpiration);\n        }\n\n        return false;\n    }\n\n    /**\n     * Closes the current session.\n     */\n    public function close(): bool\n    {\n        if (isset($this->redis)) {\n            try {\n                $pingReply = $this->redis->ping();\n\n                if (($pingReply === true) || ($pingReply === '+PONG')) {\n                    if (isset($this->lockKey)) {\n                        $this->redis->del($this->lockKey);\n                    }\n\n                    if (! $this->redis->close()) {\n                        return false;\n                    }\n                }\n            } catch (RedisException $e) {\n                $this->logger->error('Session: Got RedisException on close(): ' . $e->getMessage());\n            }\n\n            $this->redis = null;\n\n            return true;\n        }\n\n        return true;\n    }\n\n    /**\n     * Destroys a session\n     *\n     * @param string $id The session ID being destroyed\n     */\n    public function destroy($id): bool\n    {\n        if (isset($this->redis, $this->lockKey)) {\n            if (($result = $this->redis->del($this->keyPrefix . $id)) !== 1) {\n                $this->logger->debug('Session: Redis::del() expected to return 1, got ' . var_export($result, true) . ' instead.');\n            }\n\n            return $this->destroyCookie();\n        }\n\n        return false;\n    }\n\n    /**\n     * Cleans up expired sessions.\n     *\n     * @param int $max_lifetime Sessions that have not updated\n     *                          for the last max_lifetime seconds will be removed.\n     *\n     * @return false|int Returns the number of deleted sessions on success, or false on failure.\n     */\n    #[ReturnTypeWillChange]\n    public function gc($max_lifetime)\n    {\n        return 1;\n    }\n\n    /**\n     * Acquires an emulated lock.\n     *\n     * @param string $sessionID Session ID\n     */\n    protected function lockSession(string $sessionID): bool\n    {\n        $lockKey = $this->keyPrefix . $sessionID . ':lock';\n\n        // PHP 7 reuses the SessionHandler object on regeneration,\n        // so we need to check here if the lock key is for the\n        // correct session ID.\n        if ($this->lockKey === $lockKey) {\n            return $this->redis->expire($this->lockKey, 300);\n        }\n\n        $attempt = 0;\n\n        do {\n            if (($ttl = $this->redis->ttl($lockKey)) > 0) {\n                sleep(1);\n\n                continue;\n            }\n\n            if (! $this->redis->setex($lockKey, 300, (string) Time::now()->getTimestamp())) {\n                $this->logger->error('Session: Error while trying to obtain lock for ' . $this->keyPrefix . $sessionID);\n\n                return false;\n            }\n\n            $this->lockKey = $lockKey;\n            break;\n        } while (++$attempt < 30);\n\n        if ($attempt === 30) {\n            log_message('error', 'Session: Unable to obtain lock for ' . $this->keyPrefix . $sessionID . ' after 30 attempts, aborting.');\n\n            return false;\n        }\n\n        if ($ttl === -1) {\n            log_message('debug', 'Session: Lock for ' . $this->keyPrefix . $sessionID . ' had no TTL, overriding.');\n        }\n\n        $this->lock = true;\n\n        return true;\n    }\n\n    /**\n     * Releases a previously acquired lock\n     */\n    protected function releaseLock(): bool\n    {\n        if (isset($this->redis, $this->lockKey) && $this->lock) {\n            if (! $this->redis->del($this->lockKey)) {\n                $this->logger->error('Session: Error while trying to free lock for ' . $this->lockKey);\n\n                return false;\n            }\n\n            $this->lockKey = null;\n            $this->lock    = false;\n        }\n\n        return true;\n    }\n}\n", "Version 4.2.11\n##############\n\nRelease Date: December 21, 2022\n\n**4.2.11 release of CodeIgniter4**\n\n.. contents::\n    :local:\n    :depth: 2\n\nSECURITY\n********\n\n- *Attackers may spoof IP address when using proxy* was fixed. See the `Security advisory GHSA-ghw3-5qvm-3mqc <https://github.com/codeigniter4/CodeIgniter4/security/advisories/GHSA-ghw3-5qvm-3mqc>`_ for more information.\n- *Potential Session Handlers Vulnerability* was fixed. See the `Security advisory GHSA-6cq5-8cj7-g558 <https://github.com/codeigniter4/CodeIgniter4/security/advisories/GHSA-6cq5-8cj7-g558>`_ for more information.\n\nBREAKING\n********\n\n- The ``Config\\App::$proxyIPs`` value format has been changed. See :ref:`Upgrading Guide <upgrade-4211-proxyips>`.\n- The key of the session data record for :ref:`sessions-databasehandler-driver`,\n  :ref:`sessions-memcachedhandler-driver` and :ref:`sessions-redishandler-driver`\n  has changed. See :ref:`Upgrading Guide <upgrade-4211-session-key>`.\n\nBugs Fixed\n**********\n\n- Fixed a ``FileLocator::locateFile()`` bug where a similar namespace name could be replaced by another, causing a failure to find a file that exists.\n- Fixed a ``RedisHandler`` session class to use the correct config when used with a socket connection.\n\nSee the repo's `CHANGELOG.md <https://github.com/codeigniter4/CodeIgniter4/blob/develop/CHANGELOG.md>`_ for a complete list of bugs fixed.\n", "###############################\nUpgrading from 4.2.10 to 4.2.11\n###############################\n\nPlease refer to the upgrade instructions corresponding to your installation method.\n\n- :ref:`Composer Installation App Starter Upgrading <app-starter-upgrading>`\n- :ref:`Composer Installation Adding CodeIgniter4 to an Existing Project Upgrading <adding-codeigniter4-upgrading>`\n- :ref:`Manual Installation Upgrading <installing-manual-upgrading>`\n\n.. contents::\n    :local:\n    :depth: 2\n\nBreaking Changes\n****************\n\n.. _upgrade-4211-proxyips:\n\nConfig\\\\App::$proxyIPs\n======================\n\nThe config value format has been changed. Now you must set your proxy IP address and the HTTP header name for the client IP address pair as an array::\n\n    public $proxyIPs = [\n            '10.0.1.200'     => 'X-Forwarded-For',\n            '192.168.5.0/24' => 'X-Forwarded-For',\n    ];\n\n``ConfigException`` will be thrown for old format config value.\n\n.. _upgrade-4211-session-key:\n\nSession Handler Key Changes\n===========================\n\nThe key of the session data record for :ref:`sessions-databasehandler-driver`,\n:ref:`sessions-memcachedhandler-driver` and :ref:`sessions-redishandler-driver`\nhas changed. Therefore, any existing session data will be invalidated after\nthe upgrade if you are using these session handlers.\n\n- When using ``DatabaseHandler``, the ``id`` column value in the session table\n  now contains the session cookie name (``Config\\App::$sessionCookieName``).\n- When using ``MemcachedHandler`` or ``RedisHandler``, the key value contains\n  the session cookie name (``Config\\App::$sessionCookieName``).\n\nThere is maximum length for the ``id`` column and Memcached key (250 bytes).\nIf the following values exceed those maximum length, the session will not work properly.\n\n- the session cookie name, delimiter, and session id (32 characters by default)\n  when using ``DatabaseHandler``\n- the prefix (``ci_session``), session cookie name, delimiters, and session id\n  when using  ``MemcachedHandler``\n\nProject Files\n*************\n\nVersion ``4.2.11`` did not alter any executable code in project files.\n\nAll Changes\n===========\n\nThis is a list of all files in the **project space** that received changes;\nmany will be simple comments or formatting that have no effect on the runtime:\n\n* app/Config/App.php\n* app/Config/Autoload.php\n* app/Config/Logger.php\n* app/Config/Toolbar.php\n* app/Views/welcome_message.php\n* composer.json\n* phpunit.xml.dist\n", "###############\nSession Library\n###############\n\nThe Session class permits you to maintain a user's \"state\" and track their\nactivity while they browse your site.\n\nCodeIgniter comes with a few session storage drivers, that you can see\nin the last section of the table of contents:\n\n.. contents::\n    :local:\n    :depth: 2\n\nUsing the Session Class\n***********************\n\nInitializing a Session\n======================\n\nSessions will typically run globally with each page load, so the Session\nclass should be magically initialized.\n\nTo access and initialize the session:\n\n.. literalinclude:: sessions/001.php\n\nThe ``$config`` parameter is optional - your application configuration.\nIf not provided, the services register will instantiate your default\none.\n\nOnce loaded, the Sessions library object will be available using::\n\n    $session\n\nAlternatively, you can use the helper function that will use the default\nconfiguration options. This version is a little friendlier to read,\nbut does not take any configuration options.\n\n.. literalinclude:: sessions/002.php\n\nHow do Sessions work?\n=====================\n\nWhen a page is loaded, the session class will check to see if a valid\nsession cookie is sent by the user's browser. If a sessions cookie does\n**not** exist (or if it doesn't match one stored on the server or has\nexpired) a new session will be created and saved.\n\nIf a valid session does exist, its information will be updated. With each\nupdate, the session ID may be regenerated if configured to do so.\n\nIt's important for you to understand that once initialized, the Session\nclass runs automatically. There is nothing you need to do to cause the\nabove behavior to happen. You can, as you'll see below, work with session\ndata, but the process of reading, writing, and updating a session is\nautomatic.\n\n.. note:: Under CLI, the Session library will automatically halt itself,\n    as this is a concept based entirely on the HTTP protocol.\n\nA note about concurrency\n------------------------\n\nUnless you're developing a website with heavy AJAX usage, you can skip this\nsection. If you are, however, and if you're experiencing performance\nissues, then this note is exactly what you're looking for.\n\nSessions in CodeIgniter v2.x didn't implement locking,\nwhich meant that two HTTP requests using the same session could run exactly\nat the same time. To use a more appropriate technical term - requests were\nnon-blocking.\n\nHowever, non-blocking requests in the context of sessions also means\nunsafe, because, modifications to session data (or session ID regeneration)\nin one request can interfere with the execution of a second, concurrent\nrequest. This detail was at the root of many issues and the main reason why\nCodeIgniter 3 has a completely re-written Session library.\n\nWhy are we telling you this? Because it is likely that after trying to\nfind the reason for your performance issues, you may conclude that locking\nis the issue and therefore look into how to remove the locks ...\n\nDO NOT DO THAT! Removing locks would be **wrong** and it will cause you\nmore problems!\n\nLocking is not the issue, it is a solution. Your issue is that you still\nhave the session open, while you've already processed it and therefore no\nlonger need it. So, what you need is to close the session for the\ncurrent request after you no longer need it.\n\n.. literalinclude:: sessions/003.php\n\nWhat is Session Data?\n=====================\n\nSession data is simply an array associated with a particular session ID\n(cookie).\n\nIf you've used sessions in PHP before, you should be familiar with PHP's\n`$_SESSION superglobal <https://www.php.net/manual/en/reserved.variables.session.php>`_\n(if not, please read the content on that link).\n\nCodeIgniter gives access to its session data through the same means, as it\nuses the session handlers' mechanism provided by PHP. Using session data is\nas simple as manipulating (read, set and unset values) the ``$_SESSION``\narray.\n\n.. note:: In general, it is bad practice to use global variables.\n    So using the superglobal ``$_SESSION`` directly is not recommended.\n\nIn addition, CodeIgniter also provides 2 special types of session data\nthat are further explained below: `Flashdata`_ and `Tempdata`_.\n\n.. note:: For historical reasons, we refer to session data excluding Flashdata and Tempdata as \"userdata\".\n\nRetrieving Session Data\n=======================\n\nAny piece of information from the session array is available through the\n``$_SESSION`` superglobal:\n\n.. literalinclude:: sessions/004.php\n\nOr through the conventional accessor method:\n\n.. literalinclude:: sessions/005.php\n\nOr through the magic getter:\n\n.. literalinclude:: sessions/006.php\n\nOr even through the session helper method:\n\n.. literalinclude:: sessions/007.php\n\nWhere ``item`` is the array key corresponding to the item you wish to fetch.\nFor example, to assign a previously stored ``name`` item to the ``$name``\nvariable, you will do this:\n\n.. literalinclude:: sessions/008.php\n\n.. note:: The ``get()`` method returns null if the item you are trying\n    to access does not exist.\n\nIf you want to retrieve all of the existing session data, you can simply\nomit the item key (magic getter only works for single property values):\n\n.. literalinclude:: sessions/009.php\n\n.. important:: The ``get()`` method WILL return flashdata or tempdata items when\n    retrieving a single item by key. It will not return flashdata or tempdata when\n    grabbing all data from the session, however.\n\nAdding Session Data\n===================\n\nLet's say a particular user logs into your site. Once authenticated, you\ncould add their username and e-mail address to the session, making that\ndata globally available to you without having to run a database query when\nyou need it.\n\nYou can simply assign data to the ``$_SESSION`` array, as with any other\nvariable. Or as a property of ``$session``.\n\nYou can pass an array containing your new session data to the\n``set()`` method:\n\n.. literalinclude:: sessions/010.php\n\nWhere ``$array`` is an associative array containing your new data. Here's\nan example:\n\n.. literalinclude:: sessions/011.php\n\nIf you want to add session data one value at a time, ``set()`` also\nsupports this syntax:\n\n.. literalinclude:: sessions/012.php\n\nIf you want to verify that a session value exists, simply check with\n``isset()``:\n\n.. literalinclude:: sessions/013.php\n\nOr you can call ``has()``:\n\n.. literalinclude:: sessions/014.php\n\nPushing New Value to Session Data\n=================================\n\nThe ``push()`` method is used to push a new value onto a session value that is an array.\nFor instance, if the ``hobbies`` key contains an array of hobbies, you can add a new value onto the array like so:\n\n.. literalinclude:: sessions/015.php\n\nRemoving Session Data\n=====================\n\nJust as with any other variable, unsetting a value in ``$_SESSION`` can be\ndone through ``unset()``:\n\n.. literalinclude:: sessions/016.php\n\nAlso, just as ``set()`` can be used to add information to a\nsession, ``remove()`` can be used to remove it, by passing the\nsession key. For example, if you wanted to remove ``some_name`` from your\nsession data array:\n\n.. literalinclude:: sessions/017.php\n\nThis method also accepts an array of item keys to unset:\n\n.. literalinclude:: sessions/018.php\n\nFlashdata\n=========\n\nCodeIgniter supports \"flashdata\", or session data that will only be\navailable for the next request, and is then automatically cleared.\n\nThis can be very useful, especially for one-time informational, error or\nstatus messages (for example: \"Record 2 deleted\").\n\nIt should be noted that flashdata variables are regular session variables,\nmanaged inside the CodeIgniter session handler.\n\nTo mark an existing item as \"flashdata\":\n\n.. literalinclude:: sessions/019.php\n\nIf you want to mark multiple items as flashdata, simply pass the keys as an\narray:\n\n.. literalinclude:: sessions/020.php\n\nTo add flashdata:\n\n.. literalinclude:: sessions/021.php\n\nOr alternatively, using the ``setFlashdata()`` method:\n\n.. literalinclude:: sessions/022.php\n\nYou can also pass an array to ``setFlashdata()``, in the same manner as\n``set()``.\n\nReading flashdata variables is the same as reading regular session data\nthrough ``$_SESSION``:\n\n.. literalinclude:: sessions/023.php\n\n.. important:: The ``get()`` method WILL return flashdata items when\n    retrieving a single item by key. It will not return flashdata when\n    grabbing all data from the session, however.\n\nHowever, if you want to be sure that you're reading \"flashdata\" (and not\nany other kind), you can also use the ``getFlashdata()`` method:\n\n.. literalinclude:: sessions/024.php\n\n.. note:: The ``getFlashdata()`` method returns null if the item cannot be\n    found.\n\nOr to get an array with all flashdata, simply omit the key parameter:\n\n.. literalinclude:: sessions/025.php\n\n\nIf you find that you need to preserve a flashdata variable through an\nadditional request, you can do so using the ``keepFlashdata()`` method.\nYou can either pass a single item or an array of flashdata items to keep.\n\n.. literalinclude:: sessions/026.php\n\nTempdata\n========\n\nCodeIgniter also supports \"tempdata\", or session data with a specific\nexpiration time. After the value expires, or the session expires or is\ndeleted, the value is automatically removed.\n\nSimilarly to flashdata, tempdata variables are managed internally by the\nCodeIgniter session handler.\n\nTo mark an existing item as \"tempdata\", simply pass its key and expiry time\n(in seconds!) to the ``markAsTempdata()`` method:\n\n.. literalinclude:: sessions/027.php\n\nYou can mark multiple items as tempdata in two ways, depending on whether\nyou want them all to have the same expiry time or not:\n\n.. literalinclude:: sessions/028.php\n\nTo add tempdata:\n\n.. literalinclude:: sessions/029.php\n\nOr alternatively, using the ``setTempdata()`` method:\n\n.. literalinclude:: sessions/030.php\n\nYou can also pass an array to ``setTempdata()``:\n\n.. literalinclude:: sessions/031.php\n\n.. note:: If the expiration is omitted or set to 0, the default\n    time-to-live value of 300 seconds (or 5 minutes) will be used.\n\nTo read a tempdata variable, again you can just access it through the\n``$_SESSION`` superglobal array:\n\n.. literalinclude:: sessions/032.php\n\n.. important:: The ``get()`` method WILL return tempdata items when\n    retrieving a single item by key. It will not return tempdata when\n    grabbing all data from the session, however.\n\nOr if you want to be sure that you're reading \"tempdata\" (and not any\nother kind), you can also use the ``getTempdata()`` method:\n\n.. literalinclude:: sessions/033.php\n\n.. note:: The ``getTempdata()`` method returns null if the item cannot be\n    found.\n\nAnd of course, if you want to retrieve all existing tempdata:\n\n.. literalinclude:: sessions/034.php\n\nIf you need to remove a tempdata value before it expires, you can directly\nunset it from the ``$_SESSION`` array:\n\n.. literalinclude:: sessions/035.php\n\nHowever, this won't remove the marker that makes this specific item to be\ntempdata (it will be invalidated on the next HTTP request), so if you\nintend to reuse that same key in the same request, you'd want to use\n``removeTempdata()``:\n\n.. literalinclude:: sessions/036.php\n\nDestroying a Session\n====================\n\nTo clear the current session (for example, during a logout), you may\nsimply use either PHP's `session_destroy() <https://www.php.net/session_destroy>`_\nfunction, or the library's ``destroy()`` method. Both will work in exactly the\nsame way:\n\n.. literalinclude:: sessions/037.php\n\n.. note:: This must be the last session-related operation that you do\n    during the same request. All session data (including flashdata and\n    tempdata) will be destroyed permanently and functions will be\n    unusable during the same request after you destroy the session.\n\nYou may also use the ``stop()`` method to completely kill the session\nby removing the old session ID, destroying all data, and destroying\nthe cookie that contained the session ID:\n\n.. literalinclude:: sessions/038.php\n\nAccessing Session Metadata\n==========================\n\nIn CodeIgniter 2, the session data array included 4 items\nby default: 'session_id', 'ip_address', 'user_agent', 'last_activity'.\n\nThis was due to the specifics of how sessions worked, but is now no longer\nnecessary with our new implementation. However, it may happen that your\napplication relied on these values, so here are alternative methods of\naccessing them:\n\n  - session_id: ``$session->session_id`` or ``session_id()`` (PHP\u2019s built-in function)\n  - ip_address: ``$_SERVER['REMOTE_ADDR']``\n  - user_agent: ``$_SERVER['HTTP_USER_AGENT']`` (unused by sessions)\n  - last_activity: Depends on the storage, no straightforward way. Sorry!\n\nSession Preferences\n*******************\n\nCodeIgniter will usually make everything work out of the box. However,\nSessions are a very sensitive component of any application, so some\ncareful configuration must be done. Please take your time to consider\nall of the options and their effects.\n\nYou'll find the following Session related preferences in your\n**app/Config/App.php** file:\n\n============================== ================== =========================== ============================================================\nPreference                     Default            Options                     Description\n============================== ================== =========================== ============================================================\n**sessionDriver**              FileHandler::class FileHandler::class          The session storage driver to use.\n                                                  DatabaseHandler::class      All the session drivers are located in the\n                                                  MemcachedHandler::class     ``CodeIgniter\\Session\\Handlers\\`` namespace.\n                                                  RedisHandler::class\n                                                  ArrayHandler::class\n**sessionCookieName**          ci_session         [A-Za-z\\_-] characters only The name used for the session cookie.\n                                                                              The value will be included in the key of the\n                                                                              Database/Memcached/Redis session records. So, set the value\n                                                                              so that it does not exceed the maximum length of the key.\n**sessionExpiration**          7200 (2 hours)     Time in seconds (integer)   The number of seconds you would like the session to last.\n                                                                              If you would like a non-expiring session (until browser is\n                                                                              closed) set the value to zero: 0\n**sessionSavePath**            null               None                        Specifies the storage location, depends on the driver being\n                                                                              used.\n**sessionMatchIP**             false              true/false (boolean)        Whether to validate the user's IP address when reading the\n                                                                              session cookie. Note that some ISPs dynamically changes the IP,\n                                                                              so if you want a non-expiring session you will likely set this\n                                                                              to false.\n**sessionTimeToUpdate**        300                Time in seconds (integer)   This option controls how often the session class will\n                                                                              regenerate itself and create a new session ID. Setting it to 0\n                                                                              will disable session ID regeneration.\n**sessionRegenerateDestroy**   false              true/false (boolean)        Whether to destroy session data associated with the old\n                                                                              session ID when auto-regenerating\n                                                                              the session ID. When set to false, the data will be later\n                                                                              deleted by the garbage collector.\n============================== ================== =========================== ============================================================\n\n.. note:: As a last resort, the Session library will try to fetch PHP's\n    session related INI settings, as well as legacy CI settings such as\n    'sess_expire_on_close' when any of the above is not configured.\n    However, you should never rely on this behavior as it can cause\n    unexpected results or be changed in the future. Please configure\n    everything properly.\n\n.. note:: If ``sessionExpiration`` is set to ``0``, the ``session.gc_maxlifetime``\n    setting set by PHP in session management will be used as-is\n    (often the default value of ``1440``). This needs to be changed in\n    ``php.ini`` or via ``ini_set()`` as needed.\n\nIn addition to the values above, the cookie and native drivers apply the\nfollowing configuration values shared by the :doc:`IncomingRequest </incoming/incomingrequest>` and\n:doc:`Security <security>` classes:\n\n==================== =============== ===========================================================================\nPreference           Default         Description\n==================== =============== ===========================================================================\n**cookieDomain**     ''              The domain for which the session is applicable\n**cookiePath**       /               The path to which the session is applicable\n**cookieSecure**     false           Whether to create the session cookie only on encrypted (HTTPS) connections\n**cookieSameSite**   Lax             The SameSite setting for the session cookie\n==================== =============== ===========================================================================\n\n.. note:: The 'cookieHTTPOnly' setting doesn't have an effect on sessions.\n    Instead the HttpOnly parameter is always enabled, for security\n    reasons. Additionally, the ``Config\\Cookie::$prefix`` setting is completely\n    ignored.\n\nSession Drivers\n***************\n\nAs already mentioned, the Session library comes with 4 handlers, or storage\nengines, that you can use:\n\n  - CodeIgniter\\\\Session\\\\Handlers\\\\FileHandler\n  - CodeIgniter\\\\Session\\\\Handlers\\\\DatabaseHandler\n  - CodeIgniter\\\\Session\\\\Handlers\\\\MemcachedHandler\n  - CodeIgniter\\\\Session\\\\Handlers\\\\RedisHandler\n  - CodeIgniter\\\\Session\\\\Handlers\\\\ArrayHandler\n\nBy default, the ``FileHandler`` Driver will be used when a session is initialized,\nbecause it is the safest choice and is expected to work everywhere\n(virtually every environment has a file system).\n\nHowever, any other driver may be selected via the ``public $sessionDriver``\nline in your **app/Config/App.php** file, if you chose to do so.\nHave it in mind though, every driver has different caveats, so be sure to\nget yourself familiar with them (below) before you make that choice.\n\n.. note:: The ArrayHandler is used during testing and stores all data within\n    a PHP array, while preventing the data from being persisted.\n\nFileHandler Driver (the default)\n================================\n\nThe 'FileHandler' driver uses your file system for storing session data.\n\nIt can safely be said that it works exactly like PHP's own default session\nimplementation, but in case this is an important detail for you, have it\nmind that it is in fact not the same code and it has some limitations\n(and advantages).\n\nTo be more specific, it doesn't support PHP's `directory level and mode\nformats used in session.save_path\n<https://www.php.net/manual/en/session.configuration.php#ini.session.save-path>`_,\nand it has most of the options hard-coded for safety. Instead, only\nabsolute paths are supported for ``public $sessionSavePath``.\n\nAnother important thing that you should know, is to make sure that you\ndon't use a publicly-readable or shared directory for storing your session\nfiles. Make sure that *only you* have access to see the contents of your\nchosen *sessionSavePath* directory. Otherwise, anybody who can do that, can\nalso steal any of the current sessions (also known as \"session fixation\"\nattack).\n\nOn UNIX-like operating systems, this is usually achieved by setting the\n0700 mode permissions on that directory via the `chmod` command, which\nallows only the directory's owner to perform read and write operations on\nit. But be careful because the system user *running* the script is usually\nnot your own, but something like 'www-data' instead, so only setting those\npermissions will probably break your application.\n\nInstead, you should do something like this, depending on your environment\n::\n\n    > mkdir /<path to your application directory>/writable/sessions/\n    > chmod 0700 /<path to your application directory>/writable/sessions/\n    > chown www-data /<path to your application directory>/writable/sessions/\n\nBonus Tip\n---------\n\nSome of you will probably opt to choose another session driver because\nfile storage is usually slower. This is only half true.\n\nA very basic test will probably trick you into believing that an SQL\ndatabase is faster, but in 99% of the cases, this is only true while you\nonly have a few current sessions. As the sessions count and server loads\nincrease - which is the time when it matters - the file system will\nconsistently outperform almost all relational database setups.\n\nIn addition, if performance is your only concern, you may want to look\ninto using `tmpfs <https://eddmann.com/posts/storing-php-sessions-file-caches-in-memory-using-tmpfs/>`_,\n(warning: external resource), which can make your sessions blazing fast.\n\n.. _sessions-databasehandler-driver:\n\nDatabaseHandler Driver\n======================\n\nThe 'DatabaseHandler' driver uses a relational database such as MySQL or\nPostgreSQL to store sessions. This is a popular choice among many users,\nbecause it allows the developer easy access to the session data within\nan application - it is just another table in your database.\n\nHowever, there are some conditions that must be met:\n\n  - You can NOT use a persistent connection.\n\nIn order to use the 'DatabaseHandler' session driver, you must also create this\ntable that we already mentioned and then set it as your\n``$sessionSavePath`` value.\nFor example, if you would like to use 'ci_sessions' as your table name,\nyou would do this:\n\n.. literalinclude:: sessions/039.php\n\nAnd then of course, create the database table ...\n\nFor MySQL::\n\n    CREATE TABLE IF NOT EXISTS `ci_sessions` (\n        `id` varchar(128) NOT null,\n        `ip_address` varchar(45) NOT null,\n        `timestamp` timestamp DEFAULT CURRENT_TIMESTAMP NOT null,\n        `data` blob NOT null,\n        KEY `ci_sessions_timestamp` (`timestamp`)\n    );\n\nFor PostgreSQL::\n\n    CREATE TABLE \"ci_sessions\" (\n        \"id\" varchar(128) NOT NULL,\n        \"ip_address\" inet NOT NULL,\n        \"timestamp\" timestamptz DEFAULT CURRENT_TIMESTAMP NOT NULL,\n        \"data\" bytea DEFAULT '' NOT NULL\n    );\n\n    CREATE INDEX \"ci_sessions_timestamp\" ON \"ci_sessions\" (\"timestamp\");\n\n.. note:: The ``id`` value contains the session cookie name (``Config\\App::$sessionCookieName``)\n    and the session ID and a delimiter. It should be increased as needed, for example,\n    when using long session IDs.\n\nYou will also need to add a PRIMARY KEY **depending on your 'sessionMatchIP'\nsetting**. The examples below work both on MySQL and PostgreSQL::\n\n    // When sessionMatchIP = true\n    ALTER TABLE ci_sessions ADD PRIMARY KEY (id, ip_address);\n\n    // When sessionMatchIP = false\n    ALTER TABLE ci_sessions ADD PRIMARY KEY (id);\n\n    // To drop a previously created primary key (use when changing the setting)\n    ALTER TABLE ci_sessions DROP PRIMARY KEY;\n\nYou can choose the Database group to use by adding a new line to the\n**app/Config/App.php** file with the name of the group to use:\n\n.. literalinclude:: sessions/040.php\n\nIf you'd rather not do all of this by hand, you can use the ``make:migration --session`` command\nfrom the cli to generate a migration file for you::\n\n  > php spark make:migration --session\n  > php spark migrate\n\nThis command will take the **sessionSavePath** and **sessionMatchIP** settings into account\nwhen it generates the code.\n\n.. important:: Only MySQL and PostgreSQL databases are officially\n    supported, due to lack of advisory locking mechanisms on other\n    platforms. Using sessions without locks can cause all sorts of\n    problems, especially with heavy usage of AJAX, and we will not\n    support such cases. Use ``session_write_close()`` after you've\n    done processing session data if you're having performance\n    issues.\n\n.. _sessions-redishandler-driver:\n\nRedisHandler Driver\n===================\n\n.. note:: Since Redis doesn't have a locking mechanism exposed, locks for\n    this driver are emulated by a separate value that is kept for up\n    to 300 seconds.\n\nRedis is a storage engine typically used for caching and popular because\nof its high performance, which is also probably your reason to use the\n'RedisHandler' session driver.\n\nThe downside is that it is not as ubiquitous as relational databases and\nrequires the `phpredis <https://github.com/phpredis/phpredis>`_ PHP\nextension to be installed on your system, and that one doesn't come\nbundled with PHP.\nChances are, you're only be using the RedisHandler driver only if you're already\nboth familiar with Redis and using it for other purposes.\n\nJust as with the 'FileHandler' and 'DatabaseHandler' drivers, you must also configure\nthe storage location for your sessions via the\n``$sessionSavePath`` setting.\nThe format here is a bit different and complicated at the same time. It is\nbest explained by the *phpredis* extension's README file, so we'll simply\nlink you to it:\n\n    https://github.com/phpredis/phpredis\n\n.. warning:: CodeIgniter's Session library does NOT use the actual 'redis'\n    ``session.save_handler``. Take note **only** of the path format in\n    the link above.\n\nFor the most common case however, a simple ``host:port`` pair should be\nsufficient:\n\n.. literalinclude:: sessions/041.php\n\n.. _sessions-memcachedhandler-driver:\n\nMemcachedHandler Driver\n=======================\n\n.. note:: Since Memcached doesn't have a locking mechanism exposed, locks\n    for this driver are emulated by a separate value that is kept for\n    up to 300 seconds.\n\nThe 'MemcachedHandler' driver is very similar to the 'RedisHandler' one in all of its\nproperties, except perhaps for availability, because PHP's `Memcached\n<https://www.php.net/memcached>`_ extension is distributed via PECL and some\nLinux distributions make it available as an easy to install package.\n\nOther than that, and without any intentional bias towards Redis, there's\nnot much different to be said about Memcached - it is also a popular\nproduct that is usually used for caching and famed for its speed.\n\nHowever, it is worth noting that the only guarantee given by Memcached\nis that setting value X to expire after Y seconds will result in it being\ndeleted after Y seconds have passed (but not necessarily that it won't\nexpire earlier than that time). This happens very rarely, but should be\nconsidered as it may result in loss of sessions.\n\nThe ``$sessionSavePath`` format is fairly straightforward here,\nbeing just a ``host:port`` pair:\n\n.. literalinclude:: sessions/042.php\n\nBonus Tip\n---------\n\nMulti-server configuration with an optional *weight* parameter as the\nthird colon-separated (``:weight``) value is also supported, but we have\nto note that we haven't tested if that is reliable.\n\nIf you want to experiment with this feature (on your own risk), simply\nseparate the multiple server paths with commas:\n\n.. literalinclude:: sessions/043.php\n", "<?php\n\nnamespace Config;\n\nuse CodeIgniter\\Config\\BaseConfig;\n\nclass App extends BaseConfig\n{\n    // ...\n    public $sessionDriver = 'CodeIgniter\\Session\\Handlers\\DatabaseHandler';\n    // ...\n    public $sessionSavePath = 'ci_sessions';\n    // ...\n}\n", "<?php\n\nnamespace Config;\n\nuse CodeIgniter\\Config\\BaseConfig;\n\nclass App extends BaseConfig\n{\n    // ...\n    public $sessionDBGroup = 'groupName';\n    // ...\n}\n", "<?php\n\nnamespace Config;\n\nuse CodeIgniter\\Config\\BaseConfig;\n\nclass App extends BaseConfig\n{\n    // ...\n    public $sessionDiver = 'CodeIgniter\\Session\\Handlers\\RedisHandler';\n    // ...\n    public $sessionSavePath = 'tcp://localhost:6379';\n    // ...\n}\n", "<?php\n\nnamespace Config;\n\nuse CodeIgniter\\Config\\BaseConfig;\n\nclass App extends BaseConfig\n{\n    // ...\n    public $sessionDriver = 'CodeIgniter\\Session\\Handlers\\MemcachedHandler';\n    // ...\n    public $sessionSavePath = 'localhost:11211';\n    // ...\n}\n", "<?php\n\nnamespace Config;\n\nuse CodeIgniter\\Config\\BaseConfig;\n\nclass App extends BaseConfig\n{\n    // ...\n\n    // localhost will be given higher priority (5) here,\n    // compared to 192.0.2.1 with a weight of 1.\n    public $sessionSavePath = 'localhost:11211:5,192.0.2.1:11211:1';\n\n    // ...\n}\n"], "filenames": ["system/Session/Handlers/DatabaseHandler.php", "system/Session/Handlers/MemcachedHandler.php", "system/Session/Handlers/RedisHandler.php", "user_guide_src/source/changelogs/v4.2.11.rst", "user_guide_src/source/installation/upgrade_4211.rst", "user_guide_src/source/libraries/sessions.rst", "user_guide_src/source/libraries/sessions/039.php", "user_guide_src/source/libraries/sessions/040.php", "user_guide_src/source/libraries/sessions/041.php", "user_guide_src/source/libraries/sessions/042.php", "user_guide_src/source/libraries/sessions/043.php"], "buggy_code_start_loc": [63, 63, 73, 15, 31, 361, 9, 8, 9, 9, 8], "buggy_code_end_loc": [280, 294, 73, 20, 48, 633, 10, 8, 10, 10, 8], "fixing_code_start_loc": [64, 64, 74, 16, 32, 361, 9, 9, 9, 9, 9], "fixing_code_end_loc": [293, 314, 77, 25, 73, 653, 12, 10, 12, 12, 11], "type": "CWE-287", "message": "CodeIgniter is a PHP full-stack web framework. When an application uses (1) multiple session cookies (e.g., one for user pages and one for admin pages) and (2) a session handler is set to `DatabaseHandler`, `MemcachedHandler`, or `RedisHandler`, then if an attacker gets one session cookie (e.g., one for user pages), they may be able to access pages that require another session cookie (e.g., for admin pages). This issue has been patched, please upgrade to version 4.2.11 or later. As a workaround, use only one session cookie.", "other": {"cve": {"id": "CVE-2022-46170", "sourceIdentifier": "security-advisories@github.com", "published": "2022-12-22T19:15:09.223", "lastModified": "2022-12-29T16:23:33.167", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "CodeIgniter is a PHP full-stack web framework. When an application uses (1) multiple session cookies (e.g., one for user pages and one for admin pages) and (2) a session handler is set to `DatabaseHandler`, `MemcachedHandler`, or `RedisHandler`, then if an attacker gets one session cookie (e.g., one for user pages), they may be able to access pages that require another session cookie (e.g., for admin pages). This issue has been patched, please upgrade to version 4.2.11 or later. As a workaround, use only one session cookie."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:codeigniter:codeigniter:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.2.11", "matchCriteriaId": "3E8EEE4F-3F8A-4CC9-9501-87DD6F0FF2B2"}]}]}], "references": [{"url": "https://github.com/codeigniter4/CodeIgniter4/commit/f9fb6574fbeb5a4aa63f7ea87296523e10db9328", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/codeigniter4/CodeIgniter4/security/advisories/GHSA-6cq5-8cj7-g558", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/codeigniter4/CodeIgniter4/commit/f9fb6574fbeb5a4aa63f7ea87296523e10db9328"}}