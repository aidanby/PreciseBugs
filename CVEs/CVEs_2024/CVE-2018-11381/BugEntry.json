{"buggy_code": ["/* radare2 - LGPL - Copyright 2009-2018 - pancake, nibble, dso */\n\n#include <r_bin.h>\n\n// maybe too big sometimes? 2KB of stack eaten here..\n#define R_STRING_SCAN_BUFFER_SIZE 2048\n\nstatic void print_string(RBinString *string, RBinFile *bf) {\n\tif (!string || !bf) {\n\t\treturn;\n\t}\n\tint mode = bf->strmode;\n\tut64 addr , vaddr;\n\tRBin *bin = bf->rbin;\n\tconst char *section_name, *type_string;\n\tRIO *io = bin->iob.io;\n\tif (!io) {\n\t\treturn;\n\t}\n\tRBinSection *s = r_bin_get_section_at (bf->o, string->paddr, false);\n\tif (s) {\n\t\tstring->vaddr = s->vaddr + (string->paddr - s->paddr);\n\t}\n\tsection_name = s ? s->name : \"\";\n\ttype_string = r_bin_string_type (string->type);\n\tvaddr = addr = r_bin_get_vaddr (bin, string->paddr, string->vaddr);\n\n\tswitch(mode) {\n\tcase MODE_SIMPLE :\n\t\tio->cb_printf (\"0x%08\" PFMT64x \" %s\\n\", addr, string->string);\n\t\tbreak;\n\tcase MODE_RADARE :\n\t\t{\n\t\tchar *f_name, *nstr;\n\t\tf_name = strdup (string->string);\n\t\tr_name_filter (f_name, 512);\n\t\tif (bin->prefix) {\n\t\t\tnstr = r_str_newf (\"%s.str.%s\", bin->prefix, f_name);\n\t\t\tio->cb_printf (\"f %s.str.%s %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\"\n\t\t\t\t\t\"Cs %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tbin->prefix, f_name, string->size, addr,\n\t\t\t\t\tstring->size, addr);\n\t\t} else {\n\t\t\tnstr = r_str_newf (\"str.%s\", f_name);\n\t\t\tio->cb_printf (\"f str.%s %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\"\n\t\t\t\t\t\"Cs %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tf_name, string->size, addr,\n\t\t\t\t\tstring->size, addr);\n\t\t}\n\t\tfree (nstr);\n\t\tfree (f_name);\n\t\tbreak;\n\t\t}\n\tcase MODE_PRINT :\n\t\tio->cb_printf (\"%03u 0x%08\"PFMT64x\" 0x%08\"\n\t\t\t\tPFMT64x\" %3u %3u \"\n\t\t\t\t\"(%s) %5s %s\\n\",\n\t\t\t\tstring->ordinal, string->paddr, vaddr,\n\t\t\t\tstring->length, string->size,\n\t\t\t\tsection_name, type_string, string->string);\n\t\tbreak;\n\t}\n}\n\nstatic int string_scan_range(RList *list, RBinFile *bf, int min,\n\t\t\t      const ut64 from, const ut64 to, int type) {\n\tut8 tmp[R_STRING_SCAN_BUFFER_SIZE];\n\tut64 str_start, needle = from;\n\tint count = 0, i, rc, runes;\n\tint str_type = R_STRING_TYPE_DETECT;\n\n\tif (type == -1) {\n\t\ttype = R_STRING_TYPE_DETECT;\n\t}\n\tif (from >= to) {\n\t\teprintf (\"Invalid range to find strings 0x%llx .. 0x%llx\\n\", from, to);\n\t\treturn -1;\n\t}\n\tut8 *buf = calloc (to - from, 1);\n\tif (!buf || !min) {\n\t\treturn -1;\n\t}\n\tr_buf_read_at (bf->buf, from, buf, to - from);\n\t// may oobread\n\twhile (needle < to) {\n\t\trc = r_utf8_decode (buf + needle - from, to - needle, NULL);\n\t\tif (!rc) {\n\t\t\tneedle++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (type == R_STRING_TYPE_DETECT) {\n\t\t\tchar *w = (char *)buf + needle + rc - from;\n\t\t\tif ((to - needle) > 5) {\n\t\t\t\tbool is_wide32 = needle + rc + 2 < to && !w[0] && !w[1] && !w[2] && w[3] && !w[4];\n\t\t\t\tif (is_wide32) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_WIDE32;\n\t\t\t\t} else {\n\t\t\t\t\tbool is_wide = needle + rc + 2 < to && !w[0] && w[1] && !w[2];\n\t\t\t\t\tstr_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr_type = R_STRING_TYPE_ASCII;\n\t\t\t}\n\t\t} else {\n\t\t\tstr_type = type;\n\t\t}\n\t\trunes = 0;\n\t\tstr_start = needle;\n\n\t\t/* Eat a whole C string */\n\t\tfor (rc = i = 0; i < sizeof (tmp) - 3 && needle < to; i += rc) {\n\t\t\tRRune r = {0};\n\n\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\trc = r_utf32le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc) {\n\t\t\t\t\trc = 4;\n\t\t\t\t}\n\t\t\t} else if (str_type == R_STRING_TYPE_WIDE) {\n\t\t\t\trc = r_utf16le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc == 1) {\n\t\t\t\t\trc = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = r_utf8_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Invalid sequence detected */\n\t\t\tif (!rc) {\n\t\t\t\tneedle++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tneedle += rc;\n\n\t\t\tif (r_isprint (r) && r != '\\\\') {\n\t\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\t\tif (r == 0xff) {\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trc = r_utf8_encode (&tmp[i], r);\n\t\t\t\trunes++;\n\t\t\t\t/* Print the escape code */\n\t\t\t} else if (r && r < 0x100 && strchr (\"\\b\\v\\f\\n\\r\\t\\a\\033\\\\\", (char)r)) {\n\t\t\t\tif ((i + 32) < sizeof (tmp) && r < 93) {\n\t\t\t\t\ttmp[i + 0] = '\\\\';\n\t\t\t\t\ttmp[i + 1] = \"       abtnvfr             e  \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"  \\\\\"[r];\n\t\t\t\t} else {\n\t\t\t\t\t// string too long\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trc = 2;\n\t\t\t\trunes++;\n\t\t\t} else {\n\t\t\t\t/* \\0 marks the end of C-strings */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttmp[i++] = '\\0';\n\n\t\tif (runes >= min) {\n\t\t\tif (str_type == R_STRING_TYPE_ASCII) {\n\t\t\t\t// reduce false positives\n\t\t\t\tint j;\n\t\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\tchar ch = tmp[j];\n\t\t\t\t\tif (ch != '\\n' && ch != '\\r' && ch != '\\t') {\n\t\t\t\t\t\tif (!IS_PRINTABLE (tmp[j])) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tRBinString *bs = R_NEW0 (RBinString);\n\t\t\tif (!bs) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbs->type = str_type;\n\t\t\tbs->length = runes;\n\t\t\tbs->size = needle - str_start;\n\t\t\tbs->ordinal = count++;\n\t\t\t// TODO: move into adjust_offset\n\t\t\tswitch (str_type) {\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\t\tif (str_start -from> 1) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 2 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 2; // \\xff\\xfe\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tif (str_start -from> 3) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 4 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 4; // \\xff\\xfe\\x00\\x00\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbs->paddr = bs->vaddr = str_start;\n\t\t\tbs->string = r_str_ndup ((const char *)tmp, i);\n\t\t\tif (list) {\n\t\t\t\tr_list_append (list, bs);\n\t\t\t} else {\n\t\t\t\tprint_string (bs, bf);\n\t\t\t\tr_bin_string_free (bs);\n\t\t\t}\n\t\t}\n\t}\n\tfree (buf);\n\treturn count;\n}\n\nstatic char *swiftField(const char *dn, const char *cn) {\n\tchar *p = strstr (dn, \".getter_\");\n\tif (!p) {\n\t\tp = strstr (dn, \".setter_\");\n\t\tif (!p) {\n\t\t\tp = strstr (dn, \".method_\");\n\t\t}\n\t}\n\tif (p) {\n\t\tchar *q = strstr (dn, cn);\n\t\tif (q && q[strlen (cn)] == '.') {\n\t\t\tq = strdup (q + strlen (cn) + 1);\n\t\t\tchar *r = strchr (q, '.');\n\t\t\tif (r) {\n\t\t\t\t*r = 0;\n\t\t\t}\n\t\t\treturn q;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RList *r_bin_classes_from_symbols (RBinFile *bf, RBinObject *o) {\n\tRBinSymbol *sym;\n\tRListIter *iter;\n\tRList *symbols = o->symbols;\n\tRList *classes = o->classes;\n\tif (!classes) {\n\t\tclasses = r_list_newf ((RListFree)r_bin_class_free);\n\t}\n\tr_list_foreach (symbols, iter, sym) {\n\t\tif (sym->name[0] != '_') {\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *cn = sym->classname;\n\t\tif (cn) {\n\t\t\tRBinClass *c = r_bin_class_new (bf, sym->classname, NULL, 0);\n\t\t\tif (!c) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// swift specific\n\t\t\tchar *dn = sym->dname;\n\t\t\tchar *fn = swiftField (dn, cn);\n\t\t\tif (fn) {\n\t\t\t\t// eprintf (\"FIELD %s  %s\\n\", cn, fn);\n\t\t\t\tRBinField *f = r_bin_field_new (sym->paddr, sym->vaddr, sym->size, fn, NULL, NULL);\n\t\t\t\tr_list_append (c->fields, f);\n\t\t\t\tfree (fn);\n\t\t\t} else {\n\t\t\t\tchar *mn = strstr (dn, \"..\");\n\t\t\t\tif (mn) {\n\t\t\t\t\t// eprintf (\"META %s  %s\\n\", sym->classname, mn);\n\t\t\t\t} else {\n\t\t\t\t\tchar *mn = strstr (dn, cn);\n\t\t\t\t\tif (mn && mn[strlen(cn)] == '.') {\n\t\t\t\t\t\tmn += strlen (cn) + 1;\n\t\t\t\t\t\t// eprintf (\"METHOD %s  %s\\n\", sym->classname, mn);\n\t\t\t\t\t\tr_list_append (c->methods, sym);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (r_list_empty (classes)) {\n\t\tr_list_free (classes);\n\t\treturn NULL;\n\t}\n\treturn classes;\n}\n\nR_API RBinFile *r_bin_file_new(RBin *bin, const char *file, const ut8 *bytes, ut64 sz, ut64 file_sz, int rawstr, int fd, const char *xtrname, Sdb *sdb, bool steal_ptr) {\n\tRBinFile *binfile = R_NEW0 (RBinFile);\n\tif (!binfile) {\n\t\treturn NULL;\n\t}\n\tif (!r_id_pool_grab_id (bin->file_ids, &binfile->id)) {\n\t\tif (steal_ptr) { // we own the ptr, free on error\n\t\t\tfree ((void*) bytes);\n\t\t}\n\t\tfree (binfile);\t\t//no id means no binfile\n\t\treturn NULL;\n\t}\n\tint res = r_bin_file_set_bytes (binfile, bytes, sz, steal_ptr);\n\tif (!res && steal_ptr) { // we own the ptr, free on error\n\t\tfree((void*) bytes);\n\t}\n\tbinfile->rbin = bin;\n\tbinfile->file = file? strdup (file): NULL;\n\tbinfile->rawstr = rawstr;\n\tbinfile->fd = fd;\n\tbinfile->curxtr = r_bin_get_xtrplugin_by_name (bin, xtrname);\n\tbinfile->sdb = sdb;\n\tbinfile->size = file_sz;\n\tbinfile->xtr_data = r_list_newf ((RListFree)r_bin_xtrdata_free);\n\tbinfile->objs = r_list_newf ((RListFree)r_bin_object_free);\n\tbinfile->xtr_obj  = NULL;\n\n\tif (!binfile->buf) {\n\t\t//r_bin_file_free (binfile);\n\t\tbinfile->buf = r_buf_new ();\n\t\t//\treturn NULL;\n\t}\n\n\tif (sdb) {\n\t\tbinfile->sdb = sdb_ns (sdb, sdb_fmt (\"fd.%d\", fd), 1);\n\t\tsdb_set (binfile->sdb, \"archs\", \"0:0:x86:32\", 0); // x86??\n\t\t/* NOTE */\n\t\t/* Those refs++ are necessary because sdb_ns() doesnt rerefs all\n\t\t * sub-namespaces */\n\t\t/* And if any namespace is referenced backwards it gets\n\t\t * double-freed */\n\t\tbinfile->sdb_addrinfo = sdb_ns (binfile->sdb, \"addrinfo\", 1);\n\t\tbinfile->sdb_addrinfo->refs++;\n\t\tsdb_ns_set (sdb, \"cur\", binfile->sdb);\n\t\tbinfile->sdb->refs++;\n\t}\n\treturn binfile;\n}\n\nR_API bool r_bin_file_object_new_from_xtr_data(RBin *bin, RBinFile *bf, ut64 baseaddr, ut64 loadaddr, RBinXtrData *data) {\n\tRBinObject *o = NULL;\n\tRBinPlugin *plugin = NULL;\n\tut8* bytes;\n\tut64 offset = data? data->offset: 0;\n\tut64 sz = data ? data->size : 0;\n\tif (!data || !bf) {\n\t\treturn false;\n\t}\n\n\t// for right now the bytes used will just be the offest into the binfile\n\t// buffer\n\t// if the extraction requires some sort of transformation then this will\n\t// need to be fixed\n\t// here.\n\tbytes = data->buffer;\n\tif (!bytes) {\n\t\treturn false;\n\t}\n\tplugin = r_bin_get_binplugin_by_bytes (bin, (const ut8*)bytes, sz);\n\tif (!plugin) {\n\t\tplugin = r_bin_get_binplugin_any (bin);\n\t}\n\tr_buf_free (bf->buf);\n\tbf->buf = r_buf_new_with_bytes ((const ut8*)bytes, data->size);\n\t//r_bin_object_new append the new object into binfile\n\to = r_bin_object_new (bf, plugin, baseaddr, loadaddr, offset, sz);\n\t// size is set here because the reported size of the object depends on\n\t// if loaded from xtr plugin or partially read\n\tif (!o) {\n\t\treturn false;\n\t}\n\tif (o && !o->size) {\n\t\to->size = sz;\n\t}\n\tbf->narch = data->file_count;\n\tif (!o->info) {\n\t\to->info = R_NEW0 (RBinInfo);\n\t}\n\tfree (o->info->file);\n\tfree (o->info->arch);\n\tfree (o->info->machine);\n\tfree (o->info->type);\n\to->info->file = strdup (bf->file);\n\to->info->arch = strdup (data->metadata->arch);\n\to->info->machine = strdup (data->metadata->machine);\n\to->info->type = strdup (data->metadata->type);\n\to->info->bits = data->metadata->bits;\n\to->info->has_crypto = bf->o->info->has_crypto;\n\tdata->loaded = true;\n\treturn true;\n}\n\n\nR_API RBinFile *r_bin_file_new_from_fd(RBin *bin, int fd, RBinFileOptions *options) {\nint file_sz = 0;\n\tRBinPlugin *plugin = NULL;\n\tRBinFile *bf = r_bin_file_create_append (bin, \"-\", NULL, 0, file_sz,\n\t\t\t\t       0, fd, NULL, false);\n\tif (!bf) {\n\t\treturn NULL;\n\t}\n\tint loadaddr = options? options->laddr: 0;\n\tint baseaddr = options? options->baddr: 0;\n\t// int loadaddr = options? options->laddr: 0;\n\tbool binfile_created = true;\n\tr_buf_free (bf->buf);\n\tbf->buf = r_buf_new_with_io (&bin->iob, fd);\n\tif (bin->force) {\n\t\tplugin = r_bin_get_binplugin_by_name (bin, bin->force);\n\t}\n\tif (!plugin) {\n\t\tif (options && options->plugname) {\n\t\t\tplugin = r_bin_get_binplugin_by_name (bin, options->plugname);\n\t\t}\n\t\tif (!plugin) {\n\t\t\tut8 bytes[1024];\n\t\t\tint sz = 1024;\n\t\t\tr_buf_read_at (bf->buf, 0, bytes, sz);\n\t\t\tplugin = r_bin_get_binplugin_by_bytes (bin, bytes, sz);\n\t\t\tif (!plugin) {\n\t\t\t\tplugin = r_bin_get_binplugin_any (bin);\n\t\t\t}\n\t\t}\n\t}\n\n\tRBinObject *o = r_bin_object_new (bf, plugin, baseaddr, loadaddr, 0, r_buf_size (bf->buf));\n\t// size is set here because the reported size of the object depends on\n\t// if loaded from xtr plugin or partially read\n\tif (o && !o->size) {\n\t\to->size = file_sz;\n\t}\n\n\tif (!o) {\n\t\tif (bf && binfile_created) {\n\t\t\tr_list_delete_data (bin->binfiles, bf);\n\t\t}\n\t\treturn NULL;\n\t}\n#if 0\n\t/* WTF */\n\tif (strcmp (plugin->name, \"any\")) {\n\t\tbf->narch = 1;\n\t}\n#endif\n\t/* free unnecessary rbuffer (???) */\n\treturn bf;\n}\n\nR_API RBinFile *r_bin_file_new_from_bytes(RBin *bin, const char *file, const ut8 *bytes, ut64 sz, ut64 file_sz, int rawstr, ut64 baseaddr, ut64 loadaddr, int fd, const char *pluginname, const char *xtrname, ut64 offset, bool steal_ptr) {\n\tut8 binfile_created = false;\n\tRBinPlugin *plugin = NULL;\n\tRBinXtrPlugin *xtr = NULL;\n\tRBinObject *o = NULL;\n\tif (sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\n\tif (xtrname) {\n\t\txtr = r_bin_get_xtrplugin_by_name (bin, xtrname);\n\t}\n\n\tif (xtr && xtr->check_bytes (bytes, sz)) {\n\t\treturn r_bin_file_xtr_load_bytes (bin, xtr, file,\n\t\t\t\t\t\tbytes, sz, file_sz, baseaddr, loadaddr, 0,\n\t\t\t\t\t\tfd, rawstr);\n\t}\n\n\tRBinFile *bf = r_bin_file_create_append (bin, file, bytes, sz, file_sz,\n\t\t\t\t       rawstr, fd, xtrname, steal_ptr);\n\tif (!bf) {\n\t\tif (!steal_ptr) { // we own the ptr, free on error\n\t\t\tfree ((void*) bytes);\n\t\t}\n\t\treturn NULL;\n\t}\n\tbinfile_created = true;\n\n\tif (bin->force) {\n\t\tplugin = r_bin_get_binplugin_by_name (bin, bin->force);\n\t}\n\tif (!plugin) {\n\t\tif (pluginname) {\n\t\t\tplugin = r_bin_get_binplugin_by_name (bin, pluginname);\n\t\t}\n\t\tif (!plugin) {\n\t\t\tplugin = r_bin_get_binplugin_by_bytes (bin, bytes, sz);\n\t\t\tif (!plugin) {\n\t\t\t\tplugin = r_bin_get_binplugin_any (bin);\n\t\t\t}\n\t\t}\n\t}\n\n\to = r_bin_object_new (bf, plugin, baseaddr, loadaddr, 0, r_buf_size (bf->buf));\n\t// size is set here because the reported size of the object depends on\n\t// if loaded from xtr plugin or partially read\n\tif (o && !o->size) {\n\t\to->size = file_sz;\n\t}\n\n\tif (!o) {\n\t\tif (bf && binfile_created) {\n\t\t\tr_list_delete_data (bin->binfiles, bf);\n\t\t}\n\t\treturn NULL;\n\t}\n#if 0\n\t/* WTF */\n\tif (strcmp (plugin->name, \"any\")) {\n\t\tbf->narch = 1;\n\t}\n#endif\n\n\t/* free unnecessary rbuffer (???) */\n\treturn bf;\n}\n\nR_API RBinFile *r_bin_file_find_by_arch_bits(RBin *bin, const char *arch, int bits, const char *name) {\n\tRListIter *iter;\n\tRBinFile *binfile = NULL;\n\tRBinXtrData *xtr_data;\n\n\tif (!name || !arch) {\n\t\treturn NULL;\n\t}\n\tr_list_foreach (bin->binfiles, iter, binfile) {\n\t\tRListIter *iter_xtr;\n\t\tif (!binfile->xtr_data) {\n\t\t\tcontinue;\n\t\t}\n\t\t// look for sub-bins in Xtr Data and Load if we need to\n\t\tr_list_foreach (binfile->xtr_data, iter_xtr, xtr_data) {\n\t\t\tif (xtr_data->metadata && xtr_data->metadata->arch) {\n\t\t\t\tchar *iter_arch = xtr_data->metadata->arch;\n\t\t\t\tint iter_bits = xtr_data->metadata->bits;\n\t\t\t\tif (bits == iter_bits && !strcmp (iter_arch, arch)) {\n\t\t\t\t\tif (!xtr_data->loaded) {\n\t\t\t\t\t\tif (!r_bin_file_object_new_from_xtr_data (\n\t\t\t\t\t\t\t    bin, binfile, xtr_data->baddr,\n\t\t\t\t\t\t\t    xtr_data->laddr, xtr_data)) {\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn binfile;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn binfile;\n}\n\nR_API RBinObject *r_bin_file_object_find_by_id(RBinFile *binfile, ut32 binobj_id) {\n\tRBinObject *obj;\n\tRListIter *iter;\n\tif (binfile)  {\n\t\tr_list_foreach (binfile->objs, iter, obj) {\n\t\t\tif (obj->id == binobj_id) {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RBinFile *r_bin_file_find_by_object_id(RBin *bin, ut32 binobj_id) {\n\tRListIter *iter;\n\tRBinFile *binfile;\n\tr_list_foreach (bin->binfiles, iter, binfile) {\n\t\tif (r_bin_file_object_find_by_id (binfile, binobj_id)) {\n\t\t\treturn binfile;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RBinFile *r_bin_file_find_by_id(RBin *bin, ut32 binfile_id) {\n\tRBinFile *binfile = NULL;\n\tRListIter *iter = NULL;\n\tr_list_foreach (bin->binfiles, iter, binfile) {\n\t\tif (binfile->id == binfile_id) {\n\t\t\tbreak;\n\t\t}\n\t\tbinfile = NULL;\n\t}\n\treturn binfile;\n}\n\nR_API int r_bin_file_object_add(RBinFile *binfile, RBinObject *o) {\n\tif (!o) {\n\t\treturn false;\n\t}\n\tr_list_append (binfile->objs, o);\n\tr_bin_file_set_cur_binfile_obj (binfile->rbin, binfile, o);\n\treturn true;\n}\n\nR_API int r_bin_file_delete_all(RBin *bin) {\n\tint counter = 0;\n\tif (bin) {\n\t\tcounter = r_list_length (bin->binfiles);\n\t\tr_list_purge (bin->binfiles);\n\t\tbin->cur = NULL;\n\t}\n\treturn counter;\n}\n\nR_API int r_bin_file_delete(RBin *bin, ut32 bin_fd) {\n\tRListIter *iter;\n\tRBinFile *bf;\n\tRBinFile *cur = r_bin_cur (bin);\n\tif (bin && cur) {\n\t\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\t\tif (bf && bf->fd == bin_fd) {\n\t\t\t\tif (cur->fd == bin_fd) {\n\t\t\t\t\t//avoiding UaF due to dead reference\n\t\t\t\t\tbin->cur = NULL;\n\t\t\t\t}\n\t\t\t\tr_list_delete (bin->binfiles, iter);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nR_API RBinFile *r_bin_file_find_by_fd(RBin *bin, ut32 bin_fd) {\n\tRListIter *iter;\n\tRBinFile *bf;\n\tif (bin) {\n\t\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\t\tif (bf && bf->fd == bin_fd) {\n\t\t\t\treturn bf;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RBinFile *r_bin_file_find_by_name(RBin *bin, const char *name) {\n\tRListIter *iter;\n\tRBinFile *bf = NULL;\n\tif (!bin || !name) {\n\t\treturn NULL;\n\t}\n\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\tif (bf && bf->file && !strcmp (bf->file, name)) {\n\t\t\tbreak;\n\t\t}\n\t\tbf = NULL;\n\t}\n\treturn bf;\n}\n\nR_API RBinFile *r_bin_file_find_by_name_n(RBin *bin, const char *name, int idx) {\n\tRListIter *iter;\n\tRBinFile *bf = NULL;\n\tint i = 0;\n\tif (!bin) {\n\t\treturn bf;\n\t}\n\n\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\tif (bf && bf->file && !strcmp (bf->file, name)) {\n\t\t\tif (i == idx) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tbf = NULL;\n\t}\n\treturn bf;\n}\n\nR_API int r_bin_file_set_cur_by_fd(RBin *bin, ut32 bin_fd) {\n\tRBinFile *bf = r_bin_file_find_by_fd (bin, bin_fd);\n\treturn r_bin_file_set_cur_binfile (bin, bf);\n}\n\nR_API bool r_bin_file_set_cur_binfile_obj(RBin *bin, RBinFile *bf, RBinObject *obj) {\n\tRBinPlugin *plugin = NULL;\n\tif (!bin || !bf || !obj) {\n\t\treturn false;\n\t}\n\tbin->file = bf->file;\n\tbin->cur = bf;\n\tbin->narch = bf->narch;\n\tbf->o = obj;\n\tplugin = r_bin_file_cur_plugin (bf);\n\tif (bin->minstrlen < 1) {\n\t\tbin->minstrlen = plugin? plugin->minstrlen: bin->minstrlen;\n\t}\n\treturn true;\n}\n\nR_API int r_bin_file_set_cur_binfile(RBin *bin, RBinFile *bf) {\n\tRBinObject *obj = bf? bf->o: NULL;\n\treturn r_bin_file_set_cur_binfile_obj (bin, bf, obj);\n}\n\nR_API int r_bin_file_set_cur_by_name(RBin *bin, const char *name) {\n\tRBinFile *bf = r_bin_file_find_by_name (bin, name);\n\treturn r_bin_file_set_cur_binfile (bin, bf);\n}\n\nR_API RBinObject *r_bin_file_object_get_cur(RBinFile *binfile) {\n\treturn binfile? binfile->o: NULL;\n}\n\nR_API int r_bin_file_cur_set_plugin(RBinFile *binfile, RBinPlugin *plugin) {\n\tif (binfile && binfile->o) {\n\t\tbinfile->o->plugin = plugin;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_bin_file_deref_by_bind(RBinBind *binb) {\n\tRBin *bin = binb? binb->bin: NULL;\n\tRBinFile *a = r_bin_cur (bin);\n\treturn r_bin_file_deref (bin, a);\n}\n\nR_API int r_bin_file_deref(RBin *bin, RBinFile *a) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\tint res = false;\n\tif (a && !o) {\n\t\t//r_list_delete_data (bin->binfiles, a);\n\t\tres = true;\n\t} else if (a && o->referenced - 1 < 1) {\n\t\t//r_list_delete_data (bin->binfiles, a);\n\t\tres = true;\n\t\t// not thread safe\n\t} else if (o) {\n\t\to->referenced--;\n\t}\n\t// it is possible for a file not\n\t// to be bound to RBin and RBinFiles\n\t// XXX - is this an ok assumption?\n\tif (bin) {\n\t\tbin->cur = NULL;\n\t}\n\treturn res;\n}\n\nR_API int r_bin_file_ref_by_bind(RBinBind *binb) {\n\tRBin *bin = binb? binb->bin: NULL;\n\tRBinFile *a = r_bin_cur (bin);\n\treturn r_bin_file_ref (bin, a);\n}\n\nR_API int r_bin_file_ref(RBin *bin, RBinFile *a) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\tif (a && o) {\n\t\to->referenced--;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API void r_bin_file_free(void /*RBinFile*/ *bf_) {\n\tRBinFile *a = bf_;\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (a);\n\n\tif (!a) {\n\t\treturn;\n\t}\n\t// Binary format objects are connected to the\n\t// RBinObject, so the plugin must destroy the\n\t// format data first\n\tif (plugin && plugin->destroy) {\n\t\tplugin->destroy (a);\n\t}\n\tif (a->curxtr && a->curxtr->destroy && a->xtr_obj) {\n\t\ta->curxtr->free_xtr ((void *)(a->xtr_obj));\n\t}\n\tr_buf_free (a->buf);\n\t// TODO: unset related sdb namespaces\n\tif (a && a->sdb_addrinfo) {\n\t\tsdb_free (a->sdb_addrinfo);\n\t\ta->sdb_addrinfo = NULL;\n\t}\n\tR_FREE (a->file);\n\ta->o = NULL;\n\tr_list_free (a->objs);\n\tr_list_free (a->xtr_data);\n\tif (a->id != -1) {\n\t\tr_id_pool_kick_id (a->rbin->file_ids, a->id);\n\t}\n\tmemset (a, 0, sizeof (RBinFile));\n\tfree (a);\n}\n\n// This is an unnecessary piece of overengineering\nR_API RBinFile *r_bin_file_create_append(RBin *bin, const char *file, const ut8 *bytes, ut64 sz, ut64 file_sz, int rawstr, int fd, const char *xtrname, bool steal_ptr) {\n\tRBinFile *bf = r_bin_file_new (bin, file, bytes, sz, file_sz, rawstr,\n\t\t\t\t       fd, xtrname, bin->sdb, steal_ptr);\n\tif (bf) {\n\t\tr_list_append (bin->binfiles, bf);\n\t}\n\treturn bf;\n}\n\n// This function populate RBinFile->xtr_data, that information is enough to\n// create RBinObject when needed using r_bin_file_object_new_from_xtr_data\nR_API RBinFile *r_bin_file_xtr_load_bytes(RBin *bin, RBinXtrPlugin *xtr, const char *filename, const ut8 *bytes, ut64 sz, ut64 file_sz, ut64 baseaddr, ut64 loadaddr, int idx, int fd, int rawstr) {\n\tif (!bin || !bytes) {\n\t\treturn NULL;\n\t}\n\tRBinFile *bf = r_bin_file_find_by_name (bin, filename);\n\tif (!bf) {\n\t\tbf = r_bin_file_create_append (bin, filename, bytes, sz,\n\t\t\t\t\t       file_sz, rawstr, fd, xtr->name, false);\n\t\tif (!bf) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!bin->cur) {\n\t\t\tbin->cur = bf;\n\t\t}\n\t}\n\tif (bf->xtr_data) {\n\t\tr_list_free (bf->xtr_data);\n\t}\n\tif (xtr && bytes) {\n\t\tRList *xtr_data_list = xtr->extractall_from_bytes (bin, bytes, sz);\n\t\tRListIter *iter;\n\t\tRBinXtrData *xtr;\n\t\t//populate xtr_data with baddr and laddr that will be used later on\n\t\t//r_bin_file_object_new_from_xtr_data\n\t\tr_list_foreach (xtr_data_list, iter, xtr) {\n\t\t\txtr->baddr = baseaddr? baseaddr : UT64_MAX;\n\t\t\txtr->laddr = loadaddr? loadaddr : UT64_MAX;\n\t\t}\n\t\tbf->loadaddr = loadaddr;\n\t\tbf->xtr_data = xtr_data_list ? xtr_data_list : NULL;\n\t}\n\treturn bf;\n}\n\n#define LIMIT_SIZE 0\nR_API int r_bin_file_set_bytes(RBinFile *binfile, const ut8 *bytes, ut64 sz, bool steal_ptr) {\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tif (!bytes) {\n\t\treturn false;\n\t}\n\tr_buf_free (binfile->buf);\n\tbinfile->buf = r_buf_new ();\n#if LIMIT_SIZE\n\tif (sz > 1024 * 1024) {\n\t\teprintf (\"Too big\\n\");\n\t\t// TODO: use r_buf_io instead of setbytes all the time to save memory\n\t\treturn NULL;\n\t}\n#else\n\tif (steal_ptr) {\n\t\tr_buf_set_bytes_steal (binfile->buf, bytes, sz);\n\t} else {\n\t\tr_buf_set_bytes (binfile->buf, bytes, sz);\n\t}\n#endif\n\treturn binfile->buf != NULL;\n}\n\nR_API RBinPlugin *r_bin_file_cur_plugin(RBinFile *binfile) {\n\treturn binfile && binfile->o? binfile->o->plugin: NULL;\n}\n\nstatic int is_data_section(RBinFile *a, RBinSection *s) {\n\tif (s->has_strings || s->is_data) {\n\t\treturn true;\n\t}\n\tif (s->is_data) {\n\t\treturn true;\n\t}\n \t// Rust\n\treturn (strstr (s->name, \"_const\") != NULL);\n}\n\nR_API RList *r_bin_file_get_strings(RBinFile *a, int min, int dump) {\n\tRListIter *iter;\n\tRBinSection *section;\n\tRBinObject *o = a? a->o: NULL;\n\tRList *ret;\n\n\tif (dump) {\n\t\t/* dump to stdout, not stored in list */\n\t\tret = NULL;\n\t} else {\n\t\tret = r_list_newf (r_bin_string_free);\n\t\tif (!ret) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (o && o->sections && !r_list_empty (o->sections) && !a->rawstr) {\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tif (is_data_section (a, section)) {\n\t\t\t\tr_bin_file_get_strings_range (a, ret, min, section->paddr,\n\t\t\t\t\t\tsection->paddr + section->size);\n\t\t\t}\n\t\t}\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tRBinString *s;\n\t\t\tRListIter *iter2;\n\t\t\t/* load objc/swift strings */\n\t\t\tconst int bits = (a->o && a->o->info) ? a->o->info->bits : 32;\n\t\t\tconst int cfstr_size = (bits == 64) ? 32 : 16;\n\t\t\tconst int cfstr_offs = (bits == 64) ? 16 :  8;\n\t\t\tif (strstr (section->name, \"__cfstring\")) {\n\t\t\t\tint i;\n// XXX do not walk if bin.strings == 0\n\t\t\t\tut8 *p;\n\t\t\t\tfor (i = 0; i < section->size; i += cfstr_size) {\n\t\t\t\t\tut8 buf[32];\n\t\t\t\t\tif (!r_buf_read_at (\n\t\t\t\t\t\t    a->buf, section->paddr + i + cfstr_offs,\n\t\t\t\t\t\t    buf, sizeof (buf))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp = buf;\n\t\t\t\t\tut64 cfstr_vaddr = section->vaddr + i;\n\t\t\t\t\tut64 cstr_vaddr = (bits == 64)\n\t\t\t\t\t\t\t\t   ? r_read_le64 (p)\n\t\t\t\t\t\t\t\t   : r_read_le32 (p);\n\t\t\t\t\tr_list_foreach (ret, iter2, s) {\n\t\t\t\t\t\tif (s->vaddr == cstr_vaddr) {\n\t\t\t\t\t\t\tRBinString *bs = R_NEW0 (RBinString);\n\t\t\t\t\t\t\tif (bs) {\n\t\t\t\t\t\t\t\tbs->type = s->type;\n\t\t\t\t\t\t\t\tbs->length = s->length;\n\t\t\t\t\t\t\t\tbs->size = s->size;\n\t\t\t\t\t\t\t\tbs->ordinal = s->ordinal;\n\t\t\t\t\t\t\t\tbs->paddr = bs->vaddr = cfstr_vaddr;\n\t\t\t\t\t\t\t\tbs->string = r_str_newf (\"cstr.%s\", s->string);\n\t\t\t\t\t\t\t\tr_list_append (ret, bs);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (a) {\n\t\t\tr_bin_file_get_strings_range (a, ret, min, 0, a->size);\n\t\t}\n\t}\n\treturn ret;\n}\n\nR_API void r_bin_file_get_strings_range(RBinFile *bf, RList *list, int min, ut64 from, ut64 to) {\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (bf);\n\tRBinString *ptr;\n\tRListIter *it;\n\n\tif (!bf || !bf->buf) {\n\t\treturn;\n\t}\n\tif (!bf->rawstr) {\n\t\tif (!plugin || !plugin->info) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!min) {\n\t\tmin = plugin? plugin->minstrlen: 4;\n\t}\n\t/* Some plugins return zero, fix it up */\n\tif (!min) {\n\t\tmin = 4;\n\t}\n\tif (min < 0) {\n\t\treturn;\n\t}\n\tif (!to || to > bf->buf->length) {\n\t\tto = r_buf_size (bf->buf);\n\t}\n\tif (!to) {\n\t\teprintf (\"Empty file with fd %d?\\n\", bf->buf->fd);\n\t\treturn;\n\t}\n\tif (bf->rawstr != 2) {\n\t\tut64 size = to - from;\n\t\t// in case of dump ignore here\n\t\tif (bf->rbin->maxstrbuf && size && size > bf->rbin->maxstrbuf) {\n\t\t\tif (bf->rbin->verbose) {\n\t\t\t\teprintf (\"WARNING: bin_strings buffer is too big \"\n\t\t\t\t\t\"(0x%08\" PFMT64x\n\t\t\t\t\t\").\"\n\t\t\t\t\t\" Use -zzz or set bin.maxstrbuf \"\n\t\t\t\t\t\"(RABIN2_MAXSTRBUF) in r2 (rabin2)\\n\",\n\t\t\t\t\tsize);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\tif (string_scan_range (list, bf, min, from, to, -1) < 0) {\n\t\treturn;\n\t}\n\tr_list_foreach (list, it, ptr) {\n\t\tRBinSection *s = r_bin_get_section_at (bf->o, ptr->paddr, false);\n\t\tif (s) {\n\t\t\tptr->vaddr = s->vaddr + (ptr->paddr - s->paddr);\n\t\t}\n\t}\n}\n\nR_API ut64 r_bin_file_get_baddr(RBinFile *binfile) {\n\treturn binfile? r_bin_object_get_baddr (binfile->o): UT64_MAX;\n}\n\n"], "fixing_code": ["/* radare2 - LGPL - Copyright 2009-2018 - pancake, nibble, dso */\n\n#include <r_bin.h>\n\n// maybe too big sometimes? 2KB of stack eaten here..\n#define R_STRING_SCAN_BUFFER_SIZE 2048\n\nstatic void print_string(RBinString *string, RBinFile *bf) {\n\tif (!string || !bf) {\n\t\treturn;\n\t}\n\tint mode = bf->strmode;\n\tut64 addr , vaddr;\n\tRBin *bin = bf->rbin;\n\tconst char *section_name, *type_string;\n\tRIO *io = bin->iob.io;\n\tif (!io) {\n\t\treturn;\n\t}\n\tRBinSection *s = r_bin_get_section_at (bf->o, string->paddr, false);\n\tif (s) {\n\t\tstring->vaddr = s->vaddr + (string->paddr - s->paddr);\n\t}\n\tsection_name = s ? s->name : \"\";\n\ttype_string = r_bin_string_type (string->type);\n\tvaddr = addr = r_bin_get_vaddr (bin, string->paddr, string->vaddr);\n\n\tswitch(mode) {\n\tcase MODE_SIMPLE :\n\t\tio->cb_printf (\"0x%08\" PFMT64x \" %s\\n\", addr, string->string);\n\t\tbreak;\n\tcase MODE_RADARE :\n\t\t{\n\t\tchar *f_name, *nstr;\n\t\tf_name = strdup (string->string);\n\t\tr_name_filter (f_name, 512);\n\t\tif (bin->prefix) {\n\t\t\tnstr = r_str_newf (\"%s.str.%s\", bin->prefix, f_name);\n\t\t\tio->cb_printf (\"f %s.str.%s %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\"\n\t\t\t\t\t\"Cs %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tbin->prefix, f_name, string->size, addr,\n\t\t\t\t\tstring->size, addr);\n\t\t} else {\n\t\t\tnstr = r_str_newf (\"str.%s\", f_name);\n\t\t\tio->cb_printf (\"f str.%s %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\"\n\t\t\t\t\t\"Cs %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tf_name, string->size, addr,\n\t\t\t\t\tstring->size, addr);\n\t\t}\n\t\tfree (nstr);\n\t\tfree (f_name);\n\t\tbreak;\n\t\t}\n\tcase MODE_PRINT :\n\t\tio->cb_printf (\"%03u 0x%08\"PFMT64x\" 0x%08\"\n\t\t\t\tPFMT64x\" %3u %3u \"\n\t\t\t\t\"(%s) %5s %s\\n\",\n\t\t\t\tstring->ordinal, string->paddr, vaddr,\n\t\t\t\tstring->length, string->size,\n\t\t\t\tsection_name, type_string, string->string);\n\t\tbreak;\n\t}\n}\n\nstatic int string_scan_range(RList *list, RBinFile *bf, int min,\n\t\t\t      const ut64 from, const ut64 to, int type) {\n\tut8 tmp[R_STRING_SCAN_BUFFER_SIZE];\n\tut64 str_start, needle = from;\n\tint count = 0, i, rc, runes;\n\tint str_type = R_STRING_TYPE_DETECT;\n\n\tif (type == -1) {\n\t\ttype = R_STRING_TYPE_DETECT;\n\t}\n\tif (from >= to) {\n\t\teprintf (\"Invalid range to find strings 0x%llx .. 0x%llx\\n\", from, to);\n\t\treturn -1;\n\t}\n\tint len = to - from;\n\tut8 *buf = calloc (len, 1);\n\tif (!buf || !min) {\n\t\treturn -1;\n\t}\n\tr_buf_read_at (bf->buf, from, buf, len);\n\t// may oobread\n\twhile (needle < to) {\n\t\trc = r_utf8_decode (buf + needle - from, to - needle, NULL);\n\t\tif (!rc) {\n\t\t\tneedle++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (type == R_STRING_TYPE_DETECT) {\n\t\t\tchar *w = (char *)buf + needle + rc - from;\n\t\t\tif ((to - needle) > 5 + rc) {\n\t\t\t\tbool is_wide32 = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);\n\t\t\t\tif (is_wide32) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_WIDE32;\n\t\t\t\t} else {\n\t\t\t\t\tbool is_wide = needle + rc + 2 < to && !w[0] && w[1] && !w[2];\n\t\t\t\t\tstr_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr_type = R_STRING_TYPE_ASCII;\n\t\t\t}\n\t\t} else {\n\t\t\tstr_type = type;\n\t\t}\n\t\trunes = 0;\n\t\tstr_start = needle;\n\n\t\t/* Eat a whole C string */\n\t\tfor (rc = i = 0; i < sizeof (tmp) - 3 && needle < to; i += rc) {\n\t\t\tRRune r = {0};\n\n\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\trc = r_utf32le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc) {\n\t\t\t\t\trc = 4;\n\t\t\t\t}\n\t\t\t} else if (str_type == R_STRING_TYPE_WIDE) {\n\t\t\t\trc = r_utf16le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc == 1) {\n\t\t\t\t\trc = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = r_utf8_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Invalid sequence detected */\n\t\t\tif (!rc) {\n\t\t\t\tneedle++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tneedle += rc;\n\n\t\t\tif (r_isprint (r) && r != '\\\\') {\n\t\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\t\tif (r == 0xff) {\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trc = r_utf8_encode (&tmp[i], r);\n\t\t\t\trunes++;\n\t\t\t\t/* Print the escape code */\n\t\t\t} else if (r && r < 0x100 && strchr (\"\\b\\v\\f\\n\\r\\t\\a\\033\\\\\", (char)r)) {\n\t\t\t\tif ((i + 32) < sizeof (tmp) && r < 93) {\n\t\t\t\t\ttmp[i + 0] = '\\\\';\n\t\t\t\t\ttmp[i + 1] = \"       abtnvfr             e  \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"  \\\\\"[r];\n\t\t\t\t} else {\n\t\t\t\t\t// string too long\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trc = 2;\n\t\t\t\trunes++;\n\t\t\t} else {\n\t\t\t\t/* \\0 marks the end of C-strings */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttmp[i++] = '\\0';\n\n\t\tif (runes >= min) {\n\t\t\tif (str_type == R_STRING_TYPE_ASCII) {\n\t\t\t\t// reduce false positives\n\t\t\t\tint j;\n\t\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\tchar ch = tmp[j];\n\t\t\t\t\tif (ch != '\\n' && ch != '\\r' && ch != '\\t') {\n\t\t\t\t\t\tif (!IS_PRINTABLE (tmp[j])) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tRBinString *bs = R_NEW0 (RBinString);\n\t\t\tif (!bs) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbs->type = str_type;\n\t\t\tbs->length = runes;\n\t\t\tbs->size = needle - str_start;\n\t\t\tbs->ordinal = count++;\n\t\t\t// TODO: move into adjust_offset\n\t\t\tswitch (str_type) {\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\t\tif (str_start -from> 1) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 2 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 2; // \\xff\\xfe\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tif (str_start -from> 3) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 4 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 4; // \\xff\\xfe\\x00\\x00\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbs->paddr = bs->vaddr = str_start;\n\t\t\tbs->string = r_str_ndup ((const char *)tmp, i);\n\t\t\tif (list) {\n\t\t\t\tr_list_append (list, bs);\n\t\t\t} else {\n\t\t\t\tprint_string (bs, bf);\n\t\t\t\tr_bin_string_free (bs);\n\t\t\t}\n\t\t}\n\t}\n\tfree (buf);\n\treturn count;\n}\n\nstatic char *swiftField(const char *dn, const char *cn) {\n\tchar *p = strstr (dn, \".getter_\");\n\tif (!p) {\n\t\tp = strstr (dn, \".setter_\");\n\t\tif (!p) {\n\t\t\tp = strstr (dn, \".method_\");\n\t\t}\n\t}\n\tif (p) {\n\t\tchar *q = strstr (dn, cn);\n\t\tif (q && q[strlen (cn)] == '.') {\n\t\t\tq = strdup (q + strlen (cn) + 1);\n\t\t\tchar *r = strchr (q, '.');\n\t\t\tif (r) {\n\t\t\t\t*r = 0;\n\t\t\t}\n\t\t\treturn q;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RList *r_bin_classes_from_symbols (RBinFile *bf, RBinObject *o) {\n\tRBinSymbol *sym;\n\tRListIter *iter;\n\tRList *symbols = o->symbols;\n\tRList *classes = o->classes;\n\tif (!classes) {\n\t\tclasses = r_list_newf ((RListFree)r_bin_class_free);\n\t}\n\tr_list_foreach (symbols, iter, sym) {\n\t\tif (sym->name[0] != '_') {\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *cn = sym->classname;\n\t\tif (cn) {\n\t\t\tRBinClass *c = r_bin_class_new (bf, sym->classname, NULL, 0);\n\t\t\tif (!c) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// swift specific\n\t\t\tchar *dn = sym->dname;\n\t\t\tchar *fn = swiftField (dn, cn);\n\t\t\tif (fn) {\n\t\t\t\t// eprintf (\"FIELD %s  %s\\n\", cn, fn);\n\t\t\t\tRBinField *f = r_bin_field_new (sym->paddr, sym->vaddr, sym->size, fn, NULL, NULL);\n\t\t\t\tr_list_append (c->fields, f);\n\t\t\t\tfree (fn);\n\t\t\t} else {\n\t\t\t\tchar *mn = strstr (dn, \"..\");\n\t\t\t\tif (mn) {\n\t\t\t\t\t// eprintf (\"META %s  %s\\n\", sym->classname, mn);\n\t\t\t\t} else {\n\t\t\t\t\tchar *mn = strstr (dn, cn);\n\t\t\t\t\tif (mn && mn[strlen(cn)] == '.') {\n\t\t\t\t\t\tmn += strlen (cn) + 1;\n\t\t\t\t\t\t// eprintf (\"METHOD %s  %s\\n\", sym->classname, mn);\n\t\t\t\t\t\tr_list_append (c->methods, sym);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (r_list_empty (classes)) {\n\t\tr_list_free (classes);\n\t\treturn NULL;\n\t}\n\treturn classes;\n}\n\nR_API RBinFile *r_bin_file_new(RBin *bin, const char *file, const ut8 *bytes, ut64 sz, ut64 file_sz, int rawstr, int fd, const char *xtrname, Sdb *sdb, bool steal_ptr) {\n\tRBinFile *binfile = R_NEW0 (RBinFile);\n\tif (!binfile) {\n\t\treturn NULL;\n\t}\n\tif (!r_id_pool_grab_id (bin->file_ids, &binfile->id)) {\n\t\tif (steal_ptr) { // we own the ptr, free on error\n\t\t\tfree ((void*) bytes);\n\t\t}\n\t\tfree (binfile);\t\t//no id means no binfile\n\t\treturn NULL;\n\t}\n\tint res = r_bin_file_set_bytes (binfile, bytes, sz, steal_ptr);\n\tif (!res && steal_ptr) { // we own the ptr, free on error\n\t\tfree((void*) bytes);\n\t}\n\tbinfile->rbin = bin;\n\tbinfile->file = file? strdup (file): NULL;\n\tbinfile->rawstr = rawstr;\n\tbinfile->fd = fd;\n\tbinfile->curxtr = r_bin_get_xtrplugin_by_name (bin, xtrname);\n\tbinfile->sdb = sdb;\n\tbinfile->size = file_sz;\n\tbinfile->xtr_data = r_list_newf ((RListFree)r_bin_xtrdata_free);\n\tbinfile->objs = r_list_newf ((RListFree)r_bin_object_free);\n\tbinfile->xtr_obj  = NULL;\n\n\tif (!binfile->buf) {\n\t\t//r_bin_file_free (binfile);\n\t\tbinfile->buf = r_buf_new ();\n\t\t//\treturn NULL;\n\t}\n\n\tif (sdb) {\n\t\tbinfile->sdb = sdb_ns (sdb, sdb_fmt (\"fd.%d\", fd), 1);\n\t\tsdb_set (binfile->sdb, \"archs\", \"0:0:x86:32\", 0); // x86??\n\t\t/* NOTE */\n\t\t/* Those refs++ are necessary because sdb_ns() doesnt rerefs all\n\t\t * sub-namespaces */\n\t\t/* And if any namespace is referenced backwards it gets\n\t\t * double-freed */\n\t\tbinfile->sdb_addrinfo = sdb_ns (binfile->sdb, \"addrinfo\", 1);\n\t\tbinfile->sdb_addrinfo->refs++;\n\t\tsdb_ns_set (sdb, \"cur\", binfile->sdb);\n\t\tbinfile->sdb->refs++;\n\t}\n\treturn binfile;\n}\n\nR_API bool r_bin_file_object_new_from_xtr_data(RBin *bin, RBinFile *bf, ut64 baseaddr, ut64 loadaddr, RBinXtrData *data) {\n\tRBinObject *o = NULL;\n\tRBinPlugin *plugin = NULL;\n\tut8* bytes;\n\tut64 offset = data? data->offset: 0;\n\tut64 sz = data ? data->size : 0;\n\tif (!data || !bf) {\n\t\treturn false;\n\t}\n\n\t// for right now the bytes used will just be the offest into the binfile\n\t// buffer\n\t// if the extraction requires some sort of transformation then this will\n\t// need to be fixed\n\t// here.\n\tbytes = data->buffer;\n\tif (!bytes) {\n\t\treturn false;\n\t}\n\tplugin = r_bin_get_binplugin_by_bytes (bin, (const ut8*)bytes, sz);\n\tif (!plugin) {\n\t\tplugin = r_bin_get_binplugin_any (bin);\n\t}\n\tr_buf_free (bf->buf);\n\tbf->buf = r_buf_new_with_bytes ((const ut8*)bytes, data->size);\n\t//r_bin_object_new append the new object into binfile\n\to = r_bin_object_new (bf, plugin, baseaddr, loadaddr, offset, sz);\n\t// size is set here because the reported size of the object depends on\n\t// if loaded from xtr plugin or partially read\n\tif (!o) {\n\t\treturn false;\n\t}\n\tif (o && !o->size) {\n\t\to->size = sz;\n\t}\n\tbf->narch = data->file_count;\n\tif (!o->info) {\n\t\to->info = R_NEW0 (RBinInfo);\n\t}\n\tfree (o->info->file);\n\tfree (o->info->arch);\n\tfree (o->info->machine);\n\tfree (o->info->type);\n\to->info->file = strdup (bf->file);\n\to->info->arch = strdup (data->metadata->arch);\n\to->info->machine = strdup (data->metadata->machine);\n\to->info->type = strdup (data->metadata->type);\n\to->info->bits = data->metadata->bits;\n\to->info->has_crypto = bf->o->info->has_crypto;\n\tdata->loaded = true;\n\treturn true;\n}\n\n\nR_API RBinFile *r_bin_file_new_from_fd(RBin *bin, int fd, RBinFileOptions *options) {\nint file_sz = 0;\n\tRBinPlugin *plugin = NULL;\n\tRBinFile *bf = r_bin_file_create_append (bin, \"-\", NULL, 0, file_sz,\n\t\t\t\t       0, fd, NULL, false);\n\tif (!bf) {\n\t\treturn NULL;\n\t}\n\tint loadaddr = options? options->laddr: 0;\n\tint baseaddr = options? options->baddr: 0;\n\t// int loadaddr = options? options->laddr: 0;\n\tbool binfile_created = true;\n\tr_buf_free (bf->buf);\n\tbf->buf = r_buf_new_with_io (&bin->iob, fd);\n\tif (bin->force) {\n\t\tplugin = r_bin_get_binplugin_by_name (bin, bin->force);\n\t}\n\tif (!plugin) {\n\t\tif (options && options->plugname) {\n\t\t\tplugin = r_bin_get_binplugin_by_name (bin, options->plugname);\n\t\t}\n\t\tif (!plugin) {\n\t\t\tut8 bytes[1024];\n\t\t\tint sz = 1024;\n\t\t\tr_buf_read_at (bf->buf, 0, bytes, sz);\n\t\t\tplugin = r_bin_get_binplugin_by_bytes (bin, bytes, sz);\n\t\t\tif (!plugin) {\n\t\t\t\tplugin = r_bin_get_binplugin_any (bin);\n\t\t\t}\n\t\t}\n\t}\n\n\tRBinObject *o = r_bin_object_new (bf, plugin, baseaddr, loadaddr, 0, r_buf_size (bf->buf));\n\t// size is set here because the reported size of the object depends on\n\t// if loaded from xtr plugin or partially read\n\tif (o && !o->size) {\n\t\to->size = file_sz;\n\t}\n\n\tif (!o) {\n\t\tif (bf && binfile_created) {\n\t\t\tr_list_delete_data (bin->binfiles, bf);\n\t\t}\n\t\treturn NULL;\n\t}\n#if 0\n\t/* WTF */\n\tif (strcmp (plugin->name, \"any\")) {\n\t\tbf->narch = 1;\n\t}\n#endif\n\t/* free unnecessary rbuffer (???) */\n\treturn bf;\n}\n\nR_API RBinFile *r_bin_file_new_from_bytes(RBin *bin, const char *file, const ut8 *bytes, ut64 sz, ut64 file_sz, int rawstr, ut64 baseaddr, ut64 loadaddr, int fd, const char *pluginname, const char *xtrname, ut64 offset, bool steal_ptr) {\n\tut8 binfile_created = false;\n\tRBinPlugin *plugin = NULL;\n\tRBinXtrPlugin *xtr = NULL;\n\tRBinObject *o = NULL;\n\tif (sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\n\tif (xtrname) {\n\t\txtr = r_bin_get_xtrplugin_by_name (bin, xtrname);\n\t}\n\n\tif (xtr && xtr->check_bytes (bytes, sz)) {\n\t\treturn r_bin_file_xtr_load_bytes (bin, xtr, file,\n\t\t\t\t\t\tbytes, sz, file_sz, baseaddr, loadaddr, 0,\n\t\t\t\t\t\tfd, rawstr);\n\t}\n\n\tRBinFile *bf = r_bin_file_create_append (bin, file, bytes, sz, file_sz,\n\t\t\t\t       rawstr, fd, xtrname, steal_ptr);\n\tif (!bf) {\n\t\tif (!steal_ptr) { // we own the ptr, free on error\n\t\t\tfree ((void*) bytes);\n\t\t}\n\t\treturn NULL;\n\t}\n\tbinfile_created = true;\n\n\tif (bin->force) {\n\t\tplugin = r_bin_get_binplugin_by_name (bin, bin->force);\n\t}\n\tif (!plugin) {\n\t\tif (pluginname) {\n\t\t\tplugin = r_bin_get_binplugin_by_name (bin, pluginname);\n\t\t}\n\t\tif (!plugin) {\n\t\t\tplugin = r_bin_get_binplugin_by_bytes (bin, bytes, sz);\n\t\t\tif (!plugin) {\n\t\t\t\tplugin = r_bin_get_binplugin_any (bin);\n\t\t\t}\n\t\t}\n\t}\n\n\to = r_bin_object_new (bf, plugin, baseaddr, loadaddr, 0, r_buf_size (bf->buf));\n\t// size is set here because the reported size of the object depends on\n\t// if loaded from xtr plugin or partially read\n\tif (o && !o->size) {\n\t\to->size = file_sz;\n\t}\n\n\tif (!o) {\n\t\tif (bf && binfile_created) {\n\t\t\tr_list_delete_data (bin->binfiles, bf);\n\t\t}\n\t\treturn NULL;\n\t}\n#if 0\n\t/* WTF */\n\tif (strcmp (plugin->name, \"any\")) {\n\t\tbf->narch = 1;\n\t}\n#endif\n\n\t/* free unnecessary rbuffer (???) */\n\treturn bf;\n}\n\nR_API RBinFile *r_bin_file_find_by_arch_bits(RBin *bin, const char *arch, int bits, const char *name) {\n\tRListIter *iter;\n\tRBinFile *binfile = NULL;\n\tRBinXtrData *xtr_data;\n\n\tif (!name || !arch) {\n\t\treturn NULL;\n\t}\n\tr_list_foreach (bin->binfiles, iter, binfile) {\n\t\tRListIter *iter_xtr;\n\t\tif (!binfile->xtr_data) {\n\t\t\tcontinue;\n\t\t}\n\t\t// look for sub-bins in Xtr Data and Load if we need to\n\t\tr_list_foreach (binfile->xtr_data, iter_xtr, xtr_data) {\n\t\t\tif (xtr_data->metadata && xtr_data->metadata->arch) {\n\t\t\t\tchar *iter_arch = xtr_data->metadata->arch;\n\t\t\t\tint iter_bits = xtr_data->metadata->bits;\n\t\t\t\tif (bits == iter_bits && !strcmp (iter_arch, arch)) {\n\t\t\t\t\tif (!xtr_data->loaded) {\n\t\t\t\t\t\tif (!r_bin_file_object_new_from_xtr_data (\n\t\t\t\t\t\t\t    bin, binfile, xtr_data->baddr,\n\t\t\t\t\t\t\t    xtr_data->laddr, xtr_data)) {\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn binfile;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn binfile;\n}\n\nR_API RBinObject *r_bin_file_object_find_by_id(RBinFile *binfile, ut32 binobj_id) {\n\tRBinObject *obj;\n\tRListIter *iter;\n\tif (binfile)  {\n\t\tr_list_foreach (binfile->objs, iter, obj) {\n\t\t\tif (obj->id == binobj_id) {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RBinFile *r_bin_file_find_by_object_id(RBin *bin, ut32 binobj_id) {\n\tRListIter *iter;\n\tRBinFile *binfile;\n\tr_list_foreach (bin->binfiles, iter, binfile) {\n\t\tif (r_bin_file_object_find_by_id (binfile, binobj_id)) {\n\t\t\treturn binfile;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RBinFile *r_bin_file_find_by_id(RBin *bin, ut32 binfile_id) {\n\tRBinFile *binfile = NULL;\n\tRListIter *iter = NULL;\n\tr_list_foreach (bin->binfiles, iter, binfile) {\n\t\tif (binfile->id == binfile_id) {\n\t\t\tbreak;\n\t\t}\n\t\tbinfile = NULL;\n\t}\n\treturn binfile;\n}\n\nR_API int r_bin_file_object_add(RBinFile *binfile, RBinObject *o) {\n\tif (!o) {\n\t\treturn false;\n\t}\n\tr_list_append (binfile->objs, o);\n\tr_bin_file_set_cur_binfile_obj (binfile->rbin, binfile, o);\n\treturn true;\n}\n\nR_API int r_bin_file_delete_all(RBin *bin) {\n\tint counter = 0;\n\tif (bin) {\n\t\tcounter = r_list_length (bin->binfiles);\n\t\tr_list_purge (bin->binfiles);\n\t\tbin->cur = NULL;\n\t}\n\treturn counter;\n}\n\nR_API int r_bin_file_delete(RBin *bin, ut32 bin_fd) {\n\tRListIter *iter;\n\tRBinFile *bf;\n\tRBinFile *cur = r_bin_cur (bin);\n\tif (bin && cur) {\n\t\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\t\tif (bf && bf->fd == bin_fd) {\n\t\t\t\tif (cur->fd == bin_fd) {\n\t\t\t\t\t//avoiding UaF due to dead reference\n\t\t\t\t\tbin->cur = NULL;\n\t\t\t\t}\n\t\t\t\tr_list_delete (bin->binfiles, iter);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nR_API RBinFile *r_bin_file_find_by_fd(RBin *bin, ut32 bin_fd) {\n\tRListIter *iter;\n\tRBinFile *bf;\n\tif (bin) {\n\t\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\t\tif (bf && bf->fd == bin_fd) {\n\t\t\t\treturn bf;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RBinFile *r_bin_file_find_by_name(RBin *bin, const char *name) {\n\tRListIter *iter;\n\tRBinFile *bf = NULL;\n\tif (!bin || !name) {\n\t\treturn NULL;\n\t}\n\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\tif (bf && bf->file && !strcmp (bf->file, name)) {\n\t\t\tbreak;\n\t\t}\n\t\tbf = NULL;\n\t}\n\treturn bf;\n}\n\nR_API RBinFile *r_bin_file_find_by_name_n(RBin *bin, const char *name, int idx) {\n\tRListIter *iter;\n\tRBinFile *bf = NULL;\n\tint i = 0;\n\tif (!bin) {\n\t\treturn bf;\n\t}\n\n\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\tif (bf && bf->file && !strcmp (bf->file, name)) {\n\t\t\tif (i == idx) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tbf = NULL;\n\t}\n\treturn bf;\n}\n\nR_API int r_bin_file_set_cur_by_fd(RBin *bin, ut32 bin_fd) {\n\tRBinFile *bf = r_bin_file_find_by_fd (bin, bin_fd);\n\treturn r_bin_file_set_cur_binfile (bin, bf);\n}\n\nR_API bool r_bin_file_set_cur_binfile_obj(RBin *bin, RBinFile *bf, RBinObject *obj) {\n\tRBinPlugin *plugin = NULL;\n\tif (!bin || !bf || !obj) {\n\t\treturn false;\n\t}\n\tbin->file = bf->file;\n\tbin->cur = bf;\n\tbin->narch = bf->narch;\n\tbf->o = obj;\n\tplugin = r_bin_file_cur_plugin (bf);\n\tif (bin->minstrlen < 1) {\n\t\tbin->minstrlen = plugin? plugin->minstrlen: bin->minstrlen;\n\t}\n\treturn true;\n}\n\nR_API int r_bin_file_set_cur_binfile(RBin *bin, RBinFile *bf) {\n\tRBinObject *obj = bf? bf->o: NULL;\n\treturn r_bin_file_set_cur_binfile_obj (bin, bf, obj);\n}\n\nR_API int r_bin_file_set_cur_by_name(RBin *bin, const char *name) {\n\tRBinFile *bf = r_bin_file_find_by_name (bin, name);\n\treturn r_bin_file_set_cur_binfile (bin, bf);\n}\n\nR_API RBinObject *r_bin_file_object_get_cur(RBinFile *binfile) {\n\treturn binfile? binfile->o: NULL;\n}\n\nR_API int r_bin_file_cur_set_plugin(RBinFile *binfile, RBinPlugin *plugin) {\n\tif (binfile && binfile->o) {\n\t\tbinfile->o->plugin = plugin;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_bin_file_deref_by_bind(RBinBind *binb) {\n\tRBin *bin = binb? binb->bin: NULL;\n\tRBinFile *a = r_bin_cur (bin);\n\treturn r_bin_file_deref (bin, a);\n}\n\nR_API int r_bin_file_deref(RBin *bin, RBinFile *a) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\tint res = false;\n\tif (a && !o) {\n\t\t//r_list_delete_data (bin->binfiles, a);\n\t\tres = true;\n\t} else if (a && o->referenced - 1 < 1) {\n\t\t//r_list_delete_data (bin->binfiles, a);\n\t\tres = true;\n\t\t// not thread safe\n\t} else if (o) {\n\t\to->referenced--;\n\t}\n\t// it is possible for a file not\n\t// to be bound to RBin and RBinFiles\n\t// XXX - is this an ok assumption?\n\tif (bin) {\n\t\tbin->cur = NULL;\n\t}\n\treturn res;\n}\n\nR_API int r_bin_file_ref_by_bind(RBinBind *binb) {\n\tRBin *bin = binb? binb->bin: NULL;\n\tRBinFile *a = r_bin_cur (bin);\n\treturn r_bin_file_ref (bin, a);\n}\n\nR_API int r_bin_file_ref(RBin *bin, RBinFile *a) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\tif (a && o) {\n\t\to->referenced--;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API void r_bin_file_free(void /*RBinFile*/ *bf_) {\n\tRBinFile *a = bf_;\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (a);\n\n\tif (!a) {\n\t\treturn;\n\t}\n\t// Binary format objects are connected to the\n\t// RBinObject, so the plugin must destroy the\n\t// format data first\n\tif (plugin && plugin->destroy) {\n\t\tplugin->destroy (a);\n\t}\n\tif (a->curxtr && a->curxtr->destroy && a->xtr_obj) {\n\t\ta->curxtr->free_xtr ((void *)(a->xtr_obj));\n\t}\n\tr_buf_free (a->buf);\n\t// TODO: unset related sdb namespaces\n\tif (a && a->sdb_addrinfo) {\n\t\tsdb_free (a->sdb_addrinfo);\n\t\ta->sdb_addrinfo = NULL;\n\t}\n\tR_FREE (a->file);\n\ta->o = NULL;\n\tr_list_free (a->objs);\n\tr_list_free (a->xtr_data);\n\tif (a->id != -1) {\n\t\tr_id_pool_kick_id (a->rbin->file_ids, a->id);\n\t}\n\tmemset (a, 0, sizeof (RBinFile));\n\tfree (a);\n}\n\n// This is an unnecessary piece of overengineering\nR_API RBinFile *r_bin_file_create_append(RBin *bin, const char *file, const ut8 *bytes, ut64 sz, ut64 file_sz, int rawstr, int fd, const char *xtrname, bool steal_ptr) {\n\tRBinFile *bf = r_bin_file_new (bin, file, bytes, sz, file_sz, rawstr,\n\t\t\t\t       fd, xtrname, bin->sdb, steal_ptr);\n\tif (bf) {\n\t\tr_list_append (bin->binfiles, bf);\n\t}\n\treturn bf;\n}\n\n// This function populate RBinFile->xtr_data, that information is enough to\n// create RBinObject when needed using r_bin_file_object_new_from_xtr_data\nR_API RBinFile *r_bin_file_xtr_load_bytes(RBin *bin, RBinXtrPlugin *xtr, const char *filename, const ut8 *bytes, ut64 sz, ut64 file_sz, ut64 baseaddr, ut64 loadaddr, int idx, int fd, int rawstr) {\n\tif (!bin || !bytes) {\n\t\treturn NULL;\n\t}\n\tRBinFile *bf = r_bin_file_find_by_name (bin, filename);\n\tif (!bf) {\n\t\tbf = r_bin_file_create_append (bin, filename, bytes, sz,\n\t\t\t\t\t       file_sz, rawstr, fd, xtr->name, false);\n\t\tif (!bf) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!bin->cur) {\n\t\t\tbin->cur = bf;\n\t\t}\n\t}\n\tif (bf->xtr_data) {\n\t\tr_list_free (bf->xtr_data);\n\t}\n\tif (xtr && bytes) {\n\t\tRList *xtr_data_list = xtr->extractall_from_bytes (bin, bytes, sz);\n\t\tRListIter *iter;\n\t\tRBinXtrData *xtr;\n\t\t//populate xtr_data with baddr and laddr that will be used later on\n\t\t//r_bin_file_object_new_from_xtr_data\n\t\tr_list_foreach (xtr_data_list, iter, xtr) {\n\t\t\txtr->baddr = baseaddr? baseaddr : UT64_MAX;\n\t\t\txtr->laddr = loadaddr? loadaddr : UT64_MAX;\n\t\t}\n\t\tbf->loadaddr = loadaddr;\n\t\tbf->xtr_data = xtr_data_list ? xtr_data_list : NULL;\n\t}\n\treturn bf;\n}\n\n#define LIMIT_SIZE 0\nR_API int r_bin_file_set_bytes(RBinFile *binfile, const ut8 *bytes, ut64 sz, bool steal_ptr) {\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tif (!bytes) {\n\t\treturn false;\n\t}\n\tr_buf_free (binfile->buf);\n\tbinfile->buf = r_buf_new ();\n#if LIMIT_SIZE\n\tif (sz > 1024 * 1024) {\n\t\teprintf (\"Too big\\n\");\n\t\t// TODO: use r_buf_io instead of setbytes all the time to save memory\n\t\treturn NULL;\n\t}\n#else\n\tif (steal_ptr) {\n\t\tr_buf_set_bytes_steal (binfile->buf, bytes, sz);\n\t} else {\n\t\tr_buf_set_bytes (binfile->buf, bytes, sz);\n\t}\n#endif\n\treturn binfile->buf != NULL;\n}\n\nR_API RBinPlugin *r_bin_file_cur_plugin(RBinFile *binfile) {\n\treturn binfile && binfile->o? binfile->o->plugin: NULL;\n}\n\nstatic int is_data_section(RBinFile *a, RBinSection *s) {\n\tif (s->has_strings || s->is_data) {\n\t\treturn true;\n\t}\n\tif (s->is_data) {\n\t\treturn true;\n\t}\n \t// Rust\n\treturn (strstr (s->name, \"_const\") != NULL);\n}\n\nR_API RList *r_bin_file_get_strings(RBinFile *a, int min, int dump) {\n\tRListIter *iter;\n\tRBinSection *section;\n\tRBinObject *o = a? a->o: NULL;\n\tRList *ret;\n\n\tif (dump) {\n\t\t/* dump to stdout, not stored in list */\n\t\tret = NULL;\n\t} else {\n\t\tret = r_list_newf (r_bin_string_free);\n\t\tif (!ret) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (o && o->sections && !r_list_empty (o->sections) && !a->rawstr) {\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tif (is_data_section (a, section)) {\n\t\t\t\tr_bin_file_get_strings_range (a, ret, min, section->paddr,\n\t\t\t\t\t\tsection->paddr + section->size);\n\t\t\t}\n\t\t}\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tRBinString *s;\n\t\t\tRListIter *iter2;\n\t\t\t/* load objc/swift strings */\n\t\t\tconst int bits = (a->o && a->o->info) ? a->o->info->bits : 32;\n\t\t\tconst int cfstr_size = (bits == 64) ? 32 : 16;\n\t\t\tconst int cfstr_offs = (bits == 64) ? 16 :  8;\n\t\t\tif (strstr (section->name, \"__cfstring\")) {\n\t\t\t\tint i;\n// XXX do not walk if bin.strings == 0\n\t\t\t\tut8 *p;\n\t\t\t\tfor (i = 0; i < section->size; i += cfstr_size) {\n\t\t\t\t\tut8 buf[32];\n\t\t\t\t\tif (!r_buf_read_at (\n\t\t\t\t\t\t    a->buf, section->paddr + i + cfstr_offs,\n\t\t\t\t\t\t    buf, sizeof (buf))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp = buf;\n\t\t\t\t\tut64 cfstr_vaddr = section->vaddr + i;\n\t\t\t\t\tut64 cstr_vaddr = (bits == 64)\n\t\t\t\t\t\t\t\t   ? r_read_le64 (p)\n\t\t\t\t\t\t\t\t   : r_read_le32 (p);\n\t\t\t\t\tr_list_foreach (ret, iter2, s) {\n\t\t\t\t\t\tif (s->vaddr == cstr_vaddr) {\n\t\t\t\t\t\t\tRBinString *bs = R_NEW0 (RBinString);\n\t\t\t\t\t\t\tif (bs) {\n\t\t\t\t\t\t\t\tbs->type = s->type;\n\t\t\t\t\t\t\t\tbs->length = s->length;\n\t\t\t\t\t\t\t\tbs->size = s->size;\n\t\t\t\t\t\t\t\tbs->ordinal = s->ordinal;\n\t\t\t\t\t\t\t\tbs->paddr = bs->vaddr = cfstr_vaddr;\n\t\t\t\t\t\t\t\tbs->string = r_str_newf (\"cstr.%s\", s->string);\n\t\t\t\t\t\t\t\tr_list_append (ret, bs);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (a) {\n\t\t\tr_bin_file_get_strings_range (a, ret, min, 0, a->size);\n\t\t}\n\t}\n\treturn ret;\n}\n\nR_API void r_bin_file_get_strings_range(RBinFile *bf, RList *list, int min, ut64 from, ut64 to) {\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (bf);\n\tRBinString *ptr;\n\tRListIter *it;\n\n\tif (!bf || !bf->buf) {\n\t\treturn;\n\t}\n\tif (!bf->rawstr) {\n\t\tif (!plugin || !plugin->info) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!min) {\n\t\tmin = plugin? plugin->minstrlen: 4;\n\t}\n\t/* Some plugins return zero, fix it up */\n\tif (!min) {\n\t\tmin = 4;\n\t}\n\tif (min < 0) {\n\t\treturn;\n\t}\n\tif (!to || to > bf->buf->length) {\n\t\tto = r_buf_size (bf->buf);\n\t}\n\tif (!to) {\n\t\teprintf (\"Empty file with fd %d?\\n\", bf->buf->fd);\n\t\treturn;\n\t}\n\tif (bf->rawstr != 2) {\n\t\tut64 size = to - from;\n\t\t// in case of dump ignore here\n\t\tif (bf->rbin->maxstrbuf && size && size > bf->rbin->maxstrbuf) {\n\t\t\tif (bf->rbin->verbose) {\n\t\t\t\teprintf (\"WARNING: bin_strings buffer is too big \"\n\t\t\t\t\t\"(0x%08\" PFMT64x\n\t\t\t\t\t\").\"\n\t\t\t\t\t\" Use -zzz or set bin.maxstrbuf \"\n\t\t\t\t\t\"(RABIN2_MAXSTRBUF) in r2 (rabin2)\\n\",\n\t\t\t\t\tsize);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\tif (string_scan_range (list, bf, min, from, to, -1) < 0) {\n\t\treturn;\n\t}\n\tr_list_foreach (list, it, ptr) {\n\t\tRBinSection *s = r_bin_get_section_at (bf->o, ptr->paddr, false);\n\t\tif (s) {\n\t\t\tptr->vaddr = s->vaddr + (ptr->paddr - s->paddr);\n\t\t}\n\t}\n}\n\nR_API ut64 r_bin_file_get_baddr(RBinFile *binfile) {\n\treturn binfile? r_bin_object_get_baddr (binfile->o): UT64_MAX;\n}\n\n"], "filenames": ["libr/bin/file.c"], "buggy_code_start_loc": [79], "buggy_code_end_loc": [95], "fixing_code_start_loc": [79], "fixing_code_end_loc": [96], "type": "CWE-125", "message": "The string_scan_range() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted binary file.", "other": {"cve": {"id": "CVE-2018-11381", "sourceIdentifier": "cve@mitre.org", "published": "2018-05-22T19:29:00.520", "lastModified": "2018-06-27T15:18:21.250", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The string_scan_range() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted binary file."}, {"lang": "es", "value": "La funci\u00f3n string_scan_range() en radare2 2.5.0 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites basada en memoria din\u00e1mica o heap y cierre inesperado de la aplicaci\u00f3n) mediante un archivo binario manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:2.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "81E40EFA-5307-45F3-9722-CB499D21141F"}]}]}], "references": [{"url": "https://github.com/radare/radare2/commit/3fcf41ed96ffa25b38029449520c8d0a198745f3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/9902", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/3fcf41ed96ffa25b38029449520c8d0a198745f3"}}