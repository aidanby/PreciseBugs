{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        JJJJJ  PPPP   EEEEE   GGGG                           %\n%                          J    P   P  E      G                               %\n%                          J    PPPP   EEE    G  GG                           %\n%                        J J    P      E      G   G                           %\n%                        JJJ    P      EEEEE   GGG                            %\n%                                                                             %\n%                                                                             %\n%                       Read/Write JPEG Image Format                          %\n%                                                                             %\n%                              Software Design                                %\n%                                John Cristy                                  %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2013 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% This software is based in part on the work of the Independent JPEG Group.\n% See ftp://ftp.uu.net/graphics/jpeg/jpegsrc.v6b.tar.gz for copyright and\n% licensing restrictions.  Blob support contributed by Glenn Randers-Pehrson.\n%\n%\n*/\n\n\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/option-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/xml-tree.h\"\n#include \"MagickCore/xml-tree-private.h\"\n#include <setjmp.h>\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n#define JPEG_INTERNAL_OPTIONS\n#if defined(__MINGW32__) || defined(__MINGW64__)\n# define XMD_H 1  /* Avoid conflicting typedef for INT32 */\n#endif\n#undef HAVE_STDLIB_H\n#include \"jpeglib.h\"\n#include \"jerror.h\"\n#endif\n\f\n/*\n  Define declarations.\n*/\n#define ICC_MARKER  (JPEG_APP0+2)\n#define ICC_PROFILE  \"ICC_PROFILE\"\n#define IPTC_MARKER  (JPEG_APP0+13)\n#define XML_MARKER  (JPEG_APP0+1)\n#define MaxBufferExtent  16384\n\f\n/*\n  Typedef declarations.\n*/\n#if defined(MAGICKCORE_JPEG_DELEGATE)\ntypedef struct _DestinationManager\n{\n  struct jpeg_destination_mgr\n    manager;\n\n  Image\n    *image;\n\n  JOCTET\n    *buffer;\n} DestinationManager;\n\ntypedef struct _ErrorManager\n{\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    finished;\n\n  StringInfo\n    *profile;\n\n  jmp_buf\n    error_recovery;\n} ErrorManager;\n\ntypedef struct _SourceManager\n{\n  struct jpeg_source_mgr\n    manager;\n\n  Image\n    *image;\n\n  JOCTET\n    *buffer;\n\n  boolean\n    start_of_blob;\n} SourceManager;\n#endif\n\ntypedef struct _QuantizationTable\n{\n  char\n    *slot,\n    *description;\n\n  size_t\n    width,\n    height;\n\n  double\n    divisor;\n\n  unsigned int\n    *levels;\n} QuantizationTable;\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_JPEG_DELEGATE)\nstatic MagickBooleanType\n  WriteJPEGImage(const ImageInfo *,Image *,ExceptionInfo *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s J P E G                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsJPEG() returns MagickTrue if the image format type, identified by the\n%  magick string, is JPEG.\n%\n%  The format of the IsJPEG  method is:\n%\n%      MagickBooleanType IsJPEG(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsJPEG(const unsigned char *magick,const size_t length)\n{\n  if (length < 3)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\377\\330\\377\",3) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d J P E G I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadJPEGImage() reads a JPEG image file and returns it.  It allocates\n%  the memory necessary for the new Image structure and returns a pointer to\n%  the new image.\n%\n%  The format of the ReadJPEGImage method is:\n%\n%      Image *ReadJPEGImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic boolean FillInputBuffer(j_decompress_ptr cinfo)\n{\n  SourceManager\n    *source;\n\n  source=(SourceManager *) cinfo->src;\n  source->manager.bytes_in_buffer=(size_t) ReadBlob(source->image,\n    MaxBufferExtent,source->buffer);\n  if (source->manager.bytes_in_buffer == 0)\n    {\n      if (source->start_of_blob != FALSE)\n        ERREXIT(cinfo,JERR_INPUT_EMPTY);\n      WARNMS(cinfo,JWRN_JPEG_EOF);\n      source->buffer[0]=(JOCTET) 0xff;\n      source->buffer[1]=(JOCTET) JPEG_EOI;\n      source->manager.bytes_in_buffer=2;\n    }\n  source->manager.next_input_byte=source->buffer;\n  source->start_of_blob=FALSE;\n  return(TRUE);\n}\n\nstatic int GetCharacter(j_decompress_ptr jpeg_info)\n{\n  if (jpeg_info->src->bytes_in_buffer == 0)\n    (void) (*jpeg_info->src->fill_input_buffer)(jpeg_info);\n  jpeg_info->src->bytes_in_buffer--;\n  return((int) GETJOCTET(*jpeg_info->src->next_input_byte++));\n}\n\nstatic void InitializeSource(j_decompress_ptr cinfo)\n{\n  SourceManager\n    *source;\n\n  source=(SourceManager *) cinfo->src;\n  source->start_of_blob=TRUE;\n}\n\nstatic MagickBooleanType IsITUFaxImage(const Image *image)\n{\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *datum;\n\n  profile=GetImageProfile(image,\"8bim\");\n  if (profile == (const StringInfo *) NULL)\n    return(MagickFalse);\n  if (GetStringInfoLength(profile) < 5)\n    return(MagickFalse);\n  datum=GetStringInfoDatum(profile);\n  if ((datum[0] == 0x47) && (datum[1] == 0x33) && (datum[2] == 0x46) &&\n      (datum[3] == 0x41) && (datum[4] == 0x58))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic void JPEGErrorHandler(j_common_ptr jpeg_info)\n{\n  char\n    message[JMSG_LENGTH_MAX];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  *message='\\0';\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n  exception=error_manager->exception;\n  (jpeg_info->err->format_message)(jpeg_info,message);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"[%s] JPEG Trace: \\\"%s\\\"\",image->filename,message);\n  if (error_manager->finished != MagickFalse)\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageWarning,\n      (char *) message,\"`%s'\",image->filename);\n  else\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n      (char *) message,\"`%s'\",image->filename);\n  longjmp(error_manager->error_recovery,1);\n}\n\nstatic MagickBooleanType JPEGWarningHandler(j_common_ptr jpeg_info,int level)\n{\n#define JPEGExcessiveWarnings  1000\n\n  char\n    message[JMSG_LENGTH_MAX];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  *message='\\0';\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  if (level < 0)\n    {\n      /*\n        Process warning message.\n      */\n      (jpeg_info->err->format_message)(jpeg_info,message);\n      if (jpeg_info->err->num_warnings++ > JPEGExcessiveWarnings)\n        JPEGErrorHandler(jpeg_info);\n      ThrowBinaryException(CorruptImageWarning,(char *) message,\n        image->filename);\n    }\n  else\n    if ((image->debug != MagickFalse) &&\n        (level >= jpeg_info->err->trace_level))\n      {\n        /*\n          Process trace message.\n        */\n        (jpeg_info->err->format_message)(jpeg_info,message);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"[%s] JPEG Trace: \\\"%s\\\"\",image->filename,message);\n      }\n  return(MagickTrue);\n}\n\nstatic boolean ReadComment(j_decompress_ptr jpeg_info)\n{\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  StringInfo\n    *comment;\n\n  /*\n    Determine length of comment.\n  */\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=GetCharacter(jpeg_info);\n  if (length <= 2)\n    return(TRUE);\n  length-=2;\n  comment=BlobToStringInfo((const void *) NULL,length);\n  if (comment == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  /*\n    Read comment.\n  */\n  error_manager->profile=comment;\n  p=GetStringInfoDatum(comment);\n  for (i=0; i < (ssize_t) GetStringInfoLength(comment); i++)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  *p='\\0';\n  error_manager->profile=NULL;\n  p=GetStringInfoDatum(comment);\n  (void) SetImageProperty(image,\"comment\",(const char *) p,exception);\n  comment=DestroyStringInfo(comment);\n  return(TRUE);\n}\n\nstatic boolean ReadICCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[12];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *icc_profile,\n    *profile;\n\n  /*\n    Read color profile.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (length-- > 0)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  for (i=0; i < 12; i++)\n    magick[i]=(char) GetCharacter(jpeg_info);\n  if (LocaleCompare(magick,ICC_PROFILE) != 0)\n    {\n      /*\n        Not a ICC profile, return.\n      */\n      for (i=0; i < (ssize_t) (length-12); i++)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  (void) GetCharacter(jpeg_info);  /* id */\n  (void) GetCharacter(jpeg_info);  /* markers */\n  length-=14;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=(ssize_t) GetStringInfoLength(profile)-1; i >= 0; i--)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  error_manager->profile=NULL;\n  icc_profile=(StringInfo *) GetImageProfile(image,\"icc\");\n  if (icc_profile != (StringInfo *) NULL)\n    {\n      ConcatenateStringInfo(icc_profile,profile);\n      profile=DestroyStringInfo(profile);\n    }\n  else\n    {\n      status=SetImageProfile(image,\"icc\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      if (status == MagickFalse)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          return(FALSE);\n        }\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: ICC, %.20g bytes\",(double) length);\n  return(TRUE);\n}\n\nstatic boolean ReadIPTCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[MagickPathExtent];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *iptc_profile,\n    *profile;\n\n  /*\n    Determine length of binary data stored here.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (length-- > 0)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  /*\n    Validate that this was written as a Photoshop resource format slug.\n  */\n  for (i=0; i < 10; i++)\n    magick[i]=(char) GetCharacter(jpeg_info);\n  magick[10]='\\0';\n  length-=10;\n  if (length <= 10)\n    return(TRUE);\n  if (LocaleCompare(magick,\"Photoshop \") != 0)\n    {\n      /*\n        Not a IPTC profile, return.\n      */\n      for (i=0; i < (ssize_t) length; i++)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  /*\n    Remove the version number.\n  */\n  for (i=0; i < 4; i++)\n    (void) GetCharacter(jpeg_info);\n  if (length <= 11)\n    return(TRUE);\n  length-=4;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0;  i < (ssize_t) GetStringInfoLength(profile); i++)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  error_manager->profile=NULL;\n  iptc_profile=(StringInfo *) GetImageProfile(image,\"8bim\");\n  if (iptc_profile != (StringInfo *) NULL)\n    {\n      ConcatenateStringInfo(iptc_profile,profile);\n      profile=DestroyStringInfo(profile);\n    }\n  else\n    {\n      status=SetImageProfile(image,\"8bim\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      if (status == MagickFalse)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          return(FALSE);\n        }\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: iptc, %.20g bytes\",(double) length);\n  return(TRUE);\n}\n\nstatic boolean ReadProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    name[MagickPathExtent];\n\n  const StringInfo\n    *previous_profile;\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  int\n    marker;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *profile;\n\n  /*\n    Read generic profile.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  if (length <= 2)\n    return(TRUE);\n  length-=2;\n  marker=jpeg_info->unread_marker-JPEG_APP0;\n  (void) FormatLocaleString(name,MagickPathExtent,\"APP%d\",marker);\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0; i < (ssize_t) GetStringInfoLength(profile); i++)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  error_manager->profile=NULL;\n  if (marker == 1)\n    {\n      p=GetStringInfoDatum(profile);\n      if ((length > 4) && (LocaleNCompare((char *) p,\"exif\",4) == 0))\n        (void) CopyMagickString(name,\"exif\",MagickPathExtent);\n      if ((length > 5) && (LocaleNCompare((char *) p,\"http:\",5) == 0))\n        {\n          ssize_t\n            j;\n\n          /*\n            Extract namespace from XMP profile.\n          */\n          p=GetStringInfoDatum(profile);\n          for (j=0; j < (ssize_t) GetStringInfoLength(profile); j++)\n          {\n            if (*p == '\\0')\n              break;\n            p++;\n          }\n          if (j < (ssize_t) GetStringInfoLength(profile))\n            (void) DestroyStringInfo(SplitStringInfo(profile,(size_t) (j+1)));\n          (void) CopyMagickString(name,\"xmp\",MagickPathExtent);\n        }\n    }\n  previous_profile=GetImageProfile(image,name);\n  if (previous_profile != (const StringInfo *) NULL)\n    {\n      size_t\n        profile_length;\n\n      profile_length=GetStringInfoLength(profile);\n      SetStringInfoLength(profile,GetStringInfoLength(profile)+\n        GetStringInfoLength(previous_profile));\n      (void) memmove(GetStringInfoDatum(profile)+\n        GetStringInfoLength(previous_profile),GetStringInfoDatum(profile),\n        profile_length);\n      (void) memcpy(GetStringInfoDatum(profile),\n        GetStringInfoDatum(previous_profile),\n        GetStringInfoLength(previous_profile));\n    }\n  status=SetImageProfile(image,name,profile,exception);\n  profile=DestroyStringInfo(profile);\n  if (status == MagickFalse)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: %s, %.20g bytes\",name,(double) length);\n  return(TRUE);\n}\n\nstatic void SkipInputData(j_decompress_ptr cinfo,long number_bytes)\n{\n  SourceManager\n    *source;\n\n  if (number_bytes <= 0)\n    return;\n  source=(SourceManager *) cinfo->src;\n  while (number_bytes > (long) source->manager.bytes_in_buffer)\n  {\n    number_bytes-=(long) source->manager.bytes_in_buffer;\n    (void) FillInputBuffer(cinfo);\n  }\n  source->manager.next_input_byte+=number_bytes;\n  source->manager.bytes_in_buffer-=number_bytes;\n}\n\nstatic void TerminateSource(j_decompress_ptr cinfo)\n{\n  (void) cinfo;\n}\n\nstatic void JPEGSourceManager(j_decompress_ptr cinfo,Image *image)\n{\n  SourceManager\n    *source;\n\n  cinfo->src=(struct jpeg_source_mgr *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,sizeof(SourceManager));\n  source=(SourceManager *) cinfo->src;\n  source->buffer=(JOCTET *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,MaxBufferExtent*sizeof(JOCTET));\n  source=(SourceManager *) cinfo->src;\n  source->manager.init_source=InitializeSource;\n  source->manager.fill_input_buffer=FillInputBuffer;\n  source->manager.skip_input_data=SkipInputData;\n  source->manager.resync_to_restart=jpeg_resync_to_restart;\n  source->manager.term_source=TerminateSource;\n  source->manager.bytes_in_buffer=0;\n  source->manager.next_input_byte=NULL;\n  source->image=image;\n}\n\nstatic void JPEGSetImageQuality(struct jpeg_decompress_struct *jpeg_info,\n  Image *image)\n{\n  image->quality=UndefinedCompressionQuality;\n#if defined(D_PROGRESSIVE_SUPPORTED)\n  if (image->compression == LosslessJPEGCompression)\n    {\n      image->quality=100;\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Quality: 100 (lossless)\");\n    }\n  else\n#endif\n  {\n    ssize_t\n      j,\n      qvalue,\n      sum;\n\n    register ssize_t\n      i;\n\n    /*\n      Determine the JPEG compression quality from the quantization tables.\n    */\n    sum=0;\n    for (i=0; i < NUM_QUANT_TBLS; i++)\n    {\n      if (jpeg_info->quant_tbl_ptrs[i] != NULL)\n        for (j=0; j < DCTSIZE2; j++)\n          sum+=jpeg_info->quant_tbl_ptrs[i]->quantval[j];\n    }\n    if ((jpeg_info->quant_tbl_ptrs[0] != NULL) &&\n        (jpeg_info->quant_tbl_ptrs[1] != NULL))\n      {\n        ssize_t\n          hash[101] =\n          {\n            1020, 1015,  932,  848,  780,  735,  702,  679,  660,  645,\n             632,  623,  613,  607,  600,  594,  589,  585,  581,  571,\n             555,  542,  529,  514,  494,  474,  457,  439,  424,  410,\n             397,  386,  373,  364,  351,  341,  334,  324,  317,  309,\n             299,  294,  287,  279,  274,  267,  262,  257,  251,  247,\n             243,  237,  232,  227,  222,  217,  213,  207,  202,  198,\n             192,  188,  183,  177,  173,  168,  163,  157,  153,  148,\n             143,  139,  132,  128,  125,  119,  115,  108,  104,   99,\n              94,   90,   84,   79,   74,   70,   64,   59,   55,   49,\n              45,   40,   34,   30,   25,   20,   15,   11,    6,    4,\n               0\n          },\n          sums[101] =\n          {\n            32640, 32635, 32266, 31495, 30665, 29804, 29146, 28599, 28104,\n            27670, 27225, 26725, 26210, 25716, 25240, 24789, 24373, 23946,\n            23572, 22846, 21801, 20842, 19949, 19121, 18386, 17651, 16998,\n            16349, 15800, 15247, 14783, 14321, 13859, 13535, 13081, 12702,\n            12423, 12056, 11779, 11513, 11135, 10955, 10676, 10392, 10208,\n             9928,  9747,  9564,  9369,  9193,  9017,  8822,  8639,  8458,\n             8270,  8084,  7896,  7710,  7527,  7347,  7156,  6977,  6788,\n             6607,  6422,  6236,  6054,  5867,  5684,  5495,  5305,  5128,\n             4945,  4751,  4638,  4442,  4248,  4065,  3888,  3698,  3509,\n             3326,  3139,  2957,  2775,  2586,  2405,  2216,  2037,  1846,\n             1666,  1483,  1297,  1109,   927,   735,   554,   375,   201,\n              128,     0\n          };\n\n        qvalue=(ssize_t) (jpeg_info->quant_tbl_ptrs[0]->quantval[2]+\n          jpeg_info->quant_tbl_ptrs[0]->quantval[53]+\n          jpeg_info->quant_tbl_ptrs[1]->quantval[0]+\n          jpeg_info->quant_tbl_ptrs[1]->quantval[DCTSIZE2-1]);\n        for (i=0; i < 100; i++)\n        {\n          if ((qvalue < hash[i]) && (sum < sums[i]))\n            continue;\n          if (((qvalue <= hash[i]) && (sum <= sums[i])) || (i >= 50))\n            image->quality=(size_t) i+1;\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"Quality: %.20g (%s)\",(double) i+1,(qvalue <= hash[i]) &&\n              (sum <= sums[i]) ? \"exact\" : \"approximate\");\n          break;\n        }\n      }\n    else\n      if (jpeg_info->quant_tbl_ptrs[0] != NULL)\n        {\n          ssize_t\n            hash[101] =\n            {\n              510,  505,  422,  380,  355,  338,  326,  318,  311,  305,\n              300,  297,  293,  291,  288,  286,  284,  283,  281,  280,\n              279,  278,  277,  273,  262,  251,  243,  233,  225,  218,\n              211,  205,  198,  193,  186,  181,  177,  172,  168,  164,\n              158,  156,  152,  148,  145,  142,  139,  136,  133,  131,\n              129,  126,  123,  120,  118,  115,  113,  110,  107,  105,\n              102,  100,   97,   94,   92,   89,   87,   83,   81,   79,\n               76,   74,   70,   68,   66,   63,   61,   57,   55,   52,\n               50,   48,   44,   42,   39,   37,   34,   31,   29,   26,\n               24,   21,   18,   16,   13,   11,    8,    6,    3,    2,\n                0\n            },\n            sums[101] =\n            {\n              16320, 16315, 15946, 15277, 14655, 14073, 13623, 13230, 12859,\n              12560, 12240, 11861, 11456, 11081, 10714, 10360, 10027,  9679,\n               9368,  9056,  8680,  8331,  7995,  7668,  7376,  7084,  6823,\n               6562,  6345,  6125,  5939,  5756,  5571,  5421,  5240,  5086,\n               4976,  4829,  4719,  4616,  4463,  4393,  4280,  4166,  4092,\n               3980,  3909,  3835,  3755,  3688,  3621,  3541,  3467,  3396,\n               3323,  3247,  3170,  3096,  3021,  2952,  2874,  2804,  2727,\n               2657,  2583,  2509,  2437,  2362,  2290,  2211,  2136,  2068,\n               1996,  1915,  1858,  1773,  1692,  1620,  1552,  1477,  1398,\n               1326,  1251,  1179,  1109,  1031,   961,   884,   814,   736,\n                667,   592,   518,   441,   369,   292,   221,   151,    86,\n                 64,     0\n            };\n\n          qvalue=(ssize_t) (jpeg_info->quant_tbl_ptrs[0]->quantval[2]+\n            jpeg_info->quant_tbl_ptrs[0]->quantval[53]);\n          for (i=0; i < 100; i++)\n          {\n            if ((qvalue < hash[i]) && (sum < sums[i]))\n              continue;\n            if (((qvalue <= hash[i]) && (sum <= sums[i])) || (i >= 50))\n              image->quality=(size_t)i+1;\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Quality: %.20g (%s)\",(double) i+1,(qvalue <= hash[i]) &&\n                (sum <= sums[i]) ? \"exact\" : \"approximate\");\n            break;\n          }\n        }\n  }\n}\n\nstatic void JPEGSetImageSamplingFactor(struct jpeg_decompress_struct *jpeg_info,  Image *image,ExceptionInfo *exception)\n{\n  char\n    sampling_factor[MagickPathExtent];\n\n  switch (jpeg_info->out_color_space)\n  {\n    case JCS_CMYK:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: CMYK\");\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n        \"%dx%d,%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor,\n        jpeg_info->comp_info[3].h_samp_factor,\n        jpeg_info->comp_info[3].v_samp_factor);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Colorspace: GRAYSCALE\");\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\"%dx%d\",\n        jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor);\n      break;\n    }\n    case JCS_RGB:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: RGB\");\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n        \"%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor);\n      break;\n    }\n    default:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: %d\",\n        jpeg_info->out_color_space);\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n        \"%dx%d,%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor,\n        jpeg_info->comp_info[3].h_samp_factor,\n        jpeg_info->comp_info[3].v_samp_factor);\n      break;\n    }\n  }\n  (void) SetImageProperty(image,\"jpeg:sampling-factor\",sampling_factor,\n    exception);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Sampling Factors: %s\",\n    sampling_factor);\n}\n\nstatic Image *ReadJPEGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    value[MagickPathExtent];\n\n  const char\n    *option;\n\n  ErrorManager\n    error_manager;\n\n  Image\n    *image;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *memory_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    i;\n\n  struct jpeg_decompress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  register JSAMPLE\n    *p;\n\n  size_t\n    units;\n\n  ssize_t\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  debug=IsEventLogging();\n  (void) debug;\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize JPEG parameters.\n  */\n  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));\n  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));\n  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  memory_info=(MemoryInfo *) NULL;\n  error_manager.exception=exception;\n  error_manager.image=image;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      if (error_manager.profile != (StringInfo *) NULL)\n        error_manager.profile=DestroyStringInfo(error_manager.profile);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      return(DestroyImage(image));\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_decompress(&jpeg_info);\n  JPEGSourceManager(&jpeg_info,image);\n  jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);\n  option=GetImageOption(image_info,\"profile:skip\");\n  if (IsOptionMember(\"ICC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);\n  if (IsOptionMember(\"IPTC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);\n  for (i=1; i < 16; i++)\n    if ((i != 2) && (i != 13) && (i != 14))\n      if (IsOptionMember(\"APP\",option) == MagickFalse)\n        jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);\n  i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);\n  if ((image_info->colorspace == YCbCrColorspace) ||\n      (image_info->colorspace == Rec601YCbCrColorspace) ||\n      (image_info->colorspace == Rec709YCbCrColorspace))\n    jpeg_info.out_color_space=JCS_YCbCr;\n  /*\n    Set image resolution.\n  */\n  units=0;\n  if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&\n      (jpeg_info.Y_density != 1))\n    {\n      image->resolution.x=(double) jpeg_info.X_density;\n      image->resolution.y=(double) jpeg_info.Y_density;\n      units=(size_t) jpeg_info.density_unit;\n    }\n  if (units == 1)\n    image->units=PixelsPerInchResolution;\n  if (units == 2)\n    image->units=PixelsPerCentimeterResolution;\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  option=GetImageOption(image_info,\"jpeg:size\");\n  if ((option != (const char *) NULL) &&\n      (jpeg_info.out_color_space != JCS_YCbCr))\n    {\n      double\n        scale_factor;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Scale the image.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & SigmaValue) == 0)\n        geometry_info.sigma=geometry_info.rho;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      image->magick_columns=jpeg_info.output_width;\n      image->magick_rows=jpeg_info.output_height;\n      scale_factor=1.0;\n      if (geometry_info.rho != 0.0)\n        scale_factor=jpeg_info.output_width/geometry_info.rho;\n      if ((geometry_info.sigma != 0.0) &&\n          (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))\n        scale_factor=jpeg_info.output_height/geometry_info.sigma;\n      jpeg_info.scale_num=1U;\n      jpeg_info.scale_denom=(unsigned int) scale_factor;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Scale factor: %.20g\",(double) scale_factor);\n    }\n#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)\n#if defined(D_LOSSLESS_SUPPORTED)\n  image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?\n    JPEGInterlace : NoInterlace;\n  image->compression=jpeg_info.process == JPROC_LOSSLESS ?\n    LosslessJPEGCompression : JPEGCompression;\n  if (jpeg_info.data_precision > 8)\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n      \"12-bit JPEG not supported. Reducing pixel data to 8 bits\",\"`%s'\",\n      image->filename);\n  if (jpeg_info.data_precision == 16)\n    jpeg_info.data_precision=12;\n#else\n  image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :\n    NoInterlace;\n  image->compression=JPEGCompression;\n#endif\n#else\n  image->compression=JPEGCompression;\n  image->interlace=JPEGInterlace;\n#endif\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    {\n      /*\n        Let the JPEG library quantize the image.\n      */\n      jpeg_info.quantize_colors=TRUE;\n      jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);\n    }\n  option=GetImageOption(image_info,\"jpeg:block-smoothing\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  jpeg_info.dct_method=JDCT_FLOAT;\n  option=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (option != (const char *) NULL)\n    switch (*option)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(option,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(option,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(option,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(option,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(option,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:fancy-upsampling\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  (void) jpeg_start_decompress(&jpeg_info);\n  image->columns=jpeg_info.output_width;\n  image->rows=jpeg_info.output_height;\n  image->depth=(size_t) jpeg_info.data_precision;\n  switch (jpeg_info.out_color_space)\n  {\n    case JCS_RGB:\n    default:\n    {\n      (void) SetImageColorspace(image,sRGBColorspace,exception);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) SetImageColorspace(image,GRAYColorspace,exception);\n      break;\n    }\n    case JCS_YCbCr:\n    {\n      (void) SetImageColorspace(image,YCbCrColorspace,exception);\n      break;\n    }\n    case JCS_CMYK:\n    {\n      (void) SetImageColorspace(image,CMYKColorspace,exception);\n      break;\n    }\n  }\n  if (IsITUFaxImage(image) != MagickFalse)\n    {\n      (void) SetImageColorspace(image,LabColorspace,exception);\n      jpeg_info.out_color_space=JCS_YCbCr;\n    }\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    if (AcquireImageColormap(image,StringToUnsignedLong(option),exception)\n         == MagickFalse)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))\n    {\n      size_t\n        colors;\n\n      colors=(size_t) GetQuantumRange(image->depth)+1;\n      if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  if (image->debug != MagickFalse)\n    {\n      if (image->interlace != NoInterlace)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: nonprogressive\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Data precision: %d\",\n        (int) jpeg_info.data_precision);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %dx%d\",\n        (int) jpeg_info.output_width,(int) jpeg_info.output_height);\n    }\n  JPEGSetImageQuality(&jpeg_info,image);\n  JPEGSetImageSamplingFactor(&jpeg_info,image,exception);\n  (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n    jpeg_info.out_color_space);\n  (void) SetImageProperty(image,\"jpeg:colorspace\",value,exception);\n  if (image_info->ping != MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      return(DestroyImageList(image));\n    }\n  if ((jpeg_info.output_components != 1) &&\n      (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(CorruptImageError,\"ImageTypeNotSupported\");\n    }\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.output_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n  /*\n    Convert JPEG pixels to pixel packets.\n  */\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      return(DestroyImage(image));\n    }\n  if (jpeg_info.quantize_colors != 0)\n    {\n      image->colors=(size_t) jpeg_info.actual_number_of_colors;\n      if (jpeg_info.out_color_space == JCS_GRAYSCALE)\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[0][i]);\n          image->colormap[i].green=image->colormap[i].red;\n          image->colormap[i].blue=image->colormap[i].red;\n          image->colormap[i].alpha=(MagickRealType) OpaqueAlpha;\n        }\n      else\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[0][i]);\n          image->colormap[i].green=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[1][i]);\n          image->colormap[i].blue=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[2][i]);\n          image->colormap[i].alpha=(MagickRealType) OpaqueAlpha;\n        }\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);\n        continue;\n      }\n    p=jpeg_pixels;\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    if (jpeg_info.data_precision > 8)\n      {\n        unsigned short\n          scale;\n\n        scale=65535/(unsigned short) GetQuantumRange((size_t)\n          jpeg_info.data_precision);\n        if (jpeg_info.output_components == 1)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            ssize_t\n              pixel;\n\n            pixel=(ssize_t) (scale*GETJSAMPLE(*p));\n            index=(Quantum) ConstrainColormapIndex(image,pixel,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        else\n          if (image->colorspace != CMYKColorspace)\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelGreen(image,ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelBlue(image,ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelAlpha(image,OpaqueAlpha,q);\n              q+=GetPixelChannels(image);\n            }\n          else\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelCyan(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelMagenta(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelYellow(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelBlack(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelAlpha(image,OpaqueAlpha,q);\n              q+=GetPixelChannels(image);\n            }\n      }\n    else\n      if (jpeg_info.output_components == 1)\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          index=(Quantum) ConstrainColormapIndex(image,(ssize_t) GETJSAMPLE(*p),\n            exception);\n          SetPixelIndex(image,index,q);\n          SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n      else\n        if (image->colorspace != CMYKColorspace)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)),q);\n            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)),q);\n            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n        else\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelMagenta(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelYellow(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelBlack(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      {\n        jpeg_abort_decompress(&jpeg_info);\n        break;\n      }\n  }\n  if (status != MagickFalse)\n    {\n      error_manager.finished=MagickTrue;\n      if (setjmp(error_manager.error_recovery) == 0)\n        (void) jpeg_finish_decompress(&jpeg_info);\n    }\n  /*\n    Free jpeg resources.\n  */\n  jpeg_destroy_decompress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r J P E G I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterJPEGImage() adds properties for the JPEG image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterJPEGImage method is:\n%\n%      size_t RegisterJPEGImage(void)\n%\n*/\nModuleExport size_t RegisterJPEGImage(void)\n{\n#define JPEGDescription \"Joint Photographic Experts Group JFIF format\"\n\n  char\n    version[MagickPathExtent];\n\n  MagickInfo\n    *entry;\n\n  *version='\\0';\n#if defined(JPEG_LIB_VERSION)\n  (void) FormatLocaleString(version,MagickPathExtent,\"%d\",JPEG_LIB_VERSION);\n#endif\n  entry=AcquireMagickInfo(\"JPEG\",\"JPE\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsJPEG;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"JPEG\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsJPEG;\n  entry->flags^=CoderAdjoinFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"JPG\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"JPS\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"PJPEG\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r J P E G I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterJPEGImage() removes format registrations made by the\n%  JPEG module from the list of supported formats.\n%\n%  The format of the UnregisterJPEGImage method is:\n%\n%      UnregisterJPEGImage(void)\n%\n*/\nModuleExport void UnregisterJPEGImage(void)\n{\n  (void) UnregisterMagickInfo(\"PJPG\");\n  (void) UnregisterMagickInfo(\"JPS\");\n  (void) UnregisterMagickInfo(\"JPG\");\n  (void) UnregisterMagickInfo(\"JPEG\");\n  (void) UnregisterMagickInfo(\"JPE\");\n}\n\f\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  W r i t e J P E G I m a g e                                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteJPEGImage() writes a JPEG image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the WriteJPEGImage method is:\n%\n%      MagickBooleanType WriteJPEGImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o jpeg_image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic QuantizationTable *DestroyQuantizationTable(QuantizationTable *table)\n{\n  assert(table != (QuantizationTable *) NULL);\n  if (table->slot != (char *) NULL)\n    table->slot=DestroyString(table->slot);\n  if (table->description != (char *) NULL)\n    table->description=DestroyString(table->description);\n  if (table->levels != (unsigned int *) NULL)\n    table->levels=(unsigned int *) RelinquishMagickMemory(table->levels);\n  table=(QuantizationTable *) RelinquishMagickMemory(table);\n  return(table);\n}\n\nstatic boolean EmptyOutputBuffer(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  destination->manager.free_in_buffer=(size_t) WriteBlob(destination->image,\n    MaxBufferExtent,destination->buffer);\n  if (destination->manager.free_in_buffer != MaxBufferExtent)\n    ERREXIT(cinfo,JERR_FILE_WRITE);\n  destination->manager.next_output_byte=destination->buffer;\n  return(TRUE);\n}\n\nstatic QuantizationTable *GetQuantizationTable(const char *filename,\n  const char *slot,ExceptionInfo *exception)\n{\n  char\n    *p,\n    *xml;\n\n  const char\n    *attribute,\n    *content;\n\n  double\n    value;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    j;\n\n  QuantizationTable\n    *table;\n\n  size_t\n    length;\n\n  XMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\n\n  (void) LogMagickEvent(ConfigureEvent,GetMagickModule(),\n    \"Loading quantization tables \\\"%s\\\" ...\",filename);\n  table=(QuantizationTable *) NULL;\n  xml=FileToString(filename,~0UL,exception);\n  if (xml == (char *) NULL)\n    return(table);\n  quantization_tables=NewXMLTree(xml,exception);\n  if (quantization_tables == (XMLTreeInfo *) NULL)\n    {\n      xml=DestroyString(xml);\n      return(table);\n    }\n  for (table_iterator=GetXMLTreeChild(quantization_tables,\"table\");\n       table_iterator != (XMLTreeInfo *) NULL;\n       table_iterator=GetNextXMLTreeTag(table_iterator))\n  {\n    attribute=GetXMLTreeAttribute(table_iterator,\"slot\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(slot,attribute) == 0))\n      break;\n    attribute=GetXMLTreeAttribute(table_iterator,\"alias\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(slot,attribute) == 0))\n      break;\n  }\n  if (table_iterator == (XMLTreeInfo *) NULL)\n    {\n      xml=DestroyString(xml);\n      return(table);\n    }\n  description=GetXMLTreeChild(table_iterator,\"description\");\n  if (description == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\",\"<description>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  levels=GetXMLTreeChild(table_iterator,\"levels\");\n  if (levels == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\",\"<levels>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));\n  if (table == (QuantizationTable *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\n      \"UnableToAcquireQuantizationTable\");\n  table->slot=(char *) NULL;\n  table->description=(char *) NULL;\n  table->levels=(unsigned int *) NULL;\n  attribute=GetXMLTreeAttribute(table_iterator,\"slot\");\n  if (attribute != (char *) NULL)\n    table->slot=ConstantString(attribute);\n  content=GetXMLTreeContent(description);\n  if (content != (char *) NULL)\n    table->description=ConstantString(content);\n  attribute=GetXMLTreeAttribute(levels,\"width\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels width>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->width=StringToUnsignedLong(attribute);\n  if (table->width == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n       \"XmlInvalidAttribute\",\"<levels width>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"height\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels height>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->height=StringToUnsignedLong(attribute);\n  if (table->height == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\",\"<levels height>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"divisor\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels divisor>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->divisor=InterpretLocaleValue(attribute,(char **) NULL);\n  if (table->divisor == 0.0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\",\"<levels divisor>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  content=GetXMLTreeContent(levels);\n  if (content == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingContent\",\"<levels>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  length=(size_t) table->width*table->height;\n  if (length < 64)\n    length=64;\n  table->levels=(unsigned int *) AcquireQuantumMemory(length,\n    sizeof(*table->levels));\n  if (table->levels == (unsigned int *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\n      \"UnableToAcquireQuantizationTable\");\n  for (i=0; i < (ssize_t) (table->width*table->height); i++)\n  {\n    table->levels[i]=(unsigned int) (InterpretLocaleValue(content,&p)/\n      table->divisor+0.5);\n    while (isspace((int) ((unsigned char) *p)) != 0)\n      p++;\n    if (*p == ',')\n      p++;\n    content=p;\n  }\n  value=InterpretLocaleValue(content,&p);\n  (void) value;\n  if (p != content)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidContent\",\"<level> too many values, table \\\"%s\\\"\",slot);\n     quantization_tables=DestroyXMLTree(quantization_tables);\n     table=DestroyQuantizationTable(table);\n     xml=DestroyString(xml);\n     return(table);\n   }\n  for (j=i; j < 64; j++)\n    table->levels[j]=table->levels[j-1];\n  quantization_tables=DestroyXMLTree(quantization_tables);\n  xml=DestroyString(xml);\n  return(table);\n}\n\nstatic void InitializeDestination(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  destination->buffer=(JOCTET *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,MaxBufferExtent*sizeof(JOCTET));\n  destination->manager.next_output_byte=destination->buffer;\n  destination->manager.free_in_buffer=MaxBufferExtent;\n}\n\nstatic void TerminateDestination(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  if ((MaxBufferExtent-(int) destination->manager.free_in_buffer) > 0)\n    {\n      ssize_t\n        count;\n\n      count=WriteBlob(destination->image,MaxBufferExtent-\n        destination->manager.free_in_buffer,destination->buffer);\n      if (count != (ssize_t)\n          (MaxBufferExtent-destination->manager.free_in_buffer))\n        ERREXIT(cinfo,JERR_FILE_WRITE);\n    }\n}\n\nstatic void WriteProfile(j_compress_ptr jpeg_info,Image *image)\n{\n  const char\n    *name;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    iptc;\n\n  register ssize_t\n    i;\n\n  size_t\n    length,\n    tag_length;\n\n  StringInfo\n    *custom_profile;\n\n  /*\n    Save image profile as a APP marker.\n  */\n  iptc=MagickFalse;\n  custom_profile=AcquireStringInfo(65535L);\n  ResetImageProfileIterator(image);\n  for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n  {\n    profile=GetImageProfile(image,name);\n    if (LocaleCompare(name,\"EXIF\") == 0)\n      for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=65533L)\n      {\n        length=MagickMin(GetStringInfoLength(profile)-i,65533L);\n        jpeg_write_marker(jpeg_info,XML_MARKER,GetStringInfoDatum(profile)+i,\n          (unsigned int) length);\n      }\n    if (LocaleCompare(name,\"ICC\") == 0)\n      {\n        register unsigned char\n          *p;\n\n        tag_length=strlen(ICC_PROFILE);\n        p=GetStringInfoDatum(custom_profile);\n        (void) CopyMagickMemory(p,ICC_PROFILE,tag_length);\n        p[tag_length]='\\0';\n        for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=65519L)\n        {\n          length=MagickMin(GetStringInfoLength(profile)-i,65519L);\n          p[12]=(unsigned char) ((i/65519L)+1);\n          p[13]=(unsigned char) (GetStringInfoLength(profile)/65519L+1);\n          (void) CopyMagickMemory(p+tag_length+3,GetStringInfoDatum(profile)+i,\n            length);\n          jpeg_write_marker(jpeg_info,ICC_MARKER,GetStringInfoDatum(\n            custom_profile),(unsigned int) (length+tag_length+3));\n        }\n      }\n    if (((LocaleCompare(name,\"IPTC\") == 0) ||\n        (LocaleCompare(name,\"8BIM\") == 0)) && (iptc == MagickFalse))\n      {\n        register unsigned char\n          *p;\n\n        size_t\n          roundup;\n\n        iptc=MagickTrue;\n        p=GetStringInfoDatum(custom_profile);\n        for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=65500L)\n        {\n          length=MagickMin(GetStringInfoLength(profile)-i,65500L);\n          roundup=(size_t) (length & 0x01);\n          if (LocaleNCompare((char *) GetStringInfoDatum(profile),\"8BIM\",4) == 0)\n            {\n              (void) memcpy(p,\"Photoshop 3.0 \",14);\n              tag_length=14;\n            }\n          else\n            {\n              (void) CopyMagickMemory(p,\"Photoshop 3.0 8BIM\\04\\04\\0\\0\\0\\0\",24);\n              tag_length=26;\n              p[24]=(unsigned char) (length >> 8);\n              p[25]=(unsigned char) (length & 0xff);\n            }\n          p[13]=0x00;\n          (void) memcpy(p+tag_length,GetStringInfoDatum(profile)+i,length);\n          if (roundup != 0)\n            p[length+tag_length]='\\0';\n          jpeg_write_marker(jpeg_info,IPTC_MARKER,GetStringInfoDatum(\n            custom_profile),(unsigned int) (length+tag_length+roundup));\n        }\n      }\n    if (LocaleCompare(name,\"XMP\") == 0)\n      {\n        StringInfo\n          *xmp_profile;\n\n        /*\n          Add namespace to XMP profile.\n        */\n        xmp_profile=StringToStringInfo(\"http://ns.adobe.com/xap/1.0/ \");\n        if (xmp_profile != (StringInfo *) NULL)\n          {\n            if (profile != (StringInfo *) NULL)\n              ConcatenateStringInfo(xmp_profile,profile);\n            GetStringInfoDatum(xmp_profile)[28]='\\0';\n            for (i=0; i < (ssize_t) GetStringInfoLength(xmp_profile); i+=65533L)\n            {\n              length=MagickMin(GetStringInfoLength(xmp_profile)-i,65533L);\n              jpeg_write_marker(jpeg_info,XML_MARKER,\n                GetStringInfoDatum(xmp_profile)+i,(unsigned int) length);\n            }\n            xmp_profile=DestroyStringInfo(xmp_profile);\n          }\n      }\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"%s profile: %.20g bytes\",name,(double) GetStringInfoLength(profile));\n    name=GetNextImageProfile(image);\n  }\n  custom_profile=DestroyStringInfo(custom_profile);\n}\n\nstatic void JPEGDestinationManager(j_compress_ptr cinfo,Image * image)\n{\n  DestinationManager\n    *destination;\n\n  cinfo->dest=(struct jpeg_destination_mgr *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,sizeof(DestinationManager));\n  destination=(DestinationManager *) cinfo->dest;\n  destination->manager.init_destination=InitializeDestination;\n  destination->manager.empty_output_buffer=EmptyOutputBuffer;\n  destination->manager.term_destination=TerminateDestination;\n  destination->image=image;\n}\n\nstatic char **SamplingFactorToList(const char *text)\n{\n  char\n    **textlist;\n\n  register char\n    *q;\n\n  register const char\n    *p;\n\n  register ssize_t\n    i;\n\n  if (text == (char *) NULL)\n    return((char **) NULL);\n  /*\n    Convert string to an ASCII list.\n  */\n  textlist=(char **) AcquireQuantumMemory((size_t) MAX_COMPONENTS,\n    sizeof(*textlist));\n  if (textlist == (char **) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToConvertText\");\n  p=text;\n  for (i=0; i < (ssize_t) MAX_COMPONENTS; i++)\n  {\n    for (q=(char *) p; *q != '\\0'; q++)\n      if (*q == ',')\n        break;\n    textlist[i]=(char *) AcquireQuantumMemory((size_t) (q-p)+MagickPathExtent,\n      sizeof(*textlist[i]));\n    if (textlist[i] == (char *) NULL)\n      ThrowFatalException(ResourceLimitFatalError,\"UnableToConvertText\");\n    (void) CopyMagickString(textlist[i],p,(size_t) (q-p+1));\n    if (*q == '\\r')\n      q++;\n    if (*q == '\\0')\n      break;\n    p=q+1;\n  }\n  for (i++; i < (ssize_t) MAX_COMPONENTS; i++)\n    textlist[i]=ConstantString(\"1x1\");\n  return(textlist);\n}\n\nstatic MagickBooleanType WriteJPEGImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *option,\n    *sampling_factor,\n    *value;\n\n  ErrorManager\n    error_manager;\n\n  Image\n    *volatile volatile_image;\n\n  int\n    colorspace,\n    quality;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *memory_info;\n\n  register JSAMPLE\n    *q;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  struct jpeg_compress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  unsigned short\n    scale;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if ((LocaleCompare(image_info->magick,\"JPS\") == 0) &&\n      (image->next != (Image *) NULL))\n    image=AppendImages(image,MagickFalse,exception);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize JPEG parameters.\n  */\n  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));\n  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));\n  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));\n  volatile_image=image;\n  jpeg_info.client_data=(void *) volatile_image;\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  error_manager.exception=exception;\n  error_manager.image=volatile_image;\n  memory_info=(MemoryInfo *) NULL;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_compress(&jpeg_info);\n      (void) CloseBlob(volatile_image);\n      return(MagickFalse);\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_compress(&jpeg_info);\n  JPEGDestinationManager(&jpeg_info,image);\n  if ((image->columns != (unsigned int) image->columns) ||\n      (image->rows != (unsigned int) image->rows))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  jpeg_info.image_width=(unsigned int) image->columns;\n  jpeg_info.image_height=(unsigned int) image->rows;\n  jpeg_info.input_components=3;\n  jpeg_info.data_precision=8;\n  jpeg_info.in_color_space=JCS_RGB;\n  switch (image->colorspace)\n  {\n    case CMYKColorspace:\n    {\n      jpeg_info.input_components=4;\n      jpeg_info.in_color_space=JCS_CMYK;\n      break;\n    }\n    case YCbCrColorspace:\n    case Rec601YCbCrColorspace:\n    case Rec709YCbCrColorspace:\n    {\n      jpeg_info.in_color_space=JCS_YCbCr;\n      break;\n    }\n    case GRAYColorspace:\n    {\n      if (image_info->type == TrueColorType)\n        break;\n      jpeg_info.input_components=1;\n      jpeg_info.in_color_space=JCS_GRAYSCALE;\n      break;\n    }\n    default:\n    {\n      (void) TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image_info->type == TrueColorType)\n        break;\n      if (SetImageGray(image,exception) != MagickFalse)\n        {\n          jpeg_info.input_components=1;\n          jpeg_info.in_color_space=JCS_GRAYSCALE;\n        }\n      break;\n    }\n  }\n  jpeg_set_defaults(&jpeg_info);\n  if (jpeg_info.in_color_space == JCS_CMYK)\n    jpeg_set_colorspace(&jpeg_info,JCS_YCCK);\n  if ((jpeg_info.data_precision != 12) && (image->depth <= 8))\n    jpeg_info.data_precision=8;\n  else\n    jpeg_info.data_precision=BITS_IN_JSAMPLE;\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Image resolution: %.20g,%.20g\",image->resolution.x,image->resolution.y);\n  if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))\n    {\n      /*\n        Set image resolution.\n      */\n      jpeg_info.write_JFIF_header=TRUE;\n      jpeg_info.X_density=(UINT16) image->resolution.x;\n      jpeg_info.Y_density=(UINT16) image->resolution.y;\n      /*\n        Set image resolution units.\n      */\n      if (image->units == PixelsPerInchResolution)\n        jpeg_info.density_unit=(UINT8) 1;\n      if (image->units == PixelsPerCentimeterResolution)\n        jpeg_info.density_unit=(UINT8) 2;\n    }\n  jpeg_info.dct_method=JDCT_FLOAT;\n  option=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (option != (const char *) NULL)\n    switch (*option)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(option,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(option,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(option,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(option,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(option,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:optimize-coding\");\n  if (option != (const char *) NULL)\n    jpeg_info.optimize_coding=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  else\n    {\n      MagickSizeType\n        length;\n\n      length=(MagickSizeType) jpeg_info.input_components*image->columns*\n        image->rows*sizeof(JSAMPLE);\n      if (length == (MagickSizeType) ((size_t) length))\n        {\n          /*\n            Perform optimization only if available memory resources permit it.\n          */\n          status=AcquireMagickResource(MemoryResource,length);\n          RelinquishMagickResource(MemoryResource,length);\n          jpeg_info.optimize_coding=status == MagickFalse ? FALSE : TRUE;\n        }\n    }\n#if (JPEG_LIB_VERSION >= 61) && defined(C_PROGRESSIVE_SUPPORTED)\n  if ((LocaleCompare(image_info->magick,\"PJPEG\") == 0) ||\n      (image_info->interlace != NoInterlace))\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      jpeg_simple_progression(&jpeg_info);\n    }\n  else\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Interlace: non-progressive\");\n#else\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Interlace: nonprogressive\");\n#endif\n  quality=92;\n  if ((image_info->compression != LosslessJPEGCompression) &&\n      (image->quality <= 100))\n    {\n      if (image->quality != UndefinedCompressionQuality)\n        quality=(int) image->quality;\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Quality: %.20g\",\n          (double) image->quality);\n    }\n  else\n    {\n#if !defined(C_LOSSLESS_SUPPORTED)\n      quality=100;\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Quality: 100\");\n#else\n      if (image->quality < 100)\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n          \"LosslessToLossyJPEGConversion\",image->filename);\n      else\n        {\n          int\n            point_transform,\n            predictor;\n\n          predictor=image->quality/100;  /* range 1-7 */\n          point_transform=image->quality % 20;  /* range 0-15 */\n          jpeg_simple_lossless(&jpeg_info,predictor,point_transform);\n          if (image->debug != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Compression: lossless\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Predictor: %d\",predictor);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Point Transform: %d\",point_transform);\n            }\n        }\n#endif\n    }\n  option=GetImageOption(image_info,\"jpeg:extent\");\n  if (option != (const char *) NULL)\n    {\n      Image\n        *jpeg_image;\n\n      ImageInfo\n        *extent_info;\n\n      extent_info=CloneImageInfo(image_info);\n      extent_info->blob=NULL;\n      jpeg_image=CloneImage(image,0,0,MagickTrue,exception);\n      if (jpeg_image != (Image *) NULL)\n        {\n          MagickSizeType\n            extent;\n\n          size_t\n            maximum,\n            minimum;\n\n          /*\n            Search for compression quality that does not exceed image extent.\n          */\n          extent_info->quality=0;\n          extent=(MagickSizeType) SiPrefixToDoubleInterval(option,100.0);\n          (void) DeleteImageOption(extent_info,\"jpeg:extent\");\n          (void) DeleteImageArtifact(jpeg_image,\"jpeg:extent\");\n          maximum=image_info->quality;\n          if (maximum < 2)\n            maximum=101;\n          for (minimum=2; minimum < maximum; )\n          {\n            (void) AcquireUniqueFilename(jpeg_image->filename);\n            jpeg_image->quality=minimum+(maximum-minimum+1)/2;\n            status=WriteJPEGImage(extent_info,jpeg_image,exception);\n            if (GetBlobSize(jpeg_image) <= extent)\n              minimum=jpeg_image->quality+1;\n            else\n              maximum=jpeg_image->quality-1;\n            (void) RelinquishUniqueFileResource(jpeg_image->filename);\n          }\n          quality=(int) minimum-1;\n          jpeg_image=DestroyImage(jpeg_image);\n        }\n      extent_info=DestroyImageInfo(extent_info);\n    }\n  jpeg_set_quality(&jpeg_info,quality,TRUE);\n#if (JPEG_LIB_VERSION >= 70)\n  option=GetImageOption(image_info,\"quality\");\n  if (option != (const char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      int\n        flags;\n\n      /*\n        Set quality scaling for luminance and chrominance separately.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if (((flags & RhoValue) != 0) && ((flags & SigmaValue) != 0))\n        {\n          jpeg_info.q_scale_factor[0]=jpeg_quality_scaling((int)\n            (geometry_info.rho+0.5));\n          jpeg_info.q_scale_factor[1]=jpeg_quality_scaling((int)\n            (geometry_info.sigma+0.5));\n          jpeg_default_qtables(&jpeg_info,TRUE);\n        }\n    }\n#endif\n  colorspace=jpeg_info.in_color_space;\n  value=GetImageOption(image_info,\"jpeg:colorspace\");\n  if (value == (char *) NULL)\n    value=GetImageProperty(image,\"jpeg:colorspace\",exception);\n  if (value != (char *) NULL)\n    colorspace=StringToInteger(value);\n  sampling_factor=(const char *) NULL;\n  if (colorspace == jpeg_info.in_color_space)\n    {\n      value=GetImageOption(image_info,\"jpeg:sampling-factor\");\n      if (value == (char *) NULL)\n        value=GetImageProperty(image,\"jpeg:sampling-factor\",exception);\n      if (value != (char *) NULL)\n        {\n          sampling_factor=value;\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Input sampling-factors=%s\",sampling_factor);\n        }\n    }\n  value=GetImageOption(image_info,\"jpeg:sampling-factor\");\n  if (image_info->sampling_factor != (char *) NULL)\n    sampling_factor=image_info->sampling_factor;\n  if (sampling_factor == (const char *) NULL)\n    {\n      if (quality >= 90)\n        for (i=0; i < MAX_COMPONENTS; i++)\n        {\n          jpeg_info.comp_info[i].h_samp_factor=1;\n          jpeg_info.comp_info[i].v_samp_factor=1;\n        }\n    }\n  else\n    {\n      char\n        **factors;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Set sampling factor.\n      */\n      i=0;\n      factors=SamplingFactorToList(sampling_factor);\n      if (factors != (char **) NULL)\n        {\n          for (i=0; i < MAX_COMPONENTS; i++)\n          {\n            if (factors[i] == (char *) NULL)\n              break;\n            flags=ParseGeometry(factors[i],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            jpeg_info.comp_info[i].h_samp_factor=(int) geometry_info.rho;\n            jpeg_info.comp_info[i].v_samp_factor=(int) geometry_info.sigma;\n            factors[i]=(char *) RelinquishMagickMemory(factors[i]);\n          }\n          factors=(char **) RelinquishMagickMemory(factors);\n        }\n      for ( ; i < MAX_COMPONENTS; i++)\n      {\n        jpeg_info.comp_info[i].h_samp_factor=1;\n        jpeg_info.comp_info[i].v_samp_factor=1;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:q-table\");\n  if (option != (const char *) NULL)\n    {\n      QuantizationTable\n        *table;\n\n      /*\n        Custom quantization tables.\n      */\n      table=GetQuantizationTable(option,\"0\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=0; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=0;\n          jpeg_add_quant_table(&jpeg_info,0,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"1\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=1; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=1;\n          jpeg_add_quant_table(&jpeg_info,1,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"2\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=2; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=2;\n          jpeg_add_quant_table(&jpeg_info,2,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"3\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=3; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=3;\n          jpeg_add_quant_table(&jpeg_info,3,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n    }\n  jpeg_start_compress(&jpeg_info,TRUE);\n  if (image->debug != MagickFalse)\n    {\n      if (image->storage_class == PseudoClass)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Storage class: PseudoClass\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Storage class: DirectClass\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Depth: %.20g\",\n        (double) image->depth);\n      if (image->colors != 0)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Number of colors: %.20g\",(double) image->colors);\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Number of colors: unspecified\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"JPEG data precision: %d\",(int) jpeg_info.data_precision);\n      switch (image->colorspace)\n      {\n        case CMYKColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Storage class: DirectClass\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: CMYK\");\n          break;\n        }\n        case YCbCrColorspace:\n        case Rec601YCbCrColorspace:\n        case Rec709YCbCrColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: YCbCr\");\n          break;\n        }\n        default:\n          break;\n      }\n      switch (image->colorspace)\n      {\n        case CMYKColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: CMYK\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor,\n            jpeg_info.comp_info[3].h_samp_factor,\n            jpeg_info.comp_info[3].v_samp_factor);\n          break;\n        }\n        case GRAYColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: GRAY\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d\",jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor);\n          break;\n        }\n        case sRGBColorspace:\n        case RGBColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Image colorspace is RGB\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor);\n          break;\n        }\n        case YCbCrColorspace:\n        case Rec601YCbCrColorspace:\n        case Rec709YCbCrColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: YCbCr\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor);\n          break;\n        }\n        default:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: %d\",\n            image->colorspace);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor,\n            jpeg_info.comp_info[3].h_samp_factor,\n            jpeg_info.comp_info[3].v_samp_factor);\n          break;\n        }\n      }\n    }\n  /*\n    Write JPEG profiles.\n  */\n  value=GetImageProperty(image,\"comment\",exception);\n  if (value != (char *) NULL)\n    for (i=0; i < (ssize_t) strlen(value); i+=65533L)\n      jpeg_write_marker(&jpeg_info,JPEG_COM,(unsigned char *) value+i,\n        (unsigned int) MagickMin((size_t) strlen(value+i),65533L));\n  if (image->profiles != (void *) NULL)\n    WriteProfile(&jpeg_info,image);\n  /*\n    Convert MIFF to JPEG raster pixels.\n  */\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.input_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_compress(&jpeg_info);\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  scale=65535/(unsigned short) GetQuantumRange((size_t)\n    jpeg_info.data_precision);\n  if (scale == 0)\n    scale=1;\n  if (jpeg_info.data_precision <= 8)\n    {\n      if ((jpeg_info.in_color_space == JCS_RGB) ||\n          (jpeg_info.in_color_space == JCS_YCbCr))\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelBlue(image,p));\n            p+=GetPixelChannels(image);\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n      else\n        if (jpeg_info.in_color_space == JCS_GRAYSCALE)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register const Quantum\n              *p;\n\n            register ssize_t\n              x;\n\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            q=jpeg_pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              *q++=(JSAMPLE) ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(\n                image,p)));\n              p+=GetPixelChannels(image);\n            }\n            (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n            status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n            }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register const Quantum\n              *p;\n\n            register ssize_t\n              x;\n\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            q=jpeg_pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              /*\n                Convert DirectClass packets to contiguous CMYK scanlines.\n              */\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelCyan(image,p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelMagenta(image,p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelYellow(image,p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelBlack(image,p))));\n              p+=GetPixelChannels(image);\n            }\n            (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n            status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n    }\n  else\n    if (jpeg_info.in_color_space == JCS_GRAYSCALE)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register const Quantum\n          *p;\n\n        register ssize_t\n          x;\n\n        p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          break;\n        q=jpeg_pixels;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          *q++=(JSAMPLE) (ScaleQuantumToShort(ClampToQuantum(GetPixelLuma(image,\n            p)))/scale);\n          p+=GetPixelChannels(image);\n        }\n        (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n    else\n      if ((jpeg_info.in_color_space == JCS_RGB) ||\n          (jpeg_info.in_color_space == JCS_YCbCr))\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelRed(image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelGreen(image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelBlue(image,p))/scale);\n            p+=GetPixelChannels(image);\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n      else\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            /*\n              Convert DirectClass packets to contiguous CMYK scanlines.\n            */\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelRed(\n              image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelGreen(\n              image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelBlue(\n              image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelBlack(\n              image,p))/scale);\n            p+=GetPixelChannels(image);\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n  if (y == (ssize_t) image->rows)\n    jpeg_finish_compress(&jpeg_info);\n  /*\n    Relinquish resources.\n  */\n  jpeg_destroy_compress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n#endif\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE locale [\n<!ELEMENT locale (exception)>\n<!ELEMENT exception (ANY)+>\n<!ELEMENT warning (message)+>\n<!ELEMENT error (message)+>\n<!ELEMENT fatalerror (message)+>\n<!ELEMENT message (#PCDATA)>\n<!ATTLIST locale name CDATA #REQUIRED>\n<!ATTLIST message name CDATA #REQUIRED>\n]>\n<locale name=\"english\">\n  <exception>\n    <blob>\n      <error>\n        <message name=\"UnableToOpenBlob\">\n          unable to open image\n        </message>\n        <message name=\"UnableToOpenFile\">\n          unable to open file\n        </message>\n        <message name=\"UnableToReadBlob\">\n          unable to read blob\n        </message>\n        <message name=\"UnableToWriteBlob\">\n          unable to write blob\n        </message>\n        <message name=\"UnrecognizedImageFormat\">\n          unrecognized image format\n        </message>\n        <message name=\"ZeroLengthBlobNotPermitted\">\n          zero-length blob not permitted\n        </message>\n      </error>\n    </blob>\n    <cache>\n      <error>\n        <message name=\"CacheResourcesExhausted\">\n          cache resources exhausted\n        </message>\n        <message name=\"IncompatibleAPI\">\n          incompatible API\n        </message>\n        <message name=\"NoPixelsDefinedInCache\">\n          no pixels defined in cache\n        </message>\n        <message name=\"PixelCacheIsNotOpen\">\n          pixel cache is not open\n        </message>\n        <message name=\"PixelsAreNotAuthentic\">\n          pixels are not authentic\n        </message>\n        <message name=\"UnableToCloneCache\">\n          unable to clone cache\n        </message>\n        <message name=\"UnableToExtendCache\">\n          unable to extend cache\n        </message>\n        <message name=\"UnableToGetCacheNexus\">\n          unable to get cache nexus\n        </message>\n        <message name=\"UnableToOpenPixelCache\">\n          unable to open pixel cache\n        </message>\n        <message name=\"UnableToPersistPixelCache\">\n          unable to persist pixel cache\n        </message>\n        <message name=\"UnableToReadPixelCache\">\n          unable to read pixel cache\n        </message>\n        <message name=\"UnableToWritePixelCache\">\n          unable to write pixel cache\n        </message>\n      </error>\n      <fatalerror>\n        <message name=\"UnableToAcquireCacheView\">\n          unable to acquire cache view\n        </message>\n        <message name=\"UnableToExtendPixelCache\">\n          unable to extend pixel cache\n        </message>\n      </fatalerror>\n    </cache>\n    <coder>\n      <error>\n        <message name=\"ColormapTypeNotSupported\">\n          colormap type not supported\n        </message>\n        <message name=\"ColorspaceModelIsNotSupported\">\n          colorspace model is not supported\n        </message>\n        <message name=\"CompressNotSupported\">\n          compression not supported\n        </message>\n        <message name=\"DataEncodingSchemeIsNotSupported\">\n          data encoding scheme is not supported\n        </message>\n        <message name=\"DataStorageTypeIsNotSupported\">\n          data storage type is not supported\n        </message>\n        <message name=\"DeltaPNGNotSupported\">\n          delta-PNG is not supported\n        </message>\n        <message name=\"EncryptedWPGImageFileNotSupported\">\n          encrypted WPG image file not supported\n        </message>\n        <message name=\"FractalCompressNotSupported\">\n          fractal compression not supported\n        </message>\n        <message name=\"ImageColumnOrRowSizeIsNotSupported\">\n          image column or row size is not supported\n        </message>\n        <message name=\"ImageDoesNotHaveAClipMask\">\n          image does not have a clip mask\n        </message>\n        <message name=\"ImageDoesNotHaveAnAlphaChannel\">\n          image does not have an alpha channel\n        </message>\n        <message name=\"ImageDoesNotHaveAThumbnail\">\n          image does not have a EXIF thumbnail\n        </message>\n        <message name=\"ImageIsNotTiled\">\n          image is not tiled\n        </message>\n        <message name=\"IrregularChannelGeometryNotSupported\">\n          irregular channel geometry not supported\n        </message>\n        <message name=\"JNGCompressNotSupported\">\n          JNG compression not supported\n        </message>\n        <message name=\"JPEGCompressNotSupported\">\n          JPEG compression not supported\n        </message>\n        <message name=\"JPEGEmbeddingFailed\">\n          JPEG embedding failed\n        </message>\n        <message name=\"LocationTypeIsNotSupported\">\n          location type is not supported\n        </message>\n        <message name=\"MapStorageTypeIsNotSupported\">\n          map storage type is not supported\n        </message>\n        <message name=\"MultidimensionalMatricesAreNotSupported\">\n          multi-dimensional matrices are not supported\n        </message>\n        <message name=\"MultipleRecordListNotSupported\">\n          multiple record list not supported\n        </message>\n        <message name=\"NoBitmapOnClipboard\">\n          no bitmap on clipboard\n        </message>\n        <message name=\"NoAPP1DataIsAvailable\">\n          no APP1 data is available\n        </message>\n        <message name=\"No8BIMDataIsAvailable\">\n          no 8BIM data is available\n        </message>\n        <message name=\"NoColorProfileIsAvailable\">\n          no color profile is available\n        </message>\n        <message name=\"NoDataReturned\">\n          no data returned\n        </message>\n        <message name=\"NoImageVectorGraphics\">\n          no image vector graphics; unable to generate SVG\n        </message>\n        <message name=\"NoIPTCProfileAvailable\">\n          no IPTC profile available\n        </message>\n        <message name=\"NumberOfImagesIsNotSupported\">\n          number of images is not supported\n        </message>\n        <message name=\"OnlyContinuousTonePictureSupported\">\n          only continuous tone picture supported\n        </message>\n        <message name=\"OnlyLevelZerofilesSupported\">\n          only level zero files Supported\n        </message>\n        <message name=\"PNGCompressNotSupported\">\n          PNG compression not supported\n        </message>\n        <message name=\"RLECompressNotSupported\">\n          RLE compression not supported\n        </message>\n        <message name=\"UnableToCopyProfile\">\n          unable to copy profile\n        </message>\n        <message name=\"UnableToCreateBitmap\">\n          unable to create bitmap\n        </message>\n        <message name=\"UnableToCreateADC\">\n          unable to create a DC\n        </message>\n        <message name=\"UnableToDecompressImage\">\n          unable to decompress image\n        </message>\n        <message name=\"UnableToWriteMPEGParameters\">\n          unable to write MPEG parameters\n        </message>\n        <message name=\"UnableToZipCompressImage\">\n          unable to zip-compress image\n        </message>\n        <message name=\"ZIPCompressNotSupported\">\n          ZIP compression not supported\n        </message>\n      </error>\n      <warning>\n        <message name=\"LosslessToLossyJPEGConversion\">\n          lossless to lossy JPEG conversion\n        </message>\n      </warning>\n    </coder>\n    <configure>\n      <error>\n        <message name=\"IncludeElementNestedTooDeeply\">\n          include element nested too deeply\n        </message>\n      </error>\n      <warning>\n        <message name=\"UnableToOpenConfigureFile\">\n          unable to access configure file\n        </message>\n        <message name=\"UnableToOpenModuleFile\">\n          unable to open module file\n        </message>\n      </warning>\n    </configure>\n    <corrupt>\n      <image>\n        <error>\n          <message name=\"AnErrorHasOccurredReadingFromFile\">\n            an error has occurred reading from file\n          </message>\n          <message name=\"AnErrorHasOccurredWritingToFile\">\n            an error has occurred writing to file\n          </message>\n          <message name=\"CipherSupportNotEnabled\">\n            cipher support not enabled\n          </message>\n          <message name=\"ColormapExceeds256Colors\">\n            colormap exceeded 256 colors\n          </message>\n          <message name=\"CorruptImage\">\n            corrupt image\n          </message>\n          <message name=\"FileFormatVersionMismatch\">\n            file format version mismatch\n          </message>\n          <message name=\"ImageDepthNotSupported\">\n            image depth not supported\n          </message>\n          <message name=\"ImageFileDoesNotContainAnyImageData\">\n            image file does not contain any image data\n          </message>\n          <message name=\"ImageTypeNotSupported\">\n            image type not supported\n          </message>\n          <message name=\"ImproperImageHeader\">\n            improper image header\n          </message>\n          <message name=\"InsufficientImageDataInFile\">\n            insufficient image data in file\n          </message>\n          <message name=\"InvalidColormapIndex\">\n            invalid colormap index\n          </message>\n          <message name=\"InvalidPixel\">\n            invalid pixel\n          </message>\n          <message name=\"LengthAndFilesizeDoNotMatch\">\n            length and filesize do not match\n          </message>\n          <message name=\"MaximumChannelsExceeded\">\n            maximum channels exceeded\n          </message>\n          <message name=\"MissingImageChannel\">\n            missing image channel\n          </message>\n          <message name=\"NegativeOrZeroImageSize\">\n            negative or zero image size\n          </message>\n          <message name=\"NonOS2HeaderSizeError\">\n            non OS2 BMP header size less than 40\n          </message>\n          <message name=\"NotEnoughPixelData\">\n            not enough pixel data\n          </message>\n          <message name=\"NotEnoughTiles\">\n            not enough tiles found in level\n          </message>\n          <message name=\"TooMuchImageDataInFile\">\n            too much image data in file\n          </message>\n          <message name=\"StaticPlanesValueNotEqualToOne\">\n            static planes value not equal to 1\n          </message>\n          <message name=\"UnableToReadExtensionBlock\">\n            unable to read extension block\n          </message>\n          <message name=\"UnableToReadImageHeader\">\n            unable to read image header\n          </message>\n          <message name=\"UnableToReadImageData\">\n            unable to read image data\n          </message>\n          <message name=\"UnableToRunlengthDecodeImage\">\n            unable to runlength decode image\n          </message>\n          <message name=\"UnableToUncompressImage\">\n            unable to uncompress image\n          </message>\n          <message name=\"UnexpectedEndOfFile\">\n            unexpected end-of-file\n          </message>\n          <message name=\"UnexpectedSamplingFactor\">\n            unexpected sampling factor\n          </message>\n          <message name=\"UnknownPatternType\">\n            unknown pattern type\n          </message>\n          <message name=\"UnrecognizedAlphaChannelOption\">\n            unrecognized alpha channel option\n          </message>\n          <message name=\"UnrecognizedBitsPerPixel\">\n            unrecognized bits per pixel\n          </message>\n          <message name=\"UnrecognizedImageCompression\">\n            unrecognized compression\n          </message>\n          <message name=\"UnrecognizedNumberOfColors\">\n            unrecognized number of colors\n          </message>\n        </error>\n        <fatalerror>\n          <message name=\"UnableToPersistKey\">\n            unable to persist key\n          </message>\n        </fatalerror>\n        <warning>\n          <message name=\"InsufficientImageDataInFile\">\n            insufficient image data in file\n          </message>\n          <message name=\"LengthAndFilesizeDoNotMatch\">\n            length and filesize do not match\n          </message>\n          <message name=\"SkipToSyncByte\">\n            corrupt PCD image, skipping to sync byte\n          </message>\n        </warning>\n      </image>\n    </corrupt>\n    <delegate>\n      <error>\n        <message name=\"DelegateFailed\">\n          delegate failed\n        </message>\n        <message name=\"FailedToComputeOutputSize\">\n          failed to compute output size\n        </message>\n        <message name=\"FailedToRenderFile\">\n          failed to render file\n        </message>\n        <message name=\"FailedToScanFile\">\n          failed to scan file\n        </message>\n        <message name=\"NoTagFound\">\n          no tag found\n        </message>\n        <message name=\"PCLDelegateFailed\">\n          PCL delegate failed\n        </message>\n        <message name=\"PostscriptDelegateFailed\">\n          Postscript delegate failed\n        </message>\n        <message name=\"UnableToCreateImage\">\n          unable to create image\n        </message>\n        <message name=\"UnableToDecodeImageFile\">\n          unable to decode image file\n        </message>\n        <message name=\"UnableToEncodeImageFile\">\n          unable to encode image file\n        </message>\n        <message name=\"UnableToInitializeFPXLibrary\">\n          unable to initialize FPX library\n        </message>\n        <message name=\"UnableToInitializeWMFLibrary\">\n          unable to initialize WMF library\n        </message>\n        <message name=\"UnableToManageJP2Stream\">\n          unable to manage JP2 stream\n        </message>\n        <message name=\"UnableToReadAspectRatio\">\n          unable to read aspect ratio\n        </message>\n        <message name=\"UnableToReadSummaryInfo\">\n          unable to read summary info\n        </message>\n        <message name=\"UnableToSetAffineMatrix\">\n          unable to set affine matrix\n        </message>\n        <message name=\"UnableToSetAspectRatio\">\n          unable to set aspect ratio\n        </message>\n        <message name=\"UnableToSetColorTwist\">\n          unable to set color twist\n        </message>\n        <message name=\"UnableToSetContrast\">\n          unable to set contrast\n        </message>\n        <message name=\"UnableToSetFilteringValue\">\n          unable to set filtering value\n        </message>\n        <message name=\"UnableToSetImageTitle\">\n          unable to set image title\n        </message>\n        <message name=\"UnableToSetJPEGLevel\">\n          unable to set JPEG level\n        </message>\n        <message name=\"UnableToSetRegionOfInterest\">\n          unable to set region of interest\n        </message>\n        <message name=\"UnableToSetSummaryInfo\">\n          unable to set summary info\n        </message>\n        <message name=\"UnableToWriteSVGFormat\">\n          unable to write SVG format\n        </message>\n        <message name=\"XPSDelegateFailed\">\n          XPS delegate failed\n        </message>\n      </error>\n    </delegate>\n    <draw>\n      <error>\n        <message name=\"AlreadyPushingPatternDefinition\">\n          already pushing pattern definition\n        </message>\n        <message name=\"NonconformingDrawingPrimitiveDefinition\">\n          non-conforming drawing primitive definition\n        </message>\n        <message name=\"NotARelativeURL\">\n          not a relative URL\n        </message>\n        <message name=\"NotCurrentlyPushingPatternDefinition\">\n          not currently pushing pattern definition\n        </message>\n        <message name=\"SegmentStackOverflow\">\n          segment stack overflow\n        </message>\n        <message name=\"TooManyBezierCoordinates\">\n          too many bezier coordinates\n        </message>\n        <message name=\"UnableToPrint\">\n          unable to print\n        </message>\n        <message name=\"UnbalancedGraphicContextPushPop\">\n          unbalanced graphic context push-pop\n        </message>\n        <message name=\"URLNotFound\">\n          URL not found\n        </message>\n      </error>\n    </draw>\n    <file>\n      <open>\n        <error>\n          <message name=\"AnErrorHasOccurredReadingFromFile\">\n            an error has occurred reading from file\n          </message>\n          <message name=\"UnableToCreateTemporaryFile\">\n            unable to create temporary file\n          </message>\n          <message name=\"UnableToOpenFile\">\n            unable to open file\n          </message>\n          <message name=\"UnableToWriteFile\">\n            unable to write file\n          </message>\n        </error>\n      </open>\n    </file>\n    <image>\n      <error>\n        <message name=\"AngleIsDiscontinuous\">\n          angle is discontinuous\n        </message>\n        <message name=\"ColormappedImageRequired\">\n          colormapped image required\n        </message>\n        <message name=\"ColorSeparatedImageRequired\">\n          color separated image required\n        </message>\n        <message name=\"ColorspaceColorProfileMismatch\">\n          color profile operates on another colorspace\n        </message>\n        <message name=\"ImageDepthNotSupported\">\n          image depth not supported\n        </message>\n        <message name=\"ImageMorphologyDiffers\">\n          image morphology differs\n        </message>\n        <message name=\"ImageListRequired\">\n          image list is required\n        </message>\n        <message name=\"ImageSizeDiffers\">\n          image size differs\n        </message>\n        <message name=\"ImagesTooDissimilar\">\n          images too dissimilar\n        </message>\n        <message name=\"LeftAndRightImageSizesDiffer\">\n          left and right image sizes differ\n        </message>\n        <message name=\"NegativeOrZeroImageSize\">\n          negative or zero image size\n        </message>\n        <message name=\"NoImagesWereFound\">\n          no images were found\n        </message>\n        <message name=\"NoImagesWereLoaded\">\n          no images were loaded\n        </message>\n        <message name=\"TooManyClusters\">\n          too many cluster\n        </message>\n        <message name=\"UnableToCreateColorTransform\">\n          unable to create color transform\n        </message>\n        <message name=\"WidthOrHeightExceedsLimit\">\n          width or height exceeds limit\n        </message>\n      </error>\n      <warning>\n        <message name=\"AssociateProfile\">\n          associate profile with image, a source and destination color profile required for transform\n        </message>\n      </warning>\n    </image>\n    <filter>\n      <error>\n        <message name=\"FilterFailed\">\n          filter failed\n        </message>\n      </error>\n    </filter>\n    <missing>\n      <delegate>\n        <error>\n          <message name=\"DelegateLibrarySupportNotBuiltIn\">\n            delegate library support not built-in\n          </message>\n          <message name=\"NoDecodeDelegateForThisImageFormat\">\n            no decode delegate for this image format\n          </message>\n          <message name=\"NoEncodeDelegateForThisImageFormat\">\n            no encode delegate for this image format\n          </message>\n        </error>\n        <warning>\n          <message name=\"DelegateLibrarySupportNotBuiltIn\">\n            delegate library support not built-in\n          </message>\n          <message name=\"FreeTypeLibraryIsNotAvailable\">\n            FreeType library is not available\n          </message>\n          <message name=\"LCMSLibraryIsNotAvailable\">\n            LCMS color profile library is not available\n          </message>\n          <message name=\"NoEncodeDelegateForThisImageFormat\">\n            no encode delegate for this image format\n          </message>\n        </warning>\n      </delegate>\n    </missing>\n    <module>\n      <error>\n        <message name=\"ImageCoderSignatureMismatch\">\n          image coder signature mismatch\n        </message>\n        <message name=\"ImageFilterSignatureMismatch\">\n          image filter signature mismatch\n        </message>\n        <message name=\"UnableToLoadModule\">\n          unable to load module\n        </message>\n        <message name=\"UnableToRegisterImageFormat\">\n          unable to register image format\n        </message>\n      </error>\n      <fatalerror>\n        <message name=\"UnableToInitializeModuleLoader\">\n          unable to initialize module loader\n        </message>\n      </fatalerror>\n      <warning>\n        <message name=\"UnableToCloseModule\">\n          unable to close module\n        </message>\n      </warning>\n    </module>\n    <option>\n      <error>\n        <message name=\"ClutImageRequired\">\n          color lookup table image required\n        </message>\n        <message name=\"CompositeImageRequired\">\n          composite image required\n        </message>\n        <message name=\"CurlyBrasesNestedTooDeeply\">\n          curly braces nested too deeply\n        </message>\n        <message name=\"DeprecatedOptionNoCode\">\n          option deprecated, unable to execute\n        </message>\n        <message name=\"DivideByZero\">\n          divide by zero\n        </message>\n        <message name=\"FrameIsLessThanImageSize\">\n          frame is less than image size\n        </message>\n        <message name=\"GeometryDimensionsAreZero\">\n          geometry dimensions are zero\n        </message>\n        <message name=\"GeometryDoesNotContainImage\">\n          geometry does not contain image\n        </message>\n        <message name=\"InterpretPropertyFailure\">\n          failure to interpret image property escapes\n        </message>\n        <message name=\"InvalidArgument\">\n          invalid argument for option\n        </message>\n        <message name=\"InvalidUseOfOption\">\n          invalid use of option\n        </message>\n        <message name=\"InvalidGeometry\">\n          invalid geometry\n        </message>\n        <message name=\"InvalidImageIndex\">\n          invalid image index\n        </message>\n        <message name=\"InvalidNumberList\">\n          invalid list of numbers\n        </message>\n        <message name=\"InvalidSetting\">\n          invalid setting\n        </message>\n        <message name=\"ImagesAreNotTheSameSize\">\n          images are not the same size\n        </message>\n        <message name=\"ImageSizeMustExceedBevelWidth\">\n          size must exceed bevel width\n        </message>\n        <message name=\"ImageWidthsOrHeightsDiffer\">\n          image widths or heights differ\n        </message>\n        <message name=\"KernelWidthMustBeAnOddNumber\">\n          kernel width must be an odd number\n        </message>\n        <message name=\"MapImageRequired\">\n          map image required\n        </message>\n        <message name=\"MissingArgument\">\n          missing required argument\n        </message>\n        <message name=\"MissingAnImageFilename\">\n        <!-- FUTURE: Depreciate using MissingOutputFilename -->\n          missing an image filename\n        </message>\n        <message name=\"MissingExpression\">\n          missing expression\n        </message>\n        <message name=\"MissingNullSeparator\">\n          missing Null Image List Separator\n        </message>\n        <message name=\"MissingOutputFilename\">\n          missing output filename\n        </message>\n        <message name=\"MustSpecifyAnImageName\">\n          must specify an image name\n        </message>\n        <message name=\"MustSpecifyImageSize\">\n          must specify image size\n        </message>\n        <message name=\"NoBlobDefined\">\n          no Binary Large OBjects defined\n        </message>\n        <message name=\"NoClipPathDefined\">\n          no clip path defined\n        </message>\n        <message name=\"NoImagesForWrite\">\n          no images for write\n        </message>\n        <message name=\"NoImagesFound\">\n          no images found for operation\n        </message>\n        <message name=\"NoImagesDefined\">\n          no images defined\n        </message>\n        <message name=\"NoImageVectorGraphics\">\n          no image vector graphics\n        </message>\n        <message name=\"NoSuchImage\">\n          no such image\n        </message>\n        <message name=\"NoSuchImageChannel\">\n          no such image channel\n        </message>\n        <message name=\"NoSuchOption\">\n          no such option\n        </message>\n        <message name=\"NonZeroWidthAndHeightRequired\">\n          non-zero width and height required\n        </message>\n        <message name=\"NotEnoughParameters\">\n          not enough parameters\n        </message>\n        <message name=\"ParenthesisNestedTooDeeply\">\n          parenthesis nested too deeply\n        </message>\n        <message name=\"ReferenceImageRequired\">\n          reference image required\n        </message>\n        <message name=\"ReferenceIsNotMyType\">\n          reference is not my type\n        </message>\n        <message name=\"SetReadOnlyProperty\">\n          attempt to set read-only property\n        </message>\n        <message name=\"SteganoImageRequired\">\n          stegano image required\n        </message>\n        <message name=\"StereoImageRequired\">\n          stereo image required\n        </message>\n        <message name=\"SubimageSpecificationReturnsNoImages\">\n          subimage specification returns no images\n        </message>\n        <message name=\"TwoOrMoreImagesRequired\">\n          two or more images required\n        </message>\n        <message name=\"UnableToAccessPath\">\n          unable to access file path\n        </message>\n        <message name=\"UnableToOpenFile\">\n          unable to open file\n        </message>\n        <message name=\"UnableToParseExpression\">\n          unable to parse expression\n        </message>\n        <message name=\"UnableToParseKernel\">\n          unable to parse kernel string\n        </message>\n        <message name=\"UnbalancedBraces\">\n          unbalanced braces\n        </message>\n        <message name=\"UnbalancedParenthesis\">\n          unbalanced parenthesis\n        </message>\n        <message name=\"UnrecognizedAttribute\">\n          unrecognized attribute\n        </message>\n        <message name=\"UnrecognizedChannelType\">\n          unrecognized channel type\n        </message>\n        <message name=\"UnrecognizedColor\">\n          unrecognized color\n        </message>\n        <message name=\"UnrecognizedColorspace\">\n          unrecognized colorspace\n        </message>\n        <message name=\"UnrecognizedComposeOperator\">\n          unrecognized compose operator\n        </message>\n        <message name=\"UnrecognizedCompressType\">\n          unrecognized compress type\n        </message>\n        <message name=\"UnrecognizedDirectionType\">\n          unrecognized direction type\n        </message>\n        <message name=\"UnrecognizedDisposeMethod\">\n          unrecognized dispose method\n        </message>\n        <message name=\"UnrecognizedDistortMethod\">\n          unrecognized distortion method\n        </message>\n        <message name=\"UnrecognizedDitherMethod\">\n          unrecognized dither method\n        </message>\n        <message name=\"UnrecognizedEndianType\">\n          unrecognized endian type\n        </message>\n        <message name=\"UnrecognizedElement\">\n          unrecognized element\n        </message>\n        <message name=\"UnrecognizedEvaluateOperator\">\n          unrecognized evaluate operator\n        </message>\n        <message name=\"UnrecognizedEventType\">\n          unrecognized event type\n        </message>\n        <message name=\"UnrecognizedFunction\">\n          unrecognized function\n        </message>\n        <message name=\"UnrecognizedGravityType\">\n          unrecognized gravity type\n        </message>\n        <message name=\"UnrecognizedImageCompression\">\n          unrecognized image compression\n        </message>\n        <message name=\"UnrecognizedImageFilter\">\n          unrecognized image filter\n        </message>\n        <message name=\"UnrecognizedImageFormat\">\n          unrecognized image format\n        </message>\n        <message name=\"UnrecognizedImageMode\">\n          unrecognized image mode\n        </message>\n        <message name=\"UnrecognizedImageOrientation\">\n          unrecognized image orientation\n        </message>\n        <message name=\"UnrecognizedImageType\">\n          unrecognized image type\n        </message>\n        <message name=\"UnrecognizedIntentType\">\n          unrecognized intent type\n        </message>\n        <message name=\"UnrecognizedInterlaceType\">\n          unrecognized interlace type\n        </message>\n        <message name=\"UnrecognizedInterpolateMethod\">\n          unrecognized interpolate method\n        </message>\n        <message name=\"UnrecognizedKernelType\">\n          unrecognized kernel type\n        </message>\n        <message name=\"UnrecognizedListType\">\n          unrecognized list type\n        </message>\n        <message name=\"UnrecognizedMetricType\">\n          unrecognized metric type\n        </message>\n        <message name=\"UnrecognizedModeType\">\n          unrecognized mode type\n        </message>\n        <message name=\"UnrecognizedMorphologyMethod\">\n          unrecognized morphology method\n        </message>\n        <message name=\"UnrecognizedOption\">\n          unrecognized option\n        </message>\n        <message name=\"UnrecognizedPerlMagickMethod\">\n          unrecognized PerlMagick method\n        </message>\n        <message name=\"UnrecognizedPixelMap\">\n          unrecognized pixel map\n        </message>\n        <message name=\"UnrecognizedPreviewType\">\n          unrecognized preview type\n        </message>\n        <message name=\"UnrecognizedResourceType\">\n          unrecognized resource type\n        </message>\n        <message name=\"UnrecognizedSparseColorMethod\">\n          unrecognized sparse color method\n        </message>\n        <message name=\"UnrecognizedStorageType\">\n          unrecognized storage type\n        </message>\n        <message name=\"UnrecognizedStretchType\">\n          unrecognized stretch type\n        </message>\n        <message name=\"UnrecognizedStyleType\">\n          unrecognized style type\n        </message>\n        <message name=\"UnrecognizedType\">\n          unrecognized type\n        </message>\n        <message name=\"UnrecognizedUnitsType\">\n          unrecognized units type\n        </message>\n        <message name=\"UnrecognizedValidateType\">\n          unrecognized validate type\n        </message>\n        <message name=\"UnrecognizedVirtualPixelMethod\">\n          unrecognized virtual pixel method\n        </message>\n        <message name=\"XmlInvalidAttribute\">\n          XML invalid attribute\n        </message>\n        <message name=\"XmlInvalidContent\">\n          XML invalid content\n        </message>\n        <message name=\"XmlMissingAttribute\">\n          XML missing required attribute\n        </message>\n        <message name=\"XmlMissingContent\">\n          XML missing required content\n        </message>\n        <message name=\"XmlMissingElement\">\n          XML missing required element\n        </message>\n      </error>\n      <fatalerror>\n        <message name=\"FilenameTruncated\">\n          image filename truncated\n        </message>\n        <message name=\"MissingAnImageFilename\">\n          missing an image filename\n        </message>\n        <message name=\"ScriptIsBinary\">\n          script is binary\n        </message>\n        <message name=\"ScriptTokenMemoryFailed\">\n          script token too big\n        </message>\n        <message name=\"ScriptUnbalancedQuotes\">\n          script token with unbalanced quotes\n        </message>\n        <message name=\"UnableToOpenScript\">\n          unable to open script\n        </message>\n        <message name=\"UnrecognizedColormapType\">\n          unrecognized colormap type\n        </message>\n        <message name=\"UnrecognizedColorspaceType\">\n          unrecognized colorspace type\n        </message>\n        <message name=\"UnrecognizedEndianType\">\n          unrecognized endian type\n        </message>\n        <message name=\"UnrecognizedImageCompressionType\">\n          unrecognized compression type\n        </message>\n        <message name=\"UnrecognizedImageType\">\n          unrecognized image type\n        </message>\n        <message name=\"UnrecognizedInterlaceType\">\n          unrecognized interlace type\n        </message>\n        <message name=\"UnrecognizedListType\">\n          unrecognized list type\n        </message>\n        <message name=\"UnrecognizedDisposeMethod\">\n          unrecognized dispose method\n        </message>\n        <message name=\"UnrecognizedOption\">\n          unrecognized option\n        </message>\n        <message name=\"UnrecognizedResourceType\">\n          unrecognized resource type\n        </message>\n        <message name=\"UnrecognizedVirtualPixelMethod\">\n          unrecognized virtual pixel method\n        </message>\n      </fatalerror>\n      <warning>\n        <message name=\"ReplacedOption\">\n          option has been replaced\n        </message>\n        <message name=\"GeometryDoesNotContainImage\">\n          geometry does not contain image\n        </message>\n        <message name=\"InterpretPropertyFailure\">\n          failure in interpret image property escapes\n        </message>\n        <message name=\"InvalidSetting\">\n          invalid setting\n        </message>\n        <message name=\"NoImageForProperty\">\n          no image to apply a property\n        </message>\n        <message name=\"NoImageInfoForProperty\">\n          no image info (wand) to apply a property\n        </message>\n        <message name=\"NoSuchElement\">\n          no such element in list\n        </message>\n        <message name=\"UnknownImageProperty\">\n          unknown image property\n        </message>\n        <message name=\"UnrecognizedColor\">\n          unrecognized color\n        </message>\n        <message name=\"ZeroTimeAnimation\">\n          animation only contains zero time delays\n        </message>\n      </warning>\n    </option>\n    <policy>\n      <error>\n        <message name=\"NotAuthorized\">\n          not authorized\n        </message>\n      </error>\n    </policy>\n    <registry>\n      <error>\n        <message name=\"UnableToGetRegistryID\">\n          unable to get registry ID\n        </message>\n        <message name=\"UnableToSetRegistry\">\n          unable to set registry\n        </message>\n      </error>\n    </registry>\n    <resource>\n      <limit>\n        <error>\n          <message name=\"PixelCacheAllocationFailed\">\n            pixel cache allocation failed\n          </message>\n          <message name=\"MemoryAllocationFailed\">\n            memory allocation failed\n          </message>\n          <message name=\"TooManyObjects\">\n            too many objects\n          </message>\n          <message name=\"UnableToAcquireString\">\n            unable to acquire string\n          </message>\n          <message name=\"UnableToAllocateColormap\">\n            unable to allocate colormap\n          </message>\n          <message name=\"UnableToConvertFont\">\n            unable to convert font\n          </message>\n          <message name=\"UnableToCreateColormap\">\n            unable to create colormap\n          </message>\n          <message name=\"UnableToDitherImage\">\n            unable to dither image\n          </message>\n          <message name=\"UnableToClonePackageInfo\">\n            unable to clone package info\n          </message>\n          <message name=\"UnableToGetPackageInfo\">\n            unable to get package info\n          </message>\n        </error>\n        <fatalerror>\n          <message name=\"TimeLimitExceeded\">\n            time limit exceeded\n          </message>\n          <message name=\"UnableToAllocateDashPattern\">\n            unable to allocate dash pattern\n          </message>\n          <message name=\"UnableToAllocateDerivatives\">\n            unable to allocate derivates\n          </message>\n          <message name=\"UnableToAllocateGammaMap\">\n            unable to allocate gamma map\n          </message>\n          <message name=\"UnableToAllocateImage\">\n            unable to allocate image\n          </message>\n          <message name=\"UnableToAllocateImagePixels\">\n            unable to allocate image pixels\n          </message>\n          <message name=\"UnableToDestroySemaphore\">\n            unable to destroy semaphore\n          </message>\n          <message name=\"UnableToInstantiateSemaphore\">\n            unable to instantiate semaphore\n          </message>\n          <message name=\"UnableToAcquireString\">\n            unable to allocate string\n          </message>\n          <message name=\"MemoryAllocationFailed\">\n            Memory allocation failed\n          </message>\n          <message name=\"UnableToConcatenateString\">\n            unable to concatenate string\n          </message>\n          <message name=\"UnableToConvertText\">\n            unable to convert text\n          </message>\n          <message name=\"UnableToCreateColormap\">\n            unable to create colormap\n          </message>\n          <message name=\"UnableToCloneImage\">\n            unable to clone image\n          </message>\n          <message name=\"UnableToDisplayImage\">\n            unable to display image\n          </message>\n          <message name=\"UnableToEscapeString\">\n            unable to escape string\n          </message>\n          <message name=\"UnableToInterpretMSLImage\">\n            unable to interpret MSL image\n          </message>\n          <message name=\"UnableToLockSemaphore\">\n            unable to lock semaphore\n          </message>\n          <message name=\"UnableToUnlockSemaphore\">\n            unable to unlock semaphore\n          </message>\n        </fatalerror>\n        <warning>\n          <message name=\"MemoryAllocationFailed\">\n            memory allocation failed\n          </message>\n        </warning>\n      </limit>\n    </resource>\n    <type>\n      <error>\n        <message name=\"FontSubstitutionRequired\">\n          font substitution required\n        </message>\n        <message name=\"UnableToGetTypeMetrics\">\n          unable to get type metrics\n        </message>\n        <message name=\"UnableToInitializeFreetypeLibrary\">\n          unable to initialize freetype library\n        </message>\n        <message name=\"UnableToReadFont\">\n          unable to read font\n        </message>\n        <message name=\"UnrecognizedFontEncoding\">\n          unrecognized font encoding\n        </message>\n      </error>\n      <warning>\n        <message name=\"UnableToReadFont\">\n          unable to read font\n        </message>\n      </warning>\n    </type>\n    <stream>\n      <error>\n        <message name=\"ImageDoesNotContainTheStreamGeometry\">\n          image does not contain the stream geometry\n        </message>\n        <message name=\"NoStreamHandlerIsDefined\">\n          no stream handler is defined\n        </message>\n        <message name=\"PixelCacheIsNotOpen\">\n          pixel cache is not open\n        </message>\n      </error>\n    </stream>\n    <wand>\n      <error>\n        <message name=\"InvalidColormapIndex\">\n          invalid colormap index\n        </message>\n        <message name=\"ZeroRegionSize\">\n          zero region size\n        </message>\n        <message name=\"UnableToOpenFile\">\n          unable to open file\n        </message>\n        <message name=\"QuantumDepthMismatch\">\n          wand quantum depth does not match that of the core API\n        </message>\n        <message name=\"ContainsNoImages\">\n          wand contains no images\n        </message>\n        <message name=\"ContainsNoIterators\">\n          wand contains no iterators\n        </message>\n      </error>\n    </wand>\n    <xserver>\n      <error>\n        <message name=\"ColorIsNotKnownToServer\">\n          color is not known to server\n        </message>\n        <message name=\"NoWindowWithSpecifiedIDExists\">\n          no window with specified ID exists\n        </message>\n        <message name=\"StandardColormapIsNotInitialized\">\n          standard Colormap is not initialized\n        </message>\n        <message name=\"UnableToConnectToRemoteDisplay\">\n          unable to connect to remote display\n        </message>\n        <message name=\"UnableToCreateBitmap\">\n          unable to create bitmap\n        </message>\n        <message name=\"UnableToCreateColormap\">\n          unable to create colormap\n        </message>\n        <message name=\"UnableToCreatePixmap\">\n          unable to create pixmap\n        </message>\n        <message name=\"UnableToCreateProperty\">\n          unable to create property\n        </message>\n        <message name=\"UnableToCreateStandardColormap\">\n          unable to create standard colormap\n        </message>\n        <message name=\"UnableToDisplayImageInfo\">\n          unable to display image info\n        </message>\n        <message name=\"UnableToGetProperty\">\n          unable to get property\n        </message>\n        <message name=\"UnableToGetStandardColormap\">\n          unable to get Standard Colormap\n        </message>\n        <message name=\"UnableToGetVisual\">\n          unable to get visual\n        </message>\n        <message name=\"UnableToGrabMouse\">\n          unable to grab mouse\n        </message>\n        <message name=\"UnableToLoadFont\">\n          unable to load font\n        </message>\n        <message name=\"UnableToMatchVisualToStandardColormap\">\n          unable to match visual to Standard Colormap\n        </message>\n        <message name=\"UnableToOpenXServer\">\n          unable to open X server\n        </message>\n        <message name=\"UnableToReadXWindowAttributes\">\n          unable to read X window attributes\n        </message>\n        <message name=\"UnableToReadXWindowImage\">\n          unable to read X window image\n        </message>\n        <message name=\"UnrecognizedColormapType\">\n          unrecognized colormap type\n        </message>\n        <message name=\"UnrecognizedGravityType\">\n          unrecognized gravity type\n        </message>\n        <message name=\"UnrecognizedVisualSpecifier\">\n          unrecognized visual specifier\n        </message>\n      </error>\n      <fatalerror>\n        <message name=\"UnableToCreateCursor\">\n          unable to create X cursor\n        </message>\n        <message name=\"UnableToCreateGraphicContext\">\n          unable to create graphic context\n        </message>\n        <message name=\"UnableToCreateStandardColormap\">\n          unable to create standard colormap\n        </message>\n        <message name=\"UnableToCreateTextProperty\">\n          unable to create text property\n        </message>\n        <message name=\"UnableToCreateXWindow\">\n          unable to create X window\n        </message>\n        <message name=\"UnableToCreateXImage\">\n          unable to create X image\n        </message>\n        <message name=\"UnableToCreateXPixmap\">\n          unable to create X pixmap\n        </message>\n        <message name=\"UnableToDisplayImage\">\n          unable to display image\n        </message>\n        <message name=\"UnableToGetVisual\">\n          unable to get visual\n        </message>\n        <message name=\"UnableToGetPixelInfo\">\n          unable to get pixel info\n        </message>\n        <message name=\"UnableToLoadFont\">\n          unable to load font\n        </message>\n        <message name=\"UnableToMakeXWindow\">\n          unable to make X window\n        </message>\n        <message name=\"UnableToOpenXServer\">\n          unable to open X server\n        </message>\n        <message name=\"UnableToViewFonts\">\n          unable to view fonts\n        </message>\n      </fatalerror>\n      <warning>\n        <message name=\"UsingDefaultVisual\">\n          using default visual\n        </message>\n        <message name=\"UnableToGetVisual\">\n          unable to get visual\n        </message>\n      </warning>\n    </xserver>\n  </exception>\n  <monitor>\n    <AddNoise>\n      <message name=\"Image\">\n        add noise to image\n      </message>\n    </AddNoise>\n    <Append>\n      <message name=\"Image\">\n        append image sequence\n      </message>\n    </Append>\n    <assign>\n      <message name=\"Image\">\n        assign image colors\n      </message>\n    </assign>\n    <Average>\n      <message name=\"Image\">\n        average image sequence\n      </message>\n    </Average>\n    <Chop>\n      <message name=\"Image\">\n        chop image\n      </message>\n    </Chop>\n    <Classify>\n      <message name=\"Image\">\n        classify image colors\n      </message>\n    </Classify>\n    <ColorReplace>\n      <message name=\"Image\">\n        replace color in image\n      </message>\n    </ColorReplace>\n    <Colorize>\n      <message name=\"Image\">\n        colorize image\n      </message>\n    </Colorize>\n    <Combine>\n      <message name=\"Image\">\n        combine image\n      </message>\n    </Combine>\n    <ContrastStretch>\n      <message name=\"Image\">\n         contrast-stretch image\n      </message>\n    </ContrastStretch>\n    <Convolve>\n      <message name=\"Image\">\n        convolve image\n      </message>\n    </Convolve>\n    <Crop>\n      <message name=\"Image\">\n        crop image\n      </message>\n    </Crop>\n    <Decode>\n      <message name=\"Image\">\n        decode image\n      </message>\n    </Decode>\n    <Despeckle>\n      <message name=\"Image\">\n        despeckle image\n      </message>\n    </Despeckle>\n    <Distort>\n      <message name=\"Image\">\n        distort image\n      </message>\n    </Distort>\n    <Dither>\n      <message name=\"Image\">\n        dither image colors\n      </message>\n    </Dither>\n    <DullContrast>\n      <message name=\"Image\">\n        dull image contrast\n      </message>\n    </DullContrast>\n    <Encode>\n      <message name=\"Image\">\n        encode image\n      </message>\n    </Encode>\n    <Equalize>\n      <message name=\"Image\">\n        equalize image\n      </message>\n    </Equalize>\n    <Flip>\n      <message name=\"Image\">\n        flip image\n      </message>\n    </Flip>\n    <Flop>\n      <message name=\"Image\">\n        flop image\n      </message>\n    </Flop>\n    <Frame>\n      <message name=\"Image\">\n        add frame to image\n      </message>\n    </Frame>\n    <Fx>\n      <message name=\"Image\">\n        fx image\n      </message>\n    </Fx>\n    <GammaCorrect>\n      <message name=\"Image\">\n        gamma correct image\n      </message>\n    </GammaCorrect>\n    <Histogram>\n      <message name=\"Image\">\n        compute image histogram\n      </message>\n    </Histogram>\n    <Implode>\n      <message name=\"Image\">\n        implode image\n      </message>\n    </Implode>\n    <Level>\n      <message name=\"Image\">\n        level image\n      </message>\n    </Level>\n    <Load>\n      <message name=\"Image\">\n        load image\n      </message>\n      <message name=\"Images\">\n        load images\n      </message>\n    </Load>\n    <Magnfiy>\n      <message name=\"Image\">\n        magnfiy image\n      </message>\n    </Magnfiy>\n    <MedianFilter>\n      <message name=\"Image\">\n        filter image with neighborhood ranking\n      </message>\n    </MedianFilter>\n    <Minify>\n      <message name=\"Image\">\n        minify image\n      </message>\n    </Minify>\n    <Modulate>\n      <message name=\"Image\">\n        modulate image\n      </message>\n    </Modulate>\n    <Mogrify>\n      <message name=\"Image\">\n        mogrify image\n      </message>\n    </Mogrify>\n    <Montage>\n      <message name=\"Image\">\n        montage image\n      </message>\n    </Montage>\n    <Morph>\n      <message name=\"Image\">\n        morph image sequence\n      </message>\n    </Morph>\n    <Mosaic>\n      <message name=\"Image\">\n        mosaic image\n      </message>\n    </Mosaic>\n    <Negate>\n      <message name=\"Image\">\n        negate image\n      </message>\n    </Negate>\n    <OilPaint>\n      <message name=\"Image\">\n        oil paint image\n      </message>\n    </OilPaint>\n    <Opaque>\n      <message name=\"Image\">\n        set opaque color in image\n      </message>\n    </Opaque>\n    <Plasma>\n      <message name=\"Image\">\n        plasma image\n      </message>\n    </Plasma>\n    <Preview>\n      <message name=\"Image\">\n        preview image\n      </message>\n    </Preview>\n    <Raise>\n      <message name=\"Image\">\n        raise image\n      </message>\n    </Raise>\n    <Recolor>\n      <message name=\"Image\">\n        recolor color image\n      </message>\n    </Recolor>\n    <Reduce>\n      <message name=\"Image\">\n        reduce image colors\n      </message>\n    </Reduce>\n    <ReduceNoise>\n      <message name=\"Image\">\n        reduce the image noise\n      </message>\n    </ReduceNoise>\n    <Render>\n      <message name=\"Image\">\n        render image\n      </message>\n    </Render>\n    <Resize>\n      <message name=\"Image\">\n        resize image\n      </message>\n    </Resize>\n    <RGBTransform>\n      <message name=\"Image\">\n        RGB transform image\n      </message>\n    </RGBTransform>\n    <Roll>\n      <message name=\"Image\">\n        roll image\n      </message>\n    </Roll>\n    <Rotate>\n      <message name=\"Image\">\n        rotate image\n      </message>\n    </Rotate>\n    <Sample>\n      <message name=\"Image\">\n        sample image\n      </message>\n    </Sample>\n    <Save>\n      <message name=\"Image\">\n        save image\n      </message>\n      <message name=\"Images\">\n        save images\n      </message>\n    </Save>\n    <Scale>\n      <message name=\"Image\">\n        scale image\n      </message>\n    </Scale>\n    <Segment>\n      <message name=\"Image\">\n        segment image\n      </message>\n    </Segment>\n    <Separate>\n      <message name=\"Image\">\n        extract a channel from image\n      </message>\n    </Separate>\n    <SepiaTone>\n      <message name=\"Image\">\n        sepia-tone image\n      </message>\n    </SepiaTone>\n    <Shade>\n      <message name=\"Image\">\n        shade image\n      </message>\n    </Shade>\n    <Sharpen>\n      <message name=\"Image\">\n        sharpen image\n      </message>\n    </Sharpen>\n    <SharpenContrast>\n      <message name=\"Image\">\n        sharpen image contrast\n      </message>\n    </SharpenContrast>\n    <SigmoidalContrast>\n      <message name=\"Image\">\n        sigmoidal contrast image\n      </message>\n    </SigmoidalContrast>\n    <Solarize>\n      <message name=\"Image\">\n        solarize image\n      </message>\n    </Solarize>\n    <Splice>\n      <message name=\"Image\">\n        splice image\n      </message>\n    </Splice>\n    <Spread>\n      <message name=\"Image\">\n        spread image\n      </message>\n    </Spread>\n    <Stegano>\n      <message name=\"Image\">\n        stegano image\n      </message>\n    </Stegano>\n    <Stereo>\n      <message name=\"Image\">\n        stereo image\n      </message>\n    </Stereo>\n    <Swirl>\n      <message name=\"Image\">\n        swirl image\n      </message>\n    </Swirl>\n    <Texture>\n      <message name=\"Image\">\n        texture image\n      </message>\n    </Texture>\n    <Threshold>\n      <message name=\"Image\">\n        threshold image\n      </message>\n    </Threshold>\n    <Tile>\n      <message name=\"Image\">\n        tile image\n      </message>\n    </Tile>\n    <Tint>\n      <message name=\"Image\">\n        tint image\n      </message>\n    </Tint>\n    <TransformRGB>\n      <message name=\"Image\">\n        transform RGB image\n      </message>\n    </TransformRGB>\n    <Transparent>\n      <message name=\"Image\">\n        set transparent color in image\n      </message>\n    </Transparent>\n    <Wave>\n      <message name=\"Image\">\n        wave image\n      </message>\n    </Wave>\n    <Write>\n      <message name=\"Image\">\n        write image\n      </message>\n    </Write>\n    <XShear>\n      <message name=\"Image\">\n        x shear image\n      </message>\n    </XShear>\n    <YShear>\n      <message name=\"Image\">\n        y shear image\n      </message>\n    </YShear>\n  </monitor>\n</locale>\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        JJJJJ  PPPP   EEEEE   GGGG                           %\n%                          J    P   P  E      G                               %\n%                          J    PPPP   EEE    G  GG                           %\n%                        J J    P      E      G   G                           %\n%                        JJJ    P      EEEEE   GGG                            %\n%                                                                             %\n%                                                                             %\n%                       Read/Write JPEG Image Format                          %\n%                                                                             %\n%                              Software Design                                %\n%                                John Cristy                                  %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2013 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% This software is based in part on the work of the Independent JPEG Group.\n% See ftp://ftp.uu.net/graphics/jpeg/jpegsrc.v6b.tar.gz for copyright and\n% licensing restrictions.  Blob support contributed by Glenn Randers-Pehrson.\n%\n%\n*/\n\n\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/option-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/xml-tree.h\"\n#include \"MagickCore/xml-tree-private.h\"\n#include <setjmp.h>\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n#define JPEG_INTERNAL_OPTIONS\n#if defined(__MINGW32__) || defined(__MINGW64__)\n# define XMD_H 1  /* Avoid conflicting typedef for INT32 */\n#endif\n#undef HAVE_STDLIB_H\n#include \"jpeglib.h\"\n#include \"jerror.h\"\n#endif\n\f\n/*\n  Define declarations.\n*/\n#define ICC_MARKER  (JPEG_APP0+2)\n#define ICC_PROFILE  \"ICC_PROFILE\"\n#define IPTC_MARKER  (JPEG_APP0+13)\n#define XML_MARKER  (JPEG_APP0+1)\n#define MaxBufferExtent  16384\n\f\n/*\n  Typedef declarations.\n*/\n#if defined(MAGICKCORE_JPEG_DELEGATE)\ntypedef struct _DestinationManager\n{\n  struct jpeg_destination_mgr\n    manager;\n\n  Image\n    *image;\n\n  JOCTET\n    *buffer;\n} DestinationManager;\n\ntypedef struct _ErrorManager\n{\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    finished;\n\n  StringInfo\n    *profile;\n\n  jmp_buf\n    error_recovery;\n} ErrorManager;\n\ntypedef struct _SourceManager\n{\n  struct jpeg_source_mgr\n    manager;\n\n  Image\n    *image;\n\n  JOCTET\n    *buffer;\n\n  boolean\n    start_of_blob;\n} SourceManager;\n#endif\n\ntypedef struct _QuantizationTable\n{\n  char\n    *slot,\n    *description;\n\n  size_t\n    width,\n    height;\n\n  double\n    divisor;\n\n  unsigned int\n    *levels;\n} QuantizationTable;\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_JPEG_DELEGATE)\nstatic MagickBooleanType\n  WriteJPEGImage(const ImageInfo *,Image *,ExceptionInfo *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s J P E G                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsJPEG() returns MagickTrue if the image format type, identified by the\n%  magick string, is JPEG.\n%\n%  The format of the IsJPEG  method is:\n%\n%      MagickBooleanType IsJPEG(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsJPEG(const unsigned char *magick,const size_t length)\n{\n  if (length < 3)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\377\\330\\377\",3) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d J P E G I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadJPEGImage() reads a JPEG image file and returns it.  It allocates\n%  the memory necessary for the new Image structure and returns a pointer to\n%  the new image.\n%\n%  The format of the ReadJPEGImage method is:\n%\n%      Image *ReadJPEGImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic boolean FillInputBuffer(j_decompress_ptr cinfo)\n{\n  SourceManager\n    *source;\n\n  source=(SourceManager *) cinfo->src;\n  source->manager.bytes_in_buffer=(size_t) ReadBlob(source->image,\n    MaxBufferExtent,source->buffer);\n  if (source->manager.bytes_in_buffer == 0)\n    {\n      if (source->start_of_blob != FALSE)\n        ERREXIT(cinfo,JERR_INPUT_EMPTY);\n      WARNMS(cinfo,JWRN_JPEG_EOF);\n      source->buffer[0]=(JOCTET) 0xff;\n      source->buffer[1]=(JOCTET) JPEG_EOI;\n      source->manager.bytes_in_buffer=2;\n    }\n  source->manager.next_input_byte=source->buffer;\n  source->start_of_blob=FALSE;\n  return(TRUE);\n}\n\nstatic int GetCharacter(j_decompress_ptr jpeg_info)\n{\n  if (jpeg_info->src->bytes_in_buffer == 0)\n    (void) (*jpeg_info->src->fill_input_buffer)(jpeg_info);\n  jpeg_info->src->bytes_in_buffer--;\n  return((int) GETJOCTET(*jpeg_info->src->next_input_byte++));\n}\n\nstatic void InitializeSource(j_decompress_ptr cinfo)\n{\n  SourceManager\n    *source;\n\n  source=(SourceManager *) cinfo->src;\n  source->start_of_blob=TRUE;\n}\n\nstatic MagickBooleanType IsITUFaxImage(const Image *image)\n{\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *datum;\n\n  profile=GetImageProfile(image,\"8bim\");\n  if (profile == (const StringInfo *) NULL)\n    return(MagickFalse);\n  if (GetStringInfoLength(profile) < 5)\n    return(MagickFalse);\n  datum=GetStringInfoDatum(profile);\n  if ((datum[0] == 0x47) && (datum[1] == 0x33) && (datum[2] == 0x46) &&\n      (datum[3] == 0x41) && (datum[4] == 0x58))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic void JPEGErrorHandler(j_common_ptr jpeg_info)\n{\n  char\n    message[JMSG_LENGTH_MAX];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  *message='\\0';\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n  exception=error_manager->exception;\n  (jpeg_info->err->format_message)(jpeg_info,message);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"[%s] JPEG Trace: \\\"%s\\\"\",image->filename,message);\n  if (error_manager->finished != MagickFalse)\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageWarning,\n      (char *) message,\"`%s'\",image->filename);\n  else\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n      (char *) message,\"`%s'\",image->filename);\n  longjmp(error_manager->error_recovery,1);\n}\n\nstatic MagickBooleanType JPEGWarningHandler(j_common_ptr jpeg_info,int level)\n{\n#define JPEGExcessiveWarnings  1000\n\n  char\n    message[JMSG_LENGTH_MAX];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  *message='\\0';\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  if (level < 0)\n    {\n      /*\n        Process warning message.\n      */\n      (jpeg_info->err->format_message)(jpeg_info,message);\n      if (jpeg_info->err->num_warnings++ > JPEGExcessiveWarnings)\n        JPEGErrorHandler(jpeg_info);\n      ThrowBinaryException(CorruptImageWarning,(char *) message,\n        image->filename);\n    }\n  else\n    if ((image->debug != MagickFalse) &&\n        (level >= jpeg_info->err->trace_level))\n      {\n        /*\n          Process trace message.\n        */\n        (jpeg_info->err->format_message)(jpeg_info,message);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"[%s] JPEG Trace: \\\"%s\\\"\",image->filename,message);\n      }\n  return(MagickTrue);\n}\n\nstatic boolean ReadComment(j_decompress_ptr jpeg_info)\n{\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  StringInfo\n    *comment;\n\n  /*\n    Determine length of comment.\n  */\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=GetCharacter(jpeg_info);\n  if (length <= 2)\n    return(TRUE);\n  length-=2;\n  comment=BlobToStringInfo((const void *) NULL,length);\n  if (comment == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  /*\n    Read comment.\n  */\n  error_manager->profile=comment;\n  p=GetStringInfoDatum(comment);\n  for (i=0; i < (ssize_t) GetStringInfoLength(comment); i++)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  *p='\\0';\n  error_manager->profile=NULL;\n  p=GetStringInfoDatum(comment);\n  (void) SetImageProperty(image,\"comment\",(const char *) p,exception);\n  comment=DestroyStringInfo(comment);\n  return(TRUE);\n}\n\nstatic boolean ReadICCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[12];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *icc_profile,\n    *profile;\n\n  /*\n    Read color profile.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (length-- > 0)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  for (i=0; i < 12; i++)\n    magick[i]=(char) GetCharacter(jpeg_info);\n  if (LocaleCompare(magick,ICC_PROFILE) != 0)\n    {\n      /*\n        Not a ICC profile, return.\n      */\n      for (i=0; i < (ssize_t) (length-12); i++)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  (void) GetCharacter(jpeg_info);  /* id */\n  (void) GetCharacter(jpeg_info);  /* markers */\n  length-=14;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=(ssize_t) GetStringInfoLength(profile)-1; i >= 0; i--)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  error_manager->profile=NULL;\n  icc_profile=(StringInfo *) GetImageProfile(image,\"icc\");\n  if (icc_profile != (StringInfo *) NULL)\n    {\n      ConcatenateStringInfo(icc_profile,profile);\n      profile=DestroyStringInfo(profile);\n    }\n  else\n    {\n      status=SetImageProfile(image,\"icc\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      if (status == MagickFalse)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          return(FALSE);\n        }\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: ICC, %.20g bytes\",(double) length);\n  return(TRUE);\n}\n\nstatic boolean ReadIPTCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[MagickPathExtent];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *iptc_profile,\n    *profile;\n\n  /*\n    Determine length of binary data stored here.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (length-- > 0)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  /*\n    Validate that this was written as a Photoshop resource format slug.\n  */\n  for (i=0; i < 10; i++)\n    magick[i]=(char) GetCharacter(jpeg_info);\n  magick[10]='\\0';\n  length-=10;\n  if (length <= 10)\n    return(TRUE);\n  if (LocaleCompare(magick,\"Photoshop \") != 0)\n    {\n      /*\n        Not a IPTC profile, return.\n      */\n      for (i=0; i < (ssize_t) length; i++)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  /*\n    Remove the version number.\n  */\n  for (i=0; i < 4; i++)\n    (void) GetCharacter(jpeg_info);\n  if (length <= 11)\n    return(TRUE);\n  length-=4;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0;  i < (ssize_t) GetStringInfoLength(profile); i++)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  error_manager->profile=NULL;\n  iptc_profile=(StringInfo *) GetImageProfile(image,\"8bim\");\n  if (iptc_profile != (StringInfo *) NULL)\n    {\n      ConcatenateStringInfo(iptc_profile,profile);\n      profile=DestroyStringInfo(profile);\n    }\n  else\n    {\n      status=SetImageProfile(image,\"8bim\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      if (status == MagickFalse)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          return(FALSE);\n        }\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: iptc, %.20g bytes\",(double) length);\n  return(TRUE);\n}\n\nstatic boolean ReadProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    name[MagickPathExtent];\n\n  const StringInfo\n    *previous_profile;\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  int\n    marker;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *profile;\n\n  /*\n    Read generic profile.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  if (length <= 2)\n    return(TRUE);\n  length-=2;\n  marker=jpeg_info->unread_marker-JPEG_APP0;\n  (void) FormatLocaleString(name,MagickPathExtent,\"APP%d\",marker);\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0; i < (ssize_t) GetStringInfoLength(profile); i++)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  error_manager->profile=NULL;\n  if (marker == 1)\n    {\n      p=GetStringInfoDatum(profile);\n      if ((length > 4) && (LocaleNCompare((char *) p,\"exif\",4) == 0))\n        (void) CopyMagickString(name,\"exif\",MagickPathExtent);\n      if ((length > 5) && (LocaleNCompare((char *) p,\"http:\",5) == 0))\n        {\n          ssize_t\n            j;\n\n          /*\n            Extract namespace from XMP profile.\n          */\n          p=GetStringInfoDatum(profile);\n          for (j=0; j < (ssize_t) GetStringInfoLength(profile); j++)\n          {\n            if (*p == '\\0')\n              break;\n            p++;\n          }\n          if (j < (ssize_t) GetStringInfoLength(profile))\n            (void) DestroyStringInfo(SplitStringInfo(profile,(size_t) (j+1)));\n          (void) CopyMagickString(name,\"xmp\",MagickPathExtent);\n        }\n    }\n  previous_profile=GetImageProfile(image,name);\n  if (previous_profile != (const StringInfo *) NULL)\n    {\n      size_t\n        profile_length;\n\n      profile_length=GetStringInfoLength(profile);\n      SetStringInfoLength(profile,GetStringInfoLength(profile)+\n        GetStringInfoLength(previous_profile));\n      (void) memmove(GetStringInfoDatum(profile)+\n        GetStringInfoLength(previous_profile),GetStringInfoDatum(profile),\n        profile_length);\n      (void) memcpy(GetStringInfoDatum(profile),\n        GetStringInfoDatum(previous_profile),\n        GetStringInfoLength(previous_profile));\n    }\n  status=SetImageProfile(image,name,profile,exception);\n  profile=DestroyStringInfo(profile);\n  if (status == MagickFalse)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: %s, %.20g bytes\",name,(double) length);\n  return(TRUE);\n}\n\nstatic void SkipInputData(j_decompress_ptr cinfo,long number_bytes)\n{\n  SourceManager\n    *source;\n\n  if (number_bytes <= 0)\n    return;\n  source=(SourceManager *) cinfo->src;\n  while (number_bytes > (long) source->manager.bytes_in_buffer)\n  {\n    number_bytes-=(long) source->manager.bytes_in_buffer;\n    (void) FillInputBuffer(cinfo);\n  }\n  source->manager.next_input_byte+=number_bytes;\n  source->manager.bytes_in_buffer-=number_bytes;\n}\n\nstatic void TerminateSource(j_decompress_ptr cinfo)\n{\n  (void) cinfo;\n}\n\nstatic void JPEGSourceManager(j_decompress_ptr cinfo,Image *image)\n{\n  SourceManager\n    *source;\n\n  cinfo->src=(struct jpeg_source_mgr *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,sizeof(SourceManager));\n  source=(SourceManager *) cinfo->src;\n  source->buffer=(JOCTET *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,MaxBufferExtent*sizeof(JOCTET));\n  source=(SourceManager *) cinfo->src;\n  source->manager.init_source=InitializeSource;\n  source->manager.fill_input_buffer=FillInputBuffer;\n  source->manager.skip_input_data=SkipInputData;\n  source->manager.resync_to_restart=jpeg_resync_to_restart;\n  source->manager.term_source=TerminateSource;\n  source->manager.bytes_in_buffer=0;\n  source->manager.next_input_byte=NULL;\n  source->image=image;\n}\n\nstatic void JPEGSetImageQuality(struct jpeg_decompress_struct *jpeg_info,\n  Image *image)\n{\n  image->quality=UndefinedCompressionQuality;\n#if defined(D_PROGRESSIVE_SUPPORTED)\n  if (image->compression == LosslessJPEGCompression)\n    {\n      image->quality=100;\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Quality: 100 (lossless)\");\n    }\n  else\n#endif\n  {\n    ssize_t\n      j,\n      qvalue,\n      sum;\n\n    register ssize_t\n      i;\n\n    /*\n      Determine the JPEG compression quality from the quantization tables.\n    */\n    sum=0;\n    for (i=0; i < NUM_QUANT_TBLS; i++)\n    {\n      if (jpeg_info->quant_tbl_ptrs[i] != NULL)\n        for (j=0; j < DCTSIZE2; j++)\n          sum+=jpeg_info->quant_tbl_ptrs[i]->quantval[j];\n    }\n    if ((jpeg_info->quant_tbl_ptrs[0] != NULL) &&\n        (jpeg_info->quant_tbl_ptrs[1] != NULL))\n      {\n        ssize_t\n          hash[101] =\n          {\n            1020, 1015,  932,  848,  780,  735,  702,  679,  660,  645,\n             632,  623,  613,  607,  600,  594,  589,  585,  581,  571,\n             555,  542,  529,  514,  494,  474,  457,  439,  424,  410,\n             397,  386,  373,  364,  351,  341,  334,  324,  317,  309,\n             299,  294,  287,  279,  274,  267,  262,  257,  251,  247,\n             243,  237,  232,  227,  222,  217,  213,  207,  202,  198,\n             192,  188,  183,  177,  173,  168,  163,  157,  153,  148,\n             143,  139,  132,  128,  125,  119,  115,  108,  104,   99,\n              94,   90,   84,   79,   74,   70,   64,   59,   55,   49,\n              45,   40,   34,   30,   25,   20,   15,   11,    6,    4,\n               0\n          },\n          sums[101] =\n          {\n            32640, 32635, 32266, 31495, 30665, 29804, 29146, 28599, 28104,\n            27670, 27225, 26725, 26210, 25716, 25240, 24789, 24373, 23946,\n            23572, 22846, 21801, 20842, 19949, 19121, 18386, 17651, 16998,\n            16349, 15800, 15247, 14783, 14321, 13859, 13535, 13081, 12702,\n            12423, 12056, 11779, 11513, 11135, 10955, 10676, 10392, 10208,\n             9928,  9747,  9564,  9369,  9193,  9017,  8822,  8639,  8458,\n             8270,  8084,  7896,  7710,  7527,  7347,  7156,  6977,  6788,\n             6607,  6422,  6236,  6054,  5867,  5684,  5495,  5305,  5128,\n             4945,  4751,  4638,  4442,  4248,  4065,  3888,  3698,  3509,\n             3326,  3139,  2957,  2775,  2586,  2405,  2216,  2037,  1846,\n             1666,  1483,  1297,  1109,   927,   735,   554,   375,   201,\n              128,     0\n          };\n\n        qvalue=(ssize_t) (jpeg_info->quant_tbl_ptrs[0]->quantval[2]+\n          jpeg_info->quant_tbl_ptrs[0]->quantval[53]+\n          jpeg_info->quant_tbl_ptrs[1]->quantval[0]+\n          jpeg_info->quant_tbl_ptrs[1]->quantval[DCTSIZE2-1]);\n        for (i=0; i < 100; i++)\n        {\n          if ((qvalue < hash[i]) && (sum < sums[i]))\n            continue;\n          if (((qvalue <= hash[i]) && (sum <= sums[i])) || (i >= 50))\n            image->quality=(size_t) i+1;\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"Quality: %.20g (%s)\",(double) i+1,(qvalue <= hash[i]) &&\n              (sum <= sums[i]) ? \"exact\" : \"approximate\");\n          break;\n        }\n      }\n    else\n      if (jpeg_info->quant_tbl_ptrs[0] != NULL)\n        {\n          ssize_t\n            hash[101] =\n            {\n              510,  505,  422,  380,  355,  338,  326,  318,  311,  305,\n              300,  297,  293,  291,  288,  286,  284,  283,  281,  280,\n              279,  278,  277,  273,  262,  251,  243,  233,  225,  218,\n              211,  205,  198,  193,  186,  181,  177,  172,  168,  164,\n              158,  156,  152,  148,  145,  142,  139,  136,  133,  131,\n              129,  126,  123,  120,  118,  115,  113,  110,  107,  105,\n              102,  100,   97,   94,   92,   89,   87,   83,   81,   79,\n               76,   74,   70,   68,   66,   63,   61,   57,   55,   52,\n               50,   48,   44,   42,   39,   37,   34,   31,   29,   26,\n               24,   21,   18,   16,   13,   11,    8,    6,    3,    2,\n                0\n            },\n            sums[101] =\n            {\n              16320, 16315, 15946, 15277, 14655, 14073, 13623, 13230, 12859,\n              12560, 12240, 11861, 11456, 11081, 10714, 10360, 10027,  9679,\n               9368,  9056,  8680,  8331,  7995,  7668,  7376,  7084,  6823,\n               6562,  6345,  6125,  5939,  5756,  5571,  5421,  5240,  5086,\n               4976,  4829,  4719,  4616,  4463,  4393,  4280,  4166,  4092,\n               3980,  3909,  3835,  3755,  3688,  3621,  3541,  3467,  3396,\n               3323,  3247,  3170,  3096,  3021,  2952,  2874,  2804,  2727,\n               2657,  2583,  2509,  2437,  2362,  2290,  2211,  2136,  2068,\n               1996,  1915,  1858,  1773,  1692,  1620,  1552,  1477,  1398,\n               1326,  1251,  1179,  1109,  1031,   961,   884,   814,   736,\n                667,   592,   518,   441,   369,   292,   221,   151,    86,\n                 64,     0\n            };\n\n          qvalue=(ssize_t) (jpeg_info->quant_tbl_ptrs[0]->quantval[2]+\n            jpeg_info->quant_tbl_ptrs[0]->quantval[53]);\n          for (i=0; i < 100; i++)\n          {\n            if ((qvalue < hash[i]) && (sum < sums[i]))\n              continue;\n            if (((qvalue <= hash[i]) && (sum <= sums[i])) || (i >= 50))\n              image->quality=(size_t)i+1;\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Quality: %.20g (%s)\",(double) i+1,(qvalue <= hash[i]) &&\n                (sum <= sums[i]) ? \"exact\" : \"approximate\");\n            break;\n          }\n        }\n  }\n}\n\nstatic void JPEGSetImageSamplingFactor(struct jpeg_decompress_struct *jpeg_info,  Image *image,ExceptionInfo *exception)\n{\n  char\n    sampling_factor[MagickPathExtent];\n\n  switch (jpeg_info->out_color_space)\n  {\n    case JCS_CMYK:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: CMYK\");\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n        \"%dx%d,%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor,\n        jpeg_info->comp_info[3].h_samp_factor,\n        jpeg_info->comp_info[3].v_samp_factor);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Colorspace: GRAYSCALE\");\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\"%dx%d\",\n        jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor);\n      break;\n    }\n    case JCS_RGB:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: RGB\");\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n        \"%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor);\n      break;\n    }\n    default:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: %d\",\n        jpeg_info->out_color_space);\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n        \"%dx%d,%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor,\n        jpeg_info->comp_info[3].h_samp_factor,\n        jpeg_info->comp_info[3].v_samp_factor);\n      break;\n    }\n  }\n  (void) SetImageProperty(image,\"jpeg:sampling-factor\",sampling_factor,\n    exception);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Sampling Factors: %s\",\n    sampling_factor);\n}\n\nstatic Image *ReadJPEGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    value[MagickPathExtent];\n\n  const char\n    *option;\n\n  ErrorManager\n    error_manager;\n\n  Image\n    *image;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *memory_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    i;\n\n  struct jpeg_decompress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  register JSAMPLE\n    *p;\n\n  size_t\n    units;\n\n  ssize_t\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  debug=IsEventLogging();\n  (void) debug;\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize JPEG parameters.\n  */\n  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));\n  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));\n  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  memory_info=(MemoryInfo *) NULL;\n  error_manager.exception=exception;\n  error_manager.image=image;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      if (error_manager.profile != (StringInfo *) NULL)\n        error_manager.profile=DestroyStringInfo(error_manager.profile);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      return(DestroyImage(image));\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_decompress(&jpeg_info);\n  JPEGSourceManager(&jpeg_info,image);\n  jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);\n  option=GetImageOption(image_info,\"profile:skip\");\n  if (IsOptionMember(\"ICC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);\n  if (IsOptionMember(\"IPTC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);\n  for (i=1; i < 16; i++)\n    if ((i != 2) && (i != 13) && (i != 14))\n      if (IsOptionMember(\"APP\",option) == MagickFalse)\n        jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);\n  i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);\n  if ((image_info->colorspace == YCbCrColorspace) ||\n      (image_info->colorspace == Rec601YCbCrColorspace) ||\n      (image_info->colorspace == Rec709YCbCrColorspace))\n    jpeg_info.out_color_space=JCS_YCbCr;\n  /*\n    Set image resolution.\n  */\n  units=0;\n  if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&\n      (jpeg_info.Y_density != 1))\n    {\n      image->resolution.x=(double) jpeg_info.X_density;\n      image->resolution.y=(double) jpeg_info.Y_density;\n      units=(size_t) jpeg_info.density_unit;\n    }\n  if (units == 1)\n    image->units=PixelsPerInchResolution;\n  if (units == 2)\n    image->units=PixelsPerCentimeterResolution;\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  option=GetImageOption(image_info,\"jpeg:size\");\n  if ((option != (const char *) NULL) &&\n      (jpeg_info.out_color_space != JCS_YCbCr))\n    {\n      double\n        scale_factor;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Scale the image.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & SigmaValue) == 0)\n        geometry_info.sigma=geometry_info.rho;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      image->magick_columns=jpeg_info.output_width;\n      image->magick_rows=jpeg_info.output_height;\n      scale_factor=1.0;\n      if (geometry_info.rho != 0.0)\n        scale_factor=jpeg_info.output_width/geometry_info.rho;\n      if ((geometry_info.sigma != 0.0) &&\n          (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))\n        scale_factor=jpeg_info.output_height/geometry_info.sigma;\n      jpeg_info.scale_num=1U;\n      jpeg_info.scale_denom=(unsigned int) scale_factor;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Scale factor: %.20g\",(double) scale_factor);\n    }\n#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)\n#if defined(D_LOSSLESS_SUPPORTED)\n  image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?\n    JPEGInterlace : NoInterlace;\n  image->compression=jpeg_info.process == JPROC_LOSSLESS ?\n    LosslessJPEGCompression : JPEGCompression;\n  if (jpeg_info.data_precision > 8)\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n      \"12-bit JPEG not supported. Reducing pixel data to 8 bits\",\"`%s'\",\n      image->filename);\n  if (jpeg_info.data_precision == 16)\n    jpeg_info.data_precision=12;\n#else\n  image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :\n    NoInterlace;\n  image->compression=JPEGCompression;\n#endif\n#else\n  image->compression=JPEGCompression;\n  image->interlace=JPEGInterlace;\n#endif\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    {\n      /*\n        Let the JPEG library quantize the image.\n      */\n      jpeg_info.quantize_colors=TRUE;\n      jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);\n    }\n  option=GetImageOption(image_info,\"jpeg:block-smoothing\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  jpeg_info.dct_method=JDCT_FLOAT;\n  option=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (option != (const char *) NULL)\n    switch (*option)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(option,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(option,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(option,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(option,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(option,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:fancy-upsampling\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  (void) jpeg_start_decompress(&jpeg_info);\n  image->columns=jpeg_info.output_width;\n  image->rows=jpeg_info.output_height;\n  image->depth=(size_t) jpeg_info.data_precision;\n  switch (jpeg_info.out_color_space)\n  {\n    case JCS_RGB:\n    default:\n    {\n      (void) SetImageColorspace(image,sRGBColorspace,exception);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) SetImageColorspace(image,GRAYColorspace,exception);\n      break;\n    }\n    case JCS_YCbCr:\n    {\n      (void) SetImageColorspace(image,YCbCrColorspace,exception);\n      break;\n    }\n    case JCS_CMYK:\n    {\n      (void) SetImageColorspace(image,CMYKColorspace,exception);\n      break;\n    }\n  }\n  if (IsITUFaxImage(image) != MagickFalse)\n    {\n      (void) SetImageColorspace(image,LabColorspace,exception);\n      jpeg_info.out_color_space=JCS_YCbCr;\n    }\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    if (AcquireImageColormap(image,StringToUnsignedLong(option),exception)\n         == MagickFalse)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))\n    {\n      size_t\n        colors;\n\n      colors=(size_t) GetQuantumRange(image->depth)+1;\n      if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  if (image->debug != MagickFalse)\n    {\n      if (image->interlace != NoInterlace)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: nonprogressive\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Data precision: %d\",\n        (int) jpeg_info.data_precision);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %dx%d\",\n        (int) jpeg_info.output_width,(int) jpeg_info.output_height);\n    }\n  JPEGSetImageQuality(&jpeg_info,image);\n  JPEGSetImageSamplingFactor(&jpeg_info,image,exception);\n  (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n    jpeg_info.out_color_space);\n  (void) SetImageProperty(image,\"jpeg:colorspace\",value,exception);\n  if (image_info->ping != MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      return(DestroyImageList(image));\n    }\n  if ((jpeg_info.output_components != 1) &&\n      (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(CorruptImageError,\"ImageTypeNotSupported\");\n    }\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.output_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n  /*\n    Convert JPEG pixels to pixel packets.\n  */\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      return(DestroyImage(image));\n    }\n  if (jpeg_info.quantize_colors != 0)\n    {\n      image->colors=(size_t) jpeg_info.actual_number_of_colors;\n      if (jpeg_info.out_color_space == JCS_GRAYSCALE)\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[0][i]);\n          image->colormap[i].green=image->colormap[i].red;\n          image->colormap[i].blue=image->colormap[i].red;\n          image->colormap[i].alpha=(MagickRealType) OpaqueAlpha;\n        }\n      else\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[0][i]);\n          image->colormap[i].green=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[1][i]);\n          image->colormap[i].blue=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[2][i]);\n          image->colormap[i].alpha=(MagickRealType) OpaqueAlpha;\n        }\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);\n        continue;\n      }\n    p=jpeg_pixels;\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    if (jpeg_info.data_precision > 8)\n      {\n        unsigned short\n          scale;\n\n        scale=65535/(unsigned short) GetQuantumRange((size_t)\n          jpeg_info.data_precision);\n        if (jpeg_info.output_components == 1)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            ssize_t\n              pixel;\n\n            pixel=(ssize_t) (scale*GETJSAMPLE(*p));\n            index=(Quantum) ConstrainColormapIndex(image,pixel,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        else\n          if (image->colorspace != CMYKColorspace)\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelGreen(image,ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelBlue(image,ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelAlpha(image,OpaqueAlpha,q);\n              q+=GetPixelChannels(image);\n            }\n          else\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelCyan(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelMagenta(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelYellow(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelBlack(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelAlpha(image,OpaqueAlpha,q);\n              q+=GetPixelChannels(image);\n            }\n      }\n    else\n      if (jpeg_info.output_components == 1)\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          index=(Quantum) ConstrainColormapIndex(image,(ssize_t) GETJSAMPLE(*p),\n            exception);\n          SetPixelIndex(image,index,q);\n          SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n      else\n        if (image->colorspace != CMYKColorspace)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)),q);\n            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)),q);\n            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n        else\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelMagenta(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelYellow(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelBlack(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      {\n        jpeg_abort_decompress(&jpeg_info);\n        break;\n      }\n  }\n  if (status != MagickFalse)\n    {\n      error_manager.finished=MagickTrue;\n      if (setjmp(error_manager.error_recovery) == 0)\n        (void) jpeg_finish_decompress(&jpeg_info);\n    }\n  /*\n    Free jpeg resources.\n  */\n  jpeg_destroy_decompress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r J P E G I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterJPEGImage() adds properties for the JPEG image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterJPEGImage method is:\n%\n%      size_t RegisterJPEGImage(void)\n%\n*/\nModuleExport size_t RegisterJPEGImage(void)\n{\n#define JPEGDescription \"Joint Photographic Experts Group JFIF format\"\n\n  char\n    version[MagickPathExtent];\n\n  MagickInfo\n    *entry;\n\n  *version='\\0';\n#if defined(JPEG_LIB_VERSION)\n  (void) FormatLocaleString(version,MagickPathExtent,\"%d\",JPEG_LIB_VERSION);\n#endif\n  entry=AcquireMagickInfo(\"JPEG\",\"JPE\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsJPEG;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"JPEG\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsJPEG;\n  entry->flags^=CoderAdjoinFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"JPG\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"JPS\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"PJPEG\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r J P E G I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterJPEGImage() removes format registrations made by the\n%  JPEG module from the list of supported formats.\n%\n%  The format of the UnregisterJPEGImage method is:\n%\n%      UnregisterJPEGImage(void)\n%\n*/\nModuleExport void UnregisterJPEGImage(void)\n{\n  (void) UnregisterMagickInfo(\"PJPG\");\n  (void) UnregisterMagickInfo(\"JPS\");\n  (void) UnregisterMagickInfo(\"JPG\");\n  (void) UnregisterMagickInfo(\"JPEG\");\n  (void) UnregisterMagickInfo(\"JPE\");\n}\n\f\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  W r i t e J P E G I m a g e                                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteJPEGImage() writes a JPEG image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the WriteJPEGImage method is:\n%\n%      MagickBooleanType WriteJPEGImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o jpeg_image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic QuantizationTable *DestroyQuantizationTable(QuantizationTable *table)\n{\n  assert(table != (QuantizationTable *) NULL);\n  if (table->slot != (char *) NULL)\n    table->slot=DestroyString(table->slot);\n  if (table->description != (char *) NULL)\n    table->description=DestroyString(table->description);\n  if (table->levels != (unsigned int *) NULL)\n    table->levels=(unsigned int *) RelinquishMagickMemory(table->levels);\n  table=(QuantizationTable *) RelinquishMagickMemory(table);\n  return(table);\n}\n\nstatic boolean EmptyOutputBuffer(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  destination->manager.free_in_buffer=(size_t) WriteBlob(destination->image,\n    MaxBufferExtent,destination->buffer);\n  if (destination->manager.free_in_buffer != MaxBufferExtent)\n    ERREXIT(cinfo,JERR_FILE_WRITE);\n  destination->manager.next_output_byte=destination->buffer;\n  return(TRUE);\n}\n\nstatic QuantizationTable *GetQuantizationTable(const char *filename,\n  const char *slot,ExceptionInfo *exception)\n{\n  char\n    *p,\n    *xml;\n\n  const char\n    *attribute,\n    *content;\n\n  double\n    value;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    j;\n\n  QuantizationTable\n    *table;\n\n  size_t\n    length;\n\n  XMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\n\n  (void) LogMagickEvent(ConfigureEvent,GetMagickModule(),\n    \"Loading quantization tables \\\"%s\\\" ...\",filename);\n  table=(QuantizationTable *) NULL;\n  xml=FileToString(filename,~0UL,exception);\n  if (xml == (char *) NULL)\n    return(table);\n  quantization_tables=NewXMLTree(xml,exception);\n  if (quantization_tables == (XMLTreeInfo *) NULL)\n    {\n      xml=DestroyString(xml);\n      return(table);\n    }\n  for (table_iterator=GetXMLTreeChild(quantization_tables,\"table\");\n       table_iterator != (XMLTreeInfo *) NULL;\n       table_iterator=GetNextXMLTreeTag(table_iterator))\n  {\n    attribute=GetXMLTreeAttribute(table_iterator,\"slot\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(slot,attribute) == 0))\n      break;\n    attribute=GetXMLTreeAttribute(table_iterator,\"alias\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(slot,attribute) == 0))\n      break;\n  }\n  if (table_iterator == (XMLTreeInfo *) NULL)\n    {\n      xml=DestroyString(xml);\n      return(table);\n    }\n  description=GetXMLTreeChild(table_iterator,\"description\");\n  if (description == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\",\"<description>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  levels=GetXMLTreeChild(table_iterator,\"levels\");\n  if (levels == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\",\"<levels>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));\n  if (table == (QuantizationTable *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\n      \"UnableToAcquireQuantizationTable\");\n  table->slot=(char *) NULL;\n  table->description=(char *) NULL;\n  table->levels=(unsigned int *) NULL;\n  attribute=GetXMLTreeAttribute(table_iterator,\"slot\");\n  if (attribute != (char *) NULL)\n    table->slot=ConstantString(attribute);\n  content=GetXMLTreeContent(description);\n  if (content != (char *) NULL)\n    table->description=ConstantString(content);\n  attribute=GetXMLTreeAttribute(levels,\"width\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels width>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->width=StringToUnsignedLong(attribute);\n  if (table->width == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n       \"XmlInvalidAttribute\",\"<levels width>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"height\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels height>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->height=StringToUnsignedLong(attribute);\n  if (table->height == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\",\"<levels height>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"divisor\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels divisor>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->divisor=InterpretLocaleValue(attribute,(char **) NULL);\n  if (table->divisor == 0.0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\",\"<levels divisor>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  content=GetXMLTreeContent(levels);\n  if (content == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingContent\",\"<levels>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  length=(size_t) table->width*table->height;\n  if (length < 64)\n    length=64;\n  table->levels=(unsigned int *) AcquireQuantumMemory(length,\n    sizeof(*table->levels));\n  if (table->levels == (unsigned int *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\n      \"UnableToAcquireQuantizationTable\");\n  for (i=0; i < (ssize_t) (table->width*table->height); i++)\n  {\n    table->levels[i]=(unsigned int) (InterpretLocaleValue(content,&p)/\n      table->divisor+0.5);\n    while (isspace((int) ((unsigned char) *p)) != 0)\n      p++;\n    if (*p == ',')\n      p++;\n    content=p;\n  }\n  value=InterpretLocaleValue(content,&p);\n  (void) value;\n  if (p != content)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidContent\",\"<level> too many values, table \\\"%s\\\"\",slot);\n     quantization_tables=DestroyXMLTree(quantization_tables);\n     table=DestroyQuantizationTable(table);\n     xml=DestroyString(xml);\n     return(table);\n   }\n  for (j=i; j < 64; j++)\n    table->levels[j]=table->levels[j-1];\n  quantization_tables=DestroyXMLTree(quantization_tables);\n  xml=DestroyString(xml);\n  return(table);\n}\n\nstatic void InitializeDestination(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  destination->buffer=(JOCTET *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,MaxBufferExtent*sizeof(JOCTET));\n  destination->manager.next_output_byte=destination->buffer;\n  destination->manager.free_in_buffer=MaxBufferExtent;\n}\n\nstatic void TerminateDestination(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  if ((MaxBufferExtent-(int) destination->manager.free_in_buffer) > 0)\n    {\n      ssize_t\n        count;\n\n      count=WriteBlob(destination->image,MaxBufferExtent-\n        destination->manager.free_in_buffer,destination->buffer);\n      if (count != (ssize_t)\n          (MaxBufferExtent-destination->manager.free_in_buffer))\n        ERREXIT(cinfo,JERR_FILE_WRITE);\n    }\n}\n\nstatic void WriteProfile(j_compress_ptr jpeg_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const char\n    *name;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    iptc;\n\n  register ssize_t\n    i;\n\n  size_t\n    length,\n    tag_length;\n\n  StringInfo\n    *custom_profile;\n\n  /*\n    Save image profile as a APP marker.\n  */\n  iptc=MagickFalse;\n  custom_profile=AcquireStringInfo(65535L);\n  ResetImageProfileIterator(image);\n  for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n  {\n    profile=GetImageProfile(image,name);\n    if (LocaleCompare(name,\"EXIF\") == 0)\n      {\n        length=GetStringInfoLength(profile);\n        if (length > 65533L)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              CoderWarning,\"ExifProfileSizeExceedsLimit\",image->filename);\n            length=65533L;\n          }\n        jpeg_write_marker(jpeg_info,XML_MARKER,GetStringInfoDatum(profile),\n          (unsigned int) length);\n      }\n    if (LocaleCompare(name,\"ICC\") == 0)\n      {\n        register unsigned char\n          *p;\n\n        tag_length=strlen(ICC_PROFILE);\n        p=GetStringInfoDatum(custom_profile);\n        (void) CopyMagickMemory(p,ICC_PROFILE,tag_length);\n        p[tag_length]='\\0';\n        for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=65519L)\n        {\n          length=MagickMin(GetStringInfoLength(profile)-i,65519L);\n          p[12]=(unsigned char) ((i/65519L)+1);\n          p[13]=(unsigned char) (GetStringInfoLength(profile)/65519L+1);\n          (void) CopyMagickMemory(p+tag_length+3,GetStringInfoDatum(profile)+i,\n            length);\n          jpeg_write_marker(jpeg_info,ICC_MARKER,GetStringInfoDatum(\n            custom_profile),(unsigned int) (length+tag_length+3));\n        }\n      }\n    if (((LocaleCompare(name,\"IPTC\") == 0) ||\n        (LocaleCompare(name,\"8BIM\") == 0)) && (iptc == MagickFalse))\n      {\n        register unsigned char\n          *p;\n\n        size_t\n          roundup;\n\n        iptc=MagickTrue;\n        p=GetStringInfoDatum(custom_profile);\n        for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=65500L)\n        {\n          length=MagickMin(GetStringInfoLength(profile)-i,65500L);\n          roundup=(size_t) (length & 0x01);\n          if (LocaleNCompare((char *) GetStringInfoDatum(profile),\"8BIM\",4) == 0)\n            {\n              (void) memcpy(p,\"Photoshop 3.0 \",14);\n              tag_length=14;\n            }\n          else\n            {\n              (void) CopyMagickMemory(p,\"Photoshop 3.0 8BIM\\04\\04\\0\\0\\0\\0\",24);\n              tag_length=26;\n              p[24]=(unsigned char) (length >> 8);\n              p[25]=(unsigned char) (length & 0xff);\n            }\n          p[13]=0x00;\n          (void) memcpy(p+tag_length,GetStringInfoDatum(profile)+i,length);\n          if (roundup != 0)\n            p[length+tag_length]='\\0';\n          jpeg_write_marker(jpeg_info,IPTC_MARKER,GetStringInfoDatum(\n            custom_profile),(unsigned int) (length+tag_length+roundup));\n        }\n      }\n    if (LocaleCompare(name,\"XMP\") == 0)\n      {\n        StringInfo\n          *xmp_profile;\n\n        /*\n          Add namespace to XMP profile.\n        */\n        xmp_profile=StringToStringInfo(\"http://ns.adobe.com/xap/1.0/ \");\n        if (xmp_profile != (StringInfo *) NULL)\n          {\n            if (profile != (StringInfo *) NULL)\n              ConcatenateStringInfo(xmp_profile,profile);\n            GetStringInfoDatum(xmp_profile)[28]='\\0';\n            for (i=0; i < (ssize_t) GetStringInfoLength(xmp_profile); i+=65533L)\n            {\n              length=MagickMin(GetStringInfoLength(xmp_profile)-i,65533L);\n              jpeg_write_marker(jpeg_info,XML_MARKER,\n                GetStringInfoDatum(xmp_profile)+i,(unsigned int) length);\n            }\n            xmp_profile=DestroyStringInfo(xmp_profile);\n          }\n      }\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"%s profile: %.20g bytes\",name,(double) GetStringInfoLength(profile));\n    name=GetNextImageProfile(image);\n  }\n  custom_profile=DestroyStringInfo(custom_profile);\n}\n\nstatic void JPEGDestinationManager(j_compress_ptr cinfo,Image * image)\n{\n  DestinationManager\n    *destination;\n\n  cinfo->dest=(struct jpeg_destination_mgr *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,sizeof(DestinationManager));\n  destination=(DestinationManager *) cinfo->dest;\n  destination->manager.init_destination=InitializeDestination;\n  destination->manager.empty_output_buffer=EmptyOutputBuffer;\n  destination->manager.term_destination=TerminateDestination;\n  destination->image=image;\n}\n\nstatic char **SamplingFactorToList(const char *text)\n{\n  char\n    **textlist;\n\n  register char\n    *q;\n\n  register const char\n    *p;\n\n  register ssize_t\n    i;\n\n  if (text == (char *) NULL)\n    return((char **) NULL);\n  /*\n    Convert string to an ASCII list.\n  */\n  textlist=(char **) AcquireQuantumMemory((size_t) MAX_COMPONENTS,\n    sizeof(*textlist));\n  if (textlist == (char **) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToConvertText\");\n  p=text;\n  for (i=0; i < (ssize_t) MAX_COMPONENTS; i++)\n  {\n    for (q=(char *) p; *q != '\\0'; q++)\n      if (*q == ',')\n        break;\n    textlist[i]=(char *) AcquireQuantumMemory((size_t) (q-p)+MagickPathExtent,\n      sizeof(*textlist[i]));\n    if (textlist[i] == (char *) NULL)\n      ThrowFatalException(ResourceLimitFatalError,\"UnableToConvertText\");\n    (void) CopyMagickString(textlist[i],p,(size_t) (q-p+1));\n    if (*q == '\\r')\n      q++;\n    if (*q == '\\0')\n      break;\n    p=q+1;\n  }\n  for (i++; i < (ssize_t) MAX_COMPONENTS; i++)\n    textlist[i]=ConstantString(\"1x1\");\n  return(textlist);\n}\n\nstatic MagickBooleanType WriteJPEGImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *option,\n    *sampling_factor,\n    *value;\n\n  ErrorManager\n    error_manager;\n\n  Image\n    *volatile volatile_image;\n\n  int\n    colorspace,\n    quality;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *memory_info;\n\n  register JSAMPLE\n    *q;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  struct jpeg_compress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  unsigned short\n    scale;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if ((LocaleCompare(image_info->magick,\"JPS\") == 0) &&\n      (image->next != (Image *) NULL))\n    image=AppendImages(image,MagickFalse,exception);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize JPEG parameters.\n  */\n  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));\n  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));\n  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));\n  volatile_image=image;\n  jpeg_info.client_data=(void *) volatile_image;\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  error_manager.exception=exception;\n  error_manager.image=volatile_image;\n  memory_info=(MemoryInfo *) NULL;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_compress(&jpeg_info);\n      (void) CloseBlob(volatile_image);\n      return(MagickFalse);\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_compress(&jpeg_info);\n  JPEGDestinationManager(&jpeg_info,image);\n  if ((image->columns != (unsigned int) image->columns) ||\n      (image->rows != (unsigned int) image->rows))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  jpeg_info.image_width=(unsigned int) image->columns;\n  jpeg_info.image_height=(unsigned int) image->rows;\n  jpeg_info.input_components=3;\n  jpeg_info.data_precision=8;\n  jpeg_info.in_color_space=JCS_RGB;\n  switch (image->colorspace)\n  {\n    case CMYKColorspace:\n    {\n      jpeg_info.input_components=4;\n      jpeg_info.in_color_space=JCS_CMYK;\n      break;\n    }\n    case YCbCrColorspace:\n    case Rec601YCbCrColorspace:\n    case Rec709YCbCrColorspace:\n    {\n      jpeg_info.in_color_space=JCS_YCbCr;\n      break;\n    }\n    case GRAYColorspace:\n    {\n      if (image_info->type == TrueColorType)\n        break;\n      jpeg_info.input_components=1;\n      jpeg_info.in_color_space=JCS_GRAYSCALE;\n      break;\n    }\n    default:\n    {\n      (void) TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image_info->type == TrueColorType)\n        break;\n      if (SetImageGray(image,exception) != MagickFalse)\n        {\n          jpeg_info.input_components=1;\n          jpeg_info.in_color_space=JCS_GRAYSCALE;\n        }\n      break;\n    }\n  }\n  jpeg_set_defaults(&jpeg_info);\n  if (jpeg_info.in_color_space == JCS_CMYK)\n    jpeg_set_colorspace(&jpeg_info,JCS_YCCK);\n  if ((jpeg_info.data_precision != 12) && (image->depth <= 8))\n    jpeg_info.data_precision=8;\n  else\n    jpeg_info.data_precision=BITS_IN_JSAMPLE;\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Image resolution: %.20g,%.20g\",image->resolution.x,image->resolution.y);\n  if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))\n    {\n      /*\n        Set image resolution.\n      */\n      jpeg_info.write_JFIF_header=TRUE;\n      jpeg_info.X_density=(UINT16) image->resolution.x;\n      jpeg_info.Y_density=(UINT16) image->resolution.y;\n      /*\n        Set image resolution units.\n      */\n      if (image->units == PixelsPerInchResolution)\n        jpeg_info.density_unit=(UINT8) 1;\n      if (image->units == PixelsPerCentimeterResolution)\n        jpeg_info.density_unit=(UINT8) 2;\n    }\n  jpeg_info.dct_method=JDCT_FLOAT;\n  option=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (option != (const char *) NULL)\n    switch (*option)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(option,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(option,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(option,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(option,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(option,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:optimize-coding\");\n  if (option != (const char *) NULL)\n    jpeg_info.optimize_coding=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  else\n    {\n      MagickSizeType\n        length;\n\n      length=(MagickSizeType) jpeg_info.input_components*image->columns*\n        image->rows*sizeof(JSAMPLE);\n      if (length == (MagickSizeType) ((size_t) length))\n        {\n          /*\n            Perform optimization only if available memory resources permit it.\n          */\n          status=AcquireMagickResource(MemoryResource,length);\n          RelinquishMagickResource(MemoryResource,length);\n          jpeg_info.optimize_coding=status == MagickFalse ? FALSE : TRUE;\n        }\n    }\n#if (JPEG_LIB_VERSION >= 61) && defined(C_PROGRESSIVE_SUPPORTED)\n  if ((LocaleCompare(image_info->magick,\"PJPEG\") == 0) ||\n      (image_info->interlace != NoInterlace))\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      jpeg_simple_progression(&jpeg_info);\n    }\n  else\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Interlace: non-progressive\");\n#else\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Interlace: nonprogressive\");\n#endif\n  quality=92;\n  if ((image_info->compression != LosslessJPEGCompression) &&\n      (image->quality <= 100))\n    {\n      if (image->quality != UndefinedCompressionQuality)\n        quality=(int) image->quality;\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Quality: %.20g\",\n          (double) image->quality);\n    }\n  else\n    {\n#if !defined(C_LOSSLESS_SUPPORTED)\n      quality=100;\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Quality: 100\");\n#else\n      if (image->quality < 100)\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n          \"LosslessToLossyJPEGConversion\",image->filename);\n      else\n        {\n          int\n            point_transform,\n            predictor;\n\n          predictor=image->quality/100;  /* range 1-7 */\n          point_transform=image->quality % 20;  /* range 0-15 */\n          jpeg_simple_lossless(&jpeg_info,predictor,point_transform);\n          if (image->debug != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Compression: lossless\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Predictor: %d\",predictor);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Point Transform: %d\",point_transform);\n            }\n        }\n#endif\n    }\n  option=GetImageOption(image_info,\"jpeg:extent\");\n  if (option != (const char *) NULL)\n    {\n      Image\n        *jpeg_image;\n\n      ImageInfo\n        *extent_info;\n\n      extent_info=CloneImageInfo(image_info);\n      extent_info->blob=NULL;\n      jpeg_image=CloneImage(image,0,0,MagickTrue,exception);\n      if (jpeg_image != (Image *) NULL)\n        {\n          MagickSizeType\n            extent;\n\n          size_t\n            maximum,\n            minimum;\n\n          /*\n            Search for compression quality that does not exceed image extent.\n          */\n          extent_info->quality=0;\n          extent=(MagickSizeType) SiPrefixToDoubleInterval(option,100.0);\n          (void) DeleteImageOption(extent_info,\"jpeg:extent\");\n          (void) DeleteImageArtifact(jpeg_image,\"jpeg:extent\");\n          maximum=image_info->quality;\n          if (maximum < 2)\n            maximum=101;\n          for (minimum=2; minimum < maximum; )\n          {\n            (void) AcquireUniqueFilename(jpeg_image->filename);\n            jpeg_image->quality=minimum+(maximum-minimum+1)/2;\n            status=WriteJPEGImage(extent_info,jpeg_image,exception);\n            if (GetBlobSize(jpeg_image) <= extent)\n              minimum=jpeg_image->quality+1;\n            else\n              maximum=jpeg_image->quality-1;\n            (void) RelinquishUniqueFileResource(jpeg_image->filename);\n          }\n          quality=(int) minimum-1;\n          jpeg_image=DestroyImage(jpeg_image);\n        }\n      extent_info=DestroyImageInfo(extent_info);\n    }\n  jpeg_set_quality(&jpeg_info,quality,TRUE);\n#if (JPEG_LIB_VERSION >= 70)\n  option=GetImageOption(image_info,\"quality\");\n  if (option != (const char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      int\n        flags;\n\n      /*\n        Set quality scaling for luminance and chrominance separately.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if (((flags & RhoValue) != 0) && ((flags & SigmaValue) != 0))\n        {\n          jpeg_info.q_scale_factor[0]=jpeg_quality_scaling((int)\n            (geometry_info.rho+0.5));\n          jpeg_info.q_scale_factor[1]=jpeg_quality_scaling((int)\n            (geometry_info.sigma+0.5));\n          jpeg_default_qtables(&jpeg_info,TRUE);\n        }\n    }\n#endif\n  colorspace=jpeg_info.in_color_space;\n  value=GetImageOption(image_info,\"jpeg:colorspace\");\n  if (value == (char *) NULL)\n    value=GetImageProperty(image,\"jpeg:colorspace\",exception);\n  if (value != (char *) NULL)\n    colorspace=StringToInteger(value);\n  sampling_factor=(const char *) NULL;\n  if (colorspace == jpeg_info.in_color_space)\n    {\n      value=GetImageOption(image_info,\"jpeg:sampling-factor\");\n      if (value == (char *) NULL)\n        value=GetImageProperty(image,\"jpeg:sampling-factor\",exception);\n      if (value != (char *) NULL)\n        {\n          sampling_factor=value;\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Input sampling-factors=%s\",sampling_factor);\n        }\n    }\n  value=GetImageOption(image_info,\"jpeg:sampling-factor\");\n  if (image_info->sampling_factor != (char *) NULL)\n    sampling_factor=image_info->sampling_factor;\n  if (sampling_factor == (const char *) NULL)\n    {\n      if (quality >= 90)\n        for (i=0; i < MAX_COMPONENTS; i++)\n        {\n          jpeg_info.comp_info[i].h_samp_factor=1;\n          jpeg_info.comp_info[i].v_samp_factor=1;\n        }\n    }\n  else\n    {\n      char\n        **factors;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Set sampling factor.\n      */\n      i=0;\n      factors=SamplingFactorToList(sampling_factor);\n      if (factors != (char **) NULL)\n        {\n          for (i=0; i < MAX_COMPONENTS; i++)\n          {\n            if (factors[i] == (char *) NULL)\n              break;\n            flags=ParseGeometry(factors[i],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            jpeg_info.comp_info[i].h_samp_factor=(int) geometry_info.rho;\n            jpeg_info.comp_info[i].v_samp_factor=(int) geometry_info.sigma;\n            factors[i]=(char *) RelinquishMagickMemory(factors[i]);\n          }\n          factors=(char **) RelinquishMagickMemory(factors);\n        }\n      for ( ; i < MAX_COMPONENTS; i++)\n      {\n        jpeg_info.comp_info[i].h_samp_factor=1;\n        jpeg_info.comp_info[i].v_samp_factor=1;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:q-table\");\n  if (option != (const char *) NULL)\n    {\n      QuantizationTable\n        *table;\n\n      /*\n        Custom quantization tables.\n      */\n      table=GetQuantizationTable(option,\"0\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=0; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=0;\n          jpeg_add_quant_table(&jpeg_info,0,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"1\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=1; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=1;\n          jpeg_add_quant_table(&jpeg_info,1,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"2\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=2; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=2;\n          jpeg_add_quant_table(&jpeg_info,2,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"3\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=3; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=3;\n          jpeg_add_quant_table(&jpeg_info,3,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n    }\n  jpeg_start_compress(&jpeg_info,TRUE);\n  if (image->debug != MagickFalse)\n    {\n      if (image->storage_class == PseudoClass)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Storage class: PseudoClass\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Storage class: DirectClass\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Depth: %.20g\",\n        (double) image->depth);\n      if (image->colors != 0)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Number of colors: %.20g\",(double) image->colors);\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Number of colors: unspecified\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"JPEG data precision: %d\",(int) jpeg_info.data_precision);\n      switch (image->colorspace)\n      {\n        case CMYKColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Storage class: DirectClass\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: CMYK\");\n          break;\n        }\n        case YCbCrColorspace:\n        case Rec601YCbCrColorspace:\n        case Rec709YCbCrColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: YCbCr\");\n          break;\n        }\n        default:\n          break;\n      }\n      switch (image->colorspace)\n      {\n        case CMYKColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: CMYK\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor,\n            jpeg_info.comp_info[3].h_samp_factor,\n            jpeg_info.comp_info[3].v_samp_factor);\n          break;\n        }\n        case GRAYColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: GRAY\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d\",jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor);\n          break;\n        }\n        case sRGBColorspace:\n        case RGBColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Image colorspace is RGB\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor);\n          break;\n        }\n        case YCbCrColorspace:\n        case Rec601YCbCrColorspace:\n        case Rec709YCbCrColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: YCbCr\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor);\n          break;\n        }\n        default:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: %d\",\n            image->colorspace);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor,\n            jpeg_info.comp_info[3].h_samp_factor,\n            jpeg_info.comp_info[3].v_samp_factor);\n          break;\n        }\n      }\n    }\n  /*\n    Write JPEG profiles.\n  */\n  value=GetImageProperty(image,\"comment\",exception);\n  if (value != (char *) NULL)\n    for (i=0; i < (ssize_t) strlen(value); i+=65533L)\n      jpeg_write_marker(&jpeg_info,JPEG_COM,(unsigned char *) value+i,\n        (unsigned int) MagickMin((size_t) strlen(value+i),65533L));\n  if (image->profiles != (void *) NULL)\n    WriteProfile(&jpeg_info,image,exception);\n  /*\n    Convert MIFF to JPEG raster pixels.\n  */\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.input_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_compress(&jpeg_info);\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  scale=65535/(unsigned short) GetQuantumRange((size_t)\n    jpeg_info.data_precision);\n  if (scale == 0)\n    scale=1;\n  if (jpeg_info.data_precision <= 8)\n    {\n      if ((jpeg_info.in_color_space == JCS_RGB) ||\n          (jpeg_info.in_color_space == JCS_YCbCr))\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelBlue(image,p));\n            p+=GetPixelChannels(image);\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n      else\n        if (jpeg_info.in_color_space == JCS_GRAYSCALE)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register const Quantum\n              *p;\n\n            register ssize_t\n              x;\n\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            q=jpeg_pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              *q++=(JSAMPLE) ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(\n                image,p)));\n              p+=GetPixelChannels(image);\n            }\n            (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n            status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n            }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register const Quantum\n              *p;\n\n            register ssize_t\n              x;\n\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            q=jpeg_pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              /*\n                Convert DirectClass packets to contiguous CMYK scanlines.\n              */\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelCyan(image,p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelMagenta(image,p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelYellow(image,p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelBlack(image,p))));\n              p+=GetPixelChannels(image);\n            }\n            (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n            status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n    }\n  else\n    if (jpeg_info.in_color_space == JCS_GRAYSCALE)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register const Quantum\n          *p;\n\n        register ssize_t\n          x;\n\n        p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          break;\n        q=jpeg_pixels;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          *q++=(JSAMPLE) (ScaleQuantumToShort(ClampToQuantum(GetPixelLuma(image,\n            p)))/scale);\n          p+=GetPixelChannels(image);\n        }\n        (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n    else\n      if ((jpeg_info.in_color_space == JCS_RGB) ||\n          (jpeg_info.in_color_space == JCS_YCbCr))\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelRed(image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelGreen(image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelBlue(image,p))/scale);\n            p+=GetPixelChannels(image);\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n      else\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            /*\n              Convert DirectClass packets to contiguous CMYK scanlines.\n            */\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelRed(\n              image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelGreen(\n              image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelBlue(\n              image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelBlack(\n              image,p))/scale);\n            p+=GetPixelChannels(image);\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n  if (y == (ssize_t) image->rows)\n    jpeg_finish_compress(&jpeg_info);\n  /*\n    Relinquish resources.\n  */\n  jpeg_destroy_compress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n#endif\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE locale [\n<!ELEMENT locale (exception)>\n<!ELEMENT exception (ANY)+>\n<!ELEMENT warning (message)+>\n<!ELEMENT error (message)+>\n<!ELEMENT fatalerror (message)+>\n<!ELEMENT message (#PCDATA)>\n<!ATTLIST locale name CDATA #REQUIRED>\n<!ATTLIST message name CDATA #REQUIRED>\n]>\n<locale name=\"english\">\n  <exception>\n    <blob>\n      <error>\n        <message name=\"UnableToOpenBlob\">\n          unable to open image\n        </message>\n        <message name=\"UnableToOpenFile\">\n          unable to open file\n        </message>\n        <message name=\"UnableToReadBlob\">\n          unable to read blob\n        </message>\n        <message name=\"UnableToWriteBlob\">\n          unable to write blob\n        </message>\n        <message name=\"UnrecognizedImageFormat\">\n          unrecognized image format\n        </message>\n        <message name=\"ZeroLengthBlobNotPermitted\">\n          zero-length blob not permitted\n        </message>\n      </error>\n    </blob>\n    <cache>\n      <error>\n        <message name=\"CacheResourcesExhausted\">\n          cache resources exhausted\n        </message>\n        <message name=\"IncompatibleAPI\">\n          incompatible API\n        </message>\n        <message name=\"NoPixelsDefinedInCache\">\n          no pixels defined in cache\n        </message>\n        <message name=\"PixelCacheIsNotOpen\">\n          pixel cache is not open\n        </message>\n        <message name=\"PixelsAreNotAuthentic\">\n          pixels are not authentic\n        </message>\n        <message name=\"UnableToCloneCache\">\n          unable to clone cache\n        </message>\n        <message name=\"UnableToExtendCache\">\n          unable to extend cache\n        </message>\n        <message name=\"UnableToGetCacheNexus\">\n          unable to get cache nexus\n        </message>\n        <message name=\"UnableToOpenPixelCache\">\n          unable to open pixel cache\n        </message>\n        <message name=\"UnableToPersistPixelCache\">\n          unable to persist pixel cache\n        </message>\n        <message name=\"UnableToReadPixelCache\">\n          unable to read pixel cache\n        </message>\n        <message name=\"UnableToWritePixelCache\">\n          unable to write pixel cache\n        </message>\n      </error>\n      <fatalerror>\n        <message name=\"UnableToAcquireCacheView\">\n          unable to acquire cache view\n        </message>\n        <message name=\"UnableToExtendPixelCache\">\n          unable to extend pixel cache\n        </message>\n      </fatalerror>\n    </cache>\n    <coder>\n      <error>\n        <message name=\"ColormapTypeNotSupported\">\n          colormap type not supported\n        </message>\n        <message name=\"ColorspaceModelIsNotSupported\">\n          colorspace model is not supported\n        </message>\n        <message name=\"CompressNotSupported\">\n          compression not supported\n        </message>\n        <message name=\"DataEncodingSchemeIsNotSupported\">\n          data encoding scheme is not supported\n        </message>\n        <message name=\"DataStorageTypeIsNotSupported\">\n          data storage type is not supported\n        </message>\n        <message name=\"DeltaPNGNotSupported\">\n          delta-PNG is not supported\n        </message>\n        <message name=\"EncryptedWPGImageFileNotSupported\">\n          encrypted WPG image file not supported\n        </message>\n        <message name=\"FractalCompressNotSupported\">\n          fractal compression not supported\n        </message>\n        <message name=\"ImageColumnOrRowSizeIsNotSupported\">\n          image column or row size is not supported\n        </message>\n        <message name=\"ImageDoesNotHaveAClipMask\">\n          image does not have a clip mask\n        </message>\n        <message name=\"ImageDoesNotHaveAnAlphaChannel\">\n          image does not have an alpha channel\n        </message>\n        <message name=\"ImageDoesNotHaveAThumbnail\">\n          image does not have a EXIF thumbnail\n        </message>\n        <message name=\"ImageIsNotTiled\">\n          image is not tiled\n        </message>\n        <message name=\"IrregularChannelGeometryNotSupported\">\n          irregular channel geometry not supported\n        </message>\n        <message name=\"JNGCompressNotSupported\">\n          JNG compression not supported\n        </message>\n        <message name=\"JPEGCompressNotSupported\">\n          JPEG compression not supported\n        </message>\n        <message name=\"JPEGEmbeddingFailed\">\n          JPEG embedding failed\n        </message>\n        <message name=\"LocationTypeIsNotSupported\">\n          location type is not supported\n        </message>\n        <message name=\"MapStorageTypeIsNotSupported\">\n          map storage type is not supported\n        </message>\n        <message name=\"MultidimensionalMatricesAreNotSupported\">\n          multi-dimensional matrices are not supported\n        </message>\n        <message name=\"MultipleRecordListNotSupported\">\n          multiple record list not supported\n        </message>\n        <message name=\"NoBitmapOnClipboard\">\n          no bitmap on clipboard\n        </message>\n        <message name=\"NoAPP1DataIsAvailable\">\n          no APP1 data is available\n        </message>\n        <message name=\"No8BIMDataIsAvailable\">\n          no 8BIM data is available\n        </message>\n        <message name=\"NoColorProfileIsAvailable\">\n          no color profile is available\n        </message>\n        <message name=\"NoDataReturned\">\n          no data returned\n        </message>\n        <message name=\"NoImageVectorGraphics\">\n          no image vector graphics; unable to generate SVG\n        </message>\n        <message name=\"NoIPTCProfileAvailable\">\n          no IPTC profile available\n        </message>\n        <message name=\"NumberOfImagesIsNotSupported\">\n          number of images is not supported\n        </message>\n        <message name=\"OnlyContinuousTonePictureSupported\">\n          only continuous tone picture supported\n        </message>\n        <message name=\"OnlyLevelZerofilesSupported\">\n          only level zero files Supported\n        </message>\n        <message name=\"PNGCompressNotSupported\">\n          PNG compression not supported\n        </message>\n        <message name=\"RLECompressNotSupported\">\n          RLE compression not supported\n        </message>\n        <message name=\"UnableToCopyProfile\">\n          unable to copy profile\n        </message>\n        <message name=\"UnableToCreateBitmap\">\n          unable to create bitmap\n        </message>\n        <message name=\"UnableToCreateADC\">\n          unable to create a DC\n        </message>\n        <message name=\"UnableToDecompressImage\">\n          unable to decompress image\n        </message>\n        <message name=\"UnableToWriteMPEGParameters\">\n          unable to write MPEG parameters\n        </message>\n        <message name=\"UnableToZipCompressImage\">\n          unable to zip-compress image\n        </message>\n        <message name=\"ZIPCompressNotSupported\">\n          ZIP compression not supported\n        </message>\n      </error>\n      <warning>\n        <message name=\"ExifProfileSizeExceedsLimit\">\n          exif profile size exceeds limit and will be truncated\n        </message>\n        <message name=\"LosslessToLossyJPEGConversion\">\n          lossless to lossy JPEG conversion\n        </message>\n      </warning>\n    </coder>\n    <configure>\n      <error>\n        <message name=\"IncludeElementNestedTooDeeply\">\n          include element nested too deeply\n        </message>\n      </error>\n      <warning>\n        <message name=\"UnableToOpenConfigureFile\">\n          unable to access configure file\n        </message>\n        <message name=\"UnableToOpenModuleFile\">\n          unable to open module file\n        </message>\n      </warning>\n    </configure>\n    <corrupt>\n      <image>\n        <error>\n          <message name=\"AnErrorHasOccurredReadingFromFile\">\n            an error has occurred reading from file\n          </message>\n          <message name=\"AnErrorHasOccurredWritingToFile\">\n            an error has occurred writing to file\n          </message>\n          <message name=\"CipherSupportNotEnabled\">\n            cipher support not enabled\n          </message>\n          <message name=\"ColormapExceeds256Colors\">\n            colormap exceeded 256 colors\n          </message>\n          <message name=\"CorruptImage\">\n            corrupt image\n          </message>\n          <message name=\"FileFormatVersionMismatch\">\n            file format version mismatch\n          </message>\n          <message name=\"ImageDepthNotSupported\">\n            image depth not supported\n          </message>\n          <message name=\"ImageFileDoesNotContainAnyImageData\">\n            image file does not contain any image data\n          </message>\n          <message name=\"ImageTypeNotSupported\">\n            image type not supported\n          </message>\n          <message name=\"ImproperImageHeader\">\n            improper image header\n          </message>\n          <message name=\"InsufficientImageDataInFile\">\n            insufficient image data in file\n          </message>\n          <message name=\"InvalidColormapIndex\">\n            invalid colormap index\n          </message>\n          <message name=\"InvalidPixel\">\n            invalid pixel\n          </message>\n          <message name=\"LengthAndFilesizeDoNotMatch\">\n            length and filesize do not match\n          </message>\n          <message name=\"MaximumChannelsExceeded\">\n            maximum channels exceeded\n          </message>\n          <message name=\"MissingImageChannel\">\n            missing image channel\n          </message>\n          <message name=\"NegativeOrZeroImageSize\">\n            negative or zero image size\n          </message>\n          <message name=\"NonOS2HeaderSizeError\">\n            non OS2 BMP header size less than 40\n          </message>\n          <message name=\"NotEnoughPixelData\">\n            not enough pixel data\n          </message>\n          <message name=\"NotEnoughTiles\">\n            not enough tiles found in level\n          </message>\n          <message name=\"TooMuchImageDataInFile\">\n            too much image data in file\n          </message>\n          <message name=\"StaticPlanesValueNotEqualToOne\">\n            static planes value not equal to 1\n          </message>\n          <message name=\"UnableToReadExtensionBlock\">\n            unable to read extension block\n          </message>\n          <message name=\"UnableToReadImageHeader\">\n            unable to read image header\n          </message>\n          <message name=\"UnableToReadImageData\">\n            unable to read image data\n          </message>\n          <message name=\"UnableToRunlengthDecodeImage\">\n            unable to runlength decode image\n          </message>\n          <message name=\"UnableToUncompressImage\">\n            unable to uncompress image\n          </message>\n          <message name=\"UnexpectedEndOfFile\">\n            unexpected end-of-file\n          </message>\n          <message name=\"UnexpectedSamplingFactor\">\n            unexpected sampling factor\n          </message>\n          <message name=\"UnknownPatternType\">\n            unknown pattern type\n          </message>\n          <message name=\"UnrecognizedAlphaChannelOption\">\n            unrecognized alpha channel option\n          </message>\n          <message name=\"UnrecognizedBitsPerPixel\">\n            unrecognized bits per pixel\n          </message>\n          <message name=\"UnrecognizedImageCompression\">\n            unrecognized compression\n          </message>\n          <message name=\"UnrecognizedNumberOfColors\">\n            unrecognized number of colors\n          </message>\n        </error>\n        <fatalerror>\n          <message name=\"UnableToPersistKey\">\n            unable to persist key\n          </message>\n        </fatalerror>\n        <warning>\n          <message name=\"InsufficientImageDataInFile\">\n            insufficient image data in file\n          </message>\n          <message name=\"LengthAndFilesizeDoNotMatch\">\n            length and filesize do not match\n          </message>\n          <message name=\"SkipToSyncByte\">\n            corrupt PCD image, skipping to sync byte\n          </message>\n        </warning>\n      </image>\n    </corrupt>\n    <delegate>\n      <error>\n        <message name=\"DelegateFailed\">\n          delegate failed\n        </message>\n        <message name=\"FailedToComputeOutputSize\">\n          failed to compute output size\n        </message>\n        <message name=\"FailedToRenderFile\">\n          failed to render file\n        </message>\n        <message name=\"FailedToScanFile\">\n          failed to scan file\n        </message>\n        <message name=\"NoTagFound\">\n          no tag found\n        </message>\n        <message name=\"PCLDelegateFailed\">\n          PCL delegate failed\n        </message>\n        <message name=\"PostscriptDelegateFailed\">\n          Postscript delegate failed\n        </message>\n        <message name=\"UnableToCreateImage\">\n          unable to create image\n        </message>\n        <message name=\"UnableToDecodeImageFile\">\n          unable to decode image file\n        </message>\n        <message name=\"UnableToEncodeImageFile\">\n          unable to encode image file\n        </message>\n        <message name=\"UnableToInitializeFPXLibrary\">\n          unable to initialize FPX library\n        </message>\n        <message name=\"UnableToInitializeWMFLibrary\">\n          unable to initialize WMF library\n        </message>\n        <message name=\"UnableToManageJP2Stream\">\n          unable to manage JP2 stream\n        </message>\n        <message name=\"UnableToReadAspectRatio\">\n          unable to read aspect ratio\n        </message>\n        <message name=\"UnableToReadSummaryInfo\">\n          unable to read summary info\n        </message>\n        <message name=\"UnableToSetAffineMatrix\">\n          unable to set affine matrix\n        </message>\n        <message name=\"UnableToSetAspectRatio\">\n          unable to set aspect ratio\n        </message>\n        <message name=\"UnableToSetColorTwist\">\n          unable to set color twist\n        </message>\n        <message name=\"UnableToSetContrast\">\n          unable to set contrast\n        </message>\n        <message name=\"UnableToSetFilteringValue\">\n          unable to set filtering value\n        </message>\n        <message name=\"UnableToSetImageTitle\">\n          unable to set image title\n        </message>\n        <message name=\"UnableToSetJPEGLevel\">\n          unable to set JPEG level\n        </message>\n        <message name=\"UnableToSetRegionOfInterest\">\n          unable to set region of interest\n        </message>\n        <message name=\"UnableToSetSummaryInfo\">\n          unable to set summary info\n        </message>\n        <message name=\"UnableToWriteSVGFormat\">\n          unable to write SVG format\n        </message>\n        <message name=\"XPSDelegateFailed\">\n          XPS delegate failed\n        </message>\n      </error>\n    </delegate>\n    <draw>\n      <error>\n        <message name=\"AlreadyPushingPatternDefinition\">\n          already pushing pattern definition\n        </message>\n        <message name=\"NonconformingDrawingPrimitiveDefinition\">\n          non-conforming drawing primitive definition\n        </message>\n        <message name=\"NotARelativeURL\">\n          not a relative URL\n        </message>\n        <message name=\"NotCurrentlyPushingPatternDefinition\">\n          not currently pushing pattern definition\n        </message>\n        <message name=\"SegmentStackOverflow\">\n          segment stack overflow\n        </message>\n        <message name=\"TooManyBezierCoordinates\">\n          too many bezier coordinates\n        </message>\n        <message name=\"UnableToPrint\">\n          unable to print\n        </message>\n        <message name=\"UnbalancedGraphicContextPushPop\">\n          unbalanced graphic context push-pop\n        </message>\n        <message name=\"URLNotFound\">\n          URL not found\n        </message>\n      </error>\n    </draw>\n    <file>\n      <open>\n        <error>\n          <message name=\"AnErrorHasOccurredReadingFromFile\">\n            an error has occurred reading from file\n          </message>\n          <message name=\"UnableToCreateTemporaryFile\">\n            unable to create temporary file\n          </message>\n          <message name=\"UnableToOpenFile\">\n            unable to open file\n          </message>\n          <message name=\"UnableToWriteFile\">\n            unable to write file\n          </message>\n        </error>\n      </open>\n    </file>\n    <image>\n      <error>\n        <message name=\"AngleIsDiscontinuous\">\n          angle is discontinuous\n        </message>\n        <message name=\"ColormappedImageRequired\">\n          colormapped image required\n        </message>\n        <message name=\"ColorSeparatedImageRequired\">\n          color separated image required\n        </message>\n        <message name=\"ColorspaceColorProfileMismatch\">\n          color profile operates on another colorspace\n        </message>\n        <message name=\"ImageDepthNotSupported\">\n          image depth not supported\n        </message>\n        <message name=\"ImageMorphologyDiffers\">\n          image morphology differs\n        </message>\n        <message name=\"ImageListRequired\">\n          image list is required\n        </message>\n        <message name=\"ImageSizeDiffers\">\n          image size differs\n        </message>\n        <message name=\"ImagesTooDissimilar\">\n          images too dissimilar\n        </message>\n        <message name=\"LeftAndRightImageSizesDiffer\">\n          left and right image sizes differ\n        </message>\n        <message name=\"NegativeOrZeroImageSize\">\n          negative or zero image size\n        </message>\n        <message name=\"NoImagesWereFound\">\n          no images were found\n        </message>\n        <message name=\"NoImagesWereLoaded\">\n          no images were loaded\n        </message>\n        <message name=\"TooManyClusters\">\n          too many cluster\n        </message>\n        <message name=\"UnableToCreateColorTransform\">\n          unable to create color transform\n        </message>\n        <message name=\"WidthOrHeightExceedsLimit\">\n          width or height exceeds limit\n        </message>\n      </error>\n      <warning>\n        <message name=\"AssociateProfile\">\n          associate profile with image, a source and destination color profile required for transform\n        </message>\n      </warning>\n    </image>\n    <filter>\n      <error>\n        <message name=\"FilterFailed\">\n          filter failed\n        </message>\n      </error>\n    </filter>\n    <missing>\n      <delegate>\n        <error>\n          <message name=\"DelegateLibrarySupportNotBuiltIn\">\n            delegate library support not built-in\n          </message>\n          <message name=\"NoDecodeDelegateForThisImageFormat\">\n            no decode delegate for this image format\n          </message>\n          <message name=\"NoEncodeDelegateForThisImageFormat\">\n            no encode delegate for this image format\n          </message>\n        </error>\n        <warning>\n          <message name=\"DelegateLibrarySupportNotBuiltIn\">\n            delegate library support not built-in\n          </message>\n          <message name=\"FreeTypeLibraryIsNotAvailable\">\n            FreeType library is not available\n          </message>\n          <message name=\"LCMSLibraryIsNotAvailable\">\n            LCMS color profile library is not available\n          </message>\n          <message name=\"NoEncodeDelegateForThisImageFormat\">\n            no encode delegate for this image format\n          </message>\n        </warning>\n      </delegate>\n    </missing>\n    <module>\n      <error>\n        <message name=\"ImageCoderSignatureMismatch\">\n          image coder signature mismatch\n        </message>\n        <message name=\"ImageFilterSignatureMismatch\">\n          image filter signature mismatch\n        </message>\n        <message name=\"UnableToLoadModule\">\n          unable to load module\n        </message>\n        <message name=\"UnableToRegisterImageFormat\">\n          unable to register image format\n        </message>\n      </error>\n      <fatalerror>\n        <message name=\"UnableToInitializeModuleLoader\">\n          unable to initialize module loader\n        </message>\n      </fatalerror>\n      <warning>\n        <message name=\"UnableToCloseModule\">\n          unable to close module\n        </message>\n      </warning>\n    </module>\n    <option>\n      <error>\n        <message name=\"ClutImageRequired\">\n          color lookup table image required\n        </message>\n        <message name=\"CompositeImageRequired\">\n          composite image required\n        </message>\n        <message name=\"CurlyBrasesNestedTooDeeply\">\n          curly braces nested too deeply\n        </message>\n        <message name=\"DeprecatedOptionNoCode\">\n          option deprecated, unable to execute\n        </message>\n        <message name=\"DivideByZero\">\n          divide by zero\n        </message>\n        <message name=\"FrameIsLessThanImageSize\">\n          frame is less than image size\n        </message>\n        <message name=\"GeometryDimensionsAreZero\">\n          geometry dimensions are zero\n        </message>\n        <message name=\"GeometryDoesNotContainImage\">\n          geometry does not contain image\n        </message>\n        <message name=\"InterpretPropertyFailure\">\n          failure to interpret image property escapes\n        </message>\n        <message name=\"InvalidArgument\">\n          invalid argument for option\n        </message>\n        <message name=\"InvalidUseOfOption\">\n          invalid use of option\n        </message>\n        <message name=\"InvalidGeometry\">\n          invalid geometry\n        </message>\n        <message name=\"InvalidImageIndex\">\n          invalid image index\n        </message>\n        <message name=\"InvalidNumberList\">\n          invalid list of numbers\n        </message>\n        <message name=\"InvalidSetting\">\n          invalid setting\n        </message>\n        <message name=\"ImagesAreNotTheSameSize\">\n          images are not the same size\n        </message>\n        <message name=\"ImageSizeMustExceedBevelWidth\">\n          size must exceed bevel width\n        </message>\n        <message name=\"ImageWidthsOrHeightsDiffer\">\n          image widths or heights differ\n        </message>\n        <message name=\"KernelWidthMustBeAnOddNumber\">\n          kernel width must be an odd number\n        </message>\n        <message name=\"MapImageRequired\">\n          map image required\n        </message>\n        <message name=\"MissingArgument\">\n          missing required argument\n        </message>\n        <message name=\"MissingAnImageFilename\">\n        <!-- FUTURE: Depreciate using MissingOutputFilename -->\n          missing an image filename\n        </message>\n        <message name=\"MissingExpression\">\n          missing expression\n        </message>\n        <message name=\"MissingNullSeparator\">\n          missing Null Image List Separator\n        </message>\n        <message name=\"MissingOutputFilename\">\n          missing output filename\n        </message>\n        <message name=\"MustSpecifyAnImageName\">\n          must specify an image name\n        </message>\n        <message name=\"MustSpecifyImageSize\">\n          must specify image size\n        </message>\n        <message name=\"NoBlobDefined\">\n          no Binary Large OBjects defined\n        </message>\n        <message name=\"NoClipPathDefined\">\n          no clip path defined\n        </message>\n        <message name=\"NoImagesForWrite\">\n          no images for write\n        </message>\n        <message name=\"NoImagesFound\">\n          no images found for operation\n        </message>\n        <message name=\"NoImagesDefined\">\n          no images defined\n        </message>\n        <message name=\"NoImageVectorGraphics\">\n          no image vector graphics\n        </message>\n        <message name=\"NoSuchImage\">\n          no such image\n        </message>\n        <message name=\"NoSuchImageChannel\">\n          no such image channel\n        </message>\n        <message name=\"NoSuchOption\">\n          no such option\n        </message>\n        <message name=\"NonZeroWidthAndHeightRequired\">\n          non-zero width and height required\n        </message>\n        <message name=\"NotEnoughParameters\">\n          not enough parameters\n        </message>\n        <message name=\"ParenthesisNestedTooDeeply\">\n          parenthesis nested too deeply\n        </message>\n        <message name=\"ReferenceImageRequired\">\n          reference image required\n        </message>\n        <message name=\"ReferenceIsNotMyType\">\n          reference is not my type\n        </message>\n        <message name=\"SetReadOnlyProperty\">\n          attempt to set read-only property\n        </message>\n        <message name=\"SteganoImageRequired\">\n          stegano image required\n        </message>\n        <message name=\"StereoImageRequired\">\n          stereo image required\n        </message>\n        <message name=\"SubimageSpecificationReturnsNoImages\">\n          subimage specification returns no images\n        </message>\n        <message name=\"TwoOrMoreImagesRequired\">\n          two or more images required\n        </message>\n        <message name=\"UnableToAccessPath\">\n          unable to access file path\n        </message>\n        <message name=\"UnableToOpenFile\">\n          unable to open file\n        </message>\n        <message name=\"UnableToParseExpression\">\n          unable to parse expression\n        </message>\n        <message name=\"UnableToParseKernel\">\n          unable to parse kernel string\n        </message>\n        <message name=\"UnbalancedBraces\">\n          unbalanced braces\n        </message>\n        <message name=\"UnbalancedParenthesis\">\n          unbalanced parenthesis\n        </message>\n        <message name=\"UnrecognizedAttribute\">\n          unrecognized attribute\n        </message>\n        <message name=\"UnrecognizedChannelType\">\n          unrecognized channel type\n        </message>\n        <message name=\"UnrecognizedColor\">\n          unrecognized color\n        </message>\n        <message name=\"UnrecognizedColorspace\">\n          unrecognized colorspace\n        </message>\n        <message name=\"UnrecognizedComposeOperator\">\n          unrecognized compose operator\n        </message>\n        <message name=\"UnrecognizedCompressType\">\n          unrecognized compress type\n        </message>\n        <message name=\"UnrecognizedDirectionType\">\n          unrecognized direction type\n        </message>\n        <message name=\"UnrecognizedDisposeMethod\">\n          unrecognized dispose method\n        </message>\n        <message name=\"UnrecognizedDistortMethod\">\n          unrecognized distortion method\n        </message>\n        <message name=\"UnrecognizedDitherMethod\">\n          unrecognized dither method\n        </message>\n        <message name=\"UnrecognizedEndianType\">\n          unrecognized endian type\n        </message>\n        <message name=\"UnrecognizedElement\">\n          unrecognized element\n        </message>\n        <message name=\"UnrecognizedEvaluateOperator\">\n          unrecognized evaluate operator\n        </message>\n        <message name=\"UnrecognizedEventType\">\n          unrecognized event type\n        </message>\n        <message name=\"UnrecognizedFunction\">\n          unrecognized function\n        </message>\n        <message name=\"UnrecognizedGravityType\">\n          unrecognized gravity type\n        </message>\n        <message name=\"UnrecognizedImageCompression\">\n          unrecognized image compression\n        </message>\n        <message name=\"UnrecognizedImageFilter\">\n          unrecognized image filter\n        </message>\n        <message name=\"UnrecognizedImageFormat\">\n          unrecognized image format\n        </message>\n        <message name=\"UnrecognizedImageMode\">\n          unrecognized image mode\n        </message>\n        <message name=\"UnrecognizedImageOrientation\">\n          unrecognized image orientation\n        </message>\n        <message name=\"UnrecognizedImageType\">\n          unrecognized image type\n        </message>\n        <message name=\"UnrecognizedIntentType\">\n          unrecognized intent type\n        </message>\n        <message name=\"UnrecognizedInterlaceType\">\n          unrecognized interlace type\n        </message>\n        <message name=\"UnrecognizedInterpolateMethod\">\n          unrecognized interpolate method\n        </message>\n        <message name=\"UnrecognizedKernelType\">\n          unrecognized kernel type\n        </message>\n        <message name=\"UnrecognizedListType\">\n          unrecognized list type\n        </message>\n        <message name=\"UnrecognizedMetricType\">\n          unrecognized metric type\n        </message>\n        <message name=\"UnrecognizedModeType\">\n          unrecognized mode type\n        </message>\n        <message name=\"UnrecognizedMorphologyMethod\">\n          unrecognized morphology method\n        </message>\n        <message name=\"UnrecognizedOption\">\n          unrecognized option\n        </message>\n        <message name=\"UnrecognizedPerlMagickMethod\">\n          unrecognized PerlMagick method\n        </message>\n        <message name=\"UnrecognizedPixelMap\">\n          unrecognized pixel map\n        </message>\n        <message name=\"UnrecognizedPreviewType\">\n          unrecognized preview type\n        </message>\n        <message name=\"UnrecognizedResourceType\">\n          unrecognized resource type\n        </message>\n        <message name=\"UnrecognizedSparseColorMethod\">\n          unrecognized sparse color method\n        </message>\n        <message name=\"UnrecognizedStorageType\">\n          unrecognized storage type\n        </message>\n        <message name=\"UnrecognizedStretchType\">\n          unrecognized stretch type\n        </message>\n        <message name=\"UnrecognizedStyleType\">\n          unrecognized style type\n        </message>\n        <message name=\"UnrecognizedType\">\n          unrecognized type\n        </message>\n        <message name=\"UnrecognizedUnitsType\">\n          unrecognized units type\n        </message>\n        <message name=\"UnrecognizedValidateType\">\n          unrecognized validate type\n        </message>\n        <message name=\"UnrecognizedVirtualPixelMethod\">\n          unrecognized virtual pixel method\n        </message>\n        <message name=\"XmlInvalidAttribute\">\n          XML invalid attribute\n        </message>\n        <message name=\"XmlInvalidContent\">\n          XML invalid content\n        </message>\n        <message name=\"XmlMissingAttribute\">\n          XML missing required attribute\n        </message>\n        <message name=\"XmlMissingContent\">\n          XML missing required content\n        </message>\n        <message name=\"XmlMissingElement\">\n          XML missing required element\n        </message>\n      </error>\n      <fatalerror>\n        <message name=\"FilenameTruncated\">\n          image filename truncated\n        </message>\n        <message name=\"MissingAnImageFilename\">\n          missing an image filename\n        </message>\n        <message name=\"ScriptIsBinary\">\n          script is binary\n        </message>\n        <message name=\"ScriptTokenMemoryFailed\">\n          script token too big\n        </message>\n        <message name=\"ScriptUnbalancedQuotes\">\n          script token with unbalanced quotes\n        </message>\n        <message name=\"UnableToOpenScript\">\n          unable to open script\n        </message>\n        <message name=\"UnrecognizedColormapType\">\n          unrecognized colormap type\n        </message>\n        <message name=\"UnrecognizedColorspaceType\">\n          unrecognized colorspace type\n        </message>\n        <message name=\"UnrecognizedEndianType\">\n          unrecognized endian type\n        </message>\n        <message name=\"UnrecognizedImageCompressionType\">\n          unrecognized compression type\n        </message>\n        <message name=\"UnrecognizedImageType\">\n          unrecognized image type\n        </message>\n        <message name=\"UnrecognizedInterlaceType\">\n          unrecognized interlace type\n        </message>\n        <message name=\"UnrecognizedListType\">\n          unrecognized list type\n        </message>\n        <message name=\"UnrecognizedDisposeMethod\">\n          unrecognized dispose method\n        </message>\n        <message name=\"UnrecognizedOption\">\n          unrecognized option\n        </message>\n        <message name=\"UnrecognizedResourceType\">\n          unrecognized resource type\n        </message>\n        <message name=\"UnrecognizedVirtualPixelMethod\">\n          unrecognized virtual pixel method\n        </message>\n      </fatalerror>\n      <warning>\n        <message name=\"ReplacedOption\">\n          option has been replaced\n        </message>\n        <message name=\"GeometryDoesNotContainImage\">\n          geometry does not contain image\n        </message>\n        <message name=\"InterpretPropertyFailure\">\n          failure in interpret image property escapes\n        </message>\n        <message name=\"InvalidSetting\">\n          invalid setting\n        </message>\n        <message name=\"NoImageForProperty\">\n          no image to apply a property\n        </message>\n        <message name=\"NoImageInfoForProperty\">\n          no image info (wand) to apply a property\n        </message>\n        <message name=\"NoSuchElement\">\n          no such element in list\n        </message>\n        <message name=\"UnknownImageProperty\">\n          unknown image property\n        </message>\n        <message name=\"UnrecognizedColor\">\n          unrecognized color\n        </message>\n        <message name=\"ZeroTimeAnimation\">\n          animation only contains zero time delays\n        </message>\n      </warning>\n    </option>\n    <policy>\n      <error>\n        <message name=\"NotAuthorized\">\n          not authorized\n        </message>\n      </error>\n    </policy>\n    <registry>\n      <error>\n        <message name=\"UnableToGetRegistryID\">\n          unable to get registry ID\n        </message>\n        <message name=\"UnableToSetRegistry\">\n          unable to set registry\n        </message>\n      </error>\n    </registry>\n    <resource>\n      <limit>\n        <error>\n          <message name=\"PixelCacheAllocationFailed\">\n            pixel cache allocation failed\n          </message>\n          <message name=\"MemoryAllocationFailed\">\n            memory allocation failed\n          </message>\n          <message name=\"TooManyObjects\">\n            too many objects\n          </message>\n          <message name=\"UnableToAcquireString\">\n            unable to acquire string\n          </message>\n          <message name=\"UnableToAllocateColormap\">\n            unable to allocate colormap\n          </message>\n          <message name=\"UnableToConvertFont\">\n            unable to convert font\n          </message>\n          <message name=\"UnableToCreateColormap\">\n            unable to create colormap\n          </message>\n          <message name=\"UnableToDitherImage\">\n            unable to dither image\n          </message>\n          <message name=\"UnableToClonePackageInfo\">\n            unable to clone package info\n          </message>\n          <message name=\"UnableToGetPackageInfo\">\n            unable to get package info\n          </message>\n        </error>\n        <fatalerror>\n          <message name=\"TimeLimitExceeded\">\n            time limit exceeded\n          </message>\n          <message name=\"UnableToAllocateDashPattern\">\n            unable to allocate dash pattern\n          </message>\n          <message name=\"UnableToAllocateDerivatives\">\n            unable to allocate derivates\n          </message>\n          <message name=\"UnableToAllocateGammaMap\">\n            unable to allocate gamma map\n          </message>\n          <message name=\"UnableToAllocateImage\">\n            unable to allocate image\n          </message>\n          <message name=\"UnableToAllocateImagePixels\">\n            unable to allocate image pixels\n          </message>\n          <message name=\"UnableToDestroySemaphore\">\n            unable to destroy semaphore\n          </message>\n          <message name=\"UnableToInstantiateSemaphore\">\n            unable to instantiate semaphore\n          </message>\n          <message name=\"UnableToAcquireString\">\n            unable to allocate string\n          </message>\n          <message name=\"MemoryAllocationFailed\">\n            Memory allocation failed\n          </message>\n          <message name=\"UnableToConcatenateString\">\n            unable to concatenate string\n          </message>\n          <message name=\"UnableToConvertText\">\n            unable to convert text\n          </message>\n          <message name=\"UnableToCreateColormap\">\n            unable to create colormap\n          </message>\n          <message name=\"UnableToCloneImage\">\n            unable to clone image\n          </message>\n          <message name=\"UnableToDisplayImage\">\n            unable to display image\n          </message>\n          <message name=\"UnableToEscapeString\">\n            unable to escape string\n          </message>\n          <message name=\"UnableToInterpretMSLImage\">\n            unable to interpret MSL image\n          </message>\n          <message name=\"UnableToLockSemaphore\">\n            unable to lock semaphore\n          </message>\n          <message name=\"UnableToUnlockSemaphore\">\n            unable to unlock semaphore\n          </message>\n        </fatalerror>\n        <warning>\n          <message name=\"MemoryAllocationFailed\">\n            memory allocation failed\n          </message>\n        </warning>\n      </limit>\n    </resource>\n    <type>\n      <error>\n        <message name=\"FontSubstitutionRequired\">\n          font substitution required\n        </message>\n        <message name=\"UnableToGetTypeMetrics\">\n          unable to get type metrics\n        </message>\n        <message name=\"UnableToInitializeFreetypeLibrary\">\n          unable to initialize freetype library\n        </message>\n        <message name=\"UnableToReadFont\">\n          unable to read font\n        </message>\n        <message name=\"UnrecognizedFontEncoding\">\n          unrecognized font encoding\n        </message>\n      </error>\n      <warning>\n        <message name=\"UnableToReadFont\">\n          unable to read font\n        </message>\n      </warning>\n    </type>\n    <stream>\n      <error>\n        <message name=\"ImageDoesNotContainTheStreamGeometry\">\n          image does not contain the stream geometry\n        </message>\n        <message name=\"NoStreamHandlerIsDefined\">\n          no stream handler is defined\n        </message>\n        <message name=\"PixelCacheIsNotOpen\">\n          pixel cache is not open\n        </message>\n      </error>\n    </stream>\n    <wand>\n      <error>\n        <message name=\"InvalidColormapIndex\">\n          invalid colormap index\n        </message>\n        <message name=\"ZeroRegionSize\">\n          zero region size\n        </message>\n        <message name=\"UnableToOpenFile\">\n          unable to open file\n        </message>\n        <message name=\"QuantumDepthMismatch\">\n          wand quantum depth does not match that of the core API\n        </message>\n        <message name=\"ContainsNoImages\">\n          wand contains no images\n        </message>\n        <message name=\"ContainsNoIterators\">\n          wand contains no iterators\n        </message>\n      </error>\n    </wand>\n    <xserver>\n      <error>\n        <message name=\"ColorIsNotKnownToServer\">\n          color is not known to server\n        </message>\n        <message name=\"NoWindowWithSpecifiedIDExists\">\n          no window with specified ID exists\n        </message>\n        <message name=\"StandardColormapIsNotInitialized\">\n          standard Colormap is not initialized\n        </message>\n        <message name=\"UnableToConnectToRemoteDisplay\">\n          unable to connect to remote display\n        </message>\n        <message name=\"UnableToCreateBitmap\">\n          unable to create bitmap\n        </message>\n        <message name=\"UnableToCreateColormap\">\n          unable to create colormap\n        </message>\n        <message name=\"UnableToCreatePixmap\">\n          unable to create pixmap\n        </message>\n        <message name=\"UnableToCreateProperty\">\n          unable to create property\n        </message>\n        <message name=\"UnableToCreateStandardColormap\">\n          unable to create standard colormap\n        </message>\n        <message name=\"UnableToDisplayImageInfo\">\n          unable to display image info\n        </message>\n        <message name=\"UnableToGetProperty\">\n          unable to get property\n        </message>\n        <message name=\"UnableToGetStandardColormap\">\n          unable to get Standard Colormap\n        </message>\n        <message name=\"UnableToGetVisual\">\n          unable to get visual\n        </message>\n        <message name=\"UnableToGrabMouse\">\n          unable to grab mouse\n        </message>\n        <message name=\"UnableToLoadFont\">\n          unable to load font\n        </message>\n        <message name=\"UnableToMatchVisualToStandardColormap\">\n          unable to match visual to Standard Colormap\n        </message>\n        <message name=\"UnableToOpenXServer\">\n          unable to open X server\n        </message>\n        <message name=\"UnableToReadXWindowAttributes\">\n          unable to read X window attributes\n        </message>\n        <message name=\"UnableToReadXWindowImage\">\n          unable to read X window image\n        </message>\n        <message name=\"UnrecognizedColormapType\">\n          unrecognized colormap type\n        </message>\n        <message name=\"UnrecognizedGravityType\">\n          unrecognized gravity type\n        </message>\n        <message name=\"UnrecognizedVisualSpecifier\">\n          unrecognized visual specifier\n        </message>\n      </error>\n      <fatalerror>\n        <message name=\"UnableToCreateCursor\">\n          unable to create X cursor\n        </message>\n        <message name=\"UnableToCreateGraphicContext\">\n          unable to create graphic context\n        </message>\n        <message name=\"UnableToCreateStandardColormap\">\n          unable to create standard colormap\n        </message>\n        <message name=\"UnableToCreateTextProperty\">\n          unable to create text property\n        </message>\n        <message name=\"UnableToCreateXWindow\">\n          unable to create X window\n        </message>\n        <message name=\"UnableToCreateXImage\">\n          unable to create X image\n        </message>\n        <message name=\"UnableToCreateXPixmap\">\n          unable to create X pixmap\n        </message>\n        <message name=\"UnableToDisplayImage\">\n          unable to display image\n        </message>\n        <message name=\"UnableToGetVisual\">\n          unable to get visual\n        </message>\n        <message name=\"UnableToGetPixelInfo\">\n          unable to get pixel info\n        </message>\n        <message name=\"UnableToLoadFont\">\n          unable to load font\n        </message>\n        <message name=\"UnableToMakeXWindow\">\n          unable to make X window\n        </message>\n        <message name=\"UnableToOpenXServer\">\n          unable to open X server\n        </message>\n        <message name=\"UnableToViewFonts\">\n          unable to view fonts\n        </message>\n      </fatalerror>\n      <warning>\n        <message name=\"UsingDefaultVisual\">\n          using default visual\n        </message>\n        <message name=\"UnableToGetVisual\">\n          unable to get visual\n        </message>\n      </warning>\n    </xserver>\n  </exception>\n  <monitor>\n    <AddNoise>\n      <message name=\"Image\">\n        add noise to image\n      </message>\n    </AddNoise>\n    <Append>\n      <message name=\"Image\">\n        append image sequence\n      </message>\n    </Append>\n    <assign>\n      <message name=\"Image\">\n        assign image colors\n      </message>\n    </assign>\n    <Average>\n      <message name=\"Image\">\n        average image sequence\n      </message>\n    </Average>\n    <Chop>\n      <message name=\"Image\">\n        chop image\n      </message>\n    </Chop>\n    <Classify>\n      <message name=\"Image\">\n        classify image colors\n      </message>\n    </Classify>\n    <ColorReplace>\n      <message name=\"Image\">\n        replace color in image\n      </message>\n    </ColorReplace>\n    <Colorize>\n      <message name=\"Image\">\n        colorize image\n      </message>\n    </Colorize>\n    <Combine>\n      <message name=\"Image\">\n        combine image\n      </message>\n    </Combine>\n    <ContrastStretch>\n      <message name=\"Image\">\n         contrast-stretch image\n      </message>\n    </ContrastStretch>\n    <Convolve>\n      <message name=\"Image\">\n        convolve image\n      </message>\n    </Convolve>\n    <Crop>\n      <message name=\"Image\">\n        crop image\n      </message>\n    </Crop>\n    <Decode>\n      <message name=\"Image\">\n        decode image\n      </message>\n    </Decode>\n    <Despeckle>\n      <message name=\"Image\">\n        despeckle image\n      </message>\n    </Despeckle>\n    <Distort>\n      <message name=\"Image\">\n        distort image\n      </message>\n    </Distort>\n    <Dither>\n      <message name=\"Image\">\n        dither image colors\n      </message>\n    </Dither>\n    <DullContrast>\n      <message name=\"Image\">\n        dull image contrast\n      </message>\n    </DullContrast>\n    <Encode>\n      <message name=\"Image\">\n        encode image\n      </message>\n    </Encode>\n    <Equalize>\n      <message name=\"Image\">\n        equalize image\n      </message>\n    </Equalize>\n    <Flip>\n      <message name=\"Image\">\n        flip image\n      </message>\n    </Flip>\n    <Flop>\n      <message name=\"Image\">\n        flop image\n      </message>\n    </Flop>\n    <Frame>\n      <message name=\"Image\">\n        add frame to image\n      </message>\n    </Frame>\n    <Fx>\n      <message name=\"Image\">\n        fx image\n      </message>\n    </Fx>\n    <GammaCorrect>\n      <message name=\"Image\">\n        gamma correct image\n      </message>\n    </GammaCorrect>\n    <Histogram>\n      <message name=\"Image\">\n        compute image histogram\n      </message>\n    </Histogram>\n    <Implode>\n      <message name=\"Image\">\n        implode image\n      </message>\n    </Implode>\n    <Level>\n      <message name=\"Image\">\n        level image\n      </message>\n    </Level>\n    <Load>\n      <message name=\"Image\">\n        load image\n      </message>\n      <message name=\"Images\">\n        load images\n      </message>\n    </Load>\n    <Magnfiy>\n      <message name=\"Image\">\n        magnfiy image\n      </message>\n    </Magnfiy>\n    <MedianFilter>\n      <message name=\"Image\">\n        filter image with neighborhood ranking\n      </message>\n    </MedianFilter>\n    <Minify>\n      <message name=\"Image\">\n        minify image\n      </message>\n    </Minify>\n    <Modulate>\n      <message name=\"Image\">\n        modulate image\n      </message>\n    </Modulate>\n    <Mogrify>\n      <message name=\"Image\">\n        mogrify image\n      </message>\n    </Mogrify>\n    <Montage>\n      <message name=\"Image\">\n        montage image\n      </message>\n    </Montage>\n    <Morph>\n      <message name=\"Image\">\n        morph image sequence\n      </message>\n    </Morph>\n    <Mosaic>\n      <message name=\"Image\">\n        mosaic image\n      </message>\n    </Mosaic>\n    <Negate>\n      <message name=\"Image\">\n        negate image\n      </message>\n    </Negate>\n    <OilPaint>\n      <message name=\"Image\">\n        oil paint image\n      </message>\n    </OilPaint>\n    <Opaque>\n      <message name=\"Image\">\n        set opaque color in image\n      </message>\n    </Opaque>\n    <Plasma>\n      <message name=\"Image\">\n        plasma image\n      </message>\n    </Plasma>\n    <Preview>\n      <message name=\"Image\">\n        preview image\n      </message>\n    </Preview>\n    <Raise>\n      <message name=\"Image\">\n        raise image\n      </message>\n    </Raise>\n    <Recolor>\n      <message name=\"Image\">\n        recolor color image\n      </message>\n    </Recolor>\n    <Reduce>\n      <message name=\"Image\">\n        reduce image colors\n      </message>\n    </Reduce>\n    <ReduceNoise>\n      <message name=\"Image\">\n        reduce the image noise\n      </message>\n    </ReduceNoise>\n    <Render>\n      <message name=\"Image\">\n        render image\n      </message>\n    </Render>\n    <Resize>\n      <message name=\"Image\">\n        resize image\n      </message>\n    </Resize>\n    <RGBTransform>\n      <message name=\"Image\">\n        RGB transform image\n      </message>\n    </RGBTransform>\n    <Roll>\n      <message name=\"Image\">\n        roll image\n      </message>\n    </Roll>\n    <Rotate>\n      <message name=\"Image\">\n        rotate image\n      </message>\n    </Rotate>\n    <Sample>\n      <message name=\"Image\">\n        sample image\n      </message>\n    </Sample>\n    <Save>\n      <message name=\"Image\">\n        save image\n      </message>\n      <message name=\"Images\">\n        save images\n      </message>\n    </Save>\n    <Scale>\n      <message name=\"Image\">\n        scale image\n      </message>\n    </Scale>\n    <Segment>\n      <message name=\"Image\">\n        segment image\n      </message>\n    </Segment>\n    <Separate>\n      <message name=\"Image\">\n        extract a channel from image\n      </message>\n    </Separate>\n    <SepiaTone>\n      <message name=\"Image\">\n        sepia-tone image\n      </message>\n    </SepiaTone>\n    <Shade>\n      <message name=\"Image\">\n        shade image\n      </message>\n    </Shade>\n    <Sharpen>\n      <message name=\"Image\">\n        sharpen image\n      </message>\n    </Sharpen>\n    <SharpenContrast>\n      <message name=\"Image\">\n        sharpen image contrast\n      </message>\n    </SharpenContrast>\n    <SigmoidalContrast>\n      <message name=\"Image\">\n        sigmoidal contrast image\n      </message>\n    </SigmoidalContrast>\n    <Solarize>\n      <message name=\"Image\">\n        solarize image\n      </message>\n    </Solarize>\n    <Splice>\n      <message name=\"Image\">\n        splice image\n      </message>\n    </Splice>\n    <Spread>\n      <message name=\"Image\">\n        spread image\n      </message>\n    </Spread>\n    <Stegano>\n      <message name=\"Image\">\n        stegano image\n      </message>\n    </Stegano>\n    <Stereo>\n      <message name=\"Image\">\n        stereo image\n      </message>\n    </Stereo>\n    <Swirl>\n      <message name=\"Image\">\n        swirl image\n      </message>\n    </Swirl>\n    <Texture>\n      <message name=\"Image\">\n        texture image\n      </message>\n    </Texture>\n    <Threshold>\n      <message name=\"Image\">\n        threshold image\n      </message>\n    </Threshold>\n    <Tile>\n      <message name=\"Image\">\n        tile image\n      </message>\n    </Tile>\n    <Tint>\n      <message name=\"Image\">\n        tint image\n      </message>\n    </Tint>\n    <TransformRGB>\n      <message name=\"Image\">\n        transform RGB image\n      </message>\n    </TransformRGB>\n    <Transparent>\n      <message name=\"Image\">\n        set transparent color in image\n      </message>\n    </Transparent>\n    <Wave>\n      <message name=\"Image\">\n        wave image\n      </message>\n    </Wave>\n    <Write>\n      <message name=\"Image\">\n        write image\n      </message>\n    </Write>\n    <XShear>\n      <message name=\"Image\">\n        x shear image\n      </message>\n    </XShear>\n    <YShear>\n      <message name=\"Image\">\n        y shear image\n      </message>\n    </YShear>\n  </monitor>\n</locale>\n"], "filenames": ["coders/jpeg.c", "config/english.xml"], "buggy_code_start_loc": [1919, 207], "buggy_code_end_loc": [2682, 207], "fixing_code_start_loc": [1919, 208], "fixing_code_end_loc": [2688, 211], "type": "CWE-119", "message": "Buffer overflow in the WriteProfile function in coders/jpeg.c in ImageMagick before 6.9.5-6 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted file.", "other": {"cve": {"id": "CVE-2016-10052", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-23T17:59:00.517", "lastModified": "2020-11-16T19:57:07.260", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Buffer overflow in the WriteProfile function in coders/jpeg.c in ImageMagick before 6.9.5-6 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted file."}, {"lang": "es", "value": "Desbordamiento del b\u00fafer en la funci\u00f3n WriteProfile en coders/jpeg.c en ImageMagick en versiones anteriores a 6.9.5-6 permite atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda de la aplicaci\u00f3n) u otro impacto no especificado a trav\u00e9s de un archivo manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.5-5", "matchCriteriaId": "C8A689D3-2067-48A5-8F37-0DA5F3481727"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2017-02/msg00028.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2017-02/msg00031.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/12/26/9", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95181", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1410459", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/13267a10845a8dadabed63072b537f050cec6daa", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/9e187b73a8a1290bb0e1a1c878f8be1917aa8742", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/13267a10845a8dadabed63072b537f050cec6daa"}}