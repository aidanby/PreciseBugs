{"buggy_code": ["# -*- coding: utf-8 -*-\nfrom __future__ import absolute_import\nimport datetime\nfrom django.conf import settings\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.contrib.sites.models import Site\nfrom django.http import HttpResponse\nfrom django.test import TestCase\nfrom django.utils.timezone import now as timezone_now\n\nfrom mock import patch, MagicMock\nfrom zerver.lib.test_helpers import MockLDAP\n\nfrom confirmation.models import Confirmation\n\nfrom zilencer.models import Deployment\n\nfrom zerver.forms import HomepageForm, WRONG_SUBDOMAIN_ERROR\nfrom zerver.lib.actions import do_change_password\nfrom zerver.views.auth import login_or_register_remote_user\nfrom zerver.views.invite import get_invitee_emails_set\nfrom zerver.views.registration import confirmation_key, \\\n    redirect_and_log_into_subdomain, send_registration_completion_email\n\nfrom zerver.models import (\n    get_realm, get_prereg_user_by_email, get_user,\n    get_unique_open_realm, completely_open, get_recipient,\n    PreregistrationUser, Realm, RealmDomain, Recipient, Message,\n    Referral, ScheduledJob, UserProfile, UserMessage,\n    Stream, Subscription, ScheduledJob, flush_per_request_caches\n)\nfrom zerver.lib.actions import (\n    set_default_streams,\n    do_change_is_admin,\n    get_stream,\n    do_create_realm,\n)\nfrom zerver.lib.send_email import display_email, send_email, send_future_email\nfrom zerver.lib.initial_password import initial_password\nfrom zerver.lib.actions import (\n    do_deactivate_realm,\n    do_set_realm_property,\n    add_new_user_history,\n)\nfrom zerver.lib.mobile_auth_otp import xor_hex_strings, ascii_to_hex, \\\n    otp_encrypt_api_key, is_valid_otp, hex_to_ascii, otp_decrypt_api_key\nfrom zerver.lib.notifications import enqueue_welcome_emails, \\\n    one_click_unsubscribe_link\nfrom zerver.lib.test_helpers import find_pattern_in_email, find_key_by_email, queries_captured, \\\n    HostRequestMock, unsign_subdomain_cookie, POSTRequestMock\nfrom zerver.lib.test_classes import (\n    ZulipTestCase,\n)\nfrom zerver.lib.test_runner import slow\nfrom zerver.lib.sessions import get_session_dict_user\nfrom zerver.context_processors import common_context\n\nfrom collections import defaultdict\nimport re\nimport ujson\n\nfrom typing import Any, Dict, List, Optional, Set\n\nfrom six.moves import urllib\nfrom six.moves import range\nfrom typing import Any, Text\nimport os\n\nclass RedirectAndLogIntoSubdomainTestCase(ZulipTestCase):\n    def test_cookie_data(self):\n        # type: () -> None\n        realm = Realm.objects.all().first()\n        name = 'Hamlet'\n        email = self.example_email(\"hamlet\")\n        response = redirect_and_log_into_subdomain(realm, name, email)\n        data = unsign_subdomain_cookie(response)\n        self.assertDictEqual(data, {'name': name, 'email': email,\n                                    'subdomain': realm.subdomain,\n                                    'is_signup': False})\n\n        response = redirect_and_log_into_subdomain(realm, name, email,\n                                                   is_signup=True)\n        data = unsign_subdomain_cookie(response)\n        self.assertDictEqual(data, {'name': name, 'email': email,\n                                    'subdomain': realm.subdomain,\n                                    'is_signup': True})\n\nclass AddNewUserHistoryTest(ZulipTestCase):\n    def test_add_new_user_history_race(self):\n        # type: () -> None\n        \"\"\"Sends a message during user creation\"\"\"\n        # Create a user who hasn't had historical messages added\n        stream_dict = {\n            \"Denmark\": {\"description\": \"A Scandinavian country\", \"invite_only\": False},\n            \"Verona\": {\"description\": \"A city in Italy\", \"invite_only\": False}\n        }  # type: Dict[Text, Dict[Text, Any]]\n        realm = get_realm('zulip')\n        set_default_streams(realm, stream_dict)\n        with patch(\"zerver.lib.actions.add_new_user_history\"):\n            self.register(self.nonreg_email('test'), \"test\")\n        user_profile = self.nonreg_user('test')\n\n        subs = Subscription.objects.select_related(\"recipient\").filter(\n            user_profile=user_profile, recipient__type=Recipient.STREAM)\n        streams = Stream.objects.filter(id__in=[sub.recipient.type_id for sub in subs])\n        self.send_message(self.example_email('hamlet'), streams[0].name, Recipient.STREAM, \"test\")\n        add_new_user_history(user_profile, streams)\n\nclass PasswordResetTest(ZulipTestCase):\n    \"\"\"\n    Log in, reset password, log out, log in with new password.\n    \"\"\"\n\n    def test_password_reset(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        old_password = initial_password(email)\n\n        self.login(email)\n\n        # test password reset template\n        result = self.client_get('/accounts/password/reset/')\n        self.assert_in_response('Reset your password', result)\n\n        # start the password reset process by supplying an email address\n        result = self.client_post('/accounts/password/reset/', {'email': email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email to finish the process.\", result)\n\n        # Visit the password reset link.\n        password_reset_url = self.get_confirmation_url_from_outbox(email, \"(\\S+)\")\n        result = self.client_get(password_reset_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Reset your password\n        result = self.client_post(password_reset_url,\n                                  {'new_password1': 'new_password',\n                                   'new_password2': 'new_password'})\n\n        # password reset succeeded\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/password/done/\"))\n\n        # log back in with new password\n        self.login(email, password='new_password')\n        user_profile = self.example_user('hamlet')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n        # make sure old password no longer works\n        self.login(email, password=old_password, fails=True)\n\n    def test_invalid_subdomain(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        string_id = 'hamlet'\n        name = 'Hamlet'\n        do_create_realm(\n            string_id,\n            name,\n            restricted_to_domain=False,\n            invite_required=False\n        )\n\n        with self.settings(REALMS_HAVE_SUBDOMAINS=True):\n            with patch('zerver.forms.get_subdomain', return_value=string_id):\n                # start the password reset process by supplying an email address\n                result = self.client_post(\n                    '/accounts/password/reset/', {'email': email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email to finish the process.\", result)\n\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 1)\n        message = outbox.pop()\n        self.assertIn(\"hamlet@zulip.com does not\\nhave an active account in http://\",\n                      message.body)\n\n    def test_correct_subdomain(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        string_id = 'zulip'\n\n        with self.settings(REALMS_HAVE_SUBDOMAINS=True):\n            with patch('zerver.forms.get_subdomain', return_value=string_id):\n                # start the password reset process by supplying an email address\n                result = self.client_post(\n                    '/accounts/password/reset/', {'email': email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email to finish the process.\", result)\n\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 1)\n        message = outbox.pop()\n        self.assertIn(\"Psst. Word on the street is that you forgot your password,\",\n                      message.body)\n\n    def test_redirect_endpoints(self):\n        # type: () -> None\n        '''\n        These tests are mostly designed to give us 100% URL coverage\n        in our URL coverage reports.  Our mechanism for finding URL\n        coverage doesn't handle redirects, so we just have a few quick\n        tests here.\n        '''\n        result = self.client_get('/accounts/password/reset/done/')\n        self.assert_in_success_response([\"Check your email\"], result)\n\n        result = self.client_get('/accounts/password/done/')\n        self.assert_in_success_response([\"We've reset your password!\"], result)\n\n        result = self.client_get('/accounts/send_confirm/alice@example.com')\n        self.assert_in_success_response([\"Still no email?\"], result)\n\nclass LoginTest(ZulipTestCase):\n    \"\"\"\n    Logging in, registration, and logging out.\n    \"\"\"\n\n    def test_login(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"))\n        user_profile = self.example_user('hamlet')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_login_bad_password(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"), password=\"wrongpassword\", fails=True)\n        self.assertIsNone(get_session_dict_user(self.client.session))\n\n    def test_login_nonexist_user(self):\n        # type: () -> None\n        result = self.login_with_return(\"xxx@zulip.com\", \"xxx\")\n        self.assert_in_response(\"Please enter a correct email and password\", result)\n\n    def test_register(self):\n        # type: () -> None\n        realm = get_realm(\"zulip\")\n        stream_dict = {\"stream_\"+str(i): {\"description\": \"stream_%s_description\" % i, \"invite_only\": False}\n                       for i in range(40)}  # type: Dict[Text, Dict[Text, Any]]\n        for stream_name in stream_dict.keys():\n            self.make_stream(stream_name, realm=realm)\n\n        set_default_streams(realm, stream_dict)\n        # Clear all the caches.\n        flush_per_request_caches()\n        ContentType.objects.clear_cache()\n        Site.objects.clear_cache()\n\n        with queries_captured() as queries:\n            self.register(self.nonreg_email('test'), \"test\")\n        # Ensure the number of queries we make is not O(streams)\n        self.assert_length(queries, 47)\n        user_profile = self.nonreg_user('test')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n        self.assertFalse(user_profile.enable_stream_desktop_notifications)\n\n    def test_register_deactivated(self):\n        # type: () -> None\n        \"\"\"\n        If you try to register for a deactivated realm, you get a clear error\n        page.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.register(self.nonreg_email('test'), \"test\")\n        self.assert_in_response(\"has been deactivated\", result)\n\n        with self.assertRaises(UserProfile.DoesNotExist):\n            self.nonreg_user('test')\n\n    def test_login_deactivated(self):\n        # type: () -> None\n        \"\"\"\n        If you try to log in to a deactivated realm, you get a clear error page.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.login_with_return(self.example_email(\"hamlet\"))\n        self.assert_in_response(\"has been deactivated\", result)\n\n    def test_logout(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"))\n        # We use the logout API, not self.logout, to make sure we test\n        # the actual logout code path.\n        self.client_post('/accounts/logout/')\n        self.assertIsNone(get_session_dict_user(self.client.session))\n\n    def test_non_ascii_login(self):\n        # type: () -> None\n        \"\"\"\n        You can log in even if your password contain non-ASCII characters.\n        \"\"\"\n        email = self.nonreg_email('test')\n        password = u\"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Registering succeeds.\n        self.register(email, password)\n        user_profile = self.nonreg_user('test')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n        self.logout()\n        self.assertIsNone(get_session_dict_user(self.client.session))\n\n        # Logging in succeeds.\n        self.logout()\n        self.login(email, password)\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_login_page_redirects_logged_in_user(self):\n        # type: () -> None\n        \"\"\"You will be redirected to the app's main page if you land on the\n        login page when already logged in.\n        \"\"\"\n        self.login(self.example_email(\"cordelia\"))\n        response = self.client_get(\"/login/\")\n        self.assertEqual(response[\"Location\"], \"/\")\n\nclass InviteUserTest(ZulipTestCase):\n\n    def invite(self, users, streams, body=''):\n        # type: (Text, List[Text], str) -> HttpResponse\n        \"\"\"\n        Invites the specified users to Zulip with the specified streams.\n\n        users should be a string containing the users to invite, comma or\n            newline separated.\n\n        streams should be a list of strings.\n        \"\"\"\n\n        return self.client_post(\"/json/invite_users\",\n                                {\"invitee_emails\": users,\n                                 \"stream\": streams,\n                                 \"custom_body\": body})\n\n    def check_sent_emails(self, correct_recipients, custom_body=None):\n        # type: (List[Text], Optional[str]) -> None\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), len(correct_recipients))\n        email_recipients = [email.recipients()[0] for email in outbox]\n        self.assertEqual(sorted(email_recipients), sorted(correct_recipients))\n        if len(outbox) == 0:\n            return\n\n        if custom_body is None:\n            self.assertNotIn(\"Message from\", outbox[0].body)\n        else:\n            self.assertIn(\"Message from \", outbox[0].body)\n            self.assertIn(custom_body, outbox[0].body)\n\n    def test_successful_invite_user(self):\n        # type: () -> None\n        \"\"\"\n        A call to /json/invite_users with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n        self.check_sent_emails([invitee])\n\n    def test_successful_invite_user_with_custom_body(self):\n        # type: () -> None\n        \"\"\"\n        A call to /json/invite_users with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        invitee = \"alice-test@zulip.com\"\n        body = \"Custom Text.\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"], body))\n        self.assertTrue(find_pattern_in_email(invitee, body))\n        self.check_sent_emails([invitee], custom_body=body)\n\n    def test_successful_invite_user_with_name(self):\n        # type: () -> None\n        \"\"\"\n        A call to /json/invite_users with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        email = \"alice-test@zulip.com\"\n        invitee = \"Alice Test <{}>\".format(email)\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.check_sent_emails([email])\n\n    def test_successful_invite_user_with_name_and_normal_one(self):\n        # type: () -> None\n        \"\"\"\n        A call to /json/invite_users with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = \"Alice Test <{}>, {}\".format(email, email2)\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_successful_invite_user_with_notifications_stream(self):\n        # type: () -> None\n        \"\"\"\n        A call to /json/invite_users with valid parameters unconditionally\n        subscribes the invitee to the notifications stream if it exists and is\n        public.\n        \"\"\"\n        realm = get_realm('zulip')\n        notifications_stream = get_stream('Verona', realm)\n        realm.notifications_stream = notifications_stream\n        realm.save()\n\n        self.login(self.example_email(\"hamlet\"))\n        invitee = 'alice-test@zulip.com'\n        self.assert_json_success(self.invite(invitee, ['Denmark']))\n        self.assertTrue(find_key_by_email(invitee))\n        self.check_sent_emails([invitee])\n\n        prereg_user = get_prereg_user_by_email(invitee)\n        streams = list(prereg_user.streams.all())\n        self.assertTrue(notifications_stream in streams)\n\n    def test_invite_user_signup_initial_history(self):\n        # type: () -> None\n        \"\"\"\n        Test that a new user invited to a stream receives some initial\n        history but only from public streams.\n        \"\"\"\n        self.login(self.example_email('hamlet'))\n        user_profile = self.example_user('hamlet')\n        private_stream_name = \"Secret\"\n        self.make_stream(private_stream_name, invite_only=True)\n        self.subscribe_to_stream(user_profile.email, private_stream_name)\n        public_msg_id = self.send_message(self.example_email(\"hamlet\"), \"Denmark\", Recipient.STREAM,\n                                          \"Public topic\", \"Public message\")\n        secret_msg_id = self.send_message(self.example_email(\"hamlet\"), private_stream_name, Recipient.STREAM,\n                                          \"Secret topic\", \"Secret message\")\n        invitee = self.nonreg_email('alice')\n        self.assert_json_success(self.invite(invitee, [private_stream_name, \"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user('alice')\n        invitee_msg_ids = [um.message_id for um in\n                           UserMessage.objects.filter(user_profile=invitee_profile)]\n        self.assertTrue(public_msg_id in invitee_msg_ids)\n        self.assertFalse(secret_msg_id in invitee_msg_ids)\n\n    def test_multi_user_invite(self):\n        # type: () -> None\n        \"\"\"\n        Invites multiple users with a variety of delimiters.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        # Intentionally use a weird string.\n        self.assert_json_success(self.invite(\n            \"\"\"bob-test@zulip.com,     carol-test@zulip.com,\n            dave-test@zulip.com\n\n\nearl-test@zulip.com\"\"\", [\"Denmark\"]))\n        for user in (\"bob\", \"carol\", \"dave\", \"earl\"):\n            self.assertTrue(find_key_by_email(\"%s-test@zulip.com\" % (user,)))\n        self.check_sent_emails([\"bob-test@zulip.com\", \"carol-test@zulip.com\",\n                                \"dave-test@zulip.com\", \"earl-test@zulip.com\"])\n\n    def test_missing_or_invalid_params(self):\n        # type: () -> None\n        \"\"\"\n        Tests inviting with various missing or invalid parameters.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        self.assert_json_error(\n            self.client_post(\"/json/invite_users\", {\"invitee_emails\": \"foo@zulip.com\",\n                                                    \"custom_body\": ''}),\n            \"You must specify at least one stream for invitees to join.\")\n\n        for address in (\"noatsign.com\", \"outsideyourdomain@example.net\"):\n            self.assert_json_error(\n                self.invite(address, [\"Denmark\"]),\n                \"Some emails did not validate, so we didn't send any invitations.\")\n        self.check_sent_emails([])\n\n        self.assert_json_error(\n            self.invite(\"\", [\"Denmark\"]),\n            \"You must specify at least one email address.\")\n        self.check_sent_emails([])\n\n    def test_invalid_stream(self):\n        # type: () -> None\n        \"\"\"\n        Tests inviting to a non-existent stream.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        self.assert_json_error(self.invite(\"iago-test@zulip.com\", [\"NotARealStream\"]),\n                               \"Stream does not exist: NotARealStream. No invites were sent.\")\n        self.check_sent_emails([])\n\n    def test_invite_existing_user(self):\n        # type: () -> None\n        \"\"\"\n        If you invite an address already using Zulip, no invitation is sent.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        self.assert_json_error(\n            self.client_post(\"/json/invite_users\",\n                             {\"invitee_emails\": self.example_email(\"hamlet\"),\n                              \"stream\": [\"Denmark\"],\n                              \"custom_body\": ''}),\n            \"We weren't able to invite anyone.\")\n        self.assertRaises(PreregistrationUser.DoesNotExist,\n                          lambda: PreregistrationUser.objects.get(\n                              email=self.example_email(\"hamlet\")))\n        self.check_sent_emails([])\n\n    def test_invite_some_existing_some_new(self):\n        # type: () -> None\n        \"\"\"\n        If you invite a mix of already existing and new users, invitations are\n        only sent to the new users.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        existing = [self.example_email(\"hamlet\"), u\"othello@zulip.com\"]\n        new = [u\"foo-test@zulip.com\", u\"bar-test@zulip.com\"]\n\n        result = self.client_post(\"/json/invite_users\",\n                                  {\"invitee_emails\": \"\\n\".join(existing + new),\n                                   \"stream\": [\"Denmark\"],\n                                   \"custom_body\": ''})\n        self.assert_json_error(result,\n                               \"Some of those addresses are already using Zulip, \\\nso we didn't send them an invitation. We did send invitations to everyone else!\")\n\n        # We only created accounts for the new users.\n        for email in existing:\n            self.assertRaises(PreregistrationUser.DoesNotExist,\n                              lambda: PreregistrationUser.objects.get(\n                                  email=email))\n        for email in new:\n            self.assertTrue(PreregistrationUser.objects.get(email=email))\n\n        # We only sent emails to the new users.\n        self.check_sent_emails(new)\n\n        prereg_user = get_prereg_user_by_email('foo-test@zulip.com')\n        self.assertEqual(prereg_user.email, 'foo-test@zulip.com')\n\n    def test_invite_outside_domain_in_closed_realm(self):\n        # type: () -> None\n        \"\"\"\n        In a realm with `restricted_to_domain = True`, you can't invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.restricted_to_domain = True\n        zulip_realm.save()\n\n        self.login(self.example_email(\"hamlet\"))\n        external_address = \"foo@example.com\"\n\n        self.assert_json_error(\n            self.invite(external_address, [\"Denmark\"]),\n            \"Some emails did not validate, so we didn't send any invitations.\")\n\n    def test_invite_outside_domain_in_open_realm(self):\n        # type: () -> None\n        \"\"\"\n        In a realm with `restricted_to_domain = False`, you can invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.restricted_to_domain = False\n        zulip_realm.save()\n\n        self.login(self.example_email(\"hamlet\"))\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n    def test_invite_outside_domain_before_closing(self):\n        # type: () -> None\n        \"\"\"\n        If you invite someone with a different domain from that of the realm\n        when `restricted_to_domain = False`, but `restricted_to_domain` later\n        changes to true, the invitation should succeed but the invitee's signup\n        attempt should fail.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.restricted_to_domain = False\n        zulip_realm.save()\n\n        self.login(self.example_email(\"hamlet\"))\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.restricted_to_domain = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(\"foo@example.com\", \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"only allows users with e-mail\", result)\n\n    def test_invite_with_non_ascii_streams(self):\n        # type: () -> None\n        \"\"\"\n        Inviting someone to streams with non-ASCII characters succeeds.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        invitee = \"alice-test@zulip.com\"\n\n        stream_name = u\"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Make sure we're subscribed before inviting someone.\n        self.subscribe_to_stream(self.example_email(\"hamlet\"), stream_name)\n\n        self.assert_json_success(self.invite(invitee, [stream_name]))\n\n    def test_refer_friend(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"))\n        user = self.example_user('hamlet')\n        user.invites_granted = 1\n        user.invites_used = 0\n        user.save()\n\n        invitee = \"alice-test@zulip.com\"\n        result = self.client_post('/json/refer_friend', dict(email=invitee))\n        self.assert_json_success(result)\n\n        # verify this works\n        Referral.objects.get(user_profile=user, email=invitee)\n\n        user = self.example_user('hamlet')\n        self.assertEqual(user.invites_used, 1)\n\n    def test_refer_friend_no_email(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"))\n        user = self.example_user('hamlet')\n        user.invites_granted = 1\n        user.invites_used = 0\n        user.save()\n\n        self.assert_json_error(\n            self.client_post('/json/refer_friend', dict(email='')),\n            \"No email address specified\")\n\n        user = self.example_user('hamlet')\n        self.assertEqual(user.invites_used, 0)\n\n    def test_refer_friend_no_invites(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"))\n        user = self.example_user('hamlet')\n        user.invites_granted = 1\n        user.invites_used = 1\n        user.save()\n\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_error(\n            self.client_post('/json/refer_friend', dict(email=invitee)),\n            \"Insufficient invites\")\n\n        user = self.example_user('hamlet')\n        self.assertEqual(user.invites_used, 1)\n\n    def test_invitation_reminder_email(self):\n        # type: () -> None\n        from django.core.mail import outbox\n\n        # All users belong to zulip realm\n        referrer_user = 'hamlet'\n        current_user_email = self.example_email(referrer_user)\n        self.login(current_user_email)\n        invitee = self.nonreg_email('alice')\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n        self.check_sent_emails([invitee])\n\n        data = {\"email\": invitee, \"referrer_email\": current_user_email}\n        invitee = get_prereg_user_by_email(data[\"email\"])\n        referrer = self.example_user(referrer_user)\n        link = Confirmation.objects.get_link_for_object(invitee, host=referrer.realm.host)\n        context = common_context(referrer)\n        context.update({\n            'activate_url': link,\n            'referrer_name': referrer.full_name,\n            'referrer_email': referrer.email,\n            'referrer_realm_name': referrer.realm.name,\n            'verbose_support_offers': settings.VERBOSE_SUPPORT_OFFERS,\n            'support_email': settings.ZULIP_ADMINISTRATOR\n        })\n        with self.settings(EMAIL_BACKEND='django.core.mail.backends.console.EmailBackend'):\n            send_future_email(\n                \"zerver/emails/invitation_reminder\", data[\"email\"],\n                from_email=settings.ZULIP_ADMINISTRATOR, context=context)\n        email_jobs_to_deliver = ScheduledJob.objects.filter(\n            type=ScheduledJob.EMAIL,\n            scheduled_timestamp__lte=timezone_now())\n        self.assertEqual(len(email_jobs_to_deliver), 1)\n        email_count = len(outbox)\n        for job in email_jobs_to_deliver:\n            self.assertTrue(send_email(**ujson.loads(job.data)))\n        self.assertEqual(len(outbox), email_count + 1)\n\nclass InviteeEmailsParserTests(TestCase):\n    def setUp(self):\n        # type: () -> None\n        self.email1 = \"email1@zulip.com\"\n        self.email2 = \"email2@zulip.com\"\n        self.email3 = \"email3@zulip.com\"\n\n    def test_if_emails_separated_by_commas_are_parsed_and_striped_correctly(self):\n        # type: () -> None\n        emails_raw = \"{} ,{}, {}\".format(self.email1, self.email2, self.email3)\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_separated_by_newlines_are_parsed_and_striped_correctly(self):\n        # type: () -> None\n        emails_raw = \"{}\\n {}\\n {} \".format(self.email1, self.email2, self.email3)\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_from_email_client_separated_by_newlines_are_parsed_correctly(self):\n        # type: () -> None\n        emails_raw = \"Email One <{}>\\nEmailTwo<{}>\\nEmail Three<{}>\".format(self.email1, self.email2, self.email3)\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_in_mixed_style_are_parsed_correctly(self):\n        # type: () -> None\n        emails_raw = \"Email One <{}>,EmailTwo<{}>\\n{}\".format(self.email1, self.email2, self.email3)\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n\nclass EmailUnsubscribeTests(ZulipTestCase):\n    def test_error_unsubscribe(self):\n        # type: () -> None\n\n        # An invalid insubscribe token \"test123\" produces an error.\n        result = self.client_get('/accounts/unsubscribe/missed_messages/test123')\n        self.assert_in_response('Unknown email unsubscribe request', result)\n\n        # An unknown message type \"fake\" produces an error.\n        user_profile = self.example_user('hamlet')\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"fake\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n        self.assert_in_response('Unknown email unsubscribe request', result)\n\n    def test_missedmessage_unsubscribe(self):\n        # type: () -> None\n        \"\"\"\n        We provide one-click unsubscribe links in missed message\n        e-mails that you can click even when logged out to update your\n        email notification settings.\n        \"\"\"\n        user_profile = self.example_user('hamlet')\n        user_profile.enable_offline_email_notifications = True\n        user_profile.save()\n\n        unsubscribe_link = one_click_unsubscribe_link(user_profile,\n                                                      \"missed_messages\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        self.assertEqual(result.status_code, 200)\n        # Circumvent user_profile caching.\n        user_profile = UserProfile.objects.get(email=self.example_email(\"hamlet\"))\n        self.assertFalse(user_profile.enable_offline_email_notifications)\n\n    def test_welcome_unsubscribe(self):\n        # type: () -> None\n        \"\"\"\n        We provide one-click unsubscribe links in welcome e-mails that you can\n        click even when logged out to stop receiving them.\n        \"\"\"\n        email = self.example_email(\"hamlet\")\n        user_profile = self.example_user('hamlet')\n\n        # Simulate a new user signing up, which enqueues 2 welcome e-mails.\n        enqueue_welcome_emails(email, \"King Hamlet\")\n        self.assertEqual(2, len(ScheduledJob.objects.filter(\n            type=ScheduledJob.EMAIL, filter_string__iexact=email)))\n\n        # Simulate unsubscribing from the welcome e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"welcome\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        # The welcome email jobs are no longer scheduled.\n        self.assertEqual(result.status_code, 200)\n        self.assertEqual(0, len(ScheduledJob.objects.filter(\n            type=ScheduledJob.EMAIL, filter_string__iexact=email)))\n\n    def test_digest_unsubscribe(self):\n        # type: () -> None\n        \"\"\"\n        We provide one-click unsubscribe links in digest e-mails that you can\n        click even when logged out to stop receiving them.\n\n        Unsubscribing from these emails also dequeues any digest email jobs that\n        have been queued.\n        \"\"\"\n        email = self.example_email(\"hamlet\")\n        user_profile = self.example_user('hamlet')\n        self.assertTrue(user_profile.enable_digest_emails)\n\n        # Enqueue a fake digest email.\n        context = {'name': '', 'realm_uri': '', 'unread_pms': [], 'hot_conversations': [],\n                   'new_users': [], 'new_streams': {'plain': []}, 'unsubscribe_link': ''}\n        send_future_email('zerver/emails/digest', display_email(user_profile), context=context)\n\n        self.assertEqual(1, len(ScheduledJob.objects.filter(\n            type=ScheduledJob.EMAIL, filter_string__iexact=email)))\n\n        # Simulate unsubscribing from digest e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"digest\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        # The setting is toggled off, and scheduled jobs have been removed.\n        self.assertEqual(result.status_code, 200)\n        # Circumvent user_profile caching.\n        user_profile = UserProfile.objects.get(email=self.example_email(\"hamlet\"))\n        self.assertFalse(user_profile.enable_digest_emails)\n        self.assertEqual(0, len(ScheduledJob.objects.filter(\n            type=ScheduledJob.EMAIL, filter_string__iexact=email)))\n\nclass RealmCreationTest(ZulipTestCase):\n\n    def test_create_realm(self):\n        # type: () -> None\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm = get_realm('test')\n\n        # Make sure the realm does not exist\n        self.assertIsNone(realm)\n\n        with self.settings(OPEN_REALM_CREATION=True):\n            # Create new realm with the email\n            result = self.client_post('/create_realm/', {'email': email})\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result[\"Location\"].endswith(\n                \"/accounts/send_confirm/%s\" % (email,)))\n            result = self.client_get(result[\"Location\"])\n            self.assert_in_response(\"Check your email so we can get started.\", result)\n\n            # Visit the confirmation link.\n            confirmation_url = self.get_confirmation_url_from_outbox(email)\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(email, password, realm_subdomain=string_id)\n            self.assertEqual(result.status_code, 302)\n\n            # Make sure the realm is created\n            realm = get_realm(string_id)\n            self.assertIsNotNone(realm)\n            self.assertEqual(realm.string_id, string_id)\n            self.assertEqual(get_user(email, realm).realm, realm)\n\n            # Check defaults\n            self.assertEqual(realm.org_type, Realm.COMMUNITY)\n            self.assertEqual(realm.restricted_to_domain, False)\n            self.assertEqual(realm.invite_required, True)\n\n            self.assertTrue(result[\"Location\"].endswith(\"/\"))\n\n            # Check welcome messages\n            for stream_name in ['general', 'social', 'zulip']:\n                stream = get_stream(stream_name, realm)\n                recipient = get_recipient(Recipient.STREAM, stream.id)\n                messages = Message.objects.filter(recipient=recipient)\n                self.assertEqual(len(messages), 1)\n                self.assertIn('Welcome to', messages[0].content)\n\n    def test_create_realm_existing_email(self):\n        # type: () -> None\n        \"\"\"\n        Trying to create a realm with an existing email should just redirect to\n        a login page.\n        \"\"\"\n        with self.settings(OPEN_REALM_CREATION=True):\n            email = self.example_email(\"hamlet\")\n            result = self.client_post('/create_realm/', {'email': email})\n            self.assertEqual(result.status_code, 302)\n            self.assertIn('login', result['Location'])\n\n    def test_create_realm_no_creation_key(self):\n        # type: () -> None\n        \"\"\"\n        Trying to create a realm without a creation_key should fail when\n        OPEN_REALM_CREATION is false.\n        \"\"\"\n        email = \"user1@test.com\"\n        realm = get_realm('test')\n\n        # Make sure the realm does not exist\n        self.assertIsNone(realm)\n\n        with self.settings(OPEN_REALM_CREATION=False):\n            # Create new realm with the email, but no creation key.\n            result = self.client_post('/create_realm/', {'email': email})\n            self.assertEqual(result.status_code, 200)\n            self.assert_in_response('New organization creation disabled.', result)\n\n    def test_create_realm_with_subdomain(self):\n        # type: () -> None\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        self.assertIsNone(get_realm('test'))\n\n        with self.settings(REALMS_HAVE_SUBDOMAINS=True), self.settings(OPEN_REALM_CREATION=True):\n            # Create new realm with the email\n            result = self.client_post('/create_realm/', {'email': email})\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result[\"Location\"].endswith(\n                \"/accounts/send_confirm/%s\" % (email,)))\n            result = self.client_get(result[\"Location\"])\n            self.assert_in_response(\"Check your email so we can get started.\", result)\n\n            # Visit the confirmation link.\n            confirmation_url = self.get_confirmation_url_from_outbox(email)\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(email, password,\n                                                   realm_subdomain = string_id,\n                                                   realm_name=realm_name,\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=string_id + \".testserver\")\n            self.assertEqual(result.status_code, 302)\n\n            # Make sure the realm is created\n            realm = get_realm(string_id)\n            self.assertIsNotNone(realm)\n            self.assertEqual(realm.string_id, string_id)\n            self.assertEqual(get_user(email, realm).realm, realm)\n\n            self.assertEqual(realm.name, realm_name)\n            self.assertEqual(realm.subdomain, string_id)\n\n    def test_mailinator_signup(self):\n        # type: () -> None\n        with self.settings(OPEN_REALM_CREATION=True):\n            result = self.client_post('/create_realm/', {'email': \"hi@mailinator.com\"})\n            self.assert_in_response('Please use your real email address.', result)\n\n    def test_subdomain_restrictions(self):\n        # type: () -> None\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        with self.settings(REALMS_HAVE_SUBDOMAINS=False), self.settings(OPEN_REALM_CREATION=True):\n            result = self.client_post('/create_realm/', {'email': email})\n            self.client_get(result[\"Location\"])\n            confirmation_url = self.get_confirmation_url_from_outbox(email)\n            self.client_get(confirmation_url)\n\n            errors = {'id': \"at least 3 characters\",\n                      '-id': \"cannot start or end with a\",\n                      'string-ID': \"lowercase letters\",\n                      'string_id': \"lowercase letters\",\n                      'stream': \"unavailable\",\n                      'streams': \"unavailable\",\n                      'about': \"unavailable\",\n                      'abouts': \"unavailable\",\n                      'zephyr': \"unavailable\"}\n            for string_id, error_msg in errors.items():\n                result = self.submit_reg_form_for_user(email, password,\n                                                       realm_subdomain = string_id,\n                                                       realm_name = realm_name)\n                self.assert_in_response(error_msg, result)\n\n            # test valid subdomain\n            result = self.submit_reg_form_for_user(email, password,\n                                                   realm_subdomain = 'a-0',\n                                                   realm_name = realm_name)\n            self.assertEqual(result.status_code, 302)\n\nclass UserSignUpTest(ZulipTestCase):\n\n    def test_user_default_language_and_timezone(self):\n        # type: () -> None\n        \"\"\"\n        Check if the default language of new user is the default language\n        of the realm.\n        \"\"\"\n        email = self.nonreg_email('newguy')\n        password = \"newpassword\"\n        timezone = \"US/Mountain\"\n        realm = get_realm('zulip')\n        do_set_realm_property(realm, 'default_language', u\"de\")\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS.\n        result = self.submit_reg_form_for_user(email, password, timezone=timezone)\n        self.assertEqual(result.status_code, 302)\n\n        user_profile = self.nonreg_user('newguy')\n        self.assertEqual(user_profile.default_language, realm.default_language)\n        self.assertEqual(user_profile.timezone, timezone)\n        from django.core.mail import outbox\n        outbox.pop()\n\n    def test_signup_already_active(self):\n        # type: () -> None\n        \"\"\"\n        Check if signing up with an active email redirects to a login page.\n        \"\"\"\n        email = self.example_email(\"hamlet\")\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertIn('login', result['Location'])\n\n    def test_signup_invalid_name(self):\n        # type: () -> None\n        \"\"\"\n        Check if an invalid name during signup is handled properly.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS.\n        result = self.submit_reg_form_for_user(email, password, full_name=\"<invalid>\")\n        self.assert_in_success_response([\"Invalid characters in name!\"], result)\n\n    def test_signup_without_password(self):\n        # type: () -> None\n        \"\"\"\n        Check if signing up without a password works properly when\n        password_auth_enabled is False.\n        \"\"\"\n\n        email = self.nonreg_email('newuser')\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        with patch('zerver.views.registration.password_auth_enabled', return_value=False):\n            result = self.client_post(\n                '/accounts/register/',\n                {'full_name': 'New User',\n                 'realm_name': 'Zulip Test',\n                 'realm_subdomain': 'zuliptest',\n                 'key': find_key_by_email(email),\n                 'realm_org_type': Realm.COMMUNITY,\n                 'terms': True})\n\n        # User should now be logged in.\n        self.assertEqual(result.status_code, 302)\n        user_profile = self.nonreg_user('newuser')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_signup_without_full_name(self):\n        # type: () -> None\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.client_post(\n            '/accounts/register/',\n            {'password': password,\n             'realm_name': 'Zulip Test',\n             'realm_subdomain': 'zuliptest',\n             'key': find_key_by_email(email),\n             'realm_org_type': Realm.COMMUNITY,\n             'terms': True,\n             'from_confirmation': '1'})\n        self.assert_in_success_response([\"You're almost there.\"], result)\n\n    def test_signup_with_full_name(self):\n        # type: () -> None\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.client_post(\n            '/accounts/register/',\n            {'password': password,\n             'realm_name': 'Zulip Test',\n             'realm_subdomain': 'zuliptest',\n             'key': find_key_by_email(email),\n             'realm_org_type': Realm.COMMUNITY,\n             'terms': True,\n             'full_name': \"New Guy\",\n             'from_confirmation': '1'})\n        self.assert_in_success_response([\"You're almost there.\"], result)\n\n    def test_signup_invalid_subdomain(self):\n        # type: () -> None\n        \"\"\"\n        Check if attempting to authenticate to the wrong subdomain logs an\n        error and redirects.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        def invalid_subdomain(**kwargs):\n            # type: (**Any) -> Any\n            return_data = kwargs.get('return_data', {})\n            return_data['invalid_subdomain'] = True\n\n        with patch('zerver.views.registration.authenticate', side_effect=invalid_subdomain):\n            with patch('logging.error') as mock_error:\n                result = self.client_post(\n                    '/accounts/register/',\n                    {'password': password,\n                     'full_name': 'New User',\n                     'realm_name': 'Zulip Test',\n                     'realm_subdomain': 'zuliptest',\n                     'key': find_key_by_email(email),\n                     'realm_org_type': Realm.COMMUNITY,\n                     'terms': True})\n        mock_error.assert_called_once()\n        self.assertEqual(result.status_code, 302)\n\n    def test_unique_completely_open_domain(self):\n        # type: () -> None\n        password = \"test\"\n        email = \"user1@acme.com\"\n        subdomain = \"zulip\"\n        realm_name = \"Zulip\"\n\n        realm = get_realm('zulip')\n        realm.restricted_to_domain = False\n        realm.invite_required = False\n        realm.save()\n\n        for string_id in ('simple', 'zephyr'):\n            realm = get_realm(string_id)\n            do_deactivate_realm(realm)\n            realm.save()\n\n        result = self.client_post('/register/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n        for message in reversed(outbox):\n            if email in message.to:\n                confirmation_link_pattern = re.compile(settings.EXTERNAL_HOST + \"(\\S+)>\")\n                confirmation_url = confirmation_link_pattern.search(\n                    message.body).groups()[0]\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email,\n                                               password,\n                                               realm_name=realm_name,\n                                               realm_subdomain=subdomain,\n                                               # Pass HTTP_HOST for the target subdomain\n                                               HTTP_HOST=subdomain + \".testserver\")\n        self.assert_in_success_response([\"You're almost there.\"], result)\n\n    def test_completely_open_domain_success(self):\n        # type: () -> None\n        password = \"test\"\n        email = \"user1@acme.com\"\n        subdomain = \"zulip\"\n        realm_name = \"Zulip\"\n\n        realm = get_realm('zulip')\n        realm.restricted_to_domain = False\n        realm.invite_required = False\n        realm.save()\n\n        result = self.client_post('/register/zulip/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n        for message in reversed(outbox):\n            if email in message.to:\n                confirmation_link_pattern = re.compile(settings.EXTERNAL_HOST + \"(\\S+)>\")\n                confirmation_url = confirmation_link_pattern.search(\n                    message.body).groups()[0]\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email,\n                                               password,\n                                               realm_name=realm_name,\n                                               realm_subdomain=subdomain,\n                                               # Pass HTTP_HOST for the target subdomain\n                                               HTTP_HOST=subdomain + \".testserver\")\n        self.assert_in_success_response([\"You're almost there.\"], result)\n\n    def test_failed_signup_with_realm_str(self):\n        # type: () -> None\n        \"\"\"\n        Signing up with the special accounts_home_with_realm_str endpoint should\n        fail (i.e. redirect to the standard accounts_home) if\n        settings.REALMS_HAVE_SUBDOMAINS is true, or if the realm is not\n        completely open.\n        \"\"\"\n        realm = get_realm('zulip')\n        realm.restricted_to_domain = False\n        realm.invite_required = False\n        realm.save()\n        with self.settings(REALMS_HAVE_SUBDOMAINS=True):\n            email = 'user1@acme.com'\n            result = self.client_post('/register/zulip/', {'email': email})\n            self.assertEqual(result.status_code, 302)\n            self.assertIn('accounts/home', result['Location'])\n\n        realm = get_realm('zulip')\n        realm.invite_required = True\n        realm.save()\n        with self.settings(REALMS_HAVE_SUBDOMAINS=False):\n            email = 'user1@acme.com'\n            result = self.client_post('/register/zulip/', {'email': email})\n            self.assertEqual(result.status_code, 302)\n            self.assertIn('accounts/home', result['Location'])\n\n    def test_failed_signup_due_to_restricted_domain(self):\n        # type: () -> None\n        realm = get_realm('zulip')\n        realm.invite_required = False\n        realm.save()\n        with self.settings(REALMS_HAVE_SUBDOMAINS = True):\n            request = HostRequestMock(host = realm.host)\n            request.session = {} # type: ignore\n            email = 'user@acme.com'\n            form = HomepageForm({'email': email}, realm=realm)\n            self.assertIn(\"Your email address, {}, is not in one of the domains\".format(email),\n                          form.errors['email'][0])\n\n    def test_failed_signup_due_to_invite_required(self):\n        # type: () -> None\n        realm = get_realm('zulip')\n        realm.invite_required = True\n        realm.save()\n        request = HostRequestMock(host = realm.host)\n        request.session = {} # type: ignore\n        email = 'user@zulip.com'\n        form = HomepageForm({'email': email}, realm=realm)\n        self.assertIn(\"Please request an invite for {} from\".format(email),\n                      form.errors['email'][0])\n\n    def test_failed_signup_due_to_nonexistent_realm(self):\n        # type: () -> None\n        with self.settings(REALMS_HAVE_SUBDOMAINS = True):\n            request = HostRequestMock(host = 'acme.' + settings.EXTERNAL_HOST)\n            request.session = {} # type: ignore\n            email = 'user@acme.com'\n            form = HomepageForm({'email': email}, realm=None)\n            self.assertIn(\"organization you are trying to join using {} does \"\n                          \"not exist\".format(email), form.errors['email'][0])\n\n    def test_registration_through_ldap(self):\n        # type: () -> None\n        password = \"testing\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        realm_name = \"Zulip\"\n        ldap_user_attr_map = {'full_name': 'fn', 'short_name': 'sn'}\n\n        ldap_patcher = patch('django_auth_ldap.config.ldap.initialize')\n        mock_initialize = ldap_patcher.start()\n        mock_ldap = MockLDAP()\n        mock_initialize.return_value = mock_ldap\n\n        mock_ldap.directory = {\n            'uid=newuser,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing',\n                'fn': ['New User Name']\n            }\n        }\n\n        with patch('zerver.views.registration.get_subdomain', return_value=subdomain):\n            result = self.client_post('/register/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n        for message in reversed(outbox):\n            if email in message.to:\n                confirmation_link_pattern = re.compile(settings.EXTERNAL_HOST + \"(\\S+)>\")\n                confirmation_url = confirmation_link_pattern.search(\n                    message.body).groups()[0]\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n                POPULATE_PROFILE_VIA_LDAP=True,\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n                AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',),\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            # The full_name should not be overriden by the value from LDAP if\n            # request.session['authenticated_full_name'] has not been set yet.\n            with patch('zerver.views.registration.name_changes_disabled', return_value=True):\n                result = self.submit_reg_form_for_user(email,\n                                                       password,\n                                                       full_name=\"Non LDAP Full Name\",\n                                                       realm_name=realm_name,\n                                                       realm_subdomain=subdomain,\n                                                       # Pass HTTP_HOST for the target subdomain\n                                                       HTTP_HOST=subdomain + \".testserver\")\n            self.assert_in_success_response([\"You're almost there.\",\n                                             \"Non LDAP Full Name\",\n                                             \"newuser@zulip.com\"],\n                                            result)\n\n            # Submitting the registration form with from_confirmation='1' sets\n            # the value of request.session['authenticated_full_name'] from LDAP.\n            result = self.submit_reg_form_for_user(email,\n                                                   password,\n                                                   realm_name=realm_name,\n                                                   realm_subdomain=subdomain,\n                                                   from_confirmation='1',\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=subdomain + \".testserver\")\n            self.assert_in_success_response([\"You're almost there.\",\n                                             \"New User Name\",\n                                             \"newuser@zulip.com\"],\n                                            result)\n\n            # The full name be populated from the value of\n            # request.session['authenticated_full_name'] from LDAP in the case\n            # where from_confirmation and name_changes_disabled are both False.\n            with patch('zerver.views.registration.name_changes_disabled', return_value=True):\n                result = self.submit_reg_form_for_user(email,\n                                                       password,\n                                                       full_name=\"Non LDAP Full Name\",\n                                                       realm_name=realm_name,\n                                                       realm_subdomain=subdomain,\n                                                       # Pass HTTP_HOST for the target subdomain\n                                                       HTTP_HOST=subdomain + \".testserver\")\n            self.assert_in_success_response([\"You're almost there.\",\n                                             \"New User Name\",\n                                             \"newuser@zulip.com\"],\n                                            result)\n\n            # Test the TypeError exception handler\n            mock_ldap.directory = {\n                'uid=newuser,ou=users,dc=zulip,dc=com': {\n                    'userPassword': 'testing',\n                    'fn': None  # This will raise TypeError\n                }\n            }\n            result = self.submit_reg_form_for_user(email,\n                                                   password,\n                                                   realm_name=realm_name,\n                                                   realm_subdomain=subdomain,\n                                                   from_confirmation='1',\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=subdomain + \".testserver\")\n            self.assert_in_success_response([\"You're almost there.\",\n                                             \"newuser@zulip.com\"],\n                                            result)\n\n        mock_ldap.reset()\n        mock_initialize.stop()\n\n    @patch('DNS.dnslookup', return_value=[['sipbtest:*:20922:101:Fred Sipb,,,:/mit/sipbtest:/bin/athena/tcsh']])\n    def test_registration_email_for_mirror_dummy_user(self, ignored):\n        # type: (Any) -> None\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.email\n        user_profile.is_mirror_dummy = True\n        user_profile.is_active = False\n        user_profile.save()\n\n        with self.settings(REALMS_HAVE_SUBDOMAINS=True):\n            with patch('zerver.forms.get_subdomain', return_value='zephyr'):\n                with patch('zerver.views.registration.get_subdomain', return_value='zephyr'):\n                    result = self.client_post('/accounts/home/', {'email': email})\n                    self.assertEqual(result.status_code, 302)\n\n        from django.core.mail import outbox\n        for message in reversed(outbox):\n            if email in message.to:\n                # The main difference between the zephyr registation email\n                # and the normal one is this string\n                index = message.body.find('https://zephyr.zulipchat.com/zephyr')\n                if index >= 0:\n                    return\n        else:\n            raise AssertionError(\"Couldn't find the right confirmation email.\")\n\n    @patch('DNS.dnslookup', return_value=[['sipbtest:*:20922:101:Fred Sipb,,,:/mit/sipbtest:/bin/athena/tcsh']])\n    def test_registration_of_mirror_dummy_user(self, ignored):\n        # type: (Any) -> None\n        password = \"test\"\n        subdomain = \"sipb\"\n        realm_name = \"MIT\"\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.email\n        user_profile.is_mirror_dummy = True\n        user_profile.is_active = False\n        user_profile.save()\n\n        result = self.client_post('/register/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n        for message in reversed(outbox):\n            if email in message.to:\n                confirmation_link_pattern = re.compile(settings.EXTERNAL_HOST + \"(\\S+)>\")\n                confirmation_url = confirmation_link_pattern.search(\n                    message.body).groups()[0]\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # If the mirror dummy user is already active, attempting to submit the\n        # registration form should just redirect to a login page.\n        user_profile.is_active = True\n        user_profile.save()\n        result = self.submit_reg_form_for_user(email,\n                                               password,\n                                               realm_name=realm_name,\n                                               realm_subdomain=subdomain,\n                                               from_confirmation='1',\n                                               # Pass HTTP_HOST for the target subdomain\n                                               HTTP_HOST=subdomain + \".testserver\")\n        self.assertEqual(result.status_code, 302)\n        self.assertIn('login', result['Location'])\n        user_profile.is_active = False\n        user_profile.save()\n\n        result = self.submit_reg_form_for_user(email,\n                                               password,\n                                               realm_name=realm_name,\n                                               realm_subdomain=subdomain,\n                                               from_confirmation='1',\n                                               # Pass HTTP_HOST for the target subdomain\n                                               HTTP_HOST=subdomain + \".testserver\")\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(email,\n                                               password,\n                                               realm_name=realm_name,\n                                               realm_subdomain=subdomain,\n                                               # Pass HTTP_HOST for the target subdomain\n                                               HTTP_HOST=subdomain + \".testserver\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_registration_of_active_mirror_dummy_user(self):\n        # type: (Any) -> None\n        \"\"\"\n        Trying to activate an already-active mirror dummy user should just\n        redirect to a login page.\n        \"\"\"\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.email\n        user_profile.is_mirror_dummy = True\n        user_profile.is_active = True\n        user_profile.save()\n\n        result = self.client_post('/register/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertIn('login', result['Location'])\n\nclass TestOpenRealms(ZulipTestCase):\n    def test_open_realm_logic(self):\n        # type: () -> None\n        realm = get_realm('simple')\n        do_deactivate_realm(realm)\n\n        mit_realm = get_realm(\"zephyr\")\n        self.assertEqual(get_unique_open_realm(), None)\n        mit_realm.restricted_to_domain = False\n        mit_realm.save()\n        self.assertTrue(completely_open(mit_realm))\n        self.assertEqual(get_unique_open_realm(), None)\n        with self.settings(SYSTEM_ONLY_REALMS={\"zulip\"}):\n            self.assertEqual(get_unique_open_realm(), mit_realm)\n        mit_realm.restricted_to_domain = True\n        mit_realm.save()\n\nclass DeactivateUserTest(ZulipTestCase):\n\n    def test_deactivate_user(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        self.login(email)\n        user = self.example_user('hamlet')\n        self.assertTrue(user.is_active)\n        result = self.client_delete('/json/users/me')\n        self.assert_json_success(result)\n        user = self.example_user('hamlet')\n        self.assertFalse(user.is_active)\n        self.login(email, fails=True)\n\n    def test_do_not_deactivate_final_admin(self):\n        # type: () -> None\n        email = self.example_email(\"iago\")\n        self.login(email)\n        user = self.example_user('iago')\n        self.assertTrue(user.is_active)\n        result = self.client_delete('/json/users/me')\n        self.assert_json_error(result, \"Cannot deactivate the only organization administrator\")\n        user = self.example_user('iago')\n        self.assertTrue(user.is_active)\n        self.assertTrue(user.is_realm_admin)\n        email = self.example_email(\"hamlet\")\n        user_2 = self.example_user('hamlet')\n        do_change_is_admin(user_2, True)\n        self.assertTrue(user_2.is_realm_admin)\n        result = self.client_delete('/json/users/me')\n        self.assert_json_success(result)\n        do_change_is_admin(user, True)\n\nclass TestLoginPage(ZulipTestCase):\n    def test_login_page_wrong_subdomain_error(self):\n        # type: () -> None\n        result = self.client_get(\"/login/?subdomain=1\")\n        self.assertIn(WRONG_SUBDOMAIN_ERROR, result.content.decode('utf8'))\n\n    @patch('django.http.HttpRequest.get_host')\n    def test_login_page_redirects_for_root_alias(self, mock_get_host):\n        # type: (MagicMock) -> None\n        mock_get_host.return_value = 'www.testserver'\n        with self.settings(REALMS_HAVE_SUBDOMAINS=True,\n                           ROOT_SUBDOMAIN_ALIASES=['www']):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, '/find_my_team/')\n\n    @patch('django.http.HttpRequest.get_host')\n    def test_login_page_redirects_for_root_domain(self, mock_get_host):\n        # type: (MagicMock) -> None\n        mock_get_host.return_value = 'testserver'\n        with self.settings(REALMS_HAVE_SUBDOMAINS=True,\n                           ROOT_SUBDOMAIN_ALIASES=['www']):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, '/find_my_team/')\n\n        mock_get_host.return_value = 'www.testserver.com'\n        with self.settings(REALMS_HAVE_SUBDOMAINS=True,\n                           EXTERNAL_HOST='www.testserver.com',\n                           ROOT_SUBDOMAIN_ALIASES=['test']):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, '/find_my_team/')\n\n    @patch('django.http.HttpRequest.get_host')\n    def test_login_page_works_without_subdomains(self, mock_get_host):\n        # type: (MagicMock) -> None\n        mock_get_host.return_value = 'www.testserver'\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=['www']):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = 'testserver'\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=['www']):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 200)\n\nclass TestFindMyTeam(ZulipTestCase):\n    def test_template(self):\n        # type: () -> None\n        result = self.client_get('/find_my_team/')\n        self.assertIn(\"Find your team\", result.content.decode('utf8'))\n\n    def test_result(self):\n        # type: () -> None\n        url = '/find_my_team/?emails=iago@zulip.com,cordelia@zulip.com'\n        result = self.client_get(url)\n        content = result.content.decode('utf8')\n        self.assertIn(\"Emails sent! You will only receive emails\", content)\n        self.assertIn(self.example_email(\"iago\"), content)\n        self.assertIn(self.example_email(\"cordelia\"), content)\n\n    def test_find_team_ignore_invalid_email(self):\n        # type: () -> None\n        url = '/find_my_team/?emails=iago@zulip.com,invalid_email'\n        result = self.client_get(url)\n        content = result.content.decode('utf8')\n        self.assertIn(\"Emails sent! You will only receive emails\", content)\n        self.assertIn(self.example_email(\"iago\"), content)\n        self.assertNotIn(\"invalid_email\", content)\n\n    def test_find_team_zero_emails(self):\n        # type: () -> None\n        data = {'emails': ''}\n        result = self.client_post('/find_my_team/', data)\n        self.assertIn('This field is required', result.content.decode('utf8'))\n        self.assertEqual(result.status_code, 200)\n\n    def test_find_team_one_email(self):\n        # type: () -> None\n        data = {'emails': self.example_email(\"hamlet\")}\n        result = self.client_post('/find_my_team/', data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, '/find_my_team/?emails=hamlet%40zulip.com')\n\n    def test_find_team_multiple_emails(self):\n        # type: () -> None\n        data = {'emails': 'hamlet@zulip.com,iago@zulip.com'}\n        result = self.client_post('/find_my_team/', data)\n        self.assertEqual(result.status_code, 302)\n        expected = '/find_my_team/?emails=hamlet%40zulip.com%2Ciago%40zulip.com'\n        self.assertEqual(result.url, expected)\n\n    def test_find_team_more_than_ten_emails(self):\n        # type: () -> None\n        data = {'emails': ','.join(['hamlet-{}@zulip.com'.format(i) for i in range(11)])}\n        result = self.client_post('/find_my_team/', data)\n        self.assertEqual(result.status_code, 200)\n        self.assertIn(\"Please enter at most 10\", result.content.decode('utf8'))\n\nclass ConfirmationKeyTest(ZulipTestCase):\n    def test_confirmation_key(self):\n        # type: () -> None\n        request = MagicMock()\n        request.session = {\n            'confirmation_key': {'confirmation_key': 'xyzzy'}\n        }\n        result = confirmation_key(request)\n        self.assert_json_success(result)\n        self.assert_in_response('xyzzy', result)\n\nclass MobileAuthOTPTest(ZulipTestCase):\n    def test_xor_hex_strings(self):\n        # type: () -> None\n        self.assertEqual(xor_hex_strings('1237c81ab', '18989fd12'), '0aaf57cb9')\n        with self.assertRaises(AssertionError):\n            xor_hex_strings('1', '31')\n\n    def test_is_valid_otp(self):\n        # type: () -> None\n        self.assertEqual(is_valid_otp('1234'), False)\n        self.assertEqual(is_valid_otp('1234abcd' * 8), True)\n        self.assertEqual(is_valid_otp('1234abcZ' * 8), False)\n\n    def test_ascii_to_hex(self):\n        # type: () -> None\n        self.assertEqual(ascii_to_hex('ZcdR1234'), '5a63645231323334')\n        self.assertEqual(hex_to_ascii('5a63645231323334'), 'ZcdR1234')\n\n    def test_otp_encrypt_api_key(self):\n        # type: () -> None\n        hamlet = self.example_user('hamlet')\n        hamlet.api_key = '12ac' * 8\n        otp = '7be38894' * 8\n        result = otp_encrypt_api_key(hamlet, otp)\n        self.assertEqual(result, '4ad1e9f7' * 8)\n\n        decryped = otp_decrypt_api_key(result, otp)\n        self.assertEqual(decryped, hamlet.api_key)\n\nclass LoginOrAskForRegistrationTestCase(ZulipTestCase):\n    def test_confirm(self):\n        # type: () -> None\n        request = POSTRequestMock({}, None)\n        email = 'new@zulip.com'\n        user_profile = None\n        full_name = 'New User'\n        invalid_subdomain = False\n        result = login_or_register_remote_user(\n            request,\n            email,\n            user_profile,\n            full_name=full_name,\n            invalid_subdomain=invalid_subdomain)\n        self.assert_in_response('You attempted to login using the email account',\n                                result)\n        self.assert_in_response('new@zulip.com, but this email address does not',\n                                result)\n\n    def test_invalid_subdomain(self):\n        # type: () -> None\n        request = POSTRequestMock({}, None)\n        email = 'new@zulip.com'\n        user_profile = None\n        full_name = 'New User'\n        invalid_subdomain = True\n        response = login_or_register_remote_user(\n            request,\n            email,\n            user_profile,\n            full_name=full_name,\n            invalid_subdomain=invalid_subdomain)\n        self.assertEqual(response.status_code, 302)\n        self.assertIn('/accounts/login/?subdomain=1', response.url)\n\n    def test_invalid_email(self):\n        # type: () -> None\n        request = POSTRequestMock({}, None)\n        email = None\n        user_profile = None\n        full_name = 'New User'\n        invalid_subdomain = False\n        response = login_or_register_remote_user(\n            request,\n            email,\n            user_profile,\n            full_name=full_name,\n            invalid_subdomain=invalid_subdomain)\n        self.assert_in_response('Please click the following button if '\n                                'you wish to register', response)\n\n    def test_login_under_subdomains(self):\n        # type: () -> None\n        request = POSTRequestMock({}, None)\n        setattr(request, 'session', self.client.session)\n        user_profile = self.example_user('hamlet')\n        user_profile.backend = 'zproject.backends.GitHubAuthBackend'\n        full_name = 'Hamlet'\n        invalid_subdomain = False\n        with self.settings(REALMS_HAVE_SUBDOMAINS=True):\n            response = login_or_register_remote_user(\n                request,\n                user_profile.email,\n                user_profile,\n                full_name=full_name,\n                invalid_subdomain=invalid_subdomain)\n            user_id = get_session_dict_user(getattr(request, 'session'))\n            self.assertEqual(user_id, user_profile.id)\n            self.assertEqual(response.status_code, 302)\n            self.assertIn('http://zulip.testserver', response.url)\n\n    def test_login_without_subdomains(self):\n        # type: () -> None\n        request = POSTRequestMock({}, None)\n        setattr(request, 'session', self.client.session)\n        setattr(request, 'get_host', lambda: 'localhost')\n        user_profile = self.example_user('hamlet')\n        user_profile.backend = 'zproject.backends.GitHubAuthBackend'\n        full_name = 'Hamlet'\n        invalid_subdomain = False\n        with self.settings(REALMS_HAVE_SUBDOMAINS=False):\n            response = login_or_register_remote_user(\n                request,\n                user_profile.email,\n                user_profile,\n                full_name=full_name,\n                invalid_subdomain=invalid_subdomain)\n            user_id = get_session_dict_user(getattr(request, 'session'))\n            self.assertEqual(user_id, user_profile.id)\n            self.assertEqual(response.status_code, 302)\n            self.assertIn('http://localhost', response.url)\n", "from __future__ import absolute_import\n\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.http import HttpRequest, HttpResponse\nfrom django.utils.translation import ugettext as _\nfrom typing import List, Optional, Set, Text\n\nfrom zerver.decorator import authenticated_json_post_view\nfrom zerver.lib.actions import do_invite_users, do_refer_friend, \\\n    get_default_subs, internal_send_message\nfrom zerver.lib.request import REQ, has_request_variables, JsonableError\nfrom zerver.lib.response import json_success, json_error\nfrom zerver.lib.streams import access_stream_by_name\nfrom zerver.lib.validator import check_string, check_list\nfrom zerver.models import PreregistrationUser, Stream, UserProfile\n\nimport re\n\n@authenticated_json_post_view\n@has_request_variables\ndef json_invite_users(request, user_profile,\n                      invitee_emails_raw=REQ(\"invitee_emails\"),\n                      body=REQ(\"custom_body\", default=None)):\n    # type: (HttpRequest, UserProfile, str, Optional[str]) -> HttpResponse\n    if not invitee_emails_raw:\n        return json_error(_(\"You must specify at least one email address.\"))\n    if body == '':\n        body = None\n\n    invitee_emails = get_invitee_emails_set(invitee_emails_raw)\n\n    stream_names = request.POST.getlist('stream')\n    if not stream_names:\n        return json_error(_(\"You must specify at least one stream for invitees to join.\"))\n\n    # We unconditionally sub you to the notifications stream if it\n    # exists and is public.\n    notifications_stream = user_profile.realm.notifications_stream  # type: Optional[Stream]\n    if notifications_stream and not notifications_stream.invite_only:\n        stream_names.append(notifications_stream.name)\n\n    streams = []  # type: List[Stream]\n    for stream_name in stream_names:\n        try:\n            (stream, recipient, sub) = access_stream_by_name(user_profile, stream_name)\n        except JsonableError:\n            return json_error(_(\"Stream does not exist: %s. No invites were sent.\") % (stream_name,))\n        streams.append(stream)\n\n    ret_error, error_data = do_invite_users(user_profile, invitee_emails, streams, body)\n\n    if ret_error is not None:\n        return json_error(data=error_data, msg=ret_error)\n    else:\n        return json_success()\n\ndef get_invitee_emails_set(invitee_emails_raw):\n    # type: (str) -> Set[str]\n    invitee_emails_list = set(re.split(r'[,\\n]', invitee_emails_raw))\n    invitee_emails = set()\n    for email in invitee_emails_list:\n        is_email_with_name = re.search(r'<(?P<email>.*)>', email)\n        if is_email_with_name:\n            email = is_email_with_name.group('email')\n        invitee_emails.add(email.strip())\n    return invitee_emails\n\n@authenticated_json_post_view\n@has_request_variables\ndef json_refer_friend(request, user_profile, email=REQ()):\n    # type: (HttpRequest, UserProfile, str) -> HttpResponse\n    if not email:\n        return json_error(_(\"No email address specified\"))\n    if user_profile.invites_granted - user_profile.invites_used <= 0:\n        return json_error(_(\"Insufficient invites\"))\n\n    do_refer_friend(user_profile, email)\n\n    return json_success()\n"], "fixing_code": ["# -*- coding: utf-8 -*-\nfrom __future__ import absolute_import\nimport datetime\nfrom django.conf import settings\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.contrib.sites.models import Site\nfrom django.http import HttpResponse\nfrom django.test import TestCase\nfrom django.utils.timezone import now as timezone_now\n\nfrom mock import patch, MagicMock\nfrom zerver.lib.test_helpers import MockLDAP\n\nfrom confirmation.models import Confirmation\n\nfrom zilencer.models import Deployment\n\nfrom zerver.forms import HomepageForm, WRONG_SUBDOMAIN_ERROR\nfrom zerver.lib.actions import do_change_password\nfrom zerver.views.auth import login_or_register_remote_user\nfrom zerver.views.invite import get_invitee_emails_set\nfrom zerver.views.registration import confirmation_key, \\\n    redirect_and_log_into_subdomain, send_registration_completion_email\n\nfrom zerver.models import (\n    get_realm, get_prereg_user_by_email, get_user,\n    get_unique_open_realm, completely_open, get_recipient,\n    PreregistrationUser, Realm, RealmDomain, Recipient, Message,\n    Referral, ScheduledJob, UserProfile, UserMessage,\n    Stream, Subscription, ScheduledJob, flush_per_request_caches\n)\nfrom zerver.lib.actions import (\n    set_default_streams,\n    do_change_is_admin,\n    get_stream,\n    do_create_realm,\n)\nfrom zerver.lib.send_email import display_email, send_email, send_future_email\nfrom zerver.lib.initial_password import initial_password\nfrom zerver.lib.actions import (\n    do_deactivate_realm,\n    do_set_realm_property,\n    add_new_user_history,\n)\nfrom zerver.lib.mobile_auth_otp import xor_hex_strings, ascii_to_hex, \\\n    otp_encrypt_api_key, is_valid_otp, hex_to_ascii, otp_decrypt_api_key\nfrom zerver.lib.notifications import enqueue_welcome_emails, \\\n    one_click_unsubscribe_link\nfrom zerver.lib.test_helpers import find_pattern_in_email, find_key_by_email, queries_captured, \\\n    HostRequestMock, unsign_subdomain_cookie, POSTRequestMock\nfrom zerver.lib.test_classes import (\n    ZulipTestCase,\n)\nfrom zerver.lib.test_runner import slow\nfrom zerver.lib.sessions import get_session_dict_user\nfrom zerver.context_processors import common_context\n\nfrom collections import defaultdict\nimport re\nimport ujson\n\nfrom typing import Any, Dict, List, Optional, Set\n\nfrom six.moves import urllib\nfrom six.moves import range\nfrom typing import Any, Text\nimport os\n\nclass RedirectAndLogIntoSubdomainTestCase(ZulipTestCase):\n    def test_cookie_data(self):\n        # type: () -> None\n        realm = Realm.objects.all().first()\n        name = 'Hamlet'\n        email = self.example_email(\"hamlet\")\n        response = redirect_and_log_into_subdomain(realm, name, email)\n        data = unsign_subdomain_cookie(response)\n        self.assertDictEqual(data, {'name': name, 'email': email,\n                                    'subdomain': realm.subdomain,\n                                    'is_signup': False})\n\n        response = redirect_and_log_into_subdomain(realm, name, email,\n                                                   is_signup=True)\n        data = unsign_subdomain_cookie(response)\n        self.assertDictEqual(data, {'name': name, 'email': email,\n                                    'subdomain': realm.subdomain,\n                                    'is_signup': True})\n\nclass AddNewUserHistoryTest(ZulipTestCase):\n    def test_add_new_user_history_race(self):\n        # type: () -> None\n        \"\"\"Sends a message during user creation\"\"\"\n        # Create a user who hasn't had historical messages added\n        stream_dict = {\n            \"Denmark\": {\"description\": \"A Scandinavian country\", \"invite_only\": False},\n            \"Verona\": {\"description\": \"A city in Italy\", \"invite_only\": False}\n        }  # type: Dict[Text, Dict[Text, Any]]\n        realm = get_realm('zulip')\n        set_default_streams(realm, stream_dict)\n        with patch(\"zerver.lib.actions.add_new_user_history\"):\n            self.register(self.nonreg_email('test'), \"test\")\n        user_profile = self.nonreg_user('test')\n\n        subs = Subscription.objects.select_related(\"recipient\").filter(\n            user_profile=user_profile, recipient__type=Recipient.STREAM)\n        streams = Stream.objects.filter(id__in=[sub.recipient.type_id for sub in subs])\n        self.send_message(self.example_email('hamlet'), streams[0].name, Recipient.STREAM, \"test\")\n        add_new_user_history(user_profile, streams)\n\nclass PasswordResetTest(ZulipTestCase):\n    \"\"\"\n    Log in, reset password, log out, log in with new password.\n    \"\"\"\n\n    def test_password_reset(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        old_password = initial_password(email)\n\n        self.login(email)\n\n        # test password reset template\n        result = self.client_get('/accounts/password/reset/')\n        self.assert_in_response('Reset your password', result)\n\n        # start the password reset process by supplying an email address\n        result = self.client_post('/accounts/password/reset/', {'email': email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email to finish the process.\", result)\n\n        # Visit the password reset link.\n        password_reset_url = self.get_confirmation_url_from_outbox(email, \"(\\S+)\")\n        result = self.client_get(password_reset_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Reset your password\n        result = self.client_post(password_reset_url,\n                                  {'new_password1': 'new_password',\n                                   'new_password2': 'new_password'})\n\n        # password reset succeeded\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/password/done/\"))\n\n        # log back in with new password\n        self.login(email, password='new_password')\n        user_profile = self.example_user('hamlet')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n        # make sure old password no longer works\n        self.login(email, password=old_password, fails=True)\n\n    def test_invalid_subdomain(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        string_id = 'hamlet'\n        name = 'Hamlet'\n        do_create_realm(\n            string_id,\n            name,\n            restricted_to_domain=False,\n            invite_required=False\n        )\n\n        with self.settings(REALMS_HAVE_SUBDOMAINS=True):\n            with patch('zerver.forms.get_subdomain', return_value=string_id):\n                # start the password reset process by supplying an email address\n                result = self.client_post(\n                    '/accounts/password/reset/', {'email': email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email to finish the process.\", result)\n\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 1)\n        message = outbox.pop()\n        self.assertIn(\"hamlet@zulip.com does not\\nhave an active account in http://\",\n                      message.body)\n\n    def test_correct_subdomain(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        string_id = 'zulip'\n\n        with self.settings(REALMS_HAVE_SUBDOMAINS=True):\n            with patch('zerver.forms.get_subdomain', return_value=string_id):\n                # start the password reset process by supplying an email address\n                result = self.client_post(\n                    '/accounts/password/reset/', {'email': email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email to finish the process.\", result)\n\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 1)\n        message = outbox.pop()\n        self.assertIn(\"Psst. Word on the street is that you forgot your password,\",\n                      message.body)\n\n    def test_redirect_endpoints(self):\n        # type: () -> None\n        '''\n        These tests are mostly designed to give us 100% URL coverage\n        in our URL coverage reports.  Our mechanism for finding URL\n        coverage doesn't handle redirects, so we just have a few quick\n        tests here.\n        '''\n        result = self.client_get('/accounts/password/reset/done/')\n        self.assert_in_success_response([\"Check your email\"], result)\n\n        result = self.client_get('/accounts/password/done/')\n        self.assert_in_success_response([\"We've reset your password!\"], result)\n\n        result = self.client_get('/accounts/send_confirm/alice@example.com')\n        self.assert_in_success_response([\"Still no email?\"], result)\n\nclass LoginTest(ZulipTestCase):\n    \"\"\"\n    Logging in, registration, and logging out.\n    \"\"\"\n\n    def test_login(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"))\n        user_profile = self.example_user('hamlet')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_login_bad_password(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"), password=\"wrongpassword\", fails=True)\n        self.assertIsNone(get_session_dict_user(self.client.session))\n\n    def test_login_nonexist_user(self):\n        # type: () -> None\n        result = self.login_with_return(\"xxx@zulip.com\", \"xxx\")\n        self.assert_in_response(\"Please enter a correct email and password\", result)\n\n    def test_register(self):\n        # type: () -> None\n        realm = get_realm(\"zulip\")\n        stream_dict = {\"stream_\"+str(i): {\"description\": \"stream_%s_description\" % i, \"invite_only\": False}\n                       for i in range(40)}  # type: Dict[Text, Dict[Text, Any]]\n        for stream_name in stream_dict.keys():\n            self.make_stream(stream_name, realm=realm)\n\n        set_default_streams(realm, stream_dict)\n        # Clear all the caches.\n        flush_per_request_caches()\n        ContentType.objects.clear_cache()\n        Site.objects.clear_cache()\n\n        with queries_captured() as queries:\n            self.register(self.nonreg_email('test'), \"test\")\n        # Ensure the number of queries we make is not O(streams)\n        self.assert_length(queries, 47)\n        user_profile = self.nonreg_user('test')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n        self.assertFalse(user_profile.enable_stream_desktop_notifications)\n\n    def test_register_deactivated(self):\n        # type: () -> None\n        \"\"\"\n        If you try to register for a deactivated realm, you get a clear error\n        page.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.register(self.nonreg_email('test'), \"test\")\n        self.assert_in_response(\"has been deactivated\", result)\n\n        with self.assertRaises(UserProfile.DoesNotExist):\n            self.nonreg_user('test')\n\n    def test_login_deactivated(self):\n        # type: () -> None\n        \"\"\"\n        If you try to log in to a deactivated realm, you get a clear error page.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.login_with_return(self.example_email(\"hamlet\"))\n        self.assert_in_response(\"has been deactivated\", result)\n\n    def test_logout(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"))\n        # We use the logout API, not self.logout, to make sure we test\n        # the actual logout code path.\n        self.client_post('/accounts/logout/')\n        self.assertIsNone(get_session_dict_user(self.client.session))\n\n    def test_non_ascii_login(self):\n        # type: () -> None\n        \"\"\"\n        You can log in even if your password contain non-ASCII characters.\n        \"\"\"\n        email = self.nonreg_email('test')\n        password = u\"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Registering succeeds.\n        self.register(email, password)\n        user_profile = self.nonreg_user('test')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n        self.logout()\n        self.assertIsNone(get_session_dict_user(self.client.session))\n\n        # Logging in succeeds.\n        self.logout()\n        self.login(email, password)\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_login_page_redirects_logged_in_user(self):\n        # type: () -> None\n        \"\"\"You will be redirected to the app's main page if you land on the\n        login page when already logged in.\n        \"\"\"\n        self.login(self.example_email(\"cordelia\"))\n        response = self.client_get(\"/login/\")\n        self.assertEqual(response[\"Location\"], \"/\")\n\nclass InviteUserTest(ZulipTestCase):\n\n    def invite(self, users, streams, body=''):\n        # type: (Text, List[Text], str) -> HttpResponse\n        \"\"\"\n        Invites the specified users to Zulip with the specified streams.\n\n        users should be a string containing the users to invite, comma or\n            newline separated.\n\n        streams should be a list of strings.\n        \"\"\"\n\n        return self.client_post(\"/json/invite_users\",\n                                {\"invitee_emails\": users,\n                                 \"stream\": streams,\n                                 \"custom_body\": body})\n\n    def check_sent_emails(self, correct_recipients, custom_body=None):\n        # type: (List[Text], Optional[str]) -> None\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), len(correct_recipients))\n        email_recipients = [email.recipients()[0] for email in outbox]\n        self.assertEqual(sorted(email_recipients), sorted(correct_recipients))\n        if len(outbox) == 0:\n            return\n\n        if custom_body is None:\n            self.assertNotIn(\"Message from\", outbox[0].body)\n        else:\n            self.assertIn(\"Message from \", outbox[0].body)\n            self.assertIn(custom_body, outbox[0].body)\n\n    def test_successful_invite_user(self):\n        # type: () -> None\n        \"\"\"\n        A call to /json/invite_users with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n        self.check_sent_emails([invitee])\n\n    def test_successful_invite_user_with_custom_body(self):\n        # type: () -> None\n        \"\"\"\n        A call to /json/invite_users with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        invitee = \"alice-test@zulip.com\"\n        body = \"Custom Text.\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"], body))\n        self.assertTrue(find_pattern_in_email(invitee, body))\n        self.check_sent_emails([invitee], custom_body=body)\n\n    def test_successful_invite_user_with_name(self):\n        # type: () -> None\n        \"\"\"\n        A call to /json/invite_users with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        email = \"alice-test@zulip.com\"\n        invitee = \"Alice Test <{}>\".format(email)\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.check_sent_emails([email])\n\n    def test_successful_invite_user_with_name_and_normal_one(self):\n        # type: () -> None\n        \"\"\"\n        A call to /json/invite_users with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = \"Alice Test <{}>, {}\".format(email, email2)\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_require_realm_admin(self):\n        # type: () -> None\n        \"\"\"\n        The invite_by_admins_only realm setting works properly.\n        \"\"\"\n        realm = get_realm('zulip')\n        realm.invite_by_admins_only = True\n        realm.save()\n\n        self.login(\"hamlet@zulip.com\")\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = \"Alice Test <{}>, {}\".format(email, email2)\n        self.assert_json_error(self.invite(invitee, [\"Denmark\"]),\n                               \"Must be a realm administrator\")\n\n        # Now verify an administrator can do it\n        self.login(\"iago@zulip.com\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_successful_invite_user_with_notifications_stream(self):\n        # type: () -> None\n        \"\"\"\n        A call to /json/invite_users with valid parameters unconditionally\n        subscribes the invitee to the notifications stream if it exists and is\n        public.\n        \"\"\"\n        realm = get_realm('zulip')\n        notifications_stream = get_stream('Verona', realm)\n        realm.notifications_stream = notifications_stream\n        realm.save()\n\n        self.login(self.example_email(\"hamlet\"))\n        invitee = 'alice-test@zulip.com'\n        self.assert_json_success(self.invite(invitee, ['Denmark']))\n        self.assertTrue(find_key_by_email(invitee))\n        self.check_sent_emails([invitee])\n\n        prereg_user = get_prereg_user_by_email(invitee)\n        streams = list(prereg_user.streams.all())\n        self.assertTrue(notifications_stream in streams)\n\n    def test_invite_user_signup_initial_history(self):\n        # type: () -> None\n        \"\"\"\n        Test that a new user invited to a stream receives some initial\n        history but only from public streams.\n        \"\"\"\n        self.login(self.example_email('hamlet'))\n        user_profile = self.example_user('hamlet')\n        private_stream_name = \"Secret\"\n        self.make_stream(private_stream_name, invite_only=True)\n        self.subscribe_to_stream(user_profile.email, private_stream_name)\n        public_msg_id = self.send_message(self.example_email(\"hamlet\"), \"Denmark\", Recipient.STREAM,\n                                          \"Public topic\", \"Public message\")\n        secret_msg_id = self.send_message(self.example_email(\"hamlet\"), private_stream_name, Recipient.STREAM,\n                                          \"Secret topic\", \"Secret message\")\n        invitee = self.nonreg_email('alice')\n        self.assert_json_success(self.invite(invitee, [private_stream_name, \"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user('alice')\n        invitee_msg_ids = [um.message_id for um in\n                           UserMessage.objects.filter(user_profile=invitee_profile)]\n        self.assertTrue(public_msg_id in invitee_msg_ids)\n        self.assertFalse(secret_msg_id in invitee_msg_ids)\n\n    def test_multi_user_invite(self):\n        # type: () -> None\n        \"\"\"\n        Invites multiple users with a variety of delimiters.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        # Intentionally use a weird string.\n        self.assert_json_success(self.invite(\n            \"\"\"bob-test@zulip.com,     carol-test@zulip.com,\n            dave-test@zulip.com\n\n\nearl-test@zulip.com\"\"\", [\"Denmark\"]))\n        for user in (\"bob\", \"carol\", \"dave\", \"earl\"):\n            self.assertTrue(find_key_by_email(\"%s-test@zulip.com\" % (user,)))\n        self.check_sent_emails([\"bob-test@zulip.com\", \"carol-test@zulip.com\",\n                                \"dave-test@zulip.com\", \"earl-test@zulip.com\"])\n\n    def test_missing_or_invalid_params(self):\n        # type: () -> None\n        \"\"\"\n        Tests inviting with various missing or invalid parameters.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        self.assert_json_error(\n            self.client_post(\"/json/invite_users\", {\"invitee_emails\": \"foo@zulip.com\",\n                                                    \"custom_body\": ''}),\n            \"You must specify at least one stream for invitees to join.\")\n\n        for address in (\"noatsign.com\", \"outsideyourdomain@example.net\"):\n            self.assert_json_error(\n                self.invite(address, [\"Denmark\"]),\n                \"Some emails did not validate, so we didn't send any invitations.\")\n        self.check_sent_emails([])\n\n        self.assert_json_error(\n            self.invite(\"\", [\"Denmark\"]),\n            \"You must specify at least one email address.\")\n        self.check_sent_emails([])\n\n    def test_invalid_stream(self):\n        # type: () -> None\n        \"\"\"\n        Tests inviting to a non-existent stream.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        self.assert_json_error(self.invite(\"iago-test@zulip.com\", [\"NotARealStream\"]),\n                               \"Stream does not exist: NotARealStream. No invites were sent.\")\n        self.check_sent_emails([])\n\n    def test_invite_existing_user(self):\n        # type: () -> None\n        \"\"\"\n        If you invite an address already using Zulip, no invitation is sent.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        self.assert_json_error(\n            self.client_post(\"/json/invite_users\",\n                             {\"invitee_emails\": self.example_email(\"hamlet\"),\n                              \"stream\": [\"Denmark\"],\n                              \"custom_body\": ''}),\n            \"We weren't able to invite anyone.\")\n        self.assertRaises(PreregistrationUser.DoesNotExist,\n                          lambda: PreregistrationUser.objects.get(\n                              email=self.example_email(\"hamlet\")))\n        self.check_sent_emails([])\n\n    def test_invite_some_existing_some_new(self):\n        # type: () -> None\n        \"\"\"\n        If you invite a mix of already existing and new users, invitations are\n        only sent to the new users.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        existing = [self.example_email(\"hamlet\"), u\"othello@zulip.com\"]\n        new = [u\"foo-test@zulip.com\", u\"bar-test@zulip.com\"]\n\n        result = self.client_post(\"/json/invite_users\",\n                                  {\"invitee_emails\": \"\\n\".join(existing + new),\n                                   \"stream\": [\"Denmark\"],\n                                   \"custom_body\": ''})\n        self.assert_json_error(result,\n                               \"Some of those addresses are already using Zulip, \\\nso we didn't send them an invitation. We did send invitations to everyone else!\")\n\n        # We only created accounts for the new users.\n        for email in existing:\n            self.assertRaises(PreregistrationUser.DoesNotExist,\n                              lambda: PreregistrationUser.objects.get(\n                                  email=email))\n        for email in new:\n            self.assertTrue(PreregistrationUser.objects.get(email=email))\n\n        # We only sent emails to the new users.\n        self.check_sent_emails(new)\n\n        prereg_user = get_prereg_user_by_email('foo-test@zulip.com')\n        self.assertEqual(prereg_user.email, 'foo-test@zulip.com')\n\n    def test_invite_outside_domain_in_closed_realm(self):\n        # type: () -> None\n        \"\"\"\n        In a realm with `restricted_to_domain = True`, you can't invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.restricted_to_domain = True\n        zulip_realm.save()\n\n        self.login(self.example_email(\"hamlet\"))\n        external_address = \"foo@example.com\"\n\n        self.assert_json_error(\n            self.invite(external_address, [\"Denmark\"]),\n            \"Some emails did not validate, so we didn't send any invitations.\")\n\n    def test_invite_outside_domain_in_open_realm(self):\n        # type: () -> None\n        \"\"\"\n        In a realm with `restricted_to_domain = False`, you can invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.restricted_to_domain = False\n        zulip_realm.save()\n\n        self.login(self.example_email(\"hamlet\"))\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n    def test_invite_outside_domain_before_closing(self):\n        # type: () -> None\n        \"\"\"\n        If you invite someone with a different domain from that of the realm\n        when `restricted_to_domain = False`, but `restricted_to_domain` later\n        changes to true, the invitation should succeed but the invitee's signup\n        attempt should fail.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.restricted_to_domain = False\n        zulip_realm.save()\n\n        self.login(self.example_email(\"hamlet\"))\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.restricted_to_domain = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(\"foo@example.com\", \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"only allows users with e-mail\", result)\n\n    def test_invite_with_non_ascii_streams(self):\n        # type: () -> None\n        \"\"\"\n        Inviting someone to streams with non-ASCII characters succeeds.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        invitee = \"alice-test@zulip.com\"\n\n        stream_name = u\"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Make sure we're subscribed before inviting someone.\n        self.subscribe_to_stream(self.example_email(\"hamlet\"), stream_name)\n\n        self.assert_json_success(self.invite(invitee, [stream_name]))\n\n    def test_refer_friend(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"))\n        user = self.example_user('hamlet')\n        user.invites_granted = 1\n        user.invites_used = 0\n        user.save()\n\n        invitee = \"alice-test@zulip.com\"\n        result = self.client_post('/json/refer_friend', dict(email=invitee))\n        self.assert_json_success(result)\n\n        # verify this works\n        Referral.objects.get(user_profile=user, email=invitee)\n\n        user = self.example_user('hamlet')\n        self.assertEqual(user.invites_used, 1)\n\n    def test_refer_friend_no_email(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"))\n        user = self.example_user('hamlet')\n        user.invites_granted = 1\n        user.invites_used = 0\n        user.save()\n\n        self.assert_json_error(\n            self.client_post('/json/refer_friend', dict(email='')),\n            \"No email address specified\")\n\n        user = self.example_user('hamlet')\n        self.assertEqual(user.invites_used, 0)\n\n    def test_refer_friend_no_invites(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"))\n        user = self.example_user('hamlet')\n        user.invites_granted = 1\n        user.invites_used = 1\n        user.save()\n\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_error(\n            self.client_post('/json/refer_friend', dict(email=invitee)),\n            \"Insufficient invites\")\n\n        user = self.example_user('hamlet')\n        self.assertEqual(user.invites_used, 1)\n\n    def test_invitation_reminder_email(self):\n        # type: () -> None\n        from django.core.mail import outbox\n\n        # All users belong to zulip realm\n        referrer_user = 'hamlet'\n        current_user_email = self.example_email(referrer_user)\n        self.login(current_user_email)\n        invitee = self.nonreg_email('alice')\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n        self.check_sent_emails([invitee])\n\n        data = {\"email\": invitee, \"referrer_email\": current_user_email}\n        invitee = get_prereg_user_by_email(data[\"email\"])\n        referrer = self.example_user(referrer_user)\n        link = Confirmation.objects.get_link_for_object(invitee, host=referrer.realm.host)\n        context = common_context(referrer)\n        context.update({\n            'activate_url': link,\n            'referrer_name': referrer.full_name,\n            'referrer_email': referrer.email,\n            'referrer_realm_name': referrer.realm.name,\n            'verbose_support_offers': settings.VERBOSE_SUPPORT_OFFERS,\n            'support_email': settings.ZULIP_ADMINISTRATOR\n        })\n        with self.settings(EMAIL_BACKEND='django.core.mail.backends.console.EmailBackend'):\n            send_future_email(\n                \"zerver/emails/invitation_reminder\", data[\"email\"],\n                from_email=settings.ZULIP_ADMINISTRATOR, context=context)\n        email_jobs_to_deliver = ScheduledJob.objects.filter(\n            type=ScheduledJob.EMAIL,\n            scheduled_timestamp__lte=timezone_now())\n        self.assertEqual(len(email_jobs_to_deliver), 1)\n        email_count = len(outbox)\n        for job in email_jobs_to_deliver:\n            self.assertTrue(send_email(**ujson.loads(job.data)))\n        self.assertEqual(len(outbox), email_count + 1)\n\nclass InviteeEmailsParserTests(TestCase):\n    def setUp(self):\n        # type: () -> None\n        self.email1 = \"email1@zulip.com\"\n        self.email2 = \"email2@zulip.com\"\n        self.email3 = \"email3@zulip.com\"\n\n    def test_if_emails_separated_by_commas_are_parsed_and_striped_correctly(self):\n        # type: () -> None\n        emails_raw = \"{} ,{}, {}\".format(self.email1, self.email2, self.email3)\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_separated_by_newlines_are_parsed_and_striped_correctly(self):\n        # type: () -> None\n        emails_raw = \"{}\\n {}\\n {} \".format(self.email1, self.email2, self.email3)\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_from_email_client_separated_by_newlines_are_parsed_correctly(self):\n        # type: () -> None\n        emails_raw = \"Email One <{}>\\nEmailTwo<{}>\\nEmail Three<{}>\".format(self.email1, self.email2, self.email3)\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_in_mixed_style_are_parsed_correctly(self):\n        # type: () -> None\n        emails_raw = \"Email One <{}>,EmailTwo<{}>\\n{}\".format(self.email1, self.email2, self.email3)\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n\nclass EmailUnsubscribeTests(ZulipTestCase):\n    def test_error_unsubscribe(self):\n        # type: () -> None\n\n        # An invalid insubscribe token \"test123\" produces an error.\n        result = self.client_get('/accounts/unsubscribe/missed_messages/test123')\n        self.assert_in_response('Unknown email unsubscribe request', result)\n\n        # An unknown message type \"fake\" produces an error.\n        user_profile = self.example_user('hamlet')\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"fake\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n        self.assert_in_response('Unknown email unsubscribe request', result)\n\n    def test_missedmessage_unsubscribe(self):\n        # type: () -> None\n        \"\"\"\n        We provide one-click unsubscribe links in missed message\n        e-mails that you can click even when logged out to update your\n        email notification settings.\n        \"\"\"\n        user_profile = self.example_user('hamlet')\n        user_profile.enable_offline_email_notifications = True\n        user_profile.save()\n\n        unsubscribe_link = one_click_unsubscribe_link(user_profile,\n                                                      \"missed_messages\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        self.assertEqual(result.status_code, 200)\n        # Circumvent user_profile caching.\n        user_profile = UserProfile.objects.get(email=self.example_email(\"hamlet\"))\n        self.assertFalse(user_profile.enable_offline_email_notifications)\n\n    def test_welcome_unsubscribe(self):\n        # type: () -> None\n        \"\"\"\n        We provide one-click unsubscribe links in welcome e-mails that you can\n        click even when logged out to stop receiving them.\n        \"\"\"\n        email = self.example_email(\"hamlet\")\n        user_profile = self.example_user('hamlet')\n\n        # Simulate a new user signing up, which enqueues 2 welcome e-mails.\n        enqueue_welcome_emails(email, \"King Hamlet\")\n        self.assertEqual(2, len(ScheduledJob.objects.filter(\n            type=ScheduledJob.EMAIL, filter_string__iexact=email)))\n\n        # Simulate unsubscribing from the welcome e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"welcome\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        # The welcome email jobs are no longer scheduled.\n        self.assertEqual(result.status_code, 200)\n        self.assertEqual(0, len(ScheduledJob.objects.filter(\n            type=ScheduledJob.EMAIL, filter_string__iexact=email)))\n\n    def test_digest_unsubscribe(self):\n        # type: () -> None\n        \"\"\"\n        We provide one-click unsubscribe links in digest e-mails that you can\n        click even when logged out to stop receiving them.\n\n        Unsubscribing from these emails also dequeues any digest email jobs that\n        have been queued.\n        \"\"\"\n        email = self.example_email(\"hamlet\")\n        user_profile = self.example_user('hamlet')\n        self.assertTrue(user_profile.enable_digest_emails)\n\n        # Enqueue a fake digest email.\n        context = {'name': '', 'realm_uri': '', 'unread_pms': [], 'hot_conversations': [],\n                   'new_users': [], 'new_streams': {'plain': []}, 'unsubscribe_link': ''}\n        send_future_email('zerver/emails/digest', display_email(user_profile), context=context)\n\n        self.assertEqual(1, len(ScheduledJob.objects.filter(\n            type=ScheduledJob.EMAIL, filter_string__iexact=email)))\n\n        # Simulate unsubscribing from digest e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"digest\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        # The setting is toggled off, and scheduled jobs have been removed.\n        self.assertEqual(result.status_code, 200)\n        # Circumvent user_profile caching.\n        user_profile = UserProfile.objects.get(email=self.example_email(\"hamlet\"))\n        self.assertFalse(user_profile.enable_digest_emails)\n        self.assertEqual(0, len(ScheduledJob.objects.filter(\n            type=ScheduledJob.EMAIL, filter_string__iexact=email)))\n\nclass RealmCreationTest(ZulipTestCase):\n\n    def test_create_realm(self):\n        # type: () -> None\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm = get_realm('test')\n\n        # Make sure the realm does not exist\n        self.assertIsNone(realm)\n\n        with self.settings(OPEN_REALM_CREATION=True):\n            # Create new realm with the email\n            result = self.client_post('/create_realm/', {'email': email})\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result[\"Location\"].endswith(\n                \"/accounts/send_confirm/%s\" % (email,)))\n            result = self.client_get(result[\"Location\"])\n            self.assert_in_response(\"Check your email so we can get started.\", result)\n\n            # Visit the confirmation link.\n            confirmation_url = self.get_confirmation_url_from_outbox(email)\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(email, password, realm_subdomain=string_id)\n            self.assertEqual(result.status_code, 302)\n\n            # Make sure the realm is created\n            realm = get_realm(string_id)\n            self.assertIsNotNone(realm)\n            self.assertEqual(realm.string_id, string_id)\n            self.assertEqual(get_user(email, realm).realm, realm)\n\n            # Check defaults\n            self.assertEqual(realm.org_type, Realm.COMMUNITY)\n            self.assertEqual(realm.restricted_to_domain, False)\n            self.assertEqual(realm.invite_required, True)\n\n            self.assertTrue(result[\"Location\"].endswith(\"/\"))\n\n            # Check welcome messages\n            for stream_name in ['general', 'social', 'zulip']:\n                stream = get_stream(stream_name, realm)\n                recipient = get_recipient(Recipient.STREAM, stream.id)\n                messages = Message.objects.filter(recipient=recipient)\n                self.assertEqual(len(messages), 1)\n                self.assertIn('Welcome to', messages[0].content)\n\n    def test_create_realm_existing_email(self):\n        # type: () -> None\n        \"\"\"\n        Trying to create a realm with an existing email should just redirect to\n        a login page.\n        \"\"\"\n        with self.settings(OPEN_REALM_CREATION=True):\n            email = self.example_email(\"hamlet\")\n            result = self.client_post('/create_realm/', {'email': email})\n            self.assertEqual(result.status_code, 302)\n            self.assertIn('login', result['Location'])\n\n    def test_create_realm_no_creation_key(self):\n        # type: () -> None\n        \"\"\"\n        Trying to create a realm without a creation_key should fail when\n        OPEN_REALM_CREATION is false.\n        \"\"\"\n        email = \"user1@test.com\"\n        realm = get_realm('test')\n\n        # Make sure the realm does not exist\n        self.assertIsNone(realm)\n\n        with self.settings(OPEN_REALM_CREATION=False):\n            # Create new realm with the email, but no creation key.\n            result = self.client_post('/create_realm/', {'email': email})\n            self.assertEqual(result.status_code, 200)\n            self.assert_in_response('New organization creation disabled.', result)\n\n    def test_create_realm_with_subdomain(self):\n        # type: () -> None\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        self.assertIsNone(get_realm('test'))\n\n        with self.settings(REALMS_HAVE_SUBDOMAINS=True), self.settings(OPEN_REALM_CREATION=True):\n            # Create new realm with the email\n            result = self.client_post('/create_realm/', {'email': email})\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result[\"Location\"].endswith(\n                \"/accounts/send_confirm/%s\" % (email,)))\n            result = self.client_get(result[\"Location\"])\n            self.assert_in_response(\"Check your email so we can get started.\", result)\n\n            # Visit the confirmation link.\n            confirmation_url = self.get_confirmation_url_from_outbox(email)\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(email, password,\n                                                   realm_subdomain = string_id,\n                                                   realm_name=realm_name,\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=string_id + \".testserver\")\n            self.assertEqual(result.status_code, 302)\n\n            # Make sure the realm is created\n            realm = get_realm(string_id)\n            self.assertIsNotNone(realm)\n            self.assertEqual(realm.string_id, string_id)\n            self.assertEqual(get_user(email, realm).realm, realm)\n\n            self.assertEqual(realm.name, realm_name)\n            self.assertEqual(realm.subdomain, string_id)\n\n    def test_mailinator_signup(self):\n        # type: () -> None\n        with self.settings(OPEN_REALM_CREATION=True):\n            result = self.client_post('/create_realm/', {'email': \"hi@mailinator.com\"})\n            self.assert_in_response('Please use your real email address.', result)\n\n    def test_subdomain_restrictions(self):\n        # type: () -> None\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        with self.settings(REALMS_HAVE_SUBDOMAINS=False), self.settings(OPEN_REALM_CREATION=True):\n            result = self.client_post('/create_realm/', {'email': email})\n            self.client_get(result[\"Location\"])\n            confirmation_url = self.get_confirmation_url_from_outbox(email)\n            self.client_get(confirmation_url)\n\n            errors = {'id': \"at least 3 characters\",\n                      '-id': \"cannot start or end with a\",\n                      'string-ID': \"lowercase letters\",\n                      'string_id': \"lowercase letters\",\n                      'stream': \"unavailable\",\n                      'streams': \"unavailable\",\n                      'about': \"unavailable\",\n                      'abouts': \"unavailable\",\n                      'zephyr': \"unavailable\"}\n            for string_id, error_msg in errors.items():\n                result = self.submit_reg_form_for_user(email, password,\n                                                       realm_subdomain = string_id,\n                                                       realm_name = realm_name)\n                self.assert_in_response(error_msg, result)\n\n            # test valid subdomain\n            result = self.submit_reg_form_for_user(email, password,\n                                                   realm_subdomain = 'a-0',\n                                                   realm_name = realm_name)\n            self.assertEqual(result.status_code, 302)\n\nclass UserSignUpTest(ZulipTestCase):\n\n    def test_user_default_language_and_timezone(self):\n        # type: () -> None\n        \"\"\"\n        Check if the default language of new user is the default language\n        of the realm.\n        \"\"\"\n        email = self.nonreg_email('newguy')\n        password = \"newpassword\"\n        timezone = \"US/Mountain\"\n        realm = get_realm('zulip')\n        do_set_realm_property(realm, 'default_language', u\"de\")\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS.\n        result = self.submit_reg_form_for_user(email, password, timezone=timezone)\n        self.assertEqual(result.status_code, 302)\n\n        user_profile = self.nonreg_user('newguy')\n        self.assertEqual(user_profile.default_language, realm.default_language)\n        self.assertEqual(user_profile.timezone, timezone)\n        from django.core.mail import outbox\n        outbox.pop()\n\n    def test_signup_already_active(self):\n        # type: () -> None\n        \"\"\"\n        Check if signing up with an active email redirects to a login page.\n        \"\"\"\n        email = self.example_email(\"hamlet\")\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertIn('login', result['Location'])\n\n    def test_signup_invalid_name(self):\n        # type: () -> None\n        \"\"\"\n        Check if an invalid name during signup is handled properly.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS.\n        result = self.submit_reg_form_for_user(email, password, full_name=\"<invalid>\")\n        self.assert_in_success_response([\"Invalid characters in name!\"], result)\n\n    def test_signup_without_password(self):\n        # type: () -> None\n        \"\"\"\n        Check if signing up without a password works properly when\n        password_auth_enabled is False.\n        \"\"\"\n\n        email = self.nonreg_email('newuser')\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        with patch('zerver.views.registration.password_auth_enabled', return_value=False):\n            result = self.client_post(\n                '/accounts/register/',\n                {'full_name': 'New User',\n                 'realm_name': 'Zulip Test',\n                 'realm_subdomain': 'zuliptest',\n                 'key': find_key_by_email(email),\n                 'realm_org_type': Realm.COMMUNITY,\n                 'terms': True})\n\n        # User should now be logged in.\n        self.assertEqual(result.status_code, 302)\n        user_profile = self.nonreg_user('newuser')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_signup_without_full_name(self):\n        # type: () -> None\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.client_post(\n            '/accounts/register/',\n            {'password': password,\n             'realm_name': 'Zulip Test',\n             'realm_subdomain': 'zuliptest',\n             'key': find_key_by_email(email),\n             'realm_org_type': Realm.COMMUNITY,\n             'terms': True,\n             'from_confirmation': '1'})\n        self.assert_in_success_response([\"You're almost there.\"], result)\n\n    def test_signup_with_full_name(self):\n        # type: () -> None\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.client_post(\n            '/accounts/register/',\n            {'password': password,\n             'realm_name': 'Zulip Test',\n             'realm_subdomain': 'zuliptest',\n             'key': find_key_by_email(email),\n             'realm_org_type': Realm.COMMUNITY,\n             'terms': True,\n             'full_name': \"New Guy\",\n             'from_confirmation': '1'})\n        self.assert_in_success_response([\"You're almost there.\"], result)\n\n    def test_signup_invalid_subdomain(self):\n        # type: () -> None\n        \"\"\"\n        Check if attempting to authenticate to the wrong subdomain logs an\n        error and redirects.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        def invalid_subdomain(**kwargs):\n            # type: (**Any) -> Any\n            return_data = kwargs.get('return_data', {})\n            return_data['invalid_subdomain'] = True\n\n        with patch('zerver.views.registration.authenticate', side_effect=invalid_subdomain):\n            with patch('logging.error') as mock_error:\n                result = self.client_post(\n                    '/accounts/register/',\n                    {'password': password,\n                     'full_name': 'New User',\n                     'realm_name': 'Zulip Test',\n                     'realm_subdomain': 'zuliptest',\n                     'key': find_key_by_email(email),\n                     'realm_org_type': Realm.COMMUNITY,\n                     'terms': True})\n        mock_error.assert_called_once()\n        self.assertEqual(result.status_code, 302)\n\n    def test_unique_completely_open_domain(self):\n        # type: () -> None\n        password = \"test\"\n        email = \"user1@acme.com\"\n        subdomain = \"zulip\"\n        realm_name = \"Zulip\"\n\n        realm = get_realm('zulip')\n        realm.restricted_to_domain = False\n        realm.invite_required = False\n        realm.save()\n\n        for string_id in ('simple', 'zephyr'):\n            realm = get_realm(string_id)\n            do_deactivate_realm(realm)\n            realm.save()\n\n        result = self.client_post('/register/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n        for message in reversed(outbox):\n            if email in message.to:\n                confirmation_link_pattern = re.compile(settings.EXTERNAL_HOST + \"(\\S+)>\")\n                confirmation_url = confirmation_link_pattern.search(\n                    message.body).groups()[0]\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email,\n                                               password,\n                                               realm_name=realm_name,\n                                               realm_subdomain=subdomain,\n                                               # Pass HTTP_HOST for the target subdomain\n                                               HTTP_HOST=subdomain + \".testserver\")\n        self.assert_in_success_response([\"You're almost there.\"], result)\n\n    def test_completely_open_domain_success(self):\n        # type: () -> None\n        password = \"test\"\n        email = \"user1@acme.com\"\n        subdomain = \"zulip\"\n        realm_name = \"Zulip\"\n\n        realm = get_realm('zulip')\n        realm.restricted_to_domain = False\n        realm.invite_required = False\n        realm.save()\n\n        result = self.client_post('/register/zulip/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n        for message in reversed(outbox):\n            if email in message.to:\n                confirmation_link_pattern = re.compile(settings.EXTERNAL_HOST + \"(\\S+)>\")\n                confirmation_url = confirmation_link_pattern.search(\n                    message.body).groups()[0]\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email,\n                                               password,\n                                               realm_name=realm_name,\n                                               realm_subdomain=subdomain,\n                                               # Pass HTTP_HOST for the target subdomain\n                                               HTTP_HOST=subdomain + \".testserver\")\n        self.assert_in_success_response([\"You're almost there.\"], result)\n\n    def test_failed_signup_with_realm_str(self):\n        # type: () -> None\n        \"\"\"\n        Signing up with the special accounts_home_with_realm_str endpoint should\n        fail (i.e. redirect to the standard accounts_home) if\n        settings.REALMS_HAVE_SUBDOMAINS is true, or if the realm is not\n        completely open.\n        \"\"\"\n        realm = get_realm('zulip')\n        realm.restricted_to_domain = False\n        realm.invite_required = False\n        realm.save()\n        with self.settings(REALMS_HAVE_SUBDOMAINS=True):\n            email = 'user1@acme.com'\n            result = self.client_post('/register/zulip/', {'email': email})\n            self.assertEqual(result.status_code, 302)\n            self.assertIn('accounts/home', result['Location'])\n\n        realm = get_realm('zulip')\n        realm.invite_required = True\n        realm.save()\n        with self.settings(REALMS_HAVE_SUBDOMAINS=False):\n            email = 'user1@acme.com'\n            result = self.client_post('/register/zulip/', {'email': email})\n            self.assertEqual(result.status_code, 302)\n            self.assertIn('accounts/home', result['Location'])\n\n    def test_failed_signup_due_to_restricted_domain(self):\n        # type: () -> None\n        realm = get_realm('zulip')\n        realm.invite_required = False\n        realm.save()\n        with self.settings(REALMS_HAVE_SUBDOMAINS = True):\n            request = HostRequestMock(host = realm.host)\n            request.session = {} # type: ignore\n            email = 'user@acme.com'\n            form = HomepageForm({'email': email}, realm=realm)\n            self.assertIn(\"Your email address, {}, is not in one of the domains\".format(email),\n                          form.errors['email'][0])\n\n    def test_failed_signup_due_to_invite_required(self):\n        # type: () -> None\n        realm = get_realm('zulip')\n        realm.invite_required = True\n        realm.save()\n        request = HostRequestMock(host = realm.host)\n        request.session = {} # type: ignore\n        email = 'user@zulip.com'\n        form = HomepageForm({'email': email}, realm=realm)\n        self.assertIn(\"Please request an invite for {} from\".format(email),\n                      form.errors['email'][0])\n\n    def test_failed_signup_due_to_nonexistent_realm(self):\n        # type: () -> None\n        with self.settings(REALMS_HAVE_SUBDOMAINS = True):\n            request = HostRequestMock(host = 'acme.' + settings.EXTERNAL_HOST)\n            request.session = {} # type: ignore\n            email = 'user@acme.com'\n            form = HomepageForm({'email': email}, realm=None)\n            self.assertIn(\"organization you are trying to join using {} does \"\n                          \"not exist\".format(email), form.errors['email'][0])\n\n    def test_registration_through_ldap(self):\n        # type: () -> None\n        password = \"testing\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        realm_name = \"Zulip\"\n        ldap_user_attr_map = {'full_name': 'fn', 'short_name': 'sn'}\n\n        ldap_patcher = patch('django_auth_ldap.config.ldap.initialize')\n        mock_initialize = ldap_patcher.start()\n        mock_ldap = MockLDAP()\n        mock_initialize.return_value = mock_ldap\n\n        mock_ldap.directory = {\n            'uid=newuser,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing',\n                'fn': ['New User Name']\n            }\n        }\n\n        with patch('zerver.views.registration.get_subdomain', return_value=subdomain):\n            result = self.client_post('/register/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n        for message in reversed(outbox):\n            if email in message.to:\n                confirmation_link_pattern = re.compile(settings.EXTERNAL_HOST + \"(\\S+)>\")\n                confirmation_url = confirmation_link_pattern.search(\n                    message.body).groups()[0]\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n                POPULATE_PROFILE_VIA_LDAP=True,\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n                AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',),\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            # The full_name should not be overriden by the value from LDAP if\n            # request.session['authenticated_full_name'] has not been set yet.\n            with patch('zerver.views.registration.name_changes_disabled', return_value=True):\n                result = self.submit_reg_form_for_user(email,\n                                                       password,\n                                                       full_name=\"Non LDAP Full Name\",\n                                                       realm_name=realm_name,\n                                                       realm_subdomain=subdomain,\n                                                       # Pass HTTP_HOST for the target subdomain\n                                                       HTTP_HOST=subdomain + \".testserver\")\n            self.assert_in_success_response([\"You're almost there.\",\n                                             \"Non LDAP Full Name\",\n                                             \"newuser@zulip.com\"],\n                                            result)\n\n            # Submitting the registration form with from_confirmation='1' sets\n            # the value of request.session['authenticated_full_name'] from LDAP.\n            result = self.submit_reg_form_for_user(email,\n                                                   password,\n                                                   realm_name=realm_name,\n                                                   realm_subdomain=subdomain,\n                                                   from_confirmation='1',\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=subdomain + \".testserver\")\n            self.assert_in_success_response([\"You're almost there.\",\n                                             \"New User Name\",\n                                             \"newuser@zulip.com\"],\n                                            result)\n\n            # The full name be populated from the value of\n            # request.session['authenticated_full_name'] from LDAP in the case\n            # where from_confirmation and name_changes_disabled are both False.\n            with patch('zerver.views.registration.name_changes_disabled', return_value=True):\n                result = self.submit_reg_form_for_user(email,\n                                                       password,\n                                                       full_name=\"Non LDAP Full Name\",\n                                                       realm_name=realm_name,\n                                                       realm_subdomain=subdomain,\n                                                       # Pass HTTP_HOST for the target subdomain\n                                                       HTTP_HOST=subdomain + \".testserver\")\n            self.assert_in_success_response([\"You're almost there.\",\n                                             \"New User Name\",\n                                             \"newuser@zulip.com\"],\n                                            result)\n\n            # Test the TypeError exception handler\n            mock_ldap.directory = {\n                'uid=newuser,ou=users,dc=zulip,dc=com': {\n                    'userPassword': 'testing',\n                    'fn': None  # This will raise TypeError\n                }\n            }\n            result = self.submit_reg_form_for_user(email,\n                                                   password,\n                                                   realm_name=realm_name,\n                                                   realm_subdomain=subdomain,\n                                                   from_confirmation='1',\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=subdomain + \".testserver\")\n            self.assert_in_success_response([\"You're almost there.\",\n                                             \"newuser@zulip.com\"],\n                                            result)\n\n        mock_ldap.reset()\n        mock_initialize.stop()\n\n    @patch('DNS.dnslookup', return_value=[['sipbtest:*:20922:101:Fred Sipb,,,:/mit/sipbtest:/bin/athena/tcsh']])\n    def test_registration_email_for_mirror_dummy_user(self, ignored):\n        # type: (Any) -> None\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.email\n        user_profile.is_mirror_dummy = True\n        user_profile.is_active = False\n        user_profile.save()\n\n        with self.settings(REALMS_HAVE_SUBDOMAINS=True):\n            with patch('zerver.forms.get_subdomain', return_value='zephyr'):\n                with patch('zerver.views.registration.get_subdomain', return_value='zephyr'):\n                    result = self.client_post('/accounts/home/', {'email': email})\n                    self.assertEqual(result.status_code, 302)\n\n        from django.core.mail import outbox\n        for message in reversed(outbox):\n            if email in message.to:\n                # The main difference between the zephyr registation email\n                # and the normal one is this string\n                index = message.body.find('https://zephyr.zulipchat.com/zephyr')\n                if index >= 0:\n                    return\n        else:\n            raise AssertionError(\"Couldn't find the right confirmation email.\")\n\n    @patch('DNS.dnslookup', return_value=[['sipbtest:*:20922:101:Fred Sipb,,,:/mit/sipbtest:/bin/athena/tcsh']])\n    def test_registration_of_mirror_dummy_user(self, ignored):\n        # type: (Any) -> None\n        password = \"test\"\n        subdomain = \"sipb\"\n        realm_name = \"MIT\"\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.email\n        user_profile.is_mirror_dummy = True\n        user_profile.is_active = False\n        user_profile.save()\n\n        result = self.client_post('/register/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n        for message in reversed(outbox):\n            if email in message.to:\n                confirmation_link_pattern = re.compile(settings.EXTERNAL_HOST + \"(\\S+)>\")\n                confirmation_url = confirmation_link_pattern.search(\n                    message.body).groups()[0]\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # If the mirror dummy user is already active, attempting to submit the\n        # registration form should just redirect to a login page.\n        user_profile.is_active = True\n        user_profile.save()\n        result = self.submit_reg_form_for_user(email,\n                                               password,\n                                               realm_name=realm_name,\n                                               realm_subdomain=subdomain,\n                                               from_confirmation='1',\n                                               # Pass HTTP_HOST for the target subdomain\n                                               HTTP_HOST=subdomain + \".testserver\")\n        self.assertEqual(result.status_code, 302)\n        self.assertIn('login', result['Location'])\n        user_profile.is_active = False\n        user_profile.save()\n\n        result = self.submit_reg_form_for_user(email,\n                                               password,\n                                               realm_name=realm_name,\n                                               realm_subdomain=subdomain,\n                                               from_confirmation='1',\n                                               # Pass HTTP_HOST for the target subdomain\n                                               HTTP_HOST=subdomain + \".testserver\")\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(email,\n                                               password,\n                                               realm_name=realm_name,\n                                               realm_subdomain=subdomain,\n                                               # Pass HTTP_HOST for the target subdomain\n                                               HTTP_HOST=subdomain + \".testserver\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_registration_of_active_mirror_dummy_user(self):\n        # type: (Any) -> None\n        \"\"\"\n        Trying to activate an already-active mirror dummy user should just\n        redirect to a login page.\n        \"\"\"\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.email\n        user_profile.is_mirror_dummy = True\n        user_profile.is_active = True\n        user_profile.save()\n\n        result = self.client_post('/register/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertIn('login', result['Location'])\n\nclass TestOpenRealms(ZulipTestCase):\n    def test_open_realm_logic(self):\n        # type: () -> None\n        realm = get_realm('simple')\n        do_deactivate_realm(realm)\n\n        mit_realm = get_realm(\"zephyr\")\n        self.assertEqual(get_unique_open_realm(), None)\n        mit_realm.restricted_to_domain = False\n        mit_realm.save()\n        self.assertTrue(completely_open(mit_realm))\n        self.assertEqual(get_unique_open_realm(), None)\n        with self.settings(SYSTEM_ONLY_REALMS={\"zulip\"}):\n            self.assertEqual(get_unique_open_realm(), mit_realm)\n        mit_realm.restricted_to_domain = True\n        mit_realm.save()\n\nclass DeactivateUserTest(ZulipTestCase):\n\n    def test_deactivate_user(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        self.login(email)\n        user = self.example_user('hamlet')\n        self.assertTrue(user.is_active)\n        result = self.client_delete('/json/users/me')\n        self.assert_json_success(result)\n        user = self.example_user('hamlet')\n        self.assertFalse(user.is_active)\n        self.login(email, fails=True)\n\n    def test_do_not_deactivate_final_admin(self):\n        # type: () -> None\n        email = self.example_email(\"iago\")\n        self.login(email)\n        user = self.example_user('iago')\n        self.assertTrue(user.is_active)\n        result = self.client_delete('/json/users/me')\n        self.assert_json_error(result, \"Cannot deactivate the only organization administrator\")\n        user = self.example_user('iago')\n        self.assertTrue(user.is_active)\n        self.assertTrue(user.is_realm_admin)\n        email = self.example_email(\"hamlet\")\n        user_2 = self.example_user('hamlet')\n        do_change_is_admin(user_2, True)\n        self.assertTrue(user_2.is_realm_admin)\n        result = self.client_delete('/json/users/me')\n        self.assert_json_success(result)\n        do_change_is_admin(user, True)\n\nclass TestLoginPage(ZulipTestCase):\n    def test_login_page_wrong_subdomain_error(self):\n        # type: () -> None\n        result = self.client_get(\"/login/?subdomain=1\")\n        self.assertIn(WRONG_SUBDOMAIN_ERROR, result.content.decode('utf8'))\n\n    @patch('django.http.HttpRequest.get_host')\n    def test_login_page_redirects_for_root_alias(self, mock_get_host):\n        # type: (MagicMock) -> None\n        mock_get_host.return_value = 'www.testserver'\n        with self.settings(REALMS_HAVE_SUBDOMAINS=True,\n                           ROOT_SUBDOMAIN_ALIASES=['www']):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, '/find_my_team/')\n\n    @patch('django.http.HttpRequest.get_host')\n    def test_login_page_redirects_for_root_domain(self, mock_get_host):\n        # type: (MagicMock) -> None\n        mock_get_host.return_value = 'testserver'\n        with self.settings(REALMS_HAVE_SUBDOMAINS=True,\n                           ROOT_SUBDOMAIN_ALIASES=['www']):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, '/find_my_team/')\n\n        mock_get_host.return_value = 'www.testserver.com'\n        with self.settings(REALMS_HAVE_SUBDOMAINS=True,\n                           EXTERNAL_HOST='www.testserver.com',\n                           ROOT_SUBDOMAIN_ALIASES=['test']):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, '/find_my_team/')\n\n    @patch('django.http.HttpRequest.get_host')\n    def test_login_page_works_without_subdomains(self, mock_get_host):\n        # type: (MagicMock) -> None\n        mock_get_host.return_value = 'www.testserver'\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=['www']):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = 'testserver'\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=['www']):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 200)\n\nclass TestFindMyTeam(ZulipTestCase):\n    def test_template(self):\n        # type: () -> None\n        result = self.client_get('/find_my_team/')\n        self.assertIn(\"Find your team\", result.content.decode('utf8'))\n\n    def test_result(self):\n        # type: () -> None\n        url = '/find_my_team/?emails=iago@zulip.com,cordelia@zulip.com'\n        result = self.client_get(url)\n        content = result.content.decode('utf8')\n        self.assertIn(\"Emails sent! You will only receive emails\", content)\n        self.assertIn(self.example_email(\"iago\"), content)\n        self.assertIn(self.example_email(\"cordelia\"), content)\n\n    def test_find_team_ignore_invalid_email(self):\n        # type: () -> None\n        url = '/find_my_team/?emails=iago@zulip.com,invalid_email'\n        result = self.client_get(url)\n        content = result.content.decode('utf8')\n        self.assertIn(\"Emails sent! You will only receive emails\", content)\n        self.assertIn(self.example_email(\"iago\"), content)\n        self.assertNotIn(\"invalid_email\", content)\n\n    def test_find_team_zero_emails(self):\n        # type: () -> None\n        data = {'emails': ''}\n        result = self.client_post('/find_my_team/', data)\n        self.assertIn('This field is required', result.content.decode('utf8'))\n        self.assertEqual(result.status_code, 200)\n\n    def test_find_team_one_email(self):\n        # type: () -> None\n        data = {'emails': self.example_email(\"hamlet\")}\n        result = self.client_post('/find_my_team/', data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, '/find_my_team/?emails=hamlet%40zulip.com')\n\n    def test_find_team_multiple_emails(self):\n        # type: () -> None\n        data = {'emails': 'hamlet@zulip.com,iago@zulip.com'}\n        result = self.client_post('/find_my_team/', data)\n        self.assertEqual(result.status_code, 302)\n        expected = '/find_my_team/?emails=hamlet%40zulip.com%2Ciago%40zulip.com'\n        self.assertEqual(result.url, expected)\n\n    def test_find_team_more_than_ten_emails(self):\n        # type: () -> None\n        data = {'emails': ','.join(['hamlet-{}@zulip.com'.format(i) for i in range(11)])}\n        result = self.client_post('/find_my_team/', data)\n        self.assertEqual(result.status_code, 200)\n        self.assertIn(\"Please enter at most 10\", result.content.decode('utf8'))\n\nclass ConfirmationKeyTest(ZulipTestCase):\n    def test_confirmation_key(self):\n        # type: () -> None\n        request = MagicMock()\n        request.session = {\n            'confirmation_key': {'confirmation_key': 'xyzzy'}\n        }\n        result = confirmation_key(request)\n        self.assert_json_success(result)\n        self.assert_in_response('xyzzy', result)\n\nclass MobileAuthOTPTest(ZulipTestCase):\n    def test_xor_hex_strings(self):\n        # type: () -> None\n        self.assertEqual(xor_hex_strings('1237c81ab', '18989fd12'), '0aaf57cb9')\n        with self.assertRaises(AssertionError):\n            xor_hex_strings('1', '31')\n\n    def test_is_valid_otp(self):\n        # type: () -> None\n        self.assertEqual(is_valid_otp('1234'), False)\n        self.assertEqual(is_valid_otp('1234abcd' * 8), True)\n        self.assertEqual(is_valid_otp('1234abcZ' * 8), False)\n\n    def test_ascii_to_hex(self):\n        # type: () -> None\n        self.assertEqual(ascii_to_hex('ZcdR1234'), '5a63645231323334')\n        self.assertEqual(hex_to_ascii('5a63645231323334'), 'ZcdR1234')\n\n    def test_otp_encrypt_api_key(self):\n        # type: () -> None\n        hamlet = self.example_user('hamlet')\n        hamlet.api_key = '12ac' * 8\n        otp = '7be38894' * 8\n        result = otp_encrypt_api_key(hamlet, otp)\n        self.assertEqual(result, '4ad1e9f7' * 8)\n\n        decryped = otp_decrypt_api_key(result, otp)\n        self.assertEqual(decryped, hamlet.api_key)\n\nclass LoginOrAskForRegistrationTestCase(ZulipTestCase):\n    def test_confirm(self):\n        # type: () -> None\n        request = POSTRequestMock({}, None)\n        email = 'new@zulip.com'\n        user_profile = None\n        full_name = 'New User'\n        invalid_subdomain = False\n        result = login_or_register_remote_user(\n            request,\n            email,\n            user_profile,\n            full_name=full_name,\n            invalid_subdomain=invalid_subdomain)\n        self.assert_in_response('You attempted to login using the email account',\n                                result)\n        self.assert_in_response('new@zulip.com, but this email address does not',\n                                result)\n\n    def test_invalid_subdomain(self):\n        # type: () -> None\n        request = POSTRequestMock({}, None)\n        email = 'new@zulip.com'\n        user_profile = None\n        full_name = 'New User'\n        invalid_subdomain = True\n        response = login_or_register_remote_user(\n            request,\n            email,\n            user_profile,\n            full_name=full_name,\n            invalid_subdomain=invalid_subdomain)\n        self.assertEqual(response.status_code, 302)\n        self.assertIn('/accounts/login/?subdomain=1', response.url)\n\n    def test_invalid_email(self):\n        # type: () -> None\n        request = POSTRequestMock({}, None)\n        email = None\n        user_profile = None\n        full_name = 'New User'\n        invalid_subdomain = False\n        response = login_or_register_remote_user(\n            request,\n            email,\n            user_profile,\n            full_name=full_name,\n            invalid_subdomain=invalid_subdomain)\n        self.assert_in_response('Please click the following button if '\n                                'you wish to register', response)\n\n    def test_login_under_subdomains(self):\n        # type: () -> None\n        request = POSTRequestMock({}, None)\n        setattr(request, 'session', self.client.session)\n        user_profile = self.example_user('hamlet')\n        user_profile.backend = 'zproject.backends.GitHubAuthBackend'\n        full_name = 'Hamlet'\n        invalid_subdomain = False\n        with self.settings(REALMS_HAVE_SUBDOMAINS=True):\n            response = login_or_register_remote_user(\n                request,\n                user_profile.email,\n                user_profile,\n                full_name=full_name,\n                invalid_subdomain=invalid_subdomain)\n            user_id = get_session_dict_user(getattr(request, 'session'))\n            self.assertEqual(user_id, user_profile.id)\n            self.assertEqual(response.status_code, 302)\n            self.assertIn('http://zulip.testserver', response.url)\n\n    def test_login_without_subdomains(self):\n        # type: () -> None\n        request = POSTRequestMock({}, None)\n        setattr(request, 'session', self.client.session)\n        setattr(request, 'get_host', lambda: 'localhost')\n        user_profile = self.example_user('hamlet')\n        user_profile.backend = 'zproject.backends.GitHubAuthBackend'\n        full_name = 'Hamlet'\n        invalid_subdomain = False\n        with self.settings(REALMS_HAVE_SUBDOMAINS=False):\n            response = login_or_register_remote_user(\n                request,\n                user_profile.email,\n                user_profile,\n                full_name=full_name,\n                invalid_subdomain=invalid_subdomain)\n            user_id = get_session_dict_user(getattr(request, 'session'))\n            self.assertEqual(user_id, user_profile.id)\n            self.assertEqual(response.status_code, 302)\n            self.assertIn('http://localhost', response.url)\n", "from __future__ import absolute_import\n\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.http import HttpRequest, HttpResponse\nfrom django.utils.translation import ugettext as _\nfrom typing import List, Optional, Set, Text\n\nfrom zerver.decorator import authenticated_json_post_view\nfrom zerver.lib.actions import do_invite_users, do_refer_friend, \\\n    get_default_subs, internal_send_message\nfrom zerver.lib.request import REQ, has_request_variables, JsonableError\nfrom zerver.lib.response import json_success, json_error\nfrom zerver.lib.streams import access_stream_by_name\nfrom zerver.lib.validator import check_string, check_list\nfrom zerver.models import PreregistrationUser, Stream, UserProfile\n\nimport re\n\n@authenticated_json_post_view\n@has_request_variables\ndef json_invite_users(request, user_profile,\n                      invitee_emails_raw=REQ(\"invitee_emails\"),\n                      body=REQ(\"custom_body\", default=None)):\n    # type: (HttpRequest, UserProfile, str, Optional[str]) -> HttpResponse\n    if user_profile.realm.invite_by_admins_only and not user_profile.is_realm_admin:\n        return json_error(_(\"Must be a realm administrator\"))\n    if not invitee_emails_raw:\n        return json_error(_(\"You must specify at least one email address.\"))\n    if body == '':\n        body = None\n\n    invitee_emails = get_invitee_emails_set(invitee_emails_raw)\n\n    stream_names = request.POST.getlist('stream')\n    if not stream_names:\n        return json_error(_(\"You must specify at least one stream for invitees to join.\"))\n\n    # We unconditionally sub you to the notifications stream if it\n    # exists and is public.\n    notifications_stream = user_profile.realm.notifications_stream  # type: Optional[Stream]\n    if notifications_stream and not notifications_stream.invite_only:\n        stream_names.append(notifications_stream.name)\n\n    streams = []  # type: List[Stream]\n    for stream_name in stream_names:\n        try:\n            (stream, recipient, sub) = access_stream_by_name(user_profile, stream_name)\n        except JsonableError:\n            return json_error(_(\"Stream does not exist: %s. No invites were sent.\") % (stream_name,))\n        streams.append(stream)\n\n    ret_error, error_data = do_invite_users(user_profile, invitee_emails, streams, body)\n\n    if ret_error is not None:\n        return json_error(data=error_data, msg=ret_error)\n    else:\n        return json_success()\n\ndef get_invitee_emails_set(invitee_emails_raw):\n    # type: (str) -> Set[str]\n    invitee_emails_list = set(re.split(r'[,\\n]', invitee_emails_raw))\n    invitee_emails = set()\n    for email in invitee_emails_list:\n        is_email_with_name = re.search(r'<(?P<email>.*)>', email)\n        if is_email_with_name:\n            email = is_email_with_name.group('email')\n        invitee_emails.add(email.strip())\n    return invitee_emails\n\n@authenticated_json_post_view\n@has_request_variables\ndef json_refer_friend(request, user_profile, email=REQ()):\n    # type: (HttpRequest, UserProfile, str) -> HttpResponse\n    if not email:\n        return json_error(_(\"No email address specified\"))\n    if user_profile.invites_granted - user_profile.invites_used <= 0:\n        return json_error(_(\"Insufficient invites\"))\n\n    do_refer_friend(user_profile, email)\n\n    return json_success()\n"], "filenames": ["zerver/tests/test_signup.py", "zerver/views/invite.py"], "buggy_code_start_loc": [425, 25], "buggy_code_end_loc": [425, 25], "fixing_code_start_loc": [426, 26], "fixing_code_end_loc": [449, 28], "type": "CWE-862", "message": "Zulip Server 1.5.1 and below suffer from an error in the implementation of the invite_by_admins_only setting in the Zulip group chat application server that allowed an authenticated user to invite other users to join a Zulip organization even if the organization was configured to prevent this.", "other": {"cve": {"id": "CVE-2017-0896", "sourceIdentifier": "support@hackerone.com", "published": "2017-06-02T17:29:00.167", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Zulip Server 1.5.1 and below suffer from an error in the implementation of the invite_by_admins_only setting in the Zulip group chat application server that allowed an authenticated user to invite other users to join a Zulip organization even if the organization was configured to prevent this."}, {"lang": "es", "value": "Zulip Server versi\u00f3n 1.5.1 y posteriores, sufre de un error en la implementaci\u00f3n de la configuraci\u00f3n de invite_by_admins_only en el servidor de aplicaciones de chat del grupo Zulip que permiti\u00f3 a un usuario autenticado invitar a otros usuarios a unirse a una organizaci\u00f3n Zulip, incluso si la organizaci\u00f3n fue configurada para evitar esto."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "03ECA4CD-B128-45EA-8A19-5F137BD08690"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:1.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "0609969D-7C68-4428-A2F3-EA532F6C4045"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:1.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "6141BC81-A452-44F0-9A61-B82772D406FF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:1.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "F3662F33-CC19-46AE-902F-2A685030FDE3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:1.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "7A20311C-FC51-4ED5-BCBC-955543FD1AF5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:1.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "B4CC0654-4F8C-4D1B-B06F-035368E7B120"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:1.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "13048A35-82DA-45AF-BB3C-AEBD1A80734B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:1.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "BE689D6F-F774-41AF-B97A-23973E22C9C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:1.3.9:*:*:*:*:*:*:*", "matchCriteriaId": "7C300421-CBDE-4DC2-A41E-38AFDD498725"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:1.3.10:*:*:*:*:*:*:*", "matchCriteriaId": "08DE09CC-3869-4686-A36D-F42788FC7118"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:1.3.11:*:*:*:*:*:*:*", "matchCriteriaId": "8A6AAE8C-F5E6-4A9C-9AF1-0D03EB9A7E97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:1.3.12:*:*:*:*:*:*:*", "matchCriteriaId": "612DA887-F6BC-45F8-B187-AE23CF2F1027"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:1.3.13:*:*:*:*:*:*:*", "matchCriteriaId": "A21AE1B1-5A7E-447A-9301-1AD965F04833"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:1.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "034098C9-DCC3-46CC-9534-811F28F4493D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:1.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "EA56546E-7E0A-49EB-967A-7219C907BE50"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:1.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "2CF03C39-6873-4044-96B8-760156D7B1BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:1.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "A0167E36-42E4-4DA5-96FB-CFF0EC8FDA38"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:1.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "3914FE1E-E734-4B4A-8266-25FB5C32800D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:1.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "B25BEDD5-B562-4A2E-8284-07A47CB1F6D3"}]}]}], "references": [{"url": "https://github.com/zulip/zulip/commit/1f48fa27672170bba3b9a97384905bb04c18761b", "source": "support@hackerone.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://groups.google.com/forum/#!msg/zulip-announce/sUYeJv-fFmg/2TU2TLmNAwAJ", "source": "support@hackerone.com"}, {"url": "https://hackerone.com/reports/224210", "source": "support@hackerone.com", "tags": ["Permissions Required"]}]}, "github_commit_url": "https://github.com/zulip/zulip/commit/1f48fa27672170bba3b9a97384905bb04c18761b"}}