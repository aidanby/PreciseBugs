{"buggy_code": ["/* -*- c-file-style: \"linux\" -*- */\n/*\n * v4l2loopback.c  --  video4linux2 loopback driver\n *\n * Copyright (C) 2005-2009 Vasily Levin (vasaka@gmail.com)\n * Copyright (C) 2010-2019 IOhannes m zmoelnig (zmoelnig@iem.at)\n * Copyright (C) 2011 Stefan Diewald (stefan.diewald@mytum.de)\n * Copyright (C) 2012 Anton Novikov (random.plant@gmail.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n */\n#include <linux/version.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/module.h>\n#include <linux/videodev2.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/eventpoll.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-common.h>\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 29)\n#define HAVE__V4L2_DEVICE\n#include <media/v4l2-device.h>\n#endif\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)\n#define HAVE__V4L2_CTRLS\n#include <media/v4l2-ctrls.h>\n#endif\n#include <media/v4l2-event.h>\n\n#include <linux/miscdevice.h>\n#include \"v4l2loopback.h\"\n\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 1)\n#define kstrtoul strict_strtoul\n#endif\n\n#if defined(timer_setup) && defined(from_timer)\n#define HAVE_TIMER_SETUP\n#endif\n\n#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 7, 0)\n#define VFL_TYPE_VIDEO VFL_TYPE_GRABBER\n#endif\n\n#define V4L2LOOPBACK_VERSION_CODE                                              \\\n\tKERNEL_VERSION(V4L2LOOPBACK_VERSION_MAJOR, V4L2LOOPBACK_VERSION_MINOR, \\\n\t\t       V4L2LOOPBACK_VERSION_BUGFIX)\n\nMODULE_DESCRIPTION(\"V4L2 loopback video device\");\nMODULE_AUTHOR(\"Vasily Levin, \"\n\t      \"IOhannes m zmoelnig <zmoelnig@iem.at>,\"\n\t      \"Stefan Diewald,\"\n\t      \"Anton Novikov\"\n\t      \"et al.\");\nMODULE_VERSION(\"0.12.5\");\nMODULE_LICENSE(\"GPL\");\n\n/*\n * helpers\n */\n#define STRINGIFY(s) #s\n#define STRINGIFY2(s) STRINGIFY(s)\n\n#define dprintk(fmt, args...)                                                  \\\n\tdo {                                                                   \\\n\t\tif (debug > 0) {                                               \\\n\t\t\tprintk(KERN_INFO \"v4l2-loopback[\" STRINGIFY2(          \\\n\t\t\t\t       __LINE__) \"]: \" fmt,                    \\\n\t\t\t       ##args);                                        \\\n\t\t}                                                              \\\n\t} while (0)\n\n#define MARK()                                                                 \\\n\tdo {                                                                   \\\n\t\tif (debug > 1) {                                               \\\n\t\t\tprintk(KERN_INFO \"%s:%d[%s]\\n\", __FILE__, __LINE__,    \\\n\t\t\t       __func__);                                      \\\n\t\t}                                                              \\\n\t} while (0)\n\n#define dprintkrw(fmt, args...)                                                \\\n\tdo {                                                                   \\\n\t\tif (debug > 2) {                                               \\\n\t\t\tprintk(KERN_INFO \"v4l2-loopback[\" STRINGIFY2(          \\\n\t\t\t\t       __LINE__) \"]: \" fmt,                    \\\n\t\t\t       ##args);                                        \\\n\t\t}                                                              \\\n\t} while (0)\n\n/*\n * compatibility hacks\n */\n\n#ifndef HAVE__V4L2_CTRLS\nstruct v4l2_ctrl_handler {\n\tint error;\n};\nstruct v4l2_ctrl_config {\n\tvoid *ops;\n\tu32 id;\n\tconst char *name;\n\tint type;\n\ts32 min;\n\ts32 max;\n\tu32 step;\n\ts32 def;\n};\nint v4l2_ctrl_handler_init(struct v4l2_ctrl_handler *hdl,\n\t\t\t   unsigned nr_of_controls_hint)\n{\n\thdl->error = 0;\n\treturn 0;\n}\nvoid v4l2_ctrl_handler_free(struct v4l2_ctrl_handler *hdl)\n{\n}\nvoid *v4l2_ctrl_new_custom(struct v4l2_ctrl_handler *hdl,\n\t\t\t   const struct v4l2_ctrl_config *conf, void *priv)\n{\n\treturn NULL;\n}\n#endif /* HAVE__V4L2_CTRLS */\n\n#ifndef HAVE__V4L2_DEVICE\n/* dummy v4l2_device struct/functions */\n#define V4L2_DEVICE_NAME_SIZE (20 + 16)\nstruct v4l2_device {\n\tchar name[V4L2_DEVICE_NAME_SIZE];\n\tstruct v4l2_ctrl_handler *ctrl_handler;\n};\nstatic inline int v4l2_device_register(void *dev, void *v4l2_dev)\n{\n\treturn 0;\n}\nstatic inline void v4l2_device_unregister(struct v4l2_device *v4l2_dev)\n{\n\treturn;\n}\n#endif /*  HAVE__V4L2_DEVICE */\n\n#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)\n#define v4l2_file_operations file_operations\n#endif\n#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37)\nvoid *v4l2l_vzalloc(unsigned long size)\n{\n\tvoid *data = vmalloc(size);\n\n\tmemset(data, 0, size);\n\treturn data;\n}\n#else\n#define v4l2l_vzalloc vzalloc\n#endif\n\nstatic inline void v4l2l_get_timestamp(struct v4l2_buffer *b)\n{\n\t/* ktime_get_ts is considered deprecated, so use ktime_get_ts64 if possible */\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0)\n\tstruct timespec ts;\n\tktime_get_ts(&ts);\n#else\n\tstruct timespec64 ts;\n\tktime_get_ts64(&ts);\n#endif\n\n\tb->timestamp.tv_sec = ts.tv_sec;\n\tb->timestamp.tv_usec = (ts.tv_nsec / NSEC_PER_USEC);\n}\n\n#if !defined(__poll_t)\ntypedef unsigned __poll_t;\n#endif\n\n/* module constants\n *  can be overridden during he build process using something like\n *\tmake KCPPFLAGS=\"-DMAX_DEVICES=100\"\n */\n\n/* maximum number of v4l2loopback devices that can be created */\n#ifndef MAX_DEVICES\n#define MAX_DEVICES 8\n#endif\n\n/* whether the default is to announce capabilities exclusively or not */\n#ifndef V4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS\n#define V4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS 0\n#endif\n\n/* when a producer is considered to have gone stale */\n#ifndef MAX_TIMEOUT\n#define MAX_TIMEOUT (100 * 1000) /* in msecs */\n#endif\n\n/* max buffers that can be mapped, actually they\n * are all mapped to max_buffers buffers */\n#ifndef MAX_BUFFERS\n#define MAX_BUFFERS 32\n#endif\n\n/* module parameters */\nstatic int debug = 0;\nmodule_param(debug, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"debugging level (higher values == more verbose)\");\n\n#define V4L2LOOPBACK_DEFAULT_MAX_BUFFERS 2\nstatic int max_buffers = V4L2LOOPBACK_DEFAULT_MAX_BUFFERS;\nmodule_param(max_buffers, int, S_IRUGO);\nMODULE_PARM_DESC(max_buffers,\n\t\t \"how many buffers should be allocated [DEFAULT: \" STRINGIFY2(\n\t\t\t V4L2LOOPBACK_DEFAULT_MAX_BUFFERS) \"]\");\n\n/* how many times a device can be opened\n * the per-module default value can be overridden on a per-device basis using\n * the /sys/devices interface\n *\n * note that max_openers should be at least 2 in order to get a working system:\n *   one opener for the producer and one opener for the consumer\n *   however, we leave that to the user\n */\n#define V4L2LOOPBACK_DEFAULT_MAX_OPENERS 10\nstatic int max_openers = V4L2LOOPBACK_DEFAULT_MAX_OPENERS;\nmodule_param(max_openers, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(\n\tmax_openers,\n\t\"how many users can open the loopback device [DEFAULT: \" STRINGIFY2(\n\t\tV4L2LOOPBACK_DEFAULT_MAX_OPENERS) \"]\");\n\nstatic int devices = -1;\nmodule_param(devices, int, 0);\nMODULE_PARM_DESC(devices, \"how many devices should be created\");\n\nstatic int video_nr[MAX_DEVICES] = { [0 ...(MAX_DEVICES - 1)] = -1 };\nmodule_param_array(video_nr, int, NULL, 0444);\nMODULE_PARM_DESC(video_nr,\n\t\t \"video device numbers (-1=auto, 0=/dev/video0, etc.)\");\n\nstatic char *card_label[MAX_DEVICES];\nmodule_param_array(card_label, charp, NULL, 0000);\nMODULE_PARM_DESC(card_label, \"card labels for each device\");\n\nstatic bool exclusive_caps[MAX_DEVICES] = {\n\t[0 ...(MAX_DEVICES - 1)] = V4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS\n};\nmodule_param_array(exclusive_caps, bool, NULL, 0444);\n/* FIXXME: wording */\nMODULE_PARM_DESC(\n\texclusive_caps,\n\t\"whether to announce OUTPUT/CAPTURE capabilities exclusively or not  [DEFAULT: \" STRINGIFY2(\n\t\tV4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS) \"]\");\n\n/* format specifications */\n#define V4L2LOOPBACK_SIZE_MIN_WIDTH 48\n#define V4L2LOOPBACK_SIZE_MIN_HEIGHT 32\n#define V4L2LOOPBACK_SIZE_DEFAULT_MAX_WIDTH 8192\n#define V4L2LOOPBACK_SIZE_DEFAULT_MAX_HEIGHT 8192\n\n#define V4L2LOOPBACK_SIZE_DEFAULT_WIDTH 640\n#define V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT 480\n\nstatic int max_width = V4L2LOOPBACK_SIZE_DEFAULT_MAX_WIDTH;\nmodule_param(max_width, int, S_IRUGO);\nMODULE_PARM_DESC(max_width, \"maximum allowed frame width [DEFAULT: \" STRINGIFY2(\n\t\t\t\t    V4L2LOOPBACK_SIZE_DEFAULT_MAX_WIDTH) \"]\");\nstatic int max_height = V4L2LOOPBACK_SIZE_DEFAULT_MAX_HEIGHT;\nmodule_param(max_height, int, S_IRUGO);\nMODULE_PARM_DESC(max_height,\n\t\t \"maximum allowed frame height [DEFAULT: \" STRINGIFY2(\n\t\t\t V4L2LOOPBACK_SIZE_DEFAULT_MAX_HEIGHT) \"]\");\n\nstatic DEFINE_IDR(v4l2loopback_index_idr);\nstatic DEFINE_MUTEX(v4l2loopback_ctl_mutex);\n\n/* control IDs */\n#ifndef HAVE__V4L2_CTRLS\n#define V4L2LOOPBACK_CID_BASE (V4L2_CID_PRIVATE_BASE)\n#else\n#define V4L2LOOPBACK_CID_BASE (V4L2_CID_USER_BASE | 0xf000)\n#endif\n#define CID_KEEP_FORMAT (V4L2LOOPBACK_CID_BASE + 0)\n#define CID_SUSTAIN_FRAMERATE (V4L2LOOPBACK_CID_BASE + 1)\n#define CID_TIMEOUT (V4L2LOOPBACK_CID_BASE + 2)\n#define CID_TIMEOUT_IMAGE_IO (V4L2LOOPBACK_CID_BASE + 3)\n\nstatic int v4l2loopback_s_ctrl(struct v4l2_ctrl *ctrl);\nstatic const struct v4l2_ctrl_ops v4l2loopback_ctrl_ops = {\n\t.s_ctrl = v4l2loopback_s_ctrl,\n};\nstatic const struct v4l2_ctrl_config v4l2loopback_ctrl_keepformat = {\n\t// clang-format off\n\t.ops\t= &v4l2loopback_ctrl_ops,\n\t.id\t= CID_KEEP_FORMAT,\n\t.name\t= \"keep_format\",\n\t.type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t.min\t= 0,\n\t.max\t= 1,\n\t.step\t= 1,\n\t.def\t= 0,\n\t// clang-format on\n};\nstatic const struct v4l2_ctrl_config v4l2loopback_ctrl_sustainframerate = {\n\t// clang-format off\n\t.ops\t= &v4l2loopback_ctrl_ops,\n\t.id\t= CID_SUSTAIN_FRAMERATE,\n\t.name\t= \"sustain_framerate\",\n\t.type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t.min\t= 0,\n\t.max\t= 1,\n\t.step\t= 1,\n\t.def\t= 0,\n\t// clang-format on\n};\nstatic const struct v4l2_ctrl_config v4l2loopback_ctrl_timeout = {\n\t// clang-format off\n\t.ops\t= &v4l2loopback_ctrl_ops,\n\t.id\t= CID_TIMEOUT,\n\t.name\t= \"timeout\",\n\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t.min\t= 0,\n\t.max\t= MAX_TIMEOUT,\n\t.step\t= 1,\n\t.def\t= 0,\n\t// clang-format on\n};\nstatic const struct v4l2_ctrl_config v4l2loopback_ctrl_timeoutimageio = {\n\t// clang-format off\n\t.ops\t= &v4l2loopback_ctrl_ops,\n\t.id\t= CID_TIMEOUT_IMAGE_IO,\n\t.name\t= \"timeout_image_io\",\n\t.type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t.min\t= 0,\n\t.max\t= 1,\n\t.step\t= 1,\n\t.def\t= 0,\n\t// clang-format on\n};\n\n/* module structures */\nstruct v4l2loopback_private {\n\tint device_nr;\n};\n\n/* TODO(vasaka) use typenames which are common to kernel, but first find out if\n * it is needed */\n/* struct keeping state and settings of loopback device */\n\nstruct v4l2l_buffer {\n\tstruct v4l2_buffer buffer;\n\tstruct list_head list_head;\n\tint use_count;\n};\n\nstruct v4l2_loopback_device {\n\tstruct v4l2_device v4l2_dev;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tstruct video_device *vdev;\n\t/* pixel and stream format */\n\tstruct v4l2_pix_format pix_format;\n\tstruct v4l2_captureparm capture_param;\n\tunsigned long frame_jiffies;\n\n\t/* ctrls */\n\tint keep_format; /* CID_KEEP_FORMAT; stay ready_for_capture even when all\n\t\t\t    openers close() the device */\n\tint sustain_framerate; /* CID_SUSTAIN_FRAMERATE; duplicate frames to maintain\n\t\t\t\t  (close to) nominal framerate */\n\n\t/* buffers stuff */\n\tu8 *image; /* pointer to actual buffers data */\n\tunsigned long int imagesize; /* size of buffers data */\n\tint buffers_number; /* should not be big, 4 is a good choice */\n\tstruct v4l2l_buffer buffers[MAX_BUFFERS]; /* inner driver buffers */\n\tint used_buffers; /* number of the actually used buffers */\n\tint max_openers; /* how many times can this device be opened */\n\n\tint write_position; /* number of last written frame + 1 */\n\tstruct list_head outbufs_list; /* buffers in output DQBUF order */\n\tint bufpos2index\n\t\t[MAX_BUFFERS]; /* mapping of (read/write_position % used_buffers)\n                        * to inner buffer index */\n\tlong buffer_size;\n\n\t/* sustain_framerate stuff */\n\tstruct timer_list sustain_timer;\n\tunsigned int reread_count;\n\n\t/* timeout stuff */\n\tunsigned long timeout_jiffies; /* CID_TIMEOUT; 0 means disabled */\n\tint timeout_image_io; /* CID_TIMEOUT_IMAGE_IO; next opener will\n\t\t\t       * read/write to timeout_image */\n\tu8 *timeout_image; /* copy of it will be captured when timeout passes */\n\tstruct v4l2l_buffer timeout_image_buffer;\n\tstruct timer_list timeout_timer;\n\tint timeout_happened;\n\n\t/* sync stuff */\n\tatomic_t open_count;\n\n\tint ready_for_capture; /* set to the number of writers that opened the\n                                * device and negotiated format. */\n\tint ready_for_output; /* set to true when no writer is currently attached\n\t\t\t       * this differs slightly from !ready_for_capture,\n\t\t\t       * e.g. when using fallback images */\n\tint announce_all_caps; /* set to false, if device caps (OUTPUT/CAPTURE)\n                                * should only be announced if the resp. \"ready\"\n                                * flag is set; default=TRUE */\n\n\tint max_width;\n\tint max_height;\n\n\tchar card_label[32];\n\n\twait_queue_head_t read_event;\n\tspinlock_t lock;\n};\n\n/* types of opener shows what opener wants to do with loopback */\nenum opener_type {\n\t// clang-format off\n\tUNNEGOTIATED\t= 0,\n\tREADER\t\t= 1,\n\tWRITER\t\t= 2,\n\t// clang-format on\n};\n\n/* struct keeping state and type of opener */\nstruct v4l2_loopback_opener {\n\tenum opener_type type;\n\tint vidioc_enum_frameintervals_calls;\n\tint read_position; /* number of last processed frame + 1 or\n\t\t\t    * write_position - 1 if reader went out of sync */\n\tunsigned int reread_count;\n\tstruct v4l2_buffer *buffers;\n\tint buffers_number; /* should not be big, 4 is a good choice */\n\tint timeout_image_io;\n\n\tstruct v4l2_fh fh;\n};\n\n#define fh_to_opener(ptr) container_of((ptr), struct v4l2_loopback_opener, fh)\n\n/* this is heavily inspired by the bttv driver found in the linux kernel */\nstruct v4l2l_format {\n\tchar *name;\n\tint fourcc; /* video4linux 2 */\n\tint depth; /* bit/pixel */\n\tint flags;\n};\n/* set the v4l2l_format.flags to PLANAR for non-packed formats */\n#define FORMAT_FLAGS_PLANAR 0x01\n#define FORMAT_FLAGS_COMPRESSED 0x02\n\n#include \"v4l2loopback_formats.h\"\n\nstatic const unsigned int FORMATS = ARRAY_SIZE(formats);\n\nstatic char *fourcc2str(unsigned int fourcc, char buf[4])\n{\n\tbuf[0] = (fourcc >> 0) & 0xFF;\n\tbuf[1] = (fourcc >> 8) & 0xFF;\n\tbuf[2] = (fourcc >> 16) & 0xFF;\n\tbuf[3] = (fourcc >> 24) & 0xFF;\n\n\treturn buf;\n}\n\nstatic const struct v4l2l_format *format_by_fourcc(int fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < FORMATS; i++) {\n\t\tif (formats[i].fourcc == fourcc)\n\t\t\treturn formats + i;\n\t}\n\n\tdprintk(\"unsupported format '%c%c%c%c'\\n\", (fourcc >> 0) & 0xFF,\n\t\t(fourcc >> 8) & 0xFF, (fourcc >> 16) & 0xFF,\n\t\t(fourcc >> 24) & 0xFF);\n\treturn NULL;\n}\n\nstatic void pix_format_set_size(struct v4l2_pix_format *f,\n\t\t\t\tconst struct v4l2l_format *fmt,\n\t\t\t\tunsigned int width, unsigned int height)\n{\n\tf->width = width;\n\tf->height = height;\n\n\tif (fmt->flags & FORMAT_FLAGS_PLANAR) {\n\t\tf->bytesperline = width; /* Y plane */\n\t\tf->sizeimage = (width * height * fmt->depth) >> 3;\n\t} else if (fmt->flags & FORMAT_FLAGS_COMPRESSED) {\n\t\t/* doesn't make sense for compressed formats */\n\t\tf->bytesperline = 0;\n\t\tf->sizeimage = (width * height * fmt->depth) >> 3;\n\t} else {\n\t\tf->bytesperline = (width * fmt->depth) >> 3;\n\t\tf->sizeimage = height * f->bytesperline;\n\t}\n}\n\nstatic int set_timeperframe(struct v4l2_loopback_device *dev,\n\t\t\t    struct v4l2_fract *tpf)\n{\n\tif ((tpf->denominator < 1) || (tpf->numerator < 1)) {\n\t\treturn -EINVAL;\n\t}\n\tdev->capture_param.timeperframe = *tpf;\n\tdev->frame_jiffies = max(1UL, msecs_to_jiffies(1000) * tpf->numerator /\n\t\t\t\t\t      tpf->denominator);\n\treturn 0;\n}\n\nstatic struct v4l2_loopback_device *v4l2loopback_cd2dev(struct device *cd);\n\n/* device attributes */\n/* available via sysfs: /sys/devices/virtual/video4linux/video* */\n\nstatic ssize_t attr_show_format(struct device *cd,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\t/* gets the current format as \"FOURCC:WxH@f/s\", e.g. \"YUYV:320x240@1000/30\" */\n\tstruct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);\n\tconst struct v4l2_fract *tpf;\n\tchar buf4cc[5], buf_fps[32];\n\n\tif (!dev || !dev->ready_for_capture)\n\t\treturn 0;\n\ttpf = &dev->capture_param.timeperframe;\n\n\tfourcc2str(dev->pix_format.pixelformat, buf4cc);\n\tbuf4cc[4] = 0;\n\tif (tpf->numerator == 1)\n\t\tsnprintf(buf_fps, sizeof(buf_fps), \"%d\", tpf->denominator);\n\telse\n\t\tsnprintf(buf_fps, sizeof(buf_fps), \"%d/%d\", tpf->denominator,\n\t\t\t tpf->numerator);\n\treturn sprintf(buf, \"%4s:%dx%d@%s\\n\", buf4cc, dev->pix_format.width,\n\t\t       dev->pix_format.height, buf_fps);\n}\n\nstatic ssize_t attr_store_format(struct device *cd,\n\t\t\t\t struct device_attribute *attr, const char *buf,\n\t\t\t\t size_t len)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);\n\tint fps_num = 0, fps_den = 1;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\t/* only fps changing is supported */\n\tif (sscanf(buf, \"@%d/%d\", &fps_num, &fps_den) > 0) {\n\t\tstruct v4l2_fract f = { .numerator = fps_den,\n\t\t\t\t\t.denominator = fps_num };\n\t\tint err = 0;\n\t\tif ((err = set_timeperframe(dev, &f)) < 0)\n\t\t\treturn err;\n\t\treturn len;\n\t}\n\treturn -EINVAL;\n}\n\nstatic DEVICE_ATTR(format, S_IRUGO | S_IWUSR, attr_show_format,\n\t\t   attr_store_format);\n\nstatic ssize_t attr_show_buffers(struct device *cd,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"%d\\n\", dev->used_buffers);\n}\n\nstatic DEVICE_ATTR(buffers, S_IRUGO, attr_show_buffers, NULL);\n\nstatic ssize_t attr_show_maxopeners(struct device *cd,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);\n\n\treturn sprintf(buf, \"%d\\n\", dev->max_openers);\n}\n\nstatic ssize_t attr_store_maxopeners(struct device *cd,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t len)\n{\n\tstruct v4l2_loopback_device *dev = NULL;\n\tunsigned long curr = 0;\n\n\tif (kstrtoul(buf, 0, &curr))\n\t\treturn -EINVAL;\n\n\tdev = v4l2loopback_cd2dev(cd);\n\n\tif (dev->max_openers == curr)\n\t\treturn len;\n\n\tif (curr > __INT_MAX__ || dev->open_count.counter > curr) {\n\t\t/* request to limit to less openers as are currently attached to us */\n\t\treturn -EINVAL;\n\t}\n\n\tdev->max_openers = (int)curr;\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR(max_openers, S_IRUGO | S_IWUSR, attr_show_maxopeners,\n\t\t   attr_store_maxopeners);\n\nstatic void v4l2loopback_remove_sysfs(struct video_device *vdev)\n{\n#define V4L2_SYSFS_DESTROY(x) device_remove_file(&vdev->dev, &dev_attr_##x)\n\n\tif (vdev) {\n\t\tV4L2_SYSFS_DESTROY(format);\n\t\tV4L2_SYSFS_DESTROY(buffers);\n\t\tV4L2_SYSFS_DESTROY(max_openers);\n\t\t/* ... */\n\t}\n}\n\nstatic void v4l2loopback_create_sysfs(struct video_device *vdev)\n{\n\tint res = 0;\n\n#define V4L2_SYSFS_CREATE(x)                                                   \\\n\tres = device_create_file(&vdev->dev, &dev_attr_##x);                   \\\n\tif (res < 0)                                                           \\\n\tbreak\n\tif (!vdev)\n\t\treturn;\n\tdo {\n\t\tV4L2_SYSFS_CREATE(format);\n\t\tV4L2_SYSFS_CREATE(buffers);\n\t\tV4L2_SYSFS_CREATE(max_openers);\n\t\t/* ... */\n\t} while (0);\n\n\tif (res >= 0)\n\t\treturn;\n\tdev_err(&vdev->dev, \"%s error: %d\\n\", __func__, res);\n}\n\n/* global module data */\n/* find a device based on it's device-number (e.g. '3' for /dev/video3) */\nstruct v4l2loopback_lookup_cb_data {\n\tint device_nr;\n\tstruct v4l2_loopback_device *device;\n};\nstatic int v4l2loopback_lookup_cb(int id, void *ptr, void *data)\n{\n\tstruct v4l2_loopback_device *device = ptr;\n\tstruct v4l2loopback_lookup_cb_data *cbdata = data;\n\tif (cbdata && device && device->vdev) {\n\t\tif (device->vdev->num == cbdata->device_nr) {\n\t\t\tcbdata->device = device;\n\t\t\tcbdata->device_nr = id;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nstatic int v4l2loopback_lookup(int device_nr,\n\t\t\t       struct v4l2_loopback_device **device)\n{\n\tstruct v4l2loopback_lookup_cb_data data = {\n\t\t.device_nr = device_nr,\n\t\t.device = NULL,\n\t};\n\tint err = idr_for_each(&v4l2loopback_index_idr, &v4l2loopback_lookup_cb,\n\t\t\t       &data);\n\tif (1 == err) {\n\t\tif (device)\n\t\t\t*device = data.device;\n\t\treturn data.device_nr;\n\t}\n\treturn -ENODEV;\n}\nstatic struct v4l2_loopback_device *v4l2loopback_cd2dev(struct device *cd)\n{\n\tstruct video_device *loopdev = to_video_device(cd);\n\tstruct v4l2loopback_private *ptr =\n\t\t(struct v4l2loopback_private *)video_get_drvdata(loopdev);\n\tint nr = ptr->device_nr;\n\n\treturn idr_find(&v4l2loopback_index_idr, nr);\n}\n\nstatic struct v4l2_loopback_device *v4l2loopback_getdevice(struct file *f)\n{\n\tstruct v4l2loopback_private *ptr = video_drvdata(f);\n\tint nr = ptr->device_nr;\n\n\treturn idr_find(&v4l2loopback_index_idr, nr);\n}\n\n/* forward declarations */\nstatic void init_buffers(struct v4l2_loopback_device *dev);\nstatic int allocate_buffers(struct v4l2_loopback_device *dev);\nstatic void free_buffers(struct v4l2_loopback_device *dev);\nstatic void try_free_buffers(struct v4l2_loopback_device *dev);\nstatic int allocate_timeout_image(struct v4l2_loopback_device *dev);\nstatic void check_timers(struct v4l2_loopback_device *dev);\nstatic const struct v4l2_file_operations v4l2_loopback_fops;\nstatic const struct v4l2_ioctl_ops v4l2_loopback_ioctl_ops;\n\n/* Queue helpers */\n/* next functions sets buffer flags and adjusts counters accordingly */\nstatic inline void set_done(struct v4l2l_buffer *buffer)\n{\n\tbuffer->buffer.flags &= ~V4L2_BUF_FLAG_QUEUED;\n\tbuffer->buffer.flags |= V4L2_BUF_FLAG_DONE;\n}\n\nstatic inline void set_queued(struct v4l2l_buffer *buffer)\n{\n\tbuffer->buffer.flags &= ~V4L2_BUF_FLAG_DONE;\n\tbuffer->buffer.flags |= V4L2_BUF_FLAG_QUEUED;\n}\n\nstatic inline void unset_flags(struct v4l2l_buffer *buffer)\n{\n\tbuffer->buffer.flags &= ~V4L2_BUF_FLAG_QUEUED;\n\tbuffer->buffer.flags &= ~V4L2_BUF_FLAG_DONE;\n}\n\n/* V4L2 ioctl caps and params calls */\n/* returns device capabilities\n * called on VIDIOC_QUERYCAP\n */\nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tint labellen = (sizeof(cap->card) < sizeof(dev->card_label)) ?\n\t\t\t       sizeof(cap->card) :\n\t\t\t\t     sizeof(dev->card_label);\n\tint device_nr =\n\t\t((struct v4l2loopback_private *)video_get_drvdata(dev->vdev))\n\t\t\t->device_nr;\n\t__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\n\tstrlcpy(cap->driver, \"v4l2 loopback\", sizeof(cap->driver));\n\tsnprintf(cap->card, labellen, dev->card_label);\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:v4l2loopback-%03d\", device_nr);\n\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0)\n\t/* since 3.1.0, the v4l2-core system is supposed to set the version */\n\tcap->version = V4L2LOOPBACK_VERSION_CODE;\n#endif\n\n#ifdef V4L2_CAP_VIDEO_M2M\n\tcapabilities |= V4L2_CAP_VIDEO_M2M;\n#endif /* V4L2_CAP_VIDEO_M2M */\n\n\tif (dev->announce_all_caps) {\n\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\n\t} else {\n\t\tif (dev->ready_for_capture) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE;\n\t\t}\n\t\tif (dev->ready_for_output) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_OUTPUT;\n\t\t}\n\t}\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n\tdev->vdev->device_caps =\n#endif /* >=linux-4.7.0 */\n\t\tcap->device_caps = cap->capabilities = capabilities;\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)\n\tcap->capabilities |= V4L2_CAP_DEVICE_CAPS;\n#endif\n\n\tmemset(cap->reserved, 0, sizeof(cap->reserved));\n\treturn 0;\n}\n\nstatic int vidioc_enum_framesizes(struct file *file, void *fh,\n\t\t\t\t  struct v4l2_frmsizeenum *argp)\n{\n\tstruct v4l2_loopback_device *dev;\n\n\t/* LATER: what does the index really  mean?\n\t * if it's about enumerating formats, we can safely ignore it\n\t * (CHECK)\n\t */\n\n\t/* there can be only one... */\n\tif (argp->index)\n\t\treturn -EINVAL;\n\n\tdev = v4l2loopback_getdevice(file);\n\tif (dev->ready_for_capture) {\n\t\t/* format has already been negotiated\n\t\t * cannot change during runtime\n\t\t */\n\t\targp->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\n\t\targp->discrete.width = dev->pix_format.width;\n\t\targp->discrete.height = dev->pix_format.height;\n\t} else {\n\t\t/* if the format has not been negotiated yet, we accept anything\n\t\t */\n\t\targp->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;\n\n\t\targp->stepwise.min_width = V4L2LOOPBACK_SIZE_MIN_WIDTH;\n\t\targp->stepwise.min_height = V4L2LOOPBACK_SIZE_MIN_HEIGHT;\n\n\t\targp->stepwise.max_width = dev->max_width;\n\t\targp->stepwise.max_height = dev->max_height;\n\n\t\targp->stepwise.step_width = 1;\n\t\targp->stepwise.step_height = 1;\n\t}\n\treturn 0;\n}\n\n/* returns frameinterval (fps) for the set resolution\n * called on VIDIOC_ENUM_FRAMEINTERVALS\n */\nstatic int vidioc_enum_frameintervals(struct file *file, void *fh,\n\t\t\t\t      struct v4l2_frmivalenum *argp)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tstruct v4l2_loopback_opener *opener = fh_to_opener(fh);\n\n\tif (dev->ready_for_capture) {\n\t\tif (opener->vidioc_enum_frameintervals_calls > 0)\n\t\t\treturn -EINVAL;\n\t\tif (argp->width == dev->pix_format.width &&\n\t\t    argp->height == dev->pix_format.height) {\n\t\t\targp->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\t\t\targp->discrete = dev->capture_param.timeperframe;\n\t\t\topener->vidioc_enum_frameintervals_calls++;\n\t\t\treturn 0;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n/* ------------------ CAPTURE ----------------------- */\n\n/* returns device formats\n * called on VIDIOC_ENUM_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_CAPTURE\n */\nstatic int vidioc_enum_fmt_cap(struct file *file, void *fh,\n\t\t\t       struct v4l2_fmtdesc *f)\n{\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\n\tif (f->index)\n\t\treturn -EINVAL;\n\tif (dev->ready_for_capture) {\n\t\tconst __u32 format = dev->pix_format.pixelformat;\n\n\t\tsnprintf(f->description, sizeof(f->description), \"[%c%c%c%c]\",\n\t\t\t (format >> 0) & 0xFF, (format >> 8) & 0xFF,\n\t\t\t (format >> 16) & 0xFF, (format >> 24) & 0xFF);\n\n\t\tf->pixelformat = dev->pix_format.pixelformat;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tf->flags = 0;\n\tMARK();\n\treturn 0;\n}\n\n/* returns current video format\n * called on VIDIOC_G_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_CAPTURE\n */\nstatic int vidioc_g_fmt_cap(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *fmt)\n{\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\n\tif (!dev->ready_for_capture)\n\t\treturn -EINVAL;\n\n\tfmt->fmt.pix = dev->pix_format;\n\tMARK();\n\treturn 0;\n}\n\n/* checks if it is OK to change to format fmt;\n * actual check is done by inner_try_fmt_cap\n * just checking that pixelformat is OK and set other parameters, app should\n * obey this decision\n * called on VIDIOC_TRY_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_CAPTURE\n */\nstatic int vidioc_try_fmt_cap(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *fmt)\n{\n\tstruct v4l2_loopback_device *dev;\n\tchar buf[5];\n\n\tdev = v4l2loopback_getdevice(file);\n\n\tif (0 == dev->ready_for_capture) {\n\t\tdprintk(\"setting fmt_cap not possible yet\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (fmt->fmt.pix.pixelformat != dev->pix_format.pixelformat)\n\t\treturn -EINVAL;\n\n\tfmt->fmt.pix = dev->pix_format;\n\n\tbuf[4] = 0;\n\tdprintk(\"capFOURCC=%s\\n\", fourcc2str(dev->pix_format.pixelformat, buf));\n\treturn 0;\n}\n\n/* sets new output format, if possible\n * actually format is set  by input and we even do not check it, just return\n * current one, but it is possible to set subregions of input TODO(vasaka)\n * called on VIDIOC_S_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_CAPTURE\n */\nstatic int vidioc_s_fmt_cap(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *fmt)\n{\n\treturn vidioc_try_fmt_cap(file, priv, fmt);\n}\n\n/* ------------------ OUTPUT ----------------------- */\n\n/* returns device formats;\n * LATER: allow all formats\n * called on VIDIOC_ENUM_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_OUTPUT\n */\nstatic int vidioc_enum_fmt_out(struct file *file, void *fh,\n\t\t\t       struct v4l2_fmtdesc *f)\n{\n\tstruct v4l2_loopback_device *dev;\n\tconst struct v4l2l_format *fmt;\n\n\tdev = v4l2loopback_getdevice(file);\n\n\tif (dev->ready_for_capture) {\n\t\tconst __u32 format = dev->pix_format.pixelformat;\n\n\t\t/* format has been fixed by the writer, so only one single format is supported */\n\t\tif (f->index)\n\t\t\treturn -EINVAL;\n\n\t\tfmt = format_by_fourcc(format);\n\t\tif (NULL == fmt)\n\t\t\treturn -EINVAL;\n\n\t\tf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\t/* f->flags = ??; */\n\t\tsnprintf(f->description, sizeof(f->description), \"%s\",\n\t\t\t fmt->name);\n\n\t\tf->pixelformat = dev->pix_format.pixelformat;\n\t} else {\n\t\t/* fill in a dummy format */\n\t\t/* coverity[unsigned_compare] */\n\t\tif (f->index < 0 || f->index >= FORMATS)\n\t\t\treturn -EINVAL;\n\n\t\tfmt = &formats[f->index];\n\n\t\tf->pixelformat = fmt->fourcc;\n\t\tsnprintf(f->description, sizeof(f->description), \"%s\",\n\t\t\t fmt->name);\n\t}\n\tf->flags = 0;\n\n\treturn 0;\n}\n\n/* returns current video format format fmt */\n/* NOTE: this is called from the producer\n * so if format has not been negotiated yet,\n * it should return ALL of available formats,\n * called on VIDIOC_G_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_OUTPUT\n */\nstatic int vidioc_g_fmt_out(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *fmt)\n{\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\n\t/*\n\t * LATER: this should return the currently valid format\n\t * gstreamer doesn't like it, if this returns -EINVAL, as it\n\t * then concludes that there is _no_ valid format\n\t * CHECK whether this assumption is wrong,\n\t * or whether we have to always provide a valid format\n\t */\n\n\tfmt->fmt.pix = dev->pix_format;\n\treturn 0;\n}\n\n/* checks if it is OK to change to format fmt;\n * if format is negotiated do not change it\n * called on VIDIOC_TRY_FMT with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_OUTPUT\n */\nstatic int vidioc_try_fmt_out(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *fmt)\n{\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\n\t/* TODO(vasaka) loopback does not care about formats writer want to set,\n\t * maybe it is a good idea to restrict format somehow */\n\tif (dev->ready_for_capture) {\n\t\tfmt->fmt.pix = dev->pix_format;\n\t} else {\n\t\t__u32 w = fmt->fmt.pix.width;\n\t\t__u32 h = fmt->fmt.pix.height;\n\t\t__u32 pixfmt = fmt->fmt.pix.pixelformat;\n\t\tconst struct v4l2l_format *format = format_by_fourcc(pixfmt);\n\n\t\tif (w > dev->max_width)\n\t\t\tw = dev->max_width;\n\t\tif (h > dev->max_height)\n\t\t\th = dev->max_height;\n\n\t\tdprintk(\"trying image %dx%d\\n\", w, h);\n\n\t\tif (w < 1)\n\t\t\tw = V4L2LOOPBACK_SIZE_DEFAULT_WIDTH;\n\n\t\tif (h < 1)\n\t\t\th = V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT;\n\n\t\tif (NULL == format)\n\t\t\tformat = &formats[0];\n\n\t\tpix_format_set_size(&fmt->fmt.pix, format, w, h);\n\n\t\tfmt->fmt.pix.pixelformat = format->fourcc;\n\n\t\tif ((fmt->fmt.pix.colorspace == V4L2_COLORSPACE_DEFAULT) ||\n\t\t    (fmt->fmt.pix.colorspace > V4L2_COLORSPACE_DCI_P3))\n\t\t\tfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;\n\n\t\tif (V4L2_FIELD_ANY == fmt->fmt.pix.field)\n\t\t\tfmt->fmt.pix.field = V4L2_FIELD_NONE;\n\n\t\t/* FIXXME: try_fmt should never modify the device-state */\n\t\tdev->pix_format = fmt->fmt.pix;\n\t}\n\treturn 0;\n}\n\n/* sets new output format, if possible;\n * allocate data here because we do not know if it will be streaming or\n * read/write IO\n * called on VIDIOC_S_FMT with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_OUTPUT\n */\nstatic int vidioc_s_fmt_out(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *fmt)\n{\n\tstruct v4l2_loopback_device *dev;\n\tchar buf[5];\n\tint ret;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\tret = vidioc_try_fmt_out(file, priv, fmt);\n\n\tdprintk(\"s_fmt_out(%d) %d...%d\\n\", ret, dev->ready_for_capture,\n\t\tdev->pix_format.sizeimage);\n\n\tbuf[4] = 0;\n\tdprintk(\"outFOURCC=%s\\n\", fourcc2str(dev->pix_format.pixelformat, buf));\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!dev->ready_for_capture) {\n\t\tdev->buffer_size = PAGE_ALIGN(dev->pix_format.sizeimage);\n\t\tfmt->fmt.pix.sizeimage = dev->buffer_size;\n\t\tallocate_buffers(dev);\n\t}\n\treturn ret;\n}\n\n// #define V4L2L_OVERLAY\n#ifdef V4L2L_OVERLAY\n/* ------------------ OVERLAY ----------------------- */\n/* currently unsupported */\n/* GSTreamer's v4l2sink is buggy, as it requires the overlay to work\n * while it should only require it, if overlay is requested\n * once the gstreamer element is fixed, remove the overlay dummies\n */\n#warning OVERLAY dummies\nstatic int vidioc_g_fmt_overlay(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *fmt)\n{\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_overlay(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *fmt)\n{\n\treturn 0;\n}\n#endif /* V4L2L_OVERLAY */\n\n/* ------------------ PARAMs ----------------------- */\n\n/* get some data flow parameters, only capability, fps and readbuffers has\n * effect on this driver\n * called on VIDIOC_G_PARM\n */\nstatic int vidioc_g_parm(struct file *file, void *priv,\n\t\t\t struct v4l2_streamparm *parm)\n{\n\t/* do not care about type of opener, hope these enums would always be\n\t * compatible */\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\tparm->parm.capture = dev->capture_param;\n\treturn 0;\n}\n\n/* get some data flow parameters, only capability, fps and readbuffers has\n * effect on this driver\n * called on VIDIOC_S_PARM\n */\nstatic int vidioc_s_parm(struct file *file, void *priv,\n\t\t\t struct v4l2_streamparm *parm)\n{\n\tstruct v4l2_loopback_device *dev;\n\tint err = 0;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\tdprintk(\"vidioc_s_parm called frate=%d/%d\\n\",\n\t\tparm->parm.capture.timeperframe.numerator,\n\t\tparm->parm.capture.timeperframe.denominator);\n\n\tswitch (parm->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tif ((err = set_timeperframe(\n\t\t\t     dev, &parm->parm.capture.timeperframe)) < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif ((err = set_timeperframe(\n\t\t\t     dev, &parm->parm.capture.timeperframe)) < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tparm->parm.capture = dev->capture_param;\n\treturn 0;\n}\n\n#ifdef V4L2LOOPBACK_WITH_STD\n/* sets a tv standard, actually we do not need to handle this any special way\n * added to support effecttv\n * called on VIDIOC_S_STD\n */\nstatic int vidioc_s_std(struct file *file, void *fh, v4l2_std_id *_std)\n{\n\tv4l2_std_id req_std = 0, supported_std = 0;\n\tconst v4l2_std_id all_std = V4L2_STD_ALL, no_std = 0;\n\n\tif (_std) {\n\t\treq_std = *_std;\n\t\t*_std = all_std;\n\t}\n\n\t/* we support everything in V4L2_STD_ALL, but not more... */\n\tsupported_std = (all_std & req_std);\n\tif (no_std == supported_std)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/* gets a fake video standard\n * called on VIDIOC_G_STD\n */\nstatic int vidioc_g_std(struct file *file, void *fh, v4l2_std_id *norm)\n{\n\tif (norm)\n\t\t*norm = V4L2_STD_ALL;\n\treturn 0;\n}\n/* gets a fake video standard\n * called on VIDIOC_QUERYSTD\n */\nstatic int vidioc_querystd(struct file *file, void *fh, v4l2_std_id *norm)\n{\n\tif (norm)\n\t\t*norm = V4L2_STD_ALL;\n\treturn 0;\n}\n#endif /* V4L2LOOPBACK_WITH_STD */\n\n/* get ctrls info\n * called on VIDIOC_QUERYCTRL\n */\nstatic int vidioc_queryctrl(struct file *file, void *fh,\n\t\t\t    struct v4l2_queryctrl *q)\n{\n\tconst struct v4l2_ctrl_config *cnf = 0;\n\tswitch (q->id) {\n\tcase CID_KEEP_FORMAT:\n\t\tcnf = &v4l2loopback_ctrl_keepformat;\n\t\tbreak;\n\tcase CID_SUSTAIN_FRAMERATE:\n\t\tcnf = &v4l2loopback_ctrl_sustainframerate;\n\t\tbreak;\n\tcase CID_TIMEOUT:\n\t\tcnf = &v4l2loopback_ctrl_timeout;\n\t\tbreak;\n\tcase CID_TIMEOUT_IMAGE_IO:\n\t\tcnf = &v4l2loopback_ctrl_timeoutimageio;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (!cnf)\n\t\tBUG();\n\n\tstrcpy(q->name, cnf->name);\n\tq->default_value = cnf->def;\n\tq->type = cnf->type;\n\tq->minimum = cnf->min;\n\tq->maximum = cnf->max;\n\tq->step = cnf->step;\n\n\tmemset(q->reserved, 0, sizeof(q->reserved));\n\treturn 0;\n}\n\nstatic int vidioc_g_ctrl(struct file *file, void *fh, struct v4l2_control *c)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\n\tswitch (c->id) {\n\tcase CID_KEEP_FORMAT:\n\t\tc->value = dev->keep_format;\n\t\tbreak;\n\tcase CID_SUSTAIN_FRAMERATE:\n\t\tc->value = dev->sustain_framerate;\n\t\tbreak;\n\tcase CID_TIMEOUT:\n\t\tc->value = jiffies_to_msecs(dev->timeout_jiffies);\n\t\tbreak;\n\tcase CID_TIMEOUT_IMAGE_IO:\n\t\tc->value = dev->timeout_image_io;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int v4l2loopback_set_ctrl(struct v4l2_loopback_device *dev, u32 id,\n\t\t\t\t s64 val)\n{\n\tswitch (id) {\n\tcase CID_KEEP_FORMAT:\n\t\tif (val < 0 || val > 1)\n\t\t\treturn -EINVAL;\n\t\tdev->keep_format = val;\n\t\ttry_free_buffers(\n\t\t\tdev); /* will only free buffers if !keep_format */\n\t\tbreak;\n\tcase CID_SUSTAIN_FRAMERATE:\n\t\tif (val < 0 || val > 1)\n\t\t\treturn -EINVAL;\n\t\tspin_lock_bh(&dev->lock);\n\t\tdev->sustain_framerate = val;\n\t\tcheck_timers(dev);\n\t\tspin_unlock_bh(&dev->lock);\n\t\tbreak;\n\tcase CID_TIMEOUT:\n\t\tif (val < 0 || val > MAX_TIMEOUT)\n\t\t\treturn -EINVAL;\n\t\tspin_lock_bh(&dev->lock);\n\t\tdev->timeout_jiffies = msecs_to_jiffies(val);\n\t\tcheck_timers(dev);\n\t\tspin_unlock_bh(&dev->lock);\n\t\tallocate_timeout_image(dev);\n\t\tbreak;\n\tcase CID_TIMEOUT_IMAGE_IO:\n\t\tif (val < 0 || val > 1)\n\t\t\treturn -EINVAL;\n\t\tdev->timeout_image_io = val;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int v4l2loopback_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_loopback_device *dev = container_of(\n\t\tctrl->handler, struct v4l2_loopback_device, ctrl_handler);\n\treturn v4l2loopback_set_ctrl(dev, ctrl->id, ctrl->val);\n}\nstatic int vidioc_s_ctrl(struct file *file, void *fh, struct v4l2_control *c)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\treturn v4l2loopback_set_ctrl(dev, c->id, c->value);\n}\n\n/* returns set of device outputs, in our case there is only one\n * called on VIDIOC_ENUMOUTPUT\n */\nstatic int vidioc_enum_output(struct file *file, void *fh,\n\t\t\t      struct v4l2_output *outp)\n{\n\t__u32 index = outp->index;\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tMARK();\n\n\tif (!dev->announce_all_caps && !dev->ready_for_output)\n\t\treturn -ENOTTY;\n\n\tif (0 != index)\n\t\treturn -EINVAL;\n\n\t/* clear all data (including the reserved fields) */\n\tmemset(outp, 0, sizeof(*outp));\n\n\toutp->index = index;\n\tstrlcpy(outp->name, \"loopback in\", sizeof(outp->name));\n\toutp->type = V4L2_OUTPUT_TYPE_ANALOG;\n\toutp->audioset = 0;\n\toutp->modulator = 0;\n#ifdef V4L2LOOPBACK_WITH_STD\n\toutp->std = V4L2_STD_ALL;\n#ifdef V4L2_OUT_CAP_STD\n\toutp->capabilities |= V4L2_OUT_CAP_STD;\n#endif /*  V4L2_OUT_CAP_STD */\n#endif /* V4L2LOOPBACK_WITH_STD */\n\n\treturn 0;\n}\n\n/* which output is currently active,\n * called on VIDIOC_G_OUTPUT\n */\nstatic int vidioc_g_output(struct file *file, void *fh, unsigned int *i)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tif (!dev->announce_all_caps && !dev->ready_for_output)\n\t\treturn -ENOTTY;\n\tif (i)\n\t\t*i = 0;\n\treturn 0;\n}\n\n/* set output, can make sense if we have more than one video src,\n * called on VIDIOC_S_OUTPUT\n */\nstatic int vidioc_s_output(struct file *file, void *fh, unsigned int i)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tif (!dev->announce_all_caps && !dev->ready_for_output)\n\t\treturn -ENOTTY;\n\n\tif (i)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/* returns set of device inputs, in our case there is only one,\n * but later I may add more\n * called on VIDIOC_ENUMINPUT\n */\nstatic int vidioc_enum_input(struct file *file, void *fh,\n\t\t\t     struct v4l2_input *inp)\n{\n\t__u32 index = inp->index;\n\tMARK();\n\n\tif (0 != index)\n\t\treturn -EINVAL;\n\n\t/* clear all data (including the reserved fields) */\n\tmemset(inp, 0, sizeof(*inp));\n\n\tinp->index = index;\n\tstrlcpy(inp->name, \"loopback\", sizeof(inp->name));\n\tinp->type = V4L2_INPUT_TYPE_CAMERA;\n\tinp->audioset = 0;\n\tinp->tuner = 0;\n\tinp->status = 0;\n\n#ifdef V4L2LOOPBACK_WITH_STD\n\tinp->std = V4L2_STD_ALL;\n#ifdef V4L2_IN_CAP_STD\n\tinp->capabilities |= V4L2_IN_CAP_STD;\n#endif\n#endif /* V4L2LOOPBACK_WITH_STD */\n\n\treturn 0;\n}\n\n/* which input is currently active,\n * called on VIDIOC_G_INPUT\n */\nstatic int vidioc_g_input(struct file *file, void *fh, unsigned int *i)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tif (!dev->announce_all_caps && !dev->ready_for_capture)\n\t\treturn -ENOTTY;\n\tif (i)\n\t\t*i = 0;\n\treturn 0;\n}\n\n/* set input, can make sense if we have more than one video src,\n * called on VIDIOC_S_INPUT\n */\nstatic int vidioc_s_input(struct file *file, void *fh, unsigned int i)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tif (!dev->announce_all_caps && !dev->ready_for_capture)\n\t\treturn -ENOTTY;\n\tif (i == 0)\n\t\treturn 0;\n\treturn -EINVAL;\n}\n\n/* --------------- V4L2 ioctl buffer related calls ----------------- */\n\n/* negotiate buffer type\n * only mmap streaming supported\n * called on VIDIOC_REQBUFS\n */\nstatic int vidioc_reqbufs(struct file *file, void *fh,\n\t\t\t  struct v4l2_requestbuffers *b)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\tint i;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(fh);\n\n\tdprintk(\"reqbufs: %d\\t%d=%d\\n\", b->memory, b->count,\n\t\tdev->buffers_number);\n\tif (opener->timeout_image_io) {\n\t\tif (b->memory != V4L2_MEMORY_MMAP)\n\t\t\treturn -EINVAL;\n\t\tb->count = 1;\n\t\treturn 0;\n\t}\n\n\tinit_buffers(dev);\n\tswitch (b->memory) {\n\tcase V4L2_MEMORY_MMAP:\n\t\t/* do nothing here, buffers are always allocated */\n\t\tif (b->count < 1 || dev->buffers_number < 1)\n\t\t\treturn 0;\n\n\t\tif (b->count > dev->buffers_number)\n\t\t\tb->count = dev->buffers_number;\n\n\t\t/* make sure that outbufs_list contains buffers from 0 to used_buffers-1\n\t\t * actually, it will have been already populated via v4l2_loopback_init()\n\t\t * at this point */\n\t\tif (list_empty(&dev->outbufs_list)) {\n\t\t\tfor (i = 0; i < dev->used_buffers; ++i)\n\t\t\t\tlist_add_tail(&dev->buffers[i].list_head,\n\t\t\t\t\t      &dev->outbufs_list);\n\t\t}\n\n\t\t/* also, if dev->used_buffers is going to be decreased, we should remove\n\t\t * out-of-range buffers from outbufs_list, and fix bufpos2index mapping */\n\t\tif (b->count < dev->used_buffers) {\n\t\t\tstruct v4l2l_buffer *pos, *n;\n\n\t\t\tlist_for_each_entry_safe (pos, n, &dev->outbufs_list,\n\t\t\t\t\t\t  list_head) {\n\t\t\t\tif (pos->buffer.index >= b->count)\n\t\t\t\t\tlist_del(&pos->list_head);\n\t\t\t}\n\n\t\t\t/* after we update dev->used_buffers, buffers in outbufs_list will\n\t\t\t * correspond to dev->write_position + [0;b->count-1] range */\n\t\t\ti = dev->write_position;\n\t\t\tlist_for_each_entry (pos, &dev->outbufs_list,\n\t\t\t\t\t     list_head) {\n\t\t\t\tdev->bufpos2index[i % b->count] =\n\t\t\t\t\tpos->buffer.index;\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\n\t\topener->buffers_number = b->count;\n\t\tif (opener->buffers_number < dev->used_buffers)\n\t\t\tdev->used_buffers = opener->buffers_number;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/* returns buffer asked for;\n * give app as many buffers as it wants, if it less than MAX,\n * but map them in our inner buffers\n * called on VIDIOC_QUERYBUF\n */\nstatic int vidioc_querybuf(struct file *file, void *fh, struct v4l2_buffer *b)\n{\n\tenum v4l2_buf_type type;\n\tint index;\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\n\tMARK();\n\n\ttype = b->type;\n\tindex = b->index;\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(fh);\n\n\tif ((b->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\n\t    (b->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)) {\n\t\treturn -EINVAL;\n\t}\n\tif (b->index > max_buffers)\n\t\treturn -EINVAL;\n\n\tif (opener->timeout_image_io)\n\t\t*b = dev->timeout_image_buffer.buffer;\n\telse\n\t\t*b = dev->buffers[b->index % dev->used_buffers].buffer;\n\n\tb->type = type;\n\tb->index = index;\n\tdprintkrw(\"buffer type: %d (of %d with size=%ld)\\n\", b->memory,\n\t\t  dev->buffers_number, dev->buffer_size);\n\n\t/*  Hopefully fix 'DQBUF return bad index if queue bigger then 2 for capture'\n            https://github.com/umlaeute/v4l2loopback/issues/60 */\n\tb->flags &= ~V4L2_BUF_FLAG_DONE;\n\tb->flags |= V4L2_BUF_FLAG_QUEUED;\n\n\treturn 0;\n}\n\nstatic void buffer_written(struct v4l2_loopback_device *dev,\n\t\t\t   struct v4l2l_buffer *buf)\n{\n\tdel_timer_sync(&dev->sustain_timer);\n\tdel_timer_sync(&dev->timeout_timer);\n\tspin_lock_bh(&dev->lock);\n\n\tdev->bufpos2index[dev->write_position % dev->used_buffers] =\n\t\tbuf->buffer.index;\n\tlist_move_tail(&buf->list_head, &dev->outbufs_list);\n\t++dev->write_position;\n\tdev->reread_count = 0;\n\n\tcheck_timers(dev);\n\tspin_unlock_bh(&dev->lock);\n}\n\n/* put buffer to queue\n * called on VIDIOC_QBUF\n */\nstatic int vidioc_qbuf(struct file *file, void *fh, struct v4l2_buffer *buf)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\tstruct v4l2l_buffer *b;\n\tint index;\n\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(fh);\n\n\tif (buf->index > max_buffers)\n\t\treturn -EINVAL;\n\tif (opener->timeout_image_io)\n\t\treturn 0;\n\n\tindex = buf->index % dev->used_buffers;\n\tb = &dev->buffers[index];\n\n\tswitch (buf->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tdprintkrw(\"capture QBUF index: %d\\n\", index);\n\t\tset_queued(b);\n\t\treturn 0;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tdprintkrw(\"output QBUF pos: %d index: %d\\n\",\n\t\t\t  dev->write_position, index);\n\t\tif (buf->timestamp.tv_sec == 0 && buf->timestamp.tv_usec == 0)\n\t\t\tv4l2l_get_timestamp(&b->buffer);\n\t\telse\n\t\t\tb->buffer.timestamp = buf->timestamp;\n\t\tb->buffer.bytesused = buf->bytesused;\n\t\tset_done(b);\n\t\tbuffer_written(dev, b);\n\n\t\t/*  Hopefully fix 'DQBUF return bad index if queue bigger then 2 for capture'\n                    https://github.com/umlaeute/v4l2loopback/issues/60 */\n\t\tbuf->flags &= ~V4L2_BUF_FLAG_DONE;\n\t\tbuf->flags |= V4L2_BUF_FLAG_QUEUED;\n\n\t\twake_up_all(&dev->read_event);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int can_read(struct v4l2_loopback_device *dev,\n\t\t    struct v4l2_loopback_opener *opener)\n{\n\tint ret;\n\n\tspin_lock_bh(&dev->lock);\n\tcheck_timers(dev);\n\tret = dev->write_position > opener->read_position ||\n\t      dev->reread_count > opener->reread_count || dev->timeout_happened;\n\tspin_unlock_bh(&dev->lock);\n\treturn ret;\n}\n\nstatic int get_capture_buffer(struct file *file)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tstruct v4l2_loopback_opener *opener = fh_to_opener(file->private_data);\n\tint pos, ret;\n\tint timeout_happened;\n\n\tif ((file->f_flags & O_NONBLOCK) &&\n\t    (dev->write_position <= opener->read_position &&\n\t     dev->reread_count <= opener->reread_count &&\n\t     !dev->timeout_happened))\n\t\treturn -EAGAIN;\n\twait_event_interruptible(dev->read_event, can_read(dev, opener));\n\n\tspin_lock_bh(&dev->lock);\n\tif (dev->write_position == opener->read_position) {\n\t\tif (dev->reread_count > opener->reread_count + 2)\n\t\t\topener->reread_count = dev->reread_count - 1;\n\t\t++opener->reread_count;\n\t\tpos = (opener->read_position + dev->used_buffers - 1) %\n\t\t      dev->used_buffers;\n\t} else {\n\t\topener->reread_count = 0;\n\t\tif (dev->write_position >\n\t\t    opener->read_position + dev->used_buffers)\n\t\t\topener->read_position = dev->write_position - 1;\n\t\tpos = opener->read_position % dev->used_buffers;\n\t\t++opener->read_position;\n\t}\n\ttimeout_happened = dev->timeout_happened;\n\tdev->timeout_happened = 0;\n\tspin_unlock_bh(&dev->lock);\n\n\tret = dev->bufpos2index[pos];\n\tif (timeout_happened) {\n\t\tif (ret < 0) {\n\t\t\tdprintk(\"trying to return not mapped buf[%d]\\n\", ret);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\t/* although allocated on-demand, timeout_image is freed only\n\t\t * in free_buffers(), so we don't need to worry about it being\n\t\t * deallocated suddenly */\n\t\tmemcpy(dev->image + dev->buffers[ret].buffer.m.offset,\n\t\t       dev->timeout_image, dev->buffer_size);\n\t}\n\treturn ret;\n}\n\n/* put buffer to dequeue\n * called on VIDIOC_DQBUF\n */\nstatic int vidioc_dqbuf(struct file *file, void *fh, struct v4l2_buffer *buf)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\tint index;\n\tstruct v4l2l_buffer *b;\n\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(fh);\n\tif (opener->timeout_image_io) {\n\t\t*buf = dev->timeout_image_buffer.buffer;\n\t\treturn 0;\n\t}\n\n\tswitch (buf->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tindex = get_capture_buffer(file);\n\t\tif (index < 0)\n\t\t\treturn index;\n\t\tdprintkrw(\"capture DQBUF pos: %d index: %d\\n\",\n\t\t\t  opener->read_position - 1, index);\n\t\tif (!(dev->buffers[index].buffer.flags &\n\t\t      V4L2_BUF_FLAG_MAPPED)) {\n\t\t\tdprintk(\"trying to return not mapped buf[%d]\\n\", index);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tunset_flags(&dev->buffers[index]);\n\t\t*buf = dev->buffers[index].buffer;\n\t\treturn 0;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tb = list_entry(dev->outbufs_list.prev, struct v4l2l_buffer,\n\t\t\t       list_head);\n\t\tlist_move_tail(&b->list_head, &dev->outbufs_list);\n\t\tdprintkrw(\"output DQBUF index: %d\\n\", b->buffer.index);\n\t\tunset_flags(b);\n\t\t*buf = b->buffer;\n\t\tbuf->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/* ------------- STREAMING ------------------- */\n\n/* start streaming\n * called on VIDIOC_STREAMON\n */\nstatic int vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type type)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(fh);\n\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif (!dev->ready_for_capture) {\n\t\t\tint ret = allocate_buffers(dev);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\topener->type = WRITER;\n\t\tdev->ready_for_output = 0;\n\t\tdev->ready_for_capture++;\n\t\treturn 0;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tif (!dev->ready_for_capture)\n\t\t\treturn -EIO;\n\t\topener->type = READER;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn -EINVAL;\n}\n\n/* stop streaming\n * called on VIDIOC_STREAMOFF\n */\nstatic int vidioc_streamoff(struct file *file, void *fh,\n\t\t\t    enum v4l2_buf_type type)\n{\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\tdprintk(\"%d\\n\", type);\n\n\tdev = v4l2loopback_getdevice(file);\n\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif (dev->ready_for_capture > 0)\n\t\t\tdev->ready_for_capture--;\n\t\treturn 0;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_VIDEO_V4L1_COMPAT\nstatic int vidiocgmbuf(struct file *file, void *fh, struct video_mbuf *p)\n{\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\tp->frames = dev->buffers_number;\n\tp->offsets[0] = 0;\n\tp->offsets[1] = 0;\n\tp->size = dev->buffer_size;\n\treturn 0;\n}\n#endif\n\nstatic int vidioc_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\t  const struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_CTRL:\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\t}\n\n\treturn -EINVAL;\n}\n\n/* file operations */\nstatic void vm_open(struct vm_area_struct *vma)\n{\n\tstruct v4l2l_buffer *buf;\n\tMARK();\n\n\tbuf = vma->vm_private_data;\n\tbuf->use_count++;\n}\n\nstatic void vm_close(struct vm_area_struct *vma)\n{\n\tstruct v4l2l_buffer *buf;\n\tMARK();\n\n\tbuf = vma->vm_private_data;\n\tbuf->use_count--;\n}\n\nstatic struct vm_operations_struct vm_ops = {\n\t.open = vm_open,\n\t.close = vm_close,\n};\n\nstatic int v4l2_loopback_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tu8 *addr;\n\tunsigned long start;\n\tunsigned long size;\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\tstruct v4l2l_buffer *buffer = NULL;\n\tMARK();\n\n\tstart = (unsigned long)vma->vm_start;\n\tsize = (unsigned long)(vma->vm_end - vma->vm_start);\n\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(file->private_data);\n\n\tif (size > dev->buffer_size) {\n\t\tdprintk(\"userspace tries to mmap too much, fail\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (opener->timeout_image_io) {\n\t\t/* we are going to map the timeout_image_buffer */\n\t\tif ((vma->vm_pgoff << PAGE_SHIFT) !=\n\t\t    dev->buffer_size * MAX_BUFFERS) {\n\t\t\tdprintk(\"invalid mmap offset for timeout_image_io mode\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if ((vma->vm_pgoff << PAGE_SHIFT) >\n\t\t   dev->buffer_size * (dev->buffers_number - 1)) {\n\t\tdprintk(\"userspace tries to mmap too far, fail\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* FIXXXXXME: allocation should not happen here! */\n\tif (NULL == dev->image)\n\t\tif (allocate_buffers(dev) < 0)\n\t\t\treturn -EINVAL;\n\n\tif (opener->timeout_image_io) {\n\t\tbuffer = &dev->timeout_image_buffer;\n\t\taddr = dev->timeout_image;\n\t} else {\n\t\tint i;\n\t\tfor (i = 0; i < dev->buffers_number; ++i) {\n\t\t\tbuffer = &dev->buffers[i];\n\t\t\tif ((buffer->buffer.m.offset >> PAGE_SHIFT) ==\n\t\t\t    vma->vm_pgoff)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (NULL == buffer)\n\t\t\treturn -EINVAL;\n\n\t\taddr = dev->image + (vma->vm_pgoff << PAGE_SHIFT);\n\t}\n\n\twhile (size > 0) {\n\t\tstruct page *page;\n\n\t\tpage = vmalloc_to_page(addr);\n\n\t\tif (vm_insert_page(vma, start, page) < 0)\n\t\t\treturn -EAGAIN;\n\n\t\tstart += PAGE_SIZE;\n\t\taddr += PAGE_SIZE;\n\t\tsize -= PAGE_SIZE;\n\t}\n\n\tvma->vm_ops = &vm_ops;\n\tvma->vm_private_data = buffer;\n\tbuffer->buffer.flags |= V4L2_BUF_FLAG_MAPPED;\n\n\tvm_open(vma);\n\n\tMARK();\n\treturn 0;\n}\n\nstatic unsigned int v4l2_loopback_poll(struct file *file,\n\t\t\t\t       struct poll_table_struct *pts)\n{\n\tstruct v4l2_loopback_opener *opener;\n\tstruct v4l2_loopback_device *dev;\n\t__poll_t req_events = poll_requested_events(pts);\n\tint ret_mask = 0;\n\tMARK();\n\n\topener = fh_to_opener(file->private_data);\n\tdev = v4l2loopback_getdevice(file);\n\n\tif (req_events & POLLPRI) {\n\t\tif (!v4l2_event_pending(&opener->fh))\n\t\t\tpoll_wait(file, &opener->fh.wait, pts);\n\t\tif (v4l2_event_pending(&opener->fh)) {\n\t\t\tret_mask |= POLLPRI;\n\t\t\tif (!(req_events & DEFAULT_POLLMASK))\n\t\t\t\treturn ret_mask;\n\t\t}\n\t}\n\n\tswitch (opener->type) {\n\tcase WRITER:\n\t\tret_mask |= POLLOUT | POLLWRNORM;\n\t\tbreak;\n\tcase READER:\n\t\tif (!can_read(dev, opener)) {\n\t\t\tif (ret_mask)\n\t\t\t\treturn ret_mask;\n\t\t\tpoll_wait(file, &dev->read_event, pts);\n\t\t}\n\t\tif (can_read(dev, opener))\n\t\t\tret_mask |= POLLIN | POLLRDNORM;\n\t\tif (v4l2_event_pending(&opener->fh))\n\t\t\tret_mask |= POLLPRI;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tMARK();\n\treturn ret_mask;\n}\n\n/* do not want to limit device opens, it can be as many readers as user want,\n * writers are limited by means of setting writer field */\nstatic int v4l2_loopback_open(struct file *file)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\tMARK();\n\tdev = v4l2loopback_getdevice(file);\n\tif (dev->open_count.counter >= dev->max_openers)\n\t\treturn -EBUSY;\n\t/* kfree on close */\n\topener = kzalloc(sizeof(*opener), GFP_KERNEL);\n\tif (opener == NULL)\n\t\treturn -ENOMEM;\n\n\tatomic_inc(&dev->open_count);\n\n\topener->timeout_image_io = dev->timeout_image_io;\n\tif (opener->timeout_image_io) {\n\t\tint r = allocate_timeout_image(dev);\n\n\t\tif (r < 0) {\n\t\t\tdprintk(\"timeout image allocation failed\\n\");\n\n\t\t\tatomic_dec(&dev->open_count);\n\n\t\t\tkfree(opener);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tdev->timeout_image_io = 0;\n\n\tv4l2_fh_init(&opener->fh, video_devdata(file));\n\tfile->private_data = &opener->fh;\n\n\tv4l2_fh_add(&opener->fh);\n\tdprintk(\"opened dev:%p with image:%p\\n\", dev, dev ? dev->image : NULL);\n\tMARK();\n\treturn 0;\n}\n\nstatic int v4l2_loopback_close(struct file *file)\n{\n\tstruct v4l2_loopback_opener *opener;\n\tstruct v4l2_loopback_device *dev;\n\tint iswriter = 0;\n\tMARK();\n\n\topener = fh_to_opener(file->private_data);\n\tdev = v4l2loopback_getdevice(file);\n\n\tif (WRITER == opener->type)\n\t\tiswriter = 1;\n\n\tatomic_dec(&dev->open_count);\n\tif (dev->open_count.counter == 0) {\n\t\tdel_timer_sync(&dev->sustain_timer);\n\t\tdel_timer_sync(&dev->timeout_timer);\n\t}\n\ttry_free_buffers(dev);\n\n\tv4l2_fh_del(&opener->fh);\n\tv4l2_fh_exit(&opener->fh);\n\n\tkfree(opener);\n\tif (iswriter) {\n\t\tdev->ready_for_output = 1;\n\t}\n\tMARK();\n\treturn 0;\n}\n\nstatic ssize_t v4l2_loopback_read(struct file *file, char __user *buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tint read_index;\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_buffer *b;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\n\tread_index = get_capture_buffer(file);\n\tif (read_index < 0)\n\t\treturn read_index;\n\tif (count > dev->buffer_size)\n\t\tcount = dev->buffer_size;\n\tb = &dev->buffers[read_index].buffer;\n\tif (count > b->bytesused)\n\t\tcount = b->bytesused;\n\tif (copy_to_user((void *)buf, (void *)(dev->image + b->m.offset),\n\t\t\t count)) {\n\t\tprintk(KERN_ERR\n\t\t       \"v4l2-loopback: failed copy_to_user() in read buf\\n\");\n\t\treturn -EFAULT;\n\t}\n\tdprintkrw(\"leave v4l2_loopback_read()\\n\");\n\treturn count;\n}\n\nstatic ssize_t v4l2_loopback_write(struct file *file, const char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct v4l2_loopback_opener *opener;\n\tstruct v4l2_loopback_device *dev;\n\tint write_index;\n\tstruct v4l2_buffer *b;\n\tint err = 0;\n\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(file->private_data);\n\n\tif (UNNEGOTIATED == opener->type) {\n\t\tspin_lock(&dev->lock);\n\n\t\tif (dev->ready_for_output) {\n\t\t\terr = vidioc_streamon(file, file->private_data,\n\t\t\t\t\t      V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\t\t}\n\n\t\tspin_unlock(&dev->lock);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (WRITER != opener->type)\n\t\treturn -EINVAL;\n\n\tif (!dev->ready_for_capture) {\n\t\tint ret = allocate_buffers(dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdev->ready_for_capture = 1;\n\t}\n\tdprintkrw(\"v4l2_loopback_write() trying to write %zu bytes\\n\", count);\n\tif (count > dev->buffer_size)\n\t\tcount = dev->buffer_size;\n\n\twrite_index = dev->write_position % dev->used_buffers;\n\tb = &dev->buffers[write_index].buffer;\n\n\tif (copy_from_user((void *)(dev->image + b->m.offset), (void *)buf,\n\t\t\t   count)) {\n\t\tprintk(KERN_ERR\n\t\t       \"v4l2-loopback: failed copy_from_user() in write buf, could not write %zu\\n\",\n\t\t       count);\n\t\treturn -EFAULT;\n\t}\n\tv4l2l_get_timestamp(b);\n\tb->bytesused = count;\n\tb->sequence = dev->write_position;\n\tbuffer_written(dev, &dev->buffers[write_index]);\n\twake_up_all(&dev->read_event);\n\tdprintkrw(\"leave v4l2_loopback_write()\\n\");\n\treturn count;\n}\n\n/* init functions */\n/* frees buffers, if already allocated */\nstatic void free_buffers(struct v4l2_loopback_device *dev)\n{\n\tMARK();\n\tdprintk(\"freeing image@%p for dev:%p\\n\", dev ? dev->image : NULL, dev);\n\tif (dev->image) {\n\t\tvfree(dev->image);\n\t\tdev->image = NULL;\n\t}\n\tif (dev->timeout_image) {\n\t\tvfree(dev->timeout_image);\n\t\tdev->timeout_image = NULL;\n\t}\n\tdev->imagesize = 0;\n}\n/* frees buffers, if they are no longer needed */\nstatic void try_free_buffers(struct v4l2_loopback_device *dev)\n{\n\tMARK();\n\tif (0 == dev->open_count.counter && !dev->keep_format) {\n\t\tfree_buffers(dev);\n\t\tdev->ready_for_capture = 0;\n\t\tdev->buffer_size = 0;\n\t\tdev->write_position = 0;\n\t}\n}\n/* allocates buffers, if buffer_size is set */\nstatic int allocate_buffers(struct v4l2_loopback_device *dev)\n{\n\tint err;\n\n\tMARK();\n\t/* vfree on close file operation in case no open handles left */\n\n\tif (dev->buffer_size < 1 || dev->buffers_number < 1)\n\t\treturn -EINVAL;\n\n\tif ((__LONG_MAX__ / dev->buffer_size) < dev->buffers_number)\n\t\treturn -ENOSPC;\n\n\tif (dev->image) {\n\t\tdprintk(\"allocating buffers again: %ld %ld\\n\",\n\t\t\tdev->buffer_size * dev->buffers_number, dev->imagesize);\n\t\t/* FIXME: prevent double allocation more intelligently! */\n\t\tif (dev->buffer_size * dev->buffers_number == dev->imagesize)\n\t\t\treturn 0;\n\n\t\t/* if there is only one writer, no problem should occur */\n\t\tif (dev->open_count.counter == 1)\n\t\t\tfree_buffers(dev);\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tdev->imagesize = (unsigned long)dev->buffer_size *\n\t\t\t (unsigned long)dev->buffers_number;\n\n\tdprintk(\"allocating %ld = %ldx%d\\n\", dev->imagesize, dev->buffer_size,\n\t\tdev->buffers_number);\n\terr = -ENOMEM;\n\n\tif (dev->timeout_jiffies > 0) {\n\t\terr = allocate_timeout_image(dev);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t}\n\n\tdev->image = vmalloc(dev->imagesize);\n\tif (dev->image == NULL)\n\t\tgoto error;\n\n\tdprintk(\"vmallocated %ld bytes\\n\", dev->imagesize);\n\tMARK();\n\n\tinit_buffers(dev);\n\treturn 0;\n\nerror:\n\tfree_buffers(dev);\n\treturn err;\n}\n\n/* init inner buffers, they are capture mode and flags are set as\n * for capture mod buffers */\nstatic void init_buffers(struct v4l2_loopback_device *dev)\n{\n\tint i;\n\tint buffer_size;\n\tint bytesused;\n\tMARK();\n\n\tbuffer_size = dev->buffer_size;\n\tbytesused = dev->pix_format.sizeimage;\n\n\tfor (i = 0; i < dev->buffers_number; ++i) {\n\t\tstruct v4l2_buffer *b = &dev->buffers[i].buffer;\n\t\tb->index = i;\n\t\tb->bytesused = bytesused;\n\t\tb->length = buffer_size;\n\t\tb->field = V4L2_FIELD_NONE;\n\t\tb->flags = 0;\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 1)\n\t\tb->input = 0;\n#endif\n\t\tb->m.offset = i * buffer_size;\n\t\tb->memory = V4L2_MEMORY_MMAP;\n\t\tb->sequence = 0;\n\t\tb->timestamp.tv_sec = 0;\n\t\tb->timestamp.tv_usec = 0;\n\t\tb->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n\t\tv4l2l_get_timestamp(b);\n\t}\n\tdev->timeout_image_buffer = dev->buffers[0];\n\tdev->timeout_image_buffer.buffer.m.offset = MAX_BUFFERS * buffer_size;\n\tMARK();\n}\n\nstatic int allocate_timeout_image(struct v4l2_loopback_device *dev)\n{\n\tMARK();\n\tif (dev->buffer_size <= 0)\n\t\treturn -EINVAL;\n\n\tif (dev->timeout_image == NULL) {\n\t\tdev->timeout_image = v4l2l_vzalloc(dev->buffer_size);\n\t\tif (dev->timeout_image == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n/* fills and register video device */\nstatic void init_vdev(struct video_device *vdev, int nr)\n{\n\tMARK();\n\n#ifdef V4L2LOOPBACK_WITH_STD\n\tvdev->tvnorms = V4L2_STD_ALL;\n#endif /* V4L2LOOPBACK_WITH_STD */\n\n\tvdev->vfl_type = VFL_TYPE_VIDEO;\n\tvdev->fops = &v4l2_loopback_fops;\n\tvdev->ioctl_ops = &v4l2_loopback_ioctl_ops;\n\tvdev->release = &video_device_release;\n\tvdev->minor = -1;\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n\tvdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT |\n\t\t\t    V4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\n#ifdef V4L2_CAP_VIDEO_M2M\n\tvdev->device_caps |= V4L2_CAP_VIDEO_M2M;\n#endif\n#endif /* >=linux-4.7.0 */\n\n\tif (debug > 1)\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 20, 0)\n\t\tvdev->debug = V4L2_DEBUG_IOCTL | V4L2_DEBUG_IOCTL_ARG;\n#else\n\t\tvdev->dev_debug =\n\t\t\tV4L2_DEV_DEBUG_IOCTL | V4L2_DEV_DEBUG_IOCTL_ARG;\n#endif\n\n\t\t/* since kernel-3.7, there is a new field 'vfl_dir' that has to be\n\t * set to VFL_DIR_M2M for bidirectional devices */\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0)\n\tvdev->vfl_dir = VFL_DIR_M2M;\n#endif\n\n\tMARK();\n}\n\n/* init default capture parameters, only fps may be changed in future */\nstatic void init_capture_param(struct v4l2_captureparm *capture_param)\n{\n\tMARK();\n\tcapture_param->capability = 0;\n\tcapture_param->capturemode = 0;\n\tcapture_param->extendedmode = 0;\n\tcapture_param->readbuffers = max_buffers;\n\tcapture_param->timeperframe.numerator = 1;\n\tcapture_param->timeperframe.denominator = 30;\n}\n\nstatic void check_timers(struct v4l2_loopback_device *dev)\n{\n\tif (!dev->ready_for_capture)\n\t\treturn;\n\n\tif (dev->timeout_jiffies > 0 && !timer_pending(&dev->timeout_timer))\n\t\tmod_timer(&dev->timeout_timer, jiffies + dev->timeout_jiffies);\n\tif (dev->sustain_framerate && !timer_pending(&dev->sustain_timer))\n\t\tmod_timer(&dev->sustain_timer,\n\t\t\t  jiffies + dev->frame_jiffies * 3 / 2);\n}\n#ifdef HAVE_TIMER_SETUP\nstatic void sustain_timer_clb(struct timer_list *t)\n{\n\tstruct v4l2_loopback_device *dev = from_timer(dev, t, sustain_timer);\n#else\nstatic void sustain_timer_clb(unsigned long nr)\n{\n\tstruct v4l2_loopback_device *dev =\n\t\tidr_find(&v4l2loopback_index_idr, nr);\n#endif\n\tspin_lock(&dev->lock);\n\tif (dev->sustain_framerate) {\n\t\tdev->reread_count++;\n\t\tdprintkrw(\"reread: %d %d\\n\", dev->write_position,\n\t\t\t  dev->reread_count);\n\t\tif (dev->reread_count == 1)\n\t\t\tmod_timer(&dev->sustain_timer,\n\t\t\t\t  jiffies + max(1UL, dev->frame_jiffies / 2));\n\t\telse\n\t\t\tmod_timer(&dev->sustain_timer,\n\t\t\t\t  jiffies + dev->frame_jiffies);\n\t\twake_up_all(&dev->read_event);\n\t}\n\tspin_unlock(&dev->lock);\n}\n#ifdef HAVE_TIMER_SETUP\nstatic void timeout_timer_clb(struct timer_list *t)\n{\n\tstruct v4l2_loopback_device *dev = from_timer(dev, t, timeout_timer);\n#else\nstatic void timeout_timer_clb(unsigned long nr)\n{\n\tstruct v4l2_loopback_device *dev =\n\t\tidr_find(&v4l2loopback_index_idr, nr);\n#endif\n\tspin_lock(&dev->lock);\n\tif (dev->timeout_jiffies > 0) {\n\t\tdev->timeout_happened = 1;\n\t\tmod_timer(&dev->timeout_timer, jiffies + dev->timeout_jiffies);\n\t\twake_up_all(&dev->read_event);\n\t}\n\tspin_unlock(&dev->lock);\n}\n\n/* init loopback main structure */\n#define DEFAULT_FROM_CONF(confmember, default_condition, default_value)        \\\n\t((conf) ?                                                              \\\n\t\t ((conf->confmember default_condition) ? (default_value) :     \\\n\t\t\t\t\t\t\t       (conf->confmember)) : \\\n\t\t       default_value)\n\nstatic int v4l2_loopback_add(struct v4l2_loopback_config *conf, int *ret_nr)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct v4l2loopback_private *vdev_priv = NULL;\n\n\tint err = -ENOMEM;\n\n\tint _max_width = DEFAULT_FROM_CONF(\n\t\tmax_width, < V4L2LOOPBACK_SIZE_MIN_WIDTH, max_width);\n\tint _max_height = DEFAULT_FROM_CONF(\n\t\tmax_height, < V4L2LOOPBACK_SIZE_MIN_HEIGHT, max_height);\n\tbool _announce_all_caps = (conf && conf->announce_all_caps >= 0) ?\n\t\t\t\t\t  (conf->announce_all_caps) :\n\t\t\t\t\t\tV4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS;\n\tint _max_buffers = DEFAULT_FROM_CONF(max_buffers, <= 0, max_buffers);\n\tint _max_openers = DEFAULT_FROM_CONF(max_openers, <= 0, max_openers);\n\n\tint nr = -1;\n\n\t_announce_all_caps = (!!_announce_all_caps);\n\n\tif (conf) {\n\t\tif (conf->capture_nr >= 0 &&\n\t\t    conf->output_nr == conf->capture_nr) {\n\t\t\tnr = conf->capture_nr;\n\t\t} else if (conf->capture_nr < 0 && conf->output_nr < 0) {\n\t\t\tnr = -1;\n\t\t} else if (conf->capture_nr < 0) {\n\t\t\tnr = conf->output_nr;\n\t\t} else if (conf->output_nr < 0) {\n\t\t\tnr = conf->capture_nr;\n\t\t} else {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"split OUTPUT and CAPTURE devices not yet supported.\");\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"both devices must have the same number (%d != %d).\",\n\t\t\t       conf->output_nr, conf->capture_nr);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (idr_find(&v4l2loopback_index_idr, nr))\n\t\treturn -EEXIST;\n\n\tdprintk(\"creating v4l2loopback-device #%d\\n\", nr);\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t/* allocate id, if @id >= 0, we're requesting that specific id */\n\tif (nr >= 0) {\n\t\terr = idr_alloc(&v4l2loopback_index_idr, dev, nr, nr + 1,\n\t\t\t\tGFP_KERNEL);\n\t\tif (err == -ENOSPC)\n\t\t\terr = -EEXIST;\n\t} else {\n\t\terr = idr_alloc(&v4l2loopback_index_idr, dev, 0, 0, GFP_KERNEL);\n\t}\n\tif (err < 0)\n\t\tgoto out_free_dev;\n\tnr = err;\n\terr = -ENOMEM;\n\n\tif (conf && conf->card_label && *(conf->card_label)) {\n\t\tsnprintf(dev->card_label, sizeof(dev->card_label), \"%s\",\n\t\t\t conf->card_label);\n\t} else {\n\t\tsnprintf(dev->card_label, sizeof(dev->card_label),\n\t\t\t \"Dummy video device (0x%04X)\", nr);\n\t}\n\tsnprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name),\n\t\t \"v4l2loopback-%03d\", nr);\n\n\terr = v4l2_device_register(NULL, &dev->v4l2_dev);\n\tif (err)\n\t\tgoto out_free_idr;\n\tMARK();\n\n\tdev->vdev = video_device_alloc();\n\tif (dev->vdev == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unregister;\n\t}\n\n\tvdev_priv = kzalloc(sizeof(struct v4l2loopback_private), GFP_KERNEL);\n\tif (vdev_priv == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unregister;\n\t}\n\n\tvideo_set_drvdata(dev->vdev, vdev_priv);\n\tif (video_get_drvdata(dev->vdev) == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unregister;\n\t}\n\n\tMARK();\n\tsnprintf(dev->vdev->name, sizeof(dev->vdev->name), dev->card_label);\n\n\tvdev_priv->device_nr = nr;\n\n\tinit_vdev(dev->vdev, nr);\n\tdev->vdev->v4l2_dev = &dev->v4l2_dev;\n\tinit_capture_param(&dev->capture_param);\n\terr = set_timeperframe(dev, &dev->capture_param.timeperframe);\n\tif (err)\n\t\tgoto out_unregister;\n\tdev->keep_format = 0;\n\tdev->sustain_framerate = 0;\n\n\tdev->announce_all_caps = _announce_all_caps;\n\tdev->max_width = _max_width;\n\tdev->max_height = _max_height;\n\tdev->max_openers = _max_openers;\n\tdev->buffers_number = dev->used_buffers = _max_buffers;\n\n\tdev->write_position = 0;\n\n\tMARK();\n\tspin_lock_init(&dev->lock);\n\tINIT_LIST_HEAD(&dev->outbufs_list);\n\tif (list_empty(&dev->outbufs_list)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < dev->used_buffers; ++i)\n\t\t\tlist_add_tail(&dev->buffers[i].list_head,\n\t\t\t\t      &dev->outbufs_list);\n\t}\n\tmemset(dev->bufpos2index, 0, sizeof(dev->bufpos2index));\n\tatomic_set(&dev->open_count, 0);\n\tdev->ready_for_capture = 0;\n\tdev->ready_for_output = 1;\n\n\tdev->buffer_size = 0;\n\tdev->image = NULL;\n\tdev->imagesize = 0;\n#ifdef HAVE_TIMER_SETUP\n\ttimer_setup(&dev->sustain_timer, sustain_timer_clb, 0);\n\ttimer_setup(&dev->timeout_timer, timeout_timer_clb, 0);\n#else\n\tsetup_timer(&dev->sustain_timer, sustain_timer_clb, nr);\n\tsetup_timer(&dev->timeout_timer, timeout_timer_clb, nr);\n#endif\n\tdev->reread_count = 0;\n\tdev->timeout_jiffies = 0;\n\tdev->timeout_image = NULL;\n\tdev->timeout_happened = 0;\n\n\thdl = &dev->ctrl_handler;\n\terr = v4l2_ctrl_handler_init(hdl, 4);\n\tif (err)\n\t\tgoto out_unregister;\n\tv4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_keepformat, NULL);\n\tv4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_sustainframerate, NULL);\n\tv4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_timeout, NULL);\n\tv4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_timeoutimageio, NULL);\n\tif (hdl->error) {\n\t\terr = hdl->error;\n\t\tgoto out_free_handler;\n\t}\n\tdev->v4l2_dev.ctrl_handler = hdl;\n\n\terr = v4l2_ctrl_handler_setup(hdl);\n\tif (err)\n\t\tgoto out_free_handler;\n\n\t/* FIXME set buffers to 0 */\n\n\t/* Set initial format */\n\tdev->pix_format.width = 0; /* V4L2LOOPBACK_SIZE_DEFAULT_WIDTH; */\n\tdev->pix_format.height = 0; /* V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT; */\n\tdev->pix_format.pixelformat = formats[0].fourcc;\n\tdev->pix_format.colorspace =\n\t\tV4L2_COLORSPACE_SRGB; /* do we need to set this ? */\n\tdev->pix_format.field = V4L2_FIELD_NONE;\n\n\tdev->buffer_size = PAGE_ALIGN(dev->pix_format.sizeimage);\n\tdprintk(\"buffer_size = %ld (=%d)\\n\", dev->buffer_size,\n\t\tdev->pix_format.sizeimage);\n\n\tif (dev->buffer_size && ((err = allocate_buffers(dev)) < 0))\n\t\tgoto out_free_handler;\n\n\tinit_waitqueue_head(&dev->read_event);\n\n\t/* register the device -> it creates /dev/video* */\n\tif (video_register_device(dev->vdev, VFL_TYPE_VIDEO, nr) < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"v4l2loopback: failed video_register_device()\\n\");\n\t\terr = -EFAULT;\n\t\tgoto out_free_device;\n\t}\n\tv4l2loopback_create_sysfs(dev->vdev);\n\n\tMARK();\n\tif (ret_nr)\n\t\t*ret_nr = dev->vdev->num;\n\treturn 0;\n\nout_free_device:\n\tvideo_device_release(dev->vdev);\nout_free_handler:\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\nout_unregister:\n\tvideo_set_drvdata(dev->vdev, NULL);\n\tif (vdev_priv != NULL)\n\t\tkfree(vdev_priv);\n\tv4l2_device_unregister(&dev->v4l2_dev);\nout_free_idr:\n\tidr_remove(&v4l2loopback_index_idr, nr);\nout_free_dev:\n\tkfree(dev);\n\treturn err;\n}\n\nstatic void v4l2_loopback_remove(struct v4l2_loopback_device *dev)\n{\n\tfree_buffers(dev);\n\tv4l2loopback_remove_sysfs(dev->vdev);\n\tkfree(video_get_drvdata(dev->vdev));\n\tvideo_unregister_device(dev->vdev);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\n\tkfree(dev);\n}\n\nstatic long v4l2loopback_control_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t       unsigned long parm)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_config conf;\n\tstruct v4l2_loopback_config *confptr = &conf;\n\tint device_nr;\n\tint ret;\n\n\tret = mutex_lock_killable(&v4l2loopback_ctl_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EINVAL;\n\tswitch (cmd) {\n\tdefault:\n\t\tret = -ENOSYS;\n\t\tbreak;\n\t\t/* add a v4l2loopback device (pair), based on the user-provided specs */\n\tcase V4L2LOOPBACK_CTL_ADD:\n\t\tif (parm) {\n\t\t\tif ((ret = copy_from_user(&conf, (void *)parm,\n\t\t\t\t\t\t  sizeof(conf))) < 0)\n\t\t\t\tbreak;\n\t\t} else\n\t\t\tconfptr = NULL;\n\t\tret = v4l2_loopback_add(confptr, &device_nr);\n\t\tif (ret >= 0)\n\t\t\tret = device_nr;\n\t\tbreak;\n\t\t/* remove a v4l2loopback device (both capture and output) */\n\tcase V4L2LOOPBACK_CTL_REMOVE:\n\t\tret = v4l2loopback_lookup((int)parm, &dev);\n\t\tif (ret >= 0 && dev) {\n\t\t\tint nr = ret;\n\t\t\tret = -EBUSY;\n\t\t\tif (dev->open_count.counter > 0)\n\t\t\t\tbreak;\n\t\t\tidr_remove(&v4l2loopback_index_idr, nr);\n\t\t\tv4l2_loopback_remove(dev);\n\t\t\tret = 0;\n\t\t};\n\t\tbreak;\n\t\t/* get information for a loopback device.\n                 * this is mostly about limits (which cannot be queried directly with  VIDIOC_G_FMT and friends\n                 */\n\tcase V4L2LOOPBACK_CTL_QUERY:\n\t\tif (!parm)\n\t\t\tbreak;\n\t\tif ((ret = copy_from_user(&conf, (void *)parm, sizeof(conf))) <\n\t\t    0)\n\t\t\tbreak;\n\t\tdevice_nr =\n\t\t\t(conf.output_nr < 0) ? conf.capture_nr : conf.output_nr;\n\t\tMARK();\n\t\t/* get the device from either capture_nr or output_nr (whatever is valid) */\n\t\tif ((ret = v4l2loopback_lookup(device_nr, &dev)) < 0)\n\t\t\tbreak;\n\t\tMARK();\n\t\t/* if we got the device from output_nr and there is a valid capture_nr,\n                 * make sure that both refer to the same device (or bail out)\n                 */\n\t\tif ((device_nr != conf.capture_nr) && (conf.capture_nr >= 0) &&\n\t\t    (ret != v4l2loopback_lookup(conf.capture_nr, 0)))\n\t\t\tbreak;\n\t\tMARK();\n\t\t/* if otoh, we got the device from capture_nr and there is a valid output_nr,\n                 * make sure that both refer to the same device (or bail out)\n                 */\n\t\tif ((device_nr != conf.output_nr) && (conf.output_nr >= 0) &&\n\t\t    (ret != v4l2loopback_lookup(conf.output_nr, 0)))\n\t\t\tbreak;\n\t\tMARK();\n\n\t\t/* v4l2_loopback_config identified a single device, so fetch the data */\n\t\tsnprintf(conf.card_label, sizeof(conf.card_label), \"%s\",\n\t\t\t dev->card_label);\n\t\tMARK();\n\t\tconf.output_nr = conf.capture_nr = dev->vdev->num;\n\t\tconf.max_width = dev->max_width;\n\t\tconf.max_height = dev->max_height;\n\t\tconf.announce_all_caps = dev->announce_all_caps;\n\t\tconf.max_buffers = dev->buffers_number;\n\t\tconf.max_openers = dev->max_openers;\n\t\tconf.debug = debug;\n\t\tMARK();\n\t\tif (copy_to_user((void *)parm, &conf, sizeof(conf))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tMARK();\n\t\tret = 0;\n\t\t;\n\t\tbreak;\n\t}\n\n\tMARK();\n\tmutex_unlock(&v4l2loopback_ctl_mutex);\n\tMARK();\n\treturn ret;\n}\n\n/* LINUX KERNEL */\n\nstatic const struct file_operations v4l2loopback_ctl_fops = {\n\t// clang-format off\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= nonseekable_open,\n\t.unlocked_ioctl\t= v4l2loopback_control_ioctl,\n\t.compat_ioctl\t= v4l2loopback_control_ioctl,\n\t.llseek\t\t= noop_llseek,\n\t// clang-format on\n};\n\nstatic struct miscdevice v4l2loopback_misc = {\n\t// clang-format off\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"v4l2loopback\",\n\t.fops\t\t= &v4l2loopback_ctl_fops,\n\t// clang-format on\n};\n\nstatic const struct v4l2_file_operations v4l2_loopback_fops = {\n\t// clang-format off\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= v4l2_loopback_open,\n\t.release\t= v4l2_loopback_close,\n\t.read\t\t= v4l2_loopback_read,\n\t.write\t\t= v4l2_loopback_write,\n\t.poll\t\t= v4l2_loopback_poll,\n\t.mmap\t\t= v4l2_loopback_mmap,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t// clang-format on\n};\n\nstatic const struct v4l2_ioctl_ops v4l2_loopback_ioctl_ops = {\n\t// clang-format off\n\t.vidioc_querycap\t\t= &vidioc_querycap,\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 29)\n\t.vidioc_enum_framesizes\t\t= &vidioc_enum_framesizes,\n\t.vidioc_enum_frameintervals\t= &vidioc_enum_frameintervals,\n#endif\n\n#ifndef HAVE__V4L2_CTRLS\n\t.vidioc_queryctrl\t\t= &vidioc_queryctrl,\n\t.vidioc_g_ctrl\t\t\t= &vidioc_g_ctrl,\n\t.vidioc_s_ctrl\t\t\t= &vidioc_s_ctrl,\n#endif /* HAVE__V4L2_CTRLS */\n\n\t.vidioc_enum_output\t\t= &vidioc_enum_output,\n\t.vidioc_g_output\t\t= &vidioc_g_output,\n\t.vidioc_s_output\t\t= &vidioc_s_output,\n\n\t.vidioc_enum_input\t\t= &vidioc_enum_input,\n\t.vidioc_g_input\t\t\t= &vidioc_g_input,\n\t.vidioc_s_input\t\t\t= &vidioc_s_input,\n\n\t.vidioc_enum_fmt_vid_cap\t= &vidioc_enum_fmt_cap,\n\t.vidioc_g_fmt_vid_cap\t\t= &vidioc_g_fmt_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= &vidioc_s_fmt_cap,\n\t.vidioc_try_fmt_vid_cap\t\t= &vidioc_try_fmt_cap,\n\n\t.vidioc_enum_fmt_vid_out\t= &vidioc_enum_fmt_out,\n\t.vidioc_s_fmt_vid_out\t\t= &vidioc_s_fmt_out,\n\t.vidioc_g_fmt_vid_out\t\t= &vidioc_g_fmt_out,\n\t.vidioc_try_fmt_vid_out\t\t= &vidioc_try_fmt_out,\n\n#ifdef V4L2L_OVERLAY\n\t.vidioc_s_fmt_vid_overlay\t= &vidioc_s_fmt_overlay,\n\t.vidioc_g_fmt_vid_overlay\t= &vidioc_g_fmt_overlay,\n#endif\n\n#ifdef V4L2LOOPBACK_WITH_STD\n\t.vidioc_s_std\t\t\t= &vidioc_s_std,\n\t.vidioc_g_std\t\t\t= &vidioc_g_std,\n\t.vidioc_querystd\t\t= &vidioc_querystd,\n#endif /* V4L2LOOPBACK_WITH_STD */\n\n\t.vidioc_g_parm\t\t\t= &vidioc_g_parm,\n\t.vidioc_s_parm\t\t\t= &vidioc_s_parm,\n\n\t.vidioc_reqbufs\t\t\t= &vidioc_reqbufs,\n\t.vidioc_querybuf\t\t= &vidioc_querybuf,\n\t.vidioc_qbuf\t\t\t= &vidioc_qbuf,\n\t.vidioc_dqbuf\t\t\t= &vidioc_dqbuf,\n\n\t.vidioc_streamon\t\t= &vidioc_streamon,\n\t.vidioc_streamoff\t\t= &vidioc_streamoff,\n\n#ifdef CONFIG_VIDEO_V4L1_COMPAT\n\t.vidiocgmbuf\t\t\t= &vidiocgmbuf,\n#endif\n\n\t.vidioc_subscribe_event\t\t= &vidioc_subscribe_event,\n\t.vidioc_unsubscribe_event\t= &v4l2_event_unsubscribe,\n\t// clang-format on\n};\n\nstatic int free_device_cb(int id, void *ptr, void *data)\n{\n\tstruct v4l2_loopback_device *dev = ptr;\n\tv4l2_loopback_remove(dev);\n\treturn 0;\n}\nstatic void free_devices(void)\n{\n\tidr_for_each(&v4l2loopback_index_idr, &free_device_cb, NULL);\n\tidr_destroy(&v4l2loopback_index_idr);\n}\n\nstatic int __init v4l2loopback_init_module(void)\n{\n\tint err;\n\tint i;\n\tMARK();\n\n\terr = misc_register(&v4l2loopback_misc);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (devices < 0) {\n\t\tdevices = 1;\n\n\t\t/* try guessing the devices from the \"video_nr\" parameter */\n\t\tfor (i = MAX_DEVICES - 1; i >= 0; i--) {\n\t\t\tif (video_nr[i] >= 0) {\n\t\t\t\tdevices = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (devices > MAX_DEVICES) {\n\t\tdevices = MAX_DEVICES;\n\t\tprintk(KERN_INFO\n\t\t       \"v4l2loopback: number of initial devices is limited to: %d\\n\",\n\t\t       MAX_DEVICES);\n\t}\n\n\tif (max_buffers > MAX_BUFFERS) {\n\t\tmax_buffers = MAX_BUFFERS;\n\t\tprintk(KERN_INFO\n\t\t       \"v4l2loopback: number of buffers is limited to: %d\\n\",\n\t\t       MAX_BUFFERS);\n\t}\n\n\tif (max_openers < 0) {\n\t\tprintk(KERN_INFO\n\t\t       \"v4l2loopback: allowing %d openers rather than %d\\n\",\n\t\t       2, max_openers);\n\t\tmax_openers = 2;\n\t}\n\n\tif (max_width < V4L2LOOPBACK_SIZE_MIN_WIDTH) {\n\t\tmax_width = V4L2LOOPBACK_SIZE_DEFAULT_MAX_WIDTH;\n\t\tprintk(KERN_INFO \"v4l2loopback: using max_width %d\\n\",\n\t\t       max_width);\n\t}\n\tif (max_height < V4L2LOOPBACK_SIZE_MIN_HEIGHT) {\n\t\tmax_height = V4L2LOOPBACK_SIZE_DEFAULT_MAX_HEIGHT;\n\t\tprintk(KERN_INFO \"v4l2loopback: using max_height %d\\n\",\n\t\t       max_height);\n\t}\n\n\t/* kfree on module release */\n\tfor (i = 0; i < devices; i++) {\n\t\tstruct v4l2_loopback_config cfg = {\n\t\t\t// clang-format off\n\t\t\t.output_nr\t\t= video_nr[i],\n\t\t\t.capture_nr\t\t= video_nr[i],\n\t\t\t.max_width\t\t= max_width,\n\t\t\t.max_height\t\t= max_height,\n\t\t\t.announce_all_caps\t= (!exclusive_caps[i]),\n\t\t\t.max_buffers\t\t= max_buffers,\n\t\t\t.max_openers\t\t= max_openers,\n\t\t\t.debug\t\t\t= debug,\n\t\t\t// clang-format on\n\t\t};\n\t\tcfg.card_label[0] = 0;\n\t\tif (card_label[i])\n\t\t\tsnprintf(cfg.card_label, sizeof(cfg.card_label), \"%s\",\n\t\t\t\t card_label[i]);\n\t\terr = v4l2_loopback_add(&cfg, 0);\n\t\tif (err) {\n\t\t\tfree_devices();\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tdprintk(\"module installed\\n\");\n\n\tprintk(KERN_INFO \"v4l2loopback driver version %d.%d.%d%s loaded\\n\",\n\t       // clang-format off\n\t       (V4L2LOOPBACK_VERSION_CODE >> 16) & 0xff,\n\t       (V4L2LOOPBACK_VERSION_CODE >>  8) & 0xff,\n\t       (V4L2LOOPBACK_VERSION_CODE      ) & 0xff,\n#ifdef SNAPSHOT_VERSION\n\t       \" (\" STRINGIFY2(SNAPSHOT_VERSION) \")\"\n#else\n\t       \"\"\n#endif\n\t       );\n\t// clang-format on\n\n\treturn 0;\nerror:\n\tmisc_deregister(&v4l2loopback_misc);\n\treturn err;\n}\n\n#ifdef MODULE\nstatic void v4l2loopback_cleanup_module(void)\n{\n\tMARK();\n\t/* unregister the device -> it deletes /dev/video* */\n\tfree_devices();\n\t/* and get rid of /dev/v4l2loopback */\n\tmisc_deregister(&v4l2loopback_misc);\n\tdprintk(\"module removed\\n\");\n}\n#endif\n\nMODULE_ALIAS_MISCDEV(MISC_DYNAMIC_MINOR);\n\nmodule_init(v4l2loopback_init_module);\nmodule_exit(v4l2loopback_cleanup_module);\n\n/*\n * fake usage of unused functions\n */\n#ifdef HAVE__V4L2_CTRLS\nstatic int vidioc_queryctrl(struct file *file, void *fh,\n\t\t\t    struct v4l2_queryctrl *q) __attribute__((unused));\nstatic int vidioc_g_ctrl(struct file *file, void *fh, struct v4l2_control *c)\n\t__attribute__((unused));\nstatic int vidioc_s_ctrl(struct file *file, void *fh, struct v4l2_control *c)\n\t__attribute__((unused));\n#endif /* HAVE__V4L2_CTRLS */\n"], "fixing_code": ["/* -*- c-file-style: \"linux\" -*- */\n/*\n * v4l2loopback.c  --  video4linux2 loopback driver\n *\n * Copyright (C) 2005-2009 Vasily Levin (vasaka@gmail.com)\n * Copyright (C) 2010-2019 IOhannes m zmoelnig (zmoelnig@iem.at)\n * Copyright (C) 2011 Stefan Diewald (stefan.diewald@mytum.de)\n * Copyright (C) 2012 Anton Novikov (random.plant@gmail.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n */\n#include <linux/version.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/module.h>\n#include <linux/videodev2.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/eventpoll.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-common.h>\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 29)\n#define HAVE__V4L2_DEVICE\n#include <media/v4l2-device.h>\n#endif\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)\n#define HAVE__V4L2_CTRLS\n#include <media/v4l2-ctrls.h>\n#endif\n#include <media/v4l2-event.h>\n\n#include <linux/miscdevice.h>\n#include \"v4l2loopback.h\"\n\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 1)\n#define kstrtoul strict_strtoul\n#endif\n\n#if defined(timer_setup) && defined(from_timer)\n#define HAVE_TIMER_SETUP\n#endif\n\n#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 7, 0)\n#define VFL_TYPE_VIDEO VFL_TYPE_GRABBER\n#endif\n\n#define V4L2LOOPBACK_VERSION_CODE                                              \\\n\tKERNEL_VERSION(V4L2LOOPBACK_VERSION_MAJOR, V4L2LOOPBACK_VERSION_MINOR, \\\n\t\t       V4L2LOOPBACK_VERSION_BUGFIX)\n\nMODULE_DESCRIPTION(\"V4L2 loopback video device\");\nMODULE_AUTHOR(\"Vasily Levin, \"\n\t      \"IOhannes m zmoelnig <zmoelnig@iem.at>,\"\n\t      \"Stefan Diewald,\"\n\t      \"Anton Novikov\"\n\t      \"et al.\");\nMODULE_VERSION(\"0.12.5\");\nMODULE_LICENSE(\"GPL\");\n\n/*\n * helpers\n */\n#define STRINGIFY(s) #s\n#define STRINGIFY2(s) STRINGIFY(s)\n\n#define dprintk(fmt, args...)                                                  \\\n\tdo {                                                                   \\\n\t\tif (debug > 0) {                                               \\\n\t\t\tprintk(KERN_INFO \"v4l2-loopback[\" STRINGIFY2(          \\\n\t\t\t\t       __LINE__) \"]: \" fmt,                    \\\n\t\t\t       ##args);                                        \\\n\t\t}                                                              \\\n\t} while (0)\n\n#define MARK()                                                                 \\\n\tdo {                                                                   \\\n\t\tif (debug > 1) {                                               \\\n\t\t\tprintk(KERN_INFO \"%s:%d[%s]\\n\", __FILE__, __LINE__,    \\\n\t\t\t       __func__);                                      \\\n\t\t}                                                              \\\n\t} while (0)\n\n#define dprintkrw(fmt, args...)                                                \\\n\tdo {                                                                   \\\n\t\tif (debug > 2) {                                               \\\n\t\t\tprintk(KERN_INFO \"v4l2-loopback[\" STRINGIFY2(          \\\n\t\t\t\t       __LINE__) \"]: \" fmt,                    \\\n\t\t\t       ##args);                                        \\\n\t\t}                                                              \\\n\t} while (0)\n\n/*\n * compatibility hacks\n */\n\n#ifndef HAVE__V4L2_CTRLS\nstruct v4l2_ctrl_handler {\n\tint error;\n};\nstruct v4l2_ctrl_config {\n\tvoid *ops;\n\tu32 id;\n\tconst char *name;\n\tint type;\n\ts32 min;\n\ts32 max;\n\tu32 step;\n\ts32 def;\n};\nint v4l2_ctrl_handler_init(struct v4l2_ctrl_handler *hdl,\n\t\t\t   unsigned nr_of_controls_hint)\n{\n\thdl->error = 0;\n\treturn 0;\n}\nvoid v4l2_ctrl_handler_free(struct v4l2_ctrl_handler *hdl)\n{\n}\nvoid *v4l2_ctrl_new_custom(struct v4l2_ctrl_handler *hdl,\n\t\t\t   const struct v4l2_ctrl_config *conf, void *priv)\n{\n\treturn NULL;\n}\n#endif /* HAVE__V4L2_CTRLS */\n\n#ifndef HAVE__V4L2_DEVICE\n/* dummy v4l2_device struct/functions */\n#define V4L2_DEVICE_NAME_SIZE (20 + 16)\nstruct v4l2_device {\n\tchar name[V4L2_DEVICE_NAME_SIZE];\n\tstruct v4l2_ctrl_handler *ctrl_handler;\n};\nstatic inline int v4l2_device_register(void *dev, void *v4l2_dev)\n{\n\treturn 0;\n}\nstatic inline void v4l2_device_unregister(struct v4l2_device *v4l2_dev)\n{\n\treturn;\n}\n#endif /*  HAVE__V4L2_DEVICE */\n\n#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)\n#define v4l2_file_operations file_operations\n#endif\n#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37)\nvoid *v4l2l_vzalloc(unsigned long size)\n{\n\tvoid *data = vmalloc(size);\n\n\tmemset(data, 0, size);\n\treturn data;\n}\n#else\n#define v4l2l_vzalloc vzalloc\n#endif\n\nstatic inline void v4l2l_get_timestamp(struct v4l2_buffer *b)\n{\n\t/* ktime_get_ts is considered deprecated, so use ktime_get_ts64 if possible */\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0)\n\tstruct timespec ts;\n\tktime_get_ts(&ts);\n#else\n\tstruct timespec64 ts;\n\tktime_get_ts64(&ts);\n#endif\n\n\tb->timestamp.tv_sec = ts.tv_sec;\n\tb->timestamp.tv_usec = (ts.tv_nsec / NSEC_PER_USEC);\n}\n\n#if !defined(__poll_t)\ntypedef unsigned __poll_t;\n#endif\n\n/* module constants\n *  can be overridden during he build process using something like\n *\tmake KCPPFLAGS=\"-DMAX_DEVICES=100\"\n */\n\n/* maximum number of v4l2loopback devices that can be created */\n#ifndef MAX_DEVICES\n#define MAX_DEVICES 8\n#endif\n\n/* whether the default is to announce capabilities exclusively or not */\n#ifndef V4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS\n#define V4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS 0\n#endif\n\n/* when a producer is considered to have gone stale */\n#ifndef MAX_TIMEOUT\n#define MAX_TIMEOUT (100 * 1000) /* in msecs */\n#endif\n\n/* max buffers that can be mapped, actually they\n * are all mapped to max_buffers buffers */\n#ifndef MAX_BUFFERS\n#define MAX_BUFFERS 32\n#endif\n\n/* module parameters */\nstatic int debug = 0;\nmodule_param(debug, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"debugging level (higher values == more verbose)\");\n\n#define V4L2LOOPBACK_DEFAULT_MAX_BUFFERS 2\nstatic int max_buffers = V4L2LOOPBACK_DEFAULT_MAX_BUFFERS;\nmodule_param(max_buffers, int, S_IRUGO);\nMODULE_PARM_DESC(max_buffers,\n\t\t \"how many buffers should be allocated [DEFAULT: \" STRINGIFY2(\n\t\t\t V4L2LOOPBACK_DEFAULT_MAX_BUFFERS) \"]\");\n\n/* how many times a device can be opened\n * the per-module default value can be overridden on a per-device basis using\n * the /sys/devices interface\n *\n * note that max_openers should be at least 2 in order to get a working system:\n *   one opener for the producer and one opener for the consumer\n *   however, we leave that to the user\n */\n#define V4L2LOOPBACK_DEFAULT_MAX_OPENERS 10\nstatic int max_openers = V4L2LOOPBACK_DEFAULT_MAX_OPENERS;\nmodule_param(max_openers, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(\n\tmax_openers,\n\t\"how many users can open the loopback device [DEFAULT: \" STRINGIFY2(\n\t\tV4L2LOOPBACK_DEFAULT_MAX_OPENERS) \"]\");\n\nstatic int devices = -1;\nmodule_param(devices, int, 0);\nMODULE_PARM_DESC(devices, \"how many devices should be created\");\n\nstatic int video_nr[MAX_DEVICES] = { [0 ...(MAX_DEVICES - 1)] = -1 };\nmodule_param_array(video_nr, int, NULL, 0444);\nMODULE_PARM_DESC(video_nr,\n\t\t \"video device numbers (-1=auto, 0=/dev/video0, etc.)\");\n\nstatic char *card_label[MAX_DEVICES];\nmodule_param_array(card_label, charp, NULL, 0000);\nMODULE_PARM_DESC(card_label, \"card labels for each device\");\n\nstatic bool exclusive_caps[MAX_DEVICES] = {\n\t[0 ...(MAX_DEVICES - 1)] = V4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS\n};\nmodule_param_array(exclusive_caps, bool, NULL, 0444);\n/* FIXXME: wording */\nMODULE_PARM_DESC(\n\texclusive_caps,\n\t\"whether to announce OUTPUT/CAPTURE capabilities exclusively or not  [DEFAULT: \" STRINGIFY2(\n\t\tV4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS) \"]\");\n\n/* format specifications */\n#define V4L2LOOPBACK_SIZE_MIN_WIDTH 48\n#define V4L2LOOPBACK_SIZE_MIN_HEIGHT 32\n#define V4L2LOOPBACK_SIZE_DEFAULT_MAX_WIDTH 8192\n#define V4L2LOOPBACK_SIZE_DEFAULT_MAX_HEIGHT 8192\n\n#define V4L2LOOPBACK_SIZE_DEFAULT_WIDTH 640\n#define V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT 480\n\nstatic int max_width = V4L2LOOPBACK_SIZE_DEFAULT_MAX_WIDTH;\nmodule_param(max_width, int, S_IRUGO);\nMODULE_PARM_DESC(max_width, \"maximum allowed frame width [DEFAULT: \" STRINGIFY2(\n\t\t\t\t    V4L2LOOPBACK_SIZE_DEFAULT_MAX_WIDTH) \"]\");\nstatic int max_height = V4L2LOOPBACK_SIZE_DEFAULT_MAX_HEIGHT;\nmodule_param(max_height, int, S_IRUGO);\nMODULE_PARM_DESC(max_height,\n\t\t \"maximum allowed frame height [DEFAULT: \" STRINGIFY2(\n\t\t\t V4L2LOOPBACK_SIZE_DEFAULT_MAX_HEIGHT) \"]\");\n\nstatic DEFINE_IDR(v4l2loopback_index_idr);\nstatic DEFINE_MUTEX(v4l2loopback_ctl_mutex);\n\n/* control IDs */\n#ifndef HAVE__V4L2_CTRLS\n#define V4L2LOOPBACK_CID_BASE (V4L2_CID_PRIVATE_BASE)\n#else\n#define V4L2LOOPBACK_CID_BASE (V4L2_CID_USER_BASE | 0xf000)\n#endif\n#define CID_KEEP_FORMAT (V4L2LOOPBACK_CID_BASE + 0)\n#define CID_SUSTAIN_FRAMERATE (V4L2LOOPBACK_CID_BASE + 1)\n#define CID_TIMEOUT (V4L2LOOPBACK_CID_BASE + 2)\n#define CID_TIMEOUT_IMAGE_IO (V4L2LOOPBACK_CID_BASE + 3)\n\nstatic int v4l2loopback_s_ctrl(struct v4l2_ctrl *ctrl);\nstatic const struct v4l2_ctrl_ops v4l2loopback_ctrl_ops = {\n\t.s_ctrl = v4l2loopback_s_ctrl,\n};\nstatic const struct v4l2_ctrl_config v4l2loopback_ctrl_keepformat = {\n\t// clang-format off\n\t.ops\t= &v4l2loopback_ctrl_ops,\n\t.id\t= CID_KEEP_FORMAT,\n\t.name\t= \"keep_format\",\n\t.type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t.min\t= 0,\n\t.max\t= 1,\n\t.step\t= 1,\n\t.def\t= 0,\n\t// clang-format on\n};\nstatic const struct v4l2_ctrl_config v4l2loopback_ctrl_sustainframerate = {\n\t// clang-format off\n\t.ops\t= &v4l2loopback_ctrl_ops,\n\t.id\t= CID_SUSTAIN_FRAMERATE,\n\t.name\t= \"sustain_framerate\",\n\t.type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t.min\t= 0,\n\t.max\t= 1,\n\t.step\t= 1,\n\t.def\t= 0,\n\t// clang-format on\n};\nstatic const struct v4l2_ctrl_config v4l2loopback_ctrl_timeout = {\n\t// clang-format off\n\t.ops\t= &v4l2loopback_ctrl_ops,\n\t.id\t= CID_TIMEOUT,\n\t.name\t= \"timeout\",\n\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t.min\t= 0,\n\t.max\t= MAX_TIMEOUT,\n\t.step\t= 1,\n\t.def\t= 0,\n\t// clang-format on\n};\nstatic const struct v4l2_ctrl_config v4l2loopback_ctrl_timeoutimageio = {\n\t// clang-format off\n\t.ops\t= &v4l2loopback_ctrl_ops,\n\t.id\t= CID_TIMEOUT_IMAGE_IO,\n\t.name\t= \"timeout_image_io\",\n\t.type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t.min\t= 0,\n\t.max\t= 1,\n\t.step\t= 1,\n\t.def\t= 0,\n\t// clang-format on\n};\n\n/* module structures */\nstruct v4l2loopback_private {\n\tint device_nr;\n};\n\n/* TODO(vasaka) use typenames which are common to kernel, but first find out if\n * it is needed */\n/* struct keeping state and settings of loopback device */\n\nstruct v4l2l_buffer {\n\tstruct v4l2_buffer buffer;\n\tstruct list_head list_head;\n\tint use_count;\n};\n\nstruct v4l2_loopback_device {\n\tstruct v4l2_device v4l2_dev;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tstruct video_device *vdev;\n\t/* pixel and stream format */\n\tstruct v4l2_pix_format pix_format;\n\tstruct v4l2_captureparm capture_param;\n\tunsigned long frame_jiffies;\n\n\t/* ctrls */\n\tint keep_format; /* CID_KEEP_FORMAT; stay ready_for_capture even when all\n\t\t\t    openers close() the device */\n\tint sustain_framerate; /* CID_SUSTAIN_FRAMERATE; duplicate frames to maintain\n\t\t\t\t  (close to) nominal framerate */\n\n\t/* buffers stuff */\n\tu8 *image; /* pointer to actual buffers data */\n\tunsigned long int imagesize; /* size of buffers data */\n\tint buffers_number; /* should not be big, 4 is a good choice */\n\tstruct v4l2l_buffer buffers[MAX_BUFFERS]; /* inner driver buffers */\n\tint used_buffers; /* number of the actually used buffers */\n\tint max_openers; /* how many times can this device be opened */\n\n\tint write_position; /* number of last written frame + 1 */\n\tstruct list_head outbufs_list; /* buffers in output DQBUF order */\n\tint bufpos2index\n\t\t[MAX_BUFFERS]; /* mapping of (read/write_position % used_buffers)\n                        * to inner buffer index */\n\tlong buffer_size;\n\n\t/* sustain_framerate stuff */\n\tstruct timer_list sustain_timer;\n\tunsigned int reread_count;\n\n\t/* timeout stuff */\n\tunsigned long timeout_jiffies; /* CID_TIMEOUT; 0 means disabled */\n\tint timeout_image_io; /* CID_TIMEOUT_IMAGE_IO; next opener will\n\t\t\t       * read/write to timeout_image */\n\tu8 *timeout_image; /* copy of it will be captured when timeout passes */\n\tstruct v4l2l_buffer timeout_image_buffer;\n\tstruct timer_list timeout_timer;\n\tint timeout_happened;\n\n\t/* sync stuff */\n\tatomic_t open_count;\n\n\tint ready_for_capture; /* set to the number of writers that opened the\n                                * device and negotiated format. */\n\tint ready_for_output; /* set to true when no writer is currently attached\n\t\t\t       * this differs slightly from !ready_for_capture,\n\t\t\t       * e.g. when using fallback images */\n\tint announce_all_caps; /* set to false, if device caps (OUTPUT/CAPTURE)\n                                * should only be announced if the resp. \"ready\"\n                                * flag is set; default=TRUE */\n\n\tint max_width;\n\tint max_height;\n\n\tchar card_label[32];\n\n\twait_queue_head_t read_event;\n\tspinlock_t lock;\n};\n\n/* types of opener shows what opener wants to do with loopback */\nenum opener_type {\n\t// clang-format off\n\tUNNEGOTIATED\t= 0,\n\tREADER\t\t= 1,\n\tWRITER\t\t= 2,\n\t// clang-format on\n};\n\n/* struct keeping state and type of opener */\nstruct v4l2_loopback_opener {\n\tenum opener_type type;\n\tint vidioc_enum_frameintervals_calls;\n\tint read_position; /* number of last processed frame + 1 or\n\t\t\t    * write_position - 1 if reader went out of sync */\n\tunsigned int reread_count;\n\tstruct v4l2_buffer *buffers;\n\tint buffers_number; /* should not be big, 4 is a good choice */\n\tint timeout_image_io;\n\n\tstruct v4l2_fh fh;\n};\n\n#define fh_to_opener(ptr) container_of((ptr), struct v4l2_loopback_opener, fh)\n\n/* this is heavily inspired by the bttv driver found in the linux kernel */\nstruct v4l2l_format {\n\tchar *name;\n\tint fourcc; /* video4linux 2 */\n\tint depth; /* bit/pixel */\n\tint flags;\n};\n/* set the v4l2l_format.flags to PLANAR for non-packed formats */\n#define FORMAT_FLAGS_PLANAR 0x01\n#define FORMAT_FLAGS_COMPRESSED 0x02\n\n#include \"v4l2loopback_formats.h\"\n\nstatic const unsigned int FORMATS = ARRAY_SIZE(formats);\n\nstatic char *fourcc2str(unsigned int fourcc, char buf[4])\n{\n\tbuf[0] = (fourcc >> 0) & 0xFF;\n\tbuf[1] = (fourcc >> 8) & 0xFF;\n\tbuf[2] = (fourcc >> 16) & 0xFF;\n\tbuf[3] = (fourcc >> 24) & 0xFF;\n\n\treturn buf;\n}\n\nstatic const struct v4l2l_format *format_by_fourcc(int fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < FORMATS; i++) {\n\t\tif (formats[i].fourcc == fourcc)\n\t\t\treturn formats + i;\n\t}\n\n\tdprintk(\"unsupported format '%c%c%c%c'\\n\", (fourcc >> 0) & 0xFF,\n\t\t(fourcc >> 8) & 0xFF, (fourcc >> 16) & 0xFF,\n\t\t(fourcc >> 24) & 0xFF);\n\treturn NULL;\n}\n\nstatic void pix_format_set_size(struct v4l2_pix_format *f,\n\t\t\t\tconst struct v4l2l_format *fmt,\n\t\t\t\tunsigned int width, unsigned int height)\n{\n\tf->width = width;\n\tf->height = height;\n\n\tif (fmt->flags & FORMAT_FLAGS_PLANAR) {\n\t\tf->bytesperline = width; /* Y plane */\n\t\tf->sizeimage = (width * height * fmt->depth) >> 3;\n\t} else if (fmt->flags & FORMAT_FLAGS_COMPRESSED) {\n\t\t/* doesn't make sense for compressed formats */\n\t\tf->bytesperline = 0;\n\t\tf->sizeimage = (width * height * fmt->depth) >> 3;\n\t} else {\n\t\tf->bytesperline = (width * fmt->depth) >> 3;\n\t\tf->sizeimage = height * f->bytesperline;\n\t}\n}\n\nstatic int set_timeperframe(struct v4l2_loopback_device *dev,\n\t\t\t    struct v4l2_fract *tpf)\n{\n\tif ((tpf->denominator < 1) || (tpf->numerator < 1)) {\n\t\treturn -EINVAL;\n\t}\n\tdev->capture_param.timeperframe = *tpf;\n\tdev->frame_jiffies = max(1UL, msecs_to_jiffies(1000) * tpf->numerator /\n\t\t\t\t\t      tpf->denominator);\n\treturn 0;\n}\n\nstatic struct v4l2_loopback_device *v4l2loopback_cd2dev(struct device *cd);\n\n/* device attributes */\n/* available via sysfs: /sys/devices/virtual/video4linux/video* */\n\nstatic ssize_t attr_show_format(struct device *cd,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\t/* gets the current format as \"FOURCC:WxH@f/s\", e.g. \"YUYV:320x240@1000/30\" */\n\tstruct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);\n\tconst struct v4l2_fract *tpf;\n\tchar buf4cc[5], buf_fps[32];\n\n\tif (!dev || !dev->ready_for_capture)\n\t\treturn 0;\n\ttpf = &dev->capture_param.timeperframe;\n\n\tfourcc2str(dev->pix_format.pixelformat, buf4cc);\n\tbuf4cc[4] = 0;\n\tif (tpf->numerator == 1)\n\t\tsnprintf(buf_fps, sizeof(buf_fps), \"%d\", tpf->denominator);\n\telse\n\t\tsnprintf(buf_fps, sizeof(buf_fps), \"%d/%d\", tpf->denominator,\n\t\t\t tpf->numerator);\n\treturn sprintf(buf, \"%4s:%dx%d@%s\\n\", buf4cc, dev->pix_format.width,\n\t\t       dev->pix_format.height, buf_fps);\n}\n\nstatic ssize_t attr_store_format(struct device *cd,\n\t\t\t\t struct device_attribute *attr, const char *buf,\n\t\t\t\t size_t len)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);\n\tint fps_num = 0, fps_den = 1;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\t/* only fps changing is supported */\n\tif (sscanf(buf, \"@%d/%d\", &fps_num, &fps_den) > 0) {\n\t\tstruct v4l2_fract f = { .numerator = fps_den,\n\t\t\t\t\t.denominator = fps_num };\n\t\tint err = 0;\n\t\tif ((err = set_timeperframe(dev, &f)) < 0)\n\t\t\treturn err;\n\t\treturn len;\n\t}\n\treturn -EINVAL;\n}\n\nstatic DEVICE_ATTR(format, S_IRUGO | S_IWUSR, attr_show_format,\n\t\t   attr_store_format);\n\nstatic ssize_t attr_show_buffers(struct device *cd,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"%d\\n\", dev->used_buffers);\n}\n\nstatic DEVICE_ATTR(buffers, S_IRUGO, attr_show_buffers, NULL);\n\nstatic ssize_t attr_show_maxopeners(struct device *cd,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);\n\n\treturn sprintf(buf, \"%d\\n\", dev->max_openers);\n}\n\nstatic ssize_t attr_store_maxopeners(struct device *cd,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t len)\n{\n\tstruct v4l2_loopback_device *dev = NULL;\n\tunsigned long curr = 0;\n\n\tif (kstrtoul(buf, 0, &curr))\n\t\treturn -EINVAL;\n\n\tdev = v4l2loopback_cd2dev(cd);\n\n\tif (dev->max_openers == curr)\n\t\treturn len;\n\n\tif (curr > __INT_MAX__ || dev->open_count.counter > curr) {\n\t\t/* request to limit to less openers as are currently attached to us */\n\t\treturn -EINVAL;\n\t}\n\n\tdev->max_openers = (int)curr;\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR(max_openers, S_IRUGO | S_IWUSR, attr_show_maxopeners,\n\t\t   attr_store_maxopeners);\n\nstatic void v4l2loopback_remove_sysfs(struct video_device *vdev)\n{\n#define V4L2_SYSFS_DESTROY(x) device_remove_file(&vdev->dev, &dev_attr_##x)\n\n\tif (vdev) {\n\t\tV4L2_SYSFS_DESTROY(format);\n\t\tV4L2_SYSFS_DESTROY(buffers);\n\t\tV4L2_SYSFS_DESTROY(max_openers);\n\t\t/* ... */\n\t}\n}\n\nstatic void v4l2loopback_create_sysfs(struct video_device *vdev)\n{\n\tint res = 0;\n\n#define V4L2_SYSFS_CREATE(x)                                                   \\\n\tres = device_create_file(&vdev->dev, &dev_attr_##x);                   \\\n\tif (res < 0)                                                           \\\n\tbreak\n\tif (!vdev)\n\t\treturn;\n\tdo {\n\t\tV4L2_SYSFS_CREATE(format);\n\t\tV4L2_SYSFS_CREATE(buffers);\n\t\tV4L2_SYSFS_CREATE(max_openers);\n\t\t/* ... */\n\t} while (0);\n\n\tif (res >= 0)\n\t\treturn;\n\tdev_err(&vdev->dev, \"%s error: %d\\n\", __func__, res);\n}\n\n/* global module data */\n/* find a device based on it's device-number (e.g. '3' for /dev/video3) */\nstruct v4l2loopback_lookup_cb_data {\n\tint device_nr;\n\tstruct v4l2_loopback_device *device;\n};\nstatic int v4l2loopback_lookup_cb(int id, void *ptr, void *data)\n{\n\tstruct v4l2_loopback_device *device = ptr;\n\tstruct v4l2loopback_lookup_cb_data *cbdata = data;\n\tif (cbdata && device && device->vdev) {\n\t\tif (device->vdev->num == cbdata->device_nr) {\n\t\t\tcbdata->device = device;\n\t\t\tcbdata->device_nr = id;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nstatic int v4l2loopback_lookup(int device_nr,\n\t\t\t       struct v4l2_loopback_device **device)\n{\n\tstruct v4l2loopback_lookup_cb_data data = {\n\t\t.device_nr = device_nr,\n\t\t.device = NULL,\n\t};\n\tint err = idr_for_each(&v4l2loopback_index_idr, &v4l2loopback_lookup_cb,\n\t\t\t       &data);\n\tif (1 == err) {\n\t\tif (device)\n\t\t\t*device = data.device;\n\t\treturn data.device_nr;\n\t}\n\treturn -ENODEV;\n}\nstatic struct v4l2_loopback_device *v4l2loopback_cd2dev(struct device *cd)\n{\n\tstruct video_device *loopdev = to_video_device(cd);\n\tstruct v4l2loopback_private *ptr =\n\t\t(struct v4l2loopback_private *)video_get_drvdata(loopdev);\n\tint nr = ptr->device_nr;\n\n\treturn idr_find(&v4l2loopback_index_idr, nr);\n}\n\nstatic struct v4l2_loopback_device *v4l2loopback_getdevice(struct file *f)\n{\n\tstruct v4l2loopback_private *ptr = video_drvdata(f);\n\tint nr = ptr->device_nr;\n\n\treturn idr_find(&v4l2loopback_index_idr, nr);\n}\n\n/* forward declarations */\nstatic void init_buffers(struct v4l2_loopback_device *dev);\nstatic int allocate_buffers(struct v4l2_loopback_device *dev);\nstatic void free_buffers(struct v4l2_loopback_device *dev);\nstatic void try_free_buffers(struct v4l2_loopback_device *dev);\nstatic int allocate_timeout_image(struct v4l2_loopback_device *dev);\nstatic void check_timers(struct v4l2_loopback_device *dev);\nstatic const struct v4l2_file_operations v4l2_loopback_fops;\nstatic const struct v4l2_ioctl_ops v4l2_loopback_ioctl_ops;\n\n/* Queue helpers */\n/* next functions sets buffer flags and adjusts counters accordingly */\nstatic inline void set_done(struct v4l2l_buffer *buffer)\n{\n\tbuffer->buffer.flags &= ~V4L2_BUF_FLAG_QUEUED;\n\tbuffer->buffer.flags |= V4L2_BUF_FLAG_DONE;\n}\n\nstatic inline void set_queued(struct v4l2l_buffer *buffer)\n{\n\tbuffer->buffer.flags &= ~V4L2_BUF_FLAG_DONE;\n\tbuffer->buffer.flags |= V4L2_BUF_FLAG_QUEUED;\n}\n\nstatic inline void unset_flags(struct v4l2l_buffer *buffer)\n{\n\tbuffer->buffer.flags &= ~V4L2_BUF_FLAG_QUEUED;\n\tbuffer->buffer.flags &= ~V4L2_BUF_FLAG_DONE;\n}\n\n/* V4L2 ioctl caps and params calls */\n/* returns device capabilities\n * called on VIDIOC_QUERYCAP\n */\nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tint labellen = (sizeof(cap->card) < sizeof(dev->card_label)) ?\n\t\t\t       sizeof(cap->card) :\n\t\t\t\t     sizeof(dev->card_label);\n\tint device_nr =\n\t\t((struct v4l2loopback_private *)video_get_drvdata(dev->vdev))\n\t\t\t->device_nr;\n\t__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\n\tstrlcpy(cap->driver, \"v4l2 loopback\", sizeof(cap->driver));\n\tsnprintf(cap->card, labellen, \"%s\", dev->card_label);\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:v4l2loopback-%03d\", device_nr);\n\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0)\n\t/* since 3.1.0, the v4l2-core system is supposed to set the version */\n\tcap->version = V4L2LOOPBACK_VERSION_CODE;\n#endif\n\n#ifdef V4L2_CAP_VIDEO_M2M\n\tcapabilities |= V4L2_CAP_VIDEO_M2M;\n#endif /* V4L2_CAP_VIDEO_M2M */\n\n\tif (dev->announce_all_caps) {\n\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\n\t} else {\n\t\tif (dev->ready_for_capture) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE;\n\t\t}\n\t\tif (dev->ready_for_output) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_OUTPUT;\n\t\t}\n\t}\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n\tdev->vdev->device_caps =\n#endif /* >=linux-4.7.0 */\n\t\tcap->device_caps = cap->capabilities = capabilities;\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)\n\tcap->capabilities |= V4L2_CAP_DEVICE_CAPS;\n#endif\n\n\tmemset(cap->reserved, 0, sizeof(cap->reserved));\n\treturn 0;\n}\n\nstatic int vidioc_enum_framesizes(struct file *file, void *fh,\n\t\t\t\t  struct v4l2_frmsizeenum *argp)\n{\n\tstruct v4l2_loopback_device *dev;\n\n\t/* LATER: what does the index really  mean?\n\t * if it's about enumerating formats, we can safely ignore it\n\t * (CHECK)\n\t */\n\n\t/* there can be only one... */\n\tif (argp->index)\n\t\treturn -EINVAL;\n\n\tdev = v4l2loopback_getdevice(file);\n\tif (dev->ready_for_capture) {\n\t\t/* format has already been negotiated\n\t\t * cannot change during runtime\n\t\t */\n\t\targp->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\n\t\targp->discrete.width = dev->pix_format.width;\n\t\targp->discrete.height = dev->pix_format.height;\n\t} else {\n\t\t/* if the format has not been negotiated yet, we accept anything\n\t\t */\n\t\targp->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;\n\n\t\targp->stepwise.min_width = V4L2LOOPBACK_SIZE_MIN_WIDTH;\n\t\targp->stepwise.min_height = V4L2LOOPBACK_SIZE_MIN_HEIGHT;\n\n\t\targp->stepwise.max_width = dev->max_width;\n\t\targp->stepwise.max_height = dev->max_height;\n\n\t\targp->stepwise.step_width = 1;\n\t\targp->stepwise.step_height = 1;\n\t}\n\treturn 0;\n}\n\n/* returns frameinterval (fps) for the set resolution\n * called on VIDIOC_ENUM_FRAMEINTERVALS\n */\nstatic int vidioc_enum_frameintervals(struct file *file, void *fh,\n\t\t\t\t      struct v4l2_frmivalenum *argp)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tstruct v4l2_loopback_opener *opener = fh_to_opener(fh);\n\n\tif (dev->ready_for_capture) {\n\t\tif (opener->vidioc_enum_frameintervals_calls > 0)\n\t\t\treturn -EINVAL;\n\t\tif (argp->width == dev->pix_format.width &&\n\t\t    argp->height == dev->pix_format.height) {\n\t\t\targp->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\t\t\targp->discrete = dev->capture_param.timeperframe;\n\t\t\topener->vidioc_enum_frameintervals_calls++;\n\t\t\treturn 0;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n/* ------------------ CAPTURE ----------------------- */\n\n/* returns device formats\n * called on VIDIOC_ENUM_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_CAPTURE\n */\nstatic int vidioc_enum_fmt_cap(struct file *file, void *fh,\n\t\t\t       struct v4l2_fmtdesc *f)\n{\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\n\tif (f->index)\n\t\treturn -EINVAL;\n\tif (dev->ready_for_capture) {\n\t\tconst __u32 format = dev->pix_format.pixelformat;\n\n\t\tsnprintf(f->description, sizeof(f->description), \"[%c%c%c%c]\",\n\t\t\t (format >> 0) & 0xFF, (format >> 8) & 0xFF,\n\t\t\t (format >> 16) & 0xFF, (format >> 24) & 0xFF);\n\n\t\tf->pixelformat = dev->pix_format.pixelformat;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tf->flags = 0;\n\tMARK();\n\treturn 0;\n}\n\n/* returns current video format\n * called on VIDIOC_G_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_CAPTURE\n */\nstatic int vidioc_g_fmt_cap(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *fmt)\n{\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\n\tif (!dev->ready_for_capture)\n\t\treturn -EINVAL;\n\n\tfmt->fmt.pix = dev->pix_format;\n\tMARK();\n\treturn 0;\n}\n\n/* checks if it is OK to change to format fmt;\n * actual check is done by inner_try_fmt_cap\n * just checking that pixelformat is OK and set other parameters, app should\n * obey this decision\n * called on VIDIOC_TRY_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_CAPTURE\n */\nstatic int vidioc_try_fmt_cap(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *fmt)\n{\n\tstruct v4l2_loopback_device *dev;\n\tchar buf[5];\n\n\tdev = v4l2loopback_getdevice(file);\n\n\tif (0 == dev->ready_for_capture) {\n\t\tdprintk(\"setting fmt_cap not possible yet\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (fmt->fmt.pix.pixelformat != dev->pix_format.pixelformat)\n\t\treturn -EINVAL;\n\n\tfmt->fmt.pix = dev->pix_format;\n\n\tbuf[4] = 0;\n\tdprintk(\"capFOURCC=%s\\n\", fourcc2str(dev->pix_format.pixelformat, buf));\n\treturn 0;\n}\n\n/* sets new output format, if possible\n * actually format is set  by input and we even do not check it, just return\n * current one, but it is possible to set subregions of input TODO(vasaka)\n * called on VIDIOC_S_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_CAPTURE\n */\nstatic int vidioc_s_fmt_cap(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *fmt)\n{\n\treturn vidioc_try_fmt_cap(file, priv, fmt);\n}\n\n/* ------------------ OUTPUT ----------------------- */\n\n/* returns device formats;\n * LATER: allow all formats\n * called on VIDIOC_ENUM_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_OUTPUT\n */\nstatic int vidioc_enum_fmt_out(struct file *file, void *fh,\n\t\t\t       struct v4l2_fmtdesc *f)\n{\n\tstruct v4l2_loopback_device *dev;\n\tconst struct v4l2l_format *fmt;\n\n\tdev = v4l2loopback_getdevice(file);\n\n\tif (dev->ready_for_capture) {\n\t\tconst __u32 format = dev->pix_format.pixelformat;\n\n\t\t/* format has been fixed by the writer, so only one single format is supported */\n\t\tif (f->index)\n\t\t\treturn -EINVAL;\n\n\t\tfmt = format_by_fourcc(format);\n\t\tif (NULL == fmt)\n\t\t\treturn -EINVAL;\n\n\t\tf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\t/* f->flags = ??; */\n\t\tsnprintf(f->description, sizeof(f->description), \"%s\",\n\t\t\t fmt->name);\n\n\t\tf->pixelformat = dev->pix_format.pixelformat;\n\t} else {\n\t\t/* fill in a dummy format */\n\t\t/* coverity[unsigned_compare] */\n\t\tif (f->index < 0 || f->index >= FORMATS)\n\t\t\treturn -EINVAL;\n\n\t\tfmt = &formats[f->index];\n\n\t\tf->pixelformat = fmt->fourcc;\n\t\tsnprintf(f->description, sizeof(f->description), \"%s\",\n\t\t\t fmt->name);\n\t}\n\tf->flags = 0;\n\n\treturn 0;\n}\n\n/* returns current video format format fmt */\n/* NOTE: this is called from the producer\n * so if format has not been negotiated yet,\n * it should return ALL of available formats,\n * called on VIDIOC_G_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_OUTPUT\n */\nstatic int vidioc_g_fmt_out(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *fmt)\n{\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\n\t/*\n\t * LATER: this should return the currently valid format\n\t * gstreamer doesn't like it, if this returns -EINVAL, as it\n\t * then concludes that there is _no_ valid format\n\t * CHECK whether this assumption is wrong,\n\t * or whether we have to always provide a valid format\n\t */\n\n\tfmt->fmt.pix = dev->pix_format;\n\treturn 0;\n}\n\n/* checks if it is OK to change to format fmt;\n * if format is negotiated do not change it\n * called on VIDIOC_TRY_FMT with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_OUTPUT\n */\nstatic int vidioc_try_fmt_out(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *fmt)\n{\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\n\t/* TODO(vasaka) loopback does not care about formats writer want to set,\n\t * maybe it is a good idea to restrict format somehow */\n\tif (dev->ready_for_capture) {\n\t\tfmt->fmt.pix = dev->pix_format;\n\t} else {\n\t\t__u32 w = fmt->fmt.pix.width;\n\t\t__u32 h = fmt->fmt.pix.height;\n\t\t__u32 pixfmt = fmt->fmt.pix.pixelformat;\n\t\tconst struct v4l2l_format *format = format_by_fourcc(pixfmt);\n\n\t\tif (w > dev->max_width)\n\t\t\tw = dev->max_width;\n\t\tif (h > dev->max_height)\n\t\t\th = dev->max_height;\n\n\t\tdprintk(\"trying image %dx%d\\n\", w, h);\n\n\t\tif (w < 1)\n\t\t\tw = V4L2LOOPBACK_SIZE_DEFAULT_WIDTH;\n\n\t\tif (h < 1)\n\t\t\th = V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT;\n\n\t\tif (NULL == format)\n\t\t\tformat = &formats[0];\n\n\t\tpix_format_set_size(&fmt->fmt.pix, format, w, h);\n\n\t\tfmt->fmt.pix.pixelformat = format->fourcc;\n\n\t\tif ((fmt->fmt.pix.colorspace == V4L2_COLORSPACE_DEFAULT) ||\n\t\t    (fmt->fmt.pix.colorspace > V4L2_COLORSPACE_DCI_P3))\n\t\t\tfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;\n\n\t\tif (V4L2_FIELD_ANY == fmt->fmt.pix.field)\n\t\t\tfmt->fmt.pix.field = V4L2_FIELD_NONE;\n\n\t\t/* FIXXME: try_fmt should never modify the device-state */\n\t\tdev->pix_format = fmt->fmt.pix;\n\t}\n\treturn 0;\n}\n\n/* sets new output format, if possible;\n * allocate data here because we do not know if it will be streaming or\n * read/write IO\n * called on VIDIOC_S_FMT with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_OUTPUT\n */\nstatic int vidioc_s_fmt_out(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *fmt)\n{\n\tstruct v4l2_loopback_device *dev;\n\tchar buf[5];\n\tint ret;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\tret = vidioc_try_fmt_out(file, priv, fmt);\n\n\tdprintk(\"s_fmt_out(%d) %d...%d\\n\", ret, dev->ready_for_capture,\n\t\tdev->pix_format.sizeimage);\n\n\tbuf[4] = 0;\n\tdprintk(\"outFOURCC=%s\\n\", fourcc2str(dev->pix_format.pixelformat, buf));\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!dev->ready_for_capture) {\n\t\tdev->buffer_size = PAGE_ALIGN(dev->pix_format.sizeimage);\n\t\tfmt->fmt.pix.sizeimage = dev->buffer_size;\n\t\tallocate_buffers(dev);\n\t}\n\treturn ret;\n}\n\n// #define V4L2L_OVERLAY\n#ifdef V4L2L_OVERLAY\n/* ------------------ OVERLAY ----------------------- */\n/* currently unsupported */\n/* GSTreamer's v4l2sink is buggy, as it requires the overlay to work\n * while it should only require it, if overlay is requested\n * once the gstreamer element is fixed, remove the overlay dummies\n */\n#warning OVERLAY dummies\nstatic int vidioc_g_fmt_overlay(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *fmt)\n{\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_overlay(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *fmt)\n{\n\treturn 0;\n}\n#endif /* V4L2L_OVERLAY */\n\n/* ------------------ PARAMs ----------------------- */\n\n/* get some data flow parameters, only capability, fps and readbuffers has\n * effect on this driver\n * called on VIDIOC_G_PARM\n */\nstatic int vidioc_g_parm(struct file *file, void *priv,\n\t\t\t struct v4l2_streamparm *parm)\n{\n\t/* do not care about type of opener, hope these enums would always be\n\t * compatible */\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\tparm->parm.capture = dev->capture_param;\n\treturn 0;\n}\n\n/* get some data flow parameters, only capability, fps and readbuffers has\n * effect on this driver\n * called on VIDIOC_S_PARM\n */\nstatic int vidioc_s_parm(struct file *file, void *priv,\n\t\t\t struct v4l2_streamparm *parm)\n{\n\tstruct v4l2_loopback_device *dev;\n\tint err = 0;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\tdprintk(\"vidioc_s_parm called frate=%d/%d\\n\",\n\t\tparm->parm.capture.timeperframe.numerator,\n\t\tparm->parm.capture.timeperframe.denominator);\n\n\tswitch (parm->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tif ((err = set_timeperframe(\n\t\t\t     dev, &parm->parm.capture.timeperframe)) < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif ((err = set_timeperframe(\n\t\t\t     dev, &parm->parm.capture.timeperframe)) < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tparm->parm.capture = dev->capture_param;\n\treturn 0;\n}\n\n#ifdef V4L2LOOPBACK_WITH_STD\n/* sets a tv standard, actually we do not need to handle this any special way\n * added to support effecttv\n * called on VIDIOC_S_STD\n */\nstatic int vidioc_s_std(struct file *file, void *fh, v4l2_std_id *_std)\n{\n\tv4l2_std_id req_std = 0, supported_std = 0;\n\tconst v4l2_std_id all_std = V4L2_STD_ALL, no_std = 0;\n\n\tif (_std) {\n\t\treq_std = *_std;\n\t\t*_std = all_std;\n\t}\n\n\t/* we support everything in V4L2_STD_ALL, but not more... */\n\tsupported_std = (all_std & req_std);\n\tif (no_std == supported_std)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/* gets a fake video standard\n * called on VIDIOC_G_STD\n */\nstatic int vidioc_g_std(struct file *file, void *fh, v4l2_std_id *norm)\n{\n\tif (norm)\n\t\t*norm = V4L2_STD_ALL;\n\treturn 0;\n}\n/* gets a fake video standard\n * called on VIDIOC_QUERYSTD\n */\nstatic int vidioc_querystd(struct file *file, void *fh, v4l2_std_id *norm)\n{\n\tif (norm)\n\t\t*norm = V4L2_STD_ALL;\n\treturn 0;\n}\n#endif /* V4L2LOOPBACK_WITH_STD */\n\n/* get ctrls info\n * called on VIDIOC_QUERYCTRL\n */\nstatic int vidioc_queryctrl(struct file *file, void *fh,\n\t\t\t    struct v4l2_queryctrl *q)\n{\n\tconst struct v4l2_ctrl_config *cnf = 0;\n\tswitch (q->id) {\n\tcase CID_KEEP_FORMAT:\n\t\tcnf = &v4l2loopback_ctrl_keepformat;\n\t\tbreak;\n\tcase CID_SUSTAIN_FRAMERATE:\n\t\tcnf = &v4l2loopback_ctrl_sustainframerate;\n\t\tbreak;\n\tcase CID_TIMEOUT:\n\t\tcnf = &v4l2loopback_ctrl_timeout;\n\t\tbreak;\n\tcase CID_TIMEOUT_IMAGE_IO:\n\t\tcnf = &v4l2loopback_ctrl_timeoutimageio;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (!cnf)\n\t\tBUG();\n\n\tstrcpy(q->name, cnf->name);\n\tq->default_value = cnf->def;\n\tq->type = cnf->type;\n\tq->minimum = cnf->min;\n\tq->maximum = cnf->max;\n\tq->step = cnf->step;\n\n\tmemset(q->reserved, 0, sizeof(q->reserved));\n\treturn 0;\n}\n\nstatic int vidioc_g_ctrl(struct file *file, void *fh, struct v4l2_control *c)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\n\tswitch (c->id) {\n\tcase CID_KEEP_FORMAT:\n\t\tc->value = dev->keep_format;\n\t\tbreak;\n\tcase CID_SUSTAIN_FRAMERATE:\n\t\tc->value = dev->sustain_framerate;\n\t\tbreak;\n\tcase CID_TIMEOUT:\n\t\tc->value = jiffies_to_msecs(dev->timeout_jiffies);\n\t\tbreak;\n\tcase CID_TIMEOUT_IMAGE_IO:\n\t\tc->value = dev->timeout_image_io;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int v4l2loopback_set_ctrl(struct v4l2_loopback_device *dev, u32 id,\n\t\t\t\t s64 val)\n{\n\tswitch (id) {\n\tcase CID_KEEP_FORMAT:\n\t\tif (val < 0 || val > 1)\n\t\t\treturn -EINVAL;\n\t\tdev->keep_format = val;\n\t\ttry_free_buffers(\n\t\t\tdev); /* will only free buffers if !keep_format */\n\t\tbreak;\n\tcase CID_SUSTAIN_FRAMERATE:\n\t\tif (val < 0 || val > 1)\n\t\t\treturn -EINVAL;\n\t\tspin_lock_bh(&dev->lock);\n\t\tdev->sustain_framerate = val;\n\t\tcheck_timers(dev);\n\t\tspin_unlock_bh(&dev->lock);\n\t\tbreak;\n\tcase CID_TIMEOUT:\n\t\tif (val < 0 || val > MAX_TIMEOUT)\n\t\t\treturn -EINVAL;\n\t\tspin_lock_bh(&dev->lock);\n\t\tdev->timeout_jiffies = msecs_to_jiffies(val);\n\t\tcheck_timers(dev);\n\t\tspin_unlock_bh(&dev->lock);\n\t\tallocate_timeout_image(dev);\n\t\tbreak;\n\tcase CID_TIMEOUT_IMAGE_IO:\n\t\tif (val < 0 || val > 1)\n\t\t\treturn -EINVAL;\n\t\tdev->timeout_image_io = val;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int v4l2loopback_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_loopback_device *dev = container_of(\n\t\tctrl->handler, struct v4l2_loopback_device, ctrl_handler);\n\treturn v4l2loopback_set_ctrl(dev, ctrl->id, ctrl->val);\n}\nstatic int vidioc_s_ctrl(struct file *file, void *fh, struct v4l2_control *c)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\treturn v4l2loopback_set_ctrl(dev, c->id, c->value);\n}\n\n/* returns set of device outputs, in our case there is only one\n * called on VIDIOC_ENUMOUTPUT\n */\nstatic int vidioc_enum_output(struct file *file, void *fh,\n\t\t\t      struct v4l2_output *outp)\n{\n\t__u32 index = outp->index;\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tMARK();\n\n\tif (!dev->announce_all_caps && !dev->ready_for_output)\n\t\treturn -ENOTTY;\n\n\tif (0 != index)\n\t\treturn -EINVAL;\n\n\t/* clear all data (including the reserved fields) */\n\tmemset(outp, 0, sizeof(*outp));\n\n\toutp->index = index;\n\tstrlcpy(outp->name, \"loopback in\", sizeof(outp->name));\n\toutp->type = V4L2_OUTPUT_TYPE_ANALOG;\n\toutp->audioset = 0;\n\toutp->modulator = 0;\n#ifdef V4L2LOOPBACK_WITH_STD\n\toutp->std = V4L2_STD_ALL;\n#ifdef V4L2_OUT_CAP_STD\n\toutp->capabilities |= V4L2_OUT_CAP_STD;\n#endif /*  V4L2_OUT_CAP_STD */\n#endif /* V4L2LOOPBACK_WITH_STD */\n\n\treturn 0;\n}\n\n/* which output is currently active,\n * called on VIDIOC_G_OUTPUT\n */\nstatic int vidioc_g_output(struct file *file, void *fh, unsigned int *i)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tif (!dev->announce_all_caps && !dev->ready_for_output)\n\t\treturn -ENOTTY;\n\tif (i)\n\t\t*i = 0;\n\treturn 0;\n}\n\n/* set output, can make sense if we have more than one video src,\n * called on VIDIOC_S_OUTPUT\n */\nstatic int vidioc_s_output(struct file *file, void *fh, unsigned int i)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tif (!dev->announce_all_caps && !dev->ready_for_output)\n\t\treturn -ENOTTY;\n\n\tif (i)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/* returns set of device inputs, in our case there is only one,\n * but later I may add more\n * called on VIDIOC_ENUMINPUT\n */\nstatic int vidioc_enum_input(struct file *file, void *fh,\n\t\t\t     struct v4l2_input *inp)\n{\n\t__u32 index = inp->index;\n\tMARK();\n\n\tif (0 != index)\n\t\treturn -EINVAL;\n\n\t/* clear all data (including the reserved fields) */\n\tmemset(inp, 0, sizeof(*inp));\n\n\tinp->index = index;\n\tstrlcpy(inp->name, \"loopback\", sizeof(inp->name));\n\tinp->type = V4L2_INPUT_TYPE_CAMERA;\n\tinp->audioset = 0;\n\tinp->tuner = 0;\n\tinp->status = 0;\n\n#ifdef V4L2LOOPBACK_WITH_STD\n\tinp->std = V4L2_STD_ALL;\n#ifdef V4L2_IN_CAP_STD\n\tinp->capabilities |= V4L2_IN_CAP_STD;\n#endif\n#endif /* V4L2LOOPBACK_WITH_STD */\n\n\treturn 0;\n}\n\n/* which input is currently active,\n * called on VIDIOC_G_INPUT\n */\nstatic int vidioc_g_input(struct file *file, void *fh, unsigned int *i)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tif (!dev->announce_all_caps && !dev->ready_for_capture)\n\t\treturn -ENOTTY;\n\tif (i)\n\t\t*i = 0;\n\treturn 0;\n}\n\n/* set input, can make sense if we have more than one video src,\n * called on VIDIOC_S_INPUT\n */\nstatic int vidioc_s_input(struct file *file, void *fh, unsigned int i)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tif (!dev->announce_all_caps && !dev->ready_for_capture)\n\t\treturn -ENOTTY;\n\tif (i == 0)\n\t\treturn 0;\n\treturn -EINVAL;\n}\n\n/* --------------- V4L2 ioctl buffer related calls ----------------- */\n\n/* negotiate buffer type\n * only mmap streaming supported\n * called on VIDIOC_REQBUFS\n */\nstatic int vidioc_reqbufs(struct file *file, void *fh,\n\t\t\t  struct v4l2_requestbuffers *b)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\tint i;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(fh);\n\n\tdprintk(\"reqbufs: %d\\t%d=%d\\n\", b->memory, b->count,\n\t\tdev->buffers_number);\n\tif (opener->timeout_image_io) {\n\t\tif (b->memory != V4L2_MEMORY_MMAP)\n\t\t\treturn -EINVAL;\n\t\tb->count = 1;\n\t\treturn 0;\n\t}\n\n\tinit_buffers(dev);\n\tswitch (b->memory) {\n\tcase V4L2_MEMORY_MMAP:\n\t\t/* do nothing here, buffers are always allocated */\n\t\tif (b->count < 1 || dev->buffers_number < 1)\n\t\t\treturn 0;\n\n\t\tif (b->count > dev->buffers_number)\n\t\t\tb->count = dev->buffers_number;\n\n\t\t/* make sure that outbufs_list contains buffers from 0 to used_buffers-1\n\t\t * actually, it will have been already populated via v4l2_loopback_init()\n\t\t * at this point */\n\t\tif (list_empty(&dev->outbufs_list)) {\n\t\t\tfor (i = 0; i < dev->used_buffers; ++i)\n\t\t\t\tlist_add_tail(&dev->buffers[i].list_head,\n\t\t\t\t\t      &dev->outbufs_list);\n\t\t}\n\n\t\t/* also, if dev->used_buffers is going to be decreased, we should remove\n\t\t * out-of-range buffers from outbufs_list, and fix bufpos2index mapping */\n\t\tif (b->count < dev->used_buffers) {\n\t\t\tstruct v4l2l_buffer *pos, *n;\n\n\t\t\tlist_for_each_entry_safe (pos, n, &dev->outbufs_list,\n\t\t\t\t\t\t  list_head) {\n\t\t\t\tif (pos->buffer.index >= b->count)\n\t\t\t\t\tlist_del(&pos->list_head);\n\t\t\t}\n\n\t\t\t/* after we update dev->used_buffers, buffers in outbufs_list will\n\t\t\t * correspond to dev->write_position + [0;b->count-1] range */\n\t\t\ti = dev->write_position;\n\t\t\tlist_for_each_entry (pos, &dev->outbufs_list,\n\t\t\t\t\t     list_head) {\n\t\t\t\tdev->bufpos2index[i % b->count] =\n\t\t\t\t\tpos->buffer.index;\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\n\t\topener->buffers_number = b->count;\n\t\tif (opener->buffers_number < dev->used_buffers)\n\t\t\tdev->used_buffers = opener->buffers_number;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/* returns buffer asked for;\n * give app as many buffers as it wants, if it less than MAX,\n * but map them in our inner buffers\n * called on VIDIOC_QUERYBUF\n */\nstatic int vidioc_querybuf(struct file *file, void *fh, struct v4l2_buffer *b)\n{\n\tenum v4l2_buf_type type;\n\tint index;\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\n\tMARK();\n\n\ttype = b->type;\n\tindex = b->index;\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(fh);\n\n\tif ((b->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\n\t    (b->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)) {\n\t\treturn -EINVAL;\n\t}\n\tif (b->index > max_buffers)\n\t\treturn -EINVAL;\n\n\tif (opener->timeout_image_io)\n\t\t*b = dev->timeout_image_buffer.buffer;\n\telse\n\t\t*b = dev->buffers[b->index % dev->used_buffers].buffer;\n\n\tb->type = type;\n\tb->index = index;\n\tdprintkrw(\"buffer type: %d (of %d with size=%ld)\\n\", b->memory,\n\t\t  dev->buffers_number, dev->buffer_size);\n\n\t/*  Hopefully fix 'DQBUF return bad index if queue bigger then 2 for capture'\n            https://github.com/umlaeute/v4l2loopback/issues/60 */\n\tb->flags &= ~V4L2_BUF_FLAG_DONE;\n\tb->flags |= V4L2_BUF_FLAG_QUEUED;\n\n\treturn 0;\n}\n\nstatic void buffer_written(struct v4l2_loopback_device *dev,\n\t\t\t   struct v4l2l_buffer *buf)\n{\n\tdel_timer_sync(&dev->sustain_timer);\n\tdel_timer_sync(&dev->timeout_timer);\n\tspin_lock_bh(&dev->lock);\n\n\tdev->bufpos2index[dev->write_position % dev->used_buffers] =\n\t\tbuf->buffer.index;\n\tlist_move_tail(&buf->list_head, &dev->outbufs_list);\n\t++dev->write_position;\n\tdev->reread_count = 0;\n\n\tcheck_timers(dev);\n\tspin_unlock_bh(&dev->lock);\n}\n\n/* put buffer to queue\n * called on VIDIOC_QBUF\n */\nstatic int vidioc_qbuf(struct file *file, void *fh, struct v4l2_buffer *buf)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\tstruct v4l2l_buffer *b;\n\tint index;\n\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(fh);\n\n\tif (buf->index > max_buffers)\n\t\treturn -EINVAL;\n\tif (opener->timeout_image_io)\n\t\treturn 0;\n\n\tindex = buf->index % dev->used_buffers;\n\tb = &dev->buffers[index];\n\n\tswitch (buf->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tdprintkrw(\"capture QBUF index: %d\\n\", index);\n\t\tset_queued(b);\n\t\treturn 0;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tdprintkrw(\"output QBUF pos: %d index: %d\\n\",\n\t\t\t  dev->write_position, index);\n\t\tif (buf->timestamp.tv_sec == 0 && buf->timestamp.tv_usec == 0)\n\t\t\tv4l2l_get_timestamp(&b->buffer);\n\t\telse\n\t\t\tb->buffer.timestamp = buf->timestamp;\n\t\tb->buffer.bytesused = buf->bytesused;\n\t\tset_done(b);\n\t\tbuffer_written(dev, b);\n\n\t\t/*  Hopefully fix 'DQBUF return bad index if queue bigger then 2 for capture'\n                    https://github.com/umlaeute/v4l2loopback/issues/60 */\n\t\tbuf->flags &= ~V4L2_BUF_FLAG_DONE;\n\t\tbuf->flags |= V4L2_BUF_FLAG_QUEUED;\n\n\t\twake_up_all(&dev->read_event);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int can_read(struct v4l2_loopback_device *dev,\n\t\t    struct v4l2_loopback_opener *opener)\n{\n\tint ret;\n\n\tspin_lock_bh(&dev->lock);\n\tcheck_timers(dev);\n\tret = dev->write_position > opener->read_position ||\n\t      dev->reread_count > opener->reread_count || dev->timeout_happened;\n\tspin_unlock_bh(&dev->lock);\n\treturn ret;\n}\n\nstatic int get_capture_buffer(struct file *file)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tstruct v4l2_loopback_opener *opener = fh_to_opener(file->private_data);\n\tint pos, ret;\n\tint timeout_happened;\n\n\tif ((file->f_flags & O_NONBLOCK) &&\n\t    (dev->write_position <= opener->read_position &&\n\t     dev->reread_count <= opener->reread_count &&\n\t     !dev->timeout_happened))\n\t\treturn -EAGAIN;\n\twait_event_interruptible(dev->read_event, can_read(dev, opener));\n\n\tspin_lock_bh(&dev->lock);\n\tif (dev->write_position == opener->read_position) {\n\t\tif (dev->reread_count > opener->reread_count + 2)\n\t\t\topener->reread_count = dev->reread_count - 1;\n\t\t++opener->reread_count;\n\t\tpos = (opener->read_position + dev->used_buffers - 1) %\n\t\t      dev->used_buffers;\n\t} else {\n\t\topener->reread_count = 0;\n\t\tif (dev->write_position >\n\t\t    opener->read_position + dev->used_buffers)\n\t\t\topener->read_position = dev->write_position - 1;\n\t\tpos = opener->read_position % dev->used_buffers;\n\t\t++opener->read_position;\n\t}\n\ttimeout_happened = dev->timeout_happened;\n\tdev->timeout_happened = 0;\n\tspin_unlock_bh(&dev->lock);\n\n\tret = dev->bufpos2index[pos];\n\tif (timeout_happened) {\n\t\tif (ret < 0) {\n\t\t\tdprintk(\"trying to return not mapped buf[%d]\\n\", ret);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\t/* although allocated on-demand, timeout_image is freed only\n\t\t * in free_buffers(), so we don't need to worry about it being\n\t\t * deallocated suddenly */\n\t\tmemcpy(dev->image + dev->buffers[ret].buffer.m.offset,\n\t\t       dev->timeout_image, dev->buffer_size);\n\t}\n\treturn ret;\n}\n\n/* put buffer to dequeue\n * called on VIDIOC_DQBUF\n */\nstatic int vidioc_dqbuf(struct file *file, void *fh, struct v4l2_buffer *buf)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\tint index;\n\tstruct v4l2l_buffer *b;\n\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(fh);\n\tif (opener->timeout_image_io) {\n\t\t*buf = dev->timeout_image_buffer.buffer;\n\t\treturn 0;\n\t}\n\n\tswitch (buf->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tindex = get_capture_buffer(file);\n\t\tif (index < 0)\n\t\t\treturn index;\n\t\tdprintkrw(\"capture DQBUF pos: %d index: %d\\n\",\n\t\t\t  opener->read_position - 1, index);\n\t\tif (!(dev->buffers[index].buffer.flags &\n\t\t      V4L2_BUF_FLAG_MAPPED)) {\n\t\t\tdprintk(\"trying to return not mapped buf[%d]\\n\", index);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tunset_flags(&dev->buffers[index]);\n\t\t*buf = dev->buffers[index].buffer;\n\t\treturn 0;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tb = list_entry(dev->outbufs_list.prev, struct v4l2l_buffer,\n\t\t\t       list_head);\n\t\tlist_move_tail(&b->list_head, &dev->outbufs_list);\n\t\tdprintkrw(\"output DQBUF index: %d\\n\", b->buffer.index);\n\t\tunset_flags(b);\n\t\t*buf = b->buffer;\n\t\tbuf->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/* ------------- STREAMING ------------------- */\n\n/* start streaming\n * called on VIDIOC_STREAMON\n */\nstatic int vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type type)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(fh);\n\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif (!dev->ready_for_capture) {\n\t\t\tint ret = allocate_buffers(dev);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\topener->type = WRITER;\n\t\tdev->ready_for_output = 0;\n\t\tdev->ready_for_capture++;\n\t\treturn 0;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tif (!dev->ready_for_capture)\n\t\t\treturn -EIO;\n\t\topener->type = READER;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn -EINVAL;\n}\n\n/* stop streaming\n * called on VIDIOC_STREAMOFF\n */\nstatic int vidioc_streamoff(struct file *file, void *fh,\n\t\t\t    enum v4l2_buf_type type)\n{\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\tdprintk(\"%d\\n\", type);\n\n\tdev = v4l2loopback_getdevice(file);\n\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif (dev->ready_for_capture > 0)\n\t\t\tdev->ready_for_capture--;\n\t\treturn 0;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_VIDEO_V4L1_COMPAT\nstatic int vidiocgmbuf(struct file *file, void *fh, struct video_mbuf *p)\n{\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\tp->frames = dev->buffers_number;\n\tp->offsets[0] = 0;\n\tp->offsets[1] = 0;\n\tp->size = dev->buffer_size;\n\treturn 0;\n}\n#endif\n\nstatic int vidioc_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\t  const struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_CTRL:\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\t}\n\n\treturn -EINVAL;\n}\n\n/* file operations */\nstatic void vm_open(struct vm_area_struct *vma)\n{\n\tstruct v4l2l_buffer *buf;\n\tMARK();\n\n\tbuf = vma->vm_private_data;\n\tbuf->use_count++;\n}\n\nstatic void vm_close(struct vm_area_struct *vma)\n{\n\tstruct v4l2l_buffer *buf;\n\tMARK();\n\n\tbuf = vma->vm_private_data;\n\tbuf->use_count--;\n}\n\nstatic struct vm_operations_struct vm_ops = {\n\t.open = vm_open,\n\t.close = vm_close,\n};\n\nstatic int v4l2_loopback_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tu8 *addr;\n\tunsigned long start;\n\tunsigned long size;\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\tstruct v4l2l_buffer *buffer = NULL;\n\tMARK();\n\n\tstart = (unsigned long)vma->vm_start;\n\tsize = (unsigned long)(vma->vm_end - vma->vm_start);\n\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(file->private_data);\n\n\tif (size > dev->buffer_size) {\n\t\tdprintk(\"userspace tries to mmap too much, fail\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (opener->timeout_image_io) {\n\t\t/* we are going to map the timeout_image_buffer */\n\t\tif ((vma->vm_pgoff << PAGE_SHIFT) !=\n\t\t    dev->buffer_size * MAX_BUFFERS) {\n\t\t\tdprintk(\"invalid mmap offset for timeout_image_io mode\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if ((vma->vm_pgoff << PAGE_SHIFT) >\n\t\t   dev->buffer_size * (dev->buffers_number - 1)) {\n\t\tdprintk(\"userspace tries to mmap too far, fail\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* FIXXXXXME: allocation should not happen here! */\n\tif (NULL == dev->image)\n\t\tif (allocate_buffers(dev) < 0)\n\t\t\treturn -EINVAL;\n\n\tif (opener->timeout_image_io) {\n\t\tbuffer = &dev->timeout_image_buffer;\n\t\taddr = dev->timeout_image;\n\t} else {\n\t\tint i;\n\t\tfor (i = 0; i < dev->buffers_number; ++i) {\n\t\t\tbuffer = &dev->buffers[i];\n\t\t\tif ((buffer->buffer.m.offset >> PAGE_SHIFT) ==\n\t\t\t    vma->vm_pgoff)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (NULL == buffer)\n\t\t\treturn -EINVAL;\n\n\t\taddr = dev->image + (vma->vm_pgoff << PAGE_SHIFT);\n\t}\n\n\twhile (size > 0) {\n\t\tstruct page *page;\n\n\t\tpage = vmalloc_to_page(addr);\n\n\t\tif (vm_insert_page(vma, start, page) < 0)\n\t\t\treturn -EAGAIN;\n\n\t\tstart += PAGE_SIZE;\n\t\taddr += PAGE_SIZE;\n\t\tsize -= PAGE_SIZE;\n\t}\n\n\tvma->vm_ops = &vm_ops;\n\tvma->vm_private_data = buffer;\n\tbuffer->buffer.flags |= V4L2_BUF_FLAG_MAPPED;\n\n\tvm_open(vma);\n\n\tMARK();\n\treturn 0;\n}\n\nstatic unsigned int v4l2_loopback_poll(struct file *file,\n\t\t\t\t       struct poll_table_struct *pts)\n{\n\tstruct v4l2_loopback_opener *opener;\n\tstruct v4l2_loopback_device *dev;\n\t__poll_t req_events = poll_requested_events(pts);\n\tint ret_mask = 0;\n\tMARK();\n\n\topener = fh_to_opener(file->private_data);\n\tdev = v4l2loopback_getdevice(file);\n\n\tif (req_events & POLLPRI) {\n\t\tif (!v4l2_event_pending(&opener->fh))\n\t\t\tpoll_wait(file, &opener->fh.wait, pts);\n\t\tif (v4l2_event_pending(&opener->fh)) {\n\t\t\tret_mask |= POLLPRI;\n\t\t\tif (!(req_events & DEFAULT_POLLMASK))\n\t\t\t\treturn ret_mask;\n\t\t}\n\t}\n\n\tswitch (opener->type) {\n\tcase WRITER:\n\t\tret_mask |= POLLOUT | POLLWRNORM;\n\t\tbreak;\n\tcase READER:\n\t\tif (!can_read(dev, opener)) {\n\t\t\tif (ret_mask)\n\t\t\t\treturn ret_mask;\n\t\t\tpoll_wait(file, &dev->read_event, pts);\n\t\t}\n\t\tif (can_read(dev, opener))\n\t\t\tret_mask |= POLLIN | POLLRDNORM;\n\t\tif (v4l2_event_pending(&opener->fh))\n\t\t\tret_mask |= POLLPRI;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tMARK();\n\treturn ret_mask;\n}\n\n/* do not want to limit device opens, it can be as many readers as user want,\n * writers are limited by means of setting writer field */\nstatic int v4l2_loopback_open(struct file *file)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\tMARK();\n\tdev = v4l2loopback_getdevice(file);\n\tif (dev->open_count.counter >= dev->max_openers)\n\t\treturn -EBUSY;\n\t/* kfree on close */\n\topener = kzalloc(sizeof(*opener), GFP_KERNEL);\n\tif (opener == NULL)\n\t\treturn -ENOMEM;\n\n\tatomic_inc(&dev->open_count);\n\n\topener->timeout_image_io = dev->timeout_image_io;\n\tif (opener->timeout_image_io) {\n\t\tint r = allocate_timeout_image(dev);\n\n\t\tif (r < 0) {\n\t\t\tdprintk(\"timeout image allocation failed\\n\");\n\n\t\t\tatomic_dec(&dev->open_count);\n\n\t\t\tkfree(opener);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tdev->timeout_image_io = 0;\n\n\tv4l2_fh_init(&opener->fh, video_devdata(file));\n\tfile->private_data = &opener->fh;\n\n\tv4l2_fh_add(&opener->fh);\n\tdprintk(\"opened dev:%p with image:%p\\n\", dev, dev ? dev->image : NULL);\n\tMARK();\n\treturn 0;\n}\n\nstatic int v4l2_loopback_close(struct file *file)\n{\n\tstruct v4l2_loopback_opener *opener;\n\tstruct v4l2_loopback_device *dev;\n\tint iswriter = 0;\n\tMARK();\n\n\topener = fh_to_opener(file->private_data);\n\tdev = v4l2loopback_getdevice(file);\n\n\tif (WRITER == opener->type)\n\t\tiswriter = 1;\n\n\tatomic_dec(&dev->open_count);\n\tif (dev->open_count.counter == 0) {\n\t\tdel_timer_sync(&dev->sustain_timer);\n\t\tdel_timer_sync(&dev->timeout_timer);\n\t}\n\ttry_free_buffers(dev);\n\n\tv4l2_fh_del(&opener->fh);\n\tv4l2_fh_exit(&opener->fh);\n\n\tkfree(opener);\n\tif (iswriter) {\n\t\tdev->ready_for_output = 1;\n\t}\n\tMARK();\n\treturn 0;\n}\n\nstatic ssize_t v4l2_loopback_read(struct file *file, char __user *buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tint read_index;\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_buffer *b;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\n\tread_index = get_capture_buffer(file);\n\tif (read_index < 0)\n\t\treturn read_index;\n\tif (count > dev->buffer_size)\n\t\tcount = dev->buffer_size;\n\tb = &dev->buffers[read_index].buffer;\n\tif (count > b->bytesused)\n\t\tcount = b->bytesused;\n\tif (copy_to_user((void *)buf, (void *)(dev->image + b->m.offset),\n\t\t\t count)) {\n\t\tprintk(KERN_ERR\n\t\t       \"v4l2-loopback: failed copy_to_user() in read buf\\n\");\n\t\treturn -EFAULT;\n\t}\n\tdprintkrw(\"leave v4l2_loopback_read()\\n\");\n\treturn count;\n}\n\nstatic ssize_t v4l2_loopback_write(struct file *file, const char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct v4l2_loopback_opener *opener;\n\tstruct v4l2_loopback_device *dev;\n\tint write_index;\n\tstruct v4l2_buffer *b;\n\tint err = 0;\n\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(file->private_data);\n\n\tif (UNNEGOTIATED == opener->type) {\n\t\tspin_lock(&dev->lock);\n\n\t\tif (dev->ready_for_output) {\n\t\t\terr = vidioc_streamon(file, file->private_data,\n\t\t\t\t\t      V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\t\t}\n\n\t\tspin_unlock(&dev->lock);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (WRITER != opener->type)\n\t\treturn -EINVAL;\n\n\tif (!dev->ready_for_capture) {\n\t\tint ret = allocate_buffers(dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdev->ready_for_capture = 1;\n\t}\n\tdprintkrw(\"v4l2_loopback_write() trying to write %zu bytes\\n\", count);\n\tif (count > dev->buffer_size)\n\t\tcount = dev->buffer_size;\n\n\twrite_index = dev->write_position % dev->used_buffers;\n\tb = &dev->buffers[write_index].buffer;\n\n\tif (copy_from_user((void *)(dev->image + b->m.offset), (void *)buf,\n\t\t\t   count)) {\n\t\tprintk(KERN_ERR\n\t\t       \"v4l2-loopback: failed copy_from_user() in write buf, could not write %zu\\n\",\n\t\t       count);\n\t\treturn -EFAULT;\n\t}\n\tv4l2l_get_timestamp(b);\n\tb->bytesused = count;\n\tb->sequence = dev->write_position;\n\tbuffer_written(dev, &dev->buffers[write_index]);\n\twake_up_all(&dev->read_event);\n\tdprintkrw(\"leave v4l2_loopback_write()\\n\");\n\treturn count;\n}\n\n/* init functions */\n/* frees buffers, if already allocated */\nstatic void free_buffers(struct v4l2_loopback_device *dev)\n{\n\tMARK();\n\tdprintk(\"freeing image@%p for dev:%p\\n\", dev ? dev->image : NULL, dev);\n\tif (dev->image) {\n\t\tvfree(dev->image);\n\t\tdev->image = NULL;\n\t}\n\tif (dev->timeout_image) {\n\t\tvfree(dev->timeout_image);\n\t\tdev->timeout_image = NULL;\n\t}\n\tdev->imagesize = 0;\n}\n/* frees buffers, if they are no longer needed */\nstatic void try_free_buffers(struct v4l2_loopback_device *dev)\n{\n\tMARK();\n\tif (0 == dev->open_count.counter && !dev->keep_format) {\n\t\tfree_buffers(dev);\n\t\tdev->ready_for_capture = 0;\n\t\tdev->buffer_size = 0;\n\t\tdev->write_position = 0;\n\t}\n}\n/* allocates buffers, if buffer_size is set */\nstatic int allocate_buffers(struct v4l2_loopback_device *dev)\n{\n\tint err;\n\n\tMARK();\n\t/* vfree on close file operation in case no open handles left */\n\n\tif (dev->buffer_size < 1 || dev->buffers_number < 1)\n\t\treturn -EINVAL;\n\n\tif ((__LONG_MAX__ / dev->buffer_size) < dev->buffers_number)\n\t\treturn -ENOSPC;\n\n\tif (dev->image) {\n\t\tdprintk(\"allocating buffers again: %ld %ld\\n\",\n\t\t\tdev->buffer_size * dev->buffers_number, dev->imagesize);\n\t\t/* FIXME: prevent double allocation more intelligently! */\n\t\tif (dev->buffer_size * dev->buffers_number == dev->imagesize)\n\t\t\treturn 0;\n\n\t\t/* if there is only one writer, no problem should occur */\n\t\tif (dev->open_count.counter == 1)\n\t\t\tfree_buffers(dev);\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tdev->imagesize = (unsigned long)dev->buffer_size *\n\t\t\t (unsigned long)dev->buffers_number;\n\n\tdprintk(\"allocating %ld = %ldx%d\\n\", dev->imagesize, dev->buffer_size,\n\t\tdev->buffers_number);\n\terr = -ENOMEM;\n\n\tif (dev->timeout_jiffies > 0) {\n\t\terr = allocate_timeout_image(dev);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t}\n\n\tdev->image = vmalloc(dev->imagesize);\n\tif (dev->image == NULL)\n\t\tgoto error;\n\n\tdprintk(\"vmallocated %ld bytes\\n\", dev->imagesize);\n\tMARK();\n\n\tinit_buffers(dev);\n\treturn 0;\n\nerror:\n\tfree_buffers(dev);\n\treturn err;\n}\n\n/* init inner buffers, they are capture mode and flags are set as\n * for capture mod buffers */\nstatic void init_buffers(struct v4l2_loopback_device *dev)\n{\n\tint i;\n\tint buffer_size;\n\tint bytesused;\n\tMARK();\n\n\tbuffer_size = dev->buffer_size;\n\tbytesused = dev->pix_format.sizeimage;\n\n\tfor (i = 0; i < dev->buffers_number; ++i) {\n\t\tstruct v4l2_buffer *b = &dev->buffers[i].buffer;\n\t\tb->index = i;\n\t\tb->bytesused = bytesused;\n\t\tb->length = buffer_size;\n\t\tb->field = V4L2_FIELD_NONE;\n\t\tb->flags = 0;\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 1)\n\t\tb->input = 0;\n#endif\n\t\tb->m.offset = i * buffer_size;\n\t\tb->memory = V4L2_MEMORY_MMAP;\n\t\tb->sequence = 0;\n\t\tb->timestamp.tv_sec = 0;\n\t\tb->timestamp.tv_usec = 0;\n\t\tb->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n\t\tv4l2l_get_timestamp(b);\n\t}\n\tdev->timeout_image_buffer = dev->buffers[0];\n\tdev->timeout_image_buffer.buffer.m.offset = MAX_BUFFERS * buffer_size;\n\tMARK();\n}\n\nstatic int allocate_timeout_image(struct v4l2_loopback_device *dev)\n{\n\tMARK();\n\tif (dev->buffer_size <= 0)\n\t\treturn -EINVAL;\n\n\tif (dev->timeout_image == NULL) {\n\t\tdev->timeout_image = v4l2l_vzalloc(dev->buffer_size);\n\t\tif (dev->timeout_image == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n/* fills and register video device */\nstatic void init_vdev(struct video_device *vdev, int nr)\n{\n\tMARK();\n\n#ifdef V4L2LOOPBACK_WITH_STD\n\tvdev->tvnorms = V4L2_STD_ALL;\n#endif /* V4L2LOOPBACK_WITH_STD */\n\n\tvdev->vfl_type = VFL_TYPE_VIDEO;\n\tvdev->fops = &v4l2_loopback_fops;\n\tvdev->ioctl_ops = &v4l2_loopback_ioctl_ops;\n\tvdev->release = &video_device_release;\n\tvdev->minor = -1;\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n\tvdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT |\n\t\t\t    V4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\n#ifdef V4L2_CAP_VIDEO_M2M\n\tvdev->device_caps |= V4L2_CAP_VIDEO_M2M;\n#endif\n#endif /* >=linux-4.7.0 */\n\n\tif (debug > 1)\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 20, 0)\n\t\tvdev->debug = V4L2_DEBUG_IOCTL | V4L2_DEBUG_IOCTL_ARG;\n#else\n\t\tvdev->dev_debug =\n\t\t\tV4L2_DEV_DEBUG_IOCTL | V4L2_DEV_DEBUG_IOCTL_ARG;\n#endif\n\n\t\t/* since kernel-3.7, there is a new field 'vfl_dir' that has to be\n\t * set to VFL_DIR_M2M for bidirectional devices */\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0)\n\tvdev->vfl_dir = VFL_DIR_M2M;\n#endif\n\n\tMARK();\n}\n\n/* init default capture parameters, only fps may be changed in future */\nstatic void init_capture_param(struct v4l2_captureparm *capture_param)\n{\n\tMARK();\n\tcapture_param->capability = 0;\n\tcapture_param->capturemode = 0;\n\tcapture_param->extendedmode = 0;\n\tcapture_param->readbuffers = max_buffers;\n\tcapture_param->timeperframe.numerator = 1;\n\tcapture_param->timeperframe.denominator = 30;\n}\n\nstatic void check_timers(struct v4l2_loopback_device *dev)\n{\n\tif (!dev->ready_for_capture)\n\t\treturn;\n\n\tif (dev->timeout_jiffies > 0 && !timer_pending(&dev->timeout_timer))\n\t\tmod_timer(&dev->timeout_timer, jiffies + dev->timeout_jiffies);\n\tif (dev->sustain_framerate && !timer_pending(&dev->sustain_timer))\n\t\tmod_timer(&dev->sustain_timer,\n\t\t\t  jiffies + dev->frame_jiffies * 3 / 2);\n}\n#ifdef HAVE_TIMER_SETUP\nstatic void sustain_timer_clb(struct timer_list *t)\n{\n\tstruct v4l2_loopback_device *dev = from_timer(dev, t, sustain_timer);\n#else\nstatic void sustain_timer_clb(unsigned long nr)\n{\n\tstruct v4l2_loopback_device *dev =\n\t\tidr_find(&v4l2loopback_index_idr, nr);\n#endif\n\tspin_lock(&dev->lock);\n\tif (dev->sustain_framerate) {\n\t\tdev->reread_count++;\n\t\tdprintkrw(\"reread: %d %d\\n\", dev->write_position,\n\t\t\t  dev->reread_count);\n\t\tif (dev->reread_count == 1)\n\t\t\tmod_timer(&dev->sustain_timer,\n\t\t\t\t  jiffies + max(1UL, dev->frame_jiffies / 2));\n\t\telse\n\t\t\tmod_timer(&dev->sustain_timer,\n\t\t\t\t  jiffies + dev->frame_jiffies);\n\t\twake_up_all(&dev->read_event);\n\t}\n\tspin_unlock(&dev->lock);\n}\n#ifdef HAVE_TIMER_SETUP\nstatic void timeout_timer_clb(struct timer_list *t)\n{\n\tstruct v4l2_loopback_device *dev = from_timer(dev, t, timeout_timer);\n#else\nstatic void timeout_timer_clb(unsigned long nr)\n{\n\tstruct v4l2_loopback_device *dev =\n\t\tidr_find(&v4l2loopback_index_idr, nr);\n#endif\n\tspin_lock(&dev->lock);\n\tif (dev->timeout_jiffies > 0) {\n\t\tdev->timeout_happened = 1;\n\t\tmod_timer(&dev->timeout_timer, jiffies + dev->timeout_jiffies);\n\t\twake_up_all(&dev->read_event);\n\t}\n\tspin_unlock(&dev->lock);\n}\n\n/* init loopback main structure */\n#define DEFAULT_FROM_CONF(confmember, default_condition, default_value)        \\\n\t((conf) ?                                                              \\\n\t\t ((conf->confmember default_condition) ? (default_value) :     \\\n\t\t\t\t\t\t\t       (conf->confmember)) : \\\n\t\t       default_value)\n\nstatic int v4l2_loopback_add(struct v4l2_loopback_config *conf, int *ret_nr)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct v4l2loopback_private *vdev_priv = NULL;\n\n\tint err = -ENOMEM;\n\n\tint _max_width = DEFAULT_FROM_CONF(\n\t\tmax_width, < V4L2LOOPBACK_SIZE_MIN_WIDTH, max_width);\n\tint _max_height = DEFAULT_FROM_CONF(\n\t\tmax_height, < V4L2LOOPBACK_SIZE_MIN_HEIGHT, max_height);\n\tbool _announce_all_caps = (conf && conf->announce_all_caps >= 0) ?\n\t\t\t\t\t  (conf->announce_all_caps) :\n\t\t\t\t\t\tV4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS;\n\tint _max_buffers = DEFAULT_FROM_CONF(max_buffers, <= 0, max_buffers);\n\tint _max_openers = DEFAULT_FROM_CONF(max_openers, <= 0, max_openers);\n\n\tint nr = -1;\n\n\t_announce_all_caps = (!!_announce_all_caps);\n\n\tif (conf) {\n\t\tif (conf->capture_nr >= 0 &&\n\t\t    conf->output_nr == conf->capture_nr) {\n\t\t\tnr = conf->capture_nr;\n\t\t} else if (conf->capture_nr < 0 && conf->output_nr < 0) {\n\t\t\tnr = -1;\n\t\t} else if (conf->capture_nr < 0) {\n\t\t\tnr = conf->output_nr;\n\t\t} else if (conf->output_nr < 0) {\n\t\t\tnr = conf->capture_nr;\n\t\t} else {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"split OUTPUT and CAPTURE devices not yet supported.\");\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"both devices must have the same number (%d != %d).\",\n\t\t\t       conf->output_nr, conf->capture_nr);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (idr_find(&v4l2loopback_index_idr, nr))\n\t\treturn -EEXIST;\n\n\tdprintk(\"creating v4l2loopback-device #%d\\n\", nr);\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t/* allocate id, if @id >= 0, we're requesting that specific id */\n\tif (nr >= 0) {\n\t\terr = idr_alloc(&v4l2loopback_index_idr, dev, nr, nr + 1,\n\t\t\t\tGFP_KERNEL);\n\t\tif (err == -ENOSPC)\n\t\t\terr = -EEXIST;\n\t} else {\n\t\terr = idr_alloc(&v4l2loopback_index_idr, dev, 0, 0, GFP_KERNEL);\n\t}\n\tif (err < 0)\n\t\tgoto out_free_dev;\n\tnr = err;\n\terr = -ENOMEM;\n\n\tif (conf && conf->card_label && *(conf->card_label)) {\n\t\tsnprintf(dev->card_label, sizeof(dev->card_label), \"%s\",\n\t\t\t conf->card_label);\n\t} else {\n\t\tsnprintf(dev->card_label, sizeof(dev->card_label),\n\t\t\t \"Dummy video device (0x%04X)\", nr);\n\t}\n\tsnprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name),\n\t\t \"v4l2loopback-%03d\", nr);\n\n\terr = v4l2_device_register(NULL, &dev->v4l2_dev);\n\tif (err)\n\t\tgoto out_free_idr;\n\tMARK();\n\n\tdev->vdev = video_device_alloc();\n\tif (dev->vdev == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unregister;\n\t}\n\n\tvdev_priv = kzalloc(sizeof(struct v4l2loopback_private), GFP_KERNEL);\n\tif (vdev_priv == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unregister;\n\t}\n\n\tvideo_set_drvdata(dev->vdev, vdev_priv);\n\tif (video_get_drvdata(dev->vdev) == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unregister;\n\t}\n\n\tMARK();\n\tsnprintf(dev->vdev->name, sizeof(dev->vdev->name), \"%s\", dev->card_label);\n\n\tvdev_priv->device_nr = nr;\n\n\tinit_vdev(dev->vdev, nr);\n\tdev->vdev->v4l2_dev = &dev->v4l2_dev;\n\tinit_capture_param(&dev->capture_param);\n\terr = set_timeperframe(dev, &dev->capture_param.timeperframe);\n\tif (err)\n\t\tgoto out_unregister;\n\tdev->keep_format = 0;\n\tdev->sustain_framerate = 0;\n\n\tdev->announce_all_caps = _announce_all_caps;\n\tdev->max_width = _max_width;\n\tdev->max_height = _max_height;\n\tdev->max_openers = _max_openers;\n\tdev->buffers_number = dev->used_buffers = _max_buffers;\n\n\tdev->write_position = 0;\n\n\tMARK();\n\tspin_lock_init(&dev->lock);\n\tINIT_LIST_HEAD(&dev->outbufs_list);\n\tif (list_empty(&dev->outbufs_list)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < dev->used_buffers; ++i)\n\t\t\tlist_add_tail(&dev->buffers[i].list_head,\n\t\t\t\t      &dev->outbufs_list);\n\t}\n\tmemset(dev->bufpos2index, 0, sizeof(dev->bufpos2index));\n\tatomic_set(&dev->open_count, 0);\n\tdev->ready_for_capture = 0;\n\tdev->ready_for_output = 1;\n\n\tdev->buffer_size = 0;\n\tdev->image = NULL;\n\tdev->imagesize = 0;\n#ifdef HAVE_TIMER_SETUP\n\ttimer_setup(&dev->sustain_timer, sustain_timer_clb, 0);\n\ttimer_setup(&dev->timeout_timer, timeout_timer_clb, 0);\n#else\n\tsetup_timer(&dev->sustain_timer, sustain_timer_clb, nr);\n\tsetup_timer(&dev->timeout_timer, timeout_timer_clb, nr);\n#endif\n\tdev->reread_count = 0;\n\tdev->timeout_jiffies = 0;\n\tdev->timeout_image = NULL;\n\tdev->timeout_happened = 0;\n\n\thdl = &dev->ctrl_handler;\n\terr = v4l2_ctrl_handler_init(hdl, 4);\n\tif (err)\n\t\tgoto out_unregister;\n\tv4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_keepformat, NULL);\n\tv4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_sustainframerate, NULL);\n\tv4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_timeout, NULL);\n\tv4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_timeoutimageio, NULL);\n\tif (hdl->error) {\n\t\terr = hdl->error;\n\t\tgoto out_free_handler;\n\t}\n\tdev->v4l2_dev.ctrl_handler = hdl;\n\n\terr = v4l2_ctrl_handler_setup(hdl);\n\tif (err)\n\t\tgoto out_free_handler;\n\n\t/* FIXME set buffers to 0 */\n\n\t/* Set initial format */\n\tdev->pix_format.width = 0; /* V4L2LOOPBACK_SIZE_DEFAULT_WIDTH; */\n\tdev->pix_format.height = 0; /* V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT; */\n\tdev->pix_format.pixelformat = formats[0].fourcc;\n\tdev->pix_format.colorspace =\n\t\tV4L2_COLORSPACE_SRGB; /* do we need to set this ? */\n\tdev->pix_format.field = V4L2_FIELD_NONE;\n\n\tdev->buffer_size = PAGE_ALIGN(dev->pix_format.sizeimage);\n\tdprintk(\"buffer_size = %ld (=%d)\\n\", dev->buffer_size,\n\t\tdev->pix_format.sizeimage);\n\n\tif (dev->buffer_size && ((err = allocate_buffers(dev)) < 0))\n\t\tgoto out_free_handler;\n\n\tinit_waitqueue_head(&dev->read_event);\n\n\t/* register the device -> it creates /dev/video* */\n\tif (video_register_device(dev->vdev, VFL_TYPE_VIDEO, nr) < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"v4l2loopback: failed video_register_device()\\n\");\n\t\terr = -EFAULT;\n\t\tgoto out_free_device;\n\t}\n\tv4l2loopback_create_sysfs(dev->vdev);\n\n\tMARK();\n\tif (ret_nr)\n\t\t*ret_nr = dev->vdev->num;\n\treturn 0;\n\nout_free_device:\n\tvideo_device_release(dev->vdev);\nout_free_handler:\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\nout_unregister:\n\tvideo_set_drvdata(dev->vdev, NULL);\n\tif (vdev_priv != NULL)\n\t\tkfree(vdev_priv);\n\tv4l2_device_unregister(&dev->v4l2_dev);\nout_free_idr:\n\tidr_remove(&v4l2loopback_index_idr, nr);\nout_free_dev:\n\tkfree(dev);\n\treturn err;\n}\n\nstatic void v4l2_loopback_remove(struct v4l2_loopback_device *dev)\n{\n\tfree_buffers(dev);\n\tv4l2loopback_remove_sysfs(dev->vdev);\n\tkfree(video_get_drvdata(dev->vdev));\n\tvideo_unregister_device(dev->vdev);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\n\tkfree(dev);\n}\n\nstatic long v4l2loopback_control_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t       unsigned long parm)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_config conf;\n\tstruct v4l2_loopback_config *confptr = &conf;\n\tint device_nr;\n\tint ret;\n\n\tret = mutex_lock_killable(&v4l2loopback_ctl_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EINVAL;\n\tswitch (cmd) {\n\tdefault:\n\t\tret = -ENOSYS;\n\t\tbreak;\n\t\t/* add a v4l2loopback device (pair), based on the user-provided specs */\n\tcase V4L2LOOPBACK_CTL_ADD:\n\t\tif (parm) {\n\t\t\tif ((ret = copy_from_user(&conf, (void *)parm,\n\t\t\t\t\t\t  sizeof(conf))) < 0)\n\t\t\t\tbreak;\n\t\t} else\n\t\t\tconfptr = NULL;\n\t\tret = v4l2_loopback_add(confptr, &device_nr);\n\t\tif (ret >= 0)\n\t\t\tret = device_nr;\n\t\tbreak;\n\t\t/* remove a v4l2loopback device (both capture and output) */\n\tcase V4L2LOOPBACK_CTL_REMOVE:\n\t\tret = v4l2loopback_lookup((int)parm, &dev);\n\t\tif (ret >= 0 && dev) {\n\t\t\tint nr = ret;\n\t\t\tret = -EBUSY;\n\t\t\tif (dev->open_count.counter > 0)\n\t\t\t\tbreak;\n\t\t\tidr_remove(&v4l2loopback_index_idr, nr);\n\t\t\tv4l2_loopback_remove(dev);\n\t\t\tret = 0;\n\t\t};\n\t\tbreak;\n\t\t/* get information for a loopback device.\n                 * this is mostly about limits (which cannot be queried directly with  VIDIOC_G_FMT and friends\n                 */\n\tcase V4L2LOOPBACK_CTL_QUERY:\n\t\tif (!parm)\n\t\t\tbreak;\n\t\tif ((ret = copy_from_user(&conf, (void *)parm, sizeof(conf))) <\n\t\t    0)\n\t\t\tbreak;\n\t\tdevice_nr =\n\t\t\t(conf.output_nr < 0) ? conf.capture_nr : conf.output_nr;\n\t\tMARK();\n\t\t/* get the device from either capture_nr or output_nr (whatever is valid) */\n\t\tif ((ret = v4l2loopback_lookup(device_nr, &dev)) < 0)\n\t\t\tbreak;\n\t\tMARK();\n\t\t/* if we got the device from output_nr and there is a valid capture_nr,\n                 * make sure that both refer to the same device (or bail out)\n                 */\n\t\tif ((device_nr != conf.capture_nr) && (conf.capture_nr >= 0) &&\n\t\t    (ret != v4l2loopback_lookup(conf.capture_nr, 0)))\n\t\t\tbreak;\n\t\tMARK();\n\t\t/* if otoh, we got the device from capture_nr and there is a valid output_nr,\n                 * make sure that both refer to the same device (or bail out)\n                 */\n\t\tif ((device_nr != conf.output_nr) && (conf.output_nr >= 0) &&\n\t\t    (ret != v4l2loopback_lookup(conf.output_nr, 0)))\n\t\t\tbreak;\n\t\tMARK();\n\n\t\t/* v4l2_loopback_config identified a single device, so fetch the data */\n\t\tsnprintf(conf.card_label, sizeof(conf.card_label), \"%s\",\n\t\t\t dev->card_label);\n\t\tMARK();\n\t\tconf.output_nr = conf.capture_nr = dev->vdev->num;\n\t\tconf.max_width = dev->max_width;\n\t\tconf.max_height = dev->max_height;\n\t\tconf.announce_all_caps = dev->announce_all_caps;\n\t\tconf.max_buffers = dev->buffers_number;\n\t\tconf.max_openers = dev->max_openers;\n\t\tconf.debug = debug;\n\t\tMARK();\n\t\tif (copy_to_user((void *)parm, &conf, sizeof(conf))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tMARK();\n\t\tret = 0;\n\t\t;\n\t\tbreak;\n\t}\n\n\tMARK();\n\tmutex_unlock(&v4l2loopback_ctl_mutex);\n\tMARK();\n\treturn ret;\n}\n\n/* LINUX KERNEL */\n\nstatic const struct file_operations v4l2loopback_ctl_fops = {\n\t// clang-format off\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= nonseekable_open,\n\t.unlocked_ioctl\t= v4l2loopback_control_ioctl,\n\t.compat_ioctl\t= v4l2loopback_control_ioctl,\n\t.llseek\t\t= noop_llseek,\n\t// clang-format on\n};\n\nstatic struct miscdevice v4l2loopback_misc = {\n\t// clang-format off\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"v4l2loopback\",\n\t.fops\t\t= &v4l2loopback_ctl_fops,\n\t// clang-format on\n};\n\nstatic const struct v4l2_file_operations v4l2_loopback_fops = {\n\t// clang-format off\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= v4l2_loopback_open,\n\t.release\t= v4l2_loopback_close,\n\t.read\t\t= v4l2_loopback_read,\n\t.write\t\t= v4l2_loopback_write,\n\t.poll\t\t= v4l2_loopback_poll,\n\t.mmap\t\t= v4l2_loopback_mmap,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t// clang-format on\n};\n\nstatic const struct v4l2_ioctl_ops v4l2_loopback_ioctl_ops = {\n\t// clang-format off\n\t.vidioc_querycap\t\t= &vidioc_querycap,\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 29)\n\t.vidioc_enum_framesizes\t\t= &vidioc_enum_framesizes,\n\t.vidioc_enum_frameintervals\t= &vidioc_enum_frameintervals,\n#endif\n\n#ifndef HAVE__V4L2_CTRLS\n\t.vidioc_queryctrl\t\t= &vidioc_queryctrl,\n\t.vidioc_g_ctrl\t\t\t= &vidioc_g_ctrl,\n\t.vidioc_s_ctrl\t\t\t= &vidioc_s_ctrl,\n#endif /* HAVE__V4L2_CTRLS */\n\n\t.vidioc_enum_output\t\t= &vidioc_enum_output,\n\t.vidioc_g_output\t\t= &vidioc_g_output,\n\t.vidioc_s_output\t\t= &vidioc_s_output,\n\n\t.vidioc_enum_input\t\t= &vidioc_enum_input,\n\t.vidioc_g_input\t\t\t= &vidioc_g_input,\n\t.vidioc_s_input\t\t\t= &vidioc_s_input,\n\n\t.vidioc_enum_fmt_vid_cap\t= &vidioc_enum_fmt_cap,\n\t.vidioc_g_fmt_vid_cap\t\t= &vidioc_g_fmt_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= &vidioc_s_fmt_cap,\n\t.vidioc_try_fmt_vid_cap\t\t= &vidioc_try_fmt_cap,\n\n\t.vidioc_enum_fmt_vid_out\t= &vidioc_enum_fmt_out,\n\t.vidioc_s_fmt_vid_out\t\t= &vidioc_s_fmt_out,\n\t.vidioc_g_fmt_vid_out\t\t= &vidioc_g_fmt_out,\n\t.vidioc_try_fmt_vid_out\t\t= &vidioc_try_fmt_out,\n\n#ifdef V4L2L_OVERLAY\n\t.vidioc_s_fmt_vid_overlay\t= &vidioc_s_fmt_overlay,\n\t.vidioc_g_fmt_vid_overlay\t= &vidioc_g_fmt_overlay,\n#endif\n\n#ifdef V4L2LOOPBACK_WITH_STD\n\t.vidioc_s_std\t\t\t= &vidioc_s_std,\n\t.vidioc_g_std\t\t\t= &vidioc_g_std,\n\t.vidioc_querystd\t\t= &vidioc_querystd,\n#endif /* V4L2LOOPBACK_WITH_STD */\n\n\t.vidioc_g_parm\t\t\t= &vidioc_g_parm,\n\t.vidioc_s_parm\t\t\t= &vidioc_s_parm,\n\n\t.vidioc_reqbufs\t\t\t= &vidioc_reqbufs,\n\t.vidioc_querybuf\t\t= &vidioc_querybuf,\n\t.vidioc_qbuf\t\t\t= &vidioc_qbuf,\n\t.vidioc_dqbuf\t\t\t= &vidioc_dqbuf,\n\n\t.vidioc_streamon\t\t= &vidioc_streamon,\n\t.vidioc_streamoff\t\t= &vidioc_streamoff,\n\n#ifdef CONFIG_VIDEO_V4L1_COMPAT\n\t.vidiocgmbuf\t\t\t= &vidiocgmbuf,\n#endif\n\n\t.vidioc_subscribe_event\t\t= &vidioc_subscribe_event,\n\t.vidioc_unsubscribe_event\t= &v4l2_event_unsubscribe,\n\t// clang-format on\n};\n\nstatic int free_device_cb(int id, void *ptr, void *data)\n{\n\tstruct v4l2_loopback_device *dev = ptr;\n\tv4l2_loopback_remove(dev);\n\treturn 0;\n}\nstatic void free_devices(void)\n{\n\tidr_for_each(&v4l2loopback_index_idr, &free_device_cb, NULL);\n\tidr_destroy(&v4l2loopback_index_idr);\n}\n\nstatic int __init v4l2loopback_init_module(void)\n{\n\tint err;\n\tint i;\n\tMARK();\n\n\terr = misc_register(&v4l2loopback_misc);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (devices < 0) {\n\t\tdevices = 1;\n\n\t\t/* try guessing the devices from the \"video_nr\" parameter */\n\t\tfor (i = MAX_DEVICES - 1; i >= 0; i--) {\n\t\t\tif (video_nr[i] >= 0) {\n\t\t\t\tdevices = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (devices > MAX_DEVICES) {\n\t\tdevices = MAX_DEVICES;\n\t\tprintk(KERN_INFO\n\t\t       \"v4l2loopback: number of initial devices is limited to: %d\\n\",\n\t\t       MAX_DEVICES);\n\t}\n\n\tif (max_buffers > MAX_BUFFERS) {\n\t\tmax_buffers = MAX_BUFFERS;\n\t\tprintk(KERN_INFO\n\t\t       \"v4l2loopback: number of buffers is limited to: %d\\n\",\n\t\t       MAX_BUFFERS);\n\t}\n\n\tif (max_openers < 0) {\n\t\tprintk(KERN_INFO\n\t\t       \"v4l2loopback: allowing %d openers rather than %d\\n\",\n\t\t       2, max_openers);\n\t\tmax_openers = 2;\n\t}\n\n\tif (max_width < V4L2LOOPBACK_SIZE_MIN_WIDTH) {\n\t\tmax_width = V4L2LOOPBACK_SIZE_DEFAULT_MAX_WIDTH;\n\t\tprintk(KERN_INFO \"v4l2loopback: using max_width %d\\n\",\n\t\t       max_width);\n\t}\n\tif (max_height < V4L2LOOPBACK_SIZE_MIN_HEIGHT) {\n\t\tmax_height = V4L2LOOPBACK_SIZE_DEFAULT_MAX_HEIGHT;\n\t\tprintk(KERN_INFO \"v4l2loopback: using max_height %d\\n\",\n\t\t       max_height);\n\t}\n\n\t/* kfree on module release */\n\tfor (i = 0; i < devices; i++) {\n\t\tstruct v4l2_loopback_config cfg = {\n\t\t\t// clang-format off\n\t\t\t.output_nr\t\t= video_nr[i],\n\t\t\t.capture_nr\t\t= video_nr[i],\n\t\t\t.max_width\t\t= max_width,\n\t\t\t.max_height\t\t= max_height,\n\t\t\t.announce_all_caps\t= (!exclusive_caps[i]),\n\t\t\t.max_buffers\t\t= max_buffers,\n\t\t\t.max_openers\t\t= max_openers,\n\t\t\t.debug\t\t\t= debug,\n\t\t\t// clang-format on\n\t\t};\n\t\tcfg.card_label[0] = 0;\n\t\tif (card_label[i])\n\t\t\tsnprintf(cfg.card_label, sizeof(cfg.card_label), \"%s\",\n\t\t\t\t card_label[i]);\n\t\terr = v4l2_loopback_add(&cfg, 0);\n\t\tif (err) {\n\t\t\tfree_devices();\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tdprintk(\"module installed\\n\");\n\n\tprintk(KERN_INFO \"v4l2loopback driver version %d.%d.%d%s loaded\\n\",\n\t       // clang-format off\n\t       (V4L2LOOPBACK_VERSION_CODE >> 16) & 0xff,\n\t       (V4L2LOOPBACK_VERSION_CODE >>  8) & 0xff,\n\t       (V4L2LOOPBACK_VERSION_CODE      ) & 0xff,\n#ifdef SNAPSHOT_VERSION\n\t       \" (\" STRINGIFY2(SNAPSHOT_VERSION) \")\"\n#else\n\t       \"\"\n#endif\n\t       );\n\t// clang-format on\n\n\treturn 0;\nerror:\n\tmisc_deregister(&v4l2loopback_misc);\n\treturn err;\n}\n\n#ifdef MODULE\nstatic void v4l2loopback_cleanup_module(void)\n{\n\tMARK();\n\t/* unregister the device -> it deletes /dev/video* */\n\tfree_devices();\n\t/* and get rid of /dev/v4l2loopback */\n\tmisc_deregister(&v4l2loopback_misc);\n\tdprintk(\"module removed\\n\");\n}\n#endif\n\nMODULE_ALIAS_MISCDEV(MISC_DYNAMIC_MINOR);\n\nmodule_init(v4l2loopback_init_module);\nmodule_exit(v4l2loopback_cleanup_module);\n\n/*\n * fake usage of unused functions\n */\n#ifdef HAVE__V4L2_CTRLS\nstatic int vidioc_queryctrl(struct file *file, void *fh,\n\t\t\t    struct v4l2_queryctrl *q) __attribute__((unused));\nstatic int vidioc_g_ctrl(struct file *file, void *fh, struct v4l2_control *c)\n\t__attribute__((unused));\nstatic int vidioc_s_ctrl(struct file *file, void *fh, struct v4l2_control *c)\n\t__attribute__((unused));\n#endif /* HAVE__V4L2_CTRLS */\n"], "filenames": ["v4l2loopback.c"], "buggy_code_start_loc": [759], "buggy_code_end_loc": [2498], "fixing_code_start_loc": [759], "fixing_code_end_loc": [2498], "type": "CWE-134", "message": "Depending on the way the format strings in the card label are crafted it's possible to leak kernel stack memory. There is also the possibility for DoS due to the v4l2loopback kernel module crashing when providing the card label on request (reproduce e.g. with many %s modifiers in a row).", "other": {"cve": {"id": "CVE-2022-2652", "sourceIdentifier": "security@huntr.dev", "published": "2022-08-04T10:15:07.990", "lastModified": "2022-08-10T13:40:00.297", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Depending on the way the format strings in the card label are crafted it's possible to leak kernel stack memory. There is also the possibility for DoS due to the v4l2loopback kernel module crashing when providing the card label on request (reproduce e.g. with many %s modifiers in a row)."}, {"lang": "es", "value": "Dependiendo de la forma en que sean dise\u00f1adas las cadenas de formato en la etiqueta de la tarjeta, es posible filtrar la memoria de la pila del kernel. Tambi\u00e9n se presenta la posibilidad de DoS debido a que el m\u00f3dulo del kernel v4l2loopback es bloqueado cuando es proporcionada la etiqueta de la tarjeta a petici\u00f3n (es reproducido, por ejemplo, con muchos modificadores %s en una fila)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.5, "impactScore": 5.3}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-134"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:v4l2loopback_project:v4l2loopback:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.12.6", "matchCriteriaId": "80644B02-6794-437D-8E55-1F0BD2763E67"}]}]}], "references": [{"url": "https://github.com/umlaeute/v4l2loopback/commit/e4cd225557486c420f6a34411f98c575effd43dd", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/1b055da5-7a9e-4409-99d7-030280d242d5", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/umlaeute/v4l2loopback/commit/e4cd225557486c420f6a34411f98c575effd43dd"}}