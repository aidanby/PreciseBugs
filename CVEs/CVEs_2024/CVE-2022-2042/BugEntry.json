{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * spell.c: code for spell checking\n *\n * See spellfile.c for the Vim spell file format.\n *\n * The spell checking mechanism uses a tree (aka trie).  Each node in the tree\n * has a list of bytes that can appear (siblings).  For each byte there is a\n * pointer to the node with the byte that follows in the word (child).\n *\n * A NUL byte is used where the word may end.  The bytes are sorted, so that\n * binary searching can be used and the NUL bytes are at the start.  The\n * number of possible bytes is stored before the list of bytes.\n *\n * The tree uses two arrays: \"byts\" stores the characters, \"idxs\" stores\n * either the next index or flags.  The tree starts at index 0.  For example,\n * to lookup \"vi\" this sequence is followed:\n *\ti = 0\n *\tlen = byts[i]\n *\tn = where \"v\" appears in byts[i + 1] to byts[i + len]\n *\ti = idxs[n]\n *\tlen = byts[i]\n *\tn = where \"i\" appears in byts[i + 1] to byts[i + len]\n *\ti = idxs[n]\n *\tlen = byts[i]\n *\tfind that byts[i + 1] is 0, idxs[i + 1] has flags for \"vi\".\n *\n * There are two word trees: one with case-folded words and one with words in\n * original case.  The second one is only used for keep-case words and is\n * usually small.\n *\n * There is one additional tree for when not all prefixes are applied when\n * generating the .spl file.  This tree stores all the possible prefixes, as\n * if they were words.  At each word (prefix) end the prefix nr is stored, the\n * following word must support this prefix nr.  And the condition nr is\n * stored, used to lookup the condition that the word must match with.\n *\n * Thanks to Olaf Seibert for providing an example implementation of this tree\n * and the compression mechanism.\n * LZ trie ideas:\n *\thttp://www.irb.hr/hr/home/ristov/papers/RistovLZtrieRevision1.pdf\n * More papers: http://www-igm.univ-mlv.fr/~laporte/publi_en.html\n *\n * Matching involves checking the caps type: Onecap ALLCAP KeepCap.\n *\n * Why doesn't Vim use aspell/ispell/myspell/etc.?\n * See \":help develop-spell\".\n */\n\n#define IN_SPELL_C\n#include \"vim.h\"\n\n#if defined(FEAT_SPELL) || defined(PROTO)\n\n#ifndef UNIX\t\t// it's in os_unix.h for Unix\n# include <time.h>\t// for time_t\n#endif\n\n#define REGION_ALL 0xff\t\t// word valid in all regions\n\n// Result values.  Lower number is accepted over higher one.\n#define SP_BANNED\t(-1)\n#define SP_OK\t\t0\n#define SP_RARE\t\t1\n#define SP_LOCAL\t2\n#define SP_BAD\t\t3\n\n/*\n * Structure to store info for word matching.\n */\ntypedef struct matchinf_S\n{\n    langp_T\t*mi_lp;\t\t\t// info for language and region\n\n    // pointers to original text to be checked\n    char_u\t*mi_word;\t\t// start of word being checked\n    char_u\t*mi_end;\t\t// end of matching word so far\n    char_u\t*mi_fend;\t\t// next char to be added to mi_fword\n    char_u\t*mi_cend;\t\t// char after what was used for\n\t\t\t\t\t// mi_capflags\n\n    // case-folded text\n    char_u\tmi_fword[MAXWLEN + 1];\t// mi_word case-folded\n    int\t\tmi_fwordlen;\t\t// nr of valid bytes in mi_fword\n\n    // for when checking word after a prefix\n    int\t\tmi_prefarridx;\t\t// index in sl_pidxs with list of\n\t\t\t\t\t// affixID/condition\n    int\t\tmi_prefcnt;\t\t// number of entries at mi_prefarridx\n    int\t\tmi_prefixlen;\t\t// byte length of prefix\n    int\t\tmi_cprefixlen;\t\t// byte length of prefix in original\n\t\t\t\t\t// case\n\n    // for when checking a compound word\n    int\t\tmi_compoff;\t\t// start of following word offset\n    char_u\tmi_compflags[MAXWLEN];\t// flags for compound words used\n    int\t\tmi_complen;\t\t// nr of compound words used\n    int\t\tmi_compextra;\t\t// nr of COMPOUNDROOT words\n\n    // others\n    int\t\tmi_result;\t\t// result so far: SP_BAD, SP_OK, etc.\n    int\t\tmi_capflags;\t\t// WF_ONECAP WF_ALLCAP WF_KEEPCAP\n    win_T\t*mi_win;\t\t// buffer being checked\n\n    // for NOBREAK\n    int\t\tmi_result2;\t\t// \"mi_resul\" without following word\n    char_u\t*mi_end2;\t\t// \"mi_end\" without following word\n} matchinf_T;\n\n\nstatic int spell_mb_isword_class(int cl, win_T *wp);\n\n// mode values for find_word\n#define FIND_FOLDWORD\t    0\t// find word case-folded\n#define FIND_KEEPWORD\t    1\t// find keep-case word\n#define FIND_PREFIX\t    2\t// find word after prefix\n#define FIND_COMPOUND\t    3\t// find case-folded compound word\n#define FIND_KEEPCOMPOUND   4\t// find keep-case compound word\n\nstatic void find_word(matchinf_T *mip, int mode);\nstatic void find_prefix(matchinf_T *mip, int mode);\nstatic int fold_more(matchinf_T *mip);\nstatic void spell_load_cb(char_u *fname, void *cookie);\nstatic int count_syllables(slang_T *slang, char_u *word);\nstatic void clear_midword(win_T *buf);\nstatic void use_midword(slang_T *lp, win_T *buf);\nstatic int find_region(char_u *rp, char_u *region);\nstatic void spell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res);\nstatic void spell_soundfold_sal(slang_T *slang, char_u *inword, char_u *res);\nstatic void spell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res);\nstatic void dump_word(slang_T *slang, char_u *word, char_u *pat, int *dir, int round, int flags, linenr_T lnum);\nstatic linenr_T dump_prefixes(slang_T *slang, char_u *word, char_u *pat, int *dir, int round, int flags, linenr_T startlnum);\n\n/*\n * Main spell-checking function.\n * \"ptr\" points to a character that could be the start of a word.\n * \"*attrp\" is set to the highlight index for a badly spelled word.  For a\n * non-word or when it's OK it remains unchanged.\n * This must only be called when 'spelllang' is not empty.\n *\n * \"capcol\" is used to check for a Capitalised word after the end of a\n * sentence.  If it's zero then perform the check.  Return the column where to\n * check next, or -1 when no sentence end was found.  If it's NULL then don't\n * worry.\n *\n * Returns the length of the word in bytes, also when it's OK, so that the\n * caller can skip over the word.\n */\n    int\nspell_check(\n    win_T\t*wp,\t\t// current window\n    char_u\t*ptr,\n    hlf_T\t*attrp,\n    int\t\t*capcol,\t// column to check for Capital\n    int\t\tdocount)\t// count good words\n{\n    matchinf_T\tmi;\t\t// Most things are put in \"mi\" so that it can\n\t\t\t\t// be passed to functions quickly.\n    int\t\tnrlen = 0;\t// found a number first\n    int\t\tc;\n    int\t\twrongcaplen = 0;\n    int\t\tlpi;\n    int\t\tcount_word = docount;\n    int\t\tuse_camel_case = *wp->w_s->b_p_spo != NUL;\n    int\t\tcamel_case = 0;\n\n    // A word never starts at a space or a control character.  Return quickly\n    // then, skipping over the character.\n    if (*ptr <= ' ')\n\treturn 1;\n\n    // Return here when loading language files failed.\n    if (wp->w_s->b_langp.ga_len == 0)\n\treturn 1;\n\n    CLEAR_FIELD(mi);\n\n    // A number is always OK.  Also skip hexadecimal numbers 0xFF99 and\n    // 0X99FF.  But always do check spelling to find \"3GPP\" and \"11\n    // julifeest\".\n    if (*ptr >= '0' && *ptr <= '9')\n    {\n\tif (*ptr == '0' && (ptr[1] == 'b' || ptr[1] == 'B'))\n\t    mi.mi_end = skipbin(ptr + 2);\n\telse if (*ptr == '0' && (ptr[1] == 'x' || ptr[1] == 'X'))\n\t    mi.mi_end = skiphex(ptr + 2);\n\telse\n\t    mi.mi_end = skipdigits(ptr);\n\tnrlen = (int)(mi.mi_end - ptr);\n    }\n\n    // Find the normal end of the word (until the next non-word character).\n    mi.mi_word = ptr;\n    mi.mi_fend = ptr;\n    if (spell_iswordp(mi.mi_fend, wp))\n    {\n\tint prev_upper;\n\tint this_upper = FALSE;  // init for gcc\n\n\tif (use_camel_case)\n\t{\n\t    c = PTR2CHAR(mi.mi_fend);\n\t    this_upper = SPELL_ISUPPER(c);\n\t}\n\n\tdo\n\t{\n\t    MB_PTR_ADV(mi.mi_fend);\n\t    if (use_camel_case)\n\t    {\n\t\tprev_upper = this_upper;\n\t\tc = PTR2CHAR(mi.mi_fend);\n\t\tthis_upper = SPELL_ISUPPER(c);\n\t\tcamel_case = !prev_upper && this_upper;\n\t    }\n\t} while (*mi.mi_fend != NUL && spell_iswordp(mi.mi_fend, wp)\n\t\t\t\t\t\t\t       && !camel_case);\n\n\tif (capcol != NULL && *capcol == 0 && wp->w_s->b_cap_prog != NULL)\n\t{\n\t    // Check word starting with capital letter.\n\t    c = PTR2CHAR(ptr);\n\t    if (!SPELL_ISUPPER(c))\n\t\twrongcaplen = (int)(mi.mi_fend - ptr);\n\t}\n    }\n    if (capcol != NULL)\n\t*capcol = -1;\n\n    // We always use the characters up to the next non-word character,\n    // also for bad words.\n    mi.mi_end = mi.mi_fend;\n\n    // Check caps type later.\n    mi.mi_capflags = 0;\n    mi.mi_cend = NULL;\n    mi.mi_win = wp;\n\n    // case-fold the word with one non-word character, so that we can check\n    // for the word end.\n    if (*mi.mi_fend != NUL)\n\tMB_PTR_ADV(mi.mi_fend);\n\n    (void)spell_casefold(wp, ptr, (int)(mi.mi_fend - ptr), mi.mi_fword,\n\t\t\t\t\t\t\t     MAXWLEN + 1);\n    mi.mi_fwordlen = (int)STRLEN(mi.mi_fword);\n\n    if (camel_case && mi.mi_fwordlen > 0)\n\t// Introduce a fake word end space into the folded word.\n\tmi.mi_fword[mi.mi_fwordlen - 1] = ' ';\n\n    // The word is bad unless we recognize it.\n    mi.mi_result = SP_BAD;\n    mi.mi_result2 = SP_BAD;\n\n    /*\n     * Loop over the languages specified in 'spelllang'.\n     * We check them all, because a word may be matched longer in another\n     * language.\n     */\n    for (lpi = 0; lpi < wp->w_s->b_langp.ga_len; ++lpi)\n    {\n\tmi.mi_lp = LANGP_ENTRY(wp->w_s->b_langp, lpi);\n\n\t// If reloading fails the language is still in the list but everything\n\t// has been cleared.\n\tif (mi.mi_lp->lp_slang->sl_fidxs == NULL)\n\t    continue;\n\n\t// Check for a matching word in case-folded words.\n\tfind_word(&mi, FIND_FOLDWORD);\n\n\t// Check for a matching word in keep-case words.\n\tfind_word(&mi, FIND_KEEPWORD);\n\n\t// Check for matching prefixes.\n\tfind_prefix(&mi, FIND_FOLDWORD);\n\n\t// For a NOBREAK language, may want to use a word without a following\n\t// word as a backup.\n\tif (mi.mi_lp->lp_slang->sl_nobreak && mi.mi_result == SP_BAD\n\t\t\t\t\t\t   && mi.mi_result2 != SP_BAD)\n\t{\n\t    mi.mi_result = mi.mi_result2;\n\t    mi.mi_end = mi.mi_end2;\n\t}\n\n\t// Count the word in the first language where it's found to be OK.\n\tif (count_word && mi.mi_result == SP_OK)\n\t{\n\t    count_common_word(mi.mi_lp->lp_slang, ptr,\n\t\t\t\t\t\t   (int)(mi.mi_end - ptr), 1);\n\t    count_word = FALSE;\n\t}\n    }\n\n    if (mi.mi_result != SP_OK)\n    {\n\t// If we found a number skip over it.  Allows for \"42nd\".  Do flag\n\t// rare and local words, e.g., \"3GPP\".\n\tif (nrlen > 0)\n\t{\n\t    if (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED)\n\t\treturn nrlen;\n\t}\n\n\t// When we are at a non-word character there is no error, just\n\t// skip over the character (try looking for a word after it).\n\telse if (!spell_iswordp_nmw(ptr, wp))\n\t{\n\t    if (capcol != NULL && wp->w_s->b_cap_prog != NULL)\n\t    {\n\t\tregmatch_T\tregmatch;\n\t\tint\t\tr;\n\n\t\t// Check for end of sentence.\n\t\tregmatch.regprog = wp->w_s->b_cap_prog;\n\t\tregmatch.rm_ic = FALSE;\n\t\tr = vim_regexec(&regmatch, ptr, 0);\n\t\twp->w_s->b_cap_prog = regmatch.regprog;\n\t\tif (r)\n\t\t    *capcol = (int)(regmatch.endp[0] - ptr);\n\t    }\n\n\t    if (has_mbyte)\n\t\treturn (*mb_ptr2len)(ptr);\n\t    return 1;\n\t}\n\telse if (mi.mi_end == ptr)\n\t    // Always include at least one character.  Required for when there\n\t    // is a mixup in \"midword\".\n\t    MB_PTR_ADV(mi.mi_end);\n\telse if (mi.mi_result == SP_BAD\n\t\t&& LANGP_ENTRY(wp->w_s->b_langp, 0)->lp_slang->sl_nobreak)\n\t{\n\t    char_u\t*p, *fp;\n\t    int\t\tsave_result = mi.mi_result;\n\n\t    // First language in 'spelllang' is NOBREAK.  Find first position\n\t    // at which any word would be valid.\n\t    mi.mi_lp = LANGP_ENTRY(wp->w_s->b_langp, 0);\n\t    if (mi.mi_lp->lp_slang->sl_fidxs != NULL)\n\t    {\n\t\tp = mi.mi_word;\n\t\tfp = mi.mi_fword;\n\t\tfor (;;)\n\t\t{\n\t\t    MB_PTR_ADV(p);\n\t\t    MB_PTR_ADV(fp);\n\t\t    if (p >= mi.mi_end)\n\t\t\tbreak;\n\t\t    mi.mi_compoff = (int)(fp - mi.mi_fword);\n\t\t    find_word(&mi, FIND_COMPOUND);\n\t\t    if (mi.mi_result != SP_BAD)\n\t\t    {\n\t\t\tmi.mi_end = p;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tmi.mi_result = save_result;\n\t    }\n\t}\n\n\tif (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED)\n\t    *attrp = HLF_SPB;\n\telse if (mi.mi_result == SP_RARE)\n\t    *attrp = HLF_SPR;\n\telse\n\t    *attrp = HLF_SPL;\n    }\n\n    if (wrongcaplen > 0 && (mi.mi_result == SP_OK || mi.mi_result == SP_RARE))\n    {\n\t// Report SpellCap only when the word isn't badly spelled.\n\t*attrp = HLF_SPC;\n\treturn wrongcaplen;\n    }\n\n    return (int)(mi.mi_end - ptr);\n}\n\n/*\n * Check if the word at \"mip->mi_word\" is in the tree.\n * When \"mode\" is FIND_FOLDWORD check in fold-case word tree.\n * When \"mode\" is FIND_KEEPWORD check in keep-case word tree.\n * When \"mode\" is FIND_PREFIX check for word after prefix in fold-case word\n * tree.\n *\n * For a match mip->mi_result is updated.\n */\n    static void\nfind_word(matchinf_T *mip, int mode)\n{\n    idx_T\tarridx = 0;\n    int\t\tendlen[MAXWLEN];    // length at possible word endings\n    idx_T\tendidx[MAXWLEN];    // possible word endings\n    int\t\tendidxcnt = 0;\n    int\t\tlen;\n    int\t\twlen = 0;\n    int\t\tflen;\n    int\t\tc;\n    char_u\t*ptr;\n    idx_T\tlo, hi, m;\n    char_u\t*s;\n    char_u\t*p;\n    int\t\tres = SP_BAD;\n    slang_T\t*slang = mip->mi_lp->lp_slang;\n    unsigned\tflags;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\tword_ends;\n    int\t\tprefix_found;\n    int\t\tnobreak_result;\n\n    if (mode == FIND_KEEPWORD || mode == FIND_KEEPCOMPOUND)\n    {\n\t// Check for word with matching case in keep-case tree.\n\tptr = mip->mi_word;\n\tflen = 9999;\t\t    // no case folding, always enough bytes\n\tbyts = slang->sl_kbyts;\n\tidxs = slang->sl_kidxs;\n\n\tif (mode == FIND_KEEPCOMPOUND)\n\t    // Skip over the previously found word(s).\n\t    wlen += mip->mi_compoff;\n    }\n    else\n    {\n\t// Check for case-folded in case-folded tree.\n\tptr = mip->mi_fword;\n\tflen = mip->mi_fwordlen;    // available case-folded bytes\n\tbyts = slang->sl_fbyts;\n\tidxs = slang->sl_fidxs;\n\n\tif (mode == FIND_PREFIX)\n\t{\n\t    // Skip over the prefix.\n\t    wlen = mip->mi_prefixlen;\n\t    flen -= mip->mi_prefixlen;\n\t}\n\telse if (mode == FIND_COMPOUND)\n\t{\n\t    // Skip over the previously found word(s).\n\t    wlen = mip->mi_compoff;\n\t    flen -= mip->mi_compoff;\n\t}\n\n    }\n\n    if (byts == NULL)\n\treturn;\t\t\t// array is empty\n\n    /*\n     * Repeat advancing in the tree until:\n     * - there is a byte that doesn't match,\n     * - we reach the end of the tree,\n     * - or we reach the end of the line.\n     */\n    for (;;)\n    {\n\tif (flen <= 0 && *mip->mi_fend != NUL)\n\t    flen = fold_more(mip);\n\n\tlen = byts[arridx++];\n\n\t// If the first possible byte is a zero the word could end here.\n\t// Remember this index, we first check for the longest word.\n\tif (byts[arridx] == 0)\n\t{\n\t    if (endidxcnt == MAXWLEN)\n\t    {\n\t\t// Must be a corrupted spell file.\n\t\temsg(_(e_format_error_in_spell_file));\n\t\treturn;\n\t    }\n\t    endlen[endidxcnt] = wlen;\n\t    endidx[endidxcnt++] = arridx++;\n\t    --len;\n\n\t    // Skip over the zeros, there can be several flag/region\n\t    // combinations.\n\t    while (len > 0 && byts[arridx] == 0)\n\t    {\n\t\t++arridx;\n\t\t--len;\n\t    }\n\t    if (len == 0)\n\t\tbreak;\t    // no children, word must end here\n\t}\n\n\t// Stop looking at end of the line.\n\tif (ptr[wlen] == NUL)\n\t    break;\n\n\t// Perform a binary search in the list of accepted bytes.\n\tc = ptr[wlen];\n\tif (c == TAB)\t    // <Tab> is handled like <Space>\n\t    c = ' ';\n\tlo = arridx;\n\thi = arridx + len - 1;\n\twhile (lo < hi)\n\t{\n\t    m = (lo + hi) / 2;\n\t    if (byts[m] > c)\n\t\thi = m - 1;\n\t    else if (byts[m] < c)\n\t\tlo = m + 1;\n\t    else\n\t    {\n\t\tlo = hi = m;\n\t\tbreak;\n\t    }\n\t}\n\n\t// Stop if there is no matching byte.\n\tif (hi < lo || byts[lo] != c)\n\t    break;\n\n\t// Continue at the child (if there is one).\n\tarridx = idxs[lo];\n\t++wlen;\n\t--flen;\n\n\t// One space in the good word may stand for several spaces in the\n\t// checked word.\n\tif (c == ' ')\n\t{\n\t    for (;;)\n\t    {\n\t\tif (flen <= 0 && *mip->mi_fend != NUL)\n\t\t    flen = fold_more(mip);\n\t\tif (ptr[wlen] != ' ' && ptr[wlen] != TAB)\n\t\t    break;\n\t\t++wlen;\n\t\t--flen;\n\t    }\n\t}\n    }\n\n    /*\n     * Verify that one of the possible endings is valid.  Try the longest\n     * first.\n     */\n    while (endidxcnt > 0)\n    {\n\t--endidxcnt;\n\tarridx = endidx[endidxcnt];\n\twlen = endlen[endidxcnt];\n\n\tif ((*mb_head_off)(ptr, ptr + wlen) > 0)\n\t    continue;\t    // not at first byte of character\n\tif (spell_iswordp(ptr + wlen, mip->mi_win))\n\t{\n\t    if (slang->sl_compprog == NULL && !slang->sl_nobreak)\n\t\tcontinue;\t    // next char is a word character\n\t    word_ends = FALSE;\n\t}\n\telse\n\t    word_ends = TRUE;\n\t// The prefix flag is before compound flags.  Once a valid prefix flag\n\t// has been found we try compound flags.\n\tprefix_found = FALSE;\n\n\tif (mode != FIND_KEEPWORD && has_mbyte)\n\t{\n\t    // Compute byte length in original word, length may change\n\t    // when folding case.  This can be slow, take a shortcut when the\n\t    // case-folded word is equal to the keep-case word.\n\t    p = mip->mi_word;\n\t    if (STRNCMP(ptr, p, wlen) != 0)\n\t    {\n\t\tfor (s = ptr; s < ptr + wlen; MB_PTR_ADV(s))\n\t\t    MB_PTR_ADV(p);\n\t\twlen = (int)(p - mip->mi_word);\n\t    }\n\t}\n\n\t// Check flags and region.  For FIND_PREFIX check the condition and\n\t// prefix ID.\n\t// Repeat this if there are more flags/region alternatives until there\n\t// is a match.\n\tres = SP_BAD;\n\tfor (len = byts[arridx - 1]; len > 0 && byts[arridx] == 0;\n\t\t\t\t\t\t\t      --len, ++arridx)\n\t{\n\t    flags = idxs[arridx];\n\n\t    // For the fold-case tree check that the case of the checked word\n\t    // matches with what the word in the tree requires.\n\t    // For keep-case tree the case is always right.  For prefixes we\n\t    // don't bother to check.\n\t    if (mode == FIND_FOLDWORD)\n\t    {\n\t\tif (mip->mi_cend != mip->mi_word + wlen)\n\t\t{\n\t\t    // mi_capflags was set for a different word length, need\n\t\t    // to do it again.\n\t\t    mip->mi_cend = mip->mi_word + wlen;\n\t\t    mip->mi_capflags = captype(mip->mi_word, mip->mi_cend);\n\t\t}\n\n\t\tif (mip->mi_capflags == WF_KEEPCAP\n\t\t\t\t|| !spell_valid_case(mip->mi_capflags, flags))\n\t\t    continue;\n\t    }\n\n\t    // When mode is FIND_PREFIX the word must support the prefix:\n\t    // check the prefix ID and the condition.  Do that for the list at\n\t    // mip->mi_prefarridx that find_prefix() filled.\n\t    else if (mode == FIND_PREFIX && !prefix_found)\n\t    {\n\t\tc = valid_word_prefix(mip->mi_prefcnt, mip->mi_prefarridx,\n\t\t\t\t    flags,\n\t\t\t\t    mip->mi_word + mip->mi_cprefixlen, slang,\n\t\t\t\t    FALSE);\n\t\tif (c == 0)\n\t\t    continue;\n\n\t\t// Use the WF_RARE flag for a rare prefix.\n\t\tif (c & WF_RAREPFX)\n\t\t    flags |= WF_RARE;\n\t\tprefix_found = TRUE;\n\t    }\n\n\t    if (slang->sl_nobreak)\n\t    {\n\t\tif ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND)\n\t\t\t&& (flags & WF_BANNED) == 0)\n\t\t{\n\t\t    // NOBREAK: found a valid following word.  That's all we\n\t\t    // need to know, so return.\n\t\t    mip->mi_result = SP_OK;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    else if ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND\n\t\t\t\t\t\t\t\t|| !word_ends))\n\t    {\n\t\t// If there is no compound flag or the word is shorter than\n\t\t// COMPOUNDMIN reject it quickly.\n\t\t// Makes you wonder why someone puts a compound flag on a word\n\t\t// that's too short...  Myspell compatibility requires this\n\t\t// anyway.\n\t\tif (((unsigned)flags >> 24) == 0\n\t\t\t     || wlen - mip->mi_compoff < slang->sl_compminlen)\n\t\t    continue;\n\t\t// For multi-byte chars check character length against\n\t\t// COMPOUNDMIN.\n\t\tif (has_mbyte\n\t\t\t&& slang->sl_compminlen > 0\n\t\t\t&& mb_charlen_len(mip->mi_word + mip->mi_compoff,\n\t\t\t\twlen - mip->mi_compoff) < slang->sl_compminlen)\n\t\t\tcontinue;\n\n\t\t// Limit the number of compound words to COMPOUNDWORDMAX if no\n\t\t// maximum for syllables is specified.\n\t\tif (!word_ends && mip->mi_complen + mip->mi_compextra + 2\n\t\t\t\t\t\t\t   > slang->sl_compmax\n\t\t\t\t\t   && slang->sl_compsylmax == MAXWLEN)\n\t\t    continue;\n\n\t\t// Don't allow compounding on a side where an affix was added,\n\t\t// unless COMPOUNDPERMITFLAG was used.\n\t\tif (mip->mi_complen > 0 && (flags & WF_NOCOMPBEF))\n\t\t    continue;\n\t\tif (!word_ends && (flags & WF_NOCOMPAFT))\n\t\t    continue;\n\n\t\t// Quickly check if compounding is possible with this flag.\n\t\tif (!byte_in_str(mip->mi_complen == 0\n\t\t\t\t\t? slang->sl_compstartflags\n\t\t\t\t\t: slang->sl_compallflags,\n\t\t\t\t\t    ((unsigned)flags >> 24)))\n\t\t    continue;\n\n\t\t// If there is a match with a CHECKCOMPOUNDPATTERN rule\n\t\t// discard the compound word.\n\t\tif (match_checkcompoundpattern(ptr, wlen, &slang->sl_comppat))\n\t\t    continue;\n\n\t\tif (mode == FIND_COMPOUND)\n\t\t{\n\t\t    int\t    capflags;\n\n\t\t    // Need to check the caps type of the appended compound\n\t\t    // word.\n\t\t    if (has_mbyte && STRNCMP(ptr, mip->mi_word,\n\t\t\t\t\t\t\tmip->mi_compoff) != 0)\n\t\t    {\n\t\t\t// case folding may have changed the length\n\t\t\tp = mip->mi_word;\n\t\t\tfor (s = ptr; s < ptr + mip->mi_compoff; MB_PTR_ADV(s))\n\t\t\t    MB_PTR_ADV(p);\n\t\t    }\n\t\t    else\n\t\t\tp = mip->mi_word + mip->mi_compoff;\n\t\t    capflags = captype(p, mip->mi_word + wlen);\n\t\t    if (capflags == WF_KEEPCAP || (capflags == WF_ALLCAP\n\t\t\t\t\t\t && (flags & WF_FIXCAP) != 0))\n\t\t\tcontinue;\n\n\t\t    if (capflags != WF_ALLCAP)\n\t\t    {\n\t\t\t// When the character before the word is a word\n\t\t\t// character we do not accept a Onecap word.  We do\n\t\t\t// accept a no-caps word, even when the dictionary\n\t\t\t// word specifies ONECAP.\n\t\t\tMB_PTR_BACK(mip->mi_word, p);\n\t\t\tif (spell_iswordp_nmw(p, mip->mi_win)\n\t\t\t\t? capflags == WF_ONECAP\n\t\t\t\t: (flags & WF_ONECAP) != 0\n\t\t\t\t\t\t     && capflags != WF_ONECAP)\n\t\t\t    continue;\n\t\t    }\n\t\t}\n\n\t\t// If the word ends the sequence of compound flags of the\n\t\t// words must match with one of the COMPOUNDRULE items and\n\t\t// the number of syllables must not be too large.\n\t\tmip->mi_compflags[mip->mi_complen] = ((unsigned)flags >> 24);\n\t\tmip->mi_compflags[mip->mi_complen + 1] = NUL;\n\t\tif (word_ends)\n\t\t{\n\t\t    char_u\tfword[MAXWLEN];\n\n\t\t    if (slang->sl_compsylmax < MAXWLEN)\n\t\t    {\n\t\t\t// \"fword\" is only needed for checking syllables.\n\t\t\tif (ptr == mip->mi_word)\n\t\t\t    (void)spell_casefold(mip->mi_win,\n\t\t\t\t\t\t    ptr, wlen, fword, MAXWLEN);\n\t\t\telse\n\t\t\t    vim_strncpy(fword, ptr, endlen[endidxcnt]);\n\t\t    }\n\t\t    if (!can_compound(slang, fword, mip->mi_compflags))\n\t\t\tcontinue;\n\t\t}\n\t\telse if (slang->sl_comprules != NULL\n\t\t\t     && !match_compoundrule(slang, mip->mi_compflags))\n\t\t    // The compound flags collected so far do not match any\n\t\t    // COMPOUNDRULE, discard the compounded word.\n\t\t    continue;\n\t    }\n\n\t    // Check NEEDCOMPOUND: can't use word without compounding.\n\t    else if (flags & WF_NEEDCOMP)\n\t\tcontinue;\n\n\t    nobreak_result = SP_OK;\n\n\t    if (!word_ends)\n\t    {\n\t\tint\tsave_result = mip->mi_result;\n\t\tchar_u\t*save_end = mip->mi_end;\n\t\tlangp_T\t*save_lp = mip->mi_lp;\n\t\tint\tlpi;\n\n\t\t// Check that a valid word follows.  If there is one and we\n\t\t// are compounding, it will set \"mi_result\", thus we are\n\t\t// always finished here.  For NOBREAK we only check that a\n\t\t// valid word follows.\n\t\t// Recursive!\n\t\tif (slang->sl_nobreak)\n\t\t    mip->mi_result = SP_BAD;\n\n\t\t// Find following word in case-folded tree.\n\t\tmip->mi_compoff = endlen[endidxcnt];\n\t\tif (has_mbyte && mode == FIND_KEEPWORD)\n\t\t{\n\t\t    // Compute byte length in case-folded word from \"wlen\":\n\t\t    // byte length in keep-case word.  Length may change when\n\t\t    // folding case.  This can be slow, take a shortcut when\n\t\t    // the case-folded word is equal to the keep-case word.\n\t\t    p = mip->mi_fword;\n\t\t    if (STRNCMP(ptr, p, wlen) != 0)\n\t\t    {\n\t\t\tfor (s = ptr; s < ptr + wlen; MB_PTR_ADV(s))\n\t\t\t    MB_PTR_ADV(p);\n\t\t\tmip->mi_compoff = (int)(p - mip->mi_fword);\n\t\t    }\n\t\t}\n#if 0 // Disabled, see below\n\t\tc = mip->mi_compoff;\n#endif\n\t\t++mip->mi_complen;\n\t\tif (flags & WF_COMPROOT)\n\t\t    ++mip->mi_compextra;\n\n\t\t// For NOBREAK we need to try all NOBREAK languages, at least\n\t\t// to find the \".add\" file(s).\n\t\tfor (lpi = 0; lpi < mip->mi_win->w_s->b_langp.ga_len; ++lpi)\n\t\t{\n\t\t    if (slang->sl_nobreak)\n\t\t    {\n\t\t\tmip->mi_lp = LANGP_ENTRY(mip->mi_win->w_s->b_langp, lpi);\n\t\t\tif (mip->mi_lp->lp_slang->sl_fidxs == NULL\n\t\t\t\t\t || !mip->mi_lp->lp_slang->sl_nobreak)\n\t\t\t    continue;\n\t\t    }\n\n\t\t    find_word(mip, FIND_COMPOUND);\n\n\t\t    // When NOBREAK any word that matches is OK.  Otherwise we\n\t\t    // need to find the longest match, thus try with keep-case\n\t\t    // and prefix too.\n\t\t    if (!slang->sl_nobreak || mip->mi_result == SP_BAD)\n\t\t    {\n\t\t\t// Find following word in keep-case tree.\n\t\t\tmip->mi_compoff = wlen;\n\t\t\tfind_word(mip, FIND_KEEPCOMPOUND);\n\n#if 0\t    // Disabled, a prefix must not appear halfway a compound word,\n\t    // unless the COMPOUNDPERMITFLAG is used and then it can't be a\n\t    // postponed prefix.\n\t\t\tif (!slang->sl_nobreak || mip->mi_result == SP_BAD)\n\t\t\t{\n\t\t\t    // Check for following word with prefix.\n\t\t\t    mip->mi_compoff = c;\n\t\t\t    find_prefix(mip, FIND_COMPOUND);\n\t\t\t}\n#endif\n\t\t    }\n\n\t\t    if (!slang->sl_nobreak)\n\t\t\tbreak;\n\t\t}\n\t\t--mip->mi_complen;\n\t\tif (flags & WF_COMPROOT)\n\t\t    --mip->mi_compextra;\n\t\tmip->mi_lp = save_lp;\n\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    nobreak_result = mip->mi_result;\n\t\t    mip->mi_result = save_result;\n\t\t    mip->mi_end = save_end;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (mip->mi_result == SP_OK)\n\t\t\tbreak;\n\t\t    continue;\n\t\t}\n\t    }\n\n\t    if (flags & WF_BANNED)\n\t\tres = SP_BANNED;\n\t    else if (flags & WF_REGION)\n\t    {\n\t\t// Check region.\n\t\tif ((mip->mi_lp->lp_region & (flags >> 16)) != 0)\n\t\t    res = SP_OK;\n\t\telse\n\t\t    res = SP_LOCAL;\n\t    }\n\t    else if (flags & WF_RARE)\n\t\tres = SP_RARE;\n\t    else\n\t\tres = SP_OK;\n\n\t    // Always use the longest match and the best result.  For NOBREAK\n\t    // we separately keep the longest match without a following good\n\t    // word as a fall-back.\n\t    if (nobreak_result == SP_BAD)\n\t    {\n\t\tif (mip->mi_result2 > res)\n\t\t{\n\t\t    mip->mi_result2 = res;\n\t\t    mip->mi_end2 = mip->mi_word + wlen;\n\t\t}\n\t\telse if (mip->mi_result2 == res\n\t\t\t\t\t&& mip->mi_end2 < mip->mi_word + wlen)\n\t\t    mip->mi_end2 = mip->mi_word + wlen;\n\t    }\n\t    else if (mip->mi_result > res)\n\t    {\n\t\tmip->mi_result = res;\n\t\tmip->mi_end = mip->mi_word + wlen;\n\t    }\n\t    else if (mip->mi_result == res && mip->mi_end < mip->mi_word + wlen)\n\t\tmip->mi_end = mip->mi_word + wlen;\n\n\t    if (mip->mi_result == SP_OK)\n\t\tbreak;\n\t}\n\n\tif (mip->mi_result == SP_OK)\n\t    break;\n    }\n}\n\n/*\n * Return TRUE if there is a match between the word ptr[wlen] and\n * CHECKCOMPOUNDPATTERN rules, assuming that we will concatenate with another\n * word.\n * A match means that the first part of CHECKCOMPOUNDPATTERN matches at the\n * end of ptr[wlen] and the second part matches after it.\n */\n    int\nmatch_checkcompoundpattern(\n    char_u\t*ptr,\n    int\t\twlen,\n    garray_T\t*gap)  // &sl_comppat\n{\n    int\t\ti;\n    char_u\t*p;\n    int\t\tlen;\n\n    for (i = 0; i + 1 < gap->ga_len; i += 2)\n    {\n\tp = ((char_u **)gap->ga_data)[i + 1];\n\tif (STRNCMP(ptr + wlen, p, STRLEN(p)) == 0)\n\t{\n\t    // Second part matches at start of following compound word, now\n\t    // check if first part matches at end of previous word.\n\t    p = ((char_u **)gap->ga_data)[i];\n\t    len = (int)STRLEN(p);\n\t    if (len <= wlen && STRNCMP(ptr + wlen - len, p, len) == 0)\n\t\treturn TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if \"flags\" is a valid sequence of compound flags and \"word\"\n * does not have too many syllables.\n */\n    int\ncan_compound(slang_T *slang, char_u *word, char_u *flags)\n{\n    char_u\tuflags[MAXWLEN * 2];\n    int\t\ti;\n    char_u\t*p;\n\n    if (slang->sl_compprog == NULL)\n\treturn FALSE;\n    if (enc_utf8)\n    {\n\t// Need to convert the single byte flags to utf8 characters.\n\tp = uflags;\n\tfor (i = 0; flags[i] != NUL; ++i)\n\t    p += utf_char2bytes(flags[i], p);\n\t*p = NUL;\n\tp = uflags;\n    }\n    else\n\tp = flags;\n    if (!vim_regexec_prog(&slang->sl_compprog, FALSE, p, 0))\n\treturn FALSE;\n\n    // Count the number of syllables.  This may be slow, do it last.  If there\n    // are too many syllables AND the number of compound words is above\n    // COMPOUNDWORDMAX then compounding is not allowed.\n    if (slang->sl_compsylmax < MAXWLEN\n\t\t       && count_syllables(slang, word) > slang->sl_compsylmax)\n\treturn (int)STRLEN(flags) < slang->sl_compmax;\n    return TRUE;\n}\n\n/*\n * Return TRUE if the compound flags in compflags[] match the start of any\n * compound rule.  This is used to stop trying a compound if the flags\n * collected so far can't possibly match any compound rule.\n * Caller must check that slang->sl_comprules is not NULL.\n */\n    int\nmatch_compoundrule(slang_T *slang, char_u *compflags)\n{\n    char_u\t*p;\n    int\t\ti;\n    int\t\tc;\n\n    // loop over all the COMPOUNDRULE entries\n    for (p = slang->sl_comprules; *p != NUL; ++p)\n    {\n\t// loop over the flags in the compound word we have made, match\n\t// them against the current rule entry\n\tfor (i = 0; ; ++i)\n\t{\n\t    c = compflags[i];\n\t    if (c == NUL)\n\t\t// found a rule that matches for the flags we have so far\n\t\treturn TRUE;\n\t    if (*p == '/' || *p == NUL)\n\t\tbreak;  // end of rule, it's too short\n\t    if (*p == '[')\n\t    {\n\t\tint match = FALSE;\n\n\t\t// compare against all the flags in []\n\t\t++p;\n\t\twhile (*p != ']' && *p != NUL)\n\t\t    if (*p++ == c)\n\t\t\tmatch = TRUE;\n\t\tif (!match)\n\t\t    break;  // none matches\n\t    }\n\t    else if (*p != c)\n\t\tbreak;  // flag of word doesn't match flag in pattern\n\t    ++p;\n\t}\n\n\t// Skip to the next \"/\", where the next pattern starts.\n\tp = vim_strchr(p, '/');\n\tif (p == NULL)\n\t    break;\n    }\n\n    // Checked all the rules and none of them match the flags, so there\n    // can't possibly be a compound starting with these flags.\n    return FALSE;\n}\n\n/*\n * Return non-zero if the prefix indicated by \"arridx\" matches with the prefix\n * ID in \"flags\" for the word \"word\".\n * The WF_RAREPFX flag is included in the return value for a rare prefix.\n */\n    int\nvalid_word_prefix(\n    int\t\ttotprefcnt,\t// nr of prefix IDs\n    int\t\tarridx,\t\t// idx in sl_pidxs[]\n    int\t\tflags,\n    char_u\t*word,\n    slang_T\t*slang,\n    int\t\tcond_req)\t// only use prefixes with a condition\n{\n    int\t\tprefcnt;\n    int\t\tpidx;\n    regprog_T\t**rp;\n    int\t\tprefid;\n\n    prefid = (unsigned)flags >> 24;\n    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)\n    {\n\tpidx = slang->sl_pidxs[arridx + prefcnt];\n\n\t// Check the prefix ID.\n\tif (prefid != (pidx & 0xff))\n\t    continue;\n\n\t// Check if the prefix doesn't combine and the word already has a\n\t// suffix.\n\tif ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))\n\t    continue;\n\n\t// Check the condition, if there is one.  The condition index is\n\t// stored in the two bytes above the prefix ID byte.\n\trp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];\n\tif (*rp != NULL)\n\t{\n\t    if (!vim_regexec_prog(rp, FALSE, word, 0))\n\t\tcontinue;\n\t}\n\telse if (cond_req)\n\t    continue;\n\n\t// It's a match!  Return the WF_ flags.\n\treturn pidx;\n    }\n    return 0;\n}\n\n/*\n * Check if the word at \"mip->mi_word\" has a matching prefix.\n * If it does, then check the following word.\n *\n * If \"mode\" is \"FIND_COMPOUND\" then do the same after another word, find a\n * prefix in a compound word.\n *\n * For a match mip->mi_result is updated.\n */\n    static void\nfind_prefix(matchinf_T *mip, int mode)\n{\n    idx_T\tarridx = 0;\n    int\t\tlen;\n    int\t\twlen = 0;\n    int\t\tflen;\n    int\t\tc;\n    char_u\t*ptr;\n    idx_T\tlo, hi, m;\n    slang_T\t*slang = mip->mi_lp->lp_slang;\n    char_u\t*byts;\n    idx_T\t*idxs;\n\n    byts = slang->sl_pbyts;\n    if (byts == NULL)\n\treturn;\t\t\t// array is empty\n\n    // We use the case-folded word here, since prefixes are always\n    // case-folded.\n    ptr = mip->mi_fword;\n    flen = mip->mi_fwordlen;    // available case-folded bytes\n    if (mode == FIND_COMPOUND)\n    {\n\t// Skip over the previously found word(s).\n\tptr += mip->mi_compoff;\n\tflen -= mip->mi_compoff;\n    }\n    idxs = slang->sl_pidxs;\n\n    /*\n     * Repeat advancing in the tree until:\n     * - there is a byte that doesn't match,\n     * - we reach the end of the tree,\n     * - or we reach the end of the line.\n     */\n    for (;;)\n    {\n\tif (flen == 0 && *mip->mi_fend != NUL)\n\t    flen = fold_more(mip);\n\n\tlen = byts[arridx++];\n\n\t// If the first possible byte is a zero the prefix could end here.\n\t// Check if the following word matches and supports the prefix.\n\tif (byts[arridx] == 0)\n\t{\n\t    // There can be several prefixes with different conditions.  We\n\t    // try them all, since we don't know which one will give the\n\t    // longest match.  The word is the same each time, pass the list\n\t    // of possible prefixes to find_word().\n\t    mip->mi_prefarridx = arridx;\n\t    mip->mi_prefcnt = len;\n\t    while (len > 0 && byts[arridx] == 0)\n\t    {\n\t\t++arridx;\n\t\t--len;\n\t    }\n\t    mip->mi_prefcnt -= len;\n\n\t    // Find the word that comes after the prefix.\n\t    mip->mi_prefixlen = wlen;\n\t    if (mode == FIND_COMPOUND)\n\t\t// Skip over the previously found word(s).\n\t\tmip->mi_prefixlen += mip->mi_compoff;\n\n\t    if (has_mbyte)\n\t    {\n\t\t// Case-folded length may differ from original length.\n\t\tmip->mi_cprefixlen = nofold_len(mip->mi_fword,\n\t\t\t\t\t     mip->mi_prefixlen, mip->mi_word);\n\t    }\n\t    else\n\t\tmip->mi_cprefixlen = mip->mi_prefixlen;\n\t    find_word(mip, FIND_PREFIX);\n\n\n\t    if (len == 0)\n\t\tbreak;\t    // no children, word must end here\n\t}\n\n\t// Stop looking at end of the line.\n\tif (ptr[wlen] == NUL)\n\t    break;\n\n\t// Perform a binary search in the list of accepted bytes.\n\tc = ptr[wlen];\n\tlo = arridx;\n\thi = arridx + len - 1;\n\twhile (lo < hi)\n\t{\n\t    m = (lo + hi) / 2;\n\t    if (byts[m] > c)\n\t\thi = m - 1;\n\t    else if (byts[m] < c)\n\t\tlo = m + 1;\n\t    else\n\t    {\n\t\tlo = hi = m;\n\t\tbreak;\n\t    }\n\t}\n\n\t// Stop if there is no matching byte.\n\tif (hi < lo || byts[lo] != c)\n\t    break;\n\n\t// Continue at the child (if there is one).\n\tarridx = idxs[lo];\n\t++wlen;\n\t--flen;\n    }\n}\n\n/*\n * Need to fold at least one more character.  Do until next non-word character\n * for efficiency.  Include the non-word character too.\n * Return the length of the folded chars in bytes.\n */\n    static int\nfold_more(matchinf_T *mip)\n{\n    int\t\tflen;\n    char_u\t*p;\n\n    p = mip->mi_fend;\n    do\n\tMB_PTR_ADV(mip->mi_fend);\n    while (*mip->mi_fend != NUL && spell_iswordp(mip->mi_fend, mip->mi_win));\n\n    // Include the non-word character so that we can check for the word end.\n    if (*mip->mi_fend != NUL)\n\tMB_PTR_ADV(mip->mi_fend);\n\n    (void)spell_casefold(mip->mi_win, p, (int)(mip->mi_fend - p),\n\t\t\t     mip->mi_fword + mip->mi_fwordlen,\n\t\t\t     MAXWLEN - mip->mi_fwordlen);\n    flen = (int)STRLEN(mip->mi_fword + mip->mi_fwordlen);\n    mip->mi_fwordlen += flen;\n    return flen;\n}\n\n/*\n * Check case flags for a word.  Return TRUE if the word has the requested\n * case.\n */\n    int\nspell_valid_case(\n    int\t    wordflags,\t    // flags for the checked word.\n    int\t    treeflags)\t    // flags for the word in the spell tree\n{\n    return ((wordflags == WF_ALLCAP && (treeflags & WF_FIXCAP) == 0)\n\t    || ((treeflags & (WF_ALLCAP | WF_KEEPCAP)) == 0\n\t\t&& ((treeflags & WF_ONECAP) == 0\n\t\t\t\t\t   || (wordflags & WF_ONECAP) != 0)));\n}\n\n/*\n * Return TRUE if spell checking is not enabled.\n */\n    static int\nno_spell_checking(win_T *wp)\n{\n    if (!wp->w_p_spell || *wp->w_s->b_p_spl == NUL\n\t\t\t\t\t || wp->w_s->b_langp.ga_len == 0)\n    {\n\temsg(_(e_spell_checking_is_not_possible));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Move to next spell error.\n * \"curline\" is FALSE for \"[s\", \"]s\", \"[S\" and \"]S\".\n * \"curline\" is TRUE to find word under/after cursor in the same line.\n * For Insert mode completion \"dir\" is BACKWARD and \"curline\" is TRUE: move\n * to after badly spelled word before the cursor.\n * Return 0 if not found, length of the badly spelled word otherwise.\n */\n    int\nspell_move_to(\n    win_T\t*wp,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tallwords,\t// TRUE for \"[s\"/\"]s\", FALSE for \"[S\"/\"]S\"\n    int\t\tcurline,\n    hlf_T\t*attrp)\t\t// return: attributes of bad word or NULL\n\t\t\t\t// (only when \"dir\" is FORWARD)\n{\n    linenr_T\tlnum;\n    pos_T\tfound_pos;\n    int\t\tfound_len = 0;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\t*endp;\n    hlf_T\tattr;\n    int\t\tlen;\n#ifdef FEAT_SYN_HL\n    int\t\thas_syntax = syntax_present(wp);\n#endif\n    int\t\tcol;\n    int\t\tcan_spell;\n    char_u\t*buf = NULL;\n    int\t\tbuflen = 0;\n    int\t\tskip = 0;\n    int\t\tcapcol = -1;\n    int\t\tfound_one = FALSE;\n    int\t\twrapped = FALSE;\n\n    if (no_spell_checking(wp))\n\treturn 0;\n\n    /*\n     * Start looking for bad word at the start of the line, because we can't\n     * start halfway a word, we don't know where it starts or ends.\n     *\n     * When searching backwards, we continue in the line to find the last\n     * bad word (in the cursor line: before the cursor).\n     *\n     * We concatenate the start of the next line, so that wrapped words work\n     * (e.g. \"et<line-break>cetera\").  Doesn't work when searching backwards\n     * though...\n     */\n    lnum = wp->w_cursor.lnum;\n    CLEAR_POS(&found_pos);\n\n    while (!got_int)\n    {\n\tline = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\n\tlen = (int)STRLEN(line);\n\tif (buflen < len + MAXWLEN + 2)\n\t{\n\t    vim_free(buf);\n\t    buflen = len + MAXWLEN + 2;\n\t    buf = alloc(buflen);\n\t    if (buf == NULL)\n\t\tbreak;\n\t}\n\n\t// In first line check first word for Capital.\n\tif (lnum == 1)\n\t    capcol = 0;\n\n\t// For checking first word with a capital skip white space.\n\tif (capcol == 0)\n\t    capcol = getwhitecols(line);\n\telse if (curline && wp == curwin)\n\t{\n\t    // For spellbadword(): check if first word needs a capital.\n\t    col = getwhitecols(line);\n\t    if (check_need_cap(lnum, col))\n\t\tcapcol = col;\n\n\t    // Need to get the line again, may have looked at the previous\n\t    // one.\n\t    line = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\t}\n\n\t// Copy the line into \"buf\" and append the start of the next line if\n\t// possible.\n\tSTRCPY(buf, line);\n\tif (lnum < wp->w_buffer->b_ml.ml_line_count)\n\t    spell_cat_line(buf + STRLEN(buf),\n\t\t\t  ml_get_buf(wp->w_buffer, lnum + 1, FALSE), MAXWLEN);\n\n\tp = buf + skip;\n\tendp = buf + len;\n\twhile (p < endp)\n\t{\n\t    // When searching backward don't search after the cursor.  Unless\n\t    // we wrapped around the end of the buffer.\n\t    if (dir == BACKWARD\n\t\t    && lnum == wp->w_cursor.lnum\n\t\t    && !wrapped\n\t\t    && (colnr_T)(p - buf) >= wp->w_cursor.col)\n\t\tbreak;\n\n\t    // start of word\n\t    attr = HLF_COUNT;\n\t    len = spell_check(wp, p, &attr, &capcol, FALSE);\n\n\t    if (attr != HLF_COUNT)\n\t    {\n\t\t// We found a bad word.  Check the attribute.\n\t\tif (allwords || attr == HLF_SPB)\n\t\t{\n\t\t    // When searching forward only accept a bad word after\n\t\t    // the cursor.\n\t\t    if (dir == BACKWARD\n\t\t\t    || lnum != wp->w_cursor.lnum\n\t\t\t    || (wrapped\n\t\t\t\t|| (colnr_T)(curline ? p - buf + len\n\t\t\t\t\t\t     : p - buf)\n\t\t\t\t\t\t  > wp->w_cursor.col))\n\t\t    {\n#ifdef FEAT_SYN_HL\n\t\t\tif (has_syntax)\n\t\t\t{\n\t\t\t    col = (int)(p - buf);\n\t\t\t    (void)syn_get_id(wp, lnum, (colnr_T)col,\n\t\t\t\t\t\t    FALSE, &can_spell, FALSE);\n\t\t\t    if (!can_spell)\n\t\t\t\tattr = HLF_COUNT;\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t    can_spell = TRUE;\n\n\t\t\tif (can_spell)\n\t\t\t{\n\t\t\t    found_one = TRUE;\n\t\t\t    found_pos.lnum = lnum;\n\t\t\t    found_pos.col = (int)(p - buf);\n\t\t\t    found_pos.coladd = 0;\n\t\t\t    if (dir == FORWARD)\n\t\t\t    {\n\t\t\t\t// No need to search further.\n\t\t\t\twp->w_cursor = found_pos;\n\t\t\t\tvim_free(buf);\n\t\t\t\tif (attrp != NULL)\n\t\t\t\t    *attrp = attr;\n\t\t\t\treturn len;\n\t\t\t    }\n\t\t\t    else if (curline)\n\t\t\t\t// Insert mode completion: put cursor after\n\t\t\t\t// the bad word.\n\t\t\t\tfound_pos.col += len;\n\t\t\t    found_len = len;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tfound_one = TRUE;\n\t\t}\n\t    }\n\n\t    // advance to character after the word\n\t    p += len;\n\t    capcol -= len;\n\t}\n\n\tif (dir == BACKWARD && found_pos.lnum != 0)\n\t{\n\t    // Use the last match in the line (before the cursor).\n\t    wp->w_cursor = found_pos;\n\t    vim_free(buf);\n\t    return found_len;\n\t}\n\n\tif (curline)\n\t    break;\t// only check cursor line\n\n\t// If we are back at the starting line and searched it again there\n\t// is no match, give up.\n\tif (lnum == wp->w_cursor.lnum && wrapped)\n\t    break;\n\n\t// Advance to next line.\n\tif (dir == BACKWARD)\n\t{\n\t    if (lnum > 1)\n\t\t--lnum;\n\t    else if (!p_ws)\n\t\tbreak;\t    // at first line and 'nowrapscan'\n\t    else\n\t    {\n\t\t// Wrap around to the end of the buffer.  May search the\n\t\t// starting line again and accept the last match.\n\t\tlnum = wp->w_buffer->b_ml.ml_line_count;\n\t\twrapped = TRUE;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(top_bot_msg), TRUE);\n\t    }\n\t    capcol = -1;\n\t}\n\telse\n\t{\n\t    if (lnum < wp->w_buffer->b_ml.ml_line_count)\n\t\t++lnum;\n\t    else if (!p_ws)\n\t\tbreak;\t    // at first line and 'nowrapscan'\n\t    else\n\t    {\n\t\t// Wrap around to the start of the buffer.  May search the\n\t\t// starting line again and accept the first match.\n\t\tlnum = 1;\n\t\twrapped = TRUE;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(bot_top_msg), TRUE);\n\t    }\n\n\t    // If we are back at the starting line and there is no match then\n\t    // give up.\n\t    if (lnum == wp->w_cursor.lnum && !found_one)\n\t\tbreak;\n\n\t    // Skip the characters at the start of the next line that were\n\t    // included in a match crossing line boundaries.\n\t    if (attr == HLF_COUNT)\n\t\tskip = (int)(p - endp);\n\t    else\n\t\tskip = 0;\n\n\t    // Capcol skips over the inserted space.\n\t    --capcol;\n\n\t    // But after empty line check first word in next line\n\t    if (*skipwhite(line) == NUL)\n\t\tcapcol = 0;\n\t}\n\n\tline_breakcheck();\n    }\n\n    vim_free(buf);\n    return 0;\n}\n\n/*\n * For spell checking: concatenate the start of the following line \"line\" into\n * \"buf\", blanking-out special characters.  Copy less than \"maxlen\" bytes.\n * Keep the blanks at the start of the next line, this is used in win_line()\n * to skip those bytes if the word was OK.\n */\n    void\nspell_cat_line(char_u *buf, char_u *line, int maxlen)\n{\n    char_u\t*p;\n    int\t\tn;\n\n    p = skipwhite(line);\n    while (vim_strchr((char_u *)\"*#/\\\"\\t\", *p) != NULL)\n\tp = skipwhite(p + 1);\n\n    if (*p != NUL)\n    {\n\t// Only worth concatenating if there is something else than spaces to\n\t// concatenate.\n\tn = (int)(p - line) + 1;\n\tif (n < maxlen - 1)\n\t{\n\t    vim_memset(buf, ' ', n);\n\t    vim_strncpy(buf +  n, p, maxlen - 1 - n);\n\t}\n    }\n}\n\n/*\n * Structure used for the cookie argument of do_in_runtimepath().\n */\ntypedef struct spelload_S\n{\n    char_u  sl_lang[MAXWLEN + 1];\t// language name\n    slang_T *sl_slang;\t\t\t// resulting slang_T struct\n    int\t    sl_nobreak;\t\t\t// NOBREAK language found\n} spelload_T;\n\n/*\n * Load word list(s) for \"lang\" from Vim spell file(s).\n * \"lang\" must be the language without the region: e.g., \"en\".\n */\n    static void\nspell_load_lang(char_u *lang)\n{\n    char_u\tfname_enc[85];\n    int\t\tr;\n    spelload_T\tsl;\n    int\t\tround;\n\n    // Copy the language name to pass it to spell_load_cb() as a cookie.\n    // It's truncated when an error is detected.\n    STRCPY(sl.sl_lang, lang);\n    sl.sl_slang = NULL;\n    sl.sl_nobreak = FALSE;\n\n    // We may retry when no spell file is found for the language, an\n    // autocommand may load it then.\n    for (round = 1; round <= 2; ++round)\n    {\n\t/*\n\t * Find the first spell file for \"lang\" in 'runtimepath' and load it.\n\t */\n\tvim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,\n#ifdef VMS\n\t\t\t\t\t\"spell/%s_%s.spl\",\n#else\n\t\t\t\t\t\"spell/%s.%s.spl\",\n#endif\n\t\t\t\t\t\t\t   lang, spell_enc());\n\tr = do_in_runtimepath(fname_enc, 0, spell_load_cb, &sl);\n\n\tif (r == FAIL && *sl.sl_lang != NUL)\n\t{\n\t    // Try loading the ASCII version.\n\t    vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,\n#ifdef VMS\n\t\t\t\t\t\t  \"spell/%s_ascii.spl\",\n#else\n\t\t\t\t\t\t  \"spell/%s.ascii.spl\",\n#endif\n\t\t\t\t\t\t\t\t\tlang);\n\t    r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &sl);\n\n\t    if (r == FAIL && *sl.sl_lang != NUL && round == 1\n\t\t    && apply_autocmds(EVENT_SPELLFILEMISSING, lang,\n\t\t\t\t\t      curbuf->b_fname, FALSE, curbuf))\n\t\tcontinue;\n\t    break;\n\t}\n\tbreak;\n    }\n\n    if (r == FAIL)\n    {\n\tsmsg(\n#ifdef VMS\n\t_(\"Warning: Cannot find word list \\\"%s_%s.spl\\\" or \\\"%s_ascii.spl\\\"\"),\n#else\n\t_(\"Warning: Cannot find word list \\\"%s.%s.spl\\\" or \\\"%s.ascii.spl\\\"\"),\n#endif\n\t\t\t\t\t\t     lang, spell_enc(), lang);\n    }\n    else if (sl.sl_slang != NULL)\n    {\n\t// At least one file was loaded, now load ALL the additions.\n\tSTRCPY(fname_enc + STRLEN(fname_enc) - 3, \"add.spl\");\n\tdo_in_runtimepath(fname_enc, DIP_ALL, spell_load_cb, &sl);\n    }\n}\n\n/*\n * Return the encoding used for spell checking: Use 'encoding', except that we\n * use \"latin1\" for \"latin9\".  And limit to 60 characters (just in case).\n */\n    char_u *\nspell_enc(void)\n{\n\n    if (STRLEN(p_enc) < 60 && STRCMP(p_enc, \"iso-8859-15\") != 0)\n\treturn p_enc;\n    return (char_u *)\"latin1\";\n}\n\n/*\n * Get the name of the .spl file for the internal wordlist into\n * \"fname[MAXPATHL]\".\n */\n    static void\nint_wordlist_spl(char_u *fname)\n{\n    vim_snprintf((char *)fname, MAXPATHL, SPL_FNAME_TMPL,\n\t\t\t\t\t\t  int_wordlist, spell_enc());\n}\n\n/*\n * Allocate a new slang_T for language \"lang\".  \"lang\" can be NULL.\n * Caller must fill \"sl_next\".\n */\n    slang_T *\nslang_alloc(char_u *lang)\n{\n    slang_T *lp;\n\n    lp = ALLOC_CLEAR_ONE(slang_T);\n    if (lp != NULL)\n    {\n\tif (lang != NULL)\n\t    lp->sl_name = vim_strsave(lang);\n\tga_init2(&lp->sl_rep, sizeof(fromto_T), 10);\n\tga_init2(&lp->sl_repsal, sizeof(fromto_T), 10);\n\tlp->sl_compmax = MAXWLEN;\n\tlp->sl_compsylmax = MAXWLEN;\n\thash_init(&lp->sl_wordcount);\n    }\n\n    return lp;\n}\n\n/*\n * Free the contents of an slang_T and the structure itself.\n */\n    void\nslang_free(slang_T *lp)\n{\n    vim_free(lp->sl_name);\n    vim_free(lp->sl_fname);\n    slang_clear(lp);\n    vim_free(lp);\n}\n\n/*\n * Clear an slang_T so that the file can be reloaded.\n */\n    void\nslang_clear(slang_T *lp)\n{\n    garray_T\t*gap;\n    fromto_T\t*ftp;\n    salitem_T\t*smp;\n    int\t\ti;\n    int\t\tround;\n\n    VIM_CLEAR(lp->sl_fbyts);\n    VIM_CLEAR(lp->sl_kbyts);\n    VIM_CLEAR(lp->sl_pbyts);\n\n    VIM_CLEAR(lp->sl_fidxs);\n    VIM_CLEAR(lp->sl_kidxs);\n    VIM_CLEAR(lp->sl_pidxs);\n\n    for (round = 1; round <= 2; ++round)\n    {\n\tgap = round == 1 ? &lp->sl_rep : &lp->sl_repsal;\n\twhile (gap->ga_len > 0)\n\t{\n\t    ftp = &((fromto_T *)gap->ga_data)[--gap->ga_len];\n\t    vim_free(ftp->ft_from);\n\t    vim_free(ftp->ft_to);\n\t}\n\tga_clear(gap);\n    }\n\n    gap = &lp->sl_sal;\n    if (lp->sl_sofo)\n    {\n\t// \"ga_len\" is set to 1 without adding an item for latin1\n\tif (gap->ga_data != NULL)\n\t    // SOFOFROM and SOFOTO items: free lists of wide characters.\n\t    for (i = 0; i < gap->ga_len; ++i)\n\t\tvim_free(((int **)gap->ga_data)[i]);\n    }\n    else\n\t// SAL items: free salitem_T items\n\twhile (gap->ga_len > 0)\n\t{\n\t    smp = &((salitem_T *)gap->ga_data)[--gap->ga_len];\n\t    vim_free(smp->sm_lead);\n\t    // Don't free sm_oneof and sm_rules, they point into sm_lead.\n\t    vim_free(smp->sm_to);\n\t    vim_free(smp->sm_lead_w);\n\t    vim_free(smp->sm_oneof_w);\n\t    vim_free(smp->sm_to_w);\n\t}\n    ga_clear(gap);\n\n    for (i = 0; i < lp->sl_prefixcnt; ++i)\n\tvim_regfree(lp->sl_prefprog[i]);\n    lp->sl_prefixcnt = 0;\n    VIM_CLEAR(lp->sl_prefprog);\n\n    VIM_CLEAR(lp->sl_info);\n\n    VIM_CLEAR(lp->sl_midword);\n\n    vim_regfree(lp->sl_compprog);\n    lp->sl_compprog = NULL;\n    VIM_CLEAR(lp->sl_comprules);\n    VIM_CLEAR(lp->sl_compstartflags);\n    VIM_CLEAR(lp->sl_compallflags);\n\n    VIM_CLEAR(lp->sl_syllable);\n    ga_clear(&lp->sl_syl_items);\n\n    ga_clear_strings(&lp->sl_comppat);\n\n    hash_clear_all(&lp->sl_wordcount, WC_KEY_OFF);\n    hash_init(&lp->sl_wordcount);\n\n    hash_clear_all(&lp->sl_map_hash, 0);\n\n    // Clear info from .sug file.\n    slang_clear_sug(lp);\n\n    lp->sl_compmax = MAXWLEN;\n    lp->sl_compminlen = 0;\n    lp->sl_compsylmax = MAXWLEN;\n    lp->sl_regions[0] = NUL;\n}\n\n/*\n * Clear the info from the .sug file in \"lp\".\n */\n    void\nslang_clear_sug(slang_T *lp)\n{\n    VIM_CLEAR(lp->sl_sbyts);\n    VIM_CLEAR(lp->sl_sidxs);\n    close_spellbuf(lp->sl_sugbuf);\n    lp->sl_sugbuf = NULL;\n    lp->sl_sugloaded = FALSE;\n    lp->sl_sugtime = 0;\n}\n\n/*\n * Load one spell file and store the info into a slang_T.\n * Invoked through do_in_runtimepath().\n */\n    static void\nspell_load_cb(char_u *fname, void *cookie)\n{\n    spelload_T\t*slp = (spelload_T *)cookie;\n    slang_T\t*slang;\n\n    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);\n    if (slang != NULL)\n    {\n\t// When a previously loaded file has NOBREAK also use it for the\n\t// \".add\" files.\n\tif (slp->sl_nobreak && slang->sl_add)\n\t    slang->sl_nobreak = TRUE;\n\telse if (slang->sl_nobreak)\n\t    slp->sl_nobreak = TRUE;\n\n\tslp->sl_slang = slang;\n    }\n}\n\n\n/*\n * Add a word to the hashtable of common words.\n * If it's already there then the counter is increased.\n */\n    void\ncount_common_word(\n    slang_T\t*lp,\n    char_u\t*word,\n    int\t\tlen,\t    // word length, -1 for up to NUL\n    int\t\tcount)\t    // 1 to count once, 10 to init\n{\n    hash_T\thash;\n    hashitem_T\t*hi;\n    wordcount_T\t*wc;\n    char_u\tbuf[MAXWLEN];\n    char_u\t*p;\n\n    if (len == -1)\n\tp = word;\n    else if (len >= MAXWLEN)\n\treturn;\n    else\n    {\n\tvim_strncpy(buf, word, len);\n\tp = buf;\n    }\n\n    hash = hash_hash(p);\n    hi = hash_lookup(&lp->sl_wordcount, p, hash);\n    if (HASHITEM_EMPTY(hi))\n    {\n\twc = alloc(sizeof(wordcount_T) + STRLEN(p));\n\tif (wc == NULL)\n\t    return;\n\tSTRCPY(wc->wc_word, p);\n\twc->wc_count = count;\n\thash_add_item(&lp->sl_wordcount, hi, wc->wc_word, hash);\n    }\n    else\n    {\n\twc = HI2WC(hi);\n\tif ((wc->wc_count += count) < (unsigned)count)\t// check for overflow\n\t    wc->wc_count = MAXWORDCOUNT;\n    }\n}\n\n/*\n * Return TRUE if byte \"n\" appears in \"str\".\n * Like strchr() but independent of locale.\n */\n    int\nbyte_in_str(char_u *str, int n)\n{\n    char_u\t*p;\n\n    for (p = str; *p != NUL; ++p)\n\tif (*p == n)\n\t    return TRUE;\n    return FALSE;\n}\n\n#define SY_MAXLEN   30\ntypedef struct syl_item_S\n{\n    char_u\tsy_chars[SY_MAXLEN];\t    // the sequence of chars\n    int\t\tsy_len;\n} syl_item_T;\n\n/*\n * Truncate \"slang->sl_syllable\" at the first slash and put the following items\n * in \"slang->sl_syl_items\".\n */\n    int\ninit_syl_tab(slang_T *slang)\n{\n    char_u\t*p;\n    char_u\t*s;\n    int\t\tl;\n    syl_item_T\t*syl;\n\n    ga_init2(&slang->sl_syl_items, sizeof(syl_item_T), 4);\n    p = vim_strchr(slang->sl_syllable, '/');\n    while (p != NULL)\n    {\n\t*p++ = NUL;\n\tif (*p == NUL)\t    // trailing slash\n\t    break;\n\ts = p;\n\tp = vim_strchr(p, '/');\n\tif (p == NULL)\n\t    l = (int)STRLEN(s);\n\telse\n\t    l = (int)(p - s);\n\tif (l >= SY_MAXLEN)\n\t    return SP_FORMERROR;\n\tif (ga_grow(&slang->sl_syl_items, 1) == FAIL)\n\t    return SP_OTHERERROR;\n\tsyl = ((syl_item_T *)slang->sl_syl_items.ga_data)\n\t\t\t\t\t       + slang->sl_syl_items.ga_len++;\n\tvim_strncpy(syl->sy_chars, s, l);\n\tsyl->sy_len = l;\n    }\n    return OK;\n}\n\n/*\n * Count the number of syllables in \"word\".\n * When \"word\" contains spaces the syllables after the last space are counted.\n * Returns zero if syllables are not defines.\n */\n    static int\ncount_syllables(slang_T *slang, char_u *word)\n{\n    int\t\tcnt = 0;\n    int\t\tskip = FALSE;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\ti;\n    syl_item_T\t*syl;\n    int\t\tc;\n\n    if (slang->sl_syllable == NULL)\n\treturn 0;\n\n    for (p = word; *p != NUL; p += len)\n    {\n\t// When running into a space reset counter.\n\tif (*p == ' ')\n\t{\n\t    len = 1;\n\t    cnt = 0;\n\t    continue;\n\t}\n\n\t// Find longest match of syllable items.\n\tlen = 0;\n\tfor (i = 0; i < slang->sl_syl_items.ga_len; ++i)\n\t{\n\t    syl = ((syl_item_T *)slang->sl_syl_items.ga_data) + i;\n\t    if (syl->sy_len > len\n\t\t\t       && STRNCMP(p, syl->sy_chars, syl->sy_len) == 0)\n\t\tlen = syl->sy_len;\n\t}\n\tif (len != 0)\t// found a match, count syllable\n\t{\n\t    ++cnt;\n\t    skip = FALSE;\n\t}\n\telse\n\t{\n\t    // No recognized syllable item, at least a syllable char then?\n\t    c = mb_ptr2char(p);\n\t    len = (*mb_ptr2len)(p);\n\t    if (vim_strchr(slang->sl_syllable, c) == NULL)\n\t\tskip = FALSE;\t    // No, search for next syllable\n\t    else if (!skip)\n\t    {\n\t\t++cnt;\t\t    // Yes, count it\n\t\tskip = TRUE;\t    // don't count following syllable chars\n\t    }\n\t}\n    }\n    return cnt;\n}\n\n/*\n * Parse 'spelllang' and set w_s->b_langp accordingly.\n * Returns NULL if it's OK, an untranslated error message otherwise.\n */\n    char *\ndid_set_spelllang(win_T *wp)\n{\n    garray_T\tga;\n    char_u\t*splp;\n    char_u\t*region;\n    char_u\tregion_cp[3];\n    int\t\tfilename;\n    int\t\tregion_mask;\n    slang_T\t*slang;\n    int\t\tc;\n    char_u\tlang[MAXWLEN + 1];\n    char_u\tspf_name[MAXPATHL];\n    int\t\tlen;\n    char_u\t*p;\n    int\t\tround;\n    char_u\t*spf;\n    char_u\t*use_region = NULL;\n    int\t\tdont_use_region = FALSE;\n    int\t\tnobreak = FALSE;\n    int\t\ti, j;\n    langp_T\t*lp, *lp2;\n    static int\trecursive = FALSE;\n    char\t*ret_msg = NULL;\n    char_u\t*spl_copy;\n    bufref_T\tbufref;\n\n    set_bufref(&bufref, wp->w_buffer);\n\n    // We don't want to do this recursively.  May happen when a language is\n    // not available and the SpellFileMissing autocommand opens a new buffer\n    // in which 'spell' is set.\n    if (recursive)\n\treturn NULL;\n    recursive = TRUE;\n\n    ga_init2(&ga, sizeof(langp_T), 2);\n    clear_midword(wp);\n\n    // Make a copy of 'spelllang', the SpellFileMissing autocommands may change\n    // it under our fingers.\n    spl_copy = vim_strsave(wp->w_s->b_p_spl);\n    if (spl_copy == NULL)\n\tgoto theend;\n\n    wp->w_s->b_cjk = 0;\n\n    // Loop over comma separated language names.\n    for (splp = spl_copy; *splp != NUL; )\n    {\n\t// Get one language name.\n\tcopy_option_part(&splp, lang, MAXWLEN, \",\");\n\tregion = NULL;\n\tlen = (int)STRLEN(lang);\n\n\tif (!valid_spelllang(lang))\n\t    continue;\n\n\tif (STRCMP(lang, \"cjk\") == 0)\n\t{\n\t    wp->w_s->b_cjk = 1;\n\t    continue;\n\t}\n\n\t// If the name ends in \".spl\" use it as the name of the spell file.\n\t// If there is a region name let \"region\" point to it and remove it\n\t// from the name.\n\tif (len > 4 && fnamecmp(lang + len - 4, \".spl\") == 0)\n\t{\n\t    filename = TRUE;\n\n\t    // Locate a region and remove it from the file name.\n\t    p = vim_strchr(gettail(lang), '_');\n\t    if (p != NULL && ASCII_ISALPHA(p[1]) && ASCII_ISALPHA(p[2])\n\t\t\t\t\t\t      && !ASCII_ISALPHA(p[3]))\n\t    {\n\t\tvim_strncpy(region_cp, p + 1, 2);\n\t\tmch_memmove(p, p + 3, len - (p - lang) - 2);\n\t\tregion = region_cp;\n\t    }\n\t    else\n\t\tdont_use_region = TRUE;\n\n\t    // Check if we loaded this language before.\n\t    FOR_ALL_SPELL_LANGS(slang)\n\t\tif (fullpathcmp(lang, slang->sl_fname, FALSE, TRUE) == FPC_SAME)\n\t\t    break;\n\t}\n\telse\n\t{\n\t    filename = FALSE;\n\t    if (len > 3 && lang[len - 3] == '_')\n\t    {\n\t\tregion = lang + len - 2;\n\t\tlen -= 3;\n\t\tlang[len] = NUL;\n\t    }\n\t    else\n\t\tdont_use_region = TRUE;\n\n\t    // Check if we loaded this language before.\n\t    FOR_ALL_SPELL_LANGS(slang)\n\t\tif (STRICMP(lang, slang->sl_name) == 0)\n\t\t    break;\n\t}\n\n\tif (region != NULL)\n\t{\n\t    // If the region differs from what was used before then don't\n\t    // use it for 'spellfile'.\n\t    if (use_region != NULL && STRCMP(region, use_region) != 0)\n\t\tdont_use_region = TRUE;\n\t    use_region = region;\n\t}\n\n\t// If not found try loading the language now.\n\tif (slang == NULL)\n\t{\n\t    if (filename)\n\t\t(void)spell_load_file(lang, lang, NULL, FALSE);\n\t    else\n\t    {\n\t\tspell_load_lang(lang);\n\t\t// SpellFileMissing autocommands may do anything, including\n\t\t// destroying the buffer we are using...\n\t\tif (!bufref_valid(&bufref))\n\t\t{\n\t\t    ret_msg = N_(e_spellfilemising_autocommand_deleted_buffer);\n\t\t    goto theend;\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * Loop over the languages, there can be several files for \"lang\".\n\t */\n\tFOR_ALL_SPELL_LANGS(slang)\n\t    if (filename ? fullpathcmp(lang, slang->sl_fname, FALSE, TRUE)\n\t\t\t\t\t\t\t\t    == FPC_SAME\n\t\t\t : STRICMP(lang, slang->sl_name) == 0)\n\t    {\n\t\tregion_mask = REGION_ALL;\n\t\tif (!filename && region != NULL)\n\t\t{\n\t\t    // find region in sl_regions\n\t\t    c = find_region(slang->sl_regions, region);\n\t\t    if (c == REGION_ALL)\n\t\t    {\n\t\t\tif (slang->sl_add)\n\t\t\t{\n\t\t\t    if (*slang->sl_regions != NUL)\n\t\t\t\t// This addition file is for other regions.\n\t\t\t\tregion_mask = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t    // This is probably an error.  Give a warning and\n\t\t\t    // accept the words anyway.\n\t\t\t    smsg(_(\"Warning: region %s not supported\"),\n\t\t\t\t\t\t\t\t      region);\n\t\t    }\n\t\t    else\n\t\t\tregion_mask = 1 << c;\n\t\t}\n\n\t\tif (region_mask != 0)\n\t\t{\n\t\t    if (ga_grow(&ga, 1) == FAIL)\n\t\t    {\n\t\t\tga_clear(&ga);\n\t\t\tret_msg = e_out_of_memory;\n\t\t\tgoto theend;\n\t\t    }\n\t\t    LANGP_ENTRY(ga, ga.ga_len)->lp_slang = slang;\n\t\t    LANGP_ENTRY(ga, ga.ga_len)->lp_region = region_mask;\n\t\t    ++ga.ga_len;\n\t\t    use_midword(slang, wp);\n\t\t    if (slang->sl_nobreak)\n\t\t\tnobreak = TRUE;\n\t\t}\n\t    }\n    }\n\n    // round 0: load int_wordlist, if possible.\n    // round 1: load first name in 'spellfile'.\n    // round 2: load second name in 'spellfile.\n    // etc.\n    spf = curwin->w_s->b_p_spf;\n    for (round = 0; round == 0 || *spf != NUL; ++round)\n    {\n\tif (round == 0)\n\t{\n\t    // Internal wordlist, if there is one.\n\t    if (int_wordlist == NULL)\n\t\tcontinue;\n\t    int_wordlist_spl(spf_name);\n\t}\n\telse\n\t{\n\t    // One entry in 'spellfile'.\n\t    copy_option_part(&spf, spf_name, MAXPATHL - 5, \",\");\n\t    STRCAT(spf_name, \".spl\");\n\n\t    // If it was already found above then skip it.\n\t    for (c = 0; c < ga.ga_len; ++c)\n\t    {\n\t\tp = LANGP_ENTRY(ga, c)->lp_slang->sl_fname;\n\t\tif (p != NULL && fullpathcmp(spf_name, p, FALSE, TRUE)\n\t\t\t\t\t\t\t\t== FPC_SAME)\n\t\t    break;\n\t    }\n\t    if (c < ga.ga_len)\n\t\tcontinue;\n\t}\n\n\t// Check if it was loaded already.\n\tFOR_ALL_SPELL_LANGS(slang)\n\t    if (fullpathcmp(spf_name, slang->sl_fname, FALSE, TRUE)\n\t\t\t\t\t\t\t\t== FPC_SAME)\n\t\tbreak;\n\tif (slang == NULL)\n\t{\n\t    // Not loaded, try loading it now.  The language name includes the\n\t    // region name, the region is ignored otherwise.  for int_wordlist\n\t    // use an arbitrary name.\n\t    if (round == 0)\n\t\tSTRCPY(lang, \"internal wordlist\");\n\t    else\n\t    {\n\t\tvim_strncpy(lang, gettail(spf_name), MAXWLEN);\n\t\tp = vim_strchr(lang, '.');\n\t\tif (p != NULL)\n\t\t    *p = NUL;\t// truncate at \".encoding.add\"\n\t    }\n\t    slang = spell_load_file(spf_name, lang, NULL, TRUE);\n\n\t    // If one of the languages has NOBREAK we assume the addition\n\t    // files also have this.\n\t    if (slang != NULL && nobreak)\n\t\tslang->sl_nobreak = TRUE;\n\t}\n\tif (slang != NULL && ga_grow(&ga, 1) == OK)\n\t{\n\t    region_mask = REGION_ALL;\n\t    if (use_region != NULL && !dont_use_region)\n\t    {\n\t\t// find region in sl_regions\n\t\tc = find_region(slang->sl_regions, use_region);\n\t\tif (c != REGION_ALL)\n\t\t    region_mask = 1 << c;\n\t\telse if (*slang->sl_regions != NUL)\n\t\t    // This spell file is for other regions.\n\t\t    region_mask = 0;\n\t    }\n\n\t    if (region_mask != 0)\n\t    {\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_slang = slang;\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_sallang = NULL;\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_replang = NULL;\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_region = region_mask;\n\t\t++ga.ga_len;\n\t\tuse_midword(slang, wp);\n\t    }\n\t}\n    }\n\n    // Everything is fine, store the new b_langp value.\n    ga_clear(&wp->w_s->b_langp);\n    wp->w_s->b_langp = ga;\n\n    // For each language figure out what language to use for sound folding and\n    // REP items.  If the language doesn't support it itself use another one\n    // with the same name.  E.g. for \"en-math\" use \"en\".\n    for (i = 0; i < ga.ga_len; ++i)\n    {\n\tlp = LANGP_ENTRY(ga, i);\n\n\t// sound folding\n\tif (lp->lp_slang->sl_sal.ga_len > 0)\n\t    // language does sound folding itself\n\t    lp->lp_sallang = lp->lp_slang;\n\telse\n\t    // find first similar language that does sound folding\n\t    for (j = 0; j < ga.ga_len; ++j)\n\t    {\n\t\tlp2 = LANGP_ENTRY(ga, j);\n\t\tif (lp2->lp_slang->sl_sal.ga_len > 0\n\t\t\t&& STRNCMP(lp->lp_slang->sl_name,\n\t\t\t\t\t      lp2->lp_slang->sl_name, 2) == 0)\n\t\t{\n\t\t    lp->lp_sallang = lp2->lp_slang;\n\t\t    break;\n\t\t}\n\t    }\n\n\t// REP items\n\tif (lp->lp_slang->sl_rep.ga_len > 0)\n\t    // language has REP items itself\n\t    lp->lp_replang = lp->lp_slang;\n\telse\n\t    // find first similar language that has REP items\n\t    for (j = 0; j < ga.ga_len; ++j)\n\t    {\n\t\tlp2 = LANGP_ENTRY(ga, j);\n\t\tif (lp2->lp_slang->sl_rep.ga_len > 0\n\t\t\t&& STRNCMP(lp->lp_slang->sl_name,\n\t\t\t\t\t      lp2->lp_slang->sl_name, 2) == 0)\n\t\t{\n\t\t    lp->lp_replang = lp2->lp_slang;\n\t\t    break;\n\t\t}\n\t    }\n    }\n    redraw_win_later(wp, NOT_VALID);\n\ntheend:\n    vim_free(spl_copy);\n    recursive = FALSE;\n    return ret_msg;\n}\n\n/*\n * Clear the midword characters for buffer \"buf\".\n */\n    static void\nclear_midword(win_T *wp)\n{\n    CLEAR_FIELD(wp->w_s->b_spell_ismw);\n    VIM_CLEAR(wp->w_s->b_spell_ismw_mb);\n}\n\n/*\n * Use the \"sl_midword\" field of language \"lp\" for buffer \"buf\".\n * They add up to any currently used midword characters.\n */\n    static void\nuse_midword(slang_T *lp, win_T *wp)\n{\n    char_u\t*p;\n\n    if (lp->sl_midword == NULL)\t    // there aren't any\n\treturn;\n\n    for (p = lp->sl_midword; *p != NUL; )\n\tif (has_mbyte)\n\t{\n\t    int\t    c, l, n;\n\t    char_u  *bp;\n\n\t    c = mb_ptr2char(p);\n\t    l = (*mb_ptr2len)(p);\n\t    if (c < 256 && l <= 2)\n\t\twp->w_s->b_spell_ismw[c] = TRUE;\n\t    else if (wp->w_s->b_spell_ismw_mb == NULL)\n\t\t// First multi-byte char in \"b_spell_ismw_mb\".\n\t\twp->w_s->b_spell_ismw_mb = vim_strnsave(p, l);\n\t    else\n\t    {\n\t\t// Append multi-byte chars to \"b_spell_ismw_mb\".\n\t\tn = (int)STRLEN(wp->w_s->b_spell_ismw_mb);\n\t\tbp = vim_strnsave(wp->w_s->b_spell_ismw_mb, n + l);\n\t\tif (bp != NULL)\n\t\t{\n\t\t    vim_free(wp->w_s->b_spell_ismw_mb);\n\t\t    wp->w_s->b_spell_ismw_mb = bp;\n\t\t    vim_strncpy(bp + n, p, l);\n\t\t}\n\t    }\n\t    p += l;\n\t}\n\telse\n\t    wp->w_s->b_spell_ismw[*p++] = TRUE;\n}\n\n/*\n * Find the region \"region[2]\" in \"rp\" (points to \"sl_regions\").\n * Each region is simply stored as the two characters of its name.\n * Returns the index if found (first is 0), REGION_ALL if not found.\n */\n    static int\nfind_region(char_u *rp, char_u *region)\n{\n    int\t\ti;\n\n    for (i = 0; ; i += 2)\n    {\n\tif (rp[i] == NUL)\n\t    return REGION_ALL;\n\tif (rp[i] == region[0] && rp[i + 1] == region[1])\n\t    break;\n    }\n    return i / 2;\n}\n\n/*\n * Return case type of word:\n * w word\t0\n * Word\t\tWF_ONECAP\n * W WORD\tWF_ALLCAP\n * WoRd\twOrd\tWF_KEEPCAP\n */\n    int\ncaptype(\n    char_u\t*word,\n    char_u\t*end)\t    // When NULL use up to NUL byte.\n{\n    char_u\t*p;\n    int\t\tc;\n    int\t\tfirstcap;\n    int\t\tallcap;\n    int\t\tpast_second = FALSE;\t// past second word char\n\n    // find first letter\n    for (p = word; !spell_iswordp_nmw(p, curwin); MB_PTR_ADV(p))\n\tif (end == NULL ? *p == NUL : p >= end)\n\t    return 0;\t    // only non-word characters, illegal word\n    if (has_mbyte)\n\tc = mb_ptr2char_adv(&p);\n    else\n\tc = *p++;\n    firstcap = allcap = SPELL_ISUPPER(c);\n\n    /*\n     * Need to check all letters to find a word with mixed upper/lower.\n     * But a word with an upper char only at start is a ONECAP.\n     */\n    for ( ; end == NULL ? *p != NUL : p < end; MB_PTR_ADV(p))\n\tif (spell_iswordp_nmw(p, curwin))\n\t{\n\t    c = PTR2CHAR(p);\n\t    if (!SPELL_ISUPPER(c))\n\t    {\n\t\t// UUl -> KEEPCAP\n\t\tif (past_second && allcap)\n\t\t    return WF_KEEPCAP;\n\t\tallcap = FALSE;\n\t    }\n\t    else if (!allcap)\n\t\t// UlU -> KEEPCAP\n\t\treturn WF_KEEPCAP;\n\t    past_second = TRUE;\n\t}\n\n    if (allcap)\n\treturn WF_ALLCAP;\n    if (firstcap)\n\treturn WF_ONECAP;\n    return 0;\n}\n\n/*\n * Delete the internal wordlist and its .spl file.\n */\n    void\nspell_delete_wordlist(void)\n{\n    char_u\tfname[MAXPATHL];\n\n    if (int_wordlist != NULL)\n    {\n\tmch_remove(int_wordlist);\n\tint_wordlist_spl(fname);\n\tmch_remove(fname);\n\tVIM_CLEAR(int_wordlist);\n    }\n}\n\n/*\n * Free all languages.\n */\n    void\nspell_free_all(void)\n{\n    slang_T\t*slang;\n    buf_T\t*buf;\n\n    // Go through all buffers and handle 'spelllang'. <VN>\n    FOR_ALL_BUFFERS(buf)\n\tga_clear(&buf->b_s.b_langp);\n\n    while (first_lang != NULL)\n    {\n\tslang = first_lang;\n\tfirst_lang = slang->sl_next;\n\tslang_free(slang);\n    }\n\n    spell_delete_wordlist();\n\n    VIM_CLEAR(repl_to);\n    VIM_CLEAR(repl_from);\n}\n\n/*\n * Clear all spelling tables and reload them.\n * Used after 'encoding' is set and when \":mkspell\" was used.\n */\n    void\nspell_reload(void)\n{\n    win_T\t*wp;\n\n    // Initialize the table for spell_iswordp().\n    init_spell_chartab();\n\n    // Unload all allocated memory.\n    spell_free_all();\n\n    // Go through all buffers and handle 'spelllang'.\n    FOR_ALL_WINDOWS(wp)\n    {\n\t// Only load the wordlists when 'spelllang' is set and there is a\n\t// window for this buffer in which 'spell' is set.\n\tif (*wp->w_s->b_p_spl != NUL)\n\t{\n\t\tif (wp->w_p_spell)\n\t\t{\n\t\t    (void)did_set_spelllang(wp);\n\t\t    break;\n\t\t}\n\t}\n    }\n}\n\n/*\n * Open a spell buffer.  This is a nameless buffer that is not in the buffer\n * list and only contains text lines.  Can use a swapfile to reduce memory\n * use.\n * Most other fields are invalid!  Esp. watch out for string options being\n * NULL and there is no undo info.\n * Returns NULL when out of memory.\n */\n    buf_T *\nopen_spellbuf(void)\n{\n    buf_T\t*buf;\n\n    buf = ALLOC_CLEAR_ONE(buf_T);\n    if (buf != NULL)\n    {\n\tbuf->b_spell = TRUE;\n\tbuf->b_p_swf = TRUE;\t// may create a swap file\n#ifdef FEAT_CRYPT\n\tbuf->b_p_key = empty_option;\n#endif\n\tml_open(buf);\n\tml_open_file(buf);\t// create swap file now\n    }\n    return buf;\n}\n\n/*\n * Close the buffer used for spell info.\n */\n    void\nclose_spellbuf(buf_T *buf)\n{\n    if (buf != NULL)\n    {\n\tml_close(buf, TRUE);\n\tvim_free(buf);\n    }\n}\n\n/*\n * Init the chartab used for spelling for ASCII.\n */\n    void\nclear_spell_chartab(spelltab_T *sp)\n{\n    int\t\ti;\n\n    // Init everything to FALSE (zero).\n    CLEAR_FIELD(sp->st_isw);\n    CLEAR_FIELD(sp->st_isu);\n    for (i = 0; i < 256; ++i)\n    {\n\tsp->st_fold[i] = i;\n\tsp->st_upper[i] = i;\n    }\n\n    // We include digits.  A word shouldn't start with a digit, but handling\n    // that is done separately.\n    for (i = '0'; i <= '9'; ++i)\n\tsp->st_isw[i] = TRUE;\n    for (i = 'A'; i <= 'Z'; ++i)\n    {\n\tsp->st_isw[i] = TRUE;\n\tsp->st_isu[i] = TRUE;\n\tsp->st_fold[i] = i + 0x20;\n    }\n    for (i = 'a'; i <= 'z'; ++i)\n    {\n\tsp->st_isw[i] = TRUE;\n\tsp->st_upper[i] = i - 0x20;\n    }\n}\n\n/*\n * Init the chartab used for spelling.  Only depends on 'encoding'.\n * Called once while starting up and when 'encoding' changes.\n * The default is to use isalpha(), but the spell file should define the word\n * characters to make it possible that 'encoding' differs from the current\n * locale.  For utf-8 we don't use isalpha() but our own functions.\n */\n    void\ninit_spell_chartab(void)\n{\n    int\t    i;\n\n    did_set_spelltab = FALSE;\n    clear_spell_chartab(&spelltab);\n    if (enc_dbcs)\n    {\n\t// DBCS: assume double-wide characters are word characters.\n\tfor (i = 128; i <= 255; ++i)\n\t    if (MB_BYTE2LEN(i) == 2)\n\t\tspelltab.st_isw[i] = TRUE;\n    }\n    else if (enc_utf8)\n    {\n\tfor (i = 128; i < 256; ++i)\n\t{\n\t    int f = utf_fold(i);\n\t    int u = utf_toupper(i);\n\n\t    spelltab.st_isu[i] = utf_isupper(i);\n\t    spelltab.st_isw[i] = spelltab.st_isu[i] || utf_islower(i);\n\t    // The folded/upper-cased value is different between latin1 and\n\t    // utf8 for 0xb5, causing E763 for no good reason.  Use the latin1\n\t    // value for utf-8 to avoid this.\n\t    spelltab.st_fold[i] = (f < 256) ? f : i;\n\t    spelltab.st_upper[i] = (u < 256) ? u : i;\n\t}\n    }\n    else\n    {\n\t// Rough guess: use locale-dependent library functions.\n\tfor (i = 128; i < 256; ++i)\n\t{\n\t    if (MB_ISUPPER(i))\n\t    {\n\t\tspelltab.st_isw[i] = TRUE;\n\t\tspelltab.st_isu[i] = TRUE;\n\t\tspelltab.st_fold[i] = MB_TOLOWER(i);\n\t    }\n\t    else if (MB_ISLOWER(i))\n\t    {\n\t\tspelltab.st_isw[i] = TRUE;\n\t\tspelltab.st_upper[i] = MB_TOUPPER(i);\n\t    }\n\t}\n    }\n}\n\n\n/*\n * Return TRUE if \"p\" points to a word character.\n * As a special case we see \"midword\" characters as word character when it is\n * followed by a word character.  This finds they'there but not 'they there'.\n * Thus this only works properly when past the first character of the word.\n */\n    int\nspell_iswordp(\n    char_u\t*p,\n    win_T\t*wp)\t    // buffer used\n{\n    char_u\t*s;\n    int\t\tl;\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tl = mb_ptr2len(p);\n\ts = p;\n\tif (l == 1)\n\t{\n\t    // be quick for ASCII\n\t    if (wp->w_s->b_spell_ismw[*p])\n\t\ts = p + 1;\t\t// skip a mid-word character\n\t}\n\telse\n\t{\n\t    c = mb_ptr2char(p);\n\t    if (c < 256 ? wp->w_s->b_spell_ismw[c]\n\t\t    : (wp->w_s->b_spell_ismw_mb != NULL\n\t\t\t   && vim_strchr(wp->w_s->b_spell_ismw_mb, c) != NULL))\n\t\ts = p + l;\n\t}\n\n\tc = mb_ptr2char(s);\n\tif (c > 255)\n\t    return spell_mb_isword_class(mb_get_class(s), wp);\n\treturn spelltab.st_isw[c];\n    }\n\n    return spelltab.st_isw[wp->w_s->b_spell_ismw[*p] ? p[1] : p[0]];\n}\n\n/*\n * Return TRUE if \"p\" points to a word character.\n * Unlike spell_iswordp() this doesn't check for \"midword\" characters.\n */\n    int\nspell_iswordp_nmw(char_u *p, win_T *wp)\n{\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tc = mb_ptr2char(p);\n\tif (c > 255)\n\t    return spell_mb_isword_class(mb_get_class(p), wp);\n\treturn spelltab.st_isw[c];\n    }\n    return spelltab.st_isw[*p];\n}\n\n/*\n * Return TRUE if word class indicates a word character.\n * Only for characters above 255.\n * Unicode subscript and superscript are not considered word characters.\n * See also dbcs_class() and utf_class() in mbyte.c.\n */\n    static int\nspell_mb_isword_class(int cl, win_T *wp)\n{\n    if (wp->w_s->b_cjk)\n\t// East Asian characters are not considered word characters.\n\treturn cl == 2 || cl == 0x2800;\n    return cl >= 2 && cl != 0x2070 && cl != 0x2080 && cl != 3;\n}\n\n/*\n * Return TRUE if \"p\" points to a word character.\n * Wide version of spell_iswordp().\n */\n    static int\nspell_iswordp_w(int *p, win_T *wp)\n{\n    int\t\t*s;\n\n    if (*p < 256 ? wp->w_s->b_spell_ismw[*p]\n\t\t : (wp->w_s->b_spell_ismw_mb != NULL\n\t\t\t     && vim_strchr(wp->w_s->b_spell_ismw_mb, *p) != NULL))\n\ts = p + 1;\n    else\n\ts = p;\n\n    if (*s > 255)\n    {\n\tif (enc_utf8)\n\t    return spell_mb_isword_class(utf_class(*s), wp);\n\tif (enc_dbcs)\n\t    return spell_mb_isword_class(\n\t\t\t\tdbcs_class((unsigned)*s >> 8, *s & 0xff), wp);\n\treturn 0;\n    }\n    return spelltab.st_isw[*s];\n}\n\n/*\n * Case-fold \"str[len]\" into \"buf[buflen]\".  The result is NUL terminated.\n * Uses the character definitions from the .spl file.\n * When using a multi-byte 'encoding' the length may change!\n * Returns FAIL when something wrong.\n */\n    int\nspell_casefold(\n    win_T\t*wp,\n    char_u\t*str,\n    int\t\tlen,\n    char_u\t*buf,\n    int\t\tbuflen)\n{\n    int\t\ti;\n\n    if (len >= buflen)\n    {\n\tbuf[0] = NUL;\n\treturn FAIL;\t\t// result will not fit\n    }\n\n    if (has_mbyte)\n    {\n\tint\touti = 0;\n\tchar_u\t*p;\n\tint\tc;\n\n\t// Fold one character at a time.\n\tfor (p = str; p < str + len; )\n\t{\n\t    if (outi + MB_MAXBYTES > buflen)\n\t    {\n\t\tbuf[outi] = NUL;\n\t\treturn FAIL;\n\t    }\n\t    c = mb_cptr2char_adv(&p);\n\n\t    // Exception: greek capital sigma 0x03A3 folds to 0x03C3, except\n\t    // when it is the last character in a word, then it folds to\n\t    // 0x03C2.\n\t    if (c == 0x03a3 || c == 0x03c2)\n\t    {\n\t\tif (p == str + len || !spell_iswordp(p, wp))\n\t\t    c = 0x03c2;\n\t\telse\n\t\t    c = 0x03c3;\n\t    }\n\t    else\n\t\tc = SPELL_TOFOLD(c);\n\n\t    outi += mb_char2bytes(c, buf + outi);\n\t}\n\tbuf[outi] = NUL;\n    }\n    else\n    {\n\t// Be quick for non-multibyte encodings.\n\tfor (i = 0; i < len; ++i)\n\t    buf[i] = spelltab.st_fold[str[i]];\n\tbuf[i] = NUL;\n    }\n\n    return OK;\n}\n\n/*\n * Check if the word at line \"lnum\" column \"col\" is required to start with a\n * capital.  This uses 'spellcapcheck' of the current buffer.\n */\n    int\ncheck_need_cap(linenr_T lnum, colnr_T col)\n{\n    int\t\tneed_cap = FALSE;\n    char_u\t*line;\n    char_u\t*line_copy = NULL;\n    char_u\t*p;\n    colnr_T\tendcol;\n    regmatch_T\tregmatch;\n\n    if (curwin->w_s->b_cap_prog == NULL)\n\treturn FALSE;\n\n    line = ml_get_curline();\n    endcol = 0;\n    if (getwhitecols(line) >= (int)col)\n    {\n\t// At start of line, check if previous line is empty or sentence\n\t// ends there.\n\tif (lnum == 1)\n\t    need_cap = TRUE;\n\telse\n\t{\n\t    line = ml_get(lnum - 1);\n\t    if (*skipwhite(line) == NUL)\n\t\tneed_cap = TRUE;\n\t    else\n\t    {\n\t\t// Append a space in place of the line break.\n\t\tline_copy = concat_str(line, (char_u *)\" \");\n\t\tline = line_copy;\n\t\tendcol = (colnr_T)STRLEN(line);\n\t    }\n\t}\n    }\n    else\n\tendcol = col;\n\n    if (endcol > 0)\n    {\n\t// Check if sentence ends before the bad word.\n\tregmatch.regprog = curwin->w_s->b_cap_prog;\n\tregmatch.rm_ic = FALSE;\n\tp = line + endcol;\n\tfor (;;)\n\t{\n\t    MB_PTR_BACK(line, p);\n\t    if (p == line || spell_iswordp_nmw(p, curwin))\n\t\tbreak;\n\t    if (vim_regexec(&regmatch, p, 0)\n\t\t\t\t\t && regmatch.endp[0] == line + endcol)\n\t    {\n\t\tneed_cap = TRUE;\n\t\tbreak;\n\t    }\n\t}\n\tcurwin->w_s->b_cap_prog = regmatch.regprog;\n    }\n\n    vim_free(line_copy);\n\n    return need_cap;\n}\n\n\n/*\n * \":spellrepall\"\n */\n    void\nex_spellrepall(exarg_T *eap UNUSED)\n{\n    pos_T\tpos = curwin->w_cursor;\n    char_u\t*frompat;\n    int\t\taddlen;\n    char_u\t*line;\n    char_u\t*p;\n    int\t\tsave_ws = p_ws;\n    linenr_T\tprev_lnum = 0;\n\n    if (repl_from == NULL || repl_to == NULL)\n    {\n\temsg(_(e_no_previous_spell_replacement));\n\treturn;\n    }\n    addlen = (int)(STRLEN(repl_to) - STRLEN(repl_from));\n\n    frompat = alloc(STRLEN(repl_from) + 7);\n    if (frompat == NULL)\n\treturn;\n    sprintf((char *)frompat, \"\\\\V\\\\<%s\\\\>\", repl_from);\n    p_ws = FALSE;\n\n    sub_nsubs = 0;\n    sub_nlines = 0;\n    curwin->w_cursor.lnum = 0;\n    while (!got_int)\n    {\n\tif (do_search(NULL, '/', '/', frompat, 1L, SEARCH_KEEP, NULL) == 0\n\t\t\t\t\t\t   || u_save_cursor() == FAIL)\n\t    break;\n\n\t// Only replace when the right word isn't there yet.  This happens\n\t// when changing \"etc\" to \"etc.\".\n\tline = ml_get_curline();\n\tif (addlen <= 0 || STRNCMP(line + curwin->w_cursor.col,\n\t\t\t\t\t       repl_to, STRLEN(repl_to)) != 0)\n\t{\n\t    p = alloc(STRLEN(line) + addlen + 1);\n\t    if (p == NULL)\n\t\tbreak;\n\t    mch_memmove(p, line, curwin->w_cursor.col);\n\t    STRCPY(p + curwin->w_cursor.col, repl_to);\n\t    STRCAT(p, line + curwin->w_cursor.col + STRLEN(repl_from));\n\t    ml_replace(curwin->w_cursor.lnum, p, FALSE);\n\t    changed_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\t    if (curbuf->b_has_textprop && addlen != 0)\n\t\tadjust_prop_columns(curwin->w_cursor.lnum,\n\t\t\t\t curwin->w_cursor.col, addlen, APC_SUBSTITUTE);\n\n\t    if (curwin->w_cursor.lnum != prev_lnum)\n\t    {\n\t\t++sub_nlines;\n\t\tprev_lnum = curwin->w_cursor.lnum;\n\t    }\n\t    ++sub_nsubs;\n\t}\n\tcurwin->w_cursor.col += (colnr_T)STRLEN(repl_to);\n    }\n\n    p_ws = save_ws;\n    curwin->w_cursor = pos;\n    vim_free(frompat);\n\n    if (sub_nsubs == 0)\n\tsemsg(_(e_not_found_str), repl_from);\n    else\n\tdo_sub_msg(FALSE);\n}\n\n/*\n * Make a copy of \"word\", with the first letter upper or lower cased, to\n * \"wcopy[MAXWLEN]\".  \"word\" must not be empty.\n * The result is NUL terminated.\n */\n    void\nonecap_copy(\n    char_u\t*word,\n    char_u\t*wcopy,\n    int\t\tupper)\t    // TRUE: first letter made upper case\n{\n    char_u\t*p;\n    int\t\tc;\n    int\t\tl;\n\n    p = word;\n    if (has_mbyte)\n\tc = mb_cptr2char_adv(&p);\n    else\n\tc = *p++;\n    if (upper)\n\tc = SPELL_TOUPPER(c);\n    else\n\tc = SPELL_TOFOLD(c);\n    if (has_mbyte)\n\tl = mb_char2bytes(c, wcopy);\n    else\n    {\n\tl = 1;\n\twcopy[0] = c;\n    }\n    vim_strncpy(wcopy + l, p, MAXWLEN - l - 1);\n}\n\n/*\n * Make a copy of \"word\" with all the letters upper cased into\n * \"wcopy[MAXWLEN]\".  The result is NUL terminated.\n */\n    void\nallcap_copy(char_u *word, char_u *wcopy)\n{\n    char_u\t*s;\n    char_u\t*d;\n    int\t\tc;\n\n    d = wcopy;\n    for (s = word; *s != NUL; )\n    {\n\tif (has_mbyte)\n\t    c = mb_cptr2char_adv(&s);\n\telse\n\t    c = *s++;\n\n\t// We only change 0xdf to SS when we are certain latin1 is used.  It\n\t// would cause weird errors in other 8-bit encodings.\n\tif (enc_latin1like && c == 0xdf)\n\t{\n\t    c = 'S';\n\t    if (d - wcopy >= MAXWLEN - 1)\n\t\tbreak;\n\t    *d++ = c;\n\t}\n\telse\n\t    c = SPELL_TOUPPER(c);\n\n\tif (has_mbyte)\n\t{\n\t    if (d - wcopy >= MAXWLEN - MB_MAXBYTES)\n\t\tbreak;\n\t    d += mb_char2bytes(c, d);\n\t}\n\telse\n\t{\n\t    if (d - wcopy >= MAXWLEN - 1)\n\t\tbreak;\n\t    *d++ = c;\n\t}\n    }\n    *d = NUL;\n}\n\n/*\n * Case-folding may change the number of bytes: Count nr of chars in\n * fword[flen] and return the byte length of that many chars in \"word\".\n */\n    int\nnofold_len(char_u *fword, int flen, char_u *word)\n{\n    char_u\t*p;\n    int\t\ti = 0;\n\n    for (p = fword; p < fword + flen; MB_PTR_ADV(p))\n\t++i;\n    for (p = word; i > 0; MB_PTR_ADV(p))\n\t--i;\n    return (int)(p - word);\n}\n\n/*\n * Copy \"fword\" to \"cword\", fixing case according to \"flags\".\n */\n    void\nmake_case_word(char_u *fword, char_u *cword, int flags)\n{\n    if (flags & WF_ALLCAP)\n\t// Make it all upper-case\n\tallcap_copy(fword, cword);\n    else if (flags & WF_ONECAP)\n\t// Make the first letter upper-case\n\tonecap_copy(fword, cword, TRUE);\n    else\n\t// Use goodword as-is.\n\tSTRCPY(cword, fword);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Soundfold a string, for soundfold().\n * Result is in allocated memory, NULL for an error.\n */\n    char_u *\neval_soundfold(char_u *word)\n{\n    langp_T\t*lp;\n    char_u\tsound[MAXWLEN];\n    int\t\tlpi;\n\n    if (curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t// Use the sound-folding of the first language that supports it.\n\tfor (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n\t{\n\t    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\t    if (lp->lp_slang->sl_sal.ga_len > 0)\n\t    {\n\t\t// soundfold the word\n\t\tspell_soundfold(lp->lp_slang, word, FALSE, sound);\n\t\treturn vim_strsave(sound);\n\t    }\n\t}\n\n    // No language with sound folding, return word as-is.\n    return vim_strsave(word);\n}\n#endif\n\n/*\n * Turn \"inword\" into its sound-a-like equivalent in \"res[MAXWLEN]\".\n *\n * There are many ways to turn a word into a sound-a-like representation.  The\n * oldest is Soundex (1918!).   A nice overview can be found in \"Approximate\n * swedish name matching - survey and test of different algorithms\" by Klas\n * Erikson.\n *\n * We support two methods:\n * 1. SOFOFROM/SOFOTO do a simple character mapping.\n * 2. SAL items define a more advanced sound-folding (and much slower).\n */\n    void\nspell_soundfold(\n    slang_T\t*slang,\n    char_u\t*inword,\n    int\t\tfolded,\t    // \"inword\" is already case-folded\n    char_u\t*res)\n{\n    char_u\tfword[MAXWLEN];\n    char_u\t*word;\n\n    if (slang->sl_sofo)\n\t// SOFOFROM and SOFOTO used\n\tspell_soundfold_sofo(slang, inword, res);\n    else\n    {\n\t// SAL items used.  Requires the word to be case-folded.\n\tif (folded)\n\t    word = inword;\n\telse\n\t{\n\t    (void)spell_casefold(curwin,\n\t\t\t\t  inword, (int)STRLEN(inword), fword, MAXWLEN);\n\t    word = fword;\n\t}\n\n\tif (has_mbyte)\n\t    spell_soundfold_wsal(slang, word, res);\n\telse\n\t    spell_soundfold_sal(slang, word, res);\n    }\n}\n\n/*\n * Perform sound folding of \"inword\" into \"res\" according to SOFOFROM and\n * SOFOTO lines.\n */\n    static void\nspell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res)\n{\n    char_u\t*s;\n    int\t\tri = 0;\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tint\tprevc = 0;\n\tint\t*ip;\n\n\t// The sl_sal_first[] table contains the translation for chars up to\n\t// 255, sl_sal the rest.\n\tfor (s = inword; *s != NUL; )\n\t{\n\t    c = mb_cptr2char_adv(&s);\n\t    if (enc_utf8 ? utf_class(c) == 0 : VIM_ISWHITE(c))\n\t\tc = ' ';\n\t    else if (c < 256)\n\t\tc = slang->sl_sal_first[c];\n\t    else\n\t    {\n\t\tip = ((int **)slang->sl_sal.ga_data)[c & 0xff];\n\t\tif (ip == NULL)\t\t// empty list, can't match\n\t\t    c = NUL;\n\t\telse\n\t\t    for (;;)\t\t// find \"c\" in the list\n\t\t    {\n\t\t\tif (*ip == 0)\t// not found\n\t\t\t{\n\t\t\t    c = NUL;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (*ip == c)\t// match!\n\t\t\t{\n\t\t\t    c = ip[1];\n\t\t\t    break;\n\t\t\t}\n\t\t\tip += 2;\n\t\t    }\n\t    }\n\n\t    if (c != NUL && c != prevc)\n\t    {\n\t\tri += mb_char2bytes(c, res + ri);\n\t\tif (ri + MB_MAXBYTES > MAXWLEN)\n\t\t    break;\n\t\tprevc = c;\n\t    }\n\t}\n    }\n    else\n    {\n\t// The sl_sal_first[] table contains the translation.\n\tfor (s = inword; (c = *s) != NUL; ++s)\n\t{\n\t    if (VIM_ISWHITE(c))\n\t\tc = ' ';\n\t    else\n\t\tc = slang->sl_sal_first[c];\n\t    if (c != NUL && (ri == 0 || res[ri - 1] != c))\n\t\tres[ri++] = c;\n\t}\n    }\n\n    res[ri] = NUL;\n}\n\n    static void\nspell_soundfold_sal(slang_T *slang, char_u *inword, char_u *res)\n{\n    salitem_T\t*smp;\n    char_u\tword[MAXWLEN];\n    char_u\t*s = inword;\n    char_u\t*t;\n    char_u\t*pf;\n    int\t\ti, j, z;\n    int\t\treslen;\n    int\t\tn, k = 0;\n    int\t\tz0;\n    int\t\tk0;\n    int\t\tn0;\n    int\t\tc;\n    int\t\tpri;\n    int\t\tp0 = -333;\n    int\t\tc0;\n\n    // Remove accents, if wanted.  We actually remove all non-word characters.\n    // But keep white space.  We need a copy, the word may be changed here.\n    if (slang->sl_rem_accents)\n    {\n\tt = word;\n\twhile (*s != NUL)\n\t{\n\t    if (VIM_ISWHITE(*s))\n\t    {\n\t\t*t++ = ' ';\n\t\ts = skipwhite(s);\n\t    }\n\t    else\n\t    {\n\t\tif (spell_iswordp_nmw(s, curwin))\n\t\t    *t++ = *s;\n\t\t++s;\n\t    }\n\t}\n\t*t = NUL;\n    }\n    else\n\tvim_strncpy(word, s, MAXWLEN - 1);\n\n    smp = (salitem_T *)slang->sl_sal.ga_data;\n\n    /*\n     * This comes from Aspell phonet.cpp.  Converted from C++ to C.\n     * Changed to keep spaces.\n     */\n    i = reslen = z = 0;\n    while ((c = word[i]) != NUL)\n    {\n\t// Start with the first rule that has the character in the word.\n\tn = slang->sl_sal_first[c];\n\tz0 = 0;\n\n\tif (n >= 0)\n\t{\n\t    // check all rules for the same letter\n\t    for (; (s = smp[n].sm_lead)[0] == c; ++n)\n\t    {\n\t\t// Quickly skip entries that don't match the word.  Most\n\t\t// entries are less than three chars, optimize for that.\n\t\tk = smp[n].sm_leadlen;\n\t\tif (k > 1)\n\t\t{\n\t\t    if (word[i + 1] != s[1])\n\t\t\tcontinue;\n\t\t    if (k > 2)\n\t\t    {\n\t\t\tfor (j = 2; j < k; ++j)\n\t\t\t    if (word[i + j] != s[j])\n\t\t\t\tbreak;\n\t\t\tif (j < k)\n\t\t\t    continue;\n\t\t    }\n\t\t}\n\n\t\tif ((pf = smp[n].sm_oneof) != NULL)\n\t\t{\n\t\t    // Check for match with one of the chars in \"sm_oneof\".\n\t\t    while (*pf != NUL && *pf != word[i + k])\n\t\t\t++pf;\n\t\t    if (*pf == NUL)\n\t\t\tcontinue;\n\t\t    ++k;\n\t\t}\n\t\ts = smp[n].sm_rules;\n\t\tpri = 5;    // default priority\n\n\t\tp0 = *s;\n\t\tk0 = k;\n\t\twhile (*s == '-' && k > 1)\n\t\t{\n\t\t    k--;\n\t\t    s++;\n\t\t}\n\t\tif (*s == '<')\n\t\t    s++;\n\t\tif (VIM_ISDIGIT(*s))\n\t\t{\n\t\t    // determine priority\n\t\t    pri = *s - '0';\n\t\t    s++;\n\t\t}\n\t\tif (*s == '^' && *(s + 1) == '^')\n\t\t    s++;\n\n\t\tif (*s == NUL\n\t\t\t|| (*s == '^'\n\t\t\t    && (i == 0 || !(word[i - 1] == ' '\n\t\t\t\t      || spell_iswordp(word + i - 1, curwin)))\n\t\t\t    && (*(s + 1) != '$'\n\t\t\t\t|| (!spell_iswordp(word + i + k0, curwin))))\n\t\t\t|| (*s == '$' && i > 0\n\t\t\t    && spell_iswordp(word + i - 1, curwin)\n\t\t\t    && (!spell_iswordp(word + i + k0, curwin))))\n\t\t{\n\t\t    // search for followup rules, if:\n\t\t    // followup and k > 1  and  NO '-' in searchstring\n\t\t    c0 = word[i + k - 1];\n\t\t    n0 = slang->sl_sal_first[c0];\n\n\t\t    if (slang->sl_followup && k > 1 && n0 >= 0\n\t\t\t\t\t   && p0 != '-' && word[i + k] != NUL)\n\t\t    {\n\t\t\t// test follow-up rule for \"word[i + k]\"\n\t\t\tfor ( ; (s = smp[n0].sm_lead)[0] == c0; ++n0)\n\t\t\t{\n\t\t\t    // Quickly skip entries that don't match the word.\n\t\t\t    //\n\t\t\t    k0 = smp[n0].sm_leadlen;\n\t\t\t    if (k0 > 1)\n\t\t\t    {\n\t\t\t\tif (word[i + k] != s[1])\n\t\t\t\t    continue;\n\t\t\t\tif (k0 > 2)\n\t\t\t\t{\n\t\t\t\t    pf = word + i + k + 1;\n\t\t\t\t    for (j = 2; j < k0; ++j)\n\t\t\t\t\tif (*pf++ != s[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (j < k0)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    k0 += k - 1;\n\n\t\t\t    if ((pf = smp[n0].sm_oneof) != NULL)\n\t\t\t    {\n\t\t\t\t// Check for match with one of the chars in\n\t\t\t\t// \"sm_oneof\".\n\t\t\t\twhile (*pf != NUL && *pf != word[i + k0])\n\t\t\t\t    ++pf;\n\t\t\t\tif (*pf == NUL)\n\t\t\t\t    continue;\n\t\t\t\t++k0;\n\t\t\t    }\n\n\t\t\t    p0 = 5;\n\t\t\t    s = smp[n0].sm_rules;\n\t\t\t    while (*s == '-')\n\t\t\t    {\n\t\t\t\t// \"k0\" gets NOT reduced because\n\t\t\t\t// \"if (k0 == k)\"\n\t\t\t\ts++;\n\t\t\t    }\n\t\t\t    if (*s == '<')\n\t\t\t\ts++;\n\t\t\t    if (VIM_ISDIGIT(*s))\n\t\t\t    {\n\t\t\t\tp0 = *s - '0';\n\t\t\t\ts++;\n\t\t\t    }\n\n\t\t\t    if (*s == NUL\n\t\t\t\t    // *s == '^' cuts\n\t\t\t\t    || (*s == '$'\n\t\t\t\t\t    && !spell_iswordp(word + i + k0,\n\t\t\t\t\t\t\t\t     curwin)))\n\t\t\t    {\n\t\t\t\tif (k0 == k)\n\t\t\t\t    // this is just a piece of the string\n\t\t\t\t    continue;\n\n\t\t\t\tif (p0 < pri)\n\t\t\t\t    // priority too low\n\t\t\t\t    continue;\n\t\t\t\t// rule fits; stop search\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (p0 >= pri && smp[n0].sm_lead[0] == c0)\n\t\t\t    continue;\n\t\t    }\n\n\t\t    // replace string\n\t\t    s = smp[n].sm_to;\n\t\t    if (s == NULL)\n\t\t\ts = (char_u *)\"\";\n\t\t    pf = smp[n].sm_rules;\n\t\t    p0 = (vim_strchr(pf, '<') != NULL) ? 1 : 0;\n\t\t    if (p0 == 1 && z == 0)\n\t\t    {\n\t\t\t// rule with '<' is used\n\t\t\tif (reslen > 0 && *s != NUL && (res[reslen - 1] == c\n\t\t\t\t\t\t    || res[reslen - 1] == *s))\n\t\t\t    reslen--;\n\t\t\tz0 = 1;\n\t\t\tz = 1;\n\t\t\tk0 = 0;\n\t\t\twhile (*s != NUL && word[i + k0] != NUL)\n\t\t\t{\n\t\t\t    word[i + k0] = *s;\n\t\t\t    k0++;\n\t\t\t    s++;\n\t\t\t}\n\t\t\tif (k > k0)\n\t\t\t    STRMOVE(word + i + k0, word + i + k);\n\n\t\t\t// new \"actual letter\"\n\t\t\tc = word[i];\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// no '<' rule used\n\t\t\ti += k - 1;\n\t\t\tz = 0;\n\t\t\twhile (*s != NUL && s[1] != NUL && reslen < MAXWLEN)\n\t\t\t{\n\t\t\t    if (reslen == 0 || res[reslen - 1] != *s)\n\t\t\t\tres[reslen++] = *s;\n\t\t\t    s++;\n\t\t\t}\n\t\t\t// new \"actual letter\"\n\t\t\tc = *s;\n\t\t\tif (strstr((char *)pf, \"^^\") != NULL)\n\t\t\t{\n\t\t\t    if (c != NUL)\n\t\t\t\tres[reslen++] = c;\n\t\t\t    STRMOVE(word, word + i + 1);\n\t\t\t    i = 0;\n\t\t\t    z0 = 1;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse if (VIM_ISWHITE(c))\n\t{\n\t    c = ' ';\n\t    k = 1;\n\t}\n\n\tif (z0 == 0)\n\t{\n\t    if (k && !p0 && reslen < MAXWLEN && c != NUL\n\t\t    && (!slang->sl_collapse || reslen == 0\n\t\t\t\t\t\t     || res[reslen - 1] != c))\n\t\t// condense only double letters\n\t\tres[reslen++] = c;\n\n\t    i++;\n\t    z = 0;\n\t    k = 0;\n\t}\n    }\n\n    res[reslen] = NUL;\n}\n\n/*\n * Turn \"inword\" into its sound-a-like equivalent in \"res[MAXWLEN]\".\n * Multi-byte version of spell_soundfold().\n */\n    static void\nspell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res)\n{\n    salitem_T\t*smp = (salitem_T *)slang->sl_sal.ga_data;\n    int\t\tword[MAXWLEN];\n    int\t\twres[MAXWLEN];\n    int\t\tl;\n    char_u\t*s;\n    int\t\t*ws;\n    char_u\t*t;\n    int\t\t*pf;\n    int\t\ti, j, z;\n    int\t\treslen;\n    int\t\tn, k = 0;\n    int\t\tz0;\n    int\t\tk0;\n    int\t\tn0;\n    int\t\tc;\n    int\t\tpri;\n    int\t\tp0 = -333;\n    int\t\tc0;\n    int\t\tdid_white = FALSE;\n    int\t\twordlen;\n\n\n    /*\n     * Convert the multi-byte string to a wide-character string.\n     * Remove accents, if wanted.  We actually remove all non-word characters.\n     * But keep white space.\n     */\n    wordlen = 0;\n    for (s = inword; *s != NUL; )\n    {\n\tt = s;\n\tc = mb_cptr2char_adv(&s);\n\tif (slang->sl_rem_accents)\n\t{\n\t    if (enc_utf8 ? utf_class(c) == 0 : VIM_ISWHITE(c))\n\t    {\n\t\tif (did_white)\n\t\t    continue;\n\t\tc = ' ';\n\t\tdid_white = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tdid_white = FALSE;\n\t\tif (!spell_iswordp_nmw(t, curwin))\n\t\t    continue;\n\t    }\n\t}\n\tword[wordlen++] = c;\n    }\n    word[wordlen] = NUL;\n\n    /*\n     * This algorithm comes from Aspell phonet.cpp.\n     * Converted from C++ to C.  Added support for multi-byte chars.\n     * Changed to keep spaces.\n     */\n    i = reslen = z = 0;\n    while ((c = word[i]) != NUL)\n    {\n\t// Start with the first rule that has the character in the word.\n\tn = slang->sl_sal_first[c & 0xff];\n\tz0 = 0;\n\n\tif (n >= 0)\n\t{\n\t    // Check all rules for the same index byte.\n\t    // If c is 0x300 need extra check for the end of the array, as\n\t    // (c & 0xff) is NUL.\n\t    for (; ((ws = smp[n].sm_lead_w)[0] & 0xff) == (c & 0xff)\n\t\t\t\t\t\t\t && ws[0] != NUL; ++n)\n\t    {\n\t\t// Quickly skip entries that don't match the word.  Most\n\t\t// entries are less than three chars, optimize for that.\n\t\tif (c != ws[0])\n\t\t    continue;\n\t\tk = smp[n].sm_leadlen;\n\t\tif (k > 1)\n\t\t{\n\t\t    if (word[i + 1] != ws[1])\n\t\t\tcontinue;\n\t\t    if (k > 2)\n\t\t    {\n\t\t\tfor (j = 2; j < k; ++j)\n\t\t\t    if (word[i + j] != ws[j])\n\t\t\t\tbreak;\n\t\t\tif (j < k)\n\t\t\t    continue;\n\t\t    }\n\t\t}\n\n\t\tif ((pf = smp[n].sm_oneof_w) != NULL)\n\t\t{\n\t\t    // Check for match with one of the chars in \"sm_oneof\".\n\t\t    while (*pf != NUL && *pf != word[i + k])\n\t\t\t++pf;\n\t\t    if (*pf == NUL)\n\t\t\tcontinue;\n\t\t    ++k;\n\t\t}\n\t\ts = smp[n].sm_rules;\n\t\tpri = 5;    // default priority\n\n\t\tp0 = *s;\n\t\tk0 = k;\n\t\twhile (*s == '-' && k > 1)\n\t\t{\n\t\t    k--;\n\t\t    s++;\n\t\t}\n\t\tif (*s == '<')\n\t\t    s++;\n\t\tif (VIM_ISDIGIT(*s))\n\t\t{\n\t\t    // determine priority\n\t\t    pri = *s - '0';\n\t\t    s++;\n\t\t}\n\t\tif (*s == '^' && *(s + 1) == '^')\n\t\t    s++;\n\n\t\tif (*s == NUL\n\t\t\t|| (*s == '^'\n\t\t\t    && (i == 0 || !(word[i - 1] == ' '\n\t\t\t\t    || spell_iswordp_w(word + i - 1, curwin)))\n\t\t\t    && (*(s + 1) != '$'\n\t\t\t\t|| (!spell_iswordp_w(word + i + k0, curwin))))\n\t\t\t|| (*s == '$' && i > 0\n\t\t\t    && spell_iswordp_w(word + i - 1, curwin)\n\t\t\t    && (!spell_iswordp_w(word + i + k0, curwin))))\n\t\t{\n\t\t    // search for followup rules, if:\n\t\t    // followup and k > 1  and  NO '-' in searchstring\n\t\t    c0 = word[i + k - 1];\n\t\t    n0 = slang->sl_sal_first[c0 & 0xff];\n\n\t\t    if (slang->sl_followup && k > 1 && n0 >= 0\n\t\t\t\t\t   && p0 != '-' && word[i + k] != NUL)\n\t\t    {\n\t\t\t// Test follow-up rule for \"word[i + k]\"; loop over\n\t\t\t// all entries with the same index byte.\n\t\t\tfor ( ; ((ws = smp[n0].sm_lead_w)[0] & 0xff)\n\t\t\t\t\t\t\t == (c0 & 0xff); ++n0)\n\t\t\t{\n\t\t\t    // Quickly skip entries that don't match the word.\n\t\t\t    if (c0 != ws[0])\n\t\t\t\tcontinue;\n\t\t\t    k0 = smp[n0].sm_leadlen;\n\t\t\t    if (k0 > 1)\n\t\t\t    {\n\t\t\t\tif (word[i + k] != ws[1])\n\t\t\t\t    continue;\n\t\t\t\tif (k0 > 2)\n\t\t\t\t{\n\t\t\t\t    pf = word + i + k + 1;\n\t\t\t\t    for (j = 2; j < k0; ++j)\n\t\t\t\t\tif (*pf++ != ws[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (j < k0)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    k0 += k - 1;\n\n\t\t\t    if ((pf = smp[n0].sm_oneof_w) != NULL)\n\t\t\t    {\n\t\t\t\t// Check for match with one of the chars in\n\t\t\t\t// \"sm_oneof\".\n\t\t\t\twhile (*pf != NUL && *pf != word[i + k0])\n\t\t\t\t    ++pf;\n\t\t\t\tif (*pf == NUL)\n\t\t\t\t    continue;\n\t\t\t\t++k0;\n\t\t\t    }\n\n\t\t\t    p0 = 5;\n\t\t\t    s = smp[n0].sm_rules;\n\t\t\t    while (*s == '-')\n\t\t\t    {\n\t\t\t\t// \"k0\" gets NOT reduced because\n\t\t\t\t// \"if (k0 == k)\"\n\t\t\t\ts++;\n\t\t\t    }\n\t\t\t    if (*s == '<')\n\t\t\t\ts++;\n\t\t\t    if (VIM_ISDIGIT(*s))\n\t\t\t    {\n\t\t\t\tp0 = *s - '0';\n\t\t\t\ts++;\n\t\t\t    }\n\n\t\t\t    if (*s == NUL\n\t\t\t\t    // *s == '^' cuts\n\t\t\t\t    || (*s == '$'\n\t\t\t\t\t && !spell_iswordp_w(word + i + k0,\n\t\t\t\t\t\t\t\t     curwin)))\n\t\t\t    {\n\t\t\t\tif (k0 == k)\n\t\t\t\t    // this is just a piece of the string\n\t\t\t\t    continue;\n\n\t\t\t\tif (p0 < pri)\n\t\t\t\t    // priority too low\n\t\t\t\t    continue;\n\t\t\t\t// rule fits; stop search\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (p0 >= pri && (smp[n0].sm_lead_w[0] & 0xff)\n\t\t\t\t\t\t\t       == (c0 & 0xff))\n\t\t\t    continue;\n\t\t    }\n\n\t\t    // replace string\n\t\t    ws = smp[n].sm_to_w;\n\t\t    s = smp[n].sm_rules;\n\t\t    p0 = (vim_strchr(s, '<') != NULL) ? 1 : 0;\n\t\t    if (p0 == 1 && z == 0)\n\t\t    {\n\t\t\t// rule with '<' is used\n\t\t\tif (reslen > 0 && ws != NULL && *ws != NUL\n\t\t\t\t&& (wres[reslen - 1] == c\n\t\t\t\t\t\t    || wres[reslen - 1] == *ws))\n\t\t\t    reslen--;\n\t\t\tz0 = 1;\n\t\t\tz = 1;\n\t\t\tk0 = 0;\n\t\t\tif (ws != NULL)\n\t\t\t    while (*ws != NUL && word[i + k0] != NUL)\n\t\t\t    {\n\t\t\t\tword[i + k0] = *ws;\n\t\t\t\tk0++;\n\t\t\t\tws++;\n\t\t\t    }\n\t\t\tif (k > k0)\n\t\t\t    mch_memmove(word + i + k0, word + i + k,\n\t\t\t\t    sizeof(int) * (wordlen - (i + k) + 1));\n\n\t\t\t// new \"actual letter\"\n\t\t\tc = word[i];\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// no '<' rule used\n\t\t\ti += k - 1;\n\t\t\tz = 0;\n\t\t\tif (ws != NULL)\n\t\t\t    while (*ws != NUL && ws[1] != NUL\n\t\t\t\t\t\t\t  && reslen < MAXWLEN)\n\t\t\t    {\n\t\t\t\tif (reslen == 0 || wres[reslen - 1] != *ws)\n\t\t\t\t    wres[reslen++] = *ws;\n\t\t\t\tws++;\n\t\t\t    }\n\t\t\t// new \"actual letter\"\n\t\t\tif (ws == NULL)\n\t\t\t    c = NUL;\n\t\t\telse\n\t\t\t    c = *ws;\n\t\t\tif (strstr((char *)s, \"^^\") != NULL)\n\t\t\t{\n\t\t\t    if (c != NUL)\n\t\t\t\twres[reslen++] = c;\n\t\t\t    mch_memmove(word, word + i + 1,\n\t\t\t\t       sizeof(int) * (wordlen - (i + 1) + 1));\n\t\t\t    i = 0;\n\t\t\t    z0 = 1;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse if (VIM_ISWHITE(c))\n\t{\n\t    c = ' ';\n\t    k = 1;\n\t}\n\n\tif (z0 == 0)\n\t{\n\t    if (k && !p0 && reslen < MAXWLEN && c != NUL\n\t\t    && (!slang->sl_collapse || reslen == 0\n\t\t\t\t\t\t     || wres[reslen - 1] != c))\n\t\t// condense only double letters\n\t\twres[reslen++] = c;\n\n\t    i++;\n\t    z = 0;\n\t    k = 0;\n\t}\n    }\n\n    // Convert wide characters in \"wres\" to a multi-byte string in \"res\".\n    l = 0;\n    for (n = 0; n < reslen; ++n)\n    {\n\tl += mb_char2bytes(wres[n], res + l);\n\tif (l + MB_MAXBYTES > MAXWLEN)\n\t    break;\n    }\n    res[l] = NUL;\n}\n\n/*\n * \":spellinfo\"\n */\n    void\nex_spellinfo(exarg_T *eap UNUSED)\n{\n    int\t\tlpi;\n    langp_T\t*lp;\n    char_u\t*p;\n\n    if (no_spell_checking(curwin))\n\treturn;\n\n    msg_start();\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len && !got_int; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tmsg_puts(\"file: \");\n\tmsg_puts((char *)lp->lp_slang->sl_fname);\n\tmsg_putchar('\\n');\n\tp = lp->lp_slang->sl_info;\n\tif (p != NULL)\n\t{\n\t    msg_puts((char *)p);\n\t    msg_putchar('\\n');\n\t}\n    }\n    msg_end();\n}\n\n#define DUMPFLAG_KEEPCASE   1\t// round 2: keep-case tree\n#define DUMPFLAG_COUNT\t    2\t// include word count\n#define DUMPFLAG_ICASE\t    4\t// ignore case when finding matches\n#define DUMPFLAG_ONECAP\t    8\t// pattern starts with capital\n#define DUMPFLAG_ALLCAP\t    16\t// pattern is all capitals\n\n/*\n * \":spelldump\"\n */\n    void\nex_spelldump(exarg_T *eap)\n{\n    char_u  *spl;\n    long    dummy;\n\n    if (no_spell_checking(curwin))\n\treturn;\n    (void)get_option_value((char_u*)\"spl\", &dummy, &spl, NULL, OPT_LOCAL);\n\n    // Create a new empty buffer in a new window.\n    do_cmdline_cmd((char_u *)\"new\");\n\n    // enable spelling locally in the new window\n    set_option_value_give_err((char_u*)\"spell\", TRUE, (char_u*)\"\", OPT_LOCAL);\n    set_option_value_give_err((char_u*)\"spl\",  dummy, spl, OPT_LOCAL);\n    vim_free(spl);\n\n    if (!BUFEMPTY())\n\treturn;\n\n    spell_dump_compl(NULL, 0, NULL, eap->forceit ? DUMPFLAG_COUNT : 0);\n\n    // Delete the empty line that we started with.\n    if (curbuf->b_ml.ml_line_count > 1)\n\tml_delete(curbuf->b_ml.ml_line_count);\n\n    redraw_later(NOT_VALID);\n}\n\n/*\n * Go through all possible words and:\n * 1. When \"pat\" is NULL: dump a list of all words in the current buffer.\n *\t\"ic\" and \"dir\" are not used.\n * 2. When \"pat\" is not NULL: add matching words to insert mode completion.\n */\n    void\nspell_dump_compl(\n    char_u\t*pat,\t    // leading part of the word\n    int\t\tic,\t    // ignore case\n    int\t\t*dir,\t    // direction for adding matches\n    int\t\tdumpflags_arg)\t// DUMPFLAG_*\n{\n    langp_T\t*lp;\n    slang_T\t*slang;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\tword[MAXWLEN];\n    int\t\tc;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    linenr_T\tlnum = 0;\n    int\t\tround;\n    int\t\tdepth;\n    int\t\tn;\n    int\t\tflags;\n    char_u\t*region_names = NULL;\t    // region names being used\n    int\t\tdo_region = TRUE;\t    // dump region names and numbers\n    char_u\t*p;\n    int\t\tlpi;\n    int\t\tdumpflags = dumpflags_arg;\n    int\t\tpatlen;\n\n    // When ignoring case or when the pattern starts with capital pass this on\n    // to dump_word().\n    if (pat != NULL)\n    {\n\tif (ic)\n\t    dumpflags |= DUMPFLAG_ICASE;\n\telse\n\t{\n\t    n = captype(pat, NULL);\n\t    if (n == WF_ONECAP)\n\t\tdumpflags |= DUMPFLAG_ONECAP;\n\t    else if (n == WF_ALLCAP && (int)STRLEN(pat) > mb_ptr2len(pat))\n\t\tdumpflags |= DUMPFLAG_ALLCAP;\n\t}\n    }\n\n    // Find out if we can support regions: All languages must support the same\n    // regions or none at all.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tp = lp->lp_slang->sl_regions;\n\tif (p[0] != 0)\n\t{\n\t    if (region_names == NULL)\t    // first language with regions\n\t\tregion_names = p;\n\t    else if (STRCMP(region_names, p) != 0)\n\t    {\n\t\tdo_region = FALSE;\t    // region names are different\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (do_region && region_names != NULL)\n    {\n\tif (pat == NULL)\n\t{\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"/regions=%s\", region_names);\n\t    ml_append(lnum++, IObuff, (colnr_T)0, FALSE);\n\t}\n    }\n    else\n\tdo_region = FALSE;\n\n    /*\n     * Loop over all files loaded for the entries in 'spelllang'.\n     */\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tslang = lp->lp_slang;\n\tif (slang->sl_fbyts == NULL)\t    // reloading failed\n\t    continue;\n\n\tif (pat == NULL)\n\t{\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"# file: %s\", slang->sl_fname);\n\t    ml_append(lnum++, IObuff, (colnr_T)0, FALSE);\n\t}\n\n\t// When matching with a pattern and there are no prefixes only use\n\t// parts of the tree that match \"pat\".\n\tif (pat != NULL && slang->sl_pbyts == NULL)\n\t    patlen = (int)STRLEN(pat);\n\telse\n\t    patlen = -1;\n\n\t// round 1: case-folded tree\n\t// round 2: keep-case tree\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    if (round == 1)\n\t    {\n\t\tdumpflags &= ~DUMPFLAG_KEEPCASE;\n\t\tbyts = slang->sl_fbyts;\n\t\tidxs = slang->sl_fidxs;\n\t    }\n\t    else\n\t    {\n\t\tdumpflags |= DUMPFLAG_KEEPCASE;\n\t\tbyts = slang->sl_kbyts;\n\t\tidxs = slang->sl_kidxs;\n\t    }\n\t    if (byts == NULL)\n\t\tcontinue;\t\t// array is empty\n\n\t    depth = 0;\n\t    arridx[0] = 0;\n\t    curi[0] = 1;\n\t    while (depth >= 0 && !got_int\n\t\t\t\t  && (pat == NULL || !ins_compl_interrupted()))\n\t    {\n\t\tif (curi[depth] > byts[arridx[depth]])\n\t\t{\n\t\t    // Done all bytes at this node, go up one level.\n\t\t    --depth;\n\t\t    line_breakcheck();\n\t\t    ins_compl_check_keys(50, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Do one more byte at this node.\n\t\t    n = arridx[depth] + curi[depth];\n\t\t    ++curi[depth];\n\t\t    c = byts[n];\n\t\t    if (c == 0)\n\t\t    {\n\t\t\t// End of word, deal with the word.\n\t\t\t// Don't use keep-case words in the fold-case tree,\n\t\t\t// they will appear in the keep-case tree.\n\t\t\t// Only use the word when the region matches.\n\t\t\tflags = (int)idxs[n];\n\t\t\tif ((round == 2 || (flags & WF_KEEPCAP) == 0)\n\t\t\t\t&& (flags & WF_NEEDCOMP) == 0\n\t\t\t\t&& (do_region\n\t\t\t\t    || (flags & WF_REGION) == 0\n\t\t\t\t    || (((unsigned)flags >> 16)\n\t\t\t\t\t\t       & lp->lp_region) != 0))\n\t\t\t{\n\t\t\t    word[depth] = NUL;\n\t\t\t    if (!do_region)\n\t\t\t\tflags &= ~WF_REGION;\n\n\t\t\t    // Dump the basic word if there is no prefix or\n\t\t\t    // when it's the first one.\n\t\t\t    c = (unsigned)flags >> 24;\n\t\t\t    if (c == 0 || curi[depth] == 2)\n\t\t\t    {\n\t\t\t\tdump_word(slang, word, pat, dir,\n\t\t\t\t\t\t      dumpflags, flags, lnum);\n\t\t\t\tif (pat == NULL)\n\t\t\t\t    ++lnum;\n\t\t\t    }\n\n\t\t\t    // Apply the prefix, if there is one.\n\t\t\t    if (c != 0)\n\t\t\t\tlnum = dump_prefixes(slang, word, pat, dir,\n\t\t\t\t\t\t      dumpflags, flags, lnum);\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Normal char, go one level deeper.\n\t\t\tword[depth++] = c;\n\t\t\tarridx[depth] = idxs[n];\n\t\t\tcuri[depth] = 1;\n\n\t\t\t// Check if this character matches with the pattern.\n\t\t\t// If not skip the whole tree below it.\n\t\t\t// Always ignore case here, dump_word() will check\n\t\t\t// proper case later.  This isn't exactly right when\n\t\t\t// length changes for multi-byte characters with\n\t\t\t// ignore case...\n\t\t\tif (depth <= patlen\n\t\t\t\t\t&& MB_STRNICMP(word, pat, depth) != 0)\n\t\t\t    --depth;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * Dump one word: apply case modifications and append a line to the buffer.\n * When \"lnum\" is zero add insert mode completion.\n */\n    static void\ndump_word(\n    slang_T\t*slang,\n    char_u\t*word,\n    char_u\t*pat,\n    int\t\t*dir,\n    int\t\tdumpflags,\n    int\t\twordflags,\n    linenr_T\tlnum)\n{\n    int\t\tkeepcap = FALSE;\n    char_u\t*p;\n    char_u\t*tw;\n    char_u\tcword[MAXWLEN];\n    char_u\tbadword[MAXWLEN + 10];\n    int\t\ti;\n    int\t\tflags = wordflags;\n\n    if (dumpflags & DUMPFLAG_ONECAP)\n\tflags |= WF_ONECAP;\n    if (dumpflags & DUMPFLAG_ALLCAP)\n\tflags |= WF_ALLCAP;\n\n    if ((dumpflags & DUMPFLAG_KEEPCASE) == 0 && (flags & WF_CAPMASK) != 0)\n    {\n\t// Need to fix case according to \"flags\".\n\tmake_case_word(word, cword, flags);\n\tp = cword;\n    }\n    else\n    {\n\tp = word;\n\tif ((dumpflags & DUMPFLAG_KEEPCASE)\n\t\t&& ((captype(word, NULL) & WF_KEEPCAP) == 0\n\t\t\t\t\t\t || (flags & WF_FIXCAP) != 0))\n\t    keepcap = TRUE;\n    }\n    tw = p;\n\n    if (pat == NULL)\n    {\n\t// Add flags and regions after a slash.\n\tif ((flags & (WF_BANNED | WF_RARE | WF_REGION)) || keepcap)\n\t{\n\t    STRCPY(badword, p);\n\t    STRCAT(badword, \"/\");\n\t    if (keepcap)\n\t\tSTRCAT(badword, \"=\");\n\t    if (flags & WF_BANNED)\n\t\tSTRCAT(badword, \"!\");\n\t    else if (flags & WF_RARE)\n\t\tSTRCAT(badword, \"?\");\n\t    if (flags & WF_REGION)\n\t\tfor (i = 0; i < 7; ++i)\n\t\t    if (flags & (0x10000 << i))\n\t\t\tsprintf((char *)badword + STRLEN(badword), \"%d\", i + 1);\n\t    p = badword;\n\t}\n\n\tif (dumpflags & DUMPFLAG_COUNT)\n\t{\n\t    hashitem_T  *hi;\n\n\t    // Include the word count for \":spelldump!\".\n\t    hi = hash_find(&slang->sl_wordcount, tw);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"%s\\t%d\",\n\t\t\t\t\t\t     tw, HI2WC(hi)->wc_count);\n\t\tp = IObuff;\n\t    }\n\t}\n\n\tml_append(lnum, p, (colnr_T)0, FALSE);\n    }\n    else if (((dumpflags & DUMPFLAG_ICASE)\n\t\t    ? MB_STRNICMP(p, pat, STRLEN(pat)) == 0\n\t\t    : STRNCMP(p, pat, STRLEN(pat)) == 0)\n\t\t&& ins_compl_add_infercase(p, (int)STRLEN(p),\n\t\t\t\t\t  p_ic, NULL, *dir, FALSE) == OK)\n\t// if dir was BACKWARD then honor it just once\n\t*dir = FORWARD;\n}\n\n/*\n * For \":spelldump\": Find matching prefixes for \"word\".  Prepend each to\n * \"word\" and append a line to the buffer.\n * When \"lnum\" is zero add insert mode completion.\n * Return the updated line number.\n */\n    static linenr_T\ndump_prefixes(\n    slang_T\t*slang,\n    char_u\t*word,\t    // case-folded word\n    char_u\t*pat,\n    int\t\t*dir,\n    int\t\tdumpflags,\n    int\t\tflags,\t    // flags with prefix ID\n    linenr_T\tstartlnum)\n{\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\tprefix[MAXWLEN];\n    char_u\tword_up[MAXWLEN];\n    int\t\thas_word_up = FALSE;\n    int\t\tc;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    linenr_T\tlnum = startlnum;\n    int\t\tdepth;\n    int\t\tn;\n    int\t\tlen;\n    int\t\ti;\n\n    // If the word starts with a lower-case letter make the word with an\n    // upper-case letter in word_up[].\n    c = PTR2CHAR(word);\n    if (SPELL_TOUPPER(c) != c)\n    {\n\tonecap_copy(word, word_up, TRUE);\n\thas_word_up = TRUE;\n    }\n\n    byts = slang->sl_pbyts;\n    idxs = slang->sl_pidxs;\n    if (byts != NULL)\t\t// array not is empty\n    {\n\t/*\n\t * Loop over all prefixes, building them byte-by-byte in prefix[].\n\t * When at the end of a prefix check that it supports \"flags\".\n\t */\n\tdepth = 0;\n\tarridx[0] = 0;\n\tcuri[0] = 1;\n\twhile (depth >= 0 && !got_int)\n\t{\n\t    n = arridx[depth];\n\t    len = byts[n];\n\t    if (curi[depth] > len)\n\t    {\n\t\t// Done all bytes at this node, go up one level.\n\t\t--depth;\n\t\tline_breakcheck();\n\t    }\n\t    else\n\t    {\n\t\t// Do one more byte at this node.\n\t\tn += curi[depth];\n\t\t++curi[depth];\n\t\tc = byts[n];\n\t\tif (c == 0)\n\t\t{\n\t\t    // End of prefix, find out how many IDs there are.\n\t\t    for (i = 1; i < len; ++i)\n\t\t\tif (byts[n + i] != 0)\n\t\t\t    break;\n\t\t    curi[depth] += i - 1;\n\n\t\t    c = valid_word_prefix(i, n, flags, word, slang, FALSE);\n\t\t    if (c != 0)\n\t\t    {\n\t\t\tvim_strncpy(prefix + depth, word, MAXWLEN - depth - 1);\n\t\t\tdump_word(slang, prefix, pat, dir, dumpflags,\n\t\t\t\t(c & WF_RAREPFX) ? (flags | WF_RARE)\n\t\t\t\t\t\t\t       : flags, lnum);\n\t\t\tif (lnum != 0)\n\t\t\t    ++lnum;\n\t\t    }\n\n\t\t    // Check for prefix that matches the word when the\n\t\t    // first letter is upper-case, but only if the prefix has\n\t\t    // a condition.\n\t\t    if (has_word_up)\n\t\t    {\n\t\t\tc = valid_word_prefix(i, n, flags, word_up, slang,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t\tif (c != 0)\n\t\t\t{\n\t\t\t    vim_strncpy(prefix + depth, word_up,\n\t\t\t\t\t\t\t MAXWLEN - depth - 1);\n\t\t\t    dump_word(slang, prefix, pat, dir, dumpflags,\n\t\t\t\t    (c & WF_RAREPFX) ? (flags | WF_RARE)\n\t\t\t\t\t\t\t       : flags, lnum);\n\t\t\t    if (lnum != 0)\n\t\t\t\t++lnum;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Normal char, go one level deeper.\n\t\t    prefix[depth++] = c;\n\t\t    arridx[depth] = idxs[n];\n\t\t    curi[depth] = 1;\n\t\t}\n\t    }\n\t}\n    }\n\n    return lnum;\n}\n\n/*\n * Move \"p\" to the end of word \"start\".\n * Uses the spell-checking word characters.\n */\n    char_u *\nspell_to_word_end(char_u *start, win_T *win)\n{\n    char_u  *p = start;\n\n    while (*p != NUL && spell_iswordp(p, win))\n\tMB_PTR_ADV(p);\n    return p;\n}\n\n/*\n * For Insert mode completion CTRL-X s:\n * Find start of the word in front of column \"startcol\".\n * We don't check if it is badly spelled, with completion we can only change\n * the word in front of the cursor.\n * Returns the column number of the word.\n */\n    int\nspell_word_start(int startcol)\n{\n    char_u\t*line;\n    char_u\t*p;\n    int\t\tcol = 0;\n\n    if (no_spell_checking(curwin))\n\treturn startcol;\n\n    // Find a word character before \"startcol\".\n    line = ml_get_curline();\n    for (p = line + startcol; p > line; )\n    {\n\tMB_PTR_BACK(line, p);\n\tif (spell_iswordp_nmw(p, curwin))\n\t    break;\n    }\n\n    // Go back to start of the word.\n    while (p > line)\n    {\n\tcol = (int)(p - line);\n\tMB_PTR_BACK(line, p);\n\tif (!spell_iswordp(p, curwin))\n\t    break;\n\tcol = 0;\n    }\n\n    return col;\n}\n\n/*\n * Need to check for 'spellcapcheck' now, the word is removed before\n * expand_spelling() is called.  Therefore the ugly global variable.\n */\nstatic int spell_expand_need_cap;\n\n    void\nspell_expand_check_cap(colnr_T col)\n{\n    spell_expand_need_cap = check_need_cap(curwin->w_cursor.lnum, col);\n}\n\n/*\n * Get list of spelling suggestions.\n * Used for Insert mode completion CTRL-X ?.\n * Returns the number of matches.  The matches are in \"matchp[]\", array of\n * allocated strings.\n */\n    int\nexpand_spelling(\n    linenr_T\tlnum UNUSED,\n    char_u\t*pat,\n    char_u\t***matchp)\n{\n    garray_T\tga;\n\n    spell_suggest_list(&ga, pat, 100, spell_expand_need_cap, TRUE);\n    *matchp = ga.ga_data;\n    return ga.ga_len;\n}\n\n/*\n * Return TRUE if \"val\" is a valid 'spelllang' value.\n */\n    int\nvalid_spelllang(char_u *val)\n{\n    return valid_name(val, \".-_,@\");\n}\n\n/*\n * Return TRUE if \"val\" is a valid 'spellfile' value.\n */\n    int\nvalid_spellfile(char_u *val)\n{\n    char_u *s;\n\n    for (s = val; *s != NUL; ++s)\n\tif (!vim_isfilec(*s) && *s != ',' && *s != ' ')\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Handle side effects of setting 'spell'.\n * Return an error message or NULL for success.\n */\n    char *\ndid_set_spell_option(int is_spellfile)\n{\n    char    *errmsg = NULL;\n    win_T   *wp;\n    int\t    l;\n\n    if (is_spellfile)\n    {\n\tl = (int)STRLEN(curwin->w_s->b_p_spf);\n\tif (l > 0 && (l < 4\n\t\t\t|| STRCMP(curwin->w_s->b_p_spf + l - 4, \".add\") != 0))\n\t    errmsg = e_invalid_argument;\n    }\n\n    if (errmsg == NULL)\n    {\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == curbuf && wp->w_p_spell)\n\t    {\n\t\terrmsg = did_set_spelllang(wp);\n\t\tbreak;\n\t    }\n    }\n    return errmsg;\n}\n\n/*\n * Set curbuf->b_cap_prog to the regexp program for 'spellcapcheck'.\n * Return error message when failed, NULL when OK.\n */\n    char *\ncompile_cap_prog(synblock_T *synblock)\n{\n    regprog_T   *rp = synblock->b_cap_prog;\n    char_u\t*re;\n\n    if (synblock->b_p_spc == NULL || *synblock->b_p_spc == NUL)\n\tsynblock->b_cap_prog = NULL;\n    else\n    {\n\t// Prepend a ^ so that we only match at one column\n\tre = concat_str((char_u *)\"^\", synblock->b_p_spc);\n\tif (re != NULL)\n\t{\n\t    synblock->b_cap_prog = vim_regcomp(re, RE_MAGIC);\n\t    vim_free(re);\n\t    if (synblock->b_cap_prog == NULL)\n\t    {\n\t\tsynblock->b_cap_prog = rp; // restore the previous program\n\t\treturn e_invalid_argument;\n\t    }\n\t}\n    }\n\n    vim_regfree(rp);\n    return NULL;\n}\n\n#endif  // FEAT_SPELL\n", "\" Test for spell checking with 'encoding' set to utf-8\n\nsource check.vim\nCheckFeature spell\n\nscriptencoding utf-8\n\nfunc TearDown()\n  set nospell\n  call delete('Xtest.aff')\n  call delete('Xtest.dic')\n  call delete('Xtest.utf-8.add')\n  call delete('Xtest.utf-8.add.spl')\n  call delete('Xtest.utf-8.spl')\n  call delete('Xtest.utf-8.sug')\nendfunc\n\nlet g:test_data_aff1 = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\u00eb\u00e9\u00e8\u00ea\u00ef\u00ee\u00e4\u00e0\u00e2\u00f6\u00fc\u00fb'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00df\u00ff\",\n      \\\"LOW  \u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00df\u00ff\",\n      \\\"UPP  \u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00ff\",\n      \\\"\",\n      \\\"SOFOFROM abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xBF\",\n      \\\"SOFOTO   ebctefghejklnnepkrstevvkesebctefghejklnnepkrstevvkeseeeeeeeceeeeeeeedneeeeeeeeeeepseeeeeeeeceeeeeeeedneeeeeeeeeeep?\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\"\n      \\ ]\nlet g:test_data_dic1 = [\n      \\\"123456\",\n      \\\"test/NO\",\n      \\\"# comment\",\n      \\\"wrong\",\n      \\\"Comment\",\n      \\\"OK\",\n      \\\"uk\",\n      \\\"put/ISO\",\n      \\\"the end\",\n      \\\"deol\",\n      \\\"d\\xE9\\xF4r\",\n      \\ ]\nlet g:test_data_aff2 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out [a-z]\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\ ]\nlet g:test_data_aff3 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDRULE m*\",\n      \\\"NEEDCOMPOUND x\",\n      \\ ]\nlet g:test_data_dic3 = [\n      \\\"1234\",\n      \\\"foo/m\",\n      \\\"bar/mx\",\n      \\\"m\\xEF/m\",\n      \\\"la/mx\",\n      \\ ]\nlet g:test_data_aff4 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"COMPOUNDRULE m+\",\n      \\\"COMPOUNDRULE sm*e\",\n      \\\"COMPOUNDRULE sm+\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDWORDMAX 3\",\n      \\\"COMPOUNDFORBIDFLAG t\",\n      \\\"\",\n      \\\"COMPOUNDSYLMAX 5\",\n      \\\"SYLLABLE a\\xE1e\\xE9i\\xEDo\\xF3\\xF6\\xF5u\\xFA\\xFC\\xFBy/aa/au/ea/ee/ei/ie/oa/oe/oo/ou/uu/ui\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"NEEDAFFIX x\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD '-\",\n      \\\"\",\n      \\\"SFX q N 1\",\n      \\\"SFX q   0    -ok .\",\n      \\\"\",\n      \\\"SFX a Y 2\",\n      \\\"SFX a 0 s .\",\n      \\\"SFX a 0 ize/t .\",\n      \\\"\",\n      \\\"PFX p N 1\",\n      \\\"PFX p 0 pre .\",\n      \\\"\",\n      \\\"PFX P N 1\",\n      \\\"PFX P 0 nou .\",\n      \\ ]\nlet g:test_data_dic4 = [\n      \\\"1234\",\n      \\\"word/mP\",\n      \\\"util/am\",\n      \\\"pro/xq\",\n      \\\"tomato/m\",\n      \\\"bork/mp\",\n      \\\"start/s\",\n      \\\"end/e\",\n      \\ ]\nlet g:test_data_aff5 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG long\",\n      \\\"\",\n      \\\"NEEDAFFIX !!\",\n      \\\"\",\n      \\\"COMPOUNDRULE ssmm*ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND xx\",\n      \\\"COMPOUNDPERMITFLAG pp\",\n      \\\"\",\n      \\\"SFX 13 Y 1\",\n      \\\"SFX 13 0 bork .\",\n      \\\"\",\n      \\\"SFX a1 Y 1\",\n      \\\"SFX a1 0 a1 .\",\n      \\\"\",\n      \\\"SFX a\\xE9 Y 1\",\n      \\\"SFX a\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX zz Y 1\",\n      \\\"PFX zz 0 pre/pp .\",\n      \\\"\",\n      \\\"PFX yy Y 1\",\n      \\\"PFX yy 0 nou .\",\n      \\ ]\nlet g:test_data_dic5 = [\n      \\\"1234\",\n      \\\"foo/a1a\\xE9!!\",\n      \\\"bar/zz13ee\",\n      \\\"start/ss\",\n      \\\"end/eeyy\",\n      \\\"middle/mmxx\",\n      \\ ]\nlet g:test_data_aff6 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG caplong\",\n      \\\"\",\n      \\\"NEEDAFFIX A!\",\n      \\\"\",\n      \\\"COMPOUNDRULE sMm*Ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND Xx\",\n      \\\"\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX N3 Y 1\",\n      \\\"SFX N3 0 bork .\",\n      \\\"\",\n      \\\"SFX A1 Y 1\",\n      \\\"SFX A1 0 a1 .\",\n      \\\"\",\n      \\\"SFX A\\xE9 Y 1\",\n      \\\"SFX A\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX Zz Y 1\",\n      \\\"PFX Zz 0 pre/p .\",\n      \\ ]\nlet g:test_data_dic6 = [\n      \\\"1234\",\n      \\\"mee/A1A\\xE9A!\",\n      \\\"bar/ZzN3Ee\",\n      \\\"lead/s\",\n      \\\"end/Ee\",\n      \\\"middle/MmXx\",\n      \\ ]\nlet g:test_data_aff7 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG num\",\n      \\\"\",\n      \\\"NEEDAFFIX 9999\",\n      \\\"\",\n      \\\"COMPOUNDRULE 2,77*123\",\n      \\\"\",\n      \\\"NEEDCOMPOUND 1\",\n      \\\"COMPOUNDPERMITFLAG 432\",\n      \\\"\",\n      \\\"SFX 61003 Y 1\",\n      \\\"SFX 61003 0 meat .\",\n      \\\"\",\n      \\\"SFX 0 Y 1\",\n      \\\"SFX 0 0 zero .\",\n      \\\"\",\n      \\\"SFX 391 Y 1\",\n      \\\"SFX 391 0 a1 .\",\n      \\\"\",\n      \\\"SFX 111 Y 1\",\n      \\\"SFX 111 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX 17 Y 1\",\n      \\\"PFX 17 0 pre/432 .\",\n      \\ ]\nlet g:test_data_dic7 = [\n      \\\"1234\",\n      \\\"mee/0,391,111,9999\",\n      \\\"bar/17,61003,123\",\n      \\\"lead/2\",\n      \\\"tail/123\",\n      \\\"middle/77,1\",\n      \\ ]\nlet g:test_data_aff8 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"NOSPLITSUGS\",\n      \\ ]\nlet g:test_data_dic8 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\\"faabar\",\n      \\ ]\nlet g:test_data_aff9 = [\n      \\ ]\nlet g:test_data_dic9 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\ ]\nlet g:test_data_aff10 = [\n      \\\"COMPOUNDRULE se\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX A Y 1\",\n      \\\"SFX A 0 able/Mp .\",\n      \\\"\",\n      \\\"SFX M Y 1\",\n      \\\"SFX M 0 s .\",\n      \\ ]\nlet g:test_data_dic10 = [\n      \\\"1234\",\n      \\\"drink/As\",\n      \\\"table/e\",\n      \\ ]\nlet g:test_data_aff_sal = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\\xEB\\xE9\\xE8\\xEA\\xEF\\xEE\\xE4\\xE0\\xE2\\xF6\\xFC\\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"SAL AH(AEIOUY)-^         *H\",\n      \\\"SAL AR(AEIOUY)-^         *R\",\n      \\\"SAL A(HR)^               *\",\n      \\\"SAL A^                   *\",\n      \\\"SAL AH(AEIOUY)-          H\",\n      \\\"SAL AR(AEIOUY)-          R\",\n      \\\"SAL A(HR)                _\",\n      \\\"SAL \\xC0^                   *\",\n      \\\"SAL \\xC5^                   *\",\n      \\\"SAL BB-                  _\",\n      \\\"SAL B                    B\",\n      \\\"SAL CQ-                  _\",\n      \\\"SAL CIA                  X\",\n      \\\"SAL CH                   X\",\n      \\\"SAL C(EIY)-              S\",\n      \\\"SAL CK                   K\",\n      \\\"SAL COUGH^               KF\",\n      \\\"SAL CC<                  C\",\n      \\\"SAL C                    K\",\n      \\\"SAL DG(EIY)              K\",\n      \\\"SAL DD-                  _\",\n      \\\"SAL D                    T\",\n      \\\"SAL \\xC9<                   E\",\n      \\\"SAL EH(AEIOUY)-^         *H\",\n      \\\"SAL ER(AEIOUY)-^         *R\",\n      \\\"SAL E(HR)^               *\",\n      \\\"SAL ENOUGH^$             *NF\",\n      \\\"SAL E^                   *\",\n      \\\"SAL EH(AEIOUY)-          H\",\n      \\\"SAL ER(AEIOUY)-          R\",\n      \\\"SAL E(HR)                _\",\n      \\\"SAL FF-                  _\",\n      \\\"SAL F                    F\",\n      \\\"SAL GN^                  N\",\n      \\\"SAL GN$                  N\",\n      \\\"SAL GNS$                 NS\",\n      \\\"SAL GNED$                N\",\n      \\\"SAL GH(AEIOUY)-          K\",\n      \\\"SAL GH                   _\",\n      \\\"SAL GG9                  K\",\n      \\\"SAL G                    K\",\n      \\\"SAL H                    H\",\n      \\\"SAL IH(AEIOUY)-^         *H\",\n      \\\"SAL IR(AEIOUY)-^         *R\",\n      \\\"SAL I(HR)^               *\",\n      \\\"SAL I^                   *\",\n      \\\"SAL ING6                 N\",\n      \\\"SAL IH(AEIOUY)-          H\",\n      \\\"SAL IR(AEIOUY)-          R\",\n      \\\"SAL I(HR)                _\",\n      \\\"SAL J                    K\",\n      \\\"SAL KN^                  N\",\n      \\\"SAL KK-                  _\",\n      \\\"SAL K                    K\",\n      \\\"SAL LAUGH^               LF\",\n      \\\"SAL LL-                  _\",\n      \\\"SAL L                    L\",\n      \\\"SAL MB$                  M\",\n      \\\"SAL MM                   M\",\n      \\\"SAL M                    M\",\n      \\\"SAL NN-                  _\",\n      \\\"SAL N                    N\",\n      \\\"SAL OH(AEIOUY)-^         *H\",\n      \\\"SAL OR(AEIOUY)-^         *R\",\n      \\\"SAL O(HR)^               *\",\n      \\\"SAL O^                   *\",\n      \\\"SAL OH(AEIOUY)-          H\",\n      \\\"SAL OR(AEIOUY)-          R\",\n      \\\"SAL O(HR)                _\",\n      \\\"SAL PH                   F\",\n      \\\"SAL PN^                  N\",\n      \\\"SAL PP-                  _\",\n      \\\"SAL P                    P\",\n      \\\"SAL Q                    K\",\n      \\\"SAL RH^                  R\",\n      \\\"SAL ROUGH^               RF\",\n      \\\"SAL RR-                  _\",\n      \\\"SAL R                    R\",\n      \\\"SAL SCH(EOU)-            SK\",\n      \\\"SAL SC(IEY)-             S\",\n      \\\"SAL SH                   X\",\n      \\\"SAL SI(AO)-              X\",\n      \\\"SAL SS-                  _\",\n      \\\"SAL S                    S\",\n      \\\"SAL TI(AO)-              X\",\n      \\\"SAL TH                   @\",\n      \\\"SAL TCH--                _\",\n      \\\"SAL TOUGH^               TF\",\n      \\\"SAL TT-                  _\",\n      \\\"SAL T                    T\",\n      \\\"SAL UH(AEIOUY)-^         *H\",\n      \\\"SAL UR(AEIOUY)-^         *R\",\n      \\\"SAL U(HR)^               *\",\n      \\\"SAL U^                   *\",\n      \\\"SAL UH(AEIOUY)-          H\",\n      \\\"SAL UR(AEIOUY)-          R\",\n      \\\"SAL U(HR)                _\",\n      \\\"SAL V^                   W\",\n      \\\"SAL V                    F\",\n      \\\"SAL WR^                  R\",\n      \\\"SAL WH^                  W\",\n      \\\"SAL W(AEIOU)-            W\",\n      \\\"SAL X^                   S\",\n      \\\"SAL X                    KS\",\n      \\\"SAL Y(AEIOU)-            Y\",\n      \\\"SAL ZZ-                  _\",\n      \\\"SAL Z                    S\",\n      \\ ]\n\nfunc LoadAffAndDic(aff_contents, dic_contents)\n  set enc=utf-8\n  set spellfile=\n  call writefile(a:aff_contents, \"Xtest.aff\")\n  call writefile(a:dic_contents, \"Xtest.dic\")\n  \" Generate a .spl file from a .dic and .aff file.\n  mkspell! Xtest Xtest\n  \" use that spell file\n  set spl=Xtest.utf-8.spl spell\nendfunc\n\nfunc ListWords()\n  spelldump\n  %yank\n  quit\n  return split(@\", \"\\n\")\nendfunc\n\nfunc TestGoodBadBase()\n  exe '1;/^good:'\n  normal 0f:]s\n  let prevbad = ''\n  let result = []\n  while 1\n    let [bad, a] = spellbadword()\n    if bad == '' || bad == prevbad || bad == 'badend'\n      break\n    endif\n    let prevbad = bad\n    let lst = bad->spellsuggest(3)\n    normal mm\n\n    call add(result, [bad, lst])\n    normal `m]s\n  endwhile\n  return result\nendfunc\n\nfunc RunGoodBad(good, bad, expected_words, expected_bad_words)\n  %bwipe!\n  call setline(1, ['', \"good: \", a:good,  a:bad, \" badend \"])\n  let words = ListWords()\n  call assert_equal(a:expected_words, words[1:-1])\n  let bad_words = TestGoodBadBase()\n  call assert_equal(a:expected_bad_words, bad_words)\n  %bwipe!\nendfunc\n\nfunc Test_spell_basic()\n  call LoadAffAndDic(g:test_data_aff1, g:test_data_dic1)\n  call RunGoodBad(\"wrong OK puts. Test the end\",\n        \\ \"bad: inputs comment ok Ok. test d\\u00E9\\u00F4l end the\",\n        \\[\"Comment\", \"deol\", \"d\\u00E9\\u00F4r\", \"input\", \"OK\", \"output\", \"outputs\", \"outtest\", \"put\", \"puts\",\n        \\  \"test\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\[\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\", \"outtest\", \"the end\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\u00E9\\u00F4l\", [\"deol\", \"d\\u00E9\\u00F4r\", \"test\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\ ]\n        \\ )\n\n  call assert_equal(\"gebletegek\", soundfold('goobledygoook'))\n  call assert_equal(\"kepereneven\", 'k\u00f3op\u00ebr\u00ffn\u00f4ven'->soundfold())\n  call assert_equal(\"everles gesvets etele\", soundfold('oeverloos gezwets edale'))\nendfunc\n\n\" Postponed prefixes\nfunc Test_spell_prefixes()\n  call LoadAffAndDic(g:test_data_aff2, g:test_data_dic1)\n  call RunGoodBad(\"puts\",\n        \\ \"bad: inputs comment ok Ok end the. test d\\u00E9\\u00F4l\",\n        \\ [\"Comment\", \"deol\", \"d\\u00E9\\u00F4r\", \"OK\", \"put\", \"input\", \"output\", \"puts\", \"outputs\", \"test\", \"outtest\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\ [\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"deol\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\u00E9\\u00F4l\", [\"deol\", \"d\\u00E9\\u00F4r\", \"test\"]],\n        \\ ])\nendfunc\n\n\"Compound words\nfunc Test_spell_compound()\n  call LoadAffAndDic(g:test_data_aff3, g:test_data_dic3)\n  call RunGoodBad(\"foo m\\u00EF foobar foofoobar barfoo barbarfoo\",\n        \\ \"bad: bar la foom\\u00EF barm\\u00EF m\\u00EFfoo m\\u00EFbar m\\u00EFm\\u00EF lala m\\u00EFla lam\\u00EF foola labar\",\n        \\ [\"foo\", \"m\\u00EF\"],\n        \\ [\n        \\   [\"bad\", [\"foo\", \"m\\u00EF\"]],\n        \\   [\"bar\", [\"barfoo\", \"foobar\", \"foo\"]],\n        \\   [\"la\", [\"m\\u00EF\", \"foo\"]],\n        \\   [\"foom\\u00EF\", [\"foo m\\u00EF\", \"foo\", \"foofoo\"]],\n        \\   [\"barm\\u00EF\", [\"barfoo\", \"m\\u00EF\", \"barbar\"]],\n        \\   [\"m\\u00EFfoo\", [\"m\\u00EF foo\", \"foo\", \"foofoo\"]],\n        \\   [\"m\\u00EFbar\", [\"foobar\", \"barbar\", \"m\\u00EF\"]],\n        \\   [\"m\\u00EFm\\u00EF\", [\"m\\u00EF m\\u00EF\", \"m\\u00EF\"]],\n        \\   [\"lala\", []],\n        \\   [\"m\\u00EFla\", [\"m\\u00EF\", \"m\\u00EF m\\u00EF\"]],\n        \\   [\"lam\\u00EF\", [\"m\\u00EF\", \"m\\u00EF m\\u00EF\"]],\n        \\   [\"foola\", [\"foo\", \"foobar\", \"foofoo\"]],\n        \\   [\"labar\", [\"barbar\", \"foobar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff4, g:test_data_dic4)\n  call RunGoodBad(\"word util bork prebork start end wordutil wordutils pro-ok bork borkbork borkborkbork borkborkborkbork borkborkborkborkbork tomato tomatotomato startend startword startwordword startwordend startwordwordend startwordwordwordend prebork preborkbork preborkborkbork nouword\",\n        \\ \"bad: wordutilize pro borkborkborkborkborkbork tomatotomatotomato endstart endend startstart wordend wordstart preborkprebork  preborkpreborkbork startwordwordwordwordend borkpreborkpreborkbork utilsbork  startnouword\",\n        \\ [\"bork\", \"prebork\", \"end\", \"pro-ok\", \"start\", \"tomato\", \"util\", \"utilize\", \"utils\", \"word\", \"nouword\"],\n        \\ [\n        \\   [\"bad\", [\"end\", \"bork\", \"word\"]],\n        \\   [\"wordutilize\", [\"word utilize\", \"wordutils\", \"wordutil\"]],\n        \\   [\"pro\", [\"bork\", \"word\", \"end\"]],\n        \\   [\"borkborkborkborkborkbork\", [\"bork borkborkborkborkbork\", \"borkbork borkborkborkbork\", \"borkborkbork borkborkbork\"]],\n        \\   [\"tomatotomatotomato\", [\"tomato tomatotomato\", \"tomatotomato tomato\", \"tomato tomato tomato\"]],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"endend\", [\"end end\", \"end\"]],\n        \\   [\"startstart\", [\"start start\"]],\n        \\   [\"wordend\", [\"word end\", \"word\", \"wordword\"]],\n        \\   [\"wordstart\", [\"word start\", \"bork start\"]],\n        \\   [\"preborkprebork\", [\"prebork prebork\", \"preborkbork\", \"preborkborkbork\"]],\n        \\   [\"preborkpreborkbork\", [\"prebork preborkbork\", \"preborkborkbork\", \"preborkborkborkbork\"]],\n        \\   [\"startwordwordwordwordend\", [\"startwordwordwordword end\", \"startwordwordwordword\", \"start wordwordwordword end\"]],\n        \\   [\"borkpreborkpreborkbork\", [\"bork preborkpreborkbork\", \"bork prebork preborkbork\", \"bork preborkprebork bork\"]],\n        \\   [\"utilsbork\", [\"utilbork\", \"utils bork\", \"util bork\"]],\n        \\   [\"startnouword\", [\"start nouword\", \"startword\", \"startborkword\"]],\n        \\ ])\n\nendfunc\n\n\" Test affix flags with two characters\nfunc Test_spell_affix()\n  call LoadAffAndDic(g:test_data_aff5, g:test_data_dic5)\n  call RunGoodBad(\"fooa1 fooa\\u00E9 bar prebar barbork prebarbork  startprebar start end startend  startmiddleend nouend\",\n        \\ \"bad: foo fooa2 prabar probarbirk middle startmiddle middleend endstart startprobar startnouend\",\n        \\ [\"bar\", \"barbork\", \"end\", \"fooa1\", \"fooa\\u00E9\", \"nouend\", \"prebar\", \"prebarbork\", \"start\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"fooa1\"]],\n        \\   [\"foo\", [\"fooa1\", \"bar\", \"end\"]],\n        \\   [\"fooa2\", [\"fooa1\", \"fooa\\u00E9\", \"bar\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"bar bar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"startmiddle\", [\"startmiddleend\", \"startmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"startprobar\", [\"startprebar\", \"start prebar\", \"startbar\"]],\n        \\   [\"startnouend\", [\"start nouend\", \"startend\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff6, g:test_data_dic6)\n  call RunGoodBad(\"meea1 meea\\u00E9 bar prebar barbork prebarbork  leadprebar lead end leadend  leadmiddleend\",\n        \\  \"bad: mee meea2 prabar probarbirk middle leadmiddle middleend endlead leadprobar\",\n        \\ [\"bar\", \"barbork\", \"end\", \"lead\", \"meea1\", \"meea\\u00E9\", \"prebar\", \"prebarbork\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"lead\"]],\n        \\   [\"mee\", [\"meea1\", \"bar\", \"end\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\u00E9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddleend\", \"leadmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endlead\", [\"end lead\", \"lead\", \"end end\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff7, g:test_data_dic7)\n  call RunGoodBad(\"meea1 meezero meea\\u00E9 bar prebar barmeat prebarmeat  leadprebar lead tail leadtail  leadmiddletail\",\n        \\ \"bad: mee meea2 prabar probarmaat middle leadmiddle middletail taillead leadprobar\",\n        \\ [\"bar\", \"barmeat\", \"lead\", \"meea1\", \"meea\\u00E9\", \"meezero\", \"prebar\", \"prebarmeat\", \"tail\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"lead\", \"tail\"]],\n        \\   [\"mee\", [\"meea1\", \"bar\", \"lead\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\u00E9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarmaat\", [\"prebarmeat\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddlebar\"]],\n        \\   [\"middletail\", []],\n        \\   [\"taillead\", [\"tail lead\", \"tail\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\nendfunc\n\nfunc Test_spell_NOSLITSUGS()\n  call LoadAffAndDic(g:test_data_aff8, g:test_data_dic8)\n  call RunGoodBad(\"foo bar faabar\", \"bad: foobar barfoo\",\n        \\ [\"bar\", \"faabar\", \"foo\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"foo\"]],\n        \\   [\"foobar\", [\"faabar\", \"foo bar\", \"bar\"]],\n        \\   [\"barfoo\", [\"bar foo\", \"bar\", \"foo\"]],\n        \\ ])\nendfunc\n\n\" Numbers\nfunc Test_spell_Numbers()\n  call LoadAffAndDic(g:test_data_aff9, g:test_data_dic9)\n  call RunGoodBad(\"0b1011 0777 1234 0x01ff\", \"\",\n        \\ [\"bar\", \"foo\"],\n        \\ [\n        \\ ])\nendfunc\n\n\" Affix flags\nfunc Test_spell_affix_flags()\n  call LoadAffAndDic(g:test_data_aff10, g:test_data_dic10)\n  call RunGoodBad(\"drink drinkable drinkables drinktable drinkabletable\",\n\t\\ \"bad: drinks drinkstable drinkablestable\",\n        \\ [\"drink\", \"drinkable\", \"drinkables\", \"table\"],\n        \\ [['bad', []],\n\t\\ ['drinks', ['drink']],\n\t\\ ['drinkstable', ['drinktable', 'drinkable', 'drink table']],\n        \\ ['drinkablestable', ['drinkabletable', 'drinkables table', 'drinkable table']],\n\t\\ ])\nendfunc\n\nfunction FirstSpellWord()\n  call feedkeys(\"/^start:\\n\", 'tx')\n  normal ]smm\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\nfunction SecondSpellWord()\n  normal `m]s\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\n\" Test with SAL instead of SOFO items; test automatic reloading\nfunc Test_spell_sal_and_addition()\n  set spellfile=\n  call writefile(g:test_data_dic1, \"Xtest.dic\")\n  call writefile(g:test_data_aff_sal, \"Xtest.aff\")\n  mkspell! Xtest Xtest\n  set spl=Xtest.utf-8.spl spell\n  call assert_equal('kbltykk', soundfold('goobledygoook'))\n  call assert_equal('kprnfn', soundfold('k\u00f3op\u00ebr\u00ffn\u00f4ven'))\n  call assert_equal('*fls kswts tl', soundfold('oeverloos gezwets edale'))\n\n  \"also use an addition file\n  call writefile([\"/regions=usgbnz\", \"elequint/2\", \"elekwint/3\"], \"Xtest.utf-8.add\")\n  mkspell! Xtest.utf-8.add.spl Xtest.utf-8.add\n\n  bwipe!\n  call setline(1, [\"start: elequint test elekwint test elekwent asdf\"])\n\n  set spellfile=Xtest.utf-8.add\n  call assert_equal(\"elekwent\", FirstSpellWord())\n\n  set spl=Xtest_us.utf-8.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\n\n  set spl=Xtest_gb.utf-8.spl\n  call assert_equal(\"elekwint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_nz.utf-8.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_ca.utf-8.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\n\n  set spellfile=\n  set spl&\nendfunc\n\nfunc Test_spellfile_value()\n  set spellfile=Xdir/Xtest.utf-8.add\n  set spellfile=Xdir/Xtest.utf-8.add,Xtest_other.add\n  set spellfile=\nendfunc\n\nfunc Test_no_crash_with_weird_text()\n  new\n  let lines =<< trim END\n      r<sfile>\n      \u0080\n\n\n      \u0080\n  END\n  call setline(1, lines)\n  exe \"%norm \\<C-v>ez=>\\<C-v>wzG\"\n\n  bwipe!\nendfunc\n\n\" Invalid bytes may cause trouble when creating the word list.\nfunc Test_check_for_valid_word()\n  call assert_fails(\"spellgood! 0\u0002\\xac\", 'E1280:')\nendfunc\n\n\" This was going over the end of the word\nfunc Test_word_index()\n  new\n  norm R0\n  spellgood! \ufb020\n  sil norm z=\n\n  bwipe!\n  \" clear the word list\n  set enc=utf-8\n  call delete('Xtmpfile')\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    5071,\n/**/\n    5070,\n/**/\n    5069,\n/**/\n    5068,\n/**/\n    5067,\n/**/\n    5066,\n/**/\n    5065,\n/**/\n    5064,\n/**/\n    5063,\n/**/\n    5062,\n/**/\n    5061,\n/**/\n    5060,\n/**/\n    5059,\n/**/\n    5058,\n/**/\n    5057,\n/**/\n    5056,\n/**/\n    5055,\n/**/\n    5054,\n/**/\n    5053,\n/**/\n    5052,\n/**/\n    5051,\n/**/\n    5050,\n/**/\n    5049,\n/**/\n    5048,\n/**/\n    5047,\n/**/\n    5046,\n/**/\n    5045,\n/**/\n    5044,\n/**/\n    5043,\n/**/\n    5042,\n/**/\n    5041,\n/**/\n    5040,\n/**/\n    5039,\n/**/\n    5038,\n/**/\n    5037,\n/**/\n    5036,\n/**/\n    5035,\n/**/\n    5034,\n/**/\n    5033,\n/**/\n    5032,\n/**/\n    5031,\n/**/\n    5030,\n/**/\n    5029,\n/**/\n    5028,\n/**/\n    5027,\n/**/\n    5026,\n/**/\n    5025,\n/**/\n    5024,\n/**/\n    5023,\n/**/\n    5022,\n/**/\n    5021,\n/**/\n    5020,\n/**/\n    5019,\n/**/\n    5018,\n/**/\n    5017,\n/**/\n    5016,\n/**/\n    5015,\n/**/\n    5014,\n/**/\n    5013,\n/**/\n    5012,\n/**/\n    5011,\n/**/\n    5010,\n/**/\n    5009,\n/**/\n    5008,\n/**/\n    5007,\n/**/\n    5006,\n/**/\n    5005,\n/**/\n    5004,\n/**/\n    5003,\n/**/\n    5002,\n/**/\n    5001,\n/**/\n    5000,\n/**/\n    4999,\n/**/\n    4998,\n/**/\n    4997,\n/**/\n    4996,\n/**/\n    4995,\n/**/\n    4994,\n/**/\n    4993,\n/**/\n    4992,\n/**/\n    4991,\n/**/\n    4990,\n/**/\n    4989,\n/**/\n    4988,\n/**/\n    4987,\n/**/\n    4986,\n/**/\n    4985,\n/**/\n    4984,\n/**/\n    4983,\n/**/\n    4982,\n/**/\n    4981,\n/**/\n    4980,\n/**/\n    4979,\n/**/\n    4978,\n/**/\n    4977,\n/**/\n    4976,\n/**/\n    4975,\n/**/\n    4974,\n/**/\n    4973,\n/**/\n    4972,\n/**/\n    4971,\n/**/\n    4970,\n/**/\n    4969,\n/**/\n    4968,\n/**/\n    4967,\n/**/\n    4966,\n/**/\n    4965,\n/**/\n    4964,\n/**/\n    4963,\n/**/\n    4962,\n/**/\n    4961,\n/**/\n    4960,\n/**/\n    4959,\n/**/\n    4958,\n/**/\n    4957,\n/**/\n    4956,\n/**/\n    4955,\n/**/\n    4954,\n/**/\n    4953,\n/**/\n    4952,\n/**/\n    4951,\n/**/\n    4950,\n/**/\n    4949,\n/**/\n    4948,\n/**/\n    4947,\n/**/\n    4946,\n/**/\n    4945,\n/**/\n    4944,\n/**/\n    4943,\n/**/\n    4942,\n/**/\n    4941,\n/**/\n    4940,\n/**/\n    4939,\n/**/\n    4938,\n/**/\n    4937,\n/**/\n    4936,\n/**/\n    4935,\n/**/\n    4934,\n/**/\n    4933,\n/**/\n    4932,\n/**/\n    4931,\n/**/\n    4930,\n/**/\n    4929,\n/**/\n    4928,\n/**/\n    4927,\n/**/\n    4926,\n/**/\n    4925,\n/**/\n    4924,\n/**/\n    4923,\n/**/\n    4922,\n/**/\n    4921,\n/**/\n    4920,\n/**/\n    4919,\n/**/\n    4918,\n/**/\n    4917,\n/**/\n    4916,\n/**/\n    4915,\n/**/\n    4914,\n/**/\n    4913,\n/**/\n    4912,\n/**/\n    4911,\n/**/\n    4910,\n/**/\n    4909,\n/**/\n    4908,\n/**/\n    4907,\n/**/\n    4906,\n/**/\n    4905,\n/**/\n    4904,\n/**/\n    4903,\n/**/\n    4902,\n/**/\n    4901,\n/**/\n    4900,\n/**/\n    4899,\n/**/\n    4898,\n/**/\n    4897,\n/**/\n    4896,\n/**/\n    4895,\n/**/\n    4894,\n/**/\n    4893,\n/**/\n    4892,\n/**/\n    4891,\n/**/\n    4890,\n/**/\n    4889,\n/**/\n    4888,\n/**/\n    4887,\n/**/\n    4886,\n/**/\n    4885,\n/**/\n    4884,\n/**/\n    4883,\n/**/\n    4882,\n/**/\n    4881,\n/**/\n    4880,\n/**/\n    4879,\n/**/\n    4878,\n/**/\n    4877,\n/**/\n    4876,\n/**/\n    4875,\n/**/\n    4874,\n/**/\n    4873,\n/**/\n    4872,\n/**/\n    4871,\n/**/\n    4870,\n/**/\n    4869,\n/**/\n    4868,\n/**/\n    4867,\n/**/\n    4866,\n/**/\n    4865,\n/**/\n    4864,\n/**/\n    4863,\n/**/\n    4862,\n/**/\n    4861,\n/**/\n    4860,\n/**/\n    4859,\n/**/\n    4858,\n/**/\n    4857,\n/**/\n    4856,\n/**/\n    4855,\n/**/\n    4854,\n/**/\n    4853,\n/**/\n    4852,\n/**/\n    4851,\n/**/\n    4850,\n/**/\n    4849,\n/**/\n    4848,\n/**/\n    4847,\n/**/\n    4846,\n/**/\n    4845,\n/**/\n    4844,\n/**/\n    4843,\n/**/\n    4842,\n/**/\n    4841,\n/**/\n    4840,\n/**/\n    4839,\n/**/\n    4838,\n/**/\n    4837,\n/**/\n    4836,\n/**/\n    4835,\n/**/\n    4834,\n/**/\n    4833,\n/**/\n    4832,\n/**/\n    4831,\n/**/\n    4830,\n/**/\n    4829,\n/**/\n    4828,\n/**/\n    4827,\n/**/\n    4826,\n/**/\n    4825,\n/**/\n    4824,\n/**/\n    4823,\n/**/\n    4822,\n/**/\n    4821,\n/**/\n    4820,\n/**/\n    4819,\n/**/\n    4818,\n/**/\n    4817,\n/**/\n    4816,\n/**/\n    4815,\n/**/\n    4814,\n/**/\n    4813,\n/**/\n    4812,\n/**/\n    4811,\n/**/\n    4810,\n/**/\n    4809,\n/**/\n    4808,\n/**/\n    4807,\n/**/\n    4806,\n/**/\n    4805,\n/**/\n    4804,\n/**/\n    4803,\n/**/\n    4802,\n/**/\n    4801,\n/**/\n    4800,\n/**/\n    4799,\n/**/\n    4798,\n/**/\n    4797,\n/**/\n    4796,\n/**/\n    4795,\n/**/\n    4794,\n/**/\n    4793,\n/**/\n    4792,\n/**/\n    4791,\n/**/\n    4790,\n/**/\n    4789,\n/**/\n    4788,\n/**/\n    4787,\n/**/\n    4786,\n/**/\n    4785,\n/**/\n    4784,\n/**/\n    4783,\n/**/\n    4782,\n/**/\n    4781,\n/**/\n    4780,\n/**/\n    4779,\n/**/\n    4778,\n/**/\n    4777,\n/**/\n    4776,\n/**/\n    4775,\n/**/\n    4774,\n/**/\n    4773,\n/**/\n    4772,\n/**/\n    4771,\n/**/\n    4770,\n/**/\n    4769,\n/**/\n    4768,\n/**/\n    4767,\n/**/\n    4766,\n/**/\n    4765,\n/**/\n    4764,\n/**/\n    4763,\n/**/\n    4762,\n/**/\n    4761,\n/**/\n    4760,\n/**/\n    4759,\n/**/\n    4758,\n/**/\n    4757,\n/**/\n    4756,\n/**/\n    4755,\n/**/\n    4754,\n/**/\n    4753,\n/**/\n    4752,\n/**/\n    4751,\n/**/\n    4750,\n/**/\n    4749,\n/**/\n    4748,\n/**/\n    4747,\n/**/\n    4746,\n/**/\n    4745,\n/**/\n    4744,\n/**/\n    4743,\n/**/\n    4742,\n/**/\n    4741,\n/**/\n    4740,\n/**/\n    4739,\n/**/\n    4738,\n/**/\n    4737,\n/**/\n    4736,\n/**/\n    4735,\n/**/\n    4734,\n/**/\n    4733,\n/**/\n    4732,\n/**/\n    4731,\n/**/\n    4730,\n/**/\n    4729,\n/**/\n    4728,\n/**/\n    4727,\n/**/\n    4726,\n/**/\n    4725,\n/**/\n    4724,\n/**/\n    4723,\n/**/\n    4722,\n/**/\n    4721,\n/**/\n    4720,\n/**/\n    4719,\n/**/\n    4718,\n/**/\n    4717,\n/**/\n    4716,\n/**/\n    4715,\n/**/\n    4714,\n/**/\n    4713,\n/**/\n    4712,\n/**/\n    4711,\n/**/\n    4710,\n/**/\n    4709,\n/**/\n    4708,\n/**/\n    4707,\n/**/\n    4706,\n/**/\n    4705,\n/**/\n    4704,\n/**/\n    4703,\n/**/\n    4702,\n/**/\n    4701,\n/**/\n    4700,\n/**/\n    4699,\n/**/\n    4698,\n/**/\n    4697,\n/**/\n    4696,\n/**/\n    4695,\n/**/\n    4694,\n/**/\n    4693,\n/**/\n    4692,\n/**/\n    4691,\n/**/\n    4690,\n/**/\n    4689,\n/**/\n    4688,\n/**/\n    4687,\n/**/\n    4686,\n/**/\n    4685,\n/**/\n    4684,\n/**/\n    4683,\n/**/\n    4682,\n/**/\n    4681,\n/**/\n    4680,\n/**/\n    4679,\n/**/\n    4678,\n/**/\n    4677,\n/**/\n    4676,\n/**/\n    4675,\n/**/\n    4674,\n/**/\n    4673,\n/**/\n    4672,\n/**/\n    4671,\n/**/\n    4670,\n/**/\n    4669,\n/**/\n    4668,\n/**/\n    4667,\n/**/\n    4666,\n/**/\n    4665,\n/**/\n    4664,\n/**/\n    4663,\n/**/\n    4662,\n/**/\n    4661,\n/**/\n    4660,\n/**/\n    4659,\n/**/\n    4658,\n/**/\n    4657,\n/**/\n    4656,\n/**/\n    4655,\n/**/\n    4654,\n/**/\n    4653,\n/**/\n    4652,\n/**/\n    4651,\n/**/\n    4650,\n/**/\n    4649,\n/**/\n    4648,\n/**/\n    4647,\n/**/\n    4646,\n/**/\n    4645,\n/**/\n    4644,\n/**/\n    4643,\n/**/\n    4642,\n/**/\n    4641,\n/**/\n    4640,\n/**/\n    4639,\n/**/\n    4638,\n/**/\n    4637,\n/**/\n    4636,\n/**/\n    4635,\n/**/\n    4634,\n/**/\n    4633,\n/**/\n    4632,\n/**/\n    4631,\n/**/\n    4630,\n/**/\n    4629,\n/**/\n    4628,\n/**/\n    4627,\n/**/\n    4626,\n/**/\n    4625,\n/**/\n    4624,\n/**/\n    4623,\n/**/\n    4622,\n/**/\n    4621,\n/**/\n    4620,\n/**/\n    4619,\n/**/\n    4618,\n/**/\n    4617,\n/**/\n    4616,\n/**/\n    4615,\n/**/\n    4614,\n/**/\n    4613,\n/**/\n    4612,\n/**/\n    4611,\n/**/\n    4610,\n/**/\n    4609,\n/**/\n    4608,\n/**/\n    4607,\n/**/\n    4606,\n/**/\n    4605,\n/**/\n    4604,\n/**/\n    4603,\n/**/\n    4602,\n/**/\n    4601,\n/**/\n    4600,\n/**/\n    4599,\n/**/\n    4598,\n/**/\n    4597,\n/**/\n    4596,\n/**/\n    4595,\n/**/\n    4594,\n/**/\n    4593,\n/**/\n    4592,\n/**/\n    4591,\n/**/\n    4590,\n/**/\n    4589,\n/**/\n    4588,\n/**/\n    4587,\n/**/\n    4586,\n/**/\n    4585,\n/**/\n    4584,\n/**/\n    4583,\n/**/\n    4582,\n/**/\n    4581,\n/**/\n    4580,\n/**/\n    4579,\n/**/\n    4578,\n/**/\n    4577,\n/**/\n    4576,\n/**/\n    4575,\n/**/\n    4574,\n/**/\n    4573,\n/**/\n    4572,\n/**/\n    4571,\n/**/\n    4570,\n/**/\n    4569,\n/**/\n    4568,\n/**/\n    4567,\n/**/\n    4566,\n/**/\n    4565,\n/**/\n    4564,\n/**/\n    4563,\n/**/\n    4562,\n/**/\n    4561,\n/**/\n    4560,\n/**/\n    4559,\n/**/\n    4558,\n/**/\n    4557,\n/**/\n    4556,\n/**/\n    4555,\n/**/\n    4554,\n/**/\n    4553,\n/**/\n    4552,\n/**/\n    4551,\n/**/\n    4550,\n/**/\n    4549,\n/**/\n    4548,\n/**/\n    4547,\n/**/\n    4546,\n/**/\n    4545,\n/**/\n    4544,\n/**/\n    4543,\n/**/\n    4542,\n/**/\n    4541,\n/**/\n    4540,\n/**/\n    4539,\n/**/\n    4538,\n/**/\n    4537,\n/**/\n    4536,\n/**/\n    4535,\n/**/\n    4534,\n/**/\n    4533,\n/**/\n    4532,\n/**/\n    4531,\n/**/\n    4530,\n/**/\n    4529,\n/**/\n    4528,\n/**/\n    4527,\n/**/\n    4526,\n/**/\n    4525,\n/**/\n    4524,\n/**/\n    4523,\n/**/\n    4522,\n/**/\n    4521,\n/**/\n    4520,\n/**/\n    4519,\n/**/\n    4518,\n/**/\n    4517,\n/**/\n    4516,\n/**/\n    4515,\n/**/\n    4514,\n/**/\n    4513,\n/**/\n    4512,\n/**/\n    4511,\n/**/\n    4510,\n/**/\n    4509,\n/**/\n    4508,\n/**/\n    4507,\n/**/\n    4506,\n/**/\n    4505,\n/**/\n    4504,\n/**/\n    4503,\n/**/\n    4502,\n/**/\n    4501,\n/**/\n    4500,\n/**/\n    4499,\n/**/\n    4498,\n/**/\n    4497,\n/**/\n    4496,\n/**/\n    4495,\n/**/\n    4494,\n/**/\n    4493,\n/**/\n    4492,\n/**/\n    4491,\n/**/\n    4490,\n/**/\n    4489,\n/**/\n    4488,\n/**/\n    4487,\n/**/\n    4486,\n/**/\n    4485,\n/**/\n    4484,\n/**/\n    4483,\n/**/\n    4482,\n/**/\n    4481,\n/**/\n    4480,\n/**/\n    4479,\n/**/\n    4478,\n/**/\n    4477,\n/**/\n    4476,\n/**/\n    4475,\n/**/\n    4474,\n/**/\n    4473,\n/**/\n    4472,\n/**/\n    4471,\n/**/\n    4470,\n/**/\n    4469,\n/**/\n    4468,\n/**/\n    4467,\n/**/\n    4466,\n/**/\n    4465,\n/**/\n    4464,\n/**/\n    4463,\n/**/\n    4462,\n/**/\n    4461,\n/**/\n    4460,\n/**/\n    4459,\n/**/\n    4458,\n/**/\n    4457,\n/**/\n    4456,\n/**/\n    4455,\n/**/\n    4454,\n/**/\n    4453,\n/**/\n    4452,\n/**/\n    4451,\n/**/\n    4450,\n/**/\n    4449,\n/**/\n    4448,\n/**/\n    4447,\n/**/\n    4446,\n/**/\n    4445,\n/**/\n    4444,\n/**/\n    4443,\n/**/\n    4442,\n/**/\n    4441,\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * spell.c: code for spell checking\n *\n * See spellfile.c for the Vim spell file format.\n *\n * The spell checking mechanism uses a tree (aka trie).  Each node in the tree\n * has a list of bytes that can appear (siblings).  For each byte there is a\n * pointer to the node with the byte that follows in the word (child).\n *\n * A NUL byte is used where the word may end.  The bytes are sorted, so that\n * binary searching can be used and the NUL bytes are at the start.  The\n * number of possible bytes is stored before the list of bytes.\n *\n * The tree uses two arrays: \"byts\" stores the characters, \"idxs\" stores\n * either the next index or flags.  The tree starts at index 0.  For example,\n * to lookup \"vi\" this sequence is followed:\n *\ti = 0\n *\tlen = byts[i]\n *\tn = where \"v\" appears in byts[i + 1] to byts[i + len]\n *\ti = idxs[n]\n *\tlen = byts[i]\n *\tn = where \"i\" appears in byts[i + 1] to byts[i + len]\n *\ti = idxs[n]\n *\tlen = byts[i]\n *\tfind that byts[i + 1] is 0, idxs[i + 1] has flags for \"vi\".\n *\n * There are two word trees: one with case-folded words and one with words in\n * original case.  The second one is only used for keep-case words and is\n * usually small.\n *\n * There is one additional tree for when not all prefixes are applied when\n * generating the .spl file.  This tree stores all the possible prefixes, as\n * if they were words.  At each word (prefix) end the prefix nr is stored, the\n * following word must support this prefix nr.  And the condition nr is\n * stored, used to lookup the condition that the word must match with.\n *\n * Thanks to Olaf Seibert for providing an example implementation of this tree\n * and the compression mechanism.\n * LZ trie ideas:\n *\thttp://www.irb.hr/hr/home/ristov/papers/RistovLZtrieRevision1.pdf\n * More papers: http://www-igm.univ-mlv.fr/~laporte/publi_en.html\n *\n * Matching involves checking the caps type: Onecap ALLCAP KeepCap.\n *\n * Why doesn't Vim use aspell/ispell/myspell/etc.?\n * See \":help develop-spell\".\n */\n\n#define IN_SPELL_C\n#include \"vim.h\"\n\n#if defined(FEAT_SPELL) || defined(PROTO)\n\n#ifndef UNIX\t\t// it's in os_unix.h for Unix\n# include <time.h>\t// for time_t\n#endif\n\n#define REGION_ALL 0xff\t\t// word valid in all regions\n\n// Result values.  Lower number is accepted over higher one.\n#define SP_BANNED\t(-1)\n#define SP_OK\t\t0\n#define SP_RARE\t\t1\n#define SP_LOCAL\t2\n#define SP_BAD\t\t3\n\n/*\n * Structure to store info for word matching.\n */\ntypedef struct matchinf_S\n{\n    langp_T\t*mi_lp;\t\t\t// info for language and region\n\n    // pointers to original text to be checked\n    char_u\t*mi_word;\t\t// start of word being checked\n    char_u\t*mi_end;\t\t// end of matching word so far\n    char_u\t*mi_fend;\t\t// next char to be added to mi_fword\n    char_u\t*mi_cend;\t\t// char after what was used for\n\t\t\t\t\t// mi_capflags\n\n    // case-folded text\n    char_u\tmi_fword[MAXWLEN + 1];\t// mi_word case-folded\n    int\t\tmi_fwordlen;\t\t// nr of valid bytes in mi_fword\n\n    // for when checking word after a prefix\n    int\t\tmi_prefarridx;\t\t// index in sl_pidxs with list of\n\t\t\t\t\t// affixID/condition\n    int\t\tmi_prefcnt;\t\t// number of entries at mi_prefarridx\n    int\t\tmi_prefixlen;\t\t// byte length of prefix\n    int\t\tmi_cprefixlen;\t\t// byte length of prefix in original\n\t\t\t\t\t// case\n\n    // for when checking a compound word\n    int\t\tmi_compoff;\t\t// start of following word offset\n    char_u\tmi_compflags[MAXWLEN];\t// flags for compound words used\n    int\t\tmi_complen;\t\t// nr of compound words used\n    int\t\tmi_compextra;\t\t// nr of COMPOUNDROOT words\n\n    // others\n    int\t\tmi_result;\t\t// result so far: SP_BAD, SP_OK, etc.\n    int\t\tmi_capflags;\t\t// WF_ONECAP WF_ALLCAP WF_KEEPCAP\n    win_T\t*mi_win;\t\t// buffer being checked\n\n    // for NOBREAK\n    int\t\tmi_result2;\t\t// \"mi_resul\" without following word\n    char_u\t*mi_end2;\t\t// \"mi_end\" without following word\n} matchinf_T;\n\n\nstatic int spell_mb_isword_class(int cl, win_T *wp);\n\n// mode values for find_word\n#define FIND_FOLDWORD\t    0\t// find word case-folded\n#define FIND_KEEPWORD\t    1\t// find keep-case word\n#define FIND_PREFIX\t    2\t// find word after prefix\n#define FIND_COMPOUND\t    3\t// find case-folded compound word\n#define FIND_KEEPCOMPOUND   4\t// find keep-case compound word\n\nstatic void find_word(matchinf_T *mip, int mode);\nstatic void find_prefix(matchinf_T *mip, int mode);\nstatic int fold_more(matchinf_T *mip);\nstatic void spell_load_cb(char_u *fname, void *cookie);\nstatic int count_syllables(slang_T *slang, char_u *word);\nstatic void clear_midword(win_T *buf);\nstatic void use_midword(slang_T *lp, win_T *buf);\nstatic int find_region(char_u *rp, char_u *region);\nstatic void spell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res);\nstatic void spell_soundfold_sal(slang_T *slang, char_u *inword, char_u *res);\nstatic void spell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res);\nstatic void dump_word(slang_T *slang, char_u *word, char_u *pat, int *dir, int round, int flags, linenr_T lnum);\nstatic linenr_T dump_prefixes(slang_T *slang, char_u *word, char_u *pat, int *dir, int round, int flags, linenr_T startlnum);\n\n/*\n * Main spell-checking function.\n * \"ptr\" points to a character that could be the start of a word.\n * \"*attrp\" is set to the highlight index for a badly spelled word.  For a\n * non-word or when it's OK it remains unchanged.\n * This must only be called when 'spelllang' is not empty.\n *\n * \"capcol\" is used to check for a Capitalised word after the end of a\n * sentence.  If it's zero then perform the check.  Return the column where to\n * check next, or -1 when no sentence end was found.  If it's NULL then don't\n * worry.\n *\n * Returns the length of the word in bytes, also when it's OK, so that the\n * caller can skip over the word.\n */\n    int\nspell_check(\n    win_T\t*wp,\t\t// current window\n    char_u\t*ptr,\n    hlf_T\t*attrp,\n    int\t\t*capcol,\t// column to check for Capital\n    int\t\tdocount)\t// count good words\n{\n    matchinf_T\tmi;\t\t// Most things are put in \"mi\" so that it can\n\t\t\t\t// be passed to functions quickly.\n    int\t\tnrlen = 0;\t// found a number first\n    int\t\tc;\n    int\t\twrongcaplen = 0;\n    int\t\tlpi;\n    int\t\tcount_word = docount;\n    int\t\tuse_camel_case = *wp->w_s->b_p_spo != NUL;\n    int\t\tcamel_case = 0;\n\n    // A word never starts at a space or a control character.  Return quickly\n    // then, skipping over the character.\n    if (*ptr <= ' ')\n\treturn 1;\n\n    // Return here when loading language files failed.\n    if (wp->w_s->b_langp.ga_len == 0)\n\treturn 1;\n\n    CLEAR_FIELD(mi);\n\n    // A number is always OK.  Also skip hexadecimal numbers 0xFF99 and\n    // 0X99FF.  But always do check spelling to find \"3GPP\" and \"11\n    // julifeest\".\n    if (*ptr >= '0' && *ptr <= '9')\n    {\n\tif (*ptr == '0' && (ptr[1] == 'b' || ptr[1] == 'B'))\n\t    mi.mi_end = skipbin(ptr + 2);\n\telse if (*ptr == '0' && (ptr[1] == 'x' || ptr[1] == 'X'))\n\t    mi.mi_end = skiphex(ptr + 2);\n\telse\n\t    mi.mi_end = skipdigits(ptr);\n\tnrlen = (int)(mi.mi_end - ptr);\n    }\n\n    // Find the normal end of the word (until the next non-word character).\n    mi.mi_word = ptr;\n    mi.mi_fend = ptr;\n    if (spell_iswordp(mi.mi_fend, wp))\n    {\n\tint prev_upper;\n\tint this_upper = FALSE;  // init for gcc\n\n\tif (use_camel_case)\n\t{\n\t    c = PTR2CHAR(mi.mi_fend);\n\t    this_upper = SPELL_ISUPPER(c);\n\t}\n\n\tdo\n\t{\n\t    MB_PTR_ADV(mi.mi_fend);\n\t    if (use_camel_case)\n\t    {\n\t\tprev_upper = this_upper;\n\t\tc = PTR2CHAR(mi.mi_fend);\n\t\tthis_upper = SPELL_ISUPPER(c);\n\t\tcamel_case = !prev_upper && this_upper;\n\t    }\n\t} while (*mi.mi_fend != NUL && spell_iswordp(mi.mi_fend, wp)\n\t\t\t\t\t\t\t       && !camel_case);\n\n\tif (capcol != NULL && *capcol == 0 && wp->w_s->b_cap_prog != NULL)\n\t{\n\t    // Check word starting with capital letter.\n\t    c = PTR2CHAR(ptr);\n\t    if (!SPELL_ISUPPER(c))\n\t\twrongcaplen = (int)(mi.mi_fend - ptr);\n\t}\n    }\n    if (capcol != NULL)\n\t*capcol = -1;\n\n    // We always use the characters up to the next non-word character,\n    // also for bad words.\n    mi.mi_end = mi.mi_fend;\n\n    // Check caps type later.\n    mi.mi_capflags = 0;\n    mi.mi_cend = NULL;\n    mi.mi_win = wp;\n\n    // case-fold the word with one non-word character, so that we can check\n    // for the word end.\n    if (*mi.mi_fend != NUL)\n\tMB_PTR_ADV(mi.mi_fend);\n\n    (void)spell_casefold(wp, ptr, (int)(mi.mi_fend - ptr), mi.mi_fword,\n\t\t\t\t\t\t\t     MAXWLEN + 1);\n    mi.mi_fwordlen = (int)STRLEN(mi.mi_fword);\n\n    if (camel_case && mi.mi_fwordlen > 0)\n\t// Introduce a fake word end space into the folded word.\n\tmi.mi_fword[mi.mi_fwordlen - 1] = ' ';\n\n    // The word is bad unless we recognize it.\n    mi.mi_result = SP_BAD;\n    mi.mi_result2 = SP_BAD;\n\n    /*\n     * Loop over the languages specified in 'spelllang'.\n     * We check them all, because a word may be matched longer in another\n     * language.\n     */\n    for (lpi = 0; lpi < wp->w_s->b_langp.ga_len; ++lpi)\n    {\n\tmi.mi_lp = LANGP_ENTRY(wp->w_s->b_langp, lpi);\n\n\t// If reloading fails the language is still in the list but everything\n\t// has been cleared.\n\tif (mi.mi_lp->lp_slang->sl_fidxs == NULL)\n\t    continue;\n\n\t// Check for a matching word in case-folded words.\n\tfind_word(&mi, FIND_FOLDWORD);\n\n\t// Check for a matching word in keep-case words.\n\tfind_word(&mi, FIND_KEEPWORD);\n\n\t// Check for matching prefixes.\n\tfind_prefix(&mi, FIND_FOLDWORD);\n\n\t// For a NOBREAK language, may want to use a word without a following\n\t// word as a backup.\n\tif (mi.mi_lp->lp_slang->sl_nobreak && mi.mi_result == SP_BAD\n\t\t\t\t\t\t   && mi.mi_result2 != SP_BAD)\n\t{\n\t    mi.mi_result = mi.mi_result2;\n\t    mi.mi_end = mi.mi_end2;\n\t}\n\n\t// Count the word in the first language where it's found to be OK.\n\tif (count_word && mi.mi_result == SP_OK)\n\t{\n\t    count_common_word(mi.mi_lp->lp_slang, ptr,\n\t\t\t\t\t\t   (int)(mi.mi_end - ptr), 1);\n\t    count_word = FALSE;\n\t}\n    }\n\n    if (mi.mi_result != SP_OK)\n    {\n\t// If we found a number skip over it.  Allows for \"42nd\".  Do flag\n\t// rare and local words, e.g., \"3GPP\".\n\tif (nrlen > 0)\n\t{\n\t    if (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED)\n\t\treturn nrlen;\n\t}\n\n\t// When we are at a non-word character there is no error, just\n\t// skip over the character (try looking for a word after it).\n\telse if (!spell_iswordp_nmw(ptr, wp))\n\t{\n\t    if (capcol != NULL && wp->w_s->b_cap_prog != NULL)\n\t    {\n\t\tregmatch_T\tregmatch;\n\t\tint\t\tr;\n\n\t\t// Check for end of sentence.\n\t\tregmatch.regprog = wp->w_s->b_cap_prog;\n\t\tregmatch.rm_ic = FALSE;\n\t\tr = vim_regexec(&regmatch, ptr, 0);\n\t\twp->w_s->b_cap_prog = regmatch.regprog;\n\t\tif (r)\n\t\t    *capcol = (int)(regmatch.endp[0] - ptr);\n\t    }\n\n\t    if (has_mbyte)\n\t\treturn (*mb_ptr2len)(ptr);\n\t    return 1;\n\t}\n\telse if (mi.mi_end == ptr)\n\t    // Always include at least one character.  Required for when there\n\t    // is a mixup in \"midword\".\n\t    MB_PTR_ADV(mi.mi_end);\n\telse if (mi.mi_result == SP_BAD\n\t\t&& LANGP_ENTRY(wp->w_s->b_langp, 0)->lp_slang->sl_nobreak)\n\t{\n\t    char_u\t*p, *fp;\n\t    int\t\tsave_result = mi.mi_result;\n\n\t    // First language in 'spelllang' is NOBREAK.  Find first position\n\t    // at which any word would be valid.\n\t    mi.mi_lp = LANGP_ENTRY(wp->w_s->b_langp, 0);\n\t    if (mi.mi_lp->lp_slang->sl_fidxs != NULL)\n\t    {\n\t\tp = mi.mi_word;\n\t\tfp = mi.mi_fword;\n\t\tfor (;;)\n\t\t{\n\t\t    MB_PTR_ADV(p);\n\t\t    MB_PTR_ADV(fp);\n\t\t    if (p >= mi.mi_end)\n\t\t\tbreak;\n\t\t    mi.mi_compoff = (int)(fp - mi.mi_fword);\n\t\t    find_word(&mi, FIND_COMPOUND);\n\t\t    if (mi.mi_result != SP_BAD)\n\t\t    {\n\t\t\tmi.mi_end = p;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tmi.mi_result = save_result;\n\t    }\n\t}\n\n\tif (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED)\n\t    *attrp = HLF_SPB;\n\telse if (mi.mi_result == SP_RARE)\n\t    *attrp = HLF_SPR;\n\telse\n\t    *attrp = HLF_SPL;\n    }\n\n    if (wrongcaplen > 0 && (mi.mi_result == SP_OK || mi.mi_result == SP_RARE))\n    {\n\t// Report SpellCap only when the word isn't badly spelled.\n\t*attrp = HLF_SPC;\n\treturn wrongcaplen;\n    }\n\n    return (int)(mi.mi_end - ptr);\n}\n\n/*\n * Check if the word at \"mip->mi_word\" is in the tree.\n * When \"mode\" is FIND_FOLDWORD check in fold-case word tree.\n * When \"mode\" is FIND_KEEPWORD check in keep-case word tree.\n * When \"mode\" is FIND_PREFIX check for word after prefix in fold-case word\n * tree.\n *\n * For a match mip->mi_result is updated.\n */\n    static void\nfind_word(matchinf_T *mip, int mode)\n{\n    idx_T\tarridx = 0;\n    int\t\tendlen[MAXWLEN];    // length at possible word endings\n    idx_T\tendidx[MAXWLEN];    // possible word endings\n    int\t\tendidxcnt = 0;\n    int\t\tlen;\n    int\t\twlen = 0;\n    int\t\tflen;\n    int\t\tc;\n    char_u\t*ptr;\n    idx_T\tlo, hi, m;\n    char_u\t*s;\n    char_u\t*p;\n    int\t\tres = SP_BAD;\n    slang_T\t*slang = mip->mi_lp->lp_slang;\n    unsigned\tflags;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\tword_ends;\n    int\t\tprefix_found;\n    int\t\tnobreak_result;\n\n    if (mode == FIND_KEEPWORD || mode == FIND_KEEPCOMPOUND)\n    {\n\t// Check for word with matching case in keep-case tree.\n\tptr = mip->mi_word;\n\tflen = 9999;\t\t    // no case folding, always enough bytes\n\tbyts = slang->sl_kbyts;\n\tidxs = slang->sl_kidxs;\n\n\tif (mode == FIND_KEEPCOMPOUND)\n\t    // Skip over the previously found word(s).\n\t    wlen += mip->mi_compoff;\n    }\n    else\n    {\n\t// Check for case-folded in case-folded tree.\n\tptr = mip->mi_fword;\n\tflen = mip->mi_fwordlen;    // available case-folded bytes\n\tbyts = slang->sl_fbyts;\n\tidxs = slang->sl_fidxs;\n\n\tif (mode == FIND_PREFIX)\n\t{\n\t    // Skip over the prefix.\n\t    wlen = mip->mi_prefixlen;\n\t    flen -= mip->mi_prefixlen;\n\t}\n\telse if (mode == FIND_COMPOUND)\n\t{\n\t    // Skip over the previously found word(s).\n\t    wlen = mip->mi_compoff;\n\t    flen -= mip->mi_compoff;\n\t}\n\n    }\n\n    if (byts == NULL)\n\treturn;\t\t\t// array is empty\n\n    /*\n     * Repeat advancing in the tree until:\n     * - there is a byte that doesn't match,\n     * - we reach the end of the tree,\n     * - or we reach the end of the line.\n     */\n    for (;;)\n    {\n\tif (flen <= 0 && *mip->mi_fend != NUL)\n\t    flen = fold_more(mip);\n\n\tlen = byts[arridx++];\n\n\t// If the first possible byte is a zero the word could end here.\n\t// Remember this index, we first check for the longest word.\n\tif (byts[arridx] == 0)\n\t{\n\t    if (endidxcnt == MAXWLEN)\n\t    {\n\t\t// Must be a corrupted spell file.\n\t\temsg(_(e_format_error_in_spell_file));\n\t\treturn;\n\t    }\n\t    endlen[endidxcnt] = wlen;\n\t    endidx[endidxcnt++] = arridx++;\n\t    --len;\n\n\t    // Skip over the zeros, there can be several flag/region\n\t    // combinations.\n\t    while (len > 0 && byts[arridx] == 0)\n\t    {\n\t\t++arridx;\n\t\t--len;\n\t    }\n\t    if (len == 0)\n\t\tbreak;\t    // no children, word must end here\n\t}\n\n\t// Stop looking at end of the line.\n\tif (ptr[wlen] == NUL)\n\t    break;\n\n\t// Perform a binary search in the list of accepted bytes.\n\tc = ptr[wlen];\n\tif (c == TAB)\t    // <Tab> is handled like <Space>\n\t    c = ' ';\n\tlo = arridx;\n\thi = arridx + len - 1;\n\twhile (lo < hi)\n\t{\n\t    m = (lo + hi) / 2;\n\t    if (byts[m] > c)\n\t\thi = m - 1;\n\t    else if (byts[m] < c)\n\t\tlo = m + 1;\n\t    else\n\t    {\n\t\tlo = hi = m;\n\t\tbreak;\n\t    }\n\t}\n\n\t// Stop if there is no matching byte.\n\tif (hi < lo || byts[lo] != c)\n\t    break;\n\n\t// Continue at the child (if there is one).\n\tarridx = idxs[lo];\n\t++wlen;\n\t--flen;\n\n\t// One space in the good word may stand for several spaces in the\n\t// checked word.\n\tif (c == ' ')\n\t{\n\t    for (;;)\n\t    {\n\t\tif (flen <= 0 && *mip->mi_fend != NUL)\n\t\t    flen = fold_more(mip);\n\t\tif (ptr[wlen] != ' ' && ptr[wlen] != TAB)\n\t\t    break;\n\t\t++wlen;\n\t\t--flen;\n\t    }\n\t}\n    }\n\n    /*\n     * Verify that one of the possible endings is valid.  Try the longest\n     * first.\n     */\n    while (endidxcnt > 0)\n    {\n\t--endidxcnt;\n\tarridx = endidx[endidxcnt];\n\twlen = endlen[endidxcnt];\n\n\tif ((*mb_head_off)(ptr, ptr + wlen) > 0)\n\t    continue;\t    // not at first byte of character\n\tif (spell_iswordp(ptr + wlen, mip->mi_win))\n\t{\n\t    if (slang->sl_compprog == NULL && !slang->sl_nobreak)\n\t\tcontinue;\t    // next char is a word character\n\t    word_ends = FALSE;\n\t}\n\telse\n\t    word_ends = TRUE;\n\t// The prefix flag is before compound flags.  Once a valid prefix flag\n\t// has been found we try compound flags.\n\tprefix_found = FALSE;\n\n\tif (mode != FIND_KEEPWORD && has_mbyte)\n\t{\n\t    // Compute byte length in original word, length may change\n\t    // when folding case.  This can be slow, take a shortcut when the\n\t    // case-folded word is equal to the keep-case word.\n\t    p = mip->mi_word;\n\t    if (STRNCMP(ptr, p, wlen) != 0)\n\t    {\n\t\tfor (s = ptr; s < ptr + wlen; MB_PTR_ADV(s))\n\t\t    MB_PTR_ADV(p);\n\t\twlen = (int)(p - mip->mi_word);\n\t    }\n\t}\n\n\t// Check flags and region.  For FIND_PREFIX check the condition and\n\t// prefix ID.\n\t// Repeat this if there are more flags/region alternatives until there\n\t// is a match.\n\tres = SP_BAD;\n\tfor (len = byts[arridx - 1]; len > 0 && byts[arridx] == 0;\n\t\t\t\t\t\t\t      --len, ++arridx)\n\t{\n\t    flags = idxs[arridx];\n\n\t    // For the fold-case tree check that the case of the checked word\n\t    // matches with what the word in the tree requires.\n\t    // For keep-case tree the case is always right.  For prefixes we\n\t    // don't bother to check.\n\t    if (mode == FIND_FOLDWORD)\n\t    {\n\t\tif (mip->mi_cend != mip->mi_word + wlen)\n\t\t{\n\t\t    // mi_capflags was set for a different word length, need\n\t\t    // to do it again.\n\t\t    mip->mi_cend = mip->mi_word + wlen;\n\t\t    mip->mi_capflags = captype(mip->mi_word, mip->mi_cend);\n\t\t}\n\n\t\tif (mip->mi_capflags == WF_KEEPCAP\n\t\t\t\t|| !spell_valid_case(mip->mi_capflags, flags))\n\t\t    continue;\n\t    }\n\n\t    // When mode is FIND_PREFIX the word must support the prefix:\n\t    // check the prefix ID and the condition.  Do that for the list at\n\t    // mip->mi_prefarridx that find_prefix() filled.\n\t    else if (mode == FIND_PREFIX && !prefix_found)\n\t    {\n\t\tc = valid_word_prefix(mip->mi_prefcnt, mip->mi_prefarridx,\n\t\t\t\t    flags,\n\t\t\t\t    mip->mi_word + mip->mi_cprefixlen, slang,\n\t\t\t\t    FALSE);\n\t\tif (c == 0)\n\t\t    continue;\n\n\t\t// Use the WF_RARE flag for a rare prefix.\n\t\tif (c & WF_RAREPFX)\n\t\t    flags |= WF_RARE;\n\t\tprefix_found = TRUE;\n\t    }\n\n\t    if (slang->sl_nobreak)\n\t    {\n\t\tif ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND)\n\t\t\t&& (flags & WF_BANNED) == 0)\n\t\t{\n\t\t    // NOBREAK: found a valid following word.  That's all we\n\t\t    // need to know, so return.\n\t\t    mip->mi_result = SP_OK;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    else if ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND\n\t\t\t\t\t\t\t\t|| !word_ends))\n\t    {\n\t\t// If there is no compound flag or the word is shorter than\n\t\t// COMPOUNDMIN reject it quickly.\n\t\t// Makes you wonder why someone puts a compound flag on a word\n\t\t// that's too short...  Myspell compatibility requires this\n\t\t// anyway.\n\t\tif (((unsigned)flags >> 24) == 0\n\t\t\t     || wlen - mip->mi_compoff < slang->sl_compminlen)\n\t\t    continue;\n\t\t// For multi-byte chars check character length against\n\t\t// COMPOUNDMIN.\n\t\tif (has_mbyte\n\t\t\t&& slang->sl_compminlen > 0\n\t\t\t&& mb_charlen_len(mip->mi_word + mip->mi_compoff,\n\t\t\t\twlen - mip->mi_compoff) < slang->sl_compminlen)\n\t\t\tcontinue;\n\n\t\t// Limit the number of compound words to COMPOUNDWORDMAX if no\n\t\t// maximum for syllables is specified.\n\t\tif (!word_ends && mip->mi_complen + mip->mi_compextra + 2\n\t\t\t\t\t\t\t   > slang->sl_compmax\n\t\t\t\t\t   && slang->sl_compsylmax == MAXWLEN)\n\t\t    continue;\n\n\t\t// Don't allow compounding on a side where an affix was added,\n\t\t// unless COMPOUNDPERMITFLAG was used.\n\t\tif (mip->mi_complen > 0 && (flags & WF_NOCOMPBEF))\n\t\t    continue;\n\t\tif (!word_ends && (flags & WF_NOCOMPAFT))\n\t\t    continue;\n\n\t\t// Quickly check if compounding is possible with this flag.\n\t\tif (!byte_in_str(mip->mi_complen == 0\n\t\t\t\t\t? slang->sl_compstartflags\n\t\t\t\t\t: slang->sl_compallflags,\n\t\t\t\t\t    ((unsigned)flags >> 24)))\n\t\t    continue;\n\n\t\t// If there is a match with a CHECKCOMPOUNDPATTERN rule\n\t\t// discard the compound word.\n\t\tif (match_checkcompoundpattern(ptr, wlen, &slang->sl_comppat))\n\t\t    continue;\n\n\t\tif (mode == FIND_COMPOUND)\n\t\t{\n\t\t    int\t    capflags;\n\n\t\t    // Need to check the caps type of the appended compound\n\t\t    // word.\n\t\t    if (has_mbyte && STRNCMP(ptr, mip->mi_word,\n\t\t\t\t\t\t\tmip->mi_compoff) != 0)\n\t\t    {\n\t\t\t// case folding may have changed the length\n\t\t\tp = mip->mi_word;\n\t\t\tfor (s = ptr; s < ptr + mip->mi_compoff; MB_PTR_ADV(s))\n\t\t\t    MB_PTR_ADV(p);\n\t\t    }\n\t\t    else\n\t\t\tp = mip->mi_word + mip->mi_compoff;\n\t\t    capflags = captype(p, mip->mi_word + wlen);\n\t\t    if (capflags == WF_KEEPCAP || (capflags == WF_ALLCAP\n\t\t\t\t\t\t && (flags & WF_FIXCAP) != 0))\n\t\t\tcontinue;\n\n\t\t    if (capflags != WF_ALLCAP)\n\t\t    {\n\t\t\t// When the character before the word is a word\n\t\t\t// character we do not accept a Onecap word.  We do\n\t\t\t// accept a no-caps word, even when the dictionary\n\t\t\t// word specifies ONECAP.\n\t\t\tMB_PTR_BACK(mip->mi_word, p);\n\t\t\tif (spell_iswordp_nmw(p, mip->mi_win)\n\t\t\t\t? capflags == WF_ONECAP\n\t\t\t\t: (flags & WF_ONECAP) != 0\n\t\t\t\t\t\t     && capflags != WF_ONECAP)\n\t\t\t    continue;\n\t\t    }\n\t\t}\n\n\t\t// If the word ends the sequence of compound flags of the\n\t\t// words must match with one of the COMPOUNDRULE items and\n\t\t// the number of syllables must not be too large.\n\t\tmip->mi_compflags[mip->mi_complen] = ((unsigned)flags >> 24);\n\t\tmip->mi_compflags[mip->mi_complen + 1] = NUL;\n\t\tif (word_ends)\n\t\t{\n\t\t    char_u\tfword[MAXWLEN];\n\n\t\t    if (slang->sl_compsylmax < MAXWLEN)\n\t\t    {\n\t\t\t// \"fword\" is only needed for checking syllables.\n\t\t\tif (ptr == mip->mi_word)\n\t\t\t    (void)spell_casefold(mip->mi_win,\n\t\t\t\t\t\t    ptr, wlen, fword, MAXWLEN);\n\t\t\telse\n\t\t\t    vim_strncpy(fword, ptr, endlen[endidxcnt]);\n\t\t    }\n\t\t    if (!can_compound(slang, fword, mip->mi_compflags))\n\t\t\tcontinue;\n\t\t}\n\t\telse if (slang->sl_comprules != NULL\n\t\t\t     && !match_compoundrule(slang, mip->mi_compflags))\n\t\t    // The compound flags collected so far do not match any\n\t\t    // COMPOUNDRULE, discard the compounded word.\n\t\t    continue;\n\t    }\n\n\t    // Check NEEDCOMPOUND: can't use word without compounding.\n\t    else if (flags & WF_NEEDCOMP)\n\t\tcontinue;\n\n\t    nobreak_result = SP_OK;\n\n\t    if (!word_ends)\n\t    {\n\t\tint\tsave_result = mip->mi_result;\n\t\tchar_u\t*save_end = mip->mi_end;\n\t\tlangp_T\t*save_lp = mip->mi_lp;\n\t\tint\tlpi;\n\n\t\t// Check that a valid word follows.  If there is one and we\n\t\t// are compounding, it will set \"mi_result\", thus we are\n\t\t// always finished here.  For NOBREAK we only check that a\n\t\t// valid word follows.\n\t\t// Recursive!\n\t\tif (slang->sl_nobreak)\n\t\t    mip->mi_result = SP_BAD;\n\n\t\t// Find following word in case-folded tree.\n\t\tmip->mi_compoff = endlen[endidxcnt];\n\t\tif (has_mbyte && mode == FIND_KEEPWORD)\n\t\t{\n\t\t    // Compute byte length in case-folded word from \"wlen\":\n\t\t    // byte length in keep-case word.  Length may change when\n\t\t    // folding case.  This can be slow, take a shortcut when\n\t\t    // the case-folded word is equal to the keep-case word.\n\t\t    p = mip->mi_fword;\n\t\t    if (STRNCMP(ptr, p, wlen) != 0)\n\t\t    {\n\t\t\tfor (s = ptr; s < ptr + wlen; MB_PTR_ADV(s))\n\t\t\t    MB_PTR_ADV(p);\n\t\t\tmip->mi_compoff = (int)(p - mip->mi_fword);\n\t\t    }\n\t\t}\n#if 0 // Disabled, see below\n\t\tc = mip->mi_compoff;\n#endif\n\t\t++mip->mi_complen;\n\t\tif (flags & WF_COMPROOT)\n\t\t    ++mip->mi_compextra;\n\n\t\t// For NOBREAK we need to try all NOBREAK languages, at least\n\t\t// to find the \".add\" file(s).\n\t\tfor (lpi = 0; lpi < mip->mi_win->w_s->b_langp.ga_len; ++lpi)\n\t\t{\n\t\t    if (slang->sl_nobreak)\n\t\t    {\n\t\t\tmip->mi_lp = LANGP_ENTRY(mip->mi_win->w_s->b_langp, lpi);\n\t\t\tif (mip->mi_lp->lp_slang->sl_fidxs == NULL\n\t\t\t\t\t || !mip->mi_lp->lp_slang->sl_nobreak)\n\t\t\t    continue;\n\t\t    }\n\n\t\t    find_word(mip, FIND_COMPOUND);\n\n\t\t    // When NOBREAK any word that matches is OK.  Otherwise we\n\t\t    // need to find the longest match, thus try with keep-case\n\t\t    // and prefix too.\n\t\t    if (!slang->sl_nobreak || mip->mi_result == SP_BAD)\n\t\t    {\n\t\t\t// Find following word in keep-case tree.\n\t\t\tmip->mi_compoff = wlen;\n\t\t\tfind_word(mip, FIND_KEEPCOMPOUND);\n\n#if 0\t    // Disabled, a prefix must not appear halfway a compound word,\n\t    // unless the COMPOUNDPERMITFLAG is used and then it can't be a\n\t    // postponed prefix.\n\t\t\tif (!slang->sl_nobreak || mip->mi_result == SP_BAD)\n\t\t\t{\n\t\t\t    // Check for following word with prefix.\n\t\t\t    mip->mi_compoff = c;\n\t\t\t    find_prefix(mip, FIND_COMPOUND);\n\t\t\t}\n#endif\n\t\t    }\n\n\t\t    if (!slang->sl_nobreak)\n\t\t\tbreak;\n\t\t}\n\t\t--mip->mi_complen;\n\t\tif (flags & WF_COMPROOT)\n\t\t    --mip->mi_compextra;\n\t\tmip->mi_lp = save_lp;\n\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    nobreak_result = mip->mi_result;\n\t\t    mip->mi_result = save_result;\n\t\t    mip->mi_end = save_end;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (mip->mi_result == SP_OK)\n\t\t\tbreak;\n\t\t    continue;\n\t\t}\n\t    }\n\n\t    if (flags & WF_BANNED)\n\t\tres = SP_BANNED;\n\t    else if (flags & WF_REGION)\n\t    {\n\t\t// Check region.\n\t\tif ((mip->mi_lp->lp_region & (flags >> 16)) != 0)\n\t\t    res = SP_OK;\n\t\telse\n\t\t    res = SP_LOCAL;\n\t    }\n\t    else if (flags & WF_RARE)\n\t\tres = SP_RARE;\n\t    else\n\t\tres = SP_OK;\n\n\t    // Always use the longest match and the best result.  For NOBREAK\n\t    // we separately keep the longest match without a following good\n\t    // word as a fall-back.\n\t    if (nobreak_result == SP_BAD)\n\t    {\n\t\tif (mip->mi_result2 > res)\n\t\t{\n\t\t    mip->mi_result2 = res;\n\t\t    mip->mi_end2 = mip->mi_word + wlen;\n\t\t}\n\t\telse if (mip->mi_result2 == res\n\t\t\t\t\t&& mip->mi_end2 < mip->mi_word + wlen)\n\t\t    mip->mi_end2 = mip->mi_word + wlen;\n\t    }\n\t    else if (mip->mi_result > res)\n\t    {\n\t\tmip->mi_result = res;\n\t\tmip->mi_end = mip->mi_word + wlen;\n\t    }\n\t    else if (mip->mi_result == res && mip->mi_end < mip->mi_word + wlen)\n\t\tmip->mi_end = mip->mi_word + wlen;\n\n\t    if (mip->mi_result == SP_OK)\n\t\tbreak;\n\t}\n\n\tif (mip->mi_result == SP_OK)\n\t    break;\n    }\n}\n\n/*\n * Return TRUE if there is a match between the word ptr[wlen] and\n * CHECKCOMPOUNDPATTERN rules, assuming that we will concatenate with another\n * word.\n * A match means that the first part of CHECKCOMPOUNDPATTERN matches at the\n * end of ptr[wlen] and the second part matches after it.\n */\n    int\nmatch_checkcompoundpattern(\n    char_u\t*ptr,\n    int\t\twlen,\n    garray_T\t*gap)  // &sl_comppat\n{\n    int\t\ti;\n    char_u\t*p;\n    int\t\tlen;\n\n    for (i = 0; i + 1 < gap->ga_len; i += 2)\n    {\n\tp = ((char_u **)gap->ga_data)[i + 1];\n\tif (STRNCMP(ptr + wlen, p, STRLEN(p)) == 0)\n\t{\n\t    // Second part matches at start of following compound word, now\n\t    // check if first part matches at end of previous word.\n\t    p = ((char_u **)gap->ga_data)[i];\n\t    len = (int)STRLEN(p);\n\t    if (len <= wlen && STRNCMP(ptr + wlen - len, p, len) == 0)\n\t\treturn TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if \"flags\" is a valid sequence of compound flags and \"word\"\n * does not have too many syllables.\n */\n    int\ncan_compound(slang_T *slang, char_u *word, char_u *flags)\n{\n    char_u\tuflags[MAXWLEN * 2];\n    int\t\ti;\n    char_u\t*p;\n\n    if (slang->sl_compprog == NULL)\n\treturn FALSE;\n    if (enc_utf8)\n    {\n\t// Need to convert the single byte flags to utf8 characters.\n\tp = uflags;\n\tfor (i = 0; flags[i] != NUL; ++i)\n\t    p += utf_char2bytes(flags[i], p);\n\t*p = NUL;\n\tp = uflags;\n    }\n    else\n\tp = flags;\n    if (!vim_regexec_prog(&slang->sl_compprog, FALSE, p, 0))\n\treturn FALSE;\n\n    // Count the number of syllables.  This may be slow, do it last.  If there\n    // are too many syllables AND the number of compound words is above\n    // COMPOUNDWORDMAX then compounding is not allowed.\n    if (slang->sl_compsylmax < MAXWLEN\n\t\t       && count_syllables(slang, word) > slang->sl_compsylmax)\n\treturn (int)STRLEN(flags) < slang->sl_compmax;\n    return TRUE;\n}\n\n/*\n * Return TRUE if the compound flags in compflags[] match the start of any\n * compound rule.  This is used to stop trying a compound if the flags\n * collected so far can't possibly match any compound rule.\n * Caller must check that slang->sl_comprules is not NULL.\n */\n    int\nmatch_compoundrule(slang_T *slang, char_u *compflags)\n{\n    char_u\t*p;\n    int\t\ti;\n    int\t\tc;\n\n    // loop over all the COMPOUNDRULE entries\n    for (p = slang->sl_comprules; *p != NUL; ++p)\n    {\n\t// loop over the flags in the compound word we have made, match\n\t// them against the current rule entry\n\tfor (i = 0; ; ++i)\n\t{\n\t    c = compflags[i];\n\t    if (c == NUL)\n\t\t// found a rule that matches for the flags we have so far\n\t\treturn TRUE;\n\t    if (*p == '/' || *p == NUL)\n\t\tbreak;  // end of rule, it's too short\n\t    if (*p == '[')\n\t    {\n\t\tint match = FALSE;\n\n\t\t// compare against all the flags in []\n\t\t++p;\n\t\twhile (*p != ']' && *p != NUL)\n\t\t    if (*p++ == c)\n\t\t\tmatch = TRUE;\n\t\tif (!match)\n\t\t    break;  // none matches\n\t    }\n\t    else if (*p != c)\n\t\tbreak;  // flag of word doesn't match flag in pattern\n\t    ++p;\n\t}\n\n\t// Skip to the next \"/\", where the next pattern starts.\n\tp = vim_strchr(p, '/');\n\tif (p == NULL)\n\t    break;\n    }\n\n    // Checked all the rules and none of them match the flags, so there\n    // can't possibly be a compound starting with these flags.\n    return FALSE;\n}\n\n/*\n * Return non-zero if the prefix indicated by \"arridx\" matches with the prefix\n * ID in \"flags\" for the word \"word\".\n * The WF_RAREPFX flag is included in the return value for a rare prefix.\n */\n    int\nvalid_word_prefix(\n    int\t\ttotprefcnt,\t// nr of prefix IDs\n    int\t\tarridx,\t\t// idx in sl_pidxs[]\n    int\t\tflags,\n    char_u\t*word,\n    slang_T\t*slang,\n    int\t\tcond_req)\t// only use prefixes with a condition\n{\n    int\t\tprefcnt;\n    int\t\tpidx;\n    regprog_T\t**rp;\n    int\t\tprefid;\n\n    prefid = (unsigned)flags >> 24;\n    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)\n    {\n\tpidx = slang->sl_pidxs[arridx + prefcnt];\n\n\t// Check the prefix ID.\n\tif (prefid != (pidx & 0xff))\n\t    continue;\n\n\t// Check if the prefix doesn't combine and the word already has a\n\t// suffix.\n\tif ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))\n\t    continue;\n\n\t// Check the condition, if there is one.  The condition index is\n\t// stored in the two bytes above the prefix ID byte.\n\trp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];\n\tif (*rp != NULL)\n\t{\n\t    if (!vim_regexec_prog(rp, FALSE, word, 0))\n\t\tcontinue;\n\t}\n\telse if (cond_req)\n\t    continue;\n\n\t// It's a match!  Return the WF_ flags.\n\treturn pidx;\n    }\n    return 0;\n}\n\n/*\n * Check if the word at \"mip->mi_word\" has a matching prefix.\n * If it does, then check the following word.\n *\n * If \"mode\" is \"FIND_COMPOUND\" then do the same after another word, find a\n * prefix in a compound word.\n *\n * For a match mip->mi_result is updated.\n */\n    static void\nfind_prefix(matchinf_T *mip, int mode)\n{\n    idx_T\tarridx = 0;\n    int\t\tlen;\n    int\t\twlen = 0;\n    int\t\tflen;\n    int\t\tc;\n    char_u\t*ptr;\n    idx_T\tlo, hi, m;\n    slang_T\t*slang = mip->mi_lp->lp_slang;\n    char_u\t*byts;\n    idx_T\t*idxs;\n\n    byts = slang->sl_pbyts;\n    if (byts == NULL)\n\treturn;\t\t\t// array is empty\n\n    // We use the case-folded word here, since prefixes are always\n    // case-folded.\n    ptr = mip->mi_fword;\n    flen = mip->mi_fwordlen;    // available case-folded bytes\n    if (mode == FIND_COMPOUND)\n    {\n\t// Skip over the previously found word(s).\n\tptr += mip->mi_compoff;\n\tflen -= mip->mi_compoff;\n    }\n    idxs = slang->sl_pidxs;\n\n    /*\n     * Repeat advancing in the tree until:\n     * - there is a byte that doesn't match,\n     * - we reach the end of the tree,\n     * - or we reach the end of the line.\n     */\n    for (;;)\n    {\n\tif (flen == 0 && *mip->mi_fend != NUL)\n\t    flen = fold_more(mip);\n\n\tlen = byts[arridx++];\n\n\t// If the first possible byte is a zero the prefix could end here.\n\t// Check if the following word matches and supports the prefix.\n\tif (byts[arridx] == 0)\n\t{\n\t    // There can be several prefixes with different conditions.  We\n\t    // try them all, since we don't know which one will give the\n\t    // longest match.  The word is the same each time, pass the list\n\t    // of possible prefixes to find_word().\n\t    mip->mi_prefarridx = arridx;\n\t    mip->mi_prefcnt = len;\n\t    while (len > 0 && byts[arridx] == 0)\n\t    {\n\t\t++arridx;\n\t\t--len;\n\t    }\n\t    mip->mi_prefcnt -= len;\n\n\t    // Find the word that comes after the prefix.\n\t    mip->mi_prefixlen = wlen;\n\t    if (mode == FIND_COMPOUND)\n\t\t// Skip over the previously found word(s).\n\t\tmip->mi_prefixlen += mip->mi_compoff;\n\n\t    if (has_mbyte)\n\t    {\n\t\t// Case-folded length may differ from original length.\n\t\tmip->mi_cprefixlen = nofold_len(mip->mi_fword,\n\t\t\t\t\t     mip->mi_prefixlen, mip->mi_word);\n\t    }\n\t    else\n\t\tmip->mi_cprefixlen = mip->mi_prefixlen;\n\t    find_word(mip, FIND_PREFIX);\n\n\n\t    if (len == 0)\n\t\tbreak;\t    // no children, word must end here\n\t}\n\n\t// Stop looking at end of the line.\n\tif (ptr[wlen] == NUL)\n\t    break;\n\n\t// Perform a binary search in the list of accepted bytes.\n\tc = ptr[wlen];\n\tlo = arridx;\n\thi = arridx + len - 1;\n\twhile (lo < hi)\n\t{\n\t    m = (lo + hi) / 2;\n\t    if (byts[m] > c)\n\t\thi = m - 1;\n\t    else if (byts[m] < c)\n\t\tlo = m + 1;\n\t    else\n\t    {\n\t\tlo = hi = m;\n\t\tbreak;\n\t    }\n\t}\n\n\t// Stop if there is no matching byte.\n\tif (hi < lo || byts[lo] != c)\n\t    break;\n\n\t// Continue at the child (if there is one).\n\tarridx = idxs[lo];\n\t++wlen;\n\t--flen;\n    }\n}\n\n/*\n * Need to fold at least one more character.  Do until next non-word character\n * for efficiency.  Include the non-word character too.\n * Return the length of the folded chars in bytes.\n */\n    static int\nfold_more(matchinf_T *mip)\n{\n    int\t\tflen;\n    char_u\t*p;\n\n    p = mip->mi_fend;\n    do\n\tMB_PTR_ADV(mip->mi_fend);\n    while (*mip->mi_fend != NUL && spell_iswordp(mip->mi_fend, mip->mi_win));\n\n    // Include the non-word character so that we can check for the word end.\n    if (*mip->mi_fend != NUL)\n\tMB_PTR_ADV(mip->mi_fend);\n\n    (void)spell_casefold(mip->mi_win, p, (int)(mip->mi_fend - p),\n\t\t\t     mip->mi_fword + mip->mi_fwordlen,\n\t\t\t     MAXWLEN - mip->mi_fwordlen);\n    flen = (int)STRLEN(mip->mi_fword + mip->mi_fwordlen);\n    mip->mi_fwordlen += flen;\n    return flen;\n}\n\n/*\n * Check case flags for a word.  Return TRUE if the word has the requested\n * case.\n */\n    int\nspell_valid_case(\n    int\t    wordflags,\t    // flags for the checked word.\n    int\t    treeflags)\t    // flags for the word in the spell tree\n{\n    return ((wordflags == WF_ALLCAP && (treeflags & WF_FIXCAP) == 0)\n\t    || ((treeflags & (WF_ALLCAP | WF_KEEPCAP)) == 0\n\t\t&& ((treeflags & WF_ONECAP) == 0\n\t\t\t\t\t   || (wordflags & WF_ONECAP) != 0)));\n}\n\n/*\n * Return TRUE if spell checking is not enabled.\n */\n    static int\nno_spell_checking(win_T *wp)\n{\n    if (!wp->w_p_spell || *wp->w_s->b_p_spl == NUL\n\t\t\t\t\t || wp->w_s->b_langp.ga_len == 0)\n    {\n\temsg(_(e_spell_checking_is_not_possible));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Move to next spell error.\n * \"curline\" is FALSE for \"[s\", \"]s\", \"[S\" and \"]S\".\n * \"curline\" is TRUE to find word under/after cursor in the same line.\n * For Insert mode completion \"dir\" is BACKWARD and \"curline\" is TRUE: move\n * to after badly spelled word before the cursor.\n * Return 0 if not found, length of the badly spelled word otherwise.\n */\n    int\nspell_move_to(\n    win_T\t*wp,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tallwords,\t// TRUE for \"[s\"/\"]s\", FALSE for \"[S\"/\"]S\"\n    int\t\tcurline,\n    hlf_T\t*attrp)\t\t// return: attributes of bad word or NULL\n\t\t\t\t// (only when \"dir\" is FORWARD)\n{\n    linenr_T\tlnum;\n    pos_T\tfound_pos;\n    int\t\tfound_len = 0;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\t*endp;\n    hlf_T\tattr = 0;\n    int\t\tlen;\n#ifdef FEAT_SYN_HL\n    int\t\thas_syntax = syntax_present(wp);\n#endif\n    int\t\tcol;\n    int\t\tcan_spell;\n    char_u\t*buf = NULL;\n    int\t\tbuflen = 0;\n    int\t\tskip = 0;\n    int\t\tcapcol = -1;\n    int\t\tfound_one = FALSE;\n    int\t\twrapped = FALSE;\n\n    if (no_spell_checking(wp))\n\treturn 0;\n\n    /*\n     * Start looking for bad word at the start of the line, because we can't\n     * start halfway a word, we don't know where it starts or ends.\n     *\n     * When searching backwards, we continue in the line to find the last\n     * bad word (in the cursor line: before the cursor).\n     *\n     * We concatenate the start of the next line, so that wrapped words work\n     * (e.g. \"et<line-break>cetera\").  Doesn't work when searching backwards\n     * though...\n     */\n    lnum = wp->w_cursor.lnum;\n    CLEAR_POS(&found_pos);\n\n    while (!got_int)\n    {\n\tint empty_line;\n\n\tline = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\n\tlen = (int)STRLEN(line);\n\tif (buflen < len + MAXWLEN + 2)\n\t{\n\t    vim_free(buf);\n\t    buflen = len + MAXWLEN + 2;\n\t    buf = alloc(buflen);\n\t    if (buf == NULL)\n\t\tbreak;\n\t}\n\n\t// In first line check first word for Capital.\n\tif (lnum == 1)\n\t    capcol = 0;\n\n\t// For checking first word with a capital skip white space.\n\tif (capcol == 0)\n\t    capcol = getwhitecols(line);\n\telse if (curline && wp == curwin)\n\t{\n\t    // For spellbadword(): check if first word needs a capital.\n\t    col = getwhitecols(line);\n\t    if (check_need_cap(lnum, col))\n\t\tcapcol = col;\n\n\t    // Need to get the line again, may have looked at the previous\n\t    // one.\n\t    line = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\t}\n\n\t// Copy the line into \"buf\" and append the start of the next line if\n\t// possible.  Note: this ml_get_buf() may make \"line\" invalid, check\n\t// for empty line first.\n\tempty_line = *skipwhite(line) == NUL;\n\tSTRCPY(buf, line);\n\tif (lnum < wp->w_buffer->b_ml.ml_line_count)\n\t    spell_cat_line(buf + STRLEN(buf),\n\t\t\t  ml_get_buf(wp->w_buffer, lnum + 1, FALSE), MAXWLEN);\n\n\tp = buf + skip;\n\tendp = buf + len;\n\twhile (p < endp)\n\t{\n\t    // When searching backward don't search after the cursor.  Unless\n\t    // we wrapped around the end of the buffer.\n\t    if (dir == BACKWARD\n\t\t    && lnum == wp->w_cursor.lnum\n\t\t    && !wrapped\n\t\t    && (colnr_T)(p - buf) >= wp->w_cursor.col)\n\t\tbreak;\n\n\t    // start of word\n\t    attr = HLF_COUNT;\n\t    len = spell_check(wp, p, &attr, &capcol, FALSE);\n\n\t    if (attr != HLF_COUNT)\n\t    {\n\t\t// We found a bad word.  Check the attribute.\n\t\tif (allwords || attr == HLF_SPB)\n\t\t{\n\t\t    // When searching forward only accept a bad word after\n\t\t    // the cursor.\n\t\t    if (dir == BACKWARD\n\t\t\t    || lnum != wp->w_cursor.lnum\n\t\t\t    || (wrapped\n\t\t\t\t|| (colnr_T)(curline ? p - buf + len\n\t\t\t\t\t\t     : p - buf)\n\t\t\t\t\t\t  > wp->w_cursor.col))\n\t\t    {\n#ifdef FEAT_SYN_HL\n\t\t\tif (has_syntax)\n\t\t\t{\n\t\t\t    col = (int)(p - buf);\n\t\t\t    (void)syn_get_id(wp, lnum, (colnr_T)col,\n\t\t\t\t\t\t    FALSE, &can_spell, FALSE);\n\t\t\t    if (!can_spell)\n\t\t\t\tattr = HLF_COUNT;\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t    can_spell = TRUE;\n\n\t\t\tif (can_spell)\n\t\t\t{\n\t\t\t    found_one = TRUE;\n\t\t\t    found_pos.lnum = lnum;\n\t\t\t    found_pos.col = (int)(p - buf);\n\t\t\t    found_pos.coladd = 0;\n\t\t\t    if (dir == FORWARD)\n\t\t\t    {\n\t\t\t\t// No need to search further.\n\t\t\t\twp->w_cursor = found_pos;\n\t\t\t\tvim_free(buf);\n\t\t\t\tif (attrp != NULL)\n\t\t\t\t    *attrp = attr;\n\t\t\t\treturn len;\n\t\t\t    }\n\t\t\t    else if (curline)\n\t\t\t\t// Insert mode completion: put cursor after\n\t\t\t\t// the bad word.\n\t\t\t\tfound_pos.col += len;\n\t\t\t    found_len = len;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tfound_one = TRUE;\n\t\t}\n\t    }\n\n\t    // advance to character after the word\n\t    p += len;\n\t    capcol -= len;\n\t}\n\n\tif (dir == BACKWARD && found_pos.lnum != 0)\n\t{\n\t    // Use the last match in the line (before the cursor).\n\t    wp->w_cursor = found_pos;\n\t    vim_free(buf);\n\t    return found_len;\n\t}\n\n\tif (curline)\n\t    break;\t// only check cursor line\n\n\t// If we are back at the starting line and searched it again there\n\t// is no match, give up.\n\tif (lnum == wp->w_cursor.lnum && wrapped)\n\t    break;\n\n\t// Advance to next line.\n\tif (dir == BACKWARD)\n\t{\n\t    if (lnum > 1)\n\t\t--lnum;\n\t    else if (!p_ws)\n\t\tbreak;\t    // at first line and 'nowrapscan'\n\t    else\n\t    {\n\t\t// Wrap around to the end of the buffer.  May search the\n\t\t// starting line again and accept the last match.\n\t\tlnum = wp->w_buffer->b_ml.ml_line_count;\n\t\twrapped = TRUE;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(top_bot_msg), TRUE);\n\t    }\n\t    capcol = -1;\n\t}\n\telse\n\t{\n\t    if (lnum < wp->w_buffer->b_ml.ml_line_count)\n\t\t++lnum;\n\t    else if (!p_ws)\n\t\tbreak;\t    // at first line and 'nowrapscan'\n\t    else\n\t    {\n\t\t// Wrap around to the start of the buffer.  May search the\n\t\t// starting line again and accept the first match.\n\t\tlnum = 1;\n\t\twrapped = TRUE;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(bot_top_msg), TRUE);\n\t    }\n\n\t    // If we are back at the starting line and there is no match then\n\t    // give up.\n\t    if (lnum == wp->w_cursor.lnum && !found_one)\n\t\tbreak;\n\n\t    // Skip the characters at the start of the next line that were\n\t    // included in a match crossing line boundaries.\n\t    if (attr == HLF_COUNT)\n\t\tskip = (int)(p - endp);\n\t    else\n\t\tskip = 0;\n\n\t    // Capcol skips over the inserted space.\n\t    --capcol;\n\n\t    // But after empty line check first word in next line\n\t    if (empty_line)\n\t\tcapcol = 0;\n\t}\n\n\tline_breakcheck();\n    }\n\n    vim_free(buf);\n    return 0;\n}\n\n/*\n * For spell checking: concatenate the start of the following line \"line\" into\n * \"buf\", blanking-out special characters.  Copy less than \"maxlen\" bytes.\n * Keep the blanks at the start of the next line, this is used in win_line()\n * to skip those bytes if the word was OK.\n */\n    void\nspell_cat_line(char_u *buf, char_u *line, int maxlen)\n{\n    char_u\t*p;\n    int\t\tn;\n\n    p = skipwhite(line);\n    while (vim_strchr((char_u *)\"*#/\\\"\\t\", *p) != NULL)\n\tp = skipwhite(p + 1);\n\n    if (*p != NUL)\n    {\n\t// Only worth concatenating if there is something else than spaces to\n\t// concatenate.\n\tn = (int)(p - line) + 1;\n\tif (n < maxlen - 1)\n\t{\n\t    vim_memset(buf, ' ', n);\n\t    vim_strncpy(buf +  n, p, maxlen - 1 - n);\n\t}\n    }\n}\n\n/*\n * Structure used for the cookie argument of do_in_runtimepath().\n */\ntypedef struct spelload_S\n{\n    char_u  sl_lang[MAXWLEN + 1];\t// language name\n    slang_T *sl_slang;\t\t\t// resulting slang_T struct\n    int\t    sl_nobreak;\t\t\t// NOBREAK language found\n} spelload_T;\n\n/*\n * Load word list(s) for \"lang\" from Vim spell file(s).\n * \"lang\" must be the language without the region: e.g., \"en\".\n */\n    static void\nspell_load_lang(char_u *lang)\n{\n    char_u\tfname_enc[85];\n    int\t\tr;\n    spelload_T\tsl;\n    int\t\tround;\n\n    // Copy the language name to pass it to spell_load_cb() as a cookie.\n    // It's truncated when an error is detected.\n    STRCPY(sl.sl_lang, lang);\n    sl.sl_slang = NULL;\n    sl.sl_nobreak = FALSE;\n\n    // We may retry when no spell file is found for the language, an\n    // autocommand may load it then.\n    for (round = 1; round <= 2; ++round)\n    {\n\t/*\n\t * Find the first spell file for \"lang\" in 'runtimepath' and load it.\n\t */\n\tvim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,\n#ifdef VMS\n\t\t\t\t\t\"spell/%s_%s.spl\",\n#else\n\t\t\t\t\t\"spell/%s.%s.spl\",\n#endif\n\t\t\t\t\t\t\t   lang, spell_enc());\n\tr = do_in_runtimepath(fname_enc, 0, spell_load_cb, &sl);\n\n\tif (r == FAIL && *sl.sl_lang != NUL)\n\t{\n\t    // Try loading the ASCII version.\n\t    vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,\n#ifdef VMS\n\t\t\t\t\t\t  \"spell/%s_ascii.spl\",\n#else\n\t\t\t\t\t\t  \"spell/%s.ascii.spl\",\n#endif\n\t\t\t\t\t\t\t\t\tlang);\n\t    r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &sl);\n\n\t    if (r == FAIL && *sl.sl_lang != NUL && round == 1\n\t\t    && apply_autocmds(EVENT_SPELLFILEMISSING, lang,\n\t\t\t\t\t      curbuf->b_fname, FALSE, curbuf))\n\t\tcontinue;\n\t    break;\n\t}\n\tbreak;\n    }\n\n    if (r == FAIL)\n    {\n\tsmsg(\n#ifdef VMS\n\t_(\"Warning: Cannot find word list \\\"%s_%s.spl\\\" or \\\"%s_ascii.spl\\\"\"),\n#else\n\t_(\"Warning: Cannot find word list \\\"%s.%s.spl\\\" or \\\"%s.ascii.spl\\\"\"),\n#endif\n\t\t\t\t\t\t     lang, spell_enc(), lang);\n    }\n    else if (sl.sl_slang != NULL)\n    {\n\t// At least one file was loaded, now load ALL the additions.\n\tSTRCPY(fname_enc + STRLEN(fname_enc) - 3, \"add.spl\");\n\tdo_in_runtimepath(fname_enc, DIP_ALL, spell_load_cb, &sl);\n    }\n}\n\n/*\n * Return the encoding used for spell checking: Use 'encoding', except that we\n * use \"latin1\" for \"latin9\".  And limit to 60 characters (just in case).\n */\n    char_u *\nspell_enc(void)\n{\n\n    if (STRLEN(p_enc) < 60 && STRCMP(p_enc, \"iso-8859-15\") != 0)\n\treturn p_enc;\n    return (char_u *)\"latin1\";\n}\n\n/*\n * Get the name of the .spl file for the internal wordlist into\n * \"fname[MAXPATHL]\".\n */\n    static void\nint_wordlist_spl(char_u *fname)\n{\n    vim_snprintf((char *)fname, MAXPATHL, SPL_FNAME_TMPL,\n\t\t\t\t\t\t  int_wordlist, spell_enc());\n}\n\n/*\n * Allocate a new slang_T for language \"lang\".  \"lang\" can be NULL.\n * Caller must fill \"sl_next\".\n */\n    slang_T *\nslang_alloc(char_u *lang)\n{\n    slang_T *lp;\n\n    lp = ALLOC_CLEAR_ONE(slang_T);\n    if (lp != NULL)\n    {\n\tif (lang != NULL)\n\t    lp->sl_name = vim_strsave(lang);\n\tga_init2(&lp->sl_rep, sizeof(fromto_T), 10);\n\tga_init2(&lp->sl_repsal, sizeof(fromto_T), 10);\n\tlp->sl_compmax = MAXWLEN;\n\tlp->sl_compsylmax = MAXWLEN;\n\thash_init(&lp->sl_wordcount);\n    }\n\n    return lp;\n}\n\n/*\n * Free the contents of an slang_T and the structure itself.\n */\n    void\nslang_free(slang_T *lp)\n{\n    vim_free(lp->sl_name);\n    vim_free(lp->sl_fname);\n    slang_clear(lp);\n    vim_free(lp);\n}\n\n/*\n * Clear an slang_T so that the file can be reloaded.\n */\n    void\nslang_clear(slang_T *lp)\n{\n    garray_T\t*gap;\n    fromto_T\t*ftp;\n    salitem_T\t*smp;\n    int\t\ti;\n    int\t\tround;\n\n    VIM_CLEAR(lp->sl_fbyts);\n    VIM_CLEAR(lp->sl_kbyts);\n    VIM_CLEAR(lp->sl_pbyts);\n\n    VIM_CLEAR(lp->sl_fidxs);\n    VIM_CLEAR(lp->sl_kidxs);\n    VIM_CLEAR(lp->sl_pidxs);\n\n    for (round = 1; round <= 2; ++round)\n    {\n\tgap = round == 1 ? &lp->sl_rep : &lp->sl_repsal;\n\twhile (gap->ga_len > 0)\n\t{\n\t    ftp = &((fromto_T *)gap->ga_data)[--gap->ga_len];\n\t    vim_free(ftp->ft_from);\n\t    vim_free(ftp->ft_to);\n\t}\n\tga_clear(gap);\n    }\n\n    gap = &lp->sl_sal;\n    if (lp->sl_sofo)\n    {\n\t// \"ga_len\" is set to 1 without adding an item for latin1\n\tif (gap->ga_data != NULL)\n\t    // SOFOFROM and SOFOTO items: free lists of wide characters.\n\t    for (i = 0; i < gap->ga_len; ++i)\n\t\tvim_free(((int **)gap->ga_data)[i]);\n    }\n    else\n\t// SAL items: free salitem_T items\n\twhile (gap->ga_len > 0)\n\t{\n\t    smp = &((salitem_T *)gap->ga_data)[--gap->ga_len];\n\t    vim_free(smp->sm_lead);\n\t    // Don't free sm_oneof and sm_rules, they point into sm_lead.\n\t    vim_free(smp->sm_to);\n\t    vim_free(smp->sm_lead_w);\n\t    vim_free(smp->sm_oneof_w);\n\t    vim_free(smp->sm_to_w);\n\t}\n    ga_clear(gap);\n\n    for (i = 0; i < lp->sl_prefixcnt; ++i)\n\tvim_regfree(lp->sl_prefprog[i]);\n    lp->sl_prefixcnt = 0;\n    VIM_CLEAR(lp->sl_prefprog);\n\n    VIM_CLEAR(lp->sl_info);\n\n    VIM_CLEAR(lp->sl_midword);\n\n    vim_regfree(lp->sl_compprog);\n    lp->sl_compprog = NULL;\n    VIM_CLEAR(lp->sl_comprules);\n    VIM_CLEAR(lp->sl_compstartflags);\n    VIM_CLEAR(lp->sl_compallflags);\n\n    VIM_CLEAR(lp->sl_syllable);\n    ga_clear(&lp->sl_syl_items);\n\n    ga_clear_strings(&lp->sl_comppat);\n\n    hash_clear_all(&lp->sl_wordcount, WC_KEY_OFF);\n    hash_init(&lp->sl_wordcount);\n\n    hash_clear_all(&lp->sl_map_hash, 0);\n\n    // Clear info from .sug file.\n    slang_clear_sug(lp);\n\n    lp->sl_compmax = MAXWLEN;\n    lp->sl_compminlen = 0;\n    lp->sl_compsylmax = MAXWLEN;\n    lp->sl_regions[0] = NUL;\n}\n\n/*\n * Clear the info from the .sug file in \"lp\".\n */\n    void\nslang_clear_sug(slang_T *lp)\n{\n    VIM_CLEAR(lp->sl_sbyts);\n    VIM_CLEAR(lp->sl_sidxs);\n    close_spellbuf(lp->sl_sugbuf);\n    lp->sl_sugbuf = NULL;\n    lp->sl_sugloaded = FALSE;\n    lp->sl_sugtime = 0;\n}\n\n/*\n * Load one spell file and store the info into a slang_T.\n * Invoked through do_in_runtimepath().\n */\n    static void\nspell_load_cb(char_u *fname, void *cookie)\n{\n    spelload_T\t*slp = (spelload_T *)cookie;\n    slang_T\t*slang;\n\n    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);\n    if (slang != NULL)\n    {\n\t// When a previously loaded file has NOBREAK also use it for the\n\t// \".add\" files.\n\tif (slp->sl_nobreak && slang->sl_add)\n\t    slang->sl_nobreak = TRUE;\n\telse if (slang->sl_nobreak)\n\t    slp->sl_nobreak = TRUE;\n\n\tslp->sl_slang = slang;\n    }\n}\n\n\n/*\n * Add a word to the hashtable of common words.\n * If it's already there then the counter is increased.\n */\n    void\ncount_common_word(\n    slang_T\t*lp,\n    char_u\t*word,\n    int\t\tlen,\t    // word length, -1 for up to NUL\n    int\t\tcount)\t    // 1 to count once, 10 to init\n{\n    hash_T\thash;\n    hashitem_T\t*hi;\n    wordcount_T\t*wc;\n    char_u\tbuf[MAXWLEN];\n    char_u\t*p;\n\n    if (len == -1)\n\tp = word;\n    else if (len >= MAXWLEN)\n\treturn;\n    else\n    {\n\tvim_strncpy(buf, word, len);\n\tp = buf;\n    }\n\n    hash = hash_hash(p);\n    hi = hash_lookup(&lp->sl_wordcount, p, hash);\n    if (HASHITEM_EMPTY(hi))\n    {\n\twc = alloc(sizeof(wordcount_T) + STRLEN(p));\n\tif (wc == NULL)\n\t    return;\n\tSTRCPY(wc->wc_word, p);\n\twc->wc_count = count;\n\thash_add_item(&lp->sl_wordcount, hi, wc->wc_word, hash);\n    }\n    else\n    {\n\twc = HI2WC(hi);\n\tif ((wc->wc_count += count) < (unsigned)count)\t// check for overflow\n\t    wc->wc_count = MAXWORDCOUNT;\n    }\n}\n\n/*\n * Return TRUE if byte \"n\" appears in \"str\".\n * Like strchr() but independent of locale.\n */\n    int\nbyte_in_str(char_u *str, int n)\n{\n    char_u\t*p;\n\n    for (p = str; *p != NUL; ++p)\n\tif (*p == n)\n\t    return TRUE;\n    return FALSE;\n}\n\n#define SY_MAXLEN   30\ntypedef struct syl_item_S\n{\n    char_u\tsy_chars[SY_MAXLEN];\t    // the sequence of chars\n    int\t\tsy_len;\n} syl_item_T;\n\n/*\n * Truncate \"slang->sl_syllable\" at the first slash and put the following items\n * in \"slang->sl_syl_items\".\n */\n    int\ninit_syl_tab(slang_T *slang)\n{\n    char_u\t*p;\n    char_u\t*s;\n    int\t\tl;\n    syl_item_T\t*syl;\n\n    ga_init2(&slang->sl_syl_items, sizeof(syl_item_T), 4);\n    p = vim_strchr(slang->sl_syllable, '/');\n    while (p != NULL)\n    {\n\t*p++ = NUL;\n\tif (*p == NUL)\t    // trailing slash\n\t    break;\n\ts = p;\n\tp = vim_strchr(p, '/');\n\tif (p == NULL)\n\t    l = (int)STRLEN(s);\n\telse\n\t    l = (int)(p - s);\n\tif (l >= SY_MAXLEN)\n\t    return SP_FORMERROR;\n\tif (ga_grow(&slang->sl_syl_items, 1) == FAIL)\n\t    return SP_OTHERERROR;\n\tsyl = ((syl_item_T *)slang->sl_syl_items.ga_data)\n\t\t\t\t\t       + slang->sl_syl_items.ga_len++;\n\tvim_strncpy(syl->sy_chars, s, l);\n\tsyl->sy_len = l;\n    }\n    return OK;\n}\n\n/*\n * Count the number of syllables in \"word\".\n * When \"word\" contains spaces the syllables after the last space are counted.\n * Returns zero if syllables are not defines.\n */\n    static int\ncount_syllables(slang_T *slang, char_u *word)\n{\n    int\t\tcnt = 0;\n    int\t\tskip = FALSE;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\ti;\n    syl_item_T\t*syl;\n    int\t\tc;\n\n    if (slang->sl_syllable == NULL)\n\treturn 0;\n\n    for (p = word; *p != NUL; p += len)\n    {\n\t// When running into a space reset counter.\n\tif (*p == ' ')\n\t{\n\t    len = 1;\n\t    cnt = 0;\n\t    continue;\n\t}\n\n\t// Find longest match of syllable items.\n\tlen = 0;\n\tfor (i = 0; i < slang->sl_syl_items.ga_len; ++i)\n\t{\n\t    syl = ((syl_item_T *)slang->sl_syl_items.ga_data) + i;\n\t    if (syl->sy_len > len\n\t\t\t       && STRNCMP(p, syl->sy_chars, syl->sy_len) == 0)\n\t\tlen = syl->sy_len;\n\t}\n\tif (len != 0)\t// found a match, count syllable\n\t{\n\t    ++cnt;\n\t    skip = FALSE;\n\t}\n\telse\n\t{\n\t    // No recognized syllable item, at least a syllable char then?\n\t    c = mb_ptr2char(p);\n\t    len = (*mb_ptr2len)(p);\n\t    if (vim_strchr(slang->sl_syllable, c) == NULL)\n\t\tskip = FALSE;\t    // No, search for next syllable\n\t    else if (!skip)\n\t    {\n\t\t++cnt;\t\t    // Yes, count it\n\t\tskip = TRUE;\t    // don't count following syllable chars\n\t    }\n\t}\n    }\n    return cnt;\n}\n\n/*\n * Parse 'spelllang' and set w_s->b_langp accordingly.\n * Returns NULL if it's OK, an untranslated error message otherwise.\n */\n    char *\ndid_set_spelllang(win_T *wp)\n{\n    garray_T\tga;\n    char_u\t*splp;\n    char_u\t*region;\n    char_u\tregion_cp[3];\n    int\t\tfilename;\n    int\t\tregion_mask;\n    slang_T\t*slang;\n    int\t\tc;\n    char_u\tlang[MAXWLEN + 1];\n    char_u\tspf_name[MAXPATHL];\n    int\t\tlen;\n    char_u\t*p;\n    int\t\tround;\n    char_u\t*spf;\n    char_u\t*use_region = NULL;\n    int\t\tdont_use_region = FALSE;\n    int\t\tnobreak = FALSE;\n    int\t\ti, j;\n    langp_T\t*lp, *lp2;\n    static int\trecursive = FALSE;\n    char\t*ret_msg = NULL;\n    char_u\t*spl_copy;\n    bufref_T\tbufref;\n\n    set_bufref(&bufref, wp->w_buffer);\n\n    // We don't want to do this recursively.  May happen when a language is\n    // not available and the SpellFileMissing autocommand opens a new buffer\n    // in which 'spell' is set.\n    if (recursive)\n\treturn NULL;\n    recursive = TRUE;\n\n    ga_init2(&ga, sizeof(langp_T), 2);\n    clear_midword(wp);\n\n    // Make a copy of 'spelllang', the SpellFileMissing autocommands may change\n    // it under our fingers.\n    spl_copy = vim_strsave(wp->w_s->b_p_spl);\n    if (spl_copy == NULL)\n\tgoto theend;\n\n    wp->w_s->b_cjk = 0;\n\n    // Loop over comma separated language names.\n    for (splp = spl_copy; *splp != NUL; )\n    {\n\t// Get one language name.\n\tcopy_option_part(&splp, lang, MAXWLEN, \",\");\n\tregion = NULL;\n\tlen = (int)STRLEN(lang);\n\n\tif (!valid_spelllang(lang))\n\t    continue;\n\n\tif (STRCMP(lang, \"cjk\") == 0)\n\t{\n\t    wp->w_s->b_cjk = 1;\n\t    continue;\n\t}\n\n\t// If the name ends in \".spl\" use it as the name of the spell file.\n\t// If there is a region name let \"region\" point to it and remove it\n\t// from the name.\n\tif (len > 4 && fnamecmp(lang + len - 4, \".spl\") == 0)\n\t{\n\t    filename = TRUE;\n\n\t    // Locate a region and remove it from the file name.\n\t    p = vim_strchr(gettail(lang), '_');\n\t    if (p != NULL && ASCII_ISALPHA(p[1]) && ASCII_ISALPHA(p[2])\n\t\t\t\t\t\t      && !ASCII_ISALPHA(p[3]))\n\t    {\n\t\tvim_strncpy(region_cp, p + 1, 2);\n\t\tmch_memmove(p, p + 3, len - (p - lang) - 2);\n\t\tregion = region_cp;\n\t    }\n\t    else\n\t\tdont_use_region = TRUE;\n\n\t    // Check if we loaded this language before.\n\t    FOR_ALL_SPELL_LANGS(slang)\n\t\tif (fullpathcmp(lang, slang->sl_fname, FALSE, TRUE) == FPC_SAME)\n\t\t    break;\n\t}\n\telse\n\t{\n\t    filename = FALSE;\n\t    if (len > 3 && lang[len - 3] == '_')\n\t    {\n\t\tregion = lang + len - 2;\n\t\tlen -= 3;\n\t\tlang[len] = NUL;\n\t    }\n\t    else\n\t\tdont_use_region = TRUE;\n\n\t    // Check if we loaded this language before.\n\t    FOR_ALL_SPELL_LANGS(slang)\n\t\tif (STRICMP(lang, slang->sl_name) == 0)\n\t\t    break;\n\t}\n\n\tif (region != NULL)\n\t{\n\t    // If the region differs from what was used before then don't\n\t    // use it for 'spellfile'.\n\t    if (use_region != NULL && STRCMP(region, use_region) != 0)\n\t\tdont_use_region = TRUE;\n\t    use_region = region;\n\t}\n\n\t// If not found try loading the language now.\n\tif (slang == NULL)\n\t{\n\t    if (filename)\n\t\t(void)spell_load_file(lang, lang, NULL, FALSE);\n\t    else\n\t    {\n\t\tspell_load_lang(lang);\n\t\t// SpellFileMissing autocommands may do anything, including\n\t\t// destroying the buffer we are using...\n\t\tif (!bufref_valid(&bufref))\n\t\t{\n\t\t    ret_msg = N_(e_spellfilemising_autocommand_deleted_buffer);\n\t\t    goto theend;\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * Loop over the languages, there can be several files for \"lang\".\n\t */\n\tFOR_ALL_SPELL_LANGS(slang)\n\t    if (filename ? fullpathcmp(lang, slang->sl_fname, FALSE, TRUE)\n\t\t\t\t\t\t\t\t    == FPC_SAME\n\t\t\t : STRICMP(lang, slang->sl_name) == 0)\n\t    {\n\t\tregion_mask = REGION_ALL;\n\t\tif (!filename && region != NULL)\n\t\t{\n\t\t    // find region in sl_regions\n\t\t    c = find_region(slang->sl_regions, region);\n\t\t    if (c == REGION_ALL)\n\t\t    {\n\t\t\tif (slang->sl_add)\n\t\t\t{\n\t\t\t    if (*slang->sl_regions != NUL)\n\t\t\t\t// This addition file is for other regions.\n\t\t\t\tregion_mask = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t    // This is probably an error.  Give a warning and\n\t\t\t    // accept the words anyway.\n\t\t\t    smsg(_(\"Warning: region %s not supported\"),\n\t\t\t\t\t\t\t\t      region);\n\t\t    }\n\t\t    else\n\t\t\tregion_mask = 1 << c;\n\t\t}\n\n\t\tif (region_mask != 0)\n\t\t{\n\t\t    if (ga_grow(&ga, 1) == FAIL)\n\t\t    {\n\t\t\tga_clear(&ga);\n\t\t\tret_msg = e_out_of_memory;\n\t\t\tgoto theend;\n\t\t    }\n\t\t    LANGP_ENTRY(ga, ga.ga_len)->lp_slang = slang;\n\t\t    LANGP_ENTRY(ga, ga.ga_len)->lp_region = region_mask;\n\t\t    ++ga.ga_len;\n\t\t    use_midword(slang, wp);\n\t\t    if (slang->sl_nobreak)\n\t\t\tnobreak = TRUE;\n\t\t}\n\t    }\n    }\n\n    // round 0: load int_wordlist, if possible.\n    // round 1: load first name in 'spellfile'.\n    // round 2: load second name in 'spellfile.\n    // etc.\n    spf = curwin->w_s->b_p_spf;\n    for (round = 0; round == 0 || *spf != NUL; ++round)\n    {\n\tif (round == 0)\n\t{\n\t    // Internal wordlist, if there is one.\n\t    if (int_wordlist == NULL)\n\t\tcontinue;\n\t    int_wordlist_spl(spf_name);\n\t}\n\telse\n\t{\n\t    // One entry in 'spellfile'.\n\t    copy_option_part(&spf, spf_name, MAXPATHL - 5, \",\");\n\t    STRCAT(spf_name, \".spl\");\n\n\t    // If it was already found above then skip it.\n\t    for (c = 0; c < ga.ga_len; ++c)\n\t    {\n\t\tp = LANGP_ENTRY(ga, c)->lp_slang->sl_fname;\n\t\tif (p != NULL && fullpathcmp(spf_name, p, FALSE, TRUE)\n\t\t\t\t\t\t\t\t== FPC_SAME)\n\t\t    break;\n\t    }\n\t    if (c < ga.ga_len)\n\t\tcontinue;\n\t}\n\n\t// Check if it was loaded already.\n\tFOR_ALL_SPELL_LANGS(slang)\n\t    if (fullpathcmp(spf_name, slang->sl_fname, FALSE, TRUE)\n\t\t\t\t\t\t\t\t== FPC_SAME)\n\t\tbreak;\n\tif (slang == NULL)\n\t{\n\t    // Not loaded, try loading it now.  The language name includes the\n\t    // region name, the region is ignored otherwise.  for int_wordlist\n\t    // use an arbitrary name.\n\t    if (round == 0)\n\t\tSTRCPY(lang, \"internal wordlist\");\n\t    else\n\t    {\n\t\tvim_strncpy(lang, gettail(spf_name), MAXWLEN);\n\t\tp = vim_strchr(lang, '.');\n\t\tif (p != NULL)\n\t\t    *p = NUL;\t// truncate at \".encoding.add\"\n\t    }\n\t    slang = spell_load_file(spf_name, lang, NULL, TRUE);\n\n\t    // If one of the languages has NOBREAK we assume the addition\n\t    // files also have this.\n\t    if (slang != NULL && nobreak)\n\t\tslang->sl_nobreak = TRUE;\n\t}\n\tif (slang != NULL && ga_grow(&ga, 1) == OK)\n\t{\n\t    region_mask = REGION_ALL;\n\t    if (use_region != NULL && !dont_use_region)\n\t    {\n\t\t// find region in sl_regions\n\t\tc = find_region(slang->sl_regions, use_region);\n\t\tif (c != REGION_ALL)\n\t\t    region_mask = 1 << c;\n\t\telse if (*slang->sl_regions != NUL)\n\t\t    // This spell file is for other regions.\n\t\t    region_mask = 0;\n\t    }\n\n\t    if (region_mask != 0)\n\t    {\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_slang = slang;\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_sallang = NULL;\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_replang = NULL;\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_region = region_mask;\n\t\t++ga.ga_len;\n\t\tuse_midword(slang, wp);\n\t    }\n\t}\n    }\n\n    // Everything is fine, store the new b_langp value.\n    ga_clear(&wp->w_s->b_langp);\n    wp->w_s->b_langp = ga;\n\n    // For each language figure out what language to use for sound folding and\n    // REP items.  If the language doesn't support it itself use another one\n    // with the same name.  E.g. for \"en-math\" use \"en\".\n    for (i = 0; i < ga.ga_len; ++i)\n    {\n\tlp = LANGP_ENTRY(ga, i);\n\n\t// sound folding\n\tif (lp->lp_slang->sl_sal.ga_len > 0)\n\t    // language does sound folding itself\n\t    lp->lp_sallang = lp->lp_slang;\n\telse\n\t    // find first similar language that does sound folding\n\t    for (j = 0; j < ga.ga_len; ++j)\n\t    {\n\t\tlp2 = LANGP_ENTRY(ga, j);\n\t\tif (lp2->lp_slang->sl_sal.ga_len > 0\n\t\t\t&& STRNCMP(lp->lp_slang->sl_name,\n\t\t\t\t\t      lp2->lp_slang->sl_name, 2) == 0)\n\t\t{\n\t\t    lp->lp_sallang = lp2->lp_slang;\n\t\t    break;\n\t\t}\n\t    }\n\n\t// REP items\n\tif (lp->lp_slang->sl_rep.ga_len > 0)\n\t    // language has REP items itself\n\t    lp->lp_replang = lp->lp_slang;\n\telse\n\t    // find first similar language that has REP items\n\t    for (j = 0; j < ga.ga_len; ++j)\n\t    {\n\t\tlp2 = LANGP_ENTRY(ga, j);\n\t\tif (lp2->lp_slang->sl_rep.ga_len > 0\n\t\t\t&& STRNCMP(lp->lp_slang->sl_name,\n\t\t\t\t\t      lp2->lp_slang->sl_name, 2) == 0)\n\t\t{\n\t\t    lp->lp_replang = lp2->lp_slang;\n\t\t    break;\n\t\t}\n\t    }\n    }\n    redraw_win_later(wp, NOT_VALID);\n\ntheend:\n    vim_free(spl_copy);\n    recursive = FALSE;\n    return ret_msg;\n}\n\n/*\n * Clear the midword characters for buffer \"buf\".\n */\n    static void\nclear_midword(win_T *wp)\n{\n    CLEAR_FIELD(wp->w_s->b_spell_ismw);\n    VIM_CLEAR(wp->w_s->b_spell_ismw_mb);\n}\n\n/*\n * Use the \"sl_midword\" field of language \"lp\" for buffer \"buf\".\n * They add up to any currently used midword characters.\n */\n    static void\nuse_midword(slang_T *lp, win_T *wp)\n{\n    char_u\t*p;\n\n    if (lp->sl_midword == NULL)\t    // there aren't any\n\treturn;\n\n    for (p = lp->sl_midword; *p != NUL; )\n\tif (has_mbyte)\n\t{\n\t    int\t    c, l, n;\n\t    char_u  *bp;\n\n\t    c = mb_ptr2char(p);\n\t    l = (*mb_ptr2len)(p);\n\t    if (c < 256 && l <= 2)\n\t\twp->w_s->b_spell_ismw[c] = TRUE;\n\t    else if (wp->w_s->b_spell_ismw_mb == NULL)\n\t\t// First multi-byte char in \"b_spell_ismw_mb\".\n\t\twp->w_s->b_spell_ismw_mb = vim_strnsave(p, l);\n\t    else\n\t    {\n\t\t// Append multi-byte chars to \"b_spell_ismw_mb\".\n\t\tn = (int)STRLEN(wp->w_s->b_spell_ismw_mb);\n\t\tbp = vim_strnsave(wp->w_s->b_spell_ismw_mb, n + l);\n\t\tif (bp != NULL)\n\t\t{\n\t\t    vim_free(wp->w_s->b_spell_ismw_mb);\n\t\t    wp->w_s->b_spell_ismw_mb = bp;\n\t\t    vim_strncpy(bp + n, p, l);\n\t\t}\n\t    }\n\t    p += l;\n\t}\n\telse\n\t    wp->w_s->b_spell_ismw[*p++] = TRUE;\n}\n\n/*\n * Find the region \"region[2]\" in \"rp\" (points to \"sl_regions\").\n * Each region is simply stored as the two characters of its name.\n * Returns the index if found (first is 0), REGION_ALL if not found.\n */\n    static int\nfind_region(char_u *rp, char_u *region)\n{\n    int\t\ti;\n\n    for (i = 0; ; i += 2)\n    {\n\tif (rp[i] == NUL)\n\t    return REGION_ALL;\n\tif (rp[i] == region[0] && rp[i + 1] == region[1])\n\t    break;\n    }\n    return i / 2;\n}\n\n/*\n * Return case type of word:\n * w word\t0\n * Word\t\tWF_ONECAP\n * W WORD\tWF_ALLCAP\n * WoRd\twOrd\tWF_KEEPCAP\n */\n    int\ncaptype(\n    char_u\t*word,\n    char_u\t*end)\t    // When NULL use up to NUL byte.\n{\n    char_u\t*p;\n    int\t\tc;\n    int\t\tfirstcap;\n    int\t\tallcap;\n    int\t\tpast_second = FALSE;\t// past second word char\n\n    // find first letter\n    for (p = word; !spell_iswordp_nmw(p, curwin); MB_PTR_ADV(p))\n\tif (end == NULL ? *p == NUL : p >= end)\n\t    return 0;\t    // only non-word characters, illegal word\n    if (has_mbyte)\n\tc = mb_ptr2char_adv(&p);\n    else\n\tc = *p++;\n    firstcap = allcap = SPELL_ISUPPER(c);\n\n    /*\n     * Need to check all letters to find a word with mixed upper/lower.\n     * But a word with an upper char only at start is a ONECAP.\n     */\n    for ( ; end == NULL ? *p != NUL : p < end; MB_PTR_ADV(p))\n\tif (spell_iswordp_nmw(p, curwin))\n\t{\n\t    c = PTR2CHAR(p);\n\t    if (!SPELL_ISUPPER(c))\n\t    {\n\t\t// UUl -> KEEPCAP\n\t\tif (past_second && allcap)\n\t\t    return WF_KEEPCAP;\n\t\tallcap = FALSE;\n\t    }\n\t    else if (!allcap)\n\t\t// UlU -> KEEPCAP\n\t\treturn WF_KEEPCAP;\n\t    past_second = TRUE;\n\t}\n\n    if (allcap)\n\treturn WF_ALLCAP;\n    if (firstcap)\n\treturn WF_ONECAP;\n    return 0;\n}\n\n/*\n * Delete the internal wordlist and its .spl file.\n */\n    void\nspell_delete_wordlist(void)\n{\n    char_u\tfname[MAXPATHL];\n\n    if (int_wordlist != NULL)\n    {\n\tmch_remove(int_wordlist);\n\tint_wordlist_spl(fname);\n\tmch_remove(fname);\n\tVIM_CLEAR(int_wordlist);\n    }\n}\n\n/*\n * Free all languages.\n */\n    void\nspell_free_all(void)\n{\n    slang_T\t*slang;\n    buf_T\t*buf;\n\n    // Go through all buffers and handle 'spelllang'. <VN>\n    FOR_ALL_BUFFERS(buf)\n\tga_clear(&buf->b_s.b_langp);\n\n    while (first_lang != NULL)\n    {\n\tslang = first_lang;\n\tfirst_lang = slang->sl_next;\n\tslang_free(slang);\n    }\n\n    spell_delete_wordlist();\n\n    VIM_CLEAR(repl_to);\n    VIM_CLEAR(repl_from);\n}\n\n/*\n * Clear all spelling tables and reload them.\n * Used after 'encoding' is set and when \":mkspell\" was used.\n */\n    void\nspell_reload(void)\n{\n    win_T\t*wp;\n\n    // Initialize the table for spell_iswordp().\n    init_spell_chartab();\n\n    // Unload all allocated memory.\n    spell_free_all();\n\n    // Go through all buffers and handle 'spelllang'.\n    FOR_ALL_WINDOWS(wp)\n    {\n\t// Only load the wordlists when 'spelllang' is set and there is a\n\t// window for this buffer in which 'spell' is set.\n\tif (*wp->w_s->b_p_spl != NUL)\n\t{\n\t\tif (wp->w_p_spell)\n\t\t{\n\t\t    (void)did_set_spelllang(wp);\n\t\t    break;\n\t\t}\n\t}\n    }\n}\n\n/*\n * Open a spell buffer.  This is a nameless buffer that is not in the buffer\n * list and only contains text lines.  Can use a swapfile to reduce memory\n * use.\n * Most other fields are invalid!  Esp. watch out for string options being\n * NULL and there is no undo info.\n * Returns NULL when out of memory.\n */\n    buf_T *\nopen_spellbuf(void)\n{\n    buf_T\t*buf;\n\n    buf = ALLOC_CLEAR_ONE(buf_T);\n    if (buf != NULL)\n    {\n\tbuf->b_spell = TRUE;\n\tbuf->b_p_swf = TRUE;\t// may create a swap file\n#ifdef FEAT_CRYPT\n\tbuf->b_p_key = empty_option;\n#endif\n\tml_open(buf);\n\tml_open_file(buf);\t// create swap file now\n    }\n    return buf;\n}\n\n/*\n * Close the buffer used for spell info.\n */\n    void\nclose_spellbuf(buf_T *buf)\n{\n    if (buf != NULL)\n    {\n\tml_close(buf, TRUE);\n\tvim_free(buf);\n    }\n}\n\n/*\n * Init the chartab used for spelling for ASCII.\n */\n    void\nclear_spell_chartab(spelltab_T *sp)\n{\n    int\t\ti;\n\n    // Init everything to FALSE (zero).\n    CLEAR_FIELD(sp->st_isw);\n    CLEAR_FIELD(sp->st_isu);\n    for (i = 0; i < 256; ++i)\n    {\n\tsp->st_fold[i] = i;\n\tsp->st_upper[i] = i;\n    }\n\n    // We include digits.  A word shouldn't start with a digit, but handling\n    // that is done separately.\n    for (i = '0'; i <= '9'; ++i)\n\tsp->st_isw[i] = TRUE;\n    for (i = 'A'; i <= 'Z'; ++i)\n    {\n\tsp->st_isw[i] = TRUE;\n\tsp->st_isu[i] = TRUE;\n\tsp->st_fold[i] = i + 0x20;\n    }\n    for (i = 'a'; i <= 'z'; ++i)\n    {\n\tsp->st_isw[i] = TRUE;\n\tsp->st_upper[i] = i - 0x20;\n    }\n}\n\n/*\n * Init the chartab used for spelling.  Only depends on 'encoding'.\n * Called once while starting up and when 'encoding' changes.\n * The default is to use isalpha(), but the spell file should define the word\n * characters to make it possible that 'encoding' differs from the current\n * locale.  For utf-8 we don't use isalpha() but our own functions.\n */\n    void\ninit_spell_chartab(void)\n{\n    int\t    i;\n\n    did_set_spelltab = FALSE;\n    clear_spell_chartab(&spelltab);\n    if (enc_dbcs)\n    {\n\t// DBCS: assume double-wide characters are word characters.\n\tfor (i = 128; i <= 255; ++i)\n\t    if (MB_BYTE2LEN(i) == 2)\n\t\tspelltab.st_isw[i] = TRUE;\n    }\n    else if (enc_utf8)\n    {\n\tfor (i = 128; i < 256; ++i)\n\t{\n\t    int f = utf_fold(i);\n\t    int u = utf_toupper(i);\n\n\t    spelltab.st_isu[i] = utf_isupper(i);\n\t    spelltab.st_isw[i] = spelltab.st_isu[i] || utf_islower(i);\n\t    // The folded/upper-cased value is different between latin1 and\n\t    // utf8 for 0xb5, causing E763 for no good reason.  Use the latin1\n\t    // value for utf-8 to avoid this.\n\t    spelltab.st_fold[i] = (f < 256) ? f : i;\n\t    spelltab.st_upper[i] = (u < 256) ? u : i;\n\t}\n    }\n    else\n    {\n\t// Rough guess: use locale-dependent library functions.\n\tfor (i = 128; i < 256; ++i)\n\t{\n\t    if (MB_ISUPPER(i))\n\t    {\n\t\tspelltab.st_isw[i] = TRUE;\n\t\tspelltab.st_isu[i] = TRUE;\n\t\tspelltab.st_fold[i] = MB_TOLOWER(i);\n\t    }\n\t    else if (MB_ISLOWER(i))\n\t    {\n\t\tspelltab.st_isw[i] = TRUE;\n\t\tspelltab.st_upper[i] = MB_TOUPPER(i);\n\t    }\n\t}\n    }\n}\n\n\n/*\n * Return TRUE if \"p\" points to a word character.\n * As a special case we see \"midword\" characters as word character when it is\n * followed by a word character.  This finds they'there but not 'they there'.\n * Thus this only works properly when past the first character of the word.\n */\n    int\nspell_iswordp(\n    char_u\t*p,\n    win_T\t*wp)\t    // buffer used\n{\n    char_u\t*s;\n    int\t\tl;\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tl = mb_ptr2len(p);\n\ts = p;\n\tif (l == 1)\n\t{\n\t    // be quick for ASCII\n\t    if (wp->w_s->b_spell_ismw[*p])\n\t\ts = p + 1;\t\t// skip a mid-word character\n\t}\n\telse\n\t{\n\t    c = mb_ptr2char(p);\n\t    if (c < 256 ? wp->w_s->b_spell_ismw[c]\n\t\t    : (wp->w_s->b_spell_ismw_mb != NULL\n\t\t\t   && vim_strchr(wp->w_s->b_spell_ismw_mb, c) != NULL))\n\t\ts = p + l;\n\t}\n\n\tc = mb_ptr2char(s);\n\tif (c > 255)\n\t    return spell_mb_isword_class(mb_get_class(s), wp);\n\treturn spelltab.st_isw[c];\n    }\n\n    return spelltab.st_isw[wp->w_s->b_spell_ismw[*p] ? p[1] : p[0]];\n}\n\n/*\n * Return TRUE if \"p\" points to a word character.\n * Unlike spell_iswordp() this doesn't check for \"midword\" characters.\n */\n    int\nspell_iswordp_nmw(char_u *p, win_T *wp)\n{\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tc = mb_ptr2char(p);\n\tif (c > 255)\n\t    return spell_mb_isword_class(mb_get_class(p), wp);\n\treturn spelltab.st_isw[c];\n    }\n    return spelltab.st_isw[*p];\n}\n\n/*\n * Return TRUE if word class indicates a word character.\n * Only for characters above 255.\n * Unicode subscript and superscript are not considered word characters.\n * See also dbcs_class() and utf_class() in mbyte.c.\n */\n    static int\nspell_mb_isword_class(int cl, win_T *wp)\n{\n    if (wp->w_s->b_cjk)\n\t// East Asian characters are not considered word characters.\n\treturn cl == 2 || cl == 0x2800;\n    return cl >= 2 && cl != 0x2070 && cl != 0x2080 && cl != 3;\n}\n\n/*\n * Return TRUE if \"p\" points to a word character.\n * Wide version of spell_iswordp().\n */\n    static int\nspell_iswordp_w(int *p, win_T *wp)\n{\n    int\t\t*s;\n\n    if (*p < 256 ? wp->w_s->b_spell_ismw[*p]\n\t\t : (wp->w_s->b_spell_ismw_mb != NULL\n\t\t\t     && vim_strchr(wp->w_s->b_spell_ismw_mb, *p) != NULL))\n\ts = p + 1;\n    else\n\ts = p;\n\n    if (*s > 255)\n    {\n\tif (enc_utf8)\n\t    return spell_mb_isword_class(utf_class(*s), wp);\n\tif (enc_dbcs)\n\t    return spell_mb_isword_class(\n\t\t\t\tdbcs_class((unsigned)*s >> 8, *s & 0xff), wp);\n\treturn 0;\n    }\n    return spelltab.st_isw[*s];\n}\n\n/*\n * Case-fold \"str[len]\" into \"buf[buflen]\".  The result is NUL terminated.\n * Uses the character definitions from the .spl file.\n * When using a multi-byte 'encoding' the length may change!\n * Returns FAIL when something wrong.\n */\n    int\nspell_casefold(\n    win_T\t*wp,\n    char_u\t*str,\n    int\t\tlen,\n    char_u\t*buf,\n    int\t\tbuflen)\n{\n    int\t\ti;\n\n    if (len >= buflen)\n    {\n\tbuf[0] = NUL;\n\treturn FAIL;\t\t// result will not fit\n    }\n\n    if (has_mbyte)\n    {\n\tint\touti = 0;\n\tchar_u\t*p;\n\tint\tc;\n\n\t// Fold one character at a time.\n\tfor (p = str; p < str + len; )\n\t{\n\t    if (outi + MB_MAXBYTES > buflen)\n\t    {\n\t\tbuf[outi] = NUL;\n\t\treturn FAIL;\n\t    }\n\t    c = mb_cptr2char_adv(&p);\n\n\t    // Exception: greek capital sigma 0x03A3 folds to 0x03C3, except\n\t    // when it is the last character in a word, then it folds to\n\t    // 0x03C2.\n\t    if (c == 0x03a3 || c == 0x03c2)\n\t    {\n\t\tif (p == str + len || !spell_iswordp(p, wp))\n\t\t    c = 0x03c2;\n\t\telse\n\t\t    c = 0x03c3;\n\t    }\n\t    else\n\t\tc = SPELL_TOFOLD(c);\n\n\t    outi += mb_char2bytes(c, buf + outi);\n\t}\n\tbuf[outi] = NUL;\n    }\n    else\n    {\n\t// Be quick for non-multibyte encodings.\n\tfor (i = 0; i < len; ++i)\n\t    buf[i] = spelltab.st_fold[str[i]];\n\tbuf[i] = NUL;\n    }\n\n    return OK;\n}\n\n/*\n * Check if the word at line \"lnum\" column \"col\" is required to start with a\n * capital.  This uses 'spellcapcheck' of the current buffer.\n */\n    int\ncheck_need_cap(linenr_T lnum, colnr_T col)\n{\n    int\t\tneed_cap = FALSE;\n    char_u\t*line;\n    char_u\t*line_copy = NULL;\n    char_u\t*p;\n    colnr_T\tendcol;\n    regmatch_T\tregmatch;\n\n    if (curwin->w_s->b_cap_prog == NULL)\n\treturn FALSE;\n\n    line = ml_get_curline();\n    endcol = 0;\n    if (getwhitecols(line) >= (int)col)\n    {\n\t// At start of line, check if previous line is empty or sentence\n\t// ends there.\n\tif (lnum == 1)\n\t    need_cap = TRUE;\n\telse\n\t{\n\t    line = ml_get(lnum - 1);\n\t    if (*skipwhite(line) == NUL)\n\t\tneed_cap = TRUE;\n\t    else\n\t    {\n\t\t// Append a space in place of the line break.\n\t\tline_copy = concat_str(line, (char_u *)\" \");\n\t\tline = line_copy;\n\t\tendcol = (colnr_T)STRLEN(line);\n\t    }\n\t}\n    }\n    else\n\tendcol = col;\n\n    if (endcol > 0)\n    {\n\t// Check if sentence ends before the bad word.\n\tregmatch.regprog = curwin->w_s->b_cap_prog;\n\tregmatch.rm_ic = FALSE;\n\tp = line + endcol;\n\tfor (;;)\n\t{\n\t    MB_PTR_BACK(line, p);\n\t    if (p == line || spell_iswordp_nmw(p, curwin))\n\t\tbreak;\n\t    if (vim_regexec(&regmatch, p, 0)\n\t\t\t\t\t && regmatch.endp[0] == line + endcol)\n\t    {\n\t\tneed_cap = TRUE;\n\t\tbreak;\n\t    }\n\t}\n\tcurwin->w_s->b_cap_prog = regmatch.regprog;\n    }\n\n    vim_free(line_copy);\n\n    return need_cap;\n}\n\n\n/*\n * \":spellrepall\"\n */\n    void\nex_spellrepall(exarg_T *eap UNUSED)\n{\n    pos_T\tpos = curwin->w_cursor;\n    char_u\t*frompat;\n    int\t\taddlen;\n    char_u\t*line;\n    char_u\t*p;\n    int\t\tsave_ws = p_ws;\n    linenr_T\tprev_lnum = 0;\n\n    if (repl_from == NULL || repl_to == NULL)\n    {\n\temsg(_(e_no_previous_spell_replacement));\n\treturn;\n    }\n    addlen = (int)(STRLEN(repl_to) - STRLEN(repl_from));\n\n    frompat = alloc(STRLEN(repl_from) + 7);\n    if (frompat == NULL)\n\treturn;\n    sprintf((char *)frompat, \"\\\\V\\\\<%s\\\\>\", repl_from);\n    p_ws = FALSE;\n\n    sub_nsubs = 0;\n    sub_nlines = 0;\n    curwin->w_cursor.lnum = 0;\n    while (!got_int)\n    {\n\tif (do_search(NULL, '/', '/', frompat, 1L, SEARCH_KEEP, NULL) == 0\n\t\t\t\t\t\t   || u_save_cursor() == FAIL)\n\t    break;\n\n\t// Only replace when the right word isn't there yet.  This happens\n\t// when changing \"etc\" to \"etc.\".\n\tline = ml_get_curline();\n\tif (addlen <= 0 || STRNCMP(line + curwin->w_cursor.col,\n\t\t\t\t\t       repl_to, STRLEN(repl_to)) != 0)\n\t{\n\t    p = alloc(STRLEN(line) + addlen + 1);\n\t    if (p == NULL)\n\t\tbreak;\n\t    mch_memmove(p, line, curwin->w_cursor.col);\n\t    STRCPY(p + curwin->w_cursor.col, repl_to);\n\t    STRCAT(p, line + curwin->w_cursor.col + STRLEN(repl_from));\n\t    ml_replace(curwin->w_cursor.lnum, p, FALSE);\n\t    changed_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\t    if (curbuf->b_has_textprop && addlen != 0)\n\t\tadjust_prop_columns(curwin->w_cursor.lnum,\n\t\t\t\t curwin->w_cursor.col, addlen, APC_SUBSTITUTE);\n\n\t    if (curwin->w_cursor.lnum != prev_lnum)\n\t    {\n\t\t++sub_nlines;\n\t\tprev_lnum = curwin->w_cursor.lnum;\n\t    }\n\t    ++sub_nsubs;\n\t}\n\tcurwin->w_cursor.col += (colnr_T)STRLEN(repl_to);\n    }\n\n    p_ws = save_ws;\n    curwin->w_cursor = pos;\n    vim_free(frompat);\n\n    if (sub_nsubs == 0)\n\tsemsg(_(e_not_found_str), repl_from);\n    else\n\tdo_sub_msg(FALSE);\n}\n\n/*\n * Make a copy of \"word\", with the first letter upper or lower cased, to\n * \"wcopy[MAXWLEN]\".  \"word\" must not be empty.\n * The result is NUL terminated.\n */\n    void\nonecap_copy(\n    char_u\t*word,\n    char_u\t*wcopy,\n    int\t\tupper)\t    // TRUE: first letter made upper case\n{\n    char_u\t*p;\n    int\t\tc;\n    int\t\tl;\n\n    p = word;\n    if (has_mbyte)\n\tc = mb_cptr2char_adv(&p);\n    else\n\tc = *p++;\n    if (upper)\n\tc = SPELL_TOUPPER(c);\n    else\n\tc = SPELL_TOFOLD(c);\n    if (has_mbyte)\n\tl = mb_char2bytes(c, wcopy);\n    else\n    {\n\tl = 1;\n\twcopy[0] = c;\n    }\n    vim_strncpy(wcopy + l, p, MAXWLEN - l - 1);\n}\n\n/*\n * Make a copy of \"word\" with all the letters upper cased into\n * \"wcopy[MAXWLEN]\".  The result is NUL terminated.\n */\n    void\nallcap_copy(char_u *word, char_u *wcopy)\n{\n    char_u\t*s;\n    char_u\t*d;\n    int\t\tc;\n\n    d = wcopy;\n    for (s = word; *s != NUL; )\n    {\n\tif (has_mbyte)\n\t    c = mb_cptr2char_adv(&s);\n\telse\n\t    c = *s++;\n\n\t// We only change 0xdf to SS when we are certain latin1 is used.  It\n\t// would cause weird errors in other 8-bit encodings.\n\tif (enc_latin1like && c == 0xdf)\n\t{\n\t    c = 'S';\n\t    if (d - wcopy >= MAXWLEN - 1)\n\t\tbreak;\n\t    *d++ = c;\n\t}\n\telse\n\t    c = SPELL_TOUPPER(c);\n\n\tif (has_mbyte)\n\t{\n\t    if (d - wcopy >= MAXWLEN - MB_MAXBYTES)\n\t\tbreak;\n\t    d += mb_char2bytes(c, d);\n\t}\n\telse\n\t{\n\t    if (d - wcopy >= MAXWLEN - 1)\n\t\tbreak;\n\t    *d++ = c;\n\t}\n    }\n    *d = NUL;\n}\n\n/*\n * Case-folding may change the number of bytes: Count nr of chars in\n * fword[flen] and return the byte length of that many chars in \"word\".\n */\n    int\nnofold_len(char_u *fword, int flen, char_u *word)\n{\n    char_u\t*p;\n    int\t\ti = 0;\n\n    for (p = fword; p < fword + flen; MB_PTR_ADV(p))\n\t++i;\n    for (p = word; i > 0; MB_PTR_ADV(p))\n\t--i;\n    return (int)(p - word);\n}\n\n/*\n * Copy \"fword\" to \"cword\", fixing case according to \"flags\".\n */\n    void\nmake_case_word(char_u *fword, char_u *cword, int flags)\n{\n    if (flags & WF_ALLCAP)\n\t// Make it all upper-case\n\tallcap_copy(fword, cword);\n    else if (flags & WF_ONECAP)\n\t// Make the first letter upper-case\n\tonecap_copy(fword, cword, TRUE);\n    else\n\t// Use goodword as-is.\n\tSTRCPY(cword, fword);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Soundfold a string, for soundfold().\n * Result is in allocated memory, NULL for an error.\n */\n    char_u *\neval_soundfold(char_u *word)\n{\n    langp_T\t*lp;\n    char_u\tsound[MAXWLEN];\n    int\t\tlpi;\n\n    if (curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t// Use the sound-folding of the first language that supports it.\n\tfor (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n\t{\n\t    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\t    if (lp->lp_slang->sl_sal.ga_len > 0)\n\t    {\n\t\t// soundfold the word\n\t\tspell_soundfold(lp->lp_slang, word, FALSE, sound);\n\t\treturn vim_strsave(sound);\n\t    }\n\t}\n\n    // No language with sound folding, return word as-is.\n    return vim_strsave(word);\n}\n#endif\n\n/*\n * Turn \"inword\" into its sound-a-like equivalent in \"res[MAXWLEN]\".\n *\n * There are many ways to turn a word into a sound-a-like representation.  The\n * oldest is Soundex (1918!).   A nice overview can be found in \"Approximate\n * swedish name matching - survey and test of different algorithms\" by Klas\n * Erikson.\n *\n * We support two methods:\n * 1. SOFOFROM/SOFOTO do a simple character mapping.\n * 2. SAL items define a more advanced sound-folding (and much slower).\n */\n    void\nspell_soundfold(\n    slang_T\t*slang,\n    char_u\t*inword,\n    int\t\tfolded,\t    // \"inword\" is already case-folded\n    char_u\t*res)\n{\n    char_u\tfword[MAXWLEN];\n    char_u\t*word;\n\n    if (slang->sl_sofo)\n\t// SOFOFROM and SOFOTO used\n\tspell_soundfold_sofo(slang, inword, res);\n    else\n    {\n\t// SAL items used.  Requires the word to be case-folded.\n\tif (folded)\n\t    word = inword;\n\telse\n\t{\n\t    (void)spell_casefold(curwin,\n\t\t\t\t  inword, (int)STRLEN(inword), fword, MAXWLEN);\n\t    word = fword;\n\t}\n\n\tif (has_mbyte)\n\t    spell_soundfold_wsal(slang, word, res);\n\telse\n\t    spell_soundfold_sal(slang, word, res);\n    }\n}\n\n/*\n * Perform sound folding of \"inword\" into \"res\" according to SOFOFROM and\n * SOFOTO lines.\n */\n    static void\nspell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res)\n{\n    char_u\t*s;\n    int\t\tri = 0;\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tint\tprevc = 0;\n\tint\t*ip;\n\n\t// The sl_sal_first[] table contains the translation for chars up to\n\t// 255, sl_sal the rest.\n\tfor (s = inword; *s != NUL; )\n\t{\n\t    c = mb_cptr2char_adv(&s);\n\t    if (enc_utf8 ? utf_class(c) == 0 : VIM_ISWHITE(c))\n\t\tc = ' ';\n\t    else if (c < 256)\n\t\tc = slang->sl_sal_first[c];\n\t    else\n\t    {\n\t\tip = ((int **)slang->sl_sal.ga_data)[c & 0xff];\n\t\tif (ip == NULL)\t\t// empty list, can't match\n\t\t    c = NUL;\n\t\telse\n\t\t    for (;;)\t\t// find \"c\" in the list\n\t\t    {\n\t\t\tif (*ip == 0)\t// not found\n\t\t\t{\n\t\t\t    c = NUL;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (*ip == c)\t// match!\n\t\t\t{\n\t\t\t    c = ip[1];\n\t\t\t    break;\n\t\t\t}\n\t\t\tip += 2;\n\t\t    }\n\t    }\n\n\t    if (c != NUL && c != prevc)\n\t    {\n\t\tri += mb_char2bytes(c, res + ri);\n\t\tif (ri + MB_MAXBYTES > MAXWLEN)\n\t\t    break;\n\t\tprevc = c;\n\t    }\n\t}\n    }\n    else\n    {\n\t// The sl_sal_first[] table contains the translation.\n\tfor (s = inword; (c = *s) != NUL; ++s)\n\t{\n\t    if (VIM_ISWHITE(c))\n\t\tc = ' ';\n\t    else\n\t\tc = slang->sl_sal_first[c];\n\t    if (c != NUL && (ri == 0 || res[ri - 1] != c))\n\t\tres[ri++] = c;\n\t}\n    }\n\n    res[ri] = NUL;\n}\n\n    static void\nspell_soundfold_sal(slang_T *slang, char_u *inword, char_u *res)\n{\n    salitem_T\t*smp;\n    char_u\tword[MAXWLEN];\n    char_u\t*s = inword;\n    char_u\t*t;\n    char_u\t*pf;\n    int\t\ti, j, z;\n    int\t\treslen;\n    int\t\tn, k = 0;\n    int\t\tz0;\n    int\t\tk0;\n    int\t\tn0;\n    int\t\tc;\n    int\t\tpri;\n    int\t\tp0 = -333;\n    int\t\tc0;\n\n    // Remove accents, if wanted.  We actually remove all non-word characters.\n    // But keep white space.  We need a copy, the word may be changed here.\n    if (slang->sl_rem_accents)\n    {\n\tt = word;\n\twhile (*s != NUL)\n\t{\n\t    if (VIM_ISWHITE(*s))\n\t    {\n\t\t*t++ = ' ';\n\t\ts = skipwhite(s);\n\t    }\n\t    else\n\t    {\n\t\tif (spell_iswordp_nmw(s, curwin))\n\t\t    *t++ = *s;\n\t\t++s;\n\t    }\n\t}\n\t*t = NUL;\n    }\n    else\n\tvim_strncpy(word, s, MAXWLEN - 1);\n\n    smp = (salitem_T *)slang->sl_sal.ga_data;\n\n    /*\n     * This comes from Aspell phonet.cpp.  Converted from C++ to C.\n     * Changed to keep spaces.\n     */\n    i = reslen = z = 0;\n    while ((c = word[i]) != NUL)\n    {\n\t// Start with the first rule that has the character in the word.\n\tn = slang->sl_sal_first[c];\n\tz0 = 0;\n\n\tif (n >= 0)\n\t{\n\t    // check all rules for the same letter\n\t    for (; (s = smp[n].sm_lead)[0] == c; ++n)\n\t    {\n\t\t// Quickly skip entries that don't match the word.  Most\n\t\t// entries are less than three chars, optimize for that.\n\t\tk = smp[n].sm_leadlen;\n\t\tif (k > 1)\n\t\t{\n\t\t    if (word[i + 1] != s[1])\n\t\t\tcontinue;\n\t\t    if (k > 2)\n\t\t    {\n\t\t\tfor (j = 2; j < k; ++j)\n\t\t\t    if (word[i + j] != s[j])\n\t\t\t\tbreak;\n\t\t\tif (j < k)\n\t\t\t    continue;\n\t\t    }\n\t\t}\n\n\t\tif ((pf = smp[n].sm_oneof) != NULL)\n\t\t{\n\t\t    // Check for match with one of the chars in \"sm_oneof\".\n\t\t    while (*pf != NUL && *pf != word[i + k])\n\t\t\t++pf;\n\t\t    if (*pf == NUL)\n\t\t\tcontinue;\n\t\t    ++k;\n\t\t}\n\t\ts = smp[n].sm_rules;\n\t\tpri = 5;    // default priority\n\n\t\tp0 = *s;\n\t\tk0 = k;\n\t\twhile (*s == '-' && k > 1)\n\t\t{\n\t\t    k--;\n\t\t    s++;\n\t\t}\n\t\tif (*s == '<')\n\t\t    s++;\n\t\tif (VIM_ISDIGIT(*s))\n\t\t{\n\t\t    // determine priority\n\t\t    pri = *s - '0';\n\t\t    s++;\n\t\t}\n\t\tif (*s == '^' && *(s + 1) == '^')\n\t\t    s++;\n\n\t\tif (*s == NUL\n\t\t\t|| (*s == '^'\n\t\t\t    && (i == 0 || !(word[i - 1] == ' '\n\t\t\t\t      || spell_iswordp(word + i - 1, curwin)))\n\t\t\t    && (*(s + 1) != '$'\n\t\t\t\t|| (!spell_iswordp(word + i + k0, curwin))))\n\t\t\t|| (*s == '$' && i > 0\n\t\t\t    && spell_iswordp(word + i - 1, curwin)\n\t\t\t    && (!spell_iswordp(word + i + k0, curwin))))\n\t\t{\n\t\t    // search for followup rules, if:\n\t\t    // followup and k > 1  and  NO '-' in searchstring\n\t\t    c0 = word[i + k - 1];\n\t\t    n0 = slang->sl_sal_first[c0];\n\n\t\t    if (slang->sl_followup && k > 1 && n0 >= 0\n\t\t\t\t\t   && p0 != '-' && word[i + k] != NUL)\n\t\t    {\n\t\t\t// test follow-up rule for \"word[i + k]\"\n\t\t\tfor ( ; (s = smp[n0].sm_lead)[0] == c0; ++n0)\n\t\t\t{\n\t\t\t    // Quickly skip entries that don't match the word.\n\t\t\t    //\n\t\t\t    k0 = smp[n0].sm_leadlen;\n\t\t\t    if (k0 > 1)\n\t\t\t    {\n\t\t\t\tif (word[i + k] != s[1])\n\t\t\t\t    continue;\n\t\t\t\tif (k0 > 2)\n\t\t\t\t{\n\t\t\t\t    pf = word + i + k + 1;\n\t\t\t\t    for (j = 2; j < k0; ++j)\n\t\t\t\t\tif (*pf++ != s[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (j < k0)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    k0 += k - 1;\n\n\t\t\t    if ((pf = smp[n0].sm_oneof) != NULL)\n\t\t\t    {\n\t\t\t\t// Check for match with one of the chars in\n\t\t\t\t// \"sm_oneof\".\n\t\t\t\twhile (*pf != NUL && *pf != word[i + k0])\n\t\t\t\t    ++pf;\n\t\t\t\tif (*pf == NUL)\n\t\t\t\t    continue;\n\t\t\t\t++k0;\n\t\t\t    }\n\n\t\t\t    p0 = 5;\n\t\t\t    s = smp[n0].sm_rules;\n\t\t\t    while (*s == '-')\n\t\t\t    {\n\t\t\t\t// \"k0\" gets NOT reduced because\n\t\t\t\t// \"if (k0 == k)\"\n\t\t\t\ts++;\n\t\t\t    }\n\t\t\t    if (*s == '<')\n\t\t\t\ts++;\n\t\t\t    if (VIM_ISDIGIT(*s))\n\t\t\t    {\n\t\t\t\tp0 = *s - '0';\n\t\t\t\ts++;\n\t\t\t    }\n\n\t\t\t    if (*s == NUL\n\t\t\t\t    // *s == '^' cuts\n\t\t\t\t    || (*s == '$'\n\t\t\t\t\t    && !spell_iswordp(word + i + k0,\n\t\t\t\t\t\t\t\t     curwin)))\n\t\t\t    {\n\t\t\t\tif (k0 == k)\n\t\t\t\t    // this is just a piece of the string\n\t\t\t\t    continue;\n\n\t\t\t\tif (p0 < pri)\n\t\t\t\t    // priority too low\n\t\t\t\t    continue;\n\t\t\t\t// rule fits; stop search\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (p0 >= pri && smp[n0].sm_lead[0] == c0)\n\t\t\t    continue;\n\t\t    }\n\n\t\t    // replace string\n\t\t    s = smp[n].sm_to;\n\t\t    if (s == NULL)\n\t\t\ts = (char_u *)\"\";\n\t\t    pf = smp[n].sm_rules;\n\t\t    p0 = (vim_strchr(pf, '<') != NULL) ? 1 : 0;\n\t\t    if (p0 == 1 && z == 0)\n\t\t    {\n\t\t\t// rule with '<' is used\n\t\t\tif (reslen > 0 && *s != NUL && (res[reslen - 1] == c\n\t\t\t\t\t\t    || res[reslen - 1] == *s))\n\t\t\t    reslen--;\n\t\t\tz0 = 1;\n\t\t\tz = 1;\n\t\t\tk0 = 0;\n\t\t\twhile (*s != NUL && word[i + k0] != NUL)\n\t\t\t{\n\t\t\t    word[i + k0] = *s;\n\t\t\t    k0++;\n\t\t\t    s++;\n\t\t\t}\n\t\t\tif (k > k0)\n\t\t\t    STRMOVE(word + i + k0, word + i + k);\n\n\t\t\t// new \"actual letter\"\n\t\t\tc = word[i];\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// no '<' rule used\n\t\t\ti += k - 1;\n\t\t\tz = 0;\n\t\t\twhile (*s != NUL && s[1] != NUL && reslen < MAXWLEN)\n\t\t\t{\n\t\t\t    if (reslen == 0 || res[reslen - 1] != *s)\n\t\t\t\tres[reslen++] = *s;\n\t\t\t    s++;\n\t\t\t}\n\t\t\t// new \"actual letter\"\n\t\t\tc = *s;\n\t\t\tif (strstr((char *)pf, \"^^\") != NULL)\n\t\t\t{\n\t\t\t    if (c != NUL)\n\t\t\t\tres[reslen++] = c;\n\t\t\t    STRMOVE(word, word + i + 1);\n\t\t\t    i = 0;\n\t\t\t    z0 = 1;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse if (VIM_ISWHITE(c))\n\t{\n\t    c = ' ';\n\t    k = 1;\n\t}\n\n\tif (z0 == 0)\n\t{\n\t    if (k && !p0 && reslen < MAXWLEN && c != NUL\n\t\t    && (!slang->sl_collapse || reslen == 0\n\t\t\t\t\t\t     || res[reslen - 1] != c))\n\t\t// condense only double letters\n\t\tres[reslen++] = c;\n\n\t    i++;\n\t    z = 0;\n\t    k = 0;\n\t}\n    }\n\n    res[reslen] = NUL;\n}\n\n/*\n * Turn \"inword\" into its sound-a-like equivalent in \"res[MAXWLEN]\".\n * Multi-byte version of spell_soundfold().\n */\n    static void\nspell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res)\n{\n    salitem_T\t*smp = (salitem_T *)slang->sl_sal.ga_data;\n    int\t\tword[MAXWLEN];\n    int\t\twres[MAXWLEN];\n    int\t\tl;\n    char_u\t*s;\n    int\t\t*ws;\n    char_u\t*t;\n    int\t\t*pf;\n    int\t\ti, j, z;\n    int\t\treslen;\n    int\t\tn, k = 0;\n    int\t\tz0;\n    int\t\tk0;\n    int\t\tn0;\n    int\t\tc;\n    int\t\tpri;\n    int\t\tp0 = -333;\n    int\t\tc0;\n    int\t\tdid_white = FALSE;\n    int\t\twordlen;\n\n\n    /*\n     * Convert the multi-byte string to a wide-character string.\n     * Remove accents, if wanted.  We actually remove all non-word characters.\n     * But keep white space.\n     */\n    wordlen = 0;\n    for (s = inword; *s != NUL; )\n    {\n\tt = s;\n\tc = mb_cptr2char_adv(&s);\n\tif (slang->sl_rem_accents)\n\t{\n\t    if (enc_utf8 ? utf_class(c) == 0 : VIM_ISWHITE(c))\n\t    {\n\t\tif (did_white)\n\t\t    continue;\n\t\tc = ' ';\n\t\tdid_white = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tdid_white = FALSE;\n\t\tif (!spell_iswordp_nmw(t, curwin))\n\t\t    continue;\n\t    }\n\t}\n\tword[wordlen++] = c;\n    }\n    word[wordlen] = NUL;\n\n    /*\n     * This algorithm comes from Aspell phonet.cpp.\n     * Converted from C++ to C.  Added support for multi-byte chars.\n     * Changed to keep spaces.\n     */\n    i = reslen = z = 0;\n    while ((c = word[i]) != NUL)\n    {\n\t// Start with the first rule that has the character in the word.\n\tn = slang->sl_sal_first[c & 0xff];\n\tz0 = 0;\n\n\tif (n >= 0)\n\t{\n\t    // Check all rules for the same index byte.\n\t    // If c is 0x300 need extra check for the end of the array, as\n\t    // (c & 0xff) is NUL.\n\t    for (; ((ws = smp[n].sm_lead_w)[0] & 0xff) == (c & 0xff)\n\t\t\t\t\t\t\t && ws[0] != NUL; ++n)\n\t    {\n\t\t// Quickly skip entries that don't match the word.  Most\n\t\t// entries are less than three chars, optimize for that.\n\t\tif (c != ws[0])\n\t\t    continue;\n\t\tk = smp[n].sm_leadlen;\n\t\tif (k > 1)\n\t\t{\n\t\t    if (word[i + 1] != ws[1])\n\t\t\tcontinue;\n\t\t    if (k > 2)\n\t\t    {\n\t\t\tfor (j = 2; j < k; ++j)\n\t\t\t    if (word[i + j] != ws[j])\n\t\t\t\tbreak;\n\t\t\tif (j < k)\n\t\t\t    continue;\n\t\t    }\n\t\t}\n\n\t\tif ((pf = smp[n].sm_oneof_w) != NULL)\n\t\t{\n\t\t    // Check for match with one of the chars in \"sm_oneof\".\n\t\t    while (*pf != NUL && *pf != word[i + k])\n\t\t\t++pf;\n\t\t    if (*pf == NUL)\n\t\t\tcontinue;\n\t\t    ++k;\n\t\t}\n\t\ts = smp[n].sm_rules;\n\t\tpri = 5;    // default priority\n\n\t\tp0 = *s;\n\t\tk0 = k;\n\t\twhile (*s == '-' && k > 1)\n\t\t{\n\t\t    k--;\n\t\t    s++;\n\t\t}\n\t\tif (*s == '<')\n\t\t    s++;\n\t\tif (VIM_ISDIGIT(*s))\n\t\t{\n\t\t    // determine priority\n\t\t    pri = *s - '0';\n\t\t    s++;\n\t\t}\n\t\tif (*s == '^' && *(s + 1) == '^')\n\t\t    s++;\n\n\t\tif (*s == NUL\n\t\t\t|| (*s == '^'\n\t\t\t    && (i == 0 || !(word[i - 1] == ' '\n\t\t\t\t    || spell_iswordp_w(word + i - 1, curwin)))\n\t\t\t    && (*(s + 1) != '$'\n\t\t\t\t|| (!spell_iswordp_w(word + i + k0, curwin))))\n\t\t\t|| (*s == '$' && i > 0\n\t\t\t    && spell_iswordp_w(word + i - 1, curwin)\n\t\t\t    && (!spell_iswordp_w(word + i + k0, curwin))))\n\t\t{\n\t\t    // search for followup rules, if:\n\t\t    // followup and k > 1  and  NO '-' in searchstring\n\t\t    c0 = word[i + k - 1];\n\t\t    n0 = slang->sl_sal_first[c0 & 0xff];\n\n\t\t    if (slang->sl_followup && k > 1 && n0 >= 0\n\t\t\t\t\t   && p0 != '-' && word[i + k] != NUL)\n\t\t    {\n\t\t\t// Test follow-up rule for \"word[i + k]\"; loop over\n\t\t\t// all entries with the same index byte.\n\t\t\tfor ( ; ((ws = smp[n0].sm_lead_w)[0] & 0xff)\n\t\t\t\t\t\t\t == (c0 & 0xff); ++n0)\n\t\t\t{\n\t\t\t    // Quickly skip entries that don't match the word.\n\t\t\t    if (c0 != ws[0])\n\t\t\t\tcontinue;\n\t\t\t    k0 = smp[n0].sm_leadlen;\n\t\t\t    if (k0 > 1)\n\t\t\t    {\n\t\t\t\tif (word[i + k] != ws[1])\n\t\t\t\t    continue;\n\t\t\t\tif (k0 > 2)\n\t\t\t\t{\n\t\t\t\t    pf = word + i + k + 1;\n\t\t\t\t    for (j = 2; j < k0; ++j)\n\t\t\t\t\tif (*pf++ != ws[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (j < k0)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    k0 += k - 1;\n\n\t\t\t    if ((pf = smp[n0].sm_oneof_w) != NULL)\n\t\t\t    {\n\t\t\t\t// Check for match with one of the chars in\n\t\t\t\t// \"sm_oneof\".\n\t\t\t\twhile (*pf != NUL && *pf != word[i + k0])\n\t\t\t\t    ++pf;\n\t\t\t\tif (*pf == NUL)\n\t\t\t\t    continue;\n\t\t\t\t++k0;\n\t\t\t    }\n\n\t\t\t    p0 = 5;\n\t\t\t    s = smp[n0].sm_rules;\n\t\t\t    while (*s == '-')\n\t\t\t    {\n\t\t\t\t// \"k0\" gets NOT reduced because\n\t\t\t\t// \"if (k0 == k)\"\n\t\t\t\ts++;\n\t\t\t    }\n\t\t\t    if (*s == '<')\n\t\t\t\ts++;\n\t\t\t    if (VIM_ISDIGIT(*s))\n\t\t\t    {\n\t\t\t\tp0 = *s - '0';\n\t\t\t\ts++;\n\t\t\t    }\n\n\t\t\t    if (*s == NUL\n\t\t\t\t    // *s == '^' cuts\n\t\t\t\t    || (*s == '$'\n\t\t\t\t\t && !spell_iswordp_w(word + i + k0,\n\t\t\t\t\t\t\t\t     curwin)))\n\t\t\t    {\n\t\t\t\tif (k0 == k)\n\t\t\t\t    // this is just a piece of the string\n\t\t\t\t    continue;\n\n\t\t\t\tif (p0 < pri)\n\t\t\t\t    // priority too low\n\t\t\t\t    continue;\n\t\t\t\t// rule fits; stop search\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (p0 >= pri && (smp[n0].sm_lead_w[0] & 0xff)\n\t\t\t\t\t\t\t       == (c0 & 0xff))\n\t\t\t    continue;\n\t\t    }\n\n\t\t    // replace string\n\t\t    ws = smp[n].sm_to_w;\n\t\t    s = smp[n].sm_rules;\n\t\t    p0 = (vim_strchr(s, '<') != NULL) ? 1 : 0;\n\t\t    if (p0 == 1 && z == 0)\n\t\t    {\n\t\t\t// rule with '<' is used\n\t\t\tif (reslen > 0 && ws != NULL && *ws != NUL\n\t\t\t\t&& (wres[reslen - 1] == c\n\t\t\t\t\t\t    || wres[reslen - 1] == *ws))\n\t\t\t    reslen--;\n\t\t\tz0 = 1;\n\t\t\tz = 1;\n\t\t\tk0 = 0;\n\t\t\tif (ws != NULL)\n\t\t\t    while (*ws != NUL && word[i + k0] != NUL)\n\t\t\t    {\n\t\t\t\tword[i + k0] = *ws;\n\t\t\t\tk0++;\n\t\t\t\tws++;\n\t\t\t    }\n\t\t\tif (k > k0)\n\t\t\t    mch_memmove(word + i + k0, word + i + k,\n\t\t\t\t    sizeof(int) * (wordlen - (i + k) + 1));\n\n\t\t\t// new \"actual letter\"\n\t\t\tc = word[i];\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// no '<' rule used\n\t\t\ti += k - 1;\n\t\t\tz = 0;\n\t\t\tif (ws != NULL)\n\t\t\t    while (*ws != NUL && ws[1] != NUL\n\t\t\t\t\t\t\t  && reslen < MAXWLEN)\n\t\t\t    {\n\t\t\t\tif (reslen == 0 || wres[reslen - 1] != *ws)\n\t\t\t\t    wres[reslen++] = *ws;\n\t\t\t\tws++;\n\t\t\t    }\n\t\t\t// new \"actual letter\"\n\t\t\tif (ws == NULL)\n\t\t\t    c = NUL;\n\t\t\telse\n\t\t\t    c = *ws;\n\t\t\tif (strstr((char *)s, \"^^\") != NULL)\n\t\t\t{\n\t\t\t    if (c != NUL)\n\t\t\t\twres[reslen++] = c;\n\t\t\t    mch_memmove(word, word + i + 1,\n\t\t\t\t       sizeof(int) * (wordlen - (i + 1) + 1));\n\t\t\t    i = 0;\n\t\t\t    z0 = 1;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse if (VIM_ISWHITE(c))\n\t{\n\t    c = ' ';\n\t    k = 1;\n\t}\n\n\tif (z0 == 0)\n\t{\n\t    if (k && !p0 && reslen < MAXWLEN && c != NUL\n\t\t    && (!slang->sl_collapse || reslen == 0\n\t\t\t\t\t\t     || wres[reslen - 1] != c))\n\t\t// condense only double letters\n\t\twres[reslen++] = c;\n\n\t    i++;\n\t    z = 0;\n\t    k = 0;\n\t}\n    }\n\n    // Convert wide characters in \"wres\" to a multi-byte string in \"res\".\n    l = 0;\n    for (n = 0; n < reslen; ++n)\n    {\n\tl += mb_char2bytes(wres[n], res + l);\n\tif (l + MB_MAXBYTES > MAXWLEN)\n\t    break;\n    }\n    res[l] = NUL;\n}\n\n/*\n * \":spellinfo\"\n */\n    void\nex_spellinfo(exarg_T *eap UNUSED)\n{\n    int\t\tlpi;\n    langp_T\t*lp;\n    char_u\t*p;\n\n    if (no_spell_checking(curwin))\n\treturn;\n\n    msg_start();\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len && !got_int; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tmsg_puts(\"file: \");\n\tmsg_puts((char *)lp->lp_slang->sl_fname);\n\tmsg_putchar('\\n');\n\tp = lp->lp_slang->sl_info;\n\tif (p != NULL)\n\t{\n\t    msg_puts((char *)p);\n\t    msg_putchar('\\n');\n\t}\n    }\n    msg_end();\n}\n\n#define DUMPFLAG_KEEPCASE   1\t// round 2: keep-case tree\n#define DUMPFLAG_COUNT\t    2\t// include word count\n#define DUMPFLAG_ICASE\t    4\t// ignore case when finding matches\n#define DUMPFLAG_ONECAP\t    8\t// pattern starts with capital\n#define DUMPFLAG_ALLCAP\t    16\t// pattern is all capitals\n\n/*\n * \":spelldump\"\n */\n    void\nex_spelldump(exarg_T *eap)\n{\n    char_u  *spl;\n    long    dummy;\n\n    if (no_spell_checking(curwin))\n\treturn;\n    (void)get_option_value((char_u*)\"spl\", &dummy, &spl, NULL, OPT_LOCAL);\n\n    // Create a new empty buffer in a new window.\n    do_cmdline_cmd((char_u *)\"new\");\n\n    // enable spelling locally in the new window\n    set_option_value_give_err((char_u*)\"spell\", TRUE, (char_u*)\"\", OPT_LOCAL);\n    set_option_value_give_err((char_u*)\"spl\",  dummy, spl, OPT_LOCAL);\n    vim_free(spl);\n\n    if (!BUFEMPTY())\n\treturn;\n\n    spell_dump_compl(NULL, 0, NULL, eap->forceit ? DUMPFLAG_COUNT : 0);\n\n    // Delete the empty line that we started with.\n    if (curbuf->b_ml.ml_line_count > 1)\n\tml_delete(curbuf->b_ml.ml_line_count);\n\n    redraw_later(NOT_VALID);\n}\n\n/*\n * Go through all possible words and:\n * 1. When \"pat\" is NULL: dump a list of all words in the current buffer.\n *\t\"ic\" and \"dir\" are not used.\n * 2. When \"pat\" is not NULL: add matching words to insert mode completion.\n */\n    void\nspell_dump_compl(\n    char_u\t*pat,\t    // leading part of the word\n    int\t\tic,\t    // ignore case\n    int\t\t*dir,\t    // direction for adding matches\n    int\t\tdumpflags_arg)\t// DUMPFLAG_*\n{\n    langp_T\t*lp;\n    slang_T\t*slang;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\tword[MAXWLEN];\n    int\t\tc;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    linenr_T\tlnum = 0;\n    int\t\tround;\n    int\t\tdepth;\n    int\t\tn;\n    int\t\tflags;\n    char_u\t*region_names = NULL;\t    // region names being used\n    int\t\tdo_region = TRUE;\t    // dump region names and numbers\n    char_u\t*p;\n    int\t\tlpi;\n    int\t\tdumpflags = dumpflags_arg;\n    int\t\tpatlen;\n\n    // When ignoring case or when the pattern starts with capital pass this on\n    // to dump_word().\n    if (pat != NULL)\n    {\n\tif (ic)\n\t    dumpflags |= DUMPFLAG_ICASE;\n\telse\n\t{\n\t    n = captype(pat, NULL);\n\t    if (n == WF_ONECAP)\n\t\tdumpflags |= DUMPFLAG_ONECAP;\n\t    else if (n == WF_ALLCAP && (int)STRLEN(pat) > mb_ptr2len(pat))\n\t\tdumpflags |= DUMPFLAG_ALLCAP;\n\t}\n    }\n\n    // Find out if we can support regions: All languages must support the same\n    // regions or none at all.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tp = lp->lp_slang->sl_regions;\n\tif (p[0] != 0)\n\t{\n\t    if (region_names == NULL)\t    // first language with regions\n\t\tregion_names = p;\n\t    else if (STRCMP(region_names, p) != 0)\n\t    {\n\t\tdo_region = FALSE;\t    // region names are different\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (do_region && region_names != NULL)\n    {\n\tif (pat == NULL)\n\t{\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"/regions=%s\", region_names);\n\t    ml_append(lnum++, IObuff, (colnr_T)0, FALSE);\n\t}\n    }\n    else\n\tdo_region = FALSE;\n\n    /*\n     * Loop over all files loaded for the entries in 'spelllang'.\n     */\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tslang = lp->lp_slang;\n\tif (slang->sl_fbyts == NULL)\t    // reloading failed\n\t    continue;\n\n\tif (pat == NULL)\n\t{\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"# file: %s\", slang->sl_fname);\n\t    ml_append(lnum++, IObuff, (colnr_T)0, FALSE);\n\t}\n\n\t// When matching with a pattern and there are no prefixes only use\n\t// parts of the tree that match \"pat\".\n\tif (pat != NULL && slang->sl_pbyts == NULL)\n\t    patlen = (int)STRLEN(pat);\n\telse\n\t    patlen = -1;\n\n\t// round 1: case-folded tree\n\t// round 2: keep-case tree\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    if (round == 1)\n\t    {\n\t\tdumpflags &= ~DUMPFLAG_KEEPCASE;\n\t\tbyts = slang->sl_fbyts;\n\t\tidxs = slang->sl_fidxs;\n\t    }\n\t    else\n\t    {\n\t\tdumpflags |= DUMPFLAG_KEEPCASE;\n\t\tbyts = slang->sl_kbyts;\n\t\tidxs = slang->sl_kidxs;\n\t    }\n\t    if (byts == NULL)\n\t\tcontinue;\t\t// array is empty\n\n\t    depth = 0;\n\t    arridx[0] = 0;\n\t    curi[0] = 1;\n\t    while (depth >= 0 && !got_int\n\t\t\t\t  && (pat == NULL || !ins_compl_interrupted()))\n\t    {\n\t\tif (curi[depth] > byts[arridx[depth]])\n\t\t{\n\t\t    // Done all bytes at this node, go up one level.\n\t\t    --depth;\n\t\t    line_breakcheck();\n\t\t    ins_compl_check_keys(50, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Do one more byte at this node.\n\t\t    n = arridx[depth] + curi[depth];\n\t\t    ++curi[depth];\n\t\t    c = byts[n];\n\t\t    if (c == 0)\n\t\t    {\n\t\t\t// End of word, deal with the word.\n\t\t\t// Don't use keep-case words in the fold-case tree,\n\t\t\t// they will appear in the keep-case tree.\n\t\t\t// Only use the word when the region matches.\n\t\t\tflags = (int)idxs[n];\n\t\t\tif ((round == 2 || (flags & WF_KEEPCAP) == 0)\n\t\t\t\t&& (flags & WF_NEEDCOMP) == 0\n\t\t\t\t&& (do_region\n\t\t\t\t    || (flags & WF_REGION) == 0\n\t\t\t\t    || (((unsigned)flags >> 16)\n\t\t\t\t\t\t       & lp->lp_region) != 0))\n\t\t\t{\n\t\t\t    word[depth] = NUL;\n\t\t\t    if (!do_region)\n\t\t\t\tflags &= ~WF_REGION;\n\n\t\t\t    // Dump the basic word if there is no prefix or\n\t\t\t    // when it's the first one.\n\t\t\t    c = (unsigned)flags >> 24;\n\t\t\t    if (c == 0 || curi[depth] == 2)\n\t\t\t    {\n\t\t\t\tdump_word(slang, word, pat, dir,\n\t\t\t\t\t\t      dumpflags, flags, lnum);\n\t\t\t\tif (pat == NULL)\n\t\t\t\t    ++lnum;\n\t\t\t    }\n\n\t\t\t    // Apply the prefix, if there is one.\n\t\t\t    if (c != 0)\n\t\t\t\tlnum = dump_prefixes(slang, word, pat, dir,\n\t\t\t\t\t\t      dumpflags, flags, lnum);\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Normal char, go one level deeper.\n\t\t\tword[depth++] = c;\n\t\t\tarridx[depth] = idxs[n];\n\t\t\tcuri[depth] = 1;\n\n\t\t\t// Check if this character matches with the pattern.\n\t\t\t// If not skip the whole tree below it.\n\t\t\t// Always ignore case here, dump_word() will check\n\t\t\t// proper case later.  This isn't exactly right when\n\t\t\t// length changes for multi-byte characters with\n\t\t\t// ignore case...\n\t\t\tif (depth <= patlen\n\t\t\t\t\t&& MB_STRNICMP(word, pat, depth) != 0)\n\t\t\t    --depth;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * Dump one word: apply case modifications and append a line to the buffer.\n * When \"lnum\" is zero add insert mode completion.\n */\n    static void\ndump_word(\n    slang_T\t*slang,\n    char_u\t*word,\n    char_u\t*pat,\n    int\t\t*dir,\n    int\t\tdumpflags,\n    int\t\twordflags,\n    linenr_T\tlnum)\n{\n    int\t\tkeepcap = FALSE;\n    char_u\t*p;\n    char_u\t*tw;\n    char_u\tcword[MAXWLEN];\n    char_u\tbadword[MAXWLEN + 10];\n    int\t\ti;\n    int\t\tflags = wordflags;\n\n    if (dumpflags & DUMPFLAG_ONECAP)\n\tflags |= WF_ONECAP;\n    if (dumpflags & DUMPFLAG_ALLCAP)\n\tflags |= WF_ALLCAP;\n\n    if ((dumpflags & DUMPFLAG_KEEPCASE) == 0 && (flags & WF_CAPMASK) != 0)\n    {\n\t// Need to fix case according to \"flags\".\n\tmake_case_word(word, cword, flags);\n\tp = cword;\n    }\n    else\n    {\n\tp = word;\n\tif ((dumpflags & DUMPFLAG_KEEPCASE)\n\t\t&& ((captype(word, NULL) & WF_KEEPCAP) == 0\n\t\t\t\t\t\t || (flags & WF_FIXCAP) != 0))\n\t    keepcap = TRUE;\n    }\n    tw = p;\n\n    if (pat == NULL)\n    {\n\t// Add flags and regions after a slash.\n\tif ((flags & (WF_BANNED | WF_RARE | WF_REGION)) || keepcap)\n\t{\n\t    STRCPY(badword, p);\n\t    STRCAT(badword, \"/\");\n\t    if (keepcap)\n\t\tSTRCAT(badword, \"=\");\n\t    if (flags & WF_BANNED)\n\t\tSTRCAT(badword, \"!\");\n\t    else if (flags & WF_RARE)\n\t\tSTRCAT(badword, \"?\");\n\t    if (flags & WF_REGION)\n\t\tfor (i = 0; i < 7; ++i)\n\t\t    if (flags & (0x10000 << i))\n\t\t\tsprintf((char *)badword + STRLEN(badword), \"%d\", i + 1);\n\t    p = badword;\n\t}\n\n\tif (dumpflags & DUMPFLAG_COUNT)\n\t{\n\t    hashitem_T  *hi;\n\n\t    // Include the word count for \":spelldump!\".\n\t    hi = hash_find(&slang->sl_wordcount, tw);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"%s\\t%d\",\n\t\t\t\t\t\t     tw, HI2WC(hi)->wc_count);\n\t\tp = IObuff;\n\t    }\n\t}\n\n\tml_append(lnum, p, (colnr_T)0, FALSE);\n    }\n    else if (((dumpflags & DUMPFLAG_ICASE)\n\t\t    ? MB_STRNICMP(p, pat, STRLEN(pat)) == 0\n\t\t    : STRNCMP(p, pat, STRLEN(pat)) == 0)\n\t\t&& ins_compl_add_infercase(p, (int)STRLEN(p),\n\t\t\t\t\t  p_ic, NULL, *dir, FALSE) == OK)\n\t// if dir was BACKWARD then honor it just once\n\t*dir = FORWARD;\n}\n\n/*\n * For \":spelldump\": Find matching prefixes for \"word\".  Prepend each to\n * \"word\" and append a line to the buffer.\n * When \"lnum\" is zero add insert mode completion.\n * Return the updated line number.\n */\n    static linenr_T\ndump_prefixes(\n    slang_T\t*slang,\n    char_u\t*word,\t    // case-folded word\n    char_u\t*pat,\n    int\t\t*dir,\n    int\t\tdumpflags,\n    int\t\tflags,\t    // flags with prefix ID\n    linenr_T\tstartlnum)\n{\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\tprefix[MAXWLEN];\n    char_u\tword_up[MAXWLEN];\n    int\t\thas_word_up = FALSE;\n    int\t\tc;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    linenr_T\tlnum = startlnum;\n    int\t\tdepth;\n    int\t\tn;\n    int\t\tlen;\n    int\t\ti;\n\n    // If the word starts with a lower-case letter make the word with an\n    // upper-case letter in word_up[].\n    c = PTR2CHAR(word);\n    if (SPELL_TOUPPER(c) != c)\n    {\n\tonecap_copy(word, word_up, TRUE);\n\thas_word_up = TRUE;\n    }\n\n    byts = slang->sl_pbyts;\n    idxs = slang->sl_pidxs;\n    if (byts != NULL)\t\t// array not is empty\n    {\n\t/*\n\t * Loop over all prefixes, building them byte-by-byte in prefix[].\n\t * When at the end of a prefix check that it supports \"flags\".\n\t */\n\tdepth = 0;\n\tarridx[0] = 0;\n\tcuri[0] = 1;\n\twhile (depth >= 0 && !got_int)\n\t{\n\t    n = arridx[depth];\n\t    len = byts[n];\n\t    if (curi[depth] > len)\n\t    {\n\t\t// Done all bytes at this node, go up one level.\n\t\t--depth;\n\t\tline_breakcheck();\n\t    }\n\t    else\n\t    {\n\t\t// Do one more byte at this node.\n\t\tn += curi[depth];\n\t\t++curi[depth];\n\t\tc = byts[n];\n\t\tif (c == 0)\n\t\t{\n\t\t    // End of prefix, find out how many IDs there are.\n\t\t    for (i = 1; i < len; ++i)\n\t\t\tif (byts[n + i] != 0)\n\t\t\t    break;\n\t\t    curi[depth] += i - 1;\n\n\t\t    c = valid_word_prefix(i, n, flags, word, slang, FALSE);\n\t\t    if (c != 0)\n\t\t    {\n\t\t\tvim_strncpy(prefix + depth, word, MAXWLEN - depth - 1);\n\t\t\tdump_word(slang, prefix, pat, dir, dumpflags,\n\t\t\t\t(c & WF_RAREPFX) ? (flags | WF_RARE)\n\t\t\t\t\t\t\t       : flags, lnum);\n\t\t\tif (lnum != 0)\n\t\t\t    ++lnum;\n\t\t    }\n\n\t\t    // Check for prefix that matches the word when the\n\t\t    // first letter is upper-case, but only if the prefix has\n\t\t    // a condition.\n\t\t    if (has_word_up)\n\t\t    {\n\t\t\tc = valid_word_prefix(i, n, flags, word_up, slang,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t\tif (c != 0)\n\t\t\t{\n\t\t\t    vim_strncpy(prefix + depth, word_up,\n\t\t\t\t\t\t\t MAXWLEN - depth - 1);\n\t\t\t    dump_word(slang, prefix, pat, dir, dumpflags,\n\t\t\t\t    (c & WF_RAREPFX) ? (flags | WF_RARE)\n\t\t\t\t\t\t\t       : flags, lnum);\n\t\t\t    if (lnum != 0)\n\t\t\t\t++lnum;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Normal char, go one level deeper.\n\t\t    prefix[depth++] = c;\n\t\t    arridx[depth] = idxs[n];\n\t\t    curi[depth] = 1;\n\t\t}\n\t    }\n\t}\n    }\n\n    return lnum;\n}\n\n/*\n * Move \"p\" to the end of word \"start\".\n * Uses the spell-checking word characters.\n */\n    char_u *\nspell_to_word_end(char_u *start, win_T *win)\n{\n    char_u  *p = start;\n\n    while (*p != NUL && spell_iswordp(p, win))\n\tMB_PTR_ADV(p);\n    return p;\n}\n\n/*\n * For Insert mode completion CTRL-X s:\n * Find start of the word in front of column \"startcol\".\n * We don't check if it is badly spelled, with completion we can only change\n * the word in front of the cursor.\n * Returns the column number of the word.\n */\n    int\nspell_word_start(int startcol)\n{\n    char_u\t*line;\n    char_u\t*p;\n    int\t\tcol = 0;\n\n    if (no_spell_checking(curwin))\n\treturn startcol;\n\n    // Find a word character before \"startcol\".\n    line = ml_get_curline();\n    for (p = line + startcol; p > line; )\n    {\n\tMB_PTR_BACK(line, p);\n\tif (spell_iswordp_nmw(p, curwin))\n\t    break;\n    }\n\n    // Go back to start of the word.\n    while (p > line)\n    {\n\tcol = (int)(p - line);\n\tMB_PTR_BACK(line, p);\n\tif (!spell_iswordp(p, curwin))\n\t    break;\n\tcol = 0;\n    }\n\n    return col;\n}\n\n/*\n * Need to check for 'spellcapcheck' now, the word is removed before\n * expand_spelling() is called.  Therefore the ugly global variable.\n */\nstatic int spell_expand_need_cap;\n\n    void\nspell_expand_check_cap(colnr_T col)\n{\n    spell_expand_need_cap = check_need_cap(curwin->w_cursor.lnum, col);\n}\n\n/*\n * Get list of spelling suggestions.\n * Used for Insert mode completion CTRL-X ?.\n * Returns the number of matches.  The matches are in \"matchp[]\", array of\n * allocated strings.\n */\n    int\nexpand_spelling(\n    linenr_T\tlnum UNUSED,\n    char_u\t*pat,\n    char_u\t***matchp)\n{\n    garray_T\tga;\n\n    spell_suggest_list(&ga, pat, 100, spell_expand_need_cap, TRUE);\n    *matchp = ga.ga_data;\n    return ga.ga_len;\n}\n\n/*\n * Return TRUE if \"val\" is a valid 'spelllang' value.\n */\n    int\nvalid_spelllang(char_u *val)\n{\n    return valid_name(val, \".-_,@\");\n}\n\n/*\n * Return TRUE if \"val\" is a valid 'spellfile' value.\n */\n    int\nvalid_spellfile(char_u *val)\n{\n    char_u *s;\n\n    for (s = val; *s != NUL; ++s)\n\tif (!vim_isfilec(*s) && *s != ',' && *s != ' ')\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Handle side effects of setting 'spell'.\n * Return an error message or NULL for success.\n */\n    char *\ndid_set_spell_option(int is_spellfile)\n{\n    char    *errmsg = NULL;\n    win_T   *wp;\n    int\t    l;\n\n    if (is_spellfile)\n    {\n\tl = (int)STRLEN(curwin->w_s->b_p_spf);\n\tif (l > 0 && (l < 4\n\t\t\t|| STRCMP(curwin->w_s->b_p_spf + l - 4, \".add\") != 0))\n\t    errmsg = e_invalid_argument;\n    }\n\n    if (errmsg == NULL)\n    {\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == curbuf && wp->w_p_spell)\n\t    {\n\t\terrmsg = did_set_spelllang(wp);\n\t\tbreak;\n\t    }\n    }\n    return errmsg;\n}\n\n/*\n * Set curbuf->b_cap_prog to the regexp program for 'spellcapcheck'.\n * Return error message when failed, NULL when OK.\n */\n    char *\ncompile_cap_prog(synblock_T *synblock)\n{\n    regprog_T   *rp = synblock->b_cap_prog;\n    char_u\t*re;\n\n    if (synblock->b_p_spc == NULL || *synblock->b_p_spc == NUL)\n\tsynblock->b_cap_prog = NULL;\n    else\n    {\n\t// Prepend a ^ so that we only match at one column\n\tre = concat_str((char_u *)\"^\", synblock->b_p_spc);\n\tif (re != NULL)\n\t{\n\t    synblock->b_cap_prog = vim_regcomp(re, RE_MAGIC);\n\t    vim_free(re);\n\t    if (synblock->b_cap_prog == NULL)\n\t    {\n\t\tsynblock->b_cap_prog = rp; // restore the previous program\n\t\treturn e_invalid_argument;\n\t    }\n\t}\n    }\n\n    vim_regfree(rp);\n    return NULL;\n}\n\n#endif  // FEAT_SPELL\n", "\" Test for spell checking with 'encoding' set to utf-8\n\nsource check.vim\nCheckFeature spell\n\nscriptencoding utf-8\n\nfunc TearDown()\n  set nospell\n  call delete('Xtest.aff')\n  call delete('Xtest.dic')\n  call delete('Xtest.utf-8.add')\n  call delete('Xtest.utf-8.add.spl')\n  call delete('Xtest.utf-8.spl')\n  call delete('Xtest.utf-8.sug')\nendfunc\n\nlet g:test_data_aff1 = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\u00eb\u00e9\u00e8\u00ea\u00ef\u00ee\u00e4\u00e0\u00e2\u00f6\u00fc\u00fb'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00df\u00ff\",\n      \\\"LOW  \u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00df\u00ff\",\n      \\\"UPP  \u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00ff\",\n      \\\"\",\n      \\\"SOFOFROM abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xBF\",\n      \\\"SOFOTO   ebctefghejklnnepkrstevvkesebctefghejklnnepkrstevvkeseeeeeeeceeeeeeeedneeeeeeeeeeepseeeeeeeeceeeeeeeedneeeeeeeeeeep?\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\"\n      \\ ]\nlet g:test_data_dic1 = [\n      \\\"123456\",\n      \\\"test/NO\",\n      \\\"# comment\",\n      \\\"wrong\",\n      \\\"Comment\",\n      \\\"OK\",\n      \\\"uk\",\n      \\\"put/ISO\",\n      \\\"the end\",\n      \\\"deol\",\n      \\\"d\\xE9\\xF4r\",\n      \\ ]\nlet g:test_data_aff2 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out [a-z]\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\ ]\nlet g:test_data_aff3 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDRULE m*\",\n      \\\"NEEDCOMPOUND x\",\n      \\ ]\nlet g:test_data_dic3 = [\n      \\\"1234\",\n      \\\"foo/m\",\n      \\\"bar/mx\",\n      \\\"m\\xEF/m\",\n      \\\"la/mx\",\n      \\ ]\nlet g:test_data_aff4 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"COMPOUNDRULE m+\",\n      \\\"COMPOUNDRULE sm*e\",\n      \\\"COMPOUNDRULE sm+\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDWORDMAX 3\",\n      \\\"COMPOUNDFORBIDFLAG t\",\n      \\\"\",\n      \\\"COMPOUNDSYLMAX 5\",\n      \\\"SYLLABLE a\\xE1e\\xE9i\\xEDo\\xF3\\xF6\\xF5u\\xFA\\xFC\\xFBy/aa/au/ea/ee/ei/ie/oa/oe/oo/ou/uu/ui\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"NEEDAFFIX x\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD '-\",\n      \\\"\",\n      \\\"SFX q N 1\",\n      \\\"SFX q   0    -ok .\",\n      \\\"\",\n      \\\"SFX a Y 2\",\n      \\\"SFX a 0 s .\",\n      \\\"SFX a 0 ize/t .\",\n      \\\"\",\n      \\\"PFX p N 1\",\n      \\\"PFX p 0 pre .\",\n      \\\"\",\n      \\\"PFX P N 1\",\n      \\\"PFX P 0 nou .\",\n      \\ ]\nlet g:test_data_dic4 = [\n      \\\"1234\",\n      \\\"word/mP\",\n      \\\"util/am\",\n      \\\"pro/xq\",\n      \\\"tomato/m\",\n      \\\"bork/mp\",\n      \\\"start/s\",\n      \\\"end/e\",\n      \\ ]\nlet g:test_data_aff5 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG long\",\n      \\\"\",\n      \\\"NEEDAFFIX !!\",\n      \\\"\",\n      \\\"COMPOUNDRULE ssmm*ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND xx\",\n      \\\"COMPOUNDPERMITFLAG pp\",\n      \\\"\",\n      \\\"SFX 13 Y 1\",\n      \\\"SFX 13 0 bork .\",\n      \\\"\",\n      \\\"SFX a1 Y 1\",\n      \\\"SFX a1 0 a1 .\",\n      \\\"\",\n      \\\"SFX a\\xE9 Y 1\",\n      \\\"SFX a\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX zz Y 1\",\n      \\\"PFX zz 0 pre/pp .\",\n      \\\"\",\n      \\\"PFX yy Y 1\",\n      \\\"PFX yy 0 nou .\",\n      \\ ]\nlet g:test_data_dic5 = [\n      \\\"1234\",\n      \\\"foo/a1a\\xE9!!\",\n      \\\"bar/zz13ee\",\n      \\\"start/ss\",\n      \\\"end/eeyy\",\n      \\\"middle/mmxx\",\n      \\ ]\nlet g:test_data_aff6 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG caplong\",\n      \\\"\",\n      \\\"NEEDAFFIX A!\",\n      \\\"\",\n      \\\"COMPOUNDRULE sMm*Ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND Xx\",\n      \\\"\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX N3 Y 1\",\n      \\\"SFX N3 0 bork .\",\n      \\\"\",\n      \\\"SFX A1 Y 1\",\n      \\\"SFX A1 0 a1 .\",\n      \\\"\",\n      \\\"SFX A\\xE9 Y 1\",\n      \\\"SFX A\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX Zz Y 1\",\n      \\\"PFX Zz 0 pre/p .\",\n      \\ ]\nlet g:test_data_dic6 = [\n      \\\"1234\",\n      \\\"mee/A1A\\xE9A!\",\n      \\\"bar/ZzN3Ee\",\n      \\\"lead/s\",\n      \\\"end/Ee\",\n      \\\"middle/MmXx\",\n      \\ ]\nlet g:test_data_aff7 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG num\",\n      \\\"\",\n      \\\"NEEDAFFIX 9999\",\n      \\\"\",\n      \\\"COMPOUNDRULE 2,77*123\",\n      \\\"\",\n      \\\"NEEDCOMPOUND 1\",\n      \\\"COMPOUNDPERMITFLAG 432\",\n      \\\"\",\n      \\\"SFX 61003 Y 1\",\n      \\\"SFX 61003 0 meat .\",\n      \\\"\",\n      \\\"SFX 0 Y 1\",\n      \\\"SFX 0 0 zero .\",\n      \\\"\",\n      \\\"SFX 391 Y 1\",\n      \\\"SFX 391 0 a1 .\",\n      \\\"\",\n      \\\"SFX 111 Y 1\",\n      \\\"SFX 111 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX 17 Y 1\",\n      \\\"PFX 17 0 pre/432 .\",\n      \\ ]\nlet g:test_data_dic7 = [\n      \\\"1234\",\n      \\\"mee/0,391,111,9999\",\n      \\\"bar/17,61003,123\",\n      \\\"lead/2\",\n      \\\"tail/123\",\n      \\\"middle/77,1\",\n      \\ ]\nlet g:test_data_aff8 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"NOSPLITSUGS\",\n      \\ ]\nlet g:test_data_dic8 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\\"faabar\",\n      \\ ]\nlet g:test_data_aff9 = [\n      \\ ]\nlet g:test_data_dic9 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\ ]\nlet g:test_data_aff10 = [\n      \\\"COMPOUNDRULE se\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX A Y 1\",\n      \\\"SFX A 0 able/Mp .\",\n      \\\"\",\n      \\\"SFX M Y 1\",\n      \\\"SFX M 0 s .\",\n      \\ ]\nlet g:test_data_dic10 = [\n      \\\"1234\",\n      \\\"drink/As\",\n      \\\"table/e\",\n      \\ ]\nlet g:test_data_aff_sal = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\\xEB\\xE9\\xE8\\xEA\\xEF\\xEE\\xE4\\xE0\\xE2\\xF6\\xFC\\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"SAL AH(AEIOUY)-^         *H\",\n      \\\"SAL AR(AEIOUY)-^         *R\",\n      \\\"SAL A(HR)^               *\",\n      \\\"SAL A^                   *\",\n      \\\"SAL AH(AEIOUY)-          H\",\n      \\\"SAL AR(AEIOUY)-          R\",\n      \\\"SAL A(HR)                _\",\n      \\\"SAL \\xC0^                   *\",\n      \\\"SAL \\xC5^                   *\",\n      \\\"SAL BB-                  _\",\n      \\\"SAL B                    B\",\n      \\\"SAL CQ-                  _\",\n      \\\"SAL CIA                  X\",\n      \\\"SAL CH                   X\",\n      \\\"SAL C(EIY)-              S\",\n      \\\"SAL CK                   K\",\n      \\\"SAL COUGH^               KF\",\n      \\\"SAL CC<                  C\",\n      \\\"SAL C                    K\",\n      \\\"SAL DG(EIY)              K\",\n      \\\"SAL DD-                  _\",\n      \\\"SAL D                    T\",\n      \\\"SAL \\xC9<                   E\",\n      \\\"SAL EH(AEIOUY)-^         *H\",\n      \\\"SAL ER(AEIOUY)-^         *R\",\n      \\\"SAL E(HR)^               *\",\n      \\\"SAL ENOUGH^$             *NF\",\n      \\\"SAL E^                   *\",\n      \\\"SAL EH(AEIOUY)-          H\",\n      \\\"SAL ER(AEIOUY)-          R\",\n      \\\"SAL E(HR)                _\",\n      \\\"SAL FF-                  _\",\n      \\\"SAL F                    F\",\n      \\\"SAL GN^                  N\",\n      \\\"SAL GN$                  N\",\n      \\\"SAL GNS$                 NS\",\n      \\\"SAL GNED$                N\",\n      \\\"SAL GH(AEIOUY)-          K\",\n      \\\"SAL GH                   _\",\n      \\\"SAL GG9                  K\",\n      \\\"SAL G                    K\",\n      \\\"SAL H                    H\",\n      \\\"SAL IH(AEIOUY)-^         *H\",\n      \\\"SAL IR(AEIOUY)-^         *R\",\n      \\\"SAL I(HR)^               *\",\n      \\\"SAL I^                   *\",\n      \\\"SAL ING6                 N\",\n      \\\"SAL IH(AEIOUY)-          H\",\n      \\\"SAL IR(AEIOUY)-          R\",\n      \\\"SAL I(HR)                _\",\n      \\\"SAL J                    K\",\n      \\\"SAL KN^                  N\",\n      \\\"SAL KK-                  _\",\n      \\\"SAL K                    K\",\n      \\\"SAL LAUGH^               LF\",\n      \\\"SAL LL-                  _\",\n      \\\"SAL L                    L\",\n      \\\"SAL MB$                  M\",\n      \\\"SAL MM                   M\",\n      \\\"SAL M                    M\",\n      \\\"SAL NN-                  _\",\n      \\\"SAL N                    N\",\n      \\\"SAL OH(AEIOUY)-^         *H\",\n      \\\"SAL OR(AEIOUY)-^         *R\",\n      \\\"SAL O(HR)^               *\",\n      \\\"SAL O^                   *\",\n      \\\"SAL OH(AEIOUY)-          H\",\n      \\\"SAL OR(AEIOUY)-          R\",\n      \\\"SAL O(HR)                _\",\n      \\\"SAL PH                   F\",\n      \\\"SAL PN^                  N\",\n      \\\"SAL PP-                  _\",\n      \\\"SAL P                    P\",\n      \\\"SAL Q                    K\",\n      \\\"SAL RH^                  R\",\n      \\\"SAL ROUGH^               RF\",\n      \\\"SAL RR-                  _\",\n      \\\"SAL R                    R\",\n      \\\"SAL SCH(EOU)-            SK\",\n      \\\"SAL SC(IEY)-             S\",\n      \\\"SAL SH                   X\",\n      \\\"SAL SI(AO)-              X\",\n      \\\"SAL SS-                  _\",\n      \\\"SAL S                    S\",\n      \\\"SAL TI(AO)-              X\",\n      \\\"SAL TH                   @\",\n      \\\"SAL TCH--                _\",\n      \\\"SAL TOUGH^               TF\",\n      \\\"SAL TT-                  _\",\n      \\\"SAL T                    T\",\n      \\\"SAL UH(AEIOUY)-^         *H\",\n      \\\"SAL UR(AEIOUY)-^         *R\",\n      \\\"SAL U(HR)^               *\",\n      \\\"SAL U^                   *\",\n      \\\"SAL UH(AEIOUY)-          H\",\n      \\\"SAL UR(AEIOUY)-          R\",\n      \\\"SAL U(HR)                _\",\n      \\\"SAL V^                   W\",\n      \\\"SAL V                    F\",\n      \\\"SAL WR^                  R\",\n      \\\"SAL WH^                  W\",\n      \\\"SAL W(AEIOU)-            W\",\n      \\\"SAL X^                   S\",\n      \\\"SAL X                    KS\",\n      \\\"SAL Y(AEIOU)-            Y\",\n      \\\"SAL ZZ-                  _\",\n      \\\"SAL Z                    S\",\n      \\ ]\n\nfunc LoadAffAndDic(aff_contents, dic_contents)\n  set enc=utf-8\n  set spellfile=\n  call writefile(a:aff_contents, \"Xtest.aff\")\n  call writefile(a:dic_contents, \"Xtest.dic\")\n  \" Generate a .spl file from a .dic and .aff file.\n  mkspell! Xtest Xtest\n  \" use that spell file\n  set spl=Xtest.utf-8.spl spell\nendfunc\n\nfunc ListWords()\n  spelldump\n  %yank\n  quit\n  return split(@\", \"\\n\")\nendfunc\n\nfunc TestGoodBadBase()\n  exe '1;/^good:'\n  normal 0f:]s\n  let prevbad = ''\n  let result = []\n  while 1\n    let [bad, a] = spellbadword()\n    if bad == '' || bad == prevbad || bad == 'badend'\n      break\n    endif\n    let prevbad = bad\n    let lst = bad->spellsuggest(3)\n    normal mm\n\n    call add(result, [bad, lst])\n    normal `m]s\n  endwhile\n  return result\nendfunc\n\nfunc RunGoodBad(good, bad, expected_words, expected_bad_words)\n  %bwipe!\n  call setline(1, ['', \"good: \", a:good,  a:bad, \" badend \"])\n  let words = ListWords()\n  call assert_equal(a:expected_words, words[1:-1])\n  let bad_words = TestGoodBadBase()\n  call assert_equal(a:expected_bad_words, bad_words)\n  %bwipe!\nendfunc\n\nfunc Test_spell_basic()\n  call LoadAffAndDic(g:test_data_aff1, g:test_data_dic1)\n  call RunGoodBad(\"wrong OK puts. Test the end\",\n        \\ \"bad: inputs comment ok Ok. test d\\u00E9\\u00F4l end the\",\n        \\[\"Comment\", \"deol\", \"d\\u00E9\\u00F4r\", \"input\", \"OK\", \"output\", \"outputs\", \"outtest\", \"put\", \"puts\",\n        \\  \"test\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\[\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\", \"outtest\", \"the end\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\u00E9\\u00F4l\", [\"deol\", \"d\\u00E9\\u00F4r\", \"test\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\ ]\n        \\ )\n\n  call assert_equal(\"gebletegek\", soundfold('goobledygoook'))\n  call assert_equal(\"kepereneven\", 'k\u00f3op\u00ebr\u00ffn\u00f4ven'->soundfold())\n  call assert_equal(\"everles gesvets etele\", soundfold('oeverloos gezwets edale'))\nendfunc\n\n\" Postponed prefixes\nfunc Test_spell_prefixes()\n  call LoadAffAndDic(g:test_data_aff2, g:test_data_dic1)\n  call RunGoodBad(\"puts\",\n        \\ \"bad: inputs comment ok Ok end the. test d\\u00E9\\u00F4l\",\n        \\ [\"Comment\", \"deol\", \"d\\u00E9\\u00F4r\", \"OK\", \"put\", \"input\", \"output\", \"puts\", \"outputs\", \"test\", \"outtest\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\ [\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"deol\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\u00E9\\u00F4l\", [\"deol\", \"d\\u00E9\\u00F4r\", \"test\"]],\n        \\ ])\nendfunc\n\n\"Compound words\nfunc Test_spell_compound()\n  call LoadAffAndDic(g:test_data_aff3, g:test_data_dic3)\n  call RunGoodBad(\"foo m\\u00EF foobar foofoobar barfoo barbarfoo\",\n        \\ \"bad: bar la foom\\u00EF barm\\u00EF m\\u00EFfoo m\\u00EFbar m\\u00EFm\\u00EF lala m\\u00EFla lam\\u00EF foola labar\",\n        \\ [\"foo\", \"m\\u00EF\"],\n        \\ [\n        \\   [\"bad\", [\"foo\", \"m\\u00EF\"]],\n        \\   [\"bar\", [\"barfoo\", \"foobar\", \"foo\"]],\n        \\   [\"la\", [\"m\\u00EF\", \"foo\"]],\n        \\   [\"foom\\u00EF\", [\"foo m\\u00EF\", \"foo\", \"foofoo\"]],\n        \\   [\"barm\\u00EF\", [\"barfoo\", \"m\\u00EF\", \"barbar\"]],\n        \\   [\"m\\u00EFfoo\", [\"m\\u00EF foo\", \"foo\", \"foofoo\"]],\n        \\   [\"m\\u00EFbar\", [\"foobar\", \"barbar\", \"m\\u00EF\"]],\n        \\   [\"m\\u00EFm\\u00EF\", [\"m\\u00EF m\\u00EF\", \"m\\u00EF\"]],\n        \\   [\"lala\", []],\n        \\   [\"m\\u00EFla\", [\"m\\u00EF\", \"m\\u00EF m\\u00EF\"]],\n        \\   [\"lam\\u00EF\", [\"m\\u00EF\", \"m\\u00EF m\\u00EF\"]],\n        \\   [\"foola\", [\"foo\", \"foobar\", \"foofoo\"]],\n        \\   [\"labar\", [\"barbar\", \"foobar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff4, g:test_data_dic4)\n  call RunGoodBad(\"word util bork prebork start end wordutil wordutils pro-ok bork borkbork borkborkbork borkborkborkbork borkborkborkborkbork tomato tomatotomato startend startword startwordword startwordend startwordwordend startwordwordwordend prebork preborkbork preborkborkbork nouword\",\n        \\ \"bad: wordutilize pro borkborkborkborkborkbork tomatotomatotomato endstart endend startstart wordend wordstart preborkprebork  preborkpreborkbork startwordwordwordwordend borkpreborkpreborkbork utilsbork  startnouword\",\n        \\ [\"bork\", \"prebork\", \"end\", \"pro-ok\", \"start\", \"tomato\", \"util\", \"utilize\", \"utils\", \"word\", \"nouword\"],\n        \\ [\n        \\   [\"bad\", [\"end\", \"bork\", \"word\"]],\n        \\   [\"wordutilize\", [\"word utilize\", \"wordutils\", \"wordutil\"]],\n        \\   [\"pro\", [\"bork\", \"word\", \"end\"]],\n        \\   [\"borkborkborkborkborkbork\", [\"bork borkborkborkborkbork\", \"borkbork borkborkborkbork\", \"borkborkbork borkborkbork\"]],\n        \\   [\"tomatotomatotomato\", [\"tomato tomatotomato\", \"tomatotomato tomato\", \"tomato tomato tomato\"]],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"endend\", [\"end end\", \"end\"]],\n        \\   [\"startstart\", [\"start start\"]],\n        \\   [\"wordend\", [\"word end\", \"word\", \"wordword\"]],\n        \\   [\"wordstart\", [\"word start\", \"bork start\"]],\n        \\   [\"preborkprebork\", [\"prebork prebork\", \"preborkbork\", \"preborkborkbork\"]],\n        \\   [\"preborkpreborkbork\", [\"prebork preborkbork\", \"preborkborkbork\", \"preborkborkborkbork\"]],\n        \\   [\"startwordwordwordwordend\", [\"startwordwordwordword end\", \"startwordwordwordword\", \"start wordwordwordword end\"]],\n        \\   [\"borkpreborkpreborkbork\", [\"bork preborkpreborkbork\", \"bork prebork preborkbork\", \"bork preborkprebork bork\"]],\n        \\   [\"utilsbork\", [\"utilbork\", \"utils bork\", \"util bork\"]],\n        \\   [\"startnouword\", [\"start nouword\", \"startword\", \"startborkword\"]],\n        \\ ])\n\nendfunc\n\n\" Test affix flags with two characters\nfunc Test_spell_affix()\n  call LoadAffAndDic(g:test_data_aff5, g:test_data_dic5)\n  call RunGoodBad(\"fooa1 fooa\\u00E9 bar prebar barbork prebarbork  startprebar start end startend  startmiddleend nouend\",\n        \\ \"bad: foo fooa2 prabar probarbirk middle startmiddle middleend endstart startprobar startnouend\",\n        \\ [\"bar\", \"barbork\", \"end\", \"fooa1\", \"fooa\\u00E9\", \"nouend\", \"prebar\", \"prebarbork\", \"start\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"fooa1\"]],\n        \\   [\"foo\", [\"fooa1\", \"bar\", \"end\"]],\n        \\   [\"fooa2\", [\"fooa1\", \"fooa\\u00E9\", \"bar\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"bar bar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"startmiddle\", [\"startmiddleend\", \"startmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"startprobar\", [\"startprebar\", \"start prebar\", \"startbar\"]],\n        \\   [\"startnouend\", [\"start nouend\", \"startend\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff6, g:test_data_dic6)\n  call RunGoodBad(\"meea1 meea\\u00E9 bar prebar barbork prebarbork  leadprebar lead end leadend  leadmiddleend\",\n        \\  \"bad: mee meea2 prabar probarbirk middle leadmiddle middleend endlead leadprobar\",\n        \\ [\"bar\", \"barbork\", \"end\", \"lead\", \"meea1\", \"meea\\u00E9\", \"prebar\", \"prebarbork\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"lead\"]],\n        \\   [\"mee\", [\"meea1\", \"bar\", \"end\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\u00E9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddleend\", \"leadmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endlead\", [\"end lead\", \"lead\", \"end end\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff7, g:test_data_dic7)\n  call RunGoodBad(\"meea1 meezero meea\\u00E9 bar prebar barmeat prebarmeat  leadprebar lead tail leadtail  leadmiddletail\",\n        \\ \"bad: mee meea2 prabar probarmaat middle leadmiddle middletail taillead leadprobar\",\n        \\ [\"bar\", \"barmeat\", \"lead\", \"meea1\", \"meea\\u00E9\", \"meezero\", \"prebar\", \"prebarmeat\", \"tail\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"lead\", \"tail\"]],\n        \\   [\"mee\", [\"meea1\", \"bar\", \"lead\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\u00E9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarmaat\", [\"prebarmeat\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddlebar\"]],\n        \\   [\"middletail\", []],\n        \\   [\"taillead\", [\"tail lead\", \"tail\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\nendfunc\n\nfunc Test_spell_NOSLITSUGS()\n  call LoadAffAndDic(g:test_data_aff8, g:test_data_dic8)\n  call RunGoodBad(\"foo bar faabar\", \"bad: foobar barfoo\",\n        \\ [\"bar\", \"faabar\", \"foo\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"foo\"]],\n        \\   [\"foobar\", [\"faabar\", \"foo bar\", \"bar\"]],\n        \\   [\"barfoo\", [\"bar foo\", \"bar\", \"foo\"]],\n        \\ ])\nendfunc\n\n\" Numbers\nfunc Test_spell_Numbers()\n  call LoadAffAndDic(g:test_data_aff9, g:test_data_dic9)\n  call RunGoodBad(\"0b1011 0777 1234 0x01ff\", \"\",\n        \\ [\"bar\", \"foo\"],\n        \\ [\n        \\ ])\nendfunc\n\n\" Affix flags\nfunc Test_spell_affix_flags()\n  call LoadAffAndDic(g:test_data_aff10, g:test_data_dic10)\n  call RunGoodBad(\"drink drinkable drinkables drinktable drinkabletable\",\n\t\\ \"bad: drinks drinkstable drinkablestable\",\n        \\ [\"drink\", \"drinkable\", \"drinkables\", \"table\"],\n        \\ [['bad', []],\n\t\\ ['drinks', ['drink']],\n\t\\ ['drinkstable', ['drinktable', 'drinkable', 'drink table']],\n        \\ ['drinkablestable', ['drinkabletable', 'drinkables table', 'drinkable table']],\n\t\\ ])\nendfunc\n\nfunction FirstSpellWord()\n  call feedkeys(\"/^start:\\n\", 'tx')\n  normal ]smm\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\nfunction SecondSpellWord()\n  normal `m]s\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\n\" Test with SAL instead of SOFO items; test automatic reloading\nfunc Test_spell_sal_and_addition()\n  set spellfile=\n  call writefile(g:test_data_dic1, \"Xtest.dic\")\n  call writefile(g:test_data_aff_sal, \"Xtest.aff\")\n  mkspell! Xtest Xtest\n  set spl=Xtest.utf-8.spl spell\n  call assert_equal('kbltykk', soundfold('goobledygoook'))\n  call assert_equal('kprnfn', soundfold('k\u00f3op\u00ebr\u00ffn\u00f4ven'))\n  call assert_equal('*fls kswts tl', soundfold('oeverloos gezwets edale'))\n\n  \"also use an addition file\n  call writefile([\"/regions=usgbnz\", \"elequint/2\", \"elekwint/3\"], \"Xtest.utf-8.add\")\n  mkspell! Xtest.utf-8.add.spl Xtest.utf-8.add\n\n  bwipe!\n  call setline(1, [\"start: elequint test elekwint test elekwent asdf\"])\n\n  set spellfile=Xtest.utf-8.add\n  call assert_equal(\"elekwent\", FirstSpellWord())\n\n  set spl=Xtest_us.utf-8.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\n\n  set spl=Xtest_gb.utf-8.spl\n  call assert_equal(\"elekwint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_nz.utf-8.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_ca.utf-8.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\n\n  set spellfile=\n  set spl&\nendfunc\n\nfunc Test_spellfile_value()\n  set spellfile=Xdir/Xtest.utf-8.add\n  set spellfile=Xdir/Xtest.utf-8.add,Xtest_other.add\n  set spellfile=\nendfunc\n\nfunc Test_no_crash_with_weird_text()\n  new\n  let lines =<< trim END\n      r<sfile>\n      \u0080\n\n\n      \u0080\n  END\n  call setline(1, lines)\n  exe \"%norm \\<C-v>ez=>\\<C-v>wzG\"\n\n  bwipe!\nendfunc\n\n\" Invalid bytes may cause trouble when creating the word list.\nfunc Test_check_for_valid_word()\n  call assert_fails(\"spellgood! 0\u0002\\xac\", 'E1280:')\nendfunc\n\n\" This was going over the end of the word\nfunc Test_word_index()\n  new\n  norm R0\n  spellgood! \ufb020\n  sil norm z=\n\n  bwipe!\n  \" clear the word list\n  set enc=utf-8\n  call delete('Xtmpfile')\nendfunc\n\nfunc Test_check_empty_line()\n  \" This was using freed memory\n  enew\n  spellgood! \ufb02\n  norm z=\n  norm yy\n  sil! norm P]svc\n  norm P]s\n\n  \" set 'encoding' to clear the wordt list\n  set enc=latin1\n  set enc=utf-8\n  bwipe!\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    5072,\n/**/\n    5071,\n/**/\n    5070,\n/**/\n    5069,\n/**/\n    5068,\n/**/\n    5067,\n/**/\n    5066,\n/**/\n    5065,\n/**/\n    5064,\n/**/\n    5063,\n/**/\n    5062,\n/**/\n    5061,\n/**/\n    5060,\n/**/\n    5059,\n/**/\n    5058,\n/**/\n    5057,\n/**/\n    5056,\n/**/\n    5055,\n/**/\n    5054,\n/**/\n    5053,\n/**/\n    5052,\n/**/\n    5051,\n/**/\n    5050,\n/**/\n    5049,\n/**/\n    5048,\n/**/\n    5047,\n/**/\n    5046,\n/**/\n    5045,\n/**/\n    5044,\n/**/\n    5043,\n/**/\n    5042,\n/**/\n    5041,\n/**/\n    5040,\n/**/\n    5039,\n/**/\n    5038,\n/**/\n    5037,\n/**/\n    5036,\n/**/\n    5035,\n/**/\n    5034,\n/**/\n    5033,\n/**/\n    5032,\n/**/\n    5031,\n/**/\n    5030,\n/**/\n    5029,\n/**/\n    5028,\n/**/\n    5027,\n/**/\n    5026,\n/**/\n    5025,\n/**/\n    5024,\n/**/\n    5023,\n/**/\n    5022,\n/**/\n    5021,\n/**/\n    5020,\n/**/\n    5019,\n/**/\n    5018,\n/**/\n    5017,\n/**/\n    5016,\n/**/\n    5015,\n/**/\n    5014,\n/**/\n    5013,\n/**/\n    5012,\n/**/\n    5011,\n/**/\n    5010,\n/**/\n    5009,\n/**/\n    5008,\n/**/\n    5007,\n/**/\n    5006,\n/**/\n    5005,\n/**/\n    5004,\n/**/\n    5003,\n/**/\n    5002,\n/**/\n    5001,\n/**/\n    5000,\n/**/\n    4999,\n/**/\n    4998,\n/**/\n    4997,\n/**/\n    4996,\n/**/\n    4995,\n/**/\n    4994,\n/**/\n    4993,\n/**/\n    4992,\n/**/\n    4991,\n/**/\n    4990,\n/**/\n    4989,\n/**/\n    4988,\n/**/\n    4987,\n/**/\n    4986,\n/**/\n    4985,\n/**/\n    4984,\n/**/\n    4983,\n/**/\n    4982,\n/**/\n    4981,\n/**/\n    4980,\n/**/\n    4979,\n/**/\n    4978,\n/**/\n    4977,\n/**/\n    4976,\n/**/\n    4975,\n/**/\n    4974,\n/**/\n    4973,\n/**/\n    4972,\n/**/\n    4971,\n/**/\n    4970,\n/**/\n    4969,\n/**/\n    4968,\n/**/\n    4967,\n/**/\n    4966,\n/**/\n    4965,\n/**/\n    4964,\n/**/\n    4963,\n/**/\n    4962,\n/**/\n    4961,\n/**/\n    4960,\n/**/\n    4959,\n/**/\n    4958,\n/**/\n    4957,\n/**/\n    4956,\n/**/\n    4955,\n/**/\n    4954,\n/**/\n    4953,\n/**/\n    4952,\n/**/\n    4951,\n/**/\n    4950,\n/**/\n    4949,\n/**/\n    4948,\n/**/\n    4947,\n/**/\n    4946,\n/**/\n    4945,\n/**/\n    4944,\n/**/\n    4943,\n/**/\n    4942,\n/**/\n    4941,\n/**/\n    4940,\n/**/\n    4939,\n/**/\n    4938,\n/**/\n    4937,\n/**/\n    4936,\n/**/\n    4935,\n/**/\n    4934,\n/**/\n    4933,\n/**/\n    4932,\n/**/\n    4931,\n/**/\n    4930,\n/**/\n    4929,\n/**/\n    4928,\n/**/\n    4927,\n/**/\n    4926,\n/**/\n    4925,\n/**/\n    4924,\n/**/\n    4923,\n/**/\n    4922,\n/**/\n    4921,\n/**/\n    4920,\n/**/\n    4919,\n/**/\n    4918,\n/**/\n    4917,\n/**/\n    4916,\n/**/\n    4915,\n/**/\n    4914,\n/**/\n    4913,\n/**/\n    4912,\n/**/\n    4911,\n/**/\n    4910,\n/**/\n    4909,\n/**/\n    4908,\n/**/\n    4907,\n/**/\n    4906,\n/**/\n    4905,\n/**/\n    4904,\n/**/\n    4903,\n/**/\n    4902,\n/**/\n    4901,\n/**/\n    4900,\n/**/\n    4899,\n/**/\n    4898,\n/**/\n    4897,\n/**/\n    4896,\n/**/\n    4895,\n/**/\n    4894,\n/**/\n    4893,\n/**/\n    4892,\n/**/\n    4891,\n/**/\n    4890,\n/**/\n    4889,\n/**/\n    4888,\n/**/\n    4887,\n/**/\n    4886,\n/**/\n    4885,\n/**/\n    4884,\n/**/\n    4883,\n/**/\n    4882,\n/**/\n    4881,\n/**/\n    4880,\n/**/\n    4879,\n/**/\n    4878,\n/**/\n    4877,\n/**/\n    4876,\n/**/\n    4875,\n/**/\n    4874,\n/**/\n    4873,\n/**/\n    4872,\n/**/\n    4871,\n/**/\n    4870,\n/**/\n    4869,\n/**/\n    4868,\n/**/\n    4867,\n/**/\n    4866,\n/**/\n    4865,\n/**/\n    4864,\n/**/\n    4863,\n/**/\n    4862,\n/**/\n    4861,\n/**/\n    4860,\n/**/\n    4859,\n/**/\n    4858,\n/**/\n    4857,\n/**/\n    4856,\n/**/\n    4855,\n/**/\n    4854,\n/**/\n    4853,\n/**/\n    4852,\n/**/\n    4851,\n/**/\n    4850,\n/**/\n    4849,\n/**/\n    4848,\n/**/\n    4847,\n/**/\n    4846,\n/**/\n    4845,\n/**/\n    4844,\n/**/\n    4843,\n/**/\n    4842,\n/**/\n    4841,\n/**/\n    4840,\n/**/\n    4839,\n/**/\n    4838,\n/**/\n    4837,\n/**/\n    4836,\n/**/\n    4835,\n/**/\n    4834,\n/**/\n    4833,\n/**/\n    4832,\n/**/\n    4831,\n/**/\n    4830,\n/**/\n    4829,\n/**/\n    4828,\n/**/\n    4827,\n/**/\n    4826,\n/**/\n    4825,\n/**/\n    4824,\n/**/\n    4823,\n/**/\n    4822,\n/**/\n    4821,\n/**/\n    4820,\n/**/\n    4819,\n/**/\n    4818,\n/**/\n    4817,\n/**/\n    4816,\n/**/\n    4815,\n/**/\n    4814,\n/**/\n    4813,\n/**/\n    4812,\n/**/\n    4811,\n/**/\n    4810,\n/**/\n    4809,\n/**/\n    4808,\n/**/\n    4807,\n/**/\n    4806,\n/**/\n    4805,\n/**/\n    4804,\n/**/\n    4803,\n/**/\n    4802,\n/**/\n    4801,\n/**/\n    4800,\n/**/\n    4799,\n/**/\n    4798,\n/**/\n    4797,\n/**/\n    4796,\n/**/\n    4795,\n/**/\n    4794,\n/**/\n    4793,\n/**/\n    4792,\n/**/\n    4791,\n/**/\n    4790,\n/**/\n    4789,\n/**/\n    4788,\n/**/\n    4787,\n/**/\n    4786,\n/**/\n    4785,\n/**/\n    4784,\n/**/\n    4783,\n/**/\n    4782,\n/**/\n    4781,\n/**/\n    4780,\n/**/\n    4779,\n/**/\n    4778,\n/**/\n    4777,\n/**/\n    4776,\n/**/\n    4775,\n/**/\n    4774,\n/**/\n    4773,\n/**/\n    4772,\n/**/\n    4771,\n/**/\n    4770,\n/**/\n    4769,\n/**/\n    4768,\n/**/\n    4767,\n/**/\n    4766,\n/**/\n    4765,\n/**/\n    4764,\n/**/\n    4763,\n/**/\n    4762,\n/**/\n    4761,\n/**/\n    4760,\n/**/\n    4759,\n/**/\n    4758,\n/**/\n    4757,\n/**/\n    4756,\n/**/\n    4755,\n/**/\n    4754,\n/**/\n    4753,\n/**/\n    4752,\n/**/\n    4751,\n/**/\n    4750,\n/**/\n    4749,\n/**/\n    4748,\n/**/\n    4747,\n/**/\n    4746,\n/**/\n    4745,\n/**/\n    4744,\n/**/\n    4743,\n/**/\n    4742,\n/**/\n    4741,\n/**/\n    4740,\n/**/\n    4739,\n/**/\n    4738,\n/**/\n    4737,\n/**/\n    4736,\n/**/\n    4735,\n/**/\n    4734,\n/**/\n    4733,\n/**/\n    4732,\n/**/\n    4731,\n/**/\n    4730,\n/**/\n    4729,\n/**/\n    4728,\n/**/\n    4727,\n/**/\n    4726,\n/**/\n    4725,\n/**/\n    4724,\n/**/\n    4723,\n/**/\n    4722,\n/**/\n    4721,\n/**/\n    4720,\n/**/\n    4719,\n/**/\n    4718,\n/**/\n    4717,\n/**/\n    4716,\n/**/\n    4715,\n/**/\n    4714,\n/**/\n    4713,\n/**/\n    4712,\n/**/\n    4711,\n/**/\n    4710,\n/**/\n    4709,\n/**/\n    4708,\n/**/\n    4707,\n/**/\n    4706,\n/**/\n    4705,\n/**/\n    4704,\n/**/\n    4703,\n/**/\n    4702,\n/**/\n    4701,\n/**/\n    4700,\n/**/\n    4699,\n/**/\n    4698,\n/**/\n    4697,\n/**/\n    4696,\n/**/\n    4695,\n/**/\n    4694,\n/**/\n    4693,\n/**/\n    4692,\n/**/\n    4691,\n/**/\n    4690,\n/**/\n    4689,\n/**/\n    4688,\n/**/\n    4687,\n/**/\n    4686,\n/**/\n    4685,\n/**/\n    4684,\n/**/\n    4683,\n/**/\n    4682,\n/**/\n    4681,\n/**/\n    4680,\n/**/\n    4679,\n/**/\n    4678,\n/**/\n    4677,\n/**/\n    4676,\n/**/\n    4675,\n/**/\n    4674,\n/**/\n    4673,\n/**/\n    4672,\n/**/\n    4671,\n/**/\n    4670,\n/**/\n    4669,\n/**/\n    4668,\n/**/\n    4667,\n/**/\n    4666,\n/**/\n    4665,\n/**/\n    4664,\n/**/\n    4663,\n/**/\n    4662,\n/**/\n    4661,\n/**/\n    4660,\n/**/\n    4659,\n/**/\n    4658,\n/**/\n    4657,\n/**/\n    4656,\n/**/\n    4655,\n/**/\n    4654,\n/**/\n    4653,\n/**/\n    4652,\n/**/\n    4651,\n/**/\n    4650,\n/**/\n    4649,\n/**/\n    4648,\n/**/\n    4647,\n/**/\n    4646,\n/**/\n    4645,\n/**/\n    4644,\n/**/\n    4643,\n/**/\n    4642,\n/**/\n    4641,\n/**/\n    4640,\n/**/\n    4639,\n/**/\n    4638,\n/**/\n    4637,\n/**/\n    4636,\n/**/\n    4635,\n/**/\n    4634,\n/**/\n    4633,\n/**/\n    4632,\n/**/\n    4631,\n/**/\n    4630,\n/**/\n    4629,\n/**/\n    4628,\n/**/\n    4627,\n/**/\n    4626,\n/**/\n    4625,\n/**/\n    4624,\n/**/\n    4623,\n/**/\n    4622,\n/**/\n    4621,\n/**/\n    4620,\n/**/\n    4619,\n/**/\n    4618,\n/**/\n    4617,\n/**/\n    4616,\n/**/\n    4615,\n/**/\n    4614,\n/**/\n    4613,\n/**/\n    4612,\n/**/\n    4611,\n/**/\n    4610,\n/**/\n    4609,\n/**/\n    4608,\n/**/\n    4607,\n/**/\n    4606,\n/**/\n    4605,\n/**/\n    4604,\n/**/\n    4603,\n/**/\n    4602,\n/**/\n    4601,\n/**/\n    4600,\n/**/\n    4599,\n/**/\n    4598,\n/**/\n    4597,\n/**/\n    4596,\n/**/\n    4595,\n/**/\n    4594,\n/**/\n    4593,\n/**/\n    4592,\n/**/\n    4591,\n/**/\n    4590,\n/**/\n    4589,\n/**/\n    4588,\n/**/\n    4587,\n/**/\n    4586,\n/**/\n    4585,\n/**/\n    4584,\n/**/\n    4583,\n/**/\n    4582,\n/**/\n    4581,\n/**/\n    4580,\n/**/\n    4579,\n/**/\n    4578,\n/**/\n    4577,\n/**/\n    4576,\n/**/\n    4575,\n/**/\n    4574,\n/**/\n    4573,\n/**/\n    4572,\n/**/\n    4571,\n/**/\n    4570,\n/**/\n    4569,\n/**/\n    4568,\n/**/\n    4567,\n/**/\n    4566,\n/**/\n    4565,\n/**/\n    4564,\n/**/\n    4563,\n/**/\n    4562,\n/**/\n    4561,\n/**/\n    4560,\n/**/\n    4559,\n/**/\n    4558,\n/**/\n    4557,\n/**/\n    4556,\n/**/\n    4555,\n/**/\n    4554,\n/**/\n    4553,\n/**/\n    4552,\n/**/\n    4551,\n/**/\n    4550,\n/**/\n    4549,\n/**/\n    4548,\n/**/\n    4547,\n/**/\n    4546,\n/**/\n    4545,\n/**/\n    4544,\n/**/\n    4543,\n/**/\n    4542,\n/**/\n    4541,\n/**/\n    4540,\n/**/\n    4539,\n/**/\n    4538,\n/**/\n    4537,\n/**/\n    4536,\n/**/\n    4535,\n/**/\n    4534,\n/**/\n    4533,\n/**/\n    4532,\n/**/\n    4531,\n/**/\n    4530,\n/**/\n    4529,\n/**/\n    4528,\n/**/\n    4527,\n/**/\n    4526,\n/**/\n    4525,\n/**/\n    4524,\n/**/\n    4523,\n/**/\n    4522,\n/**/\n    4521,\n/**/\n    4520,\n/**/\n    4519,\n/**/\n    4518,\n/**/\n    4517,\n/**/\n    4516,\n/**/\n    4515,\n/**/\n    4514,\n/**/\n    4513,\n/**/\n    4512,\n/**/\n    4511,\n/**/\n    4510,\n/**/\n    4509,\n/**/\n    4508,\n/**/\n    4507,\n/**/\n    4506,\n/**/\n    4505,\n/**/\n    4504,\n/**/\n    4503,\n/**/\n    4502,\n/**/\n    4501,\n/**/\n    4500,\n/**/\n    4499,\n/**/\n    4498,\n/**/\n    4497,\n/**/\n    4496,\n/**/\n    4495,\n/**/\n    4494,\n/**/\n    4493,\n/**/\n    4492,\n/**/\n    4491,\n/**/\n    4490,\n/**/\n    4489,\n/**/\n    4488,\n/**/\n    4487,\n/**/\n    4486,\n/**/\n    4485,\n/**/\n    4484,\n/**/\n    4483,\n/**/\n    4482,\n/**/\n    4481,\n/**/\n    4480,\n/**/\n    4479,\n/**/\n    4478,\n/**/\n    4477,\n/**/\n    4476,\n/**/\n    4475,\n/**/\n    4474,\n/**/\n    4473,\n/**/\n    4472,\n/**/\n    4471,\n/**/\n    4470,\n/**/\n    4469,\n/**/\n    4468,\n/**/\n    4467,\n/**/\n    4466,\n/**/\n    4465,\n/**/\n    4464,\n/**/\n    4463,\n/**/\n    4462,\n/**/\n    4461,\n/**/\n    4460,\n/**/\n    4459,\n/**/\n    4458,\n/**/\n    4457,\n/**/\n    4456,\n/**/\n    4455,\n/**/\n    4454,\n/**/\n    4453,\n/**/\n    4452,\n/**/\n    4451,\n/**/\n    4450,\n/**/\n    4449,\n/**/\n    4448,\n/**/\n    4447,\n/**/\n    4446,\n/**/\n    4445,\n/**/\n    4444,\n/**/\n    4443,\n/**/\n    4442,\n/**/\n    4441,\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/spell.c", "src/testdir/test_spell_utf8.vim", "src/version.c"], "buggy_code_start_loc": [1278, 804, 736], "buggy_code_end_loc": [1491, 804, 736], "fixing_code_start_loc": [1278, 805, 737], "fixing_code_end_loc": [1495, 820, 739], "type": "CWE-416", "message": "Use After Free in GitHub repository vim/vim prior to 8.2.", "other": {"cve": {"id": "CVE-2022-2042", "sourceIdentifier": "security@huntr.dev", "published": "2022-06-10T19:15:08.813", "lastModified": "2023-05-03T12:15:40.820", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use After Free in GitHub repository vim/vim prior to 8.2."}, {"lang": "es", "value": "Un Uso de Memoria Previamente Liberada en el repositorio GitHub vim/vim versiones anteriores a 8.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:R/S:C/C:H/I:H/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 0.8, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.5072", "matchCriteriaId": "8B6CDC65-37D1-4A6A-B6C5-7B58DC5757ED"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionEndExcluding": "11.7", "matchCriteriaId": "0146DEE5-EF72-48C3-9DDD-28EA3595BDD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionStartIncluding": "12.0", "versionEndExcluding": "12.6", "matchCriteriaId": "7B7BC361-3A04-4C88-A3AE-82B9993A73A0"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2022/Oct/28", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Oct/41", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Oct/43", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Oct/45", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/2813f38e021c6e6581c0c88fcf107e41788bc835", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/8628b4cd-4055-4059-aed4-64f7fdc10eba", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}, {"url": "https://support.apple.com/kb/HT213443", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213444", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213488", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/2813f38e021c6e6581c0c88fcf107e41788bc835"}}