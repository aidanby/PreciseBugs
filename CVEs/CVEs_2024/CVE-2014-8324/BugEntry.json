{"buggy_code": [" /*\n  *  Copyright (c) 2007, 2008, Andrea Bittau <a.bittau@cs.ucl.ac.uk>\n  *\n  *  OS dependent API for using card via network.\n  *\n  *  This program is free software; you can redistribute it and/or modify\n  *  it under the terms of the GNU General Public License as published by\n  *  the Free Software Foundation; either version 2 of the License, or\n  *  (at your option) any later version.\n  *\n  *  This program is distributed in the hope that it will be useful,\n  *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  *  GNU General Public License for more details.\n  *\n  *  You should have received a copy of the GNU General Public License\n  *  along with this program; if not, write to the Free Software\n  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n  */\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <assert.h>\n#include <sys/select.h>\n#include <errno.h>\n\n#include \"osdep.h\"\n#include \"network.h\"\n\n#define QUEUE_MAX 666\n\nstruct queue {\n\tunsigned char\tq_buf[2048];\n\tint\t\tq_len;\n\n\tstruct queue\t*q_next;\n\tstruct queue\t*q_prev;\n};\n\nstruct priv_net {\n\tint\t\tpn_s;\n\tstruct queue\tpn_queue;\n\tstruct queue\tpn_queue_free;\n\tint\t\tpn_queue_len;\n};\n\nint net_send(int s, int command, void *arg, int len)\n{\n\tstruct net_hdr *pnh;\n\tchar *pktbuf;\n\tsize_t pktlen;\n\n\tpktlen = sizeof(struct net_hdr) + len;\n\n\tpktbuf = (char*)calloc(sizeof(char), pktlen);\n\tif (pktbuf == NULL) {\n\t\tperror(\"calloc\");\n\t\tgoto net_send_error;\n\t}\n\n\tpnh = (struct net_hdr*)pktbuf;\n\tpnh->nh_type = command;\n\tpnh->nh_len = htonl(len);\n\n\tmemcpy(pktbuf + sizeof(struct net_hdr), arg, len);\n\n\tfor (;;) {\n\t\tssize_t rc = send(s, pktbuf, pktlen, 0);\n\n\t\tif ((size_t)rc == pktlen)\n\t\t\tbreak;\n\n\t\tif (rc == EAGAIN || rc == EWOULDBLOCK || rc == EINTR)\n\t\t\tcontinue;\n\n\t\tif (rc == ECONNRESET)\n\t\t\tprintf(\"Connection reset while sending packet!\\n\");\n\n\t\tgoto net_send_error;\n\t}\n\n\tfree(pktbuf);\n\treturn 0;\n\nnet_send_error:\n\tfree(pktbuf);\n\treturn -1;\n}\n\nint net_read_exact(int s, void *arg, int len)\n{\n\tssize_t rc;\n\tint rlen = 0;\n\tchar *buf = (char*)arg;\n\twhile (rlen < len) {\n\t\trc = recv(s, buf, (len - rlen), 0);\n\n\t\tif (rc < 1) {\n\t\t\tif (rc == -1 && (errno == EAGAIN || errno == EINTR)) {\n\t\t\t\tusleep(100);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuf += rc;\n\t\trlen += rc;\n\t}\n\n\treturn 0;\n}\n\nint net_get(int s, void *arg, int *len)\n{\n\tstruct net_hdr nh;\n\tint plen;\n\n\tif (net_read_exact(s, &nh, sizeof(nh)) == -1)\n        {\n\t\treturn -1;\n        }\n\n\tplen = ntohl(nh.nh_len);\n\tif (!(plen <= *len))\n\t\tprintf(\"PLEN %d type %d len %d\\n\",\n\t\t\tplen, nh.nh_type, *len);\n\tassert(plen <= *len); /* XXX */\n\n\t*len = plen;\n\tif ((*len) && (net_read_exact(s, arg, *len) == -1))\n        {\n            return -1;\n        }\n\n\treturn nh.nh_type;\n}\n\nstatic void queue_del(struct queue *q)\n{\n\tq->q_prev->q_next = q->q_next;\n\tq->q_next->q_prev = q->q_prev;\n}\n\nstatic void queue_add(struct queue *head, struct queue *q)\n{\n\tstruct queue *pos = head->q_prev;\n\n\tq->q_prev = pos;\n\tq->q_next = pos->q_next;\n\tq->q_next->q_prev = q;\n\tpos->q_next = q;\n}\n\n#if 0\nstatic int queue_len(struct queue *head)\n{\n\tstruct queue *q = head->q_next;\n\tint i = 0;\n\n\twhile (q != head) {\n\t\ti++;\n\t\tq = q->q_next;\n\t}\n\n\treturn i;\n}\n#endif\n\nstatic struct queue *queue_get_slot(struct priv_net *pn)\n{\n\tstruct queue *q = pn->pn_queue_free.q_next;\n\n\tif (q != &pn->pn_queue_free) {\n\t\tqueue_del(q);\n\t\treturn q;\n\t}\n\n\tif (pn->pn_queue_len++ > QUEUE_MAX)\n\t\treturn NULL;\n\n\treturn malloc(sizeof(*q));\n}\n\nstatic void net_enque(struct priv_net *pn, void *buf, int len)\n{\n\tstruct queue *q;\n\n\tq = queue_get_slot(pn);\n\tif (!q)\n\t\treturn;\n\n\tq->q_len = len;\n\tassert((int) sizeof(q->q_buf) >= q->q_len);\n\tmemcpy(q->q_buf, buf, q->q_len);\n\tqueue_add(&pn->pn_queue, q);\n}\n\nstatic int net_get_nopacket(struct priv_net *pn, void *arg, int *len)\n{\n\tunsigned char buf[2048];\n\tint l = sizeof(buf);\n\tint c;\n\n\twhile (1) {\n\t\tl = sizeof(buf);\n\t\tc = net_get(pn->pn_s, buf, &l);\n\n\t\tif (c != NET_PACKET && c > 0)\n\t\t\tbreak;\n\n                if(c > 0)\n                    net_enque(pn, buf, l);\n\t}\n\n\tassert(l <= *len);\n\tmemcpy(arg, buf, l);\n\t*len = l;\n\n\treturn c;\n}\n\nstatic int net_cmd(struct priv_net *pn, int command, void *arg, int alen)\n{\n\tuint32_t rc;\n\tint len;\n\tint cmd;\n\n\tif (net_send(pn->pn_s, command, arg, alen) == -1)\n        {\n\t\treturn -1;\n        }\n\n\tlen = sizeof(rc);\n\tcmd = net_get_nopacket(pn, &rc, &len);\n\tif (cmd == -1)\n        {\n\t\treturn -1;\n        }\n\tassert(cmd == NET_RC);\n\tassert(len == sizeof(rc));\n\n\treturn ntohl(rc);\n}\n\nstatic int queue_get(struct priv_net *pn, void *buf, int len)\n{\n\tstruct queue *head = &pn->pn_queue;\n\tstruct queue *q = head->q_next;\n\n\tif (q == head)\n\t\treturn 0;\n\n\tassert(q->q_len <= len);\n\tmemcpy(buf, q->q_buf, q->q_len);\n\n\tqueue_del(q);\n\tqueue_add(&pn->pn_queue_free, q);\n\n\treturn q->q_len;\n}\n\nstatic int net_read(struct wif *wi, unsigned char *h80211, int len,\n\t\t    struct rx_info *ri)\n{\n\tstruct priv_net *pn = wi_priv(wi);\n\tuint32_t buf[512]; // 512 * 4 = 2048\n\tunsigned char *bufc = (unsigned char*)buf;\n\tint cmd;\n\tint sz = sizeof(*ri);\n\tint l;\n\tint ret;\n\n\t/* try queue */\n\tl = queue_get(pn, buf, sizeof(buf));\n\tif (!l) {\n\t\t/* try reading form net */\n\t\tl = sizeof(buf);\n\t\tcmd = net_get(pn->pn_s, buf, &l);\n\n\t\tif (cmd == -1)\n\t\t\treturn -1;\n\t\tif (cmd == NET_RC)\n\t\t{\n\t\t\tret = ntohl((buf[0]));\n\t\t\treturn ret;\n\t\t}\n\t\tassert(cmd == NET_PACKET);\n\t}\n\n\t/* XXX */\n\tif (ri) {\n\t\t// re-assemble 64-bit integer\n\t\tri->ri_mactime = __be64_to_cpu(((uint64_t)buf[0] << 32 || buf[1] ));\n\t\tri->ri_power = __be32_to_cpu(buf[2]);\n\t\tri->ri_noise = __be32_to_cpu(buf[3]);\n\t\tri->ri_channel = __be32_to_cpu(buf[4]);\n\t\tri->ri_rate = __be32_to_cpu(buf[5]);\n\t\tri->ri_antenna = __be32_to_cpu(buf[6]);\n\t}\n\tl -= sz;\n\tassert(l > 0);\n\tif (l > len)\n\t\tl = len;\n\tmemcpy(h80211, &bufc[sz], l);\n\n\treturn l;\n}\n\nstatic int net_get_mac(struct wif *wi, unsigned char *mac)\n{\n\tstruct priv_net *pn = wi_priv(wi);\n\tuint32_t buf[2]; // only need 6 bytes, this provides 8\n\tint cmd;\n\tint sz = 6;\n\n\tif (net_send(pn->pn_s, NET_GET_MAC, NULL, 0) == -1)\n\t\treturn -1;\n\n\tcmd = net_get_nopacket(pn, buf, &sz);\n\tif (cmd == -1)\n\t\treturn -1;\n\tif (cmd == NET_RC)\n\t\treturn ntohl(buf[0]);\n\tassert(cmd == NET_MAC);\n\tassert(sz == 6);\n\n\tmemcpy(mac, buf, 6);\n\n\treturn 0;\n}\n\nstatic int net_write(struct wif *wi, unsigned char *h80211, int len,\n\t\t     struct tx_info *ti)\n{\n\tstruct priv_net *pn = wi_priv(wi);\n\tint sz = sizeof(*ti);\n\tunsigned char buf[2048];\n\tunsigned char *ptr = buf;\n\n\t/* XXX */\n\tif (ti)\n\t\tmemcpy(ptr, ti, sz);\n\telse\n\t\tmemset(ptr, 0, sizeof(*ti));\n\n\tptr += sz;\n\tmemcpy(ptr, h80211, len);\n\tsz += len;\n\n\treturn net_cmd(pn, NET_WRITE, buf, sz);\n}\n\nstatic int net_set_channel(struct wif *wi, int chan)\n{\n\tuint32_t c = htonl(chan);\n\n\treturn net_cmd(wi_priv(wi), NET_SET_CHAN, &c, sizeof(c));\n}\n\nstatic int net_get_channel(struct wif *wi)\n{\n\tstruct priv_net *pn = wi_priv(wi);\n\n\treturn net_cmd(pn, NET_GET_CHAN, NULL, 0);\n}\n\nstatic int net_set_rate(struct wif *wi, int rate)\n{\n\tuint32_t c = htonl(rate);\n\n\treturn net_cmd(wi_priv(wi), NET_SET_RATE, &c, sizeof(c));\n}\n\nstatic int net_get_rate(struct wif *wi)\n{\n\tstruct priv_net *pn = wi_priv(wi);\n\n\treturn net_cmd(pn, NET_GET_RATE, NULL, 0);\n}\n\nstatic int net_get_monitor(struct wif *wi)\n{\n\treturn net_cmd(wi_priv(wi), NET_GET_MONITOR, NULL, 0);\n}\n\nstatic void do_net_free(struct wif *wi)\n{\n\tassert(wi->wi_priv);\n\tfree(wi->wi_priv);\n\twi->wi_priv = 0;\n\tfree(wi);\n}\n\nstatic void net_close(struct wif *wi)\n{\n\tstruct priv_net *pn = wi_priv(wi);\n\n\tclose(pn->pn_s);\n\tdo_net_free(wi);\n}\n\nstatic int get_ip_port(char *iface, char *ip, const int ipsize)\n{\n\tchar *host;\n\tchar *ptr;\n\tint port = -1;\n\tstruct in_addr addr;\n\n\thost = strdup(iface);\n\tif (!host)\n\t\treturn -1;\n\n\tptr = strchr(host, ':');\n\tif (!ptr)\n\t\tgoto out;\n\n\t*ptr++ = 0;\n\n\tif (!inet_aton(host, &addr))\n\t\tgoto out; /* XXX resolve hostname */\n\n\tassert(strlen(host) <= 15);\n\tstrncpy(ip, host, ipsize);\n\tport = atoi(ptr);\n\nout:\n\tfree(host);\n\treturn port;\n}\n\nstatic int handshake(int s)\n{\n\tif (s) {} /* XXX unused */\n\t/* XXX do a handshake */\n\treturn 0;\n}\n\nstatic int do_net_open(char *iface)\n{\n\tint s, port;\n\tchar ip[16];\n\tstruct sockaddr_in s_in;\n\n\tport = get_ip_port(iface, ip, sizeof(ip)-1);\n\tif (port == -1)\n\t\treturn -1;\n\n\ts_in.sin_family = PF_INET;\n\ts_in.sin_port = htons(port);\n\tif (!inet_aton(ip, &s_in.sin_addr))\n\t\treturn -1;\n\n\tif ((s = socket(s_in.sin_family, SOCK_STREAM, IPPROTO_TCP)) == -1)\n\t\treturn -1;\n\n\tprintf(\"Connecting to %s port %d...\\n\", ip, port);\n\n\tif (connect(s, (struct sockaddr*) &s_in, sizeof(s_in)) == -1) {\n\t\tclose(s);\n\n\t\tprintf(\"Failed to connect\\n\");\n\n\t\treturn -1;\n\t}\n\n\tif (handshake(s) == -1) {\n\t\tclose(s);\n\n\t\tprintf(\"Failed to connect - handshake failed\\n\");\n\n\t\treturn -1;\n\t}\n\n\tprintf(\"Connection successful\\n\");\n\n\treturn s;\n}\n\nstatic int net_fd(struct wif *wi)\n{\n\tstruct priv_net *pn = wi_priv(wi);\n\n\treturn pn->pn_s;\n}\n\nstruct wif *net_open(char *iface)\n{\n\tstruct wif *wi;\n\tstruct priv_net *pn;\n\tint s;\n\n\t/* setup wi struct */\n\twi = wi_alloc(sizeof(*pn));\n\tif (!wi)\n\t\treturn NULL;\n\twi->wi_read\t\t= net_read;\n\twi->wi_write\t\t= net_write;\n\twi->wi_set_channel\t= net_set_channel;\n\twi->wi_get_channel\t= net_get_channel;\n        wi->wi_set_rate    \t= net_set_rate;\n\twi->wi_get_rate    \t= net_get_rate;\n\twi->wi_close\t\t= net_close;\n\twi->wi_fd\t\t= net_fd;\n\twi->wi_get_mac\t\t= net_get_mac;\n\twi->wi_get_monitor\t= net_get_monitor;\n\n\t/* setup iface */\n\ts = do_net_open(iface);\n\tif (s == -1) {\n\t\tdo_net_free(wi);\n\t\treturn NULL;\n\t}\n\n\t/* setup private state */\n\tpn = wi_priv(wi);\n\tpn->pn_s = s;\n\tpn->pn_queue.q_next = pn->pn_queue.q_prev = &pn->pn_queue;\n\tpn->pn_queue_free.q_next = pn->pn_queue_free.q_prev\n\t\t\t\t\t= &pn->pn_queue_free;\n\n\treturn wi;\n}\n"], "fixing_code": [" /*\n  *  Copyright (c) 2007, 2008, Andrea Bittau <a.bittau@cs.ucl.ac.uk>\n  *\n  *  OS dependent API for using card via network.\n  *\n  *  This program is free software; you can redistribute it and/or modify\n  *  it under the terms of the GNU General Public License as published by\n  *  the Free Software Foundation; either version 2 of the License, or\n  *  (at your option) any later version.\n  *\n  *  This program is distributed in the hope that it will be useful,\n  *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  *  GNU General Public License for more details.\n  *\n  *  You should have received a copy of the GNU General Public License\n  *  along with this program; if not, write to the Free Software\n  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n  */\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <assert.h>\n#include <sys/select.h>\n#include <errno.h>\n\n#include \"osdep.h\"\n#include \"network.h\"\n\n#define QUEUE_MAX 666\n\nstruct queue {\n\tunsigned char\tq_buf[2048];\n\tint\t\tq_len;\n\n\tstruct queue\t*q_next;\n\tstruct queue\t*q_prev;\n};\n\nstruct priv_net {\n\tint\t\tpn_s;\n\tstruct queue\tpn_queue;\n\tstruct queue\tpn_queue_free;\n\tint\t\tpn_queue_len;\n};\n\nint net_send(int s, int command, void *arg, int len)\n{\n\tstruct net_hdr *pnh;\n\tchar *pktbuf;\n\tsize_t pktlen;\n\n\tpktlen = sizeof(struct net_hdr) + len;\n\n\tpktbuf = (char*)calloc(sizeof(char), pktlen);\n\tif (pktbuf == NULL) {\n\t\tperror(\"calloc\");\n\t\tgoto net_send_error;\n\t}\n\n\tpnh = (struct net_hdr*)pktbuf;\n\tpnh->nh_type = command;\n\tpnh->nh_len = htonl(len);\n\n\tmemcpy(pktbuf + sizeof(struct net_hdr), arg, len);\n\n\tfor (;;) {\n\t\tssize_t rc = send(s, pktbuf, pktlen, 0);\n\n\t\tif ((size_t)rc == pktlen)\n\t\t\tbreak;\n\n\t\tif (rc == EAGAIN || rc == EWOULDBLOCK || rc == EINTR)\n\t\t\tcontinue;\n\n\t\tif (rc == ECONNRESET)\n\t\t\tprintf(\"Connection reset while sending packet!\\n\");\n\n\t\tgoto net_send_error;\n\t}\n\n\tfree(pktbuf);\n\treturn 0;\n\nnet_send_error:\n\tfree(pktbuf);\n\treturn -1;\n}\n\nint net_read_exact(int s, void *arg, int len)\n{\n\tssize_t rc;\n\tint rlen = 0;\n\tchar *buf = (char*)arg;\n\twhile (rlen < len) {\n\t\trc = recv(s, buf, (len - rlen), 0);\n\n\t\tif (rc < 1) {\n\t\t\tif (rc == -1 && (errno == EAGAIN || errno == EINTR)) {\n\t\t\t\tusleep(100);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuf += rc;\n\t\trlen += rc;\n\t}\n\n\treturn 0;\n}\n\nint net_get(int s, void *arg, int *len)\n{\n\tstruct net_hdr nh;\n\tint plen;\n\n\tif (net_read_exact(s, &nh, sizeof(nh)) == -1)\n        {\n\t\treturn -1;\n        }\n\n\tplen = ntohl(nh.nh_len);\n\tif (!(plen <= *len))\n\t\tprintf(\"PLEN %d type %d len %d\\n\",\n\t\t\tplen, nh.nh_type, *len);\n\tassert(plen <= *len && plen > 0); /* XXX */\n\n\t*len = plen;\n\tif ((*len) && (net_read_exact(s, arg, *len) == -1))\n        {\n            return -1;\n        }\n\n\treturn nh.nh_type;\n}\n\nstatic void queue_del(struct queue *q)\n{\n\tq->q_prev->q_next = q->q_next;\n\tq->q_next->q_prev = q->q_prev;\n}\n\nstatic void queue_add(struct queue *head, struct queue *q)\n{\n\tstruct queue *pos = head->q_prev;\n\n\tq->q_prev = pos;\n\tq->q_next = pos->q_next;\n\tq->q_next->q_prev = q;\n\tpos->q_next = q;\n}\n\n#if 0\nstatic int queue_len(struct queue *head)\n{\n\tstruct queue *q = head->q_next;\n\tint i = 0;\n\n\twhile (q != head) {\n\t\ti++;\n\t\tq = q->q_next;\n\t}\n\n\treturn i;\n}\n#endif\n\nstatic struct queue *queue_get_slot(struct priv_net *pn)\n{\n\tstruct queue *q = pn->pn_queue_free.q_next;\n\n\tif (q != &pn->pn_queue_free) {\n\t\tqueue_del(q);\n\t\treturn q;\n\t}\n\n\tif (pn->pn_queue_len++ > QUEUE_MAX)\n\t\treturn NULL;\n\n\treturn malloc(sizeof(*q));\n}\n\nstatic void net_enque(struct priv_net *pn, void *buf, int len)\n{\n\tstruct queue *q;\n\n\tq = queue_get_slot(pn);\n\tif (!q)\n\t\treturn;\n\n\tq->q_len = len;\n\tassert((int) sizeof(q->q_buf) >= q->q_len);\n\tmemcpy(q->q_buf, buf, q->q_len);\n\tqueue_add(&pn->pn_queue, q);\n}\n\nstatic int net_get_nopacket(struct priv_net *pn, void *arg, int *len)\n{\n\tunsigned char buf[2048];\n\tint l = sizeof(buf);\n\tint c;\n\n\twhile (1) {\n\t\tl = sizeof(buf);\n\t\tc = net_get(pn->pn_s, buf, &l);\n\n\t\tif (c != NET_PACKET && c > 0)\n\t\t\tbreak;\n\n                if(c > 0)\n                    net_enque(pn, buf, l);\n\t}\n\n\tassert(l <= *len);\n\tmemcpy(arg, buf, l);\n\t*len = l;\n\n\treturn c;\n}\n\nstatic int net_cmd(struct priv_net *pn, int command, void *arg, int alen)\n{\n\tuint32_t rc;\n\tint len;\n\tint cmd;\n\n\tif (net_send(pn->pn_s, command, arg, alen) == -1)\n        {\n\t\treturn -1;\n        }\n\n\tlen = sizeof(rc);\n\tcmd = net_get_nopacket(pn, &rc, &len);\n\tif (cmd == -1)\n        {\n\t\treturn -1;\n        }\n\tassert(cmd == NET_RC);\n\tassert(len == sizeof(rc));\n\n\treturn ntohl(rc);\n}\n\nstatic int queue_get(struct priv_net *pn, void *buf, int len)\n{\n\tstruct queue *head = &pn->pn_queue;\n\tstruct queue *q = head->q_next;\n\n\tif (q == head)\n\t\treturn 0;\n\n\tassert(q->q_len <= len);\n\tmemcpy(buf, q->q_buf, q->q_len);\n\n\tqueue_del(q);\n\tqueue_add(&pn->pn_queue_free, q);\n\n\treturn q->q_len;\n}\n\nstatic int net_read(struct wif *wi, unsigned char *h80211, int len,\n\t\t    struct rx_info *ri)\n{\n\tstruct priv_net *pn = wi_priv(wi);\n\tuint32_t buf[512]; // 512 * 4 = 2048\n\tunsigned char *bufc = (unsigned char*)buf;\n\tint cmd;\n\tint sz = sizeof(*ri);\n\tint l;\n\tint ret;\n\n\t/* try queue */\n\tl = queue_get(pn, buf, sizeof(buf));\n\tif (!l) {\n\t\t/* try reading form net */\n\t\tl = sizeof(buf);\n\t\tcmd = net_get(pn->pn_s, buf, &l);\n\n\t\tif (cmd == -1)\n\t\t\treturn -1;\n\t\tif (cmd == NET_RC)\n\t\t{\n\t\t\tret = ntohl((buf[0]));\n\t\t\treturn ret;\n\t\t}\n\t\tassert(cmd == NET_PACKET);\n\t}\n\n\t/* XXX */\n\tif (ri) {\n\t\t// re-assemble 64-bit integer\n\t\tri->ri_mactime = __be64_to_cpu(((uint64_t)buf[0] << 32 || buf[1] ));\n\t\tri->ri_power = __be32_to_cpu(buf[2]);\n\t\tri->ri_noise = __be32_to_cpu(buf[3]);\n\t\tri->ri_channel = __be32_to_cpu(buf[4]);\n\t\tri->ri_rate = __be32_to_cpu(buf[5]);\n\t\tri->ri_antenna = __be32_to_cpu(buf[6]);\n\t}\n\tl -= sz;\n\tassert(l > 0);\n\tif (l > len)\n\t\tl = len;\n\tmemcpy(h80211, &bufc[sz], l);\n\n\treturn l;\n}\n\nstatic int net_get_mac(struct wif *wi, unsigned char *mac)\n{\n\tstruct priv_net *pn = wi_priv(wi);\n\tuint32_t buf[2]; // only need 6 bytes, this provides 8\n\tint cmd;\n\tint sz = 6;\n\n\tif (net_send(pn->pn_s, NET_GET_MAC, NULL, 0) == -1)\n\t\treturn -1;\n\n\tcmd = net_get_nopacket(pn, buf, &sz);\n\tif (cmd == -1)\n\t\treturn -1;\n\tif (cmd == NET_RC)\n\t\treturn ntohl(buf[0]);\n\tassert(cmd == NET_MAC);\n\tassert(sz == 6);\n\n\tmemcpy(mac, buf, 6);\n\n\treturn 0;\n}\n\nstatic int net_write(struct wif *wi, unsigned char *h80211, int len,\n\t\t     struct tx_info *ti)\n{\n\tstruct priv_net *pn = wi_priv(wi);\n\tint sz = sizeof(*ti);\n\tunsigned char buf[2048];\n\tunsigned char *ptr = buf;\n\n\t/* XXX */\n\tif (ti)\n\t\tmemcpy(ptr, ti, sz);\n\telse\n\t\tmemset(ptr, 0, sizeof(*ti));\n\n\tptr += sz;\n\tmemcpy(ptr, h80211, len);\n\tsz += len;\n\n\treturn net_cmd(pn, NET_WRITE, buf, sz);\n}\n\nstatic int net_set_channel(struct wif *wi, int chan)\n{\n\tuint32_t c = htonl(chan);\n\n\treturn net_cmd(wi_priv(wi), NET_SET_CHAN, &c, sizeof(c));\n}\n\nstatic int net_get_channel(struct wif *wi)\n{\n\tstruct priv_net *pn = wi_priv(wi);\n\n\treturn net_cmd(pn, NET_GET_CHAN, NULL, 0);\n}\n\nstatic int net_set_rate(struct wif *wi, int rate)\n{\n\tuint32_t c = htonl(rate);\n\n\treturn net_cmd(wi_priv(wi), NET_SET_RATE, &c, sizeof(c));\n}\n\nstatic int net_get_rate(struct wif *wi)\n{\n\tstruct priv_net *pn = wi_priv(wi);\n\n\treturn net_cmd(pn, NET_GET_RATE, NULL, 0);\n}\n\nstatic int net_get_monitor(struct wif *wi)\n{\n\treturn net_cmd(wi_priv(wi), NET_GET_MONITOR, NULL, 0);\n}\n\nstatic void do_net_free(struct wif *wi)\n{\n\tassert(wi->wi_priv);\n\tfree(wi->wi_priv);\n\twi->wi_priv = 0;\n\tfree(wi);\n}\n\nstatic void net_close(struct wif *wi)\n{\n\tstruct priv_net *pn = wi_priv(wi);\n\n\tclose(pn->pn_s);\n\tdo_net_free(wi);\n}\n\nstatic int get_ip_port(char *iface, char *ip, const int ipsize)\n{\n\tchar *host;\n\tchar *ptr;\n\tint port = -1;\n\tstruct in_addr addr;\n\n\thost = strdup(iface);\n\tif (!host)\n\t\treturn -1;\n\n\tptr = strchr(host, ':');\n\tif (!ptr)\n\t\tgoto out;\n\n\t*ptr++ = 0;\n\n\tif (!inet_aton(host, &addr))\n\t\tgoto out; /* XXX resolve hostname */\n\n\tassert(strlen(host) <= 15);\n\tstrncpy(ip, host, ipsize);\n\tport = atoi(ptr);\n\nout:\n\tfree(host);\n\treturn port;\n}\n\nstatic int handshake(int s)\n{\n\tif (s) {} /* XXX unused */\n\t/* XXX do a handshake */\n\treturn 0;\n}\n\nstatic int do_net_open(char *iface)\n{\n\tint s, port;\n\tchar ip[16];\n\tstruct sockaddr_in s_in;\n\n\tport = get_ip_port(iface, ip, sizeof(ip)-1);\n\tif (port == -1)\n\t\treturn -1;\n\n\ts_in.sin_family = PF_INET;\n\ts_in.sin_port = htons(port);\n\tif (!inet_aton(ip, &s_in.sin_addr))\n\t\treturn -1;\n\n\tif ((s = socket(s_in.sin_family, SOCK_STREAM, IPPROTO_TCP)) == -1)\n\t\treturn -1;\n\n\tprintf(\"Connecting to %s port %d...\\n\", ip, port);\n\n\tif (connect(s, (struct sockaddr*) &s_in, sizeof(s_in)) == -1) {\n\t\tclose(s);\n\n\t\tprintf(\"Failed to connect\\n\");\n\n\t\treturn -1;\n\t}\n\n\tif (handshake(s) == -1) {\n\t\tclose(s);\n\n\t\tprintf(\"Failed to connect - handshake failed\\n\");\n\n\t\treturn -1;\n\t}\n\n\tprintf(\"Connection successful\\n\");\n\n\treturn s;\n}\n\nstatic int net_fd(struct wif *wi)\n{\n\tstruct priv_net *pn = wi_priv(wi);\n\n\treturn pn->pn_s;\n}\n\nstruct wif *net_open(char *iface)\n{\n\tstruct wif *wi;\n\tstruct priv_net *pn;\n\tint s;\n\n\t/* setup wi struct */\n\twi = wi_alloc(sizeof(*pn));\n\tif (!wi)\n\t\treturn NULL;\n\twi->wi_read\t\t= net_read;\n\twi->wi_write\t\t= net_write;\n\twi->wi_set_channel\t= net_set_channel;\n\twi->wi_get_channel\t= net_get_channel;\n        wi->wi_set_rate    \t= net_set_rate;\n\twi->wi_get_rate    \t= net_get_rate;\n\twi->wi_close\t\t= net_close;\n\twi->wi_fd\t\t= net_fd;\n\twi->wi_get_mac\t\t= net_get_mac;\n\twi->wi_get_monitor\t= net_get_monitor;\n\n\t/* setup iface */\n\ts = do_net_open(iface);\n\tif (s == -1) {\n\t\tdo_net_free(wi);\n\t\treturn NULL;\n\t}\n\n\t/* setup private state */\n\tpn = wi_priv(wi);\n\tpn->pn_s = s;\n\tpn->pn_queue.q_next = pn->pn_queue.q_prev = &pn->pn_queue;\n\tpn->pn_queue_free.q_next = pn->pn_queue_free.q_prev\n\t\t\t\t\t= &pn->pn_queue_free;\n\n\treturn wi;\n}\n"], "filenames": ["src/osdep/network.c"], "buggy_code_start_loc": [134], "buggy_code_end_loc": [135], "fixing_code_start_loc": [134], "fixing_code_end_loc": [135], "type": "CWE-20", "message": "network.c in Aircrack-ng before 1.2 Beta 3 allows remote attackers to cause a denial of service (segmentation fault) via a response with a crafted length parameter.", "other": {"cve": {"id": "CVE-2014-8324", "sourceIdentifier": "cve@mitre.org", "published": "2017-10-17T14:29:00.290", "lastModified": "2018-10-09T19:53:50.073", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "network.c in Aircrack-ng before 1.2 Beta 3 allows remote attackers to cause a denial of service (segmentation fault) via a response with a crafted length parameter."}, {"lang": "es", "value": "network.c en Aircrack-ng en versiones anteriores a 1.2 Beta 3 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (fallo de segmentaci\u00f3n) a trav\u00e9s de una respuesta con una longitud de par\u00e1metro manipulada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:aircrack-ng:aircrack-ng:*:beta2:*:*:*:*:*:*", "versionEndIncluding": "1.2", "matchCriteriaId": "C1734B0A-A2E3-4064-A29C-FFB901C38465"}]}]}], "references": [{"url": "http://aircrack-ng.blogspot.com/2014/10/aircrack-ng-12-release-candidate-1.html", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-November/143216.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-November/143595.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-November/143606.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://packetstormsecurity.com/files/128943/Aircrack-ng-1.2-Beta-3-DoS-Code-Execution.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "http://security.gentoo.org/glsa/glsa-201411-08.xml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/archive/1/533869/100/0/threaded", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1159812", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/aircrack-ng/aircrack-ng/commit/88702a3ce4c28a973bf69023cd0312f412f6193e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/aircrack-ng/aircrack-ng/commit/88702a3ce4c28a973bf69023cd0312f412f6193e"}}