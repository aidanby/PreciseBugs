{"buggy_code": ["/*\n  SDL_ttf:  A companion library to SDL for working with TrueType (tm) fonts\n  Copyright (C) 2001-2022 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\n#include \"SDL.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n\n#include \"SDL_ttf.h\"\n\n#include <ft2build.h>\n#include FT_FREETYPE_H\n#include FT_OUTLINE_H\n#include FT_STROKER_H\n#include FT_GLYPH_H\n#include FT_TRUETYPE_IDS_H\n#include FT_IMAGE_H\n\n/* Enable rendering with color\n * Freetype may need to be compiled with FT_CONFIG_OPTION_USE_PNG */\n#if defined(FT_HAS_COLOR)\n#  define TTF_USE_COLOR 1\n#else\n#  define TTF_USE_COLOR 0\n#endif\n\n/* Enable Signed Distance Field rendering (requires latest FreeType version) */\n#if defined(FT_RASTER_FLAG_SDF)\n#  define TTF_USE_SDF 1\n#else\n#  define TTF_USE_SDF 0\n#endif\n\n#if TTF_USE_SDF\n#include FT_MODULE_H\n#endif\n\n/* Enable HarfBuzz for Complex text rendering\n * Freetype may need to be compiled with FT_CONFIG_OPTION_USE_HARFBUZZ */\n#ifndef TTF_USE_HARFBUZZ\n#  define TTF_USE_HARFBUZZ 0\n#endif\n\n#if TTF_USE_HARFBUZZ\n#include <hb.h>\n#include <hb-ft.h>\n\n/* Default configuration */\nstatic hb_direction_t g_hb_direction = HB_DIRECTION_LTR;\nstatic hb_script_t    g_hb_script = HB_SCRIPT_UNKNOWN;\n#endif\n\n/* Harfbuzz */\nint TTF_SetDirection(int direction) /* hb_direction_t */\n{\n#if TTF_USE_HARFBUZZ\n    g_hb_direction = direction;\n    return 0;\n#else\n    (void) direction;\n    return -1;\n#endif\n}\n\nint TTF_SetScript(int script) /* hb_script_t */\n{\n#if TTF_USE_HARFBUZZ\n    g_hb_script = script;\n    return 0;\n#else\n    (void) script;\n    return -1;\n#endif\n}\n\n/* Round glyph to 16 bytes width and use SSE2 instructions */\n#if defined(__SSE2__)\n#  define HAVE_SSE2_INTRINSICS 1\n#endif\n\n/* Round glyph width to 16 bytes use NEON instructions */\n#if 0 /*defined(__ARM_NEON)*/\n#  define HAVE_NEON_INTRINSICS 1\n#endif\n\n/* Round glyph width to 8 bytes */\n#define HAVE_BLIT_GLYPH_64\n\n/* Android armeabi-v7a doesn't like int64 (Maybe all other __ARM_ARCH < 7 ?),\n * un-activate it, especially if NEON isn't detected */\n#if defined(__ARM_ARCH)\n#  if __ARM_ARCH < 8\n#    if defined(HAVE_BLIT_GLYPH_64)\n#      undef HAVE_BLIT_GLYPH_64\n#    endif\n#  endif\n#endif\n\n/* Default: round glyph width to 4 bytes to copy them faster */\n#define HAVE_BLIT_GLYPH_32\n\n/* Use Duff's device to unroll loops */\n//#define USE_DUFFS_LOOP\n\n#if defined(HAVE_SSE2_INTRINSICS)\nstatic SDL_INLINE int hasSSE2()\n{\n    static int val = -1;\n    if (val != -1) {\n        return val;\n    }\n    val = SDL_HasSSE2();\n    return val;\n}\n#endif\n\n#if defined(HAVE_NEON_INTRINSICS)\nstatic SDL_INLINE int hasNEON()\n{\n    static int val = -1;\n    if (val != -1) {\n        return val;\n    }\n    val = SDL_HasNEON();\n    return val;\n}\n#endif\n\n/* FIXME: Right now we assume the gray-scale renderer Freetype is using\n   supports 256 shades of gray, but we should instead key off of num_grays\n   in the result FT_Bitmap after the FT_Render_Glyph() call. */\n#define NUM_GRAYS       256\n\n/* x offset = cos(((90.0-12)/360) * 2 * M_PI), or 12 degree angle */\n/* same value as in FT_GlyphSlot_Oblique, fixed point 16.16 */\n#define GLYPH_ITALICS  0x0366AL\n\n/* Handy routines for converting from fixed point 26.6 */\n#define FT_FLOOR(X) (((X) & -64) / 64)\n#define FT_CEIL(X)  FT_FLOOR((X) + 63)\n\n/* Handy routine for converting to fixed point 26.6 */\n#define F26Dot6(X)  ((X) << 6)\n\n/* Faster divide by 255, with same result\n * in range [0; 255]:  (x + 1   + (x >> 8)) >> 8\n * in range [-255; 0]: (x + 255 + (x >> 8)) >> 8 */\n#define DIVIDE_BY_255_SIGNED(x, sign_val)  (((x) + (sign_val) + ((x)>>8)) >> 8)\n\n/* When x positive */\n#define DIVIDE_BY_255(x)    DIVIDE_BY_255_SIGNED(x, 1)\n\n\n#define CACHED_METRICS  0x10\n#define CACHED_BITMAP   0x01\n#define CACHED_PIXMAP   0x02\n#define CACHED_COLOR    0x04\n#define CACHED_SUBPIX   0x08\n\n\ntypedef struct {\n    unsigned char *buffer; /* aligned */\n    int            left;\n    int            top;\n    int            width;\n    int            rows;\n    int            pitch;\n    int            is_color;\n} TTF_Image;\n\n/* Cached glyph information */\ntypedef struct cached_glyph {\n    int stored;\n    FT_UInt index;\n    TTF_Image bitmap;\n    TTF_Image pixmap;\n    int sz_left;\n    int sz_top;\n    int sz_width;\n    int sz_rows;\n    int advance;\n    union {\n        /* TTF_HINTING_LIGHT_SUBPIXEL (only pixmap) */\n        struct {\n            int lsb_minus_rsb;\n            int translation;\n        } subpixel;\n        /* Other hinting */\n        struct {\n            int rsb_delta;\n            int lsb_delta;\n        } kerning_smart;\n    };\n} c_glyph;\n\n/* Internal buffer to store positions computed by TTF_Size_Internal()\n * for rendered string by Render_Line() */\ntypedef struct PosBuf {\n    FT_UInt index;\n    int x;\n    int y;\n} PosBuf_t;\n\n/* The structure used to hold internal font information */\nstruct _TTF_Font {\n    /* Freetype2 maintains all sorts of useful info itself */\n    FT_Face face;\n\n    /* We'll cache these ourselves */\n    int height;\n    int ascent;\n    int descent;\n    int lineskip;\n\n    /* The font style */\n    int style;\n    int outline_val;\n\n    /* Whether kerning is desired */\n    int allow_kerning;\n    int use_kerning;\n\n    /* Extra width in glyph bounds for text styles */\n    int glyph_overhang;\n\n    /* Information in the font for underlining */\n    int line_thickness;\n    int underline_top_row;\n    int strikethrough_top_row;\n\n    /* Cache for style-transformed glyphs */\n    c_glyph cache[256];\n    FT_UInt cache_index[128];\n\n    /* We are responsible for closing the font stream */\n    SDL_RWops *src;\n    int freesrc;\n    FT_Open_Args args;\n\n    /* Internal buffer to store positions computed by TTF_Size_Internal()\n     * for rendered string by Render_Line() */\n    PosBuf_t *pos_buf;\n    Uint32 pos_len;\n    Uint32 pos_max;\n\n    /* Hinting modes */\n    int ft_load_target;\n    int render_subpixel;\n#if TTF_USE_HARFBUZZ\n    hb_font_t *hb_font;\n    hb_script_t hb_script;\n    hb_direction_t hb_direction;\n#endif\n    int render_sdf;\n};\n\n/* Tell if SDL_ttf has to handle the style */\n#define TTF_HANDLE_STYLE_BOLD(font)          ((font)->style & TTF_STYLE_BOLD)\n#define TTF_HANDLE_STYLE_ITALIC(font)        ((font)->style & TTF_STYLE_ITALIC)\n#define TTF_HANDLE_STYLE_UNDERLINE(font)     ((font)->style & TTF_STYLE_UNDERLINE)\n#define TTF_HANDLE_STYLE_STRIKETHROUGH(font) ((font)->style & TTF_STYLE_STRIKETHROUGH)\n\n/* Font styles that does not impact glyph drawing */\n#define TTF_STYLE_NO_GLYPH_CHANGE   (TTF_STYLE_UNDERLINE | TTF_STYLE_STRIKETHROUGH)\n\n/* The FreeType font engine/library */\nstatic FT_Library library = NULL;\nstatic int TTF_initialized = 0;\nstatic SDL_bool TTF_byteswapped = SDL_FALSE;\n\n#define TTF_CHECK_INITIALIZED(errval)                   \\\n    if (!TTF_initialized) {                             \\\n        TTF_SetError(\"Library not initialized\");        \\\n        return errval;                                  \\\n    }\n\n#define TTF_CHECK_POINTER(p, errval)                    \\\n    if (!(p)) {                                         \\\n        TTF_SetError(\"Passed a NULL pointer\");          \\\n        return errval;                                  \\\n    }\n\ntypedef enum {\n    RENDER_SOLID = 0,\n    RENDER_SHADED,\n    RENDER_BLENDED\n} render_mode_t;\n\ntypedef enum {\n    STR_UTF8 = 0,\n    STR_TEXT,\n    STR_UNICODE\n} str_type_t;\n\nstatic int TTF_initFontMetrics(TTF_Font *font);\n\nstatic int TTF_Size_Internal(TTF_Font *font, const char *text, str_type_t str_type,\n        int *w, int *h, int *xstart, int *ystart, int measure_width, int *extent, int *count);\n\n#define NO_MEASUREMENT  \\\n        0, NULL, NULL\n\n\nstatic SDL_Surface* TTF_Render_Internal(TTF_Font *font, const char *text, str_type_t str_type,\n        SDL_Color fg, SDL_Color bg, render_mode_t render_mode);\n\nstatic SDL_Surface* TTF_Render_Wrapped_Internal(TTF_Font *font, const char *text, str_type_t str_type,\n        SDL_Color fg, SDL_Color bg, Uint32 wrapLength, render_mode_t render_mode);\n\nstatic SDL_INLINE int Find_GlyphByIndex(TTF_Font *font, FT_UInt idx,\n        int want_bitmap, int want_pixmap, int want_color, int want_subpixel,\n        int translation, c_glyph **out_glyph, TTF_Image **out_image);\n\nstatic void Flush_Cache(TTF_Font *font);\n\n#if defined(USE_DUFFS_LOOP)\n\n/* 4-times unrolled loop */\n#define DUFFS_LOOP4(pixel_copy_increment, width)                        \\\n{ int n = (width+3)/4;                                                  \\\n    switch (width & 3) {                                                \\\n    case 0: do {    pixel_copy_increment;   /* fallthrough */           \\\n    case 3:     pixel_copy_increment;       /* fallthrough */           \\\n    case 2:     pixel_copy_increment;       /* fallthrough */           \\\n    case 1:     pixel_copy_increment;       /* fallthrough */           \\\n        } while (--n > 0);                                              \\\n    }                                                                   \\\n}\n\n#else\n\n/* Don't use Duff's device to unroll loops */\n#define DUFFS_LOOP(pixel_copy_increment, width)                         \\\n{ int n;                                                                \\\n    for ( n=width; n > 0; --n ) {                                       \\\n        pixel_copy_increment;                                           \\\n    }                                                                   \\\n}\n\n#define DUFFS_LOOP4(pixel_copy_increment, width)                        \\\n    DUFFS_LOOP(pixel_copy_increment, width)\n\n#endif\n\n\n/* Blend colored glyphs */\nstatic SDL_INLINE void BG_Blended_Color(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip, Uint8 fg_alpha)\n{\n    const Uint32 *src   = (Uint32 *)image->buffer;\n    Uint32      *dst    = destination;\n    Uint32       width  = image->width;\n    Uint32       height = image->rows;\n\n    if (fg_alpha == 0) { /* SDL_ALPHA_OPAQUE */\n        while (height--) {\n            /* *INDENT-OFF* */\n            DUFFS_LOOP4(\n                *dst++ = *src++;\n            , width);\n            /* *INDENT-ON* */\n            src = (const Uint32 *)((const Uint8 *)src + srcskip);\n            dst = (Uint32 *)((Uint8 *)dst + dstskip);\n        }\n    } else {\n        Uint32 alpha;\n        Uint32 tmp;\n\n        while (height--) {\n            /* *INDENT-OFF* */\n            DUFFS_LOOP4(\n                    tmp = *src++;\n                    alpha = tmp >> 24;\n                    tmp &= ~0xFF000000;\n                    alpha = fg_alpha * alpha;\n                    alpha =  DIVIDE_BY_255(alpha) << 24;\n                    *dst++ = tmp | alpha\n                    , width);\n            /* *INDENT-ON* */\n            src = (const Uint32 *)((const Uint8 *)src + srcskip);\n            dst = (Uint32 *)((Uint8 *)dst + dstskip);\n        }\n    }\n}\n\n#if TTF_USE_SDF\n\n/* Blended Opaque SDF */\nstatic SDL_INLINE void BG_Blended_Opaque_SDF(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip)\n{\n    const Uint8 *src    = image->buffer;\n    Uint32      *dst    = destination;\n    Uint32       width  = image->width;\n    Uint32       height = image->rows;\n\n    Uint32 s;\n    Uint32 d;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            d = *dst;\n            s = *src++ << 24;\n            if (s > d) {\n                *dst = s;\n            }\n            dst++;\n        , width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst  = (Uint32 *)((Uint8 *)dst + dstskip);\n    }\n}\n\n/* Blended non-opaque SDF */\nstatic SDL_INLINE void BG_Blended_SDF(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip, Uint8 fg_alpha)\n{\n    const Uint8 *src    = image->buffer;\n    Uint32      *dst    = destination;\n    Uint32       width  = image->width;\n    Uint32       height = image->rows;\n\n    Uint32 s;\n    Uint32 d;\n\n    Uint32 tmp;\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            d = *dst;\n            tmp = fg_alpha * (*src++);\n            s = DIVIDE_BY_255(tmp) << 24;\n            if (s > d) {\n                *dst = s;\n            }\n            dst++;\n        , width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst  = (Uint32 *)((Uint8 *)dst + dstskip);\n    }\n}\n\n#endif /* TTF_USE_SDF */\n\n/* Blended Opaque */\nstatic SDL_INLINE void BG_Blended_Opaque(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip)\n{\n    const Uint8 *src    = image->buffer;\n    Uint32      *dst    = destination;\n    Uint32       width  = image->width;\n    Uint32       height = image->rows;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            *dst++ |= *src++ << 24;\n        , width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst  = (Uint32 *)((Uint8 *)dst + dstskip);\n    }\n}\n\n/* Blended non-opaque */\nstatic SDL_INLINE void BG_Blended(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip, Uint8 fg_alpha)\n{\n    const Uint8 *src    = image->buffer;\n    Uint32      *dst    = destination;\n    Uint32       width  = image->width;\n    Uint32       height = image->rows;\n\n    Uint32 tmp;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            tmp     = fg_alpha * (*src++);\n            *dst++ |= DIVIDE_BY_255(tmp) << 24;\n        , width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst  = (Uint32 *)((Uint8 *)dst + dstskip);\n    }\n}\n\n#if defined(HAVE_BLIT_GLYPH_32) || defined(HAVE_BLIT_GLYPH_64)\nstatic SDL_INLINE void BG_Blended_Opaque_32(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip)\n{\n    const Uint8 *src    = image->buffer;\n    Uint32      *dst    = destination;\n    Uint32       width  = image->width / 4;\n    Uint32       height = image->rows;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            *dst++ |= *src++ << 24;\n            *dst++ |= *src++ << 24;\n            *dst++ |= *src++ << 24;\n            *dst++ |= *src++ << 24;\n        , width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst  = (Uint32 *)((Uint8 *)dst + dstskip);\n    }\n}\n\nstatic SDL_INLINE void BG_Blended_32(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip, Uint8 fg_alpha)\n{\n    const Uint8 *src    = image->buffer;\n    Uint32      *dst    = destination;\n    Uint32       width  = image->width / 4;\n    Uint32       height = image->rows;\n\n    Uint32 tmp0, tmp1, tmp2, tmp3;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            tmp0    = fg_alpha * (*src++);\n            tmp1    = fg_alpha * (*src++);\n            tmp2    = fg_alpha * (*src++);\n            tmp3    = fg_alpha * (*src++);\n            *dst++ |= DIVIDE_BY_255(tmp0) << 24;\n            *dst++ |= DIVIDE_BY_255(tmp1) << 24;\n            *dst++ |= DIVIDE_BY_255(tmp2) << 24;\n            *dst++ |= DIVIDE_BY_255(tmp3) << 24;\n        , width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst  = (Uint32 *)((Uint8 *)dst + dstskip);\n    }\n}\n#endif\n\n#if defined(HAVE_SSE2_INTRINSICS)\n/* Apply: alpha_table[i] = i << 24; */\nstatic SDL_INLINE void BG_Blended_Opaque_SSE(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip)\n{\n    const __m128i *src    = (__m128i *)image->buffer;\n    __m128i       *dst    = (__m128i *)destination;\n    Uint32         width  = image->width / 16;\n    Uint32         height = image->rows;\n\n    __m128i s, s0, s1, s2, s3, d0, d1, d2, d3, r0, r1, r2, r3, L, H;\n    const __m128i zero  = _mm_setzero_si128();\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            /* Read 16 Uint8 at once and put into 4 __m128i */\n            s  = _mm_loadu_si128(src);          // load unaligned\n            d0 = _mm_load_si128(dst);           // load\n            d1 = _mm_load_si128(dst + 1);       // load\n            d2 = _mm_load_si128(dst + 2);       // load\n            d3 = _mm_load_si128(dst + 3);       // load\n\n            L  = _mm_unpacklo_epi8(zero, s);\n            H  = _mm_unpackhi_epi8(zero, s);\n\n            s0 = _mm_unpacklo_epi8(zero, L);\n            s1 = _mm_unpackhi_epi8(zero, L);\n            s2 = _mm_unpacklo_epi8(zero, H);\n            s3 = _mm_unpackhi_epi8(zero, H);\n                                                // already shifted by 24\n            r0 = _mm_or_si128(d0, s0);          // or\n            r1 = _mm_or_si128(d1, s1);          // or\n            r2 = _mm_or_si128(d2, s2);          // or\n            r3 = _mm_or_si128(d3, s3);          // or\n\n            _mm_store_si128(dst, r0);           // store\n            _mm_store_si128(dst + 1, r1);       // store\n            _mm_store_si128(dst + 2, r2);       // store\n            _mm_store_si128(dst + 3, r3);       // store\n\n            dst += 4;\n            src += 1;\n        , width);\n        /* *INDENT-ON* */\n        src = (const __m128i *)((const Uint8 *)src + srcskip);\n        dst = (__m128i *)((Uint8 *)dst + dstskip);\n    }\n}\n\nstatic SDL_INLINE void BG_Blended_SSE(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip, Uint8 fg_alpha)\n{\n    const __m128i *src    = (__m128i *)image->buffer;\n    __m128i       *dst    = (__m128i *)destination;\n    Uint32         width  = image->width / 16;\n    Uint32         height = image->rows;\n\n    const __m128i alpha = _mm_set1_epi16(fg_alpha);\n    const __m128i one   = _mm_set1_epi16(1);\n    const __m128i zero  = _mm_setzero_si128();\n    __m128i s, s0, s1, s2, s3, d0, d1, d2, d3, r0, r1, r2, r3, L, H, Ls8, Hs8;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            /* Read 16 Uint8 at once and put into 4 __m128i */\n            s  = _mm_loadu_si128(src);          // load unaligned\n            d0 = _mm_load_si128(dst);           // load\n            d1 = _mm_load_si128(dst + 1);       // load\n            d2 = _mm_load_si128(dst + 2);       // load\n            d3 = _mm_load_si128(dst + 3);       // load\n\n            L  = _mm_unpacklo_epi8(s, zero);    // interleave, no shifting\n            H  = _mm_unpackhi_epi8(s, zero);    // enough room to multiply\n\n            /* Apply: alpha_table[i] = ((i * fg.a / 255) << 24; */\n            /* Divide by 255 is done as:    (x + 1 + (x >> 8)) >> 8 */\n\n            L  = _mm_mullo_epi16(L, alpha);     // x := i * fg.a\n            H  = _mm_mullo_epi16(H, alpha);\n\n            Ls8 = _mm_srli_epi16(L, 8);         // x >> 8\n            Hs8 = _mm_srli_epi16(H, 8);\n            L = _mm_add_epi16(L, one);          // x + 1\n            H = _mm_add_epi16(H, one);\n            L = _mm_add_epi16(L, Ls8);          // x + 1 + (x >> 8)\n            H = _mm_add_epi16(H, Hs8);\n            L = _mm_srli_epi16(L, 8);           // ((x + 1 + (x >> 8)) >> 8\n            H = _mm_srli_epi16(H, 8);\n\n            L = _mm_slli_epi16(L, 8);           // shift << 8, so we're prepared\n            H = _mm_slli_epi16(H, 8);           // to have final format << 24\n\n            s0 = _mm_unpacklo_epi8(zero, L);\n            s1 = _mm_unpackhi_epi8(zero, L);\n            s2 = _mm_unpacklo_epi8(zero, H);\n            s3 = _mm_unpackhi_epi8(zero, H);\n                                                // already shifted by 24\n\n            r0 = _mm_or_si128(d0, s0);          // or\n            r1 = _mm_or_si128(d1, s1);          // or\n            r2 = _mm_or_si128(d2, s2);          // or\n            r3 = _mm_or_si128(d3, s3);          // or\n\n            _mm_store_si128(dst, r0);           // store\n            _mm_store_si128(dst + 1, r1);       // store\n            _mm_store_si128(dst + 2, r2);       // store\n            _mm_store_si128(dst + 3, r3);       // store\n\n            dst += 4;\n            src += 1;\n        , width);\n        /* *INDENT-ON* */\n        src = (const __m128i *)((const Uint8 *)src + srcskip);\n        dst = (__m128i *)((Uint8 *)dst + dstskip);\n    }\n}\n#endif\n\n#if defined(HAVE_NEON_INTRINSICS)\n/* Apply: alpha_table[i] = i << 24; */\nstatic SDL_INLINE void BG_Blended_Opaque_NEON(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip)\n{\n    const Uint32 *src    = (Uint32 *)image->buffer;\n    Uint32       *dst    = destination;\n    Uint32        width  = image->width / 16;\n    Uint32        height = image->rows;\n\n    uint32x4_t s, d0, d1, d2, d3, r0, r1, r2, r3;\n    uint8x16x2_t sx, sx01, sx23;\n    uint32x4_t zero = vmovq_n_u32(0);\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            /* Read 4 Uint32 and put 16 Uint8 into uint32x4x2_t (uint8x16x2_t)\n             * takes advantage of vzipq_u8 which produces two lanes */\n\n            s   = vld1q_u32(src);               // load\n            d0  = vld1q_u32(dst);               // load\n            d1  = vld1q_u32(dst + 4);           // load\n            d2  = vld1q_u32(dst + 8);           // load\n            d3  = vld1q_u32(dst + 12);          // load\n\n            sx   = vzipq_u8(zero, s);           // interleave\n            sx01 = vzipq_u8(zero, sx.val[0]);   // interleave\n            sx23 = vzipq_u8(zero, sx.val[1]);   // interleave\n                                                // already shifted by 24\n            r0  = vorrq_u32(d0, sx01.val[0]);   // or\n            r1  = vorrq_u32(d1, sx01.val[1]);   // or\n            r2  = vorrq_u32(d2, sx23.val[0]);   // or\n            r3  = vorrq_u32(d3, sx23.val[1]);   // or\n\n            vst1q_u32(dst, r0);                 // store\n            vst1q_u32(dst + 4, r1);             // store\n            vst1q_u32(dst + 8, r2);             // store\n            vst1q_u32(dst + 12, r3);            // store\n\n            dst += 16;\n            src += 4;\n        , width);\n        /* *INDENT-ON* */\n        src = (const Uint32 *)((const Uint8 *)src + srcskip);\n        dst = (Uint32 *)((Uint8 *)dst + dstskip);\n    }\n}\n\n/* Non-opaque, computes alpha blending on the fly */\nstatic SDL_INLINE void BG_Blended_NEON(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip, Uint8 fg_alpha)\n{\n    const Uint32 *src    = (Uint32 *)image->buffer;\n    Uint32       *dst    = destination;\n    Uint32        width  = image->width / 16;\n    Uint32        height = image->rows;\n\n    uint32x4_t s, d0, d1, d2, d3, r0, r1, r2, r3;\n    uint16x8_t Ls8, Hs8;\n    uint8x16x2_t sx, sx01, sx23;\n\n    const uint16x8_t alpha = vmovq_n_u16(fg_alpha);\n    const uint16x8_t one   = vmovq_n_u16(1);\n    const uint32x4_t zero  = vmovq_n_u32(0);\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            /* Read 4 Uint32 and put 16 Uint8 into uint32x4x2_t (uint8x16x2_t)\n             * takes advantage of vzipq_u8 which produces two lanes */\n\n            s  = vld1q_u32(src);                        // load\n            d0 = vld1q_u32(dst);                        // load\n            d1 = vld1q_u32(dst + 4);                    // load\n            d2 = vld1q_u32(dst + 8);                    // load\n            d3 = vld1q_u32(dst + 12);                   // load\n\n            sx = vzipq_u8(s, zero);                     // interleave, no shifting\n                                                        // enough room to multiply\n\n            /* Apply: alpha_table[i] = ((i * fg.a / 255) << 24; */\n            /* Divide by 255 is done as:    (x + 1 + (x >> 8)) >> 8 */\n\n            sx.val[0] = vmulq_u16(sx.val[0], alpha);    // x := i * fg.a\n            sx.val[1] = vmulq_u16(sx.val[1], alpha);\n\n            Ls8 = vshrq_n_u16(sx.val[0], 8);            // x >> 8\n            Hs8 = vshrq_n_u16(sx.val[1], 8);\n\n            sx.val[0] = vaddq_u16(sx.val[0], one);      // x + 1\n            sx.val[1] = vaddq_u16(sx.val[1], one);\n\n            sx.val[0] = vaddq_u16(sx.val[0], Ls8);      // x + 1 + (x >> 8)\n            sx.val[1] = vaddq_u16(sx.val[1], Hs8);\n\n            sx.val[0] = vshrq_n_u16(sx.val[0], 8);      // ((x + 1 + (x >> 8)) >> 8\n            sx.val[1] = vshrq_n_u16(sx.val[1], 8);\n\n            sx.val[0] = vshlq_n_u16(sx.val[0], 8);      // shift << 8, so we're prepared\n            sx.val[1] = vshlq_n_u16(sx.val[1], 8);      // to have final format << 24\n\n            sx01 = vzipq_u8(zero, sx.val[0]);           // interleave\n            sx23 = vzipq_u8(zero, sx.val[1]);           // interleave\n                                                        // already shifted by 24\n\n            r0  = vorrq_u32(d0, sx01.val[0]);           // or\n            r1  = vorrq_u32(d1, sx01.val[1]);           // or\n            r2  = vorrq_u32(d2, sx23.val[0]);           // or\n            r3  = vorrq_u32(d3, sx23.val[1]);           // or\n\n            vst1q_u32(dst, r0);                         // store\n            vst1q_u32(dst + 4, r1);                     // store\n            vst1q_u32(dst + 8, r2);                     // store\n            vst1q_u32(dst + 12, r3);                    // store\n\n            dst += 16;\n            src += 4;\n        , width);\n        /* *INDENT-ON* */\n        src = (const Uint32 *)((const Uint8 *)src + srcskip);\n        dst = (Uint32 *)((Uint8 *)dst + dstskip);\n    }\n}\n#endif\n\nstatic SDL_INLINE void BG(const TTF_Image *image, Uint8 *destination, Sint32 srcskip, Uint32 dstskip)\n{\n    const Uint8 *src    = image->buffer;\n    Uint8       *dst    = destination;\n    Uint32       width  = image->width;\n    Uint32       height = image->rows;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            *dst++ |= *src++;\n        , width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\n#if defined(HAVE_BLIT_GLYPH_64)\nstatic SDL_INLINE void BG_64(const TTF_Image *image, Uint8 *destination, Sint32 srcskip, Uint32 dstskip)\n{\n    const Uint64 *src    = (Uint64 *)image->buffer;\n    Uint64       *dst    = (Uint64 *)destination;\n    Uint32        width  = image->width / 8;\n    Uint32        height = image->rows;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            *dst++ |= *src++;\n        , width);\n        /* *INDENT-ON* */\n        src = (const Uint64 *)((const Uint8 *)src + srcskip);\n        dst = (Uint64 *)((Uint8 *)dst + dstskip);\n    }\n}\n#elif defined(HAVE_BLIT_GLYPH_32)\nstatic SDL_INLINE void BG_32(const TTF_Image *image, Uint8 *destination, Sint32 srcskip, Uint32 dstskip)\n{\n    const Uint32 *src    = (Uint32 *)image->buffer;\n    Uint32       *dst    = (Uint32 *)destination;\n    Uint32        width  = image->width / 4;\n    Uint32        height = image->rows;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            *dst++ |= *src++;\n        , width);\n        /* *INDENT-ON* */\n        src = (const Uint32 *)((const Uint8 *)src + srcskip);\n        dst = (Uint32 *)((Uint8 *)dst + dstskip);\n    }\n}\n#endif\n\n#if defined(HAVE_SSE2_INTRINSICS)\nstatic SDL_INLINE void BG_SSE(const TTF_Image *image, Uint8 *destination, Sint32 srcskip, Uint32 dstskip)\n{\n    const __m128i *src    = (__m128i *)image->buffer;\n    __m128i       *dst    = (__m128i *)destination;\n    Uint32         width  = image->width / 16;\n    Uint32         height = image->rows;\n\n    __m128i s, d, r;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            s = _mm_loadu_si128(src);   // load unaligned\n            d = _mm_load_si128(dst);    // load\n            r = _mm_or_si128(d, s);     // or\n            _mm_store_si128(dst, r);    // store\n            src += 1;\n            dst += 1;\n        , width);\n        /* *INDENT-ON* */\n        src = (const __m128i *)((const Uint8 *)src + srcskip);\n        dst = (__m128i *)((Uint8 *)dst + dstskip);\n    }\n}\n#endif\n\n#if defined(HAVE_NEON_INTRINSICS)\nstatic SDL_INLINE void BG_NEON(const TTF_Image *image, Uint8 *destination, Sint32 srcskip, Uint32 dstskip)\n{\n    const Uint8 *src    = image->buffer;\n    Uint8       *dst    = destination;\n    Uint32       width  = image->width / 16;\n    Uint32       height = image->rows;\n\n    uint8x16_t s, d, r;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            s = vld1q_u8(src);  // load\n            d = vld1q_u8(dst);  // load\n            r = vorrq_u8(d, s); // or\n            vst1q_u8(dst, r);   // store\n            src += 16;\n            dst += 16;\n        , width);\n        /* *INDENT-ON* */\n        src = (const Uint8 *)((const Uint8 *)src + srcskip);\n        dst += dstskip;\n    }\n}\n#endif\n\n/* Underline and Strikethrough style. Draw a line at the given row. */\nstatic void Draw_Line(TTF_Font *font, const SDL_Surface *textbuf, int row, int line_width, int line_thickness, Uint32 color, const render_mode_t render_mode)\n{\n    int tmp    = row + line_thickness - textbuf->h;\n    Uint8 *dst = (Uint8 *)textbuf->pixels + row * textbuf->pitch;\n\n#if TTF_USE_HARFBUZZ\n    /* No Underline/Strikethrough style if direction is vertical */\n    if (font->hb_direction == HB_DIRECTION_TTB || font->hb_direction == HB_DIRECTION_BTT) {\n        return;\n    }\n#endif\n\n    /* Not needed because of \"font->height = SDL_max(font->height, bottom_row);\".\n     * But if you patch to render textshaping and break line in middle of a cluster,\n     * (which is a bad usage and a corner case), you need this to prevent out of bounds.\n     * You can get an \"ystart\" for the \"whole line\", which is different (and smaller)\n     * than the ones of the \"splitted lines\". */\n    if (tmp > 0) {\n        line_thickness -= tmp;\n    }\n\n    /* Wrapped mode with an unbroken line: 'line_width' is greater that 'textbuf->w' */\n    line_width = SDL_min(line_width, textbuf->w);\n\n    if (render_mode == RENDER_BLENDED) {\n        while (line_thickness--) {\n            SDL_memset4(dst, color, line_width);\n            dst += textbuf->pitch;\n        }\n    } else {\n        while (line_thickness--) {\n            SDL_memset(dst, color, line_width);\n            dst += textbuf->pitch;\n        }\n    }\n}\n\nstatic void clip_glyph(int *_x, int *_y, TTF_Image *image, const SDL_Surface *textbuf)\n{\n    int above_w;\n    int above_h;\n    int x = *_x;\n    int y = *_y;\n\n    int srcbpp = 1;\n    if (image->is_color) {\n        /* This isn't tested because colored image never ends up left clipped */\n        srcbpp = 4;\n    }\n\n    /* Don't go below x=0 */\n    if (x < 0) {\n        int tmp = -x;\n        x = 0;\n        image->width  -= tmp;\n        image->buffer += srcbpp * tmp;\n    }\n    /* Don't go above textbuf->w */\n    above_w = x + image->width - textbuf->w;\n    if (above_w > 0) {\n        image->width -= above_w;\n    }\n    /* Don't go below y=0 */\n    if (y < 0) {\n        int tmp = -y;\n        y = 0;\n        image->rows   -= tmp;\n        image->buffer += tmp * image->pitch;\n    }\n    /* Don't go above textbuf->h */\n    above_h = y + image->rows - textbuf->h;\n    if (above_h > 0) {\n        image->rows -= above_h;\n    }\n    /* Could be negative if (x > textbuf->w), or if (x + width < 0) */\n    image->width = SDL_max(0, image->width);\n    image->rows  = SDL_max(0, image->rows);\n\n    /* After 'image->width' clipping:\n     * Make sure 'rows' is also 0, so it doesn't break USE_DUFFS_LOOP */\n    if (image->width == 0) {\n        image->rows = 0;\n    }\n\n    *_x = x;\n    *_y = y;\n}\n\n/* Glyph width is rounded, dst addresses are aligned, src addresses are not aligned */\nstatic int Get_Alignement()\n{\n#if defined(HAVE_NEON_INTRINSICS)\n    if (hasNEON()) {\n        return 16;\n    }\n#endif\n\n#if defined(HAVE_SSE2_INTRINSICS)\n    if (hasSSE2()) {\n        return 16;\n    }\n#endif\n\n#if defined(HAVE_BLIT_GLYPH_64)\n    return 8;\n#elif defined(HAVE_BLIT_GLYPH_32)\n    return 4;\n#else\n    return 1;\n#endif\n}\n\n#ifdef __GNUC__\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-value\"\n#endif\n#define BUILD_RENDER_LINE(NAME, IS_BLENDED, IS_BLENDED_OPAQUE, WB_WP_WC, WS, BLIT_GLYPH_BLENDED_OPAQUE_OPTIM, BLIT_GLYPH_BLENDED_OPTIM, BLIT_GLYPH_OPTIM) \\\n                                                                                                                        \\\nstatic SDL_INLINE                                                                                                       \\\nint Render_Line_##NAME(TTF_Font *font, SDL_Surface *textbuf, int xstart, int ystart, Uint8 fg_alpha)                    \\\n{                                                                                                                       \\\n    const int alignment = Get_Alignement() - 1;                                                                         \\\n    const int bpp = ((IS_BLENDED) ? 4 : 1);                                                                             \\\n    unsigned int i;                                                                                                     \\\n    for (i = 0; i < font->pos_len; i++) {                                                                               \\\n        FT_UInt idx = font->pos_buf[i].index;                                                                           \\\n        int x       = font->pos_buf[i].x;                                                                               \\\n        int y       = font->pos_buf[i].y;                                                                               \\\n        TTF_Image *image;                                                                                               \\\n                                                                                                                        \\\n        if (Find_GlyphByIndex(font, idx, WB_WP_WC, WS, x & 63, NULL, &image) == 0) {                                    \\\n            int above_w, above_h;                                                                                       \\\n            Uint32 dstskip;                                                                                             \\\n            Sint32 srcskip; /* Can be negative */                                                                       \\\n            Uint8 *dst;                                                                                                 \\\n            int remainder;                                                                                              \\\n            Uint8 *saved_buffer = image->buffer;                                                                        \\\n            int saved_width = image->width;                                                                             \\\n            image->buffer += alignment;                                                                                 \\\n            /* Position updated after glyph rendering */                                                                \\\n            x = xstart + FT_FLOOR(x) + image->left;                                                                     \\\n            y = ystart + FT_FLOOR(y) - image->top;                                                                      \\\n                                                                                                                        \\\n            /* Make sure glyph is inside textbuf */                                                                     \\\n            above_w = x + image->width - textbuf->w;                                                                    \\\n            above_h = y + image->rows  - textbuf->h;                                                                    \\\n                                                                                                                        \\\n            if (x >= 0 && y >= 0 && above_w <= 0 && above_h <= 0) {                                                     \\\n                /* Most often, glyph is inside textbuf */                                                               \\\n                /* Compute dst */                                                                                       \\\n                dst  = (Uint8 *)textbuf->pixels + y * textbuf->pitch + x * bpp;                                         \\\n                /* Align dst, get remainder, shift & align glyph width */                                               \\\n                remainder = ((uintptr_t)dst & alignment) / bpp;                                                         \\\n                dst  = (Uint8 *)((uintptr_t)dst & ~alignment);                                                          \\\n                image->buffer -= remainder;                                                                             \\\n                image->width   = (image->width + remainder + alignment) & ~alignment;                                   \\\n                /* Compute srcskip, dstskip */                                                                          \\\n                srcskip = image->pitch - image->width;                                                                  \\\n                dstskip = textbuf->pitch - image->width * bpp;                                                          \\\n                /* Render glyph at (x, y) with optimized copy functions */                                              \\\n                if (!IS_BLENDED || image->is_color == 0) {                                                              \\\n                    if (IS_BLENDED_OPAQUE) {                                                                            \\\n                        BLIT_GLYPH_BLENDED_OPAQUE_OPTIM(image, (Uint32 *)dst, srcskip, dstskip);                        \\\n                    } else if (IS_BLENDED) {                                                                            \\\n                        BLIT_GLYPH_BLENDED_OPTIM(image, (Uint32 *)dst, srcskip, dstskip, fg_alpha);                     \\\n                    } else {                                                                                            \\\n                        BLIT_GLYPH_OPTIM(image, dst, srcskip, dstskip);                                                 \\\n                    }                                                                                                   \\\n                } else if (IS_BLENDED && image->is_color) {                                                             \\\n                    image->buffer = saved_buffer;                                                                       \\\n                    image->buffer += alignment;                                                                         \\\n                    image->width = saved_width;                                                                         \\\n                    dst = (Uint8 *)textbuf->pixels + y * textbuf->pitch + x * bpp;                                      \\\n                    /* Compute srcskip, dstskip */                                                                      \\\n                    srcskip = image->pitch - 4 * image->width;                                                          \\\n                    dstskip = textbuf->pitch - image->width * bpp;                                                      \\\n                    BG_Blended_Color(image, (Uint32 *)dst, srcskip, dstskip, fg_alpha);                                 \\\n                }                                                                                                       \\\n                /* restore modification */                                                                              \\\n                image->width = saved_width;                                                                             \\\n            } else {                                                                                                    \\\n                /* Modify a copy, and clip it */                                                                        \\\n                TTF_Image image_clipped = *image;                                                                       \\\n                /* Intersect image glyph at (x,y) with textbuf */                                                       \\\n                clip_glyph(&x, &y, &image_clipped, textbuf);                                                            \\\n                /* Compute dst */                                                                                       \\\n                dst = (Uint8 *)textbuf->pixels + y * textbuf->pitch + x * bpp;                                          \\\n                /* Compute srcskip, dstskip */                                                                          \\\n                srcskip = image_clipped.pitch - image_clipped.width;                                                    \\\n                dstskip = textbuf->pitch - image_clipped.width * bpp;                                                   \\\n                /* Render glyph at (x, y) */                                                                            \\\n                if (!IS_BLENDED || image->is_color == 0) {                                                              \\\n                    if (IS_BLENDED_OPAQUE) {                                                                            \\\n                        BG_Blended_Opaque(&image_clipped, (Uint32 *)dst, srcskip, dstskip);                             \\\n                    } else if (IS_BLENDED) {                                                                            \\\n                        BG_Blended(&image_clipped, (Uint32 *)dst, srcskip, dstskip, fg_alpha);                          \\\n                    } else {                                                                                            \\\n                        BG(&image_clipped, dst, srcskip, dstskip);                                                      \\\n                    }                                                                                                   \\\n                } else if (IS_BLENDED && image->is_color) {                                                             \\\n                    srcskip -= 3 * image_clipped.width;                                                                 \\\n                    BG_Blended_Color(&image_clipped, (Uint32 *)dst, srcskip, dstskip, fg_alpha);                        \\\n                }                                                                                                       \\\n            }                                                                                                           \\\n            image->buffer = saved_buffer;                                                                               \\\n        } else {                                                                                                        \\\n            return -1;                                                                                                  \\\n        }                                                                                                               \\\n    }                                                                                                                   \\\n                                                                                                                        \\\n    return 0;                                                                                                           \\\n}                                                                                                                       \\\n                                                                                                                        \\\n\n#define BITMAP  CACHED_BITMAP, 0, 0\n#define PIXMAP  0, CACHED_PIXMAP, 0\n#define COLOR   0, 0, CACHED_COLOR\n\n#define SUBPIX  CACHED_SUBPIX\n\n/* BUILD_RENDER_LINE(NAME, IS_BLENDED, IS_BLENDED_OPAQUE, WANT_BITMAP_PIXMAP_COLOR, WANT_SUBPIXEL, BLIT_GLYPH_BLENDED_OPAQUE_OPTIM, BLIT_GLYPH_BLENDED_OPTIM, BLIT_GLYPH_OPTIM) */\n\n#if defined(HAVE_SSE2_INTRINSICS)\nBUILD_RENDER_LINE(SSE_Shaded            , 0, 0, PIXMAP, 0     ,                       ,                , BG_SSE     )\nBUILD_RENDER_LINE(SSE_Blended           , 1, 0,  COLOR, 0     ,                       , BG_Blended_SSE ,            )\nBUILD_RENDER_LINE(SSE_Blended_Opaque    , 1, 1,  COLOR, 0     , BG_Blended_Opaque_SSE ,                ,            )\nBUILD_RENDER_LINE(SSE_Solid             , 0, 0, BITMAP, 0     ,                       ,                , BG_SSE     )\nBUILD_RENDER_LINE(SSE_Shaded_SP         , 0, 0, PIXMAP, SUBPIX,                       ,                , BG_SSE     )\nBUILD_RENDER_LINE(SSE_Blended_SP        , 1, 0,  COLOR, SUBPIX,                       , BG_Blended_SSE ,            )\nBUILD_RENDER_LINE(SSE_Blended_Opaque_SP , 1, 1,  COLOR, SUBPIX, BG_Blended_Opaque_SSE ,                ,            )\n#endif\n\n#if defined(HAVE_NEON_INTRINSICS)\nBUILD_RENDER_LINE(NEON_Shaded           , 0, 0, PIXMAP, 0     ,                       ,                , BG_NEON    )\nBUILD_RENDER_LINE(NEON_Blended          , 1, 0,  COLOR, 0     ,                       , BG_Blended_NEON,            )\nBUILD_RENDER_LINE(NEON_Blended_Opaque   , 1, 1,  COLOR, 0     , BG_Blended_Opaque_NEON,                ,            )\nBUILD_RENDER_LINE(NEON_Solid            , 0, 0, BITMAP, 0     ,                       ,                , BG_NEON    )\nBUILD_RENDER_LINE(NEON_Shaded_SP        , 0, 0, PIXMAP, SUBPIX,                       ,                , BG_NEON    )\nBUILD_RENDER_LINE(NEON_Blended_SP       , 1, 0,  COLOR, SUBPIX,                       , BG_Blended_NEON,            )\nBUILD_RENDER_LINE(NEON_Blended_Opaque_SP, 1, 1,  COLOR, SUBPIX, BG_Blended_Opaque_NEON,                ,            )\n#endif\n\n#if defined(HAVE_BLIT_GLYPH_64)\nBUILD_RENDER_LINE(64_Shaded             , 0, 0, PIXMAP, 0     ,                       ,                , BG_64      )\nBUILD_RENDER_LINE(64_Blended            , 1, 0,  COLOR, 0     ,                       , BG_Blended_32  ,            )\nBUILD_RENDER_LINE(64_Blended_Opaque     , 1, 1,  COLOR, 0     , BG_Blended_Opaque_32  ,                ,            )\nBUILD_RENDER_LINE(64_Solid              , 0, 0, BITMAP, 0     ,                       ,                , BG_64      )\nBUILD_RENDER_LINE(64_Shaded_SP          , 0, 0, PIXMAP, SUBPIX,                       ,                , BG_64      )\nBUILD_RENDER_LINE(64_Blended_SP         , 1, 0,  COLOR, SUBPIX,                       , BG_Blended_32  ,            )\nBUILD_RENDER_LINE(64_Blended_Opaque_SP  , 1, 1,  COLOR, SUBPIX, BG_Blended_Opaque_32  ,                ,            )\n#elif defined(HAVE_BLIT_GLYPH_32)\nBUILD_RENDER_LINE(32_Shaded             , 0, 0, PIXMAP, 0     ,                       ,                , BG_32      )\nBUILD_RENDER_LINE(32_Blended            , 1, 0,  COLOR, 0     ,                       , BG_Blended_32  ,            )\nBUILD_RENDER_LINE(32_Blended_Opaque     , 1, 1,  COLOR, 0     , BG_Blended_Opaque_32  ,                ,            )\nBUILD_RENDER_LINE(32_Solid              , 0, 0, BITMAP, 0     ,                       ,                , BG_32      )\nBUILD_RENDER_LINE(32_Shaded_SP          , 0, 0, PIXMAP, SUBPIX,                       ,                , BG_32      )\nBUILD_RENDER_LINE(32_Blended_SP         , 1, 0,  COLOR, SUBPIX,                       , BG_Blended_32  ,            )\nBUILD_RENDER_LINE(32_Blended_Opaque_SP  , 1, 1,  COLOR, SUBPIX, BG_Blended_Opaque_32  ,                ,            )\n#else\nBUILD_RENDER_LINE(8_Shaded              , 0, 0, PIXMAP, 0     ,                       ,                , BG         )\nBUILD_RENDER_LINE(8_Blended             , 1, 0,  COLOR, 0     ,                       , BG_Blended     ,            )\nBUILD_RENDER_LINE(8_Blended_Opaque      , 1, 1,  COLOR, 0     , BG_Blended_Opaque     ,                ,            )\nBUILD_RENDER_LINE(8_Solid               , 0, 0, BITMAP, 0     ,                       ,                , BG         )\nBUILD_RENDER_LINE(8_Shaded_SP           , 0, 0, PIXMAP, SUBPIX,                       ,                , BG         )\nBUILD_RENDER_LINE(8_Blended_SP          , 1, 0,  COLOR, SUBPIX,                       , BG_Blended     ,            )\nBUILD_RENDER_LINE(8_Blended_Opaque_SP   , 1, 1,  COLOR, SUBPIX, BG_Blended_Opaque     ,                ,            )\n#endif\n\n\n#if TTF_USE_SDF\nstatic int (*Render_Line_SDF_Shaded)(TTF_Font *font, SDL_Surface *textbuf, int xstart, int ystart, Uint8 fg_alpha) = NULL;\nBUILD_RENDER_LINE(SDF_Blended           , 1, 0,  COLOR, 0     ,                       , BG_Blended_SDF ,            )\nBUILD_RENDER_LINE(SDF_Blended_Opaque    , 1, 1,  COLOR, 0     , BG_Blended_Opaque_SDF ,                ,            )\nstatic int (*Render_Line_SDF_Solid)(TTF_Font *font, SDL_Surface *textbuf, int xstart, int ystart, Uint8 fg_alpha) = NULL;\nstatic int (*Render_Line_SDF_Shaded_SP)(TTF_Font *font, SDL_Surface *textbuf, int xstart, int ystart, Uint8 fg_alpha) = NULL;\nBUILD_RENDER_LINE(SDF_Blended_SP        , 1, 0,  COLOR, SUBPIX,                       , BG_Blended_SDF ,            )\nBUILD_RENDER_LINE(SDF_Blended_Opaque_SP , 1, 1,  COLOR, SUBPIX, BG_Blended_Opaque_SDF ,                ,            )\n#endif\n\n#ifdef __GNUC__\n#pragma GCC diagnostic pop\n#endif\n\nstatic SDL_INLINE int Render_Line(const render_mode_t render_mode, int subpixel, TTF_Font *font, SDL_Surface *textbuf, int xstart, int ystart, Uint8 fg_alpha)\n{\n    /* Render line (pos_buf) to textbuf at (xstart, ystart) */\n\n    /* Subpixel with RENDER_SOLID doesn't make sense. */\n    /* (and 'cached->subpixel.translation' would need to distinguish bitmap/pixmap). */\n\n    int is_opaque = (fg_alpha == SDL_ALPHA_OPAQUE);\n\n#define Call_Specific_Render_Line(NAME)                                                                     \\\n        if (render_mode == RENDER_SHADED) {                                                                 \\\n            if (subpixel == 0) {                                                                            \\\n                return Render_Line_##NAME##_Shaded(font, textbuf, xstart, ystart, 0);                       \\\n            } else {                                                                                        \\\n                return Render_Line_##NAME##_Shaded_SP(font, textbuf, xstart, ystart, 0);                    \\\n            }                                                                                               \\\n        } else if (render_mode == RENDER_BLENDED) {                                                         \\\n            if (is_opaque) {                                                                                \\\n                if (subpixel == 0) {                                                                        \\\n                    return Render_Line_##NAME##_Blended_Opaque(font, textbuf, xstart, ystart, 0);           \\\n                } else {                                                                                    \\\n                    return Render_Line_##NAME##_Blended_Opaque_SP(font, textbuf, xstart, ystart, 0);        \\\n                }                                                                                           \\\n            } else {                                                                                        \\\n                if (subpixel == 0) {                                                                        \\\n                    return Render_Line_##NAME##_Blended(font, textbuf, xstart, ystart, fg_alpha);           \\\n                } else {                                                                                    \\\n                    return Render_Line_##NAME##_Blended_SP(font, textbuf, xstart, ystart, fg_alpha);        \\\n                }                                                                                           \\\n            }                                                                                               \\\n        } else {                                                                                            \\\n            return Render_Line_##NAME##_Solid(font, textbuf, xstart, ystart, 0);                            \\\n        }\n\n#if TTF_USE_SDF\n    if (font->render_sdf && render_mode == RENDER_BLENDED) {\n        Call_Specific_Render_Line(SDF)\n    }\n#endif\n\n#if defined(HAVE_NEON_INTRINSICS)\n    if (hasNEON()) {\n        Call_Specific_Render_Line(NEON)\n    }\n#endif\n#if defined(HAVE_SSE2_INTRINSICS)\n    if (hasSSE2()) {\n        Call_Specific_Render_Line(SSE)\n    }\n#endif\n#if defined(HAVE_BLIT_GLYPH_64)\n    Call_Specific_Render_Line(64)\n#elif defined(HAVE_BLIT_GLYPH_32)\n    Call_Specific_Render_Line(32)\n#else\n    Call_Specific_Render_Line(8)\n#endif\n}\n\nstatic SDL_Surface* Create_Surface_Solid(int width, int height, SDL_Color fg, Uint32 *color)\n{\n    const int alignment = Get_Alignement() - 1;\n    SDL_Surface *textbuf;\n    Sint64 size;\n\n    /* Create a surface with memory:\n     * - pitch is rounded to alignment\n     * - adress is aligned\n     */\n    void *pixels, *ptr;\n    /* Worse case at the end of line pulling 'alignment' extra blank pixels */\n    Sint64 pitch = width + alignment;\n    pitch += alignment;\n    pitch &= ~alignment;\n    size = height * pitch + sizeof (void *) + alignment;\n    if (size < 0 || size > SDL_MAX_SINT32) {\n        /* Overflow... */\n        return NULL;\n    }\n\n    ptr = SDL_malloc((size_t)size);\n    if (ptr == NULL) {\n        return NULL;\n    }\n\n    /* address is aligned */\n    pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment);\n    ((void **)pixels)[-1] = ptr;\n\n    textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_INDEX8);\n    if (textbuf == NULL) {\n        SDL_free(ptr);\n        return NULL;\n    }\n\n    /* Let SDL handle the memory allocation */\n    textbuf->flags &= ~SDL_PREALLOC;\n    textbuf->flags |= SDL_SIMD_ALIGNED;\n\n    /* Initialize with background to 0 */\n    SDL_memset(pixels, 0, height * pitch);\n\n    /* Underline/Strikethrough color style */\n    *color = 1;\n\n    /* Fill the palette: 1 is foreground */\n    {\n        SDL_Palette *palette = textbuf->format->palette;\n        palette->colors[0].r = 255 - fg.r;\n        palette->colors[0].g = 255 - fg.g;\n        palette->colors[0].b = 255 - fg.b;\n        palette->colors[1].r = fg.r;\n        palette->colors[1].g = fg.g;\n        palette->colors[1].b = fg.b;\n        palette->colors[1].a = fg.a;\n    }\n\n    SDL_SetColorKey(textbuf, SDL_TRUE, 0);\n\n    return textbuf;\n}\n\nstatic SDL_Surface* Create_Surface_Shaded(int width, int height, SDL_Color fg, SDL_Color bg, Uint32 *color)\n{\n    const int alignment = Get_Alignement() - 1;\n    SDL_Surface *textbuf;\n    Sint64 size;\n    Uint8 bg_alpha = bg.a;\n\n    /* Create a surface with memory:\n     * - pitch is rounded to alignment\n     * - adress is aligned\n     */\n    void *pixels, *ptr;\n    /* Worse case at the end of line pulling 'alignment' extra blank pixels */\n    Sint64 pitch = width + alignment;\n    pitch += alignment;\n    pitch &= ~alignment;\n    size = height * pitch + sizeof (void *) + alignment;\n    if (size < 0 || size > SDL_MAX_SINT32) {\n        /* Overflow... */\n        return NULL;\n    }\n\n    ptr = SDL_malloc((size_t)size);\n    if (ptr == NULL) {\n        return NULL;\n    }\n\n    /* address is aligned */\n    pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment);\n    ((void **)pixels)[-1] = ptr;\n\n    textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_INDEX8);\n    if (textbuf == NULL) {\n        SDL_free(ptr);\n        return NULL;\n    }\n\n    /* Let SDL handle the memory allocation */\n    textbuf->flags &= ~SDL_PREALLOC;\n    textbuf->flags |= SDL_SIMD_ALIGNED;\n\n    /* Initialize with background to 0 */\n    SDL_memset(pixels, 0, height * pitch);\n\n    /* Underline/Strikethrough color style */\n    *color = NUM_GRAYS - 1;\n\n    /* Support alpha blending */\n    if (fg.a != SDL_ALPHA_OPAQUE || bg.a != SDL_ALPHA_OPAQUE) {\n        SDL_SetSurfaceBlendMode(textbuf, SDL_BLENDMODE_BLEND);\n\n        /* Would disturb alpha palette */\n        if (bg.a == SDL_ALPHA_OPAQUE) {\n            bg.a = 0;\n        }\n    }\n\n    /* Fill the palette with NUM_GRAYS levels of shading from bg to fg */\n    {\n        SDL_Palette *palette = textbuf->format->palette;\n        int rdiff  = fg.r - bg.r;\n        int gdiff  = fg.g - bg.g;\n        int bdiff  = fg.b - bg.b;\n        int adiff  = fg.a - bg.a;\n        int sign_r = (rdiff >= 0) ? 1 : 255;\n        int sign_g = (gdiff >= 0) ? 1 : 255;\n        int sign_b = (bdiff >= 0) ? 1 : 255;\n        int sign_a = (adiff >= 0) ? 1 : 255;\n        int i;\n\n        for (i = 0; i < NUM_GRAYS; ++i) {\n            /* Compute color[i] = (i * color_diff / 255) */\n            int tmp_r = i * rdiff;\n            int tmp_g = i * gdiff;\n            int tmp_b = i * bdiff;\n            int tmp_a = i * adiff;\n            palette->colors[i].r = (Uint8)(bg.r + DIVIDE_BY_255_SIGNED(tmp_r, sign_r));\n            palette->colors[i].g = (Uint8)(bg.g + DIVIDE_BY_255_SIGNED(tmp_g, sign_g));\n            palette->colors[i].b = (Uint8)(bg.b + DIVIDE_BY_255_SIGNED(tmp_b, sign_b));\n            palette->colors[i].a = (Uint8)(bg.a + DIVIDE_BY_255_SIGNED(tmp_a, sign_a));\n        }\n\n        /* Make sure background has the correct alpha value */\n        palette->colors[0].a = bg_alpha;\n    }\n\n    return textbuf;\n}\n\nstatic SDL_Surface *Create_Surface_Blended(int width, int height, SDL_Color fg, Uint32 *color)\n{\n    const int alignment = Get_Alignement() - 1;\n    SDL_Surface *textbuf = NULL;\n    Uint32 bgcolor;\n\n    /* Background color */\n    bgcolor = (fg.r << 16) | (fg.g << 8) | fg.b;\n\n    /* Underline/Strikethrough color style */\n    *color = bgcolor | (fg.a << 24);\n\n    /* Create the target surface if required */\n    if (width != 0) {\n        /* Create a surface with memory:\n         * - pitch is rounded to alignment\n         * - adress is aligned\n         */\n        Sint64 size;\n        void *pixels, *ptr;\n        /* Worse case at the end of line pulling 'alignment' extra blank pixels */\n        Sint64 pitch = (width + alignment) * 4;\n        pitch += alignment;\n        pitch &= ~alignment;\n        size = height * pitch + sizeof (void *) + alignment;\n        if (size < 0 || size > SDL_MAX_SINT32) {\n            /* Overflow... */\n            return NULL;\n        }\n\n        ptr = SDL_malloc((size_t)size);\n        if (ptr == NULL) {\n            return NULL;\n        }\n\n        /* address is aligned */\n        pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment);\n        ((void **)pixels)[-1] = ptr;\n\n        textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_ARGB8888);\n        if (textbuf == NULL) {\n            SDL_free(ptr);\n            return NULL;\n        }\n\n        /* Let SDL handle the memory allocation */\n        textbuf->flags &= ~SDL_PREALLOC;\n        textbuf->flags |= SDL_SIMD_ALIGNED;\n\n        /* Initialize with fg and 0 alpha */\n        SDL_memset4(pixels, bgcolor, (height * pitch) / 4);\n\n        /* Support alpha blending */\n        if (fg.a != SDL_ALPHA_OPAQUE) {\n            SDL_SetSurfaceBlendMode(textbuf, SDL_BLENDMODE_BLEND);\n        }\n    }\n\n    return textbuf;\n}\n\n/* rcg06192001 get linked library's version. */\nconst SDL_version* TTF_Linked_Version(void)\n{\n    static SDL_version linked_version;\n    SDL_TTF_VERSION(&linked_version);\n    return &linked_version;\n}\n\n/* This function tells the library whether UNICODE text is generally\n   byteswapped.  A UNICODE BOM character at the beginning of a string\n   will override this setting for that string.  */\nvoid TTF_ByteSwappedUNICODE(SDL_bool swapped)\n{\n    TTF_byteswapped = swapped;\n}\n\n#if defined(USE_FREETYPE_ERRORS)\nstatic void TTF_SetFTError(const char *msg, FT_Error error)\n{\n#undef FTERRORS_H_\n#define FT_ERRORDEF(e, v, s)    { e, s },\n#define FT_ERROR_START_LIST     {\n#define FT_ERROR_END_LIST       { 0, NULL } };\n    const struct\n    {\n      int          err_code;\n      const char  *err_msg;\n    } ft_errors[] =\n#include FT_ERRORS_H\n\n    unsigned int i;\n    const char *err_msg = NULL;\n\n    for (i = 0; i < sizeof (ft_errors) / sizeof (ft_errors[0]); ++i) {\n        if (error == ft_errors[i].err_code) {\n            err_msg = ft_errors[i].err_msg;\n            break;\n        }\n    }\n    if (!err_msg) {\n        err_msg = \"unknown FreeType error\";\n    }\n    TTF_SetError(\"%s: %s\", msg, err_msg);\n}\n#else\n#define TTF_SetFTError(msg, error)    TTF_SetError(msg)\n#endif /* USE_FREETYPE_ERRORS */\n\nint TTF_Init(void)\n{\n    int status = 0;\n\n/* Some debug to know how it gets compiled */\n#if 0\n    int duffs = 0, sse2 = 0, neon = 0, compil_sse2 = 0, compil_neon = 0;\n#  if defined(USE_DUFFS_LOOP)\n    duffs = 1;\n#  endif\n#  if defined(HAVE_SSE2_INTRINSICS)\n    sse2 = hasSSE2();\n    compil_sse2 = 1;\n#  endif\n#  if defined(HAVE_NEON_INTRINSICS)\n    neon = hasNEON();\n    compil_neon = 1;\n#  endif\n    SDL_Log(\"SDL_ttf: hasSSE2=%d hasNEON=%d alignment=%d duffs_loop=%d compil_sse2=%d compil_neon=%d\",\n            sse2, neon, Get_Alignement(), duffs, compil_sse2, compil_neon);\n\n    SDL_Log(\"Sizeof TTF_Image: %d c_glyph: %d TTF_Font: %d\", sizeof (TTF_Image), sizeof (c_glyph), sizeof (TTF_Font));\n#endif\n\n    if (!TTF_initialized) {\n        FT_Error error = FT_Init_FreeType(&library);\n        if (error) {\n            TTF_SetFTError(\"Couldn't init FreeType engine\", error);\n            status = -1;\n        }\n    }\n    if (status == 0) {\n        ++TTF_initialized;\n#if TTF_USE_SDF\n#  if 0\n        /* Set various properties of the renderers. */\n        int spread = 4;\n        int overlaps = 0;\n        FT_Property_Set( library, \"bsdf\", \"spread\", &spread);\n        FT_Property_Set( library, \"sdf\", \"spread\", &spread);\n        FT_Property_Set( library, \"sdf\", \"overlaps\", &overlaps);\n#  endif\n#endif\n    }\n    return status;\n}\n\nSDL_COMPILE_TIME_ASSERT(FT_Int, sizeof(int) == sizeof(FT_Int)); /* just in case. */\nvoid TTF_GetFreeTypeVersion(int *major, int *minor, int *patch)\n{\n    FT_Library_Version(library, major, minor, patch);\n}\n\nvoid TTF_GetHarfBuzzVersion(int *major, int *minor, int *patch)\n{\n    unsigned int hb_major = 0;\n    unsigned int hb_minor = 0;\n    unsigned int hb_micro = 0;\n\n#if TTF_USE_HARFBUZZ\n    hb_version(&hb_major, &hb_minor, &hb_micro);\n#endif\n    if (major) {\n        *major = (int)hb_major;\n    }\n    if (minor) {\n        *minor = (int)hb_minor;\n    }\n    if (patch) {\n        *patch = (int)hb_micro;\n    }\n}\n\nstatic unsigned long RWread(\n    FT_Stream stream,\n    unsigned long offset,\n    unsigned char *buffer,\n    unsigned long count\n)\n{\n    SDL_RWops *src;\n\n    src = (SDL_RWops *)stream->descriptor.pointer;\n    SDL_RWseek(src, (int)offset, RW_SEEK_SET);\n    if (count == 0) {\n        return 0;\n    }\n    return (unsigned long)SDL_RWread(src, buffer, 1, (int)count);\n}\n\nTTF_Font* TTF_OpenFontIndexDPIRW(SDL_RWops *src, int freesrc, int ptsize, long index, unsigned int hdpi, unsigned int vdpi)\n{\n    TTF_Font *font;\n    FT_Error error;\n    FT_Face face;\n    FT_Stream stream;\n    FT_CharMap found;\n    Sint64 position;\n    int i;\n\n    if (!TTF_initialized) {\n        TTF_SetError(\"Library not initialized\");\n        if (src && freesrc) {\n            SDL_RWclose(src);\n        }\n        return NULL;\n    }\n\n    if (!src) {\n        TTF_SetError(\"Passed a NULL font source\");\n        return NULL;\n    }\n\n    /* Check to make sure we can seek in this stream */\n    position = SDL_RWtell(src);\n    if (position < 0) {\n        TTF_SetError(\"Can't seek in stream\");\n        if (freesrc) {\n            SDL_RWclose(src);\n        }\n        return NULL;\n    }\n\n    font = (TTF_Font *)SDL_malloc(sizeof (*font));\n    if (font == NULL) {\n        TTF_SetError(\"Out of memory\");\n        if (freesrc) {\n            SDL_RWclose(src);\n        }\n        return NULL;\n    }\n    SDL_memset(font, 0, sizeof (*font));\n\n    font->src = src;\n    font->freesrc = freesrc;\n\n    stream = (FT_Stream)SDL_malloc(sizeof (*stream));\n    if (stream == NULL) {\n        TTF_SetError(\"Out of memory\");\n        TTF_CloseFont(font);\n        return NULL;\n    }\n    SDL_memset(stream, 0, sizeof (*stream));\n\n    stream->read = RWread;\n    stream->descriptor.pointer = src;\n    stream->pos = (unsigned long)position;\n    stream->size = (unsigned long)(SDL_RWsize(src) - position);\n\n    font->args.flags = FT_OPEN_STREAM;\n    font->args.stream = stream;\n\n    error = FT_Open_Face(library, &font->args, index, &font->face);\n    if (error || font->face == NULL) {\n        TTF_SetFTError(\"Couldn't load font file\", error);\n        TTF_CloseFont(font);\n        return NULL;\n    }\n    face = font->face;\n\n    /* Set charmap for loaded font */\n    found = 0;\n#if 0 /* Font debug code */\n    for (i = 0; i < face->num_charmaps; i++) {\n        FT_CharMap charmap = face->charmaps[i];\n        SDL_Log(\"Found charmap: platform id %d, encoding id %d\", charmap->platform_id, charmap->encoding_id);\n    }\n#endif\n    if (!found) {\n        for (i = 0; i < face->num_charmaps; i++) {\n            FT_CharMap charmap = face->charmaps[i];\n            if (charmap->platform_id == 3 && charmap->encoding_id == 10) { /* UCS-4 Unicode */\n                found = charmap;\n                break;\n            }\n        }\n    }\n    if (!found) {\n        for (i = 0; i < face->num_charmaps; i++) {\n            FT_CharMap charmap = face->charmaps[i];\n            if ((charmap->platform_id == 3 && charmap->encoding_id == 1) /* Windows Unicode */\n             || (charmap->platform_id == 3 && charmap->encoding_id == 0) /* Windows Symbol */\n             || (charmap->platform_id == 2 && charmap->encoding_id == 1) /* ISO Unicode */\n             || (charmap->platform_id == 0)) { /* Apple Unicode */\n                found = charmap;\n                break;\n            }\n        }\n    }\n    if (found) {\n        /* If this fails, continue using the default charmap */\n        FT_Set_Charmap(face, found);\n    }\n\n    /* Set the default font style */\n    font->style = TTF_STYLE_NORMAL;\n    font->outline_val = 0;\n    font->ft_load_target = FT_LOAD_TARGET_NORMAL;\n    TTF_SetFontKerning(font, 1);\n\n    font->pos_len = 0;\n    font->pos_max = 16;\n    font->pos_buf = (PosBuf_t *)SDL_malloc(font->pos_max * sizeof (font->pos_buf[0]));\n    if (! font->pos_buf) {\n        TTF_SetError(\"Out of memory\");\n        TTF_CloseFont(font);\n        return NULL;\n    }\n\n#if TTF_USE_HARFBUZZ\n    font->hb_font = hb_ft_font_create(face, NULL);\n    if (font->hb_font == NULL) {\n        TTF_SetError(\"Cannot create harfbuzz font\");\n        TTF_CloseFont(font);\n        return NULL;\n    }\n\n    /* Default load-flags of hb_ft_font_create is no-hinting.\n     * So unless you call hb_ft_font_set_load_flags to match what flags you use for rendering,\n     * you will get mismatching advances and raster. */\n    hb_ft_font_set_load_flags(font->hb_font, FT_LOAD_DEFAULT | font->ft_load_target);\n\n    /* Default value script / direction */\n    TTF_SetFontScript(font, g_hb_script);\n    TTF_SetFontDirection(font, g_hb_direction);\n#endif\n\n    if (TTF_SetFontSizeDPI(font, ptsize, hdpi, vdpi) < 0) {\n        TTF_SetFTError(\"Couldn't set font size\", error);\n        TTF_CloseFont(font);\n        return NULL;\n    }\n    return font;\n}\n\nint TTF_SetFontSizeDPI(TTF_Font *font, int ptsize, unsigned int hdpi, unsigned int vdpi)\n{\n    FT_Face face = font->face;\n    FT_Error error;\n\n    /* Make sure that our font face is scalable (global metrics) */\n    if (FT_IS_SCALABLE(face)) {\n        /* Set the character size using the provided DPI.  If a zero DPI\n         * is provided, then the other DPI setting will be used.  If both\n         * are zero, then Freetype's default 72 DPI will be used.  */\n        error = FT_Set_Char_Size(face, 0, ptsize * 64, hdpi, vdpi);\n        if (error) {\n            TTF_SetFTError(\"Couldn't set font size\", error);\n            return -1;\n        }\n    } else {\n        /* Non-scalable font case.  ptsize determines which family\n         * or series of fonts to grab from the non-scalable format.\n         * It is not the point size of the font.  */\n        if (face->num_fixed_sizes <= 0) {\n            TTF_SetError(\"Couldn't select size : no num_fixed_sizes\");\n            return -1;\n        }\n\n        /* within [0; num_fixed_sizes - 1] */\n        ptsize = SDL_max(ptsize, 0);\n        ptsize = SDL_min(ptsize, face->num_fixed_sizes - 1);\n\n        error = FT_Select_Size(face, ptsize);\n        if (error) {\n            TTF_SetFTError(\"Couldn't select size\", error);\n            return -1;\n        }\n    }\n\n    if (TTF_initFontMetrics(font) < 0) {\n        TTF_SetError(\"Cannot initialize metrics\");\n        return -1;\n    }\n\n    Flush_Cache(font);\n\n#if TTF_USE_HARFBUZZ\n    /* Call when size or variations settings on underlying FT_Face change. */\n    hb_ft_font_changed(font->hb_font);\n#endif\n\n    return 0;\n}\n\nint TTF_SetFontSize(TTF_Font *font, int ptsize)\n{\n    return TTF_SetFontSizeDPI(font, ptsize, 0, 0);\n}\n\n/* Update font parameter depending on a style change */\nstatic int TTF_initFontMetrics(TTF_Font *font)\n{\n    FT_Face face = font->face;\n    int underline_offset;\n\n    /* Make sure that our font face is scalable (global metrics) */\n    if (FT_IS_SCALABLE(face)) {\n        /* Get the scalable font metrics for this font */\n        FT_Fixed scale       = face->size->metrics.y_scale;\n        font->ascent         = FT_CEIL(FT_MulFix(face->ascender, scale));\n        font->descent        = FT_CEIL(FT_MulFix(face->descender, scale));\n        font->height         = FT_CEIL(FT_MulFix(face->ascender - face->descender, scale));\n        font->lineskip       = FT_CEIL(FT_MulFix(face->height, scale));\n        underline_offset     = FT_FLOOR(FT_MulFix(face->underline_position, scale));\n        font->line_thickness = FT_FLOOR(FT_MulFix(face->underline_thickness, scale));\n    } else {\n        /* Get the font metrics for this font, for the selected size */\n        font->ascent         = FT_CEIL(face->size->metrics.ascender);\n        font->descent        = FT_CEIL(face->size->metrics.descender);\n        font->height         = FT_CEIL(face->size->metrics.height);\n        font->lineskip       = FT_CEIL(face->size->metrics.height);\n        /* face->underline_position and face->underline_height are only\n         * relevant for scalable formats (see freetype.h FT_FaceRec) */\n        underline_offset     = font->descent / 2;\n        font->line_thickness = 1;\n    }\n\n    if (font->line_thickness < 1) {\n        font->line_thickness = 1;\n    }\n\n    font->underline_top_row     = font->ascent - underline_offset - 1;\n    font->strikethrough_top_row = font->height / 2;\n\n    /* Adjust OutlineStyle, only for scalable fonts */\n    /* TTF_Size(): increase w and h by 2 * outline_val, translate positionning by 1 * outline_val */\n    if (font->outline_val > 0) {\n        int fo = font->outline_val;\n        font->line_thickness        += 2 * fo;\n        font->underline_top_row     -= fo;\n        font->strikethrough_top_row -= fo;\n    }\n\n    /* Robustness: no negative values allowed */\n    font->underline_top_row     = SDL_max(0, font->underline_top_row);\n    font->strikethrough_top_row = SDL_max(0, font->strikethrough_top_row);\n\n    /* Update height according to the needs of the underline style */\n    if (TTF_HANDLE_STYLE_UNDERLINE(font)) {\n        int bottom_row = font->underline_top_row + font->line_thickness;\n        font->height = SDL_max(font->height, bottom_row);\n    }\n    /* Update height according to the needs of the strikethrough style */\n    if (TTF_HANDLE_STYLE_STRIKETHROUGH(font)) {\n        int bottom_row = font->strikethrough_top_row + font->line_thickness;\n        font->height = SDL_max(font->height, bottom_row);\n    }\n\n#if defined(DEBUG_FONTS)\n    SDL_Log(\"Font metrics:\");\n    SDL_Log(\"ascent = %d, descent = %d\", font->ascent, font->descent);\n    SDL_Log(\"height = %d, lineskip = %d\", font->height, font->lineskip);\n    SDL_Log(\"underline_offset = %d, line_thickness = %d\", underline_offset, font->line_thickness);\n    SDL_Log(\"underline_top_row = %d, strikethrough_top_row = %d\", font->underline_top_row, font->strikethrough_top_row);\n    SDL_Log(\"scalable=%d fixed_sizes=%d\", FT_IS_SCALABLE(face), FT_HAS_FIXED_SIZES(face));\n#endif\n\n    font->glyph_overhang = face->size->metrics.y_ppem / 10;\n\n    return 0;\n}\n\nTTF_Font* TTF_OpenFontDPIRW( SDL_RWops *src, int freesrc, int ptsize, unsigned int hdpi, unsigned int vdpi )\n{\n    return TTF_OpenFontIndexDPIRW(src, freesrc, ptsize, 0, hdpi, vdpi);\n}\n\nTTF_Font* TTF_OpenFontIndexRW( SDL_RWops *src, int freesrc, int ptsize, long index )\n{\n    return TTF_OpenFontIndexDPIRW(src, freesrc, ptsize, index, 0, 0);\n}\n\nTTF_Font* TTF_OpenFontIndexDPI( const char *file, int ptsize, long index, unsigned int hdpi, unsigned int vdpi )\n{\n    SDL_RWops *rw = SDL_RWFromFile(file, \"rb\");\n    if ( rw == NULL ) {\n        return NULL;\n    }\n    return TTF_OpenFontIndexDPIRW(rw, 1, ptsize, index, hdpi, vdpi);\n}\n\nTTF_Font* TTF_OpenFontRW(SDL_RWops *src, int freesrc, int ptsize)\n{\n    return TTF_OpenFontIndexRW(src, freesrc, ptsize, 0);\n}\n\nTTF_Font* TTF_OpenFontDPI(const char *file, int ptsize, unsigned int hdpi, unsigned int vdpi)\n{\n    return TTF_OpenFontIndexDPI(file, ptsize, 0, hdpi, vdpi);\n}\n\nTTF_Font* TTF_OpenFontIndex(const char *file, int ptsize, long index)\n{\n    return TTF_OpenFontIndexDPI(file, ptsize, index, 0, 0);\n}\n\nTTF_Font* TTF_OpenFont(const char *file, int ptsize)\n{\n    return TTF_OpenFontIndex(file, ptsize, 0);\n}\n\nstatic void Flush_Glyph_Image(TTF_Image *image) {\n    if (image->buffer) {\n        SDL_free(image->buffer);\n        image->buffer = NULL;\n    }\n}\n\nstatic void Flush_Glyph(c_glyph *glyph)\n{\n    glyph->stored = 0;\n    glyph->index = 0;\n    Flush_Glyph_Image(&glyph->pixmap);\n    Flush_Glyph_Image(&glyph->bitmap);\n}\n\nstatic void Flush_Cache(TTF_Font *font)\n{\n    int i;\n    int size = sizeof (font->cache) / sizeof (font->cache[0]);\n\n    for (i = 0; i < size; ++i) {\n        if (font->cache[i].stored) {\n            Flush_Glyph(&font->cache[i]);\n        }\n    }\n}\n\nstatic FT_Error Load_Glyph(TTF_Font *font, c_glyph *cached, int want, int translation)\n{\n    const int alignment = Get_Alignement() - 1;\n    FT_GlyphSlot slot;\n    FT_Error error;\n\n    int ft_load = FT_LOAD_DEFAULT | font->ft_load_target;\n\n#if TTF_USE_COLOR\n    if (want & CACHED_COLOR) {\n        ft_load |= FT_LOAD_COLOR;\n    }\n#endif\n\n    error = FT_Load_Glyph(font->face, cached->index, ft_load);\n    if (error) {\n        goto ft_failure;\n    }\n\n    /* Get our glyph shortcut */\n    slot = font->face->glyph;\n\n    /* Get the glyph metrics, always needed */\n    if (cached->stored == 0) {\n        cached->sz_left  = slot->bitmap_left;\n        cached->sz_top   = slot->bitmap_top;\n        cached->sz_rows  = slot->bitmap.rows;\n        cached->sz_width = slot->bitmap.width;\n\n        /* Current version of freetype is 2.9.1, but on older freetype (2.8.1) this can be 0.\n         * Try to get them from 'FT_Glyph_Metrics' */\n        if (cached->sz_left == 0 && cached->sz_top == 0 && cached->sz_rows == 0 && cached->sz_width == 0) {\n            FT_Glyph_Metrics *metrics = &slot->metrics;\n            if (metrics) {\n                int minx = FT_FLOOR(metrics->horiBearingX);\n                int maxx = FT_CEIL(metrics->horiBearingX + metrics->width);\n                int maxy = FT_FLOOR(metrics->horiBearingY);\n                int miny = maxy - FT_CEIL(metrics->height);\n\n                cached->sz_left  = minx;\n                cached->sz_top   = maxy;\n                cached->sz_rows  = maxy - miny;\n                cached->sz_width = maxx - minx;\n            }\n        }\n\n        /* All FP 26.6 are 'long' but 'int' should be engouh */\n        cached->advance  = (int)slot->metrics.horiAdvance; /* FP 26.6 */\n\n        if (font->render_subpixel == 0) {\n            /* FT KERNING_MODE_SMART */\n            cached->kerning_smart.rsb_delta = (int)slot->rsb_delta; /* FP 26.6 */\n            cached->kerning_smart.lsb_delta = (int)slot->lsb_delta; /* FP 26.6 */\n        } else {\n            /* FT LCD_MODE_LIGHT_SUBPIXEL */\n            cached->subpixel.lsb_minus_rsb  = (int)(slot->lsb_delta - slot->rsb_delta); /* FP 26.6 */\n            cached->subpixel.translation    = 0; /* FP 26.6 */\n        }\n\n#if defined(DEBUG_FONTS)\n        SDL_Log(\"Index=%d sz_left=%d sz_top=%d sz_width=%d sz_rows=%d advance=%d is_outline=%d is_bitmap=%d\",\n                cached->index, cached->sz_left, cached->sz_top, cached->sz_width, cached->sz_rows, cached->advance,\n                slot->format == FT_GLYPH_FORMAT_OUTLINE, slot->format == FT_GLYPH_FORMAT_BITMAP);\n#endif\n\n        /* Adjust for bold text */\n        if (TTF_HANDLE_STYLE_BOLD(font)) {\n            cached->sz_width += font->glyph_overhang;\n            cached->advance  += F26Dot6(font->glyph_overhang);\n        }\n\n        /* Adjust for italic text */\n        if (TTF_HANDLE_STYLE_ITALIC(font) && slot->format == FT_GLYPH_FORMAT_OUTLINE) {\n            cached->sz_width += (GLYPH_ITALICS * font->height) >> 16;\n        }\n\n        /* Adjust for subpixel */\n        if (font->render_subpixel) {\n            cached->sz_width += 1;\n        }\n\n        /* Adjust for SDF */\n        if (font->render_sdf) {\n            /* Default 'spread' property */\n            cached->sz_width += 2 * 8;\n            cached->sz_rows  += 2 * 8;\n        }\n\n\n        cached->stored |= CACHED_METRICS;\n    }\n\n    if (((want & CACHED_BITMAP) && !(cached->stored & CACHED_BITMAP)) ||\n        ((want & CACHED_PIXMAP) && !(cached->stored & CACHED_PIXMAP)) ||\n        ((want & CACHED_COLOR) && !(cached->stored & CACHED_COLOR)) ||\n         (want & CACHED_SUBPIX)\n       ) {\n        const int  mono  = (want & CACHED_BITMAP);\n        TTF_Image *dst   = (mono ? &cached->bitmap : &cached->pixmap);\n        FT_Glyph   glyph = NULL;\n        FT_Bitmap *src;\n        FT_Render_Mode ft_render_mode;\n\n        if (mono) {\n            ft_render_mode = FT_RENDER_MODE_MONO;\n        } else {\n            ft_render_mode = FT_RENDER_MODE_NORMAL;\n#if TTF_USE_SDF\n            if ((want & CACHED_COLOR) && font->render_sdf) {\n                ft_render_mode = FT_RENDER_MODE_SDF;\n            }\n#endif\n        }\n\n        /* Subpixel translation, flush previous datas */\n        if (want & CACHED_SUBPIX) {\n            Flush_Glyph_Image(&cached->pixmap);\n            FT_Outline_Translate(&slot->outline, translation, 0 );\n            cached->subpixel.translation = translation;\n        }\n\n        /* Handle the italic style, only for scalable fonts */\n        if (TTF_HANDLE_STYLE_ITALIC(font) && slot->format == FT_GLYPH_FORMAT_OUTLINE) {\n            FT_Matrix shear;\n            shear.xx = 1 << 16;\n            shear.xy = GLYPH_ITALICS;\n            shear.yx = 0;\n            shear.yy = 1 << 16;\n            FT_Outline_Transform(&slot->outline, &shear);\n        }\n\n        /* Render as outline */\n        if ((font->outline_val > 0 && slot->format == FT_GLYPH_FORMAT_OUTLINE)\n            || slot->format == FT_GLYPH_FORMAT_BITMAP) {\n\n            FT_BitmapGlyph bitmap_glyph;\n\n            error = FT_Get_Glyph(slot, &glyph);\n            if (error) {\n                goto ft_failure;\n            }\n\n            if (font->outline_val > 0) {\n                FT_Stroker stroker;\n                error = FT_Stroker_New(library, &stroker);\n                if (error) {\n                    goto ft_failure;\n                }\n                FT_Stroker_Set(stroker, font->outline_val * 64, FT_STROKER_LINECAP_ROUND, FT_STROKER_LINEJOIN_ROUND, 0);\n                FT_Glyph_Stroke(&glyph, stroker, 1 /* delete the original glyph */);\n                FT_Stroker_Done(stroker);\n            }\n\n            /* Render the glyph */\n            error = FT_Glyph_To_Bitmap(&glyph, ft_render_mode, 0, 1);\n            if (error) {\n                FT_Done_Glyph(glyph);\n                goto ft_failure;\n            }\n\n            /* Access bitmap content by typecasting */\n            bitmap_glyph = (FT_BitmapGlyph) glyph;\n            src          = &bitmap_glyph->bitmap;\n\n            /* Get new metrics, from bitmap */\n            dst->left   = bitmap_glyph->left;\n            dst->top    = bitmap_glyph->top;\n        } else {\n            /* Render the glyph */\n            error = FT_Render_Glyph(slot, ft_render_mode);\n            if (error) {\n                goto ft_failure;\n            }\n\n            /* Access bitmap from slot */\n            src         = &slot->bitmap;\n\n            /* Get new metrics, from slot */\n            dst->left   = slot->bitmap_left;\n            dst->top    = slot->bitmap_top;\n        }\n\n        /* Common metrics */\n        dst->width  = src->width;\n        dst->rows   = src->rows;\n        dst->buffer = NULL;\n\n        /* FT can make small size glyph of 'width == 0', and 'rows != 0'.\n         * Make sure 'rows' is also 0, so it doesn't break USE_DUFFS_LOOP */\n        if (dst->width == 0) {\n            dst->rows = 0;\n        }\n\n        /* Adjust for bold text */\n        if (TTF_HANDLE_STYLE_BOLD(font)) {\n            dst->width += font->glyph_overhang;\n        }\n\n        /* Compute pitch: glyph is padded right to be able to read an 'aligned' size expanding on the right */\n        dst->pitch = dst->width + alignment;\n#if TTF_USE_COLOR\n        if (src->pixel_mode == FT_PIXEL_MODE_BGRA) {\n            dst->pitch += 3 * dst->width;\n        }\n#endif\n\n        if (dst->rows != 0) {\n            unsigned int i;\n\n            /* Glyph buffer is NOT aligned,\n             * Extra width so it can read an 'aligned' size expanding on the left */\n            dst->buffer = (unsigned char *)SDL_malloc(alignment + dst->pitch * dst->rows);\n\n            if (!dst->buffer) {\n                error = FT_Err_Out_Of_Memory;\n                goto ft_failure;\n            }\n\n            /* Memset */\n            SDL_memset(dst->buffer, 0, alignment + dst->pitch * dst->rows);\n\n            /* Shift, so that the glyph is decoded centered */\n            dst->buffer += alignment;\n\n            /* FT_Render_Glyph() and .fon fonts always generate a two-color (black and white)\n             * glyphslot surface, even when rendered in FT_RENDER_MODE_NORMAL. */\n            /* FT_IS_SCALABLE() means that the face contains outline glyphs, but does not imply\n             * that outline is rendered as 8-bit grayscale, because embedded bitmap/graymap is\n             * preferred (see FT_LOAD_DEFAULT section of FreeType2 API Reference).\n             * FT_Render_Glyph() canreturn two-color bitmap or 4/16/256 color graymap\n             * according to the format of embedded bitmap/graymap. */\n            for (i = 0; i < (unsigned int)src->rows; i++) {\n                unsigned char *srcp = src->buffer + i * src->pitch;\n                unsigned char *dstp = dst->buffer + i * dst->pitch;\n                unsigned int k, quotient, remainder;\n\n                /* Decode exactly the needed size from src->width */\n                if (src->pixel_mode == FT_PIXEL_MODE_MONO) {\n                    quotient  = src->width / 8;\n                    remainder = src->width & 0x7;\n                } else if (src->pixel_mode == FT_PIXEL_MODE_GRAY2) {\n                    quotient  = src->width / 4;\n                    remainder = src->width & 0x3;\n                } else if (src->pixel_mode == FT_PIXEL_MODE_GRAY4) {\n                    quotient  = src->width / 2;\n                    remainder = src->width & 0x1;\n#if TTF_USE_COLOR\n                } else if (src->pixel_mode == FT_PIXEL_MODE_BGRA) {\n                    quotient  = src->width;\n                    remainder = 0;\n#endif\n                } else {\n                    quotient  = src->width;\n                    remainder = 0;\n                }\n\n/* FT_RENDER_MODE_MONO and src->pixel_mode MONO */\n#ifdef _WIN32\n#pragma warning(push, 1)\n#pragma warning(disable:4127)\n#endif\n#define MONO_MONO(K_MAX)                                                    \\\n                if ((K_MAX)) {                                              \\\n                    unsigned char c = *srcp++;                              \\\n                    for (k = 0; k < (K_MAX); ++k) {                         \\\n                        *dstp++ = (c & 0x80) >> 7;                          \\\n                        c <<= 1;                                            \\\n                    }                                                       \\\n                }\n\n/* FT_RENDER_MODE_MONO and src->pixel_mode GRAY2 */\n#define MONO_GRAY2(K_MAX)                                                   \\\n                if ((K_MAX)) {                                              \\\n                    unsigned char c = *srcp++;                              \\\n                    for (k = 0; k < (K_MAX); ++k) {                         \\\n                        *dstp++ = (((c&0xA0) >> 6) >= 0x2) ? 1 : 0;         \\\n                        c <<= 2;                                            \\\n                    }                                                       \\\n                }\n\n/* FT_RENDER_MODE_MONO and src->pixel_mode GRAY4 */\n#define MONO_GRAY4(K_MAX)                                                   \\\n                if ((K_MAX)) {                                              \\\n                    unsigned char c = *srcp++;                              \\\n                    for (k = 0; k < (K_MAX); ++k) {                         \\\n                        *dstp++ = (((c&0xF0) >> 4) >= 0x8) ? 1 : 0;         \\\n                        c <<= 4;                                            \\\n                    }                                                       \\\n                }\n\n/* FT_RENDER_MODE_NORMAL and src->pixel_mode MONO */\n#define NORMAL_MONO(K_MAX)                                                  \\\n                if ((K_MAX)) {                                              \\\n                    unsigned char c = *srcp++;                              \\\n                    for (k = 0; k < (K_MAX); ++k) {                         \\\n                        if ((c&0x80) >> 7) {                                \\\n                            *dstp++ = NUM_GRAYS - 1;                        \\\n                        } else {                                            \\\n                            *dstp++ = 0x00;                                 \\\n                        }                                                   \\\n                        c <<= 1;                                            \\\n                    }                                                       \\\n                }\n\n/* FT_RENDER_MODE_NORMAL and src->pixel_mode GRAY2 */\n#define NORMAL_GRAY2(K_MAX)                                                 \\\n                if ((K_MAX)) {                                              \\\n                    unsigned char c = *srcp++;                              \\\n                    for (k = 0; k < (K_MAX); ++k) {                         \\\n                        if ((c&0xA0) >> 6) {                                \\\n                            *dstp++ = NUM_GRAYS * ((c&0xA0) >> 6) / 3 - 1;  \\\n                        } else {                                            \\\n                            *dstp++ = 0x00;                                 \\\n                        }                                                   \\\n                        c <<= 2;                                            \\\n                    }                                                       \\\n                }\n\n/* FT_RENDER_MODE_NORMAL and src->pixel_mode GRAY4 */\n#define NORMAL_GRAY4(K_MAX)                                                 \\\n                if ((K_MAX)) {                                              \\\n                    unsigned char c = *srcp++;                              \\\n                    for (k = 0; k < (K_MAX); ++k) {                         \\\n                        if ((c&0xF0) >> 4) {                                \\\n                            *dstp++ = NUM_GRAYS * ((c&0xF0) >> 4) / 15 - 1; \\\n                        } else {                                            \\\n                            *dstp++ = 0x00;                                 \\\n                        }                                                   \\\n                        c <<= 4;                                            \\\n                    }                                                       \\\n                }\n\n\n\n                if (mono) {\n                    if (src->pixel_mode == FT_PIXEL_MODE_MONO) {\n                        while (quotient--) {\n                            MONO_MONO(8);\n                        }\n                        MONO_MONO(remainder);\n                    } else if (src->pixel_mode == FT_PIXEL_MODE_GRAY2) {\n                        while (quotient--) {\n                            MONO_GRAY2(4);\n                        }\n                        MONO_GRAY2(remainder);\n                    } else if (src->pixel_mode == FT_PIXEL_MODE_GRAY4) {\n                        while (quotient--) {\n                            MONO_GRAY4(2);\n                        }\n                        MONO_GRAY4(remainder);\n                    } else {\n                        while (quotient--) {\n                            unsigned char c = *srcp++;\n                            *dstp++ = (c >= 0x80) ? 1 : 0;\n                        }\n                    }\n                } else if (src->pixel_mode == FT_PIXEL_MODE_MONO) {\n                    /* This special case wouldn't be here if the FT_Render_Glyph()\n                     * function wasn't buggy when it tried to render a .fon font with 256\n                     * shades of gray.  Instead, it returns a black and white surface\n                     * and we have to translate it back to a 256 gray shaded surface. */\n                    while (quotient--) {\n                        NORMAL_MONO(8);\n                    }\n                    NORMAL_MONO(remainder);\n                } else if (src->pixel_mode == FT_PIXEL_MODE_GRAY2) {\n                    while (quotient--) {\n                        NORMAL_GRAY2(4);\n                    }\n                    NORMAL_GRAY2(remainder);\n                } else if (src->pixel_mode == FT_PIXEL_MODE_GRAY4) {\n                    while (quotient--) {\n                        NORMAL_GRAY4(2);\n                    }\n                    NORMAL_GRAY4(remainder);\n#if TTF_USE_COLOR\n                } else if (src->pixel_mode == FT_PIXEL_MODE_BGRA) {\n                    SDL_memcpy(dstp, srcp, 4 * src->width);\n#endif\n                } else {\n#if TTF_USE_SDF\n                    if (ft_render_mode != FT_RENDER_MODE_SDF) {\n                        SDL_memcpy(dstp, srcp, src->width);\n                    } else {\n                        int x;\n                        for (x = 0; x < src->width; x++) {\n                            Uint8 s = srcp[x];\n                            Uint8 d;\n                            if (s < 128) {\n                                d = 256 - (128 - s) * 2;\n                            } else {\n                                d = 255;\n                                /* some glitch ?\n                                if (s == 255) {\n                                    d = 0;\n                                }*/\n                            }\n                            dstp[x] = d;\n                        }\n                    }\n#else\n                    SDL_memcpy(dstp, srcp, src->width);\n#endif\n                }\n            }\n        }\n#ifdef _WIN32\n#pragma warning(pop)\n#endif\n\n        /* Handle the bold style */\n        if (TTF_HANDLE_STYLE_BOLD(font)) {\n            int row;\n            /* The pixmap is a little hard, we have to add and clamp */\n            for (row = dst->rows - 1; row >= 0; --row) {\n                Uint8 *pixmap = dst->buffer + row * dst->pitch;\n                int col, offset;\n                /* Minimal memset */\n                /* SDL_memset(pixmap + dst->width - font->glyph_overhang, 0, font->glyph_overhang); */\n                for (offset = 1; offset <= font->glyph_overhang; ++offset) {\n                    for (col = dst->width - 1; col > 0; --col) {\n                        if (mono) {\n                            pixmap[col] |= pixmap[col-1];\n                        } else {\n                            int pixel = (pixmap[col] + pixmap[col-1]);\n                            if (pixel > NUM_GRAYS - 1) {\n                                pixel = NUM_GRAYS - 1;\n                            }\n                            pixmap[col] = (Uint8) pixel;\n                        }\n                    }\n                }\n            }\n        }\n\n        /* Shift back */\n        if (dst->buffer) {\n            dst->buffer -= alignment;\n        }\n\n#if TTF_USE_COLOR\n        if (src->pixel_mode == FT_PIXEL_MODE_BGRA) {\n            dst->is_color = 1;\n        } else {\n            dst->is_color = 0;\n        }\n#else\n        dst->is_color = 0;\n#endif\n\n        /* Mark that we rendered this format */\n        if (mono) {\n            cached->stored |= CACHED_BITMAP;\n        } else {\n#if TTF_USE_COLOR\n            if (want & CACHED_COLOR) {\n                cached->stored |= CACHED_COLOR;\n                /* Most of the time, glyphs loaded with FT_LOAD_COLOR are non colored, so the cache is\n                   also suitable for Shaded rendering (eg, loaded without FT_LOAD_COLOR) */\n                if (dst->is_color == 0) {\n                    cached->stored |= CACHED_PIXMAP;\n                }\n            } else {\n                cached->stored |= CACHED_PIXMAP;\n                /* If font has no color information, Shaded/Pixmap cache is also suitable for Blend/Color */\n                if (!FT_HAS_COLOR(font->face)) {\n                    cached->stored |= CACHED_COLOR;\n                }\n            }\n#else\n            cached->stored |= CACHED_COLOR | CACHED_PIXMAP;\n#endif\n        }\n\n        /* Free outlined glyph */\n        if (glyph) {\n            FT_Done_Glyph(glyph);\n        }\n    }\n\n    /* We're done, this glyph is cached since 'stored' is not 0 */\n    return 0;\n\nft_failure:\n    TTF_SetFTError(\"Couldn't find glyph\", error);\n    return -1;\n}\n\nstatic SDL_INLINE int Find_GlyphByIndex(TTF_Font *font, FT_UInt idx,\n        int want_bitmap, int want_pixmap, int want_color, int want_subpixel,\n        int translation, c_glyph **out_glyph, TTF_Image **out_image)\n{\n    /* cache size is 256, get key by masking */\n    c_glyph *glyph = &font->cache[idx & 0xff];\n\n    if (out_glyph) {\n        *out_glyph = glyph;\n    }\n\n    if (want_pixmap || want_color) {\n        *out_image = &glyph->pixmap;\n    }\n\n    if (want_bitmap) {\n        *out_image = &glyph->bitmap;\n    }\n\n    if (want_subpixel)\n    {\n        /* No a real cache, but if it always advances by integer pixels (eg translation 0 or same as previous),\n         * this allows to render as fast as normal mode. */\n        int retval;\n        int want = CACHED_METRICS | want_bitmap | want_pixmap | want_color | want_subpixel;\n\n        if (glyph->stored && glyph->index != idx) {\n            Flush_Glyph(glyph);\n        }\n\n        if (glyph->subpixel.translation == translation) {\n            want &= ~CACHED_SUBPIX;\n        }\n\n        if ((glyph->stored & want) == want) {\n            return 0;\n        }\n\n        glyph->index = idx;\n        retval = Load_Glyph(font, glyph, want, translation);\n        if (retval == 0) {\n            return 0;\n        } else {\n            return -1;\n        }\n    }\n    else\n    {\n        int retval;\n        const int want = CACHED_METRICS | want_bitmap | want_pixmap | want_color;\n\n        /* Faster check as it gets inlined */\n        if (want_pixmap) {\n            if ((glyph->stored & CACHED_PIXMAP) && glyph->index == idx) {\n                return 0;\n            }\n        } else if (want_bitmap) {\n            if ((glyph->stored & CACHED_BITMAP) && glyph->index == idx) {\n                return 0;\n            }\n        } else if (want_color) {\n            if ((glyph->stored & CACHED_COLOR) && glyph->index == idx) {\n                return 0;\n            }\n        } else {\n            /* Get metrics */\n            if (glyph->stored && glyph->index == idx) {\n                return 0;\n            }\n        }\n\n        /* Cache cannot contain both PIXMAP and COLOR (unless COLOR is actually not colored). \n           So, if it's already used, clear it */\n        if (want_color || want_pixmap) {\n            if (glyph->stored & (CACHED_COLOR|CACHED_PIXMAP)) {\n                Flush_Glyph(glyph);\n            }\n        }\n\n        if (glyph->stored && glyph->index != idx) {\n            Flush_Glyph(glyph);\n        }\n\n        glyph->index = idx;\n        retval = Load_Glyph(font, glyph, want, 0);\n        if (retval == 0) {\n            return 0;\n        } else {\n            return -1;\n        }\n    }\n}\n\nstatic SDL_INLINE FT_UInt get_char_index(TTF_Font *font, Uint32 ch)\n{\n    Uint32 cache_index_size = sizeof (font->cache_index) / sizeof (font->cache_index[0]);\n\n    if (ch < cache_index_size) {\n        FT_UInt idx = font->cache_index[ch];\n        if (idx) {\n            return idx;\n        }\n        idx = FT_Get_Char_Index(font->face, ch);\n        font->cache_index[ch] = idx;\n        return idx;\n    }\n\n    return FT_Get_Char_Index(font->face, ch);\n}\n\n\nstatic SDL_INLINE int Find_GlyphMetrics(TTF_Font *font, Uint32 ch, c_glyph **out_glyph)\n{\n    FT_UInt idx = get_char_index(font, ch);\n    return Find_GlyphByIndex(font, idx, 0, 0, 0, 0, 0, out_glyph, NULL);\n}\n\nvoid TTF_CloseFont(TTF_Font *font)\n{\n    if (font) {\n#if TTF_USE_HARFBUZZ\n        hb_font_destroy(font->hb_font);\n#endif\n        Flush_Cache(font);\n        if (font->face) {\n            FT_Done_Face(font->face);\n        }\n        if (font->args.stream) {\n            SDL_free(font->args.stream);\n        }\n        if (font->freesrc) {\n            SDL_RWclose(font->src);\n        }\n        if (font->pos_buf) {\n            SDL_free(font->pos_buf);\n        }\n        SDL_free(font);\n    }\n}\n\n/* Gets the number of bytes needed to convert a Latin-1 string to UTF-8 */\nstatic size_t LATIN1_to_UTF8_len(const char *text)\n{\n    size_t bytes = 1;\n    while (*text) {\n        Uint8 ch = *(const Uint8 *)text++;\n        if (ch <= 0x7F) {\n            bytes += 1;\n        } else {\n            bytes += 2;\n        }\n    }\n    return bytes;\n}\n\n/* Gets the number of bytes needed to convert a UCS2 string to UTF-8 */\nstatic size_t UCS2_to_UTF8_len(const Uint16 *text)\n{\n    size_t bytes = 1;\n    while (*text) {\n        Uint16 ch = *text++;\n        if (ch <= 0x7F) {\n            bytes += 1;\n        } else if (ch <= 0x7FF) {\n            bytes += 2;\n        } else {\n            bytes += 3;\n        }\n    }\n    return bytes;\n}\n\n/* Convert a Latin-1 string to a UTF-8 string */\nstatic void LATIN1_to_UTF8(const char *src, Uint8 *dst)\n{\n    while (*src) {\n        Uint8 ch = *(const Uint8 *)src++;\n        if (ch <= 0x7F) {\n            *dst++ = ch;\n        } else {\n            *dst++ = 0xC0 | ((ch >> 6) & 0x1F);\n            *dst++ = 0x80 | (ch & 0x3F);\n        }\n    }\n    *dst = '\\0';\n}\n\n/* Convert a UCS-2 string to a UTF-8 string */\nstatic void UCS2_to_UTF8(const Uint16 *src, Uint8 *dst)\n{\n    SDL_bool swapped = TTF_byteswapped;\n\n    while (*src) {\n        Uint16 ch = *src++;\n        if (ch == UNICODE_BOM_NATIVE) {\n            swapped = SDL_FALSE;\n            continue;\n        }\n        if (ch == UNICODE_BOM_SWAPPED) {\n            swapped = SDL_TRUE;\n            continue;\n        }\n        if (swapped) {\n            ch = SDL_Swap16(ch);\n        }\n        if (ch <= 0x7F) {\n            *dst++ = (Uint8) ch;\n        } else if (ch <= 0x7FF) {\n            *dst++ = 0xC0 | (Uint8) ((ch >> 6) & 0x1F);\n            *dst++ = 0x80 | (Uint8) (ch & 0x3F);\n        } else {\n            *dst++ = 0xE0 | (Uint8) ((ch >> 12) & 0x0F);\n            *dst++ = 0x80 | (Uint8) ((ch >> 6) & 0x3F);\n            *dst++ = 0x80 | (Uint8) (ch & 0x3F);\n        }\n    }\n    *dst = '\\0';\n}\n\n/* Convert a unicode char to a UTF-8 string */\nstatic SDL_bool Char_to_UTF8(Uint32 ch, Uint8 *dst)\n{\n    if (ch <= 0x7F) {\n        *dst++ = (Uint8) ch;\n    } else if (ch <= 0x7FF) {\n        *dst++ = 0xC0 | (Uint8) ((ch >> 6) & 0x1F);\n        *dst++ = 0x80 | (Uint8) (ch & 0x3F);\n    } else if (ch <= 0xFFFF) {\n        *dst++ = 0xE0 | (Uint8) ((ch >> 12) & 0x0F);\n        *dst++ = 0x80 | (Uint8) ((ch >> 6) & 0x3F);\n        *dst++ = 0x80 | (Uint8) (ch & 0x3F);\n    } else if (ch <= 0x1FFFFF) {\n        *dst++ = 0xF0 | (Uint8) ((ch >> 18) & 0x07);\n        *dst++ = 0x80 | (Uint8) ((ch >> 12) & 0x3F);\n        *dst++ = 0x80 | (Uint8) ((ch >> 6) & 0x3F);\n        *dst++ = 0x80 | (Uint8) (ch & 0x3F);\n    } else if (ch <= 0x3FFFFFF) {\n        *dst++ = 0xF8 | (Uint8) ((ch >> 24) & 0x03);\n        *dst++ = 0x80 | (Uint8) ((ch >> 18) & 0x3F);\n        *dst++ = 0x80 | (Uint8) ((ch >> 12) & 0x3F);\n        *dst++ = 0x80 | (Uint8) ((ch >> 6) & 0x3F);\n        *dst++ = 0x80 | (Uint8) (ch & 0x3F);\n    } else if (ch < 0x7FFFFFFF) {\n        *dst++ = 0xFC | (Uint8) ((ch >> 30) & 0x01);\n        *dst++ = 0x80 | (Uint8) ((ch >> 24) & 0x3F);\n        *dst++ = 0x80 | (Uint8) ((ch >> 18) & 0x3F);\n        *dst++ = 0x80 | (Uint8) ((ch >> 12) & 0x3F);\n        *dst++ = 0x80 | (Uint8) ((ch >> 6) & 0x3F);\n        *dst++ = 0x80 | (Uint8) (ch & 0x3F);\n    } else {\n        TTF_SetError(\"Invalid character\");\n        return SDL_FALSE;\n    }\n    *dst = '\\0';\n    return SDL_TRUE;\n}\n\n/* Gets a unicode value from a UTF-8 encoded string\n * Ouputs increment to advance the string */\n#define UNKNOWN_UNICODE 0xFFFD\nstatic Uint32 UTF8_getch(const char *src, size_t srclen, int *inc)\n{\n    const Uint8 *p = (const Uint8 *)src;\n    size_t left = 0;\n    size_t save_srclen = srclen;\n    SDL_bool overlong = SDL_FALSE;\n    SDL_bool underflow = SDL_FALSE;\n    Uint32 ch = UNKNOWN_UNICODE;\n\n    if (srclen == 0) {\n        return UNKNOWN_UNICODE;\n    }\n    if (p[0] >= 0xFC) {\n        if ((p[0] & 0xFE) == 0xFC) {\n            if (p[0] == 0xFC && (p[1] & 0xFC) == 0x80) {\n                overlong = SDL_TRUE;\n            }\n            ch = (Uint32) (p[0] & 0x01);\n            left = 5;\n        }\n    } else if (p[0] >= 0xF8) {\n        if ((p[0] & 0xFC) == 0xF8) {\n            if (p[0] == 0xF8 && (p[1] & 0xF8) == 0x80) {\n                overlong = SDL_TRUE;\n            }\n            ch = (Uint32) (p[0] & 0x03);\n            left = 4;\n        }\n    } else if (p[0] >= 0xF0) {\n        if ((p[0] & 0xF8) == 0xF0) {\n            if (p[0] == 0xF0 && (p[1] & 0xF0) == 0x80) {\n                overlong = SDL_TRUE;\n            }\n            ch = (Uint32) (p[0] & 0x07);\n            left = 3;\n        }\n    } else if (p[0] >= 0xE0) {\n        if ((p[0] & 0xF0) == 0xE0) {\n            if (p[0] == 0xE0 && (p[1] & 0xE0) == 0x80) {\n                overlong = SDL_TRUE;\n            }\n            ch = (Uint32) (p[0] & 0x0F);\n            left = 2;\n        }\n    } else if (p[0] >= 0xC0) {\n        if ((p[0] & 0xE0) == 0xC0) {\n            if ((p[0] & 0xDE) == 0xC0) {\n                overlong = SDL_TRUE;\n            }\n            ch = (Uint32) (p[0] & 0x1F);\n            left = 1;\n        }\n    } else {\n        if ((p[0] & 0x80) == 0x00) {\n            ch = (Uint32) p[0];\n        }\n    }\n    --srclen;\n    while (left > 0 && srclen > 0) {\n        ++p;\n        if ((p[0] & 0xC0) != 0x80) {\n            ch = UNKNOWN_UNICODE;\n            break;\n        }\n        ch <<= 6;\n        ch |= (p[0] & 0x3F);\n        --srclen;\n        --left;\n    }\n    if (left > 0) {\n        underflow = SDL_TRUE;\n    }\n    /* Technically overlong sequences are invalid and should not be interpreted.\n       However, it doesn't cause a security risk here and I don't see any harm in\n       displaying them. The application is responsible for any other side effects\n       of allowing overlong sequences (e.g. string compares failing, etc.)\n       See bug 1931 for sample input that triggers this.\n    */\n    /* if (overlong) return UNKNOWN_UNICODE; */\n\n    (void) overlong;\n\n    if (underflow ||\n        (ch >= 0xD800 && ch <= 0xDFFF) ||\n        (ch == 0xFFFE || ch == 0xFFFF) || ch > 0x10FFFF) {\n        ch = UNKNOWN_UNICODE;\n    }\n\n    *inc = (int)(save_srclen - srclen);\n\n    return ch;\n}\n\nint TTF_FontHeight(const TTF_Font *font)\n{\n    return font->height;\n}\n\nint TTF_FontAscent(const TTF_Font *font)\n{\n    return font->ascent + 2 * font->outline_val;\n}\n\nint TTF_FontDescent(const TTF_Font *font)\n{\n    return font->descent;\n}\n\nint TTF_FontLineSkip(const TTF_Font *font)\n{\n    return font->lineskip;\n}\n\nint TTF_GetFontKerning(const TTF_Font *font)\n{\n    return font->allow_kerning;\n}\n\nvoid TTF_SetFontKerning(TTF_Font *font, int allowed)\n{\n    font->allow_kerning = allowed;\n    font->use_kerning   = allowed && FT_HAS_KERNING(font->face);\n}\n\nlong TTF_FontFaces(const TTF_Font *font)\n{\n    return font->face->num_faces;\n}\n\nint TTF_FontFaceIsFixedWidth(const TTF_Font *font)\n{\n    return FT_IS_FIXED_WIDTH(font->face);\n}\n\nchar* TTF_FontFaceFamilyName(const TTF_Font *font)\n{\n    return font->face->family_name;\n}\n\nchar* TTF_FontFaceStyleName(const TTF_Font *font)\n{\n    return font->face->style_name;\n}\n\nint TTF_GlyphIsProvided(TTF_Font *font, Uint16 ch)\n{\n    return (int)get_char_index(font, ch);\n}\n\nint TTF_GlyphIsProvided32(TTF_Font *font, Uint32 ch)\n{\n    return (int)get_char_index(font, ch);\n}\n\nint TTF_GlyphMetrics(TTF_Font *font, Uint16 ch,\n                     int *minx, int *maxx, int *miny, int *maxy, int *advance)\n{\n    return TTF_GlyphMetrics32(font, ch, minx, maxx, miny, maxy, advance);\n}\n\nint TTF_GlyphMetrics32(TTF_Font *font, Uint32 ch,\n                     int *minx, int *maxx, int *miny, int *maxy, int *advance)\n{\n    c_glyph *glyph;\n\n    TTF_CHECK_POINTER(font, -1);\n\n    if (Find_GlyphMetrics(font, ch, &glyph) < 0) {\n        return -1;\n    }\n\n    if (minx) {\n        *minx = glyph->sz_left;\n    }\n    if (maxx) {\n        *maxx = glyph->sz_left + glyph->sz_width;\n        *maxx += 2 * font->outline_val;\n    }\n    if (miny) {\n        *miny = glyph->sz_top - glyph->sz_rows;\n    }\n    if (maxy) {\n        *maxy = glyph->sz_top;\n        *maxy += 2 * font->outline_val;\n    }\n    if (advance) {\n        *advance = FT_CEIL(glyph->advance);\n    }\n    return 0;\n}\n\nint TTF_SetFontDirection(TTF_Font *font, int direction) /* hb_direction_t */\n{\n#if TTF_USE_HARFBUZZ\n    font->hb_direction = direction;\n    return 0;\n#else\n    (void) direction;\n    return -1;\n#endif\n}\n\nint TTF_SetFontScript(TTF_Font *font, int script) /* hb_script_t */\n{\n#if TTF_USE_HARFBUZZ\n    font->hb_script = script;\n    return 0;\n#else\n    (void) script;\n    return -1;\n#endif\n}\n\nstatic int TTF_Size_Internal(TTF_Font *font,\n        const char *text, const str_type_t str_type,\n        int *w, int *h, int *xstart, int *ystart,\n        int measure_width, int *extent, int *count)\n{\n    int x = 0;\n    int pos_x, pos_y;\n    int minx = 0, maxx = 0;\n    int miny = 0, maxy = 0;\n    Uint8 *utf8_alloc = NULL;\n    c_glyph *glyph;\n#if TTF_USE_HARFBUZZ\n    hb_buffer_t *hb_buffer = NULL;\n    unsigned int g;\n    unsigned int glyph_count;\n    hb_glyph_info_t *hb_glyph_info;\n    hb_glyph_position_t *hb_glyph_position;\n    int y = 0;\n#else\n    size_t textlen;\n    int skip_first = 1;\n    FT_UInt prev_index = 0;\n    FT_Pos  prev_delta = 0;\n#endif\n    int prev_advance = 0;\n\n    /* Measurement mode */\n    int char_count = 0;\n    int current_width = 0;\n\n    TTF_CHECK_INITIALIZED(-1);\n    TTF_CHECK_POINTER(font, -1);\n    TTF_CHECK_POINTER(text, -1);\n\n    /* Convert input string to default encoding UTF-8 */\n    if (str_type == STR_TEXT) {\n        utf8_alloc = SDL_stack_alloc(Uint8, LATIN1_to_UTF8_len(text));\n        if (utf8_alloc == NULL) {\n            SDL_OutOfMemory();\n            goto failure;\n        }\n        LATIN1_to_UTF8(text, utf8_alloc);\n        text = (const char *)utf8_alloc;\n    } else if (str_type == STR_UNICODE) {\n        const Uint16 *text16 = (const Uint16 *) text;\n        utf8_alloc = SDL_stack_alloc(Uint8, UCS2_to_UTF8_len(text16));\n        if (utf8_alloc == NULL) {\n            SDL_OutOfMemory();\n            goto failure;\n        }\n        UCS2_to_UTF8(text16, utf8_alloc);\n        text = (const char *)utf8_alloc;\n    }\n\n    maxy = font->height;\n\n    /* Reset buffer */\n    font->pos_len = 0;\n\n#if TTF_USE_HARFBUZZ\n    /* Create a buffer for harfbuzz to use */\n    hb_buffer = hb_buffer_create();\n    if (hb_buffer == NULL) {\n       TTF_SetError(\"Cannot create harfbuzz buffer\");\n       goto failure;\n    }\n\n    /* Set global configuration */\n    hb_buffer_set_direction(hb_buffer, font->hb_direction);\n    hb_buffer_set_script(hb_buffer, font->hb_script);\n\n    /* Layout the text */\n    hb_buffer_add_utf8(hb_buffer, text, -1, 0, -1);\n    hb_shape(font->hb_font, hb_buffer, NULL, 0);\n\n    /* Get the result */\n    hb_glyph_info = hb_buffer_get_glyph_infos(hb_buffer, &glyph_count);\n    hb_glyph_position = hb_buffer_get_glyph_positions(hb_buffer, &glyph_count);\n\n    /* Load and render each character */\n    for (g = 0; g < glyph_count; g++)\n    {\n        FT_UInt idx   = hb_glyph_info[g].codepoint;\n        int x_advance = hb_glyph_position[g].x_advance;\n        int y_advance = hb_glyph_position[g].y_advance;\n        int x_offset  = hb_glyph_position[g].x_offset;\n        int y_offset  = hb_glyph_position[g].y_offset;\n#else\n    /* Load each character and sum it's bounding box */\n    textlen = SDL_strlen(text);\n    while (textlen > 0) {\n        int inc = 0;\n        Uint32 c = UTF8_getch(text, textlen, &inc);\n        FT_UInt idx = get_char_index(font, c);\n        text += inc;\n        textlen -= inc;\n\n        if (c == UNICODE_BOM_NATIVE || c == UNICODE_BOM_SWAPPED) {\n            continue;\n        }\n#endif\n        if (Find_GlyphByIndex(font, idx, 0, 0, 0, 0, 0, &glyph, NULL) < 0) {\n            goto failure;\n        }\n\n        /* Realloc, if needed */\n        if (font->pos_len >= font->pos_max) {\n            PosBuf_t *saved = font->pos_buf;\n            font->pos_max *= 2;\n            font->pos_buf = (PosBuf_t *)SDL_realloc(font->pos_buf, font->pos_max * sizeof (font->pos_buf[0]));\n            if (font->pos_buf == NULL) {\n                font->pos_max /= 2;\n                font->pos_buf = saved;\n                TTF_SetError(\"Out of memory\");\n                goto failure;\n            }\n        }\n\n#if TTF_USE_HARFBUZZ\n        /* Compute positions */\n        pos_x  = x                     + x_offset;\n        pos_y  = y + F26Dot6(font->ascent) - y_offset;\n        x     += x_advance;\n        y     += y_advance;\n#else\n        /* Compute positions */\n        x += prev_advance;\n        prev_advance = glyph->advance;\n        if (font->use_kerning) {\n            if (prev_index && glyph->index) {\n                FT_Vector delta;\n                FT_Get_Kerning(font->face, prev_index, glyph->index, FT_KERNING_UNFITTED, &delta);\n                x += delta.x;\n            }\n            prev_index = glyph->index;\n        }\n        /* FT SUBPIXEL : LCD_MODE_LIGHT_SUBPIXEL  */\n        if (font->render_subpixel) {\n            x += prev_delta;\n            /* Increment by prev_glyph->lsb_delta - prev_glyph->rsb_delta; */\n            prev_delta = glyph->subpixel.lsb_minus_rsb;\n        } else {\n            /* FT KERNING_MODE_SMART: Use `lsb_delta' and `rsb_delta' to improve integer positioning of glyphs */\n            if (skip_first) {\n                skip_first = 0;\n            } else {\n                if (prev_delta - glyph->kerning_smart.lsb_delta >  32 ) {\n                    x -= 64;\n                } else if (prev_delta - glyph->kerning_smart.lsb_delta < -31 ) {\n                    x += 64;\n                }\n            }\n            prev_delta = glyph->kerning_smart.rsb_delta;\n            x = ((x + 32) & -64); /* ROUND() */\n        }\n\n        /* Compute positions where to copy the glyph bitmap */\n        pos_x = x;\n        pos_y = F26Dot6(font->ascent);\n#endif\n        /* Store things for Render_Line() */\n        font->pos_buf[font->pos_len].x     = pos_x;\n        font->pos_buf[font->pos_len].y     = pos_y;\n        font->pos_buf[font->pos_len].index = idx;\n        font->pos_len += 1;\n\n        /* Compute previsionnal global bounding box */\n        pos_x = FT_FLOOR(pos_x) + glyph->sz_left;\n        pos_y = FT_FLOOR(pos_y) - glyph->sz_top;\n\n        minx = SDL_min(minx, pos_x);\n        maxx = SDL_max(maxx, pos_x + glyph->sz_width);\n        miny = SDL_min(miny, pos_y);\n        maxy = SDL_max(maxy, pos_y + glyph->sz_rows);\n\n        /* Measurement mode */\n        if (measure_width) {\n            int cw = SDL_max(maxx, FT_FLOOR(x + prev_advance)) - minx;\n            cw += 2 * font->outline_val;\n            if (cw >= measure_width) {\n                break;\n            }\n            current_width = cw;\n            char_count += 1;\n        }\n    }\n\n    /* Allows to render a string with only one space (bug 4344). */\n    maxx = SDL_max(maxx, FT_FLOOR(x + prev_advance));\n\n    /* Initial x start position: often 0, except when a glyph would be written at\n     * a negative position. In this case an offset is needed for the whole line. */\n    if (xstart) {\n        *xstart = (minx < 0)? -minx : 0;\n        *xstart += font->outline_val;\n        if (font->render_sdf) {\n            *xstart += 8; /* Default 'spread' property */\n        }\n    }\n\n    /* Initial y start: compensation for a negative y offset */\n    if (ystart) {\n        *ystart = (miny < 0)? -miny : 0;\n        *ystart += font->outline_val;\n        if (font->render_sdf) {\n            *ystart += 8; /* Default 'spread' property */\n        }\n    }\n\n    /* Fill the bounds rectangle */\n    if (w) {\n        *w = (maxx - minx);\n        if (*w != 0) {\n            *w += 2 * font->outline_val;\n        }\n    }\n    if (h) {\n        *h = (maxy - miny);\n        *h += 2 * font->outline_val;\n    }\n\n    /* Measurement mode */\n    if (measure_width) {\n        if (extent) {\n            *extent = current_width;\n        }\n        if (count) {\n            *count = char_count;\n        }\n    }\n\n#if TTF_USE_HARFBUZZ\n    if (hb_buffer) {\n        hb_buffer_destroy(hb_buffer);\n    }\n#endif\n    if (utf8_alloc) {\n        SDL_stack_free(utf8_alloc);\n    }\n    return 0;\nfailure:\n#if TTF_USE_HARFBUZZ\n    if (hb_buffer) {\n        hb_buffer_destroy(hb_buffer);\n    }\n#endif\n    if (utf8_alloc) {\n        SDL_stack_free(utf8_alloc);\n    }\n    return -1;\n}\n\nint TTF_SizeText(TTF_Font *font, const char *text, int *w, int *h)\n{\n    return TTF_Size_Internal(font, text, STR_TEXT, w, h, NULL, NULL, NO_MEASUREMENT);\n}\n\nint TTF_SizeUTF8(TTF_Font *font, const char *text, int *w, int *h)\n{\n    return TTF_Size_Internal(font, text, STR_UTF8, w, h, NULL, NULL, NO_MEASUREMENT);\n}\n\nint TTF_SizeUNICODE(TTF_Font *font, const Uint16 *text, int *w, int *h)\n{\n    return TTF_Size_Internal(font, (const char *)text, STR_UNICODE, w, h, NULL, NULL, NO_MEASUREMENT);\n}\n\nint TTF_MeasureText(TTF_Font *font, const char *text, int width, int *extent, int *count)\n{\n    return TTF_Size_Internal(font, text, STR_TEXT, NULL, NULL, NULL, NULL, width, extent, count);\n}\n\nint TTF_MeasureUTF8(TTF_Font *font, const char *text, int width, int *extent, int *count)\n{\n    return TTF_Size_Internal(font, text, STR_UTF8, NULL, NULL, NULL, NULL, width, extent, count);\n}\n\nint TTF_MeasureUNICODE(TTF_Font *font, const Uint16 *text, int width, int *extent, int *count)\n{\n    return TTF_Size_Internal(font, (const char *)text, STR_UNICODE, NULL, NULL, NULL, NULL, width, extent, count);\n}\n\nstatic SDL_Surface* TTF_Render_Internal(TTF_Font *font, const char *text, const str_type_t str_type,\n        SDL_Color fg, SDL_Color bg, const render_mode_t render_mode)\n{\n    Uint32 color;\n    int xstart, ystart, width, height;\n    SDL_Surface *textbuf = NULL;\n    Uint8 *utf8_alloc = NULL;\n\n    TTF_CHECK_INITIALIZED(NULL);\n    TTF_CHECK_POINTER(font, NULL);\n    TTF_CHECK_POINTER(text, NULL);\n\n    /* Convert input string to default encoding UTF-8 */\n    if (str_type == STR_TEXT) {\n        utf8_alloc = SDL_stack_alloc(Uint8, LATIN1_to_UTF8_len(text));\n        if (utf8_alloc == NULL) {\n            SDL_OutOfMemory();\n            goto failure;\n        }\n        LATIN1_to_UTF8(text, utf8_alloc);\n        text = (const char *)utf8_alloc;\n    } else if (str_type == STR_UNICODE) {\n        const Uint16 *text16 = (const Uint16 *) text;\n        utf8_alloc = SDL_stack_alloc(Uint8, UCS2_to_UTF8_len(text16));\n        if (utf8_alloc == NULL) {\n            SDL_OutOfMemory();\n            goto failure;\n        }\n        UCS2_to_UTF8(text16, utf8_alloc);\n        text = (const char *)utf8_alloc;\n    }\n\n    /* Get the dimensions of the text surface */\n    if ((TTF_Size_Internal(font, text, STR_UTF8, &width, &height, &xstart, &ystart, NO_MEASUREMENT) < 0) || !width) {\n        TTF_SetError(\"Text has zero width\");\n        goto failure;\n    }\n\n    /* Support alpha blending */\n    fg.a = fg.a ? fg.a : SDL_ALPHA_OPAQUE;\n    bg.a = bg.a ? bg.a : SDL_ALPHA_OPAQUE;\n\n    /* Create surface for rendering */\n    if (render_mode == RENDER_SOLID) {\n        textbuf = Create_Surface_Solid(width, height, fg, &color);\n    } else if (render_mode == RENDER_SHADED) {\n        textbuf = Create_Surface_Shaded(width, height, fg, bg, &color);\n    } else { /* render_mode == RENDER_BLENDED */\n        textbuf = Create_Surface_Blended(width, height, fg, &color);\n    }\n\n    if (textbuf == NULL) {\n        goto failure;\n    }\n\n    /* Render one text line to textbuf at (xstart, ystart) */\n    if (Render_Line(render_mode, font->render_subpixel, font, textbuf, xstart, ystart, fg.a) < 0) {\n        goto failure;\n    }\n\n    /* Apply underline or strikethrough style, if needed */\n    if (TTF_HANDLE_STYLE_UNDERLINE(font)) {\n        Draw_Line(font, textbuf, ystart + font->underline_top_row, width, font->line_thickness, color, render_mode);\n    }\n\n    if (TTF_HANDLE_STYLE_STRIKETHROUGH(font)) {\n        Draw_Line(font, textbuf, ystart + font->strikethrough_top_row, width, font->line_thickness, color, render_mode);\n    }\n\n    if (utf8_alloc) {\n        SDL_stack_free(utf8_alloc);\n    }\n    return textbuf;\nfailure:\n    if (textbuf) {\n        SDL_FreeSurface(textbuf);\n    }\n    if (utf8_alloc) {\n        SDL_stack_free(utf8_alloc);\n    }\n    return NULL;\n}\n\nSDL_Surface* TTF_RenderText_Solid(TTF_Font *font, const char *text, SDL_Color fg)\n{\n    return TTF_Render_Internal(font, text, STR_TEXT, fg, fg /* unused */, RENDER_SOLID);\n}\n\nSDL_Surface* TTF_RenderUTF8_Solid(TTF_Font *font, const char *text, SDL_Color fg)\n{\n    return TTF_Render_Internal(font, text, STR_UTF8, fg, fg /* unused */, RENDER_SOLID);\n}\n\nSDL_Surface* TTF_RenderUNICODE_Solid(TTF_Font *font, const Uint16 *text, SDL_Color fg)\n{\n    return TTF_Render_Internal(font, (const char *)text, STR_UNICODE, fg, fg /* unused */, RENDER_SOLID);\n}\n\nSDL_Surface* TTF_RenderGlyph_Solid(TTF_Font *font, Uint16 ch, SDL_Color fg)\n{\n    return TTF_RenderGlyph32_Solid(font, ch, fg);\n}\n\nSDL_Surface* TTF_RenderGlyph32_Solid(TTF_Font *font, Uint32 ch, SDL_Color fg)\n{\n    Uint8 utf8[7];\n\n    TTF_CHECK_POINTER(font, NULL);\n\n    if (!Char_to_UTF8(ch, utf8)) {\n        return NULL;\n    }\n\n    return TTF_RenderUTF8_Solid(font, (char *)utf8, fg);\n}\n\nSDL_Surface* TTF_RenderText_Shaded(TTF_Font *font, const char *text, SDL_Color fg, SDL_Color bg)\n{\n    return TTF_Render_Internal(font, text, STR_TEXT, fg, bg, RENDER_SHADED);\n}\n\nSDL_Surface* TTF_RenderUTF8_Shaded(TTF_Font *font, const char *text, SDL_Color fg, SDL_Color bg)\n{\n    return TTF_Render_Internal(font, text, STR_UTF8, fg, bg, RENDER_SHADED);\n}\n\nSDL_Surface* TTF_RenderUNICODE_Shaded(TTF_Font *font, const Uint16 *text, SDL_Color fg, SDL_Color bg)\n{\n    return TTF_Render_Internal(font, (const char *)text, STR_UNICODE, fg, bg, RENDER_SHADED);\n}\n\nSDL_Surface* TTF_RenderGlyph_Shaded(TTF_Font *font, Uint16 ch, SDL_Color fg, SDL_Color bg)\n{\n    return TTF_RenderGlyph32_Shaded(font, ch, fg, bg);\n}\n\nSDL_Surface* TTF_RenderGlyph32_Shaded(TTF_Font *font, Uint32 ch, SDL_Color fg, SDL_Color bg)\n{\n    Uint8 utf8[7];\n\n    TTF_CHECK_POINTER(font, NULL);\n\n    if (!Char_to_UTF8(ch, utf8)) {\n        return NULL;\n    }\n\n    return TTF_RenderUTF8_Shaded(font, (char *)utf8, fg, bg);\n}\n\nSDL_Surface* TTF_RenderText_Blended(TTF_Font *font, const char *text, SDL_Color fg)\n{\n    return TTF_Render_Internal(font, text, STR_TEXT, fg, fg /* unused */, RENDER_BLENDED);\n}\n\nSDL_Surface* TTF_RenderUTF8_Blended(TTF_Font *font, const char *text, SDL_Color fg)\n{\n    return TTF_Render_Internal(font, text, STR_UTF8, fg, fg /* unused */, RENDER_BLENDED);\n}\n\nSDL_Surface* TTF_RenderUNICODE_Blended(TTF_Font *font, const Uint16 *text, SDL_Color fg)\n{\n    return TTF_Render_Internal(font, (const char *)text, STR_UNICODE, fg, fg /* unused */, RENDER_BLENDED);\n}\n\nstatic SDL_bool CharacterIsDelimiter(Uint32 c)\n{\n    if (c == ' ' || c == '\\t' || c == '\\r' || c == '\\n') {\n        return SDL_TRUE;\n    }\n    return SDL_FALSE;\n}\n\nstatic SDL_bool CharacterIsNewLine(Uint32 c)\n{\n    if (c == '\\n') {\n        return SDL_TRUE;\n    }\n    return SDL_FALSE;\n}\n\nstatic SDL_Surface* TTF_Render_Wrapped_Internal(TTF_Font *font, const char *text, const str_type_t str_type,\n        SDL_Color fg, SDL_Color bg, Uint32 wrapLength, const render_mode_t render_mode)\n{\n    Uint32 color;\n    int width, height;\n    SDL_Surface *textbuf = NULL;\n    Uint8 *utf8_alloc = NULL;\n\n    int i, numLines, rowHeight, lineskip;\n    char **strLines = NULL, *text_cpy;\n\n    TTF_CHECK_INITIALIZED(NULL);\n    TTF_CHECK_POINTER(font, NULL);\n    TTF_CHECK_POINTER(text, NULL);\n\n    /* Convert input string to default encoding UTF-8 */\n    if (str_type == STR_TEXT) {\n        utf8_alloc = SDL_stack_alloc(Uint8, LATIN1_to_UTF8_len(text));\n        if (utf8_alloc == NULL) {\n            SDL_OutOfMemory();\n            goto failure;\n        }\n        LATIN1_to_UTF8(text, utf8_alloc);\n        text_cpy = (char *)utf8_alloc;\n    } else if (str_type == STR_UNICODE) {\n        const Uint16 *text16 = (const Uint16 *) text;\n        utf8_alloc = SDL_stack_alloc(Uint8, UCS2_to_UTF8_len(text16));\n        if (utf8_alloc == NULL) {\n            SDL_OutOfMemory();\n            goto failure;\n        }\n        UCS2_to_UTF8(text16, utf8_alloc);\n        text_cpy = (char *)utf8_alloc;\n    } else {\n        /* Use a copy anyway */\n        size_t str_len = SDL_strlen(text);\n        utf8_alloc = SDL_stack_alloc(Uint8, str_len + 1);\n        if (utf8_alloc == NULL) {\n            SDL_OutOfMemory();\n            goto failure;\n        }\n        SDL_memcpy(utf8_alloc, text, str_len + 1);\n        text_cpy = (char *)utf8_alloc;\n    }\n\n    /* Get the dimensions of the text surface */\n    if ((TTF_SizeUTF8(font, text_cpy, &width, &height) < 0) || !width) {\n        TTF_SetError(\"Text has zero width\");\n        goto failure;\n    }\n\n    /* wrapLength is unsigned, but don't allow negative values */\n    if ((int)wrapLength < 0) {\n        TTF_SetError(\"Invalid parameter 'wrapLength'\");\n        goto failure;\n    }\n\n    numLines = 1;\n\n    if (*text_cpy) {\n        int maxNumLines = 0;\n        size_t textlen = SDL_strlen(text_cpy);\n        numLines = 0;\n\n        do {\n            int extent = 0, max_count = 0, char_count = 0;\n            size_t save_textlen = (size_t)(-1);\n            char *save_text  = NULL;\n\n            if (numLines >= maxNumLines) {\n                char **saved = strLines;\n                if (wrapLength == 0) {\n                    maxNumLines += 32;\n                } else {\n                    maxNumLines += (width / wrapLength) + 1;\n                }\n                strLines = (char **)SDL_realloc(strLines, maxNumLines * sizeof (*strLines));\n                if (strLines == NULL) {\n                    strLines = saved;\n                    SDL_OutOfMemory();\n                    goto failure;\n                }\n            }\n\n            strLines[numLines++] = text_cpy;\n\n            if (TTF_MeasureUTF8(font, text_cpy, wrapLength, &extent, &max_count) < 0) {\n                TTF_SetError(\"Error measure text\");\n                goto failure;\n            }\n\n            if (wrapLength != 0) {\n                if (max_count == 0) {\n                    max_count = 1;\n                }\n            }\n\n            while (textlen > 0) {\n                int inc = 0;\n                int is_delim;\n                Uint32 c = UTF8_getch(text_cpy, textlen, &inc);\n                text_cpy += inc;\n                textlen -= inc;\n\n                if (c == UNICODE_BOM_NATIVE || c == UNICODE_BOM_SWAPPED) {\n                    continue;\n                }\n\n                char_count += 1;\n\n                /* With wrapLength == 0, normal text rendering but newline aware */\n                is_delim = (wrapLength > 0) ?  CharacterIsDelimiter(c) : CharacterIsNewLine(c);\n\n                /* Record last delimiter position */\n                if (is_delim) {\n                    save_textlen = textlen;\n                    save_text = text_cpy;\n                    /* Break, if new line */\n                    if (c == '\\n' || c == '\\r') {\n                        *(text_cpy - 1) = '\\0';\n                        break;\n                    }\n                }\n\n                /* Break, if reach the limit */\n                if (char_count == max_count) {\n                    break;\n                }\n            }\n\n            /* Cut at last delimiter/new lines, otherwise in the middle of the word */\n            if (save_text && textlen) {\n                text_cpy = save_text;\n                textlen = save_textlen;\n            }\n        } while (textlen > 0);\n    }\n\n    lineskip = TTF_FontLineSkip(font);\n    rowHeight = SDL_max(height, lineskip);\n\n    if (wrapLength == 0) {\n        /* Find the max of all line lengths */\n        if (numLines > 1) {\n            width = 0;\n            for (i = 0; i < numLines; i++) {\n                char save_c = 0;\n                int w, h;\n\n                /* Add end-of-line */\n                if (strLines) {\n                    text = strLines[i];\n                    if (i + 1 < numLines) {\n                        save_c = strLines[i + 1][0];\n                        strLines[i + 1][0] = '\\0';\n                    }\n                }\n\n                if (TTF_SizeUTF8(font, text, &w, &h) == 0) {\n                    width = SDL_max(w, width);\n                }\n\n                /* Remove end-of-line */\n                if (strLines) {\n                    if (i + 1 < numLines) {\n                        strLines[i + 1][0] = save_c;\n                    }\n                }\n            }\n        }\n    } else {\n        if (numLines > 1) {\n            width = wrapLength;\n        } else {\n            /* Don't go above wrapLength if you have only 1 line which hasn't been cut */\n            width = SDL_min((int)wrapLength, width);\n        }\n    }\n    height = rowHeight + lineskip * (numLines - 1);\n\n    /* Support alpha blending */\n    fg.a = fg.a ? fg.a : SDL_ALPHA_OPAQUE;\n    bg.a = bg.a ? bg.a : SDL_ALPHA_OPAQUE;\n\n    /* Create surface for rendering */\n    if (render_mode == RENDER_SOLID) {\n        textbuf = Create_Surface_Solid(width, height, fg, &color);\n    } else if (render_mode == RENDER_SHADED) {\n        textbuf = Create_Surface_Shaded(width, height, fg, bg, &color);\n    } else { /* render_mode == RENDER_BLENDED */\n        textbuf = Create_Surface_Blended(width, height, fg, &color);\n    }\n\n    if (textbuf == NULL) {\n        goto failure;\n    }\n\n    /* Render each line */\n    for (i = 0; i < numLines; i++) {\n        int xstart, ystart, line_width;\n        char save_c = 0;\n\n        /* Add end-of-line */\n        if (strLines) {\n            text = strLines[i];\n            if (i + 1 < numLines) {\n                save_c = strLines[i + 1][0];\n                strLines[i + 1][0] = '\\0';\n            }\n        }\n\n        /* Initialize xstart, ystart and compute positions */\n        if (TTF_Size_Internal(font, text, STR_UTF8, &line_width, NULL, &xstart, &ystart, NO_MEASUREMENT) < 0) {\n            goto failure;\n        }\n\n        /* Move to i-th line */\n        ystart += i * lineskip;\n\n        /* Render one text line to textbuf at (xstart, ystart) */\n        if (Render_Line(render_mode, font->render_subpixel, font, textbuf, xstart, ystart, fg.a) < 0) {\n            goto failure;\n        }\n\n        /* Apply underline or strikethrough style, if needed */\n        if (TTF_HANDLE_STYLE_UNDERLINE(font)) {\n            Draw_Line(font, textbuf, ystart + font->underline_top_row, line_width, font->line_thickness, color, render_mode);\n        }\n\n        if (TTF_HANDLE_STYLE_STRIKETHROUGH(font)) {\n            Draw_Line(font, textbuf, ystart + font->strikethrough_top_row, line_width, font->line_thickness, color, render_mode);\n        }\n\n        /* Remove end-of-line */\n        if (strLines) {\n            if (i + 1 < numLines) {\n                strLines[i + 1][0] = save_c;\n            }\n        }\n    }\n\n    if (strLines) {\n        SDL_free(strLines);\n    }\n    if (utf8_alloc) {\n        SDL_stack_free(utf8_alloc);\n    }\n    return textbuf;\nfailure:\n    if (textbuf) {\n        SDL_FreeSurface(textbuf);\n    }\n    if (strLines) {\n        SDL_free(strLines);\n    }\n    if (utf8_alloc) {\n        SDL_stack_free(utf8_alloc);\n    }\n    return NULL;\n}\n\nSDL_Surface* TTF_RenderText_Solid_Wrapped(TTF_Font *font, const char *text, SDL_Color fg, Uint32 wrapLength)\n{\n    return TTF_Render_Wrapped_Internal(font, text, STR_TEXT, fg, fg /* unused */, wrapLength, RENDER_SOLID);\n}\n\nSDL_Surface* TTF_RenderUTF8_Solid_Wrapped(TTF_Font *font, const char *text, SDL_Color fg, Uint32 wrapLength)\n{\n    return TTF_Render_Wrapped_Internal(font, text, STR_UTF8, fg, fg /* unused */, wrapLength, RENDER_SOLID);\n}\n\nSDL_Surface* TTF_RenderUNICODE_Solid_Wrapped(TTF_Font *font, const Uint16 *text, SDL_Color fg, Uint32 wrapLength)\n{\n    return TTF_Render_Wrapped_Internal(font, (const char *)text, STR_UNICODE, fg, fg /* unused */, wrapLength, RENDER_SOLID);\n}\n\nSDL_Surface* TTF_RenderText_Shaded_Wrapped(TTF_Font *font, const char *text, SDL_Color fg, SDL_Color bg, Uint32 wrapLength)\n{\n    return TTF_Render_Wrapped_Internal(font, text, STR_TEXT, fg, bg, wrapLength, RENDER_SHADED);\n}\n\nSDL_Surface* TTF_RenderUTF8_Shaded_Wrapped(TTF_Font *font, const char *text, SDL_Color fg, SDL_Color bg, Uint32 wrapLength)\n{\n    return TTF_Render_Wrapped_Internal(font, text, STR_UTF8, fg, bg, wrapLength, RENDER_SHADED);\n}\n\nSDL_Surface* TTF_RenderUNICODE_Shaded_Wrapped(TTF_Font *font, const Uint16 *text, SDL_Color fg, SDL_Color bg, Uint32 wrapLength)\n{\n    return TTF_Render_Wrapped_Internal(font, (const char *)text, STR_UNICODE, fg, bg, wrapLength, RENDER_SHADED);\n}\n\nSDL_Surface* TTF_RenderText_Blended_Wrapped(TTF_Font *font, const char *text, SDL_Color fg, Uint32 wrapLength)\n{\n    return TTF_Render_Wrapped_Internal(font, text, STR_TEXT, fg, fg /* unused */, wrapLength, RENDER_BLENDED);\n}\n\nSDL_Surface* TTF_RenderUTF8_Blended_Wrapped(TTF_Font *font, const char *text, SDL_Color fg, Uint32 wrapLength)\n{\n    return TTF_Render_Wrapped_Internal(font, text, STR_UTF8, fg, fg /* unused */, wrapLength, RENDER_BLENDED);\n}\n\nSDL_Surface* TTF_RenderUNICODE_Blended_Wrapped(TTF_Font *font, const Uint16 *text, SDL_Color fg, Uint32 wrapLength)\n{\n    return TTF_Render_Wrapped_Internal(font, (const char *)text, STR_UNICODE, fg, fg /* unused */, wrapLength, RENDER_BLENDED);\n}\n\nSDL_Surface* TTF_RenderGlyph_Blended(TTF_Font *font, Uint16 ch, SDL_Color fg)\n{\n    return TTF_RenderGlyph32_Blended(font, ch, fg);\n}\n\nSDL_Surface* TTF_RenderGlyph32_Blended(TTF_Font *font, Uint32 ch, SDL_Color fg)\n{\n    Uint8 utf8[7];\n\n    TTF_CHECK_POINTER(font, NULL);\n\n    if (!Char_to_UTF8(ch, utf8)) {\n        return NULL;\n    }\n\n    return TTF_RenderUTF8_Blended(font, (char *)utf8, fg);\n}\n\nvoid TTF_SetFontStyle(TTF_Font *font, int style)\n{\n    int prev_style;\n    long face_style;\n\n    TTF_CHECK_POINTER(font,);\n\n    prev_style = font->style;\n    face_style = font->face->style_flags;\n\n    /* Don't add a style if already in the font, SDL_ttf doesn't need to handle them */\n    if (face_style & FT_STYLE_FLAG_BOLD) {\n        style &= ~TTF_STYLE_BOLD;\n    }\n    if (face_style & FT_STYLE_FLAG_ITALIC) {\n        style &= ~TTF_STYLE_ITALIC;\n    }\n\n    font->style = style;\n\n    TTF_initFontMetrics(font);\n\n    /* Flush the cache if the style has changed.\n     * Ignore styles which do not impact glyph drawning. */\n    if ((font->style | TTF_STYLE_NO_GLYPH_CHANGE) != (prev_style | TTF_STYLE_NO_GLYPH_CHANGE)) {\n        Flush_Cache(font);\n    }\n}\n\nint TTF_GetFontStyle(const TTF_Font *font)\n{\n    int style;\n    long face_style;\n\n    TTF_CHECK_POINTER(font, -1);\n\n    style = font->style;\n    face_style = font->face->style_flags;\n\n    /* Add the style already in the font */\n    if (face_style & FT_STYLE_FLAG_BOLD) {\n        style |= TTF_STYLE_BOLD;\n    }\n    if (face_style & FT_STYLE_FLAG_ITALIC) {\n        style |= TTF_STYLE_ITALIC;\n    }\n\n    return style;\n}\n\nvoid TTF_SetFontOutline(TTF_Font *font, int outline)\n{\n    TTF_CHECK_POINTER(font,);\n\n    font->outline_val = SDL_max(0, outline);\n    TTF_initFontMetrics(font);\n    Flush_Cache(font);\n}\n\nint TTF_GetFontOutline(const TTF_Font *font)\n{\n    TTF_CHECK_POINTER(font, -1);\n\n    return font->outline_val;\n}\n\nvoid TTF_SetFontHinting(TTF_Font *font, int hinting)\n{\n    TTF_CHECK_POINTER(font,);\n\n    if (hinting == TTF_HINTING_LIGHT || hinting == TTF_HINTING_LIGHT_SUBPIXEL) {\n        font->ft_load_target = FT_LOAD_TARGET_LIGHT;\n    } else if (hinting == TTF_HINTING_MONO) {\n        font->ft_load_target = FT_LOAD_TARGET_MONO;\n    } else if (hinting == TTF_HINTING_NONE) {\n        font->ft_load_target = FT_LOAD_NO_HINTING;\n    } else {\n        font->ft_load_target = FT_LOAD_TARGET_NORMAL;\n    }\n\n    font->render_subpixel = (hinting == TTF_HINTING_LIGHT_SUBPIXEL) ? 1 : 0;\n#if TTF_USE_HARFBUZZ\n    /* update flag for HB */\n    hb_ft_font_set_load_flags(font->hb_font, FT_LOAD_DEFAULT | font->ft_load_target);\n#endif\n\n    Flush_Cache(font);\n}\n\nint TTF_GetFontHinting(const TTF_Font *font)\n{\n    TTF_CHECK_POINTER(font, -1);\n\n    if (font->ft_load_target == FT_LOAD_TARGET_LIGHT) {\n        if (font->render_subpixel == 0) {\n            return TTF_HINTING_LIGHT;\n        } else {\n            return TTF_HINTING_LIGHT_SUBPIXEL;\n        }\n    } else if (font->ft_load_target == FT_LOAD_TARGET_MONO) {\n        return TTF_HINTING_MONO;\n    } else if (font->ft_load_target == FT_LOAD_NO_HINTING) {\n        return TTF_HINTING_NONE;\n    }\n    return TTF_HINTING_NORMAL;\n}\n\nint TTF_SetFontSDF(TTF_Font *font, SDL_bool on_off)\n{\n    TTF_CHECK_POINTER(font, -1);\n#if TTF_USE_SDF\n    font->render_sdf = on_off;\n    Flush_Cache(font);\n    return 0;\n#else\n    TTF_SetError(\"SDL_ttf compiled without SDF support\");\n    return -1;\n#endif\n}\n\nSDL_bool TTF_GetFontSDF(const TTF_Font *font)\n{\n    TTF_CHECK_POINTER(font, SDL_FALSE);\n    return font->render_sdf;\n}\n\nvoid TTF_Quit(void)\n{\n    if (TTF_initialized) {\n        if (--TTF_initialized == 0) {\n            FT_Done_FreeType(library);\n            library = NULL;\n        }\n    }\n}\n\nint TTF_WasInit(void)\n{\n    return TTF_initialized;\n}\n\n/* don't use this function. It's just here for binary compatibility. */\nint TTF_GetFontKerningSize(TTF_Font *font, int prev_index, int index)\n{\n    FT_Vector delta;\n\n    TTF_CHECK_POINTER(font, -1);\n\n    FT_Get_Kerning(font->face, (FT_UInt)prev_index, (FT_UInt)index, FT_KERNING_DEFAULT, &delta);\n    return (int)(delta.x >> 6);\n}\n\nint TTF_GetFontKerningSizeGlyphs(TTF_Font *font, Uint16 previous_ch, Uint16 ch)\n{\n    return TTF_GetFontKerningSizeGlyphs32(font, previous_ch, ch);\n}\n\nint TTF_GetFontKerningSizeGlyphs32(TTF_Font *font, Uint32 previous_ch, Uint32 ch)\n{\n    FT_Error error;\n    c_glyph *prev_glyph, *glyph;\n    FT_Vector delta;\n\n    TTF_CHECK_POINTER(font, -1);\n\n    if (ch == UNICODE_BOM_NATIVE || ch == UNICODE_BOM_SWAPPED) {\n        return 0;\n    }\n\n    if (previous_ch == UNICODE_BOM_NATIVE || previous_ch == UNICODE_BOM_SWAPPED) {\n        return 0;\n    }\n\n    if (Find_GlyphMetrics(font, ch, &glyph) < 0) {\n        return -1;\n    }\n\n    if (Find_GlyphMetrics(font, previous_ch, &prev_glyph) < 0) {\n        return -1;\n    }\n\n    error = FT_Get_Kerning(font->face, prev_glyph->index, glyph->index, FT_KERNING_DEFAULT, &delta);\n    if (error) {\n        TTF_SetFTError(\"Couldn't get glyph kerning\", error);\n        return -1;\n    }\n    return (int)(delta.x >> 6);\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n"], "fixing_code": ["/*\n  SDL_ttf:  A companion library to SDL for working with TrueType (tm) fonts\n  Copyright (C) 2001-2022 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\n#include \"SDL.h\"\n#include \"SDL_cpuinfo.h\"\n#include \"SDL_endian.h\"\n\n#include \"SDL_ttf.h\"\n\n#include <ft2build.h>\n#include FT_FREETYPE_H\n#include FT_OUTLINE_H\n#include FT_STROKER_H\n#include FT_GLYPH_H\n#include FT_TRUETYPE_IDS_H\n#include FT_IMAGE_H\n\n/* Enable rendering with color\n * Freetype may need to be compiled with FT_CONFIG_OPTION_USE_PNG */\n#if defined(FT_HAS_COLOR)\n#  define TTF_USE_COLOR 1\n#else\n#  define TTF_USE_COLOR 0\n#endif\n\n/* Enable Signed Distance Field rendering (requires latest FreeType version) */\n#if defined(FT_RASTER_FLAG_SDF)\n#  define TTF_USE_SDF 1\n#else\n#  define TTF_USE_SDF 0\n#endif\n\n#if TTF_USE_SDF\n#include FT_MODULE_H\n#endif\n\n/* Enable HarfBuzz for Complex text rendering\n * Freetype may need to be compiled with FT_CONFIG_OPTION_USE_HARFBUZZ */\n#ifndef TTF_USE_HARFBUZZ\n#  define TTF_USE_HARFBUZZ 0\n#endif\n\n#if TTF_USE_HARFBUZZ\n#include <hb.h>\n#include <hb-ft.h>\n\n/* Default configuration */\nstatic hb_direction_t g_hb_direction = HB_DIRECTION_LTR;\nstatic hb_script_t    g_hb_script = HB_SCRIPT_UNKNOWN;\n#endif\n\n/* Harfbuzz */\nint TTF_SetDirection(int direction) /* hb_direction_t */\n{\n#if TTF_USE_HARFBUZZ\n    g_hb_direction = direction;\n    return 0;\n#else\n    (void) direction;\n    return -1;\n#endif\n}\n\nint TTF_SetScript(int script) /* hb_script_t */\n{\n#if TTF_USE_HARFBUZZ\n    g_hb_script = script;\n    return 0;\n#else\n    (void) script;\n    return -1;\n#endif\n}\n\n/* Round glyph to 16 bytes width and use SSE2 instructions */\n#if defined(__SSE2__)\n#  define HAVE_SSE2_INTRINSICS 1\n#endif\n\n/* Round glyph width to 16 bytes use NEON instructions */\n#if 0 /*defined(__ARM_NEON)*/\n#  define HAVE_NEON_INTRINSICS 1\n#endif\n\n/* Round glyph width to 8 bytes */\n#define HAVE_BLIT_GLYPH_64\n\n/* Android armeabi-v7a doesn't like int64 (Maybe all other __ARM_ARCH < 7 ?),\n * un-activate it, especially if NEON isn't detected */\n#if defined(__ARM_ARCH)\n#  if __ARM_ARCH < 8\n#    if defined(HAVE_BLIT_GLYPH_64)\n#      undef HAVE_BLIT_GLYPH_64\n#    endif\n#  endif\n#endif\n\n/* Default: round glyph width to 4 bytes to copy them faster */\n#define HAVE_BLIT_GLYPH_32\n\n/* Use Duff's device to unroll loops */\n//#define USE_DUFFS_LOOP\n\n#if defined(HAVE_SSE2_INTRINSICS)\nstatic SDL_INLINE int hasSSE2()\n{\n    static int val = -1;\n    if (val != -1) {\n        return val;\n    }\n    val = SDL_HasSSE2();\n    return val;\n}\n#endif\n\n#if defined(HAVE_NEON_INTRINSICS)\nstatic SDL_INLINE int hasNEON()\n{\n    static int val = -1;\n    if (val != -1) {\n        return val;\n    }\n    val = SDL_HasNEON();\n    return val;\n}\n#endif\n\n/* FIXME: Right now we assume the gray-scale renderer Freetype is using\n   supports 256 shades of gray, but we should instead key off of num_grays\n   in the result FT_Bitmap after the FT_Render_Glyph() call. */\n#define NUM_GRAYS       256\n\n/* x offset = cos(((90.0-12)/360) * 2 * M_PI), or 12 degree angle */\n/* same value as in FT_GlyphSlot_Oblique, fixed point 16.16 */\n#define GLYPH_ITALICS  0x0366AL\n\n/* Handy routines for converting from fixed point 26.6 */\n#define FT_FLOOR(X) (((X) & -64) / 64)\n#define FT_CEIL(X)  FT_FLOOR((X) + 63)\n\n/* Handy routine for converting to fixed point 26.6 */\n#define F26Dot6(X)  ((X) << 6)\n\n/* Faster divide by 255, with same result\n * in range [0; 255]:  (x + 1   + (x >> 8)) >> 8\n * in range [-255; 0]: (x + 255 + (x >> 8)) >> 8 */\n#define DIVIDE_BY_255_SIGNED(x, sign_val)  (((x) + (sign_val) + ((x)>>8)) >> 8)\n\n/* When x positive */\n#define DIVIDE_BY_255(x)    DIVIDE_BY_255_SIGNED(x, 1)\n\n\n#define CACHED_METRICS  0x10\n#define CACHED_BITMAP   0x01\n#define CACHED_PIXMAP   0x02\n#define CACHED_COLOR    0x04\n#define CACHED_SUBPIX   0x08\n\n\ntypedef struct {\n    unsigned char *buffer; /* aligned */\n    int            left;\n    int            top;\n    int            width;\n    int            rows;\n    int            pitch;\n    int            is_color;\n} TTF_Image;\n\n/* Cached glyph information */\ntypedef struct cached_glyph {\n    int stored;\n    FT_UInt index;\n    TTF_Image bitmap;\n    TTF_Image pixmap;\n    int sz_left;\n    int sz_top;\n    int sz_width;\n    int sz_rows;\n    int advance;\n    union {\n        /* TTF_HINTING_LIGHT_SUBPIXEL (only pixmap) */\n        struct {\n            int lsb_minus_rsb;\n            int translation;\n        } subpixel;\n        /* Other hinting */\n        struct {\n            int rsb_delta;\n            int lsb_delta;\n        } kerning_smart;\n    };\n} c_glyph;\n\n/* Internal buffer to store positions computed by TTF_Size_Internal()\n * for rendered string by Render_Line() */\ntypedef struct PosBuf {\n    FT_UInt index;\n    int x;\n    int y;\n} PosBuf_t;\n\n/* The structure used to hold internal font information */\nstruct _TTF_Font {\n    /* Freetype2 maintains all sorts of useful info itself */\n    FT_Face face;\n\n    /* We'll cache these ourselves */\n    int height;\n    int ascent;\n    int descent;\n    int lineskip;\n\n    /* The font style */\n    int style;\n    int outline_val;\n\n    /* Whether kerning is desired */\n    int allow_kerning;\n    int use_kerning;\n\n    /* Extra width in glyph bounds for text styles */\n    int glyph_overhang;\n\n    /* Information in the font for underlining */\n    int line_thickness;\n    int underline_top_row;\n    int strikethrough_top_row;\n\n    /* Cache for style-transformed glyphs */\n    c_glyph cache[256];\n    FT_UInt cache_index[128];\n\n    /* We are responsible for closing the font stream */\n    SDL_RWops *src;\n    int freesrc;\n    FT_Open_Args args;\n\n    /* Internal buffer to store positions computed by TTF_Size_Internal()\n     * for rendered string by Render_Line() */\n    PosBuf_t *pos_buf;\n    Uint32 pos_len;\n    Uint32 pos_max;\n\n    /* Hinting modes */\n    int ft_load_target;\n    int render_subpixel;\n#if TTF_USE_HARFBUZZ\n    hb_font_t *hb_font;\n    hb_script_t hb_script;\n    hb_direction_t hb_direction;\n#endif\n    int render_sdf;\n};\n\n/* Tell if SDL_ttf has to handle the style */\n#define TTF_HANDLE_STYLE_BOLD(font)          ((font)->style & TTF_STYLE_BOLD)\n#define TTF_HANDLE_STYLE_ITALIC(font)        ((font)->style & TTF_STYLE_ITALIC)\n#define TTF_HANDLE_STYLE_UNDERLINE(font)     ((font)->style & TTF_STYLE_UNDERLINE)\n#define TTF_HANDLE_STYLE_STRIKETHROUGH(font) ((font)->style & TTF_STYLE_STRIKETHROUGH)\n\n/* Font styles that does not impact glyph drawing */\n#define TTF_STYLE_NO_GLYPH_CHANGE   (TTF_STYLE_UNDERLINE | TTF_STYLE_STRIKETHROUGH)\n\n/* The FreeType font engine/library */\nstatic FT_Library library = NULL;\nstatic int TTF_initialized = 0;\nstatic SDL_bool TTF_byteswapped = SDL_FALSE;\n\n#define TTF_CHECK_INITIALIZED(errval)                   \\\n    if (!TTF_initialized) {                             \\\n        TTF_SetError(\"Library not initialized\");        \\\n        return errval;                                  \\\n    }\n\n#define TTF_CHECK_POINTER(p, errval)                    \\\n    if (!(p)) {                                         \\\n        TTF_SetError(\"Passed a NULL pointer\");          \\\n        return errval;                                  \\\n    }\n\ntypedef enum {\n    RENDER_SOLID = 0,\n    RENDER_SHADED,\n    RENDER_BLENDED\n} render_mode_t;\n\ntypedef enum {\n    STR_UTF8 = 0,\n    STR_TEXT,\n    STR_UNICODE\n} str_type_t;\n\nstatic int TTF_initFontMetrics(TTF_Font *font);\n\nstatic int TTF_Size_Internal(TTF_Font *font, const char *text, str_type_t str_type,\n        int *w, int *h, int *xstart, int *ystart, int measure_width, int *extent, int *count);\n\n#define NO_MEASUREMENT  \\\n        0, NULL, NULL\n\n\nstatic SDL_Surface* TTF_Render_Internal(TTF_Font *font, const char *text, str_type_t str_type,\n        SDL_Color fg, SDL_Color bg, render_mode_t render_mode);\n\nstatic SDL_Surface* TTF_Render_Wrapped_Internal(TTF_Font *font, const char *text, str_type_t str_type,\n        SDL_Color fg, SDL_Color bg, Uint32 wrapLength, render_mode_t render_mode);\n\nstatic SDL_INLINE int Find_GlyphByIndex(TTF_Font *font, FT_UInt idx,\n        int want_bitmap, int want_pixmap, int want_color, int want_subpixel,\n        int translation, c_glyph **out_glyph, TTF_Image **out_image);\n\nstatic void Flush_Cache(TTF_Font *font);\n\n#if defined(USE_DUFFS_LOOP)\n\n/* 4-times unrolled loop */\n#define DUFFS_LOOP4(pixel_copy_increment, width)                        \\\n{ int n = (width+3)/4;                                                  \\\n    switch (width & 3) {                                                \\\n    case 0: do {    pixel_copy_increment;   /* fallthrough */           \\\n    case 3:     pixel_copy_increment;       /* fallthrough */           \\\n    case 2:     pixel_copy_increment;       /* fallthrough */           \\\n    case 1:     pixel_copy_increment;       /* fallthrough */           \\\n        } while (--n > 0);                                              \\\n    }                                                                   \\\n}\n\n#else\n\n/* Don't use Duff's device to unroll loops */\n#define DUFFS_LOOP(pixel_copy_increment, width)                         \\\n{ int n;                                                                \\\n    for ( n=width; n > 0; --n ) {                                       \\\n        pixel_copy_increment;                                           \\\n    }                                                                   \\\n}\n\n#define DUFFS_LOOP4(pixel_copy_increment, width)                        \\\n    DUFFS_LOOP(pixel_copy_increment, width)\n\n#endif\n\n\n/* Blend colored glyphs */\nstatic SDL_INLINE void BG_Blended_Color(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip, Uint8 fg_alpha)\n{\n    const Uint32 *src   = (Uint32 *)image->buffer;\n    Uint32      *dst    = destination;\n    Uint32       width  = image->width;\n    Uint32       height = image->rows;\n\n    if (fg_alpha == 0) { /* SDL_ALPHA_OPAQUE */\n        while (height--) {\n            /* *INDENT-OFF* */\n            DUFFS_LOOP4(\n                *dst++ = *src++;\n            , width);\n            /* *INDENT-ON* */\n            src = (const Uint32 *)((const Uint8 *)src + srcskip);\n            dst = (Uint32 *)((Uint8 *)dst + dstskip);\n        }\n    } else {\n        Uint32 alpha;\n        Uint32 tmp;\n\n        while (height--) {\n            /* *INDENT-OFF* */\n            DUFFS_LOOP4(\n                    tmp = *src++;\n                    alpha = tmp >> 24;\n                    tmp &= ~0xFF000000;\n                    alpha = fg_alpha * alpha;\n                    alpha =  DIVIDE_BY_255(alpha) << 24;\n                    *dst++ = tmp | alpha\n                    , width);\n            /* *INDENT-ON* */\n            src = (const Uint32 *)((const Uint8 *)src + srcskip);\n            dst = (Uint32 *)((Uint8 *)dst + dstskip);\n        }\n    }\n}\n\n#if TTF_USE_SDF\n\n/* Blended Opaque SDF */\nstatic SDL_INLINE void BG_Blended_Opaque_SDF(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip)\n{\n    const Uint8 *src    = image->buffer;\n    Uint32      *dst    = destination;\n    Uint32       width  = image->width;\n    Uint32       height = image->rows;\n\n    Uint32 s;\n    Uint32 d;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            d = *dst;\n            s = *src++ << 24;\n            if (s > d) {\n                *dst = s;\n            }\n            dst++;\n        , width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst  = (Uint32 *)((Uint8 *)dst + dstskip);\n    }\n}\n\n/* Blended non-opaque SDF */\nstatic SDL_INLINE void BG_Blended_SDF(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip, Uint8 fg_alpha)\n{\n    const Uint8 *src    = image->buffer;\n    Uint32      *dst    = destination;\n    Uint32       width  = image->width;\n    Uint32       height = image->rows;\n\n    Uint32 s;\n    Uint32 d;\n\n    Uint32 tmp;\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            d = *dst;\n            tmp = fg_alpha * (*src++);\n            s = DIVIDE_BY_255(tmp) << 24;\n            if (s > d) {\n                *dst = s;\n            }\n            dst++;\n        , width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst  = (Uint32 *)((Uint8 *)dst + dstskip);\n    }\n}\n\n#endif /* TTF_USE_SDF */\n\n/* Blended Opaque */\nstatic SDL_INLINE void BG_Blended_Opaque(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip)\n{\n    const Uint8 *src    = image->buffer;\n    Uint32      *dst    = destination;\n    Uint32       width  = image->width;\n    Uint32       height = image->rows;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            *dst++ |= *src++ << 24;\n        , width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst  = (Uint32 *)((Uint8 *)dst + dstskip);\n    }\n}\n\n/* Blended non-opaque */\nstatic SDL_INLINE void BG_Blended(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip, Uint8 fg_alpha)\n{\n    const Uint8 *src    = image->buffer;\n    Uint32      *dst    = destination;\n    Uint32       width  = image->width;\n    Uint32       height = image->rows;\n\n    Uint32 tmp;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            tmp     = fg_alpha * (*src++);\n            *dst++ |= DIVIDE_BY_255(tmp) << 24;\n        , width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst  = (Uint32 *)((Uint8 *)dst + dstskip);\n    }\n}\n\n#if defined(HAVE_BLIT_GLYPH_32) || defined(HAVE_BLIT_GLYPH_64)\nstatic SDL_INLINE void BG_Blended_Opaque_32(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip)\n{\n    const Uint8 *src    = image->buffer;\n    Uint32      *dst    = destination;\n    Uint32       width  = image->width / 4;\n    Uint32       height = image->rows;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            *dst++ |= *src++ << 24;\n            *dst++ |= *src++ << 24;\n            *dst++ |= *src++ << 24;\n            *dst++ |= *src++ << 24;\n        , width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst  = (Uint32 *)((Uint8 *)dst + dstskip);\n    }\n}\n\nstatic SDL_INLINE void BG_Blended_32(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip, Uint8 fg_alpha)\n{\n    const Uint8 *src    = image->buffer;\n    Uint32      *dst    = destination;\n    Uint32       width  = image->width / 4;\n    Uint32       height = image->rows;\n\n    Uint32 tmp0, tmp1, tmp2, tmp3;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            tmp0    = fg_alpha * (*src++);\n            tmp1    = fg_alpha * (*src++);\n            tmp2    = fg_alpha * (*src++);\n            tmp3    = fg_alpha * (*src++);\n            *dst++ |= DIVIDE_BY_255(tmp0) << 24;\n            *dst++ |= DIVIDE_BY_255(tmp1) << 24;\n            *dst++ |= DIVIDE_BY_255(tmp2) << 24;\n            *dst++ |= DIVIDE_BY_255(tmp3) << 24;\n        , width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst  = (Uint32 *)((Uint8 *)dst + dstskip);\n    }\n}\n#endif\n\n#if defined(HAVE_SSE2_INTRINSICS)\n/* Apply: alpha_table[i] = i << 24; */\nstatic SDL_INLINE void BG_Blended_Opaque_SSE(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip)\n{\n    const __m128i *src    = (__m128i *)image->buffer;\n    __m128i       *dst    = (__m128i *)destination;\n    Uint32         width  = image->width / 16;\n    Uint32         height = image->rows;\n\n    __m128i s, s0, s1, s2, s3, d0, d1, d2, d3, r0, r1, r2, r3, L, H;\n    const __m128i zero  = _mm_setzero_si128();\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            /* Read 16 Uint8 at once and put into 4 __m128i */\n            s  = _mm_loadu_si128(src);          // load unaligned\n            d0 = _mm_load_si128(dst);           // load\n            d1 = _mm_load_si128(dst + 1);       // load\n            d2 = _mm_load_si128(dst + 2);       // load\n            d3 = _mm_load_si128(dst + 3);       // load\n\n            L  = _mm_unpacklo_epi8(zero, s);\n            H  = _mm_unpackhi_epi8(zero, s);\n\n            s0 = _mm_unpacklo_epi8(zero, L);\n            s1 = _mm_unpackhi_epi8(zero, L);\n            s2 = _mm_unpacklo_epi8(zero, H);\n            s3 = _mm_unpackhi_epi8(zero, H);\n                                                // already shifted by 24\n            r0 = _mm_or_si128(d0, s0);          // or\n            r1 = _mm_or_si128(d1, s1);          // or\n            r2 = _mm_or_si128(d2, s2);          // or\n            r3 = _mm_or_si128(d3, s3);          // or\n\n            _mm_store_si128(dst, r0);           // store\n            _mm_store_si128(dst + 1, r1);       // store\n            _mm_store_si128(dst + 2, r2);       // store\n            _mm_store_si128(dst + 3, r3);       // store\n\n            dst += 4;\n            src += 1;\n        , width);\n        /* *INDENT-ON* */\n        src = (const __m128i *)((const Uint8 *)src + srcskip);\n        dst = (__m128i *)((Uint8 *)dst + dstskip);\n    }\n}\n\nstatic SDL_INLINE void BG_Blended_SSE(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip, Uint8 fg_alpha)\n{\n    const __m128i *src    = (__m128i *)image->buffer;\n    __m128i       *dst    = (__m128i *)destination;\n    Uint32         width  = image->width / 16;\n    Uint32         height = image->rows;\n\n    const __m128i alpha = _mm_set1_epi16(fg_alpha);\n    const __m128i one   = _mm_set1_epi16(1);\n    const __m128i zero  = _mm_setzero_si128();\n    __m128i s, s0, s1, s2, s3, d0, d1, d2, d3, r0, r1, r2, r3, L, H, Ls8, Hs8;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            /* Read 16 Uint8 at once and put into 4 __m128i */\n            s  = _mm_loadu_si128(src);          // load unaligned\n            d0 = _mm_load_si128(dst);           // load\n            d1 = _mm_load_si128(dst + 1);       // load\n            d2 = _mm_load_si128(dst + 2);       // load\n            d3 = _mm_load_si128(dst + 3);       // load\n\n            L  = _mm_unpacklo_epi8(s, zero);    // interleave, no shifting\n            H  = _mm_unpackhi_epi8(s, zero);    // enough room to multiply\n\n            /* Apply: alpha_table[i] = ((i * fg.a / 255) << 24; */\n            /* Divide by 255 is done as:    (x + 1 + (x >> 8)) >> 8 */\n\n            L  = _mm_mullo_epi16(L, alpha);     // x := i * fg.a\n            H  = _mm_mullo_epi16(H, alpha);\n\n            Ls8 = _mm_srli_epi16(L, 8);         // x >> 8\n            Hs8 = _mm_srli_epi16(H, 8);\n            L = _mm_add_epi16(L, one);          // x + 1\n            H = _mm_add_epi16(H, one);\n            L = _mm_add_epi16(L, Ls8);          // x + 1 + (x >> 8)\n            H = _mm_add_epi16(H, Hs8);\n            L = _mm_srli_epi16(L, 8);           // ((x + 1 + (x >> 8)) >> 8\n            H = _mm_srli_epi16(H, 8);\n\n            L = _mm_slli_epi16(L, 8);           // shift << 8, so we're prepared\n            H = _mm_slli_epi16(H, 8);           // to have final format << 24\n\n            s0 = _mm_unpacklo_epi8(zero, L);\n            s1 = _mm_unpackhi_epi8(zero, L);\n            s2 = _mm_unpacklo_epi8(zero, H);\n            s3 = _mm_unpackhi_epi8(zero, H);\n                                                // already shifted by 24\n\n            r0 = _mm_or_si128(d0, s0);          // or\n            r1 = _mm_or_si128(d1, s1);          // or\n            r2 = _mm_or_si128(d2, s2);          // or\n            r3 = _mm_or_si128(d3, s3);          // or\n\n            _mm_store_si128(dst, r0);           // store\n            _mm_store_si128(dst + 1, r1);       // store\n            _mm_store_si128(dst + 2, r2);       // store\n            _mm_store_si128(dst + 3, r3);       // store\n\n            dst += 4;\n            src += 1;\n        , width);\n        /* *INDENT-ON* */\n        src = (const __m128i *)((const Uint8 *)src + srcskip);\n        dst = (__m128i *)((Uint8 *)dst + dstskip);\n    }\n}\n#endif\n\n#if defined(HAVE_NEON_INTRINSICS)\n/* Apply: alpha_table[i] = i << 24; */\nstatic SDL_INLINE void BG_Blended_Opaque_NEON(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip)\n{\n    const Uint32 *src    = (Uint32 *)image->buffer;\n    Uint32       *dst    = destination;\n    Uint32        width  = image->width / 16;\n    Uint32        height = image->rows;\n\n    uint32x4_t s, d0, d1, d2, d3, r0, r1, r2, r3;\n    uint8x16x2_t sx, sx01, sx23;\n    uint32x4_t zero = vmovq_n_u32(0);\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            /* Read 4 Uint32 and put 16 Uint8 into uint32x4x2_t (uint8x16x2_t)\n             * takes advantage of vzipq_u8 which produces two lanes */\n\n            s   = vld1q_u32(src);               // load\n            d0  = vld1q_u32(dst);               // load\n            d1  = vld1q_u32(dst + 4);           // load\n            d2  = vld1q_u32(dst + 8);           // load\n            d3  = vld1q_u32(dst + 12);          // load\n\n            sx   = vzipq_u8(zero, s);           // interleave\n            sx01 = vzipq_u8(zero, sx.val[0]);   // interleave\n            sx23 = vzipq_u8(zero, sx.val[1]);   // interleave\n                                                // already shifted by 24\n            r0  = vorrq_u32(d0, sx01.val[0]);   // or\n            r1  = vorrq_u32(d1, sx01.val[1]);   // or\n            r2  = vorrq_u32(d2, sx23.val[0]);   // or\n            r3  = vorrq_u32(d3, sx23.val[1]);   // or\n\n            vst1q_u32(dst, r0);                 // store\n            vst1q_u32(dst + 4, r1);             // store\n            vst1q_u32(dst + 8, r2);             // store\n            vst1q_u32(dst + 12, r3);            // store\n\n            dst += 16;\n            src += 4;\n        , width);\n        /* *INDENT-ON* */\n        src = (const Uint32 *)((const Uint8 *)src + srcskip);\n        dst = (Uint32 *)((Uint8 *)dst + dstskip);\n    }\n}\n\n/* Non-opaque, computes alpha blending on the fly */\nstatic SDL_INLINE void BG_Blended_NEON(const TTF_Image *image, Uint32 *destination, Sint32 srcskip, Uint32 dstskip, Uint8 fg_alpha)\n{\n    const Uint32 *src    = (Uint32 *)image->buffer;\n    Uint32       *dst    = destination;\n    Uint32        width  = image->width / 16;\n    Uint32        height = image->rows;\n\n    uint32x4_t s, d0, d1, d2, d3, r0, r1, r2, r3;\n    uint16x8_t Ls8, Hs8;\n    uint8x16x2_t sx, sx01, sx23;\n\n    const uint16x8_t alpha = vmovq_n_u16(fg_alpha);\n    const uint16x8_t one   = vmovq_n_u16(1);\n    const uint32x4_t zero  = vmovq_n_u32(0);\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            /* Read 4 Uint32 and put 16 Uint8 into uint32x4x2_t (uint8x16x2_t)\n             * takes advantage of vzipq_u8 which produces two lanes */\n\n            s  = vld1q_u32(src);                        // load\n            d0 = vld1q_u32(dst);                        // load\n            d1 = vld1q_u32(dst + 4);                    // load\n            d2 = vld1q_u32(dst + 8);                    // load\n            d3 = vld1q_u32(dst + 12);                   // load\n\n            sx = vzipq_u8(s, zero);                     // interleave, no shifting\n                                                        // enough room to multiply\n\n            /* Apply: alpha_table[i] = ((i * fg.a / 255) << 24; */\n            /* Divide by 255 is done as:    (x + 1 + (x >> 8)) >> 8 */\n\n            sx.val[0] = vmulq_u16(sx.val[0], alpha);    // x := i * fg.a\n            sx.val[1] = vmulq_u16(sx.val[1], alpha);\n\n            Ls8 = vshrq_n_u16(sx.val[0], 8);            // x >> 8\n            Hs8 = vshrq_n_u16(sx.val[1], 8);\n\n            sx.val[0] = vaddq_u16(sx.val[0], one);      // x + 1\n            sx.val[1] = vaddq_u16(sx.val[1], one);\n\n            sx.val[0] = vaddq_u16(sx.val[0], Ls8);      // x + 1 + (x >> 8)\n            sx.val[1] = vaddq_u16(sx.val[1], Hs8);\n\n            sx.val[0] = vshrq_n_u16(sx.val[0], 8);      // ((x + 1 + (x >> 8)) >> 8\n            sx.val[1] = vshrq_n_u16(sx.val[1], 8);\n\n            sx.val[0] = vshlq_n_u16(sx.val[0], 8);      // shift << 8, so we're prepared\n            sx.val[1] = vshlq_n_u16(sx.val[1], 8);      // to have final format << 24\n\n            sx01 = vzipq_u8(zero, sx.val[0]);           // interleave\n            sx23 = vzipq_u8(zero, sx.val[1]);           // interleave\n                                                        // already shifted by 24\n\n            r0  = vorrq_u32(d0, sx01.val[0]);           // or\n            r1  = vorrq_u32(d1, sx01.val[1]);           // or\n            r2  = vorrq_u32(d2, sx23.val[0]);           // or\n            r3  = vorrq_u32(d3, sx23.val[1]);           // or\n\n            vst1q_u32(dst, r0);                         // store\n            vst1q_u32(dst + 4, r1);                     // store\n            vst1q_u32(dst + 8, r2);                     // store\n            vst1q_u32(dst + 12, r3);                    // store\n\n            dst += 16;\n            src += 4;\n        , width);\n        /* *INDENT-ON* */\n        src = (const Uint32 *)((const Uint8 *)src + srcskip);\n        dst = (Uint32 *)((Uint8 *)dst + dstskip);\n    }\n}\n#endif\n\nstatic SDL_INLINE void BG(const TTF_Image *image, Uint8 *destination, Sint32 srcskip, Uint32 dstskip)\n{\n    const Uint8 *src    = image->buffer;\n    Uint8       *dst    = destination;\n    Uint32       width  = image->width;\n    Uint32       height = image->rows;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            *dst++ |= *src++;\n        , width);\n        /* *INDENT-ON* */\n        src += srcskip;\n        dst += dstskip;\n    }\n}\n\n#if defined(HAVE_BLIT_GLYPH_64)\nstatic SDL_INLINE void BG_64(const TTF_Image *image, Uint8 *destination, Sint32 srcskip, Uint32 dstskip)\n{\n    const Uint64 *src    = (Uint64 *)image->buffer;\n    Uint64       *dst    = (Uint64 *)destination;\n    Uint32        width  = image->width / 8;\n    Uint32        height = image->rows;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            *dst++ |= *src++;\n        , width);\n        /* *INDENT-ON* */\n        src = (const Uint64 *)((const Uint8 *)src + srcskip);\n        dst = (Uint64 *)((Uint8 *)dst + dstskip);\n    }\n}\n#elif defined(HAVE_BLIT_GLYPH_32)\nstatic SDL_INLINE void BG_32(const TTF_Image *image, Uint8 *destination, Sint32 srcskip, Uint32 dstskip)\n{\n    const Uint32 *src    = (Uint32 *)image->buffer;\n    Uint32       *dst    = (Uint32 *)destination;\n    Uint32        width  = image->width / 4;\n    Uint32        height = image->rows;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            *dst++ |= *src++;\n        , width);\n        /* *INDENT-ON* */\n        src = (const Uint32 *)((const Uint8 *)src + srcskip);\n        dst = (Uint32 *)((Uint8 *)dst + dstskip);\n    }\n}\n#endif\n\n#if defined(HAVE_SSE2_INTRINSICS)\nstatic SDL_INLINE void BG_SSE(const TTF_Image *image, Uint8 *destination, Sint32 srcskip, Uint32 dstskip)\n{\n    const __m128i *src    = (__m128i *)image->buffer;\n    __m128i       *dst    = (__m128i *)destination;\n    Uint32         width  = image->width / 16;\n    Uint32         height = image->rows;\n\n    __m128i s, d, r;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            s = _mm_loadu_si128(src);   // load unaligned\n            d = _mm_load_si128(dst);    // load\n            r = _mm_or_si128(d, s);     // or\n            _mm_store_si128(dst, r);    // store\n            src += 1;\n            dst += 1;\n        , width);\n        /* *INDENT-ON* */\n        src = (const __m128i *)((const Uint8 *)src + srcskip);\n        dst = (__m128i *)((Uint8 *)dst + dstskip);\n    }\n}\n#endif\n\n#if defined(HAVE_NEON_INTRINSICS)\nstatic SDL_INLINE void BG_NEON(const TTF_Image *image, Uint8 *destination, Sint32 srcskip, Uint32 dstskip)\n{\n    const Uint8 *src    = image->buffer;\n    Uint8       *dst    = destination;\n    Uint32       width  = image->width / 16;\n    Uint32       height = image->rows;\n\n    uint8x16_t s, d, r;\n\n    while (height--) {\n        /* *INDENT-OFF* */\n        DUFFS_LOOP4(\n            s = vld1q_u8(src);  // load\n            d = vld1q_u8(dst);  // load\n            r = vorrq_u8(d, s); // or\n            vst1q_u8(dst, r);   // store\n            src += 16;\n            dst += 16;\n        , width);\n        /* *INDENT-ON* */\n        src = (const Uint8 *)((const Uint8 *)src + srcskip);\n        dst += dstskip;\n    }\n}\n#endif\n\n/* Underline and Strikethrough style. Draw a line at the given row. */\nstatic void Draw_Line(TTF_Font *font, const SDL_Surface *textbuf, int row, int line_width, int line_thickness, Uint32 color, const render_mode_t render_mode)\n{\n    int tmp    = row + line_thickness - textbuf->h;\n    Uint8 *dst = (Uint8 *)textbuf->pixels + row * textbuf->pitch;\n\n#if TTF_USE_HARFBUZZ\n    /* No Underline/Strikethrough style if direction is vertical */\n    if (font->hb_direction == HB_DIRECTION_TTB || font->hb_direction == HB_DIRECTION_BTT) {\n        return;\n    }\n#endif\n\n    /* Not needed because of \"font->height = SDL_max(font->height, bottom_row);\".\n     * But if you patch to render textshaping and break line in middle of a cluster,\n     * (which is a bad usage and a corner case), you need this to prevent out of bounds.\n     * You can get an \"ystart\" for the \"whole line\", which is different (and smaller)\n     * than the ones of the \"splitted lines\". */\n    if (tmp > 0) {\n        line_thickness -= tmp;\n    }\n\n    /* Wrapped mode with an unbroken line: 'line_width' is greater that 'textbuf->w' */\n    line_width = SDL_min(line_width, textbuf->w);\n\n    if (render_mode == RENDER_BLENDED) {\n        while (line_thickness--) {\n            SDL_memset4(dst, color, line_width);\n            dst += textbuf->pitch;\n        }\n    } else {\n        while (line_thickness--) {\n            SDL_memset(dst, color, line_width);\n            dst += textbuf->pitch;\n        }\n    }\n}\n\nstatic void clip_glyph(int *_x, int *_y, TTF_Image *image, const SDL_Surface *textbuf)\n{\n    int above_w;\n    int above_h;\n    int x = *_x;\n    int y = *_y;\n\n    int srcbpp = 1;\n    if (image->is_color) {\n        /* This isn't tested because colored image never ends up left clipped */\n        srcbpp = 4;\n    }\n\n    /* Don't go below x=0 */\n    if (x < 0) {\n        int tmp = -x;\n        x = 0;\n        image->width  -= tmp;\n        image->buffer += srcbpp * tmp;\n    }\n    /* Don't go above textbuf->w */\n    above_w = x + image->width - textbuf->w;\n    if (above_w > 0) {\n        image->width -= above_w;\n    }\n    /* Don't go below y=0 */\n    if (y < 0) {\n        int tmp = -y;\n        y = 0;\n        image->rows   -= tmp;\n        image->buffer += tmp * image->pitch;\n    }\n    /* Don't go above textbuf->h */\n    above_h = y + image->rows - textbuf->h;\n    if (above_h > 0) {\n        image->rows -= above_h;\n    }\n    /* Could be negative if (x > textbuf->w), or if (x + width < 0) */\n    image->width = SDL_max(0, image->width);\n    image->rows  = SDL_max(0, image->rows);\n\n    /* After 'image->width' clipping:\n     * Make sure 'rows' is also 0, so it doesn't break USE_DUFFS_LOOP */\n    if (image->width == 0) {\n        image->rows = 0;\n    }\n\n    *_x = x;\n    *_y = y;\n}\n\n/* Glyph width is rounded, dst addresses are aligned, src addresses are not aligned */\nstatic int Get_Alignement()\n{\n#if defined(HAVE_NEON_INTRINSICS)\n    if (hasNEON()) {\n        return 16;\n    }\n#endif\n\n#if defined(HAVE_SSE2_INTRINSICS)\n    if (hasSSE2()) {\n        return 16;\n    }\n#endif\n\n#if defined(HAVE_BLIT_GLYPH_64)\n    return 8;\n#elif defined(HAVE_BLIT_GLYPH_32)\n    return 4;\n#else\n    return 1;\n#endif\n}\n\n#ifdef __GNUC__\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-value\"\n#endif\n#define BUILD_RENDER_LINE(NAME, IS_BLENDED, IS_BLENDED_OPAQUE, WB_WP_WC, WS, BLIT_GLYPH_BLENDED_OPAQUE_OPTIM, BLIT_GLYPH_BLENDED_OPTIM, BLIT_GLYPH_OPTIM) \\\n                                                                                                                        \\\nstatic SDL_INLINE                                                                                                       \\\nint Render_Line_##NAME(TTF_Font *font, SDL_Surface *textbuf, int xstart, int ystart, Uint8 fg_alpha)                    \\\n{                                                                                                                       \\\n    const int alignment = Get_Alignement() - 1;                                                                         \\\n    const int bpp = ((IS_BLENDED) ? 4 : 1);                                                                             \\\n    unsigned int i;                                                                                                     \\\n    for (i = 0; i < font->pos_len; i++) {                                                                               \\\n        FT_UInt idx = font->pos_buf[i].index;                                                                           \\\n        int x       = font->pos_buf[i].x;                                                                               \\\n        int y       = font->pos_buf[i].y;                                                                               \\\n        TTF_Image *image;                                                                                               \\\n                                                                                                                        \\\n        if (Find_GlyphByIndex(font, idx, WB_WP_WC, WS, x & 63, NULL, &image) == 0) {                                    \\\n            int above_w, above_h;                                                                                       \\\n            Uint32 dstskip;                                                                                             \\\n            Sint32 srcskip; /* Can be negative */                                                                       \\\n            Uint8 *dst;                                                                                                 \\\n            int remainder;                                                                                              \\\n            Uint8 *saved_buffer = image->buffer;                                                                        \\\n            int saved_width = image->width;                                                                             \\\n            image->buffer += alignment;                                                                                 \\\n            /* Position updated after glyph rendering */                                                                \\\n            x = xstart + FT_FLOOR(x) + image->left;                                                                     \\\n            y = ystart + FT_FLOOR(y) - image->top;                                                                      \\\n                                                                                                                        \\\n            /* Make sure glyph is inside textbuf */                                                                     \\\n            above_w = x + image->width - textbuf->w;                                                                    \\\n            above_h = y + image->rows  - textbuf->h;                                                                    \\\n                                                                                                                        \\\n            if (x >= 0 && y >= 0 && above_w <= 0 && above_h <= 0) {                                                     \\\n                /* Most often, glyph is inside textbuf */                                                               \\\n                /* Compute dst */                                                                                       \\\n                dst  = (Uint8 *)textbuf->pixels + y * textbuf->pitch + x * bpp;                                         \\\n                /* Align dst, get remainder, shift & align glyph width */                                               \\\n                remainder = ((uintptr_t)dst & alignment) / bpp;                                                         \\\n                dst  = (Uint8 *)((uintptr_t)dst & ~alignment);                                                          \\\n                image->buffer -= remainder;                                                                             \\\n                image->width   = (image->width + remainder + alignment) & ~alignment;                                   \\\n                /* Compute srcskip, dstskip */                                                                          \\\n                srcskip = image->pitch - image->width;                                                                  \\\n                dstskip = textbuf->pitch - image->width * bpp;                                                          \\\n                /* Render glyph at (x, y) with optimized copy functions */                                              \\\n                if (!IS_BLENDED || image->is_color == 0) {                                                              \\\n                    if (IS_BLENDED_OPAQUE) {                                                                            \\\n                        BLIT_GLYPH_BLENDED_OPAQUE_OPTIM(image, (Uint32 *)dst, srcskip, dstskip);                        \\\n                    } else if (IS_BLENDED) {                                                                            \\\n                        BLIT_GLYPH_BLENDED_OPTIM(image, (Uint32 *)dst, srcskip, dstskip, fg_alpha);                     \\\n                    } else {                                                                                            \\\n                        BLIT_GLYPH_OPTIM(image, dst, srcskip, dstskip);                                                 \\\n                    }                                                                                                   \\\n                } else if (IS_BLENDED && image->is_color) {                                                             \\\n                    image->buffer = saved_buffer;                                                                       \\\n                    image->buffer += alignment;                                                                         \\\n                    image->width = saved_width;                                                                         \\\n                    dst = (Uint8 *)textbuf->pixels + y * textbuf->pitch + x * bpp;                                      \\\n                    /* Compute srcskip, dstskip */                                                                      \\\n                    srcskip = image->pitch - 4 * image->width;                                                          \\\n                    dstskip = textbuf->pitch - image->width * bpp;                                                      \\\n                    BG_Blended_Color(image, (Uint32 *)dst, srcskip, dstskip, fg_alpha);                                 \\\n                }                                                                                                       \\\n                /* restore modification */                                                                              \\\n                image->width = saved_width;                                                                             \\\n            } else {                                                                                                    \\\n                /* Modify a copy, and clip it */                                                                        \\\n                TTF_Image image_clipped = *image;                                                                       \\\n                /* Intersect image glyph at (x,y) with textbuf */                                                       \\\n                clip_glyph(&x, &y, &image_clipped, textbuf);                                                            \\\n                /* Compute dst */                                                                                       \\\n                dst = (Uint8 *)textbuf->pixels + y * textbuf->pitch + x * bpp;                                          \\\n                /* Compute srcskip, dstskip */                                                                          \\\n                srcskip = image_clipped.pitch - image_clipped.width;                                                    \\\n                dstskip = textbuf->pitch - image_clipped.width * bpp;                                                   \\\n                /* Render glyph at (x, y) */                                                                            \\\n                if (!IS_BLENDED || image->is_color == 0) {                                                              \\\n                    if (IS_BLENDED_OPAQUE) {                                                                            \\\n                        BG_Blended_Opaque(&image_clipped, (Uint32 *)dst, srcskip, dstskip);                             \\\n                    } else if (IS_BLENDED) {                                                                            \\\n                        BG_Blended(&image_clipped, (Uint32 *)dst, srcskip, dstskip, fg_alpha);                          \\\n                    } else {                                                                                            \\\n                        BG(&image_clipped, dst, srcskip, dstskip);                                                      \\\n                    }                                                                                                   \\\n                } else if (IS_BLENDED && image->is_color) {                                                             \\\n                    srcskip -= 3 * image_clipped.width;                                                                 \\\n                    BG_Blended_Color(&image_clipped, (Uint32 *)dst, srcskip, dstskip, fg_alpha);                        \\\n                }                                                                                                       \\\n            }                                                                                                           \\\n            image->buffer = saved_buffer;                                                                               \\\n        } else {                                                                                                        \\\n            return -1;                                                                                                  \\\n        }                                                                                                               \\\n    }                                                                                                                   \\\n                                                                                                                        \\\n    return 0;                                                                                                           \\\n}                                                                                                                       \\\n                                                                                                                        \\\n\n#define BITMAP  CACHED_BITMAP, 0, 0\n#define PIXMAP  0, CACHED_PIXMAP, 0\n#define COLOR   0, 0, CACHED_COLOR\n\n#define SUBPIX  CACHED_SUBPIX\n\n/* BUILD_RENDER_LINE(NAME, IS_BLENDED, IS_BLENDED_OPAQUE, WANT_BITMAP_PIXMAP_COLOR, WANT_SUBPIXEL, BLIT_GLYPH_BLENDED_OPAQUE_OPTIM, BLIT_GLYPH_BLENDED_OPTIM, BLIT_GLYPH_OPTIM) */\n\n#if defined(HAVE_SSE2_INTRINSICS)\nBUILD_RENDER_LINE(SSE_Shaded            , 0, 0, PIXMAP, 0     ,                       ,                , BG_SSE     )\nBUILD_RENDER_LINE(SSE_Blended           , 1, 0,  COLOR, 0     ,                       , BG_Blended_SSE ,            )\nBUILD_RENDER_LINE(SSE_Blended_Opaque    , 1, 1,  COLOR, 0     , BG_Blended_Opaque_SSE ,                ,            )\nBUILD_RENDER_LINE(SSE_Solid             , 0, 0, BITMAP, 0     ,                       ,                , BG_SSE     )\nBUILD_RENDER_LINE(SSE_Shaded_SP         , 0, 0, PIXMAP, SUBPIX,                       ,                , BG_SSE     )\nBUILD_RENDER_LINE(SSE_Blended_SP        , 1, 0,  COLOR, SUBPIX,                       , BG_Blended_SSE ,            )\nBUILD_RENDER_LINE(SSE_Blended_Opaque_SP , 1, 1,  COLOR, SUBPIX, BG_Blended_Opaque_SSE ,                ,            )\n#endif\n\n#if defined(HAVE_NEON_INTRINSICS)\nBUILD_RENDER_LINE(NEON_Shaded           , 0, 0, PIXMAP, 0     ,                       ,                , BG_NEON    )\nBUILD_RENDER_LINE(NEON_Blended          , 1, 0,  COLOR, 0     ,                       , BG_Blended_NEON,            )\nBUILD_RENDER_LINE(NEON_Blended_Opaque   , 1, 1,  COLOR, 0     , BG_Blended_Opaque_NEON,                ,            )\nBUILD_RENDER_LINE(NEON_Solid            , 0, 0, BITMAP, 0     ,                       ,                , BG_NEON    )\nBUILD_RENDER_LINE(NEON_Shaded_SP        , 0, 0, PIXMAP, SUBPIX,                       ,                , BG_NEON    )\nBUILD_RENDER_LINE(NEON_Blended_SP       , 1, 0,  COLOR, SUBPIX,                       , BG_Blended_NEON,            )\nBUILD_RENDER_LINE(NEON_Blended_Opaque_SP, 1, 1,  COLOR, SUBPIX, BG_Blended_Opaque_NEON,                ,            )\n#endif\n\n#if defined(HAVE_BLIT_GLYPH_64)\nBUILD_RENDER_LINE(64_Shaded             , 0, 0, PIXMAP, 0     ,                       ,                , BG_64      )\nBUILD_RENDER_LINE(64_Blended            , 1, 0,  COLOR, 0     ,                       , BG_Blended_32  ,            )\nBUILD_RENDER_LINE(64_Blended_Opaque     , 1, 1,  COLOR, 0     , BG_Blended_Opaque_32  ,                ,            )\nBUILD_RENDER_LINE(64_Solid              , 0, 0, BITMAP, 0     ,                       ,                , BG_64      )\nBUILD_RENDER_LINE(64_Shaded_SP          , 0, 0, PIXMAP, SUBPIX,                       ,                , BG_64      )\nBUILD_RENDER_LINE(64_Blended_SP         , 1, 0,  COLOR, SUBPIX,                       , BG_Blended_32  ,            )\nBUILD_RENDER_LINE(64_Blended_Opaque_SP  , 1, 1,  COLOR, SUBPIX, BG_Blended_Opaque_32  ,                ,            )\n#elif defined(HAVE_BLIT_GLYPH_32)\nBUILD_RENDER_LINE(32_Shaded             , 0, 0, PIXMAP, 0     ,                       ,                , BG_32      )\nBUILD_RENDER_LINE(32_Blended            , 1, 0,  COLOR, 0     ,                       , BG_Blended_32  ,            )\nBUILD_RENDER_LINE(32_Blended_Opaque     , 1, 1,  COLOR, 0     , BG_Blended_Opaque_32  ,                ,            )\nBUILD_RENDER_LINE(32_Solid              , 0, 0, BITMAP, 0     ,                       ,                , BG_32      )\nBUILD_RENDER_LINE(32_Shaded_SP          , 0, 0, PIXMAP, SUBPIX,                       ,                , BG_32      )\nBUILD_RENDER_LINE(32_Blended_SP         , 1, 0,  COLOR, SUBPIX,                       , BG_Blended_32  ,            )\nBUILD_RENDER_LINE(32_Blended_Opaque_SP  , 1, 1,  COLOR, SUBPIX, BG_Blended_Opaque_32  ,                ,            )\n#else\nBUILD_RENDER_LINE(8_Shaded              , 0, 0, PIXMAP, 0     ,                       ,                , BG         )\nBUILD_RENDER_LINE(8_Blended             , 1, 0,  COLOR, 0     ,                       , BG_Blended     ,            )\nBUILD_RENDER_LINE(8_Blended_Opaque      , 1, 1,  COLOR, 0     , BG_Blended_Opaque     ,                ,            )\nBUILD_RENDER_LINE(8_Solid               , 0, 0, BITMAP, 0     ,                       ,                , BG         )\nBUILD_RENDER_LINE(8_Shaded_SP           , 0, 0, PIXMAP, SUBPIX,                       ,                , BG         )\nBUILD_RENDER_LINE(8_Blended_SP          , 1, 0,  COLOR, SUBPIX,                       , BG_Blended     ,            )\nBUILD_RENDER_LINE(8_Blended_Opaque_SP   , 1, 1,  COLOR, SUBPIX, BG_Blended_Opaque     ,                ,            )\n#endif\n\n\n#if TTF_USE_SDF\nstatic int (*Render_Line_SDF_Shaded)(TTF_Font *font, SDL_Surface *textbuf, int xstart, int ystart, Uint8 fg_alpha) = NULL;\nBUILD_RENDER_LINE(SDF_Blended           , 1, 0,  COLOR, 0     ,                       , BG_Blended_SDF ,            )\nBUILD_RENDER_LINE(SDF_Blended_Opaque    , 1, 1,  COLOR, 0     , BG_Blended_Opaque_SDF ,                ,            )\nstatic int (*Render_Line_SDF_Solid)(TTF_Font *font, SDL_Surface *textbuf, int xstart, int ystart, Uint8 fg_alpha) = NULL;\nstatic int (*Render_Line_SDF_Shaded_SP)(TTF_Font *font, SDL_Surface *textbuf, int xstart, int ystart, Uint8 fg_alpha) = NULL;\nBUILD_RENDER_LINE(SDF_Blended_SP        , 1, 0,  COLOR, SUBPIX,                       , BG_Blended_SDF ,            )\nBUILD_RENDER_LINE(SDF_Blended_Opaque_SP , 1, 1,  COLOR, SUBPIX, BG_Blended_Opaque_SDF ,                ,            )\n#endif\n\n#ifdef __GNUC__\n#pragma GCC diagnostic pop\n#endif\n\nstatic SDL_INLINE int Render_Line(const render_mode_t render_mode, int subpixel, TTF_Font *font, SDL_Surface *textbuf, int xstart, int ystart, Uint8 fg_alpha)\n{\n    /* Render line (pos_buf) to textbuf at (xstart, ystart) */\n\n    /* Subpixel with RENDER_SOLID doesn't make sense. */\n    /* (and 'cached->subpixel.translation' would need to distinguish bitmap/pixmap). */\n\n    int is_opaque = (fg_alpha == SDL_ALPHA_OPAQUE);\n\n#define Call_Specific_Render_Line(NAME)                                                                     \\\n        if (render_mode == RENDER_SHADED) {                                                                 \\\n            if (subpixel == 0) {                                                                            \\\n                return Render_Line_##NAME##_Shaded(font, textbuf, xstart, ystart, 0);                       \\\n            } else {                                                                                        \\\n                return Render_Line_##NAME##_Shaded_SP(font, textbuf, xstart, ystart, 0);                    \\\n            }                                                                                               \\\n        } else if (render_mode == RENDER_BLENDED) {                                                         \\\n            if (is_opaque) {                                                                                \\\n                if (subpixel == 0) {                                                                        \\\n                    return Render_Line_##NAME##_Blended_Opaque(font, textbuf, xstart, ystart, 0);           \\\n                } else {                                                                                    \\\n                    return Render_Line_##NAME##_Blended_Opaque_SP(font, textbuf, xstart, ystart, 0);        \\\n                }                                                                                           \\\n            } else {                                                                                        \\\n                if (subpixel == 0) {                                                                        \\\n                    return Render_Line_##NAME##_Blended(font, textbuf, xstart, ystart, fg_alpha);           \\\n                } else {                                                                                    \\\n                    return Render_Line_##NAME##_Blended_SP(font, textbuf, xstart, ystart, fg_alpha);        \\\n                }                                                                                           \\\n            }                                                                                               \\\n        } else {                                                                                            \\\n            return Render_Line_##NAME##_Solid(font, textbuf, xstart, ystart, 0);                            \\\n        }\n\n#if TTF_USE_SDF\n    if (font->render_sdf && render_mode == RENDER_BLENDED) {\n        Call_Specific_Render_Line(SDF)\n    }\n#endif\n\n#if defined(HAVE_NEON_INTRINSICS)\n    if (hasNEON()) {\n        Call_Specific_Render_Line(NEON)\n    }\n#endif\n#if defined(HAVE_SSE2_INTRINSICS)\n    if (hasSSE2()) {\n        Call_Specific_Render_Line(SSE)\n    }\n#endif\n#if defined(HAVE_BLIT_GLYPH_64)\n    Call_Specific_Render_Line(64)\n#elif defined(HAVE_BLIT_GLYPH_32)\n    Call_Specific_Render_Line(32)\n#else\n    Call_Specific_Render_Line(8)\n#endif\n}\n\nstatic SDL_Surface* Create_Surface_Solid(int width, int height, SDL_Color fg, Uint32 *color)\n{\n    const int alignment = Get_Alignement() - 1;\n    SDL_Surface *textbuf;\n    Sint64 size;\n\n    /* Create a surface with memory:\n     * - pitch is rounded to alignment\n     * - adress is aligned\n     */\n    void *pixels, *ptr;\n    /* Worse case at the end of line pulling 'alignment' extra blank pixels */\n    Sint64 pitch = (Sint64)width + (Sint64)alignment;\n    pitch += alignment;\n    pitch &= ~alignment;\n    size = height * pitch + sizeof (void *) + alignment;\n    if (size < 0 || size > SDL_MAX_SINT32) {\n        /* Overflow... */\n        return NULL;\n    }\n\n    ptr = SDL_malloc((size_t)size);\n    if (ptr == NULL) {\n        return NULL;\n    }\n\n    /* address is aligned */\n    pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment);\n    ((void **)pixels)[-1] = ptr;\n\n    textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_INDEX8);\n    if (textbuf == NULL) {\n        SDL_free(ptr);\n        return NULL;\n    }\n\n    /* Let SDL handle the memory allocation */\n    textbuf->flags &= ~SDL_PREALLOC;\n    textbuf->flags |= SDL_SIMD_ALIGNED;\n\n    /* Initialize with background to 0 */\n    SDL_memset(pixels, 0, height * pitch);\n\n    /* Underline/Strikethrough color style */\n    *color = 1;\n\n    /* Fill the palette: 1 is foreground */\n    {\n        SDL_Palette *palette = textbuf->format->palette;\n        palette->colors[0].r = 255 - fg.r;\n        palette->colors[0].g = 255 - fg.g;\n        palette->colors[0].b = 255 - fg.b;\n        palette->colors[1].r = fg.r;\n        palette->colors[1].g = fg.g;\n        palette->colors[1].b = fg.b;\n        palette->colors[1].a = fg.a;\n    }\n\n    SDL_SetColorKey(textbuf, SDL_TRUE, 0);\n\n    return textbuf;\n}\n\nstatic SDL_Surface* Create_Surface_Shaded(int width, int height, SDL_Color fg, SDL_Color bg, Uint32 *color)\n{\n    const int alignment = Get_Alignement() - 1;\n    SDL_Surface *textbuf;\n    Sint64 size;\n    Uint8 bg_alpha = bg.a;\n\n    /* Create a surface with memory:\n     * - pitch is rounded to alignment\n     * - adress is aligned\n     */\n    void *pixels, *ptr;\n    /* Worse case at the end of line pulling 'alignment' extra blank pixels */\n    Sint64 pitch = (Sint64)width + (Sint64)alignment;\n    pitch += alignment;\n    pitch &= ~alignment;\n    size = height * pitch + sizeof (void *) + alignment;\n    if (size < 0 || size > SDL_MAX_SINT32) {\n        /* Overflow... */\n        return NULL;\n    }\n\n    ptr = SDL_malloc((size_t)size);\n    if (ptr == NULL) {\n        return NULL;\n    }\n\n    /* address is aligned */\n    pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment);\n    ((void **)pixels)[-1] = ptr;\n\n    textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_INDEX8);\n    if (textbuf == NULL) {\n        SDL_free(ptr);\n        return NULL;\n    }\n\n    /* Let SDL handle the memory allocation */\n    textbuf->flags &= ~SDL_PREALLOC;\n    textbuf->flags |= SDL_SIMD_ALIGNED;\n\n    /* Initialize with background to 0 */\n    SDL_memset(pixels, 0, height * pitch);\n\n    /* Underline/Strikethrough color style */\n    *color = NUM_GRAYS - 1;\n\n    /* Support alpha blending */\n    if (fg.a != SDL_ALPHA_OPAQUE || bg.a != SDL_ALPHA_OPAQUE) {\n        SDL_SetSurfaceBlendMode(textbuf, SDL_BLENDMODE_BLEND);\n\n        /* Would disturb alpha palette */\n        if (bg.a == SDL_ALPHA_OPAQUE) {\n            bg.a = 0;\n        }\n    }\n\n    /* Fill the palette with NUM_GRAYS levels of shading from bg to fg */\n    {\n        SDL_Palette *palette = textbuf->format->palette;\n        int rdiff  = fg.r - bg.r;\n        int gdiff  = fg.g - bg.g;\n        int bdiff  = fg.b - bg.b;\n        int adiff  = fg.a - bg.a;\n        int sign_r = (rdiff >= 0) ? 1 : 255;\n        int sign_g = (gdiff >= 0) ? 1 : 255;\n        int sign_b = (bdiff >= 0) ? 1 : 255;\n        int sign_a = (adiff >= 0) ? 1 : 255;\n        int i;\n\n        for (i = 0; i < NUM_GRAYS; ++i) {\n            /* Compute color[i] = (i * color_diff / 255) */\n            int tmp_r = i * rdiff;\n            int tmp_g = i * gdiff;\n            int tmp_b = i * bdiff;\n            int tmp_a = i * adiff;\n            palette->colors[i].r = (Uint8)(bg.r + DIVIDE_BY_255_SIGNED(tmp_r, sign_r));\n            palette->colors[i].g = (Uint8)(bg.g + DIVIDE_BY_255_SIGNED(tmp_g, sign_g));\n            palette->colors[i].b = (Uint8)(bg.b + DIVIDE_BY_255_SIGNED(tmp_b, sign_b));\n            palette->colors[i].a = (Uint8)(bg.a + DIVIDE_BY_255_SIGNED(tmp_a, sign_a));\n        }\n\n        /* Make sure background has the correct alpha value */\n        palette->colors[0].a = bg_alpha;\n    }\n\n    return textbuf;\n}\n\nstatic SDL_Surface *Create_Surface_Blended(int width, int height, SDL_Color fg, Uint32 *color)\n{\n    const int alignment = Get_Alignement() - 1;\n    SDL_Surface *textbuf = NULL;\n    Uint32 bgcolor;\n\n    /* Background color */\n    bgcolor = (fg.r << 16) | (fg.g << 8) | fg.b;\n\n    /* Underline/Strikethrough color style */\n    *color = bgcolor | (fg.a << 24);\n\n    /* Create the target surface if required */\n    if (width != 0) {\n        /* Create a surface with memory:\n         * - pitch is rounded to alignment\n         * - adress is aligned\n         */\n        Sint64 size;\n        void *pixels, *ptr;\n        /* Worse case at the end of line pulling 'alignment' extra blank pixels */\n        Sint64 pitch = ((Sint64)width + (Sint64)alignment) * 4;\n        pitch += alignment;\n        pitch &= ~alignment;\n        size = height * pitch + sizeof (void *) + alignment;\n        if (size < 0 || size > SDL_MAX_SINT32) {\n            /* Overflow... */\n            return NULL;\n        }\n\n        ptr = SDL_malloc((size_t)size);\n        if (ptr == NULL) {\n            return NULL;\n        }\n\n        /* address is aligned */\n        pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment);\n        ((void **)pixels)[-1] = ptr;\n\n        textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_ARGB8888);\n        if (textbuf == NULL) {\n            SDL_free(ptr);\n            return NULL;\n        }\n\n        /* Let SDL handle the memory allocation */\n        textbuf->flags &= ~SDL_PREALLOC;\n        textbuf->flags |= SDL_SIMD_ALIGNED;\n\n        /* Initialize with fg and 0 alpha */\n        SDL_memset4(pixels, bgcolor, (height * pitch) / 4);\n\n        /* Support alpha blending */\n        if (fg.a != SDL_ALPHA_OPAQUE) {\n            SDL_SetSurfaceBlendMode(textbuf, SDL_BLENDMODE_BLEND);\n        }\n    }\n\n    return textbuf;\n}\n\n/* rcg06192001 get linked library's version. */\nconst SDL_version* TTF_Linked_Version(void)\n{\n    static SDL_version linked_version;\n    SDL_TTF_VERSION(&linked_version);\n    return &linked_version;\n}\n\n/* This function tells the library whether UNICODE text is generally\n   byteswapped.  A UNICODE BOM character at the beginning of a string\n   will override this setting for that string.  */\nvoid TTF_ByteSwappedUNICODE(SDL_bool swapped)\n{\n    TTF_byteswapped = swapped;\n}\n\n#if defined(USE_FREETYPE_ERRORS)\nstatic void TTF_SetFTError(const char *msg, FT_Error error)\n{\n#undef FTERRORS_H_\n#define FT_ERRORDEF(e, v, s)    { e, s },\n#define FT_ERROR_START_LIST     {\n#define FT_ERROR_END_LIST       { 0, NULL } };\n    const struct\n    {\n      int          err_code;\n      const char  *err_msg;\n    } ft_errors[] =\n#include FT_ERRORS_H\n\n    unsigned int i;\n    const char *err_msg = NULL;\n\n    for (i = 0; i < sizeof (ft_errors) / sizeof (ft_errors[0]); ++i) {\n        if (error == ft_errors[i].err_code) {\n            err_msg = ft_errors[i].err_msg;\n            break;\n        }\n    }\n    if (!err_msg) {\n        err_msg = \"unknown FreeType error\";\n    }\n    TTF_SetError(\"%s: %s\", msg, err_msg);\n}\n#else\n#define TTF_SetFTError(msg, error)    TTF_SetError(msg)\n#endif /* USE_FREETYPE_ERRORS */\n\nint TTF_Init(void)\n{\n    int status = 0;\n\n/* Some debug to know how it gets compiled */\n#if 0\n    int duffs = 0, sse2 = 0, neon = 0, compil_sse2 = 0, compil_neon = 0;\n#  if defined(USE_DUFFS_LOOP)\n    duffs = 1;\n#  endif\n#  if defined(HAVE_SSE2_INTRINSICS)\n    sse2 = hasSSE2();\n    compil_sse2 = 1;\n#  endif\n#  if defined(HAVE_NEON_INTRINSICS)\n    neon = hasNEON();\n    compil_neon = 1;\n#  endif\n    SDL_Log(\"SDL_ttf: hasSSE2=%d hasNEON=%d alignment=%d duffs_loop=%d compil_sse2=%d compil_neon=%d\",\n            sse2, neon, Get_Alignement(), duffs, compil_sse2, compil_neon);\n\n    SDL_Log(\"Sizeof TTF_Image: %d c_glyph: %d TTF_Font: %d\", sizeof (TTF_Image), sizeof (c_glyph), sizeof (TTF_Font));\n#endif\n\n    if (!TTF_initialized) {\n        FT_Error error = FT_Init_FreeType(&library);\n        if (error) {\n            TTF_SetFTError(\"Couldn't init FreeType engine\", error);\n            status = -1;\n        }\n    }\n    if (status == 0) {\n        ++TTF_initialized;\n#if TTF_USE_SDF\n#  if 0\n        /* Set various properties of the renderers. */\n        int spread = 4;\n        int overlaps = 0;\n        FT_Property_Set( library, \"bsdf\", \"spread\", &spread);\n        FT_Property_Set( library, \"sdf\", \"spread\", &spread);\n        FT_Property_Set( library, \"sdf\", \"overlaps\", &overlaps);\n#  endif\n#endif\n    }\n    return status;\n}\n\nSDL_COMPILE_TIME_ASSERT(FT_Int, sizeof(int) == sizeof(FT_Int)); /* just in case. */\nvoid TTF_GetFreeTypeVersion(int *major, int *minor, int *patch)\n{\n    FT_Library_Version(library, major, minor, patch);\n}\n\nvoid TTF_GetHarfBuzzVersion(int *major, int *minor, int *patch)\n{\n    unsigned int hb_major = 0;\n    unsigned int hb_minor = 0;\n    unsigned int hb_micro = 0;\n\n#if TTF_USE_HARFBUZZ\n    hb_version(&hb_major, &hb_minor, &hb_micro);\n#endif\n    if (major) {\n        *major = (int)hb_major;\n    }\n    if (minor) {\n        *minor = (int)hb_minor;\n    }\n    if (patch) {\n        *patch = (int)hb_micro;\n    }\n}\n\nstatic unsigned long RWread(\n    FT_Stream stream,\n    unsigned long offset,\n    unsigned char *buffer,\n    unsigned long count\n)\n{\n    SDL_RWops *src;\n\n    src = (SDL_RWops *)stream->descriptor.pointer;\n    SDL_RWseek(src, (int)offset, RW_SEEK_SET);\n    if (count == 0) {\n        return 0;\n    }\n    return (unsigned long)SDL_RWread(src, buffer, 1, (int)count);\n}\n\nTTF_Font* TTF_OpenFontIndexDPIRW(SDL_RWops *src, int freesrc, int ptsize, long index, unsigned int hdpi, unsigned int vdpi)\n{\n    TTF_Font *font;\n    FT_Error error;\n    FT_Face face;\n    FT_Stream stream;\n    FT_CharMap found;\n    Sint64 position;\n    int i;\n\n    if (!TTF_initialized) {\n        TTF_SetError(\"Library not initialized\");\n        if (src && freesrc) {\n            SDL_RWclose(src);\n        }\n        return NULL;\n    }\n\n    if (!src) {\n        TTF_SetError(\"Passed a NULL font source\");\n        return NULL;\n    }\n\n    /* Check to make sure we can seek in this stream */\n    position = SDL_RWtell(src);\n    if (position < 0) {\n        TTF_SetError(\"Can't seek in stream\");\n        if (freesrc) {\n            SDL_RWclose(src);\n        }\n        return NULL;\n    }\n\n    font = (TTF_Font *)SDL_malloc(sizeof (*font));\n    if (font == NULL) {\n        TTF_SetError(\"Out of memory\");\n        if (freesrc) {\n            SDL_RWclose(src);\n        }\n        return NULL;\n    }\n    SDL_memset(font, 0, sizeof (*font));\n\n    font->src = src;\n    font->freesrc = freesrc;\n\n    stream = (FT_Stream)SDL_malloc(sizeof (*stream));\n    if (stream == NULL) {\n        TTF_SetError(\"Out of memory\");\n        TTF_CloseFont(font);\n        return NULL;\n    }\n    SDL_memset(stream, 0, sizeof (*stream));\n\n    stream->read = RWread;\n    stream->descriptor.pointer = src;\n    stream->pos = (unsigned long)position;\n    stream->size = (unsigned long)(SDL_RWsize(src) - position);\n\n    font->args.flags = FT_OPEN_STREAM;\n    font->args.stream = stream;\n\n    error = FT_Open_Face(library, &font->args, index, &font->face);\n    if (error || font->face == NULL) {\n        TTF_SetFTError(\"Couldn't load font file\", error);\n        TTF_CloseFont(font);\n        return NULL;\n    }\n    face = font->face;\n\n    /* Set charmap for loaded font */\n    found = 0;\n#if 0 /* Font debug code */\n    for (i = 0; i < face->num_charmaps; i++) {\n        FT_CharMap charmap = face->charmaps[i];\n        SDL_Log(\"Found charmap: platform id %d, encoding id %d\", charmap->platform_id, charmap->encoding_id);\n    }\n#endif\n    if (!found) {\n        for (i = 0; i < face->num_charmaps; i++) {\n            FT_CharMap charmap = face->charmaps[i];\n            if (charmap->platform_id == 3 && charmap->encoding_id == 10) { /* UCS-4 Unicode */\n                found = charmap;\n                break;\n            }\n        }\n    }\n    if (!found) {\n        for (i = 0; i < face->num_charmaps; i++) {\n            FT_CharMap charmap = face->charmaps[i];\n            if ((charmap->platform_id == 3 && charmap->encoding_id == 1) /* Windows Unicode */\n             || (charmap->platform_id == 3 && charmap->encoding_id == 0) /* Windows Symbol */\n             || (charmap->platform_id == 2 && charmap->encoding_id == 1) /* ISO Unicode */\n             || (charmap->platform_id == 0)) { /* Apple Unicode */\n                found = charmap;\n                break;\n            }\n        }\n    }\n    if (found) {\n        /* If this fails, continue using the default charmap */\n        FT_Set_Charmap(face, found);\n    }\n\n    /* Set the default font style */\n    font->style = TTF_STYLE_NORMAL;\n    font->outline_val = 0;\n    font->ft_load_target = FT_LOAD_TARGET_NORMAL;\n    TTF_SetFontKerning(font, 1);\n\n    font->pos_len = 0;\n    font->pos_max = 16;\n    font->pos_buf = (PosBuf_t *)SDL_malloc(font->pos_max * sizeof (font->pos_buf[0]));\n    if (! font->pos_buf) {\n        TTF_SetError(\"Out of memory\");\n        TTF_CloseFont(font);\n        return NULL;\n    }\n\n#if TTF_USE_HARFBUZZ\n    font->hb_font = hb_ft_font_create(face, NULL);\n    if (font->hb_font == NULL) {\n        TTF_SetError(\"Cannot create harfbuzz font\");\n        TTF_CloseFont(font);\n        return NULL;\n    }\n\n    /* Default load-flags of hb_ft_font_create is no-hinting.\n     * So unless you call hb_ft_font_set_load_flags to match what flags you use for rendering,\n     * you will get mismatching advances and raster. */\n    hb_ft_font_set_load_flags(font->hb_font, FT_LOAD_DEFAULT | font->ft_load_target);\n\n    /* Default value script / direction */\n    TTF_SetFontScript(font, g_hb_script);\n    TTF_SetFontDirection(font, g_hb_direction);\n#endif\n\n    if (TTF_SetFontSizeDPI(font, ptsize, hdpi, vdpi) < 0) {\n        TTF_SetFTError(\"Couldn't set font size\", error);\n        TTF_CloseFont(font);\n        return NULL;\n    }\n    return font;\n}\n\nint TTF_SetFontSizeDPI(TTF_Font *font, int ptsize, unsigned int hdpi, unsigned int vdpi)\n{\n    FT_Face face = font->face;\n    FT_Error error;\n\n    /* Make sure that our font face is scalable (global metrics) */\n    if (FT_IS_SCALABLE(face)) {\n        /* Set the character size using the provided DPI.  If a zero DPI\n         * is provided, then the other DPI setting will be used.  If both\n         * are zero, then Freetype's default 72 DPI will be used.  */\n        error = FT_Set_Char_Size(face, 0, ptsize * 64, hdpi, vdpi);\n        if (error) {\n            TTF_SetFTError(\"Couldn't set font size\", error);\n            return -1;\n        }\n    } else {\n        /* Non-scalable font case.  ptsize determines which family\n         * or series of fonts to grab from the non-scalable format.\n         * It is not the point size of the font.  */\n        if (face->num_fixed_sizes <= 0) {\n            TTF_SetError(\"Couldn't select size : no num_fixed_sizes\");\n            return -1;\n        }\n\n        /* within [0; num_fixed_sizes - 1] */\n        ptsize = SDL_max(ptsize, 0);\n        ptsize = SDL_min(ptsize, face->num_fixed_sizes - 1);\n\n        error = FT_Select_Size(face, ptsize);\n        if (error) {\n            TTF_SetFTError(\"Couldn't select size\", error);\n            return -1;\n        }\n    }\n\n    if (TTF_initFontMetrics(font) < 0) {\n        TTF_SetError(\"Cannot initialize metrics\");\n        return -1;\n    }\n\n    Flush_Cache(font);\n\n#if TTF_USE_HARFBUZZ\n    /* Call when size or variations settings on underlying FT_Face change. */\n    hb_ft_font_changed(font->hb_font);\n#endif\n\n    return 0;\n}\n\nint TTF_SetFontSize(TTF_Font *font, int ptsize)\n{\n    return TTF_SetFontSizeDPI(font, ptsize, 0, 0);\n}\n\n/* Update font parameter depending on a style change */\nstatic int TTF_initFontMetrics(TTF_Font *font)\n{\n    FT_Face face = font->face;\n    int underline_offset;\n\n    /* Make sure that our font face is scalable (global metrics) */\n    if (FT_IS_SCALABLE(face)) {\n        /* Get the scalable font metrics for this font */\n        FT_Fixed scale       = face->size->metrics.y_scale;\n        font->ascent         = FT_CEIL(FT_MulFix(face->ascender, scale));\n        font->descent        = FT_CEIL(FT_MulFix(face->descender, scale));\n        font->height         = FT_CEIL(FT_MulFix(face->ascender - face->descender, scale));\n        font->lineskip       = FT_CEIL(FT_MulFix(face->height, scale));\n        underline_offset     = FT_FLOOR(FT_MulFix(face->underline_position, scale));\n        font->line_thickness = FT_FLOOR(FT_MulFix(face->underline_thickness, scale));\n    } else {\n        /* Get the font metrics for this font, for the selected size */\n        font->ascent         = FT_CEIL(face->size->metrics.ascender);\n        font->descent        = FT_CEIL(face->size->metrics.descender);\n        font->height         = FT_CEIL(face->size->metrics.height);\n        font->lineskip       = FT_CEIL(face->size->metrics.height);\n        /* face->underline_position and face->underline_height are only\n         * relevant for scalable formats (see freetype.h FT_FaceRec) */\n        underline_offset     = font->descent / 2;\n        font->line_thickness = 1;\n    }\n\n    if (font->line_thickness < 1) {\n        font->line_thickness = 1;\n    }\n\n    font->underline_top_row     = font->ascent - underline_offset - 1;\n    font->strikethrough_top_row = font->height / 2;\n\n    /* Adjust OutlineStyle, only for scalable fonts */\n    /* TTF_Size(): increase w and h by 2 * outline_val, translate positionning by 1 * outline_val */\n    if (font->outline_val > 0) {\n        int fo = font->outline_val;\n        font->line_thickness        += 2 * fo;\n        font->underline_top_row     -= fo;\n        font->strikethrough_top_row -= fo;\n    }\n\n    /* Robustness: no negative values allowed */\n    font->underline_top_row     = SDL_max(0, font->underline_top_row);\n    font->strikethrough_top_row = SDL_max(0, font->strikethrough_top_row);\n\n    /* Update height according to the needs of the underline style */\n    if (TTF_HANDLE_STYLE_UNDERLINE(font)) {\n        int bottom_row = font->underline_top_row + font->line_thickness;\n        font->height = SDL_max(font->height, bottom_row);\n    }\n    /* Update height according to the needs of the strikethrough style */\n    if (TTF_HANDLE_STYLE_STRIKETHROUGH(font)) {\n        int bottom_row = font->strikethrough_top_row + font->line_thickness;\n        font->height = SDL_max(font->height, bottom_row);\n    }\n\n#if defined(DEBUG_FONTS)\n    SDL_Log(\"Font metrics:\");\n    SDL_Log(\"ascent = %d, descent = %d\", font->ascent, font->descent);\n    SDL_Log(\"height = %d, lineskip = %d\", font->height, font->lineskip);\n    SDL_Log(\"underline_offset = %d, line_thickness = %d\", underline_offset, font->line_thickness);\n    SDL_Log(\"underline_top_row = %d, strikethrough_top_row = %d\", font->underline_top_row, font->strikethrough_top_row);\n    SDL_Log(\"scalable=%d fixed_sizes=%d\", FT_IS_SCALABLE(face), FT_HAS_FIXED_SIZES(face));\n#endif\n\n    font->glyph_overhang = face->size->metrics.y_ppem / 10;\n\n    return 0;\n}\n\nTTF_Font* TTF_OpenFontDPIRW( SDL_RWops *src, int freesrc, int ptsize, unsigned int hdpi, unsigned int vdpi )\n{\n    return TTF_OpenFontIndexDPIRW(src, freesrc, ptsize, 0, hdpi, vdpi);\n}\n\nTTF_Font* TTF_OpenFontIndexRW( SDL_RWops *src, int freesrc, int ptsize, long index )\n{\n    return TTF_OpenFontIndexDPIRW(src, freesrc, ptsize, index, 0, 0);\n}\n\nTTF_Font* TTF_OpenFontIndexDPI( const char *file, int ptsize, long index, unsigned int hdpi, unsigned int vdpi )\n{\n    SDL_RWops *rw = SDL_RWFromFile(file, \"rb\");\n    if ( rw == NULL ) {\n        return NULL;\n    }\n    return TTF_OpenFontIndexDPIRW(rw, 1, ptsize, index, hdpi, vdpi);\n}\n\nTTF_Font* TTF_OpenFontRW(SDL_RWops *src, int freesrc, int ptsize)\n{\n    return TTF_OpenFontIndexRW(src, freesrc, ptsize, 0);\n}\n\nTTF_Font* TTF_OpenFontDPI(const char *file, int ptsize, unsigned int hdpi, unsigned int vdpi)\n{\n    return TTF_OpenFontIndexDPI(file, ptsize, 0, hdpi, vdpi);\n}\n\nTTF_Font* TTF_OpenFontIndex(const char *file, int ptsize, long index)\n{\n    return TTF_OpenFontIndexDPI(file, ptsize, index, 0, 0);\n}\n\nTTF_Font* TTF_OpenFont(const char *file, int ptsize)\n{\n    return TTF_OpenFontIndex(file, ptsize, 0);\n}\n\nstatic void Flush_Glyph_Image(TTF_Image *image) {\n    if (image->buffer) {\n        SDL_free(image->buffer);\n        image->buffer = NULL;\n    }\n}\n\nstatic void Flush_Glyph(c_glyph *glyph)\n{\n    glyph->stored = 0;\n    glyph->index = 0;\n    Flush_Glyph_Image(&glyph->pixmap);\n    Flush_Glyph_Image(&glyph->bitmap);\n}\n\nstatic void Flush_Cache(TTF_Font *font)\n{\n    int i;\n    int size = sizeof (font->cache) / sizeof (font->cache[0]);\n\n    for (i = 0; i < size; ++i) {\n        if (font->cache[i].stored) {\n            Flush_Glyph(&font->cache[i]);\n        }\n    }\n}\n\nstatic FT_Error Load_Glyph(TTF_Font *font, c_glyph *cached, int want, int translation)\n{\n    const int alignment = Get_Alignement() - 1;\n    FT_GlyphSlot slot;\n    FT_Error error;\n\n    int ft_load = FT_LOAD_DEFAULT | font->ft_load_target;\n\n#if TTF_USE_COLOR\n    if (want & CACHED_COLOR) {\n        ft_load |= FT_LOAD_COLOR;\n    }\n#endif\n\n    error = FT_Load_Glyph(font->face, cached->index, ft_load);\n    if (error) {\n        goto ft_failure;\n    }\n\n    /* Get our glyph shortcut */\n    slot = font->face->glyph;\n\n    /* Get the glyph metrics, always needed */\n    if (cached->stored == 0) {\n        cached->sz_left  = slot->bitmap_left;\n        cached->sz_top   = slot->bitmap_top;\n        cached->sz_rows  = slot->bitmap.rows;\n        cached->sz_width = slot->bitmap.width;\n\n        /* Current version of freetype is 2.9.1, but on older freetype (2.8.1) this can be 0.\n         * Try to get them from 'FT_Glyph_Metrics' */\n        if (cached->sz_left == 0 && cached->sz_top == 0 && cached->sz_rows == 0 && cached->sz_width == 0) {\n            FT_Glyph_Metrics *metrics = &slot->metrics;\n            if (metrics) {\n                int minx = FT_FLOOR(metrics->horiBearingX);\n                int maxx = FT_CEIL(metrics->horiBearingX + metrics->width);\n                int maxy = FT_FLOOR(metrics->horiBearingY);\n                int miny = maxy - FT_CEIL(metrics->height);\n\n                cached->sz_left  = minx;\n                cached->sz_top   = maxy;\n                cached->sz_rows  = maxy - miny;\n                cached->sz_width = maxx - minx;\n            }\n        }\n\n        /* All FP 26.6 are 'long' but 'int' should be engouh */\n        cached->advance  = (int)slot->metrics.horiAdvance; /* FP 26.6 */\n\n        if (font->render_subpixel == 0) {\n            /* FT KERNING_MODE_SMART */\n            cached->kerning_smart.rsb_delta = (int)slot->rsb_delta; /* FP 26.6 */\n            cached->kerning_smart.lsb_delta = (int)slot->lsb_delta; /* FP 26.6 */\n        } else {\n            /* FT LCD_MODE_LIGHT_SUBPIXEL */\n            cached->subpixel.lsb_minus_rsb  = (int)(slot->lsb_delta - slot->rsb_delta); /* FP 26.6 */\n            cached->subpixel.translation    = 0; /* FP 26.6 */\n        }\n\n#if defined(DEBUG_FONTS)\n        SDL_Log(\"Index=%d sz_left=%d sz_top=%d sz_width=%d sz_rows=%d advance=%d is_outline=%d is_bitmap=%d\",\n                cached->index, cached->sz_left, cached->sz_top, cached->sz_width, cached->sz_rows, cached->advance,\n                slot->format == FT_GLYPH_FORMAT_OUTLINE, slot->format == FT_GLYPH_FORMAT_BITMAP);\n#endif\n\n        /* Adjust for bold text */\n        if (TTF_HANDLE_STYLE_BOLD(font)) {\n            cached->sz_width += font->glyph_overhang;\n            cached->advance  += F26Dot6(font->glyph_overhang);\n        }\n\n        /* Adjust for italic text */\n        if (TTF_HANDLE_STYLE_ITALIC(font) && slot->format == FT_GLYPH_FORMAT_OUTLINE) {\n            cached->sz_width += (GLYPH_ITALICS * font->height) >> 16;\n        }\n\n        /* Adjust for subpixel */\n        if (font->render_subpixel) {\n            cached->sz_width += 1;\n        }\n\n        /* Adjust for SDF */\n        if (font->render_sdf) {\n            /* Default 'spread' property */\n            cached->sz_width += 2 * 8;\n            cached->sz_rows  += 2 * 8;\n        }\n\n\n        cached->stored |= CACHED_METRICS;\n    }\n\n    if (((want & CACHED_BITMAP) && !(cached->stored & CACHED_BITMAP)) ||\n        ((want & CACHED_PIXMAP) && !(cached->stored & CACHED_PIXMAP)) ||\n        ((want & CACHED_COLOR) && !(cached->stored & CACHED_COLOR)) ||\n         (want & CACHED_SUBPIX)\n       ) {\n        const int  mono  = (want & CACHED_BITMAP);\n        TTF_Image *dst   = (mono ? &cached->bitmap : &cached->pixmap);\n        FT_Glyph   glyph = NULL;\n        FT_Bitmap *src;\n        FT_Render_Mode ft_render_mode;\n\n        if (mono) {\n            ft_render_mode = FT_RENDER_MODE_MONO;\n        } else {\n            ft_render_mode = FT_RENDER_MODE_NORMAL;\n#if TTF_USE_SDF\n            if ((want & CACHED_COLOR) && font->render_sdf) {\n                ft_render_mode = FT_RENDER_MODE_SDF;\n            }\n#endif\n        }\n\n        /* Subpixel translation, flush previous datas */\n        if (want & CACHED_SUBPIX) {\n            Flush_Glyph_Image(&cached->pixmap);\n            FT_Outline_Translate(&slot->outline, translation, 0 );\n            cached->subpixel.translation = translation;\n        }\n\n        /* Handle the italic style, only for scalable fonts */\n        if (TTF_HANDLE_STYLE_ITALIC(font) && slot->format == FT_GLYPH_FORMAT_OUTLINE) {\n            FT_Matrix shear;\n            shear.xx = 1 << 16;\n            shear.xy = GLYPH_ITALICS;\n            shear.yx = 0;\n            shear.yy = 1 << 16;\n            FT_Outline_Transform(&slot->outline, &shear);\n        }\n\n        /* Render as outline */\n        if ((font->outline_val > 0 && slot->format == FT_GLYPH_FORMAT_OUTLINE)\n            || slot->format == FT_GLYPH_FORMAT_BITMAP) {\n\n            FT_BitmapGlyph bitmap_glyph;\n\n            error = FT_Get_Glyph(slot, &glyph);\n            if (error) {\n                goto ft_failure;\n            }\n\n            if (font->outline_val > 0) {\n                FT_Stroker stroker;\n                error = FT_Stroker_New(library, &stroker);\n                if (error) {\n                    goto ft_failure;\n                }\n                FT_Stroker_Set(stroker, font->outline_val * 64, FT_STROKER_LINECAP_ROUND, FT_STROKER_LINEJOIN_ROUND, 0);\n                FT_Glyph_Stroke(&glyph, stroker, 1 /* delete the original glyph */);\n                FT_Stroker_Done(stroker);\n            }\n\n            /* Render the glyph */\n            error = FT_Glyph_To_Bitmap(&glyph, ft_render_mode, 0, 1);\n            if (error) {\n                FT_Done_Glyph(glyph);\n                goto ft_failure;\n            }\n\n            /* Access bitmap content by typecasting */\n            bitmap_glyph = (FT_BitmapGlyph) glyph;\n            src          = &bitmap_glyph->bitmap;\n\n            /* Get new metrics, from bitmap */\n            dst->left   = bitmap_glyph->left;\n            dst->top    = bitmap_glyph->top;\n        } else {\n            /* Render the glyph */\n            error = FT_Render_Glyph(slot, ft_render_mode);\n            if (error) {\n                goto ft_failure;\n            }\n\n            /* Access bitmap from slot */\n            src         = &slot->bitmap;\n\n            /* Get new metrics, from slot */\n            dst->left   = slot->bitmap_left;\n            dst->top    = slot->bitmap_top;\n        }\n\n        /* Common metrics */\n        dst->width  = src->width;\n        dst->rows   = src->rows;\n        dst->buffer = NULL;\n\n        /* FT can make small size glyph of 'width == 0', and 'rows != 0'.\n         * Make sure 'rows' is also 0, so it doesn't break USE_DUFFS_LOOP */\n        if (dst->width == 0) {\n            dst->rows = 0;\n        }\n\n        /* Adjust for bold text */\n        if (TTF_HANDLE_STYLE_BOLD(font)) {\n            dst->width += font->glyph_overhang;\n        }\n\n        /* Compute pitch: glyph is padded right to be able to read an 'aligned' size expanding on the right */\n        dst->pitch = dst->width + alignment;\n#if TTF_USE_COLOR\n        if (src->pixel_mode == FT_PIXEL_MODE_BGRA) {\n            dst->pitch += 3 * dst->width;\n        }\n#endif\n\n        if (dst->rows != 0) {\n            unsigned int i;\n\n            /* Glyph buffer is NOT aligned,\n             * Extra width so it can read an 'aligned' size expanding on the left */\n            dst->buffer = (unsigned char *)SDL_malloc(alignment + dst->pitch * dst->rows);\n\n            if (!dst->buffer) {\n                error = FT_Err_Out_Of_Memory;\n                goto ft_failure;\n            }\n\n            /* Memset */\n            SDL_memset(dst->buffer, 0, alignment + dst->pitch * dst->rows);\n\n            /* Shift, so that the glyph is decoded centered */\n            dst->buffer += alignment;\n\n            /* FT_Render_Glyph() and .fon fonts always generate a two-color (black and white)\n             * glyphslot surface, even when rendered in FT_RENDER_MODE_NORMAL. */\n            /* FT_IS_SCALABLE() means that the face contains outline glyphs, but does not imply\n             * that outline is rendered as 8-bit grayscale, because embedded bitmap/graymap is\n             * preferred (see FT_LOAD_DEFAULT section of FreeType2 API Reference).\n             * FT_Render_Glyph() canreturn two-color bitmap or 4/16/256 color graymap\n             * according to the format of embedded bitmap/graymap. */\n            for (i = 0; i < (unsigned int)src->rows; i++) {\n                unsigned char *srcp = src->buffer + i * src->pitch;\n                unsigned char *dstp = dst->buffer + i * dst->pitch;\n                unsigned int k, quotient, remainder;\n\n                /* Decode exactly the needed size from src->width */\n                if (src->pixel_mode == FT_PIXEL_MODE_MONO) {\n                    quotient  = src->width / 8;\n                    remainder = src->width & 0x7;\n                } else if (src->pixel_mode == FT_PIXEL_MODE_GRAY2) {\n                    quotient  = src->width / 4;\n                    remainder = src->width & 0x3;\n                } else if (src->pixel_mode == FT_PIXEL_MODE_GRAY4) {\n                    quotient  = src->width / 2;\n                    remainder = src->width & 0x1;\n#if TTF_USE_COLOR\n                } else if (src->pixel_mode == FT_PIXEL_MODE_BGRA) {\n                    quotient  = src->width;\n                    remainder = 0;\n#endif\n                } else {\n                    quotient  = src->width;\n                    remainder = 0;\n                }\n\n/* FT_RENDER_MODE_MONO and src->pixel_mode MONO */\n#ifdef _WIN32\n#pragma warning(push, 1)\n#pragma warning(disable:4127)\n#endif\n#define MONO_MONO(K_MAX)                                                    \\\n                if ((K_MAX)) {                                              \\\n                    unsigned char c = *srcp++;                              \\\n                    for (k = 0; k < (K_MAX); ++k) {                         \\\n                        *dstp++ = (c & 0x80) >> 7;                          \\\n                        c <<= 1;                                            \\\n                    }                                                       \\\n                }\n\n/* FT_RENDER_MODE_MONO and src->pixel_mode GRAY2 */\n#define MONO_GRAY2(K_MAX)                                                   \\\n                if ((K_MAX)) {                                              \\\n                    unsigned char c = *srcp++;                              \\\n                    for (k = 0; k < (K_MAX); ++k) {                         \\\n                        *dstp++ = (((c&0xA0) >> 6) >= 0x2) ? 1 : 0;         \\\n                        c <<= 2;                                            \\\n                    }                                                       \\\n                }\n\n/* FT_RENDER_MODE_MONO and src->pixel_mode GRAY4 */\n#define MONO_GRAY4(K_MAX)                                                   \\\n                if ((K_MAX)) {                                              \\\n                    unsigned char c = *srcp++;                              \\\n                    for (k = 0; k < (K_MAX); ++k) {                         \\\n                        *dstp++ = (((c&0xF0) >> 4) >= 0x8) ? 1 : 0;         \\\n                        c <<= 4;                                            \\\n                    }                                                       \\\n                }\n\n/* FT_RENDER_MODE_NORMAL and src->pixel_mode MONO */\n#define NORMAL_MONO(K_MAX)                                                  \\\n                if ((K_MAX)) {                                              \\\n                    unsigned char c = *srcp++;                              \\\n                    for (k = 0; k < (K_MAX); ++k) {                         \\\n                        if ((c&0x80) >> 7) {                                \\\n                            *dstp++ = NUM_GRAYS - 1;                        \\\n                        } else {                                            \\\n                            *dstp++ = 0x00;                                 \\\n                        }                                                   \\\n                        c <<= 1;                                            \\\n                    }                                                       \\\n                }\n\n/* FT_RENDER_MODE_NORMAL and src->pixel_mode GRAY2 */\n#define NORMAL_GRAY2(K_MAX)                                                 \\\n                if ((K_MAX)) {                                              \\\n                    unsigned char c = *srcp++;                              \\\n                    for (k = 0; k < (K_MAX); ++k) {                         \\\n                        if ((c&0xA0) >> 6) {                                \\\n                            *dstp++ = NUM_GRAYS * ((c&0xA0) >> 6) / 3 - 1;  \\\n                        } else {                                            \\\n                            *dstp++ = 0x00;                                 \\\n                        }                                                   \\\n                        c <<= 2;                                            \\\n                    }                                                       \\\n                }\n\n/* FT_RENDER_MODE_NORMAL and src->pixel_mode GRAY4 */\n#define NORMAL_GRAY4(K_MAX)                                                 \\\n                if ((K_MAX)) {                                              \\\n                    unsigned char c = *srcp++;                              \\\n                    for (k = 0; k < (K_MAX); ++k) {                         \\\n                        if ((c&0xF0) >> 4) {                                \\\n                            *dstp++ = NUM_GRAYS * ((c&0xF0) >> 4) / 15 - 1; \\\n                        } else {                                            \\\n                            *dstp++ = 0x00;                                 \\\n                        }                                                   \\\n                        c <<= 4;                                            \\\n                    }                                                       \\\n                }\n\n\n\n                if (mono) {\n                    if (src->pixel_mode == FT_PIXEL_MODE_MONO) {\n                        while (quotient--) {\n                            MONO_MONO(8);\n                        }\n                        MONO_MONO(remainder);\n                    } else if (src->pixel_mode == FT_PIXEL_MODE_GRAY2) {\n                        while (quotient--) {\n                            MONO_GRAY2(4);\n                        }\n                        MONO_GRAY2(remainder);\n                    } else if (src->pixel_mode == FT_PIXEL_MODE_GRAY4) {\n                        while (quotient--) {\n                            MONO_GRAY4(2);\n                        }\n                        MONO_GRAY4(remainder);\n                    } else {\n                        while (quotient--) {\n                            unsigned char c = *srcp++;\n                            *dstp++ = (c >= 0x80) ? 1 : 0;\n                        }\n                    }\n                } else if (src->pixel_mode == FT_PIXEL_MODE_MONO) {\n                    /* This special case wouldn't be here if the FT_Render_Glyph()\n                     * function wasn't buggy when it tried to render a .fon font with 256\n                     * shades of gray.  Instead, it returns a black and white surface\n                     * and we have to translate it back to a 256 gray shaded surface. */\n                    while (quotient--) {\n                        NORMAL_MONO(8);\n                    }\n                    NORMAL_MONO(remainder);\n                } else if (src->pixel_mode == FT_PIXEL_MODE_GRAY2) {\n                    while (quotient--) {\n                        NORMAL_GRAY2(4);\n                    }\n                    NORMAL_GRAY2(remainder);\n                } else if (src->pixel_mode == FT_PIXEL_MODE_GRAY4) {\n                    while (quotient--) {\n                        NORMAL_GRAY4(2);\n                    }\n                    NORMAL_GRAY4(remainder);\n#if TTF_USE_COLOR\n                } else if (src->pixel_mode == FT_PIXEL_MODE_BGRA) {\n                    SDL_memcpy(dstp, srcp, 4 * src->width);\n#endif\n                } else {\n#if TTF_USE_SDF\n                    if (ft_render_mode != FT_RENDER_MODE_SDF) {\n                        SDL_memcpy(dstp, srcp, src->width);\n                    } else {\n                        int x;\n                        for (x = 0; x < src->width; x++) {\n                            Uint8 s = srcp[x];\n                            Uint8 d;\n                            if (s < 128) {\n                                d = 256 - (128 - s) * 2;\n                            } else {\n                                d = 255;\n                                /* some glitch ?\n                                if (s == 255) {\n                                    d = 0;\n                                }*/\n                            }\n                            dstp[x] = d;\n                        }\n                    }\n#else\n                    SDL_memcpy(dstp, srcp, src->width);\n#endif\n                }\n            }\n        }\n#ifdef _WIN32\n#pragma warning(pop)\n#endif\n\n        /* Handle the bold style */\n        if (TTF_HANDLE_STYLE_BOLD(font)) {\n            int row;\n            /* The pixmap is a little hard, we have to add and clamp */\n            for (row = dst->rows - 1; row >= 0; --row) {\n                Uint8 *pixmap = dst->buffer + row * dst->pitch;\n                int col, offset;\n                /* Minimal memset */\n                /* SDL_memset(pixmap + dst->width - font->glyph_overhang, 0, font->glyph_overhang); */\n                for (offset = 1; offset <= font->glyph_overhang; ++offset) {\n                    for (col = dst->width - 1; col > 0; --col) {\n                        if (mono) {\n                            pixmap[col] |= pixmap[col-1];\n                        } else {\n                            int pixel = (pixmap[col] + pixmap[col-1]);\n                            if (pixel > NUM_GRAYS - 1) {\n                                pixel = NUM_GRAYS - 1;\n                            }\n                            pixmap[col] = (Uint8) pixel;\n                        }\n                    }\n                }\n            }\n        }\n\n        /* Shift back */\n        if (dst->buffer) {\n            dst->buffer -= alignment;\n        }\n\n#if TTF_USE_COLOR\n        if (src->pixel_mode == FT_PIXEL_MODE_BGRA) {\n            dst->is_color = 1;\n        } else {\n            dst->is_color = 0;\n        }\n#else\n        dst->is_color = 0;\n#endif\n\n        /* Mark that we rendered this format */\n        if (mono) {\n            cached->stored |= CACHED_BITMAP;\n        } else {\n#if TTF_USE_COLOR\n            if (want & CACHED_COLOR) {\n                cached->stored |= CACHED_COLOR;\n                /* Most of the time, glyphs loaded with FT_LOAD_COLOR are non colored, so the cache is\n                   also suitable for Shaded rendering (eg, loaded without FT_LOAD_COLOR) */\n                if (dst->is_color == 0) {\n                    cached->stored |= CACHED_PIXMAP;\n                }\n            } else {\n                cached->stored |= CACHED_PIXMAP;\n                /* If font has no color information, Shaded/Pixmap cache is also suitable for Blend/Color */\n                if (!FT_HAS_COLOR(font->face)) {\n                    cached->stored |= CACHED_COLOR;\n                }\n            }\n#else\n            cached->stored |= CACHED_COLOR | CACHED_PIXMAP;\n#endif\n        }\n\n        /* Free outlined glyph */\n        if (glyph) {\n            FT_Done_Glyph(glyph);\n        }\n    }\n\n    /* We're done, this glyph is cached since 'stored' is not 0 */\n    return 0;\n\nft_failure:\n    TTF_SetFTError(\"Couldn't find glyph\", error);\n    return -1;\n}\n\nstatic SDL_INLINE int Find_GlyphByIndex(TTF_Font *font, FT_UInt idx,\n        int want_bitmap, int want_pixmap, int want_color, int want_subpixel,\n        int translation, c_glyph **out_glyph, TTF_Image **out_image)\n{\n    /* cache size is 256, get key by masking */\n    c_glyph *glyph = &font->cache[idx & 0xff];\n\n    if (out_glyph) {\n        *out_glyph = glyph;\n    }\n\n    if (want_pixmap || want_color) {\n        *out_image = &glyph->pixmap;\n    }\n\n    if (want_bitmap) {\n        *out_image = &glyph->bitmap;\n    }\n\n    if (want_subpixel)\n    {\n        /* No a real cache, but if it always advances by integer pixels (eg translation 0 or same as previous),\n         * this allows to render as fast as normal mode. */\n        int retval;\n        int want = CACHED_METRICS | want_bitmap | want_pixmap | want_color | want_subpixel;\n\n        if (glyph->stored && glyph->index != idx) {\n            Flush_Glyph(glyph);\n        }\n\n        if (glyph->subpixel.translation == translation) {\n            want &= ~CACHED_SUBPIX;\n        }\n\n        if ((glyph->stored & want) == want) {\n            return 0;\n        }\n\n        glyph->index = idx;\n        retval = Load_Glyph(font, glyph, want, translation);\n        if (retval == 0) {\n            return 0;\n        } else {\n            return -1;\n        }\n    }\n    else\n    {\n        int retval;\n        const int want = CACHED_METRICS | want_bitmap | want_pixmap | want_color;\n\n        /* Faster check as it gets inlined */\n        if (want_pixmap) {\n            if ((glyph->stored & CACHED_PIXMAP) && glyph->index == idx) {\n                return 0;\n            }\n        } else if (want_bitmap) {\n            if ((glyph->stored & CACHED_BITMAP) && glyph->index == idx) {\n                return 0;\n            }\n        } else if (want_color) {\n            if ((glyph->stored & CACHED_COLOR) && glyph->index == idx) {\n                return 0;\n            }\n        } else {\n            /* Get metrics */\n            if (glyph->stored && glyph->index == idx) {\n                return 0;\n            }\n        }\n\n        /* Cache cannot contain both PIXMAP and COLOR (unless COLOR is actually not colored). \n           So, if it's already used, clear it */\n        if (want_color || want_pixmap) {\n            if (glyph->stored & (CACHED_COLOR|CACHED_PIXMAP)) {\n                Flush_Glyph(glyph);\n            }\n        }\n\n        if (glyph->stored && glyph->index != idx) {\n            Flush_Glyph(glyph);\n        }\n\n        glyph->index = idx;\n        retval = Load_Glyph(font, glyph, want, 0);\n        if (retval == 0) {\n            return 0;\n        } else {\n            return -1;\n        }\n    }\n}\n\nstatic SDL_INLINE FT_UInt get_char_index(TTF_Font *font, Uint32 ch)\n{\n    Uint32 cache_index_size = sizeof (font->cache_index) / sizeof (font->cache_index[0]);\n\n    if (ch < cache_index_size) {\n        FT_UInt idx = font->cache_index[ch];\n        if (idx) {\n            return idx;\n        }\n        idx = FT_Get_Char_Index(font->face, ch);\n        font->cache_index[ch] = idx;\n        return idx;\n    }\n\n    return FT_Get_Char_Index(font->face, ch);\n}\n\n\nstatic SDL_INLINE int Find_GlyphMetrics(TTF_Font *font, Uint32 ch, c_glyph **out_glyph)\n{\n    FT_UInt idx = get_char_index(font, ch);\n    return Find_GlyphByIndex(font, idx, 0, 0, 0, 0, 0, out_glyph, NULL);\n}\n\nvoid TTF_CloseFont(TTF_Font *font)\n{\n    if (font) {\n#if TTF_USE_HARFBUZZ\n        hb_font_destroy(font->hb_font);\n#endif\n        Flush_Cache(font);\n        if (font->face) {\n            FT_Done_Face(font->face);\n        }\n        if (font->args.stream) {\n            SDL_free(font->args.stream);\n        }\n        if (font->freesrc) {\n            SDL_RWclose(font->src);\n        }\n        if (font->pos_buf) {\n            SDL_free(font->pos_buf);\n        }\n        SDL_free(font);\n    }\n}\n\n/* Gets the number of bytes needed to convert a Latin-1 string to UTF-8 */\nstatic size_t LATIN1_to_UTF8_len(const char *text)\n{\n    size_t bytes = 1;\n    while (*text) {\n        Uint8 ch = *(const Uint8 *)text++;\n        if (ch <= 0x7F) {\n            bytes += 1;\n        } else {\n            bytes += 2;\n        }\n    }\n    return bytes;\n}\n\n/* Gets the number of bytes needed to convert a UCS2 string to UTF-8 */\nstatic size_t UCS2_to_UTF8_len(const Uint16 *text)\n{\n    size_t bytes = 1;\n    while (*text) {\n        Uint16 ch = *text++;\n        if (ch <= 0x7F) {\n            bytes += 1;\n        } else if (ch <= 0x7FF) {\n            bytes += 2;\n        } else {\n            bytes += 3;\n        }\n    }\n    return bytes;\n}\n\n/* Convert a Latin-1 string to a UTF-8 string */\nstatic void LATIN1_to_UTF8(const char *src, Uint8 *dst)\n{\n    while (*src) {\n        Uint8 ch = *(const Uint8 *)src++;\n        if (ch <= 0x7F) {\n            *dst++ = ch;\n        } else {\n            *dst++ = 0xC0 | ((ch >> 6) & 0x1F);\n            *dst++ = 0x80 | (ch & 0x3F);\n        }\n    }\n    *dst = '\\0';\n}\n\n/* Convert a UCS-2 string to a UTF-8 string */\nstatic void UCS2_to_UTF8(const Uint16 *src, Uint8 *dst)\n{\n    SDL_bool swapped = TTF_byteswapped;\n\n    while (*src) {\n        Uint16 ch = *src++;\n        if (ch == UNICODE_BOM_NATIVE) {\n            swapped = SDL_FALSE;\n            continue;\n        }\n        if (ch == UNICODE_BOM_SWAPPED) {\n            swapped = SDL_TRUE;\n            continue;\n        }\n        if (swapped) {\n            ch = SDL_Swap16(ch);\n        }\n        if (ch <= 0x7F) {\n            *dst++ = (Uint8) ch;\n        } else if (ch <= 0x7FF) {\n            *dst++ = 0xC0 | (Uint8) ((ch >> 6) & 0x1F);\n            *dst++ = 0x80 | (Uint8) (ch & 0x3F);\n        } else {\n            *dst++ = 0xE0 | (Uint8) ((ch >> 12) & 0x0F);\n            *dst++ = 0x80 | (Uint8) ((ch >> 6) & 0x3F);\n            *dst++ = 0x80 | (Uint8) (ch & 0x3F);\n        }\n    }\n    *dst = '\\0';\n}\n\n/* Convert a unicode char to a UTF-8 string */\nstatic SDL_bool Char_to_UTF8(Uint32 ch, Uint8 *dst)\n{\n    if (ch <= 0x7F) {\n        *dst++ = (Uint8) ch;\n    } else if (ch <= 0x7FF) {\n        *dst++ = 0xC0 | (Uint8) ((ch >> 6) & 0x1F);\n        *dst++ = 0x80 | (Uint8) (ch & 0x3F);\n    } else if (ch <= 0xFFFF) {\n        *dst++ = 0xE0 | (Uint8) ((ch >> 12) & 0x0F);\n        *dst++ = 0x80 | (Uint8) ((ch >> 6) & 0x3F);\n        *dst++ = 0x80 | (Uint8) (ch & 0x3F);\n    } else if (ch <= 0x1FFFFF) {\n        *dst++ = 0xF0 | (Uint8) ((ch >> 18) & 0x07);\n        *dst++ = 0x80 | (Uint8) ((ch >> 12) & 0x3F);\n        *dst++ = 0x80 | (Uint8) ((ch >> 6) & 0x3F);\n        *dst++ = 0x80 | (Uint8) (ch & 0x3F);\n    } else if (ch <= 0x3FFFFFF) {\n        *dst++ = 0xF8 | (Uint8) ((ch >> 24) & 0x03);\n        *dst++ = 0x80 | (Uint8) ((ch >> 18) & 0x3F);\n        *dst++ = 0x80 | (Uint8) ((ch >> 12) & 0x3F);\n        *dst++ = 0x80 | (Uint8) ((ch >> 6) & 0x3F);\n        *dst++ = 0x80 | (Uint8) (ch & 0x3F);\n    } else if (ch < 0x7FFFFFFF) {\n        *dst++ = 0xFC | (Uint8) ((ch >> 30) & 0x01);\n        *dst++ = 0x80 | (Uint8) ((ch >> 24) & 0x3F);\n        *dst++ = 0x80 | (Uint8) ((ch >> 18) & 0x3F);\n        *dst++ = 0x80 | (Uint8) ((ch >> 12) & 0x3F);\n        *dst++ = 0x80 | (Uint8) ((ch >> 6) & 0x3F);\n        *dst++ = 0x80 | (Uint8) (ch & 0x3F);\n    } else {\n        TTF_SetError(\"Invalid character\");\n        return SDL_FALSE;\n    }\n    *dst = '\\0';\n    return SDL_TRUE;\n}\n\n/* Gets a unicode value from a UTF-8 encoded string\n * Ouputs increment to advance the string */\n#define UNKNOWN_UNICODE 0xFFFD\nstatic Uint32 UTF8_getch(const char *src, size_t srclen, int *inc)\n{\n    const Uint8 *p = (const Uint8 *)src;\n    size_t left = 0;\n    size_t save_srclen = srclen;\n    SDL_bool overlong = SDL_FALSE;\n    SDL_bool underflow = SDL_FALSE;\n    Uint32 ch = UNKNOWN_UNICODE;\n\n    if (srclen == 0) {\n        return UNKNOWN_UNICODE;\n    }\n    if (p[0] >= 0xFC) {\n        if ((p[0] & 0xFE) == 0xFC) {\n            if (p[0] == 0xFC && (p[1] & 0xFC) == 0x80) {\n                overlong = SDL_TRUE;\n            }\n            ch = (Uint32) (p[0] & 0x01);\n            left = 5;\n        }\n    } else if (p[0] >= 0xF8) {\n        if ((p[0] & 0xFC) == 0xF8) {\n            if (p[0] == 0xF8 && (p[1] & 0xF8) == 0x80) {\n                overlong = SDL_TRUE;\n            }\n            ch = (Uint32) (p[0] & 0x03);\n            left = 4;\n        }\n    } else if (p[0] >= 0xF0) {\n        if ((p[0] & 0xF8) == 0xF0) {\n            if (p[0] == 0xF0 && (p[1] & 0xF0) == 0x80) {\n                overlong = SDL_TRUE;\n            }\n            ch = (Uint32) (p[0] & 0x07);\n            left = 3;\n        }\n    } else if (p[0] >= 0xE0) {\n        if ((p[0] & 0xF0) == 0xE0) {\n            if (p[0] == 0xE0 && (p[1] & 0xE0) == 0x80) {\n                overlong = SDL_TRUE;\n            }\n            ch = (Uint32) (p[0] & 0x0F);\n            left = 2;\n        }\n    } else if (p[0] >= 0xC0) {\n        if ((p[0] & 0xE0) == 0xC0) {\n            if ((p[0] & 0xDE) == 0xC0) {\n                overlong = SDL_TRUE;\n            }\n            ch = (Uint32) (p[0] & 0x1F);\n            left = 1;\n        }\n    } else {\n        if ((p[0] & 0x80) == 0x00) {\n            ch = (Uint32) p[0];\n        }\n    }\n    --srclen;\n    while (left > 0 && srclen > 0) {\n        ++p;\n        if ((p[0] & 0xC0) != 0x80) {\n            ch = UNKNOWN_UNICODE;\n            break;\n        }\n        ch <<= 6;\n        ch |= (p[0] & 0x3F);\n        --srclen;\n        --left;\n    }\n    if (left > 0) {\n        underflow = SDL_TRUE;\n    }\n    /* Technically overlong sequences are invalid and should not be interpreted.\n       However, it doesn't cause a security risk here and I don't see any harm in\n       displaying them. The application is responsible for any other side effects\n       of allowing overlong sequences (e.g. string compares failing, etc.)\n       See bug 1931 for sample input that triggers this.\n    */\n    /* if (overlong) return UNKNOWN_UNICODE; */\n\n    (void) overlong;\n\n    if (underflow ||\n        (ch >= 0xD800 && ch <= 0xDFFF) ||\n        (ch == 0xFFFE || ch == 0xFFFF) || ch > 0x10FFFF) {\n        ch = UNKNOWN_UNICODE;\n    }\n\n    *inc = (int)(save_srclen - srclen);\n\n    return ch;\n}\n\nint TTF_FontHeight(const TTF_Font *font)\n{\n    return font->height;\n}\n\nint TTF_FontAscent(const TTF_Font *font)\n{\n    return font->ascent + 2 * font->outline_val;\n}\n\nint TTF_FontDescent(const TTF_Font *font)\n{\n    return font->descent;\n}\n\nint TTF_FontLineSkip(const TTF_Font *font)\n{\n    return font->lineskip;\n}\n\nint TTF_GetFontKerning(const TTF_Font *font)\n{\n    return font->allow_kerning;\n}\n\nvoid TTF_SetFontKerning(TTF_Font *font, int allowed)\n{\n    font->allow_kerning = allowed;\n    font->use_kerning   = allowed && FT_HAS_KERNING(font->face);\n}\n\nlong TTF_FontFaces(const TTF_Font *font)\n{\n    return font->face->num_faces;\n}\n\nint TTF_FontFaceIsFixedWidth(const TTF_Font *font)\n{\n    return FT_IS_FIXED_WIDTH(font->face);\n}\n\nchar* TTF_FontFaceFamilyName(const TTF_Font *font)\n{\n    return font->face->family_name;\n}\n\nchar* TTF_FontFaceStyleName(const TTF_Font *font)\n{\n    return font->face->style_name;\n}\n\nint TTF_GlyphIsProvided(TTF_Font *font, Uint16 ch)\n{\n    return (int)get_char_index(font, ch);\n}\n\nint TTF_GlyphIsProvided32(TTF_Font *font, Uint32 ch)\n{\n    return (int)get_char_index(font, ch);\n}\n\nint TTF_GlyphMetrics(TTF_Font *font, Uint16 ch,\n                     int *minx, int *maxx, int *miny, int *maxy, int *advance)\n{\n    return TTF_GlyphMetrics32(font, ch, minx, maxx, miny, maxy, advance);\n}\n\nint TTF_GlyphMetrics32(TTF_Font *font, Uint32 ch,\n                     int *minx, int *maxx, int *miny, int *maxy, int *advance)\n{\n    c_glyph *glyph;\n\n    TTF_CHECK_POINTER(font, -1);\n\n    if (Find_GlyphMetrics(font, ch, &glyph) < 0) {\n        return -1;\n    }\n\n    if (minx) {\n        *minx = glyph->sz_left;\n    }\n    if (maxx) {\n        *maxx = glyph->sz_left + glyph->sz_width;\n        *maxx += 2 * font->outline_val;\n    }\n    if (miny) {\n        *miny = glyph->sz_top - glyph->sz_rows;\n    }\n    if (maxy) {\n        *maxy = glyph->sz_top;\n        *maxy += 2 * font->outline_val;\n    }\n    if (advance) {\n        *advance = FT_CEIL(glyph->advance);\n    }\n    return 0;\n}\n\nint TTF_SetFontDirection(TTF_Font *font, int direction) /* hb_direction_t */\n{\n#if TTF_USE_HARFBUZZ\n    font->hb_direction = direction;\n    return 0;\n#else\n    (void) direction;\n    return -1;\n#endif\n}\n\nint TTF_SetFontScript(TTF_Font *font, int script) /* hb_script_t */\n{\n#if TTF_USE_HARFBUZZ\n    font->hb_script = script;\n    return 0;\n#else\n    (void) script;\n    return -1;\n#endif\n}\n\nstatic int TTF_Size_Internal(TTF_Font *font,\n        const char *text, const str_type_t str_type,\n        int *w, int *h, int *xstart, int *ystart,\n        int measure_width, int *extent, int *count)\n{\n    int x = 0;\n    int pos_x, pos_y;\n    int minx = 0, maxx = 0;\n    int miny = 0, maxy = 0;\n    Uint8 *utf8_alloc = NULL;\n    c_glyph *glyph;\n#if TTF_USE_HARFBUZZ\n    hb_buffer_t *hb_buffer = NULL;\n    unsigned int g;\n    unsigned int glyph_count;\n    hb_glyph_info_t *hb_glyph_info;\n    hb_glyph_position_t *hb_glyph_position;\n    int y = 0;\n#else\n    size_t textlen;\n    int skip_first = 1;\n    FT_UInt prev_index = 0;\n    FT_Pos  prev_delta = 0;\n#endif\n    int prev_advance = 0;\n\n    /* Measurement mode */\n    int char_count = 0;\n    int current_width = 0;\n\n    TTF_CHECK_INITIALIZED(-1);\n    TTF_CHECK_POINTER(font, -1);\n    TTF_CHECK_POINTER(text, -1);\n\n    /* Convert input string to default encoding UTF-8 */\n    if (str_type == STR_TEXT) {\n        utf8_alloc = SDL_stack_alloc(Uint8, LATIN1_to_UTF8_len(text));\n        if (utf8_alloc == NULL) {\n            SDL_OutOfMemory();\n            goto failure;\n        }\n        LATIN1_to_UTF8(text, utf8_alloc);\n        text = (const char *)utf8_alloc;\n    } else if (str_type == STR_UNICODE) {\n        const Uint16 *text16 = (const Uint16 *) text;\n        utf8_alloc = SDL_stack_alloc(Uint8, UCS2_to_UTF8_len(text16));\n        if (utf8_alloc == NULL) {\n            SDL_OutOfMemory();\n            goto failure;\n        }\n        UCS2_to_UTF8(text16, utf8_alloc);\n        text = (const char *)utf8_alloc;\n    }\n\n    maxy = font->height;\n\n    /* Reset buffer */\n    font->pos_len = 0;\n\n#if TTF_USE_HARFBUZZ\n    /* Create a buffer for harfbuzz to use */\n    hb_buffer = hb_buffer_create();\n    if (hb_buffer == NULL) {\n       TTF_SetError(\"Cannot create harfbuzz buffer\");\n       goto failure;\n    }\n\n    /* Set global configuration */\n    hb_buffer_set_direction(hb_buffer, font->hb_direction);\n    hb_buffer_set_script(hb_buffer, font->hb_script);\n\n    /* Layout the text */\n    hb_buffer_add_utf8(hb_buffer, text, -1, 0, -1);\n    hb_shape(font->hb_font, hb_buffer, NULL, 0);\n\n    /* Get the result */\n    hb_glyph_info = hb_buffer_get_glyph_infos(hb_buffer, &glyph_count);\n    hb_glyph_position = hb_buffer_get_glyph_positions(hb_buffer, &glyph_count);\n\n    /* Load and render each character */\n    for (g = 0; g < glyph_count; g++)\n    {\n        FT_UInt idx   = hb_glyph_info[g].codepoint;\n        int x_advance = hb_glyph_position[g].x_advance;\n        int y_advance = hb_glyph_position[g].y_advance;\n        int x_offset  = hb_glyph_position[g].x_offset;\n        int y_offset  = hb_glyph_position[g].y_offset;\n#else\n    /* Load each character and sum it's bounding box */\n    textlen = SDL_strlen(text);\n    while (textlen > 0) {\n        int inc = 0;\n        Uint32 c = UTF8_getch(text, textlen, &inc);\n        FT_UInt idx = get_char_index(font, c);\n        text += inc;\n        textlen -= inc;\n\n        if (c == UNICODE_BOM_NATIVE || c == UNICODE_BOM_SWAPPED) {\n            continue;\n        }\n#endif\n        if (Find_GlyphByIndex(font, idx, 0, 0, 0, 0, 0, &glyph, NULL) < 0) {\n            goto failure;\n        }\n\n        /* Realloc, if needed */\n        if (font->pos_len >= font->pos_max) {\n            PosBuf_t *saved = font->pos_buf;\n            font->pos_max *= 2;\n            font->pos_buf = (PosBuf_t *)SDL_realloc(font->pos_buf, font->pos_max * sizeof (font->pos_buf[0]));\n            if (font->pos_buf == NULL) {\n                font->pos_max /= 2;\n                font->pos_buf = saved;\n                TTF_SetError(\"Out of memory\");\n                goto failure;\n            }\n        }\n\n#if TTF_USE_HARFBUZZ\n        /* Compute positions */\n        pos_x  = x                     + x_offset;\n        pos_y  = y + F26Dot6(font->ascent) - y_offset;\n        x     += x_advance;\n        y     += y_advance;\n#else\n        /* Compute positions */\n        x += prev_advance;\n        prev_advance = glyph->advance;\n        if (font->use_kerning) {\n            if (prev_index && glyph->index) {\n                FT_Vector delta;\n                FT_Get_Kerning(font->face, prev_index, glyph->index, FT_KERNING_UNFITTED, &delta);\n                x += delta.x;\n            }\n            prev_index = glyph->index;\n        }\n        /* FT SUBPIXEL : LCD_MODE_LIGHT_SUBPIXEL  */\n        if (font->render_subpixel) {\n            x += prev_delta;\n            /* Increment by prev_glyph->lsb_delta - prev_glyph->rsb_delta; */\n            prev_delta = glyph->subpixel.lsb_minus_rsb;\n        } else {\n            /* FT KERNING_MODE_SMART: Use `lsb_delta' and `rsb_delta' to improve integer positioning of glyphs */\n            if (skip_first) {\n                skip_first = 0;\n            } else {\n                if (prev_delta - glyph->kerning_smart.lsb_delta >  32 ) {\n                    x -= 64;\n                } else if (prev_delta - glyph->kerning_smart.lsb_delta < -31 ) {\n                    x += 64;\n                }\n            }\n            prev_delta = glyph->kerning_smart.rsb_delta;\n            x = ((x + 32) & -64); /* ROUND() */\n        }\n\n        /* Compute positions where to copy the glyph bitmap */\n        pos_x = x;\n        pos_y = F26Dot6(font->ascent);\n#endif\n        /* Store things for Render_Line() */\n        font->pos_buf[font->pos_len].x     = pos_x;\n        font->pos_buf[font->pos_len].y     = pos_y;\n        font->pos_buf[font->pos_len].index = idx;\n        font->pos_len += 1;\n\n        /* Compute previsionnal global bounding box */\n        pos_x = FT_FLOOR(pos_x) + glyph->sz_left;\n        pos_y = FT_FLOOR(pos_y) - glyph->sz_top;\n\n        minx = SDL_min(minx, pos_x);\n        maxx = SDL_max(maxx, pos_x + glyph->sz_width);\n        miny = SDL_min(miny, pos_y);\n        maxy = SDL_max(maxy, pos_y + glyph->sz_rows);\n\n        /* Measurement mode */\n        if (measure_width) {\n            int cw = SDL_max(maxx, FT_FLOOR(x + prev_advance)) - minx;\n            cw += 2 * font->outline_val;\n            if (cw >= measure_width) {\n                break;\n            }\n            current_width = cw;\n            char_count += 1;\n        }\n    }\n\n    /* Allows to render a string with only one space (bug 4344). */\n    maxx = SDL_max(maxx, FT_FLOOR(x + prev_advance));\n\n    /* Initial x start position: often 0, except when a glyph would be written at\n     * a negative position. In this case an offset is needed for the whole line. */\n    if (xstart) {\n        *xstart = (minx < 0)? -minx : 0;\n        *xstart += font->outline_val;\n        if (font->render_sdf) {\n            *xstart += 8; /* Default 'spread' property */\n        }\n    }\n\n    /* Initial y start: compensation for a negative y offset */\n    if (ystart) {\n        *ystart = (miny < 0)? -miny : 0;\n        *ystart += font->outline_val;\n        if (font->render_sdf) {\n            *ystart += 8; /* Default 'spread' property */\n        }\n    }\n\n    /* Fill the bounds rectangle */\n    if (w) {\n        *w = (maxx - minx);\n        if (*w != 0) {\n            *w += 2 * font->outline_val;\n        }\n    }\n    if (h) {\n        *h = (maxy - miny);\n        *h += 2 * font->outline_val;\n    }\n\n    /* Measurement mode */\n    if (measure_width) {\n        if (extent) {\n            *extent = current_width;\n        }\n        if (count) {\n            *count = char_count;\n        }\n    }\n\n#if TTF_USE_HARFBUZZ\n    if (hb_buffer) {\n        hb_buffer_destroy(hb_buffer);\n    }\n#endif\n    if (utf8_alloc) {\n        SDL_stack_free(utf8_alloc);\n    }\n    return 0;\nfailure:\n#if TTF_USE_HARFBUZZ\n    if (hb_buffer) {\n        hb_buffer_destroy(hb_buffer);\n    }\n#endif\n    if (utf8_alloc) {\n        SDL_stack_free(utf8_alloc);\n    }\n    return -1;\n}\n\nint TTF_SizeText(TTF_Font *font, const char *text, int *w, int *h)\n{\n    return TTF_Size_Internal(font, text, STR_TEXT, w, h, NULL, NULL, NO_MEASUREMENT);\n}\n\nint TTF_SizeUTF8(TTF_Font *font, const char *text, int *w, int *h)\n{\n    return TTF_Size_Internal(font, text, STR_UTF8, w, h, NULL, NULL, NO_MEASUREMENT);\n}\n\nint TTF_SizeUNICODE(TTF_Font *font, const Uint16 *text, int *w, int *h)\n{\n    return TTF_Size_Internal(font, (const char *)text, STR_UNICODE, w, h, NULL, NULL, NO_MEASUREMENT);\n}\n\nint TTF_MeasureText(TTF_Font *font, const char *text, int width, int *extent, int *count)\n{\n    return TTF_Size_Internal(font, text, STR_TEXT, NULL, NULL, NULL, NULL, width, extent, count);\n}\n\nint TTF_MeasureUTF8(TTF_Font *font, const char *text, int width, int *extent, int *count)\n{\n    return TTF_Size_Internal(font, text, STR_UTF8, NULL, NULL, NULL, NULL, width, extent, count);\n}\n\nint TTF_MeasureUNICODE(TTF_Font *font, const Uint16 *text, int width, int *extent, int *count)\n{\n    return TTF_Size_Internal(font, (const char *)text, STR_UNICODE, NULL, NULL, NULL, NULL, width, extent, count);\n}\n\nstatic SDL_Surface* TTF_Render_Internal(TTF_Font *font, const char *text, const str_type_t str_type,\n        SDL_Color fg, SDL_Color bg, const render_mode_t render_mode)\n{\n    Uint32 color;\n    int xstart, ystart, width, height;\n    SDL_Surface *textbuf = NULL;\n    Uint8 *utf8_alloc = NULL;\n\n    TTF_CHECK_INITIALIZED(NULL);\n    TTF_CHECK_POINTER(font, NULL);\n    TTF_CHECK_POINTER(text, NULL);\n\n    /* Convert input string to default encoding UTF-8 */\n    if (str_type == STR_TEXT) {\n        utf8_alloc = SDL_stack_alloc(Uint8, LATIN1_to_UTF8_len(text));\n        if (utf8_alloc == NULL) {\n            SDL_OutOfMemory();\n            goto failure;\n        }\n        LATIN1_to_UTF8(text, utf8_alloc);\n        text = (const char *)utf8_alloc;\n    } else if (str_type == STR_UNICODE) {\n        const Uint16 *text16 = (const Uint16 *) text;\n        utf8_alloc = SDL_stack_alloc(Uint8, UCS2_to_UTF8_len(text16));\n        if (utf8_alloc == NULL) {\n            SDL_OutOfMemory();\n            goto failure;\n        }\n        UCS2_to_UTF8(text16, utf8_alloc);\n        text = (const char *)utf8_alloc;\n    }\n\n    /* Get the dimensions of the text surface */\n    if ((TTF_Size_Internal(font, text, STR_UTF8, &width, &height, &xstart, &ystart, NO_MEASUREMENT) < 0) || !width) {\n        TTF_SetError(\"Text has zero width\");\n        goto failure;\n    }\n\n    /* Support alpha blending */\n    fg.a = fg.a ? fg.a : SDL_ALPHA_OPAQUE;\n    bg.a = bg.a ? bg.a : SDL_ALPHA_OPAQUE;\n\n    /* Create surface for rendering */\n    if (render_mode == RENDER_SOLID) {\n        textbuf = Create_Surface_Solid(width, height, fg, &color);\n    } else if (render_mode == RENDER_SHADED) {\n        textbuf = Create_Surface_Shaded(width, height, fg, bg, &color);\n    } else { /* render_mode == RENDER_BLENDED */\n        textbuf = Create_Surface_Blended(width, height, fg, &color);\n    }\n\n    if (textbuf == NULL) {\n        goto failure;\n    }\n\n    /* Render one text line to textbuf at (xstart, ystart) */\n    if (Render_Line(render_mode, font->render_subpixel, font, textbuf, xstart, ystart, fg.a) < 0) {\n        goto failure;\n    }\n\n    /* Apply underline or strikethrough style, if needed */\n    if (TTF_HANDLE_STYLE_UNDERLINE(font)) {\n        Draw_Line(font, textbuf, ystart + font->underline_top_row, width, font->line_thickness, color, render_mode);\n    }\n\n    if (TTF_HANDLE_STYLE_STRIKETHROUGH(font)) {\n        Draw_Line(font, textbuf, ystart + font->strikethrough_top_row, width, font->line_thickness, color, render_mode);\n    }\n\n    if (utf8_alloc) {\n        SDL_stack_free(utf8_alloc);\n    }\n    return textbuf;\nfailure:\n    if (textbuf) {\n        SDL_FreeSurface(textbuf);\n    }\n    if (utf8_alloc) {\n        SDL_stack_free(utf8_alloc);\n    }\n    return NULL;\n}\n\nSDL_Surface* TTF_RenderText_Solid(TTF_Font *font, const char *text, SDL_Color fg)\n{\n    return TTF_Render_Internal(font, text, STR_TEXT, fg, fg /* unused */, RENDER_SOLID);\n}\n\nSDL_Surface* TTF_RenderUTF8_Solid(TTF_Font *font, const char *text, SDL_Color fg)\n{\n    return TTF_Render_Internal(font, text, STR_UTF8, fg, fg /* unused */, RENDER_SOLID);\n}\n\nSDL_Surface* TTF_RenderUNICODE_Solid(TTF_Font *font, const Uint16 *text, SDL_Color fg)\n{\n    return TTF_Render_Internal(font, (const char *)text, STR_UNICODE, fg, fg /* unused */, RENDER_SOLID);\n}\n\nSDL_Surface* TTF_RenderGlyph_Solid(TTF_Font *font, Uint16 ch, SDL_Color fg)\n{\n    return TTF_RenderGlyph32_Solid(font, ch, fg);\n}\n\nSDL_Surface* TTF_RenderGlyph32_Solid(TTF_Font *font, Uint32 ch, SDL_Color fg)\n{\n    Uint8 utf8[7];\n\n    TTF_CHECK_POINTER(font, NULL);\n\n    if (!Char_to_UTF8(ch, utf8)) {\n        return NULL;\n    }\n\n    return TTF_RenderUTF8_Solid(font, (char *)utf8, fg);\n}\n\nSDL_Surface* TTF_RenderText_Shaded(TTF_Font *font, const char *text, SDL_Color fg, SDL_Color bg)\n{\n    return TTF_Render_Internal(font, text, STR_TEXT, fg, bg, RENDER_SHADED);\n}\n\nSDL_Surface* TTF_RenderUTF8_Shaded(TTF_Font *font, const char *text, SDL_Color fg, SDL_Color bg)\n{\n    return TTF_Render_Internal(font, text, STR_UTF8, fg, bg, RENDER_SHADED);\n}\n\nSDL_Surface* TTF_RenderUNICODE_Shaded(TTF_Font *font, const Uint16 *text, SDL_Color fg, SDL_Color bg)\n{\n    return TTF_Render_Internal(font, (const char *)text, STR_UNICODE, fg, bg, RENDER_SHADED);\n}\n\nSDL_Surface* TTF_RenderGlyph_Shaded(TTF_Font *font, Uint16 ch, SDL_Color fg, SDL_Color bg)\n{\n    return TTF_RenderGlyph32_Shaded(font, ch, fg, bg);\n}\n\nSDL_Surface* TTF_RenderGlyph32_Shaded(TTF_Font *font, Uint32 ch, SDL_Color fg, SDL_Color bg)\n{\n    Uint8 utf8[7];\n\n    TTF_CHECK_POINTER(font, NULL);\n\n    if (!Char_to_UTF8(ch, utf8)) {\n        return NULL;\n    }\n\n    return TTF_RenderUTF8_Shaded(font, (char *)utf8, fg, bg);\n}\n\nSDL_Surface* TTF_RenderText_Blended(TTF_Font *font, const char *text, SDL_Color fg)\n{\n    return TTF_Render_Internal(font, text, STR_TEXT, fg, fg /* unused */, RENDER_BLENDED);\n}\n\nSDL_Surface* TTF_RenderUTF8_Blended(TTF_Font *font, const char *text, SDL_Color fg)\n{\n    return TTF_Render_Internal(font, text, STR_UTF8, fg, fg /* unused */, RENDER_BLENDED);\n}\n\nSDL_Surface* TTF_RenderUNICODE_Blended(TTF_Font *font, const Uint16 *text, SDL_Color fg)\n{\n    return TTF_Render_Internal(font, (const char *)text, STR_UNICODE, fg, fg /* unused */, RENDER_BLENDED);\n}\n\nstatic SDL_bool CharacterIsDelimiter(Uint32 c)\n{\n    if (c == ' ' || c == '\\t' || c == '\\r' || c == '\\n') {\n        return SDL_TRUE;\n    }\n    return SDL_FALSE;\n}\n\nstatic SDL_bool CharacterIsNewLine(Uint32 c)\n{\n    if (c == '\\n') {\n        return SDL_TRUE;\n    }\n    return SDL_FALSE;\n}\n\nstatic SDL_Surface* TTF_Render_Wrapped_Internal(TTF_Font *font, const char *text, const str_type_t str_type,\n        SDL_Color fg, SDL_Color bg, Uint32 wrapLength, const render_mode_t render_mode)\n{\n    Uint32 color;\n    int width, height;\n    SDL_Surface *textbuf = NULL;\n    Uint8 *utf8_alloc = NULL;\n\n    int i, numLines, rowHeight, lineskip;\n    char **strLines = NULL, *text_cpy;\n\n    TTF_CHECK_INITIALIZED(NULL);\n    TTF_CHECK_POINTER(font, NULL);\n    TTF_CHECK_POINTER(text, NULL);\n\n    /* Convert input string to default encoding UTF-8 */\n    if (str_type == STR_TEXT) {\n        utf8_alloc = SDL_stack_alloc(Uint8, LATIN1_to_UTF8_len(text));\n        if (utf8_alloc == NULL) {\n            SDL_OutOfMemory();\n            goto failure;\n        }\n        LATIN1_to_UTF8(text, utf8_alloc);\n        text_cpy = (char *)utf8_alloc;\n    } else if (str_type == STR_UNICODE) {\n        const Uint16 *text16 = (const Uint16 *) text;\n        utf8_alloc = SDL_stack_alloc(Uint8, UCS2_to_UTF8_len(text16));\n        if (utf8_alloc == NULL) {\n            SDL_OutOfMemory();\n            goto failure;\n        }\n        UCS2_to_UTF8(text16, utf8_alloc);\n        text_cpy = (char *)utf8_alloc;\n    } else {\n        /* Use a copy anyway */\n        size_t str_len = SDL_strlen(text);\n        utf8_alloc = SDL_stack_alloc(Uint8, str_len + 1);\n        if (utf8_alloc == NULL) {\n            SDL_OutOfMemory();\n            goto failure;\n        }\n        SDL_memcpy(utf8_alloc, text, str_len + 1);\n        text_cpy = (char *)utf8_alloc;\n    }\n\n    /* Get the dimensions of the text surface */\n    if ((TTF_SizeUTF8(font, text_cpy, &width, &height) < 0) || !width) {\n        TTF_SetError(\"Text has zero width\");\n        goto failure;\n    }\n\n    /* wrapLength is unsigned, but don't allow negative values */\n    if ((int)wrapLength < 0) {\n        TTF_SetError(\"Invalid parameter 'wrapLength'\");\n        goto failure;\n    }\n\n    numLines = 1;\n\n    if (*text_cpy) {\n        int maxNumLines = 0;\n        size_t textlen = SDL_strlen(text_cpy);\n        numLines = 0;\n\n        do {\n            int extent = 0, max_count = 0, char_count = 0;\n            size_t save_textlen = (size_t)(-1);\n            char *save_text  = NULL;\n\n            if (numLines >= maxNumLines) {\n                char **saved = strLines;\n                if (wrapLength == 0) {\n                    maxNumLines += 32;\n                } else {\n                    maxNumLines += (width / wrapLength) + 1;\n                }\n                strLines = (char **)SDL_realloc(strLines, maxNumLines * sizeof (*strLines));\n                if (strLines == NULL) {\n                    strLines = saved;\n                    SDL_OutOfMemory();\n                    goto failure;\n                }\n            }\n\n            strLines[numLines++] = text_cpy;\n\n            if (TTF_MeasureUTF8(font, text_cpy, wrapLength, &extent, &max_count) < 0) {\n                TTF_SetError(\"Error measure text\");\n                goto failure;\n            }\n\n            if (wrapLength != 0) {\n                if (max_count == 0) {\n                    max_count = 1;\n                }\n            }\n\n            while (textlen > 0) {\n                int inc = 0;\n                int is_delim;\n                Uint32 c = UTF8_getch(text_cpy, textlen, &inc);\n                text_cpy += inc;\n                textlen -= inc;\n\n                if (c == UNICODE_BOM_NATIVE || c == UNICODE_BOM_SWAPPED) {\n                    continue;\n                }\n\n                char_count += 1;\n\n                /* With wrapLength == 0, normal text rendering but newline aware */\n                is_delim = (wrapLength > 0) ?  CharacterIsDelimiter(c) : CharacterIsNewLine(c);\n\n                /* Record last delimiter position */\n                if (is_delim) {\n                    save_textlen = textlen;\n                    save_text = text_cpy;\n                    /* Break, if new line */\n                    if (c == '\\n' || c == '\\r') {\n                        *(text_cpy - 1) = '\\0';\n                        break;\n                    }\n                }\n\n                /* Break, if reach the limit */\n                if (char_count == max_count) {\n                    break;\n                }\n            }\n\n            /* Cut at last delimiter/new lines, otherwise in the middle of the word */\n            if (save_text && textlen) {\n                text_cpy = save_text;\n                textlen = save_textlen;\n            }\n        } while (textlen > 0);\n    }\n\n    lineskip = TTF_FontLineSkip(font);\n    rowHeight = SDL_max(height, lineskip);\n\n    if (wrapLength == 0) {\n        /* Find the max of all line lengths */\n        if (numLines > 1) {\n            width = 0;\n            for (i = 0; i < numLines; i++) {\n                char save_c = 0;\n                int w, h;\n\n                /* Add end-of-line */\n                if (strLines) {\n                    text = strLines[i];\n                    if (i + 1 < numLines) {\n                        save_c = strLines[i + 1][0];\n                        strLines[i + 1][0] = '\\0';\n                    }\n                }\n\n                if (TTF_SizeUTF8(font, text, &w, &h) == 0) {\n                    width = SDL_max(w, width);\n                }\n\n                /* Remove end-of-line */\n                if (strLines) {\n                    if (i + 1 < numLines) {\n                        strLines[i + 1][0] = save_c;\n                    }\n                }\n            }\n        }\n    } else {\n        if (numLines > 1) {\n            width = wrapLength;\n        } else {\n            /* Don't go above wrapLength if you have only 1 line which hasn't been cut */\n            width = SDL_min((int)wrapLength, width);\n        }\n    }\n    height = rowHeight + lineskip * (numLines - 1);\n\n    /* Support alpha blending */\n    fg.a = fg.a ? fg.a : SDL_ALPHA_OPAQUE;\n    bg.a = bg.a ? bg.a : SDL_ALPHA_OPAQUE;\n\n    /* Create surface for rendering */\n    if (render_mode == RENDER_SOLID) {\n        textbuf = Create_Surface_Solid(width, height, fg, &color);\n    } else if (render_mode == RENDER_SHADED) {\n        textbuf = Create_Surface_Shaded(width, height, fg, bg, &color);\n    } else { /* render_mode == RENDER_BLENDED */\n        textbuf = Create_Surface_Blended(width, height, fg, &color);\n    }\n\n    if (textbuf == NULL) {\n        goto failure;\n    }\n\n    /* Render each line */\n    for (i = 0; i < numLines; i++) {\n        int xstart, ystart, line_width;\n        char save_c = 0;\n\n        /* Add end-of-line */\n        if (strLines) {\n            text = strLines[i];\n            if (i + 1 < numLines) {\n                save_c = strLines[i + 1][0];\n                strLines[i + 1][0] = '\\0';\n            }\n        }\n\n        /* Initialize xstart, ystart and compute positions */\n        if (TTF_Size_Internal(font, text, STR_UTF8, &line_width, NULL, &xstart, &ystart, NO_MEASUREMENT) < 0) {\n            goto failure;\n        }\n\n        /* Move to i-th line */\n        ystart += i * lineskip;\n\n        /* Render one text line to textbuf at (xstart, ystart) */\n        if (Render_Line(render_mode, font->render_subpixel, font, textbuf, xstart, ystart, fg.a) < 0) {\n            goto failure;\n        }\n\n        /* Apply underline or strikethrough style, if needed */\n        if (TTF_HANDLE_STYLE_UNDERLINE(font)) {\n            Draw_Line(font, textbuf, ystart + font->underline_top_row, line_width, font->line_thickness, color, render_mode);\n        }\n\n        if (TTF_HANDLE_STYLE_STRIKETHROUGH(font)) {\n            Draw_Line(font, textbuf, ystart + font->strikethrough_top_row, line_width, font->line_thickness, color, render_mode);\n        }\n\n        /* Remove end-of-line */\n        if (strLines) {\n            if (i + 1 < numLines) {\n                strLines[i + 1][0] = save_c;\n            }\n        }\n    }\n\n    if (strLines) {\n        SDL_free(strLines);\n    }\n    if (utf8_alloc) {\n        SDL_stack_free(utf8_alloc);\n    }\n    return textbuf;\nfailure:\n    if (textbuf) {\n        SDL_FreeSurface(textbuf);\n    }\n    if (strLines) {\n        SDL_free(strLines);\n    }\n    if (utf8_alloc) {\n        SDL_stack_free(utf8_alloc);\n    }\n    return NULL;\n}\n\nSDL_Surface* TTF_RenderText_Solid_Wrapped(TTF_Font *font, const char *text, SDL_Color fg, Uint32 wrapLength)\n{\n    return TTF_Render_Wrapped_Internal(font, text, STR_TEXT, fg, fg /* unused */, wrapLength, RENDER_SOLID);\n}\n\nSDL_Surface* TTF_RenderUTF8_Solid_Wrapped(TTF_Font *font, const char *text, SDL_Color fg, Uint32 wrapLength)\n{\n    return TTF_Render_Wrapped_Internal(font, text, STR_UTF8, fg, fg /* unused */, wrapLength, RENDER_SOLID);\n}\n\nSDL_Surface* TTF_RenderUNICODE_Solid_Wrapped(TTF_Font *font, const Uint16 *text, SDL_Color fg, Uint32 wrapLength)\n{\n    return TTF_Render_Wrapped_Internal(font, (const char *)text, STR_UNICODE, fg, fg /* unused */, wrapLength, RENDER_SOLID);\n}\n\nSDL_Surface* TTF_RenderText_Shaded_Wrapped(TTF_Font *font, const char *text, SDL_Color fg, SDL_Color bg, Uint32 wrapLength)\n{\n    return TTF_Render_Wrapped_Internal(font, text, STR_TEXT, fg, bg, wrapLength, RENDER_SHADED);\n}\n\nSDL_Surface* TTF_RenderUTF8_Shaded_Wrapped(TTF_Font *font, const char *text, SDL_Color fg, SDL_Color bg, Uint32 wrapLength)\n{\n    return TTF_Render_Wrapped_Internal(font, text, STR_UTF8, fg, bg, wrapLength, RENDER_SHADED);\n}\n\nSDL_Surface* TTF_RenderUNICODE_Shaded_Wrapped(TTF_Font *font, const Uint16 *text, SDL_Color fg, SDL_Color bg, Uint32 wrapLength)\n{\n    return TTF_Render_Wrapped_Internal(font, (const char *)text, STR_UNICODE, fg, bg, wrapLength, RENDER_SHADED);\n}\n\nSDL_Surface* TTF_RenderText_Blended_Wrapped(TTF_Font *font, const char *text, SDL_Color fg, Uint32 wrapLength)\n{\n    return TTF_Render_Wrapped_Internal(font, text, STR_TEXT, fg, fg /* unused */, wrapLength, RENDER_BLENDED);\n}\n\nSDL_Surface* TTF_RenderUTF8_Blended_Wrapped(TTF_Font *font, const char *text, SDL_Color fg, Uint32 wrapLength)\n{\n    return TTF_Render_Wrapped_Internal(font, text, STR_UTF8, fg, fg /* unused */, wrapLength, RENDER_BLENDED);\n}\n\nSDL_Surface* TTF_RenderUNICODE_Blended_Wrapped(TTF_Font *font, const Uint16 *text, SDL_Color fg, Uint32 wrapLength)\n{\n    return TTF_Render_Wrapped_Internal(font, (const char *)text, STR_UNICODE, fg, fg /* unused */, wrapLength, RENDER_BLENDED);\n}\n\nSDL_Surface* TTF_RenderGlyph_Blended(TTF_Font *font, Uint16 ch, SDL_Color fg)\n{\n    return TTF_RenderGlyph32_Blended(font, ch, fg);\n}\n\nSDL_Surface* TTF_RenderGlyph32_Blended(TTF_Font *font, Uint32 ch, SDL_Color fg)\n{\n    Uint8 utf8[7];\n\n    TTF_CHECK_POINTER(font, NULL);\n\n    if (!Char_to_UTF8(ch, utf8)) {\n        return NULL;\n    }\n\n    return TTF_RenderUTF8_Blended(font, (char *)utf8, fg);\n}\n\nvoid TTF_SetFontStyle(TTF_Font *font, int style)\n{\n    int prev_style;\n    long face_style;\n\n    TTF_CHECK_POINTER(font,);\n\n    prev_style = font->style;\n    face_style = font->face->style_flags;\n\n    /* Don't add a style if already in the font, SDL_ttf doesn't need to handle them */\n    if (face_style & FT_STYLE_FLAG_BOLD) {\n        style &= ~TTF_STYLE_BOLD;\n    }\n    if (face_style & FT_STYLE_FLAG_ITALIC) {\n        style &= ~TTF_STYLE_ITALIC;\n    }\n\n    font->style = style;\n\n    TTF_initFontMetrics(font);\n\n    /* Flush the cache if the style has changed.\n     * Ignore styles which do not impact glyph drawning. */\n    if ((font->style | TTF_STYLE_NO_GLYPH_CHANGE) != (prev_style | TTF_STYLE_NO_GLYPH_CHANGE)) {\n        Flush_Cache(font);\n    }\n}\n\nint TTF_GetFontStyle(const TTF_Font *font)\n{\n    int style;\n    long face_style;\n\n    TTF_CHECK_POINTER(font, -1);\n\n    style = font->style;\n    face_style = font->face->style_flags;\n\n    /* Add the style already in the font */\n    if (face_style & FT_STYLE_FLAG_BOLD) {\n        style |= TTF_STYLE_BOLD;\n    }\n    if (face_style & FT_STYLE_FLAG_ITALIC) {\n        style |= TTF_STYLE_ITALIC;\n    }\n\n    return style;\n}\n\nvoid TTF_SetFontOutline(TTF_Font *font, int outline)\n{\n    TTF_CHECK_POINTER(font,);\n\n    font->outline_val = SDL_max(0, outline);\n    TTF_initFontMetrics(font);\n    Flush_Cache(font);\n}\n\nint TTF_GetFontOutline(const TTF_Font *font)\n{\n    TTF_CHECK_POINTER(font, -1);\n\n    return font->outline_val;\n}\n\nvoid TTF_SetFontHinting(TTF_Font *font, int hinting)\n{\n    TTF_CHECK_POINTER(font,);\n\n    if (hinting == TTF_HINTING_LIGHT || hinting == TTF_HINTING_LIGHT_SUBPIXEL) {\n        font->ft_load_target = FT_LOAD_TARGET_LIGHT;\n    } else if (hinting == TTF_HINTING_MONO) {\n        font->ft_load_target = FT_LOAD_TARGET_MONO;\n    } else if (hinting == TTF_HINTING_NONE) {\n        font->ft_load_target = FT_LOAD_NO_HINTING;\n    } else {\n        font->ft_load_target = FT_LOAD_TARGET_NORMAL;\n    }\n\n    font->render_subpixel = (hinting == TTF_HINTING_LIGHT_SUBPIXEL) ? 1 : 0;\n#if TTF_USE_HARFBUZZ\n    /* update flag for HB */\n    hb_ft_font_set_load_flags(font->hb_font, FT_LOAD_DEFAULT | font->ft_load_target);\n#endif\n\n    Flush_Cache(font);\n}\n\nint TTF_GetFontHinting(const TTF_Font *font)\n{\n    TTF_CHECK_POINTER(font, -1);\n\n    if (font->ft_load_target == FT_LOAD_TARGET_LIGHT) {\n        if (font->render_subpixel == 0) {\n            return TTF_HINTING_LIGHT;\n        } else {\n            return TTF_HINTING_LIGHT_SUBPIXEL;\n        }\n    } else if (font->ft_load_target == FT_LOAD_TARGET_MONO) {\n        return TTF_HINTING_MONO;\n    } else if (font->ft_load_target == FT_LOAD_NO_HINTING) {\n        return TTF_HINTING_NONE;\n    }\n    return TTF_HINTING_NORMAL;\n}\n\nint TTF_SetFontSDF(TTF_Font *font, SDL_bool on_off)\n{\n    TTF_CHECK_POINTER(font, -1);\n#if TTF_USE_SDF\n    font->render_sdf = on_off;\n    Flush_Cache(font);\n    return 0;\n#else\n    TTF_SetError(\"SDL_ttf compiled without SDF support\");\n    return -1;\n#endif\n}\n\nSDL_bool TTF_GetFontSDF(const TTF_Font *font)\n{\n    TTF_CHECK_POINTER(font, SDL_FALSE);\n    return font->render_sdf;\n}\n\nvoid TTF_Quit(void)\n{\n    if (TTF_initialized) {\n        if (--TTF_initialized == 0) {\n            FT_Done_FreeType(library);\n            library = NULL;\n        }\n    }\n}\n\nint TTF_WasInit(void)\n{\n    return TTF_initialized;\n}\n\n/* don't use this function. It's just here for binary compatibility. */\nint TTF_GetFontKerningSize(TTF_Font *font, int prev_index, int index)\n{\n    FT_Vector delta;\n\n    TTF_CHECK_POINTER(font, -1);\n\n    FT_Get_Kerning(font->face, (FT_UInt)prev_index, (FT_UInt)index, FT_KERNING_DEFAULT, &delta);\n    return (int)(delta.x >> 6);\n}\n\nint TTF_GetFontKerningSizeGlyphs(TTF_Font *font, Uint16 previous_ch, Uint16 ch)\n{\n    return TTF_GetFontKerningSizeGlyphs32(font, previous_ch, ch);\n}\n\nint TTF_GetFontKerningSizeGlyphs32(TTF_Font *font, Uint32 previous_ch, Uint32 ch)\n{\n    FT_Error error;\n    c_glyph *prev_glyph, *glyph;\n    FT_Vector delta;\n\n    TTF_CHECK_POINTER(font, -1);\n\n    if (ch == UNICODE_BOM_NATIVE || ch == UNICODE_BOM_SWAPPED) {\n        return 0;\n    }\n\n    if (previous_ch == UNICODE_BOM_NATIVE || previous_ch == UNICODE_BOM_SWAPPED) {\n        return 0;\n    }\n\n    if (Find_GlyphMetrics(font, ch, &glyph) < 0) {\n        return -1;\n    }\n\n    if (Find_GlyphMetrics(font, previous_ch, &prev_glyph) < 0) {\n        return -1;\n    }\n\n    error = FT_Get_Kerning(font->face, prev_glyph->index, glyph->index, FT_KERNING_DEFAULT, &delta);\n    if (error) {\n        TTF_SetFTError(\"Couldn't get glyph kerning\", error);\n        return -1;\n    }\n    return (int)(delta.x >> 6);\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n"], "filenames": ["SDL_ttf.c"], "buggy_code_start_loc": [1260], "buggy_code_end_loc": [1422], "fixing_code_start_loc": [1260], "fixing_code_end_loc": [1422], "type": "CWE-787", "message": "SDL_ttf v2.0.18 and below was discovered to contain an arbitrary memory write via the function TTF_RenderText_Solid(). This vulnerability is triggered via a crafted TTF file.", "other": {"cve": {"id": "CVE-2022-27470", "sourceIdentifier": "cve@mitre.org", "published": "2022-05-04T03:15:07.627", "lastModified": "2022-05-12T19:43:18.333", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SDL_ttf v2.0.18 and below was discovered to contain an arbitrary memory write via the function TTF_RenderText_Solid(). This vulnerability is triggered via a crafted TTF file."}, {"lang": "es", "value": "Se ha detectado que SDL_ttf versiones v2.0.18 y anteriores, contienen una escritura arbitraria en memoria por medio de la funci\u00f3n TTF_RenderText_Solid(). Esta vulnerabilidad es desencadenada por medio de un archivo TTF dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libsdl:sdl_ttf:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0.18", "matchCriteriaId": "030E0F2C-3446-4732-8E66-FF2818FEF632"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/libsdl-org/SDL_ttf/commit/db1b41ab8bde6723c24b866e466cad78c2fa0448", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libsdl-org/SDL_ttf/issues/187", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EAGMQMRQDTZFQW64JEW3O6HY3JYLAAHT/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RXI3MDPR24W5557G34YHWOP2MOK6BTGB/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XPYTEBBNHCDGPVFACC5RC5K2FZUCYTPZ/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libsdl-org/SDL_ttf/commit/db1b41ab8bde6723c24b866e466cad78c2fa0448"}}