{"buggy_code": ["#include <linux/err.h>\n#include <linux/igmp.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/rculist.h>\n#include <linux/skbuff.h>\n#include <linux/if_ether.h>\n#include <net/ip.h>\n#include <net/netlink.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/ipv6.h>\n#endif\n\n#include \"br_private.h\"\n\nstatic int br_rports_fill_info(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t       struct net_device *dev)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct net_bridge_port *p;\n\tstruct nlattr *nest;\n\n\tif (!br->multicast_router || hlist_empty(&br->router_list))\n\t\treturn 0;\n\n\tnest = nla_nest_start(skb, MDBA_ROUTER);\n\tif (nest == NULL)\n\t\treturn -EMSGSIZE;\n\n\thlist_for_each_entry_rcu(p, &br->router_list, rlist) {\n\t\tif (p && nla_put_u32(skb, MDBA_ROUTER_PORT, p->dev->ifindex))\n\t\t\tgoto fail;\n\t}\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\nfail:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int br_mdb_fill_info(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t    struct net_device *dev)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct nlattr *nest, *nest2;\n\tint i, err = 0;\n\tint idx = 0, s_idx = cb->args[1];\n\n\tif (br->multicast_disabled)\n\t\treturn 0;\n\n\tmdb = rcu_dereference(br->mdb);\n\tif (!mdb)\n\t\treturn 0;\n\n\tnest = nla_nest_start(skb, MDBA_MDB);\n\tif (nest == NULL)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i < mdb->max; i++) {\n\t\tstruct net_bridge_mdb_entry *mp;\n\t\tstruct net_bridge_port_group *p, **pp;\n\t\tstruct net_bridge_port *port;\n\n\t\thlist_for_each_entry_rcu(mp, &mdb->mhash[i], hlist[mdb->ver]) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto skip;\n\n\t\t\tnest2 = nla_nest_start(skb, MDBA_MDB_ENTRY);\n\t\t\tif (nest2 == NULL) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfor (pp = &mp->ports;\n\t\t\t     (p = rcu_dereference(*pp)) != NULL;\n\t\t\t      pp = &p->next) {\n\t\t\t\tport = p->port;\n\t\t\t\tif (port) {\n\t\t\t\t\tstruct br_mdb_entry e;\n\t\t\t\t\tmemset(&e, 0, sizeof(e));\n\t\t\t\t\te.ifindex = port->dev->ifindex;\n\t\t\t\t\te.state = p->state;\n\t\t\t\t\tif (p->addr.proto == htons(ETH_P_IP))\n\t\t\t\t\t\te.addr.u.ip4 = p->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\t\t\tif (p->addr.proto == htons(ETH_P_IPV6))\n\t\t\t\t\t\te.addr.u.ip6 = p->addr.u.ip6;\n#endif\n\t\t\t\t\te.addr.proto = p->addr.proto;\n\t\t\t\t\tif (nla_put(skb, MDBA_MDB_ENTRY_INFO, sizeof(e), &e)) {\n\t\t\t\t\t\tnla_nest_cancel(skb, nest2);\n\t\t\t\t\t\terr = -EMSGSIZE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnla_nest_end(skb, nest2);\n\t\tskip:\n\t\t\tidx++;\n\t\t}\n\t}\n\nout:\n\tcb->args[1] = idx;\n\tnla_nest_end(skb, nest);\n\treturn err;\n}\n\nstatic int br_mdb_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net_device *dev;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlmsghdr *nlh = NULL;\n\tint idx = 0, s_idx;\n\n\ts_idx = cb->args[0];\n\n\trcu_read_lock();\n\n\t/* In theory this could be wrapped to 0... */\n\tcb->seq = net->dev_base_seq + br_mdb_rehash_seq;\n\n\tfor_each_netdev_rcu(net, dev) {\n\t\tif (dev->priv_flags & IFF_EBRIDGE) {\n\t\t\tstruct br_port_msg *bpm;\n\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto skip;\n\n\t\t\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\tcb->nlh->nlmsg_seq, RTM_GETMDB,\n\t\t\t\t\tsizeof(*bpm), NLM_F_MULTI);\n\t\t\tif (nlh == NULL)\n\t\t\t\tbreak;\n\n\t\t\tbpm = nlmsg_data(nlh);\n\t\t\tmemset(bpm, 0, sizeof(*bpm));\n\t\t\tbpm->ifindex = dev->ifindex;\n\t\t\tif (br_mdb_fill_info(skb, cb, dev) < 0)\n\t\t\t\tgoto out;\n\t\t\tif (br_rports_fill_info(skb, cb, dev) < 0)\n\t\t\t\tgoto out;\n\n\t\t\tcb->args[1] = 0;\n\t\t\tnlmsg_end(skb, nlh);\n\t\tskip:\n\t\t\tidx++;\n\t\t}\n\t}\n\nout:\n\tif (nlh)\n\t\tnlmsg_end(skb, nlh);\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\nstatic int nlmsg_populate_mdb_fill(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   struct br_mdb_entry *entry, u32 pid,\n\t\t\t\t   u32 seq, int type, unsigned int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct br_port_msg *bpm;\n\tstruct nlattr *nest, *nest2;\n\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*bpm), NLM_F_MULTI);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tbpm = nlmsg_data(nlh);\n\tmemset(bpm, 0, sizeof(*bpm));\n\tbpm->family  = AF_BRIDGE;\n\tbpm->ifindex = dev->ifindex;\n\tnest = nla_nest_start(skb, MDBA_MDB);\n\tif (nest == NULL)\n\t\tgoto cancel;\n\tnest2 = nla_nest_start(skb, MDBA_MDB_ENTRY);\n\tif (nest2 == NULL)\n\t\tgoto end;\n\n\tif (nla_put(skb, MDBA_MDB_ENTRY_INFO, sizeof(*entry), entry))\n\t\tgoto end;\n\n\tnla_nest_end(skb, nest2);\n\tnla_nest_end(skb, nest);\n\treturn nlmsg_end(skb, nlh);\n\nend:\n\tnla_nest_end(skb, nest);\ncancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic inline size_t rtnl_mdb_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct br_port_msg))\n\t\t+ nla_total_size(sizeof(struct br_mdb_entry));\n}\n\nstatic void __br_mdb_notify(struct net_device *dev, struct br_mdb_entry *entry,\n\t\t\t    int type)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(rtnl_mdb_nlmsg_size(), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = nlmsg_populate_mdb_fill(skb, dev, entry, 0, 0, type, NTF_SELF);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, 0, RTNLGRP_MDB, NULL, GFP_ATOMIC);\n\treturn;\nerrout:\n\trtnl_set_sk_err(net, RTNLGRP_MDB, err);\n}\n\nvoid br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,\n\t\t   struct br_ip *group, int type)\n{\n\tstruct br_mdb_entry entry;\n\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.ifindex = port->dev->ifindex;\n\tentry.addr.proto = group->proto;\n\tentry.addr.u.ip4 = group->u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tentry.addr.u.ip6 = group->u.ip6;\n#endif\n\t__br_mdb_notify(dev, &entry, type);\n}\n\nstatic bool is_valid_mdb_entry(struct br_mdb_entry *entry)\n{\n\tif (entry->ifindex == 0)\n\t\treturn false;\n\n\tif (entry->addr.proto == htons(ETH_P_IP)) {\n\t\tif (!ipv4_is_multicast(entry->addr.u.ip4))\n\t\t\treturn false;\n\t\tif (ipv4_is_local_multicast(entry->addr.u.ip4))\n\t\t\treturn false;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (entry->addr.proto == htons(ETH_P_IPV6)) {\n\t\tif (!ipv6_is_transient_multicast(&entry->addr.u.ip6))\n\t\t\treturn false;\n#endif\n\t} else\n\t\treturn false;\n\tif (entry->state != MDB_PERMANENT && entry->state != MDB_TEMPORARY)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int br_mdb_parse(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct net_device **pdev, struct br_mdb_entry **pentry)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct br_mdb_entry *entry;\n\tstruct br_port_msg *bpm;\n\tstruct nlattr *tb[MDBA_SET_ENTRY_MAX+1];\n\tstruct net_device *dev;\n\tint err;\n\n\terr = nlmsg_parse(nlh, sizeof(*bpm), tb, MDBA_SET_ENTRY, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tbpm = nlmsg_data(nlh);\n\tif (bpm->ifindex == 0) {\n\t\tpr_info(\"PF_BRIDGE: br_mdb_parse() with invalid ifindex\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = __dev_get_by_index(net, bpm->ifindex);\n\tif (dev == NULL) {\n\t\tpr_info(\"PF_BRIDGE: br_mdb_parse() with unknown ifindex\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!(dev->priv_flags & IFF_EBRIDGE)) {\n\t\tpr_info(\"PF_BRIDGE: br_mdb_parse() with non-bridge\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t*pdev = dev;\n\n\tif (!tb[MDBA_SET_ENTRY] ||\n\t    nla_len(tb[MDBA_SET_ENTRY]) != sizeof(struct br_mdb_entry)) {\n\t\tpr_info(\"PF_BRIDGE: br_mdb_parse() with invalid attr\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tentry = nla_data(tb[MDBA_SET_ENTRY]);\n\tif (!is_valid_mdb_entry(entry)) {\n\t\tpr_info(\"PF_BRIDGE: br_mdb_parse() with invalid entry\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*pentry = entry;\n\treturn 0;\n}\n\nstatic int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,\n\t\t\t    struct br_ip *group, unsigned char state)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct net_bridge_mdb_htable *mdb;\n\tint err;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, group);\n\tif (!mp) {\n\t\tmp = br_multicast_new_group(br, port, group);\n\t\terr = PTR_ERR(mp);\n\t\tif (IS_ERR(mp))\n\t\t\treturn err;\n\t}\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\treturn -EEXIST;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\n\tp = br_multicast_new_port_group(port, group, *pp, state);\n\tif (unlikely(!p))\n\t\treturn -ENOMEM;\n\trcu_assign_pointer(*pp, p);\n\n\tbr_mdb_notify(br->dev, port, group, RTM_NEWMDB);\n\treturn 0;\n}\n\nstatic int __br_mdb_add(struct net *net, struct net_bridge *br,\n\t\t\tstruct br_mdb_entry *entry)\n{\n\tstruct br_ip ip;\n\tstruct net_device *dev;\n\tstruct net_bridge_port *p;\n\tint ret;\n\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\n\tdev = __dev_get_by_index(net, entry->ifindex);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tp = br_port_get_rtnl(dev);\n\tif (!p || p->br != br || p->state == BR_STATE_DISABLED)\n\t\treturn -EINVAL;\n\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\n\tspin_lock_bh(&br->multicast_lock);\n\tret = br_mdb_add_group(br, p, &ip, entry->state);\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn ret;\n}\n\nstatic int br_mdb_add(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct br_mdb_entry *entry;\n\tstruct net_device *dev;\n\tstruct net_bridge *br;\n\tint err;\n\n\terr = br_mdb_parse(skb, nlh, &dev, &entry);\n\tif (err < 0)\n\t\treturn err;\n\n\tbr = netdev_priv(dev);\n\n\terr = __br_mdb_add(net, br, entry);\n\tif (!err)\n\t\t__br_mdb_notify(dev, entry, RTM_NEWMDB);\n\treturn err;\n}\n\nstatic int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip ip;\n\tint err = -EINVAL;\n\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\n\tif (timer_pending(&br->multicast_querier_timer))\n\t\treturn -EBUSY;\n\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\n\tmp = br_mdb_ip_get(mdb, &ip);\n\tif (!mp)\n\t\tgoto unlock;\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (!p->port || p->port->dev->ifindex != entry->ifindex)\n\t\t\tcontinue;\n\n\t\tif (p->port->state == BR_STATE_DISABLED)\n\t\t\tgoto unlock;\n\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\terr = 0;\n\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\tbreak;\n\t}\n\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn err;\n}\n\nstatic int br_mdb_del(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net_device *dev;\n\tstruct br_mdb_entry *entry;\n\tstruct net_bridge *br;\n\tint err;\n\n\terr = br_mdb_parse(skb, nlh, &dev, &entry);\n\tif (err < 0)\n\t\treturn err;\n\n\tbr = netdev_priv(dev);\n\n\terr = __br_mdb_del(br, entry);\n\tif (!err)\n\t\t__br_mdb_notify(dev, entry, RTM_DELMDB);\n\treturn err;\n}\n\nvoid br_mdb_init(void)\n{\n\trtnl_register(PF_BRIDGE, RTM_GETMDB, NULL, br_mdb_dump, NULL);\n\trtnl_register(PF_BRIDGE, RTM_NEWMDB, br_mdb_add, NULL, NULL);\n\trtnl_register(PF_BRIDGE, RTM_DELMDB, br_mdb_del, NULL, NULL);\n}\n\nvoid br_mdb_uninit(void)\n{\n\trtnl_unregister(PF_BRIDGE, RTM_GETMDB);\n\trtnl_unregister(PF_BRIDGE, RTM_NEWMDB);\n\trtnl_unregister(PF_BRIDGE, RTM_DELMDB);\n}\n", "/*\n * Bridge multicast support.\n *\n * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include <linux/err.h>\n#include <linux/if_ether.h>\n#include <linux/igmp.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/netdevice.h>\n#include <linux/netfilter_bridge.h>\n#include <linux/random.h>\n#include <linux/rculist.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/inetdevice.h>\n#include <net/ip.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/ipv6.h>\n#include <net/mld.h>\n#include <net/ip6_checksum.h>\n#endif\n\n#include \"br_private.h\"\n\nstatic void br_multicast_start_querier(struct net_bridge *br);\nunsigned int br_mdb_rehash_seq;\n\nstatic inline int br_ip_equal(const struct br_ip *a, const struct br_ip *b)\n{\n\tif (a->proto != b->proto)\n\t\treturn 0;\n\tif (a->vid != b->vid)\n\t\treturn 0;\n\tswitch (a->proto) {\n\tcase htons(ETH_P_IP):\n\t\treturn a->u.ip4 == b->u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\treturn ipv6_addr_equal(&a->u.ip6, &b->u.ip6);\n#endif\n\t}\n\treturn 0;\n}\n\nstatic inline int __br_ip4_hash(struct net_bridge_mdb_htable *mdb, __be32 ip,\n\t\t\t\t__u16 vid)\n{\n\treturn jhash_2words((__force u32)ip, vid, mdb->secret) & (mdb->max - 1);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic inline int __br_ip6_hash(struct net_bridge_mdb_htable *mdb,\n\t\t\t\tconst struct in6_addr *ip,\n\t\t\t\t__u16 vid)\n{\n\treturn jhash_2words(ipv6_addr_hash(ip), vid,\n\t\t\t    mdb->secret) & (mdb->max - 1);\n}\n#endif\n\nstatic inline int br_ip_hash(struct net_bridge_mdb_htable *mdb,\n\t\t\t     struct br_ip *ip)\n{\n\tswitch (ip->proto) {\n\tcase htons(ETH_P_IP):\n\t\treturn __br_ip4_hash(mdb, ip->u.ip4, ip->vid);\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\treturn __br_ip6_hash(mdb, &ip->u.ip6, ip->vid);\n#endif\n\t}\n\treturn 0;\n}\n\nstatic struct net_bridge_mdb_entry *__br_mdb_ip_get(\n\tstruct net_bridge_mdb_htable *mdb, struct br_ip *dst, int hash)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\n\thlist_for_each_entry_rcu(mp, &mdb->mhash[hash], hlist[mdb->ver]) {\n\t\tif (br_ip_equal(&mp->addr, dst))\n\t\t\treturn mp;\n\t}\n\n\treturn NULL;\n}\n\nstruct net_bridge_mdb_entry *br_mdb_ip_get(struct net_bridge_mdb_htable *mdb,\n\t\t\t\t\t   struct br_ip *dst)\n{\n\tif (!mdb)\n\t\treturn NULL;\n\n\treturn __br_mdb_ip_get(mdb, dst, br_ip_hash(mdb, dst));\n}\n\nstatic struct net_bridge_mdb_entry *br_mdb_ip4_get(\n\tstruct net_bridge_mdb_htable *mdb, __be32 dst, __u16 vid)\n{\n\tstruct br_ip br_dst;\n\n\tbr_dst.u.ip4 = dst;\n\tbr_dst.proto = htons(ETH_P_IP);\n\tbr_dst.vid = vid;\n\n\treturn br_mdb_ip_get(mdb, &br_dst);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic struct net_bridge_mdb_entry *br_mdb_ip6_get(\n\tstruct net_bridge_mdb_htable *mdb, const struct in6_addr *dst,\n\t__u16 vid)\n{\n\tstruct br_ip br_dst;\n\n\tbr_dst.u.ip6 = *dst;\n\tbr_dst.proto = htons(ETH_P_IPV6);\n\tbr_dst.vid = vid;\n\n\treturn br_mdb_ip_get(mdb, &br_dst);\n}\n#endif\n\nstruct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,\n\t\t\t\t\tstruct sk_buff *skb, u16 vid)\n{\n\tstruct net_bridge_mdb_htable *mdb = rcu_dereference(br->mdb);\n\tstruct br_ip ip;\n\n\tif (br->multicast_disabled)\n\t\treturn NULL;\n\n\tif (BR_INPUT_SKB_CB(skb)->igmp)\n\t\treturn NULL;\n\n\tip.proto = skb->protocol;\n\tip.vid = vid;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tip.u.ip4 = ip_hdr(skb)->daddr;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\tip.u.ip6 = ipv6_hdr(skb)->daddr;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn br_mdb_ip_get(mdb, &ip);\n}\n\nstatic void br_mdb_free(struct rcu_head *head)\n{\n\tstruct net_bridge_mdb_htable *mdb =\n\t\tcontainer_of(head, struct net_bridge_mdb_htable, rcu);\n\tstruct net_bridge_mdb_htable *old = mdb->old;\n\n\tmdb->old = NULL;\n\tkfree(old->mhash);\n\tkfree(old);\n}\n\nstatic int br_mdb_copy(struct net_bridge_mdb_htable *new,\n\t\t       struct net_bridge_mdb_htable *old,\n\t\t       int elasticity)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tint maxlen;\n\tint len;\n\tint i;\n\n\tfor (i = 0; i < old->max; i++)\n\t\thlist_for_each_entry(mp, &old->mhash[i], hlist[old->ver])\n\t\t\thlist_add_head(&mp->hlist[new->ver],\n\t\t\t\t       &new->mhash[br_ip_hash(new, &mp->addr)]);\n\n\tif (!elasticity)\n\t\treturn 0;\n\n\tmaxlen = 0;\n\tfor (i = 0; i < new->max; i++) {\n\t\tlen = 0;\n\t\thlist_for_each_entry(mp, &new->mhash[i], hlist[new->ver])\n\t\t\tlen++;\n\t\tif (len > maxlen)\n\t\t\tmaxlen = len;\n\t}\n\n\treturn maxlen > elasticity ? -EINVAL : 0;\n}\n\nvoid br_multicast_free_pg(struct rcu_head *head)\n{\n\tstruct net_bridge_port_group *p =\n\t\tcontainer_of(head, struct net_bridge_port_group, rcu);\n\n\tkfree(p);\n}\n\nstatic void br_multicast_free_group(struct rcu_head *head)\n{\n\tstruct net_bridge_mdb_entry *mp =\n\t\tcontainer_of(head, struct net_bridge_mdb_entry, rcu);\n\n\tkfree(mp);\n}\n\nstatic void br_multicast_group_expired(unsigned long data)\n{\n\tstruct net_bridge_mdb_entry *mp = (void *)data;\n\tstruct net_bridge *br = mp->br;\n\tstruct net_bridge_mdb_htable *mdb;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || timer_pending(&mp->timer))\n\t\tgoto out;\n\n\tmp->mglist = false;\n\n\tif (mp->ports)\n\t\tgoto out;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\n\thlist_del_rcu(&mp->hlist[mdb->ver]);\n\tmdb->size--;\n\n\tcall_rcu_bh(&mp->rcu, br_multicast_free_group);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void br_multicast_del_pg(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\n\tmp = br_mdb_ip_get(mdb, &pg->addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\n\t\treturn;\n\t}\n\n\tWARN_ON(1);\n}\n\nstatic void br_multicast_port_group_expired(unsigned long data)\n{\n\tstruct net_bridge_port_group *pg = (void *)data;\n\tstruct net_bridge *br = pg->port->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || timer_pending(&pg->timer) ||\n\t    hlist_unhashed(&pg->mglist) || pg->state & MDB_PERMANENT)\n\t\tgoto out;\n\n\tbr_multicast_del_pg(br, pg);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic int br_mdb_rehash(struct net_bridge_mdb_htable __rcu **mdbp, int max,\n\t\t\t int elasticity)\n{\n\tstruct net_bridge_mdb_htable *old = rcu_dereference_protected(*mdbp, 1);\n\tstruct net_bridge_mdb_htable *mdb;\n\tint err;\n\n\tmdb = kmalloc(sizeof(*mdb), GFP_ATOMIC);\n\tif (!mdb)\n\t\treturn -ENOMEM;\n\n\tmdb->max = max;\n\tmdb->old = old;\n\n\tmdb->mhash = kzalloc(max * sizeof(*mdb->mhash), GFP_ATOMIC);\n\tif (!mdb->mhash) {\n\t\tkfree(mdb);\n\t\treturn -ENOMEM;\n\t}\n\n\tmdb->size = old ? old->size : 0;\n\tmdb->ver = old ? old->ver ^ 1 : 0;\n\n\tif (!old || elasticity)\n\t\tget_random_bytes(&mdb->secret, sizeof(mdb->secret));\n\telse\n\t\tmdb->secret = old->secret;\n\n\tif (!old)\n\t\tgoto out;\n\n\terr = br_mdb_copy(mdb, old, elasticity);\n\tif (err) {\n\t\tkfree(mdb->mhash);\n\t\tkfree(mdb);\n\t\treturn err;\n\t}\n\n\tbr_mdb_rehash_seq++;\n\tcall_rcu_bh(&mdb->rcu, br_mdb_free);\n\nout:\n\trcu_assign_pointer(*mdbp, mdb);\n\n\treturn 0;\n}\n\nstatic struct sk_buff *br_ip4_multicast_alloc_query(struct net_bridge *br,\n\t\t\t\t\t\t    __be32 group)\n{\n\tstruct sk_buff *skb;\n\tstruct igmphdr *ih;\n\tstruct ethhdr *eth;\n\tstruct iphdr *iph;\n\n\tskb = netdev_alloc_skb_ip_align(br->dev, sizeof(*eth) + sizeof(*iph) +\n\t\t\t\t\t\t sizeof(*ih) + 4);\n\tif (!skb)\n\t\tgoto out;\n\n\tskb->protocol = htons(ETH_P_IP);\n\n\tskb_reset_mac_header(skb);\n\teth = eth_hdr(skb);\n\n\tmemcpy(eth->h_source, br->dev->dev_addr, 6);\n\teth->h_dest[0] = 1;\n\teth->h_dest[1] = 0;\n\teth->h_dest[2] = 0x5e;\n\teth->h_dest[3] = 0;\n\teth->h_dest[4] = 0;\n\teth->h_dest[5] = 1;\n\teth->h_proto = htons(ETH_P_IP);\n\tskb_put(skb, sizeof(*eth));\n\n\tskb_set_network_header(skb, skb->len);\n\tiph = ip_hdr(skb);\n\n\tiph->version = 4;\n\tiph->ihl = 6;\n\tiph->tos = 0xc0;\n\tiph->tot_len = htons(sizeof(*iph) + sizeof(*ih) + 4);\n\tiph->id = 0;\n\tiph->frag_off = htons(IP_DF);\n\tiph->ttl = 1;\n\tiph->protocol = IPPROTO_IGMP;\n\tiph->saddr = br->multicast_query_use_ifaddr ?\n\t\t     inet_select_addr(br->dev, 0, RT_SCOPE_LINK) : 0;\n\tiph->daddr = htonl(INADDR_ALLHOSTS_GROUP);\n\t((u8 *)&iph[1])[0] = IPOPT_RA;\n\t((u8 *)&iph[1])[1] = 4;\n\t((u8 *)&iph[1])[2] = 0;\n\t((u8 *)&iph[1])[3] = 0;\n\tip_send_check(iph);\n\tskb_put(skb, 24);\n\n\tskb_set_transport_header(skb, skb->len);\n\tih = igmp_hdr(skb);\n\tih->type = IGMP_HOST_MEMBERSHIP_QUERY;\n\tih->code = (group ? br->multicast_last_member_interval :\n\t\t\t    br->multicast_query_response_interval) /\n\t\t   (HZ / IGMP_TIMER_SCALE);\n\tih->group = group;\n\tih->csum = 0;\n\tih->csum = ip_compute_csum((void *)ih, sizeof(struct igmphdr));\n\tskb_put(skb, sizeof(*ih));\n\n\t__skb_pull(skb, sizeof(*eth));\n\nout:\n\treturn skb;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic struct sk_buff *br_ip6_multicast_alloc_query(struct net_bridge *br,\n\t\t\t\t\t\t    const struct in6_addr *group)\n{\n\tstruct sk_buff *skb;\n\tstruct ipv6hdr *ip6h;\n\tstruct mld_msg *mldq;\n\tstruct ethhdr *eth;\n\tu8 *hopopt;\n\tunsigned long interval;\n\n\tskb = netdev_alloc_skb_ip_align(br->dev, sizeof(*eth) + sizeof(*ip6h) +\n\t\t\t\t\t\t 8 + sizeof(*mldq));\n\tif (!skb)\n\t\tgoto out;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\n\t/* Ethernet header */\n\tskb_reset_mac_header(skb);\n\teth = eth_hdr(skb);\n\n\tmemcpy(eth->h_source, br->dev->dev_addr, 6);\n\teth->h_proto = htons(ETH_P_IPV6);\n\tskb_put(skb, sizeof(*eth));\n\n\t/* IPv6 header + HbH option */\n\tskb_set_network_header(skb, skb->len);\n\tip6h = ipv6_hdr(skb);\n\n\t*(__force __be32 *)ip6h = htonl(0x60000000);\n\tip6h->payload_len = htons(8 + sizeof(*mldq));\n\tip6h->nexthdr = IPPROTO_HOPOPTS;\n\tip6h->hop_limit = 1;\n\tipv6_addr_set(&ip6h->daddr, htonl(0xff020000), 0, 0, htonl(1));\n\tif (ipv6_dev_get_saddr(dev_net(br->dev), br->dev, &ip6h->daddr, 0,\n\t\t\t       &ip6h->saddr)) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\tipv6_eth_mc_map(&ip6h->daddr, eth->h_dest);\n\n\thopopt = (u8 *)(ip6h + 1);\n\thopopt[0] = IPPROTO_ICMPV6;\t\t/* next hdr */\n\thopopt[1] = 0;\t\t\t\t/* length of HbH */\n\thopopt[2] = IPV6_TLV_ROUTERALERT;\t/* Router Alert */\n\thopopt[3] = 2;\t\t\t\t/* Length of RA Option */\n\thopopt[4] = 0;\t\t\t\t/* Type = 0x0000 (MLD) */\n\thopopt[5] = 0;\n\thopopt[6] = IPV6_TLV_PAD1;\t\t/* Pad1 */\n\thopopt[7] = IPV6_TLV_PAD1;\t\t/* Pad1 */\n\n\tskb_put(skb, sizeof(*ip6h) + 8);\n\n\t/* ICMPv6 */\n\tskb_set_transport_header(skb, skb->len);\n\tmldq = (struct mld_msg *) icmp6_hdr(skb);\n\n\tinterval = ipv6_addr_any(group) ?\n\t\t\tbr->multicast_query_response_interval :\n\t\t\tbr->multicast_last_member_interval;\n\n\tmldq->mld_type = ICMPV6_MGM_QUERY;\n\tmldq->mld_code = 0;\n\tmldq->mld_cksum = 0;\n\tmldq->mld_maxdelay = htons((u16)jiffies_to_msecs(interval));\n\tmldq->mld_reserved = 0;\n\tmldq->mld_mca = *group;\n\n\t/* checksum */\n\tmldq->mld_cksum = csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr,\n\t\t\t\t\t  sizeof(*mldq), IPPROTO_ICMPV6,\n\t\t\t\t\t  csum_partial(mldq,\n\t\t\t\t\t\t       sizeof(*mldq), 0));\n\tskb_put(skb, sizeof(*mldq));\n\n\t__skb_pull(skb, sizeof(*eth));\n\nout:\n\treturn skb;\n}\n#endif\n\nstatic struct sk_buff *br_multicast_alloc_query(struct net_bridge *br,\n\t\t\t\t\t\tstruct br_ip *addr)\n{\n\tswitch (addr->proto) {\n\tcase htons(ETH_P_IP):\n\t\treturn br_ip4_multicast_alloc_query(br, addr->u.ip4);\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\treturn br_ip6_multicast_alloc_query(br, &addr->u.ip6);\n#endif\n\t}\n\treturn NULL;\n}\n\nstatic struct net_bridge_mdb_entry *br_multicast_get_group(\n\tstruct net_bridge *br, struct net_bridge_port *port,\n\tstruct br_ip *group, int hash)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tunsigned int count = 0;\n\tunsigned int max;\n\tint elasticity;\n\tint err;\n\n\tmdb = rcu_dereference_protected(br->mdb, 1);\n\thlist_for_each_entry(mp, &mdb->mhash[hash], hlist[mdb->ver]) {\n\t\tcount++;\n\t\tif (unlikely(br_ip_equal(group, &mp->addr)))\n\t\t\treturn mp;\n\t}\n\n\telasticity = 0;\n\tmax = mdb->max;\n\n\tif (unlikely(count > br->hash_elasticity && count)) {\n\t\tif (net_ratelimit())\n\t\t\tbr_info(br, \"Multicast hash table \"\n\t\t\t\t\"chain limit reached: %s\\n\",\n\t\t\t\tport ? port->dev->name : br->dev->name);\n\n\t\telasticity = br->hash_elasticity;\n\t}\n\n\tif (mdb->size >= max) {\n\t\tmax *= 2;\n\t\tif (unlikely(max > br->hash_max)) {\n\t\t\tbr_warn(br, \"Multicast hash table maximum of %d \"\n\t\t\t\t\"reached, disabling snooping: %s\\n\",\n\t\t\t\tbr->hash_max,\n\t\t\t\tport ? port->dev->name : br->dev->name);\n\t\t\terr = -E2BIG;\ndisable:\n\t\t\tbr->multicast_disabled = 1;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (max > mdb->max || elasticity) {\n\t\tif (mdb->old) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tbr_info(br, \"Multicast hash table \"\n\t\t\t\t\t\"on fire: %s\\n\",\n\t\t\t\t\tport ? port->dev->name : br->dev->name);\n\t\t\terr = -EEXIST;\n\t\t\tgoto err;\n\t\t}\n\n\t\terr = br_mdb_rehash(&br->mdb, max, elasticity);\n\t\tif (err) {\n\t\t\tbr_warn(br, \"Cannot rehash multicast \"\n\t\t\t\t\"hash table, disabling snooping: %s, %d, %d\\n\",\n\t\t\t\tport ? port->dev->name : br->dev->name,\n\t\t\t\tmdb->size, err);\n\t\t\tgoto disable;\n\t\t}\n\n\t\terr = -EAGAIN;\n\t\tgoto err;\n\t}\n\n\treturn NULL;\n\nerr:\n\tmp = ERR_PTR(err);\n\treturn mp;\n}\n\nstruct net_bridge_mdb_entry *br_multicast_new_group(struct net_bridge *br,\n\tstruct net_bridge_port *port, struct br_ip *group)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tint hash;\n\tint err;\n\n\tmdb = rcu_dereference_protected(br->mdb, 1);\n\tif (!mdb) {\n\t\terr = br_mdb_rehash(&br->mdb, BR_HASH_SIZE, 0);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tgoto rehash;\n\t}\n\n\thash = br_ip_hash(mdb, group);\n\tmp = br_multicast_get_group(br, port, group, hash);\n\tswitch (PTR_ERR(mp)) {\n\tcase 0:\n\t\tbreak;\n\n\tcase -EAGAIN:\nrehash:\n\t\tmdb = rcu_dereference_protected(br->mdb, 1);\n\t\thash = br_ip_hash(mdb, group);\n\t\tbreak;\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tmp = kzalloc(sizeof(*mp), GFP_ATOMIC);\n\tif (unlikely(!mp))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmp->br = br;\n\tmp->addr = *group;\n\n\thlist_add_head_rcu(&mp->hlist[mdb->ver], &mdb->mhash[hash]);\n\tmdb->size++;\n\nout:\n\treturn mp;\n}\n\nstruct net_bridge_port_group *br_multicast_new_port_group(\n\t\t\tstruct net_bridge_port *port,\n\t\t\tstruct br_ip *group,\n\t\t\tstruct net_bridge_port_group __rcu *next,\n\t\t\tunsigned char state)\n{\n\tstruct net_bridge_port_group *p;\n\n\tp = kzalloc(sizeof(*p), GFP_ATOMIC);\n\tif (unlikely(!p))\n\t\treturn NULL;\n\n\tp->addr = *group;\n\tp->port = port;\n\tp->state = state;\n\trcu_assign_pointer(p->next, next);\n\thlist_add_head(&p->mglist, &port->mglist);\n\tsetup_timer(&p->timer, br_multicast_port_group_expired,\n\t\t    (unsigned long)p);\n\treturn p;\n}\n\nstatic int br_multicast_add_group(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct br_ip *group)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tint err;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\n\tmp = br_multicast_new_group(br, port, group);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto err;\n\n\tif (!port) {\n\t\tmp->mglist = true;\n\t\tgoto out;\n\t}\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\tgoto out;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\n\tp = br_multicast_new_port_group(port, group, *pp, MDB_TEMPORARY);\n\tif (unlikely(!p))\n\t\tgoto err;\n\trcu_assign_pointer(*pp, p);\n\tbr_mdb_notify(br->dev, port, group, RTM_NEWMDB);\n\nout:\n\terr = 0;\n\nerr:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}\n\nstatic int br_ip4_multicast_add_group(struct net_bridge *br,\n\t\t\t\t      struct net_bridge_port *port,\n\t\t\t\t      __be32 group,\n\t\t\t\t      __u16 vid)\n{\n\tstruct br_ip br_group;\n\n\tif (ipv4_is_local_multicast(group))\n\t\treturn 0;\n\n\tbr_group.u.ip4 = group;\n\tbr_group.proto = htons(ETH_P_IP);\n\tbr_group.vid = vid;\n\n\treturn br_multicast_add_group(br, port, &br_group);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int br_ip6_multicast_add_group(struct net_bridge *br,\n\t\t\t\t      struct net_bridge_port *port,\n\t\t\t\t      const struct in6_addr *group,\n\t\t\t\t      __u16 vid)\n{\n\tstruct br_ip br_group;\n\n\tif (!ipv6_is_transient_multicast(group))\n\t\treturn 0;\n\n\tbr_group.u.ip6 = *group;\n\tbr_group.proto = htons(ETH_P_IPV6);\n\tbr_group.vid = vid;\n\n\treturn br_multicast_add_group(br, port, &br_group);\n}\n#endif\n\nstatic void br_multicast_router_expired(unsigned long data)\n{\n\tstruct net_bridge_port *port = (void *)data;\n\tstruct net_bridge *br = port->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (port->multicast_router != 1 ||\n\t    timer_pending(&port->multicast_router_timer) ||\n\t    hlist_unhashed(&port->rlist))\n\t\tgoto out;\n\n\thlist_del_init_rcu(&port->rlist);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void br_multicast_local_router_expired(unsigned long data)\n{\n}\n\nstatic void br_multicast_querier_expired(unsigned long data)\n{\n\tstruct net_bridge *br = (void *)data;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\tgoto out;\n\n\tbr_multicast_start_querier(br);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void __br_multicast_send_query(struct net_bridge *br,\n\t\t\t\t      struct net_bridge_port *port,\n\t\t\t\t      struct br_ip *ip)\n{\n\tstruct sk_buff *skb;\n\n\tskb = br_multicast_alloc_query(br, ip);\n\tif (!skb)\n\t\treturn;\n\n\tif (port) {\n\t\t__skb_push(skb, sizeof(struct ethhdr));\n\t\tskb->dev = port->dev;\n\t\tNF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, skb, NULL, skb->dev,\n\t\t\tdev_queue_xmit);\n\t} else\n\t\tnetif_rx(skb);\n}\n\nstatic void br_multicast_send_query(struct net_bridge *br,\n\t\t\t\t    struct net_bridge_port *port, u32 sent)\n{\n\tunsigned long time;\n\tstruct br_ip br_group;\n\n\tif (!netif_running(br->dev) || br->multicast_disabled ||\n\t    !br->multicast_querier ||\n\t    timer_pending(&br->multicast_querier_timer))\n\t\treturn;\n\n\tmemset(&br_group.u, 0, sizeof(br_group.u));\n\n\tbr_group.proto = htons(ETH_P_IP);\n\t__br_multicast_send_query(br, port, &br_group);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tbr_group.proto = htons(ETH_P_IPV6);\n\t__br_multicast_send_query(br, port, &br_group);\n#endif\n\n\ttime = jiffies;\n\ttime += sent < br->multicast_startup_query_count ?\n\t\tbr->multicast_startup_query_interval :\n\t\tbr->multicast_query_interval;\n\tmod_timer(port ? &port->multicast_query_timer :\n\t\t\t &br->multicast_query_timer, time);\n}\n\nstatic void br_multicast_port_query_expired(unsigned long data)\n{\n\tstruct net_bridge_port *port = (void *)data;\n\tstruct net_bridge *br = port->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (port->state == BR_STATE_DISABLED ||\n\t    port->state == BR_STATE_BLOCKING)\n\t\tgoto out;\n\n\tif (port->multicast_startup_queries_sent <\n\t    br->multicast_startup_query_count)\n\t\tport->multicast_startup_queries_sent++;\n\n\tbr_multicast_send_query(port->br, port,\n\t\t\t\tport->multicast_startup_queries_sent);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nvoid br_multicast_add_port(struct net_bridge_port *port)\n{\n\tport->multicast_router = 1;\n\n\tsetup_timer(&port->multicast_router_timer, br_multicast_router_expired,\n\t\t    (unsigned long)port);\n\tsetup_timer(&port->multicast_query_timer,\n\t\t    br_multicast_port_query_expired, (unsigned long)port);\n}\n\nvoid br_multicast_del_port(struct net_bridge_port *port)\n{\n\tdel_timer_sync(&port->multicast_router_timer);\n}\n\nstatic void __br_multicast_enable_port(struct net_bridge_port *port)\n{\n\tport->multicast_startup_queries_sent = 0;\n\n\tif (try_to_del_timer_sync(&port->multicast_query_timer) >= 0 ||\n\t    del_timer(&port->multicast_query_timer))\n\t\tmod_timer(&port->multicast_query_timer, jiffies);\n}\n\nvoid br_multicast_enable_port(struct net_bridge_port *port)\n{\n\tstruct net_bridge *br = port->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (br->multicast_disabled || !netif_running(br->dev))\n\t\tgoto out;\n\n\t__br_multicast_enable_port(port);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nvoid br_multicast_disable_port(struct net_bridge_port *port)\n{\n\tstruct net_bridge *br = port->br;\n\tstruct net_bridge_port_group *pg;\n\tstruct hlist_node *n;\n\n\tspin_lock(&br->multicast_lock);\n\thlist_for_each_entry_safe(pg, n, &port->mglist, mglist)\n\t\tbr_multicast_del_pg(br, pg);\n\n\tif (!hlist_unhashed(&port->rlist))\n\t\thlist_del_init_rcu(&port->rlist);\n\tdel_timer(&port->multicast_router_timer);\n\tdel_timer(&port->multicast_query_timer);\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic int br_ip4_multicast_igmp3_report(struct net_bridge *br,\n\t\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct igmpv3_report *ih;\n\tstruct igmpv3_grec *grec;\n\tint i;\n\tint len;\n\tint num;\n\tint type;\n\tint err = 0;\n\t__be32 group;\n\tu16 vid = 0;\n\n\tif (!pskb_may_pull(skb, sizeof(*ih)))\n\t\treturn -EINVAL;\n\n\tbr_vlan_get_tag(skb, &vid);\n\tih = igmpv3_report_hdr(skb);\n\tnum = ntohs(ih->ngrec);\n\tlen = sizeof(*ih);\n\n\tfor (i = 0; i < num; i++) {\n\t\tlen += sizeof(*grec);\n\t\tif (!pskb_may_pull(skb, len))\n\t\t\treturn -EINVAL;\n\n\t\tgrec = (void *)(skb->data + len - sizeof(*grec));\n\t\tgroup = grec->grec_mca;\n\t\ttype = grec->grec_type;\n\n\t\tlen += ntohs(grec->grec_nsrcs) * 4;\n\t\tif (!pskb_may_pull(skb, len))\n\t\t\treturn -EINVAL;\n\n\t\t/* We treat this as an IGMPv2 report for now. */\n\t\tswitch (type) {\n\t\tcase IGMPV3_MODE_IS_INCLUDE:\n\t\tcase IGMPV3_MODE_IS_EXCLUDE:\n\t\tcase IGMPV3_CHANGE_TO_INCLUDE:\n\t\tcase IGMPV3_CHANGE_TO_EXCLUDE:\n\t\tcase IGMPV3_ALLOW_NEW_SOURCES:\n\t\tcase IGMPV3_BLOCK_OLD_SOURCES:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = br_ip4_multicast_add_group(br, port, group, vid);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int br_ip6_multicast_mld2_report(struct net_bridge *br,\n\t\t\t\t\tstruct net_bridge_port *port,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct icmp6hdr *icmp6h;\n\tstruct mld2_grec *grec;\n\tint i;\n\tint len;\n\tint num;\n\tint err = 0;\n\tu16 vid = 0;\n\n\tif (!pskb_may_pull(skb, sizeof(*icmp6h)))\n\t\treturn -EINVAL;\n\n\tbr_vlan_get_tag(skb, &vid);\n\ticmp6h = icmp6_hdr(skb);\n\tnum = ntohs(icmp6h->icmp6_dataun.un_data16[1]);\n\tlen = sizeof(*icmp6h);\n\n\tfor (i = 0; i < num; i++) {\n\t\t__be16 *nsrcs, _nsrcs;\n\n\t\tnsrcs = skb_header_pointer(skb,\n\t\t\t\t\t   len + offsetof(struct mld2_grec,\n\t\t\t\t\t\t\t  grec_nsrcs),\n\t\t\t\t\t   sizeof(_nsrcs), &_nsrcs);\n\t\tif (!nsrcs)\n\t\t\treturn -EINVAL;\n\n\t\tif (!pskb_may_pull(skb,\n\t\t\t\t   len + sizeof(*grec) +\n\t\t\t\t   sizeof(struct in6_addr) * ntohs(*nsrcs)))\n\t\t\treturn -EINVAL;\n\n\t\tgrec = (struct mld2_grec *)(skb->data + len);\n\t\tlen += sizeof(*grec) +\n\t\t       sizeof(struct in6_addr) * ntohs(*nsrcs);\n\n\t\t/* We treat these as MLDv1 reports for now. */\n\t\tswitch (grec->grec_type) {\n\t\tcase MLD2_MODE_IS_INCLUDE:\n\t\tcase MLD2_MODE_IS_EXCLUDE:\n\t\tcase MLD2_CHANGE_TO_INCLUDE:\n\t\tcase MLD2_CHANGE_TO_EXCLUDE:\n\t\tcase MLD2_ALLOW_NEW_SOURCES:\n\t\tcase MLD2_BLOCK_OLD_SOURCES:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = br_ip6_multicast_add_group(br, port, &grec->grec_mca,\n\t\t\t\t\t\t vid);\n\t\tif (!err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n#endif\n\n/*\n * Add port to router_list\n *  list is maintained ordered by pointer value\n *  and locked by br->multicast_lock and RCU\n */\nstatic void br_multicast_add_router(struct net_bridge *br,\n\t\t\t\t    struct net_bridge_port *port)\n{\n\tstruct net_bridge_port *p;\n\tstruct hlist_node *slot = NULL;\n\n\thlist_for_each_entry(p, &br->router_list, rlist) {\n\t\tif ((unsigned long) port >= (unsigned long) p)\n\t\t\tbreak;\n\t\tslot = &p->rlist;\n\t}\n\n\tif (slot)\n\t\thlist_add_after_rcu(slot, &port->rlist);\n\telse\n\t\thlist_add_head_rcu(&port->rlist, &br->router_list);\n}\n\nstatic void br_multicast_mark_router(struct net_bridge *br,\n\t\t\t\t     struct net_bridge_port *port)\n{\n\tunsigned long now = jiffies;\n\n\tif (!port) {\n\t\tif (br->multicast_router == 1)\n\t\t\tmod_timer(&br->multicast_router_timer,\n\t\t\t\t  now + br->multicast_querier_interval);\n\t\treturn;\n\t}\n\n\tif (port->multicast_router != 1)\n\t\treturn;\n\n\tif (!hlist_unhashed(&port->rlist))\n\t\tgoto timer;\n\n\tbr_multicast_add_router(br, port);\n\ntimer:\n\tmod_timer(&port->multicast_router_timer,\n\t\t  now + br->multicast_querier_interval);\n}\n\nstatic void br_multicast_query_received(struct net_bridge *br,\n\t\t\t\t\tstruct net_bridge_port *port,\n\t\t\t\t\tint saddr)\n{\n\tif (saddr)\n\t\tmod_timer(&br->multicast_querier_timer,\n\t\t\t  jiffies + br->multicast_querier_interval);\n\telse if (timer_pending(&br->multicast_querier_timer))\n\t\treturn;\n\n\tbr_multicast_mark_router(br, port);\n}\n\nstatic int br_ip4_multicast_query(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tstruct igmphdr *ih = igmp_hdr(skb);\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct igmpv3_query *ih3;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long max_delay;\n\tunsigned long now = jiffies;\n\t__be32 group;\n\tint err = 0;\n\tu16 vid = 0;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\n\tbr_multicast_query_received(br, port, !!iph->saddr);\n\n\tgroup = ih->group;\n\n\tif (skb->len == sizeof(*ih)) {\n\t\tmax_delay = ih->code * (HZ / IGMP_TIMER_SCALE);\n\n\t\tif (!max_delay) {\n\t\t\tmax_delay = 10 * HZ;\n\t\t\tgroup = 0;\n\t\t}\n\t} else {\n\t\tif (!pskb_may_pull(skb, sizeof(struct igmpv3_query))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tih3 = igmpv3_query_hdr(skb);\n\t\tif (ih3->nsrcs)\n\t\t\tgoto out;\n\n\t\tmax_delay = ih3->code ?\n\t\t\t    IGMPV3_MRC(ih3->code) * (HZ / IGMP_TIMER_SCALE) : 1;\n\t}\n\n\tif (!group)\n\t\tgoto out;\n\n\tbr_vlan_get_tag(skb, &vid);\n\tmp = br_mdb_ip4_get(mlock_dereference(br->mdb, br), group, vid);\n\tif (!mp)\n\t\tgoto out;\n\n\tsetup_timer(&mp->timer, br_multicast_group_expired, (unsigned long)mp);\n\tmod_timer(&mp->timer, now + br->multicast_membership_interval);\n\tmp->timer_armed = true;\n\n\tmax_delay *= br->multicast_last_member_count;\n\n\tif (mp->mglist &&\n\t    (timer_pending(&mp->timer) ?\n\t     time_after(mp->timer.expires, now + max_delay) :\n\t     try_to_del_timer_sync(&mp->timer) >= 0))\n\t\tmod_timer(&mp->timer, now + max_delay);\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (timer_pending(&p->timer) ?\n\t\t    time_after(p->timer.expires, now + max_delay) :\n\t\t    try_to_del_timer_sync(&p->timer) >= 0)\n\t\t\tmod_timer(&p->timer, now + max_delay);\n\t}\n\nout:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int br_ip6_multicast_query(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\tstruct mld_msg *mld;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct mld2_query *mld2q;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long max_delay;\n\tunsigned long now = jiffies;\n\tconst struct in6_addr *group = NULL;\n\tint err = 0;\n\tu16 vid = 0;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\n\tbr_multicast_query_received(br, port, !ipv6_addr_any(&ip6h->saddr));\n\n\tif (skb->len == sizeof(*mld)) {\n\t\tif (!pskb_may_pull(skb, sizeof(*mld))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmld = (struct mld_msg *) icmp6_hdr(skb);\n\t\tmax_delay = msecs_to_jiffies(ntohs(mld->mld_maxdelay));\n\t\tif (max_delay)\n\t\t\tgroup = &mld->mld_mca;\n\t} else if (skb->len >= sizeof(*mld2q)) {\n\t\tif (!pskb_may_pull(skb, sizeof(*mld2q))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmld2q = (struct mld2_query *)icmp6_hdr(skb);\n\t\tif (!mld2q->mld2q_nsrcs)\n\t\t\tgroup = &mld2q->mld2q_mca;\n\t\tmax_delay = mld2q->mld2q_mrc ? MLDV2_MRC(ntohs(mld2q->mld2q_mrc)) : 1;\n\t}\n\n\tif (!group)\n\t\tgoto out;\n\n\tbr_vlan_get_tag(skb, &vid);\n\tmp = br_mdb_ip6_get(mlock_dereference(br->mdb, br), group, vid);\n\tif (!mp)\n\t\tgoto out;\n\n\tsetup_timer(&mp->timer, br_multicast_group_expired, (unsigned long)mp);\n\tmod_timer(&mp->timer, now + br->multicast_membership_interval);\n\tmp->timer_armed = true;\n\n\tmax_delay *= br->multicast_last_member_count;\n\tif (mp->mglist &&\n\t    (timer_pending(&mp->timer) ?\n\t     time_after(mp->timer.expires, now + max_delay) :\n\t     try_to_del_timer_sync(&mp->timer) >= 0))\n\t\tmod_timer(&mp->timer, now + max_delay);\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (timer_pending(&p->timer) ?\n\t\t    time_after(p->timer.expires, now + max_delay) :\n\t\t    try_to_del_timer_sync(&p->timer) >= 0)\n\t\t\tmod_timer(&p->timer, now + max_delay);\n\t}\n\nout:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}\n#endif\n\nstatic void br_multicast_leave_group(struct net_bridge *br,\n\t\t\t\t     struct net_bridge_port *port,\n\t\t\t\t     struct br_ip *group)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tunsigned long now;\n\tunsigned long time;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED) ||\n\t    timer_pending(&br->multicast_querier_timer))\n\t\tgoto out;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, group);\n\tif (!mp)\n\t\tgoto out;\n\n\tif (br->multicast_querier &&\n\t    !timer_pending(&br->multicast_querier_timer)) {\n\t\t__br_multicast_send_query(br, port, &mp->addr);\n\n\t\ttime = jiffies + br->multicast_last_member_count *\n\t\t\t\t br->multicast_last_member_interval;\n\t\tmod_timer(port ? &port->multicast_query_timer :\n\t\t\t\t &br->multicast_query_timer, time);\n\n\t\tfor (p = mlock_dereference(mp->ports, br);\n\t\t     p != NULL;\n\t\t     p = mlock_dereference(p->next, br)) {\n\t\t\tif (p->port != port)\n\t\t\t\tcontinue;\n\n\t\t\tif (!hlist_unhashed(&p->mglist) &&\n\t\t\t    (timer_pending(&p->timer) ?\n\t\t\t     time_after(p->timer.expires, time) :\n\t\t\t     try_to_del_timer_sync(&p->timer) >= 0)) {\n\t\t\t\tmod_timer(&p->timer, time);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (port && (port->flags & BR_MULTICAST_FAST_LEAVE)) {\n\t\tstruct net_bridge_port_group __rcu **pp;\n\n\t\tfor (pp = &mp->ports;\n\t\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t\t     pp = &p->next) {\n\t\t\tif (p->port != port)\n\t\t\t\tcontinue;\n\n\t\t\trcu_assign_pointer(*pp, p->next);\n\t\t\thlist_del_init(&p->mglist);\n\t\t\tdel_timer(&p->timer);\n\t\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\t\tbr_mdb_notify(br->dev, port, group, RTM_DELMDB);\n\n\t\t\tif (!mp->ports && !mp->mglist && mp->timer_armed &&\n\t\t\t    netif_running(br->dev))\n\t\t\t\tmod_timer(&mp->timer, jiffies);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tnow = jiffies;\n\ttime = now + br->multicast_last_member_count *\n\t\t     br->multicast_last_member_interval;\n\n\tif (!port) {\n\t\tif (mp->mglist && mp->timer_armed &&\n\t\t    (timer_pending(&mp->timer) ?\n\t\t     time_after(mp->timer.expires, time) :\n\t\t     try_to_del_timer_sync(&mp->timer) >= 0)) {\n\t\t\tmod_timer(&mp->timer, time);\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void br_ip4_multicast_leave_group(struct net_bridge *br,\n\t\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t\t __be32 group,\n\t\t\t\t\t __u16 vid)\n{\n\tstruct br_ip br_group;\n\n\tif (ipv4_is_local_multicast(group))\n\t\treturn;\n\n\tbr_group.u.ip4 = group;\n\tbr_group.proto = htons(ETH_P_IP);\n\tbr_group.vid = vid;\n\n\tbr_multicast_leave_group(br, port, &br_group);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void br_ip6_multicast_leave_group(struct net_bridge *br,\n\t\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t\t const struct in6_addr *group,\n\t\t\t\t\t __u16 vid)\n{\n\tstruct br_ip br_group;\n\n\tif (!ipv6_is_transient_multicast(group))\n\t\treturn;\n\n\tbr_group.u.ip6 = *group;\n\tbr_group.proto = htons(ETH_P_IPV6);\n\tbr_group.vid = vid;\n\n\tbr_multicast_leave_group(br, port, &br_group);\n}\n#endif\n\nstatic int br_multicast_ipv4_rcv(struct net_bridge *br,\n\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct sk_buff *skb2 = skb;\n\tconst struct iphdr *iph;\n\tstruct igmphdr *ih;\n\tunsigned int len;\n\tunsigned int offset;\n\tint err;\n\tu16 vid = 0;\n\n\t/* We treat OOM as packet loss for now. */\n\tif (!pskb_may_pull(skb, sizeof(*iph)))\n\t\treturn -EINVAL;\n\n\tiph = ip_hdr(skb);\n\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\treturn -EINVAL;\n\n\tif (!pskb_may_pull(skb, ip_hdrlen(skb)))\n\t\treturn -EINVAL;\n\n\tiph = ip_hdr(skb);\n\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\treturn -EINVAL;\n\n\tif (iph->protocol != IPPROTO_IGMP) {\n\t\tif (!ipv4_is_local_multicast(iph->daddr))\n\t\t\tBR_INPUT_SKB_CB(skb)->mrouters_only = 1;\n\t\treturn 0;\n\t}\n\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len || len < ip_hdrlen(skb))\n\t\treturn -EINVAL;\n\n\tif (skb->len > len) {\n\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!skb2)\n\t\t\treturn -ENOMEM;\n\n\t\terr = pskb_trim_rcsum(skb2, len);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\tlen -= ip_hdrlen(skb2);\n\toffset = skb_network_offset(skb2) + ip_hdrlen(skb2);\n\t__skb_pull(skb2, offset);\n\tskb_reset_transport_header(skb2);\n\n\terr = -EINVAL;\n\tif (!pskb_may_pull(skb2, sizeof(*ih)))\n\t\tgoto out;\n\n\tswitch (skb2->ip_summed) {\n\tcase CHECKSUM_COMPLETE:\n\t\tif (!csum_fold(skb2->csum))\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase CHECKSUM_NONE:\n\t\tskb2->csum = 0;\n\t\tif (skb_checksum_complete(skb2))\n\t\t\tgoto out;\n\t}\n\n\terr = 0;\n\n\tbr_vlan_get_tag(skb2, &vid);\n\tBR_INPUT_SKB_CB(skb)->igmp = 1;\n\tih = igmp_hdr(skb2);\n\n\tswitch (ih->type) {\n\tcase IGMP_HOST_MEMBERSHIP_REPORT:\n\tcase IGMPV2_HOST_MEMBERSHIP_REPORT:\n\t\tBR_INPUT_SKB_CB(skb)->mrouters_only = 1;\n\t\terr = br_ip4_multicast_add_group(br, port, ih->group, vid);\n\t\tbreak;\n\tcase IGMPV3_HOST_MEMBERSHIP_REPORT:\n\t\terr = br_ip4_multicast_igmp3_report(br, port, skb2);\n\t\tbreak;\n\tcase IGMP_HOST_MEMBERSHIP_QUERY:\n\t\terr = br_ip4_multicast_query(br, port, skb2);\n\t\tbreak;\n\tcase IGMP_HOST_LEAVE_MESSAGE:\n\t\tbr_ip4_multicast_leave_group(br, port, ih->group, vid);\n\t\tbreak;\n\t}\n\nout:\n\t__skb_push(skb2, offset);\nerr_out:\n\tif (skb2 != skb)\n\t\tkfree_skb(skb2);\n\treturn err;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int br_multicast_ipv6_rcv(struct net_bridge *br,\n\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct sk_buff *skb2;\n\tconst struct ipv6hdr *ip6h;\n\tu8 icmp6_type;\n\tu8 nexthdr;\n\t__be16 frag_off;\n\tunsigned int len;\n\tint offset;\n\tint err;\n\tu16 vid = 0;\n\n\tif (!pskb_may_pull(skb, sizeof(*ip6h)))\n\t\treturn -EINVAL;\n\n\tip6h = ipv6_hdr(skb);\n\n\t/*\n\t * We're interested in MLD messages only.\n\t *  - Version is 6\n\t *  - MLD has always Router Alert hop-by-hop option\n\t *  - But we do not support jumbrograms.\n\t */\n\tif (ip6h->version != 6 ||\n\t    ip6h->nexthdr != IPPROTO_HOPOPTS ||\n\t    ip6h->payload_len == 0)\n\t\treturn 0;\n\n\tlen = ntohs(ip6h->payload_len) + sizeof(*ip6h);\n\tif (skb->len < len)\n\t\treturn -EINVAL;\n\n\tnexthdr = ip6h->nexthdr;\n\toffset = ipv6_skip_exthdr(skb, sizeof(*ip6h), &nexthdr, &frag_off);\n\n\tif (offset < 0 || nexthdr != IPPROTO_ICMPV6)\n\t\treturn 0;\n\n\t/* Okay, we found ICMPv6 header */\n\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\terr = -EINVAL;\n\tif (!pskb_may_pull(skb2, offset + sizeof(struct icmp6hdr)))\n\t\tgoto out;\n\n\tlen -= offset - skb_network_offset(skb2);\n\n\t__skb_pull(skb2, offset);\n\tskb_reset_transport_header(skb2);\n\tskb_postpull_rcsum(skb2, skb_network_header(skb2),\n\t\t\t   skb_network_header_len(skb2));\n\n\ticmp6_type = icmp6_hdr(skb2)->icmp6_type;\n\n\tswitch (icmp6_type) {\n\tcase ICMPV6_MGM_QUERY:\n\tcase ICMPV6_MGM_REPORT:\n\tcase ICMPV6_MGM_REDUCTION:\n\tcase ICMPV6_MLD2_REPORT:\n\t\tbreak;\n\tdefault:\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\t/* Okay, we found MLD message. Check further. */\n\tif (skb2->len > len) {\n\t\terr = pskb_trim_rcsum(skb2, len);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = -EINVAL;\n\t}\n\n\tip6h = ipv6_hdr(skb2);\n\n\tswitch (skb2->ip_summed) {\n\tcase CHECKSUM_COMPLETE:\n\t\tif (!csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr, skb2->len,\n\t\t\t\t\tIPPROTO_ICMPV6, skb2->csum))\n\t\t\tbreak;\n\t\t/*FALLTHROUGH*/\n\tcase CHECKSUM_NONE:\n\t\tskb2->csum = ~csum_unfold(csum_ipv6_magic(&ip6h->saddr,\n\t\t\t\t\t\t\t&ip6h->daddr,\n\t\t\t\t\t\t\tskb2->len,\n\t\t\t\t\t\t\tIPPROTO_ICMPV6, 0));\n\t\tif (__skb_checksum_complete(skb2))\n\t\t\tgoto out;\n\t}\n\n\terr = 0;\n\n\tbr_vlan_get_tag(skb, &vid);\n\tBR_INPUT_SKB_CB(skb)->igmp = 1;\n\n\tswitch (icmp6_type) {\n\tcase ICMPV6_MGM_REPORT:\n\t    {\n\t\tstruct mld_msg *mld;\n\t\tif (!pskb_may_pull(skb2, sizeof(*mld))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmld = (struct mld_msg *)skb_transport_header(skb2);\n\t\tBR_INPUT_SKB_CB(skb)->mrouters_only = 1;\n\t\terr = br_ip6_multicast_add_group(br, port, &mld->mld_mca, vid);\n\t\tbreak;\n\t    }\n\tcase ICMPV6_MLD2_REPORT:\n\t\terr = br_ip6_multicast_mld2_report(br, port, skb2);\n\t\tbreak;\n\tcase ICMPV6_MGM_QUERY:\n\t\terr = br_ip6_multicast_query(br, port, skb2);\n\t\tbreak;\n\tcase ICMPV6_MGM_REDUCTION:\n\t    {\n\t\tstruct mld_msg *mld;\n\t\tif (!pskb_may_pull(skb2, sizeof(*mld))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmld = (struct mld_msg *)skb_transport_header(skb2);\n\t\tbr_ip6_multicast_leave_group(br, port, &mld->mld_mca, vid);\n\t    }\n\t}\n\nout:\n\tkfree_skb(skb2);\n\treturn err;\n}\n#endif\n\nint br_multicast_rcv(struct net_bridge *br, struct net_bridge_port *port,\n\t\t     struct sk_buff *skb)\n{\n\tBR_INPUT_SKB_CB(skb)->igmp = 0;\n\tBR_INPUT_SKB_CB(skb)->mrouters_only = 0;\n\n\tif (br->multicast_disabled)\n\t\treturn 0;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\treturn br_multicast_ipv4_rcv(br, port, skb);\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\treturn br_multicast_ipv6_rcv(br, port, skb);\n#endif\n\t}\n\n\treturn 0;\n}\n\nstatic void br_multicast_query_expired(unsigned long data)\n{\n\tstruct net_bridge *br = (void *)data;\n\n\tspin_lock(&br->multicast_lock);\n\tif (br->multicast_startup_queries_sent <\n\t    br->multicast_startup_query_count)\n\t\tbr->multicast_startup_queries_sent++;\n\n\tbr_multicast_send_query(br, NULL, br->multicast_startup_queries_sent);\n\n\tspin_unlock(&br->multicast_lock);\n}\n\nvoid br_multicast_init(struct net_bridge *br)\n{\n\tbr->hash_elasticity = 4;\n\tbr->hash_max = 512;\n\n\tbr->multicast_router = 1;\n\tbr->multicast_querier = 0;\n\tbr->multicast_query_use_ifaddr = 0;\n\tbr->multicast_last_member_count = 2;\n\tbr->multicast_startup_query_count = 2;\n\n\tbr->multicast_last_member_interval = HZ;\n\tbr->multicast_query_response_interval = 10 * HZ;\n\tbr->multicast_startup_query_interval = 125 * HZ / 4;\n\tbr->multicast_query_interval = 125 * HZ;\n\tbr->multicast_querier_interval = 255 * HZ;\n\tbr->multicast_membership_interval = 260 * HZ;\n\n\tspin_lock_init(&br->multicast_lock);\n\tsetup_timer(&br->multicast_router_timer,\n\t\t    br_multicast_local_router_expired, 0);\n\tsetup_timer(&br->multicast_querier_timer,\n\t\t    br_multicast_querier_expired, (unsigned long)br);\n\tsetup_timer(&br->multicast_query_timer, br_multicast_query_expired,\n\t\t    (unsigned long)br);\n}\n\nvoid br_multicast_open(struct net_bridge *br)\n{\n\tbr->multicast_startup_queries_sent = 0;\n\n\tif (br->multicast_disabled)\n\t\treturn;\n\n\tmod_timer(&br->multicast_query_timer, jiffies);\n}\n\nvoid br_multicast_stop(struct net_bridge *br)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct hlist_node *n;\n\tu32 ver;\n\tint i;\n\n\tdel_timer_sync(&br->multicast_router_timer);\n\tdel_timer_sync(&br->multicast_querier_timer);\n\tdel_timer_sync(&br->multicast_query_timer);\n\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\tif (!mdb)\n\t\tgoto out;\n\n\tbr->mdb = NULL;\n\n\tver = mdb->ver;\n\tfor (i = 0; i < mdb->max; i++) {\n\t\thlist_for_each_entry_safe(mp, n, &mdb->mhash[i],\n\t\t\t\t\t  hlist[ver]) {\n\t\t\tdel_timer(&mp->timer);\n\t\t\tmp->timer_armed = false;\n\t\t\tcall_rcu_bh(&mp->rcu, br_multicast_free_group);\n\t\t}\n\t}\n\n\tif (mdb->old) {\n\t\tspin_unlock_bh(&br->multicast_lock);\n\t\trcu_barrier_bh();\n\t\tspin_lock_bh(&br->multicast_lock);\n\t\tWARN_ON(mdb->old);\n\t}\n\n\tmdb->old = mdb;\n\tcall_rcu_bh(&mdb->rcu, br_mdb_free);\n\nout:\n\tspin_unlock_bh(&br->multicast_lock);\n}\n\nint br_multicast_set_router(struct net_bridge *br, unsigned long val)\n{\n\tint err = -ENOENT;\n\n\tspin_lock_bh(&br->multicast_lock);\n\tif (!netif_running(br->dev))\n\t\tgoto unlock;\n\n\tswitch (val) {\n\tcase 0:\n\tcase 2:\n\t\tdel_timer(&br->multicast_router_timer);\n\t\t/* fall through */\n\tcase 1:\n\t\tbr->multicast_router = val;\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\n\treturn err;\n}\n\nint br_multicast_set_port_router(struct net_bridge_port *p, unsigned long val)\n{\n\tstruct net_bridge *br = p->br;\n\tint err = -ENOENT;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || p->state == BR_STATE_DISABLED)\n\t\tgoto unlock;\n\n\tswitch (val) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\tp->multicast_router = val;\n\t\terr = 0;\n\n\t\tif (val < 2 && !hlist_unhashed(&p->rlist))\n\t\t\thlist_del_init_rcu(&p->rlist);\n\n\t\tif (val == 1)\n\t\t\tbreak;\n\n\t\tdel_timer(&p->multicast_router_timer);\n\n\t\tif (val == 0)\n\t\t\tbreak;\n\n\t\tbr_multicast_add_router(br, p);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock:\n\tspin_unlock(&br->multicast_lock);\n\n\treturn err;\n}\n\nstatic void br_multicast_start_querier(struct net_bridge *br)\n{\n\tstruct net_bridge_port *port;\n\n\tbr_multicast_open(br);\n\n\tlist_for_each_entry(port, &br->port_list, list) {\n\t\tif (port->state == BR_STATE_DISABLED ||\n\t\t    port->state == BR_STATE_BLOCKING)\n\t\t\tcontinue;\n\n\t\t__br_multicast_enable_port(port);\n\t}\n}\n\nint br_multicast_toggle(struct net_bridge *br, unsigned long val)\n{\n\tint err = 0;\n\tstruct net_bridge_mdb_htable *mdb;\n\n\tspin_lock_bh(&br->multicast_lock);\n\tif (br->multicast_disabled == !val)\n\t\tgoto unlock;\n\n\tbr->multicast_disabled = !val;\n\tif (br->multicast_disabled)\n\t\tgoto unlock;\n\n\tif (!netif_running(br->dev))\n\t\tgoto unlock;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\tif (mdb) {\n\t\tif (mdb->old) {\n\t\t\terr = -EEXIST;\nrollback:\n\t\t\tbr->multicast_disabled = !!val;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = br_mdb_rehash(&br->mdb, mdb->max,\n\t\t\t\t    br->hash_elasticity);\n\t\tif (err)\n\t\t\tgoto rollback;\n\t}\n\n\tbr_multicast_start_querier(br);\n\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\n\treturn err;\n}\n\nint br_multicast_set_querier(struct net_bridge *br, unsigned long val)\n{\n\tval = !!val;\n\n\tspin_lock_bh(&br->multicast_lock);\n\tif (br->multicast_querier == val)\n\t\tgoto unlock;\n\n\tbr->multicast_querier = val;\n\tif (val)\n\t\tbr_multicast_start_querier(br);\n\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\n\treturn 0;\n}\n\nint br_multicast_set_hash_max(struct net_bridge *br, unsigned long val)\n{\n\tint err = -ENOENT;\n\tu32 old;\n\tstruct net_bridge_mdb_htable *mdb;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev))\n\t\tgoto unlock;\n\n\terr = -EINVAL;\n\tif (!is_power_of_2(val))\n\t\tgoto unlock;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\tif (mdb && val < mdb->size)\n\t\tgoto unlock;\n\n\terr = 0;\n\n\told = br->hash_max;\n\tbr->hash_max = val;\n\n\tif (mdb) {\n\t\tif (mdb->old) {\n\t\t\terr = -EEXIST;\nrollback:\n\t\t\tbr->hash_max = old;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = br_mdb_rehash(&br->mdb, br->hash_max,\n\t\t\t\t    br->hash_elasticity);\n\t\tif (err)\n\t\t\tgoto rollback;\n\t}\n\nunlock:\n\tspin_unlock(&br->multicast_lock);\n\n\treturn err;\n}\n"], "fixing_code": ["#include <linux/err.h>\n#include <linux/igmp.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/rculist.h>\n#include <linux/skbuff.h>\n#include <linux/if_ether.h>\n#include <net/ip.h>\n#include <net/netlink.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/ipv6.h>\n#endif\n\n#include \"br_private.h\"\n\nstatic int br_rports_fill_info(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t       struct net_device *dev)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct net_bridge_port *p;\n\tstruct nlattr *nest;\n\n\tif (!br->multicast_router || hlist_empty(&br->router_list))\n\t\treturn 0;\n\n\tnest = nla_nest_start(skb, MDBA_ROUTER);\n\tif (nest == NULL)\n\t\treturn -EMSGSIZE;\n\n\thlist_for_each_entry_rcu(p, &br->router_list, rlist) {\n\t\tif (p && nla_put_u32(skb, MDBA_ROUTER_PORT, p->dev->ifindex))\n\t\t\tgoto fail;\n\t}\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\nfail:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int br_mdb_fill_info(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t    struct net_device *dev)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct nlattr *nest, *nest2;\n\tint i, err = 0;\n\tint idx = 0, s_idx = cb->args[1];\n\n\tif (br->multicast_disabled)\n\t\treturn 0;\n\n\tmdb = rcu_dereference(br->mdb);\n\tif (!mdb)\n\t\treturn 0;\n\n\tnest = nla_nest_start(skb, MDBA_MDB);\n\tif (nest == NULL)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i < mdb->max; i++) {\n\t\tstruct net_bridge_mdb_entry *mp;\n\t\tstruct net_bridge_port_group *p, **pp;\n\t\tstruct net_bridge_port *port;\n\n\t\thlist_for_each_entry_rcu(mp, &mdb->mhash[i], hlist[mdb->ver]) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto skip;\n\n\t\t\tnest2 = nla_nest_start(skb, MDBA_MDB_ENTRY);\n\t\t\tif (nest2 == NULL) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfor (pp = &mp->ports;\n\t\t\t     (p = rcu_dereference(*pp)) != NULL;\n\t\t\t      pp = &p->next) {\n\t\t\t\tport = p->port;\n\t\t\t\tif (port) {\n\t\t\t\t\tstruct br_mdb_entry e;\n\t\t\t\t\tmemset(&e, 0, sizeof(e));\n\t\t\t\t\te.ifindex = port->dev->ifindex;\n\t\t\t\t\te.state = p->state;\n\t\t\t\t\tif (p->addr.proto == htons(ETH_P_IP))\n\t\t\t\t\t\te.addr.u.ip4 = p->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\t\t\tif (p->addr.proto == htons(ETH_P_IPV6))\n\t\t\t\t\t\te.addr.u.ip6 = p->addr.u.ip6;\n#endif\n\t\t\t\t\te.addr.proto = p->addr.proto;\n\t\t\t\t\tif (nla_put(skb, MDBA_MDB_ENTRY_INFO, sizeof(e), &e)) {\n\t\t\t\t\t\tnla_nest_cancel(skb, nest2);\n\t\t\t\t\t\terr = -EMSGSIZE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnla_nest_end(skb, nest2);\n\t\tskip:\n\t\t\tidx++;\n\t\t}\n\t}\n\nout:\n\tcb->args[1] = idx;\n\tnla_nest_end(skb, nest);\n\treturn err;\n}\n\nstatic int br_mdb_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net_device *dev;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlmsghdr *nlh = NULL;\n\tint idx = 0, s_idx;\n\n\ts_idx = cb->args[0];\n\n\trcu_read_lock();\n\n\t/* In theory this could be wrapped to 0... */\n\tcb->seq = net->dev_base_seq + br_mdb_rehash_seq;\n\n\tfor_each_netdev_rcu(net, dev) {\n\t\tif (dev->priv_flags & IFF_EBRIDGE) {\n\t\t\tstruct br_port_msg *bpm;\n\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto skip;\n\n\t\t\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\tcb->nlh->nlmsg_seq, RTM_GETMDB,\n\t\t\t\t\tsizeof(*bpm), NLM_F_MULTI);\n\t\t\tif (nlh == NULL)\n\t\t\t\tbreak;\n\n\t\t\tbpm = nlmsg_data(nlh);\n\t\t\tmemset(bpm, 0, sizeof(*bpm));\n\t\t\tbpm->ifindex = dev->ifindex;\n\t\t\tif (br_mdb_fill_info(skb, cb, dev) < 0)\n\t\t\t\tgoto out;\n\t\t\tif (br_rports_fill_info(skb, cb, dev) < 0)\n\t\t\t\tgoto out;\n\n\t\t\tcb->args[1] = 0;\n\t\t\tnlmsg_end(skb, nlh);\n\t\tskip:\n\t\t\tidx++;\n\t\t}\n\t}\n\nout:\n\tif (nlh)\n\t\tnlmsg_end(skb, nlh);\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\nstatic int nlmsg_populate_mdb_fill(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   struct br_mdb_entry *entry, u32 pid,\n\t\t\t\t   u32 seq, int type, unsigned int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct br_port_msg *bpm;\n\tstruct nlattr *nest, *nest2;\n\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*bpm), NLM_F_MULTI);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tbpm = nlmsg_data(nlh);\n\tmemset(bpm, 0, sizeof(*bpm));\n\tbpm->family  = AF_BRIDGE;\n\tbpm->ifindex = dev->ifindex;\n\tnest = nla_nest_start(skb, MDBA_MDB);\n\tif (nest == NULL)\n\t\tgoto cancel;\n\tnest2 = nla_nest_start(skb, MDBA_MDB_ENTRY);\n\tif (nest2 == NULL)\n\t\tgoto end;\n\n\tif (nla_put(skb, MDBA_MDB_ENTRY_INFO, sizeof(*entry), entry))\n\t\tgoto end;\n\n\tnla_nest_end(skb, nest2);\n\tnla_nest_end(skb, nest);\n\treturn nlmsg_end(skb, nlh);\n\nend:\n\tnla_nest_end(skb, nest);\ncancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic inline size_t rtnl_mdb_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct br_port_msg))\n\t\t+ nla_total_size(sizeof(struct br_mdb_entry));\n}\n\nstatic void __br_mdb_notify(struct net_device *dev, struct br_mdb_entry *entry,\n\t\t\t    int type)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(rtnl_mdb_nlmsg_size(), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = nlmsg_populate_mdb_fill(skb, dev, entry, 0, 0, type, NTF_SELF);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, 0, RTNLGRP_MDB, NULL, GFP_ATOMIC);\n\treturn;\nerrout:\n\trtnl_set_sk_err(net, RTNLGRP_MDB, err);\n}\n\nvoid br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,\n\t\t   struct br_ip *group, int type)\n{\n\tstruct br_mdb_entry entry;\n\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.ifindex = port->dev->ifindex;\n\tentry.addr.proto = group->proto;\n\tentry.addr.u.ip4 = group->u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tentry.addr.u.ip6 = group->u.ip6;\n#endif\n\t__br_mdb_notify(dev, &entry, type);\n}\n\nstatic bool is_valid_mdb_entry(struct br_mdb_entry *entry)\n{\n\tif (entry->ifindex == 0)\n\t\treturn false;\n\n\tif (entry->addr.proto == htons(ETH_P_IP)) {\n\t\tif (!ipv4_is_multicast(entry->addr.u.ip4))\n\t\t\treturn false;\n\t\tif (ipv4_is_local_multicast(entry->addr.u.ip4))\n\t\t\treturn false;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (entry->addr.proto == htons(ETH_P_IPV6)) {\n\t\tif (!ipv6_is_transient_multicast(&entry->addr.u.ip6))\n\t\t\treturn false;\n#endif\n\t} else\n\t\treturn false;\n\tif (entry->state != MDB_PERMANENT && entry->state != MDB_TEMPORARY)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int br_mdb_parse(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct net_device **pdev, struct br_mdb_entry **pentry)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct br_mdb_entry *entry;\n\tstruct br_port_msg *bpm;\n\tstruct nlattr *tb[MDBA_SET_ENTRY_MAX+1];\n\tstruct net_device *dev;\n\tint err;\n\n\terr = nlmsg_parse(nlh, sizeof(*bpm), tb, MDBA_SET_ENTRY, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tbpm = nlmsg_data(nlh);\n\tif (bpm->ifindex == 0) {\n\t\tpr_info(\"PF_BRIDGE: br_mdb_parse() with invalid ifindex\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = __dev_get_by_index(net, bpm->ifindex);\n\tif (dev == NULL) {\n\t\tpr_info(\"PF_BRIDGE: br_mdb_parse() with unknown ifindex\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!(dev->priv_flags & IFF_EBRIDGE)) {\n\t\tpr_info(\"PF_BRIDGE: br_mdb_parse() with non-bridge\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t*pdev = dev;\n\n\tif (!tb[MDBA_SET_ENTRY] ||\n\t    nla_len(tb[MDBA_SET_ENTRY]) != sizeof(struct br_mdb_entry)) {\n\t\tpr_info(\"PF_BRIDGE: br_mdb_parse() with invalid attr\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tentry = nla_data(tb[MDBA_SET_ENTRY]);\n\tif (!is_valid_mdb_entry(entry)) {\n\t\tpr_info(\"PF_BRIDGE: br_mdb_parse() with invalid entry\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*pentry = entry;\n\treturn 0;\n}\n\nstatic int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,\n\t\t\t    struct br_ip *group, unsigned char state)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct net_bridge_mdb_htable *mdb;\n\tint err;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, group);\n\tif (!mp) {\n\t\tmp = br_multicast_new_group(br, port, group);\n\t\terr = PTR_ERR(mp);\n\t\tif (IS_ERR(mp))\n\t\t\treturn err;\n\t}\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\treturn -EEXIST;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\n\tp = br_multicast_new_port_group(port, group, *pp, state);\n\tif (unlikely(!p))\n\t\treturn -ENOMEM;\n\trcu_assign_pointer(*pp, p);\n\n\tbr_mdb_notify(br->dev, port, group, RTM_NEWMDB);\n\treturn 0;\n}\n\nstatic int __br_mdb_add(struct net *net, struct net_bridge *br,\n\t\t\tstruct br_mdb_entry *entry)\n{\n\tstruct br_ip ip;\n\tstruct net_device *dev;\n\tstruct net_bridge_port *p;\n\tint ret;\n\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\n\tdev = __dev_get_by_index(net, entry->ifindex);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tp = br_port_get_rtnl(dev);\n\tif (!p || p->br != br || p->state == BR_STATE_DISABLED)\n\t\treturn -EINVAL;\n\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\n\tspin_lock_bh(&br->multicast_lock);\n\tret = br_mdb_add_group(br, p, &ip, entry->state);\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn ret;\n}\n\nstatic int br_mdb_add(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct br_mdb_entry *entry;\n\tstruct net_device *dev;\n\tstruct net_bridge *br;\n\tint err;\n\n\terr = br_mdb_parse(skb, nlh, &dev, &entry);\n\tif (err < 0)\n\t\treturn err;\n\n\tbr = netdev_priv(dev);\n\n\terr = __br_mdb_add(net, br, entry);\n\tif (!err)\n\t\t__br_mdb_notify(dev, entry, RTM_NEWMDB);\n\treturn err;\n}\n\nstatic int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip ip;\n\tint err = -EINVAL;\n\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\n\tif (timer_pending(&br->multicast_querier_timer))\n\t\treturn -EBUSY;\n\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\n\tmp = br_mdb_ip_get(mdb, &ip);\n\tif (!mp)\n\t\tgoto unlock;\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (!p->port || p->port->dev->ifindex != entry->ifindex)\n\t\t\tcontinue;\n\n\t\tif (p->port->state == BR_STATE_DISABLED)\n\t\t\tgoto unlock;\n\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\terr = 0;\n\n\t\tif (!mp->ports && !mp->mglist && mp->timer_armed &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\tbreak;\n\t}\n\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn err;\n}\n\nstatic int br_mdb_del(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net_device *dev;\n\tstruct br_mdb_entry *entry;\n\tstruct net_bridge *br;\n\tint err;\n\n\terr = br_mdb_parse(skb, nlh, &dev, &entry);\n\tif (err < 0)\n\t\treturn err;\n\n\tbr = netdev_priv(dev);\n\n\terr = __br_mdb_del(br, entry);\n\tif (!err)\n\t\t__br_mdb_notify(dev, entry, RTM_DELMDB);\n\treturn err;\n}\n\nvoid br_mdb_init(void)\n{\n\trtnl_register(PF_BRIDGE, RTM_GETMDB, NULL, br_mdb_dump, NULL);\n\trtnl_register(PF_BRIDGE, RTM_NEWMDB, br_mdb_add, NULL, NULL);\n\trtnl_register(PF_BRIDGE, RTM_DELMDB, br_mdb_del, NULL, NULL);\n}\n\nvoid br_mdb_uninit(void)\n{\n\trtnl_unregister(PF_BRIDGE, RTM_GETMDB);\n\trtnl_unregister(PF_BRIDGE, RTM_NEWMDB);\n\trtnl_unregister(PF_BRIDGE, RTM_DELMDB);\n}\n", "/*\n * Bridge multicast support.\n *\n * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include <linux/err.h>\n#include <linux/if_ether.h>\n#include <linux/igmp.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/netdevice.h>\n#include <linux/netfilter_bridge.h>\n#include <linux/random.h>\n#include <linux/rculist.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/inetdevice.h>\n#include <net/ip.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/ipv6.h>\n#include <net/mld.h>\n#include <net/ip6_checksum.h>\n#endif\n\n#include \"br_private.h\"\n\nstatic void br_multicast_start_querier(struct net_bridge *br);\nunsigned int br_mdb_rehash_seq;\n\nstatic inline int br_ip_equal(const struct br_ip *a, const struct br_ip *b)\n{\n\tif (a->proto != b->proto)\n\t\treturn 0;\n\tif (a->vid != b->vid)\n\t\treturn 0;\n\tswitch (a->proto) {\n\tcase htons(ETH_P_IP):\n\t\treturn a->u.ip4 == b->u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\treturn ipv6_addr_equal(&a->u.ip6, &b->u.ip6);\n#endif\n\t}\n\treturn 0;\n}\n\nstatic inline int __br_ip4_hash(struct net_bridge_mdb_htable *mdb, __be32 ip,\n\t\t\t\t__u16 vid)\n{\n\treturn jhash_2words((__force u32)ip, vid, mdb->secret) & (mdb->max - 1);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic inline int __br_ip6_hash(struct net_bridge_mdb_htable *mdb,\n\t\t\t\tconst struct in6_addr *ip,\n\t\t\t\t__u16 vid)\n{\n\treturn jhash_2words(ipv6_addr_hash(ip), vid,\n\t\t\t    mdb->secret) & (mdb->max - 1);\n}\n#endif\n\nstatic inline int br_ip_hash(struct net_bridge_mdb_htable *mdb,\n\t\t\t     struct br_ip *ip)\n{\n\tswitch (ip->proto) {\n\tcase htons(ETH_P_IP):\n\t\treturn __br_ip4_hash(mdb, ip->u.ip4, ip->vid);\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\treturn __br_ip6_hash(mdb, &ip->u.ip6, ip->vid);\n#endif\n\t}\n\treturn 0;\n}\n\nstatic struct net_bridge_mdb_entry *__br_mdb_ip_get(\n\tstruct net_bridge_mdb_htable *mdb, struct br_ip *dst, int hash)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\n\thlist_for_each_entry_rcu(mp, &mdb->mhash[hash], hlist[mdb->ver]) {\n\t\tif (br_ip_equal(&mp->addr, dst))\n\t\t\treturn mp;\n\t}\n\n\treturn NULL;\n}\n\nstruct net_bridge_mdb_entry *br_mdb_ip_get(struct net_bridge_mdb_htable *mdb,\n\t\t\t\t\t   struct br_ip *dst)\n{\n\tif (!mdb)\n\t\treturn NULL;\n\n\treturn __br_mdb_ip_get(mdb, dst, br_ip_hash(mdb, dst));\n}\n\nstatic struct net_bridge_mdb_entry *br_mdb_ip4_get(\n\tstruct net_bridge_mdb_htable *mdb, __be32 dst, __u16 vid)\n{\n\tstruct br_ip br_dst;\n\n\tbr_dst.u.ip4 = dst;\n\tbr_dst.proto = htons(ETH_P_IP);\n\tbr_dst.vid = vid;\n\n\treturn br_mdb_ip_get(mdb, &br_dst);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic struct net_bridge_mdb_entry *br_mdb_ip6_get(\n\tstruct net_bridge_mdb_htable *mdb, const struct in6_addr *dst,\n\t__u16 vid)\n{\n\tstruct br_ip br_dst;\n\n\tbr_dst.u.ip6 = *dst;\n\tbr_dst.proto = htons(ETH_P_IPV6);\n\tbr_dst.vid = vid;\n\n\treturn br_mdb_ip_get(mdb, &br_dst);\n}\n#endif\n\nstruct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,\n\t\t\t\t\tstruct sk_buff *skb, u16 vid)\n{\n\tstruct net_bridge_mdb_htable *mdb = rcu_dereference(br->mdb);\n\tstruct br_ip ip;\n\n\tif (br->multicast_disabled)\n\t\treturn NULL;\n\n\tif (BR_INPUT_SKB_CB(skb)->igmp)\n\t\treturn NULL;\n\n\tip.proto = skb->protocol;\n\tip.vid = vid;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tip.u.ip4 = ip_hdr(skb)->daddr;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\tip.u.ip6 = ipv6_hdr(skb)->daddr;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn br_mdb_ip_get(mdb, &ip);\n}\n\nstatic void br_mdb_free(struct rcu_head *head)\n{\n\tstruct net_bridge_mdb_htable *mdb =\n\t\tcontainer_of(head, struct net_bridge_mdb_htable, rcu);\n\tstruct net_bridge_mdb_htable *old = mdb->old;\n\n\tmdb->old = NULL;\n\tkfree(old->mhash);\n\tkfree(old);\n}\n\nstatic int br_mdb_copy(struct net_bridge_mdb_htable *new,\n\t\t       struct net_bridge_mdb_htable *old,\n\t\t       int elasticity)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tint maxlen;\n\tint len;\n\tint i;\n\n\tfor (i = 0; i < old->max; i++)\n\t\thlist_for_each_entry(mp, &old->mhash[i], hlist[old->ver])\n\t\t\thlist_add_head(&mp->hlist[new->ver],\n\t\t\t\t       &new->mhash[br_ip_hash(new, &mp->addr)]);\n\n\tif (!elasticity)\n\t\treturn 0;\n\n\tmaxlen = 0;\n\tfor (i = 0; i < new->max; i++) {\n\t\tlen = 0;\n\t\thlist_for_each_entry(mp, &new->mhash[i], hlist[new->ver])\n\t\t\tlen++;\n\t\tif (len > maxlen)\n\t\t\tmaxlen = len;\n\t}\n\n\treturn maxlen > elasticity ? -EINVAL : 0;\n}\n\nvoid br_multicast_free_pg(struct rcu_head *head)\n{\n\tstruct net_bridge_port_group *p =\n\t\tcontainer_of(head, struct net_bridge_port_group, rcu);\n\n\tkfree(p);\n}\n\nstatic void br_multicast_free_group(struct rcu_head *head)\n{\n\tstruct net_bridge_mdb_entry *mp =\n\t\tcontainer_of(head, struct net_bridge_mdb_entry, rcu);\n\n\tkfree(mp);\n}\n\nstatic void br_multicast_group_expired(unsigned long data)\n{\n\tstruct net_bridge_mdb_entry *mp = (void *)data;\n\tstruct net_bridge *br = mp->br;\n\tstruct net_bridge_mdb_htable *mdb;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || timer_pending(&mp->timer))\n\t\tgoto out;\n\n\tmp->mglist = false;\n\n\tif (mp->ports)\n\t\tgoto out;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\n\thlist_del_rcu(&mp->hlist[mdb->ver]);\n\tmdb->size--;\n\n\tcall_rcu_bh(&mp->rcu, br_multicast_free_group);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void br_multicast_del_pg(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\n\tmp = br_mdb_ip_get(mdb, &pg->addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\n\t\tif (!mp->ports && !mp->mglist && mp->timer_armed &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\n\t\treturn;\n\t}\n\n\tWARN_ON(1);\n}\n\nstatic void br_multicast_port_group_expired(unsigned long data)\n{\n\tstruct net_bridge_port_group *pg = (void *)data;\n\tstruct net_bridge *br = pg->port->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || timer_pending(&pg->timer) ||\n\t    hlist_unhashed(&pg->mglist) || pg->state & MDB_PERMANENT)\n\t\tgoto out;\n\n\tbr_multicast_del_pg(br, pg);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic int br_mdb_rehash(struct net_bridge_mdb_htable __rcu **mdbp, int max,\n\t\t\t int elasticity)\n{\n\tstruct net_bridge_mdb_htable *old = rcu_dereference_protected(*mdbp, 1);\n\tstruct net_bridge_mdb_htable *mdb;\n\tint err;\n\n\tmdb = kmalloc(sizeof(*mdb), GFP_ATOMIC);\n\tif (!mdb)\n\t\treturn -ENOMEM;\n\n\tmdb->max = max;\n\tmdb->old = old;\n\n\tmdb->mhash = kzalloc(max * sizeof(*mdb->mhash), GFP_ATOMIC);\n\tif (!mdb->mhash) {\n\t\tkfree(mdb);\n\t\treturn -ENOMEM;\n\t}\n\n\tmdb->size = old ? old->size : 0;\n\tmdb->ver = old ? old->ver ^ 1 : 0;\n\n\tif (!old || elasticity)\n\t\tget_random_bytes(&mdb->secret, sizeof(mdb->secret));\n\telse\n\t\tmdb->secret = old->secret;\n\n\tif (!old)\n\t\tgoto out;\n\n\terr = br_mdb_copy(mdb, old, elasticity);\n\tif (err) {\n\t\tkfree(mdb->mhash);\n\t\tkfree(mdb);\n\t\treturn err;\n\t}\n\n\tbr_mdb_rehash_seq++;\n\tcall_rcu_bh(&mdb->rcu, br_mdb_free);\n\nout:\n\trcu_assign_pointer(*mdbp, mdb);\n\n\treturn 0;\n}\n\nstatic struct sk_buff *br_ip4_multicast_alloc_query(struct net_bridge *br,\n\t\t\t\t\t\t    __be32 group)\n{\n\tstruct sk_buff *skb;\n\tstruct igmphdr *ih;\n\tstruct ethhdr *eth;\n\tstruct iphdr *iph;\n\n\tskb = netdev_alloc_skb_ip_align(br->dev, sizeof(*eth) + sizeof(*iph) +\n\t\t\t\t\t\t sizeof(*ih) + 4);\n\tif (!skb)\n\t\tgoto out;\n\n\tskb->protocol = htons(ETH_P_IP);\n\n\tskb_reset_mac_header(skb);\n\teth = eth_hdr(skb);\n\n\tmemcpy(eth->h_source, br->dev->dev_addr, 6);\n\teth->h_dest[0] = 1;\n\teth->h_dest[1] = 0;\n\teth->h_dest[2] = 0x5e;\n\teth->h_dest[3] = 0;\n\teth->h_dest[4] = 0;\n\teth->h_dest[5] = 1;\n\teth->h_proto = htons(ETH_P_IP);\n\tskb_put(skb, sizeof(*eth));\n\n\tskb_set_network_header(skb, skb->len);\n\tiph = ip_hdr(skb);\n\n\tiph->version = 4;\n\tiph->ihl = 6;\n\tiph->tos = 0xc0;\n\tiph->tot_len = htons(sizeof(*iph) + sizeof(*ih) + 4);\n\tiph->id = 0;\n\tiph->frag_off = htons(IP_DF);\n\tiph->ttl = 1;\n\tiph->protocol = IPPROTO_IGMP;\n\tiph->saddr = br->multicast_query_use_ifaddr ?\n\t\t     inet_select_addr(br->dev, 0, RT_SCOPE_LINK) : 0;\n\tiph->daddr = htonl(INADDR_ALLHOSTS_GROUP);\n\t((u8 *)&iph[1])[0] = IPOPT_RA;\n\t((u8 *)&iph[1])[1] = 4;\n\t((u8 *)&iph[1])[2] = 0;\n\t((u8 *)&iph[1])[3] = 0;\n\tip_send_check(iph);\n\tskb_put(skb, 24);\n\n\tskb_set_transport_header(skb, skb->len);\n\tih = igmp_hdr(skb);\n\tih->type = IGMP_HOST_MEMBERSHIP_QUERY;\n\tih->code = (group ? br->multicast_last_member_interval :\n\t\t\t    br->multicast_query_response_interval) /\n\t\t   (HZ / IGMP_TIMER_SCALE);\n\tih->group = group;\n\tih->csum = 0;\n\tih->csum = ip_compute_csum((void *)ih, sizeof(struct igmphdr));\n\tskb_put(skb, sizeof(*ih));\n\n\t__skb_pull(skb, sizeof(*eth));\n\nout:\n\treturn skb;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic struct sk_buff *br_ip6_multicast_alloc_query(struct net_bridge *br,\n\t\t\t\t\t\t    const struct in6_addr *group)\n{\n\tstruct sk_buff *skb;\n\tstruct ipv6hdr *ip6h;\n\tstruct mld_msg *mldq;\n\tstruct ethhdr *eth;\n\tu8 *hopopt;\n\tunsigned long interval;\n\n\tskb = netdev_alloc_skb_ip_align(br->dev, sizeof(*eth) + sizeof(*ip6h) +\n\t\t\t\t\t\t 8 + sizeof(*mldq));\n\tif (!skb)\n\t\tgoto out;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\n\t/* Ethernet header */\n\tskb_reset_mac_header(skb);\n\teth = eth_hdr(skb);\n\n\tmemcpy(eth->h_source, br->dev->dev_addr, 6);\n\teth->h_proto = htons(ETH_P_IPV6);\n\tskb_put(skb, sizeof(*eth));\n\n\t/* IPv6 header + HbH option */\n\tskb_set_network_header(skb, skb->len);\n\tip6h = ipv6_hdr(skb);\n\n\t*(__force __be32 *)ip6h = htonl(0x60000000);\n\tip6h->payload_len = htons(8 + sizeof(*mldq));\n\tip6h->nexthdr = IPPROTO_HOPOPTS;\n\tip6h->hop_limit = 1;\n\tipv6_addr_set(&ip6h->daddr, htonl(0xff020000), 0, 0, htonl(1));\n\tif (ipv6_dev_get_saddr(dev_net(br->dev), br->dev, &ip6h->daddr, 0,\n\t\t\t       &ip6h->saddr)) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\tipv6_eth_mc_map(&ip6h->daddr, eth->h_dest);\n\n\thopopt = (u8 *)(ip6h + 1);\n\thopopt[0] = IPPROTO_ICMPV6;\t\t/* next hdr */\n\thopopt[1] = 0;\t\t\t\t/* length of HbH */\n\thopopt[2] = IPV6_TLV_ROUTERALERT;\t/* Router Alert */\n\thopopt[3] = 2;\t\t\t\t/* Length of RA Option */\n\thopopt[4] = 0;\t\t\t\t/* Type = 0x0000 (MLD) */\n\thopopt[5] = 0;\n\thopopt[6] = IPV6_TLV_PAD1;\t\t/* Pad1 */\n\thopopt[7] = IPV6_TLV_PAD1;\t\t/* Pad1 */\n\n\tskb_put(skb, sizeof(*ip6h) + 8);\n\n\t/* ICMPv6 */\n\tskb_set_transport_header(skb, skb->len);\n\tmldq = (struct mld_msg *) icmp6_hdr(skb);\n\n\tinterval = ipv6_addr_any(group) ?\n\t\t\tbr->multicast_query_response_interval :\n\t\t\tbr->multicast_last_member_interval;\n\n\tmldq->mld_type = ICMPV6_MGM_QUERY;\n\tmldq->mld_code = 0;\n\tmldq->mld_cksum = 0;\n\tmldq->mld_maxdelay = htons((u16)jiffies_to_msecs(interval));\n\tmldq->mld_reserved = 0;\n\tmldq->mld_mca = *group;\n\n\t/* checksum */\n\tmldq->mld_cksum = csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr,\n\t\t\t\t\t  sizeof(*mldq), IPPROTO_ICMPV6,\n\t\t\t\t\t  csum_partial(mldq,\n\t\t\t\t\t\t       sizeof(*mldq), 0));\n\tskb_put(skb, sizeof(*mldq));\n\n\t__skb_pull(skb, sizeof(*eth));\n\nout:\n\treturn skb;\n}\n#endif\n\nstatic struct sk_buff *br_multicast_alloc_query(struct net_bridge *br,\n\t\t\t\t\t\tstruct br_ip *addr)\n{\n\tswitch (addr->proto) {\n\tcase htons(ETH_P_IP):\n\t\treturn br_ip4_multicast_alloc_query(br, addr->u.ip4);\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\treturn br_ip6_multicast_alloc_query(br, &addr->u.ip6);\n#endif\n\t}\n\treturn NULL;\n}\n\nstatic struct net_bridge_mdb_entry *br_multicast_get_group(\n\tstruct net_bridge *br, struct net_bridge_port *port,\n\tstruct br_ip *group, int hash)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tunsigned int count = 0;\n\tunsigned int max;\n\tint elasticity;\n\tint err;\n\n\tmdb = rcu_dereference_protected(br->mdb, 1);\n\thlist_for_each_entry(mp, &mdb->mhash[hash], hlist[mdb->ver]) {\n\t\tcount++;\n\t\tif (unlikely(br_ip_equal(group, &mp->addr)))\n\t\t\treturn mp;\n\t}\n\n\telasticity = 0;\n\tmax = mdb->max;\n\n\tif (unlikely(count > br->hash_elasticity && count)) {\n\t\tif (net_ratelimit())\n\t\t\tbr_info(br, \"Multicast hash table \"\n\t\t\t\t\"chain limit reached: %s\\n\",\n\t\t\t\tport ? port->dev->name : br->dev->name);\n\n\t\telasticity = br->hash_elasticity;\n\t}\n\n\tif (mdb->size >= max) {\n\t\tmax *= 2;\n\t\tif (unlikely(max > br->hash_max)) {\n\t\t\tbr_warn(br, \"Multicast hash table maximum of %d \"\n\t\t\t\t\"reached, disabling snooping: %s\\n\",\n\t\t\t\tbr->hash_max,\n\t\t\t\tport ? port->dev->name : br->dev->name);\n\t\t\terr = -E2BIG;\ndisable:\n\t\t\tbr->multicast_disabled = 1;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (max > mdb->max || elasticity) {\n\t\tif (mdb->old) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tbr_info(br, \"Multicast hash table \"\n\t\t\t\t\t\"on fire: %s\\n\",\n\t\t\t\t\tport ? port->dev->name : br->dev->name);\n\t\t\terr = -EEXIST;\n\t\t\tgoto err;\n\t\t}\n\n\t\terr = br_mdb_rehash(&br->mdb, max, elasticity);\n\t\tif (err) {\n\t\t\tbr_warn(br, \"Cannot rehash multicast \"\n\t\t\t\t\"hash table, disabling snooping: %s, %d, %d\\n\",\n\t\t\t\tport ? port->dev->name : br->dev->name,\n\t\t\t\tmdb->size, err);\n\t\t\tgoto disable;\n\t\t}\n\n\t\terr = -EAGAIN;\n\t\tgoto err;\n\t}\n\n\treturn NULL;\n\nerr:\n\tmp = ERR_PTR(err);\n\treturn mp;\n}\n\nstruct net_bridge_mdb_entry *br_multicast_new_group(struct net_bridge *br,\n\tstruct net_bridge_port *port, struct br_ip *group)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tint hash;\n\tint err;\n\n\tmdb = rcu_dereference_protected(br->mdb, 1);\n\tif (!mdb) {\n\t\terr = br_mdb_rehash(&br->mdb, BR_HASH_SIZE, 0);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tgoto rehash;\n\t}\n\n\thash = br_ip_hash(mdb, group);\n\tmp = br_multicast_get_group(br, port, group, hash);\n\tswitch (PTR_ERR(mp)) {\n\tcase 0:\n\t\tbreak;\n\n\tcase -EAGAIN:\nrehash:\n\t\tmdb = rcu_dereference_protected(br->mdb, 1);\n\t\thash = br_ip_hash(mdb, group);\n\t\tbreak;\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tmp = kzalloc(sizeof(*mp), GFP_ATOMIC);\n\tif (unlikely(!mp))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmp->br = br;\n\tmp->addr = *group;\n\n\thlist_add_head_rcu(&mp->hlist[mdb->ver], &mdb->mhash[hash]);\n\tmdb->size++;\n\nout:\n\treturn mp;\n}\n\nstruct net_bridge_port_group *br_multicast_new_port_group(\n\t\t\tstruct net_bridge_port *port,\n\t\t\tstruct br_ip *group,\n\t\t\tstruct net_bridge_port_group __rcu *next,\n\t\t\tunsigned char state)\n{\n\tstruct net_bridge_port_group *p;\n\n\tp = kzalloc(sizeof(*p), GFP_ATOMIC);\n\tif (unlikely(!p))\n\t\treturn NULL;\n\n\tp->addr = *group;\n\tp->port = port;\n\tp->state = state;\n\trcu_assign_pointer(p->next, next);\n\thlist_add_head(&p->mglist, &port->mglist);\n\tsetup_timer(&p->timer, br_multicast_port_group_expired,\n\t\t    (unsigned long)p);\n\treturn p;\n}\n\nstatic int br_multicast_add_group(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct br_ip *group)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tint err;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\n\tmp = br_multicast_new_group(br, port, group);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto err;\n\n\tif (!port) {\n\t\tmp->mglist = true;\n\t\tgoto out;\n\t}\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\tgoto out;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\n\tp = br_multicast_new_port_group(port, group, *pp, MDB_TEMPORARY);\n\tif (unlikely(!p))\n\t\tgoto err;\n\trcu_assign_pointer(*pp, p);\n\tbr_mdb_notify(br->dev, port, group, RTM_NEWMDB);\n\nout:\n\terr = 0;\n\nerr:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}\n\nstatic int br_ip4_multicast_add_group(struct net_bridge *br,\n\t\t\t\t      struct net_bridge_port *port,\n\t\t\t\t      __be32 group,\n\t\t\t\t      __u16 vid)\n{\n\tstruct br_ip br_group;\n\n\tif (ipv4_is_local_multicast(group))\n\t\treturn 0;\n\n\tbr_group.u.ip4 = group;\n\tbr_group.proto = htons(ETH_P_IP);\n\tbr_group.vid = vid;\n\n\treturn br_multicast_add_group(br, port, &br_group);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int br_ip6_multicast_add_group(struct net_bridge *br,\n\t\t\t\t      struct net_bridge_port *port,\n\t\t\t\t      const struct in6_addr *group,\n\t\t\t\t      __u16 vid)\n{\n\tstruct br_ip br_group;\n\n\tif (!ipv6_is_transient_multicast(group))\n\t\treturn 0;\n\n\tbr_group.u.ip6 = *group;\n\tbr_group.proto = htons(ETH_P_IPV6);\n\tbr_group.vid = vid;\n\n\treturn br_multicast_add_group(br, port, &br_group);\n}\n#endif\n\nstatic void br_multicast_router_expired(unsigned long data)\n{\n\tstruct net_bridge_port *port = (void *)data;\n\tstruct net_bridge *br = port->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (port->multicast_router != 1 ||\n\t    timer_pending(&port->multicast_router_timer) ||\n\t    hlist_unhashed(&port->rlist))\n\t\tgoto out;\n\n\thlist_del_init_rcu(&port->rlist);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void br_multicast_local_router_expired(unsigned long data)\n{\n}\n\nstatic void br_multicast_querier_expired(unsigned long data)\n{\n\tstruct net_bridge *br = (void *)data;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\tgoto out;\n\n\tbr_multicast_start_querier(br);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void __br_multicast_send_query(struct net_bridge *br,\n\t\t\t\t      struct net_bridge_port *port,\n\t\t\t\t      struct br_ip *ip)\n{\n\tstruct sk_buff *skb;\n\n\tskb = br_multicast_alloc_query(br, ip);\n\tif (!skb)\n\t\treturn;\n\n\tif (port) {\n\t\t__skb_push(skb, sizeof(struct ethhdr));\n\t\tskb->dev = port->dev;\n\t\tNF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, skb, NULL, skb->dev,\n\t\t\tdev_queue_xmit);\n\t} else\n\t\tnetif_rx(skb);\n}\n\nstatic void br_multicast_send_query(struct net_bridge *br,\n\t\t\t\t    struct net_bridge_port *port, u32 sent)\n{\n\tunsigned long time;\n\tstruct br_ip br_group;\n\n\tif (!netif_running(br->dev) || br->multicast_disabled ||\n\t    !br->multicast_querier ||\n\t    timer_pending(&br->multicast_querier_timer))\n\t\treturn;\n\n\tmemset(&br_group.u, 0, sizeof(br_group.u));\n\n\tbr_group.proto = htons(ETH_P_IP);\n\t__br_multicast_send_query(br, port, &br_group);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tbr_group.proto = htons(ETH_P_IPV6);\n\t__br_multicast_send_query(br, port, &br_group);\n#endif\n\n\ttime = jiffies;\n\ttime += sent < br->multicast_startup_query_count ?\n\t\tbr->multicast_startup_query_interval :\n\t\tbr->multicast_query_interval;\n\tmod_timer(port ? &port->multicast_query_timer :\n\t\t\t &br->multicast_query_timer, time);\n}\n\nstatic void br_multicast_port_query_expired(unsigned long data)\n{\n\tstruct net_bridge_port *port = (void *)data;\n\tstruct net_bridge *br = port->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (port->state == BR_STATE_DISABLED ||\n\t    port->state == BR_STATE_BLOCKING)\n\t\tgoto out;\n\n\tif (port->multicast_startup_queries_sent <\n\t    br->multicast_startup_query_count)\n\t\tport->multicast_startup_queries_sent++;\n\n\tbr_multicast_send_query(port->br, port,\n\t\t\t\tport->multicast_startup_queries_sent);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nvoid br_multicast_add_port(struct net_bridge_port *port)\n{\n\tport->multicast_router = 1;\n\n\tsetup_timer(&port->multicast_router_timer, br_multicast_router_expired,\n\t\t    (unsigned long)port);\n\tsetup_timer(&port->multicast_query_timer,\n\t\t    br_multicast_port_query_expired, (unsigned long)port);\n}\n\nvoid br_multicast_del_port(struct net_bridge_port *port)\n{\n\tdel_timer_sync(&port->multicast_router_timer);\n}\n\nstatic void __br_multicast_enable_port(struct net_bridge_port *port)\n{\n\tport->multicast_startup_queries_sent = 0;\n\n\tif (try_to_del_timer_sync(&port->multicast_query_timer) >= 0 ||\n\t    del_timer(&port->multicast_query_timer))\n\t\tmod_timer(&port->multicast_query_timer, jiffies);\n}\n\nvoid br_multicast_enable_port(struct net_bridge_port *port)\n{\n\tstruct net_bridge *br = port->br;\n\n\tspin_lock(&br->multicast_lock);\n\tif (br->multicast_disabled || !netif_running(br->dev))\n\t\tgoto out;\n\n\t__br_multicast_enable_port(port);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nvoid br_multicast_disable_port(struct net_bridge_port *port)\n{\n\tstruct net_bridge *br = port->br;\n\tstruct net_bridge_port_group *pg;\n\tstruct hlist_node *n;\n\n\tspin_lock(&br->multicast_lock);\n\thlist_for_each_entry_safe(pg, n, &port->mglist, mglist)\n\t\tbr_multicast_del_pg(br, pg);\n\n\tif (!hlist_unhashed(&port->rlist))\n\t\thlist_del_init_rcu(&port->rlist);\n\tdel_timer(&port->multicast_router_timer);\n\tdel_timer(&port->multicast_query_timer);\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic int br_ip4_multicast_igmp3_report(struct net_bridge *br,\n\t\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct igmpv3_report *ih;\n\tstruct igmpv3_grec *grec;\n\tint i;\n\tint len;\n\tint num;\n\tint type;\n\tint err = 0;\n\t__be32 group;\n\tu16 vid = 0;\n\n\tif (!pskb_may_pull(skb, sizeof(*ih)))\n\t\treturn -EINVAL;\n\n\tbr_vlan_get_tag(skb, &vid);\n\tih = igmpv3_report_hdr(skb);\n\tnum = ntohs(ih->ngrec);\n\tlen = sizeof(*ih);\n\n\tfor (i = 0; i < num; i++) {\n\t\tlen += sizeof(*grec);\n\t\tif (!pskb_may_pull(skb, len))\n\t\t\treturn -EINVAL;\n\n\t\tgrec = (void *)(skb->data + len - sizeof(*grec));\n\t\tgroup = grec->grec_mca;\n\t\ttype = grec->grec_type;\n\n\t\tlen += ntohs(grec->grec_nsrcs) * 4;\n\t\tif (!pskb_may_pull(skb, len))\n\t\t\treturn -EINVAL;\n\n\t\t/* We treat this as an IGMPv2 report for now. */\n\t\tswitch (type) {\n\t\tcase IGMPV3_MODE_IS_INCLUDE:\n\t\tcase IGMPV3_MODE_IS_EXCLUDE:\n\t\tcase IGMPV3_CHANGE_TO_INCLUDE:\n\t\tcase IGMPV3_CHANGE_TO_EXCLUDE:\n\t\tcase IGMPV3_ALLOW_NEW_SOURCES:\n\t\tcase IGMPV3_BLOCK_OLD_SOURCES:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = br_ip4_multicast_add_group(br, port, group, vid);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int br_ip6_multicast_mld2_report(struct net_bridge *br,\n\t\t\t\t\tstruct net_bridge_port *port,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct icmp6hdr *icmp6h;\n\tstruct mld2_grec *grec;\n\tint i;\n\tint len;\n\tint num;\n\tint err = 0;\n\tu16 vid = 0;\n\n\tif (!pskb_may_pull(skb, sizeof(*icmp6h)))\n\t\treturn -EINVAL;\n\n\tbr_vlan_get_tag(skb, &vid);\n\ticmp6h = icmp6_hdr(skb);\n\tnum = ntohs(icmp6h->icmp6_dataun.un_data16[1]);\n\tlen = sizeof(*icmp6h);\n\n\tfor (i = 0; i < num; i++) {\n\t\t__be16 *nsrcs, _nsrcs;\n\n\t\tnsrcs = skb_header_pointer(skb,\n\t\t\t\t\t   len + offsetof(struct mld2_grec,\n\t\t\t\t\t\t\t  grec_nsrcs),\n\t\t\t\t\t   sizeof(_nsrcs), &_nsrcs);\n\t\tif (!nsrcs)\n\t\t\treturn -EINVAL;\n\n\t\tif (!pskb_may_pull(skb,\n\t\t\t\t   len + sizeof(*grec) +\n\t\t\t\t   sizeof(struct in6_addr) * ntohs(*nsrcs)))\n\t\t\treturn -EINVAL;\n\n\t\tgrec = (struct mld2_grec *)(skb->data + len);\n\t\tlen += sizeof(*grec) +\n\t\t       sizeof(struct in6_addr) * ntohs(*nsrcs);\n\n\t\t/* We treat these as MLDv1 reports for now. */\n\t\tswitch (grec->grec_type) {\n\t\tcase MLD2_MODE_IS_INCLUDE:\n\t\tcase MLD2_MODE_IS_EXCLUDE:\n\t\tcase MLD2_CHANGE_TO_INCLUDE:\n\t\tcase MLD2_CHANGE_TO_EXCLUDE:\n\t\tcase MLD2_ALLOW_NEW_SOURCES:\n\t\tcase MLD2_BLOCK_OLD_SOURCES:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = br_ip6_multicast_add_group(br, port, &grec->grec_mca,\n\t\t\t\t\t\t vid);\n\t\tif (!err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n#endif\n\n/*\n * Add port to router_list\n *  list is maintained ordered by pointer value\n *  and locked by br->multicast_lock and RCU\n */\nstatic void br_multicast_add_router(struct net_bridge *br,\n\t\t\t\t    struct net_bridge_port *port)\n{\n\tstruct net_bridge_port *p;\n\tstruct hlist_node *slot = NULL;\n\n\thlist_for_each_entry(p, &br->router_list, rlist) {\n\t\tif ((unsigned long) port >= (unsigned long) p)\n\t\t\tbreak;\n\t\tslot = &p->rlist;\n\t}\n\n\tif (slot)\n\t\thlist_add_after_rcu(slot, &port->rlist);\n\telse\n\t\thlist_add_head_rcu(&port->rlist, &br->router_list);\n}\n\nstatic void br_multicast_mark_router(struct net_bridge *br,\n\t\t\t\t     struct net_bridge_port *port)\n{\n\tunsigned long now = jiffies;\n\n\tif (!port) {\n\t\tif (br->multicast_router == 1)\n\t\t\tmod_timer(&br->multicast_router_timer,\n\t\t\t\t  now + br->multicast_querier_interval);\n\t\treturn;\n\t}\n\n\tif (port->multicast_router != 1)\n\t\treturn;\n\n\tif (!hlist_unhashed(&port->rlist))\n\t\tgoto timer;\n\n\tbr_multicast_add_router(br, port);\n\ntimer:\n\tmod_timer(&port->multicast_router_timer,\n\t\t  now + br->multicast_querier_interval);\n}\n\nstatic void br_multicast_query_received(struct net_bridge *br,\n\t\t\t\t\tstruct net_bridge_port *port,\n\t\t\t\t\tint saddr)\n{\n\tif (saddr)\n\t\tmod_timer(&br->multicast_querier_timer,\n\t\t\t  jiffies + br->multicast_querier_interval);\n\telse if (timer_pending(&br->multicast_querier_timer))\n\t\treturn;\n\n\tbr_multicast_mark_router(br, port);\n}\n\nstatic int br_ip4_multicast_query(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tstruct igmphdr *ih = igmp_hdr(skb);\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct igmpv3_query *ih3;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long max_delay;\n\tunsigned long now = jiffies;\n\t__be32 group;\n\tint err = 0;\n\tu16 vid = 0;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\n\tbr_multicast_query_received(br, port, !!iph->saddr);\n\n\tgroup = ih->group;\n\n\tif (skb->len == sizeof(*ih)) {\n\t\tmax_delay = ih->code * (HZ / IGMP_TIMER_SCALE);\n\n\t\tif (!max_delay) {\n\t\t\tmax_delay = 10 * HZ;\n\t\t\tgroup = 0;\n\t\t}\n\t} else {\n\t\tif (!pskb_may_pull(skb, sizeof(struct igmpv3_query))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tih3 = igmpv3_query_hdr(skb);\n\t\tif (ih3->nsrcs)\n\t\t\tgoto out;\n\n\t\tmax_delay = ih3->code ?\n\t\t\t    IGMPV3_MRC(ih3->code) * (HZ / IGMP_TIMER_SCALE) : 1;\n\t}\n\n\tif (!group)\n\t\tgoto out;\n\n\tbr_vlan_get_tag(skb, &vid);\n\tmp = br_mdb_ip4_get(mlock_dereference(br->mdb, br), group, vid);\n\tif (!mp)\n\t\tgoto out;\n\n\tsetup_timer(&mp->timer, br_multicast_group_expired, (unsigned long)mp);\n\tmod_timer(&mp->timer, now + br->multicast_membership_interval);\n\tmp->timer_armed = true;\n\n\tmax_delay *= br->multicast_last_member_count;\n\n\tif (mp->mglist &&\n\t    (timer_pending(&mp->timer) ?\n\t     time_after(mp->timer.expires, now + max_delay) :\n\t     try_to_del_timer_sync(&mp->timer) >= 0))\n\t\tmod_timer(&mp->timer, now + max_delay);\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (timer_pending(&p->timer) ?\n\t\t    time_after(p->timer.expires, now + max_delay) :\n\t\t    try_to_del_timer_sync(&p->timer) >= 0)\n\t\t\tmod_timer(&p->timer, now + max_delay);\n\t}\n\nout:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int br_ip6_multicast_query(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\tstruct mld_msg *mld;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct mld2_query *mld2q;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long max_delay;\n\tunsigned long now = jiffies;\n\tconst struct in6_addr *group = NULL;\n\tint err = 0;\n\tu16 vid = 0;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\n\tbr_multicast_query_received(br, port, !ipv6_addr_any(&ip6h->saddr));\n\n\tif (skb->len == sizeof(*mld)) {\n\t\tif (!pskb_may_pull(skb, sizeof(*mld))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmld = (struct mld_msg *) icmp6_hdr(skb);\n\t\tmax_delay = msecs_to_jiffies(ntohs(mld->mld_maxdelay));\n\t\tif (max_delay)\n\t\t\tgroup = &mld->mld_mca;\n\t} else if (skb->len >= sizeof(*mld2q)) {\n\t\tif (!pskb_may_pull(skb, sizeof(*mld2q))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmld2q = (struct mld2_query *)icmp6_hdr(skb);\n\t\tif (!mld2q->mld2q_nsrcs)\n\t\t\tgroup = &mld2q->mld2q_mca;\n\t\tmax_delay = mld2q->mld2q_mrc ? MLDV2_MRC(ntohs(mld2q->mld2q_mrc)) : 1;\n\t}\n\n\tif (!group)\n\t\tgoto out;\n\n\tbr_vlan_get_tag(skb, &vid);\n\tmp = br_mdb_ip6_get(mlock_dereference(br->mdb, br), group, vid);\n\tif (!mp)\n\t\tgoto out;\n\n\tsetup_timer(&mp->timer, br_multicast_group_expired, (unsigned long)mp);\n\tmod_timer(&mp->timer, now + br->multicast_membership_interval);\n\tmp->timer_armed = true;\n\n\tmax_delay *= br->multicast_last_member_count;\n\tif (mp->mglist &&\n\t    (timer_pending(&mp->timer) ?\n\t     time_after(mp->timer.expires, now + max_delay) :\n\t     try_to_del_timer_sync(&mp->timer) >= 0))\n\t\tmod_timer(&mp->timer, now + max_delay);\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (timer_pending(&p->timer) ?\n\t\t    time_after(p->timer.expires, now + max_delay) :\n\t\t    try_to_del_timer_sync(&p->timer) >= 0)\n\t\t\tmod_timer(&p->timer, now + max_delay);\n\t}\n\nout:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}\n#endif\n\nstatic void br_multicast_leave_group(struct net_bridge *br,\n\t\t\t\t     struct net_bridge_port *port,\n\t\t\t\t     struct br_ip *group)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tunsigned long now;\n\tunsigned long time;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED) ||\n\t    timer_pending(&br->multicast_querier_timer))\n\t\tgoto out;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, group);\n\tif (!mp)\n\t\tgoto out;\n\n\tif (br->multicast_querier &&\n\t    !timer_pending(&br->multicast_querier_timer)) {\n\t\t__br_multicast_send_query(br, port, &mp->addr);\n\n\t\ttime = jiffies + br->multicast_last_member_count *\n\t\t\t\t br->multicast_last_member_interval;\n\t\tmod_timer(port ? &port->multicast_query_timer :\n\t\t\t\t &br->multicast_query_timer, time);\n\n\t\tfor (p = mlock_dereference(mp->ports, br);\n\t\t     p != NULL;\n\t\t     p = mlock_dereference(p->next, br)) {\n\t\t\tif (p->port != port)\n\t\t\t\tcontinue;\n\n\t\t\tif (!hlist_unhashed(&p->mglist) &&\n\t\t\t    (timer_pending(&p->timer) ?\n\t\t\t     time_after(p->timer.expires, time) :\n\t\t\t     try_to_del_timer_sync(&p->timer) >= 0)) {\n\t\t\t\tmod_timer(&p->timer, time);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (port && (port->flags & BR_MULTICAST_FAST_LEAVE)) {\n\t\tstruct net_bridge_port_group __rcu **pp;\n\n\t\tfor (pp = &mp->ports;\n\t\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t\t     pp = &p->next) {\n\t\t\tif (p->port != port)\n\t\t\t\tcontinue;\n\n\t\t\trcu_assign_pointer(*pp, p->next);\n\t\t\thlist_del_init(&p->mglist);\n\t\t\tdel_timer(&p->timer);\n\t\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\t\tbr_mdb_notify(br->dev, port, group, RTM_DELMDB);\n\n\t\t\tif (!mp->ports && !mp->mglist && mp->timer_armed &&\n\t\t\t    netif_running(br->dev))\n\t\t\t\tmod_timer(&mp->timer, jiffies);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tnow = jiffies;\n\ttime = now + br->multicast_last_member_count *\n\t\t     br->multicast_last_member_interval;\n\n\tif (!port) {\n\t\tif (mp->mglist && mp->timer_armed &&\n\t\t    (timer_pending(&mp->timer) ?\n\t\t     time_after(mp->timer.expires, time) :\n\t\t     try_to_del_timer_sync(&mp->timer) >= 0)) {\n\t\t\tmod_timer(&mp->timer, time);\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n\nstatic void br_ip4_multicast_leave_group(struct net_bridge *br,\n\t\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t\t __be32 group,\n\t\t\t\t\t __u16 vid)\n{\n\tstruct br_ip br_group;\n\n\tif (ipv4_is_local_multicast(group))\n\t\treturn;\n\n\tbr_group.u.ip4 = group;\n\tbr_group.proto = htons(ETH_P_IP);\n\tbr_group.vid = vid;\n\n\tbr_multicast_leave_group(br, port, &br_group);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void br_ip6_multicast_leave_group(struct net_bridge *br,\n\t\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t\t const struct in6_addr *group,\n\t\t\t\t\t __u16 vid)\n{\n\tstruct br_ip br_group;\n\n\tif (!ipv6_is_transient_multicast(group))\n\t\treturn;\n\n\tbr_group.u.ip6 = *group;\n\tbr_group.proto = htons(ETH_P_IPV6);\n\tbr_group.vid = vid;\n\n\tbr_multicast_leave_group(br, port, &br_group);\n}\n#endif\n\nstatic int br_multicast_ipv4_rcv(struct net_bridge *br,\n\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct sk_buff *skb2 = skb;\n\tconst struct iphdr *iph;\n\tstruct igmphdr *ih;\n\tunsigned int len;\n\tunsigned int offset;\n\tint err;\n\tu16 vid = 0;\n\n\t/* We treat OOM as packet loss for now. */\n\tif (!pskb_may_pull(skb, sizeof(*iph)))\n\t\treturn -EINVAL;\n\n\tiph = ip_hdr(skb);\n\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\treturn -EINVAL;\n\n\tif (!pskb_may_pull(skb, ip_hdrlen(skb)))\n\t\treturn -EINVAL;\n\n\tiph = ip_hdr(skb);\n\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\treturn -EINVAL;\n\n\tif (iph->protocol != IPPROTO_IGMP) {\n\t\tif (!ipv4_is_local_multicast(iph->daddr))\n\t\t\tBR_INPUT_SKB_CB(skb)->mrouters_only = 1;\n\t\treturn 0;\n\t}\n\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len || len < ip_hdrlen(skb))\n\t\treturn -EINVAL;\n\n\tif (skb->len > len) {\n\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!skb2)\n\t\t\treturn -ENOMEM;\n\n\t\terr = pskb_trim_rcsum(skb2, len);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\tlen -= ip_hdrlen(skb2);\n\toffset = skb_network_offset(skb2) + ip_hdrlen(skb2);\n\t__skb_pull(skb2, offset);\n\tskb_reset_transport_header(skb2);\n\n\terr = -EINVAL;\n\tif (!pskb_may_pull(skb2, sizeof(*ih)))\n\t\tgoto out;\n\n\tswitch (skb2->ip_summed) {\n\tcase CHECKSUM_COMPLETE:\n\t\tif (!csum_fold(skb2->csum))\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase CHECKSUM_NONE:\n\t\tskb2->csum = 0;\n\t\tif (skb_checksum_complete(skb2))\n\t\t\tgoto out;\n\t}\n\n\terr = 0;\n\n\tbr_vlan_get_tag(skb2, &vid);\n\tBR_INPUT_SKB_CB(skb)->igmp = 1;\n\tih = igmp_hdr(skb2);\n\n\tswitch (ih->type) {\n\tcase IGMP_HOST_MEMBERSHIP_REPORT:\n\tcase IGMPV2_HOST_MEMBERSHIP_REPORT:\n\t\tBR_INPUT_SKB_CB(skb)->mrouters_only = 1;\n\t\terr = br_ip4_multicast_add_group(br, port, ih->group, vid);\n\t\tbreak;\n\tcase IGMPV3_HOST_MEMBERSHIP_REPORT:\n\t\terr = br_ip4_multicast_igmp3_report(br, port, skb2);\n\t\tbreak;\n\tcase IGMP_HOST_MEMBERSHIP_QUERY:\n\t\terr = br_ip4_multicast_query(br, port, skb2);\n\t\tbreak;\n\tcase IGMP_HOST_LEAVE_MESSAGE:\n\t\tbr_ip4_multicast_leave_group(br, port, ih->group, vid);\n\t\tbreak;\n\t}\n\nout:\n\t__skb_push(skb2, offset);\nerr_out:\n\tif (skb2 != skb)\n\t\tkfree_skb(skb2);\n\treturn err;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int br_multicast_ipv6_rcv(struct net_bridge *br,\n\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct sk_buff *skb2;\n\tconst struct ipv6hdr *ip6h;\n\tu8 icmp6_type;\n\tu8 nexthdr;\n\t__be16 frag_off;\n\tunsigned int len;\n\tint offset;\n\tint err;\n\tu16 vid = 0;\n\n\tif (!pskb_may_pull(skb, sizeof(*ip6h)))\n\t\treturn -EINVAL;\n\n\tip6h = ipv6_hdr(skb);\n\n\t/*\n\t * We're interested in MLD messages only.\n\t *  - Version is 6\n\t *  - MLD has always Router Alert hop-by-hop option\n\t *  - But we do not support jumbrograms.\n\t */\n\tif (ip6h->version != 6 ||\n\t    ip6h->nexthdr != IPPROTO_HOPOPTS ||\n\t    ip6h->payload_len == 0)\n\t\treturn 0;\n\n\tlen = ntohs(ip6h->payload_len) + sizeof(*ip6h);\n\tif (skb->len < len)\n\t\treturn -EINVAL;\n\n\tnexthdr = ip6h->nexthdr;\n\toffset = ipv6_skip_exthdr(skb, sizeof(*ip6h), &nexthdr, &frag_off);\n\n\tif (offset < 0 || nexthdr != IPPROTO_ICMPV6)\n\t\treturn 0;\n\n\t/* Okay, we found ICMPv6 header */\n\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\terr = -EINVAL;\n\tif (!pskb_may_pull(skb2, offset + sizeof(struct icmp6hdr)))\n\t\tgoto out;\n\n\tlen -= offset - skb_network_offset(skb2);\n\n\t__skb_pull(skb2, offset);\n\tskb_reset_transport_header(skb2);\n\tskb_postpull_rcsum(skb2, skb_network_header(skb2),\n\t\t\t   skb_network_header_len(skb2));\n\n\ticmp6_type = icmp6_hdr(skb2)->icmp6_type;\n\n\tswitch (icmp6_type) {\n\tcase ICMPV6_MGM_QUERY:\n\tcase ICMPV6_MGM_REPORT:\n\tcase ICMPV6_MGM_REDUCTION:\n\tcase ICMPV6_MLD2_REPORT:\n\t\tbreak;\n\tdefault:\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\t/* Okay, we found MLD message. Check further. */\n\tif (skb2->len > len) {\n\t\terr = pskb_trim_rcsum(skb2, len);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = -EINVAL;\n\t}\n\n\tip6h = ipv6_hdr(skb2);\n\n\tswitch (skb2->ip_summed) {\n\tcase CHECKSUM_COMPLETE:\n\t\tif (!csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr, skb2->len,\n\t\t\t\t\tIPPROTO_ICMPV6, skb2->csum))\n\t\t\tbreak;\n\t\t/*FALLTHROUGH*/\n\tcase CHECKSUM_NONE:\n\t\tskb2->csum = ~csum_unfold(csum_ipv6_magic(&ip6h->saddr,\n\t\t\t\t\t\t\t&ip6h->daddr,\n\t\t\t\t\t\t\tskb2->len,\n\t\t\t\t\t\t\tIPPROTO_ICMPV6, 0));\n\t\tif (__skb_checksum_complete(skb2))\n\t\t\tgoto out;\n\t}\n\n\terr = 0;\n\n\tbr_vlan_get_tag(skb, &vid);\n\tBR_INPUT_SKB_CB(skb)->igmp = 1;\n\n\tswitch (icmp6_type) {\n\tcase ICMPV6_MGM_REPORT:\n\t    {\n\t\tstruct mld_msg *mld;\n\t\tif (!pskb_may_pull(skb2, sizeof(*mld))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmld = (struct mld_msg *)skb_transport_header(skb2);\n\t\tBR_INPUT_SKB_CB(skb)->mrouters_only = 1;\n\t\terr = br_ip6_multicast_add_group(br, port, &mld->mld_mca, vid);\n\t\tbreak;\n\t    }\n\tcase ICMPV6_MLD2_REPORT:\n\t\terr = br_ip6_multicast_mld2_report(br, port, skb2);\n\t\tbreak;\n\tcase ICMPV6_MGM_QUERY:\n\t\terr = br_ip6_multicast_query(br, port, skb2);\n\t\tbreak;\n\tcase ICMPV6_MGM_REDUCTION:\n\t    {\n\t\tstruct mld_msg *mld;\n\t\tif (!pskb_may_pull(skb2, sizeof(*mld))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmld = (struct mld_msg *)skb_transport_header(skb2);\n\t\tbr_ip6_multicast_leave_group(br, port, &mld->mld_mca, vid);\n\t    }\n\t}\n\nout:\n\tkfree_skb(skb2);\n\treturn err;\n}\n#endif\n\nint br_multicast_rcv(struct net_bridge *br, struct net_bridge_port *port,\n\t\t     struct sk_buff *skb)\n{\n\tBR_INPUT_SKB_CB(skb)->igmp = 0;\n\tBR_INPUT_SKB_CB(skb)->mrouters_only = 0;\n\n\tif (br->multicast_disabled)\n\t\treturn 0;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\treturn br_multicast_ipv4_rcv(br, port, skb);\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\treturn br_multicast_ipv6_rcv(br, port, skb);\n#endif\n\t}\n\n\treturn 0;\n}\n\nstatic void br_multicast_query_expired(unsigned long data)\n{\n\tstruct net_bridge *br = (void *)data;\n\n\tspin_lock(&br->multicast_lock);\n\tif (br->multicast_startup_queries_sent <\n\t    br->multicast_startup_query_count)\n\t\tbr->multicast_startup_queries_sent++;\n\n\tbr_multicast_send_query(br, NULL, br->multicast_startup_queries_sent);\n\n\tspin_unlock(&br->multicast_lock);\n}\n\nvoid br_multicast_init(struct net_bridge *br)\n{\n\tbr->hash_elasticity = 4;\n\tbr->hash_max = 512;\n\n\tbr->multicast_router = 1;\n\tbr->multicast_querier = 0;\n\tbr->multicast_query_use_ifaddr = 0;\n\tbr->multicast_last_member_count = 2;\n\tbr->multicast_startup_query_count = 2;\n\n\tbr->multicast_last_member_interval = HZ;\n\tbr->multicast_query_response_interval = 10 * HZ;\n\tbr->multicast_startup_query_interval = 125 * HZ / 4;\n\tbr->multicast_query_interval = 125 * HZ;\n\tbr->multicast_querier_interval = 255 * HZ;\n\tbr->multicast_membership_interval = 260 * HZ;\n\n\tspin_lock_init(&br->multicast_lock);\n\tsetup_timer(&br->multicast_router_timer,\n\t\t    br_multicast_local_router_expired, 0);\n\tsetup_timer(&br->multicast_querier_timer,\n\t\t    br_multicast_querier_expired, (unsigned long)br);\n\tsetup_timer(&br->multicast_query_timer, br_multicast_query_expired,\n\t\t    (unsigned long)br);\n}\n\nvoid br_multicast_open(struct net_bridge *br)\n{\n\tbr->multicast_startup_queries_sent = 0;\n\n\tif (br->multicast_disabled)\n\t\treturn;\n\n\tmod_timer(&br->multicast_query_timer, jiffies);\n}\n\nvoid br_multicast_stop(struct net_bridge *br)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct hlist_node *n;\n\tu32 ver;\n\tint i;\n\n\tdel_timer_sync(&br->multicast_router_timer);\n\tdel_timer_sync(&br->multicast_querier_timer);\n\tdel_timer_sync(&br->multicast_query_timer);\n\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\tif (!mdb)\n\t\tgoto out;\n\n\tbr->mdb = NULL;\n\n\tver = mdb->ver;\n\tfor (i = 0; i < mdb->max; i++) {\n\t\thlist_for_each_entry_safe(mp, n, &mdb->mhash[i],\n\t\t\t\t\t  hlist[ver]) {\n\t\t\tdel_timer(&mp->timer);\n\t\t\tmp->timer_armed = false;\n\t\t\tcall_rcu_bh(&mp->rcu, br_multicast_free_group);\n\t\t}\n\t}\n\n\tif (mdb->old) {\n\t\tspin_unlock_bh(&br->multicast_lock);\n\t\trcu_barrier_bh();\n\t\tspin_lock_bh(&br->multicast_lock);\n\t\tWARN_ON(mdb->old);\n\t}\n\n\tmdb->old = mdb;\n\tcall_rcu_bh(&mdb->rcu, br_mdb_free);\n\nout:\n\tspin_unlock_bh(&br->multicast_lock);\n}\n\nint br_multicast_set_router(struct net_bridge *br, unsigned long val)\n{\n\tint err = -ENOENT;\n\n\tspin_lock_bh(&br->multicast_lock);\n\tif (!netif_running(br->dev))\n\t\tgoto unlock;\n\n\tswitch (val) {\n\tcase 0:\n\tcase 2:\n\t\tdel_timer(&br->multicast_router_timer);\n\t\t/* fall through */\n\tcase 1:\n\t\tbr->multicast_router = val;\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\n\treturn err;\n}\n\nint br_multicast_set_port_router(struct net_bridge_port *p, unsigned long val)\n{\n\tstruct net_bridge *br = p->br;\n\tint err = -ENOENT;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || p->state == BR_STATE_DISABLED)\n\t\tgoto unlock;\n\n\tswitch (val) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\tp->multicast_router = val;\n\t\terr = 0;\n\n\t\tif (val < 2 && !hlist_unhashed(&p->rlist))\n\t\t\thlist_del_init_rcu(&p->rlist);\n\n\t\tif (val == 1)\n\t\t\tbreak;\n\n\t\tdel_timer(&p->multicast_router_timer);\n\n\t\tif (val == 0)\n\t\t\tbreak;\n\n\t\tbr_multicast_add_router(br, p);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock:\n\tspin_unlock(&br->multicast_lock);\n\n\treturn err;\n}\n\nstatic void br_multicast_start_querier(struct net_bridge *br)\n{\n\tstruct net_bridge_port *port;\n\n\tbr_multicast_open(br);\n\n\tlist_for_each_entry(port, &br->port_list, list) {\n\t\tif (port->state == BR_STATE_DISABLED ||\n\t\t    port->state == BR_STATE_BLOCKING)\n\t\t\tcontinue;\n\n\t\t__br_multicast_enable_port(port);\n\t}\n}\n\nint br_multicast_toggle(struct net_bridge *br, unsigned long val)\n{\n\tint err = 0;\n\tstruct net_bridge_mdb_htable *mdb;\n\n\tspin_lock_bh(&br->multicast_lock);\n\tif (br->multicast_disabled == !val)\n\t\tgoto unlock;\n\n\tbr->multicast_disabled = !val;\n\tif (br->multicast_disabled)\n\t\tgoto unlock;\n\n\tif (!netif_running(br->dev))\n\t\tgoto unlock;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\tif (mdb) {\n\t\tif (mdb->old) {\n\t\t\terr = -EEXIST;\nrollback:\n\t\t\tbr->multicast_disabled = !!val;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = br_mdb_rehash(&br->mdb, mdb->max,\n\t\t\t\t    br->hash_elasticity);\n\t\tif (err)\n\t\t\tgoto rollback;\n\t}\n\n\tbr_multicast_start_querier(br);\n\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\n\treturn err;\n}\n\nint br_multicast_set_querier(struct net_bridge *br, unsigned long val)\n{\n\tval = !!val;\n\n\tspin_lock_bh(&br->multicast_lock);\n\tif (br->multicast_querier == val)\n\t\tgoto unlock;\n\n\tbr->multicast_querier = val;\n\tif (val)\n\t\tbr_multicast_start_querier(br);\n\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\n\treturn 0;\n}\n\nint br_multicast_set_hash_max(struct net_bridge *br, unsigned long val)\n{\n\tint err = -ENOENT;\n\tu32 old;\n\tstruct net_bridge_mdb_htable *mdb;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev))\n\t\tgoto unlock;\n\n\terr = -EINVAL;\n\tif (!is_power_of_2(val))\n\t\tgoto unlock;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\tif (mdb && val < mdb->size)\n\t\tgoto unlock;\n\n\terr = 0;\n\n\told = br->hash_max;\n\tbr->hash_max = val;\n\n\tif (mdb) {\n\t\tif (mdb->old) {\n\t\t\terr = -EEXIST;\nrollback:\n\t\t\tbr->hash_max = old;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = br_mdb_rehash(&br->mdb, br->hash_max,\n\t\t\t\t    br->hash_elasticity);\n\t\tif (err)\n\t\t\tgoto rollback;\n\t}\n\nunlock:\n\tspin_unlock(&br->multicast_lock);\n\n\treturn err;\n}\n"], "filenames": ["net/bridge/br_mdb.c", "net/bridge/br_multicast.c"], "buggy_code_start_loc": [450, 273], "buggy_code_end_loc": [451, 274], "fixing_code_start_loc": [450, 273], "fixing_code_end_loc": [451, 274], "type": "CWE-20", "message": "The bridge multicast implementation in the Linux kernel through 3.10.3 does not check whether a certain timer is armed before modifying the timeout value of that timer, which allows local users to cause a denial of service (BUG and system crash) via vectors involving the shutdown of a KVM virtual machine, related to net/bridge/br_mdb.c and net/bridge/br_multicast.c.", "other": {"cve": {"id": "CVE-2013-4129", "sourceIdentifier": "secalert@redhat.com", "published": "2013-07-29T13:59:56.803", "lastModified": "2023-02-13T04:44:52.267", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The bridge multicast implementation in the Linux kernel through 3.10.3 does not check whether a certain timer is armed before modifying the timeout value of that timer, which allows local users to cause a denial of service (BUG and system crash) via vectors involving the shutdown of a KVM virtual machine, related to net/bridge/br_mdb.c and net/bridge/br_multicast.c."}, {"lang": "es", "value": "La implementaci\u00f3n bridge multicast en el kernel de Linux hasta la 3.10.3 no valida si un temporizador se encuentra activado antes de modificar su valor de timeout, lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio (BUG y ca\u00edda de sistema) a trav\u00e9s de vectores que involucran el apagado del KVM de una m\u00e1quina virtual. Relacionado con net/bridge/br_mdb.c y net/bridge/br_multicast.c."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "079505E8-2942-4C33-93D1-35ADA4C39E72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.34:*:*:*:*:*:*:*", "matchCriteriaId": "83FF021E-07E3-41CC-AAE8-D99D7FF24B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.35:*:*:*:*:*:*:*", "matchCriteriaId": "F72412E3-8DA9-4CC9-A426-B534202ADBA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.36:*:*:*:*:*:*:*", "matchCriteriaId": "FCAA9D7A-3C3E-4C0B-9D38-EA80E68C2E46"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.37:*:*:*:*:*:*:*", "matchCriteriaId": "4A9E3AE5-3FCF-4CBB-A30B-082BCFBFB0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.38:*:*:*:*:*:*:*", "matchCriteriaId": "CF715657-4C3A-4392-B85D-1BBF4DE45D89"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.39:*:*:*:*:*:*:*", "matchCriteriaId": "4B63C618-AC3D-4EF7-AFDF-27B9BF482B78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.40:*:*:*:*:*:*:*", "matchCriteriaId": "C33DA5A9-5E40-4365-9602-82FB4DCD15B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.41:*:*:*:*:*:*:*", "matchCriteriaId": "EFAFDB74-40BD-46FA-89AC-617EB2C7160B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.42:*:*:*:*:*:*:*", "matchCriteriaId": "CF5F17DA-30A7-40CF-BD7C-CEDF06D64617"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.43:*:*:*:*:*:*:*", "matchCriteriaId": "71A276F5-BD9D-4C1B-90DF-9B0C15B6F7DF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.44:*:*:*:*:*:*:*", "matchCriteriaId": "F8F6EBEC-3C29-444B-BB85-6EF239B59EC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.45:*:*:*:*:*:*:*", "matchCriteriaId": "FDB91302-FD18-44CF-A8A8-B31483328539"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.46:*:*:*:*:*:*:*", "matchCriteriaId": "9B81DC2B-46FA-4640-AD6C-2A404D94BA0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.47:*:*:*:*:*:*:*", "matchCriteriaId": "BA6A1663-BC4C-4FC9-B5EB-A52EDED17B26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.48:*:*:*:*:*:*:*", "matchCriteriaId": "69C33D6C-6B9F-49F4-B505-E7B589CDEC50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.49:*:*:*:*:*:*:*", "matchCriteriaId": "C464796B-2F31-4159-A132-82A0C74137B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.50:*:*:*:*:*:*:*", "matchCriteriaId": "1D6C6E46-FE29-4D2D-A0EC-43DA5112BCC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.51:*:*:*:*:*:*:*", "matchCriteriaId": "1A370E91-73A1-4D62-8E7B-696B920203F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.52:*:*:*:*:*:*:*", "matchCriteriaId": "340197CD-9645-4B7E-B976-F3F5A7D4C5BE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.53:*:*:*:*:*:*:*", "matchCriteriaId": "96030636-0C4A-4A10-B768-525D6A0E18CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.54:*:*:*:*:*:*:*", "matchCriteriaId": "A42D8419-914F-4AD6-B0E9-C1290D514FF1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.55:*:*:*:*:*:*:*", "matchCriteriaId": "F4E2C88B-42EA-4F4F-B1F6-A9332EC6888B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.56:*:*:*:*:*:*:*", "matchCriteriaId": "2449D13B-3314-4182-832F-03F6B11AA31F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.57:*:*:*:*:*:*:*", "matchCriteriaId": "9A35B66C-F050-4462-A58E-FEE061B5582E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.58:*:*:*:*:*:*:*", "matchCriteriaId": "1B551164-0167-49BB-A3AE-4034BDA3DCB4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.59:*:*:*:*:*:*:*", "matchCriteriaId": "7244278E-49B6-4405-A14C-F3540C8F5AF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.60:*:*:*:*:*:*:*", "matchCriteriaId": "B4C3E4B8-7274-4ABB-B7CE-6A39C183CE18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.61:*:*:*:*:*:*:*", "matchCriteriaId": "6501EDB9-4847-47F8-90EE-B295626E4CDC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.62:*:*:*:*:*:*:*", "matchCriteriaId": "2D676D48-7521-45E2-8563-6B966FF86A35"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.63:*:*:*:*:*:*:*", "matchCriteriaId": "3B69FA17-0AB9-4986-A5A7-2A4C1DD24222"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.64:*:*:*:*:*:*:*", "matchCriteriaId": "7BC35593-96C7-41F0-B738-1568F8129121"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.65:*:*:*:*:*:*:*", "matchCriteriaId": "38D23794-0E7C-4FA5-A7A8-CF940E3FA962"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.66:*:*:*:*:*:*:*", "matchCriteriaId": "008E1E7D-4C20-4560-9288-EF532ADB0029"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.67:*:*:*:*:*:*:*", "matchCriteriaId": "3B3A7044-A92E-47A9-A7BD-35E5B575F5FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.68:*:*:*:*:*:*:*", "matchCriteriaId": "783E2980-B6AB-489E-B157-B6A2E10A32CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "3DFFE5A6-6A67-4992-84A3-C0F05FACDEAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "13BBD2A3-AE10-48B9-8776-4FB1CAC37D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "B25680CC-8918-4F27-8D7E-A6579215450B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc3:*:*:*:*:*:*", "matchCriteriaId": "92C48B4C-410C-4BA8-A28A-B2E928320FCC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB447523-855B-461E-8197-95169BE86EB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B155BBDF-6DF6-4FF5-9C41-D8A5266DCC67"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "28476DEC-9630-4B40-9D4D-9BC151DC4CA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646880A-2355-4BDD-89E7-825863A0311F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "7FF99148-267A-46F8-9927-A9082269BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A783C083-5D9C-48F9-B5A6-A97A9604FB19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B817A24-03AC-46CD-BEFA-505457FD2A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "51CF1BCE-090E-4B70-BA16-ACB74411293B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "187AAD67-10D7-4B57-B4C6-00443E246AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "F341CE88-C5BC-4CDD-9CB5-B6BAD7152E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "37ACE2A6-C229-4236-8E9F-235F008F3AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D3220B70-917F-4F9F-8A3B-2BF581281E8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "99372D07-C06A-41FA-9843-6D57F99AB5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "2B9DC110-D260-4DB4-B8B0-EF1D160ADA07"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc4:*:*:*:*:*:*", "matchCriteriaId": "6192FE84-4D53-40D4-AF61-78CE7136141A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc5:*:*:*:*:*:*", "matchCriteriaId": "42FEF3CF-1302-45EB-89CC-3786FE4BAC1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc6:*:*:*:*:*:*", "matchCriteriaId": "AE6A6B58-2C89-4DE4-BA57-78100818095C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc7:*:*:*:*:*:*", "matchCriteriaId": "1D467F87-2F13-4D26-9A93-E0BA526FEA24"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE348F7B-02DE-47D5-8011-F83DA9426021"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E91594EA-F0A3-41B3-A9C6-F7864FC2F229"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E1ECCDB-0208-48F6-B44F-16CC0ECE3503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "FBA8B5DE-372E-47E0-A0F6-BE286D509CC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "9A1CA083-2CF8-45AE-9E15-1AA3A8352E3B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "19D69A49-5290-4C5F-8157-719AD58D253D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "290BD969-42E7-47B0-B21B-06DE4865432C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "23A9E29E-DE78-4C73-9FBD-C2410F5FC8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "018434C9-E75F-45CB-A169-DAB4B1D864D7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "DC0AC68F-EC58-4C4F-8CBC-A59ECC00CCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "C123C844-F6D7-471E-A62E-F756042FB1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "A11C38BB-7FA2-49B0-AAC9-83DB387A06DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.13:*:*:*:*:*:*:*", "matchCriteriaId": "61F3733C-E5F6-4855-B471-DF3FB823613B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.14:*:*:*:*:*:*:*", "matchCriteriaId": "1DDCA75F-9A06-4457-9A45-38A38E7F7086"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.15:*:*:*:*:*:*:*", "matchCriteriaId": "7AEA837E-7864-4003-8DB7-111ED710A7E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.16:*:*:*:*:*:*:*", "matchCriteriaId": "B6FE471F-2D1F-4A1D-A197-7E46B75787E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.17:*:*:*:*:*:*:*", "matchCriteriaId": "FDA9E6AB-58DC-4EC5-A25C-11F9D0B38BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.18:*:*:*:*:*:*:*", "matchCriteriaId": "DC6B8DB3-B05B-41A2-B091-342D66AAE8F5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.19:*:*:*:*:*:*:*", "matchCriteriaId": "958F0FF8-33EF-4A71-A0BD-572C85211DBA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.20:*:*:*:*:*:*:*", "matchCriteriaId": "FBA39F48-B02F-4C48-B304-DA9CCA055244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.21:*:*:*:*:*:*:*", "matchCriteriaId": "1FF841F3-48A7-41D7-9C45-A8170435A5EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.22:*:*:*:*:*:*:*", "matchCriteriaId": "EF506916-A6DC-4B1E-90E5-959492AF55F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.23:*:*:*:*:*:*:*", "matchCriteriaId": "B3CDAD1F-2C6A-48C0-8FAB-C2659373FA25"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.24:*:*:*:*:*:*:*", "matchCriteriaId": "4FFE4B22-C96A-43D0-B993-F51EDD9C5E0E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.25:*:*:*:*:*:*:*", "matchCriteriaId": "F571CC8B-B212-4553-B463-1DB01D616E8A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.26:*:*:*:*:*:*:*", "matchCriteriaId": "84E3E151-D437-48ED-A529-731EEFF88567"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.27:*:*:*:*:*:*:*", "matchCriteriaId": "E9E3EA3C-CCA5-4433-86E0-3D02C4757A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.28:*:*:*:*:*:*:*", "matchCriteriaId": "F7AC4F7D-9FA6-4CF1-B2E9-70BF7D4D177C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.29:*:*:*:*:*:*:*", "matchCriteriaId": "3CE3A80D-9648-43CC-8F99-D741ED6552BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.30:*:*:*:*:*:*:*", "matchCriteriaId": "C8A98C03-A465-41B4-A551-A26FEC7FFD94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFB76697-1C2F-48C0-9B14-517EC053D4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "BED88DFD-1DC5-4505-A441-44ECDEF0252D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "DBFD2ACD-728A-4082-BB6A-A1EF6E58E47D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "C31B0E51-F62D-4053-B04F-FC4D5BC373D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "A914303E-1CB6-4AAD-9F5F-DE5433C4E814"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "203BBA69-90B2-4C5E-8023-C14180742421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "0DBFAB53-B889-4028-AC0E-7E165B152A18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc7:*:*:*:*:*:*", "matchCriteriaId": "FE409AEC-F677-4DEF-8EB7-2C35809043CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "578EC12B-402F-4AD4-B8F8-C9B2CAB06891"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "877002ED-8097-4BB4-BB88-6FC6306C38B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "76294CE3-D72C-41D5-9E0F-B693D0042699"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "916E97D4-1FAB-42F5-826B-653B1C0909A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "33FD2217-C5D0-48C1-AD74-3527127FEF9C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "2E92971F-B629-4E0A-9A50-8B235F9704B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "EDD3A069-3829-4EE2-9D5A-29459F29D4C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "A4A0964C-CEB2-41D7-A69C-1599B05B6171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "0F960FA6-F904-4A4E-B483-44C70090E9A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "261C1B41-C9E0-414F-8368-51C0C0B8AD38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:*:*", "matchCriteriaId": "5CCA261D-2B97-492F-89A0-5F209A804350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:*:*", "matchCriteriaId": "1B1C0C68-9194-473F-BE5E-EC7F184899FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:*:*", "matchCriteriaId": "D7A6AC9E-BEA6-44B0-B3B3-F0F94E32424A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:*:*", "matchCriteriaId": "16038328-9399-4B85-B777-BA4757D02C9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:*:*", "matchCriteriaId": "16CA2757-FA8D-43D9-96E8-D3C0EB6E1DEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:*:*", "matchCriteriaId": "E8CB5481-5EAE-401E-BD7E-D3095CCA9E94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0F36FAC-141D-476D-84C5-A558C199F904"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "51D64824-25F6-4761-BD6A-29038A143744"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "E284C8A1-740F-454D-A774-99CD3A21B594"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "C70D72AE-0CBF-4324-9935-57E28EC6279C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "F674B06B-7E86-4E41-9126-8152D0DDABAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "7039B3EC-8B22-413E-B582-B4BEC6181241"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "35CF1DD2-80B9-4476-8963-5C3EF52B33F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "BFB0B05B-A5CE-4B9C-AE7F-83062868D35B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "D166A66E-7454-47EC-BB56-861A9AFEAFE1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "7DA94F50-2A62-4300-BF4D-A342AAE35629"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "252D937B-50DC-444F-AE73-5FCF6203DF27"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "F6D8EE51-02C1-47BC-A92C-0A8ABEFD28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "7F20A5D7-3B38-4911-861A-04C8310D5916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.14:*:*:*:*:*:*:*", "matchCriteriaId": "D472DE3A-71D8-4F40-9DDE-85929A2B047D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.15:*:*:*:*:*:*:*", "matchCriteriaId": "B2AED943-65A8-4FDB-BBD0-CCEF8682A48C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.16:*:*:*:*:*:*:*", "matchCriteriaId": "D4640185-F3D8-4575-A71D-4C889A93DE2C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.17:*:*:*:*:*:*:*", "matchCriteriaId": "144CCF7C-025E-4879-B2E7-ABB8E4390BE5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.18:*:*:*:*:*:*:*", "matchCriteriaId": "B6FAA052-0B2B-40CE-8C98-919B8D08A5ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.19:*:*:*:*:*:*:*", "matchCriteriaId": "4B5A53DE-9C83-4A6B-96F3-23C03BF445D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.20:*:*:*:*:*:*:*", "matchCriteriaId": "063EB879-CB05-4E33-AA90-9E43516839B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.21:*:*:*:*:*:*:*", "matchCriteriaId": "2D25764F-4B02-4C65-954E-8C7D6632DE00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.22:*:*:*:*:*:*:*", "matchCriteriaId": "F31F5BF3-CD0A-465C-857F-273841BCD28A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.23:*:*:*:*:*:*:*", "matchCriteriaId": "FF302C8A-079B-42B9-B455-CD9083BFA067"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.24:*:*:*:*:*:*:*", "matchCriteriaId": "744999C0-33D3-4363-B3DB-E0D02CDD3918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.25:*:*:*:*:*:*:*", "matchCriteriaId": "C2E77A76-2A60-45D8-9337-867BC22C5110"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.26:*:*:*:*:*:*:*", "matchCriteriaId": "C9F4AAE7-C870-46B7-B559-2949737BE777"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.27:*:*:*:*:*:*:*", "matchCriteriaId": "20FA2824-20B0-48B8-BB0A-4904C1D3E8AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.28:*:*:*:*:*:*:*", "matchCriteriaId": "9F9B347E-61AC-419F-9701-B862BBFA46F2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.29:*:*:*:*:*:*:*", "matchCriteriaId": "989F351C-8B7C-4C1B-AFA2-AE9431576368"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.30:*:*:*:*:*:*:*", "matchCriteriaId": "8D22172A-9FA7-42E0-8451-165D8E47A573"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.31:*:*:*:*:*:*:*", "matchCriteriaId": "CE31624C-94F9-45D8-9B4A-D0028F10602F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.32:*:*:*:*:*:*:*", "matchCriteriaId": "70967A83-28F6-4568-9ADA-6EF232E5BBC2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "962B0C45-AB29-4383-AC16-C6E8245D0FF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "A0EE126B-74B2-4F79-BFE1-3DC169F3F9B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "392075E0-A9C7-4B4A-90F9-7F1ADFF5EFA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "ECC66968-06F0-4874-A95A-A292C36E45C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "5FE986E6-1068-4E1B-8EAB-DF1EAF32B4E3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "543E8536-1A8E-4E76-B89F-1B1F9F26FAB8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "EC2B45E3-31E1-4B46-85FA-3A84E75B8F84"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6:*:*:*:*:*:*:*", "matchCriteriaId": "DDB8CC75-D3EE-417C-A83D-CB6D666FE595"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "09A072F1-7BEE-4236-ACBB-55DB8FEF4A03"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "E19D5A58-17D6-4502-A57A-70B2F84817A4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "D58BA035-1204-4DFA-98A1-12111FB6222E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "A17F2E87-8EB8-476A-B5B5-9AE5CF53D9FE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "A8CCC101-5852-4299-9B67-EA1B149D58C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "B8074D32-C252-4AD3-A579-1C5EDDD7014B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "962AA802-8179-4606-AAC0-9363BAEABC9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "1286C858-D5A2-45F3-86D1-E50FE53FB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "5AC4A13E-F560-4D01-98A3-E2A2B82EB25B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "942C462A-5398-4BB9-A792-598682E1FEF2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "B852F7E0-0282-483D-BB4D-18CB7A4F1392"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7:*:*:*:*:*:*:*", "matchCriteriaId": "53ED9A31-99CC-41C8-8B72-5B2A9B49AA6C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "EFD646BC-62F7-47CF-B0BE-768F701F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F43D418E-87C1-4C83-9FF1-4F45B4F452DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "680D0E00-F29A-487C-8770-8E7EAC672B7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "2DCA96A4-A836-4E94-A39C-3AD3EA1D9611"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "753C05E3-B603-4E36-B9BA-FAEDCBF62A7D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "E385C2E0-B9F1-4564-8E6D-56FD9E762405"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "041335D4-05E1-4004-9381-28AAD5994B47"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "370F2AE5-3DBC-46B9-AC70-F052C9229C00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "7A971BE3-259D-4494-BBC5-12793D92DB57"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.10:*:*:*:*:*:*:*", "matchCriteriaId": "8E4719A6-FDEA-4714-A830-E23A52AE90BC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "4F543D23-1774-4D14-A7D1-AD49EDEA94DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "FC323F58-CA00-4C3C-BA4D-CC2C0A6E5F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "FEA0B2E3-668D-40ED-9D3D-709EB6449F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "3431B258-4EC8-4E7F-87BB-4D934880601E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "1B09FA1E-8B28-4F2A-BA7E-8E1C40365970"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "91917120-9D68-41C0-8B5D-85C256BC6200"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.9:*:*:*:*:*:*:*", "matchCriteriaId": "AAD268A0-096C-4C31-BEC5-D47F5149D462"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "32BD2427-C47F-4660-A1D9-448E500EF5B9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "02048CE5-81C7-4DFB-BC40-CE4C86B7E022"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.12:*:*:*:*:*:*:*", "matchCriteriaId": "934D2B37-0575-4A75-B00B-0028316D6DF0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.13:*:*:*:*:*:*:*", "matchCriteriaId": "06754C21-995C-4850-A4DC-F21826C0F8C5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc1:*:*:*:*:*:*", "matchCriteriaId": "42633FF9-FB0C-4095-B4A1-8D623A98683B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc2:*:*:*:*:*:*", "matchCriteriaId": "08C04619-89A2-4B15-82A2-48BCC662C1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc3:*:*:*:*:*:*", "matchCriteriaId": "5B039196-7159-476C-876A-C61242CC41DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc4:*:*:*:*:*:*", "matchCriteriaId": "3A9E0457-53C9-44DD-ACFB-31EE1D1E060E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc5:*:*:*:*:*:*", "matchCriteriaId": "BEE406E7-87BA-44BA-BF61-673E6CC44A2F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc6:*:*:*:*:*:*", "matchCriteriaId": "29FBA173-658F-45DC-8205-934CACD67166"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc7:*:*:*:*:*:*", "matchCriteriaId": "139700F0-BA32-40CF-B9DF-C9C450384FDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "E578085C-3968-4543-BEBA-EE3C3CB4FA02"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "4DCFA441-68FB-4559-A245-FF0B79DE43CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "8C2508D8-6571-4B81-A0D7-E494CCD039CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "8B516926-5E86-4C0A-85F3-F64E1FCDA249"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "069D774D-79BE-479F-BF4E-F021AD808114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "D15B27A9-46E0-4DDF-A00C-29F8F1F18D73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "A381BB4A-28B4-4672-87EE-91B3DDD6C71A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "922F80CF-937D-4FA2-AFF2-6E47FFE9E1E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "A548ADF4-9E3B-407C-A5ED-05150EB3A185"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "9C623230-4497-41B9-9BD2-7A6CFDD77983"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "C72FA8A6-60A6-4486-A245-7BEF8B2A2711"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.11:*:*:*:*:*:*:*", "matchCriteriaId": "0A498D90-BB99-405E-9FA6-1FBFE179787E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "D0D32776-8ADB-4E79-846A-C0C99FED19E0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "B7D01673-D13F-487F-81B6-1279C187277E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "ADB27A3E-78E4-40F7-9716-A1099B0D85FB"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=c7e8e8a8f7a70b343ca1e0f90a31e35ab2d16de1", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/07/16/1", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.securityfocus.com/bid/61193", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=984743", "source": "secalert@redhat.com"}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/85763", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/c7e8e8a8f7a70b343ca1e0f90a31e35ab2d16de1", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c7e8e8a8f7a70b343ca1e0f90a31e35ab2d16de1"}}