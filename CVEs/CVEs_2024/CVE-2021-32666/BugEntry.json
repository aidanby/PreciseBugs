{"buggy_code": ["//\n// Wire\n// Copyright (C) 2017 Wire Swiss GmbH\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see http://www.gnu.org/licenses/.\n//\n\nimport Foundation\nimport WireUtilities\nimport WireSystem\n\nextension ZMUser: UserType {\n    @objc\n    public var hasTeam: Bool {\n        /// Other users won't have a team object, but a teamIdentifier.\n        return nil != team || nil != teamIdentifier\n    }\n\n    /// Whether all user's devices are verified by the selfUser\n    public var isTrusted: Bool {\n        let selfUser = managedObjectContext.map(ZMUser.selfUser)\n        let selfClient = selfUser?.selfClient()\n        let hasUntrustedClients = self.clients.contains(where: { ($0 != selfClient) && !(selfClient?.trustedClients.contains($0) ?? false) })\n        \n        return !hasUntrustedClients\n    }\n    \n    public func isGuest(in conversation: ConversationLike) -> Bool {\n        return _isGuest(in: conversation)\n    }\n    \n    public var teamName: String? {\n        return team?.name\n    }\n    \n    public var hasDigitalSignatureEnabled: Bool {\n        return team?.fetchFeatureFlag(with: .digitalSignature)?.isEnabled ?? false\n    }\n    \n    public var previewImageData: Data? {\n        return imageSmallProfileData\n    }\n    \n    public var completeImageData: Data? {\n        return imageMediumData\n    }\n    \n    public var activeConversations: Set<ZMConversation> {\n        return Set(self.participantRoles.compactMap {$0.conversation})\n    }\n    \n    public var isVerified: Bool {\n        guard let selfUser = managedObjectContext.map(ZMUser.selfUser) else {\n            return false\n        }\n        return isTrusted && selfUser.isTrusted && !clients.isEmpty\n    }\n\n    public var isFederated: Bool {\n        guard let selfUser = managedObjectContext.map(ZMUser.selfUser) else {\n            return false\n        }\n\n        return selfUser.isFederating(with: self)\n    }\n\n    // MARK: - Conversation Roles\n\n    public func canManagedGroupRole(of user: UserType, conversation: ZMConversation) -> Bool {\n        guard isGroupAdmin(in: conversation) else { return false }\n        return !user.isSelfUser && (user.isConnected || isOnSameTeam(otherUser: user))\n    }\n\n    public func isGroupAdmin(in conversation: ConversationLike) -> Bool {\n        return role(in: conversation)?.name == ZMConversation.defaultAdminRoleName\n    }\n\n    public func role(in conversation: ConversationLike?) -> Role? {\n        return participantRoles.first(where: { $0.conversation === conversation })?.role\n    }\n\n    // MARK: Legal Hold\n\n    @objc public var isUnderLegalHold: Bool {\n        return clients.any(\\.isLegalHoldDevice)\n    }\n\n    @objc class func keyPathsForValuesAffectingIsUnderLegalHold() -> Set<String> {\n        return [UserClientsKey, \"clients.deviceClass\"]\n    }\n    \n    public var allClients: [UserClientType] {\n        return Array(clients)\n    }\n\n    // MARK: - Data refresh requests\n\n    public func refreshRichProfile() {\n        needsRichProfileUpdate = true\n    }\n\n    public func refreshMembership() {\n        membership?.needsToBeUpdatedFromBackend = true\n    }\n\n    public func refreshTeamData() {\n        team?.refreshMetadata()\n    }\n    \n}\n\npublic struct AssetKey {\n    \n    static let legalCharacterSet = CharacterSet.alphanumerics.union(CharacterSet.punctuationCharacters)\n    \n    public init?(_ string: String) {\n        if AssetKey.validate(string: string) {\n            stringValue = string\n        } else {\n            return nil\n        }\n    }\n    \n    let stringValue : String\n    \n    fileprivate static func validate(string : String) -> Bool {\n        return CharacterSet(charactersIn: string).isSubset(of: legalCharacterSet)\n    }\n}\n\n@objc public enum ProfileImageSize: Int {\n    case preview\n    case complete\n    \n    public var imageFormat: ZMImageFormat {\n        switch self {\n        case .preview:\n            return .profile\n        case .complete:\n            return .medium\n        }\n    }\n\n    public init?(stringValue: String) {\n        switch stringValue {\n        case ProfileImageSize.preview.stringValue: self = .preview\n        case ProfileImageSize.complete.stringValue: self = .complete\n        default: return nil\n        }\n    }\n\n    var stringValue: String {\n        switch self {\n        case .preview: return \"preview\"\n        case .complete: return \"complete\"\n        }\n    }\n    \n    public static var allSizes: [ProfileImageSize] {\n        return [.preview, .complete]\n    }\n}\n\nextension ProfileImageSize: CustomDebugStringConvertible {\n     public var debugDescription: String {\n        switch self {\n        case .preview:\n            return \"ProfileImageSize.preview\"\n        case .complete:\n            return \"ProfileImageSize.complete\"\n        }\n    }\n}\n\nextension ZMUser: ServiceUser {\n    @NSManaged public var providerIdentifier: String?\n    @NSManaged public var serviceIdentifier: String?\n}\n\npublic extension Notification.Name {\n    static let userDidRequestPreviewAsset = Notification.Name(\"UserDidRequestPreviewAsset\")\n    static let userDidRequestCompleteAsset = Notification.Name(\"UserDidRequestCompleteAsset\")\n}\n\nextension ZMUser {\n    \n    @objc static let previewProfileAssetIdentifierKey = #keyPath(ZMUser.previewProfileAssetIdentifier)\n    @objc static let completeProfileAssetIdentifierKey = #keyPath(ZMUser.completeProfileAssetIdentifier)\n\n    @NSManaged public var previewProfileAssetIdentifier: String?\n    @NSManaged public var completeProfileAssetIdentifier: String?\n    \n    /// Conversations created by this user\n    @NSManaged var conversationsCreated: Set<ZMConversation>\n    \n    /// Team membership for this user\n    @NSManaged public internal(set) var membership: Member?\n\n    /// Reactions expressed by this user\n    @NSManaged var reactions: Set<Reaction>\n    \n    /// System messages referencing this user\n    @NSManaged var systemMessages: Set<ZMSystemMessage>\n    \n    @NSManaged var expiresAt: Date?\n    \n    /// `accountIsDeleted` is true if this account has been deleted on the backend\n    @NSManaged public internal(set) var isAccountDeleted: Bool\n    \n    @NSManaged public var usesCompanyLogin: Bool\n    \n    /// If `needsToRefetchLabels` is true we need to refetch the conversation labels (favorites & folders)\n    @NSManaged public var needsToRefetchLabels: Bool\n    \n    @NSManaged public var domain: String?\n    \n    @objc(setImageData:size:)\n    public func setImage(data: Data?, size: ProfileImageSize) {\n        guard let imageData = data else {\n            managedObjectContext?.zm_userImageCache?.removeAllUserImages(self)\n            return\n        }\n        managedObjectContext?.zm_userImageCache?.setUserImage(self, imageData: imageData, size: size)\n        \n        if let uiContext = managedObjectContext?.zm_userInterface {\n            let changedKey = size == .preview ? #keyPath(ZMUser.previewImageData) : #keyPath(ZMUser.completeImageData)\n            NotificationDispatcher.notifyNonCoreDataChanges(objectID: objectID, changedKeys: [changedKey], uiContext: uiContext)\n        }\n    }\n    \n    public func imageData(for size: ProfileImageSize, queue: DispatchQueue, completion: @escaping (_ imageData: Data?) -> Void) {\n        managedObjectContext?.zm_userImageCache?.userImage(self, size: size, queue: queue, completion: completion)\n    }\n    \n    @objc(imageDataforSize:)\n    public func imageData(for size: ProfileImageSize) -> Data? {\n        return managedObjectContext?.zm_userImageCache?.userImage(self, size: size)\n    }\n    \n    public static var previewImageDownloadFilter: NSPredicate {\n        let assetIdExists = NSPredicate(format: \"(%K != nil)\", ZMUser.previewProfileAssetIdentifierKey)\n        let notCached = NSPredicate() { (user, _) -> Bool in\n            guard let user = user as? ZMUser else { return false }\n            return user.imageSmallProfileData == nil\n        }\n        return NSCompoundPredicate(andPredicateWithSubpredicates: [assetIdExists, notCached])\n    }\n    \n    public static var completeImageDownloadFilter: NSPredicate {\n        let assetIdExists = NSPredicate(format: \"(%K != nil)\", ZMUser.completeProfileAssetIdentifierKey)\n        let notCached = NSPredicate() { (user, _) -> Bool in\n            guard let user = user as? ZMUser else { return false }\n            return user.imageMediumData == nil\n        }\n        return NSCompoundPredicate(andPredicateWithSubpredicates: [assetIdExists, notCached])\n    }\n    \n    public func updateAndSyncProfileAssetIdentifiers(previewIdentifier: String, completeIdentifier: String) {\n        guard isSelfUser else { return }\n        previewProfileAssetIdentifier = previewIdentifier\n        completeProfileAssetIdentifier = completeIdentifier\n        setLocallyModifiedKeys([ZMUser.previewProfileAssetIdentifierKey, ZMUser.completeProfileAssetIdentifierKey])\n    }\n    \n    @objc public func updateAssetData(with assets: NSArray?, authoritative: Bool) {\n        guard !hasLocalModifications(forKeys: [ZMUser.previewProfileAssetIdentifierKey, ZMUser.completeProfileAssetIdentifierKey]) else { return }\n        guard let assets = assets as? [[String : String]], !assets.isEmpty else {\n            if authoritative {\n                previewProfileAssetIdentifier = nil\n                completeProfileAssetIdentifier = nil\n            }\n            return\n        }\n        for data in assets {\n            if let size = data[\"size\"].flatMap(ProfileImageSize.init), let key = data[\"key\"].flatMap(AssetKey.init) {\n                switch size {\n                case .preview:\n                    if key.stringValue != previewProfileAssetIdentifier {\n                        previewProfileAssetIdentifier = key.stringValue\n                    }\n                case .complete:\n                    if key.stringValue != completeProfileAssetIdentifier {\n                        completeProfileAssetIdentifier = key.stringValue\n                    }\n                }\n            }\n        }\n    }\n    \n    @objc public func requestPreviewProfileImage() {\n        guard let moc = self.managedObjectContext, moc.zm_isUserInterfaceContext, !moc.zm_userImageCache.hasUserImage(self, size: .preview) else { return }\n        \n        NotificationInContext(name: .userDidRequestPreviewAsset,\n                              context: moc.notificationContext,\n                              object: self.objectID).post()\n    }\n    \n    @objc public func requestCompleteProfileImage() {\n        guard let moc = self.managedObjectContext, moc.zm_isUserInterfaceContext, !moc.zm_userImageCache.hasUserImage(self, size: .complete) else { return }\n        \n        NotificationInContext(name: .userDidRequestCompleteAsset,\n                              context: moc.notificationContext,\n                              object: self.objectID).post()\n    }\n    \n    /// Mark the user's account as having been deleted. This will also remove the user from any conversations he/she\n    /// is still a participant of.\n    @objc public func markAccountAsDeleted(at timestamp: Date) {\n        isAccountDeleted = true\n        removeFromAllConversations(at: timestamp)\n    }\n    \n    /// Remove user from all group conversations he is a participant of\n    fileprivate func removeFromAllConversations(at timestamp: Date) {\n        let allGroupConversations: [ZMConversation] = participantRoles.compactMap {\n            guard let convo = $0.conversation,\n                convo.conversationType == .group else { return nil}\n            return convo\n        }\n        \n        allGroupConversations.forEach { conversation in\n            if isTeamMember && conversation.team == team {\n                conversation.appendTeamMemberRemovedSystemMessage(user: self, at: timestamp)\n            } else {\n                conversation.appendParticipantRemovedSystemMessage(user: self, at: timestamp)\n            }\n            conversation.removeParticipantAndUpdateConversationState(user: self, initiatingUser: self)\n        }\n    }\n}\n\nextension ZMUser {\n    // MARK: - Participant role\n    \n    @objc\n    public var conversations: Set<ZMConversation> {\n        return Set(participantRoles.compactMap{ return $0.conversation })\n    }\n}\n\nextension NSManagedObject: SafeForLoggingStringConvertible {\n    public var safeForLoggingDescription: String {\n        let moc: String = self.managedObjectContext?.description ?? \"nil\"\n        \n        return \"\\(type(of: self)) \\(Unmanaged.passUnretained(self).toOpaque()): moc=\\(moc) objectID=\\(self.objectID)\"\n    }\n}\n\nextension ZMUser {\n    \n    /// The initials e.g. \"JS\" for \"John Smith\"\n    @objc public var initials: String? {\n        return PersonName.person(withName: self.name ?? \"\", schemeTagger: nil).initials\n    }\n}\n\n", "//\n// Wire\n// Copyright (C) 2017 Wire Swiss GmbH\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see http://www.gnu.org/licenses/.\n//\n\nimport Foundation\n@testable import WireDataModel\n\n// MARK: - Modified keys for profile picture upload\nfinal class ZMUserTests_Swift: ModelObjectsTests {\n    func testThatSettingUserProfileAssetIdentifiersDirectlyDoesNotMarkAsModified() {\n        // GIVEN\n        let user = ZMUser.selfUser(in: uiMOC)\n        \n        // WHEN\n        user.previewProfileAssetIdentifier = \"foo\"\n        user.completeProfileAssetIdentifier = \"bar\"\n\n        // THEN\n        XCTAssertFalse(user.hasLocalModifications(forKey: #keyPath(ZMUser.previewProfileAssetIdentifier)))\n        XCTAssertFalse(user.hasLocalModifications(forKey: #keyPath(ZMUser.completeProfileAssetIdentifier)))\n    }\n\n    \n    func testThatSettingUserProfileAssetIdentifiersMarksKeysAsModified() {\n        // GIVEN\n        let user = ZMUser.selfUser(in: uiMOC)\n        \n        // WHEN\n        user.updateAndSyncProfileAssetIdentifiers(previewIdentifier: \"foo\", completeIdentifier: \"bar\")\n        \n        // THEN\n        XCTAssert(user.hasLocalModifications(forKey: #keyPath(ZMUser.previewProfileAssetIdentifier)))\n        XCTAssert(user.hasLocalModifications(forKey: #keyPath(ZMUser.completeProfileAssetIdentifier)))\n    }\n    \n    func testThatSettingUserProfileAssetIdentifiersDoNothingForNonSelfUsers() {\n        // GIVEN\n        let initialPreview = \"123456\"\n        let initialComplete = \"987654\"\n        let user = ZMUser.insertNewObject(in: uiMOC)\n        user.previewProfileAssetIdentifier = initialPreview\n        user.completeProfileAssetIdentifier = initialComplete\n        \n        // WHEN\n        user.updateAndSyncProfileAssetIdentifiers(previewIdentifier: \"foo\", completeIdentifier: \"bar\")\n        \n        // THEN\n        XCTAssertEqual(user.previewProfileAssetIdentifier, initialPreview)\n        XCTAssertEqual(user.completeProfileAssetIdentifier, initialComplete)\n    }\n    \n}\n\n// MARK: - AssetV3 response parsing\n\nextension ZMUserTests_Swift {\n    \n    func assetPayload(previewId: String , completeId: String) -> NSArray {\n        return [\n            [\"size\" : \"preview\", \"type\" : \"image\", \"key\" : previewId],\n            [\"size\" : \"complete\", \"type\" : \"image\", \"key\" : completeId],\n        ] as NSArray\n    }\n    \n    func testThatItDoesNotUpdateAssetsWhenThereAreLocalModifications() {\n        syncMOC.performGroupedBlockAndWait {\n\n            // GIVEN\n            let user = ZMUser.selfUser(in: self.syncMOC)\n            let previewId = \"some\"\n            let completeId = \"other\"\n            let payload = self.assetPayload(previewId: \"foo\", completeId: \"bar\")\n            \n            // WHEN\n            user.updateAndSyncProfileAssetIdentifiers(previewIdentifier: previewId, completeIdentifier: completeId)\n            user.updateAssetData(with: payload, authoritative: true)\n            \n            // THEN\n            XCTAssertEqual(user.previewProfileAssetIdentifier, previewId)\n            XCTAssertEqual(user.completeProfileAssetIdentifier, completeId)\n        }\n    }\n    \n    func testThatItIgnoreAssetsWithIllegalCharacters() {\n        syncMOC.performGroupedBlockAndWait {\n            \n            // GIVEN\n            let user = ZMUser.selfUser(in: self.syncMOC)\n            let previewId = \"some\"\n            let completeId = \"other\"\n            let payload = self.assetPayload(previewId: \"Aa\\\\u0000\\r\\n\", completeId: \"Aa\\\\u0000\\r\\n\")\n            \n            // WHEN\n            user.updateAndSyncProfileAssetIdentifiers(previewIdentifier: previewId, completeIdentifier: completeId)\n            user.updateAssetData(with: payload, authoritative: true)\n            \n            // THEN\n            XCTAssertEqual(user.previewProfileAssetIdentifier, previewId)\n            XCTAssertEqual(user.completeProfileAssetIdentifier, completeId)\n        }\n    }\n    \n    func testThatItRemovesRemoteIdentifiersWhenWeGetEmptyAssets() {\n        syncMOC.performGroupedBlockAndWait {\n            // GIVEN\n            let user = ZMUser(remoteID: UUID.create(), createIfNeeded: true, in: self.syncMOC)\n            user?.previewProfileAssetIdentifier = \"some\"\n            user?.completeProfileAssetIdentifier = \"other\"\n            \n            // WHEN\n            user?.updateAssetData(with: NSArray(), authoritative: true)\n            \n            // THEN\n            XCTAssertNil(user?.previewProfileAssetIdentifier)\n            XCTAssertNil(user?.completeProfileAssetIdentifier)\n        }\n    }\n    \n    func testThatItUpdatesIdentifiersAndRemovesCachedImagesWhenWeGetRemoteIdentifiers() {\n        syncMOC.performGroupedBlockAndWait {\n            // GIVEN\n            let user = ZMUser(remoteID: UUID.create(), createIfNeeded: true, in: self.syncMOC)\n            user?.previewProfileAssetIdentifier = \"123\"\n            user?.completeProfileAssetIdentifier = \"456\"\n            user?.setImage(data: \"some\".data(using: .utf8), size: .preview)\n            user?.setImage(data: \"other\".data(using: .utf8), size: .complete)\n            XCTAssertNotNil(user?.imageData(for: .preview))\n            XCTAssertNotNil(user?.imageData(for: .complete))\n            let previewId = \"some\"\n            let completeId = \"other\"\n            let payload = self.assetPayload(previewId: previewId, completeId: completeId)\n            \n            // WHEN\n            user?.updateAssetData(with: payload, authoritative: true)\n            \n            // THEN\n            XCTAssertEqual(user?.previewProfileAssetIdentifier, previewId)\n            XCTAssertNil(user?.imageData(for: .preview))\n            XCTAssertEqual(user?.completeProfileAssetIdentifier, completeId)\n            XCTAssertNil(user?.imageData(for: .complete))\n        }\n    }\n    \n    func testThatItDoesNotRemoveLocalImagesIfRemoteIdentifiersHaveNotChanged() {\n        syncMOC.performGroupedBlockAndWait {\n            // GIVEN\n            let previewId = \"some\"\n            let previewData = \"some\".data(using: .utf8)\n            let completeId = \"other\"\n            let completeData = \"other\".data(using: .utf8)\n            let user = ZMUser(remoteID: UUID.create(), createIfNeeded: true, in: self.syncMOC)\n            user?.previewProfileAssetIdentifier = previewId\n            user?.completeProfileAssetIdentifier = completeId\n            user?.setImage(data: previewData, size: .preview)\n            user?.setImage(data: completeData, size: .complete)\n            XCTAssertNotNil(user?.imageData(for: .preview))\n            XCTAssertNotNil(user?.imageData(for: .complete))\n            let payload = self.assetPayload(previewId: previewId, completeId: completeId)\n            \n            // WHEN\n            user?.updateAssetData(with: payload, authoritative: true)\n            \n            // THEN\n            XCTAssertEqual(user?.previewProfileAssetIdentifier, previewId)\n            XCTAssertEqual(user?.completeProfileAssetIdentifier, completeId)\n            XCTAssertEqual(user?.imageData(for: .preview), previewData)\n            XCTAssertEqual(user?.imageData(for: .complete), completeData)\n        }\n    }\n\n}\n\n// MARK: - AssetV3 filter predicates\nextension ZMUserTests_Swift {\n    func testThatPreviewImageDownloadFilterPicksUpUser() {\n        syncMOC.performGroupedBlockAndWait {\n            // GIVEN\n            let predicate = ZMUser.previewImageDownloadFilter\n            let user = ZMUser(remoteID: UUID.create(), createIfNeeded: true, in: self.syncMOC)\n            user?.previewProfileAssetIdentifier = \"some identifier\"\n            \n            // THEN\n            XCTAssert(predicate.evaluate(with: user))\n        }\n    }\n    \n    func testThatCompleteImageDownloadFilterPicksUpUser() {\n        syncMOC.performGroupedBlockAndWait {\n            // GIVEN\n            let predicate = ZMUser.completeImageDownloadFilter\n            let user = ZMUser(remoteID: UUID.create(), createIfNeeded: true, in: self.syncMOC)\n            user?.completeProfileAssetIdentifier = \"some identifier\"\n            user?.setImage(data: nil, size: .complete)\n            \n            // THEN\n            XCTAssert(predicate.evaluate(with: user))\n        }\n    }\n    \n    func testThatCompleteImageDownloadFilterDoesNotPickUpUsersWithoutAssetId() {\n        syncMOC.performGroupedBlockAndWait {\n            // GIVEN\n            let predicate = ZMUser.completeImageDownloadFilter\n            let user = ZMUser(remoteID: UUID.create(), createIfNeeded: true, in: self.syncMOC)\n            user?.completeProfileAssetIdentifier = nil\n            user?.setImage(data: \"foo\".data(using: .utf8), size: .complete)\n            \n            // THEN\n            XCTAssertFalse(predicate.evaluate(with: user))\n        }\n    }\n    \n    func testThatPreviewImageDownloadFilterDoesNotPickUpUsersWithCachedImages() {\n        syncMOC.performGroupedBlockAndWait {\n            // GIVEN\n            let predicate = ZMUser.completeImageDownloadFilter\n            let user = ZMUser(remoteID: UUID.create(), createIfNeeded: true, in: self.syncMOC)\n            user?.previewProfileAssetIdentifier = \"1234\"\n            user?.setImage(data: \"foo\".data(using: .utf8), size: .preview)\n            \n            // THEN\n            XCTAssertFalse(predicate.evaluate(with: user))\n        }\n    }\n    \n    func testThatCompleteImageDownloadFilterDoesNotPickUpUsersWithCachedImages() {\n        syncMOC.performGroupedBlockAndWait {\n            // GIVEN\n            let predicate = ZMUser.completeImageDownloadFilter\n            let user = ZMUser(remoteID: UUID.create(), createIfNeeded: true, in: self.syncMOC)\n            user?.completeProfileAssetIdentifier = \"1234\"\n            user?.setImage(data: \"foo\".data(using: .utf8), size: .complete)\n            \n            // THEN\n            XCTAssertFalse(predicate.evaluate(with: user))\n        }\n    }\n}\n\n// MARK: - AssetV3 request notifications\nextension ZMUserTests_Swift {\n    \n    func testThatItPostsPreviewRequestNotifications() {\n        let noteExpectation = expectation(description: \"PreviewAssetFetchNotification should be fired\")\n        var userObjectId: NSManagedObjectID? = nil\n        \n        let token = ManagedObjectObserverToken(name: .userDidRequestPreviewAsset,\n                                               managedObjectContext: self.uiMOC)\n        { note in\n            let objectId = note.object as? NSManagedObjectID\n            XCTAssertNotNil(objectId)\n            XCTAssertEqual(objectId, userObjectId)\n            noteExpectation.fulfill()\n        }\n\n        let user = ZMUser.insertNewObject(in: uiMOC)\n        user.remoteIdentifier = UUID.create()\n        userObjectId = user.objectID\n        user.requestPreviewProfileImage()\n        \n        withExtendedLifetime(token) { () -> () in\n            XCTAssertTrue(waitForAllGroupsToBeEmpty(withTimeout: 0.5))\n            XCTAssertTrue(waitForCustomExpectations(withTimeout: 0.5))\n        }\n    }\n    \n    func testThatItPostsCompleteRequestNotifications() {\n        let noteExpectation = expectation(description: \"CompleteAssetFetchNotification should be fired\")\n        var userObjectId: NSManagedObjectID? = nil\n        \n        let token = ManagedObjectObserverToken(name: .userDidRequestCompleteAsset,\n                                               managedObjectContext: self.uiMOC)\n        { note in\n            let objectId = note.object as? NSManagedObjectID\n            XCTAssertNotNil(objectId)\n            XCTAssertEqual(objectId, userObjectId)\n            noteExpectation.fulfill()\n        }\n        \n        let user =  ZMUser.insertNewObject(in: uiMOC)\n        user.remoteIdentifier = UUID.create()\n        userObjectId = user.objectID\n        user.requestCompleteProfileImage()\n        \n        withExtendedLifetime(token) { () -> () in\n            XCTAssertTrue(waitForAllGroupsToBeEmpty(withTimeout: 0.5))\n            XCTAssertTrue(waitForCustomExpectations(withTimeout: 0.5))\n        }\n    }\n}\n\nextension ZMUser {\n\n    @discardableResult\n    static func insert(in moc: NSManagedObjectContext, id: UUID = .create(), name: String, handle: String? = nil, connectionStatus: ZMConnectionStatus = .accepted) -> ZMUser {\n        let user = ZMUser.insertNewObject(in: moc)\n        user.remoteIdentifier = id\n        user.name = name\n        user.setHandle(handle)\n        let connection = ZMConnection.insertNewSentConnection(to: user)\n        connection?.status = connectionStatus\n\n        return user\n    }\n}\n\n// MARK: - Predicates\nextension ZMUserTests_Swift {\n    \n    func testPredicateFilteringConnectedUsersByHandle() {\n        // Given\n        let user1 = ZMUser.insert(in: self.uiMOC, name: \"Some body\", handle: \"yyy\", connectionStatus: .accepted)\n        let user2 = ZMUser.insert(in: self.uiMOC, name: \"No body\", handle: \"yes-b\", connectionStatus: .accepted)\n        \n        let all = NSArray(array: [user1, user2])\n        \n        // When\n        let users = all.filtered(using: ZMUser.predicateForConnectedUsers(withSearch: \"yyy\")) as! [ZMUser]\n        \n        // Then\n        XCTAssertEqual(users.count, 1)\n        XCTAssertEqual(users, [user1])\n    }\n\n    func testPredicateFilteringConnectedUsersByHandleWithAtSymbol() {\n        // Given\n        let user1 = ZMUser.insert(in: self.uiMOC, name: \"Some body\", handle: \"ab\", connectionStatus: .accepted)\n        let user2 = ZMUser.insert(in: self.uiMOC, name: \"No body\", handle: \"yes-b\", connectionStatus: .accepted)\n        \n        let all = NSArray(array: [user1, user2])\n        \n        // When\n        let users = all.filtered(using: ZMUser.predicateForConnectedUsers(withSearch: \"@ab\")) as! [ZMUser]\n        \n        // Then\n        XCTAssertEqual(users.count, 1)\n        XCTAssertEqual(users, [user1])\n    }\n\n    func testPredicateFilteringConnectedUsersByHandlePrefix() {\n        // Given\n        let user1 = ZMUser.insert(in: self.uiMOC, name: \"Some body\", handle: \"alonghandle\", connectionStatus: .accepted)\n        let user2 = ZMUser.insert(in: self.uiMOC, name: \"No body\", handle: \"yes-b\", connectionStatus: .accepted)\n        \n        let all = NSArray(array: [user1, user2])\n        \n        // When\n        let users = all.filtered(using: ZMUser.predicateForConnectedUsers(withSearch: \"alo\")) as! [ZMUser]\n        \n        // Then\n        XCTAssertEqual(users.count, 1)\n        XCTAssertEqual(users, [user1])\n    }\n    \n    func testPredicateFilteringConnectedUsersStripsDiactricMarks() {\n        // Given\n        let user1 = ZMUser.insert(in: self.uiMOC, name: \"\u0160\u0151m\u0117 body\", handle: \"hand\", connectionStatus: .accepted)\n        let user2 = ZMUser.insert(in: self.uiMOC, name: \"No body\", handle: \"yes-b\", connectionStatus: .accepted)\n        \n        let all = NSArray(array: [user1, user2])\n        \n        // When\n        let users = all.filtered(using: ZMUser.predicateForConnectedUsers(withSearch: \"some\")) as! [ZMUser]\n        \n        // Then\n        XCTAssertEqual(users.count, 1)\n        XCTAssertEqual(users, [user1])\n    }\n    \n    func testPredicateFilteringForAllUsers() {\n        // Given\n        let user1 = ZMUser.insert(in: self.uiMOC, name: \"Some body\", handle: \"ab\", connectionStatus: .accepted)\n        let user2 = ZMUser.insert(in: self.uiMOC, name: \"No body\", handle: \"no-b\", connectionStatus: .accepted)\n        let user3 = ZMUser.insert(in: self.uiMOC, name: \"Yes body\", handle: \"yes-b\", connectionStatus: .pending)\n\n        let all = NSArray(array: [user1, user2, user3])\n        \n        // When\n        let users = all.filtered(using: ZMUser.predicateForAllUsers(withSearch: \"body\")) as! [ZMUser]\n        \n        // Then\n        XCTAssertEqual(users.count, 3)\n        XCTAssertEqual(users, [user1, user2, user3])\n    }\n    \n}\n\n// MARK: - Filename\nextension ZMUserTests_Swift {\n    \n    /// check the generated filename matches several critirias and a regex pattern\n    ///\n    /// - Parameters:\n    ///   - pattern: pattern string for regex\n    ///   - filename: filename to check\n    func checkFilenameIsValid(pattern: String, filename: String) {\n        XCTAssertEqual(filename.count, 214)\n        XCTAssertTrue(filename.hasPrefix(\"Some\"))\n        XCTAssertTrue(filename.contains(\"body\"))\n\n        let regexp = try! NSRegularExpression(pattern: pattern, options: [])\n        let matches = regexp.matches(in: filename as String, options: [], range: NSMakeRange(0, filename.count))\n        \n        XCTAssertTrue(matches.count > 0)\n    }\n    \n    func testFilenameForUser() throws {\n        // Given\n        let user = ZMUser.insert(in: self.uiMOC, name: \"Some body with a very long name and a emoji \ud83c\udded\ud83c\uddf0 and some Chinese \u4e2d\u6587 and some German Fu\u00dfg\u00e4nger\u00fcberg\u00e4nge\")\n        \n        // When\n        let filename = user.filename()\n        \n        // Then\n        /// check ends with a date stamp, e.g. -2017-10-24-11.05.43\n        let pattern = \"^.*[0-9-.]{20,20}$\"\n        checkFilenameIsValid(pattern: pattern, filename: filename)\n    }\n\n    func testFilenameWithSuffixForUser() throws {\n        // Given\n        let user = ZMUser.insert(in: self.uiMOC, name: \"Some body with a very long name and a emoji \ud83c\udded\ud83c\uddf0 and some Chinese \u4e2d\u6587 and some German Fu\u00dfg\u00e4nger\u00fcberg\u00e4nge\")\n        \n        // When\n        let suffix: String = \"-Jellyfish\"\n        let filename = user.filename(suffix: suffix)\n        \n        // Then\n        /// check ends with a date stamp and a suffix, e.g. -2017-10-24-11.05.43-Jellyfish\n        let pattern = \"^.*[0-9-.]{20,20}\\(suffix)$\"\n        checkFilenameIsValid(pattern: pattern, filename: filename)\n    }\n}\n\n// MARK: - Availability\nextension ZMUserTests_Swift {\n    \n    func testThatWeCanUpdateAvailabilityFromGenericMessage() {\n        // given\n        let user = ZMUser.insert(in: self.uiMOC, name: \"Foo\")\n        XCTAssertEqual(user.availability, .none)\n        let availability = WireProtos.Availability(.away)\n        // when\n        user.updateAvailability(from: GenericMessage(content: availability))\n        \n        // then\n        XCTAssertEqual(user.availability, .away)\n    }\n    \n    func testThatWeAllowModifyingAvailabilityOnTheSelfUser() {\n        // given\n        XCTAssertEqual(selfUser.availability, .none)\n        \n        // when\n        selfUser.availability = .away\n        \n        // then\n        XCTAssertEqual(selfUser.availability, .away)\n    }\n    \n    func testThatWeDontAllowModifyingAvailabilityOnOtherUsers() {\n        // given\n        let user = ZMUser.insert(in: self.uiMOC, name: \"Foo\")\n        XCTAssertEqual(user.availability, .none)\n        \n        // when\n        user.availability = .away\n        \n        // then\n        XCTAssertEqual(user.availability, .none)\n    }\n\n    func testThatNeedsToNotifyAvailabilityBehaviourChangeDefaultsToNothing() {\n        XCTAssertEqual(selfUser.needsToNotifyAvailabilityBehaviourChange, [])\n    }\n    \n    func testThatNeedsToNotifyAvailabilityBehaviourChangeCanBeUpdated() {\n        // given\n        selfUser.needsToNotifyAvailabilityBehaviourChange = .alert\n        \n        // then\n        XCTAssertEqual(selfUser.needsToNotifyAvailabilityBehaviourChange, .alert)\n    }\n        \n}\n\n// MARK: - Broadcast Recipients\n\nextension ZMUserTests_Swift {\n\n    func testThatItReturnsAllKnownTeamUsers() {\n        // given\n        let selfTeam = createTeam(in: uiMOC)\n        createMembership(in: uiMOC, user: selfUser, team: selfTeam)\n\n        // fellow team members\n        createUserAndAddMember(to: selfTeam)\n        createUserAndAddMember(to: selfTeam)\n\n        let otherTeam = createTeam(in: uiMOC)\n\n        // other team users but not connected\n        createUserAndAddMember(to: otherTeam)\n        createUserAndAddMember(to: otherTeam)\n\n        // other team users and connected\n        let (connectedTeamUser1, _) = createUserAndAddMember(to: otherTeam)\n        let (connectedTeamUser2, _) = createUserAndAddMember(to: otherTeam)\n\n        // non team users but connected\n        let connectedUser1 = createUser(in: uiMOC)\n        let connectedUser2 = createUser(in: uiMOC)\n\n        let usersToConnect = [connectedUser1, connectedUser2, connectedTeamUser1, connectedTeamUser2]\n\n        for user in usersToConnect {\n            let connection = ZMConnection.insertNewSentConnection(to: user)\n            connection?.status = .accepted\n        }\n\n        // when\n        let knownTeamUsers = ZMUser.knownTeamUsers(in: uiMOC)\n\n        // then\n        XCTAssertEqual(knownTeamUsers, Set([connectedTeamUser1, connectedTeamUser2]))\n    }\n\n\n    func testThatItReturnsOnlyKnownTeamUsersWithAcceptedConnections() {\n        // given\n        let selfTeam = createTeam(in: uiMOC)\n        createMembership(in: uiMOC, user: selfUser, team: selfTeam)\n\n        let otherTeam = createTeam(in: uiMOC)\n\n        // other team users with accepted connections\n        let (connectedTeamUser1, _) = createUserAndAddMember(to: otherTeam)\n        let (connectedTeamUser2, _) = createUserAndAddMember(to: otherTeam)\n\n        let usersToConnect = [connectedTeamUser1, connectedTeamUser2]\n\n        for user in usersToConnect {\n            let connection = ZMConnection.insertNewSentConnection(to: user)\n            connection?.status = .accepted\n        }\n\n        // other team users with unaccepted connections\n        for connectionStatus in [ZMConnectionStatus.pending, .blocked, .cancelled, .ignored, .sent, .invalid] {\n            let (user, _) = createUserAndAddMember(to: otherTeam)\n            let connection = ZMConnection.insertNewSentConnection(to: user)\n            connection?.status = connectionStatus\n        }\n\n        // when\n        let knownTeamUsers = ZMUser.knownTeamUsers(in: uiMOC)\n\n        // then\n        XCTAssertEqual(knownTeamUsers, Set([connectedTeamUser1, connectedTeamUser2]))\n    }\n\n    func testThatItReturnsAllKnownTeamMembers() {\n        // given\n        let selfUserTeam = createTeam(in: uiMOC)\n        createMembership(in: uiMOC, user: selfUser, team: selfUserTeam)\n\n        let (selfTeamUser1, _) = createUserAndAddMember(to: selfUserTeam)\n        let (selfTeamUser2, _) = createUserAndAddMember(to: selfUserTeam)\n        let (selfTeamUser3, _) = createUserAndAddMember(to: selfUserTeam)\n\n        _ = ZMUser.insert(in: uiMOC, name: \"1\", handle: \"1\", connectionStatus: .accepted)\n\n        let otherTeam = createTeam(in: uiMOC)\n        let (otherTeamUser, _) = createUserAndAddMember(to: otherTeam)\n\n        createConversation(in: uiMOC, with: [selfUser, selfTeamUser1])\n        createConversation(in: uiMOC, with: [selfUser, selfTeamUser2])\n        createConversation(in: uiMOC, with: [selfTeamUser2, selfTeamUser3])\n        createConversation(in: uiMOC, with: [selfUser, otherTeamUser])\n\n        // when\n        let knownTeamMembers = ZMUser.knownTeamMembers(in: uiMOC)\n\n        // then\n        XCTAssertEqual(knownTeamMembers, Set([selfTeamUser1, selfTeamUser2]))\n    }\n\n    func testThatReturnsExpectedRecipientsForBroadcast() {\n        // given\n        let selfUserTeam = createTeam(in: uiMOC)\n        createMembership(in: uiMOC, user: selfUser, team: selfUserTeam)\n\n        let (selfTeamUser1, _) = createUserAndAddMember(to: selfUserTeam)\n        let (selfTeamUser2, _) = createUserAndAddMember(to: selfUserTeam)\n        let (selfTeamUser3, _) = createUserAndAddMember(to: selfUserTeam)\n\n        let otherTeam = createTeam(in: uiMOC)\n\n        // unconnected other team users\n        createUserAndAddMember(to: otherTeam)\n        createUserAndAddMember(to: otherTeam)\n\n        let (connectedTeamUser1, _) = createUserAndAddMember(to: otherTeam)\n        let (connectedTeamUser2, _) = createUserAndAddMember(to: otherTeam)\n\n        let usersToConnect = [connectedTeamUser1, connectedTeamUser2]\n\n        for user in usersToConnect {\n            let connection = ZMConnection.insertNewSentConnection(to: user)\n            connection?.status = .accepted\n        }\n\n        createConversation(in: uiMOC, with: [selfUser, selfTeamUser1])\n        createConversation(in: uiMOC, with: [selfUser, selfTeamUser2])\n        createConversation(in: uiMOC, with: [selfTeamUser2, selfTeamUser3])\n        createConversation(in: uiMOC, with: [selfUser, connectedTeamUser1])\n\n        // when\n        let recipients = ZMUser.recipientsForAvailabilityStatusBroadcast(in: uiMOC, maxCount: 50)\n\n        // then\n        XCTAssertEqual(recipients, Set([selfUser, selfTeamUser1, selfTeamUser2, connectedTeamUser1, connectedTeamUser2]))\n    }\n\n    func testThatItReturnsRecipientsForBroadcastUpToAMaximumCount() {\n        // given\n        let selfUserTeam = createTeam(in: uiMOC)\n        createMembership(in: uiMOC, user: selfUser, team: selfUserTeam)\n\n        let (selfTeamUser1, _) = createUserAndAddMember(to: selfUserTeam)\n        let (selfTeamUser2, _) = createUserAndAddMember(to: selfUserTeam)\n        let (selfTeamUser3, _) = createUserAndAddMember(to: selfUserTeam)\n\n        let allRecipients = [\n            selfUser!,\n            selfTeamUser1,\n            selfTeamUser2,\n            selfTeamUser3\n        ]\n\n        createConversation(in: uiMOC, with: allRecipients)\n\n        // when\n        let recipients = ZMUser.recipientsForAvailabilityStatusBroadcast(in: uiMOC, maxCount: 3)\n\n        // then\n        XCTAssertEqual(recipients.count, 3)\n    }\n\n    func testThatItPrioritiesTeamMembersOverOtherTeamUsersForBroadcast() {\n        // given\n        let selfUserTeam = createTeam(in: uiMOC)\n        createMembership(in: uiMOC, user: selfUser, team: selfUserTeam)\n\n        let (selfTeamUser1, _) = createUserAndAddMember(to: selfUserTeam)\n        let (selfTeamUser2, _) = createUserAndAddMember(to: selfUserTeam)\n\n        let otherTeam = createTeam(in: uiMOC)\n\n        let (connectedTeamUser1, _) = createUserAndAddMember(to: otherTeam)\n        let (connectedTeamUser2, _) = createUserAndAddMember(to: otherTeam)\n\n        let usersToConnect = [connectedTeamUser1, connectedTeamUser2]\n\n        for user in usersToConnect {\n            let connection = ZMConnection.insertNewSentConnection(to: user)\n            connection?.status = .accepted\n        }\n\n        let allRecipients = [\n            selfUser!,\n            selfTeamUser1,\n            selfTeamUser2,\n            connectedTeamUser1,\n            connectedTeamUser2\n        ]\n\n        createConversation(in: uiMOC, with: allRecipients)\n\n        // when\n        let recipients = ZMUser.recipientsForAvailabilityStatusBroadcast(in: uiMOC, maxCount: 3)\n\n        // then\n        XCTAssertEqual(recipients, Set([selfUser, selfTeamUser1, selfTeamUser2]))\n    }\n\n    func testThatItRecipientsForBroadcastIsDeterministic() {\n        // given\n        let selfUserTeam = createTeam(in: uiMOC)\n        createMembership(in: uiMOC, user: selfUser, team: selfUserTeam)\n\n        let (teamUser1, _) = createUserAndAddMember(to: selfUserTeam)\n        let (teamUser2, _) = createUserAndAddMember(to: selfUserTeam)\n        let (teamUser3, _) = createUserAndAddMember(to: selfUserTeam)\n        let (teamUser4, _) = createUserAndAddMember(to: selfUserTeam)\n\n        let allRecipients = [\n            selfUser!,\n            teamUser1,\n            teamUser2,\n            teamUser3,\n            teamUser4\n        ]\n\n        createConversation(in: uiMOC, with: allRecipients)\n\n        // when\n        let recipients = ZMUser.recipientsForAvailabilityStatusBroadcast(in: uiMOC, maxCount: 3)\n\n        // then\n        let expectedRecipients = allRecipients.sorted {\n            $0.remoteIdentifier.transportString() < $1.remoteIdentifier.transportString()\n        }.prefix(3)\n\n        XCTAssertEqual(recipients, Set(expectedRecipients))\n    }\n\n}\n\n// MARK: - Bot support\nextension ZMUserTests_Swift {\n    func testThatServiceIdentifierAndProviderIdentifierAreNilByDefault() {\n        // GIVEN\n        let sut = ZMUser.insertNewObject(in: self.uiMOC)\n\n        // WHEN & THEN\n        XCTAssertNil(sut.providerIdentifier)\n        XCTAssertNil(sut.serviceIdentifier)\n    }\n}\n\n// MARK: - Expiration support\nextension ZMUserTests_Swift {\n    func testIsWirelessUserCalculation_false() {\n        // given\n        let sut = ZMUser.insertNewObject(in: self.uiMOC)\n        // when & then\n        XCTAssertFalse(sut.isWirelessUser)\n        XCTAssertFalse(sut.isExpired)\n        XCTAssertEqual(sut.expiresAfter, 0)\n    }\n    \n    func testIsWirelessUserCalculation_true_not_expired() {\n        // given\n        let sut = ZMUser.insertNewObject(in: self.uiMOC)\n        sut.expiresAt = Date(timeIntervalSinceNow: 1)\n        // when & then\n        XCTAssertTrue(sut.isWirelessUser)\n        XCTAssertFalse(sut.isExpired)\n        XCTAssertEqual(round(sut.expiresAfter), 1)\n    }\n    \n    func testIsWirelessUserCalculation_true_expired() {\n        // given\n        let sut = ZMUser.insertNewObject(in: self.uiMOC)\n        sut.expiresAt = Date(timeIntervalSinceNow: -1)\n        // when & then\n        XCTAssertTrue(sut.isWirelessUser)\n        XCTAssertTrue(sut.isExpired)\n        XCTAssertEqual(round(sut.expiresAfter), 0)\n    }\n}\n\n// MARK: - Account deletion\n\nextension ZMUserTests_Swift {\n    \n    func testThatUserIsRemovedFromAllConversationsWhenAccountIsDeleted() {\n        // given\n        let sut = createUser(in: uiMOC)\n        let conversation1 = createConversation(in: uiMOC)\n        conversation1.conversationType = .group\n        conversation1.addParticipantAndUpdateConversationState(user: sut, role: nil)\n        \n        let conversation2 = createConversation(in: uiMOC)\n        conversation2.conversationType = .group\n        conversation2.addParticipantAndUpdateConversationState(user: sut, role: nil)\n        \n        // when\n        sut.markAccountAsDeleted(at: Date())\n        \n        // then\n        XCTAssertNil(conversation1.participantRoles.first(where: { $0.user == sut })) //FIXME -> It was XCTAssertNotNil\n        XCTAssertNil(conversation2.participantRoles.first(where: { $0.user == sut })) //FIXME -> It was XCTAssertNotNil\n    }\n    \n    func testThatUserIsNotRemovedFromTeamOneToOneConversationsWhenAccountIsDeleted() {\n        // given\n        let team = createTeam(in: uiMOC)\n        let sut = createTeamMember(in: uiMOC, for: team)\n        let teamOneToOneConversation = ZMConversation.fetchOrCreateOneToOneTeamConversation(moc: uiMOC, participant: sut, team: team)!\n        teamOneToOneConversation.teamRemoteIdentifier = team.remoteIdentifier\n        \n        // when\n        sut.markAccountAsDeleted(at: Date())\n        \n        // then\n        XCTAssertTrue(teamOneToOneConversation.localParticipants.contains(sut))\n    }\n    \n}\n\n// MARK: - Active conversations\n\nextension ZMUserTests_Swift {\n    \n    func testActiveConversationsForSelfUser() {\n        // given\n        let sut = ZMUser.selfUser(in: uiMOC)\n        let conversation = ZMConversation.insertNewObject(in: uiMOC)\n        conversation.addParticipantAndUpdateConversationState(user: sut, role: nil)\n        let selfConversation = ZMConversation.fetch(withRemoteIdentifier: self.selfUser.remoteIdentifier, in: uiMOC)\n        \n        // then\n        XCTAssertEqual(sut.activeConversations, [conversation, selfConversation])\n    }\n    \n    func testActiveConversationsForOtherUser() {\n        // given\n        let sut = ZMUser.insertNewObject(in: uiMOC)\n        let conversation = ZMConversation.insertNewObject(in: uiMOC)\n        conversation.addParticipantAndUpdateConversationState(user: sut, role: nil)\n        \n        // then\n        XCTAssertEqual(sut.activeConversations, Set(arrayLiteral: conversation))\n    }\n    \n}\n\n// MARK: - Self user tests\nextension ZMUserTests_Swift {\n    func testThatItIsPossibleToSetReadReceiptsEnabled() {\n        // GIVEN\n        let sut = ZMUser.selfUser(in: uiMOC)\n        // WHEN\n        sut.readReceiptsEnabled = true\n        // THEN\n        XCTAssertEqual(sut.readReceiptsEnabled, true)\n    }\n    \n    func testThatItIsPossibleToSetReadReceiptsEnabled_andReset() {\n        // GIVEN\n        let sut = ZMUser.selfUser(in: uiMOC)\n        // WHEN\n        sut.readReceiptsEnabled = true\n        // THEN\n        XCTAssertEqual(sut.readReceiptsEnabled, true)\n        // AND WHEN\n        sut.readReceiptsEnabled = false\n        // THEN\n        XCTAssertEqual(sut.readReceiptsEnabled, false)\n    }\n    \n    func testThatItUpdatesOtherContextForEnableReadReceipts() {\n        // GIVEN\n        let sut = ZMUser.selfUser(in: uiMOC)\n        // WHEN\n        sut.readReceiptsEnabled = true\n        self.uiMOC.saveOrRollback()\n        \n        // THEN\n        \n        self.syncMOC.performGroupedBlock {\n            let syncSelfUser = ZMUser.selfUser(in: self.syncMOC)\n\n            XCTAssertEqual(syncSelfUser.readReceiptsEnabled, true)\n        }\n        \n        XCTAssertTrue(self.waitForAllGroupsToBeEmpty(withTimeout: 0.5))\n    }\n    \n    func testThatItSetsModifiedKeysForEnableReadReceipts() {\n        // GIVEN\n        let sut = ZMUser.selfUser(in: uiMOC)\n        sut.resetLocallyModifiedKeys(Set())\n        \n        // WHEN\n        sut.readReceiptsEnabled = true\n        \n        uiMOC.saveOrRollback()\n\n        // THEN\n        XCTAssertEqual(sut.modifiedKeys, Set([ReadReceiptsEnabledKey]))\n    }\n    \n    func testThatItDoesNotSetModifiedKeysForEnableReadReceipts() {\n        self.syncMOC.performGroupedAndWait { _ in\n            // GIVEN\n            let sut = ZMUser.selfUser(in: self.syncMOC)\n            sut.resetLocallyModifiedKeys(Set())\n            \n            // WHEN\n            sut.readReceiptsEnabled = true\n            self.syncMOC.saveOrRollback()\n\n            // THEN\n            XCTAssertEqual(sut.modifiedKeys, nil)\n        }\n    }\n    \n    func testThatItSavesValueOfReadReceiptsEnabled() {\n        // GIVEN\n        let user = ZMUser.selfUser(in: uiMOC)\n        // WHEN\n        user.readReceiptsEnabled = true\n        uiMOC.saveOrRollback()\n        // THEN\n        XCTAssert(user.readReceiptsEnabled)\n    }\n}\n\n// MARK: - Verifying user\nextension ZMUserTests_Swift {\n    \n    func testThatUserIsVerified_WhenSelfUserAndUserIsTrusted() {\n        // GIVEN\n        let user: ZMUser = self.userWithClients(count: 2, trusted: true)\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n        \n        // WHEN\n        XCTAssertTrue(user.isTrusted)\n        XCTAssertTrue(selfUser.isTrusted)\n        \n        // THEN\n        XCTAssertTrue(user.isVerified)\n    }\n    \n    func testThatUserIsNotVerified_WhenSelfUserIsNotTrustedButUserIsTrusted() {\n        // GIVEN\n        let user: ZMUser = self.userWithClients(count: 2, trusted: true)\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n        let selfClient: UserClient? = selfUser.selfClient()\n        \n        // WHEN\n        let newClient: UserClient = UserClient.insertNewObject(in: self.uiMOC)\n        newClient.user = selfUser\n        selfClient?.ignoreClient(newClient)\n        \n        // THEN\n        XCTAssertTrue(user.isTrusted)\n        XCTAssertFalse(selfUser.isTrusted)\n        XCTAssertFalse(user.isVerified)\n    }\n\n}\n"], "fixing_code": ["//\n// Wire\n// Copyright (C) 2017 Wire Swiss GmbH\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see http://www.gnu.org/licenses/.\n//\n\nimport Foundation\nimport WireUtilities\nimport WireSystem\n\nextension ZMUser: UserType {\n    @objc\n    public var hasTeam: Bool {\n        /// Other users won't have a team object, but a teamIdentifier.\n        return nil != team || nil != teamIdentifier\n    }\n\n    /// Whether all user's devices are verified by the selfUser\n    public var isTrusted: Bool {\n        let selfUser = managedObjectContext.map(ZMUser.selfUser)\n        let selfClient = selfUser?.selfClient()\n        let hasUntrustedClients = self.clients.contains(where: { ($0 != selfClient) && !(selfClient?.trustedClients.contains($0) ?? false) })\n        \n        return !hasUntrustedClients\n    }\n    \n    public func isGuest(in conversation: ConversationLike) -> Bool {\n        return _isGuest(in: conversation)\n    }\n    \n    public var teamName: String? {\n        return team?.name\n    }\n    \n    public var hasDigitalSignatureEnabled: Bool {\n        return team?.fetchFeatureFlag(with: .digitalSignature)?.isEnabled ?? false\n    }\n    \n    public var previewImageData: Data? {\n        return imageSmallProfileData\n    }\n    \n    public var completeImageData: Data? {\n        return imageMediumData\n    }\n    \n    public var activeConversations: Set<ZMConversation> {\n        return Set(self.participantRoles.compactMap {$0.conversation})\n    }\n    \n    public var isVerified: Bool {\n        guard let selfUser = managedObjectContext.map(ZMUser.selfUser) else {\n            return false\n        }\n        return isTrusted && selfUser.isTrusted && !clients.isEmpty\n    }\n\n    public var isFederated: Bool {\n        guard let selfUser = managedObjectContext.map(ZMUser.selfUser) else {\n            return false\n        }\n\n        return selfUser.isFederating(with: self)\n    }\n\n    // MARK: - Conversation Roles\n\n    public func canManagedGroupRole(of user: UserType, conversation: ZMConversation) -> Bool {\n        guard isGroupAdmin(in: conversation) else { return false }\n        return !user.isSelfUser && (user.isConnected || isOnSameTeam(otherUser: user))\n    }\n\n    public func isGroupAdmin(in conversation: ConversationLike) -> Bool {\n        return role(in: conversation)?.name == ZMConversation.defaultAdminRoleName\n    }\n\n    public func role(in conversation: ConversationLike?) -> Role? {\n        return participantRoles.first(where: { $0.conversation === conversation })?.role\n    }\n\n    // MARK: Legal Hold\n\n    @objc public var isUnderLegalHold: Bool {\n        return clients.any(\\.isLegalHoldDevice)\n    }\n\n    @objc class func keyPathsForValuesAffectingIsUnderLegalHold() -> Set<String> {\n        return [UserClientsKey, \"clients.deviceClass\"]\n    }\n    \n    public var allClients: [UserClientType] {\n        return Array(clients)\n    }\n\n    // MARK: - Data refresh requests\n\n    public func refreshRichProfile() {\n        needsRichProfileUpdate = true\n    }\n\n    public func refreshMembership() {\n        membership?.needsToBeUpdatedFromBackend = true\n    }\n\n    public func refreshTeamData() {\n        team?.refreshMetadata()\n    }\n    \n}\n\npublic struct AssetKey {\n    \n    static let legalCharacterSet = CharacterSet.alphanumerics.union(CharacterSet.punctuationCharacters)\n    \n    public init?(_ string: String) {\n        if AssetKey.validate(string: string) {\n            stringValue = string\n        } else {\n            return nil\n        }\n    }\n    \n    let stringValue : String\n    \n    fileprivate static func validate(string : String) -> Bool {\n        return CharacterSet(charactersIn: string).isSubset(of: legalCharacterSet)\n    }\n}\n\n@objc public enum ProfileImageSize: Int {\n    case preview\n    case complete\n    \n    public var imageFormat: ZMImageFormat {\n        switch self {\n        case .preview:\n            return .profile\n        case .complete:\n            return .medium\n        }\n    }\n\n    public init?(stringValue: String) {\n        switch stringValue {\n        case ProfileImageSize.preview.stringValue: self = .preview\n        case ProfileImageSize.complete.stringValue: self = .complete\n        default: return nil\n        }\n    }\n\n    var stringValue: String {\n        switch self {\n        case .preview: return \"preview\"\n        case .complete: return \"complete\"\n        }\n    }\n    \n    public static var allSizes: [ProfileImageSize] {\n        return [.preview, .complete]\n    }\n}\n\nextension ProfileImageSize: CustomDebugStringConvertible {\n     public var debugDescription: String {\n        switch self {\n        case .preview:\n            return \"ProfileImageSize.preview\"\n        case .complete:\n            return \"ProfileImageSize.complete\"\n        }\n    }\n}\n\nextension ZMUser: ServiceUser {\n    @NSManaged public var providerIdentifier: String?\n    @NSManaged public var serviceIdentifier: String?\n}\n\npublic extension Notification.Name {\n    static let userDidRequestPreviewAsset = Notification.Name(\"UserDidRequestPreviewAsset\")\n    static let userDidRequestCompleteAsset = Notification.Name(\"UserDidRequestCompleteAsset\")\n}\n\nextension ZMUser {\n    \n    @objc static let previewProfileAssetIdentifierKey = #keyPath(ZMUser.previewProfileAssetIdentifier)\n    @objc static let completeProfileAssetIdentifierKey = #keyPath(ZMUser.completeProfileAssetIdentifier)\n\n    @NSManaged public var previewProfileAssetIdentifier: String?\n    @NSManaged public var completeProfileAssetIdentifier: String?\n    \n    /// Conversations created by this user\n    @NSManaged var conversationsCreated: Set<ZMConversation>\n    \n    /// Team membership for this user\n    @NSManaged public internal(set) var membership: Member?\n\n    /// Reactions expressed by this user\n    @NSManaged var reactions: Set<Reaction>\n    \n    /// System messages referencing this user\n    @NSManaged var systemMessages: Set<ZMSystemMessage>\n    \n    @NSManaged var expiresAt: Date?\n    \n    /// `accountIsDeleted` is true if this account has been deleted on the backend\n    @NSManaged public internal(set) var isAccountDeleted: Bool\n    \n    @NSManaged public var usesCompanyLogin: Bool\n    \n    /// If `needsToRefetchLabels` is true we need to refetch the conversation labels (favorites & folders)\n    @NSManaged public var needsToRefetchLabels: Bool\n    \n    @NSManaged public var domain: String?\n    \n    @objc(setImageData:size:)\n    public func setImage(data: Data?, size: ProfileImageSize) {\n        guard let imageData = data else {\n            managedObjectContext?.zm_userImageCache?.removeAllUserImages(self)\n            return\n        }\n        managedObjectContext?.zm_userImageCache?.setUserImage(self, imageData: imageData, size: size)\n        \n        if let uiContext = managedObjectContext?.zm_userInterface {\n            let changedKey = size == .preview ? #keyPath(ZMUser.previewImageData) : #keyPath(ZMUser.completeImageData)\n            NotificationDispatcher.notifyNonCoreDataChanges(objectID: objectID, changedKeys: [changedKey], uiContext: uiContext)\n        }\n    }\n    \n    public func imageData(for size: ProfileImageSize, queue: DispatchQueue, completion: @escaping (_ imageData: Data?) -> Void) {\n        managedObjectContext?.zm_userImageCache?.userImage(self, size: size, queue: queue, completion: completion)\n    }\n    \n    @objc(imageDataforSize:)\n    public func imageData(for size: ProfileImageSize) -> Data? {\n        return managedObjectContext?.zm_userImageCache?.userImage(self, size: size)\n    }\n    \n    public static var previewImageDownloadFilter: NSPredicate {\n        let assetIdExists = NSPredicate(format: \"(%K != nil)\", ZMUser.previewProfileAssetIdentifierKey)\n        let assetIdIsValid = NSPredicate { (user, _) -> Bool in\n            guard let user = user as? ZMUser else { return false }\n            return user.previewProfileAssetIdentifier?.isValidAssetID ?? false\n        }\n        let notCached = NSPredicate() { (user, _) -> Bool in\n            guard let user = user as? ZMUser else { return false }\n            return user.imageSmallProfileData == nil\n        }\n        return NSCompoundPredicate(andPredicateWithSubpredicates: [assetIdExists, assetIdIsValid, notCached])\n    }\n\n    public static var completeImageDownloadFilter: NSPredicate {\n        let assetIdExists = NSPredicate(format: \"(%K != nil)\", ZMUser.completeProfileAssetIdentifierKey)\n        let assetIdIsValid = NSPredicate { (user, _) -> Bool in\n            guard let user = user as? ZMUser else { return false }\n            return user.completeProfileAssetIdentifier?.isValidAssetID ?? false\n        }\n        let notCached = NSPredicate() { (user, _) -> Bool in\n            guard let user = user as? ZMUser else { return false }\n            return user.imageMediumData == nil\n        }\n        return NSCompoundPredicate(andPredicateWithSubpredicates: [assetIdExists, assetIdIsValid, notCached])\n    }\n    \n    public func updateAndSyncProfileAssetIdentifiers(previewIdentifier: String, completeIdentifier: String) {\n        guard isSelfUser else { return }\n        previewProfileAssetIdentifier = previewIdentifier\n        completeProfileAssetIdentifier = completeIdentifier\n        setLocallyModifiedKeys([ZMUser.previewProfileAssetIdentifierKey, ZMUser.completeProfileAssetIdentifierKey])\n    }\n    \n    @objc public func updateAssetData(with assets: NSArray?, authoritative: Bool) {\n        guard !hasLocalModifications(forKeys: [ZMUser.previewProfileAssetIdentifierKey, ZMUser.completeProfileAssetIdentifierKey]) else { return }\n        guard let assets = assets as? [[String : String]], !assets.isEmpty else {\n            if authoritative {\n                previewProfileAssetIdentifier = nil\n                completeProfileAssetIdentifier = nil\n            }\n            return\n        }\n        for data in assets {\n            if let size = data[\"size\"].flatMap(ProfileImageSize.init), let key = data[\"key\"].flatMap(AssetKey.init) {\n                switch size {\n                case .preview:\n                    if key.stringValue != previewProfileAssetIdentifier {\n                        previewProfileAssetIdentifier = key.stringValue\n                    }\n                case .complete:\n                    if key.stringValue != completeProfileAssetIdentifier {\n                        completeProfileAssetIdentifier = key.stringValue\n                    }\n                }\n            }\n        }\n    }\n    \n    @objc public func requestPreviewProfileImage() {\n        guard let moc = self.managedObjectContext, moc.zm_isUserInterfaceContext, !moc.zm_userImageCache.hasUserImage(self, size: .preview) else { return }\n        \n        NotificationInContext(name: .userDidRequestPreviewAsset,\n                              context: moc.notificationContext,\n                              object: self.objectID).post()\n    }\n    \n    @objc public func requestCompleteProfileImage() {\n        guard let moc = self.managedObjectContext, moc.zm_isUserInterfaceContext, !moc.zm_userImageCache.hasUserImage(self, size: .complete) else { return }\n        \n        NotificationInContext(name: .userDidRequestCompleteAsset,\n                              context: moc.notificationContext,\n                              object: self.objectID).post()\n    }\n    \n    /// Mark the user's account as having been deleted. This will also remove the user from any conversations he/she\n    /// is still a participant of.\n    @objc public func markAccountAsDeleted(at timestamp: Date) {\n        isAccountDeleted = true\n        removeFromAllConversations(at: timestamp)\n    }\n    \n    /// Remove user from all group conversations he is a participant of\n    fileprivate func removeFromAllConversations(at timestamp: Date) {\n        let allGroupConversations: [ZMConversation] = participantRoles.compactMap {\n            guard let convo = $0.conversation,\n                convo.conversationType == .group else { return nil}\n            return convo\n        }\n        \n        allGroupConversations.forEach { conversation in\n            if isTeamMember && conversation.team == team {\n                conversation.appendTeamMemberRemovedSystemMessage(user: self, at: timestamp)\n            } else {\n                conversation.appendParticipantRemovedSystemMessage(user: self, at: timestamp)\n            }\n            conversation.removeParticipantAndUpdateConversationState(user: self, initiatingUser: self)\n        }\n    }\n}\n\nextension ZMUser {\n    // MARK: - Participant role\n    \n    @objc\n    public var conversations: Set<ZMConversation> {\n        return Set(participantRoles.compactMap{ return $0.conversation })\n    }\n}\n\nextension NSManagedObject: SafeForLoggingStringConvertible {\n    public var safeForLoggingDescription: String {\n        let moc: String = self.managedObjectContext?.description ?? \"nil\"\n        \n        return \"\\(type(of: self)) \\(Unmanaged.passUnretained(self).toOpaque()): moc=\\(moc) objectID=\\(self.objectID)\"\n    }\n}\n\nextension ZMUser {\n    \n    /// The initials e.g. \"JS\" for \"John Smith\"\n    @objc public var initials: String? {\n        return PersonName.person(withName: self.name ?? \"\", schemeTagger: nil).initials\n    }\n}\n\n", "//\n// Wire\n// Copyright (C) 2017 Wire Swiss GmbH\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see http://www.gnu.org/licenses/.\n//\n\nimport Foundation\n@testable import WireDataModel\n\n// MARK: - Modified keys for profile picture upload\nfinal class ZMUserTests_Swift: ModelObjectsTests {\n    func testThatSettingUserProfileAssetIdentifiersDirectlyDoesNotMarkAsModified() {\n        // GIVEN\n        let user = ZMUser.selfUser(in: uiMOC)\n        \n        // WHEN\n        user.previewProfileAssetIdentifier = \"foo\"\n        user.completeProfileAssetIdentifier = \"bar\"\n\n        // THEN\n        XCTAssertFalse(user.hasLocalModifications(forKey: #keyPath(ZMUser.previewProfileAssetIdentifier)))\n        XCTAssertFalse(user.hasLocalModifications(forKey: #keyPath(ZMUser.completeProfileAssetIdentifier)))\n    }\n\n    \n    func testThatSettingUserProfileAssetIdentifiersMarksKeysAsModified() {\n        // GIVEN\n        let user = ZMUser.selfUser(in: uiMOC)\n        \n        // WHEN\n        user.updateAndSyncProfileAssetIdentifiers(previewIdentifier: \"foo\", completeIdentifier: \"bar\")\n        \n        // THEN\n        XCTAssert(user.hasLocalModifications(forKey: #keyPath(ZMUser.previewProfileAssetIdentifier)))\n        XCTAssert(user.hasLocalModifications(forKey: #keyPath(ZMUser.completeProfileAssetIdentifier)))\n    }\n    \n    func testThatSettingUserProfileAssetIdentifiersDoNothingForNonSelfUsers() {\n        // GIVEN\n        let initialPreview = \"123456\"\n        let initialComplete = \"987654\"\n        let user = ZMUser.insertNewObject(in: uiMOC)\n        user.previewProfileAssetIdentifier = initialPreview\n        user.completeProfileAssetIdentifier = initialComplete\n        \n        // WHEN\n        user.updateAndSyncProfileAssetIdentifiers(previewIdentifier: \"foo\", completeIdentifier: \"bar\")\n        \n        // THEN\n        XCTAssertEqual(user.previewProfileAssetIdentifier, initialPreview)\n        XCTAssertEqual(user.completeProfileAssetIdentifier, initialComplete)\n    }\n    \n}\n\n// MARK: - AssetV3 response parsing\n\nextension ZMUserTests_Swift {\n    \n    func assetPayload(previewId: String , completeId: String) -> NSArray {\n        return [\n            [\"size\" : \"preview\", \"type\" : \"image\", \"key\" : previewId],\n            [\"size\" : \"complete\", \"type\" : \"image\", \"key\" : completeId],\n        ] as NSArray\n    }\n    \n    func testThatItDoesNotUpdateAssetsWhenThereAreLocalModifications() {\n        syncMOC.performGroupedBlockAndWait {\n\n            // GIVEN\n            let user = ZMUser.selfUser(in: self.syncMOC)\n            let previewId = \"some\"\n            let completeId = \"other\"\n            let payload = self.assetPayload(previewId: \"foo\", completeId: \"bar\")\n            \n            // WHEN\n            user.updateAndSyncProfileAssetIdentifiers(previewIdentifier: previewId, completeIdentifier: completeId)\n            user.updateAssetData(with: payload, authoritative: true)\n            \n            // THEN\n            XCTAssertEqual(user.previewProfileAssetIdentifier, previewId)\n            XCTAssertEqual(user.completeProfileAssetIdentifier, completeId)\n        }\n    }\n    \n    func testThatItIgnoreAssetsWithIllegalCharacters() {\n        syncMOC.performGroupedBlockAndWait {\n            \n            // GIVEN\n            let user = ZMUser.selfUser(in: self.syncMOC)\n            let previewId = \"some\"\n            let completeId = \"other\"\n            let payload = self.assetPayload(previewId: \"Aa\\\\u0000\\r\\n\", completeId: \"Aa\\\\u0000\\r\\n\")\n            \n            // WHEN\n            user.updateAndSyncProfileAssetIdentifiers(previewIdentifier: previewId, completeIdentifier: completeId)\n            user.updateAssetData(with: payload, authoritative: true)\n            \n            // THEN\n            XCTAssertEqual(user.previewProfileAssetIdentifier, previewId)\n            XCTAssertEqual(user.completeProfileAssetIdentifier, completeId)\n        }\n    }\n    \n    func testThatItRemovesRemoteIdentifiersWhenWeGetEmptyAssets() {\n        syncMOC.performGroupedBlockAndWait {\n            // GIVEN\n            let user = ZMUser(remoteID: UUID.create(), createIfNeeded: true, in: self.syncMOC)\n            user?.previewProfileAssetIdentifier = \"some\"\n            user?.completeProfileAssetIdentifier = \"other\"\n            \n            // WHEN\n            user?.updateAssetData(with: NSArray(), authoritative: true)\n            \n            // THEN\n            XCTAssertNil(user?.previewProfileAssetIdentifier)\n            XCTAssertNil(user?.completeProfileAssetIdentifier)\n        }\n    }\n    \n    func testThatItUpdatesIdentifiersAndRemovesCachedImagesWhenWeGetRemoteIdentifiers() {\n        syncMOC.performGroupedBlockAndWait {\n            // GIVEN\n            let user = ZMUser(remoteID: UUID.create(), createIfNeeded: true, in: self.syncMOC)\n            user?.previewProfileAssetIdentifier = \"123\"\n            user?.completeProfileAssetIdentifier = \"456\"\n            user?.setImage(data: \"some\".data(using: .utf8), size: .preview)\n            user?.setImage(data: \"other\".data(using: .utf8), size: .complete)\n            XCTAssertNotNil(user?.imageData(for: .preview))\n            XCTAssertNotNil(user?.imageData(for: .complete))\n            let previewId = \"some\"\n            let completeId = \"other\"\n            let payload = self.assetPayload(previewId: previewId, completeId: completeId)\n            \n            // WHEN\n            user?.updateAssetData(with: payload, authoritative: true)\n            \n            // THEN\n            XCTAssertEqual(user?.previewProfileAssetIdentifier, previewId)\n            XCTAssertNil(user?.imageData(for: .preview))\n            XCTAssertEqual(user?.completeProfileAssetIdentifier, completeId)\n            XCTAssertNil(user?.imageData(for: .complete))\n        }\n    }\n    \n    func testThatItDoesNotRemoveLocalImagesIfRemoteIdentifiersHaveNotChanged() {\n        syncMOC.performGroupedBlockAndWait {\n            // GIVEN\n            let previewId = \"some\"\n            let previewData = \"some\".data(using: .utf8)\n            let completeId = \"other\"\n            let completeData = \"other\".data(using: .utf8)\n            let user = ZMUser(remoteID: UUID.create(), createIfNeeded: true, in: self.syncMOC)\n            user?.previewProfileAssetIdentifier = previewId\n            user?.completeProfileAssetIdentifier = completeId\n            user?.setImage(data: previewData, size: .preview)\n            user?.setImage(data: completeData, size: .complete)\n            XCTAssertNotNil(user?.imageData(for: .preview))\n            XCTAssertNotNil(user?.imageData(for: .complete))\n            let payload = self.assetPayload(previewId: previewId, completeId: completeId)\n            \n            // WHEN\n            user?.updateAssetData(with: payload, authoritative: true)\n            \n            // THEN\n            XCTAssertEqual(user?.previewProfileAssetIdentifier, previewId)\n            XCTAssertEqual(user?.completeProfileAssetIdentifier, completeId)\n            XCTAssertEqual(user?.imageData(for: .preview), previewData)\n            XCTAssertEqual(user?.imageData(for: .complete), completeData)\n        }\n    }\n\n}\n\n// MARK: - AssetV3 filter predicates\nextension ZMUserTests_Swift {\n    func testThatPreviewImageDownloadFilterPicksUpUser() {\n        syncMOC.performGroupedBlockAndWait {\n            // GIVEN\n            let predicate = ZMUser.previewImageDownloadFilter\n            let user = ZMUser(remoteID: UUID.create(), createIfNeeded: true, in: self.syncMOC)\n            user?.previewProfileAssetIdentifier = \"some identifier\"\n            \n            // THEN\n            XCTAssert(predicate.evaluate(with: user))\n        }\n    }\n    \n    func testThatCompleteImageDownloadFilterPicksUpUser() {\n        syncMOC.performGroupedBlockAndWait {\n            // GIVEN\n            let predicate = ZMUser.completeImageDownloadFilter\n            let user = ZMUser(remoteID: UUID.create(), createIfNeeded: true, in: self.syncMOC)\n            user?.completeProfileAssetIdentifier = \"some identifier\"\n            user?.setImage(data: nil, size: .complete)\n            \n            // THEN\n            XCTAssert(predicate.evaluate(with: user))\n        }\n    }\n    \n    func testThatCompleteImageDownloadFilterDoesNotPickUpUsersWithoutAssetId() {\n        syncMOC.performGroupedBlockAndWait {\n            // GIVEN\n            let predicate = ZMUser.completeImageDownloadFilter\n            let user = ZMUser(remoteID: UUID.create(), createIfNeeded: true, in: self.syncMOC)\n            user?.completeProfileAssetIdentifier = nil\n            user?.setImage(data: \"foo\".data(using: .utf8), size: .complete)\n            \n            // THEN\n            XCTAssertFalse(predicate.evaluate(with: user))\n        }\n    }\n\n    func testThatCompleteImageDownloadFilterDoesNotPickUpUsersWithInvalidAssetId() {\n        syncMOC.performGroupedBlockAndWait {\n            // GIVEN\n            let predicate = ZMUser.completeImageDownloadFilter\n            let user = ZMUser(remoteID: UUID.create(), createIfNeeded: true, in: self.syncMOC)\n            user?.completeProfileAssetIdentifier = \"not+valid+id\"\n            user?.setImage(data: \"foo\".data(using: .utf8), size: .complete)\n\n            // THEN\n            XCTAssertFalse(predicate.evaluate(with: user))\n        }\n    }\n    \n    func testThatPreviewImageDownloadFilterDoesNotPickUpUsersWithCachedImages() {\n        syncMOC.performGroupedBlockAndWait {\n            // GIVEN\n            let predicate = ZMUser.completeImageDownloadFilter\n            let user = ZMUser(remoteID: UUID.create(), createIfNeeded: true, in: self.syncMOC)\n            user?.previewProfileAssetIdentifier = \"1234\"\n            user?.setImage(data: \"foo\".data(using: .utf8), size: .preview)\n            \n            // THEN\n            XCTAssertFalse(predicate.evaluate(with: user))\n        }\n    }\n    \n    func testThatCompleteImageDownloadFilterDoesNotPickUpUsersWithCachedImages() {\n        syncMOC.performGroupedBlockAndWait {\n            // GIVEN\n            let predicate = ZMUser.completeImageDownloadFilter\n            let user = ZMUser(remoteID: UUID.create(), createIfNeeded: true, in: self.syncMOC)\n            user?.completeProfileAssetIdentifier = \"1234\"\n            user?.setImage(data: \"foo\".data(using: .utf8), size: .complete)\n            \n            // THEN\n            XCTAssertFalse(predicate.evaluate(with: user))\n        }\n    }\n}\n\n// MARK: - AssetV3 request notifications\nextension ZMUserTests_Swift {\n    \n    func testThatItPostsPreviewRequestNotifications() {\n        let noteExpectation = expectation(description: \"PreviewAssetFetchNotification should be fired\")\n        var userObjectId: NSManagedObjectID? = nil\n        \n        let token = ManagedObjectObserverToken(name: .userDidRequestPreviewAsset,\n                                               managedObjectContext: self.uiMOC)\n        { note in\n            let objectId = note.object as? NSManagedObjectID\n            XCTAssertNotNil(objectId)\n            XCTAssertEqual(objectId, userObjectId)\n            noteExpectation.fulfill()\n        }\n\n        let user = ZMUser.insertNewObject(in: uiMOC)\n        user.remoteIdentifier = UUID.create()\n        userObjectId = user.objectID\n        user.requestPreviewProfileImage()\n        \n        withExtendedLifetime(token) { () -> () in\n            XCTAssertTrue(waitForAllGroupsToBeEmpty(withTimeout: 0.5))\n            XCTAssertTrue(waitForCustomExpectations(withTimeout: 0.5))\n        }\n    }\n    \n    func testThatItPostsCompleteRequestNotifications() {\n        let noteExpectation = expectation(description: \"CompleteAssetFetchNotification should be fired\")\n        var userObjectId: NSManagedObjectID? = nil\n        \n        let token = ManagedObjectObserverToken(name: .userDidRequestCompleteAsset,\n                                               managedObjectContext: self.uiMOC)\n        { note in\n            let objectId = note.object as? NSManagedObjectID\n            XCTAssertNotNil(objectId)\n            XCTAssertEqual(objectId, userObjectId)\n            noteExpectation.fulfill()\n        }\n        \n        let user =  ZMUser.insertNewObject(in: uiMOC)\n        user.remoteIdentifier = UUID.create()\n        userObjectId = user.objectID\n        user.requestCompleteProfileImage()\n        \n        withExtendedLifetime(token) { () -> () in\n            XCTAssertTrue(waitForAllGroupsToBeEmpty(withTimeout: 0.5))\n            XCTAssertTrue(waitForCustomExpectations(withTimeout: 0.5))\n        }\n    }\n}\n\nextension ZMUser {\n\n    @discardableResult\n    static func insert(in moc: NSManagedObjectContext, id: UUID = .create(), name: String, handle: String? = nil, connectionStatus: ZMConnectionStatus = .accepted) -> ZMUser {\n        let user = ZMUser.insertNewObject(in: moc)\n        user.remoteIdentifier = id\n        user.name = name\n        user.setHandle(handle)\n        let connection = ZMConnection.insertNewSentConnection(to: user)\n        connection?.status = connectionStatus\n\n        return user\n    }\n}\n\n// MARK: - Predicates\nextension ZMUserTests_Swift {\n    \n    func testPredicateFilteringConnectedUsersByHandle() {\n        // Given\n        let user1 = ZMUser.insert(in: self.uiMOC, name: \"Some body\", handle: \"yyy\", connectionStatus: .accepted)\n        let user2 = ZMUser.insert(in: self.uiMOC, name: \"No body\", handle: \"yes-b\", connectionStatus: .accepted)\n        \n        let all = NSArray(array: [user1, user2])\n        \n        // When\n        let users = all.filtered(using: ZMUser.predicateForConnectedUsers(withSearch: \"yyy\")) as! [ZMUser]\n        \n        // Then\n        XCTAssertEqual(users.count, 1)\n        XCTAssertEqual(users, [user1])\n    }\n\n    func testPredicateFilteringConnectedUsersByHandleWithAtSymbol() {\n        // Given\n        let user1 = ZMUser.insert(in: self.uiMOC, name: \"Some body\", handle: \"ab\", connectionStatus: .accepted)\n        let user2 = ZMUser.insert(in: self.uiMOC, name: \"No body\", handle: \"yes-b\", connectionStatus: .accepted)\n        \n        let all = NSArray(array: [user1, user2])\n        \n        // When\n        let users = all.filtered(using: ZMUser.predicateForConnectedUsers(withSearch: \"@ab\")) as! [ZMUser]\n        \n        // Then\n        XCTAssertEqual(users.count, 1)\n        XCTAssertEqual(users, [user1])\n    }\n\n    func testPredicateFilteringConnectedUsersByHandlePrefix() {\n        // Given\n        let user1 = ZMUser.insert(in: self.uiMOC, name: \"Some body\", handle: \"alonghandle\", connectionStatus: .accepted)\n        let user2 = ZMUser.insert(in: self.uiMOC, name: \"No body\", handle: \"yes-b\", connectionStatus: .accepted)\n        \n        let all = NSArray(array: [user1, user2])\n        \n        // When\n        let users = all.filtered(using: ZMUser.predicateForConnectedUsers(withSearch: \"alo\")) as! [ZMUser]\n        \n        // Then\n        XCTAssertEqual(users.count, 1)\n        XCTAssertEqual(users, [user1])\n    }\n    \n    func testPredicateFilteringConnectedUsersStripsDiactricMarks() {\n        // Given\n        let user1 = ZMUser.insert(in: self.uiMOC, name: \"\u0160\u0151m\u0117 body\", handle: \"hand\", connectionStatus: .accepted)\n        let user2 = ZMUser.insert(in: self.uiMOC, name: \"No body\", handle: \"yes-b\", connectionStatus: .accepted)\n        \n        let all = NSArray(array: [user1, user2])\n        \n        // When\n        let users = all.filtered(using: ZMUser.predicateForConnectedUsers(withSearch: \"some\")) as! [ZMUser]\n        \n        // Then\n        XCTAssertEqual(users.count, 1)\n        XCTAssertEqual(users, [user1])\n    }\n    \n    func testPredicateFilteringForAllUsers() {\n        // Given\n        let user1 = ZMUser.insert(in: self.uiMOC, name: \"Some body\", handle: \"ab\", connectionStatus: .accepted)\n        let user2 = ZMUser.insert(in: self.uiMOC, name: \"No body\", handle: \"no-b\", connectionStatus: .accepted)\n        let user3 = ZMUser.insert(in: self.uiMOC, name: \"Yes body\", handle: \"yes-b\", connectionStatus: .pending)\n\n        let all = NSArray(array: [user1, user2, user3])\n        \n        // When\n        let users = all.filtered(using: ZMUser.predicateForAllUsers(withSearch: \"body\")) as! [ZMUser]\n        \n        // Then\n        XCTAssertEqual(users.count, 3)\n        XCTAssertEqual(users, [user1, user2, user3])\n    }\n    \n}\n\n// MARK: - Filename\nextension ZMUserTests_Swift {\n    \n    /// check the generated filename matches several critirias and a regex pattern\n    ///\n    /// - Parameters:\n    ///   - pattern: pattern string for regex\n    ///   - filename: filename to check\n    func checkFilenameIsValid(pattern: String, filename: String) {\n        XCTAssertEqual(filename.count, 214)\n        XCTAssertTrue(filename.hasPrefix(\"Some\"))\n        XCTAssertTrue(filename.contains(\"body\"))\n\n        let regexp = try! NSRegularExpression(pattern: pattern, options: [])\n        let matches = regexp.matches(in: filename as String, options: [], range: NSMakeRange(0, filename.count))\n        \n        XCTAssertTrue(matches.count > 0)\n    }\n    \n    func testFilenameForUser() throws {\n        // Given\n        let user = ZMUser.insert(in: self.uiMOC, name: \"Some body with a very long name and a emoji \ud83c\udded\ud83c\uddf0 and some Chinese \u4e2d\u6587 and some German Fu\u00dfg\u00e4nger\u00fcberg\u00e4nge\")\n        \n        // When\n        let filename = user.filename()\n        \n        // Then\n        /// check ends with a date stamp, e.g. -2017-10-24-11.05.43\n        let pattern = \"^.*[0-9-.]{20,20}$\"\n        checkFilenameIsValid(pattern: pattern, filename: filename)\n    }\n\n    func testFilenameWithSuffixForUser() throws {\n        // Given\n        let user = ZMUser.insert(in: self.uiMOC, name: \"Some body with a very long name and a emoji \ud83c\udded\ud83c\uddf0 and some Chinese \u4e2d\u6587 and some German Fu\u00dfg\u00e4nger\u00fcberg\u00e4nge\")\n        \n        // When\n        let suffix: String = \"-Jellyfish\"\n        let filename = user.filename(suffix: suffix)\n        \n        // Then\n        /// check ends with a date stamp and a suffix, e.g. -2017-10-24-11.05.43-Jellyfish\n        let pattern = \"^.*[0-9-.]{20,20}\\(suffix)$\"\n        checkFilenameIsValid(pattern: pattern, filename: filename)\n    }\n}\n\n// MARK: - Availability\nextension ZMUserTests_Swift {\n    \n    func testThatWeCanUpdateAvailabilityFromGenericMessage() {\n        // given\n        let user = ZMUser.insert(in: self.uiMOC, name: \"Foo\")\n        XCTAssertEqual(user.availability, .none)\n        let availability = WireProtos.Availability(.away)\n        // when\n        user.updateAvailability(from: GenericMessage(content: availability))\n        \n        // then\n        XCTAssertEqual(user.availability, .away)\n    }\n    \n    func testThatWeAllowModifyingAvailabilityOnTheSelfUser() {\n        // given\n        XCTAssertEqual(selfUser.availability, .none)\n        \n        // when\n        selfUser.availability = .away\n        \n        // then\n        XCTAssertEqual(selfUser.availability, .away)\n    }\n    \n    func testThatWeDontAllowModifyingAvailabilityOnOtherUsers() {\n        // given\n        let user = ZMUser.insert(in: self.uiMOC, name: \"Foo\")\n        XCTAssertEqual(user.availability, .none)\n        \n        // when\n        user.availability = .away\n        \n        // then\n        XCTAssertEqual(user.availability, .none)\n    }\n\n    func testThatNeedsToNotifyAvailabilityBehaviourChangeDefaultsToNothing() {\n        XCTAssertEqual(selfUser.needsToNotifyAvailabilityBehaviourChange, [])\n    }\n    \n    func testThatNeedsToNotifyAvailabilityBehaviourChangeCanBeUpdated() {\n        // given\n        selfUser.needsToNotifyAvailabilityBehaviourChange = .alert\n        \n        // then\n        XCTAssertEqual(selfUser.needsToNotifyAvailabilityBehaviourChange, .alert)\n    }\n        \n}\n\n// MARK: - Broadcast Recipients\n\nextension ZMUserTests_Swift {\n\n    func testThatItReturnsAllKnownTeamUsers() {\n        // given\n        let selfTeam = createTeam(in: uiMOC)\n        createMembership(in: uiMOC, user: selfUser, team: selfTeam)\n\n        // fellow team members\n        createUserAndAddMember(to: selfTeam)\n        createUserAndAddMember(to: selfTeam)\n\n        let otherTeam = createTeam(in: uiMOC)\n\n        // other team users but not connected\n        createUserAndAddMember(to: otherTeam)\n        createUserAndAddMember(to: otherTeam)\n\n        // other team users and connected\n        let (connectedTeamUser1, _) = createUserAndAddMember(to: otherTeam)\n        let (connectedTeamUser2, _) = createUserAndAddMember(to: otherTeam)\n\n        // non team users but connected\n        let connectedUser1 = createUser(in: uiMOC)\n        let connectedUser2 = createUser(in: uiMOC)\n\n        let usersToConnect = [connectedUser1, connectedUser2, connectedTeamUser1, connectedTeamUser2]\n\n        for user in usersToConnect {\n            let connection = ZMConnection.insertNewSentConnection(to: user)\n            connection?.status = .accepted\n        }\n\n        // when\n        let knownTeamUsers = ZMUser.knownTeamUsers(in: uiMOC)\n\n        // then\n        XCTAssertEqual(knownTeamUsers, Set([connectedTeamUser1, connectedTeamUser2]))\n    }\n\n\n    func testThatItReturnsOnlyKnownTeamUsersWithAcceptedConnections() {\n        // given\n        let selfTeam = createTeam(in: uiMOC)\n        createMembership(in: uiMOC, user: selfUser, team: selfTeam)\n\n        let otherTeam = createTeam(in: uiMOC)\n\n        // other team users with accepted connections\n        let (connectedTeamUser1, _) = createUserAndAddMember(to: otherTeam)\n        let (connectedTeamUser2, _) = createUserAndAddMember(to: otherTeam)\n\n        let usersToConnect = [connectedTeamUser1, connectedTeamUser2]\n\n        for user in usersToConnect {\n            let connection = ZMConnection.insertNewSentConnection(to: user)\n            connection?.status = .accepted\n        }\n\n        // other team users with unaccepted connections\n        for connectionStatus in [ZMConnectionStatus.pending, .blocked, .cancelled, .ignored, .sent, .invalid] {\n            let (user, _) = createUserAndAddMember(to: otherTeam)\n            let connection = ZMConnection.insertNewSentConnection(to: user)\n            connection?.status = connectionStatus\n        }\n\n        // when\n        let knownTeamUsers = ZMUser.knownTeamUsers(in: uiMOC)\n\n        // then\n        XCTAssertEqual(knownTeamUsers, Set([connectedTeamUser1, connectedTeamUser2]))\n    }\n\n    func testThatItReturnsAllKnownTeamMembers() {\n        // given\n        let selfUserTeam = createTeam(in: uiMOC)\n        createMembership(in: uiMOC, user: selfUser, team: selfUserTeam)\n\n        let (selfTeamUser1, _) = createUserAndAddMember(to: selfUserTeam)\n        let (selfTeamUser2, _) = createUserAndAddMember(to: selfUserTeam)\n        let (selfTeamUser3, _) = createUserAndAddMember(to: selfUserTeam)\n\n        _ = ZMUser.insert(in: uiMOC, name: \"1\", handle: \"1\", connectionStatus: .accepted)\n\n        let otherTeam = createTeam(in: uiMOC)\n        let (otherTeamUser, _) = createUserAndAddMember(to: otherTeam)\n\n        createConversation(in: uiMOC, with: [selfUser, selfTeamUser1])\n        createConversation(in: uiMOC, with: [selfUser, selfTeamUser2])\n        createConversation(in: uiMOC, with: [selfTeamUser2, selfTeamUser3])\n        createConversation(in: uiMOC, with: [selfUser, otherTeamUser])\n\n        // when\n        let knownTeamMembers = ZMUser.knownTeamMembers(in: uiMOC)\n\n        // then\n        XCTAssertEqual(knownTeamMembers, Set([selfTeamUser1, selfTeamUser2]))\n    }\n\n    func testThatReturnsExpectedRecipientsForBroadcast() {\n        // given\n        let selfUserTeam = createTeam(in: uiMOC)\n        createMembership(in: uiMOC, user: selfUser, team: selfUserTeam)\n\n        let (selfTeamUser1, _) = createUserAndAddMember(to: selfUserTeam)\n        let (selfTeamUser2, _) = createUserAndAddMember(to: selfUserTeam)\n        let (selfTeamUser3, _) = createUserAndAddMember(to: selfUserTeam)\n\n        let otherTeam = createTeam(in: uiMOC)\n\n        // unconnected other team users\n        createUserAndAddMember(to: otherTeam)\n        createUserAndAddMember(to: otherTeam)\n\n        let (connectedTeamUser1, _) = createUserAndAddMember(to: otherTeam)\n        let (connectedTeamUser2, _) = createUserAndAddMember(to: otherTeam)\n\n        let usersToConnect = [connectedTeamUser1, connectedTeamUser2]\n\n        for user in usersToConnect {\n            let connection = ZMConnection.insertNewSentConnection(to: user)\n            connection?.status = .accepted\n        }\n\n        createConversation(in: uiMOC, with: [selfUser, selfTeamUser1])\n        createConversation(in: uiMOC, with: [selfUser, selfTeamUser2])\n        createConversation(in: uiMOC, with: [selfTeamUser2, selfTeamUser3])\n        createConversation(in: uiMOC, with: [selfUser, connectedTeamUser1])\n\n        // when\n        let recipients = ZMUser.recipientsForAvailabilityStatusBroadcast(in: uiMOC, maxCount: 50)\n\n        // then\n        XCTAssertEqual(recipients, Set([selfUser, selfTeamUser1, selfTeamUser2, connectedTeamUser1, connectedTeamUser2]))\n    }\n\n    func testThatItReturnsRecipientsForBroadcastUpToAMaximumCount() {\n        // given\n        let selfUserTeam = createTeam(in: uiMOC)\n        createMembership(in: uiMOC, user: selfUser, team: selfUserTeam)\n\n        let (selfTeamUser1, _) = createUserAndAddMember(to: selfUserTeam)\n        let (selfTeamUser2, _) = createUserAndAddMember(to: selfUserTeam)\n        let (selfTeamUser3, _) = createUserAndAddMember(to: selfUserTeam)\n\n        let allRecipients = [\n            selfUser!,\n            selfTeamUser1,\n            selfTeamUser2,\n            selfTeamUser3\n        ]\n\n        createConversation(in: uiMOC, with: allRecipients)\n\n        // when\n        let recipients = ZMUser.recipientsForAvailabilityStatusBroadcast(in: uiMOC, maxCount: 3)\n\n        // then\n        XCTAssertEqual(recipients.count, 3)\n    }\n\n    func testThatItPrioritiesTeamMembersOverOtherTeamUsersForBroadcast() {\n        // given\n        let selfUserTeam = createTeam(in: uiMOC)\n        createMembership(in: uiMOC, user: selfUser, team: selfUserTeam)\n\n        let (selfTeamUser1, _) = createUserAndAddMember(to: selfUserTeam)\n        let (selfTeamUser2, _) = createUserAndAddMember(to: selfUserTeam)\n\n        let otherTeam = createTeam(in: uiMOC)\n\n        let (connectedTeamUser1, _) = createUserAndAddMember(to: otherTeam)\n        let (connectedTeamUser2, _) = createUserAndAddMember(to: otherTeam)\n\n        let usersToConnect = [connectedTeamUser1, connectedTeamUser2]\n\n        for user in usersToConnect {\n            let connection = ZMConnection.insertNewSentConnection(to: user)\n            connection?.status = .accepted\n        }\n\n        let allRecipients = [\n            selfUser!,\n            selfTeamUser1,\n            selfTeamUser2,\n            connectedTeamUser1,\n            connectedTeamUser2\n        ]\n\n        createConversation(in: uiMOC, with: allRecipients)\n\n        // when\n        let recipients = ZMUser.recipientsForAvailabilityStatusBroadcast(in: uiMOC, maxCount: 3)\n\n        // then\n        XCTAssertEqual(recipients, Set([selfUser, selfTeamUser1, selfTeamUser2]))\n    }\n\n    func testThatItRecipientsForBroadcastIsDeterministic() {\n        // given\n        let selfUserTeam = createTeam(in: uiMOC)\n        createMembership(in: uiMOC, user: selfUser, team: selfUserTeam)\n\n        let (teamUser1, _) = createUserAndAddMember(to: selfUserTeam)\n        let (teamUser2, _) = createUserAndAddMember(to: selfUserTeam)\n        let (teamUser3, _) = createUserAndAddMember(to: selfUserTeam)\n        let (teamUser4, _) = createUserAndAddMember(to: selfUserTeam)\n\n        let allRecipients = [\n            selfUser!,\n            teamUser1,\n            teamUser2,\n            teamUser3,\n            teamUser4\n        ]\n\n        createConversation(in: uiMOC, with: allRecipients)\n\n        // when\n        let recipients = ZMUser.recipientsForAvailabilityStatusBroadcast(in: uiMOC, maxCount: 3)\n\n        // then\n        let expectedRecipients = allRecipients.sorted {\n            $0.remoteIdentifier.transportString() < $1.remoteIdentifier.transportString()\n        }.prefix(3)\n\n        XCTAssertEqual(recipients, Set(expectedRecipients))\n    }\n\n}\n\n// MARK: - Bot support\nextension ZMUserTests_Swift {\n    func testThatServiceIdentifierAndProviderIdentifierAreNilByDefault() {\n        // GIVEN\n        let sut = ZMUser.insertNewObject(in: self.uiMOC)\n\n        // WHEN & THEN\n        XCTAssertNil(sut.providerIdentifier)\n        XCTAssertNil(sut.serviceIdentifier)\n    }\n}\n\n// MARK: - Expiration support\nextension ZMUserTests_Swift {\n    func testIsWirelessUserCalculation_false() {\n        // given\n        let sut = ZMUser.insertNewObject(in: self.uiMOC)\n        // when & then\n        XCTAssertFalse(sut.isWirelessUser)\n        XCTAssertFalse(sut.isExpired)\n        XCTAssertEqual(sut.expiresAfter, 0)\n    }\n    \n    func testIsWirelessUserCalculation_true_not_expired() {\n        // given\n        let sut = ZMUser.insertNewObject(in: self.uiMOC)\n        sut.expiresAt = Date(timeIntervalSinceNow: 1)\n        // when & then\n        XCTAssertTrue(sut.isWirelessUser)\n        XCTAssertFalse(sut.isExpired)\n        XCTAssertEqual(round(sut.expiresAfter), 1)\n    }\n    \n    func testIsWirelessUserCalculation_true_expired() {\n        // given\n        let sut = ZMUser.insertNewObject(in: self.uiMOC)\n        sut.expiresAt = Date(timeIntervalSinceNow: -1)\n        // when & then\n        XCTAssertTrue(sut.isWirelessUser)\n        XCTAssertTrue(sut.isExpired)\n        XCTAssertEqual(round(sut.expiresAfter), 0)\n    }\n}\n\n// MARK: - Account deletion\n\nextension ZMUserTests_Swift {\n    \n    func testThatUserIsRemovedFromAllConversationsWhenAccountIsDeleted() {\n        // given\n        let sut = createUser(in: uiMOC)\n        let conversation1 = createConversation(in: uiMOC)\n        conversation1.conversationType = .group\n        conversation1.addParticipantAndUpdateConversationState(user: sut, role: nil)\n        \n        let conversation2 = createConversation(in: uiMOC)\n        conversation2.conversationType = .group\n        conversation2.addParticipantAndUpdateConversationState(user: sut, role: nil)\n        \n        // when\n        sut.markAccountAsDeleted(at: Date())\n        \n        // then\n        XCTAssertNil(conversation1.participantRoles.first(where: { $0.user == sut })) //FIXME -> It was XCTAssertNotNil\n        XCTAssertNil(conversation2.participantRoles.first(where: { $0.user == sut })) //FIXME -> It was XCTAssertNotNil\n    }\n    \n    func testThatUserIsNotRemovedFromTeamOneToOneConversationsWhenAccountIsDeleted() {\n        // given\n        let team = createTeam(in: uiMOC)\n        let sut = createTeamMember(in: uiMOC, for: team)\n        let teamOneToOneConversation = ZMConversation.fetchOrCreateOneToOneTeamConversation(moc: uiMOC, participant: sut, team: team)!\n        teamOneToOneConversation.teamRemoteIdentifier = team.remoteIdentifier\n        \n        // when\n        sut.markAccountAsDeleted(at: Date())\n        \n        // then\n        XCTAssertTrue(teamOneToOneConversation.localParticipants.contains(sut))\n    }\n    \n}\n\n// MARK: - Active conversations\n\nextension ZMUserTests_Swift {\n    \n    func testActiveConversationsForSelfUser() {\n        // given\n        let sut = ZMUser.selfUser(in: uiMOC)\n        let conversation = ZMConversation.insertNewObject(in: uiMOC)\n        conversation.addParticipantAndUpdateConversationState(user: sut, role: nil)\n        let selfConversation = ZMConversation.fetch(withRemoteIdentifier: self.selfUser.remoteIdentifier, in: uiMOC)\n        \n        // then\n        XCTAssertEqual(sut.activeConversations, [conversation, selfConversation])\n    }\n    \n    func testActiveConversationsForOtherUser() {\n        // given\n        let sut = ZMUser.insertNewObject(in: uiMOC)\n        let conversation = ZMConversation.insertNewObject(in: uiMOC)\n        conversation.addParticipantAndUpdateConversationState(user: sut, role: nil)\n        \n        // then\n        XCTAssertEqual(sut.activeConversations, Set(arrayLiteral: conversation))\n    }\n    \n}\n\n// MARK: - Self user tests\nextension ZMUserTests_Swift {\n    func testThatItIsPossibleToSetReadReceiptsEnabled() {\n        // GIVEN\n        let sut = ZMUser.selfUser(in: uiMOC)\n        // WHEN\n        sut.readReceiptsEnabled = true\n        // THEN\n        XCTAssertEqual(sut.readReceiptsEnabled, true)\n    }\n    \n    func testThatItIsPossibleToSetReadReceiptsEnabled_andReset() {\n        // GIVEN\n        let sut = ZMUser.selfUser(in: uiMOC)\n        // WHEN\n        sut.readReceiptsEnabled = true\n        // THEN\n        XCTAssertEqual(sut.readReceiptsEnabled, true)\n        // AND WHEN\n        sut.readReceiptsEnabled = false\n        // THEN\n        XCTAssertEqual(sut.readReceiptsEnabled, false)\n    }\n    \n    func testThatItUpdatesOtherContextForEnableReadReceipts() {\n        // GIVEN\n        let sut = ZMUser.selfUser(in: uiMOC)\n        // WHEN\n        sut.readReceiptsEnabled = true\n        self.uiMOC.saveOrRollback()\n        \n        // THEN\n        \n        self.syncMOC.performGroupedBlock {\n            let syncSelfUser = ZMUser.selfUser(in: self.syncMOC)\n\n            XCTAssertEqual(syncSelfUser.readReceiptsEnabled, true)\n        }\n        \n        XCTAssertTrue(self.waitForAllGroupsToBeEmpty(withTimeout: 0.5))\n    }\n    \n    func testThatItSetsModifiedKeysForEnableReadReceipts() {\n        // GIVEN\n        let sut = ZMUser.selfUser(in: uiMOC)\n        sut.resetLocallyModifiedKeys(Set())\n        \n        // WHEN\n        sut.readReceiptsEnabled = true\n        \n        uiMOC.saveOrRollback()\n\n        // THEN\n        XCTAssertEqual(sut.modifiedKeys, Set([ReadReceiptsEnabledKey]))\n    }\n    \n    func testThatItDoesNotSetModifiedKeysForEnableReadReceipts() {\n        self.syncMOC.performGroupedAndWait { _ in\n            // GIVEN\n            let sut = ZMUser.selfUser(in: self.syncMOC)\n            sut.resetLocallyModifiedKeys(Set())\n            \n            // WHEN\n            sut.readReceiptsEnabled = true\n            self.syncMOC.saveOrRollback()\n\n            // THEN\n            XCTAssertEqual(sut.modifiedKeys, nil)\n        }\n    }\n    \n    func testThatItSavesValueOfReadReceiptsEnabled() {\n        // GIVEN\n        let user = ZMUser.selfUser(in: uiMOC)\n        // WHEN\n        user.readReceiptsEnabled = true\n        uiMOC.saveOrRollback()\n        // THEN\n        XCTAssert(user.readReceiptsEnabled)\n    }\n}\n\n// MARK: - Verifying user\nextension ZMUserTests_Swift {\n    \n    func testThatUserIsVerified_WhenSelfUserAndUserIsTrusted() {\n        // GIVEN\n        let user: ZMUser = self.userWithClients(count: 2, trusted: true)\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n        \n        // WHEN\n        XCTAssertTrue(user.isTrusted)\n        XCTAssertTrue(selfUser.isTrusted)\n        \n        // THEN\n        XCTAssertTrue(user.isVerified)\n    }\n    \n    func testThatUserIsNotVerified_WhenSelfUserIsNotTrustedButUserIsTrusted() {\n        // GIVEN\n        let user: ZMUser = self.userWithClients(count: 2, trusted: true)\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n        let selfClient: UserClient? = selfUser.selfClient()\n        \n        // WHEN\n        let newClient: UserClient = UserClient.insertNewObject(in: self.uiMOC)\n        newClient.user = selfUser\n        selfClient?.ignoreClient(newClient)\n        \n        // THEN\n        XCTAssertTrue(user.isTrusted)\n        XCTAssertFalse(selfUser.isTrusted)\n        XCTAssertFalse(user.isVerified)\n    }\n\n}\n"], "filenames": ["Source/Model/User/ZMUser.swift", "Tests/Source/Model/User/ZMUserTests+Swift.swift"], "buggy_code_start_loc": [252, 225], "buggy_code_end_loc": [267, 225], "fixing_code_start_loc": [253, 226], "fixing_code_end_loc": [275, 239], "type": "CWE-20", "message": "wire-ios is the iOS version of Wire, an open-source secure messaging app. In wire-ios versions 3.8.0 and prior, a vulnerability exists that can cause a denial of service between users. If a user has an invalid assetID for their profile picture and it contains the \" character, it will cause the iOS client to crash. The vulnerability is patched in wire-ios version 3.8.1.", "other": {"cve": {"id": "CVE-2021-32666", "sourceIdentifier": "security-advisories@github.com", "published": "2021-06-03T22:15:08.067", "lastModified": "2021-06-11T19:33:01.413", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "wire-ios is the iOS version of Wire, an open-source secure messaging app. In wire-ios versions 3.8.0 and prior, a vulnerability exists that can cause a denial of service between users. If a user has an invalid assetID for their profile picture and it contains the \" character, it will cause the iOS client to crash. The vulnerability is patched in wire-ios version 3.8.1."}, {"lang": "es", "value": "wire-ios es la versi\u00f3n para iOS de Wire, una aplicaci\u00f3n de mensajer\u00eda segura de c\u00f3digo abierto. En wire-ios, versiones 3.8.0 y anteriores se presenta una vulnerabilidad que puede causar una denegaci\u00f3n de servicio entre usuarios. Si un usuario tiene un assetID no v\u00e1lido para su foto de perfil y contiene el car\u00e1cter \", causar\u00e1 que el cliente de iOS se bloquee. La vulnerabilidad est\u00e1 parcheada en la versi\u00f3n 3.8.1 de wire-ios"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire:*:*:*:*:*:iphone_os:*:*", "versionEndExcluding": "3.81", "matchCriteriaId": "2DD070A1-55C9-4B0A-85F1-DA8C996520FE"}]}]}], "references": [{"url": "https://github.com/wireapp/wire-ios-data-model/commit/35af3f632085f51a2ce7f608fdaeffd1a69ad89f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/wireapp/wire-ios/security/advisories/GHSA-2x9x-vh27-h4rv", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wireapp/wire-ios-data-model/commit/35af3f632085f51a2ce7f608fdaeffd1a69ad89f"}}