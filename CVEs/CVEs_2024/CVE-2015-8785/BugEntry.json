{"buggy_code": ["/*\n  FUSE: Filesystem in Userspace\n  Copyright (C) 2001-2008  Miklos Szeredi <miklos@szeredi.hu>\n\n  This program can be distributed under the terms of the GNU GPL.\n  See the file COPYING.\n*/\n\n#include \"fuse_i.h\"\n\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/uio.h>\n\nstatic const struct file_operations fuse_direct_io_file_operations;\n\nstatic int fuse_send_open(struct fuse_conn *fc, u64 nodeid, struct file *file,\n\t\t\t  int opcode, struct fuse_open_out *outargp)\n{\n\tstruct fuse_open_in inarg;\n\tFUSE_ARGS(args);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.flags = file->f_flags & ~(O_CREAT | O_EXCL | O_NOCTTY);\n\tif (!fc->atomic_o_trunc)\n\t\tinarg.flags &= ~O_TRUNC;\n\targs.in.h.opcode = opcode;\n\targs.in.h.nodeid = nodeid;\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(*outargp);\n\targs.out.args[0].value = outargp;\n\n\treturn fuse_simple_request(fc, &args);\n}\n\nstruct fuse_file *fuse_file_alloc(struct fuse_conn *fc)\n{\n\tstruct fuse_file *ff;\n\n\tff = kmalloc(sizeof(struct fuse_file), GFP_KERNEL);\n\tif (unlikely(!ff))\n\t\treturn NULL;\n\n\tff->fc = fc;\n\tff->reserved_req = fuse_request_alloc(0);\n\tif (unlikely(!ff->reserved_req)) {\n\t\tkfree(ff);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&ff->write_entry);\n\tatomic_set(&ff->count, 0);\n\tRB_CLEAR_NODE(&ff->polled_node);\n\tinit_waitqueue_head(&ff->poll_wait);\n\n\tspin_lock(&fc->lock);\n\tff->kh = ++fc->khctr;\n\tspin_unlock(&fc->lock);\n\n\treturn ff;\n}\n\nvoid fuse_file_free(struct fuse_file *ff)\n{\n\tfuse_request_free(ff->reserved_req);\n\tkfree(ff);\n}\n\nstruct fuse_file *fuse_file_get(struct fuse_file *ff)\n{\n\tatomic_inc(&ff->count);\n\treturn ff;\n}\n\nstatic void fuse_release_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tiput(req->misc.release.inode);\n}\n\nstatic void fuse_file_put(struct fuse_file *ff, bool sync)\n{\n\tif (atomic_dec_and_test(&ff->count)) {\n\t\tstruct fuse_req *req = ff->reserved_req;\n\n\t\tif (ff->fc->no_open) {\n\t\t\t/*\n\t\t\t * Drop the release request when client does not\n\t\t\t * implement 'open'\n\t\t\t */\n\t\t\t__clear_bit(FR_BACKGROUND, &req->flags);\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else if (sync) {\n\t\t\t__clear_bit(FR_BACKGROUND, &req->flags);\n\t\t\tfuse_request_send(ff->fc, req);\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else {\n\t\t\treq->end = fuse_release_end;\n\t\t\t__set_bit(FR_BACKGROUND, &req->flags);\n\t\t\tfuse_request_send_background(ff->fc, req);\n\t\t}\n\t\tkfree(ff);\n\t}\n}\n\nint fuse_do_open(struct fuse_conn *fc, u64 nodeid, struct file *file,\n\t\t bool isdir)\n{\n\tstruct fuse_file *ff;\n\tint opcode = isdir ? FUSE_OPENDIR : FUSE_OPEN;\n\n\tff = fuse_file_alloc(fc);\n\tif (!ff)\n\t\treturn -ENOMEM;\n\n\tff->fh = 0;\n\tff->open_flags = FOPEN_KEEP_CACHE; /* Default for no-open */\n\tif (!fc->no_open || isdir) {\n\t\tstruct fuse_open_out outarg;\n\t\tint err;\n\n\t\terr = fuse_send_open(fc, nodeid, file, opcode, &outarg);\n\t\tif (!err) {\n\t\t\tff->fh = outarg.fh;\n\t\t\tff->open_flags = outarg.open_flags;\n\n\t\t} else if (err != -ENOSYS || isdir) {\n\t\t\tfuse_file_free(ff);\n\t\t\treturn err;\n\t\t} else {\n\t\t\tfc->no_open = 1;\n\t\t}\n\t}\n\n\tif (isdir)\n\t\tff->open_flags &= ~FOPEN_DIRECT_IO;\n\n\tff->nodeid = nodeid;\n\tfile->private_data = fuse_file_get(ff);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fuse_do_open);\n\nstatic void fuse_link_write_file(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_file *ff = file->private_data;\n\t/*\n\t * file may be written through mmap, so chain it onto the\n\t * inodes's write_file list\n\t */\n\tspin_lock(&fc->lock);\n\tif (list_empty(&ff->write_entry))\n\t\tlist_add(&ff->write_entry, &fi->write_files);\n\tspin_unlock(&fc->lock);\n}\n\nvoid fuse_finish_open(struct inode *inode, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (ff->open_flags & FOPEN_DIRECT_IO)\n\t\tfile->f_op = &fuse_direct_io_file_operations;\n\tif (!(ff->open_flags & FOPEN_KEEP_CACHE))\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\tif (ff->open_flags & FOPEN_NONSEEKABLE)\n\t\tnonseekable_open(inode, file);\n\tif (fc->atomic_o_trunc && (file->f_flags & O_TRUNC)) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\tspin_lock(&fc->lock);\n\t\tfi->attr_version = ++fc->attr_version;\n\t\ti_size_write(inode, 0);\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_invalidate_attr(inode);\n\t\tif (fc->writeback_cache)\n\t\t\tfile_update_time(file);\n\t}\n\tif ((file->f_mode & FMODE_WRITE) && fc->writeback_cache)\n\t\tfuse_link_write_file(file);\n}\n\nint fuse_open_common(struct inode *inode, struct file *file, bool isdir)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\tbool lock_inode = (file->f_flags & O_TRUNC) &&\n\t\t\t  fc->atomic_o_trunc &&\n\t\t\t  fc->writeback_cache;\n\n\terr = generic_file_open(inode, file);\n\tif (err)\n\t\treturn err;\n\n\tif (lock_inode)\n\t\tmutex_lock(&inode->i_mutex);\n\n\terr = fuse_do_open(fc, get_node_id(inode), file, isdir);\n\n\tif (!err)\n\t\tfuse_finish_open(inode, file);\n\n\tif (lock_inode)\n\t\tmutex_unlock(&inode->i_mutex);\n\n\treturn err;\n}\n\nstatic void fuse_prepare_release(struct fuse_file *ff, int flags, int opcode)\n{\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_req *req = ff->reserved_req;\n\tstruct fuse_release_in *inarg = &req->misc.release.in;\n\n\tspin_lock(&fc->lock);\n\tlist_del(&ff->write_entry);\n\tif (!RB_EMPTY_NODE(&ff->polled_node))\n\t\trb_erase(&ff->polled_node, &fc->polled_files);\n\tspin_unlock(&fc->lock);\n\n\twake_up_interruptible_all(&ff->poll_wait);\n\n\tinarg->fh = ff->fh;\n\tinarg->flags = flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_release_in);\n\treq->in.args[0].value = inarg;\n}\n\nvoid fuse_release_common(struct file *file, int opcode)\n{\n\tstruct fuse_file *ff;\n\tstruct fuse_req *req;\n\n\tff = file->private_data;\n\tif (unlikely(!ff))\n\t\treturn;\n\n\treq = ff->reserved_req;\n\tfuse_prepare_release(ff, file->f_flags, opcode);\n\n\tif (ff->flock) {\n\t\tstruct fuse_release_in *inarg = &req->misc.release.in;\n\t\tinarg->release_flags |= FUSE_RELEASE_FLOCK_UNLOCK;\n\t\tinarg->lock_owner = fuse_lock_owner_id(ff->fc,\n\t\t\t\t\t\t       (fl_owner_t) file);\n\t}\n\t/* Hold inode until release is finished */\n\treq->misc.release.inode = igrab(file_inode(file));\n\n\t/*\n\t * Normally this will send the RELEASE request, however if\n\t * some asynchronous READ or WRITE requests are outstanding,\n\t * the sending will be delayed.\n\t *\n\t * Make the release synchronous if this is a fuseblk mount,\n\t * synchronous RELEASE is allowed (and desirable) in this case\n\t * because the server can be trusted not to screw up.\n\t */\n\tfuse_file_put(ff, ff->fc->destroy_req != NULL);\n}\n\nstatic int fuse_open(struct inode *inode, struct file *file)\n{\n\treturn fuse_open_common(inode, file, false);\n}\n\nstatic int fuse_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\t/* see fuse_vma_close() for !writeback_cache case */\n\tif (fc->writeback_cache)\n\t\twrite_inode_now(inode, 1);\n\n\tfuse_release_common(file, FUSE_RELEASE);\n\n\t/* return value is ignored by VFS */\n\treturn 0;\n}\n\nvoid fuse_sync_release(struct fuse_file *ff, int flags)\n{\n\tWARN_ON(atomic_read(&ff->count) > 1);\n\tfuse_prepare_release(ff, flags, FUSE_RELEASE);\n\t__set_bit(FR_FORCE, &ff->reserved_req->flags);\n\t__clear_bit(FR_BACKGROUND, &ff->reserved_req->flags);\n\tfuse_request_send(ff->fc, ff->reserved_req);\n\tfuse_put_request(ff->fc, ff->reserved_req);\n\tkfree(ff);\n}\nEXPORT_SYMBOL_GPL(fuse_sync_release);\n\n/*\n * Scramble the ID space with XTEA, so that the value of the files_struct\n * pointer is not exposed to userspace.\n */\nu64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id)\n{\n\tu32 *k = fc->scramble_key;\n\tu64 v = (unsigned long) id;\n\tu32 v0 = v;\n\tu32 v1 = v >> 32;\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tv0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + k[sum & 3]);\n\t\tsum += 0x9E3779B9;\n\t\tv1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + k[sum>>11 & 3]);\n\t}\n\n\treturn (u64) v0 + ((u64) v1 << 32);\n}\n\n/*\n * Check if any page in a range is under writeback\n *\n * This is currently done by walking the list of writepage requests\n * for the inode, which can be pretty inefficient.\n */\nstatic bool fuse_range_is_writeback(struct inode *inode, pgoff_t idx_from,\n\t\t\t\t   pgoff_t idx_to)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tbool found = false;\n\n\tspin_lock(&fc->lock);\n\tlist_for_each_entry(req, &fi->writepages, writepages_entry) {\n\t\tpgoff_t curr_index;\n\n\t\tBUG_ON(req->inode != inode);\n\t\tcurr_index = req->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (idx_from < curr_index + req->num_pages &&\n\t\t    curr_index <= idx_to) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn found;\n}\n\nstatic inline bool fuse_page_is_writeback(struct inode *inode, pgoff_t index)\n{\n\treturn fuse_range_is_writeback(inode, index, index);\n}\n\n/*\n * Wait for page writeback to be completed.\n *\n * Since fuse doesn't rely on the VM writeback tracking, this has to\n * use some other means.\n */\nstatic int fuse_wait_on_page_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\twait_event(fi->page_waitq, !fuse_page_is_writeback(inode, index));\n\treturn 0;\n}\n\n/*\n * Wait for all pending writepages on the inode to finish.\n *\n * This is currently done by blocking further writes with FUSE_NOWRITE\n * and waiting for all sent writes to complete.\n *\n * This must be called under i_mutex, otherwise the FUSE_NOWRITE usage\n * could conflict with truncation.\n */\nstatic void fuse_sync_writes(struct inode *inode)\n{\n\tfuse_set_nowrite(inode);\n\tfuse_release_nowrite(inode);\n}\n\nstatic int fuse_flush(struct file *file, fl_owner_t id)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_req *req;\n\tstruct fuse_flush_in inarg;\n\tint err;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tif (fc->no_flush)\n\t\treturn 0;\n\n\terr = write_inode_now(inode, 1);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&inode->i_mutex);\n\tfuse_sync_writes(inode);\n\tmutex_unlock(&inode->i_mutex);\n\n\treq = fuse_get_req_nofail_nopages(fc, file);\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.fh = ff->fh;\n\tinarg.lock_owner = fuse_lock_owner_id(fc, id);\n\treq->in.h.opcode = FUSE_FLUSH;\n\treq->in.h.nodeid = get_node_id(inode);\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\t__set_bit(FR_FORCE, &req->flags);\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\tif (err == -ENOSYS) {\n\t\tfc->no_flush = 1;\n\t\terr = 0;\n\t}\n\treturn err;\n}\n\nint fuse_fsync_common(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync, int isdir)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tFUSE_ARGS(args);\n\tstruct fuse_fsync_in inarg;\n\tint err;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * Start writeback against all dirty pages of the inode, then\n\t * wait for all outstanding writes, before sending the FSYNC\n\t * request.\n\t */\n\terr = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (err)\n\t\tgoto out;\n\n\tfuse_sync_writes(inode);\n\terr = sync_inode_metadata(inode, 1);\n\tif (err)\n\t\tgoto out;\n\n\tif ((!isdir && fc->no_fsync) || (isdir && fc->no_fsyncdir))\n\t\tgoto out;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.fh = ff->fh;\n\tinarg.fsync_flags = datasync ? 1 : 0;\n\targs.in.h.opcode = isdir ? FUSE_FSYNCDIR : FUSE_FSYNC;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS) {\n\t\tif (isdir)\n\t\t\tfc->no_fsyncdir = 1;\n\t\telse\n\t\t\tfc->no_fsync = 1;\n\t\terr = 0;\n\t}\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn err;\n}\n\nstatic int fuse_fsync(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync)\n{\n\treturn fuse_fsync_common(file, start, end, datasync, 0);\n}\n\nvoid fuse_read_fill(struct fuse_req *req, struct file *file, loff_t pos,\n\t\t    size_t count, int opcode)\n{\n\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\tstruct fuse_file *ff = file->private_data;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\tinarg->flags = file->f_flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_read_in);\n\treq->in.args[0].value = inarg;\n\treq->out.argvar = 1;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = count;\n}\n\nstatic void fuse_release_user_pages(struct fuse_req *req, int write)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\t\tif (write)\n\t\t\tset_page_dirty_lock(page);\n\t\tput_page(page);\n\t}\n}\n\nstatic ssize_t fuse_get_res_by_io(struct fuse_io_priv *io)\n{\n\tif (io->err)\n\t\treturn io->err;\n\n\tif (io->bytes >= 0 && io->write)\n\t\treturn -EIO;\n\n\treturn io->bytes < 0 ? io->size : io->bytes;\n}\n\n/**\n * In case of short read, the caller sets 'pos' to the position of\n * actual end of fuse request in IO request. Otherwise, if bytes_requested\n * == bytes_transferred or rw == WRITE, the caller sets 'pos' to -1.\n *\n * An example:\n * User requested DIO read of 64K. It was splitted into two 32K fuse requests,\n * both submitted asynchronously. The first of them was ACKed by userspace as\n * fully completed (req->out.args[0].size == 32K) resulting in pos == -1. The\n * second request was ACKed as short, e.g. only 1K was read, resulting in\n * pos == 33K.\n *\n * Thus, when all fuse requests are completed, the minimal non-negative 'pos'\n * will be equal to the length of the longest contiguous fragment of\n * transferred data starting from the beginning of IO request.\n */\nstatic void fuse_aio_complete(struct fuse_io_priv *io, int err, ssize_t pos)\n{\n\tbool is_sync = is_sync_kiocb(io->iocb);\n\tint left;\n\n\tspin_lock(&io->lock);\n\tif (err)\n\t\tio->err = io->err ? : err;\n\telse if (pos >= 0 && (io->bytes < 0 || pos < io->bytes))\n\t\tio->bytes = pos;\n\n\tleft = --io->reqs;\n\tif (!left && is_sync)\n\t\tcomplete(io->done);\n\tspin_unlock(&io->lock);\n\n\tif (!left && !is_sync) {\n\t\tssize_t res = fuse_get_res_by_io(io);\n\n\t\tif (res >= 0) {\n\t\t\tstruct inode *inode = file_inode(io->iocb->ki_filp);\n\t\t\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\t\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\t\tspin_lock(&fc->lock);\n\t\t\tfi->attr_version = ++fc->attr_version;\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tio->iocb->ki_complete(io->iocb, res, 0);\n\t\tkfree(io);\n\t}\n}\n\nstatic void fuse_aio_complete_req(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct fuse_io_priv *io = req->io;\n\tssize_t pos = -1;\n\n\tfuse_release_user_pages(req, !io->write);\n\n\tif (io->write) {\n\t\tif (req->misc.write.in.size != req->misc.write.out.size)\n\t\t\tpos = req->misc.write.in.offset - io->offset +\n\t\t\t\treq->misc.write.out.size;\n\t} else {\n\t\tif (req->misc.read.in.size != req->out.args[0].size)\n\t\t\tpos = req->misc.read.in.offset - io->offset +\n\t\t\t\treq->out.args[0].size;\n\t}\n\n\tfuse_aio_complete(io, req->out.h.error, pos);\n}\n\nstatic size_t fuse_async_req_send(struct fuse_conn *fc, struct fuse_req *req,\n\t\tsize_t num_bytes, struct fuse_io_priv *io)\n{\n\tspin_lock(&io->lock);\n\tio->size += num_bytes;\n\tio->reqs++;\n\tspin_unlock(&io->lock);\n\n\treq->io = io;\n\treq->end = fuse_aio_complete_req;\n\n\t__fuse_get_request(req);\n\tfuse_request_send_background(fc, req);\n\n\treturn num_bytes;\n}\n\nstatic size_t fuse_send_read(struct fuse_req *req, struct fuse_io_priv *io,\n\t\t\t     loff_t pos, size_t count, fl_owner_t owner)\n{\n\tstruct file *file = io->file;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\tif (owner != NULL) {\n\t\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\n\t\tinarg->read_flags |= FUSE_READ_LOCKOWNER;\n\t\tinarg->lock_owner = fuse_lock_owner_id(fc, owner);\n\t}\n\n\tif (io->async)\n\t\treturn fuse_async_req_send(fc, req, count, io);\n\n\tfuse_request_send(fc, req);\n\treturn req->out.args[0].size;\n}\n\nstatic void fuse_read_update_size(struct inode *inode, loff_t size,\n\t\t\t\t  u64 attr_ver)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tspin_lock(&fc->lock);\n\tif (attr_ver == fi->attr_version && size < inode->i_size &&\n\t    !test_bit(FUSE_I_SIZE_UNSTABLE, &fi->state)) {\n\t\tfi->attr_version = ++fc->attr_version;\n\t\ti_size_write(inode, size);\n\t}\n\tspin_unlock(&fc->lock);\n}\n\nstatic void fuse_short_read(struct fuse_req *req, struct inode *inode,\n\t\t\t    u64 attr_ver)\n{\n\tsize_t num_read = req->out.args[0].size;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (fc->writeback_cache) {\n\t\t/*\n\t\t * A hole in a file. Some data after the hole are in page cache,\n\t\t * but have not reached the client fs yet. So, the hole is not\n\t\t * present there.\n\t\t */\n\t\tint i;\n\t\tint start_idx = num_read >> PAGE_CACHE_SHIFT;\n\t\tsize_t off = num_read & (PAGE_CACHE_SIZE - 1);\n\n\t\tfor (i = start_idx; i < req->num_pages; i++) {\n\t\t\tzero_user_segment(req->pages[i], off, PAGE_CACHE_SIZE);\n\t\t\toff = 0;\n\t\t}\n\t} else {\n\t\tloff_t pos = page_offset(req->pages[0]) + num_read;\n\t\tfuse_read_update_size(inode, pos, attr_ver);\n\t}\n}\n\nstatic int fuse_do_readpage(struct file *file, struct page *page)\n{\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\tstruct inode *inode = page->mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tsize_t num_read;\n\tloff_t pos = page_offset(page);\n\tsize_t count = PAGE_CACHE_SIZE;\n\tu64 attr_ver;\n\tint err;\n\n\t/*\n\t * Page writeback can extend beyond the lifetime of the\n\t * page-cache page, so make sure we read a properly synced\n\t * page.\n\t */\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\treq = fuse_get_req(fc, 1);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tattr_ver = fuse_get_attr_version(fc);\n\n\treq->out.page_zeroing = 1;\n\treq->out.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = page;\n\treq->page_descs[0].length = count;\n\tnum_read = fuse_send_read(req, &io, pos, count, NULL);\n\terr = req->out.h.error;\n\n\tif (!err) {\n\t\t/*\n\t\t * Short read means EOF.  If file size is larger, truncate it\n\t\t */\n\t\tif (num_read < count)\n\t\t\tfuse_short_read(req, inode, attr_ver);\n\n\t\tSetPageUptodate(page);\n\t}\n\n\tfuse_put_request(fc, req);\n\n\treturn err;\n}\n\nstatic int fuse_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint err;\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\terr = fuse_do_readpage(file, page);\n\tfuse_invalidate_atime(inode);\n out:\n\tunlock_page(page);\n\treturn err;\n}\n\nstatic void fuse_readpages_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tint i;\n\tsize_t count = req->misc.read.in.size;\n\tsize_t num_read = req->out.args[0].size;\n\tstruct address_space *mapping = NULL;\n\n\tfor (i = 0; mapping == NULL && i < req->num_pages; i++)\n\t\tmapping = req->pages[i]->mapping;\n\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\n\t\t/*\n\t\t * Short read means EOF. If file size is larger, truncate it\n\t\t */\n\t\tif (!req->out.h.error && num_read < count)\n\t\t\tfuse_short_read(req, inode, req->misc.read.attr_ver);\n\n\t\tfuse_invalidate_atime(inode);\n\t}\n\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\t\tif (!req->out.h.error)\n\t\t\tSetPageUptodate(page);\n\t\telse\n\t\t\tSetPageError(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (req->ff)\n\t\tfuse_file_put(req->ff, false);\n}\n\nstatic void fuse_send_readpages(struct fuse_req *req, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tloff_t pos = page_offset(req->pages[0]);\n\tsize_t count = req->num_pages << PAGE_CACHE_SHIFT;\n\n\treq->out.argpages = 1;\n\treq->out.page_zeroing = 1;\n\treq->out.page_replace = 1;\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\treq->misc.read.attr_ver = fuse_get_attr_version(fc);\n\tif (fc->async_read) {\n\t\treq->ff = fuse_file_get(ff);\n\t\treq->end = fuse_readpages_end;\n\t\tfuse_request_send_background(fc, req);\n\t} else {\n\t\tfuse_request_send(fc, req);\n\t\tfuse_readpages_end(fc, req);\n\t\tfuse_put_request(fc, req);\n\t}\n}\n\nstruct fuse_fill_data {\n\tstruct fuse_req *req;\n\tstruct file *file;\n\tstruct inode *inode;\n\tunsigned nr_pages;\n};\n\nstatic int fuse_readpages_fill(void *_data, struct page *page)\n{\n\tstruct fuse_fill_data *data = _data;\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\tif (req->num_pages &&\n\t    (req->num_pages == FUSE_MAX_PAGES_PER_REQ ||\n\t     (req->num_pages + 1) * PAGE_CACHE_SIZE > fc->max_read ||\n\t     req->pages[req->num_pages - 1]->index + 1 != page->index)) {\n\t\tint nr_alloc = min_t(unsigned, data->nr_pages,\n\t\t\t\t     FUSE_MAX_PAGES_PER_REQ);\n\t\tfuse_send_readpages(req, data->file);\n\t\tif (fc->async_read)\n\t\t\treq = fuse_get_req_for_background(fc, nr_alloc);\n\t\telse\n\t\t\treq = fuse_get_req(fc, nr_alloc);\n\n\t\tdata->req = req;\n\t\tif (IS_ERR(req)) {\n\t\t\tunlock_page(page);\n\t\t\treturn PTR_ERR(req);\n\t\t}\n\t}\n\n\tif (WARN_ON(req->num_pages >= req->max_pages)) {\n\t\tfuse_put_request(fc, req);\n\t\treturn -EIO;\n\t}\n\n\tpage_cache_get(page);\n\treq->pages[req->num_pages] = page;\n\treq->page_descs[req->num_pages].length = PAGE_SIZE;\n\treq->num_pages++;\n\tdata->nr_pages--;\n\treturn 0;\n}\n\nstatic int fuse_readpages(struct file *file, struct address_space *mapping,\n\t\t\t  struct list_head *pages, unsigned nr_pages)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_fill_data data;\n\tint err;\n\tint nr_alloc = min_t(unsigned, nr_pages, FUSE_MAX_PAGES_PER_REQ);\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\tdata.file = file;\n\tdata.inode = inode;\n\tif (fc->async_read)\n\t\tdata.req = fuse_get_req_for_background(fc, nr_alloc);\n\telse\n\t\tdata.req = fuse_get_req(fc, nr_alloc);\n\tdata.nr_pages = nr_pages;\n\terr = PTR_ERR(data.req);\n\tif (IS_ERR(data.req))\n\t\tgoto out;\n\n\terr = read_cache_pages(mapping, pages, fuse_readpages_fill, &data);\n\tif (!err) {\n\t\tif (data.req->num_pages)\n\t\t\tfuse_send_readpages(data.req, file);\n\t\telse\n\t\t\tfuse_put_request(fc, data.req);\n\t}\nout:\n\treturn err;\n}\n\nstatic ssize_t fuse_file_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct inode *inode = iocb->ki_filp->f_mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\t/*\n\t * In auto invalidate mode, always update attributes on read.\n\t * Otherwise, only update if we attempt to read past EOF (to ensure\n\t * i_size is up to date).\n\t */\n\tif (fc->auto_inval_data ||\n\t    (iocb->ki_pos + iov_iter_count(to) > i_size_read(inode))) {\n\t\tint err;\n\t\terr = fuse_update_attributes(inode, NULL, iocb->ki_filp, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn generic_file_read_iter(iocb, to);\n}\n\nstatic void fuse_write_fill(struct fuse_req *req, struct fuse_file *ff,\n\t\t\t    loff_t pos, size_t count)\n{\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\tstruct fuse_write_out *outarg = &req->misc.write.out;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\treq->in.h.opcode = FUSE_WRITE;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 2;\n\tif (ff->fc->minor < 9)\n\t\treq->in.args[0].size = FUSE_COMPAT_WRITE_IN_SIZE;\n\telse\n\t\treq->in.args[0].size = sizeof(struct fuse_write_in);\n\treq->in.args[0].value = inarg;\n\treq->in.args[1].size = count;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = sizeof(struct fuse_write_out);\n\treq->out.args[0].value = outarg;\n}\n\nstatic size_t fuse_send_write(struct fuse_req *req, struct fuse_io_priv *io,\n\t\t\t      loff_t pos, size_t count, fl_owner_t owner)\n{\n\tstruct file *file = io->file;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\n\tfuse_write_fill(req, ff, pos, count);\n\tinarg->flags = file->f_flags;\n\tif (owner != NULL) {\n\t\tinarg->write_flags |= FUSE_WRITE_LOCKOWNER;\n\t\tinarg->lock_owner = fuse_lock_owner_id(fc, owner);\n\t}\n\n\tif (io->async)\n\t\treturn fuse_async_req_send(fc, req, count, io);\n\n\tfuse_request_send(fc, req);\n\treturn req->misc.write.out.size;\n}\n\nbool fuse_write_update_size(struct inode *inode, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool ret = false;\n\n\tspin_lock(&fc->lock);\n\tfi->attr_version = ++fc->attr_version;\n\tif (pos > inode->i_size) {\n\t\ti_size_write(inode, pos);\n\t\tret = true;\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ret;\n}\n\nstatic size_t fuse_send_write_pages(struct fuse_req *req, struct file *file,\n\t\t\t\t    struct inode *inode, loff_t pos,\n\t\t\t\t    size_t count)\n{\n\tsize_t res;\n\tunsigned offset;\n\tunsigned i;\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\tfuse_wait_on_page_writeback(inode, req->pages[i]->index);\n\n\tres = fuse_send_write(req, &io, pos, count, NULL);\n\n\toffset = req->page_descs[0].offset;\n\tcount = res;\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\n\t\tif (!req->out.h.error && !offset && count >= PAGE_CACHE_SIZE)\n\t\t\tSetPageUptodate(page);\n\n\t\tif (count > PAGE_CACHE_SIZE - offset)\n\t\t\tcount -= PAGE_CACHE_SIZE - offset;\n\t\telse\n\t\t\tcount = 0;\n\t\toffset = 0;\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treturn res;\n}\n\nstatic ssize_t fuse_fill_write_pages(struct fuse_req *req,\n\t\t\t       struct address_space *mapping,\n\t\t\t       struct iov_iter *ii, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(mapping->host);\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tsize_t count = 0;\n\tint err;\n\n\treq->in.argpages = 1;\n\treq->page_descs[0].offset = offset;\n\n\tdo {\n\t\tsize_t tmp;\n\t\tstruct page *page;\n\t\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\t\tsize_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,\n\t\t\t\t     iov_iter_count(ii));\n\n\t\tbytes = min_t(size_t, bytes, fc->max_write - count);\n\n again:\n\t\terr = -EFAULT;\n\t\tif (iov_iter_fault_in_readable(ii, bytes))\n\t\t\tbreak;\n\n\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tflush_dcache_page(page);\n\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = tmp;\n\t\treq->num_pages++;\n\n\t\tiov_iter_advance(ii, tmp);\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < req->max_pages && offset == 0);\n\n\treturn count > 0 ? count : err;\n}\n\nstatic inline unsigned fuse_wr_pages(loff_t pos, size_t len)\n{\n\treturn min_t(unsigned,\n\t\t     ((pos + len - 1) >> PAGE_CACHE_SHIFT) -\n\t\t     (pos >> PAGE_CACHE_SHIFT) + 1,\n\t\t     FUSE_MAX_PAGES_PER_REQ);\n}\n\nstatic ssize_t fuse_perform_write(struct file *file,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct iov_iter *ii, loff_t pos)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint err = 0;\n\tssize_t res = 0;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tif (inode->i_size < pos + iov_iter_count(ii))\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\tdo {\n\t\tstruct fuse_req *req;\n\t\tssize_t count;\n\t\tunsigned nr_pages = fuse_wr_pages(pos, iov_iter_count(ii));\n\n\t\treq = fuse_get_req(fc, nr_pages);\n\t\tif (IS_ERR(req)) {\n\t\t\terr = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = fuse_fill_write_pages(req, mapping, ii, pos);\n\t\tif (count <= 0) {\n\t\t\terr = count;\n\t\t} else {\n\t\t\tsize_t num_written;\n\n\t\t\tnum_written = fuse_send_write_pages(req, file, inode,\n\t\t\t\t\t\t\t    pos, count);\n\t\t\terr = req->out.h.error;\n\t\t\tif (!err) {\n\t\t\t\tres += num_written;\n\t\t\t\tpos += num_written;\n\n\t\t\t\t/* break out of the loop on short write */\n\t\t\t\tif (num_written != count)\n\t\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tfuse_put_request(fc, req);\n\t} while (!err && iov_iter_count(ii));\n\n\tif (res > 0)\n\t\tfuse_write_update_size(inode, pos);\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\tfuse_invalidate_attr(inode);\n\n\treturn res > 0 ? res : err;\n}\n\nstatic ssize_t fuse_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tssize_t written = 0;\n\tssize_t written_buffered = 0;\n\tstruct inode *inode = mapping->host;\n\tssize_t err;\n\tloff_t endbyte = 0;\n\n\tif (get_fuse_conn(inode)->writeback_cache) {\n\t\t/* Update size (EOF optimization) and mode (SUID clearing) */\n\t\terr = fuse_update_attributes(mapping->host, NULL, file, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn generic_file_write_iter(iocb, from);\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/* We can write back this queue in page reclaim */\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\n\terr = generic_write_checks(iocb, from);\n\tif (err <= 0)\n\t\tgoto out;\n\n\terr = file_remove_privs(file);\n\tif (err)\n\t\tgoto out;\n\n\terr = file_update_time(file);\n\tif (err)\n\t\tgoto out;\n\n\tif (iocb->ki_flags & IOCB_DIRECT) {\n\t\tloff_t pos = iocb->ki_pos;\n\t\twritten = generic_file_direct_write(iocb, from, pos);\n\t\tif (written < 0 || !iov_iter_count(from))\n\t\t\tgoto out;\n\n\t\tpos += written;\n\n\t\twritten_buffered = fuse_perform_write(file, mapping, from, pos);\n\t\tif (written_buffered < 0) {\n\t\t\terr = written_buffered;\n\t\t\tgoto out;\n\t\t}\n\t\tendbyte = pos + written_buffered - 1;\n\n\t\terr = filemap_write_and_wait_range(file->f_mapping, pos,\n\t\t\t\t\t\t   endbyte);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tinvalidate_mapping_pages(file->f_mapping,\n\t\t\t\t\t pos >> PAGE_CACHE_SHIFT,\n\t\t\t\t\t endbyte >> PAGE_CACHE_SHIFT);\n\n\t\twritten += written_buffered;\n\t\tiocb->ki_pos = pos + written_buffered;\n\t} else {\n\t\twritten = fuse_perform_write(file, mapping, from, iocb->ki_pos);\n\t\tif (written >= 0)\n\t\t\tiocb->ki_pos += written;\n\t}\nout:\n\tcurrent->backing_dev_info = NULL;\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn written ? written : err;\n}\n\nstatic inline void fuse_page_descs_length_init(struct fuse_req *req,\n\t\tunsigned index, unsigned nr_pages)\n{\n\tint i;\n\n\tfor (i = index; i < index + nr_pages; i++)\n\t\treq->page_descs[i].length = PAGE_SIZE -\n\t\t\treq->page_descs[i].offset;\n}\n\nstatic inline unsigned long fuse_get_user_addr(const struct iov_iter *ii)\n{\n\treturn (unsigned long)ii->iov->iov_base + ii->iov_offset;\n}\n\nstatic inline size_t fuse_get_frag_size(const struct iov_iter *ii,\n\t\t\t\t\tsize_t max_size)\n{\n\treturn min(iov_iter_single_seg_count(ii), max_size);\n}\n\nstatic int fuse_get_user_pages(struct fuse_req *req, struct iov_iter *ii,\n\t\t\t       size_t *nbytesp, int write)\n{\n\tsize_t nbytes = 0;  /* # bytes already packed in req */\n\n\t/* Special case for kernel I/O: can copy directly into the buffer */\n\tif (ii->type & ITER_KVEC) {\n\t\tunsigned long user_addr = fuse_get_user_addr(ii);\n\t\tsize_t frag_size = fuse_get_frag_size(ii, *nbytesp);\n\n\t\tif (write)\n\t\t\treq->in.args[1].value = (void *) user_addr;\n\t\telse\n\t\t\treq->out.args[0].value = (void *) user_addr;\n\n\t\tiov_iter_advance(ii, frag_size);\n\t\t*nbytesp = frag_size;\n\t\treturn 0;\n\t}\n\n\twhile (nbytes < *nbytesp && req->num_pages < req->max_pages) {\n\t\tunsigned npages;\n\t\tsize_t start;\n\t\tssize_t ret = iov_iter_get_pages(ii,\n\t\t\t\t\t&req->pages[req->num_pages],\n\t\t\t\t\t*nbytesp - nbytes,\n\t\t\t\t\treq->max_pages - req->num_pages,\n\t\t\t\t\t&start);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tiov_iter_advance(ii, ret);\n\t\tnbytes += ret;\n\n\t\tret += start;\n\t\tnpages = (ret + PAGE_SIZE - 1) / PAGE_SIZE;\n\n\t\treq->page_descs[req->num_pages].offset = start;\n\t\tfuse_page_descs_length_init(req, req->num_pages, npages);\n\n\t\treq->num_pages += npages;\n\t\treq->page_descs[req->num_pages - 1].length -=\n\t\t\t(PAGE_SIZE - ret) & (PAGE_SIZE - 1);\n\t}\n\n\tif (write)\n\t\treq->in.argpages = 1;\n\telse\n\t\treq->out.argpages = 1;\n\n\t*nbytesp = nbytes;\n\n\treturn 0;\n}\n\nstatic inline int fuse_iter_npages(const struct iov_iter *ii_p)\n{\n\treturn iov_iter_npages(ii_p, FUSE_MAX_PAGES_PER_REQ);\n}\n\nssize_t fuse_direct_io(struct fuse_io_priv *io, struct iov_iter *iter,\n\t\t       loff_t *ppos, int flags)\n{\n\tint write = flags & FUSE_DIO_WRITE;\n\tint cuse = flags & FUSE_DIO_CUSE;\n\tstruct file *file = io->file;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tsize_t nmax = write ? fc->max_write : fc->max_read;\n\tloff_t pos = *ppos;\n\tsize_t count = iov_iter_count(iter);\n\tpgoff_t idx_from = pos >> PAGE_CACHE_SHIFT;\n\tpgoff_t idx_to = (pos + count - 1) >> PAGE_CACHE_SHIFT;\n\tssize_t res = 0;\n\tstruct fuse_req *req;\n\n\tif (io->async)\n\t\treq = fuse_get_req_for_background(fc, fuse_iter_npages(iter));\n\telse\n\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tif (!cuse && fuse_range_is_writeback(inode, idx_from, idx_to)) {\n\t\tif (!write)\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\tfuse_sync_writes(inode);\n\t\tif (!write)\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\twhile (count) {\n\t\tsize_t nres;\n\t\tfl_owner_t owner = current->files;\n\t\tsize_t nbytes = min(count, nmax);\n\t\tint err = fuse_get_user_pages(req, iter, &nbytes, write);\n\t\tif (err) {\n\t\t\tres = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write)\n\t\t\tnres = fuse_send_write(req, io, pos, nbytes, owner);\n\t\telse\n\t\t\tnres = fuse_send_read(req, io, pos, nbytes, owner);\n\n\t\tif (!io->async)\n\t\t\tfuse_release_user_pages(req, !write);\n\t\tif (req->out.h.error) {\n\t\t\tif (!res)\n\t\t\t\tres = req->out.h.error;\n\t\t\tbreak;\n\t\t} else if (nres > nbytes) {\n\t\t\tres = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcount -= nres;\n\t\tres += nres;\n\t\tpos += nres;\n\t\tif (nres != nbytes)\n\t\t\tbreak;\n\t\tif (count) {\n\t\t\tfuse_put_request(fc, req);\n\t\t\tif (io->async)\n\t\t\t\treq = fuse_get_req_for_background(fc,\n\t\t\t\t\tfuse_iter_npages(iter));\n\t\t\telse\n\t\t\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\t\t\tif (IS_ERR(req))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!IS_ERR(req))\n\t\tfuse_put_request(fc, req);\n\tif (res > 0)\n\t\t*ppos = pos;\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(fuse_direct_io);\n\nstatic ssize_t __fuse_direct_read(struct fuse_io_priv *io,\n\t\t\t\t  struct iov_iter *iter,\n\t\t\t\t  loff_t *ppos)\n{\n\tssize_t res;\n\tstruct file *file = io->file;\n\tstruct inode *inode = file_inode(file);\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tres = fuse_direct_io(io, iter, ppos, 0);\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res;\n}\n\nstatic ssize_t fuse_direct_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct fuse_io_priv io = { .async = 0, .file = iocb->ki_filp };\n\treturn __fuse_direct_read(&io, to, &iocb->ki_pos);\n}\n\nstatic ssize_t fuse_direct_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\tssize_t res;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\t/* Don't allow parallel writes to the same file */\n\tmutex_lock(&inode->i_mutex);\n\tres = generic_write_checks(iocb, from);\n\tif (res > 0)\n\t\tres = fuse_direct_io(&io, from, &iocb->ki_pos, FUSE_DIO_WRITE);\n\tfuse_invalidate_attr(inode);\n\tif (res > 0)\n\t\tfuse_write_update_size(inode, iocb->ki_pos);\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn res;\n}\n\nstatic void fuse_writepage_free(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tint i;\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\t__free_page(req->pages[i]);\n\n\tif (req->ff)\n\t\tfuse_file_put(req->ff, false);\n}\n\nstatic void fuse_writepage_finish(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct inode *inode = req->inode;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tint i;\n\n\tlist_del(&req->writepages_entry);\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tdec_wb_stat(&bdi->wb, WB_WRITEBACK);\n\t\tdec_zone_page_state(req->pages[i], NR_WRITEBACK_TEMP);\n\t\twb_writeout_inc(&bdi->wb);\n\t}\n\twake_up(&fi->page_waitq);\n}\n\n/* Called under fc->lock, may release and reacquire it */\nstatic void fuse_send_writepage(struct fuse_conn *fc, struct fuse_req *req,\n\t\t\t\tloff_t size)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(req->inode);\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\t__u64 data_size = req->num_pages * PAGE_CACHE_SIZE;\n\n\tif (!fc->connected)\n\t\tgoto out_free;\n\n\tif (inarg->offset + data_size <= size) {\n\t\tinarg->size = data_size;\n\t} else if (inarg->offset < size) {\n\t\tinarg->size = size - inarg->offset;\n\t} else {\n\t\t/* Got truncated off completely */\n\t\tgoto out_free;\n\t}\n\n\treq->in.args[1].size = inarg->size;\n\tfi->writectr++;\n\tfuse_request_send_background_locked(fc, req);\n\treturn;\n\n out_free:\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n\tfuse_put_request(fc, req);\n\tspin_lock(&fc->lock);\n}\n\n/*\n * If fi->writectr is positive (no truncate or fsync going on) send\n * all queued writepage requests.\n *\n * Called with fc->lock\n */\nvoid fuse_flush_writepages(struct inode *inode)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tsize_t crop = i_size_read(inode);\n\tstruct fuse_req *req;\n\n\twhile (fi->writectr >= 0 && !list_empty(&fi->queued_writes)) {\n\t\treq = list_entry(fi->queued_writes.next, struct fuse_req, list);\n\t\tlist_del_init(&req->list);\n\t\tfuse_send_writepage(fc, req, crop);\n\t}\n}\n\nstatic void fuse_writepage_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct inode *inode = req->inode;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tmapping_set_error(inode->i_mapping, req->out.h.error);\n\tspin_lock(&fc->lock);\n\twhile (req->misc.write.next) {\n\t\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\t\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\t\tstruct fuse_req *next = req->misc.write.next;\n\t\treq->misc.write.next = next->misc.write.next;\n\t\tnext->misc.write.next = NULL;\n\t\tnext->ff = fuse_file_get(req->ff);\n\t\tlist_add(&next->writepages_entry, &fi->writepages);\n\n\t\t/*\n\t\t * Skip fuse_flush_writepages() to make it easy to crop requests\n\t\t * based on primary request size.\n\t\t *\n\t\t * 1st case (trivial): there are no concurrent activities using\n\t\t * fuse_set/release_nowrite.  Then we're on safe side because\n\t\t * fuse_flush_writepages() would call fuse_send_writepage()\n\t\t * anyway.\n\t\t *\n\t\t * 2nd case: someone called fuse_set_nowrite and it is waiting\n\t\t * now for completion of all in-flight requests.  This happens\n\t\t * rarely and no more than once per page, so this should be\n\t\t * okay.\n\t\t *\n\t\t * 3rd case: someone (e.g. fuse_do_setattr()) is in the middle\n\t\t * of fuse_set_nowrite..fuse_release_nowrite section.  The fact\n\t\t * that fuse_set_nowrite returned implies that all in-flight\n\t\t * requests were completed along with all of their secondary\n\t\t * requests.  Further primary requests are blocked by negative\n\t\t * writectr.  Hence there cannot be any in-flight requests and\n\t\t * no invocations of fuse_writepage_end() while we're in\n\t\t * fuse_set_nowrite..fuse_release_nowrite section.\n\t\t */\n\t\tfuse_send_writepage(fc, next, inarg->offset + inarg->size);\n\t}\n\tfi->writectr--;\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n}\n\nstatic struct fuse_file *__fuse_write_file_get(struct fuse_conn *fc,\n\t\t\t\t\t       struct fuse_inode *fi)\n{\n\tstruct fuse_file *ff = NULL;\n\n\tspin_lock(&fc->lock);\n\tif (!list_empty(&fi->write_files)) {\n\t\tff = list_entry(fi->write_files.next, struct fuse_file,\n\t\t\t\twrite_entry);\n\t\tfuse_file_get(ff);\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ff;\n}\n\nstatic struct fuse_file *fuse_write_file_get(struct fuse_conn *fc,\n\t\t\t\t\t     struct fuse_inode *fi)\n{\n\tstruct fuse_file *ff = __fuse_write_file_get(fc, fi);\n\tWARN_ON(!ff);\n\treturn ff;\n}\n\nint fuse_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_file *ff;\n\tint err;\n\n\tff = __fuse_write_file_get(fc, fi);\n\terr = fuse_flush_times(inode, ff);\n\tif (ff)\n\t\tfuse_file_put(ff, 0);\n\n\treturn err;\n}\n\nstatic int fuse_writepage_locked(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tstruct page *tmp_page;\n\tint error = -ENOMEM;\n\n\tset_page_writeback(page);\n\n\treq = fuse_request_alloc_nofs(1);\n\tif (!req)\n\t\tgoto err;\n\n\t/* writeback always goes to bg_queue */\n\t__set_bit(FR_BACKGROUND, &req->flags);\n\ttmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!tmp_page)\n\t\tgoto err_free;\n\n\terror = -EIO;\n\treq->ff = fuse_write_file_get(fc, fi);\n\tif (!req->ff)\n\t\tgoto err_nofile;\n\n\tfuse_write_fill(req, req->ff, page_offset(page), 0);\n\n\tcopy_highpage(tmp_page, page);\n\treq->misc.write.in.write_flags |= FUSE_WRITE_CACHE;\n\treq->misc.write.next = NULL;\n\treq->in.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = tmp_page;\n\treq->page_descs[0].offset = 0;\n\treq->page_descs[0].length = PAGE_SIZE;\n\treq->end = fuse_writepage_end;\n\treq->inode = inode;\n\n\tinc_wb_stat(&inode_to_bdi(inode)->wb, WB_WRITEBACK);\n\tinc_zone_page_state(tmp_page, NR_WRITEBACK_TEMP);\n\n\tspin_lock(&fc->lock);\n\tlist_add(&req->writepages_entry, &fi->writepages);\n\tlist_add_tail(&req->list, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fc->lock);\n\n\tend_page_writeback(page);\n\n\treturn 0;\n\nerr_nofile:\n\t__free_page(tmp_page);\nerr_free:\n\tfuse_request_free(req);\nerr:\n\tend_page_writeback(page);\n\treturn error;\n}\n\nstatic int fuse_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint err;\n\n\tif (fuse_page_is_writeback(page->mapping->host, page->index)) {\n\t\t/*\n\t\t * ->writepages() should be called for sync() and friends.  We\n\t\t * should only get here on direct reclaim and then we are\n\t\t * allowed to skip a page which is already in flight\n\t\t */\n\t\tWARN_ON(wbc->sync_mode == WB_SYNC_ALL);\n\n\t\tredirty_page_for_writepage(wbc, page);\n\t\treturn 0;\n\t}\n\n\terr = fuse_writepage_locked(page);\n\tunlock_page(page);\n\n\treturn err;\n}\n\nstruct fuse_fill_wb_data {\n\tstruct fuse_req *req;\n\tstruct fuse_file *ff;\n\tstruct inode *inode;\n\tstruct page **orig_pages;\n};\n\nstatic void fuse_writepages_send(struct fuse_fill_wb_data *data)\n{\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint num_pages = req->num_pages;\n\tint i;\n\n\treq->ff = fuse_file_get(data->ff);\n\tspin_lock(&fc->lock);\n\tlist_add_tail(&req->list, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fc->lock);\n\n\tfor (i = 0; i < num_pages; i++)\n\t\tend_page_writeback(data->orig_pages[i]);\n}\n\nstatic bool fuse_writepage_in_flight(struct fuse_req *new_req,\n\t\t\t\t     struct page *page)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(new_req->inode);\n\tstruct fuse_inode *fi = get_fuse_inode(new_req->inode);\n\tstruct fuse_req *tmp;\n\tstruct fuse_req *old_req;\n\tbool found = false;\n\tpgoff_t curr_index;\n\n\tBUG_ON(new_req->num_pages != 0);\n\n\tspin_lock(&fc->lock);\n\tlist_del(&new_req->writepages_entry);\n\tlist_for_each_entry(old_req, &fi->writepages, writepages_entry) {\n\t\tBUG_ON(old_req->inode != new_req->inode);\n\t\tcurr_index = old_req->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (curr_index <= page->index &&\n\t\t    page->index < curr_index + old_req->num_pages) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tlist_add(&new_req->writepages_entry, &fi->writepages);\n\t\tgoto out_unlock;\n\t}\n\n\tnew_req->num_pages = 1;\n\tfor (tmp = old_req; tmp != NULL; tmp = tmp->misc.write.next) {\n\t\tBUG_ON(tmp->inode != new_req->inode);\n\t\tcurr_index = tmp->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (tmp->num_pages == 1 &&\n\t\t    curr_index == page->index) {\n\t\t\told_req = tmp;\n\t\t}\n\t}\n\n\tif (old_req->num_pages == 1 && test_bit(FR_PENDING, &old_req->flags)) {\n\t\tstruct backing_dev_info *bdi = inode_to_bdi(page->mapping->host);\n\n\t\tcopy_highpage(old_req->pages[0], page);\n\t\tspin_unlock(&fc->lock);\n\n\t\tdec_wb_stat(&bdi->wb, WB_WRITEBACK);\n\t\tdec_zone_page_state(page, NR_WRITEBACK_TEMP);\n\t\twb_writeout_inc(&bdi->wb);\n\t\tfuse_writepage_free(fc, new_req);\n\t\tfuse_request_free(new_req);\n\t\tgoto out;\n\t} else {\n\t\tnew_req->misc.write.next = old_req->misc.write.next;\n\t\told_req->misc.write.next = new_req;\n\t}\nout_unlock:\n\tspin_unlock(&fc->lock);\nout:\n\treturn found;\n}\n\nstatic int fuse_writepages_fill(struct page *page,\n\t\tstruct writeback_control *wbc, void *_data)\n{\n\tstruct fuse_fill_wb_data *data = _data;\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct page *tmp_page;\n\tbool is_writeback;\n\tint err;\n\n\tif (!data->ff) {\n\t\terr = -EIO;\n\t\tdata->ff = fuse_write_file_get(fc, get_fuse_inode(inode));\n\t\tif (!data->ff)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Being under writeback is unlikely but possible.  For example direct\n\t * read to an mmaped fuse file will set the page dirty twice; once when\n\t * the pages are faulted with get_user_pages(), and then after the read\n\t * completed.\n\t */\n\tis_writeback = fuse_page_is_writeback(inode, page->index);\n\n\tif (req && req->num_pages &&\n\t    (is_writeback || req->num_pages == FUSE_MAX_PAGES_PER_REQ ||\n\t     (req->num_pages + 1) * PAGE_CACHE_SIZE > fc->max_write ||\n\t     data->orig_pages[req->num_pages - 1]->index + 1 != page->index)) {\n\t\tfuse_writepages_send(data);\n\t\tdata->req = NULL;\n\t}\n\terr = -ENOMEM;\n\ttmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!tmp_page)\n\t\tgoto out_unlock;\n\n\t/*\n\t * The page must not be redirtied until the writeout is completed\n\t * (i.e. userspace has sent a reply to the write request).  Otherwise\n\t * there could be more than one temporary page instance for each real\n\t * page.\n\t *\n\t * This is ensured by holding the page lock in page_mkwrite() while\n\t * checking fuse_page_is_writeback().  We already hold the page lock\n\t * since clear_page_dirty_for_io() and keep it held until we add the\n\t * request to the fi->writepages list and increment req->num_pages.\n\t * After this fuse_page_is_writeback() will indicate that the page is\n\t * under writeback, so we can release the page lock.\n\t */\n\tif (data->req == NULL) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\terr = -ENOMEM;\n\t\treq = fuse_request_alloc_nofs(FUSE_MAX_PAGES_PER_REQ);\n\t\tif (!req) {\n\t\t\t__free_page(tmp_page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tfuse_write_fill(req, data->ff, page_offset(page), 0);\n\t\treq->misc.write.in.write_flags |= FUSE_WRITE_CACHE;\n\t\treq->misc.write.next = NULL;\n\t\treq->in.argpages = 1;\n\t\t__set_bit(FR_BACKGROUND, &req->flags);\n\t\treq->num_pages = 0;\n\t\treq->end = fuse_writepage_end;\n\t\treq->inode = inode;\n\n\t\tspin_lock(&fc->lock);\n\t\tlist_add(&req->writepages_entry, &fi->writepages);\n\t\tspin_unlock(&fc->lock);\n\n\t\tdata->req = req;\n\t}\n\tset_page_writeback(page);\n\n\tcopy_highpage(tmp_page, page);\n\treq->pages[req->num_pages] = tmp_page;\n\treq->page_descs[req->num_pages].offset = 0;\n\treq->page_descs[req->num_pages].length = PAGE_SIZE;\n\n\tinc_wb_stat(&inode_to_bdi(inode)->wb, WB_WRITEBACK);\n\tinc_zone_page_state(tmp_page, NR_WRITEBACK_TEMP);\n\n\terr = 0;\n\tif (is_writeback && fuse_writepage_in_flight(req, page)) {\n\t\tend_page_writeback(page);\n\t\tdata->req = NULL;\n\t\tgoto out_unlock;\n\t}\n\tdata->orig_pages[req->num_pages] = page;\n\n\t/*\n\t * Protected by fc->lock against concurrent access by\n\t * fuse_page_is_writeback().\n\t */\n\tspin_lock(&fc->lock);\n\treq->num_pages++;\n\tspin_unlock(&fc->lock);\n\nout_unlock:\n\tunlock_page(page);\n\n\treturn err;\n}\n\nstatic int fuse_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_fill_wb_data data;\n\tint err;\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\tdata.inode = inode;\n\tdata.req = NULL;\n\tdata.ff = NULL;\n\n\terr = -ENOMEM;\n\tdata.orig_pages = kcalloc(FUSE_MAX_PAGES_PER_REQ,\n\t\t\t\t  sizeof(struct page *),\n\t\t\t\t  GFP_NOFS);\n\tif (!data.orig_pages)\n\t\tgoto out;\n\n\terr = write_cache_pages(mapping, wbc, fuse_writepages_fill, &data);\n\tif (data.req) {\n\t\t/* Ignore errors if we can write at least one page */\n\t\tBUG_ON(!data.req->num_pages);\n\t\tfuse_writepages_send(&data);\n\t\terr = 0;\n\t}\n\tif (data.ff)\n\t\tfuse_file_put(data.ff, false);\n\n\tkfree(data.orig_pages);\nout:\n\treturn err;\n}\n\n/*\n * It's worthy to make sure that space is reserved on disk for the write,\n * but how to implement it without killing performance need more thinking.\n */\nstatic int fuse_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct fuse_conn *fc = get_fuse_conn(file_inode(file));\n\tstruct page *page;\n\tloff_t fsize;\n\tint err = -ENOMEM;\n\n\tWARN_ON(!fc->writeback_cache);\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\tgoto error;\n\n\tfuse_wait_on_page_writeback(mapping->host, page->index);\n\n\tif (PageUptodate(page) || len == PAGE_CACHE_SIZE)\n\t\tgoto success;\n\t/*\n\t * Check if the start this page comes after the end of file, in which\n\t * case the readpage can be optimized away.\n\t */\n\tfsize = i_size_read(mapping->host);\n\tif (fsize <= (pos & PAGE_CACHE_MASK)) {\n\t\tsize_t off = pos & ~PAGE_CACHE_MASK;\n\t\tif (off)\n\t\t\tzero_user_segment(page, 0, off);\n\t\tgoto success;\n\t}\n\terr = fuse_do_readpage(file, page);\n\tif (err)\n\t\tgoto cleanup;\nsuccess:\n\t*pagep = page;\n\treturn 0;\n\ncleanup:\n\tunlock_page(page);\n\tpage_cache_release(page);\nerror:\n\treturn err;\n}\n\nstatic int fuse_write_end(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned copied,\n\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\n\tif (!PageUptodate(page)) {\n\t\t/* Zero any unwritten bytes at the end of the page */\n\t\tsize_t endoff = (pos + copied) & ~PAGE_CACHE_MASK;\n\t\tif (endoff)\n\t\t\tzero_user_segment(page, endoff, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t}\n\n\tfuse_write_update_size(inode, pos + copied);\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn copied;\n}\n\nstatic int fuse_launder_page(struct page *page)\n{\n\tint err = 0;\n\tif (clear_page_dirty_for_io(page)) {\n\t\tstruct inode *inode = page->mapping->host;\n\t\terr = fuse_writepage_locked(page);\n\t\tif (!err)\n\t\t\tfuse_wait_on_page_writeback(inode, page->index);\n\t}\n\treturn err;\n}\n\n/*\n * Write back dirty pages now, because there may not be any suitable\n * open files later\n */\nstatic void fuse_vma_close(struct vm_area_struct *vma)\n{\n\tfilemap_write_and_wait(vma->vm_file->f_mapping);\n}\n\n/*\n * Wait for writeback against this page to complete before allowing it\n * to be marked dirty again, and hence written back again, possibly\n * before the previous writepage completed.\n *\n * Block here, instead of in ->writepage(), so that the userspace fs\n * can only block processes actually operating on the filesystem.\n *\n * Otherwise unprivileged userspace fs would be able to block\n * unrelated:\n *\n * - page migration\n * - sync(2)\n * - try_to_free_pages() with order > PAGE_ALLOC_COSTLY_ORDER\n */\nstatic int fuse_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\n\tfile_update_time(vma->vm_file);\n\tlock_page(page);\n\tif (page->mapping != inode->i_mapping) {\n\t\tunlock_page(page);\n\t\treturn VM_FAULT_NOPAGE;\n\t}\n\n\tfuse_wait_on_page_writeback(inode, page->index);\n\treturn VM_FAULT_LOCKED;\n}\n\nstatic const struct vm_operations_struct fuse_file_vm_ops = {\n\t.close\t\t= fuse_vma_close,\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= fuse_page_mkwrite,\n};\n\nstatic int fuse_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tif ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE))\n\t\tfuse_link_write_file(file);\n\n\tfile_accessed(file);\n\tvma->vm_ops = &fuse_file_vm_ops;\n\treturn 0;\n}\n\nstatic int fuse_direct_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\t/* Can't provide the coherency needed for MAP_SHARED */\n\tif (vma->vm_flags & VM_MAYSHARE)\n\t\treturn -ENODEV;\n\n\tinvalidate_inode_pages2(file->f_mapping);\n\n\treturn generic_file_mmap(file, vma);\n}\n\nstatic int convert_fuse_file_lock(const struct fuse_file_lock *ffl,\n\t\t\t\t  struct file_lock *fl)\n{\n\tswitch (ffl->type) {\n\tcase F_UNLCK:\n\t\tbreak;\n\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\tif (ffl->start > OFFSET_MAX || ffl->end > OFFSET_MAX ||\n\t\t    ffl->end < ffl->start)\n\t\t\treturn -EIO;\n\n\t\tfl->fl_start = ffl->start;\n\t\tfl->fl_end = ffl->end;\n\t\tfl->fl_pid = ffl->pid;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EIO;\n\t}\n\tfl->fl_type = ffl->type;\n\treturn 0;\n}\n\nstatic void fuse_lk_fill(struct fuse_args *args, struct file *file,\n\t\t\t const struct file_lock *fl, int opcode, pid_t pid,\n\t\t\t int flock, struct fuse_lk_in *inarg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\n\tmemset(inarg, 0, sizeof(*inarg));\n\tinarg->fh = ff->fh;\n\tinarg->owner = fuse_lock_owner_id(fc, fl->fl_owner);\n\tinarg->lk.start = fl->fl_start;\n\tinarg->lk.end = fl->fl_end;\n\tinarg->lk.type = fl->fl_type;\n\tinarg->lk.pid = pid;\n\tif (flock)\n\t\tinarg->lk_flags |= FUSE_LK_FLOCK;\n\targs->in.h.opcode = opcode;\n\targs->in.h.nodeid = get_node_id(inode);\n\targs->in.numargs = 1;\n\targs->in.args[0].size = sizeof(*inarg);\n\targs->in.args[0].value = inarg;\n}\n\nstatic int fuse_getlk(struct file *file, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_lk_in inarg;\n\tstruct fuse_lk_out outarg;\n\tint err;\n\n\tfuse_lk_fill(&args, file, fl, FUSE_GETLK, 0, 0, &inarg);\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err)\n\t\terr = convert_fuse_file_lock(&outarg.lk, fl);\n\n\treturn err;\n}\n\nstatic int fuse_setlk(struct file *file, struct file_lock *fl, int flock)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_lk_in inarg;\n\tint opcode = (fl->fl_flags & FL_SLEEP) ? FUSE_SETLKW : FUSE_SETLK;\n\tpid_t pid = fl->fl_type != F_UNLCK ? current->tgid : 0;\n\tint err;\n\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant) {\n\t\t/* NLM needs asynchronous locks, which we don't support yet */\n\t\treturn -ENOLCK;\n\t}\n\n\t/* Unlock on close is handled by the flush method */\n\tif (fl->fl_flags & FL_CLOSE)\n\t\treturn 0;\n\n\tfuse_lk_fill(&args, file, fl, opcode, pid, flock, &inarg);\n\terr = fuse_simple_request(fc, &args);\n\n\t/* locking is restartable */\n\tif (err == -EINTR)\n\t\terr = -ERESTARTSYS;\n\n\treturn err;\n}\n\nstatic int fuse_file_lock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\n\tif (cmd == F_CANCELLK) {\n\t\terr = 0;\n\t} else if (cmd == F_GETLK) {\n\t\tif (fc->no_lock) {\n\t\t\tposix_test_lock(file, fl);\n\t\t\terr = 0;\n\t\t} else\n\t\t\terr = fuse_getlk(file, fl);\n\t} else {\n\t\tif (fc->no_lock)\n\t\t\terr = posix_lock_file(file, fl, NULL);\n\t\telse\n\t\t\terr = fuse_setlk(file, fl, 0);\n\t}\n\treturn err;\n}\n\nstatic int fuse_file_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\n\tif (fc->no_flock) {\n\t\terr = flock_lock_file_wait(file, fl);\n\t} else {\n\t\tstruct fuse_file *ff = file->private_data;\n\n\t\t/* emulate flock with POSIX locks */\n\t\tff->flock = true;\n\t\terr = fuse_setlk(file, fl, 1);\n\t}\n\n\treturn err;\n}\n\nstatic sector_t fuse_bmap(struct address_space *mapping, sector_t block)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_bmap_in inarg;\n\tstruct fuse_bmap_out outarg;\n\tint err;\n\n\tif (!inode->i_sb->s_bdev || fc->no_bmap)\n\t\treturn 0;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.block = block;\n\tinarg.blocksize = inode->i_sb->s_blocksize;\n\targs.in.h.opcode = FUSE_BMAP;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS)\n\t\tfc->no_bmap = 1;\n\n\treturn err ? 0 : outarg.block;\n}\n\nstatic loff_t fuse_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t retval;\n\tstruct inode *inode = file_inode(file);\n\n\t/* No i_mutex protection necessary for SEEK_CUR and SEEK_SET */\n\tif (whence == SEEK_CUR || whence == SEEK_SET)\n\t\treturn generic_file_llseek(file, offset, whence);\n\n\tmutex_lock(&inode->i_mutex);\n\tretval = fuse_update_attributes(inode, NULL, file, NULL);\n\tif (!retval)\n\t\tretval = generic_file_llseek(file, offset, whence);\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn retval;\n}\n\nstatic int fuse_ioctl_copy_user(struct page **pages, struct iovec *iov,\n\t\t\tunsigned int nr_segs, size_t bytes, bool to_user)\n{\n\tstruct iov_iter ii;\n\tint page_idx = 0;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tiov_iter_init(&ii, to_user ? READ : WRITE, iov, nr_segs, bytes);\n\n\twhile (iov_iter_count(&ii)) {\n\t\tstruct page *page = pages[page_idx++];\n\t\tsize_t todo = min_t(size_t, PAGE_SIZE, iov_iter_count(&ii));\n\t\tvoid *kaddr;\n\n\t\tkaddr = kmap(page);\n\n\t\twhile (todo) {\n\t\t\tchar __user *uaddr = ii.iov->iov_base + ii.iov_offset;\n\t\t\tsize_t iov_len = ii.iov->iov_len - ii.iov_offset;\n\t\t\tsize_t copy = min(todo, iov_len);\n\t\t\tsize_t left;\n\n\t\t\tif (!to_user)\n\t\t\t\tleft = copy_from_user(kaddr, uaddr, copy);\n\t\t\telse\n\t\t\t\tleft = copy_to_user(uaddr, kaddr, copy);\n\n\t\t\tif (unlikely(left))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tiov_iter_advance(&ii, copy);\n\t\t\ttodo -= copy;\n\t\t\tkaddr += copy;\n\t\t}\n\n\t\tkunmap(page);\n\t}\n\n\treturn 0;\n}\n\n/*\n * CUSE servers compiled on 32bit broke on 64bit kernels because the\n * ABI was defined to be 'struct iovec' which is different on 32bit\n * and 64bit.  Fortunately we can determine which structure the server\n * used from the size of the reply.\n */\nstatic int fuse_copy_ioctl_iovec_old(struct iovec *dst, void *src,\n\t\t\t\t     size_t transferred, unsigned count,\n\t\t\t\t     bool is_compat)\n{\n#ifdef CONFIG_COMPAT\n\tif (count * sizeof(struct compat_iovec) == transferred) {\n\t\tstruct compat_iovec *ciov = src;\n\t\tunsigned i;\n\n\t\t/*\n\t\t * With this interface a 32bit server cannot support\n\t\t * non-compat (i.e. ones coming from 64bit apps) ioctl\n\t\t * requests\n\t\t */\n\t\tif (!is_compat)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tdst[i].iov_base = compat_ptr(ciov[i].iov_base);\n\t\t\tdst[i].iov_len = ciov[i].iov_len;\n\t\t}\n\t\treturn 0;\n\t}\n#endif\n\n\tif (count * sizeof(struct iovec) != transferred)\n\t\treturn -EIO;\n\n\tmemcpy(dst, src, transferred);\n\treturn 0;\n}\n\n/* Make sure iov_length() won't overflow */\nstatic int fuse_verify_ioctl_iov(struct iovec *iov, size_t count)\n{\n\tsize_t n;\n\tu32 max = FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT;\n\n\tfor (n = 0; n < count; n++, iov++) {\n\t\tif (iov->iov_len > (size_t) max)\n\t\t\treturn -ENOMEM;\n\t\tmax -= iov->iov_len;\n\t}\n\treturn 0;\n}\n\nstatic int fuse_copy_ioctl_iovec(struct fuse_conn *fc, struct iovec *dst,\n\t\t\t\t void *src, size_t transferred, unsigned count,\n\t\t\t\t bool is_compat)\n{\n\tunsigned i;\n\tstruct fuse_ioctl_iovec *fiov = src;\n\n\tif (fc->minor < 16) {\n\t\treturn fuse_copy_ioctl_iovec_old(dst, src, transferred,\n\t\t\t\t\t\t count, is_compat);\n\t}\n\n\tif (count * sizeof(struct fuse_ioctl_iovec) != transferred)\n\t\treturn -EIO;\n\n\tfor (i = 0; i < count; i++) {\n\t\t/* Did the server supply an inappropriate value? */\n\t\tif (fiov[i].base != (unsigned long) fiov[i].base ||\n\t\t    fiov[i].len != (unsigned long) fiov[i].len)\n\t\t\treturn -EIO;\n\n\t\tdst[i].iov_base = (void __user *) (unsigned long) fiov[i].base;\n\t\tdst[i].iov_len = (size_t) fiov[i].len;\n\n#ifdef CONFIG_COMPAT\n\t\tif (is_compat &&\n\t\t    (ptr_to_compat(dst[i].iov_base) != fiov[i].base ||\n\t\t     (compat_size_t) dst[i].iov_len != fiov[i].len))\n\t\t\treturn -EIO;\n#endif\n\t}\n\n\treturn 0;\n}\n\n\n/*\n * For ioctls, there is no generic way to determine how much memory\n * needs to be read and/or written.  Furthermore, ioctls are allowed\n * to dereference the passed pointer, so the parameter requires deep\n * copying but FUSE has no idea whatsoever about what to copy in or\n * out.\n *\n * This is solved by allowing FUSE server to retry ioctl with\n * necessary in/out iovecs.  Let's assume the ioctl implementation\n * needs to read in the following structure.\n *\n * struct a {\n *\tchar\t*buf;\n *\tsize_t\tbuflen;\n * }\n *\n * On the first callout to FUSE server, inarg->in_size and\n * inarg->out_size will be NULL; then, the server completes the ioctl\n * with FUSE_IOCTL_RETRY set in out->flags, out->in_iovs set to 1 and\n * the actual iov array to\n *\n * { { .iov_base = inarg.arg,\t.iov_len = sizeof(struct a) } }\n *\n * which tells FUSE to copy in the requested area and retry the ioctl.\n * On the second round, the server has access to the structure and\n * from that it can tell what to look for next, so on the invocation,\n * it sets FUSE_IOCTL_RETRY, out->in_iovs to 2 and iov array to\n *\n * { { .iov_base = inarg.arg,\t.iov_len = sizeof(struct a)\t},\n *   { .iov_base = a.buf,\t.iov_len = a.buflen\t\t} }\n *\n * FUSE will copy both struct a and the pointed buffer from the\n * process doing the ioctl and retry ioctl with both struct a and the\n * buffer.\n *\n * This time, FUSE server has everything it needs and completes ioctl\n * without FUSE_IOCTL_RETRY which finishes the ioctl call.\n *\n * Copying data out works the same way.\n *\n * Note that if FUSE_IOCTL_UNRESTRICTED is clear, the kernel\n * automatically initializes in and out iovs by decoding @cmd with\n * _IOC_* macros and the server is not allowed to request RETRY.  This\n * limits ioctl data transfers to well-formed ioctls and is the forced\n * behavior for all FUSE servers.\n */\nlong fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct fuse_req *req = NULL;\n\tstruct page **pages = NULL;\n\tstruct iovec *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;\n\tsize_t in_size, out_size, transferred;\n\tint err;\n\n#if BITS_PER_LONG == 32\n\tinarg.flags |= FUSE_IOCTL_32BIT;\n#else\n\tif (flags & FUSE_IOCTL_COMPAT)\n\t\tinarg.flags |= FUSE_IOCTL_32BIT;\n#endif\n\n\t/* assume all the iovs returned by client always fits in a page */\n\tBUILD_BUG_ON(sizeof(struct fuse_ioctl_iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tpages = kcalloc(FUSE_MAX_PAGES_PER_REQ, sizeof(pages[0]), GFP_KERNEL);\n\tiov_page = (struct iovec *) __get_free_page(GFP_KERNEL);\n\tif (!pages || !iov_page)\n\t\tgoto out;\n\n\t/*\n\t * If restricted, initialize IO parameters as encoded in @cmd.\n\t * RETRY from server is not allowed.\n\t */\n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = iov_page;\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t/*\n\t * Out data can be used either for actual out data or iovs,\n\t * make sure there always is at least one page.\n\t */\n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t/* make sure there are enough buffer pages and init request with them */\n\terr = -ENOMEM;\n\tif (max_pages > FUSE_MAX_PAGES_PER_REQ)\n\t\tgoto out;\n\twhile (num_pages < max_pages) {\n\t\tpages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!pages[num_pages])\n\t\t\tgoto out;\n\t\tnum_pages++;\n\t}\n\n\treq = fuse_get_req(fc, num_pages);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\tmemcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);\n\treq->num_pages = num_pages;\n\tfuse_page_descs_length_init(req, 0, req->num_pages);\n\n\t/* okay, let's send it to the client */\n\treq->in.h.opcode = FUSE_IOCTL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tif (in_size) {\n\t\treq->in.numargs++;\n\t\treq->in.args[1].size = in_size;\n\t\treq->in.argpages = 1;\n\n\t\terr = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,\n\t\t\t\t\t   false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\treq->out.args[1].size = out_size;\n\treq->out.argpages = 1;\n\treq->out.argvar = 1;\n\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\ttransferred = req->out.args[1].size;\n\tfuse_put_request(fc, req);\n\treq = NULL;\n\tif (err)\n\t\tgoto out;\n\n\t/* did it ask for retry? */\n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tvoid *vaddr;\n\n\t\t/* no retry if in restricted mode */\n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t/*\n\t\t * Make sure things are in boundary, separate checks\n\t\t * are to protect against overflow.\n\t\t */\n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_atomic(pages[0]);\n\t\terr = fuse_copy_ioctl_iovec(fc, iov_page, vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_atomic(vaddr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tin_iov = iov_page;\n\t\tout_iov = in_iov + in_iovs;\n\n\t\terr = fuse_verify_ioctl_iov(in_iov, in_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = fuse_verify_ioctl_iov(out_iov, out_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tgoto retry;\n\t}\n\n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);\n out:\n\tif (req)\n\t\tfuse_put_request(fc, req);\n\tfree_page((unsigned long) iov_page);\n\twhile (num_pages)\n\t\t__free_page(pages[--num_pages]);\n\tkfree(pages);\n\n\treturn err ? err : outarg.result;\n}\nEXPORT_SYMBOL_GPL(fuse_do_ioctl);\n\nlong fuse_ioctl_common(struct file *file, unsigned int cmd,\n\t\t       unsigned long arg, unsigned int flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}\n\nstatic long fuse_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\treturn fuse_ioctl_common(file, cmd, arg, 0);\n}\n\nstatic long fuse_file_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t   unsigned long arg)\n{\n\treturn fuse_ioctl_common(file, cmd, arg, FUSE_IOCTL_COMPAT);\n}\n\n/*\n * All files which have been polled are linked to RB tree\n * fuse_conn->polled_files which is indexed by kh.  Walk the tree and\n * find the matching one.\n */\nstatic struct rb_node **fuse_find_polled_node(struct fuse_conn *fc, u64 kh,\n\t\t\t\t\t      struct rb_node **parent_out)\n{\n\tstruct rb_node **link = &fc->polled_files.rb_node;\n\tstruct rb_node *last = NULL;\n\n\twhile (*link) {\n\t\tstruct fuse_file *ff;\n\n\t\tlast = *link;\n\t\tff = rb_entry(last, struct fuse_file, polled_node);\n\n\t\tif (kh < ff->kh)\n\t\t\tlink = &last->rb_left;\n\t\telse if (kh > ff->kh)\n\t\t\tlink = &last->rb_right;\n\t\telse\n\t\t\treturn link;\n\t}\n\n\tif (parent_out)\n\t\t*parent_out = last;\n\treturn link;\n}\n\n/*\n * The file is about to be polled.  Make sure it's on the polled_files\n * RB tree.  Note that files once added to the polled_files tree are\n * not removed before the file is released.  This is because a file\n * polled once is likely to be polled again.\n */\nstatic void fuse_register_polled_file(struct fuse_conn *fc,\n\t\t\t\t      struct fuse_file *ff)\n{\n\tspin_lock(&fc->lock);\n\tif (RB_EMPTY_NODE(&ff->polled_node)) {\n\t\tstruct rb_node **link, *uninitialized_var(parent);\n\n\t\tlink = fuse_find_polled_node(fc, ff->kh, &parent);\n\t\tBUG_ON(*link);\n\t\trb_link_node(&ff->polled_node, parent, link);\n\t\trb_insert_color(&ff->polled_node, &fc->polled_files);\n\t}\n\tspin_unlock(&fc->lock);\n}\n\nunsigned fuse_file_poll(struct file *file, poll_table *wait)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_poll_in inarg = { .fh = ff->fh, .kh = ff->kh };\n\tstruct fuse_poll_out outarg;\n\tFUSE_ARGS(args);\n\tint err;\n\n\tif (fc->no_poll)\n\t\treturn DEFAULT_POLLMASK;\n\n\tpoll_wait(file, &ff->poll_wait, wait);\n\tinarg.events = (__u32)poll_requested_events(wait);\n\n\t/*\n\t * Ask for notification iff there's someone waiting for it.\n\t * The client may ignore the flag and always notify.\n\t */\n\tif (waitqueue_active(&ff->poll_wait)) {\n\t\tinarg.flags |= FUSE_POLL_SCHEDULE_NOTIFY;\n\t\tfuse_register_polled_file(fc, ff);\n\t}\n\n\targs.in.h.opcode = FUSE_POLL;\n\targs.in.h.nodeid = ff->nodeid;\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\n\tif (!err)\n\t\treturn outarg.revents;\n\tif (err == -ENOSYS) {\n\t\tfc->no_poll = 1;\n\t\treturn DEFAULT_POLLMASK;\n\t}\n\treturn POLLERR;\n}\nEXPORT_SYMBOL_GPL(fuse_file_poll);\n\n/*\n * This is called from fuse_handle_notify() on FUSE_NOTIFY_POLL and\n * wakes up the poll waiters.\n */\nint fuse_notify_poll_wakeup(struct fuse_conn *fc,\n\t\t\t    struct fuse_notify_poll_wakeup_out *outarg)\n{\n\tu64 kh = outarg->kh;\n\tstruct rb_node **link;\n\n\tspin_lock(&fc->lock);\n\n\tlink = fuse_find_polled_node(fc, kh, NULL);\n\tif (*link) {\n\t\tstruct fuse_file *ff;\n\n\t\tff = rb_entry(*link, struct fuse_file, polled_node);\n\t\twake_up_interruptible_sync(&ff->poll_wait);\n\t}\n\n\tspin_unlock(&fc->lock);\n\treturn 0;\n}\n\nstatic void fuse_do_truncate(struct file *file)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct iattr attr;\n\n\tattr.ia_valid = ATTR_SIZE;\n\tattr.ia_size = i_size_read(inode);\n\n\tattr.ia_file = file;\n\tattr.ia_valid |= ATTR_FILE;\n\n\tfuse_do_setattr(inode, &attr, file);\n}\n\nstatic inline loff_t fuse_round_up(loff_t off)\n{\n\treturn round_up(off, FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT);\n}\n\nstatic ssize_t\nfuse_direct_IO(struct kiocb *iocb, struct iov_iter *iter, loff_t offset)\n{\n\tDECLARE_COMPLETION_ONSTACK(wait);\n\tssize_t ret = 0;\n\tstruct file *file = iocb->ki_filp;\n\tstruct fuse_file *ff = file->private_data;\n\tbool async_dio = ff->fc->async_dio;\n\tloff_t pos = 0;\n\tstruct inode *inode;\n\tloff_t i_size;\n\tsize_t count = iov_iter_count(iter);\n\tstruct fuse_io_priv *io;\n\n\tpos = offset;\n\tinode = file->f_mapping->host;\n\ti_size = i_size_read(inode);\n\n\tif ((iov_iter_rw(iter) == READ) && (offset > i_size))\n\t\treturn 0;\n\n\t/* optimization for short read */\n\tif (async_dio && iov_iter_rw(iter) != WRITE && offset + count > i_size) {\n\t\tif (offset >= i_size)\n\t\t\treturn 0;\n\t\tiov_iter_truncate(iter, fuse_round_up(i_size - offset));\n\t\tcount = iov_iter_count(iter);\n\t}\n\n\tio = kmalloc(sizeof(struct fuse_io_priv), GFP_KERNEL);\n\tif (!io)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&io->lock);\n\tio->reqs = 1;\n\tio->bytes = -1;\n\tio->size = 0;\n\tio->offset = offset;\n\tio->write = (iov_iter_rw(iter) == WRITE);\n\tio->err = 0;\n\tio->file = file;\n\t/*\n\t * By default, we want to optimize all I/Os with async request\n\t * submission to the client filesystem if supported.\n\t */\n\tio->async = async_dio;\n\tio->iocb = iocb;\n\n\t/*\n\t * We cannot asynchronously extend the size of a file. We have no method\n\t * to wait on real async I/O requests, so we must submit this request\n\t * synchronously.\n\t */\n\tif (!is_sync_kiocb(iocb) && (offset + count > i_size) &&\n\t    iov_iter_rw(iter) == WRITE)\n\t\tio->async = false;\n\n\tif (io->async && is_sync_kiocb(iocb))\n\t\tio->done = &wait;\n\n\tif (iov_iter_rw(iter) == WRITE) {\n\t\tret = fuse_direct_io(io, iter, &pos, FUSE_DIO_WRITE);\n\t\tfuse_invalidate_attr(inode);\n\t} else {\n\t\tret = __fuse_direct_read(io, iter, &pos);\n\t}\n\n\tif (io->async) {\n\t\tfuse_aio_complete(io, ret < 0 ? ret : 0, -1);\n\n\t\t/* we have a non-extending, async request, so return */\n\t\tif (!is_sync_kiocb(iocb))\n\t\t\treturn -EIOCBQUEUED;\n\n\t\twait_for_completion(&wait);\n\t\tret = fuse_get_res_by_io(io);\n\t}\n\n\tkfree(io);\n\n\tif (iov_iter_rw(iter) == WRITE) {\n\t\tif (ret > 0)\n\t\t\tfuse_write_update_size(inode, pos);\n\t\telse if (ret < 0 && offset + count > i_size)\n\t\t\tfuse_do_truncate(file);\n\t}\n\n\treturn ret;\n}\n\nstatic long fuse_file_fallocate(struct file *file, int mode, loff_t offset,\n\t\t\t\tloff_t length)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_conn *fc = ff->fc;\n\tFUSE_ARGS(args);\n\tstruct fuse_fallocate_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.offset = offset,\n\t\t.length = length,\n\t\t.mode = mode\n\t};\n\tint err;\n\tbool lock_inode = !(mode & FALLOC_FL_KEEP_SIZE) ||\n\t\t\t   (mode & FALLOC_FL_PUNCH_HOLE);\n\n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (fc->no_fallocate)\n\t\treturn -EOPNOTSUPP;\n\n\tif (lock_inode) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tif (mode & FALLOC_FL_PUNCH_HOLE) {\n\t\t\tloff_t endbyte = offset + length - 1;\n\t\t\terr = filemap_write_and_wait_range(inode->i_mapping,\n\t\t\t\t\t\t\t   offset, endbyte);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tfuse_sync_writes(inode);\n\t\t}\n\t}\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE))\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\targs.in.h.opcode = FUSE_FALLOCATE;\n\targs.in.h.nodeid = ff->nodeid;\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS) {\n\t\tfc->no_fallocate = 1;\n\t\terr = -EOPNOTSUPP;\n\t}\n\tif (err)\n\t\tgoto out;\n\n\t/* we could have extended the file */\n\tif (!(mode & FALLOC_FL_KEEP_SIZE)) {\n\t\tbool changed = fuse_write_update_size(inode, offset + length);\n\n\t\tif (changed && fc->writeback_cache)\n\t\t\tfile_update_time(file);\n\t}\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE)\n\t\ttruncate_pagecache_range(inode, offset, offset + length - 1);\n\n\tfuse_invalidate_attr(inode);\n\nout:\n\tif (!(mode & FALLOC_FL_KEEP_SIZE))\n\t\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\tif (lock_inode)\n\t\tmutex_unlock(&inode->i_mutex);\n\n\treturn err;\n}\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\n\nstatic const struct file_operations fuse_direct_io_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read_iter\t= fuse_direct_read_iter,\n\t.write_iter\t= fuse_direct_write_iter,\n\t.mmap\t\t= fuse_direct_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n\t/* no splice_read */\n};\n\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}\n"], "fixing_code": ["/*\n  FUSE: Filesystem in Userspace\n  Copyright (C) 2001-2008  Miklos Szeredi <miklos@szeredi.hu>\n\n  This program can be distributed under the terms of the GNU GPL.\n  See the file COPYING.\n*/\n\n#include \"fuse_i.h\"\n\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/uio.h>\n\nstatic const struct file_operations fuse_direct_io_file_operations;\n\nstatic int fuse_send_open(struct fuse_conn *fc, u64 nodeid, struct file *file,\n\t\t\t  int opcode, struct fuse_open_out *outargp)\n{\n\tstruct fuse_open_in inarg;\n\tFUSE_ARGS(args);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.flags = file->f_flags & ~(O_CREAT | O_EXCL | O_NOCTTY);\n\tif (!fc->atomic_o_trunc)\n\t\tinarg.flags &= ~O_TRUNC;\n\targs.in.h.opcode = opcode;\n\targs.in.h.nodeid = nodeid;\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(*outargp);\n\targs.out.args[0].value = outargp;\n\n\treturn fuse_simple_request(fc, &args);\n}\n\nstruct fuse_file *fuse_file_alloc(struct fuse_conn *fc)\n{\n\tstruct fuse_file *ff;\n\n\tff = kmalloc(sizeof(struct fuse_file), GFP_KERNEL);\n\tif (unlikely(!ff))\n\t\treturn NULL;\n\n\tff->fc = fc;\n\tff->reserved_req = fuse_request_alloc(0);\n\tif (unlikely(!ff->reserved_req)) {\n\t\tkfree(ff);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&ff->write_entry);\n\tatomic_set(&ff->count, 0);\n\tRB_CLEAR_NODE(&ff->polled_node);\n\tinit_waitqueue_head(&ff->poll_wait);\n\n\tspin_lock(&fc->lock);\n\tff->kh = ++fc->khctr;\n\tspin_unlock(&fc->lock);\n\n\treturn ff;\n}\n\nvoid fuse_file_free(struct fuse_file *ff)\n{\n\tfuse_request_free(ff->reserved_req);\n\tkfree(ff);\n}\n\nstruct fuse_file *fuse_file_get(struct fuse_file *ff)\n{\n\tatomic_inc(&ff->count);\n\treturn ff;\n}\n\nstatic void fuse_release_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tiput(req->misc.release.inode);\n}\n\nstatic void fuse_file_put(struct fuse_file *ff, bool sync)\n{\n\tif (atomic_dec_and_test(&ff->count)) {\n\t\tstruct fuse_req *req = ff->reserved_req;\n\n\t\tif (ff->fc->no_open) {\n\t\t\t/*\n\t\t\t * Drop the release request when client does not\n\t\t\t * implement 'open'\n\t\t\t */\n\t\t\t__clear_bit(FR_BACKGROUND, &req->flags);\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else if (sync) {\n\t\t\t__clear_bit(FR_BACKGROUND, &req->flags);\n\t\t\tfuse_request_send(ff->fc, req);\n\t\t\tiput(req->misc.release.inode);\n\t\t\tfuse_put_request(ff->fc, req);\n\t\t} else {\n\t\t\treq->end = fuse_release_end;\n\t\t\t__set_bit(FR_BACKGROUND, &req->flags);\n\t\t\tfuse_request_send_background(ff->fc, req);\n\t\t}\n\t\tkfree(ff);\n\t}\n}\n\nint fuse_do_open(struct fuse_conn *fc, u64 nodeid, struct file *file,\n\t\t bool isdir)\n{\n\tstruct fuse_file *ff;\n\tint opcode = isdir ? FUSE_OPENDIR : FUSE_OPEN;\n\n\tff = fuse_file_alloc(fc);\n\tif (!ff)\n\t\treturn -ENOMEM;\n\n\tff->fh = 0;\n\tff->open_flags = FOPEN_KEEP_CACHE; /* Default for no-open */\n\tif (!fc->no_open || isdir) {\n\t\tstruct fuse_open_out outarg;\n\t\tint err;\n\n\t\terr = fuse_send_open(fc, nodeid, file, opcode, &outarg);\n\t\tif (!err) {\n\t\t\tff->fh = outarg.fh;\n\t\t\tff->open_flags = outarg.open_flags;\n\n\t\t} else if (err != -ENOSYS || isdir) {\n\t\t\tfuse_file_free(ff);\n\t\t\treturn err;\n\t\t} else {\n\t\t\tfc->no_open = 1;\n\t\t}\n\t}\n\n\tif (isdir)\n\t\tff->open_flags &= ~FOPEN_DIRECT_IO;\n\n\tff->nodeid = nodeid;\n\tfile->private_data = fuse_file_get(ff);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fuse_do_open);\n\nstatic void fuse_link_write_file(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_file *ff = file->private_data;\n\t/*\n\t * file may be written through mmap, so chain it onto the\n\t * inodes's write_file list\n\t */\n\tspin_lock(&fc->lock);\n\tif (list_empty(&ff->write_entry))\n\t\tlist_add(&ff->write_entry, &fi->write_files);\n\tspin_unlock(&fc->lock);\n}\n\nvoid fuse_finish_open(struct inode *inode, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (ff->open_flags & FOPEN_DIRECT_IO)\n\t\tfile->f_op = &fuse_direct_io_file_operations;\n\tif (!(ff->open_flags & FOPEN_KEEP_CACHE))\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\tif (ff->open_flags & FOPEN_NONSEEKABLE)\n\t\tnonseekable_open(inode, file);\n\tif (fc->atomic_o_trunc && (file->f_flags & O_TRUNC)) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\tspin_lock(&fc->lock);\n\t\tfi->attr_version = ++fc->attr_version;\n\t\ti_size_write(inode, 0);\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_invalidate_attr(inode);\n\t\tif (fc->writeback_cache)\n\t\t\tfile_update_time(file);\n\t}\n\tif ((file->f_mode & FMODE_WRITE) && fc->writeback_cache)\n\t\tfuse_link_write_file(file);\n}\n\nint fuse_open_common(struct inode *inode, struct file *file, bool isdir)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\tbool lock_inode = (file->f_flags & O_TRUNC) &&\n\t\t\t  fc->atomic_o_trunc &&\n\t\t\t  fc->writeback_cache;\n\n\terr = generic_file_open(inode, file);\n\tif (err)\n\t\treturn err;\n\n\tif (lock_inode)\n\t\tmutex_lock(&inode->i_mutex);\n\n\terr = fuse_do_open(fc, get_node_id(inode), file, isdir);\n\n\tif (!err)\n\t\tfuse_finish_open(inode, file);\n\n\tif (lock_inode)\n\t\tmutex_unlock(&inode->i_mutex);\n\n\treturn err;\n}\n\nstatic void fuse_prepare_release(struct fuse_file *ff, int flags, int opcode)\n{\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_req *req = ff->reserved_req;\n\tstruct fuse_release_in *inarg = &req->misc.release.in;\n\n\tspin_lock(&fc->lock);\n\tlist_del(&ff->write_entry);\n\tif (!RB_EMPTY_NODE(&ff->polled_node))\n\t\trb_erase(&ff->polled_node, &fc->polled_files);\n\tspin_unlock(&fc->lock);\n\n\twake_up_interruptible_all(&ff->poll_wait);\n\n\tinarg->fh = ff->fh;\n\tinarg->flags = flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_release_in);\n\treq->in.args[0].value = inarg;\n}\n\nvoid fuse_release_common(struct file *file, int opcode)\n{\n\tstruct fuse_file *ff;\n\tstruct fuse_req *req;\n\n\tff = file->private_data;\n\tif (unlikely(!ff))\n\t\treturn;\n\n\treq = ff->reserved_req;\n\tfuse_prepare_release(ff, file->f_flags, opcode);\n\n\tif (ff->flock) {\n\t\tstruct fuse_release_in *inarg = &req->misc.release.in;\n\t\tinarg->release_flags |= FUSE_RELEASE_FLOCK_UNLOCK;\n\t\tinarg->lock_owner = fuse_lock_owner_id(ff->fc,\n\t\t\t\t\t\t       (fl_owner_t) file);\n\t}\n\t/* Hold inode until release is finished */\n\treq->misc.release.inode = igrab(file_inode(file));\n\n\t/*\n\t * Normally this will send the RELEASE request, however if\n\t * some asynchronous READ or WRITE requests are outstanding,\n\t * the sending will be delayed.\n\t *\n\t * Make the release synchronous if this is a fuseblk mount,\n\t * synchronous RELEASE is allowed (and desirable) in this case\n\t * because the server can be trusted not to screw up.\n\t */\n\tfuse_file_put(ff, ff->fc->destroy_req != NULL);\n}\n\nstatic int fuse_open(struct inode *inode, struct file *file)\n{\n\treturn fuse_open_common(inode, file, false);\n}\n\nstatic int fuse_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\t/* see fuse_vma_close() for !writeback_cache case */\n\tif (fc->writeback_cache)\n\t\twrite_inode_now(inode, 1);\n\n\tfuse_release_common(file, FUSE_RELEASE);\n\n\t/* return value is ignored by VFS */\n\treturn 0;\n}\n\nvoid fuse_sync_release(struct fuse_file *ff, int flags)\n{\n\tWARN_ON(atomic_read(&ff->count) > 1);\n\tfuse_prepare_release(ff, flags, FUSE_RELEASE);\n\t__set_bit(FR_FORCE, &ff->reserved_req->flags);\n\t__clear_bit(FR_BACKGROUND, &ff->reserved_req->flags);\n\tfuse_request_send(ff->fc, ff->reserved_req);\n\tfuse_put_request(ff->fc, ff->reserved_req);\n\tkfree(ff);\n}\nEXPORT_SYMBOL_GPL(fuse_sync_release);\n\n/*\n * Scramble the ID space with XTEA, so that the value of the files_struct\n * pointer is not exposed to userspace.\n */\nu64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id)\n{\n\tu32 *k = fc->scramble_key;\n\tu64 v = (unsigned long) id;\n\tu32 v0 = v;\n\tu32 v1 = v >> 32;\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tv0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + k[sum & 3]);\n\t\tsum += 0x9E3779B9;\n\t\tv1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + k[sum>>11 & 3]);\n\t}\n\n\treturn (u64) v0 + ((u64) v1 << 32);\n}\n\n/*\n * Check if any page in a range is under writeback\n *\n * This is currently done by walking the list of writepage requests\n * for the inode, which can be pretty inefficient.\n */\nstatic bool fuse_range_is_writeback(struct inode *inode, pgoff_t idx_from,\n\t\t\t\t   pgoff_t idx_to)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tbool found = false;\n\n\tspin_lock(&fc->lock);\n\tlist_for_each_entry(req, &fi->writepages, writepages_entry) {\n\t\tpgoff_t curr_index;\n\n\t\tBUG_ON(req->inode != inode);\n\t\tcurr_index = req->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (idx_from < curr_index + req->num_pages &&\n\t\t    curr_index <= idx_to) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn found;\n}\n\nstatic inline bool fuse_page_is_writeback(struct inode *inode, pgoff_t index)\n{\n\treturn fuse_range_is_writeback(inode, index, index);\n}\n\n/*\n * Wait for page writeback to be completed.\n *\n * Since fuse doesn't rely on the VM writeback tracking, this has to\n * use some other means.\n */\nstatic int fuse_wait_on_page_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\twait_event(fi->page_waitq, !fuse_page_is_writeback(inode, index));\n\treturn 0;\n}\n\n/*\n * Wait for all pending writepages on the inode to finish.\n *\n * This is currently done by blocking further writes with FUSE_NOWRITE\n * and waiting for all sent writes to complete.\n *\n * This must be called under i_mutex, otherwise the FUSE_NOWRITE usage\n * could conflict with truncation.\n */\nstatic void fuse_sync_writes(struct inode *inode)\n{\n\tfuse_set_nowrite(inode);\n\tfuse_release_nowrite(inode);\n}\n\nstatic int fuse_flush(struct file *file, fl_owner_t id)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_req *req;\n\tstruct fuse_flush_in inarg;\n\tint err;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tif (fc->no_flush)\n\t\treturn 0;\n\n\terr = write_inode_now(inode, 1);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&inode->i_mutex);\n\tfuse_sync_writes(inode);\n\tmutex_unlock(&inode->i_mutex);\n\n\treq = fuse_get_req_nofail_nopages(fc, file);\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.fh = ff->fh;\n\tinarg.lock_owner = fuse_lock_owner_id(fc, id);\n\treq->in.h.opcode = FUSE_FLUSH;\n\treq->in.h.nodeid = get_node_id(inode);\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\t__set_bit(FR_FORCE, &req->flags);\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\tif (err == -ENOSYS) {\n\t\tfc->no_flush = 1;\n\t\terr = 0;\n\t}\n\treturn err;\n}\n\nint fuse_fsync_common(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync, int isdir)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tFUSE_ARGS(args);\n\tstruct fuse_fsync_in inarg;\n\tint err;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * Start writeback against all dirty pages of the inode, then\n\t * wait for all outstanding writes, before sending the FSYNC\n\t * request.\n\t */\n\terr = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (err)\n\t\tgoto out;\n\n\tfuse_sync_writes(inode);\n\terr = sync_inode_metadata(inode, 1);\n\tif (err)\n\t\tgoto out;\n\n\tif ((!isdir && fc->no_fsync) || (isdir && fc->no_fsyncdir))\n\t\tgoto out;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.fh = ff->fh;\n\tinarg.fsync_flags = datasync ? 1 : 0;\n\targs.in.h.opcode = isdir ? FUSE_FSYNCDIR : FUSE_FSYNC;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS) {\n\t\tif (isdir)\n\t\t\tfc->no_fsyncdir = 1;\n\t\telse\n\t\t\tfc->no_fsync = 1;\n\t\terr = 0;\n\t}\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn err;\n}\n\nstatic int fuse_fsync(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync)\n{\n\treturn fuse_fsync_common(file, start, end, datasync, 0);\n}\n\nvoid fuse_read_fill(struct fuse_req *req, struct file *file, loff_t pos,\n\t\t    size_t count, int opcode)\n{\n\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\tstruct fuse_file *ff = file->private_data;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\tinarg->flags = file->f_flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_read_in);\n\treq->in.args[0].value = inarg;\n\treq->out.argvar = 1;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = count;\n}\n\nstatic void fuse_release_user_pages(struct fuse_req *req, int write)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\t\tif (write)\n\t\t\tset_page_dirty_lock(page);\n\t\tput_page(page);\n\t}\n}\n\nstatic ssize_t fuse_get_res_by_io(struct fuse_io_priv *io)\n{\n\tif (io->err)\n\t\treturn io->err;\n\n\tif (io->bytes >= 0 && io->write)\n\t\treturn -EIO;\n\n\treturn io->bytes < 0 ? io->size : io->bytes;\n}\n\n/**\n * In case of short read, the caller sets 'pos' to the position of\n * actual end of fuse request in IO request. Otherwise, if bytes_requested\n * == bytes_transferred or rw == WRITE, the caller sets 'pos' to -1.\n *\n * An example:\n * User requested DIO read of 64K. It was splitted into two 32K fuse requests,\n * both submitted asynchronously. The first of them was ACKed by userspace as\n * fully completed (req->out.args[0].size == 32K) resulting in pos == -1. The\n * second request was ACKed as short, e.g. only 1K was read, resulting in\n * pos == 33K.\n *\n * Thus, when all fuse requests are completed, the minimal non-negative 'pos'\n * will be equal to the length of the longest contiguous fragment of\n * transferred data starting from the beginning of IO request.\n */\nstatic void fuse_aio_complete(struct fuse_io_priv *io, int err, ssize_t pos)\n{\n\tbool is_sync = is_sync_kiocb(io->iocb);\n\tint left;\n\n\tspin_lock(&io->lock);\n\tif (err)\n\t\tio->err = io->err ? : err;\n\telse if (pos >= 0 && (io->bytes < 0 || pos < io->bytes))\n\t\tio->bytes = pos;\n\n\tleft = --io->reqs;\n\tif (!left && is_sync)\n\t\tcomplete(io->done);\n\tspin_unlock(&io->lock);\n\n\tif (!left && !is_sync) {\n\t\tssize_t res = fuse_get_res_by_io(io);\n\n\t\tif (res >= 0) {\n\t\t\tstruct inode *inode = file_inode(io->iocb->ki_filp);\n\t\t\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\t\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\t\tspin_lock(&fc->lock);\n\t\t\tfi->attr_version = ++fc->attr_version;\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tio->iocb->ki_complete(io->iocb, res, 0);\n\t\tkfree(io);\n\t}\n}\n\nstatic void fuse_aio_complete_req(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct fuse_io_priv *io = req->io;\n\tssize_t pos = -1;\n\n\tfuse_release_user_pages(req, !io->write);\n\n\tif (io->write) {\n\t\tif (req->misc.write.in.size != req->misc.write.out.size)\n\t\t\tpos = req->misc.write.in.offset - io->offset +\n\t\t\t\treq->misc.write.out.size;\n\t} else {\n\t\tif (req->misc.read.in.size != req->out.args[0].size)\n\t\t\tpos = req->misc.read.in.offset - io->offset +\n\t\t\t\treq->out.args[0].size;\n\t}\n\n\tfuse_aio_complete(io, req->out.h.error, pos);\n}\n\nstatic size_t fuse_async_req_send(struct fuse_conn *fc, struct fuse_req *req,\n\t\tsize_t num_bytes, struct fuse_io_priv *io)\n{\n\tspin_lock(&io->lock);\n\tio->size += num_bytes;\n\tio->reqs++;\n\tspin_unlock(&io->lock);\n\n\treq->io = io;\n\treq->end = fuse_aio_complete_req;\n\n\t__fuse_get_request(req);\n\tfuse_request_send_background(fc, req);\n\n\treturn num_bytes;\n}\n\nstatic size_t fuse_send_read(struct fuse_req *req, struct fuse_io_priv *io,\n\t\t\t     loff_t pos, size_t count, fl_owner_t owner)\n{\n\tstruct file *file = io->file;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\tif (owner != NULL) {\n\t\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\n\t\tinarg->read_flags |= FUSE_READ_LOCKOWNER;\n\t\tinarg->lock_owner = fuse_lock_owner_id(fc, owner);\n\t}\n\n\tif (io->async)\n\t\treturn fuse_async_req_send(fc, req, count, io);\n\n\tfuse_request_send(fc, req);\n\treturn req->out.args[0].size;\n}\n\nstatic void fuse_read_update_size(struct inode *inode, loff_t size,\n\t\t\t\t  u64 attr_ver)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tspin_lock(&fc->lock);\n\tif (attr_ver == fi->attr_version && size < inode->i_size &&\n\t    !test_bit(FUSE_I_SIZE_UNSTABLE, &fi->state)) {\n\t\tfi->attr_version = ++fc->attr_version;\n\t\ti_size_write(inode, size);\n\t}\n\tspin_unlock(&fc->lock);\n}\n\nstatic void fuse_short_read(struct fuse_req *req, struct inode *inode,\n\t\t\t    u64 attr_ver)\n{\n\tsize_t num_read = req->out.args[0].size;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (fc->writeback_cache) {\n\t\t/*\n\t\t * A hole in a file. Some data after the hole are in page cache,\n\t\t * but have not reached the client fs yet. So, the hole is not\n\t\t * present there.\n\t\t */\n\t\tint i;\n\t\tint start_idx = num_read >> PAGE_CACHE_SHIFT;\n\t\tsize_t off = num_read & (PAGE_CACHE_SIZE - 1);\n\n\t\tfor (i = start_idx; i < req->num_pages; i++) {\n\t\t\tzero_user_segment(req->pages[i], off, PAGE_CACHE_SIZE);\n\t\t\toff = 0;\n\t\t}\n\t} else {\n\t\tloff_t pos = page_offset(req->pages[0]) + num_read;\n\t\tfuse_read_update_size(inode, pos, attr_ver);\n\t}\n}\n\nstatic int fuse_do_readpage(struct file *file, struct page *page)\n{\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\tstruct inode *inode = page->mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tsize_t num_read;\n\tloff_t pos = page_offset(page);\n\tsize_t count = PAGE_CACHE_SIZE;\n\tu64 attr_ver;\n\tint err;\n\n\t/*\n\t * Page writeback can extend beyond the lifetime of the\n\t * page-cache page, so make sure we read a properly synced\n\t * page.\n\t */\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\treq = fuse_get_req(fc, 1);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tattr_ver = fuse_get_attr_version(fc);\n\n\treq->out.page_zeroing = 1;\n\treq->out.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = page;\n\treq->page_descs[0].length = count;\n\tnum_read = fuse_send_read(req, &io, pos, count, NULL);\n\terr = req->out.h.error;\n\n\tif (!err) {\n\t\t/*\n\t\t * Short read means EOF.  If file size is larger, truncate it\n\t\t */\n\t\tif (num_read < count)\n\t\t\tfuse_short_read(req, inode, attr_ver);\n\n\t\tSetPageUptodate(page);\n\t}\n\n\tfuse_put_request(fc, req);\n\n\treturn err;\n}\n\nstatic int fuse_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint err;\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\terr = fuse_do_readpage(file, page);\n\tfuse_invalidate_atime(inode);\n out:\n\tunlock_page(page);\n\treturn err;\n}\n\nstatic void fuse_readpages_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tint i;\n\tsize_t count = req->misc.read.in.size;\n\tsize_t num_read = req->out.args[0].size;\n\tstruct address_space *mapping = NULL;\n\n\tfor (i = 0; mapping == NULL && i < req->num_pages; i++)\n\t\tmapping = req->pages[i]->mapping;\n\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\n\t\t/*\n\t\t * Short read means EOF. If file size is larger, truncate it\n\t\t */\n\t\tif (!req->out.h.error && num_read < count)\n\t\t\tfuse_short_read(req, inode, req->misc.read.attr_ver);\n\n\t\tfuse_invalidate_atime(inode);\n\t}\n\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\t\tif (!req->out.h.error)\n\t\t\tSetPageUptodate(page);\n\t\telse\n\t\t\tSetPageError(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (req->ff)\n\t\tfuse_file_put(req->ff, false);\n}\n\nstatic void fuse_send_readpages(struct fuse_req *req, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tloff_t pos = page_offset(req->pages[0]);\n\tsize_t count = req->num_pages << PAGE_CACHE_SHIFT;\n\n\treq->out.argpages = 1;\n\treq->out.page_zeroing = 1;\n\treq->out.page_replace = 1;\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\treq->misc.read.attr_ver = fuse_get_attr_version(fc);\n\tif (fc->async_read) {\n\t\treq->ff = fuse_file_get(ff);\n\t\treq->end = fuse_readpages_end;\n\t\tfuse_request_send_background(fc, req);\n\t} else {\n\t\tfuse_request_send(fc, req);\n\t\tfuse_readpages_end(fc, req);\n\t\tfuse_put_request(fc, req);\n\t}\n}\n\nstruct fuse_fill_data {\n\tstruct fuse_req *req;\n\tstruct file *file;\n\tstruct inode *inode;\n\tunsigned nr_pages;\n};\n\nstatic int fuse_readpages_fill(void *_data, struct page *page)\n{\n\tstruct fuse_fill_data *data = _data;\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\tif (req->num_pages &&\n\t    (req->num_pages == FUSE_MAX_PAGES_PER_REQ ||\n\t     (req->num_pages + 1) * PAGE_CACHE_SIZE > fc->max_read ||\n\t     req->pages[req->num_pages - 1]->index + 1 != page->index)) {\n\t\tint nr_alloc = min_t(unsigned, data->nr_pages,\n\t\t\t\t     FUSE_MAX_PAGES_PER_REQ);\n\t\tfuse_send_readpages(req, data->file);\n\t\tif (fc->async_read)\n\t\t\treq = fuse_get_req_for_background(fc, nr_alloc);\n\t\telse\n\t\t\treq = fuse_get_req(fc, nr_alloc);\n\n\t\tdata->req = req;\n\t\tif (IS_ERR(req)) {\n\t\t\tunlock_page(page);\n\t\t\treturn PTR_ERR(req);\n\t\t}\n\t}\n\n\tif (WARN_ON(req->num_pages >= req->max_pages)) {\n\t\tfuse_put_request(fc, req);\n\t\treturn -EIO;\n\t}\n\n\tpage_cache_get(page);\n\treq->pages[req->num_pages] = page;\n\treq->page_descs[req->num_pages].length = PAGE_SIZE;\n\treq->num_pages++;\n\tdata->nr_pages--;\n\treturn 0;\n}\n\nstatic int fuse_readpages(struct file *file, struct address_space *mapping,\n\t\t\t  struct list_head *pages, unsigned nr_pages)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_fill_data data;\n\tint err;\n\tint nr_alloc = min_t(unsigned, nr_pages, FUSE_MAX_PAGES_PER_REQ);\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\tdata.file = file;\n\tdata.inode = inode;\n\tif (fc->async_read)\n\t\tdata.req = fuse_get_req_for_background(fc, nr_alloc);\n\telse\n\t\tdata.req = fuse_get_req(fc, nr_alloc);\n\tdata.nr_pages = nr_pages;\n\terr = PTR_ERR(data.req);\n\tif (IS_ERR(data.req))\n\t\tgoto out;\n\n\terr = read_cache_pages(mapping, pages, fuse_readpages_fill, &data);\n\tif (!err) {\n\t\tif (data.req->num_pages)\n\t\t\tfuse_send_readpages(data.req, file);\n\t\telse\n\t\t\tfuse_put_request(fc, data.req);\n\t}\nout:\n\treturn err;\n}\n\nstatic ssize_t fuse_file_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct inode *inode = iocb->ki_filp->f_mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\t/*\n\t * In auto invalidate mode, always update attributes on read.\n\t * Otherwise, only update if we attempt to read past EOF (to ensure\n\t * i_size is up to date).\n\t */\n\tif (fc->auto_inval_data ||\n\t    (iocb->ki_pos + iov_iter_count(to) > i_size_read(inode))) {\n\t\tint err;\n\t\terr = fuse_update_attributes(inode, NULL, iocb->ki_filp, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn generic_file_read_iter(iocb, to);\n}\n\nstatic void fuse_write_fill(struct fuse_req *req, struct fuse_file *ff,\n\t\t\t    loff_t pos, size_t count)\n{\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\tstruct fuse_write_out *outarg = &req->misc.write.out;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\treq->in.h.opcode = FUSE_WRITE;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 2;\n\tif (ff->fc->minor < 9)\n\t\treq->in.args[0].size = FUSE_COMPAT_WRITE_IN_SIZE;\n\telse\n\t\treq->in.args[0].size = sizeof(struct fuse_write_in);\n\treq->in.args[0].value = inarg;\n\treq->in.args[1].size = count;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = sizeof(struct fuse_write_out);\n\treq->out.args[0].value = outarg;\n}\n\nstatic size_t fuse_send_write(struct fuse_req *req, struct fuse_io_priv *io,\n\t\t\t      loff_t pos, size_t count, fl_owner_t owner)\n{\n\tstruct file *file = io->file;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\n\tfuse_write_fill(req, ff, pos, count);\n\tinarg->flags = file->f_flags;\n\tif (owner != NULL) {\n\t\tinarg->write_flags |= FUSE_WRITE_LOCKOWNER;\n\t\tinarg->lock_owner = fuse_lock_owner_id(fc, owner);\n\t}\n\n\tif (io->async)\n\t\treturn fuse_async_req_send(fc, req, count, io);\n\n\tfuse_request_send(fc, req);\n\treturn req->misc.write.out.size;\n}\n\nbool fuse_write_update_size(struct inode *inode, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool ret = false;\n\n\tspin_lock(&fc->lock);\n\tfi->attr_version = ++fc->attr_version;\n\tif (pos > inode->i_size) {\n\t\ti_size_write(inode, pos);\n\t\tret = true;\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ret;\n}\n\nstatic size_t fuse_send_write_pages(struct fuse_req *req, struct file *file,\n\t\t\t\t    struct inode *inode, loff_t pos,\n\t\t\t\t    size_t count)\n{\n\tsize_t res;\n\tunsigned offset;\n\tunsigned i;\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\tfuse_wait_on_page_writeback(inode, req->pages[i]->index);\n\n\tres = fuse_send_write(req, &io, pos, count, NULL);\n\n\toffset = req->page_descs[0].offset;\n\tcount = res;\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\n\t\tif (!req->out.h.error && !offset && count >= PAGE_CACHE_SIZE)\n\t\t\tSetPageUptodate(page);\n\n\t\tif (count > PAGE_CACHE_SIZE - offset)\n\t\t\tcount -= PAGE_CACHE_SIZE - offset;\n\t\telse\n\t\t\tcount = 0;\n\t\toffset = 0;\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treturn res;\n}\n\nstatic ssize_t fuse_fill_write_pages(struct fuse_req *req,\n\t\t\t       struct address_space *mapping,\n\t\t\t       struct iov_iter *ii, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(mapping->host);\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tsize_t count = 0;\n\tint err;\n\n\treq->in.argpages = 1;\n\treq->page_descs[0].offset = offset;\n\n\tdo {\n\t\tsize_t tmp;\n\t\tstruct page *page;\n\t\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\t\tsize_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,\n\t\t\t\t     iov_iter_count(ii));\n\n\t\tbytes = min_t(size_t, bytes, fc->max_write - count);\n\n again:\n\t\terr = -EFAULT;\n\t\tif (iov_iter_fault_in_readable(ii, bytes))\n\t\t\tbreak;\n\n\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tflush_dcache_page(page);\n\n\t\tiov_iter_advance(ii, tmp);\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = tmp;\n\t\treq->num_pages++;\n\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < req->max_pages && offset == 0);\n\n\treturn count > 0 ? count : err;\n}\n\nstatic inline unsigned fuse_wr_pages(loff_t pos, size_t len)\n{\n\treturn min_t(unsigned,\n\t\t     ((pos + len - 1) >> PAGE_CACHE_SHIFT) -\n\t\t     (pos >> PAGE_CACHE_SHIFT) + 1,\n\t\t     FUSE_MAX_PAGES_PER_REQ);\n}\n\nstatic ssize_t fuse_perform_write(struct file *file,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct iov_iter *ii, loff_t pos)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint err = 0;\n\tssize_t res = 0;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tif (inode->i_size < pos + iov_iter_count(ii))\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\tdo {\n\t\tstruct fuse_req *req;\n\t\tssize_t count;\n\t\tunsigned nr_pages = fuse_wr_pages(pos, iov_iter_count(ii));\n\n\t\treq = fuse_get_req(fc, nr_pages);\n\t\tif (IS_ERR(req)) {\n\t\t\terr = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = fuse_fill_write_pages(req, mapping, ii, pos);\n\t\tif (count <= 0) {\n\t\t\terr = count;\n\t\t} else {\n\t\t\tsize_t num_written;\n\n\t\t\tnum_written = fuse_send_write_pages(req, file, inode,\n\t\t\t\t\t\t\t    pos, count);\n\t\t\terr = req->out.h.error;\n\t\t\tif (!err) {\n\t\t\t\tres += num_written;\n\t\t\t\tpos += num_written;\n\n\t\t\t\t/* break out of the loop on short write */\n\t\t\t\tif (num_written != count)\n\t\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tfuse_put_request(fc, req);\n\t} while (!err && iov_iter_count(ii));\n\n\tif (res > 0)\n\t\tfuse_write_update_size(inode, pos);\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\tfuse_invalidate_attr(inode);\n\n\treturn res > 0 ? res : err;\n}\n\nstatic ssize_t fuse_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tssize_t written = 0;\n\tssize_t written_buffered = 0;\n\tstruct inode *inode = mapping->host;\n\tssize_t err;\n\tloff_t endbyte = 0;\n\n\tif (get_fuse_conn(inode)->writeback_cache) {\n\t\t/* Update size (EOF optimization) and mode (SUID clearing) */\n\t\terr = fuse_update_attributes(mapping->host, NULL, file, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn generic_file_write_iter(iocb, from);\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/* We can write back this queue in page reclaim */\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\n\terr = generic_write_checks(iocb, from);\n\tif (err <= 0)\n\t\tgoto out;\n\n\terr = file_remove_privs(file);\n\tif (err)\n\t\tgoto out;\n\n\terr = file_update_time(file);\n\tif (err)\n\t\tgoto out;\n\n\tif (iocb->ki_flags & IOCB_DIRECT) {\n\t\tloff_t pos = iocb->ki_pos;\n\t\twritten = generic_file_direct_write(iocb, from, pos);\n\t\tif (written < 0 || !iov_iter_count(from))\n\t\t\tgoto out;\n\n\t\tpos += written;\n\n\t\twritten_buffered = fuse_perform_write(file, mapping, from, pos);\n\t\tif (written_buffered < 0) {\n\t\t\terr = written_buffered;\n\t\t\tgoto out;\n\t\t}\n\t\tendbyte = pos + written_buffered - 1;\n\n\t\terr = filemap_write_and_wait_range(file->f_mapping, pos,\n\t\t\t\t\t\t   endbyte);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tinvalidate_mapping_pages(file->f_mapping,\n\t\t\t\t\t pos >> PAGE_CACHE_SHIFT,\n\t\t\t\t\t endbyte >> PAGE_CACHE_SHIFT);\n\n\t\twritten += written_buffered;\n\t\tiocb->ki_pos = pos + written_buffered;\n\t} else {\n\t\twritten = fuse_perform_write(file, mapping, from, iocb->ki_pos);\n\t\tif (written >= 0)\n\t\t\tiocb->ki_pos += written;\n\t}\nout:\n\tcurrent->backing_dev_info = NULL;\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn written ? written : err;\n}\n\nstatic inline void fuse_page_descs_length_init(struct fuse_req *req,\n\t\tunsigned index, unsigned nr_pages)\n{\n\tint i;\n\n\tfor (i = index; i < index + nr_pages; i++)\n\t\treq->page_descs[i].length = PAGE_SIZE -\n\t\t\treq->page_descs[i].offset;\n}\n\nstatic inline unsigned long fuse_get_user_addr(const struct iov_iter *ii)\n{\n\treturn (unsigned long)ii->iov->iov_base + ii->iov_offset;\n}\n\nstatic inline size_t fuse_get_frag_size(const struct iov_iter *ii,\n\t\t\t\t\tsize_t max_size)\n{\n\treturn min(iov_iter_single_seg_count(ii), max_size);\n}\n\nstatic int fuse_get_user_pages(struct fuse_req *req, struct iov_iter *ii,\n\t\t\t       size_t *nbytesp, int write)\n{\n\tsize_t nbytes = 0;  /* # bytes already packed in req */\n\n\t/* Special case for kernel I/O: can copy directly into the buffer */\n\tif (ii->type & ITER_KVEC) {\n\t\tunsigned long user_addr = fuse_get_user_addr(ii);\n\t\tsize_t frag_size = fuse_get_frag_size(ii, *nbytesp);\n\n\t\tif (write)\n\t\t\treq->in.args[1].value = (void *) user_addr;\n\t\telse\n\t\t\treq->out.args[0].value = (void *) user_addr;\n\n\t\tiov_iter_advance(ii, frag_size);\n\t\t*nbytesp = frag_size;\n\t\treturn 0;\n\t}\n\n\twhile (nbytes < *nbytesp && req->num_pages < req->max_pages) {\n\t\tunsigned npages;\n\t\tsize_t start;\n\t\tssize_t ret = iov_iter_get_pages(ii,\n\t\t\t\t\t&req->pages[req->num_pages],\n\t\t\t\t\t*nbytesp - nbytes,\n\t\t\t\t\treq->max_pages - req->num_pages,\n\t\t\t\t\t&start);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tiov_iter_advance(ii, ret);\n\t\tnbytes += ret;\n\n\t\tret += start;\n\t\tnpages = (ret + PAGE_SIZE - 1) / PAGE_SIZE;\n\n\t\treq->page_descs[req->num_pages].offset = start;\n\t\tfuse_page_descs_length_init(req, req->num_pages, npages);\n\n\t\treq->num_pages += npages;\n\t\treq->page_descs[req->num_pages - 1].length -=\n\t\t\t(PAGE_SIZE - ret) & (PAGE_SIZE - 1);\n\t}\n\n\tif (write)\n\t\treq->in.argpages = 1;\n\telse\n\t\treq->out.argpages = 1;\n\n\t*nbytesp = nbytes;\n\n\treturn 0;\n}\n\nstatic inline int fuse_iter_npages(const struct iov_iter *ii_p)\n{\n\treturn iov_iter_npages(ii_p, FUSE_MAX_PAGES_PER_REQ);\n}\n\nssize_t fuse_direct_io(struct fuse_io_priv *io, struct iov_iter *iter,\n\t\t       loff_t *ppos, int flags)\n{\n\tint write = flags & FUSE_DIO_WRITE;\n\tint cuse = flags & FUSE_DIO_CUSE;\n\tstruct file *file = io->file;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tsize_t nmax = write ? fc->max_write : fc->max_read;\n\tloff_t pos = *ppos;\n\tsize_t count = iov_iter_count(iter);\n\tpgoff_t idx_from = pos >> PAGE_CACHE_SHIFT;\n\tpgoff_t idx_to = (pos + count - 1) >> PAGE_CACHE_SHIFT;\n\tssize_t res = 0;\n\tstruct fuse_req *req;\n\n\tif (io->async)\n\t\treq = fuse_get_req_for_background(fc, fuse_iter_npages(iter));\n\telse\n\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tif (!cuse && fuse_range_is_writeback(inode, idx_from, idx_to)) {\n\t\tif (!write)\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\tfuse_sync_writes(inode);\n\t\tif (!write)\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\twhile (count) {\n\t\tsize_t nres;\n\t\tfl_owner_t owner = current->files;\n\t\tsize_t nbytes = min(count, nmax);\n\t\tint err = fuse_get_user_pages(req, iter, &nbytes, write);\n\t\tif (err) {\n\t\t\tres = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write)\n\t\t\tnres = fuse_send_write(req, io, pos, nbytes, owner);\n\t\telse\n\t\t\tnres = fuse_send_read(req, io, pos, nbytes, owner);\n\n\t\tif (!io->async)\n\t\t\tfuse_release_user_pages(req, !write);\n\t\tif (req->out.h.error) {\n\t\t\tif (!res)\n\t\t\t\tres = req->out.h.error;\n\t\t\tbreak;\n\t\t} else if (nres > nbytes) {\n\t\t\tres = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcount -= nres;\n\t\tres += nres;\n\t\tpos += nres;\n\t\tif (nres != nbytes)\n\t\t\tbreak;\n\t\tif (count) {\n\t\t\tfuse_put_request(fc, req);\n\t\t\tif (io->async)\n\t\t\t\treq = fuse_get_req_for_background(fc,\n\t\t\t\t\tfuse_iter_npages(iter));\n\t\t\telse\n\t\t\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\t\t\tif (IS_ERR(req))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!IS_ERR(req))\n\t\tfuse_put_request(fc, req);\n\tif (res > 0)\n\t\t*ppos = pos;\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(fuse_direct_io);\n\nstatic ssize_t __fuse_direct_read(struct fuse_io_priv *io,\n\t\t\t\t  struct iov_iter *iter,\n\t\t\t\t  loff_t *ppos)\n{\n\tssize_t res;\n\tstruct file *file = io->file;\n\tstruct inode *inode = file_inode(file);\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tres = fuse_direct_io(io, iter, ppos, 0);\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res;\n}\n\nstatic ssize_t fuse_direct_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct fuse_io_priv io = { .async = 0, .file = iocb->ki_filp };\n\treturn __fuse_direct_read(&io, to, &iocb->ki_pos);\n}\n\nstatic ssize_t fuse_direct_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\tssize_t res;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\t/* Don't allow parallel writes to the same file */\n\tmutex_lock(&inode->i_mutex);\n\tres = generic_write_checks(iocb, from);\n\tif (res > 0)\n\t\tres = fuse_direct_io(&io, from, &iocb->ki_pos, FUSE_DIO_WRITE);\n\tfuse_invalidate_attr(inode);\n\tif (res > 0)\n\t\tfuse_write_update_size(inode, iocb->ki_pos);\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn res;\n}\n\nstatic void fuse_writepage_free(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tint i;\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\t__free_page(req->pages[i]);\n\n\tif (req->ff)\n\t\tfuse_file_put(req->ff, false);\n}\n\nstatic void fuse_writepage_finish(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct inode *inode = req->inode;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tint i;\n\n\tlist_del(&req->writepages_entry);\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tdec_wb_stat(&bdi->wb, WB_WRITEBACK);\n\t\tdec_zone_page_state(req->pages[i], NR_WRITEBACK_TEMP);\n\t\twb_writeout_inc(&bdi->wb);\n\t}\n\twake_up(&fi->page_waitq);\n}\n\n/* Called under fc->lock, may release and reacquire it */\nstatic void fuse_send_writepage(struct fuse_conn *fc, struct fuse_req *req,\n\t\t\t\tloff_t size)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(req->inode);\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\t__u64 data_size = req->num_pages * PAGE_CACHE_SIZE;\n\n\tif (!fc->connected)\n\t\tgoto out_free;\n\n\tif (inarg->offset + data_size <= size) {\n\t\tinarg->size = data_size;\n\t} else if (inarg->offset < size) {\n\t\tinarg->size = size - inarg->offset;\n\t} else {\n\t\t/* Got truncated off completely */\n\t\tgoto out_free;\n\t}\n\n\treq->in.args[1].size = inarg->size;\n\tfi->writectr++;\n\tfuse_request_send_background_locked(fc, req);\n\treturn;\n\n out_free:\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n\tfuse_put_request(fc, req);\n\tspin_lock(&fc->lock);\n}\n\n/*\n * If fi->writectr is positive (no truncate or fsync going on) send\n * all queued writepage requests.\n *\n * Called with fc->lock\n */\nvoid fuse_flush_writepages(struct inode *inode)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tsize_t crop = i_size_read(inode);\n\tstruct fuse_req *req;\n\n\twhile (fi->writectr >= 0 && !list_empty(&fi->queued_writes)) {\n\t\treq = list_entry(fi->queued_writes.next, struct fuse_req, list);\n\t\tlist_del_init(&req->list);\n\t\tfuse_send_writepage(fc, req, crop);\n\t}\n}\n\nstatic void fuse_writepage_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct inode *inode = req->inode;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tmapping_set_error(inode->i_mapping, req->out.h.error);\n\tspin_lock(&fc->lock);\n\twhile (req->misc.write.next) {\n\t\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\t\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\t\tstruct fuse_req *next = req->misc.write.next;\n\t\treq->misc.write.next = next->misc.write.next;\n\t\tnext->misc.write.next = NULL;\n\t\tnext->ff = fuse_file_get(req->ff);\n\t\tlist_add(&next->writepages_entry, &fi->writepages);\n\n\t\t/*\n\t\t * Skip fuse_flush_writepages() to make it easy to crop requests\n\t\t * based on primary request size.\n\t\t *\n\t\t * 1st case (trivial): there are no concurrent activities using\n\t\t * fuse_set/release_nowrite.  Then we're on safe side because\n\t\t * fuse_flush_writepages() would call fuse_send_writepage()\n\t\t * anyway.\n\t\t *\n\t\t * 2nd case: someone called fuse_set_nowrite and it is waiting\n\t\t * now for completion of all in-flight requests.  This happens\n\t\t * rarely and no more than once per page, so this should be\n\t\t * okay.\n\t\t *\n\t\t * 3rd case: someone (e.g. fuse_do_setattr()) is in the middle\n\t\t * of fuse_set_nowrite..fuse_release_nowrite section.  The fact\n\t\t * that fuse_set_nowrite returned implies that all in-flight\n\t\t * requests were completed along with all of their secondary\n\t\t * requests.  Further primary requests are blocked by negative\n\t\t * writectr.  Hence there cannot be any in-flight requests and\n\t\t * no invocations of fuse_writepage_end() while we're in\n\t\t * fuse_set_nowrite..fuse_release_nowrite section.\n\t\t */\n\t\tfuse_send_writepage(fc, next, inarg->offset + inarg->size);\n\t}\n\tfi->writectr--;\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n}\n\nstatic struct fuse_file *__fuse_write_file_get(struct fuse_conn *fc,\n\t\t\t\t\t       struct fuse_inode *fi)\n{\n\tstruct fuse_file *ff = NULL;\n\n\tspin_lock(&fc->lock);\n\tif (!list_empty(&fi->write_files)) {\n\t\tff = list_entry(fi->write_files.next, struct fuse_file,\n\t\t\t\twrite_entry);\n\t\tfuse_file_get(ff);\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn ff;\n}\n\nstatic struct fuse_file *fuse_write_file_get(struct fuse_conn *fc,\n\t\t\t\t\t     struct fuse_inode *fi)\n{\n\tstruct fuse_file *ff = __fuse_write_file_get(fc, fi);\n\tWARN_ON(!ff);\n\treturn ff;\n}\n\nint fuse_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_file *ff;\n\tint err;\n\n\tff = __fuse_write_file_get(fc, fi);\n\terr = fuse_flush_times(inode, ff);\n\tif (ff)\n\t\tfuse_file_put(ff, 0);\n\n\treturn err;\n}\n\nstatic int fuse_writepage_locked(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tstruct page *tmp_page;\n\tint error = -ENOMEM;\n\n\tset_page_writeback(page);\n\n\treq = fuse_request_alloc_nofs(1);\n\tif (!req)\n\t\tgoto err;\n\n\t/* writeback always goes to bg_queue */\n\t__set_bit(FR_BACKGROUND, &req->flags);\n\ttmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!tmp_page)\n\t\tgoto err_free;\n\n\terror = -EIO;\n\treq->ff = fuse_write_file_get(fc, fi);\n\tif (!req->ff)\n\t\tgoto err_nofile;\n\n\tfuse_write_fill(req, req->ff, page_offset(page), 0);\n\n\tcopy_highpage(tmp_page, page);\n\treq->misc.write.in.write_flags |= FUSE_WRITE_CACHE;\n\treq->misc.write.next = NULL;\n\treq->in.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = tmp_page;\n\treq->page_descs[0].offset = 0;\n\treq->page_descs[0].length = PAGE_SIZE;\n\treq->end = fuse_writepage_end;\n\treq->inode = inode;\n\n\tinc_wb_stat(&inode_to_bdi(inode)->wb, WB_WRITEBACK);\n\tinc_zone_page_state(tmp_page, NR_WRITEBACK_TEMP);\n\n\tspin_lock(&fc->lock);\n\tlist_add(&req->writepages_entry, &fi->writepages);\n\tlist_add_tail(&req->list, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fc->lock);\n\n\tend_page_writeback(page);\n\n\treturn 0;\n\nerr_nofile:\n\t__free_page(tmp_page);\nerr_free:\n\tfuse_request_free(req);\nerr:\n\tend_page_writeback(page);\n\treturn error;\n}\n\nstatic int fuse_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint err;\n\n\tif (fuse_page_is_writeback(page->mapping->host, page->index)) {\n\t\t/*\n\t\t * ->writepages() should be called for sync() and friends.  We\n\t\t * should only get here on direct reclaim and then we are\n\t\t * allowed to skip a page which is already in flight\n\t\t */\n\t\tWARN_ON(wbc->sync_mode == WB_SYNC_ALL);\n\n\t\tredirty_page_for_writepage(wbc, page);\n\t\treturn 0;\n\t}\n\n\terr = fuse_writepage_locked(page);\n\tunlock_page(page);\n\n\treturn err;\n}\n\nstruct fuse_fill_wb_data {\n\tstruct fuse_req *req;\n\tstruct fuse_file *ff;\n\tstruct inode *inode;\n\tstruct page **orig_pages;\n};\n\nstatic void fuse_writepages_send(struct fuse_fill_wb_data *data)\n{\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint num_pages = req->num_pages;\n\tint i;\n\n\treq->ff = fuse_file_get(data->ff);\n\tspin_lock(&fc->lock);\n\tlist_add_tail(&req->list, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fc->lock);\n\n\tfor (i = 0; i < num_pages; i++)\n\t\tend_page_writeback(data->orig_pages[i]);\n}\n\nstatic bool fuse_writepage_in_flight(struct fuse_req *new_req,\n\t\t\t\t     struct page *page)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(new_req->inode);\n\tstruct fuse_inode *fi = get_fuse_inode(new_req->inode);\n\tstruct fuse_req *tmp;\n\tstruct fuse_req *old_req;\n\tbool found = false;\n\tpgoff_t curr_index;\n\n\tBUG_ON(new_req->num_pages != 0);\n\n\tspin_lock(&fc->lock);\n\tlist_del(&new_req->writepages_entry);\n\tlist_for_each_entry(old_req, &fi->writepages, writepages_entry) {\n\t\tBUG_ON(old_req->inode != new_req->inode);\n\t\tcurr_index = old_req->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (curr_index <= page->index &&\n\t\t    page->index < curr_index + old_req->num_pages) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tlist_add(&new_req->writepages_entry, &fi->writepages);\n\t\tgoto out_unlock;\n\t}\n\n\tnew_req->num_pages = 1;\n\tfor (tmp = old_req; tmp != NULL; tmp = tmp->misc.write.next) {\n\t\tBUG_ON(tmp->inode != new_req->inode);\n\t\tcurr_index = tmp->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (tmp->num_pages == 1 &&\n\t\t    curr_index == page->index) {\n\t\t\told_req = tmp;\n\t\t}\n\t}\n\n\tif (old_req->num_pages == 1 && test_bit(FR_PENDING, &old_req->flags)) {\n\t\tstruct backing_dev_info *bdi = inode_to_bdi(page->mapping->host);\n\n\t\tcopy_highpage(old_req->pages[0], page);\n\t\tspin_unlock(&fc->lock);\n\n\t\tdec_wb_stat(&bdi->wb, WB_WRITEBACK);\n\t\tdec_zone_page_state(page, NR_WRITEBACK_TEMP);\n\t\twb_writeout_inc(&bdi->wb);\n\t\tfuse_writepage_free(fc, new_req);\n\t\tfuse_request_free(new_req);\n\t\tgoto out;\n\t} else {\n\t\tnew_req->misc.write.next = old_req->misc.write.next;\n\t\told_req->misc.write.next = new_req;\n\t}\nout_unlock:\n\tspin_unlock(&fc->lock);\nout:\n\treturn found;\n}\n\nstatic int fuse_writepages_fill(struct page *page,\n\t\tstruct writeback_control *wbc, void *_data)\n{\n\tstruct fuse_fill_wb_data *data = _data;\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct page *tmp_page;\n\tbool is_writeback;\n\tint err;\n\n\tif (!data->ff) {\n\t\terr = -EIO;\n\t\tdata->ff = fuse_write_file_get(fc, get_fuse_inode(inode));\n\t\tif (!data->ff)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Being under writeback is unlikely but possible.  For example direct\n\t * read to an mmaped fuse file will set the page dirty twice; once when\n\t * the pages are faulted with get_user_pages(), and then after the read\n\t * completed.\n\t */\n\tis_writeback = fuse_page_is_writeback(inode, page->index);\n\n\tif (req && req->num_pages &&\n\t    (is_writeback || req->num_pages == FUSE_MAX_PAGES_PER_REQ ||\n\t     (req->num_pages + 1) * PAGE_CACHE_SIZE > fc->max_write ||\n\t     data->orig_pages[req->num_pages - 1]->index + 1 != page->index)) {\n\t\tfuse_writepages_send(data);\n\t\tdata->req = NULL;\n\t}\n\terr = -ENOMEM;\n\ttmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!tmp_page)\n\t\tgoto out_unlock;\n\n\t/*\n\t * The page must not be redirtied until the writeout is completed\n\t * (i.e. userspace has sent a reply to the write request).  Otherwise\n\t * there could be more than one temporary page instance for each real\n\t * page.\n\t *\n\t * This is ensured by holding the page lock in page_mkwrite() while\n\t * checking fuse_page_is_writeback().  We already hold the page lock\n\t * since clear_page_dirty_for_io() and keep it held until we add the\n\t * request to the fi->writepages list and increment req->num_pages.\n\t * After this fuse_page_is_writeback() will indicate that the page is\n\t * under writeback, so we can release the page lock.\n\t */\n\tif (data->req == NULL) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\terr = -ENOMEM;\n\t\treq = fuse_request_alloc_nofs(FUSE_MAX_PAGES_PER_REQ);\n\t\tif (!req) {\n\t\t\t__free_page(tmp_page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tfuse_write_fill(req, data->ff, page_offset(page), 0);\n\t\treq->misc.write.in.write_flags |= FUSE_WRITE_CACHE;\n\t\treq->misc.write.next = NULL;\n\t\treq->in.argpages = 1;\n\t\t__set_bit(FR_BACKGROUND, &req->flags);\n\t\treq->num_pages = 0;\n\t\treq->end = fuse_writepage_end;\n\t\treq->inode = inode;\n\n\t\tspin_lock(&fc->lock);\n\t\tlist_add(&req->writepages_entry, &fi->writepages);\n\t\tspin_unlock(&fc->lock);\n\n\t\tdata->req = req;\n\t}\n\tset_page_writeback(page);\n\n\tcopy_highpage(tmp_page, page);\n\treq->pages[req->num_pages] = tmp_page;\n\treq->page_descs[req->num_pages].offset = 0;\n\treq->page_descs[req->num_pages].length = PAGE_SIZE;\n\n\tinc_wb_stat(&inode_to_bdi(inode)->wb, WB_WRITEBACK);\n\tinc_zone_page_state(tmp_page, NR_WRITEBACK_TEMP);\n\n\terr = 0;\n\tif (is_writeback && fuse_writepage_in_flight(req, page)) {\n\t\tend_page_writeback(page);\n\t\tdata->req = NULL;\n\t\tgoto out_unlock;\n\t}\n\tdata->orig_pages[req->num_pages] = page;\n\n\t/*\n\t * Protected by fc->lock against concurrent access by\n\t * fuse_page_is_writeback().\n\t */\n\tspin_lock(&fc->lock);\n\treq->num_pages++;\n\tspin_unlock(&fc->lock);\n\nout_unlock:\n\tunlock_page(page);\n\n\treturn err;\n}\n\nstatic int fuse_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_fill_wb_data data;\n\tint err;\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\tdata.inode = inode;\n\tdata.req = NULL;\n\tdata.ff = NULL;\n\n\terr = -ENOMEM;\n\tdata.orig_pages = kcalloc(FUSE_MAX_PAGES_PER_REQ,\n\t\t\t\t  sizeof(struct page *),\n\t\t\t\t  GFP_NOFS);\n\tif (!data.orig_pages)\n\t\tgoto out;\n\n\terr = write_cache_pages(mapping, wbc, fuse_writepages_fill, &data);\n\tif (data.req) {\n\t\t/* Ignore errors if we can write at least one page */\n\t\tBUG_ON(!data.req->num_pages);\n\t\tfuse_writepages_send(&data);\n\t\terr = 0;\n\t}\n\tif (data.ff)\n\t\tfuse_file_put(data.ff, false);\n\n\tkfree(data.orig_pages);\nout:\n\treturn err;\n}\n\n/*\n * It's worthy to make sure that space is reserved on disk for the write,\n * but how to implement it without killing performance need more thinking.\n */\nstatic int fuse_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct fuse_conn *fc = get_fuse_conn(file_inode(file));\n\tstruct page *page;\n\tloff_t fsize;\n\tint err = -ENOMEM;\n\n\tWARN_ON(!fc->writeback_cache);\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\tgoto error;\n\n\tfuse_wait_on_page_writeback(mapping->host, page->index);\n\n\tif (PageUptodate(page) || len == PAGE_CACHE_SIZE)\n\t\tgoto success;\n\t/*\n\t * Check if the start this page comes after the end of file, in which\n\t * case the readpage can be optimized away.\n\t */\n\tfsize = i_size_read(mapping->host);\n\tif (fsize <= (pos & PAGE_CACHE_MASK)) {\n\t\tsize_t off = pos & ~PAGE_CACHE_MASK;\n\t\tif (off)\n\t\t\tzero_user_segment(page, 0, off);\n\t\tgoto success;\n\t}\n\terr = fuse_do_readpage(file, page);\n\tif (err)\n\t\tgoto cleanup;\nsuccess:\n\t*pagep = page;\n\treturn 0;\n\ncleanup:\n\tunlock_page(page);\n\tpage_cache_release(page);\nerror:\n\treturn err;\n}\n\nstatic int fuse_write_end(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned copied,\n\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\n\tif (!PageUptodate(page)) {\n\t\t/* Zero any unwritten bytes at the end of the page */\n\t\tsize_t endoff = (pos + copied) & ~PAGE_CACHE_MASK;\n\t\tif (endoff)\n\t\t\tzero_user_segment(page, endoff, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t}\n\n\tfuse_write_update_size(inode, pos + copied);\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn copied;\n}\n\nstatic int fuse_launder_page(struct page *page)\n{\n\tint err = 0;\n\tif (clear_page_dirty_for_io(page)) {\n\t\tstruct inode *inode = page->mapping->host;\n\t\terr = fuse_writepage_locked(page);\n\t\tif (!err)\n\t\t\tfuse_wait_on_page_writeback(inode, page->index);\n\t}\n\treturn err;\n}\n\n/*\n * Write back dirty pages now, because there may not be any suitable\n * open files later\n */\nstatic void fuse_vma_close(struct vm_area_struct *vma)\n{\n\tfilemap_write_and_wait(vma->vm_file->f_mapping);\n}\n\n/*\n * Wait for writeback against this page to complete before allowing it\n * to be marked dirty again, and hence written back again, possibly\n * before the previous writepage completed.\n *\n * Block here, instead of in ->writepage(), so that the userspace fs\n * can only block processes actually operating on the filesystem.\n *\n * Otherwise unprivileged userspace fs would be able to block\n * unrelated:\n *\n * - page migration\n * - sync(2)\n * - try_to_free_pages() with order > PAGE_ALLOC_COSTLY_ORDER\n */\nstatic int fuse_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\n\tfile_update_time(vma->vm_file);\n\tlock_page(page);\n\tif (page->mapping != inode->i_mapping) {\n\t\tunlock_page(page);\n\t\treturn VM_FAULT_NOPAGE;\n\t}\n\n\tfuse_wait_on_page_writeback(inode, page->index);\n\treturn VM_FAULT_LOCKED;\n}\n\nstatic const struct vm_operations_struct fuse_file_vm_ops = {\n\t.close\t\t= fuse_vma_close,\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= fuse_page_mkwrite,\n};\n\nstatic int fuse_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tif ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE))\n\t\tfuse_link_write_file(file);\n\n\tfile_accessed(file);\n\tvma->vm_ops = &fuse_file_vm_ops;\n\treturn 0;\n}\n\nstatic int fuse_direct_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\t/* Can't provide the coherency needed for MAP_SHARED */\n\tif (vma->vm_flags & VM_MAYSHARE)\n\t\treturn -ENODEV;\n\n\tinvalidate_inode_pages2(file->f_mapping);\n\n\treturn generic_file_mmap(file, vma);\n}\n\nstatic int convert_fuse_file_lock(const struct fuse_file_lock *ffl,\n\t\t\t\t  struct file_lock *fl)\n{\n\tswitch (ffl->type) {\n\tcase F_UNLCK:\n\t\tbreak;\n\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\tif (ffl->start > OFFSET_MAX || ffl->end > OFFSET_MAX ||\n\t\t    ffl->end < ffl->start)\n\t\t\treturn -EIO;\n\n\t\tfl->fl_start = ffl->start;\n\t\tfl->fl_end = ffl->end;\n\t\tfl->fl_pid = ffl->pid;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EIO;\n\t}\n\tfl->fl_type = ffl->type;\n\treturn 0;\n}\n\nstatic void fuse_lk_fill(struct fuse_args *args, struct file *file,\n\t\t\t const struct file_lock *fl, int opcode, pid_t pid,\n\t\t\t int flock, struct fuse_lk_in *inarg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\n\tmemset(inarg, 0, sizeof(*inarg));\n\tinarg->fh = ff->fh;\n\tinarg->owner = fuse_lock_owner_id(fc, fl->fl_owner);\n\tinarg->lk.start = fl->fl_start;\n\tinarg->lk.end = fl->fl_end;\n\tinarg->lk.type = fl->fl_type;\n\tinarg->lk.pid = pid;\n\tif (flock)\n\t\tinarg->lk_flags |= FUSE_LK_FLOCK;\n\targs->in.h.opcode = opcode;\n\targs->in.h.nodeid = get_node_id(inode);\n\targs->in.numargs = 1;\n\targs->in.args[0].size = sizeof(*inarg);\n\targs->in.args[0].value = inarg;\n}\n\nstatic int fuse_getlk(struct file *file, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_lk_in inarg;\n\tstruct fuse_lk_out outarg;\n\tint err;\n\n\tfuse_lk_fill(&args, file, fl, FUSE_GETLK, 0, 0, &inarg);\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err)\n\t\terr = convert_fuse_file_lock(&outarg.lk, fl);\n\n\treturn err;\n}\n\nstatic int fuse_setlk(struct file *file, struct file_lock *fl, int flock)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_lk_in inarg;\n\tint opcode = (fl->fl_flags & FL_SLEEP) ? FUSE_SETLKW : FUSE_SETLK;\n\tpid_t pid = fl->fl_type != F_UNLCK ? current->tgid : 0;\n\tint err;\n\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant) {\n\t\t/* NLM needs asynchronous locks, which we don't support yet */\n\t\treturn -ENOLCK;\n\t}\n\n\t/* Unlock on close is handled by the flush method */\n\tif (fl->fl_flags & FL_CLOSE)\n\t\treturn 0;\n\n\tfuse_lk_fill(&args, file, fl, opcode, pid, flock, &inarg);\n\terr = fuse_simple_request(fc, &args);\n\n\t/* locking is restartable */\n\tif (err == -EINTR)\n\t\terr = -ERESTARTSYS;\n\n\treturn err;\n}\n\nstatic int fuse_file_lock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\n\tif (cmd == F_CANCELLK) {\n\t\terr = 0;\n\t} else if (cmd == F_GETLK) {\n\t\tif (fc->no_lock) {\n\t\t\tposix_test_lock(file, fl);\n\t\t\terr = 0;\n\t\t} else\n\t\t\terr = fuse_getlk(file, fl);\n\t} else {\n\t\tif (fc->no_lock)\n\t\t\terr = posix_lock_file(file, fl, NULL);\n\t\telse\n\t\t\terr = fuse_setlk(file, fl, 0);\n\t}\n\treturn err;\n}\n\nstatic int fuse_file_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\n\tif (fc->no_flock) {\n\t\terr = flock_lock_file_wait(file, fl);\n\t} else {\n\t\tstruct fuse_file *ff = file->private_data;\n\n\t\t/* emulate flock with POSIX locks */\n\t\tff->flock = true;\n\t\terr = fuse_setlk(file, fl, 1);\n\t}\n\n\treturn err;\n}\n\nstatic sector_t fuse_bmap(struct address_space *mapping, sector_t block)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_bmap_in inarg;\n\tstruct fuse_bmap_out outarg;\n\tint err;\n\n\tif (!inode->i_sb->s_bdev || fc->no_bmap)\n\t\treturn 0;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.block = block;\n\tinarg.blocksize = inode->i_sb->s_blocksize;\n\targs.in.h.opcode = FUSE_BMAP;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS)\n\t\tfc->no_bmap = 1;\n\n\treturn err ? 0 : outarg.block;\n}\n\nstatic loff_t fuse_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t retval;\n\tstruct inode *inode = file_inode(file);\n\n\t/* No i_mutex protection necessary for SEEK_CUR and SEEK_SET */\n\tif (whence == SEEK_CUR || whence == SEEK_SET)\n\t\treturn generic_file_llseek(file, offset, whence);\n\n\tmutex_lock(&inode->i_mutex);\n\tretval = fuse_update_attributes(inode, NULL, file, NULL);\n\tif (!retval)\n\t\tretval = generic_file_llseek(file, offset, whence);\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn retval;\n}\n\nstatic int fuse_ioctl_copy_user(struct page **pages, struct iovec *iov,\n\t\t\tunsigned int nr_segs, size_t bytes, bool to_user)\n{\n\tstruct iov_iter ii;\n\tint page_idx = 0;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tiov_iter_init(&ii, to_user ? READ : WRITE, iov, nr_segs, bytes);\n\n\twhile (iov_iter_count(&ii)) {\n\t\tstruct page *page = pages[page_idx++];\n\t\tsize_t todo = min_t(size_t, PAGE_SIZE, iov_iter_count(&ii));\n\t\tvoid *kaddr;\n\n\t\tkaddr = kmap(page);\n\n\t\twhile (todo) {\n\t\t\tchar __user *uaddr = ii.iov->iov_base + ii.iov_offset;\n\t\t\tsize_t iov_len = ii.iov->iov_len - ii.iov_offset;\n\t\t\tsize_t copy = min(todo, iov_len);\n\t\t\tsize_t left;\n\n\t\t\tif (!to_user)\n\t\t\t\tleft = copy_from_user(kaddr, uaddr, copy);\n\t\t\telse\n\t\t\t\tleft = copy_to_user(uaddr, kaddr, copy);\n\n\t\t\tif (unlikely(left))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tiov_iter_advance(&ii, copy);\n\t\t\ttodo -= copy;\n\t\t\tkaddr += copy;\n\t\t}\n\n\t\tkunmap(page);\n\t}\n\n\treturn 0;\n}\n\n/*\n * CUSE servers compiled on 32bit broke on 64bit kernels because the\n * ABI was defined to be 'struct iovec' which is different on 32bit\n * and 64bit.  Fortunately we can determine which structure the server\n * used from the size of the reply.\n */\nstatic int fuse_copy_ioctl_iovec_old(struct iovec *dst, void *src,\n\t\t\t\t     size_t transferred, unsigned count,\n\t\t\t\t     bool is_compat)\n{\n#ifdef CONFIG_COMPAT\n\tif (count * sizeof(struct compat_iovec) == transferred) {\n\t\tstruct compat_iovec *ciov = src;\n\t\tunsigned i;\n\n\t\t/*\n\t\t * With this interface a 32bit server cannot support\n\t\t * non-compat (i.e. ones coming from 64bit apps) ioctl\n\t\t * requests\n\t\t */\n\t\tif (!is_compat)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tdst[i].iov_base = compat_ptr(ciov[i].iov_base);\n\t\t\tdst[i].iov_len = ciov[i].iov_len;\n\t\t}\n\t\treturn 0;\n\t}\n#endif\n\n\tif (count * sizeof(struct iovec) != transferred)\n\t\treturn -EIO;\n\n\tmemcpy(dst, src, transferred);\n\treturn 0;\n}\n\n/* Make sure iov_length() won't overflow */\nstatic int fuse_verify_ioctl_iov(struct iovec *iov, size_t count)\n{\n\tsize_t n;\n\tu32 max = FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT;\n\n\tfor (n = 0; n < count; n++, iov++) {\n\t\tif (iov->iov_len > (size_t) max)\n\t\t\treturn -ENOMEM;\n\t\tmax -= iov->iov_len;\n\t}\n\treturn 0;\n}\n\nstatic int fuse_copy_ioctl_iovec(struct fuse_conn *fc, struct iovec *dst,\n\t\t\t\t void *src, size_t transferred, unsigned count,\n\t\t\t\t bool is_compat)\n{\n\tunsigned i;\n\tstruct fuse_ioctl_iovec *fiov = src;\n\n\tif (fc->minor < 16) {\n\t\treturn fuse_copy_ioctl_iovec_old(dst, src, transferred,\n\t\t\t\t\t\t count, is_compat);\n\t}\n\n\tif (count * sizeof(struct fuse_ioctl_iovec) != transferred)\n\t\treturn -EIO;\n\n\tfor (i = 0; i < count; i++) {\n\t\t/* Did the server supply an inappropriate value? */\n\t\tif (fiov[i].base != (unsigned long) fiov[i].base ||\n\t\t    fiov[i].len != (unsigned long) fiov[i].len)\n\t\t\treturn -EIO;\n\n\t\tdst[i].iov_base = (void __user *) (unsigned long) fiov[i].base;\n\t\tdst[i].iov_len = (size_t) fiov[i].len;\n\n#ifdef CONFIG_COMPAT\n\t\tif (is_compat &&\n\t\t    (ptr_to_compat(dst[i].iov_base) != fiov[i].base ||\n\t\t     (compat_size_t) dst[i].iov_len != fiov[i].len))\n\t\t\treturn -EIO;\n#endif\n\t}\n\n\treturn 0;\n}\n\n\n/*\n * For ioctls, there is no generic way to determine how much memory\n * needs to be read and/or written.  Furthermore, ioctls are allowed\n * to dereference the passed pointer, so the parameter requires deep\n * copying but FUSE has no idea whatsoever about what to copy in or\n * out.\n *\n * This is solved by allowing FUSE server to retry ioctl with\n * necessary in/out iovecs.  Let's assume the ioctl implementation\n * needs to read in the following structure.\n *\n * struct a {\n *\tchar\t*buf;\n *\tsize_t\tbuflen;\n * }\n *\n * On the first callout to FUSE server, inarg->in_size and\n * inarg->out_size will be NULL; then, the server completes the ioctl\n * with FUSE_IOCTL_RETRY set in out->flags, out->in_iovs set to 1 and\n * the actual iov array to\n *\n * { { .iov_base = inarg.arg,\t.iov_len = sizeof(struct a) } }\n *\n * which tells FUSE to copy in the requested area and retry the ioctl.\n * On the second round, the server has access to the structure and\n * from that it can tell what to look for next, so on the invocation,\n * it sets FUSE_IOCTL_RETRY, out->in_iovs to 2 and iov array to\n *\n * { { .iov_base = inarg.arg,\t.iov_len = sizeof(struct a)\t},\n *   { .iov_base = a.buf,\t.iov_len = a.buflen\t\t} }\n *\n * FUSE will copy both struct a and the pointed buffer from the\n * process doing the ioctl and retry ioctl with both struct a and the\n * buffer.\n *\n * This time, FUSE server has everything it needs and completes ioctl\n * without FUSE_IOCTL_RETRY which finishes the ioctl call.\n *\n * Copying data out works the same way.\n *\n * Note that if FUSE_IOCTL_UNRESTRICTED is clear, the kernel\n * automatically initializes in and out iovs by decoding @cmd with\n * _IOC_* macros and the server is not allowed to request RETRY.  This\n * limits ioctl data transfers to well-formed ioctls and is the forced\n * behavior for all FUSE servers.\n */\nlong fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct fuse_req *req = NULL;\n\tstruct page **pages = NULL;\n\tstruct iovec *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;\n\tsize_t in_size, out_size, transferred;\n\tint err;\n\n#if BITS_PER_LONG == 32\n\tinarg.flags |= FUSE_IOCTL_32BIT;\n#else\n\tif (flags & FUSE_IOCTL_COMPAT)\n\t\tinarg.flags |= FUSE_IOCTL_32BIT;\n#endif\n\n\t/* assume all the iovs returned by client always fits in a page */\n\tBUILD_BUG_ON(sizeof(struct fuse_ioctl_iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tpages = kcalloc(FUSE_MAX_PAGES_PER_REQ, sizeof(pages[0]), GFP_KERNEL);\n\tiov_page = (struct iovec *) __get_free_page(GFP_KERNEL);\n\tif (!pages || !iov_page)\n\t\tgoto out;\n\n\t/*\n\t * If restricted, initialize IO parameters as encoded in @cmd.\n\t * RETRY from server is not allowed.\n\t */\n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = iov_page;\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t/*\n\t * Out data can be used either for actual out data or iovs,\n\t * make sure there always is at least one page.\n\t */\n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t/* make sure there are enough buffer pages and init request with them */\n\terr = -ENOMEM;\n\tif (max_pages > FUSE_MAX_PAGES_PER_REQ)\n\t\tgoto out;\n\twhile (num_pages < max_pages) {\n\t\tpages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!pages[num_pages])\n\t\t\tgoto out;\n\t\tnum_pages++;\n\t}\n\n\treq = fuse_get_req(fc, num_pages);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\tmemcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);\n\treq->num_pages = num_pages;\n\tfuse_page_descs_length_init(req, 0, req->num_pages);\n\n\t/* okay, let's send it to the client */\n\treq->in.h.opcode = FUSE_IOCTL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tif (in_size) {\n\t\treq->in.numargs++;\n\t\treq->in.args[1].size = in_size;\n\t\treq->in.argpages = 1;\n\n\t\terr = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,\n\t\t\t\t\t   false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\treq->out.args[1].size = out_size;\n\treq->out.argpages = 1;\n\treq->out.argvar = 1;\n\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\ttransferred = req->out.args[1].size;\n\tfuse_put_request(fc, req);\n\treq = NULL;\n\tif (err)\n\t\tgoto out;\n\n\t/* did it ask for retry? */\n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tvoid *vaddr;\n\n\t\t/* no retry if in restricted mode */\n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t/*\n\t\t * Make sure things are in boundary, separate checks\n\t\t * are to protect against overflow.\n\t\t */\n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_atomic(pages[0]);\n\t\terr = fuse_copy_ioctl_iovec(fc, iov_page, vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_atomic(vaddr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tin_iov = iov_page;\n\t\tout_iov = in_iov + in_iovs;\n\n\t\terr = fuse_verify_ioctl_iov(in_iov, in_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = fuse_verify_ioctl_iov(out_iov, out_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tgoto retry;\n\t}\n\n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);\n out:\n\tif (req)\n\t\tfuse_put_request(fc, req);\n\tfree_page((unsigned long) iov_page);\n\twhile (num_pages)\n\t\t__free_page(pages[--num_pages]);\n\tkfree(pages);\n\n\treturn err ? err : outarg.result;\n}\nEXPORT_SYMBOL_GPL(fuse_do_ioctl);\n\nlong fuse_ioctl_common(struct file *file, unsigned int cmd,\n\t\t       unsigned long arg, unsigned int flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}\n\nstatic long fuse_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\treturn fuse_ioctl_common(file, cmd, arg, 0);\n}\n\nstatic long fuse_file_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t   unsigned long arg)\n{\n\treturn fuse_ioctl_common(file, cmd, arg, FUSE_IOCTL_COMPAT);\n}\n\n/*\n * All files which have been polled are linked to RB tree\n * fuse_conn->polled_files which is indexed by kh.  Walk the tree and\n * find the matching one.\n */\nstatic struct rb_node **fuse_find_polled_node(struct fuse_conn *fc, u64 kh,\n\t\t\t\t\t      struct rb_node **parent_out)\n{\n\tstruct rb_node **link = &fc->polled_files.rb_node;\n\tstruct rb_node *last = NULL;\n\n\twhile (*link) {\n\t\tstruct fuse_file *ff;\n\n\t\tlast = *link;\n\t\tff = rb_entry(last, struct fuse_file, polled_node);\n\n\t\tif (kh < ff->kh)\n\t\t\tlink = &last->rb_left;\n\t\telse if (kh > ff->kh)\n\t\t\tlink = &last->rb_right;\n\t\telse\n\t\t\treturn link;\n\t}\n\n\tif (parent_out)\n\t\t*parent_out = last;\n\treturn link;\n}\n\n/*\n * The file is about to be polled.  Make sure it's on the polled_files\n * RB tree.  Note that files once added to the polled_files tree are\n * not removed before the file is released.  This is because a file\n * polled once is likely to be polled again.\n */\nstatic void fuse_register_polled_file(struct fuse_conn *fc,\n\t\t\t\t      struct fuse_file *ff)\n{\n\tspin_lock(&fc->lock);\n\tif (RB_EMPTY_NODE(&ff->polled_node)) {\n\t\tstruct rb_node **link, *uninitialized_var(parent);\n\n\t\tlink = fuse_find_polled_node(fc, ff->kh, &parent);\n\t\tBUG_ON(*link);\n\t\trb_link_node(&ff->polled_node, parent, link);\n\t\trb_insert_color(&ff->polled_node, &fc->polled_files);\n\t}\n\tspin_unlock(&fc->lock);\n}\n\nunsigned fuse_file_poll(struct file *file, poll_table *wait)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_poll_in inarg = { .fh = ff->fh, .kh = ff->kh };\n\tstruct fuse_poll_out outarg;\n\tFUSE_ARGS(args);\n\tint err;\n\n\tif (fc->no_poll)\n\t\treturn DEFAULT_POLLMASK;\n\n\tpoll_wait(file, &ff->poll_wait, wait);\n\tinarg.events = (__u32)poll_requested_events(wait);\n\n\t/*\n\t * Ask for notification iff there's someone waiting for it.\n\t * The client may ignore the flag and always notify.\n\t */\n\tif (waitqueue_active(&ff->poll_wait)) {\n\t\tinarg.flags |= FUSE_POLL_SCHEDULE_NOTIFY;\n\t\tfuse_register_polled_file(fc, ff);\n\t}\n\n\targs.in.h.opcode = FUSE_POLL;\n\targs.in.h.nodeid = ff->nodeid;\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\n\tif (!err)\n\t\treturn outarg.revents;\n\tif (err == -ENOSYS) {\n\t\tfc->no_poll = 1;\n\t\treturn DEFAULT_POLLMASK;\n\t}\n\treturn POLLERR;\n}\nEXPORT_SYMBOL_GPL(fuse_file_poll);\n\n/*\n * This is called from fuse_handle_notify() on FUSE_NOTIFY_POLL and\n * wakes up the poll waiters.\n */\nint fuse_notify_poll_wakeup(struct fuse_conn *fc,\n\t\t\t    struct fuse_notify_poll_wakeup_out *outarg)\n{\n\tu64 kh = outarg->kh;\n\tstruct rb_node **link;\n\n\tspin_lock(&fc->lock);\n\n\tlink = fuse_find_polled_node(fc, kh, NULL);\n\tif (*link) {\n\t\tstruct fuse_file *ff;\n\n\t\tff = rb_entry(*link, struct fuse_file, polled_node);\n\t\twake_up_interruptible_sync(&ff->poll_wait);\n\t}\n\n\tspin_unlock(&fc->lock);\n\treturn 0;\n}\n\nstatic void fuse_do_truncate(struct file *file)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct iattr attr;\n\n\tattr.ia_valid = ATTR_SIZE;\n\tattr.ia_size = i_size_read(inode);\n\n\tattr.ia_file = file;\n\tattr.ia_valid |= ATTR_FILE;\n\n\tfuse_do_setattr(inode, &attr, file);\n}\n\nstatic inline loff_t fuse_round_up(loff_t off)\n{\n\treturn round_up(off, FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT);\n}\n\nstatic ssize_t\nfuse_direct_IO(struct kiocb *iocb, struct iov_iter *iter, loff_t offset)\n{\n\tDECLARE_COMPLETION_ONSTACK(wait);\n\tssize_t ret = 0;\n\tstruct file *file = iocb->ki_filp;\n\tstruct fuse_file *ff = file->private_data;\n\tbool async_dio = ff->fc->async_dio;\n\tloff_t pos = 0;\n\tstruct inode *inode;\n\tloff_t i_size;\n\tsize_t count = iov_iter_count(iter);\n\tstruct fuse_io_priv *io;\n\n\tpos = offset;\n\tinode = file->f_mapping->host;\n\ti_size = i_size_read(inode);\n\n\tif ((iov_iter_rw(iter) == READ) && (offset > i_size))\n\t\treturn 0;\n\n\t/* optimization for short read */\n\tif (async_dio && iov_iter_rw(iter) != WRITE && offset + count > i_size) {\n\t\tif (offset >= i_size)\n\t\t\treturn 0;\n\t\tiov_iter_truncate(iter, fuse_round_up(i_size - offset));\n\t\tcount = iov_iter_count(iter);\n\t}\n\n\tio = kmalloc(sizeof(struct fuse_io_priv), GFP_KERNEL);\n\tif (!io)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&io->lock);\n\tio->reqs = 1;\n\tio->bytes = -1;\n\tio->size = 0;\n\tio->offset = offset;\n\tio->write = (iov_iter_rw(iter) == WRITE);\n\tio->err = 0;\n\tio->file = file;\n\t/*\n\t * By default, we want to optimize all I/Os with async request\n\t * submission to the client filesystem if supported.\n\t */\n\tio->async = async_dio;\n\tio->iocb = iocb;\n\n\t/*\n\t * We cannot asynchronously extend the size of a file. We have no method\n\t * to wait on real async I/O requests, so we must submit this request\n\t * synchronously.\n\t */\n\tif (!is_sync_kiocb(iocb) && (offset + count > i_size) &&\n\t    iov_iter_rw(iter) == WRITE)\n\t\tio->async = false;\n\n\tif (io->async && is_sync_kiocb(iocb))\n\t\tio->done = &wait;\n\n\tif (iov_iter_rw(iter) == WRITE) {\n\t\tret = fuse_direct_io(io, iter, &pos, FUSE_DIO_WRITE);\n\t\tfuse_invalidate_attr(inode);\n\t} else {\n\t\tret = __fuse_direct_read(io, iter, &pos);\n\t}\n\n\tif (io->async) {\n\t\tfuse_aio_complete(io, ret < 0 ? ret : 0, -1);\n\n\t\t/* we have a non-extending, async request, so return */\n\t\tif (!is_sync_kiocb(iocb))\n\t\t\treturn -EIOCBQUEUED;\n\n\t\twait_for_completion(&wait);\n\t\tret = fuse_get_res_by_io(io);\n\t}\n\n\tkfree(io);\n\n\tif (iov_iter_rw(iter) == WRITE) {\n\t\tif (ret > 0)\n\t\t\tfuse_write_update_size(inode, pos);\n\t\telse if (ret < 0 && offset + count > i_size)\n\t\t\tfuse_do_truncate(file);\n\t}\n\n\treturn ret;\n}\n\nstatic long fuse_file_fallocate(struct file *file, int mode, loff_t offset,\n\t\t\t\tloff_t length)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_conn *fc = ff->fc;\n\tFUSE_ARGS(args);\n\tstruct fuse_fallocate_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.offset = offset,\n\t\t.length = length,\n\t\t.mode = mode\n\t};\n\tint err;\n\tbool lock_inode = !(mode & FALLOC_FL_KEEP_SIZE) ||\n\t\t\t   (mode & FALLOC_FL_PUNCH_HOLE);\n\n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (fc->no_fallocate)\n\t\treturn -EOPNOTSUPP;\n\n\tif (lock_inode) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tif (mode & FALLOC_FL_PUNCH_HOLE) {\n\t\t\tloff_t endbyte = offset + length - 1;\n\t\t\terr = filemap_write_and_wait_range(inode->i_mapping,\n\t\t\t\t\t\t\t   offset, endbyte);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tfuse_sync_writes(inode);\n\t\t}\n\t}\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE))\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\targs.in.h.opcode = FUSE_FALLOCATE;\n\targs.in.h.nodeid = ff->nodeid;\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS) {\n\t\tfc->no_fallocate = 1;\n\t\terr = -EOPNOTSUPP;\n\t}\n\tif (err)\n\t\tgoto out;\n\n\t/* we could have extended the file */\n\tif (!(mode & FALLOC_FL_KEEP_SIZE)) {\n\t\tbool changed = fuse_write_update_size(inode, offset + length);\n\n\t\tif (changed && fc->writeback_cache)\n\t\t\tfile_update_time(file);\n\t}\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE)\n\t\ttruncate_pagecache_range(inode, offset, offset + length - 1);\n\n\tfuse_invalidate_attr(inode);\n\nout:\n\tif (!(mode & FALLOC_FL_KEEP_SIZE))\n\t\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\tif (lock_inode)\n\t\tmutex_unlock(&inode->i_mutex);\n\n\treturn err;\n}\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\n\nstatic const struct file_operations fuse_direct_io_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read_iter\t= fuse_direct_read_iter,\n\t.write_iter\t= fuse_direct_write_iter,\n\t.mmap\t\t= fuse_direct_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n\t/* no splice_read */\n};\n\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}\n"], "filenames": ["fs/fuse/file.c"], "buggy_code_start_loc": [1051], "buggy_code_end_loc": [1065], "fixing_code_start_loc": [1052], "fixing_code_end_loc": [1064], "type": "CWE-835", "message": "The fuse_fill_write_pages function in fs/fuse/file.c in the Linux kernel before 4.4 allows local users to cause a denial of service (infinite loop) via a writev system call that triggers a zero length for the first segment of an iov.", "other": {"cve": {"id": "CVE-2015-8785", "sourceIdentifier": "security@debian.org", "published": "2016-02-08T03:59:07.823", "lastModified": "2022-01-31T17:52:44.187", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The fuse_fill_write_pages function in fs/fuse/file.c in the Linux kernel before 4.4 allows local users to cause a denial of service (infinite loop) via a writev system call that triggers a zero length for the first segment of an iov."}, {"lang": "es", "value": "La funci\u00f3n fuse_fill_write_pages en fs/fuse/file.c en el kernel de Linux en versiones anteriores a 4.4 permite a usuarios locales provocar una denegaci\u00f3n de servicio (bucle infinito) a trav\u00e9s de una llamada a sistema writev que desencadena una longitud cero para el primer segmento de un iov."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.4", "matchCriteriaId": "311A4477-1B05-4B33-8886-88EF75FEB5B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "E425B7E4-0104-4CF8-A874-4CAF3273BCDF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.4:rc2:*:*:*:*:*:*", "matchCriteriaId": "C066AC79-4021-4414-A9F2-6B75C2D62773"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.4:rc3:*:*:*:*:*:*", "matchCriteriaId": "A8FD5845-6A12-42D1-B59F-C3F8AED2EFEC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.4:rc4:*:*:*:*:*:*", "matchCriteriaId": "7B37BB89-774E-43E3-B676-BC19C14B1823"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_real_time_extension:12:sp1:*:*:*:*:*:*", "matchCriteriaId": "18D823E3-E1F3-4A15-A9C7-1AB61C1B6703"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=3ca8138f014a913f98e6ef40e939868e1e9ea876", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-03/msg00094.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00015.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00045.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-07/msg00005.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00038.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2016/dsa-3503", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/01/24/1", "source": "security@debian.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinjul2016-3090544.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/ovmbulletinoct2016-3090547.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/81688", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-2886-1", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1290642", "source": "security@debian.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/3ca8138f014a913f98e6ef40e939868e1e9ea876", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/3ca8138f014a913f98e6ef40e939868e1e9ea876"}}