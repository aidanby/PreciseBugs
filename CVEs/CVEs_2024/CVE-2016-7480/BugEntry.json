{"buggy_code": ["/*\n   +----------------------------------------------------------------------+\n   | PHP Version 7                                                        |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 1997-2016 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Authors: Marcus Boerger <helly@php.net>                              |\n   |          Etienne Kneuss <colder@php.net>                             |\n   +----------------------------------------------------------------------+\n */\n\n/* $Id$ */\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include \"php.h\"\n#include \"php_ini.h\"\n#include \"ext/standard/info.h\"\n#include \"ext/standard/php_array.h\"\n#include \"ext/standard/php_var.h\"\n#include \"zend_smart_str.h\"\n#include \"zend_interfaces.h\"\n#include \"zend_exceptions.h\"\n\n#include \"php_spl.h\"\n#include \"spl_functions.h\"\n#include \"spl_engine.h\"\n#include \"spl_observer.h\"\n#include \"spl_iterators.h\"\n#include \"spl_array.h\"\n#include \"spl_exceptions.h\"\n\nSPL_METHOD(SplObserver, update);\nSPL_METHOD(SplSubject, attach);\nSPL_METHOD(SplSubject, detach);\nSPL_METHOD(SplSubject, notify);\n\nZEND_BEGIN_ARG_INFO(arginfo_SplObserver_update, 0)\n\tZEND_ARG_OBJ_INFO(0, SplSubject, SplSubject, 0)\nZEND_END_ARG_INFO();\n\nstatic const zend_function_entry spl_funcs_SplObserver[] = {\n\tSPL_ABSTRACT_ME(SplObserver, update,   arginfo_SplObserver_update)\n\t{NULL, NULL, NULL}\n};\n\nZEND_BEGIN_ARG_INFO(arginfo_SplSubject_attach, 0)\n\tZEND_ARG_OBJ_INFO(0, SplObserver, SplObserver, 0)\nZEND_END_ARG_INFO();\n\nZEND_BEGIN_ARG_INFO(arginfo_SplSubject_void, 0)\nZEND_END_ARG_INFO();\n\n/*ZEND_BEGIN_ARG_INFO_EX(arginfo_SplSubject_notify, 0, 0, 1)\n\tZEND_ARG_OBJ_INFO(0, ignore, SplObserver, 1)\nZEND_END_ARG_INFO();*/\n\nstatic const zend_function_entry spl_funcs_SplSubject[] = {\n\tSPL_ABSTRACT_ME(SplSubject,  attach,   arginfo_SplSubject_attach)\n\tSPL_ABSTRACT_ME(SplSubject,  detach,   arginfo_SplSubject_attach)\n\tSPL_ABSTRACT_ME(SplSubject,  notify,   arginfo_SplSubject_void)\n\t{NULL, NULL, NULL}\n};\n\nPHPAPI zend_class_entry     *spl_ce_SplObserver;\nPHPAPI zend_class_entry     *spl_ce_SplSubject;\nPHPAPI zend_class_entry     *spl_ce_SplObjectStorage;\nPHPAPI zend_class_entry     *spl_ce_MultipleIterator;\n\nPHPAPI zend_object_handlers spl_handler_SplObjectStorage;\n\ntypedef struct _spl_SplObjectStorage { /* {{{ */\n\tHashTable         storage;\n\tzend_long         index;\n\tHashPosition      pos;\n\tzend_long         flags;\n\tzend_function    *fptr_get_hash;\n\tzval             *gcdata;\n\tsize_t            gcdata_num;\n\tzend_object       std;\n} spl_SplObjectStorage; /* }}} */\n\n/* {{{ storage is an assoc aray of [zend_object*]=>[zval *obj, zval *inf] */\ntypedef struct _spl_SplObjectStorageElement {\n\tzval obj;\n\tzval inf;\n} spl_SplObjectStorageElement; /* }}} */\n\nstatic inline spl_SplObjectStorage *spl_object_storage_from_obj(zend_object *obj) /* {{{ */ {\n\treturn (spl_SplObjectStorage*)((char*)(obj) - XtOffsetOf(spl_SplObjectStorage, std));\n}\n/* }}} */\n\n#define Z_SPLOBJSTORAGE_P(zv)  spl_object_storage_from_obj(Z_OBJ_P((zv)))\n\nvoid spl_SplObjectStorage_free_storage(zend_object *object) /* {{{ */\n{\n\tspl_SplObjectStorage *intern = spl_object_storage_from_obj(object);\n\n\tzend_object_std_dtor(&intern->std);\n\n\tzend_hash_destroy(&intern->storage);\n\n\tif (intern->gcdata != NULL) {\n\t\tefree(intern->gcdata);\n\t}\n\n} /* }}} */\n\nstatic zend_string *spl_object_storage_get_hash(spl_SplObjectStorage *intern, zval *this, zval *obj) {\n\tif (intern->fptr_get_hash) {\n\t\tzval rv;\n\t\tzend_call_method_with_1_params(this, intern->std.ce, &intern->fptr_get_hash, \"getHash\", &rv, obj);\n\t\tif (!Z_ISUNDEF(rv)) {\n\t\t\tif (Z_TYPE(rv) == IS_STRING) {\n\t\t\t\treturn Z_STR(rv);\n\t\t\t} else {\n\t\t\t\tzend_throw_exception(spl_ce_RuntimeException, \"Hash needs to be a string\", 0);\n\n\t\t\t\tzval_ptr_dtor(&rv);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tzend_string *hash = zend_string_alloc(sizeof(zend_object*), 0);\n\t\tmemcpy(ZSTR_VAL(hash), (void*)&Z_OBJ_P(obj), sizeof(zend_object*));\n\t\tZSTR_VAL(hash)[ZSTR_LEN(hash)] = '\\0';\n\t\treturn hash;\n\t}\n}\n\nstatic void spl_object_storage_free_hash(spl_SplObjectStorage *intern, zend_string *hash) {\n\tzend_string_release(hash);\n}\n\nstatic void spl_object_storage_dtor(zval *element) /* {{{ */\n{\n\tspl_SplObjectStorageElement *el = Z_PTR_P(element);\n\tzval_ptr_dtor(&el->obj);\n\tzval_ptr_dtor(&el->inf);\n\tefree(el);\n} /* }}} */\n\nspl_SplObjectStorageElement* spl_object_storage_get(spl_SplObjectStorage *intern, zend_string *hash) /* {{{ */\n{\n\treturn (spl_SplObjectStorageElement*)zend_hash_find_ptr(&intern->storage, hash);\n} /* }}} */\n\nspl_SplObjectStorageElement *spl_object_storage_attach(spl_SplObjectStorage *intern, zval *this, zval *obj, zval *inf) /* {{{ */\n{\n\tspl_SplObjectStorageElement *pelement, element;\n\tzend_string *hash = spl_object_storage_get_hash(intern, this, obj);\n\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\n\tpelement = spl_object_storage_get(intern, hash);\n\n\tif (pelement) {\n\t\tzval_ptr_dtor(&pelement->inf);\n\t\tif (inf) {\n\t\t\tZVAL_COPY(&pelement->inf, inf);\n\t\t} else {\n\t\t\tZVAL_NULL(&pelement->inf);\n\t\t}\n\t\tspl_object_storage_free_hash(intern, hash);\n\t\treturn pelement;\n\t}\n\n\tZVAL_COPY(&element.obj, obj);\n\tif (inf) {\n\t\tZVAL_COPY(&element.inf, inf);\n\t} else {\n\t\tZVAL_NULL(&element.inf);\n\t}\n\tpelement = zend_hash_update_mem(&intern->storage, hash, &element, sizeof(spl_SplObjectStorageElement));\n\tspl_object_storage_free_hash(intern, hash);\n\treturn pelement;\n} /* }}} */\n\nint spl_object_storage_detach(spl_SplObjectStorage *intern, zval *this, zval *obj) /* {{{ */\n{\n\tint ret = FAILURE;\n\tzend_string *hash = spl_object_storage_get_hash(intern, this, obj);\n\tif (!hash) {\n\t\treturn ret;\n\t}\n\tret = zend_hash_del(&intern->storage, hash);\n\tspl_object_storage_free_hash(intern, hash);\n\n\treturn ret;\n} /* }}}*/\n\nvoid spl_object_storage_addall(spl_SplObjectStorage *intern, zval *this, spl_SplObjectStorage *other) { /* {{{ */\n\tspl_SplObjectStorageElement *element;\n\n\tZEND_HASH_FOREACH_PTR(&other->storage, element) {\n\t\tspl_object_storage_attach(intern, this, &element->obj, &element->inf);\n\t} ZEND_HASH_FOREACH_END();\n\n\tintern->index = 0;\n} /* }}} */\n\nstatic zend_object *spl_object_storage_new_ex(zend_class_entry *class_type, zval *orig) /* {{{ */\n{\n\tspl_SplObjectStorage *intern;\n\tzend_class_entry *parent = class_type;\n\n\tintern = emalloc(sizeof(spl_SplObjectStorage) + zend_object_properties_size(parent));\n\tmemset(intern, 0, sizeof(spl_SplObjectStorage) - sizeof(zval));\n\tintern->pos = HT_INVALID_IDX;\n\n\tzend_object_std_init(&intern->std, class_type);\n\tobject_properties_init(&intern->std, class_type);\n\n\tzend_hash_init(&intern->storage, 0, NULL, spl_object_storage_dtor, 0);\n\n\tintern->std.handlers = &spl_handler_SplObjectStorage;\n\n\twhile (parent) {\n\t\tif (parent == spl_ce_SplObjectStorage) {\n\t\t\tif (class_type != spl_ce_SplObjectStorage) {\n\t\t\t\tintern->fptr_get_hash = zend_hash_str_find_ptr(&class_type->function_table, \"gethash\", sizeof(\"gethash\") - 1);\n\t\t\t\tif (intern->fptr_get_hash->common.scope == spl_ce_SplObjectStorage) {\n\t\t\t\t\tintern->fptr_get_hash = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tparent = parent->parent;\n\t}\n\n\tif (orig) {\n\t\tspl_SplObjectStorage *other = Z_SPLOBJSTORAGE_P(orig);\n\t\tspl_object_storage_addall(intern, orig, other);\n\t}\n\n\treturn &intern->std;\n}\n/* }}} */\n\n/* {{{ spl_object_storage_clone */\nstatic zend_object *spl_object_storage_clone(zval *zobject)\n{\n\tzend_object *old_object;\n\tzend_object *new_object;\n\n\told_object = Z_OBJ_P(zobject);\n\tnew_object = spl_object_storage_new_ex(old_object->ce, zobject);\n\n\tzend_objects_clone_members(new_object, old_object);\n\n\treturn new_object;\n}\n/* }}} */\n\nstatic HashTable* spl_object_storage_debug_info(zval *obj, int *is_temp) /* {{{ */\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(obj);\n\tspl_SplObjectStorageElement *element;\n\tHashTable *props;\n\tzval tmp, storage;\n\tzend_string *md5str;\n\tzend_string *zname;\n\tHashTable *debug_info;\n\n\t*is_temp = 1;\n\n\tprops = Z_OBJPROP_P(obj);\n\n\tALLOC_HASHTABLE(debug_info);\n\tZEND_INIT_SYMTABLE_EX(debug_info, zend_hash_num_elements(props) + 1, 0);\n\tzend_hash_copy(debug_info, props, (copy_ctor_func_t)zval_add_ref);\n\n\tarray_init(&storage);\n\n\tZEND_HASH_FOREACH_PTR(&intern->storage, element) {\n\t\tmd5str = php_spl_object_hash(&element->obj);\n\t\tarray_init(&tmp);\n\t\t/* Incrementing the refcount of obj and inf would confuse the garbage collector.\n\t\t * Prefer to null the destructor */\n\t\tZ_ARRVAL_P(&tmp)->pDestructor = NULL;\n\t\tadd_assoc_zval_ex(&tmp, \"obj\", sizeof(\"obj\") - 1, &element->obj);\n\t\tadd_assoc_zval_ex(&tmp, \"inf\", sizeof(\"inf\") - 1, &element->inf);\n\t\tzend_hash_update(Z_ARRVAL(storage), md5str, &tmp);\n\t\tzend_string_release(md5str);\n\t} ZEND_HASH_FOREACH_END();\n\n\tzname = spl_gen_private_prop_name(spl_ce_SplObjectStorage, \"storage\", sizeof(\"storage\")-1);\n\tzend_symtable_update(debug_info, zname, &storage);\n\tzend_string_release(zname);\n\n\treturn debug_info;\n}\n/* }}} */\n\n/* overriden for garbage collection */\nstatic HashTable *spl_object_storage_get_gc(zval *obj, zval **table, int *n) /* {{{ */\n{\n\tint i = 0;\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(obj);\n\tspl_SplObjectStorageElement *element;\n\n\tif (intern->storage.nNumOfElements * 2 > intern->gcdata_num) {\n\t\tintern->gcdata_num = intern->storage.nNumOfElements * 2;\n\t\tintern->gcdata = (zval*)erealloc(intern->gcdata, sizeof(zval) * intern->gcdata_num);\n\t}\n\n\tZEND_HASH_FOREACH_PTR(&intern->storage, element) {\n\t\tZVAL_COPY_VALUE(&intern->gcdata[i++], &element->obj);\n\t\tZVAL_COPY_VALUE(&intern->gcdata[i++], &element->inf);\n\t} ZEND_HASH_FOREACH_END();\n\n\t*table = intern->gcdata;\n\t*n = i;\n\n\treturn std_object_handlers.get_properties(obj);\n}\n/* }}} */\n\nstatic int spl_object_storage_compare_info(zval *e1, zval *e2) /* {{{ */\n{\n\tspl_SplObjectStorageElement *s1 = (spl_SplObjectStorageElement*)Z_PTR_P(e1);\n\tspl_SplObjectStorageElement *s2 = (spl_SplObjectStorageElement*)Z_PTR_P(e2);\n\tzval result;\n\n\tif (compare_function(&result, &s1->inf, &s2->inf) == FAILURE) {\n\t\treturn 1;\n\t}\n\n\treturn Z_LVAL(result) > 0 ? 1 : (Z_LVAL(result) < 0 ? -1 : 0);\n}\n/* }}} */\n\nstatic int spl_object_storage_compare_objects(zval *o1, zval *o2) /* {{{ */\n{\n\tzend_object *zo1 = (zend_object *)Z_OBJ_P(o1);\n\tzend_object *zo2 = (zend_object *)Z_OBJ_P(o2);\n\n\tif (zo1->ce != spl_ce_SplObjectStorage || zo2->ce != spl_ce_SplObjectStorage) {\n\t\treturn 1;\n\t}\n\n\treturn zend_hash_compare(&(Z_SPLOBJSTORAGE_P(o1))->storage, &(Z_SPLOBJSTORAGE_P(o2))->storage, (compare_func_t)spl_object_storage_compare_info, 0);\n}\n/* }}} */\n\n/* {{{ spl_array_object_new */\nstatic zend_object *spl_SplObjectStorage_new(zend_class_entry *class_type)\n{\n\treturn spl_object_storage_new_ex(class_type, NULL);\n}\n/* }}} */\n\nint spl_object_storage_contains(spl_SplObjectStorage *intern, zval *this, zval *obj) /* {{{ */\n{\n\tint found;\n\tzend_string *hash = spl_object_storage_get_hash(intern, this, obj);\n\tif (!hash) {\n\t\treturn 0;\n\t}\n\n\tfound = zend_hash_exists(&intern->storage, hash);\n\tspl_object_storage_free_hash(intern, hash);\n\treturn found;\n} /* }}} */\n\n/* {{{ proto void SplObjectStorage::attach(object obj, mixed inf = NULL)\n Attaches an object to the storage if not yet contained */\nSPL_METHOD(SplObjectStorage, attach)\n{\n\tzval *obj, *inf = NULL;\n\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"o|z!\", &obj, &inf) == FAILURE) {\n\t\treturn;\n\t}\n\tspl_object_storage_attach(intern, getThis(), obj, inf);\n} /* }}} */\n\n/* {{{ proto void SplObjectStorage::detach(object obj)\n Detaches an object from the storage */\nSPL_METHOD(SplObjectStorage, detach)\n{\n\tzval *obj;\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"o\", &obj) == FAILURE) {\n\t\treturn;\n\t}\n\tspl_object_storage_detach(intern, getThis(), obj);\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\tintern->index = 0;\n} /* }}} */\n\n/* {{{ proto string SplObjectStorage::getHash(object obj)\n Returns the hash of an object */\nSPL_METHOD(SplObjectStorage, getHash)\n{\n\tzval *obj;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"o\", &obj) == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_NEW_STR(php_spl_object_hash(obj));\n\n} /* }}} */\n\n/* {{{ proto mixed SplObjectStorage::offsetGet(object obj)\n Returns associated information for a stored object */\nSPL_METHOD(SplObjectStorage, offsetGet)\n{\n\tzval *obj;\n\tspl_SplObjectStorageElement *element;\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\tzend_string *hash;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"o\", &obj) == FAILURE) {\n\t\treturn;\n\t}\n\n\thash = spl_object_storage_get_hash(intern, getThis(), obj);\n\tif (!hash) {\n\t\treturn;\n\t}\n\n\telement = spl_object_storage_get(intern, hash);\n\tspl_object_storage_free_hash(intern, hash);\n\n\tif (!element) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0, \"Object not found\");\n\t} else {\n\t\tzval *value = &element->inf;\n\n\t\tZVAL_DEREF(value);\n\t\tZVAL_COPY(return_value, value);\n\t}\n} /* }}} */\n\n/* {{{ proto bool SplObjectStorage::addAll(SplObjectStorage $os)\n Add all elements contained in $os */\nSPL_METHOD(SplObjectStorage, addAll)\n{\n\tzval *obj;\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\tspl_SplObjectStorage *other;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"O\", &obj, spl_ce_SplObjectStorage) == FAILURE) {\n\t\treturn;\n\t}\n\n\tother = Z_SPLOBJSTORAGE_P(obj);\n\n\tspl_object_storage_addall(intern, getThis(), other);\n\n\tRETURN_LONG(zend_hash_num_elements(&intern->storage));\n} /* }}} */\n\n/* {{{ proto bool SplObjectStorage::removeAll(SplObjectStorage $os)\n Remove all elements contained in $os */\nSPL_METHOD(SplObjectStorage, removeAll)\n{\n\tzval *obj;\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\tspl_SplObjectStorage *other;\n\tspl_SplObjectStorageElement *element;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"O\", &obj, spl_ce_SplObjectStorage) == FAILURE) {\n\t\treturn;\n\t}\n\n\tother = Z_SPLOBJSTORAGE_P(obj);\n\n\tzend_hash_internal_pointer_reset(&other->storage);\n\twhile ((element = zend_hash_get_current_data_ptr(&other->storage)) != NULL) {\n\t\tif (spl_object_storage_detach(intern, getThis(), &element->obj) == FAILURE) {\n\t\t\tzend_hash_move_forward(&other->storage);\n\t\t}\n\t}\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\tintern->index = 0;\n\n\tRETURN_LONG(zend_hash_num_elements(&intern->storage));\n} /* }}} */\n\n/* {{{ proto bool SplObjectStorage::removeAllExcept(SplObjectStorage $os)\n Remove elements not common to both this SplObjectStorage instance and $os */\nSPL_METHOD(SplObjectStorage, removeAllExcept)\n{\n\tzval *obj;\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\tspl_SplObjectStorage *other;\n\tspl_SplObjectStorageElement *element;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"O\", &obj, spl_ce_SplObjectStorage) == FAILURE) {\n\t\treturn;\n\t}\n\n\tother = Z_SPLOBJSTORAGE_P(obj);\n\n\tZEND_HASH_FOREACH_PTR(&intern->storage, element) {\n\t\tif (!spl_object_storage_contains(other, getThis(), &element->obj)) {\n\t\t\tspl_object_storage_detach(intern, getThis(), &element->obj);\n\t\t}\n\t} ZEND_HASH_FOREACH_END();\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\tintern->index = 0;\n\n\tRETURN_LONG(zend_hash_num_elements(&intern->storage));\n}\n/* }}} */\n\n/* {{{ proto bool SplObjectStorage::contains(object obj)\n Determine whethe an object is contained in the storage */\nSPL_METHOD(SplObjectStorage, contains)\n{\n\tzval *obj;\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"o\", &obj) == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_BOOL(spl_object_storage_contains(intern, getThis(), obj));\n} /* }}} */\n\n/* {{{ proto int SplObjectStorage::count()\n Determine number of objects in storage */\nSPL_METHOD(SplObjectStorage, count)\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\tzend_long mode = COUNT_NORMAL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"|l\", &mode) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (mode == COUNT_RECURSIVE) {\n\t\tzend_long ret = zend_hash_num_elements(&intern->storage);\n\t\tzval *element;\n\n\t\tZEND_HASH_FOREACH_VAL(&intern->storage, element) {\n\t\t\tret += php_count_recursive(element, mode);\n\t\t} ZEND_HASH_FOREACH_END();\n\n\t\tRETURN_LONG(ret);\n\t\treturn;\n\t}\n\n\tRETURN_LONG(zend_hash_num_elements(&intern->storage));\n} /* }}} */\n\n/* {{{ proto void SplObjectStorage::rewind()\n Rewind to first position */\nSPL_METHOD(SplObjectStorage, rewind)\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\tintern->index = 0;\n} /* }}} */\n\n/* {{{ proto bool SplObjectStorage::valid()\n Returns whether current position is valid */\nSPL_METHOD(SplObjectStorage, valid)\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_BOOL(zend_hash_has_more_elements_ex(&intern->storage, &intern->pos) == SUCCESS);\n} /* }}} */\n\n/* {{{ proto mixed SplObjectStorage::key()\n Returns current key */\nSPL_METHOD(SplObjectStorage, key)\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG(intern->index);\n} /* }}} */\n\n/* {{{ proto mixed SplObjectStorage::current()\n Returns current element */\nSPL_METHOD(SplObjectStorage, current)\n{\n\tspl_SplObjectStorageElement *element;\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((element = zend_hash_get_current_data_ptr_ex(&intern->storage, &intern->pos)) == NULL) {\n\t\treturn;\n\t}\n\tZVAL_COPY(return_value, &element->obj);\n} /* }}} */\n\n/* {{{ proto mixed SplObjectStorage::getInfo()\n Returns associated information to current element */\nSPL_METHOD(SplObjectStorage, getInfo)\n{\n\tspl_SplObjectStorageElement *element;\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((element = zend_hash_get_current_data_ptr_ex(&intern->storage, &intern->pos)) == NULL) {\n\t\treturn;\n\t}\n\tZVAL_COPY(return_value, &element->inf);\n} /* }}} */\n\n/* {{{ proto mixed SplObjectStorage::setInfo(mixed $inf)\n Sets associated information of current element to $inf */\nSPL_METHOD(SplObjectStorage, setInfo)\n{\n\tspl_SplObjectStorageElement *element;\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\tzval *inf;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"z\", &inf) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((element = zend_hash_get_current_data_ptr_ex(&intern->storage, &intern->pos)) == NULL) {\n\t\treturn;\n\t}\n\tzval_ptr_dtor(&element->inf);\n\tZVAL_COPY(&element->inf, inf);\n} /* }}} */\n\n/* {{{ proto void SplObjectStorage::next()\n Moves position forward */\nSPL_METHOD(SplObjectStorage, next)\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tzend_hash_move_forward_ex(&intern->storage, &intern->pos);\n\tintern->index++;\n} /* }}} */\n\n/* {{{ proto string SplObjectStorage::serialize()\n Serializes storage */\nSPL_METHOD(SplObjectStorage, serialize)\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tspl_SplObjectStorageElement *element;\n\tzval members, flags;\n\tHashPosition      pos;\n\tphp_serialize_data_t var_hash;\n\tsmart_str buf = {0};\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_VAR_SERIALIZE_INIT(var_hash);\n\n\t/* storage */\n\tsmart_str_appendl(&buf, \"x:\", 2);\n\tZVAL_LONG(&flags, zend_hash_num_elements(&intern->storage));\n\tphp_var_serialize(&buf, &flags, &var_hash);\n\tzval_ptr_dtor(&flags);\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &pos);\n\n\twhile (zend_hash_has_more_elements_ex(&intern->storage, &pos) == SUCCESS) {\n\t\tif ((element = zend_hash_get_current_data_ptr_ex(&intern->storage, &pos)) == NULL) {\n\t\t\tsmart_str_free(&buf);\n\t\t\tPHP_VAR_SERIALIZE_DESTROY(var_hash);\n\t\t\tRETURN_NULL();\n\t\t}\n\t\tphp_var_serialize(&buf, &element->obj, &var_hash);\n\t\tsmart_str_appendc(&buf, ',');\n\t\tphp_var_serialize(&buf, &element->inf, &var_hash);\n\t\tsmart_str_appendc(&buf, ';');\n\t\tzend_hash_move_forward_ex(&intern->storage, &pos);\n\t}\n\n\t/* members */\n\tsmart_str_appendl(&buf, \"m:\", 2);\n\n\tZVAL_ARR(&members, zend_array_dup(zend_std_get_properties(getThis())));\n\tphp_var_serialize(&buf, &members, &var_hash); /* finishes the string */\n\tzval_ptr_dtor(&members);\n\n\t/* done */\n\tPHP_VAR_SERIALIZE_DESTROY(var_hash);\n\n\tif (buf.s) {\n\t\tRETURN_NEW_STR(buf.s);\n\t} else {\n\t\tRETURN_NULL();\n\t}\n\n} /* }}} */\n\n/* {{{ proto void SplObjectStorage::unserialize(string serialized)\n Unserializes storage */\nSPL_METHOD(SplObjectStorage, unserialize)\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tchar *buf;\n\tsize_t buf_len;\n\tconst unsigned char *p, *s;\n\tphp_unserialize_data_t var_hash;\n\tzval entry, inf;\n\tzval *pcount, *pmembers;\n\tspl_SplObjectStorageElement *element;\n\tzend_long count;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &buf, &buf_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (buf_len == 0) {\n\t\treturn;\n\t}\n\n\t/* storage */\n\ts = p = (const unsigned char*)buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\n\tif (*p!= 'x' || *++p != ':') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\tpcount = var_tmp_var(&var_hash);\n\tif (!php_var_unserialize(pcount, &p, s + buf_len, &var_hash) || Z_TYPE_P(pcount) != IS_LONG) {\n\t\tgoto outexcept;\n\t}\n\n\t--p; /* for ';' */\n\tcount = Z_LVAL_P(pcount);\n\n\twhile (count-- > 0) {\n\t\tspl_SplObjectStorageElement *pelement;\n\t\tzend_string *hash;\n\n\t\tif (*p != ';') {\n\t\t\tgoto outexcept;\n\t\t}\n\t\t++p;\n\t\tif(*p != 'O' && *p != 'C' && *p != 'r') {\n\t\t\tgoto outexcept;\n\t\t}\n\t\t/* store reference to allow cross-references between different elements */\n\t\tif (!php_var_unserialize(&entry, &p, s + buf_len, &var_hash)) {\n\t\t\tgoto outexcept;\n\t\t}\n\t\tif (Z_TYPE(entry) != IS_OBJECT) {\n\t\t\tzval_ptr_dtor(&entry);\n\t\t\tgoto outexcept;\n\t\t}\n\t\tif (*p == ',') { /* new version has inf */\n\t\t\t++p;\n\t\t\tif (!php_var_unserialize(&inf, &p, s + buf_len, &var_hash)) {\n\t\t\t\tzval_ptr_dtor(&entry);\n\t\t\t\tgoto outexcept;\n\t\t\t}\n\t\t} else {\n\t\t\tZVAL_UNDEF(&inf);\n\t\t}\n\n\t\thash = spl_object_storage_get_hash(intern, getThis(), &entry);\n\t\tif (!hash) {\n\t\t\tzval_ptr_dtor(&entry);\n\t\t\tzval_ptr_dtor(&inf);\n\t\t\tgoto outexcept;\n\t\t}\n\t\tpelement = spl_object_storage_get(intern, hash);\n\t\tspl_object_storage_free_hash(intern, hash);\n\t\tif (pelement) {\n\t\t\tif (!Z_ISUNDEF(pelement->inf)) {\n\t\t\t\tvar_push_dtor(&var_hash, &pelement->inf);\n\t\t\t}\n\t\t\tif (!Z_ISUNDEF(pelement->obj)) {\n\t\t\t\tvar_push_dtor(&var_hash, &pelement->obj);\n\t\t\t}\n\t\t}\n\t\telement = spl_object_storage_attach(intern, getThis(), &entry, Z_ISUNDEF(inf)?NULL:&inf);\n\t\tvar_replace(&var_hash, &entry, &element->obj);\n\t\tvar_replace(&var_hash, &inf, &element->inf);\n\t\tzval_ptr_dtor(&entry);\n\t\tZVAL_UNDEF(&entry);\n\t\tzval_ptr_dtor(&inf);\n\t\tZVAL_UNDEF(&inf);\n\t}\n\n\tif (*p != ';') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\t/* members */\n\tif (*p!= 'm' || *++p != ':') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\tpmembers = var_tmp_var(&var_hash);\n\tif (!php_var_unserialize(pmembers, &p, s + buf_len, &var_hash) || Z_TYPE_P(pmembers) != IS_ARRAY) {\n\t\tgoto outexcept;\n\t}\n\n\t/* copy members */\n\tobject_properties_load(&intern->std, Z_ARRVAL_P(pmembers));\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\treturn;\n\noutexcept:\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0, \"Error at offset %pd of %d bytes\", (zend_long)((char*)p - buf), buf_len);\n\treturn;\n\n} /* }}} */\n\nZEND_BEGIN_ARG_INFO(arginfo_Object, 0)\n\tZEND_ARG_INFO(0, object)\nZEND_END_ARG_INFO();\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_attach, 0, 0, 1)\n\tZEND_ARG_INFO(0, object)\n\tZEND_ARG_INFO(0, inf)\nZEND_END_ARG_INFO();\n\nZEND_BEGIN_ARG_INFO(arginfo_Serialized, 0)\n\tZEND_ARG_INFO(0, serialized)\nZEND_END_ARG_INFO();\n\nZEND_BEGIN_ARG_INFO(arginfo_setInfo, 0)\n\tZEND_ARG_INFO(0, info)\nZEND_END_ARG_INFO();\n\nZEND_BEGIN_ARG_INFO(arginfo_getHash, 0)\n\tZEND_ARG_INFO(0, object)\nZEND_END_ARG_INFO();\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_offsetGet, 0, 0, 1)\n\tZEND_ARG_INFO(0, object)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO(arginfo_splobject_void, 0)\nZEND_END_ARG_INFO()\n\nstatic const zend_function_entry spl_funcs_SplObjectStorage[] = {\n\tSPL_ME(SplObjectStorage,  attach,      arginfo_attach,        0)\n\tSPL_ME(SplObjectStorage,  detach,      arginfo_Object,        0)\n\tSPL_ME(SplObjectStorage,  contains,    arginfo_Object,        0)\n\tSPL_ME(SplObjectStorage,  addAll,      arginfo_Object,        0)\n\tSPL_ME(SplObjectStorage,  removeAll,   arginfo_Object,        0)\n\tSPL_ME(SplObjectStorage,  removeAllExcept,   arginfo_Object,  0)\n\tSPL_ME(SplObjectStorage,  getInfo,     arginfo_splobject_void,0)\n\tSPL_ME(SplObjectStorage,  setInfo,     arginfo_setInfo,       0)\n\tSPL_ME(SplObjectStorage,  getHash,     arginfo_getHash,       0)\n\t/* Countable */\n\tSPL_ME(SplObjectStorage,  count,       arginfo_splobject_void,0)\n\t/* Iterator */\n\tSPL_ME(SplObjectStorage,  rewind,      arginfo_splobject_void,0)\n\tSPL_ME(SplObjectStorage,  valid,       arginfo_splobject_void,0)\n\tSPL_ME(SplObjectStorage,  key,         arginfo_splobject_void,0)\n\tSPL_ME(SplObjectStorage,  current,     arginfo_splobject_void,0)\n\tSPL_ME(SplObjectStorage,  next,        arginfo_splobject_void,0)\n\t/* Serializable */\n\tSPL_ME(SplObjectStorage,  unserialize, arginfo_Serialized,    0)\n\tSPL_ME(SplObjectStorage,  serialize,   arginfo_splobject_void,0)\n\t/* ArrayAccess */\n\tSPL_MA(SplObjectStorage, offsetExists, SplObjectStorage, contains, arginfo_offsetGet, 0)\n\tSPL_MA(SplObjectStorage, offsetSet,    SplObjectStorage, attach,   arginfo_attach, 0)\n\tSPL_MA(SplObjectStorage, offsetUnset,  SplObjectStorage, detach,   arginfo_offsetGet, 0)\n\tSPL_ME(SplObjectStorage, offsetGet,    arginfo_offsetGet,     0)\n\t{NULL, NULL, NULL}\n};\n\ntypedef enum {\n\tMIT_NEED_ANY     = 0,\n\tMIT_NEED_ALL     = 1,\n\tMIT_KEYS_NUMERIC = 0,\n\tMIT_KEYS_ASSOC   = 2\n} MultipleIteratorFlags;\n\n#define SPL_MULTIPLE_ITERATOR_GET_ALL_CURRENT   1\n#define SPL_MULTIPLE_ITERATOR_GET_ALL_KEY       2\n\n/* {{{ proto void MultipleIterator::__construct([int flags = MIT_NEED_ALL|MIT_KEYS_NUMERIC])\n   Iterator that iterates over several iterators one after the other */\nSPL_METHOD(MultipleIterator, __construct)\n{\n\tspl_SplObjectStorage   *intern;\n\tzend_long               flags = MIT_NEED_ALL|MIT_KEYS_NUMERIC;\n\n\tif (zend_parse_parameters_throw(ZEND_NUM_ARGS(), \"|l\", &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern = Z_SPLOBJSTORAGE_P(getThis());\n\tintern->flags = flags;\n}\n/* }}} */\n\n/* {{{ proto int MultipleIterator::getFlags()\n   Return current flags */\nSPL_METHOD(MultipleIterator, getFlags)\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_LONG(intern->flags);\n}\n/* }}} */\n\n/* {{{ proto int MultipleIterator::setFlags(int flags)\n   Set flags */\nSPL_METHOD(MultipleIterator, setFlags)\n{\n\tspl_SplObjectStorage *intern;\n\tintern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l\", &intern->flags) == FAILURE) {\n\t\treturn;\n\t}\n}\n/* }}} */\n\n/* {{{ proto void attachIterator(Iterator iterator[, mixed info]) throws InvalidArgumentException\n   Attach a new iterator */\nSPL_METHOD(MultipleIterator, attachIterator)\n{\n\tspl_SplObjectStorage        *intern;\n\tzval                        *iterator = NULL, *info = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"O|z!\", &iterator, zend_ce_iterator, &info) == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (info != NULL) {\n\t\tspl_SplObjectStorageElement *element;\n\n\t\tif (Z_TYPE_P(info) != IS_LONG && Z_TYPE_P(info) != IS_STRING) {\n\t\t\tzend_throw_exception(spl_ce_InvalidArgumentException, \"Info must be NULL, integer or string\", 0);\n\t\t\treturn;\n\t\t}\n\n\t\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\t\twhile ((element = zend_hash_get_current_data_ptr_ex(&intern->storage, &intern->pos)) != NULL) {\n\t\t\tif (fast_is_identical_function(info, &element->inf)) {\n\t\t\t\tzend_throw_exception(spl_ce_InvalidArgumentException, \"Key duplication error\", 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tzend_hash_move_forward_ex(&intern->storage, &intern->pos);\n\t\t}\n\t}\n\n\tspl_object_storage_attach(intern, getThis(), iterator, info);\n}\n/* }}} */\n\n/* {{{ proto void MultipleIterator::rewind()\n   Rewind all attached iterator instances */\nSPL_METHOD(MultipleIterator, rewind)\n{\n\tspl_SplObjectStorage        *intern;\n\tspl_SplObjectStorageElement *element;\n\tzval                        *it;\n\n\tintern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\twhile ((element = zend_hash_get_current_data_ptr_ex(&intern->storage, &intern->pos)) != NULL && !EG(exception)) {\n\t\tit = &element->obj;\n\t\tzend_call_method_with_0_params(it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_rewind, \"rewind\", NULL);\n\t\tzend_hash_move_forward_ex(&intern->storage, &intern->pos);\n\t}\n}\n/* }}} */\n\n/* {{{ proto void MultipleIterator::next()\n   Move all attached iterator instances forward */\nSPL_METHOD(MultipleIterator, next)\n{\n\tspl_SplObjectStorage        *intern;\n\tspl_SplObjectStorageElement *element;\n\tzval                        *it;\n\n\tintern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\twhile ((element = zend_hash_get_current_data_ptr_ex(&intern->storage, &intern->pos)) != NULL && !EG(exception)) {\n\t\tit = &element->obj;\n\t\tzend_call_method_with_0_params(it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_next, \"next\", NULL);\n\t\tzend_hash_move_forward_ex(&intern->storage, &intern->pos);\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool MultipleIterator::valid()\n   Return whether all or one sub iterator is valid depending on flags */\nSPL_METHOD(MultipleIterator, valid)\n{\n\tspl_SplObjectStorage        *intern;\n\tspl_SplObjectStorageElement *element;\n\tzval                        *it, retval;\n\tzend_long                         expect, valid;\n\n\tintern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!zend_hash_num_elements(&intern->storage)) {\n\t\tRETURN_FALSE;\n\t}\n\n\texpect = (intern->flags & MIT_NEED_ALL) ? 1 : 0;\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\twhile ((element = zend_hash_get_current_data_ptr_ex(&intern->storage, &intern->pos)) != NULL && !EG(exception)) {\n\t\tit = &element->obj;\n\t\tzend_call_method_with_0_params(it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_valid, \"valid\", &retval);\n\n\t\tif (!Z_ISUNDEF(retval)) {\n\t\t\tvalid = (Z_TYPE(retval) == IS_TRUE);\n\t\t\tzval_ptr_dtor(&retval);\n\t\t} else {\n\t\t\tvalid = 0;\n\t\t}\n\n\t\tif (expect != valid) {\n\t\t\tRETURN_BOOL(!expect);\n\t\t}\n\n\t\tzend_hash_move_forward_ex(&intern->storage, &intern->pos);\n\t}\n\n\tRETURN_BOOL(expect);\n}\n/* }}} */\n\nstatic void spl_multiple_iterator_get_all(spl_SplObjectStorage *intern, int get_type, zval *return_value) /* {{{ */\n{\n\tspl_SplObjectStorageElement *element;\n\tzval                        *it, retval;\n\tint                          valid = 1, num_elements;\n\n\tnum_elements = zend_hash_num_elements(&intern->storage);\n\tif (num_elements < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init_size(return_value, num_elements);\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\twhile ((element = zend_hash_get_current_data_ptr_ex(&intern->storage, &intern->pos)) != NULL && !EG(exception)) {\n\t\tit = &element->obj;\n\t\tzend_call_method_with_0_params(it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_valid, \"valid\", &retval);\n\n\t\tif (!Z_ISUNDEF(retval)) {\n\t\t\tvalid = Z_TYPE(retval) == IS_TRUE;\n\t\t\tzval_ptr_dtor(&retval);\n\t\t} else {\n\t\t\tvalid = 0;\n\t\t}\n\n\t\tif (valid) {\n\t\t\tif (SPL_MULTIPLE_ITERATOR_GET_ALL_CURRENT == get_type) {\n\t\t\t\tzend_call_method_with_0_params(it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_current, \"current\", &retval);\n\t\t\t} else {\n\t\t\t\tzend_call_method_with_0_params(it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_key, \"key\", &retval);\n\t\t\t}\n\t\t\tif (Z_ISUNDEF(retval)) {\n\t\t\t\tzend_throw_exception(spl_ce_RuntimeException, \"Failed to call sub iterator method\", 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (intern->flags & MIT_NEED_ALL) {\n\t\t\tif (SPL_MULTIPLE_ITERATOR_GET_ALL_CURRENT == get_type) {\n\t\t\t\tzend_throw_exception(spl_ce_RuntimeException, \"Called current() with non valid sub iterator\", 0);\n\t\t\t} else {\n\t\t\t\tzend_throw_exception(spl_ce_RuntimeException, \"Called key() with non valid sub iterator\", 0);\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\tZVAL_NULL(&retval);\n\t\t}\n\n\t\tif (intern->flags & MIT_KEYS_ASSOC) {\n\t\t\tswitch (Z_TYPE(element->inf)) {\n\t\t\t\tcase IS_LONG:\n\t\t\t\t\tadd_index_zval(return_value, Z_LVAL(element->inf), &retval);\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_STRING:\n\t\t\t\t\tzend_symtable_update(Z_ARRVAL_P(return_value), Z_STR(element->inf), &retval);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t\t\tzend_throw_exception(spl_ce_InvalidArgumentException, \"Sub-Iterator is associated with NULL\", 0);\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tadd_next_index_zval(return_value, &retval);\n\t\t}\n\n\t\tzend_hash_move_forward_ex(&intern->storage, &intern->pos);\n\t}\n}\n/* }}} */\n\n/* {{{ proto array current() throws RuntimeException throws InvalidArgumentException\n   Return an array of all registered Iterator instances current() result */\nSPL_METHOD(MultipleIterator, current)\n{\n\tspl_SplObjectStorage        *intern;\n\tintern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_multiple_iterator_get_all(intern, SPL_MULTIPLE_ITERATOR_GET_ALL_CURRENT, return_value);\n}\n/* }}} */\n\n/* {{{ proto array MultipleIterator::key()\n   Return an array of all registered Iterator instances key() result */\nSPL_METHOD(MultipleIterator, key)\n{\n\tspl_SplObjectStorage *intern;\n\tintern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_multiple_iterator_get_all(intern, SPL_MULTIPLE_ITERATOR_GET_ALL_KEY, return_value);\n}\n/* }}} */\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_MultipleIterator_attachIterator, 0, 0, 1)\n\tZEND_ARG_OBJ_INFO(0, iterator, Iterator, 0)\n\tZEND_ARG_INFO(0, infos)\nZEND_END_ARG_INFO();\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_MultipleIterator_detachIterator, 0, 0, 1)\n\tZEND_ARG_OBJ_INFO(0, iterator, Iterator, 0)\nZEND_END_ARG_INFO();\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_MultipleIterator_containsIterator, 0, 0, 1)\n\tZEND_ARG_OBJ_INFO(0, iterator, Iterator, 0)\nZEND_END_ARG_INFO();\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_MultipleIterator_setflags, 0, 0, 1)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO();\n\nstatic const zend_function_entry spl_funcs_MultipleIterator[] = {\n\tSPL_ME(MultipleIterator,  __construct,            arginfo_MultipleIterator_setflags,          0)\n\tSPL_ME(MultipleIterator,  getFlags,               arginfo_splobject_void,                     0)\n\tSPL_ME(MultipleIterator,  setFlags,               arginfo_MultipleIterator_setflags,          0)\n\tSPL_ME(MultipleIterator,  attachIterator,         arginfo_MultipleIterator_attachIterator,    0)\n\tSPL_MA(MultipleIterator,  detachIterator,         SplObjectStorage, detach,   arginfo_MultipleIterator_detachIterator,   0)\n\tSPL_MA(MultipleIterator,  containsIterator,       SplObjectStorage, contains, arginfo_MultipleIterator_containsIterator, 0)\n\tSPL_MA(MultipleIterator,  countIterators,         SplObjectStorage, count,    arginfo_splobject_void,                    0)\n\t/* Iterator */\n\tSPL_ME(MultipleIterator,  rewind,                 arginfo_splobject_void,                     0)\n\tSPL_ME(MultipleIterator,  valid,                  arginfo_splobject_void,                     0)\n\tSPL_ME(MultipleIterator,  key,                    arginfo_splobject_void,                     0)\n\tSPL_ME(MultipleIterator,  current,                arginfo_splobject_void,                     0)\n\tSPL_ME(MultipleIterator,  next,                   arginfo_splobject_void,                     0)\n\t{NULL, NULL, NULL}\n};\n\n/* {{{ PHP_MINIT_FUNCTION(spl_observer) */\nPHP_MINIT_FUNCTION(spl_observer)\n{\n\tREGISTER_SPL_INTERFACE(SplObserver);\n\tREGISTER_SPL_INTERFACE(SplSubject);\n\n\tREGISTER_SPL_STD_CLASS_EX(SplObjectStorage, spl_SplObjectStorage_new, spl_funcs_SplObjectStorage);\n\tmemcpy(&spl_handler_SplObjectStorage, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\n\tspl_handler_SplObjectStorage.offset          = XtOffsetOf(spl_SplObjectStorage, std);\n\tspl_handler_SplObjectStorage.get_debug_info  = spl_object_storage_debug_info;\n\tspl_handler_SplObjectStorage.compare_objects = spl_object_storage_compare_objects;\n\tspl_handler_SplObjectStorage.clone_obj       = spl_object_storage_clone;\n\tspl_handler_SplObjectStorage.get_gc          = spl_object_storage_get_gc;\n\tspl_handler_SplObjectStorage.dtor_obj        = zend_objects_destroy_object;\n\tspl_handler_SplObjectStorage.free_obj        = spl_SplObjectStorage_free_storage;\n\n\tREGISTER_SPL_IMPLEMENTS(SplObjectStorage, Countable);\n\tREGISTER_SPL_IMPLEMENTS(SplObjectStorage, Iterator);\n\tREGISTER_SPL_IMPLEMENTS(SplObjectStorage, Serializable);\n\tREGISTER_SPL_IMPLEMENTS(SplObjectStorage, ArrayAccess);\n\n\tREGISTER_SPL_STD_CLASS_EX(MultipleIterator, spl_SplObjectStorage_new, spl_funcs_MultipleIterator);\n\tREGISTER_SPL_ITERATOR(MultipleIterator);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(MultipleIterator, \"MIT_NEED_ANY\",     MIT_NEED_ANY);\n\tREGISTER_SPL_CLASS_CONST_LONG(MultipleIterator, \"MIT_NEED_ALL\",     MIT_NEED_ALL);\n\tREGISTER_SPL_CLASS_CONST_LONG(MultipleIterator, \"MIT_KEYS_NUMERIC\", MIT_KEYS_NUMERIC);\n\tREGISTER_SPL_CLASS_CONST_LONG(MultipleIterator, \"MIT_KEYS_ASSOC\",   MIT_KEYS_ASSOC);\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: fdm=marker\n * vim: noet sw=4 ts=4\n */\n"], "fixing_code": ["/*\n   +----------------------------------------------------------------------+\n   | PHP Version 7                                                        |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 1997-2016 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Authors: Marcus Boerger <helly@php.net>                              |\n   |          Etienne Kneuss <colder@php.net>                             |\n   +----------------------------------------------------------------------+\n */\n\n/* $Id$ */\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include \"php.h\"\n#include \"php_ini.h\"\n#include \"ext/standard/info.h\"\n#include \"ext/standard/php_array.h\"\n#include \"ext/standard/php_var.h\"\n#include \"zend_smart_str.h\"\n#include \"zend_interfaces.h\"\n#include \"zend_exceptions.h\"\n\n#include \"php_spl.h\"\n#include \"spl_functions.h\"\n#include \"spl_engine.h\"\n#include \"spl_observer.h\"\n#include \"spl_iterators.h\"\n#include \"spl_array.h\"\n#include \"spl_exceptions.h\"\n\nSPL_METHOD(SplObserver, update);\nSPL_METHOD(SplSubject, attach);\nSPL_METHOD(SplSubject, detach);\nSPL_METHOD(SplSubject, notify);\n\nZEND_BEGIN_ARG_INFO(arginfo_SplObserver_update, 0)\n\tZEND_ARG_OBJ_INFO(0, SplSubject, SplSubject, 0)\nZEND_END_ARG_INFO();\n\nstatic const zend_function_entry spl_funcs_SplObserver[] = {\n\tSPL_ABSTRACT_ME(SplObserver, update,   arginfo_SplObserver_update)\n\t{NULL, NULL, NULL}\n};\n\nZEND_BEGIN_ARG_INFO(arginfo_SplSubject_attach, 0)\n\tZEND_ARG_OBJ_INFO(0, SplObserver, SplObserver, 0)\nZEND_END_ARG_INFO();\n\nZEND_BEGIN_ARG_INFO(arginfo_SplSubject_void, 0)\nZEND_END_ARG_INFO();\n\n/*ZEND_BEGIN_ARG_INFO_EX(arginfo_SplSubject_notify, 0, 0, 1)\n\tZEND_ARG_OBJ_INFO(0, ignore, SplObserver, 1)\nZEND_END_ARG_INFO();*/\n\nstatic const zend_function_entry spl_funcs_SplSubject[] = {\n\tSPL_ABSTRACT_ME(SplSubject,  attach,   arginfo_SplSubject_attach)\n\tSPL_ABSTRACT_ME(SplSubject,  detach,   arginfo_SplSubject_attach)\n\tSPL_ABSTRACT_ME(SplSubject,  notify,   arginfo_SplSubject_void)\n\t{NULL, NULL, NULL}\n};\n\nPHPAPI zend_class_entry     *spl_ce_SplObserver;\nPHPAPI zend_class_entry     *spl_ce_SplSubject;\nPHPAPI zend_class_entry     *spl_ce_SplObjectStorage;\nPHPAPI zend_class_entry     *spl_ce_MultipleIterator;\n\nPHPAPI zend_object_handlers spl_handler_SplObjectStorage;\n\ntypedef struct _spl_SplObjectStorage { /* {{{ */\n\tHashTable         storage;\n\tzend_long         index;\n\tHashPosition      pos;\n\tzend_long         flags;\n\tzend_function    *fptr_get_hash;\n\tzval             *gcdata;\n\tsize_t            gcdata_num;\n\tzend_object       std;\n} spl_SplObjectStorage; /* }}} */\n\n/* {{{ storage is an assoc aray of [zend_object*]=>[zval *obj, zval *inf] */\ntypedef struct _spl_SplObjectStorageElement {\n\tzval obj;\n\tzval inf;\n} spl_SplObjectStorageElement; /* }}} */\n\nstatic inline spl_SplObjectStorage *spl_object_storage_from_obj(zend_object *obj) /* {{{ */ {\n\treturn (spl_SplObjectStorage*)((char*)(obj) - XtOffsetOf(spl_SplObjectStorage, std));\n}\n/* }}} */\n\n#define Z_SPLOBJSTORAGE_P(zv)  spl_object_storage_from_obj(Z_OBJ_P((zv)))\n\nvoid spl_SplObjectStorage_free_storage(zend_object *object) /* {{{ */\n{\n\tspl_SplObjectStorage *intern = spl_object_storage_from_obj(object);\n\n\tzend_object_std_dtor(&intern->std);\n\n\tzend_hash_destroy(&intern->storage);\n\n\tif (intern->gcdata != NULL) {\n\t\tefree(intern->gcdata);\n\t}\n\n} /* }}} */\n\nstatic zend_string *spl_object_storage_get_hash(spl_SplObjectStorage *intern, zval *this, zval *obj) {\n\tif (intern->fptr_get_hash) {\n\t\tzval rv;\n\t\tzend_call_method_with_1_params(this, intern->std.ce, &intern->fptr_get_hash, \"getHash\", &rv, obj);\n\t\tif (!Z_ISUNDEF(rv)) {\n\t\t\tif (Z_TYPE(rv) == IS_STRING) {\n\t\t\t\treturn Z_STR(rv);\n\t\t\t} else {\n\t\t\t\tzend_throw_exception(spl_ce_RuntimeException, \"Hash needs to be a string\", 0);\n\n\t\t\t\tzval_ptr_dtor(&rv);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tzend_string *hash = zend_string_alloc(sizeof(zend_object*), 0);\n\t\tmemcpy(ZSTR_VAL(hash), (void*)&Z_OBJ_P(obj), sizeof(zend_object*));\n\t\tZSTR_VAL(hash)[ZSTR_LEN(hash)] = '\\0';\n\t\treturn hash;\n\t}\n}\n\nstatic void spl_object_storage_free_hash(spl_SplObjectStorage *intern, zend_string *hash) {\n\tzend_string_release(hash);\n}\n\nstatic void spl_object_storage_dtor(zval *element) /* {{{ */\n{\n\tspl_SplObjectStorageElement *el = Z_PTR_P(element);\n\tzval_ptr_dtor(&el->obj);\n\tzval_ptr_dtor(&el->inf);\n\tefree(el);\n} /* }}} */\n\nspl_SplObjectStorageElement* spl_object_storage_get(spl_SplObjectStorage *intern, zend_string *hash) /* {{{ */\n{\n\treturn (spl_SplObjectStorageElement*)zend_hash_find_ptr(&intern->storage, hash);\n} /* }}} */\n\nspl_SplObjectStorageElement *spl_object_storage_attach(spl_SplObjectStorage *intern, zval *this, zval *obj, zval *inf) /* {{{ */\n{\n\tspl_SplObjectStorageElement *pelement, element;\n\tzend_string *hash = spl_object_storage_get_hash(intern, this, obj);\n\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\n\tpelement = spl_object_storage_get(intern, hash);\n\n\tif (pelement) {\n\t\tzval_ptr_dtor(&pelement->inf);\n\t\tif (inf) {\n\t\t\tZVAL_COPY(&pelement->inf, inf);\n\t\t} else {\n\t\t\tZVAL_NULL(&pelement->inf);\n\t\t}\n\t\tspl_object_storage_free_hash(intern, hash);\n\t\treturn pelement;\n\t}\n\n\tZVAL_COPY(&element.obj, obj);\n\tif (inf) {\n\t\tZVAL_COPY(&element.inf, inf);\n\t} else {\n\t\tZVAL_NULL(&element.inf);\n\t}\n\tpelement = zend_hash_update_mem(&intern->storage, hash, &element, sizeof(spl_SplObjectStorageElement));\n\tspl_object_storage_free_hash(intern, hash);\n\treturn pelement;\n} /* }}} */\n\nint spl_object_storage_detach(spl_SplObjectStorage *intern, zval *this, zval *obj) /* {{{ */\n{\n\tint ret = FAILURE;\n\tzend_string *hash = spl_object_storage_get_hash(intern, this, obj);\n\tif (!hash) {\n\t\treturn ret;\n\t}\n\tret = zend_hash_del(&intern->storage, hash);\n\tspl_object_storage_free_hash(intern, hash);\n\n\treturn ret;\n} /* }}}*/\n\nvoid spl_object_storage_addall(spl_SplObjectStorage *intern, zval *this, spl_SplObjectStorage *other) { /* {{{ */\n\tspl_SplObjectStorageElement *element;\n\n\tZEND_HASH_FOREACH_PTR(&other->storage, element) {\n\t\tspl_object_storage_attach(intern, this, &element->obj, &element->inf);\n\t} ZEND_HASH_FOREACH_END();\n\n\tintern->index = 0;\n} /* }}} */\n\nstatic zend_object *spl_object_storage_new_ex(zend_class_entry *class_type, zval *orig) /* {{{ */\n{\n\tspl_SplObjectStorage *intern;\n\tzend_class_entry *parent = class_type;\n\n\tintern = emalloc(sizeof(spl_SplObjectStorage) + zend_object_properties_size(parent));\n\tmemset(intern, 0, sizeof(spl_SplObjectStorage) - sizeof(zval));\n\tintern->pos = HT_INVALID_IDX;\n\n\tzend_object_std_init(&intern->std, class_type);\n\tobject_properties_init(&intern->std, class_type);\n\n\tzend_hash_init(&intern->storage, 0, NULL, spl_object_storage_dtor, 0);\n\n\tintern->std.handlers = &spl_handler_SplObjectStorage;\n\n\twhile (parent) {\n\t\tif (parent == spl_ce_SplObjectStorage) {\n\t\t\tif (class_type != spl_ce_SplObjectStorage) {\n\t\t\t\tintern->fptr_get_hash = zend_hash_str_find_ptr(&class_type->function_table, \"gethash\", sizeof(\"gethash\") - 1);\n\t\t\t\tif (intern->fptr_get_hash->common.scope == spl_ce_SplObjectStorage) {\n\t\t\t\t\tintern->fptr_get_hash = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tparent = parent->parent;\n\t}\n\n\tif (orig) {\n\t\tspl_SplObjectStorage *other = Z_SPLOBJSTORAGE_P(orig);\n\t\tspl_object_storage_addall(intern, orig, other);\n\t}\n\n\treturn &intern->std;\n}\n/* }}} */\n\n/* {{{ spl_object_storage_clone */\nstatic zend_object *spl_object_storage_clone(zval *zobject)\n{\n\tzend_object *old_object;\n\tzend_object *new_object;\n\n\told_object = Z_OBJ_P(zobject);\n\tnew_object = spl_object_storage_new_ex(old_object->ce, zobject);\n\n\tzend_objects_clone_members(new_object, old_object);\n\n\treturn new_object;\n}\n/* }}} */\n\nstatic HashTable* spl_object_storage_debug_info(zval *obj, int *is_temp) /* {{{ */\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(obj);\n\tspl_SplObjectStorageElement *element;\n\tHashTable *props;\n\tzval tmp, storage;\n\tzend_string *md5str;\n\tzend_string *zname;\n\tHashTable *debug_info;\n\n\t*is_temp = 1;\n\n\tprops = Z_OBJPROP_P(obj);\n\n\tALLOC_HASHTABLE(debug_info);\n\tZEND_INIT_SYMTABLE_EX(debug_info, zend_hash_num_elements(props) + 1, 0);\n\tzend_hash_copy(debug_info, props, (copy_ctor_func_t)zval_add_ref);\n\n\tarray_init(&storage);\n\n\tZEND_HASH_FOREACH_PTR(&intern->storage, element) {\n\t\tmd5str = php_spl_object_hash(&element->obj);\n\t\tarray_init(&tmp);\n\t\t/* Incrementing the refcount of obj and inf would confuse the garbage collector.\n\t\t * Prefer to null the destructor */\n\t\tZ_ARRVAL_P(&tmp)->pDestructor = NULL;\n\t\tadd_assoc_zval_ex(&tmp, \"obj\", sizeof(\"obj\") - 1, &element->obj);\n\t\tadd_assoc_zval_ex(&tmp, \"inf\", sizeof(\"inf\") - 1, &element->inf);\n\t\tzend_hash_update(Z_ARRVAL(storage), md5str, &tmp);\n\t\tzend_string_release(md5str);\n\t} ZEND_HASH_FOREACH_END();\n\n\tzname = spl_gen_private_prop_name(spl_ce_SplObjectStorage, \"storage\", sizeof(\"storage\")-1);\n\tzend_symtable_update(debug_info, zname, &storage);\n\tzend_string_release(zname);\n\n\treturn debug_info;\n}\n/* }}} */\n\n/* overriden for garbage collection */\nstatic HashTable *spl_object_storage_get_gc(zval *obj, zval **table, int *n) /* {{{ */\n{\n\tint i = 0;\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(obj);\n\tspl_SplObjectStorageElement *element;\n\n\tif (intern->storage.nNumOfElements * 2 > intern->gcdata_num) {\n\t\tintern->gcdata_num = intern->storage.nNumOfElements * 2;\n\t\tintern->gcdata = (zval*)erealloc(intern->gcdata, sizeof(zval) * intern->gcdata_num);\n\t}\n\n\tZEND_HASH_FOREACH_PTR(&intern->storage, element) {\n\t\tZVAL_COPY_VALUE(&intern->gcdata[i++], &element->obj);\n\t\tZVAL_COPY_VALUE(&intern->gcdata[i++], &element->inf);\n\t} ZEND_HASH_FOREACH_END();\n\n\t*table = intern->gcdata;\n\t*n = i;\n\n\treturn std_object_handlers.get_properties(obj);\n}\n/* }}} */\n\nstatic int spl_object_storage_compare_info(zval *e1, zval *e2) /* {{{ */\n{\n\tspl_SplObjectStorageElement *s1 = (spl_SplObjectStorageElement*)Z_PTR_P(e1);\n\tspl_SplObjectStorageElement *s2 = (spl_SplObjectStorageElement*)Z_PTR_P(e2);\n\tzval result;\n\n\tif (compare_function(&result, &s1->inf, &s2->inf) == FAILURE) {\n\t\treturn 1;\n\t}\n\n\treturn Z_LVAL(result) > 0 ? 1 : (Z_LVAL(result) < 0 ? -1 : 0);\n}\n/* }}} */\n\nstatic int spl_object_storage_compare_objects(zval *o1, zval *o2) /* {{{ */\n{\n\tzend_object *zo1 = (zend_object *)Z_OBJ_P(o1);\n\tzend_object *zo2 = (zend_object *)Z_OBJ_P(o2);\n\n\tif (zo1->ce != spl_ce_SplObjectStorage || zo2->ce != spl_ce_SplObjectStorage) {\n\t\treturn 1;\n\t}\n\n\treturn zend_hash_compare(&(Z_SPLOBJSTORAGE_P(o1))->storage, &(Z_SPLOBJSTORAGE_P(o2))->storage, (compare_func_t)spl_object_storage_compare_info, 0);\n}\n/* }}} */\n\n/* {{{ spl_array_object_new */\nstatic zend_object *spl_SplObjectStorage_new(zend_class_entry *class_type)\n{\n\treturn spl_object_storage_new_ex(class_type, NULL);\n}\n/* }}} */\n\nint spl_object_storage_contains(spl_SplObjectStorage *intern, zval *this, zval *obj) /* {{{ */\n{\n\tint found;\n\tzend_string *hash = spl_object_storage_get_hash(intern, this, obj);\n\tif (!hash) {\n\t\treturn 0;\n\t}\n\n\tfound = zend_hash_exists(&intern->storage, hash);\n\tspl_object_storage_free_hash(intern, hash);\n\treturn found;\n} /* }}} */\n\n/* {{{ proto void SplObjectStorage::attach(object obj, mixed inf = NULL)\n Attaches an object to the storage if not yet contained */\nSPL_METHOD(SplObjectStorage, attach)\n{\n\tzval *obj, *inf = NULL;\n\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"o|z!\", &obj, &inf) == FAILURE) {\n\t\treturn;\n\t}\n\tspl_object_storage_attach(intern, getThis(), obj, inf);\n} /* }}} */\n\n/* {{{ proto void SplObjectStorage::detach(object obj)\n Detaches an object from the storage */\nSPL_METHOD(SplObjectStorage, detach)\n{\n\tzval *obj;\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"o\", &obj) == FAILURE) {\n\t\treturn;\n\t}\n\tspl_object_storage_detach(intern, getThis(), obj);\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\tintern->index = 0;\n} /* }}} */\n\n/* {{{ proto string SplObjectStorage::getHash(object obj)\n Returns the hash of an object */\nSPL_METHOD(SplObjectStorage, getHash)\n{\n\tzval *obj;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"o\", &obj) == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_NEW_STR(php_spl_object_hash(obj));\n\n} /* }}} */\n\n/* {{{ proto mixed SplObjectStorage::offsetGet(object obj)\n Returns associated information for a stored object */\nSPL_METHOD(SplObjectStorage, offsetGet)\n{\n\tzval *obj;\n\tspl_SplObjectStorageElement *element;\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\tzend_string *hash;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"o\", &obj) == FAILURE) {\n\t\treturn;\n\t}\n\n\thash = spl_object_storage_get_hash(intern, getThis(), obj);\n\tif (!hash) {\n\t\treturn;\n\t}\n\n\telement = spl_object_storage_get(intern, hash);\n\tspl_object_storage_free_hash(intern, hash);\n\n\tif (!element) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0, \"Object not found\");\n\t} else {\n\t\tzval *value = &element->inf;\n\n\t\tZVAL_DEREF(value);\n\t\tZVAL_COPY(return_value, value);\n\t}\n} /* }}} */\n\n/* {{{ proto bool SplObjectStorage::addAll(SplObjectStorage $os)\n Add all elements contained in $os */\nSPL_METHOD(SplObjectStorage, addAll)\n{\n\tzval *obj;\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\tspl_SplObjectStorage *other;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"O\", &obj, spl_ce_SplObjectStorage) == FAILURE) {\n\t\treturn;\n\t}\n\n\tother = Z_SPLOBJSTORAGE_P(obj);\n\n\tspl_object_storage_addall(intern, getThis(), other);\n\n\tRETURN_LONG(zend_hash_num_elements(&intern->storage));\n} /* }}} */\n\n/* {{{ proto bool SplObjectStorage::removeAll(SplObjectStorage $os)\n Remove all elements contained in $os */\nSPL_METHOD(SplObjectStorage, removeAll)\n{\n\tzval *obj;\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\tspl_SplObjectStorage *other;\n\tspl_SplObjectStorageElement *element;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"O\", &obj, spl_ce_SplObjectStorage) == FAILURE) {\n\t\treturn;\n\t}\n\n\tother = Z_SPLOBJSTORAGE_P(obj);\n\n\tzend_hash_internal_pointer_reset(&other->storage);\n\twhile ((element = zend_hash_get_current_data_ptr(&other->storage)) != NULL) {\n\t\tif (spl_object_storage_detach(intern, getThis(), &element->obj) == FAILURE) {\n\t\t\tzend_hash_move_forward(&other->storage);\n\t\t}\n\t}\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\tintern->index = 0;\n\n\tRETURN_LONG(zend_hash_num_elements(&intern->storage));\n} /* }}} */\n\n/* {{{ proto bool SplObjectStorage::removeAllExcept(SplObjectStorage $os)\n Remove elements not common to both this SplObjectStorage instance and $os */\nSPL_METHOD(SplObjectStorage, removeAllExcept)\n{\n\tzval *obj;\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\tspl_SplObjectStorage *other;\n\tspl_SplObjectStorageElement *element;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"O\", &obj, spl_ce_SplObjectStorage) == FAILURE) {\n\t\treturn;\n\t}\n\n\tother = Z_SPLOBJSTORAGE_P(obj);\n\n\tZEND_HASH_FOREACH_PTR(&intern->storage, element) {\n\t\tif (!spl_object_storage_contains(other, getThis(), &element->obj)) {\n\t\t\tspl_object_storage_detach(intern, getThis(), &element->obj);\n\t\t}\n\t} ZEND_HASH_FOREACH_END();\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\tintern->index = 0;\n\n\tRETURN_LONG(zend_hash_num_elements(&intern->storage));\n}\n/* }}} */\n\n/* {{{ proto bool SplObjectStorage::contains(object obj)\n Determine whethe an object is contained in the storage */\nSPL_METHOD(SplObjectStorage, contains)\n{\n\tzval *obj;\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"o\", &obj) == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_BOOL(spl_object_storage_contains(intern, getThis(), obj));\n} /* }}} */\n\n/* {{{ proto int SplObjectStorage::count()\n Determine number of objects in storage */\nSPL_METHOD(SplObjectStorage, count)\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\tzend_long mode = COUNT_NORMAL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"|l\", &mode) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (mode == COUNT_RECURSIVE) {\n\t\tzend_long ret = zend_hash_num_elements(&intern->storage);\n\t\tzval *element;\n\n\t\tZEND_HASH_FOREACH_VAL(&intern->storage, element) {\n\t\t\tret += php_count_recursive(element, mode);\n\t\t} ZEND_HASH_FOREACH_END();\n\n\t\tRETURN_LONG(ret);\n\t\treturn;\n\t}\n\n\tRETURN_LONG(zend_hash_num_elements(&intern->storage));\n} /* }}} */\n\n/* {{{ proto void SplObjectStorage::rewind()\n Rewind to first position */\nSPL_METHOD(SplObjectStorage, rewind)\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\tintern->index = 0;\n} /* }}} */\n\n/* {{{ proto bool SplObjectStorage::valid()\n Returns whether current position is valid */\nSPL_METHOD(SplObjectStorage, valid)\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_BOOL(zend_hash_has_more_elements_ex(&intern->storage, &intern->pos) == SUCCESS);\n} /* }}} */\n\n/* {{{ proto mixed SplObjectStorage::key()\n Returns current key */\nSPL_METHOD(SplObjectStorage, key)\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG(intern->index);\n} /* }}} */\n\n/* {{{ proto mixed SplObjectStorage::current()\n Returns current element */\nSPL_METHOD(SplObjectStorage, current)\n{\n\tspl_SplObjectStorageElement *element;\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((element = zend_hash_get_current_data_ptr_ex(&intern->storage, &intern->pos)) == NULL) {\n\t\treturn;\n\t}\n\tZVAL_COPY(return_value, &element->obj);\n} /* }}} */\n\n/* {{{ proto mixed SplObjectStorage::getInfo()\n Returns associated information to current element */\nSPL_METHOD(SplObjectStorage, getInfo)\n{\n\tspl_SplObjectStorageElement *element;\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((element = zend_hash_get_current_data_ptr_ex(&intern->storage, &intern->pos)) == NULL) {\n\t\treturn;\n\t}\n\tZVAL_COPY(return_value, &element->inf);\n} /* }}} */\n\n/* {{{ proto mixed SplObjectStorage::setInfo(mixed $inf)\n Sets associated information of current element to $inf */\nSPL_METHOD(SplObjectStorage, setInfo)\n{\n\tspl_SplObjectStorageElement *element;\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\tzval *inf;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"z\", &inf) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((element = zend_hash_get_current_data_ptr_ex(&intern->storage, &intern->pos)) == NULL) {\n\t\treturn;\n\t}\n\tzval_ptr_dtor(&element->inf);\n\tZVAL_COPY(&element->inf, inf);\n} /* }}} */\n\n/* {{{ proto void SplObjectStorage::next()\n Moves position forward */\nSPL_METHOD(SplObjectStorage, next)\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tzend_hash_move_forward_ex(&intern->storage, &intern->pos);\n\tintern->index++;\n} /* }}} */\n\n/* {{{ proto string SplObjectStorage::serialize()\n Serializes storage */\nSPL_METHOD(SplObjectStorage, serialize)\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tspl_SplObjectStorageElement *element;\n\tzval members, flags;\n\tHashPosition      pos;\n\tphp_serialize_data_t var_hash;\n\tsmart_str buf = {0};\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_VAR_SERIALIZE_INIT(var_hash);\n\n\t/* storage */\n\tsmart_str_appendl(&buf, \"x:\", 2);\n\tZVAL_LONG(&flags, zend_hash_num_elements(&intern->storage));\n\tphp_var_serialize(&buf, &flags, &var_hash);\n\tzval_ptr_dtor(&flags);\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &pos);\n\n\twhile (zend_hash_has_more_elements_ex(&intern->storage, &pos) == SUCCESS) {\n\t\tif ((element = zend_hash_get_current_data_ptr_ex(&intern->storage, &pos)) == NULL) {\n\t\t\tsmart_str_free(&buf);\n\t\t\tPHP_VAR_SERIALIZE_DESTROY(var_hash);\n\t\t\tRETURN_NULL();\n\t\t}\n\t\tphp_var_serialize(&buf, &element->obj, &var_hash);\n\t\tsmart_str_appendc(&buf, ',');\n\t\tphp_var_serialize(&buf, &element->inf, &var_hash);\n\t\tsmart_str_appendc(&buf, ';');\n\t\tzend_hash_move_forward_ex(&intern->storage, &pos);\n\t}\n\n\t/* members */\n\tsmart_str_appendl(&buf, \"m:\", 2);\n\n\tZVAL_ARR(&members, zend_array_dup(zend_std_get_properties(getThis())));\n\tphp_var_serialize(&buf, &members, &var_hash); /* finishes the string */\n\tzval_ptr_dtor(&members);\n\n\t/* done */\n\tPHP_VAR_SERIALIZE_DESTROY(var_hash);\n\n\tif (buf.s) {\n\t\tRETURN_NEW_STR(buf.s);\n\t} else {\n\t\tRETURN_NULL();\n\t}\n\n} /* }}} */\n\n/* {{{ proto void SplObjectStorage::unserialize(string serialized)\n Unserializes storage */\nSPL_METHOD(SplObjectStorage, unserialize)\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tchar *buf;\n\tsize_t buf_len;\n\tconst unsigned char *p, *s;\n\tphp_unserialize_data_t var_hash;\n\tzval entry, inf;\n\tzval *pcount, *pmembers;\n\tspl_SplObjectStorageElement *element;\n\tzend_long count;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &buf, &buf_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (buf_len == 0) {\n\t\treturn;\n\t}\n\n\t/* storage */\n\ts = p = (const unsigned char*)buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\n\tif (*p!= 'x' || *++p != ':') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\tpcount = var_tmp_var(&var_hash);\n\tif (!php_var_unserialize(pcount, &p, s + buf_len, &var_hash) || Z_TYPE_P(pcount) != IS_LONG) {\n\t\tgoto outexcept;\n\t}\n\n\t--p; /* for ';' */\n\tcount = Z_LVAL_P(pcount);\n\n\tZVAL_UNDEF(&entry);\n\tZVAL_UNDEF(&inf);\n\n\twhile (count-- > 0) {\n\t\tspl_SplObjectStorageElement *pelement;\n\t\tzend_string *hash;\n\n\t\tif (*p != ';') {\n\t\t\tgoto outexcept;\n\t\t}\n\t\t++p;\n\t\tif(*p != 'O' && *p != 'C' && *p != 'r') {\n\t\t\tgoto outexcept;\n\t\t}\n\t\t/* store reference to allow cross-references between different elements */\n\t\tif (!php_var_unserialize(&entry, &p, s + buf_len, &var_hash)) {\n\t\t\tgoto outexcept;\n\t\t}\n\t\tif (*p == ',') { /* new version has inf */\n\t\t\t++p;\n\t\t\tif (!php_var_unserialize(&inf, &p, s + buf_len, &var_hash)) {\n\t\t\t\tzval_ptr_dtor(&entry);\n\t\t\t\tgoto outexcept;\n\t\t\t}\n\t\t}\n\t\tif (Z_TYPE(entry) != IS_OBJECT) {\n\t\t\tzval_ptr_dtor(&entry);\n\t\t\tzval_ptr_dtor(&inf);\n\t\t\tgoto outexcept;\n\t\t}\n\n\t\thash = spl_object_storage_get_hash(intern, getThis(), &entry);\n\t\tif (!hash) {\n\t\t\tzval_ptr_dtor(&entry);\n\t\t\tzval_ptr_dtor(&inf);\n\t\t\tgoto outexcept;\n\t\t}\n\t\tpelement = spl_object_storage_get(intern, hash);\n\t\tspl_object_storage_free_hash(intern, hash);\n\t\tif (pelement) {\n\t\t\tif (!Z_ISUNDEF(pelement->inf)) {\n\t\t\t\tvar_push_dtor(&var_hash, &pelement->inf);\n\t\t\t}\n\t\t\tif (!Z_ISUNDEF(pelement->obj)) {\n\t\t\t\tvar_push_dtor(&var_hash, &pelement->obj);\n\t\t\t}\n\t\t}\n\t\telement = spl_object_storage_attach(intern, getThis(), &entry, Z_ISUNDEF(inf)?NULL:&inf);\n\t\tvar_replace(&var_hash, &entry, &element->obj);\n\t\tvar_replace(&var_hash, &inf, &element->inf);\n\t\tzval_ptr_dtor(&entry);\n\t\tZVAL_UNDEF(&entry);\n\t\tzval_ptr_dtor(&inf);\n\t\tZVAL_UNDEF(&inf);\n\t}\n\n\tif (*p != ';') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\t/* members */\n\tif (*p!= 'm' || *++p != ':') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\tpmembers = var_tmp_var(&var_hash);\n\tif (!php_var_unserialize(pmembers, &p, s + buf_len, &var_hash) || Z_TYPE_P(pmembers) != IS_ARRAY) {\n\t\tgoto outexcept;\n\t}\n\n\t/* copy members */\n\tobject_properties_load(&intern->std, Z_ARRVAL_P(pmembers));\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\treturn;\n\noutexcept:\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0, \"Error at offset %pd of %d bytes\", (zend_long)((char*)p - buf), buf_len);\n\treturn;\n\n} /* }}} */\n\nZEND_BEGIN_ARG_INFO(arginfo_Object, 0)\n\tZEND_ARG_INFO(0, object)\nZEND_END_ARG_INFO();\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_attach, 0, 0, 1)\n\tZEND_ARG_INFO(0, object)\n\tZEND_ARG_INFO(0, inf)\nZEND_END_ARG_INFO();\n\nZEND_BEGIN_ARG_INFO(arginfo_Serialized, 0)\n\tZEND_ARG_INFO(0, serialized)\nZEND_END_ARG_INFO();\n\nZEND_BEGIN_ARG_INFO(arginfo_setInfo, 0)\n\tZEND_ARG_INFO(0, info)\nZEND_END_ARG_INFO();\n\nZEND_BEGIN_ARG_INFO(arginfo_getHash, 0)\n\tZEND_ARG_INFO(0, object)\nZEND_END_ARG_INFO();\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_offsetGet, 0, 0, 1)\n\tZEND_ARG_INFO(0, object)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO(arginfo_splobject_void, 0)\nZEND_END_ARG_INFO()\n\nstatic const zend_function_entry spl_funcs_SplObjectStorage[] = {\n\tSPL_ME(SplObjectStorage,  attach,      arginfo_attach,        0)\n\tSPL_ME(SplObjectStorage,  detach,      arginfo_Object,        0)\n\tSPL_ME(SplObjectStorage,  contains,    arginfo_Object,        0)\n\tSPL_ME(SplObjectStorage,  addAll,      arginfo_Object,        0)\n\tSPL_ME(SplObjectStorage,  removeAll,   arginfo_Object,        0)\n\tSPL_ME(SplObjectStorage,  removeAllExcept,   arginfo_Object,  0)\n\tSPL_ME(SplObjectStorage,  getInfo,     arginfo_splobject_void,0)\n\tSPL_ME(SplObjectStorage,  setInfo,     arginfo_setInfo,       0)\n\tSPL_ME(SplObjectStorage,  getHash,     arginfo_getHash,       0)\n\t/* Countable */\n\tSPL_ME(SplObjectStorage,  count,       arginfo_splobject_void,0)\n\t/* Iterator */\n\tSPL_ME(SplObjectStorage,  rewind,      arginfo_splobject_void,0)\n\tSPL_ME(SplObjectStorage,  valid,       arginfo_splobject_void,0)\n\tSPL_ME(SplObjectStorage,  key,         arginfo_splobject_void,0)\n\tSPL_ME(SplObjectStorage,  current,     arginfo_splobject_void,0)\n\tSPL_ME(SplObjectStorage,  next,        arginfo_splobject_void,0)\n\t/* Serializable */\n\tSPL_ME(SplObjectStorage,  unserialize, arginfo_Serialized,    0)\n\tSPL_ME(SplObjectStorage,  serialize,   arginfo_splobject_void,0)\n\t/* ArrayAccess */\n\tSPL_MA(SplObjectStorage, offsetExists, SplObjectStorage, contains, arginfo_offsetGet, 0)\n\tSPL_MA(SplObjectStorage, offsetSet,    SplObjectStorage, attach,   arginfo_attach, 0)\n\tSPL_MA(SplObjectStorage, offsetUnset,  SplObjectStorage, detach,   arginfo_offsetGet, 0)\n\tSPL_ME(SplObjectStorage, offsetGet,    arginfo_offsetGet,     0)\n\t{NULL, NULL, NULL}\n};\n\ntypedef enum {\n\tMIT_NEED_ANY     = 0,\n\tMIT_NEED_ALL     = 1,\n\tMIT_KEYS_NUMERIC = 0,\n\tMIT_KEYS_ASSOC   = 2\n} MultipleIteratorFlags;\n\n#define SPL_MULTIPLE_ITERATOR_GET_ALL_CURRENT   1\n#define SPL_MULTIPLE_ITERATOR_GET_ALL_KEY       2\n\n/* {{{ proto void MultipleIterator::__construct([int flags = MIT_NEED_ALL|MIT_KEYS_NUMERIC])\n   Iterator that iterates over several iterators one after the other */\nSPL_METHOD(MultipleIterator, __construct)\n{\n\tspl_SplObjectStorage   *intern;\n\tzend_long               flags = MIT_NEED_ALL|MIT_KEYS_NUMERIC;\n\n\tif (zend_parse_parameters_throw(ZEND_NUM_ARGS(), \"|l\", &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern = Z_SPLOBJSTORAGE_P(getThis());\n\tintern->flags = flags;\n}\n/* }}} */\n\n/* {{{ proto int MultipleIterator::getFlags()\n   Return current flags */\nSPL_METHOD(MultipleIterator, getFlags)\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_LONG(intern->flags);\n}\n/* }}} */\n\n/* {{{ proto int MultipleIterator::setFlags(int flags)\n   Set flags */\nSPL_METHOD(MultipleIterator, setFlags)\n{\n\tspl_SplObjectStorage *intern;\n\tintern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l\", &intern->flags) == FAILURE) {\n\t\treturn;\n\t}\n}\n/* }}} */\n\n/* {{{ proto void attachIterator(Iterator iterator[, mixed info]) throws InvalidArgumentException\n   Attach a new iterator */\nSPL_METHOD(MultipleIterator, attachIterator)\n{\n\tspl_SplObjectStorage        *intern;\n\tzval                        *iterator = NULL, *info = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"O|z!\", &iterator, zend_ce_iterator, &info) == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (info != NULL) {\n\t\tspl_SplObjectStorageElement *element;\n\n\t\tif (Z_TYPE_P(info) != IS_LONG && Z_TYPE_P(info) != IS_STRING) {\n\t\t\tzend_throw_exception(spl_ce_InvalidArgumentException, \"Info must be NULL, integer or string\", 0);\n\t\t\treturn;\n\t\t}\n\n\t\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\t\twhile ((element = zend_hash_get_current_data_ptr_ex(&intern->storage, &intern->pos)) != NULL) {\n\t\t\tif (fast_is_identical_function(info, &element->inf)) {\n\t\t\t\tzend_throw_exception(spl_ce_InvalidArgumentException, \"Key duplication error\", 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tzend_hash_move_forward_ex(&intern->storage, &intern->pos);\n\t\t}\n\t}\n\n\tspl_object_storage_attach(intern, getThis(), iterator, info);\n}\n/* }}} */\n\n/* {{{ proto void MultipleIterator::rewind()\n   Rewind all attached iterator instances */\nSPL_METHOD(MultipleIterator, rewind)\n{\n\tspl_SplObjectStorage        *intern;\n\tspl_SplObjectStorageElement *element;\n\tzval                        *it;\n\n\tintern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\twhile ((element = zend_hash_get_current_data_ptr_ex(&intern->storage, &intern->pos)) != NULL && !EG(exception)) {\n\t\tit = &element->obj;\n\t\tzend_call_method_with_0_params(it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_rewind, \"rewind\", NULL);\n\t\tzend_hash_move_forward_ex(&intern->storage, &intern->pos);\n\t}\n}\n/* }}} */\n\n/* {{{ proto void MultipleIterator::next()\n   Move all attached iterator instances forward */\nSPL_METHOD(MultipleIterator, next)\n{\n\tspl_SplObjectStorage        *intern;\n\tspl_SplObjectStorageElement *element;\n\tzval                        *it;\n\n\tintern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\twhile ((element = zend_hash_get_current_data_ptr_ex(&intern->storage, &intern->pos)) != NULL && !EG(exception)) {\n\t\tit = &element->obj;\n\t\tzend_call_method_with_0_params(it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_next, \"next\", NULL);\n\t\tzend_hash_move_forward_ex(&intern->storage, &intern->pos);\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool MultipleIterator::valid()\n   Return whether all or one sub iterator is valid depending on flags */\nSPL_METHOD(MultipleIterator, valid)\n{\n\tspl_SplObjectStorage        *intern;\n\tspl_SplObjectStorageElement *element;\n\tzval                        *it, retval;\n\tzend_long                         expect, valid;\n\n\tintern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!zend_hash_num_elements(&intern->storage)) {\n\t\tRETURN_FALSE;\n\t}\n\n\texpect = (intern->flags & MIT_NEED_ALL) ? 1 : 0;\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\twhile ((element = zend_hash_get_current_data_ptr_ex(&intern->storage, &intern->pos)) != NULL && !EG(exception)) {\n\t\tit = &element->obj;\n\t\tzend_call_method_with_0_params(it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_valid, \"valid\", &retval);\n\n\t\tif (!Z_ISUNDEF(retval)) {\n\t\t\tvalid = (Z_TYPE(retval) == IS_TRUE);\n\t\t\tzval_ptr_dtor(&retval);\n\t\t} else {\n\t\t\tvalid = 0;\n\t\t}\n\n\t\tif (expect != valid) {\n\t\t\tRETURN_BOOL(!expect);\n\t\t}\n\n\t\tzend_hash_move_forward_ex(&intern->storage, &intern->pos);\n\t}\n\n\tRETURN_BOOL(expect);\n}\n/* }}} */\n\nstatic void spl_multiple_iterator_get_all(spl_SplObjectStorage *intern, int get_type, zval *return_value) /* {{{ */\n{\n\tspl_SplObjectStorageElement *element;\n\tzval                        *it, retval;\n\tint                          valid = 1, num_elements;\n\n\tnum_elements = zend_hash_num_elements(&intern->storage);\n\tif (num_elements < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init_size(return_value, num_elements);\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\twhile ((element = zend_hash_get_current_data_ptr_ex(&intern->storage, &intern->pos)) != NULL && !EG(exception)) {\n\t\tit = &element->obj;\n\t\tzend_call_method_with_0_params(it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_valid, \"valid\", &retval);\n\n\t\tif (!Z_ISUNDEF(retval)) {\n\t\t\tvalid = Z_TYPE(retval) == IS_TRUE;\n\t\t\tzval_ptr_dtor(&retval);\n\t\t} else {\n\t\t\tvalid = 0;\n\t\t}\n\n\t\tif (valid) {\n\t\t\tif (SPL_MULTIPLE_ITERATOR_GET_ALL_CURRENT == get_type) {\n\t\t\t\tzend_call_method_with_0_params(it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_current, \"current\", &retval);\n\t\t\t} else {\n\t\t\t\tzend_call_method_with_0_params(it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_key, \"key\", &retval);\n\t\t\t}\n\t\t\tif (Z_ISUNDEF(retval)) {\n\t\t\t\tzend_throw_exception(spl_ce_RuntimeException, \"Failed to call sub iterator method\", 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (intern->flags & MIT_NEED_ALL) {\n\t\t\tif (SPL_MULTIPLE_ITERATOR_GET_ALL_CURRENT == get_type) {\n\t\t\t\tzend_throw_exception(spl_ce_RuntimeException, \"Called current() with non valid sub iterator\", 0);\n\t\t\t} else {\n\t\t\t\tzend_throw_exception(spl_ce_RuntimeException, \"Called key() with non valid sub iterator\", 0);\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\tZVAL_NULL(&retval);\n\t\t}\n\n\t\tif (intern->flags & MIT_KEYS_ASSOC) {\n\t\t\tswitch (Z_TYPE(element->inf)) {\n\t\t\t\tcase IS_LONG:\n\t\t\t\t\tadd_index_zval(return_value, Z_LVAL(element->inf), &retval);\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_STRING:\n\t\t\t\t\tzend_symtable_update(Z_ARRVAL_P(return_value), Z_STR(element->inf), &retval);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t\t\tzend_throw_exception(spl_ce_InvalidArgumentException, \"Sub-Iterator is associated with NULL\", 0);\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tadd_next_index_zval(return_value, &retval);\n\t\t}\n\n\t\tzend_hash_move_forward_ex(&intern->storage, &intern->pos);\n\t}\n}\n/* }}} */\n\n/* {{{ proto array current() throws RuntimeException throws InvalidArgumentException\n   Return an array of all registered Iterator instances current() result */\nSPL_METHOD(MultipleIterator, current)\n{\n\tspl_SplObjectStorage        *intern;\n\tintern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_multiple_iterator_get_all(intern, SPL_MULTIPLE_ITERATOR_GET_ALL_CURRENT, return_value);\n}\n/* }}} */\n\n/* {{{ proto array MultipleIterator::key()\n   Return an array of all registered Iterator instances key() result */\nSPL_METHOD(MultipleIterator, key)\n{\n\tspl_SplObjectStorage *intern;\n\tintern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_multiple_iterator_get_all(intern, SPL_MULTIPLE_ITERATOR_GET_ALL_KEY, return_value);\n}\n/* }}} */\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_MultipleIterator_attachIterator, 0, 0, 1)\n\tZEND_ARG_OBJ_INFO(0, iterator, Iterator, 0)\n\tZEND_ARG_INFO(0, infos)\nZEND_END_ARG_INFO();\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_MultipleIterator_detachIterator, 0, 0, 1)\n\tZEND_ARG_OBJ_INFO(0, iterator, Iterator, 0)\nZEND_END_ARG_INFO();\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_MultipleIterator_containsIterator, 0, 0, 1)\n\tZEND_ARG_OBJ_INFO(0, iterator, Iterator, 0)\nZEND_END_ARG_INFO();\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_MultipleIterator_setflags, 0, 0, 1)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO();\n\nstatic const zend_function_entry spl_funcs_MultipleIterator[] = {\n\tSPL_ME(MultipleIterator,  __construct,            arginfo_MultipleIterator_setflags,          0)\n\tSPL_ME(MultipleIterator,  getFlags,               arginfo_splobject_void,                     0)\n\tSPL_ME(MultipleIterator,  setFlags,               arginfo_MultipleIterator_setflags,          0)\n\tSPL_ME(MultipleIterator,  attachIterator,         arginfo_MultipleIterator_attachIterator,    0)\n\tSPL_MA(MultipleIterator,  detachIterator,         SplObjectStorage, detach,   arginfo_MultipleIterator_detachIterator,   0)\n\tSPL_MA(MultipleIterator,  containsIterator,       SplObjectStorage, contains, arginfo_MultipleIterator_containsIterator, 0)\n\tSPL_MA(MultipleIterator,  countIterators,         SplObjectStorage, count,    arginfo_splobject_void,                    0)\n\t/* Iterator */\n\tSPL_ME(MultipleIterator,  rewind,                 arginfo_splobject_void,                     0)\n\tSPL_ME(MultipleIterator,  valid,                  arginfo_splobject_void,                     0)\n\tSPL_ME(MultipleIterator,  key,                    arginfo_splobject_void,                     0)\n\tSPL_ME(MultipleIterator,  current,                arginfo_splobject_void,                     0)\n\tSPL_ME(MultipleIterator,  next,                   arginfo_splobject_void,                     0)\n\t{NULL, NULL, NULL}\n};\n\n/* {{{ PHP_MINIT_FUNCTION(spl_observer) */\nPHP_MINIT_FUNCTION(spl_observer)\n{\n\tREGISTER_SPL_INTERFACE(SplObserver);\n\tREGISTER_SPL_INTERFACE(SplSubject);\n\n\tREGISTER_SPL_STD_CLASS_EX(SplObjectStorage, spl_SplObjectStorage_new, spl_funcs_SplObjectStorage);\n\tmemcpy(&spl_handler_SplObjectStorage, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\n\tspl_handler_SplObjectStorage.offset          = XtOffsetOf(spl_SplObjectStorage, std);\n\tspl_handler_SplObjectStorage.get_debug_info  = spl_object_storage_debug_info;\n\tspl_handler_SplObjectStorage.compare_objects = spl_object_storage_compare_objects;\n\tspl_handler_SplObjectStorage.clone_obj       = spl_object_storage_clone;\n\tspl_handler_SplObjectStorage.get_gc          = spl_object_storage_get_gc;\n\tspl_handler_SplObjectStorage.dtor_obj        = zend_objects_destroy_object;\n\tspl_handler_SplObjectStorage.free_obj        = spl_SplObjectStorage_free_storage;\n\n\tREGISTER_SPL_IMPLEMENTS(SplObjectStorage, Countable);\n\tREGISTER_SPL_IMPLEMENTS(SplObjectStorage, Iterator);\n\tREGISTER_SPL_IMPLEMENTS(SplObjectStorage, Serializable);\n\tREGISTER_SPL_IMPLEMENTS(SplObjectStorage, ArrayAccess);\n\n\tREGISTER_SPL_STD_CLASS_EX(MultipleIterator, spl_SplObjectStorage_new, spl_funcs_MultipleIterator);\n\tREGISTER_SPL_ITERATOR(MultipleIterator);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(MultipleIterator, \"MIT_NEED_ANY\",     MIT_NEED_ANY);\n\tREGISTER_SPL_CLASS_CONST_LONG(MultipleIterator, \"MIT_NEED_ALL\",     MIT_NEED_ALL);\n\tREGISTER_SPL_CLASS_CONST_LONG(MultipleIterator, \"MIT_KEYS_NUMERIC\", MIT_KEYS_NUMERIC);\n\tREGISTER_SPL_CLASS_CONST_LONG(MultipleIterator, \"MIT_KEYS_ASSOC\",   MIT_KEYS_ASSOC);\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: fdm=marker\n * vim: noet sw=4 ts=4\n */\n"], "filenames": ["ext/spl/spl_observer.c"], "buggy_code_start_loc": [774], "buggy_code_end_loc": [802], "fixing_code_start_loc": [775], "fixing_code_end_loc": [804], "type": "CWE-119", "message": "The SplObjectStorage unserialize implementation in ext/spl/spl_observer.c in PHP before 7.0.12 does not verify that a key is an object, which allows remote attackers to execute arbitrary code or cause a denial of service (uninitialized memory access) via crafted serialized data.", "other": {"cve": {"id": "CVE-2016-7480", "sourceIdentifier": "cve@checkpoint.com", "published": "2017-01-11T07:59:00.143", "lastModified": "2022-07-20T16:47:04.810", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The SplObjectStorage unserialize implementation in ext/spl/spl_observer.c in PHP before 7.0.12 does not verify that a key is an object, which allows remote attackers to execute arbitrary code or cause a denial of service (uninitialized memory access) via crafted serialized data."}, {"lang": "es", "value": "La implementaci\u00f3n no serializable SplObjectStorage en ext/spl/spl_observer.c en PHP en versiones anteriores a 7.0.12 no verifica que una clave sea un objeto, lo que permite a atacantes remotos ejecutar c\u00f3digo arbitrario o provocar una denegaci\u00f3n de servicio (acceso a memoria no inicializada) a trav\u00e9s de datos serializados manipulados."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.0.11", "matchCriteriaId": "E6EDBA25-7772-4C38-BE48-59399E935373"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:clustered_data_ontap:-:*:*:*:*:*:*:*", "matchCriteriaId": "1FE996B1-6951-4F85-AA58-B99A379D2163"}]}]}], "references": [{"url": "http://blog.checkpoint.com/2016/12/27/check-point-discovers-three-zero-day-vulnerabilities-web-programming-language-php-7", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://blog.checkpoint.com/wp-content/uploads/2016/12/PHP_Technical_Report.pdf", "source": "cve@checkpoint.com", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}, {"url": "http://php.net/ChangeLog-7.php", "source": "cve@checkpoint.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/95152", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.php.net/bug.php?id=73257", "source": "cve@checkpoint.com", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/php/php-src/commit/61cdd1255d5b9c8453be71aacbbf682796ac77d4", "source": "cve@checkpoint.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20180112-0001/", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.youtube.com/watch?v=LDcaPstAuPk", "source": "cve@checkpoint.com", "tags": ["Broken Link", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/php/php-src/commit/61cdd1255d5b9c8453be71aacbbf682796ac77d4"}}