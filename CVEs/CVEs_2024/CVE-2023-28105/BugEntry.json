{"buggy_code": ["<div align=center>\n\n![Go version](https://img.shields.io/github/go-mod/go-version/dablelv/go-huge-util)\n[![GitHub latest tag](https://img.shields.io/github/tag/dablelv/go-huge-util)](https://github.com/dablelv/go-huge-util)\n[![Go Report Card](https://goreportcard.com/badge/github.com/dablelv/go-huge-util)](https://goreportcard.com/report/github.com/dablelv/go-huge-util)\n[![Unit Test](https://github.com/dablelv/go-huge-util/workflows/go-test/badge.svg)](https://github.com/dablelv/go-huge-util/actions)\n[![Coverage Status](https://coveralls.io/repos/github/dablelv/go-huge-util/badge.svg?branch=master)](https://coveralls.io/github/dablelv/go-huge-util?branch=master)\n[![Go Reference](https://pkg.go.dev/badge/github.com/dablelv/go-huge-util.svg)](https://pkg.go.dev/github.com/dablelv/go-huge-util)\n[![License](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](https://github.com/dablelv/go-huge-util/blob/main/LICENSE)\n[![Stars](https://img.shields.io/github/stars/dablelv/go-huge-util?style=social)](https://img.shields.io/github/stars/dablelv/go-huge-util?style=social)\n\n</div>\n\n# Synopsis\nGo common used utility functions help you to create go program quickly and easily.\n\n# Encode\nSome useful functions can be used to handle conversion of different character encoding, such as gbk to utf8.\n```go\ngbkStr := []byte{0xC4, 0xE3, 0xBA, 0xC3}    // \u4f60\u597d in gbk\nutf8Str, _ := GbkToUtf8(gbkStr)             // \u4f60\u597d in utf8\ngbkStrRes, _ := Utf8ToGbk(utf8Str)          // [196 227 186 195]\n```\n# Net\nSome useful functions can be used to handle network. For example you can use `IPv4StrToU32()` transform ipv4 string to uint32 value.\n\n```go\nIsReservedIP(\"0.0.0.256\")    // -1 invalid ip\nIsReservedIP(\"39.156.69.79\") // 0 public ip\nIsReservedIP(\"127.0.0.1\")    // 1 reserved ip\n\nIPv4StrToU32(\"127.0.0.1\")      // 2130706433\nU32ToIPv4Str(2130706433)       // \"127.0.0.1\"\nGetNativeEndian()              // LittleEndian\nIsLittleEndian()               // true\n```\n# Slice\nSome useful functions can be used to handle slice.\n\n```go\nUniqueIntSlice([]int{1, 2, 2, 3})              // [1 2 3]\nUniqueUintSlice([]uint{1, 2, 2, 3})            // [1 2 3]\nUniqueStrSlice([]string{\"a\", \"b\", \"b\", \"c\"})   // [a b c]\n\nReverseIntSlice([]int{1, 2, 3})                // [3 2 1]\nReverseUintSlice([]uint{1, 2, 3})              // [3 2 1]\nReverseStrSlice([]string{\"a\", \"b\", \"c\"})       // [c b a]\n\nSumSlice([]int{1,2,3})                         // 6\nSumSlice([]uint{1,2,3})                        // 6\nSumSlice([]float32{1.1, 2.2, 3.3})             // 6.6\nSumSlice([]float64{1.1, 2.2, 3.3})             // 6.6\n\nJoinSliceWithSep([]int{1, 2, 3}, \",\")              // 1,2,3\nJoinSliceWithSep([]uint{1, 2, 3}, \",\")             // 1,2,3\nJoinSliceWithSep([]float64{1.1, 2.2, 3.3}, \",\")    // 1.1,2.2,3.3\nJoinSliceWithSep([]string{\"a\", \"b\", \"c\"}, \",\")     // a,b,c\n\n// CRUD(Create Read Update Delete) on slice by index\nfib := []int{1, 1, 2, 3, 5, 8}\nr, _ := InsertSliceE(fib, 6, 13)    // [1 1 2 3 5 8 13]\nr, _ := DeleteSliceE(fib, 0)        // [1 2 3 5 8]\nr, _ := UpdateSliceE(fib, 5, 88)    // [1 1 2 3 5 88]\nr, _ := GetEleIndexesSliceE(fib, 1) // [0 1]\n\n// or\nr := InsertIntSlice(fib, 5, 13)\t\t// [1 1 2 3 5 8 13]\nr := DeleteIntSliceE(fib, 0)\t\t// [1 2 3 5 8]\nr := UpdateIntSliceE(fib, 5, 88)\t// [1 1 2 3 5 88]\nr := GetElemIndexesSlice(fib, 1)\t// [0 1]\n```\n\n# SQL\nSome useful functions can be used to handle sql statement.\n\n```go\nvar sql = `select * from t where field1=\"{name}\"`\nhuge.FormatSql(sql, map[string]string{\"name\": \"dablelv\"}, false)    // select * from t where field1=\"dablelv\"\n```\n\n# String\nSome useful functions can be used to handle string.\n\n```go\nSplit(\"a,b,c\", \",\")                    // []string{\"a\", \"b\", \"c\"}\n\nSplitSeps(\"a,b|c\", \",\", \"|\")           // []string{\"a\", \"b\", \"c\"}\nSplitSeps(\"a,bSEPc\", \",\", \"SEP\")       // []string{\"a\", \"b\", \"c\"}\n\nJoinStr(\",\", \"a\", \"\", \"b\")             // \"a,,b\"\nJoinStrSkipEmpty(\",\", \"a\", \"\", \"b\")    // \"a,b\"\n\nReverseStr(\"abc\")                      // \"cba\"\n\nGetAlphanumericNumByASCII(\"108\u6761\u6881\u5c71man\")     // 6\nGetAlphanumericNumByASCIIV2(\"108\u6761\u6881\u5c71man\")   // 6\nGetAlphanumericNumByRegExp(\"108\u6761\u6881\u5c71man\")    // 6\n```\n\n# Time\nSome useful functions can be used to handle date and time.\n\n```go\ntc := huge.NewTimeCounter()\n// do your statements\ntc.GetMs()                  // get the time cost in millisecond\n\nGetNowDate()                // just a example, the same below. 2020-05-16\nGetNowTime()                // 00:15:42\nGetNowDateTime()            // 2020-05-16 00:15:42\nGetNowDateTimeZ()           // 2020-05-16 00:15:42 +08:00\n\nGetNowS()                   // 1589559342\nGetNowMs()                  // 1589559342963\nGetNowUs()                  // 1589559342963062\nGetNowNs()                  // 1589559342964063200\n\nGetDayBeginMoment(time.Now())  // 2020-05-16 00:00:00 +0800 CST\nGetDayEndMoment(time.Now())    // 2020-05-16 23:59:59.999999999 +0800 CST\n```\n\n# Type Conversion\nSome useful functions can be used to convert one type to another types, such as to map or slice.\n\n## to another type\n```go\n// to string\ns, err := ToAny[string](\"foo\") // \"foo\"\ns, err := ToAny[string](8)     // \"8\"\ns, err := ToAny[string](8.31)  // \"8.31\"\ns, err := ToAny[string]([]byte(\"one time\")) // \"one time\"\ns, err := ToAny[string](nil)                // \"\"\n\nvar foo any = \"one more time\"\ns, err := ToAny[string](foo)                // \"one more time\"\n\n// to int\ni, err :=  ToAny[int](8)                  // 8\ni, err :=  ToAny[int](8.31)               // 8\ni, err :=  ToAny[int](\"8\")                // 8\ni, err :=  ToAny[int](true)               // 1\ni, err :=  ToAny[int](false)              // 0\ni, err :=  ToAny[int](nil)                // 0\n\nvar eight any = 8\ni, err :=  ToAny[int](eight)              // 8\n\n// to bool\nb, err := ToAny[bool](\"true\")           // true\nb, err := ToAny[bool](\"false\")          // false\nb, err := ToAny[bool](\"True\")           // true\nb, err := ToAny[bool](\"False\")          // false\nb, err := ToAny[bool](1)                // true\nb, err := ToAny[bool](0)                // false\nb, err := ToAny[bool](nil)              // false\n\nvar one any = 1\nb, err := ToAny[bool](one)           // true\n```\n## to set\n```go\n// Convert bool slice or array to set.\nbools := []bool{true, false, true}\nset := conv.ToBoolSet(bools)\nset, _ := conv.ToBoolSetE(bools)\nset := conv.ToSet[bool](bools)\nset, _ := conv.ToSetE[bool](bools)\n\n// Convert int slice or array to set.\nints := []int{1, 2, 3}\nset := conv.ToIntSet(ints)\nset, _ := conv.ToIntSetE(ints)\nset := conv.ToSetG[int](ints)\nset, _ := conv.ToSetE[int](ints)\n\n// Convert string slice or array to set.\nstrs := []string{\"foo\", \"bar\", \"baz\"}\nset := conv.ToStrSet(strs)\nset, _ := conv.ToStrSetE(strs)\nset := conv.ToSet[string](strs)\nset, _ := conv.ToSetE[string](strs)\n\n// Split string to set.\nconv.SplitStrToSet(\"a,b,c\", \",\")  // map[a:{}, b:{}, c:{}]\n```\n\n## to slice\n```go\n// Convert string separated by white space character to string slice.\nsl := conv.ToStrSlice(\"a b c\") // []string{\"a\",\"b\",\"c\"}\nsl, _ := conv.ToStrSliceE(\"a b c\") // []string{\"a\",\"b\",\"c\"}\n\n// Convert int slice or array to string slice.\nsl := conv.ToStrSlice([]int{1, 2, 3}) // []string{\"1\",\"2\",\"3\"}\nsl, _ := conv.ToStrSliceE([]int{1, 2, 3}) // []string{\"1\",\"2\",\"3\"}\n\n// Convert map to slice in random order.\nks, vs := conv.Map2Slice(map[int]int{1:1, 2:2, 3:3})\nks, vs, _ := conv.Map2SliceE(map[int]int{1:1, 2:2, 3:3})\n\nslK, _ : = ks.([]int)\nslV, _ : = vs.([]int)\n\nks, vs := conv.Map2Slice(map[string]int{\"foo\":1, \"bar\":2, \"baz\":3})\nks, vs, _ := conv.Map2SliceE(map[string]int{\"foo\":1, \"bar\":2, \"baz\":3})\n\nslK, _ : = ks.([]string)\nslV, _ : = vs.([]int)\n\n// Split string to slice.\n// int[1,2,3]\nints := conv.SplitStrToSlice[int](\"1,2,3\", \",\")\nints, _ := conv.SplitStrToSliceE[int](\"1,2,3\", \",\")\n// uint[1,2,3]      \nuints := conv.SplitStrToSlice[uint](\"1,2,3\", \",\")\nuints, _ := conv.SplitStrToSliceE[uint](\"1,2,3\", \",\")\n// float64[1.1,2.2,3.3]\nf64s := conv.SplitStrToSlice[float64](\"1.1,2.2,3.3\", \",\")\nf64s, _ := conv.SplitStrToSliceE[float64](\"1.1,2.2,3.3\", \",\")\n// bool[true,false,true,false]\nbs := conv.SplitStrToSlice[bool](\"1,0,true,false\", \",\")\nbs, _ := conv.SplitStrToSliceE[bool](\"1,0,true,false\", \",\")\n```\n\n## to map\n\n```go\nvar st = struct {\n    I int\n    S string\n}{I: 1, S: \"a\"}\n\n// to map[string]any\nStruct2Map(st)         // map[\"I\":1 \"S\":\"a\"]\n// to map[string]string\nStruct2MapString(st)   // map[\"I\":\"1\" \"S\":\"a\"]\n\n// any type tp map[string]string\nm := ToMapStrStr(`{\"foo\":\"foo\",\"bar\":\"bar\",\"baz\":\"baz\"}`)       // map[\"foo\":\"foo\" \"bar\":\"bar\" \"baz\":\"baz\"]\nm, err := ToMapStrStrE(`{\"foo\":\"foo\",\"bar\":\"bar\",\"baz\":\"baz\"}`) // map[\"foo\":\"foo\" \"bar\":\"bar\" \"baz\":\"baz\"], nil\n```\n\n# URL\n\nSome useful functions can be used to handle url.\n\n```go\nvar rawUrl=`http://www.aspxfans.com:8080/news/index.asp?boardID=520&page=1&page=2#name`\nhuge.RawUrlGetDomain(rawUrl)    // \"www.aspxfans.com\"\nhuge.RawUrlGetPort(rawUrl)      // \"8080\"\n\nhuge.RawURLGetParam(rawUrl, \"page\")         // 1 <nil>\nhuge.RawURLGetParams(rawUrl, \"page\")        // [1 2] <nil>\nhuge.RawURLGetAllParams(rawUrl)             // map[boardID:[520] page:[1 2]] <nil>\n\nhuge.RawURLAddParam(rawUrl, \"keyword\", \"dog\")   // http://www.aspxfans.com:8080/news/index.asp?boardID=520&keyword=dog&page=1&page=2#name\nhuge.RawURLDelParam(rawUrl, \"page\")             // http://www.aspxfans.com:8080/news/index.asp?boardID=520#name\nhuge.RawURLSetParam(rawUrl, \"boardID\", \"521\")   // http://www.aspxfans.com:8080/news/index.asp?boardID=521&page=1&page=2#name\n```\n\n# Crypto\nSome useful functions can be used to create Hash, HMAC and crypt data.\n\n```go\n// Hash functions.\nMD5L(\"\")   // d41d8cd98f00b204e9800998ecf8427e\nMD5U(\"\")   // D41D8CD98F00B204E9800998ECF8427E\n\nSHA1L(\"\")  // da39a3ee5e6b4b0d3255bfef95601890afd80709\nSHA1U(\"\")  // DA39A3EE5E6B4B0D3255BFEF95601890AFD80709\n\nSHA224L(\"\")    // d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f\nSHA224U(\"\")    // D14A028C2A3A2BC9476102BB288234C415A2B01F828EA62AC5B3E42F\n\nSHA256L(\"\")    // e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\nSHA256U(\"\")    // E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855\n\nSHA384L(\"\")    // 38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c0cc7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b\nSHA384U(\"\")    // 38B060A751AC96384CD9327EB1B1E36A21FDB71114BE07434C0CC7BF63F6E1DA274EDEBFE76F65FBD51AD2F14898B95B\n\nSHA512L(\"\")    // cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e\nSHA512U(\"\")    // CF83E1357EEFB8BDF1542850D66D8007D620E4050B5715DC83F4A921D36CE9CE47D0D13C5D85F2B0FF8318D2877EEC2F63B931BD47417A81A538327AF927DA3E\n\n// HMAC functions.\nHMACMD5L(\"\", \"\")   // 74e6f7298a9c2d168935f58c001bad88\nHMACMD5U(\"\", \"\")   // 74E6F7298A9C2D168935F58C001BAD88\n\nHMACSHA1L(\"\", \"\")  // fbdb1d1b18aa6c08324b7d64b71fb76370690e1d\nHMACSHA1U(\"\", \"\")  // FBDB1D1B18AA6C08324B7D64B71FB76370690E1D\n\nHMACSHA224L(\"\", \"\")    // 5ce14f72894662213e2748d2a6ba234b74263910cedde2f5a9271524\nHMACSHA224U(\"\", \"\")    // 5CE14F72894662213E2748D2A6BA234B74263910CEDDE2F5A9271524\n\nHMACSHA256L(\"\", \"\")    // b613679a0814d9ec772f95d778c35fc5ff1697c493715653c6c712144292c5ad\nHMACSHA256U(\"\", \"\")    // B613679A0814D9EC772F95D778C35FC5FF1697C493715653C6C712144292C5AD\n\nHMACSHA384L(\"\", \"\")    // 6c1f2ee938fad2e24bd91298474382ca218c75db3d83e114b3d4367776d14d3551289e75e8209cd4b792302840234adc\nHMACSHA384U(\"\", \"\")    // 6C1F2EE938FAD2E24BD91298474382CA218C75DB3D83E114B3D4367776D14D3551289E75E8209CD4B792302840234ADC\n\nHMACSHA512L(\"\", \"\")    // b936cee86c9f87aa5d3c6f2e84cb5a4239a5fe50480a6ec66b70ab5b1f4ac6730c6c515421b327ec1d69402e53dfb49ad7381eb067b338fd7b0cb22247225d47\nHMACSHA512U(\"\", \"\")    // B936CEE86C9F87AA5D3C6F2E84CB5A4239A5FE50480A6EC66B70AB5B1F4AC6730C6C515421B327EC1D69402E53DFB49AD7381EB067B338FD7B0CB22247225D47\n\n// Encryption functions.\np := []byte(\"plaintext\")\nkey16 := []byte(\"12345678abcdefgh\")\nc, _ := Base64AESCBCEncrypt(p, key16) // A67NhD3RBiNaMgG6HTm8LQ==\np, _ = Base64AESCBCDecrypt(c, key16)  // plaintext\n\nkey8 := []byte(\"12345678\")\nc, _ := Base64DESCBCEncrypt(p, key8) // UZS/y4By6ksePYMBbvZdig==\np, _ := Base64DESCBCDecrypt(c, key8) // plaintext\n\nkey24 := []byte(\"12345678abcdefgh12345678\")\nc, _ := Base64TriDESCBCEncrypt(p, key24) // dau0DzmDGQbHasZaOvxxwg==\np, _ := Base64TriDESCBCDecrypt(c, key24) // plaintext\n```\n\n# Rand\n\nSome functions to create a real non-negative random int number, specified length random string, and so on.\n\n```go\nmath.GetRandInt()               // 2040723487295132865\nmath.GetRandIntn(100)           // 49\nmath.GetRandIntRange(0, 100)    // 44\nmath.GetRandByteSlice(3)        // [241 16 101]\nmath.GetRandStr(3)              // dAt\nmath.GetRandLowerStr(3)         // lts\nmath.GetRandUpperStr(3)         // YUT\n```\n\n# JSON\n\nSome converting function to json.\n\n```go\nstudent := struct {\n    Hobby   string\n    Age     int32\n}{\n    Hobby: \"pingpopng\",\n    Age:   28,\n}\nencoding.ToIndentJSON(&student)\n/*\noutput:\n{\n    \"Hobby\": \"pingpopng\",\n    \"Age\": 28\n}\n*/\n```\n\n# Comparison\n\nSome useful functions to compare.\n\n```go\n// Compare two any type value.\ncmp.Cmp(888, 889)       // LT\ncmp.Cmp(888, 888)       // EQ\ncmp.Cmp(889, 888)       // GT\ncmp.Cmp(88.8, 88.9)     // LT\ncmp.Cmp(88.8, 88.8)     // EQ\ncmp.Cmp(88.9, 88.8)     // GT\ncmp.Cmp(\"abc\", \"b\")     // LT\ncmp.Cmp(\"abc\", \"abc\")   // EQ\ncmp.Cmp(\"b\", \"abc\")     // GT\n\n// Compare semantic version. \nb, _ := cmp.VerGTVer(\"1.0.5\", \"1.0.4\")   // true\nb, _ := cmp.VerLTVer(\"1.0.5\", \"2.0.4\")   // true\nb, _ := cmp.VerGEVer(\"2.0.4\", \"2.0.4\")   // true\nb, _ := cmp.VerLEVer(\"1.0.5\", \"1.0.5\")   // true\n```\n\n# Others\n\nSome useful functions now unclassified. Of course, it may be classified and moved to a new subdirectory in the future.\n\n```go\n// NO NOW.\n```\n\n# Star History\n\n[![Star History Chart](https://api.star-history.com/svg?repos=dablelv/go-huge-util&type=Date)](https://star-history.com/#dablelv/go-huge-util&Date)\n\n# How to Contribute\n\nWe really appreciate any code commits which make this lib powerful. Please follow the rules below to create your pull request.\n\n1. Fork the repository.\n2. Add and Commit your changes.\n3. Push to your forked repository.\n4. Create new pull request.\n\n# Summary\n\nThe above examples are just the tip of the iceberg. For more usage, please read the source code.\n\nDue to the limited personal ability, you are welcome to criticize and correct. Of course, welcome to join in the construction of this library.", "package file\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// ReadLines reads all lines of the specified file.\nfunc ReadLines(path string) ([]string, int, error) {\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tdefer file.Close()\n\n\tvar lines []string\n\tlineCount := 0\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tlines = append(lines, scanner.Text())\n\t\tlineCount++\n\t}\n\n\tif scanner.Err() == bufio.ErrTooLong {\n\t\tpanic(scanner.Err())\n\t}\n\treturn lines, lineCount, scanner.Err()\n}\n\n// ReadLinesV2 reads all lines of the specified file.\nfunc ReadLinesV2(path string) ([]string, int, error) {\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tdefer file.Close()\n\n\tvar lines []string\n\tlineCount := 0\n\treader := bufio.NewReader(file)\n\tfor {\n\t\tline, err := reader.ReadString('\\n')\n\t\tlines = append(lines, line)\n\t\tlineCount++\n\t\tif err == io.EOF {\n\t\t\treturn lines, lineCount, nil\n\t\t}\n\t\tif err != nil {\n\t\t\treturn lines, lineCount, err\n\t\t}\n\t}\n}\n\n// ListDir lists all the file or dir names in the specified directory.\n// Note that ListDir don't traverse recursively.\nfunc ListDir(dirname string) ([]string, error) {\n\tinfos, err := ioutil.ReadDir(dirname)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tnames := make([]string, len(infos))\n\tfor i, info := range infos {\n\t\tnames[i] = info.Name()\n\t}\n\treturn names, nil\n}\n\n// IsPathExist checks whether a file/dir exists.\n// Use os.Stat to get the info of the target file or dir to check whether exists.\n// If os.Stat returns nil err, the target exists.\n// If os.Stat returns a os.ErrNotExist err, the target does not exist.\n// If the error returned is another type, the target is uncertain whether exists.\nfunc IsPathExist(path string) (bool, error) {\n\t_, err := os.Stat(path)\n\tif err == nil {\n\t\treturn true, nil\n\t}\n\tif os.IsNotExist(err) {\n\t\treturn false, nil\n\t}\n\treturn false, err\n}\n\n// IsDir checks whether a path is a directory.\n// If the path is a symbolic link will follow it.\nfunc IsDir(path string) bool {\n\tif info, err := os.Stat(path); err == nil && info.IsDir() {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// IsDirE checks whether a path is a directory with error.\n// If the path is a symbolic link will follow it.\nfunc IsDirE(path string) (bool, error) {\n\tinfo, err := os.Stat(path)\n\tif err == nil && info.IsDir() {\n\t\treturn true, nil\n\t}\n\treturn false, err\n}\n\n// IsFile checks whether a path is a file.\n// If the path is a symbolic link will follow it.\nfunc IsFile(path string) bool {\n\tif info, err := os.Stat(path); err == nil && info.Mode().IsRegular() {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// IsFileE checks whether a path is a file with error.\n// If the path is a symbolic link will follow it.\nfunc IsFileE(path string) (bool, error) {\n\tinfo, err := os.Stat(path)\n\tif err == nil && info.Mode().IsRegular() {\n\t\treturn true, nil\n\t}\n\treturn false, err\n}\n\n// IsSymlink checks a file whether is a symbolic link.\n// Note that this doesn't work for the shortcut file on windows.\nfunc IsSymlink(path string) bool {\n\tif info, err := os.Lstat(path); err == nil && info.Mode()&os.ModeSymlink != 0 {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// IsSymlinkE checks a file whether is a symbolic link.\n// Note that this doesn't work for the shortcut file on windows.\nfunc IsSymlinkE(path string) (bool, error) {\n\tinfo, err := os.Lstat(path)\n\tif err == nil && info.Mode()&os.ModeSymlink != 0 {\n\t\treturn true, nil\n\t}\n\treturn false, err\n}\n\n// RemoveFile removes the named file or empty directory.\n// https://gist.github.com/novalagung/13c5c8f4d30e0c4bff27\nfunc RemoveFile(path string) error {\n\terr := os.Remove(path)\n\treturn err\n}\n\n// Create creates or truncates the target file specified by path.\n// If the parent directory does not exist, it will be created with mode os.ModePerm.is cr truncated.\n// If the file does not exist, it is created with mode 0666.\n// If successful, methods on the returned File can be used for I/O; the associated file descriptor has mode O_RDWR.\nfunc Create(filePath string) (*os.File, error) {\n\tif exist, err := IsPathExist(filePath); err != nil {\n\t\treturn nil, err\n\t} else if exist {\n\t\treturn os.Create(filePath)\n\t}\n\tif err := os.MkdirAll(filepath.Dir(filePath), os.ModePerm); err != nil {\n\t\treturn nil, err\n\t}\n\treturn os.Create(filePath)\n}\n\n// CreateFile creates a file specified by path.\nfunc CreateFile(filePath string) error {\n\tfile, err := Create(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\treturn nil\n}\n\n// FileToBytes serialize the file to bytes.\nfunc FileToBytes(path string) []byte {\n\tbyteStream, _ := ioutil.ReadFile(path)\n\treturn byteStream\n}\n\n// BytesToFile writes data to a file. If the file does not exist it will be created with permission mode 0644.\nfunc BytesToFile(filePath string, data []byte) error {\n\texist, _ := IsPathExist(filePath)\n\tif !exist {\n\t\tif err := CreateFile(filePath); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn ioutil.WriteFile(filePath, data, 0644)\n}\n\n// GetDirAllEntryPaths gets all the file or dir paths in the specified directory recursively.\n// If the incl is true result will include current dir.\n// Note that GetDirAllEntryPaths won't follow symlink if the subdir is a symbolic link.\nfunc GetDirAllEntryPaths(dirname string, incl bool) ([]string, error) {\n\t// Remove the trailing path separator if dirname has.\n\tdirname = strings.TrimSuffix(dirname, string(os.PathSeparator))\n\n\tinfos, err := ioutil.ReadDir(dirname)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpaths := make([]string, 0, len(infos))\n\t// Include current dir.\n\tif incl {\n\t\tpaths = append(paths, dirname)\n\t}\n\n\tfor _, info := range infos {\n\t\tpath := dirname + string(os.PathSeparator) + info.Name()\n\t\tif info.IsDir() {\n\t\t\ttmp, err := GetDirAllEntryPaths(path, incl)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tpaths = append(paths, tmp...)\n\t\t\tcontinue\n\t\t}\n\t\tpaths = append(paths, path)\n\t}\n\treturn paths, nil\n}\n\n// GetDirAllEntryPathsFollowSymlink gets all the file or dir paths in the specified directory recursively.\n// If the incl is true result will include current dir.\nfunc GetDirAllEntryPathsFollowSymlink(dirname string, incl bool) ([]string, error) {\n\t// Remove the trailing path separator if dirname has.\n\tdirname = strings.TrimSuffix(dirname, string(os.PathSeparator))\n\n\tinfos, err := ioutil.ReadDir(dirname)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpaths := make([]string, 0, len(infos))\n\t// Include current dir.\n\tif incl {\n\t\tpaths = append(paths, dirname)\n\t}\n\n\tfor _, info := range infos {\n\t\tpath := dirname + string(os.PathSeparator) + info.Name()\n\t\trealInfo, err := os.Stat(path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif realInfo.IsDir() {\n\t\t\ttmp, err := GetDirAllEntryPathsFollowSymlink(path, incl)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tpaths = append(paths, tmp...)\n\t\t\tcontinue\n\t\t}\n\t\tpaths = append(paths, path)\n\t}\n\treturn paths, nil\n}\n", "package zip\n\nimport (\n\t\"archive/zip\"\n\t\"io\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n)\n\n// Unzip decompresses a zip file to specified directory.\n// Note that the destination directory don't need to specify the trailing path separator.\nfunc Unzip(zipPath, dstDir string) error {\n\t// Open zip file.\n\treader, err := zip.OpenReader(zipPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer reader.Close()\n\tfor _, file := range reader.File {\n\t\tif err := unzipFile(file, dstDir); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc unzipFile(file *zip.File, dstDir string) error {\n\t// create the directory of file\n\tfilePath := path.Join(dstDir, file.Name)\n\tif file.FileInfo().IsDir() {\n\t\tif err := os.MkdirAll(filePath, os.ModePerm); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n\tif err := os.MkdirAll(filepath.Dir(filePath), os.ModePerm); err != nil {\n\t\treturn err\n\t}\n\n\t// open the file\n\tr, err := file.Open()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer r.Close()\n\n\t// create the file\n\tw, err := os.Create(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer w.Close()\n\n\t// save the decompressed file content\n\t_, err = io.Copy(w, r)\n\treturn err\n}\n", "package zip\n\nimport (\n\t\"archive/zip\"\n\t\"io\"\n\t\"io/fs\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/dablelv/go-huge-util/file\"\n)\n\n//\n// How to implement zip and unzip please refer to https://dablelv.blog.csdn.net/article/details/122441250.\n//\n\n// Zip compresses the specified files or dirs to zip archive.\n// If a path is a dir don't need to specify the trailing path separator.\n// For example calling Zip(\"archive.zip\", \"dir\", \"csv/baz.csv\") will get archive.zip and the content of which is\n// baz.csv\n// dir\n// \u251c\u2500\u2500 bar.txt\n// \u2514\u2500\u2500 foo.txt\n// Note that if a file is a symbolic link it will be skipped.\nfunc Zip(zipPath string, paths ...string) error {\n\t// Create zip file and it's parent dir.\n\tif err := os.MkdirAll(filepath.Dir(zipPath), os.ModePerm); err != nil {\n\t\treturn err\n\t}\n\tarchive, err := os.Create(zipPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer archive.Close()\n\n\t// New zip writer.\n\tzipWriter := zip.NewWriter(archive)\n\tdefer zipWriter.Close()\n\n\t// Traverse the file or directory.\n\tfor _, rootPath := range paths {\n\t\t// Remove the trailing path separator if path is a directory.\n\t\trootPath = strings.TrimSuffix(rootPath, string(os.PathSeparator))\n\n\t\t// Visit all the files or directories in the tree.\n\t\terr = filepath.Walk(rootPath, walkFunc(rootPath, zipWriter))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc walkFunc(rootPath string, zipWriter *zip.Writer) filepath.WalkFunc {\n\treturn func(path string, info fs.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If a file is a symbolic link it will be skipped.\n\t\tif info.Mode()&os.ModeSymlink != 0 {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Create a local file header.\n\t\theader, err := zip.FileInfoHeader(info)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Set compression method.\n\t\theader.Method = zip.Deflate\n\n\t\t// Set relative path of a file as the header name.\n\t\theader.Name, err = filepath.Rel(filepath.Dir(rootPath), path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\theader.Name += string(os.PathSeparator)\n\t\t}\n\n\t\t// Create writer for the file header and save content of the file.\n\t\theaderWriter, err := zipWriter.CreateHeader(header)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tf, err := os.Open(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer f.Close()\n\t\t_, err = io.Copy(headerWriter, f)\n\t\treturn err\n\t}\n}\n\n// ZipFollowSymlink compresses the specified files or dirs to zip archive.\n// If the specified files or dirs is a symbolic link ZipFollowSymlink will follow it.\n// Note that the symbolic link need to avoid loops.\nfunc ZipFollowSymlink(zipPath string, paths ...string) error {\n\t// Create zip file and it's parent dir.\n\tif err := os.MkdirAll(filepath.Dir(zipPath), os.ModePerm); err != nil {\n\t\treturn err\n\t}\n\tarchive, err := os.Create(zipPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer archive.Close()\n\n\t// New zip writer.\n\tzipWriter := zip.NewWriter(archive)\n\tdefer zipWriter.Close()\n\n\t// Get all the file or directory paths.\n\tvar allFilePaths []string\n\tpathToRoot := make(map[string]string)\n\tfor _, path := range paths {\n\t\t// If the path is a dir or symlink to dir, get all files in it.\n\t\tinfo, err := os.Stat(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\t// Remove the trailing path separator if path is a directory.\n\t\t\tpath = strings.TrimSuffix(path, string(os.PathSeparator))\n\t\t\tfilePaths, err := file.GetDirAllEntryPathsFollowSymlink(path, true)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tallFilePaths = append(allFilePaths, filePaths...)\n\t\t\tfor _, p := range filePaths {\n\t\t\t\tpathToRoot[p] = path\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tallFilePaths = append(allFilePaths, path)\n\t\tpathToRoot[path] = path\n\t}\n\n\t// Traverse all the file or directory.\n\tfor _, path := range allFilePaths {\n\t\tinfo, err := os.Stat(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Create a local file header.\n\t\theader, err := zip.FileInfoHeader(info)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Set compression method.\n\t\theader.Method = zip.Deflate\n\n\t\t// Set relative path of a file as the header name.\n\t\theader.Name, err = filepath.Rel(filepath.Dir(pathToRoot[path]), path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\theader.Name += string(os.PathSeparator)\n\t\t}\n\n\t\t// Create writer for the file header and save content of the file.\n\t\theaderWriter, err := zipWriter.CreateHeader(header)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If file is a directory.\n\t\tif info.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\t// If file is a file or symlink to file.\n\t\trealPath, err := filepath.EvalSymlinks(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tf, err := os.Open(realPath)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer f.Close()\n\t\t_, err = io.Copy(headerWriter, f)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n"], "fixing_code": ["<div align=center>\n\n![Go version](https://img.shields.io/github/go-mod/go-version/dablelv/go-huge-util)\n[![GitHub latest tag](https://img.shields.io/github/tag/dablelv/go-huge-util)](https://github.com/dablelv/go-huge-util)\n[![Go Report Card](https://goreportcard.com/badge/github.com/dablelv/go-huge-util)](https://goreportcard.com/report/github.com/dablelv/go-huge-util)\n[![Unit Test](https://github.com/dablelv/go-huge-util/workflows/go-test/badge.svg)](https://github.com/dablelv/go-huge-util/actions)\n[![Coverage Status](https://coveralls.io/repos/github/dablelv/go-huge-util/badge.svg?branch=master)](https://coveralls.io/github/dablelv/go-huge-util?branch=master)\n[![Go Reference](https://pkg.go.dev/badge/github.com/dablelv/go-huge-util.svg)](https://pkg.go.dev/github.com/dablelv/go-huge-util)\n[![License](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](https://github.com/dablelv/go-huge-util/blob/main/LICENSE)\n[![Stars](https://img.shields.io/github/stars/dablelv/go-huge-util?style=social)](https://img.shields.io/github/stars/dablelv/go-huge-util?style=social)\n\n</div>\n\n# Synopsis\nGo common used utility functions help you to create go program quickly and easily.\n\n# Encode\nSome useful functions can be used to handle conversion of different character encoding, such as gbk to utf8.\n```go\ngbkStr := []byte{0xC4, 0xE3, 0xBA, 0xC3}    // \u4f60\u597d in gbk\nutf8Str, _ := GbkToUtf8(gbkStr)             // \u4f60\u597d in utf8\ngbkStrRes, _ := Utf8ToGbk(utf8Str)          // [196 227 186 195]\n```\nSome converting function to json.\n```go\nstudent := struct {\n    Hobby   string\n    Age     int32\n}{\n    Hobby: \"pingpopng\",\n    Age:   28,\n}\nencoding.ToIndentJSON(&student)\n/*\noutput:\n{\n    \"Hobby\": \"pingpopng\",\n    \"Age\": 28\n}\n*/\n```\n# Net\nSome useful functions can be used to handle network. For example you can use `IPv4StrToU32()` transform ipv4 string to uint32 value.\n\n```go\nIsReservedIP(\"0.0.0.256\")    // -1 invalid ip\nIsReservedIP(\"39.156.69.79\") // 0 public ip\nIsReservedIP(\"127.0.0.1\")    // 1 reserved ip\n\nIPv4StrToU32(\"127.0.0.1\")      // 2130706433\nU32ToIPv4Str(2130706433)       // \"127.0.0.1\"\nGetNativeEndian()              // LittleEndian\nIsLittleEndian()               // true\n```\n# Slice\nSome useful functions can be used to handle slice.\n\n```go\nUniqueIntSlice([]int{1, 2, 2, 3})              // [1 2 3]\nUniqueUintSlice([]uint{1, 2, 2, 3})            // [1 2 3]\nUniqueStrSlice([]string{\"a\", \"b\", \"b\", \"c\"})   // [a b c]\n\nReverseIntSlice([]int{1, 2, 3})                // [3 2 1]\nReverseUintSlice([]uint{1, 2, 3})              // [3 2 1]\nReverseStrSlice([]string{\"a\", \"b\", \"c\"})       // [c b a]\n\nSumSlice([]int{1,2,3})                         // 6\nSumSlice([]uint{1,2,3})                        // 6\nSumSlice([]float32{1.1, 2.2, 3.3})             // 6.6\nSumSlice([]float64{1.1, 2.2, 3.3})             // 6.6\n\nJoinSliceWithSep([]int{1, 2, 3}, \",\")              // 1,2,3\nJoinSliceWithSep([]uint{1, 2, 3}, \",\")             // 1,2,3\nJoinSliceWithSep([]float64{1.1, 2.2, 3.3}, \",\")    // 1.1,2.2,3.3\nJoinSliceWithSep([]string{\"a\", \"b\", \"c\"}, \",\")     // a,b,c\n\n// CRUD(Create Read Update Delete) on slice by index\nfib := []int{1, 1, 2, 3, 5, 8}\nr, _ := InsertSliceE(fib, 6, 13)    // [1 1 2 3 5 8 13]\nr, _ := DeleteSliceE(fib, 0)        // [1 2 3 5 8]\nr, _ := UpdateSliceE(fib, 5, 88)    // [1 1 2 3 5 88]\nr, _ := GetEleIndexesSliceE(fib, 1) // [0 1]\n\n// or\nr := InsertIntSlice(fib, 5, 13)\t\t// [1 1 2 3 5 8 13]\nr := DeleteIntSliceE(fib, 0)\t\t// [1 2 3 5 8]\nr := UpdateIntSliceE(fib, 5, 88)\t// [1 1 2 3 5 88]\nr := GetElemIndexesSlice(fib, 1)\t// [0 1]\n```\n\n# SQL\nSome useful functions can be used to handle sql statement.\n\n```go\nvar sql = `select * from t where field1=\"{name}\"`\nhuge.FormatSql(sql, map[string]string{\"name\": \"dablelv\"}, false)    // select * from t where field1=\"dablelv\"\n```\n\n# String\nSome useful functions can be used to handle string.\n\n```go\nSplit(\"a,b,c\", \",\")                    // []string{\"a\", \"b\", \"c\"}\n\nSplitSeps(\"a,b|c\", \",\", \"|\")           // []string{\"a\", \"b\", \"c\"}\nSplitSeps(\"a,bSEPc\", \",\", \"SEP\")       // []string{\"a\", \"b\", \"c\"}\n\nJoinStr(\",\", \"a\", \"\", \"b\")             // \"a,,b\"\nJoinStrSkipEmpty(\",\", \"a\", \"\", \"b\")    // \"a,b\"\n\nReverseStr(\"abc\")                      // \"cba\"\n\nGetAlphanumericNumByASCII(\"108\u6761\u6881\u5c71man\")     // 6\nGetAlphanumericNumByASCIIV2(\"108\u6761\u6881\u5c71man\")   // 6\nGetAlphanumericNumByRegExp(\"108\u6761\u6881\u5c71man\")    // 6\n```\n\n# Time\nSome useful functions can be used to handle date and time.\n\n```go\ntc := huge.NewTimeCounter()\n// do your statements\ntc.GetMs()                  // get the time cost in millisecond\n\nGetNowDate()                // just a example, the same below. 2020-05-16\nGetNowTime()                // 00:15:42\nGetNowDateTime()            // 2020-05-16 00:15:42\nGetNowDateTimeZ()           // 2020-05-16 00:15:42 +08:00\n\nGetNowS()                   // 1589559342\nGetNowMs()                  // 1589559342963\nGetNowUs()                  // 1589559342963062\nGetNowNs()                  // 1589559342964063200\n\nGetDayBeginMoment(time.Now())  // 2020-05-16 00:00:00 +0800 CST\nGetDayEndMoment(time.Now())    // 2020-05-16 23:59:59.999999999 +0800 CST\n```\n\n# Type Conversion\nSome useful functions can be used to convert one type to another types, such as to map or slice.\n\n## to another type\n```go\n// to string\ns, err := ToAny[string](\"foo\") // \"foo\"\ns, err := ToAny[string](8)     // \"8\"\ns, err := ToAny[string](8.31)  // \"8.31\"\ns, err := ToAny[string]([]byte(\"one time\")) // \"one time\"\ns, err := ToAny[string](nil)                // \"\"\n\nvar foo any = \"one more time\"\ns, err := ToAny[string](foo)                // \"one more time\"\n\n// to int\ni, err :=  ToAny[int](8)                  // 8\ni, err :=  ToAny[int](8.31)               // 8\ni, err :=  ToAny[int](\"8\")                // 8\ni, err :=  ToAny[int](true)               // 1\ni, err :=  ToAny[int](false)              // 0\ni, err :=  ToAny[int](nil)                // 0\n\nvar eight any = 8\ni, err :=  ToAny[int](eight)              // 8\n\n// to bool\nb, err := ToAny[bool](\"true\")           // true\nb, err := ToAny[bool](\"false\")          // false\nb, err := ToAny[bool](\"True\")           // true\nb, err := ToAny[bool](\"False\")          // false\nb, err := ToAny[bool](1)                // true\nb, err := ToAny[bool](0)                // false\nb, err := ToAny[bool](nil)              // false\n\nvar one any = 1\nb, err := ToAny[bool](one)           // true\n```\n## to set\n```go\n// Convert bool slice or array to set.\nbools := []bool{true, false, true}\nset := conv.ToBoolSet(bools)\nset, _ := conv.ToBoolSetE(bools)\nset := conv.ToSet[bool](bools)\nset, _ := conv.ToSetE[bool](bools)\n\n// Convert int slice or array to set.\nints := []int{1, 2, 3}\nset := conv.ToIntSet(ints)\nset, _ := conv.ToIntSetE(ints)\nset := conv.ToSetG[int](ints)\nset, _ := conv.ToSetE[int](ints)\n\n// Convert string slice or array to set.\nstrs := []string{\"foo\", \"bar\", \"baz\"}\nset := conv.ToStrSet(strs)\nset, _ := conv.ToStrSetE(strs)\nset := conv.ToSet[string](strs)\nset, _ := conv.ToSetE[string](strs)\n\n// Split string to set.\nconv.SplitStrToSet(\"a,b,c\", \",\")  // map[a:{}, b:{}, c:{}]\n```\n\n## to slice\n```go\n// Convert string separated by white space character to string slice.\nsl := conv.ToStrSlice(\"a b c\") // []string{\"a\",\"b\",\"c\"}\nsl, _ := conv.ToStrSliceE(\"a b c\") // []string{\"a\",\"b\",\"c\"}\n\n// Convert int slice or array to string slice.\nsl := conv.ToStrSlice([]int{1, 2, 3}) // []string{\"1\",\"2\",\"3\"}\nsl, _ := conv.ToStrSliceE([]int{1, 2, 3}) // []string{\"1\",\"2\",\"3\"}\n\n// Convert map to slice in random order.\nks, vs := conv.Map2Slice(map[int]int{1:1, 2:2, 3:3})\nks, vs, _ := conv.Map2SliceE(map[int]int{1:1, 2:2, 3:3})\n\nslK, _ : = ks.([]int)\nslV, _ : = vs.([]int)\n\nks, vs := conv.Map2Slice(map[string]int{\"foo\":1, \"bar\":2, \"baz\":3})\nks, vs, _ := conv.Map2SliceE(map[string]int{\"foo\":1, \"bar\":2, \"baz\":3})\n\nslK, _ : = ks.([]string)\nslV, _ : = vs.([]int)\n\n// Split string to slice.\n// int[1,2,3]\nints := conv.SplitStrToSlice[int](\"1,2,3\", \",\")\nints, _ := conv.SplitStrToSliceE[int](\"1,2,3\", \",\")\n// uint[1,2,3]      \nuints := conv.SplitStrToSlice[uint](\"1,2,3\", \",\")\nuints, _ := conv.SplitStrToSliceE[uint](\"1,2,3\", \",\")\n// float64[1.1,2.2,3.3]\nf64s := conv.SplitStrToSlice[float64](\"1.1,2.2,3.3\", \",\")\nf64s, _ := conv.SplitStrToSliceE[float64](\"1.1,2.2,3.3\", \",\")\n// bool[true,false,true,false]\nbs := conv.SplitStrToSlice[bool](\"1,0,true,false\", \",\")\nbs, _ := conv.SplitStrToSliceE[bool](\"1,0,true,false\", \",\")\n```\n\n## to map\n\n```go\nvar st = struct {\n    I int\n    S string\n}{I: 1, S: \"a\"}\n\n// to map[string]any\nStruct2Map(st)         // map[\"I\":1 \"S\":\"a\"]\n// to map[string]string\nStruct2MapString(st)   // map[\"I\":\"1\" \"S\":\"a\"]\n\n// any type tp map[string]string\nm := ToMapStrStr(`{\"foo\":\"foo\",\"bar\":\"bar\",\"baz\":\"baz\"}`)       // map[\"foo\":\"foo\" \"bar\":\"bar\" \"baz\":\"baz\"]\nm, err := ToMapStrStrE(`{\"foo\":\"foo\",\"bar\":\"bar\",\"baz\":\"baz\"}`) // map[\"foo\":\"foo\" \"bar\":\"bar\" \"baz\":\"baz\"], nil\n```\n\n# URL\n\nSome useful functions can be used to handle url.\n\n```go\nvar rawUrl=`http://www.aspxfans.com:8080/news/index.asp?boardID=520&page=1&page=2#name`\nhuge.RawUrlGetDomain(rawUrl)    // \"www.aspxfans.com\"\nhuge.RawUrlGetPort(rawUrl)      // \"8080\"\n\nhuge.RawURLGetParam(rawUrl, \"page\")         // 1 <nil>\nhuge.RawURLGetParams(rawUrl, \"page\")        // [1 2] <nil>\nhuge.RawURLGetAllParams(rawUrl)             // map[boardID:[520] page:[1 2]] <nil>\n\nhuge.RawURLAddParam(rawUrl, \"keyword\", \"dog\")   // http://www.aspxfans.com:8080/news/index.asp?boardID=520&keyword=dog&page=1&page=2#name\nhuge.RawURLDelParam(rawUrl, \"page\")             // http://www.aspxfans.com:8080/news/index.asp?boardID=520#name\nhuge.RawURLSetParam(rawUrl, \"boardID\", \"521\")   // http://www.aspxfans.com:8080/news/index.asp?boardID=521&page=1&page=2#name\n```\n\n# Crypto\nSome useful functions can be used to create Hash, HMAC and crypt data.\n\n```go\n// Hash functions.\nMD5L(\"\")   // d41d8cd98f00b204e9800998ecf8427e\nMD5U(\"\")   // D41D8CD98F00B204E9800998ECF8427E\n\nSHA1L(\"\")  // da39a3ee5e6b4b0d3255bfef95601890afd80709\nSHA1U(\"\")  // DA39A3EE5E6B4B0D3255BFEF95601890AFD80709\n\nSHA224L(\"\")    // d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f\nSHA224U(\"\")    // D14A028C2A3A2BC9476102BB288234C415A2B01F828EA62AC5B3E42F\n\nSHA256L(\"\")    // e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\nSHA256U(\"\")    // E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855\n\nSHA384L(\"\")    // 38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c0cc7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b\nSHA384U(\"\")    // 38B060A751AC96384CD9327EB1B1E36A21FDB71114BE07434C0CC7BF63F6E1DA274EDEBFE76F65FBD51AD2F14898B95B\n\nSHA512L(\"\")    // cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e\nSHA512U(\"\")    // CF83E1357EEFB8BDF1542850D66D8007D620E4050B5715DC83F4A921D36CE9CE47D0D13C5D85F2B0FF8318D2877EEC2F63B931BD47417A81A538327AF927DA3E\n\n// HMAC functions.\nHMACMD5L(\"\", \"\")   // 74e6f7298a9c2d168935f58c001bad88\nHMACMD5U(\"\", \"\")   // 74E6F7298A9C2D168935F58C001BAD88\n\nHMACSHA1L(\"\", \"\")  // fbdb1d1b18aa6c08324b7d64b71fb76370690e1d\nHMACSHA1U(\"\", \"\")  // FBDB1D1B18AA6C08324B7D64B71FB76370690E1D\n\nHMACSHA224L(\"\", \"\")    // 5ce14f72894662213e2748d2a6ba234b74263910cedde2f5a9271524\nHMACSHA224U(\"\", \"\")    // 5CE14F72894662213E2748D2A6BA234B74263910CEDDE2F5A9271524\n\nHMACSHA256L(\"\", \"\")    // b613679a0814d9ec772f95d778c35fc5ff1697c493715653c6c712144292c5ad\nHMACSHA256U(\"\", \"\")    // B613679A0814D9EC772F95D778C35FC5FF1697C493715653C6C712144292C5AD\n\nHMACSHA384L(\"\", \"\")    // 6c1f2ee938fad2e24bd91298474382ca218c75db3d83e114b3d4367776d14d3551289e75e8209cd4b792302840234adc\nHMACSHA384U(\"\", \"\")    // 6C1F2EE938FAD2E24BD91298474382CA218C75DB3D83E114B3D4367776D14D3551289E75E8209CD4B792302840234ADC\n\nHMACSHA512L(\"\", \"\")    // b936cee86c9f87aa5d3c6f2e84cb5a4239a5fe50480a6ec66b70ab5b1f4ac6730c6c515421b327ec1d69402e53dfb49ad7381eb067b338fd7b0cb22247225d47\nHMACSHA512U(\"\", \"\")    // B936CEE86C9F87AA5D3C6F2E84CB5A4239A5FE50480A6EC66B70AB5B1F4AC6730C6C515421B327EC1D69402E53DFB49AD7381EB067B338FD7B0CB22247225D47\n\n// Encryption functions.\np := []byte(\"plaintext\")\nkey16 := []byte(\"12345678abcdefgh\")\nc, _ := Base64AESCBCEncrypt(p, key16) // A67NhD3RBiNaMgG6HTm8LQ==\np, _ = Base64AESCBCDecrypt(c, key16)  // plaintext\n\nkey8 := []byte(\"12345678\")\nc, _ := Base64DESCBCEncrypt(p, key8) // UZS/y4By6ksePYMBbvZdig==\np, _ := Base64DESCBCDecrypt(c, key8) // plaintext\n\nkey24 := []byte(\"12345678abcdefgh12345678\")\nc, _ := Base64TriDESCBCEncrypt(p, key24) // dau0DzmDGQbHasZaOvxxwg==\np, _ := Base64TriDESCBCDecrypt(c, key24) // plaintext\n```\n\n# Rand\n\nSome functions to create a real non-negative random int number, specified length random string, and so on.\n\n```go\nmath.GetRandInt()               // 2040723487295132865\nmath.GetRandIntn(100)           // 49\nmath.GetRandIntRange(0, 100)    // 44\nmath.GetRandByteSlice(3)        // [241 16 101]\nmath.GetRandStr(3)              // dAt\nmath.GetRandLowerStr(3)         // lts\nmath.GetRandUpperStr(3)         // YUT\n```\n\n# File\n\n```go\n// ListDir lists all the file or directory names in the specified directory.\nListDir()\n\n// IsExist checks whether a file/dir exists.\nIsExist()\n\n// IsDir checks whether a path is a directory.\nIsDir()\nIsDirE()\n\n// IsFile checks whether a path is a file.\nIsFile()\nIsFileE()\n\n// IsSymlink checks a file whether is a symbolic link file on Linux.\nIsSymlink()\nIsSymlinkE()\n\n// IsShortcut checks a file whether is a shortcut on Windows. \nIsShortcutFile()\n\n// Create a file.\nCreate()\nCreateFile()\n\n// ClearFile clears a file content.\nClearFile()\n\n// ...\n```\n\n# Comparison\n\nSome useful functions to compare.\n\n```go\n// Compare two any type value.\ncmp.Cmp(888, 889)       // LT\ncmp.Cmp(888, 888)       // EQ\ncmp.Cmp(889, 888)       // GT\ncmp.Cmp(88.8, 88.9)     // LT\ncmp.Cmp(88.8, 88.8)     // EQ\ncmp.Cmp(88.9, 88.8)     // GT\ncmp.Cmp(\"abc\", \"b\")     // LT\ncmp.Cmp(\"abc\", \"abc\")   // EQ\ncmp.Cmp(\"b\", \"abc\")     // GT\n\n// Compare semantic version. \nb, _ := cmp.VerGTVer(\"1.0.5\", \"1.0.4\")   // true\nb, _ := cmp.VerLTVer(\"1.0.5\", \"2.0.4\")   // true\nb, _ := cmp.VerGEVer(\"2.0.4\", \"2.0.4\")   // true\nb, _ := cmp.VerLEVer(\"1.0.5\", \"1.0.5\")   // true\n```\n\n# Others\n\nSome useful functions now unclassified. Of course, it may be classified and moved to a new subdirectory in the future.\n\n```go\n// NO NOW.\n```\n\n# Star History\n\n[![Star History Chart](https://api.star-history.com/svg?repos=dablelv/go-huge-util&type=Date)](https://star-history.com/#dablelv/go-huge-util&Date)\n\n# How to Contribute\n\nWe really appreciate any code commits which make this lib powerful. Please follow the rules below to create your pull request.\n\n1. Fork the repository.\n2. Add and Commit your changes.\n3. Push to your forked repository.\n4. Create new pull request.\n\n# Summary\n\nThe above examples are just the tip of the iceberg. For more usage, please read the source code.\n\nDue to the limited personal ability, you are welcome to criticize and correct. Of course, welcome to join in the construction of this library.", "package file\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// ReadLines reads all lines of the specified file.\nfunc ReadLines(path string) ([]string, int, error) {\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tdefer file.Close()\n\n\tvar lines []string\n\tlineCount := 0\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tlines = append(lines, scanner.Text())\n\t\tlineCount++\n\t}\n\n\tif scanner.Err() == bufio.ErrTooLong {\n\t\tpanic(scanner.Err())\n\t}\n\treturn lines, lineCount, scanner.Err()\n}\n\n// ReadLinesV2 reads all lines of the specified file.\nfunc ReadLinesV2(path string) ([]string, int, error) {\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tdefer file.Close()\n\n\tvar lines []string\n\tlineCount := 0\n\treader := bufio.NewReader(file)\n\tfor {\n\t\tline, err := reader.ReadString('\\n')\n\t\tlines = append(lines, line)\n\t\tlineCount++\n\t\tif err == io.EOF {\n\t\t\treturn lines, lineCount, nil\n\t\t}\n\t\tif err != nil {\n\t\t\treturn lines, lineCount, err\n\t\t}\n\t}\n}\n\n// ListDir lists all the file or directory names in the specified directory.\n// Note that ListDir don't traverse recursively.\nfunc ListDir(dirname string) ([]string, error) {\n\tinfos, err := ioutil.ReadDir(dirname)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tnames := make([]string, len(infos))\n\tfor i, info := range infos {\n\t\tnames[i] = info.Name()\n\t}\n\treturn names, nil\n}\n\n// IsExist checks whether a file/dir exists.\n// Use os.Stat to get the info of the target file or dir to check whether exists.\n// If os.Stat returns nil err, the target exists.\n// If os.Stat returns a os.ErrNotExist err, the target does not exist.\n// If the error returned is another type, the target is uncertain whether exists.\nfunc IsExist(path string) (bool, error) {\n\t_, err := os.Stat(path)\n\tif err == nil {\n\t\treturn true, nil\n\t}\n\tif os.IsNotExist(err) {\n\t\treturn false, nil\n\t}\n\treturn false, err\n}\n\n// IsDir checks whether a path is a directory.\n// If the path is a symbolic link will follow it.\nfunc IsDir(path string) bool {\n\tif info, err := os.Stat(path); err == nil && info.IsDir() {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// IsDirE checks whether a path is a directory with error.\n// If the path is a symbolic link will follow it.\nfunc IsDirE(path string) (bool, error) {\n\tinfo, err := os.Stat(path)\n\tif err == nil && info.IsDir() {\n\t\treturn true, nil\n\t}\n\treturn false, err\n}\n\n// IsFile checks whether a path is a file.\n// If the path is a symbolic link will follow it.\nfunc IsFile(path string) bool {\n\tif info, err := os.Stat(path); err == nil && info.Mode().IsRegular() {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// IsFileE checks whether a path is a file with error.\n// If the path is a symbolic link will follow it.\nfunc IsFileE(path string) (bool, error) {\n\tinfo, err := os.Stat(path)\n\tif err == nil && info.Mode().IsRegular() {\n\t\treturn true, nil\n\t}\n\treturn false, err\n}\n\n// IsSymlink checks a file whether is a symbolic link on Linux.\n// Note that this doesn't work for the shortcut file on windows.\n// If you want to check a file whether is a shortcut file on Windows please use IsShortcut function.\nfunc IsSymlink(path string) bool {\n\tif info, err := os.Lstat(path); err == nil && info.Mode()&os.ModeSymlink != 0 {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// IsSymlinkE checks a file whether is a symbolic link on Linux.\n// Note that this doesn't work for the shortcut file on windows.\n// If you want to check a file whether is a shortcut file on Windows please use IsShortcut function.\nfunc IsSymlinkE(path string) (bool, error) {\n\tinfo, err := os.Lstat(path)\n\tif err == nil && info.Mode()&os.ModeSymlink != 0 {\n\t\treturn true, nil\n\t}\n\treturn false, err\n}\n\n// IsShortcut checks a file whether is a shortcut on Windows.\nfunc IsShortcut(path string) bool {\n\text := filepath.Ext(path)\n\tif ext == \".lnk\" {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// RemoveFile removes the named file or empty directory.\n// If there is an error, it will be of type *PathError.\nfunc RemoveFile(path string) error {\n\treturn os.Remove(path)\n}\n\n// Create creates or truncates the target file specified by path.\n// If the parent directory does not exist, it will be created with mode os.ModePerm.\n// If the file does not exist, it is created with mode 0666.\n// If successful, methods on the returned file can be used for I/O; the associated file descriptor has mode O_RDWR.\nfunc Create(path string) (*os.File, error) {\n\texist, err := IsExist(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif exist {\n\t\treturn os.Create(path)\n\t}\n\tif err := os.MkdirAll(filepath.Dir(path), os.ModePerm); err != nil {\n\t\treturn nil, err\n\t}\n\treturn os.Create(path)\n}\n\n// CreateFile creates a file specified by path.\nfunc CreateFile(filePath string) error {\n\tfile, err := Create(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\treturn nil\n}\n\n// FileToBytes serialize the file to bytes.\nfunc FileToBytes(path string) []byte {\n\tbyteStream, _ := ioutil.ReadFile(path)\n\treturn byteStream\n}\n\n// BytesToFile writes data to a file.\n// If the file does not exist it will be created with permission mode 0644.\nfunc BytesToFile(path string, data []byte) error {\n\texist, _ := IsExist(path)\n\tif !exist {\n\t\tif err := CreateFile(path); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn ioutil.WriteFile(path, data, 0644)\n}\n\n// GetDirAllEntryPaths gets all the file or dir paths in the specified directory recursively.\n// If the incl is true result will include current dir.\n// Note that GetDirAllEntryPaths won't follow symlink if the subdir is a symbolic link.\nfunc GetDirAllEntryPaths(dirname string, incl bool) ([]string, error) {\n\t// Remove the trailing path separator if dirname has.\n\tdirname = strings.TrimSuffix(dirname, string(os.PathSeparator))\n\n\tinfos, err := ioutil.ReadDir(dirname)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpaths := make([]string, 0, len(infos))\n\t// Include current dir.\n\tif incl {\n\t\tpaths = append(paths, dirname)\n\t}\n\n\tfor _, info := range infos {\n\t\tpath := dirname + string(os.PathSeparator) + info.Name()\n\t\tif info.IsDir() {\n\t\t\ttmp, err := GetDirAllEntryPaths(path, incl)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tpaths = append(paths, tmp...)\n\t\t\tcontinue\n\t\t}\n\t\tpaths = append(paths, path)\n\t}\n\treturn paths, nil\n}\n\n// GetDirAllEntryPathsFollowSymlink gets all the file or dir paths in the specified directory recursively.\n// If the incl is true result will include current dir.\nfunc GetDirAllEntryPathsFollowSymlink(dirname string, incl bool) ([]string, error) {\n\t// Remove the trailing path separator if dirname has.\n\tdirname = strings.TrimSuffix(dirname, string(os.PathSeparator))\n\n\tinfos, err := ioutil.ReadDir(dirname)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpaths := make([]string, 0, len(infos))\n\t// Include current dir.\n\tif incl {\n\t\tpaths = append(paths, dirname)\n\t}\n\n\tfor _, info := range infos {\n\t\tpath := dirname + string(os.PathSeparator) + info.Name()\n\t\trealInfo, err := os.Stat(path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif realInfo.IsDir() {\n\t\t\ttmp, err := GetDirAllEntryPathsFollowSymlink(path, incl)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tpaths = append(paths, tmp...)\n\t\t\tcontinue\n\t\t}\n\t\tpaths = append(paths, path)\n\t}\n\treturn paths, nil\n}\n\n// ClearFile clears a file content.\nfunc ClearFile(path string) error {\n\tf, err := os.OpenFile(path, os.O_WRONLY|os.O_TRUNC, 0777)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\treturn nil\n}\n", "package zip\n\nimport (\n\t\"archive/zip\"\n\t\"io\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// Unzip decompresses a zip file to specified directory.\n// Note that the destination directory don't need to specify the trailing path separator.\nfunc Unzip(zipPath, dstDir string) error {\n\t// Open zip file.\n\treader, err := zip.OpenReader(zipPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer reader.Close()\n\tfor _, file := range reader.File {\n\t\tif err := unzipFile(file, dstDir); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc unzipFile(file *zip.File, dstDir string) error {\n\t// Prevent path traversal vulnerability.\n\t// Such as if the file name is \"../../../path/to/file.txt\" which will be cleaned to \"path/to/file.txt\".\n\tname := strings.TrimPrefix(filepath.Join(string(filepath.Separator), file.Name), string(filepath.Separator))\n\tfilePath := path.Join(dstDir, name)\n\n\t// Create the directory of file.\n\tif file.FileInfo().IsDir() {\n\t\tif err := os.MkdirAll(filePath, os.ModePerm); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n\tif err := os.MkdirAll(filepath.Dir(filePath), os.ModePerm); err != nil {\n\t\treturn err\n\t}\n\n\t// Open the file.\n\tr, err := file.Open()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer r.Close()\n\n\t// Create the file.\n\tw, err := os.Create(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer w.Close()\n\n\t// Save the decompressed file content.\n\t_, err = io.Copy(w, r)\n\treturn err\n}\n", "package zip\n\nimport (\n\t\"archive/zip\"\n\t\"io\"\n\t\"io/fs\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/dablelv/go-huge-util/file\"\n)\n\n//\n// How to implement zip and unzip please refer to https://dablelv.blog.csdn.net/article/details/122441250.\n//\n\n// Zip compresses the specified files or dirs to zip archive.\n// If a path is a dir don't need to specify the trailing path separator.\n// For example calling Zip(\"archive.zip\", \"dir\", \"csv/baz.csv\") will get archive.zip and the content of which is\n// baz.csv\n// dir\n// \u251c\u2500\u2500 bar.txt\n// \u2514\u2500\u2500 foo.txt\n// Note that if a file is a symbolic link on Linux it will be skipped.\n// If you want to follow a symbolic link please use the function ZipFollowSymlink.\nfunc Zip(zipPath string, paths ...string) error {\n\t// Create zip file and it's parent dir.\n\tif err := os.MkdirAll(filepath.Dir(zipPath), os.ModePerm); err != nil {\n\t\treturn err\n\t}\n\tarchive, err := os.Create(zipPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer archive.Close()\n\n\t// New zip writer.\n\tzipWriter := zip.NewWriter(archive)\n\tdefer zipWriter.Close()\n\n\t// Traverse the file or directory.\n\tfor _, rootPath := range paths {\n\t\t// Remove the trailing path separator if path is a directory.\n\t\trootPath = strings.TrimSuffix(rootPath, string(os.PathSeparator))\n\n\t\t// Visit all the files or directories in the tree.\n\t\terr = filepath.Walk(rootPath, walkFunc(rootPath, zipWriter))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc walkFunc(rootPath string, zipWriter *zip.Writer) filepath.WalkFunc {\n\treturn func(path string, info fs.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If a file is a symbolic link it will be skipped.\n\t\tif info.Mode()&os.ModeSymlink != 0 {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Create a local file header.\n\t\theader, err := zip.FileInfoHeader(info)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Set compression method.\n\t\theader.Method = zip.Deflate\n\n\t\t// Set relative path of a file as the header name.\n\t\theader.Name, err = filepath.Rel(filepath.Dir(rootPath), path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\theader.Name += string(os.PathSeparator)\n\t\t}\n\n\t\t// Create writer for the file header and save content of the file.\n\t\theaderWriter, err := zipWriter.CreateHeader(header)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tf, err := os.Open(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer f.Close()\n\t\t_, err = io.Copy(headerWriter, f)\n\t\treturn err\n\t}\n}\n\n// ZipFollowSymlink compresses the specified files or dirs to zip archive.\n// If the specified files or dirs is a symbolic link ZipFollowSymlink will follow it.\n// Note that the symbolic link need to avoid loops.\nfunc ZipFollowSymlink(zipPath string, paths ...string) error {\n\t// Create zip file and it's parent dir.\n\tif err := os.MkdirAll(filepath.Dir(zipPath), os.ModePerm); err != nil {\n\t\treturn err\n\t}\n\tarchive, err := os.Create(zipPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer archive.Close()\n\n\t// New zip writer.\n\tzipWriter := zip.NewWriter(archive)\n\tdefer zipWriter.Close()\n\n\t// Get all the file or directory paths.\n\tvar allFilePaths []string\n\tpathToRoot := make(map[string]string)\n\tfor _, path := range paths {\n\t\t// If the path is a dir or symlink to dir, get all files in it.\n\t\tinfo, err := os.Stat(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\t// Remove the trailing path separator if path is a directory.\n\t\t\tpath = strings.TrimSuffix(path, string(os.PathSeparator))\n\t\t\tfilePaths, err := file.GetDirAllEntryPathsFollowSymlink(path, true)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tallFilePaths = append(allFilePaths, filePaths...)\n\t\t\tfor _, p := range filePaths {\n\t\t\t\tpathToRoot[p] = path\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tallFilePaths = append(allFilePaths, path)\n\t\tpathToRoot[path] = path\n\t}\n\n\t// Traverse all the file or directory.\n\tfor _, path := range allFilePaths {\n\t\tinfo, err := os.Stat(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Create a local file header.\n\t\theader, err := zip.FileInfoHeader(info)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Set compression method.\n\t\theader.Method = zip.Deflate\n\n\t\t// Set relative path of a file as the header name.\n\t\theader.Name, err = filepath.Rel(filepath.Dir(pathToRoot[path]), path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\theader.Name += string(os.PathSeparator)\n\t\t}\n\n\t\t// Create writer for the file header and save content of the file.\n\t\theaderWriter, err := zipWriter.CreateHeader(header)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If file is a directory.\n\t\tif info.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\t// If file is a file or symlink to file.\n\t\trealPath, err := filepath.EvalSymlinks(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tf, err := os.Open(realPath)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer f.Close()\n\t\t_, err = io.Copy(headerWriter, f)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n"], "filenames": ["README.md", "file/file.go", "zip/unzip.go", "zip/zip.go"], "buggy_code_start_loc": [24, 58, 8, 25], "buggy_code_end_loc": [352, 262, 56, 26], "fixing_code_start_loc": [23, 58, 9, 25], "fixing_code_end_loc": [383, 286, 61, 27], "type": "CWE-22", "message": "go-used-util has commonly used utility functions for Go. Versions prior to 0.0.34 have a ZipSlip issue when using fsutil package to unzip files. When users use `zip.Unzip` to unzip zip files from a malicious attacker, they may be vulnerable to path traversal. The issue has been fixed in version 0.0.34. There are no known workarounds.", "other": {"cve": {"id": "CVE-2023-28105", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-16T17:15:09.483", "lastModified": "2023-03-23T13:59:56.927", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "go-used-util has commonly used utility functions for Go. Versions prior to 0.0.34 have a ZipSlip issue when using fsutil package to unzip files. When users use `zip.Unzip` to unzip zip files from a malicious attacker, they may be vulnerable to path traversal. The issue has been fixed in version 0.0.34. There are no known workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.3}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:go-huge-util_project:go-huge-util:*:*:*:*:*:go:*:*", "versionEndExcluding": "0.0.34", "matchCriteriaId": "58D7A018-81A2-441C-AAA7-220C71A59A01"}]}]}], "references": [{"url": "https://github.com/dablelv/go-huge-util/commit/0e308b0fac8973e6fa251b0ab095cdc5c1c0956b", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/dablelv/go-huge-util/security/advisories/GHSA-5g39-ppwg-6xx8", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dablelv/go-huge-util/commit/0e308b0fac8973e6fa251b0ab095cdc5c1c0956b"}}