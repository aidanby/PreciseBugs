{"buggy_code": ["module CarrierWave\n\n  ##\n  # This module simplifies manipulation with RMagick by providing a set\n  # of convenient helper methods. If you want to use them, you'll need to\n  # require this file:\n  #\n  #     require 'carrierwave/processing/rmagick'\n  #\n  # And then include it in your uploader:\n  #\n  #     class MyUploader < CarrierWave::Uploader::Base\n  #       include CarrierWave::RMagick\n  #     end\n  #\n  # You can now use the provided helpers:\n  #\n  #     class MyUploader < CarrierWave::Uploader::Base\n  #       include CarrierWave::RMagick\n  #\n  #       process :resize_to_fit => [200, 200]\n  #     end\n  #\n  # Or create your own helpers with the powerful manipulate! method. Check\n  # out the RMagick docs at http://www.imagemagick.org/RMagick/doc/ for more\n  # info\n  #\n  #     class MyUploader < CarrierWave::Uploader::Base\n  #       include CarrierWave::RMagick\n  #\n  #       process :do_stuff => 10.0\n  #\n  #       def do_stuff(blur_factor)\n  #         manipulate! do |img|\n  #           img = img.sepiatone\n  #           img = img.auto_orient\n  #           img = img.radial_blur(blur_factor)\n  #         end\n  #       end\n  #     end\n  #\n  # === Note\n  #\n  # You should be aware how RMagick handles memory. manipulate! takes care\n  # of freeing up memory for you, but for optimum memory usage you should\n  # use destructive operations as much as possible:\n  #\n  # DON'T DO THIS:\n  #     img = img.resize_to_fit\n  #\n  # DO THIS INSTEAD:\n  #     img.resize_to_fit!\n  #\n  # Read this for more information why:\n  #\n  # http://rubyforge.org/forum/forum.php?thread_id=1374&forum_id=1618\n  #\n  module RMagick\n    extend ActiveSupport::Concern\n\n    included do\n      begin\n        require \"rmagick\"\n      rescue LoadError\n        require \"RMagick\"\n      rescue LoadError => e\n        e.message << \" (You may need to install the rmagick gem)\"\n        raise e\n      end\n\n      prepend Module.new {\n        def initialize(*)\n          super\n          @format = nil\n        end\n      }\n    end\n\n    module ClassMethods\n      def convert(format)\n        process :convert => format\n      end\n\n      def resize_to_limit(width, height)\n        process :resize_to_limit => [width, height]\n      end\n\n      def resize_to_fit(width, height)\n        process :resize_to_fit => [width, height]\n      end\n\n      def resize_to_fill(width, height, gravity=::Magick::CenterGravity)\n        process :resize_to_fill => [width, height, gravity]\n      end\n\n      def resize_and_pad(width, height, background=:transparent, gravity=::Magick::CenterGravity)\n        process :resize_and_pad => [width, height, background, gravity]\n      end\n\n      def resize_to_geometry_string(geometry_string)\n        process :resize_to_geometry_string => [geometry_string]\n      end\n    end\n\n    ##\n    # Changes the image encoding format to the given format\n    #\n    # See even http://www.imagemagick.org/RMagick/doc/magick.html#formats\n    #\n    # === Parameters\n    #\n    # [format (#to_s)] an abreviation of the format\n    #\n    # === Yields\n    #\n    # [Magick::Image] additional manipulations to perform\n    #\n    # === Examples\n    #\n    #     image.convert(:png)\n    #\n    def convert(format)\n      manipulate!(:format => format)\n      @format = format\n    end\n\n    ##\n    # Resize the image to fit within the specified dimensions while retaining\n    # the original aspect ratio. Will only resize the image if it is larger than the\n    # specified dimensions. The resulting image may be shorter or narrower than specified\n    # in the smaller dimension but will not be larger than the specified values.\n    #\n    # === Parameters\n    #\n    # [width (Integer)] the width to scale the image to\n    # [height (Integer)] the height to scale the image to\n    #\n    # === Yields\n    #\n    # [Magick::Image] additional manipulations to perform\n    #\n    def resize_to_limit(width, height)\n      width = dimension_from width\n      height = dimension_from height\n      manipulate! do |img|\n        geometry = Magick::Geometry.new(width, height, 0, 0, Magick::GreaterGeometry)\n        new_img = img.change_geometry(geometry) do |new_width, new_height|\n          img.resize(new_width, new_height)\n        end\n        destroy_image(img)\n        new_img = yield(new_img) if block_given?\n        new_img\n      end\n    end\n\n    ##\n    # From the RMagick documentation: \"Resize the image to fit within the\n    # specified dimensions while retaining the original aspect ratio. The\n    # image may be shorter or narrower than specified in the smaller dimension\n    # but will not be larger than the specified values.\"\n    #\n    # See even http://www.imagemagick.org/RMagick/doc/image3.html#resize_to_fit\n    #\n    # === Parameters\n    #\n    # [width (Integer)] the width to scale the image to\n    # [height (Integer)] the height to scale the image to\n    #\n    # === Yields\n    #\n    # [Magick::Image] additional manipulations to perform\n    #\n    def resize_to_fit(width, height)\n      width = dimension_from width\n      height = dimension_from height\n      manipulate! do |img|\n        img.resize_to_fit!(width, height)\n        img = yield(img) if block_given?\n        img\n      end\n    end\n\n    ##\n    # From the RMagick documentation: \"Resize the image to fit within the\n    # specified dimensions while retaining the aspect ratio of the original\n    # image. If necessary, crop the image in the larger dimension.\"\n    #\n    # See even http://www.imagemagick.org/RMagick/doc/image3.html#resize_to_fill\n    #\n    # === Parameters\n    #\n    # [width (Integer)] the width to scale the image to\n    # [height (Integer)] the height to scale the image to\n    #\n    # === Yields\n    #\n    # [Magick::Image] additional manipulations to perform\n    #\n    def resize_to_fill(width, height, gravity=::Magick::CenterGravity)\n      width = dimension_from width\n      height = dimension_from height\n      manipulate! do |img|\n        img.crop_resized!(width, height, gravity)\n        img = yield(img) if block_given?\n        img\n      end\n    end\n\n    ##\n    # Resize the image to fit within the specified dimensions while retaining\n    # the original aspect ratio. If necessary, will pad the remaining area\n    # with the given color, which defaults to transparent (for gif and png,\n    # white for jpeg).\n    #\n    # === Parameters\n    #\n    # [width (Integer)] the width to scale the image to\n    # [height (Integer)] the height to scale the image to\n    # [background (String, :transparent)] the color of the background as a hexcode, like \"#ff45de\"\n    # [gravity (Magick::GravityType)] how to position the image\n    #\n    # === Yields\n    #\n    # [Magick::Image] additional manipulations to perform\n    #\n    def resize_and_pad(width, height, background=:transparent, gravity=::Magick::CenterGravity)\n      width = dimension_from width\n      height = dimension_from height\n      manipulate! do |img|\n        img.resize_to_fit!(width, height)\n        new_img = ::Magick::Image.new(width, height) { |img| img.background_color = background == :transparent ? 'rgba(255,255,255,0)' : background.to_s }\n        if background == :transparent\n          filled = new_img.matte_floodfill(1, 1)\n        else\n          filled = new_img.color_floodfill(1, 1, ::Magick::Pixel.from_color(background))\n        end\n        destroy_image(new_img)\n        filled.composite!(img, gravity, ::Magick::OverCompositeOp)\n        destroy_image(img)\n        filled = yield(filled) if block_given?\n        filled\n      end\n    end\n\n    ##\n    # Resize the image per the provided geometry string.\n    #\n    # === Parameters\n    #\n    # [geometry_string (String)] the proportions in which to scale image\n    #\n    # === Yields\n    #\n    # [Magick::Image] additional manipulations to perform\n    #\n    def resize_to_geometry_string(geometry_string)\n      manipulate! do |img|\n        new_img = img.change_geometry(geometry_string) do |new_width, new_height|\n          img.resize(new_width, new_height)\n        end\n        destroy_image(img)\n        new_img = yield(new_img) if block_given?\n        new_img\n      end\n    end\n\n    ##\n    # Returns the width of the image.\n    #\n    # === Returns\n    #\n    # [Integer] the image's width in pixels\n    #\n    def width\n      rmagick_image.columns\n    end\n\n    ##\n    # Returns the height of the image.\n    #\n    # === Returns\n    #\n    # [Integer] the image's height in pixels\n    #\n    def height\n      rmagick_image.rows\n    end\n\n    ##\n    # Manipulate the image with RMagick. This method will load up an image\n    # and then pass each of its frames to the supplied block. It will then\n    # save the image to disk.\n    #\n    # === Gotcha\n    #\n    # This method assumes that the object responds to +current_path+.\n    # Any class that this module is mixed into must have a +current_path+ method.\n    # CarrierWave::Uploader does, so you won't need to worry about this in\n    # most cases.\n    #\n    # === Yields\n    #\n    # [Magick::Image] manipulations to perform\n    # [Integer] Frame index if the image contains multiple frames\n    # [Hash] options, see below\n    #\n    # === Options\n    #\n    # The options argument to this method is also yielded as the third\n    # block argument.\n    #\n    # Currently, the following options are defined:\n    #\n    # ==== :write\n    # A hash of assignments to be evaluated in the block given to the RMagick write call.\n    #\n    # An example:\n    #\n    #      manipulate! do |img, index, options|\n    #        options[:write] = {\n    #          :quality => 50,\n    #          :depth => 8\n    #        }\n    #        img\n    #      end\n    #\n    # This will translate to the following RMagick::Image#write call:\n    #\n    #     image.write do |img|\n    #       self.quality = 50\n    #       self.depth = 8\n    #     end\n    #\n    # ==== :read\n    # A hash of assignments to be given to the RMagick read call.\n    #\n    # The options available are identical to those for write, but are passed in directly, like this:\n    #\n    #     manipulate! :read => { :density => 300 }\n    #\n    # ==== :format\n    # Specify the output format. If unset, the filename extension is used to determine the format.\n    #\n    # === Raises\n    #\n    # [CarrierWave::ProcessingError] if manipulation failed.\n    #\n    def manipulate!(options={}, &block)\n      cache_stored_file! if !cached?\n\n      read_block = create_info_block(options[:read])\n      image = ::Magick::Image.read(current_path, &read_block)\n      frames = ::Magick::ImageList.new\n\n      image.each_with_index do |frame, index|\n        frame = yield(*[frame, index, options].take(block.arity)) if block_given?\n        frames << frame if frame\n      end\n      frames.append(true) if block_given?\n\n      write_block = create_info_block(options[:write])\n\n      if options[:format] || @format\n        frames.write(\"#{options[:format] || @format}:#{current_path}\", &write_block)\n        move_to = current_path.chomp(File.extname(current_path)) + \".#{options[:format] || @format}\"\n        file.content_type = ::MiniMime.lookup_by_filename(move_to).content_type\n        file.move_to(move_to, permissions, directory_permissions)\n      else\n        frames.write(current_path, &write_block)\n      end\n\n      destroy_image(frames)\n    rescue ::Magick::ImageMagickError => e\n      raise CarrierWave::ProcessingError, I18n.translate(:\"errors.messages.rmagick_processing_error\", :e => e)\n    end\n\n  private\n\n    def create_info_block(options)\n      return nil unless options\n      assignments = options.map { |k, v| \"img.#{k} = #{v}\" }\n      code = \"lambda { |img| \" + assignments.join(\";\") + \"}\"\n      eval code\n    end\n\n    def destroy_image(image)\n      image.try(:destroy!)\n    end\n\n    def dimension_from(value)\n      return value unless value.instance_of?(Proc)\n      value.arity >= 1 ? value.call(self) : value.call\n    end\n\n    def rmagick_image\n      ::Magick::Image.from_blob(self.read).first\n    end\n\n  end # RMagick\nend # CarrierWave\n", "require 'spec_helper'\n\ndescribe CarrierWave::RMagick, :rmagick => true do\n\n  let(:klass) { Class.new(CarrierWave::Uploader::Base) { include CarrierWave::RMagick } }\n  let(:instance) { klass.new }\n  let(:landscape_file_path) { file_path('landscape.jpg') }\n  let(:landscape_file_copy_path) { file_path('landscape_copy.jpg') }\n\n  before do\n    FileUtils.cp(landscape_file_path, landscape_file_copy_path)\n    allow(instance).to receive(:cached?).and_return true\n    allow(instance).to receive(:file).and_return(CarrierWave::SanitizedFile.new(landscape_file_copy_path))\n  end\n\n  after do\n    FileUtils.rm(landscape_file_copy_path) if File.exist?(file_path('landscape_copy.jpg'))\n    FileUtils.rm(landscape_file_copy_path) if File.exist?(file_path('landscape_copy.jpg'))\n  end\n\n  describe '#convert' do\n    it \"converts the image to the given format\" do\n      instance.convert(:png)\n      expect(instance.file.extension).to eq('png')\n      expect(instance).to be_format('png')\n      expect(instance.file.content_type).to eq('image/png')\n    end\n  end\n\n  describe '#resize_to_fill' do\n    it \"resizes the image to exactly the given dimensions and maintain file type\" do\n      instance.resize_to_fill(200, 200)\n\n      expect(instance).to have_dimensions(200, 200)\n      expect(::Magick::Image.read(instance.current_path).first.format).to eq('JPEG')\n    end\n\n    it \"resizes the image to exactly the given dimensions and maintain updated file type\" do\n      instance.convert('png')\n      instance.resize_to_fill(200, 200)\n\n      expect(instance).to have_dimensions(200, 200)\n      expect(::Magick::Image.read(instance.current_path).first.format).to eq('PNG')\n      expect(instance.file.extension).to eq('png')\n    end\n\n    it \"scales up the image if it smaller than the given dimensions\" do\n      instance.resize_to_fill(1000, 1000)\n      expect(instance).to have_dimensions(1000, 1000)\n    end\n  end\n\n  describe '#resize_and_pad' do\n    it \"resizes the image to exactly the given dimensions and maintain file type\" do\n      instance.resize_and_pad(200, 200)\n\n      expect(instance).to have_dimensions(200, 200)\n      expect(::Magick::Image.read(instance.current_path).first.format).to eq('JPEG')\n    end\n\n    it \"resize the image to exactly the given dimensions and maintain updated file type\" do\n      instance.convert('png')\n      instance.resize_and_pad(200, 200)\n\n      expect(instance).to have_dimensions(200, 200)\n      expect(::Magick::Image.read(instance.current_path).first.format).to eq('PNG')\n      expect(instance.file.extension).to eq('png')\n    end\n\n    it \"pads with white\" do\n      instance.resize_and_pad(200, 200)\n\n      color = color_of_pixel(instance.current_path, 0, 0)\n      expect(color).to include('#FFFFFF')\n      expect(color).not_to include('#FFFFFF00')\n    end\n\n    it \"pads with transparent\" do\n      instance.convert('png')\n      instance.resize_and_pad(200, 200, :transparent)\n\n      color = color_of_pixel(instance.current_path, 0, 0)\n      expect(color).to include('#FFFFFF00')\n    end\n\n    it \"doesn't pad with transparent\" do\n      instance.resize_and_pad(200, 200, :transparent)\n      instance.convert('png')\n\n      color = color_of_pixel(instance.current_path, 0, 0)\n      expect(color).to include('#FFFFFF')\n      expect(color).not_to include('#FFFFFF00')\n    end\n\n    it \"pads with given color\" do\n      instance.resize_and_pad(200, 200, '#888')\n      color = color_of_pixel(instance.current_path, 0, 0)\n\n      expect(color).to include('#888888')\n    end\n\n    it \"scales up the image if it smaller than the given dimensions\" do\n      instance.resize_and_pad(1000, 1000)\n\n      expect(instance).to have_dimensions(1000, 1000)\n    end\n  end\n\n  describe '#resize_to_fit' do\n    it \"resizes the image to fit within the given dimensions and maintain file type\" do\n      instance.resize_to_fit(200, 200)\n\n      expect(instance).to have_dimensions(200, 150)\n      expect(::Magick::Image.read(instance.current_path).first.format).to eq('JPEG')\n    end\n\n    it \"resize the image to fit within the given dimensions and maintain updated file type\" do\n      instance.convert('png')\n      instance.resize_to_fit(200, 200)\n\n      expect(instance).to have_dimensions(200, 150)\n      expect(::Magick::Image.read(instance.current_path).first.format).to eq('PNG')\n    end\n\n    it \"scales up the image if it smaller than the given dimensions\" do\n      instance.resize_to_fit(1000, 1000)\n\n      expect(instance).to have_dimensions(1000, 750)\n    end\n  end\n\n  describe '#resize_to_limit' do\n    it \"resizes the image to fit within the given dimensions and maintain file type\" do\n      instance.resize_to_limit(200, 200)\n\n      expect(instance).to have_dimensions(200, 150)\n      expect(::Magick::Image.read(instance.current_path).first.format).to eq('JPEG')\n    end\n\n    it \"resizes the image to fit within the given dimensions and maintain updated file type\" do\n      instance.convert('png')\n      instance.resize_to_limit(200, 200)\n\n      expect(instance).to have_dimensions(200, 150)\n      expect(::Magick::Image.read(instance.current_path).first.format).to eq('PNG')\n      expect(instance.file.extension).to eq('png')\n    end\n\n    it \"doesn't scale up the image if it smaller than the given dimensions\" do\n      instance.resize_to_limit(1000, 1000)\n      expect(instance).to have_dimensions(640, 480)\n    end\n  end\n\n  describe '#resize_to_geometry_string' do\n    it \"resizes the image to comply with `200x200^` Geometry String spec and maintain file type\" do\n      instance.resize_to_geometry_string('200x200^')\n\n      expect(instance).to have_dimensions(267, 200)\n      expect(::Magick::Image.read(instance.current_path).first.format).to eq('JPEG')\n    end\n\n    it \"resizes the image to comply with `200x200^` Geometry String spec and maintain updated file type\" do\n      instance.convert('png')\n      instance.resize_to_geometry_string('200x200^')\n\n      expect(instance).to have_dimensions(267, 200)\n      expect(::Magick::Image.read(instance.current_path).first.format).to eq('PNG')\n      expect(instance.file.extension).to eq('png')\n    end\n\n    it \"resizes the image to have 125% larger dimensions\" do\n      instance.resize_to_geometry_string('125%')\n      expect(instance).to have_dimensions(800, 600)\n    end\n\n    it \"resizes the image to have a given height\" do\n      instance.resize_to_geometry_string('x256')\n      expect(instance).to have_height(256)\n    end\n\n    it \"resizes the image to have a given width\" do\n      instance.resize_to_geometry_string('256x')\n      expect(instance).to have_width(256)\n    end\n  end\n\n  describe \"#manipulate!\" do\n    let(:image) { ::Magick::Image.read(landscape_file_path) }\n\n    it 'supports passing write options to RMagick' do\n      allow(::Magick::Image).to receive_messages(:read => image)\n      expect_any_instance_of(::Magick::Image::Info).to receive(:quality=).with(50)\n      expect_any_instance_of(::Magick::Image::Info).to receive(:depth=).with(8)\n\n      instance.manipulate! do |image, index, options|\n        options[:write] = {\n          :quality => 50,\n          :depth => 8\n        }\n        image\n      end\n    end\n\n    it 'supports passing read options to RMagick' do\n      expect_any_instance_of(::Magick::Image::Info).to receive(:density=).with(10)\n      expect_any_instance_of(::Magick::Image::Info).to receive(:size=).with(\"200x200\")\n\n      instance.manipulate! :read => {\n          :density => 10,\n          :size => %{\"200x200\"}\n        }\n    end\n  end\n\n  describe \"#width and #height\" do\n    it \"returns the width and height of the image\" do\n      instance.resize_to_fill(200, 300)\n      expect(instance.width).to eq(200)\n      expect(instance.height).to eq(300)\n    end\n  end\n\n  describe '#dimension_from' do\n    it 'evaluates procs' do\n      instance.resize_to_fill(Proc.new { 200 }, Proc.new { 200 })\n\n      expect(instance).to have_dimensions(200, 200)\n    end\n\n    it 'evaluates procs with uploader instance' do\n      width_argument = nil\n      width = Proc.new do |uploader|\n        width_argument = uploader\n        200\n      end\n      height_argument = nil\n      height = Proc.new do |uploader|\n        height_argument = uploader\n        200\n      end\n      instance.resize_to_fill(width, height)\n\n      expect(instance).to have_dimensions(200, 200)\n      expect(instance).to eq(width_argument)\n      expect(instance).to eq(height_argument)\n    end\n  end\n\n  describe \"#rmagick_image\" do\n    it \"returns a ::Magick::Image\" do\n      expect{instance.send(:rmagick_image)}.to_not raise_exception\n      expect(instance.send(:rmagick_image).class).to eq(::Magick::Image)\n    end\n\n    context \"with a remotely stored file\" do\n      class RemoteFile < CarrierWave::SanitizedFile\n        def initialize local_path\n          @local_path = local_path\n        end\n\n        def current_path\n          \"foo/bar.jpg\"\n        end\n\n        def read\n          File.read @local_path\n        end\n      end\n\n      before do\n        allow(instance).to receive(:file).and_return(RemoteFile.new(landscape_file_copy_path))\n      end\n\n      it \"returns a ::Magick::Image\" do\n        expect{instance.send(:rmagick_image)}.to_not raise_exception\n        expect(instance.send(:rmagick_image).class).to eq(::Magick::Image)\n      end\n    end\n  end\n\n  describe \"test errors\" do\n    context \"invalid image file\" do\n      before do\n        File.open(instance.current_path, 'w') { |f| f.puts \"bogus\" }\n      end\n\n      it \"fails to process a non image file\" do\n        expect {instance.resize_to_limit(200, 200)}.to raise_exception(CarrierWave::ProcessingError, /^Failed to manipulate with rmagick, maybe it is not an image\\?/)\n      end\n\n      it \"uses I18n\" do\n        change_locale_and_store_translations(:nl, :errors => {\n          :messages => {\n            :rmagick_processing_error => \"Kon bestand niet met rmagick bewerken, misschien is het geen beeld bestand?\"\n          }\n        }) do\n          expect {instance.resize_to_limit(200, 200)}.to raise_exception(CarrierWave::ProcessingError, /^Kon bestand niet met rmagick bewerken, misschien is het geen beeld bestand\\?/)\n        end\n      end\n\n      it \"doesn't suppress errors when translation is unavailable\" do\n        change_locale_and_store_translations(:foo, {}) do\n          expect { instance.resize_to_limit(200, 200) }.to raise_exception( CarrierWave::ProcessingError )\n        end\n      end\n\n      context \":en locale is not available and enforce_available_locales is true\" do\n        it \"doesn't suppress errors\" do\n          change_and_enforece_available_locales(:nl, [:nl, :foo]) do\n            expect { instance.resize_to_limit(200, 200) }.to raise_exception(CarrierWave::ProcessingError)\n          end\n        end\n      end\n    end\n  end\nend\n"], "fixing_code": ["module CarrierWave\n\n  ##\n  # This module simplifies manipulation with RMagick by providing a set\n  # of convenient helper methods. If you want to use them, you'll need to\n  # require this file:\n  #\n  #     require 'carrierwave/processing/rmagick'\n  #\n  # And then include it in your uploader:\n  #\n  #     class MyUploader < CarrierWave::Uploader::Base\n  #       include CarrierWave::RMagick\n  #     end\n  #\n  # You can now use the provided helpers:\n  #\n  #     class MyUploader < CarrierWave::Uploader::Base\n  #       include CarrierWave::RMagick\n  #\n  #       process :resize_to_fit => [200, 200]\n  #     end\n  #\n  # Or create your own helpers with the powerful manipulate! method. Check\n  # out the RMagick docs at http://www.imagemagick.org/RMagick/doc/ for more\n  # info\n  #\n  #     class MyUploader < CarrierWave::Uploader::Base\n  #       include CarrierWave::RMagick\n  #\n  #       process :do_stuff => 10.0\n  #\n  #       def do_stuff(blur_factor)\n  #         manipulate! do |img|\n  #           img = img.sepiatone\n  #           img = img.auto_orient\n  #           img = img.radial_blur(blur_factor)\n  #         end\n  #       end\n  #     end\n  #\n  # === Note\n  #\n  # You should be aware how RMagick handles memory. manipulate! takes care\n  # of freeing up memory for you, but for optimum memory usage you should\n  # use destructive operations as much as possible:\n  #\n  # DON'T DO THIS:\n  #     img = img.resize_to_fit\n  #\n  # DO THIS INSTEAD:\n  #     img.resize_to_fit!\n  #\n  # Read this for more information why:\n  #\n  # http://rubyforge.org/forum/forum.php?thread_id=1374&forum_id=1618\n  #\n  module RMagick\n    extend ActiveSupport::Concern\n\n    included do\n      begin\n        require \"rmagick\"\n      rescue LoadError\n        require \"RMagick\"\n      rescue LoadError => e\n        e.message << \" (You may need to install the rmagick gem)\"\n        raise e\n      end\n\n      prepend Module.new {\n        def initialize(*)\n          super\n          @format = nil\n        end\n      }\n    end\n\n    module ClassMethods\n      def convert(format)\n        process :convert => format\n      end\n\n      def resize_to_limit(width, height)\n        process :resize_to_limit => [width, height]\n      end\n\n      def resize_to_fit(width, height)\n        process :resize_to_fit => [width, height]\n      end\n\n      def resize_to_fill(width, height, gravity=::Magick::CenterGravity)\n        process :resize_to_fill => [width, height, gravity]\n      end\n\n      def resize_and_pad(width, height, background=:transparent, gravity=::Magick::CenterGravity)\n        process :resize_and_pad => [width, height, background, gravity]\n      end\n\n      def resize_to_geometry_string(geometry_string)\n        process :resize_to_geometry_string => [geometry_string]\n      end\n    end\n\n    ##\n    # Changes the image encoding format to the given format\n    #\n    # See even http://www.imagemagick.org/RMagick/doc/magick.html#formats\n    #\n    # === Parameters\n    #\n    # [format (#to_s)] an abreviation of the format\n    #\n    # === Yields\n    #\n    # [Magick::Image] additional manipulations to perform\n    #\n    # === Examples\n    #\n    #     image.convert(:png)\n    #\n    def convert(format)\n      manipulate!(:format => format)\n      @format = format\n    end\n\n    ##\n    # Resize the image to fit within the specified dimensions while retaining\n    # the original aspect ratio. Will only resize the image if it is larger than the\n    # specified dimensions. The resulting image may be shorter or narrower than specified\n    # in the smaller dimension but will not be larger than the specified values.\n    #\n    # === Parameters\n    #\n    # [width (Integer)] the width to scale the image to\n    # [height (Integer)] the height to scale the image to\n    #\n    # === Yields\n    #\n    # [Magick::Image] additional manipulations to perform\n    #\n    def resize_to_limit(width, height)\n      width = dimension_from width\n      height = dimension_from height\n      manipulate! do |img|\n        geometry = Magick::Geometry.new(width, height, 0, 0, Magick::GreaterGeometry)\n        new_img = img.change_geometry(geometry) do |new_width, new_height|\n          img.resize(new_width, new_height)\n        end\n        destroy_image(img)\n        new_img = yield(new_img) if block_given?\n        new_img\n      end\n    end\n\n    ##\n    # From the RMagick documentation: \"Resize the image to fit within the\n    # specified dimensions while retaining the original aspect ratio. The\n    # image may be shorter or narrower than specified in the smaller dimension\n    # but will not be larger than the specified values.\"\n    #\n    # See even http://www.imagemagick.org/RMagick/doc/image3.html#resize_to_fit\n    #\n    # === Parameters\n    #\n    # [width (Integer)] the width to scale the image to\n    # [height (Integer)] the height to scale the image to\n    #\n    # === Yields\n    #\n    # [Magick::Image] additional manipulations to perform\n    #\n    def resize_to_fit(width, height)\n      width = dimension_from width\n      height = dimension_from height\n      manipulate! do |img|\n        img.resize_to_fit!(width, height)\n        img = yield(img) if block_given?\n        img\n      end\n    end\n\n    ##\n    # From the RMagick documentation: \"Resize the image to fit within the\n    # specified dimensions while retaining the aspect ratio of the original\n    # image. If necessary, crop the image in the larger dimension.\"\n    #\n    # See even http://www.imagemagick.org/RMagick/doc/image3.html#resize_to_fill\n    #\n    # === Parameters\n    #\n    # [width (Integer)] the width to scale the image to\n    # [height (Integer)] the height to scale the image to\n    #\n    # === Yields\n    #\n    # [Magick::Image] additional manipulations to perform\n    #\n    def resize_to_fill(width, height, gravity=::Magick::CenterGravity)\n      width = dimension_from width\n      height = dimension_from height\n      manipulate! do |img|\n        img.crop_resized!(width, height, gravity)\n        img = yield(img) if block_given?\n        img\n      end\n    end\n\n    ##\n    # Resize the image to fit within the specified dimensions while retaining\n    # the original aspect ratio. If necessary, will pad the remaining area\n    # with the given color, which defaults to transparent (for gif and png,\n    # white for jpeg).\n    #\n    # === Parameters\n    #\n    # [width (Integer)] the width to scale the image to\n    # [height (Integer)] the height to scale the image to\n    # [background (String, :transparent)] the color of the background as a hexcode, like \"#ff45de\"\n    # [gravity (Magick::GravityType)] how to position the image\n    #\n    # === Yields\n    #\n    # [Magick::Image] additional manipulations to perform\n    #\n    def resize_and_pad(width, height, background=:transparent, gravity=::Magick::CenterGravity)\n      width = dimension_from width\n      height = dimension_from height\n      manipulate! do |img|\n        img.resize_to_fit!(width, height)\n        new_img = ::Magick::Image.new(width, height) { |img| img.background_color = background == :transparent ? 'rgba(255,255,255,0)' : background.to_s }\n        if background == :transparent\n          filled = new_img.matte_floodfill(1, 1)\n        else\n          filled = new_img.color_floodfill(1, 1, ::Magick::Pixel.from_color(background))\n        end\n        destroy_image(new_img)\n        filled.composite!(img, gravity, ::Magick::OverCompositeOp)\n        destroy_image(img)\n        filled = yield(filled) if block_given?\n        filled\n      end\n    end\n\n    ##\n    # Resize the image per the provided geometry string.\n    #\n    # === Parameters\n    #\n    # [geometry_string (String)] the proportions in which to scale image\n    #\n    # === Yields\n    #\n    # [Magick::Image] additional manipulations to perform\n    #\n    def resize_to_geometry_string(geometry_string)\n      manipulate! do |img|\n        new_img = img.change_geometry(geometry_string) do |new_width, new_height|\n          img.resize(new_width, new_height)\n        end\n        destroy_image(img)\n        new_img = yield(new_img) if block_given?\n        new_img\n      end\n    end\n\n    ##\n    # Returns the width of the image.\n    #\n    # === Returns\n    #\n    # [Integer] the image's width in pixels\n    #\n    def width\n      rmagick_image.columns\n    end\n\n    ##\n    # Returns the height of the image.\n    #\n    # === Returns\n    #\n    # [Integer] the image's height in pixels\n    #\n    def height\n      rmagick_image.rows\n    end\n\n    ##\n    # Manipulate the image with RMagick. This method will load up an image\n    # and then pass each of its frames to the supplied block. It will then\n    # save the image to disk.\n    #\n    # === Gotcha\n    #\n    # This method assumes that the object responds to +current_path+.\n    # Any class that this module is mixed into must have a +current_path+ method.\n    # CarrierWave::Uploader does, so you won't need to worry about this in\n    # most cases.\n    #\n    # === Yields\n    #\n    # [Magick::Image] manipulations to perform\n    # [Integer] Frame index if the image contains multiple frames\n    # [Hash] options, see below\n    #\n    # === Options\n    #\n    # The options argument to this method is also yielded as the third\n    # block argument.\n    #\n    # Currently, the following options are defined:\n    #\n    # ==== :write\n    # A hash of assignments to be evaluated in the block given to the RMagick write call.\n    #\n    # An example:\n    #\n    #      manipulate! do |img, index, options|\n    #        options[:write] = {\n    #          :quality => 50,\n    #          :depth => 8\n    #        }\n    #        img\n    #      end\n    #\n    # This will translate to the following RMagick::Image#write call:\n    #\n    #     image.write do |img|\n    #       self.quality = 50\n    #       self.depth = 8\n    #     end\n    #\n    # ==== :read\n    # A hash of assignments to be given to the RMagick read call.\n    #\n    # The options available are identical to those for write, but are passed in directly, like this:\n    #\n    #     manipulate! :read => { :density => 300 }\n    #\n    # ==== :format\n    # Specify the output format. If unset, the filename extension is used to determine the format.\n    #\n    # === Raises\n    #\n    # [CarrierWave::ProcessingError] if manipulation failed.\n    #\n    def manipulate!(options={}, &block)\n      cache_stored_file! if !cached?\n\n      read_block = create_info_block(options[:read])\n      image = ::Magick::Image.read(current_path, &read_block)\n      frames = ::Magick::ImageList.new\n\n      image.each_with_index do |frame, index|\n        frame = yield(*[frame, index, options].take(block.arity)) if block_given?\n        frames << frame if frame\n      end\n      frames.append(true) if block_given?\n\n      write_block = create_info_block(options[:write])\n\n      if options[:format] || @format\n        frames.write(\"#{options[:format] || @format}:#{current_path}\", &write_block)\n        move_to = current_path.chomp(File.extname(current_path)) + \".#{options[:format] || @format}\"\n        file.content_type = ::MiniMime.lookup_by_filename(move_to).content_type\n        file.move_to(move_to, permissions, directory_permissions)\n      else\n        frames.write(current_path, &write_block)\n      end\n\n      destroy_image(frames)\n    rescue ::Magick::ImageMagickError => e\n      raise CarrierWave::ProcessingError, I18n.translate(:\"errors.messages.rmagick_processing_error\", :e => e)\n    end\n\n  private\n\n    def create_info_block(options)\n      return nil unless options\n      proc do |img|\n        options.each do |k, v|\n          if v.is_a?(String) && (matches = v.match(/^[\"'](.+)[\"']/))\n            ActiveSupport::Deprecation.warn \"Passing quoted strings like #{v} to #manipulate! is deprecated, pass them without quoting.\"\n            v = matches[1]\n          end\n          img.public_send(:\"#{k}=\", v)\n        end\n      end\n    end\n\n    def destroy_image(image)\n      image.try(:destroy!)\n    end\n\n    def dimension_from(value)\n      return value unless value.instance_of?(Proc)\n      value.arity >= 1 ? value.call(self) : value.call\n    end\n\n    def rmagick_image\n      ::Magick::Image.from_blob(self.read).first\n    end\n\n  end # RMagick\nend # CarrierWave\n", "require 'spec_helper'\n\ndescribe CarrierWave::RMagick, :rmagick => true do\n\n  let(:klass) { Class.new(CarrierWave::Uploader::Base) { include CarrierWave::RMagick } }\n  let(:instance) { klass.new }\n  let(:landscape_file_path) { file_path('landscape.jpg') }\n  let(:landscape_file_copy_path) { file_path('landscape_copy.jpg') }\n\n  before do\n    FileUtils.cp(landscape_file_path, landscape_file_copy_path)\n    allow(instance).to receive(:cached?).and_return true\n    allow(instance).to receive(:file).and_return(CarrierWave::SanitizedFile.new(landscape_file_copy_path))\n  end\n\n  after do\n    FileUtils.rm(landscape_file_copy_path) if File.exist?(file_path('landscape_copy.jpg'))\n    FileUtils.rm(landscape_file_copy_path) if File.exist?(file_path('landscape_copy.jpg'))\n  end\n\n  describe '#convert' do\n    it \"converts the image to the given format\" do\n      instance.convert(:png)\n      expect(instance.file.extension).to eq('png')\n      expect(instance).to be_format('png')\n      expect(instance.file.content_type).to eq('image/png')\n    end\n  end\n\n  describe '#resize_to_fill' do\n    it \"resizes the image to exactly the given dimensions and maintain file type\" do\n      instance.resize_to_fill(200, 200)\n\n      expect(instance).to have_dimensions(200, 200)\n      expect(::Magick::Image.read(instance.current_path).first.format).to eq('JPEG')\n    end\n\n    it \"resizes the image to exactly the given dimensions and maintain updated file type\" do\n      instance.convert('png')\n      instance.resize_to_fill(200, 200)\n\n      expect(instance).to have_dimensions(200, 200)\n      expect(::Magick::Image.read(instance.current_path).first.format).to eq('PNG')\n      expect(instance.file.extension).to eq('png')\n    end\n\n    it \"scales up the image if it smaller than the given dimensions\" do\n      instance.resize_to_fill(1000, 1000)\n      expect(instance).to have_dimensions(1000, 1000)\n    end\n  end\n\n  describe '#resize_and_pad' do\n    it \"resizes the image to exactly the given dimensions and maintain file type\" do\n      instance.resize_and_pad(200, 200)\n\n      expect(instance).to have_dimensions(200, 200)\n      expect(::Magick::Image.read(instance.current_path).first.format).to eq('JPEG')\n    end\n\n    it \"resize the image to exactly the given dimensions and maintain updated file type\" do\n      instance.convert('png')\n      instance.resize_and_pad(200, 200)\n\n      expect(instance).to have_dimensions(200, 200)\n      expect(::Magick::Image.read(instance.current_path).first.format).to eq('PNG')\n      expect(instance.file.extension).to eq('png')\n    end\n\n    it \"pads with white\" do\n      instance.resize_and_pad(200, 200)\n\n      color = color_of_pixel(instance.current_path, 0, 0)\n      expect(color).to include('#FFFFFF')\n      expect(color).not_to include('#FFFFFF00')\n    end\n\n    it \"pads with transparent\" do\n      instance.convert('png')\n      instance.resize_and_pad(200, 200, :transparent)\n\n      color = color_of_pixel(instance.current_path, 0, 0)\n      expect(color).to include('#FFFFFF00')\n    end\n\n    it \"doesn't pad with transparent\" do\n      instance.resize_and_pad(200, 200, :transparent)\n      instance.convert('png')\n\n      color = color_of_pixel(instance.current_path, 0, 0)\n      expect(color).to include('#FFFFFF')\n      expect(color).not_to include('#FFFFFF00')\n    end\n\n    it \"pads with given color\" do\n      instance.resize_and_pad(200, 200, '#888')\n      color = color_of_pixel(instance.current_path, 0, 0)\n\n      expect(color).to include('#888888')\n    end\n\n    it \"scales up the image if it smaller than the given dimensions\" do\n      instance.resize_and_pad(1000, 1000)\n\n      expect(instance).to have_dimensions(1000, 1000)\n    end\n  end\n\n  describe '#resize_to_fit' do\n    it \"resizes the image to fit within the given dimensions and maintain file type\" do\n      instance.resize_to_fit(200, 200)\n\n      expect(instance).to have_dimensions(200, 150)\n      expect(::Magick::Image.read(instance.current_path).first.format).to eq('JPEG')\n    end\n\n    it \"resize the image to fit within the given dimensions and maintain updated file type\" do\n      instance.convert('png')\n      instance.resize_to_fit(200, 200)\n\n      expect(instance).to have_dimensions(200, 150)\n      expect(::Magick::Image.read(instance.current_path).first.format).to eq('PNG')\n    end\n\n    it \"scales up the image if it smaller than the given dimensions\" do\n      instance.resize_to_fit(1000, 1000)\n\n      expect(instance).to have_dimensions(1000, 750)\n    end\n  end\n\n  describe '#resize_to_limit' do\n    it \"resizes the image to fit within the given dimensions and maintain file type\" do\n      instance.resize_to_limit(200, 200)\n\n      expect(instance).to have_dimensions(200, 150)\n      expect(::Magick::Image.read(instance.current_path).first.format).to eq('JPEG')\n    end\n\n    it \"resizes the image to fit within the given dimensions and maintain updated file type\" do\n      instance.convert('png')\n      instance.resize_to_limit(200, 200)\n\n      expect(instance).to have_dimensions(200, 150)\n      expect(::Magick::Image.read(instance.current_path).first.format).to eq('PNG')\n      expect(instance.file.extension).to eq('png')\n    end\n\n    it \"doesn't scale up the image if it smaller than the given dimensions\" do\n      instance.resize_to_limit(1000, 1000)\n      expect(instance).to have_dimensions(640, 480)\n    end\n  end\n\n  describe '#resize_to_geometry_string' do\n    it \"resizes the image to comply with `200x200^` Geometry String spec and maintain file type\" do\n      instance.resize_to_geometry_string('200x200^')\n\n      expect(instance).to have_dimensions(267, 200)\n      expect(::Magick::Image.read(instance.current_path).first.format).to eq('JPEG')\n    end\n\n    it \"resizes the image to comply with `200x200^` Geometry String spec and maintain updated file type\" do\n      instance.convert('png')\n      instance.resize_to_geometry_string('200x200^')\n\n      expect(instance).to have_dimensions(267, 200)\n      expect(::Magick::Image.read(instance.current_path).first.format).to eq('PNG')\n      expect(instance.file.extension).to eq('png')\n    end\n\n    it \"resizes the image to have 125% larger dimensions\" do\n      instance.resize_to_geometry_string('125%')\n      expect(instance).to have_dimensions(800, 600)\n    end\n\n    it \"resizes the image to have a given height\" do\n      instance.resize_to_geometry_string('x256')\n      expect(instance).to have_height(256)\n    end\n\n    it \"resizes the image to have a given width\" do\n      instance.resize_to_geometry_string('256x')\n      expect(instance).to have_width(256)\n    end\n  end\n\n  describe \"#manipulate!\" do\n    let(:image) { ::Magick::Image.read(landscape_file_path) }\n\n    it 'supports passing write options to RMagick' do\n      allow(::Magick::Image).to receive_messages(:read => image)\n      expect_any_instance_of(::Magick::Image::Info).to receive(:quality=).with(50)\n      expect_any_instance_of(::Magick::Image::Info).to receive(:depth=).with(8)\n\n      instance.manipulate! do |image, index, options|\n        options[:write] = {\n          :quality => 50,\n          :depth => 8\n        }\n        image\n      end\n    end\n\n    it 'supports passing read options to RMagick' do\n      expect_any_instance_of(::Magick::Image::Info).to receive(:density=).with(10)\n      expect_any_instance_of(::Magick::Image::Info).to receive(:size=).with(\"200x200\")\n\n      instance.manipulate! :read => {\n          :density => 10,\n          :size => \"200x200\"\n        }\n    end\n\n    it 'shows deprecation but still accepts strings enclosed with double quotes' do\n      expect_any_instance_of(::Magick::Image::Info).to receive(:size=).once.with(\"200x200\")\n      expect(ActiveSupport::Deprecation).to receive(:warn).with(any_args)\n      instance.manipulate! :read => {:size => %{\"200x200\"}}\n    end\n\n    it 'shows deprecation but still accepts strings enclosed with single quotes' do\n      expect_any_instance_of(::Magick::Image::Info).to receive(:size=).once.with(\"200x200\")\n      expect(ActiveSupport::Deprecation).to receive(:warn).with(any_args)\n      instance.manipulate! :read => {:size => %{'200x200'}}\n    end\n\n    it 'does not allow arbitrary code execution' do\n      expect_any_instance_of(Kernel).not_to receive(:puts)\n      expect do\n        instance.manipulate! :read => {\n            :density => \"1 }; raise; {\"\n        }\n      end.to raise_error ArgumentError, /invalid density geometry/\n    end\n\n    it 'does not allow invocation of non-public methods' do\n      module Kernel\n        private def foo=(value); raise; end\n      end\n      expect do\n        instance.manipulate! :read => {\n            :foo => \"1\"\n        }\n      end.to raise_error NoMethodError, /private method `foo=' called/\n    end\n  end\n\n  describe \"#width and #height\" do\n    it \"returns the width and height of the image\" do\n      instance.resize_to_fill(200, 300)\n      expect(instance.width).to eq(200)\n      expect(instance.height).to eq(300)\n    end\n  end\n\n  describe '#dimension_from' do\n    it 'evaluates procs' do\n      instance.resize_to_fill(Proc.new { 200 }, Proc.new { 200 })\n\n      expect(instance).to have_dimensions(200, 200)\n    end\n\n    it 'evaluates procs with uploader instance' do\n      width_argument = nil\n      width = Proc.new do |uploader|\n        width_argument = uploader\n        200\n      end\n      height_argument = nil\n      height = Proc.new do |uploader|\n        height_argument = uploader\n        200\n      end\n      instance.resize_to_fill(width, height)\n\n      expect(instance).to have_dimensions(200, 200)\n      expect(instance).to eq(width_argument)\n      expect(instance).to eq(height_argument)\n    end\n  end\n\n  describe \"#rmagick_image\" do\n    it \"returns a ::Magick::Image\" do\n      expect{instance.send(:rmagick_image)}.to_not raise_exception\n      expect(instance.send(:rmagick_image).class).to eq(::Magick::Image)\n    end\n\n    context \"with a remotely stored file\" do\n      class RemoteFile < CarrierWave::SanitizedFile\n        def initialize local_path\n          @local_path = local_path\n        end\n\n        def current_path\n          \"foo/bar.jpg\"\n        end\n\n        def read\n          File.read @local_path\n        end\n      end\n\n      before do\n        allow(instance).to receive(:file).and_return(RemoteFile.new(landscape_file_copy_path))\n      end\n\n      it \"returns a ::Magick::Image\" do\n        expect{instance.send(:rmagick_image)}.to_not raise_exception\n        expect(instance.send(:rmagick_image).class).to eq(::Magick::Image)\n      end\n    end\n  end\n\n  describe \"test errors\" do\n    context \"invalid image file\" do\n      before do\n        File.open(instance.current_path, 'w') { |f| f.puts \"bogus\" }\n      end\n\n      it \"fails to process a non image file\" do\n        expect {instance.resize_to_limit(200, 200)}.to raise_exception(CarrierWave::ProcessingError, /^Failed to manipulate with rmagick, maybe it is not an image\\?/)\n      end\n\n      it \"uses I18n\" do\n        change_locale_and_store_translations(:nl, :errors => {\n          :messages => {\n            :rmagick_processing_error => \"Kon bestand niet met rmagick bewerken, misschien is het geen beeld bestand?\"\n          }\n        }) do\n          expect {instance.resize_to_limit(200, 200)}.to raise_exception(CarrierWave::ProcessingError, /^Kon bestand niet met rmagick bewerken, misschien is het geen beeld bestand\\?/)\n        end\n      end\n\n      it \"doesn't suppress errors when translation is unavailable\" do\n        change_locale_and_store_translations(:foo, {}) do\n          expect { instance.resize_to_limit(200, 200) }.to raise_exception( CarrierWave::ProcessingError )\n        end\n      end\n\n      context \":en locale is not available and enforce_available_locales is true\" do\n        it \"doesn't suppress errors\" do\n          change_and_enforece_available_locales(:nl, [:nl, :foo]) do\n            expect { instance.resize_to_limit(200, 200) }.to raise_exception(CarrierWave::ProcessingError)\n          end\n        end\n      end\n    end\n  end\nend\n"], "filenames": ["lib/carrierwave/processing/rmagick.rb", "spec/processing/rmagick_spec.rb"], "buggy_code_start_loc": [381, 211], "buggy_code_end_loc": [384, 212], "fixing_code_start_loc": [381, 211], "fixing_code_end_loc": [390, 245], "type": "CWE-94", "message": "CarrierWave is an open-source RubyGem which provides a simple and flexible way to upload files from Ruby applications. In CarrierWave before versions 1.3.2 and 2.1.1, there is a code injection vulnerability. The \"#manipulate!\" method inappropriately evals the content of mutation option(:read/:write), allowing attackers to craft a string that can be executed as a Ruby code. If an application developer supplies untrusted inputs to the option, it will lead to remote code execution(RCE). This is fixed in versions 1.3.2 and 2.1.1.", "other": {"cve": {"id": "CVE-2021-21305", "sourceIdentifier": "security-advisories@github.com", "published": "2021-02-08T20:15:12.527", "lastModified": "2022-04-26T15:59:28.000", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "CarrierWave is an open-source RubyGem which provides a simple and flexible way to upload files from Ruby applications. In CarrierWave before versions 1.3.2 and 2.1.1, there is a code injection vulnerability. The \"#manipulate!\" method inappropriately evals the content of mutation option(:read/:write), allowing attackers to craft a string that can be executed as a Ruby code. If an application developer supplies untrusted inputs to the option, it will lead to remote code execution(RCE). This is fixed in versions 1.3.2 and 2.1.1."}, {"lang": "es", "value": "CarrierWave es un RubyGem de c\u00f3digo abierto que proporciona una forma simple y flexible de cargar archivos desde aplicaciones de Ruby.&#xa0;En CarrierWave versiones anteriores a 1.3.2 y 2.1.1, se presenta una vulnerabilidad de inyecci\u00f3n de c\u00f3digo.&#xa0;El m\u00e9todo \"#manipulate!\" eval\u00faa inapropiadamente el contenido de la opci\u00f3n de mutaci\u00f3n option(:read/:write), lo que permite a atacantes crear una cadena que se pueda ejecutar como c\u00f3digo de Ruby.&#xa0;Si un desarrollador de aplicaciones proporciona entradas que no son de confianza para la opci\u00f3n, conllevar\u00e1 a una ejecuci\u00f3n de c\u00f3digo remota (RCE).&#xa0;Esto se corrigi\u00f3 en las versiones 1.3.2 y 2.1.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 3.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:carrierwave_project:carrierwave:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "1.3.2", "matchCriteriaId": "68FBD42F-C60B-4C66-B772-C35F4AED519C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:carrierwave_project:carrierwave:*:*:*:*:*:ruby:*:*", "versionStartIncluding": "2.0.1", "versionEndExcluding": "2.1.1", "matchCriteriaId": "B9D2FEB0-C576-4E14-A2F6-7642E83CC6F1"}]}]}], "references": [{"url": "https://github.com/carrierwaveuploader/carrierwave/blob/master/CHANGELOG.md#132---2021-02-08", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/carrierwaveuploader/carrierwave/blob/master/CHANGELOG.md#211---2021-02-08", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/carrierwaveuploader/carrierwave/commit/387116f5c72efa42bc3938d946b4c8d2f22181b7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-cf3w-g86h-35x4", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://rubygems.org/gems/carrierwave", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/carrierwaveuploader/carrierwave/commit/387116f5c72efa42bc3938d946b4c8d2f22181b7"}}