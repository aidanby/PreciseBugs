{"buggy_code": ["/* -*- Mode: Javascript; indent-tabs-mode:nil; js-indent-level: 2 -*- */\n/* vim: set ts=2 et sw=2 tw=80: */\n\n/*************************************************************\n *\n *  MathJax/extensions/TeX/unicode.js\n *  \n *  Implements the \\unicode extension to TeX to allow arbitrary unicode\n *  code points to be entered into the TeX file.  You can specify\n *  the height and depth of the character (the width is determined by\n *  the browser), and the default font from which to take the character.\n *  \n *  Examples:\n *      \\unicode{65}                        % the character 'A'\n *      \\unicode{x41}                       % the character 'A'\n *      \\unicode[.55,0.05]{x22D6}           % less-than with dot, with height .55 and depth 0.05\n *      \\unicode[.55,0.05][Geramond]{x22D6} % same taken from Geramond font\n *      \\unicode[Garamond]{x22D6}           % same, but with default height, depth of .8,.2\n *\n *  Once a size and font are provided for a given code point, they need\n *  not be specified again in subsequent \\unicode calls for that character.\n *  Note that a font list can be given, but Internet Explorer has a buggy\n *  implementation of font-family where it only looks in the first\n *  available font and if the glyph is not in that, it does not look at\n *  later fonts, but goes directly to the default font as set in the\n *  Internet-Options/Font panel.  For this reason, the default font list is\n *  \"STIXGeneral,'Arial Unicode MS'\", so if the user has STIX fonts, the\n *  symbol will be taken from that (almost all the symbols are in\n *  STIXGeneral), otherwise Arial Unicode MS is tried.\n *  \n *  To configure the default font list, use\n *  \n *      MathJax.Hub.Config({\n *        TeX: {\n *          unicode: {\n *            fonts: \"STIXGeneral,'Arial Unicode MS'\"\n *          }\n *        }\n *      });\n *\n *  The result of \\unicode will have TeX class ORD (i.e., it will act like a\n *  variable).  Use \\mathbin, \\mathrel, etc, to specify a different class.\n *  \n *  ---------------------------------------------------------------------\n *  \n *  Copyright (c) 2009-2018 The MathJax Consortium\n * \n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n//\n//  The configuration defaults, augmented by the user settings\n//  \nMathJax.Extension[\"TeX/unicode\"] = {\n  version: \"2.7.3\",\n  unicode: {},\n  config: MathJax.Hub.CombineConfig(\"TeX.unicode\",{\n    fonts: \"STIXGeneral,'Arial Unicode MS'\"\n  })\n};\n  \nMathJax.Hub.Register.StartupHook(\"TeX Jax Ready\",function () {\n  var TEX = MathJax.InputJax.TeX;\n  var MML = MathJax.ElementJax.mml;\n  var UNICODE = MathJax.Extension[\"TeX/unicode\"].unicode;\n  \n  //\n  //  Add \\unicode macro\n  //\n  TEX.Definitions.Add({macros: {unicode: 'Unicode'}},null,true);\n  //\n  //  Implementation of \\unicode in parser\n  //\n  TEX.Parse.Augment({\n    Unicode: function(name) {\n      var HD = this.GetBrackets(name), font;\n      if (HD) {\n        if (HD.replace(/ /g,\"\").match(/^(\\d+(\\.\\d*)?|\\.\\d+),(\\d+(\\.\\d*)?|\\.\\d+)$/))\n          {HD = HD.replace(/ /g,\"\").split(/,/); font = this.GetBrackets(name)}\n            else {font = HD; HD = null}\n      }\n      var n = this.trimSpaces(this.GetArgument(name)),\n          N = parseInt(n.match(/^x/) ? \"0\"+n : n);\n      if (!UNICODE[N]) {UNICODE[N] = [800,200,font,N]}\n      else if (!font) {font = UNICODE[N][2]}\n      if (HD) {\n        UNICODE[N][0] = Math.floor(HD[0]*1000);\n        UNICODE[N][1] = Math.floor(HD[1]*1000);\n      }\n      var variant = this.stack.env.font, def = {};\n      if (font) {\n        UNICODE[N][2] = def.fontfamily = font.replace(/\"/g,\"'\");\n        if (variant) {\n          if (variant.match(/bold/))   {def.fontweight = \"bold\"}\n          if (variant.match(/italic|-mathit/)) {def.fontstyle = \"italic\"}\n        }\n      } else if (variant) {def.mathvariant = variant}\n      def.unicode = [].concat(UNICODE[N]); // make a copy\n      this.Push(MML.mtext(MML.entity(\"#\"+n)).With(def));\n    }\n  });\n\n  MathJax.Hub.Startup.signal.Post(\"TeX unicode Ready\");\n  \n});\n    \nMathJax.Hub.Register.StartupHook(\"HTML-CSS Jax Ready\",function () {\n  var MML = MathJax.ElementJax.mml;\n  var FONTS = MathJax.Extension[\"TeX/unicode\"].config.fonts;\n\n  //\n  //  Override getVariant to make one that includes the font and size\n  //\n  var GETVARIANT = MML.mbase.prototype.HTMLgetVariant;\n  MML.mbase.Augment({\n    HTMLgetVariant: function () {\n      var variant = GETVARIANT.apply(this,arguments);\n      if (variant.unicode) {delete variant.unicode; delete variant.FONTS} // clear font cache in case of restart\n      if (!this.unicode) {return variant}\n      variant.unicode = true;\n      if (!variant.defaultFont) {\n        variant = MathJax.Hub.Insert({},variant); // make a copy\n        variant.defaultFont = {family:FONTS};\n      }\n      var family = this.unicode[2]; if (family) {family += \",\"+FONTS} else {family = FONTS}\n      variant.defaultFont[this.unicode[3]] = [\n        this.unicode[0],this.unicode[1],500,0,500,\n        {isUnknown:true, isUnicode:true, font:family}\n      ];\n      return variant;\n    }\n  });\n});\n\nMathJax.Hub.Register.StartupHook(\"SVG Jax Ready\",function () {\n  var MML = MathJax.ElementJax.mml;\n  var FONTS = MathJax.Extension[\"TeX/unicode\"].config.fonts;\n\n  //\n  //  Override getVariant to make one that includes the font and size\n  //\n  var GETVARIANT = MML.mbase.prototype.SVGgetVariant;\n  MML.mbase.Augment({\n    SVGgetVariant: function () {\n      var variant = GETVARIANT.call(this);\n      if (variant.unicode) {delete variant.unicode; delete variant.FONTS} // clear font cache in case of restart\n      if (!this.unicode) {return variant}\n      variant.unicode = true;\n      if (!variant.forceFamily) {variant = MathJax.Hub.Insert({},variant)} // make a copy\n      variant.defaultFamily = FONTS; variant.noRemap = true;\n      variant.h = this.unicode[0]; variant.d = this.unicode[1];\n      return variant;\n    }\n  });\n});\n\nMathJax.Ajax.loadComplete(\"[MathJax]/extensions/TeX/unicode.js\");\n", "/* -*- Mode: Javascript; indent-tabs-mode:nil; js-indent-level: 2 -*- */\n/* vim: set ts=2 et sw=2 tw=80: */\n\n/*************************************************************\n *\n *  MathJax/extensions/toMathML.js\n *  \n *  Implements a toMathML() method for the mml Element Jax that returns\n *  a MathML string from a given math expression.\n *\n *  ---------------------------------------------------------------------\n *  \n *  Copyright (c) 2010-2018 The MathJax Consortium\n * \n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\nMathJax.Hub.Register.LoadHook(\"[MathJax]/jax/element/mml/jax.js\",function () {\n  var VERSION = \"2.7.3\";\n  \n  var MML = MathJax.ElementJax.mml,\n      SETTINGS = MathJax.Hub.config.menuSettings;\n  \n  MML.mbase.Augment({\n\n    toMathML: function (space) {\n      var inferred = (this.inferred && this.parent.inferRow);\n      if (space == null) {space = \"\"}\n      var tag = this.type, attr = this.toMathMLattributes();\n      if (tag === \"mspace\") {return space + \"<\"+tag+attr+\" />\"}\n      var data = [], SPACE = (this.isToken ? \"\" : space+(inferred ? \"\" : \"  \"));\n      for (var i = 0, m = this.data.length; i < m; i++) {\n        if (this.data[i]) {data.push(this.data[i].toMathML(SPACE))}\n          else if (!this.isToken && !this.isChars) {data.push(SPACE+\"<mrow />\")}\n      }\n      if (this.isToken || this.isChars) {return space + \"<\"+tag+attr+\">\"+data.join(\"\")+\"</\"+tag+\">\"}\n      if (inferred) {return data.join(\"\\n\")}\n      if (data.length === 0 || (data.length === 1 && data[0] === \"\"))\n        {return space + \"<\"+tag+attr+\" />\"}\n      return space + \"<\"+tag+attr+\">\\n\"+data.join(\"\\n\")+\"\\n\"+ space +\"</\"+tag+\">\";\n    },\n\n    toMathMLattributes: function () {\n      var defaults = (this.type === \"mstyle\" ? MML.math.prototype.defaults : this.defaults);\n      var names = (this.attrNames||MML.copyAttributeNames),\n          skip = MML.skipAttributes, copy = MML.copyAttributes;\n      var attr = [];\n\n      if (this.type === \"math\" && (!this.attr || !('xmlns' in this.attr)))\n        {attr.push('xmlns=\"http://www.w3.org/1998/Math/MathML\"')}\n      if (!this.attrNames) {\n        for (var id in defaults) {if (!skip[id] && !copy[id] && defaults.hasOwnProperty(id)) {\n          if (this[id] != null && this[id] !== defaults[id]) {\n            if (this.Get(id,null,1) !== this[id])\n              attr.push(id+'=\"'+this.toMathMLattribute(this[id])+'\"');\n          }\n        }}\n      }\n      for (var i = 0, m = names.length; i < m; i++) {\n        if (copy[names[i]] === 1 && !defaults.hasOwnProperty(names[i])) continue;\n        value = (this.attr||{})[names[i]]; if (value == null) {value = this[names[i]]}\n        if (value != null) {attr.push(names[i]+'=\"'+this.toMathMLquote(value)+'\"')}\n      }\n      this.toMathMLclass(attr);\n      if (attr.length) {return \" \"+attr.join(\" \")} else {return \"\"}\n    },\n    toMathMLclass: function (attr) {\n      var CLASS = []; if (this[\"class\"]) {CLASS.push(this[\"class\"])}\n      if (this.isa(MML.TeXAtom) && SETTINGS.texHints) {\n        var TEXCLASS = [\"ORD\",\"OP\",\"BIN\",\"REL\",\"OPEN\",\"CLOSE\",\"PUNCT\",\"INNER\",\"VCENTER\"][this.texClass];\n        if (TEXCLASS) {\n          CLASS.push(\"MJX-TeXAtom-\"+TEXCLASS)\n          if (TEXCLASS === \"OP\" && !this.movablelimits) CLASS.push(\"MJX-fixedlimits\");\n        }\n      }\n      if (this.mathvariant && this.toMathMLvariants[this.mathvariant])\n        {CLASS.push(\"MJX\"+this.mathvariant)}\n      if (this.variantForm) {CLASS.push(\"MJX-variant\")}\n      if (CLASS.length) {attr.unshift('class=\"'+CLASS.join(\" \")+'\"')}\n    },\n    toMathMLattribute: function (value) {\n      if (typeof(value) === \"string\" &&\n          value.replace(/ /g,\"\").match(/^(([-+])?(\\d+(\\.\\d*)?|\\.\\d+))mu$/)) {\n        // FIXME:  should take scriptlevel into account\n        return (RegExp.$2||\"\")+((1/18)*RegExp.$3).toFixed(3).replace(/\\.?0+$/,\"\")+\"em\";\n      }\n      else if (this.toMathMLvariants[value]) {return this.toMathMLvariants[value]}\n      return this.toMathMLquote(value);\n    },\n    toMathMLvariants: {\n      \"-tex-caligraphic\":      MML.VARIANT.SCRIPT,\n      \"-tex-caligraphic-bold\": MML.VARIANT.BOLDSCRIPT,\n      \"-tex-oldstyle\":         MML.VARIANT.NORMAL,\n      \"-tex-oldstyle-bold\":    MML.VARIANT.BOLD,\n      \"-tex-mathit\":           MML.VARIANT.ITALIC\n    },\n    \n    toMathMLquote: function (string) {\n      string = String(string).split(\"\");\n      for (var i = 0, m = string.length; i < m; i++) {\n        var n = string[i].charCodeAt(0);\n        if (n <= 0xD7FF || 0xE000 <= n) {\n          // Code points U+0000 to U+D7FF and U+E000 to U+FFFF.\n          // They are directly represented by n.\n          if (n > 0x7E || (n < 0x20 && n !== 0x0A && n !== 0x0D && n !== 0x09)) {\n            string[i] = \"&#x\"+n.toString(16).toUpperCase()+\";\";\n          } else {\n            var c =\n              {'&':'&amp;', '<':'&lt;', '>':'&gt;', '\"':'&quot;'}[string[i]];\n            if (c) {string[i] = c}\n          }\n        } else if (i+1 < m) {\n          // Code points U+10000 to U+10FFFF.\n          // n is the lead surrogate, let's read the trail surrogate.\n          var trailSurrogate = string[i+1].charCodeAt(0);\n          var codePoint = (((n-0xD800)<<10)+(trailSurrogate-0xDC00)+0x10000);\n          string[i] = \"&#x\"+codePoint.toString(16).toUpperCase()+\";\";\n          string[i+1] = \"\";\n          i++;\n        } else {\n          // n is a lead surrogate without corresponding trail surrogate:\n          // remove that character.\n          string[i] = \"\";\n        }\n      }\n      return string.join(\"\");\n    }\n  });\n  \n  //\n  //  Override math.toMathML in order to add semantics tag\n  //  for the input format, if the user requests that in the\n  //  Show As menu.\n  //\n  MML.math.Augment({\n    toMathML: function (space,jax) {\n      var annotation;\n      if (space == null) {space = \"\"}\n      if (jax && jax.originalText && SETTINGS.semantics)\n        {annotation = MathJax.InputJax[jax.inputJax].annotationEncoding}\n      var nested = (this.data[0] && this.data[0].data.length > 1);\n      var tag = this.type, attr = this.toMathMLattributes();\n      var data = [], SPACE = space + (annotation ? \"  \" + (nested ? \"  \" : \"\") : \"\") + \"  \";\n      for (var i = 0, m = this.data.length; i < m; i++) {\n        if (this.data[i]) {data.push(this.data[i].toMathML(SPACE))}\n          else {data.push(SPACE+\"<mrow />\")}\n      }\n      if (data.length === 0 || (data.length === 1 && data[0] === \"\")) {\n        if (!annotation) {return \"<\"+tag+attr+\" />\"}\n        data.push(SPACE+\"<mrow />\");\n      }\n      if (annotation) {\n        if (nested) {data.unshift(space+\"    <mrow>\"); data.push(space+\"    </mrow>\")}\n        data.unshift(space+\"  <semantics>\");\n        var xmlEscapedTex = jax.originalText.replace(/[&<>]/g, function(item) {\n            return { '>': '&gt;', '<': '&lt;','&': '&amp;' }[item]\n        });\n        data.push(space+'    <annotation encoding=\"'+annotation+'\">'+xmlEscapedTex+\"</annotation>\");\n        data.push(space+\"  </semantics>\");\n      }\n      return space+\"<\"+tag+attr+\">\\n\"+data.join(\"\\n\")+\"\\n\"+space+\"</\"+tag+\">\";\n    }\n  });\n  \n  MML.msubsup.Augment({\n    toMathML: function (space) {\n      var tag = this.type;\n      if (this.data[this.sup] == null) {tag = \"msub\"}\n      if (this.data[this.sub] == null) {tag = \"msup\"}\n      var attr = this.toMathMLattributes();\n      delete this.data[0].inferred;\n      var data = [];\n      for (var i = 0, m = this.data.length; i < m; i++)\n        {if (this.data[i]) {data.push(this.data[i].toMathML(space+\"  \"))}}\n      return space + \"<\"+tag+attr+\">\\n\" + data.join(\"\\n\") + \"\\n\" + space + \"</\"+tag+\">\";\n    }\n  });\n  \n  MML.munderover.Augment({\n    toMathML: function (space) {\n      var tag = this.type;\n      var base = this.data[this.base];\n      if (base && base.isa(MML.TeXAtom) && base.movablelimits && !base.Get(\"displaystyle\")) {\n        type = \"msubsup\";\n        if (this.data[this.under] == null) {tag = \"msup\"}\n        if (this.data[this.over] == null)  {tag = \"msub\"}\n      } else {\n        if (this.data[this.under] == null) {tag = \"mover\"}\n        if (this.data[this.over] == null)  {tag = \"munder\"}\n      }\n      var attr = this.toMathMLattributes();\n      delete this.data[0].inferred;\n      var data = [];\n      for (var i = 0, m = this.data.length; i < m; i++)\n        {if (this.data[i]) {data.push(this.data[i].toMathML(space+\"  \"))}}\n      return space + \"<\"+tag+attr+\">\\n\" + data.join(\"\\n\") + \"\\n\" + space + \"</\"+tag+\">\";\n    }\n  });\n  \n  MML.TeXAtom.Augment({\n    toMathML: function (space) {\n      // FIXME:  Handle spacing using mpadded?\n      var attr = this.toMathMLattributes();\n      if (!attr && this.data[0].data.length === 1) {return space.substr(2) + this.data[0].toMathML(space)}\n      return space+\"<mrow\"+attr+\">\\n\" + this.data[0].toMathML(space+\"  \")+\"\\n\"+space+\"</mrow>\";\n    }\n  });\n  \n  MML.chars.Augment({\n    toMathML: function (space) {return (space||\"\") + this.toMathMLquote(this.toString())}\n  });\n  \n  MML.entity.Augment({\n    toMathML: function (space) {return (space||\"\") + \"&\"+this.data[0]+\";<!-- \"+this.toString()+\" -->\"}\n  });\n  \n  MML.xml.Augment({\n   toMathML: function (space) {return (space||\"\") + this.toString()}\n  });\n  \n  MathJax.Hub.Register.StartupHook(\"TeX mathchoice Ready\",function () {\n    MML.TeXmathchoice.Augment({\n      toMathML: function (space) {return this.Core().toMathML(space)}\n    });\n  });\n  \n  MathJax.Hub.Startup.signal.Post(\"toMathML Ready\");\n  \n});\n\nMathJax.Ajax.loadComplete(\"[MathJax]/extensions/toMathML.js\");\n"], "fixing_code": ["/* -*- Mode: Javascript; indent-tabs-mode:nil; js-indent-level: 2 -*- */\n/* vim: set ts=2 et sw=2 tw=80: */\n\n/*************************************************************\n *\n *  MathJax/extensions/TeX/unicode.js\n *  \n *  Implements the \\unicode extension to TeX to allow arbitrary unicode\n *  code points to be entered into the TeX file.  You can specify\n *  the height and depth of the character (the width is determined by\n *  the browser), and the default font from which to take the character.\n *  \n *  Examples:\n *      \\unicode{65}                        % the character 'A'\n *      \\unicode{x41}                       % the character 'A'\n *      \\unicode[.55,0.05]{x22D6}           % less-than with dot, with height .55 and depth 0.05\n *      \\unicode[.55,0.05][Geramond]{x22D6} % same taken from Geramond font\n *      \\unicode[Garamond]{x22D6}           % same, but with default height, depth of .8,.2\n *\n *  Once a size and font are provided for a given code point, they need\n *  not be specified again in subsequent \\unicode calls for that character.\n *  Note that a font list can be given, but Internet Explorer has a buggy\n *  implementation of font-family where it only looks in the first\n *  available font and if the glyph is not in that, it does not look at\n *  later fonts, but goes directly to the default font as set in the\n *  Internet-Options/Font panel.  For this reason, the default font list is\n *  \"STIXGeneral,'Arial Unicode MS'\", so if the user has STIX fonts, the\n *  symbol will be taken from that (almost all the symbols are in\n *  STIXGeneral), otherwise Arial Unicode MS is tried.\n *  \n *  To configure the default font list, use\n *  \n *      MathJax.Hub.Config({\n *        TeX: {\n *          unicode: {\n *            fonts: \"STIXGeneral,'Arial Unicode MS'\"\n *          }\n *        }\n *      });\n *\n *  The result of \\unicode will have TeX class ORD (i.e., it will act like a\n *  variable).  Use \\mathbin, \\mathrel, etc, to specify a different class.\n *  \n *  ---------------------------------------------------------------------\n *  \n *  Copyright (c) 2009-2018 The MathJax Consortium\n * \n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n//\n//  The configuration defaults, augmented by the user settings\n//  \nMathJax.Extension[\"TeX/unicode\"] = {\n  version: \"2.7.3\",\n  unicode: {},\n  config: MathJax.Hub.CombineConfig(\"TeX.unicode\",{\n    fonts: \"STIXGeneral,'Arial Unicode MS'\"\n  })\n};\n  \nMathJax.Hub.Register.StartupHook(\"TeX Jax Ready\",function () {\n  var TEX = MathJax.InputJax.TeX;\n  var MML = MathJax.ElementJax.mml;\n  var UNICODE = MathJax.Extension[\"TeX/unicode\"].unicode;\n  \n  //\n  //  Add \\unicode macro\n  //\n  TEX.Definitions.Add({macros: {unicode: 'Unicode'}},null,true);\n  //\n  //  Implementation of \\unicode in parser\n  //\n  TEX.Parse.Augment({\n    Unicode: function(name) {\n      var HD = this.GetBrackets(name), font;\n      if (HD) {\n        if (HD.replace(/ /g,\"\").match(/^(\\d+(\\.\\d*)?|\\.\\d+),(\\d+(\\.\\d*)?|\\.\\d+)$/))\n          {HD = HD.replace(/ /g,\"\").split(/,/); font = this.GetBrackets(name)}\n            else {font = HD; HD = null}\n      }\n      var n = this.trimSpaces(this.GetArgument(name)).replace(/^0x/,\"x\");\n      if (!n.match(/^(x[0-9A-Fa-f]+|[0-9]+)$/)) {\n        TEX.Error([\"BadUnicode\",\"Argument to \\\\unicode must be a number\"]);\n      }\n      var N = parseInt(n.match(/^x/) ? \"0\"+n : n);\n      if (!UNICODE[N]) {UNICODE[N] = [800,200,font,N]}\n      else if (!font) {font = UNICODE[N][2]}\n      if (HD) {\n        UNICODE[N][0] = Math.floor(HD[0]*1000);\n        UNICODE[N][1] = Math.floor(HD[1]*1000);\n      }\n      var variant = this.stack.env.font, def = {};\n      if (font) {\n        UNICODE[N][2] = def.fontfamily = font.replace(/\"/g,\"'\");\n        if (variant) {\n          if (variant.match(/bold/)) {def.fontweight = \"bold\"}\n          if (variant.match(/italic|-mathit/)) {def.fontstyle = \"italic\"}\n        }\n      } else if (variant) {def.mathvariant = variant}\n      def.unicode = [].concat(UNICODE[N]); // make a copy\n      this.Push(MML.mtext(MML.entity(\"#\"+n)).With(def));\n    }\n  });\n\n  MathJax.Hub.Startup.signal.Post(\"TeX unicode Ready\");\n  \n});\n    \nMathJax.Hub.Register.StartupHook(\"HTML-CSS Jax Ready\",function () {\n  var MML = MathJax.ElementJax.mml;\n  var FONTS = MathJax.Extension[\"TeX/unicode\"].config.fonts;\n\n  //\n  //  Override getVariant to make one that includes the font and size\n  //\n  var GETVARIANT = MML.mbase.prototype.HTMLgetVariant;\n  MML.mbase.Augment({\n    HTMLgetVariant: function () {\n      var variant = GETVARIANT.apply(this,arguments);\n      if (variant.unicode) {delete variant.unicode; delete variant.FONTS} // clear font cache in case of restart\n      if (!this.unicode) {return variant}\n      variant.unicode = true;\n      if (!variant.defaultFont) {\n        variant = MathJax.Hub.Insert({},variant); // make a copy\n        variant.defaultFont = {family:FONTS};\n      }\n      var family = this.unicode[2]; if (family) {family += \",\"+FONTS} else {family = FONTS}\n      variant.defaultFont[this.unicode[3]] = [\n        this.unicode[0],this.unicode[1],500,0,500,\n        {isUnknown:true, isUnicode:true, font:family}\n      ];\n      return variant;\n    }\n  });\n});\n\nMathJax.Hub.Register.StartupHook(\"SVG Jax Ready\",function () {\n  var MML = MathJax.ElementJax.mml;\n  var FONTS = MathJax.Extension[\"TeX/unicode\"].config.fonts;\n\n  //\n  //  Override getVariant to make one that includes the font and size\n  //\n  var GETVARIANT = MML.mbase.prototype.SVGgetVariant;\n  MML.mbase.Augment({\n    SVGgetVariant: function () {\n      var variant = GETVARIANT.call(this);\n      if (variant.unicode) {delete variant.unicode; delete variant.FONTS} // clear font cache in case of restart\n      if (!this.unicode) {return variant}\n      variant.unicode = true;\n      if (!variant.forceFamily) {variant = MathJax.Hub.Insert({},variant)} // make a copy\n      variant.defaultFamily = FONTS; variant.noRemap = true;\n      variant.h = this.unicode[0]; variant.d = this.unicode[1];\n      return variant;\n    }\n  });\n});\n\nMathJax.Ajax.loadComplete(\"[MathJax]/extensions/TeX/unicode.js\");\n", "/* -*- Mode: Javascript; indent-tabs-mode:nil; js-indent-level: 2 -*- */\n/* vim: set ts=2 et sw=2 tw=80: */\n\n/*************************************************************\n *\n *  MathJax/extensions/toMathML.js\n *  \n *  Implements a toMathML() method for the mml Element Jax that returns\n *  a MathML string from a given math expression.\n *\n *  ---------------------------------------------------------------------\n *  \n *  Copyright (c) 2010-2018 The MathJax Consortium\n * \n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\nMathJax.Hub.Register.LoadHook(\"[MathJax]/jax/element/mml/jax.js\",function () {\n  var VERSION = \"2.7.3\";\n  \n  var MML = MathJax.ElementJax.mml,\n      SETTINGS = MathJax.Hub.config.menuSettings;\n  \n  MML.mbase.Augment({\n\n    toMathML: function (space) {\n      var inferred = (this.inferred && this.parent.inferRow);\n      if (space == null) {space = \"\"}\n      var tag = this.type, attr = this.toMathMLattributes();\n      if (tag === \"mspace\") {return space + \"<\"+tag+attr+\" />\"}\n      var data = [], SPACE = (this.isToken ? \"\" : space+(inferred ? \"\" : \"  \"));\n      for (var i = 0, m = this.data.length; i < m; i++) {\n        if (this.data[i]) {data.push(this.data[i].toMathML(SPACE))}\n          else if (!this.isToken && !this.isChars) {data.push(SPACE+\"<mrow />\")}\n      }\n      if (this.isToken || this.isChars) {return space + \"<\"+tag+attr+\">\"+data.join(\"\")+\"</\"+tag+\">\"}\n      if (inferred) {return data.join(\"\\n\")}\n      if (data.length === 0 || (data.length === 1 && data[0] === \"\"))\n        {return space + \"<\"+tag+attr+\" />\"}\n      return space + \"<\"+tag+attr+\">\\n\"+data.join(\"\\n\")+\"\\n\"+ space +\"</\"+tag+\">\";\n    },\n\n    toMathMLattributes: function () {\n      var defaults = (this.type === \"mstyle\" ? MML.math.prototype.defaults : this.defaults);\n      var names = (this.attrNames||MML.copyAttributeNames),\n          skip = MML.skipAttributes, copy = MML.copyAttributes;\n      var attr = [];\n\n      if (this.type === \"math\" && (!this.attr || !('xmlns' in this.attr)))\n        {attr.push('xmlns=\"http://www.w3.org/1998/Math/MathML\"')}\n      if (!this.attrNames) {\n        for (var id in defaults) {if (!skip[id] && !copy[id] && defaults.hasOwnProperty(id)) {\n          if (this[id] != null && this[id] !== defaults[id]) {\n            if (this.Get(id,null,1) !== this[id])\n              attr.push(id+'=\"'+this.toMathMLattribute(this[id])+'\"');\n          }\n        }}\n      }\n      for (var i = 0, m = names.length; i < m; i++) {\n        if (copy[names[i]] === 1 && !defaults.hasOwnProperty(names[i])) continue;\n        value = (this.attr||{})[names[i]]; if (value == null) {value = this[names[i]]}\n        if (value != null) {attr.push(names[i]+'=\"'+this.toMathMLquote(value)+'\"')}\n      }\n      this.toMathMLclass(attr);\n      if (attr.length) {return \" \"+attr.join(\" \")} else {return \"\"}\n    },\n    toMathMLclass: function (attr) {\n      var CLASS = []; if (this[\"class\"]) {CLASS.push(this[\"class\"])}\n      if (this.isa(MML.TeXAtom) && SETTINGS.texHints) {\n        var TEXCLASS = [\"ORD\",\"OP\",\"BIN\",\"REL\",\"OPEN\",\"CLOSE\",\"PUNCT\",\"INNER\",\"VCENTER\"][this.texClass];\n        if (TEXCLASS) {\n          CLASS.push(\"MJX-TeXAtom-\"+TEXCLASS)\n          if (TEXCLASS === \"OP\" && !this.movablelimits) CLASS.push(\"MJX-fixedlimits\");\n        }\n      }\n      if (this.mathvariant && this.toMathMLvariants[this.mathvariant])\n        {CLASS.push(\"MJX\"+this.mathvariant)}\n      if (this.variantForm) {CLASS.push(\"MJX-variant\")}\n      if (CLASS.length) {attr.unshift('class=\"'+this.toMathMLquote(CLASS.join(\" \"))+'\"')}\n    },\n    toMathMLattribute: function (value) {\n      if (typeof(value) === \"string\" &&\n          value.replace(/ /g,\"\").match(/^(([-+])?(\\d+(\\.\\d*)?|\\.\\d+))mu$/)) {\n        // FIXME:  should take scriptlevel into account\n        return (RegExp.$2||\"\")+((1/18)*RegExp.$3).toFixed(3).replace(/\\.?0+$/,\"\")+\"em\";\n      }\n      else if (this.toMathMLvariants[value]) {return this.toMathMLvariants[value]}\n      return this.toMathMLquote(value);\n    },\n    toMathMLvariants: {\n      \"-tex-caligraphic\":      MML.VARIANT.SCRIPT,\n      \"-tex-caligraphic-bold\": MML.VARIANT.BOLDSCRIPT,\n      \"-tex-oldstyle\":         MML.VARIANT.NORMAL,\n      \"-tex-oldstyle-bold\":    MML.VARIANT.BOLD,\n      \"-tex-mathit\":           MML.VARIANT.ITALIC\n    },\n    \n    toMathMLquote: function (string) {\n      string = String(string).split(\"\");\n      for (var i = 0, m = string.length; i < m; i++) {\n        var n = string[i].charCodeAt(0);\n        if (n <= 0xD7FF || 0xE000 <= n) {\n          // Code points U+0000 to U+D7FF and U+E000 to U+FFFF.\n          // They are directly represented by n.\n          if (n > 0x7E || (n < 0x20 && n !== 0x0A && n !== 0x0D && n !== 0x09)) {\n            string[i] = \"&#x\"+n.toString(16).toUpperCase()+\";\";\n          } else {\n            var c =\n              {'&':'&amp;', '<':'&lt;', '>':'&gt;', '\"':'&quot;'}[string[i]];\n            if (c) {string[i] = c}\n          }\n        } else if (i+1 < m) {\n          // Code points U+10000 to U+10FFFF.\n          // n is the lead surrogate, let's read the trail surrogate.\n          var trailSurrogate = string[i+1].charCodeAt(0);\n          var codePoint = (((n-0xD800)<<10)+(trailSurrogate-0xDC00)+0x10000);\n          string[i] = \"&#x\"+codePoint.toString(16).toUpperCase()+\";\";\n          string[i+1] = \"\";\n          i++;\n        } else {\n          // n is a lead surrogate without corresponding trail surrogate:\n          // remove that character.\n          string[i] = \"\";\n        }\n      }\n      return string.join(\"\");\n    }\n  });\n  \n  //\n  //  Override math.toMathML in order to add semantics tag\n  //  for the input format, if the user requests that in the\n  //  Show As menu.\n  //\n  MML.math.Augment({\n    toMathML: function (space,jax) {\n      var annotation;\n      if (space == null) {space = \"\"}\n      if (jax && jax.originalText && SETTINGS.semantics)\n        {annotation = MathJax.InputJax[jax.inputJax].annotationEncoding}\n      var nested = (this.data[0] && this.data[0].data.length > 1);\n      var tag = this.type, attr = this.toMathMLattributes();\n      var data = [], SPACE = space + (annotation ? \"  \" + (nested ? \"  \" : \"\") : \"\") + \"  \";\n      for (var i = 0, m = this.data.length; i < m; i++) {\n        if (this.data[i]) {data.push(this.data[i].toMathML(SPACE))}\n          else {data.push(SPACE+\"<mrow />\")}\n      }\n      if (data.length === 0 || (data.length === 1 && data[0] === \"\")) {\n        if (!annotation) {return \"<\"+tag+attr+\" />\"}\n        data.push(SPACE+\"<mrow />\");\n      }\n      if (annotation) {\n        if (nested) {data.unshift(space+\"    <mrow>\"); data.push(space+\"    </mrow>\")}\n        data.unshift(space+\"  <semantics>\");\n        var xmlEscapedTex = jax.originalText.replace(/[&<>]/g, function(item) {\n            return { '>': '&gt;', '<': '&lt;','&': '&amp;' }[item]\n        });\n        data.push(space+'    <annotation encoding=\"'+this.toMathMLquote(annotation)+'\">'+xmlEscapedTex+\"</annotation>\");\n        data.push(space+\"  </semantics>\");\n      }\n      return space+\"<\"+tag+attr+\">\\n\"+data.join(\"\\n\")+\"\\n\"+space+\"</\"+tag+\">\";\n    }\n  });\n  \n  MML.msubsup.Augment({\n    toMathML: function (space) {\n      var tag = this.type;\n      if (this.data[this.sup] == null) {tag = \"msub\"}\n      if (this.data[this.sub] == null) {tag = \"msup\"}\n      var attr = this.toMathMLattributes();\n      delete this.data[0].inferred;\n      var data = [];\n      for (var i = 0, m = this.data.length; i < m; i++)\n        {if (this.data[i]) {data.push(this.data[i].toMathML(space+\"  \"))}}\n      return space + \"<\"+tag+attr+\">\\n\" + data.join(\"\\n\") + \"\\n\" + space + \"</\"+tag+\">\";\n    }\n  });\n  \n  MML.munderover.Augment({\n    toMathML: function (space) {\n      var tag = this.type;\n      var base = this.data[this.base];\n      if (base && base.isa(MML.TeXAtom) && base.movablelimits && !base.Get(\"displaystyle\")) {\n        type = \"msubsup\";\n        if (this.data[this.under] == null) {tag = \"msup\"}\n        if (this.data[this.over] == null)  {tag = \"msub\"}\n      } else {\n        if (this.data[this.under] == null) {tag = \"mover\"}\n        if (this.data[this.over] == null)  {tag = \"munder\"}\n      }\n      var attr = this.toMathMLattributes();\n      delete this.data[0].inferred;\n      var data = [];\n      for (var i = 0, m = this.data.length; i < m; i++)\n        {if (this.data[i]) {data.push(this.data[i].toMathML(space+\"  \"))}}\n      return space + \"<\"+tag+attr+\">\\n\" + data.join(\"\\n\") + \"\\n\" + space + \"</\"+tag+\">\";\n    }\n  });\n  \n  MML.TeXAtom.Augment({\n    toMathML: function (space) {\n      // FIXME:  Handle spacing using mpadded?\n      var attr = this.toMathMLattributes();\n      if (!attr && this.data[0].data.length === 1) {return space.substr(2) + this.data[0].toMathML(space)}\n      return space+\"<mrow\"+attr+\">\\n\" + this.data[0].toMathML(space+\"  \")+\"\\n\"+space+\"</mrow>\";\n    }\n  });\n  \n  MML.chars.Augment({\n    toMathML: function (space) {return (space||\"\") + this.toMathMLquote(this.toString())}\n  });\n  \n  MML.entity.Augment({\n    toMathML: function (space) {return (space||\"\") + \"&\"+this.toMathMLquote(this.data[0])+\";<!-- \"+this.toString()+\" -->\"}\n  });\n  \n  MML.xml.Augment({\n   toMathML: function (space) {return (space||\"\") + this.toString()}\n  });\n  \n  MathJax.Hub.Register.StartupHook(\"TeX mathchoice Ready\",function () {\n    MML.TeXmathchoice.Augment({\n      toMathML: function (space) {return this.Core().toMathML(space)}\n    });\n  });\n  \n  MathJax.Hub.Startup.signal.Post(\"toMathML Ready\");\n  \n});\n\nMathJax.Ajax.loadComplete(\"[MathJax]/extensions/toMathML.js\");\n"], "filenames": ["unpacked/extensions/TeX/unicode.js", "unpacked/extensions/toMathML.js"], "buggy_code_start_loc": [92, 89], "buggy_code_end_loc": [105, 225], "fixing_code_start_loc": [92, 89], "fixing_code_end_loc": [108, 225], "type": "CWE-79", "message": "MathJax version prior to version 2.7.4 contains a Cross Site Scripting (XSS) vulnerability in the \\unicode{} macro that can result in Potentially untrusted Javascript running within a web browser. This attack appear to be exploitable via The victim must view a page where untrusted content is processed using Mathjax. This vulnerability appears to have been fixed in 2.7.4 and later.", "other": {"cve": {"id": "CVE-2018-1999024", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-23T16:29:00.320", "lastModified": "2018-09-19T16:30:38.843", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MathJax version prior to version 2.7.4 contains a Cross Site Scripting (XSS) vulnerability in the \\unicode{} macro that can result in Potentially untrusted Javascript running within a web browser. This attack appear to be exploitable via The victim must view a page where untrusted content is processed using Mathjax. This vulnerability appears to have been fixed in 2.7.4 and later."}, {"lang": "es", "value": "MathJax en versiones anteriores a la 2.7.4 contiene una vulnerabilidad Cross-Site Scripting (XSS) en la macro \\unicode{} que puede resultar en la ejecuci\u00f3n de JavaScript potencialmente no fiable en un navegador web. Este ataque parece ser explotable si la v\u00edctima visualiza una p\u00e1gina en la que se procesa contenido no fiable mediante Mathjax. La vulnerabilidad parece haber sido solucionada en las versiones 2.7.4 y siguientes."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mathjax:mathjax:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.4", "matchCriteriaId": "6CCD874E-0F42-48FD-A72C-7DA0A8837CAC"}]}]}], "references": [{"url": "https://blog.bentkowski.info/2018/06/xss-in-google-colaboratory-csp-bypass.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/mathjax/MathJax/commit/a55da396c18cafb767a26aa9ad96f6f4199852f1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mathjax/MathJax/commit/a55da396c18cafb767a26aa9ad96f6f4199852f1"}}