{"buggy_code": ["package org.bouncycastle.jce.provider;\n\nimport org.bouncycastle.asn1.ASN1InputStream;\nimport org.bouncycastle.asn1.x509.CertificatePair;\nimport org.bouncycastle.jce.X509LDAPCertStoreParameters;\n\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.*;\nimport javax.security.auth.x500.X500Principal;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.cert.*;\nimport java.util.*;\n\n/**\n * \n * This is a general purpose implementation to get X.509 certificates and CRLs\n * from a LDAP location.\n * <p>\n * At first a search is performed in the ldap*AttributeNames of the\n * {@link org.bouncycastle.jce.X509LDAPCertStoreParameters} with the given\n * information of the subject (for all kind of certificates) or issuer (for\n * CRLs), respectively, if a X509CertSelector is given with that details. For\n * CRLs, CA certificates and cross certificates a coarse search is made only for\n * entries with that content to get more possibly matching results.\n */\npublic class X509LDAPCertStoreSpi\n    extends CertStoreSpi\n{\n    private X509LDAPCertStoreParameters params;\n\n    public X509LDAPCertStoreSpi(CertStoreParameters params)\n        throws InvalidAlgorithmParameterException\n    {\n        super(params);\n\n        if (!(params instanceof X509LDAPCertStoreParameters))\n        {\n            throw new InvalidAlgorithmParameterException(\n                X509LDAPCertStoreSpi.class.getName() + \": parameter must be a \" + X509LDAPCertStoreParameters.class.getName() + \" object\\n\"\n                    + params.toString());\n        }\n\n        this.params = (X509LDAPCertStoreParameters)params;\n    }\n\n    /**\n     * Initial Context Factory.\n     */\n    private static String LDAP_PROVIDER = \"com.sun.jndi.ldap.LdapCtxFactory\";\n\n    /**\n     * Processing referrals..\n     */\n    private static String REFERRALS_IGNORE = \"ignore\";\n\n    /**\n     * Security level to be used for LDAP connections.\n     */\n    private static final String SEARCH_SECURITY_LEVEL = \"none\";\n\n    /**\n     * Package Prefix for loading URL context factories.\n     */\n    private static final String URL_CONTEXT_PREFIX = \"com.sun.jndi.url\";\n\n    private DirContext connectLDAP() throws NamingException\n    {\n        Properties props = new Properties();\n        props.setProperty(Context.INITIAL_CONTEXT_FACTORY, LDAP_PROVIDER);\n        props.setProperty(Context.BATCHSIZE, \"0\");\n\n        props.setProperty(Context.PROVIDER_URL, params.getLdapURL());\n        props.setProperty(Context.URL_PKG_PREFIXES, URL_CONTEXT_PREFIX);\n        props.setProperty(Context.REFERRAL, REFERRALS_IGNORE);\n        props.setProperty(Context.SECURITY_AUTHENTICATION,\n            SEARCH_SECURITY_LEVEL);\n\n        DirContext ctx = new InitialDirContext(props);\n        return ctx;\n    }\n\n    private String parseDN(String subject, String subjectAttributeName)\n    {\n        String temp = subject;\n        int begin = temp.toLowerCase().indexOf(\n            subjectAttributeName.toLowerCase());\n        temp = temp.substring(begin + subjectAttributeName.length());\n        int end = temp.indexOf(',');\n        if (end == -1)\n        {\n            end = temp.length();\n        }\n        while (temp.charAt(end - 1) == '\\\\')\n        {\n            end = temp.indexOf(',', end + 1);\n            if (end == -1)\n            {\n                end = temp.length();\n            }\n        }\n        temp = temp.substring(0, end);\n        begin = temp.indexOf('=');\n        temp = temp.substring(begin + 1);\n        if (temp.charAt(0) == ' ')\n        {\n            temp = temp.substring(1);\n        }\n        if (temp.startsWith(\"\\\"\"))\n        {\n            temp = temp.substring(1);\n        }\n        if (temp.endsWith(\"\\\"\"))\n        {\n            temp = temp.substring(0, temp.length() - 1);\n        }\n        return temp;\n    }\n\n    public Collection engineGetCertificates(CertSelector selector)\n        throws CertStoreException\n    {\n        if (!(selector instanceof X509CertSelector))\n        {\n            throw new CertStoreException(\"selector is not a X509CertSelector\");\n        }\n        X509CertSelector xselector = (X509CertSelector)selector;\n\n        Set certSet = new HashSet();\n\n        Set set = getEndCertificates(xselector);\n        set.addAll(getCACertificates(xselector));\n        set.addAll(getCrossCertificates(xselector));\n\n        Iterator it = set.iterator();\n\n        try\n        {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\",\n                BouncyCastleProvider.PROVIDER_NAME);\n            while (it.hasNext())\n            {\n                byte[] bytes = (byte[])it.next();\n                if (bytes == null || bytes.length == 0)\n                {\n                    continue;\n                }\n\n                List bytesList = new ArrayList();\n                bytesList.add(bytes);\n\n                try\n                {\n                    CertificatePair pair = CertificatePair\n                        .getInstance(new ASN1InputStream(bytes)\n                            .readObject());\n                    bytesList.clear();\n                    if (pair.getForward() != null)\n                    {\n                        bytesList.add(pair.getForward().getEncoded());\n                    }\n                    if (pair.getReverse() != null)\n                    {\n                        bytesList.add(pair.getReverse().getEncoded());\n                    }\n                }\n                catch (IOException e)\n                {\n\n                }\n                catch (IllegalArgumentException e)\n                {\n\n                }\n                for (Iterator it2 = bytesList.iterator(); it2.hasNext();)\n                {\n                    ByteArrayInputStream bIn = new ByteArrayInputStream(\n                        (byte[])it2.next());\n                    try\n                    {\n                        Certificate cert = cf.generateCertificate(bIn);\n                        // System.out.println(((X509Certificate)\n                        // cert).getSubjectX500Principal());\n                        if (xselector.match(cert))\n                        {\n                            certSet.add(cert);\n                        }\n                    }\n                    catch (Exception e)\n                    {\n\n                    }\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            throw new CertStoreException(\n                \"certificate cannot be constructed from LDAP result: \" + e);\n        }\n\n        return certSet;\n    }\n\n    private Set certSubjectSerialSearch(X509CertSelector xselector,\n                                        String[] attrs, String attrName, String subjectAttributeName)\n        throws CertStoreException\n    {\n        Set set = new HashSet();\n        try\n        {\n            if (xselector.getSubjectAsBytes() != null\n                || xselector.getSubjectAsString() != null\n                || xselector.getCertificate() != null)\n            {\n                String subject = null;\n                String serial = null;\n                if (xselector.getCertificate() != null)\n                {\n                    subject = xselector.getCertificate()\n                        .getSubjectX500Principal().getName(\"RFC1779\");\n                    serial = xselector.getCertificate().getSerialNumber()\n                        .toString();\n                }\n                else\n                {\n                    if (xselector.getSubjectAsBytes() != null)\n                    {\n                        subject = new X500Principal(xselector\n                            .getSubjectAsBytes()).getName(\"RFC1779\");\n                    }\n                    else\n                    {\n                        subject = xselector.getSubjectAsString();\n                    }\n                }\n                String attrValue = parseDN(subject, subjectAttributeName);\n                set.addAll(search(attrName, \"*\" + attrValue + \"*\", attrs));\n                if (serial != null\n                    && params.getSearchForSerialNumberIn() != null)\n                {\n                    attrValue = serial;\n                    attrName = params.getSearchForSerialNumberIn();\n                    set.addAll(search(attrName, \"*\" + attrValue + \"*\", attrs));\n                }\n            }\n            else\n            {\n                set.addAll(search(attrName, \"*\", attrs));\n            }\n        }\n        catch (IOException e)\n        {\n            throw new CertStoreException(\"exception processing selector: \" + e);\n        }\n\n        return set;\n    }\n\n    private Set getEndCertificates(X509CertSelector xselector)\n        throws CertStoreException\n    {\n        String[] attrs = {params.getUserCertificateAttribute()};\n        String attrName = params.getLdapUserCertificateAttributeName();\n        String subjectAttributeName = params.getUserCertificateSubjectAttributeName();\n\n        Set set = certSubjectSerialSearch(xselector, attrs, attrName,\n            subjectAttributeName);\n        return set;\n    }\n\n    private Set getCACertificates(X509CertSelector xselector)\n        throws CertStoreException\n    {\n        String[] attrs = {params.getCACertificateAttribute()};\n        String attrName = params.getLdapCACertificateAttributeName();\n        String subjectAttributeName = params\n            .getCACertificateSubjectAttributeName();\n        Set set = certSubjectSerialSearch(xselector, attrs, attrName,\n            subjectAttributeName);\n\n        if (set.isEmpty())\n        {\n            set.addAll(search(null, \"*\", attrs));\n        }\n\n        return set;\n    }\n\n    private Set getCrossCertificates(X509CertSelector xselector)\n        throws CertStoreException\n    {\n        String[] attrs = {params.getCrossCertificateAttribute()};\n        String attrName = params.getLdapCrossCertificateAttributeName();\n        String subjectAttributeName = params\n            .getCrossCertificateSubjectAttributeName();\n        Set set = certSubjectSerialSearch(xselector, attrs, attrName,\n            subjectAttributeName);\n\n        if (set.isEmpty())\n        {\n            set.addAll(search(null, \"*\", attrs));\n        }\n\n        return set;\n    }\n\n    public Collection engineGetCRLs(CRLSelector selector)\n        throws CertStoreException\n    {\n        String[] attrs = {params.getCertificateRevocationListAttribute()};\n        if (!(selector instanceof X509CRLSelector))\n        {\n            throw new CertStoreException(\"selector is not a X509CRLSelector\");\n        }\n        X509CRLSelector xselector = (X509CRLSelector)selector;\n\n        Set crlSet = new HashSet();\n\n        String attrName = params.getLdapCertificateRevocationListAttributeName();\n        Set set = new HashSet();\n\n        if (xselector.getIssuerNames() != null)\n        {\n            for (Iterator it = xselector.getIssuerNames().iterator(); it\n                .hasNext();)\n            {\n                Object o = it.next();\n                String attrValue = null;\n                if (o instanceof String)\n                {\n                    String issuerAttributeName = params\n                        .getCertificateRevocationListIssuerAttributeName();\n                    attrValue = parseDN((String)o, issuerAttributeName);\n                }\n                else\n                {\n                    String issuerAttributeName = params\n                        .getCertificateRevocationListIssuerAttributeName();\n                    attrValue = parseDN(new X500Principal((byte[])o)\n                        .getName(\"RFC1779\"), issuerAttributeName);\n                }\n                set.addAll(search(attrName, \"*\" + attrValue + \"*\", attrs));\n            }\n        }\n        else\n        {\n            set.addAll(search(attrName, \"*\", attrs));\n        }\n        set.addAll(search(null, \"*\", attrs));\n        Iterator it = set.iterator();\n\n        try\n        {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\",\n                BouncyCastleProvider.PROVIDER_NAME);\n            while (it.hasNext())\n            {\n                CRL crl = cf.generateCRL(new ByteArrayInputStream((byte[])it\n                    .next()));\n                if (xselector.match(crl))\n                {\n                    crlSet.add(crl);\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            throw new CertStoreException(\n                \"CRL cannot be constructed from LDAP result \" + e);\n        }\n\n        return crlSet;\n    }\n\n    /**\n     * Returns a Set of byte arrays with the certificate or CRL encodings.\n     *\n     * @param attributeName  The attribute name to look for in the LDAP.\n     * @param attributeValue The value the attribute name must have.\n     * @param attrs          The attributes in the LDAP which hold the certificate,\n     *                       certificate pair or CRL in a found entry.\n     * @return Set of byte arrays with the certificate encodings.\n     */\n    private Set search(String attributeName, String attributeValue,\n                       String[] attrs) throws CertStoreException\n    {\n        String filter = attributeName + \"=\" + attributeValue;\n        if (attributeName == null)\n        {\n            filter = null;\n        }\n        DirContext ctx = null;\n        Set set = new HashSet();\n        try\n        {\n\n            ctx = connectLDAP();\n\n            SearchControls constraints = new SearchControls();\n            constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);\n            constraints.setCountLimit(0);\n            for (int i = 0; i < attrs.length; i++)\n            {\n                String temp[] = new String[1];\n                temp[0] = attrs[i];\n                constraints.setReturningAttributes(temp);\n\n                String filter2 = \"(&(\" + filter + \")(\" + temp[0] + \"=*))\";\n                if (filter == null)\n                {\n                    filter2 = \"(\" + temp[0] + \"=*)\";\n                }\n                NamingEnumeration results = ctx.search(params.getBaseDN(),\n                    filter2, constraints);\n                while (results.hasMoreElements())\n                {\n                    SearchResult sr = (SearchResult)results.next();\n                    // should only be one attribute in the attribute set with\n                    // one\n                    // attribute value as byte array\n                    NamingEnumeration enumeration = ((Attribute)(sr\n                        .getAttributes().getAll().next())).getAll();\n                    while (enumeration.hasMore())\n                    {\n                        Object o = enumeration.next();\n                        set.add(o);\n                    }\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            throw new CertStoreException(\n                \"Error getting results from LDAP directory \" + e);\n\n        }\n        finally\n        {\n            try\n            {\n                if (null != ctx)\n                {\n                    ctx.close();\n                }\n            }\n            catch (Exception e)\n            {\n            }\n        }\n        return set;\n    }\n\n}\n"], "fixing_code": ["package org.bouncycastle.jce.provider;\n\nimport org.bouncycastle.asn1.ASN1InputStream;\nimport org.bouncycastle.asn1.x509.CertificatePair;\nimport org.bouncycastle.jce.X509LDAPCertStoreParameters;\n\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.*;\nimport javax.security.auth.x500.X500Principal;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.cert.*;\nimport java.util.*;\n\n/**\n * \n * This is a general purpose implementation to get X.509 certificates and CRLs\n * from a LDAP location.\n * <p>\n * At first a search is performed in the ldap*AttributeNames of the\n * {@link org.bouncycastle.jce.X509LDAPCertStoreParameters} with the given\n * information of the subject (for all kind of certificates) or issuer (for\n * CRLs), respectively, if a X509CertSelector is given with that details. For\n * CRLs, CA certificates and cross certificates a coarse search is made only for\n * entries with that content to get more possibly matching results.\n */\npublic class X509LDAPCertStoreSpi\n    extends CertStoreSpi\n{\n    private X509LDAPCertStoreParameters params;\n\n    public X509LDAPCertStoreSpi(CertStoreParameters params)\n        throws InvalidAlgorithmParameterException\n    {\n        super(params);\n\n        if (!(params instanceof X509LDAPCertStoreParameters))\n        {\n            throw new InvalidAlgorithmParameterException(\n                X509LDAPCertStoreSpi.class.getName() + \": parameter must be a \" + X509LDAPCertStoreParameters.class.getName() + \" object\\n\"\n                    + params.toString());\n        }\n\n        this.params = (X509LDAPCertStoreParameters)params;\n    }\n\n    /**\n     * Initial Context Factory.\n     */\n    private static String LDAP_PROVIDER = \"com.sun.jndi.ldap.LdapCtxFactory\";\n\n    /**\n     * Processing referrals..\n     */\n    private static String REFERRALS_IGNORE = \"ignore\";\n\n    /**\n     * Security level to be used for LDAP connections.\n     */\n    private static final String SEARCH_SECURITY_LEVEL = \"none\";\n\n    /**\n     * Package Prefix for loading URL context factories.\n     */\n    private static final String URL_CONTEXT_PREFIX = \"com.sun.jndi.url\";\n\n    private DirContext connectLDAP() throws NamingException\n    {\n        Properties props = new Properties();\n        props.setProperty(Context.INITIAL_CONTEXT_FACTORY, LDAP_PROVIDER);\n        props.setProperty(Context.BATCHSIZE, \"0\");\n\n        props.setProperty(Context.PROVIDER_URL, params.getLdapURL());\n        props.setProperty(Context.URL_PKG_PREFIXES, URL_CONTEXT_PREFIX);\n        props.setProperty(Context.REFERRAL, REFERRALS_IGNORE);\n        props.setProperty(Context.SECURITY_AUTHENTICATION,\n            SEARCH_SECURITY_LEVEL);\n\n        DirContext ctx = new InitialDirContext(props);\n        return ctx;\n    }\n\n    private String parseDN(String subject, String subjectAttributeName)\n    {\n        String temp = subject;\n        int begin = temp.toLowerCase().indexOf(\n            subjectAttributeName.toLowerCase());\n        temp = temp.substring(begin + subjectAttributeName.length());\n        int end = temp.indexOf(',');\n        if (end == -1)\n        {\n            end = temp.length();\n        }\n        while (temp.charAt(end - 1) == '\\\\')\n        {\n            end = temp.indexOf(',', end + 1);\n            if (end == -1)\n            {\n                end = temp.length();\n            }\n        }\n        temp = temp.substring(0, end);\n        begin = temp.indexOf('=');\n        temp = temp.substring(begin + 1);\n        if (temp.charAt(0) == ' ')\n        {\n            temp = temp.substring(1);\n        }\n        if (temp.startsWith(\"\\\"\"))\n        {\n            temp = temp.substring(1);\n        }\n        if (temp.endsWith(\"\\\"\"))\n        {\n            temp = temp.substring(0, temp.length() - 1);\n        }\n        return temp;\n    }\n\n    public Collection engineGetCertificates(CertSelector selector)\n        throws CertStoreException\n    {\n        if (!(selector instanceof X509CertSelector))\n        {\n            throw new CertStoreException(\"selector is not a X509CertSelector\");\n        }\n        X509CertSelector xselector = (X509CertSelector)selector;\n\n        Set certSet = new HashSet();\n\n        Set set = getEndCertificates(xselector);\n        set.addAll(getCACertificates(xselector));\n        set.addAll(getCrossCertificates(xselector));\n\n        Iterator it = set.iterator();\n\n        try\n        {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\",\n                BouncyCastleProvider.PROVIDER_NAME);\n            while (it.hasNext())\n            {\n                byte[] bytes = (byte[])it.next();\n                if (bytes == null || bytes.length == 0)\n                {\n                    continue;\n                }\n\n                List bytesList = new ArrayList();\n                bytesList.add(bytes);\n\n                try\n                {\n                    CertificatePair pair = CertificatePair\n                        .getInstance(new ASN1InputStream(bytes)\n                            .readObject());\n                    bytesList.clear();\n                    if (pair.getForward() != null)\n                    {\n                        bytesList.add(pair.getForward().getEncoded());\n                    }\n                    if (pair.getReverse() != null)\n                    {\n                        bytesList.add(pair.getReverse().getEncoded());\n                    }\n                }\n                catch (IOException e)\n                {\n\n                }\n                catch (IllegalArgumentException e)\n                {\n\n                }\n                for (Iterator it2 = bytesList.iterator(); it2.hasNext();)\n                {\n                    ByteArrayInputStream bIn = new ByteArrayInputStream(\n                        (byte[])it2.next());\n                    try\n                    {\n                        Certificate cert = cf.generateCertificate(bIn);\n                        // System.out.println(((X509Certificate)\n                        // cert).getSubjectX500Principal());\n                        if (xselector.match(cert))\n                        {\n                            certSet.add(cert);\n                        }\n                    }\n                    catch (Exception e)\n                    {\n\n                    }\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            throw new CertStoreException(\n                \"certificate cannot be constructed from LDAP result: \" + e);\n        }\n\n        return certSet;\n    }\n\n    private Set certSubjectSerialSearch(X509CertSelector xselector,\n                                        String[] attrs, String attrName, String subjectAttributeName)\n        throws CertStoreException\n    {\n        Set set = new HashSet();\n        try\n        {\n            if (xselector.getSubjectAsBytes() != null\n                || xselector.getSubjectAsString() != null\n                || xselector.getCertificate() != null)\n            {\n                String subject = null;\n                String serial = null;\n                if (xselector.getCertificate() != null)\n                {\n                    subject = xselector.getCertificate()\n                        .getSubjectX500Principal().getName(\"RFC1779\");\n                    serial = xselector.getCertificate().getSerialNumber()\n                        .toString();\n                }\n                else\n                {\n                    if (xselector.getSubjectAsBytes() != null)\n                    {\n                        subject = new X500Principal(xselector\n                            .getSubjectAsBytes()).getName(\"RFC1779\");\n                    }\n                    else\n                    {\n                        subject = xselector.getSubjectAsString();\n                    }\n                }\n                String attrValue = parseDN(subject, subjectAttributeName);\n                set.addAll(search(attrName, \"*\" + attrValue + \"*\", attrs));\n                if (serial != null\n                    && params.getSearchForSerialNumberIn() != null)\n                {\n                    attrValue = serial;\n                    attrName = params.getSearchForSerialNumberIn();\n                    set.addAll(search(attrName, \"*\" + attrValue + \"*\", attrs));\n                }\n            }\n            else\n            {\n                set.addAll(search(attrName, \"*\", attrs));\n            }\n        }\n        catch (IOException e)\n        {\n            throw new CertStoreException(\"exception processing selector: \" + e);\n        }\n\n        return set;\n    }\n\n    private Set getEndCertificates(X509CertSelector xselector)\n        throws CertStoreException\n    {\n        String[] attrs = {params.getUserCertificateAttribute()};\n        String attrName = params.getLdapUserCertificateAttributeName();\n        String subjectAttributeName = params.getUserCertificateSubjectAttributeName();\n\n        Set set = certSubjectSerialSearch(xselector, attrs, attrName,\n            subjectAttributeName);\n        return set;\n    }\n\n    private Set getCACertificates(X509CertSelector xselector)\n        throws CertStoreException\n    {\n        String[] attrs = {params.getCACertificateAttribute()};\n        String attrName = params.getLdapCACertificateAttributeName();\n        String subjectAttributeName = params\n            .getCACertificateSubjectAttributeName();\n        Set set = certSubjectSerialSearch(xselector, attrs, attrName,\n            subjectAttributeName);\n\n        if (set.isEmpty())\n        {\n            set.addAll(search(null, \"*\", attrs));\n        }\n\n        return set;\n    }\n\n    private Set getCrossCertificates(X509CertSelector xselector)\n        throws CertStoreException\n    {\n        String[] attrs = {params.getCrossCertificateAttribute()};\n        String attrName = params.getLdapCrossCertificateAttributeName();\n        String subjectAttributeName = params\n            .getCrossCertificateSubjectAttributeName();\n        Set set = certSubjectSerialSearch(xselector, attrs, attrName,\n            subjectAttributeName);\n\n        if (set.isEmpty())\n        {\n            set.addAll(search(null, \"*\", attrs));\n        }\n\n        return set;\n    }\n\n    public Collection engineGetCRLs(CRLSelector selector)\n        throws CertStoreException\n    {\n        String[] attrs = {params.getCertificateRevocationListAttribute()};\n        if (!(selector instanceof X509CRLSelector))\n        {\n            throw new CertStoreException(\"selector is not a X509CRLSelector\");\n        }\n        X509CRLSelector xselector = (X509CRLSelector)selector;\n\n        Set crlSet = new HashSet();\n\n        String attrName = params.getLdapCertificateRevocationListAttributeName();\n        Set set = new HashSet();\n\n        if (xselector.getIssuerNames() != null)\n        {\n            for (Iterator it = xselector.getIssuerNames().iterator(); it\n                .hasNext();)\n            {\n                Object o = it.next();\n                String attrValue = null;\n                if (o instanceof String)\n                {\n                    String issuerAttributeName = params\n                        .getCertificateRevocationListIssuerAttributeName();\n                    attrValue = parseDN((String)o, issuerAttributeName);\n                }\n                else\n                {\n                    String issuerAttributeName = params\n                        .getCertificateRevocationListIssuerAttributeName();\n                    attrValue = parseDN(new X500Principal((byte[])o)\n                        .getName(\"RFC1779\"), issuerAttributeName);\n                }\n                set.addAll(search(attrName, \"*\" + attrValue + \"*\", attrs));\n            }\n        }\n        else\n        {\n            set.addAll(search(attrName, \"*\", attrs));\n        }\n        set.addAll(search(null, \"*\", attrs));\n        Iterator it = set.iterator();\n\n        try\n        {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\",\n                BouncyCastleProvider.PROVIDER_NAME);\n            while (it.hasNext())\n            {\n                CRL crl = cf.generateCRL(new ByteArrayInputStream((byte[])it\n                    .next()));\n                if (xselector.match(crl))\n                {\n                    crlSet.add(crl);\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            throw new CertStoreException(\n                \"CRL cannot be constructed from LDAP result \" + e);\n        }\n\n        return crlSet;\n    }\n    private static String[] FILTER_ESCAPE_TABLE = new String['\\\\' + 1];\n\n\n    static {\n\n        // Filter encoding table -------------------------------------\n\n        // fill with char itself\n        for (char c = 0; c < FILTER_ESCAPE_TABLE.length; c++) {\n            FILTER_ESCAPE_TABLE[c] = String.valueOf(c);\n        }\n\n        // escapes (RFC2254)\n        FILTER_ESCAPE_TABLE['*'] = \"\\\\2a\";\n        FILTER_ESCAPE_TABLE['('] = \"\\\\28\";\n        FILTER_ESCAPE_TABLE[')'] = \"\\\\29\";\n        FILTER_ESCAPE_TABLE['\\\\'] = \"\\\\5c\";\n        FILTER_ESCAPE_TABLE[0] = \"\\\\00\";\n\n    }\n\n    /**\n     * Escape a value for use in a filter.\n     * @param value the value to escape.\n     * @return a properly escaped representation of the supplied value.\n     */\n    private String filterEncode(String value)\n    {\n        if (value == null)\n        {\n            return null;\n        }\n\n        // make buffer roomy\n        StringBuilder encodedValue = new StringBuilder(value.length() * 2);\n\n        int length = value.length();\n\n        for (int i = 0; i < length; i++) {\n\n            char c = value.charAt(i);\n\n            if (c < FILTER_ESCAPE_TABLE.length) {\n                encodedValue.append(FILTER_ESCAPE_TABLE[c]);\n            }\n            else {\n                // default: add the char\n                encodedValue.append(c);\n            }\n        }\n\n        return encodedValue.toString();\n    }\n\n    /**\n     * Returns a Set of byte arrays with the certificate or CRL encodings.\n     *\n     * @param attributeName  The attribute name to look for in the LDAP.\n     * @param attributeValue The value the attribute name must have.\n     * @param attrs          The attributes in the LDAP which hold the certificate,\n     *                       certificate pair or CRL in a found entry.\n     * @return Set of byte arrays with the certificate encodings.\n     */\n    private Set search(String attributeName, String attributeValue,\n                       String[] attrs) throws CertStoreException\n    {\n        String filter = attributeName + \"=\" + filterEncode(attributeValue);\n        System.out.println(filter);\n        if (attributeName == null)\n        {\n            filter = null;\n        }\n        DirContext ctx = null;\n        Set set = new HashSet();\n        try\n        {\n\n            ctx = connectLDAP();\n\n            SearchControls constraints = new SearchControls();\n            constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);\n            constraints.setCountLimit(0);\n            for (int i = 0; i < attrs.length; i++)\n            {\n                String temp[] = new String[1];\n                temp[0] = attrs[i];\n                constraints.setReturningAttributes(temp);\n\n                String filter2 = \"(&(\" + filter + \")(\" + temp[0] + \"=*))\";\n                if (filter == null)\n                {\n                    filter2 = \"(\" + temp[0] + \"=*)\";\n                }\n                NamingEnumeration results = ctx.search(params.getBaseDN(),\n                    filter2, constraints);\n                while (results.hasMoreElements())\n                {\n                    SearchResult sr = (SearchResult)results.next();\n                    // should only be one attribute in the attribute set with\n                    // one\n                    // attribute value as byte array\n                    NamingEnumeration enumeration = ((Attribute)(sr\n                        .getAttributes().getAll().next())).getAll();\n                    while (enumeration.hasMore())\n                    {\n                        Object o = enumeration.next();\n                        set.add(o);\n                    }\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            throw new CertStoreException(\n                \"Error getting results from LDAP directory \" + e);\n\n        }\n        finally\n        {\n            try\n            {\n                if (null != ctx)\n                {\n                    ctx.close();\n                }\n            }\n            catch (Exception e)\n            {\n            }\n        }\n        return set;\n    }\n\n}\n"], "filenames": ["prov/src/main/java/org/bouncycastle/jce/provider/X509LDAPCertStoreSpi.java"], "buggy_code_start_loc": [377], "buggy_code_end_loc": [392], "fixing_code_start_loc": [378], "fixing_code_end_loc": [446], "type": "CWE-295", "message": "Bouncy Castle For Java before 1.74 is affected by an LDAP injection vulnerability. The vulnerability only affects applications that use an LDAP CertStore from Bouncy Castle to validate X.509 certificates. During the certificate validation process, Bouncy Castle inserts the certificate's Subject Name into an LDAP search filter without any escaping, which leads to an LDAP injection vulnerability.", "other": {"cve": {"id": "CVE-2023-33201", "sourceIdentifier": "cve@mitre.org", "published": "2023-07-05T03:15:09.197", "lastModified": "2023-08-24T19:15:38.933", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Bouncy Castle For Java before 1.74 is affected by an LDAP injection vulnerability. The vulnerability only affects applications that use an LDAP CertStore from Bouncy Castle to validate X.509 certificates. During the certificate validation process, Bouncy Castle inserts the certificate's Subject Name into an LDAP search filter without any escaping, which leads to an LDAP injection vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bouncycastle:bc-java:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.74", "matchCriteriaId": "93E9273D-E54C-43EF-8822-39FA3C2834E0"}]}]}], "references": [{"url": "https://bouncycastle.org", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://github.com/bcgit/bc-java/commit/e8c409a8389c815ea3fda5e8b94c92fdfe583bcc", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/bcgit/bc-java/wiki/CVE-2023-33201", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/08/msg00000.html", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20230824-0008/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/bcgit/bc-java/commit/e8c409a8389c815ea3fda5e8b94c92fdfe583bcc"}}