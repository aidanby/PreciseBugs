{"buggy_code": ["\n# MD4C Change Log\n\n\n## Next Version (Work in Progress)\n\nFixes:\n\n * [#149](https://github.com/mity/md4c/issues/149):\n   A HTML block started in a container block (and not explicitly finished in\n   the block) could eat 1 line of actual contents.\n\n * [#150](https://github.com/mity/md4c/issues/150):\n   Fix md2html utility to output proper DOCTYPE and HTML tags when `full-html`\n   command line options is used, accordingly to the expected output format\n   (HTML or XHTML).\n\n * [#153](https://github.com/mity/md4c/issues/153),\n   [#154](https://github.com/mity/md4c/issues/154):\n   Set `MD_BLOCK_UL_DETAIL::mark` and `MD_BLOCK_OL_DETAIL::mark_delimiter`\n   correctly, even when the blocks are nested at the same line in a complicated\n   ways.\n\n\n## Version 0.4.7\n\nChanges:\n\n * Add `MD_TABLE_DETAIL` structure into the API. The structure describes column\n   count and row count of the table, and pointer to it is passed into the\n   application-provided block callback with the `MD_BLOCK_TABLE` block type.\n\nFixes:\n\n * [#131](https://github.com/mity/md4c/issues/131):\n   Fix handling of a reference image nested in a reference link.\n\n * [#135](https://github.com/mity/md4c/issues/135):\n   Handle unmatched parenthesis pairs inside a permissive URL and WWW auto-links\n   in a way more compatible with the GFM.\n\n * [#138](https://github.com/mity/md4c/issues/138):\n   The tag `<tbody></tbody>` is now suppressed whenever the table has zero body\n   rows.\n\n * [#139](https://github.com/mity/md4c/issues/139):\n   Recognize a list item mark even when EOF follows it.\n\n * [#142](https://github.com/mity/md4c/issues/142):\n   Fix reference link definition label matching in a case when the label ends\n   with a Unicode character with non-trivial case folding mapping.\n\n\n## Version 0.4.6\n\nFixes:\n\n * [#130](https://github.com/mity/md4c/issues/130):\n   Fix `ISANYOF` macro, which could provide unexpected results when encountering\n   zero byte in the input text; in some cases leading to broken internal state\n   of the parser.\n\n   The bug could result in denial of service and possibly also to other security\n   implications. Applications are advised to update to 0.4.6.\n\n\n## Version 0.4.5\n\nFixes:\n\n * [#118](https://github.com/mity/md4c/issues/118):\n   Fix HTML renderer's `MD_HTML_FLAG_VERBATIM_ENTITIES` flag, exposed in the\n   `md2html` utility via `--fverbatim-entities`.\n\n * [#124](https://github.com/mity/md4c/issues/124):\n   Fix handling of indentation of 16 or more spaces in the fenced code blocks.\n\n\n## Version 0.4.4\n\nChanges:\n\n * Make Unicode-specific code compliant to Unicode 13.0.\n\nNew features:\n\n * The HTML renderer, developed originally as the heart of the `md2html`\n   utility, is now built as a standalone library, in order to simplify its\n   reuse in applications.\n\n * With `MD_HTML_FLAG_SKIP_UTF8_BOM`, the HTML renderer now skips UTF-8 byte\n   order mark (BOM) if the input begins with it, before passing to the Markdown\n   parser.\n\n   `md2html` utility automatically enables the flag (unless it is custom-built\n   with `-DMD4C_USE_ASCII`).\n\n * With `MD_HTML_FLAG_XHTML`, The HTML renderer generates XHTML instead of\n   HTML.\n\n   This effectively means `<br />` instead of `<br>`, `<hr />` instead of\n   `<hr>`, and `<img ... />` instead of `<img ...>`.\n\n   `md2html` utility now understands the command line option `-x` or `--xhtml`\n   enabling the XHTML mode.\n\nFixes:\n\n * [#113](https://github.com/mity/md4c/issues/113):\n   Add missing folding info data for the following Unicode characters:\n   `U+0184`, `U+018a`, `U+01b2`, `U+01b5`, `U+01f4`, `U+0372`, `U+038f`,\n   `U+1c84`, `U+1fb9`, `U+1fbb`, `U+1fd9`, `U+1fdb`, `U+1fe9`, `U+1feb`,\n   `U+1ff9`, `U+1ffb`, `U+2c7f`, `U+2ced`, `U+a77b`, `U+a792`, `U+a7c9`.\n\n   Due the bug, the link definition label matching did not work in the case\n   insensitive way for these characters.\n\n\n## Version 0.4.3\n\nNew features:\n\n * With `MD_FLAG_UNDERLINE`, spans enclosed in underscore (`_foo_`) are seen\n   as underline (`MD_SPAN_UNDERLINE`) rather than an ordinary emphasis or\n   strong emphasis.\n\nChanges:\n\n * The implementation of wiki-links extension (with `MD_FLAG_WIKILINKS`) has\n   been simplified.\n\n    - A noticeable increase of MD4C's memory footprint introduced by the\n      extension implementation in 0.4.0 has been removed.\n    - The priority handling towards other inline elements have been unified.\n      (This affects an obscure case where syntax of an image was in place of\n      wiki-link destination made the wiki-link invalid. Now *all* inline spans\n      in the wiki-link destination, including the images, is suppressed.)\n    - The length limitation of 100 characters now always applies to wiki-link\n      destination.\n\n * Recognition of strike-through spans (with the flag `MD_FLAG_STRIKETHROUGH`)\n   has become much stricter and, arguably, reasonable.\n\n    - Only single tildes (`~`) and double tildes (`~~`) are recognized as\n      strike-through marks. Longer ones are not anymore.\n    - The length of the opener and closer marks have to be the same.\n    - The tildes cannot open a strike-through span if a whitespace follows.\n    - The tildes cannot close a strike-through span if a whitespace precedes.\n\n   This change follows the changes of behavior in cmark-gfm some time ago, so\n   it is also beneficial from compatibility point of view.\n\n * When building MD4C by hand instead of using its CMake-based build, the UTF-8\n   support was by default disabled, unless explicitly asked for by defining\n   a preprocessor macro `MD4C_USE_UTF8`.\n\n   This has been changed and the UTF-8 mode now becomes the default, no matter\n   how `md4c.c` is compiled. If you need to disable it and use the ASCII-only\n   mode, you have explicitly define macro `MD4C_USE_ASCII` when compiling it.\n\n   (The CMake-based build as provided in our repository explicitly asked for\n   the UTF-8 support with `-DMD4C_USE_UTF8`. I.e. if you are using MD4C library\n   built with our vanilla `CMakeLists.txt` files, this change should not affect\n   you.)\n\nFixes:\n\n * Fixed some string length handling in the special `MD4C_USE_UTF16` build.\n\n   (This does not affect you unless you are on Windows and explicitly define\n   the macro when building MD4C.)\n\n * [#100](https://github.com/mity/md4c/issues/100):\n   Fixed an off-by-one error in the maximal length limit of some segments\n   of e-mail addresses used in autolinks.\n\n * [#107](https://github.com/mity/md4c/issues/107):\n   Fix mis-detection of asterisk-encoded emphasis in some corner cases when\n   length of the opener and closer differs, as in `***foo *bar baz***`.\n\n\n## Version 0.4.2\n\nFixes:\n\n * [#98](https://github.com/mity/md4c/issues/98):\n   Fix mis-detection of asterisk-encoded emphasis in some corner cases when\n   length of the opener and closer differs, as in `**a *b c** d*`.\n\n\n## Version 0.4.1\n\nUnfortunately, 0.4.0 has been released with badly updated ChangeLog. Fixing\nthis is the only change on 0.4.1.\n\n\n## Version 0.4.0\n\nNew features:\n\n * With `MD_FLAG_LATEXMATHSPANS`, LaTeX math spans (`$...$`) and LaTeX display\n   math spans (`$$...$$`) are now recognized. (Note though that the HTML\n   renderer outputs them verbatim in a custom `<x-equation>` tag.)\n\n   Contributed by [Tilman Roeder](https://github.com/dyedgreen).\n\n * With `MD_FLAG_WIKILINKS`, Wiki-style links (`[[...]]`) are now recognized.\n   (Note though that the HTML renderer renders them as a custom `<x-wikilink>`\n   tag.)\n\n   Contributed by [Nils Blomqvist](https://github.com/niblo).\n\nChanges:\n\n * Parsing of tables (with `MD_FLAG_TABLES`) is now closer to the way how\n   cmark-gfm parses tables as we do not require every row of the table to\n   contain a pipe `|` anymore.\n\n   As a consequence, paragraphs now cannot interrupt tables. A paragraph which\n   follows the table has to be delimited with a blank line.\n\nFixes:\n\n * [#94](https://github.com/mity/md4c/issues/94):\n   `md_build_ref_def_hashtable()`: Do not allocate more memory than strictly\n   needed.\n\n * [#95](https://github.com/mity/md4c/issues/95):\n   `md_is_container_mark()`: Ordered list mark requires at least one digit.\n\n * [#96](https://github.com/mity/md4c/issues/96):\n   Some fixes for link label comparison.\n\n\n## Version 0.3.4\n\nChanges:\n\n * Make Unicode-specific code compliant to Unicode 12.1.\n\n * Structure `MD_BLOCK_CODE_DETAIL` got new member `fenced_char`. Application\n   can use it to detect character used to form the block fences (`` ` `` or\n   `~`). In the case of indented code block, it is set to zero.\n\nFixes:\n\n * [#77](https://github.com/mity/md4c/issues/77):\n   Fix maximal count of digits for numerical character references, as requested\n   by CommonMark specification 0.29.\n\n * [#78](https://github.com/mity/md4c/issues/78):\n   Fix link reference definition label matching for Unicode characters where\n   the folding mapping leads to multiple codepoints, as e.g. in `\u1e9e` -> `SS`.\n\n * [#83](https://github.com/mity/md4c/issues/83):\n   Fix recognition of an empty blockquote which interrupts a paragraph.\n\n\n## Version 0.3.3\n\nChanges:\n\n * Make permissive URL autolink and permissive WWW autolink extensions stricter.\n\n   This brings the behavior closer to GFM and mitigates risk of false positives.\n   In particular, the domain has to contain at least one dot and parenthesis\n   can be part of the link destination only if `(` and `)` are balanced.\n\nFixes:\n\n * [#73](https://github.com/mity/md4c/issues/73):\n   Some raw HTML inputs could lead to quadratic parsing times.\n\n * [#74](https://github.com/mity/md4c/issues/74):\n   Fix input leading to a crash. Found by fuzzing.\n\n * [#76](https://github.com/mity/md4c/issues/76):\n   Fix handling of parenthesis in some corner cases of permissive URL autolink\n   and permissive WWW autolink extensions.\n\n\n## Version 0.3.2\n\nChanges:\n\n * Changes mandated by CommonMark specification 0.29.\n\n   Most importantly, the white-space trimming rules for code spans have changed.\n   At most one space/newline is trimmed from beginning/end of the code span\n   (if the code span contains some non-space contents, and if it begins and\n   ends with space at the same time). In all other cases the spaces in the code\n   span are now left intact.\n\n   Other changes in behavior are in corner cases only. Refer to [CommonMark\n   0.29 notes](https://github.com/commonmark/commonmark-spec/releases/tag/0.29)\n   for more info.\n\nFixes:\n\n * [#68](https://github.com/mity/md4c/issues/68):\n   Some specific HTML blocks were not recognized when EOF follows without any\n   end-of-line character.\n\n * [#69](https://github.com/mity/md4c/issues/69):\n   Strike-through span not working correctly when its opener mark is directly\n   followed by other opener mark; or when other closer mark directly precedes\n   its closer mark.\n\n\n## Version 0.3.1\n\nFixes:\n\n * [#58](https://github.com/mity/md4c/issues/58),\n   [#59](https://github.com/mity/md4c/issues/59),\n   [#60](https://github.com/mity/md4c/issues/60),\n   [#63](https://github.com/mity/md4c/issues/63),\n   [#66](https://github.com/mity/md4c/issues/66):\n   Some inputs could lead to quadratic parsing times. Thanks to Anders Kaseorg\n   for finding all those issues.\n\n * [#61](https://github.com/mity/md4c/issues/59):\n   Flag `MD_FLAG_NOHTMLSPANS` erroneously affected also recognition of\n   CommonMark autolinks.\n\n\n## Version 0.3.0\n\nNew features:\n\n * Add extension for GitHub-style task lists:\n\n   ```\n    * [x] foo\n    * [x] bar\n    * [ ] baz\n   ```\n\n   (It has to be explicitly enabled with `MD_FLAG_TASKLISTS`.)\n\n * Added support for building as a shared library. On non-Windows platforms,\n   this is now default behavior; on Windows static library is still the default.\n   The CMake option `BUILD_SHARED_LIBS` can be used to request one or the other\n   explicitly.\n\n   Contributed by Lisandro Dami\u00e1n Nicanor P\u00e9rez Meyer.\n\n * Renamed structure `MD_RENDERER` to `MD_PARSER` and refactorize its contents\n   a little bit. Note this is source-level incompatible and initialization code\n   in apps may need to be updated.\n\n   The aim of the change is to be more friendly for long-term ABI compatibility\n   we shall maintain, starting with this release.\n\n * Added `CHANGELOG.md` (this file).\n\n * Make sure `md_process_table_row()` reports the same count of table cells for\n   all table rows, no matter how broken the input is. The cell count is derived\n   from table underline line. Bogus cells in other rows are silently ignored.\n   Missing cells in other rows are reported as empty ones.\n\nFixes:\n\n * CID 1475544:\n   Calling `md_free_attribute()` on uninitialized data.\n\n * [#47](https://github.com/mity/md4c/issues/47):\n   Using bad offsets in `md_is_entity_str()`, in some cases leading to buffer\n   overflow.\n\n * [#51](https://github.com/mity/md4c/issues/51):\n   Segfault in `md_process_table_cell()`.\n\n * [#53](https://github.com/mity/md4c/issues/53):\n   With `MD_FLAG_PERMISSIVEURLAUTOLINKS` or `MD_FLAG_PERMISSIVEWWWAUTOLINKS`\n   we could generate bad output for ordinary Markdown links, if a non-space\n   character immediately follows like e.g. in `[link](http://github.com)X`.\n\n\n## Version 0.2.7\n\nThis was the last version before the changelog has been added.\n", "/*\n * MD4C: Markdown parser for C\n * (http://github.com/mity/md4c)\n *\n * Copyright (c) 2016-2020 Martin Mitas\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"md4c.h\"\n\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\n/*****************************\n ***  Miscellaneous Stuff  ***\n *****************************/\n\n#if !defined(__STDC_VERSION__) || __STDC_VERSION__ < 199409L\n    /* C89/90 or old compilers in general may not understand \"inline\". */\n    #if defined __GNUC__\n        #define inline __inline__\n    #elif defined _MSC_VER\n        #define inline __inline\n    #else\n        #define inline\n    #endif\n#endif\n\n/* Make the UTF-8 support the default. */\n#if !defined MD4C_USE_ASCII && !defined MD4C_USE_UTF8 && !defined MD4C_USE_UTF16\n    #define MD4C_USE_UTF8\n#endif\n\n/* Magic for making wide literals with MD4C_USE_UTF16. */\n#ifdef _T\n    #undef _T\n#endif\n#if defined MD4C_USE_UTF16\n    #define _T(x)           L##x\n#else\n    #define _T(x)           x\n#endif\n\n/* Misc. macros. */\n#define SIZEOF_ARRAY(a)     (sizeof(a) / sizeof(a[0]))\n\n#define STRINGIZE_(x)       #x\n#define STRINGIZE(x)        STRINGIZE_(x)\n\n#ifndef TRUE\n    #define TRUE            1\n    #define FALSE           0\n#endif\n\n#define MD_LOG(msg)                                                     \\\n    do {                                                                \\\n        if(ctx->parser.debug_log != NULL)                               \\\n            ctx->parser.debug_log((msg), ctx->userdata);                \\\n    } while(0)\n\n#ifdef DEBUG\n    #define MD_ASSERT(cond)                                             \\\n            do {                                                        \\\n                if(!(cond)) {                                           \\\n                    MD_LOG(__FILE__ \":\" STRINGIZE(__LINE__) \": \"        \\\n                           \"Assertion '\" STRINGIZE(cond) \"' failed.\");  \\\n                    exit(1);                                            \\\n                }                                                       \\\n            } while(0)\n\n    #define MD_UNREACHABLE()        MD_ASSERT(1 == 0)\n#else\n    #ifdef __GNUC__\n        #define MD_ASSERT(cond)     do { if(!(cond)) __builtin_unreachable(); } while(0)\n        #define MD_UNREACHABLE()    do { __builtin_unreachable(); } while(0)\n    #elif defined _MSC_VER  &&  _MSC_VER > 120\n        #define MD_ASSERT(cond)     do { __assume(cond); } while(0)\n        #define MD_UNREACHABLE()    do { __assume(0); } while(0)\n    #else\n        #define MD_ASSERT(cond)     do {} while(0)\n        #define MD_UNREACHABLE()    do {} while(0)\n    #endif\n#endif\n\n/* For falling through case labels in switch statements. */\n#if defined __clang__ && __clang_major__ >= 12\n    #define MD_FALLTHROUGH()        __attribute__((fallthrough))\n#elif defined __GNUC__ && __GNUC__ >= 7\n    #define MD_FALLTHROUGH()        __attribute__((fallthrough))\n#else\n    #define MD_FALLTHROUGH()        ((void)0)\n#endif\n\n/* Suppress \"unused parameter\" warnings. */\n#define MD_UNUSED(x)                ((void)x)\n\n\n/************************\n ***  Internal Types  ***\n ************************/\n\n/* These are omnipresent so lets save some typing. */\n#define CHAR    MD_CHAR\n#define SZ      MD_SIZE\n#define OFF     MD_OFFSET\n\ntypedef struct MD_MARK_tag MD_MARK;\ntypedef struct MD_BLOCK_tag MD_BLOCK;\ntypedef struct MD_CONTAINER_tag MD_CONTAINER;\ntypedef struct MD_REF_DEF_tag MD_REF_DEF;\n\n\n/* During analyzes of inline marks, we need to manage some \"mark chains\",\n * of (yet unresolved) openers. This structure holds start/end of the chain.\n * The chain internals are then realized through MD_MARK::prev and ::next.\n */\ntypedef struct MD_MARKCHAIN_tag MD_MARKCHAIN;\nstruct MD_MARKCHAIN_tag {\n    int head;   /* Index of first mark in the chain, or -1 if empty. */\n    int tail;   /* Index of last mark in the chain, or -1 if empty. */\n};\n\n/* Context propagated through all the parsing. */\ntypedef struct MD_CTX_tag MD_CTX;\nstruct MD_CTX_tag {\n    /* Immutable stuff (parameters of md_parse()). */\n    const CHAR* text;\n    SZ size;\n    MD_PARSER parser;\n    void* userdata;\n\n    /* When this is true, it allows some optimizations. */\n    int doc_ends_with_newline;\n\n    /* Helper temporary growing buffer. */\n    CHAR* buffer;\n    unsigned alloc_buffer;\n\n    /* Reference definitions. */\n    MD_REF_DEF* ref_defs;\n    int n_ref_defs;\n    int alloc_ref_defs;\n    void** ref_def_hashtable;\n    int ref_def_hashtable_size;\n\n    /* Stack of inline/span markers.\n     * This is only used for parsing a single block contents but by storing it\n     * here we may reuse the stack for subsequent blocks; i.e. we have fewer\n     * (re)allocations. */\n    MD_MARK* marks;\n    int n_marks;\n    int alloc_marks;\n\n#if defined MD4C_USE_UTF16\n    char mark_char_map[128];\n#else\n    char mark_char_map[256];\n#endif\n\n    /* For resolving of inline spans. */\n    MD_MARKCHAIN mark_chains[13];\n#define PTR_CHAIN                               (ctx->mark_chains[0])\n#define TABLECELLBOUNDARIES                     (ctx->mark_chains[1])\n#define ASTERISK_OPENERS_extraword_mod3_0       (ctx->mark_chains[2])\n#define ASTERISK_OPENERS_extraword_mod3_1       (ctx->mark_chains[3])\n#define ASTERISK_OPENERS_extraword_mod3_2       (ctx->mark_chains[4])\n#define ASTERISK_OPENERS_intraword_mod3_0       (ctx->mark_chains[5])\n#define ASTERISK_OPENERS_intraword_mod3_1       (ctx->mark_chains[6])\n#define ASTERISK_OPENERS_intraword_mod3_2       (ctx->mark_chains[7])\n#define UNDERSCORE_OPENERS                      (ctx->mark_chains[8])\n#define TILDE_OPENERS_1                         (ctx->mark_chains[9])\n#define TILDE_OPENERS_2                         (ctx->mark_chains[10])\n#define BRACKET_OPENERS                         (ctx->mark_chains[11])\n#define DOLLAR_OPENERS                          (ctx->mark_chains[12])\n#define OPENERS_CHAIN_FIRST                     2\n#define OPENERS_CHAIN_LAST                      12\n\n    int n_table_cell_boundaries;\n\n    /* For resolving links. */\n    int unresolved_link_head;\n    int unresolved_link_tail;\n\n    /* For resolving raw HTML. */\n    OFF html_comment_horizon;\n    OFF html_proc_instr_horizon;\n    OFF html_decl_horizon;\n    OFF html_cdata_horizon;\n\n    /* For block analysis.\n     * Notes:\n     *   -- It holds MD_BLOCK as well as MD_LINE structures. After each\n     *      MD_BLOCK, its (multiple) MD_LINE(s) follow.\n     *   -- For MD_BLOCK_HTML and MD_BLOCK_CODE, MD_VERBATIMLINE(s) are used\n     *      instead of MD_LINE(s).\n     */\n    void* block_bytes;\n    MD_BLOCK* current_block;\n    int n_block_bytes;\n    int alloc_block_bytes;\n\n    /* For container block analysis. */\n    MD_CONTAINER* containers;\n    int n_containers;\n    int alloc_containers;\n\n    /* Minimal indentation to call the block \"indented code block\". */\n    unsigned code_indent_offset;\n\n    /* Contextual info for line analysis. */\n    SZ code_fence_length;   /* For checking closing fence length. */\n    int html_block_type;    /* For checking closing raw HTML condition. */\n    int last_line_has_list_loosening_effect;\n    int last_list_item_starts_with_two_blank_lines;\n};\n\nenum MD_LINETYPE_tag {\n    MD_LINE_BLANK,\n    MD_LINE_HR,\n    MD_LINE_ATXHEADER,\n    MD_LINE_SETEXTHEADER,\n    MD_LINE_SETEXTUNDERLINE,\n    MD_LINE_INDENTEDCODE,\n    MD_LINE_FENCEDCODE,\n    MD_LINE_HTML,\n    MD_LINE_TEXT,\n    MD_LINE_TABLE,\n    MD_LINE_TABLEUNDERLINE\n};\ntypedef enum MD_LINETYPE_tag MD_LINETYPE;\n\ntypedef struct MD_LINE_ANALYSIS_tag MD_LINE_ANALYSIS;\nstruct MD_LINE_ANALYSIS_tag {\n    MD_LINETYPE type    : 16;\n    unsigned data       : 16;\n    OFF beg;\n    OFF end;\n    unsigned indent;        /* Indentation level. */\n};\n\ntypedef struct MD_LINE_tag MD_LINE;\nstruct MD_LINE_tag {\n    OFF beg;\n    OFF end;\n};\n\ntypedef struct MD_VERBATIMLINE_tag MD_VERBATIMLINE;\nstruct MD_VERBATIMLINE_tag {\n    OFF beg;\n    OFF end;\n    OFF indent;\n};\n\n\n/*****************\n ***  Helpers  ***\n *****************/\n\n/* Character accessors. */\n#define CH(off)                 (ctx->text[(off)])\n#define STR(off)                (ctx->text + (off))\n\n/* Character classification.\n * Note we assume ASCII compatibility of code points < 128 here. */\n#define ISIN_(ch, ch_min, ch_max)       ((ch_min) <= (unsigned)(ch) && (unsigned)(ch) <= (ch_max))\n#define ISANYOF_(ch, palette)           ((ch) != _T('\\0')  &&  md_strchr((palette), (ch)) != NULL)\n#define ISANYOF2_(ch, ch1, ch2)         ((ch) == (ch1) || (ch) == (ch2))\n#define ISANYOF3_(ch, ch1, ch2, ch3)    ((ch) == (ch1) || (ch) == (ch2) || (ch) == (ch3))\n#define ISASCII_(ch)                    ((unsigned)(ch) <= 127)\n#define ISBLANK_(ch)                    (ISANYOF2_((ch), _T(' '), _T('\\t')))\n#define ISNEWLINE_(ch)                  (ISANYOF2_((ch), _T('\\r'), _T('\\n')))\n#define ISWHITESPACE_(ch)               (ISBLANK_(ch) || ISANYOF2_((ch), _T('\\v'), _T('\\f')))\n#define ISCNTRL_(ch)                    ((unsigned)(ch) <= 31 || (unsigned)(ch) == 127)\n#define ISPUNCT_(ch)                    (ISIN_(ch, 33, 47) || ISIN_(ch, 58, 64) || ISIN_(ch, 91, 96) || ISIN_(ch, 123, 126))\n#define ISUPPER_(ch)                    (ISIN_(ch, _T('A'), _T('Z')))\n#define ISLOWER_(ch)                    (ISIN_(ch, _T('a'), _T('z')))\n#define ISALPHA_(ch)                    (ISUPPER_(ch) || ISLOWER_(ch))\n#define ISDIGIT_(ch)                    (ISIN_(ch, _T('0'), _T('9')))\n#define ISXDIGIT_(ch)                   (ISDIGIT_(ch) || ISIN_(ch, _T('A'), _T('F')) || ISIN_(ch, _T('a'), _T('f')))\n#define ISALNUM_(ch)                    (ISALPHA_(ch) || ISDIGIT_(ch))\n\n#define ISANYOF(off, palette)           ISANYOF_(CH(off), (palette))\n#define ISANYOF2(off, ch1, ch2)         ISANYOF2_(CH(off), (ch1), (ch2))\n#define ISANYOF3(off, ch1, ch2, ch3)    ISANYOF3_(CH(off), (ch1), (ch2), (ch3))\n#define ISASCII(off)                    ISASCII_(CH(off))\n#define ISBLANK(off)                    ISBLANK_(CH(off))\n#define ISNEWLINE(off)                  ISNEWLINE_(CH(off))\n#define ISWHITESPACE(off)               ISWHITESPACE_(CH(off))\n#define ISCNTRL(off)                    ISCNTRL_(CH(off))\n#define ISPUNCT(off)                    ISPUNCT_(CH(off))\n#define ISUPPER(off)                    ISUPPER_(CH(off))\n#define ISLOWER(off)                    ISLOWER_(CH(off))\n#define ISALPHA(off)                    ISALPHA_(CH(off))\n#define ISDIGIT(off)                    ISDIGIT_(CH(off))\n#define ISXDIGIT(off)                   ISXDIGIT_(CH(off))\n#define ISALNUM(off)                    ISALNUM_(CH(off))\n\n\n#if defined MD4C_USE_UTF16\n    #define md_strchr wcschr\n#else\n    #define md_strchr strchr\n#endif\n\n\n/* Case insensitive check of string equality. */\nstatic inline int\nmd_ascii_case_eq(const CHAR* s1, const CHAR* s2, SZ n)\n{\n    OFF i;\n    for(i = 0; i < n; i++) {\n        CHAR ch1 = s1[i];\n        CHAR ch2 = s2[i];\n\n        if(ISLOWER_(ch1))\n            ch1 += ('A'-'a');\n        if(ISLOWER_(ch2))\n            ch2 += ('A'-'a');\n        if(ch1 != ch2)\n            return FALSE;\n    }\n    return TRUE;\n}\n\nstatic inline int\nmd_ascii_eq(const CHAR* s1, const CHAR* s2, SZ n)\n{\n    return memcmp(s1, s2, n * sizeof(CHAR)) == 0;\n}\n\nstatic int\nmd_text_with_null_replacement(MD_CTX* ctx, MD_TEXTTYPE type, const CHAR* str, SZ size)\n{\n    OFF off = 0;\n    int ret = 0;\n\n    while(1) {\n        while(off < size  &&  str[off] != _T('\\0'))\n            off++;\n\n        if(off > 0) {\n            ret = ctx->parser.text(type, str, off, ctx->userdata);\n            if(ret != 0)\n                return ret;\n\n            str += off;\n            size -= off;\n            off = 0;\n        }\n\n        if(off >= size)\n            return 0;\n\n        ret = ctx->parser.text(MD_TEXT_NULLCHAR, _T(\"\"), 1, ctx->userdata);\n        if(ret != 0)\n            return ret;\n        off++;\n    }\n}\n\n\n#define MD_CHECK(func)                                                      \\\n    do {                                                                    \\\n        ret = (func);                                                       \\\n        if(ret < 0)                                                         \\\n            goto abort;                                                     \\\n    } while(0)\n\n\n#define MD_TEMP_BUFFER(sz)                                                  \\\n    do {                                                                    \\\n        if(sz > ctx->alloc_buffer) {                                        \\\n            CHAR* new_buffer;                                               \\\n            SZ new_size = ((sz) + (sz) / 2 + 128) & ~127;                   \\\n                                                                            \\\n            new_buffer = realloc(ctx->buffer, new_size);                    \\\n            if(new_buffer == NULL) {                                        \\\n                MD_LOG(\"realloc() failed.\");                                \\\n                ret = -1;                                                   \\\n                goto abort;                                                 \\\n            }                                                               \\\n                                                                            \\\n            ctx->buffer = new_buffer;                                       \\\n            ctx->alloc_buffer = new_size;                                   \\\n        }                                                                   \\\n    } while(0)\n\n\n#define MD_ENTER_BLOCK(type, arg)                                           \\\n    do {                                                                    \\\n        ret = ctx->parser.enter_block((type), (arg), ctx->userdata);        \\\n        if(ret != 0) {                                                      \\\n            MD_LOG(\"Aborted from enter_block() callback.\");                 \\\n            goto abort;                                                     \\\n        }                                                                   \\\n    } while(0)\n\n#define MD_LEAVE_BLOCK(type, arg)                                           \\\n    do {                                                                    \\\n        ret = ctx->parser.leave_block((type), (arg), ctx->userdata);        \\\n        if(ret != 0) {                                                      \\\n            MD_LOG(\"Aborted from leave_block() callback.\");                 \\\n            goto abort;                                                     \\\n        }                                                                   \\\n    } while(0)\n\n#define MD_ENTER_SPAN(type, arg)                                            \\\n    do {                                                                    \\\n        ret = ctx->parser.enter_span((type), (arg), ctx->userdata);         \\\n        if(ret != 0) {                                                      \\\n            MD_LOG(\"Aborted from enter_span() callback.\");                  \\\n            goto abort;                                                     \\\n        }                                                                   \\\n    } while(0)\n\n#define MD_LEAVE_SPAN(type, arg)                                            \\\n    do {                                                                    \\\n        ret = ctx->parser.leave_span((type), (arg), ctx->userdata);         \\\n        if(ret != 0) {                                                      \\\n            MD_LOG(\"Aborted from leave_span() callback.\");                  \\\n            goto abort;                                                     \\\n        }                                                                   \\\n    } while(0)\n\n#define MD_TEXT(type, str, size)                                            \\\n    do {                                                                    \\\n        if(size > 0) {                                                      \\\n            ret = ctx->parser.text((type), (str), (size), ctx->userdata);   \\\n            if(ret != 0) {                                                  \\\n                MD_LOG(\"Aborted from text() callback.\");                    \\\n                goto abort;                                                 \\\n            }                                                               \\\n        }                                                                   \\\n    } while(0)\n\n#define MD_TEXT_INSECURE(type, str, size)                                   \\\n    do {                                                                    \\\n        if(size > 0) {                                                      \\\n            ret = md_text_with_null_replacement(ctx, type, str, size);      \\\n            if(ret != 0) {                                                  \\\n                MD_LOG(\"Aborted from text() callback.\");                    \\\n                goto abort;                                                 \\\n            }                                                               \\\n        }                                                                   \\\n    } while(0)\n\n\n\n/*************************\n ***  Unicode Support  ***\n *************************/\n\ntypedef struct MD_UNICODE_FOLD_INFO_tag MD_UNICODE_FOLD_INFO;\nstruct MD_UNICODE_FOLD_INFO_tag {\n    unsigned codepoints[3];\n    unsigned n_codepoints;\n};\n\n\n#if defined MD4C_USE_UTF16 || defined MD4C_USE_UTF8\n    /* Binary search over sorted \"map\" of codepoints. Consecutive sequences\n     * of codepoints may be encoded in the map by just using the\n     * (MIN_CODEPOINT | 0x40000000) and (MAX_CODEPOINT | 0x80000000).\n     *\n     * Returns index of the found record in the map (in the case of ranges,\n     * the minimal value is used); or -1 on failure. */\n    static int\n    md_unicode_bsearch__(unsigned codepoint, const unsigned* map, size_t map_size)\n    {\n        int beg, end;\n        int pivot_beg, pivot_end;\n\n        beg = 0;\n        end = (int) map_size-1;\n        while(beg <= end) {\n            /* Pivot may be a range, not just a single value. */\n            pivot_beg = pivot_end = (beg + end) / 2;\n            if(map[pivot_end] & 0x40000000)\n                pivot_end++;\n            if(map[pivot_beg] & 0x80000000)\n                pivot_beg--;\n\n            if(codepoint < (map[pivot_beg] & 0x00ffffff))\n                end = pivot_beg - 1;\n            else if(codepoint > (map[pivot_end] & 0x00ffffff))\n                beg = pivot_end + 1;\n            else\n                return pivot_beg;\n        }\n\n        return -1;\n    }\n\n    static int\n    md_is_unicode_whitespace__(unsigned codepoint)\n    {\n#define R(cp_min, cp_max)   ((cp_min) | 0x40000000), ((cp_max) | 0x80000000)\n#define S(cp)               (cp)\n        /* Unicode \"Zs\" category.\n         * (generated by scripts/build_whitespace_map.py) */\n        static const unsigned WHITESPACE_MAP[] = {\n            S(0x0020), S(0x00a0), S(0x1680), R(0x2000,0x200a), S(0x202f), S(0x205f), S(0x3000)\n        };\n#undef R\n#undef S\n\n        /* The ASCII ones are the most frequently used ones, also CommonMark\n         * specification requests few more in this range. */\n        if(codepoint <= 0x7f)\n            return ISWHITESPACE_(codepoint);\n\n        return (md_unicode_bsearch__(codepoint, WHITESPACE_MAP, SIZEOF_ARRAY(WHITESPACE_MAP)) >= 0);\n    }\n\n    static int\n    md_is_unicode_punct__(unsigned codepoint)\n    {\n#define R(cp_min, cp_max)   ((cp_min) | 0x40000000), ((cp_max) | 0x80000000)\n#define S(cp)               (cp)\n        /* Unicode \"Pc\", \"Pd\", \"Pe\", \"Pf\", \"Pi\", \"Po\", \"Ps\" categories.\n         * (generated by scripts/build_punct_map.py) */\n        static const unsigned PUNCT_MAP[] = {\n            R(0x0021,0x0023), R(0x0025,0x002a), R(0x002c,0x002f), R(0x003a,0x003b), R(0x003f,0x0040),\n            R(0x005b,0x005d), S(0x005f), S(0x007b), S(0x007d), S(0x00a1), S(0x00a7), S(0x00ab), R(0x00b6,0x00b7),\n            S(0x00bb), S(0x00bf), S(0x037e), S(0x0387), R(0x055a,0x055f), R(0x0589,0x058a), S(0x05be), S(0x05c0),\n            S(0x05c3), S(0x05c6), R(0x05f3,0x05f4), R(0x0609,0x060a), R(0x060c,0x060d), S(0x061b), R(0x061e,0x061f),\n            R(0x066a,0x066d), S(0x06d4), R(0x0700,0x070d), R(0x07f7,0x07f9), R(0x0830,0x083e), S(0x085e),\n            R(0x0964,0x0965), S(0x0970), S(0x09fd), S(0x0a76), S(0x0af0), S(0x0c77), S(0x0c84), S(0x0df4), S(0x0e4f),\n            R(0x0e5a,0x0e5b), R(0x0f04,0x0f12), S(0x0f14), R(0x0f3a,0x0f3d), S(0x0f85), R(0x0fd0,0x0fd4),\n            R(0x0fd9,0x0fda), R(0x104a,0x104f), S(0x10fb), R(0x1360,0x1368), S(0x1400), S(0x166e), R(0x169b,0x169c),\n            R(0x16eb,0x16ed), R(0x1735,0x1736), R(0x17d4,0x17d6), R(0x17d8,0x17da), R(0x1800,0x180a),\n            R(0x1944,0x1945), R(0x1a1e,0x1a1f), R(0x1aa0,0x1aa6), R(0x1aa8,0x1aad), R(0x1b5a,0x1b60),\n            R(0x1bfc,0x1bff), R(0x1c3b,0x1c3f), R(0x1c7e,0x1c7f), R(0x1cc0,0x1cc7), S(0x1cd3), R(0x2010,0x2027),\n            R(0x2030,0x2043), R(0x2045,0x2051), R(0x2053,0x205e), R(0x207d,0x207e), R(0x208d,0x208e),\n            R(0x2308,0x230b), R(0x2329,0x232a), R(0x2768,0x2775), R(0x27c5,0x27c6), R(0x27e6,0x27ef),\n            R(0x2983,0x2998), R(0x29d8,0x29db), R(0x29fc,0x29fd), R(0x2cf9,0x2cfc), R(0x2cfe,0x2cff), S(0x2d70),\n            R(0x2e00,0x2e2e), R(0x2e30,0x2e4f), S(0x2e52), R(0x3001,0x3003), R(0x3008,0x3011), R(0x3014,0x301f),\n            S(0x3030), S(0x303d), S(0x30a0), S(0x30fb), R(0xa4fe,0xa4ff), R(0xa60d,0xa60f), S(0xa673), S(0xa67e),\n            R(0xa6f2,0xa6f7), R(0xa874,0xa877), R(0xa8ce,0xa8cf), R(0xa8f8,0xa8fa), S(0xa8fc), R(0xa92e,0xa92f),\n            S(0xa95f), R(0xa9c1,0xa9cd), R(0xa9de,0xa9df), R(0xaa5c,0xaa5f), R(0xaade,0xaadf), R(0xaaf0,0xaaf1),\n            S(0xabeb), R(0xfd3e,0xfd3f), R(0xfe10,0xfe19), R(0xfe30,0xfe52), R(0xfe54,0xfe61), S(0xfe63), S(0xfe68),\n            R(0xfe6a,0xfe6b), R(0xff01,0xff03), R(0xff05,0xff0a), R(0xff0c,0xff0f), R(0xff1a,0xff1b),\n            R(0xff1f,0xff20), R(0xff3b,0xff3d), S(0xff3f), S(0xff5b), S(0xff5d), R(0xff5f,0xff65), R(0x10100,0x10102),\n            S(0x1039f), S(0x103d0), S(0x1056f), S(0x10857), S(0x1091f), S(0x1093f), R(0x10a50,0x10a58), S(0x10a7f),\n            R(0x10af0,0x10af6), R(0x10b39,0x10b3f), R(0x10b99,0x10b9c), S(0x10ead), R(0x10f55,0x10f59),\n            R(0x11047,0x1104d), R(0x110bb,0x110bc), R(0x110be,0x110c1), R(0x11140,0x11143), R(0x11174,0x11175),\n            R(0x111c5,0x111c8), S(0x111cd), S(0x111db), R(0x111dd,0x111df), R(0x11238,0x1123d), S(0x112a9),\n            R(0x1144b,0x1144f), R(0x1145a,0x1145b), S(0x1145d), S(0x114c6), R(0x115c1,0x115d7), R(0x11641,0x11643),\n            R(0x11660,0x1166c), R(0x1173c,0x1173e), S(0x1183b), R(0x11944,0x11946), S(0x119e2), R(0x11a3f,0x11a46),\n            R(0x11a9a,0x11a9c), R(0x11a9e,0x11aa2), R(0x11c41,0x11c45), R(0x11c70,0x11c71), R(0x11ef7,0x11ef8),\n            S(0x11fff), R(0x12470,0x12474), R(0x16a6e,0x16a6f), S(0x16af5), R(0x16b37,0x16b3b), S(0x16b44),\n            R(0x16e97,0x16e9a), S(0x16fe2), S(0x1bc9f), R(0x1da87,0x1da8b), R(0x1e95e,0x1e95f)\n        };\n#undef R\n#undef S\n\n        /* The ASCII ones are the most frequently used ones, also CommonMark\n         * specification requests few more in this range. */\n        if(codepoint <= 0x7f)\n            return ISPUNCT_(codepoint);\n\n        return (md_unicode_bsearch__(codepoint, PUNCT_MAP, SIZEOF_ARRAY(PUNCT_MAP)) >= 0);\n    }\n\n    static void\n    md_get_unicode_fold_info(unsigned codepoint, MD_UNICODE_FOLD_INFO* info)\n    {\n#define R(cp_min, cp_max)   ((cp_min) | 0x40000000), ((cp_max) | 0x80000000)\n#define S(cp)               (cp)\n        /* Unicode \"Pc\", \"Pd\", \"Pe\", \"Pf\", \"Pi\", \"Po\", \"Ps\" categories.\n         * (generated by scripts/build_folding_map.py) */\n        static const unsigned FOLD_MAP_1[] = {\n            R(0x0041,0x005a), S(0x00b5), R(0x00c0,0x00d6), R(0x00d8,0x00de), R(0x0100,0x012e), R(0x0132,0x0136),\n            R(0x0139,0x0147), R(0x014a,0x0176), S(0x0178), R(0x0179,0x017d), S(0x017f), S(0x0181), S(0x0182),\n            S(0x0184), S(0x0186), S(0x0187), S(0x0189), S(0x018a), S(0x018b), S(0x018e), S(0x018f), S(0x0190),\n            S(0x0191), S(0x0193), S(0x0194), S(0x0196), S(0x0197), S(0x0198), S(0x019c), S(0x019d), S(0x019f),\n            R(0x01a0,0x01a4), S(0x01a6), S(0x01a7), S(0x01a9), S(0x01ac), S(0x01ae), S(0x01af), S(0x01b1), S(0x01b2),\n            S(0x01b3), S(0x01b5), S(0x01b7), S(0x01b8), S(0x01bc), S(0x01c4), S(0x01c5), S(0x01c7), S(0x01c8),\n            S(0x01ca), R(0x01cb,0x01db), R(0x01de,0x01ee), S(0x01f1), S(0x01f2), S(0x01f4), S(0x01f6), S(0x01f7),\n            R(0x01f8,0x021e), S(0x0220), R(0x0222,0x0232), S(0x023a), S(0x023b), S(0x023d), S(0x023e), S(0x0241),\n            S(0x0243), S(0x0244), S(0x0245), R(0x0246,0x024e), S(0x0345), S(0x0370), S(0x0372), S(0x0376), S(0x037f),\n            S(0x0386), R(0x0388,0x038a), S(0x038c), S(0x038e), S(0x038f), R(0x0391,0x03a1), R(0x03a3,0x03ab),\n            S(0x03c2), S(0x03cf), S(0x03d0), S(0x03d1), S(0x03d5), S(0x03d6), R(0x03d8,0x03ee), S(0x03f0), S(0x03f1),\n            S(0x03f4), S(0x03f5), S(0x03f7), S(0x03f9), S(0x03fa), R(0x03fd,0x03ff), R(0x0400,0x040f),\n            R(0x0410,0x042f), R(0x0460,0x0480), R(0x048a,0x04be), S(0x04c0), R(0x04c1,0x04cd), R(0x04d0,0x052e),\n            R(0x0531,0x0556), R(0x10a0,0x10c5), S(0x10c7), S(0x10cd), R(0x13f8,0x13fd), S(0x1c80), S(0x1c81),\n            S(0x1c82), S(0x1c83), S(0x1c84), S(0x1c85), S(0x1c86), S(0x1c87), S(0x1c88), R(0x1c90,0x1cba),\n            R(0x1cbd,0x1cbf), R(0x1e00,0x1e94), S(0x1e9b), R(0x1ea0,0x1efe), R(0x1f08,0x1f0f), R(0x1f18,0x1f1d),\n            R(0x1f28,0x1f2f), R(0x1f38,0x1f3f), R(0x1f48,0x1f4d), S(0x1f59), S(0x1f5b), S(0x1f5d), S(0x1f5f),\n            R(0x1f68,0x1f6f), S(0x1fb8), S(0x1fb9), S(0x1fba), S(0x1fbb), S(0x1fbe), R(0x1fc8,0x1fcb), S(0x1fd8),\n            S(0x1fd9), S(0x1fda), S(0x1fdb), S(0x1fe8), S(0x1fe9), S(0x1fea), S(0x1feb), S(0x1fec), S(0x1ff8),\n            S(0x1ff9), S(0x1ffa), S(0x1ffb), S(0x2126), S(0x212a), S(0x212b), S(0x2132), R(0x2160,0x216f), S(0x2183),\n            R(0x24b6,0x24cf), R(0x2c00,0x2c2e), S(0x2c60), S(0x2c62), S(0x2c63), S(0x2c64), R(0x2c67,0x2c6b),\n            S(0x2c6d), S(0x2c6e), S(0x2c6f), S(0x2c70), S(0x2c72), S(0x2c75), S(0x2c7e), S(0x2c7f), R(0x2c80,0x2ce2),\n            S(0x2ceb), S(0x2ced), S(0x2cf2), R(0xa640,0xa66c), R(0xa680,0xa69a), R(0xa722,0xa72e), R(0xa732,0xa76e),\n            S(0xa779), S(0xa77b), S(0xa77d), R(0xa77e,0xa786), S(0xa78b), S(0xa78d), S(0xa790), S(0xa792),\n            R(0xa796,0xa7a8), S(0xa7aa), S(0xa7ab), S(0xa7ac), S(0xa7ad), S(0xa7ae), S(0xa7b0), S(0xa7b1), S(0xa7b2),\n            S(0xa7b3), R(0xa7b4,0xa7be), S(0xa7c2), S(0xa7c4), S(0xa7c5), S(0xa7c6), S(0xa7c7), S(0xa7c9), S(0xa7f5),\n            R(0xab70,0xabbf), R(0xff21,0xff3a), R(0x10400,0x10427), R(0x104b0,0x104d3), R(0x10c80,0x10cb2),\n            R(0x118a0,0x118bf), R(0x16e40,0x16e5f), R(0x1e900,0x1e921)\n        };\n        static const unsigned FOLD_MAP_1_DATA[] = {\n            0x0061, 0x007a, 0x03bc, 0x00e0, 0x00f6, 0x00f8, 0x00fe, 0x0101, 0x012f, 0x0133, 0x0137, 0x013a, 0x0148,\n            0x014b, 0x0177, 0x00ff, 0x017a, 0x017e, 0x0073, 0x0253, 0x0183, 0x0185, 0x0254, 0x0188, 0x0256, 0x0257,\n            0x018c, 0x01dd, 0x0259, 0x025b, 0x0192, 0x0260, 0x0263, 0x0269, 0x0268, 0x0199, 0x026f, 0x0272, 0x0275,\n            0x01a1, 0x01a5, 0x0280, 0x01a8, 0x0283, 0x01ad, 0x0288, 0x01b0, 0x028a, 0x028b, 0x01b4, 0x01b6, 0x0292,\n            0x01b9, 0x01bd, 0x01c6, 0x01c6, 0x01c9, 0x01c9, 0x01cc, 0x01cc, 0x01dc, 0x01df, 0x01ef, 0x01f3, 0x01f3,\n            0x01f5, 0x0195, 0x01bf, 0x01f9, 0x021f, 0x019e, 0x0223, 0x0233, 0x2c65, 0x023c, 0x019a, 0x2c66, 0x0242,\n            0x0180, 0x0289, 0x028c, 0x0247, 0x024f, 0x03b9, 0x0371, 0x0373, 0x0377, 0x03f3, 0x03ac, 0x03ad, 0x03af,\n            0x03cc, 0x03cd, 0x03ce, 0x03b1, 0x03c1, 0x03c3, 0x03cb, 0x03c3, 0x03d7, 0x03b2, 0x03b8, 0x03c6, 0x03c0,\n            0x03d9, 0x03ef, 0x03ba, 0x03c1, 0x03b8, 0x03b5, 0x03f8, 0x03f2, 0x03fb, 0x037b, 0x037d, 0x0450, 0x045f,\n            0x0430, 0x044f, 0x0461, 0x0481, 0x048b, 0x04bf, 0x04cf, 0x04c2, 0x04ce, 0x04d1, 0x052f, 0x0561, 0x0586,\n            0x2d00, 0x2d25, 0x2d27, 0x2d2d, 0x13f0, 0x13f5, 0x0432, 0x0434, 0x043e, 0x0441, 0x0442, 0x0442, 0x044a,\n            0x0463, 0xa64b, 0x10d0, 0x10fa, 0x10fd, 0x10ff, 0x1e01, 0x1e95, 0x1e61, 0x1ea1, 0x1eff, 0x1f00, 0x1f07,\n            0x1f10, 0x1f15, 0x1f20, 0x1f27, 0x1f30, 0x1f37, 0x1f40, 0x1f45, 0x1f51, 0x1f53, 0x1f55, 0x1f57, 0x1f60,\n            0x1f67, 0x1fb0, 0x1fb1, 0x1f70, 0x1f71, 0x03b9, 0x1f72, 0x1f75, 0x1fd0, 0x1fd1, 0x1f76, 0x1f77, 0x1fe0,\n            0x1fe1, 0x1f7a, 0x1f7b, 0x1fe5, 0x1f78, 0x1f79, 0x1f7c, 0x1f7d, 0x03c9, 0x006b, 0x00e5, 0x214e, 0x2170,\n            0x217f, 0x2184, 0x24d0, 0x24e9, 0x2c30, 0x2c5e, 0x2c61, 0x026b, 0x1d7d, 0x027d, 0x2c68, 0x2c6c, 0x0251,\n            0x0271, 0x0250, 0x0252, 0x2c73, 0x2c76, 0x023f, 0x0240, 0x2c81, 0x2ce3, 0x2cec, 0x2cee, 0x2cf3, 0xa641,\n            0xa66d, 0xa681, 0xa69b, 0xa723, 0xa72f, 0xa733, 0xa76f, 0xa77a, 0xa77c, 0x1d79, 0xa77f, 0xa787, 0xa78c,\n            0x0265, 0xa791, 0xa793, 0xa797, 0xa7a9, 0x0266, 0x025c, 0x0261, 0x026c, 0x026a, 0x029e, 0x0287, 0x029d,\n            0xab53, 0xa7b5, 0xa7bf, 0xa7c3, 0xa794, 0x0282, 0x1d8e, 0xa7c8, 0xa7ca, 0xa7f6, 0x13a0, 0x13ef, 0xff41,\n            0xff5a, 0x10428, 0x1044f, 0x104d8, 0x104fb, 0x10cc0, 0x10cf2, 0x118c0, 0x118df, 0x16e60, 0x16e7f, 0x1e922,\n            0x1e943\n        };\n        static const unsigned FOLD_MAP_2[] = {\n            S(0x00df), S(0x0130), S(0x0149), S(0x01f0), S(0x0587), S(0x1e96), S(0x1e97), S(0x1e98), S(0x1e99),\n            S(0x1e9a), S(0x1e9e), S(0x1f50), R(0x1f80,0x1f87), R(0x1f88,0x1f8f), R(0x1f90,0x1f97), R(0x1f98,0x1f9f),\n            R(0x1fa0,0x1fa7), R(0x1fa8,0x1faf), S(0x1fb2), S(0x1fb3), S(0x1fb4), S(0x1fb6), S(0x1fbc), S(0x1fc2),\n            S(0x1fc3), S(0x1fc4), S(0x1fc6), S(0x1fcc), S(0x1fd6), S(0x1fe4), S(0x1fe6), S(0x1ff2), S(0x1ff3),\n            S(0x1ff4), S(0x1ff6), S(0x1ffc), S(0xfb00), S(0xfb01), S(0xfb02), S(0xfb05), S(0xfb06), S(0xfb13),\n            S(0xfb14), S(0xfb15), S(0xfb16), S(0xfb17)\n        };\n        static const unsigned FOLD_MAP_2_DATA[] = {\n            0x0073,0x0073, 0x0069,0x0307, 0x02bc,0x006e, 0x006a,0x030c, 0x0565,0x0582, 0x0068,0x0331, 0x0074,0x0308,\n            0x0077,0x030a, 0x0079,0x030a, 0x0061,0x02be, 0x0073,0x0073, 0x03c5,0x0313, 0x1f00,0x03b9, 0x1f07,0x03b9,\n            0x1f00,0x03b9, 0x1f07,0x03b9, 0x1f20,0x03b9, 0x1f27,0x03b9, 0x1f20,0x03b9, 0x1f27,0x03b9, 0x1f60,0x03b9,\n            0x1f67,0x03b9, 0x1f60,0x03b9, 0x1f67,0x03b9, 0x1f70,0x03b9, 0x03b1,0x03b9, 0x03ac,0x03b9, 0x03b1,0x0342,\n            0x03b1,0x03b9, 0x1f74,0x03b9, 0x03b7,0x03b9, 0x03ae,0x03b9, 0x03b7,0x0342, 0x03b7,0x03b9, 0x03b9,0x0342,\n            0x03c1,0x0313, 0x03c5,0x0342, 0x1f7c,0x03b9, 0x03c9,0x03b9, 0x03ce,0x03b9, 0x03c9,0x0342, 0x03c9,0x03b9,\n            0x0066,0x0066, 0x0066,0x0069, 0x0066,0x006c, 0x0073,0x0074, 0x0073,0x0074, 0x0574,0x0576, 0x0574,0x0565,\n            0x0574,0x056b, 0x057e,0x0576, 0x0574,0x056d\n        };\n        static const unsigned FOLD_MAP_3[] = {\n            S(0x0390), S(0x03b0), S(0x1f52), S(0x1f54), S(0x1f56), S(0x1fb7), S(0x1fc7), S(0x1fd2), S(0x1fd3),\n            S(0x1fd7), S(0x1fe2), S(0x1fe3), S(0x1fe7), S(0x1ff7), S(0xfb03), S(0xfb04)\n        };\n        static const unsigned FOLD_MAP_3_DATA[] = {\n            0x03b9,0x0308,0x0301, 0x03c5,0x0308,0x0301, 0x03c5,0x0313,0x0300, 0x03c5,0x0313,0x0301,\n            0x03c5,0x0313,0x0342, 0x03b1,0x0342,0x03b9, 0x03b7,0x0342,0x03b9, 0x03b9,0x0308,0x0300,\n            0x03b9,0x0308,0x0301, 0x03b9,0x0308,0x0342, 0x03c5,0x0308,0x0300, 0x03c5,0x0308,0x0301,\n            0x03c5,0x0308,0x0342, 0x03c9,0x0342,0x03b9, 0x0066,0x0066,0x0069, 0x0066,0x0066,0x006c\n        };\n#undef R\n#undef S\n        static const struct {\n            const unsigned* map;\n            const unsigned* data;\n            size_t map_size;\n            unsigned n_codepoints;\n        } FOLD_MAP_LIST[] = {\n            { FOLD_MAP_1, FOLD_MAP_1_DATA, SIZEOF_ARRAY(FOLD_MAP_1), 1 },\n            { FOLD_MAP_2, FOLD_MAP_2_DATA, SIZEOF_ARRAY(FOLD_MAP_2), 2 },\n            { FOLD_MAP_3, FOLD_MAP_3_DATA, SIZEOF_ARRAY(FOLD_MAP_3), 3 }\n        };\n\n        int i;\n\n        /* Fast path for ASCII characters. */\n        if(codepoint <= 0x7f) {\n            info->codepoints[0] = codepoint;\n            if(ISUPPER_(codepoint))\n                info->codepoints[0] += 'a' - 'A';\n            info->n_codepoints = 1;\n            return;\n        }\n\n        /* Try to locate the codepoint in any of the maps. */\n        for(i = 0; i < (int) SIZEOF_ARRAY(FOLD_MAP_LIST); i++) {\n            int index;\n\n            index = md_unicode_bsearch__(codepoint, FOLD_MAP_LIST[i].map, FOLD_MAP_LIST[i].map_size);\n            if(index >= 0) {\n                /* Found the mapping. */\n                unsigned n_codepoints = FOLD_MAP_LIST[i].n_codepoints;\n                const unsigned* map = FOLD_MAP_LIST[i].map;\n                const unsigned* codepoints = FOLD_MAP_LIST[i].data + (index * n_codepoints);\n\n                memcpy(info->codepoints, codepoints, sizeof(unsigned) * n_codepoints);\n                info->n_codepoints = n_codepoints;\n\n                if(FOLD_MAP_LIST[i].map[index] != codepoint) {\n                    /* The found mapping maps whole range of codepoints,\n                     * i.e. we have to offset info->codepoints[0] accordingly. */\n                    if((map[index] & 0x00ffffff)+1 == codepoints[0]) {\n                        /* Alternating type of the range. */\n                        info->codepoints[0] = codepoint + ((codepoint & 0x1) == (map[index] & 0x1) ? 1 : 0);\n                    } else {\n                        /* Range to range kind of mapping. */\n                        info->codepoints[0] += (codepoint - (map[index] & 0x00ffffff));\n                    }\n                }\n\n                return;\n            }\n        }\n\n        /* No mapping found. Map the codepoint to itself. */\n        info->codepoints[0] = codepoint;\n        info->n_codepoints = 1;\n    }\n#endif\n\n\n#if defined MD4C_USE_UTF16\n    #define IS_UTF16_SURROGATE_HI(word)     (((WORD)(word) & 0xfc00) == 0xd800)\n    #define IS_UTF16_SURROGATE_LO(word)     (((WORD)(word) & 0xfc00) == 0xdc00)\n    #define UTF16_DECODE_SURROGATE(hi, lo)  (0x10000 + ((((unsigned)(hi) & 0x3ff) << 10) | (((unsigned)(lo) & 0x3ff) << 0)))\n\n    static unsigned\n    md_decode_utf16le__(const CHAR* str, SZ str_size, SZ* p_size)\n    {\n        if(IS_UTF16_SURROGATE_HI(str[0])) {\n            if(1 < str_size && IS_UTF16_SURROGATE_LO(str[1])) {\n                if(p_size != NULL)\n                    *p_size = 2;\n                return UTF16_DECODE_SURROGATE(str[0], str[1]);\n            }\n        }\n\n        if(p_size != NULL)\n            *p_size = 1;\n        return str[0];\n    }\n\n    static unsigned\n    md_decode_utf16le_before__(MD_CTX* ctx, OFF off)\n    {\n        if(off > 2 && IS_UTF16_SURROGATE_HI(CH(off-2)) && IS_UTF16_SURROGATE_LO(CH(off-1)))\n            return UTF16_DECODE_SURROGATE(CH(off-2), CH(off-1));\n\n        return CH(off);\n    }\n\n    /* No whitespace uses surrogates, so no decoding needed here. */\n    #define ISUNICODEWHITESPACE_(codepoint) md_is_unicode_whitespace__(codepoint)\n    #define ISUNICODEWHITESPACE(off)        md_is_unicode_whitespace__(CH(off))\n    #define ISUNICODEWHITESPACEBEFORE(off)  md_is_unicode_whitespace__(CH((off)-1))\n\n    #define ISUNICODEPUNCT(off)             md_is_unicode_punct__(md_decode_utf16le__(STR(off), ctx->size - (off), NULL))\n    #define ISUNICODEPUNCTBEFORE(off)       md_is_unicode_punct__(md_decode_utf16le_before__(ctx, off))\n\n    static inline int\n    md_decode_unicode(const CHAR* str, OFF off, SZ str_size, SZ* p_char_size)\n    {\n        return md_decode_utf16le__(str+off, str_size-off, p_char_size);\n    }\n#elif defined MD4C_USE_UTF8\n    #define IS_UTF8_LEAD1(byte)     ((unsigned char)(byte) <= 0x7f)\n    #define IS_UTF8_LEAD2(byte)     (((unsigned char)(byte) & 0xe0) == 0xc0)\n    #define IS_UTF8_LEAD3(byte)     (((unsigned char)(byte) & 0xf0) == 0xe0)\n    #define IS_UTF8_LEAD4(byte)     (((unsigned char)(byte) & 0xf8) == 0xf0)\n    #define IS_UTF8_TAIL(byte)      (((unsigned char)(byte) & 0xc0) == 0x80)\n\n    static unsigned\n    md_decode_utf8__(const CHAR* str, SZ str_size, SZ* p_size)\n    {\n        if(!IS_UTF8_LEAD1(str[0])) {\n            if(IS_UTF8_LEAD2(str[0])) {\n                if(1 < str_size && IS_UTF8_TAIL(str[1])) {\n                    if(p_size != NULL)\n                        *p_size = 2;\n\n                    return (((unsigned int)str[0] & 0x1f) << 6) |\n                           (((unsigned int)str[1] & 0x3f) << 0);\n                }\n            } else if(IS_UTF8_LEAD3(str[0])) {\n                if(2 < str_size && IS_UTF8_TAIL(str[1]) && IS_UTF8_TAIL(str[2])) {\n                    if(p_size != NULL)\n                        *p_size = 3;\n\n                    return (((unsigned int)str[0] & 0x0f) << 12) |\n                           (((unsigned int)str[1] & 0x3f) << 6) |\n                           (((unsigned int)str[2] & 0x3f) << 0);\n                }\n            } else if(IS_UTF8_LEAD4(str[0])) {\n                if(3 < str_size && IS_UTF8_TAIL(str[1]) && IS_UTF8_TAIL(str[2]) && IS_UTF8_TAIL(str[3])) {\n                    if(p_size != NULL)\n                        *p_size = 4;\n\n                    return (((unsigned int)str[0] & 0x07) << 18) |\n                           (((unsigned int)str[1] & 0x3f) << 12) |\n                           (((unsigned int)str[2] & 0x3f) << 6) |\n                           (((unsigned int)str[3] & 0x3f) << 0);\n                }\n            }\n        }\n\n        if(p_size != NULL)\n            *p_size = 1;\n        return (unsigned) str[0];\n    }\n\n    static unsigned\n    md_decode_utf8_before__(MD_CTX* ctx, OFF off)\n    {\n        if(!IS_UTF8_LEAD1(CH(off-1))) {\n            if(off > 1 && IS_UTF8_LEAD2(CH(off-2)) && IS_UTF8_TAIL(CH(off-1)))\n                return (((unsigned int)CH(off-2) & 0x1f) << 6) |\n                       (((unsigned int)CH(off-1) & 0x3f) << 0);\n\n            if(off > 2 && IS_UTF8_LEAD3(CH(off-3)) && IS_UTF8_TAIL(CH(off-2)) && IS_UTF8_TAIL(CH(off-1)))\n                return (((unsigned int)CH(off-3) & 0x0f) << 12) |\n                       (((unsigned int)CH(off-2) & 0x3f) << 6) |\n                       (((unsigned int)CH(off-1) & 0x3f) << 0);\n\n            if(off > 3 && IS_UTF8_LEAD4(CH(off-4)) && IS_UTF8_TAIL(CH(off-3)) && IS_UTF8_TAIL(CH(off-2)) && IS_UTF8_TAIL(CH(off-1)))\n                return (((unsigned int)CH(off-4) & 0x07) << 18) |\n                       (((unsigned int)CH(off-3) & 0x3f) << 12) |\n                       (((unsigned int)CH(off-2) & 0x3f) << 6) |\n                       (((unsigned int)CH(off-1) & 0x3f) << 0);\n        }\n\n        return (unsigned) CH(off-1);\n    }\n\n    #define ISUNICODEWHITESPACE_(codepoint) md_is_unicode_whitespace__(codepoint)\n    #define ISUNICODEWHITESPACE(off)        md_is_unicode_whitespace__(md_decode_utf8__(STR(off), ctx->size - (off), NULL))\n    #define ISUNICODEWHITESPACEBEFORE(off)  md_is_unicode_whitespace__(md_decode_utf8_before__(ctx, off))\n\n    #define ISUNICODEPUNCT(off)             md_is_unicode_punct__(md_decode_utf8__(STR(off), ctx->size - (off), NULL))\n    #define ISUNICODEPUNCTBEFORE(off)       md_is_unicode_punct__(md_decode_utf8_before__(ctx, off))\n\n    static inline unsigned\n    md_decode_unicode(const CHAR* str, OFF off, SZ str_size, SZ* p_char_size)\n    {\n        return md_decode_utf8__(str+off, str_size-off, p_char_size);\n    }\n#else\n    #define ISUNICODEWHITESPACE_(codepoint) ISWHITESPACE_(codepoint)\n    #define ISUNICODEWHITESPACE(off)        ISWHITESPACE(off)\n    #define ISUNICODEWHITESPACEBEFORE(off)  ISWHITESPACE((off)-1)\n\n    #define ISUNICODEPUNCT(off)             ISPUNCT(off)\n    #define ISUNICODEPUNCTBEFORE(off)       ISPUNCT((off)-1)\n\n    static inline void\n    md_get_unicode_fold_info(unsigned codepoint, MD_UNICODE_FOLD_INFO* info)\n    {\n        info->codepoints[0] = codepoint;\n        if(ISUPPER_(codepoint))\n            info->codepoints[0] += 'a' - 'A';\n        info->n_codepoints = 1;\n    }\n\n    static inline unsigned\n    md_decode_unicode(const CHAR* str, OFF off, SZ str_size, SZ* p_size)\n    {\n        *p_size = 1;\n        return (unsigned) str[off];\n    }\n#endif\n\n\n/*************************************\n ***  Helper string manipulations  ***\n *************************************/\n\n/* Fill buffer with copy of the string between 'beg' and 'end' but replace any\n * line breaks with given replacement character.\n *\n * NOTE: Caller is responsible to make sure the buffer is large enough.\n * (Given the output is always shorter then input, (end - beg) is good idea\n * what the caller should allocate.)\n */\nstatic void\nmd_merge_lines(MD_CTX* ctx, OFF beg, OFF end, const MD_LINE* lines, int n_lines,\n               CHAR line_break_replacement_char, CHAR* buffer, SZ* p_size)\n{\n    CHAR* ptr = buffer;\n    int line_index = 0;\n    OFF off = beg;\n\n    MD_UNUSED(n_lines);\n\n    while(1) {\n        const MD_LINE* line = &lines[line_index];\n        OFF line_end = line->end;\n        if(end < line_end)\n            line_end = end;\n\n        while(off < line_end) {\n            *ptr = CH(off);\n            ptr++;\n            off++;\n        }\n\n        if(off >= end) {\n            *p_size = ptr - buffer;\n            return;\n        }\n\n        *ptr = line_break_replacement_char;\n        ptr++;\n\n        line_index++;\n        off = lines[line_index].beg;\n    }\n}\n\n/* Wrapper of md_merge_lines() which allocates new buffer for the output string.\n */\nstatic int\nmd_merge_lines_alloc(MD_CTX* ctx, OFF beg, OFF end, const MD_LINE* lines, int n_lines,\n                    CHAR line_break_replacement_char, CHAR** p_str, SZ* p_size)\n{\n    CHAR* buffer;\n\n    buffer = (CHAR*) malloc(sizeof(CHAR) * (end - beg));\n    if(buffer == NULL) {\n        MD_LOG(\"malloc() failed.\");\n        return -1;\n    }\n\n    md_merge_lines(ctx, beg, end, lines, n_lines,\n                line_break_replacement_char, buffer, p_size);\n\n    *p_str = buffer;\n    return 0;\n}\n\nstatic OFF\nmd_skip_unicode_whitespace(const CHAR* label, OFF off, SZ size)\n{\n    SZ char_size;\n    unsigned codepoint;\n\n    while(off < size) {\n        codepoint = md_decode_unicode(label, off, size, &char_size);\n        if(!ISUNICODEWHITESPACE_(codepoint)  &&  !ISNEWLINE_(label[off]))\n            break;\n        off += char_size;\n    }\n\n    return off;\n}\n\n\n/******************************\n ***  Recognizing raw HTML  ***\n ******************************/\n\n/* md_is_html_tag() may be called when processing inlines (inline raw HTML)\n * or when breaking document to blocks (checking for start of HTML block type 7).\n *\n * When breaking document to blocks, we do not yet know line boundaries, but\n * in that case the whole tag has to live on a single line. We distinguish this\n * by n_lines == 0.\n */\nstatic int\nmd_is_html_tag(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)\n{\n    int attr_state;\n    OFF off = beg;\n    OFF line_end = (n_lines > 0) ? lines[0].end : ctx->size;\n    int i = 0;\n\n    MD_ASSERT(CH(beg) == _T('<'));\n\n    if(off + 1 >= line_end)\n        return FALSE;\n    off++;\n\n    /* For parsing attributes, we need a little state automaton below.\n     * State -1: no attributes are allowed.\n     * State 0: attribute could follow after some whitespace.\n     * State 1: after a whitespace (attribute name may follow).\n     * State 2: after attribute name ('=' MAY follow).\n     * State 3: after '=' (value specification MUST follow).\n     * State 41: in middle of unquoted attribute value.\n     * State 42: in middle of single-quoted attribute value.\n     * State 43: in middle of double-quoted attribute value.\n     */\n    attr_state = 0;\n\n    if(CH(off) == _T('/')) {\n        /* Closer tag \"</ ... >\". No attributes may be present. */\n        attr_state = -1;\n        off++;\n    }\n\n    /* Tag name */\n    if(off >= line_end  ||  !ISALPHA(off))\n        return FALSE;\n    off++;\n    while(off < line_end  &&  (ISALNUM(off)  ||  CH(off) == _T('-')))\n        off++;\n\n    /* (Optional) attributes (if not closer), (optional) '/' (if not closer)\n     * and final '>'. */\n    while(1) {\n        while(off < line_end  &&  !ISNEWLINE(off)) {\n            if(attr_state > 40) {\n                if(attr_state == 41 && (ISBLANK(off) || ISANYOF(off, _T(\"\\\"'=<>`\")))) {\n                    attr_state = 0;\n                    off--;  /* Put the char back for re-inspection in the new state. */\n                } else if(attr_state == 42 && CH(off) == _T('\\'')) {\n                    attr_state = 0;\n                } else if(attr_state == 43 && CH(off) == _T('\"')) {\n                    attr_state = 0;\n                }\n                off++;\n            } else if(ISWHITESPACE(off)) {\n                if(attr_state == 0)\n                    attr_state = 1;\n                off++;\n            } else if(attr_state <= 2 && CH(off) == _T('>')) {\n                /* End. */\n                goto done;\n            } else if(attr_state <= 2 && CH(off) == _T('/') && off+1 < line_end && CH(off+1) == _T('>')) {\n                /* End with digraph '/>' */\n                off++;\n                goto done;\n            } else if((attr_state == 1 || attr_state == 2) && (ISALPHA(off) || CH(off) == _T('_') || CH(off) == _T(':'))) {\n                off++;\n                /* Attribute name */\n                while(off < line_end && (ISALNUM(off) || ISANYOF(off, _T(\"_.:-\"))))\n                    off++;\n                attr_state = 2;\n            } else if(attr_state == 2 && CH(off) == _T('=')) {\n                /* Attribute assignment sign */\n                off++;\n                attr_state = 3;\n            } else if(attr_state == 3) {\n                /* Expecting start of attribute value. */\n                if(CH(off) == _T('\"'))\n                    attr_state = 43;\n                else if(CH(off) == _T('\\''))\n                    attr_state = 42;\n                else if(!ISANYOF(off, _T(\"\\\"'=<>`\"))  &&  !ISNEWLINE(off))\n                    attr_state = 41;\n                else\n                    return FALSE;\n                off++;\n            } else {\n                /* Anything unexpected. */\n                return FALSE;\n            }\n        }\n\n        /* We have to be on a single line. See definition of start condition\n         * of HTML block, type 7. */\n        if(n_lines == 0)\n            return FALSE;\n\n        i++;\n        if(i >= n_lines)\n            return FALSE;\n\n        off = lines[i].beg;\n        line_end = lines[i].end;\n\n        if(attr_state == 0  ||  attr_state == 41)\n            attr_state = 1;\n\n        if(off >= max_end)\n            return FALSE;\n    }\n\ndone:\n    if(off >= max_end)\n        return FALSE;\n\n    *p_end = off+1;\n    return TRUE;\n}\n\nstatic int\nmd_scan_for_html_closer(MD_CTX* ctx, const MD_CHAR* str, MD_SIZE len,\n                        const MD_LINE* lines, int n_lines,\n                        OFF beg, OFF max_end, OFF* p_end,\n                        OFF* p_scan_horizon)\n{\n    OFF off = beg;\n    int i = 0;\n\n    if(off < *p_scan_horizon  &&  *p_scan_horizon >= max_end - len) {\n        /* We have already scanned the range up to the max_end so we know\n         * there is nothing to see. */\n        return FALSE;\n    }\n\n    while(TRUE) {\n        while(off + len <= lines[i].end  &&  off + len <= max_end) {\n            if(md_ascii_eq(STR(off), str, len)) {\n                /* Success. */\n                *p_end = off + len;\n                return TRUE;\n            }\n            off++;\n        }\n\n        i++;\n        if(off >= max_end  ||  i >= n_lines) {\n            /* Failure. */\n            *p_scan_horizon = off;\n            return FALSE;\n        }\n\n        off = lines[i].beg;\n    }\n}\n\nstatic int\nmd_is_html_comment(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)\n{\n    OFF off = beg;\n\n    MD_ASSERT(CH(beg) == _T('<'));\n\n    if(off + 4 >= lines[0].end)\n        return FALSE;\n    if(CH(off+1) != _T('!')  ||  CH(off+2) != _T('-')  ||  CH(off+3) != _T('-'))\n        return FALSE;\n    off += 4;\n\n    /* \">\" and \"->\" must not follow the opening. */\n    if(off < lines[0].end  &&  CH(off) == _T('>'))\n        return FALSE;\n    if(off+1 < lines[0].end  &&  CH(off) == _T('-')  &&  CH(off+1) == _T('>'))\n        return FALSE;\n\n    /* HTML comment must not contain \"--\", so we scan just for \"--\" instead\n     * of \"-->\" and verify manually that '>' follows. */\n    if(md_scan_for_html_closer(ctx, _T(\"--\"), 2,\n                lines, n_lines, off, max_end, p_end, &ctx->html_comment_horizon))\n    {\n        if(*p_end < max_end  &&  CH(*p_end) == _T('>')) {\n            *p_end = *p_end + 1;\n            return TRUE;\n        }\n    }\n\n    return FALSE;\n}\n\nstatic int\nmd_is_html_processing_instruction(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)\n{\n    OFF off = beg;\n\n    if(off + 2 >= lines[0].end)\n        return FALSE;\n    if(CH(off+1) != _T('?'))\n        return FALSE;\n    off += 2;\n\n    return md_scan_for_html_closer(ctx, _T(\"?>\"), 2,\n                lines, n_lines, off, max_end, p_end, &ctx->html_proc_instr_horizon);\n}\n\nstatic int\nmd_is_html_declaration(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)\n{\n    OFF off = beg;\n\n    if(off + 2 >= lines[0].end)\n        return FALSE;\n    if(CH(off+1) != _T('!'))\n        return FALSE;\n    off += 2;\n\n    /* Declaration name. */\n    if(off >= lines[0].end  ||  !ISALPHA(off))\n        return FALSE;\n    off++;\n    while(off < lines[0].end  &&  ISALPHA(off))\n        off++;\n    if(off < lines[0].end  &&  !ISWHITESPACE(off))\n        return FALSE;\n\n    return md_scan_for_html_closer(ctx, _T(\">\"), 1,\n                lines, n_lines, off, max_end, p_end, &ctx->html_decl_horizon);\n}\n\nstatic int\nmd_is_html_cdata(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)\n{\n    static const CHAR open_str[] = _T(\"<![CDATA[\");\n    static const SZ open_size = SIZEOF_ARRAY(open_str) - 1;\n\n    OFF off = beg;\n\n    if(off + open_size >= lines[0].end)\n        return FALSE;\n    if(memcmp(STR(off), open_str, open_size) != 0)\n        return FALSE;\n    off += open_size;\n\n    if(lines[n_lines-1].end < max_end)\n        max_end = lines[n_lines-1].end - 2;\n\n    return md_scan_for_html_closer(ctx, _T(\"]]>\"), 3,\n                lines, n_lines, off, max_end, p_end, &ctx->html_cdata_horizon);\n}\n\nstatic int\nmd_is_html_any(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)\n{\n    MD_ASSERT(CH(beg) == _T('<'));\n    return (md_is_html_tag(ctx, lines, n_lines, beg, max_end, p_end)  ||\n            md_is_html_comment(ctx, lines, n_lines, beg, max_end, p_end)  ||\n            md_is_html_processing_instruction(ctx, lines, n_lines, beg, max_end, p_end)  ||\n            md_is_html_declaration(ctx, lines, n_lines, beg, max_end, p_end)  ||\n            md_is_html_cdata(ctx, lines, n_lines, beg, max_end, p_end));\n}\n\n\n/****************************\n ***  Recognizing Entity  ***\n ****************************/\n\nstatic int\nmd_is_hex_entity_contents(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)\n{\n    OFF off = beg;\n    MD_UNUSED(ctx);\n\n    while(off < max_end  &&  ISXDIGIT_(text[off])  &&  off - beg <= 8)\n        off++;\n\n    if(1 <= off - beg  &&  off - beg <= 6) {\n        *p_end = off;\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}\n\nstatic int\nmd_is_dec_entity_contents(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)\n{\n    OFF off = beg;\n    MD_UNUSED(ctx);\n\n    while(off < max_end  &&  ISDIGIT_(text[off])  &&  off - beg <= 8)\n        off++;\n\n    if(1 <= off - beg  &&  off - beg <= 7) {\n        *p_end = off;\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}\n\nstatic int\nmd_is_named_entity_contents(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)\n{\n    OFF off = beg;\n    MD_UNUSED(ctx);\n\n    if(off < max_end  &&  ISALPHA_(text[off]))\n        off++;\n    else\n        return FALSE;\n\n    while(off < max_end  &&  ISALNUM_(text[off])  &&  off - beg <= 48)\n        off++;\n\n    if(2 <= off - beg  &&  off - beg <= 48) {\n        *p_end = off;\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}\n\nstatic int\nmd_is_entity_str(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)\n{\n    int is_contents;\n    OFF off = beg;\n\n    MD_ASSERT(text[off] == _T('&'));\n    off++;\n\n    if(off+2 < max_end  &&  text[off] == _T('#')  &&  (text[off+1] == _T('x') || text[off+1] == _T('X')))\n        is_contents = md_is_hex_entity_contents(ctx, text, off+2, max_end, &off);\n    else if(off+1 < max_end  &&  text[off] == _T('#'))\n        is_contents = md_is_dec_entity_contents(ctx, text, off+1, max_end, &off);\n    else\n        is_contents = md_is_named_entity_contents(ctx, text, off, max_end, &off);\n\n    if(is_contents  &&  off < max_end  &&  text[off] == _T(';')) {\n        *p_end = off+1;\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}\n\nstatic inline int\nmd_is_entity(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end)\n{\n    return md_is_entity_str(ctx, ctx->text, beg, max_end, p_end);\n}\n\n\n/******************************\n ***  Attribute Management  ***\n ******************************/\n\ntypedef struct MD_ATTRIBUTE_BUILD_tag MD_ATTRIBUTE_BUILD;\nstruct MD_ATTRIBUTE_BUILD_tag {\n    CHAR* text;\n    MD_TEXTTYPE* substr_types;\n    OFF* substr_offsets;\n    int substr_count;\n    int substr_alloc;\n    MD_TEXTTYPE trivial_types[1];\n    OFF trivial_offsets[2];\n};\n\n\n#define MD_BUILD_ATTR_NO_ESCAPES    0x0001\n\nstatic int\nmd_build_attr_append_substr(MD_CTX* ctx, MD_ATTRIBUTE_BUILD* build,\n                            MD_TEXTTYPE type, OFF off)\n{\n    if(build->substr_count >= build->substr_alloc) {\n        MD_TEXTTYPE* new_substr_types;\n        OFF* new_substr_offsets;\n\n        build->substr_alloc = (build->substr_alloc > 0\n                ? build->substr_alloc + build->substr_alloc / 2\n                : 8);\n        new_substr_types = (MD_TEXTTYPE*) realloc(build->substr_types,\n                                    build->substr_alloc * sizeof(MD_TEXTTYPE));\n        if(new_substr_types == NULL) {\n            MD_LOG(\"realloc() failed.\");\n            return -1;\n        }\n        /* Note +1 to reserve space for final offset (== raw_size). */\n        new_substr_offsets = (OFF*) realloc(build->substr_offsets,\n                                    (build->substr_alloc+1) * sizeof(OFF));\n        if(new_substr_offsets == NULL) {\n            MD_LOG(\"realloc() failed.\");\n            free(new_substr_types);\n            return -1;\n        }\n\n        build->substr_types = new_substr_types;\n        build->substr_offsets = new_substr_offsets;\n    }\n\n    build->substr_types[build->substr_count] = type;\n    build->substr_offsets[build->substr_count] = off;\n    build->substr_count++;\n    return 0;\n}\n\nstatic void\nmd_free_attribute(MD_CTX* ctx, MD_ATTRIBUTE_BUILD* build)\n{\n    MD_UNUSED(ctx);\n\n    if(build->substr_alloc > 0) {\n        free(build->text);\n        free(build->substr_types);\n        free(build->substr_offsets);\n    }\n}\n\nstatic int\nmd_build_attribute(MD_CTX* ctx, const CHAR* raw_text, SZ raw_size,\n                   unsigned flags, MD_ATTRIBUTE* attr, MD_ATTRIBUTE_BUILD* build)\n{\n    OFF raw_off, off;\n    int is_trivial;\n    int ret = 0;\n\n    memset(build, 0, sizeof(MD_ATTRIBUTE_BUILD));\n\n    /* If there is no backslash and no ampersand, build trivial attribute\n     * without any malloc(). */\n    is_trivial = TRUE;\n    for(raw_off = 0; raw_off < raw_size; raw_off++) {\n        if(ISANYOF3_(raw_text[raw_off], _T('\\\\'), _T('&'), _T('\\0'))) {\n            is_trivial = FALSE;\n            break;\n        }\n    }\n\n    if(is_trivial) {\n        build->text = (CHAR*) (raw_size ? raw_text : NULL);\n        build->substr_types = build->trivial_types;\n        build->substr_offsets = build->trivial_offsets;\n        build->substr_count = 1;\n        build->substr_alloc = 0;\n        build->trivial_types[0] = MD_TEXT_NORMAL;\n        build->trivial_offsets[0] = 0;\n        build->trivial_offsets[1] = raw_size;\n        off = raw_size;\n    } else {\n        build->text = (CHAR*) malloc(raw_size * sizeof(CHAR));\n        if(build->text == NULL) {\n            MD_LOG(\"malloc() failed.\");\n            goto abort;\n        }\n\n        raw_off = 0;\n        off = 0;\n\n        while(raw_off < raw_size) {\n            if(raw_text[raw_off] == _T('\\0')) {\n                MD_CHECK(md_build_attr_append_substr(ctx, build, MD_TEXT_NULLCHAR, off));\n                memcpy(build->text + off, raw_text + raw_off, 1);\n                off++;\n                raw_off++;\n                continue;\n            }\n\n            if(raw_text[raw_off] == _T('&')) {\n                OFF ent_end;\n\n                if(md_is_entity_str(ctx, raw_text, raw_off, raw_size, &ent_end)) {\n                    MD_CHECK(md_build_attr_append_substr(ctx, build, MD_TEXT_ENTITY, off));\n                    memcpy(build->text + off, raw_text + raw_off, ent_end - raw_off);\n                    off += ent_end - raw_off;\n                    raw_off = ent_end;\n                    continue;\n                }\n            }\n\n            if(build->substr_count == 0  ||  build->substr_types[build->substr_count-1] != MD_TEXT_NORMAL)\n                MD_CHECK(md_build_attr_append_substr(ctx, build, MD_TEXT_NORMAL, off));\n\n            if(!(flags & MD_BUILD_ATTR_NO_ESCAPES)  &&\n               raw_text[raw_off] == _T('\\\\')  &&  raw_off+1 < raw_size  &&\n               (ISPUNCT_(raw_text[raw_off+1]) || ISNEWLINE_(raw_text[raw_off+1])))\n                raw_off++;\n\n            build->text[off++] = raw_text[raw_off++];\n        }\n        build->substr_offsets[build->substr_count] = off;\n    }\n\n    attr->text = build->text;\n    attr->size = off;\n    attr->substr_offsets = build->substr_offsets;\n    attr->substr_types = build->substr_types;\n    return 0;\n\nabort:\n    md_free_attribute(ctx, build);\n    return -1;\n}\n\n\n/*********************************************\n ***  Dictionary of Reference Definitions  ***\n *********************************************/\n\n#define MD_FNV1A_BASE       2166136261U\n#define MD_FNV1A_PRIME      16777619U\n\nstatic inline unsigned\nmd_fnv1a(unsigned base, const void* data, size_t n)\n{\n    const unsigned char* buf = (const unsigned char*) data;\n    unsigned hash = base;\n    size_t i;\n\n    for(i = 0; i < n; i++) {\n        hash ^= buf[i];\n        hash *= MD_FNV1A_PRIME;\n    }\n\n    return hash;\n}\n\n\nstruct MD_REF_DEF_tag {\n    CHAR* label;\n    CHAR* title;\n    unsigned hash;\n    SZ label_size;\n    SZ title_size;\n    OFF dest_beg;\n    OFF dest_end;\n    unsigned char label_needs_free : 1;\n    unsigned char title_needs_free : 1;\n};\n\n/* Label equivalence is quite complicated with regards to whitespace and case\n * folding. This complicates computing a hash of it as well as direct comparison\n * of two labels. */\n\nstatic unsigned\nmd_link_label_hash(const CHAR* label, SZ size)\n{\n    unsigned hash = MD_FNV1A_BASE;\n    OFF off;\n    unsigned codepoint;\n    int is_whitespace = FALSE;\n\n    off = md_skip_unicode_whitespace(label, 0, size);\n    while(off < size) {\n        SZ char_size;\n\n        codepoint = md_decode_unicode(label, off, size, &char_size);\n        is_whitespace = ISUNICODEWHITESPACE_(codepoint) || ISNEWLINE_(label[off]);\n\n        if(is_whitespace) {\n            codepoint = ' ';\n            hash = md_fnv1a(hash, &codepoint, sizeof(unsigned));\n            off = md_skip_unicode_whitespace(label, off, size);\n        } else {\n            MD_UNICODE_FOLD_INFO fold_info;\n\n            md_get_unicode_fold_info(codepoint, &fold_info);\n            hash = md_fnv1a(hash, fold_info.codepoints, fold_info.n_codepoints * sizeof(unsigned));\n            off += char_size;\n        }\n    }\n\n    return hash;\n}\n\nstatic OFF\nmd_link_label_cmp_load_fold_info(const CHAR* label, OFF off, SZ size,\n                                 MD_UNICODE_FOLD_INFO* fold_info)\n{\n    unsigned codepoint;\n    SZ char_size;\n\n    if(off >= size) {\n        /* Treat end of a link label as a whitespace. */\n        goto whitespace;\n    }\n\n    codepoint = md_decode_unicode(label, off, size, &char_size);\n    off += char_size;\n    if(ISUNICODEWHITESPACE_(codepoint)) {\n        /* Treat all whitespace as equivalent */\n        goto whitespace;\n    }\n\n    /* Get real folding info. */\n    md_get_unicode_fold_info(codepoint, fold_info);\n    return off;\n\nwhitespace:\n    fold_info->codepoints[0] = _T(' ');\n    fold_info->n_codepoints = 1;\n    return md_skip_unicode_whitespace(label, off, size);\n}\n\nstatic int\nmd_link_label_cmp(const CHAR* a_label, SZ a_size, const CHAR* b_label, SZ b_size)\n{\n    OFF a_off;\n    OFF b_off;\n    MD_UNICODE_FOLD_INFO a_fi = { { 0 }, 0 };\n    MD_UNICODE_FOLD_INFO b_fi = { { 0 }, 0 };\n    OFF a_fi_off = 0;\n    OFF b_fi_off = 0;\n    int cmp;\n\n    a_off = md_skip_unicode_whitespace(a_label, 0, a_size);\n    b_off = md_skip_unicode_whitespace(b_label, 0, b_size);\n    while(a_off < a_size || a_fi_off < a_fi.n_codepoints ||\n          b_off < b_size || b_fi_off < b_fi.n_codepoints)\n    {\n        /* If needed, load fold info for next char. */\n        if(a_fi_off >= a_fi.n_codepoints) {\n            a_fi_off = 0;\n            a_off = md_link_label_cmp_load_fold_info(a_label, a_off, a_size, &a_fi);\n        }\n        if(b_fi_off >= b_fi.n_codepoints) {\n            b_fi_off = 0;\n            b_off = md_link_label_cmp_load_fold_info(b_label, b_off, b_size, &b_fi);\n        }\n\n        cmp = b_fi.codepoints[b_fi_off] - a_fi.codepoints[a_fi_off];\n        if(cmp != 0)\n            return cmp;\n\n        a_fi_off++;\n        b_fi_off++;\n    }\n\n    return 0;\n}\n\ntypedef struct MD_REF_DEF_LIST_tag MD_REF_DEF_LIST;\nstruct MD_REF_DEF_LIST_tag {\n    int n_ref_defs;\n    int alloc_ref_defs;\n    MD_REF_DEF* ref_defs[];  /* Valid items always  point into ctx->ref_defs[] */\n};\n\nstatic int\nmd_ref_def_cmp(const void* a, const void* b)\n{\n    const MD_REF_DEF* a_ref = *(const MD_REF_DEF**)a;\n    const MD_REF_DEF* b_ref = *(const MD_REF_DEF**)b;\n\n    if(a_ref->hash < b_ref->hash)\n        return -1;\n    else if(a_ref->hash > b_ref->hash)\n        return +1;\n    else\n        return md_link_label_cmp(a_ref->label, a_ref->label_size, b_ref->label, b_ref->label_size);\n}\n\nstatic int\nmd_ref_def_cmp_for_sort(const void* a, const void* b)\n{\n    int cmp;\n\n    cmp = md_ref_def_cmp(a, b);\n\n    /* Ensure stability of the sorting. */\n    if(cmp == 0) {\n        const MD_REF_DEF* a_ref = *(const MD_REF_DEF**)a;\n        const MD_REF_DEF* b_ref = *(const MD_REF_DEF**)b;\n\n        if(a_ref < b_ref)\n            cmp = -1;\n        else if(a_ref > b_ref)\n            cmp = +1;\n        else\n            cmp = 0;\n    }\n\n    return cmp;\n}\n\nstatic int\nmd_build_ref_def_hashtable(MD_CTX* ctx)\n{\n    int i, j;\n\n    if(ctx->n_ref_defs == 0)\n        return 0;\n\n    ctx->ref_def_hashtable_size = (ctx->n_ref_defs * 5) / 4;\n    ctx->ref_def_hashtable = malloc(ctx->ref_def_hashtable_size * sizeof(void*));\n    if(ctx->ref_def_hashtable == NULL) {\n        MD_LOG(\"malloc() failed.\");\n        goto abort;\n    }\n    memset(ctx->ref_def_hashtable, 0, ctx->ref_def_hashtable_size * sizeof(void*));\n\n    /* Each member of ctx->ref_def_hashtable[] can be:\n     *  -- NULL,\n     *  -- pointer to the MD_REF_DEF in ctx->ref_defs[], or\n     *  -- pointer to a MD_REF_DEF_LIST, which holds multiple pointers to\n     *     such MD_REF_DEFs.\n     */\n    for(i = 0; i < ctx->n_ref_defs; i++) {\n        MD_REF_DEF* def = &ctx->ref_defs[i];\n        void* bucket;\n        MD_REF_DEF_LIST* list;\n\n        def->hash = md_link_label_hash(def->label, def->label_size);\n        bucket = ctx->ref_def_hashtable[def->hash % ctx->ref_def_hashtable_size];\n\n        if(bucket == NULL) {\n            /* The bucket is empty. Make it just point to the def. */\n            ctx->ref_def_hashtable[def->hash % ctx->ref_def_hashtable_size] = def;\n            continue;\n        }\n\n        if(ctx->ref_defs <= (MD_REF_DEF*) bucket  &&  (MD_REF_DEF*) bucket < ctx->ref_defs + ctx->n_ref_defs) {\n            /* The bucket already contains one ref. def. Lets see whether it\n             * is the same label (ref. def. duplicate) or different one\n             * (hash conflict). */\n            MD_REF_DEF* old_def = (MD_REF_DEF*) bucket;\n\n            if(md_link_label_cmp(def->label, def->label_size, old_def->label, old_def->label_size) == 0) {\n                /* Duplicate label: Ignore this ref. def. */\n                continue;\n            }\n\n            /* Make the bucket complex, i.e. able to hold more ref. defs. */\n            list = (MD_REF_DEF_LIST*) malloc(sizeof(MD_REF_DEF_LIST) + 2 * sizeof(MD_REF_DEF*));\n            if(list == NULL) {\n                MD_LOG(\"malloc() failed.\");\n                goto abort;\n            }\n            list->ref_defs[0] = old_def;\n            list->ref_defs[1] = def;\n            list->n_ref_defs = 2;\n            list->alloc_ref_defs = 2;\n            ctx->ref_def_hashtable[def->hash % ctx->ref_def_hashtable_size] = list;\n            continue;\n        }\n\n        /* Append the def to the complex bucket list.\n         *\n         * Note in this case we ignore potential duplicates to avoid expensive\n         * iterating over the complex bucket. Below, we revisit all the complex\n         * buckets and handle it more cheaply after the complex bucket contents\n         * is sorted. */\n        list = (MD_REF_DEF_LIST*) bucket;\n        if(list->n_ref_defs >= list->alloc_ref_defs) {\n            int alloc_ref_defs = list->alloc_ref_defs + list->alloc_ref_defs / 2;\n            MD_REF_DEF_LIST* list_tmp = (MD_REF_DEF_LIST*) realloc(list,\n                        sizeof(MD_REF_DEF_LIST) + alloc_ref_defs * sizeof(MD_REF_DEF*));\n            if(list_tmp == NULL) {\n                MD_LOG(\"realloc() failed.\");\n                goto abort;\n            }\n            list = list_tmp;\n            list->alloc_ref_defs = alloc_ref_defs;\n            ctx->ref_def_hashtable[def->hash % ctx->ref_def_hashtable_size] = list;\n        }\n\n        list->ref_defs[list->n_ref_defs] = def;\n        list->n_ref_defs++;\n    }\n\n    /* Sort the complex buckets so we can use bsearch() with them. */\n    for(i = 0; i < ctx->ref_def_hashtable_size; i++) {\n        void* bucket = ctx->ref_def_hashtable[i];\n        MD_REF_DEF_LIST* list;\n\n        if(bucket == NULL)\n            continue;\n        if(ctx->ref_defs <= (MD_REF_DEF*) bucket  &&  (MD_REF_DEF*) bucket < ctx->ref_defs + ctx->n_ref_defs)\n            continue;\n\n        list = (MD_REF_DEF_LIST*) bucket;\n        qsort(list->ref_defs, list->n_ref_defs, sizeof(MD_REF_DEF*), md_ref_def_cmp_for_sort);\n\n        /* Disable all duplicates in the complex bucket by forcing all such\n         * records to point to the 1st such ref. def. I.e. no matter which\n         * record is found during the lookup, it will always point to the right\n         * ref. def. in ctx->ref_defs[]. */\n        for(j = 1; j < list->n_ref_defs; j++) {\n            if(md_ref_def_cmp(&list->ref_defs[j-1], &list->ref_defs[j]) == 0)\n                list->ref_defs[j] = list->ref_defs[j-1];\n        }\n    }\n\n    return 0;\n\nabort:\n    return -1;\n}\n\nstatic void\nmd_free_ref_def_hashtable(MD_CTX* ctx)\n{\n    if(ctx->ref_def_hashtable != NULL) {\n        int i;\n\n        for(i = 0; i < ctx->ref_def_hashtable_size; i++) {\n            void* bucket = ctx->ref_def_hashtable[i];\n            if(bucket == NULL)\n                continue;\n            if(ctx->ref_defs <= (MD_REF_DEF*) bucket  &&  (MD_REF_DEF*) bucket < ctx->ref_defs + ctx->n_ref_defs)\n                continue;\n            free(bucket);\n        }\n\n        free(ctx->ref_def_hashtable);\n    }\n}\n\nstatic const MD_REF_DEF*\nmd_lookup_ref_def(MD_CTX* ctx, const CHAR* label, SZ label_size)\n{\n    unsigned hash;\n    void* bucket;\n\n    if(ctx->ref_def_hashtable_size == 0)\n        return NULL;\n\n    hash = md_link_label_hash(label, label_size);\n    bucket = ctx->ref_def_hashtable[hash % ctx->ref_def_hashtable_size];\n\n    if(bucket == NULL) {\n        return NULL;\n    } else if(ctx->ref_defs <= (MD_REF_DEF*) bucket  &&  (MD_REF_DEF*) bucket < ctx->ref_defs + ctx->n_ref_defs) {\n        const MD_REF_DEF* def = (MD_REF_DEF*) bucket;\n\n        if(md_link_label_cmp(def->label, def->label_size, label, label_size) == 0)\n            return def;\n        else\n            return NULL;\n    } else {\n        MD_REF_DEF_LIST* list = (MD_REF_DEF_LIST*) bucket;\n        MD_REF_DEF key_buf;\n        const MD_REF_DEF* key = &key_buf;\n        const MD_REF_DEF** ret;\n\n        key_buf.label = (CHAR*) label;\n        key_buf.label_size = label_size;\n        key_buf.hash = md_link_label_hash(key_buf.label, key_buf.label_size);\n\n        ret = (const MD_REF_DEF**) bsearch(&key, list->ref_defs,\n                    list->n_ref_defs, sizeof(MD_REF_DEF*), md_ref_def_cmp);\n        if(ret != NULL)\n            return *ret;\n        else\n            return NULL;\n    }\n}\n\n\n/***************************\n ***  Recognizing Links  ***\n ***************************/\n\n/* Note this code is partially shared between processing inlines and blocks\n * as reference definitions and links share some helper parser functions.\n */\n\ntypedef struct MD_LINK_ATTR_tag MD_LINK_ATTR;\nstruct MD_LINK_ATTR_tag {\n    OFF dest_beg;\n    OFF dest_end;\n\n    CHAR* title;\n    SZ title_size;\n    int title_needs_free;\n};\n\n\nstatic int\nmd_is_link_label(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg,\n                 OFF* p_end, int* p_beg_line_index, int* p_end_line_index,\n                 OFF* p_contents_beg, OFF* p_contents_end)\n{\n    OFF off = beg;\n    OFF contents_beg = 0;\n    OFF contents_end = 0;\n    int line_index = 0;\n    int len = 0;\n\n    if(CH(off) != _T('['))\n        return FALSE;\n    off++;\n\n    while(1) {\n        OFF line_end = lines[line_index].end;\n\n        while(off < line_end) {\n            if(CH(off) == _T('\\\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) {\n                if(contents_end == 0) {\n                    contents_beg = off;\n                    *p_beg_line_index = line_index;\n                }\n                contents_end = off + 2;\n                off += 2;\n            } else if(CH(off) == _T('[')) {\n                return FALSE;\n            } else if(CH(off) == _T(']')) {\n                if(contents_beg < contents_end) {\n                    /* Success. */\n                    *p_contents_beg = contents_beg;\n                    *p_contents_end = contents_end;\n                    *p_end = off+1;\n                    *p_end_line_index = line_index;\n                    return TRUE;\n                } else {\n                    /* Link label must have some non-whitespace contents. */\n                    return FALSE;\n                }\n            } else {\n                unsigned codepoint;\n                SZ char_size;\n\n                codepoint = md_decode_unicode(ctx->text, off, ctx->size, &char_size);\n                if(!ISUNICODEWHITESPACE_(codepoint)) {\n                    if(contents_end == 0) {\n                        contents_beg = off;\n                        *p_beg_line_index = line_index;\n                    }\n                    contents_end = off + char_size;\n                }\n\n                off += char_size;\n            }\n\n            len++;\n            if(len > 999)\n                return FALSE;\n        }\n\n        line_index++;\n        len++;\n        if(line_index < n_lines)\n            off = lines[line_index].beg;\n        else\n            break;\n    }\n\n    return FALSE;\n}\n\nstatic int\nmd_is_link_destination_A(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end,\n                         OFF* p_contents_beg, OFF* p_contents_end)\n{\n    OFF off = beg;\n\n    if(off >= max_end  ||  CH(off) != _T('<'))\n        return FALSE;\n    off++;\n\n    while(off < max_end) {\n        if(CH(off) == _T('\\\\')  &&  off+1 < max_end  &&  ISPUNCT(off+1)) {\n            off += 2;\n            continue;\n        }\n\n        if(ISNEWLINE(off)  ||  CH(off) == _T('<'))\n            return FALSE;\n\n        if(CH(off) == _T('>')) {\n            /* Success. */\n            *p_contents_beg = beg+1;\n            *p_contents_end = off;\n            *p_end = off+1;\n            return TRUE;\n        }\n\n        off++;\n    }\n\n    return FALSE;\n}\n\nstatic int\nmd_is_link_destination_B(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end,\n                         OFF* p_contents_beg, OFF* p_contents_end)\n{\n    OFF off = beg;\n    int parenthesis_level = 0;\n\n    while(off < max_end) {\n        if(CH(off) == _T('\\\\')  &&  off+1 < max_end  &&  ISPUNCT(off+1)) {\n            off += 2;\n            continue;\n        }\n\n        if(ISWHITESPACE(off) || ISCNTRL(off))\n            break;\n\n        /* Link destination may include balanced pairs of unescaped '(' ')'.\n         * Note we limit the maximal nesting level by 32 to protect us from\n         * https://github.com/jgm/cmark/issues/214 */\n        if(CH(off) == _T('(')) {\n            parenthesis_level++;\n            if(parenthesis_level > 32)\n                return FALSE;\n        } else if(CH(off) == _T(')')) {\n            if(parenthesis_level == 0)\n                break;\n            parenthesis_level--;\n        }\n\n        off++;\n    }\n\n    if(parenthesis_level != 0  ||  off == beg)\n        return FALSE;\n\n    /* Success. */\n    *p_contents_beg = beg;\n    *p_contents_end = off;\n    *p_end = off;\n    return TRUE;\n}\n\nstatic inline int\nmd_is_link_destination(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end,\n                       OFF* p_contents_beg, OFF* p_contents_end)\n{\n    if(CH(beg) == _T('<'))\n        return md_is_link_destination_A(ctx, beg, max_end, p_end, p_contents_beg, p_contents_end);\n    else\n        return md_is_link_destination_B(ctx, beg, max_end, p_end, p_contents_beg, p_contents_end);\n}\n\nstatic int\nmd_is_link_title(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg,\n                 OFF* p_end, int* p_beg_line_index, int* p_end_line_index,\n                 OFF* p_contents_beg, OFF* p_contents_end)\n{\n    OFF off = beg;\n    CHAR closer_char;\n    int line_index = 0;\n\n    /* White space with up to one line break. */\n    while(off < lines[line_index].end  &&  ISWHITESPACE(off))\n        off++;\n    if(off >= lines[line_index].end) {\n        line_index++;\n        if(line_index >= n_lines)\n            return FALSE;\n        off = lines[line_index].beg;\n    }\n    if(off == beg)\n        return FALSE;\n\n    *p_beg_line_index = line_index;\n\n    /* First char determines how to detect end of it. */\n    switch(CH(off)) {\n        case _T('\"'):   closer_char = _T('\"'); break;\n        case _T('\\''):  closer_char = _T('\\''); break;\n        case _T('('):   closer_char = _T(')'); break;\n        default:        return FALSE;\n    }\n    off++;\n\n    *p_contents_beg = off;\n\n    while(line_index < n_lines) {\n        OFF line_end = lines[line_index].end;\n\n        while(off < line_end) {\n            if(CH(off) == _T('\\\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) {\n                off++;\n            } else if(CH(off) == closer_char) {\n                /* Success. */\n                *p_contents_end = off;\n                *p_end = off+1;\n                *p_end_line_index = line_index;\n                return TRUE;\n            } else if(closer_char == _T(')')  &&  CH(off) == _T('(')) {\n                /* ()-style title cannot contain (unescaped '(')) */\n                return FALSE;\n            }\n\n            off++;\n        }\n\n        line_index++;\n    }\n\n    return FALSE;\n}\n\n/* Returns 0 if it is not a reference definition.\n *\n * Returns N > 0 if it is a reference definition. N then corresponds to the\n * number of lines forming it). In this case the definition is stored for\n * resolving any links referring to it.\n *\n * Returns -1 in case of an error (out of memory).\n */\nstatic int\nmd_is_link_reference_definition(MD_CTX* ctx, const MD_LINE* lines, int n_lines)\n{\n    OFF label_contents_beg;\n    OFF label_contents_end;\n    int label_contents_line_index = -1;\n    int label_is_multiline = FALSE;\n    OFF dest_contents_beg;\n    OFF dest_contents_end;\n    OFF title_contents_beg;\n    OFF title_contents_end;\n    int title_contents_line_index;\n    int title_is_multiline = FALSE;\n    OFF off;\n    int line_index = 0;\n    int tmp_line_index;\n    MD_REF_DEF* def = NULL;\n    int ret = 0;\n\n    /* Link label. */\n    if(!md_is_link_label(ctx, lines, n_lines, lines[0].beg,\n                &off, &label_contents_line_index, &line_index,\n                &label_contents_beg, &label_contents_end))\n        return FALSE;\n    label_is_multiline = (label_contents_line_index != line_index);\n\n    /* Colon. */\n    if(off >= lines[line_index].end  ||  CH(off) != _T(':'))\n        return FALSE;\n    off++;\n\n    /* Optional white space with up to one line break. */\n    while(off < lines[line_index].end  &&  ISWHITESPACE(off))\n        off++;\n    if(off >= lines[line_index].end) {\n        line_index++;\n        if(line_index >= n_lines)\n            return FALSE;\n        off = lines[line_index].beg;\n    }\n\n    /* Link destination. */\n    if(!md_is_link_destination(ctx, off, lines[line_index].end,\n                &off, &dest_contents_beg, &dest_contents_end))\n        return FALSE;\n\n    /* (Optional) title. Note we interpret it as an title only if nothing\n     * more follows on its last line. */\n    if(md_is_link_title(ctx, lines + line_index, n_lines - line_index, off,\n                &off, &title_contents_line_index, &tmp_line_index,\n                &title_contents_beg, &title_contents_end)\n        &&  off >= lines[line_index + tmp_line_index].end)\n    {\n        title_is_multiline = (tmp_line_index != title_contents_line_index);\n        title_contents_line_index += line_index;\n        line_index += tmp_line_index;\n    } else {\n        /* Not a title. */\n        title_is_multiline = FALSE;\n        title_contents_beg = off;\n        title_contents_end = off;\n        title_contents_line_index = 0;\n    }\n\n    /* Nothing more can follow on the last line. */\n    if(off < lines[line_index].end)\n        return FALSE;\n\n    /* So, it _is_ a reference definition. Remember it. */\n    if(ctx->n_ref_defs >= ctx->alloc_ref_defs) {\n        MD_REF_DEF* new_defs;\n\n        ctx->alloc_ref_defs = (ctx->alloc_ref_defs > 0\n                ? ctx->alloc_ref_defs + ctx->alloc_ref_defs / 2\n                : 16);\n        new_defs = (MD_REF_DEF*) realloc(ctx->ref_defs, ctx->alloc_ref_defs * sizeof(MD_REF_DEF));\n        if(new_defs == NULL) {\n            MD_LOG(\"realloc() failed.\");\n            goto abort;\n        }\n\n        ctx->ref_defs = new_defs;\n    }\n    def = &ctx->ref_defs[ctx->n_ref_defs];\n    memset(def, 0, sizeof(MD_REF_DEF));\n\n    if(label_is_multiline) {\n        MD_CHECK(md_merge_lines_alloc(ctx, label_contents_beg, label_contents_end,\n                    lines + label_contents_line_index, n_lines - label_contents_line_index,\n                    _T(' '), &def->label, &def->label_size));\n        def->label_needs_free = TRUE;\n    } else {\n        def->label = (CHAR*) STR(label_contents_beg);\n        def->label_size = label_contents_end - label_contents_beg;\n    }\n\n    if(title_is_multiline) {\n        MD_CHECK(md_merge_lines_alloc(ctx, title_contents_beg, title_contents_end,\n                    lines + title_contents_line_index, n_lines - title_contents_line_index,\n                    _T('\\n'), &def->title, &def->title_size));\n        def->title_needs_free = TRUE;\n    } else {\n        def->title = (CHAR*) STR(title_contents_beg);\n        def->title_size = title_contents_end - title_contents_beg;\n    }\n\n    def->dest_beg = dest_contents_beg;\n    def->dest_end = dest_contents_end;\n\n    /* Success. */\n    ctx->n_ref_defs++;\n    return line_index + 1;\n\nabort:\n    /* Failure. */\n    if(def != NULL  &&  def->label_needs_free)\n        free(def->label);\n    if(def != NULL  &&  def->title_needs_free)\n        free(def->title);\n    return ret;\n}\n\nstatic int\nmd_is_link_reference(MD_CTX* ctx, const MD_LINE* lines, int n_lines,\n                     OFF beg, OFF end, MD_LINK_ATTR* attr)\n{\n    const MD_REF_DEF* def;\n    const MD_LINE* beg_line;\n    const MD_LINE* end_line;\n    CHAR* label;\n    SZ label_size;\n    int ret;\n\n    MD_ASSERT(CH(beg) == _T('[') || CH(beg) == _T('!'));\n    MD_ASSERT(CH(end-1) == _T(']'));\n\n    beg += (CH(beg) == _T('!') ? 2 : 1);\n    end--;\n\n    /* Find lines corresponding to the beg and end positions. */\n    MD_ASSERT(lines[0].beg <= beg);\n    beg_line = lines;\n    while(beg >= beg_line->end)\n        beg_line++;\n\n    MD_ASSERT(end <= lines[n_lines-1].end);\n    end_line = beg_line;\n    while(end >= end_line->end)\n        end_line++;\n\n    if(beg_line != end_line) {\n        MD_CHECK(md_merge_lines_alloc(ctx, beg, end, beg_line,\n                 n_lines - (beg_line - lines), _T(' '), &label, &label_size));\n    } else {\n        label = (CHAR*) STR(beg);\n        label_size = end - beg;\n    }\n\n    def = md_lookup_ref_def(ctx, label, label_size);\n    if(def != NULL) {\n        attr->dest_beg = def->dest_beg;\n        attr->dest_end = def->dest_end;\n        attr->title = def->title;\n        attr->title_size = def->title_size;\n        attr->title_needs_free = FALSE;\n    }\n\n    if(beg_line != end_line)\n        free(label);\n\n    ret = (def != NULL);\n\nabort:\n    return ret;\n}\n\nstatic int\nmd_is_inline_link_spec(MD_CTX* ctx, const MD_LINE* lines, int n_lines,\n                       OFF beg, OFF* p_end, MD_LINK_ATTR* attr)\n{\n    int line_index = 0;\n    int tmp_line_index;\n    OFF title_contents_beg;\n    OFF title_contents_end;\n    int title_contents_line_index;\n    int title_is_multiline;\n    OFF off = beg;\n    int ret = FALSE;\n\n    while(off >= lines[line_index].end)\n        line_index++;\n\n    MD_ASSERT(CH(off) == _T('('));\n    off++;\n\n    /* Optional white space with up to one line break. */\n    while(off < lines[line_index].end  &&  ISWHITESPACE(off))\n        off++;\n    if(off >= lines[line_index].end  &&  ISNEWLINE(off)) {\n        line_index++;\n        if(line_index >= n_lines)\n            return FALSE;\n        off = lines[line_index].beg;\n    }\n\n    /* Link destination may be omitted, but only when not also having a title. */\n    if(off < ctx->size  &&  CH(off) == _T(')')) {\n        attr->dest_beg = off;\n        attr->dest_end = off;\n        attr->title = NULL;\n        attr->title_size = 0;\n        attr->title_needs_free = FALSE;\n        off++;\n        *p_end = off;\n        return TRUE;\n    }\n\n    /* Link destination. */\n    if(!md_is_link_destination(ctx, off, lines[line_index].end,\n                        &off, &attr->dest_beg, &attr->dest_end))\n        return FALSE;\n\n    /* (Optional) title. */\n    if(md_is_link_title(ctx, lines + line_index, n_lines - line_index, off,\n                &off, &title_contents_line_index, &tmp_line_index,\n                &title_contents_beg, &title_contents_end))\n    {\n        title_is_multiline = (tmp_line_index != title_contents_line_index);\n        title_contents_line_index += line_index;\n        line_index += tmp_line_index;\n    } else {\n        /* Not a title. */\n        title_is_multiline = FALSE;\n        title_contents_beg = off;\n        title_contents_end = off;\n        title_contents_line_index = 0;\n    }\n\n    /* Optional whitespace followed with final ')'. */\n    while(off < lines[line_index].end  &&  ISWHITESPACE(off))\n        off++;\n    if(off >= lines[line_index].end  &&  ISNEWLINE(off)) {\n        line_index++;\n        if(line_index >= n_lines)\n            return FALSE;\n        off = lines[line_index].beg;\n    }\n    if(CH(off) != _T(')'))\n        goto abort;\n    off++;\n\n    if(title_contents_beg >= title_contents_end) {\n        attr->title = NULL;\n        attr->title_size = 0;\n        attr->title_needs_free = FALSE;\n    } else if(!title_is_multiline) {\n        attr->title = (CHAR*) STR(title_contents_beg);\n        attr->title_size = title_contents_end - title_contents_beg;\n        attr->title_needs_free = FALSE;\n    } else {\n        MD_CHECK(md_merge_lines_alloc(ctx, title_contents_beg, title_contents_end,\n                    lines + title_contents_line_index, n_lines - title_contents_line_index,\n                    _T('\\n'), &attr->title, &attr->title_size));\n        attr->title_needs_free = TRUE;\n    }\n\n    *p_end = off;\n    ret = TRUE;\n\nabort:\n    return ret;\n}\n\nstatic void\nmd_free_ref_defs(MD_CTX* ctx)\n{\n    int i;\n\n    for(i = 0; i < ctx->n_ref_defs; i++) {\n        MD_REF_DEF* def = &ctx->ref_defs[i];\n\n        if(def->label_needs_free)\n            free(def->label);\n        if(def->title_needs_free)\n            free(def->title);\n    }\n\n    free(ctx->ref_defs);\n}\n\n\n/******************************************\n ***  Processing Inlines (a.k.a Spans)  ***\n ******************************************/\n\n/* We process inlines in few phases:\n *\n * (1) We go through the block text and collect all significant characters\n *     which may start/end a span or some other significant position into\n *     ctx->marks[]. Core of this is what md_collect_marks() does.\n *\n *     We also do some very brief preliminary context-less analysis, whether\n *     it might be opener or closer (e.g. of an emphasis span).\n *\n *     This speeds the other steps as we do not need to re-iterate over all\n *     characters anymore.\n *\n * (2) We analyze each potential mark types, in order by their precedence.\n *\n *     In each md_analyze_XXX() function, we re-iterate list of the marks,\n *     skipping already resolved regions (in preceding precedences) and try to\n *     resolve them.\n *\n * (2.1) For trivial marks, which are single (e.g. HTML entity), we just mark\n *       them as resolved.\n *\n * (2.2) For range-type marks, we analyze whether the mark could be closer\n *       and, if yes, whether there is some preceding opener it could satisfy.\n *\n *       If not we check whether it could be really an opener and if yes, we\n *       remember it so subsequent closers may resolve it.\n *\n * (3) Finally, when all marks were analyzed, we render the block contents\n *     by calling MD_RENDERER::text() callback, interrupting by ::enter_span()\n *     or ::close_span() whenever we reach a resolved mark.\n */\n\n\n/* The mark structure.\n *\n * '\\\\': Maybe escape sequence.\n * '\\0': NULL char.\n *  '*': Maybe (strong) emphasis start/end.\n *  '_': Maybe (strong) emphasis start/end.\n *  '~': Maybe strikethrough start/end (needs MD_FLAG_STRIKETHROUGH).\n *  '`': Maybe code span start/end.\n *  '&': Maybe start of entity.\n *  ';': Maybe end of entity.\n *  '<': Maybe start of raw HTML or autolink.\n *  '>': Maybe end of raw HTML or autolink.\n *  '[': Maybe start of link label or link text.\n *  '!': Equivalent of '[' for image.\n *  ']': Maybe end of link label or link text.\n *  '@': Maybe permissive e-mail auto-link (needs MD_FLAG_PERMISSIVEEMAILAUTOLINKS).\n *  ':': Maybe permissive URL auto-link (needs MD_FLAG_PERMISSIVEURLAUTOLINKS).\n *  '.': Maybe permissive WWW auto-link (needs MD_FLAG_PERMISSIVEWWWAUTOLINKS).\n *  'D': Dummy mark, it reserves a space for splitting a previous mark\n *       (e.g. emphasis) or to make more space for storing some special data\n *       related to the preceding mark (e.g. link).\n *\n * Note that not all instances of these chars in the text imply creation of the\n * structure. Only those which have (or may have, after we see more context)\n * the special meaning.\n *\n * (Keep this struct as small as possible to fit as much of them into CPU\n * cache line.)\n */\nstruct MD_MARK_tag {\n    OFF beg;\n    OFF end;\n\n    /* For unresolved openers, 'prev' and 'next' form the chain of open openers\n     * of given type 'ch'.\n     *\n     * During resolving, we disconnect from the chain and point to the\n     * corresponding counterpart so opener points to its closer and vice versa.\n     */\n    int prev;\n    int next;\n    CHAR ch;\n    unsigned char flags;\n};\n\n/* Mark flags (these apply to ALL mark types). */\n#define MD_MARK_POTENTIAL_OPENER            0x01  /* Maybe opener. */\n#define MD_MARK_POTENTIAL_CLOSER            0x02  /* Maybe closer. */\n#define MD_MARK_OPENER                      0x04  /* Definitely opener. */\n#define MD_MARK_CLOSER                      0x08  /* Definitely closer. */\n#define MD_MARK_RESOLVED                    0x10  /* Resolved in any definite way. */\n\n/* Mark flags specific for various mark types (so they can share bits). */\n#define MD_MARK_EMPH_INTRAWORD              0x20  /* Helper for the \"rule of 3\". */\n#define MD_MARK_EMPH_MOD3_0                 0x40\n#define MD_MARK_EMPH_MOD3_1                 0x80\n#define MD_MARK_EMPH_MOD3_2                 (0x40 | 0x80)\n#define MD_MARK_EMPH_MOD3_MASK              (0x40 | 0x80)\n#define MD_MARK_AUTOLINK                    0x20  /* Distinguisher for '<', '>'. */\n#define MD_MARK_VALIDPERMISSIVEAUTOLINK     0x20  /* For permissive autolinks. */\n\nstatic MD_MARKCHAIN*\nmd_asterisk_chain(MD_CTX* ctx, unsigned flags)\n{\n    switch(flags & (MD_MARK_EMPH_INTRAWORD | MD_MARK_EMPH_MOD3_MASK)) {\n        case MD_MARK_EMPH_INTRAWORD | MD_MARK_EMPH_MOD3_0:  return &ASTERISK_OPENERS_intraword_mod3_0;\n        case MD_MARK_EMPH_INTRAWORD | MD_MARK_EMPH_MOD3_1:  return &ASTERISK_OPENERS_intraword_mod3_1;\n        case MD_MARK_EMPH_INTRAWORD | MD_MARK_EMPH_MOD3_2:  return &ASTERISK_OPENERS_intraword_mod3_2;\n        case MD_MARK_EMPH_MOD3_0:                           return &ASTERISK_OPENERS_extraword_mod3_0;\n        case MD_MARK_EMPH_MOD3_1:                           return &ASTERISK_OPENERS_extraword_mod3_1;\n        case MD_MARK_EMPH_MOD3_2:                           return &ASTERISK_OPENERS_extraword_mod3_2;\n        default:                                            MD_UNREACHABLE();\n    }\n    return NULL;\n}\n\nstatic MD_MARKCHAIN*\nmd_mark_chain(MD_CTX* ctx, int mark_index)\n{\n    MD_MARK* mark = &ctx->marks[mark_index];\n\n    switch(mark->ch) {\n        case _T('*'):   return md_asterisk_chain(ctx, mark->flags);\n        case _T('_'):   return &UNDERSCORE_OPENERS;\n        case _T('~'):   return (mark->end - mark->beg == 1) ? &TILDE_OPENERS_1 : &TILDE_OPENERS_2;\n        case _T('['):   return &BRACKET_OPENERS;\n        case _T('|'):   return &TABLECELLBOUNDARIES;\n        default:        return NULL;\n    }\n}\n\nstatic MD_MARK*\nmd_push_mark(MD_CTX* ctx)\n{\n    if(ctx->n_marks >= ctx->alloc_marks) {\n        MD_MARK* new_marks;\n\n        ctx->alloc_marks = (ctx->alloc_marks > 0\n                ? ctx->alloc_marks + ctx->alloc_marks / 2\n                : 64);\n        new_marks = realloc(ctx->marks, ctx->alloc_marks * sizeof(MD_MARK));\n        if(new_marks == NULL) {\n            MD_LOG(\"realloc() failed.\");\n            return NULL;\n        }\n\n        ctx->marks = new_marks;\n    }\n\n    return &ctx->marks[ctx->n_marks++];\n}\n\n#define PUSH_MARK_()                                                    \\\n        do {                                                            \\\n            mark = md_push_mark(ctx);                                   \\\n            if(mark == NULL) {                                          \\\n                ret = -1;                                               \\\n                goto abort;                                             \\\n            }                                                           \\\n        } while(0)\n\n#define PUSH_MARK(ch_, beg_, end_, flags_)                              \\\n        do {                                                            \\\n            PUSH_MARK_();                                               \\\n            mark->beg = (beg_);                                         \\\n            mark->end = (end_);                                         \\\n            mark->prev = -1;                                            \\\n            mark->next = -1;                                            \\\n            mark->ch = (char)(ch_);                                     \\\n            mark->flags = (flags_);                                     \\\n        } while(0)\n\n\nstatic void\nmd_mark_chain_append(MD_CTX* ctx, MD_MARKCHAIN* chain, int mark_index)\n{\n    if(chain->tail >= 0)\n        ctx->marks[chain->tail].next = mark_index;\n    else\n        chain->head = mark_index;\n\n    ctx->marks[mark_index].prev = chain->tail;\n    ctx->marks[mark_index].next = -1;\n    chain->tail = mark_index;\n}\n\n/* Sometimes, we need to store a pointer into the mark. It is quite rare\n * so we do not bother to make MD_MARK use union, and it can only happen\n * for dummy marks. */\nstatic inline void\nmd_mark_store_ptr(MD_CTX* ctx, int mark_index, void* ptr)\n{\n    MD_MARK* mark = &ctx->marks[mark_index];\n    MD_ASSERT(mark->ch == 'D');\n\n    /* Check only members beg and end are misused for this. */\n    MD_ASSERT(sizeof(void*) <= 2 * sizeof(OFF));\n    memcpy(mark, &ptr, sizeof(void*));\n}\n\nstatic inline void*\nmd_mark_get_ptr(MD_CTX* ctx, int mark_index)\n{\n    void* ptr;\n    MD_MARK* mark = &ctx->marks[mark_index];\n    MD_ASSERT(mark->ch == 'D');\n    memcpy(&ptr, mark, sizeof(void*));\n    return ptr;\n}\n\nstatic void\nmd_resolve_range(MD_CTX* ctx, MD_MARKCHAIN* chain, int opener_index, int closer_index)\n{\n    MD_MARK* opener = &ctx->marks[opener_index];\n    MD_MARK* closer = &ctx->marks[closer_index];\n\n    /* Remove opener from the list of openers. */\n    if(chain != NULL) {\n        if(opener->prev >= 0)\n            ctx->marks[opener->prev].next = opener->next;\n        else\n            chain->head = opener->next;\n\n        if(opener->next >= 0)\n            ctx->marks[opener->next].prev = opener->prev;\n        else\n            chain->tail = opener->prev;\n    }\n\n    /* Interconnect opener and closer and mark both as resolved. */\n    opener->next = closer_index;\n    opener->flags |= MD_MARK_OPENER | MD_MARK_RESOLVED;\n    closer->prev = opener_index;\n    closer->flags |= MD_MARK_CLOSER | MD_MARK_RESOLVED;\n}\n\n\n#define MD_ROLLBACK_ALL         0\n#define MD_ROLLBACK_CROSSING    1\n\n/* In the range ctx->marks[opener_index] ... [closer_index], undo some or all\n * resolvings accordingly to these rules:\n *\n * (1) All openers BEFORE the range corresponding to any closer inside the\n *     range are un-resolved and they are re-added to their respective chains\n *     of unresolved openers. This ensures we can reuse the opener for closers\n *     AFTER the range.\n *\n * (2) If 'how' is MD_ROLLBACK_ALL, then ALL resolved marks inside the range\n *     are discarded.\n *\n * (3) If 'how' is MD_ROLLBACK_CROSSING, only closers with openers handled\n *     in (1) are discarded. I.e. pairs of openers and closers which are both\n *     inside the range are retained as well as any unpaired marks.\n */\nstatic void\nmd_rollback(MD_CTX* ctx, int opener_index, int closer_index, int how)\n{\n    int i;\n    int mark_index;\n\n    /* Cut all unresolved openers at the mark index. */\n    for(i = OPENERS_CHAIN_FIRST; i < OPENERS_CHAIN_LAST+1; i++) {\n        MD_MARKCHAIN* chain = &ctx->mark_chains[i];\n\n        while(chain->tail >= opener_index)\n            chain->tail = ctx->marks[chain->tail].prev;\n\n        if(chain->tail >= 0)\n            ctx->marks[chain->tail].next = -1;\n        else\n            chain->head = -1;\n    }\n\n    /* Go backwards so that unresolved openers are re-added into their\n     * respective chains, in the right order. */\n    mark_index = closer_index - 1;\n    while(mark_index > opener_index) {\n        MD_MARK* mark = &ctx->marks[mark_index];\n        int mark_flags = mark->flags;\n        int discard_flag = (how == MD_ROLLBACK_ALL);\n\n        if(mark->flags & MD_MARK_CLOSER) {\n            int mark_opener_index = mark->prev;\n\n            /* Undo opener BEFORE the range. */\n            if(mark_opener_index < opener_index) {\n                MD_MARK* mark_opener = &ctx->marks[mark_opener_index];\n                MD_MARKCHAIN* chain;\n\n                mark_opener->flags &= ~(MD_MARK_OPENER | MD_MARK_CLOSER | MD_MARK_RESOLVED);\n                chain = md_mark_chain(ctx, opener_index);\n                if(chain != NULL) {\n                    md_mark_chain_append(ctx, chain, mark_opener_index);\n                    discard_flag = 1;\n                }\n            }\n        }\n\n        /* And reset our flags. */\n        if(discard_flag)\n            mark->flags &= ~(MD_MARK_OPENER | MD_MARK_CLOSER | MD_MARK_RESOLVED);\n\n        /* Jump as far as we can over unresolved or non-interesting marks. */\n        switch(how) {\n            case MD_ROLLBACK_CROSSING:\n                if((mark_flags & MD_MARK_CLOSER)  &&  mark->prev > opener_index) {\n                    /* If we are closer with opener INSIDE the range, there may\n                     * not be any other crosser inside the subrange. */\n                    mark_index = mark->prev;\n                    break;\n                }\n                MD_FALLTHROUGH();\n            default:\n                mark_index--;\n                break;\n        }\n    }\n}\n\nstatic void\nmd_build_mark_char_map(MD_CTX* ctx)\n{\n    memset(ctx->mark_char_map, 0, sizeof(ctx->mark_char_map));\n\n    ctx->mark_char_map['\\\\'] = 1;\n    ctx->mark_char_map['*'] = 1;\n    ctx->mark_char_map['_'] = 1;\n    ctx->mark_char_map['`'] = 1;\n    ctx->mark_char_map['&'] = 1;\n    ctx->mark_char_map[';'] = 1;\n    ctx->mark_char_map['<'] = 1;\n    ctx->mark_char_map['>'] = 1;\n    ctx->mark_char_map['['] = 1;\n    ctx->mark_char_map['!'] = 1;\n    ctx->mark_char_map[']'] = 1;\n    ctx->mark_char_map['\\0'] = 1;\n\n    if(ctx->parser.flags & MD_FLAG_STRIKETHROUGH)\n        ctx->mark_char_map['~'] = 1;\n\n    if(ctx->parser.flags & MD_FLAG_LATEXMATHSPANS)\n        ctx->mark_char_map['$'] = 1;\n\n    if(ctx->parser.flags & MD_FLAG_PERMISSIVEEMAILAUTOLINKS)\n        ctx->mark_char_map['@'] = 1;\n\n    if(ctx->parser.flags & MD_FLAG_PERMISSIVEURLAUTOLINKS)\n        ctx->mark_char_map[':'] = 1;\n\n    if(ctx->parser.flags & MD_FLAG_PERMISSIVEWWWAUTOLINKS)\n        ctx->mark_char_map['.'] = 1;\n\n    if((ctx->parser.flags & MD_FLAG_TABLES) || (ctx->parser.flags & MD_FLAG_WIKILINKS))\n        ctx->mark_char_map['|'] = 1;\n\n    if(ctx->parser.flags & MD_FLAG_COLLAPSEWHITESPACE) {\n        int i;\n\n        for(i = 0; i < (int) sizeof(ctx->mark_char_map); i++) {\n            if(ISWHITESPACE_(i))\n                ctx->mark_char_map[i] = 1;\n        }\n    }\n}\n\n/* We limit code span marks to lower than 32 backticks. This solves the\n * pathologic case of too many openers, each of different length: Their\n * resolving would be then O(n^2). */\n#define CODESPAN_MARK_MAXLEN    32\n\nstatic int\nmd_is_code_span(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg,\n                OFF* p_opener_beg, OFF* p_opener_end,\n                OFF* p_closer_beg, OFF* p_closer_end,\n                OFF last_potential_closers[CODESPAN_MARK_MAXLEN],\n                int* p_reached_paragraph_end)\n{\n    OFF opener_beg = beg;\n    OFF opener_end;\n    OFF closer_beg;\n    OFF closer_end;\n    SZ mark_len;\n    OFF line_end;\n    int has_space_after_opener = FALSE;\n    int has_eol_after_opener = FALSE;\n    int has_space_before_closer = FALSE;\n    int has_eol_before_closer = FALSE;\n    int has_only_space = TRUE;\n    int line_index = 0;\n\n    line_end = lines[0].end;\n    opener_end = opener_beg;\n    while(opener_end < line_end  &&  CH(opener_end) == _T('`'))\n        opener_end++;\n    has_space_after_opener = (opener_end < line_end && CH(opener_end) == _T(' '));\n    has_eol_after_opener = (opener_end == line_end);\n\n    /* The caller needs to know end of the opening mark even if we fail. */\n    *p_opener_end = opener_end;\n\n    mark_len = opener_end - opener_beg;\n    if(mark_len > CODESPAN_MARK_MAXLEN)\n        return FALSE;\n\n    /* Check whether we already know there is no closer of this length.\n     * If so, re-scan does no sense. This fixes issue #59. */\n    if(last_potential_closers[mark_len-1] >= lines[n_lines-1].end  ||\n       (*p_reached_paragraph_end  &&  last_potential_closers[mark_len-1] < opener_end))\n        return FALSE;\n\n    closer_beg = opener_end;\n    closer_end = opener_end;\n\n    /* Find closer mark. */\n    while(TRUE) {\n        while(closer_beg < line_end  &&  CH(closer_beg) != _T('`')) {\n            if(CH(closer_beg) != _T(' '))\n                has_only_space = FALSE;\n            closer_beg++;\n        }\n        closer_end = closer_beg;\n        while(closer_end < line_end  &&  CH(closer_end) == _T('`'))\n            closer_end++;\n\n        if(closer_end - closer_beg == mark_len) {\n            /* Success. */\n            has_space_before_closer = (closer_beg > lines[line_index].beg && CH(closer_beg-1) == _T(' '));\n            has_eol_before_closer = (closer_beg == lines[line_index].beg);\n            break;\n        }\n\n        if(closer_end - closer_beg > 0) {\n            /* We have found a back-tick which is not part of the closer. */\n            has_only_space = FALSE;\n\n            /* But if we eventually fail, remember it as a potential closer\n             * of its own length for future attempts. This mitigates needs for\n             * rescans. */\n            if(closer_end - closer_beg < CODESPAN_MARK_MAXLEN) {\n                if(closer_beg > last_potential_closers[closer_end - closer_beg - 1])\n                    last_potential_closers[closer_end - closer_beg - 1] = closer_beg;\n            }\n        }\n\n        if(closer_end >= line_end) {\n            line_index++;\n            if(line_index >= n_lines) {\n                /* Reached end of the paragraph and still nothing. */\n                *p_reached_paragraph_end = TRUE;\n                return FALSE;\n            }\n            /* Try on the next line. */\n            line_end = lines[line_index].end;\n            closer_beg = lines[line_index].beg;\n        } else {\n            closer_beg = closer_end;\n        }\n    }\n\n    /* If there is a space or a new line both after and before the opener\n     * (and if the code span is not made of spaces only), consume one initial\n     * and one trailing space as part of the marks. */\n    if(!has_only_space  &&\n       (has_space_after_opener || has_eol_after_opener)  &&\n       (has_space_before_closer || has_eol_before_closer))\n    {\n        if(has_space_after_opener)\n            opener_end++;\n        else\n            opener_end = lines[1].beg;\n\n        if(has_space_before_closer)\n            closer_beg--;\n        else {\n            closer_beg = lines[line_index-1].end;\n            /* We need to eat the preceding \"\\r\\n\" but not any line trailing\n             * spaces. */\n            while(closer_beg < ctx->size  &&  ISBLANK(closer_beg))\n                closer_beg++;\n        }\n    }\n\n    *p_opener_beg = opener_beg;\n    *p_opener_end = opener_end;\n    *p_closer_beg = closer_beg;\n    *p_closer_end = closer_end;\n    return TRUE;\n}\n\nstatic int\nmd_is_autolink_uri(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end)\n{\n    OFF off = beg+1;\n\n    MD_ASSERT(CH(beg) == _T('<'));\n\n    /* Check for scheme. */\n    if(off >= max_end  ||  !ISASCII(off))\n        return FALSE;\n    off++;\n    while(1) {\n        if(off >= max_end)\n            return FALSE;\n        if(off - beg > 32)\n            return FALSE;\n        if(CH(off) == _T(':')  &&  off - beg >= 3)\n            break;\n        if(!ISALNUM(off) && CH(off) != _T('+') && CH(off) != _T('-') && CH(off) != _T('.'))\n            return FALSE;\n        off++;\n    }\n\n    /* Check the path after the scheme. */\n    while(off < max_end  &&  CH(off) != _T('>')) {\n        if(ISWHITESPACE(off) || ISCNTRL(off) || CH(off) == _T('<'))\n            return FALSE;\n        off++;\n    }\n\n    if(off >= max_end)\n        return FALSE;\n\n    MD_ASSERT(CH(off) == _T('>'));\n    *p_end = off+1;\n    return TRUE;\n}\n\nstatic int\nmd_is_autolink_email(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end)\n{\n    OFF off = beg + 1;\n    int label_len;\n\n    MD_ASSERT(CH(beg) == _T('<'));\n\n    /* The code should correspond to this regexp:\n            /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+\n            @[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\n            (?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/\n     */\n\n    /* Username (before '@'). */\n    while(off < max_end  &&  (ISALNUM(off) || ISANYOF(off, _T(\".!#$%&'*+/=?^_`{|}~-\"))))\n        off++;\n    if(off <= beg+1)\n        return FALSE;\n\n    /* '@' */\n    if(off >= max_end  ||  CH(off) != _T('@'))\n        return FALSE;\n    off++;\n\n    /* Labels delimited with '.'; each label is sequence of 1 - 63 alnum\n     * characters or '-', but '-' is not allowed as first or last char. */\n    label_len = 0;\n    while(off < max_end) {\n        if(ISALNUM(off))\n            label_len++;\n        else if(CH(off) == _T('-')  &&  label_len > 0)\n            label_len++;\n        else if(CH(off) == _T('.')  &&  label_len > 0  &&  CH(off-1) != _T('-'))\n            label_len = 0;\n        else\n            break;\n\n        if(label_len > 63)\n            return FALSE;\n\n        off++;\n    }\n\n    if(label_len <= 0  || off >= max_end  ||  CH(off) != _T('>') ||  CH(off-1) == _T('-'))\n        return FALSE;\n\n    *p_end = off+1;\n    return TRUE;\n}\n\nstatic int\nmd_is_autolink(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end, int* p_missing_mailto)\n{\n    if(md_is_autolink_uri(ctx, beg, max_end, p_end)) {\n        *p_missing_mailto = FALSE;\n        return TRUE;\n    }\n\n    if(md_is_autolink_email(ctx, beg, max_end, p_end)) {\n        *p_missing_mailto = TRUE;\n        return TRUE;\n    }\n\n    return FALSE;\n}\n\nstatic int\nmd_collect_marks(MD_CTX* ctx, const MD_LINE* lines, int n_lines, int table_mode)\n{\n    int i;\n    int ret = 0;\n    MD_MARK* mark;\n    OFF codespan_last_potential_closers[CODESPAN_MARK_MAXLEN] = { 0 };\n    int codespan_scanned_till_paragraph_end = FALSE;\n\n    for(i = 0; i < n_lines; i++) {\n        const MD_LINE* line = &lines[i];\n        OFF off = line->beg;\n        OFF line_end = line->end;\n\n        while(TRUE) {\n            CHAR ch;\n\n#ifdef MD4C_USE_UTF16\n    /* For UTF-16, mark_char_map[] covers only ASCII. */\n    #define IS_MARK_CHAR(off)   ((CH(off) < SIZEOF_ARRAY(ctx->mark_char_map))  &&  \\\n                                (ctx->mark_char_map[(unsigned char) CH(off)]))\n#else\n    /* For 8-bit encodings, mark_char_map[] covers all 256 elements. */\n    #define IS_MARK_CHAR(off)   (ctx->mark_char_map[(unsigned char) CH(off)])\n#endif\n\n            /* Optimization: Use some loop unrolling. */\n            while(off + 3 < line_end  &&  !IS_MARK_CHAR(off+0)  &&  !IS_MARK_CHAR(off+1)\n                                      &&  !IS_MARK_CHAR(off+2)  &&  !IS_MARK_CHAR(off+3))\n                off += 4;\n            while(off < line_end  &&  !IS_MARK_CHAR(off+0))\n                off++;\n\n            if(off >= line_end)\n                break;\n\n            ch = CH(off);\n\n            /* A backslash escape.\n             * It can go beyond line->end as it may involve escaped new\n             * line to form a hard break. */\n            if(ch == _T('\\\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) {\n                /* Hard-break cannot be on the last line of the block. */\n                if(!ISNEWLINE(off+1)  ||  i+1 < n_lines)\n                    PUSH_MARK(ch, off, off+2, MD_MARK_RESOLVED);\n                off += 2;\n                continue;\n            }\n\n            /* A potential (string) emphasis start/end. */\n            if(ch == _T('*')  ||  ch == _T('_')) {\n                OFF tmp = off+1;\n                int left_level;     /* What precedes: 0 = whitespace; 1 = punctuation; 2 = other char. */\n                int right_level;    /* What follows: 0 = whitespace; 1 = punctuation; 2 = other char. */\n\n                while(tmp < line_end  &&  CH(tmp) == ch)\n                    tmp++;\n\n                if(off == line->beg  ||  ISUNICODEWHITESPACEBEFORE(off))\n                    left_level = 0;\n                else if(ISUNICODEPUNCTBEFORE(off))\n                    left_level = 1;\n                else\n                    left_level = 2;\n\n                if(tmp == line_end  ||  ISUNICODEWHITESPACE(tmp))\n                    right_level = 0;\n                else if(ISUNICODEPUNCT(tmp))\n                    right_level = 1;\n                else\n                    right_level = 2;\n\n                /* Intra-word underscore doesn't have special meaning. */\n                if(ch == _T('_')  &&  left_level == 2  &&  right_level == 2) {\n                    left_level = 0;\n                    right_level = 0;\n                }\n\n                if(left_level != 0  ||  right_level != 0) {\n                    unsigned flags = 0;\n\n                    if(left_level > 0  &&  left_level >= right_level)\n                        flags |= MD_MARK_POTENTIAL_CLOSER;\n                    if(right_level > 0  &&  right_level >= left_level)\n                        flags |= MD_MARK_POTENTIAL_OPENER;\n                    if(left_level == 2  &&  right_level == 2)\n                        flags |= MD_MARK_EMPH_INTRAWORD;\n\n                    /* For \"the rule of three\" we need to remember the original\n                     * size of the mark (modulo three), before we potentially\n                     * split the mark when being later resolved partially by some\n                     * shorter closer. */\n                    switch((tmp - off) % 3) {\n                        case 0: flags |= MD_MARK_EMPH_MOD3_0; break;\n                        case 1: flags |= MD_MARK_EMPH_MOD3_1; break;\n                        case 2: flags |= MD_MARK_EMPH_MOD3_2; break;\n                    }\n\n                    PUSH_MARK(ch, off, tmp, flags);\n\n                    /* During resolving, multiple asterisks may have to be\n                     * split into independent span start/ends. Consider e.g.\n                     * \"**foo* bar*\". Therefore we push also some empty dummy\n                     * marks to have enough space for that. */\n                    off++;\n                    while(off < tmp) {\n                        PUSH_MARK('D', off, off, 0);\n                        off++;\n                    }\n                    continue;\n                }\n\n                off = tmp;\n                continue;\n            }\n\n            /* A potential code span start/end. */\n            if(ch == _T('`')) {\n                OFF opener_beg, opener_end;\n                OFF closer_beg, closer_end;\n                int is_code_span;\n\n                is_code_span = md_is_code_span(ctx, lines + i, n_lines - i, off,\n                                    &opener_beg, &opener_end, &closer_beg, &closer_end,\n                                    codespan_last_potential_closers,\n                                    &codespan_scanned_till_paragraph_end);\n                if(is_code_span) {\n                    PUSH_MARK(_T('`'), opener_beg, opener_end, MD_MARK_OPENER | MD_MARK_RESOLVED);\n                    PUSH_MARK(_T('`'), closer_beg, closer_end, MD_MARK_CLOSER | MD_MARK_RESOLVED);\n                    ctx->marks[ctx->n_marks-2].next = ctx->n_marks-1;\n                    ctx->marks[ctx->n_marks-1].prev = ctx->n_marks-2;\n\n                    off = closer_end;\n\n                    /* Advance the current line accordingly. */\n                    while(off > line_end) {\n                        i++;\n                        line++;\n                        line_end = line->end;\n                    }\n                    continue;\n                }\n\n                off = opener_end;\n                continue;\n            }\n\n            /* A potential entity start. */\n            if(ch == _T('&')) {\n                PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_OPENER);\n                off++;\n                continue;\n            }\n\n            /* A potential entity end. */\n            if(ch == _T(';')) {\n                /* We surely cannot be entity unless the previous mark is '&'. */\n                if(ctx->n_marks > 0  &&  ctx->marks[ctx->n_marks-1].ch == _T('&'))\n                    PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_CLOSER);\n\n                off++;\n                continue;\n            }\n\n            /* A potential autolink or raw HTML start/end. */\n            if(ch == _T('<')) {\n                int is_autolink;\n                OFF autolink_end;\n                int missing_mailto;\n\n                if(!(ctx->parser.flags & MD_FLAG_NOHTMLSPANS)) {\n                    int is_html;\n                    OFF html_end;\n\n                    /* Given the nature of the raw HTML, we have to recognize\n                     * it here. Doing so later in md_analyze_lt_gt() could\n                     * open can of worms of quadratic complexity. */\n                    is_html = md_is_html_any(ctx, lines + i, n_lines - i, off,\n                                    lines[n_lines-1].end, &html_end);\n                    if(is_html) {\n                        PUSH_MARK(_T('<'), off, off, MD_MARK_OPENER | MD_MARK_RESOLVED);\n                        PUSH_MARK(_T('>'), html_end, html_end, MD_MARK_CLOSER | MD_MARK_RESOLVED);\n                        ctx->marks[ctx->n_marks-2].next = ctx->n_marks-1;\n                        ctx->marks[ctx->n_marks-1].prev = ctx->n_marks-2;\n                        off = html_end;\n\n                        /* Advance the current line accordingly. */\n                        while(off > line_end) {\n                            i++;\n                            line++;\n                            line_end = line->end;\n                        }\n                        continue;\n                    }\n                }\n\n                is_autolink = md_is_autolink(ctx, off, lines[n_lines-1].end,\n                                    &autolink_end, &missing_mailto);\n                if(is_autolink) {\n                    PUSH_MARK((missing_mailto ? _T('@') : _T('<')), off, off+1,\n                                MD_MARK_OPENER | MD_MARK_RESOLVED | MD_MARK_AUTOLINK);\n                    PUSH_MARK(_T('>'), autolink_end-1, autolink_end,\n                                MD_MARK_CLOSER | MD_MARK_RESOLVED | MD_MARK_AUTOLINK);\n                    ctx->marks[ctx->n_marks-2].next = ctx->n_marks-1;\n                    ctx->marks[ctx->n_marks-1].prev = ctx->n_marks-2;\n                    off = autolink_end;\n                    continue;\n                }\n\n                off++;\n                continue;\n            }\n\n            /* A potential link or its part. */\n            if(ch == _T('[')  ||  (ch == _T('!') && off+1 < line_end && CH(off+1) == _T('['))) {\n                OFF tmp = (ch == _T('[') ? off+1 : off+2);\n                PUSH_MARK(ch, off, tmp, MD_MARK_POTENTIAL_OPENER);\n                off = tmp;\n                /* Two dummies to make enough place for data we need if it is\n                 * a link. */\n                PUSH_MARK('D', off, off, 0);\n                PUSH_MARK('D', off, off, 0);\n                continue;\n            }\n            if(ch == _T(']')) {\n                PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_CLOSER);\n                off++;\n                continue;\n            }\n\n            /* A potential permissive e-mail autolink. */\n            if(ch == _T('@')) {\n                if(line->beg + 1 <= off  &&  ISALNUM(off-1)  &&\n                    off + 3 < line->end  &&  ISALNUM(off+1))\n                {\n                    PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_OPENER);\n                    /* Push a dummy as a reserve for a closer. */\n                    PUSH_MARK('D', off, off, 0);\n                }\n\n                off++;\n                continue;\n            }\n\n            /* A potential permissive URL autolink. */\n            if(ch == _T(':')) {\n                static struct {\n                    const CHAR* scheme;\n                    SZ scheme_size;\n                    const CHAR* suffix;\n                    SZ suffix_size;\n                } scheme_map[] = {\n                    /* In the order from the most frequently used, arguably. */\n                    { _T(\"http\"), 4,    _T(\"//\"), 2 },\n                    { _T(\"https\"), 5,   _T(\"//\"), 2 },\n                    { _T(\"ftp\"), 3,     _T(\"//\"), 2 }\n                };\n                int scheme_index;\n\n                for(scheme_index = 0; scheme_index < (int) SIZEOF_ARRAY(scheme_map); scheme_index++) {\n                    const CHAR* scheme = scheme_map[scheme_index].scheme;\n                    const SZ scheme_size = scheme_map[scheme_index].scheme_size;\n                    const CHAR* suffix = scheme_map[scheme_index].suffix;\n                    const SZ suffix_size = scheme_map[scheme_index].suffix_size;\n\n                    if(line->beg + scheme_size <= off  &&  md_ascii_eq(STR(off-scheme_size), scheme, scheme_size)  &&\n                        (line->beg + scheme_size == off || ISWHITESPACE(off-scheme_size-1) || ISANYOF(off-scheme_size-1, _T(\"*_~([\")))  &&\n                        off + 1 + suffix_size < line->end  &&  md_ascii_eq(STR(off+1), suffix, suffix_size))\n                    {\n                        PUSH_MARK(ch, off-scheme_size, off+1+suffix_size, MD_MARK_POTENTIAL_OPENER);\n                        /* Push a dummy as a reserve for a closer. */\n                        PUSH_MARK('D', off, off, 0);\n                        off += 1 + suffix_size;\n                        break;\n                    }\n                }\n\n                off++;\n                continue;\n            }\n\n            /* A potential permissive WWW autolink. */\n            if(ch == _T('.')) {\n                if(line->beg + 3 <= off  &&  md_ascii_eq(STR(off-3), _T(\"www\"), 3)  &&\n                    (line->beg + 3 == off || ISWHITESPACE(off-4) || ISANYOF(off-4, _T(\"*_~([\")))  &&\n                    off + 1 < line_end)\n                {\n                    PUSH_MARK(ch, off-3, off+1, MD_MARK_POTENTIAL_OPENER);\n                    /* Push a dummy as a reserve for a closer. */\n                    PUSH_MARK('D', off, off, 0);\n                    off++;\n                    continue;\n                }\n\n                off++;\n                continue;\n            }\n\n            /* A potential table cell boundary or wiki link label delimiter. */\n            if((table_mode || ctx->parser.flags & MD_FLAG_WIKILINKS) && ch == _T('|')) {\n                PUSH_MARK(ch, off, off+1, 0);\n                off++;\n                continue;\n            }\n\n            /* A potential strikethrough start/end. */\n            if(ch == _T('~')) {\n                OFF tmp = off+1;\n\n                while(tmp < line_end  &&  CH(tmp) == _T('~'))\n                    tmp++;\n\n                if(tmp - off < 3) {\n                    unsigned flags = 0;\n\n                    if(tmp < line_end  &&  !ISUNICODEWHITESPACE(tmp))\n                        flags |= MD_MARK_POTENTIAL_OPENER;\n                    if(off > line->beg  &&  !ISUNICODEWHITESPACEBEFORE(off))\n                        flags |= MD_MARK_POTENTIAL_CLOSER;\n                    if(flags != 0)\n                        PUSH_MARK(ch, off, tmp, flags);\n                }\n\n                off = tmp;\n                continue;\n            }\n\n            /* A potential equation start/end */\n            if(ch == _T('$')) {\n                /* We can have at most two consecutive $ signs,\n                 * where two dollar signs signify a display equation. */\n                OFF tmp = off+1;\n\n                while(tmp < line_end && CH(tmp) == _T('$'))\n                    tmp++;\n\n                if (tmp - off <= 2)\n                    PUSH_MARK(ch, off, tmp, MD_MARK_POTENTIAL_OPENER | MD_MARK_POTENTIAL_CLOSER);\n                off = tmp;\n                continue;\n            }\n\n            /* Turn non-trivial whitespace into single space. */\n            if(ISWHITESPACE_(ch)) {\n                OFF tmp = off+1;\n\n                while(tmp < line_end  &&  ISWHITESPACE(tmp))\n                    tmp++;\n\n                if(tmp - off > 1  ||  ch != _T(' '))\n                    PUSH_MARK(ch, off, tmp, MD_MARK_RESOLVED);\n\n                off = tmp;\n                continue;\n            }\n\n            /* NULL character. */\n            if(ch == _T('\\0')) {\n                PUSH_MARK(ch, off, off+1, MD_MARK_RESOLVED);\n                off++;\n                continue;\n            }\n\n            off++;\n        }\n    }\n\n    /* Add a dummy mark at the end of the mark vector to simplify\n     * process_inlines(). */\n    PUSH_MARK(127, ctx->size, ctx->size, MD_MARK_RESOLVED);\n\nabort:\n    return ret;\n}\n\nstatic void\nmd_analyze_bracket(MD_CTX* ctx, int mark_index)\n{\n    /* We cannot really resolve links here as for that we would need\n     * more context. E.g. a following pair of brackets (reference link),\n     * or enclosing pair of brackets (if the inner is the link, the outer\n     * one cannot be.)\n     *\n     * Therefore we here only construct a list of resolved '[' ']' pairs\n     * ordered by position of the closer. This allows ur to analyze what is\n     * or is not link in the right order, from inside to outside in case\n     * of nested brackets.\n     *\n     * The resolving itself is deferred into md_resolve_links().\n     */\n\n    MD_MARK* mark = &ctx->marks[mark_index];\n\n    if(mark->flags & MD_MARK_POTENTIAL_OPENER) {\n        md_mark_chain_append(ctx, &BRACKET_OPENERS, mark_index);\n        return;\n    }\n\n    if(BRACKET_OPENERS.tail >= 0) {\n        /* Pop the opener from the chain. */\n        int opener_index = BRACKET_OPENERS.tail;\n        MD_MARK* opener = &ctx->marks[opener_index];\n        if(opener->prev >= 0)\n            ctx->marks[opener->prev].next = -1;\n        else\n            BRACKET_OPENERS.head = -1;\n        BRACKET_OPENERS.tail = opener->prev;\n\n        /* Interconnect the opener and closer. */\n        opener->next = mark_index;\n        mark->prev = opener_index;\n\n        /* Add the pair into chain of potential links for md_resolve_links().\n         * Note we misuse opener->prev for this as opener->next points to its\n         * closer. */\n        if(ctx->unresolved_link_tail >= 0)\n            ctx->marks[ctx->unresolved_link_tail].prev = opener_index;\n        else\n            ctx->unresolved_link_head = opener_index;\n        ctx->unresolved_link_tail = opener_index;\n        opener->prev = -1;\n    }\n}\n\n/* Forward declaration. */\nstatic void md_analyze_link_contents(MD_CTX* ctx, const MD_LINE* lines, int n_lines,\n                                     int mark_beg, int mark_end);\n\nstatic int\nmd_resolve_links(MD_CTX* ctx, const MD_LINE* lines, int n_lines)\n{\n    int opener_index = ctx->unresolved_link_head;\n    OFF last_link_beg = 0;\n    OFF last_link_end = 0;\n    OFF last_img_beg = 0;\n    OFF last_img_end = 0;\n\n    while(opener_index >= 0) {\n        MD_MARK* opener = &ctx->marks[opener_index];\n        int closer_index = opener->next;\n        MD_MARK* closer = &ctx->marks[closer_index];\n        int next_index = opener->prev;\n        MD_MARK* next_opener;\n        MD_MARK* next_closer;\n        MD_LINK_ATTR attr;\n        int is_link = FALSE;\n\n        if(next_index >= 0) {\n            next_opener = &ctx->marks[next_index];\n            next_closer = &ctx->marks[next_opener->next];\n        } else {\n            next_opener = NULL;\n            next_closer = NULL;\n        }\n\n        /* If nested (\"[ [ ] ]\"), we need to make sure that:\n         *   - The outer does not end inside of (...) belonging to the inner.\n         *   - The outer cannot be link if the inner is link (i.e. not image).\n         *\n         * (Note we here analyze from inner to outer as the marks are ordered\n         * by closer->beg.)\n         */\n        if((opener->beg < last_link_beg  &&  closer->end < last_link_end)  ||\n           (opener->beg < last_img_beg  &&  closer->end < last_img_end)  ||\n           (opener->beg < last_link_end  &&  opener->ch == '['))\n        {\n            opener_index = next_index;\n            continue;\n        }\n\n        /* Recognize and resolve wiki links.\n         * Wiki-links maybe '[[destination]]' or '[[destination|label]]'.\n         */\n        if ((ctx->parser.flags & MD_FLAG_WIKILINKS) &&\n            (opener->end - opener->beg == 1) &&         /* not image */\n            next_opener != NULL &&                      /* double '[' opener */\n            next_opener->ch == '[' &&\n            (next_opener->beg == opener->beg - 1) &&\n            (next_opener->end - next_opener->beg == 1) &&\n            next_closer != NULL &&                      /* double ']' closer */\n            next_closer->ch == ']' &&\n            (next_closer->beg == closer->beg + 1) &&\n            (next_closer->end - next_closer->beg == 1))\n        {\n            MD_MARK* delim = NULL;\n            int delim_index;\n            OFF dest_beg, dest_end;\n\n            is_link = TRUE;\n\n            /* We don't allow destination to be longer than 100 characters.\n             * Lets scan to see whether there is '|'. (If not then the whole\n             * wiki-link has to be below the 100 characters.) */\n            delim_index = opener_index + 1;\n            while(delim_index < closer_index) {\n                MD_MARK* m = &ctx->marks[delim_index];\n                if(m->ch == '|') {\n                    delim = m;\n                    break;\n                }\n                if(m->ch != 'D'  &&  m->beg - opener->end > 100)\n                    break;\n                delim_index++;\n            }\n            dest_beg = opener->end;\n            dest_end = (delim != NULL) ? delim->beg : closer->beg;\n            if(dest_end - dest_beg == 0 || dest_end - dest_beg > 100)\n                is_link = FALSE;\n\n            /* There may not be any new line in the destination. */\n            if(is_link) {\n                OFF off;\n                for(off = dest_beg; off < dest_end; off++) {\n                    if(ISNEWLINE(off)) {\n                        is_link = FALSE;\n                        break;\n                    }\n                }\n            }\n\n            if(is_link) {\n                if(delim != NULL) {\n                    if(delim->end < closer->beg) {\n                        opener->end = delim->beg;\n                    } else {\n                        /* The pipe is just before the closer: [[foo|]] */\n                        closer->beg = delim->beg;\n                        delim = NULL;\n                    }\n                }\n\n                opener->beg = next_opener->beg;\n                opener->next = closer_index;\n                opener->flags |= MD_MARK_OPENER | MD_MARK_RESOLVED;\n\n                closer->end = next_closer->end;\n                closer->prev = opener_index;\n                closer->flags |= MD_MARK_CLOSER | MD_MARK_RESOLVED;\n\n                last_link_beg = opener->beg;\n                last_link_end = closer->end;\n\n                if(delim != NULL) {\n                    delim->flags |= MD_MARK_RESOLVED;\n                    md_rollback(ctx, opener_index, delim_index, MD_ROLLBACK_ALL);\n                    md_analyze_link_contents(ctx, lines, n_lines, opener_index+1, closer_index);\n                } else {\n                    md_rollback(ctx, opener_index, closer_index, MD_ROLLBACK_ALL);\n                }\n\n                opener_index = next_opener->prev;\n                continue;\n            }\n        }\n\n        if(next_opener != NULL  &&  next_opener->beg == closer->end) {\n            if(next_closer->beg > closer->end + 1) {\n                /* Might be full reference link. */\n                is_link = md_is_link_reference(ctx, lines, n_lines, next_opener->beg, next_closer->end, &attr);\n            } else {\n                /* Might be shortcut reference link. */\n                is_link = md_is_link_reference(ctx, lines, n_lines, opener->beg, closer->end, &attr);\n            }\n\n            if(is_link < 0)\n                return -1;\n\n            if(is_link) {\n                /* Eat the 2nd \"[...]\". */\n                closer->end = next_closer->end;\n\n                /* Do not analyze the label as a standalone link in the next\n                 * iteration. */\n                next_index = ctx->marks[next_index].prev;\n            }\n        } else {\n            if(closer->end < ctx->size  &&  CH(closer->end) == _T('(')) {\n                /* Might be inline link. */\n                OFF inline_link_end = UINT_MAX;\n\n                is_link = md_is_inline_link_spec(ctx, lines, n_lines, closer->end, &inline_link_end, &attr);\n                if(is_link < 0)\n                    return -1;\n\n                /* Check the closing ')' is not inside an already resolved range\n                 * (i.e. a range with a higher priority), e.g. a code span. */\n                if(is_link) {\n                    int i = closer_index + 1;\n\n                    while(i < ctx->n_marks) {\n                        MD_MARK* mark = &ctx->marks[i];\n\n                        if(mark->beg >= inline_link_end)\n                            break;\n                        if((mark->flags & (MD_MARK_OPENER | MD_MARK_RESOLVED)) == (MD_MARK_OPENER | MD_MARK_RESOLVED)) {\n                            if(ctx->marks[mark->next].beg >= inline_link_end) {\n                                /* Cancel the link status. */\n                                if(attr.title_needs_free)\n                                    free(attr.title);\n                                is_link = FALSE;\n                                break;\n                            }\n\n                            i = mark->next + 1;\n                        } else {\n                            i++;\n                        }\n                    }\n                }\n\n                if(is_link) {\n                    /* Eat the \"(...)\" */\n                    closer->end = inline_link_end;\n                }\n            }\n\n            if(!is_link) {\n                /* Might be collapsed reference link. */\n                is_link = md_is_link_reference(ctx, lines, n_lines, opener->beg, closer->end, &attr);\n                if(is_link < 0)\n                    return -1;\n            }\n        }\n\n        if(is_link) {\n            /* Resolve the brackets as a link. */\n            opener->flags |= MD_MARK_OPENER | MD_MARK_RESOLVED;\n            closer->flags |= MD_MARK_CLOSER | MD_MARK_RESOLVED;\n\n            /* If it is a link, we store the destination and title in the two\n             * dummy marks after the opener. */\n            MD_ASSERT(ctx->marks[opener_index+1].ch == 'D');\n            ctx->marks[opener_index+1].beg = attr.dest_beg;\n            ctx->marks[opener_index+1].end = attr.dest_end;\n\n            MD_ASSERT(ctx->marks[opener_index+2].ch == 'D');\n            md_mark_store_ptr(ctx, opener_index+2, attr.title);\n            /* The title might or might not have been allocated for us. */\n            if(attr.title_needs_free)\n                md_mark_chain_append(ctx, &PTR_CHAIN, opener_index+2);\n            ctx->marks[opener_index+2].prev = attr.title_size;\n\n            if(opener->ch == '[') {\n                last_link_beg = opener->beg;\n                last_link_end = closer->end;\n            } else {\n                last_img_beg = opener->beg;\n                last_img_end = closer->end;\n            }\n\n            md_analyze_link_contents(ctx, lines, n_lines, opener_index+1, closer_index);\n        }\n\n        opener_index = next_index;\n    }\n\n    return 0;\n}\n\n/* Analyze whether the mark '&' starts a HTML entity.\n * If so, update its flags as well as flags of corresponding closer ';'. */\nstatic void\nmd_analyze_entity(MD_CTX* ctx, int mark_index)\n{\n    MD_MARK* opener = &ctx->marks[mark_index];\n    MD_MARK* closer;\n    OFF off;\n\n    /* Cannot be entity if there is no closer as the next mark.\n     * (Any other mark between would mean strange character which cannot be\n     * part of the entity.\n     *\n     * So we can do all the work on '&' and do not call this later for the\n     * closing mark ';'.\n     */\n    if(mark_index + 1 >= ctx->n_marks)\n        return;\n    closer = &ctx->marks[mark_index+1];\n    if(closer->ch != ';')\n        return;\n\n    if(md_is_entity(ctx, opener->beg, closer->end, &off)) {\n        MD_ASSERT(off == closer->end);\n\n        md_resolve_range(ctx, NULL, mark_index, mark_index+1);\n        opener->end = closer->end;\n    }\n}\n\nstatic void\nmd_analyze_table_cell_boundary(MD_CTX* ctx, int mark_index)\n{\n    MD_MARK* mark = &ctx->marks[mark_index];\n    mark->flags |= MD_MARK_RESOLVED;\n\n    md_mark_chain_append(ctx, &TABLECELLBOUNDARIES, mark_index);\n    ctx->n_table_cell_boundaries++;\n}\n\n/* Split a longer mark into two. The new mark takes the given count of\n * characters. May only be called if an adequate number of dummy 'D' marks\n * follows.\n */\nstatic int\nmd_split_emph_mark(MD_CTX* ctx, int mark_index, SZ n)\n{\n    MD_MARK* mark = &ctx->marks[mark_index];\n    int new_mark_index = mark_index + (mark->end - mark->beg - n);\n    MD_MARK* dummy = &ctx->marks[new_mark_index];\n\n    MD_ASSERT(mark->end - mark->beg > n);\n    MD_ASSERT(dummy->ch == 'D');\n\n    memcpy(dummy, mark, sizeof(MD_MARK));\n    mark->end -= n;\n    dummy->beg = mark->end;\n\n    return new_mark_index;\n}\n\nstatic void\nmd_analyze_emph(MD_CTX* ctx, int mark_index)\n{\n    MD_MARK* mark = &ctx->marks[mark_index];\n    MD_MARKCHAIN* chain = md_mark_chain(ctx, mark_index);\n\n    /* If we can be a closer, try to resolve with the preceding opener. */\n    if(mark->flags & MD_MARK_POTENTIAL_CLOSER) {\n        MD_MARK* opener = NULL;\n        int opener_index = 0;\n\n        if(mark->ch == _T('*')) {\n            MD_MARKCHAIN* opener_chains[6];\n            int i, n_opener_chains;\n            unsigned flags = mark->flags;\n\n            /* Apply the \"rule of three\". */\n            n_opener_chains = 0;\n            opener_chains[n_opener_chains++] = &ASTERISK_OPENERS_intraword_mod3_0;\n            if((flags & MD_MARK_EMPH_MOD3_MASK) != MD_MARK_EMPH_MOD3_2)\n                opener_chains[n_opener_chains++] = &ASTERISK_OPENERS_intraword_mod3_1;\n            if((flags & MD_MARK_EMPH_MOD3_MASK) != MD_MARK_EMPH_MOD3_1)\n                opener_chains[n_opener_chains++] = &ASTERISK_OPENERS_intraword_mod3_2;\n            opener_chains[n_opener_chains++] = &ASTERISK_OPENERS_extraword_mod3_0;\n            if(!(flags & MD_MARK_EMPH_INTRAWORD)  ||  (flags & MD_MARK_EMPH_MOD3_MASK) != MD_MARK_EMPH_MOD3_2)\n                opener_chains[n_opener_chains++] = &ASTERISK_OPENERS_extraword_mod3_1;\n            if(!(flags & MD_MARK_EMPH_INTRAWORD)  ||  (flags & MD_MARK_EMPH_MOD3_MASK) != MD_MARK_EMPH_MOD3_1)\n                opener_chains[n_opener_chains++] = &ASTERISK_OPENERS_extraword_mod3_2;\n\n            /* Opener is the most recent mark from the allowed chains. */\n            for(i = 0; i < n_opener_chains; i++) {\n                if(opener_chains[i]->tail >= 0) {\n                    int tmp_index = opener_chains[i]->tail;\n                    MD_MARK* tmp_mark = &ctx->marks[tmp_index];\n                    if(opener == NULL  ||  tmp_mark->end > opener->end) {\n                        opener_index = tmp_index;\n                        opener = tmp_mark;\n                    }\n                }\n            }\n        } else {\n            /* Simple emph. mark */\n            if(chain->tail >= 0) {\n                opener_index = chain->tail;\n                opener = &ctx->marks[opener_index];\n            }\n        }\n\n        /* Resolve, if we have found matching opener. */\n        if(opener != NULL) {\n            SZ opener_size = opener->end - opener->beg;\n            SZ closer_size = mark->end - mark->beg;\n            MD_MARKCHAIN* opener_chain = md_mark_chain(ctx, opener_index);\n\n            if(opener_size > closer_size) {\n                opener_index = md_split_emph_mark(ctx, opener_index, closer_size);\n                md_mark_chain_append(ctx, opener_chain, opener_index);\n            } else if(opener_size < closer_size) {\n                md_split_emph_mark(ctx, mark_index, closer_size - opener_size);\n            }\n\n            md_rollback(ctx, opener_index, mark_index, MD_ROLLBACK_CROSSING);\n            md_resolve_range(ctx, opener_chain, opener_index, mark_index);\n            return;\n        }\n    }\n\n    /* If we could not resolve as closer, we may be yet be an opener. */\n    if(mark->flags & MD_MARK_POTENTIAL_OPENER)\n        md_mark_chain_append(ctx, chain, mark_index);\n}\n\nstatic void\nmd_analyze_tilde(MD_CTX* ctx, int mark_index)\n{\n    MD_MARK* mark = &ctx->marks[mark_index];\n    MD_MARKCHAIN* chain = md_mark_chain(ctx, mark_index);\n\n    /* We attempt to be Github Flavored Markdown compatible here. GFM accepts\n     * only tildes sequences of length 1 and 2, and the length of the opener\n     * and closer has to match. */\n\n    if((mark->flags & MD_MARK_POTENTIAL_CLOSER)  &&  chain->head >= 0) {\n        int opener_index = chain->head;\n\n        md_rollback(ctx, opener_index, mark_index, MD_ROLLBACK_CROSSING);\n        md_resolve_range(ctx, chain, opener_index, mark_index);\n        return;\n    }\n\n    if(mark->flags & MD_MARK_POTENTIAL_OPENER)\n        md_mark_chain_append(ctx, chain, mark_index);\n}\n\nstatic void\nmd_analyze_dollar(MD_CTX* ctx, int mark_index)\n{\n    /* This should mimic the way inline equations work in LaTeX, so there\n     * can only ever be one item in the chain (i.e. the dollars can't be\n     * nested). This is basically the same as the md_analyze_tilde function,\n     * except that we require matching openers and closers to be of the same\n     * length.\n     *\n     * E.g.: $abc$$def$$ => abc (display equation) def (end equation) */\n    if(DOLLAR_OPENERS.head >= 0) {\n        /* If the potential closer has a non-matching number of $, discard */\n        MD_MARK* open = &ctx->marks[DOLLAR_OPENERS.head];\n        MD_MARK* close = &ctx->marks[mark_index];\n\n        int opener_index = DOLLAR_OPENERS.head;\n        md_rollback(ctx, opener_index, mark_index, MD_ROLLBACK_ALL);\n        if (open->end - open->beg == close->end - close->beg) {\n            /* We are the matching closer */\n            md_resolve_range(ctx, &DOLLAR_OPENERS, opener_index, mark_index);\n        } else {\n            /* We don't match the opener, so discard old opener and insert as opener */\n            md_mark_chain_append(ctx, &DOLLAR_OPENERS, mark_index);\n        }\n    } else {\n        /* No unmatched openers, so we are opener */\n        md_mark_chain_append(ctx, &DOLLAR_OPENERS, mark_index);\n    }\n}\n\nstatic void\nmd_analyze_permissive_url_autolink(MD_CTX* ctx, int mark_index)\n{\n    MD_MARK* opener = &ctx->marks[mark_index];\n    int closer_index = mark_index + 1;\n    MD_MARK* closer = &ctx->marks[closer_index];\n    MD_MARK* next_resolved_mark;\n    OFF off = opener->end;\n    int n_dots = FALSE;\n    int has_underscore_in_last_seg = FALSE;\n    int has_underscore_in_next_to_last_seg = FALSE;\n    int n_opened_parenthesis = 0;\n    int n_excess_parenthesis = 0;\n\n    /* Check for domain. */\n    while(off < ctx->size) {\n        if(ISALNUM(off) || CH(off) == _T('-')) {\n            off++;\n        } else if(CH(off) == _T('.')) {\n            /* We must see at least one period. */\n            n_dots++;\n            has_underscore_in_next_to_last_seg = has_underscore_in_last_seg;\n            has_underscore_in_last_seg = FALSE;\n            off++;\n        } else if(CH(off) == _T('_')) {\n            /* No underscore may be present in the last two domain segments. */\n            has_underscore_in_last_seg = TRUE;\n            off++;\n        } else {\n            break;\n        }\n    }\n    if(off > opener->end  &&  CH(off-1) == _T('.')) {\n        off--;\n        n_dots--;\n    }\n    if(off <= opener->end || n_dots == 0 || has_underscore_in_next_to_last_seg || has_underscore_in_last_seg)\n        return;\n\n    /* Check for path. */\n    next_resolved_mark = closer + 1;\n    while(next_resolved_mark->ch == 'D' || !(next_resolved_mark->flags & MD_MARK_RESOLVED))\n        next_resolved_mark++;\n    while(off < next_resolved_mark->beg  &&  CH(off) != _T('<')  &&  !ISWHITESPACE(off)  &&  !ISNEWLINE(off)) {\n        /* Parenthesis must be balanced. */\n        if(CH(off) == _T('(')) {\n            n_opened_parenthesis++;\n        } else if(CH(off) == _T(')')) {\n            if(n_opened_parenthesis > 0)\n                n_opened_parenthesis--;\n            else\n                n_excess_parenthesis++;\n        }\n\n        off++;\n    }\n\n    /* Trim a trailing punctuation from the end. */\n    while(TRUE) {\n        if(ISANYOF(off-1, _T(\"?!.,:*_~\"))) {\n            off--;\n        } else if(CH(off-1) == ')'  &&  n_excess_parenthesis > 0) {\n            /* Unmatched ')' can be in an interior of the path but not at the\n             * of it, so the auto-link may be safely nested in a parenthesis\n             * pair. */\n            off--;\n            n_excess_parenthesis--;\n        } else {\n            break;\n        }\n    }\n\n    /* Ok. Lets call it an auto-link. Adapt opener and create closer to zero\n     * length so all the contents becomes the link text. */\n    MD_ASSERT(closer->ch == 'D');\n    opener->end = opener->beg;\n    closer->ch = opener->ch;\n    closer->beg = off;\n    closer->end = off;\n    md_resolve_range(ctx, NULL, mark_index, closer_index);\n}\n\n/* The permissive autolinks do not have to be enclosed in '<' '>' but we\n * instead impose stricter rules what is understood as an e-mail address\n * here. Actually any non-alphanumeric characters with exception of '.'\n * are prohibited both in username and after '@'. */\nstatic void\nmd_analyze_permissive_email_autolink(MD_CTX* ctx, int mark_index)\n{\n    MD_MARK* opener = &ctx->marks[mark_index];\n    int closer_index;\n    MD_MARK* closer;\n    OFF beg = opener->beg;\n    OFF end = opener->end;\n    int dot_count = 0;\n\n    MD_ASSERT(CH(beg) == _T('@'));\n\n    /* Scan for name before '@'. */\n    while(beg > 0  &&  (ISALNUM(beg-1) || ISANYOF(beg-1, _T(\".-_+\"))))\n        beg--;\n\n    /* Scan for domain after '@'. */\n    while(end < ctx->size  &&  (ISALNUM(end) || ISANYOF(end, _T(\".-_\")))) {\n        if(CH(end) == _T('.'))\n            dot_count++;\n        end++;\n    }\n    if(CH(end-1) == _T('.')) {  /* Final '.' not part of it. */\n        dot_count--;\n        end--;\n    }\n    else if(ISANYOF2(end-1, _T('-'), _T('_'))) /* These are forbidden at the end. */\n        return;\n    if(CH(end-1) == _T('@')  ||  dot_count == 0)\n        return;\n\n    /* Ok. Lets call it auto-link. Adapt opener and create closer to zero\n     * length so all the contents becomes the link text. */\n    closer_index = mark_index + 1;\n    closer = &ctx->marks[closer_index];\n    MD_ASSERT(closer->ch == 'D');\n\n    opener->beg = beg;\n    opener->end = beg;\n    closer->ch = opener->ch;\n    closer->beg = end;\n    closer->end = end;\n    md_resolve_range(ctx, NULL, mark_index, closer_index);\n}\n\nstatic inline void\nmd_analyze_marks(MD_CTX* ctx, const MD_LINE* lines, int n_lines,\n                 int mark_beg, int mark_end, const CHAR* mark_chars)\n{\n    int i = mark_beg;\n    MD_UNUSED(lines);\n    MD_UNUSED(n_lines);\n\n    while(i < mark_end) {\n        MD_MARK* mark = &ctx->marks[i];\n\n        /* Skip resolved spans. */\n        if(mark->flags & MD_MARK_RESOLVED) {\n            if(mark->flags & MD_MARK_OPENER) {\n                MD_ASSERT(i < mark->next);\n                i = mark->next + 1;\n            } else {\n                i++;\n            }\n            continue;\n        }\n\n        /* Skip marks we do not want to deal with. */\n        if(!ISANYOF_(mark->ch, mark_chars)) {\n            i++;\n            continue;\n        }\n\n        /* Analyze the mark. */\n        switch(mark->ch) {\n            case '[':   /* Pass through. */\n            case '!':   /* Pass through. */\n            case ']':   md_analyze_bracket(ctx, i); break;\n            case '&':   md_analyze_entity(ctx, i); break;\n            case '|':   md_analyze_table_cell_boundary(ctx, i); break;\n            case '_':   /* Pass through. */\n            case '*':   md_analyze_emph(ctx, i); break;\n            case '~':   md_analyze_tilde(ctx, i); break;\n            case '$':   md_analyze_dollar(ctx, i); break;\n            case '.':   /* Pass through. */\n            case ':':   md_analyze_permissive_url_autolink(ctx, i); break;\n            case '@':   md_analyze_permissive_email_autolink(ctx, i); break;\n        }\n\n        i++;\n    }\n}\n\n/* Analyze marks (build ctx->marks). */\nstatic int\nmd_analyze_inlines(MD_CTX* ctx, const MD_LINE* lines, int n_lines, int table_mode)\n{\n    int ret;\n\n    /* Reset the previously collected stack of marks. */\n    ctx->n_marks = 0;\n\n    /* Collect all marks. */\n    MD_CHECK(md_collect_marks(ctx, lines, n_lines, table_mode));\n\n    /* We analyze marks in few groups to handle their precedence. */\n    /* (1) Entities; code spans; autolinks; raw HTML. */\n    md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T(\"&\"));\n\n    /* (2) Links. */\n    md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T(\"[]!\"));\n    MD_CHECK(md_resolve_links(ctx, lines, n_lines));\n    BRACKET_OPENERS.head = -1;\n    BRACKET_OPENERS.tail = -1;\n    ctx->unresolved_link_head = -1;\n    ctx->unresolved_link_tail = -1;\n\n    if(table_mode) {\n        /* (3) Analyze table cell boundaries.\n         * Note we reset TABLECELLBOUNDARIES chain prior to the call md_analyze_marks(),\n         * not after, because caller may need it. */\n        MD_ASSERT(n_lines == 1);\n        TABLECELLBOUNDARIES.head = -1;\n        TABLECELLBOUNDARIES.tail = -1;\n        ctx->n_table_cell_boundaries = 0;\n        md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T(\"|\"));\n        return ret;\n    }\n\n    /* (4) Emphasis and strong emphasis; permissive autolinks. */\n    md_analyze_link_contents(ctx, lines, n_lines, 0, ctx->n_marks);\n\nabort:\n    return ret;\n}\n\nstatic void\nmd_analyze_link_contents(MD_CTX* ctx, const MD_LINE* lines, int n_lines,\n                         int mark_beg, int mark_end)\n{\n    int i;\n\n    md_analyze_marks(ctx, lines, n_lines, mark_beg, mark_end, _T(\"*_~$@:.\"));\n\n    for(i = OPENERS_CHAIN_FIRST; i <= OPENERS_CHAIN_LAST; i++) {\n        ctx->mark_chains[i].head = -1;\n        ctx->mark_chains[i].tail = -1;\n    }\n}\n\nstatic int\nmd_enter_leave_span_a(MD_CTX* ctx, int enter, MD_SPANTYPE type,\n                      const CHAR* dest, SZ dest_size, int prohibit_escapes_in_dest,\n                      const CHAR* title, SZ title_size)\n{\n    MD_ATTRIBUTE_BUILD href_build = { 0 };\n    MD_ATTRIBUTE_BUILD title_build = { 0 };\n    MD_SPAN_A_DETAIL det;\n    int ret = 0;\n\n    /* Note we here rely on fact that MD_SPAN_A_DETAIL and\n     * MD_SPAN_IMG_DETAIL are binary-compatible. */\n    memset(&det, 0, sizeof(MD_SPAN_A_DETAIL));\n    MD_CHECK(md_build_attribute(ctx, dest, dest_size,\n                    (prohibit_escapes_in_dest ? MD_BUILD_ATTR_NO_ESCAPES : 0),\n                    &det.href, &href_build));\n    MD_CHECK(md_build_attribute(ctx, title, title_size, 0, &det.title, &title_build));\n\n    if(enter)\n        MD_ENTER_SPAN(type, &det);\n    else\n        MD_LEAVE_SPAN(type, &det);\n\nabort:\n    md_free_attribute(ctx, &href_build);\n    md_free_attribute(ctx, &title_build);\n    return ret;\n}\n\nstatic int\nmd_enter_leave_span_wikilink(MD_CTX* ctx, int enter, const CHAR* target, SZ target_size)\n{\n    MD_ATTRIBUTE_BUILD target_build = { 0 };\n    MD_SPAN_WIKILINK_DETAIL det;\n    int ret = 0;\n\n    memset(&det, 0, sizeof(MD_SPAN_WIKILINK_DETAIL));\n    MD_CHECK(md_build_attribute(ctx, target, target_size, 0, &det.target, &target_build));\n\n    if (enter)\n        MD_ENTER_SPAN(MD_SPAN_WIKILINK, &det);\n    else\n        MD_LEAVE_SPAN(MD_SPAN_WIKILINK, &det);\n\nabort:\n    md_free_attribute(ctx, &target_build);\n    return ret;\n}\n\n\n/* Render the output, accordingly to the analyzed ctx->marks. */\nstatic int\nmd_process_inlines(MD_CTX* ctx, const MD_LINE* lines, int n_lines)\n{\n    MD_TEXTTYPE text_type;\n    const MD_LINE* line = lines;\n    MD_MARK* prev_mark = NULL;\n    MD_MARK* mark;\n    OFF off = lines[0].beg;\n    OFF end = lines[n_lines-1].end;\n    int enforce_hardbreak = 0;\n    int ret = 0;\n\n    /* Find first resolved mark. Note there is always at least one resolved\n     * mark,  the dummy last one after the end of the latest line we actually\n     * never really reach. This saves us of a lot of special checks and cases\n     * in this function. */\n    mark = ctx->marks;\n    while(!(mark->flags & MD_MARK_RESOLVED))\n        mark++;\n\n    text_type = MD_TEXT_NORMAL;\n\n    while(1) {\n        /* Process the text up to the next mark or end-of-line. */\n        OFF tmp = (line->end < mark->beg ? line->end : mark->beg);\n        if(tmp > off) {\n            MD_TEXT(text_type, STR(off), tmp - off);\n            off = tmp;\n        }\n\n        /* If reached the mark, process it and move to next one. */\n        if(off >= mark->beg) {\n            switch(mark->ch) {\n                case '\\\\':      /* Backslash escape. */\n                    if(ISNEWLINE(mark->beg+1))\n                        enforce_hardbreak = 1;\n                    else\n                        MD_TEXT(text_type, STR(mark->beg+1), 1);\n                    break;\n\n                case ' ':       /* Non-trivial space. */\n                    MD_TEXT(text_type, _T(\" \"), 1);\n                    break;\n\n                case '`':       /* Code span. */\n                    if(mark->flags & MD_MARK_OPENER) {\n                        MD_ENTER_SPAN(MD_SPAN_CODE, NULL);\n                        text_type = MD_TEXT_CODE;\n                    } else {\n                        MD_LEAVE_SPAN(MD_SPAN_CODE, NULL);\n                        text_type = MD_TEXT_NORMAL;\n                    }\n                    break;\n\n                case '_':       /* Underline (or emphasis if we fall through). */\n                    if(ctx->parser.flags & MD_FLAG_UNDERLINE) {\n                        if(mark->flags & MD_MARK_OPENER) {\n                            while(off < mark->end) {\n                                MD_ENTER_SPAN(MD_SPAN_U, NULL);\n                                off++;\n                            }\n                        } else {\n                            while(off < mark->end) {\n                                MD_LEAVE_SPAN(MD_SPAN_U, NULL);\n                                off++;\n                            }\n                        }\n                        break;\n                    }\n                    MD_FALLTHROUGH();\n\n                case '*':       /* Emphasis, strong emphasis. */\n                    if(mark->flags & MD_MARK_OPENER) {\n                        if((mark->end - off) % 2) {\n                            MD_ENTER_SPAN(MD_SPAN_EM, NULL);\n                            off++;\n                        }\n                        while(off + 1 < mark->end) {\n                            MD_ENTER_SPAN(MD_SPAN_STRONG, NULL);\n                            off += 2;\n                        }\n                    } else {\n                        while(off + 1 < mark->end) {\n                            MD_LEAVE_SPAN(MD_SPAN_STRONG, NULL);\n                            off += 2;\n                        }\n                        if((mark->end - off) % 2) {\n                            MD_LEAVE_SPAN(MD_SPAN_EM, NULL);\n                            off++;\n                        }\n                    }\n                    break;\n\n                case '~':\n                    if(mark->flags & MD_MARK_OPENER)\n                        MD_ENTER_SPAN(MD_SPAN_DEL, NULL);\n                    else\n                        MD_LEAVE_SPAN(MD_SPAN_DEL, NULL);\n                    break;\n\n                case '$':\n                    if(mark->flags & MD_MARK_OPENER) {\n                        MD_ENTER_SPAN((mark->end - off) % 2 ? MD_SPAN_LATEXMATH : MD_SPAN_LATEXMATH_DISPLAY, NULL);\n                        text_type = MD_TEXT_LATEXMATH;\n                    } else {\n                        MD_LEAVE_SPAN((mark->end - off) % 2 ? MD_SPAN_LATEXMATH : MD_SPAN_LATEXMATH_DISPLAY, NULL);\n                        text_type = MD_TEXT_NORMAL;\n                    }\n                    break;\n\n                case '[':       /* Link, wiki link, image. */\n                case '!':\n                case ']':\n                {\n                    const MD_MARK* opener = (mark->ch != ']' ? mark : &ctx->marks[mark->prev]);\n                    const MD_MARK* closer = &ctx->marks[opener->next];\n                    const MD_MARK* dest_mark;\n                    const MD_MARK* title_mark;\n\n                    if ((opener->ch == '[' && closer->ch == ']') &&\n                        opener->end - opener->beg >= 2 &&\n                        closer->end - closer->beg >= 2)\n                    {\n                        int has_label = (opener->end - opener->beg > 2);\n                        SZ target_sz;\n\n                        if(has_label)\n                            target_sz = opener->end - (opener->beg+2);\n                        else\n                            target_sz = closer->beg - opener->end;\n\n                        MD_CHECK(md_enter_leave_span_wikilink(ctx, (mark->ch != ']'),\n                                 has_label ? STR(opener->beg+2) : STR(opener->end),\n                                 target_sz));\n\n                        break;\n                    }\n\n                    dest_mark = opener+1;\n                    MD_ASSERT(dest_mark->ch == 'D');\n                    title_mark = opener+2;\n                    MD_ASSERT(title_mark->ch == 'D');\n\n                    MD_CHECK(md_enter_leave_span_a(ctx, (mark->ch != ']'),\n                                (opener->ch == '!' ? MD_SPAN_IMG : MD_SPAN_A),\n                                STR(dest_mark->beg), dest_mark->end - dest_mark->beg, FALSE,\n                                md_mark_get_ptr(ctx, title_mark - ctx->marks), title_mark->prev));\n\n                    /* link/image closer may span multiple lines. */\n                    if(mark->ch == ']') {\n                        while(mark->end > line->end)\n                            line++;\n                    }\n\n                    break;\n                }\n\n                case '<':\n                case '>':       /* Autolink or raw HTML. */\n                    if(!(mark->flags & MD_MARK_AUTOLINK)) {\n                        /* Raw HTML. */\n                        if(mark->flags & MD_MARK_OPENER)\n                            text_type = MD_TEXT_HTML;\n                        else\n                            text_type = MD_TEXT_NORMAL;\n                        break;\n                    }\n                    /* Pass through, if auto-link. */\n                    MD_FALLTHROUGH();\n\n                case '@':       /* Permissive e-mail autolink. */\n                case ':':       /* Permissive URL autolink. */\n                case '.':       /* Permissive WWW autolink. */\n                {\n                    MD_MARK* opener = ((mark->flags & MD_MARK_OPENER) ? mark : &ctx->marks[mark->prev]);\n                    MD_MARK* closer = &ctx->marks[opener->next];\n                    const CHAR* dest = STR(opener->end);\n                    SZ dest_size = closer->beg - opener->end;\n\n                    /* For permissive auto-links we do not know closer mark\n                     * position at the time of md_collect_marks(), therefore\n                     * it can be out-of-order in ctx->marks[].\n                     *\n                     * With this flag, we make sure that we output the closer\n                     * only if we processed the opener. */\n                    if(mark->flags & MD_MARK_OPENER)\n                        closer->flags |= MD_MARK_VALIDPERMISSIVEAUTOLINK;\n\n                    if(opener->ch == '@' || opener->ch == '.') {\n                        dest_size += 7;\n                        MD_TEMP_BUFFER(dest_size * sizeof(CHAR));\n                        memcpy(ctx->buffer,\n                                (opener->ch == '@' ? _T(\"mailto:\") : _T(\"http://\")),\n                                7 * sizeof(CHAR));\n                        memcpy(ctx->buffer + 7, dest, (dest_size-7) * sizeof(CHAR));\n                        dest = ctx->buffer;\n                    }\n\n                    if(closer->flags & MD_MARK_VALIDPERMISSIVEAUTOLINK)\n                        MD_CHECK(md_enter_leave_span_a(ctx, (mark->flags & MD_MARK_OPENER),\n                                    MD_SPAN_A, dest, dest_size, TRUE, NULL, 0));\n                    break;\n                }\n\n                case '&':       /* Entity. */\n                    MD_TEXT(MD_TEXT_ENTITY, STR(mark->beg), mark->end - mark->beg);\n                    break;\n\n                case '\\0':\n                    MD_TEXT(MD_TEXT_NULLCHAR, _T(\"\"), 1);\n                    break;\n\n                case 127:\n                    goto abort;\n            }\n\n            off = mark->end;\n\n            /* Move to next resolved mark. */\n            prev_mark = mark;\n            mark++;\n            while(!(mark->flags & MD_MARK_RESOLVED)  ||  mark->beg < off)\n                mark++;\n        }\n\n        /* If reached end of line, move to next one. */\n        if(off >= line->end) {\n            /* If it is the last line, we are done. */\n            if(off >= end)\n                break;\n\n            if(text_type == MD_TEXT_CODE || text_type == MD_TEXT_LATEXMATH) {\n                OFF tmp;\n\n                MD_ASSERT(prev_mark != NULL);\n                MD_ASSERT(ISANYOF2_(prev_mark->ch, '`', '$')  &&  (prev_mark->flags & MD_MARK_OPENER));\n                MD_ASSERT(ISANYOF2_(mark->ch, '`', '$')  &&  (mark->flags & MD_MARK_CLOSER));\n\n                /* Inside a code span, trailing line whitespace has to be\n                 * outputted. */\n                tmp = off;\n                while(off < ctx->size  &&  ISBLANK(off))\n                    off++;\n                if(off > tmp)\n                    MD_TEXT(text_type, STR(tmp), off-tmp);\n\n                /* and new lines are transformed into single spaces. */\n                if(prev_mark->end < off  &&  off < mark->beg)\n                    MD_TEXT(text_type, _T(\" \"), 1);\n            } else if(text_type == MD_TEXT_HTML) {\n                /* Inside raw HTML, we output the new line verbatim, including\n                 * any trailing spaces. */\n                OFF tmp = off;\n\n                while(tmp < end  &&  ISBLANK(tmp))\n                    tmp++;\n                if(tmp > off)\n                    MD_TEXT(MD_TEXT_HTML, STR(off), tmp - off);\n                MD_TEXT(MD_TEXT_HTML, _T(\"\\n\"), 1);\n            } else {\n                /* Output soft or hard line break. */\n                MD_TEXTTYPE break_type = MD_TEXT_SOFTBR;\n\n                if(text_type == MD_TEXT_NORMAL) {\n                    if(enforce_hardbreak)\n                        break_type = MD_TEXT_BR;\n                    else if((CH(line->end) == _T(' ') && CH(line->end+1) == _T(' ')))\n                        break_type = MD_TEXT_BR;\n                }\n\n                MD_TEXT(break_type, _T(\"\\n\"), 1);\n            }\n\n            /* Move to the next line. */\n            line++;\n            off = line->beg;\n\n            enforce_hardbreak = 0;\n        }\n    }\n\nabort:\n    return ret;\n}\n\n\n/***************************\n ***  Processing Tables  ***\n ***************************/\n\nstatic void\nmd_analyze_table_alignment(MD_CTX* ctx, OFF beg, OFF end, MD_ALIGN* align, int n_align)\n{\n    static const MD_ALIGN align_map[] = { MD_ALIGN_DEFAULT, MD_ALIGN_LEFT, MD_ALIGN_RIGHT, MD_ALIGN_CENTER };\n    OFF off = beg;\n\n    while(n_align > 0) {\n        int index = 0;  /* index into align_map[] */\n\n        while(CH(off) != _T('-'))\n            off++;\n        if(off > beg  &&  CH(off-1) == _T(':'))\n            index |= 1;\n        while(off < end  &&  CH(off) == _T('-'))\n            off++;\n        if(off < end  &&  CH(off) == _T(':'))\n            index |= 2;\n\n        *align = align_map[index];\n        align++;\n        n_align--;\n    }\n\n}\n\n/* Forward declaration. */\nstatic int md_process_normal_block_contents(MD_CTX* ctx, const MD_LINE* lines, int n_lines);\n\nstatic int\nmd_process_table_cell(MD_CTX* ctx, MD_BLOCKTYPE cell_type, MD_ALIGN align, OFF beg, OFF end)\n{\n    MD_LINE line;\n    MD_BLOCK_TD_DETAIL det;\n    int ret = 0;\n\n    while(beg < end  &&  ISWHITESPACE(beg))\n        beg++;\n    while(end > beg  &&  ISWHITESPACE(end-1))\n        end--;\n\n    det.align = align;\n    line.beg = beg;\n    line.end = end;\n\n    MD_ENTER_BLOCK(cell_type, &det);\n    MD_CHECK(md_process_normal_block_contents(ctx, &line, 1));\n    MD_LEAVE_BLOCK(cell_type, &det);\n\nabort:\n    return ret;\n}\n\nstatic int\nmd_process_table_row(MD_CTX* ctx, MD_BLOCKTYPE cell_type, OFF beg, OFF end,\n                     const MD_ALIGN* align, int col_count)\n{\n    MD_LINE line;\n    OFF* pipe_offs = NULL;\n    int i, j, k, n;\n    int ret = 0;\n\n    line.beg = beg;\n    line.end = end;\n\n    /* Break the line into table cells by identifying pipe characters who\n     * form the cell boundary. */\n    MD_CHECK(md_analyze_inlines(ctx, &line, 1, TRUE));\n\n    /* We have to remember the cell boundaries in local buffer because\n     * ctx->marks[] shall be reused during cell contents processing. */\n    n = ctx->n_table_cell_boundaries + 2;\n    pipe_offs = (OFF*) malloc(n * sizeof(OFF));\n    if(pipe_offs == NULL) {\n        MD_LOG(\"malloc() failed.\");\n        ret = -1;\n        goto abort;\n    }\n    j = 0;\n    pipe_offs[j++] = beg;\n    for(i = TABLECELLBOUNDARIES.head; i >= 0; i = ctx->marks[i].next) {\n        MD_MARK* mark = &ctx->marks[i];\n        pipe_offs[j++] = mark->end;\n    }\n    pipe_offs[j++] = end+1;\n\n    /* Process cells. */\n    MD_ENTER_BLOCK(MD_BLOCK_TR, NULL);\n    k = 0;\n    for(i = 0; i < j-1  &&  k < col_count; i++) {\n        if(pipe_offs[i] < pipe_offs[i+1]-1)\n            MD_CHECK(md_process_table_cell(ctx, cell_type, align[k++], pipe_offs[i], pipe_offs[i+1]-1));\n    }\n    /* Make sure we call enough table cells even if the current table contains\n     * too few of them. */\n    while(k < col_count)\n        MD_CHECK(md_process_table_cell(ctx, cell_type, align[k++], 0, 0));\n    MD_LEAVE_BLOCK(MD_BLOCK_TR, NULL);\n\nabort:\n    free(pipe_offs);\n\n    /* Free any temporary memory blocks stored within some dummy marks. */\n    for(i = PTR_CHAIN.head; i >= 0; i = ctx->marks[i].next)\n        free(md_mark_get_ptr(ctx, i));\n    PTR_CHAIN.head = -1;\n    PTR_CHAIN.tail = -1;\n\n    return ret;\n}\n\nstatic int\nmd_process_table_block_contents(MD_CTX* ctx, int col_count, const MD_LINE* lines, int n_lines)\n{\n    MD_ALIGN* align;\n    int i;\n    int ret = 0;\n\n    /* At least two lines have to be present: The column headers and the line\n     * with the underlines. */\n    MD_ASSERT(n_lines >= 2);\n\n    align = malloc(col_count * sizeof(MD_ALIGN));\n    if(align == NULL) {\n        MD_LOG(\"malloc() failed.\");\n        ret = -1;\n        goto abort;\n    }\n\n    md_analyze_table_alignment(ctx, lines[1].beg, lines[1].end, align, col_count);\n\n    MD_ENTER_BLOCK(MD_BLOCK_THEAD, NULL);\n    MD_CHECK(md_process_table_row(ctx, MD_BLOCK_TH,\n                        lines[0].beg, lines[0].end, align, col_count));\n    MD_LEAVE_BLOCK(MD_BLOCK_THEAD, NULL);\n\n    if(n_lines > 2) {\n        MD_ENTER_BLOCK(MD_BLOCK_TBODY, NULL);\n        for(i = 2; i < n_lines; i++) {\n            MD_CHECK(md_process_table_row(ctx, MD_BLOCK_TD,\n                     lines[i].beg, lines[i].end, align, col_count));\n        }\n        MD_LEAVE_BLOCK(MD_BLOCK_TBODY, NULL);\n    }\n\nabort:\n    free(align);\n    return ret;\n}\n\n\n/**************************\n ***  Processing Block  ***\n **************************/\n\n#define MD_BLOCK_CONTAINER_OPENER   0x01\n#define MD_BLOCK_CONTAINER_CLOSER   0x02\n#define MD_BLOCK_CONTAINER          (MD_BLOCK_CONTAINER_OPENER | MD_BLOCK_CONTAINER_CLOSER)\n#define MD_BLOCK_LOOSE_LIST         0x04\n#define MD_BLOCK_SETEXT_HEADER      0x08\n\nstruct MD_BLOCK_tag {\n    MD_BLOCKTYPE type  :  8;\n    unsigned flags     :  8;\n\n    /* MD_BLOCK_H:      Header level (1 - 6)\n     * MD_BLOCK_CODE:   Non-zero if fenced, zero if indented.\n     * MD_BLOCK_LI:     Task mark character (0 if not task list item, 'x', 'X' or ' ').\n     * MD_BLOCK_TABLE:  Column count (as determined by the table underline).\n     */\n    unsigned data      : 16;\n\n    /* Leaf blocks:     Count of lines (MD_LINE or MD_VERBATIMLINE) on the block.\n     * MD_BLOCK_LI:     Task mark offset in the input doc.\n     * MD_BLOCK_OL:     Start item number.\n     */\n    unsigned n_lines;\n};\n\nstruct MD_CONTAINER_tag {\n    CHAR ch;\n    unsigned is_loose    : 8;\n    unsigned is_task     : 8;\n    unsigned start;\n    unsigned mark_indent;\n    unsigned contents_indent;\n    OFF block_byte_off;\n    OFF task_mark_off;\n};\n\n\nstatic int\nmd_process_normal_block_contents(MD_CTX* ctx, const MD_LINE* lines, int n_lines)\n{\n    int i;\n    int ret;\n\n    MD_CHECK(md_analyze_inlines(ctx, lines, n_lines, FALSE));\n    MD_CHECK(md_process_inlines(ctx, lines, n_lines));\n\nabort:\n    /* Free any temporary memory blocks stored within some dummy marks. */\n    for(i = PTR_CHAIN.head; i >= 0; i = ctx->marks[i].next)\n        free(md_mark_get_ptr(ctx, i));\n    PTR_CHAIN.head = -1;\n    PTR_CHAIN.tail = -1;\n\n    return ret;\n}\n\nstatic int\nmd_process_verbatim_block_contents(MD_CTX* ctx, MD_TEXTTYPE text_type, const MD_VERBATIMLINE* lines, int n_lines)\n{\n    static const CHAR indent_chunk_str[] = _T(\"                \");\n    static const SZ indent_chunk_size = SIZEOF_ARRAY(indent_chunk_str) - 1;\n\n    int i;\n    int ret = 0;\n\n    for(i = 0; i < n_lines; i++) {\n        const MD_VERBATIMLINE* line = &lines[i];\n        int indent = line->indent;\n\n        MD_ASSERT(indent >= 0);\n\n        /* Output code indentation. */\n        while(indent > (int) indent_chunk_size) {\n            MD_TEXT(text_type, indent_chunk_str, indent_chunk_size);\n            indent -= indent_chunk_size;\n        }\n        if(indent > 0)\n            MD_TEXT(text_type, indent_chunk_str, indent);\n\n        /* Output the code line itself. */\n        MD_TEXT_INSECURE(text_type, STR(line->beg), line->end - line->beg);\n\n        /* Enforce end-of-line. */\n        MD_TEXT(text_type, _T(\"\\n\"), 1);\n    }\n\nabort:\n    return ret;\n}\n\nstatic int\nmd_process_code_block_contents(MD_CTX* ctx, int is_fenced, const MD_VERBATIMLINE* lines, int n_lines)\n{\n    if(is_fenced) {\n        /* Skip the first line in case of fenced code: It is the fence.\n         * (Only the starting fence is present due to logic in md_analyze_line().) */\n        lines++;\n        n_lines--;\n    } else {\n        /* Ignore blank lines at start/end of indented code block. */\n        while(n_lines > 0  &&  lines[0].beg == lines[0].end) {\n            lines++;\n            n_lines--;\n        }\n        while(n_lines > 0  &&  lines[n_lines-1].beg == lines[n_lines-1].end) {\n            n_lines--;\n        }\n    }\n\n    if(n_lines == 0)\n        return 0;\n\n    return md_process_verbatim_block_contents(ctx, MD_TEXT_CODE, lines, n_lines);\n}\n\nstatic int\nmd_setup_fenced_code_detail(MD_CTX* ctx, const MD_BLOCK* block, MD_BLOCK_CODE_DETAIL* det,\n                            MD_ATTRIBUTE_BUILD* info_build, MD_ATTRIBUTE_BUILD* lang_build)\n{\n    const MD_VERBATIMLINE* fence_line = (const MD_VERBATIMLINE*)(block + 1);\n    OFF beg = fence_line->beg;\n    OFF end = fence_line->end;\n    OFF lang_end;\n    CHAR fence_ch = CH(fence_line->beg);\n    int ret = 0;\n\n    /* Skip the fence itself. */\n    while(beg < ctx->size  &&  CH(beg) == fence_ch)\n        beg++;\n    /* Trim initial spaces. */\n    while(beg < ctx->size  &&  CH(beg) == _T(' '))\n        beg++;\n\n    /* Trim trailing spaces. */\n    while(end > beg  &&  CH(end-1) == _T(' '))\n        end--;\n\n    /* Build info string attribute. */\n    MD_CHECK(md_build_attribute(ctx, STR(beg), end - beg, 0, &det->info, info_build));\n\n    /* Build info string attribute. */\n    lang_end = beg;\n    while(lang_end < end  &&  !ISWHITESPACE(lang_end))\n        lang_end++;\n    MD_CHECK(md_build_attribute(ctx, STR(beg), lang_end - beg, 0, &det->lang, lang_build));\n\n    det->fence_char = fence_ch;\n\nabort:\n    return ret;\n}\n\nstatic int\nmd_process_leaf_block(MD_CTX* ctx, const MD_BLOCK* block)\n{\n    union {\n        MD_BLOCK_H_DETAIL header;\n        MD_BLOCK_CODE_DETAIL code;\n        MD_BLOCK_TABLE_DETAIL table;\n    } det;\n    MD_ATTRIBUTE_BUILD info_build;\n    MD_ATTRIBUTE_BUILD lang_build;\n    int is_in_tight_list;\n    int clean_fence_code_detail = FALSE;\n    int ret = 0;\n\n    memset(&det, 0, sizeof(det));\n\n    if(ctx->n_containers == 0)\n        is_in_tight_list = FALSE;\n    else\n        is_in_tight_list = !ctx->containers[ctx->n_containers-1].is_loose;\n\n    switch(block->type) {\n        case MD_BLOCK_H:\n            det.header.level = block->data;\n            break;\n\n        case MD_BLOCK_CODE:\n            /* For fenced code block, we may need to set the info string. */\n            if(block->data != 0) {\n                memset(&det.code, 0, sizeof(MD_BLOCK_CODE_DETAIL));\n                clean_fence_code_detail = TRUE;\n                MD_CHECK(md_setup_fenced_code_detail(ctx, block, &det.code, &info_build, &lang_build));\n            }\n            break;\n\n        case MD_BLOCK_TABLE:\n            det.table.col_count = block->data;\n            det.table.head_row_count = 1;\n            det.table.body_row_count = block->n_lines - 2;\n            break;\n\n        default:\n            /* Noop. */\n            break;\n    }\n\n    if(!is_in_tight_list  ||  block->type != MD_BLOCK_P)\n        MD_ENTER_BLOCK(block->type, (void*) &det);\n\n    /* Process the block contents accordingly to is type. */\n    switch(block->type) {\n        case MD_BLOCK_HR:\n            /* noop */\n            break;\n\n        case MD_BLOCK_CODE:\n            MD_CHECK(md_process_code_block_contents(ctx, (block->data != 0),\n                            (const MD_VERBATIMLINE*)(block + 1), block->n_lines));\n            break;\n\n        case MD_BLOCK_HTML:\n            MD_CHECK(md_process_verbatim_block_contents(ctx, MD_TEXT_HTML,\n                            (const MD_VERBATIMLINE*)(block + 1), block->n_lines));\n            break;\n\n        case MD_BLOCK_TABLE:\n            MD_CHECK(md_process_table_block_contents(ctx, block->data,\n                            (const MD_LINE*)(block + 1), block->n_lines));\n            break;\n\n        default:\n            MD_CHECK(md_process_normal_block_contents(ctx,\n                            (const MD_LINE*)(block + 1), block->n_lines));\n            break;\n    }\n\n    if(!is_in_tight_list  ||  block->type != MD_BLOCK_P)\n        MD_LEAVE_BLOCK(block->type, (void*) &det);\n\nabort:\n    if(clean_fence_code_detail) {\n        md_free_attribute(ctx, &info_build);\n        md_free_attribute(ctx, &lang_build);\n    }\n    return ret;\n}\n\nstatic int\nmd_process_all_blocks(MD_CTX* ctx)\n{\n    int byte_off = 0;\n    int ret = 0;\n\n    /* ctx->containers now is not needed for detection of lists and list items\n     * so we reuse it for tracking what lists are loose or tight. We rely\n     * on the fact the vector is large enough to hold the deepest nesting\n     * level of lists. */\n    ctx->n_containers = 0;\n\n    while(byte_off < ctx->n_block_bytes) {\n        MD_BLOCK* block = (MD_BLOCK*)((char*)ctx->block_bytes + byte_off);\n        union {\n            MD_BLOCK_UL_DETAIL ul;\n            MD_BLOCK_OL_DETAIL ol;\n            MD_BLOCK_LI_DETAIL li;\n        } det;\n\n        switch(block->type) {\n            case MD_BLOCK_UL:\n                det.ul.is_tight = (block->flags & MD_BLOCK_LOOSE_LIST) ? FALSE : TRUE;\n                det.ul.mark = (CHAR) block->data;\n                break;\n\n            case MD_BLOCK_OL:\n                det.ol.start = block->n_lines;\n                det.ol.is_tight =  (block->flags & MD_BLOCK_LOOSE_LIST) ? FALSE : TRUE;\n                det.ol.mark_delimiter = (CHAR) block->data;\n                break;\n\n            case MD_BLOCK_LI:\n                det.li.is_task = (block->data != 0);\n                det.li.task_mark = (CHAR) block->data;\n                det.li.task_mark_offset = (OFF) block->n_lines;\n                break;\n\n            default:\n                /* noop */\n                break;\n        }\n\n        if(block->flags & MD_BLOCK_CONTAINER) {\n            if(block->flags & MD_BLOCK_CONTAINER_CLOSER) {\n                MD_LEAVE_BLOCK(block->type, &det);\n\n                if(block->type == MD_BLOCK_UL || block->type == MD_BLOCK_OL || block->type == MD_BLOCK_QUOTE)\n                    ctx->n_containers--;\n            }\n\n            if(block->flags & MD_BLOCK_CONTAINER_OPENER) {\n                MD_ENTER_BLOCK(block->type, &det);\n\n                if(block->type == MD_BLOCK_UL || block->type == MD_BLOCK_OL) {\n                    ctx->containers[ctx->n_containers].is_loose = (block->flags & MD_BLOCK_LOOSE_LIST);\n                    ctx->n_containers++;\n                } else if(block->type == MD_BLOCK_QUOTE) {\n                    /* This causes that any text in a block quote, even if\n                     * nested inside a tight list item, is wrapped with\n                     * <p>...</p>. */\n                    ctx->containers[ctx->n_containers].is_loose = TRUE;\n                    ctx->n_containers++;\n                }\n            }\n        } else {\n            MD_CHECK(md_process_leaf_block(ctx, block));\n\n            if(block->type == MD_BLOCK_CODE || block->type == MD_BLOCK_HTML)\n                byte_off += block->n_lines * sizeof(MD_VERBATIMLINE);\n            else\n                byte_off += block->n_lines * sizeof(MD_LINE);\n        }\n\n        byte_off += sizeof(MD_BLOCK);\n    }\n\n    ctx->n_block_bytes = 0;\n\nabort:\n    return ret;\n}\n\n\n/************************************\n ***  Grouping Lines into Blocks  ***\n ************************************/\n\nstatic void*\nmd_push_block_bytes(MD_CTX* ctx, int n_bytes)\n{\n    void* ptr;\n\n    if(ctx->n_block_bytes + n_bytes > ctx->alloc_block_bytes) {\n        void* new_block_bytes;\n\n        ctx->alloc_block_bytes = (ctx->alloc_block_bytes > 0\n                ? ctx->alloc_block_bytes + ctx->alloc_block_bytes / 2\n                : 512);\n        new_block_bytes = realloc(ctx->block_bytes, ctx->alloc_block_bytes);\n        if(new_block_bytes == NULL) {\n            MD_LOG(\"realloc() failed.\");\n            return NULL;\n        }\n\n        /* Fix the ->current_block after the reallocation. */\n        if(ctx->current_block != NULL) {\n            OFF off_current_block = (char*) ctx->current_block - (char*) ctx->block_bytes;\n            ctx->current_block = (MD_BLOCK*) ((char*) new_block_bytes + off_current_block);\n        }\n\n        ctx->block_bytes = new_block_bytes;\n    }\n\n    ptr = (char*)ctx->block_bytes + ctx->n_block_bytes;\n    ctx->n_block_bytes += n_bytes;\n    return ptr;\n}\n\nstatic int\nmd_start_new_block(MD_CTX* ctx, const MD_LINE_ANALYSIS* line)\n{\n    MD_BLOCK* block;\n\n    MD_ASSERT(ctx->current_block == NULL);\n\n    block = (MD_BLOCK*) md_push_block_bytes(ctx, sizeof(MD_BLOCK));\n    if(block == NULL)\n        return -1;\n\n    switch(line->type) {\n        case MD_LINE_HR:\n            block->type = MD_BLOCK_HR;\n            break;\n\n        case MD_LINE_ATXHEADER:\n        case MD_LINE_SETEXTHEADER:\n            block->type = MD_BLOCK_H;\n            break;\n\n        case MD_LINE_FENCEDCODE:\n        case MD_LINE_INDENTEDCODE:\n            block->type = MD_BLOCK_CODE;\n            break;\n\n        case MD_LINE_TEXT:\n            block->type = MD_BLOCK_P;\n            break;\n\n        case MD_LINE_HTML:\n            block->type = MD_BLOCK_HTML;\n            break;\n\n        case MD_LINE_BLANK:\n        case MD_LINE_SETEXTUNDERLINE:\n        case MD_LINE_TABLEUNDERLINE:\n        default:\n            MD_UNREACHABLE();\n            break;\n    }\n\n    block->flags = 0;\n    block->data = line->data;\n    block->n_lines = 0;\n\n    ctx->current_block = block;\n    return 0;\n}\n\n/* Eat from start of current (textual) block any reference definitions and\n * remember them so we can resolve any links referring to them.\n *\n * (Reference definitions can only be at start of it as they cannot break\n * a paragraph.)\n */\nstatic int\nmd_consume_link_reference_definitions(MD_CTX* ctx)\n{\n    MD_LINE* lines = (MD_LINE*) (ctx->current_block + 1);\n    int n_lines = ctx->current_block->n_lines;\n    int n = 0;\n\n    /* Compute how many lines at the start of the block form one or more\n     * reference definitions. */\n    while(n < n_lines) {\n        int n_link_ref_lines;\n\n        n_link_ref_lines = md_is_link_reference_definition(ctx,\n                                    lines + n, n_lines - n);\n        /* Not a reference definition? */\n        if(n_link_ref_lines == 0)\n            break;\n\n        /* We fail if it is the ref. def. but it could not be stored due\n         * a memory allocation error. */\n        if(n_link_ref_lines < 0)\n            return -1;\n\n        n += n_link_ref_lines;\n    }\n\n    /* If there was at least one reference definition, we need to remove\n     * its lines from the block, or perhaps even the whole block. */\n    if(n > 0) {\n        if(n == n_lines) {\n            /* Remove complete block. */\n            ctx->n_block_bytes -= n * sizeof(MD_LINE);\n            ctx->n_block_bytes -= sizeof(MD_BLOCK);\n            ctx->current_block = NULL;\n        } else {\n            /* Remove just some initial lines from the block. */\n            memmove(lines, lines + n, (n_lines - n) * sizeof(MD_LINE));\n            ctx->current_block->n_lines -= n;\n            ctx->n_block_bytes -= n * sizeof(MD_LINE);\n        }\n    }\n\n    return 0;\n}\n\nstatic int\nmd_end_current_block(MD_CTX* ctx)\n{\n    int ret = 0;\n\n    if(ctx->current_block == NULL)\n        return ret;\n\n    /* Check whether there is a reference definition. (We do this here instead\n     * of in md_analyze_line() because reference definition can take multiple\n     * lines.) */\n    if(ctx->current_block->type == MD_BLOCK_P  ||\n       (ctx->current_block->type == MD_BLOCK_H  &&  (ctx->current_block->flags & MD_BLOCK_SETEXT_HEADER)))\n    {\n        MD_LINE* lines = (MD_LINE*) (ctx->current_block + 1);\n        if(CH(lines[0].beg) == _T('[')) {\n            MD_CHECK(md_consume_link_reference_definitions(ctx));\n            if(ctx->current_block == NULL)\n                return ret;\n        }\n    }\n\n    if(ctx->current_block->type == MD_BLOCK_H  &&  (ctx->current_block->flags & MD_BLOCK_SETEXT_HEADER)) {\n        int n_lines = ctx->current_block->n_lines;\n\n        if(n_lines > 1) {\n            /* Get rid of the underline. */\n            ctx->current_block->n_lines--;\n            ctx->n_block_bytes -= sizeof(MD_LINE);\n        } else {\n            /* Only the underline has left after eating the ref. defs.\n             * Keep the line as beginning of a new ordinary paragraph. */\n            ctx->current_block->type = MD_BLOCK_P;\n            return 0;\n        }\n    }\n\n    /* Mark we are not building any block anymore. */\n    ctx->current_block = NULL;\n\nabort:\n    return ret;\n}\n\nstatic int\nmd_add_line_into_current_block(MD_CTX* ctx, const MD_LINE_ANALYSIS* analysis)\n{\n    MD_ASSERT(ctx->current_block != NULL);\n\n    if(ctx->current_block->type == MD_BLOCK_CODE || ctx->current_block->type == MD_BLOCK_HTML) {\n        MD_VERBATIMLINE* line;\n\n        line = (MD_VERBATIMLINE*) md_push_block_bytes(ctx, sizeof(MD_VERBATIMLINE));\n        if(line == NULL)\n            return -1;\n\n        line->indent = analysis->indent;\n        line->beg = analysis->beg;\n        line->end = analysis->end;\n    } else {\n        MD_LINE* line;\n\n        line = (MD_LINE*) md_push_block_bytes(ctx, sizeof(MD_LINE));\n        if(line == NULL)\n            return -1;\n\n        line->beg = analysis->beg;\n        line->end = analysis->end;\n    }\n    ctx->current_block->n_lines++;\n\n    return 0;\n}\n\nstatic int\nmd_push_container_bytes(MD_CTX* ctx, MD_BLOCKTYPE type, unsigned start,\n                        unsigned data, unsigned flags)\n{\n    MD_BLOCK* block;\n    int ret = 0;\n\n    MD_CHECK(md_end_current_block(ctx));\n\n    block = (MD_BLOCK*) md_push_block_bytes(ctx, sizeof(MD_BLOCK));\n    if(block == NULL)\n        return -1;\n\n    block->type = type;\n    block->flags = flags;\n    block->data = data;\n    block->n_lines = start;\n\nabort:\n    return ret;\n}\n\n\n\n/***********************\n ***  Line Analysis  ***\n ***********************/\n\nstatic int\nmd_is_hr_line(MD_CTX* ctx, OFF beg, OFF* p_end, OFF* p_killer)\n{\n    OFF off = beg + 1;\n    int n = 1;\n\n    while(off < ctx->size  &&  (CH(off) == CH(beg) || CH(off) == _T(' ') || CH(off) == _T('\\t'))) {\n        if(CH(off) == CH(beg))\n            n++;\n        off++;\n    }\n\n    if(n < 3) {\n        *p_killer = off;\n        return FALSE;\n    }\n\n    /* Nothing else can be present on the line. */\n    if(off < ctx->size  &&  !ISNEWLINE(off)) {\n        *p_killer = off;\n        return FALSE;\n    }\n\n    *p_end = off;\n    return TRUE;\n}\n\nstatic int\nmd_is_atxheader_line(MD_CTX* ctx, OFF beg, OFF* p_beg, OFF* p_end, unsigned* p_level)\n{\n    int n;\n    OFF off = beg + 1;\n\n    while(off < ctx->size  &&  CH(off) == _T('#')  &&  off - beg < 7)\n        off++;\n    n = off - beg;\n\n    if(n > 6)\n        return FALSE;\n    *p_level = n;\n\n    if(!(ctx->parser.flags & MD_FLAG_PERMISSIVEATXHEADERS)  &&  off < ctx->size  &&\n       CH(off) != _T(' ')  &&  CH(off) != _T('\\t')  &&  !ISNEWLINE(off))\n        return FALSE;\n\n    while(off < ctx->size  &&  CH(off) == _T(' '))\n        off++;\n    *p_beg = off;\n    *p_end = off;\n    return TRUE;\n}\n\nstatic int\nmd_is_setext_underline(MD_CTX* ctx, OFF beg, OFF* p_end, unsigned* p_level)\n{\n    OFF off = beg + 1;\n\n    while(off < ctx->size  &&  CH(off) == CH(beg))\n        off++;\n\n    /* Optionally, space(s) can follow. */\n    while(off < ctx->size  &&  CH(off) == _T(' '))\n        off++;\n\n    /* But nothing more is allowed on the line. */\n    if(off < ctx->size  &&  !ISNEWLINE(off))\n        return FALSE;\n\n    *p_level = (CH(beg) == _T('=') ? 1 : 2);\n    *p_end = off;\n    return TRUE;\n}\n\nstatic int\nmd_is_table_underline(MD_CTX* ctx, OFF beg, OFF* p_end, unsigned* p_col_count)\n{\n    OFF off = beg;\n    int found_pipe = FALSE;\n    unsigned col_count = 0;\n\n    if(off < ctx->size  &&  CH(off) == _T('|')) {\n        found_pipe = TRUE;\n        off++;\n        while(off < ctx->size  &&  ISWHITESPACE(off))\n            off++;\n    }\n\n    while(1) {\n        OFF cell_beg;\n        int delimited = FALSE;\n\n        /* Cell underline (\"-----\", \":----\", \"----:\" or \":----:\") */\n        cell_beg = off;\n        if(off < ctx->size  &&  CH(off) == _T(':'))\n            off++;\n        while(off < ctx->size  &&  CH(off) == _T('-'))\n            off++;\n        if(off < ctx->size  &&  CH(off) == _T(':'))\n            off++;\n        if(off - cell_beg < 3)\n            return FALSE;\n\n        col_count++;\n\n        /* Pipe delimiter (optional at the end of line). */\n        while(off < ctx->size  &&  ISWHITESPACE(off))\n            off++;\n        if(off < ctx->size  &&  CH(off) == _T('|')) {\n            delimited = TRUE;\n            found_pipe =  TRUE;\n            off++;\n            while(off < ctx->size  &&  ISWHITESPACE(off))\n                off++;\n        }\n\n        /* Success, if we reach end of line. */\n        if(off >= ctx->size  ||  ISNEWLINE(off))\n            break;\n\n        if(!delimited)\n            return FALSE;\n    }\n\n    if(!found_pipe)\n        return FALSE;\n\n    *p_end = off;\n    *p_col_count = col_count;\n    return TRUE;\n}\n\nstatic int\nmd_is_opening_code_fence(MD_CTX* ctx, OFF beg, OFF* p_end)\n{\n    OFF off = beg;\n\n    while(off < ctx->size && CH(off) == CH(beg))\n        off++;\n\n    /* Fence must have at least three characters. */\n    if(off - beg < 3)\n        return FALSE;\n\n    ctx->code_fence_length = off - beg;\n\n    /* Optionally, space(s) can follow. */\n    while(off < ctx->size  &&  CH(off) == _T(' '))\n        off++;\n\n    /* Optionally, an info string can follow. */\n    while(off < ctx->size  &&  !ISNEWLINE(off)) {\n        /* Backtick-based fence must not contain '`' in the info string. */\n        if(CH(beg) == _T('`')  &&  CH(off) == _T('`'))\n            return FALSE;\n        off++;\n    }\n\n    *p_end = off;\n    return TRUE;\n}\n\nstatic int\nmd_is_closing_code_fence(MD_CTX* ctx, CHAR ch, OFF beg, OFF* p_end)\n{\n    OFF off = beg;\n    int ret = FALSE;\n\n    /* Closing fence must have at least the same length and use same char as\n     * opening one. */\n    while(off < ctx->size  &&  CH(off) == ch)\n        off++;\n    if(off - beg < ctx->code_fence_length)\n        goto out;\n\n    /* Optionally, space(s) can follow */\n    while(off < ctx->size  &&  CH(off) == _T(' '))\n        off++;\n\n    /* But nothing more is allowed on the line. */\n    if(off < ctx->size  &&  !ISNEWLINE(off))\n        goto out;\n\n    ret = TRUE;\n\nout:\n    /* Note we set *p_end even on failure: If we are not closing fence, caller\n     * would eat the line anyway without any parsing. */\n    *p_end = off;\n    return ret;\n}\n\n/* Returns type of the raw HTML block, or FALSE if it is not HTML block.\n * (Refer to CommonMark specification for details about the types.)\n */\nstatic int\nmd_is_html_block_start_condition(MD_CTX* ctx, OFF beg)\n{\n    typedef struct TAG_tag TAG;\n    struct TAG_tag {\n        const CHAR* name;\n        unsigned len    : 8;\n    };\n\n    /* Type 6 is started by a long list of allowed tags. We use two-level\n     * tree to speed-up the search. */\n#ifdef X\n    #undef X\n#endif\n#define X(name)     { _T(name), (sizeof(name)-1) / sizeof(CHAR) }\n#define Xend        { NULL, 0 }\n    static const TAG t1[] = { X(\"script\"), X(\"pre\"), X(\"style\"), Xend };\n\n    static const TAG a6[] = { X(\"address\"), X(\"article\"), X(\"aside\"), Xend };\n    static const TAG b6[] = { X(\"base\"), X(\"basefont\"), X(\"blockquote\"), X(\"body\"), Xend };\n    static const TAG c6[] = { X(\"caption\"), X(\"center\"), X(\"col\"), X(\"colgroup\"), Xend };\n    static const TAG d6[] = { X(\"dd\"), X(\"details\"), X(\"dialog\"), X(\"dir\"),\n                              X(\"div\"), X(\"dl\"), X(\"dt\"), Xend };\n    static const TAG f6[] = { X(\"fieldset\"), X(\"figcaption\"), X(\"figure\"), X(\"footer\"),\n                              X(\"form\"), X(\"frame\"), X(\"frameset\"), Xend };\n    static const TAG h6[] = { X(\"h1\"), X(\"head\"), X(\"header\"), X(\"hr\"), X(\"html\"), Xend };\n    static const TAG i6[] = { X(\"iframe\"), Xend };\n    static const TAG l6[] = { X(\"legend\"), X(\"li\"), X(\"link\"), Xend };\n    static const TAG m6[] = { X(\"main\"), X(\"menu\"), X(\"menuitem\"), Xend };\n    static const TAG n6[] = { X(\"nav\"), X(\"noframes\"), Xend };\n    static const TAG o6[] = { X(\"ol\"), X(\"optgroup\"), X(\"option\"), Xend };\n    static const TAG p6[] = { X(\"p\"), X(\"param\"), Xend };\n    static const TAG s6[] = { X(\"section\"), X(\"source\"), X(\"summary\"), Xend };\n    static const TAG t6[] = { X(\"table\"), X(\"tbody\"), X(\"td\"), X(\"tfoot\"), X(\"th\"),\n                              X(\"thead\"), X(\"title\"), X(\"tr\"), X(\"track\"), Xend };\n    static const TAG u6[] = { X(\"ul\"), Xend };\n    static const TAG xx[] = { Xend };\n#undef X\n\n    static const TAG* map6[26] = {\n        a6, b6, c6, d6, xx, f6, xx, h6, i6, xx, xx, l6, m6,\n        n6, o6, p6, xx, xx, s6, t6, u6, xx, xx, xx, xx, xx\n    };\n    OFF off = beg + 1;\n    int i;\n\n    /* Check for type 1: <script, <pre, or <style */\n    for(i = 0; t1[i].name != NULL; i++) {\n        if(off + t1[i].len <= ctx->size) {\n            if(md_ascii_case_eq(STR(off), t1[i].name, t1[i].len))\n                return 1;\n        }\n    }\n\n    /* Check for type 2: <!-- */\n    if(off + 3 < ctx->size  &&  CH(off) == _T('!')  &&  CH(off+1) == _T('-')  &&  CH(off+2) == _T('-'))\n        return 2;\n\n    /* Check for type 3: <? */\n    if(off < ctx->size  &&  CH(off) == _T('?'))\n        return 3;\n\n    /* Check for type 4 or 5: <! */\n    if(off < ctx->size  &&  CH(off) == _T('!')) {\n        /* Check for type 4: <! followed by uppercase letter. */\n        if(off + 1 < ctx->size  &&  ISUPPER(off+1))\n            return 4;\n\n        /* Check for type 5: <![CDATA[ */\n        if(off + 8 < ctx->size) {\n            if(md_ascii_eq(STR(off), _T(\"![CDATA[\"), 8))\n                return 5;\n        }\n    }\n\n    /* Check for type 6: Many possible starting tags listed above. */\n    if(off + 1 < ctx->size  &&  (ISALPHA(off) || (CH(off) == _T('/') && ISALPHA(off+1)))) {\n        int slot;\n        const TAG* tags;\n\n        if(CH(off) == _T('/'))\n            off++;\n\n        slot = (ISUPPER(off) ? CH(off) - 'A' : CH(off) - 'a');\n        tags = map6[slot];\n\n        for(i = 0; tags[i].name != NULL; i++) {\n            if(off + tags[i].len <= ctx->size) {\n                if(md_ascii_case_eq(STR(off), tags[i].name, tags[i].len)) {\n                    OFF tmp = off + tags[i].len;\n                    if(tmp >= ctx->size)\n                        return 6;\n                    if(ISBLANK(tmp) || ISNEWLINE(tmp) || CH(tmp) == _T('>'))\n                        return 6;\n                    if(tmp+1 < ctx->size && CH(tmp) == _T('/') && CH(tmp+1) == _T('>'))\n                        return 6;\n                    break;\n                }\n            }\n        }\n    }\n\n    /* Check for type 7: any COMPLETE other opening or closing tag. */\n    if(off + 1 < ctx->size) {\n        OFF end;\n\n        if(md_is_html_tag(ctx, NULL, 0, beg, ctx->size, &end)) {\n            /* Only optional whitespace and new line may follow. */\n            while(end < ctx->size  &&  ISWHITESPACE(end))\n                end++;\n            if(end >= ctx->size  ||  ISNEWLINE(end))\n                return 7;\n        }\n    }\n\n    return FALSE;\n}\n\n/* Case sensitive check whether there is a substring 'what' between 'beg'\n * and end of line. */\nstatic int\nmd_line_contains(MD_CTX* ctx, OFF beg, const CHAR* what, SZ what_len, OFF* p_end)\n{\n    OFF i;\n    for(i = beg; i + what_len < ctx->size; i++) {\n        if(ISNEWLINE(i))\n            break;\n        if(memcmp(STR(i), what, what_len * sizeof(CHAR)) == 0) {\n            *p_end = i + what_len;\n            return TRUE;\n        }\n    }\n\n    *p_end = i;\n    return FALSE;\n}\n\n/* Returns type of HTML block end condition or FALSE if not an end condition.\n *\n * Note it fills p_end even when it is not end condition as the caller\n * does not need to analyze contents of a raw HTML block.\n */\nstatic int\nmd_is_html_block_end_condition(MD_CTX* ctx, OFF beg, OFF* p_end)\n{\n    switch(ctx->html_block_type) {\n        case 1:\n        {\n            OFF off = beg;\n\n            while(off < ctx->size  &&  !ISNEWLINE(off)) {\n                if(CH(off) == _T('<')) {\n                    if(md_ascii_case_eq(STR(off), _T(\"</script>\"), 9)) {\n                        *p_end = off + 9;\n                        return TRUE;\n                    }\n\n                    if(md_ascii_case_eq(STR(off), _T(\"</style>\"), 8)) {\n                        *p_end = off + 8;\n                        return TRUE;\n                    }\n\n                    if(md_ascii_case_eq(STR(off), _T(\"</pre>\"), 6)) {\n                        *p_end = off + 6;\n                        return TRUE;\n                    }\n                }\n\n                off++;\n            }\n            *p_end = off;\n            return FALSE;\n        }\n\n        case 2:\n            return (md_line_contains(ctx, beg, _T(\"-->\"), 3, p_end) ? 2 : FALSE);\n\n        case 3:\n            return (md_line_contains(ctx, beg, _T(\"?>\"), 2, p_end) ? 3 : FALSE);\n\n        case 4:\n            return (md_line_contains(ctx, beg, _T(\">\"), 1, p_end) ? 4 : FALSE);\n\n        case 5:\n            return (md_line_contains(ctx, beg, _T(\"]]>\"), 3, p_end) ? 5 : FALSE);\n\n        case 6:     /* Pass through */\n        case 7:\n            *p_end = beg;\n            return (ISNEWLINE(beg) ? ctx->html_block_type : FALSE);\n\n        default:\n            MD_UNREACHABLE();\n    }\n    return FALSE;\n}\n\n\nstatic int\nmd_is_container_compatible(const MD_CONTAINER* pivot, const MD_CONTAINER* container)\n{\n    /* Block quote has no \"items\" like lists. */\n    if(container->ch == _T('>'))\n        return FALSE;\n\n    if(container->ch != pivot->ch)\n        return FALSE;\n    if(container->mark_indent > pivot->contents_indent)\n        return FALSE;\n\n    return TRUE;\n}\n\nstatic int\nmd_push_container(MD_CTX* ctx, const MD_CONTAINER* container)\n{\n    if(ctx->n_containers >= ctx->alloc_containers) {\n        MD_CONTAINER* new_containers;\n\n        ctx->alloc_containers = (ctx->alloc_containers > 0\n                ? ctx->alloc_containers + ctx->alloc_containers / 2\n                : 16);\n        new_containers = realloc(ctx->containers, ctx->alloc_containers * sizeof(MD_CONTAINER));\n        if(new_containers == NULL) {\n            MD_LOG(\"realloc() failed.\");\n            return -1;\n        }\n\n        ctx->containers = new_containers;\n    }\n\n    memcpy(&ctx->containers[ctx->n_containers++], container, sizeof(MD_CONTAINER));\n    return 0;\n}\n\nstatic int\nmd_enter_child_containers(MD_CTX* ctx, int n_children)\n{\n    int i;\n    int ret = 0;\n\n    for(i = ctx->n_containers - n_children; i < ctx->n_containers; i++) {\n        MD_CONTAINER* c = &ctx->containers[i];\n        int is_ordered_list = FALSE;\n\n        switch(c->ch) {\n            case _T(')'):\n            case _T('.'):\n                is_ordered_list = TRUE;\n                MD_FALLTHROUGH();\n\n            case _T('-'):\n            case _T('+'):\n            case _T('*'):\n                /* Remember offset in ctx->block_bytes so we can revisit the\n                 * block if we detect it is a loose list. */\n                md_end_current_block(ctx);\n                c->block_byte_off = ctx->n_block_bytes;\n\n                MD_CHECK(md_push_container_bytes(ctx,\n                                (is_ordered_list ? MD_BLOCK_OL : MD_BLOCK_UL),\n                                c->start, c->ch, MD_BLOCK_CONTAINER_OPENER));\n                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI,\n                                c->task_mark_off,\n                                (c->is_task ? CH(c->task_mark_off) : 0),\n                                MD_BLOCK_CONTAINER_OPENER));\n                break;\n\n            case _T('>'):\n                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_QUOTE, 0, 0, MD_BLOCK_CONTAINER_OPENER));\n                break;\n\n            default:\n                MD_UNREACHABLE();\n                break;\n        }\n    }\n\nabort:\n    return ret;\n}\n\nstatic int\nmd_leave_child_containers(MD_CTX* ctx, int n_keep)\n{\n    int ret = 0;\n\n    while(ctx->n_containers > n_keep) {\n        MD_CONTAINER* c = &ctx->containers[ctx->n_containers-1];\n        int is_ordered_list = FALSE;\n\n        switch(c->ch) {\n            case _T(')'):\n            case _T('.'):\n                is_ordered_list = TRUE;\n                MD_FALLTHROUGH();\n\n            case _T('-'):\n            case _T('+'):\n            case _T('*'):\n                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI,\n                                c->task_mark_off, (c->is_task ? CH(c->task_mark_off) : 0),\n                                MD_BLOCK_CONTAINER_CLOSER));\n                MD_CHECK(md_push_container_bytes(ctx,\n                                (is_ordered_list ? MD_BLOCK_OL : MD_BLOCK_UL), 0,\n                                c->ch, MD_BLOCK_CONTAINER_CLOSER));\n                break;\n\n            case _T('>'):\n                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_QUOTE, 0,\n                                0, MD_BLOCK_CONTAINER_CLOSER));\n                break;\n\n            default:\n                MD_UNREACHABLE();\n                break;\n        }\n\n        ctx->n_containers--;\n    }\n\nabort:\n    return ret;\n}\n\nstatic int\nmd_is_container_mark(MD_CTX* ctx, unsigned indent, OFF beg, OFF* p_end, MD_CONTAINER* p_container)\n{\n    OFF off = beg;\n    OFF max_end;\n\n    if(off >= ctx->size  ||  indent >= ctx->code_indent_offset)\n        return FALSE;\n\n    /* Check for block quote mark. */\n    if(CH(off) == _T('>')) {\n        off++;\n        p_container->ch = _T('>');\n        p_container->is_loose = FALSE;\n        p_container->is_task = FALSE;\n        p_container->mark_indent = indent;\n        p_container->contents_indent = indent + 1;\n        *p_end = off;\n        return TRUE;\n    }\n\n    /* Check for list item bullet mark. */\n    if(ISANYOF(off, _T(\"-+*\"))  &&  (off+1 >= ctx->size || ISBLANK(off+1) || ISNEWLINE(off+1))) {\n        p_container->ch = CH(off);\n        p_container->is_loose = FALSE;\n        p_container->is_task = FALSE;\n        p_container->mark_indent = indent;\n        p_container->contents_indent = indent + 1;\n        *p_end = off+1;\n        return TRUE;\n    }\n\n    /* Check for ordered list item marks. */\n    max_end = off + 9;\n    if(max_end > ctx->size)\n        max_end = ctx->size;\n    p_container->start = 0;\n    while(off < max_end  &&  ISDIGIT(off)) {\n        p_container->start = p_container->start * 10 + CH(off) - _T('0');\n        off++;\n    }\n    if(off > beg  &&\n       (CH(off) == _T('.') || CH(off) == _T(')'))  &&\n       (off+1 >= ctx->size || ISBLANK(off+1) || ISNEWLINE(off+1)))\n    {\n        p_container->ch = CH(off);\n        p_container->is_loose = FALSE;\n        p_container->is_task = FALSE;\n        p_container->mark_indent = indent;\n        p_container->contents_indent = indent + off - beg + 1;\n        *p_end = off+1;\n        return TRUE;\n    }\n\n    return FALSE;\n}\n\nstatic unsigned\nmd_line_indentation(MD_CTX* ctx, unsigned total_indent, OFF beg, OFF* p_end)\n{\n    OFF off = beg;\n    unsigned indent = total_indent;\n\n    while(off < ctx->size  &&  ISBLANK(off)) {\n        if(CH(off) == _T('\\t'))\n            indent = (indent + 4) & ~3;\n        else\n            indent++;\n        off++;\n    }\n\n    *p_end = off;\n    return indent - total_indent;\n}\n\nstatic const MD_LINE_ANALYSIS md_dummy_blank_line = { MD_LINE_BLANK, 0, 0, 0, 0 };\n\n/* Analyze type of the line and find some its properties. This serves as a\n * main input for determining type and boundaries of a block. */\nstatic int\nmd_analyze_line(MD_CTX* ctx, OFF beg, OFF* p_end,\n                const MD_LINE_ANALYSIS* pivot_line, MD_LINE_ANALYSIS* line)\n{\n    unsigned total_indent = 0;\n    int n_parents = 0;\n    int n_brothers = 0;\n    int n_children = 0;\n    MD_CONTAINER container = { 0 };\n    int prev_line_has_list_loosening_effect = ctx->last_line_has_list_loosening_effect;\n    OFF off = beg;\n    OFF hr_killer = 0;\n    int ret = 0;\n\n    line->indent = md_line_indentation(ctx, total_indent, off, &off);\n    total_indent += line->indent;\n    line->beg = off;\n\n    /* Given the indentation and block quote marks '>', determine how many of\n     * the current containers are our parents. */\n    while(n_parents < ctx->n_containers) {\n        MD_CONTAINER* c = &ctx->containers[n_parents];\n\n        if(c->ch == _T('>')  &&  line->indent < ctx->code_indent_offset  &&\n            off < ctx->size  &&  CH(off) == _T('>'))\n        {\n            /* Block quote mark. */\n            off++;\n            total_indent++;\n            line->indent = md_line_indentation(ctx, total_indent, off, &off);\n            total_indent += line->indent;\n\n            /* The optional 1st space after '>' is part of the block quote mark. */\n            if(line->indent > 0)\n                line->indent--;\n\n            line->beg = off;\n\n        } else if(c->ch != _T('>')  &&  line->indent >= c->contents_indent) {\n            /* List. */\n            line->indent -= c->contents_indent;\n        } else {\n            break;\n        }\n\n        n_parents++;\n    }\n\n    if(off >= ctx->size  ||  ISNEWLINE(off)) {\n        /* Blank line does not need any real indentation to be nested inside\n         * a list. */\n        if(n_brothers + n_children == 0) {\n            while(n_parents < ctx->n_containers  &&  ctx->containers[n_parents].ch != _T('>'))\n                n_parents++;\n        }\n    }\n\n    while(TRUE) {\n        /* Check whether we are fenced code continuation. */\n        if(pivot_line->type == MD_LINE_FENCEDCODE) {\n            line->beg = off;\n\n            /* We are another MD_LINE_FENCEDCODE unless we are closing fence\n             * which we transform into MD_LINE_BLANK. */\n            if(line->indent < ctx->code_indent_offset) {\n                if(md_is_closing_code_fence(ctx, CH(pivot_line->beg), off, &off)) {\n                    line->type = MD_LINE_BLANK;\n                    ctx->last_line_has_list_loosening_effect = FALSE;\n                    break;\n                }\n            }\n\n            /* Change indentation accordingly to the initial code fence. */\n            if(n_parents == ctx->n_containers) {\n                if(line->indent > pivot_line->indent)\n                    line->indent -= pivot_line->indent;\n                else\n                    line->indent = 0;\n\n                line->type = MD_LINE_FENCEDCODE;\n                break;\n            }\n        }\n\n        /* Check whether we are HTML block continuation. */\n        if(pivot_line->type == MD_LINE_HTML  &&  ctx->html_block_type > 0) {\n            if(n_parents < ctx->n_containers) {\n                /* HTML block is implicitly ended if the enclosing container\n                 * block ends. */\n                ctx->html_block_type = 0;\n            } else {\n                int html_block_type;\n\n                html_block_type = md_is_html_block_end_condition(ctx, off, &off);\n                if(html_block_type > 0) {\n                    MD_ASSERT(html_block_type == ctx->html_block_type);\n\n                    /* Make sure this is the last line of the block. */\n                    ctx->html_block_type = 0;\n\n                    /* Some end conditions serve as blank lines at the same time. */\n                    if(html_block_type == 6 || html_block_type == 7) {\n                        line->type = MD_LINE_BLANK;\n                        line->indent = 0;\n                        break;\n                    }\n                }\n\n                line->type = MD_LINE_HTML;\n                n_parents = ctx->n_containers;\n                break;\n            }\n        }\n\n        /* Check for blank line. */\n        if(off >= ctx->size  ||  ISNEWLINE(off)) {\n            if(pivot_line->type == MD_LINE_INDENTEDCODE  &&  n_parents == ctx->n_containers) {\n                line->type = MD_LINE_INDENTEDCODE;\n                if(line->indent > ctx->code_indent_offset)\n                    line->indent -= ctx->code_indent_offset;\n                else\n                    line->indent = 0;\n                ctx->last_line_has_list_loosening_effect = FALSE;\n            } else {\n                line->type = MD_LINE_BLANK;\n                ctx->last_line_has_list_loosening_effect = (n_parents > 0  &&\n                        n_brothers + n_children == 0  &&\n                        ctx->containers[n_parents-1].ch != _T('>'));\n\n    #if 1\n                /* See https://github.com/mity/md4c/issues/6\n                 *\n                 * This ugly checking tests we are in (yet empty) list item but\n                 * not its very first line (i.e. not the line with the list\n                 * item mark).\n                 *\n                 * If we are such a blank line, then any following non-blank\n                 * line which would be part of the list item actually has to\n                 * end the list because according to the specification, \"a list\n                 * item can begin with at most one blank line.\"\n                 */\n                if(n_parents > 0  &&  ctx->containers[n_parents-1].ch != _T('>')  &&\n                   n_brothers + n_children == 0  &&  ctx->current_block == NULL  &&\n                   ctx->n_block_bytes > (int) sizeof(MD_BLOCK))\n                {\n                    MD_BLOCK* top_block = (MD_BLOCK*) ((char*)ctx->block_bytes + ctx->n_block_bytes - sizeof(MD_BLOCK));\n                    if(top_block->type == MD_BLOCK_LI)\n                        ctx->last_list_item_starts_with_two_blank_lines = TRUE;\n                }\n    #endif\n            }\n            break;\n        } else {\n    #if 1\n            /* This is the 2nd half of the hack. If the flag is set (i.e. there\n             * was a 2nd blank line at the beginning of the list item) and if\n             * we would otherwise still belong to the list item, we enforce\n             * the end of the list. */\n            ctx->last_line_has_list_loosening_effect = FALSE;\n            if(ctx->last_list_item_starts_with_two_blank_lines) {\n                if(n_parents > 0  &&  ctx->containers[n_parents-1].ch != _T('>')  &&\n                   n_brothers + n_children == 0  &&  ctx->current_block == NULL  &&\n                   ctx->n_block_bytes > (int) sizeof(MD_BLOCK))\n                {\n                    MD_BLOCK* top_block = (MD_BLOCK*) ((char*)ctx->block_bytes + ctx->n_block_bytes - sizeof(MD_BLOCK));\n                    if(top_block->type == MD_BLOCK_LI)\n                        n_parents--;\n                }\n\n                ctx->last_list_item_starts_with_two_blank_lines = FALSE;\n            }\n    #endif\n        }\n\n        /* Check whether we are Setext underline. */\n        if(line->indent < ctx->code_indent_offset  &&  pivot_line->type == MD_LINE_TEXT\n            &&  (CH(off) == _T('=') || CH(off) == _T('-'))\n            &&  (n_parents == ctx->n_containers))\n        {\n            unsigned level;\n\n            if(md_is_setext_underline(ctx, off, &off, &level)) {\n                line->type = MD_LINE_SETEXTUNDERLINE;\n                line->data = level;\n                break;\n            }\n        }\n\n        /* Check for thematic break line. */\n        if(line->indent < ctx->code_indent_offset  &&  ISANYOF(off, _T(\"-_*\"))  &&  off >= hr_killer) {\n            if(md_is_hr_line(ctx, off, &off, &hr_killer)) {\n                line->type = MD_LINE_HR;\n                break;\n            }\n        }\n\n        /* Check for \"brother\" container. I.e. whether we are another list item\n         * in already started list. */\n        if(n_parents < ctx->n_containers  &&  n_brothers + n_children == 0) {\n            OFF tmp;\n\n            if(md_is_container_mark(ctx, line->indent, off, &tmp, &container)  &&\n               md_is_container_compatible(&ctx->containers[n_parents], &container))\n            {\n                pivot_line = &md_dummy_blank_line;\n\n                off = tmp;\n\n                total_indent += container.contents_indent - container.mark_indent;\n                line->indent = md_line_indentation(ctx, total_indent, off, &off);\n                total_indent += line->indent;\n                line->beg = off;\n\n                /* Some of the following whitespace actually still belongs to the mark. */\n                if(off >= ctx->size || ISNEWLINE(off)) {\n                    container.contents_indent++;\n                } else if(line->indent <= ctx->code_indent_offset) {\n                    container.contents_indent += line->indent;\n                    line->indent = 0;\n                } else {\n                    container.contents_indent += 1;\n                    line->indent--;\n                }\n\n                ctx->containers[n_parents].mark_indent = container.mark_indent;\n                ctx->containers[n_parents].contents_indent = container.contents_indent;\n\n                n_brothers++;\n                continue;\n            }\n        }\n\n        /* Check for indented code.\n         * Note indented code block cannot interrupt a paragraph. */\n        if(line->indent >= ctx->code_indent_offset  &&\n            (pivot_line->type == MD_LINE_BLANK || pivot_line->type == MD_LINE_INDENTEDCODE))\n        {\n            line->type = MD_LINE_INDENTEDCODE;\n            MD_ASSERT(line->indent >= ctx->code_indent_offset);\n            line->indent -= ctx->code_indent_offset;\n            line->data = 0;\n            break;\n        }\n\n        /* Check for start of a new container block. */\n        if(line->indent < ctx->code_indent_offset  &&\n           md_is_container_mark(ctx, line->indent, off, &off, &container))\n        {\n            if(pivot_line->type == MD_LINE_TEXT  &&  n_parents == ctx->n_containers  &&\n                        (off >= ctx->size || ISNEWLINE(off))  &&  container.ch != _T('>'))\n            {\n                /* Noop. List mark followed by a blank line cannot interrupt a paragraph. */\n            } else if(pivot_line->type == MD_LINE_TEXT  &&  n_parents == ctx->n_containers  &&\n                        (container.ch == _T('.') || container.ch == _T(')'))  &&  container.start != 1)\n            {\n                /* Noop. Ordered list cannot interrupt a paragraph unless the start index is 1. */\n            } else {\n                total_indent += container.contents_indent - container.mark_indent;\n                line->indent = md_line_indentation(ctx, total_indent, off, &off);\n                total_indent += line->indent;\n\n                line->beg = off;\n                line->data = container.ch;\n\n                /* Some of the following whitespace actually still belongs to the mark. */\n                if(off >= ctx->size || ISNEWLINE(off)) {\n                    container.contents_indent++;\n                } else if(line->indent <= ctx->code_indent_offset) {\n                    container.contents_indent += line->indent;\n                    line->indent = 0;\n                } else {\n                    container.contents_indent += 1;\n                    line->indent--;\n                }\n\n                if(n_brothers + n_children == 0)\n                    pivot_line = &md_dummy_blank_line;\n\n                if(n_children == 0)\n                    MD_CHECK(md_leave_child_containers(ctx, n_parents + n_brothers));\n\n                n_children++;\n                MD_CHECK(md_push_container(ctx, &container));\n                continue;\n            }\n        }\n\n        /* Check whether we are table continuation. */\n        if(pivot_line->type == MD_LINE_TABLE  &&  n_parents == ctx->n_containers) {\n            line->type = MD_LINE_TABLE;\n            break;\n        }\n\n        /* Check for ATX header. */\n        if(line->indent < ctx->code_indent_offset  &&  CH(off) == _T('#')) {\n            unsigned level;\n\n            if(md_is_atxheader_line(ctx, off, &line->beg, &off, &level)) {\n                line->type = MD_LINE_ATXHEADER;\n                line->data = level;\n                break;\n            }\n        }\n\n        /* Check whether we are starting code fence. */\n        if(CH(off) == _T('`') || CH(off) == _T('~')) {\n            if(md_is_opening_code_fence(ctx, off, &off)) {\n                line->type = MD_LINE_FENCEDCODE;\n                line->data = 1;\n                break;\n            }\n        }\n\n        /* Check for start of raw HTML block. */\n        if(CH(off) == _T('<')  &&  !(ctx->parser.flags & MD_FLAG_NOHTMLBLOCKS))\n        {\n            ctx->html_block_type = md_is_html_block_start_condition(ctx, off);\n\n            /* HTML block type 7 cannot interrupt paragraph. */\n            if(ctx->html_block_type == 7  &&  pivot_line->type == MD_LINE_TEXT)\n                ctx->html_block_type = 0;\n\n            if(ctx->html_block_type > 0) {\n                /* The line itself also may immediately close the block. */\n                if(md_is_html_block_end_condition(ctx, off, &off) == ctx->html_block_type) {\n                    /* Make sure this is the last line of the block. */\n                    ctx->html_block_type = 0;\n                }\n\n                line->type = MD_LINE_HTML;\n                break;\n            }\n        }\n\n        /* Check for table underline. */\n        if((ctx->parser.flags & MD_FLAG_TABLES)  &&  pivot_line->type == MD_LINE_TEXT  &&\n           (CH(off) == _T('|') || CH(off) == _T('-') || CH(off) == _T(':'))  &&\n           n_parents == ctx->n_containers)\n        {\n            unsigned col_count;\n\n            if(ctx->current_block != NULL  &&  ctx->current_block->n_lines == 1  &&\n                md_is_table_underline(ctx, off, &off, &col_count))\n            {\n                line->data = col_count;\n                line->type = MD_LINE_TABLEUNDERLINE;\n                break;\n            }\n        }\n\n        /* By default, we are normal text line. */\n        line->type = MD_LINE_TEXT;\n        if(pivot_line->type == MD_LINE_TEXT  &&  n_brothers + n_children == 0) {\n            /* Lazy continuation. */\n            n_parents = ctx->n_containers;\n        }\n\n        /* Check for task mark. */\n        if((ctx->parser.flags & MD_FLAG_TASKLISTS)  &&  n_brothers + n_children > 0  &&\n           ISANYOF_(ctx->containers[ctx->n_containers-1].ch, _T(\"-+*.)\")))\n        {\n            OFF tmp = off;\n\n            while(tmp < ctx->size  &&  tmp < off + 3  &&  ISBLANK(tmp))\n                tmp++;\n            if(tmp + 2 < ctx->size  &&  CH(tmp) == _T('[')  &&\n               ISANYOF(tmp+1, _T(\"xX \"))  &&  CH(tmp+2) == _T(']')  &&\n               (tmp + 3 == ctx->size  ||  ISBLANK(tmp+3)  ||  ISNEWLINE(tmp+3)))\n            {\n                MD_CONTAINER* task_container = (n_children > 0 ? &ctx->containers[ctx->n_containers-1] : &container);\n                task_container->is_task = TRUE;\n                task_container->task_mark_off = tmp + 1;\n                off = tmp + 3;\n                while(ISWHITESPACE(off))\n                    off++;\n                line->beg = off;\n            }\n        }\n\n        break;\n    }\n\n    /* Scan for end of the line.\n     *\n     * Note this is quite a bottleneck of the parsing as we here iterate almost\n     * over compete document.\n     */\n#if defined __linux__ && !defined MD4C_USE_UTF16\n    /* Recent glibc versions have superbly optimized strcspn(), even using\n     * vectorization if available. */\n    if(ctx->doc_ends_with_newline  &&  off < ctx->size) {\n        while(TRUE) {\n            off += (OFF) strcspn(STR(off), \"\\r\\n\");\n\n            /* strcspn() can stop on zero terminator; but that can appear\n             * anywhere in the Markfown input... */\n            if(CH(off) == _T('\\0'))\n                off++;\n            else\n                break;\n        }\n    } else\n#endif\n    {\n        /* Optimization: Use some loop unrolling. */\n        while(off + 3 < ctx->size  &&  !ISNEWLINE(off+0)  &&  !ISNEWLINE(off+1)\n                                   &&  !ISNEWLINE(off+2)  &&  !ISNEWLINE(off+3))\n            off += 4;\n        while(off < ctx->size  &&  !ISNEWLINE(off))\n            off++;\n    }\n\n    /* Set end of the line. */\n    line->end = off;\n\n    /* But for ATX header, we should exclude the optional trailing mark. */\n    if(line->type == MD_LINE_ATXHEADER) {\n        OFF tmp = line->end;\n        while(tmp > line->beg && CH(tmp-1) == _T(' '))\n            tmp--;\n        while(tmp > line->beg && CH(tmp-1) == _T('#'))\n            tmp--;\n        if(tmp == line->beg || CH(tmp-1) == _T(' ') || (ctx->parser.flags & MD_FLAG_PERMISSIVEATXHEADERS))\n            line->end = tmp;\n    }\n\n    /* Trim trailing spaces. */\n    if(line->type != MD_LINE_INDENTEDCODE  &&  line->type != MD_LINE_FENCEDCODE) {\n        while(line->end > line->beg && CH(line->end-1) == _T(' '))\n            line->end--;\n    }\n\n    /* Eat also the new line. */\n    if(off < ctx->size && CH(off) == _T('\\r'))\n        off++;\n    if(off < ctx->size && CH(off) == _T('\\n'))\n        off++;\n\n    *p_end = off;\n\n    /* If we belong to a list after seeing a blank line, the list is loose. */\n    if(prev_line_has_list_loosening_effect  &&  line->type != MD_LINE_BLANK  &&  n_parents + n_brothers > 0) {\n        MD_CONTAINER* c = &ctx->containers[n_parents + n_brothers - 1];\n        if(c->ch != _T('>')) {\n            MD_BLOCK* block = (MD_BLOCK*) (((char*)ctx->block_bytes) + c->block_byte_off);\n            block->flags |= MD_BLOCK_LOOSE_LIST;\n        }\n    }\n\n    /* Leave any containers we are not part of anymore. */\n    if(n_children == 0  &&  n_parents + n_brothers < ctx->n_containers)\n        MD_CHECK(md_leave_child_containers(ctx, n_parents + n_brothers));\n\n    /* Enter any container we found a mark for. */\n    if(n_brothers > 0) {\n        MD_ASSERT(n_brothers == 1);\n        MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI,\n                    ctx->containers[n_parents].task_mark_off,\n                    (ctx->containers[n_parents].is_task ? CH(ctx->containers[n_parents].task_mark_off) : 0),\n                    MD_BLOCK_CONTAINER_CLOSER));\n        MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI,\n                    container.task_mark_off,\n                    (container.is_task ? CH(container.task_mark_off) : 0),\n                    MD_BLOCK_CONTAINER_OPENER));\n        ctx->containers[n_parents].is_task = container.is_task;\n        ctx->containers[n_parents].task_mark_off = container.task_mark_off;\n    }\n\n    if(n_children > 0)\n        MD_CHECK(md_enter_child_containers(ctx, n_children));\n\nabort:\n    return ret;\n}\n\nstatic int\nmd_process_line(MD_CTX* ctx, const MD_LINE_ANALYSIS** p_pivot_line, MD_LINE_ANALYSIS* line)\n{\n    const MD_LINE_ANALYSIS* pivot_line = *p_pivot_line;\n    int ret = 0;\n\n    /* Blank line ends current leaf block. */\n    if(line->type == MD_LINE_BLANK) {\n        MD_CHECK(md_end_current_block(ctx));\n        *p_pivot_line = &md_dummy_blank_line;\n        return 0;\n    }\n\n    /* Some line types form block on their own. */\n    if(line->type == MD_LINE_HR || line->type == MD_LINE_ATXHEADER) {\n        MD_CHECK(md_end_current_block(ctx));\n\n        /* Add our single-line block. */\n        MD_CHECK(md_start_new_block(ctx, line));\n        MD_CHECK(md_add_line_into_current_block(ctx, line));\n        MD_CHECK(md_end_current_block(ctx));\n        *p_pivot_line = &md_dummy_blank_line;\n        return 0;\n    }\n\n    /* MD_LINE_SETEXTUNDERLINE changes meaning of the current block and ends it. */\n    if(line->type == MD_LINE_SETEXTUNDERLINE) {\n        MD_ASSERT(ctx->current_block != NULL);\n        ctx->current_block->type = MD_BLOCK_H;\n        ctx->current_block->data = line->data;\n        ctx->current_block->flags |= MD_BLOCK_SETEXT_HEADER;\n        MD_CHECK(md_add_line_into_current_block(ctx, line));\n        MD_CHECK(md_end_current_block(ctx));\n        if(ctx->current_block == NULL) {\n            *p_pivot_line = &md_dummy_blank_line;\n        } else {\n            /* This happens if we have consumed all the body as link ref. defs.\n             * and downgraded the underline into start of a new paragraph block. */\n            line->type = MD_LINE_TEXT;\n            *p_pivot_line = line;\n        }\n        return 0;\n    }\n\n    /* MD_LINE_TABLEUNDERLINE changes meaning of the current block. */\n    if(line->type == MD_LINE_TABLEUNDERLINE) {\n        MD_ASSERT(ctx->current_block != NULL);\n        MD_ASSERT(ctx->current_block->n_lines == 1);\n        ctx->current_block->type = MD_BLOCK_TABLE;\n        ctx->current_block->data = line->data;\n        MD_ASSERT(pivot_line != &md_dummy_blank_line);\n        ((MD_LINE_ANALYSIS*)pivot_line)->type = MD_LINE_TABLE;\n        MD_CHECK(md_add_line_into_current_block(ctx, line));\n        return 0;\n    }\n\n    /* The current block also ends if the line has different type. */\n    if(line->type != pivot_line->type)\n        MD_CHECK(md_end_current_block(ctx));\n\n    /* The current line may start a new block. */\n    if(ctx->current_block == NULL) {\n        MD_CHECK(md_start_new_block(ctx, line));\n        *p_pivot_line = line;\n    }\n\n    /* In all other cases the line is just a continuation of the current block. */\n    MD_CHECK(md_add_line_into_current_block(ctx, line));\n\nabort:\n    return ret;\n}\n\nstatic int\nmd_process_doc(MD_CTX *ctx)\n{\n    const MD_LINE_ANALYSIS* pivot_line = &md_dummy_blank_line;\n    MD_LINE_ANALYSIS line_buf[2];\n    MD_LINE_ANALYSIS* line = &line_buf[0];\n    OFF off = 0;\n    int ret = 0;\n\n    MD_ENTER_BLOCK(MD_BLOCK_DOC, NULL);\n\n    while(off < ctx->size) {\n        if(line == pivot_line)\n            line = (line == &line_buf[0] ? &line_buf[1] : &line_buf[0]);\n\n        MD_CHECK(md_analyze_line(ctx, off, &off, pivot_line, line));\n        MD_CHECK(md_process_line(ctx, &pivot_line, line));\n    }\n\n    md_end_current_block(ctx);\n\n    MD_CHECK(md_build_ref_def_hashtable(ctx));\n\n    /* Process all blocks. */\n    MD_CHECK(md_leave_child_containers(ctx, 0));\n    MD_CHECK(md_process_all_blocks(ctx));\n\n    MD_LEAVE_BLOCK(MD_BLOCK_DOC, NULL);\n\nabort:\n\n#if 0\n    /* Output some memory consumption statistics. */\n    {\n        char buffer[256];\n        sprintf(buffer, \"Alloced %u bytes for block buffer.\",\n                    (unsigned)(ctx->alloc_block_bytes));\n        MD_LOG(buffer);\n\n        sprintf(buffer, \"Alloced %u bytes for containers buffer.\",\n                    (unsigned)(ctx->alloc_containers * sizeof(MD_CONTAINER)));\n        MD_LOG(buffer);\n\n        sprintf(buffer, \"Alloced %u bytes for marks buffer.\",\n                    (unsigned)(ctx->alloc_marks * sizeof(MD_MARK)));\n        MD_LOG(buffer);\n\n        sprintf(buffer, \"Alloced %u bytes for aux. buffer.\",\n                    (unsigned)(ctx->alloc_buffer * sizeof(MD_CHAR)));\n        MD_LOG(buffer);\n    }\n#endif\n\n    return ret;\n}\n\n\n/********************\n ***  Public API  ***\n ********************/\n\nint\nmd_parse(const MD_CHAR* text, MD_SIZE size, const MD_PARSER* parser, void* userdata)\n{\n    MD_CTX ctx;\n    int i;\n    int ret;\n\n    if(parser->abi_version != 0) {\n        if(parser->debug_log != NULL)\n            parser->debug_log(\"Unsupported abi_version.\", userdata);\n        return -1;\n    }\n\n    /* Setup context structure. */\n    memset(&ctx, 0, sizeof(MD_CTX));\n    ctx.text = text;\n    ctx.size = size;\n    memcpy(&ctx.parser, parser, sizeof(MD_PARSER));\n    ctx.userdata = userdata;\n    ctx.code_indent_offset = (ctx.parser.flags & MD_FLAG_NOINDENTEDCODEBLOCKS) ? (OFF)(-1) : 4;\n    md_build_mark_char_map(&ctx);\n    ctx.doc_ends_with_newline = (size > 0  &&  ISNEWLINE_(text[size-1]));\n\n    /* Reset all unresolved opener mark chains. */\n    for(i = 0; i < (int) SIZEOF_ARRAY(ctx.mark_chains); i++) {\n        ctx.mark_chains[i].head = -1;\n        ctx.mark_chains[i].tail = -1;\n    }\n    ctx.unresolved_link_head = -1;\n    ctx.unresolved_link_tail = -1;\n\n    /* All the work. */\n    ret = md_process_doc(&ctx);\n\n    /* Clean-up. */\n    md_free_ref_defs(&ctx);\n    md_free_ref_def_hashtable(&ctx);\n    free(ctx.buffer);\n    free(ctx.marks);\n    free(ctx.block_bytes);\n    free(ctx.containers);\n\n    return ret;\n}\n"], "fixing_code": ["\n# MD4C Change Log\n\n\n## Next Version (Work in Progress)\n\nFixes:\n\n * [#149](https://github.com/mity/md4c/issues/149):\n   A HTML block started in a container block (and not explicitly finished in\n   the block) could eat 1 line of actual contents.\n\n * [#150](https://github.com/mity/md4c/issues/150):\n   Fix md2html utility to output proper DOCTYPE and HTML tags when `full-html`\n   command line options is used, accordingly to the expected output format\n   (HTML or XHTML).\n\n * [#153](https://github.com/mity/md4c/issues/153),\n   [#154](https://github.com/mity/md4c/issues/154):\n   Set `MD_BLOCK_UL_DETAIL::mark` and `MD_BLOCK_OL_DETAIL::mark_delimiter`\n   correctly, even when the blocks are nested at the same line in a complicated\n   ways.\n\n * [#155](https://github.com/mity/md4c/issues/155):\n   Avoid reading 1 character beyond the input size in some complex cases.\n\n\n## Version 0.4.7\n\nChanges:\n\n * Add `MD_TABLE_DETAIL` structure into the API. The structure describes column\n   count and row count of the table, and pointer to it is passed into the\n   application-provided block callback with the `MD_BLOCK_TABLE` block type.\n\nFixes:\n\n * [#131](https://github.com/mity/md4c/issues/131):\n   Fix handling of a reference image nested in a reference link.\n\n * [#135](https://github.com/mity/md4c/issues/135):\n   Handle unmatched parenthesis pairs inside a permissive URL and WWW auto-links\n   in a way more compatible with the GFM.\n\n * [#138](https://github.com/mity/md4c/issues/138):\n   The tag `<tbody></tbody>` is now suppressed whenever the table has zero body\n   rows.\n\n * [#139](https://github.com/mity/md4c/issues/139):\n   Recognize a list item mark even when EOF follows it.\n\n * [#142](https://github.com/mity/md4c/issues/142):\n   Fix reference link definition label matching in a case when the label ends\n   with a Unicode character with non-trivial case folding mapping.\n\n\n## Version 0.4.6\n\nFixes:\n\n * [#130](https://github.com/mity/md4c/issues/130):\n   Fix `ISANYOF` macro, which could provide unexpected results when encountering\n   zero byte in the input text; in some cases leading to broken internal state\n   of the parser.\n\n   The bug could result in denial of service and possibly also to other security\n   implications. Applications are advised to update to 0.4.6.\n\n\n## Version 0.4.5\n\nFixes:\n\n * [#118](https://github.com/mity/md4c/issues/118):\n   Fix HTML renderer's `MD_HTML_FLAG_VERBATIM_ENTITIES` flag, exposed in the\n   `md2html` utility via `--fverbatim-entities`.\n\n * [#124](https://github.com/mity/md4c/issues/124):\n   Fix handling of indentation of 16 or more spaces in the fenced code blocks.\n\n\n## Version 0.4.4\n\nChanges:\n\n * Make Unicode-specific code compliant to Unicode 13.0.\n\nNew features:\n\n * The HTML renderer, developed originally as the heart of the `md2html`\n   utility, is now built as a standalone library, in order to simplify its\n   reuse in applications.\n\n * With `MD_HTML_FLAG_SKIP_UTF8_BOM`, the HTML renderer now skips UTF-8 byte\n   order mark (BOM) if the input begins with it, before passing to the Markdown\n   parser.\n\n   `md2html` utility automatically enables the flag (unless it is custom-built\n   with `-DMD4C_USE_ASCII`).\n\n * With `MD_HTML_FLAG_XHTML`, The HTML renderer generates XHTML instead of\n   HTML.\n\n   This effectively means `<br />` instead of `<br>`, `<hr />` instead of\n   `<hr>`, and `<img ... />` instead of `<img ...>`.\n\n   `md2html` utility now understands the command line option `-x` or `--xhtml`\n   enabling the XHTML mode.\n\nFixes:\n\n * [#113](https://github.com/mity/md4c/issues/113):\n   Add missing folding info data for the following Unicode characters:\n   `U+0184`, `U+018a`, `U+01b2`, `U+01b5`, `U+01f4`, `U+0372`, `U+038f`,\n   `U+1c84`, `U+1fb9`, `U+1fbb`, `U+1fd9`, `U+1fdb`, `U+1fe9`, `U+1feb`,\n   `U+1ff9`, `U+1ffb`, `U+2c7f`, `U+2ced`, `U+a77b`, `U+a792`, `U+a7c9`.\n\n   Due the bug, the link definition label matching did not work in the case\n   insensitive way for these characters.\n\n\n## Version 0.4.3\n\nNew features:\n\n * With `MD_FLAG_UNDERLINE`, spans enclosed in underscore (`_foo_`) are seen\n   as underline (`MD_SPAN_UNDERLINE`) rather than an ordinary emphasis or\n   strong emphasis.\n\nChanges:\n\n * The implementation of wiki-links extension (with `MD_FLAG_WIKILINKS`) has\n   been simplified.\n\n    - A noticeable increase of MD4C's memory footprint introduced by the\n      extension implementation in 0.4.0 has been removed.\n    - The priority handling towards other inline elements have been unified.\n      (This affects an obscure case where syntax of an image was in place of\n      wiki-link destination made the wiki-link invalid. Now *all* inline spans\n      in the wiki-link destination, including the images, is suppressed.)\n    - The length limitation of 100 characters now always applies to wiki-link\n      destination.\n\n * Recognition of strike-through spans (with the flag `MD_FLAG_STRIKETHROUGH`)\n   has become much stricter and, arguably, reasonable.\n\n    - Only single tildes (`~`) and double tildes (`~~`) are recognized as\n      strike-through marks. Longer ones are not anymore.\n    - The length of the opener and closer marks have to be the same.\n    - The tildes cannot open a strike-through span if a whitespace follows.\n    - The tildes cannot close a strike-through span if a whitespace precedes.\n\n   This change follows the changes of behavior in cmark-gfm some time ago, so\n   it is also beneficial from compatibility point of view.\n\n * When building MD4C by hand instead of using its CMake-based build, the UTF-8\n   support was by default disabled, unless explicitly asked for by defining\n   a preprocessor macro `MD4C_USE_UTF8`.\n\n   This has been changed and the UTF-8 mode now becomes the default, no matter\n   how `md4c.c` is compiled. If you need to disable it and use the ASCII-only\n   mode, you have explicitly define macro `MD4C_USE_ASCII` when compiling it.\n\n   (The CMake-based build as provided in our repository explicitly asked for\n   the UTF-8 support with `-DMD4C_USE_UTF8`. I.e. if you are using MD4C library\n   built with our vanilla `CMakeLists.txt` files, this change should not affect\n   you.)\n\nFixes:\n\n * Fixed some string length handling in the special `MD4C_USE_UTF16` build.\n\n   (This does not affect you unless you are on Windows and explicitly define\n   the macro when building MD4C.)\n\n * [#100](https://github.com/mity/md4c/issues/100):\n   Fixed an off-by-one error in the maximal length limit of some segments\n   of e-mail addresses used in autolinks.\n\n * [#107](https://github.com/mity/md4c/issues/107):\n   Fix mis-detection of asterisk-encoded emphasis in some corner cases when\n   length of the opener and closer differs, as in `***foo *bar baz***`.\n\n\n## Version 0.4.2\n\nFixes:\n\n * [#98](https://github.com/mity/md4c/issues/98):\n   Fix mis-detection of asterisk-encoded emphasis in some corner cases when\n   length of the opener and closer differs, as in `**a *b c** d*`.\n\n\n## Version 0.4.1\n\nUnfortunately, 0.4.0 has been released with badly updated ChangeLog. Fixing\nthis is the only change on 0.4.1.\n\n\n## Version 0.4.0\n\nNew features:\n\n * With `MD_FLAG_LATEXMATHSPANS`, LaTeX math spans (`$...$`) and LaTeX display\n   math spans (`$$...$$`) are now recognized. (Note though that the HTML\n   renderer outputs them verbatim in a custom `<x-equation>` tag.)\n\n   Contributed by [Tilman Roeder](https://github.com/dyedgreen).\n\n * With `MD_FLAG_WIKILINKS`, Wiki-style links (`[[...]]`) are now recognized.\n   (Note though that the HTML renderer renders them as a custom `<x-wikilink>`\n   tag.)\n\n   Contributed by [Nils Blomqvist](https://github.com/niblo).\n\nChanges:\n\n * Parsing of tables (with `MD_FLAG_TABLES`) is now closer to the way how\n   cmark-gfm parses tables as we do not require every row of the table to\n   contain a pipe `|` anymore.\n\n   As a consequence, paragraphs now cannot interrupt tables. A paragraph which\n   follows the table has to be delimited with a blank line.\n\nFixes:\n\n * [#94](https://github.com/mity/md4c/issues/94):\n   `md_build_ref_def_hashtable()`: Do not allocate more memory than strictly\n   needed.\n\n * [#95](https://github.com/mity/md4c/issues/95):\n   `md_is_container_mark()`: Ordered list mark requires at least one digit.\n\n * [#96](https://github.com/mity/md4c/issues/96):\n   Some fixes for link label comparison.\n\n\n## Version 0.3.4\n\nChanges:\n\n * Make Unicode-specific code compliant to Unicode 12.1.\n\n * Structure `MD_BLOCK_CODE_DETAIL` got new member `fenced_char`. Application\n   can use it to detect character used to form the block fences (`` ` `` or\n   `~`). In the case of indented code block, it is set to zero.\n\nFixes:\n\n * [#77](https://github.com/mity/md4c/issues/77):\n   Fix maximal count of digits for numerical character references, as requested\n   by CommonMark specification 0.29.\n\n * [#78](https://github.com/mity/md4c/issues/78):\n   Fix link reference definition label matching for Unicode characters where\n   the folding mapping leads to multiple codepoints, as e.g. in `\u1e9e` -> `SS`.\n\n * [#83](https://github.com/mity/md4c/issues/83):\n   Fix recognition of an empty blockquote which interrupts a paragraph.\n\n\n## Version 0.3.3\n\nChanges:\n\n * Make permissive URL autolink and permissive WWW autolink extensions stricter.\n\n   This brings the behavior closer to GFM and mitigates risk of false positives.\n   In particular, the domain has to contain at least one dot and parenthesis\n   can be part of the link destination only if `(` and `)` are balanced.\n\nFixes:\n\n * [#73](https://github.com/mity/md4c/issues/73):\n   Some raw HTML inputs could lead to quadratic parsing times.\n\n * [#74](https://github.com/mity/md4c/issues/74):\n   Fix input leading to a crash. Found by fuzzing.\n\n * [#76](https://github.com/mity/md4c/issues/76):\n   Fix handling of parenthesis in some corner cases of permissive URL autolink\n   and permissive WWW autolink extensions.\n\n\n## Version 0.3.2\n\nChanges:\n\n * Changes mandated by CommonMark specification 0.29.\n\n   Most importantly, the white-space trimming rules for code spans have changed.\n   At most one space/newline is trimmed from beginning/end of the code span\n   (if the code span contains some non-space contents, and if it begins and\n   ends with space at the same time). In all other cases the spaces in the code\n   span are now left intact.\n\n   Other changes in behavior are in corner cases only. Refer to [CommonMark\n   0.29 notes](https://github.com/commonmark/commonmark-spec/releases/tag/0.29)\n   for more info.\n\nFixes:\n\n * [#68](https://github.com/mity/md4c/issues/68):\n   Some specific HTML blocks were not recognized when EOF follows without any\n   end-of-line character.\n\n * [#69](https://github.com/mity/md4c/issues/69):\n   Strike-through span not working correctly when its opener mark is directly\n   followed by other opener mark; or when other closer mark directly precedes\n   its closer mark.\n\n\n## Version 0.3.1\n\nFixes:\n\n * [#58](https://github.com/mity/md4c/issues/58),\n   [#59](https://github.com/mity/md4c/issues/59),\n   [#60](https://github.com/mity/md4c/issues/60),\n   [#63](https://github.com/mity/md4c/issues/63),\n   [#66](https://github.com/mity/md4c/issues/66):\n   Some inputs could lead to quadratic parsing times. Thanks to Anders Kaseorg\n   for finding all those issues.\n\n * [#61](https://github.com/mity/md4c/issues/59):\n   Flag `MD_FLAG_NOHTMLSPANS` erroneously affected also recognition of\n   CommonMark autolinks.\n\n\n## Version 0.3.0\n\nNew features:\n\n * Add extension for GitHub-style task lists:\n\n   ```\n    * [x] foo\n    * [x] bar\n    * [ ] baz\n   ```\n\n   (It has to be explicitly enabled with `MD_FLAG_TASKLISTS`.)\n\n * Added support for building as a shared library. On non-Windows platforms,\n   this is now default behavior; on Windows static library is still the default.\n   The CMake option `BUILD_SHARED_LIBS` can be used to request one or the other\n   explicitly.\n\n   Contributed by Lisandro Dami\u00e1n Nicanor P\u00e9rez Meyer.\n\n * Renamed structure `MD_RENDERER` to `MD_PARSER` and refactorize its contents\n   a little bit. Note this is source-level incompatible and initialization code\n   in apps may need to be updated.\n\n   The aim of the change is to be more friendly for long-term ABI compatibility\n   we shall maintain, starting with this release.\n\n * Added `CHANGELOG.md` (this file).\n\n * Make sure `md_process_table_row()` reports the same count of table cells for\n   all table rows, no matter how broken the input is. The cell count is derived\n   from table underline line. Bogus cells in other rows are silently ignored.\n   Missing cells in other rows are reported as empty ones.\n\nFixes:\n\n * CID 1475544:\n   Calling `md_free_attribute()` on uninitialized data.\n\n * [#47](https://github.com/mity/md4c/issues/47):\n   Using bad offsets in `md_is_entity_str()`, in some cases leading to buffer\n   overflow.\n\n * [#51](https://github.com/mity/md4c/issues/51):\n   Segfault in `md_process_table_cell()`.\n\n * [#53](https://github.com/mity/md4c/issues/53):\n   With `MD_FLAG_PERMISSIVEURLAUTOLINKS` or `MD_FLAG_PERMISSIVEWWWAUTOLINKS`\n   we could generate bad output for ordinary Markdown links, if a non-space\n   character immediately follows like e.g. in `[link](http://github.com)X`.\n\n\n## Version 0.2.7\n\nThis was the last version before the changelog has been added.\n", "/*\n * MD4C: Markdown parser for C\n * (http://github.com/mity/md4c)\n *\n * Copyright (c) 2016-2020 Martin Mitas\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"md4c.h\"\n\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\n/*****************************\n ***  Miscellaneous Stuff  ***\n *****************************/\n\n#if !defined(__STDC_VERSION__) || __STDC_VERSION__ < 199409L\n    /* C89/90 or old compilers in general may not understand \"inline\". */\n    #if defined __GNUC__\n        #define inline __inline__\n    #elif defined _MSC_VER\n        #define inline __inline\n    #else\n        #define inline\n    #endif\n#endif\n\n/* Make the UTF-8 support the default. */\n#if !defined MD4C_USE_ASCII && !defined MD4C_USE_UTF8 && !defined MD4C_USE_UTF16\n    #define MD4C_USE_UTF8\n#endif\n\n/* Magic for making wide literals with MD4C_USE_UTF16. */\n#ifdef _T\n    #undef _T\n#endif\n#if defined MD4C_USE_UTF16\n    #define _T(x)           L##x\n#else\n    #define _T(x)           x\n#endif\n\n/* Misc. macros. */\n#define SIZEOF_ARRAY(a)     (sizeof(a) / sizeof(a[0]))\n\n#define STRINGIZE_(x)       #x\n#define STRINGIZE(x)        STRINGIZE_(x)\n\n#ifndef TRUE\n    #define TRUE            1\n    #define FALSE           0\n#endif\n\n#define MD_LOG(msg)                                                     \\\n    do {                                                                \\\n        if(ctx->parser.debug_log != NULL)                               \\\n            ctx->parser.debug_log((msg), ctx->userdata);                \\\n    } while(0)\n\n#ifdef DEBUG\n    #define MD_ASSERT(cond)                                             \\\n            do {                                                        \\\n                if(!(cond)) {                                           \\\n                    MD_LOG(__FILE__ \":\" STRINGIZE(__LINE__) \": \"        \\\n                           \"Assertion '\" STRINGIZE(cond) \"' failed.\");  \\\n                    exit(1);                                            \\\n                }                                                       \\\n            } while(0)\n\n    #define MD_UNREACHABLE()        MD_ASSERT(1 == 0)\n#else\n    #ifdef __GNUC__\n        #define MD_ASSERT(cond)     do { if(!(cond)) __builtin_unreachable(); } while(0)\n        #define MD_UNREACHABLE()    do { __builtin_unreachable(); } while(0)\n    #elif defined _MSC_VER  &&  _MSC_VER > 120\n        #define MD_ASSERT(cond)     do { __assume(cond); } while(0)\n        #define MD_UNREACHABLE()    do { __assume(0); } while(0)\n    #else\n        #define MD_ASSERT(cond)     do {} while(0)\n        #define MD_UNREACHABLE()    do {} while(0)\n    #endif\n#endif\n\n/* For falling through case labels in switch statements. */\n#if defined __clang__ && __clang_major__ >= 12\n    #define MD_FALLTHROUGH()        __attribute__((fallthrough))\n#elif defined __GNUC__ && __GNUC__ >= 7\n    #define MD_FALLTHROUGH()        __attribute__((fallthrough))\n#else\n    #define MD_FALLTHROUGH()        ((void)0)\n#endif\n\n/* Suppress \"unused parameter\" warnings. */\n#define MD_UNUSED(x)                ((void)x)\n\n\n/************************\n ***  Internal Types  ***\n ************************/\n\n/* These are omnipresent so lets save some typing. */\n#define CHAR    MD_CHAR\n#define SZ      MD_SIZE\n#define OFF     MD_OFFSET\n\ntypedef struct MD_MARK_tag MD_MARK;\ntypedef struct MD_BLOCK_tag MD_BLOCK;\ntypedef struct MD_CONTAINER_tag MD_CONTAINER;\ntypedef struct MD_REF_DEF_tag MD_REF_DEF;\n\n\n/* During analyzes of inline marks, we need to manage some \"mark chains\",\n * of (yet unresolved) openers. This structure holds start/end of the chain.\n * The chain internals are then realized through MD_MARK::prev and ::next.\n */\ntypedef struct MD_MARKCHAIN_tag MD_MARKCHAIN;\nstruct MD_MARKCHAIN_tag {\n    int head;   /* Index of first mark in the chain, or -1 if empty. */\n    int tail;   /* Index of last mark in the chain, or -1 if empty. */\n};\n\n/* Context propagated through all the parsing. */\ntypedef struct MD_CTX_tag MD_CTX;\nstruct MD_CTX_tag {\n    /* Immutable stuff (parameters of md_parse()). */\n    const CHAR* text;\n    SZ size;\n    MD_PARSER parser;\n    void* userdata;\n\n    /* When this is true, it allows some optimizations. */\n    int doc_ends_with_newline;\n\n    /* Helper temporary growing buffer. */\n    CHAR* buffer;\n    unsigned alloc_buffer;\n\n    /* Reference definitions. */\n    MD_REF_DEF* ref_defs;\n    int n_ref_defs;\n    int alloc_ref_defs;\n    void** ref_def_hashtable;\n    int ref_def_hashtable_size;\n\n    /* Stack of inline/span markers.\n     * This is only used for parsing a single block contents but by storing it\n     * here we may reuse the stack for subsequent blocks; i.e. we have fewer\n     * (re)allocations. */\n    MD_MARK* marks;\n    int n_marks;\n    int alloc_marks;\n\n#if defined MD4C_USE_UTF16\n    char mark_char_map[128];\n#else\n    char mark_char_map[256];\n#endif\n\n    /* For resolving of inline spans. */\n    MD_MARKCHAIN mark_chains[13];\n#define PTR_CHAIN                               (ctx->mark_chains[0])\n#define TABLECELLBOUNDARIES                     (ctx->mark_chains[1])\n#define ASTERISK_OPENERS_extraword_mod3_0       (ctx->mark_chains[2])\n#define ASTERISK_OPENERS_extraword_mod3_1       (ctx->mark_chains[3])\n#define ASTERISK_OPENERS_extraword_mod3_2       (ctx->mark_chains[4])\n#define ASTERISK_OPENERS_intraword_mod3_0       (ctx->mark_chains[5])\n#define ASTERISK_OPENERS_intraword_mod3_1       (ctx->mark_chains[6])\n#define ASTERISK_OPENERS_intraword_mod3_2       (ctx->mark_chains[7])\n#define UNDERSCORE_OPENERS                      (ctx->mark_chains[8])\n#define TILDE_OPENERS_1                         (ctx->mark_chains[9])\n#define TILDE_OPENERS_2                         (ctx->mark_chains[10])\n#define BRACKET_OPENERS                         (ctx->mark_chains[11])\n#define DOLLAR_OPENERS                          (ctx->mark_chains[12])\n#define OPENERS_CHAIN_FIRST                     2\n#define OPENERS_CHAIN_LAST                      12\n\n    int n_table_cell_boundaries;\n\n    /* For resolving links. */\n    int unresolved_link_head;\n    int unresolved_link_tail;\n\n    /* For resolving raw HTML. */\n    OFF html_comment_horizon;\n    OFF html_proc_instr_horizon;\n    OFF html_decl_horizon;\n    OFF html_cdata_horizon;\n\n    /* For block analysis.\n     * Notes:\n     *   -- It holds MD_BLOCK as well as MD_LINE structures. After each\n     *      MD_BLOCK, its (multiple) MD_LINE(s) follow.\n     *   -- For MD_BLOCK_HTML and MD_BLOCK_CODE, MD_VERBATIMLINE(s) are used\n     *      instead of MD_LINE(s).\n     */\n    void* block_bytes;\n    MD_BLOCK* current_block;\n    int n_block_bytes;\n    int alloc_block_bytes;\n\n    /* For container block analysis. */\n    MD_CONTAINER* containers;\n    int n_containers;\n    int alloc_containers;\n\n    /* Minimal indentation to call the block \"indented code block\". */\n    unsigned code_indent_offset;\n\n    /* Contextual info for line analysis. */\n    SZ code_fence_length;   /* For checking closing fence length. */\n    int html_block_type;    /* For checking closing raw HTML condition. */\n    int last_line_has_list_loosening_effect;\n    int last_list_item_starts_with_two_blank_lines;\n};\n\nenum MD_LINETYPE_tag {\n    MD_LINE_BLANK,\n    MD_LINE_HR,\n    MD_LINE_ATXHEADER,\n    MD_LINE_SETEXTHEADER,\n    MD_LINE_SETEXTUNDERLINE,\n    MD_LINE_INDENTEDCODE,\n    MD_LINE_FENCEDCODE,\n    MD_LINE_HTML,\n    MD_LINE_TEXT,\n    MD_LINE_TABLE,\n    MD_LINE_TABLEUNDERLINE\n};\ntypedef enum MD_LINETYPE_tag MD_LINETYPE;\n\ntypedef struct MD_LINE_ANALYSIS_tag MD_LINE_ANALYSIS;\nstruct MD_LINE_ANALYSIS_tag {\n    MD_LINETYPE type    : 16;\n    unsigned data       : 16;\n    OFF beg;\n    OFF end;\n    unsigned indent;        /* Indentation level. */\n};\n\ntypedef struct MD_LINE_tag MD_LINE;\nstruct MD_LINE_tag {\n    OFF beg;\n    OFF end;\n};\n\ntypedef struct MD_VERBATIMLINE_tag MD_VERBATIMLINE;\nstruct MD_VERBATIMLINE_tag {\n    OFF beg;\n    OFF end;\n    OFF indent;\n};\n\n\n/*****************\n ***  Helpers  ***\n *****************/\n\n/* Character accessors. */\n#define CH(off)                 (ctx->text[(off)])\n#define STR(off)                (ctx->text + (off))\n\n/* Character classification.\n * Note we assume ASCII compatibility of code points < 128 here. */\n#define ISIN_(ch, ch_min, ch_max)       ((ch_min) <= (unsigned)(ch) && (unsigned)(ch) <= (ch_max))\n#define ISANYOF_(ch, palette)           ((ch) != _T('\\0')  &&  md_strchr((palette), (ch)) != NULL)\n#define ISANYOF2_(ch, ch1, ch2)         ((ch) == (ch1) || (ch) == (ch2))\n#define ISANYOF3_(ch, ch1, ch2, ch3)    ((ch) == (ch1) || (ch) == (ch2) || (ch) == (ch3))\n#define ISASCII_(ch)                    ((unsigned)(ch) <= 127)\n#define ISBLANK_(ch)                    (ISANYOF2_((ch), _T(' '), _T('\\t')))\n#define ISNEWLINE_(ch)                  (ISANYOF2_((ch), _T('\\r'), _T('\\n')))\n#define ISWHITESPACE_(ch)               (ISBLANK_(ch) || ISANYOF2_((ch), _T('\\v'), _T('\\f')))\n#define ISCNTRL_(ch)                    ((unsigned)(ch) <= 31 || (unsigned)(ch) == 127)\n#define ISPUNCT_(ch)                    (ISIN_(ch, 33, 47) || ISIN_(ch, 58, 64) || ISIN_(ch, 91, 96) || ISIN_(ch, 123, 126))\n#define ISUPPER_(ch)                    (ISIN_(ch, _T('A'), _T('Z')))\n#define ISLOWER_(ch)                    (ISIN_(ch, _T('a'), _T('z')))\n#define ISALPHA_(ch)                    (ISUPPER_(ch) || ISLOWER_(ch))\n#define ISDIGIT_(ch)                    (ISIN_(ch, _T('0'), _T('9')))\n#define ISXDIGIT_(ch)                   (ISDIGIT_(ch) || ISIN_(ch, _T('A'), _T('F')) || ISIN_(ch, _T('a'), _T('f')))\n#define ISALNUM_(ch)                    (ISALPHA_(ch) || ISDIGIT_(ch))\n\n#define ISANYOF(off, palette)           ISANYOF_(CH(off), (palette))\n#define ISANYOF2(off, ch1, ch2)         ISANYOF2_(CH(off), (ch1), (ch2))\n#define ISANYOF3(off, ch1, ch2, ch3)    ISANYOF3_(CH(off), (ch1), (ch2), (ch3))\n#define ISASCII(off)                    ISASCII_(CH(off))\n#define ISBLANK(off)                    ISBLANK_(CH(off))\n#define ISNEWLINE(off)                  ISNEWLINE_(CH(off))\n#define ISWHITESPACE(off)               ISWHITESPACE_(CH(off))\n#define ISCNTRL(off)                    ISCNTRL_(CH(off))\n#define ISPUNCT(off)                    ISPUNCT_(CH(off))\n#define ISUPPER(off)                    ISUPPER_(CH(off))\n#define ISLOWER(off)                    ISLOWER_(CH(off))\n#define ISALPHA(off)                    ISALPHA_(CH(off))\n#define ISDIGIT(off)                    ISDIGIT_(CH(off))\n#define ISXDIGIT(off)                   ISXDIGIT_(CH(off))\n#define ISALNUM(off)                    ISALNUM_(CH(off))\n\n\n#if defined MD4C_USE_UTF16\n    #define md_strchr wcschr\n#else\n    #define md_strchr strchr\n#endif\n\n\n/* Case insensitive check of string equality. */\nstatic inline int\nmd_ascii_case_eq(const CHAR* s1, const CHAR* s2, SZ n)\n{\n    OFF i;\n    for(i = 0; i < n; i++) {\n        CHAR ch1 = s1[i];\n        CHAR ch2 = s2[i];\n\n        if(ISLOWER_(ch1))\n            ch1 += ('A'-'a');\n        if(ISLOWER_(ch2))\n            ch2 += ('A'-'a');\n        if(ch1 != ch2)\n            return FALSE;\n    }\n    return TRUE;\n}\n\nstatic inline int\nmd_ascii_eq(const CHAR* s1, const CHAR* s2, SZ n)\n{\n    return memcmp(s1, s2, n * sizeof(CHAR)) == 0;\n}\n\nstatic int\nmd_text_with_null_replacement(MD_CTX* ctx, MD_TEXTTYPE type, const CHAR* str, SZ size)\n{\n    OFF off = 0;\n    int ret = 0;\n\n    while(1) {\n        while(off < size  &&  str[off] != _T('\\0'))\n            off++;\n\n        if(off > 0) {\n            ret = ctx->parser.text(type, str, off, ctx->userdata);\n            if(ret != 0)\n                return ret;\n\n            str += off;\n            size -= off;\n            off = 0;\n        }\n\n        if(off >= size)\n            return 0;\n\n        ret = ctx->parser.text(MD_TEXT_NULLCHAR, _T(\"\"), 1, ctx->userdata);\n        if(ret != 0)\n            return ret;\n        off++;\n    }\n}\n\n\n#define MD_CHECK(func)                                                      \\\n    do {                                                                    \\\n        ret = (func);                                                       \\\n        if(ret < 0)                                                         \\\n            goto abort;                                                     \\\n    } while(0)\n\n\n#define MD_TEMP_BUFFER(sz)                                                  \\\n    do {                                                                    \\\n        if(sz > ctx->alloc_buffer) {                                        \\\n            CHAR* new_buffer;                                               \\\n            SZ new_size = ((sz) + (sz) / 2 + 128) & ~127;                   \\\n                                                                            \\\n            new_buffer = realloc(ctx->buffer, new_size);                    \\\n            if(new_buffer == NULL) {                                        \\\n                MD_LOG(\"realloc() failed.\");                                \\\n                ret = -1;                                                   \\\n                goto abort;                                                 \\\n            }                                                               \\\n                                                                            \\\n            ctx->buffer = new_buffer;                                       \\\n            ctx->alloc_buffer = new_size;                                   \\\n        }                                                                   \\\n    } while(0)\n\n\n#define MD_ENTER_BLOCK(type, arg)                                           \\\n    do {                                                                    \\\n        ret = ctx->parser.enter_block((type), (arg), ctx->userdata);        \\\n        if(ret != 0) {                                                      \\\n            MD_LOG(\"Aborted from enter_block() callback.\");                 \\\n            goto abort;                                                     \\\n        }                                                                   \\\n    } while(0)\n\n#define MD_LEAVE_BLOCK(type, arg)                                           \\\n    do {                                                                    \\\n        ret = ctx->parser.leave_block((type), (arg), ctx->userdata);        \\\n        if(ret != 0) {                                                      \\\n            MD_LOG(\"Aborted from leave_block() callback.\");                 \\\n            goto abort;                                                     \\\n        }                                                                   \\\n    } while(0)\n\n#define MD_ENTER_SPAN(type, arg)                                            \\\n    do {                                                                    \\\n        ret = ctx->parser.enter_span((type), (arg), ctx->userdata);         \\\n        if(ret != 0) {                                                      \\\n            MD_LOG(\"Aborted from enter_span() callback.\");                  \\\n            goto abort;                                                     \\\n        }                                                                   \\\n    } while(0)\n\n#define MD_LEAVE_SPAN(type, arg)                                            \\\n    do {                                                                    \\\n        ret = ctx->parser.leave_span((type), (arg), ctx->userdata);         \\\n        if(ret != 0) {                                                      \\\n            MD_LOG(\"Aborted from leave_span() callback.\");                  \\\n            goto abort;                                                     \\\n        }                                                                   \\\n    } while(0)\n\n#define MD_TEXT(type, str, size)                                            \\\n    do {                                                                    \\\n        if(size > 0) {                                                      \\\n            ret = ctx->parser.text((type), (str), (size), ctx->userdata);   \\\n            if(ret != 0) {                                                  \\\n                MD_LOG(\"Aborted from text() callback.\");                    \\\n                goto abort;                                                 \\\n            }                                                               \\\n        }                                                                   \\\n    } while(0)\n\n#define MD_TEXT_INSECURE(type, str, size)                                   \\\n    do {                                                                    \\\n        if(size > 0) {                                                      \\\n            ret = md_text_with_null_replacement(ctx, type, str, size);      \\\n            if(ret != 0) {                                                  \\\n                MD_LOG(\"Aborted from text() callback.\");                    \\\n                goto abort;                                                 \\\n            }                                                               \\\n        }                                                                   \\\n    } while(0)\n\n\n\n/*************************\n ***  Unicode Support  ***\n *************************/\n\ntypedef struct MD_UNICODE_FOLD_INFO_tag MD_UNICODE_FOLD_INFO;\nstruct MD_UNICODE_FOLD_INFO_tag {\n    unsigned codepoints[3];\n    unsigned n_codepoints;\n};\n\n\n#if defined MD4C_USE_UTF16 || defined MD4C_USE_UTF8\n    /* Binary search over sorted \"map\" of codepoints. Consecutive sequences\n     * of codepoints may be encoded in the map by just using the\n     * (MIN_CODEPOINT | 0x40000000) and (MAX_CODEPOINT | 0x80000000).\n     *\n     * Returns index of the found record in the map (in the case of ranges,\n     * the minimal value is used); or -1 on failure. */\n    static int\n    md_unicode_bsearch__(unsigned codepoint, const unsigned* map, size_t map_size)\n    {\n        int beg, end;\n        int pivot_beg, pivot_end;\n\n        beg = 0;\n        end = (int) map_size-1;\n        while(beg <= end) {\n            /* Pivot may be a range, not just a single value. */\n            pivot_beg = pivot_end = (beg + end) / 2;\n            if(map[pivot_end] & 0x40000000)\n                pivot_end++;\n            if(map[pivot_beg] & 0x80000000)\n                pivot_beg--;\n\n            if(codepoint < (map[pivot_beg] & 0x00ffffff))\n                end = pivot_beg - 1;\n            else if(codepoint > (map[pivot_end] & 0x00ffffff))\n                beg = pivot_end + 1;\n            else\n                return pivot_beg;\n        }\n\n        return -1;\n    }\n\n    static int\n    md_is_unicode_whitespace__(unsigned codepoint)\n    {\n#define R(cp_min, cp_max)   ((cp_min) | 0x40000000), ((cp_max) | 0x80000000)\n#define S(cp)               (cp)\n        /* Unicode \"Zs\" category.\n         * (generated by scripts/build_whitespace_map.py) */\n        static const unsigned WHITESPACE_MAP[] = {\n            S(0x0020), S(0x00a0), S(0x1680), R(0x2000,0x200a), S(0x202f), S(0x205f), S(0x3000)\n        };\n#undef R\n#undef S\n\n        /* The ASCII ones are the most frequently used ones, also CommonMark\n         * specification requests few more in this range. */\n        if(codepoint <= 0x7f)\n            return ISWHITESPACE_(codepoint);\n\n        return (md_unicode_bsearch__(codepoint, WHITESPACE_MAP, SIZEOF_ARRAY(WHITESPACE_MAP)) >= 0);\n    }\n\n    static int\n    md_is_unicode_punct__(unsigned codepoint)\n    {\n#define R(cp_min, cp_max)   ((cp_min) | 0x40000000), ((cp_max) | 0x80000000)\n#define S(cp)               (cp)\n        /* Unicode \"Pc\", \"Pd\", \"Pe\", \"Pf\", \"Pi\", \"Po\", \"Ps\" categories.\n         * (generated by scripts/build_punct_map.py) */\n        static const unsigned PUNCT_MAP[] = {\n            R(0x0021,0x0023), R(0x0025,0x002a), R(0x002c,0x002f), R(0x003a,0x003b), R(0x003f,0x0040),\n            R(0x005b,0x005d), S(0x005f), S(0x007b), S(0x007d), S(0x00a1), S(0x00a7), S(0x00ab), R(0x00b6,0x00b7),\n            S(0x00bb), S(0x00bf), S(0x037e), S(0x0387), R(0x055a,0x055f), R(0x0589,0x058a), S(0x05be), S(0x05c0),\n            S(0x05c3), S(0x05c6), R(0x05f3,0x05f4), R(0x0609,0x060a), R(0x060c,0x060d), S(0x061b), R(0x061e,0x061f),\n            R(0x066a,0x066d), S(0x06d4), R(0x0700,0x070d), R(0x07f7,0x07f9), R(0x0830,0x083e), S(0x085e),\n            R(0x0964,0x0965), S(0x0970), S(0x09fd), S(0x0a76), S(0x0af0), S(0x0c77), S(0x0c84), S(0x0df4), S(0x0e4f),\n            R(0x0e5a,0x0e5b), R(0x0f04,0x0f12), S(0x0f14), R(0x0f3a,0x0f3d), S(0x0f85), R(0x0fd0,0x0fd4),\n            R(0x0fd9,0x0fda), R(0x104a,0x104f), S(0x10fb), R(0x1360,0x1368), S(0x1400), S(0x166e), R(0x169b,0x169c),\n            R(0x16eb,0x16ed), R(0x1735,0x1736), R(0x17d4,0x17d6), R(0x17d8,0x17da), R(0x1800,0x180a),\n            R(0x1944,0x1945), R(0x1a1e,0x1a1f), R(0x1aa0,0x1aa6), R(0x1aa8,0x1aad), R(0x1b5a,0x1b60),\n            R(0x1bfc,0x1bff), R(0x1c3b,0x1c3f), R(0x1c7e,0x1c7f), R(0x1cc0,0x1cc7), S(0x1cd3), R(0x2010,0x2027),\n            R(0x2030,0x2043), R(0x2045,0x2051), R(0x2053,0x205e), R(0x207d,0x207e), R(0x208d,0x208e),\n            R(0x2308,0x230b), R(0x2329,0x232a), R(0x2768,0x2775), R(0x27c5,0x27c6), R(0x27e6,0x27ef),\n            R(0x2983,0x2998), R(0x29d8,0x29db), R(0x29fc,0x29fd), R(0x2cf9,0x2cfc), R(0x2cfe,0x2cff), S(0x2d70),\n            R(0x2e00,0x2e2e), R(0x2e30,0x2e4f), S(0x2e52), R(0x3001,0x3003), R(0x3008,0x3011), R(0x3014,0x301f),\n            S(0x3030), S(0x303d), S(0x30a0), S(0x30fb), R(0xa4fe,0xa4ff), R(0xa60d,0xa60f), S(0xa673), S(0xa67e),\n            R(0xa6f2,0xa6f7), R(0xa874,0xa877), R(0xa8ce,0xa8cf), R(0xa8f8,0xa8fa), S(0xa8fc), R(0xa92e,0xa92f),\n            S(0xa95f), R(0xa9c1,0xa9cd), R(0xa9de,0xa9df), R(0xaa5c,0xaa5f), R(0xaade,0xaadf), R(0xaaf0,0xaaf1),\n            S(0xabeb), R(0xfd3e,0xfd3f), R(0xfe10,0xfe19), R(0xfe30,0xfe52), R(0xfe54,0xfe61), S(0xfe63), S(0xfe68),\n            R(0xfe6a,0xfe6b), R(0xff01,0xff03), R(0xff05,0xff0a), R(0xff0c,0xff0f), R(0xff1a,0xff1b),\n            R(0xff1f,0xff20), R(0xff3b,0xff3d), S(0xff3f), S(0xff5b), S(0xff5d), R(0xff5f,0xff65), R(0x10100,0x10102),\n            S(0x1039f), S(0x103d0), S(0x1056f), S(0x10857), S(0x1091f), S(0x1093f), R(0x10a50,0x10a58), S(0x10a7f),\n            R(0x10af0,0x10af6), R(0x10b39,0x10b3f), R(0x10b99,0x10b9c), S(0x10ead), R(0x10f55,0x10f59),\n            R(0x11047,0x1104d), R(0x110bb,0x110bc), R(0x110be,0x110c1), R(0x11140,0x11143), R(0x11174,0x11175),\n            R(0x111c5,0x111c8), S(0x111cd), S(0x111db), R(0x111dd,0x111df), R(0x11238,0x1123d), S(0x112a9),\n            R(0x1144b,0x1144f), R(0x1145a,0x1145b), S(0x1145d), S(0x114c6), R(0x115c1,0x115d7), R(0x11641,0x11643),\n            R(0x11660,0x1166c), R(0x1173c,0x1173e), S(0x1183b), R(0x11944,0x11946), S(0x119e2), R(0x11a3f,0x11a46),\n            R(0x11a9a,0x11a9c), R(0x11a9e,0x11aa2), R(0x11c41,0x11c45), R(0x11c70,0x11c71), R(0x11ef7,0x11ef8),\n            S(0x11fff), R(0x12470,0x12474), R(0x16a6e,0x16a6f), S(0x16af5), R(0x16b37,0x16b3b), S(0x16b44),\n            R(0x16e97,0x16e9a), S(0x16fe2), S(0x1bc9f), R(0x1da87,0x1da8b), R(0x1e95e,0x1e95f)\n        };\n#undef R\n#undef S\n\n        /* The ASCII ones are the most frequently used ones, also CommonMark\n         * specification requests few more in this range. */\n        if(codepoint <= 0x7f)\n            return ISPUNCT_(codepoint);\n\n        return (md_unicode_bsearch__(codepoint, PUNCT_MAP, SIZEOF_ARRAY(PUNCT_MAP)) >= 0);\n    }\n\n    static void\n    md_get_unicode_fold_info(unsigned codepoint, MD_UNICODE_FOLD_INFO* info)\n    {\n#define R(cp_min, cp_max)   ((cp_min) | 0x40000000), ((cp_max) | 0x80000000)\n#define S(cp)               (cp)\n        /* Unicode \"Pc\", \"Pd\", \"Pe\", \"Pf\", \"Pi\", \"Po\", \"Ps\" categories.\n         * (generated by scripts/build_folding_map.py) */\n        static const unsigned FOLD_MAP_1[] = {\n            R(0x0041,0x005a), S(0x00b5), R(0x00c0,0x00d6), R(0x00d8,0x00de), R(0x0100,0x012e), R(0x0132,0x0136),\n            R(0x0139,0x0147), R(0x014a,0x0176), S(0x0178), R(0x0179,0x017d), S(0x017f), S(0x0181), S(0x0182),\n            S(0x0184), S(0x0186), S(0x0187), S(0x0189), S(0x018a), S(0x018b), S(0x018e), S(0x018f), S(0x0190),\n            S(0x0191), S(0x0193), S(0x0194), S(0x0196), S(0x0197), S(0x0198), S(0x019c), S(0x019d), S(0x019f),\n            R(0x01a0,0x01a4), S(0x01a6), S(0x01a7), S(0x01a9), S(0x01ac), S(0x01ae), S(0x01af), S(0x01b1), S(0x01b2),\n            S(0x01b3), S(0x01b5), S(0x01b7), S(0x01b8), S(0x01bc), S(0x01c4), S(0x01c5), S(0x01c7), S(0x01c8),\n            S(0x01ca), R(0x01cb,0x01db), R(0x01de,0x01ee), S(0x01f1), S(0x01f2), S(0x01f4), S(0x01f6), S(0x01f7),\n            R(0x01f8,0x021e), S(0x0220), R(0x0222,0x0232), S(0x023a), S(0x023b), S(0x023d), S(0x023e), S(0x0241),\n            S(0x0243), S(0x0244), S(0x0245), R(0x0246,0x024e), S(0x0345), S(0x0370), S(0x0372), S(0x0376), S(0x037f),\n            S(0x0386), R(0x0388,0x038a), S(0x038c), S(0x038e), S(0x038f), R(0x0391,0x03a1), R(0x03a3,0x03ab),\n            S(0x03c2), S(0x03cf), S(0x03d0), S(0x03d1), S(0x03d5), S(0x03d6), R(0x03d8,0x03ee), S(0x03f0), S(0x03f1),\n            S(0x03f4), S(0x03f5), S(0x03f7), S(0x03f9), S(0x03fa), R(0x03fd,0x03ff), R(0x0400,0x040f),\n            R(0x0410,0x042f), R(0x0460,0x0480), R(0x048a,0x04be), S(0x04c0), R(0x04c1,0x04cd), R(0x04d0,0x052e),\n            R(0x0531,0x0556), R(0x10a0,0x10c5), S(0x10c7), S(0x10cd), R(0x13f8,0x13fd), S(0x1c80), S(0x1c81),\n            S(0x1c82), S(0x1c83), S(0x1c84), S(0x1c85), S(0x1c86), S(0x1c87), S(0x1c88), R(0x1c90,0x1cba),\n            R(0x1cbd,0x1cbf), R(0x1e00,0x1e94), S(0x1e9b), R(0x1ea0,0x1efe), R(0x1f08,0x1f0f), R(0x1f18,0x1f1d),\n            R(0x1f28,0x1f2f), R(0x1f38,0x1f3f), R(0x1f48,0x1f4d), S(0x1f59), S(0x1f5b), S(0x1f5d), S(0x1f5f),\n            R(0x1f68,0x1f6f), S(0x1fb8), S(0x1fb9), S(0x1fba), S(0x1fbb), S(0x1fbe), R(0x1fc8,0x1fcb), S(0x1fd8),\n            S(0x1fd9), S(0x1fda), S(0x1fdb), S(0x1fe8), S(0x1fe9), S(0x1fea), S(0x1feb), S(0x1fec), S(0x1ff8),\n            S(0x1ff9), S(0x1ffa), S(0x1ffb), S(0x2126), S(0x212a), S(0x212b), S(0x2132), R(0x2160,0x216f), S(0x2183),\n            R(0x24b6,0x24cf), R(0x2c00,0x2c2e), S(0x2c60), S(0x2c62), S(0x2c63), S(0x2c64), R(0x2c67,0x2c6b),\n            S(0x2c6d), S(0x2c6e), S(0x2c6f), S(0x2c70), S(0x2c72), S(0x2c75), S(0x2c7e), S(0x2c7f), R(0x2c80,0x2ce2),\n            S(0x2ceb), S(0x2ced), S(0x2cf2), R(0xa640,0xa66c), R(0xa680,0xa69a), R(0xa722,0xa72e), R(0xa732,0xa76e),\n            S(0xa779), S(0xa77b), S(0xa77d), R(0xa77e,0xa786), S(0xa78b), S(0xa78d), S(0xa790), S(0xa792),\n            R(0xa796,0xa7a8), S(0xa7aa), S(0xa7ab), S(0xa7ac), S(0xa7ad), S(0xa7ae), S(0xa7b0), S(0xa7b1), S(0xa7b2),\n            S(0xa7b3), R(0xa7b4,0xa7be), S(0xa7c2), S(0xa7c4), S(0xa7c5), S(0xa7c6), S(0xa7c7), S(0xa7c9), S(0xa7f5),\n            R(0xab70,0xabbf), R(0xff21,0xff3a), R(0x10400,0x10427), R(0x104b0,0x104d3), R(0x10c80,0x10cb2),\n            R(0x118a0,0x118bf), R(0x16e40,0x16e5f), R(0x1e900,0x1e921)\n        };\n        static const unsigned FOLD_MAP_1_DATA[] = {\n            0x0061, 0x007a, 0x03bc, 0x00e0, 0x00f6, 0x00f8, 0x00fe, 0x0101, 0x012f, 0x0133, 0x0137, 0x013a, 0x0148,\n            0x014b, 0x0177, 0x00ff, 0x017a, 0x017e, 0x0073, 0x0253, 0x0183, 0x0185, 0x0254, 0x0188, 0x0256, 0x0257,\n            0x018c, 0x01dd, 0x0259, 0x025b, 0x0192, 0x0260, 0x0263, 0x0269, 0x0268, 0x0199, 0x026f, 0x0272, 0x0275,\n            0x01a1, 0x01a5, 0x0280, 0x01a8, 0x0283, 0x01ad, 0x0288, 0x01b0, 0x028a, 0x028b, 0x01b4, 0x01b6, 0x0292,\n            0x01b9, 0x01bd, 0x01c6, 0x01c6, 0x01c9, 0x01c9, 0x01cc, 0x01cc, 0x01dc, 0x01df, 0x01ef, 0x01f3, 0x01f3,\n            0x01f5, 0x0195, 0x01bf, 0x01f9, 0x021f, 0x019e, 0x0223, 0x0233, 0x2c65, 0x023c, 0x019a, 0x2c66, 0x0242,\n            0x0180, 0x0289, 0x028c, 0x0247, 0x024f, 0x03b9, 0x0371, 0x0373, 0x0377, 0x03f3, 0x03ac, 0x03ad, 0x03af,\n            0x03cc, 0x03cd, 0x03ce, 0x03b1, 0x03c1, 0x03c3, 0x03cb, 0x03c3, 0x03d7, 0x03b2, 0x03b8, 0x03c6, 0x03c0,\n            0x03d9, 0x03ef, 0x03ba, 0x03c1, 0x03b8, 0x03b5, 0x03f8, 0x03f2, 0x03fb, 0x037b, 0x037d, 0x0450, 0x045f,\n            0x0430, 0x044f, 0x0461, 0x0481, 0x048b, 0x04bf, 0x04cf, 0x04c2, 0x04ce, 0x04d1, 0x052f, 0x0561, 0x0586,\n            0x2d00, 0x2d25, 0x2d27, 0x2d2d, 0x13f0, 0x13f5, 0x0432, 0x0434, 0x043e, 0x0441, 0x0442, 0x0442, 0x044a,\n            0x0463, 0xa64b, 0x10d0, 0x10fa, 0x10fd, 0x10ff, 0x1e01, 0x1e95, 0x1e61, 0x1ea1, 0x1eff, 0x1f00, 0x1f07,\n            0x1f10, 0x1f15, 0x1f20, 0x1f27, 0x1f30, 0x1f37, 0x1f40, 0x1f45, 0x1f51, 0x1f53, 0x1f55, 0x1f57, 0x1f60,\n            0x1f67, 0x1fb0, 0x1fb1, 0x1f70, 0x1f71, 0x03b9, 0x1f72, 0x1f75, 0x1fd0, 0x1fd1, 0x1f76, 0x1f77, 0x1fe0,\n            0x1fe1, 0x1f7a, 0x1f7b, 0x1fe5, 0x1f78, 0x1f79, 0x1f7c, 0x1f7d, 0x03c9, 0x006b, 0x00e5, 0x214e, 0x2170,\n            0x217f, 0x2184, 0x24d0, 0x24e9, 0x2c30, 0x2c5e, 0x2c61, 0x026b, 0x1d7d, 0x027d, 0x2c68, 0x2c6c, 0x0251,\n            0x0271, 0x0250, 0x0252, 0x2c73, 0x2c76, 0x023f, 0x0240, 0x2c81, 0x2ce3, 0x2cec, 0x2cee, 0x2cf3, 0xa641,\n            0xa66d, 0xa681, 0xa69b, 0xa723, 0xa72f, 0xa733, 0xa76f, 0xa77a, 0xa77c, 0x1d79, 0xa77f, 0xa787, 0xa78c,\n            0x0265, 0xa791, 0xa793, 0xa797, 0xa7a9, 0x0266, 0x025c, 0x0261, 0x026c, 0x026a, 0x029e, 0x0287, 0x029d,\n            0xab53, 0xa7b5, 0xa7bf, 0xa7c3, 0xa794, 0x0282, 0x1d8e, 0xa7c8, 0xa7ca, 0xa7f6, 0x13a0, 0x13ef, 0xff41,\n            0xff5a, 0x10428, 0x1044f, 0x104d8, 0x104fb, 0x10cc0, 0x10cf2, 0x118c0, 0x118df, 0x16e60, 0x16e7f, 0x1e922,\n            0x1e943\n        };\n        static const unsigned FOLD_MAP_2[] = {\n            S(0x00df), S(0x0130), S(0x0149), S(0x01f0), S(0x0587), S(0x1e96), S(0x1e97), S(0x1e98), S(0x1e99),\n            S(0x1e9a), S(0x1e9e), S(0x1f50), R(0x1f80,0x1f87), R(0x1f88,0x1f8f), R(0x1f90,0x1f97), R(0x1f98,0x1f9f),\n            R(0x1fa0,0x1fa7), R(0x1fa8,0x1faf), S(0x1fb2), S(0x1fb3), S(0x1fb4), S(0x1fb6), S(0x1fbc), S(0x1fc2),\n            S(0x1fc3), S(0x1fc4), S(0x1fc6), S(0x1fcc), S(0x1fd6), S(0x1fe4), S(0x1fe6), S(0x1ff2), S(0x1ff3),\n            S(0x1ff4), S(0x1ff6), S(0x1ffc), S(0xfb00), S(0xfb01), S(0xfb02), S(0xfb05), S(0xfb06), S(0xfb13),\n            S(0xfb14), S(0xfb15), S(0xfb16), S(0xfb17)\n        };\n        static const unsigned FOLD_MAP_2_DATA[] = {\n            0x0073,0x0073, 0x0069,0x0307, 0x02bc,0x006e, 0x006a,0x030c, 0x0565,0x0582, 0x0068,0x0331, 0x0074,0x0308,\n            0x0077,0x030a, 0x0079,0x030a, 0x0061,0x02be, 0x0073,0x0073, 0x03c5,0x0313, 0x1f00,0x03b9, 0x1f07,0x03b9,\n            0x1f00,0x03b9, 0x1f07,0x03b9, 0x1f20,0x03b9, 0x1f27,0x03b9, 0x1f20,0x03b9, 0x1f27,0x03b9, 0x1f60,0x03b9,\n            0x1f67,0x03b9, 0x1f60,0x03b9, 0x1f67,0x03b9, 0x1f70,0x03b9, 0x03b1,0x03b9, 0x03ac,0x03b9, 0x03b1,0x0342,\n            0x03b1,0x03b9, 0x1f74,0x03b9, 0x03b7,0x03b9, 0x03ae,0x03b9, 0x03b7,0x0342, 0x03b7,0x03b9, 0x03b9,0x0342,\n            0x03c1,0x0313, 0x03c5,0x0342, 0x1f7c,0x03b9, 0x03c9,0x03b9, 0x03ce,0x03b9, 0x03c9,0x0342, 0x03c9,0x03b9,\n            0x0066,0x0066, 0x0066,0x0069, 0x0066,0x006c, 0x0073,0x0074, 0x0073,0x0074, 0x0574,0x0576, 0x0574,0x0565,\n            0x0574,0x056b, 0x057e,0x0576, 0x0574,0x056d\n        };\n        static const unsigned FOLD_MAP_3[] = {\n            S(0x0390), S(0x03b0), S(0x1f52), S(0x1f54), S(0x1f56), S(0x1fb7), S(0x1fc7), S(0x1fd2), S(0x1fd3),\n            S(0x1fd7), S(0x1fe2), S(0x1fe3), S(0x1fe7), S(0x1ff7), S(0xfb03), S(0xfb04)\n        };\n        static const unsigned FOLD_MAP_3_DATA[] = {\n            0x03b9,0x0308,0x0301, 0x03c5,0x0308,0x0301, 0x03c5,0x0313,0x0300, 0x03c5,0x0313,0x0301,\n            0x03c5,0x0313,0x0342, 0x03b1,0x0342,0x03b9, 0x03b7,0x0342,0x03b9, 0x03b9,0x0308,0x0300,\n            0x03b9,0x0308,0x0301, 0x03b9,0x0308,0x0342, 0x03c5,0x0308,0x0300, 0x03c5,0x0308,0x0301,\n            0x03c5,0x0308,0x0342, 0x03c9,0x0342,0x03b9, 0x0066,0x0066,0x0069, 0x0066,0x0066,0x006c\n        };\n#undef R\n#undef S\n        static const struct {\n            const unsigned* map;\n            const unsigned* data;\n            size_t map_size;\n            unsigned n_codepoints;\n        } FOLD_MAP_LIST[] = {\n            { FOLD_MAP_1, FOLD_MAP_1_DATA, SIZEOF_ARRAY(FOLD_MAP_1), 1 },\n            { FOLD_MAP_2, FOLD_MAP_2_DATA, SIZEOF_ARRAY(FOLD_MAP_2), 2 },\n            { FOLD_MAP_3, FOLD_MAP_3_DATA, SIZEOF_ARRAY(FOLD_MAP_3), 3 }\n        };\n\n        int i;\n\n        /* Fast path for ASCII characters. */\n        if(codepoint <= 0x7f) {\n            info->codepoints[0] = codepoint;\n            if(ISUPPER_(codepoint))\n                info->codepoints[0] += 'a' - 'A';\n            info->n_codepoints = 1;\n            return;\n        }\n\n        /* Try to locate the codepoint in any of the maps. */\n        for(i = 0; i < (int) SIZEOF_ARRAY(FOLD_MAP_LIST); i++) {\n            int index;\n\n            index = md_unicode_bsearch__(codepoint, FOLD_MAP_LIST[i].map, FOLD_MAP_LIST[i].map_size);\n            if(index >= 0) {\n                /* Found the mapping. */\n                unsigned n_codepoints = FOLD_MAP_LIST[i].n_codepoints;\n                const unsigned* map = FOLD_MAP_LIST[i].map;\n                const unsigned* codepoints = FOLD_MAP_LIST[i].data + (index * n_codepoints);\n\n                memcpy(info->codepoints, codepoints, sizeof(unsigned) * n_codepoints);\n                info->n_codepoints = n_codepoints;\n\n                if(FOLD_MAP_LIST[i].map[index] != codepoint) {\n                    /* The found mapping maps whole range of codepoints,\n                     * i.e. we have to offset info->codepoints[0] accordingly. */\n                    if((map[index] & 0x00ffffff)+1 == codepoints[0]) {\n                        /* Alternating type of the range. */\n                        info->codepoints[0] = codepoint + ((codepoint & 0x1) == (map[index] & 0x1) ? 1 : 0);\n                    } else {\n                        /* Range to range kind of mapping. */\n                        info->codepoints[0] += (codepoint - (map[index] & 0x00ffffff));\n                    }\n                }\n\n                return;\n            }\n        }\n\n        /* No mapping found. Map the codepoint to itself. */\n        info->codepoints[0] = codepoint;\n        info->n_codepoints = 1;\n    }\n#endif\n\n\n#if defined MD4C_USE_UTF16\n    #define IS_UTF16_SURROGATE_HI(word)     (((WORD)(word) & 0xfc00) == 0xd800)\n    #define IS_UTF16_SURROGATE_LO(word)     (((WORD)(word) & 0xfc00) == 0xdc00)\n    #define UTF16_DECODE_SURROGATE(hi, lo)  (0x10000 + ((((unsigned)(hi) & 0x3ff) << 10) | (((unsigned)(lo) & 0x3ff) << 0)))\n\n    static unsigned\n    md_decode_utf16le__(const CHAR* str, SZ str_size, SZ* p_size)\n    {\n        if(IS_UTF16_SURROGATE_HI(str[0])) {\n            if(1 < str_size && IS_UTF16_SURROGATE_LO(str[1])) {\n                if(p_size != NULL)\n                    *p_size = 2;\n                return UTF16_DECODE_SURROGATE(str[0], str[1]);\n            }\n        }\n\n        if(p_size != NULL)\n            *p_size = 1;\n        return str[0];\n    }\n\n    static unsigned\n    md_decode_utf16le_before__(MD_CTX* ctx, OFF off)\n    {\n        if(off > 2 && IS_UTF16_SURROGATE_HI(CH(off-2)) && IS_UTF16_SURROGATE_LO(CH(off-1)))\n            return UTF16_DECODE_SURROGATE(CH(off-2), CH(off-1));\n\n        return CH(off);\n    }\n\n    /* No whitespace uses surrogates, so no decoding needed here. */\n    #define ISUNICODEWHITESPACE_(codepoint) md_is_unicode_whitespace__(codepoint)\n    #define ISUNICODEWHITESPACE(off)        md_is_unicode_whitespace__(CH(off))\n    #define ISUNICODEWHITESPACEBEFORE(off)  md_is_unicode_whitespace__(CH((off)-1))\n\n    #define ISUNICODEPUNCT(off)             md_is_unicode_punct__(md_decode_utf16le__(STR(off), ctx->size - (off), NULL))\n    #define ISUNICODEPUNCTBEFORE(off)       md_is_unicode_punct__(md_decode_utf16le_before__(ctx, off))\n\n    static inline int\n    md_decode_unicode(const CHAR* str, OFF off, SZ str_size, SZ* p_char_size)\n    {\n        return md_decode_utf16le__(str+off, str_size-off, p_char_size);\n    }\n#elif defined MD4C_USE_UTF8\n    #define IS_UTF8_LEAD1(byte)     ((unsigned char)(byte) <= 0x7f)\n    #define IS_UTF8_LEAD2(byte)     (((unsigned char)(byte) & 0xe0) == 0xc0)\n    #define IS_UTF8_LEAD3(byte)     (((unsigned char)(byte) & 0xf0) == 0xe0)\n    #define IS_UTF8_LEAD4(byte)     (((unsigned char)(byte) & 0xf8) == 0xf0)\n    #define IS_UTF8_TAIL(byte)      (((unsigned char)(byte) & 0xc0) == 0x80)\n\n    static unsigned\n    md_decode_utf8__(const CHAR* str, SZ str_size, SZ* p_size)\n    {\n        if(!IS_UTF8_LEAD1(str[0])) {\n            if(IS_UTF8_LEAD2(str[0])) {\n                if(1 < str_size && IS_UTF8_TAIL(str[1])) {\n                    if(p_size != NULL)\n                        *p_size = 2;\n\n                    return (((unsigned int)str[0] & 0x1f) << 6) |\n                           (((unsigned int)str[1] & 0x3f) << 0);\n                }\n            } else if(IS_UTF8_LEAD3(str[0])) {\n                if(2 < str_size && IS_UTF8_TAIL(str[1]) && IS_UTF8_TAIL(str[2])) {\n                    if(p_size != NULL)\n                        *p_size = 3;\n\n                    return (((unsigned int)str[0] & 0x0f) << 12) |\n                           (((unsigned int)str[1] & 0x3f) << 6) |\n                           (((unsigned int)str[2] & 0x3f) << 0);\n                }\n            } else if(IS_UTF8_LEAD4(str[0])) {\n                if(3 < str_size && IS_UTF8_TAIL(str[1]) && IS_UTF8_TAIL(str[2]) && IS_UTF8_TAIL(str[3])) {\n                    if(p_size != NULL)\n                        *p_size = 4;\n\n                    return (((unsigned int)str[0] & 0x07) << 18) |\n                           (((unsigned int)str[1] & 0x3f) << 12) |\n                           (((unsigned int)str[2] & 0x3f) << 6) |\n                           (((unsigned int)str[3] & 0x3f) << 0);\n                }\n            }\n        }\n\n        if(p_size != NULL)\n            *p_size = 1;\n        return (unsigned) str[0];\n    }\n\n    static unsigned\n    md_decode_utf8_before__(MD_CTX* ctx, OFF off)\n    {\n        if(!IS_UTF8_LEAD1(CH(off-1))) {\n            if(off > 1 && IS_UTF8_LEAD2(CH(off-2)) && IS_UTF8_TAIL(CH(off-1)))\n                return (((unsigned int)CH(off-2) & 0x1f) << 6) |\n                       (((unsigned int)CH(off-1) & 0x3f) << 0);\n\n            if(off > 2 && IS_UTF8_LEAD3(CH(off-3)) && IS_UTF8_TAIL(CH(off-2)) && IS_UTF8_TAIL(CH(off-1)))\n                return (((unsigned int)CH(off-3) & 0x0f) << 12) |\n                       (((unsigned int)CH(off-2) & 0x3f) << 6) |\n                       (((unsigned int)CH(off-1) & 0x3f) << 0);\n\n            if(off > 3 && IS_UTF8_LEAD4(CH(off-4)) && IS_UTF8_TAIL(CH(off-3)) && IS_UTF8_TAIL(CH(off-2)) && IS_UTF8_TAIL(CH(off-1)))\n                return (((unsigned int)CH(off-4) & 0x07) << 18) |\n                       (((unsigned int)CH(off-3) & 0x3f) << 12) |\n                       (((unsigned int)CH(off-2) & 0x3f) << 6) |\n                       (((unsigned int)CH(off-1) & 0x3f) << 0);\n        }\n\n        return (unsigned) CH(off-1);\n    }\n\n    #define ISUNICODEWHITESPACE_(codepoint) md_is_unicode_whitespace__(codepoint)\n    #define ISUNICODEWHITESPACE(off)        md_is_unicode_whitespace__(md_decode_utf8__(STR(off), ctx->size - (off), NULL))\n    #define ISUNICODEWHITESPACEBEFORE(off)  md_is_unicode_whitespace__(md_decode_utf8_before__(ctx, off))\n\n    #define ISUNICODEPUNCT(off)             md_is_unicode_punct__(md_decode_utf8__(STR(off), ctx->size - (off), NULL))\n    #define ISUNICODEPUNCTBEFORE(off)       md_is_unicode_punct__(md_decode_utf8_before__(ctx, off))\n\n    static inline unsigned\n    md_decode_unicode(const CHAR* str, OFF off, SZ str_size, SZ* p_char_size)\n    {\n        return md_decode_utf8__(str+off, str_size-off, p_char_size);\n    }\n#else\n    #define ISUNICODEWHITESPACE_(codepoint) ISWHITESPACE_(codepoint)\n    #define ISUNICODEWHITESPACE(off)        ISWHITESPACE(off)\n    #define ISUNICODEWHITESPACEBEFORE(off)  ISWHITESPACE((off)-1)\n\n    #define ISUNICODEPUNCT(off)             ISPUNCT(off)\n    #define ISUNICODEPUNCTBEFORE(off)       ISPUNCT((off)-1)\n\n    static inline void\n    md_get_unicode_fold_info(unsigned codepoint, MD_UNICODE_FOLD_INFO* info)\n    {\n        info->codepoints[0] = codepoint;\n        if(ISUPPER_(codepoint))\n            info->codepoints[0] += 'a' - 'A';\n        info->n_codepoints = 1;\n    }\n\n    static inline unsigned\n    md_decode_unicode(const CHAR* str, OFF off, SZ str_size, SZ* p_size)\n    {\n        *p_size = 1;\n        return (unsigned) str[off];\n    }\n#endif\n\n\n/*************************************\n ***  Helper string manipulations  ***\n *************************************/\n\n/* Fill buffer with copy of the string between 'beg' and 'end' but replace any\n * line breaks with given replacement character.\n *\n * NOTE: Caller is responsible to make sure the buffer is large enough.\n * (Given the output is always shorter then input, (end - beg) is good idea\n * what the caller should allocate.)\n */\nstatic void\nmd_merge_lines(MD_CTX* ctx, OFF beg, OFF end, const MD_LINE* lines, int n_lines,\n               CHAR line_break_replacement_char, CHAR* buffer, SZ* p_size)\n{\n    CHAR* ptr = buffer;\n    int line_index = 0;\n    OFF off = beg;\n\n    MD_UNUSED(n_lines);\n\n    while(1) {\n        const MD_LINE* line = &lines[line_index];\n        OFF line_end = line->end;\n        if(end < line_end)\n            line_end = end;\n\n        while(off < line_end) {\n            *ptr = CH(off);\n            ptr++;\n            off++;\n        }\n\n        if(off >= end) {\n            *p_size = ptr - buffer;\n            return;\n        }\n\n        *ptr = line_break_replacement_char;\n        ptr++;\n\n        line_index++;\n        off = lines[line_index].beg;\n    }\n}\n\n/* Wrapper of md_merge_lines() which allocates new buffer for the output string.\n */\nstatic int\nmd_merge_lines_alloc(MD_CTX* ctx, OFF beg, OFF end, const MD_LINE* lines, int n_lines,\n                    CHAR line_break_replacement_char, CHAR** p_str, SZ* p_size)\n{\n    CHAR* buffer;\n\n    buffer = (CHAR*) malloc(sizeof(CHAR) * (end - beg));\n    if(buffer == NULL) {\n        MD_LOG(\"malloc() failed.\");\n        return -1;\n    }\n\n    md_merge_lines(ctx, beg, end, lines, n_lines,\n                line_break_replacement_char, buffer, p_size);\n\n    *p_str = buffer;\n    return 0;\n}\n\nstatic OFF\nmd_skip_unicode_whitespace(const CHAR* label, OFF off, SZ size)\n{\n    SZ char_size;\n    unsigned codepoint;\n\n    while(off < size) {\n        codepoint = md_decode_unicode(label, off, size, &char_size);\n        if(!ISUNICODEWHITESPACE_(codepoint)  &&  !ISNEWLINE_(label[off]))\n            break;\n        off += char_size;\n    }\n\n    return off;\n}\n\n\n/******************************\n ***  Recognizing raw HTML  ***\n ******************************/\n\n/* md_is_html_tag() may be called when processing inlines (inline raw HTML)\n * or when breaking document to blocks (checking for start of HTML block type 7).\n *\n * When breaking document to blocks, we do not yet know line boundaries, but\n * in that case the whole tag has to live on a single line. We distinguish this\n * by n_lines == 0.\n */\nstatic int\nmd_is_html_tag(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)\n{\n    int attr_state;\n    OFF off = beg;\n    OFF line_end = (n_lines > 0) ? lines[0].end : ctx->size;\n    int i = 0;\n\n    MD_ASSERT(CH(beg) == _T('<'));\n\n    if(off + 1 >= line_end)\n        return FALSE;\n    off++;\n\n    /* For parsing attributes, we need a little state automaton below.\n     * State -1: no attributes are allowed.\n     * State 0: attribute could follow after some whitespace.\n     * State 1: after a whitespace (attribute name may follow).\n     * State 2: after attribute name ('=' MAY follow).\n     * State 3: after '=' (value specification MUST follow).\n     * State 41: in middle of unquoted attribute value.\n     * State 42: in middle of single-quoted attribute value.\n     * State 43: in middle of double-quoted attribute value.\n     */\n    attr_state = 0;\n\n    if(CH(off) == _T('/')) {\n        /* Closer tag \"</ ... >\". No attributes may be present. */\n        attr_state = -1;\n        off++;\n    }\n\n    /* Tag name */\n    if(off >= line_end  ||  !ISALPHA(off))\n        return FALSE;\n    off++;\n    while(off < line_end  &&  (ISALNUM(off)  ||  CH(off) == _T('-')))\n        off++;\n\n    /* (Optional) attributes (if not closer), (optional) '/' (if not closer)\n     * and final '>'. */\n    while(1) {\n        while(off < line_end  &&  !ISNEWLINE(off)) {\n            if(attr_state > 40) {\n                if(attr_state == 41 && (ISBLANK(off) || ISANYOF(off, _T(\"\\\"'=<>`\")))) {\n                    attr_state = 0;\n                    off--;  /* Put the char back for re-inspection in the new state. */\n                } else if(attr_state == 42 && CH(off) == _T('\\'')) {\n                    attr_state = 0;\n                } else if(attr_state == 43 && CH(off) == _T('\"')) {\n                    attr_state = 0;\n                }\n                off++;\n            } else if(ISWHITESPACE(off)) {\n                if(attr_state == 0)\n                    attr_state = 1;\n                off++;\n            } else if(attr_state <= 2 && CH(off) == _T('>')) {\n                /* End. */\n                goto done;\n            } else if(attr_state <= 2 && CH(off) == _T('/') && off+1 < line_end && CH(off+1) == _T('>')) {\n                /* End with digraph '/>' */\n                off++;\n                goto done;\n            } else if((attr_state == 1 || attr_state == 2) && (ISALPHA(off) || CH(off) == _T('_') || CH(off) == _T(':'))) {\n                off++;\n                /* Attribute name */\n                while(off < line_end && (ISALNUM(off) || ISANYOF(off, _T(\"_.:-\"))))\n                    off++;\n                attr_state = 2;\n            } else if(attr_state == 2 && CH(off) == _T('=')) {\n                /* Attribute assignment sign */\n                off++;\n                attr_state = 3;\n            } else if(attr_state == 3) {\n                /* Expecting start of attribute value. */\n                if(CH(off) == _T('\"'))\n                    attr_state = 43;\n                else if(CH(off) == _T('\\''))\n                    attr_state = 42;\n                else if(!ISANYOF(off, _T(\"\\\"'=<>`\"))  &&  !ISNEWLINE(off))\n                    attr_state = 41;\n                else\n                    return FALSE;\n                off++;\n            } else {\n                /* Anything unexpected. */\n                return FALSE;\n            }\n        }\n\n        /* We have to be on a single line. See definition of start condition\n         * of HTML block, type 7. */\n        if(n_lines == 0)\n            return FALSE;\n\n        i++;\n        if(i >= n_lines)\n            return FALSE;\n\n        off = lines[i].beg;\n        line_end = lines[i].end;\n\n        if(attr_state == 0  ||  attr_state == 41)\n            attr_state = 1;\n\n        if(off >= max_end)\n            return FALSE;\n    }\n\ndone:\n    if(off >= max_end)\n        return FALSE;\n\n    *p_end = off+1;\n    return TRUE;\n}\n\nstatic int\nmd_scan_for_html_closer(MD_CTX* ctx, const MD_CHAR* str, MD_SIZE len,\n                        const MD_LINE* lines, int n_lines,\n                        OFF beg, OFF max_end, OFF* p_end,\n                        OFF* p_scan_horizon)\n{\n    OFF off = beg;\n    int i = 0;\n\n    if(off < *p_scan_horizon  &&  *p_scan_horizon >= max_end - len) {\n        /* We have already scanned the range up to the max_end so we know\n         * there is nothing to see. */\n        return FALSE;\n    }\n\n    while(TRUE) {\n        while(off + len <= lines[i].end  &&  off + len <= max_end) {\n            if(md_ascii_eq(STR(off), str, len)) {\n                /* Success. */\n                *p_end = off + len;\n                return TRUE;\n            }\n            off++;\n        }\n\n        i++;\n        if(off >= max_end  ||  i >= n_lines) {\n            /* Failure. */\n            *p_scan_horizon = off;\n            return FALSE;\n        }\n\n        off = lines[i].beg;\n    }\n}\n\nstatic int\nmd_is_html_comment(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)\n{\n    OFF off = beg;\n\n    MD_ASSERT(CH(beg) == _T('<'));\n\n    if(off + 4 >= lines[0].end)\n        return FALSE;\n    if(CH(off+1) != _T('!')  ||  CH(off+2) != _T('-')  ||  CH(off+3) != _T('-'))\n        return FALSE;\n    off += 4;\n\n    /* \">\" and \"->\" must not follow the opening. */\n    if(off < lines[0].end  &&  CH(off) == _T('>'))\n        return FALSE;\n    if(off+1 < lines[0].end  &&  CH(off) == _T('-')  &&  CH(off+1) == _T('>'))\n        return FALSE;\n\n    /* HTML comment must not contain \"--\", so we scan just for \"--\" instead\n     * of \"-->\" and verify manually that '>' follows. */\n    if(md_scan_for_html_closer(ctx, _T(\"--\"), 2,\n                lines, n_lines, off, max_end, p_end, &ctx->html_comment_horizon))\n    {\n        if(*p_end < max_end  &&  CH(*p_end) == _T('>')) {\n            *p_end = *p_end + 1;\n            return TRUE;\n        }\n    }\n\n    return FALSE;\n}\n\nstatic int\nmd_is_html_processing_instruction(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)\n{\n    OFF off = beg;\n\n    if(off + 2 >= lines[0].end)\n        return FALSE;\n    if(CH(off+1) != _T('?'))\n        return FALSE;\n    off += 2;\n\n    return md_scan_for_html_closer(ctx, _T(\"?>\"), 2,\n                lines, n_lines, off, max_end, p_end, &ctx->html_proc_instr_horizon);\n}\n\nstatic int\nmd_is_html_declaration(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)\n{\n    OFF off = beg;\n\n    if(off + 2 >= lines[0].end)\n        return FALSE;\n    if(CH(off+1) != _T('!'))\n        return FALSE;\n    off += 2;\n\n    /* Declaration name. */\n    if(off >= lines[0].end  ||  !ISALPHA(off))\n        return FALSE;\n    off++;\n    while(off < lines[0].end  &&  ISALPHA(off))\n        off++;\n    if(off < lines[0].end  &&  !ISWHITESPACE(off))\n        return FALSE;\n\n    return md_scan_for_html_closer(ctx, _T(\">\"), 1,\n                lines, n_lines, off, max_end, p_end, &ctx->html_decl_horizon);\n}\n\nstatic int\nmd_is_html_cdata(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)\n{\n    static const CHAR open_str[] = _T(\"<![CDATA[\");\n    static const SZ open_size = SIZEOF_ARRAY(open_str) - 1;\n\n    OFF off = beg;\n\n    if(off + open_size >= lines[0].end)\n        return FALSE;\n    if(memcmp(STR(off), open_str, open_size) != 0)\n        return FALSE;\n    off += open_size;\n\n    if(lines[n_lines-1].end < max_end)\n        max_end = lines[n_lines-1].end - 2;\n\n    return md_scan_for_html_closer(ctx, _T(\"]]>\"), 3,\n                lines, n_lines, off, max_end, p_end, &ctx->html_cdata_horizon);\n}\n\nstatic int\nmd_is_html_any(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)\n{\n    MD_ASSERT(CH(beg) == _T('<'));\n    return (md_is_html_tag(ctx, lines, n_lines, beg, max_end, p_end)  ||\n            md_is_html_comment(ctx, lines, n_lines, beg, max_end, p_end)  ||\n            md_is_html_processing_instruction(ctx, lines, n_lines, beg, max_end, p_end)  ||\n            md_is_html_declaration(ctx, lines, n_lines, beg, max_end, p_end)  ||\n            md_is_html_cdata(ctx, lines, n_lines, beg, max_end, p_end));\n}\n\n\n/****************************\n ***  Recognizing Entity  ***\n ****************************/\n\nstatic int\nmd_is_hex_entity_contents(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)\n{\n    OFF off = beg;\n    MD_UNUSED(ctx);\n\n    while(off < max_end  &&  ISXDIGIT_(text[off])  &&  off - beg <= 8)\n        off++;\n\n    if(1 <= off - beg  &&  off - beg <= 6) {\n        *p_end = off;\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}\n\nstatic int\nmd_is_dec_entity_contents(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)\n{\n    OFF off = beg;\n    MD_UNUSED(ctx);\n\n    while(off < max_end  &&  ISDIGIT_(text[off])  &&  off - beg <= 8)\n        off++;\n\n    if(1 <= off - beg  &&  off - beg <= 7) {\n        *p_end = off;\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}\n\nstatic int\nmd_is_named_entity_contents(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)\n{\n    OFF off = beg;\n    MD_UNUSED(ctx);\n\n    if(off < max_end  &&  ISALPHA_(text[off]))\n        off++;\n    else\n        return FALSE;\n\n    while(off < max_end  &&  ISALNUM_(text[off])  &&  off - beg <= 48)\n        off++;\n\n    if(2 <= off - beg  &&  off - beg <= 48) {\n        *p_end = off;\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}\n\nstatic int\nmd_is_entity_str(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)\n{\n    int is_contents;\n    OFF off = beg;\n\n    MD_ASSERT(text[off] == _T('&'));\n    off++;\n\n    if(off+2 < max_end  &&  text[off] == _T('#')  &&  (text[off+1] == _T('x') || text[off+1] == _T('X')))\n        is_contents = md_is_hex_entity_contents(ctx, text, off+2, max_end, &off);\n    else if(off+1 < max_end  &&  text[off] == _T('#'))\n        is_contents = md_is_dec_entity_contents(ctx, text, off+1, max_end, &off);\n    else\n        is_contents = md_is_named_entity_contents(ctx, text, off, max_end, &off);\n\n    if(is_contents  &&  off < max_end  &&  text[off] == _T(';')) {\n        *p_end = off+1;\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}\n\nstatic inline int\nmd_is_entity(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end)\n{\n    return md_is_entity_str(ctx, ctx->text, beg, max_end, p_end);\n}\n\n\n/******************************\n ***  Attribute Management  ***\n ******************************/\n\ntypedef struct MD_ATTRIBUTE_BUILD_tag MD_ATTRIBUTE_BUILD;\nstruct MD_ATTRIBUTE_BUILD_tag {\n    CHAR* text;\n    MD_TEXTTYPE* substr_types;\n    OFF* substr_offsets;\n    int substr_count;\n    int substr_alloc;\n    MD_TEXTTYPE trivial_types[1];\n    OFF trivial_offsets[2];\n};\n\n\n#define MD_BUILD_ATTR_NO_ESCAPES    0x0001\n\nstatic int\nmd_build_attr_append_substr(MD_CTX* ctx, MD_ATTRIBUTE_BUILD* build,\n                            MD_TEXTTYPE type, OFF off)\n{\n    if(build->substr_count >= build->substr_alloc) {\n        MD_TEXTTYPE* new_substr_types;\n        OFF* new_substr_offsets;\n\n        build->substr_alloc = (build->substr_alloc > 0\n                ? build->substr_alloc + build->substr_alloc / 2\n                : 8);\n        new_substr_types = (MD_TEXTTYPE*) realloc(build->substr_types,\n                                    build->substr_alloc * sizeof(MD_TEXTTYPE));\n        if(new_substr_types == NULL) {\n            MD_LOG(\"realloc() failed.\");\n            return -1;\n        }\n        /* Note +1 to reserve space for final offset (== raw_size). */\n        new_substr_offsets = (OFF*) realloc(build->substr_offsets,\n                                    (build->substr_alloc+1) * sizeof(OFF));\n        if(new_substr_offsets == NULL) {\n            MD_LOG(\"realloc() failed.\");\n            free(new_substr_types);\n            return -1;\n        }\n\n        build->substr_types = new_substr_types;\n        build->substr_offsets = new_substr_offsets;\n    }\n\n    build->substr_types[build->substr_count] = type;\n    build->substr_offsets[build->substr_count] = off;\n    build->substr_count++;\n    return 0;\n}\n\nstatic void\nmd_free_attribute(MD_CTX* ctx, MD_ATTRIBUTE_BUILD* build)\n{\n    MD_UNUSED(ctx);\n\n    if(build->substr_alloc > 0) {\n        free(build->text);\n        free(build->substr_types);\n        free(build->substr_offsets);\n    }\n}\n\nstatic int\nmd_build_attribute(MD_CTX* ctx, const CHAR* raw_text, SZ raw_size,\n                   unsigned flags, MD_ATTRIBUTE* attr, MD_ATTRIBUTE_BUILD* build)\n{\n    OFF raw_off, off;\n    int is_trivial;\n    int ret = 0;\n\n    memset(build, 0, sizeof(MD_ATTRIBUTE_BUILD));\n\n    /* If there is no backslash and no ampersand, build trivial attribute\n     * without any malloc(). */\n    is_trivial = TRUE;\n    for(raw_off = 0; raw_off < raw_size; raw_off++) {\n        if(ISANYOF3_(raw_text[raw_off], _T('\\\\'), _T('&'), _T('\\0'))) {\n            is_trivial = FALSE;\n            break;\n        }\n    }\n\n    if(is_trivial) {\n        build->text = (CHAR*) (raw_size ? raw_text : NULL);\n        build->substr_types = build->trivial_types;\n        build->substr_offsets = build->trivial_offsets;\n        build->substr_count = 1;\n        build->substr_alloc = 0;\n        build->trivial_types[0] = MD_TEXT_NORMAL;\n        build->trivial_offsets[0] = 0;\n        build->trivial_offsets[1] = raw_size;\n        off = raw_size;\n    } else {\n        build->text = (CHAR*) malloc(raw_size * sizeof(CHAR));\n        if(build->text == NULL) {\n            MD_LOG(\"malloc() failed.\");\n            goto abort;\n        }\n\n        raw_off = 0;\n        off = 0;\n\n        while(raw_off < raw_size) {\n            if(raw_text[raw_off] == _T('\\0')) {\n                MD_CHECK(md_build_attr_append_substr(ctx, build, MD_TEXT_NULLCHAR, off));\n                memcpy(build->text + off, raw_text + raw_off, 1);\n                off++;\n                raw_off++;\n                continue;\n            }\n\n            if(raw_text[raw_off] == _T('&')) {\n                OFF ent_end;\n\n                if(md_is_entity_str(ctx, raw_text, raw_off, raw_size, &ent_end)) {\n                    MD_CHECK(md_build_attr_append_substr(ctx, build, MD_TEXT_ENTITY, off));\n                    memcpy(build->text + off, raw_text + raw_off, ent_end - raw_off);\n                    off += ent_end - raw_off;\n                    raw_off = ent_end;\n                    continue;\n                }\n            }\n\n            if(build->substr_count == 0  ||  build->substr_types[build->substr_count-1] != MD_TEXT_NORMAL)\n                MD_CHECK(md_build_attr_append_substr(ctx, build, MD_TEXT_NORMAL, off));\n\n            if(!(flags & MD_BUILD_ATTR_NO_ESCAPES)  &&\n               raw_text[raw_off] == _T('\\\\')  &&  raw_off+1 < raw_size  &&\n               (ISPUNCT_(raw_text[raw_off+1]) || ISNEWLINE_(raw_text[raw_off+1])))\n                raw_off++;\n\n            build->text[off++] = raw_text[raw_off++];\n        }\n        build->substr_offsets[build->substr_count] = off;\n    }\n\n    attr->text = build->text;\n    attr->size = off;\n    attr->substr_offsets = build->substr_offsets;\n    attr->substr_types = build->substr_types;\n    return 0;\n\nabort:\n    md_free_attribute(ctx, build);\n    return -1;\n}\n\n\n/*********************************************\n ***  Dictionary of Reference Definitions  ***\n *********************************************/\n\n#define MD_FNV1A_BASE       2166136261U\n#define MD_FNV1A_PRIME      16777619U\n\nstatic inline unsigned\nmd_fnv1a(unsigned base, const void* data, size_t n)\n{\n    const unsigned char* buf = (const unsigned char*) data;\n    unsigned hash = base;\n    size_t i;\n\n    for(i = 0; i < n; i++) {\n        hash ^= buf[i];\n        hash *= MD_FNV1A_PRIME;\n    }\n\n    return hash;\n}\n\n\nstruct MD_REF_DEF_tag {\n    CHAR* label;\n    CHAR* title;\n    unsigned hash;\n    SZ label_size;\n    SZ title_size;\n    OFF dest_beg;\n    OFF dest_end;\n    unsigned char label_needs_free : 1;\n    unsigned char title_needs_free : 1;\n};\n\n/* Label equivalence is quite complicated with regards to whitespace and case\n * folding. This complicates computing a hash of it as well as direct comparison\n * of two labels. */\n\nstatic unsigned\nmd_link_label_hash(const CHAR* label, SZ size)\n{\n    unsigned hash = MD_FNV1A_BASE;\n    OFF off;\n    unsigned codepoint;\n    int is_whitespace = FALSE;\n\n    off = md_skip_unicode_whitespace(label, 0, size);\n    while(off < size) {\n        SZ char_size;\n\n        codepoint = md_decode_unicode(label, off, size, &char_size);\n        is_whitespace = ISUNICODEWHITESPACE_(codepoint) || ISNEWLINE_(label[off]);\n\n        if(is_whitespace) {\n            codepoint = ' ';\n            hash = md_fnv1a(hash, &codepoint, sizeof(unsigned));\n            off = md_skip_unicode_whitespace(label, off, size);\n        } else {\n            MD_UNICODE_FOLD_INFO fold_info;\n\n            md_get_unicode_fold_info(codepoint, &fold_info);\n            hash = md_fnv1a(hash, fold_info.codepoints, fold_info.n_codepoints * sizeof(unsigned));\n            off += char_size;\n        }\n    }\n\n    return hash;\n}\n\nstatic OFF\nmd_link_label_cmp_load_fold_info(const CHAR* label, OFF off, SZ size,\n                                 MD_UNICODE_FOLD_INFO* fold_info)\n{\n    unsigned codepoint;\n    SZ char_size;\n\n    if(off >= size) {\n        /* Treat end of a link label as a whitespace. */\n        goto whitespace;\n    }\n\n    codepoint = md_decode_unicode(label, off, size, &char_size);\n    off += char_size;\n    if(ISUNICODEWHITESPACE_(codepoint)) {\n        /* Treat all whitespace as equivalent */\n        goto whitespace;\n    }\n\n    /* Get real folding info. */\n    md_get_unicode_fold_info(codepoint, fold_info);\n    return off;\n\nwhitespace:\n    fold_info->codepoints[0] = _T(' ');\n    fold_info->n_codepoints = 1;\n    return md_skip_unicode_whitespace(label, off, size);\n}\n\nstatic int\nmd_link_label_cmp(const CHAR* a_label, SZ a_size, const CHAR* b_label, SZ b_size)\n{\n    OFF a_off;\n    OFF b_off;\n    MD_UNICODE_FOLD_INFO a_fi = { { 0 }, 0 };\n    MD_UNICODE_FOLD_INFO b_fi = { { 0 }, 0 };\n    OFF a_fi_off = 0;\n    OFF b_fi_off = 0;\n    int cmp;\n\n    a_off = md_skip_unicode_whitespace(a_label, 0, a_size);\n    b_off = md_skip_unicode_whitespace(b_label, 0, b_size);\n    while(a_off < a_size || a_fi_off < a_fi.n_codepoints ||\n          b_off < b_size || b_fi_off < b_fi.n_codepoints)\n    {\n        /* If needed, load fold info for next char. */\n        if(a_fi_off >= a_fi.n_codepoints) {\n            a_fi_off = 0;\n            a_off = md_link_label_cmp_load_fold_info(a_label, a_off, a_size, &a_fi);\n        }\n        if(b_fi_off >= b_fi.n_codepoints) {\n            b_fi_off = 0;\n            b_off = md_link_label_cmp_load_fold_info(b_label, b_off, b_size, &b_fi);\n        }\n\n        cmp = b_fi.codepoints[b_fi_off] - a_fi.codepoints[a_fi_off];\n        if(cmp != 0)\n            return cmp;\n\n        a_fi_off++;\n        b_fi_off++;\n    }\n\n    return 0;\n}\n\ntypedef struct MD_REF_DEF_LIST_tag MD_REF_DEF_LIST;\nstruct MD_REF_DEF_LIST_tag {\n    int n_ref_defs;\n    int alloc_ref_defs;\n    MD_REF_DEF* ref_defs[];  /* Valid items always  point into ctx->ref_defs[] */\n};\n\nstatic int\nmd_ref_def_cmp(const void* a, const void* b)\n{\n    const MD_REF_DEF* a_ref = *(const MD_REF_DEF**)a;\n    const MD_REF_DEF* b_ref = *(const MD_REF_DEF**)b;\n\n    if(a_ref->hash < b_ref->hash)\n        return -1;\n    else if(a_ref->hash > b_ref->hash)\n        return +1;\n    else\n        return md_link_label_cmp(a_ref->label, a_ref->label_size, b_ref->label, b_ref->label_size);\n}\n\nstatic int\nmd_ref_def_cmp_for_sort(const void* a, const void* b)\n{\n    int cmp;\n\n    cmp = md_ref_def_cmp(a, b);\n\n    /* Ensure stability of the sorting. */\n    if(cmp == 0) {\n        const MD_REF_DEF* a_ref = *(const MD_REF_DEF**)a;\n        const MD_REF_DEF* b_ref = *(const MD_REF_DEF**)b;\n\n        if(a_ref < b_ref)\n            cmp = -1;\n        else if(a_ref > b_ref)\n            cmp = +1;\n        else\n            cmp = 0;\n    }\n\n    return cmp;\n}\n\nstatic int\nmd_build_ref_def_hashtable(MD_CTX* ctx)\n{\n    int i, j;\n\n    if(ctx->n_ref_defs == 0)\n        return 0;\n\n    ctx->ref_def_hashtable_size = (ctx->n_ref_defs * 5) / 4;\n    ctx->ref_def_hashtable = malloc(ctx->ref_def_hashtable_size * sizeof(void*));\n    if(ctx->ref_def_hashtable == NULL) {\n        MD_LOG(\"malloc() failed.\");\n        goto abort;\n    }\n    memset(ctx->ref_def_hashtable, 0, ctx->ref_def_hashtable_size * sizeof(void*));\n\n    /* Each member of ctx->ref_def_hashtable[] can be:\n     *  -- NULL,\n     *  -- pointer to the MD_REF_DEF in ctx->ref_defs[], or\n     *  -- pointer to a MD_REF_DEF_LIST, which holds multiple pointers to\n     *     such MD_REF_DEFs.\n     */\n    for(i = 0; i < ctx->n_ref_defs; i++) {\n        MD_REF_DEF* def = &ctx->ref_defs[i];\n        void* bucket;\n        MD_REF_DEF_LIST* list;\n\n        def->hash = md_link_label_hash(def->label, def->label_size);\n        bucket = ctx->ref_def_hashtable[def->hash % ctx->ref_def_hashtable_size];\n\n        if(bucket == NULL) {\n            /* The bucket is empty. Make it just point to the def. */\n            ctx->ref_def_hashtable[def->hash % ctx->ref_def_hashtable_size] = def;\n            continue;\n        }\n\n        if(ctx->ref_defs <= (MD_REF_DEF*) bucket  &&  (MD_REF_DEF*) bucket < ctx->ref_defs + ctx->n_ref_defs) {\n            /* The bucket already contains one ref. def. Lets see whether it\n             * is the same label (ref. def. duplicate) or different one\n             * (hash conflict). */\n            MD_REF_DEF* old_def = (MD_REF_DEF*) bucket;\n\n            if(md_link_label_cmp(def->label, def->label_size, old_def->label, old_def->label_size) == 0) {\n                /* Duplicate label: Ignore this ref. def. */\n                continue;\n            }\n\n            /* Make the bucket complex, i.e. able to hold more ref. defs. */\n            list = (MD_REF_DEF_LIST*) malloc(sizeof(MD_REF_DEF_LIST) + 2 * sizeof(MD_REF_DEF*));\n            if(list == NULL) {\n                MD_LOG(\"malloc() failed.\");\n                goto abort;\n            }\n            list->ref_defs[0] = old_def;\n            list->ref_defs[1] = def;\n            list->n_ref_defs = 2;\n            list->alloc_ref_defs = 2;\n            ctx->ref_def_hashtable[def->hash % ctx->ref_def_hashtable_size] = list;\n            continue;\n        }\n\n        /* Append the def to the complex bucket list.\n         *\n         * Note in this case we ignore potential duplicates to avoid expensive\n         * iterating over the complex bucket. Below, we revisit all the complex\n         * buckets and handle it more cheaply after the complex bucket contents\n         * is sorted. */\n        list = (MD_REF_DEF_LIST*) bucket;\n        if(list->n_ref_defs >= list->alloc_ref_defs) {\n            int alloc_ref_defs = list->alloc_ref_defs + list->alloc_ref_defs / 2;\n            MD_REF_DEF_LIST* list_tmp = (MD_REF_DEF_LIST*) realloc(list,\n                        sizeof(MD_REF_DEF_LIST) + alloc_ref_defs * sizeof(MD_REF_DEF*));\n            if(list_tmp == NULL) {\n                MD_LOG(\"realloc() failed.\");\n                goto abort;\n            }\n            list = list_tmp;\n            list->alloc_ref_defs = alloc_ref_defs;\n            ctx->ref_def_hashtable[def->hash % ctx->ref_def_hashtable_size] = list;\n        }\n\n        list->ref_defs[list->n_ref_defs] = def;\n        list->n_ref_defs++;\n    }\n\n    /* Sort the complex buckets so we can use bsearch() with them. */\n    for(i = 0; i < ctx->ref_def_hashtable_size; i++) {\n        void* bucket = ctx->ref_def_hashtable[i];\n        MD_REF_DEF_LIST* list;\n\n        if(bucket == NULL)\n            continue;\n        if(ctx->ref_defs <= (MD_REF_DEF*) bucket  &&  (MD_REF_DEF*) bucket < ctx->ref_defs + ctx->n_ref_defs)\n            continue;\n\n        list = (MD_REF_DEF_LIST*) bucket;\n        qsort(list->ref_defs, list->n_ref_defs, sizeof(MD_REF_DEF*), md_ref_def_cmp_for_sort);\n\n        /* Disable all duplicates in the complex bucket by forcing all such\n         * records to point to the 1st such ref. def. I.e. no matter which\n         * record is found during the lookup, it will always point to the right\n         * ref. def. in ctx->ref_defs[]. */\n        for(j = 1; j < list->n_ref_defs; j++) {\n            if(md_ref_def_cmp(&list->ref_defs[j-1], &list->ref_defs[j]) == 0)\n                list->ref_defs[j] = list->ref_defs[j-1];\n        }\n    }\n\n    return 0;\n\nabort:\n    return -1;\n}\n\nstatic void\nmd_free_ref_def_hashtable(MD_CTX* ctx)\n{\n    if(ctx->ref_def_hashtable != NULL) {\n        int i;\n\n        for(i = 0; i < ctx->ref_def_hashtable_size; i++) {\n            void* bucket = ctx->ref_def_hashtable[i];\n            if(bucket == NULL)\n                continue;\n            if(ctx->ref_defs <= (MD_REF_DEF*) bucket  &&  (MD_REF_DEF*) bucket < ctx->ref_defs + ctx->n_ref_defs)\n                continue;\n            free(bucket);\n        }\n\n        free(ctx->ref_def_hashtable);\n    }\n}\n\nstatic const MD_REF_DEF*\nmd_lookup_ref_def(MD_CTX* ctx, const CHAR* label, SZ label_size)\n{\n    unsigned hash;\n    void* bucket;\n\n    if(ctx->ref_def_hashtable_size == 0)\n        return NULL;\n\n    hash = md_link_label_hash(label, label_size);\n    bucket = ctx->ref_def_hashtable[hash % ctx->ref_def_hashtable_size];\n\n    if(bucket == NULL) {\n        return NULL;\n    } else if(ctx->ref_defs <= (MD_REF_DEF*) bucket  &&  (MD_REF_DEF*) bucket < ctx->ref_defs + ctx->n_ref_defs) {\n        const MD_REF_DEF* def = (MD_REF_DEF*) bucket;\n\n        if(md_link_label_cmp(def->label, def->label_size, label, label_size) == 0)\n            return def;\n        else\n            return NULL;\n    } else {\n        MD_REF_DEF_LIST* list = (MD_REF_DEF_LIST*) bucket;\n        MD_REF_DEF key_buf;\n        const MD_REF_DEF* key = &key_buf;\n        const MD_REF_DEF** ret;\n\n        key_buf.label = (CHAR*) label;\n        key_buf.label_size = label_size;\n        key_buf.hash = md_link_label_hash(key_buf.label, key_buf.label_size);\n\n        ret = (const MD_REF_DEF**) bsearch(&key, list->ref_defs,\n                    list->n_ref_defs, sizeof(MD_REF_DEF*), md_ref_def_cmp);\n        if(ret != NULL)\n            return *ret;\n        else\n            return NULL;\n    }\n}\n\n\n/***************************\n ***  Recognizing Links  ***\n ***************************/\n\n/* Note this code is partially shared between processing inlines and blocks\n * as reference definitions and links share some helper parser functions.\n */\n\ntypedef struct MD_LINK_ATTR_tag MD_LINK_ATTR;\nstruct MD_LINK_ATTR_tag {\n    OFF dest_beg;\n    OFF dest_end;\n\n    CHAR* title;\n    SZ title_size;\n    int title_needs_free;\n};\n\n\nstatic int\nmd_is_link_label(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg,\n                 OFF* p_end, int* p_beg_line_index, int* p_end_line_index,\n                 OFF* p_contents_beg, OFF* p_contents_end)\n{\n    OFF off = beg;\n    OFF contents_beg = 0;\n    OFF contents_end = 0;\n    int line_index = 0;\n    int len = 0;\n\n    if(CH(off) != _T('['))\n        return FALSE;\n    off++;\n\n    while(1) {\n        OFF line_end = lines[line_index].end;\n\n        while(off < line_end) {\n            if(CH(off) == _T('\\\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) {\n                if(contents_end == 0) {\n                    contents_beg = off;\n                    *p_beg_line_index = line_index;\n                }\n                contents_end = off + 2;\n                off += 2;\n            } else if(CH(off) == _T('[')) {\n                return FALSE;\n            } else if(CH(off) == _T(']')) {\n                if(contents_beg < contents_end) {\n                    /* Success. */\n                    *p_contents_beg = contents_beg;\n                    *p_contents_end = contents_end;\n                    *p_end = off+1;\n                    *p_end_line_index = line_index;\n                    return TRUE;\n                } else {\n                    /* Link label must have some non-whitespace contents. */\n                    return FALSE;\n                }\n            } else {\n                unsigned codepoint;\n                SZ char_size;\n\n                codepoint = md_decode_unicode(ctx->text, off, ctx->size, &char_size);\n                if(!ISUNICODEWHITESPACE_(codepoint)) {\n                    if(contents_end == 0) {\n                        contents_beg = off;\n                        *p_beg_line_index = line_index;\n                    }\n                    contents_end = off + char_size;\n                }\n\n                off += char_size;\n            }\n\n            len++;\n            if(len > 999)\n                return FALSE;\n        }\n\n        line_index++;\n        len++;\n        if(line_index < n_lines)\n            off = lines[line_index].beg;\n        else\n            break;\n    }\n\n    return FALSE;\n}\n\nstatic int\nmd_is_link_destination_A(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end,\n                         OFF* p_contents_beg, OFF* p_contents_end)\n{\n    OFF off = beg;\n\n    if(off >= max_end  ||  CH(off) != _T('<'))\n        return FALSE;\n    off++;\n\n    while(off < max_end) {\n        if(CH(off) == _T('\\\\')  &&  off+1 < max_end  &&  ISPUNCT(off+1)) {\n            off += 2;\n            continue;\n        }\n\n        if(ISNEWLINE(off)  ||  CH(off) == _T('<'))\n            return FALSE;\n\n        if(CH(off) == _T('>')) {\n            /* Success. */\n            *p_contents_beg = beg+1;\n            *p_contents_end = off;\n            *p_end = off+1;\n            return TRUE;\n        }\n\n        off++;\n    }\n\n    return FALSE;\n}\n\nstatic int\nmd_is_link_destination_B(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end,\n                         OFF* p_contents_beg, OFF* p_contents_end)\n{\n    OFF off = beg;\n    int parenthesis_level = 0;\n\n    while(off < max_end) {\n        if(CH(off) == _T('\\\\')  &&  off+1 < max_end  &&  ISPUNCT(off+1)) {\n            off += 2;\n            continue;\n        }\n\n        if(ISWHITESPACE(off) || ISCNTRL(off))\n            break;\n\n        /* Link destination may include balanced pairs of unescaped '(' ')'.\n         * Note we limit the maximal nesting level by 32 to protect us from\n         * https://github.com/jgm/cmark/issues/214 */\n        if(CH(off) == _T('(')) {\n            parenthesis_level++;\n            if(parenthesis_level > 32)\n                return FALSE;\n        } else if(CH(off) == _T(')')) {\n            if(parenthesis_level == 0)\n                break;\n            parenthesis_level--;\n        }\n\n        off++;\n    }\n\n    if(parenthesis_level != 0  ||  off == beg)\n        return FALSE;\n\n    /* Success. */\n    *p_contents_beg = beg;\n    *p_contents_end = off;\n    *p_end = off;\n    return TRUE;\n}\n\nstatic inline int\nmd_is_link_destination(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end,\n                       OFF* p_contents_beg, OFF* p_contents_end)\n{\n    if(CH(beg) == _T('<'))\n        return md_is_link_destination_A(ctx, beg, max_end, p_end, p_contents_beg, p_contents_end);\n    else\n        return md_is_link_destination_B(ctx, beg, max_end, p_end, p_contents_beg, p_contents_end);\n}\n\nstatic int\nmd_is_link_title(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg,\n                 OFF* p_end, int* p_beg_line_index, int* p_end_line_index,\n                 OFF* p_contents_beg, OFF* p_contents_end)\n{\n    OFF off = beg;\n    CHAR closer_char;\n    int line_index = 0;\n\n    /* White space with up to one line break. */\n    while(off < lines[line_index].end  &&  ISWHITESPACE(off))\n        off++;\n    if(off >= lines[line_index].end) {\n        line_index++;\n        if(line_index >= n_lines)\n            return FALSE;\n        off = lines[line_index].beg;\n    }\n    if(off == beg)\n        return FALSE;\n\n    *p_beg_line_index = line_index;\n\n    /* First char determines how to detect end of it. */\n    switch(CH(off)) {\n        case _T('\"'):   closer_char = _T('\"'); break;\n        case _T('\\''):  closer_char = _T('\\''); break;\n        case _T('('):   closer_char = _T(')'); break;\n        default:        return FALSE;\n    }\n    off++;\n\n    *p_contents_beg = off;\n\n    while(line_index < n_lines) {\n        OFF line_end = lines[line_index].end;\n\n        while(off < line_end) {\n            if(CH(off) == _T('\\\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) {\n                off++;\n            } else if(CH(off) == closer_char) {\n                /* Success. */\n                *p_contents_end = off;\n                *p_end = off+1;\n                *p_end_line_index = line_index;\n                return TRUE;\n            } else if(closer_char == _T(')')  &&  CH(off) == _T('(')) {\n                /* ()-style title cannot contain (unescaped '(')) */\n                return FALSE;\n            }\n\n            off++;\n        }\n\n        line_index++;\n    }\n\n    return FALSE;\n}\n\n/* Returns 0 if it is not a reference definition.\n *\n * Returns N > 0 if it is a reference definition. N then corresponds to the\n * number of lines forming it). In this case the definition is stored for\n * resolving any links referring to it.\n *\n * Returns -1 in case of an error (out of memory).\n */\nstatic int\nmd_is_link_reference_definition(MD_CTX* ctx, const MD_LINE* lines, int n_lines)\n{\n    OFF label_contents_beg;\n    OFF label_contents_end;\n    int label_contents_line_index = -1;\n    int label_is_multiline = FALSE;\n    OFF dest_contents_beg;\n    OFF dest_contents_end;\n    OFF title_contents_beg;\n    OFF title_contents_end;\n    int title_contents_line_index;\n    int title_is_multiline = FALSE;\n    OFF off;\n    int line_index = 0;\n    int tmp_line_index;\n    MD_REF_DEF* def = NULL;\n    int ret = 0;\n\n    /* Link label. */\n    if(!md_is_link_label(ctx, lines, n_lines, lines[0].beg,\n                &off, &label_contents_line_index, &line_index,\n                &label_contents_beg, &label_contents_end))\n        return FALSE;\n    label_is_multiline = (label_contents_line_index != line_index);\n\n    /* Colon. */\n    if(off >= lines[line_index].end  ||  CH(off) != _T(':'))\n        return FALSE;\n    off++;\n\n    /* Optional white space with up to one line break. */\n    while(off < lines[line_index].end  &&  ISWHITESPACE(off))\n        off++;\n    if(off >= lines[line_index].end) {\n        line_index++;\n        if(line_index >= n_lines)\n            return FALSE;\n        off = lines[line_index].beg;\n    }\n\n    /* Link destination. */\n    if(!md_is_link_destination(ctx, off, lines[line_index].end,\n                &off, &dest_contents_beg, &dest_contents_end))\n        return FALSE;\n\n    /* (Optional) title. Note we interpret it as an title only if nothing\n     * more follows on its last line. */\n    if(md_is_link_title(ctx, lines + line_index, n_lines - line_index, off,\n                &off, &title_contents_line_index, &tmp_line_index,\n                &title_contents_beg, &title_contents_end)\n        &&  off >= lines[line_index + tmp_line_index].end)\n    {\n        title_is_multiline = (tmp_line_index != title_contents_line_index);\n        title_contents_line_index += line_index;\n        line_index += tmp_line_index;\n    } else {\n        /* Not a title. */\n        title_is_multiline = FALSE;\n        title_contents_beg = off;\n        title_contents_end = off;\n        title_contents_line_index = 0;\n    }\n\n    /* Nothing more can follow on the last line. */\n    if(off < lines[line_index].end)\n        return FALSE;\n\n    /* So, it _is_ a reference definition. Remember it. */\n    if(ctx->n_ref_defs >= ctx->alloc_ref_defs) {\n        MD_REF_DEF* new_defs;\n\n        ctx->alloc_ref_defs = (ctx->alloc_ref_defs > 0\n                ? ctx->alloc_ref_defs + ctx->alloc_ref_defs / 2\n                : 16);\n        new_defs = (MD_REF_DEF*) realloc(ctx->ref_defs, ctx->alloc_ref_defs * sizeof(MD_REF_DEF));\n        if(new_defs == NULL) {\n            MD_LOG(\"realloc() failed.\");\n            goto abort;\n        }\n\n        ctx->ref_defs = new_defs;\n    }\n    def = &ctx->ref_defs[ctx->n_ref_defs];\n    memset(def, 0, sizeof(MD_REF_DEF));\n\n    if(label_is_multiline) {\n        MD_CHECK(md_merge_lines_alloc(ctx, label_contents_beg, label_contents_end,\n                    lines + label_contents_line_index, n_lines - label_contents_line_index,\n                    _T(' '), &def->label, &def->label_size));\n        def->label_needs_free = TRUE;\n    } else {\n        def->label = (CHAR*) STR(label_contents_beg);\n        def->label_size = label_contents_end - label_contents_beg;\n    }\n\n    if(title_is_multiline) {\n        MD_CHECK(md_merge_lines_alloc(ctx, title_contents_beg, title_contents_end,\n                    lines + title_contents_line_index, n_lines - title_contents_line_index,\n                    _T('\\n'), &def->title, &def->title_size));\n        def->title_needs_free = TRUE;\n    } else {\n        def->title = (CHAR*) STR(title_contents_beg);\n        def->title_size = title_contents_end - title_contents_beg;\n    }\n\n    def->dest_beg = dest_contents_beg;\n    def->dest_end = dest_contents_end;\n\n    /* Success. */\n    ctx->n_ref_defs++;\n    return line_index + 1;\n\nabort:\n    /* Failure. */\n    if(def != NULL  &&  def->label_needs_free)\n        free(def->label);\n    if(def != NULL  &&  def->title_needs_free)\n        free(def->title);\n    return ret;\n}\n\nstatic int\nmd_is_link_reference(MD_CTX* ctx, const MD_LINE* lines, int n_lines,\n                     OFF beg, OFF end, MD_LINK_ATTR* attr)\n{\n    const MD_REF_DEF* def;\n    const MD_LINE* beg_line;\n    const MD_LINE* end_line;\n    CHAR* label;\n    SZ label_size;\n    int ret;\n\n    MD_ASSERT(CH(beg) == _T('[') || CH(beg) == _T('!'));\n    MD_ASSERT(CH(end-1) == _T(']'));\n\n    beg += (CH(beg) == _T('!') ? 2 : 1);\n    end--;\n\n    /* Find lines corresponding to the beg and end positions. */\n    MD_ASSERT(lines[0].beg <= beg);\n    beg_line = lines;\n    while(beg >= beg_line->end)\n        beg_line++;\n\n    MD_ASSERT(end <= lines[n_lines-1].end);\n    end_line = beg_line;\n    while(end >= end_line->end)\n        end_line++;\n\n    if(beg_line != end_line) {\n        MD_CHECK(md_merge_lines_alloc(ctx, beg, end, beg_line,\n                 n_lines - (beg_line - lines), _T(' '), &label, &label_size));\n    } else {\n        label = (CHAR*) STR(beg);\n        label_size = end - beg;\n    }\n\n    def = md_lookup_ref_def(ctx, label, label_size);\n    if(def != NULL) {\n        attr->dest_beg = def->dest_beg;\n        attr->dest_end = def->dest_end;\n        attr->title = def->title;\n        attr->title_size = def->title_size;\n        attr->title_needs_free = FALSE;\n    }\n\n    if(beg_line != end_line)\n        free(label);\n\n    ret = (def != NULL);\n\nabort:\n    return ret;\n}\n\nstatic int\nmd_is_inline_link_spec(MD_CTX* ctx, const MD_LINE* lines, int n_lines,\n                       OFF beg, OFF* p_end, MD_LINK_ATTR* attr)\n{\n    int line_index = 0;\n    int tmp_line_index;\n    OFF title_contents_beg;\n    OFF title_contents_end;\n    int title_contents_line_index;\n    int title_is_multiline;\n    OFF off = beg;\n    int ret = FALSE;\n\n    while(off >= lines[line_index].end)\n        line_index++;\n\n    MD_ASSERT(CH(off) == _T('('));\n    off++;\n\n    /* Optional white space with up to one line break. */\n    while(off < lines[line_index].end  &&  ISWHITESPACE(off))\n        off++;\n    if(off >= lines[line_index].end  &&  ISNEWLINE(off)) {\n        line_index++;\n        if(line_index >= n_lines)\n            return FALSE;\n        off = lines[line_index].beg;\n    }\n\n    /* Link destination may be omitted, but only when not also having a title. */\n    if(off < ctx->size  &&  CH(off) == _T(')')) {\n        attr->dest_beg = off;\n        attr->dest_end = off;\n        attr->title = NULL;\n        attr->title_size = 0;\n        attr->title_needs_free = FALSE;\n        off++;\n        *p_end = off;\n        return TRUE;\n    }\n\n    /* Link destination. */\n    if(!md_is_link_destination(ctx, off, lines[line_index].end,\n                        &off, &attr->dest_beg, &attr->dest_end))\n        return FALSE;\n\n    /* (Optional) title. */\n    if(md_is_link_title(ctx, lines + line_index, n_lines - line_index, off,\n                &off, &title_contents_line_index, &tmp_line_index,\n                &title_contents_beg, &title_contents_end))\n    {\n        title_is_multiline = (tmp_line_index != title_contents_line_index);\n        title_contents_line_index += line_index;\n        line_index += tmp_line_index;\n    } else {\n        /* Not a title. */\n        title_is_multiline = FALSE;\n        title_contents_beg = off;\n        title_contents_end = off;\n        title_contents_line_index = 0;\n    }\n\n    /* Optional whitespace followed with final ')'. */\n    while(off < lines[line_index].end  &&  ISWHITESPACE(off))\n        off++;\n    if(off >= lines[line_index].end  &&  ISNEWLINE(off)) {\n        line_index++;\n        if(line_index >= n_lines)\n            return FALSE;\n        off = lines[line_index].beg;\n    }\n    if(CH(off) != _T(')'))\n        goto abort;\n    off++;\n\n    if(title_contents_beg >= title_contents_end) {\n        attr->title = NULL;\n        attr->title_size = 0;\n        attr->title_needs_free = FALSE;\n    } else if(!title_is_multiline) {\n        attr->title = (CHAR*) STR(title_contents_beg);\n        attr->title_size = title_contents_end - title_contents_beg;\n        attr->title_needs_free = FALSE;\n    } else {\n        MD_CHECK(md_merge_lines_alloc(ctx, title_contents_beg, title_contents_end,\n                    lines + title_contents_line_index, n_lines - title_contents_line_index,\n                    _T('\\n'), &attr->title, &attr->title_size));\n        attr->title_needs_free = TRUE;\n    }\n\n    *p_end = off;\n    ret = TRUE;\n\nabort:\n    return ret;\n}\n\nstatic void\nmd_free_ref_defs(MD_CTX* ctx)\n{\n    int i;\n\n    for(i = 0; i < ctx->n_ref_defs; i++) {\n        MD_REF_DEF* def = &ctx->ref_defs[i];\n\n        if(def->label_needs_free)\n            free(def->label);\n        if(def->title_needs_free)\n            free(def->title);\n    }\n\n    free(ctx->ref_defs);\n}\n\n\n/******************************************\n ***  Processing Inlines (a.k.a Spans)  ***\n ******************************************/\n\n/* We process inlines in few phases:\n *\n * (1) We go through the block text and collect all significant characters\n *     which may start/end a span or some other significant position into\n *     ctx->marks[]. Core of this is what md_collect_marks() does.\n *\n *     We also do some very brief preliminary context-less analysis, whether\n *     it might be opener or closer (e.g. of an emphasis span).\n *\n *     This speeds the other steps as we do not need to re-iterate over all\n *     characters anymore.\n *\n * (2) We analyze each potential mark types, in order by their precedence.\n *\n *     In each md_analyze_XXX() function, we re-iterate list of the marks,\n *     skipping already resolved regions (in preceding precedences) and try to\n *     resolve them.\n *\n * (2.1) For trivial marks, which are single (e.g. HTML entity), we just mark\n *       them as resolved.\n *\n * (2.2) For range-type marks, we analyze whether the mark could be closer\n *       and, if yes, whether there is some preceding opener it could satisfy.\n *\n *       If not we check whether it could be really an opener and if yes, we\n *       remember it so subsequent closers may resolve it.\n *\n * (3) Finally, when all marks were analyzed, we render the block contents\n *     by calling MD_RENDERER::text() callback, interrupting by ::enter_span()\n *     or ::close_span() whenever we reach a resolved mark.\n */\n\n\n/* The mark structure.\n *\n * '\\\\': Maybe escape sequence.\n * '\\0': NULL char.\n *  '*': Maybe (strong) emphasis start/end.\n *  '_': Maybe (strong) emphasis start/end.\n *  '~': Maybe strikethrough start/end (needs MD_FLAG_STRIKETHROUGH).\n *  '`': Maybe code span start/end.\n *  '&': Maybe start of entity.\n *  ';': Maybe end of entity.\n *  '<': Maybe start of raw HTML or autolink.\n *  '>': Maybe end of raw HTML or autolink.\n *  '[': Maybe start of link label or link text.\n *  '!': Equivalent of '[' for image.\n *  ']': Maybe end of link label or link text.\n *  '@': Maybe permissive e-mail auto-link (needs MD_FLAG_PERMISSIVEEMAILAUTOLINKS).\n *  ':': Maybe permissive URL auto-link (needs MD_FLAG_PERMISSIVEURLAUTOLINKS).\n *  '.': Maybe permissive WWW auto-link (needs MD_FLAG_PERMISSIVEWWWAUTOLINKS).\n *  'D': Dummy mark, it reserves a space for splitting a previous mark\n *       (e.g. emphasis) or to make more space for storing some special data\n *       related to the preceding mark (e.g. link).\n *\n * Note that not all instances of these chars in the text imply creation of the\n * structure. Only those which have (or may have, after we see more context)\n * the special meaning.\n *\n * (Keep this struct as small as possible to fit as much of them into CPU\n * cache line.)\n */\nstruct MD_MARK_tag {\n    OFF beg;\n    OFF end;\n\n    /* For unresolved openers, 'prev' and 'next' form the chain of open openers\n     * of given type 'ch'.\n     *\n     * During resolving, we disconnect from the chain and point to the\n     * corresponding counterpart so opener points to its closer and vice versa.\n     */\n    int prev;\n    int next;\n    CHAR ch;\n    unsigned char flags;\n};\n\n/* Mark flags (these apply to ALL mark types). */\n#define MD_MARK_POTENTIAL_OPENER            0x01  /* Maybe opener. */\n#define MD_MARK_POTENTIAL_CLOSER            0x02  /* Maybe closer. */\n#define MD_MARK_OPENER                      0x04  /* Definitely opener. */\n#define MD_MARK_CLOSER                      0x08  /* Definitely closer. */\n#define MD_MARK_RESOLVED                    0x10  /* Resolved in any definite way. */\n\n/* Mark flags specific for various mark types (so they can share bits). */\n#define MD_MARK_EMPH_INTRAWORD              0x20  /* Helper for the \"rule of 3\". */\n#define MD_MARK_EMPH_MOD3_0                 0x40\n#define MD_MARK_EMPH_MOD3_1                 0x80\n#define MD_MARK_EMPH_MOD3_2                 (0x40 | 0x80)\n#define MD_MARK_EMPH_MOD3_MASK              (0x40 | 0x80)\n#define MD_MARK_AUTOLINK                    0x20  /* Distinguisher for '<', '>'. */\n#define MD_MARK_VALIDPERMISSIVEAUTOLINK     0x20  /* For permissive autolinks. */\n\nstatic MD_MARKCHAIN*\nmd_asterisk_chain(MD_CTX* ctx, unsigned flags)\n{\n    switch(flags & (MD_MARK_EMPH_INTRAWORD | MD_MARK_EMPH_MOD3_MASK)) {\n        case MD_MARK_EMPH_INTRAWORD | MD_MARK_EMPH_MOD3_0:  return &ASTERISK_OPENERS_intraword_mod3_0;\n        case MD_MARK_EMPH_INTRAWORD | MD_MARK_EMPH_MOD3_1:  return &ASTERISK_OPENERS_intraword_mod3_1;\n        case MD_MARK_EMPH_INTRAWORD | MD_MARK_EMPH_MOD3_2:  return &ASTERISK_OPENERS_intraword_mod3_2;\n        case MD_MARK_EMPH_MOD3_0:                           return &ASTERISK_OPENERS_extraword_mod3_0;\n        case MD_MARK_EMPH_MOD3_1:                           return &ASTERISK_OPENERS_extraword_mod3_1;\n        case MD_MARK_EMPH_MOD3_2:                           return &ASTERISK_OPENERS_extraword_mod3_2;\n        default:                                            MD_UNREACHABLE();\n    }\n    return NULL;\n}\n\nstatic MD_MARKCHAIN*\nmd_mark_chain(MD_CTX* ctx, int mark_index)\n{\n    MD_MARK* mark = &ctx->marks[mark_index];\n\n    switch(mark->ch) {\n        case _T('*'):   return md_asterisk_chain(ctx, mark->flags);\n        case _T('_'):   return &UNDERSCORE_OPENERS;\n        case _T('~'):   return (mark->end - mark->beg == 1) ? &TILDE_OPENERS_1 : &TILDE_OPENERS_2;\n        case _T('['):   return &BRACKET_OPENERS;\n        case _T('|'):   return &TABLECELLBOUNDARIES;\n        default:        return NULL;\n    }\n}\n\nstatic MD_MARK*\nmd_push_mark(MD_CTX* ctx)\n{\n    if(ctx->n_marks >= ctx->alloc_marks) {\n        MD_MARK* new_marks;\n\n        ctx->alloc_marks = (ctx->alloc_marks > 0\n                ? ctx->alloc_marks + ctx->alloc_marks / 2\n                : 64);\n        new_marks = realloc(ctx->marks, ctx->alloc_marks * sizeof(MD_MARK));\n        if(new_marks == NULL) {\n            MD_LOG(\"realloc() failed.\");\n            return NULL;\n        }\n\n        ctx->marks = new_marks;\n    }\n\n    return &ctx->marks[ctx->n_marks++];\n}\n\n#define PUSH_MARK_()                                                    \\\n        do {                                                            \\\n            mark = md_push_mark(ctx);                                   \\\n            if(mark == NULL) {                                          \\\n                ret = -1;                                               \\\n                goto abort;                                             \\\n            }                                                           \\\n        } while(0)\n\n#define PUSH_MARK(ch_, beg_, end_, flags_)                              \\\n        do {                                                            \\\n            PUSH_MARK_();                                               \\\n            mark->beg = (beg_);                                         \\\n            mark->end = (end_);                                         \\\n            mark->prev = -1;                                            \\\n            mark->next = -1;                                            \\\n            mark->ch = (char)(ch_);                                     \\\n            mark->flags = (flags_);                                     \\\n        } while(0)\n\n\nstatic void\nmd_mark_chain_append(MD_CTX* ctx, MD_MARKCHAIN* chain, int mark_index)\n{\n    if(chain->tail >= 0)\n        ctx->marks[chain->tail].next = mark_index;\n    else\n        chain->head = mark_index;\n\n    ctx->marks[mark_index].prev = chain->tail;\n    ctx->marks[mark_index].next = -1;\n    chain->tail = mark_index;\n}\n\n/* Sometimes, we need to store a pointer into the mark. It is quite rare\n * so we do not bother to make MD_MARK use union, and it can only happen\n * for dummy marks. */\nstatic inline void\nmd_mark_store_ptr(MD_CTX* ctx, int mark_index, void* ptr)\n{\n    MD_MARK* mark = &ctx->marks[mark_index];\n    MD_ASSERT(mark->ch == 'D');\n\n    /* Check only members beg and end are misused for this. */\n    MD_ASSERT(sizeof(void*) <= 2 * sizeof(OFF));\n    memcpy(mark, &ptr, sizeof(void*));\n}\n\nstatic inline void*\nmd_mark_get_ptr(MD_CTX* ctx, int mark_index)\n{\n    void* ptr;\n    MD_MARK* mark = &ctx->marks[mark_index];\n    MD_ASSERT(mark->ch == 'D');\n    memcpy(&ptr, mark, sizeof(void*));\n    return ptr;\n}\n\nstatic void\nmd_resolve_range(MD_CTX* ctx, MD_MARKCHAIN* chain, int opener_index, int closer_index)\n{\n    MD_MARK* opener = &ctx->marks[opener_index];\n    MD_MARK* closer = &ctx->marks[closer_index];\n\n    /* Remove opener from the list of openers. */\n    if(chain != NULL) {\n        if(opener->prev >= 0)\n            ctx->marks[opener->prev].next = opener->next;\n        else\n            chain->head = opener->next;\n\n        if(opener->next >= 0)\n            ctx->marks[opener->next].prev = opener->prev;\n        else\n            chain->tail = opener->prev;\n    }\n\n    /* Interconnect opener and closer and mark both as resolved. */\n    opener->next = closer_index;\n    opener->flags |= MD_MARK_OPENER | MD_MARK_RESOLVED;\n    closer->prev = opener_index;\n    closer->flags |= MD_MARK_CLOSER | MD_MARK_RESOLVED;\n}\n\n\n#define MD_ROLLBACK_ALL         0\n#define MD_ROLLBACK_CROSSING    1\n\n/* In the range ctx->marks[opener_index] ... [closer_index], undo some or all\n * resolvings accordingly to these rules:\n *\n * (1) All openers BEFORE the range corresponding to any closer inside the\n *     range are un-resolved and they are re-added to their respective chains\n *     of unresolved openers. This ensures we can reuse the opener for closers\n *     AFTER the range.\n *\n * (2) If 'how' is MD_ROLLBACK_ALL, then ALL resolved marks inside the range\n *     are discarded.\n *\n * (3) If 'how' is MD_ROLLBACK_CROSSING, only closers with openers handled\n *     in (1) are discarded. I.e. pairs of openers and closers which are both\n *     inside the range are retained as well as any unpaired marks.\n */\nstatic void\nmd_rollback(MD_CTX* ctx, int opener_index, int closer_index, int how)\n{\n    int i;\n    int mark_index;\n\n    /* Cut all unresolved openers at the mark index. */\n    for(i = OPENERS_CHAIN_FIRST; i < OPENERS_CHAIN_LAST+1; i++) {\n        MD_MARKCHAIN* chain = &ctx->mark_chains[i];\n\n        while(chain->tail >= opener_index)\n            chain->tail = ctx->marks[chain->tail].prev;\n\n        if(chain->tail >= 0)\n            ctx->marks[chain->tail].next = -1;\n        else\n            chain->head = -1;\n    }\n\n    /* Go backwards so that unresolved openers are re-added into their\n     * respective chains, in the right order. */\n    mark_index = closer_index - 1;\n    while(mark_index > opener_index) {\n        MD_MARK* mark = &ctx->marks[mark_index];\n        int mark_flags = mark->flags;\n        int discard_flag = (how == MD_ROLLBACK_ALL);\n\n        if(mark->flags & MD_MARK_CLOSER) {\n            int mark_opener_index = mark->prev;\n\n            /* Undo opener BEFORE the range. */\n            if(mark_opener_index < opener_index) {\n                MD_MARK* mark_opener = &ctx->marks[mark_opener_index];\n                MD_MARKCHAIN* chain;\n\n                mark_opener->flags &= ~(MD_MARK_OPENER | MD_MARK_CLOSER | MD_MARK_RESOLVED);\n                chain = md_mark_chain(ctx, opener_index);\n                if(chain != NULL) {\n                    md_mark_chain_append(ctx, chain, mark_opener_index);\n                    discard_flag = 1;\n                }\n            }\n        }\n\n        /* And reset our flags. */\n        if(discard_flag)\n            mark->flags &= ~(MD_MARK_OPENER | MD_MARK_CLOSER | MD_MARK_RESOLVED);\n\n        /* Jump as far as we can over unresolved or non-interesting marks. */\n        switch(how) {\n            case MD_ROLLBACK_CROSSING:\n                if((mark_flags & MD_MARK_CLOSER)  &&  mark->prev > opener_index) {\n                    /* If we are closer with opener INSIDE the range, there may\n                     * not be any other crosser inside the subrange. */\n                    mark_index = mark->prev;\n                    break;\n                }\n                MD_FALLTHROUGH();\n            default:\n                mark_index--;\n                break;\n        }\n    }\n}\n\nstatic void\nmd_build_mark_char_map(MD_CTX* ctx)\n{\n    memset(ctx->mark_char_map, 0, sizeof(ctx->mark_char_map));\n\n    ctx->mark_char_map['\\\\'] = 1;\n    ctx->mark_char_map['*'] = 1;\n    ctx->mark_char_map['_'] = 1;\n    ctx->mark_char_map['`'] = 1;\n    ctx->mark_char_map['&'] = 1;\n    ctx->mark_char_map[';'] = 1;\n    ctx->mark_char_map['<'] = 1;\n    ctx->mark_char_map['>'] = 1;\n    ctx->mark_char_map['['] = 1;\n    ctx->mark_char_map['!'] = 1;\n    ctx->mark_char_map[']'] = 1;\n    ctx->mark_char_map['\\0'] = 1;\n\n    if(ctx->parser.flags & MD_FLAG_STRIKETHROUGH)\n        ctx->mark_char_map['~'] = 1;\n\n    if(ctx->parser.flags & MD_FLAG_LATEXMATHSPANS)\n        ctx->mark_char_map['$'] = 1;\n\n    if(ctx->parser.flags & MD_FLAG_PERMISSIVEEMAILAUTOLINKS)\n        ctx->mark_char_map['@'] = 1;\n\n    if(ctx->parser.flags & MD_FLAG_PERMISSIVEURLAUTOLINKS)\n        ctx->mark_char_map[':'] = 1;\n\n    if(ctx->parser.flags & MD_FLAG_PERMISSIVEWWWAUTOLINKS)\n        ctx->mark_char_map['.'] = 1;\n\n    if((ctx->parser.flags & MD_FLAG_TABLES) || (ctx->parser.flags & MD_FLAG_WIKILINKS))\n        ctx->mark_char_map['|'] = 1;\n\n    if(ctx->parser.flags & MD_FLAG_COLLAPSEWHITESPACE) {\n        int i;\n\n        for(i = 0; i < (int) sizeof(ctx->mark_char_map); i++) {\n            if(ISWHITESPACE_(i))\n                ctx->mark_char_map[i] = 1;\n        }\n    }\n}\n\n/* We limit code span marks to lower than 32 backticks. This solves the\n * pathologic case of too many openers, each of different length: Their\n * resolving would be then O(n^2). */\n#define CODESPAN_MARK_MAXLEN    32\n\nstatic int\nmd_is_code_span(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg,\n                OFF* p_opener_beg, OFF* p_opener_end,\n                OFF* p_closer_beg, OFF* p_closer_end,\n                OFF last_potential_closers[CODESPAN_MARK_MAXLEN],\n                int* p_reached_paragraph_end)\n{\n    OFF opener_beg = beg;\n    OFF opener_end;\n    OFF closer_beg;\n    OFF closer_end;\n    SZ mark_len;\n    OFF line_end;\n    int has_space_after_opener = FALSE;\n    int has_eol_after_opener = FALSE;\n    int has_space_before_closer = FALSE;\n    int has_eol_before_closer = FALSE;\n    int has_only_space = TRUE;\n    int line_index = 0;\n\n    line_end = lines[0].end;\n    opener_end = opener_beg;\n    while(opener_end < line_end  &&  CH(opener_end) == _T('`'))\n        opener_end++;\n    has_space_after_opener = (opener_end < line_end && CH(opener_end) == _T(' '));\n    has_eol_after_opener = (opener_end == line_end);\n\n    /* The caller needs to know end of the opening mark even if we fail. */\n    *p_opener_end = opener_end;\n\n    mark_len = opener_end - opener_beg;\n    if(mark_len > CODESPAN_MARK_MAXLEN)\n        return FALSE;\n\n    /* Check whether we already know there is no closer of this length.\n     * If so, re-scan does no sense. This fixes issue #59. */\n    if(last_potential_closers[mark_len-1] >= lines[n_lines-1].end  ||\n       (*p_reached_paragraph_end  &&  last_potential_closers[mark_len-1] < opener_end))\n        return FALSE;\n\n    closer_beg = opener_end;\n    closer_end = opener_end;\n\n    /* Find closer mark. */\n    while(TRUE) {\n        while(closer_beg < line_end  &&  CH(closer_beg) != _T('`')) {\n            if(CH(closer_beg) != _T(' '))\n                has_only_space = FALSE;\n            closer_beg++;\n        }\n        closer_end = closer_beg;\n        while(closer_end < line_end  &&  CH(closer_end) == _T('`'))\n            closer_end++;\n\n        if(closer_end - closer_beg == mark_len) {\n            /* Success. */\n            has_space_before_closer = (closer_beg > lines[line_index].beg && CH(closer_beg-1) == _T(' '));\n            has_eol_before_closer = (closer_beg == lines[line_index].beg);\n            break;\n        }\n\n        if(closer_end - closer_beg > 0) {\n            /* We have found a back-tick which is not part of the closer. */\n            has_only_space = FALSE;\n\n            /* But if we eventually fail, remember it as a potential closer\n             * of its own length for future attempts. This mitigates needs for\n             * rescans. */\n            if(closer_end - closer_beg < CODESPAN_MARK_MAXLEN) {\n                if(closer_beg > last_potential_closers[closer_end - closer_beg - 1])\n                    last_potential_closers[closer_end - closer_beg - 1] = closer_beg;\n            }\n        }\n\n        if(closer_end >= line_end) {\n            line_index++;\n            if(line_index >= n_lines) {\n                /* Reached end of the paragraph and still nothing. */\n                *p_reached_paragraph_end = TRUE;\n                return FALSE;\n            }\n            /* Try on the next line. */\n            line_end = lines[line_index].end;\n            closer_beg = lines[line_index].beg;\n        } else {\n            closer_beg = closer_end;\n        }\n    }\n\n    /* If there is a space or a new line both after and before the opener\n     * (and if the code span is not made of spaces only), consume one initial\n     * and one trailing space as part of the marks. */\n    if(!has_only_space  &&\n       (has_space_after_opener || has_eol_after_opener)  &&\n       (has_space_before_closer || has_eol_before_closer))\n    {\n        if(has_space_after_opener)\n            opener_end++;\n        else\n            opener_end = lines[1].beg;\n\n        if(has_space_before_closer)\n            closer_beg--;\n        else {\n            closer_beg = lines[line_index-1].end;\n            /* We need to eat the preceding \"\\r\\n\" but not any line trailing\n             * spaces. */\n            while(closer_beg < ctx->size  &&  ISBLANK(closer_beg))\n                closer_beg++;\n        }\n    }\n\n    *p_opener_beg = opener_beg;\n    *p_opener_end = opener_end;\n    *p_closer_beg = closer_beg;\n    *p_closer_end = closer_end;\n    return TRUE;\n}\n\nstatic int\nmd_is_autolink_uri(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end)\n{\n    OFF off = beg+1;\n\n    MD_ASSERT(CH(beg) == _T('<'));\n\n    /* Check for scheme. */\n    if(off >= max_end  ||  !ISASCII(off))\n        return FALSE;\n    off++;\n    while(1) {\n        if(off >= max_end)\n            return FALSE;\n        if(off - beg > 32)\n            return FALSE;\n        if(CH(off) == _T(':')  &&  off - beg >= 3)\n            break;\n        if(!ISALNUM(off) && CH(off) != _T('+') && CH(off) != _T('-') && CH(off) != _T('.'))\n            return FALSE;\n        off++;\n    }\n\n    /* Check the path after the scheme. */\n    while(off < max_end  &&  CH(off) != _T('>')) {\n        if(ISWHITESPACE(off) || ISCNTRL(off) || CH(off) == _T('<'))\n            return FALSE;\n        off++;\n    }\n\n    if(off >= max_end)\n        return FALSE;\n\n    MD_ASSERT(CH(off) == _T('>'));\n    *p_end = off+1;\n    return TRUE;\n}\n\nstatic int\nmd_is_autolink_email(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end)\n{\n    OFF off = beg + 1;\n    int label_len;\n\n    MD_ASSERT(CH(beg) == _T('<'));\n\n    /* The code should correspond to this regexp:\n            /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+\n            @[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\n            (?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/\n     */\n\n    /* Username (before '@'). */\n    while(off < max_end  &&  (ISALNUM(off) || ISANYOF(off, _T(\".!#$%&'*+/=?^_`{|}~-\"))))\n        off++;\n    if(off <= beg+1)\n        return FALSE;\n\n    /* '@' */\n    if(off >= max_end  ||  CH(off) != _T('@'))\n        return FALSE;\n    off++;\n\n    /* Labels delimited with '.'; each label is sequence of 1 - 63 alnum\n     * characters or '-', but '-' is not allowed as first or last char. */\n    label_len = 0;\n    while(off < max_end) {\n        if(ISALNUM(off))\n            label_len++;\n        else if(CH(off) == _T('-')  &&  label_len > 0)\n            label_len++;\n        else if(CH(off) == _T('.')  &&  label_len > 0  &&  CH(off-1) != _T('-'))\n            label_len = 0;\n        else\n            break;\n\n        if(label_len > 63)\n            return FALSE;\n\n        off++;\n    }\n\n    if(label_len <= 0  || off >= max_end  ||  CH(off) != _T('>') ||  CH(off-1) == _T('-'))\n        return FALSE;\n\n    *p_end = off+1;\n    return TRUE;\n}\n\nstatic int\nmd_is_autolink(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end, int* p_missing_mailto)\n{\n    if(md_is_autolink_uri(ctx, beg, max_end, p_end)) {\n        *p_missing_mailto = FALSE;\n        return TRUE;\n    }\n\n    if(md_is_autolink_email(ctx, beg, max_end, p_end)) {\n        *p_missing_mailto = TRUE;\n        return TRUE;\n    }\n\n    return FALSE;\n}\n\nstatic int\nmd_collect_marks(MD_CTX* ctx, const MD_LINE* lines, int n_lines, int table_mode)\n{\n    int i;\n    int ret = 0;\n    MD_MARK* mark;\n    OFF codespan_last_potential_closers[CODESPAN_MARK_MAXLEN] = { 0 };\n    int codespan_scanned_till_paragraph_end = FALSE;\n\n    for(i = 0; i < n_lines; i++) {\n        const MD_LINE* line = &lines[i];\n        OFF off = line->beg;\n        OFF line_end = line->end;\n\n        while(TRUE) {\n            CHAR ch;\n\n#ifdef MD4C_USE_UTF16\n    /* For UTF-16, mark_char_map[] covers only ASCII. */\n    #define IS_MARK_CHAR(off)   ((CH(off) < SIZEOF_ARRAY(ctx->mark_char_map))  &&  \\\n                                (ctx->mark_char_map[(unsigned char) CH(off)]))\n#else\n    /* For 8-bit encodings, mark_char_map[] covers all 256 elements. */\n    #define IS_MARK_CHAR(off)   (ctx->mark_char_map[(unsigned char) CH(off)])\n#endif\n\n            /* Optimization: Use some loop unrolling. */\n            while(off + 3 < line_end  &&  !IS_MARK_CHAR(off+0)  &&  !IS_MARK_CHAR(off+1)\n                                      &&  !IS_MARK_CHAR(off+2)  &&  !IS_MARK_CHAR(off+3))\n                off += 4;\n            while(off < line_end  &&  !IS_MARK_CHAR(off+0))\n                off++;\n\n            if(off >= line_end)\n                break;\n\n            ch = CH(off);\n\n            /* A backslash escape.\n             * It can go beyond line->end as it may involve escaped new\n             * line to form a hard break. */\n            if(ch == _T('\\\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) {\n                /* Hard-break cannot be on the last line of the block. */\n                if(!ISNEWLINE(off+1)  ||  i+1 < n_lines)\n                    PUSH_MARK(ch, off, off+2, MD_MARK_RESOLVED);\n                off += 2;\n                continue;\n            }\n\n            /* A potential (string) emphasis start/end. */\n            if(ch == _T('*')  ||  ch == _T('_')) {\n                OFF tmp = off+1;\n                int left_level;     /* What precedes: 0 = whitespace; 1 = punctuation; 2 = other char. */\n                int right_level;    /* What follows: 0 = whitespace; 1 = punctuation; 2 = other char. */\n\n                while(tmp < line_end  &&  CH(tmp) == ch)\n                    tmp++;\n\n                if(off == line->beg  ||  ISUNICODEWHITESPACEBEFORE(off))\n                    left_level = 0;\n                else if(ISUNICODEPUNCTBEFORE(off))\n                    left_level = 1;\n                else\n                    left_level = 2;\n\n                if(tmp == line_end  ||  ISUNICODEWHITESPACE(tmp))\n                    right_level = 0;\n                else if(ISUNICODEPUNCT(tmp))\n                    right_level = 1;\n                else\n                    right_level = 2;\n\n                /* Intra-word underscore doesn't have special meaning. */\n                if(ch == _T('_')  &&  left_level == 2  &&  right_level == 2) {\n                    left_level = 0;\n                    right_level = 0;\n                }\n\n                if(left_level != 0  ||  right_level != 0) {\n                    unsigned flags = 0;\n\n                    if(left_level > 0  &&  left_level >= right_level)\n                        flags |= MD_MARK_POTENTIAL_CLOSER;\n                    if(right_level > 0  &&  right_level >= left_level)\n                        flags |= MD_MARK_POTENTIAL_OPENER;\n                    if(left_level == 2  &&  right_level == 2)\n                        flags |= MD_MARK_EMPH_INTRAWORD;\n\n                    /* For \"the rule of three\" we need to remember the original\n                     * size of the mark (modulo three), before we potentially\n                     * split the mark when being later resolved partially by some\n                     * shorter closer. */\n                    switch((tmp - off) % 3) {\n                        case 0: flags |= MD_MARK_EMPH_MOD3_0; break;\n                        case 1: flags |= MD_MARK_EMPH_MOD3_1; break;\n                        case 2: flags |= MD_MARK_EMPH_MOD3_2; break;\n                    }\n\n                    PUSH_MARK(ch, off, tmp, flags);\n\n                    /* During resolving, multiple asterisks may have to be\n                     * split into independent span start/ends. Consider e.g.\n                     * \"**foo* bar*\". Therefore we push also some empty dummy\n                     * marks to have enough space for that. */\n                    off++;\n                    while(off < tmp) {\n                        PUSH_MARK('D', off, off, 0);\n                        off++;\n                    }\n                    continue;\n                }\n\n                off = tmp;\n                continue;\n            }\n\n            /* A potential code span start/end. */\n            if(ch == _T('`')) {\n                OFF opener_beg, opener_end;\n                OFF closer_beg, closer_end;\n                int is_code_span;\n\n                is_code_span = md_is_code_span(ctx, lines + i, n_lines - i, off,\n                                    &opener_beg, &opener_end, &closer_beg, &closer_end,\n                                    codespan_last_potential_closers,\n                                    &codespan_scanned_till_paragraph_end);\n                if(is_code_span) {\n                    PUSH_MARK(_T('`'), opener_beg, opener_end, MD_MARK_OPENER | MD_MARK_RESOLVED);\n                    PUSH_MARK(_T('`'), closer_beg, closer_end, MD_MARK_CLOSER | MD_MARK_RESOLVED);\n                    ctx->marks[ctx->n_marks-2].next = ctx->n_marks-1;\n                    ctx->marks[ctx->n_marks-1].prev = ctx->n_marks-2;\n\n                    off = closer_end;\n\n                    /* Advance the current line accordingly. */\n                    while(off > line_end) {\n                        i++;\n                        line++;\n                        line_end = line->end;\n                    }\n                    continue;\n                }\n\n                off = opener_end;\n                continue;\n            }\n\n            /* A potential entity start. */\n            if(ch == _T('&')) {\n                PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_OPENER);\n                off++;\n                continue;\n            }\n\n            /* A potential entity end. */\n            if(ch == _T(';')) {\n                /* We surely cannot be entity unless the previous mark is '&'. */\n                if(ctx->n_marks > 0  &&  ctx->marks[ctx->n_marks-1].ch == _T('&'))\n                    PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_CLOSER);\n\n                off++;\n                continue;\n            }\n\n            /* A potential autolink or raw HTML start/end. */\n            if(ch == _T('<')) {\n                int is_autolink;\n                OFF autolink_end;\n                int missing_mailto;\n\n                if(!(ctx->parser.flags & MD_FLAG_NOHTMLSPANS)) {\n                    int is_html;\n                    OFF html_end;\n\n                    /* Given the nature of the raw HTML, we have to recognize\n                     * it here. Doing so later in md_analyze_lt_gt() could\n                     * open can of worms of quadratic complexity. */\n                    is_html = md_is_html_any(ctx, lines + i, n_lines - i, off,\n                                    lines[n_lines-1].end, &html_end);\n                    if(is_html) {\n                        PUSH_MARK(_T('<'), off, off, MD_MARK_OPENER | MD_MARK_RESOLVED);\n                        PUSH_MARK(_T('>'), html_end, html_end, MD_MARK_CLOSER | MD_MARK_RESOLVED);\n                        ctx->marks[ctx->n_marks-2].next = ctx->n_marks-1;\n                        ctx->marks[ctx->n_marks-1].prev = ctx->n_marks-2;\n                        off = html_end;\n\n                        /* Advance the current line accordingly. */\n                        while(off > line_end) {\n                            i++;\n                            line++;\n                            line_end = line->end;\n                        }\n                        continue;\n                    }\n                }\n\n                is_autolink = md_is_autolink(ctx, off, lines[n_lines-1].end,\n                                    &autolink_end, &missing_mailto);\n                if(is_autolink) {\n                    PUSH_MARK((missing_mailto ? _T('@') : _T('<')), off, off+1,\n                                MD_MARK_OPENER | MD_MARK_RESOLVED | MD_MARK_AUTOLINK);\n                    PUSH_MARK(_T('>'), autolink_end-1, autolink_end,\n                                MD_MARK_CLOSER | MD_MARK_RESOLVED | MD_MARK_AUTOLINK);\n                    ctx->marks[ctx->n_marks-2].next = ctx->n_marks-1;\n                    ctx->marks[ctx->n_marks-1].prev = ctx->n_marks-2;\n                    off = autolink_end;\n                    continue;\n                }\n\n                off++;\n                continue;\n            }\n\n            /* A potential link or its part. */\n            if(ch == _T('[')  ||  (ch == _T('!') && off+1 < line_end && CH(off+1) == _T('['))) {\n                OFF tmp = (ch == _T('[') ? off+1 : off+2);\n                PUSH_MARK(ch, off, tmp, MD_MARK_POTENTIAL_OPENER);\n                off = tmp;\n                /* Two dummies to make enough place for data we need if it is\n                 * a link. */\n                PUSH_MARK('D', off, off, 0);\n                PUSH_MARK('D', off, off, 0);\n                continue;\n            }\n            if(ch == _T(']')) {\n                PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_CLOSER);\n                off++;\n                continue;\n            }\n\n            /* A potential permissive e-mail autolink. */\n            if(ch == _T('@')) {\n                if(line->beg + 1 <= off  &&  ISALNUM(off-1)  &&\n                    off + 3 < line->end  &&  ISALNUM(off+1))\n                {\n                    PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_OPENER);\n                    /* Push a dummy as a reserve for a closer. */\n                    PUSH_MARK('D', off, off, 0);\n                }\n\n                off++;\n                continue;\n            }\n\n            /* A potential permissive URL autolink. */\n            if(ch == _T(':')) {\n                static struct {\n                    const CHAR* scheme;\n                    SZ scheme_size;\n                    const CHAR* suffix;\n                    SZ suffix_size;\n                } scheme_map[] = {\n                    /* In the order from the most frequently used, arguably. */\n                    { _T(\"http\"), 4,    _T(\"//\"), 2 },\n                    { _T(\"https\"), 5,   _T(\"//\"), 2 },\n                    { _T(\"ftp\"), 3,     _T(\"//\"), 2 }\n                };\n                int scheme_index;\n\n                for(scheme_index = 0; scheme_index < (int) SIZEOF_ARRAY(scheme_map); scheme_index++) {\n                    const CHAR* scheme = scheme_map[scheme_index].scheme;\n                    const SZ scheme_size = scheme_map[scheme_index].scheme_size;\n                    const CHAR* suffix = scheme_map[scheme_index].suffix;\n                    const SZ suffix_size = scheme_map[scheme_index].suffix_size;\n\n                    if(line->beg + scheme_size <= off  &&  md_ascii_eq(STR(off-scheme_size), scheme, scheme_size)  &&\n                        (line->beg + scheme_size == off || ISWHITESPACE(off-scheme_size-1) || ISANYOF(off-scheme_size-1, _T(\"*_~([\")))  &&\n                        off + 1 + suffix_size < line->end  &&  md_ascii_eq(STR(off+1), suffix, suffix_size))\n                    {\n                        PUSH_MARK(ch, off-scheme_size, off+1+suffix_size, MD_MARK_POTENTIAL_OPENER);\n                        /* Push a dummy as a reserve for a closer. */\n                        PUSH_MARK('D', off, off, 0);\n                        off += 1 + suffix_size;\n                        break;\n                    }\n                }\n\n                off++;\n                continue;\n            }\n\n            /* A potential permissive WWW autolink. */\n            if(ch == _T('.')) {\n                if(line->beg + 3 <= off  &&  md_ascii_eq(STR(off-3), _T(\"www\"), 3)  &&\n                    (line->beg + 3 == off || ISWHITESPACE(off-4) || ISANYOF(off-4, _T(\"*_~([\")))  &&\n                    off + 1 < line_end)\n                {\n                    PUSH_MARK(ch, off-3, off+1, MD_MARK_POTENTIAL_OPENER);\n                    /* Push a dummy as a reserve for a closer. */\n                    PUSH_MARK('D', off, off, 0);\n                    off++;\n                    continue;\n                }\n\n                off++;\n                continue;\n            }\n\n            /* A potential table cell boundary or wiki link label delimiter. */\n            if((table_mode || ctx->parser.flags & MD_FLAG_WIKILINKS) && ch == _T('|')) {\n                PUSH_MARK(ch, off, off+1, 0);\n                off++;\n                continue;\n            }\n\n            /* A potential strikethrough start/end. */\n            if(ch == _T('~')) {\n                OFF tmp = off+1;\n\n                while(tmp < line_end  &&  CH(tmp) == _T('~'))\n                    tmp++;\n\n                if(tmp - off < 3) {\n                    unsigned flags = 0;\n\n                    if(tmp < line_end  &&  !ISUNICODEWHITESPACE(tmp))\n                        flags |= MD_MARK_POTENTIAL_OPENER;\n                    if(off > line->beg  &&  !ISUNICODEWHITESPACEBEFORE(off))\n                        flags |= MD_MARK_POTENTIAL_CLOSER;\n                    if(flags != 0)\n                        PUSH_MARK(ch, off, tmp, flags);\n                }\n\n                off = tmp;\n                continue;\n            }\n\n            /* A potential equation start/end */\n            if(ch == _T('$')) {\n                /* We can have at most two consecutive $ signs,\n                 * where two dollar signs signify a display equation. */\n                OFF tmp = off+1;\n\n                while(tmp < line_end && CH(tmp) == _T('$'))\n                    tmp++;\n\n                if (tmp - off <= 2)\n                    PUSH_MARK(ch, off, tmp, MD_MARK_POTENTIAL_OPENER | MD_MARK_POTENTIAL_CLOSER);\n                off = tmp;\n                continue;\n            }\n\n            /* Turn non-trivial whitespace into single space. */\n            if(ISWHITESPACE_(ch)) {\n                OFF tmp = off+1;\n\n                while(tmp < line_end  &&  ISWHITESPACE(tmp))\n                    tmp++;\n\n                if(tmp - off > 1  ||  ch != _T(' '))\n                    PUSH_MARK(ch, off, tmp, MD_MARK_RESOLVED);\n\n                off = tmp;\n                continue;\n            }\n\n            /* NULL character. */\n            if(ch == _T('\\0')) {\n                PUSH_MARK(ch, off, off+1, MD_MARK_RESOLVED);\n                off++;\n                continue;\n            }\n\n            off++;\n        }\n    }\n\n    /* Add a dummy mark at the end of the mark vector to simplify\n     * process_inlines(). */\n    PUSH_MARK(127, ctx->size, ctx->size, MD_MARK_RESOLVED);\n\nabort:\n    return ret;\n}\n\nstatic void\nmd_analyze_bracket(MD_CTX* ctx, int mark_index)\n{\n    /* We cannot really resolve links here as for that we would need\n     * more context. E.g. a following pair of brackets (reference link),\n     * or enclosing pair of brackets (if the inner is the link, the outer\n     * one cannot be.)\n     *\n     * Therefore we here only construct a list of resolved '[' ']' pairs\n     * ordered by position of the closer. This allows ur to analyze what is\n     * or is not link in the right order, from inside to outside in case\n     * of nested brackets.\n     *\n     * The resolving itself is deferred into md_resolve_links().\n     */\n\n    MD_MARK* mark = &ctx->marks[mark_index];\n\n    if(mark->flags & MD_MARK_POTENTIAL_OPENER) {\n        md_mark_chain_append(ctx, &BRACKET_OPENERS, mark_index);\n        return;\n    }\n\n    if(BRACKET_OPENERS.tail >= 0) {\n        /* Pop the opener from the chain. */\n        int opener_index = BRACKET_OPENERS.tail;\n        MD_MARK* opener = &ctx->marks[opener_index];\n        if(opener->prev >= 0)\n            ctx->marks[opener->prev].next = -1;\n        else\n            BRACKET_OPENERS.head = -1;\n        BRACKET_OPENERS.tail = opener->prev;\n\n        /* Interconnect the opener and closer. */\n        opener->next = mark_index;\n        mark->prev = opener_index;\n\n        /* Add the pair into chain of potential links for md_resolve_links().\n         * Note we misuse opener->prev for this as opener->next points to its\n         * closer. */\n        if(ctx->unresolved_link_tail >= 0)\n            ctx->marks[ctx->unresolved_link_tail].prev = opener_index;\n        else\n            ctx->unresolved_link_head = opener_index;\n        ctx->unresolved_link_tail = opener_index;\n        opener->prev = -1;\n    }\n}\n\n/* Forward declaration. */\nstatic void md_analyze_link_contents(MD_CTX* ctx, const MD_LINE* lines, int n_lines,\n                                     int mark_beg, int mark_end);\n\nstatic int\nmd_resolve_links(MD_CTX* ctx, const MD_LINE* lines, int n_lines)\n{\n    int opener_index = ctx->unresolved_link_head;\n    OFF last_link_beg = 0;\n    OFF last_link_end = 0;\n    OFF last_img_beg = 0;\n    OFF last_img_end = 0;\n\n    while(opener_index >= 0) {\n        MD_MARK* opener = &ctx->marks[opener_index];\n        int closer_index = opener->next;\n        MD_MARK* closer = &ctx->marks[closer_index];\n        int next_index = opener->prev;\n        MD_MARK* next_opener;\n        MD_MARK* next_closer;\n        MD_LINK_ATTR attr;\n        int is_link = FALSE;\n\n        if(next_index >= 0) {\n            next_opener = &ctx->marks[next_index];\n            next_closer = &ctx->marks[next_opener->next];\n        } else {\n            next_opener = NULL;\n            next_closer = NULL;\n        }\n\n        /* If nested (\"[ [ ] ]\"), we need to make sure that:\n         *   - The outer does not end inside of (...) belonging to the inner.\n         *   - The outer cannot be link if the inner is link (i.e. not image).\n         *\n         * (Note we here analyze from inner to outer as the marks are ordered\n         * by closer->beg.)\n         */\n        if((opener->beg < last_link_beg  &&  closer->end < last_link_end)  ||\n           (opener->beg < last_img_beg  &&  closer->end < last_img_end)  ||\n           (opener->beg < last_link_end  &&  opener->ch == '['))\n        {\n            opener_index = next_index;\n            continue;\n        }\n\n        /* Recognize and resolve wiki links.\n         * Wiki-links maybe '[[destination]]' or '[[destination|label]]'.\n         */\n        if ((ctx->parser.flags & MD_FLAG_WIKILINKS) &&\n            (opener->end - opener->beg == 1) &&         /* not image */\n            next_opener != NULL &&                      /* double '[' opener */\n            next_opener->ch == '[' &&\n            (next_opener->beg == opener->beg - 1) &&\n            (next_opener->end - next_opener->beg == 1) &&\n            next_closer != NULL &&                      /* double ']' closer */\n            next_closer->ch == ']' &&\n            (next_closer->beg == closer->beg + 1) &&\n            (next_closer->end - next_closer->beg == 1))\n        {\n            MD_MARK* delim = NULL;\n            int delim_index;\n            OFF dest_beg, dest_end;\n\n            is_link = TRUE;\n\n            /* We don't allow destination to be longer than 100 characters.\n             * Lets scan to see whether there is '|'. (If not then the whole\n             * wiki-link has to be below the 100 characters.) */\n            delim_index = opener_index + 1;\n            while(delim_index < closer_index) {\n                MD_MARK* m = &ctx->marks[delim_index];\n                if(m->ch == '|') {\n                    delim = m;\n                    break;\n                }\n                if(m->ch != 'D'  &&  m->beg - opener->end > 100)\n                    break;\n                delim_index++;\n            }\n            dest_beg = opener->end;\n            dest_end = (delim != NULL) ? delim->beg : closer->beg;\n            if(dest_end - dest_beg == 0 || dest_end - dest_beg > 100)\n                is_link = FALSE;\n\n            /* There may not be any new line in the destination. */\n            if(is_link) {\n                OFF off;\n                for(off = dest_beg; off < dest_end; off++) {\n                    if(ISNEWLINE(off)) {\n                        is_link = FALSE;\n                        break;\n                    }\n                }\n            }\n\n            if(is_link) {\n                if(delim != NULL) {\n                    if(delim->end < closer->beg) {\n                        opener->end = delim->beg;\n                    } else {\n                        /* The pipe is just before the closer: [[foo|]] */\n                        closer->beg = delim->beg;\n                        delim = NULL;\n                    }\n                }\n\n                opener->beg = next_opener->beg;\n                opener->next = closer_index;\n                opener->flags |= MD_MARK_OPENER | MD_MARK_RESOLVED;\n\n                closer->end = next_closer->end;\n                closer->prev = opener_index;\n                closer->flags |= MD_MARK_CLOSER | MD_MARK_RESOLVED;\n\n                last_link_beg = opener->beg;\n                last_link_end = closer->end;\n\n                if(delim != NULL) {\n                    delim->flags |= MD_MARK_RESOLVED;\n                    md_rollback(ctx, opener_index, delim_index, MD_ROLLBACK_ALL);\n                    md_analyze_link_contents(ctx, lines, n_lines, opener_index+1, closer_index);\n                } else {\n                    md_rollback(ctx, opener_index, closer_index, MD_ROLLBACK_ALL);\n                }\n\n                opener_index = next_opener->prev;\n                continue;\n            }\n        }\n\n        if(next_opener != NULL  &&  next_opener->beg == closer->end) {\n            if(next_closer->beg > closer->end + 1) {\n                /* Might be full reference link. */\n                is_link = md_is_link_reference(ctx, lines, n_lines, next_opener->beg, next_closer->end, &attr);\n            } else {\n                /* Might be shortcut reference link. */\n                is_link = md_is_link_reference(ctx, lines, n_lines, opener->beg, closer->end, &attr);\n            }\n\n            if(is_link < 0)\n                return -1;\n\n            if(is_link) {\n                /* Eat the 2nd \"[...]\". */\n                closer->end = next_closer->end;\n\n                /* Do not analyze the label as a standalone link in the next\n                 * iteration. */\n                next_index = ctx->marks[next_index].prev;\n            }\n        } else {\n            if(closer->end < ctx->size  &&  CH(closer->end) == _T('(')) {\n                /* Might be inline link. */\n                OFF inline_link_end = UINT_MAX;\n\n                is_link = md_is_inline_link_spec(ctx, lines, n_lines, closer->end, &inline_link_end, &attr);\n                if(is_link < 0)\n                    return -1;\n\n                /* Check the closing ')' is not inside an already resolved range\n                 * (i.e. a range with a higher priority), e.g. a code span. */\n                if(is_link) {\n                    int i = closer_index + 1;\n\n                    while(i < ctx->n_marks) {\n                        MD_MARK* mark = &ctx->marks[i];\n\n                        if(mark->beg >= inline_link_end)\n                            break;\n                        if((mark->flags & (MD_MARK_OPENER | MD_MARK_RESOLVED)) == (MD_MARK_OPENER | MD_MARK_RESOLVED)) {\n                            if(ctx->marks[mark->next].beg >= inline_link_end) {\n                                /* Cancel the link status. */\n                                if(attr.title_needs_free)\n                                    free(attr.title);\n                                is_link = FALSE;\n                                break;\n                            }\n\n                            i = mark->next + 1;\n                        } else {\n                            i++;\n                        }\n                    }\n                }\n\n                if(is_link) {\n                    /* Eat the \"(...)\" */\n                    closer->end = inline_link_end;\n                }\n            }\n\n            if(!is_link) {\n                /* Might be collapsed reference link. */\n                is_link = md_is_link_reference(ctx, lines, n_lines, opener->beg, closer->end, &attr);\n                if(is_link < 0)\n                    return -1;\n            }\n        }\n\n        if(is_link) {\n            /* Resolve the brackets as a link. */\n            opener->flags |= MD_MARK_OPENER | MD_MARK_RESOLVED;\n            closer->flags |= MD_MARK_CLOSER | MD_MARK_RESOLVED;\n\n            /* If it is a link, we store the destination and title in the two\n             * dummy marks after the opener. */\n            MD_ASSERT(ctx->marks[opener_index+1].ch == 'D');\n            ctx->marks[opener_index+1].beg = attr.dest_beg;\n            ctx->marks[opener_index+1].end = attr.dest_end;\n\n            MD_ASSERT(ctx->marks[opener_index+2].ch == 'D');\n            md_mark_store_ptr(ctx, opener_index+2, attr.title);\n            /* The title might or might not have been allocated for us. */\n            if(attr.title_needs_free)\n                md_mark_chain_append(ctx, &PTR_CHAIN, opener_index+2);\n            ctx->marks[opener_index+2].prev = attr.title_size;\n\n            if(opener->ch == '[') {\n                last_link_beg = opener->beg;\n                last_link_end = closer->end;\n            } else {\n                last_img_beg = opener->beg;\n                last_img_end = closer->end;\n            }\n\n            md_analyze_link_contents(ctx, lines, n_lines, opener_index+1, closer_index);\n        }\n\n        opener_index = next_index;\n    }\n\n    return 0;\n}\n\n/* Analyze whether the mark '&' starts a HTML entity.\n * If so, update its flags as well as flags of corresponding closer ';'. */\nstatic void\nmd_analyze_entity(MD_CTX* ctx, int mark_index)\n{\n    MD_MARK* opener = &ctx->marks[mark_index];\n    MD_MARK* closer;\n    OFF off;\n\n    /* Cannot be entity if there is no closer as the next mark.\n     * (Any other mark between would mean strange character which cannot be\n     * part of the entity.\n     *\n     * So we can do all the work on '&' and do not call this later for the\n     * closing mark ';'.\n     */\n    if(mark_index + 1 >= ctx->n_marks)\n        return;\n    closer = &ctx->marks[mark_index+1];\n    if(closer->ch != ';')\n        return;\n\n    if(md_is_entity(ctx, opener->beg, closer->end, &off)) {\n        MD_ASSERT(off == closer->end);\n\n        md_resolve_range(ctx, NULL, mark_index, mark_index+1);\n        opener->end = closer->end;\n    }\n}\n\nstatic void\nmd_analyze_table_cell_boundary(MD_CTX* ctx, int mark_index)\n{\n    MD_MARK* mark = &ctx->marks[mark_index];\n    mark->flags |= MD_MARK_RESOLVED;\n\n    md_mark_chain_append(ctx, &TABLECELLBOUNDARIES, mark_index);\n    ctx->n_table_cell_boundaries++;\n}\n\n/* Split a longer mark into two. The new mark takes the given count of\n * characters. May only be called if an adequate number of dummy 'D' marks\n * follows.\n */\nstatic int\nmd_split_emph_mark(MD_CTX* ctx, int mark_index, SZ n)\n{\n    MD_MARK* mark = &ctx->marks[mark_index];\n    int new_mark_index = mark_index + (mark->end - mark->beg - n);\n    MD_MARK* dummy = &ctx->marks[new_mark_index];\n\n    MD_ASSERT(mark->end - mark->beg > n);\n    MD_ASSERT(dummy->ch == 'D');\n\n    memcpy(dummy, mark, sizeof(MD_MARK));\n    mark->end -= n;\n    dummy->beg = mark->end;\n\n    return new_mark_index;\n}\n\nstatic void\nmd_analyze_emph(MD_CTX* ctx, int mark_index)\n{\n    MD_MARK* mark = &ctx->marks[mark_index];\n    MD_MARKCHAIN* chain = md_mark_chain(ctx, mark_index);\n\n    /* If we can be a closer, try to resolve with the preceding opener. */\n    if(mark->flags & MD_MARK_POTENTIAL_CLOSER) {\n        MD_MARK* opener = NULL;\n        int opener_index = 0;\n\n        if(mark->ch == _T('*')) {\n            MD_MARKCHAIN* opener_chains[6];\n            int i, n_opener_chains;\n            unsigned flags = mark->flags;\n\n            /* Apply the \"rule of three\". */\n            n_opener_chains = 0;\n            opener_chains[n_opener_chains++] = &ASTERISK_OPENERS_intraword_mod3_0;\n            if((flags & MD_MARK_EMPH_MOD3_MASK) != MD_MARK_EMPH_MOD3_2)\n                opener_chains[n_opener_chains++] = &ASTERISK_OPENERS_intraword_mod3_1;\n            if((flags & MD_MARK_EMPH_MOD3_MASK) != MD_MARK_EMPH_MOD3_1)\n                opener_chains[n_opener_chains++] = &ASTERISK_OPENERS_intraword_mod3_2;\n            opener_chains[n_opener_chains++] = &ASTERISK_OPENERS_extraword_mod3_0;\n            if(!(flags & MD_MARK_EMPH_INTRAWORD)  ||  (flags & MD_MARK_EMPH_MOD3_MASK) != MD_MARK_EMPH_MOD3_2)\n                opener_chains[n_opener_chains++] = &ASTERISK_OPENERS_extraword_mod3_1;\n            if(!(flags & MD_MARK_EMPH_INTRAWORD)  ||  (flags & MD_MARK_EMPH_MOD3_MASK) != MD_MARK_EMPH_MOD3_1)\n                opener_chains[n_opener_chains++] = &ASTERISK_OPENERS_extraword_mod3_2;\n\n            /* Opener is the most recent mark from the allowed chains. */\n            for(i = 0; i < n_opener_chains; i++) {\n                if(opener_chains[i]->tail >= 0) {\n                    int tmp_index = opener_chains[i]->tail;\n                    MD_MARK* tmp_mark = &ctx->marks[tmp_index];\n                    if(opener == NULL  ||  tmp_mark->end > opener->end) {\n                        opener_index = tmp_index;\n                        opener = tmp_mark;\n                    }\n                }\n            }\n        } else {\n            /* Simple emph. mark */\n            if(chain->tail >= 0) {\n                opener_index = chain->tail;\n                opener = &ctx->marks[opener_index];\n            }\n        }\n\n        /* Resolve, if we have found matching opener. */\n        if(opener != NULL) {\n            SZ opener_size = opener->end - opener->beg;\n            SZ closer_size = mark->end - mark->beg;\n            MD_MARKCHAIN* opener_chain = md_mark_chain(ctx, opener_index);\n\n            if(opener_size > closer_size) {\n                opener_index = md_split_emph_mark(ctx, opener_index, closer_size);\n                md_mark_chain_append(ctx, opener_chain, opener_index);\n            } else if(opener_size < closer_size) {\n                md_split_emph_mark(ctx, mark_index, closer_size - opener_size);\n            }\n\n            md_rollback(ctx, opener_index, mark_index, MD_ROLLBACK_CROSSING);\n            md_resolve_range(ctx, opener_chain, opener_index, mark_index);\n            return;\n        }\n    }\n\n    /* If we could not resolve as closer, we may be yet be an opener. */\n    if(mark->flags & MD_MARK_POTENTIAL_OPENER)\n        md_mark_chain_append(ctx, chain, mark_index);\n}\n\nstatic void\nmd_analyze_tilde(MD_CTX* ctx, int mark_index)\n{\n    MD_MARK* mark = &ctx->marks[mark_index];\n    MD_MARKCHAIN* chain = md_mark_chain(ctx, mark_index);\n\n    /* We attempt to be Github Flavored Markdown compatible here. GFM accepts\n     * only tildes sequences of length 1 and 2, and the length of the opener\n     * and closer has to match. */\n\n    if((mark->flags & MD_MARK_POTENTIAL_CLOSER)  &&  chain->head >= 0) {\n        int opener_index = chain->head;\n\n        md_rollback(ctx, opener_index, mark_index, MD_ROLLBACK_CROSSING);\n        md_resolve_range(ctx, chain, opener_index, mark_index);\n        return;\n    }\n\n    if(mark->flags & MD_MARK_POTENTIAL_OPENER)\n        md_mark_chain_append(ctx, chain, mark_index);\n}\n\nstatic void\nmd_analyze_dollar(MD_CTX* ctx, int mark_index)\n{\n    /* This should mimic the way inline equations work in LaTeX, so there\n     * can only ever be one item in the chain (i.e. the dollars can't be\n     * nested). This is basically the same as the md_analyze_tilde function,\n     * except that we require matching openers and closers to be of the same\n     * length.\n     *\n     * E.g.: $abc$$def$$ => abc (display equation) def (end equation) */\n    if(DOLLAR_OPENERS.head >= 0) {\n        /* If the potential closer has a non-matching number of $, discard */\n        MD_MARK* open = &ctx->marks[DOLLAR_OPENERS.head];\n        MD_MARK* close = &ctx->marks[mark_index];\n\n        int opener_index = DOLLAR_OPENERS.head;\n        md_rollback(ctx, opener_index, mark_index, MD_ROLLBACK_ALL);\n        if (open->end - open->beg == close->end - close->beg) {\n            /* We are the matching closer */\n            md_resolve_range(ctx, &DOLLAR_OPENERS, opener_index, mark_index);\n        } else {\n            /* We don't match the opener, so discard old opener and insert as opener */\n            md_mark_chain_append(ctx, &DOLLAR_OPENERS, mark_index);\n        }\n    } else {\n        /* No unmatched openers, so we are opener */\n        md_mark_chain_append(ctx, &DOLLAR_OPENERS, mark_index);\n    }\n}\n\nstatic void\nmd_analyze_permissive_url_autolink(MD_CTX* ctx, int mark_index)\n{\n    MD_MARK* opener = &ctx->marks[mark_index];\n    int closer_index = mark_index + 1;\n    MD_MARK* closer = &ctx->marks[closer_index];\n    MD_MARK* next_resolved_mark;\n    OFF off = opener->end;\n    int n_dots = FALSE;\n    int has_underscore_in_last_seg = FALSE;\n    int has_underscore_in_next_to_last_seg = FALSE;\n    int n_opened_parenthesis = 0;\n    int n_excess_parenthesis = 0;\n\n    /* Check for domain. */\n    while(off < ctx->size) {\n        if(ISALNUM(off) || CH(off) == _T('-')) {\n            off++;\n        } else if(CH(off) == _T('.')) {\n            /* We must see at least one period. */\n            n_dots++;\n            has_underscore_in_next_to_last_seg = has_underscore_in_last_seg;\n            has_underscore_in_last_seg = FALSE;\n            off++;\n        } else if(CH(off) == _T('_')) {\n            /* No underscore may be present in the last two domain segments. */\n            has_underscore_in_last_seg = TRUE;\n            off++;\n        } else {\n            break;\n        }\n    }\n    if(off > opener->end  &&  CH(off-1) == _T('.')) {\n        off--;\n        n_dots--;\n    }\n    if(off <= opener->end || n_dots == 0 || has_underscore_in_next_to_last_seg || has_underscore_in_last_seg)\n        return;\n\n    /* Check for path. */\n    next_resolved_mark = closer + 1;\n    while(next_resolved_mark->ch == 'D' || !(next_resolved_mark->flags & MD_MARK_RESOLVED))\n        next_resolved_mark++;\n    while(off < next_resolved_mark->beg  &&  CH(off) != _T('<')  &&  !ISWHITESPACE(off)  &&  !ISNEWLINE(off)) {\n        /* Parenthesis must be balanced. */\n        if(CH(off) == _T('(')) {\n            n_opened_parenthesis++;\n        } else if(CH(off) == _T(')')) {\n            if(n_opened_parenthesis > 0)\n                n_opened_parenthesis--;\n            else\n                n_excess_parenthesis++;\n        }\n\n        off++;\n    }\n\n    /* Trim a trailing punctuation from the end. */\n    while(TRUE) {\n        if(ISANYOF(off-1, _T(\"?!.,:*_~\"))) {\n            off--;\n        } else if(CH(off-1) == ')'  &&  n_excess_parenthesis > 0) {\n            /* Unmatched ')' can be in an interior of the path but not at the\n             * of it, so the auto-link may be safely nested in a parenthesis\n             * pair. */\n            off--;\n            n_excess_parenthesis--;\n        } else {\n            break;\n        }\n    }\n\n    /* Ok. Lets call it an auto-link. Adapt opener and create closer to zero\n     * length so all the contents becomes the link text. */\n    MD_ASSERT(closer->ch == 'D');\n    opener->end = opener->beg;\n    closer->ch = opener->ch;\n    closer->beg = off;\n    closer->end = off;\n    md_resolve_range(ctx, NULL, mark_index, closer_index);\n}\n\n/* The permissive autolinks do not have to be enclosed in '<' '>' but we\n * instead impose stricter rules what is understood as an e-mail address\n * here. Actually any non-alphanumeric characters with exception of '.'\n * are prohibited both in username and after '@'. */\nstatic void\nmd_analyze_permissive_email_autolink(MD_CTX* ctx, int mark_index)\n{\n    MD_MARK* opener = &ctx->marks[mark_index];\n    int closer_index;\n    MD_MARK* closer;\n    OFF beg = opener->beg;\n    OFF end = opener->end;\n    int dot_count = 0;\n\n    MD_ASSERT(CH(beg) == _T('@'));\n\n    /* Scan for name before '@'. */\n    while(beg > 0  &&  (ISALNUM(beg-1) || ISANYOF(beg-1, _T(\".-_+\"))))\n        beg--;\n\n    /* Scan for domain after '@'. */\n    while(end < ctx->size  &&  (ISALNUM(end) || ISANYOF(end, _T(\".-_\")))) {\n        if(CH(end) == _T('.'))\n            dot_count++;\n        end++;\n    }\n    if(CH(end-1) == _T('.')) {  /* Final '.' not part of it. */\n        dot_count--;\n        end--;\n    }\n    else if(ISANYOF2(end-1, _T('-'), _T('_'))) /* These are forbidden at the end. */\n        return;\n    if(CH(end-1) == _T('@')  ||  dot_count == 0)\n        return;\n\n    /* Ok. Lets call it auto-link. Adapt opener and create closer to zero\n     * length so all the contents becomes the link text. */\n    closer_index = mark_index + 1;\n    closer = &ctx->marks[closer_index];\n    MD_ASSERT(closer->ch == 'D');\n\n    opener->beg = beg;\n    opener->end = beg;\n    closer->ch = opener->ch;\n    closer->beg = end;\n    closer->end = end;\n    md_resolve_range(ctx, NULL, mark_index, closer_index);\n}\n\nstatic inline void\nmd_analyze_marks(MD_CTX* ctx, const MD_LINE* lines, int n_lines,\n                 int mark_beg, int mark_end, const CHAR* mark_chars)\n{\n    int i = mark_beg;\n    MD_UNUSED(lines);\n    MD_UNUSED(n_lines);\n\n    while(i < mark_end) {\n        MD_MARK* mark = &ctx->marks[i];\n\n        /* Skip resolved spans. */\n        if(mark->flags & MD_MARK_RESOLVED) {\n            if(mark->flags & MD_MARK_OPENER) {\n                MD_ASSERT(i < mark->next);\n                i = mark->next + 1;\n            } else {\n                i++;\n            }\n            continue;\n        }\n\n        /* Skip marks we do not want to deal with. */\n        if(!ISANYOF_(mark->ch, mark_chars)) {\n            i++;\n            continue;\n        }\n\n        /* Analyze the mark. */\n        switch(mark->ch) {\n            case '[':   /* Pass through. */\n            case '!':   /* Pass through. */\n            case ']':   md_analyze_bracket(ctx, i); break;\n            case '&':   md_analyze_entity(ctx, i); break;\n            case '|':   md_analyze_table_cell_boundary(ctx, i); break;\n            case '_':   /* Pass through. */\n            case '*':   md_analyze_emph(ctx, i); break;\n            case '~':   md_analyze_tilde(ctx, i); break;\n            case '$':   md_analyze_dollar(ctx, i); break;\n            case '.':   /* Pass through. */\n            case ':':   md_analyze_permissive_url_autolink(ctx, i); break;\n            case '@':   md_analyze_permissive_email_autolink(ctx, i); break;\n        }\n\n        i++;\n    }\n}\n\n/* Analyze marks (build ctx->marks). */\nstatic int\nmd_analyze_inlines(MD_CTX* ctx, const MD_LINE* lines, int n_lines, int table_mode)\n{\n    int ret;\n\n    /* Reset the previously collected stack of marks. */\n    ctx->n_marks = 0;\n\n    /* Collect all marks. */\n    MD_CHECK(md_collect_marks(ctx, lines, n_lines, table_mode));\n\n    /* We analyze marks in few groups to handle their precedence. */\n    /* (1) Entities; code spans; autolinks; raw HTML. */\n    md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T(\"&\"));\n\n    /* (2) Links. */\n    md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T(\"[]!\"));\n    MD_CHECK(md_resolve_links(ctx, lines, n_lines));\n    BRACKET_OPENERS.head = -1;\n    BRACKET_OPENERS.tail = -1;\n    ctx->unresolved_link_head = -1;\n    ctx->unresolved_link_tail = -1;\n\n    if(table_mode) {\n        /* (3) Analyze table cell boundaries.\n         * Note we reset TABLECELLBOUNDARIES chain prior to the call md_analyze_marks(),\n         * not after, because caller may need it. */\n        MD_ASSERT(n_lines == 1);\n        TABLECELLBOUNDARIES.head = -1;\n        TABLECELLBOUNDARIES.tail = -1;\n        ctx->n_table_cell_boundaries = 0;\n        md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T(\"|\"));\n        return ret;\n    }\n\n    /* (4) Emphasis and strong emphasis; permissive autolinks. */\n    md_analyze_link_contents(ctx, lines, n_lines, 0, ctx->n_marks);\n\nabort:\n    return ret;\n}\n\nstatic void\nmd_analyze_link_contents(MD_CTX* ctx, const MD_LINE* lines, int n_lines,\n                         int mark_beg, int mark_end)\n{\n    int i;\n\n    md_analyze_marks(ctx, lines, n_lines, mark_beg, mark_end, _T(\"*_~$@:.\"));\n\n    for(i = OPENERS_CHAIN_FIRST; i <= OPENERS_CHAIN_LAST; i++) {\n        ctx->mark_chains[i].head = -1;\n        ctx->mark_chains[i].tail = -1;\n    }\n}\n\nstatic int\nmd_enter_leave_span_a(MD_CTX* ctx, int enter, MD_SPANTYPE type,\n                      const CHAR* dest, SZ dest_size, int prohibit_escapes_in_dest,\n                      const CHAR* title, SZ title_size)\n{\n    MD_ATTRIBUTE_BUILD href_build = { 0 };\n    MD_ATTRIBUTE_BUILD title_build = { 0 };\n    MD_SPAN_A_DETAIL det;\n    int ret = 0;\n\n    /* Note we here rely on fact that MD_SPAN_A_DETAIL and\n     * MD_SPAN_IMG_DETAIL are binary-compatible. */\n    memset(&det, 0, sizeof(MD_SPAN_A_DETAIL));\n    MD_CHECK(md_build_attribute(ctx, dest, dest_size,\n                    (prohibit_escapes_in_dest ? MD_BUILD_ATTR_NO_ESCAPES : 0),\n                    &det.href, &href_build));\n    MD_CHECK(md_build_attribute(ctx, title, title_size, 0, &det.title, &title_build));\n\n    if(enter)\n        MD_ENTER_SPAN(type, &det);\n    else\n        MD_LEAVE_SPAN(type, &det);\n\nabort:\n    md_free_attribute(ctx, &href_build);\n    md_free_attribute(ctx, &title_build);\n    return ret;\n}\n\nstatic int\nmd_enter_leave_span_wikilink(MD_CTX* ctx, int enter, const CHAR* target, SZ target_size)\n{\n    MD_ATTRIBUTE_BUILD target_build = { 0 };\n    MD_SPAN_WIKILINK_DETAIL det;\n    int ret = 0;\n\n    memset(&det, 0, sizeof(MD_SPAN_WIKILINK_DETAIL));\n    MD_CHECK(md_build_attribute(ctx, target, target_size, 0, &det.target, &target_build));\n\n    if (enter)\n        MD_ENTER_SPAN(MD_SPAN_WIKILINK, &det);\n    else\n        MD_LEAVE_SPAN(MD_SPAN_WIKILINK, &det);\n\nabort:\n    md_free_attribute(ctx, &target_build);\n    return ret;\n}\n\n\n/* Render the output, accordingly to the analyzed ctx->marks. */\nstatic int\nmd_process_inlines(MD_CTX* ctx, const MD_LINE* lines, int n_lines)\n{\n    MD_TEXTTYPE text_type;\n    const MD_LINE* line = lines;\n    MD_MARK* prev_mark = NULL;\n    MD_MARK* mark;\n    OFF off = lines[0].beg;\n    OFF end = lines[n_lines-1].end;\n    int enforce_hardbreak = 0;\n    int ret = 0;\n\n    /* Find first resolved mark. Note there is always at least one resolved\n     * mark,  the dummy last one after the end of the latest line we actually\n     * never really reach. This saves us of a lot of special checks and cases\n     * in this function. */\n    mark = ctx->marks;\n    while(!(mark->flags & MD_MARK_RESOLVED))\n        mark++;\n\n    text_type = MD_TEXT_NORMAL;\n\n    while(1) {\n        /* Process the text up to the next mark or end-of-line. */\n        OFF tmp = (line->end < mark->beg ? line->end : mark->beg);\n        if(tmp > off) {\n            MD_TEXT(text_type, STR(off), tmp - off);\n            off = tmp;\n        }\n\n        /* If reached the mark, process it and move to next one. */\n        if(off >= mark->beg) {\n            switch(mark->ch) {\n                case '\\\\':      /* Backslash escape. */\n                    if(ISNEWLINE(mark->beg+1))\n                        enforce_hardbreak = 1;\n                    else\n                        MD_TEXT(text_type, STR(mark->beg+1), 1);\n                    break;\n\n                case ' ':       /* Non-trivial space. */\n                    MD_TEXT(text_type, _T(\" \"), 1);\n                    break;\n\n                case '`':       /* Code span. */\n                    if(mark->flags & MD_MARK_OPENER) {\n                        MD_ENTER_SPAN(MD_SPAN_CODE, NULL);\n                        text_type = MD_TEXT_CODE;\n                    } else {\n                        MD_LEAVE_SPAN(MD_SPAN_CODE, NULL);\n                        text_type = MD_TEXT_NORMAL;\n                    }\n                    break;\n\n                case '_':       /* Underline (or emphasis if we fall through). */\n                    if(ctx->parser.flags & MD_FLAG_UNDERLINE) {\n                        if(mark->flags & MD_MARK_OPENER) {\n                            while(off < mark->end) {\n                                MD_ENTER_SPAN(MD_SPAN_U, NULL);\n                                off++;\n                            }\n                        } else {\n                            while(off < mark->end) {\n                                MD_LEAVE_SPAN(MD_SPAN_U, NULL);\n                                off++;\n                            }\n                        }\n                        break;\n                    }\n                    MD_FALLTHROUGH();\n\n                case '*':       /* Emphasis, strong emphasis. */\n                    if(mark->flags & MD_MARK_OPENER) {\n                        if((mark->end - off) % 2) {\n                            MD_ENTER_SPAN(MD_SPAN_EM, NULL);\n                            off++;\n                        }\n                        while(off + 1 < mark->end) {\n                            MD_ENTER_SPAN(MD_SPAN_STRONG, NULL);\n                            off += 2;\n                        }\n                    } else {\n                        while(off + 1 < mark->end) {\n                            MD_LEAVE_SPAN(MD_SPAN_STRONG, NULL);\n                            off += 2;\n                        }\n                        if((mark->end - off) % 2) {\n                            MD_LEAVE_SPAN(MD_SPAN_EM, NULL);\n                            off++;\n                        }\n                    }\n                    break;\n\n                case '~':\n                    if(mark->flags & MD_MARK_OPENER)\n                        MD_ENTER_SPAN(MD_SPAN_DEL, NULL);\n                    else\n                        MD_LEAVE_SPAN(MD_SPAN_DEL, NULL);\n                    break;\n\n                case '$':\n                    if(mark->flags & MD_MARK_OPENER) {\n                        MD_ENTER_SPAN((mark->end - off) % 2 ? MD_SPAN_LATEXMATH : MD_SPAN_LATEXMATH_DISPLAY, NULL);\n                        text_type = MD_TEXT_LATEXMATH;\n                    } else {\n                        MD_LEAVE_SPAN((mark->end - off) % 2 ? MD_SPAN_LATEXMATH : MD_SPAN_LATEXMATH_DISPLAY, NULL);\n                        text_type = MD_TEXT_NORMAL;\n                    }\n                    break;\n\n                case '[':       /* Link, wiki link, image. */\n                case '!':\n                case ']':\n                {\n                    const MD_MARK* opener = (mark->ch != ']' ? mark : &ctx->marks[mark->prev]);\n                    const MD_MARK* closer = &ctx->marks[opener->next];\n                    const MD_MARK* dest_mark;\n                    const MD_MARK* title_mark;\n\n                    if ((opener->ch == '[' && closer->ch == ']') &&\n                        opener->end - opener->beg >= 2 &&\n                        closer->end - closer->beg >= 2)\n                    {\n                        int has_label = (opener->end - opener->beg > 2);\n                        SZ target_sz;\n\n                        if(has_label)\n                            target_sz = opener->end - (opener->beg+2);\n                        else\n                            target_sz = closer->beg - opener->end;\n\n                        MD_CHECK(md_enter_leave_span_wikilink(ctx, (mark->ch != ']'),\n                                 has_label ? STR(opener->beg+2) : STR(opener->end),\n                                 target_sz));\n\n                        break;\n                    }\n\n                    dest_mark = opener+1;\n                    MD_ASSERT(dest_mark->ch == 'D');\n                    title_mark = opener+2;\n                    MD_ASSERT(title_mark->ch == 'D');\n\n                    MD_CHECK(md_enter_leave_span_a(ctx, (mark->ch != ']'),\n                                (opener->ch == '!' ? MD_SPAN_IMG : MD_SPAN_A),\n                                STR(dest_mark->beg), dest_mark->end - dest_mark->beg, FALSE,\n                                md_mark_get_ptr(ctx, title_mark - ctx->marks), title_mark->prev));\n\n                    /* link/image closer may span multiple lines. */\n                    if(mark->ch == ']') {\n                        while(mark->end > line->end)\n                            line++;\n                    }\n\n                    break;\n                }\n\n                case '<':\n                case '>':       /* Autolink or raw HTML. */\n                    if(!(mark->flags & MD_MARK_AUTOLINK)) {\n                        /* Raw HTML. */\n                        if(mark->flags & MD_MARK_OPENER)\n                            text_type = MD_TEXT_HTML;\n                        else\n                            text_type = MD_TEXT_NORMAL;\n                        break;\n                    }\n                    /* Pass through, if auto-link. */\n                    MD_FALLTHROUGH();\n\n                case '@':       /* Permissive e-mail autolink. */\n                case ':':       /* Permissive URL autolink. */\n                case '.':       /* Permissive WWW autolink. */\n                {\n                    MD_MARK* opener = ((mark->flags & MD_MARK_OPENER) ? mark : &ctx->marks[mark->prev]);\n                    MD_MARK* closer = &ctx->marks[opener->next];\n                    const CHAR* dest = STR(opener->end);\n                    SZ dest_size = closer->beg - opener->end;\n\n                    /* For permissive auto-links we do not know closer mark\n                     * position at the time of md_collect_marks(), therefore\n                     * it can be out-of-order in ctx->marks[].\n                     *\n                     * With this flag, we make sure that we output the closer\n                     * only if we processed the opener. */\n                    if(mark->flags & MD_MARK_OPENER)\n                        closer->flags |= MD_MARK_VALIDPERMISSIVEAUTOLINK;\n\n                    if(opener->ch == '@' || opener->ch == '.') {\n                        dest_size += 7;\n                        MD_TEMP_BUFFER(dest_size * sizeof(CHAR));\n                        memcpy(ctx->buffer,\n                                (opener->ch == '@' ? _T(\"mailto:\") : _T(\"http://\")),\n                                7 * sizeof(CHAR));\n                        memcpy(ctx->buffer + 7, dest, (dest_size-7) * sizeof(CHAR));\n                        dest = ctx->buffer;\n                    }\n\n                    if(closer->flags & MD_MARK_VALIDPERMISSIVEAUTOLINK)\n                        MD_CHECK(md_enter_leave_span_a(ctx, (mark->flags & MD_MARK_OPENER),\n                                    MD_SPAN_A, dest, dest_size, TRUE, NULL, 0));\n                    break;\n                }\n\n                case '&':       /* Entity. */\n                    MD_TEXT(MD_TEXT_ENTITY, STR(mark->beg), mark->end - mark->beg);\n                    break;\n\n                case '\\0':\n                    MD_TEXT(MD_TEXT_NULLCHAR, _T(\"\"), 1);\n                    break;\n\n                case 127:\n                    goto abort;\n            }\n\n            off = mark->end;\n\n            /* Move to next resolved mark. */\n            prev_mark = mark;\n            mark++;\n            while(!(mark->flags & MD_MARK_RESOLVED)  ||  mark->beg < off)\n                mark++;\n        }\n\n        /* If reached end of line, move to next one. */\n        if(off >= line->end) {\n            /* If it is the last line, we are done. */\n            if(off >= end)\n                break;\n\n            if(text_type == MD_TEXT_CODE || text_type == MD_TEXT_LATEXMATH) {\n                OFF tmp;\n\n                MD_ASSERT(prev_mark != NULL);\n                MD_ASSERT(ISANYOF2_(prev_mark->ch, '`', '$')  &&  (prev_mark->flags & MD_MARK_OPENER));\n                MD_ASSERT(ISANYOF2_(mark->ch, '`', '$')  &&  (mark->flags & MD_MARK_CLOSER));\n\n                /* Inside a code span, trailing line whitespace has to be\n                 * outputted. */\n                tmp = off;\n                while(off < ctx->size  &&  ISBLANK(off))\n                    off++;\n                if(off > tmp)\n                    MD_TEXT(text_type, STR(tmp), off-tmp);\n\n                /* and new lines are transformed into single spaces. */\n                if(prev_mark->end < off  &&  off < mark->beg)\n                    MD_TEXT(text_type, _T(\" \"), 1);\n            } else if(text_type == MD_TEXT_HTML) {\n                /* Inside raw HTML, we output the new line verbatim, including\n                 * any trailing spaces. */\n                OFF tmp = off;\n\n                while(tmp < end  &&  ISBLANK(tmp))\n                    tmp++;\n                if(tmp > off)\n                    MD_TEXT(MD_TEXT_HTML, STR(off), tmp - off);\n                MD_TEXT(MD_TEXT_HTML, _T(\"\\n\"), 1);\n            } else {\n                /* Output soft or hard line break. */\n                MD_TEXTTYPE break_type = MD_TEXT_SOFTBR;\n\n                if(text_type == MD_TEXT_NORMAL) {\n                    if(enforce_hardbreak)\n                        break_type = MD_TEXT_BR;\n                    else if((CH(line->end) == _T(' ') && CH(line->end+1) == _T(' ')))\n                        break_type = MD_TEXT_BR;\n                }\n\n                MD_TEXT(break_type, _T(\"\\n\"), 1);\n            }\n\n            /* Move to the next line. */\n            line++;\n            off = line->beg;\n\n            enforce_hardbreak = 0;\n        }\n    }\n\nabort:\n    return ret;\n}\n\n\n/***************************\n ***  Processing Tables  ***\n ***************************/\n\nstatic void\nmd_analyze_table_alignment(MD_CTX* ctx, OFF beg, OFF end, MD_ALIGN* align, int n_align)\n{\n    static const MD_ALIGN align_map[] = { MD_ALIGN_DEFAULT, MD_ALIGN_LEFT, MD_ALIGN_RIGHT, MD_ALIGN_CENTER };\n    OFF off = beg;\n\n    while(n_align > 0) {\n        int index = 0;  /* index into align_map[] */\n\n        while(CH(off) != _T('-'))\n            off++;\n        if(off > beg  &&  CH(off-1) == _T(':'))\n            index |= 1;\n        while(off < end  &&  CH(off) == _T('-'))\n            off++;\n        if(off < end  &&  CH(off) == _T(':'))\n            index |= 2;\n\n        *align = align_map[index];\n        align++;\n        n_align--;\n    }\n\n}\n\n/* Forward declaration. */\nstatic int md_process_normal_block_contents(MD_CTX* ctx, const MD_LINE* lines, int n_lines);\n\nstatic int\nmd_process_table_cell(MD_CTX* ctx, MD_BLOCKTYPE cell_type, MD_ALIGN align, OFF beg, OFF end)\n{\n    MD_LINE line;\n    MD_BLOCK_TD_DETAIL det;\n    int ret = 0;\n\n    while(beg < end  &&  ISWHITESPACE(beg))\n        beg++;\n    while(end > beg  &&  ISWHITESPACE(end-1))\n        end--;\n\n    det.align = align;\n    line.beg = beg;\n    line.end = end;\n\n    MD_ENTER_BLOCK(cell_type, &det);\n    MD_CHECK(md_process_normal_block_contents(ctx, &line, 1));\n    MD_LEAVE_BLOCK(cell_type, &det);\n\nabort:\n    return ret;\n}\n\nstatic int\nmd_process_table_row(MD_CTX* ctx, MD_BLOCKTYPE cell_type, OFF beg, OFF end,\n                     const MD_ALIGN* align, int col_count)\n{\n    MD_LINE line;\n    OFF* pipe_offs = NULL;\n    int i, j, k, n;\n    int ret = 0;\n\n    line.beg = beg;\n    line.end = end;\n\n    /* Break the line into table cells by identifying pipe characters who\n     * form the cell boundary. */\n    MD_CHECK(md_analyze_inlines(ctx, &line, 1, TRUE));\n\n    /* We have to remember the cell boundaries in local buffer because\n     * ctx->marks[] shall be reused during cell contents processing. */\n    n = ctx->n_table_cell_boundaries + 2;\n    pipe_offs = (OFF*) malloc(n * sizeof(OFF));\n    if(pipe_offs == NULL) {\n        MD_LOG(\"malloc() failed.\");\n        ret = -1;\n        goto abort;\n    }\n    j = 0;\n    pipe_offs[j++] = beg;\n    for(i = TABLECELLBOUNDARIES.head; i >= 0; i = ctx->marks[i].next) {\n        MD_MARK* mark = &ctx->marks[i];\n        pipe_offs[j++] = mark->end;\n    }\n    pipe_offs[j++] = end+1;\n\n    /* Process cells. */\n    MD_ENTER_BLOCK(MD_BLOCK_TR, NULL);\n    k = 0;\n    for(i = 0; i < j-1  &&  k < col_count; i++) {\n        if(pipe_offs[i] < pipe_offs[i+1]-1)\n            MD_CHECK(md_process_table_cell(ctx, cell_type, align[k++], pipe_offs[i], pipe_offs[i+1]-1));\n    }\n    /* Make sure we call enough table cells even if the current table contains\n     * too few of them. */\n    while(k < col_count)\n        MD_CHECK(md_process_table_cell(ctx, cell_type, align[k++], 0, 0));\n    MD_LEAVE_BLOCK(MD_BLOCK_TR, NULL);\n\nabort:\n    free(pipe_offs);\n\n    /* Free any temporary memory blocks stored within some dummy marks. */\n    for(i = PTR_CHAIN.head; i >= 0; i = ctx->marks[i].next)\n        free(md_mark_get_ptr(ctx, i));\n    PTR_CHAIN.head = -1;\n    PTR_CHAIN.tail = -1;\n\n    return ret;\n}\n\nstatic int\nmd_process_table_block_contents(MD_CTX* ctx, int col_count, const MD_LINE* lines, int n_lines)\n{\n    MD_ALIGN* align;\n    int i;\n    int ret = 0;\n\n    /* At least two lines have to be present: The column headers and the line\n     * with the underlines. */\n    MD_ASSERT(n_lines >= 2);\n\n    align = malloc(col_count * sizeof(MD_ALIGN));\n    if(align == NULL) {\n        MD_LOG(\"malloc() failed.\");\n        ret = -1;\n        goto abort;\n    }\n\n    md_analyze_table_alignment(ctx, lines[1].beg, lines[1].end, align, col_count);\n\n    MD_ENTER_BLOCK(MD_BLOCK_THEAD, NULL);\n    MD_CHECK(md_process_table_row(ctx, MD_BLOCK_TH,\n                        lines[0].beg, lines[0].end, align, col_count));\n    MD_LEAVE_BLOCK(MD_BLOCK_THEAD, NULL);\n\n    if(n_lines > 2) {\n        MD_ENTER_BLOCK(MD_BLOCK_TBODY, NULL);\n        for(i = 2; i < n_lines; i++) {\n            MD_CHECK(md_process_table_row(ctx, MD_BLOCK_TD,\n                     lines[i].beg, lines[i].end, align, col_count));\n        }\n        MD_LEAVE_BLOCK(MD_BLOCK_TBODY, NULL);\n    }\n\nabort:\n    free(align);\n    return ret;\n}\n\n\n/**************************\n ***  Processing Block  ***\n **************************/\n\n#define MD_BLOCK_CONTAINER_OPENER   0x01\n#define MD_BLOCK_CONTAINER_CLOSER   0x02\n#define MD_BLOCK_CONTAINER          (MD_BLOCK_CONTAINER_OPENER | MD_BLOCK_CONTAINER_CLOSER)\n#define MD_BLOCK_LOOSE_LIST         0x04\n#define MD_BLOCK_SETEXT_HEADER      0x08\n\nstruct MD_BLOCK_tag {\n    MD_BLOCKTYPE type  :  8;\n    unsigned flags     :  8;\n\n    /* MD_BLOCK_H:      Header level (1 - 6)\n     * MD_BLOCK_CODE:   Non-zero if fenced, zero if indented.\n     * MD_BLOCK_LI:     Task mark character (0 if not task list item, 'x', 'X' or ' ').\n     * MD_BLOCK_TABLE:  Column count (as determined by the table underline).\n     */\n    unsigned data      : 16;\n\n    /* Leaf blocks:     Count of lines (MD_LINE or MD_VERBATIMLINE) on the block.\n     * MD_BLOCK_LI:     Task mark offset in the input doc.\n     * MD_BLOCK_OL:     Start item number.\n     */\n    unsigned n_lines;\n};\n\nstruct MD_CONTAINER_tag {\n    CHAR ch;\n    unsigned is_loose    : 8;\n    unsigned is_task     : 8;\n    unsigned start;\n    unsigned mark_indent;\n    unsigned contents_indent;\n    OFF block_byte_off;\n    OFF task_mark_off;\n};\n\n\nstatic int\nmd_process_normal_block_contents(MD_CTX* ctx, const MD_LINE* lines, int n_lines)\n{\n    int i;\n    int ret;\n\n    MD_CHECK(md_analyze_inlines(ctx, lines, n_lines, FALSE));\n    MD_CHECK(md_process_inlines(ctx, lines, n_lines));\n\nabort:\n    /* Free any temporary memory blocks stored within some dummy marks. */\n    for(i = PTR_CHAIN.head; i >= 0; i = ctx->marks[i].next)\n        free(md_mark_get_ptr(ctx, i));\n    PTR_CHAIN.head = -1;\n    PTR_CHAIN.tail = -1;\n\n    return ret;\n}\n\nstatic int\nmd_process_verbatim_block_contents(MD_CTX* ctx, MD_TEXTTYPE text_type, const MD_VERBATIMLINE* lines, int n_lines)\n{\n    static const CHAR indent_chunk_str[] = _T(\"                \");\n    static const SZ indent_chunk_size = SIZEOF_ARRAY(indent_chunk_str) - 1;\n\n    int i;\n    int ret = 0;\n\n    for(i = 0; i < n_lines; i++) {\n        const MD_VERBATIMLINE* line = &lines[i];\n        int indent = line->indent;\n\n        MD_ASSERT(indent >= 0);\n\n        /* Output code indentation. */\n        while(indent > (int) indent_chunk_size) {\n            MD_TEXT(text_type, indent_chunk_str, indent_chunk_size);\n            indent -= indent_chunk_size;\n        }\n        if(indent > 0)\n            MD_TEXT(text_type, indent_chunk_str, indent);\n\n        /* Output the code line itself. */\n        MD_TEXT_INSECURE(text_type, STR(line->beg), line->end - line->beg);\n\n        /* Enforce end-of-line. */\n        MD_TEXT(text_type, _T(\"\\n\"), 1);\n    }\n\nabort:\n    return ret;\n}\n\nstatic int\nmd_process_code_block_contents(MD_CTX* ctx, int is_fenced, const MD_VERBATIMLINE* lines, int n_lines)\n{\n    if(is_fenced) {\n        /* Skip the first line in case of fenced code: It is the fence.\n         * (Only the starting fence is present due to logic in md_analyze_line().) */\n        lines++;\n        n_lines--;\n    } else {\n        /* Ignore blank lines at start/end of indented code block. */\n        while(n_lines > 0  &&  lines[0].beg == lines[0].end) {\n            lines++;\n            n_lines--;\n        }\n        while(n_lines > 0  &&  lines[n_lines-1].beg == lines[n_lines-1].end) {\n            n_lines--;\n        }\n    }\n\n    if(n_lines == 0)\n        return 0;\n\n    return md_process_verbatim_block_contents(ctx, MD_TEXT_CODE, lines, n_lines);\n}\n\nstatic int\nmd_setup_fenced_code_detail(MD_CTX* ctx, const MD_BLOCK* block, MD_BLOCK_CODE_DETAIL* det,\n                            MD_ATTRIBUTE_BUILD* info_build, MD_ATTRIBUTE_BUILD* lang_build)\n{\n    const MD_VERBATIMLINE* fence_line = (const MD_VERBATIMLINE*)(block + 1);\n    OFF beg = fence_line->beg;\n    OFF end = fence_line->end;\n    OFF lang_end;\n    CHAR fence_ch = CH(fence_line->beg);\n    int ret = 0;\n\n    /* Skip the fence itself. */\n    while(beg < ctx->size  &&  CH(beg) == fence_ch)\n        beg++;\n    /* Trim initial spaces. */\n    while(beg < ctx->size  &&  CH(beg) == _T(' '))\n        beg++;\n\n    /* Trim trailing spaces. */\n    while(end > beg  &&  CH(end-1) == _T(' '))\n        end--;\n\n    /* Build info string attribute. */\n    MD_CHECK(md_build_attribute(ctx, STR(beg), end - beg, 0, &det->info, info_build));\n\n    /* Build info string attribute. */\n    lang_end = beg;\n    while(lang_end < end  &&  !ISWHITESPACE(lang_end))\n        lang_end++;\n    MD_CHECK(md_build_attribute(ctx, STR(beg), lang_end - beg, 0, &det->lang, lang_build));\n\n    det->fence_char = fence_ch;\n\nabort:\n    return ret;\n}\n\nstatic int\nmd_process_leaf_block(MD_CTX* ctx, const MD_BLOCK* block)\n{\n    union {\n        MD_BLOCK_H_DETAIL header;\n        MD_BLOCK_CODE_DETAIL code;\n        MD_BLOCK_TABLE_DETAIL table;\n    } det;\n    MD_ATTRIBUTE_BUILD info_build;\n    MD_ATTRIBUTE_BUILD lang_build;\n    int is_in_tight_list;\n    int clean_fence_code_detail = FALSE;\n    int ret = 0;\n\n    memset(&det, 0, sizeof(det));\n\n    if(ctx->n_containers == 0)\n        is_in_tight_list = FALSE;\n    else\n        is_in_tight_list = !ctx->containers[ctx->n_containers-1].is_loose;\n\n    switch(block->type) {\n        case MD_BLOCK_H:\n            det.header.level = block->data;\n            break;\n\n        case MD_BLOCK_CODE:\n            /* For fenced code block, we may need to set the info string. */\n            if(block->data != 0) {\n                memset(&det.code, 0, sizeof(MD_BLOCK_CODE_DETAIL));\n                clean_fence_code_detail = TRUE;\n                MD_CHECK(md_setup_fenced_code_detail(ctx, block, &det.code, &info_build, &lang_build));\n            }\n            break;\n\n        case MD_BLOCK_TABLE:\n            det.table.col_count = block->data;\n            det.table.head_row_count = 1;\n            det.table.body_row_count = block->n_lines - 2;\n            break;\n\n        default:\n            /* Noop. */\n            break;\n    }\n\n    if(!is_in_tight_list  ||  block->type != MD_BLOCK_P)\n        MD_ENTER_BLOCK(block->type, (void*) &det);\n\n    /* Process the block contents accordingly to is type. */\n    switch(block->type) {\n        case MD_BLOCK_HR:\n            /* noop */\n            break;\n\n        case MD_BLOCK_CODE:\n            MD_CHECK(md_process_code_block_contents(ctx, (block->data != 0),\n                            (const MD_VERBATIMLINE*)(block + 1), block->n_lines));\n            break;\n\n        case MD_BLOCK_HTML:\n            MD_CHECK(md_process_verbatim_block_contents(ctx, MD_TEXT_HTML,\n                            (const MD_VERBATIMLINE*)(block + 1), block->n_lines));\n            break;\n\n        case MD_BLOCK_TABLE:\n            MD_CHECK(md_process_table_block_contents(ctx, block->data,\n                            (const MD_LINE*)(block + 1), block->n_lines));\n            break;\n\n        default:\n            MD_CHECK(md_process_normal_block_contents(ctx,\n                            (const MD_LINE*)(block + 1), block->n_lines));\n            break;\n    }\n\n    if(!is_in_tight_list  ||  block->type != MD_BLOCK_P)\n        MD_LEAVE_BLOCK(block->type, (void*) &det);\n\nabort:\n    if(clean_fence_code_detail) {\n        md_free_attribute(ctx, &info_build);\n        md_free_attribute(ctx, &lang_build);\n    }\n    return ret;\n}\n\nstatic int\nmd_process_all_blocks(MD_CTX* ctx)\n{\n    int byte_off = 0;\n    int ret = 0;\n\n    /* ctx->containers now is not needed for detection of lists and list items\n     * so we reuse it for tracking what lists are loose or tight. We rely\n     * on the fact the vector is large enough to hold the deepest nesting\n     * level of lists. */\n    ctx->n_containers = 0;\n\n    while(byte_off < ctx->n_block_bytes) {\n        MD_BLOCK* block = (MD_BLOCK*)((char*)ctx->block_bytes + byte_off);\n        union {\n            MD_BLOCK_UL_DETAIL ul;\n            MD_BLOCK_OL_DETAIL ol;\n            MD_BLOCK_LI_DETAIL li;\n        } det;\n\n        switch(block->type) {\n            case MD_BLOCK_UL:\n                det.ul.is_tight = (block->flags & MD_BLOCK_LOOSE_LIST) ? FALSE : TRUE;\n                det.ul.mark = (CHAR) block->data;\n                break;\n\n            case MD_BLOCK_OL:\n                det.ol.start = block->n_lines;\n                det.ol.is_tight =  (block->flags & MD_BLOCK_LOOSE_LIST) ? FALSE : TRUE;\n                det.ol.mark_delimiter = (CHAR) block->data;\n                break;\n\n            case MD_BLOCK_LI:\n                det.li.is_task = (block->data != 0);\n                det.li.task_mark = (CHAR) block->data;\n                det.li.task_mark_offset = (OFF) block->n_lines;\n                break;\n\n            default:\n                /* noop */\n                break;\n        }\n\n        if(block->flags & MD_BLOCK_CONTAINER) {\n            if(block->flags & MD_BLOCK_CONTAINER_CLOSER) {\n                MD_LEAVE_BLOCK(block->type, &det);\n\n                if(block->type == MD_BLOCK_UL || block->type == MD_BLOCK_OL || block->type == MD_BLOCK_QUOTE)\n                    ctx->n_containers--;\n            }\n\n            if(block->flags & MD_BLOCK_CONTAINER_OPENER) {\n                MD_ENTER_BLOCK(block->type, &det);\n\n                if(block->type == MD_BLOCK_UL || block->type == MD_BLOCK_OL) {\n                    ctx->containers[ctx->n_containers].is_loose = (block->flags & MD_BLOCK_LOOSE_LIST);\n                    ctx->n_containers++;\n                } else if(block->type == MD_BLOCK_QUOTE) {\n                    /* This causes that any text in a block quote, even if\n                     * nested inside a tight list item, is wrapped with\n                     * <p>...</p>. */\n                    ctx->containers[ctx->n_containers].is_loose = TRUE;\n                    ctx->n_containers++;\n                }\n            }\n        } else {\n            MD_CHECK(md_process_leaf_block(ctx, block));\n\n            if(block->type == MD_BLOCK_CODE || block->type == MD_BLOCK_HTML)\n                byte_off += block->n_lines * sizeof(MD_VERBATIMLINE);\n            else\n                byte_off += block->n_lines * sizeof(MD_LINE);\n        }\n\n        byte_off += sizeof(MD_BLOCK);\n    }\n\n    ctx->n_block_bytes = 0;\n\nabort:\n    return ret;\n}\n\n\n/************************************\n ***  Grouping Lines into Blocks  ***\n ************************************/\n\nstatic void*\nmd_push_block_bytes(MD_CTX* ctx, int n_bytes)\n{\n    void* ptr;\n\n    if(ctx->n_block_bytes + n_bytes > ctx->alloc_block_bytes) {\n        void* new_block_bytes;\n\n        ctx->alloc_block_bytes = (ctx->alloc_block_bytes > 0\n                ? ctx->alloc_block_bytes + ctx->alloc_block_bytes / 2\n                : 512);\n        new_block_bytes = realloc(ctx->block_bytes, ctx->alloc_block_bytes);\n        if(new_block_bytes == NULL) {\n            MD_LOG(\"realloc() failed.\");\n            return NULL;\n        }\n\n        /* Fix the ->current_block after the reallocation. */\n        if(ctx->current_block != NULL) {\n            OFF off_current_block = (char*) ctx->current_block - (char*) ctx->block_bytes;\n            ctx->current_block = (MD_BLOCK*) ((char*) new_block_bytes + off_current_block);\n        }\n\n        ctx->block_bytes = new_block_bytes;\n    }\n\n    ptr = (char*)ctx->block_bytes + ctx->n_block_bytes;\n    ctx->n_block_bytes += n_bytes;\n    return ptr;\n}\n\nstatic int\nmd_start_new_block(MD_CTX* ctx, const MD_LINE_ANALYSIS* line)\n{\n    MD_BLOCK* block;\n\n    MD_ASSERT(ctx->current_block == NULL);\n\n    block = (MD_BLOCK*) md_push_block_bytes(ctx, sizeof(MD_BLOCK));\n    if(block == NULL)\n        return -1;\n\n    switch(line->type) {\n        case MD_LINE_HR:\n            block->type = MD_BLOCK_HR;\n            break;\n\n        case MD_LINE_ATXHEADER:\n        case MD_LINE_SETEXTHEADER:\n            block->type = MD_BLOCK_H;\n            break;\n\n        case MD_LINE_FENCEDCODE:\n        case MD_LINE_INDENTEDCODE:\n            block->type = MD_BLOCK_CODE;\n            break;\n\n        case MD_LINE_TEXT:\n            block->type = MD_BLOCK_P;\n            break;\n\n        case MD_LINE_HTML:\n            block->type = MD_BLOCK_HTML;\n            break;\n\n        case MD_LINE_BLANK:\n        case MD_LINE_SETEXTUNDERLINE:\n        case MD_LINE_TABLEUNDERLINE:\n        default:\n            MD_UNREACHABLE();\n            break;\n    }\n\n    block->flags = 0;\n    block->data = line->data;\n    block->n_lines = 0;\n\n    ctx->current_block = block;\n    return 0;\n}\n\n/* Eat from start of current (textual) block any reference definitions and\n * remember them so we can resolve any links referring to them.\n *\n * (Reference definitions can only be at start of it as they cannot break\n * a paragraph.)\n */\nstatic int\nmd_consume_link_reference_definitions(MD_CTX* ctx)\n{\n    MD_LINE* lines = (MD_LINE*) (ctx->current_block + 1);\n    int n_lines = ctx->current_block->n_lines;\n    int n = 0;\n\n    /* Compute how many lines at the start of the block form one or more\n     * reference definitions. */\n    while(n < n_lines) {\n        int n_link_ref_lines;\n\n        n_link_ref_lines = md_is_link_reference_definition(ctx,\n                                    lines + n, n_lines - n);\n        /* Not a reference definition? */\n        if(n_link_ref_lines == 0)\n            break;\n\n        /* We fail if it is the ref. def. but it could not be stored due\n         * a memory allocation error. */\n        if(n_link_ref_lines < 0)\n            return -1;\n\n        n += n_link_ref_lines;\n    }\n\n    /* If there was at least one reference definition, we need to remove\n     * its lines from the block, or perhaps even the whole block. */\n    if(n > 0) {\n        if(n == n_lines) {\n            /* Remove complete block. */\n            ctx->n_block_bytes -= n * sizeof(MD_LINE);\n            ctx->n_block_bytes -= sizeof(MD_BLOCK);\n            ctx->current_block = NULL;\n        } else {\n            /* Remove just some initial lines from the block. */\n            memmove(lines, lines + n, (n_lines - n) * sizeof(MD_LINE));\n            ctx->current_block->n_lines -= n;\n            ctx->n_block_bytes -= n * sizeof(MD_LINE);\n        }\n    }\n\n    return 0;\n}\n\nstatic int\nmd_end_current_block(MD_CTX* ctx)\n{\n    int ret = 0;\n\n    if(ctx->current_block == NULL)\n        return ret;\n\n    /* Check whether there is a reference definition. (We do this here instead\n     * of in md_analyze_line() because reference definition can take multiple\n     * lines.) */\n    if(ctx->current_block->type == MD_BLOCK_P  ||\n       (ctx->current_block->type == MD_BLOCK_H  &&  (ctx->current_block->flags & MD_BLOCK_SETEXT_HEADER)))\n    {\n        MD_LINE* lines = (MD_LINE*) (ctx->current_block + 1);\n        if(CH(lines[0].beg) == _T('[')) {\n            MD_CHECK(md_consume_link_reference_definitions(ctx));\n            if(ctx->current_block == NULL)\n                return ret;\n        }\n    }\n\n    if(ctx->current_block->type == MD_BLOCK_H  &&  (ctx->current_block->flags & MD_BLOCK_SETEXT_HEADER)) {\n        int n_lines = ctx->current_block->n_lines;\n\n        if(n_lines > 1) {\n            /* Get rid of the underline. */\n            ctx->current_block->n_lines--;\n            ctx->n_block_bytes -= sizeof(MD_LINE);\n        } else {\n            /* Only the underline has left after eating the ref. defs.\n             * Keep the line as beginning of a new ordinary paragraph. */\n            ctx->current_block->type = MD_BLOCK_P;\n            return 0;\n        }\n    }\n\n    /* Mark we are not building any block anymore. */\n    ctx->current_block = NULL;\n\nabort:\n    return ret;\n}\n\nstatic int\nmd_add_line_into_current_block(MD_CTX* ctx, const MD_LINE_ANALYSIS* analysis)\n{\n    MD_ASSERT(ctx->current_block != NULL);\n\n    if(ctx->current_block->type == MD_BLOCK_CODE || ctx->current_block->type == MD_BLOCK_HTML) {\n        MD_VERBATIMLINE* line;\n\n        line = (MD_VERBATIMLINE*) md_push_block_bytes(ctx, sizeof(MD_VERBATIMLINE));\n        if(line == NULL)\n            return -1;\n\n        line->indent = analysis->indent;\n        line->beg = analysis->beg;\n        line->end = analysis->end;\n    } else {\n        MD_LINE* line;\n\n        line = (MD_LINE*) md_push_block_bytes(ctx, sizeof(MD_LINE));\n        if(line == NULL)\n            return -1;\n\n        line->beg = analysis->beg;\n        line->end = analysis->end;\n    }\n    ctx->current_block->n_lines++;\n\n    return 0;\n}\n\nstatic int\nmd_push_container_bytes(MD_CTX* ctx, MD_BLOCKTYPE type, unsigned start,\n                        unsigned data, unsigned flags)\n{\n    MD_BLOCK* block;\n    int ret = 0;\n\n    MD_CHECK(md_end_current_block(ctx));\n\n    block = (MD_BLOCK*) md_push_block_bytes(ctx, sizeof(MD_BLOCK));\n    if(block == NULL)\n        return -1;\n\n    block->type = type;\n    block->flags = flags;\n    block->data = data;\n    block->n_lines = start;\n\nabort:\n    return ret;\n}\n\n\n\n/***********************\n ***  Line Analysis  ***\n ***********************/\n\nstatic int\nmd_is_hr_line(MD_CTX* ctx, OFF beg, OFF* p_end, OFF* p_killer)\n{\n    OFF off = beg + 1;\n    int n = 1;\n\n    while(off < ctx->size  &&  (CH(off) == CH(beg) || CH(off) == _T(' ') || CH(off) == _T('\\t'))) {\n        if(CH(off) == CH(beg))\n            n++;\n        off++;\n    }\n\n    if(n < 3) {\n        *p_killer = off;\n        return FALSE;\n    }\n\n    /* Nothing else can be present on the line. */\n    if(off < ctx->size  &&  !ISNEWLINE(off)) {\n        *p_killer = off;\n        return FALSE;\n    }\n\n    *p_end = off;\n    return TRUE;\n}\n\nstatic int\nmd_is_atxheader_line(MD_CTX* ctx, OFF beg, OFF* p_beg, OFF* p_end, unsigned* p_level)\n{\n    int n;\n    OFF off = beg + 1;\n\n    while(off < ctx->size  &&  CH(off) == _T('#')  &&  off - beg < 7)\n        off++;\n    n = off - beg;\n\n    if(n > 6)\n        return FALSE;\n    *p_level = n;\n\n    if(!(ctx->parser.flags & MD_FLAG_PERMISSIVEATXHEADERS)  &&  off < ctx->size  &&\n       CH(off) != _T(' ')  &&  CH(off) != _T('\\t')  &&  !ISNEWLINE(off))\n        return FALSE;\n\n    while(off < ctx->size  &&  CH(off) == _T(' '))\n        off++;\n    *p_beg = off;\n    *p_end = off;\n    return TRUE;\n}\n\nstatic int\nmd_is_setext_underline(MD_CTX* ctx, OFF beg, OFF* p_end, unsigned* p_level)\n{\n    OFF off = beg + 1;\n\n    while(off < ctx->size  &&  CH(off) == CH(beg))\n        off++;\n\n    /* Optionally, space(s) can follow. */\n    while(off < ctx->size  &&  CH(off) == _T(' '))\n        off++;\n\n    /* But nothing more is allowed on the line. */\n    if(off < ctx->size  &&  !ISNEWLINE(off))\n        return FALSE;\n\n    *p_level = (CH(beg) == _T('=') ? 1 : 2);\n    *p_end = off;\n    return TRUE;\n}\n\nstatic int\nmd_is_table_underline(MD_CTX* ctx, OFF beg, OFF* p_end, unsigned* p_col_count)\n{\n    OFF off = beg;\n    int found_pipe = FALSE;\n    unsigned col_count = 0;\n\n    if(off < ctx->size  &&  CH(off) == _T('|')) {\n        found_pipe = TRUE;\n        off++;\n        while(off < ctx->size  &&  ISWHITESPACE(off))\n            off++;\n    }\n\n    while(1) {\n        OFF cell_beg;\n        int delimited = FALSE;\n\n        /* Cell underline (\"-----\", \":----\", \"----:\" or \":----:\") */\n        cell_beg = off;\n        if(off < ctx->size  &&  CH(off) == _T(':'))\n            off++;\n        while(off < ctx->size  &&  CH(off) == _T('-'))\n            off++;\n        if(off < ctx->size  &&  CH(off) == _T(':'))\n            off++;\n        if(off - cell_beg < 3)\n            return FALSE;\n\n        col_count++;\n\n        /* Pipe delimiter (optional at the end of line). */\n        while(off < ctx->size  &&  ISWHITESPACE(off))\n            off++;\n        if(off < ctx->size  &&  CH(off) == _T('|')) {\n            delimited = TRUE;\n            found_pipe =  TRUE;\n            off++;\n            while(off < ctx->size  &&  ISWHITESPACE(off))\n                off++;\n        }\n\n        /* Success, if we reach end of line. */\n        if(off >= ctx->size  ||  ISNEWLINE(off))\n            break;\n\n        if(!delimited)\n            return FALSE;\n    }\n\n    if(!found_pipe)\n        return FALSE;\n\n    *p_end = off;\n    *p_col_count = col_count;\n    return TRUE;\n}\n\nstatic int\nmd_is_opening_code_fence(MD_CTX* ctx, OFF beg, OFF* p_end)\n{\n    OFF off = beg;\n\n    while(off < ctx->size && CH(off) == CH(beg))\n        off++;\n\n    /* Fence must have at least three characters. */\n    if(off - beg < 3)\n        return FALSE;\n\n    ctx->code_fence_length = off - beg;\n\n    /* Optionally, space(s) can follow. */\n    while(off < ctx->size  &&  CH(off) == _T(' '))\n        off++;\n\n    /* Optionally, an info string can follow. */\n    while(off < ctx->size  &&  !ISNEWLINE(off)) {\n        /* Backtick-based fence must not contain '`' in the info string. */\n        if(CH(beg) == _T('`')  &&  CH(off) == _T('`'))\n            return FALSE;\n        off++;\n    }\n\n    *p_end = off;\n    return TRUE;\n}\n\nstatic int\nmd_is_closing_code_fence(MD_CTX* ctx, CHAR ch, OFF beg, OFF* p_end)\n{\n    OFF off = beg;\n    int ret = FALSE;\n\n    /* Closing fence must have at least the same length and use same char as\n     * opening one. */\n    while(off < ctx->size  &&  CH(off) == ch)\n        off++;\n    if(off - beg < ctx->code_fence_length)\n        goto out;\n\n    /* Optionally, space(s) can follow */\n    while(off < ctx->size  &&  CH(off) == _T(' '))\n        off++;\n\n    /* But nothing more is allowed on the line. */\n    if(off < ctx->size  &&  !ISNEWLINE(off))\n        goto out;\n\n    ret = TRUE;\n\nout:\n    /* Note we set *p_end even on failure: If we are not closing fence, caller\n     * would eat the line anyway without any parsing. */\n    *p_end = off;\n    return ret;\n}\n\n/* Returns type of the raw HTML block, or FALSE if it is not HTML block.\n * (Refer to CommonMark specification for details about the types.)\n */\nstatic int\nmd_is_html_block_start_condition(MD_CTX* ctx, OFF beg)\n{\n    typedef struct TAG_tag TAG;\n    struct TAG_tag {\n        const CHAR* name;\n        unsigned len    : 8;\n    };\n\n    /* Type 6 is started by a long list of allowed tags. We use two-level\n     * tree to speed-up the search. */\n#ifdef X\n    #undef X\n#endif\n#define X(name)     { _T(name), (sizeof(name)-1) / sizeof(CHAR) }\n#define Xend        { NULL, 0 }\n    static const TAG t1[] = { X(\"script\"), X(\"pre\"), X(\"style\"), Xend };\n\n    static const TAG a6[] = { X(\"address\"), X(\"article\"), X(\"aside\"), Xend };\n    static const TAG b6[] = { X(\"base\"), X(\"basefont\"), X(\"blockquote\"), X(\"body\"), Xend };\n    static const TAG c6[] = { X(\"caption\"), X(\"center\"), X(\"col\"), X(\"colgroup\"), Xend };\n    static const TAG d6[] = { X(\"dd\"), X(\"details\"), X(\"dialog\"), X(\"dir\"),\n                              X(\"div\"), X(\"dl\"), X(\"dt\"), Xend };\n    static const TAG f6[] = { X(\"fieldset\"), X(\"figcaption\"), X(\"figure\"), X(\"footer\"),\n                              X(\"form\"), X(\"frame\"), X(\"frameset\"), Xend };\n    static const TAG h6[] = { X(\"h1\"), X(\"head\"), X(\"header\"), X(\"hr\"), X(\"html\"), Xend };\n    static const TAG i6[] = { X(\"iframe\"), Xend };\n    static const TAG l6[] = { X(\"legend\"), X(\"li\"), X(\"link\"), Xend };\n    static const TAG m6[] = { X(\"main\"), X(\"menu\"), X(\"menuitem\"), Xend };\n    static const TAG n6[] = { X(\"nav\"), X(\"noframes\"), Xend };\n    static const TAG o6[] = { X(\"ol\"), X(\"optgroup\"), X(\"option\"), Xend };\n    static const TAG p6[] = { X(\"p\"), X(\"param\"), Xend };\n    static const TAG s6[] = { X(\"section\"), X(\"source\"), X(\"summary\"), Xend };\n    static const TAG t6[] = { X(\"table\"), X(\"tbody\"), X(\"td\"), X(\"tfoot\"), X(\"th\"),\n                              X(\"thead\"), X(\"title\"), X(\"tr\"), X(\"track\"), Xend };\n    static const TAG u6[] = { X(\"ul\"), Xend };\n    static const TAG xx[] = { Xend };\n#undef X\n\n    static const TAG* map6[26] = {\n        a6, b6, c6, d6, xx, f6, xx, h6, i6, xx, xx, l6, m6,\n        n6, o6, p6, xx, xx, s6, t6, u6, xx, xx, xx, xx, xx\n    };\n    OFF off = beg + 1;\n    int i;\n\n    /* Check for type 1: <script, <pre, or <style */\n    for(i = 0; t1[i].name != NULL; i++) {\n        if(off + t1[i].len <= ctx->size) {\n            if(md_ascii_case_eq(STR(off), t1[i].name, t1[i].len))\n                return 1;\n        }\n    }\n\n    /* Check for type 2: <!-- */\n    if(off + 3 < ctx->size  &&  CH(off) == _T('!')  &&  CH(off+1) == _T('-')  &&  CH(off+2) == _T('-'))\n        return 2;\n\n    /* Check for type 3: <? */\n    if(off < ctx->size  &&  CH(off) == _T('?'))\n        return 3;\n\n    /* Check for type 4 or 5: <! */\n    if(off < ctx->size  &&  CH(off) == _T('!')) {\n        /* Check for type 4: <! followed by uppercase letter. */\n        if(off + 1 < ctx->size  &&  ISUPPER(off+1))\n            return 4;\n\n        /* Check for type 5: <![CDATA[ */\n        if(off + 8 < ctx->size) {\n            if(md_ascii_eq(STR(off), _T(\"![CDATA[\"), 8))\n                return 5;\n        }\n    }\n\n    /* Check for type 6: Many possible starting tags listed above. */\n    if(off + 1 < ctx->size  &&  (ISALPHA(off) || (CH(off) == _T('/') && ISALPHA(off+1)))) {\n        int slot;\n        const TAG* tags;\n\n        if(CH(off) == _T('/'))\n            off++;\n\n        slot = (ISUPPER(off) ? CH(off) - 'A' : CH(off) - 'a');\n        tags = map6[slot];\n\n        for(i = 0; tags[i].name != NULL; i++) {\n            if(off + tags[i].len <= ctx->size) {\n                if(md_ascii_case_eq(STR(off), tags[i].name, tags[i].len)) {\n                    OFF tmp = off + tags[i].len;\n                    if(tmp >= ctx->size)\n                        return 6;\n                    if(ISBLANK(tmp) || ISNEWLINE(tmp) || CH(tmp) == _T('>'))\n                        return 6;\n                    if(tmp+1 < ctx->size && CH(tmp) == _T('/') && CH(tmp+1) == _T('>'))\n                        return 6;\n                    break;\n                }\n            }\n        }\n    }\n\n    /* Check for type 7: any COMPLETE other opening or closing tag. */\n    if(off + 1 < ctx->size) {\n        OFF end;\n\n        if(md_is_html_tag(ctx, NULL, 0, beg, ctx->size, &end)) {\n            /* Only optional whitespace and new line may follow. */\n            while(end < ctx->size  &&  ISWHITESPACE(end))\n                end++;\n            if(end >= ctx->size  ||  ISNEWLINE(end))\n                return 7;\n        }\n    }\n\n    return FALSE;\n}\n\n/* Case sensitive check whether there is a substring 'what' between 'beg'\n * and end of line. */\nstatic int\nmd_line_contains(MD_CTX* ctx, OFF beg, const CHAR* what, SZ what_len, OFF* p_end)\n{\n    OFF i;\n    for(i = beg; i + what_len < ctx->size; i++) {\n        if(ISNEWLINE(i))\n            break;\n        if(memcmp(STR(i), what, what_len * sizeof(CHAR)) == 0) {\n            *p_end = i + what_len;\n            return TRUE;\n        }\n    }\n\n    *p_end = i;\n    return FALSE;\n}\n\n/* Returns type of HTML block end condition or FALSE if not an end condition.\n *\n * Note it fills p_end even when it is not end condition as the caller\n * does not need to analyze contents of a raw HTML block.\n */\nstatic int\nmd_is_html_block_end_condition(MD_CTX* ctx, OFF beg, OFF* p_end)\n{\n    switch(ctx->html_block_type) {\n        case 1:\n        {\n            OFF off = beg;\n\n            while(off < ctx->size  &&  !ISNEWLINE(off)) {\n                if(CH(off) == _T('<')) {\n                    if(md_ascii_case_eq(STR(off), _T(\"</script>\"), 9)) {\n                        *p_end = off + 9;\n                        return TRUE;\n                    }\n\n                    if(md_ascii_case_eq(STR(off), _T(\"</style>\"), 8)) {\n                        *p_end = off + 8;\n                        return TRUE;\n                    }\n\n                    if(md_ascii_case_eq(STR(off), _T(\"</pre>\"), 6)) {\n                        *p_end = off + 6;\n                        return TRUE;\n                    }\n                }\n\n                off++;\n            }\n            *p_end = off;\n            return FALSE;\n        }\n\n        case 2:\n            return (md_line_contains(ctx, beg, _T(\"-->\"), 3, p_end) ? 2 : FALSE);\n\n        case 3:\n            return (md_line_contains(ctx, beg, _T(\"?>\"), 2, p_end) ? 3 : FALSE);\n\n        case 4:\n            return (md_line_contains(ctx, beg, _T(\">\"), 1, p_end) ? 4 : FALSE);\n\n        case 5:\n            return (md_line_contains(ctx, beg, _T(\"]]>\"), 3, p_end) ? 5 : FALSE);\n\n        case 6:     /* Pass through */\n        case 7:\n            *p_end = beg;\n            return (ISNEWLINE(beg) ? ctx->html_block_type : FALSE);\n\n        default:\n            MD_UNREACHABLE();\n    }\n    return FALSE;\n}\n\n\nstatic int\nmd_is_container_compatible(const MD_CONTAINER* pivot, const MD_CONTAINER* container)\n{\n    /* Block quote has no \"items\" like lists. */\n    if(container->ch == _T('>'))\n        return FALSE;\n\n    if(container->ch != pivot->ch)\n        return FALSE;\n    if(container->mark_indent > pivot->contents_indent)\n        return FALSE;\n\n    return TRUE;\n}\n\nstatic int\nmd_push_container(MD_CTX* ctx, const MD_CONTAINER* container)\n{\n    if(ctx->n_containers >= ctx->alloc_containers) {\n        MD_CONTAINER* new_containers;\n\n        ctx->alloc_containers = (ctx->alloc_containers > 0\n                ? ctx->alloc_containers + ctx->alloc_containers / 2\n                : 16);\n        new_containers = realloc(ctx->containers, ctx->alloc_containers * sizeof(MD_CONTAINER));\n        if(new_containers == NULL) {\n            MD_LOG(\"realloc() failed.\");\n            return -1;\n        }\n\n        ctx->containers = new_containers;\n    }\n\n    memcpy(&ctx->containers[ctx->n_containers++], container, sizeof(MD_CONTAINER));\n    return 0;\n}\n\nstatic int\nmd_enter_child_containers(MD_CTX* ctx, int n_children)\n{\n    int i;\n    int ret = 0;\n\n    for(i = ctx->n_containers - n_children; i < ctx->n_containers; i++) {\n        MD_CONTAINER* c = &ctx->containers[i];\n        int is_ordered_list = FALSE;\n\n        switch(c->ch) {\n            case _T(')'):\n            case _T('.'):\n                is_ordered_list = TRUE;\n                MD_FALLTHROUGH();\n\n            case _T('-'):\n            case _T('+'):\n            case _T('*'):\n                /* Remember offset in ctx->block_bytes so we can revisit the\n                 * block if we detect it is a loose list. */\n                md_end_current_block(ctx);\n                c->block_byte_off = ctx->n_block_bytes;\n\n                MD_CHECK(md_push_container_bytes(ctx,\n                                (is_ordered_list ? MD_BLOCK_OL : MD_BLOCK_UL),\n                                c->start, c->ch, MD_BLOCK_CONTAINER_OPENER));\n                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI,\n                                c->task_mark_off,\n                                (c->is_task ? CH(c->task_mark_off) : 0),\n                                MD_BLOCK_CONTAINER_OPENER));\n                break;\n\n            case _T('>'):\n                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_QUOTE, 0, 0, MD_BLOCK_CONTAINER_OPENER));\n                break;\n\n            default:\n                MD_UNREACHABLE();\n                break;\n        }\n    }\n\nabort:\n    return ret;\n}\n\nstatic int\nmd_leave_child_containers(MD_CTX* ctx, int n_keep)\n{\n    int ret = 0;\n\n    while(ctx->n_containers > n_keep) {\n        MD_CONTAINER* c = &ctx->containers[ctx->n_containers-1];\n        int is_ordered_list = FALSE;\n\n        switch(c->ch) {\n            case _T(')'):\n            case _T('.'):\n                is_ordered_list = TRUE;\n                MD_FALLTHROUGH();\n\n            case _T('-'):\n            case _T('+'):\n            case _T('*'):\n                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI,\n                                c->task_mark_off, (c->is_task ? CH(c->task_mark_off) : 0),\n                                MD_BLOCK_CONTAINER_CLOSER));\n                MD_CHECK(md_push_container_bytes(ctx,\n                                (is_ordered_list ? MD_BLOCK_OL : MD_BLOCK_UL), 0,\n                                c->ch, MD_BLOCK_CONTAINER_CLOSER));\n                break;\n\n            case _T('>'):\n                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_QUOTE, 0,\n                                0, MD_BLOCK_CONTAINER_CLOSER));\n                break;\n\n            default:\n                MD_UNREACHABLE();\n                break;\n        }\n\n        ctx->n_containers--;\n    }\n\nabort:\n    return ret;\n}\n\nstatic int\nmd_is_container_mark(MD_CTX* ctx, unsigned indent, OFF beg, OFF* p_end, MD_CONTAINER* p_container)\n{\n    OFF off = beg;\n    OFF max_end;\n\n    if(off >= ctx->size  ||  indent >= ctx->code_indent_offset)\n        return FALSE;\n\n    /* Check for block quote mark. */\n    if(CH(off) == _T('>')) {\n        off++;\n        p_container->ch = _T('>');\n        p_container->is_loose = FALSE;\n        p_container->is_task = FALSE;\n        p_container->mark_indent = indent;\n        p_container->contents_indent = indent + 1;\n        *p_end = off;\n        return TRUE;\n    }\n\n    /* Check for list item bullet mark. */\n    if(ISANYOF(off, _T(\"-+*\"))  &&  (off+1 >= ctx->size || ISBLANK(off+1) || ISNEWLINE(off+1))) {\n        p_container->ch = CH(off);\n        p_container->is_loose = FALSE;\n        p_container->is_task = FALSE;\n        p_container->mark_indent = indent;\n        p_container->contents_indent = indent + 1;\n        *p_end = off+1;\n        return TRUE;\n    }\n\n    /* Check for ordered list item marks. */\n    max_end = off + 9;\n    if(max_end > ctx->size)\n        max_end = ctx->size;\n    p_container->start = 0;\n    while(off < max_end  &&  ISDIGIT(off)) {\n        p_container->start = p_container->start * 10 + CH(off) - _T('0');\n        off++;\n    }\n    if(off > beg  &&\n       (CH(off) == _T('.') || CH(off) == _T(')'))  &&\n       (off+1 >= ctx->size || ISBLANK(off+1) || ISNEWLINE(off+1)))\n    {\n        p_container->ch = CH(off);\n        p_container->is_loose = FALSE;\n        p_container->is_task = FALSE;\n        p_container->mark_indent = indent;\n        p_container->contents_indent = indent + off - beg + 1;\n        *p_end = off+1;\n        return TRUE;\n    }\n\n    return FALSE;\n}\n\nstatic unsigned\nmd_line_indentation(MD_CTX* ctx, unsigned total_indent, OFF beg, OFF* p_end)\n{\n    OFF off = beg;\n    unsigned indent = total_indent;\n\n    while(off < ctx->size  &&  ISBLANK(off)) {\n        if(CH(off) == _T('\\t'))\n            indent = (indent + 4) & ~3;\n        else\n            indent++;\n        off++;\n    }\n\n    *p_end = off;\n    return indent - total_indent;\n}\n\nstatic const MD_LINE_ANALYSIS md_dummy_blank_line = { MD_LINE_BLANK, 0, 0, 0, 0 };\n\n/* Analyze type of the line and find some its properties. This serves as a\n * main input for determining type and boundaries of a block. */\nstatic int\nmd_analyze_line(MD_CTX* ctx, OFF beg, OFF* p_end,\n                const MD_LINE_ANALYSIS* pivot_line, MD_LINE_ANALYSIS* line)\n{\n    unsigned total_indent = 0;\n    int n_parents = 0;\n    int n_brothers = 0;\n    int n_children = 0;\n    MD_CONTAINER container = { 0 };\n    int prev_line_has_list_loosening_effect = ctx->last_line_has_list_loosening_effect;\n    OFF off = beg;\n    OFF hr_killer = 0;\n    int ret = 0;\n\n    line->indent = md_line_indentation(ctx, total_indent, off, &off);\n    total_indent += line->indent;\n    line->beg = off;\n\n    /* Given the indentation and block quote marks '>', determine how many of\n     * the current containers are our parents. */\n    while(n_parents < ctx->n_containers) {\n        MD_CONTAINER* c = &ctx->containers[n_parents];\n\n        if(c->ch == _T('>')  &&  line->indent < ctx->code_indent_offset  &&\n            off < ctx->size  &&  CH(off) == _T('>'))\n        {\n            /* Block quote mark. */\n            off++;\n            total_indent++;\n            line->indent = md_line_indentation(ctx, total_indent, off, &off);\n            total_indent += line->indent;\n\n            /* The optional 1st space after '>' is part of the block quote mark. */\n            if(line->indent > 0)\n                line->indent--;\n\n            line->beg = off;\n\n        } else if(c->ch != _T('>')  &&  line->indent >= c->contents_indent) {\n            /* List. */\n            line->indent -= c->contents_indent;\n        } else {\n            break;\n        }\n\n        n_parents++;\n    }\n\n    if(off >= ctx->size  ||  ISNEWLINE(off)) {\n        /* Blank line does not need any real indentation to be nested inside\n         * a list. */\n        if(n_brothers + n_children == 0) {\n            while(n_parents < ctx->n_containers  &&  ctx->containers[n_parents].ch != _T('>'))\n                n_parents++;\n        }\n    }\n\n    while(TRUE) {\n        /* Check whether we are fenced code continuation. */\n        if(pivot_line->type == MD_LINE_FENCEDCODE) {\n            line->beg = off;\n\n            /* We are another MD_LINE_FENCEDCODE unless we are closing fence\n             * which we transform into MD_LINE_BLANK. */\n            if(line->indent < ctx->code_indent_offset) {\n                if(md_is_closing_code_fence(ctx, CH(pivot_line->beg), off, &off)) {\n                    line->type = MD_LINE_BLANK;\n                    ctx->last_line_has_list_loosening_effect = FALSE;\n                    break;\n                }\n            }\n\n            /* Change indentation accordingly to the initial code fence. */\n            if(n_parents == ctx->n_containers) {\n                if(line->indent > pivot_line->indent)\n                    line->indent -= pivot_line->indent;\n                else\n                    line->indent = 0;\n\n                line->type = MD_LINE_FENCEDCODE;\n                break;\n            }\n        }\n\n        /* Check whether we are HTML block continuation. */\n        if(pivot_line->type == MD_LINE_HTML  &&  ctx->html_block_type > 0) {\n            if(n_parents < ctx->n_containers) {\n                /* HTML block is implicitly ended if the enclosing container\n                 * block ends. */\n                ctx->html_block_type = 0;\n            } else {\n                int html_block_type;\n\n                html_block_type = md_is_html_block_end_condition(ctx, off, &off);\n                if(html_block_type > 0) {\n                    MD_ASSERT(html_block_type == ctx->html_block_type);\n\n                    /* Make sure this is the last line of the block. */\n                    ctx->html_block_type = 0;\n\n                    /* Some end conditions serve as blank lines at the same time. */\n                    if(html_block_type == 6 || html_block_type == 7) {\n                        line->type = MD_LINE_BLANK;\n                        line->indent = 0;\n                        break;\n                    }\n                }\n\n                line->type = MD_LINE_HTML;\n                n_parents = ctx->n_containers;\n                break;\n            }\n        }\n\n        /* Check for blank line. */\n        if(off >= ctx->size  ||  ISNEWLINE(off)) {\n            if(pivot_line->type == MD_LINE_INDENTEDCODE  &&  n_parents == ctx->n_containers) {\n                line->type = MD_LINE_INDENTEDCODE;\n                if(line->indent > ctx->code_indent_offset)\n                    line->indent -= ctx->code_indent_offset;\n                else\n                    line->indent = 0;\n                ctx->last_line_has_list_loosening_effect = FALSE;\n            } else {\n                line->type = MD_LINE_BLANK;\n                ctx->last_line_has_list_loosening_effect = (n_parents > 0  &&\n                        n_brothers + n_children == 0  &&\n                        ctx->containers[n_parents-1].ch != _T('>'));\n\n    #if 1\n                /* See https://github.com/mity/md4c/issues/6\n                 *\n                 * This ugly checking tests we are in (yet empty) list item but\n                 * not its very first line (i.e. not the line with the list\n                 * item mark).\n                 *\n                 * If we are such a blank line, then any following non-blank\n                 * line which would be part of the list item actually has to\n                 * end the list because according to the specification, \"a list\n                 * item can begin with at most one blank line.\"\n                 */\n                if(n_parents > 0  &&  ctx->containers[n_parents-1].ch != _T('>')  &&\n                   n_brothers + n_children == 0  &&  ctx->current_block == NULL  &&\n                   ctx->n_block_bytes > (int) sizeof(MD_BLOCK))\n                {\n                    MD_BLOCK* top_block = (MD_BLOCK*) ((char*)ctx->block_bytes + ctx->n_block_bytes - sizeof(MD_BLOCK));\n                    if(top_block->type == MD_BLOCK_LI)\n                        ctx->last_list_item_starts_with_two_blank_lines = TRUE;\n                }\n    #endif\n            }\n            break;\n        } else {\n    #if 1\n            /* This is the 2nd half of the hack. If the flag is set (i.e. there\n             * was a 2nd blank line at the beginning of the list item) and if\n             * we would otherwise still belong to the list item, we enforce\n             * the end of the list. */\n            ctx->last_line_has_list_loosening_effect = FALSE;\n            if(ctx->last_list_item_starts_with_two_blank_lines) {\n                if(n_parents > 0  &&  ctx->containers[n_parents-1].ch != _T('>')  &&\n                   n_brothers + n_children == 0  &&  ctx->current_block == NULL  &&\n                   ctx->n_block_bytes > (int) sizeof(MD_BLOCK))\n                {\n                    MD_BLOCK* top_block = (MD_BLOCK*) ((char*)ctx->block_bytes + ctx->n_block_bytes - sizeof(MD_BLOCK));\n                    if(top_block->type == MD_BLOCK_LI)\n                        n_parents--;\n                }\n\n                ctx->last_list_item_starts_with_two_blank_lines = FALSE;\n            }\n    #endif\n        }\n\n        /* Check whether we are Setext underline. */\n        if(line->indent < ctx->code_indent_offset  &&  pivot_line->type == MD_LINE_TEXT\n            &&  off < ctx->size  &&  ISANYOF2(off, _T('='), _T('-'))\n            &&  (n_parents == ctx->n_containers))\n        {\n            unsigned level;\n\n            if(md_is_setext_underline(ctx, off, &off, &level)) {\n                line->type = MD_LINE_SETEXTUNDERLINE;\n                line->data = level;\n                break;\n            }\n        }\n\n        /* Check for thematic break line. */\n        if(line->indent < ctx->code_indent_offset\n            &&  off < ctx->size  &&  off >= hr_killer\n            &&  ISANYOF(off, _T(\"-_*\")))\n        {\n            if(md_is_hr_line(ctx, off, &off, &hr_killer)) {\n                line->type = MD_LINE_HR;\n                break;\n            }\n        }\n\n        /* Check for \"brother\" container. I.e. whether we are another list item\n         * in already started list. */\n        if(n_parents < ctx->n_containers  &&  n_brothers + n_children == 0) {\n            OFF tmp;\n\n            if(md_is_container_mark(ctx, line->indent, off, &tmp, &container)  &&\n               md_is_container_compatible(&ctx->containers[n_parents], &container))\n            {\n                pivot_line = &md_dummy_blank_line;\n\n                off = tmp;\n\n                total_indent += container.contents_indent - container.mark_indent;\n                line->indent = md_line_indentation(ctx, total_indent, off, &off);\n                total_indent += line->indent;\n                line->beg = off;\n\n                /* Some of the following whitespace actually still belongs to the mark. */\n                if(off >= ctx->size || ISNEWLINE(off)) {\n                    container.contents_indent++;\n                } else if(line->indent <= ctx->code_indent_offset) {\n                    container.contents_indent += line->indent;\n                    line->indent = 0;\n                } else {\n                    container.contents_indent += 1;\n                    line->indent--;\n                }\n\n                ctx->containers[n_parents].mark_indent = container.mark_indent;\n                ctx->containers[n_parents].contents_indent = container.contents_indent;\n\n                n_brothers++;\n                continue;\n            }\n        }\n\n        /* Check for indented code.\n         * Note indented code block cannot interrupt a paragraph. */\n        if(line->indent >= ctx->code_indent_offset  &&\n            (pivot_line->type == MD_LINE_BLANK || pivot_line->type == MD_LINE_INDENTEDCODE))\n        {\n            line->type = MD_LINE_INDENTEDCODE;\n            MD_ASSERT(line->indent >= ctx->code_indent_offset);\n            line->indent -= ctx->code_indent_offset;\n            line->data = 0;\n            break;\n        }\n\n        /* Check for start of a new container block. */\n        if(line->indent < ctx->code_indent_offset  &&\n           md_is_container_mark(ctx, line->indent, off, &off, &container))\n        {\n            if(pivot_line->type == MD_LINE_TEXT  &&  n_parents == ctx->n_containers  &&\n                        (off >= ctx->size || ISNEWLINE(off))  &&  container.ch != _T('>'))\n            {\n                /* Noop. List mark followed by a blank line cannot interrupt a paragraph. */\n            } else if(pivot_line->type == MD_LINE_TEXT  &&  n_parents == ctx->n_containers  &&\n                        ISANYOF2_(container.ch, _T('.'), _T(')'))  &&  container.start != 1)\n            {\n                /* Noop. Ordered list cannot interrupt a paragraph unless the start index is 1. */\n            } else {\n                total_indent += container.contents_indent - container.mark_indent;\n                line->indent = md_line_indentation(ctx, total_indent, off, &off);\n                total_indent += line->indent;\n\n                line->beg = off;\n                line->data = container.ch;\n\n                /* Some of the following whitespace actually still belongs to the mark. */\n                if(off >= ctx->size || ISNEWLINE(off)) {\n                    container.contents_indent++;\n                } else if(line->indent <= ctx->code_indent_offset) {\n                    container.contents_indent += line->indent;\n                    line->indent = 0;\n                } else {\n                    container.contents_indent += 1;\n                    line->indent--;\n                }\n\n                if(n_brothers + n_children == 0)\n                    pivot_line = &md_dummy_blank_line;\n\n                if(n_children == 0)\n                    MD_CHECK(md_leave_child_containers(ctx, n_parents + n_brothers));\n\n                n_children++;\n                MD_CHECK(md_push_container(ctx, &container));\n                continue;\n            }\n        }\n\n        /* Check whether we are table continuation. */\n        if(pivot_line->type == MD_LINE_TABLE  &&  n_parents == ctx->n_containers) {\n            line->type = MD_LINE_TABLE;\n            break;\n        }\n\n        /* Check for ATX header. */\n        if(line->indent < ctx->code_indent_offset  &&\n                off < ctx->size  &&  CH(off) == _T('#'))\n        {\n            unsigned level;\n\n            if(md_is_atxheader_line(ctx, off, &line->beg, &off, &level)) {\n                line->type = MD_LINE_ATXHEADER;\n                line->data = level;\n                break;\n            }\n        }\n\n        /* Check whether we are starting code fence. */\n        if(off < ctx->size  &&  ISANYOF2(off, _T('`'), _T('~'))) {\n            if(md_is_opening_code_fence(ctx, off, &off)) {\n                line->type = MD_LINE_FENCEDCODE;\n                line->data = 1;\n                break;\n            }\n        }\n\n        /* Check for start of raw HTML block. */\n        if(off < ctx->size  &&  CH(off) == _T('<')\n            &&  !(ctx->parser.flags & MD_FLAG_NOHTMLBLOCKS))\n        {\n            ctx->html_block_type = md_is_html_block_start_condition(ctx, off);\n\n            /* HTML block type 7 cannot interrupt paragraph. */\n            if(ctx->html_block_type == 7  &&  pivot_line->type == MD_LINE_TEXT)\n                ctx->html_block_type = 0;\n\n            if(ctx->html_block_type > 0) {\n                /* The line itself also may immediately close the block. */\n                if(md_is_html_block_end_condition(ctx, off, &off) == ctx->html_block_type) {\n                    /* Make sure this is the last line of the block. */\n                    ctx->html_block_type = 0;\n                }\n\n                line->type = MD_LINE_HTML;\n                break;\n            }\n        }\n\n        /* Check for table underline. */\n        if((ctx->parser.flags & MD_FLAG_TABLES)  &&  pivot_line->type == MD_LINE_TEXT\n            &&  off < ctx->size  &&  ISANYOF3(off, _T('|'), _T('-'), _T(':'))\n            &&  n_parents == ctx->n_containers)\n        {\n            unsigned col_count;\n\n            if(ctx->current_block != NULL  &&  ctx->current_block->n_lines == 1  &&\n                md_is_table_underline(ctx, off, &off, &col_count))\n            {\n                line->data = col_count;\n                line->type = MD_LINE_TABLEUNDERLINE;\n                break;\n            }\n        }\n\n        /* By default, we are normal text line. */\n        line->type = MD_LINE_TEXT;\n        if(pivot_line->type == MD_LINE_TEXT  &&  n_brothers + n_children == 0) {\n            /* Lazy continuation. */\n            n_parents = ctx->n_containers;\n        }\n\n        /* Check for task mark. */\n        if((ctx->parser.flags & MD_FLAG_TASKLISTS)  &&  n_brothers + n_children > 0  &&\n           ISANYOF_(ctx->containers[ctx->n_containers-1].ch, _T(\"-+*.)\")))\n        {\n            OFF tmp = off;\n\n            while(tmp < ctx->size  &&  tmp < off + 3  &&  ISBLANK(tmp))\n                tmp++;\n            if(tmp + 2 < ctx->size  &&  CH(tmp) == _T('[')  &&\n               ISANYOF(tmp+1, _T(\"xX \"))  &&  CH(tmp+2) == _T(']')  &&\n               (tmp + 3 == ctx->size  ||  ISBLANK(tmp+3)  ||  ISNEWLINE(tmp+3)))\n            {\n                MD_CONTAINER* task_container = (n_children > 0 ? &ctx->containers[ctx->n_containers-1] : &container);\n                task_container->is_task = TRUE;\n                task_container->task_mark_off = tmp + 1;\n                off = tmp + 3;\n                while(ISWHITESPACE(off))\n                    off++;\n                line->beg = off;\n            }\n        }\n\n        break;\n    }\n\n    /* Scan for end of the line.\n     *\n     * Note this is quite a bottleneck of the parsing as we here iterate almost\n     * over compete document.\n     */\n#if defined __linux__ && !defined MD4C_USE_UTF16\n    /* Recent glibc versions have superbly optimized strcspn(), even using\n     * vectorization if available. */\n    if(ctx->doc_ends_with_newline  &&  off < ctx->size) {\n        while(TRUE) {\n            off += (OFF) strcspn(STR(off), \"\\r\\n\");\n\n            /* strcspn() can stop on zero terminator; but that can appear\n             * anywhere in the Markfown input... */\n            if(CH(off) == _T('\\0'))\n                off++;\n            else\n                break;\n        }\n    } else\n#endif\n    {\n        /* Optimization: Use some loop unrolling. */\n        while(off + 3 < ctx->size  &&  !ISNEWLINE(off+0)  &&  !ISNEWLINE(off+1)\n                                   &&  !ISNEWLINE(off+2)  &&  !ISNEWLINE(off+3))\n            off += 4;\n        while(off < ctx->size  &&  !ISNEWLINE(off))\n            off++;\n    }\n\n    /* Set end of the line. */\n    line->end = off;\n\n    /* But for ATX header, we should exclude the optional trailing mark. */\n    if(line->type == MD_LINE_ATXHEADER) {\n        OFF tmp = line->end;\n        while(tmp > line->beg && CH(tmp-1) == _T(' '))\n            tmp--;\n        while(tmp > line->beg && CH(tmp-1) == _T('#'))\n            tmp--;\n        if(tmp == line->beg || CH(tmp-1) == _T(' ') || (ctx->parser.flags & MD_FLAG_PERMISSIVEATXHEADERS))\n            line->end = tmp;\n    }\n\n    /* Trim trailing spaces. */\n    if(line->type != MD_LINE_INDENTEDCODE  &&  line->type != MD_LINE_FENCEDCODE) {\n        while(line->end > line->beg && CH(line->end-1) == _T(' '))\n            line->end--;\n    }\n\n    /* Eat also the new line. */\n    if(off < ctx->size && CH(off) == _T('\\r'))\n        off++;\n    if(off < ctx->size && CH(off) == _T('\\n'))\n        off++;\n\n    *p_end = off;\n\n    /* If we belong to a list after seeing a blank line, the list is loose. */\n    if(prev_line_has_list_loosening_effect  &&  line->type != MD_LINE_BLANK  &&  n_parents + n_brothers > 0) {\n        MD_CONTAINER* c = &ctx->containers[n_parents + n_brothers - 1];\n        if(c->ch != _T('>')) {\n            MD_BLOCK* block = (MD_BLOCK*) (((char*)ctx->block_bytes) + c->block_byte_off);\n            block->flags |= MD_BLOCK_LOOSE_LIST;\n        }\n    }\n\n    /* Leave any containers we are not part of anymore. */\n    if(n_children == 0  &&  n_parents + n_brothers < ctx->n_containers)\n        MD_CHECK(md_leave_child_containers(ctx, n_parents + n_brothers));\n\n    /* Enter any container we found a mark for. */\n    if(n_brothers > 0) {\n        MD_ASSERT(n_brothers == 1);\n        MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI,\n                    ctx->containers[n_parents].task_mark_off,\n                    (ctx->containers[n_parents].is_task ? CH(ctx->containers[n_parents].task_mark_off) : 0),\n                    MD_BLOCK_CONTAINER_CLOSER));\n        MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI,\n                    container.task_mark_off,\n                    (container.is_task ? CH(container.task_mark_off) : 0),\n                    MD_BLOCK_CONTAINER_OPENER));\n        ctx->containers[n_parents].is_task = container.is_task;\n        ctx->containers[n_parents].task_mark_off = container.task_mark_off;\n    }\n\n    if(n_children > 0)\n        MD_CHECK(md_enter_child_containers(ctx, n_children));\n\nabort:\n    return ret;\n}\n\nstatic int\nmd_process_line(MD_CTX* ctx, const MD_LINE_ANALYSIS** p_pivot_line, MD_LINE_ANALYSIS* line)\n{\n    const MD_LINE_ANALYSIS* pivot_line = *p_pivot_line;\n    int ret = 0;\n\n    /* Blank line ends current leaf block. */\n    if(line->type == MD_LINE_BLANK) {\n        MD_CHECK(md_end_current_block(ctx));\n        *p_pivot_line = &md_dummy_blank_line;\n        return 0;\n    }\n\n    /* Some line types form block on their own. */\n    if(line->type == MD_LINE_HR || line->type == MD_LINE_ATXHEADER) {\n        MD_CHECK(md_end_current_block(ctx));\n\n        /* Add our single-line block. */\n        MD_CHECK(md_start_new_block(ctx, line));\n        MD_CHECK(md_add_line_into_current_block(ctx, line));\n        MD_CHECK(md_end_current_block(ctx));\n        *p_pivot_line = &md_dummy_blank_line;\n        return 0;\n    }\n\n    /* MD_LINE_SETEXTUNDERLINE changes meaning of the current block and ends it. */\n    if(line->type == MD_LINE_SETEXTUNDERLINE) {\n        MD_ASSERT(ctx->current_block != NULL);\n        ctx->current_block->type = MD_BLOCK_H;\n        ctx->current_block->data = line->data;\n        ctx->current_block->flags |= MD_BLOCK_SETEXT_HEADER;\n        MD_CHECK(md_add_line_into_current_block(ctx, line));\n        MD_CHECK(md_end_current_block(ctx));\n        if(ctx->current_block == NULL) {\n            *p_pivot_line = &md_dummy_blank_line;\n        } else {\n            /* This happens if we have consumed all the body as link ref. defs.\n             * and downgraded the underline into start of a new paragraph block. */\n            line->type = MD_LINE_TEXT;\n            *p_pivot_line = line;\n        }\n        return 0;\n    }\n\n    /* MD_LINE_TABLEUNDERLINE changes meaning of the current block. */\n    if(line->type == MD_LINE_TABLEUNDERLINE) {\n        MD_ASSERT(ctx->current_block != NULL);\n        MD_ASSERT(ctx->current_block->n_lines == 1);\n        ctx->current_block->type = MD_BLOCK_TABLE;\n        ctx->current_block->data = line->data;\n        MD_ASSERT(pivot_line != &md_dummy_blank_line);\n        ((MD_LINE_ANALYSIS*)pivot_line)->type = MD_LINE_TABLE;\n        MD_CHECK(md_add_line_into_current_block(ctx, line));\n        return 0;\n    }\n\n    /* The current block also ends if the line has different type. */\n    if(line->type != pivot_line->type)\n        MD_CHECK(md_end_current_block(ctx));\n\n    /* The current line may start a new block. */\n    if(ctx->current_block == NULL) {\n        MD_CHECK(md_start_new_block(ctx, line));\n        *p_pivot_line = line;\n    }\n\n    /* In all other cases the line is just a continuation of the current block. */\n    MD_CHECK(md_add_line_into_current_block(ctx, line));\n\nabort:\n    return ret;\n}\n\nstatic int\nmd_process_doc(MD_CTX *ctx)\n{\n    const MD_LINE_ANALYSIS* pivot_line = &md_dummy_blank_line;\n    MD_LINE_ANALYSIS line_buf[2];\n    MD_LINE_ANALYSIS* line = &line_buf[0];\n    OFF off = 0;\n    int ret = 0;\n\n    MD_ENTER_BLOCK(MD_BLOCK_DOC, NULL);\n\n    while(off < ctx->size) {\n        if(line == pivot_line)\n            line = (line == &line_buf[0] ? &line_buf[1] : &line_buf[0]);\n\n        MD_CHECK(md_analyze_line(ctx, off, &off, pivot_line, line));\n        MD_CHECK(md_process_line(ctx, &pivot_line, line));\n    }\n\n    md_end_current_block(ctx);\n\n    MD_CHECK(md_build_ref_def_hashtable(ctx));\n\n    /* Process all blocks. */\n    MD_CHECK(md_leave_child_containers(ctx, 0));\n    MD_CHECK(md_process_all_blocks(ctx));\n\n    MD_LEAVE_BLOCK(MD_BLOCK_DOC, NULL);\n\nabort:\n\n#if 0\n    /* Output some memory consumption statistics. */\n    {\n        char buffer[256];\n        sprintf(buffer, \"Alloced %u bytes for block buffer.\",\n                    (unsigned)(ctx->alloc_block_bytes));\n        MD_LOG(buffer);\n\n        sprintf(buffer, \"Alloced %u bytes for containers buffer.\",\n                    (unsigned)(ctx->alloc_containers * sizeof(MD_CONTAINER)));\n        MD_LOG(buffer);\n\n        sprintf(buffer, \"Alloced %u bytes for marks buffer.\",\n                    (unsigned)(ctx->alloc_marks * sizeof(MD_MARK)));\n        MD_LOG(buffer);\n\n        sprintf(buffer, \"Alloced %u bytes for aux. buffer.\",\n                    (unsigned)(ctx->alloc_buffer * sizeof(MD_CHAR)));\n        MD_LOG(buffer);\n    }\n#endif\n\n    return ret;\n}\n\n\n/********************\n ***  Public API  ***\n ********************/\n\nint\nmd_parse(const MD_CHAR* text, MD_SIZE size, const MD_PARSER* parser, void* userdata)\n{\n    MD_CTX ctx;\n    int i;\n    int ret;\n\n    if(parser->abi_version != 0) {\n        if(parser->debug_log != NULL)\n            parser->debug_log(\"Unsupported abi_version.\", userdata);\n        return -1;\n    }\n\n    /* Setup context structure. */\n    memset(&ctx, 0, sizeof(MD_CTX));\n    ctx.text = text;\n    ctx.size = size;\n    memcpy(&ctx.parser, parser, sizeof(MD_PARSER));\n    ctx.userdata = userdata;\n    ctx.code_indent_offset = (ctx.parser.flags & MD_FLAG_NOINDENTEDCODEBLOCKS) ? (OFF)(-1) : 4;\n    md_build_mark_char_map(&ctx);\n    ctx.doc_ends_with_newline = (size > 0  &&  ISNEWLINE_(text[size-1]));\n\n    /* Reset all unresolved opener mark chains. */\n    for(i = 0; i < (int) SIZEOF_ARRAY(ctx.mark_chains); i++) {\n        ctx.mark_chains[i].head = -1;\n        ctx.mark_chains[i].tail = -1;\n    }\n    ctx.unresolved_link_head = -1;\n    ctx.unresolved_link_tail = -1;\n\n    /* All the work. */\n    ret = md_process_doc(&ctx);\n\n    /* Clean-up. */\n    md_free_ref_defs(&ctx);\n    md_free_ref_def_hashtable(&ctx);\n    free(ctx.buffer);\n    free(ctx.marks);\n    free(ctx.block_bytes);\n    free(ctx.containers);\n\n    return ret;\n}\n"], "filenames": ["CHANGELOG.md", "src/md4c.c"], "buggy_code_start_loc": [22, 5872], "buggy_code_end_loc": [22, 6034], "fixing_code_start_loc": [23, 5872], "fixing_code_end_loc": [26, 6040], "type": "CWE-908", "message": "md_analyze_line in md4c.c in md4c 0.4.7 allows attackers to trigger use of uninitialized memory, and cause a denial of service via a malformed Markdown document.", "other": {"cve": {"id": "CVE-2021-30027", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-29T15:15:11.020", "lastModified": "2021-05-09T01:25:57.167", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "md_analyze_line in md4c.c in md4c 0.4.7 allows attackers to trigger use of uninitialized memory, and cause a denial of service via a malformed Markdown document."}, {"lang": "es", "value": "En la funci\u00f3n md_analyze_line en el archivo md4c.c en md4c versi\u00f3n 0.4.7, permite a atacantes desencadenar el uso de memoria no inicializada y causar una denegaci\u00f3n de servicio por medio de un documento Markdown malformado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-908"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:md4c_project:md4c:0.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "9F8ADD1F-9AB8-41D2-87DD-7A112B44D1CC"}]}]}], "references": [{"url": "https://github.com/mity/md4c/commit/4fc808d8fe8d8904f8525bb4231d854f45e23a19", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mity/md4c/issues/155", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mity/md4c/commit/4fc808d8fe8d8904f8525bb4231d854f45e23a19"}}