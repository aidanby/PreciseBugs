{"buggy_code": ["/**********************************************************************\n  regcomp.c -  Oniguruma (regular expression library)\n**********************************************************************/\n/*-\n * Copyright (c) 2002-2019  K.Kosako  <sndgk393 AT ybb DOT ne DOT jp>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"regparse.h\"\n\n#define OPS_INIT_SIZE  8\n\nOnigCaseFoldType OnigDefaultCaseFoldFlag = ONIGENC_CASE_FOLD_MIN;\n\n#if 0\ntypedef struct {\n  int  n;\n  int  alloc;\n  int* v;\n} int_stack;\n\nstatic int\nmake_int_stack(int_stack** rs, int init_size)\n{\n  int_stack* s;\n  int* v;\n\n  *rs = 0;\n\n  s = xmalloc(sizeof(*s));\n  if (IS_NULL(s)) return ONIGERR_MEMORY;\n\n  v = (int* )xmalloc(sizeof(int) * init_size);\n  if (IS_NULL(v)) {\n    xfree(s);\n    return ONIGERR_MEMORY;\n  }\n\n  s->n = 0;\n  s->alloc = init_size;\n  s->v = v;\n\n  *rs = s;\n  return ONIG_NORMAL;\n}\n\nstatic void\nfree_int_stack(int_stack* s)\n{\n  if (IS_NOT_NULL(s)) {\n    if (IS_NOT_NULL(s->v))\n      xfree(s->v);\n    xfree(s);\n  }\n}\n\nstatic int\nint_stack_push(int_stack* s, int v)\n{\n  if (s->n >= s->alloc) {\n    int new_size = s->alloc * 2;\n    int* nv = (int* )xrealloc(s->v, sizeof(int) * new_size);\n    if (IS_NULL(nv)) return ONIGERR_MEMORY;\n\n    s->alloc = new_size;\n    s->v = nv;\n  }\n\n  s->v[s->n] = v;\n  s->n++;\n  return ONIG_NORMAL;\n}\n\nstatic int\nint_stack_pop(int_stack* s)\n{\n  int v;\n\n#ifdef ONIG_DEBUG\n  if (s->n <= 0) {\n    fprintf(stderr, \"int_stack_pop: fail empty. %p\\n\", s);\n    return 0;\n  }\n#endif\n\n  v = s->v[s->n];\n  s->n--;\n  return v;\n}\n#endif\n\nstatic int\nops_init(regex_t* reg, int init_alloc_size)\n{\n  Operation* p;\n  size_t size;\n\n  if (init_alloc_size > 0) {\n    size = sizeof(Operation) * init_alloc_size;\n    p = (Operation* )xrealloc(reg->ops, size);\n    CHECK_NULL_RETURN_MEMERR(p);\n#ifdef USE_DIRECT_THREADED_CODE\n    {\n      enum OpCode* cp;\n      size = sizeof(enum OpCode) * init_alloc_size;\n      cp = (enum OpCode* )xrealloc(reg->ocs, size);\n      CHECK_NULL_RETURN_MEMERR(cp);\n      reg->ocs = cp;\n    }\n#endif\n  }\n  else {\n    p  = (Operation* )0;\n#ifdef USE_DIRECT_THREADED_CODE\n    reg->ocs = (enum OpCode* )0;\n#endif\n  }\n\n  reg->ops = p;\n  reg->ops_curr  = 0; /* !!! not yet done ops_new() */\n  reg->ops_alloc = init_alloc_size;\n  reg->ops_used  = 0;\n\n  return ONIG_NORMAL;\n}\n\nstatic int\nops_expand(regex_t* reg, int n)\n{\n#define MIN_OPS_EXPAND_SIZE   4\n\n#ifdef USE_DIRECT_THREADED_CODE\n  enum OpCode* cp;\n#endif\n  Operation* p;\n  size_t size;\n\n  if (n <= 0) n = MIN_OPS_EXPAND_SIZE;\n\n  n += reg->ops_alloc;\n\n  size = sizeof(Operation) * n;\n  p = (Operation* )xrealloc(reg->ops, size);\n  CHECK_NULL_RETURN_MEMERR(p);\n\n#ifdef USE_DIRECT_THREADED_CODE\n  size = sizeof(enum OpCode) * n;\n  cp = (enum OpCode* )xrealloc(reg->ocs, size);\n  CHECK_NULL_RETURN_MEMERR(cp);\n  reg->ocs = cp;\n#endif\n\n  reg->ops = p;\n  reg->ops_alloc = n;\n  if (reg->ops_used == 0)\n    reg->ops_curr = 0;\n  else\n    reg->ops_curr = reg->ops + (reg->ops_used - 1);\n\n  return ONIG_NORMAL;\n}\n\nstatic int\nops_new(regex_t* reg)\n{\n  int r;\n\n  if (reg->ops_used >= reg->ops_alloc) {\n    r = ops_expand(reg, reg->ops_alloc);\n    if (r != ONIG_NORMAL) return r;\n  }\n\n  reg->ops_curr = reg->ops + reg->ops_used;\n  reg->ops_used++;\n\n  xmemset(reg->ops_curr, 0, sizeof(Operation));\n  return ONIG_NORMAL;\n}\n\nstatic int\nis_in_string_pool(regex_t* reg, UChar* s)\n{\n  return (s >= reg->string_pool && s < reg->string_pool_end);\n}\n\nstatic void\nops_free(regex_t* reg)\n{\n  int i;\n\n  if (IS_NULL(reg->ops)) return ;\n\n  for (i = 0; i < (int )reg->ops_used; i++) {\n    enum OpCode opcode;\n    Operation* op;\n\n    op = reg->ops + i;\n\n#ifdef USE_DIRECT_THREADED_CODE\n    opcode = *(reg->ocs + i);\n#else\n    opcode = op->opcode;\n#endif\n\n    switch (opcode) {\n    case OP_EXACTMBN:\n      if (! is_in_string_pool(reg, op->exact_len_n.s))\n        xfree(op->exact_len_n.s);\n      break;\n    case OP_EXACTN: case OP_EXACTMB2N: case OP_EXACTMB3N: case OP_EXACTN_IC:\n      if (! is_in_string_pool(reg, op->exact_n.s))\n        xfree(op->exact_n.s);\n      break;\n    case OP_EXACT1: case OP_EXACT2: case OP_EXACT3: case OP_EXACT4:\n    case OP_EXACT5: case OP_EXACTMB2N1: case OP_EXACTMB2N2:\n    case OP_EXACTMB2N3: case OP_EXACT1_IC:\n      break;\n\n    case OP_CCLASS_NOT: case OP_CCLASS:\n      xfree(op->cclass.bsp);\n      break;\n\n    case OP_CCLASS_MB_NOT: case OP_CCLASS_MB:\n      xfree(op->cclass_mb.mb);\n      break;\n    case OP_CCLASS_MIX_NOT: case OP_CCLASS_MIX:\n      xfree(op->cclass_mix.mb);\n      xfree(op->cclass_mix.bsp);\n      break;\n\n    case OP_BACKREF1: case OP_BACKREF2: case OP_BACKREF_N: case OP_BACKREF_N_IC:\n      break;\n    case OP_BACKREF_MULTI:      case OP_BACKREF_MULTI_IC:\n    case OP_BACKREF_WITH_LEVEL:\n    case OP_BACKREF_WITH_LEVEL_IC:\n    case OP_BACKREF_CHECK:\n    case OP_BACKREF_CHECK_WITH_LEVEL:\n      if (op->backref_general.num != 1)\n        xfree(op->backref_general.ns);\n      break;\n\n    default:\n      break;\n    }\n  }\n\n  xfree(reg->ops);\n#ifdef USE_DIRECT_THREADED_CODE\n  xfree(reg->ocs);\n  reg->ocs = 0;\n#endif\n\n  reg->ops = 0;\n  reg->ops_curr  = 0;\n  reg->ops_alloc = 0;\n  reg->ops_used  = 0;\n}\n\nstatic int\nops_calc_size_of_string_pool(regex_t* reg)\n{\n  int i;\n  int total;\n\n  if (IS_NULL(reg->ops)) return 0;\n\n  total = 0;\n  for (i = 0; i < (int )reg->ops_used; i++) {\n    enum OpCode opcode;\n    Operation* op;\n\n    op = reg->ops + i;\n#ifdef USE_DIRECT_THREADED_CODE\n    opcode = *(reg->ocs + i);\n#else\n    opcode = op->opcode;\n#endif\n\n    switch (opcode) {\n    case OP_EXACTMBN:\n      total += op->exact_len_n.len * op->exact_len_n.n;\n      break;\n    case OP_EXACTN:\n    case OP_EXACTN_IC:\n      total += op->exact_n.n;\n      break;\n    case OP_EXACTMB2N:\n      total += op->exact_n.n * 2;\n      break;\n    case OP_EXACTMB3N:\n      total += op->exact_n.n * 3;\n      break;\n\n    default:\n      break;\n    }\n  }\n\n  return total;\n}\n\nstatic int\nops_make_string_pool(regex_t* reg)\n{\n  int i;\n  int len;\n  int size;\n  UChar* pool;\n  UChar* curr;\n\n  size = ops_calc_size_of_string_pool(reg);\n  if (size <= 0) {\n    return 0;\n  }\n\n  curr = pool = (UChar* )xmalloc((size_t )size);\n  CHECK_NULL_RETURN_MEMERR(pool);\n\n  for (i = 0; i < (int )reg->ops_used; i++) {\n    enum OpCode opcode;\n    Operation* op;\n\n    op = reg->ops + i;\n#ifdef USE_DIRECT_THREADED_CODE\n    opcode = *(reg->ocs + i);\n#else\n    opcode = op->opcode;\n#endif\n\n    switch (opcode) {\n    case OP_EXACTMBN:\n      len = op->exact_len_n.len * op->exact_len_n.n;\n      xmemcpy(curr, op->exact_len_n.s, len);\n      xfree(op->exact_len_n.s);\n      op->exact_len_n.s = curr;\n      curr += len;\n      break;\n    case OP_EXACTN:\n    case OP_EXACTN_IC:\n      len = op->exact_n.n;\n    copy:\n      xmemcpy(curr, op->exact_n.s, len);\n      xfree(op->exact_n.s);\n      op->exact_n.s = curr;\n      curr += len;\n      break;\n    case OP_EXACTMB2N:\n      len = op->exact_n.n * 2;\n      goto copy;\n      break;\n    case OP_EXACTMB3N:\n      len = op->exact_n.n * 3;\n      goto copy;\n      break;\n\n    default:\n      break;\n    }\n  }\n\n  reg->string_pool     = pool;\n  reg->string_pool_end = pool + size;\n  return 0;\n}\n\nextern OnigCaseFoldType\nonig_get_default_case_fold_flag(void)\n{\n  return OnigDefaultCaseFoldFlag;\n}\n\nextern int\nonig_set_default_case_fold_flag(OnigCaseFoldType case_fold_flag)\n{\n  OnigDefaultCaseFoldFlag = case_fold_flag;\n  return 0;\n}\n\nstatic int\nint_multiply_cmp(int x, int y, int v)\n{\n  if (x == 0 || y == 0) return -1;\n\n  if (x < INT_MAX / y) {\n    int xy = x * y;\n    if (xy > v) return 1;\n    else {\n      if (xy == v) return 0;\n      else return -1;\n    }\n  }\n  else\n    return 1;\n}\n\nextern int\nonig_positive_int_multiply(int x, int y)\n{\n  if (x == 0 || y == 0) return 0;\n\n  if (x < INT_MAX / y)\n    return x * y;\n  else\n    return -1;\n}\n\n\nstatic void\nswap_node(Node* a, Node* b)\n{\n  Node c;\n\n  c = *a; *a = *b; *b = c;\n\n  if (NODE_TYPE(a) == NODE_STRING) {\n    StrNode* sn = STR_(a);\n    if (sn->capacity == 0) {\n      int len = (int )(sn->end - sn->s);\n      sn->s   = sn->buf;\n      sn->end = sn->s + len;\n    }\n  }\n\n  if (NODE_TYPE(b) == NODE_STRING) {\n    StrNode* sn = STR_(b);\n    if (sn->capacity == 0) {\n      int len = (int )(sn->end - sn->s);\n      sn->s   = sn->buf;\n      sn->end = sn->s + len;\n    }\n  }\n}\n\nstatic OnigLen\ndistance_add(OnigLen d1, OnigLen d2)\n{\n  if (d1 == INFINITE_LEN || d2 == INFINITE_LEN)\n    return INFINITE_LEN;\n  else {\n    if (d1 <= INFINITE_LEN - d2) return d1 + d2;\n    else return INFINITE_LEN;\n  }\n}\n\nstatic OnigLen\ndistance_multiply(OnigLen d, int m)\n{\n  if (m == 0) return 0;\n\n  if (d < INFINITE_LEN / m)\n    return d * m;\n  else\n    return INFINITE_LEN;\n}\n\nstatic int\nbitset_is_empty(BitSetRef bs)\n{\n  int i;\n\n  for (i = 0; i < (int )BITSET_SIZE; i++) {\n    if (bs[i] != 0) return 0;\n  }\n  return 1;\n}\n\n#ifdef USE_CALL\n\nstatic int\nunset_addr_list_init(UnsetAddrList* list, int size)\n{\n  UnsetAddr* p = (UnsetAddr* )xmalloc(sizeof(UnsetAddr)* size);\n  CHECK_NULL_RETURN_MEMERR(p);\n\n  list->num   = 0;\n  list->alloc = size;\n  list->us    = p;\n  return 0;\n}\n\nstatic void\nunset_addr_list_end(UnsetAddrList* list)\n{\n  if (IS_NOT_NULL(list->us))\n    xfree(list->us);\n}\n\nstatic int\nunset_addr_list_add(UnsetAddrList* list, int offset, struct _Node* node)\n{\n  UnsetAddr* p;\n  int size;\n\n  if (list->num >= list->alloc) {\n    size = list->alloc * 2;\n    p = (UnsetAddr* )xrealloc(list->us, sizeof(UnsetAddr) * size);\n    CHECK_NULL_RETURN_MEMERR(p);\n    list->alloc = size;\n    list->us    = p;\n  }\n\n  list->us[list->num].offset = offset;\n  list->us[list->num].target = node;\n  list->num++;\n  return 0;\n}\n#endif /* USE_CALL */\n\n\nstatic int\nadd_op(regex_t* reg, int opcode)\n{\n  int r;\n\n  r = ops_new(reg);\n  if (r != ONIG_NORMAL) return r;\n\n#ifdef USE_DIRECT_THREADED_CODE\n  *(reg->ocs + (reg->ops_curr - reg->ops)) = opcode;\n#else\n  reg->ops_curr->opcode = opcode;\n#endif\n\n  return 0;\n}\n\nstatic int compile_length_tree(Node* node, regex_t* reg);\nstatic int compile_tree(Node* node, regex_t* reg, ScanEnv* env);\n\n\n#define IS_NEED_STR_LEN_OP_EXACT(op) \\\n   ((op) == OP_EXACTN    || (op) == OP_EXACTMB2N ||\\\n    (op) == OP_EXACTMB3N || (op) == OP_EXACTMBN  || (op) == OP_EXACTN_IC)\n\nstatic int\nselect_str_opcode(int mb_len, int str_len, int ignore_case)\n{\n  int op;\n\n  if (ignore_case) {\n    switch (str_len) {\n    case 1:  op = OP_EXACT1_IC; break;\n    default: op = OP_EXACTN_IC; break;\n    }\n  }\n  else {\n    switch (mb_len) {\n    case 1:\n      switch (str_len) {\n      case 1:  op = OP_EXACT1; break;\n      case 2:  op = OP_EXACT2; break;\n      case 3:  op = OP_EXACT3; break;\n      case 4:  op = OP_EXACT4; break;\n      case 5:  op = OP_EXACT5; break;\n      default: op = OP_EXACTN; break;\n      }\n      break;\n\n    case 2:\n      switch (str_len) {\n      case 1:  op = OP_EXACTMB2N1; break;\n      case 2:  op = OP_EXACTMB2N2; break;\n      case 3:  op = OP_EXACTMB2N3; break;\n      default: op = OP_EXACTMB2N;  break;\n      }\n      break;\n\n    case 3:\n      op = OP_EXACTMB3N;\n      break;\n\n    default:\n      op = OP_EXACTMBN;\n      break;\n    }\n  }\n  return op;\n}\n\nstatic int\ncompile_tree_empty_check(Node* node, regex_t* reg, int empty_info, ScanEnv* env)\n{\n  int r;\n  int saved_num_null_check = reg->num_null_check;\n\n  if (empty_info != BODY_IS_NOT_EMPTY) {\n    r = add_op(reg, OP_EMPTY_CHECK_START);\n    if (r != 0) return r;\n    COP(reg)->empty_check_start.mem = reg->num_null_check; /* NULL CHECK ID */\n    reg->num_null_check++;\n  }\n\n  r = compile_tree(node, reg, env);\n  if (r != 0) return r;\n\n  if (empty_info != BODY_IS_NOT_EMPTY) {\n    if (empty_info == BODY_IS_EMPTY)\n      r = add_op(reg, OP_EMPTY_CHECK_END);\n    else if (empty_info == BODY_IS_EMPTY_MEM)\n      r = add_op(reg, OP_EMPTY_CHECK_END_MEMST);\n    else if (empty_info == BODY_IS_EMPTY_REC)\n      r = add_op(reg, OP_EMPTY_CHECK_END_MEMST_PUSH);\n\n    if (r != 0) return r;\n    COP(reg)->empty_check_end.mem = saved_num_null_check; /* NULL CHECK ID */\n  }\n  return r;\n}\n\n#ifdef USE_CALL\nstatic int\ncompile_call(CallNode* node, regex_t* reg, ScanEnv* env)\n{\n  int r;\n  int offset;\n\n  r = add_op(reg, OP_CALL);\n  if (r != 0) return r;\n\n  COP(reg)->call.addr = 0; /* dummy addr. */\n\n  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);\n  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));\n  return r;\n}\n#endif\n\nstatic int\ncompile_tree_n_times(Node* node, int n, regex_t* reg, ScanEnv* env)\n{\n  int i, r;\n\n  for (i = 0; i < n; i++) {\n    r = compile_tree(node, reg, env);\n    if (r != 0) return r;\n  }\n  return 0;\n}\n\nstatic int\nadd_compile_string_length(UChar* s ARG_UNUSED, int mb_len, int str_len,\n                          regex_t* reg ARG_UNUSED, int ignore_case)\n{\n  return 1;\n}\n\nstatic int\nadd_compile_string(UChar* s, int mb_len, int str_len,\n                   regex_t* reg, int ignore_case)\n{\n  int op;\n  int r;\n  int byte_len;\n  UChar* p;\n  UChar* end;\n\n  op = select_str_opcode(mb_len, str_len, ignore_case);\n  r = add_op(reg, op);\n  if (r != 0) return r;\n\n  byte_len = mb_len * str_len;\n  end = s + byte_len;\n\n  if (op == OP_EXACTMBN) {\n    p = onigenc_strdup(reg->enc, s, end);\n    CHECK_NULL_RETURN_MEMERR(p);\n\n    COP(reg)->exact_len_n.len = mb_len;\n    COP(reg)->exact_len_n.n   = str_len;\n    COP(reg)->exact_len_n.s   = p;\n  }\n  else if (IS_NEED_STR_LEN_OP_EXACT(op)) {\n    p = onigenc_strdup(reg->enc, s, end);\n    CHECK_NULL_RETURN_MEMERR(p);\n\n    if (op == OP_EXACTN_IC)\n      COP(reg)->exact_n.n = byte_len;\n    else\n      COP(reg)->exact_n.n = str_len;\n\n    COP(reg)->exact_n.s = p;\n  }\n  else {\n    xmemcpy(COP(reg)->exact.s, s, (size_t )byte_len);\n    COP(reg)->exact.s[byte_len] = '\\0';\n  }\n\n  return 0;\n}\n\nstatic int\ncompile_length_string_node(Node* node, regex_t* reg)\n{\n  int rlen, r, len, prev_len, slen, ambig;\n  UChar *p, *prev;\n  StrNode* sn;\n  OnigEncoding enc = reg->enc;\n\n  sn = STR_(node);\n  if (sn->end <= sn->s)\n    return 0;\n\n  ambig = NODE_STRING_IS_AMBIG(node);\n\n  p = prev = sn->s;\n  prev_len = enclen(enc, p);\n  p += prev_len;\n  slen = 1;\n  rlen = 0;\n\n  for (; p < sn->end; ) {\n    len = enclen(enc, p);\n    if (len == prev_len) {\n      slen++;\n    }\n    else {\n      r = add_compile_string_length(prev, prev_len, slen, reg, ambig);\n      rlen += r;\n      prev = p;\n      slen = 1;\n      prev_len = len;\n    }\n    p += len;\n  }\n\n  r = add_compile_string_length(prev, prev_len, slen, reg, ambig);\n  rlen += r;\n  return rlen;\n}\n\nstatic int\ncompile_length_string_raw_node(StrNode* sn, regex_t* reg)\n{\n  if (sn->end <= sn->s)\n    return 0;\n\n  return add_compile_string_length(sn->s, 1 /* sb */, (int )(sn->end - sn->s),\n                                   reg, 0);\n}\n\nstatic int\ncompile_string_node(Node* node, regex_t* reg)\n{\n  int r, len, prev_len, slen, ambig;\n  UChar *p, *prev, *end;\n  StrNode* sn;\n  OnigEncoding enc = reg->enc;\n\n  sn = STR_(node);\n  if (sn->end <= sn->s)\n    return 0;\n\n  end = sn->end;\n  ambig = NODE_STRING_IS_AMBIG(node);\n\n  p = prev = sn->s;\n  prev_len = enclen(enc, p);\n  p += prev_len;\n  slen = 1;\n\n  for (; p < end; ) {\n    len = enclen(enc, p);\n    if (len == prev_len) {\n      slen++;\n    }\n    else {\n      r = add_compile_string(prev, prev_len, slen, reg, ambig);\n      if (r != 0) return r;\n\n      prev  = p;\n      slen  = 1;\n      prev_len = len;\n    }\n\n    p += len;\n  }\n\n  return add_compile_string(prev, prev_len, slen, reg, ambig);\n}\n\nstatic int\ncompile_string_raw_node(StrNode* sn, regex_t* reg)\n{\n  if (sn->end <= sn->s)\n    return 0;\n\n  return add_compile_string(sn->s, 1 /* sb */, (int )(sn->end - sn->s), reg, 0);\n}\n\nstatic void*\nset_multi_byte_cclass(BBuf* mbuf, regex_t* reg)\n{\n  size_t len;\n  void* p;\n\n  len = (size_t )mbuf->used;\n  p = xmalloc(len);\n  if (IS_NULL(p)) return NULL;\n\n  xmemcpy(p, mbuf->p, len);\n  return p;\n}\n\nstatic int\ncompile_length_cclass_node(CClassNode* cc, regex_t* reg)\n{\n  return 1;\n}\n\nstatic int\ncompile_cclass_node(CClassNode* cc, regex_t* reg)\n{\n  int r;\n\n  if (IS_NULL(cc->mbuf)) {\n    r = add_op(reg, IS_NCCLASS_NOT(cc) ? OP_CCLASS_NOT : OP_CCLASS);\n    if (r != 0) return r;\n\n    COP(reg)->cclass.bsp = xmalloc(SIZE_BITSET);\n    CHECK_NULL_RETURN_MEMERR(COP(reg)->cclass.bsp);\n    xmemcpy(COP(reg)->cclass.bsp, cc->bs, SIZE_BITSET);\n  }\n  else {\n    void* p;\n\n    if (ONIGENC_MBC_MINLEN(reg->enc) > 1 || bitset_is_empty(cc->bs)) {\n      r = add_op(reg, IS_NCCLASS_NOT(cc) ? OP_CCLASS_MB_NOT : OP_CCLASS_MB);\n      if (r != 0) return r;\n\n      p = set_multi_byte_cclass(cc->mbuf, reg);\n      CHECK_NULL_RETURN_MEMERR(p);\n      COP(reg)->cclass_mb.mb = p;\n    }\n    else {\n      r = add_op(reg, IS_NCCLASS_NOT(cc) ? OP_CCLASS_MIX_NOT : OP_CCLASS_MIX);\n      if (r != 0) return r;\n\n      COP(reg)->cclass_mix.bsp = xmalloc(SIZE_BITSET);\n      CHECK_NULL_RETURN_MEMERR(COP(reg)->cclass_mix.bsp);\n      xmemcpy(COP(reg)->cclass_mix.bsp, cc->bs, SIZE_BITSET);\n\n      p = set_multi_byte_cclass(cc->mbuf, reg);\n      CHECK_NULL_RETURN_MEMERR(p);\n      COP(reg)->cclass_mix.mb = p;\n    }\n  }\n\n  return 0;\n}\n\nstatic int\nentry_repeat_range(regex_t* reg, int id, int lower, int upper)\n{\n#define REPEAT_RANGE_ALLOC  4\n\n  OnigRepeatRange* p;\n\n  if (reg->repeat_range_alloc == 0) {\n    p = (OnigRepeatRange* )xmalloc(sizeof(OnigRepeatRange) * REPEAT_RANGE_ALLOC);\n    CHECK_NULL_RETURN_MEMERR(p);\n    reg->repeat_range = p;\n    reg->repeat_range_alloc = REPEAT_RANGE_ALLOC;\n  }\n  else if (reg->repeat_range_alloc <= id) {\n    int n;\n    n = reg->repeat_range_alloc + REPEAT_RANGE_ALLOC;\n    p = (OnigRepeatRange* )xrealloc(reg->repeat_range, sizeof(OnigRepeatRange) * n);\n    CHECK_NULL_RETURN_MEMERR(p);\n    reg->repeat_range = p;\n    reg->repeat_range_alloc = n;\n  }\n  else {\n    p = reg->repeat_range;\n  }\n\n  p[id].lower = lower;\n  p[id].upper = (IS_REPEAT_INFINITE(upper) ? 0x7fffffff : upper);\n  return 0;\n}\n\nstatic int\ncompile_range_repeat_node(QuantNode* qn, int target_len, int empty_info,\n                          regex_t* reg, ScanEnv* env)\n{\n  int r;\n  int num_repeat = reg->num_repeat++;\n\n  r = add_op(reg, qn->greedy ? OP_REPEAT : OP_REPEAT_NG);\n  if (r != 0) return r;\n\n  COP(reg)->repeat.id   = num_repeat;\n  COP(reg)->repeat.addr = SIZE_INC_OP + target_len + SIZE_OP_REPEAT_INC;\n\n  r = entry_repeat_range(reg, num_repeat, qn->lower, qn->upper);\n  if (r != 0) return r;\n\n  r = compile_tree_empty_check(NODE_QUANT_BODY(qn), reg, empty_info, env);\n  if (r != 0) return r;\n\n  if (\n#ifdef USE_CALL\n      NODE_IS_IN_MULTI_ENTRY(qn) ||\n#endif\n      NODE_IS_IN_REAL_REPEAT(qn)) {\n    r = add_op(reg, qn->greedy ? OP_REPEAT_INC_SG : OP_REPEAT_INC_NG_SG);\n  }\n  else {\n    r = add_op(reg, qn->greedy ? OP_REPEAT_INC : OP_REPEAT_INC_NG);\n  }\n  if (r != 0) return r;\n\n  COP(reg)->repeat_inc.id = num_repeat;\n  return r;\n}\n\nstatic int\nis_anychar_infinite_greedy(QuantNode* qn)\n{\n  if (qn->greedy && IS_REPEAT_INFINITE(qn->upper) &&\n      NODE_IS_ANYCHAR(NODE_QUANT_BODY(qn)))\n    return 1;\n  else\n    return 0;\n}\n\n#define QUANTIFIER_EXPAND_LIMIT_SIZE   10\n#define CKN_ON   (ckn > 0)\n\nstatic int\ncompile_length_quantifier_node(QuantNode* qn, regex_t* reg)\n{\n  int len, mod_tlen;\n  int infinite = IS_REPEAT_INFINITE(qn->upper);\n  enum BodyEmpty empty_info = qn->empty_info;\n  int tlen = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n\n  if (tlen < 0) return tlen;\n  if (tlen == 0) return 0;\n\n  /* anychar repeat */\n  if (is_anychar_infinite_greedy(qn)) {\n    if (qn->lower <= 1 ||\n        int_multiply_cmp(tlen, qn->lower, QUANTIFIER_EXPAND_LIMIT_SIZE) <= 0) {\n      if (IS_NOT_NULL(qn->next_head_exact))\n        return SIZE_OP_ANYCHAR_STAR_PEEK_NEXT + tlen * qn->lower;\n      else\n        return SIZE_OP_ANYCHAR_STAR + tlen * qn->lower;\n    }\n  }\n\n  if (empty_info == BODY_IS_NOT_EMPTY)\n    mod_tlen = tlen;\n  else\n    mod_tlen = tlen + (SIZE_OP_EMPTY_CHECK_START + SIZE_OP_EMPTY_CHECK_END);\n\n  if (infinite &&\n      (qn->lower <= 1 ||\n       int_multiply_cmp(tlen, qn->lower, QUANTIFIER_EXPAND_LIMIT_SIZE) <= 0)) {\n    if (qn->lower == 1 && tlen > QUANTIFIER_EXPAND_LIMIT_SIZE) {\n      len = SIZE_OP_JUMP;\n    }\n    else {\n      len = tlen * qn->lower;\n    }\n\n    if (qn->greedy) {\n#ifdef USE_OP_PUSH_OR_JUMP_EXACT\n      if (IS_NOT_NULL(qn->head_exact))\n        len += SIZE_OP_PUSH_OR_JUMP_EXACT1 + mod_tlen + SIZE_OP_JUMP;\n      else\n#endif\n      if (IS_NOT_NULL(qn->next_head_exact))\n        len += SIZE_OP_PUSH_IF_PEEK_NEXT + mod_tlen + SIZE_OP_JUMP;\n      else\n        len += SIZE_OP_PUSH + mod_tlen + SIZE_OP_JUMP;\n    }\n    else\n      len += SIZE_OP_JUMP + mod_tlen + SIZE_OP_PUSH;\n  }\n  else if (qn->upper == 0) {\n    if (qn->is_refered != 0) { /* /(?<n>..){0}/ */\n      len = SIZE_OP_JUMP + tlen;\n    }\n    else\n      len = 0;\n  }\n  else if (!infinite && qn->greedy &&\n           (qn->upper == 1 ||\n            int_multiply_cmp(tlen + SIZE_OP_PUSH, qn->upper,\n                             QUANTIFIER_EXPAND_LIMIT_SIZE) <= 0)) {\n    len = tlen * qn->lower;\n    len += (SIZE_OP_PUSH + tlen) * (qn->upper - qn->lower);\n  }\n  else if (!qn->greedy && qn->upper == 1 && qn->lower == 0) { /* '??' */\n    len = SIZE_OP_PUSH + SIZE_OP_JUMP + tlen;\n  }\n  else {\n    len = SIZE_OP_REPEAT_INC + mod_tlen + SIZE_OP_REPEAT;\n  }\n\n  return len;\n}\n\nstatic int\ncompile_quantifier_node(QuantNode* qn, regex_t* reg, ScanEnv* env)\n{\n  int i, r, mod_tlen;\n  int infinite = IS_REPEAT_INFINITE(qn->upper);\n  enum BodyEmpty empty_info = qn->empty_info;\n  int tlen = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n\n  if (tlen < 0) return tlen;\n  if (tlen == 0) return 0;\n\n  if (is_anychar_infinite_greedy(qn) &&\n      (qn->lower <= 1 ||\n       int_multiply_cmp(tlen, qn->lower, QUANTIFIER_EXPAND_LIMIT_SIZE) <= 0)) {\n    r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);\n    if (r != 0) return r;\n    if (IS_NOT_NULL(qn->next_head_exact)) {\n      r = add_op(reg,\n                 IS_MULTILINE(CTYPE_OPTION(NODE_QUANT_BODY(qn), reg)) ?\n                 OP_ANYCHAR_ML_STAR_PEEK_NEXT : OP_ANYCHAR_STAR_PEEK_NEXT);\n      if (r != 0) return r;\n\n      COP(reg)->anychar_star_peek_next.c = STR_(qn->next_head_exact)->s[0];\n      return 0;\n    }\n    else {\n      r = add_op(reg,\n                 IS_MULTILINE(CTYPE_OPTION(NODE_QUANT_BODY(qn), reg)) ?\n                 OP_ANYCHAR_ML_STAR : OP_ANYCHAR_STAR);\n      return r;\n    }\n  }\n\n  if (empty_info == BODY_IS_NOT_EMPTY)\n    mod_tlen = tlen;\n  else\n    mod_tlen = tlen + (SIZE_OP_EMPTY_CHECK_START + SIZE_OP_EMPTY_CHECK_END);\n\n  if (infinite &&\n      (qn->lower <= 1 ||\n       int_multiply_cmp(tlen, qn->lower, QUANTIFIER_EXPAND_LIMIT_SIZE) <= 0)) {\n    int addr;\n\n    if (qn->lower == 1 && tlen > QUANTIFIER_EXPAND_LIMIT_SIZE) {\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      if (qn->greedy) {\n#ifdef USE_OP_PUSH_OR_JUMP_EXACT\n        if (IS_NOT_NULL(qn->head_exact))\n          COP(reg)->jump.addr = SIZE_OP_PUSH_OR_JUMP_EXACT1 + SIZE_INC_OP;\n        else\n#endif\n        if (IS_NOT_NULL(qn->next_head_exact))\n          COP(reg)->jump.addr = SIZE_OP_PUSH_IF_PEEK_NEXT + SIZE_INC_OP;\n        else\n          COP(reg)->jump.addr = SIZE_OP_PUSH + SIZE_INC_OP;\n      }\n      else {\n        COP(reg)->jump.addr = SIZE_OP_JUMP + SIZE_INC_OP;\n      }\n    }\n    else {\n      r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);\n      if (r != 0) return r;\n    }\n\n    if (qn->greedy) {\n#ifdef USE_OP_PUSH_OR_JUMP_EXACT\n      if (IS_NOT_NULL(qn->head_exact)) {\n        r = add_op(reg, OP_PUSH_OR_JUMP_EXACT1);\n        if (r != 0) return r;\n        COP(reg)->push_or_jump_exact1.addr = SIZE_INC_OP + mod_tlen + SIZE_OP_JUMP;\n        COP(reg)->push_or_jump_exact1.c    = STR_(qn->head_exact)->s[0];\n\n        r = compile_tree_empty_check(NODE_QUANT_BODY(qn), reg, empty_info, env);\n        if (r != 0) return r;\n\n        addr = -(mod_tlen + (int )SIZE_OP_PUSH_OR_JUMP_EXACT1);\n      }\n      else\n#endif\n      if (IS_NOT_NULL(qn->next_head_exact)) {\n        r = add_op(reg, OP_PUSH_IF_PEEK_NEXT);\n        if (r != 0) return r;\n        COP(reg)->push_if_peek_next.addr = SIZE_INC_OP + mod_tlen + SIZE_OP_JUMP;\n        COP(reg)->push_if_peek_next.c    = STR_(qn->next_head_exact)->s[0];\n\n        r = compile_tree_empty_check(NODE_QUANT_BODY(qn), reg, empty_info, env);\n        if (r != 0) return r;\n\n        addr = -(mod_tlen + (int )SIZE_OP_PUSH_IF_PEEK_NEXT);\n      }\n      else {\n        r = add_op(reg, OP_PUSH);\n        if (r != 0) return r;\n        COP(reg)->push.addr = SIZE_INC_OP + mod_tlen + SIZE_OP_JUMP;\n\n        r = compile_tree_empty_check(NODE_QUANT_BODY(qn), reg, empty_info, env);\n        if (r != 0) return r;\n\n        addr = -(mod_tlen + (int )SIZE_OP_PUSH);\n      }\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = addr;\n    }\n    else {\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = mod_tlen + SIZE_INC_OP;\n\n      r = compile_tree_empty_check(NODE_QUANT_BODY(qn), reg, empty_info, env);\n      if (r != 0) return r;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = -mod_tlen;\n    }\n  }\n  else if (qn->upper == 0) {\n    if (qn->is_refered != 0) { /* /(?<n>..){0}/ */\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = tlen + SIZE_INC_OP;\n\n      r = compile_tree(NODE_QUANT_BODY(qn), reg, env);\n    }\n    else {\n      /* Nothing output */\n      r = 0;\n    }\n  }\n  else if (! infinite && qn->greedy &&\n           (qn->upper == 1 ||\n            int_multiply_cmp(tlen + SIZE_OP_PUSH, qn->upper,\n                             QUANTIFIER_EXPAND_LIMIT_SIZE) <= 0)) {\n    int n = qn->upper - qn->lower;\n\n    r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);\n    if (r != 0) return r;\n\n    for (i = 0; i < n; i++) {\n      int v = onig_positive_int_multiply(n - i, tlen + SIZE_OP_PUSH);\n      if (v < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = v;\n\n      r = compile_tree(NODE_QUANT_BODY(qn), reg, env);\n      if (r != 0) return r;\n    }\n  }\n  else if (! qn->greedy && qn->upper == 1 && qn->lower == 0) { /* '??' */\n    r = add_op(reg, OP_PUSH);\n    if (r != 0) return r;\n    COP(reg)->push.addr = SIZE_INC_OP + SIZE_OP_JUMP;\n\n    r = add_op(reg, OP_JUMP);\n    if (r != 0) return r;\n    COP(reg)->jump.addr = tlen + SIZE_INC_OP;\n\n    r = compile_tree(NODE_QUANT_BODY(qn), reg, env);\n  }\n  else {\n    r = compile_range_repeat_node(qn, mod_tlen, empty_info, reg, env);\n  }\n  return r;\n}\n\nstatic int\ncompile_length_option_node(BagNode* node, regex_t* reg)\n{\n  int tlen;\n  OnigOptionType prev = reg->options;\n\n  reg->options = node->o.options;\n  tlen = compile_length_tree(NODE_BAG_BODY(node), reg);\n  reg->options = prev;\n\n  return tlen;\n}\n\nstatic int\ncompile_option_node(BagNode* node, regex_t* reg, ScanEnv* env)\n{\n  int r;\n  OnigOptionType prev = reg->options;\n\n  reg->options = node->o.options;\n  r = compile_tree(NODE_BAG_BODY(node), reg, env);\n  reg->options = prev;\n\n  return r;\n}\n\nstatic int\ncompile_length_bag_node(BagNode* node, regex_t* reg)\n{\n  int len;\n  int tlen;\n\n  if (node->type == BAG_OPTION)\n    return compile_length_option_node(node, reg);\n\n  if (NODE_BAG_BODY(node)) {\n    tlen = compile_length_tree(NODE_BAG_BODY(node), reg);\n    if (tlen < 0) return tlen;\n  }\n  else\n    tlen = 0;\n\n  switch (node->type) {\n  case BAG_MEMORY:\n#ifdef USE_CALL\n\n    if (node->m.regnum == 0 && NODE_IS_CALLED(node)) {\n      len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;\n      return len;\n    }\n\n    if (NODE_IS_CALLED(node)) {\n      len = SIZE_OP_MEMORY_START_PUSH + tlen\n        + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;\n      if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))\n        len += (NODE_IS_RECURSION(node)\n                ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH);\n      else\n        len += (NODE_IS_RECURSION(node)\n                ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END);\n    }\n    else if (NODE_IS_RECURSION(node)) {\n      len = SIZE_OP_MEMORY_START_PUSH;\n      len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)\n                     ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC);\n    }\n    else\n#endif\n    {\n      if (MEM_STATUS_AT0(reg->bt_mem_start, node->m.regnum))\n        len = SIZE_OP_MEMORY_START_PUSH;\n      else\n        len = SIZE_OP_MEMORY_START;\n\n      len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)\n                     ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END);\n    }\n    break;\n\n  case BAG_STOP_BACKTRACK:\n    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {\n      int v;\n      QuantNode* qn;\n\n      qn = QUANT_(NODE_BAG_BODY(node));\n      tlen = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n      if (tlen < 0) return tlen;\n\n      v = onig_positive_int_multiply(qn->lower, tlen);\n      if (v < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n      len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP;\n    }\n    else {\n      len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END;\n    }\n    break;\n\n  case BAG_IF_ELSE:\n    {\n      Node* cond = NODE_BAG_BODY(node);\n      Node* Then = node->te.Then;\n      Node* Else = node->te.Else;\n\n      len = compile_length_tree(cond, reg);\n      if (len < 0) return len;\n      len += SIZE_OP_PUSH;\n      len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END;\n\n      if (IS_NOT_NULL(Then)) {\n        tlen = compile_length_tree(Then, reg);\n        if (tlen < 0) return tlen;\n        len += tlen;\n      }\n\n      if (IS_NOT_NULL(Else)) {\n        len += SIZE_OP_JUMP;\n        tlen = compile_length_tree(Else, reg);\n        if (tlen < 0) return tlen;\n        len += tlen;\n      }\n    }\n    break;\n\n  case BAG_OPTION:\n    /* never come here, but set for escape warning */\n    len = 0;\n    break;\n  }\n\n  return len;\n}\n\nstatic int get_char_len_node(Node* node, regex_t* reg, int* len);\n\nstatic int\ncompile_bag_memory_node(BagNode* node, regex_t* reg, ScanEnv* env)\n{\n  int r;\n  int len;\n\n#ifdef USE_CALL\n  if (NODE_IS_CALLED(node)) {\n    r = add_op(reg, OP_CALL);\n    if (r != 0) return r;\n\n    node->m.called_addr = COP_CURR_OFFSET(reg) + 1 + SIZE_OP_JUMP;\n    NODE_STATUS_ADD(node, ADDR_FIXED);\n    COP(reg)->call.addr = (int )node->m.called_addr;\n\n    if (node->m.regnum == 0) {\n      len = compile_length_tree(NODE_BAG_BODY(node), reg);\n      len += SIZE_OP_RETURN;\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = len + SIZE_INC_OP;\n\n      r = compile_tree(NODE_BAG_BODY(node), reg, env);\n      if (r != 0) return r;\n\n      r = add_op(reg, OP_RETURN);\n      return r;\n    }\n    else {\n      len = compile_length_tree(NODE_BAG_BODY(node), reg);\n      len += (SIZE_OP_MEMORY_START_PUSH + SIZE_OP_RETURN);\n      if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))\n        len += (NODE_IS_RECURSION(node)\n                ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH);\n      else\n        len += (NODE_IS_RECURSION(node)\n                ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END);\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = len + SIZE_INC_OP;\n    }\n  }\n#endif\n\n  if (MEM_STATUS_AT0(reg->bt_mem_start, node->m.regnum))\n    r = add_op(reg, OP_MEMORY_START_PUSH);\n  else\n    r = add_op(reg, OP_MEMORY_START);\n  if (r != 0) return r;\n  COP(reg)->memory_start.num = node->m.regnum;\n\n  r = compile_tree(NODE_BAG_BODY(node), reg, env);\n  if (r != 0) return r;\n\n#ifdef USE_CALL\n  if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))\n    r = add_op(reg, (NODE_IS_RECURSION(node)\n                     ? OP_MEMORY_END_PUSH_REC : OP_MEMORY_END_PUSH));\n  else\n    r = add_op(reg, (NODE_IS_RECURSION(node) ? OP_MEMORY_END_REC : OP_MEMORY_END));\n  if (r != 0) return r;\n  COP(reg)->memory_end.num = node->m.regnum;\n\n  if (NODE_IS_CALLED(node)) {\n    if (r != 0) return r;\n    r = add_op(reg, OP_RETURN);\n  }\n#else\n  if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))\n    r = add_op(reg, OP_MEMORY_END_PUSH);\n  else\n    r = add_op(reg, OP_MEMORY_END);\n  if (r != 0) return r;\n  COP(reg)->memory_end.num = node->m.regnum;\n#endif\n\n  return r;\n}\n\nstatic int\ncompile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n{\n  int r, len;\n\n  switch (node->type) {\n  case BAG_MEMORY:\n    r = compile_bag_memory_node(node, reg, env);\n    break;\n\n  case BAG_OPTION:\n    r = compile_option_node(node, reg, env);\n    break;\n\n  case BAG_STOP_BACKTRACK:\n    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {\n      QuantNode* qn = QUANT_(NODE_BAG_BODY(node));\n      r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);\n      if (r != 0) return r;\n\n      len = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n      if (len < 0) return len;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;\n\n      r = compile_tree(NODE_QUANT_BODY(qn), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_POP_OUT);\n      if (r != 0) return r;\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);\n    }\n    else {\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n      r = compile_tree(NODE_BAG_BODY(node), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n    }\n    break;\n\n  case BAG_IF_ELSE:\n    {\n      int cond_len, then_len, jump_len;\n      Node* cond = NODE_BAG_BODY(node);\n      Node* Then = node->te.Then;\n      Node* Else = node->te.Else;\n\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n\n      cond_len = compile_length_tree(cond, reg);\n      if (cond_len < 0) return cond_len;\n      if (IS_NOT_NULL(Then)) {\n        then_len = compile_length_tree(Then, reg);\n        if (then_len < 0) return then_len;\n      }\n      else\n        then_len = 0;\n\n      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;\n      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + jump_len;\n\n      r = compile_tree(cond, reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n      if (r != 0) return r;\n\n      if (IS_NOT_NULL(Then)) {\n        r = compile_tree(Then, reg, env);\n        if (r != 0) return r;\n      }\n\n      if (IS_NOT_NULL(Else)) {\n        int else_len = compile_length_tree(Else, reg);\n        r = add_op(reg, OP_JUMP);\n        if (r != 0) return r;\n        COP(reg)->jump.addr = else_len + SIZE_INC_OP;\n\n        r = compile_tree(Else, reg, env);\n      }\n    }\n    break;\n  }\n\n  return r;\n}\n\nstatic int\ncompile_length_anchor_node(AnchorNode* node, regex_t* reg)\n{\n  int len;\n  int tlen = 0;\n\n  if (IS_NOT_NULL(NODE_ANCHOR_BODY(node))) {\n    tlen = compile_length_tree(NODE_ANCHOR_BODY(node), reg);\n    if (tlen < 0) return tlen;\n  }\n\n  switch (node->type) {\n  case ANCR_PREC_READ:\n    len = SIZE_OP_PREC_READ_START + tlen + SIZE_OP_PREC_READ_END;\n    break;\n  case ANCR_PREC_READ_NOT:\n    len = SIZE_OP_PREC_READ_NOT_START + tlen + SIZE_OP_PREC_READ_NOT_END;\n    break;\n  case ANCR_LOOK_BEHIND:\n    len = SIZE_OP_LOOK_BEHIND + tlen;\n    break;\n  case ANCR_LOOK_BEHIND_NOT:\n    len = SIZE_OP_LOOK_BEHIND_NOT_START + tlen + SIZE_OP_LOOK_BEHIND_NOT_END;\n    break;\n\n  case ANCR_WORD_BOUNDARY:\n  case ANCR_NO_WORD_BOUNDARY:\n#ifdef USE_WORD_BEGIN_END\n  case ANCR_WORD_BEGIN:\n  case ANCR_WORD_END:\n#endif\n    len = SIZE_OP_WORD_BOUNDARY;\n    break;\n\n  case ANCR_TEXT_SEGMENT_BOUNDARY:\n  case ANCR_NO_TEXT_SEGMENT_BOUNDARY:\n    len = SIZE_OPCODE;\n    break;\n\n  default:\n    len = SIZE_OPCODE;\n    break;\n  }\n\n  return len;\n}\n\nstatic int\ncompile_anchor_node(AnchorNode* node, regex_t* reg, ScanEnv* env)\n{\n  int r, len;\n  enum OpCode op;\n\n  switch (node->type) {\n  case ANCR_BEGIN_BUF:      r = add_op(reg, OP_BEGIN_BUF);      break;\n  case ANCR_END_BUF:        r = add_op(reg, OP_END_BUF);        break;\n  case ANCR_BEGIN_LINE:     r = add_op(reg, OP_BEGIN_LINE);     break;\n  case ANCR_END_LINE:       r = add_op(reg, OP_END_LINE);       break;\n  case ANCR_SEMI_END_BUF:   r = add_op(reg, OP_SEMI_END_BUF);   break;\n  case ANCR_BEGIN_POSITION: r = add_op(reg, OP_BEGIN_POSITION); break;\n\n  case ANCR_WORD_BOUNDARY:\n    op = OP_WORD_BOUNDARY;\n  word:\n    r = add_op(reg, op);\n    if (r != 0) return r;\n    COP(reg)->word_boundary.mode = (ModeType )node->ascii_mode;\n    break;\n\n  case ANCR_NO_WORD_BOUNDARY:\n    op = OP_NO_WORD_BOUNDARY; goto word;\n    break;\n#ifdef USE_WORD_BEGIN_END\n  case ANCR_WORD_BEGIN:\n    op = OP_WORD_BEGIN; goto word;\n    break;\n  case ANCR_WORD_END:\n    op = OP_WORD_END; goto word;\n    break;\n#endif\n\n  case ANCR_TEXT_SEGMENT_BOUNDARY:\n  case ANCR_NO_TEXT_SEGMENT_BOUNDARY:\n    {\n      enum TextSegmentBoundaryType type;\n\n      r = add_op(reg, OP_TEXT_SEGMENT_BOUNDARY);\n      if (r != 0) return r;\n\n      type = EXTENDED_GRAPHEME_CLUSTER_BOUNDARY;\n#ifdef USE_UNICODE_WORD_BREAK\n      if (ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_TEXT_SEGMENT_WORD))\n        type = WORD_BOUNDARY;\n#endif\n\n      COP(reg)->text_segment_boundary.type = type;\n      COP(reg)->text_segment_boundary.not =\n        (node->type == ANCR_NO_TEXT_SEGMENT_BOUNDARY ? 1 : 0);\n    }\n    break;\n\n  case ANCR_PREC_READ:\n    r = add_op(reg, OP_PREC_READ_START);\n    if (r != 0) return r;\n    r = compile_tree(NODE_ANCHOR_BODY(node), reg, env);\n    if (r != 0) return r;\n    r = add_op(reg, OP_PREC_READ_END);\n    break;\n\n  case ANCR_PREC_READ_NOT:\n    len = compile_length_tree(NODE_ANCHOR_BODY(node), reg);\n    if (len < 0) return len;\n\n    r = add_op(reg, OP_PREC_READ_NOT_START);\n    if (r != 0) return r;\n    COP(reg)->prec_read_not_start.addr = SIZE_INC_OP + len + SIZE_OP_PREC_READ_NOT_END;\n    r = compile_tree(NODE_ANCHOR_BODY(node), reg, env);\n    if (r != 0) return r;\n    r = add_op(reg, OP_PREC_READ_NOT_END);\n    break;\n\n  case ANCR_LOOK_BEHIND:\n    {\n      int n;\n      r = add_op(reg, OP_LOOK_BEHIND);\n      if (r != 0) return r;\n      if (node->char_len < 0) {\n        r = get_char_len_node(NODE_ANCHOR_BODY(node), reg, &n);\n        if (r != 0) return ONIGERR_INVALID_LOOK_BEHIND_PATTERN;\n      }\n      else\n        n = node->char_len;\n\n      COP(reg)->look_behind.len = n;\n      r = compile_tree(NODE_ANCHOR_BODY(node), reg, env);\n    }\n    break;\n\n  case ANCR_LOOK_BEHIND_NOT:\n    {\n      int n;\n\n      len = compile_length_tree(NODE_ANCHOR_BODY(node), reg);\n      r = add_op(reg, OP_LOOK_BEHIND_NOT_START);\n      if (r != 0) return r;\n      COP(reg)->look_behind_not_start.addr = SIZE_INC_OP + len + SIZE_OP_LOOK_BEHIND_NOT_END;\n\n      if (node->char_len < 0) {\n        r = get_char_len_node(NODE_ANCHOR_BODY(node), reg, &n);\n        if (r != 0) return ONIGERR_INVALID_LOOK_BEHIND_PATTERN;\n      }\n      else\n        n = node->char_len;\n\n      COP(reg)->look_behind_not_start.len = n;\n\n      r = compile_tree(NODE_ANCHOR_BODY(node), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_LOOK_BEHIND_NOT_END);\n    }\n    break;\n\n  default:\n    return ONIGERR_TYPE_BUG;\n    break;\n  }\n\n  return r;\n}\n\nstatic int\ncompile_gimmick_node(GimmickNode* node, regex_t* reg)\n{\n  int r;\n\n  switch (node->type) {\n  case GIMMICK_FAIL:\n    r = add_op(reg, OP_FAIL);\n    break;\n\n  case GIMMICK_SAVE:\n    r = add_op(reg, OP_PUSH_SAVE_VAL);\n    if (r != 0) return r;\n    COP(reg)->push_save_val.type = node->detail_type;\n    COP(reg)->push_save_val.id   = node->id;\n    break;\n\n  case GIMMICK_UPDATE_VAR:\n    r = add_op(reg, OP_UPDATE_VAR);\n    if (r != 0) return r;\n    COP(reg)->update_var.type = node->detail_type;\n    COP(reg)->update_var.id   = node->id;\n    break;\n\n#ifdef USE_CALLOUT\n  case GIMMICK_CALLOUT:\n    switch (node->detail_type) {\n    case ONIG_CALLOUT_OF_CONTENTS:\n    case ONIG_CALLOUT_OF_NAME:\n      {\n        if (node->detail_type == ONIG_CALLOUT_OF_NAME) {\n          r = add_op(reg, OP_CALLOUT_NAME);\n          if (r != 0) return r;\n          COP(reg)->callout_name.id  = node->id;\n          COP(reg)->callout_name.num = node->num;\n        }\n        else {\n          r = add_op(reg, OP_CALLOUT_CONTENTS);\n          if (r != 0) return r;\n          COP(reg)->callout_contents.num = node->num;\n        }\n      }\n      break;\n\n    default:\n      r = ONIGERR_TYPE_BUG;\n      break;\n    }\n#endif\n  }\n\n  return r;\n}\n\nstatic int\ncompile_length_gimmick_node(GimmickNode* node, regex_t* reg)\n{\n  int len;\n\n  switch (node->type) {\n  case GIMMICK_FAIL:\n    len = SIZE_OP_FAIL;\n    break;\n\n  case GIMMICK_SAVE:\n    len = SIZE_OP_PUSH_SAVE_VAL;\n    break;\n\n  case GIMMICK_UPDATE_VAR:\n    len = SIZE_OP_UPDATE_VAR;\n    break;\n\n#ifdef USE_CALLOUT\n  case GIMMICK_CALLOUT:\n    switch (node->detail_type) {\n    case ONIG_CALLOUT_OF_CONTENTS:\n      len = SIZE_OP_CALLOUT_CONTENTS;\n      break;\n    case ONIG_CALLOUT_OF_NAME:\n      len = SIZE_OP_CALLOUT_NAME;\n      break;\n\n    default:\n      len = ONIGERR_TYPE_BUG;\n      break;\n    }\n    break;\n#endif\n  }\n\n  return len;\n}\n\nstatic int\ncompile_length_tree(Node* node, regex_t* reg)\n{\n  int len, r;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n    len = 0;\n    do {\n      r = compile_length_tree(NODE_CAR(node), reg);\n      if (r < 0) return r;\n      len += r;\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    r = len;\n    break;\n\n  case NODE_ALT:\n    {\n      int n;\n\n      n = r = 0;\n      do {\n        r += compile_length_tree(NODE_CAR(node), reg);\n        n++;\n      } while (IS_NOT_NULL(node = NODE_CDR(node)));\n      r += (SIZE_OP_PUSH + SIZE_OP_JUMP) * (n - 1);\n    }\n    break;\n\n  case NODE_STRING:\n    if (NODE_STRING_IS_RAW(node))\n      r = compile_length_string_raw_node(STR_(node), reg);\n    else\n      r = compile_length_string_node(node, reg);\n    break;\n\n  case NODE_CCLASS:\n    r = compile_length_cclass_node(CCLASS_(node), reg);\n    break;\n\n  case NODE_CTYPE:\n    r = SIZE_OPCODE;\n    break;\n\n  case NODE_BACKREF:\n    r = SIZE_OP_BACKREF;\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    r = SIZE_OP_CALL;\n    break;\n#endif\n\n  case NODE_QUANT:\n    r = compile_length_quantifier_node(QUANT_(node), reg);\n    break;\n\n  case NODE_BAG:\n    r = compile_length_bag_node(BAG_(node), reg);\n    break;\n\n  case NODE_ANCHOR:\n    r = compile_length_anchor_node(ANCHOR_(node), reg);\n    break;\n\n  case NODE_GIMMICK:\n    r = compile_length_gimmick_node(GIMMICK_(node), reg);\n    break;\n\n  default:\n    return ONIGERR_TYPE_BUG;\n    break;\n  }\n\n  return r;\n}\n\nstatic int\ncompile_tree(Node* node, regex_t* reg, ScanEnv* env)\n{\n  int n, len, pos, r = 0;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n    do {\n      r = compile_tree(NODE_CAR(node), reg, env);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_ALT:\n    {\n      Node* x = node;\n      len = 0;\n      do {\n        len += compile_length_tree(NODE_CAR(x), reg);\n        if (IS_NOT_NULL(NODE_CDR(x))) {\n          len += SIZE_OP_PUSH + SIZE_OP_JUMP;\n        }\n      } while (IS_NOT_NULL(x = NODE_CDR(x)));\n      pos = COP_CURR_OFFSET(reg) + 1 + len;  /* goal position */\n\n      do {\n        len = compile_length_tree(NODE_CAR(node), reg);\n        if (IS_NOT_NULL(NODE_CDR(node))) {\n          enum OpCode push = NODE_IS_SUPER(node) ? OP_PUSH_SUPER : OP_PUSH;\n          r = add_op(reg, push);\n          if (r != 0) break;\n          COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_JUMP;\n        }\n        r = compile_tree(NODE_CAR(node), reg, env);\n        if (r != 0) break;\n        if (IS_NOT_NULL(NODE_CDR(node))) {\n          len = pos - (COP_CURR_OFFSET(reg) + 1);\n          r = add_op(reg, OP_JUMP);\n          if (r != 0) break;\n          COP(reg)->jump.addr = len;\n        }\n      } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    }\n    break;\n\n  case NODE_STRING:\n    if (NODE_STRING_IS_RAW(node))\n      r = compile_string_raw_node(STR_(node), reg);\n    else\n      r = compile_string_node(node, reg);\n    break;\n\n  case NODE_CCLASS:\n    r = compile_cclass_node(CCLASS_(node), reg);\n    break;\n\n  case NODE_CTYPE:\n    {\n      int op;\n\n      switch (CTYPE_(node)->ctype) {\n      case CTYPE_ANYCHAR:\n        r = add_op(reg, IS_MULTILINE(CTYPE_OPTION(node, reg)) ?\n                   OP_ANYCHAR_ML : OP_ANYCHAR);\n        break;\n\n      case ONIGENC_CTYPE_WORD:\n        if (CTYPE_(node)->ascii_mode == 0) {\n          op = CTYPE_(node)->not != 0 ? OP_NO_WORD : OP_WORD;\n        }\n        else {\n          op = CTYPE_(node)->not != 0 ? OP_NO_WORD_ASCII : OP_WORD_ASCII;\n        }\n        r = add_op(reg, op);\n        break;\n\n      default:\n        return ONIGERR_TYPE_BUG;\n        break;\n      }\n    }\n    break;\n\n  case NODE_BACKREF:\n    {\n      BackRefNode* br = BACKREF_(node);\n\n      if (NODE_IS_CHECKER(node)) {\n#ifdef USE_BACKREF_WITH_LEVEL\n        if (NODE_IS_NEST_LEVEL(node)) {\n          r = add_op(reg, OP_BACKREF_CHECK_WITH_LEVEL);\n          if (r != 0) return r;\n          COP(reg)->backref_general.nest_level = br->nest_level;\n        }\n        else\n#endif\n          {\n            r = add_op(reg, OP_BACKREF_CHECK);\n            if (r != 0) return r;\n          }\n        goto add_bacref_mems;\n      }\n      else {\n#ifdef USE_BACKREF_WITH_LEVEL\n        if (NODE_IS_NEST_LEVEL(node)) {\n          if ((reg->options & ONIG_OPTION_IGNORECASE) != 0)\n            r = add_op(reg, OP_BACKREF_WITH_LEVEL_IC);\n          else\n            r = add_op(reg, OP_BACKREF_WITH_LEVEL);\n\n          if (r != 0) return r;\n          COP(reg)->backref_general.nest_level = br->nest_level;\n          goto add_bacref_mems;\n        }\n        else\n#endif\n        if (br->back_num == 1) {\n          n = br->back_static[0];\n          if (IS_IGNORECASE(reg->options)) {\n            r = add_op(reg, OP_BACKREF_N_IC);\n            if (r != 0) return r;\n            COP(reg)->backref_n.n1 = n;\n          }\n          else {\n            switch (n) {\n            case 1:  r = add_op(reg, OP_BACKREF1); break;\n            case 2:  r = add_op(reg, OP_BACKREF2); break;\n            default:\n              r = add_op(reg, OP_BACKREF_N);\n              if (r != 0) return r;\n              COP(reg)->backref_n.n1 = n;\n              break;\n            }\n          }\n        }\n        else {\n          int num;\n          int* p;\n\n          r = add_op(reg, IS_IGNORECASE(reg->options) ?\n                     OP_BACKREF_MULTI_IC : OP_BACKREF_MULTI);\n          if (r != 0) return r;\n\n        add_bacref_mems:\n          num = br->back_num;\n          COP(reg)->backref_general.num = num;\n          if (num == 1) {\n            COP(reg)->backref_general.n1 = br->back_static[0];\n          }\n          else {\n            int i, j;\n            MemNumType* ns;\n\n            ns = xmalloc(sizeof(MemNumType) * num);\n            CHECK_NULL_RETURN_MEMERR(ns);\n            COP(reg)->backref_general.ns = ns;\n            p = BACKREFS_P(br);\n            for (i = num - 1, j = 0; i >= 0; i--, j++) {\n              ns[j] = p[i];\n            }\n          }\n        }\n      }\n    }\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    r = compile_call(CALL_(node), reg, env);\n    break;\n#endif\n\n  case NODE_QUANT:\n    r = compile_quantifier_node(QUANT_(node), reg, env);\n    break;\n\n  case NODE_BAG:\n    r = compile_bag_node(BAG_(node), reg, env);\n    break;\n\n  case NODE_ANCHOR:\n    r = compile_anchor_node(ANCHOR_(node), reg, env);\n    break;\n\n  case NODE_GIMMICK:\n    r = compile_gimmick_node(GIMMICK_(node), reg);\n    break;\n\n  default:\n#ifdef ONIG_DEBUG\n    fprintf(stderr, \"compile_tree: undefined node type %d\\n\", NODE_TYPE(node));\n#endif\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nnoname_disable_map(Node** plink, GroupNumRemap* map, int* counter)\n{\n  int r = 0;\n  Node* node = *plink;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    do {\n      r = noname_disable_map(&(NODE_CAR(node)), map, counter);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_QUANT:\n    {\n      Node** ptarget = &(NODE_BODY(node));\n      Node*  old = *ptarget;\n      r = noname_disable_map(ptarget, map, counter);\n      if (*ptarget != old && NODE_TYPE(*ptarget) == NODE_QUANT) {\n        onig_reduce_nested_quantifier(node, *ptarget);\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n      if (en->type == BAG_MEMORY) {\n        if (NODE_IS_NAMED_GROUP(node)) {\n          (*counter)++;\n          map[en->m.regnum].new_val = *counter;\n          en->m.regnum = *counter;\n          r = noname_disable_map(&(NODE_BODY(node)), map, counter);\n        }\n        else {\n          *plink = NODE_BODY(node);\n          NODE_BODY(node) = NULL_NODE;\n          onig_node_free(node);\n          r = noname_disable_map(plink, map, counter);\n        }\n      }\n      else if (en->type == BAG_IF_ELSE) {\n        r = noname_disable_map(&(NODE_BAG_BODY(en)), map, counter);\n        if (r != 0) return r;\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = noname_disable_map(&(en->te.Then), map, counter);\n          if (r != 0) return r;\n        }\n        if (IS_NOT_NULL(en->te.Else)) {\n          r = noname_disable_map(&(en->te.Else), map, counter);\n          if (r != 0) return r;\n        }\n      }\n      else\n        r = noname_disable_map(&(NODE_BODY(node)), map, counter);\n    }\n    break;\n\n  case NODE_ANCHOR:\n    if (IS_NOT_NULL(NODE_BODY(node)))\n      r = noname_disable_map(&(NODE_BODY(node)), map, counter);\n    break;\n\n  default:\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nrenumber_node_backref(Node* node, GroupNumRemap* map)\n{\n  int i, pos, n, old_num;\n  int *backs;\n  BackRefNode* bn = BACKREF_(node);\n\n  if (! NODE_IS_BY_NAME(node))\n    return ONIGERR_NUMBERED_BACKREF_OR_CALL_NOT_ALLOWED;\n\n  old_num = bn->back_num;\n  if (IS_NULL(bn->back_dynamic))\n    backs = bn->back_static;\n  else\n    backs = bn->back_dynamic;\n\n  for (i = 0, pos = 0; i < old_num; i++) {\n    n = map[backs[i]].new_val;\n    if (n > 0) {\n      backs[pos] = n;\n      pos++;\n    }\n  }\n\n  bn->back_num = pos;\n  return 0;\n}\n\nstatic int\nrenumber_by_map(Node* node, GroupNumRemap* map)\n{\n  int r = 0;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    do {\n      r = renumber_by_map(NODE_CAR(node), map);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_QUANT:\n    r = renumber_by_map(NODE_BODY(node), map);\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      r = renumber_by_map(NODE_BODY(node), map);\n      if (r != 0) return r;\n\n      if (en->type == BAG_IF_ELSE) {\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = renumber_by_map(en->te.Then, map);\n          if (r != 0) return r;\n        }\n        if (IS_NOT_NULL(en->te.Else)) {\n          r = renumber_by_map(en->te.Else, map);\n          if (r != 0) return r;\n        }\n      }\n    }\n    break;\n\n  case NODE_BACKREF:\n    r = renumber_node_backref(node, map);\n    break;\n\n  case NODE_ANCHOR:\n    if (IS_NOT_NULL(NODE_BODY(node)))\n      r = renumber_by_map(NODE_BODY(node), map);\n    break;\n\n  default:\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nnumbered_ref_check(Node* node)\n{\n  int r = 0;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    do {\n      r = numbered_ref_check(NODE_CAR(node));\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_ANCHOR:\n    if (IS_NULL(NODE_BODY(node)))\n      break;\n    /* fall */\n  case NODE_QUANT:\n    r = numbered_ref_check(NODE_BODY(node));\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      r = numbered_ref_check(NODE_BODY(node));\n      if (r != 0) return r;\n\n      if (en->type == BAG_IF_ELSE) {\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = numbered_ref_check(en->te.Then);\n          if (r != 0) return r;\n        }\n        if (IS_NOT_NULL(en->te.Else)) {\n          r = numbered_ref_check(en->te.Else);\n          if (r != 0) return r;\n        }\n      }\n    }\n\n    break;\n\n  case NODE_BACKREF:\n    if (! NODE_IS_BY_NAME(node))\n      return ONIGERR_NUMBERED_BACKREF_OR_CALL_NOT_ALLOWED;\n    break;\n\n  default:\n    break;\n  }\n\n  return r;\n}\n\nstatic int\ndisable_noname_group_capture(Node** root, regex_t* reg, ScanEnv* env)\n{\n  int r, i, pos, counter;\n  MemStatusType loc;\n  GroupNumRemap* map;\n\n  map = (GroupNumRemap* )xalloca(sizeof(GroupNumRemap) * (env->num_mem + 1));\n  CHECK_NULL_RETURN_MEMERR(map);\n  for (i = 1; i <= env->num_mem; i++) {\n    map[i].new_val = 0;\n  }\n  counter = 0;\n  r = noname_disable_map(root, map, &counter);\n  if (r != 0) return r;\n\n  r = renumber_by_map(*root, map);\n  if (r != 0) return r;\n\n  for (i = 1, pos = 1; i <= env->num_mem; i++) {\n    if (map[i].new_val > 0) {\n      SCANENV_MEMENV(env)[pos] = SCANENV_MEMENV(env)[i];\n      pos++;\n    }\n  }\n\n  loc = env->capture_history;\n  MEM_STATUS_CLEAR(env->capture_history);\n  for (i = 1; i <= ONIG_MAX_CAPTURE_HISTORY_GROUP; i++) {\n    if (MEM_STATUS_AT(loc, i)) {\n      MEM_STATUS_ON_SIMPLE(env->capture_history, map[i].new_val);\n    }\n  }\n\n  env->num_mem = env->num_named;\n  reg->num_mem = env->num_named;\n\n  return onig_renumber_name_table(reg, map);\n}\n\n#ifdef USE_CALL\nstatic int\nfix_unset_addr_list(UnsetAddrList* uslist, regex_t* reg)\n{\n  int i, offset;\n  BagNode* en;\n  AbsAddrType addr;\n  AbsAddrType* paddr;\n\n  for (i = 0; i < uslist->num; i++) {\n    if (! NODE_IS_ADDR_FIXED(uslist->us[i].target))\n      return ONIGERR_PARSER_BUG;\n\n    en = BAG_(uslist->us[i].target);\n    addr   = en->m.called_addr;\n    offset = uslist->us[i].offset;\n\n    paddr = (AbsAddrType* )((char* )reg->ops + offset);\n    *paddr = addr;\n  }\n  return 0;\n}\n#endif\n\n\n#define GET_CHAR_LEN_VARLEN           -1\n#define GET_CHAR_LEN_TOP_ALT_VARLEN   -2\n\n/* fixed size pattern node only */\nstatic int\nget_char_len_node1(Node* node, regex_t* reg, int* len, int level)\n{\n  int tlen;\n  int r = 0;\n\n  level++;\n  *len = 0;\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n    do {\n      r = get_char_len_node1(NODE_CAR(node), reg, &tlen, level);\n      if (r == 0)\n        *len = distance_add(*len, tlen);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_ALT:\n    {\n      int tlen2;\n      int varlen = 0;\n\n      r = get_char_len_node1(NODE_CAR(node), reg, &tlen, level);\n      while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node))) {\n        r = get_char_len_node1(NODE_CAR(node), reg, &tlen2, level);\n        if (r == 0) {\n          if (tlen != tlen2)\n            varlen = 1;\n        }\n      }\n      if (r == 0) {\n        if (varlen != 0) {\n          if (level == 1)\n            r = GET_CHAR_LEN_TOP_ALT_VARLEN;\n          else\n            r = GET_CHAR_LEN_VARLEN;\n        }\n        else\n          *len = tlen;\n      }\n    }\n    break;\n\n  case NODE_STRING:\n    {\n      StrNode* sn = STR_(node);\n      UChar *s = sn->s;\n\n      while (s < sn->end) {\n        s += enclen(reg->enc, s);\n        (*len)++;\n      }\n    }\n    break;\n\n  case NODE_QUANT:\n    {\n      QuantNode* qn = QUANT_(node);\n\n      if (qn->lower == qn->upper) {\n        if (qn->upper == 0) {\n          *len = 0;\n        }\n        else {\n          r = get_char_len_node1(NODE_BODY(node), reg, &tlen, level);\n          if (r == 0)\n            *len = distance_multiply(tlen, qn->lower);\n        }\n      }\n      else\n        r = GET_CHAR_LEN_VARLEN;\n    }\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    if (! NODE_IS_RECURSION(node))\n      r = get_char_len_node1(NODE_BODY(node), reg, len, level);\n    else\n      r = GET_CHAR_LEN_VARLEN;\n    break;\n#endif\n\n  case NODE_CTYPE:\n  case NODE_CCLASS:\n    *len = 1;\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      switch (en->type) {\n      case BAG_MEMORY:\n#ifdef USE_CALL\n        if (NODE_IS_CLEN_FIXED(node))\n          *len = en->char_len;\n        else {\n          r = get_char_len_node1(NODE_BODY(node), reg, len, level);\n          if (r == 0) {\n            en->char_len = *len;\n            NODE_STATUS_ADD(node, CLEN_FIXED);\n          }\n        }\n        break;\n#endif\n      case BAG_OPTION:\n      case BAG_STOP_BACKTRACK:\n        r = get_char_len_node1(NODE_BODY(node), reg, len, level);\n        break;\n      case BAG_IF_ELSE:\n        {\n          int clen, elen;\n\n          r = get_char_len_node1(NODE_BODY(node), reg, &clen, level);\n          if (r == 0) {\n            if (IS_NOT_NULL(en->te.Then)) {\n              r = get_char_len_node1(en->te.Then, reg, &tlen, level);\n              if (r != 0) break;\n            }\n            else tlen = 0;\n            if (IS_NOT_NULL(en->te.Else)) {\n              r = get_char_len_node1(en->te.Else, reg, &elen, level);\n              if (r != 0) break;\n            }\n            else elen = 0;\n\n            if (clen + tlen != elen) {\n              r = GET_CHAR_LEN_VARLEN;\n            }\n            else {\n              *len = elen;\n            }\n          }\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_ANCHOR:\n  case NODE_GIMMICK:\n    break;\n\n  case NODE_BACKREF:\n    if (NODE_IS_CHECKER(node))\n      break;\n    /* fall */\n  default:\n    r = GET_CHAR_LEN_VARLEN;\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nget_char_len_node(Node* node, regex_t* reg, int* len)\n{\n  return get_char_len_node1(node, reg, len, 0);\n}\n\n/* x is not included y ==>  1 : 0 */\nstatic int\nis_exclusive(Node* x, Node* y, regex_t* reg)\n{\n  int i, len;\n  OnigCodePoint code;\n  UChar *p;\n  NodeType ytype;\n\n retry:\n  ytype = NODE_TYPE(y);\n  switch (NODE_TYPE(x)) {\n  case NODE_CTYPE:\n    {\n      if (CTYPE_(x)->ctype == CTYPE_ANYCHAR ||\n          CTYPE_(y)->ctype == CTYPE_ANYCHAR)\n        break;\n\n      switch (ytype) {\n      case NODE_CTYPE:\n        if (CTYPE_(y)->ctype == CTYPE_(x)->ctype &&\n            CTYPE_(y)->not   != CTYPE_(x)->not &&\n            CTYPE_(y)->ascii_mode == CTYPE_(x)->ascii_mode)\n          return 1;\n        else\n          return 0;\n        break;\n\n      case NODE_CCLASS:\n      swap:\n        {\n          Node* tmp;\n          tmp = x; x = y; y = tmp;\n          goto retry;\n        }\n        break;\n\n      case NODE_STRING:\n        goto swap;\n        break;\n\n      default:\n        break;\n      }\n    }\n    break;\n\n  case NODE_CCLASS:\n    {\n      int range;\n      CClassNode* xc = CCLASS_(x);\n\n      switch (ytype) {\n      case NODE_CTYPE:\n        switch (CTYPE_(y)->ctype) {\n        case CTYPE_ANYCHAR:\n          return 0;\n          break;\n\n        case ONIGENC_CTYPE_WORD:\n          if (CTYPE_(y)->not == 0) {\n            if (IS_NULL(xc->mbuf) && !IS_NCCLASS_NOT(xc)) {\n              range = CTYPE_(y)->ascii_mode != 0 ? 128 : SINGLE_BYTE_SIZE;\n              for (i = 0; i < range; i++) {\n                if (BITSET_AT(xc->bs, i)) {\n                  if (ONIGENC_IS_CODE_WORD(reg->enc, i)) return 0;\n                }\n              }\n              return 1;\n            }\n            return 0;\n          }\n          else {\n            if (IS_NOT_NULL(xc->mbuf)) return 0;\n            if (IS_NCCLASS_NOT(xc)) return 0;\n\n            range = CTYPE_(y)->ascii_mode != 0 ? 128 : SINGLE_BYTE_SIZE;\n            for (i = 0; i < range; i++) {\n              if (! ONIGENC_IS_CODE_WORD(reg->enc, i)) {\n                if (BITSET_AT(xc->bs, i))\n                  return 0;\n              }\n            }\n            for (i = range; i < SINGLE_BYTE_SIZE; i++) {\n              if (BITSET_AT(xc->bs, i)) return 0;\n            }\n            return 1;\n          }\n          break;\n\n        default:\n          break;\n        }\n        break;\n\n      case NODE_CCLASS:\n        {\n          int v;\n          CClassNode* yc = CCLASS_(y);\n\n          for (i = 0; i < SINGLE_BYTE_SIZE; i++) {\n            v = BITSET_AT(xc->bs, i);\n            if ((v != 0 && !IS_NCCLASS_NOT(xc)) || (v == 0 && IS_NCCLASS_NOT(xc))) {\n              v = BITSET_AT(yc->bs, i);\n              if ((v != 0 && !IS_NCCLASS_NOT(yc)) ||\n                  (v == 0 && IS_NCCLASS_NOT(yc)))\n                return 0;\n            }\n          }\n          if ((IS_NULL(xc->mbuf) && !IS_NCCLASS_NOT(xc)) ||\n              (IS_NULL(yc->mbuf) && !IS_NCCLASS_NOT(yc)))\n            return 1;\n          return 0;\n        }\n        break;\n\n      case NODE_STRING:\n        goto swap;\n        break;\n\n      default:\n        break;\n      }\n    }\n    break;\n\n  case NODE_STRING:\n    {\n      StrNode* xs = STR_(x);\n\n      if (NODE_STRING_LEN(x) == 0)\n        break;\n\n      switch (ytype) {\n      case NODE_CTYPE:\n        switch (CTYPE_(y)->ctype) {\n        case CTYPE_ANYCHAR:\n          break;\n\n        case ONIGENC_CTYPE_WORD:\n          if (CTYPE_(y)->ascii_mode == 0) {\n            if (ONIGENC_IS_MBC_WORD(reg->enc, xs->s, xs->end))\n              return CTYPE_(y)->not;\n            else\n              return !(CTYPE_(y)->not);\n          }\n          else {\n            if (ONIGENC_IS_MBC_WORD_ASCII(reg->enc, xs->s, xs->end))\n              return CTYPE_(y)->not;\n            else\n              return !(CTYPE_(y)->not);\n          }\n          break;\n        default:\n          break;\n        }\n        break;\n\n      case NODE_CCLASS:\n        {\n          CClassNode* cc = CCLASS_(y);\n\n          code = ONIGENC_MBC_TO_CODE(reg->enc, xs->s,\n                                     xs->s + ONIGENC_MBC_MAXLEN(reg->enc));\n          return onig_is_code_in_cc(reg->enc, code, cc) == 0;\n        }\n        break;\n\n      case NODE_STRING:\n        {\n          UChar *q;\n          StrNode* ys = STR_(y);\n\n          len = NODE_STRING_LEN(x);\n          if (len > NODE_STRING_LEN(y)) len = NODE_STRING_LEN(y);\n          if (NODE_STRING_IS_AMBIG(x) || NODE_STRING_IS_AMBIG(y)) {\n            /* tiny version */\n            return 0;\n          }\n          else {\n            for (i = 0, p = ys->s, q = xs->s; i < len; i++, p++, q++) {\n              if (*p != *q) return 1;\n            }\n          }\n        }\n        break;\n\n      default:\n        break;\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  return 0;\n}\n\nstatic Node*\nget_head_value_node(Node* node, int exact, regex_t* reg)\n{\n  Node* n = NULL_NODE;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_BACKREF:\n  case NODE_ALT:\n#ifdef USE_CALL\n  case NODE_CALL:\n#endif\n    break;\n\n  case NODE_CTYPE:\n    if (CTYPE_(node)->ctype == CTYPE_ANYCHAR)\n      break;\n    /* fall */\n  case NODE_CCLASS:\n    if (exact == 0) {\n      n = node;\n    }\n    break;\n\n  case NODE_LIST:\n    n = get_head_value_node(NODE_CAR(node), exact, reg);\n    break;\n\n  case NODE_STRING:\n    {\n      StrNode* sn = STR_(node);\n\n      if (sn->end <= sn->s)\n        break;\n\n      if (exact == 0 ||\n          ! IS_IGNORECASE(reg->options) || NODE_STRING_IS_RAW(node)) {\n        n = node;\n      }\n    }\n    break;\n\n  case NODE_QUANT:\n    {\n      QuantNode* qn = QUANT_(node);\n      if (qn->lower > 0) {\n        if (IS_NOT_NULL(qn->head_exact))\n          n = qn->head_exact;\n        else\n          n = get_head_value_node(NODE_BODY(node), exact, reg);\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n      switch (en->type) {\n      case BAG_OPTION:\n        {\n          OnigOptionType options = reg->options;\n\n          reg->options = BAG_(node)->o.options;\n          n = get_head_value_node(NODE_BODY(node), exact, reg);\n          reg->options = options;\n        }\n        break;\n\n      case BAG_MEMORY:\n      case BAG_STOP_BACKTRACK:\n      case BAG_IF_ELSE:\n        n = get_head_value_node(NODE_BODY(node), exact, reg);\n        break;\n      }\n    }\n    break;\n\n  case NODE_ANCHOR:\n    if (ANCHOR_(node)->type == ANCR_PREC_READ)\n      n = get_head_value_node(NODE_BODY(node), exact, reg);\n    break;\n\n  case NODE_GIMMICK:\n  default:\n    break;\n  }\n\n  return n;\n}\n\nstatic int\ncheck_type_tree(Node* node, int type_mask, int bag_mask, int anchor_mask)\n{\n  NodeType type;\n  int r = 0;\n\n  type = NODE_TYPE(node);\n  if ((NODE_TYPE2BIT(type) & type_mask) == 0)\n    return 1;\n\n  switch (type) {\n  case NODE_LIST:\n  case NODE_ALT:\n    do {\n      r = check_type_tree(NODE_CAR(node), type_mask, bag_mask, anchor_mask);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_QUANT:\n    r = check_type_tree(NODE_BODY(node), type_mask, bag_mask, anchor_mask);\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n      if (((1<<en->type) & bag_mask) == 0)\n        return 1;\n\n      r = check_type_tree(NODE_BODY(node), type_mask, bag_mask, anchor_mask);\n      if (r == 0 && en->type == BAG_IF_ELSE) {\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = check_type_tree(en->te.Then, type_mask, bag_mask, anchor_mask);\n          if (r != 0) break;\n        }\n        if (IS_NOT_NULL(en->te.Else)) {\n          r = check_type_tree(en->te.Else, type_mask, bag_mask, anchor_mask);\n        }\n      }\n    }\n    break;\n\n  case NODE_ANCHOR:\n    type = ANCHOR_(node)->type;\n    if ((type & anchor_mask) == 0)\n      return 1;\n\n    if (IS_NOT_NULL(NODE_BODY(node)))\n      r = check_type_tree(NODE_BODY(node), type_mask, bag_mask, anchor_mask);\n    break;\n\n  case NODE_GIMMICK:\n  default:\n    break;\n  }\n  return r;\n}\n\nstatic OnigLen\ntree_min_len(Node* node, ScanEnv* env)\n{\n  OnigLen len;\n  OnigLen tmin;\n\n  len = 0;\n  switch (NODE_TYPE(node)) {\n  case NODE_BACKREF:\n    if (! NODE_IS_CHECKER(node)) {\n      int i;\n      int* backs;\n      MemEnv* mem_env = SCANENV_MEMENV(env);\n      BackRefNode* br = BACKREF_(node);\n      if (NODE_IS_RECURSION(node)) break;\n\n      backs = BACKREFS_P(br);\n      len = tree_min_len(mem_env[backs[0]].node, env);\n      for (i = 1; i < br->back_num; i++) {\n        tmin = tree_min_len(mem_env[backs[i]].node, env);\n        if (len > tmin) len = tmin;\n      }\n    }\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    {\n      Node* t = NODE_BODY(node);\n      if (NODE_IS_RECURSION(node)) {\n        if (NODE_IS_MIN_FIXED(t))\n          len = BAG_(t)->min_len;\n      }\n      else\n        len = tree_min_len(t, env);\n    }\n    break;\n#endif\n\n  case NODE_LIST:\n    do {\n      tmin = tree_min_len(NODE_CAR(node), env);\n      len = distance_add(len, tmin);\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_ALT:\n    {\n      Node *x, *y;\n      y = node;\n      do {\n        x = NODE_CAR(y);\n        tmin = tree_min_len(x, env);\n        if (y == node) len = tmin;\n        else if (len > tmin) len = tmin;\n      } while (IS_NOT_NULL(y = NODE_CDR(y)));\n    }\n    break;\n\n  case NODE_STRING:\n    {\n      StrNode* sn = STR_(node);\n      len = (int )(sn->end - sn->s);\n    }\n    break;\n\n  case NODE_CTYPE:\n  case NODE_CCLASS:\n    len = ONIGENC_MBC_MINLEN(env->enc);\n    break;\n\n  case NODE_QUANT:\n    {\n      QuantNode* qn = QUANT_(node);\n\n      if (qn->lower > 0) {\n        len = tree_min_len(NODE_BODY(node), env);\n        len = distance_multiply(len, qn->lower);\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n      switch (en->type) {\n      case BAG_MEMORY:\n        if (NODE_IS_MIN_FIXED(node))\n          len = en->min_len;\n        else {\n          if (NODE_IS_MARK1(node))\n            len = 0;  /* recursive */\n          else {\n            NODE_STATUS_ADD(node, MARK1);\n            len = tree_min_len(NODE_BODY(node), env);\n            NODE_STATUS_REMOVE(node, MARK1);\n\n            en->min_len = len;\n            NODE_STATUS_ADD(node, MIN_FIXED);\n          }\n        }\n        break;\n\n      case BAG_OPTION:\n      case BAG_STOP_BACKTRACK:\n        len = tree_min_len(NODE_BODY(node), env);\n        break;\n      case BAG_IF_ELSE:\n        {\n          OnigLen elen;\n\n          len = tree_min_len(NODE_BODY(node), env);\n          if (IS_NOT_NULL(en->te.Then))\n            len += tree_min_len(en->te.Then, env);\n          if (IS_NOT_NULL(en->te.Else))\n            elen = tree_min_len(en->te.Else, env);\n          else elen = 0;\n\n          if (elen < len) len = elen;\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_GIMMICK:\n    {\n      GimmickNode* g = GIMMICK_(node);\n      if (g->type == GIMMICK_FAIL) {\n        len = INFINITE_LEN;\n        break;\n      }\n    }\n    /* fall */\n  case NODE_ANCHOR:\n  default:\n    break;\n  }\n\n  return len;\n}\n\nstatic OnigLen\ntree_max_len(Node* node, ScanEnv* env)\n{\n  OnigLen len;\n  OnigLen tmax;\n\n  len = 0;\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n    do {\n      tmax = tree_max_len(NODE_CAR(node), env);\n      len = distance_add(len, tmax);\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_ALT:\n    do {\n      tmax = tree_max_len(NODE_CAR(node), env);\n      if (len < tmax) len = tmax;\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_STRING:\n    {\n      StrNode* sn = STR_(node);\n      len = (OnigLen )(sn->end - sn->s);\n    }\n    break;\n\n  case NODE_CTYPE:\n  case NODE_CCLASS:\n    len = ONIGENC_MBC_MAXLEN_DIST(env->enc);\n    break;\n\n  case NODE_BACKREF:\n    if (! NODE_IS_CHECKER(node)) {\n      int i;\n      int* backs;\n      MemEnv* mem_env = SCANENV_MEMENV(env);\n      BackRefNode* br = BACKREF_(node);\n      if (NODE_IS_RECURSION(node)) {\n        len = INFINITE_LEN;\n        break;\n      }\n      backs = BACKREFS_P(br);\n      for (i = 0; i < br->back_num; i++) {\n        tmax = tree_max_len(mem_env[backs[i]].node, env);\n        if (len < tmax) len = tmax;\n      }\n    }\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    if (! NODE_IS_RECURSION(node))\n      len = tree_max_len(NODE_BODY(node), env);\n    else\n      len = INFINITE_LEN;\n    break;\n#endif\n\n  case NODE_QUANT:\n    {\n      QuantNode* qn = QUANT_(node);\n\n      if (qn->upper != 0) {\n        len = tree_max_len(NODE_BODY(node), env);\n        if (len != 0) {\n          if (! IS_REPEAT_INFINITE(qn->upper))\n            len = distance_multiply(len, qn->upper);\n          else\n            len = INFINITE_LEN;\n        }\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n      switch (en->type) {\n      case BAG_MEMORY:\n        if (NODE_IS_MAX_FIXED(node))\n          len = en->max_len;\n        else {\n          if (NODE_IS_MARK1(node))\n            len = INFINITE_LEN;\n          else {\n            NODE_STATUS_ADD(node, MARK1);\n            len = tree_max_len(NODE_BODY(node), env);\n            NODE_STATUS_REMOVE(node, MARK1);\n\n            en->max_len = len;\n            NODE_STATUS_ADD(node, MAX_FIXED);\n          }\n        }\n        break;\n\n      case BAG_OPTION:\n      case BAG_STOP_BACKTRACK:\n        len = tree_max_len(NODE_BODY(node), env);\n        break;\n      case BAG_IF_ELSE:\n        {\n          OnigLen tlen, elen;\n\n          len = tree_max_len(NODE_BODY(node), env);\n          if (IS_NOT_NULL(en->te.Then)) {\n            tlen = tree_max_len(en->te.Then, env);\n            len = distance_add(len, tlen);\n          }\n          if (IS_NOT_NULL(en->te.Else))\n            elen = tree_max_len(en->te.Else, env);\n          else elen = 0;\n\n          if (elen > len) len = elen;\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_ANCHOR:\n  case NODE_GIMMICK:\n  default:\n    break;\n  }\n\n  return len;\n}\n\nstatic int\ncheck_backrefs(Node* node, ScanEnv* env)\n{\n  int r;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    do {\n      r = check_backrefs(NODE_CAR(node), env);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_ANCHOR:\n    if (! ANCHOR_HAS_BODY(ANCHOR_(node))) {\n      r = 0;\n      break;\n    }\n    /* fall */\n  case NODE_QUANT:\n    r = check_backrefs(NODE_BODY(node), env);\n    break;\n\n  case NODE_BAG:\n    r = check_backrefs(NODE_BODY(node), env);\n    {\n      BagNode* en = BAG_(node);\n\n      if (en->type == BAG_IF_ELSE) {\n        if (r != 0) return r;\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = check_backrefs(en->te.Then, env);\n          if (r != 0) return r;\n        }\n        if (IS_NOT_NULL(en->te.Else)) {\n          r = check_backrefs(en->te.Else, env);\n        }\n      }\n    }\n    break;\n\n  case NODE_BACKREF:\n    {\n      int i;\n      BackRefNode* br = BACKREF_(node);\n      int* backs = BACKREFS_P(br);\n      MemEnv* mem_env = SCANENV_MEMENV(env);\n\n      for (i = 0; i < br->back_num; i++) {\n        if (backs[i] > env->num_mem)\n          return ONIGERR_INVALID_BACKREF;\n\n        NODE_STATUS_ADD(mem_env[backs[i]].node, BACKREF);\n      }\n      r = 0;\n    }\n    break;\n\n  default:\n    r = 0;\n    break;\n  }\n\n  return r;\n}\n\n\n#ifdef USE_CALL\n\n#define RECURSION_EXIST        (1<<0)\n#define RECURSION_MUST         (1<<1)\n#define RECURSION_INFINITE     (1<<2)\n\nstatic int\ninfinite_recursive_call_check(Node* node, ScanEnv* env, int head)\n{\n  int ret;\n  int r = 0;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n    {\n      Node *x;\n      OnigLen min;\n\n      x = node;\n      do {\n        ret = infinite_recursive_call_check(NODE_CAR(x), env, head);\n        if (ret < 0 || (ret & RECURSION_INFINITE) != 0) return ret;\n        r |= ret;\n        if (head != 0) {\n          min = tree_min_len(NODE_CAR(x), env);\n          if (min != 0) head = 0;\n        }\n      } while (IS_NOT_NULL(x = NODE_CDR(x)));\n    }\n    break;\n\n  case NODE_ALT:\n    {\n      int must;\n\n      must = RECURSION_MUST;\n      do {\n        ret = infinite_recursive_call_check(NODE_CAR(node), env, head);\n        if (ret < 0 || (ret & RECURSION_INFINITE) != 0) return ret;\n\n        r    |= (ret & RECURSION_EXIST);\n        must &= ret;\n      } while (IS_NOT_NULL(node = NODE_CDR(node)));\n      r |= must;\n    }\n    break;\n\n  case NODE_QUANT:\n    r = infinite_recursive_call_check(NODE_BODY(node), env, head);\n    if (r < 0) return r;\n    if ((r & RECURSION_MUST) != 0) {\n      if (QUANT_(node)->lower == 0)\n        r &= ~RECURSION_MUST;\n    }\n    break;\n\n  case NODE_ANCHOR:\n    if (! ANCHOR_HAS_BODY(ANCHOR_(node)))\n      break;\n    /* fall */\n  case NODE_CALL:\n    r = infinite_recursive_call_check(NODE_BODY(node), env, head);\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      if (en->type == BAG_MEMORY) {\n        if (NODE_IS_MARK2(node))\n          return 0;\n        else if (NODE_IS_MARK1(node))\n          return (head == 0 ? RECURSION_EXIST | RECURSION_MUST\n                  : RECURSION_EXIST | RECURSION_MUST | RECURSION_INFINITE);\n        else {\n          NODE_STATUS_ADD(node, MARK2);\n          r = infinite_recursive_call_check(NODE_BODY(node), env, head);\n          NODE_STATUS_REMOVE(node, MARK2);\n        }\n      }\n      else if (en->type == BAG_IF_ELSE) {\n        int eret;\n\n        ret = infinite_recursive_call_check(NODE_BODY(node), env, head);\n        if (ret < 0 || (ret & RECURSION_INFINITE) != 0) return ret;\n        r |= ret;\n        if (IS_NOT_NULL(en->te.Then)) {\n          OnigLen min;\n          if (head != 0) {\n            min = tree_min_len(NODE_BODY(node), env);\n          }\n          else min = 0;\n\n          ret = infinite_recursive_call_check(en->te.Then, env, min != 0 ? 0:head);\n          if (ret < 0 || (ret & RECURSION_INFINITE) != 0) return ret;\n          r |= ret;\n        }\n        if (IS_NOT_NULL(en->te.Else)) {\n          eret = infinite_recursive_call_check(en->te.Else, env, head);\n          if (eret < 0 || (eret & RECURSION_INFINITE) != 0) return eret;\n          r |= (eret & RECURSION_EXIST);\n          if ((eret & RECURSION_MUST) == 0)\n            r &= ~RECURSION_MUST;\n        }\n      }\n      else {\n        r = infinite_recursive_call_check(NODE_BODY(node), env, head);\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  return r;\n}\n\nstatic int\ninfinite_recursive_call_check_trav(Node* node, ScanEnv* env)\n{\n  int r;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    do {\n      r = infinite_recursive_call_check_trav(NODE_CAR(node), env);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_ANCHOR:\n    if (! ANCHOR_HAS_BODY(ANCHOR_(node))) {\n      r = 0;\n      break;\n    }\n    /* fall */\n  case NODE_QUANT:\n    r = infinite_recursive_call_check_trav(NODE_BODY(node), env);\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      if (en->type == BAG_MEMORY) {\n        if (NODE_IS_RECURSION(node) && NODE_IS_CALLED(node)) {\n          int ret;\n\n          NODE_STATUS_ADD(node, MARK1);\n\n          ret = infinite_recursive_call_check(NODE_BODY(node), env, 1);\n          if (ret < 0) return ret;\n          else if ((ret & (RECURSION_MUST | RECURSION_INFINITE)) != 0)\n            return ONIGERR_NEVER_ENDING_RECURSION;\n\n          NODE_STATUS_REMOVE(node, MARK1);\n        }\n      }\n      else if (en->type == BAG_IF_ELSE) {\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = infinite_recursive_call_check_trav(en->te.Then, env);\n          if (r != 0) return r;\n        }\n        if (IS_NOT_NULL(en->te.Else)) {\n          r = infinite_recursive_call_check_trav(en->te.Else, env);\n          if (r != 0) return r;\n        }\n      }\n    }\n\n    r = infinite_recursive_call_check_trav(NODE_BODY(node), env);\n    break;\n\n  default:\n    r = 0;\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nrecursive_call_check(Node* node)\n{\n  int r;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    r = 0;\n    do {\n      r |= recursive_call_check(NODE_CAR(node));\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_ANCHOR:\n    if (! ANCHOR_HAS_BODY(ANCHOR_(node))) {\n      r = 0;\n      break;\n    }\n    /* fall */\n  case NODE_QUANT:\n    r = recursive_call_check(NODE_BODY(node));\n    break;\n\n  case NODE_CALL:\n    r = recursive_call_check(NODE_BODY(node));\n    if (r != 0) {\n      if (NODE_IS_MARK1(NODE_BODY(node)))\n        NODE_STATUS_ADD(node, RECURSION);\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      if (en->type == BAG_MEMORY) {\n        if (NODE_IS_MARK2(node))\n          return 0;\n        else if (NODE_IS_MARK1(node))\n          return 1; /* recursion */\n        else {\n          NODE_STATUS_ADD(node, MARK2);\n          r = recursive_call_check(NODE_BODY(node));\n          NODE_STATUS_REMOVE(node, MARK2);\n        }\n      }\n      else if (en->type == BAG_IF_ELSE) {\n        r = 0;\n        if (IS_NOT_NULL(en->te.Then)) {\n          r |= recursive_call_check(en->te.Then);\n        }\n        if (IS_NOT_NULL(en->te.Else)) {\n          r |= recursive_call_check(en->te.Else);\n        }\n        r |= recursive_call_check(NODE_BODY(node));\n      }\n      else {\n        r = recursive_call_check(NODE_BODY(node));\n      }\n    }\n    break;\n\n  default:\n    r = 0;\n    break;\n  }\n\n  return r;\n}\n\n#define IN_RECURSION         (1<<0)\n#define FOUND_CALLED_NODE    1\n\nstatic int\nrecursive_call_check_trav(Node* node, ScanEnv* env, int state)\n{\n  int r = 0;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    {\n      int ret;\n      do {\n        ret = recursive_call_check_trav(NODE_CAR(node), env, state);\n        if (ret == FOUND_CALLED_NODE) r = FOUND_CALLED_NODE;\n        else if (ret < 0) return ret;\n      } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    }\n    break;\n\n  case NODE_QUANT:\n    r = recursive_call_check_trav(NODE_BODY(node), env, state);\n    if (QUANT_(node)->upper == 0) {\n      if (r == FOUND_CALLED_NODE)\n        QUANT_(node)->is_refered = 1;\n    }\n    break;\n\n  case NODE_ANCHOR:\n    {\n      AnchorNode* an = ANCHOR_(node);\n      if (ANCHOR_HAS_BODY(an))\n        r = recursive_call_check_trav(NODE_ANCHOR_BODY(an), env, state);\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      int ret;\n      int state1;\n      BagNode* en = BAG_(node);\n\n      if (en->type == BAG_MEMORY) {\n        if (NODE_IS_CALLED(node) || (state & IN_RECURSION) != 0) {\n          if (! NODE_IS_RECURSION(node)) {\n            NODE_STATUS_ADD(node, MARK1);\n            r = recursive_call_check(NODE_BODY(node));\n            if (r != 0)\n              NODE_STATUS_ADD(node, RECURSION);\n            NODE_STATUS_REMOVE(node, MARK1);\n          }\n\n          if (NODE_IS_CALLED(node))\n            r = FOUND_CALLED_NODE;\n        }\n      }\n\n      state1 = state;\n      if (NODE_IS_RECURSION(node))\n        state1 |= IN_RECURSION;\n\n      ret = recursive_call_check_trav(NODE_BODY(node), env, state1);\n      if (ret == FOUND_CALLED_NODE)\n        r = FOUND_CALLED_NODE;\n\n      if (en->type == BAG_IF_ELSE) {\n        if (IS_NOT_NULL(en->te.Then)) {\n          ret = recursive_call_check_trav(en->te.Then, env, state1);\n          if (ret == FOUND_CALLED_NODE)\n            r = FOUND_CALLED_NODE;\n        }\n        if (IS_NOT_NULL(en->te.Else)) {\n          ret = recursive_call_check_trav(en->te.Else, env, state1);\n          if (ret == FOUND_CALLED_NODE)\n            r = FOUND_CALLED_NODE;\n        }\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  return r;\n}\n\n#endif\n\n#define IN_ALT          (1<<0)\n#define IN_NOT          (1<<1)\n#define IN_REAL_REPEAT  (1<<2)\n#define IN_VAR_REPEAT   (1<<3)\n#define IN_ZERO_REPEAT  (1<<4)\n#define IN_MULTI_ENTRY  (1<<5)\n#define IN_LOOK_BEHIND  (1<<6)\n\n\n/* divide different length alternatives in look-behind.\n  (?<=A|B) ==> (?<=A)|(?<=B)\n  (?<!A|B) ==> (?<!A)(?<!B)\n*/\nstatic int\ndivide_look_behind_alternatives(Node* node)\n{\n  Node *head, *np, *insert_node;\n  AnchorNode* an = ANCHOR_(node);\n  int anc_type = an->type;\n\n  head = NODE_ANCHOR_BODY(an);\n  np = NODE_CAR(head);\n  swap_node(node, head);\n  NODE_CAR(node) = head;\n  NODE_BODY(head) = np;\n\n  np = node;\n  while (IS_NOT_NULL(np = NODE_CDR(np))) {\n    insert_node = onig_node_new_anchor(anc_type, an->ascii_mode);\n    CHECK_NULL_RETURN_MEMERR(insert_node);\n    NODE_BODY(insert_node) = NODE_CAR(np);\n    NODE_CAR(np) = insert_node;\n  }\n\n  if (anc_type == ANCR_LOOK_BEHIND_NOT) {\n    np = node;\n    do {\n      NODE_SET_TYPE(np, NODE_LIST);  /* alt -> list */\n    } while (IS_NOT_NULL(np = NODE_CDR(np)));\n  }\n  return 0;\n}\n\nstatic int\nsetup_look_behind(Node* node, regex_t* reg, ScanEnv* env)\n{\n  int r, len;\n  AnchorNode* an = ANCHOR_(node);\n\n  r = get_char_len_node(NODE_ANCHOR_BODY(an), reg, &len);\n  if (r == 0)\n    an->char_len = len;\n  else if (r == GET_CHAR_LEN_VARLEN)\n    r = ONIGERR_INVALID_LOOK_BEHIND_PATTERN;\n  else if (r == GET_CHAR_LEN_TOP_ALT_VARLEN) {\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_DIFFERENT_LEN_ALT_LOOK_BEHIND))\n      r = divide_look_behind_alternatives(node);\n    else\n      r = ONIGERR_INVALID_LOOK_BEHIND_PATTERN;\n  }\n\n  return r;\n}\n\nstatic int\nnext_setup(Node* node, Node* next_node, regex_t* reg)\n{\n  NodeType type;\n\n retry:\n  type = NODE_TYPE(node);\n  if (type == NODE_QUANT) {\n    QuantNode* qn = QUANT_(node);\n    if (qn->greedy && IS_REPEAT_INFINITE(qn->upper)) {\n#ifdef USE_QUANT_PEEK_NEXT\n      Node* n = get_head_value_node(next_node, 1, reg);\n      /* '\\0': for UTF-16BE etc... */\n      if (IS_NOT_NULL(n) && STR_(n)->s[0] != '\\0') {\n        qn->next_head_exact = n;\n      }\n#endif\n      /* automatic posseivation a*b ==> (?>a*)b */\n      if (qn->lower <= 1) {\n        if (NODE_IS_SIMPLE_TYPE(NODE_BODY(node))) {\n          Node *x, *y;\n          x = get_head_value_node(NODE_BODY(node), 0, reg);\n          if (IS_NOT_NULL(x)) {\n            y = get_head_value_node(next_node,  0, reg);\n            if (IS_NOT_NULL(y) && is_exclusive(x, y, reg)) {\n              Node* en = onig_node_new_bag(BAG_STOP_BACKTRACK);\n              CHECK_NULL_RETURN_MEMERR(en);\n              NODE_STATUS_ADD(en, STOP_BT_SIMPLE_REPEAT);\n              swap_node(node, en);\n              NODE_BODY(node) = en;\n            }\n          }\n        }\n      }\n    }\n  }\n  else if (type == NODE_BAG) {\n    BagNode* en = BAG_(node);\n    if (en->type == BAG_MEMORY) {\n      node = NODE_BODY(node);\n      goto retry;\n    }\n  }\n  return 0;\n}\n\n\nstatic int\nupdate_string_node_case_fold(regex_t* reg, Node *node)\n{\n  UChar *p, *end, buf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  UChar *sbuf, *ebuf, *sp;\n  int r, i, len, sbuf_size;\n  StrNode* sn = STR_(node);\n\n  end = sn->end;\n  sbuf_size = (int )(end - sn->s) * 2;\n  sbuf = (UChar* )xmalloc(sbuf_size);\n  CHECK_NULL_RETURN_MEMERR(sbuf);\n  ebuf = sbuf + sbuf_size;\n\n  sp = sbuf;\n  p = sn->s;\n  while (p < end) {\n    len = ONIGENC_MBC_CASE_FOLD(reg->enc, reg->case_fold_flag, &p, end, buf);\n    for (i = 0; i < len; i++) {\n      if (sp >= ebuf) {\n        sbuf = (UChar* )xrealloc(sbuf, sbuf_size * 2);\n        CHECK_NULL_RETURN_MEMERR(sbuf);\n        sp = sbuf + sbuf_size;\n        sbuf_size *= 2;\n        ebuf = sbuf + sbuf_size;\n      }\n\n      *sp++ = buf[i];\n    }\n  }\n\n  r = onig_node_str_set(node, sbuf, sp);\n  if (r != 0) {\n    xfree(sbuf);\n    return r;\n  }\n\n  xfree(sbuf);\n  return 0;\n}\n\nstatic int\nexpand_case_fold_make_rem_string(Node** rnode, UChar *s, UChar *end, regex_t* reg)\n{\n  int r;\n  Node *node;\n\n  node = onig_node_new_str(s, end);\n  if (IS_NULL(node)) return ONIGERR_MEMORY;\n\n  r = update_string_node_case_fold(reg, node);\n  if (r != 0) {\n    onig_node_free(node);\n    return r;\n  }\n\n  NODE_STRING_SET_AMBIG(node);\n  NODE_STRING_SET_DONT_GET_OPT_INFO(node);\n  *rnode = node;\n  return 0;\n}\n\nstatic int\nexpand_case_fold_string_alt(int item_num, OnigCaseFoldCodeItem items[], UChar *p,\n                            int slen, UChar *end, regex_t* reg, Node **rnode)\n{\n  int r, i, j;\n  int len;\n  int varlen;\n  Node *anode, *var_anode, *snode, *xnode, *an;\n  UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n\n  *rnode = var_anode = NULL_NODE;\n\n  varlen = 0;\n  for (i = 0; i < item_num; i++) {\n    if (items[i].byte_len != slen) {\n      varlen = 1;\n      break;\n    }\n  }\n\n  if (varlen != 0) {\n    *rnode = var_anode = onig_node_new_alt(NULL_NODE, NULL_NODE);\n    if (IS_NULL(var_anode)) return ONIGERR_MEMORY;\n\n    xnode = onig_node_new_list(NULL, NULL);\n    if (IS_NULL(xnode)) goto mem_err;\n    NODE_CAR(var_anode) = xnode;\n\n    anode = onig_node_new_alt(NULL_NODE, NULL_NODE);\n    if (IS_NULL(anode)) goto mem_err;\n    NODE_CAR(xnode) = anode;\n  }\n  else {\n    *rnode = anode = onig_node_new_alt(NULL_NODE, NULL_NODE);\n    if (IS_NULL(anode)) return ONIGERR_MEMORY;\n  }\n\n  snode = onig_node_new_str(p, p + slen);\n  if (IS_NULL(snode)) goto mem_err;\n\n  NODE_CAR(anode) = snode;\n\n  for (i = 0; i < item_num; i++) {\n    snode = onig_node_new_str(NULL, NULL);\n    if (IS_NULL(snode)) goto mem_err;\n\n    for (j = 0; j < items[i].code_len; j++) {\n      len = ONIGENC_CODE_TO_MBC(reg->enc, items[i].code[j], buf);\n      if (len < 0) {\n        r = len;\n        goto mem_err2;\n      }\n\n      r = onig_node_str_cat(snode, buf, buf + len);\n      if (r != 0) goto mem_err2;\n    }\n\n    an = onig_node_new_alt(NULL_NODE, NULL_NODE);\n    if (IS_NULL(an)) {\n      goto mem_err2;\n    }\n\n    if (items[i].byte_len != slen && IS_NOT_NULL(var_anode)) {\n      Node *rem;\n      UChar *q = p + items[i].byte_len;\n\n      if (q < end) {\n        r = expand_case_fold_make_rem_string(&rem, q, end, reg);\n        if (r != 0) {\n          onig_node_free(an);\n          goto mem_err2;\n        }\n\n        xnode = onig_node_list_add(NULL_NODE, snode);\n        if (IS_NULL(xnode)) {\n          onig_node_free(an);\n          onig_node_free(rem);\n          goto mem_err2;\n        }\n        if (IS_NULL(onig_node_list_add(xnode, rem))) {\n          onig_node_free(an);\n          onig_node_free(xnode);\n          onig_node_free(rem);\n          goto mem_err;\n        }\n\n        NODE_CAR(an) = xnode;\n      }\n      else {\n        NODE_CAR(an) = snode;\n      }\n\n      NODE_CDR(var_anode) = an;\n      var_anode = an;\n    }\n    else {\n      NODE_CAR(an)     = snode;\n      NODE_CDR(anode) = an;\n      anode = an;\n    }\n  }\n\n  return varlen;\n\n mem_err2:\n  onig_node_free(snode);\n\n mem_err:\n  onig_node_free(*rnode);\n\n  return ONIGERR_MEMORY;\n}\n\nstatic int\nis_good_case_fold_items_for_search(OnigEncoding enc, int slen,\n                                   int n, OnigCaseFoldCodeItem items[])\n{\n  int i, len;\n  UChar buf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n  for (i = 0; i < n; i++) {\n    OnigCaseFoldCodeItem* item = items + i;\n\n    if (item->code_len != 1)    return 0;\n    if (item->byte_len != slen) return 0;\n    len = ONIGENC_CODE_TO_MBC(enc, item->code[0], buf);\n    if (len != slen) return 0;\n  }\n\n  return 1;\n}\n\n#define THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION  8\n\nstatic int\nexpand_case_fold_string(Node* node, regex_t* reg, int state)\n{\n  int r, n, len, alt_num;\n  int fold_len;\n  int prev_is_ambig, prev_is_good, is_good, is_in_look_behind;\n  UChar *start, *end, *p;\n  UChar* foldp;\n  Node *top_root, *root, *snode, *prev_node;\n  OnigCaseFoldCodeItem items[ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM];\n  UChar buf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  StrNode* sn;\n\n  if (NODE_STRING_IS_AMBIG(node)) return 0;\n\n  sn = STR_(node);\n\n  start = sn->s;\n  end   = sn->end;\n  if (start >= end) return 0;\n\n  is_in_look_behind = (state & IN_LOOK_BEHIND) != 0;\n\n  r = 0;\n  top_root = root = prev_node = snode = NULL_NODE;\n  alt_num = 1;\n  p = start;\n  while (p < end) {\n    n = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(reg->enc, reg->case_fold_flag,\n                                           p, end, items);\n    if (n < 0) {\n      r = n;\n      goto err;\n    }\n\n    len = enclen(reg->enc, p);\n    is_good = is_good_case_fold_items_for_search(reg->enc, len, n, items);\n\n    if (is_in_look_behind ||\n        (IS_NOT_NULL(snode) ||\n         (is_good\n          /* expand single char case: ex. /(?i:a)/ */\n          && !(p == start && p + len >= end)))) {\n      if (IS_NULL(snode)) {\n        if (IS_NULL(root) && IS_NOT_NULL(prev_node)) {\n          top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n          if (IS_NULL(root)) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n\n        prev_node = snode = onig_node_new_str(NULL, NULL);\n        if (IS_NULL(snode)) goto mem_err;\n        if (IS_NOT_NULL(root)) {\n          if (IS_NULL(onig_node_list_add(root, snode))) {\n            onig_node_free(snode);\n            goto mem_err;\n          }\n        }\n\n        prev_is_ambig = -1; /* -1: new */\n        prev_is_good  =  0; /* escape compiler warning */\n      }\n      else {\n        prev_is_ambig = NODE_STRING_IS_AMBIG(snode);\n        prev_is_good  = NODE_STRING_IS_GOOD_AMBIG(snode);\n      }\n\n      if (n != 0) {\n        foldp = p;\n        fold_len = ONIGENC_MBC_CASE_FOLD(reg->enc, reg->case_fold_flag,\n                                         &foldp, end, buf);\n        foldp = buf;\n      }\n      else {\n        foldp = p; fold_len = len;\n      }\n\n      if ((prev_is_ambig == 0 && n != 0) ||\n          (prev_is_ambig > 0 && (n == 0 || prev_is_good != is_good))) {\n        if (IS_NULL(root) /* && IS_NOT_NULL(prev_node) */) {\n          top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n          if (IS_NULL(root)) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n\n        prev_node = snode = onig_node_new_str(foldp, foldp + fold_len);\n        if (IS_NULL(snode)) goto mem_err;\n        if (IS_NULL(onig_node_list_add(root, snode))) {\n          onig_node_free(snode);\n          goto mem_err;\n        }\n      }\n      else {\n        r = onig_node_str_cat(snode, foldp, foldp + fold_len);\n        if (r != 0) goto err;\n      }\n\n      if (n != 0) NODE_STRING_SET_AMBIG(snode);\n      if (is_good != 0) NODE_STRING_SET_GOOD_AMBIG(snode);\n    }\n    else {\n      alt_num *= (n + 1);\n      if (alt_num > THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION) break;\n\n      if (IS_NULL(root) && IS_NOT_NULL(prev_node)) {\n        top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n        if (IS_NULL(root)) {\n          onig_node_free(prev_node);\n          goto mem_err;\n        }\n      }\n\n      r = expand_case_fold_string_alt(n, items, p, len, end, reg, &prev_node);\n      if (r < 0) goto mem_err;\n      if (r == 1) {\n        if (IS_NULL(root)) {\n          top_root = prev_node;\n        }\n        else {\n          if (IS_NULL(onig_node_list_add(root, prev_node))) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n\n        root = NODE_CAR(prev_node);\n      }\n      else { /* r == 0 */\n        if (IS_NOT_NULL(root)) {\n          if (IS_NULL(onig_node_list_add(root, prev_node))) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n      }\n\n      snode = NULL_NODE;\n    }\n\n    p += len;\n  }\n\n  if (p < end) {\n    Node *srem;\n\n    r = expand_case_fold_make_rem_string(&srem, p, end, reg);\n    if (r != 0) goto mem_err;\n\n    if (IS_NOT_NULL(prev_node) && IS_NULL(root)) {\n      top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n      if (IS_NULL(root)) {\n        onig_node_free(srem);\n        onig_node_free(prev_node);\n        goto mem_err;\n      }\n    }\n\n    if (IS_NULL(root)) {\n      prev_node = srem;\n    }\n    else {\n      if (IS_NULL(onig_node_list_add(root, srem))) {\n        onig_node_free(srem);\n        goto mem_err;\n      }\n    }\n  }\n\n  /* ending */\n  top_root = (IS_NOT_NULL(top_root) ? top_root : prev_node);\n  swap_node(node, top_root);\n  onig_node_free(top_root);\n  return 0;\n\n mem_err:\n  r = ONIGERR_MEMORY;\n\n err:\n  onig_node_free(top_root);\n  return r;\n}\n\n#ifdef USE_INSISTENT_CHECK_CAPTURES_IN_EMPTY_REPEAT\nstatic enum BodyEmpty\nquantifiers_memory_node_info(Node* node)\n{\n  int r = BODY_IS_EMPTY;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    {\n      int v;\n      do {\n        v = quantifiers_memory_node_info(NODE_CAR(node));\n        if (v > r) r = v;\n      } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    }\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    if (NODE_IS_RECURSION(node)) {\n      return BODY_IS_EMPTY_REC; /* tiny version */\n    }\n    else\n      r = quantifiers_memory_node_info(NODE_BODY(node));\n    break;\n#endif\n\n  case NODE_QUANT:\n    {\n      QuantNode* qn = QUANT_(node);\n      if (qn->upper != 0) {\n        r = quantifiers_memory_node_info(NODE_BODY(node));\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n      switch (en->type) {\n      case BAG_MEMORY:\n        if (NODE_IS_RECURSION(node)) {\n          return BODY_IS_EMPTY_REC;\n        }\n        return BODY_IS_EMPTY_MEM;\n        break;\n\n      case BAG_OPTION:\n      case BAG_STOP_BACKTRACK:\n        r = quantifiers_memory_node_info(NODE_BODY(node));\n        break;\n      case BAG_IF_ELSE:\n        {\n          int v;\n          r = quantifiers_memory_node_info(NODE_BODY(node));\n          if (IS_NOT_NULL(en->te.Then)) {\n            v = quantifiers_memory_node_info(en->te.Then);\n            if (v > r) r = v;\n          }\n          if (IS_NOT_NULL(en->te.Else)) {\n            v = quantifiers_memory_node_info(en->te.Else);\n            if (v > r) r = v;\n          }\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_BACKREF:\n  case NODE_STRING:\n  case NODE_CTYPE:\n  case NODE_CCLASS:\n  case NODE_ANCHOR:\n  case NODE_GIMMICK:\n  default:\n    break;\n  }\n\n  return r;\n}\n#endif /* USE_INSISTENT_CHECK_CAPTURES_IN_EMPTY_REPEAT */\n\n\n#ifdef USE_CALL\n\n#ifdef __GNUC__\n__inline\n#endif\nstatic int\nsetup_call_node_call(CallNode* cn, ScanEnv* env, int state)\n{\n  MemEnv* mem_env = SCANENV_MEMENV(env);\n\n  if (cn->by_number != 0) {\n    int gnum = cn->group_num;\n\n    if (env->num_named > 0 &&\n        IS_SYNTAX_BV(env->syntax, ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP) &&\n        ! ONIG_IS_OPTION_ON(env->options, ONIG_OPTION_CAPTURE_GROUP)) {\n      return ONIGERR_NUMBERED_BACKREF_OR_CALL_NOT_ALLOWED;\n    }\n\n    if (gnum > env->num_mem) {\n      onig_scan_env_set_error_string(env, ONIGERR_UNDEFINED_GROUP_REFERENCE,\n                                     cn->name, cn->name_end);\n      return ONIGERR_UNDEFINED_GROUP_REFERENCE;\n    }\n\n  set_call_attr:\n    NODE_CALL_BODY(cn) = mem_env[cn->group_num].node;\n    if (IS_NULL(NODE_CALL_BODY(cn))) {\n      onig_scan_env_set_error_string(env, ONIGERR_UNDEFINED_NAME_REFERENCE,\n                                     cn->name, cn->name_end);\n      return ONIGERR_UNDEFINED_NAME_REFERENCE;\n    }\n  }\n  else {\n    int *refs;\n\n    int n = onig_name_to_group_numbers(env->reg, cn->name, cn->name_end, &refs);\n    if (n <= 0) {\n      onig_scan_env_set_error_string(env, ONIGERR_UNDEFINED_NAME_REFERENCE,\n                                     cn->name, cn->name_end);\n      return ONIGERR_UNDEFINED_NAME_REFERENCE;\n    }\n    else if (n > 1) {\n      onig_scan_env_set_error_string(env, ONIGERR_MULTIPLEX_DEFINITION_NAME_CALL,\n                                     cn->name, cn->name_end);\n      return ONIGERR_MULTIPLEX_DEFINITION_NAME_CALL;\n    }\n    else {\n      cn->group_num = refs[0];\n      goto set_call_attr;\n    }\n  }\n\n  return 0;\n}\n\nstatic void\nsetup_call2_call(Node* node)\n{\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    do {\n      setup_call2_call(NODE_CAR(node));\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_QUANT:\n    setup_call2_call(NODE_BODY(node));\n    break;\n\n  case NODE_ANCHOR:\n    if (ANCHOR_HAS_BODY(ANCHOR_(node)))\n      setup_call2_call(NODE_BODY(node));\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      if (en->type == BAG_MEMORY) {\n        if (! NODE_IS_MARK1(node)) {\n          NODE_STATUS_ADD(node, MARK1);\n          setup_call2_call(NODE_BODY(node));\n          NODE_STATUS_REMOVE(node, MARK1);\n        }\n      }\n      else if (en->type == BAG_IF_ELSE) {\n        setup_call2_call(NODE_BODY(node));\n        if (IS_NOT_NULL(en->te.Then))\n          setup_call2_call(en->te.Then);\n        if (IS_NOT_NULL(en->te.Else))\n          setup_call2_call(en->te.Else);\n      }\n      else {\n        setup_call2_call(NODE_BODY(node));\n      }\n    }\n    break;\n\n  case NODE_CALL:\n    if (! NODE_IS_MARK1(node)) {\n      NODE_STATUS_ADD(node, MARK1);\n      {\n        CallNode* cn = CALL_(node);\n        Node* called = NODE_CALL_BODY(cn);\n\n        cn->entry_count++;\n\n        NODE_STATUS_ADD(called, CALLED);\n        BAG_(called)->m.entry_count++;\n        setup_call2_call(called);\n      }\n      NODE_STATUS_REMOVE(node, MARK1);\n    }\n    break;\n\n  default:\n    break;\n  }\n}\n\nstatic int\nsetup_call(Node* node, ScanEnv* env, int state)\n{\n  int r;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    do {\n      r = setup_call(NODE_CAR(node), env, state);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_QUANT:\n    if (QUANT_(node)->upper == 0)\n      state |= IN_ZERO_REPEAT;\n\n    r = setup_call(NODE_BODY(node), env, state);\n    break;\n\n  case NODE_ANCHOR:\n    if (ANCHOR_HAS_BODY(ANCHOR_(node)))\n      r = setup_call(NODE_BODY(node), env, state);\n    else\n      r = 0;\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      if (en->type == BAG_MEMORY) {\n        if ((state & IN_ZERO_REPEAT) != 0) {\n          NODE_STATUS_ADD(node, IN_ZERO_REPEAT);\n          BAG_(node)->m.entry_count--;\n        }\n        r = setup_call(NODE_BODY(node), env, state);\n      }\n      else if (en->type == BAG_IF_ELSE) {\n        r = setup_call(NODE_BODY(node), env, state);\n        if (r != 0) return r;\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = setup_call(en->te.Then, env, state);\n          if (r != 0) return r;\n        }\n        if (IS_NOT_NULL(en->te.Else))\n          r = setup_call(en->te.Else, env, state);\n      }\n      else\n        r = setup_call(NODE_BODY(node), env, state);\n    }\n    break;\n\n  case NODE_CALL:\n    if ((state & IN_ZERO_REPEAT) != 0) {\n      NODE_STATUS_ADD(node, IN_ZERO_REPEAT);\n      CALL_(node)->entry_count--;\n    }\n\n    r = setup_call_node_call(CALL_(node), env, state);\n    break;\n\n  default:\n    r = 0;\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nsetup_call2(Node* node)\n{\n  int r = 0;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    do {\n      r = setup_call2(NODE_CAR(node));\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_QUANT:\n    if (QUANT_(node)->upper != 0)\n      r = setup_call2(NODE_BODY(node));\n    break;\n\n  case NODE_ANCHOR:\n    if (ANCHOR_HAS_BODY(ANCHOR_(node)))\n      r = setup_call2(NODE_BODY(node));\n    break;\n\n  case NODE_BAG:\n    if (! NODE_IS_IN_ZERO_REPEAT(node))\n      r = setup_call2(NODE_BODY(node));\n\n    {\n      BagNode* en = BAG_(node);\n\n      if (r != 0) return r;\n      if (en->type == BAG_IF_ELSE) {\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = setup_call2(en->te.Then);\n          if (r != 0) return r;\n        }\n        if (IS_NOT_NULL(en->te.Else))\n          r = setup_call2(en->te.Else);\n      }\n    }\n    break;\n\n  case NODE_CALL:\n    if (! NODE_IS_IN_ZERO_REPEAT(node)) {\n      setup_call2_call(node);\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  return r;\n}\n\n\nstatic void\nsetup_called_state_call(Node* node, int state)\n{\n  switch (NODE_TYPE(node)) {\n  case NODE_ALT:\n    state |= IN_ALT;\n    /* fall */\n  case NODE_LIST:\n    do {\n      setup_called_state_call(NODE_CAR(node), state);\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_QUANT:\n    {\n      QuantNode* qn = QUANT_(node);\n\n      if (IS_REPEAT_INFINITE(qn->upper) || qn->upper >= 2)\n        state |= IN_REAL_REPEAT;\n      if (qn->lower != qn->upper)\n        state |= IN_VAR_REPEAT;\n\n      setup_called_state_call(NODE_QUANT_BODY(qn), state);\n    }\n    break;\n\n  case NODE_ANCHOR:\n    {\n      AnchorNode* an = ANCHOR_(node);\n\n      switch (an->type) {\n      case ANCR_PREC_READ_NOT:\n      case ANCR_LOOK_BEHIND_NOT:\n        state |= IN_NOT;\n        /* fall */\n      case ANCR_PREC_READ:\n      case ANCR_LOOK_BEHIND:\n        setup_called_state_call(NODE_ANCHOR_BODY(an), state);\n        break;\n      default:\n        break;\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      if (en->type == BAG_MEMORY) {\n        if (NODE_IS_MARK1(node)) {\n          if ((~en->m.called_state & state) != 0) {\n            en->m.called_state |= state;\n            setup_called_state_call(NODE_BODY(node), state);\n          }\n        }\n        else {\n          NODE_STATUS_ADD(node, MARK1);\n          en->m.called_state |= state;\n          setup_called_state_call(NODE_BODY(node), state);\n          NODE_STATUS_REMOVE(node, MARK1);\n        }\n      }\n      else if (en->type == BAG_IF_ELSE) {\n        if (IS_NOT_NULL(en->te.Then)) {\n          setup_called_state_call(en->te.Then, state);\n        }\n        if (IS_NOT_NULL(en->te.Else))\n          setup_called_state_call(en->te.Else, state);\n      }\n      else {\n        setup_called_state_call(NODE_BODY(node), state);\n      }\n    }\n    break;\n\n  case NODE_CALL:\n    setup_called_state_call(NODE_BODY(node), state);\n    break;\n\n  default:\n    break;\n  }\n}\n\nstatic void\nsetup_called_state(Node* node, int state)\n{\n  switch (NODE_TYPE(node)) {\n  case NODE_ALT:\n    state |= IN_ALT;\n    /* fall */\n  case NODE_LIST:\n    do {\n      setup_called_state(NODE_CAR(node), state);\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    setup_called_state_call(node, state);\n    break;\n#endif\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      switch (en->type) {\n      case BAG_MEMORY:\n        if (en->m.entry_count > 1)\n          state |= IN_MULTI_ENTRY;\n\n        en->m.called_state |= state;\n        /* fall */\n      case BAG_OPTION:\n      case BAG_STOP_BACKTRACK:\n        setup_called_state(NODE_BODY(node), state);\n        break;\n      case BAG_IF_ELSE:\n        setup_called_state(NODE_BODY(node), state);\n        if (IS_NOT_NULL(en->te.Then))\n          setup_called_state(en->te.Then, state);\n        if (IS_NOT_NULL(en->te.Else))\n          setup_called_state(en->te.Else, state);\n        break;\n      }\n    }\n    break;\n\n  case NODE_QUANT:\n    {\n      QuantNode* qn = QUANT_(node);\n\n      if (IS_REPEAT_INFINITE(qn->upper) || qn->upper >= 2)\n        state |= IN_REAL_REPEAT;\n      if (qn->lower != qn->upper)\n        state |= IN_VAR_REPEAT;\n\n      setup_called_state(NODE_QUANT_BODY(qn), state);\n    }\n    break;\n\n  case NODE_ANCHOR:\n    {\n      AnchorNode* an = ANCHOR_(node);\n\n      switch (an->type) {\n      case ANCR_PREC_READ_NOT:\n      case ANCR_LOOK_BEHIND_NOT:\n        state |= IN_NOT;\n        /* fall */\n      case ANCR_PREC_READ:\n      case ANCR_LOOK_BEHIND:\n        setup_called_state(NODE_ANCHOR_BODY(an), state);\n        break;\n      default:\n        break;\n      }\n    }\n    break;\n\n  case NODE_BACKREF:\n  case NODE_STRING:\n  case NODE_CTYPE:\n  case NODE_CCLASS:\n  case NODE_GIMMICK:\n  default:\n    break;\n  }\n}\n\n#endif  /* USE_CALL */\n\n\nstatic int setup_tree(Node* node, regex_t* reg, int state, ScanEnv* env);\n\n#ifdef __GNUC__\n__inline\n#endif\nstatic int\nsetup_anchor(Node* node, regex_t* reg, int state, ScanEnv* env)\n{\n/* allowed node types in look-behind */\n#define ALLOWED_TYPE_IN_LB \\\n  ( NODE_BIT_LIST | NODE_BIT_ALT | NODE_BIT_STRING | NODE_BIT_CCLASS \\\n  | NODE_BIT_CTYPE | NODE_BIT_ANCHOR | NODE_BIT_BAG | NODE_BIT_QUANT \\\n  | NODE_BIT_CALL | NODE_BIT_GIMMICK)\n\n#define ALLOWED_BAG_IN_LB       ( 1<<BAG_MEMORY | 1<<BAG_OPTION | 1<<BAG_IF_ELSE )\n#define ALLOWED_BAG_IN_LB_NOT   ( 1<<BAG_OPTION | 1<<BAG_IF_ELSE )\n\n#define ALLOWED_ANCHOR_IN_LB \\\n  ( ANCR_LOOK_BEHIND | ANCR_BEGIN_LINE | ANCR_END_LINE | ANCR_BEGIN_BUF \\\n  | ANCR_BEGIN_POSITION | ANCR_WORD_BOUNDARY | ANCR_NO_WORD_BOUNDARY \\\n  | ANCR_WORD_BEGIN | ANCR_WORD_END \\\n  | ANCR_TEXT_SEGMENT_BOUNDARY | ANCR_NO_TEXT_SEGMENT_BOUNDARY )\n\n#define ALLOWED_ANCHOR_IN_LB_NOT \\\n  ( ANCR_LOOK_BEHIND | ANCR_LOOK_BEHIND_NOT | ANCR_BEGIN_LINE \\\n  | ANCR_END_LINE | ANCR_BEGIN_BUF | ANCR_BEGIN_POSITION | ANCR_WORD_BOUNDARY \\\n  | ANCR_NO_WORD_BOUNDARY | ANCR_WORD_BEGIN | ANCR_WORD_END \\\n  | ANCR_TEXT_SEGMENT_BOUNDARY | ANCR_NO_TEXT_SEGMENT_BOUNDARY )\n\n  int r;\n  AnchorNode* an = ANCHOR_(node);\n\n  switch (an->type) {\n  case ANCR_PREC_READ:\n    r = setup_tree(NODE_ANCHOR_BODY(an), reg, state, env);\n    break;\n  case ANCR_PREC_READ_NOT:\n    r = setup_tree(NODE_ANCHOR_BODY(an), reg, (state | IN_NOT), env);\n    break;\n\n  case ANCR_LOOK_BEHIND:\n    {\n      r = check_type_tree(NODE_ANCHOR_BODY(an), ALLOWED_TYPE_IN_LB,\n                          ALLOWED_BAG_IN_LB, ALLOWED_ANCHOR_IN_LB);\n      if (r < 0) return r;\n      if (r > 0) return ONIGERR_INVALID_LOOK_BEHIND_PATTERN;\n      r = setup_tree(NODE_ANCHOR_BODY(an), reg, (state|IN_LOOK_BEHIND), env);\n      if (r != 0) return r;\n      r = setup_look_behind(node, reg, env);\n    }\n    break;\n\n  case ANCR_LOOK_BEHIND_NOT:\n    {\n      r = check_type_tree(NODE_ANCHOR_BODY(an), ALLOWED_TYPE_IN_LB,\n                          ALLOWED_BAG_IN_LB_NOT, ALLOWED_ANCHOR_IN_LB_NOT);\n      if (r < 0) return r;\n      if (r > 0) return ONIGERR_INVALID_LOOK_BEHIND_PATTERN;\n      r = setup_tree(NODE_ANCHOR_BODY(an), reg, (state|IN_NOT|IN_LOOK_BEHIND),\n                     env);\n      if (r != 0) return r;\n      r = setup_look_behind(node, reg, env);\n    }\n    break;\n\n  default:\n    r = 0;\n    break;\n  }\n\n  return r;\n}\n\n#ifdef __GNUC__\n__inline\n#endif\nstatic int\nsetup_quant(Node* node, regex_t* reg, int state, ScanEnv* env)\n{\n  int r;\n  OnigLen d;\n  QuantNode* qn = QUANT_(node);\n  Node* body = NODE_BODY(node);\n\n  if ((state & IN_REAL_REPEAT) != 0) {\n    NODE_STATUS_ADD(node, IN_REAL_REPEAT);\n  }\n  if ((state & IN_MULTI_ENTRY) != 0) {\n    NODE_STATUS_ADD(node, IN_MULTI_ENTRY);\n  }\n\n  if (IS_REPEAT_INFINITE(qn->upper) || qn->upper >= 1) {\n    d = tree_min_len(body, env);\n    if (d == 0) {\n#ifdef USE_INSISTENT_CHECK_CAPTURES_IN_EMPTY_REPEAT\n      qn->empty_info = quantifiers_memory_node_info(body);\n      if (qn->empty_info == BODY_IS_EMPTY_REC) {\n        if (NODE_TYPE(body) == NODE_BAG &&\n            BAG_(body)->type == BAG_MEMORY) {\n          MEM_STATUS_ON(env->bt_mem_end, BAG_(body)->m.regnum);\n        }\n      }\n#else\n      qn->empty_info = BODY_IS_EMPTY;\n#endif\n    }\n  }\n\n  if (IS_REPEAT_INFINITE(qn->upper) || qn->upper >= 2)\n    state |= IN_REAL_REPEAT;\n  if (qn->lower != qn->upper)\n    state |= IN_VAR_REPEAT;\n\n  r = setup_tree(body, reg, state, env);\n  if (r != 0) return r;\n\n  /* expand string */\n#define EXPAND_STRING_MAX_LENGTH  100\n  if (NODE_TYPE(body) == NODE_STRING) {\n    if (!IS_REPEAT_INFINITE(qn->lower) && qn->lower == qn->upper &&\n        qn->lower > 1 && qn->lower <= EXPAND_STRING_MAX_LENGTH) {\n      int len = NODE_STRING_LEN(body);\n      StrNode* sn = STR_(body);\n\n      if (len * qn->lower <= EXPAND_STRING_MAX_LENGTH) {\n        int i, n = qn->lower;\n        onig_node_conv_to_str_node(node, STR_(body)->flag);\n        for (i = 0; i < n; i++) {\n          r = onig_node_str_cat(node, sn->s, sn->end);\n          if (r != 0) return r;\n        }\n        onig_node_free(body);\n        return r;\n      }\n    }\n  }\n\n  if (qn->greedy && (qn->empty_info == BODY_IS_NOT_EMPTY)) {\n    if (NODE_TYPE(body) == NODE_QUANT) {\n      QuantNode* tqn = QUANT_(body);\n      if (IS_NOT_NULL(tqn->head_exact)) {\n        qn->head_exact  = tqn->head_exact;\n        tqn->head_exact = NULL;\n      }\n    }\n    else {\n      qn->head_exact = get_head_value_node(NODE_BODY(node), 1, reg);\n    }\n  }\n\n  return r;\n}\n\n/* setup_tree does the following work.\n 1. check empty loop. (set qn->empty_info)\n 2. expand ignore-case in char class.\n 3. set memory status bit flags. (reg->mem_stats)\n 4. set qn->head_exact for [push, exact] -> [push_or_jump_exact1, exact].\n 5. find invalid patterns in look-behind.\n 6. expand repeated string.\n */\nstatic int\nsetup_tree(Node* node, regex_t* reg, int state, ScanEnv* env)\n{\n  int r = 0;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n    {\n      Node* prev = NULL_NODE;\n      do {\n        r = setup_tree(NODE_CAR(node), reg, state, env);\n        if (IS_NOT_NULL(prev) && r == 0) {\n          r = next_setup(prev, NODE_CAR(node), reg);\n        }\n        prev = NODE_CAR(node);\n      } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    }\n    break;\n\n  case NODE_ALT:\n    do {\n      r = setup_tree(NODE_CAR(node), reg, (state | IN_ALT), env);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_STRING:\n    if (IS_IGNORECASE(reg->options) && !NODE_STRING_IS_RAW(node)) {\n      r = expand_case_fold_string(node, reg, state);\n    }\n    break;\n\n  case NODE_BACKREF:\n    {\n      int i;\n      int* p;\n      BackRefNode* br = BACKREF_(node);\n      p = BACKREFS_P(br);\n      for (i = 0; i < br->back_num; i++) {\n        if (p[i] > env->num_mem)  return ONIGERR_INVALID_BACKREF;\n        MEM_STATUS_ON(env->backrefed_mem, p[i]);\n        MEM_STATUS_ON(env->bt_mem_start, p[i]);\n#ifdef USE_BACKREF_WITH_LEVEL\n        if (NODE_IS_NEST_LEVEL(node)) {\n          MEM_STATUS_ON(env->bt_mem_end, p[i]);\n        }\n#endif\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      switch (en->type) {\n      case BAG_OPTION:\n        {\n          OnigOptionType options = reg->options;\n          reg->options = BAG_(node)->o.options;\n          r = setup_tree(NODE_BODY(node), reg, state, env);\n          reg->options = options;\n        }\n        break;\n\n      case BAG_MEMORY:\n#ifdef USE_CALL\n        state |= en->m.called_state;\n#endif\n\n        if ((state & (IN_ALT | IN_NOT | IN_VAR_REPEAT | IN_MULTI_ENTRY)) != 0\n            || NODE_IS_RECURSION(node)) {\n          MEM_STATUS_ON(env->bt_mem_start, en->m.regnum);\n        }\n        r = setup_tree(NODE_BODY(node), reg, state, env);\n        break;\n\n      case BAG_STOP_BACKTRACK:\n        {\n          Node* target = NODE_BODY(node);\n          r = setup_tree(target, reg, state, env);\n          if (NODE_TYPE(target) == NODE_QUANT) {\n            QuantNode* tqn = QUANT_(target);\n            if (IS_REPEAT_INFINITE(tqn->upper) && tqn->lower <= 1 &&\n                tqn->greedy != 0) {  /* (?>a*), a*+ etc... */\n              if (NODE_IS_SIMPLE_TYPE(NODE_BODY(target)))\n                NODE_STATUS_ADD(node, STOP_BT_SIMPLE_REPEAT);\n            }\n          }\n        }\n        break;\n\n      case BAG_IF_ELSE:\n        r = setup_tree(NODE_BODY(node), reg, (state | IN_ALT), env);\n        if (r != 0) return r;\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = setup_tree(en->te.Then, reg, (state | IN_ALT), env);\n          if (r != 0) return r;\n        }\n        if (IS_NOT_NULL(en->te.Else))\n          r = setup_tree(en->te.Else, reg, (state | IN_ALT), env);\n        break;\n      }\n    }\n    break;\n\n  case NODE_QUANT:\n    r = setup_quant(node, reg, state, env);\n    break;\n\n  case NODE_ANCHOR:\n    r = setup_anchor(node, reg, state, env);\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n#endif\n  case NODE_CTYPE:\n  case NODE_CCLASS:\n  case NODE_GIMMICK:\n  default:\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nset_sunday_quick_search_or_bmh_skip_table(regex_t* reg, int case_expand,\n                                          UChar* s, UChar* end,\n                                          UChar skip[], int* roffset)\n{\n  int i, j, k, len, offset;\n  int n, clen;\n  UChar* p;\n  OnigEncoding enc;\n  OnigCaseFoldCodeItem items[ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM];\n  UChar buf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n  enc = reg->enc;\n  offset = ENC_GET_SKIP_OFFSET(enc);\n  if (offset == ENC_SKIP_OFFSET_1_OR_0) {\n    UChar* p = s;\n    while (1) {\n      len = enclen(enc, p);\n      if (p + len >= end) {\n        if (len == 1) offset = 1;\n        else          offset = 0;\n        break;\n      }\n      p += len;\n    }\n  }\n\n  len = (int )(end - s);\n  if (len + offset >= UCHAR_MAX)\n    return ONIGERR_PARSER_BUG;\n\n  *roffset = offset;\n\n  for (i = 0; i < CHAR_MAP_SIZE; i++) {\n    skip[i] = (UChar )(len + offset);\n  }\n\n  for (p = s; p < end; ) {\n    int z;\n\n    clen = enclen(enc, p);\n    if (p + clen > end) clen = (int )(end - p);\n\n    len = (int )(end - p);\n    for (j = 0; j < clen; j++) {\n      z = len - j + (offset - 1);\n      if (z <= 0) break;\n      skip[p[j]] = z;\n    }\n\n    if (case_expand != 0) {\n      n = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(enc, reg->case_fold_flag,\n                                             p, end, items);\n      for (k = 0; k < n; k++) {\n        ONIGENC_CODE_TO_MBC(enc, items[k].code[0], buf);\n        for (j = 0; j < clen; j++) {\n          z = len - j + (offset - 1);\n          if (z <= 0) break;\n          if (skip[buf[j]] > z)\n            skip[buf[j]] = z;\n        }\n      }\n    }\n\n    p += clen;\n  }\n\n  return 0;\n}\n\n\n#define OPT_EXACT_MAXLEN   24\n\n#if OPT_EXACT_MAXLEN >= UCHAR_MAX\n#error Too big OPT_EXACT_MAXLEN\n#endif\n\ntypedef struct {\n  OnigLen min;  /* min byte length */\n  OnigLen max;  /* max byte length */\n} MinMax;\n\ntypedef struct {\n  MinMax           mmd;\n  OnigEncoding     enc;\n  OnigOptionType   options;\n  OnigCaseFoldType case_fold_flag;\n  ScanEnv*         scan_env;\n} OptEnv;\n\ntypedef struct {\n  int left;\n  int right;\n} OptAnc;\n\ntypedef struct {\n  MinMax     mmd;   /* position */\n  OptAnc     anc;\n  int        reach_end;\n  int        case_fold;\n  int        good_case_fold;\n  int        len;\n  UChar      s[OPT_EXACT_MAXLEN];\n} OptStr;\n\ntypedef struct {\n  MinMax    mmd;    /* position */\n  OptAnc    anc;\n  int       value;  /* weighted value */\n  UChar     map[CHAR_MAP_SIZE];\n} OptMap;\n\ntypedef struct {\n  MinMax  len;\n  OptAnc  anc;\n  OptStr  sb;     /* boundary */\n  OptStr  sm;     /* middle */\n  OptStr  spr;    /* prec read (?=...) */\n  OptMap  map;    /* boundary */\n} OptNode;\n\n\nstatic int\nmap_position_value(OnigEncoding enc, int i)\n{\n  static const short int Vals[] = {\n     5,  1,  1,  1,  1,  1,  1,  1,  1, 10, 10,  1,  1, 10,  1,  1,\n     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n    12,  4,  7,  4,  4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  5,  5,\n     6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  5,  5,  5,  5,  5,  5,\n     5,  6,  6,  6,  6,  7,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n     6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  5,  6,  5,  5,  5,\n     5,  6,  6,  6,  6,  7,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n     6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  5,  5,  5,  5,  1\n  };\n\n  if (i < (int )(sizeof(Vals)/sizeof(Vals[0]))) {\n    if (i == 0 && ONIGENC_MBC_MINLEN(enc) > 1)\n      return 20;\n    else\n      return (int )Vals[i];\n  }\n  else\n    return 4;   /* Take it easy. */\n}\n\nstatic int\ndistance_value(MinMax* mm)\n{\n  /* 1000 / (min-max-dist + 1) */\n  static const short int dist_vals[] = {\n    1000,  500,  333,  250,  200,  167,  143,  125,  111,  100,\n      91,   83,   77,   71,   67,   63,   59,   56,   53,   50,\n      48,   45,   43,   42,   40,   38,   37,   36,   34,   33,\n      32,   31,   30,   29,   29,   28,   27,   26,   26,   25,\n      24,   24,   23,   23,   22,   22,   21,   21,   20,   20,\n      20,   19,   19,   19,   18,   18,   18,   17,   17,   17,\n      16,   16,   16,   16,   15,   15,   15,   15,   14,   14,\n      14,   14,   14,   14,   13,   13,   13,   13,   13,   13,\n      12,   12,   12,   12,   12,   12,   11,   11,   11,   11,\n      11,   11,   11,   11,   11,   10,   10,   10,   10,   10\n  };\n\n  OnigLen d;\n\n  if (mm->max == INFINITE_LEN) return 0;\n\n  d = mm->max - mm->min;\n  if (d < (OnigLen )(sizeof(dist_vals)/sizeof(dist_vals[0])))\n    /* return dist_vals[d] * 16 / (mm->min + 12); */\n    return (int )dist_vals[d];\n  else\n    return 1;\n}\n\nstatic int\ncomp_distance_value(MinMax* d1, MinMax* d2, int v1, int v2)\n{\n  if (v2 <= 0) return -1;\n  if (v1 <= 0) return  1;\n\n  v1 *= distance_value(d1);\n  v2 *= distance_value(d2);\n\n  if (v2 > v1) return  1;\n  if (v2 < v1) return -1;\n\n  if (d2->min < d1->min) return  1;\n  if (d2->min > d1->min) return -1;\n  return 0;\n}\n\nstatic int\nis_equal_mml(MinMax* a, MinMax* b)\n{\n  return a->min == b->min && a->max == b->max;\n}\n\nstatic void\nset_mml(MinMax* l, OnigLen min, OnigLen max)\n{\n  l->min = min;\n  l->max = max;\n}\n\nstatic void\nclear_mml(MinMax* l)\n{\n  l->min = l->max = 0;\n}\n\nstatic void\ncopy_mml(MinMax* to, MinMax* from)\n{\n  to->min = from->min;\n  to->max = from->max;\n}\n\nstatic void\nadd_mml(MinMax* to, MinMax* from)\n{\n  to->min = distance_add(to->min, from->min);\n  to->max = distance_add(to->max, from->max);\n}\n\nstatic void\nalt_merge_mml(MinMax* to, MinMax* from)\n{\n  if (to->min > from->min) to->min = from->min;\n  if (to->max < from->max) to->max = from->max;\n}\n\nstatic void\ncopy_opt_env(OptEnv* to, OptEnv* from)\n{\n  *to = *from;\n}\n\nstatic void\nclear_opt_anc_info(OptAnc* a)\n{\n  a->left  = 0;\n  a->right = 0;\n}\n\nstatic void\ncopy_opt_anc_info(OptAnc* to, OptAnc* from)\n{\n  *to = *from;\n}\n\nstatic void\nconcat_opt_anc_info(OptAnc* to, OptAnc* left, OptAnc* right,\n                    OnigLen left_len, OnigLen right_len)\n{\n  clear_opt_anc_info(to);\n\n  to->left = left->left;\n  if (left_len == 0) {\n    to->left |= right->left;\n  }\n\n  to->right = right->right;\n  if (right_len == 0) {\n    to->right |= left->right;\n  }\n  else {\n    to->right |= (left->right & ANCR_PREC_READ_NOT);\n  }\n}\n\nstatic int\nis_left(int a)\n{\n  if (a == ANCR_END_BUF  || a == ANCR_SEMI_END_BUF ||\n      a == ANCR_END_LINE || a == ANCR_PREC_READ || a == ANCR_PREC_READ_NOT)\n    return 0;\n\n  return 1;\n}\n\nstatic int\nis_set_opt_anc_info(OptAnc* to, int anc)\n{\n  if ((to->left & anc) != 0) return 1;\n\n  return ((to->right & anc) != 0 ? 1 : 0);\n}\n\nstatic void\nadd_opt_anc_info(OptAnc* to, int anc)\n{\n  if (is_left(anc))\n    to->left |= anc;\n  else\n    to->right |= anc;\n}\n\nstatic void\nremove_opt_anc_info(OptAnc* to, int anc)\n{\n  if (is_left(anc))\n    to->left &= ~anc;\n  else\n    to->right &= ~anc;\n}\n\nstatic void\nalt_merge_opt_anc_info(OptAnc* to, OptAnc* add)\n{\n  to->left  &= add->left;\n  to->right &= add->right;\n}\n\nstatic int\nis_full_opt_exact(OptStr* e)\n{\n  return e->len >= OPT_EXACT_MAXLEN;\n}\n\nstatic void\nclear_opt_exact(OptStr* e)\n{\n  clear_mml(&e->mmd);\n  clear_opt_anc_info(&e->anc);\n  e->reach_end      = 0;\n  e->case_fold      = 0;\n  e->good_case_fold = 0;\n  e->len            = 0;\n  e->s[0]           = '\\0';\n}\n\nstatic void\ncopy_opt_exact(OptStr* to, OptStr* from)\n{\n  *to = *from;\n}\n\nstatic int\nconcat_opt_exact(OptStr* to, OptStr* add, OnigEncoding enc)\n{\n  int i, j, len, r;\n  UChar *p, *end;\n  OptAnc tanc;\n\n  if (add->case_fold != 0) {\n    if (! to->case_fold) {\n      if (to->len > 1 || to->len >= add->len) return 0;  /* avoid */\n\n      to->case_fold = 1;\n    }\n    else {\n      if (to->good_case_fold != 0) {\n        if (add->good_case_fold == 0) return 0;\n      }\n    }\n  }\n\n  r = 0;\n  p = add->s;\n  end = p + add->len;\n  for (i = to->len; p < end; ) {\n    len = enclen(enc, p);\n    if (i + len > OPT_EXACT_MAXLEN) {\n      r = 1; /* 1:full */\n      break;\n    }\n    for (j = 0; j < len && p < end; j++)\n      to->s[i++] = *p++;\n  }\n\n  to->len = i;\n  to->reach_end = (p == end ? add->reach_end : 0);\n\n  concat_opt_anc_info(&tanc, &to->anc, &add->anc, 1, 1);\n  if (! to->reach_end) tanc.right = 0;\n  copy_opt_anc_info(&to->anc, &tanc);\n\n  return r;\n}\n\nstatic void\nconcat_opt_exact_str(OptStr* to, UChar* s, UChar* end, OnigEncoding enc)\n{\n  int i, j, len;\n  UChar *p;\n\n  for (i = to->len, p = s; p < end && i < OPT_EXACT_MAXLEN; ) {\n    len = enclen(enc, p);\n    if (i + len > OPT_EXACT_MAXLEN) break;\n    for (j = 0; j < len && p < end; j++)\n      to->s[i++] = *p++;\n  }\n\n  to->len = i;\n\n  if (p >= end && to->len == (int )(end - s))\n    to->reach_end = 1;\n}\n\nstatic void\nalt_merge_opt_exact(OptStr* to, OptStr* add, OptEnv* env)\n{\n  int i, j, len;\n\n  if (add->len == 0 || to->len == 0) {\n    clear_opt_exact(to);\n    return ;\n  }\n\n  if (! is_equal_mml(&to->mmd, &add->mmd)) {\n    clear_opt_exact(to);\n    return ;\n  }\n\n  for (i = 0; i < to->len && i < add->len; ) {\n    if (to->s[i] != add->s[i]) break;\n    len = enclen(env->enc, to->s + i);\n\n    for (j = 1; j < len; j++) {\n      if (to->s[i+j] != add->s[i+j]) break;\n    }\n    if (j < len) break;\n    i += len;\n  }\n\n  if (! add->reach_end || i < add->len || i < to->len) {\n    to->reach_end = 0;\n  }\n  to->len = i;\n  if (add->case_fold != 0)\n    to->case_fold = 1;\n  if (add->good_case_fold == 0)\n    to->good_case_fold = 0;\n\n  alt_merge_opt_anc_info(&to->anc, &add->anc);\n  if (! to->reach_end) to->anc.right = 0;\n}\n\nstatic void\nselect_opt_exact(OnigEncoding enc, OptStr* now, OptStr* alt)\n{\n  int vn, va;\n\n  vn = now->len;\n  va = alt->len;\n\n  if (va == 0) {\n    return ;\n  }\n  else if (vn == 0) {\n    copy_opt_exact(now, alt);\n    return ;\n  }\n  else if (vn <= 2 && va <= 2) {\n    /* ByteValTable[x] is big value --> low price */\n    va = map_position_value(enc, now->s[0]);\n    vn = map_position_value(enc, alt->s[0]);\n\n    if (now->len > 1) vn += 5;\n    if (alt->len > 1) va += 5;\n  }\n\n  if (now->case_fold == 0) vn *= 2;\n  if (alt->case_fold == 0) va *= 2;\n\n  if (now->good_case_fold != 0) vn *= 4;\n  if (alt->good_case_fold != 0) va *= 4;\n\n  if (comp_distance_value(&now->mmd, &alt->mmd, vn, va) > 0)\n    copy_opt_exact(now, alt);\n}\n\nstatic void\nclear_opt_map(OptMap* map)\n{\n  static const OptMap clean_info = {\n    {0, 0}, {0, 0}, 0,\n    {\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    }\n  };\n\n  xmemcpy(map, &clean_info, sizeof(OptMap));\n}\n\nstatic void\ncopy_opt_map(OptMap* to, OptMap* from)\n{\n  *to = *from;\n}\n\nstatic void\nadd_char_opt_map(OptMap* m, UChar c, OnigEncoding enc)\n{\n  if (m->map[c] == 0) {\n    m->map[c] = 1;\n    m->value += map_position_value(enc, c);\n  }\n}\n\nstatic int\nadd_char_amb_opt_map(OptMap* map, UChar* p, UChar* end,\n                     OnigEncoding enc, OnigCaseFoldType fold_flag)\n{\n  OnigCaseFoldCodeItem items[ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM];\n  UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n  int i, n;\n\n  add_char_opt_map(map, p[0], enc);\n\n  fold_flag = DISABLE_CASE_FOLD_MULTI_CHAR(fold_flag);\n  n = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(enc, fold_flag, p, end, items);\n  if (n < 0) return n;\n\n  for (i = 0; i < n; i++) {\n    ONIGENC_CODE_TO_MBC(enc, items[i].code[0], buf);\n    add_char_opt_map(map, buf[0], enc);\n  }\n\n  return 0;\n}\n\nstatic void\nselect_opt_map(OptMap* now, OptMap* alt)\n{\n  static int z = 1<<15; /* 32768: something big value */\n\n  int vn, va;\n\n  if (alt->value == 0) return ;\n  if (now->value == 0) {\n    copy_opt_map(now, alt);\n    return ;\n  }\n\n  vn = z / now->value;\n  va = z / alt->value;\n  if (comp_distance_value(&now->mmd, &alt->mmd, vn, va) > 0)\n    copy_opt_map(now, alt);\n}\n\nstatic int\ncomp_opt_exact_or_map(OptStr* e, OptMap* m)\n{\n#define COMP_EM_BASE  20\n  int ae, am;\n  int case_value;\n\n  if (m->value <= 0) return -1;\n\n  if (e->case_fold != 0) {\n    if (e->good_case_fold != 0)\n      case_value = 2;\n    else\n      case_value = 1;\n  }\n  else\n    case_value = 3;\n\n  ae = COMP_EM_BASE * e->len * case_value;\n  am = COMP_EM_BASE * 5 * 2 / m->value;\n  return comp_distance_value(&e->mmd, &m->mmd, ae, am);\n}\n\nstatic void\nalt_merge_opt_map(OnigEncoding enc, OptMap* to, OptMap* add)\n{\n  int i, val;\n\n  /* if (! is_equal_mml(&to->mmd, &add->mmd)) return ; */\n  if (to->value == 0) return ;\n  if (add->value == 0 || to->mmd.max < add->mmd.min) {\n    clear_opt_map(to);\n    return ;\n  }\n\n  alt_merge_mml(&to->mmd, &add->mmd);\n\n  val = 0;\n  for (i = 0; i < CHAR_MAP_SIZE; i++) {\n    if (add->map[i])\n      to->map[i] = 1;\n\n    if (to->map[i])\n      val += map_position_value(enc, i);\n  }\n  to->value = val;\n\n  alt_merge_opt_anc_info(&to->anc, &add->anc);\n}\n\nstatic void\nset_bound_node_opt_info(OptNode* opt, MinMax* plen)\n{\n  copy_mml(&(opt->sb.mmd),  plen);\n  copy_mml(&(opt->spr.mmd), plen);\n  copy_mml(&(opt->map.mmd), plen);\n}\n\nstatic void\nclear_node_opt_info(OptNode* opt)\n{\n  clear_mml(&opt->len);\n  clear_opt_anc_info(&opt->anc);\n  clear_opt_exact(&opt->sb);\n  clear_opt_exact(&opt->sm);\n  clear_opt_exact(&opt->spr);\n  clear_opt_map(&opt->map);\n}\n\nstatic void\ncopy_node_opt_info(OptNode* to, OptNode* from)\n{\n  *to = *from;\n}\n\nstatic void\nconcat_left_node_opt_info(OnigEncoding enc, OptNode* to, OptNode* add)\n{\n  int sb_reach, sm_reach;\n  OptAnc tanc;\n\n  concat_opt_anc_info(&tanc, &to->anc, &add->anc, to->len.max, add->len.max);\n  copy_opt_anc_info(&to->anc, &tanc);\n\n  if (add->sb.len > 0 && to->len.max == 0) {\n    concat_opt_anc_info(&tanc, &to->anc, &add->sb.anc, to->len.max, add->len.max);\n    copy_opt_anc_info(&add->sb.anc, &tanc);\n  }\n\n  if (add->map.value > 0 && to->len.max == 0) {\n    if (add->map.mmd.max == 0)\n      add->map.anc.left |= to->anc.left;\n  }\n\n  sb_reach = to->sb.reach_end;\n  sm_reach = to->sm.reach_end;\n\n  if (add->len.max != 0)\n    to->sb.reach_end = to->sm.reach_end = 0;\n\n  if (add->sb.len > 0) {\n    if (sb_reach) {\n      concat_opt_exact(&to->sb, &add->sb, enc);\n      clear_opt_exact(&add->sb);\n    }\n    else if (sm_reach) {\n      concat_opt_exact(&to->sm, &add->sb, enc);\n      clear_opt_exact(&add->sb);\n    }\n  }\n  select_opt_exact(enc, &to->sm, &add->sb);\n  select_opt_exact(enc, &to->sm, &add->sm);\n\n  if (to->spr.len > 0) {\n    if (add->len.max > 0) {\n      if (to->spr.len > (int )add->len.max)\n        to->spr.len = add->len.max;\n\n      if (to->spr.mmd.max == 0)\n        select_opt_exact(enc, &to->sb, &to->spr);\n      else\n        select_opt_exact(enc, &to->sm, &to->spr);\n    }\n  }\n  else if (add->spr.len > 0) {\n    copy_opt_exact(&to->spr, &add->spr);\n  }\n\n  select_opt_map(&to->map, &add->map);\n  add_mml(&to->len, &add->len);\n}\n\nstatic void\nalt_merge_node_opt_info(OptNode* to, OptNode* add, OptEnv* env)\n{\n  alt_merge_opt_anc_info(&to->anc, &add->anc);\n  alt_merge_opt_exact(&to->sb,  &add->sb, env);\n  alt_merge_opt_exact(&to->sm,  &add->sm, env);\n  alt_merge_opt_exact(&to->spr, &add->spr, env);\n  alt_merge_opt_map(env->enc, &to->map, &add->map);\n\n  alt_merge_mml(&to->len, &add->len);\n}\n\n\n#define MAX_NODE_OPT_INFO_REF_COUNT    5\n\nstatic int\noptimize_nodes(Node* node, OptNode* opt, OptEnv* env)\n{\n  int i;\n  int r;\n  OptNode xo;\n  OnigEncoding enc;\n\n  r = 0;\n  enc = env->enc;\n  clear_node_opt_info(opt);\n  set_bound_node_opt_info(opt, &env->mmd);\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n    {\n      OptEnv nenv;\n      Node* nd = node;\n\n      copy_opt_env(&nenv, env);\n      do {\n        r = optimize_nodes(NODE_CAR(nd), &xo, &nenv);\n        if (r == 0) {\n          add_mml(&nenv.mmd, &xo.len);\n          concat_left_node_opt_info(enc, opt, &xo);\n        }\n      } while (r == 0 && IS_NOT_NULL(nd = NODE_CDR(nd)));\n    }\n    break;\n\n  case NODE_ALT:\n    {\n      Node* nd = node;\n\n      do {\n        r = optimize_nodes(NODE_CAR(nd), &xo, env);\n        if (r == 0) {\n          if (nd == node) copy_node_opt_info(opt, &xo);\n          else            alt_merge_node_opt_info(opt, &xo, env);\n        }\n      } while ((r == 0) && IS_NOT_NULL(nd = NODE_CDR(nd)));\n    }\n    break;\n\n  case NODE_STRING:\n    {\n      StrNode* sn = STR_(node);\n      int slen = (int )(sn->end - sn->s);\n      /* int is_raw = NODE_STRING_IS_RAW(node); */\n\n      if (! NODE_STRING_IS_AMBIG(node)) {\n        concat_opt_exact_str(&opt->sb, sn->s, sn->end, enc);\n        if (slen > 0) {\n          add_char_opt_map(&opt->map, *(sn->s), enc);\n        }\n        set_mml(&opt->len, slen, slen);\n      }\n      else {\n        int max;\n\n        if (NODE_STRING_IS_DONT_GET_OPT_INFO(node)) {\n          int n = onigenc_strlen(enc, sn->s, sn->end);\n          max = ONIGENC_MBC_MAXLEN_DIST(enc) * n;\n        }\n        else {\n          concat_opt_exact_str(&opt->sb, sn->s, sn->end, enc);\n          opt->sb.case_fold = 1;\n          if (NODE_STRING_IS_GOOD_AMBIG(node))\n            opt->sb.good_case_fold = 1;\n\n          if (slen > 0) {\n            r = add_char_amb_opt_map(&opt->map, sn->s, sn->end,\n                                     enc, env->case_fold_flag);\n            if (r != 0) break;\n          }\n\n          max = slen;\n        }\n\n        set_mml(&opt->len, slen, max);\n      }\n    }\n    break;\n\n  case NODE_CCLASS:\n    {\n      int z;\n      CClassNode* cc = CCLASS_(node);\n\n      /* no need to check ignore case. (set in setup_tree()) */\n\n      if (IS_NOT_NULL(cc->mbuf) || IS_NCCLASS_NOT(cc)) {\n        OnigLen min = ONIGENC_MBC_MINLEN(enc);\n        OnigLen max = ONIGENC_MBC_MAXLEN_DIST(enc);\n\n        set_mml(&opt->len, min, max);\n      }\n      else {\n        for (i = 0; i < SINGLE_BYTE_SIZE; i++) {\n          z = BITSET_AT(cc->bs, i);\n          if ((z && ! IS_NCCLASS_NOT(cc)) || (! z && IS_NCCLASS_NOT(cc))) {\n            add_char_opt_map(&opt->map, (UChar )i, enc);\n          }\n        }\n        set_mml(&opt->len, 1, 1);\n      }\n    }\n    break;\n\n  case NODE_CTYPE:\n    {\n      int min, max;\n      int range;\n\n      max = ONIGENC_MBC_MAXLEN_DIST(enc);\n\n      if (max == 1) {\n        min = 1;\n\n        switch (CTYPE_(node)->ctype) {\n        case CTYPE_ANYCHAR:\n          break;\n\n        case ONIGENC_CTYPE_WORD:\n          range = CTYPE_(node)->ascii_mode != 0 ? 128 : SINGLE_BYTE_SIZE;\n          if (CTYPE_(node)->not != 0) {\n            for (i = 0; i < range; i++) {\n              if (! ONIGENC_IS_CODE_WORD(enc, i)) {\n                add_char_opt_map(&opt->map, (UChar )i, enc);\n              }\n            }\n            for (i = range; i < SINGLE_BYTE_SIZE; i++) {\n              add_char_opt_map(&opt->map, (UChar )i, enc);\n            }\n          }\n          else {\n            for (i = 0; i < range; i++) {\n              if (ONIGENC_IS_CODE_WORD(enc, i)) {\n                add_char_opt_map(&opt->map, (UChar )i, enc);\n              }\n            }\n          }\n          break;\n        }\n      }\n      else {\n        min = ONIGENC_MBC_MINLEN(enc);\n      }\n      set_mml(&opt->len, min, max);\n    }\n    break;\n\n  case NODE_ANCHOR:\n    switch (ANCHOR_(node)->type) {\n    case ANCR_BEGIN_BUF:\n    case ANCR_BEGIN_POSITION:\n    case ANCR_BEGIN_LINE:\n    case ANCR_END_BUF:\n    case ANCR_SEMI_END_BUF:\n    case ANCR_END_LINE:\n    case ANCR_PREC_READ_NOT:\n    case ANCR_LOOK_BEHIND:\n      add_opt_anc_info(&opt->anc, ANCHOR_(node)->type);\n      break;\n\n    case ANCR_PREC_READ:\n      {\n        r = optimize_nodes(NODE_BODY(node), &xo, env);\n        if (r == 0) {\n          if (xo.sb.len > 0)\n            copy_opt_exact(&opt->spr, &xo.sb);\n          else if (xo.sm.len > 0)\n            copy_opt_exact(&opt->spr, &xo.sm);\n\n          opt->spr.reach_end = 0;\n\n          if (xo.map.value > 0)\n            copy_opt_map(&opt->map, &xo.map);\n        }\n      }\n      break;\n\n    case ANCR_LOOK_BEHIND_NOT:\n      break;\n    }\n    break;\n\n  case NODE_BACKREF:\n    if (! NODE_IS_CHECKER(node)) {\n      int* backs;\n      OnigLen min, max, tmin, tmax;\n      MemEnv* mem_env = SCANENV_MEMENV(env->scan_env);\n      BackRefNode* br = BACKREF_(node);\n\n      if (NODE_IS_RECURSION(node)) {\n        set_mml(&opt->len, 0, INFINITE_LEN);\n        break;\n      }\n      backs = BACKREFS_P(br);\n      min = tree_min_len(mem_env[backs[0]].node, env->scan_env);\n      max = tree_max_len(mem_env[backs[0]].node, env->scan_env);\n      for (i = 1; i < br->back_num; i++) {\n        tmin = tree_min_len(mem_env[backs[i]].node, env->scan_env);\n        tmax = tree_max_len(mem_env[backs[i]].node, env->scan_env);\n        if (min > tmin) min = tmin;\n        if (max < tmax) max = tmax;\n      }\n      set_mml(&opt->len, min, max);\n    }\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    if (NODE_IS_RECURSION(node))\n      set_mml(&opt->len, 0, INFINITE_LEN);\n    else {\n      OnigOptionType save = env->options;\n      env->options = BAG_(NODE_BODY(node))->o.options;\n      r = optimize_nodes(NODE_BODY(node), opt, env);\n      env->options = save;\n    }\n    break;\n#endif\n\n  case NODE_QUANT:\n    {\n      OnigLen min, max;\n      QuantNode* qn = QUANT_(node);\n\n      r = optimize_nodes(NODE_BODY(node), &xo, env);\n      if (r != 0) break;\n\n      if (qn->lower > 0) {\n        copy_node_opt_info(opt, &xo);\n        if (xo.sb.len > 0) {\n          if (xo.sb.reach_end) {\n            for (i = 2; i <= qn->lower && ! is_full_opt_exact(&opt->sb); i++) {\n              int rc = concat_opt_exact(&opt->sb, &xo.sb, enc);\n              if (rc > 0) break;\n            }\n            if (i < qn->lower) opt->sb.reach_end = 0;\n          }\n        }\n\n        if (qn->lower != qn->upper) {\n          opt->sb.reach_end = 0;\n          opt->sm.reach_end = 0;\n        }\n        if (qn->lower > 1)\n          opt->sm.reach_end = 0;\n      }\n\n      if (IS_REPEAT_INFINITE(qn->upper)) {\n        if (env->mmd.max == 0 &&\n            NODE_IS_ANYCHAR(NODE_BODY(node)) && qn->greedy != 0) {\n          if (IS_MULTILINE(CTYPE_OPTION(NODE_QUANT_BODY(qn), env)))\n            add_opt_anc_info(&opt->anc, ANCR_ANYCHAR_INF_ML);\n          else\n            add_opt_anc_info(&opt->anc, ANCR_ANYCHAR_INF);\n        }\n\n        max = (xo.len.max > 0 ? INFINITE_LEN : 0);\n      }\n      else {\n        max = distance_multiply(xo.len.max, qn->upper);\n      }\n\n      min = distance_multiply(xo.len.min, qn->lower);\n      set_mml(&opt->len, min, max);\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      switch (en->type) {\n      case BAG_OPTION:\n        {\n          OnigOptionType save = env->options;\n\n          env->options = en->o.options;\n          r = optimize_nodes(NODE_BODY(node), opt, env);\n          env->options = save;\n        }\n        break;\n\n      case BAG_MEMORY:\n#ifdef USE_CALL\n        en->opt_count++;\n        if (en->opt_count > MAX_NODE_OPT_INFO_REF_COUNT) {\n          OnigLen min, max;\n\n          min = 0;\n          max = INFINITE_LEN;\n          if (NODE_IS_MIN_FIXED(node)) min = en->min_len;\n          if (NODE_IS_MAX_FIXED(node)) max = en->max_len;\n          set_mml(&opt->len, min, max);\n        }\n        else\n#endif\n          {\n            r = optimize_nodes(NODE_BODY(node), opt, env);\n            if (is_set_opt_anc_info(&opt->anc, ANCR_ANYCHAR_INF_MASK)) {\n              if (MEM_STATUS_AT0(env->scan_env->backrefed_mem, en->m.regnum))\n                remove_opt_anc_info(&opt->anc, ANCR_ANYCHAR_INF_MASK);\n            }\n          }\n        break;\n\n      case BAG_STOP_BACKTRACK:\n        r = optimize_nodes(NODE_BODY(node), opt, env);\n        break;\n\n      case BAG_IF_ELSE:\n        {\n          OptEnv nenv;\n\n          copy_opt_env(&nenv, env);\n          r = optimize_nodes(NODE_BAG_BODY(en), &xo, &nenv);\n          if (r == 0) {\n            add_mml(&nenv.mmd, &xo.len);\n            concat_left_node_opt_info(enc, opt, &xo);\n            if (IS_NOT_NULL(en->te.Then)) {\n              r = optimize_nodes(en->te.Then, &xo, &nenv);\n              if (r == 0) {\n                concat_left_node_opt_info(enc, opt, &xo);\n              }\n            }\n\n            if (IS_NOT_NULL(en->te.Else)) {\n              r = optimize_nodes(en->te.Else, &xo, env);\n              if (r == 0)\n                alt_merge_node_opt_info(opt, &xo, env);\n            }\n          }\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_GIMMICK:\n    break;\n\n  default:\n#ifdef ONIG_DEBUG\n    fprintf(stderr, \"optimize_nodes: undefined node type %d\\n\", NODE_TYPE(node));\n#endif\n    r = ONIGERR_TYPE_BUG;\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nset_optimize_exact(regex_t* reg, OptStr* e)\n{\n  int r;\n\n  if (e->len == 0) return 0;\n\n  reg->exact = (UChar* )xmalloc(e->len);\n  CHECK_NULL_RETURN_MEMERR(reg->exact);\n  xmemcpy(reg->exact, e->s, e->len);\n  reg->exact_end = reg->exact + e->len;\n\n  if (e->case_fold) {\n    reg->optimize = OPTIMIZE_STR_CASE_FOLD;\n    if (e->good_case_fold != 0) {\n      if (e->len >= 2) {\n        r = set_sunday_quick_search_or_bmh_skip_table(reg, 1,\n                             reg->exact, reg->exact_end,\n                             reg->map, &(reg->map_offset));\n        if (r != 0) return r;\n        reg->optimize = OPTIMIZE_STR_CASE_FOLD_FAST;\n      }\n    }\n  }\n  else {\n    int allow_reverse;\n\n    allow_reverse =\n      ONIGENC_IS_ALLOWED_REVERSE_MATCH(reg->enc, reg->exact, reg->exact_end);\n\n    if (e->len >= 2 || (e->len >= 1 && allow_reverse)) {\n      r = set_sunday_quick_search_or_bmh_skip_table(reg, 0,\n                                         reg->exact, reg->exact_end,\n                                         reg->map, &(reg->map_offset));\n      if (r != 0) return r;\n\n      reg->optimize = (allow_reverse != 0\n                       ? OPTIMIZE_STR_FAST\n                       : OPTIMIZE_STR_FAST_STEP_FORWARD);\n    }\n    else {\n      reg->optimize = OPTIMIZE_STR;\n    }\n  }\n\n  reg->dmin = e->mmd.min;\n  reg->dmax = e->mmd.max;\n\n  if (reg->dmin != INFINITE_LEN) {\n    reg->threshold_len = reg->dmin + (int )(reg->exact_end - reg->exact);\n  }\n\n  return 0;\n}\n\nstatic void\nset_optimize_map(regex_t* reg, OptMap* m)\n{\n  int i;\n\n  for (i = 0; i < CHAR_MAP_SIZE; i++)\n    reg->map[i] = m->map[i];\n\n  reg->optimize   = OPTIMIZE_MAP;\n  reg->dmin       = m->mmd.min;\n  reg->dmax       = m->mmd.max;\n\n  if (reg->dmin != INFINITE_LEN) {\n    reg->threshold_len = reg->dmin + 1;\n  }\n}\n\nstatic void\nset_sub_anchor(regex_t* reg, OptAnc* anc)\n{\n  reg->sub_anchor |= anc->left  & ANCR_BEGIN_LINE;\n  reg->sub_anchor |= anc->right & ANCR_END_LINE;\n}\n\n#if defined(ONIG_DEBUG_COMPILE) || defined(ONIG_DEBUG_MATCH)\nstatic void print_optimize_info(FILE* f, regex_t* reg);\n#endif\n\nstatic int\nset_optimize_info_from_tree(Node* node, regex_t* reg, ScanEnv* scan_env)\n{\n  int r;\n  OptNode opt;\n  OptEnv env;\n\n  env.enc            = reg->enc;\n  env.options        = reg->options;\n  env.case_fold_flag = reg->case_fold_flag;\n  env.scan_env       = scan_env;\n  clear_mml(&env.mmd);\n\n  r = optimize_nodes(node, &opt, &env);\n  if (r != 0) return r;\n\n  reg->anchor = opt.anc.left & (ANCR_BEGIN_BUF |\n        ANCR_BEGIN_POSITION | ANCR_ANYCHAR_INF | ANCR_ANYCHAR_INF_ML |\n        ANCR_LOOK_BEHIND);\n\n  if ((opt.anc.left & (ANCR_LOOK_BEHIND | ANCR_PREC_READ_NOT)) != 0)\n    reg->anchor &= ~ANCR_ANYCHAR_INF_ML;\n\n  reg->anchor |= opt.anc.right & (ANCR_END_BUF | ANCR_SEMI_END_BUF |\n                                  ANCR_PREC_READ_NOT);\n\n  if (reg->anchor & (ANCR_END_BUF | ANCR_SEMI_END_BUF)) {\n    reg->anchor_dmin = opt.len.min;\n    reg->anchor_dmax = opt.len.max;\n  }\n\n  if (opt.sb.len > 0 || opt.sm.len > 0) {\n    select_opt_exact(reg->enc, &opt.sb, &opt.sm);\n    if (opt.map.value > 0 && comp_opt_exact_or_map(&opt.sb, &opt.map) > 0) {\n      goto set_map;\n    }\n    else {\n      r = set_optimize_exact(reg, &opt.sb);\n      set_sub_anchor(reg, &opt.sb.anc);\n    }\n  }\n  else if (opt.map.value > 0) {\n  set_map:\n    set_optimize_map(reg, &opt.map);\n    set_sub_anchor(reg, &opt.map.anc);\n  }\n  else {\n    reg->sub_anchor |= opt.anc.left & ANCR_BEGIN_LINE;\n    if (opt.len.max == 0)\n      reg->sub_anchor |= opt.anc.right & ANCR_END_LINE;\n  }\n\n#if defined(ONIG_DEBUG_COMPILE) || defined(ONIG_DEBUG_MATCH)\n  print_optimize_info(stderr, reg);\n#endif\n  return r;\n}\n\nstatic void\nclear_optimize_info(regex_t* reg)\n{\n  reg->optimize      = OPTIMIZE_NONE;\n  reg->anchor        = 0;\n  reg->anchor_dmin   = 0;\n  reg->anchor_dmax   = 0;\n  reg->sub_anchor    = 0;\n  reg->exact_end     = (UChar* )NULL;\n  reg->map_offset    = 0;\n  reg->threshold_len = 0;\n  if (IS_NOT_NULL(reg->exact)) {\n    xfree(reg->exact);\n    reg->exact = (UChar* )NULL;\n  }\n}\n\n#ifdef ONIG_DEBUG\n\nstatic void print_enc_string(FILE* fp, OnigEncoding enc,\n                             const UChar *s, const UChar *end)\n{\n  fprintf(fp, \"\\nPATTERN: /\");\n\n  if (ONIGENC_MBC_MINLEN(enc) > 1) {\n    const UChar *p;\n    OnigCodePoint code;\n\n    p = s;\n    while (p < end) {\n      code = ONIGENC_MBC_TO_CODE(enc, p, end);\n      if (code >= 0x80) {\n        fprintf(fp, \" 0x%04x \", (int )code);\n      }\n      else {\n        fputc((int )code, fp);\n      }\n\n      p += enclen(enc, p);\n    }\n  }\n  else {\n    while (s < end) {\n      fputc((int )*s, fp);\n      s++;\n    }\n  }\n\n  fprintf(fp, \"/\\n\");\n}\n\n#endif /* ONIG_DEBUG */\n\n#if defined(ONIG_DEBUG_COMPILE) || defined(ONIG_DEBUG_MATCH)\n\nstatic void\nprint_distance_range(FILE* f, OnigLen a, OnigLen b)\n{\n  if (a == INFINITE_LEN)\n    fputs(\"inf\", f);\n  else\n    fprintf(f, \"(%u)\", a);\n\n  fputs(\"-\", f);\n\n  if (b == INFINITE_LEN)\n    fputs(\"inf\", f);\n  else\n    fprintf(f, \"(%u)\", b);\n}\n\nstatic void\nprint_anchor(FILE* f, int anchor)\n{\n  int q = 0;\n\n  fprintf(f, \"[\");\n\n  if (anchor & ANCR_BEGIN_BUF) {\n    fprintf(f, \"begin-buf\");\n    q = 1;\n  }\n  if (anchor & ANCR_BEGIN_LINE) {\n    if (q) fprintf(f, \", \");\n    q = 1;\n    fprintf(f, \"begin-line\");\n  }\n  if (anchor & ANCR_BEGIN_POSITION) {\n    if (q) fprintf(f, \", \");\n    q = 1;\n    fprintf(f, \"begin-pos\");\n  }\n  if (anchor & ANCR_END_BUF) {\n    if (q) fprintf(f, \", \");\n    q = 1;\n    fprintf(f, \"end-buf\");\n  }\n  if (anchor & ANCR_SEMI_END_BUF) {\n    if (q) fprintf(f, \", \");\n    q = 1;\n    fprintf(f, \"semi-end-buf\");\n  }\n  if (anchor & ANCR_END_LINE) {\n    if (q) fprintf(f, \", \");\n    q = 1;\n    fprintf(f, \"end-line\");\n  }\n  if (anchor & ANCR_ANYCHAR_INF) {\n    if (q) fprintf(f, \", \");\n    q = 1;\n    fprintf(f, \"anychar-inf\");\n  }\n  if (anchor & ANCR_ANYCHAR_INF_ML) {\n    if (q) fprintf(f, \", \");\n    fprintf(f, \"anychar-inf-ml\");\n  }\n\n  fprintf(f, \"]\");\n}\n\nstatic void\nprint_optimize_info(FILE* f, regex_t* reg)\n{\n  static const char* on[] = { \"NONE\", \"STR\",\n                              \"STR_FAST\", \"STR_FAST_STEP_FORWARD\",\n                              \"STR_CASE_FOLD_FAST\", \"STR_CASE_FOLD\", \"MAP\" };\n\n  fprintf(f, \"optimize: %s\\n\", on[reg->optimize]);\n  fprintf(f, \"  anchor: \"); print_anchor(f, reg->anchor);\n  if ((reg->anchor & ANCR_END_BUF_MASK) != 0)\n    print_distance_range(f, reg->anchor_dmin, reg->anchor_dmax);\n  fprintf(f, \"\\n\");\n\n  if (reg->optimize) {\n    fprintf(f, \"  sub anchor: \"); print_anchor(f, reg->sub_anchor);\n    fprintf(f, \"\\n\");\n  }\n  fprintf(f, \"\\n\");\n\n  if (reg->exact) {\n    UChar *p;\n    fprintf(f, \"exact: [\");\n    for (p = reg->exact; p < reg->exact_end; p++) {\n      fputc(*p, f);\n    }\n    fprintf(f, \"]: length: %ld\\n\", (reg->exact_end - reg->exact));\n  }\n  else if (reg->optimize & OPTIMIZE_MAP) {\n    int c, i, n = 0;\n\n    for (i = 0; i < CHAR_MAP_SIZE; i++)\n      if (reg->map[i]) n++;\n\n    fprintf(f, \"map: n=%d\\n\", n);\n    if (n > 0) {\n      c = 0;\n      fputc('[', f);\n      for (i = 0; i < CHAR_MAP_SIZE; i++) {\n        if (reg->map[i] != 0) {\n          if (c > 0)  fputs(\", \", f);\n          c++;\n          if (ONIGENC_MBC_MAXLEN(reg->enc) == 1 &&\n              ONIGENC_IS_CODE_PRINT(reg->enc, (OnigCodePoint )i))\n            fputc(i, f);\n          else\n            fprintf(f, \"%d\", i);\n        }\n      }\n      fprintf(f, \"]\\n\");\n    }\n  }\n}\n#endif\n\n\nextern RegexExt*\nonig_get_regex_ext(regex_t* reg)\n{\n  if (IS_NULL(reg->extp)) {\n    RegexExt* ext = (RegexExt* )xmalloc(sizeof(*ext));\n    if (IS_NULL(ext)) return 0;\n\n    ext->pattern      = 0;\n    ext->pattern_end  = 0;\n#ifdef USE_CALLOUT\n    ext->tag_table    = 0;\n    ext->callout_num  = 0;\n    ext->callout_list_alloc = 0;\n    ext->callout_list = 0;\n#endif\n\n    reg->extp = ext;\n  }\n\n  return reg->extp;\n}\n\nstatic void\nfree_regex_ext(RegexExt* ext)\n{\n  if (IS_NOT_NULL(ext)) {\n    if (IS_NOT_NULL(ext->pattern))\n      xfree((void* )ext->pattern);\n\n#ifdef USE_CALLOUT\n    if (IS_NOT_NULL(ext->tag_table))\n      onig_callout_tag_table_free(ext->tag_table);\n\n    if (IS_NOT_NULL(ext->callout_list))\n      onig_free_reg_callout_list(ext->callout_num, ext->callout_list);\n#endif\n\n    xfree(ext);\n  }\n}\n\nextern int\nonig_ext_set_pattern(regex_t* reg, const UChar* pattern, const UChar* pattern_end)\n{\n  RegexExt* ext;\n  UChar* s;\n\n  ext = onig_get_regex_ext(reg);\n  CHECK_NULL_RETURN_MEMERR(ext);\n\n  s = onigenc_strdup(reg->enc, pattern, pattern_end);\n  CHECK_NULL_RETURN_MEMERR(s);\n\n  ext->pattern     = s;\n  ext->pattern_end = s + (pattern_end - pattern);\n\n  return ONIG_NORMAL;\n}\n\nextern void\nonig_free_body(regex_t* reg)\n{\n  if (IS_NOT_NULL(reg)) {\n    ops_free(reg);\n    if (IS_NOT_NULL(reg->string_pool)) {\n      xfree(reg->string_pool);\n      reg->string_pool_end = reg->string_pool = 0;\n    }\n    if (IS_NOT_NULL(reg->exact))            xfree(reg->exact);\n    if (IS_NOT_NULL(reg->repeat_range))     xfree(reg->repeat_range);\n    if (IS_NOT_NULL(reg->extp)) {\n      free_regex_ext(reg->extp);\n      reg->extp = 0;\n    }\n\n    onig_names_free(reg);\n  }\n}\n\nextern void\nonig_free(regex_t* reg)\n{\n  if (IS_NOT_NULL(reg)) {\n    onig_free_body(reg);\n    xfree(reg);\n  }\n}\n\n\n#ifdef ONIG_DEBUG_PARSE\nstatic void print_tree P_((FILE* f, Node* node));\n#endif\n\nextern int onig_init_for_match_at(regex_t* reg);\n\nextern int\nonig_compile(regex_t* reg, const UChar* pattern, const UChar* pattern_end,\n             OnigErrorInfo* einfo)\n{\n  int r;\n  Node*  root;\n  ScanEnv  scan_env;\n#ifdef USE_CALL\n  UnsetAddrList  uslist;\n#endif\n\n  root = 0;\n  if (IS_NOT_NULL(einfo)) {\n    einfo->enc = reg->enc;\n    einfo->par = (UChar* )NULL;\n  }\n\n#ifdef ONIG_DEBUG\n  print_enc_string(stderr, reg->enc, pattern, pattern_end);\n#endif\n\n  if (reg->ops_alloc == 0) {\n    r = ops_init(reg, OPS_INIT_SIZE);\n    if (r != 0) goto end;\n  }\n  else\n    reg->ops_used = 0;\n\n  reg->string_pool        = 0;\n  reg->string_pool_end    = 0;\n  reg->num_mem            = 0;\n  reg->num_repeat         = 0;\n  reg->num_null_check     = 0;\n  reg->repeat_range_alloc = 0;\n  reg->repeat_range       = (OnigRepeatRange* )NULL;\n\n  r = onig_parse_tree(&root, pattern, pattern_end, reg, &scan_env);\n  if (r != 0) goto err;\n\n  /* mixed use named group and no-named group */\n  if (scan_env.num_named > 0 &&\n      IS_SYNTAX_BV(scan_env.syntax, ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP) &&\n      ! ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_CAPTURE_GROUP)) {\n    if (scan_env.num_named != scan_env.num_mem)\n      r = disable_noname_group_capture(&root, reg, &scan_env);\n    else\n      r = numbered_ref_check(root);\n\n    if (r != 0) goto err;\n  }\n\n  r = check_backrefs(root, &scan_env);\n  if (r != 0) goto err;\n\n#ifdef USE_CALL\n  if (scan_env.num_call > 0) {\n    r = unset_addr_list_init(&uslist, scan_env.num_call);\n    if (r != 0) goto err;\n    scan_env.unset_addr_list = &uslist;\n    r = setup_call(root, &scan_env, 0);\n    if (r != 0) goto err_unset;\n    r = setup_call2(root);\n    if (r != 0) goto err_unset;\n    r = recursive_call_check_trav(root, &scan_env, 0);\n    if (r  < 0) goto err_unset;\n    r = infinite_recursive_call_check_trav(root, &scan_env);\n    if (r != 0) goto err_unset;\n\n    setup_called_state(root, 0);\n  }\n\n  reg->num_call = scan_env.num_call;\n#endif\n\n  r = setup_tree(root, reg, 0, &scan_env);\n  if (r != 0) goto err_unset;\n\n#ifdef ONIG_DEBUG_PARSE\n  print_tree(stderr, root);\n#endif\n\n  reg->capture_history  = scan_env.capture_history;\n  reg->bt_mem_start     = scan_env.bt_mem_start;\n  reg->bt_mem_start    |= reg->capture_history;\n  if (IS_FIND_CONDITION(reg->options))\n    MEM_STATUS_ON_ALL(reg->bt_mem_end);\n  else {\n    reg->bt_mem_end  = scan_env.bt_mem_end;\n    reg->bt_mem_end |= reg->capture_history;\n  }\n  reg->bt_mem_start |= reg->bt_mem_end;\n\n  clear_optimize_info(reg);\n#ifndef ONIG_DONT_OPTIMIZE\n  r = set_optimize_info_from_tree(root, reg, &scan_env);\n  if (r != 0) goto err_unset;\n#endif\n\n  if (IS_NOT_NULL(scan_env.mem_env_dynamic)) {\n    xfree(scan_env.mem_env_dynamic);\n    scan_env.mem_env_dynamic = (MemEnv* )NULL;\n  }\n\n  r = compile_tree(root, reg, &scan_env);\n  if (r == 0) {\n    if (scan_env.keep_num > 0) {\n      r = add_op(reg, OP_UPDATE_VAR);\n      if (r != 0) goto err;\n\n      COP(reg)->update_var.type = UPDATE_VAR_KEEP_FROM_STACK_LAST;\n      COP(reg)->update_var.id   = 0; /* not used */\n    }\n\n    r = add_op(reg, OP_END);\n    if (r != 0) goto err;\n\n#ifdef USE_CALL\n    if (scan_env.num_call > 0) {\n      r = fix_unset_addr_list(&uslist, reg);\n      unset_addr_list_end(&uslist);\n      if (r != 0) goto err;\n    }\n#endif\n\n    if ((reg->num_repeat != 0) || (reg->bt_mem_end != 0)\n#ifdef USE_CALLOUT\n        || (IS_NOT_NULL(reg->extp) && reg->extp->callout_num != 0)\n#endif\n        )\n      reg->stack_pop_level = STACK_POP_LEVEL_ALL;\n    else {\n      if (reg->bt_mem_start != 0)\n        reg->stack_pop_level = STACK_POP_LEVEL_MEM_START;\n      else\n        reg->stack_pop_level = STACK_POP_LEVEL_FREE;\n    }\n\n    r = ops_make_string_pool(reg);\n    if (r != 0) goto err;\n  }\n#ifdef USE_CALL\n  else if (scan_env.num_call > 0) {\n    unset_addr_list_end(&uslist);\n  }\n#endif\n  onig_node_free(root);\n\n#ifdef ONIG_DEBUG_COMPILE\n  onig_print_names(stderr, reg);\n  onig_print_compiled_byte_code_list(stderr, reg);\n#endif\n\n#ifdef USE_DIRECT_THREADED_CODE\n  /* opcode -> opaddr */\n  onig_init_for_match_at(reg);\n#endif\n\n end:\n  return r;\n\n err_unset:\n#ifdef USE_CALL\n  if (scan_env.num_call > 0) {\n    unset_addr_list_end(&uslist);\n  }\n#endif\n err:\n  if (IS_NOT_NULL(scan_env.error)) {\n    if (IS_NOT_NULL(einfo)) {\n      einfo->par     = scan_env.error;\n      einfo->par_end = scan_env.error_end;\n    }\n  }\n\n  onig_node_free(root);\n  if (IS_NOT_NULL(scan_env.mem_env_dynamic))\n      xfree(scan_env.mem_env_dynamic);\n  return r;\n}\n\n\nstatic int onig_inited = 0;\n\nextern int\nonig_reg_init(regex_t* reg, OnigOptionType option, OnigCaseFoldType case_fold_flag,\n              OnigEncoding enc, OnigSyntaxType* syntax)\n{\n  int r;\n\n  xmemset(reg, 0, sizeof(*reg));\n\n  if (onig_inited == 0) {\n#if 0\n    return ONIGERR_LIBRARY_IS_NOT_INITIALIZED;\n#else\n    r = onig_initialize(&enc, 1);\n    if (r != 0)\n      return ONIGERR_FAIL_TO_INITIALIZE;\n\n    onig_warning(\"You didn't call onig_initialize() explicitly\");\n#endif\n  }\n\n  if (IS_NULL(reg))\n    return ONIGERR_INVALID_ARGUMENT;\n\n  if (ONIGENC_IS_UNDEF(enc))\n    return ONIGERR_DEFAULT_ENCODING_IS_NOT_SETTED;\n\n  if ((option & (ONIG_OPTION_DONT_CAPTURE_GROUP|ONIG_OPTION_CAPTURE_GROUP))\n      == (ONIG_OPTION_DONT_CAPTURE_GROUP|ONIG_OPTION_CAPTURE_GROUP)) {\n    return ONIGERR_INVALID_COMBINATION_OF_OPTIONS;\n  }\n\n  if ((option & ONIG_OPTION_NEGATE_SINGLELINE) != 0) {\n    option |= syntax->options;\n    option &= ~ONIG_OPTION_SINGLELINE;\n  }\n  else\n    option |= syntax->options;\n\n  (reg)->enc              = enc;\n  (reg)->options          = option;\n  (reg)->syntax           = syntax;\n  (reg)->optimize         = 0;\n  (reg)->exact            = (UChar* )NULL;\n  (reg)->extp             = (RegexExt* )NULL;\n\n  (reg)->ops              = (Operation* )NULL;\n  (reg)->ops_curr         = (Operation* )NULL;\n  (reg)->ops_used         = 0;\n  (reg)->ops_alloc        = 0;\n  (reg)->name_table       = (void* )NULL;\n\n  (reg)->case_fold_flag   = case_fold_flag;\n  return 0;\n}\n\nextern int\nonig_new_without_alloc(regex_t* reg,\n                       const UChar* pattern, const UChar* pattern_end,\n                       OnigOptionType option, OnigEncoding enc,\n                       OnigSyntaxType* syntax, OnigErrorInfo* einfo)\n{\n  int r;\n\n  r = onig_reg_init(reg, option, ONIGENC_CASE_FOLD_DEFAULT, enc, syntax);\n  if (r != 0) return r;\n\n  r = onig_compile(reg, pattern, pattern_end, einfo);\n  return r;\n}\n\nextern int\nonig_new(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n         OnigOptionType option, OnigEncoding enc, OnigSyntaxType* syntax,\n         OnigErrorInfo* einfo)\n{\n  int r;\n\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) return ONIGERR_MEMORY;\n\n  r = onig_reg_init(*reg, option, ONIGENC_CASE_FOLD_DEFAULT, enc, syntax);\n  if (r != 0) goto err;\n\n  r = onig_compile(*reg, pattern, pattern_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n  return r;\n}\n\nextern int\nonig_initialize(OnigEncoding encodings[], int n)\n{\n  int i;\n  int r;\n\n  if (onig_inited != 0)\n    return 0;\n\n  onigenc_init();\n\n  onig_inited = 1;\n\n  for (i = 0; i < n; i++) {\n    OnigEncoding enc = encodings[i];\n    r = onig_initialize_encoding(enc);\n    if (r != 0)\n      return r;\n  }\n\n  return ONIG_NORMAL;\n}\n\ntypedef struct EndCallListItem {\n  struct EndCallListItem* next;\n  void (*func)(void);\n} EndCallListItemType;\n\nstatic EndCallListItemType* EndCallTop;\n\nextern void onig_add_end_call(void (*func)(void))\n{\n  EndCallListItemType* item;\n\n  item = (EndCallListItemType* )xmalloc(sizeof(*item));\n  if (item == 0) return ;\n\n  item->next = EndCallTop;\n  item->func = func;\n\n  EndCallTop = item;\n}\n\nstatic void\nexec_end_call_list(void)\n{\n  EndCallListItemType* prev;\n  void (*func)(void);\n\n  while (EndCallTop != 0) {\n    func = EndCallTop->func;\n    (*func)();\n\n    prev = EndCallTop;\n    EndCallTop = EndCallTop->next;\n    xfree(prev);\n  }\n}\n\nextern int\nonig_end(void)\n{\n  exec_end_call_list();\n\n#ifdef USE_CALLOUT\n  onig_global_callout_names_free();\n#endif\n\n  onigenc_end();\n\n  onig_inited = 0;\n\n  return 0;\n}\n\nextern int\nonig_is_in_code_range(const UChar* p, OnigCodePoint code)\n{\n  OnigCodePoint n, *data;\n  OnigCodePoint low, high, x;\n\n  GET_CODE_POINT(n, p);\n  data = (OnigCodePoint* )p;\n  data++;\n\n  for (low = 0, high = n; low < high; ) {\n    x = (low + high) >> 1;\n    if (code > data[x * 2 + 1])\n      low = x + 1;\n    else\n      high = x;\n  }\n\n  return ((low < n && code >= data[low * 2]) ? 1 : 0);\n}\n\nextern int\nonig_is_code_in_cc_len(int elen, OnigCodePoint code, /* CClassNode* */ void* cc_arg)\n{\n  int found;\n  CClassNode* cc = (CClassNode* )cc_arg;\n\n  if (elen > 1 || (code >= SINGLE_BYTE_SIZE)) {\n    if (IS_NULL(cc->mbuf)) {\n      found = 0;\n    }\n    else {\n      found = onig_is_in_code_range(cc->mbuf->p, code) != 0;\n    }\n  }\n  else {\n    found = BITSET_AT(cc->bs, code) != 0;\n  }\n\n  if (IS_NCCLASS_NOT(cc))\n    return !found;\n  else\n    return found;\n}\n\nextern int\nonig_is_code_in_cc(OnigEncoding enc, OnigCodePoint code, CClassNode* cc)\n{\n  int len;\n\n  if (ONIGENC_MBC_MINLEN(enc) > 1) {\n    len = 2;\n  }\n  else {\n    len = ONIGENC_CODE_TO_MBCLEN(enc, code);\n  }\n  return onig_is_code_in_cc_len(len, code, cc);\n}\n\n\n#ifdef ONIG_DEBUG_PARSE\n\nstatic void\np_string(FILE* f, int len, UChar* s)\n{\n  fputs(\":\", f);\n  while (len-- > 0) { fputc(*s++, f); }\n}\n\nstatic void\nIndent(FILE* f, int indent)\n{\n  int i;\n  for (i = 0; i < indent; i++) putc(' ', f);\n}\n\nstatic void\nprint_indent_tree(FILE* f, Node* node, int indent)\n{\n  int i;\n  NodeType type;\n  UChar* p;\n  int add = 3;\n\n  Indent(f, indent);\n  if (IS_NULL(node)) {\n    fprintf(f, \"ERROR: null node!!!\\n\");\n    exit (0);\n  }\n\n  type = NODE_TYPE(node);\n  switch (type) {\n  case NODE_LIST:\n  case NODE_ALT:\n    if (type == NODE_LIST)\n      fprintf(f, \"<list:%p>\\n\", node);\n    else\n      fprintf(f, \"<alt:%p>\\n\", node);\n\n    print_indent_tree(f, NODE_CAR(node), indent + add);\n    while (IS_NOT_NULL(node = NODE_CDR(node))) {\n      if (NODE_TYPE(node) != type) {\n        fprintf(f, \"ERROR: list/alt right is not a cons. %d\\n\", NODE_TYPE(node));\n        exit(0);\n      }\n      print_indent_tree(f, NODE_CAR(node), indent + add);\n    }\n    break;\n\n  case NODE_STRING:\n    {\n      char* mode;\n      char* dont;\n      char* good;\n\n      if (NODE_STRING_IS_RAW(node))\n        mode = \"-raw\";\n      else if (NODE_STRING_IS_AMBIG(node))\n        mode = \"-ambig\";\n      else\n        mode = \"\";\n\n      if (NODE_STRING_IS_GOOD_AMBIG(node))\n        good = \"-good\";\n      else\n        good = \"\";\n\n      if (NODE_STRING_IS_DONT_GET_OPT_INFO(node))\n        dont = \" (dont-opt)\";\n      else\n        dont = \"\";\n\n      fprintf(f, \"<string%s%s%s:%p>\", mode, good, dont, node);\n      for (p = STR_(node)->s; p < STR_(node)->end; p++) {\n        if (*p >= 0x20 && *p < 0x7f)\n          fputc(*p, f);\n        else {\n          fprintf(f, \" 0x%02x\", *p);\n        }\n      }\n    }\n    break;\n\n  case NODE_CCLASS:\n    fprintf(f, \"<cclass:%p>\", node);\n    if (IS_NCCLASS_NOT(CCLASS_(node))) fputs(\" not\", f);\n    if (CCLASS_(node)->mbuf) {\n      BBuf* bbuf = CCLASS_(node)->mbuf;\n      for (i = 0; i < bbuf->used; i++) {\n        if (i > 0) fprintf(f, \",\");\n        fprintf(f, \"%0x\", bbuf->p[i]);\n      }\n    }\n    break;\n\n  case NODE_CTYPE:\n    fprintf(f, \"<ctype:%p> \", node);\n    switch (CTYPE_(node)->ctype) {\n    case CTYPE_ANYCHAR:\n      fprintf(f, \"<anychar:%p>\", node);\n      break;\n\n    case ONIGENC_CTYPE_WORD:\n      if (CTYPE_(node)->not != 0)\n        fputs(\"not word\", f);\n      else\n        fputs(\"word\",     f);\n\n      if (CTYPE_(node)->ascii_mode != 0)\n        fputs(\" (ascii)\", f);\n\n      break;\n\n    default:\n      fprintf(f, \"ERROR: undefined ctype.\\n\");\n      exit(0);\n    }\n    break;\n\n  case NODE_ANCHOR:\n    fprintf(f, \"<anchor:%p> \", node);\n    switch (ANCHOR_(node)->type) {\n    case ANCR_BEGIN_BUF:        fputs(\"begin buf\",      f); break;\n    case ANCR_END_BUF:          fputs(\"end buf\",        f); break;\n    case ANCR_BEGIN_LINE:       fputs(\"begin line\",     f); break;\n    case ANCR_END_LINE:         fputs(\"end line\",       f); break;\n    case ANCR_SEMI_END_BUF:     fputs(\"semi end buf\",   f); break;\n    case ANCR_BEGIN_POSITION:   fputs(\"begin position\", f); break;\n\n    case ANCR_WORD_BOUNDARY:    fputs(\"word boundary\",     f); break;\n    case ANCR_NO_WORD_BOUNDARY: fputs(\"not word boundary\", f); break;\n#ifdef USE_WORD_BEGIN_END\n    case ANCR_WORD_BEGIN:       fputs(\"word begin\", f);     break;\n    case ANCR_WORD_END:         fputs(\"word end\", f);       break;\n#endif\n    case ANCR_TEXT_SEGMENT_BOUNDARY:\n      fputs(\"text-segment boundary\", f); break;\n    case ANCR_NO_TEXT_SEGMENT_BOUNDARY:\n      fputs(\"no text-segment boundary\", f); break;\n    case ANCR_PREC_READ:\n      fprintf(f, \"prec read\\n\");\n      print_indent_tree(f, NODE_BODY(node), indent + add);\n      break;\n    case ANCR_PREC_READ_NOT:\n      fprintf(f, \"prec read not\\n\");\n      print_indent_tree(f, NODE_BODY(node), indent + add);\n      break;\n    case ANCR_LOOK_BEHIND:\n      fprintf(f, \"look behind\\n\");\n      print_indent_tree(f, NODE_BODY(node), indent + add);\n      break;\n    case ANCR_LOOK_BEHIND_NOT:\n      fprintf(f, \"look behind not\\n\");\n      print_indent_tree(f, NODE_BODY(node), indent + add);\n      break;\n\n    default:\n      fprintf(f, \"ERROR: undefined anchor type.\\n\");\n      break;\n    }\n    break;\n\n  case NODE_BACKREF:\n    {\n      int* p;\n      BackRefNode* br = BACKREF_(node);\n      p = BACKREFS_P(br);\n      fprintf(f, \"<backref%s:%p>\", NODE_IS_CHECKER(node) ? \"-checker\" : \"\", node);\n      for (i = 0; i < br->back_num; i++) {\n        if (i > 0) fputs(\", \", f);\n        fprintf(f, \"%d\", p[i]);\n      }\n    }\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    {\n      CallNode* cn = CALL_(node);\n      fprintf(f, \"<call:%p>\", node);\n      p_string(f, cn->name_end - cn->name, cn->name);\n    }\n    break;\n#endif\n\n  case NODE_QUANT:\n    fprintf(f, \"<quantifier:%p>{%d,%d}%s\\n\", node,\n            QUANT_(node)->lower, QUANT_(node)->upper,\n            (QUANT_(node)->greedy ? \"\" : \"?\"));\n    print_indent_tree(f, NODE_BODY(node), indent + add);\n    break;\n\n  case NODE_BAG:\n    fprintf(f, \"<bag:%p> \", node);\n    switch (BAG_(node)->type) {\n    case BAG_OPTION:\n      fprintf(f, \"option:%d\", BAG_(node)->o.options);\n      break;\n    case BAG_MEMORY:\n      fprintf(f, \"memory:%d\", BAG_(node)->m.regnum);\n      break;\n    case BAG_STOP_BACKTRACK:\n      fprintf(f, \"stop-bt\");\n      break;\n    case BAG_IF_ELSE:\n      fprintf(f, \"if-else\");\n      break;\n    }\n    fprintf(f, \"\\n\");\n    print_indent_tree(f, NODE_BODY(node), indent + add);\n    break;\n\n  case NODE_GIMMICK:\n    fprintf(f, \"<gimmick:%p> \", node);\n    switch (GIMMICK_(node)->type) {\n    case GIMMICK_FAIL:\n      fprintf(f, \"fail\");\n      break;\n    case GIMMICK_SAVE:\n      fprintf(f, \"save:%d:%d\", GIMMICK_(node)->detail_type, GIMMICK_(node)->id);\n      break;\n    case GIMMICK_UPDATE_VAR:\n      fprintf(f, \"update_var:%d:%d\", GIMMICK_(node)->detail_type, GIMMICK_(node)->id);\n      break;\n#ifdef USE_CALLOUT\n    case GIMMICK_CALLOUT:\n      switch (GIMMICK_(node)->detail_type) {\n      case ONIG_CALLOUT_OF_CONTENTS:\n        fprintf(f, \"callout:contents:%d\", GIMMICK_(node)->num);\n        break;\n      case ONIG_CALLOUT_OF_NAME:\n        fprintf(f, \"callout:name:%d:%d\", GIMMICK_(node)->id, GIMMICK_(node)->num);\n        break;\n      }\n#endif\n    }\n    break;\n\n  default:\n    fprintf(f, \"print_indent_tree: undefined node type %d\\n\", NODE_TYPE(node));\n    break;\n  }\n\n  if (type != NODE_LIST && type != NODE_ALT && type != NODE_QUANT &&\n      type != NODE_BAG)\n    fprintf(f, \"\\n\");\n  fflush(f);\n}\n\nstatic void\nprint_tree(FILE* f, Node* node)\n{\n  print_indent_tree(f, node, 0);\n}\n#endif\n"], "fixing_code": ["/**********************************************************************\n  regcomp.c -  Oniguruma (regular expression library)\n**********************************************************************/\n/*-\n * Copyright (c) 2002-2019  K.Kosako  <sndgk393 AT ybb DOT ne DOT jp>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"regparse.h\"\n\n#define OPS_INIT_SIZE  8\n\nOnigCaseFoldType OnigDefaultCaseFoldFlag = ONIGENC_CASE_FOLD_MIN;\n\n#if 0\ntypedef struct {\n  int  n;\n  int  alloc;\n  int* v;\n} int_stack;\n\nstatic int\nmake_int_stack(int_stack** rs, int init_size)\n{\n  int_stack* s;\n  int* v;\n\n  *rs = 0;\n\n  s = xmalloc(sizeof(*s));\n  if (IS_NULL(s)) return ONIGERR_MEMORY;\n\n  v = (int* )xmalloc(sizeof(int) * init_size);\n  if (IS_NULL(v)) {\n    xfree(s);\n    return ONIGERR_MEMORY;\n  }\n\n  s->n = 0;\n  s->alloc = init_size;\n  s->v = v;\n\n  *rs = s;\n  return ONIG_NORMAL;\n}\n\nstatic void\nfree_int_stack(int_stack* s)\n{\n  if (IS_NOT_NULL(s)) {\n    if (IS_NOT_NULL(s->v))\n      xfree(s->v);\n    xfree(s);\n  }\n}\n\nstatic int\nint_stack_push(int_stack* s, int v)\n{\n  if (s->n >= s->alloc) {\n    int new_size = s->alloc * 2;\n    int* nv = (int* )xrealloc(s->v, sizeof(int) * new_size);\n    if (IS_NULL(nv)) return ONIGERR_MEMORY;\n\n    s->alloc = new_size;\n    s->v = nv;\n  }\n\n  s->v[s->n] = v;\n  s->n++;\n  return ONIG_NORMAL;\n}\n\nstatic int\nint_stack_pop(int_stack* s)\n{\n  int v;\n\n#ifdef ONIG_DEBUG\n  if (s->n <= 0) {\n    fprintf(stderr, \"int_stack_pop: fail empty. %p\\n\", s);\n    return 0;\n  }\n#endif\n\n  v = s->v[s->n];\n  s->n--;\n  return v;\n}\n#endif\n\nstatic int\nops_init(regex_t* reg, int init_alloc_size)\n{\n  Operation* p;\n  size_t size;\n\n  if (init_alloc_size > 0) {\n    size = sizeof(Operation) * init_alloc_size;\n    p = (Operation* )xrealloc(reg->ops, size);\n    CHECK_NULL_RETURN_MEMERR(p);\n#ifdef USE_DIRECT_THREADED_CODE\n    {\n      enum OpCode* cp;\n      size = sizeof(enum OpCode) * init_alloc_size;\n      cp = (enum OpCode* )xrealloc(reg->ocs, size);\n      CHECK_NULL_RETURN_MEMERR(cp);\n      reg->ocs = cp;\n    }\n#endif\n  }\n  else {\n    p  = (Operation* )0;\n#ifdef USE_DIRECT_THREADED_CODE\n    reg->ocs = (enum OpCode* )0;\n#endif\n  }\n\n  reg->ops = p;\n  reg->ops_curr  = 0; /* !!! not yet done ops_new() */\n  reg->ops_alloc = init_alloc_size;\n  reg->ops_used  = 0;\n\n  return ONIG_NORMAL;\n}\n\nstatic int\nops_expand(regex_t* reg, int n)\n{\n#define MIN_OPS_EXPAND_SIZE   4\n\n#ifdef USE_DIRECT_THREADED_CODE\n  enum OpCode* cp;\n#endif\n  Operation* p;\n  size_t size;\n\n  if (n <= 0) n = MIN_OPS_EXPAND_SIZE;\n\n  n += reg->ops_alloc;\n\n  size = sizeof(Operation) * n;\n  p = (Operation* )xrealloc(reg->ops, size);\n  CHECK_NULL_RETURN_MEMERR(p);\n\n#ifdef USE_DIRECT_THREADED_CODE\n  size = sizeof(enum OpCode) * n;\n  cp = (enum OpCode* )xrealloc(reg->ocs, size);\n  CHECK_NULL_RETURN_MEMERR(cp);\n  reg->ocs = cp;\n#endif\n\n  reg->ops = p;\n  reg->ops_alloc = n;\n  if (reg->ops_used == 0)\n    reg->ops_curr = 0;\n  else\n    reg->ops_curr = reg->ops + (reg->ops_used - 1);\n\n  return ONIG_NORMAL;\n}\n\nstatic int\nops_new(regex_t* reg)\n{\n  int r;\n\n  if (reg->ops_used >= reg->ops_alloc) {\n    r = ops_expand(reg, reg->ops_alloc);\n    if (r != ONIG_NORMAL) return r;\n  }\n\n  reg->ops_curr = reg->ops + reg->ops_used;\n  reg->ops_used++;\n\n  xmemset(reg->ops_curr, 0, sizeof(Operation));\n  return ONIG_NORMAL;\n}\n\nstatic int\nis_in_string_pool(regex_t* reg, UChar* s)\n{\n  return (s >= reg->string_pool && s < reg->string_pool_end);\n}\n\nstatic void\nops_free(regex_t* reg)\n{\n  int i;\n\n  if (IS_NULL(reg->ops)) return ;\n\n  for (i = 0; i < (int )reg->ops_used; i++) {\n    enum OpCode opcode;\n    Operation* op;\n\n    op = reg->ops + i;\n\n#ifdef USE_DIRECT_THREADED_CODE\n    opcode = *(reg->ocs + i);\n#else\n    opcode = op->opcode;\n#endif\n\n    switch (opcode) {\n    case OP_EXACTMBN:\n      if (! is_in_string_pool(reg, op->exact_len_n.s))\n        xfree(op->exact_len_n.s);\n      break;\n    case OP_EXACTN: case OP_EXACTMB2N: case OP_EXACTMB3N: case OP_EXACTN_IC:\n      if (! is_in_string_pool(reg, op->exact_n.s))\n        xfree(op->exact_n.s);\n      break;\n    case OP_EXACT1: case OP_EXACT2: case OP_EXACT3: case OP_EXACT4:\n    case OP_EXACT5: case OP_EXACTMB2N1: case OP_EXACTMB2N2:\n    case OP_EXACTMB2N3: case OP_EXACT1_IC:\n      break;\n\n    case OP_CCLASS_NOT: case OP_CCLASS:\n      xfree(op->cclass.bsp);\n      break;\n\n    case OP_CCLASS_MB_NOT: case OP_CCLASS_MB:\n      xfree(op->cclass_mb.mb);\n      break;\n    case OP_CCLASS_MIX_NOT: case OP_CCLASS_MIX:\n      xfree(op->cclass_mix.mb);\n      xfree(op->cclass_mix.bsp);\n      break;\n\n    case OP_BACKREF1: case OP_BACKREF2: case OP_BACKREF_N: case OP_BACKREF_N_IC:\n      break;\n    case OP_BACKREF_MULTI:      case OP_BACKREF_MULTI_IC:\n    case OP_BACKREF_WITH_LEVEL:\n    case OP_BACKREF_WITH_LEVEL_IC:\n    case OP_BACKREF_CHECK:\n    case OP_BACKREF_CHECK_WITH_LEVEL:\n      if (op->backref_general.num != 1)\n        xfree(op->backref_general.ns);\n      break;\n\n    default:\n      break;\n    }\n  }\n\n  xfree(reg->ops);\n#ifdef USE_DIRECT_THREADED_CODE\n  xfree(reg->ocs);\n  reg->ocs = 0;\n#endif\n\n  reg->ops = 0;\n  reg->ops_curr  = 0;\n  reg->ops_alloc = 0;\n  reg->ops_used  = 0;\n}\n\nstatic int\nops_calc_size_of_string_pool(regex_t* reg)\n{\n  int i;\n  int total;\n\n  if (IS_NULL(reg->ops)) return 0;\n\n  total = 0;\n  for (i = 0; i < (int )reg->ops_used; i++) {\n    enum OpCode opcode;\n    Operation* op;\n\n    op = reg->ops + i;\n#ifdef USE_DIRECT_THREADED_CODE\n    opcode = *(reg->ocs + i);\n#else\n    opcode = op->opcode;\n#endif\n\n    switch (opcode) {\n    case OP_EXACTMBN:\n      total += op->exact_len_n.len * op->exact_len_n.n;\n      break;\n    case OP_EXACTN:\n    case OP_EXACTN_IC:\n      total += op->exact_n.n;\n      break;\n    case OP_EXACTMB2N:\n      total += op->exact_n.n * 2;\n      break;\n    case OP_EXACTMB3N:\n      total += op->exact_n.n * 3;\n      break;\n\n    default:\n      break;\n    }\n  }\n\n  return total;\n}\n\nstatic int\nops_make_string_pool(regex_t* reg)\n{\n  int i;\n  int len;\n  int size;\n  UChar* pool;\n  UChar* curr;\n\n  size = ops_calc_size_of_string_pool(reg);\n  if (size <= 0) {\n    return 0;\n  }\n\n  curr = pool = (UChar* )xmalloc((size_t )size);\n  CHECK_NULL_RETURN_MEMERR(pool);\n\n  for (i = 0; i < (int )reg->ops_used; i++) {\n    enum OpCode opcode;\n    Operation* op;\n\n    op = reg->ops + i;\n#ifdef USE_DIRECT_THREADED_CODE\n    opcode = *(reg->ocs + i);\n#else\n    opcode = op->opcode;\n#endif\n\n    switch (opcode) {\n    case OP_EXACTMBN:\n      len = op->exact_len_n.len * op->exact_len_n.n;\n      xmemcpy(curr, op->exact_len_n.s, len);\n      xfree(op->exact_len_n.s);\n      op->exact_len_n.s = curr;\n      curr += len;\n      break;\n    case OP_EXACTN:\n    case OP_EXACTN_IC:\n      len = op->exact_n.n;\n    copy:\n      xmemcpy(curr, op->exact_n.s, len);\n      xfree(op->exact_n.s);\n      op->exact_n.s = curr;\n      curr += len;\n      break;\n    case OP_EXACTMB2N:\n      len = op->exact_n.n * 2;\n      goto copy;\n      break;\n    case OP_EXACTMB3N:\n      len = op->exact_n.n * 3;\n      goto copy;\n      break;\n\n    default:\n      break;\n    }\n  }\n\n  reg->string_pool     = pool;\n  reg->string_pool_end = pool + size;\n  return 0;\n}\n\nextern OnigCaseFoldType\nonig_get_default_case_fold_flag(void)\n{\n  return OnigDefaultCaseFoldFlag;\n}\n\nextern int\nonig_set_default_case_fold_flag(OnigCaseFoldType case_fold_flag)\n{\n  OnigDefaultCaseFoldFlag = case_fold_flag;\n  return 0;\n}\n\nstatic int\nint_multiply_cmp(int x, int y, int v)\n{\n  if (x == 0 || y == 0) return -1;\n\n  if (x < INT_MAX / y) {\n    int xy = x * y;\n    if (xy > v) return 1;\n    else {\n      if (xy == v) return 0;\n      else return -1;\n    }\n  }\n  else\n    return 1;\n}\n\nextern int\nonig_positive_int_multiply(int x, int y)\n{\n  if (x == 0 || y == 0) return 0;\n\n  if (x < INT_MAX / y)\n    return x * y;\n  else\n    return -1;\n}\n\n\nstatic void\nswap_node(Node* a, Node* b)\n{\n  Node c;\n\n  c = *a; *a = *b; *b = c;\n\n  if (NODE_TYPE(a) == NODE_STRING) {\n    StrNode* sn = STR_(a);\n    if (sn->capacity == 0) {\n      int len = (int )(sn->end - sn->s);\n      sn->s   = sn->buf;\n      sn->end = sn->s + len;\n    }\n  }\n\n  if (NODE_TYPE(b) == NODE_STRING) {\n    StrNode* sn = STR_(b);\n    if (sn->capacity == 0) {\n      int len = (int )(sn->end - sn->s);\n      sn->s   = sn->buf;\n      sn->end = sn->s + len;\n    }\n  }\n}\n\nstatic OnigLen\ndistance_add(OnigLen d1, OnigLen d2)\n{\n  if (d1 == INFINITE_LEN || d2 == INFINITE_LEN)\n    return INFINITE_LEN;\n  else {\n    if (d1 <= INFINITE_LEN - d2) return d1 + d2;\n    else return INFINITE_LEN;\n  }\n}\n\nstatic OnigLen\ndistance_multiply(OnigLen d, int m)\n{\n  if (m == 0) return 0;\n\n  if (d < INFINITE_LEN / m)\n    return d * m;\n  else\n    return INFINITE_LEN;\n}\n\nstatic int\nbitset_is_empty(BitSetRef bs)\n{\n  int i;\n\n  for (i = 0; i < (int )BITSET_SIZE; i++) {\n    if (bs[i] != 0) return 0;\n  }\n  return 1;\n}\n\n#ifdef USE_CALL\n\nstatic int\nunset_addr_list_init(UnsetAddrList* list, int size)\n{\n  UnsetAddr* p = (UnsetAddr* )xmalloc(sizeof(UnsetAddr)* size);\n  CHECK_NULL_RETURN_MEMERR(p);\n\n  list->num   = 0;\n  list->alloc = size;\n  list->us    = p;\n  return 0;\n}\n\nstatic void\nunset_addr_list_end(UnsetAddrList* list)\n{\n  if (IS_NOT_NULL(list->us))\n    xfree(list->us);\n}\n\nstatic int\nunset_addr_list_add(UnsetAddrList* list, int offset, struct _Node* node)\n{\n  UnsetAddr* p;\n  int size;\n\n  if (list->num >= list->alloc) {\n    size = list->alloc * 2;\n    p = (UnsetAddr* )xrealloc(list->us, sizeof(UnsetAddr) * size);\n    CHECK_NULL_RETURN_MEMERR(p);\n    list->alloc = size;\n    list->us    = p;\n  }\n\n  list->us[list->num].offset = offset;\n  list->us[list->num].target = node;\n  list->num++;\n  return 0;\n}\n#endif /* USE_CALL */\n\n\nstatic int\nadd_op(regex_t* reg, int opcode)\n{\n  int r;\n\n  r = ops_new(reg);\n  if (r != ONIG_NORMAL) return r;\n\n#ifdef USE_DIRECT_THREADED_CODE\n  *(reg->ocs + (reg->ops_curr - reg->ops)) = opcode;\n#else\n  reg->ops_curr->opcode = opcode;\n#endif\n\n  return 0;\n}\n\nstatic int compile_length_tree(Node* node, regex_t* reg);\nstatic int compile_tree(Node* node, regex_t* reg, ScanEnv* env);\n\n\n#define IS_NEED_STR_LEN_OP_EXACT(op) \\\n   ((op) == OP_EXACTN    || (op) == OP_EXACTMB2N ||\\\n    (op) == OP_EXACTMB3N || (op) == OP_EXACTMBN  || (op) == OP_EXACTN_IC)\n\nstatic int\nselect_str_opcode(int mb_len, int str_len, int ignore_case)\n{\n  int op;\n\n  if (ignore_case) {\n    switch (str_len) {\n    case 1:  op = OP_EXACT1_IC; break;\n    default: op = OP_EXACTN_IC; break;\n    }\n  }\n  else {\n    switch (mb_len) {\n    case 1:\n      switch (str_len) {\n      case 1:  op = OP_EXACT1; break;\n      case 2:  op = OP_EXACT2; break;\n      case 3:  op = OP_EXACT3; break;\n      case 4:  op = OP_EXACT4; break;\n      case 5:  op = OP_EXACT5; break;\n      default: op = OP_EXACTN; break;\n      }\n      break;\n\n    case 2:\n      switch (str_len) {\n      case 1:  op = OP_EXACTMB2N1; break;\n      case 2:  op = OP_EXACTMB2N2; break;\n      case 3:  op = OP_EXACTMB2N3; break;\n      default: op = OP_EXACTMB2N;  break;\n      }\n      break;\n\n    case 3:\n      op = OP_EXACTMB3N;\n      break;\n\n    default:\n      op = OP_EXACTMBN;\n      break;\n    }\n  }\n  return op;\n}\n\nstatic int\ncompile_tree_empty_check(Node* node, regex_t* reg, int empty_info, ScanEnv* env)\n{\n  int r;\n  int saved_num_null_check = reg->num_null_check;\n\n  if (empty_info != BODY_IS_NOT_EMPTY) {\n    r = add_op(reg, OP_EMPTY_CHECK_START);\n    if (r != 0) return r;\n    COP(reg)->empty_check_start.mem = reg->num_null_check; /* NULL CHECK ID */\n    reg->num_null_check++;\n  }\n\n  r = compile_tree(node, reg, env);\n  if (r != 0) return r;\n\n  if (empty_info != BODY_IS_NOT_EMPTY) {\n    if (empty_info == BODY_IS_EMPTY)\n      r = add_op(reg, OP_EMPTY_CHECK_END);\n    else if (empty_info == BODY_IS_EMPTY_MEM)\n      r = add_op(reg, OP_EMPTY_CHECK_END_MEMST);\n    else if (empty_info == BODY_IS_EMPTY_REC)\n      r = add_op(reg, OP_EMPTY_CHECK_END_MEMST_PUSH);\n\n    if (r != 0) return r;\n    COP(reg)->empty_check_end.mem = saved_num_null_check; /* NULL CHECK ID */\n  }\n  return r;\n}\n\n#ifdef USE_CALL\nstatic int\ncompile_call(CallNode* node, regex_t* reg, ScanEnv* env)\n{\n  int r;\n  int offset;\n\n  r = add_op(reg, OP_CALL);\n  if (r != 0) return r;\n\n  COP(reg)->call.addr = 0; /* dummy addr. */\n\n  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);\n  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));\n  return r;\n}\n#endif\n\nstatic int\ncompile_tree_n_times(Node* node, int n, regex_t* reg, ScanEnv* env)\n{\n  int i, r;\n\n  for (i = 0; i < n; i++) {\n    r = compile_tree(node, reg, env);\n    if (r != 0) return r;\n  }\n  return 0;\n}\n\nstatic int\nadd_compile_string_length(UChar* s ARG_UNUSED, int mb_len, int str_len,\n                          regex_t* reg ARG_UNUSED, int ignore_case)\n{\n  return 1;\n}\n\nstatic int\nadd_compile_string(UChar* s, int mb_len, int str_len,\n                   regex_t* reg, int ignore_case)\n{\n  int op;\n  int r;\n  int byte_len;\n  UChar* p;\n  UChar* end;\n\n  op = select_str_opcode(mb_len, str_len, ignore_case);\n  r = add_op(reg, op);\n  if (r != 0) return r;\n\n  byte_len = mb_len * str_len;\n  end = s + byte_len;\n\n  if (op == OP_EXACTMBN) {\n    p = onigenc_strdup(reg->enc, s, end);\n    CHECK_NULL_RETURN_MEMERR(p);\n\n    COP(reg)->exact_len_n.len = mb_len;\n    COP(reg)->exact_len_n.n   = str_len;\n    COP(reg)->exact_len_n.s   = p;\n  }\n  else if (IS_NEED_STR_LEN_OP_EXACT(op)) {\n    p = onigenc_strdup(reg->enc, s, end);\n    CHECK_NULL_RETURN_MEMERR(p);\n\n    if (op == OP_EXACTN_IC)\n      COP(reg)->exact_n.n = byte_len;\n    else\n      COP(reg)->exact_n.n = str_len;\n\n    COP(reg)->exact_n.s = p;\n  }\n  else {\n    xmemcpy(COP(reg)->exact.s, s, (size_t )byte_len);\n    COP(reg)->exact.s[byte_len] = '\\0';\n  }\n\n  return 0;\n}\n\nstatic int\ncompile_length_string_node(Node* node, regex_t* reg)\n{\n  int rlen, r, len, prev_len, slen, ambig;\n  UChar *p, *prev;\n  StrNode* sn;\n  OnigEncoding enc = reg->enc;\n\n  sn = STR_(node);\n  if (sn->end <= sn->s)\n    return 0;\n\n  ambig = NODE_STRING_IS_AMBIG(node);\n\n  p = prev = sn->s;\n  prev_len = enclen(enc, p);\n  p += prev_len;\n  slen = 1;\n  rlen = 0;\n\n  for (; p < sn->end; ) {\n    len = enclen(enc, p);\n    if (len == prev_len) {\n      slen++;\n    }\n    else {\n      r = add_compile_string_length(prev, prev_len, slen, reg, ambig);\n      rlen += r;\n      prev = p;\n      slen = 1;\n      prev_len = len;\n    }\n    p += len;\n  }\n\n  r = add_compile_string_length(prev, prev_len, slen, reg, ambig);\n  rlen += r;\n  return rlen;\n}\n\nstatic int\ncompile_length_string_raw_node(StrNode* sn, regex_t* reg)\n{\n  if (sn->end <= sn->s)\n    return 0;\n\n  return add_compile_string_length(sn->s, 1 /* sb */, (int )(sn->end - sn->s),\n                                   reg, 0);\n}\n\nstatic int\ncompile_string_node(Node* node, regex_t* reg)\n{\n  int r, len, prev_len, slen, ambig;\n  UChar *p, *prev, *end;\n  StrNode* sn;\n  OnigEncoding enc = reg->enc;\n\n  sn = STR_(node);\n  if (sn->end <= sn->s)\n    return 0;\n\n  end = sn->end;\n  ambig = NODE_STRING_IS_AMBIG(node);\n\n  p = prev = sn->s;\n  prev_len = enclen(enc, p);\n  p += prev_len;\n  slen = 1;\n\n  for (; p < end; ) {\n    len = enclen(enc, p);\n    if (len == prev_len) {\n      slen++;\n    }\n    else {\n      r = add_compile_string(prev, prev_len, slen, reg, ambig);\n      if (r != 0) return r;\n\n      prev  = p;\n      slen  = 1;\n      prev_len = len;\n    }\n\n    p += len;\n  }\n\n  return add_compile_string(prev, prev_len, slen, reg, ambig);\n}\n\nstatic int\ncompile_string_raw_node(StrNode* sn, regex_t* reg)\n{\n  if (sn->end <= sn->s)\n    return 0;\n\n  return add_compile_string(sn->s, 1 /* sb */, (int )(sn->end - sn->s), reg, 0);\n}\n\nstatic void*\nset_multi_byte_cclass(BBuf* mbuf, regex_t* reg)\n{\n  size_t len;\n  void* p;\n\n  len = (size_t )mbuf->used;\n  p = xmalloc(len);\n  if (IS_NULL(p)) return NULL;\n\n  xmemcpy(p, mbuf->p, len);\n  return p;\n}\n\nstatic int\ncompile_length_cclass_node(CClassNode* cc, regex_t* reg)\n{\n  return 1;\n}\n\nstatic int\ncompile_cclass_node(CClassNode* cc, regex_t* reg)\n{\n  int r;\n\n  if (IS_NULL(cc->mbuf)) {\n    r = add_op(reg, IS_NCCLASS_NOT(cc) ? OP_CCLASS_NOT : OP_CCLASS);\n    if (r != 0) return r;\n\n    COP(reg)->cclass.bsp = xmalloc(SIZE_BITSET);\n    CHECK_NULL_RETURN_MEMERR(COP(reg)->cclass.bsp);\n    xmemcpy(COP(reg)->cclass.bsp, cc->bs, SIZE_BITSET);\n  }\n  else {\n    void* p;\n\n    if (ONIGENC_MBC_MINLEN(reg->enc) > 1 || bitset_is_empty(cc->bs)) {\n      r = add_op(reg, IS_NCCLASS_NOT(cc) ? OP_CCLASS_MB_NOT : OP_CCLASS_MB);\n      if (r != 0) return r;\n\n      p = set_multi_byte_cclass(cc->mbuf, reg);\n      CHECK_NULL_RETURN_MEMERR(p);\n      COP(reg)->cclass_mb.mb = p;\n    }\n    else {\n      r = add_op(reg, IS_NCCLASS_NOT(cc) ? OP_CCLASS_MIX_NOT : OP_CCLASS_MIX);\n      if (r != 0) return r;\n\n      COP(reg)->cclass_mix.bsp = xmalloc(SIZE_BITSET);\n      CHECK_NULL_RETURN_MEMERR(COP(reg)->cclass_mix.bsp);\n      xmemcpy(COP(reg)->cclass_mix.bsp, cc->bs, SIZE_BITSET);\n\n      p = set_multi_byte_cclass(cc->mbuf, reg);\n      CHECK_NULL_RETURN_MEMERR(p);\n      COP(reg)->cclass_mix.mb = p;\n    }\n  }\n\n  return 0;\n}\n\nstatic int\nentry_repeat_range(regex_t* reg, int id, int lower, int upper)\n{\n#define REPEAT_RANGE_ALLOC  4\n\n  OnigRepeatRange* p;\n\n  if (reg->repeat_range_alloc == 0) {\n    p = (OnigRepeatRange* )xmalloc(sizeof(OnigRepeatRange) * REPEAT_RANGE_ALLOC);\n    CHECK_NULL_RETURN_MEMERR(p);\n    reg->repeat_range = p;\n    reg->repeat_range_alloc = REPEAT_RANGE_ALLOC;\n  }\n  else if (reg->repeat_range_alloc <= id) {\n    int n;\n    n = reg->repeat_range_alloc + REPEAT_RANGE_ALLOC;\n    p = (OnigRepeatRange* )xrealloc(reg->repeat_range, sizeof(OnigRepeatRange) * n);\n    CHECK_NULL_RETURN_MEMERR(p);\n    reg->repeat_range = p;\n    reg->repeat_range_alloc = n;\n  }\n  else {\n    p = reg->repeat_range;\n  }\n\n  p[id].lower = lower;\n  p[id].upper = (IS_REPEAT_INFINITE(upper) ? 0x7fffffff : upper);\n  return 0;\n}\n\nstatic int\ncompile_range_repeat_node(QuantNode* qn, int target_len, int empty_info,\n                          regex_t* reg, ScanEnv* env)\n{\n  int r;\n  int num_repeat = reg->num_repeat++;\n\n  r = add_op(reg, qn->greedy ? OP_REPEAT : OP_REPEAT_NG);\n  if (r != 0) return r;\n\n  COP(reg)->repeat.id   = num_repeat;\n  COP(reg)->repeat.addr = SIZE_INC_OP + target_len + SIZE_OP_REPEAT_INC;\n\n  r = entry_repeat_range(reg, num_repeat, qn->lower, qn->upper);\n  if (r != 0) return r;\n\n  r = compile_tree_empty_check(NODE_QUANT_BODY(qn), reg, empty_info, env);\n  if (r != 0) return r;\n\n  if (\n#ifdef USE_CALL\n      NODE_IS_IN_MULTI_ENTRY(qn) ||\n#endif\n      NODE_IS_IN_REAL_REPEAT(qn)) {\n    r = add_op(reg, qn->greedy ? OP_REPEAT_INC_SG : OP_REPEAT_INC_NG_SG);\n  }\n  else {\n    r = add_op(reg, qn->greedy ? OP_REPEAT_INC : OP_REPEAT_INC_NG);\n  }\n  if (r != 0) return r;\n\n  COP(reg)->repeat_inc.id = num_repeat;\n  return r;\n}\n\nstatic int\nis_anychar_infinite_greedy(QuantNode* qn)\n{\n  if (qn->greedy && IS_REPEAT_INFINITE(qn->upper) &&\n      NODE_IS_ANYCHAR(NODE_QUANT_BODY(qn)))\n    return 1;\n  else\n    return 0;\n}\n\n#define QUANTIFIER_EXPAND_LIMIT_SIZE   10\n#define CKN_ON   (ckn > 0)\n\nstatic int\ncompile_length_quantifier_node(QuantNode* qn, regex_t* reg)\n{\n  int len, mod_tlen;\n  int infinite = IS_REPEAT_INFINITE(qn->upper);\n  enum BodyEmpty empty_info = qn->empty_info;\n  int tlen = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n\n  if (tlen < 0) return tlen;\n  if (tlen == 0) return 0;\n\n  /* anychar repeat */\n  if (is_anychar_infinite_greedy(qn)) {\n    if (qn->lower <= 1 ||\n        int_multiply_cmp(tlen, qn->lower, QUANTIFIER_EXPAND_LIMIT_SIZE) <= 0) {\n      if (IS_NOT_NULL(qn->next_head_exact))\n        return SIZE_OP_ANYCHAR_STAR_PEEK_NEXT + tlen * qn->lower;\n      else\n        return SIZE_OP_ANYCHAR_STAR + tlen * qn->lower;\n    }\n  }\n\n  if (empty_info == BODY_IS_NOT_EMPTY)\n    mod_tlen = tlen;\n  else\n    mod_tlen = tlen + (SIZE_OP_EMPTY_CHECK_START + SIZE_OP_EMPTY_CHECK_END);\n\n  if (infinite &&\n      (qn->lower <= 1 ||\n       int_multiply_cmp(tlen, qn->lower, QUANTIFIER_EXPAND_LIMIT_SIZE) <= 0)) {\n    if (qn->lower == 1 && tlen > QUANTIFIER_EXPAND_LIMIT_SIZE) {\n      len = SIZE_OP_JUMP;\n    }\n    else {\n      len = tlen * qn->lower;\n    }\n\n    if (qn->greedy) {\n#ifdef USE_OP_PUSH_OR_JUMP_EXACT\n      if (IS_NOT_NULL(qn->head_exact))\n        len += SIZE_OP_PUSH_OR_JUMP_EXACT1 + mod_tlen + SIZE_OP_JUMP;\n      else\n#endif\n      if (IS_NOT_NULL(qn->next_head_exact))\n        len += SIZE_OP_PUSH_IF_PEEK_NEXT + mod_tlen + SIZE_OP_JUMP;\n      else\n        len += SIZE_OP_PUSH + mod_tlen + SIZE_OP_JUMP;\n    }\n    else\n      len += SIZE_OP_JUMP + mod_tlen + SIZE_OP_PUSH;\n  }\n  else if (qn->upper == 0) {\n    if (qn->is_refered != 0) { /* /(?<n>..){0}/ */\n      len = SIZE_OP_JUMP + tlen;\n    }\n    else\n      len = 0;\n  }\n  else if (!infinite && qn->greedy &&\n           (qn->upper == 1 ||\n            int_multiply_cmp(tlen + SIZE_OP_PUSH, qn->upper,\n                             QUANTIFIER_EXPAND_LIMIT_SIZE) <= 0)) {\n    len = tlen * qn->lower;\n    len += (SIZE_OP_PUSH + tlen) * (qn->upper - qn->lower);\n  }\n  else if (!qn->greedy && qn->upper == 1 && qn->lower == 0) { /* '??' */\n    len = SIZE_OP_PUSH + SIZE_OP_JUMP + tlen;\n  }\n  else {\n    len = SIZE_OP_REPEAT_INC + mod_tlen + SIZE_OP_REPEAT;\n  }\n\n  return len;\n}\n\nstatic int\ncompile_quantifier_node(QuantNode* qn, regex_t* reg, ScanEnv* env)\n{\n  int i, r, mod_tlen;\n  int infinite = IS_REPEAT_INFINITE(qn->upper);\n  enum BodyEmpty empty_info = qn->empty_info;\n  int tlen = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n\n  if (tlen < 0) return tlen;\n  if (tlen == 0) return 0;\n\n  if (is_anychar_infinite_greedy(qn) &&\n      (qn->lower <= 1 ||\n       int_multiply_cmp(tlen, qn->lower, QUANTIFIER_EXPAND_LIMIT_SIZE) <= 0)) {\n    r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);\n    if (r != 0) return r;\n    if (IS_NOT_NULL(qn->next_head_exact)) {\n      r = add_op(reg,\n                 IS_MULTILINE(CTYPE_OPTION(NODE_QUANT_BODY(qn), reg)) ?\n                 OP_ANYCHAR_ML_STAR_PEEK_NEXT : OP_ANYCHAR_STAR_PEEK_NEXT);\n      if (r != 0) return r;\n\n      COP(reg)->anychar_star_peek_next.c = STR_(qn->next_head_exact)->s[0];\n      return 0;\n    }\n    else {\n      r = add_op(reg,\n                 IS_MULTILINE(CTYPE_OPTION(NODE_QUANT_BODY(qn), reg)) ?\n                 OP_ANYCHAR_ML_STAR : OP_ANYCHAR_STAR);\n      return r;\n    }\n  }\n\n  if (empty_info == BODY_IS_NOT_EMPTY)\n    mod_tlen = tlen;\n  else\n    mod_tlen = tlen + (SIZE_OP_EMPTY_CHECK_START + SIZE_OP_EMPTY_CHECK_END);\n\n  if (infinite &&\n      (qn->lower <= 1 ||\n       int_multiply_cmp(tlen, qn->lower, QUANTIFIER_EXPAND_LIMIT_SIZE) <= 0)) {\n    int addr;\n\n    if (qn->lower == 1 && tlen > QUANTIFIER_EXPAND_LIMIT_SIZE) {\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      if (qn->greedy) {\n#ifdef USE_OP_PUSH_OR_JUMP_EXACT\n        if (IS_NOT_NULL(qn->head_exact))\n          COP(reg)->jump.addr = SIZE_OP_PUSH_OR_JUMP_EXACT1 + SIZE_INC_OP;\n        else\n#endif\n        if (IS_NOT_NULL(qn->next_head_exact))\n          COP(reg)->jump.addr = SIZE_OP_PUSH_IF_PEEK_NEXT + SIZE_INC_OP;\n        else\n          COP(reg)->jump.addr = SIZE_OP_PUSH + SIZE_INC_OP;\n      }\n      else {\n        COP(reg)->jump.addr = SIZE_OP_JUMP + SIZE_INC_OP;\n      }\n    }\n    else {\n      r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);\n      if (r != 0) return r;\n    }\n\n    if (qn->greedy) {\n#ifdef USE_OP_PUSH_OR_JUMP_EXACT\n      if (IS_NOT_NULL(qn->head_exact)) {\n        r = add_op(reg, OP_PUSH_OR_JUMP_EXACT1);\n        if (r != 0) return r;\n        COP(reg)->push_or_jump_exact1.addr = SIZE_INC_OP + mod_tlen + SIZE_OP_JUMP;\n        COP(reg)->push_or_jump_exact1.c    = STR_(qn->head_exact)->s[0];\n\n        r = compile_tree_empty_check(NODE_QUANT_BODY(qn), reg, empty_info, env);\n        if (r != 0) return r;\n\n        addr = -(mod_tlen + (int )SIZE_OP_PUSH_OR_JUMP_EXACT1);\n      }\n      else\n#endif\n      if (IS_NOT_NULL(qn->next_head_exact)) {\n        r = add_op(reg, OP_PUSH_IF_PEEK_NEXT);\n        if (r != 0) return r;\n        COP(reg)->push_if_peek_next.addr = SIZE_INC_OP + mod_tlen + SIZE_OP_JUMP;\n        COP(reg)->push_if_peek_next.c    = STR_(qn->next_head_exact)->s[0];\n\n        r = compile_tree_empty_check(NODE_QUANT_BODY(qn), reg, empty_info, env);\n        if (r != 0) return r;\n\n        addr = -(mod_tlen + (int )SIZE_OP_PUSH_IF_PEEK_NEXT);\n      }\n      else {\n        r = add_op(reg, OP_PUSH);\n        if (r != 0) return r;\n        COP(reg)->push.addr = SIZE_INC_OP + mod_tlen + SIZE_OP_JUMP;\n\n        r = compile_tree_empty_check(NODE_QUANT_BODY(qn), reg, empty_info, env);\n        if (r != 0) return r;\n\n        addr = -(mod_tlen + (int )SIZE_OP_PUSH);\n      }\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = addr;\n    }\n    else {\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = mod_tlen + SIZE_INC_OP;\n\n      r = compile_tree_empty_check(NODE_QUANT_BODY(qn), reg, empty_info, env);\n      if (r != 0) return r;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = -mod_tlen;\n    }\n  }\n  else if (qn->upper == 0) {\n    if (qn->is_refered != 0) { /* /(?<n>..){0}/ */\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = tlen + SIZE_INC_OP;\n\n      r = compile_tree(NODE_QUANT_BODY(qn), reg, env);\n    }\n    else {\n      /* Nothing output */\n      r = 0;\n    }\n  }\n  else if (! infinite && qn->greedy &&\n           (qn->upper == 1 ||\n            int_multiply_cmp(tlen + SIZE_OP_PUSH, qn->upper,\n                             QUANTIFIER_EXPAND_LIMIT_SIZE) <= 0)) {\n    int n = qn->upper - qn->lower;\n\n    r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);\n    if (r != 0) return r;\n\n    for (i = 0; i < n; i++) {\n      int v = onig_positive_int_multiply(n - i, tlen + SIZE_OP_PUSH);\n      if (v < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = v;\n\n      r = compile_tree(NODE_QUANT_BODY(qn), reg, env);\n      if (r != 0) return r;\n    }\n  }\n  else if (! qn->greedy && qn->upper == 1 && qn->lower == 0) { /* '??' */\n    r = add_op(reg, OP_PUSH);\n    if (r != 0) return r;\n    COP(reg)->push.addr = SIZE_INC_OP + SIZE_OP_JUMP;\n\n    r = add_op(reg, OP_JUMP);\n    if (r != 0) return r;\n    COP(reg)->jump.addr = tlen + SIZE_INC_OP;\n\n    r = compile_tree(NODE_QUANT_BODY(qn), reg, env);\n  }\n  else {\n    r = compile_range_repeat_node(qn, mod_tlen, empty_info, reg, env);\n  }\n  return r;\n}\n\nstatic int\ncompile_length_option_node(BagNode* node, regex_t* reg)\n{\n  int tlen;\n  OnigOptionType prev = reg->options;\n\n  reg->options = node->o.options;\n  tlen = compile_length_tree(NODE_BAG_BODY(node), reg);\n  reg->options = prev;\n\n  return tlen;\n}\n\nstatic int\ncompile_option_node(BagNode* node, regex_t* reg, ScanEnv* env)\n{\n  int r;\n  OnigOptionType prev = reg->options;\n\n  reg->options = node->o.options;\n  r = compile_tree(NODE_BAG_BODY(node), reg, env);\n  reg->options = prev;\n\n  return r;\n}\n\nstatic int\ncompile_length_bag_node(BagNode* node, regex_t* reg)\n{\n  int len;\n  int tlen;\n\n  if (node->type == BAG_OPTION)\n    return compile_length_option_node(node, reg);\n\n  if (NODE_BAG_BODY(node)) {\n    tlen = compile_length_tree(NODE_BAG_BODY(node), reg);\n    if (tlen < 0) return tlen;\n  }\n  else\n    tlen = 0;\n\n  switch (node->type) {\n  case BAG_MEMORY:\n#ifdef USE_CALL\n\n    if (node->m.regnum == 0 && NODE_IS_CALLED(node)) {\n      len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;\n      return len;\n    }\n\n    if (NODE_IS_CALLED(node)) {\n      len = SIZE_OP_MEMORY_START_PUSH + tlen\n        + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;\n      if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))\n        len += (NODE_IS_RECURSION(node)\n                ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH);\n      else\n        len += (NODE_IS_RECURSION(node)\n                ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END);\n    }\n    else if (NODE_IS_RECURSION(node)) {\n      len = SIZE_OP_MEMORY_START_PUSH;\n      len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)\n                     ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC);\n    }\n    else\n#endif\n    {\n      if (MEM_STATUS_AT0(reg->bt_mem_start, node->m.regnum))\n        len = SIZE_OP_MEMORY_START_PUSH;\n      else\n        len = SIZE_OP_MEMORY_START;\n\n      len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)\n                     ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END);\n    }\n    break;\n\n  case BAG_STOP_BACKTRACK:\n    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {\n      int v;\n      QuantNode* qn;\n\n      qn = QUANT_(NODE_BAG_BODY(node));\n      tlen = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n      if (tlen < 0) return tlen;\n\n      v = onig_positive_int_multiply(qn->lower, tlen);\n      if (v < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n      len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP;\n    }\n    else {\n      len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END;\n    }\n    break;\n\n  case BAG_IF_ELSE:\n    {\n      Node* cond = NODE_BAG_BODY(node);\n      Node* Then = node->te.Then;\n      Node* Else = node->te.Else;\n\n      len = compile_length_tree(cond, reg);\n      if (len < 0) return len;\n      len += SIZE_OP_PUSH;\n      len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END;\n\n      if (IS_NOT_NULL(Then)) {\n        tlen = compile_length_tree(Then, reg);\n        if (tlen < 0) return tlen;\n        len += tlen;\n      }\n\n      len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END;\n\n      if (IS_NOT_NULL(Else)) {\n        tlen = compile_length_tree(Else, reg);\n        if (tlen < 0) return tlen;\n        len += tlen;\n      }\n    }\n    break;\n\n  case BAG_OPTION:\n    /* never come here, but set for escape warning */\n    len = 0;\n    break;\n  }\n\n  return len;\n}\n\nstatic int get_char_len_node(Node* node, regex_t* reg, int* len);\n\nstatic int\ncompile_bag_memory_node(BagNode* node, regex_t* reg, ScanEnv* env)\n{\n  int r;\n  int len;\n\n#ifdef USE_CALL\n  if (NODE_IS_CALLED(node)) {\n    r = add_op(reg, OP_CALL);\n    if (r != 0) return r;\n\n    node->m.called_addr = COP_CURR_OFFSET(reg) + 1 + SIZE_OP_JUMP;\n    NODE_STATUS_ADD(node, ADDR_FIXED);\n    COP(reg)->call.addr = (int )node->m.called_addr;\n\n    if (node->m.regnum == 0) {\n      len = compile_length_tree(NODE_BAG_BODY(node), reg);\n      len += SIZE_OP_RETURN;\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = len + SIZE_INC_OP;\n\n      r = compile_tree(NODE_BAG_BODY(node), reg, env);\n      if (r != 0) return r;\n\n      r = add_op(reg, OP_RETURN);\n      return r;\n    }\n    else {\n      len = compile_length_tree(NODE_BAG_BODY(node), reg);\n      len += (SIZE_OP_MEMORY_START_PUSH + SIZE_OP_RETURN);\n      if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))\n        len += (NODE_IS_RECURSION(node)\n                ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH);\n      else\n        len += (NODE_IS_RECURSION(node)\n                ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END);\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = len + SIZE_INC_OP;\n    }\n  }\n#endif\n\n  if (MEM_STATUS_AT0(reg->bt_mem_start, node->m.regnum))\n    r = add_op(reg, OP_MEMORY_START_PUSH);\n  else\n    r = add_op(reg, OP_MEMORY_START);\n  if (r != 0) return r;\n  COP(reg)->memory_start.num = node->m.regnum;\n\n  r = compile_tree(NODE_BAG_BODY(node), reg, env);\n  if (r != 0) return r;\n\n#ifdef USE_CALL\n  if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))\n    r = add_op(reg, (NODE_IS_RECURSION(node)\n                     ? OP_MEMORY_END_PUSH_REC : OP_MEMORY_END_PUSH));\n  else\n    r = add_op(reg, (NODE_IS_RECURSION(node) ? OP_MEMORY_END_REC : OP_MEMORY_END));\n  if (r != 0) return r;\n  COP(reg)->memory_end.num = node->m.regnum;\n\n  if (NODE_IS_CALLED(node)) {\n    if (r != 0) return r;\n    r = add_op(reg, OP_RETURN);\n  }\n#else\n  if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))\n    r = add_op(reg, OP_MEMORY_END_PUSH);\n  else\n    r = add_op(reg, OP_MEMORY_END);\n  if (r != 0) return r;\n  COP(reg)->memory_end.num = node->m.regnum;\n#endif\n\n  return r;\n}\n\nstatic int\ncompile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n{\n  int r, len;\n\n  switch (node->type) {\n  case BAG_MEMORY:\n    r = compile_bag_memory_node(node, reg, env);\n    break;\n\n  case BAG_OPTION:\n    r = compile_option_node(node, reg, env);\n    break;\n\n  case BAG_STOP_BACKTRACK:\n    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {\n      QuantNode* qn = QUANT_(NODE_BAG_BODY(node));\n      r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);\n      if (r != 0) return r;\n\n      len = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n      if (len < 0) return len;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;\n\n      r = compile_tree(NODE_QUANT_BODY(qn), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_POP_OUT);\n      if (r != 0) return r;\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);\n    }\n    else {\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n      r = compile_tree(NODE_BAG_BODY(node), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n    }\n    break;\n\n  case BAG_IF_ELSE:\n    {\n      int cond_len, then_len, else_len, jump_len;\n      Node* cond = NODE_BAG_BODY(node);\n      Node* Then = node->te.Then;\n      Node* Else = node->te.Else;\n\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n\n      cond_len = compile_length_tree(cond, reg);\n      if (cond_len < 0) return cond_len;\n      if (IS_NOT_NULL(Then)) {\n        then_len = compile_length_tree(Then, reg);\n        if (then_len < 0) return then_len;\n      }\n      else\n        then_len = 0;\n\n      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + jump_len;\n\n      r = compile_tree(cond, reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n      if (r != 0) return r;\n\n      if (IS_NOT_NULL(Then)) {\n        r = compile_tree(Then, reg, env);\n        if (r != 0) return r;\n      }\n\n      if (IS_NOT_NULL(Else)) {\n        else_len = compile_length_tree(Else, reg);\n        if (else_len < 0) return else_len;\n      }\n      else\n        else_len = 0;\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;\n\n      r = add_op(reg, OP_ATOMIC_END);\n      if (r != 0) return r;\n\n      if (IS_NOT_NULL(Else)) {\n        r = compile_tree(Else, reg, env);\n      }\n    }\n    break;\n  }\n\n  return r;\n}\n\nstatic int\ncompile_length_anchor_node(AnchorNode* node, regex_t* reg)\n{\n  int len;\n  int tlen = 0;\n\n  if (IS_NOT_NULL(NODE_ANCHOR_BODY(node))) {\n    tlen = compile_length_tree(NODE_ANCHOR_BODY(node), reg);\n    if (tlen < 0) return tlen;\n  }\n\n  switch (node->type) {\n  case ANCR_PREC_READ:\n    len = SIZE_OP_PREC_READ_START + tlen + SIZE_OP_PREC_READ_END;\n    break;\n  case ANCR_PREC_READ_NOT:\n    len = SIZE_OP_PREC_READ_NOT_START + tlen + SIZE_OP_PREC_READ_NOT_END;\n    break;\n  case ANCR_LOOK_BEHIND:\n    len = SIZE_OP_LOOK_BEHIND + tlen;\n    break;\n  case ANCR_LOOK_BEHIND_NOT:\n    len = SIZE_OP_LOOK_BEHIND_NOT_START + tlen + SIZE_OP_LOOK_BEHIND_NOT_END;\n    break;\n\n  case ANCR_WORD_BOUNDARY:\n  case ANCR_NO_WORD_BOUNDARY:\n#ifdef USE_WORD_BEGIN_END\n  case ANCR_WORD_BEGIN:\n  case ANCR_WORD_END:\n#endif\n    len = SIZE_OP_WORD_BOUNDARY;\n    break;\n\n  case ANCR_TEXT_SEGMENT_BOUNDARY:\n  case ANCR_NO_TEXT_SEGMENT_BOUNDARY:\n    len = SIZE_OPCODE;\n    break;\n\n  default:\n    len = SIZE_OPCODE;\n    break;\n  }\n\n  return len;\n}\n\nstatic int\ncompile_anchor_node(AnchorNode* node, regex_t* reg, ScanEnv* env)\n{\n  int r, len;\n  enum OpCode op;\n\n  switch (node->type) {\n  case ANCR_BEGIN_BUF:      r = add_op(reg, OP_BEGIN_BUF);      break;\n  case ANCR_END_BUF:        r = add_op(reg, OP_END_BUF);        break;\n  case ANCR_BEGIN_LINE:     r = add_op(reg, OP_BEGIN_LINE);     break;\n  case ANCR_END_LINE:       r = add_op(reg, OP_END_LINE);       break;\n  case ANCR_SEMI_END_BUF:   r = add_op(reg, OP_SEMI_END_BUF);   break;\n  case ANCR_BEGIN_POSITION: r = add_op(reg, OP_BEGIN_POSITION); break;\n\n  case ANCR_WORD_BOUNDARY:\n    op = OP_WORD_BOUNDARY;\n  word:\n    r = add_op(reg, op);\n    if (r != 0) return r;\n    COP(reg)->word_boundary.mode = (ModeType )node->ascii_mode;\n    break;\n\n  case ANCR_NO_WORD_BOUNDARY:\n    op = OP_NO_WORD_BOUNDARY; goto word;\n    break;\n#ifdef USE_WORD_BEGIN_END\n  case ANCR_WORD_BEGIN:\n    op = OP_WORD_BEGIN; goto word;\n    break;\n  case ANCR_WORD_END:\n    op = OP_WORD_END; goto word;\n    break;\n#endif\n\n  case ANCR_TEXT_SEGMENT_BOUNDARY:\n  case ANCR_NO_TEXT_SEGMENT_BOUNDARY:\n    {\n      enum TextSegmentBoundaryType type;\n\n      r = add_op(reg, OP_TEXT_SEGMENT_BOUNDARY);\n      if (r != 0) return r;\n\n      type = EXTENDED_GRAPHEME_CLUSTER_BOUNDARY;\n#ifdef USE_UNICODE_WORD_BREAK\n      if (ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_TEXT_SEGMENT_WORD))\n        type = WORD_BOUNDARY;\n#endif\n\n      COP(reg)->text_segment_boundary.type = type;\n      COP(reg)->text_segment_boundary.not =\n        (node->type == ANCR_NO_TEXT_SEGMENT_BOUNDARY ? 1 : 0);\n    }\n    break;\n\n  case ANCR_PREC_READ:\n    r = add_op(reg, OP_PREC_READ_START);\n    if (r != 0) return r;\n    r = compile_tree(NODE_ANCHOR_BODY(node), reg, env);\n    if (r != 0) return r;\n    r = add_op(reg, OP_PREC_READ_END);\n    break;\n\n  case ANCR_PREC_READ_NOT:\n    len = compile_length_tree(NODE_ANCHOR_BODY(node), reg);\n    if (len < 0) return len;\n\n    r = add_op(reg, OP_PREC_READ_NOT_START);\n    if (r != 0) return r;\n    COP(reg)->prec_read_not_start.addr = SIZE_INC_OP + len + SIZE_OP_PREC_READ_NOT_END;\n    r = compile_tree(NODE_ANCHOR_BODY(node), reg, env);\n    if (r != 0) return r;\n    r = add_op(reg, OP_PREC_READ_NOT_END);\n    break;\n\n  case ANCR_LOOK_BEHIND:\n    {\n      int n;\n      r = add_op(reg, OP_LOOK_BEHIND);\n      if (r != 0) return r;\n      if (node->char_len < 0) {\n        r = get_char_len_node(NODE_ANCHOR_BODY(node), reg, &n);\n        if (r != 0) return ONIGERR_INVALID_LOOK_BEHIND_PATTERN;\n      }\n      else\n        n = node->char_len;\n\n      COP(reg)->look_behind.len = n;\n      r = compile_tree(NODE_ANCHOR_BODY(node), reg, env);\n    }\n    break;\n\n  case ANCR_LOOK_BEHIND_NOT:\n    {\n      int n;\n\n      len = compile_length_tree(NODE_ANCHOR_BODY(node), reg);\n      r = add_op(reg, OP_LOOK_BEHIND_NOT_START);\n      if (r != 0) return r;\n      COP(reg)->look_behind_not_start.addr = SIZE_INC_OP + len + SIZE_OP_LOOK_BEHIND_NOT_END;\n\n      if (node->char_len < 0) {\n        r = get_char_len_node(NODE_ANCHOR_BODY(node), reg, &n);\n        if (r != 0) return ONIGERR_INVALID_LOOK_BEHIND_PATTERN;\n      }\n      else\n        n = node->char_len;\n\n      COP(reg)->look_behind_not_start.len = n;\n\n      r = compile_tree(NODE_ANCHOR_BODY(node), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_LOOK_BEHIND_NOT_END);\n    }\n    break;\n\n  default:\n    return ONIGERR_TYPE_BUG;\n    break;\n  }\n\n  return r;\n}\n\nstatic int\ncompile_gimmick_node(GimmickNode* node, regex_t* reg)\n{\n  int r;\n\n  switch (node->type) {\n  case GIMMICK_FAIL:\n    r = add_op(reg, OP_FAIL);\n    break;\n\n  case GIMMICK_SAVE:\n    r = add_op(reg, OP_PUSH_SAVE_VAL);\n    if (r != 0) return r;\n    COP(reg)->push_save_val.type = node->detail_type;\n    COP(reg)->push_save_val.id   = node->id;\n    break;\n\n  case GIMMICK_UPDATE_VAR:\n    r = add_op(reg, OP_UPDATE_VAR);\n    if (r != 0) return r;\n    COP(reg)->update_var.type = node->detail_type;\n    COP(reg)->update_var.id   = node->id;\n    break;\n\n#ifdef USE_CALLOUT\n  case GIMMICK_CALLOUT:\n    switch (node->detail_type) {\n    case ONIG_CALLOUT_OF_CONTENTS:\n    case ONIG_CALLOUT_OF_NAME:\n      {\n        if (node->detail_type == ONIG_CALLOUT_OF_NAME) {\n          r = add_op(reg, OP_CALLOUT_NAME);\n          if (r != 0) return r;\n          COP(reg)->callout_name.id  = node->id;\n          COP(reg)->callout_name.num = node->num;\n        }\n        else {\n          r = add_op(reg, OP_CALLOUT_CONTENTS);\n          if (r != 0) return r;\n          COP(reg)->callout_contents.num = node->num;\n        }\n      }\n      break;\n\n    default:\n      r = ONIGERR_TYPE_BUG;\n      break;\n    }\n#endif\n  }\n\n  return r;\n}\n\nstatic int\ncompile_length_gimmick_node(GimmickNode* node, regex_t* reg)\n{\n  int len;\n\n  switch (node->type) {\n  case GIMMICK_FAIL:\n    len = SIZE_OP_FAIL;\n    break;\n\n  case GIMMICK_SAVE:\n    len = SIZE_OP_PUSH_SAVE_VAL;\n    break;\n\n  case GIMMICK_UPDATE_VAR:\n    len = SIZE_OP_UPDATE_VAR;\n    break;\n\n#ifdef USE_CALLOUT\n  case GIMMICK_CALLOUT:\n    switch (node->detail_type) {\n    case ONIG_CALLOUT_OF_CONTENTS:\n      len = SIZE_OP_CALLOUT_CONTENTS;\n      break;\n    case ONIG_CALLOUT_OF_NAME:\n      len = SIZE_OP_CALLOUT_NAME;\n      break;\n\n    default:\n      len = ONIGERR_TYPE_BUG;\n      break;\n    }\n    break;\n#endif\n  }\n\n  return len;\n}\n\nstatic int\ncompile_length_tree(Node* node, regex_t* reg)\n{\n  int len, r;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n    len = 0;\n    do {\n      r = compile_length_tree(NODE_CAR(node), reg);\n      if (r < 0) return r;\n      len += r;\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    r = len;\n    break;\n\n  case NODE_ALT:\n    {\n      int n;\n\n      n = r = 0;\n      do {\n        r += compile_length_tree(NODE_CAR(node), reg);\n        n++;\n      } while (IS_NOT_NULL(node = NODE_CDR(node)));\n      r += (SIZE_OP_PUSH + SIZE_OP_JUMP) * (n - 1);\n    }\n    break;\n\n  case NODE_STRING:\n    if (NODE_STRING_IS_RAW(node))\n      r = compile_length_string_raw_node(STR_(node), reg);\n    else\n      r = compile_length_string_node(node, reg);\n    break;\n\n  case NODE_CCLASS:\n    r = compile_length_cclass_node(CCLASS_(node), reg);\n    break;\n\n  case NODE_CTYPE:\n    r = SIZE_OPCODE;\n    break;\n\n  case NODE_BACKREF:\n    r = SIZE_OP_BACKREF;\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    r = SIZE_OP_CALL;\n    break;\n#endif\n\n  case NODE_QUANT:\n    r = compile_length_quantifier_node(QUANT_(node), reg);\n    break;\n\n  case NODE_BAG:\n    r = compile_length_bag_node(BAG_(node), reg);\n    break;\n\n  case NODE_ANCHOR:\n    r = compile_length_anchor_node(ANCHOR_(node), reg);\n    break;\n\n  case NODE_GIMMICK:\n    r = compile_length_gimmick_node(GIMMICK_(node), reg);\n    break;\n\n  default:\n    return ONIGERR_TYPE_BUG;\n    break;\n  }\n\n  return r;\n}\n\nstatic int\ncompile_tree(Node* node, regex_t* reg, ScanEnv* env)\n{\n  int n, len, pos, r = 0;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n    do {\n      r = compile_tree(NODE_CAR(node), reg, env);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_ALT:\n    {\n      Node* x = node;\n      len = 0;\n      do {\n        len += compile_length_tree(NODE_CAR(x), reg);\n        if (IS_NOT_NULL(NODE_CDR(x))) {\n          len += SIZE_OP_PUSH + SIZE_OP_JUMP;\n        }\n      } while (IS_NOT_NULL(x = NODE_CDR(x)));\n      pos = COP_CURR_OFFSET(reg) + 1 + len;  /* goal position */\n\n      do {\n        len = compile_length_tree(NODE_CAR(node), reg);\n        if (IS_NOT_NULL(NODE_CDR(node))) {\n          enum OpCode push = NODE_IS_SUPER(node) ? OP_PUSH_SUPER : OP_PUSH;\n          r = add_op(reg, push);\n          if (r != 0) break;\n          COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_JUMP;\n        }\n        r = compile_tree(NODE_CAR(node), reg, env);\n        if (r != 0) break;\n        if (IS_NOT_NULL(NODE_CDR(node))) {\n          len = pos - (COP_CURR_OFFSET(reg) + 1);\n          r = add_op(reg, OP_JUMP);\n          if (r != 0) break;\n          COP(reg)->jump.addr = len;\n        }\n      } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    }\n    break;\n\n  case NODE_STRING:\n    if (NODE_STRING_IS_RAW(node))\n      r = compile_string_raw_node(STR_(node), reg);\n    else\n      r = compile_string_node(node, reg);\n    break;\n\n  case NODE_CCLASS:\n    r = compile_cclass_node(CCLASS_(node), reg);\n    break;\n\n  case NODE_CTYPE:\n    {\n      int op;\n\n      switch (CTYPE_(node)->ctype) {\n      case CTYPE_ANYCHAR:\n        r = add_op(reg, IS_MULTILINE(CTYPE_OPTION(node, reg)) ?\n                   OP_ANYCHAR_ML : OP_ANYCHAR);\n        break;\n\n      case ONIGENC_CTYPE_WORD:\n        if (CTYPE_(node)->ascii_mode == 0) {\n          op = CTYPE_(node)->not != 0 ? OP_NO_WORD : OP_WORD;\n        }\n        else {\n          op = CTYPE_(node)->not != 0 ? OP_NO_WORD_ASCII : OP_WORD_ASCII;\n        }\n        r = add_op(reg, op);\n        break;\n\n      default:\n        return ONIGERR_TYPE_BUG;\n        break;\n      }\n    }\n    break;\n\n  case NODE_BACKREF:\n    {\n      BackRefNode* br = BACKREF_(node);\n\n      if (NODE_IS_CHECKER(node)) {\n#ifdef USE_BACKREF_WITH_LEVEL\n        if (NODE_IS_NEST_LEVEL(node)) {\n          r = add_op(reg, OP_BACKREF_CHECK_WITH_LEVEL);\n          if (r != 0) return r;\n          COP(reg)->backref_general.nest_level = br->nest_level;\n        }\n        else\n#endif\n          {\n            r = add_op(reg, OP_BACKREF_CHECK);\n            if (r != 0) return r;\n          }\n        goto add_bacref_mems;\n      }\n      else {\n#ifdef USE_BACKREF_WITH_LEVEL\n        if (NODE_IS_NEST_LEVEL(node)) {\n          if ((reg->options & ONIG_OPTION_IGNORECASE) != 0)\n            r = add_op(reg, OP_BACKREF_WITH_LEVEL_IC);\n          else\n            r = add_op(reg, OP_BACKREF_WITH_LEVEL);\n\n          if (r != 0) return r;\n          COP(reg)->backref_general.nest_level = br->nest_level;\n          goto add_bacref_mems;\n        }\n        else\n#endif\n        if (br->back_num == 1) {\n          n = br->back_static[0];\n          if (IS_IGNORECASE(reg->options)) {\n            r = add_op(reg, OP_BACKREF_N_IC);\n            if (r != 0) return r;\n            COP(reg)->backref_n.n1 = n;\n          }\n          else {\n            switch (n) {\n            case 1:  r = add_op(reg, OP_BACKREF1); break;\n            case 2:  r = add_op(reg, OP_BACKREF2); break;\n            default:\n              r = add_op(reg, OP_BACKREF_N);\n              if (r != 0) return r;\n              COP(reg)->backref_n.n1 = n;\n              break;\n            }\n          }\n        }\n        else {\n          int num;\n          int* p;\n\n          r = add_op(reg, IS_IGNORECASE(reg->options) ?\n                     OP_BACKREF_MULTI_IC : OP_BACKREF_MULTI);\n          if (r != 0) return r;\n\n        add_bacref_mems:\n          num = br->back_num;\n          COP(reg)->backref_general.num = num;\n          if (num == 1) {\n            COP(reg)->backref_general.n1 = br->back_static[0];\n          }\n          else {\n            int i, j;\n            MemNumType* ns;\n\n            ns = xmalloc(sizeof(MemNumType) * num);\n            CHECK_NULL_RETURN_MEMERR(ns);\n            COP(reg)->backref_general.ns = ns;\n            p = BACKREFS_P(br);\n            for (i = num - 1, j = 0; i >= 0; i--, j++) {\n              ns[j] = p[i];\n            }\n          }\n        }\n      }\n    }\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    r = compile_call(CALL_(node), reg, env);\n    break;\n#endif\n\n  case NODE_QUANT:\n    r = compile_quantifier_node(QUANT_(node), reg, env);\n    break;\n\n  case NODE_BAG:\n    r = compile_bag_node(BAG_(node), reg, env);\n    break;\n\n  case NODE_ANCHOR:\n    r = compile_anchor_node(ANCHOR_(node), reg, env);\n    break;\n\n  case NODE_GIMMICK:\n    r = compile_gimmick_node(GIMMICK_(node), reg);\n    break;\n\n  default:\n#ifdef ONIG_DEBUG\n    fprintf(stderr, \"compile_tree: undefined node type %d\\n\", NODE_TYPE(node));\n#endif\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nnoname_disable_map(Node** plink, GroupNumRemap* map, int* counter)\n{\n  int r = 0;\n  Node* node = *plink;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    do {\n      r = noname_disable_map(&(NODE_CAR(node)), map, counter);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_QUANT:\n    {\n      Node** ptarget = &(NODE_BODY(node));\n      Node*  old = *ptarget;\n      r = noname_disable_map(ptarget, map, counter);\n      if (*ptarget != old && NODE_TYPE(*ptarget) == NODE_QUANT) {\n        onig_reduce_nested_quantifier(node, *ptarget);\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n      if (en->type == BAG_MEMORY) {\n        if (NODE_IS_NAMED_GROUP(node)) {\n          (*counter)++;\n          map[en->m.regnum].new_val = *counter;\n          en->m.regnum = *counter;\n          r = noname_disable_map(&(NODE_BODY(node)), map, counter);\n        }\n        else {\n          *plink = NODE_BODY(node);\n          NODE_BODY(node) = NULL_NODE;\n          onig_node_free(node);\n          r = noname_disable_map(plink, map, counter);\n        }\n      }\n      else if (en->type == BAG_IF_ELSE) {\n        r = noname_disable_map(&(NODE_BAG_BODY(en)), map, counter);\n        if (r != 0) return r;\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = noname_disable_map(&(en->te.Then), map, counter);\n          if (r != 0) return r;\n        }\n        if (IS_NOT_NULL(en->te.Else)) {\n          r = noname_disable_map(&(en->te.Else), map, counter);\n          if (r != 0) return r;\n        }\n      }\n      else\n        r = noname_disable_map(&(NODE_BODY(node)), map, counter);\n    }\n    break;\n\n  case NODE_ANCHOR:\n    if (IS_NOT_NULL(NODE_BODY(node)))\n      r = noname_disable_map(&(NODE_BODY(node)), map, counter);\n    break;\n\n  default:\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nrenumber_node_backref(Node* node, GroupNumRemap* map)\n{\n  int i, pos, n, old_num;\n  int *backs;\n  BackRefNode* bn = BACKREF_(node);\n\n  if (! NODE_IS_BY_NAME(node))\n    return ONIGERR_NUMBERED_BACKREF_OR_CALL_NOT_ALLOWED;\n\n  old_num = bn->back_num;\n  if (IS_NULL(bn->back_dynamic))\n    backs = bn->back_static;\n  else\n    backs = bn->back_dynamic;\n\n  for (i = 0, pos = 0; i < old_num; i++) {\n    n = map[backs[i]].new_val;\n    if (n > 0) {\n      backs[pos] = n;\n      pos++;\n    }\n  }\n\n  bn->back_num = pos;\n  return 0;\n}\n\nstatic int\nrenumber_by_map(Node* node, GroupNumRemap* map)\n{\n  int r = 0;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    do {\n      r = renumber_by_map(NODE_CAR(node), map);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_QUANT:\n    r = renumber_by_map(NODE_BODY(node), map);\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      r = renumber_by_map(NODE_BODY(node), map);\n      if (r != 0) return r;\n\n      if (en->type == BAG_IF_ELSE) {\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = renumber_by_map(en->te.Then, map);\n          if (r != 0) return r;\n        }\n        if (IS_NOT_NULL(en->te.Else)) {\n          r = renumber_by_map(en->te.Else, map);\n          if (r != 0) return r;\n        }\n      }\n    }\n    break;\n\n  case NODE_BACKREF:\n    r = renumber_node_backref(node, map);\n    break;\n\n  case NODE_ANCHOR:\n    if (IS_NOT_NULL(NODE_BODY(node)))\n      r = renumber_by_map(NODE_BODY(node), map);\n    break;\n\n  default:\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nnumbered_ref_check(Node* node)\n{\n  int r = 0;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    do {\n      r = numbered_ref_check(NODE_CAR(node));\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_ANCHOR:\n    if (IS_NULL(NODE_BODY(node)))\n      break;\n    /* fall */\n  case NODE_QUANT:\n    r = numbered_ref_check(NODE_BODY(node));\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      r = numbered_ref_check(NODE_BODY(node));\n      if (r != 0) return r;\n\n      if (en->type == BAG_IF_ELSE) {\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = numbered_ref_check(en->te.Then);\n          if (r != 0) return r;\n        }\n        if (IS_NOT_NULL(en->te.Else)) {\n          r = numbered_ref_check(en->te.Else);\n          if (r != 0) return r;\n        }\n      }\n    }\n\n    break;\n\n  case NODE_BACKREF:\n    if (! NODE_IS_BY_NAME(node))\n      return ONIGERR_NUMBERED_BACKREF_OR_CALL_NOT_ALLOWED;\n    break;\n\n  default:\n    break;\n  }\n\n  return r;\n}\n\nstatic int\ndisable_noname_group_capture(Node** root, regex_t* reg, ScanEnv* env)\n{\n  int r, i, pos, counter;\n  MemStatusType loc;\n  GroupNumRemap* map;\n\n  map = (GroupNumRemap* )xalloca(sizeof(GroupNumRemap) * (env->num_mem + 1));\n  CHECK_NULL_RETURN_MEMERR(map);\n  for (i = 1; i <= env->num_mem; i++) {\n    map[i].new_val = 0;\n  }\n  counter = 0;\n  r = noname_disable_map(root, map, &counter);\n  if (r != 0) return r;\n\n  r = renumber_by_map(*root, map);\n  if (r != 0) return r;\n\n  for (i = 1, pos = 1; i <= env->num_mem; i++) {\n    if (map[i].new_val > 0) {\n      SCANENV_MEMENV(env)[pos] = SCANENV_MEMENV(env)[i];\n      pos++;\n    }\n  }\n\n  loc = env->capture_history;\n  MEM_STATUS_CLEAR(env->capture_history);\n  for (i = 1; i <= ONIG_MAX_CAPTURE_HISTORY_GROUP; i++) {\n    if (MEM_STATUS_AT(loc, i)) {\n      MEM_STATUS_ON_SIMPLE(env->capture_history, map[i].new_val);\n    }\n  }\n\n  env->num_mem = env->num_named;\n  reg->num_mem = env->num_named;\n\n  return onig_renumber_name_table(reg, map);\n}\n\n#ifdef USE_CALL\nstatic int\nfix_unset_addr_list(UnsetAddrList* uslist, regex_t* reg)\n{\n  int i, offset;\n  BagNode* en;\n  AbsAddrType addr;\n  AbsAddrType* paddr;\n\n  for (i = 0; i < uslist->num; i++) {\n    if (! NODE_IS_ADDR_FIXED(uslist->us[i].target))\n      return ONIGERR_PARSER_BUG;\n\n    en = BAG_(uslist->us[i].target);\n    addr   = en->m.called_addr;\n    offset = uslist->us[i].offset;\n\n    paddr = (AbsAddrType* )((char* )reg->ops + offset);\n    *paddr = addr;\n  }\n  return 0;\n}\n#endif\n\n\n#define GET_CHAR_LEN_VARLEN           -1\n#define GET_CHAR_LEN_TOP_ALT_VARLEN   -2\n\n/* fixed size pattern node only */\nstatic int\nget_char_len_node1(Node* node, regex_t* reg, int* len, int level)\n{\n  int tlen;\n  int r = 0;\n\n  level++;\n  *len = 0;\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n    do {\n      r = get_char_len_node1(NODE_CAR(node), reg, &tlen, level);\n      if (r == 0)\n        *len = distance_add(*len, tlen);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_ALT:\n    {\n      int tlen2;\n      int varlen = 0;\n\n      r = get_char_len_node1(NODE_CAR(node), reg, &tlen, level);\n      while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node))) {\n        r = get_char_len_node1(NODE_CAR(node), reg, &tlen2, level);\n        if (r == 0) {\n          if (tlen != tlen2)\n            varlen = 1;\n        }\n      }\n      if (r == 0) {\n        if (varlen != 0) {\n          if (level == 1)\n            r = GET_CHAR_LEN_TOP_ALT_VARLEN;\n          else\n            r = GET_CHAR_LEN_VARLEN;\n        }\n        else\n          *len = tlen;\n      }\n    }\n    break;\n\n  case NODE_STRING:\n    {\n      StrNode* sn = STR_(node);\n      UChar *s = sn->s;\n\n      while (s < sn->end) {\n        s += enclen(reg->enc, s);\n        (*len)++;\n      }\n    }\n    break;\n\n  case NODE_QUANT:\n    {\n      QuantNode* qn = QUANT_(node);\n\n      if (qn->lower == qn->upper) {\n        if (qn->upper == 0) {\n          *len = 0;\n        }\n        else {\n          r = get_char_len_node1(NODE_BODY(node), reg, &tlen, level);\n          if (r == 0)\n            *len = distance_multiply(tlen, qn->lower);\n        }\n      }\n      else\n        r = GET_CHAR_LEN_VARLEN;\n    }\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    if (! NODE_IS_RECURSION(node))\n      r = get_char_len_node1(NODE_BODY(node), reg, len, level);\n    else\n      r = GET_CHAR_LEN_VARLEN;\n    break;\n#endif\n\n  case NODE_CTYPE:\n  case NODE_CCLASS:\n    *len = 1;\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      switch (en->type) {\n      case BAG_MEMORY:\n#ifdef USE_CALL\n        if (NODE_IS_CLEN_FIXED(node))\n          *len = en->char_len;\n        else {\n          r = get_char_len_node1(NODE_BODY(node), reg, len, level);\n          if (r == 0) {\n            en->char_len = *len;\n            NODE_STATUS_ADD(node, CLEN_FIXED);\n          }\n        }\n        break;\n#endif\n      case BAG_OPTION:\n      case BAG_STOP_BACKTRACK:\n        r = get_char_len_node1(NODE_BODY(node), reg, len, level);\n        break;\n      case BAG_IF_ELSE:\n        {\n          int clen, elen;\n\n          r = get_char_len_node1(NODE_BODY(node), reg, &clen, level);\n          if (r == 0) {\n            if (IS_NOT_NULL(en->te.Then)) {\n              r = get_char_len_node1(en->te.Then, reg, &tlen, level);\n              if (r != 0) break;\n            }\n            else tlen = 0;\n            if (IS_NOT_NULL(en->te.Else)) {\n              r = get_char_len_node1(en->te.Else, reg, &elen, level);\n              if (r != 0) break;\n            }\n            else elen = 0;\n\n            if (clen + tlen != elen) {\n              r = GET_CHAR_LEN_VARLEN;\n            }\n            else {\n              *len = elen;\n            }\n          }\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_ANCHOR:\n  case NODE_GIMMICK:\n    break;\n\n  case NODE_BACKREF:\n    if (NODE_IS_CHECKER(node))\n      break;\n    /* fall */\n  default:\n    r = GET_CHAR_LEN_VARLEN;\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nget_char_len_node(Node* node, regex_t* reg, int* len)\n{\n  return get_char_len_node1(node, reg, len, 0);\n}\n\n/* x is not included y ==>  1 : 0 */\nstatic int\nis_exclusive(Node* x, Node* y, regex_t* reg)\n{\n  int i, len;\n  OnigCodePoint code;\n  UChar *p;\n  NodeType ytype;\n\n retry:\n  ytype = NODE_TYPE(y);\n  switch (NODE_TYPE(x)) {\n  case NODE_CTYPE:\n    {\n      if (CTYPE_(x)->ctype == CTYPE_ANYCHAR ||\n          CTYPE_(y)->ctype == CTYPE_ANYCHAR)\n        break;\n\n      switch (ytype) {\n      case NODE_CTYPE:\n        if (CTYPE_(y)->ctype == CTYPE_(x)->ctype &&\n            CTYPE_(y)->not   != CTYPE_(x)->not &&\n            CTYPE_(y)->ascii_mode == CTYPE_(x)->ascii_mode)\n          return 1;\n        else\n          return 0;\n        break;\n\n      case NODE_CCLASS:\n      swap:\n        {\n          Node* tmp;\n          tmp = x; x = y; y = tmp;\n          goto retry;\n        }\n        break;\n\n      case NODE_STRING:\n        goto swap;\n        break;\n\n      default:\n        break;\n      }\n    }\n    break;\n\n  case NODE_CCLASS:\n    {\n      int range;\n      CClassNode* xc = CCLASS_(x);\n\n      switch (ytype) {\n      case NODE_CTYPE:\n        switch (CTYPE_(y)->ctype) {\n        case CTYPE_ANYCHAR:\n          return 0;\n          break;\n\n        case ONIGENC_CTYPE_WORD:\n          if (CTYPE_(y)->not == 0) {\n            if (IS_NULL(xc->mbuf) && !IS_NCCLASS_NOT(xc)) {\n              range = CTYPE_(y)->ascii_mode != 0 ? 128 : SINGLE_BYTE_SIZE;\n              for (i = 0; i < range; i++) {\n                if (BITSET_AT(xc->bs, i)) {\n                  if (ONIGENC_IS_CODE_WORD(reg->enc, i)) return 0;\n                }\n              }\n              return 1;\n            }\n            return 0;\n          }\n          else {\n            if (IS_NOT_NULL(xc->mbuf)) return 0;\n            if (IS_NCCLASS_NOT(xc)) return 0;\n\n            range = CTYPE_(y)->ascii_mode != 0 ? 128 : SINGLE_BYTE_SIZE;\n            for (i = 0; i < range; i++) {\n              if (! ONIGENC_IS_CODE_WORD(reg->enc, i)) {\n                if (BITSET_AT(xc->bs, i))\n                  return 0;\n              }\n            }\n            for (i = range; i < SINGLE_BYTE_SIZE; i++) {\n              if (BITSET_AT(xc->bs, i)) return 0;\n            }\n            return 1;\n          }\n          break;\n\n        default:\n          break;\n        }\n        break;\n\n      case NODE_CCLASS:\n        {\n          int v;\n          CClassNode* yc = CCLASS_(y);\n\n          for (i = 0; i < SINGLE_BYTE_SIZE; i++) {\n            v = BITSET_AT(xc->bs, i);\n            if ((v != 0 && !IS_NCCLASS_NOT(xc)) || (v == 0 && IS_NCCLASS_NOT(xc))) {\n              v = BITSET_AT(yc->bs, i);\n              if ((v != 0 && !IS_NCCLASS_NOT(yc)) ||\n                  (v == 0 && IS_NCCLASS_NOT(yc)))\n                return 0;\n            }\n          }\n          if ((IS_NULL(xc->mbuf) && !IS_NCCLASS_NOT(xc)) ||\n              (IS_NULL(yc->mbuf) && !IS_NCCLASS_NOT(yc)))\n            return 1;\n          return 0;\n        }\n        break;\n\n      case NODE_STRING:\n        goto swap;\n        break;\n\n      default:\n        break;\n      }\n    }\n    break;\n\n  case NODE_STRING:\n    {\n      StrNode* xs = STR_(x);\n\n      if (NODE_STRING_LEN(x) == 0)\n        break;\n\n      switch (ytype) {\n      case NODE_CTYPE:\n        switch (CTYPE_(y)->ctype) {\n        case CTYPE_ANYCHAR:\n          break;\n\n        case ONIGENC_CTYPE_WORD:\n          if (CTYPE_(y)->ascii_mode == 0) {\n            if (ONIGENC_IS_MBC_WORD(reg->enc, xs->s, xs->end))\n              return CTYPE_(y)->not;\n            else\n              return !(CTYPE_(y)->not);\n          }\n          else {\n            if (ONIGENC_IS_MBC_WORD_ASCII(reg->enc, xs->s, xs->end))\n              return CTYPE_(y)->not;\n            else\n              return !(CTYPE_(y)->not);\n          }\n          break;\n        default:\n          break;\n        }\n        break;\n\n      case NODE_CCLASS:\n        {\n          CClassNode* cc = CCLASS_(y);\n\n          code = ONIGENC_MBC_TO_CODE(reg->enc, xs->s,\n                                     xs->s + ONIGENC_MBC_MAXLEN(reg->enc));\n          return onig_is_code_in_cc(reg->enc, code, cc) == 0;\n        }\n        break;\n\n      case NODE_STRING:\n        {\n          UChar *q;\n          StrNode* ys = STR_(y);\n\n          len = NODE_STRING_LEN(x);\n          if (len > NODE_STRING_LEN(y)) len = NODE_STRING_LEN(y);\n          if (NODE_STRING_IS_AMBIG(x) || NODE_STRING_IS_AMBIG(y)) {\n            /* tiny version */\n            return 0;\n          }\n          else {\n            for (i = 0, p = ys->s, q = xs->s; i < len; i++, p++, q++) {\n              if (*p != *q) return 1;\n            }\n          }\n        }\n        break;\n\n      default:\n        break;\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  return 0;\n}\n\nstatic Node*\nget_head_value_node(Node* node, int exact, regex_t* reg)\n{\n  Node* n = NULL_NODE;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_BACKREF:\n  case NODE_ALT:\n#ifdef USE_CALL\n  case NODE_CALL:\n#endif\n    break;\n\n  case NODE_CTYPE:\n    if (CTYPE_(node)->ctype == CTYPE_ANYCHAR)\n      break;\n    /* fall */\n  case NODE_CCLASS:\n    if (exact == 0) {\n      n = node;\n    }\n    break;\n\n  case NODE_LIST:\n    n = get_head_value_node(NODE_CAR(node), exact, reg);\n    break;\n\n  case NODE_STRING:\n    {\n      StrNode* sn = STR_(node);\n\n      if (sn->end <= sn->s)\n        break;\n\n      if (exact == 0 ||\n          ! IS_IGNORECASE(reg->options) || NODE_STRING_IS_RAW(node)) {\n        n = node;\n      }\n    }\n    break;\n\n  case NODE_QUANT:\n    {\n      QuantNode* qn = QUANT_(node);\n      if (qn->lower > 0) {\n        if (IS_NOT_NULL(qn->head_exact))\n          n = qn->head_exact;\n        else\n          n = get_head_value_node(NODE_BODY(node), exact, reg);\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n      switch (en->type) {\n      case BAG_OPTION:\n        {\n          OnigOptionType options = reg->options;\n\n          reg->options = BAG_(node)->o.options;\n          n = get_head_value_node(NODE_BODY(node), exact, reg);\n          reg->options = options;\n        }\n        break;\n\n      case BAG_MEMORY:\n      case BAG_STOP_BACKTRACK:\n      case BAG_IF_ELSE:\n        n = get_head_value_node(NODE_BODY(node), exact, reg);\n        break;\n      }\n    }\n    break;\n\n  case NODE_ANCHOR:\n    if (ANCHOR_(node)->type == ANCR_PREC_READ)\n      n = get_head_value_node(NODE_BODY(node), exact, reg);\n    break;\n\n  case NODE_GIMMICK:\n  default:\n    break;\n  }\n\n  return n;\n}\n\nstatic int\ncheck_type_tree(Node* node, int type_mask, int bag_mask, int anchor_mask)\n{\n  NodeType type;\n  int r = 0;\n\n  type = NODE_TYPE(node);\n  if ((NODE_TYPE2BIT(type) & type_mask) == 0)\n    return 1;\n\n  switch (type) {\n  case NODE_LIST:\n  case NODE_ALT:\n    do {\n      r = check_type_tree(NODE_CAR(node), type_mask, bag_mask, anchor_mask);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_QUANT:\n    r = check_type_tree(NODE_BODY(node), type_mask, bag_mask, anchor_mask);\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n      if (((1<<en->type) & bag_mask) == 0)\n        return 1;\n\n      r = check_type_tree(NODE_BODY(node), type_mask, bag_mask, anchor_mask);\n      if (r == 0 && en->type == BAG_IF_ELSE) {\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = check_type_tree(en->te.Then, type_mask, bag_mask, anchor_mask);\n          if (r != 0) break;\n        }\n        if (IS_NOT_NULL(en->te.Else)) {\n          r = check_type_tree(en->te.Else, type_mask, bag_mask, anchor_mask);\n        }\n      }\n    }\n    break;\n\n  case NODE_ANCHOR:\n    type = ANCHOR_(node)->type;\n    if ((type & anchor_mask) == 0)\n      return 1;\n\n    if (IS_NOT_NULL(NODE_BODY(node)))\n      r = check_type_tree(NODE_BODY(node), type_mask, bag_mask, anchor_mask);\n    break;\n\n  case NODE_GIMMICK:\n  default:\n    break;\n  }\n  return r;\n}\n\nstatic OnigLen\ntree_min_len(Node* node, ScanEnv* env)\n{\n  OnigLen len;\n  OnigLen tmin;\n\n  len = 0;\n  switch (NODE_TYPE(node)) {\n  case NODE_BACKREF:\n    if (! NODE_IS_CHECKER(node)) {\n      int i;\n      int* backs;\n      MemEnv* mem_env = SCANENV_MEMENV(env);\n      BackRefNode* br = BACKREF_(node);\n      if (NODE_IS_RECURSION(node)) break;\n\n      backs = BACKREFS_P(br);\n      len = tree_min_len(mem_env[backs[0]].node, env);\n      for (i = 1; i < br->back_num; i++) {\n        tmin = tree_min_len(mem_env[backs[i]].node, env);\n        if (len > tmin) len = tmin;\n      }\n    }\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    {\n      Node* t = NODE_BODY(node);\n      if (NODE_IS_RECURSION(node)) {\n        if (NODE_IS_MIN_FIXED(t))\n          len = BAG_(t)->min_len;\n      }\n      else\n        len = tree_min_len(t, env);\n    }\n    break;\n#endif\n\n  case NODE_LIST:\n    do {\n      tmin = tree_min_len(NODE_CAR(node), env);\n      len = distance_add(len, tmin);\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_ALT:\n    {\n      Node *x, *y;\n      y = node;\n      do {\n        x = NODE_CAR(y);\n        tmin = tree_min_len(x, env);\n        if (y == node) len = tmin;\n        else if (len > tmin) len = tmin;\n      } while (IS_NOT_NULL(y = NODE_CDR(y)));\n    }\n    break;\n\n  case NODE_STRING:\n    {\n      StrNode* sn = STR_(node);\n      len = (int )(sn->end - sn->s);\n    }\n    break;\n\n  case NODE_CTYPE:\n  case NODE_CCLASS:\n    len = ONIGENC_MBC_MINLEN(env->enc);\n    break;\n\n  case NODE_QUANT:\n    {\n      QuantNode* qn = QUANT_(node);\n\n      if (qn->lower > 0) {\n        len = tree_min_len(NODE_BODY(node), env);\n        len = distance_multiply(len, qn->lower);\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n      switch (en->type) {\n      case BAG_MEMORY:\n        if (NODE_IS_MIN_FIXED(node))\n          len = en->min_len;\n        else {\n          if (NODE_IS_MARK1(node))\n            len = 0;  /* recursive */\n          else {\n            NODE_STATUS_ADD(node, MARK1);\n            len = tree_min_len(NODE_BODY(node), env);\n            NODE_STATUS_REMOVE(node, MARK1);\n\n            en->min_len = len;\n            NODE_STATUS_ADD(node, MIN_FIXED);\n          }\n        }\n        break;\n\n      case BAG_OPTION:\n      case BAG_STOP_BACKTRACK:\n        len = tree_min_len(NODE_BODY(node), env);\n        break;\n      case BAG_IF_ELSE:\n        {\n          OnigLen elen;\n\n          len = tree_min_len(NODE_BODY(node), env);\n          if (IS_NOT_NULL(en->te.Then))\n            len += tree_min_len(en->te.Then, env);\n          if (IS_NOT_NULL(en->te.Else))\n            elen = tree_min_len(en->te.Else, env);\n          else elen = 0;\n\n          if (elen < len) len = elen;\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_GIMMICK:\n    {\n      GimmickNode* g = GIMMICK_(node);\n      if (g->type == GIMMICK_FAIL) {\n        len = INFINITE_LEN;\n        break;\n      }\n    }\n    /* fall */\n  case NODE_ANCHOR:\n  default:\n    break;\n  }\n\n  return len;\n}\n\nstatic OnigLen\ntree_max_len(Node* node, ScanEnv* env)\n{\n  OnigLen len;\n  OnigLen tmax;\n\n  len = 0;\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n    do {\n      tmax = tree_max_len(NODE_CAR(node), env);\n      len = distance_add(len, tmax);\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_ALT:\n    do {\n      tmax = tree_max_len(NODE_CAR(node), env);\n      if (len < tmax) len = tmax;\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_STRING:\n    {\n      StrNode* sn = STR_(node);\n      len = (OnigLen )(sn->end - sn->s);\n    }\n    break;\n\n  case NODE_CTYPE:\n  case NODE_CCLASS:\n    len = ONIGENC_MBC_MAXLEN_DIST(env->enc);\n    break;\n\n  case NODE_BACKREF:\n    if (! NODE_IS_CHECKER(node)) {\n      int i;\n      int* backs;\n      MemEnv* mem_env = SCANENV_MEMENV(env);\n      BackRefNode* br = BACKREF_(node);\n      if (NODE_IS_RECURSION(node)) {\n        len = INFINITE_LEN;\n        break;\n      }\n      backs = BACKREFS_P(br);\n      for (i = 0; i < br->back_num; i++) {\n        tmax = tree_max_len(mem_env[backs[i]].node, env);\n        if (len < tmax) len = tmax;\n      }\n    }\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    if (! NODE_IS_RECURSION(node))\n      len = tree_max_len(NODE_BODY(node), env);\n    else\n      len = INFINITE_LEN;\n    break;\n#endif\n\n  case NODE_QUANT:\n    {\n      QuantNode* qn = QUANT_(node);\n\n      if (qn->upper != 0) {\n        len = tree_max_len(NODE_BODY(node), env);\n        if (len != 0) {\n          if (! IS_REPEAT_INFINITE(qn->upper))\n            len = distance_multiply(len, qn->upper);\n          else\n            len = INFINITE_LEN;\n        }\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n      switch (en->type) {\n      case BAG_MEMORY:\n        if (NODE_IS_MAX_FIXED(node))\n          len = en->max_len;\n        else {\n          if (NODE_IS_MARK1(node))\n            len = INFINITE_LEN;\n          else {\n            NODE_STATUS_ADD(node, MARK1);\n            len = tree_max_len(NODE_BODY(node), env);\n            NODE_STATUS_REMOVE(node, MARK1);\n\n            en->max_len = len;\n            NODE_STATUS_ADD(node, MAX_FIXED);\n          }\n        }\n        break;\n\n      case BAG_OPTION:\n      case BAG_STOP_BACKTRACK:\n        len = tree_max_len(NODE_BODY(node), env);\n        break;\n      case BAG_IF_ELSE:\n        {\n          OnigLen tlen, elen;\n\n          len = tree_max_len(NODE_BODY(node), env);\n          if (IS_NOT_NULL(en->te.Then)) {\n            tlen = tree_max_len(en->te.Then, env);\n            len = distance_add(len, tlen);\n          }\n          if (IS_NOT_NULL(en->te.Else))\n            elen = tree_max_len(en->te.Else, env);\n          else elen = 0;\n\n          if (elen > len) len = elen;\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_ANCHOR:\n  case NODE_GIMMICK:\n  default:\n    break;\n  }\n\n  return len;\n}\n\nstatic int\ncheck_backrefs(Node* node, ScanEnv* env)\n{\n  int r;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    do {\n      r = check_backrefs(NODE_CAR(node), env);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_ANCHOR:\n    if (! ANCHOR_HAS_BODY(ANCHOR_(node))) {\n      r = 0;\n      break;\n    }\n    /* fall */\n  case NODE_QUANT:\n    r = check_backrefs(NODE_BODY(node), env);\n    break;\n\n  case NODE_BAG:\n    r = check_backrefs(NODE_BODY(node), env);\n    {\n      BagNode* en = BAG_(node);\n\n      if (en->type == BAG_IF_ELSE) {\n        if (r != 0) return r;\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = check_backrefs(en->te.Then, env);\n          if (r != 0) return r;\n        }\n        if (IS_NOT_NULL(en->te.Else)) {\n          r = check_backrefs(en->te.Else, env);\n        }\n      }\n    }\n    break;\n\n  case NODE_BACKREF:\n    {\n      int i;\n      BackRefNode* br = BACKREF_(node);\n      int* backs = BACKREFS_P(br);\n      MemEnv* mem_env = SCANENV_MEMENV(env);\n\n      for (i = 0; i < br->back_num; i++) {\n        if (backs[i] > env->num_mem)\n          return ONIGERR_INVALID_BACKREF;\n\n        NODE_STATUS_ADD(mem_env[backs[i]].node, BACKREF);\n      }\n      r = 0;\n    }\n    break;\n\n  default:\n    r = 0;\n    break;\n  }\n\n  return r;\n}\n\n\n#ifdef USE_CALL\n\n#define RECURSION_EXIST        (1<<0)\n#define RECURSION_MUST         (1<<1)\n#define RECURSION_INFINITE     (1<<2)\n\nstatic int\ninfinite_recursive_call_check(Node* node, ScanEnv* env, int head)\n{\n  int ret;\n  int r = 0;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n    {\n      Node *x;\n      OnigLen min;\n\n      x = node;\n      do {\n        ret = infinite_recursive_call_check(NODE_CAR(x), env, head);\n        if (ret < 0 || (ret & RECURSION_INFINITE) != 0) return ret;\n        r |= ret;\n        if (head != 0) {\n          min = tree_min_len(NODE_CAR(x), env);\n          if (min != 0) head = 0;\n        }\n      } while (IS_NOT_NULL(x = NODE_CDR(x)));\n    }\n    break;\n\n  case NODE_ALT:\n    {\n      int must;\n\n      must = RECURSION_MUST;\n      do {\n        ret = infinite_recursive_call_check(NODE_CAR(node), env, head);\n        if (ret < 0 || (ret & RECURSION_INFINITE) != 0) return ret;\n\n        r    |= (ret & RECURSION_EXIST);\n        must &= ret;\n      } while (IS_NOT_NULL(node = NODE_CDR(node)));\n      r |= must;\n    }\n    break;\n\n  case NODE_QUANT:\n    r = infinite_recursive_call_check(NODE_BODY(node), env, head);\n    if (r < 0) return r;\n    if ((r & RECURSION_MUST) != 0) {\n      if (QUANT_(node)->lower == 0)\n        r &= ~RECURSION_MUST;\n    }\n    break;\n\n  case NODE_ANCHOR:\n    if (! ANCHOR_HAS_BODY(ANCHOR_(node)))\n      break;\n    /* fall */\n  case NODE_CALL:\n    r = infinite_recursive_call_check(NODE_BODY(node), env, head);\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      if (en->type == BAG_MEMORY) {\n        if (NODE_IS_MARK2(node))\n          return 0;\n        else if (NODE_IS_MARK1(node))\n          return (head == 0 ? RECURSION_EXIST | RECURSION_MUST\n                  : RECURSION_EXIST | RECURSION_MUST | RECURSION_INFINITE);\n        else {\n          NODE_STATUS_ADD(node, MARK2);\n          r = infinite_recursive_call_check(NODE_BODY(node), env, head);\n          NODE_STATUS_REMOVE(node, MARK2);\n        }\n      }\n      else if (en->type == BAG_IF_ELSE) {\n        int eret;\n\n        ret = infinite_recursive_call_check(NODE_BODY(node), env, head);\n        if (ret < 0 || (ret & RECURSION_INFINITE) != 0) return ret;\n        r |= ret;\n        if (IS_NOT_NULL(en->te.Then)) {\n          OnigLen min;\n          if (head != 0) {\n            min = tree_min_len(NODE_BODY(node), env);\n          }\n          else min = 0;\n\n          ret = infinite_recursive_call_check(en->te.Then, env, min != 0 ? 0:head);\n          if (ret < 0 || (ret & RECURSION_INFINITE) != 0) return ret;\n          r |= ret;\n        }\n        if (IS_NOT_NULL(en->te.Else)) {\n          eret = infinite_recursive_call_check(en->te.Else, env, head);\n          if (eret < 0 || (eret & RECURSION_INFINITE) != 0) return eret;\n          r |= (eret & RECURSION_EXIST);\n          if ((eret & RECURSION_MUST) == 0)\n            r &= ~RECURSION_MUST;\n        }\n      }\n      else {\n        r = infinite_recursive_call_check(NODE_BODY(node), env, head);\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  return r;\n}\n\nstatic int\ninfinite_recursive_call_check_trav(Node* node, ScanEnv* env)\n{\n  int r;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    do {\n      r = infinite_recursive_call_check_trav(NODE_CAR(node), env);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_ANCHOR:\n    if (! ANCHOR_HAS_BODY(ANCHOR_(node))) {\n      r = 0;\n      break;\n    }\n    /* fall */\n  case NODE_QUANT:\n    r = infinite_recursive_call_check_trav(NODE_BODY(node), env);\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      if (en->type == BAG_MEMORY) {\n        if (NODE_IS_RECURSION(node) && NODE_IS_CALLED(node)) {\n          int ret;\n\n          NODE_STATUS_ADD(node, MARK1);\n\n          ret = infinite_recursive_call_check(NODE_BODY(node), env, 1);\n          if (ret < 0) return ret;\n          else if ((ret & (RECURSION_MUST | RECURSION_INFINITE)) != 0)\n            return ONIGERR_NEVER_ENDING_RECURSION;\n\n          NODE_STATUS_REMOVE(node, MARK1);\n        }\n      }\n      else if (en->type == BAG_IF_ELSE) {\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = infinite_recursive_call_check_trav(en->te.Then, env);\n          if (r != 0) return r;\n        }\n        if (IS_NOT_NULL(en->te.Else)) {\n          r = infinite_recursive_call_check_trav(en->te.Else, env);\n          if (r != 0) return r;\n        }\n      }\n    }\n\n    r = infinite_recursive_call_check_trav(NODE_BODY(node), env);\n    break;\n\n  default:\n    r = 0;\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nrecursive_call_check(Node* node)\n{\n  int r;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    r = 0;\n    do {\n      r |= recursive_call_check(NODE_CAR(node));\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_ANCHOR:\n    if (! ANCHOR_HAS_BODY(ANCHOR_(node))) {\n      r = 0;\n      break;\n    }\n    /* fall */\n  case NODE_QUANT:\n    r = recursive_call_check(NODE_BODY(node));\n    break;\n\n  case NODE_CALL:\n    r = recursive_call_check(NODE_BODY(node));\n    if (r != 0) {\n      if (NODE_IS_MARK1(NODE_BODY(node)))\n        NODE_STATUS_ADD(node, RECURSION);\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      if (en->type == BAG_MEMORY) {\n        if (NODE_IS_MARK2(node))\n          return 0;\n        else if (NODE_IS_MARK1(node))\n          return 1; /* recursion */\n        else {\n          NODE_STATUS_ADD(node, MARK2);\n          r = recursive_call_check(NODE_BODY(node));\n          NODE_STATUS_REMOVE(node, MARK2);\n        }\n      }\n      else if (en->type == BAG_IF_ELSE) {\n        r = 0;\n        if (IS_NOT_NULL(en->te.Then)) {\n          r |= recursive_call_check(en->te.Then);\n        }\n        if (IS_NOT_NULL(en->te.Else)) {\n          r |= recursive_call_check(en->te.Else);\n        }\n        r |= recursive_call_check(NODE_BODY(node));\n      }\n      else {\n        r = recursive_call_check(NODE_BODY(node));\n      }\n    }\n    break;\n\n  default:\n    r = 0;\n    break;\n  }\n\n  return r;\n}\n\n#define IN_RECURSION         (1<<0)\n#define FOUND_CALLED_NODE    1\n\nstatic int\nrecursive_call_check_trav(Node* node, ScanEnv* env, int state)\n{\n  int r = 0;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    {\n      int ret;\n      do {\n        ret = recursive_call_check_trav(NODE_CAR(node), env, state);\n        if (ret == FOUND_CALLED_NODE) r = FOUND_CALLED_NODE;\n        else if (ret < 0) return ret;\n      } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    }\n    break;\n\n  case NODE_QUANT:\n    r = recursive_call_check_trav(NODE_BODY(node), env, state);\n    if (QUANT_(node)->upper == 0) {\n      if (r == FOUND_CALLED_NODE)\n        QUANT_(node)->is_refered = 1;\n    }\n    break;\n\n  case NODE_ANCHOR:\n    {\n      AnchorNode* an = ANCHOR_(node);\n      if (ANCHOR_HAS_BODY(an))\n        r = recursive_call_check_trav(NODE_ANCHOR_BODY(an), env, state);\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      int ret;\n      int state1;\n      BagNode* en = BAG_(node);\n\n      if (en->type == BAG_MEMORY) {\n        if (NODE_IS_CALLED(node) || (state & IN_RECURSION) != 0) {\n          if (! NODE_IS_RECURSION(node)) {\n            NODE_STATUS_ADD(node, MARK1);\n            r = recursive_call_check(NODE_BODY(node));\n            if (r != 0)\n              NODE_STATUS_ADD(node, RECURSION);\n            NODE_STATUS_REMOVE(node, MARK1);\n          }\n\n          if (NODE_IS_CALLED(node))\n            r = FOUND_CALLED_NODE;\n        }\n      }\n\n      state1 = state;\n      if (NODE_IS_RECURSION(node))\n        state1 |= IN_RECURSION;\n\n      ret = recursive_call_check_trav(NODE_BODY(node), env, state1);\n      if (ret == FOUND_CALLED_NODE)\n        r = FOUND_CALLED_NODE;\n\n      if (en->type == BAG_IF_ELSE) {\n        if (IS_NOT_NULL(en->te.Then)) {\n          ret = recursive_call_check_trav(en->te.Then, env, state1);\n          if (ret == FOUND_CALLED_NODE)\n            r = FOUND_CALLED_NODE;\n        }\n        if (IS_NOT_NULL(en->te.Else)) {\n          ret = recursive_call_check_trav(en->te.Else, env, state1);\n          if (ret == FOUND_CALLED_NODE)\n            r = FOUND_CALLED_NODE;\n        }\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  return r;\n}\n\n#endif\n\n#define IN_ALT          (1<<0)\n#define IN_NOT          (1<<1)\n#define IN_REAL_REPEAT  (1<<2)\n#define IN_VAR_REPEAT   (1<<3)\n#define IN_ZERO_REPEAT  (1<<4)\n#define IN_MULTI_ENTRY  (1<<5)\n#define IN_LOOK_BEHIND  (1<<6)\n\n\n/* divide different length alternatives in look-behind.\n  (?<=A|B) ==> (?<=A)|(?<=B)\n  (?<!A|B) ==> (?<!A)(?<!B)\n*/\nstatic int\ndivide_look_behind_alternatives(Node* node)\n{\n  Node *head, *np, *insert_node;\n  AnchorNode* an = ANCHOR_(node);\n  int anc_type = an->type;\n\n  head = NODE_ANCHOR_BODY(an);\n  np = NODE_CAR(head);\n  swap_node(node, head);\n  NODE_CAR(node) = head;\n  NODE_BODY(head) = np;\n\n  np = node;\n  while (IS_NOT_NULL(np = NODE_CDR(np))) {\n    insert_node = onig_node_new_anchor(anc_type, an->ascii_mode);\n    CHECK_NULL_RETURN_MEMERR(insert_node);\n    NODE_BODY(insert_node) = NODE_CAR(np);\n    NODE_CAR(np) = insert_node;\n  }\n\n  if (anc_type == ANCR_LOOK_BEHIND_NOT) {\n    np = node;\n    do {\n      NODE_SET_TYPE(np, NODE_LIST);  /* alt -> list */\n    } while (IS_NOT_NULL(np = NODE_CDR(np)));\n  }\n  return 0;\n}\n\nstatic int\nsetup_look_behind(Node* node, regex_t* reg, ScanEnv* env)\n{\n  int r, len;\n  AnchorNode* an = ANCHOR_(node);\n\n  r = get_char_len_node(NODE_ANCHOR_BODY(an), reg, &len);\n  if (r == 0)\n    an->char_len = len;\n  else if (r == GET_CHAR_LEN_VARLEN)\n    r = ONIGERR_INVALID_LOOK_BEHIND_PATTERN;\n  else if (r == GET_CHAR_LEN_TOP_ALT_VARLEN) {\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_DIFFERENT_LEN_ALT_LOOK_BEHIND))\n      r = divide_look_behind_alternatives(node);\n    else\n      r = ONIGERR_INVALID_LOOK_BEHIND_PATTERN;\n  }\n\n  return r;\n}\n\nstatic int\nnext_setup(Node* node, Node* next_node, regex_t* reg)\n{\n  NodeType type;\n\n retry:\n  type = NODE_TYPE(node);\n  if (type == NODE_QUANT) {\n    QuantNode* qn = QUANT_(node);\n    if (qn->greedy && IS_REPEAT_INFINITE(qn->upper)) {\n#ifdef USE_QUANT_PEEK_NEXT\n      Node* n = get_head_value_node(next_node, 1, reg);\n      /* '\\0': for UTF-16BE etc... */\n      if (IS_NOT_NULL(n) && STR_(n)->s[0] != '\\0') {\n        qn->next_head_exact = n;\n      }\n#endif\n      /* automatic posseivation a*b ==> (?>a*)b */\n      if (qn->lower <= 1) {\n        if (NODE_IS_SIMPLE_TYPE(NODE_BODY(node))) {\n          Node *x, *y;\n          x = get_head_value_node(NODE_BODY(node), 0, reg);\n          if (IS_NOT_NULL(x)) {\n            y = get_head_value_node(next_node,  0, reg);\n            if (IS_NOT_NULL(y) && is_exclusive(x, y, reg)) {\n              Node* en = onig_node_new_bag(BAG_STOP_BACKTRACK);\n              CHECK_NULL_RETURN_MEMERR(en);\n              NODE_STATUS_ADD(en, STOP_BT_SIMPLE_REPEAT);\n              swap_node(node, en);\n              NODE_BODY(node) = en;\n            }\n          }\n        }\n      }\n    }\n  }\n  else if (type == NODE_BAG) {\n    BagNode* en = BAG_(node);\n    if (en->type == BAG_MEMORY) {\n      node = NODE_BODY(node);\n      goto retry;\n    }\n  }\n  return 0;\n}\n\n\nstatic int\nupdate_string_node_case_fold(regex_t* reg, Node *node)\n{\n  UChar *p, *end, buf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  UChar *sbuf, *ebuf, *sp;\n  int r, i, len, sbuf_size;\n  StrNode* sn = STR_(node);\n\n  end = sn->end;\n  sbuf_size = (int )(end - sn->s) * 2;\n  sbuf = (UChar* )xmalloc(sbuf_size);\n  CHECK_NULL_RETURN_MEMERR(sbuf);\n  ebuf = sbuf + sbuf_size;\n\n  sp = sbuf;\n  p = sn->s;\n  while (p < end) {\n    len = ONIGENC_MBC_CASE_FOLD(reg->enc, reg->case_fold_flag, &p, end, buf);\n    for (i = 0; i < len; i++) {\n      if (sp >= ebuf) {\n        sbuf = (UChar* )xrealloc(sbuf, sbuf_size * 2);\n        CHECK_NULL_RETURN_MEMERR(sbuf);\n        sp = sbuf + sbuf_size;\n        sbuf_size *= 2;\n        ebuf = sbuf + sbuf_size;\n      }\n\n      *sp++ = buf[i];\n    }\n  }\n\n  r = onig_node_str_set(node, sbuf, sp);\n  if (r != 0) {\n    xfree(sbuf);\n    return r;\n  }\n\n  xfree(sbuf);\n  return 0;\n}\n\nstatic int\nexpand_case_fold_make_rem_string(Node** rnode, UChar *s, UChar *end, regex_t* reg)\n{\n  int r;\n  Node *node;\n\n  node = onig_node_new_str(s, end);\n  if (IS_NULL(node)) return ONIGERR_MEMORY;\n\n  r = update_string_node_case_fold(reg, node);\n  if (r != 0) {\n    onig_node_free(node);\n    return r;\n  }\n\n  NODE_STRING_SET_AMBIG(node);\n  NODE_STRING_SET_DONT_GET_OPT_INFO(node);\n  *rnode = node;\n  return 0;\n}\n\nstatic int\nexpand_case_fold_string_alt(int item_num, OnigCaseFoldCodeItem items[], UChar *p,\n                            int slen, UChar *end, regex_t* reg, Node **rnode)\n{\n  int r, i, j;\n  int len;\n  int varlen;\n  Node *anode, *var_anode, *snode, *xnode, *an;\n  UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n\n  *rnode = var_anode = NULL_NODE;\n\n  varlen = 0;\n  for (i = 0; i < item_num; i++) {\n    if (items[i].byte_len != slen) {\n      varlen = 1;\n      break;\n    }\n  }\n\n  if (varlen != 0) {\n    *rnode = var_anode = onig_node_new_alt(NULL_NODE, NULL_NODE);\n    if (IS_NULL(var_anode)) return ONIGERR_MEMORY;\n\n    xnode = onig_node_new_list(NULL, NULL);\n    if (IS_NULL(xnode)) goto mem_err;\n    NODE_CAR(var_anode) = xnode;\n\n    anode = onig_node_new_alt(NULL_NODE, NULL_NODE);\n    if (IS_NULL(anode)) goto mem_err;\n    NODE_CAR(xnode) = anode;\n  }\n  else {\n    *rnode = anode = onig_node_new_alt(NULL_NODE, NULL_NODE);\n    if (IS_NULL(anode)) return ONIGERR_MEMORY;\n  }\n\n  snode = onig_node_new_str(p, p + slen);\n  if (IS_NULL(snode)) goto mem_err;\n\n  NODE_CAR(anode) = snode;\n\n  for (i = 0; i < item_num; i++) {\n    snode = onig_node_new_str(NULL, NULL);\n    if (IS_NULL(snode)) goto mem_err;\n\n    for (j = 0; j < items[i].code_len; j++) {\n      len = ONIGENC_CODE_TO_MBC(reg->enc, items[i].code[j], buf);\n      if (len < 0) {\n        r = len;\n        goto mem_err2;\n      }\n\n      r = onig_node_str_cat(snode, buf, buf + len);\n      if (r != 0) goto mem_err2;\n    }\n\n    an = onig_node_new_alt(NULL_NODE, NULL_NODE);\n    if (IS_NULL(an)) {\n      goto mem_err2;\n    }\n\n    if (items[i].byte_len != slen && IS_NOT_NULL(var_anode)) {\n      Node *rem;\n      UChar *q = p + items[i].byte_len;\n\n      if (q < end) {\n        r = expand_case_fold_make_rem_string(&rem, q, end, reg);\n        if (r != 0) {\n          onig_node_free(an);\n          goto mem_err2;\n        }\n\n        xnode = onig_node_list_add(NULL_NODE, snode);\n        if (IS_NULL(xnode)) {\n          onig_node_free(an);\n          onig_node_free(rem);\n          goto mem_err2;\n        }\n        if (IS_NULL(onig_node_list_add(xnode, rem))) {\n          onig_node_free(an);\n          onig_node_free(xnode);\n          onig_node_free(rem);\n          goto mem_err;\n        }\n\n        NODE_CAR(an) = xnode;\n      }\n      else {\n        NODE_CAR(an) = snode;\n      }\n\n      NODE_CDR(var_anode) = an;\n      var_anode = an;\n    }\n    else {\n      NODE_CAR(an)     = snode;\n      NODE_CDR(anode) = an;\n      anode = an;\n    }\n  }\n\n  return varlen;\n\n mem_err2:\n  onig_node_free(snode);\n\n mem_err:\n  onig_node_free(*rnode);\n\n  return ONIGERR_MEMORY;\n}\n\nstatic int\nis_good_case_fold_items_for_search(OnigEncoding enc, int slen,\n                                   int n, OnigCaseFoldCodeItem items[])\n{\n  int i, len;\n  UChar buf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n  for (i = 0; i < n; i++) {\n    OnigCaseFoldCodeItem* item = items + i;\n\n    if (item->code_len != 1)    return 0;\n    if (item->byte_len != slen) return 0;\n    len = ONIGENC_CODE_TO_MBC(enc, item->code[0], buf);\n    if (len != slen) return 0;\n  }\n\n  return 1;\n}\n\n#define THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION  8\n\nstatic int\nexpand_case_fold_string(Node* node, regex_t* reg, int state)\n{\n  int r, n, len, alt_num;\n  int fold_len;\n  int prev_is_ambig, prev_is_good, is_good, is_in_look_behind;\n  UChar *start, *end, *p;\n  UChar* foldp;\n  Node *top_root, *root, *snode, *prev_node;\n  OnigCaseFoldCodeItem items[ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM];\n  UChar buf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  StrNode* sn;\n\n  if (NODE_STRING_IS_AMBIG(node)) return 0;\n\n  sn = STR_(node);\n\n  start = sn->s;\n  end   = sn->end;\n  if (start >= end) return 0;\n\n  is_in_look_behind = (state & IN_LOOK_BEHIND) != 0;\n\n  r = 0;\n  top_root = root = prev_node = snode = NULL_NODE;\n  alt_num = 1;\n  p = start;\n  while (p < end) {\n    n = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(reg->enc, reg->case_fold_flag,\n                                           p, end, items);\n    if (n < 0) {\n      r = n;\n      goto err;\n    }\n\n    len = enclen(reg->enc, p);\n    is_good = is_good_case_fold_items_for_search(reg->enc, len, n, items);\n\n    if (is_in_look_behind ||\n        (IS_NOT_NULL(snode) ||\n         (is_good\n          /* expand single char case: ex. /(?i:a)/ */\n          && !(p == start && p + len >= end)))) {\n      if (IS_NULL(snode)) {\n        if (IS_NULL(root) && IS_NOT_NULL(prev_node)) {\n          top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n          if (IS_NULL(root)) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n\n        prev_node = snode = onig_node_new_str(NULL, NULL);\n        if (IS_NULL(snode)) goto mem_err;\n        if (IS_NOT_NULL(root)) {\n          if (IS_NULL(onig_node_list_add(root, snode))) {\n            onig_node_free(snode);\n            goto mem_err;\n          }\n        }\n\n        prev_is_ambig = -1; /* -1: new */\n        prev_is_good  =  0; /* escape compiler warning */\n      }\n      else {\n        prev_is_ambig = NODE_STRING_IS_AMBIG(snode);\n        prev_is_good  = NODE_STRING_IS_GOOD_AMBIG(snode);\n      }\n\n      if (n != 0) {\n        foldp = p;\n        fold_len = ONIGENC_MBC_CASE_FOLD(reg->enc, reg->case_fold_flag,\n                                         &foldp, end, buf);\n        foldp = buf;\n      }\n      else {\n        foldp = p; fold_len = len;\n      }\n\n      if ((prev_is_ambig == 0 && n != 0) ||\n          (prev_is_ambig > 0 && (n == 0 || prev_is_good != is_good))) {\n        if (IS_NULL(root) /* && IS_NOT_NULL(prev_node) */) {\n          top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n          if (IS_NULL(root)) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n\n        prev_node = snode = onig_node_new_str(foldp, foldp + fold_len);\n        if (IS_NULL(snode)) goto mem_err;\n        if (IS_NULL(onig_node_list_add(root, snode))) {\n          onig_node_free(snode);\n          goto mem_err;\n        }\n      }\n      else {\n        r = onig_node_str_cat(snode, foldp, foldp + fold_len);\n        if (r != 0) goto err;\n      }\n\n      if (n != 0) NODE_STRING_SET_AMBIG(snode);\n      if (is_good != 0) NODE_STRING_SET_GOOD_AMBIG(snode);\n    }\n    else {\n      alt_num *= (n + 1);\n      if (alt_num > THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION) break;\n\n      if (IS_NULL(root) && IS_NOT_NULL(prev_node)) {\n        top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n        if (IS_NULL(root)) {\n          onig_node_free(prev_node);\n          goto mem_err;\n        }\n      }\n\n      r = expand_case_fold_string_alt(n, items, p, len, end, reg, &prev_node);\n      if (r < 0) goto mem_err;\n      if (r == 1) {\n        if (IS_NULL(root)) {\n          top_root = prev_node;\n        }\n        else {\n          if (IS_NULL(onig_node_list_add(root, prev_node))) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n\n        root = NODE_CAR(prev_node);\n      }\n      else { /* r == 0 */\n        if (IS_NOT_NULL(root)) {\n          if (IS_NULL(onig_node_list_add(root, prev_node))) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n      }\n\n      snode = NULL_NODE;\n    }\n\n    p += len;\n  }\n\n  if (p < end) {\n    Node *srem;\n\n    r = expand_case_fold_make_rem_string(&srem, p, end, reg);\n    if (r != 0) goto mem_err;\n\n    if (IS_NOT_NULL(prev_node) && IS_NULL(root)) {\n      top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n      if (IS_NULL(root)) {\n        onig_node_free(srem);\n        onig_node_free(prev_node);\n        goto mem_err;\n      }\n    }\n\n    if (IS_NULL(root)) {\n      prev_node = srem;\n    }\n    else {\n      if (IS_NULL(onig_node_list_add(root, srem))) {\n        onig_node_free(srem);\n        goto mem_err;\n      }\n    }\n  }\n\n  /* ending */\n  top_root = (IS_NOT_NULL(top_root) ? top_root : prev_node);\n  swap_node(node, top_root);\n  onig_node_free(top_root);\n  return 0;\n\n mem_err:\n  r = ONIGERR_MEMORY;\n\n err:\n  onig_node_free(top_root);\n  return r;\n}\n\n#ifdef USE_INSISTENT_CHECK_CAPTURES_IN_EMPTY_REPEAT\nstatic enum BodyEmpty\nquantifiers_memory_node_info(Node* node)\n{\n  int r = BODY_IS_EMPTY;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    {\n      int v;\n      do {\n        v = quantifiers_memory_node_info(NODE_CAR(node));\n        if (v > r) r = v;\n      } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    }\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    if (NODE_IS_RECURSION(node)) {\n      return BODY_IS_EMPTY_REC; /* tiny version */\n    }\n    else\n      r = quantifiers_memory_node_info(NODE_BODY(node));\n    break;\n#endif\n\n  case NODE_QUANT:\n    {\n      QuantNode* qn = QUANT_(node);\n      if (qn->upper != 0) {\n        r = quantifiers_memory_node_info(NODE_BODY(node));\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n      switch (en->type) {\n      case BAG_MEMORY:\n        if (NODE_IS_RECURSION(node)) {\n          return BODY_IS_EMPTY_REC;\n        }\n        return BODY_IS_EMPTY_MEM;\n        break;\n\n      case BAG_OPTION:\n      case BAG_STOP_BACKTRACK:\n        r = quantifiers_memory_node_info(NODE_BODY(node));\n        break;\n      case BAG_IF_ELSE:\n        {\n          int v;\n          r = quantifiers_memory_node_info(NODE_BODY(node));\n          if (IS_NOT_NULL(en->te.Then)) {\n            v = quantifiers_memory_node_info(en->te.Then);\n            if (v > r) r = v;\n          }\n          if (IS_NOT_NULL(en->te.Else)) {\n            v = quantifiers_memory_node_info(en->te.Else);\n            if (v > r) r = v;\n          }\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_BACKREF:\n  case NODE_STRING:\n  case NODE_CTYPE:\n  case NODE_CCLASS:\n  case NODE_ANCHOR:\n  case NODE_GIMMICK:\n  default:\n    break;\n  }\n\n  return r;\n}\n#endif /* USE_INSISTENT_CHECK_CAPTURES_IN_EMPTY_REPEAT */\n\n\n#ifdef USE_CALL\n\n#ifdef __GNUC__\n__inline\n#endif\nstatic int\nsetup_call_node_call(CallNode* cn, ScanEnv* env, int state)\n{\n  MemEnv* mem_env = SCANENV_MEMENV(env);\n\n  if (cn->by_number != 0) {\n    int gnum = cn->group_num;\n\n    if (env->num_named > 0 &&\n        IS_SYNTAX_BV(env->syntax, ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP) &&\n        ! ONIG_IS_OPTION_ON(env->options, ONIG_OPTION_CAPTURE_GROUP)) {\n      return ONIGERR_NUMBERED_BACKREF_OR_CALL_NOT_ALLOWED;\n    }\n\n    if (gnum > env->num_mem) {\n      onig_scan_env_set_error_string(env, ONIGERR_UNDEFINED_GROUP_REFERENCE,\n                                     cn->name, cn->name_end);\n      return ONIGERR_UNDEFINED_GROUP_REFERENCE;\n    }\n\n  set_call_attr:\n    NODE_CALL_BODY(cn) = mem_env[cn->group_num].node;\n    if (IS_NULL(NODE_CALL_BODY(cn))) {\n      onig_scan_env_set_error_string(env, ONIGERR_UNDEFINED_NAME_REFERENCE,\n                                     cn->name, cn->name_end);\n      return ONIGERR_UNDEFINED_NAME_REFERENCE;\n    }\n  }\n  else {\n    int *refs;\n\n    int n = onig_name_to_group_numbers(env->reg, cn->name, cn->name_end, &refs);\n    if (n <= 0) {\n      onig_scan_env_set_error_string(env, ONIGERR_UNDEFINED_NAME_REFERENCE,\n                                     cn->name, cn->name_end);\n      return ONIGERR_UNDEFINED_NAME_REFERENCE;\n    }\n    else if (n > 1) {\n      onig_scan_env_set_error_string(env, ONIGERR_MULTIPLEX_DEFINITION_NAME_CALL,\n                                     cn->name, cn->name_end);\n      return ONIGERR_MULTIPLEX_DEFINITION_NAME_CALL;\n    }\n    else {\n      cn->group_num = refs[0];\n      goto set_call_attr;\n    }\n  }\n\n  return 0;\n}\n\nstatic void\nsetup_call2_call(Node* node)\n{\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    do {\n      setup_call2_call(NODE_CAR(node));\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_QUANT:\n    setup_call2_call(NODE_BODY(node));\n    break;\n\n  case NODE_ANCHOR:\n    if (ANCHOR_HAS_BODY(ANCHOR_(node)))\n      setup_call2_call(NODE_BODY(node));\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      if (en->type == BAG_MEMORY) {\n        if (! NODE_IS_MARK1(node)) {\n          NODE_STATUS_ADD(node, MARK1);\n          setup_call2_call(NODE_BODY(node));\n          NODE_STATUS_REMOVE(node, MARK1);\n        }\n      }\n      else if (en->type == BAG_IF_ELSE) {\n        setup_call2_call(NODE_BODY(node));\n        if (IS_NOT_NULL(en->te.Then))\n          setup_call2_call(en->te.Then);\n        if (IS_NOT_NULL(en->te.Else))\n          setup_call2_call(en->te.Else);\n      }\n      else {\n        setup_call2_call(NODE_BODY(node));\n      }\n    }\n    break;\n\n  case NODE_CALL:\n    if (! NODE_IS_MARK1(node)) {\n      NODE_STATUS_ADD(node, MARK1);\n      {\n        CallNode* cn = CALL_(node);\n        Node* called = NODE_CALL_BODY(cn);\n\n        cn->entry_count++;\n\n        NODE_STATUS_ADD(called, CALLED);\n        BAG_(called)->m.entry_count++;\n        setup_call2_call(called);\n      }\n      NODE_STATUS_REMOVE(node, MARK1);\n    }\n    break;\n\n  default:\n    break;\n  }\n}\n\nstatic int\nsetup_call(Node* node, ScanEnv* env, int state)\n{\n  int r;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    do {\n      r = setup_call(NODE_CAR(node), env, state);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_QUANT:\n    if (QUANT_(node)->upper == 0)\n      state |= IN_ZERO_REPEAT;\n\n    r = setup_call(NODE_BODY(node), env, state);\n    break;\n\n  case NODE_ANCHOR:\n    if (ANCHOR_HAS_BODY(ANCHOR_(node)))\n      r = setup_call(NODE_BODY(node), env, state);\n    else\n      r = 0;\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      if (en->type == BAG_MEMORY) {\n        if ((state & IN_ZERO_REPEAT) != 0) {\n          NODE_STATUS_ADD(node, IN_ZERO_REPEAT);\n          BAG_(node)->m.entry_count--;\n        }\n        r = setup_call(NODE_BODY(node), env, state);\n      }\n      else if (en->type == BAG_IF_ELSE) {\n        r = setup_call(NODE_BODY(node), env, state);\n        if (r != 0) return r;\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = setup_call(en->te.Then, env, state);\n          if (r != 0) return r;\n        }\n        if (IS_NOT_NULL(en->te.Else))\n          r = setup_call(en->te.Else, env, state);\n      }\n      else\n        r = setup_call(NODE_BODY(node), env, state);\n    }\n    break;\n\n  case NODE_CALL:\n    if ((state & IN_ZERO_REPEAT) != 0) {\n      NODE_STATUS_ADD(node, IN_ZERO_REPEAT);\n      CALL_(node)->entry_count--;\n    }\n\n    r = setup_call_node_call(CALL_(node), env, state);\n    break;\n\n  default:\n    r = 0;\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nsetup_call2(Node* node)\n{\n  int r = 0;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n  case NODE_ALT:\n    do {\n      r = setup_call2(NODE_CAR(node));\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_QUANT:\n    if (QUANT_(node)->upper != 0)\n      r = setup_call2(NODE_BODY(node));\n    break;\n\n  case NODE_ANCHOR:\n    if (ANCHOR_HAS_BODY(ANCHOR_(node)))\n      r = setup_call2(NODE_BODY(node));\n    break;\n\n  case NODE_BAG:\n    if (! NODE_IS_IN_ZERO_REPEAT(node))\n      r = setup_call2(NODE_BODY(node));\n\n    {\n      BagNode* en = BAG_(node);\n\n      if (r != 0) return r;\n      if (en->type == BAG_IF_ELSE) {\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = setup_call2(en->te.Then);\n          if (r != 0) return r;\n        }\n        if (IS_NOT_NULL(en->te.Else))\n          r = setup_call2(en->te.Else);\n      }\n    }\n    break;\n\n  case NODE_CALL:\n    if (! NODE_IS_IN_ZERO_REPEAT(node)) {\n      setup_call2_call(node);\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  return r;\n}\n\n\nstatic void\nsetup_called_state_call(Node* node, int state)\n{\n  switch (NODE_TYPE(node)) {\n  case NODE_ALT:\n    state |= IN_ALT;\n    /* fall */\n  case NODE_LIST:\n    do {\n      setup_called_state_call(NODE_CAR(node), state);\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_QUANT:\n    {\n      QuantNode* qn = QUANT_(node);\n\n      if (IS_REPEAT_INFINITE(qn->upper) || qn->upper >= 2)\n        state |= IN_REAL_REPEAT;\n      if (qn->lower != qn->upper)\n        state |= IN_VAR_REPEAT;\n\n      setup_called_state_call(NODE_QUANT_BODY(qn), state);\n    }\n    break;\n\n  case NODE_ANCHOR:\n    {\n      AnchorNode* an = ANCHOR_(node);\n\n      switch (an->type) {\n      case ANCR_PREC_READ_NOT:\n      case ANCR_LOOK_BEHIND_NOT:\n        state |= IN_NOT;\n        /* fall */\n      case ANCR_PREC_READ:\n      case ANCR_LOOK_BEHIND:\n        setup_called_state_call(NODE_ANCHOR_BODY(an), state);\n        break;\n      default:\n        break;\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      if (en->type == BAG_MEMORY) {\n        if (NODE_IS_MARK1(node)) {\n          if ((~en->m.called_state & state) != 0) {\n            en->m.called_state |= state;\n            setup_called_state_call(NODE_BODY(node), state);\n          }\n        }\n        else {\n          NODE_STATUS_ADD(node, MARK1);\n          en->m.called_state |= state;\n          setup_called_state_call(NODE_BODY(node), state);\n          NODE_STATUS_REMOVE(node, MARK1);\n        }\n      }\n      else if (en->type == BAG_IF_ELSE) {\n        if (IS_NOT_NULL(en->te.Then)) {\n          setup_called_state_call(en->te.Then, state);\n        }\n        if (IS_NOT_NULL(en->te.Else))\n          setup_called_state_call(en->te.Else, state);\n      }\n      else {\n        setup_called_state_call(NODE_BODY(node), state);\n      }\n    }\n    break;\n\n  case NODE_CALL:\n    setup_called_state_call(NODE_BODY(node), state);\n    break;\n\n  default:\n    break;\n  }\n}\n\nstatic void\nsetup_called_state(Node* node, int state)\n{\n  switch (NODE_TYPE(node)) {\n  case NODE_ALT:\n    state |= IN_ALT;\n    /* fall */\n  case NODE_LIST:\n    do {\n      setup_called_state(NODE_CAR(node), state);\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    setup_called_state_call(node, state);\n    break;\n#endif\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      switch (en->type) {\n      case BAG_MEMORY:\n        if (en->m.entry_count > 1)\n          state |= IN_MULTI_ENTRY;\n\n        en->m.called_state |= state;\n        /* fall */\n      case BAG_OPTION:\n      case BAG_STOP_BACKTRACK:\n        setup_called_state(NODE_BODY(node), state);\n        break;\n      case BAG_IF_ELSE:\n        setup_called_state(NODE_BODY(node), state);\n        if (IS_NOT_NULL(en->te.Then))\n          setup_called_state(en->te.Then, state);\n        if (IS_NOT_NULL(en->te.Else))\n          setup_called_state(en->te.Else, state);\n        break;\n      }\n    }\n    break;\n\n  case NODE_QUANT:\n    {\n      QuantNode* qn = QUANT_(node);\n\n      if (IS_REPEAT_INFINITE(qn->upper) || qn->upper >= 2)\n        state |= IN_REAL_REPEAT;\n      if (qn->lower != qn->upper)\n        state |= IN_VAR_REPEAT;\n\n      setup_called_state(NODE_QUANT_BODY(qn), state);\n    }\n    break;\n\n  case NODE_ANCHOR:\n    {\n      AnchorNode* an = ANCHOR_(node);\n\n      switch (an->type) {\n      case ANCR_PREC_READ_NOT:\n      case ANCR_LOOK_BEHIND_NOT:\n        state |= IN_NOT;\n        /* fall */\n      case ANCR_PREC_READ:\n      case ANCR_LOOK_BEHIND:\n        setup_called_state(NODE_ANCHOR_BODY(an), state);\n        break;\n      default:\n        break;\n      }\n    }\n    break;\n\n  case NODE_BACKREF:\n  case NODE_STRING:\n  case NODE_CTYPE:\n  case NODE_CCLASS:\n  case NODE_GIMMICK:\n  default:\n    break;\n  }\n}\n\n#endif  /* USE_CALL */\n\n\nstatic int setup_tree(Node* node, regex_t* reg, int state, ScanEnv* env);\n\n#ifdef __GNUC__\n__inline\n#endif\nstatic int\nsetup_anchor(Node* node, regex_t* reg, int state, ScanEnv* env)\n{\n/* allowed node types in look-behind */\n#define ALLOWED_TYPE_IN_LB \\\n  ( NODE_BIT_LIST | NODE_BIT_ALT | NODE_BIT_STRING | NODE_BIT_CCLASS \\\n  | NODE_BIT_CTYPE | NODE_BIT_ANCHOR | NODE_BIT_BAG | NODE_BIT_QUANT \\\n  | NODE_BIT_CALL | NODE_BIT_GIMMICK)\n\n#define ALLOWED_BAG_IN_LB       ( 1<<BAG_MEMORY | 1<<BAG_OPTION | 1<<BAG_IF_ELSE )\n#define ALLOWED_BAG_IN_LB_NOT   ( 1<<BAG_OPTION | 1<<BAG_IF_ELSE )\n\n#define ALLOWED_ANCHOR_IN_LB \\\n  ( ANCR_LOOK_BEHIND | ANCR_BEGIN_LINE | ANCR_END_LINE | ANCR_BEGIN_BUF \\\n  | ANCR_BEGIN_POSITION | ANCR_WORD_BOUNDARY | ANCR_NO_WORD_BOUNDARY \\\n  | ANCR_WORD_BEGIN | ANCR_WORD_END \\\n  | ANCR_TEXT_SEGMENT_BOUNDARY | ANCR_NO_TEXT_SEGMENT_BOUNDARY )\n\n#define ALLOWED_ANCHOR_IN_LB_NOT \\\n  ( ANCR_LOOK_BEHIND | ANCR_LOOK_BEHIND_NOT | ANCR_BEGIN_LINE \\\n  | ANCR_END_LINE | ANCR_BEGIN_BUF | ANCR_BEGIN_POSITION | ANCR_WORD_BOUNDARY \\\n  | ANCR_NO_WORD_BOUNDARY | ANCR_WORD_BEGIN | ANCR_WORD_END \\\n  | ANCR_TEXT_SEGMENT_BOUNDARY | ANCR_NO_TEXT_SEGMENT_BOUNDARY )\n\n  int r;\n  AnchorNode* an = ANCHOR_(node);\n\n  switch (an->type) {\n  case ANCR_PREC_READ:\n    r = setup_tree(NODE_ANCHOR_BODY(an), reg, state, env);\n    break;\n  case ANCR_PREC_READ_NOT:\n    r = setup_tree(NODE_ANCHOR_BODY(an), reg, (state | IN_NOT), env);\n    break;\n\n  case ANCR_LOOK_BEHIND:\n    {\n      r = check_type_tree(NODE_ANCHOR_BODY(an), ALLOWED_TYPE_IN_LB,\n                          ALLOWED_BAG_IN_LB, ALLOWED_ANCHOR_IN_LB);\n      if (r < 0) return r;\n      if (r > 0) return ONIGERR_INVALID_LOOK_BEHIND_PATTERN;\n      r = setup_tree(NODE_ANCHOR_BODY(an), reg, (state|IN_LOOK_BEHIND), env);\n      if (r != 0) return r;\n      r = setup_look_behind(node, reg, env);\n    }\n    break;\n\n  case ANCR_LOOK_BEHIND_NOT:\n    {\n      r = check_type_tree(NODE_ANCHOR_BODY(an), ALLOWED_TYPE_IN_LB,\n                          ALLOWED_BAG_IN_LB_NOT, ALLOWED_ANCHOR_IN_LB_NOT);\n      if (r < 0) return r;\n      if (r > 0) return ONIGERR_INVALID_LOOK_BEHIND_PATTERN;\n      r = setup_tree(NODE_ANCHOR_BODY(an), reg, (state|IN_NOT|IN_LOOK_BEHIND),\n                     env);\n      if (r != 0) return r;\n      r = setup_look_behind(node, reg, env);\n    }\n    break;\n\n  default:\n    r = 0;\n    break;\n  }\n\n  return r;\n}\n\n#ifdef __GNUC__\n__inline\n#endif\nstatic int\nsetup_quant(Node* node, regex_t* reg, int state, ScanEnv* env)\n{\n  int r;\n  OnigLen d;\n  QuantNode* qn = QUANT_(node);\n  Node* body = NODE_BODY(node);\n\n  if ((state & IN_REAL_REPEAT) != 0) {\n    NODE_STATUS_ADD(node, IN_REAL_REPEAT);\n  }\n  if ((state & IN_MULTI_ENTRY) != 0) {\n    NODE_STATUS_ADD(node, IN_MULTI_ENTRY);\n  }\n\n  if (IS_REPEAT_INFINITE(qn->upper) || qn->upper >= 1) {\n    d = tree_min_len(body, env);\n    if (d == 0) {\n#ifdef USE_INSISTENT_CHECK_CAPTURES_IN_EMPTY_REPEAT\n      qn->empty_info = quantifiers_memory_node_info(body);\n      if (qn->empty_info == BODY_IS_EMPTY_REC) {\n        if (NODE_TYPE(body) == NODE_BAG &&\n            BAG_(body)->type == BAG_MEMORY) {\n          MEM_STATUS_ON(env->bt_mem_end, BAG_(body)->m.regnum);\n        }\n      }\n#else\n      qn->empty_info = BODY_IS_EMPTY;\n#endif\n    }\n  }\n\n  if (IS_REPEAT_INFINITE(qn->upper) || qn->upper >= 2)\n    state |= IN_REAL_REPEAT;\n  if (qn->lower != qn->upper)\n    state |= IN_VAR_REPEAT;\n\n  r = setup_tree(body, reg, state, env);\n  if (r != 0) return r;\n\n  /* expand string */\n#define EXPAND_STRING_MAX_LENGTH  100\n  if (NODE_TYPE(body) == NODE_STRING) {\n    if (!IS_REPEAT_INFINITE(qn->lower) && qn->lower == qn->upper &&\n        qn->lower > 1 && qn->lower <= EXPAND_STRING_MAX_LENGTH) {\n      int len = NODE_STRING_LEN(body);\n      StrNode* sn = STR_(body);\n\n      if (len * qn->lower <= EXPAND_STRING_MAX_LENGTH) {\n        int i, n = qn->lower;\n        onig_node_conv_to_str_node(node, STR_(body)->flag);\n        for (i = 0; i < n; i++) {\n          r = onig_node_str_cat(node, sn->s, sn->end);\n          if (r != 0) return r;\n        }\n        onig_node_free(body);\n        return r;\n      }\n    }\n  }\n\n  if (qn->greedy && (qn->empty_info == BODY_IS_NOT_EMPTY)) {\n    if (NODE_TYPE(body) == NODE_QUANT) {\n      QuantNode* tqn = QUANT_(body);\n      if (IS_NOT_NULL(tqn->head_exact)) {\n        qn->head_exact  = tqn->head_exact;\n        tqn->head_exact = NULL;\n      }\n    }\n    else {\n      qn->head_exact = get_head_value_node(NODE_BODY(node), 1, reg);\n    }\n  }\n\n  return r;\n}\n\n/* setup_tree does the following work.\n 1. check empty loop. (set qn->empty_info)\n 2. expand ignore-case in char class.\n 3. set memory status bit flags. (reg->mem_stats)\n 4. set qn->head_exact for [push, exact] -> [push_or_jump_exact1, exact].\n 5. find invalid patterns in look-behind.\n 6. expand repeated string.\n */\nstatic int\nsetup_tree(Node* node, regex_t* reg, int state, ScanEnv* env)\n{\n  int r = 0;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n    {\n      Node* prev = NULL_NODE;\n      do {\n        r = setup_tree(NODE_CAR(node), reg, state, env);\n        if (IS_NOT_NULL(prev) && r == 0) {\n          r = next_setup(prev, NODE_CAR(node), reg);\n        }\n        prev = NODE_CAR(node);\n      } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    }\n    break;\n\n  case NODE_ALT:\n    do {\n      r = setup_tree(NODE_CAR(node), reg, (state | IN_ALT), env);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_STRING:\n    if (IS_IGNORECASE(reg->options) && !NODE_STRING_IS_RAW(node)) {\n      r = expand_case_fold_string(node, reg, state);\n    }\n    break;\n\n  case NODE_BACKREF:\n    {\n      int i;\n      int* p;\n      BackRefNode* br = BACKREF_(node);\n      p = BACKREFS_P(br);\n      for (i = 0; i < br->back_num; i++) {\n        if (p[i] > env->num_mem)  return ONIGERR_INVALID_BACKREF;\n        MEM_STATUS_ON(env->backrefed_mem, p[i]);\n        MEM_STATUS_ON(env->bt_mem_start, p[i]);\n#ifdef USE_BACKREF_WITH_LEVEL\n        if (NODE_IS_NEST_LEVEL(node)) {\n          MEM_STATUS_ON(env->bt_mem_end, p[i]);\n        }\n#endif\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      switch (en->type) {\n      case BAG_OPTION:\n        {\n          OnigOptionType options = reg->options;\n          reg->options = BAG_(node)->o.options;\n          r = setup_tree(NODE_BODY(node), reg, state, env);\n          reg->options = options;\n        }\n        break;\n\n      case BAG_MEMORY:\n#ifdef USE_CALL\n        state |= en->m.called_state;\n#endif\n\n        if ((state & (IN_ALT | IN_NOT | IN_VAR_REPEAT | IN_MULTI_ENTRY)) != 0\n            || NODE_IS_RECURSION(node)) {\n          MEM_STATUS_ON(env->bt_mem_start, en->m.regnum);\n        }\n        r = setup_tree(NODE_BODY(node), reg, state, env);\n        break;\n\n      case BAG_STOP_BACKTRACK:\n        {\n          Node* target = NODE_BODY(node);\n          r = setup_tree(target, reg, state, env);\n          if (NODE_TYPE(target) == NODE_QUANT) {\n            QuantNode* tqn = QUANT_(target);\n            if (IS_REPEAT_INFINITE(tqn->upper) && tqn->lower <= 1 &&\n                tqn->greedy != 0) {  /* (?>a*), a*+ etc... */\n              if (NODE_IS_SIMPLE_TYPE(NODE_BODY(target)))\n                NODE_STATUS_ADD(node, STOP_BT_SIMPLE_REPEAT);\n            }\n          }\n        }\n        break;\n\n      case BAG_IF_ELSE:\n        r = setup_tree(NODE_BODY(node), reg, (state | IN_ALT), env);\n        if (r != 0) return r;\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = setup_tree(en->te.Then, reg, (state | IN_ALT), env);\n          if (r != 0) return r;\n        }\n        if (IS_NOT_NULL(en->te.Else))\n          r = setup_tree(en->te.Else, reg, (state | IN_ALT), env);\n        break;\n      }\n    }\n    break;\n\n  case NODE_QUANT:\n    r = setup_quant(node, reg, state, env);\n    break;\n\n  case NODE_ANCHOR:\n    r = setup_anchor(node, reg, state, env);\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n#endif\n  case NODE_CTYPE:\n  case NODE_CCLASS:\n  case NODE_GIMMICK:\n  default:\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nset_sunday_quick_search_or_bmh_skip_table(regex_t* reg, int case_expand,\n                                          UChar* s, UChar* end,\n                                          UChar skip[], int* roffset)\n{\n  int i, j, k, len, offset;\n  int n, clen;\n  UChar* p;\n  OnigEncoding enc;\n  OnigCaseFoldCodeItem items[ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM];\n  UChar buf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n  enc = reg->enc;\n  offset = ENC_GET_SKIP_OFFSET(enc);\n  if (offset == ENC_SKIP_OFFSET_1_OR_0) {\n    UChar* p = s;\n    while (1) {\n      len = enclen(enc, p);\n      if (p + len >= end) {\n        if (len == 1) offset = 1;\n        else          offset = 0;\n        break;\n      }\n      p += len;\n    }\n  }\n\n  len = (int )(end - s);\n  if (len + offset >= UCHAR_MAX)\n    return ONIGERR_PARSER_BUG;\n\n  *roffset = offset;\n\n  for (i = 0; i < CHAR_MAP_SIZE; i++) {\n    skip[i] = (UChar )(len + offset);\n  }\n\n  for (p = s; p < end; ) {\n    int z;\n\n    clen = enclen(enc, p);\n    if (p + clen > end) clen = (int )(end - p);\n\n    len = (int )(end - p);\n    for (j = 0; j < clen; j++) {\n      z = len - j + (offset - 1);\n      if (z <= 0) break;\n      skip[p[j]] = z;\n    }\n\n    if (case_expand != 0) {\n      n = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(enc, reg->case_fold_flag,\n                                             p, end, items);\n      for (k = 0; k < n; k++) {\n        ONIGENC_CODE_TO_MBC(enc, items[k].code[0], buf);\n        for (j = 0; j < clen; j++) {\n          z = len - j + (offset - 1);\n          if (z <= 0) break;\n          if (skip[buf[j]] > z)\n            skip[buf[j]] = z;\n        }\n      }\n    }\n\n    p += clen;\n  }\n\n  return 0;\n}\n\n\n#define OPT_EXACT_MAXLEN   24\n\n#if OPT_EXACT_MAXLEN >= UCHAR_MAX\n#error Too big OPT_EXACT_MAXLEN\n#endif\n\ntypedef struct {\n  OnigLen min;  /* min byte length */\n  OnigLen max;  /* max byte length */\n} MinMax;\n\ntypedef struct {\n  MinMax           mmd;\n  OnigEncoding     enc;\n  OnigOptionType   options;\n  OnigCaseFoldType case_fold_flag;\n  ScanEnv*         scan_env;\n} OptEnv;\n\ntypedef struct {\n  int left;\n  int right;\n} OptAnc;\n\ntypedef struct {\n  MinMax     mmd;   /* position */\n  OptAnc     anc;\n  int        reach_end;\n  int        case_fold;\n  int        good_case_fold;\n  int        len;\n  UChar      s[OPT_EXACT_MAXLEN];\n} OptStr;\n\ntypedef struct {\n  MinMax    mmd;    /* position */\n  OptAnc    anc;\n  int       value;  /* weighted value */\n  UChar     map[CHAR_MAP_SIZE];\n} OptMap;\n\ntypedef struct {\n  MinMax  len;\n  OptAnc  anc;\n  OptStr  sb;     /* boundary */\n  OptStr  sm;     /* middle */\n  OptStr  spr;    /* prec read (?=...) */\n  OptMap  map;    /* boundary */\n} OptNode;\n\n\nstatic int\nmap_position_value(OnigEncoding enc, int i)\n{\n  static const short int Vals[] = {\n     5,  1,  1,  1,  1,  1,  1,  1,  1, 10, 10,  1,  1, 10,  1,  1,\n     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n    12,  4,  7,  4,  4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  5,  5,\n     6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  5,  5,  5,  5,  5,  5,\n     5,  6,  6,  6,  6,  7,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n     6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  5,  6,  5,  5,  5,\n     5,  6,  6,  6,  6,  7,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n     6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  5,  5,  5,  5,  1\n  };\n\n  if (i < (int )(sizeof(Vals)/sizeof(Vals[0]))) {\n    if (i == 0 && ONIGENC_MBC_MINLEN(enc) > 1)\n      return 20;\n    else\n      return (int )Vals[i];\n  }\n  else\n    return 4;   /* Take it easy. */\n}\n\nstatic int\ndistance_value(MinMax* mm)\n{\n  /* 1000 / (min-max-dist + 1) */\n  static const short int dist_vals[] = {\n    1000,  500,  333,  250,  200,  167,  143,  125,  111,  100,\n      91,   83,   77,   71,   67,   63,   59,   56,   53,   50,\n      48,   45,   43,   42,   40,   38,   37,   36,   34,   33,\n      32,   31,   30,   29,   29,   28,   27,   26,   26,   25,\n      24,   24,   23,   23,   22,   22,   21,   21,   20,   20,\n      20,   19,   19,   19,   18,   18,   18,   17,   17,   17,\n      16,   16,   16,   16,   15,   15,   15,   15,   14,   14,\n      14,   14,   14,   14,   13,   13,   13,   13,   13,   13,\n      12,   12,   12,   12,   12,   12,   11,   11,   11,   11,\n      11,   11,   11,   11,   11,   10,   10,   10,   10,   10\n  };\n\n  OnigLen d;\n\n  if (mm->max == INFINITE_LEN) return 0;\n\n  d = mm->max - mm->min;\n  if (d < (OnigLen )(sizeof(dist_vals)/sizeof(dist_vals[0])))\n    /* return dist_vals[d] * 16 / (mm->min + 12); */\n    return (int )dist_vals[d];\n  else\n    return 1;\n}\n\nstatic int\ncomp_distance_value(MinMax* d1, MinMax* d2, int v1, int v2)\n{\n  if (v2 <= 0) return -1;\n  if (v1 <= 0) return  1;\n\n  v1 *= distance_value(d1);\n  v2 *= distance_value(d2);\n\n  if (v2 > v1) return  1;\n  if (v2 < v1) return -1;\n\n  if (d2->min < d1->min) return  1;\n  if (d2->min > d1->min) return -1;\n  return 0;\n}\n\nstatic int\nis_equal_mml(MinMax* a, MinMax* b)\n{\n  return a->min == b->min && a->max == b->max;\n}\n\nstatic void\nset_mml(MinMax* l, OnigLen min, OnigLen max)\n{\n  l->min = min;\n  l->max = max;\n}\n\nstatic void\nclear_mml(MinMax* l)\n{\n  l->min = l->max = 0;\n}\n\nstatic void\ncopy_mml(MinMax* to, MinMax* from)\n{\n  to->min = from->min;\n  to->max = from->max;\n}\n\nstatic void\nadd_mml(MinMax* to, MinMax* from)\n{\n  to->min = distance_add(to->min, from->min);\n  to->max = distance_add(to->max, from->max);\n}\n\nstatic void\nalt_merge_mml(MinMax* to, MinMax* from)\n{\n  if (to->min > from->min) to->min = from->min;\n  if (to->max < from->max) to->max = from->max;\n}\n\nstatic void\ncopy_opt_env(OptEnv* to, OptEnv* from)\n{\n  *to = *from;\n}\n\nstatic void\nclear_opt_anc_info(OptAnc* a)\n{\n  a->left  = 0;\n  a->right = 0;\n}\n\nstatic void\ncopy_opt_anc_info(OptAnc* to, OptAnc* from)\n{\n  *to = *from;\n}\n\nstatic void\nconcat_opt_anc_info(OptAnc* to, OptAnc* left, OptAnc* right,\n                    OnigLen left_len, OnigLen right_len)\n{\n  clear_opt_anc_info(to);\n\n  to->left = left->left;\n  if (left_len == 0) {\n    to->left |= right->left;\n  }\n\n  to->right = right->right;\n  if (right_len == 0) {\n    to->right |= left->right;\n  }\n  else {\n    to->right |= (left->right & ANCR_PREC_READ_NOT);\n  }\n}\n\nstatic int\nis_left(int a)\n{\n  if (a == ANCR_END_BUF  || a == ANCR_SEMI_END_BUF ||\n      a == ANCR_END_LINE || a == ANCR_PREC_READ || a == ANCR_PREC_READ_NOT)\n    return 0;\n\n  return 1;\n}\n\nstatic int\nis_set_opt_anc_info(OptAnc* to, int anc)\n{\n  if ((to->left & anc) != 0) return 1;\n\n  return ((to->right & anc) != 0 ? 1 : 0);\n}\n\nstatic void\nadd_opt_anc_info(OptAnc* to, int anc)\n{\n  if (is_left(anc))\n    to->left |= anc;\n  else\n    to->right |= anc;\n}\n\nstatic void\nremove_opt_anc_info(OptAnc* to, int anc)\n{\n  if (is_left(anc))\n    to->left &= ~anc;\n  else\n    to->right &= ~anc;\n}\n\nstatic void\nalt_merge_opt_anc_info(OptAnc* to, OptAnc* add)\n{\n  to->left  &= add->left;\n  to->right &= add->right;\n}\n\nstatic int\nis_full_opt_exact(OptStr* e)\n{\n  return e->len >= OPT_EXACT_MAXLEN;\n}\n\nstatic void\nclear_opt_exact(OptStr* e)\n{\n  clear_mml(&e->mmd);\n  clear_opt_anc_info(&e->anc);\n  e->reach_end      = 0;\n  e->case_fold      = 0;\n  e->good_case_fold = 0;\n  e->len            = 0;\n  e->s[0]           = '\\0';\n}\n\nstatic void\ncopy_opt_exact(OptStr* to, OptStr* from)\n{\n  *to = *from;\n}\n\nstatic int\nconcat_opt_exact(OptStr* to, OptStr* add, OnigEncoding enc)\n{\n  int i, j, len, r;\n  UChar *p, *end;\n  OptAnc tanc;\n\n  if (add->case_fold != 0) {\n    if (! to->case_fold) {\n      if (to->len > 1 || to->len >= add->len) return 0;  /* avoid */\n\n      to->case_fold = 1;\n    }\n    else {\n      if (to->good_case_fold != 0) {\n        if (add->good_case_fold == 0) return 0;\n      }\n    }\n  }\n\n  r = 0;\n  p = add->s;\n  end = p + add->len;\n  for (i = to->len; p < end; ) {\n    len = enclen(enc, p);\n    if (i + len > OPT_EXACT_MAXLEN) {\n      r = 1; /* 1:full */\n      break;\n    }\n    for (j = 0; j < len && p < end; j++)\n      to->s[i++] = *p++;\n  }\n\n  to->len = i;\n  to->reach_end = (p == end ? add->reach_end : 0);\n\n  concat_opt_anc_info(&tanc, &to->anc, &add->anc, 1, 1);\n  if (! to->reach_end) tanc.right = 0;\n  copy_opt_anc_info(&to->anc, &tanc);\n\n  return r;\n}\n\nstatic void\nconcat_opt_exact_str(OptStr* to, UChar* s, UChar* end, OnigEncoding enc)\n{\n  int i, j, len;\n  UChar *p;\n\n  for (i = to->len, p = s; p < end && i < OPT_EXACT_MAXLEN; ) {\n    len = enclen(enc, p);\n    if (i + len > OPT_EXACT_MAXLEN) break;\n    for (j = 0; j < len && p < end; j++)\n      to->s[i++] = *p++;\n  }\n\n  to->len = i;\n\n  if (p >= end && to->len == (int )(end - s))\n    to->reach_end = 1;\n}\n\nstatic void\nalt_merge_opt_exact(OptStr* to, OptStr* add, OptEnv* env)\n{\n  int i, j, len;\n\n  if (add->len == 0 || to->len == 0) {\n    clear_opt_exact(to);\n    return ;\n  }\n\n  if (! is_equal_mml(&to->mmd, &add->mmd)) {\n    clear_opt_exact(to);\n    return ;\n  }\n\n  for (i = 0; i < to->len && i < add->len; ) {\n    if (to->s[i] != add->s[i]) break;\n    len = enclen(env->enc, to->s + i);\n\n    for (j = 1; j < len; j++) {\n      if (to->s[i+j] != add->s[i+j]) break;\n    }\n    if (j < len) break;\n    i += len;\n  }\n\n  if (! add->reach_end || i < add->len || i < to->len) {\n    to->reach_end = 0;\n  }\n  to->len = i;\n  if (add->case_fold != 0)\n    to->case_fold = 1;\n  if (add->good_case_fold == 0)\n    to->good_case_fold = 0;\n\n  alt_merge_opt_anc_info(&to->anc, &add->anc);\n  if (! to->reach_end) to->anc.right = 0;\n}\n\nstatic void\nselect_opt_exact(OnigEncoding enc, OptStr* now, OptStr* alt)\n{\n  int vn, va;\n\n  vn = now->len;\n  va = alt->len;\n\n  if (va == 0) {\n    return ;\n  }\n  else if (vn == 0) {\n    copy_opt_exact(now, alt);\n    return ;\n  }\n  else if (vn <= 2 && va <= 2) {\n    /* ByteValTable[x] is big value --> low price */\n    va = map_position_value(enc, now->s[0]);\n    vn = map_position_value(enc, alt->s[0]);\n\n    if (now->len > 1) vn += 5;\n    if (alt->len > 1) va += 5;\n  }\n\n  if (now->case_fold == 0) vn *= 2;\n  if (alt->case_fold == 0) va *= 2;\n\n  if (now->good_case_fold != 0) vn *= 4;\n  if (alt->good_case_fold != 0) va *= 4;\n\n  if (comp_distance_value(&now->mmd, &alt->mmd, vn, va) > 0)\n    copy_opt_exact(now, alt);\n}\n\nstatic void\nclear_opt_map(OptMap* map)\n{\n  static const OptMap clean_info = {\n    {0, 0}, {0, 0}, 0,\n    {\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    }\n  };\n\n  xmemcpy(map, &clean_info, sizeof(OptMap));\n}\n\nstatic void\ncopy_opt_map(OptMap* to, OptMap* from)\n{\n  *to = *from;\n}\n\nstatic void\nadd_char_opt_map(OptMap* m, UChar c, OnigEncoding enc)\n{\n  if (m->map[c] == 0) {\n    m->map[c] = 1;\n    m->value += map_position_value(enc, c);\n  }\n}\n\nstatic int\nadd_char_amb_opt_map(OptMap* map, UChar* p, UChar* end,\n                     OnigEncoding enc, OnigCaseFoldType fold_flag)\n{\n  OnigCaseFoldCodeItem items[ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM];\n  UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n  int i, n;\n\n  add_char_opt_map(map, p[0], enc);\n\n  fold_flag = DISABLE_CASE_FOLD_MULTI_CHAR(fold_flag);\n  n = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(enc, fold_flag, p, end, items);\n  if (n < 0) return n;\n\n  for (i = 0; i < n; i++) {\n    ONIGENC_CODE_TO_MBC(enc, items[i].code[0], buf);\n    add_char_opt_map(map, buf[0], enc);\n  }\n\n  return 0;\n}\n\nstatic void\nselect_opt_map(OptMap* now, OptMap* alt)\n{\n  static int z = 1<<15; /* 32768: something big value */\n\n  int vn, va;\n\n  if (alt->value == 0) return ;\n  if (now->value == 0) {\n    copy_opt_map(now, alt);\n    return ;\n  }\n\n  vn = z / now->value;\n  va = z / alt->value;\n  if (comp_distance_value(&now->mmd, &alt->mmd, vn, va) > 0)\n    copy_opt_map(now, alt);\n}\n\nstatic int\ncomp_opt_exact_or_map(OptStr* e, OptMap* m)\n{\n#define COMP_EM_BASE  20\n  int ae, am;\n  int case_value;\n\n  if (m->value <= 0) return -1;\n\n  if (e->case_fold != 0) {\n    if (e->good_case_fold != 0)\n      case_value = 2;\n    else\n      case_value = 1;\n  }\n  else\n    case_value = 3;\n\n  ae = COMP_EM_BASE * e->len * case_value;\n  am = COMP_EM_BASE * 5 * 2 / m->value;\n  return comp_distance_value(&e->mmd, &m->mmd, ae, am);\n}\n\nstatic void\nalt_merge_opt_map(OnigEncoding enc, OptMap* to, OptMap* add)\n{\n  int i, val;\n\n  /* if (! is_equal_mml(&to->mmd, &add->mmd)) return ; */\n  if (to->value == 0) return ;\n  if (add->value == 0 || to->mmd.max < add->mmd.min) {\n    clear_opt_map(to);\n    return ;\n  }\n\n  alt_merge_mml(&to->mmd, &add->mmd);\n\n  val = 0;\n  for (i = 0; i < CHAR_MAP_SIZE; i++) {\n    if (add->map[i])\n      to->map[i] = 1;\n\n    if (to->map[i])\n      val += map_position_value(enc, i);\n  }\n  to->value = val;\n\n  alt_merge_opt_anc_info(&to->anc, &add->anc);\n}\n\nstatic void\nset_bound_node_opt_info(OptNode* opt, MinMax* plen)\n{\n  copy_mml(&(opt->sb.mmd),  plen);\n  copy_mml(&(opt->spr.mmd), plen);\n  copy_mml(&(opt->map.mmd), plen);\n}\n\nstatic void\nclear_node_opt_info(OptNode* opt)\n{\n  clear_mml(&opt->len);\n  clear_opt_anc_info(&opt->anc);\n  clear_opt_exact(&opt->sb);\n  clear_opt_exact(&opt->sm);\n  clear_opt_exact(&opt->spr);\n  clear_opt_map(&opt->map);\n}\n\nstatic void\ncopy_node_opt_info(OptNode* to, OptNode* from)\n{\n  *to = *from;\n}\n\nstatic void\nconcat_left_node_opt_info(OnigEncoding enc, OptNode* to, OptNode* add)\n{\n  int sb_reach, sm_reach;\n  OptAnc tanc;\n\n  concat_opt_anc_info(&tanc, &to->anc, &add->anc, to->len.max, add->len.max);\n  copy_opt_anc_info(&to->anc, &tanc);\n\n  if (add->sb.len > 0 && to->len.max == 0) {\n    concat_opt_anc_info(&tanc, &to->anc, &add->sb.anc, to->len.max, add->len.max);\n    copy_opt_anc_info(&add->sb.anc, &tanc);\n  }\n\n  if (add->map.value > 0 && to->len.max == 0) {\n    if (add->map.mmd.max == 0)\n      add->map.anc.left |= to->anc.left;\n  }\n\n  sb_reach = to->sb.reach_end;\n  sm_reach = to->sm.reach_end;\n\n  if (add->len.max != 0)\n    to->sb.reach_end = to->sm.reach_end = 0;\n\n  if (add->sb.len > 0) {\n    if (sb_reach) {\n      concat_opt_exact(&to->sb, &add->sb, enc);\n      clear_opt_exact(&add->sb);\n    }\n    else if (sm_reach) {\n      concat_opt_exact(&to->sm, &add->sb, enc);\n      clear_opt_exact(&add->sb);\n    }\n  }\n  select_opt_exact(enc, &to->sm, &add->sb);\n  select_opt_exact(enc, &to->sm, &add->sm);\n\n  if (to->spr.len > 0) {\n    if (add->len.max > 0) {\n      if (to->spr.len > (int )add->len.max)\n        to->spr.len = add->len.max;\n\n      if (to->spr.mmd.max == 0)\n        select_opt_exact(enc, &to->sb, &to->spr);\n      else\n        select_opt_exact(enc, &to->sm, &to->spr);\n    }\n  }\n  else if (add->spr.len > 0) {\n    copy_opt_exact(&to->spr, &add->spr);\n  }\n\n  select_opt_map(&to->map, &add->map);\n  add_mml(&to->len, &add->len);\n}\n\nstatic void\nalt_merge_node_opt_info(OptNode* to, OptNode* add, OptEnv* env)\n{\n  alt_merge_opt_anc_info(&to->anc, &add->anc);\n  alt_merge_opt_exact(&to->sb,  &add->sb, env);\n  alt_merge_opt_exact(&to->sm,  &add->sm, env);\n  alt_merge_opt_exact(&to->spr, &add->spr, env);\n  alt_merge_opt_map(env->enc, &to->map, &add->map);\n\n  alt_merge_mml(&to->len, &add->len);\n}\n\n\n#define MAX_NODE_OPT_INFO_REF_COUNT    5\n\nstatic int\noptimize_nodes(Node* node, OptNode* opt, OptEnv* env)\n{\n  int i;\n  int r;\n  OptNode xo;\n  OnigEncoding enc;\n\n  r = 0;\n  enc = env->enc;\n  clear_node_opt_info(opt);\n  set_bound_node_opt_info(opt, &env->mmd);\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n    {\n      OptEnv nenv;\n      Node* nd = node;\n\n      copy_opt_env(&nenv, env);\n      do {\n        r = optimize_nodes(NODE_CAR(nd), &xo, &nenv);\n        if (r == 0) {\n          add_mml(&nenv.mmd, &xo.len);\n          concat_left_node_opt_info(enc, opt, &xo);\n        }\n      } while (r == 0 && IS_NOT_NULL(nd = NODE_CDR(nd)));\n    }\n    break;\n\n  case NODE_ALT:\n    {\n      Node* nd = node;\n\n      do {\n        r = optimize_nodes(NODE_CAR(nd), &xo, env);\n        if (r == 0) {\n          if (nd == node) copy_node_opt_info(opt, &xo);\n          else            alt_merge_node_opt_info(opt, &xo, env);\n        }\n      } while ((r == 0) && IS_NOT_NULL(nd = NODE_CDR(nd)));\n    }\n    break;\n\n  case NODE_STRING:\n    {\n      StrNode* sn = STR_(node);\n      int slen = (int )(sn->end - sn->s);\n      /* int is_raw = NODE_STRING_IS_RAW(node); */\n\n      if (! NODE_STRING_IS_AMBIG(node)) {\n        concat_opt_exact_str(&opt->sb, sn->s, sn->end, enc);\n        if (slen > 0) {\n          add_char_opt_map(&opt->map, *(sn->s), enc);\n        }\n        set_mml(&opt->len, slen, slen);\n      }\n      else {\n        int max;\n\n        if (NODE_STRING_IS_DONT_GET_OPT_INFO(node)) {\n          int n = onigenc_strlen(enc, sn->s, sn->end);\n          max = ONIGENC_MBC_MAXLEN_DIST(enc) * n;\n        }\n        else {\n          concat_opt_exact_str(&opt->sb, sn->s, sn->end, enc);\n          opt->sb.case_fold = 1;\n          if (NODE_STRING_IS_GOOD_AMBIG(node))\n            opt->sb.good_case_fold = 1;\n\n          if (slen > 0) {\n            r = add_char_amb_opt_map(&opt->map, sn->s, sn->end,\n                                     enc, env->case_fold_flag);\n            if (r != 0) break;\n          }\n\n          max = slen;\n        }\n\n        set_mml(&opt->len, slen, max);\n      }\n    }\n    break;\n\n  case NODE_CCLASS:\n    {\n      int z;\n      CClassNode* cc = CCLASS_(node);\n\n      /* no need to check ignore case. (set in setup_tree()) */\n\n      if (IS_NOT_NULL(cc->mbuf) || IS_NCCLASS_NOT(cc)) {\n        OnigLen min = ONIGENC_MBC_MINLEN(enc);\n        OnigLen max = ONIGENC_MBC_MAXLEN_DIST(enc);\n\n        set_mml(&opt->len, min, max);\n      }\n      else {\n        for (i = 0; i < SINGLE_BYTE_SIZE; i++) {\n          z = BITSET_AT(cc->bs, i);\n          if ((z && ! IS_NCCLASS_NOT(cc)) || (! z && IS_NCCLASS_NOT(cc))) {\n            add_char_opt_map(&opt->map, (UChar )i, enc);\n          }\n        }\n        set_mml(&opt->len, 1, 1);\n      }\n    }\n    break;\n\n  case NODE_CTYPE:\n    {\n      int min, max;\n      int range;\n\n      max = ONIGENC_MBC_MAXLEN_DIST(enc);\n\n      if (max == 1) {\n        min = 1;\n\n        switch (CTYPE_(node)->ctype) {\n        case CTYPE_ANYCHAR:\n          break;\n\n        case ONIGENC_CTYPE_WORD:\n          range = CTYPE_(node)->ascii_mode != 0 ? 128 : SINGLE_BYTE_SIZE;\n          if (CTYPE_(node)->not != 0) {\n            for (i = 0; i < range; i++) {\n              if (! ONIGENC_IS_CODE_WORD(enc, i)) {\n                add_char_opt_map(&opt->map, (UChar )i, enc);\n              }\n            }\n            for (i = range; i < SINGLE_BYTE_SIZE; i++) {\n              add_char_opt_map(&opt->map, (UChar )i, enc);\n            }\n          }\n          else {\n            for (i = 0; i < range; i++) {\n              if (ONIGENC_IS_CODE_WORD(enc, i)) {\n                add_char_opt_map(&opt->map, (UChar )i, enc);\n              }\n            }\n          }\n          break;\n        }\n      }\n      else {\n        min = ONIGENC_MBC_MINLEN(enc);\n      }\n      set_mml(&opt->len, min, max);\n    }\n    break;\n\n  case NODE_ANCHOR:\n    switch (ANCHOR_(node)->type) {\n    case ANCR_BEGIN_BUF:\n    case ANCR_BEGIN_POSITION:\n    case ANCR_BEGIN_LINE:\n    case ANCR_END_BUF:\n    case ANCR_SEMI_END_BUF:\n    case ANCR_END_LINE:\n    case ANCR_PREC_READ_NOT:\n    case ANCR_LOOK_BEHIND:\n      add_opt_anc_info(&opt->anc, ANCHOR_(node)->type);\n      break;\n\n    case ANCR_PREC_READ:\n      {\n        r = optimize_nodes(NODE_BODY(node), &xo, env);\n        if (r == 0) {\n          if (xo.sb.len > 0)\n            copy_opt_exact(&opt->spr, &xo.sb);\n          else if (xo.sm.len > 0)\n            copy_opt_exact(&opt->spr, &xo.sm);\n\n          opt->spr.reach_end = 0;\n\n          if (xo.map.value > 0)\n            copy_opt_map(&opt->map, &xo.map);\n        }\n      }\n      break;\n\n    case ANCR_LOOK_BEHIND_NOT:\n      break;\n    }\n    break;\n\n  case NODE_BACKREF:\n    if (! NODE_IS_CHECKER(node)) {\n      int* backs;\n      OnigLen min, max, tmin, tmax;\n      MemEnv* mem_env = SCANENV_MEMENV(env->scan_env);\n      BackRefNode* br = BACKREF_(node);\n\n      if (NODE_IS_RECURSION(node)) {\n        set_mml(&opt->len, 0, INFINITE_LEN);\n        break;\n      }\n      backs = BACKREFS_P(br);\n      min = tree_min_len(mem_env[backs[0]].node, env->scan_env);\n      max = tree_max_len(mem_env[backs[0]].node, env->scan_env);\n      for (i = 1; i < br->back_num; i++) {\n        tmin = tree_min_len(mem_env[backs[i]].node, env->scan_env);\n        tmax = tree_max_len(mem_env[backs[i]].node, env->scan_env);\n        if (min > tmin) min = tmin;\n        if (max < tmax) max = tmax;\n      }\n      set_mml(&opt->len, min, max);\n    }\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    if (NODE_IS_RECURSION(node))\n      set_mml(&opt->len, 0, INFINITE_LEN);\n    else {\n      OnigOptionType save = env->options;\n      env->options = BAG_(NODE_BODY(node))->o.options;\n      r = optimize_nodes(NODE_BODY(node), opt, env);\n      env->options = save;\n    }\n    break;\n#endif\n\n  case NODE_QUANT:\n    {\n      OnigLen min, max;\n      QuantNode* qn = QUANT_(node);\n\n      r = optimize_nodes(NODE_BODY(node), &xo, env);\n      if (r != 0) break;\n\n      if (qn->lower > 0) {\n        copy_node_opt_info(opt, &xo);\n        if (xo.sb.len > 0) {\n          if (xo.sb.reach_end) {\n            for (i = 2; i <= qn->lower && ! is_full_opt_exact(&opt->sb); i++) {\n              int rc = concat_opt_exact(&opt->sb, &xo.sb, enc);\n              if (rc > 0) break;\n            }\n            if (i < qn->lower) opt->sb.reach_end = 0;\n          }\n        }\n\n        if (qn->lower != qn->upper) {\n          opt->sb.reach_end = 0;\n          opt->sm.reach_end = 0;\n        }\n        if (qn->lower > 1)\n          opt->sm.reach_end = 0;\n      }\n\n      if (IS_REPEAT_INFINITE(qn->upper)) {\n        if (env->mmd.max == 0 &&\n            NODE_IS_ANYCHAR(NODE_BODY(node)) && qn->greedy != 0) {\n          if (IS_MULTILINE(CTYPE_OPTION(NODE_QUANT_BODY(qn), env)))\n            add_opt_anc_info(&opt->anc, ANCR_ANYCHAR_INF_ML);\n          else\n            add_opt_anc_info(&opt->anc, ANCR_ANYCHAR_INF);\n        }\n\n        max = (xo.len.max > 0 ? INFINITE_LEN : 0);\n      }\n      else {\n        max = distance_multiply(xo.len.max, qn->upper);\n      }\n\n      min = distance_multiply(xo.len.min, qn->lower);\n      set_mml(&opt->len, min, max);\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      switch (en->type) {\n      case BAG_OPTION:\n        {\n          OnigOptionType save = env->options;\n\n          env->options = en->o.options;\n          r = optimize_nodes(NODE_BODY(node), opt, env);\n          env->options = save;\n        }\n        break;\n\n      case BAG_MEMORY:\n#ifdef USE_CALL\n        en->opt_count++;\n        if (en->opt_count > MAX_NODE_OPT_INFO_REF_COUNT) {\n          OnigLen min, max;\n\n          min = 0;\n          max = INFINITE_LEN;\n          if (NODE_IS_MIN_FIXED(node)) min = en->min_len;\n          if (NODE_IS_MAX_FIXED(node)) max = en->max_len;\n          set_mml(&opt->len, min, max);\n        }\n        else\n#endif\n          {\n            r = optimize_nodes(NODE_BODY(node), opt, env);\n            if (is_set_opt_anc_info(&opt->anc, ANCR_ANYCHAR_INF_MASK)) {\n              if (MEM_STATUS_AT0(env->scan_env->backrefed_mem, en->m.regnum))\n                remove_opt_anc_info(&opt->anc, ANCR_ANYCHAR_INF_MASK);\n            }\n          }\n        break;\n\n      case BAG_STOP_BACKTRACK:\n        r = optimize_nodes(NODE_BODY(node), opt, env);\n        break;\n\n      case BAG_IF_ELSE:\n        {\n          OptEnv nenv;\n\n          copy_opt_env(&nenv, env);\n          r = optimize_nodes(NODE_BAG_BODY(en), &xo, &nenv);\n          if (r == 0) {\n            add_mml(&nenv.mmd, &xo.len);\n            concat_left_node_opt_info(enc, opt, &xo);\n            if (IS_NOT_NULL(en->te.Then)) {\n              r = optimize_nodes(en->te.Then, &xo, &nenv);\n              if (r == 0) {\n                concat_left_node_opt_info(enc, opt, &xo);\n              }\n            }\n\n            if (IS_NOT_NULL(en->te.Else)) {\n              r = optimize_nodes(en->te.Else, &xo, env);\n              if (r == 0)\n                alt_merge_node_opt_info(opt, &xo, env);\n            }\n          }\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_GIMMICK:\n    break;\n\n  default:\n#ifdef ONIG_DEBUG\n    fprintf(stderr, \"optimize_nodes: undefined node type %d\\n\", NODE_TYPE(node));\n#endif\n    r = ONIGERR_TYPE_BUG;\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nset_optimize_exact(regex_t* reg, OptStr* e)\n{\n  int r;\n\n  if (e->len == 0) return 0;\n\n  reg->exact = (UChar* )xmalloc(e->len);\n  CHECK_NULL_RETURN_MEMERR(reg->exact);\n  xmemcpy(reg->exact, e->s, e->len);\n  reg->exact_end = reg->exact + e->len;\n\n  if (e->case_fold) {\n    reg->optimize = OPTIMIZE_STR_CASE_FOLD;\n    if (e->good_case_fold != 0) {\n      if (e->len >= 2) {\n        r = set_sunday_quick_search_or_bmh_skip_table(reg, 1,\n                             reg->exact, reg->exact_end,\n                             reg->map, &(reg->map_offset));\n        if (r != 0) return r;\n        reg->optimize = OPTIMIZE_STR_CASE_FOLD_FAST;\n      }\n    }\n  }\n  else {\n    int allow_reverse;\n\n    allow_reverse =\n      ONIGENC_IS_ALLOWED_REVERSE_MATCH(reg->enc, reg->exact, reg->exact_end);\n\n    if (e->len >= 2 || (e->len >= 1 && allow_reverse)) {\n      r = set_sunday_quick_search_or_bmh_skip_table(reg, 0,\n                                         reg->exact, reg->exact_end,\n                                         reg->map, &(reg->map_offset));\n      if (r != 0) return r;\n\n      reg->optimize = (allow_reverse != 0\n                       ? OPTIMIZE_STR_FAST\n                       : OPTIMIZE_STR_FAST_STEP_FORWARD);\n    }\n    else {\n      reg->optimize = OPTIMIZE_STR;\n    }\n  }\n\n  reg->dmin = e->mmd.min;\n  reg->dmax = e->mmd.max;\n\n  if (reg->dmin != INFINITE_LEN) {\n    reg->threshold_len = reg->dmin + (int )(reg->exact_end - reg->exact);\n  }\n\n  return 0;\n}\n\nstatic void\nset_optimize_map(regex_t* reg, OptMap* m)\n{\n  int i;\n\n  for (i = 0; i < CHAR_MAP_SIZE; i++)\n    reg->map[i] = m->map[i];\n\n  reg->optimize   = OPTIMIZE_MAP;\n  reg->dmin       = m->mmd.min;\n  reg->dmax       = m->mmd.max;\n\n  if (reg->dmin != INFINITE_LEN) {\n    reg->threshold_len = reg->dmin + 1;\n  }\n}\n\nstatic void\nset_sub_anchor(regex_t* reg, OptAnc* anc)\n{\n  reg->sub_anchor |= anc->left  & ANCR_BEGIN_LINE;\n  reg->sub_anchor |= anc->right & ANCR_END_LINE;\n}\n\n#if defined(ONIG_DEBUG_COMPILE) || defined(ONIG_DEBUG_MATCH)\nstatic void print_optimize_info(FILE* f, regex_t* reg);\n#endif\n\nstatic int\nset_optimize_info_from_tree(Node* node, regex_t* reg, ScanEnv* scan_env)\n{\n  int r;\n  OptNode opt;\n  OptEnv env;\n\n  env.enc            = reg->enc;\n  env.options        = reg->options;\n  env.case_fold_flag = reg->case_fold_flag;\n  env.scan_env       = scan_env;\n  clear_mml(&env.mmd);\n\n  r = optimize_nodes(node, &opt, &env);\n  if (r != 0) return r;\n\n  reg->anchor = opt.anc.left & (ANCR_BEGIN_BUF |\n        ANCR_BEGIN_POSITION | ANCR_ANYCHAR_INF | ANCR_ANYCHAR_INF_ML |\n        ANCR_LOOK_BEHIND);\n\n  if ((opt.anc.left & (ANCR_LOOK_BEHIND | ANCR_PREC_READ_NOT)) != 0)\n    reg->anchor &= ~ANCR_ANYCHAR_INF_ML;\n\n  reg->anchor |= opt.anc.right & (ANCR_END_BUF | ANCR_SEMI_END_BUF |\n                                  ANCR_PREC_READ_NOT);\n\n  if (reg->anchor & (ANCR_END_BUF | ANCR_SEMI_END_BUF)) {\n    reg->anchor_dmin = opt.len.min;\n    reg->anchor_dmax = opt.len.max;\n  }\n\n  if (opt.sb.len > 0 || opt.sm.len > 0) {\n    select_opt_exact(reg->enc, &opt.sb, &opt.sm);\n    if (opt.map.value > 0 && comp_opt_exact_or_map(&opt.sb, &opt.map) > 0) {\n      goto set_map;\n    }\n    else {\n      r = set_optimize_exact(reg, &opt.sb);\n      set_sub_anchor(reg, &opt.sb.anc);\n    }\n  }\n  else if (opt.map.value > 0) {\n  set_map:\n    set_optimize_map(reg, &opt.map);\n    set_sub_anchor(reg, &opt.map.anc);\n  }\n  else {\n    reg->sub_anchor |= opt.anc.left & ANCR_BEGIN_LINE;\n    if (opt.len.max == 0)\n      reg->sub_anchor |= opt.anc.right & ANCR_END_LINE;\n  }\n\n#if defined(ONIG_DEBUG_COMPILE) || defined(ONIG_DEBUG_MATCH)\n  print_optimize_info(stderr, reg);\n#endif\n  return r;\n}\n\nstatic void\nclear_optimize_info(regex_t* reg)\n{\n  reg->optimize      = OPTIMIZE_NONE;\n  reg->anchor        = 0;\n  reg->anchor_dmin   = 0;\n  reg->anchor_dmax   = 0;\n  reg->sub_anchor    = 0;\n  reg->exact_end     = (UChar* )NULL;\n  reg->map_offset    = 0;\n  reg->threshold_len = 0;\n  if (IS_NOT_NULL(reg->exact)) {\n    xfree(reg->exact);\n    reg->exact = (UChar* )NULL;\n  }\n}\n\n#ifdef ONIG_DEBUG\n\nstatic void print_enc_string(FILE* fp, OnigEncoding enc,\n                             const UChar *s, const UChar *end)\n{\n  fprintf(fp, \"\\nPATTERN: /\");\n\n  if (ONIGENC_MBC_MINLEN(enc) > 1) {\n    const UChar *p;\n    OnigCodePoint code;\n\n    p = s;\n    while (p < end) {\n      code = ONIGENC_MBC_TO_CODE(enc, p, end);\n      if (code >= 0x80) {\n        fprintf(fp, \" 0x%04x \", (int )code);\n      }\n      else {\n        fputc((int )code, fp);\n      }\n\n      p += enclen(enc, p);\n    }\n  }\n  else {\n    while (s < end) {\n      fputc((int )*s, fp);\n      s++;\n    }\n  }\n\n  fprintf(fp, \"/\\n\");\n}\n\n#endif /* ONIG_DEBUG */\n\n#if defined(ONIG_DEBUG_COMPILE) || defined(ONIG_DEBUG_MATCH)\n\nstatic void\nprint_distance_range(FILE* f, OnigLen a, OnigLen b)\n{\n  if (a == INFINITE_LEN)\n    fputs(\"inf\", f);\n  else\n    fprintf(f, \"(%u)\", a);\n\n  fputs(\"-\", f);\n\n  if (b == INFINITE_LEN)\n    fputs(\"inf\", f);\n  else\n    fprintf(f, \"(%u)\", b);\n}\n\nstatic void\nprint_anchor(FILE* f, int anchor)\n{\n  int q = 0;\n\n  fprintf(f, \"[\");\n\n  if (anchor & ANCR_BEGIN_BUF) {\n    fprintf(f, \"begin-buf\");\n    q = 1;\n  }\n  if (anchor & ANCR_BEGIN_LINE) {\n    if (q) fprintf(f, \", \");\n    q = 1;\n    fprintf(f, \"begin-line\");\n  }\n  if (anchor & ANCR_BEGIN_POSITION) {\n    if (q) fprintf(f, \", \");\n    q = 1;\n    fprintf(f, \"begin-pos\");\n  }\n  if (anchor & ANCR_END_BUF) {\n    if (q) fprintf(f, \", \");\n    q = 1;\n    fprintf(f, \"end-buf\");\n  }\n  if (anchor & ANCR_SEMI_END_BUF) {\n    if (q) fprintf(f, \", \");\n    q = 1;\n    fprintf(f, \"semi-end-buf\");\n  }\n  if (anchor & ANCR_END_LINE) {\n    if (q) fprintf(f, \", \");\n    q = 1;\n    fprintf(f, \"end-line\");\n  }\n  if (anchor & ANCR_ANYCHAR_INF) {\n    if (q) fprintf(f, \", \");\n    q = 1;\n    fprintf(f, \"anychar-inf\");\n  }\n  if (anchor & ANCR_ANYCHAR_INF_ML) {\n    if (q) fprintf(f, \", \");\n    fprintf(f, \"anychar-inf-ml\");\n  }\n\n  fprintf(f, \"]\");\n}\n\nstatic void\nprint_optimize_info(FILE* f, regex_t* reg)\n{\n  static const char* on[] = { \"NONE\", \"STR\",\n                              \"STR_FAST\", \"STR_FAST_STEP_FORWARD\",\n                              \"STR_CASE_FOLD_FAST\", \"STR_CASE_FOLD\", \"MAP\" };\n\n  fprintf(f, \"optimize: %s\\n\", on[reg->optimize]);\n  fprintf(f, \"  anchor: \"); print_anchor(f, reg->anchor);\n  if ((reg->anchor & ANCR_END_BUF_MASK) != 0)\n    print_distance_range(f, reg->anchor_dmin, reg->anchor_dmax);\n  fprintf(f, \"\\n\");\n\n  if (reg->optimize) {\n    fprintf(f, \"  sub anchor: \"); print_anchor(f, reg->sub_anchor);\n    fprintf(f, \"\\n\");\n  }\n  fprintf(f, \"\\n\");\n\n  if (reg->exact) {\n    UChar *p;\n    fprintf(f, \"exact: [\");\n    for (p = reg->exact; p < reg->exact_end; p++) {\n      fputc(*p, f);\n    }\n    fprintf(f, \"]: length: %ld\\n\", (reg->exact_end - reg->exact));\n  }\n  else if (reg->optimize & OPTIMIZE_MAP) {\n    int c, i, n = 0;\n\n    for (i = 0; i < CHAR_MAP_SIZE; i++)\n      if (reg->map[i]) n++;\n\n    fprintf(f, \"map: n=%d\\n\", n);\n    if (n > 0) {\n      c = 0;\n      fputc('[', f);\n      for (i = 0; i < CHAR_MAP_SIZE; i++) {\n        if (reg->map[i] != 0) {\n          if (c > 0)  fputs(\", \", f);\n          c++;\n          if (ONIGENC_MBC_MAXLEN(reg->enc) == 1 &&\n              ONIGENC_IS_CODE_PRINT(reg->enc, (OnigCodePoint )i))\n            fputc(i, f);\n          else\n            fprintf(f, \"%d\", i);\n        }\n      }\n      fprintf(f, \"]\\n\");\n    }\n  }\n}\n#endif\n\n\nextern RegexExt*\nonig_get_regex_ext(regex_t* reg)\n{\n  if (IS_NULL(reg->extp)) {\n    RegexExt* ext = (RegexExt* )xmalloc(sizeof(*ext));\n    if (IS_NULL(ext)) return 0;\n\n    ext->pattern      = 0;\n    ext->pattern_end  = 0;\n#ifdef USE_CALLOUT\n    ext->tag_table    = 0;\n    ext->callout_num  = 0;\n    ext->callout_list_alloc = 0;\n    ext->callout_list = 0;\n#endif\n\n    reg->extp = ext;\n  }\n\n  return reg->extp;\n}\n\nstatic void\nfree_regex_ext(RegexExt* ext)\n{\n  if (IS_NOT_NULL(ext)) {\n    if (IS_NOT_NULL(ext->pattern))\n      xfree((void* )ext->pattern);\n\n#ifdef USE_CALLOUT\n    if (IS_NOT_NULL(ext->tag_table))\n      onig_callout_tag_table_free(ext->tag_table);\n\n    if (IS_NOT_NULL(ext->callout_list))\n      onig_free_reg_callout_list(ext->callout_num, ext->callout_list);\n#endif\n\n    xfree(ext);\n  }\n}\n\nextern int\nonig_ext_set_pattern(regex_t* reg, const UChar* pattern, const UChar* pattern_end)\n{\n  RegexExt* ext;\n  UChar* s;\n\n  ext = onig_get_regex_ext(reg);\n  CHECK_NULL_RETURN_MEMERR(ext);\n\n  s = onigenc_strdup(reg->enc, pattern, pattern_end);\n  CHECK_NULL_RETURN_MEMERR(s);\n\n  ext->pattern     = s;\n  ext->pattern_end = s + (pattern_end - pattern);\n\n  return ONIG_NORMAL;\n}\n\nextern void\nonig_free_body(regex_t* reg)\n{\n  if (IS_NOT_NULL(reg)) {\n    ops_free(reg);\n    if (IS_NOT_NULL(reg->string_pool)) {\n      xfree(reg->string_pool);\n      reg->string_pool_end = reg->string_pool = 0;\n    }\n    if (IS_NOT_NULL(reg->exact))            xfree(reg->exact);\n    if (IS_NOT_NULL(reg->repeat_range))     xfree(reg->repeat_range);\n    if (IS_NOT_NULL(reg->extp)) {\n      free_regex_ext(reg->extp);\n      reg->extp = 0;\n    }\n\n    onig_names_free(reg);\n  }\n}\n\nextern void\nonig_free(regex_t* reg)\n{\n  if (IS_NOT_NULL(reg)) {\n    onig_free_body(reg);\n    xfree(reg);\n  }\n}\n\n\n#ifdef ONIG_DEBUG_PARSE\nstatic void print_tree P_((FILE* f, Node* node));\n#endif\n\nextern int onig_init_for_match_at(regex_t* reg);\n\nextern int\nonig_compile(regex_t* reg, const UChar* pattern, const UChar* pattern_end,\n             OnigErrorInfo* einfo)\n{\n  int r;\n  Node*  root;\n  ScanEnv  scan_env;\n#ifdef USE_CALL\n  UnsetAddrList  uslist;\n#endif\n\n  root = 0;\n  if (IS_NOT_NULL(einfo)) {\n    einfo->enc = reg->enc;\n    einfo->par = (UChar* )NULL;\n  }\n\n#ifdef ONIG_DEBUG\n  print_enc_string(stderr, reg->enc, pattern, pattern_end);\n#endif\n\n  if (reg->ops_alloc == 0) {\n    r = ops_init(reg, OPS_INIT_SIZE);\n    if (r != 0) goto end;\n  }\n  else\n    reg->ops_used = 0;\n\n  reg->string_pool        = 0;\n  reg->string_pool_end    = 0;\n  reg->num_mem            = 0;\n  reg->num_repeat         = 0;\n  reg->num_null_check     = 0;\n  reg->repeat_range_alloc = 0;\n  reg->repeat_range       = (OnigRepeatRange* )NULL;\n\n  r = onig_parse_tree(&root, pattern, pattern_end, reg, &scan_env);\n  if (r != 0) goto err;\n\n  /* mixed use named group and no-named group */\n  if (scan_env.num_named > 0 &&\n      IS_SYNTAX_BV(scan_env.syntax, ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP) &&\n      ! ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_CAPTURE_GROUP)) {\n    if (scan_env.num_named != scan_env.num_mem)\n      r = disable_noname_group_capture(&root, reg, &scan_env);\n    else\n      r = numbered_ref_check(root);\n\n    if (r != 0) goto err;\n  }\n\n  r = check_backrefs(root, &scan_env);\n  if (r != 0) goto err;\n\n#ifdef USE_CALL\n  if (scan_env.num_call > 0) {\n    r = unset_addr_list_init(&uslist, scan_env.num_call);\n    if (r != 0) goto err;\n    scan_env.unset_addr_list = &uslist;\n    r = setup_call(root, &scan_env, 0);\n    if (r != 0) goto err_unset;\n    r = setup_call2(root);\n    if (r != 0) goto err_unset;\n    r = recursive_call_check_trav(root, &scan_env, 0);\n    if (r  < 0) goto err_unset;\n    r = infinite_recursive_call_check_trav(root, &scan_env);\n    if (r != 0) goto err_unset;\n\n    setup_called_state(root, 0);\n  }\n\n  reg->num_call = scan_env.num_call;\n#endif\n\n  r = setup_tree(root, reg, 0, &scan_env);\n  if (r != 0) goto err_unset;\n\n#ifdef ONIG_DEBUG_PARSE\n  print_tree(stderr, root);\n#endif\n\n  reg->capture_history  = scan_env.capture_history;\n  reg->bt_mem_start     = scan_env.bt_mem_start;\n  reg->bt_mem_start    |= reg->capture_history;\n  if (IS_FIND_CONDITION(reg->options))\n    MEM_STATUS_ON_ALL(reg->bt_mem_end);\n  else {\n    reg->bt_mem_end  = scan_env.bt_mem_end;\n    reg->bt_mem_end |= reg->capture_history;\n  }\n  reg->bt_mem_start |= reg->bt_mem_end;\n\n  clear_optimize_info(reg);\n#ifndef ONIG_DONT_OPTIMIZE\n  r = set_optimize_info_from_tree(root, reg, &scan_env);\n  if (r != 0) goto err_unset;\n#endif\n\n  if (IS_NOT_NULL(scan_env.mem_env_dynamic)) {\n    xfree(scan_env.mem_env_dynamic);\n    scan_env.mem_env_dynamic = (MemEnv* )NULL;\n  }\n\n  r = compile_tree(root, reg, &scan_env);\n  if (r == 0) {\n    if (scan_env.keep_num > 0) {\n      r = add_op(reg, OP_UPDATE_VAR);\n      if (r != 0) goto err;\n\n      COP(reg)->update_var.type = UPDATE_VAR_KEEP_FROM_STACK_LAST;\n      COP(reg)->update_var.id   = 0; /* not used */\n    }\n\n    r = add_op(reg, OP_END);\n    if (r != 0) goto err;\n\n#ifdef USE_CALL\n    if (scan_env.num_call > 0) {\n      r = fix_unset_addr_list(&uslist, reg);\n      unset_addr_list_end(&uslist);\n      if (r != 0) goto err;\n    }\n#endif\n\n    if ((reg->num_repeat != 0) || (reg->bt_mem_end != 0)\n#ifdef USE_CALLOUT\n        || (IS_NOT_NULL(reg->extp) && reg->extp->callout_num != 0)\n#endif\n        )\n      reg->stack_pop_level = STACK_POP_LEVEL_ALL;\n    else {\n      if (reg->bt_mem_start != 0)\n        reg->stack_pop_level = STACK_POP_LEVEL_MEM_START;\n      else\n        reg->stack_pop_level = STACK_POP_LEVEL_FREE;\n    }\n\n    r = ops_make_string_pool(reg);\n    if (r != 0) goto err;\n  }\n#ifdef USE_CALL\n  else if (scan_env.num_call > 0) {\n    unset_addr_list_end(&uslist);\n  }\n#endif\n  onig_node_free(root);\n\n#ifdef ONIG_DEBUG_COMPILE\n  onig_print_names(stderr, reg);\n  onig_print_compiled_byte_code_list(stderr, reg);\n#endif\n\n#ifdef USE_DIRECT_THREADED_CODE\n  /* opcode -> opaddr */\n  onig_init_for_match_at(reg);\n#endif\n\n end:\n  return r;\n\n err_unset:\n#ifdef USE_CALL\n  if (scan_env.num_call > 0) {\n    unset_addr_list_end(&uslist);\n  }\n#endif\n err:\n  if (IS_NOT_NULL(scan_env.error)) {\n    if (IS_NOT_NULL(einfo)) {\n      einfo->par     = scan_env.error;\n      einfo->par_end = scan_env.error_end;\n    }\n  }\n\n  onig_node_free(root);\n  if (IS_NOT_NULL(scan_env.mem_env_dynamic))\n      xfree(scan_env.mem_env_dynamic);\n  return r;\n}\n\n\nstatic int onig_inited = 0;\n\nextern int\nonig_reg_init(regex_t* reg, OnigOptionType option, OnigCaseFoldType case_fold_flag,\n              OnigEncoding enc, OnigSyntaxType* syntax)\n{\n  int r;\n\n  xmemset(reg, 0, sizeof(*reg));\n\n  if (onig_inited == 0) {\n#if 0\n    return ONIGERR_LIBRARY_IS_NOT_INITIALIZED;\n#else\n    r = onig_initialize(&enc, 1);\n    if (r != 0)\n      return ONIGERR_FAIL_TO_INITIALIZE;\n\n    onig_warning(\"You didn't call onig_initialize() explicitly\");\n#endif\n  }\n\n  if (IS_NULL(reg))\n    return ONIGERR_INVALID_ARGUMENT;\n\n  if (ONIGENC_IS_UNDEF(enc))\n    return ONIGERR_DEFAULT_ENCODING_IS_NOT_SETTED;\n\n  if ((option & (ONIG_OPTION_DONT_CAPTURE_GROUP|ONIG_OPTION_CAPTURE_GROUP))\n      == (ONIG_OPTION_DONT_CAPTURE_GROUP|ONIG_OPTION_CAPTURE_GROUP)) {\n    return ONIGERR_INVALID_COMBINATION_OF_OPTIONS;\n  }\n\n  if ((option & ONIG_OPTION_NEGATE_SINGLELINE) != 0) {\n    option |= syntax->options;\n    option &= ~ONIG_OPTION_SINGLELINE;\n  }\n  else\n    option |= syntax->options;\n\n  (reg)->enc              = enc;\n  (reg)->options          = option;\n  (reg)->syntax           = syntax;\n  (reg)->optimize         = 0;\n  (reg)->exact            = (UChar* )NULL;\n  (reg)->extp             = (RegexExt* )NULL;\n\n  (reg)->ops              = (Operation* )NULL;\n  (reg)->ops_curr         = (Operation* )NULL;\n  (reg)->ops_used         = 0;\n  (reg)->ops_alloc        = 0;\n  (reg)->name_table       = (void* )NULL;\n\n  (reg)->case_fold_flag   = case_fold_flag;\n  return 0;\n}\n\nextern int\nonig_new_without_alloc(regex_t* reg,\n                       const UChar* pattern, const UChar* pattern_end,\n                       OnigOptionType option, OnigEncoding enc,\n                       OnigSyntaxType* syntax, OnigErrorInfo* einfo)\n{\n  int r;\n\n  r = onig_reg_init(reg, option, ONIGENC_CASE_FOLD_DEFAULT, enc, syntax);\n  if (r != 0) return r;\n\n  r = onig_compile(reg, pattern, pattern_end, einfo);\n  return r;\n}\n\nextern int\nonig_new(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n         OnigOptionType option, OnigEncoding enc, OnigSyntaxType* syntax,\n         OnigErrorInfo* einfo)\n{\n  int r;\n\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) return ONIGERR_MEMORY;\n\n  r = onig_reg_init(*reg, option, ONIGENC_CASE_FOLD_DEFAULT, enc, syntax);\n  if (r != 0) goto err;\n\n  r = onig_compile(*reg, pattern, pattern_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n  return r;\n}\n\nextern int\nonig_initialize(OnigEncoding encodings[], int n)\n{\n  int i;\n  int r;\n\n  if (onig_inited != 0)\n    return 0;\n\n  onigenc_init();\n\n  onig_inited = 1;\n\n  for (i = 0; i < n; i++) {\n    OnigEncoding enc = encodings[i];\n    r = onig_initialize_encoding(enc);\n    if (r != 0)\n      return r;\n  }\n\n  return ONIG_NORMAL;\n}\n\ntypedef struct EndCallListItem {\n  struct EndCallListItem* next;\n  void (*func)(void);\n} EndCallListItemType;\n\nstatic EndCallListItemType* EndCallTop;\n\nextern void onig_add_end_call(void (*func)(void))\n{\n  EndCallListItemType* item;\n\n  item = (EndCallListItemType* )xmalloc(sizeof(*item));\n  if (item == 0) return ;\n\n  item->next = EndCallTop;\n  item->func = func;\n\n  EndCallTop = item;\n}\n\nstatic void\nexec_end_call_list(void)\n{\n  EndCallListItemType* prev;\n  void (*func)(void);\n\n  while (EndCallTop != 0) {\n    func = EndCallTop->func;\n    (*func)();\n\n    prev = EndCallTop;\n    EndCallTop = EndCallTop->next;\n    xfree(prev);\n  }\n}\n\nextern int\nonig_end(void)\n{\n  exec_end_call_list();\n\n#ifdef USE_CALLOUT\n  onig_global_callout_names_free();\n#endif\n\n  onigenc_end();\n\n  onig_inited = 0;\n\n  return 0;\n}\n\nextern int\nonig_is_in_code_range(const UChar* p, OnigCodePoint code)\n{\n  OnigCodePoint n, *data;\n  OnigCodePoint low, high, x;\n\n  GET_CODE_POINT(n, p);\n  data = (OnigCodePoint* )p;\n  data++;\n\n  for (low = 0, high = n; low < high; ) {\n    x = (low + high) >> 1;\n    if (code > data[x * 2 + 1])\n      low = x + 1;\n    else\n      high = x;\n  }\n\n  return ((low < n && code >= data[low * 2]) ? 1 : 0);\n}\n\nextern int\nonig_is_code_in_cc_len(int elen, OnigCodePoint code, /* CClassNode* */ void* cc_arg)\n{\n  int found;\n  CClassNode* cc = (CClassNode* )cc_arg;\n\n  if (elen > 1 || (code >= SINGLE_BYTE_SIZE)) {\n    if (IS_NULL(cc->mbuf)) {\n      found = 0;\n    }\n    else {\n      found = onig_is_in_code_range(cc->mbuf->p, code) != 0;\n    }\n  }\n  else {\n    found = BITSET_AT(cc->bs, code) != 0;\n  }\n\n  if (IS_NCCLASS_NOT(cc))\n    return !found;\n  else\n    return found;\n}\n\nextern int\nonig_is_code_in_cc(OnigEncoding enc, OnigCodePoint code, CClassNode* cc)\n{\n  int len;\n\n  if (ONIGENC_MBC_MINLEN(enc) > 1) {\n    len = 2;\n  }\n  else {\n    len = ONIGENC_CODE_TO_MBCLEN(enc, code);\n  }\n  return onig_is_code_in_cc_len(len, code, cc);\n}\n\n\n#ifdef ONIG_DEBUG_PARSE\n\nstatic void\np_string(FILE* f, int len, UChar* s)\n{\n  fputs(\":\", f);\n  while (len-- > 0) { fputc(*s++, f); }\n}\n\nstatic void\nIndent(FILE* f, int indent)\n{\n  int i;\n  for (i = 0; i < indent; i++) putc(' ', f);\n}\n\nstatic void\nprint_indent_tree(FILE* f, Node* node, int indent)\n{\n  int i;\n  NodeType type;\n  UChar* p;\n  int add = 3;\n\n  Indent(f, indent);\n  if (IS_NULL(node)) {\n    fprintf(f, \"ERROR: null node!!!\\n\");\n    exit (0);\n  }\n\n  type = NODE_TYPE(node);\n  switch (type) {\n  case NODE_LIST:\n  case NODE_ALT:\n    if (type == NODE_LIST)\n      fprintf(f, \"<list:%p>\\n\", node);\n    else\n      fprintf(f, \"<alt:%p>\\n\", node);\n\n    print_indent_tree(f, NODE_CAR(node), indent + add);\n    while (IS_NOT_NULL(node = NODE_CDR(node))) {\n      if (NODE_TYPE(node) != type) {\n        fprintf(f, \"ERROR: list/alt right is not a cons. %d\\n\", NODE_TYPE(node));\n        exit(0);\n      }\n      print_indent_tree(f, NODE_CAR(node), indent + add);\n    }\n    break;\n\n  case NODE_STRING:\n    {\n      char* mode;\n      char* dont;\n      char* good;\n\n      if (NODE_STRING_IS_RAW(node))\n        mode = \"-raw\";\n      else if (NODE_STRING_IS_AMBIG(node))\n        mode = \"-ambig\";\n      else\n        mode = \"\";\n\n      if (NODE_STRING_IS_GOOD_AMBIG(node))\n        good = \"-good\";\n      else\n        good = \"\";\n\n      if (NODE_STRING_IS_DONT_GET_OPT_INFO(node))\n        dont = \" (dont-opt)\";\n      else\n        dont = \"\";\n\n      fprintf(f, \"<string%s%s%s:%p>\", mode, good, dont, node);\n      for (p = STR_(node)->s; p < STR_(node)->end; p++) {\n        if (*p >= 0x20 && *p < 0x7f)\n          fputc(*p, f);\n        else {\n          fprintf(f, \" 0x%02x\", *p);\n        }\n      }\n    }\n    break;\n\n  case NODE_CCLASS:\n    fprintf(f, \"<cclass:%p>\", node);\n    if (IS_NCCLASS_NOT(CCLASS_(node))) fputs(\" not\", f);\n    if (CCLASS_(node)->mbuf) {\n      BBuf* bbuf = CCLASS_(node)->mbuf;\n      for (i = 0; i < bbuf->used; i++) {\n        if (i > 0) fprintf(f, \",\");\n        fprintf(f, \"%0x\", bbuf->p[i]);\n      }\n    }\n    break;\n\n  case NODE_CTYPE:\n    fprintf(f, \"<ctype:%p> \", node);\n    switch (CTYPE_(node)->ctype) {\n    case CTYPE_ANYCHAR:\n      fprintf(f, \"<anychar:%p>\", node);\n      break;\n\n    case ONIGENC_CTYPE_WORD:\n      if (CTYPE_(node)->not != 0)\n        fputs(\"not word\", f);\n      else\n        fputs(\"word\",     f);\n\n      if (CTYPE_(node)->ascii_mode != 0)\n        fputs(\" (ascii)\", f);\n\n      break;\n\n    default:\n      fprintf(f, \"ERROR: undefined ctype.\\n\");\n      exit(0);\n    }\n    break;\n\n  case NODE_ANCHOR:\n    fprintf(f, \"<anchor:%p> \", node);\n    switch (ANCHOR_(node)->type) {\n    case ANCR_BEGIN_BUF:        fputs(\"begin buf\",      f); break;\n    case ANCR_END_BUF:          fputs(\"end buf\",        f); break;\n    case ANCR_BEGIN_LINE:       fputs(\"begin line\",     f); break;\n    case ANCR_END_LINE:         fputs(\"end line\",       f); break;\n    case ANCR_SEMI_END_BUF:     fputs(\"semi end buf\",   f); break;\n    case ANCR_BEGIN_POSITION:   fputs(\"begin position\", f); break;\n\n    case ANCR_WORD_BOUNDARY:    fputs(\"word boundary\",     f); break;\n    case ANCR_NO_WORD_BOUNDARY: fputs(\"not word boundary\", f); break;\n#ifdef USE_WORD_BEGIN_END\n    case ANCR_WORD_BEGIN:       fputs(\"word begin\", f);     break;\n    case ANCR_WORD_END:         fputs(\"word end\", f);       break;\n#endif\n    case ANCR_TEXT_SEGMENT_BOUNDARY:\n      fputs(\"text-segment boundary\", f); break;\n    case ANCR_NO_TEXT_SEGMENT_BOUNDARY:\n      fputs(\"no text-segment boundary\", f); break;\n    case ANCR_PREC_READ:\n      fprintf(f, \"prec read\\n\");\n      print_indent_tree(f, NODE_BODY(node), indent + add);\n      break;\n    case ANCR_PREC_READ_NOT:\n      fprintf(f, \"prec read not\\n\");\n      print_indent_tree(f, NODE_BODY(node), indent + add);\n      break;\n    case ANCR_LOOK_BEHIND:\n      fprintf(f, \"look behind\\n\");\n      print_indent_tree(f, NODE_BODY(node), indent + add);\n      break;\n    case ANCR_LOOK_BEHIND_NOT:\n      fprintf(f, \"look behind not\\n\");\n      print_indent_tree(f, NODE_BODY(node), indent + add);\n      break;\n\n    default:\n      fprintf(f, \"ERROR: undefined anchor type.\\n\");\n      break;\n    }\n    break;\n\n  case NODE_BACKREF:\n    {\n      int* p;\n      BackRefNode* br = BACKREF_(node);\n      p = BACKREFS_P(br);\n      fprintf(f, \"<backref%s:%p>\", NODE_IS_CHECKER(node) ? \"-checker\" : \"\", node);\n      for (i = 0; i < br->back_num; i++) {\n        if (i > 0) fputs(\", \", f);\n        fprintf(f, \"%d\", p[i]);\n      }\n    }\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    {\n      CallNode* cn = CALL_(node);\n      fprintf(f, \"<call:%p>\", node);\n      p_string(f, cn->name_end - cn->name, cn->name);\n    }\n    break;\n#endif\n\n  case NODE_QUANT:\n    fprintf(f, \"<quantifier:%p>{%d,%d}%s\\n\", node,\n            QUANT_(node)->lower, QUANT_(node)->upper,\n            (QUANT_(node)->greedy ? \"\" : \"?\"));\n    print_indent_tree(f, NODE_BODY(node), indent + add);\n    break;\n\n  case NODE_BAG:\n    fprintf(f, \"<bag:%p> \", node);\n    switch (BAG_(node)->type) {\n    case BAG_OPTION:\n      fprintf(f, \"option:%d\", BAG_(node)->o.options);\n      break;\n    case BAG_MEMORY:\n      fprintf(f, \"memory:%d\", BAG_(node)->m.regnum);\n      break;\n    case BAG_STOP_BACKTRACK:\n      fprintf(f, \"stop-bt\");\n      break;\n    case BAG_IF_ELSE:\n      fprintf(f, \"if-else\");\n      break;\n    }\n    fprintf(f, \"\\n\");\n    print_indent_tree(f, NODE_BODY(node), indent + add);\n    break;\n\n  case NODE_GIMMICK:\n    fprintf(f, \"<gimmick:%p> \", node);\n    switch (GIMMICK_(node)->type) {\n    case GIMMICK_FAIL:\n      fprintf(f, \"fail\");\n      break;\n    case GIMMICK_SAVE:\n      fprintf(f, \"save:%d:%d\", GIMMICK_(node)->detail_type, GIMMICK_(node)->id);\n      break;\n    case GIMMICK_UPDATE_VAR:\n      fprintf(f, \"update_var:%d:%d\", GIMMICK_(node)->detail_type, GIMMICK_(node)->id);\n      break;\n#ifdef USE_CALLOUT\n    case GIMMICK_CALLOUT:\n      switch (GIMMICK_(node)->detail_type) {\n      case ONIG_CALLOUT_OF_CONTENTS:\n        fprintf(f, \"callout:contents:%d\", GIMMICK_(node)->num);\n        break;\n      case ONIG_CALLOUT_OF_NAME:\n        fprintf(f, \"callout:name:%d:%d\", GIMMICK_(node)->id, GIMMICK_(node)->num);\n        break;\n      }\n#endif\n    }\n    break;\n\n  default:\n    fprintf(f, \"print_indent_tree: undefined node type %d\\n\", NODE_TYPE(node));\n    break;\n  }\n\n  if (type != NODE_LIST && type != NODE_ALT && type != NODE_QUANT &&\n      type != NODE_BAG)\n    fprintf(f, \"\\n\");\n  fflush(f);\n}\n\nstatic void\nprint_tree(FILE* f, Node* node)\n{\n  print_indent_tree(f, node, 0);\n}\n#endif\n"], "filenames": ["src/regcomp.c"], "buggy_code_start_loc": [1309], "buggy_code_end_loc": [1498], "fixing_code_start_loc": [1310], "fixing_code_end_loc": [1507], "type": "CWE-476", "message": "A NULL Pointer Dereference in match_at() in regexec.c in Oniguruma 6.9.2 allows attackers to potentially cause denial of service by providing a crafted regular expression. Oniguruma issues often affect Ruby, as well as common optional libraries for PHP and Rust.", "other": {"cve": {"id": "CVE-2019-13225", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-10T14:15:11.700", "lastModified": "2019-12-16T20:23:00.310", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A NULL Pointer Dereference in match_at() in regexec.c in Oniguruma 6.9.2 allows attackers to potentially cause denial of service by providing a crafted regular expression. Oniguruma issues often affect Ruby, as well as common optional libraries for PHP and Rust."}, {"lang": "es", "value": "Una desreferencia de puntero NULL en la funci\u00f3n match_at() en el archivo regexec.c en Oniguruma versi\u00f3n 6.9.2, permite a los atacantes causar potencialmente una denegaci\u00f3n de servicio al proporcionar una expresi\u00f3n regular dise\u00f1ada. Los problemas de Oniguruma con frecuencia afectan a Ruby, as\u00ed como a bibliotecas opcionales y comunes para PHP y Rust."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oniguruma_project:oniguruma:6.9.2:-:*:*:*:*:*:*", "matchCriteriaId": "E22B1C2B-F272-4F96-9B84-09CDA15AA5D7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:29:*:*:*:*:*:*:*", "matchCriteriaId": "D100F7CE-FC64-4CC6-852A-6136D72DA419"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}]}]}], "references": [{"url": "https://github.com/kkos/oniguruma/commit/c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JWCPDTZOIUKGMFAD5NAKUB7FPJFAIQN5/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/SNL26OZSQRVLEO6JRNUVIMZTICXBNEQW/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201911-03", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/kkos/oniguruma/commit/c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c"}}