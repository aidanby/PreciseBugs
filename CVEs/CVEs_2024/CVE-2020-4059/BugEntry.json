{"buggy_code": ["var contra = require('contra'),\n    path = require('path'),\n    fUtils = require('./files'),\n    cp = require('child_process');\n\nvar gitApp = 'git', gitExtra = { env: process.env };\n\n\nvar escapeQuotes = function (str) {\n  if (typeof str === 'string') {\n    return str.replace(/([\"$`\\\\])/g, '\\\\$1');\n  } else {\n    return str;\n  }\n};\n\nmodule.exports.isRepositoryClean = function (callback) {\n  cp.exec(gitApp + ' ' + [ 'ls-files', '-m' ].join(' '), gitExtra, function (er, stdout, stderr) {\n    // makeCommit parly inspired and taken from NPM version module\n    var lines = stdout.trim().split('\\n').filter(function (line) {\n      var file = path.basename(line.replace(/.{1,2}\\s+/, ''));\n      return line.trim() && !line.match(/^\\?\\? /) && !fUtils.isPackageFile(line);\n    }).map(function (line) {\n      return line.trim()\n    });\n\n    if (lines.length) {\n      return callback(new Error('Git working directory not clean.\\n'+lines.join('\\n')));\n    }\n    return callback();\n  });\n};\n\nmodule.exports.checkout = function (callback) {\n  cp.exec(gitApp + ' checkout -- .', gitExtra, callback);\n};\n\nmodule.exports.commit = function (files, message, newVer, tagName, callback) {\n  message = message.replace('%s', newVer).replace('\"', '').replace(\"'\", '');\n  files = files.map(function (file) {\n    return '\"' + escapeQuotes(file) + '\"';\n  }).join(' ');\n  var functionSeries = [\n    function (done) {\n      cp.exec(gitApp + ' add ' + files, gitExtra, done);\n    },\n\n    function (done) {\n      cp.exec([gitApp, 'commit', '-m', '\"' + message + '\"'].join(' '), gitExtra, done);\n    },\n\n    function (done) {\n      cp.exec(\n        [\n          gitApp, 'tag', '-a', tagName, '-m', '\"' + message + '\"'\n        ].join(' '),\n        gitExtra, done\n      );\n    }\n  ];\n  contra.series(functionSeries, callback);\n};\n", "var version = require('../'),\n    assert = require('assert'),\n    fs = require('fs'),\n    vinylFs = require('vinyl-fs'),\n    path = require('path'),\n    cp = require('child_process'),\n    File = require('vinyl'),\n    through = require('through2'),\n    fUtil = require('../lib/files'),\n    git = require('../lib/git');\n\ndescribe('git', function () {\n  var filename = 'package.json';\n  var expectedPath = path.join(__dirname, './fixtures/', filename);\n  var expectedContent = fs.readFileSync(expectedPath);\n\n  var original = fUtil.loadFiles;\n  var dest = vinylFs.dest;\n  var exec = cp.exec;\n  var originalIsRepositoryClean = git.isRepositoryClean;\n  var originalCommit = git.commit;\n  var originalCheckout = git.checkout;\n\n  before(function ()\u00a0{\n    vinylFs.dest = function () {\n      return through.obj(function (file, enc, next) {\n        this.push(file);\n        next();\n      });\n    }\n\n    var expectedFile = new File({\n      base: __dirname,\n      cwd: __dirname,\n      path: expectedPath,\n      contents: expectedContent\n    });\n\n    fUtil.loadFiles = function () {\n      var stream = through.obj();\n      stream.write(expectedFile);\n      stream.end();\n      return stream;\n    };\n  });\n\n  after(function () {\n    fUtil.loadFiles = original;\n    vinylFs.dest = dest;\n  });\n\n  afterEach(function () {\n    git.isRepositoryClean = originalIsRepositoryClean;\n    git.commit = originalCommit;\n    git.checkout = originalCheckout;\n\n    cp.exec = exec;\n  });\n\n  describe('#Update()', function(){\n    it('should return error on unclean git repository when commit is given', function (done) {\n      git.isRepositoryClean = function (cb) {\n        return cb(new Error('Not clean'));\n      };\n\n      version.update({\n        version: '1.0.0',\n        commitMessage: 'Message'\n      }, function (err, data) {\n        assert.ok(err);\n        assert.equal(err.message, 'Not clean', 'Error message should be set by isRepositoryClean');\n\n        done();\n      });\n    });\n\n    it('should return NOT error on unclean git repository when no commit message is given', function (done) {\n      git.isRepositoryClean = function (cb) {\n        return cb(new Error('Not clean'));\n      };\n\n      version.update('1.0.0', function (err, data) {\n        assert.ifError(err);\n        done();\n      });\n    });\n\n    it('should get updated version sent to commit when commit message is given', function (done) {\n      git.isRepositoryClean = function (cb) {\n        return cb(null);\n      };\n\n      git.commit = function (files, message, newVer, tagName, callback) {\n        assert.equal(message, 'Message');\n        assert.equal(newVer, '1.0.0');\n        assert.equal(files[0], expectedPath);\n        assert.equal(tagName, 'v1.0.0');\n        return callback(null);\n      };\n\n      version.update({\n        version: '1.0.0',\n        commitMessage: 'Message'\n      }, function (err, data) {\n        assert.ifError(err);\n        done();\n      });\n    });\n\n    it('should be able to override tagName', function (done) {\n      git.isRepositoryClean = function (cb) {\n        return cb(null);\n      };\n\n      git.commit = function (files, message, newVer, tagName, callback) {\n        assert.equal(tagName, 'v1.0.0-src');\n        return callback(null);\n      };\n\n      version.update({\n        version: '1.0.0',\n        commitMessage: 'Message',\n        tagName: 'v%s-src'\n      }, function (err, data) {\n        assert.ifError(err);\n        done();\n      });\n    });\n\n    it('should get flag defining if v-prefix should be used or not', function (done) {\n      git.isRepositoryClean = function (cb) {\n        return cb(null);\n      };\n\n      git.commit = function (files, message, newVer, noPrefix, callback) {\n        assert.ok(noPrefix, 'No prefix should be true');\n        return callback(null);\n      };\n\n      version.update({\n        version: '1.0.0',\n        commitMessage: 'Message',\n        noPrefix: true\n      }, function (err, data) {\n        assert.ifError(err);\n        done();\n      });\n    });\n\n    it('should make tag with v-prefix per default', function (done) {\n      git.isRepositoryClean = function (cb) {\n        return cb(null);\n      };\n\n      cp.exec = function (cmd, extra, cb) {\n        if (cmd.indexOf('-a') === -1) return cb(null);\n        assert.equal('git tag -a v1.0.0 -m \"Message\"', cmd);\n        done();\n      };\n\n      version.update({\n        version: '1.0.0',\n        commitMessage: 'Message'\n      });\n    });\n\n    it('should make tag without v-prefix if specified', function (done) {\n      git.isRepositoryClean = function (cb) {\n        return cb(null);\n      };\n\n      cp.exec = function (cmd, extra, cb) {\n        if (cmd.indexOf('-a') === -1) return cb(null);\n        assert.equal('git tag -a 1.0.0 -m \"Message\"', cmd);\n        done();\n      };\n\n      version.update({\n        version: '1.0.0',\n        commitMessage: 'Message',\n        noPrefix: true\n      });\n    });\n  });\n\n});"], "fixing_code": ["var contra = require(\"contra\"),\n  path = require(\"path\"),\n  fUtils = require(\"./files\"),\n  cp = require(\"child_process\");\n\nvar gitApp = \"git\",\n  gitExtra = { env: process.env };\n\nvar escapeQuotes = function (str) {\n  if (typeof str === \"string\") {\n    return '\"' + str.replace(/([\"'$`\\\\])/g, \"\\\\$1\") + '\"';\n  } else {\n    return str;\n  }\n};\n\nmodule.exports.isRepositoryClean = function (callback) {\n  cp.exec(gitApp + \" \" + [\"ls-files\", \"-m\"].join(\" \"), gitExtra, function (\n    er,\n    stdout,\n    stderr\n  ) {\n    // makeCommit parly inspired and taken from NPM version module\n    var lines = stdout\n      .trim()\n      .split(\"\\n\")\n      .filter(function (line) {\n        var file = path.basename(line.replace(/.{1,2}\\s+/, \"\"));\n        return (\n          line.trim() && !line.match(/^\\?\\? /) && !fUtils.isPackageFile(line)\n        );\n      })\n      .map(function (line) {\n        return line.trim();\n      });\n\n    if (lines.length) {\n      return callback(\n        new Error(\"Git working directory not clean.\\n\" + lines.join(\"\\n\"))\n      );\n    }\n    return callback();\n  });\n};\n\nmodule.exports.checkout = function (callback) {\n  cp.exec(gitApp + \" checkout -- .\", gitExtra, callback);\n};\n\nmodule.exports.commit = function (files, message, newVer, tagName, callback) {\n  message = escapeQuotes(message.replace(\"%s\", newVer));\n  files = files.map(escapeQuotes).join(\" \");\n  var functionSeries = [\n    function (done) {\n      cp.exec(gitApp + \" add \" + files, gitExtra, done);\n    },\n\n    function (done) {\n      cp.exec([gitApp, \"commit\", \"-m\", message].join(\" \"), gitExtra, done);\n    },\n\n    function (done) {\n      cp.exec(\n        [gitApp, \"tag\", \"-a\", tagName, \"-m\", message].join(\" \"),\n        gitExtra,\n        done\n      );\n    },\n  ];\n  contra.series(functionSeries, callback);\n};\n", "var version = require(\"../\"),\n  assert = require(\"assert\"),\n  fs = require(\"fs\"),\n  vinylFs = require(\"vinyl-fs\"),\n  path = require(\"path\"),\n  cp = require(\"child_process\"),\n  File = require(\"vinyl\"),\n  through = require(\"through2\"),\n  fUtil = require(\"../lib/files\"),\n  git = require(\"../lib/git\");\n\ndescribe(\"git\", function () {\n  var filename = \"package.json\";\n  var expectedPath = path.join(__dirname, \"./fixtures/\", filename);\n  var expectedContent = fs.readFileSync(expectedPath);\n\n  var original = fUtil.loadFiles;\n  var dest = vinylFs.dest;\n  var exec = cp.exec;\n  var originalIsRepositoryClean = git.isRepositoryClean;\n  var originalCommit = git.commit;\n  var originalCheckout = git.checkout;\n\n  before(function () {\n    vinylFs.dest = function () {\n      return through.obj(function (file, enc, next) {\n        this.push(file);\n        next();\n      });\n    };\n\n    var expectedFile = new File({\n      base: __dirname,\n      cwd: __dirname,\n      path: expectedPath,\n      contents: expectedContent,\n    });\n\n    fUtil.loadFiles = function () {\n      var stream = through.obj();\n      stream.write(expectedFile);\n      stream.end();\n      return stream;\n    };\n  });\n\n  after(function () {\n    fUtil.loadFiles = original;\n    vinylFs.dest = dest;\n  });\n\n  afterEach(function () {\n    git.isRepositoryClean = originalIsRepositoryClean;\n    git.commit = originalCommit;\n    git.checkout = originalCheckout;\n\n    cp.exec = exec;\n  });\n\n  describe(\"#Update()\", function () {\n    it(\"should return error on unclean git repository when commit is given\", function (done) {\n      git.isRepositoryClean = function (cb) {\n        return cb(new Error(\"Not clean\"));\n      };\n\n      version.update(\n        {\n          version: \"1.0.0\",\n          commitMessage: \"Message\",\n        },\n        function (err, data) {\n          assert.ok(err);\n          assert.equal(\n            err.message,\n            \"Not clean\",\n            \"Error message should be set by isRepositoryClean\"\n          );\n\n          done();\n        }\n      );\n    });\n\n    it(\"should return NOT error on unclean git repository when no commit message is given\", function (done) {\n      git.isRepositoryClean = function (cb) {\n        return cb(new Error(\"Not clean\"));\n      };\n\n      version.update(\"1.0.0\", function (err, data) {\n        assert.ifError(err);\n        done();\n      });\n    });\n\n    it(\"should sanitize commit message\", function (done) {\n      git.isRepositoryClean = function (cb) {\n        return cb(null);\n      };\n\n      cp.exec = function (cmd, extra, cb) {\n        if (cmd.indexOf(\"-a\") === -1) return cb(null);\n        assert.equal('git tag -a v1.0.0 -m \"Message \\\\`touch file\\\\`\"', cmd);\n        done();\n      };\n\n      version.update({\n        version: \"1.0.0\",\n        commitMessage: \"Message `touch file`\",\n      });\n    });\n\n    it(\"should get updated version sent to commit when commit message is given\", function (done) {\n      git.isRepositoryClean = function (cb) {\n        return cb(null);\n      };\n\n      git.commit = function (files, message, newVer, tagName, callback) {\n        assert.equal(message, \"Message\");\n        assert.equal(newVer, \"1.0.0\");\n        assert.equal(files[0], expectedPath);\n        assert.equal(tagName, \"v1.0.0\");\n        return callback(null);\n      };\n\n      version.update(\n        {\n          version: \"1.0.0\",\n          commitMessage: \"Message\",\n        },\n        function (err, data) {\n          assert.ifError(err);\n          done();\n        }\n      );\n    });\n\n    it(\"should be able to override tagName\", function (done) {\n      git.isRepositoryClean = function (cb) {\n        return cb(null);\n      };\n\n      git.commit = function (files, message, newVer, tagName, callback) {\n        assert.equal(tagName, \"v1.0.0-src\");\n        return callback(null);\n      };\n\n      version.update(\n        {\n          version: \"1.0.0\",\n          commitMessage: \"Message\",\n          tagName: \"v%s-src\",\n        },\n        function (err, data) {\n          assert.ifError(err);\n          done();\n        }\n      );\n    });\n\n    it(\"should get flag defining if v-prefix should be used or not\", function (done) {\n      git.isRepositoryClean = function (cb) {\n        return cb(null);\n      };\n\n      git.commit = function (files, message, newVer, noPrefix, callback) {\n        assert.ok(noPrefix, \"No prefix should be true\");\n        return callback(null);\n      };\n\n      version.update(\n        {\n          version: \"1.0.0\",\n          commitMessage: \"Message\",\n          noPrefix: true,\n        },\n        function (err, data) {\n          assert.ifError(err);\n          done();\n        }\n      );\n    });\n\n    it(\"should make tag with v-prefix per default\", function (done) {\n      git.isRepositoryClean = function (cb) {\n        return cb(null);\n      };\n\n      cp.exec = function (cmd, extra, cb) {\n        if (cmd.indexOf(\"-a\") === -1) return cb(null);\n        assert.equal('git tag -a v1.0.0 -m \"Message\"', cmd);\n        done();\n      };\n\n      version.update({\n        version: \"1.0.0\",\n        commitMessage: \"Message\",\n      });\n    });\n\n    it(\"should make tag without v-prefix if specified\", function (done) {\n      git.isRepositoryClean = function (cb) {\n        return cb(null);\n      };\n\n      cp.exec = function (cmd, extra, cb) {\n        if (cmd.indexOf(\"-a\") === -1) return cb(null);\n        assert.equal('git tag -a 1.0.0 -m \"Message\"', cmd);\n        done();\n      };\n\n      version.update({\n        version: \"1.0.0\",\n        commitMessage: \"Message\",\n        noPrefix: true,\n      });\n    });\n  });\n});\n"], "filenames": ["lib/git.js", "tests/git_test.js"], "buggy_code_start_loc": [1, 1], "buggy_code_end_loc": [60, 187], "fixing_code_start_loc": [1, 1], "fixing_code_end_loc": [69, 219], "type": "CWE-77", "message": "In mversion before 2.0.0, there is a command injection vulnerability. This issue may lead to remote code execution if a client of the library calls the vulnerable method with untrusted input. This vulnerability is patched by version 2.0.0. Previous releases are deprecated in npm. As a workaround, make sure to escape git commit messages when using the commitMessage option for the update function.", "other": {"cve": {"id": "CVE-2020-4059", "sourceIdentifier": "security-advisories@github.com", "published": "2020-06-18T20:15:10.760", "lastModified": "2020-06-29T00:50:13.310", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In mversion before 2.0.0, there is a command injection vulnerability. This issue may lead to remote code execution if a client of the library calls the vulnerable method with untrusted input. This vulnerability is patched by version 2.0.0. Previous releases are deprecated in npm. As a workaround, make sure to escape git commit messages when using the commitMessage option for the update function."}, {"lang": "es", "value": "En mversion versiones anteriores a 2.0.0, presenta una vulnerabilidad de inyecci\u00f3n de comandos. Este problema puede conllevar a una ejecuci\u00f3n de c\u00f3digo remota si un cliente de la biblioteca llama al m\u00e9todo vulnerable con una entrada no confiable. Esta vulnerabilidad est\u00e1 parcheada mediante la versi\u00f3n 2.0.0. Las versiones anteriores est\u00e1n en desuso en npm. Como correcci\u00f3n alternativa, aseg\u00farese de escapar de los mensajes de confirmaci\u00f3n de git cuando se usa la opci\u00f3n commitMessage para la funci\u00f3n update"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mversion_project:mversion:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.0", "matchCriteriaId": "B40EDF9B-C9BD-4CD9-83BA-CD70878CA5F8"}]}]}], "references": [{"url": "https://github.com/mikaelbr/mversion/commit/6c76c9efd27c7ff5a5c6f187e8b7a435c4722338", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mikaelbr/mversion/security/advisories/GHSA-qjg4-w4c6-f6c6", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mikaelbr/mversion/commit/6c76c9efd27c7ff5a5c6f187e8b7a435c4722338"}}