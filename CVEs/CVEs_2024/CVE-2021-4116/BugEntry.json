{"buggy_code": ["<?php\n\nnamespace App\\Fields;\n\nuse App\\Log;\n\n/**\n * File class.\n *\n * @package App\n *\n * @copyright YetiForce Sp. z o.o\n * @license   YetiForce Public License 4.0 (licenses/LicenseEN.txt or yetiforce.com)\n * @author    Mariusz Krzaczkowski <m.krzaczkowski@yetiforce.com>\n * @author    Rados\u0142aw Skrzypczak <r.skrzypczak@yetiforce.com>\n */\nclass File\n{\n\t/**\n\t * Temporary table name.\n\t */\n\tpublic const TABLE_NAME_TEMP = 'u_#__file_upload_temp';\n\n\t/**\n\t * Allowed formats.\n\t *\n\t * @var array\n\t */\n\tpublic static $allowedFormats = ['image' => ['jpeg', 'png', 'jpg', 'pjpeg', 'x-png', 'gif', 'bmp', 'x-ms-bmp', 'webp']];\n\n\t/**\n\t * Mime types.\n\t *\n\t * @var string[]\n\t */\n\tprivate static $mimeTypes;\n\n\t/**\n\t * What file types to validate by php injection.\n\t *\n\t * @var string[]\n\t */\n\tprivate static $phpInjection = ['image'];\n\n\t/**\n\t * Directory path used for temporary files.\n\t *\n\t * @var string\n\t */\n\tprivate static $tmpPath;\n\n\t/**\n\t * File path.\n\t *\n\t * @var string\n\t */\n\tprivate $path;\n\n\t/**\n\t * File extension.\n\t *\n\t * @var string\n\t */\n\tprivate $ext;\n\n\t/**\n\t * File mime type.\n\t *\n\t * @var string\n\t */\n\tprivate $mimeType;\n\n\t/**\n\t * File short mime type.\n\t *\n\t * @var string\n\t */\n\tprivate $mimeShortType;\n\n\t/**\n\t * Size.\n\t *\n\t * @var int\n\t */\n\tprivate $size;\n\n\t/**\n\t * File content.\n\t *\n\t * @var string\n\t */\n\tprivate $content;\n\n\t/**\n\t * Error code.\n\t *\n\t * @var bool|int\n\t */\n\tprivate $error = false;\n\n\t/**\n\t * Last validate error.\n\t *\n\t * @var string\n\t */\n\tpublic $validateError = '';\n\n\t/**\n\t * Validate all files by code injection.\n\t *\n\t * @var bool\n\t */\n\tprivate $validateAllCodeInjection = false;\n\n\t/**\n\t * Load file instance from file info.\n\t *\n\t * @param array $fileInfo\n\t *\n\t * @return \\self\n\t */\n\tpublic static function loadFromInfo($fileInfo)\n\t{\n\t\t$instance = new self();\n\t\tforeach ($fileInfo as $key => $value) {\n\t\t\t$instance->{$key} = $fileInfo[$key];\n\t\t}\n\t\treturn $instance;\n\t}\n\n\t/**\n\t * Load file instance from request.\n\t *\n\t * @param array $file\n\t *\n\t * @return \\self\n\t */\n\tpublic static function loadFromRequest($file)\n\t{\n\t\t$instance = new self();\n\t\t$instance->name = trim(\\App\\Purifier::purify($file['name']));\n\t\t$instance->path = $file['tmp_name'];\n\t\t$instance->size = $file['size'];\n\t\t$instance->error = $file['error'];\n\t\treturn $instance;\n\t}\n\n\t/**\n\t * Load file instance from file path.\n\t *\n\t * @param array $path\n\t *\n\t * @return \\self\n\t */\n\tpublic static function loadFromPath($path)\n\t{\n\t\t$instance = new self();\n\t\t$instance->name = basename($path);\n\t\t$instance->path = $path;\n\t\treturn $instance;\n\t}\n\n\t/**\n\t * Load file instance from content.\n\t *\n\t * @param string   $contents\n\t * @param string   $name\n\t * @param string[] $param\n\t *\n\t * @return bool|\\self\n\t */\n\tpublic static function loadFromContent(string $contents, $name = false, array $param = [])\n\t{\n\t\tif (empty($contents)) {\n\t\t\tLog::warning(\"Empty content, unable to create file: $name | Size: \" . \\strlen($contents), __CLASS__);\n\t\t\treturn false;\n\t\t}\n\t\tstatic::initMimeTypes();\n\t\t$extension = 'tmp';\n\t\tif (empty($name)) {\n\t\t\tif (!empty($param['mimeType']) && !($extension = array_search($param['mimeType'], self::$mimeTypes))) {\n\t\t\t\t[, $extension] = explode('/', $param['mimeType']);\n\t\t\t}\n\t\t\t$name = uniqid() . '.' . $extension;\n\t\t} elseif ('tmp' === $extension) {\n\t\t\tif (($fileExt = pathinfo($name, PATHINFO_EXTENSION)) && isset(self::$mimeTypes[$fileExt])) {\n\t\t\t\t$extension = $fileExt;\n\t\t\t\tif (isset($param['mimeType']) && $param['mimeType'] !== self::$mimeTypes[$fileExt]) {\n\t\t\t\t\tLog::error(\"Invalid file content type File: $name  | {$param['mimeType']} <> \" . self::$mimeTypes[$fileExt], __CLASS__);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} elseif (!empty($param['mimeType']) && !($extension = array_search($param['mimeType'], self::$mimeTypes))) {\n\t\t\t\t[, $extension] = explode('/', $param['mimeType']);\n\t\t\t}\n\t\t}\n\t\t$path = tempnam(static::getTmpPath(), 'YFF');\n\t\tif (!file_put_contents($path, $contents)) {\n\t\t\tLog::error(\"Error while saving the file: $path | Size: \" . \\strlen($contents), __CLASS__);\n\t\t\treturn false;\n\t\t}\n\t\tif (mb_strlen($name) > 180) {\n\t\t\t$name = \\App\\TextParser::textTruncate($name, 180, false) . '_' . uniqid() . \".$extension\";\n\t\t}\n\t\t$instance = new self();\n\t\t$instance->name = $name;\n\t\t$instance->path = $path;\n\t\t$instance->ext = $extension;\n\t\tforeach ($param as $key => $value) {\n\t\t\t$instance->{$key} = $value;\n\t\t}\n\t\treturn $instance;\n\t}\n\n\t/**\n\t * Load file instance from url.\n\t *\n\t * @param string   $url\n\t * @param string[] $param\n\t *\n\t * @return self|bool\n\t */\n\tpublic static function loadFromUrl($url, $param = [])\n\t{\n\t\tif (empty($url)) {\n\t\t\tLog::warning('No url: ' . $url, __CLASS__);\n\t\t\treturn false;\n\t\t}\n\t\tif (!\\App\\RequestUtil::isNetConnection()) {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\t\\App\\Log::beginProfile(\"GET|File::loadFromUrl|{$url}\", __NAMESPACE__);\n\t\t\t$response = (new \\GuzzleHttp\\Client(\\App\\RequestHttp::getOptions()))->request('GET', $url, ['timeout' => 5, 'connect_timeout' => 1]);\n\t\t\t\\App\\Log::endProfile(\"GET|File::loadFromUrl|{$url}\", __NAMESPACE__);\n\t\t\tif (200 !== $response->getStatusCode()) {\n\t\t\t\tLog::warning('Error when downloading content: ' . $url . ' | Status code: ' . $response->getStatusCode(), __CLASS__);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$contents = $response->getBody()->getContents();\n\t\t\t$param['mimeType'] = explode(';', $response->getHeaderLine('Content-Type'))[0];\n\t\t\t$param['size'] = \\strlen($contents);\n\t\t} catch (\\Throwable $exc) {\n\t\t\tLog::warning('Error when downloading content: ' . $url . ' | ' . $exc->getMessage(), __CLASS__);\n\t\t\treturn false;\n\t\t}\n\t\tif (empty($contents)) {\n\t\t\tLog::warning('Url does not contain content: ' . $url, __CLASS__);\n\t\t\treturn false;\n\t\t}\n\t\treturn static::loadFromContent($contents, static::sanitizeFileNameFromUrl($url), $param);\n\t}\n\n\t/**\n\t * Get size.\n\t *\n\t * @return int\n\t */\n\tpublic function getSize()\n\t{\n\t\tif (empty($this->size)) {\n\t\t\t$this->size = filesize($this->path);\n\t\t}\n\t\treturn $this->size;\n\t}\n\n\t/**\n\t * Function to sanitize the upload file name when the file name is detected to have bad extensions.\n\t *\n\t * @return string\n\t */\n\tpublic function getSanitizeName()\n\t{\n\t\treturn static::sanitizeUploadFileName($this->name);\n\t}\n\n\t/**\n\t * Get file name.\n\t *\n\t * @return string\n\t */\n\tpublic function getName()\n\t{\n\t\treturn $this->name;\n\t}\n\n\t/**\n\t * Get mime type.\n\t *\n\t * @return string\n\t */\n\tpublic function getMimeType()\n\t{\n\t\tif (empty($this->mimeType)) {\n\t\t\tstatic::initMimeTypes();\n\t\t\t$extension = $this->getExtension(true);\n\t\t\tif (isset(static::$mimeTypes[$extension])) {\n\t\t\t\t$this->mimeType = static::$mimeTypes[$extension];\n\t\t\t} elseif (\\function_exists('mime_content_type')) {\n\t\t\t\t$this->mimeType = mime_content_type($this->path);\n\t\t\t} elseif (\\function_exists('finfo_open')) {\n\t\t\t\t$finfo = finfo_open(FILEINFO_MIME);\n\t\t\t\t$this->mimeType = finfo_file($finfo, $this->path);\n\t\t\t\tfinfo_close($finfo);\n\t\t\t} else {\n\t\t\t\t$this->mimeType = 'application/octet-stream';\n\t\t\t}\n\t\t}\n\t\treturn $this->mimeType;\n\t}\n\n\t/**\n\t * Get short mime type.\n\t *\n\t * @param int $type 0 or 1\n\t *\n\t * @return string\n\t */\n\tpublic function getShortMimeType($type = 1)\n\t{\n\t\tif (empty($this->mimeShortType)) {\n\t\t\t$this->mimeShortType = explode('/', $this->getMimeType());\n\t\t}\n\t\treturn $this->mimeShortType[$type];\n\t}\n\n\t/**\n\t * Get file extension.\n\t *\n\t * @param mixed $fromName\n\t *\n\t * @return string\n\t */\n\tpublic function getExtension($fromName = false)\n\t{\n\t\tif (isset($this->ext)) {\n\t\t\treturn $this->ext;\n\t\t}\n\t\tif ($fromName) {\n\t\t\t$extension = explode('.', $this->name);\n\t\t\treturn $this->ext = strtolower(array_pop($extension));\n\t\t}\n\t\treturn $this->ext = strtolower(pathinfo($this->path, PATHINFO_EXTENSION));\n\t}\n\n\t/**\n\t * Get file path.\n\t *\n\t * @return string\n\t */\n\tpublic function getPath(): string\n\t{\n\t\treturn $this->path;\n\t}\n\n\t/**\n\t * Get file encoding.\n\t *\n\t * @param array|null $list\n\t *\n\t * @return string\n\t */\n\tpublic function getEncoding(?array $list = null): string\n\t{\n\t\treturn \\strtoupper(mb_detect_encoding($this->getContents(), ($list ?? mb_list_encodings()), true));\n\t}\n\n\t/**\n\t * Get directory path.\n\t *\n\t * @return string\n\t */\n\tpublic function getDirectoryPath()\n\t{\n\t\treturn pathinfo($this->getPath(), PATHINFO_DIRNAME);\n\t}\n\n\t/**\n\t * Validate whether the file is safe.\n\t *\n\t * @param bool|string $type\n\t *\n\t * @throws \\Exception\n\t *\n\t * @return bool\n\t */\n\tpublic function validate($type = false)\n\t{\n\t\t$return = true;\n\t\ttry {\n\t\t\tif ($type && $this->getShortMimeType(0) !== $type) {\n\t\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_ILLEGAL_FORMAT');\n\t\t\t}\n\t\t\t$this->checkFile();\n\t\t\tif (!empty($this->validateAllowedFormat)) {\n\t\t\t\t$this->validateFormat();\n\t\t\t}\n\t\t\t$this->validateCodeInjection();\n\t\t\tif (($type && 'image' === $type) || 'image' === $this->getShortMimeType(0)) {\n\t\t\t\t$this->validateImage();\n\t\t\t}\n\t\t} catch (\\Exception $e) {\n\t\t\t$return = false;\n\t\t\t$message = $e->getMessage();\n\t\t\tif (false === strpos($message, '||')) {\n\t\t\t\t$message = \\App\\Language::translateSingleMod($message, 'Other.Exceptions');\n\t\t\t} else {\n\t\t\t\t$params = explode('||', $message);\n\t\t\t\t$message = \\call_user_func_array('vsprintf', [\\App\\Language::translateSingleMod(array_shift($params), 'Other.Exceptions'), $params]);\n\t\t\t}\n\t\t\t$this->validateError = $message;\n\t\t\tLog::error(\"Error: {$e->getMessage()} | {$this->getName()} | {$this->getSize()}\", __CLASS__);\n\t\t}\n\t\treturn $return;\n\t}\n\n\t/**\n\t * Validate and secure the file.\n\t *\n\t * @param bool|string $type\n\t *\n\t * @return bool\n\t */\n\tpublic function validateAndSecure($type = false): bool\n\t{\n\t\tif ($this->validate($type)) {\n\t\t\treturn true;\n\t\t}\n\t\t$reValidate = false;\n\t\tif ('image' === $this->getShortMimeType(0) && static::secureImage($this)) {\n\t\t\t$this->size = filesize($this->path);\n\t\t\t$this->content = file_get_contents($this->path);\n\t\t\t$reValidate = true;\n\t\t}\n\t\tif ($reValidate && $this->validate($type)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Validate image content.\n\t *\n\t * @throws \\App\\Exceptions\\DangerousFile\n\t *\n\t * @return bool\n\t */\n\tpublic function validateImageContent(): bool\n\t{\n\t\t$returnVal = false;\n\t\tif (\\extension_loaded('imagick')) {\n\t\t\ttry {\n\t\t\t\t$img = new \\imagick($this->path);\n\t\t\t\t$returnVal = $img->valid();\n\t\t\t\t$img->clear();\n\t\t\t\t$img->destroy();\n\t\t\t} catch (\\ImagickException $e) {\n\t\t\t\t$this->validateError = $e->getMessage();\n\t\t\t\t$returnVal = false;\n\t\t\t}\n\t\t} else {\n\t\t\t$img = \\imagecreatefromstring($this->getContents());\n\t\t\tif (false !== $img) {\n\t\t\t\t$returnVal = true;\n\t\t\t\t\\imagedestroy($img);\n\t\t\t}\n\t\t}\n\t\treturn $returnVal;\n\t}\n\n\t/**\n\t * Basic check file.\n\t *\n\t * @throws \\Exception\n\t */\n\tprivate function checkFile()\n\t{\n\t\tif (false !== $this->error && UPLOAD_ERR_OK != $this->error) {\n\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_ERROR_REQUEST||' . self::getErrorMessage($this->error));\n\t\t}\n\t\tif (empty($this->name)) {\n\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_EMPTY_NAME');\n\t\t}\n\t\tif (0 === $this->getSize()) {\n\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_WRONG_SIZE');\n\t\t}\n\t}\n\n\t/**\n\t * Validate format.\n\t *\n\t * @throws \\Exception\n\t */\n\tprivate function validateFormat()\n\t{\n\t\tif ($this->validateAllowedFormat !== $this->getShortMimeType(0)) {\n\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_ILLEGAL_MIME_TYPE');\n\t\t}\n\t\tif (isset(self::$allowedFormats[$this->validateAllowedFormat]) && !\\in_array($this->getShortMimeType(1), self::$allowedFormats[$this->validateAllowedFormat])) {\n\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_ILLEGAL_FORMAT');\n\t\t}\n\t}\n\n\t/**\n\t * Validate image.\n\t *\n\t * @throws \\Exception\n\t */\n\tprivate function validateImage()\n\t{\n\t\tif (!getimagesize($this->path)) {\n\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_WRONG_IMAGE');\n\t\t}\n\t\tif (preg_match('[\\x01-\\x08\\x0c-\\x1f]', $this->getContents())) {\n\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_WRONG_IMAGE');\n\t\t}\n\t\t$this->validateCodeInjectionInMetadata();\n\t\tif (!$this->validateImageContent()) {\n\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_WRONG_IMAGE ||' . $this->validateError);\n\t\t}\n\t}\n\n\t/**\n\t * Validate code injection.\n\t *\n\t * @throws \\Exception\n\t */\n\tprivate function validateCodeInjection()\n\t{\n\t\t$shortMimeType = $this->getShortMimeType(0);\n\t\tif ($this->validateAllCodeInjection || \\in_array($shortMimeType, static::$phpInjection)) {\n\t\t\t$contents = $this->getContents();\n\t\t\tif ((1 === preg_match('/(<\\?php?(.*?))/si', $contents)\n\t\t\t|| false !== stripos($contents, '<?=')\n\t\t\t|| false !== stripos($contents, '<? ')) && $this->searchCodeInjection()\n\t\t\t) {\n\t\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_PHP_CODE_INJECTION');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Search code injection in content.\n\t *\n\t * @return bool\n\t */\n\tprivate function searchCodeInjection(): bool\n\t{\n\t\tif (!\\function_exists('token_get_all')) {\n\t\t\treturn true;\n\t\t}\n\t\ttry {\n\t\t\t$tokens = token_get_all($this->getContents(), TOKEN_PARSE);\n\t\t\tforeach ($tokens as $token) {\n\t\t\t\tswitch (\\is_array($token) ? $token[0] : $token) {\n\t\t\t\t\t\tcase T_COMMENT:\n\t\t\t\t\t\tcase T_DOC_COMMENT:\n\t\t\t\t\t\tcase T_WHITESPACE:\n\t\t\t\t\t\tcase T_CURLY_OPEN:\n\t\t\t\t\t\tcase T_OPEN_TAG:\n\t\t\t\t\t\tcase T_CLOSE_TAG:\n\t\t\t\t\t\tcase T_INLINE_HTML:\n\t\t\t\t\t\tcase T_DOLLAR_OPEN_CURLY_BRACES:\n\t\t\t\t\t\t\tcontinue 2;\n\t\t\t\t\t\tcase T_DOUBLE_COLON:\n\t\t\t\t\t\tcase T_ABSTRACT:\n\t\t\t\t\t\tcase T_ARRAY:\n\t\t\t\t\t\tcase T_AS:\n\t\t\t\t\t\tcase T_BREAK:\n\t\t\t\t\t\tcase T_CALLABLE:\n\t\t\t\t\t\tcase T_CASE:\n\t\t\t\t\t\tcase T_CATCH:\n\t\t\t\t\t\tcase T_CLASS:\n\t\t\t\t\t\tcase T_CLONE:\n\t\t\t\t\t\tcase T_CONTINUE:\n\t\t\t\t\t\tcase T_DEFAULT:\n\t\t\t\t\t\tcase T_ECHO:\n\t\t\t\t\t\tcase T_ELSE:\n\t\t\t\t\t\tcase T_ELSEIF:\n\t\t\t\t\t\tcase T_EMPTY:\n\t\t\t\t\t\tcase T_ENDIF:\n\t\t\t\t\t\tcase T_ENDSWITCH:\n\t\t\t\t\t\tcase T_ENDWHILE:\n\t\t\t\t\t\tcase T_EXIT:\n\t\t\t\t\t\tcase T_EXTENDS:\n\t\t\t\t\t\tcase T_FINAL:\n\t\t\t\t\t\tcase T_FINALLY:\n\t\t\t\t\t\tcase T_FOREACH:\n\t\t\t\t\t\tcase T_FUNCTION:\n\t\t\t\t\t\tcase T_GLOBAL:\n\t\t\t\t\t\tcase T_IF:\n\t\t\t\t\t\tcase T_IMPLEMENTS:\n\t\t\t\t\t\tcase T_INCLUDE:\n\t\t\t\t\t\tcase T_INCLUDE_ONCE:\n\t\t\t\t\t\tcase T_INSTANCEOF:\n\t\t\t\t\t\tcase T_INSTEADOF:\n\t\t\t\t\t\tcase T_INTERFACE:\n\t\t\t\t\t\tcase T_ISSET:\n\t\t\t\t\t\tcase T_LOGICAL_AND:\n\t\t\t\t\t\tcase T_LOGICAL_OR:\n\t\t\t\t\t\tcase T_LOGICAL_XOR:\n\t\t\t\t\t\tcase T_NAMESPACE:\n\t\t\t\t\t\tcase T_NEW:\n\t\t\t\t\t\tcase T_PRIVATE:\n\t\t\t\t\t\tcase T_PROTECTED:\n\t\t\t\t\t\tcase T_PUBLIC:\n\t\t\t\t\t\tcase T_REQUIRE:\n\t\t\t\t\t\tcase T_REQUIRE_ONCE:\n\t\t\t\t\t\tcase T_RETURN:\n\t\t\t\t\t\tcase T_STATIC:\n\t\t\t\t\t\tcase T_THROW:\n\t\t\t\t\t\tcase T_TRAIT:\n\t\t\t\t\t\tcase T_TRY:\n\t\t\t\t\t\tcase T_UNSET:\n\t\t\t\t\t\tcase T_USE:\n\t\t\t\t\t\tcase T_VAR:\n\t\t\t\t\t\tcase T_WHILE:\n\t\t\t\t\t\tcase T_YIELD:\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t$text = \\is_array($token) ? $token[1] : $token;\n\t\t\t\t\t\t\tif (\\function_exists($text) || \\defined($text)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t} catch (\\Throwable $e) {\n\t\t\tLog::warning($e->getMessage(), __METHOD__);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Validate code injection in metadata.\n\t *\n\t * @throws \\App\\Exceptions\\DangerousFile\n\t */\n\tprivate function validateCodeInjectionInMetadata()\n\t{\n\t\tif (\n\t\t\t\\function_exists('exif_read_data')\n\t\t\t&& \\in_array($this->getMimeType(), ['image/jpeg', 'image/tiff'])\n\t\t\t&& \\in_array(exif_imagetype($this->path), [IMAGETYPE_JPEG, IMAGETYPE_TIFF_II, IMAGETYPE_TIFF_MM])\n\t\t) {\n\t\t\t$imageSize = getimagesize($this->path, $imageInfo);\n\t\t\tif (\n\t\t\t\t$imageSize\n\t\t\t\t&& (empty($imageInfo['APP1']) || 0 === strpos($imageInfo['APP1'], 'Exif'))\n\t\t\t\t&& ($exifdata = exif_read_data($this->path)) && !$this->validateImageMetadata($exifdata)\n\t\t\t) {\n\t\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_PHP_CODE_INJECTION');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Validate image metadata.\n\t *\n\t * @param mixed $data\n\t *\n\t * @return bool\n\t */\n\tprivate function validateImageMetadata($data)\n\t{\n\t\tif (\\is_array($data)) {\n\t\t\tforeach ($data as $value) {\n\t\t\t\tif (!$this->validateImageMetadata($value)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (1 === preg_match('/(<\\?php?(.*?))/i', $data) || false !== stripos($data, '<?=') || false !== stripos($data, '<? ')) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Get file ontent.\n\t *\n\t * @return string\n\t */\n\tpublic function getContents()\n\t{\n\t\tif (empty($this->content)) {\n\t\t\t$this->content = file_get_contents($this->path);\n\t\t}\n\t\treturn $this->content;\n\t}\n\n\t/**\n\t * Move file.\n\t *\n\t * @param string $target\n\t *\n\t * @return bool\n\t */\n\tpublic function moveFile($target)\n\t{\n\t\tif (is_uploaded_file($this->path)) {\n\t\t\t$uploadStatus = move_uploaded_file($this->path, $target);\n\t\t} else {\n\t\t\t$uploadStatus = rename($this->path, $target);\n\t\t}\n\t\t$this->path = $target;\n\t\treturn $uploadStatus;\n\t}\n\n\t/**\n\t * Delete file.\n\t *\n\t * @return bool\n\t */\n\tpublic function delete()\n\t{\n\t\tif (file_exists($this->path)) {\n\t\t\treturn unlink($this->path);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Generate file hash.\n\t *\n\t * @param bool   $checkInAttachments\n\t * @param string $uploadFilePath\n\t *\n\t * @return string File hash sha256\n\t */\n\tpublic function generateHash(bool $checkInAttachments = false, string $uploadFilePath = '')\n\t{\n\t\tif ($checkInAttachments) {\n\t\t\t$hash = hash('sha1', $this->getContents()) . \\App\\Encryption::generatePassword(10);\n\t\t\tif ($uploadFilePath && file_exists($uploadFilePath . $hash)) {\n\t\t\t\t$hash = $this->generateHash($checkInAttachments);\n\t\t\t}\n\t\t\treturn $hash;\n\t\t}\n\t\treturn hash('sha256', $this->getContents() . \\App\\Encryption::generatePassword(10));\n\t}\n\n\t/**\n\t * Function to sanitize the upload file name when the file name is detected to have bad extensions.\n\t *\n\t * @param string      $fileName          File name to be sanitized\n\t * @param bool|string $badFileExtensions\n\t *\n\t * @return string\n\t */\n\tpublic static function sanitizeUploadFileName($fileName, $badFileExtensions = false)\n\t{\n\t\tif (!$badFileExtensions) {\n\t\t\t$badFileExtensions = \\App\\Config::main('upload_badext');\n\t\t}\n\t\t$fileName = preg_replace('/\\s+/', '_', \\App\\Utils::sanitizeSpecialChars($fileName));\n\t\t$fileName = rtrim($fileName, '\\\\/<>?*:\"<>|');\n\n\t\t$fileNameParts = explode('.', $fileName);\n\t\t$badExtensionFound = false;\n\t\tforeach ($fileNameParts as $key => &$partOfFileName) {\n\t\t\tif (\\in_array(strtolower($partOfFileName), $badFileExtensions)) {\n\t\t\t\t$badExtensionFound = true;\n\t\t\t\t$fileNameParts[$key] = $partOfFileName;\n\t\t\t}\n\t\t}\n\t\t$newFileName = implode('.', $fileNameParts);\n\t\tif ($badExtensionFound) {\n\t\t\t$newFileName .= '.txt';\n\t\t}\n\t\treturn $newFileName;\n\t}\n\n\t/**\n\t * Function to get base name of file.\n\t *\n\t * @param string $url\n\t *\n\t * @return string\n\t */\n\tpublic static function sanitizeFileNameFromUrl($url)\n\t{\n\t\t$partsUrl = parse_url($url);\n\t\treturn static::sanitizeUploadFileName(basename($partsUrl['path']));\n\t}\n\n\t/**\n\t * Get temporary directory path.\n\t *\n\t * @return string\n\t */\n\tpublic static function getTmpPath()\n\t{\n\t\tif (isset(self::$tmpPath)) {\n\t\t\treturn self::$tmpPath;\n\t\t}\n\t\t$hash = hash('crc32', ROOT_DIRECTORY);\n\t\tif (!empty(ini_get('upload_tmp_dir')) && is_writable(ini_get('upload_tmp_dir'))) {\n\t\t\tself::$tmpPath = ini_get('upload_tmp_dir') . \\DIRECTORY_SEPARATOR . 'YetiForceTemp' . $hash . \\DIRECTORY_SEPARATOR;\n\t\t\tif (!is_dir(self::$tmpPath)) {\n\t\t\t\tmkdir(self::$tmpPath, 0755);\n\t\t\t}\n\t\t} elseif (is_writable(sys_get_temp_dir())) {\n\t\t\tself::$tmpPath = sys_get_temp_dir() . \\DIRECTORY_SEPARATOR . 'YetiForceTemp' . $hash . \\DIRECTORY_SEPARATOR;\n\t\t\tif (!is_dir(self::$tmpPath)) {\n\t\t\t\tmkdir(self::$tmpPath, 0755);\n\t\t\t}\n\t\t} elseif (is_writable(ROOT_DIRECTORY . \\DIRECTORY_SEPARATOR . 'cache' . \\DIRECTORY_SEPARATOR . 'upload')) {\n\t\t\tself::$tmpPath = ROOT_DIRECTORY . \\DIRECTORY_SEPARATOR . 'cache' . \\DIRECTORY_SEPARATOR . 'upload' . \\DIRECTORY_SEPARATOR;\n\t\t}\n\t\treturn self::$tmpPath;\n\t}\n\n\t/**\n\t * Init mime types.\n\t */\n\tpublic static function initMimeTypes()\n\t{\n\t\tif (empty(self::$mimeTypes)) {\n\t\t\tself::$mimeTypes = require ROOT_DIRECTORY . '/config/mimetypes.php';\n\t\t}\n\t}\n\n\t/**\n\t * Get mime content type ex. image/png.\n\t *\n\t * @param string $fileName\n\t *\n\t * @return string\n\t */\n\tpublic static function getMimeContentType($fileName)\n\t{\n\t\tstatic::initMimeTypes();\n\t\t$extension = explode('.', $fileName);\n\t\t$extension = strtolower(array_pop($extension));\n\t\tif (isset(self::$mimeTypes[$extension])) {\n\t\t\t$mimeType = self::$mimeTypes[$extension];\n\t\t} elseif (\\function_exists('mime_content_type')) {\n\t\t\t$mimeType = mime_content_type($fileName);\n\t\t} elseif (\\function_exists('finfo_open')) {\n\t\t\t$finfo = finfo_open(FILEINFO_MIME);\n\t\t\t$mimeType = finfo_file($finfo, $fileName);\n\t\t\tfinfo_close($finfo);\n\t\t} else {\n\t\t\t$mimeType = 'application/octet-stream';\n\t\t}\n\t\treturn $mimeType;\n\t}\n\n\t/**\n\t * Create document from string.\n\t *\n\t * @param string $contents\n\t * @param array  $param\n\t *\n\t * @return bool|self\n\t */\n\tpublic static function saveFromString(string $contents, array $param = [])\n\t{\n\t\t$result = explode(',', $contents, 2);\n\t\t$contentType = $isBase64 = false;\n\t\tif (2 === \\count($result)) {\n\t\t\t[$metadata, $data] = $result;\n\t\t\tforeach (explode(';', $metadata) as $cur) {\n\t\t\t\tif ('base64' === $cur) {\n\t\t\t\t\t$isBase64 = true;\n\t\t\t\t} elseif ('data:' === substr($cur, 0, 5)) {\n\t\t\t\t\t$contentType = str_replace('data:', '', $cur);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t$data = $result[0];\n\t\t}\n\t\t$data = rawurldecode($data);\n\t\t$rawData = $isBase64 ? base64_decode($data) : $data;\n\t\tif (\\strlen($rawData) < 12) {\n\t\t\tLog::error('Incorrect content value: ' . $contents, __CLASS__);\n\t\t\treturn false;\n\t\t}\n\t\t$fileInstance = static::loadFromContent($rawData, false, array_merge($param, ['mimeType' => $contentType]));\n\t\tif ($fileInstance->validateAndSecure()) {\n\t\t\treturn $fileInstance;\n\t\t}\n\t\t$fileInstance->delete();\n\t\treturn false;\n\t}\n\n\t/**\n\t * Create document from url.\n\t *\n\t * @param string $url    Url\n\t * @param array  $params\n\t *\n\t * @return array|bool\n\t */\n\tpublic static function saveFromUrl($url, $params = [])\n\t{\n\t\t$fileInstance = static::loadFromUrl($url, $params['param'] ?? []);\n\t\tif (!$fileInstance) {\n\t\t\treturn false;\n\t\t}\n\t\tif ($fileInstance->validateAndSecure() && ($id = static::saveFromContent($fileInstance, $params))) {\n\t\t\treturn $id;\n\t\t}\n\t\t$fileInstance->delete();\n\t\treturn false;\n\t}\n\n\t/**\n\t * Create document from content.\n\t *\n\t * @param \\self $file\n\t * @param array $params\n\t *\n\t * @throws \\Exception\n\t *\n\t * @return array|bool\n\t */\n\tpublic static function saveFromContent(self $file, $params = [])\n\t{\n\t\t$fileName = $file->getName();\n\t\t$fileNameLength = \\App\\TextParser::getTextLength($fileName);\n\t\t$record = \\Vtiger_Record_Model::getCleanInstance('Documents');\n\t\tif ($fileNameLength > ($maxLength = $record->getField('filename')->get('maximumlength'))) {\n\t\t\t$extLength = 0;\n\t\t\tif ($ext = $file->getExtension()) {\n\t\t\t\t$ext .= \".{$ext}\";\n\t\t\t\t$extLength = \\App\\TextParser::getTextLength($ext);\n\t\t\t\t$fileName = substr($fileName, 0, $fileNameLength - $extLength);\n\t\t\t}\n\t\t\t$fileName = \\App\\TextParser::textTruncate($fileName, $maxLength - $extLength, false) . $ext;\n\t\t}\n\t\t$fileName = \\App\\Purifier::decodeHtml(\\App\\Purifier::purify($fileName));\n\t\t$record->setData($params);\n\t\t$record->set('notes_title', $fileName);\n\t\t$record->set('filename', $fileName);\n\t\t$record->set('filestatus', 1);\n\t\t$record->set('filelocationtype', 'I');\n\t\t$record->file = [\n\t\t\t'name' => $fileName,\n\t\t\t'size' => $file->getSize(),\n\t\t\t'type' => $file->getMimeType(),\n\t\t\t'tmp_name' => $file->getPath(),\n\t\t\t'error' => 0,\n\t\t];\n\t\t$record->save();\n\t\t$file->delete();\n\t\tif (isset($record->ext['attachmentsId'])) {\n\t\t\treturn array_merge(['crmid' => $record->getId()], $record->ext);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Init storage file directory.\n\t *\n\t * @param string $suffix\n\t *\n\t * @return string\n\t */\n\tpublic static function initStorageFileDirectory($suffix = false)\n\t{\n\t\tif (!$filepath = \\App\\Config::module($suffix, 'storagePath')) {\n\t\t\t$filepath = 'storage' . \\DIRECTORY_SEPARATOR;\n\t\t}\n\t\tif ($suffix) {\n\t\t\t$filepath .= $suffix . \\DIRECTORY_SEPARATOR;\n\t\t}\n\t\tif (!is_dir($filepath)) { //create new folder\n\t\t\tmkdir($filepath, 0755, true);\n\t\t}\n\t\t$year = date('Y');\n\t\t$month = date('F');\n\t\t$day = date('j');\n\t\t$filepath .= $year;\n\t\tif (!is_dir($filepath)) { //create new folder\n\t\t\tmkdir($filepath, 0755, true);\n\t\t}\n\t\t$filepath .= \\DIRECTORY_SEPARATOR . $month;\n\t\tif (!is_dir($filepath)) { //create new folder\n\t\t\tmkdir($filepath, 0755, true);\n\t\t}\n\t\tif ($day > 0 && $day <= 7) {\n\t\t\t$week = 'week1';\n\t\t} elseif ($day > 7 && $day <= 14) {\n\t\t\t$week = 'week2';\n\t\t} elseif ($day > 14 && $day <= 21) {\n\t\t\t$week = 'week3';\n\t\t} elseif ($day > 21 && $day <= 28) {\n\t\t\t$week = 'week4';\n\t\t} else {\n\t\t\t$week = 'week5';\n\t\t}\n\t\t$filepath .= \\DIRECTORY_SEPARATOR . $week;\n\t\tif (!is_dir($filepath)) { //create new folder\n\t\t\tmkdir($filepath, 0755, true);\n\t\t}\n\t\treturn str_replace('\\\\', '/', $filepath . \\DIRECTORY_SEPARATOR);\n\t}\n\n\t/**\n\t * Get error message by code.\n\t *\n\t * @param int $code\n\t *\n\t * @return string\n\t */\n\tpublic static function getErrorMessage(int $code): string\n\t{\n\t\tswitch ($code) {\n\t\t\tcase UPLOAD_ERR_INI_SIZE:\n\t\t\t\t$message = 'The uploaded file exceeds the upload_max_filesize directive in php.ini';\n\t\t\t\tbreak;\n\t\t\tcase UPLOAD_ERR_FORM_SIZE:\n\t\t\t\t$message = 'The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form';\n\t\t\t\tbreak;\n\t\t\tcase UPLOAD_ERR_PARTIAL:\n\t\t\t\t$message = 'The uploaded file was only partially uploaded';\n\t\t\t\tbreak;\n\t\t\tcase UPLOAD_ERR_NO_FILE:\n\t\t\t\t$message = 'No file was uploaded';\n\t\t\t\tbreak;\n\t\t\tcase UPLOAD_ERR_NO_TMP_DIR:\n\t\t\t\t$message = 'Missing a temporary folder';\n\t\t\t\tbreak;\n\t\t\tcase UPLOAD_ERR_CANT_WRITE:\n\t\t\t\t$message = 'Failed to write file to disk';\n\t\t\t\tbreak;\n\t\t\tcase UPLOAD_ERR_EXTENSION:\n\t\t\t\t$message = 'File upload stopped by extension';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t$message = 'Unknown upload error | Code: ' . $code;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn $message;\n\t}\n\n\t/**\n\t * Get image base data.\n\t *\n\t * @param string $path\n\t *\n\t * @return string\n\t */\n\tpublic static function getImageBaseData($path)\n\t{\n\t\tif ($path) {\n\t\t\t$mime = static::getMimeContentType($path);\n\t\t\t$mimeParts = explode('/', $mime);\n\t\t\tif ($mime && file_exists($path) && isset(static::$allowedFormats[$mimeParts[0]]) && \\in_array($mimeParts[1], static::$allowedFormats[$mimeParts[0]])) {\n\t\t\t\treturn \"data:$mime;base64,\" . base64_encode(file_get_contents($path));\n\t\t\t}\n\t\t}\n\t\treturn '';\n\t}\n\n\t/**\n\t * Check if give path is writeable.\n\t *\n\t * @param string $path\n\t * @param bool   $absolutePaths\n\t *\n\t * @return bool\n\t */\n\tpublic static function isWriteable(string $path, bool $absolutePaths = false): bool\n\t{\n\t\tif (!$absolutePaths) {\n\t\t\t$path = ROOT_DIRECTORY . \\DIRECTORY_SEPARATOR . $path;\n\t\t}\n\t\tif (is_dir($path)) {\n\t\t\treturn static::isDirWriteable($path);\n\t\t}\n\t\treturn is_writable($path);\n\t}\n\n\t/**\n\t * Check if given directory is writeable.\n\t * NOTE: The check is made by trying to create a random file in the directory.\n\t *\n\t * @param string $dirPath\n\t *\n\t * @return bool\n\t */\n\tpublic static function isDirWriteable($dirPath)\n\t{\n\t\tif (is_dir($dirPath)) {\n\t\t\tdo {\n\t\t\t\t$tmpFile = 'tmpfile' . time() . '-' . random_int(1, 1000) . '.tmp';\n\t\t\t\t// Continue the loop unless we find a name that does not exists already.\n\t\t\t\t$useFilename = \"$dirPath/$tmpFile\";\n\t\t\t\tif (!file_exists($useFilename)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (true);\n\t\t\t$fh = fopen($useFilename, 'a');\n\t\t\tif ($fh) {\n\t\t\t\tfclose($fh);\n\t\t\t\tunlink($useFilename);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if give URL exists.\n\t *\n\t * @param string $url\n\t *\n\t * @return bool\n\t */\n\tpublic static function isExistsUrl($url)\n\t{\n\t\t\\App\\Log::beginProfile(\"GET|File::isExistsUrl|{$url}\", __NAMESPACE__);\n\t\ttry {\n\t\t\t$response = (new \\GuzzleHttp\\Client(\\App\\RequestHttp::getOptions()))->request('HEAD', $url, ['timeout' => 1, 'connect_timeout' => 1, 'http_errors' => false, 'allow_redirects' => false]);\n\t\t\t$status = \\in_array($response->getStatusCode(), [200, 302, 401]);\n\t\t} catch (\\Throwable $th) {\n\t\t\t$status = false;\n\t\t}\n\t\t\\App\\Log::endProfile(\"GET|File::isExistsUrl|{$url}\", __NAMESPACE__);\n\t\t\\App\\Log::info(\"Checked URL: $url | Status: \" . $status, __CLASS__);\n\t\treturn $status;\n\t}\n\n\t/**\n\t * Get crm pathname or relative path.\n\t *\n\t * @param string $path       Absolute pathname\n\t * @param string $pathToTrim Path to trim\n\t *\n\t * @return string Local pathname\n\t */\n\tpublic static function getLocalPath(string $path, string $pathToTrim = ROOT_DIRECTORY): string\n\t{\n\t\tif (0 === strpos($path, $pathToTrim)) {\n\t\t\t$index = \\strlen($pathToTrim) + 1;\n\t\t\tif (strrpos($pathToTrim, '/') === \\strlen($pathToTrim) - 1) {\n\t\t\t\t--$index;\n\t\t\t}\n\t\t\t$path = substr($path, $index);\n\t\t}\n\t\treturn $path;\n\t}\n\n\t/**\n\t * Transform mulitiple uploaded file information into useful format.\n\t *\n\t * @param array $files $_FILES\n\t * @param bool  $top\n\t *\n\t * @return array\n\t */\n\tpublic static function transform(array $files, $top = true)\n\t{\n\t\t$rows = [];\n\t\tforeach ($files as $name => $file) {\n\t\t\t$subName = $top ? $file['name'] : $name;\n\t\t\tif (\\is_array($subName)) {\n\t\t\t\tforeach (array_keys($subName) as $key) {\n\t\t\t\t\t$rows[$name][$key] = [\n\t\t\t\t\t\t'name' => $file['name'][$key],\n\t\t\t\t\t\t'type' => $file['type'][$key],\n\t\t\t\t\t\t'tmp_name' => $file['tmp_name'][$key],\n\t\t\t\t\t\t'error' => $file['error'][$key],\n\t\t\t\t\t\t'size' => $file['size'][$key],\n\t\t\t\t\t];\n\t\t\t\t\t$rows[$name] = static::transform($rows[$name], false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$rows[$name] = $file;\n\t\t\t}\n\t\t}\n\t\treturn $rows;\n\t}\n\n\t/**\n\t * Upload and save attachment.\n\t *\n\t * @param \\App\\Request $request\n\t * @param array        $files\n\t * @param string       $type\n\t * @param string       $storageName\n\t *\n\t * @throws \\App\\Exceptions\\IllegalValue\n\t * @throws \\Exception\n\t * @throws \\yii\\db\\Exception\n\t *\n\t * @return array\n\t */\n\tpublic static function uploadAndSave(\\App\\Request $request, array $files, string $type, string $storageName)\n\t{\n\t\t$db = \\App\\Db::getInstance();\n\t\t$attach = [];\n\t\tforeach (static::transform($files, true) as $key => $transformFiles) {\n\t\t\tforeach ($transformFiles as $fileDetails) {\n\t\t\t\t$additionalNotes = '';\n\t\t\t\t$file = static::loadFromRequest($fileDetails);\n\t\t\t\tif (!$file->validate($type)) {\n\t\t\t\t\tif (!static::secureImage($file)) {\n\t\t\t\t\t\t$attach[] = ['name' => $file->getName(), 'error' => $file->validateError, 'hash' => $request->getByType('hash', 'Alnum')];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t$fileDetails['size'] = filesize($fileDetails['tmp_name']);\n\t\t\t\t\t$file = static::loadFromRequest($fileDetails);\n\t\t\t\t\tif (!$file->validate($type)) {\n\t\t\t\t\t\t$attach[] = ['name' => $file->getName(), 'error' => $file->validateError, 'hash' => $request->getByType('hash', 'Alnum')];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t$additionalNotes = \\App\\Language::translate('LBL_FILE_HAS_BEEN_MODIFIED');\n\t\t\t\t}\n\t\t\t\t$uploadFilePath = static::initStorageFileDirectory($storageName);\n\t\t\t\t$key = $file->generateHash(true, $uploadFilePath);\n\t\t\t\t$db->createCommand()->insert(static::TABLE_NAME_TEMP, [\n\t\t\t\t\t'name' => $file->getName(),\n\t\t\t\t\t'type' => $file->getMimeType(),\n\t\t\t\t\t'path' => $uploadFilePath,\n\t\t\t\t\t'createdtime' => date('Y-m-d H:i:s'),\n\t\t\t\t\t'fieldname' => $request->getByType('field', 'Alnum'),\n\t\t\t\t\t'key' => $key,\n\t\t\t\t\t'crmid' => $request->isEmpty('record') ? 0 : $request->getInteger('record'),\n\t\t\t\t])->execute();\n\t\t\t\tif (move_uploaded_file($file->getPath(), $uploadFilePath . $key)) {\n\t\t\t\t\t$attach[] = [\n\t\t\t\t\t\t'name' => $file->getName(),\n\t\t\t\t\t\t'size' => \\vtlib\\Functions::showBytes($file->getSize()),\n\t\t\t\t\t\t'key' => $key,\n\t\t\t\t\t\t'hash' => $request->getByType('hash', 'Alnum'),\n\t\t\t\t\t\t'info' => $additionalNotes,\n\t\t\t\t\t];\n\t\t\t\t} else {\n\t\t\t\t\t$db->createCommand()->delete(static::TABLE_NAME_TEMP, ['key' => $key])->execute();\n\t\t\t\t\tLog::error(\"Moves an uploaded file to a new location failed: {$uploadFilePath}\");\n\t\t\t\t\t$attach[] = ['hash' => $request->getByType('hash', 'Alnum'), 'name' => $file->getName(), 'error' => ''];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $attach;\n\t}\n\n\t/**\n\t * Update upload files.\n\t *\n\t * @param array                $value\n\t * @param \\Vtiger_Record_Model $recordModel\n\t * @param \\Vtiger_Field_Model  $fieldModel\n\t *\n\t * @return array\n\t */\n\tpublic static function updateUploadFiles(array $value, \\Vtiger_Record_Model $recordModel, \\Vtiger_Field_Model $fieldModel)\n\t{\n\t\t$previousValue = $recordModel->get($fieldModel->getName());\n\t\t$previousValue = ($previousValue && !\\App\\Json::isEmpty($previousValue)) ? static::parse(\\App\\Json::decode($previousValue)) : [];\n\t\t$value = static::parse($value);\n\t\t$new = [];\n\t\t$save = false;\n\t\tforeach ($value as $key => $item) {\n\t\t\tif (isset($previousValue[$item['key']])) {\n\t\t\t\t$value[$item['key']] = $previousValue[$item['key']];\n\t\t\t} elseif (!empty($item['baseContent'])) {\n\t\t\t\t$base = static::saveFromBase($item, $recordModel->getModuleName());\n\t\t\t\t$new[] = $value[$base['key']] = $base;\n\t\t\t\tunset($value[$key]);\n\t\t\t\t$save = true;\n\t\t\t} elseif ($item['key'] ? ($uploadFile = static::getUploadFile($item['key'])) : null) {\n\t\t\t\t$new[] = $value[$item['key']] = [\n\t\t\t\t\t'name' => $uploadFile['name'],\n\t\t\t\t\t'size' => $item['size'],\n\t\t\t\t\t'path' => $uploadFile['path'] . $item['key'],\n\t\t\t\t\t'key' => $item['key'],\n\t\t\t\t];\n\t\t\t\t$save = true;\n\t\t\t}\n\t\t}\n\t\tforeach ($previousValue as $item) {\n\t\t\tif (!isset($value[$item['key']])) {\n\t\t\t\t$save = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn [array_values($value), $new, $save];\n\t}\n\n\t/**\n\t * Delete data from the temporary table.\n\t *\n\t * @param string|string[] $keys\n\t *\n\t * @return int\n\t */\n\tpublic static function cleanTemp($keys)\n\t{\n\t\treturn \\App\\Db::getInstance()->createCommand()->delete(static::TABLE_NAME_TEMP, ['key' => $keys])->execute();\n\t}\n\n\t/**\n\t * Secure image file.\n\t *\n\t * @param \\App\\Fields\\File $file\n\t *\n\t * @return bool\n\t */\n\tpublic static function secureImage(self $file): bool\n\t{\n\t\t$result = false;\n\t\tif (\\extension_loaded('imagick')) {\n\t\t\ttry {\n\t\t\t\t$img = new \\imagick($file->getPath());\n\t\t\t\t$img->stripImage();\n\t\t\t\tswitch ($file->getExtension()) {\n\t\t\t\t\tcase 'jpg':\n\t\t\t\t\tcase 'jpeg':\n\t\t\t\t\t\t$img->setImageCompression(\\Imagick::COMPRESSION_JPEG);\n\t\t\t\t\t\t$img->setImageCompressionQuality(99);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t$img->writeImage($file->getPath());\n\t\t\t\t$img->clear();\n\t\t\t\t$img->destroy();\n\t\t\t\t$result = true;\n\t\t\t} catch (\\ImagickException $e) {\n\t\t\t\t$result = false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (\\in_array($file->getExtension(), ['jpeg', 'png', 'gif', 'bmp', 'wbmp', 'gd2', 'webp'])) {\n\t\t\t\t$img = \\imagecreatefromstring($file->getContents());\n\t\t\t\tif (false !== $img) {\n\t\t\t\t\tswitch ($file->getExtension()) {\n\t\t\t\t\t\tcase 'jpg':\n\t\t\t\t\t\tcase 'jpeg':\n\t\t\t\t\t\t\t$result = \\imagejpeg($img, $file->getPath());\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'png':\n\t\t\t\t\t\t\t$result = \\imagepng($img, $file->getPath());\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'gif':\n\t\t\t\t\t\t\t$result = \\imagegif($img, $file->getPath());\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'bmp':\n\t\t\t\t\t\t\t$result = \\imagebmp($img, $file->getPath());\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\\imagedestroy($img);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $result;\n\t}\n\n\t/**\n\t * Parse.\n\t *\n\t * @param array $value\n\t *\n\t * @return array\n\t */\n\tpublic static function parse(array $value)\n\t{\n\t\treturn array_reduce($value, function ($result, $item) {\n\t\t\tif (isset($item['key'])) {\n\t\t\t\t$result[$item['key']] = $item;\n\t\t\t}\n\t\t\treturn $result;\n\t\t}, []);\n\t}\n\n\t/**\n\t * Get upload file details from db.\n\t *\n\t * @param string $key\n\t *\n\t * @return array\n\t */\n\tpublic static function getUploadFile(string $key)\n\t{\n\t\t$row = (new \\App\\Db\\Query())->from(static::TABLE_NAME_TEMP)->where(['key' => $key])->one();\n\t\treturn $row ?: [];\n\t}\n\n\t/**\n\t * Check is it an allowed directory.\n\t *\n\t * @param string $fullPath\n\t *\n\t * @return bool\n\t */\n\tpublic static function isAllowedDirectory(string $fullPath)\n\t{\n\t\treturn !(!is_readable($fullPath) || !is_dir($fullPath) || is_file($fullPath));\n\t}\n\n\t/**\n\t * Check is it an allowed file directory.\n\t *\n\t * @param string $fullPath\n\t *\n\t * @return bool\n\t */\n\tpublic static function isAllowedFileDirectory(string $fullPath)\n\t{\n\t\treturn !(!is_readable($fullPath) || is_dir($fullPath) || !is_file($fullPath));\n\t}\n\n\t/**\n\t * CheckFilePath.\n\t *\n\t * @param string $path\n\t *\n\t * @return bool\n\t */\n\tpublic static function checkFilePath(string $path)\n\t{\n\t\tpreg_match('[^\\\\w\\\\s\\\\d\\\\.\\\\-_~,;:\\\\[\\\\]\\\\(\\\\]]', $path, $matches);\n\t\tif ($matches) {\n\t\t\treturn true;\n\t\t}\n\t\t$absolutes = ['YetiTemp'];\n\t\tforeach (array_filter(explode('/', str_replace(['/', '\\\\'], '/', $path)), 'strlen') as $part) {\n\t\t\tif ('.' === $part) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ('..' === $part) {\n\t\t\t\tarray_pop($absolutes);\n\t\t\t} else {\n\t\t\t\t$absolutes[] = $part;\n\t\t\t}\n\t\t}\n\t\treturn 'YetiTemp' === $absolutes[0];\n\t}\n\n\t/**\n\t * Save file from base64 encoded string.\n\t *\n\t * @param string $raw        base64 string\n\t * @param string $moduleName Destination record module name\n\t *\n\t * @return array\n\t */\n\tpublic static function saveFromBase($raw, $moduleName): array\n\t{\n\t\t$file = static::loadFromContent(\\base64_decode($raw['baseContent']), $raw['name']);\n\t\t$savePath = static::initStorageFileDirectory($moduleName);\n\t\t$key = $file->generateHash(true, $savePath);\n\t\tif ($file->moveFile($savePath . $key)) {\n\t\t\treturn [\n\t\t\t\t'name' => $file->getName(),\n\t\t\t\t'size' => \\vtlib\\Functions::showBytes($file->getSize()),\n\t\t\t\t'key' => $key,\n\t\t\t\t'hash' => \\md5_file($savePath . $key),\n\t\t\t\t'path' => $savePath . $key,\n\t\t\t];\n\t\t}\n\t\t$file->delete();\n\t\treturn [];\n\t}\n\n\t/**\n\t * Save file from given url.\n\t *\n\t * @param string      $url\n\t * @param string      $moduleName\n\t * @param string|bool $type\n\t *\n\t * @return array\n\t */\n\tpublic static function saveImageFromUrl(string $url, string $moduleName, $type = false): array\n\t{\n\t\t$value = [];\n\t\tif ($file = static::loadFromUrl($url)) {\n\t\t\tif ($file->validateAndSecure($type)) {\n\t\t\t\t$savePath = static::initStorageFileDirectory($moduleName);\n\t\t\t\t$key = $file->generateHash(true, $savePath);\n\t\t\t\tif ($file->moveFile($savePath . $key)) {\n\t\t\t\t\t$value = [\n\t\t\t\t\t\t'name' => $file->getName(),\n\t\t\t\t\t\t'size' => \\vtlib\\Functions::showBytes($file->getSize()),\n\t\t\t\t\t\t'key' => $key,\n\t\t\t\t\t\t'hash' => \\md5_file($savePath . $key),\n\t\t\t\t\t\t'path' => $savePath . $key,\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$file->delete();\n\t\t\t}\n\t\t}\n\t\treturn $value;\n\t}\n}\n", "<?php\n\nreturn [\n\t'appVersion' => '6.3.5',\n\t'patchVersion' => '2021.12.14',\n\t'lib_roundcube' => '0.2.3',\n];\n", "{\n  \"php\": {\n    \"ERR_ILLEGAL_VALUE\": \"Illegal value\",\n    \"ERR_SCRIPT_EXISTS_FUNCTION_NOT\": \"Script exists but doesn't contain imported function name.\",\n    \"ERR_FAILED_TO_SAVE_SCRIPT\": \"Failed to save workflow methods script file.\",\n    \"ERR_ILLEGAL_FIELD_VALUE\": \"Illegal value has been entered for this field type. Field name: %s, Module: %s, Value: %s\",\n    \"ERR_VALUE_IS_TOO_LONG\": \"Character limit exceeded. Field name: %s, Module: %s, Value: %s\",\n    \"ERR_TO_MANY_FILES\": \"Too many files transferred - limit was exceeded. Field name: %s, Module: %s, Value: %s\",\n    \"ERR_VALUE_CAN_NOT_BE_LESS_THAN_ZERO\": \"The field value must be greater than zero. Field name: %s, Module: %s, Value: %s\",\n    \"ERR_NOT_ALLOWED_VALUE\": \"Incorrect value detected, please contact your administrator\",\n    \"ERR_PASSWORD_HAS_ALREADY_BEEN_USED\": \"This password has already been used. The system does not allow to use the same password for security reasons.\",\n    \"ERR_USER_EXISTS\": \"User with the same username and role already exists (%s)\",\n    \"ERR_NOT_ACCESSIBLE\": \"Access denied\",\n    \"ERR_DUPLICATE_LOGIN\": \"The specified login already exists.\",\n    \"ERR_NO_PERMISSIONS_FOR_THE_RECORD\": \"You don't have the permissions required to view/edit this record. Contact the administrator if you should have the permission to view it.\",\n    \"ERR_CONTENTS_VARIABLE_CANT_CALLED_FUNCTION\": \"Variable (%s) content cannot be triggered as function\",\n    \"ERR_DUPLICATES_VALUES_FOUND\": \"Duplicated %s values found\",\n    \"ERR_EXCEEDED_NUMBER_CHARACTERS\": \"Exceeded number of characters\",\n    \"ERR_SPECIAL_CHARACTERS_NOT_ALLOWED\": \"Special characters such as %s are not allowed\",\n    \"ERR_CREATE_FILE_FAILURE\": \"Failed to create file\",\n    \"ERR_FILE_WRONG_SIZE\": \"Wrong file size\",\n    \"ERR_FILE_EMPTY_NAME\": \"File name is empty\",\n    \"ERR_FILE_ERROR_REQUEST\": \"File transfer error: %s\",\n    \"ERR_FILE_ILLEGAL_FORMAT\": \"Illegal file format\",\n    \"ERR_FILE_WRONG_IMAGE\": \"Wrong image file\",\n    \"ERR_FILE_PHP_CODE_INJECTION\": \"File contains dangerous PHP code and was rejected\",\n    \"ERR_FILE_XPACKET_CODE_INJECTION\": \"File contains dangerous XPACKET code and was rejected\",\n    \"ERR_NO_PERMISSIONS_TO_CREATE_DIRECTORIES\": \"No permissions to create directories\",\n    \"ERR_DIRECTORY_CANNOT_BE_CREATED\": \"The directory cannot be created\",\n    \"ERR_AUTO_LOGOUT\": \"Logged out automatically due to no activity\",\n    \"ERR_FIELD_NOT_FOUND\": \"Field not found (%s)\",\n    \"ERR_NUMBER_OF_ARGUMENTS_NOT_ALLOWED\": \"Number of arguments not allowed (%d %s in %s)\",\n    \"ERR_NO_VALUE\": \"No value in %s\",\n    \"ERR_BODY_IS_EMPTY\": \"Body is empty\",\n    \"ERR_API\": \"Error in API\",\n    \"ERR_MODULE_DOES_NOT_EXIST\": \"Module %s does not exist\",\n    \"ERR_RECORD_NOT_FOUND\": \"There is no record with ID: %s\",\n    \"ERR_NO_PERMISSIONS_TO_FIELD\": \"No permissions to the field\",\n    \"ERR_NO_PERMITTED_TO_VIEW\": \"No permissions to view\",\n    \"ERR_CURRENCY_TABLE_DOWNLOAD\": \"Error while downloading the exchange rate table.\",\n    \"ERR_ITERATIONS_LIMIT_EXCEEDED\": \"Exceeded iteration limit.\",\n    \"ERR_CANNOT_PARSE_SERVER_RESPONSE\": \"Error while parsing server responses\",\n    \"ERR_CANNOT_CONNECT_TO_REMOTE\": \"Error while connecting to remote server\",\n    \"ERR_NO_INTERNET_CONNECTION\": \"No Internet connection\",\n    \"ERR_OBJECT_MUST_HAVE_INTERFACE\": \"The object must have an interface %s\",\n    \"ERR_CLASS_NOT_FOUND\": \"Class %s not found\",\n    \"ERR_CLASS_MUST_BE\": \"Class must be %s\",\n    \"ERR_PAID_FUNCTIONALITY\": \"%s paid functionality, you must purchase it\",\n    \"ERR_TOKEN_DOES_NOT_EXIST\": \"The token does not exist or has expired\",\n    \"ERR_NO_TOKEN\": \"No token\",\n    \"ERR_INCORRECT_2FA_TOTP_CODE\": \"Incorrect 2FA TOTP code\",\n    \"ERR_NO_2FA_TOTP_CODE\": \"No 2FA TOTP code\"\n  }\n}\n"], "fixing_code": ["<?php\n\nnamespace App\\Fields;\n\nuse App\\Log;\n\n/**\n * File class.\n *\n * @package App\n *\n * @copyright YetiForce Sp. z o.o\n * @license   YetiForce Public License 4.0 (licenses/LicenseEN.txt or yetiforce.com)\n * @author    Mariusz Krzaczkowski <m.krzaczkowski@yetiforce.com>\n * @author    Rados\u0142aw Skrzypczak <r.skrzypczak@yetiforce.com>\n */\nclass File\n{\n\t/**\n\t * Temporary table name.\n\t */\n\tpublic const TABLE_NAME_TEMP = 'u_#__file_upload_temp';\n\n\t/**\n\t * Allowed formats.\n\t *\n\t * @var array\n\t */\n\tpublic static $allowedFormats = ['image' => ['jpeg', 'png', 'jpg', 'pjpeg', 'x-png', 'gif', 'bmp', 'x-ms-bmp', 'webp']];\n\n\t/**\n\t * Mime types.\n\t *\n\t * @var string[]\n\t */\n\tprivate static $mimeTypes;\n\n\t/**\n\t * What file types to validate by php injection.\n\t *\n\t * @var string[]\n\t */\n\tprivate static $phpInjection = ['image'];\n\n\t/**\n\t * Directory path used for temporary files.\n\t *\n\t * @var string\n\t */\n\tprivate static $tmpPath;\n\n\t/**\n\t * File path.\n\t *\n\t * @var string\n\t */\n\tprivate $path;\n\n\t/**\n\t * File extension.\n\t *\n\t * @var string\n\t */\n\tprivate $ext;\n\n\t/**\n\t * File mime type.\n\t *\n\t * @var string\n\t */\n\tprivate $mimeType;\n\n\t/**\n\t * File short mime type.\n\t *\n\t * @var string\n\t */\n\tprivate $mimeShortType;\n\n\t/**\n\t * Size.\n\t *\n\t * @var int\n\t */\n\tprivate $size;\n\n\t/**\n\t * File content.\n\t *\n\t * @var string\n\t */\n\tprivate $content;\n\n\t/**\n\t * Error code.\n\t *\n\t * @var bool|int\n\t */\n\tprivate $error = false;\n\n\t/**\n\t * Last validate error.\n\t *\n\t * @var string\n\t */\n\tpublic $validateError = '';\n\n\t/**\n\t * Validate all files by code injection.\n\t *\n\t * @var bool\n\t */\n\tprivate $validateAllCodeInjection = false;\n\n\t/**\n\t * Load file instance from file info.\n\t *\n\t * @param array $fileInfo\n\t *\n\t * @return \\self\n\t */\n\tpublic static function loadFromInfo($fileInfo)\n\t{\n\t\t$instance = new self();\n\t\tforeach ($fileInfo as $key => $value) {\n\t\t\t$instance->{$key} = $fileInfo[$key];\n\t\t}\n\t\tif (isset($instance->name)) {\n\t\t\t$instance->name = trim(\\App\\Purifier::purify($instance->name));\n\t\t}\n\t\treturn $instance;\n\t}\n\n\t/**\n\t * Load file instance from request.\n\t *\n\t * @param array $file\n\t *\n\t * @return \\self\n\t */\n\tpublic static function loadFromRequest($file)\n\t{\n\t\t$instance = new self();\n\t\t$instance->name = trim(\\App\\Purifier::purify($file['name']));\n\t\t$instance->path = $file['tmp_name'];\n\t\t$instance->size = $file['size'];\n\t\t$instance->error = $file['error'];\n\t\treturn $instance;\n\t}\n\n\t/**\n\t * Load file instance from file path.\n\t *\n\t * @param string $path\n\t *\n\t * @return \\self\n\t */\n\tpublic static function loadFromPath(string $path)\n\t{\n\t\t$instance = new self();\n\t\t$instance->name = trim(\\App\\Purifier::purify(basename($path)));\n\t\t$instance->path = $path;\n\t\treturn $instance;\n\t}\n\n\t/**\n\t * Load file instance from content.\n\t *\n\t * @param string   $contents\n\t * @param string   $name\n\t * @param string[] $param\n\t *\n\t * @return bool|\\self\n\t */\n\tpublic static function loadFromContent(string $contents, $name = false, array $param = [])\n\t{\n\t\tif (empty($contents)) {\n\t\t\tLog::warning(\"Empty content, unable to create file: $name | Size: \" . \\strlen($contents), __CLASS__);\n\t\t\treturn false;\n\t\t}\n\t\tstatic::initMimeTypes();\n\t\t$extension = 'tmp';\n\t\tif (empty($name)) {\n\t\t\tif (!empty($param['mimeType']) && !($extension = array_search($param['mimeType'], self::$mimeTypes))) {\n\t\t\t\t[, $extension] = explode('/', $param['mimeType']);\n\t\t\t}\n\t\t\t$name = uniqid() . '.' . $extension;\n\t\t} elseif ('tmp' === $extension) {\n\t\t\tif (($fileExt = pathinfo($name, PATHINFO_EXTENSION)) && isset(self::$mimeTypes[$fileExt])) {\n\t\t\t\t$extension = $fileExt;\n\t\t\t\tif (isset($param['mimeType']) && $param['mimeType'] !== self::$mimeTypes[$fileExt]) {\n\t\t\t\t\tLog::error(\"Invalid file content type File: $name  | {$param['mimeType']} <> \" . self::$mimeTypes[$fileExt], __CLASS__);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} elseif (!empty($param['mimeType']) && !($extension = array_search($param['mimeType'], self::$mimeTypes))) {\n\t\t\t\t[, $extension] = explode('/', $param['mimeType']);\n\t\t\t}\n\t\t}\n\t\t$path = tempnam(static::getTmpPath(), 'YFF');\n\t\tif (!file_put_contents($path, $contents)) {\n\t\t\tLog::error(\"Error while saving the file: $path | Size: \" . \\strlen($contents), __CLASS__);\n\t\t\treturn false;\n\t\t}\n\t\tif (mb_strlen($name) > 180) {\n\t\t\t$name = \\App\\TextParser::textTruncate($name, 180, false) . '_' . uniqid() . \".$extension\";\n\t\t}\n\t\t$instance = new self();\n\t\t$instance->name = trim(\\App\\Purifier::purify($name));\n\t\t$instance->path = $path;\n\t\t$instance->ext = $extension;\n\t\tforeach ($param as $key => $value) {\n\t\t\t$instance->{$key} = $value;\n\t\t}\n\t\treturn $instance;\n\t}\n\n\t/**\n\t * Load file instance from url.\n\t *\n\t * @param string   $url\n\t * @param string[] $param\n\t *\n\t * @return self|bool\n\t */\n\tpublic static function loadFromUrl($url, $param = [])\n\t{\n\t\tif (empty($url)) {\n\t\t\tLog::warning('No url: ' . $url, __CLASS__);\n\t\t\treturn false;\n\t\t}\n\t\tif (!\\App\\RequestUtil::isNetConnection()) {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\t\\App\\Log::beginProfile(\"GET|File::loadFromUrl|{$url}\", __NAMESPACE__);\n\t\t\t$response = (new \\GuzzleHttp\\Client(\\App\\RequestHttp::getOptions()))->request('GET', $url, ['timeout' => 5, 'connect_timeout' => 1]);\n\t\t\t\\App\\Log::endProfile(\"GET|File::loadFromUrl|{$url}\", __NAMESPACE__);\n\t\t\tif (200 !== $response->getStatusCode()) {\n\t\t\t\tLog::warning('Error when downloading content: ' . $url . ' | Status code: ' . $response->getStatusCode(), __CLASS__);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$contents = $response->getBody()->getContents();\n\t\t\t$param['mimeType'] = explode(';', $response->getHeaderLine('Content-Type'))[0];\n\t\t\t$param['size'] = \\strlen($contents);\n\t\t} catch (\\Throwable $exc) {\n\t\t\tLog::warning('Error when downloading content: ' . $url . ' | ' . $exc->getMessage(), __CLASS__);\n\t\t\treturn false;\n\t\t}\n\t\tif (empty($contents)) {\n\t\t\tLog::warning('Url does not contain content: ' . $url, __CLASS__);\n\t\t\treturn false;\n\t\t}\n\t\treturn static::loadFromContent($contents, static::sanitizeFileNameFromUrl($url), $param);\n\t}\n\n\t/**\n\t * Get size.\n\t *\n\t * @return int\n\t */\n\tpublic function getSize()\n\t{\n\t\tif (empty($this->size)) {\n\t\t\t$this->size = filesize($this->path);\n\t\t}\n\t\treturn $this->size;\n\t}\n\n\t/**\n\t * Function to sanitize the upload file name when the file name is detected to have bad extensions.\n\t *\n\t * @return string\n\t */\n\tpublic function getSanitizeName()\n\t{\n\t\treturn static::sanitizeUploadFileName($this->name);\n\t}\n\n\t/**\n\t * Get file name.\n\t *\n\t * @return string\n\t */\n\tpublic function getName()\n\t{\n\t\treturn $this->name;\n\t}\n\n\t/**\n\t * Get mime type.\n\t *\n\t * @return string\n\t */\n\tpublic function getMimeType()\n\t{\n\t\tif (empty($this->mimeType)) {\n\t\t\tstatic::initMimeTypes();\n\t\t\t$extension = $this->getExtension(true);\n\t\t\tif (isset(static::$mimeTypes[$extension])) {\n\t\t\t\t$this->mimeType = static::$mimeTypes[$extension];\n\t\t\t} elseif (\\function_exists('mime_content_type')) {\n\t\t\t\t$this->mimeType = mime_content_type($this->path);\n\t\t\t} elseif (\\function_exists('finfo_open')) {\n\t\t\t\t$finfo = finfo_open(FILEINFO_MIME);\n\t\t\t\t$this->mimeType = finfo_file($finfo, $this->path);\n\t\t\t\tfinfo_close($finfo);\n\t\t\t} else {\n\t\t\t\t$this->mimeType = 'application/octet-stream';\n\t\t\t}\n\t\t}\n\t\treturn $this->mimeType;\n\t}\n\n\t/**\n\t * Get short mime type.\n\t *\n\t * @param int $type 0 or 1\n\t *\n\t * @return string\n\t */\n\tpublic function getShortMimeType($type = 1)\n\t{\n\t\tif (empty($this->mimeShortType)) {\n\t\t\t$this->mimeShortType = explode('/', $this->getMimeType());\n\t\t}\n\t\treturn $this->mimeShortType[$type];\n\t}\n\n\t/**\n\t * Get file extension.\n\t *\n\t * @param mixed $fromName\n\t *\n\t * @return string\n\t */\n\tpublic function getExtension($fromName = false)\n\t{\n\t\tif (isset($this->ext)) {\n\t\t\treturn $this->ext;\n\t\t}\n\t\tif ($fromName) {\n\t\t\t$extension = explode('.', $this->name);\n\t\t\treturn $this->ext = strtolower(array_pop($extension));\n\t\t}\n\t\treturn $this->ext = strtolower(pathinfo($this->path, PATHINFO_EXTENSION));\n\t}\n\n\t/**\n\t * Get file path.\n\t *\n\t * @return string\n\t */\n\tpublic function getPath(): string\n\t{\n\t\treturn $this->path;\n\t}\n\n\t/**\n\t * Get file encoding.\n\t *\n\t * @param array|null $list\n\t *\n\t * @return string\n\t */\n\tpublic function getEncoding(?array $list = null): string\n\t{\n\t\treturn \\strtoupper(mb_detect_encoding($this->getContents(), ($list ?? mb_list_encodings()), true));\n\t}\n\n\t/**\n\t * Get directory path.\n\t *\n\t * @return string\n\t */\n\tpublic function getDirectoryPath()\n\t{\n\t\treturn pathinfo($this->getPath(), PATHINFO_DIRNAME);\n\t}\n\n\t/**\n\t * Validate whether the file is safe.\n\t *\n\t * @param string|null $type\n\t *\n\t * @throws \\Exception\n\t *\n\t * @return bool\n\t */\n\tpublic function validate(?string $type = null): bool\n\t{\n\t\t$return = true;\n\t\ttry {\n\t\t\tif ($type && $this->getShortMimeType(0) !== $type) {\n\t\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_ILLEGAL_FORMAT');\n\t\t\t}\n\t\t\t$this->checkFile();\n\t\t\tif (!empty($this->validateAllowedFormat)) {\n\t\t\t\t$this->validateFormat();\n\t\t\t}\n\t\t\t$this->validateCodeInjection();\n\t\t\tif (($type && 'image' === $type) || 'image' === $this->getShortMimeType(0)) {\n\t\t\t\t$this->validateImage();\n\t\t\t}\n\t\t} catch (\\Exception $e) {\n\t\t\t$return = false;\n\t\t\t$message = $e->getMessage();\n\t\t\tif (false === strpos($message, '||')) {\n\t\t\t\t$message = \\App\\Language::translateSingleMod($message, 'Other.Exceptions');\n\t\t\t} else {\n\t\t\t\t$params = explode('||', $message);\n\t\t\t\t$message = \\call_user_func_array('vsprintf', [\\App\\Language::translateSingleMod(array_shift($params), 'Other.Exceptions'), $params]);\n\t\t\t}\n\t\t\t$this->validateError = $message;\n\t\t\tLog::error(\"Error during file validation: {$this->getName()} | Size: {$this->getSize()}\\n {$e->__toString()}\", __CLASS__);\n\t\t}\n\t\treturn $return;\n\t}\n\n\t/**\n\t * Validate and secure the file.\n\t *\n\t * @param string|null $type\n\t *\n\t * @return bool\n\t */\n\tpublic function validateAndSecure(?string $type = null): bool\n\t{\n\t\tif ($this->validate($type)) {\n\t\t\treturn true;\n\t\t}\n\t\t$reValidate = false;\n\t\tif (static::secureFile($this)) {\n\t\t\t$this->size = filesize($this->path);\n\t\t\t$this->content = file_get_contents($this->path);\n\t\t\t$reValidate = true;\n\t\t}\n\t\tif ($reValidate && $this->validate($type)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Validate image content.\n\t *\n\t * @throws \\App\\Exceptions\\DangerousFile\n\t *\n\t * @return bool\n\t */\n\tpublic function validateImageContent(): bool\n\t{\n\t\t$returnVal = false;\n\t\tif (\\extension_loaded('imagick')) {\n\t\t\ttry {\n\t\t\t\t$img = new \\imagick($this->path);\n\t\t\t\t$returnVal = $img->valid();\n\t\t\t\t$img->clear();\n\t\t\t\t$img->destroy();\n\t\t\t} catch (\\ImagickException $e) {\n\t\t\t\t$this->validateError = $e->getMessage();\n\t\t\t\t$returnVal = false;\n\t\t\t}\n\t\t} else {\n\t\t\t$img = \\imagecreatefromstring($this->getContents());\n\t\t\tif (false !== $img) {\n\t\t\t\t$returnVal = true;\n\t\t\t\t\\imagedestroy($img);\n\t\t\t}\n\t\t}\n\t\treturn $returnVal;\n\t}\n\n\t/**\n\t * Basic check file.\n\t *\n\t * @throws \\Exception\n\t */\n\tprivate function checkFile()\n\t{\n\t\tif (false !== $this->error && UPLOAD_ERR_OK != $this->error) {\n\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_ERROR_REQUEST||' . self::getErrorMessage($this->error));\n\t\t}\n\t\tif (empty($this->name)) {\n\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_EMPTY_NAME');\n\t\t}\n\t\tif (!$this->validateInjection($this->name)) {\n\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_ILLEGAL_NAME');\n\t\t}\n\t\tif (0 === $this->getSize()) {\n\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_WRONG_SIZE');\n\t\t}\n\t}\n\n\t/**\n\t * Validate format.\n\t *\n\t * @throws \\Exception\n\t */\n\tprivate function validateFormat()\n\t{\n\t\tif ($this->validateAllowedFormat !== $this->getShortMimeType(0)) {\n\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_ILLEGAL_MIME_TYPE');\n\t\t}\n\t\tif (isset(self::$allowedFormats[$this->validateAllowedFormat]) && !\\in_array($this->getShortMimeType(1), self::$allowedFormats[$this->validateAllowedFormat])) {\n\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_ILLEGAL_FORMAT');\n\t\t}\n\t}\n\n\t/**\n\t * Validate image.\n\t *\n\t * @throws \\Exception\n\t */\n\tprivate function validateImage()\n\t{\n\t\tif (!getimagesize($this->path)) {\n\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_WRONG_IMAGE');\n\t\t}\n\t\tif (preg_match('[\\x01-\\x08\\x0c-\\x1f]', $this->getContents())) {\n\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_WRONG_IMAGE');\n\t\t}\n\t\t$this->validateCodeInjectionInMetadata();\n\t\tif (!$this->validateImageContent()) {\n\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_WRONG_IMAGE ||' . $this->validateError);\n\t\t}\n\t}\n\n\t/**\n\t * Validate code injection.\n\t *\n\t * @throws \\Exception\n\t */\n\tprivate function validateCodeInjection()\n\t{\n\t\t$shortMimeType = $this->getShortMimeType(0);\n\t\tif ($this->validateAllCodeInjection || \\in_array($shortMimeType, static::$phpInjection)) {\n\t\t\t$contents = $this->getContents();\n\t\t\tif ((1 === preg_match('/(<\\?php?(.*?))/si', $contents)\n\t\t\t|| false !== stripos($contents, '<?=')\n\t\t\t|| false !== stripos($contents, '<? ')) && $this->searchCodeInjection()\n\t\t\t) {\n\t\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_CODE_INJECTION');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Search code injection in content.\n\t *\n\t * @return bool\n\t */\n\tprivate function searchCodeInjection(): bool\n\t{\n\t\tif (!\\function_exists('token_get_all')) {\n\t\t\treturn true;\n\t\t}\n\t\ttry {\n\t\t\t$tokens = token_get_all($this->getContents(), TOKEN_PARSE);\n\t\t\tforeach ($tokens as $token) {\n\t\t\t\tswitch (\\is_array($token) ? $token[0] : $token) {\n\t\t\t\t\t\tcase T_COMMENT:\n\t\t\t\t\t\tcase T_DOC_COMMENT:\n\t\t\t\t\t\tcase T_WHITESPACE:\n\t\t\t\t\t\tcase T_CURLY_OPEN:\n\t\t\t\t\t\tcase T_OPEN_TAG:\n\t\t\t\t\t\tcase T_CLOSE_TAG:\n\t\t\t\t\t\tcase T_INLINE_HTML:\n\t\t\t\t\t\tcase T_DOLLAR_OPEN_CURLY_BRACES:\n\t\t\t\t\t\t\tcontinue 2;\n\t\t\t\t\t\tcase T_DOUBLE_COLON:\n\t\t\t\t\t\tcase T_ABSTRACT:\n\t\t\t\t\t\tcase T_ARRAY:\n\t\t\t\t\t\tcase T_AS:\n\t\t\t\t\t\tcase T_BREAK:\n\t\t\t\t\t\tcase T_CALLABLE:\n\t\t\t\t\t\tcase T_CASE:\n\t\t\t\t\t\tcase T_CATCH:\n\t\t\t\t\t\tcase T_CLASS:\n\t\t\t\t\t\tcase T_CLONE:\n\t\t\t\t\t\tcase T_CONTINUE:\n\t\t\t\t\t\tcase T_DEFAULT:\n\t\t\t\t\t\tcase T_ECHO:\n\t\t\t\t\t\tcase T_ELSE:\n\t\t\t\t\t\tcase T_ELSEIF:\n\t\t\t\t\t\tcase T_EMPTY:\n\t\t\t\t\t\tcase T_ENDIF:\n\t\t\t\t\t\tcase T_ENDSWITCH:\n\t\t\t\t\t\tcase T_ENDWHILE:\n\t\t\t\t\t\tcase T_EXIT:\n\t\t\t\t\t\tcase T_EXTENDS:\n\t\t\t\t\t\tcase T_FINAL:\n\t\t\t\t\t\tcase T_FINALLY:\n\t\t\t\t\t\tcase T_FOREACH:\n\t\t\t\t\t\tcase T_FUNCTION:\n\t\t\t\t\t\tcase T_GLOBAL:\n\t\t\t\t\t\tcase T_IF:\n\t\t\t\t\t\tcase T_IMPLEMENTS:\n\t\t\t\t\t\tcase T_INCLUDE:\n\t\t\t\t\t\tcase T_INCLUDE_ONCE:\n\t\t\t\t\t\tcase T_INSTANCEOF:\n\t\t\t\t\t\tcase T_INSTEADOF:\n\t\t\t\t\t\tcase T_INTERFACE:\n\t\t\t\t\t\tcase T_ISSET:\n\t\t\t\t\t\tcase T_LOGICAL_AND:\n\t\t\t\t\t\tcase T_LOGICAL_OR:\n\t\t\t\t\t\tcase T_LOGICAL_XOR:\n\t\t\t\t\t\tcase T_NAMESPACE:\n\t\t\t\t\t\tcase T_NEW:\n\t\t\t\t\t\tcase T_PRIVATE:\n\t\t\t\t\t\tcase T_PROTECTED:\n\t\t\t\t\t\tcase T_PUBLIC:\n\t\t\t\t\t\tcase T_REQUIRE:\n\t\t\t\t\t\tcase T_REQUIRE_ONCE:\n\t\t\t\t\t\tcase T_RETURN:\n\t\t\t\t\t\tcase T_STATIC:\n\t\t\t\t\t\tcase T_THROW:\n\t\t\t\t\t\tcase T_TRAIT:\n\t\t\t\t\t\tcase T_TRY:\n\t\t\t\t\t\tcase T_UNSET:\n\t\t\t\t\t\tcase T_USE:\n\t\t\t\t\t\tcase T_VAR:\n\t\t\t\t\t\tcase T_WHILE:\n\t\t\t\t\t\tcase T_YIELD:\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t$text = \\is_array($token) ? $token[1] : $token;\n\t\t\t\t\t\t\tif (\\function_exists($text) || \\defined($text)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t} catch (\\Throwable $e) {\n\t\t\tLog::warning($e->getMessage(), __METHOD__);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Validate code injection in metadata.\n\t *\n\t * @throws \\App\\Exceptions\\DangerousFile\n\t */\n\tprivate function validateCodeInjectionInMetadata()\n\t{\n\t\tif (\\extension_loaded('imagick')) {\n\t\t\ttry {\n\t\t\t\t$img = new \\imagick($this->path);\n\t\t\t\t$this->validateInjection($img->getImageProperties());\n\t\t\t} catch (\\Throwable $e) {\n\t\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_CODE_INJECTION', $e->getCode(), $e);\n\t\t\t}\n\t\t} elseif (\n\t\t\t\\function_exists('exif_read_data')\n\t\t\t&& \\in_array($this->getMimeType(), ['image/jpeg', 'image/tiff'])\n\t\t\t&& \\in_array(exif_imagetype($this->path), [IMAGETYPE_JPEG, IMAGETYPE_TIFF_II, IMAGETYPE_TIFF_MM])\n\t\t) {\n\t\t\t$imageSize = getimagesize($this->path, $imageInfo);\n\t\t\ttry {\n\t\t\t\tif (\n\t\t\t\t\t$imageSize\n\t\t\t\t\t&& (empty($imageInfo['APP1']) || 0 === strpos($imageInfo['APP1'], 'Exif'))\n\t\t\t\t\t&& ($exifData = exif_read_data($this->path)) && !$this->validateInjection($exifData)\n\t\t\t\t) {\n\t\t\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_CODE_INJECTION');\n\t\t\t\t}\n\t\t\t} catch (\\Throwable $e) {\n\t\t\t\tthrow new \\App\\Exceptions\\DangerousFile('ERR_FILE_CODE_INJECTION', $e->getCode(), $e);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Validate injection.\n\t *\n\t * @param string|array $data\n\t *\n\t * @return bool\n\t */\n\tprivate function validateInjection($data): bool\n\t{\n\t\t$return = true;\n\t\tif (\\is_array($data)) {\n\t\t\tforeach ($data as $value) {\n\t\t\t\tif (!$this->validateInjection($value)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (1 === preg_match('/(<\\?php?(.*?))/i', $data) || false !== stripos($data, '<?=') || false !== stripos($data, '<? ')) {\n\t\t\t\t$return = false;\n\t\t\t} else {\n\t\t\t\t\\App\\Purifier::purifyHtmlEventAttributes($data);\n\t\t\t}\n\t\t}\n\t\treturn $return;\n\t}\n\n\t/**\n\t * Get file ontent.\n\t *\n\t * @return string\n\t */\n\tpublic function getContents()\n\t{\n\t\tif (empty($this->content)) {\n\t\t\t$this->content = file_get_contents($this->path);\n\t\t}\n\t\treturn $this->content;\n\t}\n\n\t/**\n\t * Move file.\n\t *\n\t * @param string $target\n\t *\n\t * @return bool\n\t */\n\tpublic function moveFile($target)\n\t{\n\t\tif (is_uploaded_file($this->path)) {\n\t\t\t$uploadStatus = move_uploaded_file($this->path, $target);\n\t\t} else {\n\t\t\t$uploadStatus = rename($this->path, $target);\n\t\t}\n\t\t$this->path = $target;\n\t\treturn $uploadStatus;\n\t}\n\n\t/**\n\t * Delete file.\n\t *\n\t * @return bool\n\t */\n\tpublic function delete()\n\t{\n\t\tif (file_exists($this->path)) {\n\t\t\treturn unlink($this->path);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Generate file hash.\n\t *\n\t * @param bool   $checkInAttachments\n\t * @param string $uploadFilePath\n\t *\n\t * @return string File hash sha256\n\t */\n\tpublic function generateHash(bool $checkInAttachments = false, string $uploadFilePath = '')\n\t{\n\t\tif ($checkInAttachments) {\n\t\t\t$hash = hash('sha1', $this->getContents()) . \\App\\Encryption::generatePassword(10);\n\t\t\tif ($uploadFilePath && file_exists($uploadFilePath . $hash)) {\n\t\t\t\t$hash = $this->generateHash($checkInAttachments);\n\t\t\t}\n\t\t\treturn $hash;\n\t\t}\n\t\treturn hash('sha256', $this->getContents() . \\App\\Encryption::generatePassword(10));\n\t}\n\n\t/**\n\t * Function to sanitize the upload file name when the file name is detected to have bad extensions.\n\t *\n\t * @param string      $fileName          File name to be sanitized\n\t * @param bool|string $badFileExtensions\n\t *\n\t * @return string\n\t */\n\tpublic static function sanitizeUploadFileName($fileName, $badFileExtensions = false)\n\t{\n\t\tif (!$badFileExtensions) {\n\t\t\t$badFileExtensions = \\App\\Config::main('upload_badext');\n\t\t}\n\t\t$fileName = preg_replace('/\\s+/', '_', \\App\\Utils::sanitizeSpecialChars($fileName));\n\t\t$fileName = rtrim($fileName, '\\\\/<>?*:\"<>|');\n\n\t\t$fileNameParts = explode('.', $fileName);\n\t\t$badExtensionFound = false;\n\t\tforeach ($fileNameParts as $key => &$partOfFileName) {\n\t\t\tif (\\in_array(strtolower($partOfFileName), $badFileExtensions)) {\n\t\t\t\t$badExtensionFound = true;\n\t\t\t\t$fileNameParts[$key] = $partOfFileName;\n\t\t\t}\n\t\t}\n\t\t$newFileName = implode('.', $fileNameParts);\n\t\tif ($badExtensionFound) {\n\t\t\t$newFileName .= '.txt';\n\t\t}\n\t\treturn $newFileName;\n\t}\n\n\t/**\n\t * Function to get base name of file.\n\t *\n\t * @param string $url\n\t *\n\t * @return string\n\t */\n\tpublic static function sanitizeFileNameFromUrl($url)\n\t{\n\t\t$partsUrl = parse_url($url);\n\t\treturn static::sanitizeUploadFileName(basename($partsUrl['path']));\n\t}\n\n\t/**\n\t * Get temporary directory path.\n\t *\n\t * @return string\n\t */\n\tpublic static function getTmpPath()\n\t{\n\t\tif (isset(self::$tmpPath)) {\n\t\t\treturn self::$tmpPath;\n\t\t}\n\t\t$hash = hash('crc32', ROOT_DIRECTORY);\n\t\tif (!empty(ini_get('upload_tmp_dir')) && is_writable(ini_get('upload_tmp_dir'))) {\n\t\t\tself::$tmpPath = ini_get('upload_tmp_dir') . \\DIRECTORY_SEPARATOR . 'YetiForceTemp' . $hash . \\DIRECTORY_SEPARATOR;\n\t\t\tif (!is_dir(self::$tmpPath)) {\n\t\t\t\tmkdir(self::$tmpPath, 0755);\n\t\t\t}\n\t\t} elseif (is_writable(sys_get_temp_dir())) {\n\t\t\tself::$tmpPath = sys_get_temp_dir() . \\DIRECTORY_SEPARATOR . 'YetiForceTemp' . $hash . \\DIRECTORY_SEPARATOR;\n\t\t\tif (!is_dir(self::$tmpPath)) {\n\t\t\t\tmkdir(self::$tmpPath, 0755);\n\t\t\t}\n\t\t} elseif (is_writable(ROOT_DIRECTORY . \\DIRECTORY_SEPARATOR . 'cache' . \\DIRECTORY_SEPARATOR . 'upload')) {\n\t\t\tself::$tmpPath = ROOT_DIRECTORY . \\DIRECTORY_SEPARATOR . 'cache' . \\DIRECTORY_SEPARATOR . 'upload' . \\DIRECTORY_SEPARATOR;\n\t\t}\n\t\treturn self::$tmpPath;\n\t}\n\n\t/**\n\t * Init mime types.\n\t */\n\tpublic static function initMimeTypes()\n\t{\n\t\tif (empty(self::$mimeTypes)) {\n\t\t\tself::$mimeTypes = require ROOT_DIRECTORY . '/config/mimetypes.php';\n\t\t}\n\t}\n\n\t/**\n\t * Get mime content type ex. image/png.\n\t *\n\t * @param string $fileName\n\t *\n\t * @return string\n\t */\n\tpublic static function getMimeContentType($fileName)\n\t{\n\t\tstatic::initMimeTypes();\n\t\t$extension = explode('.', $fileName);\n\t\t$extension = strtolower(array_pop($extension));\n\t\tif (isset(self::$mimeTypes[$extension])) {\n\t\t\t$mimeType = self::$mimeTypes[$extension];\n\t\t} elseif (\\function_exists('mime_content_type')) {\n\t\t\t$mimeType = mime_content_type($fileName);\n\t\t} elseif (\\function_exists('finfo_open')) {\n\t\t\t$finfo = finfo_open(FILEINFO_MIME);\n\t\t\t$mimeType = finfo_file($finfo, $fileName);\n\t\t\tfinfo_close($finfo);\n\t\t} else {\n\t\t\t$mimeType = 'application/octet-stream';\n\t\t}\n\t\treturn $mimeType;\n\t}\n\n\t/**\n\t * Create document from string.\n\t *\n\t * @param string $contents\n\t * @param array  $param\n\t *\n\t * @return bool|self\n\t */\n\tpublic static function saveFromString(string $contents, array $param = [])\n\t{\n\t\t$result = explode(',', $contents, 2);\n\t\t$contentType = $isBase64 = false;\n\t\tif (2 === \\count($result)) {\n\t\t\t[$metadata, $data] = $result;\n\t\t\tforeach (explode(';', $metadata) as $cur) {\n\t\t\t\tif ('base64' === $cur) {\n\t\t\t\t\t$isBase64 = true;\n\t\t\t\t} elseif ('data:' === substr($cur, 0, 5)) {\n\t\t\t\t\t$contentType = str_replace('data:', '', $cur);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t$data = $result[0];\n\t\t}\n\t\t$data = rawurldecode($data);\n\t\t$rawData = $isBase64 ? base64_decode($data) : $data;\n\t\tif (\\strlen($rawData) < 12) {\n\t\t\tLog::error('Incorrect content value: ' . $contents, __CLASS__);\n\t\t\treturn false;\n\t\t}\n\t\t$fileInstance = static::loadFromContent($rawData, false, array_merge($param, ['mimeType' => $contentType]));\n\t\tif ($fileInstance->validateAndSecure()) {\n\t\t\treturn $fileInstance;\n\t\t}\n\t\t$fileInstance->delete();\n\t\treturn false;\n\t}\n\n\t/**\n\t * Create document from url.\n\t *\n\t * @param string $url    Url\n\t * @param array  $params\n\t *\n\t * @return array|bool\n\t */\n\tpublic static function saveFromUrl($url, $params = [])\n\t{\n\t\t$fileInstance = static::loadFromUrl($url, $params['param'] ?? []);\n\t\tif (!$fileInstance) {\n\t\t\treturn false;\n\t\t}\n\t\tif ($fileInstance->validateAndSecure() && ($id = static::saveFromContent($fileInstance, $params))) {\n\t\t\treturn $id;\n\t\t}\n\t\t$fileInstance->delete();\n\t\treturn false;\n\t}\n\n\t/**\n\t * Create document from content.\n\t *\n\t * @param \\self $file\n\t * @param array $params\n\t *\n\t * @throws \\Exception\n\t *\n\t * @return array|bool\n\t */\n\tpublic static function saveFromContent(self $file, $params = [])\n\t{\n\t\t$fileName = $file->getName();\n\t\t$fileNameLength = \\App\\TextParser::getTextLength($fileName);\n\t\t$record = \\Vtiger_Record_Model::getCleanInstance('Documents');\n\t\tif ($fileNameLength > ($maxLength = $record->getField('filename')->get('maximumlength'))) {\n\t\t\t$extLength = 0;\n\t\t\tif ($ext = $file->getExtension()) {\n\t\t\t\t$ext .= \".{$ext}\";\n\t\t\t\t$extLength = \\App\\TextParser::getTextLength($ext);\n\t\t\t\t$fileName = substr($fileName, 0, $fileNameLength - $extLength);\n\t\t\t}\n\t\t\t$fileName = \\App\\TextParser::textTruncate($fileName, $maxLength - $extLength, false) . $ext;\n\t\t}\n\t\t$fileName = \\App\\Purifier::decodeHtml(\\App\\Purifier::purify($fileName));\n\t\t$record->setData($params);\n\t\t$record->set('notes_title', $fileName);\n\t\t$record->set('filename', $fileName);\n\t\t$record->set('filestatus', 1);\n\t\t$record->set('filelocationtype', 'I');\n\t\t$record->file = [\n\t\t\t'name' => $fileName,\n\t\t\t'size' => $file->getSize(),\n\t\t\t'type' => $file->getMimeType(),\n\t\t\t'tmp_name' => $file->getPath(),\n\t\t\t'error' => 0,\n\t\t];\n\t\t$record->save();\n\t\t$file->delete();\n\t\tif (isset($record->ext['attachmentsId'])) {\n\t\t\treturn array_merge(['crmid' => $record->getId()], $record->ext);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Init storage file directory.\n\t *\n\t * @param string $suffix\n\t *\n\t * @return string\n\t */\n\tpublic static function initStorageFileDirectory($suffix = false)\n\t{\n\t\tif (!$filepath = \\App\\Config::module($suffix, 'storagePath')) {\n\t\t\t$filepath = 'storage' . \\DIRECTORY_SEPARATOR;\n\t\t}\n\t\tif ($suffix) {\n\t\t\t$filepath .= $suffix . \\DIRECTORY_SEPARATOR;\n\t\t}\n\t\tif (!is_dir($filepath)) { //create new folder\n\t\t\tmkdir($filepath, 0755, true);\n\t\t}\n\t\t$year = date('Y');\n\t\t$month = date('F');\n\t\t$day = date('j');\n\t\t$filepath .= $year;\n\t\tif (!is_dir($filepath)) { //create new folder\n\t\t\tmkdir($filepath, 0755, true);\n\t\t}\n\t\t$filepath .= \\DIRECTORY_SEPARATOR . $month;\n\t\tif (!is_dir($filepath)) { //create new folder\n\t\t\tmkdir($filepath, 0755, true);\n\t\t}\n\t\tif ($day > 0 && $day <= 7) {\n\t\t\t$week = 'week1';\n\t\t} elseif ($day > 7 && $day <= 14) {\n\t\t\t$week = 'week2';\n\t\t} elseif ($day > 14 && $day <= 21) {\n\t\t\t$week = 'week3';\n\t\t} elseif ($day > 21 && $day <= 28) {\n\t\t\t$week = 'week4';\n\t\t} else {\n\t\t\t$week = 'week5';\n\t\t}\n\t\t$filepath .= \\DIRECTORY_SEPARATOR . $week;\n\t\tif (!is_dir($filepath)) { //create new folder\n\t\t\tmkdir($filepath, 0755, true);\n\t\t}\n\t\treturn str_replace('\\\\', '/', $filepath . \\DIRECTORY_SEPARATOR);\n\t}\n\n\t/**\n\t * Get error message by code.\n\t *\n\t * @param int $code\n\t *\n\t * @return string\n\t */\n\tpublic static function getErrorMessage(int $code): string\n\t{\n\t\tswitch ($code) {\n\t\t\tcase UPLOAD_ERR_INI_SIZE:\n\t\t\t\t$message = 'The uploaded file exceeds the upload_max_filesize directive in php.ini';\n\t\t\t\tbreak;\n\t\t\tcase UPLOAD_ERR_FORM_SIZE:\n\t\t\t\t$message = 'The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form';\n\t\t\t\tbreak;\n\t\t\tcase UPLOAD_ERR_PARTIAL:\n\t\t\t\t$message = 'The uploaded file was only partially uploaded';\n\t\t\t\tbreak;\n\t\t\tcase UPLOAD_ERR_NO_FILE:\n\t\t\t\t$message = 'No file was uploaded';\n\t\t\t\tbreak;\n\t\t\tcase UPLOAD_ERR_NO_TMP_DIR:\n\t\t\t\t$message = 'Missing a temporary folder';\n\t\t\t\tbreak;\n\t\t\tcase UPLOAD_ERR_CANT_WRITE:\n\t\t\t\t$message = 'Failed to write file to disk';\n\t\t\t\tbreak;\n\t\t\tcase UPLOAD_ERR_EXTENSION:\n\t\t\t\t$message = 'File upload stopped by extension';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t$message = 'Unknown upload error | Code: ' . $code;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn $message;\n\t}\n\n\t/**\n\t * Get image base data.\n\t *\n\t * @param string $path\n\t *\n\t * @return string\n\t */\n\tpublic static function getImageBaseData($path)\n\t{\n\t\tif ($path) {\n\t\t\t$mime = static::getMimeContentType($path);\n\t\t\t$mimeParts = explode('/', $mime);\n\t\t\tif ($mime && file_exists($path) && isset(static::$allowedFormats[$mimeParts[0]]) && \\in_array($mimeParts[1], static::$allowedFormats[$mimeParts[0]])) {\n\t\t\t\treturn \"data:$mime;base64,\" . base64_encode(file_get_contents($path));\n\t\t\t}\n\t\t}\n\t\treturn '';\n\t}\n\n\t/**\n\t * Check if give path is writeable.\n\t *\n\t * @param string $path\n\t * @param bool   $absolutePaths\n\t *\n\t * @return bool\n\t */\n\tpublic static function isWriteable(string $path, bool $absolutePaths = false): bool\n\t{\n\t\tif (!$absolutePaths) {\n\t\t\t$path = ROOT_DIRECTORY . \\DIRECTORY_SEPARATOR . $path;\n\t\t}\n\t\tif (is_dir($path)) {\n\t\t\treturn static::isDirWriteable($path);\n\t\t}\n\t\treturn is_writable($path);\n\t}\n\n\t/**\n\t * Check if given directory is writeable.\n\t * NOTE: The check is made by trying to create a random file in the directory.\n\t *\n\t * @param string $dirPath\n\t *\n\t * @return bool\n\t */\n\tpublic static function isDirWriteable($dirPath)\n\t{\n\t\tif (is_dir($dirPath)) {\n\t\t\tdo {\n\t\t\t\t$tmpFile = 'tmpfile' . time() . '-' . random_int(1, 1000) . '.tmp';\n\t\t\t\t// Continue the loop unless we find a name that does not exists already.\n\t\t\t\t$useFilename = \"$dirPath/$tmpFile\";\n\t\t\t\tif (!file_exists($useFilename)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (true);\n\t\t\t$fh = fopen($useFilename, 'a');\n\t\t\tif ($fh) {\n\t\t\t\tfclose($fh);\n\t\t\t\tunlink($useFilename);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if give URL exists.\n\t *\n\t * @param string $url\n\t *\n\t * @return bool\n\t */\n\tpublic static function isExistsUrl($url)\n\t{\n\t\t\\App\\Log::beginProfile(\"GET|File::isExistsUrl|{$url}\", __NAMESPACE__);\n\t\ttry {\n\t\t\t$response = (new \\GuzzleHttp\\Client(\\App\\RequestHttp::getOptions()))->request('HEAD', $url, ['timeout' => 1, 'connect_timeout' => 1, 'http_errors' => false, 'allow_redirects' => false]);\n\t\t\t$status = \\in_array($response->getStatusCode(), [200, 302, 401]);\n\t\t} catch (\\Throwable $th) {\n\t\t\t$status = false;\n\t\t}\n\t\t\\App\\Log::endProfile(\"GET|File::isExistsUrl|{$url}\", __NAMESPACE__);\n\t\t\\App\\Log::info(\"Checked URL: $url | Status: \" . $status, __CLASS__);\n\t\treturn $status;\n\t}\n\n\t/**\n\t * Get crm pathname or relative path.\n\t *\n\t * @param string $path       Absolute pathname\n\t * @param string $pathToTrim Path to trim\n\t *\n\t * @return string Local pathname\n\t */\n\tpublic static function getLocalPath(string $path, string $pathToTrim = ROOT_DIRECTORY): string\n\t{\n\t\tif (0 === strpos($path, $pathToTrim)) {\n\t\t\t$index = \\strlen($pathToTrim) + 1;\n\t\t\tif (strrpos($pathToTrim, '/') === \\strlen($pathToTrim) - 1) {\n\t\t\t\t--$index;\n\t\t\t}\n\t\t\t$path = substr($path, $index);\n\t\t}\n\t\treturn $path;\n\t}\n\n\t/**\n\t * Transform mulitiple uploaded file information into useful format.\n\t *\n\t * @param array $files $_FILES\n\t * @param bool  $top\n\t *\n\t * @return array\n\t */\n\tpublic static function transform(array $files, $top = true)\n\t{\n\t\t$rows = [];\n\t\tforeach ($files as $name => $file) {\n\t\t\t$subName = $top ? $file['name'] : $name;\n\t\t\tif (\\is_array($subName)) {\n\t\t\t\tforeach (array_keys($subName) as $key) {\n\t\t\t\t\t$rows[$name][$key] = [\n\t\t\t\t\t\t'name' => $file['name'][$key],\n\t\t\t\t\t\t'type' => $file['type'][$key],\n\t\t\t\t\t\t'tmp_name' => $file['tmp_name'][$key],\n\t\t\t\t\t\t'error' => $file['error'][$key],\n\t\t\t\t\t\t'size' => $file['size'][$key],\n\t\t\t\t\t];\n\t\t\t\t\t$rows[$name] = static::transform($rows[$name], false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$rows[$name] = $file;\n\t\t\t}\n\t\t}\n\t\treturn $rows;\n\t}\n\n\t/**\n\t * Upload and save attachment.\n\t *\n\t * @param \\App\\Request $request\n\t * @param array        $files\n\t * @param string       $type\n\t * @param string       $storageName\n\t *\n\t * @throws \\App\\Exceptions\\IllegalValue\n\t * @throws \\Exception\n\t * @throws \\yii\\db\\Exception\n\t *\n\t * @return array\n\t */\n\tpublic static function uploadAndSave(\\App\\Request $request, array $files, string $type, string $storageName)\n\t{\n\t\t$db = \\App\\Db::getInstance();\n\t\t$attach = [];\n\t\tforeach (static::transform($files, true) as $key => $transformFiles) {\n\t\t\tforeach ($transformFiles as $fileDetails) {\n\t\t\t\t$additionalNotes = '';\n\t\t\t\t$file = static::loadFromRequest($fileDetails);\n\t\t\t\tif (!$file->validate($type)) {\n\t\t\t\t\tif (!static::secureFile($file)) {\n\t\t\t\t\t\t$attach[] = ['name' => $file->getName(), 'error' => $file->validateError, 'hash' => $request->getByType('hash', 'Alnum')];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t$fileDetails['size'] = filesize($fileDetails['tmp_name']);\n\t\t\t\t\t$file = static::loadFromRequest($fileDetails);\n\t\t\t\t\tif (!$file->validate($type)) {\n\t\t\t\t\t\t$attach[] = ['name' => $file->getName(), 'error' => $file->validateError, 'hash' => $request->getByType('hash', 'Alnum')];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t$additionalNotes = \\App\\Language::translate('LBL_FILE_HAS_BEEN_MODIFIED');\n\t\t\t\t}\n\t\t\t\t$uploadFilePath = static::initStorageFileDirectory($storageName);\n\t\t\t\t$key = $file->generateHash(true, $uploadFilePath);\n\t\t\t\t$db->createCommand()->insert(static::TABLE_NAME_TEMP, [\n\t\t\t\t\t'name' => $file->getName(),\n\t\t\t\t\t'type' => $file->getMimeType(),\n\t\t\t\t\t'path' => $uploadFilePath,\n\t\t\t\t\t'createdtime' => date('Y-m-d H:i:s'),\n\t\t\t\t\t'fieldname' => $request->getByType('field', 'Alnum'),\n\t\t\t\t\t'key' => $key,\n\t\t\t\t\t'crmid' => $request->isEmpty('record') ? 0 : $request->getInteger('record'),\n\t\t\t\t])->execute();\n\t\t\t\tif (move_uploaded_file($file->getPath(), $uploadFilePath . $key)) {\n\t\t\t\t\t$attach[] = [\n\t\t\t\t\t\t'name' => $file->getName(),\n\t\t\t\t\t\t'size' => \\vtlib\\Functions::showBytes($file->getSize()),\n\t\t\t\t\t\t'key' => $key,\n\t\t\t\t\t\t'hash' => $request->getByType('hash', 'Alnum'),\n\t\t\t\t\t\t'info' => $additionalNotes,\n\t\t\t\t\t];\n\t\t\t\t} else {\n\t\t\t\t\t$db->createCommand()->delete(static::TABLE_NAME_TEMP, ['key' => $key])->execute();\n\t\t\t\t\tLog::error(\"Moves an uploaded file to a new location failed: {$uploadFilePath}\");\n\t\t\t\t\t$attach[] = ['hash' => $request->getByType('hash', 'Alnum'), 'name' => $file->getName(), 'error' => ''];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $attach;\n\t}\n\n\t/**\n\t * Update upload files.\n\t *\n\t * @param array                $value\n\t * @param \\Vtiger_Record_Model $recordModel\n\t * @param \\Vtiger_Field_Model  $fieldModel\n\t *\n\t * @return array\n\t */\n\tpublic static function updateUploadFiles(array $value, \\Vtiger_Record_Model $recordModel, \\Vtiger_Field_Model $fieldModel)\n\t{\n\t\t$previousValue = $recordModel->get($fieldModel->getName());\n\t\t$previousValue = ($previousValue && !\\App\\Json::isEmpty($previousValue)) ? static::parse(\\App\\Json::decode($previousValue)) : [];\n\t\t$value = static::parse($value);\n\t\t$new = [];\n\t\t$save = false;\n\t\tforeach ($value as $key => $item) {\n\t\t\tif (isset($previousValue[$item['key']])) {\n\t\t\t\t$value[$item['key']] = $previousValue[$item['key']];\n\t\t\t} elseif (!empty($item['baseContent'])) {\n\t\t\t\t$base = static::saveFromBase($item, $recordModel->getModuleName());\n\t\t\t\t$new[] = $value[$base['key']] = $base;\n\t\t\t\tunset($value[$key]);\n\t\t\t\t$save = true;\n\t\t\t} elseif ($item['key'] ? ($uploadFile = static::getUploadFile($item['key'])) : null) {\n\t\t\t\t$new[] = $value[$item['key']] = [\n\t\t\t\t\t'name' => $uploadFile['name'],\n\t\t\t\t\t'size' => $item['size'],\n\t\t\t\t\t'path' => $uploadFile['path'] . $item['key'],\n\t\t\t\t\t'key' => $item['key'],\n\t\t\t\t];\n\t\t\t\t$save = true;\n\t\t\t}\n\t\t}\n\t\tforeach ($previousValue as $item) {\n\t\t\tif (!isset($value[$item['key']])) {\n\t\t\t\t$save = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn [array_values($value), $new, $save];\n\t}\n\n\t/**\n\t * Delete data from the temporary table.\n\t *\n\t * @param string|string[] $keys\n\t *\n\t * @return int\n\t */\n\tpublic static function cleanTemp($keys)\n\t{\n\t\treturn \\App\\Db::getInstance()->createCommand()->delete(static::TABLE_NAME_TEMP, ['key' => $keys])->execute();\n\t}\n\n\t/**\n\t * Secure image file.\n\t *\n\t * @param \\App\\Fields\\File $file\n\t *\n\t * @return bool\n\t */\n\tpublic static function secureFile(self $file): bool\n\t{\n\t\tif ('image' !== $file->getShortMimeType(0)) {\n\t\t\treturn false;\n\t\t}\n\t\t$result = false;\n\t\tif (\\extension_loaded('imagick')) {\n\t\t\ttry {\n\t\t\t\t$img = new \\imagick($file->getPath());\n\t\t\t\t$img->stripImage();\n\t\t\t\tswitch ($file->getExtension()) {\n\t\t\t\t\tcase 'jpg':\n\t\t\t\t\tcase 'jpeg':\n\t\t\t\t\t\t$img->setImageCompression(\\Imagick::COMPRESSION_JPEG);\n\t\t\t\t\t\t$img->setImageCompressionQuality(99);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t$img->writeImage($file->getPath());\n\t\t\t\t$img->clear();\n\t\t\t\t$img->destroy();\n\t\t\t\t$result = true;\n\t\t\t} catch (\\ImagickException $e) {\n\t\t\t\t$result = false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (\\in_array($file->getExtension(), ['jpeg', 'png', 'gif', 'bmp', 'wbmp', 'gd2', 'webp'])) {\n\t\t\t\t$img = \\imagecreatefromstring($file->getContents());\n\t\t\t\tif (false !== $img) {\n\t\t\t\t\tswitch ($file->getExtension()) {\n\t\t\t\t\t\tcase 'jpg':\n\t\t\t\t\t\tcase 'jpeg':\n\t\t\t\t\t\t\t$result = \\imagejpeg($img, $file->getPath());\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'png':\n\t\t\t\t\t\t\t$result = \\imagepng($img, $file->getPath());\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'gif':\n\t\t\t\t\t\t\t$result = \\imagegif($img, $file->getPath());\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'bmp':\n\t\t\t\t\t\t\t$result = \\imagebmp($img, $file->getPath());\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\\imagedestroy($img);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $result;\n\t}\n\n\t/**\n\t * Parse.\n\t *\n\t * @param array $value\n\t *\n\t * @return array\n\t */\n\tpublic static function parse(array $value)\n\t{\n\t\treturn array_reduce($value, function ($result, $item) {\n\t\t\tif (isset($item['key'])) {\n\t\t\t\t$result[$item['key']] = $item;\n\t\t\t}\n\t\t\treturn $result;\n\t\t}, []);\n\t}\n\n\t/**\n\t * Get upload file details from db.\n\t *\n\t * @param string $key\n\t *\n\t * @return array\n\t */\n\tpublic static function getUploadFile(string $key)\n\t{\n\t\t$row = (new \\App\\Db\\Query())->from(static::TABLE_NAME_TEMP)->where(['key' => $key])->one();\n\t\treturn $row ?: [];\n\t}\n\n\t/**\n\t * Check is it an allowed directory.\n\t *\n\t * @param string $fullPath\n\t *\n\t * @return bool\n\t */\n\tpublic static function isAllowedDirectory(string $fullPath)\n\t{\n\t\treturn !(!is_readable($fullPath) || !is_dir($fullPath) || is_file($fullPath));\n\t}\n\n\t/**\n\t * Check is it an allowed file directory.\n\t *\n\t * @param string $fullPath\n\t *\n\t * @return bool\n\t */\n\tpublic static function isAllowedFileDirectory(string $fullPath)\n\t{\n\t\treturn !(!is_readable($fullPath) || is_dir($fullPath) || !is_file($fullPath));\n\t}\n\n\t/**\n\t * CheckFilePath.\n\t *\n\t * @param string $path\n\t *\n\t * @return bool\n\t */\n\tpublic static function checkFilePath(string $path)\n\t{\n\t\tpreg_match('[^\\\\w\\\\s\\\\d\\\\.\\\\-_~,;:\\\\[\\\\]\\\\(\\\\]]', $path, $matches);\n\t\tif ($matches) {\n\t\t\treturn true;\n\t\t}\n\t\t$absolutes = ['YetiTemp'];\n\t\tforeach (array_filter(explode('/', str_replace(['/', '\\\\'], '/', $path)), 'strlen') as $part) {\n\t\t\tif ('.' === $part) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ('..' === $part) {\n\t\t\t\tarray_pop($absolutes);\n\t\t\t} else {\n\t\t\t\t$absolutes[] = $part;\n\t\t\t}\n\t\t}\n\t\treturn 'YetiTemp' === $absolutes[0];\n\t}\n\n\t/**\n\t * Save file from base64 encoded string.\n\t *\n\t * @param string $raw        base64 string\n\t * @param string $moduleName Destination record module name\n\t *\n\t * @return array\n\t */\n\tpublic static function saveFromBase($raw, $moduleName): array\n\t{\n\t\t$file = static::loadFromContent(\\base64_decode($raw['baseContent']), $raw['name']);\n\t\t$savePath = static::initStorageFileDirectory($moduleName);\n\t\t$key = $file->generateHash(true, $savePath);\n\t\tif ($file->moveFile($savePath . $key)) {\n\t\t\treturn [\n\t\t\t\t'name' => $file->getName(),\n\t\t\t\t'size' => \\vtlib\\Functions::showBytes($file->getSize()),\n\t\t\t\t'key' => $key,\n\t\t\t\t'hash' => \\md5_file($savePath . $key),\n\t\t\t\t'path' => $savePath . $key,\n\t\t\t];\n\t\t}\n\t\t$file->delete();\n\t\treturn [];\n\t}\n\n\t/**\n\t * Save file from given url.\n\t *\n\t * @param string      $url\n\t * @param string      $moduleName\n\t * @param string|bool $type\n\t *\n\t * @return array\n\t */\n\tpublic static function saveImageFromUrl(string $url, string $moduleName, $type = false): array\n\t{\n\t\t$value = [];\n\t\tif ($file = static::loadFromUrl($url)) {\n\t\t\tif ($file->validateAndSecure($type)) {\n\t\t\t\t$savePath = static::initStorageFileDirectory($moduleName);\n\t\t\t\t$key = $file->generateHash(true, $savePath);\n\t\t\t\tif ($file->moveFile($savePath . $key)) {\n\t\t\t\t\t$value = [\n\t\t\t\t\t\t'name' => $file->getName(),\n\t\t\t\t\t\t'size' => \\vtlib\\Functions::showBytes($file->getSize()),\n\t\t\t\t\t\t'key' => $key,\n\t\t\t\t\t\t'hash' => \\md5_file($savePath . $key),\n\t\t\t\t\t\t'path' => $savePath . $key,\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$file->delete();\n\t\t\t}\n\t\t}\n\t\treturn $value;\n\t}\n}\n", "<?php\n\nreturn [\n\t'appVersion' => '6.3.6',\n\t'patchVersion' => '2021.12.14',\n\t'lib_roundcube' => '0.2.3',\n];\n", "{\n  \"php\": {\n    \"ERR_ILLEGAL_VALUE\": \"Illegal value\",\n    \"ERR_SCRIPT_EXISTS_FUNCTION_NOT\": \"Script exists but doesn't contain imported function name.\",\n    \"ERR_FAILED_TO_SAVE_SCRIPT\": \"Failed to save workflow methods script file.\",\n    \"ERR_ILLEGAL_FIELD_VALUE\": \"Illegal value has been entered for this field type. Field name: %s, Module: %s, Value: %s\",\n    \"ERR_VALUE_IS_TOO_LONG\": \"Character limit exceeded. Field name: %s, Module: %s, Value: %s\",\n    \"ERR_TO_MANY_FILES\": \"Too many files transferred - limit was exceeded. Field name: %s, Module: %s, Value: %s\",\n    \"ERR_VALUE_CAN_NOT_BE_LESS_THAN_ZERO\": \"The field value must be greater than zero. Field name: %s, Module: %s, Value: %s\",\n    \"ERR_NOT_ALLOWED_VALUE\": \"Incorrect value detected, please contact your administrator\",\n    \"ERR_PASSWORD_HAS_ALREADY_BEEN_USED\": \"This password has already been used. The system does not allow to use the same password for security reasons.\",\n    \"ERR_USER_EXISTS\": \"User with the same username and role already exists (%s)\",\n    \"ERR_NOT_ACCESSIBLE\": \"Access denied\",\n    \"ERR_DUPLICATE_LOGIN\": \"The specified login already exists.\",\n    \"ERR_NO_PERMISSIONS_FOR_THE_RECORD\": \"You don't have the permissions required to view/edit this record. Contact the administrator if you should have the permission to view it.\",\n    \"ERR_CONTENTS_VARIABLE_CANT_CALLED_FUNCTION\": \"Variable (%s) content cannot be triggered as function\",\n    \"ERR_DUPLICATES_VALUES_FOUND\": \"Duplicated %s values found\",\n    \"ERR_EXCEEDED_NUMBER_CHARACTERS\": \"Exceeded number of characters\",\n    \"ERR_SPECIAL_CHARACTERS_NOT_ALLOWED\": \"Special characters such as %s are not allowed\",\n    \"ERR_CREATE_FILE_FAILURE\": \"Failed to create file\",\n    \"ERR_FILE_WRONG_SIZE\": \"Wrong file size\",\n    \"ERR_FILE_EMPTY_NAME\": \"File name is empty\",\n    \"ERR_FILE_ERROR_REQUEST\": \"File transfer error: %s\",\n    \"ERR_FILE_ILLEGAL_FORMAT\": \"Illegal file format\",\n    \"ERR_FILE_ILLEGAL_NAME\": \"Illegal file name\",\n    \"ERR_FILE_WRONG_IMAGE\": \"Wrong image file\",\n    \"ERR_FILE_CODE_INJECTION\": \"File contains dangerous code and was rejected\",\n    \"ERR_FILE_XPACKET_CODE_INJECTION\": \"File contains dangerous XPACKET code and was rejected\",\n    \"ERR_NO_PERMISSIONS_TO_CREATE_DIRECTORIES\": \"No permissions to create directories\",\n    \"ERR_DIRECTORY_CANNOT_BE_CREATED\": \"The directory cannot be created\",\n    \"ERR_AUTO_LOGOUT\": \"Logged out automatically due to no activity\",\n    \"ERR_FIELD_NOT_FOUND\": \"Field not found (%s)\",\n    \"ERR_NUMBER_OF_ARGUMENTS_NOT_ALLOWED\": \"Number of arguments not allowed (%d %s in %s)\",\n    \"ERR_NO_VALUE\": \"No value in %s\",\n    \"ERR_BODY_IS_EMPTY\": \"Body is empty\",\n    \"ERR_API\": \"Error in API\",\n    \"ERR_MODULE_DOES_NOT_EXIST\": \"Module %s does not exist\",\n    \"ERR_RECORD_NOT_FOUND\": \"There is no record with ID: %s\",\n    \"ERR_NO_PERMISSIONS_TO_FIELD\": \"No permissions to the field\",\n    \"ERR_NO_PERMITTED_TO_VIEW\": \"No permissions to view\",\n    \"ERR_CURRENCY_TABLE_DOWNLOAD\": \"Error while downloading the exchange rate table.\",\n    \"ERR_ITERATIONS_LIMIT_EXCEEDED\": \"Exceeded iteration limit.\",\n    \"ERR_CANNOT_PARSE_SERVER_RESPONSE\": \"Error while parsing server responses\",\n    \"ERR_CANNOT_CONNECT_TO_REMOTE\": \"Error while connecting to remote server\",\n    \"ERR_NO_INTERNET_CONNECTION\": \"No Internet connection\",\n    \"ERR_OBJECT_MUST_HAVE_INTERFACE\": \"The object must have an interface %s\",\n    \"ERR_CLASS_NOT_FOUND\": \"Class %s not found\",\n    \"ERR_CLASS_MUST_BE\": \"Class must be %s\",\n    \"ERR_PAID_FUNCTIONALITY\": \"%s paid functionality, you must purchase it\",\n    \"ERR_TOKEN_DOES_NOT_EXIST\": \"The token does not exist or has expired\",\n    \"ERR_NO_TOKEN\": \"No token\",\n    \"ERR_INCORRECT_2FA_TOTP_CODE\": \"Incorrect 2FA TOTP code\",\n    \"ERR_NO_2FA_TOTP_CODE\": \"No 2FA TOTP code\"\n  }\n}\n"], "filenames": ["app/Fields/File.php", "config/version.php", "languages/en-US/Other/Exceptions.json"], "buggy_code_start_loc": [127, 4, 24], "buggy_code_end_loc": [1306, 5, 27], "fixing_code_start_loc": [128, 4, 25], "fixing_code_end_loc": [1329, 5, 28], "type": "CWE-79", "message": "yetiforcecrm is vulnerable to Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "other": {"cve": {"id": "CVE-2021-4116", "sourceIdentifier": "security@huntr.dev", "published": "2021-12-15T14:15:07.667", "lastModified": "2021-12-17T14:32:11.577", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "yetiforcecrm is vulnerable to Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"}, {"lang": "es", "value": "yetiforcecrm es vulnerable a una Neutralizaci\u00f3n Inapropiada de Entradas Durante la Generaci\u00f3n de P\u00e1ginas Web (\"Cross-site Scripting\")"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:R/S:C/C:L/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 5.3}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:yetiforce:yetiforce_customer_relationship_management:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.3.0", "matchCriteriaId": "9857A26D-84A8-4AE3-BCFC-B198918970C8"}]}]}], "references": [{"url": "https://github.com/yetiforcecompany/yetiforcecrm/commit/9cdb012ca64ff1f719f8120d5fd162cd5ef1013f", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/7561bae7-9053-4dc8-aa59-b71acfb1712c", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/yetiforcecompany/yetiforcecrm/commit/9cdb012ca64ff1f719f8120d5fd162cd5ef1013f"}}