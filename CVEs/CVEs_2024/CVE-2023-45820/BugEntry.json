{"buggy_code": ["import type { Accountability } from '@directus/types';\nimport { parseJSON } from '@directus/utils';\nimport type { IncomingMessage, Server as httpServer } from 'http';\nimport type { ParsedUrlQuery } from 'querystring';\nimport type { RateLimiterAbstract } from 'rate-limiter-flexible';\nimport type internal from 'stream';\nimport { parse } from 'url';\nimport { v4 as uuid } from 'uuid';\nimport WebSocket, { WebSocketServer } from 'ws';\nimport { fromZodError } from 'zod-validation-error';\nimport emitter from '../../emitter.js';\nimport env from '../../env.js';\nimport { InvalidProviderConfigError, TokenExpiredError } from '../../errors/index.js';\nimport logger from '../../logger.js';\nimport { createRateLimiter } from '../../rate-limiter.js';\nimport { getAccountabilityForToken } from '../../utils/get-accountability-for-token.js';\nimport { toBoolean } from '../../utils/to-boolean.js';\nimport { authenticateConnection, authenticationSuccess } from '../authenticate.js';\nimport { WebSocketError, handleWebSocketError } from '../errors.js';\nimport { AuthMode, WebSocketAuthMessage, WebSocketMessage } from '../messages.js';\nimport type { AuthenticationState, UpgradeContext, WebSocketClient } from '../types.js';\nimport { getExpiresAtForToken } from '../utils/get-expires-at-for-token.js';\nimport { getMessageType } from '../utils/message.js';\nimport { waitForAnyMessage, waitForMessageType } from '../utils/wait-for-message.js';\nimport { registerWebSocketEvents } from './hooks.js';\n\nconst TOKEN_CHECK_INTERVAL = 15 * 60 * 1000; // 15 minutes\n\nexport default abstract class SocketController {\n\tserver: WebSocket.Server;\n\tclients: Set<WebSocketClient>;\n\tauthentication: {\n\t\tmode: AuthMode;\n\t\ttimeout: number;\n\t};\n\n\tendpoint: string;\n\tmaxConnections: number;\n\tprivate rateLimiter: RateLimiterAbstract | null;\n\tprivate authInterval: NodeJS.Timer | null;\n\n\tconstructor(httpServer: httpServer, configPrefix: string) {\n\t\tthis.server = new WebSocketServer({ noServer: true });\n\t\tthis.clients = new Set();\n\t\tthis.authInterval = null;\n\n\t\tconst { endpoint, authentication, maxConnections } = this.getEnvironmentConfig(configPrefix);\n\t\tthis.endpoint = endpoint;\n\t\tthis.authentication = authentication;\n\t\tthis.maxConnections = maxConnections;\n\t\tthis.rateLimiter = this.getRateLimiter();\n\n\t\thttpServer.on('upgrade', this.handleUpgrade.bind(this));\n\t\tthis.checkClientTokens();\n\t\tregisterWebSocketEvents();\n\t}\n\n\tprotected getEnvironmentConfig(configPrefix: string): {\n\t\tendpoint: string;\n\t\tauthentication: {\n\t\t\tmode: AuthMode;\n\t\t\ttimeout: number;\n\t\t};\n\t\tmaxConnections: number;\n\t} {\n\t\tconst endpoint = String(env[`${configPrefix}_PATH`]);\n\t\tconst authMode = AuthMode.safeParse(String(env[`${configPrefix}_AUTH`]).toLowerCase());\n\t\tconst authTimeout = Number(env[`${configPrefix}_AUTH_TIMEOUT`]) * 1000;\n\n\t\tconst maxConnections =\n\t\t\t`${configPrefix}_CONN_LIMIT` in env ? Number(env[`${configPrefix}_CONN_LIMIT`]) : Number.POSITIVE_INFINITY;\n\n\t\tif (!authMode.success) {\n\t\t\tthrow new InvalidProviderConfigError({\n\t\t\t\tprovider: 'ws',\n\t\t\t\treason: fromZodError(authMode.error, { prefix: `${configPrefix}_AUTH` }).message,\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\tendpoint,\n\t\t\tmaxConnections,\n\t\t\tauthentication: {\n\t\t\t\tmode: authMode.data,\n\t\t\t\ttimeout: authTimeout,\n\t\t\t},\n\t\t};\n\t}\n\n\tprotected getRateLimiter() {\n\t\tif (toBoolean(env['RATE_LIMITER_ENABLED']) === true) {\n\t\t\treturn createRateLimiter('RATE_LIMITER', {\n\t\t\t\tkeyPrefix: 'websocket',\n\t\t\t});\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprotected async handleUpgrade(request: IncomingMessage, socket: internal.Duplex, head: Buffer) {\n\t\tconst { pathname, query } = parse(request.url!, true);\n\t\tif (pathname !== this.endpoint) return;\n\n\t\tif (this.clients.size >= this.maxConnections) {\n\t\t\tlogger.debug('WebSocket upgrade denied - max connections reached');\n\t\t\tsocket.write('HTTP/1.1 403 Forbidden\\r\\n\\r\\n');\n\t\t\tsocket.destroy();\n\t\t\treturn;\n\t\t}\n\n\t\tconst context: UpgradeContext = { request, socket, head };\n\n\t\tif (this.authentication.mode === 'strict') {\n\t\t\tawait this.handleStrictUpgrade(context, query);\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.authentication.mode === 'handshake') {\n\t\t\tawait this.handleHandshakeUpgrade(context);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.server.handleUpgrade(request, socket, head, async (ws) => {\n\t\t\tconst state = { accountability: null, expires_at: null } as AuthenticationState;\n\t\t\tthis.server.emit('connection', ws, state);\n\t\t});\n\t}\n\n\tprotected async handleStrictUpgrade({ request, socket, head }: UpgradeContext, query: ParsedUrlQuery) {\n\t\tlet accountability: Accountability | null, expires_at: number | null;\n\n\t\ttry {\n\t\t\tconst token = query['access_token'] as string;\n\t\t\taccountability = await getAccountabilityForToken(token);\n\t\t\texpires_at = getExpiresAtForToken(token);\n\t\t} catch {\n\t\t\taccountability = null;\n\t\t\texpires_at = null;\n\t\t}\n\n\t\tif (!accountability || !accountability.user) {\n\t\t\tlogger.debug('WebSocket upgrade denied - ' + JSON.stringify(accountability || 'invalid'));\n\t\t\tsocket.write('HTTP/1.1 401 Unauthorized\\r\\n\\r\\n');\n\t\t\tsocket.destroy();\n\t\t\treturn;\n\t\t}\n\n\t\tthis.server.handleUpgrade(request, socket, head, async (ws) => {\n\t\t\tconst state = { accountability, expires_at } as AuthenticationState;\n\t\t\tthis.server.emit('connection', ws, state);\n\t\t});\n\t}\n\n\tprotected async handleHandshakeUpgrade({ request, socket, head }: UpgradeContext) {\n\t\tthis.server.handleUpgrade(request, socket, head, async (ws) => {\n\t\t\ttry {\n\t\t\t\tconst payload = await waitForAnyMessage(ws, this.authentication.timeout);\n\t\t\t\tif (getMessageType(payload) !== 'auth') throw new Error();\n\n\t\t\t\tconst state = await authenticateConnection(WebSocketAuthMessage.parse(payload));\n\t\t\t\tws.send(authenticationSuccess(payload['uid'], state.refresh_token));\n\t\t\t\tthis.server.emit('connection', ws, state);\n\t\t\t} catch {\n\t\t\t\tlogger.debug('WebSocket authentication handshake failed');\n\t\t\t\tconst error = new WebSocketError('auth', 'AUTH_FAILED', 'Authentication handshake failed.');\n\t\t\t\thandleWebSocketError(ws, error, 'auth');\n\t\t\t\tws.close();\n\t\t\t}\n\t\t});\n\t}\n\n\tcreateClient(ws: WebSocket, { accountability, expires_at }: AuthenticationState) {\n\t\tconst client = ws as WebSocketClient;\n\t\tclient.accountability = accountability;\n\t\tclient.expires_at = expires_at;\n\t\tclient.uid = uuid();\n\t\tclient.auth_timer = null;\n\n\t\tws.on('message', async (data: WebSocket.RawData) => {\n\t\t\tif (this.rateLimiter !== null) {\n\t\t\t\ttry {\n\t\t\t\t\tawait this.rateLimiter.consume(client.uid);\n\t\t\t\t} catch (limit) {\n\t\t\t\t\tconst timeout = (limit as any)?.msBeforeNext ?? this.rateLimiter.msDuration;\n\n\t\t\t\t\tconst error = new WebSocketError(\n\t\t\t\t\t\t'server',\n\t\t\t\t\t\t'REQUESTS_EXCEEDED',\n\t\t\t\t\t\t`Too many messages, retry after ${timeout}ms.`\n\t\t\t\t\t);\n\n\t\t\t\t\thandleWebSocketError(client, error, 'server');\n\t\t\t\t\tlogger.debug(`WebSocket#${client.uid} is rate limited`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet message: WebSocketMessage;\n\n\t\t\ttry {\n\t\t\t\tmessage = this.parseMessage(data.toString());\n\t\t\t} catch (err: any) {\n\t\t\t\thandleWebSocketError(client, err, 'server');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (getMessageType(message) === 'auth') {\n\t\t\t\ttry {\n\t\t\t\t\tawait this.handleAuthRequest(client, WebSocketAuthMessage.parse(message));\n\t\t\t\t} catch {\n\t\t\t\t\t// ignore errors\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// this log cannot be higher in the function or it will leak credentials\n\t\t\tlogger.trace(`WebSocket#${client.uid} - ${JSON.stringify(message)}`);\n\t\t\tws.emit('parsed-message', message);\n\t\t});\n\n\t\tws.on('error', () => {\n\t\t\tlogger.debug(`WebSocket#${client.uid} connection errored`);\n\n\t\t\tif (client.auth_timer) {\n\t\t\t\tclearTimeout(client.auth_timer);\n\t\t\t\tclient.auth_timer = null;\n\t\t\t}\n\n\t\t\tthis.clients.delete(client);\n\t\t});\n\n\t\tws.on('close', () => {\n\t\t\tlogger.debug(`WebSocket#${client.uid} connection closed`);\n\n\t\t\tif (client.auth_timer) {\n\t\t\t\tclearTimeout(client.auth_timer);\n\t\t\t\tclient.auth_timer = null;\n\t\t\t}\n\n\t\t\tthis.clients.delete(client);\n\t\t});\n\n\t\tlogger.debug(`WebSocket#${client.uid} connected`);\n\n\t\tif (accountability) {\n\t\t\tlogger.trace(`WebSocket#${client.uid} authenticated as ${JSON.stringify(accountability)}`);\n\t\t}\n\n\t\tthis.setTokenExpireTimer(client);\n\t\tthis.clients.add(client);\n\t\treturn client;\n\t}\n\n\tprotected parseMessage(data: string): WebSocketMessage {\n\t\tlet message: WebSocketMessage;\n\n\t\ttry {\n\t\t\tmessage = WebSocketMessage.parse(parseJSON(data));\n\t\t} catch (err: any) {\n\t\t\tthrow new WebSocketError('server', 'INVALID_PAYLOAD', 'Unable to parse the incoming message.');\n\t\t}\n\n\t\treturn message;\n\t}\n\n\tprotected async handleAuthRequest(client: WebSocketClient, message: WebSocketAuthMessage) {\n\t\ttry {\n\t\t\tconst { accountability, expires_at, refresh_token } = await authenticateConnection(message);\n\t\t\tclient.accountability = accountability;\n\t\t\tclient.expires_at = expires_at;\n\t\t\tthis.setTokenExpireTimer(client);\n\t\t\temitter.emitAction('websocket.auth.success', { client });\n\t\t\tclient.send(authenticationSuccess(message.uid, refresh_token));\n\t\t\tlogger.trace(`WebSocket#${client.uid} authenticated as ${JSON.stringify(client.accountability)}`);\n\t\t} catch (error) {\n\t\t\tlogger.trace(`WebSocket#${client.uid} failed authentication`);\n\t\t\temitter.emitAction('websocket.auth.failure', { client });\n\n\t\t\tclient.accountability = null;\n\t\t\tclient.expires_at = null;\n\n\t\t\tconst _error =\n\t\t\t\terror instanceof WebSocketError\n\t\t\t\t\t? error\n\t\t\t\t\t: new WebSocketError('auth', 'AUTH_FAILED', 'Authentication failed.', message.uid);\n\n\t\t\thandleWebSocketError(client, _error, 'auth');\n\n\t\t\tif (this.authentication.mode !== 'public') {\n\t\t\t\tclient.close();\n\t\t\t}\n\t\t}\n\t}\n\n\tsetTokenExpireTimer(client: WebSocketClient) {\n\t\tif (client.auth_timer !== null) {\n\t\t\t// clear up old timeouts if needed\n\t\t\tclearTimeout(client.auth_timer);\n\t\t\tclient.auth_timer = null;\n\t\t}\n\n\t\tif (!client.expires_at) return;\n\n\t\tconst expiresIn = client.expires_at * 1000 - Date.now();\n\t\tif (expiresIn > TOKEN_CHECK_INTERVAL) return;\n\n\t\tclient.auth_timer = setTimeout(() => {\n\t\t\tclient.accountability = null;\n\t\t\tclient.expires_at = null;\n\t\t\thandleWebSocketError(client, new TokenExpiredError(), 'auth');\n\n\t\t\twaitForMessageType(client, 'auth', this.authentication.timeout).catch((msg: WebSocketMessage) => {\n\t\t\t\tconst error = new WebSocketError('auth', 'AUTH_TIMEOUT', 'Authentication timed out.', msg?.uid);\n\t\t\t\thandleWebSocketError(client, error, 'auth');\n\n\t\t\t\tif (this.authentication.mode !== 'public') {\n\t\t\t\t\tclient.close();\n\t\t\t\t}\n\t\t\t});\n\t\t}, expiresIn);\n\t}\n\n\tcheckClientTokens() {\n\t\tthis.authInterval = setInterval(() => {\n\t\t\tif (this.clients.size === 0) return;\n\n\t\t\t// check the clients and set shorter timeouts if needed\n\t\t\tfor (const client of this.clients) {\n\t\t\t\tif (client.expires_at === null || client.auth_timer !== null) continue;\n\t\t\t\tthis.setTokenExpireTimer(client);\n\t\t\t}\n\t\t}, TOKEN_CHECK_INTERVAL);\n\t}\n\n\tterminate() {\n\t\tif (this.authInterval) clearInterval(this.authInterval);\n\n\t\tthis.clients.forEach((client) => {\n\t\t\tif (client.auth_timer) clearTimeout(client.auth_timer);\n\t\t});\n\n\t\tthis.server.clients.forEach((ws) => {\n\t\t\tws.terminate();\n\t\t});\n\t}\n}\n"], "fixing_code": ["import type { Accountability } from '@directus/types';\nimport { parseJSON } from '@directus/utils';\nimport type { IncomingMessage, Server as httpServer } from 'http';\nimport type { ParsedUrlQuery } from 'querystring';\nimport type { RateLimiterAbstract } from 'rate-limiter-flexible';\nimport type internal from 'stream';\nimport { parse } from 'url';\nimport { v4 as uuid } from 'uuid';\nimport WebSocket, { WebSocketServer } from 'ws';\nimport { fromZodError } from 'zod-validation-error';\nimport emitter from '../../emitter.js';\nimport env from '../../env.js';\nimport { InvalidProviderConfigError, TokenExpiredError } from '../../errors/index.js';\nimport logger from '../../logger.js';\nimport { createRateLimiter } from '../../rate-limiter.js';\nimport { getAccountabilityForToken } from '../../utils/get-accountability-for-token.js';\nimport { toBoolean } from '../../utils/to-boolean.js';\nimport { authenticateConnection, authenticationSuccess } from '../authenticate.js';\nimport { WebSocketError, handleWebSocketError } from '../errors.js';\nimport { AuthMode, WebSocketAuthMessage, WebSocketMessage } from '../messages.js';\nimport type { AuthenticationState, UpgradeContext, WebSocketClient } from '../types.js';\nimport { getExpiresAtForToken } from '../utils/get-expires-at-for-token.js';\nimport { getMessageType } from '../utils/message.js';\nimport { waitForAnyMessage, waitForMessageType } from '../utils/wait-for-message.js';\nimport { registerWebSocketEvents } from './hooks.js';\n\nconst TOKEN_CHECK_INTERVAL = 15 * 60 * 1000; // 15 minutes\n\nexport default abstract class SocketController {\n\tserver: WebSocket.Server;\n\tclients: Set<WebSocketClient>;\n\tauthentication: {\n\t\tmode: AuthMode;\n\t\ttimeout: number;\n\t};\n\n\tendpoint: string;\n\tmaxConnections: number;\n\tprivate rateLimiter: RateLimiterAbstract | null;\n\tprivate authInterval: NodeJS.Timer | null;\n\n\tconstructor(httpServer: httpServer, configPrefix: string) {\n\t\tthis.server = new WebSocketServer({ noServer: true });\n\t\tthis.clients = new Set();\n\t\tthis.authInterval = null;\n\n\t\tconst { endpoint, authentication, maxConnections } = this.getEnvironmentConfig(configPrefix);\n\t\tthis.endpoint = endpoint;\n\t\tthis.authentication = authentication;\n\t\tthis.maxConnections = maxConnections;\n\t\tthis.rateLimiter = this.getRateLimiter();\n\n\t\thttpServer.on('upgrade', this.handleUpgrade.bind(this));\n\t\tthis.checkClientTokens();\n\t\tregisterWebSocketEvents();\n\t}\n\n\tprotected getEnvironmentConfig(configPrefix: string): {\n\t\tendpoint: string;\n\t\tauthentication: {\n\t\t\tmode: AuthMode;\n\t\t\ttimeout: number;\n\t\t};\n\t\tmaxConnections: number;\n\t} {\n\t\tconst endpoint = String(env[`${configPrefix}_PATH`]);\n\t\tconst authMode = AuthMode.safeParse(String(env[`${configPrefix}_AUTH`]).toLowerCase());\n\t\tconst authTimeout = Number(env[`${configPrefix}_AUTH_TIMEOUT`]) * 1000;\n\n\t\tconst maxConnections =\n\t\t\t`${configPrefix}_CONN_LIMIT` in env ? Number(env[`${configPrefix}_CONN_LIMIT`]) : Number.POSITIVE_INFINITY;\n\n\t\tif (!authMode.success) {\n\t\t\tthrow new InvalidProviderConfigError({\n\t\t\t\tprovider: 'ws',\n\t\t\t\treason: fromZodError(authMode.error, { prefix: `${configPrefix}_AUTH` }).message,\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\tendpoint,\n\t\t\tmaxConnections,\n\t\t\tauthentication: {\n\t\t\t\tmode: authMode.data,\n\t\t\t\ttimeout: authTimeout,\n\t\t\t},\n\t\t};\n\t}\n\n\tprotected getRateLimiter() {\n\t\tif (toBoolean(env['RATE_LIMITER_ENABLED']) === true) {\n\t\t\treturn createRateLimiter('RATE_LIMITER', {\n\t\t\t\tkeyPrefix: 'websocket',\n\t\t\t});\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate catchInvalidMessages(ws: WebSocket) {\n\t\t/**\n\t\t * This fix was done to prevent the API from crashing on receiving invalid WebSocket frames\n\t\t * https://github.com/directus/directus/security/advisories/GHSA-hmgw-9jrg-hf2m\n\t\t * https://github.com/websockets/ws/issues/2098\n\t\t */\n\t\t// @ts-ignore <- required because \"_socket\" is not typed on WS\n\t\tws._socket.prependListener('data', (data) => data.toString());\n\n\t\tws.on('error', (error) => {\n\t\t\tif (error.message) logger.debug(error.message);\n\t\t});\n\t}\n\n\tprotected async handleUpgrade(request: IncomingMessage, socket: internal.Duplex, head: Buffer) {\n\t\tconst { pathname, query } = parse(request.url!, true);\n\t\tif (pathname !== this.endpoint) return;\n\n\t\tif (this.clients.size >= this.maxConnections) {\n\t\t\tlogger.debug('WebSocket upgrade denied - max connections reached');\n\t\t\tsocket.write('HTTP/1.1 403 Forbidden\\r\\n\\r\\n');\n\t\t\tsocket.destroy();\n\t\t\treturn;\n\t\t}\n\n\t\tconst context: UpgradeContext = { request, socket, head };\n\n\t\tif (this.authentication.mode === 'strict') {\n\t\t\tawait this.handleStrictUpgrade(context, query);\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.authentication.mode === 'handshake') {\n\t\t\tawait this.handleHandshakeUpgrade(context);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.server.handleUpgrade(request, socket, head, async (ws) => {\n\t\t\tthis.catchInvalidMessages(ws);\n\t\t\tconst state = { accountability: null, expires_at: null } as AuthenticationState;\n\t\t\tthis.server.emit('connection', ws, state);\n\t\t});\n\t}\n\n\tprotected async handleStrictUpgrade({ request, socket, head }: UpgradeContext, query: ParsedUrlQuery) {\n\t\tlet accountability: Accountability | null, expires_at: number | null;\n\n\t\ttry {\n\t\t\tconst token = query['access_token'] as string;\n\t\t\taccountability = await getAccountabilityForToken(token);\n\t\t\texpires_at = getExpiresAtForToken(token);\n\t\t} catch {\n\t\t\taccountability = null;\n\t\t\texpires_at = null;\n\t\t}\n\n\t\tif (!accountability || !accountability.user) {\n\t\t\tlogger.debug('WebSocket upgrade denied - ' + JSON.stringify(accountability || 'invalid'));\n\t\t\tsocket.write('HTTP/1.1 401 Unauthorized\\r\\n\\r\\n');\n\t\t\tsocket.destroy();\n\t\t\treturn;\n\t\t}\n\n\t\tthis.server.handleUpgrade(request, socket, head, async (ws) => {\n\t\t\tthis.catchInvalidMessages(ws);\n\t\t\tconst state = { accountability, expires_at } as AuthenticationState;\n\t\t\tthis.server.emit('connection', ws, state);\n\t\t});\n\t}\n\n\tprotected async handleHandshakeUpgrade({ request, socket, head }: UpgradeContext) {\n\t\tthis.server.handleUpgrade(request, socket, head, async (ws) => {\n\t\t\tthis.catchInvalidMessages(ws);\n\n\t\t\ttry {\n\t\t\t\tconst payload = await waitForAnyMessage(ws, this.authentication.timeout);\n\t\t\t\tif (getMessageType(payload) !== 'auth') throw new Error();\n\n\t\t\t\tconst state = await authenticateConnection(WebSocketAuthMessage.parse(payload));\n\t\t\t\tws.send(authenticationSuccess(payload['uid'], state.refresh_token));\n\t\t\t\tthis.server.emit('connection', ws, state);\n\t\t\t} catch {\n\t\t\t\tlogger.debug('WebSocket authentication handshake failed');\n\t\t\t\tconst error = new WebSocketError('auth', 'AUTH_FAILED', 'Authentication handshake failed.');\n\t\t\t\thandleWebSocketError(ws, error, 'auth');\n\t\t\t\tws.close();\n\t\t\t}\n\t\t});\n\t}\n\n\tcreateClient(ws: WebSocket, { accountability, expires_at }: AuthenticationState) {\n\t\tconst client = ws as WebSocketClient;\n\t\tclient.accountability = accountability;\n\t\tclient.expires_at = expires_at;\n\t\tclient.uid = uuid();\n\t\tclient.auth_timer = null;\n\n\t\tws.on('message', async (data: WebSocket.RawData) => {\n\t\t\tif (this.rateLimiter !== null) {\n\t\t\t\ttry {\n\t\t\t\t\tawait this.rateLimiter.consume(client.uid);\n\t\t\t\t} catch (limit) {\n\t\t\t\t\tconst timeout = (limit as any)?.msBeforeNext ?? this.rateLimiter.msDuration;\n\n\t\t\t\t\tconst error = new WebSocketError(\n\t\t\t\t\t\t'server',\n\t\t\t\t\t\t'REQUESTS_EXCEEDED',\n\t\t\t\t\t\t`Too many messages, retry after ${timeout}ms.`\n\t\t\t\t\t);\n\n\t\t\t\t\thandleWebSocketError(client, error, 'server');\n\t\t\t\t\tlogger.debug(`WebSocket#${client.uid} is rate limited`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet message: WebSocketMessage;\n\n\t\t\ttry {\n\t\t\t\tmessage = this.parseMessage(data.toString());\n\t\t\t} catch (err: any) {\n\t\t\t\thandleWebSocketError(client, err, 'server');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (getMessageType(message) === 'auth') {\n\t\t\t\ttry {\n\t\t\t\t\tawait this.handleAuthRequest(client, WebSocketAuthMessage.parse(message));\n\t\t\t\t} catch {\n\t\t\t\t\t// ignore errors\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// this log cannot be higher in the function or it will leak credentials\n\t\t\tlogger.trace(`WebSocket#${client.uid} - ${JSON.stringify(message)}`);\n\t\t\tws.emit('parsed-message', message);\n\t\t});\n\n\t\tws.on('error', () => {\n\t\t\tlogger.debug(`WebSocket#${client.uid} connection errored`);\n\n\t\t\tif (client.auth_timer) {\n\t\t\t\tclearTimeout(client.auth_timer);\n\t\t\t\tclient.auth_timer = null;\n\t\t\t}\n\n\t\t\tthis.clients.delete(client);\n\t\t});\n\n\t\tws.on('close', () => {\n\t\t\tlogger.debug(`WebSocket#${client.uid} connection closed`);\n\n\t\t\tif (client.auth_timer) {\n\t\t\t\tclearTimeout(client.auth_timer);\n\t\t\t\tclient.auth_timer = null;\n\t\t\t}\n\n\t\t\tthis.clients.delete(client);\n\t\t});\n\n\t\tlogger.debug(`WebSocket#${client.uid} connected`);\n\n\t\tif (accountability) {\n\t\t\tlogger.trace(`WebSocket#${client.uid} authenticated as ${JSON.stringify(accountability)}`);\n\t\t}\n\n\t\tthis.setTokenExpireTimer(client);\n\t\tthis.clients.add(client);\n\t\treturn client;\n\t}\n\n\tprotected parseMessage(data: string): WebSocketMessage {\n\t\tlet message: WebSocketMessage;\n\n\t\ttry {\n\t\t\tmessage = WebSocketMessage.parse(parseJSON(data));\n\t\t} catch (err: any) {\n\t\t\tthrow new WebSocketError('server', 'INVALID_PAYLOAD', 'Unable to parse the incoming message.');\n\t\t}\n\n\t\treturn message;\n\t}\n\n\tprotected async handleAuthRequest(client: WebSocketClient, message: WebSocketAuthMessage) {\n\t\ttry {\n\t\t\tconst { accountability, expires_at, refresh_token } = await authenticateConnection(message);\n\t\t\tclient.accountability = accountability;\n\t\t\tclient.expires_at = expires_at;\n\t\t\tthis.setTokenExpireTimer(client);\n\t\t\temitter.emitAction('websocket.auth.success', { client });\n\t\t\tclient.send(authenticationSuccess(message.uid, refresh_token));\n\t\t\tlogger.trace(`WebSocket#${client.uid} authenticated as ${JSON.stringify(client.accountability)}`);\n\t\t} catch (error) {\n\t\t\tlogger.trace(`WebSocket#${client.uid} failed authentication`);\n\t\t\temitter.emitAction('websocket.auth.failure', { client });\n\n\t\t\tclient.accountability = null;\n\t\t\tclient.expires_at = null;\n\n\t\t\tconst _error =\n\t\t\t\terror instanceof WebSocketError\n\t\t\t\t\t? error\n\t\t\t\t\t: new WebSocketError('auth', 'AUTH_FAILED', 'Authentication failed.', message.uid);\n\n\t\t\thandleWebSocketError(client, _error, 'auth');\n\n\t\t\tif (this.authentication.mode !== 'public') {\n\t\t\t\tclient.close();\n\t\t\t}\n\t\t}\n\t}\n\n\tsetTokenExpireTimer(client: WebSocketClient) {\n\t\tif (client.auth_timer !== null) {\n\t\t\t// clear up old timeouts if needed\n\t\t\tclearTimeout(client.auth_timer);\n\t\t\tclient.auth_timer = null;\n\t\t}\n\n\t\tif (!client.expires_at) return;\n\n\t\tconst expiresIn = client.expires_at * 1000 - Date.now();\n\t\tif (expiresIn > TOKEN_CHECK_INTERVAL) return;\n\n\t\tclient.auth_timer = setTimeout(() => {\n\t\t\tclient.accountability = null;\n\t\t\tclient.expires_at = null;\n\t\t\thandleWebSocketError(client, new TokenExpiredError(), 'auth');\n\n\t\t\twaitForMessageType(client, 'auth', this.authentication.timeout).catch((msg: WebSocketMessage) => {\n\t\t\t\tconst error = new WebSocketError('auth', 'AUTH_TIMEOUT', 'Authentication timed out.', msg?.uid);\n\t\t\t\thandleWebSocketError(client, error, 'auth');\n\n\t\t\t\tif (this.authentication.mode !== 'public') {\n\t\t\t\t\tclient.close();\n\t\t\t\t}\n\t\t\t});\n\t\t}, expiresIn);\n\t}\n\n\tcheckClientTokens() {\n\t\tthis.authInterval = setInterval(() => {\n\t\t\tif (this.clients.size === 0) return;\n\n\t\t\t// check the clients and set shorter timeouts if needed\n\t\t\tfor (const client of this.clients) {\n\t\t\t\tif (client.expires_at === null || client.auth_timer !== null) continue;\n\t\t\t\tthis.setTokenExpireTimer(client);\n\t\t\t}\n\t\t}, TOKEN_CHECK_INTERVAL);\n\t}\n\n\tterminate() {\n\t\tif (this.authInterval) clearInterval(this.authInterval);\n\n\t\tthis.clients.forEach((client) => {\n\t\t\tif (client.auth_timer) clearTimeout(client.auth_timer);\n\t\t});\n\n\t\tthis.server.clients.forEach((ws) => {\n\t\t\tws.terminate();\n\t\t});\n\t}\n}\n"], "filenames": ["api/src/websocket/controllers/base.ts"], "buggy_code_start_loc": [99], "buggy_code_end_loc": [155], "fixing_code_start_loc": [100], "fixing_code_end_loc": [174], "type": "CWE-755", "message": "Directus is a real-time API and App dashboard for managing SQL database content. In affected versions any Directus installation that has websockets enabled can be crashed if the websocket server receives an invalid frame. A malicious user could leverage this bug to crash Directus. This issue has been addressed in version 10.6.2. Users are advised to upgrade. Users unable to upgrade should avoid using websockets.", "other": {"cve": {"id": "CVE-2023-45820", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-19T19:15:15.950", "lastModified": "2023-10-25T20:27:12.457", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Directus is a real-time API and App dashboard for managing SQL database content. In affected versions any Directus installation that has websockets enabled can be crashed if the websocket server receives an invalid frame. A malicious user could leverage this bug to crash Directus. This issue has been addressed in version 10.6.2. Users are advised to upgrade. Users unable to upgrade should avoid using websockets."}, {"lang": "es", "value": "Directus es una API y un panel de aplicaciones en tiempo real para administrar el contenido de la base de datos SQL. En las versiones afectadas, cualquier instalaci\u00f3n de Directus que tenga websockets habilitados puede fallar si el servidor websocket recibe un frame no v\u00e1lido. Un usuario malintencionado podr\u00eda aprovechar este error para bloquear Directus. Este problema se solucion\u00f3 en la versi\u00f3n 10.6.2. Se recomienda a los usuarios que actualicen. Los usuarios que no puedan actualizar deben evitar el uso de websockets."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-755"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:monospace:directus:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "10.4.0", "versionEndExcluding": "10.6.2", "matchCriteriaId": "975F0834-DF6F-42D1-8D6F-482C096BB328"}]}]}], "references": [{"url": "https://github.com/directus/directus/commit/243eed781b42d6b4948ddb8c3792bcf5b44f55bb", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/directus/directus/security/advisories/GHSA-hmgw-9jrg-hf2m", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/directus/directus/commit/243eed781b42d6b4948ddb8c3792bcf5b44f55bb"}}