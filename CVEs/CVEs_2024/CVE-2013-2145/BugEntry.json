{"buggy_code": ["[Changes for 0.70 - Thu Nov 29 01:45:54 CST 2012]\n\n* Don't check gpg version if gpg does not exist.\n\n  This avoids unnecessary warnings during installation\n  when gpg executable is not installed.\n\n  Contributed by: Kenichi Ishigaki\n\n[Changes for 0.69 - Fri Nov  2 23:04:19 CST 2012]\n\n* Support for gpg under these alternate names:\n\n    gpg gpg2 gnupg gnupg2\n\n  Contributed by: Michael Schwern\n\n[Changes for 0.68 - Fri, 13 May 2011 11:51:50 +0200]\n\n* Fix breakage introduced by 0.67 (Andreas K\u00f6nig).\n\n[Changes for 0.67 - Sun, 17 Apr 2011 16:29:23 +0200]\n\n* Better handling of \\r (Andreas K\u00f6nig, Zefram) (Closes RT#46339).\n\n[Changes for 0.66 - Fri,  6 Sep 2010 22:51:37 +0200]\n\n* Fix incompatibility with EU::Manifest 1.54 to 1.57\n  (Paul Howarth) (Closes RT#61124).\n\n[Changes for 0.65 - Fri,  3 Sep 2010 21:38:02 +0200]\n\n* Skip MYMETA (Alexandr Ciornii)\n\n[Changes for 0.64 - Sun,  9 May 2010 00:50:11 +0200]\n\n* Avoid creating gnupg configuration files for the user invoking Makefile.PL\n  (Closes RT#41978).\n* Correctly detect the version of gnupg on cygwin and add tests for it\n  (Paul Fenwick) (Closes RT#39258).\n\n[Changes for 0.63 - Sun, 28 Mar 2010 04:46:27 +0100]\n\n* Fix diagnostic message from Makefile.PL when the user dosn't have gnupg or\n  Crypt::OpenPGP (miyagawa).\n\n[Changes for 0.62 - Tue, 23 Mar 2010 22:17:39 +0100]\n\n* Change the default keyserver from the outdated pgp.mit.edu to\n  pool.sks-keyservers.net.\n\n[Changes for 0.61 - 2009\u5e7411\u670819\u65e5 \u5468\u56db 00\u664256\u520641\u79d2 CST]\n\n* Added \"=encoding utf8\" to POD to fix author name display.\n  No functional changes.\n\n[Changes for 0.60 - 2009\u5e7411\u670816\u65e5 \u5468\u4e00 22\u664248\u520654\u79d2 CST]\n\n* LICENSING CHANGE: This compilation and all individual files in it\n  are now under the nullary CC0 1.0 Universal terms:\n\n  To the extent possible under law, \u5510\u9cf3 has waived all copyright and\n  related or neighboring rights to Module-Signature.\n\n* Updated Module::Install to 0.91, prompted by Florian Ragwitz.\n\n[Changes for 0.55 - 2006-07-29]\n\n* ANDK submitted a patch to fix versioning problem when\n  the user elects to install Crypt::OpenPGP.\n\n* Major refactoring of the Makefile.PL to ease the installation process.\n\n[Changes for 0.54 - 2006-05-12]\n\n* Fixed a long-standing bug where differing end-of-line conventions\n  could cause bogus comparisons in signature checks.\n\n* Fixed another long-standing bug where CRLF text files were hashed\n  into different digests under Unix and Dosish platforms.  Now it's\n  consistently hashed as if it's been normalized to LF.\n\n* Optional dependencies are no longer installed-by-default.\n\n[Changes for 0.53 - 2006-01-31]\n\n* The explicit call to \"readline(D)\" didn't compile on earlier perls which\n  demanded either \"readline(*D)\" or \"<D>\" -- I elected the latter form.\n  Reported by: Matthew Persic\n\n* Update my author key to reflect revoked past uids.\n\n[Changes for 0.52 - 2006-01-19]\n\n* POD and source code cleanup; no functional changes.\n\n* Updated my author key to reflect my new name and identity.\n\n* Upgrade to the latest Module::Install to fix Cygwin\n  installation problems.\n  Reported by: Lyle Ziegelmiller\n\n[Changes for 0.51 - 2006-01-02]\n\n* Even more flexible CRLF handling for SIGNATURE files,\n  Contributed by: Andreas Koenig.\n\n[Changes for 0.50 - 2005-08-21]\n\n* Add support for to SHA-256, requested by Mark Shelor in light\n  of the recent SHA1 attacks.  SHA1 is still the default, but\n  you can now override this by settings MODULE_SIGNATURE_CIPHER\n  environment variable to SHA256.\n\n[Changes for 0.45 - 2005-08-09]\n\n* Andreas Koenig ported out that \"Import GPG keys?\" was asked\n  far too many times during autoinstall.\n\n[Changes for 0.44 - 2004-12-16]\n\n* Add \"pmfiles.dat\" to legacy manifest_skip routine to accomodate\n  early Win32 hacks.  Reported by Steve Hay via Michael Schwern.\n\n[Changes for 0.43 - 2004-12-16]\n\n* Updated t/0-signature.t to be more friendly with Test::More;\n  contributed by Michael Schwern.\n\n* Add $Timeout (default 3 seconds) to control the timeout for\n  probing connections to the key server.\n\n* Take account of the .ts files produced by newer MakeMakers\n  in the suggested MANIFEST.SKIP list.\n\n[Changes for 0.42 - 2004-11-20]\n\n* Move under SVK version control management; ditch keyword tags.\n\n* Michael Schwern pointed out that during development, the\n  \"signature.t\" file would keep failing. \n\n* Documented how to generate SIGNATURE files as part of \"make dist\",\n  for Module::Install, ExtUtils::MakeMaker and Module::Build users .\n\n[Changes for 0.41 - 2004-07-04]\n\n* Mark Shelor points out that support for Digest::SHA was broken.\n\n[Changes for 0.40 - 2004-07-01]\n\n* Dave Rolsky points out that GPG version detection always\n  returns '1'. (bug #6810)\n\n[Changes for 0.39 - 2004-06-17]\n\n* Supports Digest::SHA (now preferred) and Digest::SHA1::PurePerl,\n  in addition to the original Digest::SHA1 backend.\n\n* We now asks before importing the default keys,\n  also suggested by Tels.\n\n* Unknown cipher is made fatal, thanks to suggestion by Tels.\n\n* Apply Dave Rolsky's patch to verify that author's pubkey\n  is available on a keyserver. may need more work.\n\n[Changes for 0.38 - 2004-01-01]\n\n* Update to the newest Module::Install.\n\n* Not using inc/SCRIPT/ anymore.\n\n* Add \"#defaults\" and \"^blibdirs$\" to recommended MANIFEST.SKIP\n  to pacify newer ExtUtil::MakeMaker.\n\n* Starting to think about how to make \"disttest\" + \"dist\"\n  not signing twice.\n\n[Changes for 0.37 - 2003-11-06]\n\n* Move bin/cpansign to script/cpansign.\n\n* Make cpansign exit upon failure.\n\n[Changes for 0.36 - 2003-10-28]\n\n* Use sign(1) to autosign ourselves.\n\n* Soren A pointed out that hkp:// didn't work with GnuPG.\n\n[Changes for 0.25 - 2003-08-28]\n\n* Now ships with my pubkey and PAUSE's.\n\n* Interactive Makefile.PL, suggested by Jarkko.\n\n[Changes for 0.34 - 2003-08-18]\n\n* Don't ask user to install Crypt::OpenPGP if she does not have a\n  C compiler anyway.\n\n* ExtUtils::Manifest 1.38 does not support good enough skips even\n  for Makefile.PL, sigh.\n\n[Changes for 0.33 - 2003-08-12]\n\n* William Wentworth-Sheilds points out that META.yml is dynamic,\n  which makes SIGNATURE incorrect for people without either \"diff\"\n  or \"gpg\".  Fixed.\n\n[Changes for 0.32 - 2003-08-11]\n\n* Take Schwern's patch to only set _maniskip for legacy EU::Manifest.\n\n* Remove ::TieOut since we are not using it anymore.\n\n* Reduce noise for untrusted signatures to two lines.\n\n[Changes for 0.31 - 2003-08-10]\n\n* Scott R. Godin pointed out 0.30 had bad signature.  whoops.\n\n[Changes for 0.30 - 2003-08-10]\n\n* Add JHI to authors.\n\n* Patch from Michael Schwern: only let GnuPG display anything\n  if we're handling suspicious keys, not when you have added\n  the signer into the trustdb.\n\n* New global config variable, $Verbose.\n\n* MODULE_SIGNATURE_VERBOSE, MODULE_SIGNATURE_KEYSERVER and\n  MODULE_SIGNATURE_KEYSERVERPORT env variables are now respected.\n\n* Only supply _default_skip if our ExtUtils::MakeMaker is too old.\n\n[Changes for 0.29 - 2003-08-08]\n\n* Now fails gracefully all the time, including when incapable of\n  connecting to the keyserver.\n\n* Also, SHA1 sum is still checked even if the user does not have\n  GnuPg/Crypt::OpenPGP.\n\n* Hence, Crypt::OpenPGP is no longer a mandatory prerequisite even\n  for users without gnupg.\n\n* \"0E0\" is now made into a constant, CANNOT_VERIFY.\n\n* Do not die() when we absolutely can't verify.\n\n* BZAJAC pointed out that we should add .svn to _default_skip.\n\n[Changes for 0.28 - 2003-07-29]\n\n* Remove Digest.pm dependency.\n\n* Don't test for \"diff -version\" anymore -- not all diffs\n  have -version, thanks again to Alan Burlison.\n\n[Changes for 0.27 - 2003-07-28]\n\n* More punctuation cleanups in POD.\n\n* Michael Schwern pointed out that successful tests shouldn't be noisy.\n\n[Changes for 0.26 - 2003-07-17]\n\n* New internal function, _verify(), that takes $sigfile as its first\n  argument, eliminating the \"local $Module::Signautre::SIGNATURE\" approach.\n\n* sign() now also takes a skip=> parameter (defaults to true)\n  about whether to respect MANIFEST.SKIP.  This needs to be\n  set to 0 to sign blib/ archives.\n\n* Officially supporting signing and verification of PAR files, using PAR::Dist.\n\n* Let's ignore warnings when performing on exe files\n\n[Changes for 0.24 - 2003-07-08]\n\n* Preliminary PAR support.\n\n[Changes for 0.23 - 2003-07-07]\n\n* Ken Williams noted that M::B now works on 5.005.\n\n[Changes for 0.22 - 2003-05-15]\n\n* Move Signature.pm to lib/Module/Signature.pm.\n\n* Switch to the Module::Install framework.\n\n* Updates TODO to reflect correspondence with andk.\n\n* Matt Southall mentioned that, if somebody has never run gpg before,\n  we need to initialize it once before running test.\n\n* Warn about potential 'Makefile' exploit as pointed out by Tels.\n  Document pending.\n\n* Bugfix for incorrect 'MALFORMED' response to signatures made from \n  older versions of GnuPG, as reported by Tels.\n\n[Changes for 0.18 - 2002-11-04]\n\n* Binary files handling on win32 was broken. (Jos Boumans)\n\n[Changes for 0.17 - 2002-10-30]\n\n* Resolve bug report by Iain Truskett: cpansign -s should not complain\n  manifest mismatch if SIGNATURE is lacking.\n\n* Also, bail out gracefully when signing fails, instead of crippling the\n  old SIGNATURE.\n\n* MANIFEST.SKIP doc lifted from Test::Signature.\n\n* Minor POD fixups.\n\n[Changes for 0.16 - 2002-10-28]\n\n* Adds AUTHORS file.\n\n* Added connectivity probing for testing.\n\n* Print a helpful success message after signing.\n\n* Don't cripple old SIGNATURE file.\n\n* Suggestion from Tels: skip the ambiguous 'optional'\n  probing for Crypt::OpenPGP if gnupg is there.\n\n[Changes for 0.15 - 2002-10-17]\n\n* Fixed compatibility with old MakeMaker versions, thanks to chromatic.\n\n* Fixed \"no /dev/tty\" bug during smoke testing,\n  as reported by the excellent CPAN Smokers.\n\n[Changes for 0.12 - 2002-10-12]\n\n* Supports automatic key retrieval, implemented in Crypt::OpenPGP.\n\n[Changes for 1.02 - 2002-10-12]\n\n* Fixed the default cipher from MD5 back to SHA1.\n\n[Changes for 0.10 - 2002-10-12]\n\n* Fixed a problem that prevents earlier versions of GnuPG from fetching\n  public keys via --keyserver-option=auto-key-retrieve.\n\n[Changes for 0.09 - 2002-10-12]\n\n* Documented the package variables so they become part of APIs.\n\n* Alternative (non-SHA1) ciphers in SIGNATUREs are now recognized.\n\n* Added a new return value, CIPHER_UNKNOWN.\n\n* Mention Test::Signature.\n\n* Ditch Test::More from the sample script.\n\n* Label tests.\n\n[Changes for 0.09 - 2002-10-11]\n\n* We're no longer alpha status; reflect in README.\n\n* Incoporated a suggestion from Tels: undefining the $KeyServer\n  package variable should disable automatic key-fetching.\n\n* Include the tests from Iain.\n\n* Tels: disable KeyServer fetching if it's undef'ed.\n\n[Changes for 0.07 - 2002-10-11]\n\n* Fixed our own signatures.\n\n[Changes for 0.06 - 2002-10-10]\n\n* Use many-arg system() instead of the one-arg form to prevent security breach.\n\n* Iain Truskett: fixed export bug so SIGNATURE_OK is properly exported.\n\n* Introduced global $KeyServer variable, default at 'pgp.mit.edu'.\n\n* Suggestion from Aurthur Bergman: cpansign without arg should DWIM.\n\n* Set a default keyserver for cpansign -v.\n\n* Use by-name params for functions. sign(override => $bool).\n\n[Changes for 0.05 - 2002-08-14]\n\n* Typo correction and safety checking.\n\n[Changes for 0.04 - 2002-08-14]\n\n* Added boilerplate text before SIGNATURE to explain what's it about.\n\n* Crypt::OpenPGP signature didn't work.\n\n* Add keyword expansion tags.\n", "---\nabstract: 'Module signature file manipulation'\nauthor:\n  - '\u5510\u9cf3 <cpan@audreyt.org>'\nbuild_requires:\n  ExtUtils::MakeMaker: 6.36\n  IPC::Run: 0\n  Test::More: 0\nconfigure_requires:\n  ExtUtils::MakeMaker: 6.36\ndistribution_type: module\ndynamic_config: 1\ngenerated_by: 'Module::Install version 1.06'\nlicense: cc0\nmeta-spec:\n  url: http://module-build.sourceforge.net/META-spec-v1.4.html\n  version: 1.4\nname: Module-Signature\nno_index:\n  directory:\n    - inc\n    - t\nrequires:\n  IO::Socket::INET: 0\n  perl: 5.005\nresources:\n  repository: http://github.com/audreyt/module-signature\nversion: 0.70\n", "package Module::Signature;\n$Module::Signature::VERSION = '0.70';\n\nuse 5.005;\nuse strict;\nuse vars qw($VERSION $SIGNATURE @ISA @EXPORT_OK);\nuse vars qw($Preamble $Cipher $Debug $Verbose $Timeout);\nuse vars qw($KeyServer $KeyServerPort $AutoKeyRetrieve $CanKeyRetrieve);\n\nuse constant CANNOT_VERIFY       => '0E0';\nuse constant SIGNATURE_OK        => 0;\nuse constant SIGNATURE_MISSING   => -1;\nuse constant SIGNATURE_MALFORMED => -2;\nuse constant SIGNATURE_BAD       => -3;\nuse constant SIGNATURE_MISMATCH  => -4;\nuse constant MANIFEST_MISMATCH   => -5;\nuse constant CIPHER_UNKNOWN      => -6;\n\nuse ExtUtils::Manifest ();\nuse Exporter;\n\n@EXPORT_OK      = (\n    qw(sign verify),\n    qw($SIGNATURE $KeyServer $Cipher $Preamble),\n    (grep { /^[A-Z_]+_[A-Z_]+$/ } keys %Module::Signature::),\n);\n@ISA            = 'Exporter';\n\n$SIGNATURE      = 'SIGNATURE';\n$Timeout        = $ENV{MODULE_SIGNATURE_TIMEOUT} || 3;\n$Verbose        = $ENV{MODULE_SIGNATURE_VERBOSE} || 0;\n$KeyServer      = $ENV{MODULE_SIGNATURE_KEYSERVER} || 'pool.sks-keyservers.net';\n$KeyServerPort  = $ENV{MODULE_SIGNATURE_KEYSERVERPORT} || '11371';\n$Cipher         = $ENV{MODULE_SIGNATURE_CIPHER} || 'SHA1';\n$Preamble       = << \".\";\nThis file contains message digests of all files listed in MANIFEST,\nsigned via the Module::Signature module, version $VERSION.\n\nTo verify the content in this distribution, first make sure you have\nModule::Signature installed, then type:\n\n    % cpansign -v\n\nIt will check each file's integrity, as well as the signature's\nvalidity.  If \"==> Signature verified OK! <==\" is not displayed,\nthe distribution may already have been compromised, and you should\nnot run its Makefile.PL or Build.PL.\n\n.\n\n$AutoKeyRetrieve    = 1;\n$CanKeyRetrieve     = undef;\n\nsub _cipher_map {\n    my($sigtext) = @_;\n    my @lines = split /\\015?\\012/, $sigtext;\n    my %map;\n    for my $line (@lines) {\n        my($cipher,$digest,$file) = split \" \", $line, 3;\n        return unless defined $file;\n        $map{$file} = [$cipher, $digest];\n    }\n    return \\%map;\n}\n\nsub verify {\n    my %args = ( skip => 1, @_ );\n    my $rv;\n\n    (-r $SIGNATURE) or do {\n        warn \"==> MISSING Signature file! <==\\n\";\n        return SIGNATURE_MISSING;\n    };\n\n    (my $sigtext = _read_sigfile($SIGNATURE)) or do {\n        warn \"==> MALFORMED Signature file! <==\\n\";\n        return SIGNATURE_MALFORMED;\n    };\n\n    (my ($cipher_map) = _cipher_map($sigtext)) or do {\n        warn \"==> MALFORMED Signature file! <==\\n\";\n        return SIGNATURE_MALFORMED;\n    };\n\n    (defined(my $plaintext = _mkdigest($cipher_map))) or do {\n        warn \"==> UNKNOWN Cipher format! <==\\n\";\n        return CIPHER_UNKNOWN;\n    };\n\n    $rv = _verify($SIGNATURE, $sigtext, $plaintext);\n\n    if ($rv == SIGNATURE_OK) {\n        my ($mani, $file) = _fullcheck($args{skip});\n\n        if (@{$mani} or @{$file}) {\n            warn \"==> MISMATCHED content between MANIFEST and distribution files! <==\\n\";\n            return MANIFEST_MISMATCH;\n        }\n        else {\n            warn \"==> Signature verified OK! <==\\n\" if $Verbose;\n        }\n    }\n    elsif ($rv == SIGNATURE_BAD) {\n        warn \"==> BAD/TAMPERED signature detected! <==\\n\";\n    }\n    elsif ($rv == SIGNATURE_MISMATCH) {\n        warn \"==> MISMATCHED content between SIGNATURE and distribution files! <==\\n\";\n    }\n\n    return $rv;\n}\n\nsub _verify {\n    my $signature = shift || $SIGNATURE;\n    my $sigtext   = shift || '';\n    my $plaintext = shift || '';\n\n    local $SIGNATURE = $signature if $signature ne $SIGNATURE;\n\n    if ($AutoKeyRetrieve and !$CanKeyRetrieve) {\n        if (!defined $CanKeyRetrieve) {\n            require IO::Socket::INET;\n            my $sock = IO::Socket::INET->new(\n                Timeout => $Timeout,\n                PeerAddr => \"$KeyServer:$KeyServerPort\",\n            );\n            $CanKeyRetrieve = ($sock ? 1 : 0);\n            $sock->shutdown(2) if $sock;\n        }\n        $AutoKeyRetrieve = $CanKeyRetrieve;\n    }\n\n    if (my $version = _has_gpg()) {\n        return _verify_gpg($sigtext, $plaintext, $version);\n    }\n    elsif (eval {require Crypt::OpenPGP; 1}) {\n        return _verify_crypt_openpgp($sigtext, $plaintext);\n    }\n    else {\n        warn \"Cannot use GnuPG or Crypt::OpenPGP, please install either one first!\\n\";\n        return _compare($sigtext, $plaintext, CANNOT_VERIFY);\n    }\n}\n\nsub _has_gpg {\n    my $gpg = _which_gpg() or return;\n    `$gpg --version` =~ /GnuPG.*?(\\S+)\\s*$/m or return;\n    return $1;\n}\n\nsub _fullcheck {\n    my $skip = shift;\n    my @extra;\n\n    local $^W;\n    local $ExtUtils::Manifest::Quiet = 1;\n\n    my($mani, $file);\n    if( _legacy_extutils() ) {\n        my $_maniskip;\n        if ( _public_maniskip() ) {\n            $_maniskip = &ExtUtils::Manifest::maniskip;\n        } else {\n            $_maniskip = &ExtUtils::Manifest::_maniskip;\n        }\n\n        local *ExtUtils::Manifest::_maniskip = sub { sub {\n            return unless $skip;\n            my $ok = $_maniskip->(@_);\n            if ($ok ||= (!-e 'MANIFEST.SKIP' and _default_skip(@_))) {\n                print \"Skipping $_\\n\" for @_;\n                push @extra, @_;\n            }\n            return $ok;\n        } };\n\n        ($mani, $file) = ExtUtils::Manifest::fullcheck();\n    }\n    else {\n        ($mani, $file) = ExtUtils::Manifest::fullcheck();\n    }\n\n    foreach my $makefile ('Makefile', 'Build') {\n        warn \"==> SKIPPED CHECKING '$_'!\" .\n                (-e \"$_.PL\" && \" (run $_.PL to ensure its integrity)\") .\n                \" <===\\n\" for grep $_ eq $makefile, @extra;\n    }\n\n    @{$mani} = grep {$_ ne 'SIGNATURE'} @{$mani};\n\n    warn \"Not in MANIFEST: $_\\n\" for @{$file};\n    warn \"No such file: $_\\n\" for @{$mani};\n\n    return ($mani, $file);\n}\n\nsub _legacy_extutils {\n    # ExtUtils::Manifest older than 1.58 does not handle MYMETA.\n    return (ExtUtils::Manifest->VERSION < 1.58);\n}\n\nsub _public_maniskip {\n    # ExtUtils::Manifest 1.54 onwards have public maniskip\n    return (ExtUtils::Manifest->VERSION > 1.53);\n}\n\nsub _default_skip {\n    local $_ = shift;\n    return 1 if /\\bRCS\\b/ or /\\bCVS\\b/ or /\\B\\.svn\\b/ or /,v$/\n             or /^MANIFEST\\.bak/ or /^Makefile$/ or /^blib\\//\n             or /^MakeMaker-\\d/ or /^pm_to_blib/ or /^blibdirs/\n             or /^_build\\// or /^Build$/ or /^pmfiles\\.dat/\n             or /^MYMETA\\./\n             or /~$/ or /\\.old$/ or /\\#$/ or /^\\.#/;\n}\n\nmy $which_gpg;\nsub _which_gpg {\n    # Cache it so we don't need to keep checking.\n    return $which_gpg if $which_gpg;\n\n    for my $gpg_bin ('gpg', 'gpg2', 'gnupg', 'gnupg2') {\n        my $version = `$gpg_bin --version 2>&1`;\n        if( $version && $version =~ /GnuPG/ ) {\n            $which_gpg = $gpg_bin;\n            return $which_gpg;\n        }\n    }\n}\n\nsub _verify_gpg {\n    my ($sigtext, $plaintext, $version) = @_;\n\n    local $SIGNATURE = Win32::GetShortPathName($SIGNATURE)\n        if defined &Win32::GetShortPathName and $SIGNATURE =~ /[^-\\w.:~\\\\\\/]/;\n\n    my $keyserver = _keyserver($version);\n\n    my $gpg = _which_gpg();\n    my @quiet = $Verbose ? () : qw(-q --logger-fd=1);\n    my @cmd = (\n        $gpg, qw(--verify --batch --no-tty), @quiet, ($KeyServer ? (\n            \"--keyserver=$keyserver\",\n            ($AutoKeyRetrieve and $version ge '1.0.7')\n                ? '--keyserver-options=auto-key-retrieve'\n                : ()\n        ) : ()), $SIGNATURE\n    );\n\n    my $output = '';\n    if( $Verbose ) {\n        warn \"Executing @cmd\\n\";\n        system @cmd;\n    }\n    else {\n        my $cmd = join ' ', @cmd;\n        $output = `$cmd`;\n    }\n\n    if( $? ) {\n        print STDERR $output;\n    }\n    elsif ($output =~ /((?: +[\\dA-F]{4}){10,})/) {\n        warn \"WARNING: This key is not certified with a trusted signature!\\n\";\n        warn \"Primary key fingerprint:$1\\n\";\n    }\n\n    return SIGNATURE_BAD if ($? and $AutoKeyRetrieve);\n    return _compare($sigtext, $plaintext, (!$?) ? SIGNATURE_OK : CANNOT_VERIFY);\n}\n\nsub _keyserver {\n    my $version = shift;\n    my $scheme = 'x-hkp';\n    $scheme = 'hkp' if $version ge '1.2.0';\n\n    return \"$scheme://$KeyServer:$KeyServerPort\";\n}\n\nsub _verify_crypt_openpgp {\n    my ($sigtext, $plaintext) = @_;\n\n    require Crypt::OpenPGP;\n    my $pgp = Crypt::OpenPGP->new(\n        ($KeyServer) ? ( KeyServer => $KeyServer, AutoKeyRetrieve => $AutoKeyRetrieve ) : (),\n    );\n    my $rv = $pgp->handle( Filename => $SIGNATURE )\n        or die $pgp->errstr;\n\n    return SIGNATURE_BAD if (!$rv->{Validity} and $AutoKeyRetrieve);\n\n    if ($rv->{Validity}) {\n        warn 'Signature made ', scalar localtime($rv->{Signature}->timestamp),\n             ' using key ID ', substr(uc(unpack('H*', $rv->{Signature}->key_id)), -8), \"\\n\",\n             \"Good signature from \\\"$rv->{Validity}\\\"\\n\" if $Verbose;\n    }\n    else {\n        warn \"Cannot verify signature; public key not found\\n\";\n    }\n\n    return _compare($sigtext, $plaintext, $rv->{Validity} ? SIGNATURE_OK : CANNOT_VERIFY);\n}\n\nsub _read_sigfile {\n    my $sigfile = shift;\n    my $signature = '';\n    my $well_formed;\n\n    local *D;\n    open D, $sigfile or die \"Could not open $sigfile: $!\";\n\n    if ($] >= 5.006 and <D> =~ /\\r/) {\n        close D;\n        open D, $sigfile or die \"Could not open $sigfile: $!\";\n        binmode D, ':crlf';\n    } else {\n        close D;\n        open D, $sigfile or die \"Could not open $sigfile: $!\";\n    }\n\n    while (<D>) {\n        next if (1 .. /^-----BEGIN PGP SIGNED MESSAGE-----/);\n        last if /^-----BEGIN PGP SIGNATURE/;\n\n        $signature .= $_;\n    }\n\n    return ((split(/\\n+/, $signature, 2))[1]);\n}\n\nsub _compare {\n    my ($str1, $str2, $ok) = @_;\n\n    # normalize all linebreaks\n    $str1 =~ s/[^\\S ]+/\\n/g; $str2 =~ s/[^\\S ]+/\\n/g;\n\n    return $ok if $str1 eq $str2;\n\n    if (eval { require Text::Diff; 1 }) {\n        warn \"--- $SIGNATURE \".localtime((stat($SIGNATURE))[9]).\"\\n\";\n        warn '+++ (current) '.localtime().\"\\n\";\n        warn Text::Diff::diff( \\$str1, \\$str2, { STYLE => 'Unified' } );\n    }\n    else {\n        local (*D, *S);\n        open S, $SIGNATURE or die \"Could not open $SIGNATURE: $!\";\n        open D, \"| diff -u $SIGNATURE -\" or (warn \"Could not call diff: $!\", return SIGNATURE_MISMATCH);\n        while (<S>) {\n            print D $_ if (1 .. /^-----BEGIN PGP SIGNED MESSAGE-----/);\n            print D if (/^Hash: / .. /^$/);\n            next if (1 .. /^-----BEGIN PGP SIGNATURE/);\n            print D $str2, \"-----BEGIN PGP SIGNATURE-----\\n\", $_ and last;\n        }\n        print D <S>;\n        close D;\n    }\n\n    return SIGNATURE_MISMATCH;\n}\n\nsub sign {\n    my %args = ( skip => 1, @_ );\n    my $overwrite = $args{overwrite};\n    my $plaintext = _mkdigest();\n\n    my ($mani, $file) = _fullcheck($args{skip});\n\n    if (@{$mani} or @{$file}) {\n        warn \"==> MISMATCHED content between MANIFEST and the distribution! <==\\n\";\n        warn \"==> Please correct your MANIFEST file and/or delete extra files. <==\\n\";\n    }\n\n    if (!$overwrite and -e $SIGNATURE and -t STDIN) {\n        local $/ = \"\\n\";\n        print \"$SIGNATURE already exists; overwrite [y/N]? \";\n        return unless <STDIN> =~ /[Yy]/;\n    }\n\n    if (my $version = _has_gpg()) {\n        _sign_gpg($SIGNATURE, $plaintext, $version);\n    }\n    elsif (eval {require Crypt::OpenPGP; 1}) {\n        _sign_crypt_openpgp($SIGNATURE, $plaintext);\n    }\n    else {\n        die 'Cannot use GnuPG or Crypt::OpenPGP, please install either one first!';\n    }\n\n    warn \"==> SIGNATURE file created successfully. <==\\n\";\n    return SIGNATURE_OK;\n}\n\nsub _sign_gpg {\n    my ($sigfile, $plaintext, $version) = @_;\n\n    die \"Could not write to $sigfile\"\n        if -e $sigfile and (-d $sigfile or not -w $sigfile);\n\n    my $gpg = _which_gpg();\n\n    local *D;\n    open D, \"| $gpg --clearsign >> $sigfile.tmp\" or die \"Could not call $gpg: $!\";\n    print D $plaintext;\n    close D;\n\n    (-e \"$sigfile.tmp\" and -s \"$sigfile.tmp\") or do {\n        unlink \"$sigfile.tmp\";\n        die \"Cannot find $sigfile.tmp, signing aborted.\\n\";\n    };\n\n    open D, \"$sigfile.tmp\" or die \"Cannot open $sigfile.tmp: $!\";\n\n    open S, \">$sigfile\" or do {\n        unlink \"$sigfile.tmp\";\n        die \"Could not write to $sigfile: $!\";\n    };\n\n    print S $Preamble;\n    print S <D>;\n\n    close S;\n    close D;\n\n    unlink(\"$sigfile.tmp\");\n\n    my $key_id;\n    my $key_name;\n    # This doesn't work because the output from verify goes to STDERR.\n    # If I try to redirect it using \"--logger-fd 1\" it just hangs.\n    # WTF?\n    my @verify = `$gpg --batch --verify $SIGNATURE`;\n    while (@verify) {\n        if (/key ID ([0-9A-F]+)$/) {\n            $key_id = $1;\n        } elsif (/signature from \"(.+)\"$/) {\n            $key_name = $1;\n        }\n    }\n\n    my $found_name;\n    my $found_key;\n    if (defined $key_id && defined $key_name) {\n        my $keyserver = _keyserver($version);\n        while (`$gpg --batch --keyserver=$keyserver --search-keys '$key_name'`) {\n            if (/^\\(\\d+\\)/) {\n                $found_name = 0;\n            } elsif ($found_name) {\n                if (/key \\Q$key_id\\E/) {\n                    $found_key = 1;\n                    last;\n                }\n            }\n\n            if (/\\Q$key_name\\E/) {\n                $found_name = 1;\n                next;\n            }\n        }\n\n        unless ($found_key) {\n            _warn_non_public_signature($key_name);\n        }\n    }\n\n    return 1;\n}\n\nsub _sign_crypt_openpgp {\n    my ($sigfile, $plaintext) = @_;\n\n    require Crypt::OpenPGP;\n    my $pgp = Crypt::OpenPGP->new;\n    my $ring = Crypt::OpenPGP::KeyRing->new(\n        Filename => $pgp->{cfg}->get('SecRing')\n    ) or die $pgp->error(Crypt::OpenPGP::KeyRing->errstr);\n    my $kb = $ring->find_keyblock_by_index(-1)\n        or die $pgp->error('Can\\'t find last keyblock: ' . $ring->errstr);\n\n    my $cert = $kb->signing_key;\n    my $uid = $cert->uid($kb->primary_uid);\n    warn \"Debug: acquiring signature from $uid\\n\" if $Debug;\n\n    my $signature = $pgp->sign(\n        Data       => $plaintext,\n        Detach     => 0,\n        Clearsign  => 1,\n        Armour     => 1,\n        Key        => $cert,\n        PassphraseCallback => \\&Crypt::OpenPGP::_default_passphrase_cb,\n    ) or die $pgp->errstr;\n\n\n    local *D;\n    open D, \"> $sigfile\" or die \"Could not write to $sigfile: $!\";\n    print D $Preamble;\n    print D $signature;\n    close D;\n\n    require Crypt::OpenPGP::KeyServer;\n    my $server = Crypt::OpenPGP::KeyServer->new(Server => $KeyServer);\n\n    unless ($server->find_keyblock_by_keyid($cert->key_id)) {\n        _warn_non_public_signature($uid);\n    }\n\n    return 1;\n}\n\nsub _warn_non_public_signature {\n    my $uid = shift;\n\n    warn <<\"EOF\"\nYou have signed this distribution with a key ($uid) that cannot be\nfound on the public key server at $KeyServer.\n\nThis will probably cause signature verification to fail if your module\nis distributed on CPAN.\nEOF\n}\n\nsub _mkdigest {\n    my $digest = _mkdigest_files(@_) or return;\n    my $plaintext = '';\n\n    foreach my $file (sort keys %$digest) {\n        next if $file eq $SIGNATURE;\n        $plaintext .= \"@{$digest->{$file}} $file\\n\";\n    }\n\n    return $plaintext;\n}\n\nsub _digest_object {\n    my($algorithm) = @_;\n    my $obj = eval { Digest->new($algorithm) } || eval {\n        my ($base, $variant) = ($algorithm =~ /^(\\w+?)(\\d+)$/g) or die;\n        require \"Digest/$base.pm\"; \"Digest::$base\"->new($variant)\n    } || eval {\n        require \"Digest/$algorithm.pm\"; \"Digest::$algorithm\"->new\n    } || eval {\n        my ($base, $variant) = ($algorithm =~ /^(\\w+?)(\\d+)$/g) or die;\n        require \"Digest/$base/PurePerl.pm\"; \"Digest::$base\\::PurePerl\"->new($variant)\n    } || eval {\n        require \"Digest/$algorithm/PurePerl.pm\"; \"Digest::$algorithm\\::PurePerl\"->new\n    } or do { eval {\n        my ($base, $variant) = ($algorithm =~ /^(\\w+?)(\\d+)$/g) or die;\n        warn \"Unknown cipher: $algorithm, please install Digest::$base, Digest::$base$variant, or Digest::$base\\::PurePerl\\n\";\n    } and return } or do {\n        warn \"Unknown cipher: $algorithm, please install Digest::$algorithm\\n\"; return;\n    };\n    $obj;\n}\n\nsub _mkdigest_files {\n    my $verify_map = shift;\n    my $dosnames = (defined(&Dos::UseLFN) && Dos::UseLFN()==0);\n    my $read = ExtUtils::Manifest::maniread() || {};\n    my $found = ExtUtils::Manifest::manifind();\n    my(%digest) = ();\n    my($default_obj) = _digest_object($Cipher);\n FILE: foreach my $file (sort keys %$read){\n        next FILE if $file eq $SIGNATURE;\n        my($obj,$this_cipher,$this_hexdigest,$verify_digest);\n        if ($verify_map) {\n            if (my $vmf = $verify_map->{$file}) {\n                ($this_cipher,$verify_digest) = @$vmf;\n                if ($this_cipher eq $Cipher) {\n                    $obj = $default_obj;\n                } else {\n                    $obj = _digest_object($this_cipher);\n                }\n            } else {\n                $this_cipher = $Cipher;\n                $obj = $default_obj;\n            }\n        } else {\n            $this_cipher = $Cipher;\n            $obj = $default_obj;\n        }\n        warn \"Debug: collecting digest from $file\\n\" if $Debug;\n        if ($dosnames){\n            $file = lc $file;\n            $file =~ s!(\\.(\\w|-)+)!substr ($1,0,4)!ge;\n            $file =~ s!((\\w|-)+)!substr ($1,0,8)!ge;\n        }\n        unless ( exists $found->{$file} ) {\n            warn \"No such file: $file\\n\" if $Verbose;\n        }\n        else {\n            local *F;\n            open F, $file or die \"Cannot open $file for reading: $!\";\n            if (-B $file) {\n                binmode(F);\n                $obj->addfile(*F);\n                $this_hexdigest = $obj->hexdigest;\n            }\n            elsif ($^O eq 'MSWin32') {\n                $obj->addfile(*F);\n                $this_hexdigest = $obj->hexdigest;\n            }\n            else {\n                # Normalize by hand...\n                local $/;\n                binmode(F);\n                my $input = <F>;\n            VERIFYLOOP: for my $eol (\"\",\"\\015\\012\",\"\\012\") {\n                    my $lax_input = $input;\n                    if (! length $eol) {\n                        # first try is binary\n                    } else {\n                        my @lines = split /$eol/, $input, -1;\n                        if (grep /[\\015\\012]/, @lines) {\n                            # oops, apparently not a text file, treat as binary, forget @lines\n                        } else {\n                            my $other_eol = $eol eq \"\\012\" ? \"\\015\\012\" : \"\\012\";\n                            $lax_input = join $other_eol, @lines;\n                        }\n                    }\n                    $obj->add($lax_input);\n                    $this_hexdigest = $obj->hexdigest;\n                    if ($verify_digest) {\n                        if ($this_hexdigest eq $verify_digest) {\n                            last VERIFYLOOP;\n                        }\n                        $obj->reset;\n                    } else {\n                        last VERIFYLOOP;\n                    }\n                }\n            }\n            $digest{$file} = [$this_cipher, $this_hexdigest];\n            $obj->reset;\n        }\n    }\n\n    return \\%digest;\n}\n\n1;\n\n__END__\n\n=encoding utf8\n\n=head1 NAME\n\nModule::Signature - Module signature file manipulation\n\n=head1 SYNOPSIS\n\nAs a shell command:\n\n    % cpansign              # verify an existing SIGNATURE, or\n                            # make a new one if none exists\n\n    % cpansign sign         # make signature; overwrites existing one\n    % cpansign -s           # same thing\n\n    % cpansign verify       # verify a signature\n    % cpansign -v           # same thing\n    % cpansign -v --skip    # ignore files in MANIFEST.SKIP\n\n    % cpansign help         # display this documentation\n    % cpansign -h           # same thing\n\nIn programs:\n\n    use Module::Signature qw(sign verify SIGNATURE_OK);\n    sign();\n    sign(overwrite => 1);       # overwrites without asking\n\n    # see the CONSTANTS section below\n    (verify() == SIGNATURE_OK) or die \"failed!\";\n\n=head1 DESCRIPTION\n\nB<Module::Signature> adds cryptographic authentications to CPAN\ndistributions, via the special F<SIGNATURE> file.\n\nIf you are a module user, all you have to do is to remember to run\nC<cpansign -v> (or just C<cpansign>) before issuing C<perl Makefile.PL>\nor C<perl Build.PL>; that will ensure the distribution has not been\ntampered with.\n\nModule authors can easily add the F<SIGNATURE> file to the distribution\ntarball; see L</NOTES> below for how to do it as part of C<make dist>.\n\nIf you I<really> want to sign a distribution manually, simply add\nC<SIGNATURE> to F<MANIFEST>, then type C<cpansign -s> immediately\nbefore C<make dist>.  Be sure to delete the F<SIGNATURE> file afterwards.\n\nPlease also see L</NOTES> about F<MANIFEST.SKIP> issues, especially if\nyou are using B<Module::Build> or writing your own F<MANIFEST.SKIP>.\n\n=head1 VARIABLES\n\nNo package variables are exported by default.\n\n=over 4\n\n=item $Verbose\n\nIf true, Module::Signature will give information during processing including\ngpg output.  If false, Module::Signature will be as quiet as possible as\nlong as everything is working ok.  Defaults to false.\n\n=item $SIGNATURE\n\nThe filename for a distribution's signature file.  Defaults to\nC<SIGNATURE>.\n\n=item $KeyServer\n\nThe OpenPGP key server for fetching the author's public key\n(currently only implemented on C<gpg>, not C<Crypt::OpenPGP>).\nMay be set to a false value to prevent this module from\nfetching public keys.\n\n=item $KeyServerPort\n\nThe OpenPGP key server port, defaults to C<11371>.\n\n=item $Timeout\n\nMaximum time to wait to try to establish a link to the key server.\nDefaults to C<3>.\n\n=item $AutoKeyRetrieve\n\nWhether to automatically fetch unknown keys from the key server.\nDefaults to C<1>.\n\n=item $Cipher\n\nThe default cipher used by the C<Digest> module to make signature\nfiles.  Defaults to C<SHA1>, but may be changed to other ciphers\nvia the C<MODULE_SIGNATURE_CIPHER> environment variable if the SHA1\ncipher is undesirable for the user.\n\nThe cipher specified in the F<SIGNATURE> file's first entry will\nbe used to validate its integrity.  For C<SHA1>, the user needs\nto have any one of these four modules installed: B<Digest::SHA>,\nB<Digest::SHA1>, B<Digest::SHA::PurePerl>, or (currently nonexistent)\nB<Digest::SHA1::PurePerl>.\n\n=item $Preamble\n\nThe explanatory text written to newly generated F<SIGNATURE> files\nbefore the actual entries.\n\n=back\n\n=head1 ENVIRONMENT\n\nB<Module::Signature> honors these environment variables:\n\n=over 4\n\n=item MODULE_SIGNATURE_CIPHER\n\nWorks like C<$Cipher>.\n\n=item MODULE_SIGNATURE_VERBOSE\n\nWorks like C<$Verbose>.\n\n=item MODULE_SIGNATURE_KEYSERVER\n\nWorks like C<$KeyServer>.\n\n=item MODULE_SIGNATURE_KEYSERVERPORT\n\nWorks like C<$KeyServerPort>.\n\n=item MODULE_SIGNATURE_TIMEOUT\n\nWorks like C<$Timeout>.\n\n=back\n\n=head1 CONSTANTS\n\nThese constants are not exported by default.\n\n=over 4\n\n=item CANNOT_VERIFY (C<0E0>)\n\nCannot verify the OpenPGP signature, maybe due to the lack of a network\nconnection to the key server, or if neither gnupg nor Crypt::OpenPGP\nexists on the system.\n\n=item SIGNATURE_OK (C<0>)\n\nSignature successfully verified.\n\n=item SIGNATURE_MISSING (C<-1>)\n\nThe F<SIGNATURE> file does not exist.\n\n=item SIGNATURE_MALFORMED (C<-2>)\n\nThe signature file does not contains a valid OpenPGP message.\n\n=item SIGNATURE_BAD (C<-3>)\n\nInvalid signature detected -- it might have been tampered with.\n\n=item SIGNATURE_MISMATCH (C<-4>)\n\nThe signature is valid, but files in the distribution have changed\nsince its creation.\n\n=item MANIFEST_MISMATCH (C<-5>)\n\nThere are extra files in the current directory not specified by\nthe MANIFEST file.\n\n=item CIPHER_UNKNOWN (C<-6>)\n\nThe cipher used by the signature file is not recognized by the\nC<Digest> and C<Digest::*> modules.\n\n=back\n\n=head1 NOTES\n\n=head2 Signing your module as part of C<make dist>\n\nThe easiest way is to use B<Module::Install>:\n\n    sign;       # put this before \"WriteAll\"\n    WriteAll;\n\nFor B<ExtUtils::MakeMaker> (version 6.18 or above), you may do this:\n\n    WriteMakefile(\n        (MM->can('signature_target') ? (SIGN => 1) : ()),\n        # ... original arguments ...\n    );\n\nUsers of B<Module::Build> may do this:\n\n    Module::Build->new(\n        (sign => 1),\n        # ... original arguments ...\n    )->create_build_script;\n\n=head2 F<MANIFEST.SKIP> Considerations\n\n(The following section is lifted from Iain Truskett's B<Test::Signature>\nmodule, under the Perl license.  Thanks, Iain!)\n\nIt is B<imperative> that your F<MANIFEST> and F<MANIFEST.SKIP> files be\naccurate and complete. If you are using C<ExtUtils::MakeMaker> and you\ndo not have a F<MANIFEST.SKIP> file, then don't worry about the rest of\nthis. If you do have a F<MANIFEST.SKIP> file, or you use\nC<Module::Build>, you must read this.\n\nSince the test is run at C<make test> time, the distribution has been\nmade. Thus your F<MANIFEST.SKIP> file should have the entries listed\nbelow.\n\nIf you're using C<ExtUtils::MakeMaker>, you should have, at least:\n\n    #defaults\n    ^Makefile$\n    ^blib/\n    ^pm_to_blib\n    ^blibdirs\n\nThese entries are part of the default set provided by\nC<ExtUtils::Manifest>, which is ignored if you provide your own\nF<MANIFEST.SKIP> file.\n\nIf you are using C<Module::Build>, you should have two extra entries:\n\n    ^Build$\n    ^_build/\n\nIf you don't have the correct entries, C<Module::Signature> will\ncomplain that you have:\n\n    ==> MISMATCHED content between MANIFEST and distribution files! <==\n\nYou should note this during normal development testing anyway.\n\n=head2 Testing signatures\n\nYou may add this code as F<t/0-signature.t> in your distribution tree:\n\n    #!/usr/bin/perl\n\n    use strict;\n    print \"1..1\\n\";\n\n    if (!$ENV{TEST_SIGNATURE}) {\n        print \"ok 1 # skip Set the environment variable\",\n                    \" TEST_SIGNATURE to enable this test\\n\";\n    }\n    elsif (!-s 'SIGNATURE') {\n        print \"ok 1 # skip No signature file found\\n\";\n    }\n    elsif (!eval { require Module::Signature; 1 }) {\n        print \"ok 1 # skip \",\n                \"Next time around, consider install Module::Signature, \",\n                \"so you can verify the integrity of this distribution.\\n\";\n    }\n    elsif (!eval { require Socket; Socket::inet_aton('pool.sks-keyservers.net') }) {\n        print \"ok 1 # skip \",\n                \"Cannot connect to the keyserver\\n\";\n    }\n    else {\n        (Module::Signature::verify() == Module::Signature::SIGNATURE_OK())\n            or print \"not \";\n        print \"ok 1 # Valid signature\\n\";\n    }\n\n    __END__\n\nIf you are already using B<Test::More> for testing, a more\nstraightforward version of F<t/0-signature.t> can be found in the\nB<Module::Signature> distribution.\n\nAlso, if you prefer a more full-fledged testing package, and are\nwilling to inflict the dependency of B<Module::Build> on your users,\nIain Truskett's B<Test::Signature> might be a better choice.\n\n=cut\n\n=head1 SEE ALSO\n\nL<Digest>, L<Digest::SHA>, L<Digest::SHA1>, L<Digest::SHA::PurePerl>\n\nL<ExtUtils::Manifest>, L<Crypt::OpenPGP>, L<Test::Signature>\n\nL<Module::Install>, L<ExtUtils::MakeMaker>, L<Module::Build>\n\n=head1 AUTHORS\n\n\u5510\u9cf3 E<lt>cpan@audreyt.orgE<gt>\n\n=head1 CC0 1.0 Universal\n\nTo the extent possible under law, \u5510\u9cf3 has waived all copyright and related\nor neighboring rights to Module-Signature.\n\nThis work is published from Taiwan.\n\nL<http://creativecommons.org/publicdomain/zero/1.0>\n\n=cut\n"], "fixing_code": ["[Changes for 0.71 - Tue Jun  4 18:24:10 CST 2013]\n\n* Constrain the user-specified digest name to /^\\w+\\d+$/.\n\n* Avoid loading Digest::* from relative paths in @INC.\n\n  Contributed by: Florian Weimer\n\n[Changes for 0.70 - Thu Nov 29 01:45:54 CST 2012]\n\n* Don't check gpg version if gpg does not exist.\n\n  This avoids unnecessary warnings during installation\n  when gpg executable is not installed.\n\n  Contributed by: Kenichi Ishigaki\n\n[Changes for 0.69 - Fri Nov  2 23:04:19 CST 2012]\n\n* Support for gpg under these alternate names:\n\n    gpg gpg2 gnupg gnupg2\n\n  Contributed by: Michael Schwern\n\n[Changes for 0.68 - Fri, 13 May 2011 11:51:50 +0200]\n\n* Fix breakage introduced by 0.67 (Andreas K\u00f6nig).\n\n[Changes for 0.67 - Sun, 17 Apr 2011 16:29:23 +0200]\n\n* Better handling of \\r (Andreas K\u00f6nig, Zefram) (Closes RT#46339).\n\n[Changes for 0.66 - Fri,  6 Sep 2010 22:51:37 +0200]\n\n* Fix incompatibility with EU::Manifest 1.54 to 1.57\n  (Paul Howarth) (Closes RT#61124).\n\n[Changes for 0.65 - Fri,  3 Sep 2010 21:38:02 +0200]\n\n* Skip MYMETA (Alexandr Ciornii)\n\n[Changes for 0.64 - Sun,  9 May 2010 00:50:11 +0200]\n\n* Avoid creating gnupg configuration files for the user invoking Makefile.PL\n  (Closes RT#41978).\n* Correctly detect the version of gnupg on cygwin and add tests for it\n  (Paul Fenwick) (Closes RT#39258).\n\n[Changes for 0.63 - Sun, 28 Mar 2010 04:46:27 +0100]\n\n* Fix diagnostic message from Makefile.PL when the user dosn't have gnupg or\n  Crypt::OpenPGP (miyagawa).\n\n[Changes for 0.62 - Tue, 23 Mar 2010 22:17:39 +0100]\n\n* Change the default keyserver from the outdated pgp.mit.edu to\n  pool.sks-keyservers.net.\n\n[Changes for 0.61 - 2009\u5e7411\u670819\u65e5 \u5468\u56db 00\u664256\u520641\u79d2 CST]\n\n* Added \"=encoding utf8\" to POD to fix author name display.\n  No functional changes.\n\n[Changes for 0.60 - 2009\u5e7411\u670816\u65e5 \u5468\u4e00 22\u664248\u520654\u79d2 CST]\n\n* LICENSING CHANGE: This compilation and all individual files in it\n  are now under the nullary CC0 1.0 Universal terms:\n\n  To the extent possible under law, \u5510\u9cf3 has waived all copyright and\n  related or neighboring rights to Module-Signature.\n\n* Updated Module::Install to 0.91, prompted by Florian Ragwitz.\n\n[Changes for 0.55 - 2006-07-29]\n\n* ANDK submitted a patch to fix versioning problem when\n  the user elects to install Crypt::OpenPGP.\n\n* Major refactoring of the Makefile.PL to ease the installation process.\n\n[Changes for 0.54 - 2006-05-12]\n\n* Fixed a long-standing bug where differing end-of-line conventions\n  could cause bogus comparisons in signature checks.\n\n* Fixed another long-standing bug where CRLF text files were hashed\n  into different digests under Unix and Dosish platforms.  Now it's\n  consistently hashed as if it's been normalized to LF.\n\n* Optional dependencies are no longer installed-by-default.\n\n[Changes for 0.53 - 2006-01-31]\n\n* The explicit call to \"readline(D)\" didn't compile on earlier perls which\n  demanded either \"readline(*D)\" or \"<D>\" -- I elected the latter form.\n  Reported by: Matthew Persic\n\n* Update my author key to reflect revoked past uids.\n\n[Changes for 0.52 - 2006-01-19]\n\n* POD and source code cleanup; no functional changes.\n\n* Updated my author key to reflect my new name and identity.\n\n* Upgrade to the latest Module::Install to fix Cygwin\n  installation problems.\n  Reported by: Lyle Ziegelmiller\n\n[Changes for 0.51 - 2006-01-02]\n\n* Even more flexible CRLF handling for SIGNATURE files,\n  Contributed by: Andreas Koenig.\n\n[Changes for 0.50 - 2005-08-21]\n\n* Add support for to SHA-256, requested by Mark Shelor in light\n  of the recent SHA1 attacks.  SHA1 is still the default, but\n  you can now override this by settings MODULE_SIGNATURE_CIPHER\n  environment variable to SHA256.\n\n[Changes for 0.45 - 2005-08-09]\n\n* Andreas Koenig ported out that \"Import GPG keys?\" was asked\n  far too many times during autoinstall.\n\n[Changes for 0.44 - 2004-12-16]\n\n* Add \"pmfiles.dat\" to legacy manifest_skip routine to accomodate\n  early Win32 hacks.  Reported by Steve Hay via Michael Schwern.\n\n[Changes for 0.43 - 2004-12-16]\n\n* Updated t/0-signature.t to be more friendly with Test::More;\n  contributed by Michael Schwern.\n\n* Add $Timeout (default 3 seconds) to control the timeout for\n  probing connections to the key server.\n\n* Take account of the .ts files produced by newer MakeMakers\n  in the suggested MANIFEST.SKIP list.\n\n[Changes for 0.42 - 2004-11-20]\n\n* Move under SVK version control management; ditch keyword tags.\n\n* Michael Schwern pointed out that during development, the\n  \"signature.t\" file would keep failing. \n\n* Documented how to generate SIGNATURE files as part of \"make dist\",\n  for Module::Install, ExtUtils::MakeMaker and Module::Build users .\n\n[Changes for 0.41 - 2004-07-04]\n\n* Mark Shelor points out that support for Digest::SHA was broken.\n\n[Changes for 0.40 - 2004-07-01]\n\n* Dave Rolsky points out that GPG version detection always\n  returns '1'. (bug #6810)\n\n[Changes for 0.39 - 2004-06-17]\n\n* Supports Digest::SHA (now preferred) and Digest::SHA1::PurePerl,\n  in addition to the original Digest::SHA1 backend.\n\n* We now asks before importing the default keys,\n  also suggested by Tels.\n\n* Unknown cipher is made fatal, thanks to suggestion by Tels.\n\n* Apply Dave Rolsky's patch to verify that author's pubkey\n  is available on a keyserver. may need more work.\n\n[Changes for 0.38 - 2004-01-01]\n\n* Update to the newest Module::Install.\n\n* Not using inc/SCRIPT/ anymore.\n\n* Add \"#defaults\" and \"^blibdirs$\" to recommended MANIFEST.SKIP\n  to pacify newer ExtUtil::MakeMaker.\n\n* Starting to think about how to make \"disttest\" + \"dist\"\n  not signing twice.\n\n[Changes for 0.37 - 2003-11-06]\n\n* Move bin/cpansign to script/cpansign.\n\n* Make cpansign exit upon failure.\n\n[Changes for 0.36 - 2003-10-28]\n\n* Use sign(1) to autosign ourselves.\n\n* Soren A pointed out that hkp:// didn't work with GnuPG.\n\n[Changes for 0.25 - 2003-08-28]\n\n* Now ships with my pubkey and PAUSE's.\n\n* Interactive Makefile.PL, suggested by Jarkko.\n\n[Changes for 0.34 - 2003-08-18]\n\n* Don't ask user to install Crypt::OpenPGP if she does not have a\n  C compiler anyway.\n\n* ExtUtils::Manifest 1.38 does not support good enough skips even\n  for Makefile.PL, sigh.\n\n[Changes for 0.33 - 2003-08-12]\n\n* William Wentworth-Sheilds points out that META.yml is dynamic,\n  which makes SIGNATURE incorrect for people without either \"diff\"\n  or \"gpg\".  Fixed.\n\n[Changes for 0.32 - 2003-08-11]\n\n* Take Schwern's patch to only set _maniskip for legacy EU::Manifest.\n\n* Remove ::TieOut since we are not using it anymore.\n\n* Reduce noise for untrusted signatures to two lines.\n\n[Changes for 0.31 - 2003-08-10]\n\n* Scott R. Godin pointed out 0.30 had bad signature.  whoops.\n\n[Changes for 0.30 - 2003-08-10]\n\n* Add JHI to authors.\n\n* Patch from Michael Schwern: only let GnuPG display anything\n  if we're handling suspicious keys, not when you have added\n  the signer into the trustdb.\n\n* New global config variable, $Verbose.\n\n* MODULE_SIGNATURE_VERBOSE, MODULE_SIGNATURE_KEYSERVER and\n  MODULE_SIGNATURE_KEYSERVERPORT env variables are now respected.\n\n* Only supply _default_skip if our ExtUtils::MakeMaker is too old.\n\n[Changes for 0.29 - 2003-08-08]\n\n* Now fails gracefully all the time, including when incapable of\n  connecting to the keyserver.\n\n* Also, SHA1 sum is still checked even if the user does not have\n  GnuPg/Crypt::OpenPGP.\n\n* Hence, Crypt::OpenPGP is no longer a mandatory prerequisite even\n  for users without gnupg.\n\n* \"0E0\" is now made into a constant, CANNOT_VERIFY.\n\n* Do not die() when we absolutely can't verify.\n\n* BZAJAC pointed out that we should add .svn to _default_skip.\n\n[Changes for 0.28 - 2003-07-29]\n\n* Remove Digest.pm dependency.\n\n* Don't test for \"diff -version\" anymore -- not all diffs\n  have -version, thanks again to Alan Burlison.\n\n[Changes for 0.27 - 2003-07-28]\n\n* More punctuation cleanups in POD.\n\n* Michael Schwern pointed out that successful tests shouldn't be noisy.\n\n[Changes for 0.26 - 2003-07-17]\n\n* New internal function, _verify(), that takes $sigfile as its first\n  argument, eliminating the \"local $Module::Signautre::SIGNATURE\" approach.\n\n* sign() now also takes a skip=> parameter (defaults to true)\n  about whether to respect MANIFEST.SKIP.  This needs to be\n  set to 0 to sign blib/ archives.\n\n* Officially supporting signing and verification of PAR files, using PAR::Dist.\n\n* Let's ignore warnings when performing on exe files\n\n[Changes for 0.24 - 2003-07-08]\n\n* Preliminary PAR support.\n\n[Changes for 0.23 - 2003-07-07]\n\n* Ken Williams noted that M::B now works on 5.005.\n\n[Changes for 0.22 - 2003-05-15]\n\n* Move Signature.pm to lib/Module/Signature.pm.\n\n* Switch to the Module::Install framework.\n\n* Updates TODO to reflect correspondence with andk.\n\n* Matt Southall mentioned that, if somebody has never run gpg before,\n  we need to initialize it once before running test.\n\n* Warn about potential 'Makefile' exploit as pointed out by Tels.\n  Document pending.\n\n* Bugfix for incorrect 'MALFORMED' response to signatures made from \n  older versions of GnuPG, as reported by Tels.\n\n[Changes for 0.18 - 2002-11-04]\n\n* Binary files handling on win32 was broken. (Jos Boumans)\n\n[Changes for 0.17 - 2002-10-30]\n\n* Resolve bug report by Iain Truskett: cpansign -s should not complain\n  manifest mismatch if SIGNATURE is lacking.\n\n* Also, bail out gracefully when signing fails, instead of crippling the\n  old SIGNATURE.\n\n* MANIFEST.SKIP doc lifted from Test::Signature.\n\n* Minor POD fixups.\n\n[Changes for 0.16 - 2002-10-28]\n\n* Adds AUTHORS file.\n\n* Added connectivity probing for testing.\n\n* Print a helpful success message after signing.\n\n* Don't cripple old SIGNATURE file.\n\n* Suggestion from Tels: skip the ambiguous 'optional'\n  probing for Crypt::OpenPGP if gnupg is there.\n\n[Changes for 0.15 - 2002-10-17]\n\n* Fixed compatibility with old MakeMaker versions, thanks to chromatic.\n\n* Fixed \"no /dev/tty\" bug during smoke testing,\n  as reported by the excellent CPAN Smokers.\n\n[Changes for 0.12 - 2002-10-12]\n\n* Supports automatic key retrieval, implemented in Crypt::OpenPGP.\n\n[Changes for 1.02 - 2002-10-12]\n\n* Fixed the default cipher from MD5 back to SHA1.\n\n[Changes for 0.10 - 2002-10-12]\n\n* Fixed a problem that prevents earlier versions of GnuPG from fetching\n  public keys via --keyserver-option=auto-key-retrieve.\n\n[Changes for 0.09 - 2002-10-12]\n\n* Documented the package variables so they become part of APIs.\n\n* Alternative (non-SHA1) ciphers in SIGNATUREs are now recognized.\n\n* Added a new return value, CIPHER_UNKNOWN.\n\n* Mention Test::Signature.\n\n* Ditch Test::More from the sample script.\n\n* Label tests.\n\n[Changes for 0.09 - 2002-10-11]\n\n* We're no longer alpha status; reflect in README.\n\n* Incoporated a suggestion from Tels: undefining the $KeyServer\n  package variable should disable automatic key-fetching.\n\n* Include the tests from Iain.\n\n* Tels: disable KeyServer fetching if it's undef'ed.\n\n[Changes for 0.07 - 2002-10-11]\n\n* Fixed our own signatures.\n\n[Changes for 0.06 - 2002-10-10]\n\n* Use many-arg system() instead of the one-arg form to prevent security breach.\n\n* Iain Truskett: fixed export bug so SIGNATURE_OK is properly exported.\n\n* Introduced global $KeyServer variable, default at 'pgp.mit.edu'.\n\n* Suggestion from Aurthur Bergman: cpansign without arg should DWIM.\n\n* Set a default keyserver for cpansign -v.\n\n* Use by-name params for functions. sign(override => $bool).\n\n[Changes for 0.05 - 2002-08-14]\n\n* Typo correction and safety checking.\n\n[Changes for 0.04 - 2002-08-14]\n\n* Added boilerplate text before SIGNATURE to explain what's it about.\n\n* Crypt::OpenPGP signature didn't work.\n\n* Add keyword expansion tags.\n", "---\nabstract: 'Module signature file manipulation'\nauthor:\n  - '\u5510\u9cf3 <cpan@audreyt.org>'\nbuild_requires:\n  ExtUtils::MakeMaker: 6.36\n  IPC::Run: 0\n  Test::More: 0\nconfigure_requires:\n  ExtUtils::MakeMaker: 6.36\ndistribution_type: module\ndynamic_config: 1\ngenerated_by: 'Module::Install version 1.06'\nlicense: cc0\nmeta-spec:\n  url: http://module-build.sourceforge.net/META-spec-v1.4.html\n  version: 1.4\nname: Module-Signature\nno_index:\n  directory:\n    - inc\n    - t\nrequires:\n  IO::Socket::INET: 0\n  perl: 5.005\nresources:\n  repository: http://github.com/audreyt/module-signature\nversion: 0.71\n", "package Module::Signature;\n$Module::Signature::VERSION = '0.71';\n\nuse 5.005;\nuse strict;\nuse vars qw($VERSION $SIGNATURE @ISA @EXPORT_OK);\nuse vars qw($Preamble $Cipher $Debug $Verbose $Timeout);\nuse vars qw($KeyServer $KeyServerPort $AutoKeyRetrieve $CanKeyRetrieve);\n\nuse constant CANNOT_VERIFY       => '0E0';\nuse constant SIGNATURE_OK        => 0;\nuse constant SIGNATURE_MISSING   => -1;\nuse constant SIGNATURE_MALFORMED => -2;\nuse constant SIGNATURE_BAD       => -3;\nuse constant SIGNATURE_MISMATCH  => -4;\nuse constant MANIFEST_MISMATCH   => -5;\nuse constant CIPHER_UNKNOWN      => -6;\n\nuse ExtUtils::Manifest ();\nuse Exporter;\n\n@EXPORT_OK      = (\n    qw(sign verify),\n    qw($SIGNATURE $KeyServer $Cipher $Preamble),\n    (grep { /^[A-Z_]+_[A-Z_]+$/ } keys %Module::Signature::),\n);\n@ISA            = 'Exporter';\n\n$SIGNATURE      = 'SIGNATURE';\n$Timeout        = $ENV{MODULE_SIGNATURE_TIMEOUT} || 3;\n$Verbose        = $ENV{MODULE_SIGNATURE_VERBOSE} || 0;\n$KeyServer      = $ENV{MODULE_SIGNATURE_KEYSERVER} || 'pool.sks-keyservers.net';\n$KeyServerPort  = $ENV{MODULE_SIGNATURE_KEYSERVERPORT} || '11371';\n$Cipher         = $ENV{MODULE_SIGNATURE_CIPHER} || 'SHA1';\n$Preamble       = << \".\";\nThis file contains message digests of all files listed in MANIFEST,\nsigned via the Module::Signature module, version $VERSION.\n\nTo verify the content in this distribution, first make sure you have\nModule::Signature installed, then type:\n\n    % cpansign -v\n\nIt will check each file's integrity, as well as the signature's\nvalidity.  If \"==> Signature verified OK! <==\" is not displayed,\nthe distribution may already have been compromised, and you should\nnot run its Makefile.PL or Build.PL.\n\n.\n\n$AutoKeyRetrieve    = 1;\n$CanKeyRetrieve     = undef;\n\nsub _cipher_map {\n    my($sigtext) = @_;\n    my @lines = split /\\015?\\012/, $sigtext;\n    my %map;\n    for my $line (@lines) {\n        my($cipher,$digest,$file) = split \" \", $line, 3;\n        return unless defined $file;\n        $map{$file} = [$cipher, $digest];\n    }\n    return \\%map;\n}\n\nsub verify {\n    my %args = ( skip => 1, @_ );\n    my $rv;\n\n    (-r $SIGNATURE) or do {\n        warn \"==> MISSING Signature file! <==\\n\";\n        return SIGNATURE_MISSING;\n    };\n\n    (my $sigtext = _read_sigfile($SIGNATURE)) or do {\n        warn \"==> MALFORMED Signature file! <==\\n\";\n        return SIGNATURE_MALFORMED;\n    };\n\n    (my ($cipher_map) = _cipher_map($sigtext)) or do {\n        warn \"==> MALFORMED Signature file! <==\\n\";\n        return SIGNATURE_MALFORMED;\n    };\n\n    (defined(my $plaintext = _mkdigest($cipher_map))) or do {\n        warn \"==> UNKNOWN Cipher format! <==\\n\";\n        return CIPHER_UNKNOWN;\n    };\n\n    $rv = _verify($SIGNATURE, $sigtext, $plaintext);\n\n    if ($rv == SIGNATURE_OK) {\n        my ($mani, $file) = _fullcheck($args{skip});\n\n        if (@{$mani} or @{$file}) {\n            warn \"==> MISMATCHED content between MANIFEST and distribution files! <==\\n\";\n            return MANIFEST_MISMATCH;\n        }\n        else {\n            warn \"==> Signature verified OK! <==\\n\" if $Verbose;\n        }\n    }\n    elsif ($rv == SIGNATURE_BAD) {\n        warn \"==> BAD/TAMPERED signature detected! <==\\n\";\n    }\n    elsif ($rv == SIGNATURE_MISMATCH) {\n        warn \"==> MISMATCHED content between SIGNATURE and distribution files! <==\\n\";\n    }\n\n    return $rv;\n}\n\nsub _verify {\n    my $signature = shift || $SIGNATURE;\n    my $sigtext   = shift || '';\n    my $plaintext = shift || '';\n\n    local $SIGNATURE = $signature if $signature ne $SIGNATURE;\n\n    if ($AutoKeyRetrieve and !$CanKeyRetrieve) {\n        if (!defined $CanKeyRetrieve) {\n            require IO::Socket::INET;\n            my $sock = IO::Socket::INET->new(\n                Timeout => $Timeout,\n                PeerAddr => \"$KeyServer:$KeyServerPort\",\n            );\n            $CanKeyRetrieve = ($sock ? 1 : 0);\n            $sock->shutdown(2) if $sock;\n        }\n        $AutoKeyRetrieve = $CanKeyRetrieve;\n    }\n\n    if (my $version = _has_gpg()) {\n        return _verify_gpg($sigtext, $plaintext, $version);\n    }\n    elsif (eval {require Crypt::OpenPGP; 1}) {\n        return _verify_crypt_openpgp($sigtext, $plaintext);\n    }\n    else {\n        warn \"Cannot use GnuPG or Crypt::OpenPGP, please install either one first!\\n\";\n        return _compare($sigtext, $plaintext, CANNOT_VERIFY);\n    }\n}\n\nsub _has_gpg {\n    my $gpg = _which_gpg() or return;\n    `$gpg --version` =~ /GnuPG.*?(\\S+)\\s*$/m or return;\n    return $1;\n}\n\nsub _fullcheck {\n    my $skip = shift;\n    my @extra;\n\n    local $^W;\n    local $ExtUtils::Manifest::Quiet = 1;\n\n    my($mani, $file);\n    if( _legacy_extutils() ) {\n        my $_maniskip;\n        if ( _public_maniskip() ) {\n            $_maniskip = &ExtUtils::Manifest::maniskip;\n        } else {\n            $_maniskip = &ExtUtils::Manifest::_maniskip;\n        }\n\n        local *ExtUtils::Manifest::_maniskip = sub { sub {\n            return unless $skip;\n            my $ok = $_maniskip->(@_);\n            if ($ok ||= (!-e 'MANIFEST.SKIP' and _default_skip(@_))) {\n                print \"Skipping $_\\n\" for @_;\n                push @extra, @_;\n            }\n            return $ok;\n        } };\n\n        ($mani, $file) = ExtUtils::Manifest::fullcheck();\n    }\n    else {\n        ($mani, $file) = ExtUtils::Manifest::fullcheck();\n    }\n\n    foreach my $makefile ('Makefile', 'Build') {\n        warn \"==> SKIPPED CHECKING '$_'!\" .\n                (-e \"$_.PL\" && \" (run $_.PL to ensure its integrity)\") .\n                \" <===\\n\" for grep $_ eq $makefile, @extra;\n    }\n\n    @{$mani} = grep {$_ ne 'SIGNATURE'} @{$mani};\n\n    warn \"Not in MANIFEST: $_\\n\" for @{$file};\n    warn \"No such file: $_\\n\" for @{$mani};\n\n    return ($mani, $file);\n}\n\nsub _legacy_extutils {\n    # ExtUtils::Manifest older than 1.58 does not handle MYMETA.\n    return (ExtUtils::Manifest->VERSION < 1.58);\n}\n\nsub _public_maniskip {\n    # ExtUtils::Manifest 1.54 onwards have public maniskip\n    return (ExtUtils::Manifest->VERSION > 1.53);\n}\n\nsub _default_skip {\n    local $_ = shift;\n    return 1 if /\\bRCS\\b/ or /\\bCVS\\b/ or /\\B\\.svn\\b/ or /,v$/\n             or /^MANIFEST\\.bak/ or /^Makefile$/ or /^blib\\//\n             or /^MakeMaker-\\d/ or /^pm_to_blib/ or /^blibdirs/\n             or /^_build\\// or /^Build$/ or /^pmfiles\\.dat/\n             or /^MYMETA\\./\n             or /~$/ or /\\.old$/ or /\\#$/ or /^\\.#/;\n}\n\nmy $which_gpg;\nsub _which_gpg {\n    # Cache it so we don't need to keep checking.\n    return $which_gpg if $which_gpg;\n\n    for my $gpg_bin ('gpg', 'gpg2', 'gnupg', 'gnupg2') {\n        my $version = `$gpg_bin --version 2>&1`;\n        if( $version && $version =~ /GnuPG/ ) {\n            $which_gpg = $gpg_bin;\n            return $which_gpg;\n        }\n    }\n}\n\nsub _verify_gpg {\n    my ($sigtext, $plaintext, $version) = @_;\n\n    local $SIGNATURE = Win32::GetShortPathName($SIGNATURE)\n        if defined &Win32::GetShortPathName and $SIGNATURE =~ /[^-\\w.:~\\\\\\/]/;\n\n    my $keyserver = _keyserver($version);\n\n    my $gpg = _which_gpg();\n    my @quiet = $Verbose ? () : qw(-q --logger-fd=1);\n    my @cmd = (\n        $gpg, qw(--verify --batch --no-tty), @quiet, ($KeyServer ? (\n            \"--keyserver=$keyserver\",\n            ($AutoKeyRetrieve and $version ge '1.0.7')\n                ? '--keyserver-options=auto-key-retrieve'\n                : ()\n        ) : ()), $SIGNATURE\n    );\n\n    my $output = '';\n    if( $Verbose ) {\n        warn \"Executing @cmd\\n\";\n        system @cmd;\n    }\n    else {\n        my $cmd = join ' ', @cmd;\n        $output = `$cmd`;\n    }\n\n    if( $? ) {\n        print STDERR $output;\n    }\n    elsif ($output =~ /((?: +[\\dA-F]{4}){10,})/) {\n        warn \"WARNING: This key is not certified with a trusted signature!\\n\";\n        warn \"Primary key fingerprint:$1\\n\";\n    }\n\n    return SIGNATURE_BAD if ($? and $AutoKeyRetrieve);\n    return _compare($sigtext, $plaintext, (!$?) ? SIGNATURE_OK : CANNOT_VERIFY);\n}\n\nsub _keyserver {\n    my $version = shift;\n    my $scheme = 'x-hkp';\n    $scheme = 'hkp' if $version ge '1.2.0';\n\n    return \"$scheme://$KeyServer:$KeyServerPort\";\n}\n\nsub _verify_crypt_openpgp {\n    my ($sigtext, $plaintext) = @_;\n\n    require Crypt::OpenPGP;\n    my $pgp = Crypt::OpenPGP->new(\n        ($KeyServer) ? ( KeyServer => $KeyServer, AutoKeyRetrieve => $AutoKeyRetrieve ) : (),\n    );\n    my $rv = $pgp->handle( Filename => $SIGNATURE )\n        or die $pgp->errstr;\n\n    return SIGNATURE_BAD if (!$rv->{Validity} and $AutoKeyRetrieve);\n\n    if ($rv->{Validity}) {\n        warn 'Signature made ', scalar localtime($rv->{Signature}->timestamp),\n             ' using key ID ', substr(uc(unpack('H*', $rv->{Signature}->key_id)), -8), \"\\n\",\n             \"Good signature from \\\"$rv->{Validity}\\\"\\n\" if $Verbose;\n    }\n    else {\n        warn \"Cannot verify signature; public key not found\\n\";\n    }\n\n    return _compare($sigtext, $plaintext, $rv->{Validity} ? SIGNATURE_OK : CANNOT_VERIFY);\n}\n\nsub _read_sigfile {\n    my $sigfile = shift;\n    my $signature = '';\n    my $well_formed;\n\n    local *D;\n    open D, $sigfile or die \"Could not open $sigfile: $!\";\n\n    if ($] >= 5.006 and <D> =~ /\\r/) {\n        close D;\n        open D, $sigfile or die \"Could not open $sigfile: $!\";\n        binmode D, ':crlf';\n    } else {\n        close D;\n        open D, $sigfile or die \"Could not open $sigfile: $!\";\n    }\n\n    while (<D>) {\n        next if (1 .. /^-----BEGIN PGP SIGNED MESSAGE-----/);\n        last if /^-----BEGIN PGP SIGNATURE/;\n\n        $signature .= $_;\n    }\n\n    return ((split(/\\n+/, $signature, 2))[1]);\n}\n\nsub _compare {\n    my ($str1, $str2, $ok) = @_;\n\n    # normalize all linebreaks\n    $str1 =~ s/[^\\S ]+/\\n/g; $str2 =~ s/[^\\S ]+/\\n/g;\n\n    return $ok if $str1 eq $str2;\n\n    if (eval { require Text::Diff; 1 }) {\n        warn \"--- $SIGNATURE \".localtime((stat($SIGNATURE))[9]).\"\\n\";\n        warn '+++ (current) '.localtime().\"\\n\";\n        warn Text::Diff::diff( \\$str1, \\$str2, { STYLE => 'Unified' } );\n    }\n    else {\n        local (*D, *S);\n        open S, $SIGNATURE or die \"Could not open $SIGNATURE: $!\";\n        open D, \"| diff -u $SIGNATURE -\" or (warn \"Could not call diff: $!\", return SIGNATURE_MISMATCH);\n        while (<S>) {\n            print D $_ if (1 .. /^-----BEGIN PGP SIGNED MESSAGE-----/);\n            print D if (/^Hash: / .. /^$/);\n            next if (1 .. /^-----BEGIN PGP SIGNATURE/);\n            print D $str2, \"-----BEGIN PGP SIGNATURE-----\\n\", $_ and last;\n        }\n        print D <S>;\n        close D;\n    }\n\n    return SIGNATURE_MISMATCH;\n}\n\nsub sign {\n    my %args = ( skip => 1, @_ );\n    my $overwrite = $args{overwrite};\n    my $plaintext = _mkdigest();\n\n    my ($mani, $file) = _fullcheck($args{skip});\n\n    if (@{$mani} or @{$file}) {\n        warn \"==> MISMATCHED content between MANIFEST and the distribution! <==\\n\";\n        warn \"==> Please correct your MANIFEST file and/or delete extra files. <==\\n\";\n    }\n\n    if (!$overwrite and -e $SIGNATURE and -t STDIN) {\n        local $/ = \"\\n\";\n        print \"$SIGNATURE already exists; overwrite [y/N]? \";\n        return unless <STDIN> =~ /[Yy]/;\n    }\n\n    if (my $version = _has_gpg()) {\n        _sign_gpg($SIGNATURE, $plaintext, $version);\n    }\n    elsif (eval {require Crypt::OpenPGP; 1}) {\n        _sign_crypt_openpgp($SIGNATURE, $plaintext);\n    }\n    else {\n        die 'Cannot use GnuPG or Crypt::OpenPGP, please install either one first!';\n    }\n\n    warn \"==> SIGNATURE file created successfully. <==\\n\";\n    return SIGNATURE_OK;\n}\n\nsub _sign_gpg {\n    my ($sigfile, $plaintext, $version) = @_;\n\n    die \"Could not write to $sigfile\"\n        if -e $sigfile and (-d $sigfile or not -w $sigfile);\n\n    my $gpg = _which_gpg();\n\n    local *D;\n    open D, \"| $gpg --clearsign >> $sigfile.tmp\" or die \"Could not call $gpg: $!\";\n    print D $plaintext;\n    close D;\n\n    (-e \"$sigfile.tmp\" and -s \"$sigfile.tmp\") or do {\n        unlink \"$sigfile.tmp\";\n        die \"Cannot find $sigfile.tmp, signing aborted.\\n\";\n    };\n\n    open D, \"$sigfile.tmp\" or die \"Cannot open $sigfile.tmp: $!\";\n\n    open S, \">$sigfile\" or do {\n        unlink \"$sigfile.tmp\";\n        die \"Could not write to $sigfile: $!\";\n    };\n\n    print S $Preamble;\n    print S <D>;\n\n    close S;\n    close D;\n\n    unlink(\"$sigfile.tmp\");\n\n    my $key_id;\n    my $key_name;\n    # This doesn't work because the output from verify goes to STDERR.\n    # If I try to redirect it using \"--logger-fd 1\" it just hangs.\n    # WTF?\n    my @verify = `$gpg --batch --verify $SIGNATURE`;\n    while (@verify) {\n        if (/key ID ([0-9A-F]+)$/) {\n            $key_id = $1;\n        } elsif (/signature from \"(.+)\"$/) {\n            $key_name = $1;\n        }\n    }\n\n    my $found_name;\n    my $found_key;\n    if (defined $key_id && defined $key_name) {\n        my $keyserver = _keyserver($version);\n        while (`$gpg --batch --keyserver=$keyserver --search-keys '$key_name'`) {\n            if (/^\\(\\d+\\)/) {\n                $found_name = 0;\n            } elsif ($found_name) {\n                if (/key \\Q$key_id\\E/) {\n                    $found_key = 1;\n                    last;\n                }\n            }\n\n            if (/\\Q$key_name\\E/) {\n                $found_name = 1;\n                next;\n            }\n        }\n\n        unless ($found_key) {\n            _warn_non_public_signature($key_name);\n        }\n    }\n\n    return 1;\n}\n\nsub _sign_crypt_openpgp {\n    my ($sigfile, $plaintext) = @_;\n\n    require Crypt::OpenPGP;\n    my $pgp = Crypt::OpenPGP->new;\n    my $ring = Crypt::OpenPGP::KeyRing->new(\n        Filename => $pgp->{cfg}->get('SecRing')\n    ) or die $pgp->error(Crypt::OpenPGP::KeyRing->errstr);\n    my $kb = $ring->find_keyblock_by_index(-1)\n        or die $pgp->error('Can\\'t find last keyblock: ' . $ring->errstr);\n\n    my $cert = $kb->signing_key;\n    my $uid = $cert->uid($kb->primary_uid);\n    warn \"Debug: acquiring signature from $uid\\n\" if $Debug;\n\n    my $signature = $pgp->sign(\n        Data       => $plaintext,\n        Detach     => 0,\n        Clearsign  => 1,\n        Armour     => 1,\n        Key        => $cert,\n        PassphraseCallback => \\&Crypt::OpenPGP::_default_passphrase_cb,\n    ) or die $pgp->errstr;\n\n\n    local *D;\n    open D, \"> $sigfile\" or die \"Could not write to $sigfile: $!\";\n    print D $Preamble;\n    print D $signature;\n    close D;\n\n    require Crypt::OpenPGP::KeyServer;\n    my $server = Crypt::OpenPGP::KeyServer->new(Server => $KeyServer);\n\n    unless ($server->find_keyblock_by_keyid($cert->key_id)) {\n        _warn_non_public_signature($uid);\n    }\n\n    return 1;\n}\n\nsub _warn_non_public_signature {\n    my $uid = shift;\n\n    warn <<\"EOF\"\nYou have signed this distribution with a key ($uid) that cannot be\nfound on the public key server at $KeyServer.\n\nThis will probably cause signature verification to fail if your module\nis distributed on CPAN.\nEOF\n}\n\nsub _mkdigest {\n    my $digest = _mkdigest_files(@_) or return;\n    my $plaintext = '';\n\n    foreach my $file (sort keys %$digest) {\n        next if $file eq $SIGNATURE;\n        $plaintext .= \"@{$digest->{$file}} $file\\n\";\n    }\n\n    return $plaintext;\n}\n\nsub _digest_object {\n    my($algorithm) = @_;\n\n    # Avoid loading Digest::* from relative paths in @INC.\n    local @INC = grep { /^[^.]/ } @INC;\n\n    # Constrain algorithm name to be of form ABC123.\n    my ($base, $variant) = ($algorithm =~ /^([_a-zA-Z]+)([0-9]+)$/g)\n        or die \"Malformed algorithm name: $algorithm (should match /\\\\w+\\\\d+/)\";\n\n    my $obj = eval { Digest->new($algorithm) } || eval {\n        require \"Digest/$base.pm\"; \"Digest::$base\"->new($variant)\n    } || eval {\n        require \"Digest/$algorithm.pm\"; \"Digest::$algorithm\"->new\n    } || eval {\n        require \"Digest/$base/PurePerl.pm\"; \"Digest::$base\\::PurePerl\"->new($variant)\n    } || eval {\n        require \"Digest/$algorithm/PurePerl.pm\"; \"Digest::$algorithm\\::PurePerl\"->new\n    } or do { eval {\n        warn \"Unknown cipher: $algorithm, please install Digest::$base, Digest::$base$variant, or Digest::$base\\::PurePerl\\n\";\n    } and return } or do {\n        warn \"Unknown cipher: $algorithm, please install Digest::$algorithm\\n\"; return;\n    };\n    $obj;\n}\n\nsub _mkdigest_files {\n    my $verify_map = shift;\n    my $dosnames = (defined(&Dos::UseLFN) && Dos::UseLFN()==0);\n    my $read = ExtUtils::Manifest::maniread() || {};\n    my $found = ExtUtils::Manifest::manifind();\n    my(%digest) = ();\n    my($default_obj) = _digest_object($Cipher);\n FILE: foreach my $file (sort keys %$read){\n        next FILE if $file eq $SIGNATURE;\n        my($obj,$this_cipher,$this_hexdigest,$verify_digest);\n        if ($verify_map) {\n            if (my $vmf = $verify_map->{$file}) {\n                ($this_cipher,$verify_digest) = @$vmf;\n                if ($this_cipher eq $Cipher) {\n                    $obj = $default_obj;\n                } else {\n                    $obj = _digest_object($this_cipher);\n                }\n            } else {\n                $this_cipher = $Cipher;\n                $obj = $default_obj;\n            }\n        } else {\n            $this_cipher = $Cipher;\n            $obj = $default_obj;\n        }\n        warn \"Debug: collecting digest from $file\\n\" if $Debug;\n        if ($dosnames){\n            $file = lc $file;\n            $file =~ s!(\\.(\\w|-)+)!substr ($1,0,4)!ge;\n            $file =~ s!((\\w|-)+)!substr ($1,0,8)!ge;\n        }\n        unless ( exists $found->{$file} ) {\n            warn \"No such file: $file\\n\" if $Verbose;\n        }\n        else {\n            local *F;\n            open F, $file or die \"Cannot open $file for reading: $!\";\n            if (-B $file) {\n                binmode(F);\n                $obj->addfile(*F);\n                $this_hexdigest = $obj->hexdigest;\n            }\n            elsif ($^O eq 'MSWin32') {\n                $obj->addfile(*F);\n                $this_hexdigest = $obj->hexdigest;\n            }\n            else {\n                # Normalize by hand...\n                local $/;\n                binmode(F);\n                my $input = <F>;\n            VERIFYLOOP: for my $eol (\"\",\"\\015\\012\",\"\\012\") {\n                    my $lax_input = $input;\n                    if (! length $eol) {\n                        # first try is binary\n                    } else {\n                        my @lines = split /$eol/, $input, -1;\n                        if (grep /[\\015\\012]/, @lines) {\n                            # oops, apparently not a text file, treat as binary, forget @lines\n                        } else {\n                            my $other_eol = $eol eq \"\\012\" ? \"\\015\\012\" : \"\\012\";\n                            $lax_input = join $other_eol, @lines;\n                        }\n                    }\n                    $obj->add($lax_input);\n                    $this_hexdigest = $obj->hexdigest;\n                    if ($verify_digest) {\n                        if ($this_hexdigest eq $verify_digest) {\n                            last VERIFYLOOP;\n                        }\n                        $obj->reset;\n                    } else {\n                        last VERIFYLOOP;\n                    }\n                }\n            }\n            $digest{$file} = [$this_cipher, $this_hexdigest];\n            $obj->reset;\n        }\n    }\n\n    return \\%digest;\n}\n\n1;\n\n__END__\n\n=encoding utf8\n\n=head1 NAME\n\nModule::Signature - Module signature file manipulation\n\n=head1 SYNOPSIS\n\nAs a shell command:\n\n    % cpansign              # verify an existing SIGNATURE, or\n                            # make a new one if none exists\n\n    % cpansign sign         # make signature; overwrites existing one\n    % cpansign -s           # same thing\n\n    % cpansign verify       # verify a signature\n    % cpansign -v           # same thing\n    % cpansign -v --skip    # ignore files in MANIFEST.SKIP\n\n    % cpansign help         # display this documentation\n    % cpansign -h           # same thing\n\nIn programs:\n\n    use Module::Signature qw(sign verify SIGNATURE_OK);\n    sign();\n    sign(overwrite => 1);       # overwrites without asking\n\n    # see the CONSTANTS section below\n    (verify() == SIGNATURE_OK) or die \"failed!\";\n\n=head1 DESCRIPTION\n\nB<Module::Signature> adds cryptographic authentications to CPAN\ndistributions, via the special F<SIGNATURE> file.\n\nIf you are a module user, all you have to do is to remember to run\nC<cpansign -v> (or just C<cpansign>) before issuing C<perl Makefile.PL>\nor C<perl Build.PL>; that will ensure the distribution has not been\ntampered with.\n\nModule authors can easily add the F<SIGNATURE> file to the distribution\ntarball; see L</NOTES> below for how to do it as part of C<make dist>.\n\nIf you I<really> want to sign a distribution manually, simply add\nC<SIGNATURE> to F<MANIFEST>, then type C<cpansign -s> immediately\nbefore C<make dist>.  Be sure to delete the F<SIGNATURE> file afterwards.\n\nPlease also see L</NOTES> about F<MANIFEST.SKIP> issues, especially if\nyou are using B<Module::Build> or writing your own F<MANIFEST.SKIP>.\n\n=head1 VARIABLES\n\nNo package variables are exported by default.\n\n=over 4\n\n=item $Verbose\n\nIf true, Module::Signature will give information during processing including\ngpg output.  If false, Module::Signature will be as quiet as possible as\nlong as everything is working ok.  Defaults to false.\n\n=item $SIGNATURE\n\nThe filename for a distribution's signature file.  Defaults to\nC<SIGNATURE>.\n\n=item $KeyServer\n\nThe OpenPGP key server for fetching the author's public key\n(currently only implemented on C<gpg>, not C<Crypt::OpenPGP>).\nMay be set to a false value to prevent this module from\nfetching public keys.\n\n=item $KeyServerPort\n\nThe OpenPGP key server port, defaults to C<11371>.\n\n=item $Timeout\n\nMaximum time to wait to try to establish a link to the key server.\nDefaults to C<3>.\n\n=item $AutoKeyRetrieve\n\nWhether to automatically fetch unknown keys from the key server.\nDefaults to C<1>.\n\n=item $Cipher\n\nThe default cipher used by the C<Digest> module to make signature\nfiles.  Defaults to C<SHA1>, but may be changed to other ciphers\nvia the C<MODULE_SIGNATURE_CIPHER> environment variable if the SHA1\ncipher is undesirable for the user.\n\nThe cipher specified in the F<SIGNATURE> file's first entry will\nbe used to validate its integrity.  For C<SHA1>, the user needs\nto have any one of these four modules installed: B<Digest::SHA>,\nB<Digest::SHA1>, B<Digest::SHA::PurePerl>, or (currently nonexistent)\nB<Digest::SHA1::PurePerl>.\n\n=item $Preamble\n\nThe explanatory text written to newly generated F<SIGNATURE> files\nbefore the actual entries.\n\n=back\n\n=head1 ENVIRONMENT\n\nB<Module::Signature> honors these environment variables:\n\n=over 4\n\n=item MODULE_SIGNATURE_CIPHER\n\nWorks like C<$Cipher>.\n\n=item MODULE_SIGNATURE_VERBOSE\n\nWorks like C<$Verbose>.\n\n=item MODULE_SIGNATURE_KEYSERVER\n\nWorks like C<$KeyServer>.\n\n=item MODULE_SIGNATURE_KEYSERVERPORT\n\nWorks like C<$KeyServerPort>.\n\n=item MODULE_SIGNATURE_TIMEOUT\n\nWorks like C<$Timeout>.\n\n=back\n\n=head1 CONSTANTS\n\nThese constants are not exported by default.\n\n=over 4\n\n=item CANNOT_VERIFY (C<0E0>)\n\nCannot verify the OpenPGP signature, maybe due to the lack of a network\nconnection to the key server, or if neither gnupg nor Crypt::OpenPGP\nexists on the system.\n\n=item SIGNATURE_OK (C<0>)\n\nSignature successfully verified.\n\n=item SIGNATURE_MISSING (C<-1>)\n\nThe F<SIGNATURE> file does not exist.\n\n=item SIGNATURE_MALFORMED (C<-2>)\n\nThe signature file does not contains a valid OpenPGP message.\n\n=item SIGNATURE_BAD (C<-3>)\n\nInvalid signature detected -- it might have been tampered with.\n\n=item SIGNATURE_MISMATCH (C<-4>)\n\nThe signature is valid, but files in the distribution have changed\nsince its creation.\n\n=item MANIFEST_MISMATCH (C<-5>)\n\nThere are extra files in the current directory not specified by\nthe MANIFEST file.\n\n=item CIPHER_UNKNOWN (C<-6>)\n\nThe cipher used by the signature file is not recognized by the\nC<Digest> and C<Digest::*> modules.\n\n=back\n\n=head1 NOTES\n\n=head2 Signing your module as part of C<make dist>\n\nThe easiest way is to use B<Module::Install>:\n\n    sign;       # put this before \"WriteAll\"\n    WriteAll;\n\nFor B<ExtUtils::MakeMaker> (version 6.18 or above), you may do this:\n\n    WriteMakefile(\n        (MM->can('signature_target') ? (SIGN => 1) : ()),\n        # ... original arguments ...\n    );\n\nUsers of B<Module::Build> may do this:\n\n    Module::Build->new(\n        (sign => 1),\n        # ... original arguments ...\n    )->create_build_script;\n\n=head2 F<MANIFEST.SKIP> Considerations\n\n(The following section is lifted from Iain Truskett's B<Test::Signature>\nmodule, under the Perl license.  Thanks, Iain!)\n\nIt is B<imperative> that your F<MANIFEST> and F<MANIFEST.SKIP> files be\naccurate and complete. If you are using C<ExtUtils::MakeMaker> and you\ndo not have a F<MANIFEST.SKIP> file, then don't worry about the rest of\nthis. If you do have a F<MANIFEST.SKIP> file, or you use\nC<Module::Build>, you must read this.\n\nSince the test is run at C<make test> time, the distribution has been\nmade. Thus your F<MANIFEST.SKIP> file should have the entries listed\nbelow.\n\nIf you're using C<ExtUtils::MakeMaker>, you should have, at least:\n\n    #defaults\n    ^Makefile$\n    ^blib/\n    ^pm_to_blib\n    ^blibdirs\n\nThese entries are part of the default set provided by\nC<ExtUtils::Manifest>, which is ignored if you provide your own\nF<MANIFEST.SKIP> file.\n\nIf you are using C<Module::Build>, you should have two extra entries:\n\n    ^Build$\n    ^_build/\n\nIf you don't have the correct entries, C<Module::Signature> will\ncomplain that you have:\n\n    ==> MISMATCHED content between MANIFEST and distribution files! <==\n\nYou should note this during normal development testing anyway.\n\n=head2 Testing signatures\n\nYou may add this code as F<t/0-signature.t> in your distribution tree:\n\n    #!/usr/bin/perl\n\n    use strict;\n    print \"1..1\\n\";\n\n    if (!$ENV{TEST_SIGNATURE}) {\n        print \"ok 1 # skip Set the environment variable\",\n                    \" TEST_SIGNATURE to enable this test\\n\";\n    }\n    elsif (!-s 'SIGNATURE') {\n        print \"ok 1 # skip No signature file found\\n\";\n    }\n    elsif (!eval { require Module::Signature; 1 }) {\n        print \"ok 1 # skip \",\n                \"Next time around, consider install Module::Signature, \",\n                \"so you can verify the integrity of this distribution.\\n\";\n    }\n    elsif (!eval { require Socket; Socket::inet_aton('pool.sks-keyservers.net') }) {\n        print \"ok 1 # skip \",\n                \"Cannot connect to the keyserver\\n\";\n    }\n    else {\n        (Module::Signature::verify() == Module::Signature::SIGNATURE_OK())\n            or print \"not \";\n        print \"ok 1 # Valid signature\\n\";\n    }\n\n    __END__\n\nIf you are already using B<Test::More> for testing, a more\nstraightforward version of F<t/0-signature.t> can be found in the\nB<Module::Signature> distribution.\n\nAlso, if you prefer a more full-fledged testing package, and are\nwilling to inflict the dependency of B<Module::Build> on your users,\nIain Truskett's B<Test::Signature> might be a better choice.\n\n=cut\n\n=head1 SEE ALSO\n\nL<Digest>, L<Digest::SHA>, L<Digest::SHA1>, L<Digest::SHA::PurePerl>\n\nL<ExtUtils::Manifest>, L<Crypt::OpenPGP>, L<Test::Signature>\n\nL<Module::Install>, L<ExtUtils::MakeMaker>, L<Module::Build>\n\n=head1 AUTHORS\n\n\u5510\u9cf3 E<lt>cpan@audreyt.orgE<gt>\n\n=head1 CC0 1.0 Universal\n\nTo the extent possible under law, \u5510\u9cf3 has waived all copyright and related\nor neighboring rights to Module-Signature.\n\nThis work is published from Taiwan.\n\nL<http://creativecommons.org/publicdomain/zero/1.0>\n\n=cut\n"], "filenames": ["Changes", "META.yml", "lib/Module/Signature.pm"], "buggy_code_start_loc": [0, 28, 2], "buggy_code_end_loc": [0, 29, 547], "fixing_code_start_loc": [1, 28, 2], "fixing_code_end_loc": [9, 29, 551], "type": "CWE-20", "message": "The cpansign verify functionality in the Module::Signature module before 0.72 for Perl allows attackers to bypass the signature check and execute arbitrary code via a SIGNATURE file with a \"special unknown cipher\" that references an untrusted module in Digest/.", "other": {"cve": {"id": "CVE-2013-2145", "sourceIdentifier": "secalert@redhat.com", "published": "2013-08-19T23:55:08.397", "lastModified": "2018-10-30T16:27:34.373", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The cpansign verify functionality in the Module::Signature module before 0.72 for Perl allows attackers to bypass the signature check and execute arbitrary code via a SIGNATURE file with a \"special unknown cipher\" that references an untrusted module in Digest/."}, {"lang": "es", "value": "La funcionalidad de verificaci\u00f3n  cpansign en el  m\u00f3dulo Module::Signature anterior a  0.72 para  Perl, permite a atacantes evitar la comprobaci\u00f3n de firma y ejecutar c\u00f3digo arbitrarioa trav\u00e9s de un archivo SIGNATURE con \"un cifrado desconocido especial\" que referencia a un m\u00f3dulo no confiable en Digest/."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:-:lts:*:*:*:*:*", "matchCriteriaId": "F5D324C4-97C7-49D3-A809-9EAD4B690C69"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.10:*:*:*:*:*:*:*", "matchCriteriaId": "E2076871-2E80-4605-A470-A41C1A8EC7EE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:13.04:*:*:*:*:*:*:*", "matchCriteriaId": "EFAA48D9-BEB4-4E49-AD50-325C262D46D9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:11.4:*:*:*:*:*:*:*", "matchCriteriaId": "DE554781-1EB9-446E-911F-6C11970C47F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:12.2:*:*:*:*:*:*:*", "matchCriteriaId": "D806A17E-B8F9-466D-807D-3F1E77603DC8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:12.3:*:*:*:*:*:*:*", "matchCriteriaId": "DFBF430B-0832-44B0-AA0E-BA9E467F7668"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:perlmonks:module\\:\\:signature:*:*:*:*:*:perl:*:*", "versionEndIncluding": "0.72", "matchCriteriaId": "2E6F9A20-E1C8-44DA-93DA-159F0CF69AD8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:perlmonks:module\\:\\:signature:0.70:*:*:*:*:perl:*:*", "matchCriteriaId": "A0220732-83D9-438E-A6A8-997E11187221"}, {"vulnerable": true, "criteria": "cpe:2.3:a:perlmonks:module\\:\\:signature:0.71:*:*:*:*:perl:*:*", "matchCriteriaId": "F3716378-31D1-4E92-B3D3-3529750C76DB"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2013-07/msg00039.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-07/msg00043.html", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/06/05/16", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/60352", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1896-1", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=971096", "source": "secalert@redhat.com"}, {"url": "https://github.com/audreyt/module-signature/commit/575f7bd6ba4cc7c92f841e8758f88a131674ebf2", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://github.com/audreyt/module-signature/commit/cbd06b392a73c63159dc5c20ff5b3c8fc88c4896", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/audreyt/module-signature/commit/575f7bd6ba4cc7c92f841e8758f88a131674ebf2"}}