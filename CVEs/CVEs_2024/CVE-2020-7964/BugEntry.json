{"buggy_code": ["# Changelog\n\nAll notable, unreleased changes to this project will be documented in this file. For the released changes, please visit the [Releases](https://github.com/mirumee/saleor/releases) page.\n\n## [Unreleased]\n\n- Account confirmation email - #5126 by @tomaszszymanski129\n- Relocate Checkout and CheckoutLine methods into separate module and update checkout related plugins to use them - #4980 by @krzysztofwolski\n- Fix problem with free shipping voucher - #4942 by @IKarbowiak\n- Add sub-categories to random data - #4949 by @IKarbowiak\n- Deprecate `localized` field in Money type - #4952 by @IKarbowiak\n- Fix for shipping api doesn't apply taxes - #4913 by @kswiatek92\n- Query object translation with only manage_translation permission - #4914 by @fowczarek\n- Add customer note to draft orders api - #4973 by @IKarbowiak\n- Allow to delete category and leave products - #4970 by @IKarbowiak\n- Remove thumbnail generation from migration - #3494 by @kswiatek92\n- Rename 'shipping_date' field in fulfillment model to 'created' - #2433 by @kswiatek92\n- Reduce number of queries for 'completeCheckout' mutation - #4989 by @IKarbowiak\n- Now force pytest to ignore the environment variable containing the django settings module - #4992 by @NyanKiyoshi\n- Extend JWT token payload with user information - #4987 by @salwator\n- Optimize the queries for product list in the dashboard - #4995 by @IKarbowiak\n- Drop dashboard 1.0 - #5000 by @IKarbowiak\n- Fixed serialization error on weight fields when running `loaddata` and `dumpdb` - #5005 by @NyanKiyoshi\n- Fixed JSON encoding error on Google Analytics reporting - #5004 by @NyanKiyoshi\n- Create custom field to translation, use new translation types in translations query - #5007 by @fowczarek\n- Take allocated stock in account in `StockAvailability` filter - #5019 by @simonbru\n- Generate matching postal codes for US addresses - #5033 by @maarcingebala\n- Update debug toolbar - #5032 by @IKarbowiak\n- Allow staff member to receive notification about customers orders - #4993 by @kswiatek92\n- JWT payload now contains user global id - #5039 by @salwator\n- Made middleware path resolving lazy and refactored middleware names - #5041 by @NyanKiyoshi\n- Generate slug in attribute value save - #5055 by @fowczarek\n- Fix order status after order update - #5072 by @fowczarek\n- Extend top-level connection resolvers with ability to sort results - #5018 by @fowczarek\n- Drop storefront 1.0 - #5043 by @IKarbowiak\n- Replace permissions strings with enums - #5038 by @kswiatek92\n- Remove gateways forms and templates - #5075 by @IKarbowiak\n- Add `Wishlist` models and GraphQL endpoints - #5021 by @derenio\n- Remove deprecated code - #5107 by @IKarbowiak\n- Fix voucher start date filtering - #5133 by @dominik-zeglen\n- Search by sku in products query - #5117 by @fowczarek\n- Send fulfillment update email - #5118 by @IKarbowiak\n- Add address query - #5148 by @kswiatek92\n- Add `checkout_quantity_changed` webhook - #5042 by @derenio\n- Remove unnecessary manage_orders permission - #5142 by @kswiatek92\n- Mutation to change user email - #5076 by @kswiatek92\n- Add mypy checks - #5150 by @IKarbowiak\n- Move extracting user or service_account from context to utils - #5152 by @kswiatek92\n- Add deprecate description to order status/created arguments - #5076 by @kswiatek92\n- Fix getting title field in page mutations #5160 by @maarcingebala\n- Copy public and private metadata from the checkout to the order upon creation - #5165 by @dankolbman\n- Add warehouses and stocks- #4986 by @szewczykmira\n- Add permission groups - #5176 by @IKarbowiak\n- Drop gettext occurrences - #5189 by @IKarbowiak\n- Fix `product_created` webhook - #5187 by @dzkb\n- Drop unused resolver `resolve_availability` - #5190 by @maarcingebala\n\n## 2.9.0\n\n### API\n\n- Add mutation to change customer's first name last name - #4489 by @fowczarek\n- Add mutation to delete customer's account - #4494 by @fowczarek\n- Add mutation to change customer's password - #4656 by @fowczarek\n- Add ability to customize email sender address in emails sent by Saleor - #4820 by @NyanKiyoshi\n- Add ability to filter attributes per global ID - #4640 by @NyanKiyoshi\n- Add ability to search product types by value (through the name) - #4647 by @NyanKiyoshi\n- Add queries and mutation for serving and saving the configuration of all plugins - #4576 by @korycins\n- Add `redirectUrl` to staff and user create mutations - #4717 by @fowczarek\n- Add error codes to mutations responses - #4676 by @Kwaidan00\n- Add translations to countries in `shop` query - #4732 by @fowczarek\n- Add support for sorting product by their attribute values through given attribute ID - #4740 by @NyanKiyoshi\n- Add descriptions for queries and query arguments - #4758 by @maarcingebala\n- Add support for Apollo Federation - #4825 by @salwator\n- Add mutation to create multiple product variants at once - #4735 by @fowczarek\n- Add default value to custom errors - #4797 by @fowczarek\n- Extend `availablePaymentGateways` field with gateways' configuration data - #4774 by @salwator\n- Change `AddressValidationRules` API - #4655 by @Kwaidan00\n- Use search in a consistent way; add sort by product type name and publication status to `products` query. - #4715 by @fowczarek\n- Unify `menuItemMove` mutation with other reordering mutations - #4734 by @NyanKiyoshi\n- Don't create an order when the payment was unsuccessful - #4500 by @NyanKiyoshi\n- Don't require shipping information in checkout for digital orders - #4573 by @NyanKiyoshi\n- Drop `manage_users` permission from the `permissions` query - #4854 by @maarcingebala\n- Deprecate `inCategory` and `inCollection` attributes filters in favor of `filter` argument - #4700 by @NyanKiyoshi & @khalibloo\n- Remove `PaymentGatewayEnum` from the schema, as gateways now are dynamic plugins - #4756 by @salwator\n- Require `manage_products` permission to query `costPrice` and `stockQuantity` fields - #4753 by @NyanKiyoshi\n- Refactor account mutations - #4510, #4668 by @fowczarek\n- Fix generating random avatars when updating staff accounts - #4521 by @maarcingebala\n- Fix updating JSON menu representation in mutations - #4524 by @maarcingebala\n- Fix setting variant's `priceOverride` and `costPrice` to `null` - #4754 by @NyanKiyoshi\n- Fix fetching staff user without `manage_users` permission - #4835 by @fowczarek\n- Ensure that a GraphQL query is a string - #4836 by @nix010\n- Add ability to configure the password reset link - #4863 by @fowczarek\n\n### Core\n\n- Add enterprise-grade attributes management - #4351 by @dominik-zeglen and @NyanKiyoshix\n- Add extensions manager - #4497 by @korycins\n- Add service accounts - backend support - #4689 by @korycins\n- Add support for webhooks - #4731 by @korycins\n- Migrate the attributes mapping from HStore to many-to-many relation - #4663 by @NyanKiyoshi\n- Create general abstraction for object metadata - #4447 by @salwator\n- Add metadata to `Order` and `Fulfillment` models - #4513, #4866 by @szewczykmira\n- Migrate the tax calculations to plugins - #4497 by @korycins\n- Rewrite payment gateways using plugin architecture - #4669 by @salwator\n- Rewrite Stripe integration to use PaymentIntents API - #4606 by @salwator\n- Refactor password recovery system - #4617 by @fowczarek\n- Add functionality to sort products by their \"minimal variant price\" - #4416 by @derenio\n- Add voucher's \"once per customer\" feature - #4442 by @fowczarek\n- Add validations for minimum password length in settings - #4735 by @fowczarek\n- Add form to configure payments in the dashboard - #4807 by @szewczykmira\n- Change `unique_together` in `AttributeValue` - #4805 by @fowczarek\n- Change max length of SKU to 255 characters - #4811 by @lex111\n- Distinguish `OrderLine` product name and variant name - #4702 by @fowczarek\n- Fix updating order status after automatic fulfillment of digital products - #4709 by @korycins\n- Fix error when updating or creating a sale with missing required values - #4778 by @NyanKiyoshi\n- Fix error filtering pages by URL in the dashboard 1.0 - #4776 by @NyanKiyoshi\n- Fix display of the products tax rate in the details page of dashboard 1.0 - #4780 by @NyanKiyoshi\n- Fix adding the same product into a collection multiple times - #4518 by @NyanKiyoshi\n- Fix crash when placing an order when a customer happens to have the same address more than once - #4824 by @NyanKiyoshi\n- Fix time zone based tests - #4468 by @fowczarek\n- Fix serializing empty URLs as a string when creating menu items - #4616 by @maarcingebala\n- The invalid IP address in HTTP requests now fallback to the requester's IP address. - #4597 by @NyanKiyoshi\n- Fix product variant update with current attribute values - #4936 by @fowczarek\n- Update checkout last field and add auto now fields to save with update_fields parameter - #5177 by @IKarbowiak\n\n### Dashboard 2.0\n\n- Allow selecting the number of rows displayed in dashboard's list views - #4414 by @benekex2\n- Add ability to toggle visible columns in product list - #4608 by @dominik-zeglen\n- Add voucher settings - #4556 by @benekex2\n- Contrast improvements - #4508 by @benekex2\n- Display menu item form errors - #4551 by @dominik-zeglen\n- Do not allow random IDs to appear in snapshots - #4495 by @dominik-zeglen\n- Input UI changes - #4542 by @benekex2\n- Implement new menu design - #4476 by @benekex2\n- Refetch attribute list after closing modal - #4615 by @dominik-zeglen\n- Add config for Testcafe - #4553 by @dominik-zeglen\n- Fix product type taxes select - #4453 by @benekex2\n- Fix form reloading - #4467 by @dominik-zeglen\n- Fix voucher limit value when checkbox unchecked - #4456 by @benekex2\n- Fix searches and pickers - #4487 by @dominik-zeglen\n- Fix dashboard menu styles - #4491 by @benekex2\n- Fix menu responsiveness - #4511 by @benekex2\n- Fix loosing focus while typing in the product description field - #4549 by @dominik-zeglen\n- Fix MUI warnings - #4588 by @dominik-zeglen\n- Fix bulk action checkboxes - #4618 by @dominik-zeglen\n- Fix rendering user avatar when it's empty #4546 by @maarcingebala\n- Remove Dashboard 2.0 files form Saleor repository - #4631 by @dominik-zeglen\n\n### Other notable changes\n\n- Replace Pipenv with Poetry - #3894 by @michaljelonek\n- Upgrade `django-prices` to v2.1 - #4639 by @NyanKiyoshi\n- Disable reports from uWSGI about broken pipe and write errors from disconnected clients - #4596 by @NyanKiyoshi\n- Fix the random failures of `populatedb` trying to create users with an existing email - #4769 by @NyanKiyoshi\n- Enforce `pydocstyle` for Python docstrings over the project - #4562 by @NyanKiyoshi\n- Move Django Debug Toolbar to dev requirements - #4454 by @derenio\n- Change license for artwork to CC-BY 4.0\n- New translations:\n  - Greek\n\n## 2.8.0\n\n### Core\n\n- Avatax backend support - #4310 by @korycins\n- Add ability to store used payment sources in gateways (first implemented in Braintree) - #4195 by @salwator\n- Add ability to specify a minimal quantity of checkout items for a voucher - #4427 by @fowczarek\n- Change the type of start and end date fields from Date to DateTime - #4293 by @fowczarek\n- Revert the custom dynamic middlewares - #4452 by @NyanKiyoshi\n\n### Dashboard 2.0\n\n- UX improvements in Vouchers section - #4362 by @benekex2\n- Add company address configuration - #4432 by @benekex2\n- Require name when saving a custom list filter - #4269 by @benekex2\n- Use `esModuleInterop` flag in `tsconfig.json` to simplify imports - #4372 by @dominik-zeglen\n- Use hooks instead of a class component in forms - #4374 by @dominik-zeglen\n- Drop CSRF token header from API client - #4357 by @dominik-zeglen\n- Fix various bugs in the product section - #4429 by @dominik-zeglen\n\n### Other notable changes\n\n- Fix error when creating a checkout with voucher code - #4292 by @NyanKiyoshi\n- Fix error when users enter an invalid phone number in an address - #4404 by @NyanKiyoshi\n- Fix error when adding a note to an anonymous order - #4319 by @NyanKiyoshi\n- Fix gift card duplication error in the `populatedb` script - #4336 by @fowczarek\n- Fix vouchers apply once per order - #4339 by @fowczarek\n- Fix discount tests failing at random - #4401 by @korycins\n- Add `SPECIFIC_PRODUCT` type to `VoucherType` - #4344 by @fowczarek\n- New translations:\n  - Icelandic\n- Refactored the backend side of `checkoutCreate` to improve performances and prevent side effects over the user's checkout if the checkout creation was to fail. - #4367 by @NyanKiyoshi\n- Refactored the logic of cleaning the checkout shipping method over the API, so users do not lose the shipping method when updating their checkout. If the shipping method becomes invalid, it will be replaced by the cheapest available. - #4367 by @NyanKiyoshi & @szewczykmira\n- Refactored process of getting available shipping methods to make it easier to understand and prevent human-made errors. - #4367 by @NyanKiyoshi\n- Moved 3D secure option to Braintree plugin configuration and update config structure mechanism - #4751 by @salwator\n\n## 2.7.0\n\n### API\n\n- Create order only when payment is successful - #4154 by @NyanKiyoshi\n- Order Events containing order lines or fulfillment lines now return the line object in the GraphQL API - #4114 by @NyanKiyoshi\n- GraphQL now prints exceptions to stderr as well as returning them or not - #4148 by @NyanKiyoshi\n- Refactored API resolvers to static methods with root typing - #4155 by @NyanKiyoshi\n- Add phone validation in the GraphQL API to handle the library upgrade - #4156 by @NyanKiyoshi\n\n### Core\n\n- Add basic Gift Cards support in the backend - #4025 by @fowczarek\n- Add the ability to sort products within a collection - #4123 by @NyanKiyoshi\n- Implement customer events - #4094 by @NyanKiyoshi\n- Merge \"authorize\" and \"capture\" operations - #4098 by @korycins, @NyanKiyoshi\n- Separate the Django middlewares from the GraphQL API middlewares - #4102 by @NyanKiyoshi, #4186 by @cmiacz\n\n### Dashboard 2.0\n\n- Add navigation section - #4012 by @dominik-zeglen\n- Add filtering on product list - #4193 by @dominik-zeglen\n- Add filtering on orders list - #4237 by @dominik-zeglen\n- Change input style and improve Storybook stories - #4115 by @dominik-zeglen\n- Migrate deprecated fields in Dashboard 2.0 - #4121 by @benekex2\n- Add multiple select checkbox - #4133, #4146 by @benekex2\n- Rename menu items in Dashboard 2.0 - #4172 by @benekex2\n- Category delete modal improvements - #4171 by @benekex2\n- Close modals on click outside - #4236 - by @benekex2\n- Use date localize hook in translations - #4202 by @dominik-zeglen\n- Unify search API - #4200 by @dominik-zeglen\n- Default default PAGINATE_BY - #4238 by @dominik-zeglen\n- Create generic filtering interface - #4221 by @dominik-zeglen\n- Add default state to rich text editor = #4281 by @dominik-zeglen\n- Fix translation discard button - #4109 by @benekex2\n- Fix draftail options and icons - #4132 by @benekex2\n- Fix typos and messages in Dashboard 2.0 - #4168 by @benekex2\n- Fix view all orders button - #4173 by @benekex2\n- Fix visibility card view - #4198 by @benekex2\n- Fix query refetch after selecting an object in list - #4272 by @dominik-zeglen\n- Fix image selection in variants - #4270 by @benekex2\n- Fix collection search - #4267 by @dominik-zeglen\n- Fix quantity height in draft order edit - #4273 by @benekex2\n- Fix checkbox clickable area size - #4280 by @dominik-zeglen\n- Fix breaking object selection in menu section - #4282 by @dominik-zeglen\n- Reset selected items when tab switch - #4268 by @benekex2\n\n### Other notable changes\n\n- Add support for Google Cloud Storage - #4127 by @chetabahana\n- Adding a nonexistent variant to checkout no longer crashes - #4166 by @NyanKiyoshi\n- Disable storage of Celery results - #4169 by @NyanKiyoshi\n- Disable polling in Playground - #4188 by @maarcingebala\n- Cleanup code for updated function names and unused argument - #4090 by @jxltom\n- Users can now add multiple \"Add to Cart\" forms in a single page - #4165 by @NyanKiyoshi\n- Fix incorrect argument in `get_client_token` in Braintree integration - #4182 by @maarcingebala\n- Fix resolving attribute values when transforming them to HStore - #4161 by @maarcingebala\n- Fix wrong calculation of subtotal in cart page - #4145 by @korycins\n- Fix margin calculations when product/variant price is set to zero - #4170 by @MahmoudRizk\n- Fix applying discounts in checkout's subtotal calculation in API - #4192 by @maarcingebala\n- Fix GATEWAYS_ENUM to always contain all implemented payment gateways - #4108 by @koradon\n\n## 2.6.0\n\n### API\n\n- Add unified filtering interface in resolvers - #3952, #4078 by @korycins\n- Add mutations for bulk actions - #3935, #3954, #3967, #3969, #3970 by @akjanik\n- Add mutation for reordering menu items - #3958 by @NyanKiyoshi\n- Optimize queries for single nodes - #3968 @NyanKiyoshi\n- Refactor error handling in mutations #3891 by @maarcingebala & @akjanik\n- Specify mutation permissions through Meta classes - #3980 by @NyanKiyoshi\n- Unify pricing access in products and variants - #3948 by @NyanKiyoshi\n- Use only_fields instead of exclude_fields in type definitions - #3940 by @michaljelonek\n- Prefetch collections when getting sales of a bunch of products - #3961 by @NyanKiyoshi\n- Remove unnecessary dedents from GraphQL schema so new Playground can work - #4045 by @salwator\n- Restrict resolving payment by ID - #4009 @NyanKiyoshi\n- Require `checkoutId` for updating checkout's shipping and billing address - #4074 by @jxltom\n- Handle errors in `TokenVerify` mutation - #3981 by @fowczarek\n- Unify argument names in types and resolvers - #3942 by @NyanKiyoshi\n\n### Core\n\n- Use Black as the default code formatting tool - #3852 by @krzysztofwolski and @NyanKiyoshi\n- Dropped Python 3.5 support - #4028 by @korycins\n- Rename Cart to Checkout - #3963 by @michaljelonek\n- Use data classes to exchange data with payment gateways - #4028 by @korycins\n- Refactor order events - #4018 by @NyanKiyoshi\n\n### Dashboard 2.0\n\n- Add bulk actions - #3955 by @dominik-zeglen\n- Add user avatar management - #4030 by @benekex2\n- Add navigation drawer support on mobile devices - #3839 by @benekex2\n- Fix rendering validation errors in product form - #4024 by @benekex2\n- Move dialog windows to query string rather than router paths - #3953 by @dominik-zeglen\n- Update order events types - #4089 by @jxltom\n- Code cleanup by replacing render props with react hooks - #4010 by @dominik-zeglen\n\n### Other notable changes\n\n- Add setting to enable Django Debug Toolbar - #3983 by @koradon\n- Use newest GraphQL Playground - #3971 by @salwator\n- Ensure adding to quantities in the checkout is respecting the limits - #4005 by @NyanKiyoshi\n- Fix country area choices - #4008 by @fowczarek\n- Fix price_range_as_dict function - #3999 by @zodiacfireworks\n- Fix the product listing not showing in the voucher when there were products selected - #4062 by @NyanKiyoshi\n- Fix crash in Dashboard 1.0 when updating an order address's phone number - #4061 by @NyanKiyoshi\n- Reduce the time of tests execution by using dummy password hasher - #4083 by @korycins\n- Set up explicit **hash** function - #3979 by @akjanik\n- Unit tests use none as media root - #3975 by @korycins\n- Update file field styles with materializecss template filter - #3998 by @zodiacfireworks\n- New translations:\n  - Albanian\n  - Colombian Spanish\n  - Lithuanian\n\n## 2.5.0\n\n### API\n\n- Add query to fetch draft orders - #3809 by @michaljelonek\n- Add bulk delete mutations - #3838 by @michaljelonek\n- Add `languageCode` enum to API - #3819 by @michaljelonek, #3854 by @jxltom\n- Duplicate address instances in checkout mutations - #3866 by @pawelzar\n- Restrict access to `orders` query for unauthorized users - #3861 by @pawelzar\n- Support setting address as default in address mutations - #3787 by @jxltom\n- Fix phone number validation in GraphQL when country prefix not given - #3905 by @patrys\n- Report pretty stack traces in DEBUG mode - #3918 by @patrys\n\n### Core\n\n- Drop support for Django 2.1 and Django 1.11 (previous LTS) - #3929 by @patrys\n- Fulfillment of digital products - #3868 by @korycins\n- Introduce avatars for staff accounts - #3878 by @pawelzar\n- Refactor the account avatars path from a relative to absolute - #3938 by @NyanKiyoshi\n\n### Dashboard 2.0\n\n- Add translations section - #3884 by @dominik-zeglen\n- Add light/dark theme - #3856 by @dominik-zeglen\n- Add customer's address book view - #3826 by @dominik-zeglen\n- Add \"Add variant\" button on the variant details page = #3914 by @dominik-zeglen\n- Add back arrows in \"Configure\" subsections - #3917 by @dominik-zeglen\n- Display avatars in staff views - #3922 by @dominik-zeglen\n- Prevent user from changing his own status and permissions - #3922 by @dominik-zeglen\n- Fix crashing product create view - #3837, #3910 by @dominik-zeglen\n- Fix layout in staff members details page - #3857 by @dominik-zeglen\n- Fix unfocusing rich text editor - #3902 by @dominik-zeglen\n- Improve accessibility - #3856 by @dominik-zeglen\n\n### Other notable changes\n\n- Improve user and staff management in dashboard 1.0 - #3781 by @jxltom\n- Fix default product tax rate in Dashboard 1.0 - #3880 by @pawelzar\n- Fix logo in docs - #3928 by @michaljelonek\n- Fix name of logo file - #3867 by @jxltom\n- Fix variants for juices in example data - #3926 by @michaljelonek\n- Fix alignment of the cart dropdown on new bootstrap version - #3937 by @NyanKiyoshi\n- Refactor the account avatars path from a relative to absolute - #3938 by @NyanKiyoshi\n- New translations:\n  - Armenian\n  - Portuguese\n  - Swahili\n  - Thai\n\n## 2.4.0\n\n### API\n\n- Add model translations support in GraphQL API - #3789 by @michaljelonek\n- Add mutations to manage addresses for authenticated customers - #3772 by @Kwaidan00, @maarcingebala\n- Add mutation to apply vouchers in checkout - #3739 by @Kwaidan00\n- Add thumbnail field to `OrderLine` type - #3737 by @michaljelonek\n- Add a query to fetch order by token - #3740 by @michaljelonek\n- Add city choices and city area type to address validator API - #3788 by @jxltom\n- Fix access to unpublished objects in API - #3724 by @Kwaidan00\n- Fix bug where errors are not returned when creating fulfillment with a non-existent order line - #3777 by @jxltom\n- Fix `productCreate` mutation when no product type was provided - #3804 by @michaljelonek\n- Enable database search in products query - #3736 by @michaljelonek\n- Use authenticated user's email as default email in creating checkout - #3726 by @jxltom\n- Generate voucher code if it wasn't provided in mutation - #3717 by @Kwaidan00\n- Improve limitation of vouchers by country - #3707 by @michaljelonek\n- Only include canceled fulfillments for staff in fulfillment API - #3778 by @jxltom\n- Support setting address as when creating customer address #3782 by @jxltom\n- Fix generating slug from title - #3816 by @maarcingebala\n- Add `variant` field to `OrderLine` type - #3820 by @maarcingebala\n\n### Core\n\n- Add JSON fields to store rich-text content - #3756 by @michaljelonek\n- Add function to recalculate total order weight - #3755 by @Kwaidan00, @maarcingebala\n- Unify cart creation logic in API and Django views - #3761, #3790 by @maarcingebala\n- Unify payment creation logic in API and Django views - #3715 by @maarcingebala\n- Support partially charged and refunded payments - #3735 by @jxltom\n- Support partial fulfillment of ordered items - #3754 by @jxltom\n- Fix applying discounts when a sale has no end date - #3595 by @cprinos\n\n### Dashboard 2.0\n\n- Add \"Discounts\" section - #3654 by @dominik-zeglen\n- Add \"Pages\" section; introduce Draftail WYSIWYG editor - #3751 by @dominik-zeglen\n- Add \"Shipping Methods\" section - #3770 by @dominik-zeglen\n- Add support for date and datetime components - #3708 by @dominik-zeglen\n- Restyle app layout - #3811 by @dominik-zeglen\n\n### Other notable changes\n\n- Unify model field names related to models' public access - `publication_date` and `is_published` - #3706 by @michaljelonek\n- Improve filter orders by payment status - #3749 @jxltom\n- Refactor translations in emails - #3701 by @Kwaidan00\n- Use exact image versions in docker-compose - #3742 by @ashishnitinpatil\n- Sort order payment and history in descending order - #3747 by @jxltom\n- Disable style-loader in dev mode - #3720 by @jxltom\n- Add ordering to shipping method - #3806 by @michaljelonek\n- Add missing type definition for dashboard 2.0 - #3776 by @jxltom\n- Add header and footer for checkout success pages #3752 by @jxltom\n- Add instructions for using local assets in Docker - #3723 by @michaljelonek\n- Update S3 deployment documentation to include CORS configuration note - #3743 by @NyanKiyoshi\n- Fix missing migrations for is_published field of product and page model - #3757 by @jxltom\n- Fix problem with l10n in Braintree payment gateway template - #3691 by @Kwaidan00\n- Fix bug where payment is not filtered from active ones when creating payment - #3732 by @jxltom\n- Fix incorrect cart badge location - #3786 by @jxltom\n- Fix storefront styles after bootstrap is updated to 4.3.1 - #3753 by @jxltom\n- Fix logo size in different browser and devices with different sizes - #3722 by @jxltom\n- Rename dumpdata file `db.json` to `populatedb_data.json` - #3810 by @maarcingebala\n- Prefetch collections for product availability - #3813 by @michaljelonek\n- Bump django-graphql-jwt - #3814 by @michaljelonek\n- Fix generating slug from title - #3816 by @maarcingebala\n- New translations:\n  - Estonian\n  - Indonesian\n\n## 2.3.1\n\n- Fix access to private variant fields in API - #3773 by maarcingebala\n- Limit access of quantity and allocated quantity to staff in GraphQL API #3780 by @jxltom\n\n## 2.3.0\n\n### API\n\n- Return user's last checkout in the `User` type - #3578 by @fowczarek\n- Automatically assign checkout to the logged in user - #3587 by @fowczarek\n- Expose `chargeTaxesOnShipping` field in the `Shop` type - #3603 by @fowczarek\n- Expose list of enabled payment gateways - #3639 by @fowczarek\n- Validate uploaded files in a unified way - #3633 by @fowczarek\n- Add mutation to trigger fetching tax rates - #3622 by @fowczarek\n- Use USERNAME_FIELD instead of hard-code email field when resolving user - #3577 by @jxltom\n- Require variant and quantity fields in `CheckoutLineInput` type - #3592 by @jxltom\n- Preserve order of nodes in `get_nodes_or_error` function - #3632 by @jxltom\n- Add list mutations for `Voucher` and `Sale` models - #3669 by @michaljelonek\n- Use proper type for countries in `Voucher` type - #3664 by @michaljelonek\n- Require email in when creating checkout in API - #3667 by @michaljelonek\n- Unify returning errors in the `tokenCreate` mutation - #3666 by @michaljelonek\n- Use `Date` field in Sale/Voucher inputs - #3672 by @michaljelonek\n- Refactor checkout mutations - #3610 by @fowczarek\n- Refactor `clean_instance`, so it does not returns errors anymore - #3597 by @akjanik\n- Handle GraphqQL syntax errors - #3576 by @jxltom\n\n### Core\n\n- Refactor payments architecture - #3519 by @michaljelonek\n- Improve Docker and `docker-compose` configuration - #3657 by @michaljelonek\n- Allow setting payment status manually for dummy gateway in Storefront 1.0 - #3648 by @jxltom\n- Infer default transaction kind from operation type - #3646 by @jxltom\n- Get correct payment status for order without any payments - #3605 by @jxltom\n- Add default ordering by `id` for `CartLine` model - #3593 by @jxltom\n- Fix \"set password\" email sent to customer created in the dashboard - #3688 by @Kwaidan00\n\n### Dashboard 2.0\n\n- \ufe0fAdd taxes section - #3622 by @dominik-zeglen\n- Add drag'n'drop image upload - #3611 by @dominik-zeglen\n- Unify grid handling - #3520 by @dominik-zeglen\n- Add component generator - #3670 by @dominik-zeglen\n- Throw Typescript errors while snapshotting - #3611 by @dominik-zeglen\n- Simplify mutation's error checking - #3589 by @dominik-zeglen\n- Fix order cancelling - #3624 by @dominik-zeglen\n- Fix logo placement - #3602 by @dominik-zeglen\n\n### Other notable changes\n\n- Register Celery task for updating exchange rates - #3599 by @jxltom\n- Fix handling different attributes with the same slug - #3626 by @jxltom\n- Add missing migrations for tax rate choices - #3629 by @jxltom\n- Fix `TypeError` on calling `get_client_token` - #3660 by @michaljelonek\n- Make shipping required as default when creating product types - #3655 by @jxltom\n- Display payment status on customer's account page in Storefront 1.0 - #3637 by @jxltom\n- Make order fields sequence in Dashboard 1.0 same as in Dashboard 2.0 - #3606 by @jxltom\n- Fix returning products for homepage for the currently viewing user - #3598 by @jxltom\n- Allow filtering payments by status in Dashboard 1.0 - #3608 by @jxltom\n- Fix typo in the definition of order status - #3649 by @jxltom\n- Add margin for order notes section - #3650 by @jxltom\n- Fix logo position - #3609, #3616 by @jxltom\n- Storefront visual improvements - #3696 by @piotrgrundas\n- Fix product list price filter - #3697 by @Kwaidan00\n- Redirect to success page after successful payment - #3693 by @Kwaidan00\n\n## 2.2.0\n\n### API\n\n- Use `PermissionEnum` as input parameter type for `permissions` field - #3434 by @maarcingebala\n- Add \"authorize\" and \"charge\" mutations for payments - #3426 by @jxltom\n- Add alt text to product thumbnails and background images of collections and categories - #3429 by @fowczarek\n- Fix passing decimal arguments = #3457 by @fowczarek\n- Allow sorting products by the update date - #3470 by @jxltom\n- Validate and clear the shipping method in draft order mutations - #3472 by @fowczarek\n- Change tax rate field to choice field - #3478 by @fowczarek\n- Allow filtering attributes by collections - #3508 by @maarcingebala\n- Resolve to `None` when empty object ID was passed as mutation argument - #3497 by @maarcingebala\n- Change `errors` field type from [Error] to [Error!] - #3489 by @fowczarek\n- Support creating default variant for product types that don't use multiple variants - #3505 by @fowczarek\n- Validate SKU when creating a default variant - #3555 by @fowczarek\n- Extract enums to separate files - #3523 by @maarcingebala\n\n### Core\n\n- Add Stripe payment gateway - #3408 by @jxltom\n- Add `first_name` and `last_name` fields to the `User` model - #3101 by @fowczarek\n- Improve several payment validations - #3418 by @jxltom\n- Optimize payments related database queries - #3455 by @jxltom\n- Add publication date to collections - #3369 by @k-brk\n- Fix hard-coded site name in order PDFs - #3526 by @NyanKiyoshi\n- Update favicons to the new style - #3483 by @dominik-zeglen\n- Fix migrations for default currency - #3235 by @bykof\n- Remove Elasticsearch from `docker-compose.yml` - #3482 by @maarcingebala\n- Resort imports in tests - #3471 by @jxltom\n- Fix the no shipping orders payment crash on Stripe - #3550 by @NyanKiyoshi\n- Bump backend dependencies - #3557 by @maarcingebala. This PR removes security issue CVE-2019-3498 which was present in Django 2.1.4. Saleor however wasn't vulnerable to this issue as it doesn't use the affected `django.views.defaults.page_not_found()` view.\n- Generate random data using the default currency - #3512 by @stephenmoloney\n- New translations:\n  - Catalan\n  - Serbian\n\n### Dashboard 2.0\n\n- Restyle product selection dialogs - #3499 by @dominik-zeglen, @maarcingebala\n- Fix minor visual bugs in Dashboard 2.0 - #3433 by @dominik-zeglen\n- Display warning if order draft has missing data - #3431 by @dominik-zeglen\n- Add description field to collections - #3435 by @dominik-zeglen\n- Add query batching - #3443 by @dominik-zeglen\n- Use autocomplete fields in country selection - #3443 by @dominik-zeglen\n- Add alt text to categories and collections - #3461 by @dominik-zeglen\n- Use first and last name of a customer or staff member in UI - #3247 by @Bonifacy1, @dominik-zeglen\n- Show error page if an object was not found - #3463 by @dominik-zeglen\n- Fix simple product's inventory data saving bug - #3474 by @dominik-zeglen\n- Replace `thumbnailUrl` with `thumbnail { url }` - #3484 by @dominik-zeglen\n- Change \"Feature on Homepage\" switch behavior - #3481 by @dominik-zeglen\n- Expand payment section in order view - #3502 by @dominik-zeglen\n- Change TypeScript loader to speed up the build process - #3545 by @patrys\n\n### Bugfixes\n\n- Do not show `Pay For Order` if order is partly paid since partial payment is not supported - #3398 by @jxltom\n- Fix attribute filters in the products category view - #3535 by @fowczarek\n- Fix storybook dependencies conflict - #3544 by @dominik-zeglen\n\n## 2.1.0\n\n### API\n\n- Change selected connection fields to lists - #3307 by @fowczarek\n- Require pagination in connections - #3352 by @maarcingebala\n- Replace Graphene view with a custom one - #3263 by @patrys\n- Change `sortBy` parameter to use enum type - #3345 by @fowczarek\n- Add `me` query to fetch data of a logged-in user - #3202, #3316 by @fowczarek\n- Add `canFinalize` field to the Order type - #3356 by @fowczarek\n- Extract resolvers and mutations to separate files - #3248 by @fowczarek\n- Add VAT tax rates field to country - #3392 by @michaljelonek\n- Allow creating orders without users - #3396 by @fowczarek\n\n### Core\n\n- Add Razorpay payment gatway - #3205 by @NyanKiyoshi\n- Use standard tax rate as a default tax rate value - #3340 by @fowczarek\n- Add description field to the Collection model - #3275 by @fowczarek\n- Enforce the POST method on VAT rates fetching - #3337 by @NyanKiyoshi\n- Generate thumbnails for category/collection background images - #3270 by @NyanKiyoshi\n- Add warm-up support in product image creation mutation - #3276 by @NyanKiyoshi\n- Fix error in the `populatedb` script when running it not from the project root - #3272 by @NyanKiyoshi\n- Make Webpack rebuilds fast - #3290 by @patrys\n- Skip installing Chromium to make deployment faster - #3227 by @jxltom\n- Add default test runner - #3258 by @jxltom\n- Add Transifex client to Pipfile - #3321 by @jxltom\n- Remove additional pytest arguments in tox - #3338 by @jxltom\n- Remove test warnings - #3339 by @jxltom\n- Remove runtime warning when product has discount - #3310 by @jxltom\n- Remove `django-graphene-jwt` warnings - #3228 by @jxltom\n- Disable deprecated warnings - #3229 by @jxltom\n- Add `AWS_S3_ENDPOINT_URL` setting to support DigitalOcean spaces. - #3281 by @hairychris\n- Add `.gitattributes` file to hide diffs for generated files on Github - #3055 by @NyanKiyoshi\n- Add database sequence reset to `populatedb` - #3406 by @michaljelonek\n- Get authorized amount from succeeded auth transactions - #3417 by @jxltom\n- Resort imports by `isort` - #3412 by @jxltom\n\n### Dashboard 2.0\n\n- Add confirmation modal when leaving view with unsaved changes - #3375 by @dominik-zeglen\n- Add dialog loading and error states - #3359 by @dominik-zeglen\n- Split paths and urls - #3350 by @dominik-zeglen\n- Derive state from props in forms - #3360 by @dominik-zeglen\n- Apply debounce to autocomplete fields - #3351 by @dominik-zeglen\n- Use Apollo signatures - #3353 by @dominik-zeglen\n- Add order note field in the order details view - #3346 by @dominik-zeglen\n- Add app-wide progress bar - #3312 by @dominik-zeglen\n- Ensure that all queries are built on top of TypedQuery - #3309 by @dominik-zeglen\n- Close modal windows automatically - #3296 by @dominik-zeglen\n- Move URLs to separate files - #3295 by @dominik-zeglen\n- Add basic filters for products and orders list - #3237 by @Bonifacy1\n- Fetch default currency from API - #3280 by @dominik-zeglen\n- Add `displayName` property to components - #3238 by @Bonifacy1\n- Add window titles - #3279 by @dominik-zeglen\n- Add paginator component - #3265 by @dominik-zeglen\n- Update Material UI to 3.6 - #3387 by @patrys\n- Upgrade React, Apollo, Webpack and Babel - #3393 by @patrys\n- Add pagination for required connections - #3411 by @dominik-zeglen\n\n### Bugfixes\n\n- Fix language codes - #3311 by @jxltom\n- Fix resolving empty attributes list - #3293 by @maarcingebala\n- Fix range filters not being applied - #3385 by @michaljelonek\n- Remove timeout for updating image height - #3344 by @jxltom\n- Return error if checkout was not found - #3289 by @maarcingebala\n- Solve an auto-resize conflict between Materialize and medium-editor - #3367 by @adonig\n- Fix calls to `ngettext_lazy` - #3380 by @patrys\n- Filter preauthorized order from succeeded transactions - #3399 by @jxltom\n- Fix incorrect country code in fixtures - #3349 by @bingimar\n- Fix updating background image of a collection - #3362 by @fowczarek & @dominik-zeglen\n\n### Docs\n\n- Document settings related to generating thumbnails on demand - #3329 by @NyanKiyoshi\n- Improve documentation for Heroku deployment - #3170 by @raybesiga\n- Update documentation on Docker deployment - #3326 by @jxltom\n- Document payment gateway configuration - #3376 by @NyanKiyoshi\n\n## 2.0.0\n\n### API\n\n- Add mutation to delete a customer; add `isActive` field in `customerUpdate` mutation - #3177 by @maarcingebala\n- Add mutations to manage authorization keys - #3082 by @maarcingebala\n- Add queries for dashboard homepage - #3146 by @maarcingebala\n- Allows user to unset homepage collection - #3140 by @oldPadavan\n- Use enums as permission codes - #3095 by @the-bionic\n- Return absolute image URLs - #3182 by @maarcingebala\n- Add `backgroundImage` field to `CategoryInput` - #3153 by @oldPadavan\n- Add `dateJoined` and `lastLogin` fields in `User` type - #3169 by @maarcingebala\n- Separate `parent` input field from `CategoryInput` - #3150 by @akjanik\n- Remove duplicated field in Order type - #3180 by @maarcingebala\n- Handle empty `backgroundImage` field in API - #3159 by @maarcingebala\n- Generate name-based slug in collection mutations - #3145 by @akjanik\n- Remove products field from `collectionUpdate` mutation - #3141 by @oldPadavan\n- Change `items` field in `Menu` type from connection to list - #3032 by @oldPadavan\n- Make `Meta.description` required in `BaseMutation` - #3034 by @oldPadavan\n- Apply `textwrap.dedent` to GraphQL descriptions - #3167 by @fowczarek\n\n### Dashboard 2.0\n\n- Add collection management - #3135 by @dominik-zeglen\n- Add customer management - #3176 by @dominik-zeglen\n- Add homepage view - #3155, #3178 by @Bonifacy1 and @dominik-zeglen\n- Add product type management - #3052 by @dominik-zeglen\n- Add site settings management - #3071 by @dominik-zeglen\n- Escape node IDs in URLs - #3115 by @dominik-zeglen\n- Restyle categories section - #3072 by @Bonifacy1\n\n### Other\n\n- Change relation between `ProductType` and `Attribute` models - #3097 by @maarcingebala\n- Remove `quantity-allocated` generation in `populatedb` script - #3084 by @MartinSeibert\n- Handle `Money` serialization - #3131 by @Pacu2\n- Do not collect unnecessary static files - #3050 by @jxltom\n- Remove host mounted volume in `docker-compose` - #3091 by @tiangolo\n- Remove custom services names in `docker-compose` - #3092 by @tiangolo\n- Replace COUNTRIES with countries.countries - #3079 by @neeraj1909\n- Installing dev packages in docker since tests are needed - #3078 by @jxltom\n- Remove comparing string in address-form-panel template - #3074 by @tomcio1205\n- Move updating variant names to a Celery task - #3189 by @fowczarek\n\n### Bugfixes\n\n- Fix typo in `clean_input` method - #3100 by @the-bionic\n- Fix typo in `ShippingMethod` model - #3099 by @the-bionic\n- Remove duplicated variable declaration - #3094 by @the-bionic\n\n### Docs\n\n- Add createdb note to getting started for Windows - #3106 by @ajostergaard\n- Update docs on pipenv - #3045 by @jxltom\n", "from typing import List, Optional, Tuple\n\nimport graphene\nfrom django.conf import settings\nfrom django.core.exceptions import ObjectDoesNotExist, ValidationError\nfrom django.db import transaction\nfrom django.db.models import Prefetch\n\nfrom ...account.error_codes import AccountErrorCode\nfrom ...checkout import models\nfrom ...checkout.error_codes import CheckoutErrorCode\nfrom ...checkout.utils import (\n    abort_order_data,\n    add_promo_code_to_checkout,\n    add_variant_to_checkout,\n    change_billing_address_in_checkout,\n    change_shipping_address_in_checkout,\n    clean_checkout,\n    create_order,\n    get_user_checkout,\n    get_valid_shipping_methods_for_checkout,\n    prepare_order_data,\n    recalculate_checkout_discount,\n    remove_promo_code_from_checkout,\n)\nfrom ...core import analytics\nfrom ...core.exceptions import InsufficientStock\nfrom ...core.permissions import OrderPermissions\nfrom ...core.taxes import TaxError\nfrom ...core.utils.url import validate_storefront_url\nfrom ...discount import models as voucher_model\nfrom ...payment import PaymentError, gateway, models as payment_models\nfrom ...payment.interface import AddressData\nfrom ...payment.utils import store_customer_id\nfrom ...product import models as product_models\nfrom ...warehouse.availability import check_stock_quantity, get_available_quantity\nfrom ..account.i18n import I18nMixin\nfrom ..account.types import AddressInput, User\nfrom ..core.mutations import (\n    BaseMutation,\n    ClearMetaBaseMutation,\n    ModelMutation,\n    UpdateMetaBaseMutation,\n)\nfrom ..core.types.common import CheckoutError\nfrom ..core.utils import from_global_id_strict_type\nfrom ..order.types import Order\nfrom ..product.types import ProductVariant\nfrom ..shipping.types import ShippingMethod\nfrom .types import Checkout, CheckoutLine\n\nERROR_DOES_NOT_SHIP = \"This checkout doesn't need shipping\"\n\n\ndef clean_shipping_method(\n    checkout: models.Checkout, method: Optional[models.ShippingMethod], discounts\n) -> bool:\n    \"\"\"Check if current shipping method is valid.\"\"\"\n\n    if not method:\n        # no shipping method was provided, it is valid\n        return True\n\n    if not checkout.is_shipping_required():\n        raise ValidationError(\n            ERROR_DOES_NOT_SHIP, code=CheckoutErrorCode.SHIPPING_NOT_REQUIRED.value\n        )\n\n    if not checkout.shipping_address:\n        raise ValidationError(\n            \"Cannot choose a shipping method for a checkout without the \"\n            \"shipping address.\",\n            code=CheckoutErrorCode.SHIPPING_ADDRESS_NOT_SET.value,\n        )\n\n    valid_methods = get_valid_shipping_methods_for_checkout(checkout, discounts)\n    return method in valid_methods\n\n\ndef update_checkout_shipping_method_if_invalid(checkout: models.Checkout, discounts):\n    # remove shipping method when empty checkout\n    if checkout.quantity == 0 or not checkout.is_shipping_required():\n        checkout.shipping_method = None\n        checkout.save(update_fields=[\"shipping_method\", \"last_change\"])\n\n    is_valid = clean_shipping_method(\n        checkout=checkout, method=checkout.shipping_method, discounts=discounts\n    )\n\n    if not is_valid:\n        cheapest_alternative = get_valid_shipping_methods_for_checkout(\n            checkout, discounts\n        ).first()\n        checkout.shipping_method = cheapest_alternative\n        checkout.save(update_fields=[\"shipping_method\", \"last_change\"])\n\n\ndef check_lines_quantity(variants, quantities, country):\n    \"\"\"Check if stock is sufficient for each line in the list of dicts.\"\"\"\n    for variant, quantity in zip(variants, quantities):\n        if quantity < 0:\n            raise ValidationError(\n                {\n                    \"quantity\": ValidationError(\n                        \"The quantity should be higher than zero.\",\n                        code=CheckoutErrorCode.ZERO_QUANTITY,\n                    )\n                }\n            )\n        if quantity > settings.MAX_CHECKOUT_LINE_QUANTITY:\n            raise ValidationError(\n                {\n                    \"quantity\": ValidationError(\n                        \"Cannot add more than %d times this item.\"\n                        \"\" % settings.MAX_CHECKOUT_LINE_QUANTITY,\n                        code=CheckoutErrorCode.QUANTITY_GREATER_THAN_LIMIT,\n                    )\n                }\n            )\n        try:\n            check_stock_quantity(variant, country, quantity)\n        except InsufficientStock as e:\n            available_quantity = get_available_quantity(e.item, country)\n            message = (\n                \"Could not add item \"\n                + \"%(item_name)s. Only %(remaining)d remaining in stock.\"\n                % {\n                    \"remaining\": available_quantity,\n                    \"item_name\": e.item.display_product(),\n                }\n            )\n            raise ValidationError({\"quantity\": ValidationError(message, code=e.code)})\n\n\nclass CheckoutLineInput(graphene.InputObjectType):\n    quantity = graphene.Int(required=True, description=\"The number of items purchased.\")\n    variant_id = graphene.ID(required=True, description=\"ID of the product variant.\")\n\n\nclass CheckoutCreateInput(graphene.InputObjectType):\n    lines = graphene.List(\n        CheckoutLineInput,\n        description=(\n            \"A list of checkout lines, each containing information about \"\n            \"an item in the checkout.\"\n        ),\n        required=True,\n    )\n    email = graphene.String(description=\"The customer's email address.\")\n    shipping_address = AddressInput(\n        description=(\n            \"The mailing address to where the checkout will be shipped. \"\n            \"Note: the address will be ignored if the checkout \"\n            \"doesn't contain shippable items.\"\n        )\n    )\n    billing_address = AddressInput(description=\"Billing address of the customer.\")\n\n\nclass CheckoutCreate(ModelMutation, I18nMixin):\n    created = graphene.Field(\n        graphene.Boolean,\n        description=(\n            \"Whether the checkout was created or the current active one was returned. \"\n            \"Refer to checkoutLinesAdd and checkoutLinesUpdate to merge a cart \"\n            \"with an active checkout.\"\n        ),\n    )\n\n    class Arguments:\n        input = CheckoutCreateInput(\n            required=True, description=\"Fields required to create checkout.\"\n        )\n\n    class Meta:\n        description = \"Create a new checkout.\"\n        model = models.Checkout\n        return_field_name = \"checkout\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def process_checkout_lines(\n        cls, lines, country\n    ) -> Tuple[List[product_models.ProductVariant], List[int]]:\n        variant_ids = [line.get(\"variant_id\") for line in lines]\n        variants = cls.get_nodes_or_error(\n            variant_ids,\n            \"variant_id\",\n            ProductVariant,\n            qs=product_models.ProductVariant.objects.prefetch_related(\n                \"product__product_type\"\n            ),\n        )\n        quantities = [line.get(\"quantity\") for line in lines]\n\n        check_lines_quantity(variants, quantities, country)\n\n        return variants, quantities\n\n    @classmethod\n    def retrieve_shipping_address(cls, user, data: dict) -> Optional[models.Address]:\n        if \"shipping_address\" in data:\n            return cls.validate_address(data[\"shipping_address\"])\n        if user.is_authenticated:\n            return user.default_shipping_address\n        return None\n\n    @classmethod\n    def retrieve_billing_address(cls, user, data: dict) -> Optional[models.Address]:\n        if \"billing_address\" in data:\n            return cls.validate_address(data[\"billing_address\"])\n        if user.is_authenticated:\n            return user.default_billing_address\n        return None\n\n    @classmethod\n    def clean_input(cls, info, instance: models.Checkout, data, input_cls=None):\n        cleaned_input = super().clean_input(info, instance, data)\n        user = info.context.user\n        country = info.context.country.code\n\n        # Resolve and process the lines, retrieving the variants and quantities\n        lines = data.pop(\"lines\", None)\n        if lines:\n            (\n                cleaned_input[\"variants\"],\n                cleaned_input[\"quantities\"],\n            ) = cls.process_checkout_lines(lines, country)\n\n        cleaned_input[\"shipping_address\"] = cls.retrieve_shipping_address(user, data)\n        cleaned_input[\"billing_address\"] = cls.retrieve_billing_address(user, data)\n\n        # Use authenticated user's email as default email\n        if user.is_authenticated:\n            email = data.pop(\"email\", None)\n            cleaned_input[\"email\"] = email or user.email\n\n        return cleaned_input\n\n    @classmethod\n    def save_addresses(cls, instance: models.Checkout, cleaned_input: dict):\n        shipping_address = cleaned_input.get(\"shipping_address\")\n        billing_address = cleaned_input.get(\"billing_address\")\n\n        updated_fields = [\"last_change\"]\n\n        if shipping_address and instance.is_shipping_required():\n            shipping_address.save()\n            instance.shipping_address = shipping_address.get_copy()\n            updated_fields.append(\"shipping_address\")\n        if billing_address:\n            billing_address.save()\n            instance.billing_address = billing_address.get_copy()\n            updated_fields.append(\"billing_address\")\n\n        # Note django will simply return if the list is empty\n        instance.save(update_fields=updated_fields)\n\n    @classmethod\n    @transaction.atomic()\n    def save(cls, info, instance: models.Checkout, cleaned_input):\n        # Create the checkout object\n        instance.save()\n        country = info.context.country\n        instance.set_country(country.code, commit=True)\n\n        # Retrieve the lines to create\n        variants = cleaned_input.get(\"variants\")\n        quantities = cleaned_input.get(\"quantities\")\n\n        # Create the checkout lines\n        if variants and quantities:\n            for variant, quantity in zip(variants, quantities):\n                try:\n                    add_variant_to_checkout(instance, variant, quantity)\n                except InsufficientStock as exc:\n                    raise ValidationError(\n                        f\"Insufficient product stock: {exc.item}\", code=exc.code\n                    )\n\n        # Save provided addresses and associate them to the checkout\n        cls.save_addresses(instance, cleaned_input)\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        user = info.context.user\n\n        # `perform_mutation` is overridden to properly get or create a checkout\n        # instance here and abort mutation if needed.\n        if user.is_authenticated:\n            checkout, _ = get_user_checkout(user)\n\n            if checkout is not None:\n                # If user has an active checkout, return it without any\n                # modifications.\n                return CheckoutCreate(checkout=checkout, created=False)\n\n            checkout = models.Checkout(user=user)\n        else:\n            checkout = models.Checkout()\n\n        cleaned_input = cls.clean_input(info, checkout, data.get(\"input\"))\n        checkout = cls.construct_instance(checkout, cleaned_input)\n        cls.clean_instance(info, checkout)\n        cls.save(info, checkout, cleaned_input)\n        cls._save_m2m(info, checkout, cleaned_input)\n        return CheckoutCreate(checkout=checkout, created=True)\n\n\nclass CheckoutLinesAdd(BaseMutation):\n    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")\n\n    class Arguments:\n        checkout_id = graphene.ID(description=\"The ID of the checkout.\", required=True)\n        lines = graphene.List(\n            CheckoutLineInput,\n            required=True,\n            description=(\n                \"A list of checkout lines, each containing information about \"\n                \"an item in the checkout.\"\n            ),\n        )\n\n    class Meta:\n        description = \"Adds a checkout line to the existing checkout.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id, lines, replace=False):\n        checkout = cls.get_node_or_error(\n            info, checkout_id, only_type=Checkout, field=\"checkout_id\"\n        )\n\n        variant_ids = [line.get(\"variant_id\") for line in lines]\n        variants = cls.get_nodes_or_error(variant_ids, \"variant_id\", ProductVariant)\n        quantities = [line.get(\"quantity\") for line in lines]\n\n        check_lines_quantity(variants, quantities, checkout.get_country())\n\n        if variants and quantities:\n            for variant, quantity in zip(variants, quantities):\n                try:\n                    add_variant_to_checkout(\n                        checkout, variant, quantity, replace=replace\n                    )\n                except InsufficientStock as exc:\n                    raise ValidationError(\n                        f\"Insufficient product stock: {exc.item}\", code=exc.code\n                    )\n\n        update_checkout_shipping_method_if_invalid(checkout, info.context.discounts)\n        recalculate_checkout_discount(checkout, info.context.discounts)\n\n        return CheckoutLinesAdd(checkout=checkout)\n\n\nclass CheckoutLinesUpdate(CheckoutLinesAdd):\n    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")\n\n    class Meta:\n        description = \"Updates checkout line in the existing checkout.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, root, info, checkout_id, lines):\n        return super().perform_mutation(root, info, checkout_id, lines, replace=True)\n\n\nclass CheckoutLineDelete(BaseMutation):\n    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")\n\n    class Arguments:\n        checkout_id = graphene.ID(description=\"The ID of the checkout.\", required=True)\n        line_id = graphene.ID(description=\"ID of the checkout line to delete.\")\n\n    class Meta:\n        description = \"Deletes a CheckoutLine.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id, line_id):\n        checkout = cls.get_node_or_error(\n            info, checkout_id, only_type=Checkout, field=\"checkout_id\"\n        )\n        line = cls.get_node_or_error(\n            info, line_id, only_type=CheckoutLine, field=\"line_id\"\n        )\n\n        if line and line in checkout.lines.all():\n            line.delete()\n\n        update_checkout_shipping_method_if_invalid(checkout, info.context.discounts)\n        recalculate_checkout_discount(checkout, info.context.discounts)\n\n        return CheckoutLineDelete(checkout=checkout)\n\n\nclass CheckoutCustomerAttach(BaseMutation):\n    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")\n\n    class Arguments:\n        checkout_id = graphene.ID(required=True, description=\"ID of the checkout.\")\n        customer_id = graphene.ID(required=True, description=\"The ID of the customer.\")\n\n    class Meta:\n        description = \"Sets the customer as the owner of the checkout.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id, customer_id):\n        checkout = cls.get_node_or_error(\n            info, checkout_id, only_type=Checkout, field=\"checkout_id\"\n        )\n        customer = cls.get_node_or_error(\n            info, customer_id, only_type=User, field=\"customer_id\"\n        )\n        checkout.user = customer\n        checkout.save(update_fields=[\"user\", \"last_change\"])\n        return CheckoutCustomerAttach(checkout=checkout)\n\n\nclass CheckoutCustomerDetach(BaseMutation):\n    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")\n\n    class Arguments:\n        checkout_id = graphene.ID(description=\"Checkout ID.\", required=True)\n\n    class Meta:\n        description = \"Removes the user assigned as the owner of the checkout.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id):\n        checkout = cls.get_node_or_error(\n            info, checkout_id, only_type=Checkout, field=\"checkout_id\"\n        )\n        checkout.user = None\n        checkout.save(update_fields=[\"user\", \"last_change\"])\n        return CheckoutCustomerDetach(checkout=checkout)\n\n\nclass CheckoutShippingAddressUpdate(BaseMutation, I18nMixin):\n    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")\n\n    class Arguments:\n        checkout_id = graphene.ID(required=True, description=\"ID of the checkout.\")\n        shipping_address = AddressInput(\n            required=True,\n            description=\"The mailing address to where the checkout will be shipped.\",\n        )\n\n    class Meta:\n        description = \"Update shipping address in the existing checkout.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id, shipping_address):\n        pk = from_global_id_strict_type(checkout_id, Checkout, field=\"checkout_id\")\n\n        try:\n            checkout = models.Checkout.objects.prefetch_related(\n                \"lines__variant__product__product_type\"\n            ).get(pk=pk)\n        except ObjectDoesNotExist:\n            raise ValidationError(\n                {\n                    \"checkout_id\": ValidationError(\n                        f\"Couldn't resolve to a node: {checkout_id}\",\n                        code=CheckoutErrorCode.NOT_FOUND,\n                    )\n                }\n            )\n\n        if not checkout.is_shipping_required():\n            raise ValidationError(\n                {\n                    \"shipping_address\": ValidationError(\n                        ERROR_DOES_NOT_SHIP,\n                        code=CheckoutErrorCode.SHIPPING_NOT_REQUIRED,\n                    )\n                }\n            )\n\n        shipping_address = cls.validate_address(\n            shipping_address, instance=checkout.shipping_address, info=info\n        )\n\n        update_checkout_shipping_method_if_invalid(checkout, info.context.discounts)\n\n        with transaction.atomic():\n            shipping_address.save()\n            change_shipping_address_in_checkout(checkout, shipping_address)\n        recalculate_checkout_discount(checkout, info.context.discounts)\n\n        return CheckoutShippingAddressUpdate(checkout=checkout)\n\n\nclass CheckoutBillingAddressUpdate(CheckoutShippingAddressUpdate):\n    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")\n\n    class Arguments:\n        checkout_id = graphene.ID(required=True, description=\"ID of the checkout.\")\n        billing_address = AddressInput(\n            required=True, description=\"The billing address of the checkout.\"\n        )\n\n    class Meta:\n        description = \"Update billing address in the existing checkout.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id, billing_address):\n        checkout = cls.get_node_or_error(\n            info, checkout_id, only_type=Checkout, field=\"checkout_id\"\n        )\n\n        billing_address = cls.validate_address(\n            billing_address, instance=checkout.billing_address, info=info\n        )\n        with transaction.atomic():\n            billing_address.save()\n            change_billing_address_in_checkout(checkout, billing_address)\n        return CheckoutBillingAddressUpdate(checkout=checkout)\n\n\nclass CheckoutEmailUpdate(BaseMutation):\n    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")\n\n    class Arguments:\n        checkout_id = graphene.ID(description=\"Checkout ID.\")\n        email = graphene.String(required=True, description=\"email.\")\n\n    class Meta:\n        description = \"Updates email address in the existing checkout object.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id, email):\n        checkout = cls.get_node_or_error(\n            info, checkout_id, only_type=Checkout, field=\"checkout_id\"\n        )\n\n        checkout.email = email\n        cls.clean_instance(info, checkout)\n        checkout.save(update_fields=[\"email\", \"last_change\"])\n        return CheckoutEmailUpdate(checkout=checkout)\n\n\nclass CheckoutShippingMethodUpdate(BaseMutation):\n    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")\n\n    class Arguments:\n        checkout_id = graphene.ID(description=\"Checkout ID.\")\n        shipping_method_id = graphene.ID(required=True, description=\"Shipping method.\")\n\n    class Meta:\n        description = \"Updates the shipping address of the checkout.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id, shipping_method_id):\n        pk = from_global_id_strict_type(\n            checkout_id, only_type=Checkout, field=\"checkout_id\"\n        )\n\n        try:\n            checkout = models.Checkout.objects.prefetch_related(\n                \"lines__variant__product__collections\",\n                \"lines__variant__product__product_type\",\n            ).get(pk=pk)\n        except ObjectDoesNotExist:\n            raise ValidationError(\n                {\n                    \"checkout_id\": ValidationError(\n                        f\"Couldn't resolve to a node: {checkout_id}\",\n                        code=CheckoutErrorCode.NOT_FOUND,\n                    )\n                }\n            )\n\n        if not checkout.is_shipping_required():\n            raise ValidationError(\n                {\n                    \"shipping_method\": ValidationError(\n                        ERROR_DOES_NOT_SHIP,\n                        code=CheckoutErrorCode.SHIPPING_NOT_REQUIRED,\n                    )\n                }\n            )\n\n        shipping_method = cls.get_node_or_error(\n            info,\n            shipping_method_id,\n            only_type=ShippingMethod,\n            field=\"shipping_method_id\",\n        )\n\n        shipping_method_is_valid = clean_shipping_method(\n            checkout=checkout, method=shipping_method, discounts=info.context.discounts\n        )\n\n        if not shipping_method_is_valid:\n            raise ValidationError(\n                {\n                    \"shipping_method\": ValidationError(\n                        \"This shipping method is not applicable.\",\n                        code=CheckoutErrorCode.SHIPPING_METHOD_NOT_APPLICABLE,\n                    )\n                }\n            )\n\n        checkout.shipping_method = shipping_method\n        checkout.save(update_fields=[\"shipping_method\", \"last_change\"])\n        recalculate_checkout_discount(checkout, info.context.discounts)\n\n        return CheckoutShippingMethodUpdate(checkout=checkout)\n\n\nclass CheckoutComplete(BaseMutation):\n    order = graphene.Field(Order, description=\"Placed order.\")\n\n    class Arguments:\n        checkout_id = graphene.ID(description=\"Checkout ID.\", required=True)\n        store_source = graphene.Boolean(\n            default_value=False,\n            description=(\n                \"Determines whether to store the payment source for future usage.\"\n            ),\n        )\n        redirect_url = graphene.String(\n            required=False,\n            description=(\n                \"URL of a view where users should be redirected to \"\n                \"see the order details. URL in RFC 1808 format.\"\n            ),\n        )\n\n    class Meta:\n        description = (\n            \"Completes the checkout. As a result a new order is created and \"\n            \"a payment charge is made. This action requires a successful \"\n            \"payment before it can be performed.\"\n        )\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id, store_source, **data):\n        checkout = cls.get_node_or_error(\n            info,\n            checkout_id,\n            only_type=Checkout,\n            field=\"checkout_id\",\n            qs=models.Checkout.objects.prefetch_related(\n                \"gift_cards\",\n                \"lines\",\n                Prefetch(\n                    \"payments\",\n                    queryset=payment_models.Payment.objects.prefetch_related(\n                        \"order\", \"order__lines\"\n                    ),\n                ),\n            ).select_related(\"shipping_method\", \"shipping_method__shipping_zone\"),\n        )\n\n        discounts = info.context.discounts\n        user = info.context.user\n        clean_checkout(checkout, discounts)\n\n        payment = checkout.get_last_active_payment()\n\n        with transaction.atomic():\n            try:\n                order_data = prepare_order_data(\n                    checkout=checkout,\n                    tracking_code=analytics.get_client_id(info.context),\n                    discounts=discounts,\n                )\n            except InsufficientStock as e:\n                raise ValidationError(\n                    f\"Insufficient product stock: {e.item}\", code=e.code\n                )\n            except voucher_model.NotApplicable:\n                raise ValidationError(\n                    \"Voucher not applicable\",\n                    code=CheckoutErrorCode.VOUCHER_NOT_APPLICABLE,\n                )\n            except TaxError as tax_error:\n                return ValidationError(\n                    \"Unable to calculate taxes - %s\" % str(tax_error),\n                    code=CheckoutErrorCode.TAX_ERROR,\n                )\n\n        billing_address = order_data[\"billing_address\"]\n        shipping_address = order_data.get(\"shipping_address\", None)\n\n        billing_address = AddressData(**billing_address.as_data())\n\n        if shipping_address is not None:\n            shipping_address = AddressData(**shipping_address.as_data())\n\n        try:\n            txn = gateway.process_payment(\n                payment=payment, token=payment.token, store_source=store_source\n            )\n\n            if not txn.is_success:\n                raise PaymentError(txn.error)\n\n        except PaymentError as e:\n            abort_order_data(order_data)\n            raise ValidationError(str(e), code=CheckoutErrorCode.PAYMENT_ERROR)\n\n        if txn.customer_id and user.is_authenticated:\n            store_customer_id(user, payment.gateway, txn.customer_id)\n\n        redirect_url = data.get(\"redirect_url\", \"\")\n        if redirect_url:\n            try:\n                validate_storefront_url(redirect_url)\n            except ValidationError as error:\n                raise ValidationError(\n                    {\"redirect_url\": error}, code=AccountErrorCode.INVALID\n                )\n\n        # create the order into the database\n        order = create_order(\n            checkout=checkout,\n            order_data=order_data,\n            user=user,\n            redirect_url=redirect_url,\n        )\n\n        # remove checkout after order is successfully paid\n        checkout.delete()\n\n        # return the success response with the newly created order data\n        return CheckoutComplete(order=order)\n\n\nclass CheckoutAddPromoCode(BaseMutation):\n    checkout = graphene.Field(\n        Checkout, description=\"The checkout with the added gift card or voucher.\"\n    )\n\n    class Arguments:\n        checkout_id = graphene.ID(description=\"Checkout ID.\", required=True)\n        promo_code = graphene.String(\n            description=\"Gift card code or voucher code.\", required=True\n        )\n\n    class Meta:\n        description = \"Adds a gift card or a voucher to a checkout.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id, promo_code):\n        checkout = cls.get_node_or_error(\n            info, checkout_id, only_type=Checkout, field=\"checkout_id\"\n        )\n        add_promo_code_to_checkout(checkout, promo_code, info.context.discounts)\n        return CheckoutAddPromoCode(checkout=checkout)\n\n\nclass CheckoutRemovePromoCode(BaseMutation):\n    checkout = graphene.Field(\n        Checkout, description=\"The checkout with the removed gift card or voucher.\"\n    )\n\n    class Arguments:\n        checkout_id = graphene.ID(description=\"Checkout ID.\", required=True)\n        promo_code = graphene.String(\n            description=\"Gift card code or voucher code.\", required=True\n        )\n\n    class Meta:\n        description = \"Remove a gift card or a voucher from a checkout.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id, promo_code):\n        checkout = cls.get_node_or_error(\n            info, checkout_id, only_type=Checkout, field=\"checkout_id\"\n        )\n        remove_promo_code_from_checkout(checkout, promo_code)\n        return CheckoutRemovePromoCode(checkout=checkout)\n\n\nclass CheckoutUpdateMeta(UpdateMetaBaseMutation):\n    class Meta:\n        description = \"Updates metadata for checkout.\"\n        permissions = (OrderPermissions.MANAGE_ORDERS,)\n        model = models.Checkout\n        public = True\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n\nclass CheckoutUpdatePrivateMeta(UpdateMetaBaseMutation):\n    class Meta:\n        description = \"Updates private metadata for checkout.\"\n        permissions = (OrderPermissions.MANAGE_ORDERS,)\n        model = models.Checkout\n        public = False\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n\nclass CheckoutClearMeta(ClearMetaBaseMutation):\n    class Meta:\n        description = \"Clear metadata for checkout.\"\n        permissions = (OrderPermissions.MANAGE_ORDERS,)\n        model = models.Checkout\n        public = True\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n\nclass CheckoutClearPrivateMeta(ClearMetaBaseMutation):\n    class Meta:\n        description = \"Clear private metadata for checkout.\"\n        permissions = (OrderPermissions.MANAGE_ORDERS,)\n        model = models.Checkout\n        public = False\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n", "schema {\n  query: Query\n  mutation: Mutation\n}\n\ntype AccountAddressCreate {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n  address: Address\n}\n\ntype AccountAddressDelete {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n  address: Address\n}\n\ntype AccountAddressUpdate {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n  address: Address\n}\n\ntype AccountDelete {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ntype AccountError {\n  field: String\n  message: String\n  code: AccountErrorCode\n}\n\nenum AccountErrorCode {\n  ACTIVATE_OWN_ACCOUNT\n  ACTIVATE_SUPERUSER_ACCOUNT\n  ASSIGN_NON_STAFF_MEMBER\n  DEACTIVATE_OWN_ACCOUNT\n  DEACTIVATE_SUPERUSER_ACCOUNT\n  DELETE_NON_STAFF_USER\n  DELETE_OWN_ACCOUNT\n  DELETE_STAFF_ACCOUNT\n  DELETE_SUPERUSER_ACCOUNT\n  GRAPHQL_ERROR\n  INVALID\n  INVALID_PASSWORD\n  NOT_FOUND\n  PASSWORD_ENTIRELY_NUMERIC\n  PASSWORD_TOO_COMMON\n  PASSWORD_TOO_SHORT\n  PASSWORD_TOO_SIMILAR\n  REQUIRED\n  UNIQUE\n}\n\ninput AccountInput {\n  firstName: String\n  lastName: String\n  defaultBillingAddress: AddressInput\n  defaultShippingAddress: AddressInput\n}\n\ntype AccountRegister {\n  errors: [Error!]\n  requiresConfirmation: Boolean\n  accountErrors: [AccountError!]\n  user: User\n}\n\ninput AccountRegisterInput {\n  email: String!\n  password: String!\n  redirectUrl: String!\n}\n\ntype AccountRequestDeletion {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n}\n\ntype AccountSetDefaultAddress {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n}\n\ntype AccountUpdate {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ntype AccountUpdateMeta {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ntype Address implements Node {\n  id: ID!\n  firstName: String!\n  lastName: String!\n  companyName: String!\n  streetAddress1: String!\n  streetAddress2: String!\n  city: String!\n  cityArea: String!\n  postalCode: String!\n  country: CountryDisplay!\n  countryArea: String!\n  phone: String\n  isDefaultShippingAddress: Boolean\n  isDefaultBillingAddress: Boolean\n}\n\ntype AddressCreate {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n  address: Address\n}\n\ntype AddressDelete {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n  address: Address\n}\n\ninput AddressInput {\n  firstName: String\n  lastName: String\n  companyName: String\n  streetAddress1: String\n  streetAddress2: String\n  city: String\n  cityArea: String\n  postalCode: String\n  country: CountryCode\n  countryArea: String\n  phone: String\n}\n\ntype AddressSetDefault {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n}\n\nenum AddressTypeEnum {\n  BILLING\n  SHIPPING\n}\n\ntype AddressUpdate {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n  address: Address\n}\n\ntype AddressValidationData {\n  countryCode: String\n  countryName: String\n  addressFormat: String\n  addressLatinFormat: String\n  allowedFields: [String]\n  requiredFields: [String]\n  upperFields: [String]\n  countryAreaType: String\n  countryAreaChoices: [ChoiceValue]\n  cityType: String\n  cityChoices: [ChoiceValue]\n  cityAreaType: String\n  cityAreaChoices: [ChoiceValue]\n  postalCodeType: String\n  postalCodeMatchers: [String]\n  postalCodeExamples: [String]\n  postalCodePrefix: String\n}\n\ntype AssignNavigation {\n  errors: [Error!]\n  menu: Menu\n  menuErrors: [MenuError!]\n}\n\ntype Attribute implements Node {\n  id: ID!\n  productTypes(before: String, after: String, first: Int, last: Int): ProductTypeCountableConnection!\n  productVariantTypes(before: String, after: String, first: Int, last: Int): ProductTypeCountableConnection!\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  inputType: AttributeInputTypeEnum\n  name: String\n  slug: String\n  values: [AttributeValue]\n  valueRequired: Boolean!\n  visibleInStorefront: Boolean!\n  filterableInStorefront: Boolean!\n  filterableInDashboard: Boolean!\n  availableInGrid: Boolean!\n  translation(languageCode: LanguageCodeEnum!): AttributeTranslation\n  storefrontSearchPosition: Int!\n}\n\ntype AttributeAssign {\n  errors: [Error!]\n  productType: ProductType\n  productErrors: [ProductError!]\n}\n\ninput AttributeAssignInput {\n  id: ID!\n  type: AttributeTypeEnum!\n}\n\ntype AttributeBulkDelete {\n  errors: [Error!]\n  count: Int!\n  productErrors: [ProductError!]\n}\n\ntype AttributeClearMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  attribute: Attribute\n}\n\ntype AttributeClearPrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  attribute: Attribute\n}\n\ntype AttributeCountableConnection {\n  pageInfo: PageInfo!\n  edges: [AttributeCountableEdge!]!\n  totalCount: Int\n}\n\ntype AttributeCountableEdge {\n  node: Attribute!\n  cursor: String!\n}\n\ntype AttributeCreate {\n  errors: [Error!]\n  attribute: Attribute\n  productErrors: [ProductError!]\n}\n\ninput AttributeCreateInput {\n  inputType: AttributeInputTypeEnum\n  name: String!\n  slug: String\n  values: [AttributeValueCreateInput]\n  valueRequired: Boolean\n  isVariantOnly: Boolean\n  visibleInStorefront: Boolean\n  filterableInStorefront: Boolean\n  filterableInDashboard: Boolean\n  storefrontSearchPosition: Int\n  availableInGrid: Boolean\n}\n\ntype AttributeDelete {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  attribute: Attribute\n}\n\ninput AttributeFilterInput {\n  valueRequired: Boolean\n  isVariantOnly: Boolean\n  visibleInStorefront: Boolean\n  filterableInStorefront: Boolean\n  filterableInDashboard: Boolean\n  availableInGrid: Boolean\n  search: String\n  ids: [ID]\n  inCollection: ID\n  inCategory: ID\n}\n\ninput AttributeInput {\n  slug: String!\n  value: String\n  values: [String]\n}\n\nenum AttributeInputTypeEnum {\n  DROPDOWN\n  MULTISELECT\n}\n\ntype AttributeReorderValues {\n  errors: [Error!]\n  attribute: Attribute\n  productErrors: [ProductError!]\n}\n\nenum AttributeSortField {\n  NAME\n  SLUG\n  VALUE_REQUIRED\n  IS_VARIANT_ONLY\n  VISIBLE_IN_STOREFRONT\n  FILTERABLE_IN_STOREFRONT\n  FILTERABLE_IN_DASHBOARD\n  DASHBOARD_VARIANT_POSITION\n  DASHBOARD_PRODUCT_POSITION\n  STOREFRONT_SEARCH_POSITION\n  AVAILABLE_IN_GRID\n}\n\ninput AttributeSortingInput {\n  direction: OrderDirection!\n  field: AttributeSortField!\n}\n\ntype AttributeTranslatableContent implements Node {\n  id: ID!\n  name: String!\n  translation(languageCode: LanguageCodeEnum!): AttributeTranslation\n  attribute: Attribute\n}\n\ntype AttributeTranslate {\n  errors: [Error!]\n  attribute: Attribute\n}\n\ntype AttributeTranslation implements Node {\n  id: ID!\n  name: String!\n  language: LanguageDisplay!\n}\n\nenum AttributeTypeEnum {\n  PRODUCT\n  VARIANT\n}\n\ntype AttributeUnassign {\n  errors: [Error!]\n  productType: ProductType\n  productErrors: [ProductError!]\n}\n\ntype AttributeUpdate {\n  errors: [Error!]\n  attribute: Attribute\n  productErrors: [ProductError!]\n}\n\ninput AttributeUpdateInput {\n  name: String\n  slug: String\n  removeValues: [ID]\n  addValues: [AttributeValueCreateInput]\n  valueRequired: Boolean\n  isVariantOnly: Boolean\n  visibleInStorefront: Boolean\n  filterableInStorefront: Boolean\n  filterableInDashboard: Boolean\n  storefrontSearchPosition: Int\n  availableInGrid: Boolean\n}\n\ntype AttributeUpdateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  attribute: Attribute\n}\n\ntype AttributeUpdatePrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  attribute: Attribute\n}\n\ntype AttributeValue implements Node {\n  id: ID!\n  name: String\n  slug: String\n  type: AttributeValueType\n  translation(languageCode: LanguageCodeEnum!): AttributeValueTranslation\n  inputType: AttributeInputTypeEnum\n}\n\ntype AttributeValueBulkDelete {\n  errors: [Error!]\n  count: Int!\n  productErrors: [ProductError!]\n}\n\ntype AttributeValueCreate {\n  errors: [Error!]\n  attribute: Attribute\n  productErrors: [ProductError!]\n  attributeValue: AttributeValue\n}\n\ninput AttributeValueCreateInput {\n  name: String!\n}\n\ntype AttributeValueDelete {\n  errors: [Error!]\n  attribute: Attribute\n  productErrors: [ProductError!]\n  attributeValue: AttributeValue\n}\n\ninput AttributeValueInput {\n  id: ID\n  values: [String]!\n}\n\ntype AttributeValueTranslatableContent implements Node {\n  id: ID!\n  name: String!\n  translation(languageCode: LanguageCodeEnum!): AttributeValueTranslation\n  attributeValue: AttributeValue\n}\n\ntype AttributeValueTranslate {\n  errors: [Error!]\n  attributeValue: AttributeValue\n}\n\ntype AttributeValueTranslation implements Node {\n  id: ID!\n  name: String!\n  language: LanguageDisplay!\n}\n\nenum AttributeValueType {\n  COLOR\n  GRADIENT\n  URL\n  STRING\n}\n\ntype AttributeValueUpdate {\n  errors: [Error!]\n  attribute: Attribute\n  productErrors: [ProductError!]\n  attributeValue: AttributeValue\n}\n\ntype AuthorizationKey {\n  name: AuthorizationKeyType!\n  key: String!\n}\n\ntype AuthorizationKeyAdd {\n  errors: [Error!]\n  authorizationKey: AuthorizationKey\n  shop: Shop\n  shopErrors: [ShopError!]\n}\n\ntype AuthorizationKeyDelete {\n  errors: [Error!]\n  authorizationKey: AuthorizationKey\n  shop: Shop\n  shopErrors: [ShopError!]\n}\n\ninput AuthorizationKeyInput {\n  key: String!\n  password: String!\n}\n\nenum AuthorizationKeyType {\n  FACEBOOK\n  GOOGLE_OAUTH2\n}\n\ntype BulkProductError {\n  field: String\n  message: String\n  code: ProductErrorCode\n  index: Int\n}\n\ninput CatalogueInput {\n  products: [ID]\n  categories: [ID]\n  collections: [ID]\n}\n\ntype Category implements Node {\n  seoTitle: String\n  seoDescription: String\n  id: ID!\n  name: String!\n  description: String!\n  descriptionJson: JSONString!\n  slug: String!\n  parent: Category\n  level: Int!\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  ancestors(before: String, after: String, first: Int, last: Int): CategoryCountableConnection\n  products(before: String, after: String, first: Int, last: Int): ProductCountableConnection\n  url: String\n  children(before: String, after: String, first: Int, last: Int): CategoryCountableConnection\n  backgroundImage(size: Int): Image\n  translation(languageCode: LanguageCodeEnum!): CategoryTranslation\n}\n\ntype CategoryBulkDelete {\n  errors: [Error!]\n  count: Int!\n  productErrors: [ProductError!]\n}\n\ntype CategoryClearMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  category: Category\n}\n\ntype CategoryClearPrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  category: Category\n}\n\ntype CategoryCountableConnection {\n  pageInfo: PageInfo!\n  edges: [CategoryCountableEdge!]!\n  totalCount: Int\n}\n\ntype CategoryCountableEdge {\n  node: Category!\n  cursor: String!\n}\n\ntype CategoryCreate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  category: Category\n}\n\ntype CategoryDelete {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  category: Category\n}\n\ninput CategoryFilterInput {\n  search: String\n  ids: [ID]\n}\n\ninput CategoryInput {\n  description: String\n  descriptionJson: JSONString\n  name: String\n  slug: String\n  seo: SeoInput\n  backgroundImage: Upload\n  backgroundImageAlt: String\n}\n\nenum CategorySortField {\n  NAME\n  PRODUCT_COUNT\n  SUBCATEGORY_COUNT\n}\n\ninput CategorySortingInput {\n  direction: OrderDirection!\n  field: CategorySortField!\n}\n\ntype CategoryTranslatableContent implements Node {\n  seoTitle: String\n  seoDescription: String\n  id: ID!\n  name: String!\n  description: String!\n  descriptionJson: JSONString!\n  translation(languageCode: LanguageCodeEnum!): CategoryTranslation\n  category: Category\n}\n\ntype CategoryTranslate {\n  errors: [Error!]\n  category: Category\n}\n\ntype CategoryTranslation implements Node {\n  seoTitle: String\n  seoDescription: String\n  id: ID!\n  name: String!\n  description: String!\n  descriptionJson: JSONString!\n  language: LanguageDisplay!\n}\n\ntype CategoryUpdate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  category: Category\n}\n\ntype CategoryUpdateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  category: Category\n}\n\ntype CategoryUpdatePrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  category: Category\n}\n\ntype Checkout implements Node {\n  created: DateTime!\n  lastChange: DateTime!\n  user: User\n  token: UUID!\n  quantity: Int!\n  billingAddress: Address\n  shippingAddress: Address\n  shippingMethod: ShippingMethod\n  note: String!\n  discount: Money\n  discountName: String\n  translatedDiscountName: String\n  voucherCode: String\n  giftCards: [GiftCard]\n  id: ID!\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  availableShippingMethods: [ShippingMethod]!\n  availablePaymentGateways: [PaymentGateway]!\n  email: String!\n  isShippingRequired: Boolean!\n  lines: [CheckoutLine]\n  shippingPrice: TaxedMoney\n  subtotalPrice: TaxedMoney\n  totalPrice: TaxedMoney\n}\n\ntype CheckoutAddPromoCode {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutBillingAddressUpdate {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutClearMeta {\n  errors: [Error!]\n  checkoutErrors: [CheckoutError!]\n  checkout: Checkout\n}\n\ntype CheckoutClearPrivateMeta {\n  errors: [Error!]\n  checkoutErrors: [CheckoutError!]\n  checkout: Checkout\n}\n\ntype CheckoutComplete {\n  errors: [Error!]\n  order: Order\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutCountableConnection {\n  pageInfo: PageInfo!\n  edges: [CheckoutCountableEdge!]!\n  totalCount: Int\n}\n\ntype CheckoutCountableEdge {\n  node: Checkout!\n  cursor: String!\n}\n\ntype CheckoutCreate {\n  errors: [Error!]\n  created: Boolean\n  checkoutErrors: [CheckoutError!]\n  checkout: Checkout\n}\n\ninput CheckoutCreateInput {\n  lines: [CheckoutLineInput]!\n  email: String\n  shippingAddress: AddressInput\n  billingAddress: AddressInput\n}\n\ntype CheckoutCustomerAttach {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutCustomerDetach {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutEmailUpdate {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutError {\n  field: String\n  message: String\n  code: CheckoutErrorCode\n}\n\nenum CheckoutErrorCode {\n  BILLING_ADDRESS_NOT_SET\n  CHECKOUT_NOT_FULLY_PAID\n  GRAPHQL_ERROR\n  INSUFFICIENT_STOCK\n  INVALID\n  INVALID_SHIPPING_METHOD\n  NOT_FOUND\n  PAYMENT_ERROR\n  QUANTITY_GREATER_THAN_LIMIT\n  REQUIRED\n  SHIPPING_ADDRESS_NOT_SET\n  SHIPPING_METHOD_NOT_APPLICABLE\n  SHIPPING_METHOD_NOT_SET\n  SHIPPING_NOT_REQUIRED\n  TAX_ERROR\n  UNIQUE\n  VOUCHER_NOT_APPLICABLE\n  ZERO_QUANTITY\n}\n\ntype CheckoutLine implements Node {\n  id: ID!\n  variant: ProductVariant!\n  quantity: Int!\n  totalPrice: TaxedMoney\n  requiresShipping: Boolean\n}\n\ntype CheckoutLineCountableConnection {\n  pageInfo: PageInfo!\n  edges: [CheckoutLineCountableEdge!]!\n  totalCount: Int\n}\n\ntype CheckoutLineCountableEdge {\n  node: CheckoutLine!\n  cursor: String!\n}\n\ntype CheckoutLineDelete {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ninput CheckoutLineInput {\n  quantity: Int!\n  variantId: ID!\n}\n\ntype CheckoutLinesAdd {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutLinesUpdate {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutPaymentCreate {\n  errors: [Error!]\n  checkout: Checkout\n  payment: Payment\n  paymentErrors: [PaymentError!]\n}\n\ntype CheckoutRemovePromoCode {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutShippingAddressUpdate {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutShippingMethodUpdate {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutUpdateMeta {\n  errors: [Error!]\n  checkoutErrors: [CheckoutError!]\n  checkout: Checkout\n}\n\ntype CheckoutUpdatePrivateMeta {\n  errors: [Error!]\n  checkoutErrors: [CheckoutError!]\n  checkout: Checkout\n}\n\ntype ChoiceValue {\n  raw: String\n  verbose: String\n}\n\ntype Collection implements Node {\n  seoTitle: String\n  seoDescription: String\n  id: ID!\n  name: String!\n  description: String!\n  descriptionJson: JSONString!\n  publicationDate: Date\n  isPublished: Boolean!\n  slug: String!\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  products(before: String, after: String, first: Int, last: Int): ProductCountableConnection\n  backgroundImage(size: Int): Image\n  translation(languageCode: LanguageCodeEnum!): CollectionTranslation\n}\n\ntype CollectionAddProducts {\n  errors: [Error!]\n  collection: Collection\n  productErrors: [ProductError!]\n}\n\ntype CollectionBulkDelete {\n  errors: [Error!]\n  count: Int!\n  productErrors: [ProductError!]\n}\n\ntype CollectionBulkPublish {\n  errors: [Error!]\n  count: Int!\n  productErrors: [ProductError!]\n}\n\ntype CollectionClearMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  collection: Collection\n}\n\ntype CollectionClearPrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  collection: Collection\n}\n\ntype CollectionCountableConnection {\n  pageInfo: PageInfo!\n  edges: [CollectionCountableEdge!]!\n  totalCount: Int\n}\n\ntype CollectionCountableEdge {\n  node: Collection!\n  cursor: String!\n}\n\ntype CollectionCreate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  collection: Collection\n}\n\ninput CollectionCreateInput {\n  isPublished: Boolean\n  name: String\n  slug: String\n  description: String\n  descriptionJson: JSONString\n  backgroundImage: Upload\n  backgroundImageAlt: String\n  seo: SeoInput\n  publicationDate: Date\n  products: [ID]\n}\n\ntype CollectionDelete {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  collection: Collection\n}\n\ninput CollectionFilterInput {\n  published: CollectionPublished\n  search: String\n  ids: [ID]\n}\n\ninput CollectionInput {\n  isPublished: Boolean\n  name: String\n  slug: String\n  description: String\n  descriptionJson: JSONString\n  backgroundImage: Upload\n  backgroundImageAlt: String\n  seo: SeoInput\n  publicationDate: Date\n}\n\nenum CollectionPublished {\n  PUBLISHED\n  HIDDEN\n}\n\ntype CollectionRemoveProducts {\n  errors: [Error!]\n  collection: Collection\n  productErrors: [ProductError!]\n}\n\ntype CollectionReorderProducts {\n  errors: [Error!]\n  collection: Collection\n  productErrors: [ProductError!]\n}\n\nenum CollectionSortField {\n  NAME\n  AVAILABILITY\n  PRODUCT_COUNT\n}\n\ninput CollectionSortingInput {\n  direction: OrderDirection!\n  field: CollectionSortField!\n}\n\ntype CollectionTranslatableContent implements Node {\n  seoTitle: String\n  seoDescription: String\n  id: ID!\n  name: String!\n  description: String!\n  descriptionJson: JSONString!\n  translation(languageCode: LanguageCodeEnum!): CollectionTranslation\n  collection: Collection\n}\n\ntype CollectionTranslate {\n  errors: [Error!]\n  collection: Collection\n}\n\ntype CollectionTranslation implements Node {\n  seoTitle: String\n  seoDescription: String\n  id: ID!\n  name: String!\n  description: String!\n  descriptionJson: JSONString!\n  language: LanguageDisplay!\n}\n\ntype CollectionUpdate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  collection: Collection\n}\n\ntype CollectionUpdateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  collection: Collection\n}\n\ntype CollectionUpdatePrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  collection: Collection\n}\n\ntype ConfigurationItem {\n  name: String!\n  value: String\n  type: ConfigurationTypeFieldEnum\n  helpText: String\n  label: String\n}\n\ninput ConfigurationItemInput {\n  name: String!\n  value: String\n}\n\nenum ConfigurationTypeFieldEnum {\n  STRING\n  BOOLEAN\n  SECRET\n  PASSWORD\n}\n\ntype ConfirmAccount {\n  errors: [Error!]\n}\n\ntype ConfirmEmailChange {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n}\n\nenum CountryCode {\n  AF\n  AX\n  AL\n  DZ\n  AS\n  AD\n  AO\n  AI\n  AQ\n  AG\n  AR\n  AM\n  AW\n  AU\n  AT\n  AZ\n  BS\n  BH\n  BD\n  BB\n  BY\n  BE\n  BZ\n  BJ\n  BM\n  BT\n  BO\n  BQ\n  BA\n  BW\n  BV\n  BR\n  IO\n  BN\n  BG\n  BF\n  BI\n  CV\n  KH\n  CM\n  CA\n  KY\n  CF\n  TD\n  CL\n  CN\n  CX\n  CC\n  CO\n  KM\n  CG\n  CD\n  CK\n  CR\n  CI\n  HR\n  CU\n  CW\n  CY\n  CZ\n  DK\n  DJ\n  DM\n  DO\n  EC\n  EG\n  SV\n  GQ\n  ER\n  EE\n  SZ\n  ET\n  EU\n  FK\n  FO\n  FJ\n  FI\n  FR\n  GF\n  PF\n  TF\n  GA\n  GM\n  GE\n  DE\n  GH\n  GI\n  GR\n  GL\n  GD\n  GP\n  GU\n  GT\n  GG\n  GN\n  GW\n  GY\n  HT\n  HM\n  VA\n  HN\n  HK\n  HU\n  IS\n  IN\n  ID\n  IR\n  IQ\n  IE\n  IM\n  IL\n  IT\n  JM\n  JP\n  JE\n  JO\n  KZ\n  KE\n  KI\n  KW\n  KG\n  LA\n  LV\n  LB\n  LS\n  LR\n  LY\n  LI\n  LT\n  LU\n  MO\n  MG\n  MW\n  MY\n  MV\n  ML\n  MT\n  MH\n  MQ\n  MR\n  MU\n  YT\n  MX\n  FM\n  MD\n  MC\n  MN\n  ME\n  MS\n  MA\n  MZ\n  MM\n  NA\n  NR\n  NP\n  NL\n  NC\n  NZ\n  NI\n  NE\n  NG\n  NU\n  NF\n  KP\n  MK\n  MP\n  NO\n  OM\n  PK\n  PW\n  PS\n  PA\n  PG\n  PY\n  PE\n  PH\n  PN\n  PL\n  PT\n  PR\n  QA\n  RE\n  RO\n  RU\n  RW\n  BL\n  SH\n  KN\n  LC\n  MF\n  PM\n  VC\n  WS\n  SM\n  ST\n  SA\n  SN\n  RS\n  SC\n  SL\n  SG\n  SX\n  SK\n  SI\n  SB\n  SO\n  ZA\n  GS\n  KR\n  SS\n  ES\n  LK\n  SD\n  SR\n  SJ\n  SE\n  CH\n  SY\n  TW\n  TJ\n  TZ\n  TH\n  TL\n  TG\n  TK\n  TO\n  TT\n  TN\n  TR\n  TM\n  TC\n  TV\n  UG\n  UA\n  AE\n  GB\n  UM\n  US\n  UY\n  UZ\n  VU\n  VE\n  VN\n  VG\n  VI\n  WF\n  EH\n  YE\n  ZM\n  ZW\n}\n\ntype CountryDisplay {\n  code: String!\n  country: String!\n  vat: VAT\n}\n\ntype CreateToken {\n  token: String\n  errors: [Error]!\n  user: User\n}\n\ntype CreditCard {\n  brand: String!\n  firstDigits: String!\n  lastDigits: String!\n  expMonth: Int!\n  expYear: Int!\n}\n\ntype CustomerBulkDelete {\n  errors: [Error!]\n  count: Int!\n  accountErrors: [AccountError!]\n}\n\ntype CustomerCreate {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ntype CustomerDelete {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ntype CustomerEvent implements Node {\n  id: ID!\n  date: DateTime\n  type: CustomerEventsEnum\n  user(id: ID): User\n  message: String\n  count: Int\n  order: Order\n  orderLine: OrderLine\n}\n\nenum CustomerEventsEnum {\n  ACCOUNT_CREATED\n  PASSWORD_RESET_LINK_SENT\n  PASSWORD_RESET\n  EMAIL_CHANGED_REQUEST\n  PASSWORD_CHANGED\n  EMAIL_CHANGED\n  PLACED_ORDER\n  NOTE_ADDED_TO_ORDER\n  DIGITAL_LINK_DOWNLOADED\n  CUSTOMER_DELETED\n  NAME_ASSIGNED\n  EMAIL_ASSIGNED\n  NOTE_ADDED\n}\n\ninput CustomerFilterInput {\n  dateJoined: DateRangeInput\n  moneySpent: PriceRangeInput\n  numberOfOrders: IntRangeInput\n  placedOrders: DateRangeInput\n  search: String\n}\n\ninput CustomerInput {\n  defaultBillingAddress: AddressInput\n  defaultShippingAddress: AddressInput\n  firstName: String\n  lastName: String\n  email: String\n  isActive: Boolean\n  note: String\n}\n\ntype CustomerUpdate {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\nscalar Date\n\ninput DateRangeInput {\n  gte: Date\n  lte: Date\n}\n\nscalar DateTime\n\ninput DateTimeRangeInput {\n  gte: DateTime\n  lte: DateTime\n}\n\nscalar Decimal\n\ntype DigitalContent implements Node {\n  useDefaultSettings: Boolean!\n  automaticFulfillment: Boolean!\n  productVariant: ProductVariant!\n  contentFile: String!\n  maxDownloads: Int\n  urlValidDays: Int\n  urls: [DigitalContentUrl]\n  id: ID!\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n}\n\ntype DigitalContentCountableConnection {\n  pageInfo: PageInfo!\n  edges: [DigitalContentCountableEdge!]!\n  totalCount: Int\n}\n\ntype DigitalContentCountableEdge {\n  node: DigitalContent!\n  cursor: String!\n}\n\ntype DigitalContentCreate {\n  errors: [Error!]\n  variant: ProductVariant\n  content: DigitalContent\n  productErrors: [ProductError!]\n}\n\ntype DigitalContentDelete {\n  errors: [Error!]\n  variant: ProductVariant\n  productErrors: [ProductError!]\n}\n\ninput DigitalContentInput {\n  useDefaultSettings: Boolean!\n  maxDownloads: Int\n  urlValidDays: Int\n  automaticFulfillment: Boolean\n}\n\ntype DigitalContentUpdate {\n  errors: [Error!]\n  variant: ProductVariant\n  content: DigitalContent\n  productErrors: [ProductError!]\n}\n\ninput DigitalContentUploadInput {\n  useDefaultSettings: Boolean!\n  maxDownloads: Int\n  urlValidDays: Int\n  automaticFulfillment: Boolean\n  contentFile: Upload!\n}\n\ntype DigitalContentUrl implements Node {\n  token: UUID!\n  content: DigitalContent!\n  created: DateTime!\n  downloadNum: Int!\n  id: ID!\n  url: String\n}\n\ntype DigitalContentUrlCreate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  digitalContentUrl: DigitalContentUrl\n}\n\ninput DigitalContentUrlCreateInput {\n  content: ID!\n}\n\nenum DiscountStatusEnum {\n  ACTIVE\n  EXPIRED\n  SCHEDULED\n}\n\nenum DiscountValueTypeEnum {\n  FIXED\n  PERCENTAGE\n}\n\ntype Domain {\n  host: String!\n  sslEnabled: Boolean!\n  url: String!\n}\n\ntype DraftOrderBulkDelete {\n  errors: [Error!]\n  count: Int!\n  orderErrors: [OrderError!]\n}\n\ntype DraftOrderComplete {\n  errors: [Error!]\n  order: Order\n  orderErrors: [OrderError!]\n}\n\ntype DraftOrderCreate {\n  errors: [Error!]\n  orderErrors: [OrderError!]\n  order: Order\n}\n\ninput DraftOrderCreateInput {\n  billingAddress: AddressInput\n  user: ID\n  userEmail: String\n  discount: Decimal\n  shippingAddress: AddressInput\n  shippingMethod: ID\n  voucher: ID\n  customerNote: String\n  lines: [OrderLineCreateInput]\n}\n\ntype DraftOrderDelete {\n  errors: [Error!]\n  orderErrors: [OrderError!]\n  order: Order\n}\n\ninput DraftOrderInput {\n  billingAddress: AddressInput\n  user: ID\n  userEmail: String\n  discount: Decimal\n  shippingAddress: AddressInput\n  shippingMethod: ID\n  voucher: ID\n  customerNote: String\n}\n\ntype DraftOrderLineDelete {\n  errors: [Error!]\n  order: Order\n  orderLine: OrderLine\n  orderErrors: [OrderError!]\n}\n\ntype DraftOrderLineUpdate {\n  errors: [Error!]\n  order: Order\n  orderErrors: [OrderError!]\n  orderLine: OrderLine\n}\n\ntype DraftOrderLinesBulkDelete {\n  errors: [Error!]\n  count: Int!\n  orderErrors: [OrderError!]\n}\n\ntype DraftOrderLinesCreate {\n  errors: [Error!]\n  order: Order\n  orderLines: [OrderLine!]\n  orderErrors: [OrderError!]\n}\n\ntype DraftOrderUpdate {\n  errors: [Error!]\n  orderErrors: [OrderError!]\n  order: Order\n}\n\ntype Error {\n  field: String\n  message: String\n}\n\ntype ExtensionsError {\n  field: String\n  message: String\n  code: ExtensionsErrorCode\n}\n\nenum ExtensionsErrorCode {\n  GRAPHQL_ERROR\n  INVALID\n  PLUGIN_MISCONFIGURED\n  NOT_FOUND\n  REQUIRED\n  UNIQUE\n}\n\ntype Fulfillment implements Node {\n  id: ID!\n  fulfillmentOrder: Int!\n  status: FulfillmentStatus!\n  trackingNumber: String!\n  created: DateTime!\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  lines: [FulfillmentLine]\n  statusDisplay: String\n}\n\ntype FulfillmentCancel {\n  errors: [Error!]\n  fulfillment: Fulfillment\n  order: Order\n  orderErrors: [OrderError!]\n}\n\ninput FulfillmentCancelInput {\n  restock: Boolean\n}\n\ntype FulfillmentClearMeta {\n  errors: [Error!]\n  fulfillment: Fulfillment\n}\n\ntype FulfillmentClearPrivateMeta {\n  errors: [Error!]\n  fulfillment: Fulfillment\n}\n\ntype FulfillmentCreate {\n  errors: [Error!]\n  fulfillment: Fulfillment\n  order: Order\n  orderErrors: [OrderError!]\n}\n\ninput FulfillmentCreateInput {\n  trackingNumber: String\n  notifyCustomer: Boolean\n  lines: [FulfillmentLineInput]!\n}\n\ntype FulfillmentLine implements Node {\n  id: ID!\n  quantity: Int!\n  orderLine: OrderLine\n}\n\ninput FulfillmentLineInput {\n  orderLineId: ID\n  quantity: Int\n}\n\nenum FulfillmentStatus {\n  FULFILLED\n  CANCELED\n}\n\ntype FulfillmentUpdateMeta {\n  errors: [Error!]\n  fulfillment: Fulfillment\n}\n\ntype FulfillmentUpdatePrivateMeta {\n  errors: [Error!]\n  fulfillment: Fulfillment\n}\n\ntype FulfillmentUpdateTracking {\n  errors: [Error!]\n  fulfillment: Fulfillment\n  order: Order\n  orderErrors: [OrderError!]\n}\n\ninput FulfillmentUpdateTrackingInput {\n  trackingNumber: String\n  notifyCustomer: Boolean = false\n}\n\ntype GatewayConfigLine {\n  field: String!\n  value: String\n}\n\nscalar GenericScalar\n\ntype Geolocalization {\n  country: CountryDisplay\n}\n\ntype GiftCard implements Node {\n  code: String\n  user: User\n  created: DateTime!\n  startDate: Date!\n  endDate: Date\n  lastUsedOn: DateTime\n  isActive: Boolean!\n  initialBalance: Money\n  currentBalance: Money\n  id: ID!\n  displayCode: String\n}\n\ntype GiftCardActivate {\n  errors: [Error!]\n  giftCard: GiftCard\n  giftCardErrors: [GiftCardError!]\n}\n\ntype GiftCardCountableConnection {\n  pageInfo: PageInfo!\n  edges: [GiftCardCountableEdge!]!\n  totalCount: Int\n}\n\ntype GiftCardCountableEdge {\n  node: GiftCard!\n  cursor: String!\n}\n\ntype GiftCardCreate {\n  errors: [Error!]\n  giftCardErrors: [GiftCardError!]\n  giftCard: GiftCard\n}\n\ninput GiftCardCreateInput {\n  startDate: Date\n  endDate: Date\n  balance: Decimal\n  userEmail: String\n  code: String\n}\n\ntype GiftCardDeactivate {\n  errors: [Error!]\n  giftCard: GiftCard\n  giftCardErrors: [GiftCardError!]\n}\n\ntype GiftCardError {\n  field: String\n  message: String\n  code: GiftCardErrorCode\n}\n\nenum GiftCardErrorCode {\n  ALREADY_EXISTS\n  GRAPHQL_ERROR\n  INVALID\n  NOT_FOUND\n  REQUIRED\n  UNIQUE\n}\n\ntype GiftCardUpdate {\n  errors: [Error!]\n  giftCardErrors: [GiftCardError!]\n  giftCard: GiftCard\n}\n\ninput GiftCardUpdateInput {\n  startDate: Date\n  endDate: Date\n  balance: Decimal\n  userEmail: String\n}\n\ntype Group implements Node {\n  id: ID!\n  name: String!\n  permissions: [PermissionDisplay]\n  users: [User]\n}\n\ntype GroupCountableConnection {\n  pageInfo: PageInfo!\n  edges: [GroupCountableEdge!]!\n  totalCount: Int\n}\n\ntype GroupCountableEdge {\n  node: Group!\n  cursor: String!\n}\n\ntype HomepageCollectionUpdate {\n  errors: [Error!]\n  shop: Shop\n  shopErrors: [ShopError!]\n}\n\ntype Image {\n  url: String!\n  alt: String\n}\n\ninput IntRangeInput {\n  gte: Int\n  lte: Int\n}\n\nscalar JSONString\n\nenum LanguageCodeEnum {\n  AR\n  AZ\n  BG\n  BN\n  CA\n  CS\n  DA\n  DE\n  EL\n  EN\n  ES\n  ES_CO\n  ET\n  FA\n  FR\n  HI\n  HU\n  HY\n  ID\n  IS\n  IT\n  JA\n  KO\n  LT\n  MN\n  NB\n  NL\n  PL\n  PT\n  PT_BR\n  RO\n  RU\n  SK\n  SQ\n  SR\n  SW\n  SV\n  TH\n  TR\n  UK\n  VI\n  ZH_HANS\n  ZH_HANT\n}\n\ntype LanguageDisplay {\n  code: LanguageCodeEnum!\n  language: String!\n}\n\ntype Margin {\n  start: Int\n  stop: Int\n}\n\ntype Menu implements Node {\n  id: ID!\n  name: String!\n  items: [MenuItem]\n}\n\ntype MenuBulkDelete {\n  errors: [Error!]\n  count: Int!\n  menuErrors: [MenuError!]\n}\n\ntype MenuCountableConnection {\n  pageInfo: PageInfo!\n  edges: [MenuCountableEdge!]!\n  totalCount: Int\n}\n\ntype MenuCountableEdge {\n  node: Menu!\n  cursor: String!\n}\n\ntype MenuCreate {\n  errors: [Error!]\n  menuErrors: [MenuError!]\n  menu: Menu\n}\n\ninput MenuCreateInput {\n  name: String!\n  items: [MenuItemInput]\n}\n\ntype MenuDelete {\n  errors: [Error!]\n  menuErrors: [MenuError!]\n  menu: Menu\n}\n\ntype MenuError {\n  field: String\n  message: String\n  code: MenuErrorCode\n}\n\nenum MenuErrorCode {\n  CANNOT_ASSIGN_NODE\n  GRAPHQL_ERROR\n  INVALID\n  INVALID_MENU_ITEM\n  NO_MENU_ITEM_PROVIDED\n  NOT_FOUND\n  REQUIRED\n  TOO_MANY_MENU_ITEMS\n  UNIQUE\n}\n\ninput MenuFilterInput {\n  search: String\n}\n\ninput MenuInput {\n  name: String\n}\n\ntype MenuItem implements Node {\n  id: ID!\n  name: String!\n  menu: Menu!\n  parent: MenuItem\n  category: Category\n  collection: Collection\n  page: Page\n  level: Int!\n  children: [MenuItem]\n  url: String\n  translation(languageCode: LanguageCodeEnum!): MenuItemTranslation\n}\n\ntype MenuItemBulkDelete {\n  errors: [Error!]\n  count: Int!\n  menuErrors: [MenuError!]\n}\n\ntype MenuItemCountableConnection {\n  pageInfo: PageInfo!\n  edges: [MenuItemCountableEdge!]!\n  totalCount: Int\n}\n\ntype MenuItemCountableEdge {\n  node: MenuItem!\n  cursor: String!\n}\n\ntype MenuItemCreate {\n  errors: [Error!]\n  menuErrors: [MenuError!]\n  menuItem: MenuItem\n}\n\ninput MenuItemCreateInput {\n  name: String!\n  url: String\n  category: ID\n  collection: ID\n  page: ID\n  menu: ID!\n  parent: ID\n}\n\ntype MenuItemDelete {\n  errors: [Error!]\n  menuErrors: [MenuError!]\n  menuItem: MenuItem\n}\n\ninput MenuItemFilterInput {\n  search: String\n}\n\ninput MenuItemInput {\n  name: String\n  url: String\n  category: ID\n  collection: ID\n  page: ID\n}\n\ntype MenuItemMove {\n  errors: [Error!]\n  menu: Menu\n  menuErrors: [MenuError!]\n}\n\ninput MenuItemMoveInput {\n  itemId: ID!\n  parentId: ID\n  sortOrder: Int\n}\n\ninput MenuItemSortingInput {\n  direction: OrderDirection!\n  field: MenuItemsSortField!\n}\n\ntype MenuItemTranslatableContent implements Node {\n  id: ID!\n  name: String!\n  translation(languageCode: LanguageCodeEnum!): MenuItemTranslation\n  menuItem: MenuItem\n}\n\ntype MenuItemTranslate {\n  errors: [Error!]\n  menuItem: MenuItem\n}\n\ntype MenuItemTranslation implements Node {\n  id: ID!\n  name: String!\n  language: LanguageDisplay!\n}\n\ntype MenuItemUpdate {\n  errors: [Error!]\n  menuErrors: [MenuError!]\n  menuItem: MenuItem\n}\n\nenum MenuItemsSortField {\n  NAME\n}\n\nenum MenuSortField {\n  NAME\n  ITEMS_COUNT\n}\n\ninput MenuSortingInput {\n  direction: OrderDirection!\n  field: MenuSortField!\n}\n\ntype MenuUpdate {\n  errors: [Error!]\n  menuErrors: [MenuError!]\n  menu: Menu\n}\n\ntype MetaClientStore {\n  name: String!\n  metadata: [MetaItem]!\n}\n\ninput MetaInput {\n  namespace: String!\n  clientName: String!\n  key: String!\n  value: String!\n}\n\ntype MetaItem {\n  key: String!\n  value: String!\n}\n\ninput MetaPath {\n  namespace: String!\n  clientName: String!\n  key: String!\n}\n\ntype MetaStore {\n  namespace: String!\n  clients: [MetaClientStore]!\n}\n\ntype Money {\n  currency: String!\n  amount: Float!\n  localized: String! @deprecated(reason: \"DEPRECATED: Will be removed in Saleor 2.11. Price formatting according to the current locale should be handled by the frontend client.\")\n}\n\ntype MoneyRange {\n  start: Money\n  stop: Money\n}\n\ninput MoveProductInput {\n  productId: ID!\n  sortOrder: Int\n}\n\ntype Mutation {\n  wishlistAddProduct(productId: ID!): WishlistAddProductMutation\n  wishlistRemoveProduct(productId: ID!): WishlistRemoveProductMutation\n  wishlistAddVariant(variantId: ID!): WishlistAddProductVariantMutation\n  wishlistRemoveVariant(variantId: ID!): WishlistRemoveProductVariantMutation\n  webhookCreate(input: WebhookCreateInput!): WebhookCreate\n  webhookDelete(id: ID!): WebhookDelete\n  webhookUpdate(id: ID!, input: WebhookUpdateInput!): WebhookUpdate\n  createWarehouse(input: WarehouseCreateInput!): WarehouseCreate\n  updateWarehouse(id: ID!, input: WarehouseUpdateInput!): WarehouseUpdate\n  deleteWarehouse(id: ID!): WarehouseDelete\n  createStock(input: StockInput!): StockCreate\n  updateStock(id: ID!, input: StockInput!): StockUpdate\n  deleteStock(id: ID!): StockDelete\n  bulkDeleteStock(ids: [ID]!): StockBulkDelete\n  authorizationKeyAdd(input: AuthorizationKeyInput!, keyType: AuthorizationKeyType!): AuthorizationKeyAdd\n  authorizationKeyDelete(keyType: AuthorizationKeyType!): AuthorizationKeyDelete\n  staffNotificationRecipientCreate(input: StaffNotificationRecipientInput!): StaffNotificationRecipientCreate\n  staffNotificationRecipientUpdate(id: ID!, input: StaffNotificationRecipientInput!): StaffNotificationRecipientUpdate\n  staffNotificationRecipientDelete(id: ID!): StaffNotificationRecipientDelete\n  homepageCollectionUpdate(collection: ID): HomepageCollectionUpdate\n  shopDomainUpdate(input: SiteDomainInput): ShopDomainUpdate\n  shopSettingsUpdate(input: ShopSettingsInput!): ShopSettingsUpdate\n  shopFetchTaxRates: ShopFetchTaxRates\n  shopSettingsTranslate(input: ShopSettingsTranslationInput!, languageCode: LanguageCodeEnum!): ShopSettingsTranslate\n  shopAddressUpdate(input: AddressInput): ShopAddressUpdate\n  shippingPriceCreate(input: ShippingPriceInput!): ShippingPriceCreate\n  shippingPriceDelete(id: ID!): ShippingPriceDelete\n  shippingPriceBulkDelete(ids: [ID]!): ShippingPriceBulkDelete\n  shippingPriceUpdate(id: ID!, input: ShippingPriceInput!): ShippingPriceUpdate\n  shippingPriceTranslate(id: ID!, input: NameTranslationInput!, languageCode: LanguageCodeEnum!): ShippingPriceTranslate\n  shippingZoneCreate(input: ShippingZoneInput!): ShippingZoneCreate\n  shippingZoneDelete(id: ID!): ShippingZoneDelete\n  shippingZoneBulkDelete(ids: [ID]!): ShippingZoneBulkDelete\n  shippingZoneUpdate(id: ID!, input: ShippingZoneInput!): ShippingZoneUpdate\n  attributeCreate(input: AttributeCreateInput!): AttributeCreate\n  attributeDelete(id: ID!): AttributeDelete\n  attributeBulkDelete(ids: [ID]!): AttributeBulkDelete\n  attributeAssign(operations: [AttributeAssignInput]!, productTypeId: ID!): AttributeAssign\n  attributeUnassign(attributeIds: [ID]!, productTypeId: ID!): AttributeUnassign\n  attributeUpdate(id: ID!, input: AttributeUpdateInput!): AttributeUpdate\n  attributeTranslate(id: ID!, input: NameTranslationInput!, languageCode: LanguageCodeEnum!): AttributeTranslate\n  attributeUpdateMetadata(id: ID!, input: MetaInput!): AttributeUpdateMeta\n  attributeClearMetadata(id: ID!, input: MetaPath!): AttributeClearMeta\n  attributeUpdatePrivateMetadata(id: ID!, input: MetaInput!): AttributeUpdatePrivateMeta\n  attributeClearPrivateMetadata(id: ID!, input: MetaPath!): AttributeClearPrivateMeta\n  attributeValueCreate(attribute: ID!, input: AttributeValueCreateInput!): AttributeValueCreate\n  attributeValueDelete(id: ID!): AttributeValueDelete\n  attributeValueBulkDelete(ids: [ID]!): AttributeValueBulkDelete\n  attributeValueUpdate(id: ID!, input: AttributeValueCreateInput!): AttributeValueUpdate\n  attributeValueTranslate(id: ID!, input: NameTranslationInput!, languageCode: LanguageCodeEnum!): AttributeValueTranslate\n  attributeReorderValues(attributeId: ID!, moves: [ReorderInput]!): AttributeReorderValues\n  categoryCreate(input: CategoryInput!, parent: ID): CategoryCreate\n  categoryDelete(id: ID!): CategoryDelete\n  categoryBulkDelete(ids: [ID]!): CategoryBulkDelete\n  categoryUpdate(id: ID!, input: CategoryInput!): CategoryUpdate\n  categoryTranslate(id: ID!, input: TranslationInput!, languageCode: LanguageCodeEnum!): CategoryTranslate\n  categoryUpdateMetadata(id: ID!, input: MetaInput!): CategoryUpdateMeta\n  categoryClearMetadata(id: ID!, input: MetaPath!): CategoryClearMeta\n  categoryUpdatePrivateMetadata(id: ID!, input: MetaInput!): CategoryUpdatePrivateMeta\n  categoryClearPrivateMetadata(id: ID!, input: MetaPath!): CategoryClearPrivateMeta\n  collectionAddProducts(collectionId: ID!, products: [ID]!): CollectionAddProducts\n  collectionCreate(input: CollectionCreateInput!): CollectionCreate\n  collectionDelete(id: ID!): CollectionDelete\n  collectionReorderProducts(collectionId: ID!, moves: [MoveProductInput]!): CollectionReorderProducts\n  collectionBulkDelete(ids: [ID]!): CollectionBulkDelete\n  collectionBulkPublish(ids: [ID]!, isPublished: Boolean!): CollectionBulkPublish\n  collectionRemoveProducts(collectionId: ID!, products: [ID]!): CollectionRemoveProducts\n  collectionUpdate(id: ID!, input: CollectionInput!): CollectionUpdate\n  collectionTranslate(id: ID!, input: TranslationInput!, languageCode: LanguageCodeEnum!): CollectionTranslate\n  collectionUpdateMetadata(id: ID!, input: MetaInput!): CollectionUpdateMeta\n  collectionClearMetadata(id: ID!, input: MetaPath!): CollectionClearMeta\n  collectionUpdatePrivateMetadata(id: ID!, input: MetaInput!): CollectionUpdatePrivateMeta\n  collectionClearPrivateMetadata(id: ID!, input: MetaPath!): CollectionClearPrivateMeta\n  productCreate(input: ProductCreateInput!): ProductCreate\n  productDelete(id: ID!): ProductDelete\n  productBulkDelete(ids: [ID]!): ProductBulkDelete\n  productBulkPublish(ids: [ID]!, isPublished: Boolean!): ProductBulkPublish\n  productUpdate(id: ID!, input: ProductInput!): ProductUpdate\n  productTranslate(id: ID!, input: TranslationInput!, languageCode: LanguageCodeEnum!): ProductTranslate\n  productUpdateMetadata(id: ID!, input: MetaInput!): ProductUpdateMeta\n  productClearMetadata(id: ID!, input: MetaPath!): ProductClearMeta\n  productUpdatePrivateMetadata(id: ID!, input: MetaInput!): ProductUpdatePrivateMeta\n  productClearPrivateMetadata(id: ID!, input: MetaPath!): ProductClearPrivateMeta\n  productImageCreate(input: ProductImageCreateInput!): ProductImageCreate\n  productImageDelete(id: ID!): ProductImageDelete\n  productImageBulkDelete(ids: [ID]!): ProductImageBulkDelete\n  productImageReorder(imagesIds: [ID]!, productId: ID!): ProductImageReorder\n  productImageUpdate(id: ID!, input: ProductImageUpdateInput!): ProductImageUpdate\n  productTypeCreate(input: ProductTypeInput!): ProductTypeCreate\n  productTypeDelete(id: ID!): ProductTypeDelete\n  productTypeBulkDelete(ids: [ID]!): ProductTypeBulkDelete\n  productTypeUpdate(id: ID!, input: ProductTypeInput!): ProductTypeUpdate\n  productTypeReorderAttributes(moves: [ReorderInput]!, productTypeId: ID!, type: AttributeTypeEnum!): ProductTypeReorderAttributes\n  productTypeUpdateMetadata(id: ID!, input: MetaInput!): ProductTypeUpdateMeta\n  productTypeClearMetadata(id: ID!, input: MetaPath!): ProductTypeClearMeta\n  productTypeUpdatePrivateMetadata(id: ID!, input: MetaInput!): ProductTypeUpdatePrivateMeta\n  productTypeClearPrivateMetadata(id: ID!, input: MetaPath!): ProductTypeClearPrivateMeta\n  digitalContentCreate(input: DigitalContentUploadInput!, variantId: ID!): DigitalContentCreate\n  digitalContentDelete(variantId: ID!): DigitalContentDelete\n  digitalContentUpdate(input: DigitalContentInput!, variantId: ID!): DigitalContentUpdate\n  digitalContentUrlCreate(input: DigitalContentUrlCreateInput!): DigitalContentUrlCreate\n  productVariantCreate(input: ProductVariantCreateInput!): ProductVariantCreate\n  productVariantDelete(id: ID!): ProductVariantDelete\n  productVariantBulkCreate(product: ID!, variants: [ProductVariantBulkCreateInput]!): ProductVariantBulkCreate\n  productVariantBulkDelete(ids: [ID]!): ProductVariantBulkDelete\n  productVariantUpdate(id: ID!, input: ProductVariantInput!): ProductVariantUpdate\n  productVariantTranslate(id: ID!, input: NameTranslationInput!, languageCode: LanguageCodeEnum!): ProductVariantTranslate\n  productVariantUpdateMetadata(id: ID!, input: MetaInput!): ProductVariantUpdateMeta\n  productVariantClearMetadata(id: ID!, input: MetaPath!): ProductVariantClearMeta\n  productVariantUpdatePrivateMetadata(id: ID!, input: MetaInput!): ProductVariantUpdatePrivateMeta\n  productVariantClearPrivateMetadata(id: ID!, input: MetaPath!): ProductVariantClearPrivateMeta\n  variantImageAssign(imageId: ID!, variantId: ID!): VariantImageAssign\n  variantImageUnassign(imageId: ID!, variantId: ID!): VariantImageUnassign\n  paymentCapture(amount: Decimal, paymentId: ID!): PaymentCapture\n  paymentRefund(amount: Decimal, paymentId: ID!): PaymentRefund\n  paymentVoid(paymentId: ID!): PaymentVoid\n  paymentSecureConfirm(paymentId: ID!): PaymentSecureConfirm\n  pageCreate(input: PageInput!): PageCreate\n  pageDelete(id: ID!): PageDelete\n  pageBulkDelete(ids: [ID]!): PageBulkDelete\n  pageBulkPublish(ids: [ID]!, isPublished: Boolean!): PageBulkPublish\n  pageUpdate(id: ID!, input: PageInput!): PageUpdate\n  pageTranslate(id: ID!, input: PageTranslationInput!, languageCode: LanguageCodeEnum!): PageTranslate\n  draftOrderComplete(id: ID!): DraftOrderComplete\n  draftOrderCreate(input: DraftOrderCreateInput!): DraftOrderCreate\n  draftOrderDelete(id: ID!): DraftOrderDelete\n  draftOrderBulkDelete(ids: [ID]!): DraftOrderBulkDelete\n  draftOrderLinesBulkDelete(ids: [ID]!): DraftOrderLinesBulkDelete\n  draftOrderLinesCreate(id: ID!, input: [OrderLineCreateInput]!): DraftOrderLinesCreate\n  draftOrderLineDelete(id: ID!): DraftOrderLineDelete\n  draftOrderLineUpdate(id: ID!, input: OrderLineInput!): DraftOrderLineUpdate\n  draftOrderUpdate(id: ID!, input: DraftOrderInput!): DraftOrderUpdate\n  orderAddNote(order: ID!, input: OrderAddNoteInput!): OrderAddNote\n  orderCancel(id: ID!, restock: Boolean!): OrderCancel\n  orderCapture(amount: Decimal!, id: ID!): OrderCapture\n  orderClearPrivateMeta(id: ID!, input: MetaPath!): OrderClearPrivateMeta\n  orderClearMeta(input: MetaPath!, token: UUID!): OrderClearMeta\n  orderFulfillmentCancel(id: ID!, input: FulfillmentCancelInput!): FulfillmentCancel\n  orderFulfillmentCreate(input: FulfillmentCreateInput!, order: ID): FulfillmentCreate\n  orderFulfillmentUpdateTracking(id: ID!, input: FulfillmentUpdateTrackingInput!): FulfillmentUpdateTracking\n  orderFulfillmentClearMeta(id: ID!, input: MetaPath!): FulfillmentClearMeta\n  orderFulfillmentClearPrivateMeta(id: ID!, input: MetaPath!): FulfillmentClearPrivateMeta\n  orderFulfillmentUpdateMeta(id: ID!, input: MetaInput!): FulfillmentUpdateMeta\n  orderFulfillmentUpdatePrivateMeta(id: ID!, input: MetaInput!): FulfillmentUpdatePrivateMeta\n  orderMarkAsPaid(id: ID!): OrderMarkAsPaid\n  orderRefund(amount: Decimal!, id: ID!): OrderRefund\n  orderUpdate(id: ID!, input: OrderUpdateInput!): OrderUpdate\n  orderUpdateMeta(input: MetaInput!, token: UUID!): OrderUpdateMeta\n  orderUpdatePrivateMeta(id: ID!, input: MetaInput!): OrderUpdatePrivateMeta\n  orderUpdateShipping(order: ID!, input: OrderUpdateShippingInput): OrderUpdateShipping\n  orderVoid(id: ID!): OrderVoid\n  orderBulkCancel(ids: [ID]!, restock: Boolean!): OrderBulkCancel\n  assignNavigation(menu: ID, navigationType: NavigationType!): AssignNavigation\n  menuCreate(input: MenuCreateInput!): MenuCreate\n  menuDelete(id: ID!): MenuDelete\n  menuBulkDelete(ids: [ID]!): MenuBulkDelete\n  menuUpdate(id: ID!, input: MenuInput!): MenuUpdate\n  menuItemCreate(input: MenuItemCreateInput!): MenuItemCreate\n  menuItemDelete(id: ID!): MenuItemDelete\n  menuItemBulkDelete(ids: [ID]!): MenuItemBulkDelete\n  menuItemUpdate(id: ID!, input: MenuItemInput!): MenuItemUpdate\n  menuItemTranslate(id: ID!, input: NameTranslationInput!, languageCode: LanguageCodeEnum!): MenuItemTranslate\n  menuItemMove(menu: ID!, moves: [MenuItemMoveInput]!): MenuItemMove\n  giftCardActivate(id: ID!): GiftCardActivate\n  giftCardCreate(input: GiftCardCreateInput!): GiftCardCreate\n  giftCardDeactivate(id: ID!): GiftCardDeactivate\n  giftCardUpdate(id: ID!, input: GiftCardUpdateInput!): GiftCardUpdate\n  pluginUpdate(id: ID!, input: PluginUpdateInput!): PluginUpdate\n  saleCreate(input: SaleInput!): SaleCreate\n  saleDelete(id: ID!): SaleDelete\n  saleBulkDelete(ids: [ID]!): SaleBulkDelete\n  saleUpdate(id: ID!, input: SaleInput!): SaleUpdate\n  saleCataloguesAdd(id: ID!, input: CatalogueInput!): SaleAddCatalogues\n  saleCataloguesRemove(id: ID!, input: CatalogueInput!): SaleRemoveCatalogues\n  saleTranslate(id: ID!, input: NameTranslationInput!, languageCode: LanguageCodeEnum!): SaleTranslate\n  voucherCreate(input: VoucherInput!): VoucherCreate\n  voucherDelete(id: ID!): VoucherDelete\n  voucherBulkDelete(ids: [ID]!): VoucherBulkDelete\n  voucherUpdate(id: ID!, input: VoucherInput!): VoucherUpdate\n  voucherCataloguesAdd(id: ID!, input: CatalogueInput!): VoucherAddCatalogues\n  voucherCataloguesRemove(id: ID!, input: CatalogueInput!): VoucherRemoveCatalogues\n  voucherTranslate(id: ID!, input: NameTranslationInput!, languageCode: LanguageCodeEnum!): VoucherTranslate\n  tokenCreate(email: String!, password: String!): CreateToken\n  tokenRefresh(token: String!): Refresh\n  tokenVerify(token: String!): VerifyToken\n  checkoutAddPromoCode(checkoutId: ID!, promoCode: String!): CheckoutAddPromoCode\n  checkoutBillingAddressUpdate(billingAddress: AddressInput!, checkoutId: ID!): CheckoutBillingAddressUpdate\n  checkoutComplete(checkoutId: ID!, redirectUrl: String, storeSource: Boolean = false): CheckoutComplete\n  checkoutCreate(input: CheckoutCreateInput!): CheckoutCreate\n  checkoutCustomerAttach(checkoutId: ID!, customerId: ID!): CheckoutCustomerAttach\n  checkoutCustomerDetach(checkoutId: ID!): CheckoutCustomerDetach\n  checkoutEmailUpdate(checkoutId: ID, email: String!): CheckoutEmailUpdate\n  checkoutLineDelete(checkoutId: ID!, lineId: ID): CheckoutLineDelete\n  checkoutLinesAdd(checkoutId: ID!, lines: [CheckoutLineInput]!): CheckoutLinesAdd\n  checkoutLinesUpdate(checkoutId: ID!, lines: [CheckoutLineInput]!): CheckoutLinesUpdate\n  checkoutRemovePromoCode(checkoutId: ID!, promoCode: String!): CheckoutRemovePromoCode\n  checkoutPaymentCreate(checkoutId: ID!, input: PaymentInput!): CheckoutPaymentCreate\n  checkoutShippingAddressUpdate(checkoutId: ID!, shippingAddress: AddressInput!): CheckoutShippingAddressUpdate\n  checkoutShippingMethodUpdate(checkoutId: ID, shippingMethodId: ID!): CheckoutShippingMethodUpdate\n  checkoutUpdateMetadata(id: ID!, input: MetaInput!): CheckoutUpdateMeta\n  checkoutClearMetadata(id: ID!, input: MetaPath!): CheckoutClearMeta\n  checkoutUpdatePrivateMetadata(id: ID!, input: MetaInput!): CheckoutUpdatePrivateMeta\n  checkoutClearPrivateMetadata(id: ID!, input: MetaPath!): CheckoutClearPrivateMeta\n  requestPasswordReset(email: String!, redirectUrl: String!): RequestPasswordReset\n  confirmAccount(email: String!, token: String!): ConfirmAccount\n  setPassword(token: String!, email: String!, password: String!): SetPassword\n  passwordChange(newPassword: String!, oldPassword: String!): PasswordChange\n  requestEmailChange(newEmail: String!, password: String!, redirectUrl: String!): RequestEmailChange\n  confirmEmailChange(token: String!): ConfirmEmailChange\n  accountAddressCreate(input: AddressInput!, type: AddressTypeEnum): AccountAddressCreate\n  accountAddressUpdate(id: ID!, input: AddressInput!): AccountAddressUpdate\n  accountAddressDelete(id: ID!): AccountAddressDelete\n  accountSetDefaultAddress(id: ID!, type: AddressTypeEnum!): AccountSetDefaultAddress\n  accountRegister(input: AccountRegisterInput!): AccountRegister\n  accountUpdate(input: AccountInput!): AccountUpdate\n  accountRequestDeletion(redirectUrl: String!): AccountRequestDeletion\n  accountDelete(token: String!): AccountDelete\n  accountUpdateMeta(input: MetaInput!): AccountUpdateMeta\n  addressCreate(input: AddressInput!, userId: ID!): AddressCreate\n  addressUpdate(id: ID!, input: AddressInput!): AddressUpdate\n  addressDelete(id: ID!): AddressDelete\n  addressSetDefault(addressId: ID!, type: AddressTypeEnum!, userId: ID!): AddressSetDefault\n  customerCreate(input: UserCreateInput!): CustomerCreate\n  customerUpdate(id: ID!, input: CustomerInput!): CustomerUpdate\n  customerDelete(id: ID!): CustomerDelete\n  customerBulkDelete(ids: [ID]!): CustomerBulkDelete\n  staffCreate(input: StaffCreateInput!): StaffCreate\n  staffUpdate(id: ID!, input: StaffInput!): StaffUpdate\n  staffDelete(id: ID!): StaffDelete\n  staffBulkDelete(ids: [ID]!): StaffBulkDelete\n  userAvatarUpdate(image: Upload!): UserAvatarUpdate\n  userAvatarDelete: UserAvatarDelete\n  userBulkSetActive(ids: [ID]!, isActive: Boolean!): UserBulkSetActive\n  userUpdateMetadata(id: ID!, input: MetaInput!): UserUpdateMeta\n  userClearMetadata(id: ID!, input: MetaPath!): UserClearMeta\n  userUpdatePrivateMetadata(id: ID!, input: MetaInput!): UserUpdatePrivateMeta\n  userClearPrivateMetadata(id: ID!, input: MetaPath!): UserClearPrivateMeta\n  serviceAccountCreate(input: ServiceAccountInput!): ServiceAccountCreate\n  serviceAccountUpdate(id: ID!, input: ServiceAccountInput!): ServiceAccountUpdate\n  serviceAccountDelete(id: ID!): ServiceAccountDelete\n  serviceAccountUpdatePrivateMetadata(id: ID!, input: MetaInput!): ServiceAccountUpdatePrivateMeta\n  serviceAccountClearPrivateMetadata(id: ID!, input: MetaPath!): ServiceAccountClearPrivateMeta\n  serviceAccountTokenCreate(input: ServiceAccountTokenInput!): ServiceAccountTokenCreate\n  serviceAccountTokenDelete(id: ID!): ServiceAccountTokenDelete\n  permissionGroupCreate(input: PermissionGroupCreateInput!): PermissionGroupCreate\n  permissionGroupUpdate(id: ID!, input: PermissionGroupInput!): PermissionGroupUpdate\n  permissionGroupDelete(id: ID!): PermissionGroupDelete\n  permissionGroupAssignUsers(id: ID!, input: UsersInput!): PermissionGroupAssignUsers\n  permissionGroupUnassignUsers(id: ID!, input: UsersInput!): PermissionGroupUnassignUsers\n}\n\ninput NameTranslationInput {\n  name: String\n}\n\ntype Navigation {\n  main: Menu\n  secondary: Menu\n}\n\nenum NavigationType {\n  MAIN\n  SECONDARY\n}\n\ninterface Node {\n  id: ID!\n}\n\ntype Order implements Node {\n  id: ID!\n  created: DateTime!\n  status: OrderStatus!\n  user: User\n  languageCode: String!\n  trackingClientId: String!\n  billingAddress: Address\n  shippingAddress: Address\n  shippingMethod: ShippingMethod\n  shippingMethodName: String\n  shippingPrice: TaxedMoney\n  token: String!\n  voucher: Voucher\n  giftCards: [GiftCard]\n  discount: Money\n  discountName: String!\n  translatedDiscountName: String!\n  displayGrossPrices: Boolean!\n  customerNote: String!\n  weight: Weight\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  fulfillments: [Fulfillment]!\n  lines: [OrderLine]!\n  actions: [OrderAction]!\n  availableShippingMethods: [ShippingMethod]\n  number: String\n  isPaid: Boolean\n  paymentStatus: PaymentChargeStatusEnum\n  paymentStatusDisplay: String\n  payments: [Payment]\n  total: TaxedMoney\n  subtotal: TaxedMoney\n  statusDisplay: String\n  canFinalize: Boolean!\n  totalAuthorized: Money\n  totalCaptured: Money\n  events: [OrderEvent]\n  totalBalance: Money!\n  userEmail: String\n  isShippingRequired: Boolean!\n}\n\nenum OrderAction {\n  CAPTURE\n  MARK_AS_PAID\n  REFUND\n  VOID\n}\n\ntype OrderAddNote {\n  errors: [Error!]\n  order: Order\n  event: OrderEvent\n  orderErrors: [OrderError!]\n}\n\ninput OrderAddNoteInput {\n  message: String\n}\n\ntype OrderBulkCancel {\n  errors: [Error!]\n  count: Int!\n  orderErrors: [OrderError!]\n}\n\ntype OrderCancel {\n  errors: [Error!]\n  order: Order\n  orderErrors: [OrderError!]\n}\n\ntype OrderCapture {\n  errors: [Error!]\n  order: Order\n  orderErrors: [OrderError!]\n}\n\ntype OrderClearMeta {\n  errors: [Error!]\n  order: Order\n}\n\ntype OrderClearPrivateMeta {\n  errors: [Error!]\n  order: Order\n}\n\ntype OrderCountableConnection {\n  pageInfo: PageInfo!\n  edges: [OrderCountableEdge!]!\n  totalCount: Int\n}\n\ntype OrderCountableEdge {\n  node: Order!\n  cursor: String!\n}\n\nenum OrderDirection {\n  ASC\n  DESC\n}\n\ninput OrderDraftFilterInput {\n  customer: String\n  created: DateRangeInput\n  search: String\n}\n\ntype OrderError {\n  field: String\n  message: String\n  code: OrderErrorCode\n}\n\nenum OrderErrorCode {\n  CANNOT_CANCEL_FULFILLMENT\n  CANNOT_CANCEL_ORDER\n  CANNOT_DELETE\n  CANNOT_REFUND\n  CAPTURE_INACTIVE_PAYMENT\n  NOT_EDITABLE\n  FULFILL_ORDER_LINE\n  GRAPHQL_ERROR\n  INVALID\n  NOT_FOUND\n  ORDER_NO_SHIPPING_ADDRESS\n  PAYMENT_ERROR\n  PAYMENT_MISSING\n  REQUIRED\n  SHIPPING_METHOD_NOT_APPLICABLE\n  SHIPPING_METHOD_REQUIRED\n  UNIQUE\n  VOID_INACTIVE_PAYMENT\n  ZERO_QUANTITY\n}\n\ntype OrderEvent implements Node {\n  id: ID!\n  date: DateTime\n  type: OrderEventsEnum\n  user(id: ID): User\n  message: String\n  email: String\n  emailType: OrderEventsEmailsEnum\n  amount: Float\n  paymentId: String\n  paymentGateway: String\n  quantity: Int\n  composedId: String\n  orderNumber: String\n  oversoldItems: [String]\n  lines: [OrderEventOrderLineObject]\n  fulfilledItems: [FulfillmentLine]\n}\n\ntype OrderEventCountableConnection {\n  pageInfo: PageInfo!\n  edges: [OrderEventCountableEdge!]!\n  totalCount: Int\n}\n\ntype OrderEventCountableEdge {\n  node: OrderEvent!\n  cursor: String!\n}\n\ntype OrderEventOrderLineObject {\n  quantity: Int\n  orderLine: OrderLine\n  itemName: String\n}\n\nenum OrderEventsEmailsEnum {\n  PAYMENT_CONFIRMATION\n  SHIPPING_CONFIRMATION\n  TRACKING_UPDATED\n  ORDER_CONFIRMATION\n  FULFILLMENT_CONFIRMATION\n  DIGITAL_LINKS\n}\n\nenum OrderEventsEnum {\n  DRAFT_CREATED\n  DRAFT_ADDED_PRODUCTS\n  DRAFT_REMOVED_PRODUCTS\n  PLACED\n  PLACED_FROM_DRAFT\n  OVERSOLD_ITEMS\n  CANCELED\n  ORDER_MARKED_AS_PAID\n  ORDER_FULLY_PAID\n  UPDATED_ADDRESS\n  EMAIL_SENT\n  PAYMENT_CAPTURED\n  PAYMENT_REFUNDED\n  PAYMENT_VOIDED\n  PAYMENT_FAILED\n  FULFILLMENT_CANCELED\n  FULFILLMENT_RESTOCKED_ITEMS\n  FULFILLMENT_FULFILLED_ITEMS\n  TRACKING_UPDATED\n  NOTE_ADDED\n  OTHER\n}\n\ninput OrderFilterInput {\n  paymentStatus: [PaymentChargeStatusEnum]\n  status: [OrderStatusFilter]\n  customer: String\n  created: DateRangeInput\n  search: String\n}\n\ntype OrderLine implements Node {\n  id: ID!\n  productName: String!\n  variantName: String!\n  productSku: String!\n  isShippingRequired: Boolean!\n  quantity: Int!\n  quantityFulfilled: Int!\n  taxRate: Float!\n  digitalContentUrl: DigitalContentUrl\n  thumbnail(size: Int): Image\n  unitPrice: TaxedMoney\n  variant: ProductVariant\n  translatedProductName: String!\n  translatedVariantName: String!\n}\n\ninput OrderLineCreateInput {\n  quantity: Int!\n  variantId: ID!\n}\n\ninput OrderLineInput {\n  quantity: Int!\n}\n\ntype OrderMarkAsPaid {\n  errors: [Error!]\n  order: Order\n  orderErrors: [OrderError!]\n}\n\ntype OrderRefund {\n  errors: [Error!]\n  order: Order\n  orderErrors: [OrderError!]\n}\n\nenum OrderSortField {\n  NUMBER\n  CREATION_DATE\n  CUSTOMER\n  PAYMENT\n  FULFILLMENT_STATUS\n  TOTAL\n}\n\ninput OrderSortingInput {\n  direction: OrderDirection!\n  field: OrderSortField!\n}\n\nenum OrderStatus {\n  DRAFT\n  UNFULFILLED\n  PARTIALLY_FULFILLED\n  FULFILLED\n  CANCELED\n}\n\nenum OrderStatusFilter {\n  READY_TO_FULFILL\n  READY_TO_CAPTURE\n  UNFULFILLED\n  PARTIALLY_FULFILLED\n  FULFILLED\n  CANCELED\n}\n\ntype OrderUpdate {\n  errors: [Error!]\n  orderErrors: [OrderError!]\n  order: Order\n}\n\ninput OrderUpdateInput {\n  billingAddress: AddressInput\n  userEmail: String\n  shippingAddress: AddressInput\n}\n\ntype OrderUpdateMeta {\n  errors: [Error!]\n  order: Order\n}\n\ntype OrderUpdatePrivateMeta {\n  errors: [Error!]\n  order: Order\n}\n\ntype OrderUpdateShipping {\n  errors: [Error!]\n  order: Order\n  orderErrors: [OrderError!]\n}\n\ninput OrderUpdateShippingInput {\n  shippingMethod: ID\n}\n\ntype OrderVoid {\n  errors: [Error!]\n  order: Order\n  orderErrors: [OrderError!]\n}\n\ntype Page implements Node {\n  seoTitle: String\n  seoDescription: String\n  id: ID!\n  title: String!\n  content: String!\n  contentJson: JSONString!\n  publicationDate: Date\n  isPublished: Boolean!\n  slug: String!\n  created: DateTime!\n  translation(languageCode: LanguageCodeEnum!): PageTranslation\n}\n\ntype PageBulkDelete {\n  errors: [Error!]\n  count: Int!\n}\n\ntype PageBulkPublish {\n  errors: [Error!]\n  count: Int!\n}\n\ntype PageCountableConnection {\n  pageInfo: PageInfo!\n  edges: [PageCountableEdge!]!\n  totalCount: Int\n}\n\ntype PageCountableEdge {\n  node: Page!\n  cursor: String!\n}\n\ntype PageCreate {\n  errors: [Error!]\n  page: Page\n}\n\ntype PageDelete {\n  errors: [Error!]\n  page: Page\n}\n\ninput PageFilterInput {\n  search: String\n}\n\ntype PageInfo {\n  hasNextPage: Boolean!\n  hasPreviousPage: Boolean!\n  startCursor: String\n  endCursor: String\n}\n\ninput PageInput {\n  slug: String\n  title: String\n  content: String\n  contentJson: JSONString\n  isPublished: Boolean\n  publicationDate: String\n  seo: SeoInput\n}\n\nenum PageSortField {\n  TITLE\n  SLUG\n  VISIBILITY\n  CREATION_DATE\n  PUBLICATION_DATE\n}\n\ninput PageSortingInput {\n  direction: OrderDirection!\n  field: PageSortField!\n}\n\ntype PageTranslatableContent implements Node {\n  seoTitle: String\n  seoDescription: String\n  id: ID!\n  title: String!\n  content: String!\n  contentJson: JSONString!\n  translation(languageCode: LanguageCodeEnum!): PageTranslation\n  page: Page\n}\n\ntype PageTranslate {\n  errors: [Error!]\n  page: PageTranslatableContent\n}\n\ntype PageTranslation implements Node {\n  seoTitle: String\n  seoDescription: String\n  id: ID!\n  title: String!\n  content: String!\n  contentJson: JSONString!\n  language: LanguageDisplay!\n}\n\ninput PageTranslationInput {\n  seoTitle: String\n  seoDescription: String\n  title: String\n  content: String\n  contentJson: JSONString\n}\n\ntype PageUpdate {\n  errors: [Error!]\n  page: Page\n}\n\ntype PasswordChange {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n}\n\ntype Payment implements Node {\n  id: ID!\n  gateway: String!\n  isActive: Boolean!\n  created: DateTime!\n  modified: DateTime!\n  token: String!\n  checkout: Checkout\n  order: Order\n  billingEmail: String!\n  customerIpAddress: String\n  extraData: String!\n  chargeStatus: PaymentChargeStatusEnum!\n  actions: [OrderAction]!\n  total: Money\n  capturedAmount: Money\n  billingAddress: Address\n  transactions: [Transaction]\n  availableCaptureAmount: Money\n  availableRefundAmount: Money\n  creditCard: CreditCard\n}\n\ntype PaymentCapture {\n  errors: [Error!]\n  payment: Payment\n  paymentErrors: [PaymentError!]\n}\n\nenum PaymentChargeStatusEnum {\n  NOT_CHARGED\n  PARTIALLY_CHARGED\n  FULLY_CHARGED\n  PARTIALLY_REFUNDED\n  FULLY_REFUNDED\n}\n\ntype PaymentCountableConnection {\n  pageInfo: PageInfo!\n  edges: [PaymentCountableEdge!]!\n  totalCount: Int\n}\n\ntype PaymentCountableEdge {\n  node: Payment!\n  cursor: String!\n}\n\ntype PaymentError {\n  field: String\n  message: String\n  code: PaymentErrorCode\n}\n\nenum PaymentErrorCode {\n  BILLING_ADDRESS_NOT_SET\n  GRAPHQL_ERROR\n  INVALID\n  NOT_FOUND\n  PARTIAL_PAYMENT_NOT_ALLOWED\n  PAYMENT_ERROR\n  REQUIRED\n  UNIQUE\n}\n\ntype PaymentGateway {\n  name: String!\n  config: [GatewayConfigLine!]!\n}\n\ninput PaymentInput {\n  gateway: String!\n  token: String!\n  amount: Decimal\n  billingAddress: AddressInput\n}\n\ntype PaymentRefund {\n  errors: [Error!]\n  payment: Payment\n  paymentErrors: [PaymentError!]\n}\n\ntype PaymentSecureConfirm {\n  errors: [Error!]\n  payment: Payment\n  paymentErrors: [PaymentError!]\n}\n\ntype PaymentSource {\n  gateway: String!\n  creditCardInfo: CreditCard\n}\n\ntype PaymentVoid {\n  errors: [Error!]\n  payment: Payment\n  paymentErrors: [PaymentError!]\n}\n\ntype PermissionDisplay {\n  code: PermissionEnum!\n  name: String!\n}\n\nenum PermissionEnum {\n  MANAGE_USERS\n  MANAGE_STAFF\n  MANAGE_SERVICE_ACCOUNTS\n  MANAGE_DISCOUNTS\n  MANAGE_PLUGINS\n  MANAGE_GIFT_CARD\n  MANAGE_MENUS\n  MANAGE_ORDERS\n  MANAGE_PAGES\n  MANAGE_PRODUCTS\n  MANAGE_SHIPPING\n  MANAGE_SETTINGS\n  MANAGE_TRANSLATIONS\n  MANAGE_WEBHOOKS\n  MANAGE_CHECKOUTS\n}\n\ntype PermissionGroupAssignUsers {\n  errors: [Error!]\n  group: Group\n  accountErrors: [AccountError!]\n}\n\ntype PermissionGroupCreate {\n  errors: [Error!]\n  group: Group\n  accountErrors: [AccountError!]\n}\n\ninput PermissionGroupCreateInput {\n  name: String!\n  permissions: [PermissionEnum!]\n}\n\ntype PermissionGroupDelete {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  group: Group\n}\n\ninput PermissionGroupFilterInput {\n  search: String\n}\n\ninput PermissionGroupInput {\n  name: String\n  permissions: [PermissionEnum!]\n}\n\nenum PermissionGroupSortField {\n  NAME\n}\n\ninput PermissionGroupSortingInput {\n  direction: OrderDirection!\n  field: PermissionGroupSortField!\n}\n\ntype PermissionGroupUnassignUsers {\n  errors: [Error!]\n  group: Group\n  accountErrors: [AccountError!]\n}\n\ntype PermissionGroupUpdate {\n  errors: [Error!]\n  group: Group\n  accountErrors: [AccountError!]\n}\n\ntype Plugin implements Node {\n  name: String!\n  description: String!\n  active: Boolean!\n  configuration: [ConfigurationItem]\n  id: ID!\n}\n\ntype PluginCountableConnection {\n  pageInfo: PageInfo!\n  edges: [PluginCountableEdge!]!\n  totalCount: Int\n}\n\ntype PluginCountableEdge {\n  node: Plugin!\n  cursor: String!\n}\n\ninput PluginFilterInput {\n  active: Boolean\n  search: String\n}\n\nenum PluginSortField {\n  NAME\n  IS_ACTIVE\n}\n\ninput PluginSortingInput {\n  direction: OrderDirection!\n  field: PluginSortField!\n}\n\ntype PluginUpdate {\n  errors: [Error!]\n  plugin: Plugin\n  extensionsErrors: [ExtensionsError!]\n}\n\ninput PluginUpdateInput {\n  active: Boolean\n  configuration: [ConfigurationItemInput]\n}\n\ninput PriceRangeInput {\n  gte: Float\n  lte: Float\n}\n\ntype Product implements Node {\n  id: ID!\n  seoTitle: String\n  seoDescription: String\n  name: String!\n  description: String!\n  descriptionJson: JSONString!\n  publicationDate: Date\n  isPublished: Boolean!\n  productType: ProductType!\n  category: Category\n  updatedAt: DateTime\n  chargeTaxes: Boolean!\n  weight: Weight\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  url: String!\n  thumbnail(size: Int): Image\n  pricing: ProductPricingInfo\n  isAvailable: Boolean\n  basePrice: Money\n  minimalVariantPrice: Money\n  taxType: TaxType\n  attributes: [SelectedAttribute!]!\n  purchaseCost: MoneyRange\n  margin: Margin\n  imageById(id: ID): ProductImage\n  variants: [ProductVariant]\n  images: [ProductImage]\n  collections: [Collection]\n  translation(languageCode: LanguageCodeEnum!): ProductTranslation\n  slug: String!\n}\n\ntype ProductBulkDelete {\n  errors: [Error!]\n  count: Int!\n  productErrors: [ProductError!]\n}\n\ntype ProductBulkPublish {\n  errors: [Error!]\n  count: Int!\n  productErrors: [ProductError!]\n}\n\ntype ProductClearMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  product: Product\n}\n\ntype ProductClearPrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  product: Product\n}\n\ntype ProductCountableConnection {\n  pageInfo: PageInfo!\n  edges: [ProductCountableEdge!]!\n  totalCount: Int\n}\n\ntype ProductCountableEdge {\n  node: Product!\n  cursor: String!\n}\n\ntype ProductCreate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  product: Product\n}\n\ninput ProductCreateInput {\n  attributes: [AttributeValueInput]\n  publicationDate: Date\n  category: ID\n  chargeTaxes: Boolean\n  collections: [ID]\n  description: String\n  descriptionJson: JSONString\n  isPublished: Boolean\n  name: String\n  basePrice: Decimal\n  taxCode: String\n  seo: SeoInput\n  weight: WeightScalar\n  sku: String\n  quantity: Int\n  trackInventory: Boolean\n  productType: ID!\n}\n\ntype ProductDelete {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  product: Product\n}\n\ntype ProductError {\n  field: String\n  message: String\n  code: ProductErrorCode\n}\n\nenum ProductErrorCode {\n  ALREADY_EXISTS\n  ATTRIBUTE_ALREADY_ASSIGNED\n  ATTRIBUTE_CANNOT_BE_ASSIGNED\n  ATTRIBUTE_VARIANTS_DISABLED\n  GRAPHQL_ERROR\n  INVALID\n  NOT_PRODUCTS_IMAGE\n  NOT_FOUND\n  REQUIRED\n  UNIQUE\n  VARIANT_NO_DIGITAL_CONTENT\n}\n\ninput ProductFilterInput {\n  isPublished: Boolean\n  collections: [ID]\n  categories: [ID]\n  hasCategory: Boolean\n  price: PriceRangeInput\n  attributes: [AttributeInput]\n  stockAvailability: StockAvailability\n  productType: ID\n  search: String\n  minimalPrice: PriceRangeInput\n  productTypes: [ID]\n}\n\ntype ProductImage implements Node {\n  id: ID!\n  sortOrder: Int\n  alt: String!\n  url(size: Int): String!\n}\n\ntype ProductImageBulkDelete {\n  errors: [Error!]\n  count: Int!\n  productErrors: [ProductError!]\n}\n\ntype ProductImageCreate {\n  errors: [Error!]\n  product: Product\n  image: ProductImage\n  productErrors: [ProductError!]\n}\n\ninput ProductImageCreateInput {\n  alt: String\n  image: Upload!\n  product: ID!\n}\n\ntype ProductImageDelete {\n  errors: [Error!]\n  product: Product\n  image: ProductImage\n  productErrors: [ProductError!]\n}\n\ntype ProductImageReorder {\n  errors: [Error!]\n  product: Product\n  images: [ProductImage]\n  productErrors: [ProductError!]\n}\n\ntype ProductImageUpdate {\n  errors: [Error!]\n  product: Product\n  image: ProductImage\n  productErrors: [ProductError!]\n}\n\ninput ProductImageUpdateInput {\n  alt: String\n}\n\ninput ProductInput {\n  attributes: [AttributeValueInput]\n  publicationDate: Date\n  category: ID\n  chargeTaxes: Boolean\n  collections: [ID]\n  description: String\n  descriptionJson: JSONString\n  isPublished: Boolean\n  name: String\n  basePrice: Decimal\n  taxCode: String\n  seo: SeoInput\n  weight: WeightScalar\n  sku: String\n  quantity: Int\n  trackInventory: Boolean\n}\n\ninput ProductOrder {\n  direction: OrderDirection!\n  attributeId: ID\n  field: ProductOrderField\n}\n\nenum ProductOrderField {\n  NAME\n  PRICE\n  MINIMAL_PRICE\n  DATE\n  TYPE\n  PUBLISHED\n}\n\ntype ProductPricingInfo {\n  onSale: Boolean\n  discount: TaxedMoney\n  discountLocalCurrency: TaxedMoney\n  priceRange: TaxedMoneyRange\n  priceRangeUndiscounted: TaxedMoneyRange\n  priceRangeLocalCurrency: TaxedMoneyRange\n}\n\ntype ProductTranslatableContent implements Node {\n  id: ID!\n  seoTitle: String\n  seoDescription: String\n  name: String!\n  description: String!\n  descriptionJson: JSONString!\n  translation(languageCode: LanguageCodeEnum!): ProductTranslation\n  product: Product\n}\n\ntype ProductTranslate {\n  errors: [Error!]\n  product: Product\n}\n\ntype ProductTranslation implements Node {\n  id: ID!\n  seoTitle: String\n  seoDescription: String\n  name: String!\n  description: String!\n  descriptionJson: JSONString!\n  language: LanguageDisplay!\n}\n\ntype ProductType implements Node {\n  id: ID!\n  name: String!\n  hasVariants: Boolean!\n  isShippingRequired: Boolean!\n  isDigital: Boolean!\n  weight: Weight\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  products(before: String, after: String, first: Int, last: Int): ProductCountableConnection\n  taxRate: TaxRateType\n  taxType: TaxType\n  variantAttributes: [Attribute]\n  productAttributes: [Attribute]\n  availableAttributes(filter: AttributeFilterInput, before: String, after: String, first: Int, last: Int): AttributeCountableConnection\n}\n\ntype ProductTypeBulkDelete {\n  errors: [Error!]\n  count: Int!\n  productErrors: [ProductError!]\n}\n\ntype ProductTypeClearMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productType: ProductType\n}\n\ntype ProductTypeClearPrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productType: ProductType\n}\n\nenum ProductTypeConfigurable {\n  CONFIGURABLE\n  SIMPLE\n}\n\ntype ProductTypeCountableConnection {\n  pageInfo: PageInfo!\n  edges: [ProductTypeCountableEdge!]!\n  totalCount: Int\n}\n\ntype ProductTypeCountableEdge {\n  node: ProductType!\n  cursor: String!\n}\n\ntype ProductTypeCreate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productType: ProductType\n}\n\ntype ProductTypeDelete {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productType: ProductType\n}\n\nenum ProductTypeEnum {\n  DIGITAL\n  SHIPPABLE\n}\n\ninput ProductTypeFilterInput {\n  search: String\n  configurable: ProductTypeConfigurable\n  productType: ProductTypeEnum\n  ids: [ID]\n}\n\ninput ProductTypeInput {\n  name: String\n  hasVariants: Boolean\n  productAttributes: [ID]\n  variantAttributes: [ID]\n  isShippingRequired: Boolean\n  isDigital: Boolean\n  weight: WeightScalar\n  taxCode: String\n}\n\ntype ProductTypeReorderAttributes {\n  errors: [Error!]\n  productType: ProductType\n  productErrors: [ProductError!]\n}\n\nenum ProductTypeSortField {\n  NAME\n  DIGITAL\n  SHIPPING_REQUIRED\n}\n\ninput ProductTypeSortingInput {\n  direction: OrderDirection!\n  field: ProductTypeSortField!\n}\n\ntype ProductTypeUpdate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productType: ProductType\n}\n\ntype ProductTypeUpdateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productType: ProductType\n}\n\ntype ProductTypeUpdatePrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productType: ProductType\n}\n\ntype ProductUpdate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  product: Product\n}\n\ntype ProductUpdateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  product: Product\n}\n\ntype ProductUpdatePrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  product: Product\n}\n\ntype ProductVariant implements Node {\n  id: ID!\n  name: String!\n  sku: String!\n  product: Product!\n  trackInventory: Boolean!\n  weight: Weight\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  quantity: Int! @deprecated(reason: \"This field will be removed in Saleor 2.11. Use the stock field instead.\")\n  quantityAllocated: Int @deprecated(reason: \"This field will be removed in Saleor 2.11. Use the stock field instead.\")\n  stockQuantity: Int! @deprecated(reason: \"This field will be removed in Saleor 2.11. Use the stock field instead.\")\n  priceOverride: Money\n  pricing: VariantPricingInfo\n  isAvailable: Boolean @deprecated(reason: \"This field will be removed in Saleor 2.11. Use the stock field instead.\")\n  attributes: [SelectedAttribute!]!\n  costPrice: Money\n  margin: Int\n  quantityOrdered: Int\n  revenue(period: ReportingPeriod): TaxedMoney\n  images: [ProductImage]\n  translation(languageCode: LanguageCodeEnum!): ProductVariantTranslation\n  digitalContent: DigitalContent\n  stock(country: String): [Stock]\n}\n\ntype ProductVariantBulkCreate {\n  errors: [Error!]\n  count: Int!\n  productVariants: [ProductVariant!]!\n  bulkProductErrors: [BulkProductError!]\n}\n\ninput ProductVariantBulkCreateInput {\n  attributes: [AttributeValueInput]!\n  costPrice: Decimal\n  priceOverride: Decimal\n  sku: String!\n  quantity: Int\n  trackInventory: Boolean\n  weight: WeightScalar\n}\n\ntype ProductVariantBulkDelete {\n  errors: [Error!]\n  count: Int!\n  productErrors: [ProductError!]\n}\n\ntype ProductVariantClearMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productVariant: ProductVariant\n}\n\ntype ProductVariantClearPrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productVariant: ProductVariant\n}\n\ntype ProductVariantCountableConnection {\n  pageInfo: PageInfo!\n  edges: [ProductVariantCountableEdge!]!\n  totalCount: Int\n}\n\ntype ProductVariantCountableEdge {\n  node: ProductVariant!\n  cursor: String!\n}\n\ntype ProductVariantCreate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productVariant: ProductVariant\n}\n\ninput ProductVariantCreateInput {\n  attributes: [AttributeValueInput]!\n  costPrice: Decimal\n  priceOverride: Decimal\n  sku: String\n  quantity: Int\n  trackInventory: Boolean\n  weight: WeightScalar\n  product: ID!\n}\n\ntype ProductVariantDelete {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productVariant: ProductVariant\n}\n\ninput ProductVariantInput {\n  attributes: [AttributeValueInput]\n  costPrice: Decimal\n  priceOverride: Decimal\n  sku: String\n  quantity: Int\n  trackInventory: Boolean\n  weight: WeightScalar\n}\n\ntype ProductVariantTranslatableContent implements Node {\n  id: ID!\n  name: String!\n  translation(languageCode: LanguageCodeEnum!): ProductVariantTranslation\n  productVariant: ProductVariant\n}\n\ntype ProductVariantTranslate {\n  errors: [Error!]\n  productVariant: ProductVariant\n}\n\ntype ProductVariantTranslation implements Node {\n  id: ID!\n  name: String!\n  language: LanguageDisplay!\n}\n\ntype ProductVariantUpdate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productVariant: ProductVariant\n}\n\ntype ProductVariantUpdateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productVariant: ProductVariant\n}\n\ntype ProductVariantUpdatePrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productVariant: ProductVariant\n}\n\ntype Query {\n  webhook(id: ID!): Webhook\n  webhooks(sortBy: WebhookSortingInput, filter: WebhookFilterInput, before: String, after: String, first: Int, last: Int): WebhookCountableConnection\n  webhookEvents: [WebhookEvent]\n  webhookSamplePayload(eventType: WebhookEventTypeEnum!): JSONString\n  warehouse(id: ID!): Warehouse\n  warehouses(filter: WarehouseFilterInput, before: String, after: String, first: Int, last: Int): WarehouseCountableConnection\n  translations(kind: TranslatableKinds!, before: String, after: String, first: Int, last: Int): TranslatableItemConnection\n  translation(id: ID!, kind: TranslatableKinds!): TranslatableItem\n  stock(id: ID!): Stock\n  stocks(filter: StockFilterInput, before: String, after: String, first: Int, last: Int): StockCountableConnection\n  shop: Shop\n  shippingZone(id: ID!): ShippingZone\n  shippingZones(before: String, after: String, first: Int, last: Int): ShippingZoneCountableConnection\n  digitalContent(id: ID!): DigitalContent\n  digitalContents(before: String, after: String, first: Int, last: Int): DigitalContentCountableConnection\n  attributes(filter: AttributeFilterInput, sortBy: AttributeSortingInput, before: String, after: String, first: Int, last: Int): AttributeCountableConnection\n  attribute(id: ID!): Attribute\n  categories(filter: CategoryFilterInput, sortBy: CategorySortingInput, level: Int, before: String, after: String, first: Int, last: Int): CategoryCountableConnection\n  category(id: ID!): Category\n  collection(id: ID!): Collection\n  collections(filter: CollectionFilterInput, sortBy: CollectionSortingInput, before: String, after: String, first: Int, last: Int): CollectionCountableConnection\n  product(id: ID!): Product\n  products(filter: ProductFilterInput, sortBy: ProductOrder, stockAvailability: StockAvailability, before: String, after: String, first: Int, last: Int): ProductCountableConnection\n  productType(id: ID!): ProductType\n  productTypes(filter: ProductTypeFilterInput, sortBy: ProductTypeSortingInput, before: String, after: String, first: Int, last: Int): ProductTypeCountableConnection\n  productVariant(id: ID!): ProductVariant\n  productVariants(ids: [ID], before: String, after: String, first: Int, last: Int): ProductVariantCountableConnection\n  reportProductSales(period: ReportingPeriod!, before: String, after: String, first: Int, last: Int): ProductVariantCountableConnection\n  payment(id: ID!): Payment\n  payments(before: String, after: String, first: Int, last: Int): PaymentCountableConnection\n  page(id: ID, slug: String): Page\n  pages(sortBy: PageSortingInput, filter: PageFilterInput, before: String, after: String, first: Int, last: Int): PageCountableConnection\n  homepageEvents(before: String, after: String, first: Int, last: Int): OrderEventCountableConnection\n  order(id: ID!): Order\n  orders(sortBy: OrderSortingInput, filter: OrderFilterInput, created: ReportingPeriod, status: OrderStatusFilter, before: String, after: String, first: Int, last: Int): OrderCountableConnection\n  draftOrders(sortBy: OrderSortingInput, filter: OrderDraftFilterInput, created: ReportingPeriod, before: String, after: String, first: Int, last: Int): OrderCountableConnection\n  ordersTotal(period: ReportingPeriod): TaxedMoney\n  orderByToken(token: UUID!): Order\n  menu(id: ID, name: String): Menu\n  menus(sortBy: MenuSortingInput, filter: MenuFilterInput, before: String, after: String, first: Int, last: Int): MenuCountableConnection\n  menuItem(id: ID!): MenuItem\n  menuItems(sortBy: MenuItemSortingInput, filter: MenuItemFilterInput, before: String, after: String, first: Int, last: Int): MenuItemCountableConnection\n  giftCard(id: ID!): GiftCard\n  giftCards(before: String, after: String, first: Int, last: Int): GiftCardCountableConnection\n  plugin(id: ID!): Plugin\n  plugins(filter: PluginFilterInput, sortBy: PluginSortingInput, before: String, after: String, first: Int, last: Int): PluginCountableConnection\n  sale(id: ID!): Sale\n  sales(filter: SaleFilterInput, sortBy: SaleSortingInput, query: String, before: String, after: String, first: Int, last: Int): SaleCountableConnection\n  voucher(id: ID!): Voucher\n  vouchers(filter: VoucherFilterInput, sortBy: VoucherSortingInput, query: String, before: String, after: String, first: Int, last: Int): VoucherCountableConnection\n  taxTypes: [TaxType]\n  checkout(token: UUID): Checkout\n  checkouts(before: String, after: String, first: Int, last: Int): CheckoutCountableConnection\n  checkoutLine(id: ID): CheckoutLine\n  checkoutLines(before: String, after: String, first: Int, last: Int): CheckoutLineCountableConnection\n  addressValidationRules(countryCode: CountryCode!, countryArea: String, city: String, cityArea: String): AddressValidationData\n  address(id: ID!): Address\n  customers(filter: CustomerFilterInput, sortBy: UserSortingInput, before: String, after: String, first: Int, last: Int): UserCountableConnection\n  permissionGroups(filter: PermissionGroupFilterInput, sortBy: PermissionGroupSortingInput, before: String, after: String, first: Int, last: Int): GroupCountableConnection\n  permissionGroup(id: ID!): Group\n  me: User\n  staffUsers(filter: StaffUserInput, sortBy: UserSortingInput, before: String, after: String, first: Int, last: Int): UserCountableConnection\n  serviceAccounts(filter: ServiceAccountFilterInput, sortBy: ServiceAccountSortingInput, before: String, after: String, first: Int, last: Int): ServiceAccountCountableConnection\n  serviceAccount(id: ID!): ServiceAccount\n  user(id: ID!): User\n  _entities(representations: [_Any]): [_Entity]\n  _service: _Service\n}\n\ntype ReducedRate {\n  rate: Float!\n  rateType: TaxRateType!\n}\n\ntype Refresh {\n  token: String\n  payload: GenericScalar\n}\n\ninput ReorderInput {\n  id: ID!\n  sortOrder: Int\n}\n\nenum ReportingPeriod {\n  TODAY\n  THIS_MONTH\n}\n\ntype RequestEmailChange {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n}\n\ntype RequestPasswordReset {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n}\n\ntype Sale implements Node {\n  id: ID!\n  name: String!\n  type: SaleType!\n  value: Float!\n  startDate: DateTime!\n  endDate: DateTime\n  categories(before: String, after: String, first: Int, last: Int): CategoryCountableConnection\n  collections(before: String, after: String, first: Int, last: Int): CollectionCountableConnection\n  products(before: String, after: String, first: Int, last: Int): ProductCountableConnection\n  translation(languageCode: LanguageCodeEnum!): SaleTranslation\n}\n\ntype SaleAddCatalogues {\n  errors: [Error!]\n  sale: Sale\n}\n\ntype SaleBulkDelete {\n  errors: [Error!]\n  count: Int!\n}\n\ntype SaleCountableConnection {\n  pageInfo: PageInfo!\n  edges: [SaleCountableEdge!]!\n  totalCount: Int\n}\n\ntype SaleCountableEdge {\n  node: Sale!\n  cursor: String!\n}\n\ntype SaleCreate {\n  errors: [Error!]\n  sale: Sale\n}\n\ntype SaleDelete {\n  errors: [Error!]\n  sale: Sale\n}\n\ninput SaleFilterInput {\n  status: [DiscountStatusEnum]\n  saleType: DiscountValueTypeEnum\n  started: DateTimeRangeInput\n  search: String\n}\n\ninput SaleInput {\n  name: String\n  type: DiscountValueTypeEnum\n  value: Decimal\n  products: [ID]\n  categories: [ID]\n  collections: [ID]\n  startDate: DateTime\n  endDate: DateTime\n}\n\ntype SaleRemoveCatalogues {\n  errors: [Error!]\n  sale: Sale\n}\n\nenum SaleSortField {\n  NAME\n  START_DATE\n  END_DATE\n  VALUE\n  TYPE\n}\n\ninput SaleSortingInput {\n  direction: OrderDirection!\n  field: SaleSortField!\n}\n\ntype SaleTranslatableContent implements Node {\n  id: ID!\n  name: String!\n  translation(languageCode: LanguageCodeEnum!): SaleTranslation\n  sale: Sale\n}\n\ntype SaleTranslate {\n  errors: [Error!]\n  sale: Sale\n}\n\ntype SaleTranslation implements Node {\n  id: ID!\n  name: String\n  language: LanguageDisplay!\n}\n\nenum SaleType {\n  FIXED\n  PERCENTAGE\n}\n\ntype SaleUpdate {\n  errors: [Error!]\n  sale: Sale\n}\n\ntype SelectedAttribute {\n  attribute: Attribute!\n  values: [AttributeValue]!\n}\n\ninput SeoInput {\n  title: String\n  description: String\n}\n\ntype ServiceAccount implements Node {\n  id: ID!\n  created: DateTime\n  isActive: Boolean\n  tokens: [ServiceAccountToken]\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  permissions: [PermissionDisplay]\n  name: String\n}\n\ntype ServiceAccountClearPrivateMeta {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  serviceAccount: ServiceAccount\n}\n\ntype ServiceAccountCountableConnection {\n  pageInfo: PageInfo!\n  edges: [ServiceAccountCountableEdge!]!\n  totalCount: Int\n}\n\ntype ServiceAccountCountableEdge {\n  node: ServiceAccount!\n  cursor: String!\n}\n\ntype ServiceAccountCreate {\n  errors: [Error!]\n  authToken: String\n  accountErrors: [AccountError!]\n  serviceAccount: ServiceAccount\n}\n\ntype ServiceAccountDelete {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  serviceAccount: ServiceAccount\n}\n\ninput ServiceAccountFilterInput {\n  search: String\n  isActive: Boolean\n}\n\ninput ServiceAccountInput {\n  name: String\n  isActive: Boolean\n  permissions: [PermissionEnum]\n}\n\nenum ServiceAccountSortField {\n  NAME\n  CREATION_DATE\n}\n\ninput ServiceAccountSortingInput {\n  direction: OrderDirection!\n  field: ServiceAccountSortField!\n}\n\ntype ServiceAccountToken implements Node {\n  name: String\n  authToken: String\n  id: ID!\n}\n\ntype ServiceAccountTokenCreate {\n  errors: [Error!]\n  authToken: String\n  accountErrors: [AccountError!]\n  serviceAccountToken: ServiceAccountToken\n}\n\ntype ServiceAccountTokenDelete {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  serviceAccountToken: ServiceAccountToken\n}\n\ninput ServiceAccountTokenInput {\n  name: String\n  serviceAccount: ID!\n}\n\ntype ServiceAccountUpdate {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  serviceAccount: ServiceAccount\n}\n\ntype ServiceAccountUpdatePrivateMeta {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  serviceAccount: ServiceAccount\n}\n\ntype SetPassword {\n  token: String\n  errors: [Error]!\n  user: User\n  accountErrors: [AccountError!]\n}\n\ntype ShippingError {\n  field: String\n  message: String\n  code: ShippingErrorCode\n}\n\nenum ShippingErrorCode {\n  ALREADY_EXISTS\n  GRAPHQL_ERROR\n  INVALID\n  MAX_LESS_THAN_MIN\n  NOT_FOUND\n  REQUIRED\n  UNIQUE\n}\n\ntype ShippingMethod implements Node {\n  id: ID!\n  name: String!\n  price: Money\n  minimumOrderPrice: Money\n  maximumOrderPrice: Money\n  minimumOrderWeight: Weight\n  maximumOrderWeight: Weight\n  type: ShippingMethodTypeEnum\n  translation(languageCode: LanguageCodeEnum!): ShippingMethodTranslation\n}\n\ntype ShippingMethodTranslatableContent implements Node {\n  id: ID!\n  name: String!\n  translation(languageCode: LanguageCodeEnum!): ShippingMethodTranslation\n  shippingMethod: ShippingMethod\n}\n\ntype ShippingMethodTranslation implements Node {\n  id: ID!\n  name: String\n  language: LanguageDisplay!\n}\n\nenum ShippingMethodTypeEnum {\n  PRICE\n  WEIGHT\n}\n\ntype ShippingPriceBulkDelete {\n  errors: [Error!]\n  count: Int!\n  shippingErrors: [ShippingError!]\n}\n\ntype ShippingPriceCreate {\n  errors: [Error!]\n  shippingZone: ShippingZone\n  shippingErrors: [ShippingError!]\n  shippingMethod: ShippingMethod\n}\n\ntype ShippingPriceDelete {\n  errors: [Error!]\n  shippingMethod: ShippingMethod\n  shippingZone: ShippingZone\n  shippingErrors: [ShippingError!]\n}\n\ninput ShippingPriceInput {\n  name: String\n  price: Decimal\n  minimumOrderPrice: Decimal\n  maximumOrderPrice: Decimal\n  minimumOrderWeight: WeightScalar\n  maximumOrderWeight: WeightScalar\n  type: ShippingMethodTypeEnum\n  shippingZone: ID\n}\n\ntype ShippingPriceTranslate {\n  errors: [Error!]\n  shippingMethod: ShippingMethod\n}\n\ntype ShippingPriceUpdate {\n  errors: [Error!]\n  shippingZone: ShippingZone\n  shippingErrors: [ShippingError!]\n  shippingMethod: ShippingMethod\n}\n\ntype ShippingZone implements Node {\n  id: ID!\n  name: String!\n  default: Boolean!\n  priceRange: MoneyRange\n  countries: [CountryDisplay]\n  shippingMethods: [ShippingMethod]\n}\n\ntype ShippingZoneBulkDelete {\n  errors: [Error!]\n  count: Int!\n  shippingErrors: [ShippingError!]\n}\n\ntype ShippingZoneCountableConnection {\n  pageInfo: PageInfo!\n  edges: [ShippingZoneCountableEdge!]!\n  totalCount: Int\n}\n\ntype ShippingZoneCountableEdge {\n  node: ShippingZone!\n  cursor: String!\n}\n\ntype ShippingZoneCreate {\n  errors: [Error!]\n  shippingZone: ShippingZone\n  shippingErrors: [ShippingError!]\n}\n\ntype ShippingZoneDelete {\n  errors: [Error!]\n  shippingErrors: [ShippingError!]\n  shippingZone: ShippingZone\n}\n\ninput ShippingZoneInput {\n  name: String\n  countries: [String]\n  default: Boolean\n}\n\ntype ShippingZoneUpdate {\n  errors: [Error!]\n  shippingZone: ShippingZone\n  shippingErrors: [ShippingError!]\n}\n\ntype Shop {\n  geolocalization: Geolocalization\n  authorizationKeys: [AuthorizationKey]!\n  countries(languageCode: LanguageCodeEnum): [CountryDisplay]!\n  currencies: [String]!\n  defaultCurrency: String!\n  defaultCountry: CountryDisplay\n  defaultMailSenderName: String\n  defaultMailSenderAddress: String\n  description: String\n  domain: Domain!\n  homepageCollection: Collection\n  languages: [LanguageDisplay]!\n  name: String!\n  navigation: Navigation\n  permissions: [PermissionDisplay]!\n  phonePrefixes: [String]!\n  headerText: String\n  includeTaxesInPrices: Boolean!\n  displayGrossPrices: Boolean!\n  chargeTaxesOnShipping: Boolean!\n  trackInventoryByDefault: Boolean\n  defaultWeightUnit: WeightUnitsEnum\n  translation(languageCode: LanguageCodeEnum!): ShopTranslation\n  automaticFulfillmentDigitalProducts: Boolean\n  defaultDigitalMaxDownloads: Int\n  defaultDigitalUrlValidDays: Int\n  companyAddress: Address\n  customerSetPasswordUrl: String\n  staffNotificationRecipients: [StaffNotificationRecipient]\n}\n\ntype ShopAddressUpdate {\n  errors: [Error!]\n  shop: Shop\n  shopErrors: [ShopError!]\n}\n\ntype ShopDomainUpdate {\n  errors: [Error!]\n  shop: Shop\n  shopErrors: [ShopError!]\n}\n\ntype ShopError {\n  field: String\n  message: String\n  code: ShopErrorCode\n}\n\nenum ShopErrorCode {\n  ALREADY_EXISTS\n  CANNOT_FETCH_TAX_RATES\n  GRAPHQL_ERROR\n  INVALID\n  NOT_FOUND\n  REQUIRED\n  UNIQUE\n}\n\ntype ShopFetchTaxRates {\n  errors: [Error!]\n  shop: Shop\n  shopErrors: [ShopError!]\n}\n\ninput ShopSettingsInput {\n  headerText: String\n  description: String\n  includeTaxesInPrices: Boolean\n  displayGrossPrices: Boolean\n  chargeTaxesOnShipping: Boolean\n  trackInventoryByDefault: Boolean\n  defaultWeightUnit: WeightUnitsEnum\n  automaticFulfillmentDigitalProducts: Boolean\n  defaultDigitalMaxDownloads: Int\n  defaultDigitalUrlValidDays: Int\n  defaultMailSenderName: String\n  defaultMailSenderAddress: String\n  customerSetPasswordUrl: String\n}\n\ntype ShopSettingsTranslate {\n  errors: [Error!]\n  shop: Shop\n}\n\ninput ShopSettingsTranslationInput {\n  headerText: String\n  description: String\n}\n\ntype ShopSettingsUpdate {\n  errors: [Error!]\n  shop: Shop\n  shopErrors: [ShopError!]\n}\n\ntype ShopTranslation implements Node {\n  id: ID!\n  headerText: String!\n  description: String!\n  language: LanguageDisplay!\n}\n\ninput SiteDomainInput {\n  domain: String\n  name: String\n}\n\ntype StaffBulkDelete {\n  errors: [Error!]\n  count: Int!\n  accountErrors: [AccountError!]\n}\n\ntype StaffCreate {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ninput StaffCreateInput {\n  firstName: String\n  lastName: String\n  email: String\n  isActive: Boolean\n  note: String\n  permissions: [PermissionEnum]\n  redirectUrl: String\n}\n\ntype StaffDelete {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ninput StaffInput {\n  firstName: String\n  lastName: String\n  email: String\n  isActive: Boolean\n  note: String\n  permissions: [PermissionEnum]\n}\n\nenum StaffMemberStatus {\n  ACTIVE\n  DEACTIVATED\n}\n\ntype StaffNotificationRecipient implements Node {\n  user: User\n  active: Boolean\n  id: ID!\n  email: String\n}\n\ntype StaffNotificationRecipientCreate {\n  errors: [Error!]\n  shopErrors: [ShopError!]\n  staffNotificationRecipient: StaffNotificationRecipient\n}\n\ntype StaffNotificationRecipientDelete {\n  errors: [Error!]\n  shopErrors: [ShopError!]\n  staffNotificationRecipient: StaffNotificationRecipient\n}\n\ninput StaffNotificationRecipientInput {\n  user: ID\n  email: String\n  active: Boolean\n}\n\ntype StaffNotificationRecipientUpdate {\n  errors: [Error!]\n  shopErrors: [ShopError!]\n  staffNotificationRecipient: StaffNotificationRecipient\n}\n\ntype StaffUpdate {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ninput StaffUserInput {\n  status: StaffMemberStatus\n  search: String\n}\n\ntype Stock implements Node {\n  warehouse: Warehouse!\n  productVariant: ProductVariant!\n  quantity: Int!\n  quantityAllocated: Int!\n  id: ID!\n  stockQuantity: Int!\n}\n\nenum StockAvailability {\n  IN_STOCK\n  OUT_OF_STOCK\n}\n\ntype StockBulkDelete {\n  errors: [Error!]\n  count: Int!\n  stockError: [StockError!]\n}\n\ntype StockCountableConnection {\n  pageInfo: PageInfo!\n  edges: [StockCountableEdge!]!\n  totalCount: Int\n}\n\ntype StockCountableEdge {\n  node: Stock!\n  cursor: String!\n}\n\ntype StockCreate {\n  errors: [Error!]\n  stockErrors: [StockError!]\n  stock: Stock\n}\n\ntype StockDelete {\n  errors: [Error!]\n  stock: Stock\n}\n\nenum StockErorrCode {\n  ALREADY_EXISTS\n  GRAPHQL_ERROR\n  INVALID\n  NOT_FOUND\n  REQUIRED\n  UNIQUE\n}\n\ntype StockError {\n  field: String\n  message: String\n  code: StockErorrCode\n}\n\ninput StockFilterInput {\n  quantity: Float\n  quantityAllocated: Float\n  search: String\n}\n\ninput StockInput {\n  productVariant: ID!\n  warehouse: ID!\n  quantity: Int\n}\n\ntype StockUpdate {\n  errors: [Error!]\n  stockError: [StockError!]\n  stock: Stock\n}\n\nenum TaxRateType {\n  ACCOMMODATION\n  ADMISSION_TO_CULTURAL_EVENTS\n  ADMISSION_TO_ENTERTAINMENT_EVENTS\n  ADMISSION_TO_SPORTING_EVENTS\n  ADVERTISING\n  AGRICULTURAL_SUPPLIES\n  BABY_FOODSTUFFS\n  BIKES\n  BOOKS\n  CHILDRENS_CLOTHING\n  DOMESTIC_FUEL\n  DOMESTIC_SERVICES\n  E_BOOKS\n  FOODSTUFFS\n  HOTELS\n  MEDICAL\n  NEWSPAPERS\n  PASSENGER_TRANSPORT\n  PHARMACEUTICALS\n  PROPERTY_RENOVATIONS\n  RESTAURANTS\n  SOCIAL_HOUSING\n  STANDARD\n  WATER\n  WINE\n}\n\ntype TaxType {\n  description: String\n  taxCode: String\n}\n\ntype TaxedMoney {\n  currency: String!\n  gross: Money!\n  net: Money!\n  tax: Money!\n}\n\ntype TaxedMoneyRange {\n  start: TaxedMoney\n  stop: TaxedMoney\n}\n\ntype Transaction implements Node {\n  id: ID!\n  created: DateTime!\n  payment: Payment!\n  token: String!\n  kind: TransactionKind!\n  isSuccess: Boolean!\n  error: TransactionError\n  gatewayResponse: JSONString!\n  amount: Money\n}\n\nenum TransactionError {\n  TRANSACTIONERROR_INCORRECT_NUMBER\n  TRANSACTIONERROR_INVALID_NUMBER\n  TRANSACTIONERROR_INCORRECT_CVV\n  TRANSACTIONERROR_INVALID_CVV\n  TRANSACTIONERROR_INCORRECT_ZIP\n  TRANSACTIONERROR_INCORRECT_ADDRESS\n  TRANSACTIONERROR_INVALID_EXPIRY_DATE\n  TRANSACTIONERROR_EXPIRED\n  TRANSACTIONERROR_PROCESSING_ERROR\n  TRANSACTIONERROR_DECLINED\n}\n\nenum TransactionKind {\n  AUTH\n  REFUND\n  CAPTURE\n  VOID\n  CONFIRM\n}\n\nunion TranslatableItem = ProductTranslatableContent | CollectionTranslatableContent | CategoryTranslatableContent | AttributeTranslatableContent | AttributeValueTranslatableContent | ProductVariantTranslatableContent | PageTranslatableContent | ShippingMethodTranslatableContent | SaleTranslatableContent | VoucherTranslatableContent | MenuItemTranslatableContent\n\ntype TranslatableItemConnection {\n  pageInfo: PageInfo!\n  edges: [TranslatableItemEdge!]!\n  totalCount: Int\n}\n\ntype TranslatableItemEdge {\n  node: TranslatableItem!\n  cursor: String!\n}\n\nenum TranslatableKinds {\n  ATTRIBUTE\n  ATTRIBUTE_VALUE\n  CATEGORY\n  COLLECTION\n  MENU_ITEM\n  PAGE\n  PRODUCT\n  SALE\n  SHIPPING_METHOD\n  VARIANT\n  VOUCHER\n}\n\ninput TranslationInput {\n  seoTitle: String\n  seoDescription: String\n  name: String\n  description: String\n  descriptionJson: JSONString\n}\n\nscalar UUID\n\nscalar Upload\n\ntype User implements Node {\n  id: ID!\n  lastLogin: DateTime\n  email: String!\n  firstName: String!\n  lastName: String!\n  isStaff: Boolean!\n  isActive: Boolean!\n  note: String\n  dateJoined: DateTime!\n  defaultShippingAddress: Address\n  defaultBillingAddress: Address\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  addresses: [Address]\n  checkout: Checkout\n  giftCards(before: String, after: String, first: Int, last: Int): GiftCardCountableConnection\n  orders(before: String, after: String, first: Int, last: Int): OrderCountableConnection\n  permissions: [PermissionDisplay]\n  avatar(size: Int): Image\n  events: [CustomerEvent]\n  storedPaymentSources: [PaymentSource]\n  wishlist(before: String, after: String, first: Int, last: Int): WishlistItemCountableConnection\n}\n\ntype UserAvatarDelete {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n}\n\ntype UserAvatarUpdate {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n}\n\ntype UserBulkSetActive {\n  errors: [Error!]\n  count: Int!\n  accountErrors: [AccountError!]\n}\n\ntype UserClearMeta {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ntype UserClearPrivateMeta {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ntype UserCountableConnection {\n  pageInfo: PageInfo!\n  edges: [UserCountableEdge!]!\n  totalCount: Int\n}\n\ntype UserCountableEdge {\n  node: User!\n  cursor: String!\n}\n\ninput UserCreateInput {\n  defaultBillingAddress: AddressInput\n  defaultShippingAddress: AddressInput\n  firstName: String\n  lastName: String\n  email: String\n  isActive: Boolean\n  note: String\n  redirectUrl: String\n}\n\nenum UserSortField {\n  FIRST_NAME\n  LAST_NAME\n  EMAIL\n  ORDER_COUNT\n}\n\ninput UserSortingInput {\n  direction: OrderDirection!\n  field: UserSortField!\n}\n\ntype UserUpdateMeta {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ntype UserUpdatePrivateMeta {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ninput UsersInput {\n  users: [ID!]!\n}\n\ntype VAT {\n  countryCode: String!\n  standardRate: Float\n  reducedRates: [ReducedRate]!\n}\n\ntype VariantImageAssign {\n  errors: [Error!]\n  productVariant: ProductVariant\n  image: ProductImage\n  productErrors: [ProductError!]\n}\n\ntype VariantImageUnassign {\n  errors: [Error!]\n  productVariant: ProductVariant\n  image: ProductImage\n  productErrors: [ProductError!]\n}\n\ntype VariantPricingInfo {\n  onSale: Boolean\n  discount: TaxedMoney\n  discountLocalCurrency: TaxedMoney\n  price: TaxedMoney\n  priceUndiscounted: TaxedMoney\n  priceLocalCurrency: TaxedMoney\n}\n\ntype VerifyToken {\n  payload: GenericScalar\n  user: User\n}\n\ntype Voucher implements Node {\n  id: ID!\n  name: String\n  type: VoucherTypeEnum!\n  code: String!\n  usageLimit: Int\n  used: Int!\n  startDate: DateTime!\n  endDate: DateTime\n  applyOncePerOrder: Boolean!\n  applyOncePerCustomer: Boolean!\n  discountValueType: DiscountValueTypeEnum!\n  discountValue: Float!\n  minSpent: Money\n  minCheckoutItemsQuantity: Int\n  categories(before: String, after: String, first: Int, last: Int): CategoryCountableConnection\n  collections(before: String, after: String, first: Int, last: Int): CollectionCountableConnection\n  products(before: String, after: String, first: Int, last: Int): ProductCountableConnection\n  countries: [CountryDisplay]\n  translation(languageCode: LanguageCodeEnum!): VoucherTranslation\n}\n\ntype VoucherAddCatalogues {\n  errors: [Error!]\n  voucher: Voucher\n}\n\ntype VoucherBulkDelete {\n  errors: [Error!]\n  count: Int!\n}\n\ntype VoucherCountableConnection {\n  pageInfo: PageInfo!\n  edges: [VoucherCountableEdge!]!\n  totalCount: Int\n}\n\ntype VoucherCountableEdge {\n  node: Voucher!\n  cursor: String!\n}\n\ntype VoucherCreate {\n  errors: [Error!]\n  voucher: Voucher\n}\n\ntype VoucherDelete {\n  errors: [Error!]\n  voucher: Voucher\n}\n\nenum VoucherDiscountType {\n  FIXED\n  PERCENTAGE\n  SHIPPING\n}\n\ninput VoucherFilterInput {\n  status: [DiscountStatusEnum]\n  timesUsed: IntRangeInput\n  discountType: [VoucherDiscountType]\n  started: DateTimeRangeInput\n  search: String\n}\n\ninput VoucherInput {\n  type: VoucherTypeEnum\n  name: String\n  code: String\n  startDate: DateTime\n  endDate: DateTime\n  discountValueType: DiscountValueTypeEnum\n  discountValue: Decimal\n  products: [ID]\n  collections: [ID]\n  categories: [ID]\n  minAmountSpent: Decimal\n  minCheckoutItemsQuantity: Int\n  countries: [String]\n  applyOncePerOrder: Boolean\n  applyOncePerCustomer: Boolean\n  usageLimit: Int\n}\n\ntype VoucherRemoveCatalogues {\n  errors: [Error!]\n  voucher: Voucher\n}\n\nenum VoucherSortField {\n  CODE\n  START_DATE\n  END_DATE\n  VALUE\n  TYPE\n  USAGE_LIMIT\n  MINIMUM_SPENT_AMOUNT\n}\n\ninput VoucherSortingInput {\n  direction: OrderDirection!\n  field: VoucherSortField!\n}\n\ntype VoucherTranslatableContent implements Node {\n  id: ID!\n  name: String\n  translation(languageCode: LanguageCodeEnum!): VoucherTranslation\n  voucher: Voucher\n}\n\ntype VoucherTranslate {\n  errors: [Error!]\n  voucher: Voucher\n}\n\ntype VoucherTranslation implements Node {\n  id: ID!\n  name: String\n  language: LanguageDisplay!\n}\n\nenum VoucherTypeEnum {\n  SHIPPING\n  ENTIRE_ORDER\n  SPECIFIC_PRODUCT\n}\n\ntype VoucherUpdate {\n  errors: [Error!]\n  voucher: Voucher\n}\n\ntype Warehouse implements Node {\n  id: ID!\n  name: String!\n  companyName: String!\n  shippingZones(before: String, after: String, first: Int, last: Int): ShippingZoneCountableConnection!\n  address: Address!\n  email: String!\n}\n\ninput WarehouseAddressInput {\n  streetAddress1: String!\n  streetAddress2: String\n  city: String!\n  cityArea: String\n  postalCode: String\n  country: CountryCode!\n  countryArea: String\n  phone: String\n}\n\ntype WarehouseCountableConnection {\n  pageInfo: PageInfo!\n  edges: [WarehouseCountableEdge!]!\n  totalCount: Int\n}\n\ntype WarehouseCountableEdge {\n  node: Warehouse!\n  cursor: String!\n}\n\ntype WarehouseCreate {\n  errors: [Error!]\n  warehouseErrors: [WarehouseError!]\n  warehouse: Warehouse\n}\n\ninput WarehouseCreateInput {\n  name: String!\n  companyName: String\n  shippingZones: [ID]\n  email: String\n  address: WarehouseAddressInput!\n}\n\ntype WarehouseDelete {\n  errors: [Error!]\n  warehouseErrors: [WarehouseError!]\n  warehouse: Warehouse\n}\n\ntype WarehouseError {\n  field: String\n  message: String\n  code: WarehouseErrorCode\n}\n\nenum WarehouseErrorCode {\n  ALREADY_EXISTS\n  GRAPHQL_ERROR\n  INVALID\n  NOT_FOUND\n  REQUIRED\n  UNIQUE\n}\n\ninput WarehouseFilterInput {\n  search: String\n}\n\ntype WarehouseUpdate {\n  errors: [Error!]\n  warehouseErrors: [WarehouseError!]\n  warehouse: Warehouse\n}\n\ninput WarehouseUpdateInput {\n  name: String!\n  companyName: String\n  shippingZones: [ID]\n  email: String\n  address: WarehouseAddressInput\n}\n\ntype Webhook implements Node {\n  name: String\n  serviceAccount: ServiceAccount!\n  targetUrl: String!\n  isActive: Boolean!\n  secretKey: String\n  id: ID!\n  events: [WebhookEvent]\n}\n\ntype WebhookCountableConnection {\n  pageInfo: PageInfo!\n  edges: [WebhookCountableEdge!]!\n  totalCount: Int\n}\n\ntype WebhookCountableEdge {\n  node: Webhook!\n  cursor: String!\n}\n\ntype WebhookCreate {\n  errors: [Error!]\n  webhookErrors: [WebhookError!]\n  webhook: Webhook\n}\n\ninput WebhookCreateInput {\n  name: String\n  targetUrl: String\n  events: [WebhookEventTypeEnum]\n  serviceAccount: ID\n  isActive: Boolean\n  secretKey: String\n}\n\ntype WebhookDelete {\n  errors: [Error!]\n  webhook: Webhook\n  webhookErrors: [WebhookError!]\n}\n\ntype WebhookError {\n  field: String\n  message: String\n  code: WebhookErrorCode\n}\n\nenum WebhookErrorCode {\n  GRAPHQL_ERROR\n  INVALID\n  NOT_FOUND\n  REQUIRED\n  UNIQUE\n}\n\ntype WebhookEvent {\n  eventType: WebhookEventTypeEnum\n  name: String\n}\n\nenum WebhookEventTypeEnum {\n  ANY_EVENTS\n  ORDER_CREATED\n  ORDER_FULLY_PAID\n  ORDER_UPDATED\n  ORDER_CANCELLED\n  ORDER_FULFILLED\n  CUSTOMER_CREATED\n  PRODUCT_CREATED\n  CHECKOUT_QUANTITY_CHANGED\n}\n\ninput WebhookFilterInput {\n  search: String\n  isActive: Boolean\n}\n\nenum WebhookSortField {\n  NAME\n  SERVICE_ACCOUNT\n  TARGET_URL\n}\n\ninput WebhookSortingInput {\n  direction: OrderDirection!\n  field: WebhookSortField!\n}\n\ntype WebhookUpdate {\n  errors: [Error!]\n  webhook: Webhook\n  webhookErrors: [WebhookError!]\n}\n\ninput WebhookUpdateInput {\n  name: String\n  targetUrl: String\n  events: [WebhookEventTypeEnum]\n  serviceAccount: ID\n  isActive: Boolean\n  secretKey: String\n}\n\ntype Weight {\n  unit: String!\n  value: Float!\n}\n\nscalar WeightScalar\n\nenum WeightUnitsEnum {\n  KG\n  LB\n  OZ\n  G\n}\n\ntype Wishlist implements Node {\n  id: ID!\n  createdAt: DateTime!\n  items(before: String, after: String, first: Int, last: Int, id: ID): WishlistItemCountableConnection!\n}\n\ntype WishlistAddProductMutation {\n  errors: [Error!]\n  wishlist: [WishlistItem]\n  wishlistErrors: [WishlistError!]\n}\n\ntype WishlistAddProductVariantMutation {\n  errors: [Error!]\n  wishlist: [WishlistItem]\n  wishlistErrors: [WishlistError!]\n}\n\ntype WishlistError {\n  field: String\n  message: String\n  code: WishlistErrorCode\n}\n\nenum WishlistErrorCode {\n  GRAPHQL_ERROR\n  INVALID\n  NOT_FOUND\n  REQUIRED\n  UNIQUE\n}\n\ntype WishlistItem implements Node {\n  id: ID!\n  wishlist: Wishlist!\n  product: Product!\n  variants(before: String, after: String, first: Int, last: Int): ProductVariantCountableConnection!\n}\n\ntype WishlistItemCountableConnection {\n  pageInfo: PageInfo!\n  edges: [WishlistItemCountableEdge!]!\n  totalCount: Int\n}\n\ntype WishlistItemCountableEdge {\n  node: WishlistItem!\n  cursor: String!\n}\n\ntype WishlistRemoveProductMutation {\n  errors: [Error!]\n  wishlist: [WishlistItem]\n  wishlistErrors: [WishlistError!]\n}\n\ntype WishlistRemoveProductVariantMutation {\n  errors: [Error!]\n  wishlist: [WishlistItem]\n  wishlistErrors: [WishlistError!]\n}\n\nscalar _Any\n\nunion _Entity = Address | ServiceAccount | User | Group | ProductVariant | Product | ProductType | Collection | Category | ProductImage\n\ntype _Service {\n  sdl: String\n}\n", "import uuid\nfrom decimal import Decimal\nfrom unittest import mock\nfrom unittest.mock import ANY, patch\n\nimport graphene\nimport pytest\nfrom django.core.exceptions import ValidationError\nfrom prices import Money, TaxedMoney\n\nfrom saleor.checkout import calculations\nfrom saleor.checkout.error_codes import CheckoutErrorCode\nfrom saleor.checkout.models import Checkout\nfrom saleor.checkout.utils import clean_checkout, is_fully_paid\nfrom saleor.core.payments import PaymentInterface\nfrom saleor.core.taxes import zero_money\nfrom saleor.extensions.manager import ExtensionsManager\nfrom saleor.graphql.checkout.mutations import (\n    clean_shipping_method,\n    update_checkout_shipping_method_if_invalid,\n)\nfrom saleor.order.models import Order\nfrom saleor.payment import TransactionKind\nfrom saleor.payment.interface import GatewayResponse\nfrom saleor.shipping import ShippingMethodType\nfrom saleor.shipping.models import ShippingMethod\nfrom saleor.warehouse.models import Stock\nfrom tests.api.utils import get_graphql_content\n\n\n@pytest.fixture\ndef other_shipping_method(shipping_zone):\n    return ShippingMethod.objects.create(\n        name=\"DPD\",\n        minimum_order_price=Money(0, \"USD\"),\n        type=ShippingMethodType.PRICE_BASED,\n        price=Money(9, \"USD\"),\n        shipping_zone=shipping_zone,\n    )\n\n\n@pytest.fixture(autouse=True)\ndef setup_dummy_gateway(settings):\n    settings.PLUGINS = [\"saleor.payment.gateways.dummy.plugin.DummyGatewayPlugin\"]\n    return settings\n\n\ndef test_clean_shipping_method_after_shipping_address_changes_stay_the_same(\n    checkout_with_single_item, address, shipping_method, other_shipping_method\n):\n    \"\"\"Ensure the current shipping method applies to new address.\n\n    If it does, then it doesn't need to be changed.\n    \"\"\"\n\n    checkout = checkout_with_single_item\n    checkout.shipping_address = address\n\n    is_valid_method = clean_shipping_method(checkout, shipping_method, [])\n    assert is_valid_method is True\n\n\ndef test_clean_shipping_method_does_nothing_if_no_shipping_method(\n    checkout_with_single_item, address, other_shipping_method\n):\n    \"\"\"If no shipping method was selected, it shouldn't return an error.\"\"\"\n\n    checkout = checkout_with_single_item\n    checkout.shipping_address = address\n\n    is_valid_method = clean_shipping_method(checkout, None, [])\n    assert is_valid_method is True\n\n\ndef test_update_checkout_shipping_method_if_invalid(\n    checkout_with_single_item,\n    address,\n    shipping_method,\n    other_shipping_method,\n    shipping_zone_without_countries,\n):\n    \"\"\"If the shipping method is invalid, it should replace it.\"\"\"\n\n    checkout = checkout_with_single_item\n    checkout.shipping_address = address\n    checkout.shipping_method = shipping_method\n\n    shipping_method.shipping_zone = shipping_zone_without_countries\n    shipping_method.save(update_fields=[\"shipping_zone\"])\n\n    update_checkout_shipping_method_if_invalid(checkout, None)\n\n    assert checkout.shipping_method == other_shipping_method\n\n    # Ensure the checkout's shipping method was saved\n    checkout.refresh_from_db(fields=[\"shipping_method\"])\n    assert checkout.shipping_method == other_shipping_method\n\n\nMUTATION_CHECKOUT_CREATE = \"\"\"\n    mutation createCheckout($checkoutInput: CheckoutCreateInput!) {\n      checkoutCreate(input: $checkoutInput) {\n        created\n        checkout {\n          id\n          token\n          email\n          lines {\n            quantity\n          }\n        }\n        errors {\n          field\n          message\n        }\n        checkoutErrors {\n          field\n          message\n          code\n        }\n      }\n    }\n\"\"\"\n\n\ndef test_checkout_create(api_client, stock, graphql_address_data):\n    \"\"\"Create checkout object using GraphQL API.\"\"\"\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.id)\n    test_email = \"test@example.com\"\n    shipping_address = graphql_address_data\n    variables = {\n        \"checkoutInput\": {\n            \"lines\": [{\"quantity\": 1, \"variantId\": variant_id}],\n            \"email\": test_email,\n            \"shippingAddress\": shipping_address,\n        }\n    }\n    assert not Checkout.objects.exists()\n    response = api_client.post_graphql(MUTATION_CHECKOUT_CREATE, variables)\n    content = get_graphql_content(response)[\"data\"][\"checkoutCreate\"]\n\n    # Look at the flag to see whether a new checkout was created or not\n    assert content[\"created\"] is True\n\n    new_checkout = Checkout.objects.first()\n    assert new_checkout is not None\n    checkout_data = content[\"checkout\"]\n    assert checkout_data[\"token\"] == str(new_checkout.token)\n    assert new_checkout.lines.count() == 1\n    checkout_line = new_checkout.lines.first()\n    assert checkout_line.variant == variant\n    assert checkout_line.quantity == 1\n    assert new_checkout.shipping_address is not None\n    assert new_checkout.shipping_address.first_name == shipping_address[\"firstName\"]\n    assert new_checkout.shipping_address.last_name == shipping_address[\"lastName\"]\n    assert (\n        new_checkout.shipping_address.street_address_1\n        == shipping_address[\"streetAddress1\"]\n    )\n    assert (\n        new_checkout.shipping_address.street_address_2\n        == shipping_address[\"streetAddress2\"]\n    )\n    assert new_checkout.shipping_address.postal_code == shipping_address[\"postalCode\"]\n    assert new_checkout.shipping_address.country == shipping_address[\"country\"]\n    assert new_checkout.shipping_address.city == shipping_address[\"city\"].upper()\n\n\n@pytest.mark.parametrize(\n    \"quantity, expected_error_message, error_code\",\n    (\n        (\n            -1,\n            \"The quantity should be higher than zero.\",\n            CheckoutErrorCode.ZERO_QUANTITY,\n        ),\n        (\n            51,\n            \"Cannot add more than 50 times this item.\",\n            CheckoutErrorCode.QUANTITY_GREATER_THAN_LIMIT,\n        ),\n    ),\n)\ndef test_checkout_create_cannot_add_invalid_quantities(\n    api_client,\n    stock,\n    graphql_address_data,\n    quantity,\n    expected_error_message,\n    error_code,\n):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.id)\n    test_email = \"test@example.com\"\n    shipping_address = graphql_address_data\n    variables = {\n        \"checkoutInput\": {\n            \"lines\": [{\"quantity\": quantity, \"variantId\": variant_id}],\n            \"email\": test_email,\n            \"shippingAddress\": shipping_address,\n        }\n    }\n    assert not Checkout.objects.exists()\n    response = api_client.post_graphql(MUTATION_CHECKOUT_CREATE, variables)\n    content = get_graphql_content(response)[\"data\"][\"checkoutCreate\"]\n    assert content[\"errors\"]\n    assert content[\"errors\"] == [\n        {\"field\": \"quantity\", \"message\": expected_error_message}\n    ]\n\n    assert content[\"checkoutErrors\"] == [\n        {\n            \"field\": \"quantity\",\n            \"message\": expected_error_message,\n            \"code\": error_code.name,\n        }\n    ]\n\n\ndef test_checkout_create_reuse_checkout(checkout, user_api_client, stock):\n    # assign user to the checkout\n    checkout.user = user_api_client.user\n    checkout.save()\n    variant = stock.product_variant\n\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.id)\n    variables = {\"checkoutInput\": {\"lines\": [{\"quantity\": 1, \"variantId\": variant_id}]}}\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_CREATE, variables)\n    content = get_graphql_content(response)[\"data\"][\"checkoutCreate\"]\n\n    # Look at the flag to see whether a new checkout was created or not\n    assert not content[\"created\"]\n\n    # assert that existing checkout was reused and returned by mutation\n    checkout_data = content[\"checkout\"]\n    assert checkout_data[\"token\"] == str(checkout.token)\n\n    # if checkout was reused it should be returned unmodified (e.g. without\n    # adding new lines that was passed)\n    assert checkout_data[\"lines\"] == []\n\n\ndef test_checkout_create_required_email(api_client, stock):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.id)\n    variables = {\n        \"checkoutInput\": {\n            \"lines\": [{\"quantity\": 1, \"variantId\": variant_id}],\n            \"email\": \"\",\n        }\n    }\n\n    response = api_client.post_graphql(MUTATION_CHECKOUT_CREATE, variables)\n    content = get_graphql_content(response)\n\n    errors = content[\"data\"][\"checkoutCreate\"][\"errors\"]\n    assert errors\n    assert errors[0][\"field\"] == \"email\"\n    assert errors[0][\"message\"] == \"This field cannot be blank.\"\n\n    checkout_errors = content[\"data\"][\"checkoutCreate\"][\"checkoutErrors\"]\n    assert checkout_errors[0][\"code\"] == CheckoutErrorCode.REQUIRED.name\n\n\ndef test_checkout_create_default_email_for_logged_in_customer(user_api_client, stock):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.id)\n    variables = {\"checkoutInput\": {\"lines\": [{\"quantity\": 1, \"variantId\": variant_id}]}}\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_CREATE, variables)\n    customer = user_api_client.user\n    content = get_graphql_content(response)\n    new_checkout = Checkout.objects.first()\n    assert new_checkout is not None\n    checkout_data = content[\"data\"][\"checkoutCreate\"][\"checkout\"]\n    assert checkout_data[\"email\"] == str(customer.email)\n    assert new_checkout.user.id == customer.id\n    assert new_checkout.email == customer.email\n\n\ndef test_checkout_create_logged_in_customer(user_api_client, stock):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.id)\n    variables = {\n        \"checkoutInput\": {\n            \"email\": user_api_client.user.email,\n            \"lines\": [{\"quantity\": 1, \"variantId\": variant_id}],\n        }\n    }\n    assert not Checkout.objects.exists()\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_CREATE, variables)\n    content = get_graphql_content(response)\n    new_checkout = Checkout.objects.first()\n    assert new_checkout is not None\n    checkout_data = content[\"data\"][\"checkoutCreate\"][\"checkout\"]\n    assert checkout_data[\"token\"] == str(new_checkout.token)\n    checkout_user = new_checkout.user\n    customer = user_api_client.user\n    assert customer.id == checkout_user.id\n    assert customer.default_shipping_address_id != new_checkout.shipping_address_id\n    assert (\n        customer.default_shipping_address.as_data()\n        == new_checkout.shipping_address.as_data()\n    )\n    assert customer.default_billing_address_id != new_checkout.billing_address_id\n    assert (\n        customer.default_billing_address.as_data()\n        == new_checkout.billing_address.as_data()\n    )\n    assert customer.email == new_checkout.email\n\n\ndef test_checkout_create_logged_in_customer_custom_email(user_api_client, stock):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.id)\n    customer = user_api_client.user\n    custom_email = \"custom@example.com\"\n    variables = {\n        \"checkoutInput\": {\n            \"lines\": [{\"quantity\": 1, \"variantId\": variant_id}],\n            \"email\": custom_email,\n        }\n    }\n    assert not Checkout.objects.exists()\n    assert not custom_email == customer.email\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_CREATE, variables)\n    content = get_graphql_content(response)\n    new_checkout = Checkout.objects.first()\n    assert new_checkout is not None\n    checkout_data = content[\"data\"][\"checkoutCreate\"][\"checkout\"]\n    assert checkout_data[\"token\"] == str(new_checkout.token)\n    checkout_user = new_checkout.user\n    assert customer.id == checkout_user.id\n    assert new_checkout.email == custom_email\n\n\ndef test_checkout_create_logged_in_customer_custom_addresses(\n    user_api_client, stock, graphql_address_data\n):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.id)\n    shipping_address = graphql_address_data\n    billing_address = graphql_address_data\n    variables = {\n        \"checkoutInput\": {\n            \"email\": user_api_client.user.email,\n            \"lines\": [{\"quantity\": 1, \"variantId\": variant_id}],\n            \"shippingAddress\": shipping_address,\n            \"billingAddress\": billing_address,\n        }\n    }\n    assert not Checkout.objects.exists()\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_CREATE, variables)\n    content = get_graphql_content(response)\n    new_checkout = Checkout.objects.first()\n    assert new_checkout is not None\n    checkout_data = content[\"data\"][\"checkoutCreate\"][\"checkout\"]\n    assert checkout_data[\"token\"] == str(new_checkout.token)\n    checkout_user = new_checkout.user\n    customer = user_api_client.user\n    assert customer.id == checkout_user.id\n    assert not (\n        customer.default_shipping_address_id == new_checkout.shipping_address_id\n    )\n    assert not (customer.default_billing_address_id == new_checkout.billing_address_id)\n    assert new_checkout.shipping_address.first_name == shipping_address[\"firstName\"]\n    assert new_checkout.billing_address.first_name == billing_address[\"firstName\"]\n\n\ndef test_checkout_create_check_lines_quantity(\n    user_api_client, stock, graphql_address_data\n):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.id)\n    test_email = \"test@example.com\"\n    shipping_address = graphql_address_data\n    variables = {\n        \"checkoutInput\": {\n            \"lines\": [{\"quantity\": 3, \"variantId\": variant_id}],\n            \"email\": test_email,\n            \"shippingAddress\": shipping_address,\n        }\n    }\n    assert not Checkout.objects.exists()\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_CREATE, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutCreate\"]\n    assert data[\"errors\"][0][\"message\"] == (\n        \"Could not add item Test product (SKU_A). Only 2 remaining in stock.\"\n    )\n    assert data[\"errors\"][0][\"field\"] == \"quantity\"\n\n\n@pytest.fixture\ndef expected_dummy_gateway():\n    return {\n        \"name\": \"Dummy\",\n        \"config\": [{\"field\": \"store_customer_card\", \"value\": \"false\"}],\n    }\n\n\ndef test_checkout_available_payment_gateways(\n    api_client, checkout_with_item, expected_dummy_gateway\n):\n    query = \"\"\"\n    query getCheckout($token: UUID!) {\n        checkout(token: $token) {\n           availablePaymentGateways {\n               name\n               config {\n                   field\n                   value\n               }\n           }\n        }\n    }\n    \"\"\"\n    variables = {\"token\": str(checkout_with_item.token)}\n    response = api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkout\"]\n    assert data[\"availablePaymentGateways\"] == [expected_dummy_gateway]\n\n\ndef test_checkout_available_shipping_methods(\n    api_client, checkout_with_item, address, shipping_zone\n):\n    checkout_with_item.shipping_address = address\n    checkout_with_item.save()\n\n    query = \"\"\"\n    query getCheckout($token: UUID!) {\n        checkout(token: $token) {\n            availableShippingMethods {\n                name\n            }\n        }\n    }\n    \"\"\"\n    variables = {\"token\": checkout_with_item.token}\n    response = api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkout\"]\n\n    shipping_method = shipping_zone.shipping_methods.first()\n    assert data[\"availableShippingMethods\"] == [{\"name\": shipping_method.name}]\n\n\n@pytest.mark.parametrize(\n    \"expected_price_type, expected_price, display_gross_prices\",\n    ((\"gross\", 13, True), (\"net\", 10, False)),\n)\ndef test_checkout_available_shipping_methods_with_price_displayed(\n    expected_price_type,\n    expected_price,\n    display_gross_prices,\n    monkeypatch,\n    api_client,\n    checkout_with_item,\n    address,\n    shipping_zone,\n    site_settings,\n):\n    shipping_method = shipping_zone.shipping_methods.first()\n    taxed_price = TaxedMoney(net=Money(10, \"USD\"), gross=Money(13, \"USD\"))\n    apply_taxes_to_shipping_mock = mock.Mock(return_value=taxed_price)\n    monkeypatch.setattr(\n        ExtensionsManager, \"apply_taxes_to_shipping\", apply_taxes_to_shipping_mock\n    )\n    site_settings.display_gross_prices = display_gross_prices\n    site_settings.save()\n    checkout_with_item.shipping_address = address\n    checkout_with_item.save()\n\n    query = \"\"\"\n    query getCheckout($token: UUID!) {\n        checkout(token: $token) {\n            availableShippingMethods {\n                name\n                price {\n                    amount\n                }\n            }\n        }\n    }\n    \"\"\"\n    variables = {\"token\": checkout_with_item.token}\n    response = api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkout\"]\n\n    apply_taxes_to_shipping_mock.assert_called_once_with(\n        shipping_method.price, mock.ANY\n    )\n    assert data[\"availableShippingMethods\"] == [\n        {\"name\": \"DHL\", \"price\": {\"amount\": expected_price}}\n    ]\n\n\ndef test_checkout_no_available_shipping_methods_without_address(\n    api_client, checkout_with_item\n):\n    query = \"\"\"\n    query getCheckout($token: UUID!) {\n        checkout(token: $token) {\n            availableShippingMethods {\n                name\n            }\n        }\n    }\n    \"\"\"\n    variables = {\"token\": checkout_with_item.token}\n    response = api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkout\"]\n\n    assert data[\"availableShippingMethods\"] == []\n\n\ndef test_checkout_no_available_shipping_methods_without_lines(api_client, checkout):\n    query = \"\"\"\n    query getCheckout($token: UUID!) {\n        checkout(token: $token) {\n            availableShippingMethods {\n                name\n            }\n        }\n    }\n    \"\"\"\n    variables = {\"token\": checkout.token}\n    response = api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkout\"]\n\n    assert data[\"availableShippingMethods\"] == []\n\n\nMUTATION_CHECKOUT_LINES_ADD = \"\"\"\n    mutation checkoutLinesAdd(\n            $checkoutId: ID!, $lines: [CheckoutLineInput!]!) {\n        checkoutLinesAdd(checkoutId: $checkoutId, lines: $lines) {\n            checkout {\n                token\n                lines {\n                    quantity\n                    variant {\n                        id\n                    }\n                }\n            }\n            errors {\n                field\n                message\n            }\n        }\n    }\"\"\"\n\n\n@mock.patch(\n    \"saleor.graphql.checkout.mutations.update_checkout_shipping_method_if_invalid\",\n    wraps=update_checkout_shipping_method_if_invalid,\n)\ndef test_checkout_lines_add(\n    mocked_update_shipping_method, user_api_client, checkout_with_item, stock\n):\n    variant = stock.product_variant\n    checkout = checkout_with_item\n    line = checkout.lines.first()\n    assert line.quantity == 3\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.pk)\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    variables = {\n        \"checkoutId\": checkout_id,\n        \"lines\": [{\"variantId\": variant_id, \"quantity\": 1}],\n    }\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_ADD, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutLinesAdd\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    line = checkout.lines.latest(\"pk\")\n    assert line.variant == variant\n    assert line.quantity == 1\n\n    mocked_update_shipping_method.assert_called_once_with(checkout, mock.ANY)\n\n\ndef test_checkout_lines_add_too_many(user_api_client, checkout_with_item, stock):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.pk)\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout_with_item.pk)\n\n    variables = {\n        \"checkoutId\": checkout_id,\n        \"lines\": [{\"variantId\": variant_id, \"quantity\": 51}],\n    }\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_ADD, variables)\n    content = get_graphql_content(response)[\"data\"][\"checkoutLinesAdd\"]\n\n    assert content[\"errors\"]\n    assert content[\"errors\"] == [\n        {\"field\": \"quantity\", \"message\": \"Cannot add more than 50 times this item.\"}\n    ]\n\n\ndef test_checkout_lines_add_empty_checkout(user_api_client, checkout, stock):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.pk)\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    variables = {\n        \"checkoutId\": checkout_id,\n        \"lines\": [{\"variantId\": variant_id, \"quantity\": 1}],\n    }\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_ADD, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutLinesAdd\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    line = checkout.lines.first()\n    assert line.variant == variant\n    assert line.quantity == 1\n\n\ndef test_checkout_lines_add_check_lines_quantity(user_api_client, checkout, stock):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.pk)\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    variables = {\n        \"checkoutId\": checkout_id,\n        \"lines\": [{\"variantId\": variant_id, \"quantity\": 3}],\n    }\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_ADD, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutLinesAdd\"]\n    assert data[\"errors\"][0][\"message\"] == (\n        \"Could not add item Test product (SKU_A). Only 2 remaining in stock.\"\n    )\n    assert data[\"errors\"][0][\"field\"] == \"quantity\"\n\n\ndef test_checkout_lines_invalid_variant_id(user_api_client, checkout, stock):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.pk)\n    invalid_variant_id = \"InvalidId\"\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    variables = {\n        \"checkoutId\": checkout_id,\n        \"lines\": [\n            {\"variantId\": variant_id, \"quantity\": 1},\n            {\"variantId\": invalid_variant_id, \"quantity\": 3},\n        ],\n    }\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_ADD, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutLinesAdd\"]\n    error_msg = \"Could not resolve to a node with the global id list of '%s'.\"\n    assert data[\"errors\"][0][\"message\"] == error_msg % [invalid_variant_id]\n    assert data[\"errors\"][0][\"field\"] == \"variantId\"\n\n\nMUTATION_CHECKOUT_LINES_UPDATE = \"\"\"\n    mutation checkoutLinesUpdate(\n            $checkoutId: ID!, $lines: [CheckoutLineInput!]!) {\n        checkoutLinesUpdate(checkoutId: $checkoutId, lines: $lines) {\n            checkout {\n                token\n                lines {\n                    quantity\n                    variant {\n                        id\n                    }\n                }\n            }\n            errors {\n                field\n                message\n            }\n        }\n    }\n    \"\"\"\n\n\n@mock.patch(\n    \"saleor.graphql.checkout.mutations.update_checkout_shipping_method_if_invalid\",\n    wraps=update_checkout_shipping_method_if_invalid,\n)\ndef test_checkout_lines_update(\n    mocked_update_shipping_method, user_api_client, checkout_with_item\n):\n    checkout = checkout_with_item\n    assert checkout.lines.count() == 1\n    line = checkout.lines.first()\n    variant = line.variant\n    assert line.quantity == 3\n\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.pk)\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    variables = {\n        \"checkoutId\": checkout_id,\n        \"lines\": [{\"variantId\": variant_id, \"quantity\": 1}],\n    }\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_UPDATE, variables)\n    content = get_graphql_content(response)\n\n    data = content[\"data\"][\"checkoutLinesUpdate\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    assert checkout.lines.count() == 1\n    line = checkout.lines.first()\n    assert line.variant == variant\n    assert line.quantity == 1\n\n    mocked_update_shipping_method.assert_called_once_with(checkout, mock.ANY)\n\n\ndef test_checkout_lines_update_invalid_checkout_id(user_api_client):\n    variables = {\"checkoutId\": \"test\", \"lines\": []}\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_UPDATE, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutLinesUpdate\"]\n    assert data[\"errors\"][0][\"field\"] == \"checkoutId\"\n\n\ndef test_checkout_lines_update_check_lines_quantity(\n    user_api_client, checkout_with_item\n):\n    checkout = checkout_with_item\n    line = checkout.lines.first()\n    variant = line.variant\n\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.pk)\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    variables = {\n        \"checkoutId\": checkout_id,\n        \"lines\": [{\"variantId\": variant_id, \"quantity\": 10}],\n    }\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_UPDATE, variables)\n    content = get_graphql_content(response)\n\n    data = content[\"data\"][\"checkoutLinesUpdate\"]\n    assert data[\"errors\"][0][\"message\"] == (\n        \"Could not add item Test product (123). Only 9 remaining in stock.\"\n    )\n    assert data[\"errors\"][0][\"field\"] == \"quantity\"\n\n\ndef test_checkout_lines_update_with_chosen_shipping(\n    user_api_client, checkout, stock, address, shipping_method\n):\n    checkout.shipping_address = address\n    checkout.shipping_method = shipping_method\n    checkout.save()\n\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.pk)\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    variables = {\n        \"checkoutId\": checkout_id,\n        \"lines\": [{\"variantId\": variant_id, \"quantity\": 1}],\n    }\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_UPDATE, variables)\n    content = get_graphql_content(response)\n\n    data = content[\"data\"][\"checkoutLinesUpdate\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    assert checkout.quantity == 1\n\n\nMUTATION_CHECKOUT_LINES_DELETE = \"\"\"\n    mutation checkoutLineDelete($checkoutId: ID!, $lineId: ID!) {\n        checkoutLineDelete(checkoutId: $checkoutId, lineId: $lineId) {\n            checkout {\n                token\n                lines {\n                    quantity\n                    variant {\n                        id\n                    }\n                }\n            }\n            errors {\n                field\n                message\n            }\n        }\n    }\n\"\"\"\n\n\n@mock.patch(\n    \"saleor.graphql.checkout.mutations.update_checkout_shipping_method_if_invalid\",\n    wraps=update_checkout_shipping_method_if_invalid,\n)\ndef test_checkout_line_delete(\n    mocked_update_shipping_method, user_api_client, checkout_with_item\n):\n    checkout = checkout_with_item\n    assert checkout.lines.count() == 1\n    line = checkout.lines.first()\n    assert line.quantity == 3\n\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n    line_id = graphene.Node.to_global_id(\"CheckoutLine\", line.pk)\n\n    variables = {\"checkoutId\": checkout_id, \"lineId\": line_id}\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_DELETE, variables)\n    content = get_graphql_content(response)\n\n    data = content[\"data\"][\"checkoutLineDelete\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    assert checkout.lines.count() == 0\n    mocked_update_shipping_method.assert_called_once_with(checkout, mock.ANY)\n\n\n@mock.patch(\n    \"saleor.graphql.checkout.mutations.update_checkout_shipping_method_if_invalid\",\n    wraps=update_checkout_shipping_method_if_invalid,\n)\ndef test_checkout_line_delete_by_zero_quantity(\n    mocked_update_shipping_method, user_api_client, checkout_with_item\n):\n    checkout = checkout_with_item\n    assert checkout.lines.count() == 1\n    line = checkout.lines.first()\n    variant = line.variant\n    assert line.quantity == 3\n\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.pk)\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    variables = {\n        \"checkoutId\": checkout_id,\n        \"lines\": [{\"variantId\": variant_id, \"quantity\": 0}],\n    }\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_UPDATE, variables)\n    content = get_graphql_content(response)\n\n    data = content[\"data\"][\"checkoutLinesUpdate\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    assert checkout.lines.count() == 0\n    mocked_update_shipping_method.assert_called_once_with(checkout, mock.ANY)\n\n\ndef test_checkout_customer_attach(user_api_client, checkout_with_item, customer_user):\n    checkout = checkout_with_item\n    assert checkout.user is None\n\n    query = \"\"\"\n        mutation checkoutCustomerAttach($checkoutId: ID!, $customerId: ID!) {\n            checkoutCustomerAttach(\n                    checkoutId: $checkoutId, customerId: $customerId) {\n                checkout {\n                    token\n                }\n                errors {\n                    field\n                    message\n                }\n            }\n        }\n    \"\"\"\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n    customer_id = graphene.Node.to_global_id(\"User\", customer_user.pk)\n\n    variables = {\"checkoutId\": checkout_id, \"customerId\": customer_id}\n    response = user_api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n\n    data = content[\"data\"][\"checkoutCustomerAttach\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    assert checkout.user == customer_user\n\n\nMUTATION_CHECKOUT_CUSTOMER_DETACH = \"\"\"\n    mutation checkoutCustomerDetach($checkoutId: ID!) {\n        checkoutCustomerDetach(checkoutId: $checkoutId) {\n            checkout {\n                token\n            }\n            errors {\n                field\n                message\n            }\n        }\n    }\n    \"\"\"\n\n\ndef test_checkout_customer_detach(user_api_client, checkout_with_item, customer_user):\n    checkout = checkout_with_item\n    checkout.user = customer_user\n    checkout.save(update_fields=[\"user\"])\n\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n    variables = {\"checkoutId\": checkout_id}\n    response = user_api_client.post_graphql(\n        MUTATION_CHECKOUT_CUSTOMER_DETACH, variables\n    )\n    content = get_graphql_content(response)\n\n    data = content[\"data\"][\"checkoutCustomerDetach\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    assert checkout.user is None\n\n\nMUTATION_CHECKOUT_SHIPPING_ADDRESS_UPDATE = \"\"\"\n    mutation checkoutShippingAddressUpdate(\n            $checkoutId: ID!, $shippingAddress: AddressInput!) {\n        checkoutShippingAddressUpdate(\n                checkoutId: $checkoutId, shippingAddress: $shippingAddress) {\n            checkout {\n                token,\n                id\n            },\n            errors {\n                field,\n                message,\n            }\n            checkoutErrors {\n                field\n                message\n                code\n            }\n        }\n    }\"\"\"\n\n\n@mock.patch(\n    \"saleor.graphql.checkout.mutations.update_checkout_shipping_method_if_invalid\",\n    wraps=update_checkout_shipping_method_if_invalid,\n)\ndef test_checkout_shipping_address_update(\n    mocked_update_shipping_method,\n    user_api_client,\n    checkout_with_item,\n    graphql_address_data,\n):\n    checkout = checkout_with_item\n    assert checkout.shipping_address is None\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    shipping_address = graphql_address_data\n    variables = {\"checkoutId\": checkout_id, \"shippingAddress\": shipping_address}\n\n    response = user_api_client.post_graphql(\n        MUTATION_CHECKOUT_SHIPPING_ADDRESS_UPDATE, variables\n    )\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutShippingAddressUpdate\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    assert checkout.shipping_address is not None\n    assert checkout.shipping_address.first_name == shipping_address[\"firstName\"]\n    assert checkout.shipping_address.last_name == shipping_address[\"lastName\"]\n    assert (\n        checkout.shipping_address.street_address_1 == shipping_address[\"streetAddress1\"]\n    )\n    assert (\n        checkout.shipping_address.street_address_2 == shipping_address[\"streetAddress2\"]\n    )\n    assert checkout.shipping_address.postal_code == shipping_address[\"postalCode\"]\n    assert checkout.shipping_address.country == shipping_address[\"country\"]\n    assert checkout.shipping_address.city == shipping_address[\"city\"].upper()\n    mocked_update_shipping_method.assert_called_once_with(checkout, mock.ANY)\n\n\ndef test_checkout_shipping_address_with_invalid_phone_number_returns_error(\n    user_api_client, checkout_with_item, graphql_address_data\n):\n    checkout = checkout_with_item\n    assert checkout.shipping_address is None\n\n    shipping_address = graphql_address_data\n    shipping_address[\"phone\"] = \"+33600000\"\n\n    response = get_graphql_content(\n        user_api_client.post_graphql(\n            MUTATION_CHECKOUT_SHIPPING_ADDRESS_UPDATE,\n            {\n                \"checkoutId\": graphene.Node.to_global_id(\"Checkout\", checkout.pk),\n                \"shippingAddress\": shipping_address,\n            },\n        )\n    )[\"data\"][\"checkoutShippingAddressUpdate\"]\n    assert response[\"errors\"] == [\n        {\"field\": \"phone\", \"message\": \"'+33600000' is not a valid phone number.\"}\n    ]\n    assert response[\"checkoutErrors\"] == [\n        {\n            \"field\": \"phone\",\n            \"message\": \"'+33600000' is not a valid phone number.\",\n            \"code\": CheckoutErrorCode.INVALID.name,\n        }\n    ]\n\n\n@pytest.mark.parametrize(\n    \"number\", [\"+48321321888\", \"+44 (113) 892-1113\", \"00 44 (0) 20 7839 1377\"]\n)\ndef test_checkout_shipping_address_update_with_phone_country_prefix(\n    number, user_api_client, checkout_with_item, graphql_address_data\n):\n    checkout = checkout_with_item\n    assert checkout.shipping_address is None\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    shipping_address = graphql_address_data\n    shipping_address[\"phone\"] = number\n    variables = {\"checkoutId\": checkout_id, \"shippingAddress\": shipping_address}\n\n    response = user_api_client.post_graphql(\n        MUTATION_CHECKOUT_SHIPPING_ADDRESS_UPDATE, variables\n    )\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutShippingAddressUpdate\"]\n    assert not data[\"errors\"]\n\n\ndef test_checkout_shipping_address_update_without_phone_country_prefix(\n    user_api_client, checkout_with_item, graphql_address_data\n):\n    checkout = checkout_with_item\n    assert checkout.shipping_address is None\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    shipping_address = graphql_address_data\n    shipping_address[\"phone\"] = \"+1-202-555-0132\"\n    variables = {\"checkoutId\": checkout_id, \"shippingAddress\": shipping_address}\n\n    response = user_api_client.post_graphql(\n        MUTATION_CHECKOUT_SHIPPING_ADDRESS_UPDATE, variables\n    )\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutShippingAddressUpdate\"]\n    assert not data[\"errors\"]\n\n\ndef test_checkout_billing_address_update(\n    user_api_client, checkout_with_item, graphql_address_data\n):\n    checkout = checkout_with_item\n    assert checkout.shipping_address is None\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    query = \"\"\"\n    mutation checkoutBillingAddressUpdate(\n            $checkoutId: ID!, $billingAddress: AddressInput!) {\n        checkoutBillingAddressUpdate(\n                checkoutId: $checkoutId, billingAddress: $billingAddress) {\n            checkout {\n                token,\n                id\n            },\n            errors {\n                field,\n                message\n            }\n        }\n    }\n    \"\"\"\n    billing_address = graphql_address_data\n\n    variables = {\"checkoutId\": checkout_id, \"billingAddress\": billing_address}\n\n    response = user_api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutBillingAddressUpdate\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    assert checkout.billing_address is not None\n    assert checkout.billing_address.first_name == billing_address[\"firstName\"]\n    assert checkout.billing_address.last_name == billing_address[\"lastName\"]\n    assert (\n        checkout.billing_address.street_address_1 == billing_address[\"streetAddress1\"]\n    )\n    assert (\n        checkout.billing_address.street_address_2 == billing_address[\"streetAddress2\"]\n    )\n    assert checkout.billing_address.postal_code == billing_address[\"postalCode\"]\n    assert checkout.billing_address.country == billing_address[\"country\"]\n    assert checkout.billing_address.city == billing_address[\"city\"].upper()\n\n\nCHECKOUT_EMAIL_UPDATE_MUTATION = \"\"\"\n    mutation checkoutEmailUpdate($checkoutId: ID!, $email: String!) {\n        checkoutEmailUpdate(checkoutId: $checkoutId, email: $email) {\n            checkout {\n                id,\n                email\n            },\n            errors {\n                field,\n                message\n            }\n            checkoutErrors {\n                field,\n                message\n                code\n            }\n        }\n    }\n\"\"\"\n\n\ndef test_checkout_email_update(user_api_client, checkout_with_item):\n    checkout = checkout_with_item\n    assert not checkout.email\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    email = \"test@example.com\"\n    variables = {\"checkoutId\": checkout_id, \"email\": email}\n\n    response = user_api_client.post_graphql(CHECKOUT_EMAIL_UPDATE_MUTATION, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutEmailUpdate\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    assert checkout.email == email\n\n\ndef test_checkout_email_update_validation(user_api_client, checkout_with_item):\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout_with_item.pk)\n    variables = {\"checkoutId\": checkout_id, \"email\": \"\"}\n\n    response = user_api_client.post_graphql(CHECKOUT_EMAIL_UPDATE_MUTATION, variables)\n    content = get_graphql_content(response)\n\n    errors = content[\"data\"][\"checkoutEmailUpdate\"][\"errors\"]\n    assert errors\n    assert errors[0][\"field\"] == \"email\"\n    assert errors[0][\"message\"] == \"This field cannot be blank.\"\n\n    checkout_errors = content[\"data\"][\"checkoutEmailUpdate\"][\"checkoutErrors\"]\n    assert checkout_errors[0][\"code\"] == CheckoutErrorCode.REQUIRED.name\n\n\nMUTATION_CHECKOUT_COMPLETE = \"\"\"\n    mutation checkoutComplete($checkoutId: ID!, $redirectUrl: String) {\n        checkoutComplete(checkoutId: $checkoutId, redirectUrl: $redirectUrl) {\n            order {\n                id,\n                token\n            },\n            errors {\n                field,\n                message\n            }\n        }\n    }\n    \"\"\"\n\n\n@pytest.mark.integration\ndef test_checkout_complete(\n    user_api_client,\n    checkout_with_gift_card,\n    gift_card,\n    payment_dummy,\n    address,\n    shipping_method,\n):\n\n    assert not gift_card.last_used_on\n\n    checkout = checkout_with_gift_card\n    checkout.shipping_address = address\n    checkout.shipping_method = shipping_method\n    checkout.billing_address = address\n    checkout.store_meta(namespace=\"PUBLIC\", client=\"PLUGIN\", item={\"accepted\": \"true\"})\n    checkout.store_private_meta(\n        namespace=\"PRIVATE\", client=\"PLUGIN\", item={\"accepted\": \"true\"}\n    )\n    checkout.save()\n\n    checkout_line = checkout.lines.first()\n    checkout_line_quantity = checkout_line.quantity\n    checkout_line_variant = checkout_line.variant\n\n    gift_current_balance = checkout.get_total_gift_cards_balance()\n    total = calculations.checkout_total(checkout)\n    payment = payment_dummy\n    payment.is_active = True\n    payment.order = None\n    payment.total = total.gross.amount\n    payment.currency = total.gross.currency\n    payment.checkout = checkout\n    payment.save()\n    assert not payment.transactions.exists()\n\n    orders_count = Order.objects.count()\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n    variables = {\"checkoutId\": checkout_id, \"redirectUrl\": \"https://www.example.com\"}\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_COMPLETE, variables)\n\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutComplete\"]\n    assert not data[\"errors\"]\n\n    order_token = data[\"order\"][\"token\"]\n    assert Order.objects.count() == orders_count + 1\n    order = Order.objects.first()\n    assert order.token == order_token\n    assert order.total.gross == total.gross - gift_current_balance\n    assert order.meta == checkout.meta\n    assert order.private_meta == checkout.private_meta\n\n    order_line = order.lines.first()\n    assert checkout_line_quantity == order_line.quantity\n    assert checkout_line_variant == order_line.variant\n    assert order.shipping_address == address\n    assert order.shipping_method == checkout.shipping_method\n    assert order.payments.exists()\n    order_payment = order.payments.first()\n    assert order_payment == payment\n    assert payment.transactions.count() == 1\n\n    gift_card.refresh_from_db()\n    assert gift_card.current_balance == zero_money()\n    assert gift_card.last_used_on\n\n    assert not Checkout.objects.filter(\n        pk=checkout.pk\n    ).exists(), \"Checkout should have been deleted\"\n\n\nERROR_GATEWAY_RESPONSE = GatewayResponse(\n    is_success=False,\n    action_required=False,\n    kind=TransactionKind.CAPTURE,\n    amount=Decimal(0),\n    currency=\"usd\",\n    transaction_id=\"1234\",\n    error=\"ERROR\",\n)\n\n\ndef _process_payment_transaction_returns_error(*args, **kwards):\n    return ERROR_GATEWAY_RESPONSE\n\n\ndef _process_payment_raise_error(*args, **kwargs):\n    raise Exception(\"Oops! Something went wrong.\")\n\n\n@pytest.fixture(\n    params=[_process_payment_raise_error, _process_payment_transaction_returns_error]\n)\ndef error_side_effect(request):\n    return request.param\n\n\n@pytest.fixture\ndef fake_manager(mocker):\n    return mocker.Mock(spec=PaymentInterface)\n\n\n@pytest.fixture\ndef mock_get_manager(mocker, fake_manager):\n    mgr = mocker.patch(\n        \"saleor.payment.gateway.get_extensions_manager\",\n        autospec=True,\n        return_value=fake_manager,\n    )\n    yield fake_manager\n    mgr.assert_called_once()\n\n\ndef test_checkout_complete_does_not_delete_checkout_after_unsuccessful_payment(\n    mock_get_manager,\n    error_side_effect,\n    user_api_client,\n    checkout_with_voucher,\n    voucher,\n    payment_dummy,\n    address,\n    shipping_method,\n):\n    mock_get_manager.process_payment.side_effect = error_side_effect\n    expected_voucher_usage_count = voucher.used\n    checkout = checkout_with_voucher\n    checkout.shipping_address = address\n    checkout.shipping_method = shipping_method\n    checkout.billing_address = address\n    checkout.save()\n\n    taxed_total = calculations.checkout_total(checkout)\n    payment = payment_dummy\n    payment.is_active = True\n    payment.order = None\n    payment.total = taxed_total.gross.amount\n    payment.currency = taxed_total.gross.currency\n    payment.checkout = checkout\n    payment.save()\n    assert not payment.transactions.exists()\n\n    orders_count = Order.objects.count()\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n    variables = {\"checkoutId\": checkout_id, \"redirectUrl\": \"https://www.example.com\"}\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_COMPLETE, variables)\n    get_graphql_content(response)\n\n    assert Order.objects.count() == orders_count\n\n    payment.refresh_from_db(fields=[\"order\"])\n    transaction = payment.transactions.get()\n    assert transaction.error\n    assert payment.order is None\n\n    # ensure the voucher usage count was not incremented\n    voucher.refresh_from_db(fields=[\"used\"])\n    assert voucher.used == expected_voucher_usage_count\n\n    assert Checkout.objects.filter(\n        pk=checkout.pk\n    ).exists(), \"Checkout should not have been deleted\"\n\n\ndef test_checkout_complete_invalid_checkout_id(user_api_client):\n    checkout_id = \"invalidId\"\n    variables = {\"checkoutId\": checkout_id, \"redirectUrl\": \"https://www.example.com\"}\n    orders_count = Order.objects.count()\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_COMPLETE, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutComplete\"]\n    assert data[\"errors\"][0][\"message\"] == \"Couldn't resolve to a node: invalidId\"\n    assert data[\"errors\"][0][\"field\"] == \"checkoutId\"\n    assert orders_count == Order.objects.count()\n\n\ndef test_checkout_complete_no_payment(\n    user_api_client, checkout_with_item, address, shipping_method\n):\n    checkout = checkout_with_item\n    checkout.shipping_address = address\n    checkout.shipping_method = shipping_method\n    checkout.billing_address = address\n    checkout.save()\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n    variables = {\"checkoutId\": checkout_id, \"redirectUrl\": \"https://www.example.com\"}\n    orders_count = Order.objects.count()\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_COMPLETE, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutComplete\"]\n    assert data[\"errors\"][0][\"message\"] == (\n        \"Provided payment methods can not cover the checkout's total amount\"\n    )\n    assert orders_count == Order.objects.count()\n\n\ndef test_checkout_complete_insufficient_stock(\n    user_api_client, checkout_with_item, address, payment_dummy, shipping_method\n):\n    checkout = checkout_with_item\n    checkout_line = checkout.lines.first()\n    stock = Stock.objects.get(product_variant=checkout_line.variant)\n    quantity_available = stock.quantity_available\n    checkout_line.quantity = quantity_available + 1\n    checkout_line.save()\n    checkout.shipping_address = address\n    checkout.shipping_method = shipping_method\n    checkout.billing_address = address\n    checkout.save()\n    total = calculations.checkout_total(checkout)\n    payment = payment_dummy\n    payment.is_active = True\n    payment.order = None\n    payment.total = total.gross.amount\n    payment.currency = total.gross.currency\n    payment.checkout = checkout\n    payment.save()\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n    variables = {\"checkoutId\": checkout_id, \"redirectUrl\": \"https://www.example.com\"}\n    orders_count = Order.objects.count()\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_COMPLETE, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutComplete\"]\n    assert data[\"errors\"][0][\"message\"] == \"Insufficient product stock: 123\"\n    assert orders_count == Order.objects.count()\n\n\ndef test_checkout_complete_without_redirect_url(\n    user_api_client,\n    checkout_with_gift_card,\n    gift_card,\n    payment_dummy,\n    address,\n    shipping_method,\n):\n\n    assert not gift_card.last_used_on\n\n    checkout = checkout_with_gift_card\n    checkout.shipping_address = address\n    checkout.shipping_method = shipping_method\n    checkout.billing_address = address\n    checkout.save()\n\n    checkout_line = checkout.lines.first()\n    checkout_line_quantity = checkout_line.quantity\n    checkout_line_variant = checkout_line.variant\n\n    gift_current_balance = checkout.get_total_gift_cards_balance()\n    total = calculations.checkout_total(checkout)\n    payment = payment_dummy\n    payment.is_active = True\n    payment.order = None\n    payment.total = total.gross.amount\n    payment.currency = total.gross.currency\n    payment.checkout = checkout\n    payment.save()\n    assert not payment.transactions.exists()\n\n    orders_count = Order.objects.count()\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n    variables = {\"checkoutId\": checkout_id}\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_COMPLETE, variables)\n\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutComplete\"]\n    assert not data[\"errors\"]\n\n    order_token = data[\"order\"][\"token\"]\n    assert Order.objects.count() == orders_count + 1\n    order = Order.objects.first()\n    assert order.token == order_token\n    assert order.total.gross == total.gross - gift_current_balance\n\n    order_line = order.lines.first()\n    assert checkout_line_quantity == order_line.quantity\n    assert checkout_line_variant == order_line.variant\n    assert order.shipping_address == address\n    assert order.shipping_method == checkout.shipping_method\n    assert order.payments.exists()\n    order_payment = order.payments.first()\n    assert order_payment == payment\n    assert payment.transactions.count() == 1\n\n    gift_card.refresh_from_db()\n    assert gift_card.current_balance == zero_money()\n    assert gift_card.last_used_on\n\n    assert not Checkout.objects.filter(\n        pk=checkout.pk\n    ).exists(), \"Checkout should have been deleted\"\n\n\ndef test_fetch_checkout_by_token(user_api_client, checkout_with_item):\n    query = \"\"\"\n    query getCheckout($token: UUID!) {\n        checkout(token: $token) {\n           token,\n           lines {\n                variant {\n                    product {\n                        name\n                    }\n                }\n           }\n        }\n    }\n    \"\"\"\n    variables = {\"token\": str(checkout_with_item.token)}\n    response = user_api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkout\"]\n    assert data[\"token\"] == str(checkout_with_item.token)\n    assert len(data[\"lines\"]) == checkout_with_item.lines.count()\n\n\ndef test_fetch_checkout_invalid_token(user_api_client):\n    query = \"\"\"\n        query getCheckout($token: UUID!) {\n            checkout(token: $token) {\n                token\n            }\n        }\n    \"\"\"\n    variables = {\"token\": str(uuid.uuid4())}\n    response = user_api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkout\"]\n    assert data is None\n\n\ndef test_checkout_prices(user_api_client, checkout_with_item):\n    query = \"\"\"\n    query getCheckout($token: UUID!) {\n        checkout(token: $token) {\n           token,\n           totalPrice {\n                currency\n                gross {\n                    amount\n                }\n            }\n            subtotalPrice {\n                currency\n                gross {\n                    amount\n                }\n            }\n           lines {\n                totalPrice {\n                    currency\n                    gross {\n                        amount\n                    }\n                }\n           }\n        }\n    }\n    \"\"\"\n    variables = {\"token\": str(checkout_with_item.token)}\n    response = user_api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkout\"]\n    assert data[\"token\"] == str(checkout_with_item.token)\n    assert len(data[\"lines\"]) == checkout_with_item.lines.count()\n    total = calculations.checkout_total(checkout_with_item)\n    assert data[\"totalPrice\"][\"gross\"][\"amount\"] == (total.gross.amount)\n    subtotal = calculations.checkout_subtotal(checkout_with_item)\n    assert data[\"subtotalPrice\"][\"gross\"][\"amount\"] == (subtotal.gross.amount)\n\n\nMUTATION_UPDATE_SHIPPING_METHOD = \"\"\"\n    mutation checkoutShippingMethodUpdate(\n            $checkoutId:ID!, $shippingMethodId:ID!){\n        checkoutShippingMethodUpdate(\n            checkoutId:$checkoutId, shippingMethodId:$shippingMethodId) {\n            errors {\n                field\n                message\n            }\n            checkout {\n                id\n            }\n        }\n    }\n\"\"\"\n\n\n@pytest.mark.parametrize(\"is_valid_shipping_method\", (True, False))\n@patch(\"saleor.graphql.checkout.mutations.clean_shipping_method\")\ndef test_checkout_shipping_method_update(\n    mock_clean_shipping,\n    staff_api_client,\n    shipping_method,\n    checkout_with_item,\n    is_valid_shipping_method,\n):\n    checkout = checkout_with_item\n    query = MUTATION_UPDATE_SHIPPING_METHOD\n    mock_clean_shipping.return_value = is_valid_shipping_method\n\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n    method_id = graphene.Node.to_global_id(\"ShippingMethod\", shipping_method.id)\n\n    response = staff_api_client.post_graphql(\n        query, {\"checkoutId\": checkout_id, \"shippingMethodId\": method_id}\n    )\n    data = get_graphql_content(response)[\"data\"][\"checkoutShippingMethodUpdate\"]\n\n    checkout.refresh_from_db()\n\n    mock_clean_shipping.assert_called_once_with(\n        checkout=checkout, method=shipping_method, discounts=ANY\n    )\n\n    if is_valid_shipping_method:\n        assert not data[\"errors\"]\n        assert data[\"checkout\"][\"id\"] == checkout_id\n        assert checkout.shipping_method == shipping_method\n    else:\n        assert data[\"errors\"] == [\n            {\n                \"field\": \"shippingMethod\",\n                \"message\": \"This shipping method is not applicable.\",\n            }\n        ]\n        assert checkout.shipping_method is None\n\n\ndef test_query_checkout_line(checkout_with_item, user_api_client):\n    query = \"\"\"\n    query checkoutLine($id: ID) {\n        checkoutLine(id: $id) {\n            id\n        }\n    }\n    \"\"\"\n    checkout = checkout_with_item\n    line = checkout.lines.first()\n    line_id = graphene.Node.to_global_id(\"CheckoutLine\", line.pk)\n    variables = {\"id\": line_id}\n    response = user_api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    received_id = content[\"data\"][\"checkoutLine\"][\"id\"]\n    assert received_id == line_id\n\n\ndef test_query_checkouts(\n    checkout_with_item, staff_api_client, permission_manage_orders\n):\n    query = \"\"\"\n    {\n        checkouts(first: 20) {\n            edges {\n                node {\n                    token\n                }\n            }\n        }\n    }\n    \"\"\"\n    checkout = checkout_with_item\n    response = staff_api_client.post_graphql(\n        query, {}, permissions=[permission_manage_orders]\n    )\n    content = get_graphql_content(response)\n    received_checkout = content[\"data\"][\"checkouts\"][\"edges\"][0][\"node\"]\n    assert str(checkout.token) == received_checkout[\"token\"]\n\n\ndef test_query_checkout_lines(\n    checkout_with_item, staff_api_client, permission_manage_orders\n):\n    query = \"\"\"\n    {\n        checkoutLines(first: 20) {\n            edges {\n                node {\n                    id\n                }\n            }\n        }\n    }\n    \"\"\"\n    checkout = checkout_with_item\n    response = staff_api_client.post_graphql(\n        query, permissions=[permission_manage_orders]\n    )\n    content = get_graphql_content(response)\n    lines = content[\"data\"][\"checkoutLines\"][\"edges\"]\n    checkout_lines_ids = [line[\"node\"][\"id\"] for line in lines]\n    expected_lines_ids = [\n        graphene.Node.to_global_id(\"CheckoutLine\", item.pk) for item in checkout\n    ]\n    assert expected_lines_ids == checkout_lines_ids\n\n\ndef test_clean_checkout(checkout_with_item, payment_dummy, address, shipping_method):\n    checkout = checkout_with_item\n    checkout.shipping_address = address\n    checkout.shipping_method = shipping_method\n    checkout.billing_address = address\n    checkout.save()\n    total = calculations.checkout_total(checkout)\n    payment = payment_dummy\n    payment.is_active = True\n    payment.order = None\n    payment.total = total.gross.amount\n    payment.currency = total.gross.currency\n    payment.checkout = checkout\n    payment.save()\n    # Shouldn't raise any errors\n    clean_checkout(checkout, None)\n\n\ndef test_clean_checkout_no_shipping_method(checkout_with_item, address):\n    checkout = checkout_with_item\n    checkout.shipping_address = address\n    checkout.save()\n\n    with pytest.raises(ValidationError) as e:\n        clean_checkout(checkout, None)\n\n    msg = \"Shipping method is not set\"\n    assert e.value.error_list[0].message == msg\n\n\ndef test_clean_checkout_no_shipping_address(checkout_with_item, shipping_method):\n    checkout = checkout_with_item\n    checkout.shipping_method = shipping_method\n    checkout.save()\n\n    with pytest.raises(ValidationError) as e:\n        clean_checkout(checkout, None)\n    msg = \"Shipping address is not set\"\n    assert e.value.error_list[0].message == msg\n\n\ndef test_clean_checkout_invalid_shipping_method(\n    checkout_with_item, address, shipping_zone_without_countries\n):\n    checkout = checkout_with_item\n    checkout.shipping_address = address\n    shipping_method = shipping_zone_without_countries.shipping_methods.first()\n    checkout.shipping_method = shipping_method\n    checkout.save()\n\n    with pytest.raises(ValidationError) as e:\n        clean_checkout(checkout, None)\n\n    msg = \"Shipping method is not valid for your shipping address\"\n    assert e.value.error_list[0].message == msg\n\n\ndef test_clean_checkout_no_billing_address(\n    checkout_with_item, address, shipping_method\n):\n    checkout = checkout_with_item\n    checkout.shipping_address = address\n    checkout.shipping_method = shipping_method\n    checkout.save()\n\n    with pytest.raises(ValidationError) as e:\n        clean_checkout(checkout, None)\n    msg = \"Billing address is not set\"\n    assert e.value.error_list[0].message == msg\n\n\ndef test_clean_checkout_no_payment(checkout_with_item, shipping_method, address):\n    checkout = checkout_with_item\n    checkout.shipping_address = address\n    checkout.shipping_method = shipping_method\n    checkout.billing_address = address\n    checkout.save()\n\n    with pytest.raises(ValidationError) as e:\n        clean_checkout(checkout, None)\n\n    msg = \"Provided payment methods can not cover the checkout's total amount\"\n    assert e.value.error_list[0].message == msg\n\n\ndef test_is_fully_paid(checkout_with_item, payment_dummy):\n    checkout = checkout_with_item\n    total = calculations.checkout_total(checkout)\n    payment = payment_dummy\n    payment.is_active = True\n    payment.order = None\n    payment.total = total.gross.amount\n    payment.currency = total.gross.currency\n    payment.checkout = checkout\n    payment.save()\n    is_paid = is_fully_paid(checkout, None)\n    assert is_paid\n\n\ndef test_is_fully_paid_many_payments(checkout_with_item, payment_dummy):\n    checkout = checkout_with_item\n    total = calculations.checkout_total(checkout)\n    payment = payment_dummy\n    payment.is_active = True\n    payment.order = None\n    payment.total = total.gross.amount - 1\n    payment.currency = total.gross.currency\n    payment.checkout = checkout\n    payment.save()\n    payment2 = payment_dummy\n    payment2.pk = None\n    payment2.is_active = True\n    payment2.order = None\n    payment2.total = 1\n    payment2.currency = total.gross.currency\n    payment2.checkout = checkout\n    payment2.save()\n    is_paid = is_fully_paid(checkout, None)\n    assert is_paid\n\n\ndef test_is_fully_paid_partially_paid(checkout_with_item, payment_dummy):\n    checkout = checkout_with_item\n    total = calculations.checkout_total(checkout)\n    payment = payment_dummy\n    payment.is_active = True\n    payment.order = None\n    payment.total = total.gross.amount - 1\n    payment.currency = total.gross.currency\n    payment.checkout = checkout\n    payment.save()\n    is_paid = is_fully_paid(checkout, None)\n    assert not is_paid\n\n\ndef test_is_fully_paid_no_payment(checkout_with_item):\n    checkout = checkout_with_item\n    is_paid = is_fully_paid(checkout, None)\n    assert not is_paid\n"], "fixing_code": ["# Changelog\n\nAll notable, unreleased changes to this project will be documented in this file. For the released changes, please visit the [Releases](https://github.com/mirumee/saleor/releases) page.\n\n## [Unreleased]\n\n- Account confirmation email - #5126 by @tomaszszymanski129\n- Relocate Checkout and CheckoutLine methods into separate module and update checkout related plugins to use them - #4980 by @krzysztofwolski\n- Fix problem with free shipping voucher - #4942 by @IKarbowiak\n- Add sub-categories to random data - #4949 by @IKarbowiak\n- Deprecate `localized` field in Money type - #4952 by @IKarbowiak\n- Fix for shipping api doesn't apply taxes - #4913 by @kswiatek92\n- Query object translation with only manage_translation permission - #4914 by @fowczarek\n- Add customer note to draft orders api - #4973 by @IKarbowiak\n- Allow to delete category and leave products - #4970 by @IKarbowiak\n- Remove thumbnail generation from migration - #3494 by @kswiatek92\n- Rename 'shipping_date' field in fulfillment model to 'created' - #2433 by @kswiatek92\n- Reduce number of queries for 'completeCheckout' mutation - #4989 by @IKarbowiak\n- Now force pytest to ignore the environment variable containing the django settings module - #4992 by @NyanKiyoshi\n- Extend JWT token payload with user information - #4987 by @salwator\n- Optimize the queries for product list in the dashboard - #4995 by @IKarbowiak\n- Drop dashboard 1.0 - #5000 by @IKarbowiak\n- Fixed serialization error on weight fields when running `loaddata` and `dumpdb` - #5005 by @NyanKiyoshi\n- Fixed JSON encoding error on Google Analytics reporting - #5004 by @NyanKiyoshi\n- Create custom field to translation, use new translation types in translations query - #5007 by @fowczarek\n- Take allocated stock in account in `StockAvailability` filter - #5019 by @simonbru\n- Generate matching postal codes for US addresses - #5033 by @maarcingebala\n- Update debug toolbar - #5032 by @IKarbowiak\n- Allow staff member to receive notification about customers orders - #4993 by @kswiatek92\n- JWT payload now contains user global id - #5039 by @salwator\n- Made middleware path resolving lazy and refactored middleware names - #5041 by @NyanKiyoshi\n- Generate slug in attribute value save - #5055 by @fowczarek\n- Fix order status after order update - #5072 by @fowczarek\n- Extend top-level connection resolvers with ability to sort results - #5018 by @fowczarek\n- Drop storefront 1.0 - #5043 by @IKarbowiak\n- Replace permissions strings with enums - #5038 by @kswiatek92\n- Remove gateways forms and templates - #5075 by @IKarbowiak\n- Add `Wishlist` models and GraphQL endpoints - #5021 by @derenio\n- Remove deprecated code - #5107 by @IKarbowiak\n- Fix voucher start date filtering - #5133 by @dominik-zeglen\n- Search by sku in products query - #5117 by @fowczarek\n- Send fulfillment update email - #5118 by @IKarbowiak\n- Add address query - #5148 by @kswiatek92\n- Add `checkout_quantity_changed` webhook - #5042 by @derenio\n- Remove unnecessary manage_orders permission - #5142 by @kswiatek92\n- Mutation to change user email - #5076 by @kswiatek92\n- Add mypy checks - #5150 by @IKarbowiak\n- Move extracting user or service_account from context to utils - #5152 by @kswiatek92\n- Add deprecate description to order status/created arguments - #5076 by @kswiatek92\n- Fix getting title field in page mutations #5160 by @maarcingebala\n- Copy public and private metadata from the checkout to the order upon creation - #5165 by @dankolbman\n- Add warehouses and stocks- #4986 by @szewczykmira\n- Add permission groups - #5176 by @IKarbowiak\n- Drop gettext occurrences - #5189 by @IKarbowiak\n- Fix `product_created` webhook - #5187 by @dzkb\n- Drop unused resolver `resolve_availability` - #5190 by @maarcingebala\n- Fix permission for `checkoutCustomerAttach` mutation - #5192 by @maarcingebala\n\n## 2.9.0\n\n### API\n\n- Add mutation to change customer's first name last name - #4489 by @fowczarek\n- Add mutation to delete customer's account - #4494 by @fowczarek\n- Add mutation to change customer's password - #4656 by @fowczarek\n- Add ability to customize email sender address in emails sent by Saleor - #4820 by @NyanKiyoshi\n- Add ability to filter attributes per global ID - #4640 by @NyanKiyoshi\n- Add ability to search product types by value (through the name) - #4647 by @NyanKiyoshi\n- Add queries and mutation for serving and saving the configuration of all plugins - #4576 by @korycins\n- Add `redirectUrl` to staff and user create mutations - #4717 by @fowczarek\n- Add error codes to mutations responses - #4676 by @Kwaidan00\n- Add translations to countries in `shop` query - #4732 by @fowczarek\n- Add support for sorting product by their attribute values through given attribute ID - #4740 by @NyanKiyoshi\n- Add descriptions for queries and query arguments - #4758 by @maarcingebala\n- Add support for Apollo Federation - #4825 by @salwator\n- Add mutation to create multiple product variants at once - #4735 by @fowczarek\n- Add default value to custom errors - #4797 by @fowczarek\n- Extend `availablePaymentGateways` field with gateways' configuration data - #4774 by @salwator\n- Change `AddressValidationRules` API - #4655 by @Kwaidan00\n- Use search in a consistent way; add sort by product type name and publication status to `products` query. - #4715 by @fowczarek\n- Unify `menuItemMove` mutation with other reordering mutations - #4734 by @NyanKiyoshi\n- Don't create an order when the payment was unsuccessful - #4500 by @NyanKiyoshi\n- Don't require shipping information in checkout for digital orders - #4573 by @NyanKiyoshi\n- Drop `manage_users` permission from the `permissions` query - #4854 by @maarcingebala\n- Deprecate `inCategory` and `inCollection` attributes filters in favor of `filter` argument - #4700 by @NyanKiyoshi & @khalibloo\n- Remove `PaymentGatewayEnum` from the schema, as gateways now are dynamic plugins - #4756 by @salwator\n- Require `manage_products` permission to query `costPrice` and `stockQuantity` fields - #4753 by @NyanKiyoshi\n- Refactor account mutations - #4510, #4668 by @fowczarek\n- Fix generating random avatars when updating staff accounts - #4521 by @maarcingebala\n- Fix updating JSON menu representation in mutations - #4524 by @maarcingebala\n- Fix setting variant's `priceOverride` and `costPrice` to `null` - #4754 by @NyanKiyoshi\n- Fix fetching staff user without `manage_users` permission - #4835 by @fowczarek\n- Ensure that a GraphQL query is a string - #4836 by @nix010\n- Add ability to configure the password reset link - #4863 by @fowczarek\n\n### Core\n\n- Add enterprise-grade attributes management - #4351 by @dominik-zeglen and @NyanKiyoshix\n- Add extensions manager - #4497 by @korycins\n- Add service accounts - backend support - #4689 by @korycins\n- Add support for webhooks - #4731 by @korycins\n- Migrate the attributes mapping from HStore to many-to-many relation - #4663 by @NyanKiyoshi\n- Create general abstraction for object metadata - #4447 by @salwator\n- Add metadata to `Order` and `Fulfillment` models - #4513, #4866 by @szewczykmira\n- Migrate the tax calculations to plugins - #4497 by @korycins\n- Rewrite payment gateways using plugin architecture - #4669 by @salwator\n- Rewrite Stripe integration to use PaymentIntents API - #4606 by @salwator\n- Refactor password recovery system - #4617 by @fowczarek\n- Add functionality to sort products by their \"minimal variant price\" - #4416 by @derenio\n- Add voucher's \"once per customer\" feature - #4442 by @fowczarek\n- Add validations for minimum password length in settings - #4735 by @fowczarek\n- Add form to configure payments in the dashboard - #4807 by @szewczykmira\n- Change `unique_together` in `AttributeValue` - #4805 by @fowczarek\n- Change max length of SKU to 255 characters - #4811 by @lex111\n- Distinguish `OrderLine` product name and variant name - #4702 by @fowczarek\n- Fix updating order status after automatic fulfillment of digital products - #4709 by @korycins\n- Fix error when updating or creating a sale with missing required values - #4778 by @NyanKiyoshi\n- Fix error filtering pages by URL in the dashboard 1.0 - #4776 by @NyanKiyoshi\n- Fix display of the products tax rate in the details page of dashboard 1.0 - #4780 by @NyanKiyoshi\n- Fix adding the same product into a collection multiple times - #4518 by @NyanKiyoshi\n- Fix crash when placing an order when a customer happens to have the same address more than once - #4824 by @NyanKiyoshi\n- Fix time zone based tests - #4468 by @fowczarek\n- Fix serializing empty URLs as a string when creating menu items - #4616 by @maarcingebala\n- The invalid IP address in HTTP requests now fallback to the requester's IP address. - #4597 by @NyanKiyoshi\n- Fix product variant update with current attribute values - #4936 by @fowczarek\n- Update checkout last field and add auto now fields to save with update_fields parameter - #5177 by @IKarbowiak\n\n### Dashboard 2.0\n\n- Allow selecting the number of rows displayed in dashboard's list views - #4414 by @benekex2\n- Add ability to toggle visible columns in product list - #4608 by @dominik-zeglen\n- Add voucher settings - #4556 by @benekex2\n- Contrast improvements - #4508 by @benekex2\n- Display menu item form errors - #4551 by @dominik-zeglen\n- Do not allow random IDs to appear in snapshots - #4495 by @dominik-zeglen\n- Input UI changes - #4542 by @benekex2\n- Implement new menu design - #4476 by @benekex2\n- Refetch attribute list after closing modal - #4615 by @dominik-zeglen\n- Add config for Testcafe - #4553 by @dominik-zeglen\n- Fix product type taxes select - #4453 by @benekex2\n- Fix form reloading - #4467 by @dominik-zeglen\n- Fix voucher limit value when checkbox unchecked - #4456 by @benekex2\n- Fix searches and pickers - #4487 by @dominik-zeglen\n- Fix dashboard menu styles - #4491 by @benekex2\n- Fix menu responsiveness - #4511 by @benekex2\n- Fix loosing focus while typing in the product description field - #4549 by @dominik-zeglen\n- Fix MUI warnings - #4588 by @dominik-zeglen\n- Fix bulk action checkboxes - #4618 by @dominik-zeglen\n- Fix rendering user avatar when it's empty #4546 by @maarcingebala\n- Remove Dashboard 2.0 files form Saleor repository - #4631 by @dominik-zeglen\n\n### Other notable changes\n\n- Replace Pipenv with Poetry - #3894 by @michaljelonek\n- Upgrade `django-prices` to v2.1 - #4639 by @NyanKiyoshi\n- Disable reports from uWSGI about broken pipe and write errors from disconnected clients - #4596 by @NyanKiyoshi\n- Fix the random failures of `populatedb` trying to create users with an existing email - #4769 by @NyanKiyoshi\n- Enforce `pydocstyle` for Python docstrings over the project - #4562 by @NyanKiyoshi\n- Move Django Debug Toolbar to dev requirements - #4454 by @derenio\n- Change license for artwork to CC-BY 4.0\n- New translations:\n  - Greek\n\n## 2.8.0\n\n### Core\n\n- Avatax backend support - #4310 by @korycins\n- Add ability to store used payment sources in gateways (first implemented in Braintree) - #4195 by @salwator\n- Add ability to specify a minimal quantity of checkout items for a voucher - #4427 by @fowczarek\n- Change the type of start and end date fields from Date to DateTime - #4293 by @fowczarek\n- Revert the custom dynamic middlewares - #4452 by @NyanKiyoshi\n\n### Dashboard 2.0\n\n- UX improvements in Vouchers section - #4362 by @benekex2\n- Add company address configuration - #4432 by @benekex2\n- Require name when saving a custom list filter - #4269 by @benekex2\n- Use `esModuleInterop` flag in `tsconfig.json` to simplify imports - #4372 by @dominik-zeglen\n- Use hooks instead of a class component in forms - #4374 by @dominik-zeglen\n- Drop CSRF token header from API client - #4357 by @dominik-zeglen\n- Fix various bugs in the product section - #4429 by @dominik-zeglen\n\n### Other notable changes\n\n- Fix error when creating a checkout with voucher code - #4292 by @NyanKiyoshi\n- Fix error when users enter an invalid phone number in an address - #4404 by @NyanKiyoshi\n- Fix error when adding a note to an anonymous order - #4319 by @NyanKiyoshi\n- Fix gift card duplication error in the `populatedb` script - #4336 by @fowczarek\n- Fix vouchers apply once per order - #4339 by @fowczarek\n- Fix discount tests failing at random - #4401 by @korycins\n- Add `SPECIFIC_PRODUCT` type to `VoucherType` - #4344 by @fowczarek\n- New translations:\n  - Icelandic\n- Refactored the backend side of `checkoutCreate` to improve performances and prevent side effects over the user's checkout if the checkout creation was to fail. - #4367 by @NyanKiyoshi\n- Refactored the logic of cleaning the checkout shipping method over the API, so users do not lose the shipping method when updating their checkout. If the shipping method becomes invalid, it will be replaced by the cheapest available. - #4367 by @NyanKiyoshi & @szewczykmira\n- Refactored process of getting available shipping methods to make it easier to understand and prevent human-made errors. - #4367 by @NyanKiyoshi\n- Moved 3D secure option to Braintree plugin configuration and update config structure mechanism - #4751 by @salwator\n\n## 2.7.0\n\n### API\n\n- Create order only when payment is successful - #4154 by @NyanKiyoshi\n- Order Events containing order lines or fulfillment lines now return the line object in the GraphQL API - #4114 by @NyanKiyoshi\n- GraphQL now prints exceptions to stderr as well as returning them or not - #4148 by @NyanKiyoshi\n- Refactored API resolvers to static methods with root typing - #4155 by @NyanKiyoshi\n- Add phone validation in the GraphQL API to handle the library upgrade - #4156 by @NyanKiyoshi\n\n### Core\n\n- Add basic Gift Cards support in the backend - #4025 by @fowczarek\n- Add the ability to sort products within a collection - #4123 by @NyanKiyoshi\n- Implement customer events - #4094 by @NyanKiyoshi\n- Merge \"authorize\" and \"capture\" operations - #4098 by @korycins, @NyanKiyoshi\n- Separate the Django middlewares from the GraphQL API middlewares - #4102 by @NyanKiyoshi, #4186 by @cmiacz\n\n### Dashboard 2.0\n\n- Add navigation section - #4012 by @dominik-zeglen\n- Add filtering on product list - #4193 by @dominik-zeglen\n- Add filtering on orders list - #4237 by @dominik-zeglen\n- Change input style and improve Storybook stories - #4115 by @dominik-zeglen\n- Migrate deprecated fields in Dashboard 2.0 - #4121 by @benekex2\n- Add multiple select checkbox - #4133, #4146 by @benekex2\n- Rename menu items in Dashboard 2.0 - #4172 by @benekex2\n- Category delete modal improvements - #4171 by @benekex2\n- Close modals on click outside - #4236 - by @benekex2\n- Use date localize hook in translations - #4202 by @dominik-zeglen\n- Unify search API - #4200 by @dominik-zeglen\n- Default default PAGINATE_BY - #4238 by @dominik-zeglen\n- Create generic filtering interface - #4221 by @dominik-zeglen\n- Add default state to rich text editor = #4281 by @dominik-zeglen\n- Fix translation discard button - #4109 by @benekex2\n- Fix draftail options and icons - #4132 by @benekex2\n- Fix typos and messages in Dashboard 2.0 - #4168 by @benekex2\n- Fix view all orders button - #4173 by @benekex2\n- Fix visibility card view - #4198 by @benekex2\n- Fix query refetch after selecting an object in list - #4272 by @dominik-zeglen\n- Fix image selection in variants - #4270 by @benekex2\n- Fix collection search - #4267 by @dominik-zeglen\n- Fix quantity height in draft order edit - #4273 by @benekex2\n- Fix checkbox clickable area size - #4280 by @dominik-zeglen\n- Fix breaking object selection in menu section - #4282 by @dominik-zeglen\n- Reset selected items when tab switch - #4268 by @benekex2\n\n### Other notable changes\n\n- Add support for Google Cloud Storage - #4127 by @chetabahana\n- Adding a nonexistent variant to checkout no longer crashes - #4166 by @NyanKiyoshi\n- Disable storage of Celery results - #4169 by @NyanKiyoshi\n- Disable polling in Playground - #4188 by @maarcingebala\n- Cleanup code for updated function names and unused argument - #4090 by @jxltom\n- Users can now add multiple \"Add to Cart\" forms in a single page - #4165 by @NyanKiyoshi\n- Fix incorrect argument in `get_client_token` in Braintree integration - #4182 by @maarcingebala\n- Fix resolving attribute values when transforming them to HStore - #4161 by @maarcingebala\n- Fix wrong calculation of subtotal in cart page - #4145 by @korycins\n- Fix margin calculations when product/variant price is set to zero - #4170 by @MahmoudRizk\n- Fix applying discounts in checkout's subtotal calculation in API - #4192 by @maarcingebala\n- Fix GATEWAYS_ENUM to always contain all implemented payment gateways - #4108 by @koradon\n\n## 2.6.0\n\n### API\n\n- Add unified filtering interface in resolvers - #3952, #4078 by @korycins\n- Add mutations for bulk actions - #3935, #3954, #3967, #3969, #3970 by @akjanik\n- Add mutation for reordering menu items - #3958 by @NyanKiyoshi\n- Optimize queries for single nodes - #3968 @NyanKiyoshi\n- Refactor error handling in mutations #3891 by @maarcingebala & @akjanik\n- Specify mutation permissions through Meta classes - #3980 by @NyanKiyoshi\n- Unify pricing access in products and variants - #3948 by @NyanKiyoshi\n- Use only_fields instead of exclude_fields in type definitions - #3940 by @michaljelonek\n- Prefetch collections when getting sales of a bunch of products - #3961 by @NyanKiyoshi\n- Remove unnecessary dedents from GraphQL schema so new Playground can work - #4045 by @salwator\n- Restrict resolving payment by ID - #4009 @NyanKiyoshi\n- Require `checkoutId` for updating checkout's shipping and billing address - #4074 by @jxltom\n- Handle errors in `TokenVerify` mutation - #3981 by @fowczarek\n- Unify argument names in types and resolvers - #3942 by @NyanKiyoshi\n\n### Core\n\n- Use Black as the default code formatting tool - #3852 by @krzysztofwolski and @NyanKiyoshi\n- Dropped Python 3.5 support - #4028 by @korycins\n- Rename Cart to Checkout - #3963 by @michaljelonek\n- Use data classes to exchange data with payment gateways - #4028 by @korycins\n- Refactor order events - #4018 by @NyanKiyoshi\n\n### Dashboard 2.0\n\n- Add bulk actions - #3955 by @dominik-zeglen\n- Add user avatar management - #4030 by @benekex2\n- Add navigation drawer support on mobile devices - #3839 by @benekex2\n- Fix rendering validation errors in product form - #4024 by @benekex2\n- Move dialog windows to query string rather than router paths - #3953 by @dominik-zeglen\n- Update order events types - #4089 by @jxltom\n- Code cleanup by replacing render props with react hooks - #4010 by @dominik-zeglen\n\n### Other notable changes\n\n- Add setting to enable Django Debug Toolbar - #3983 by @koradon\n- Use newest GraphQL Playground - #3971 by @salwator\n- Ensure adding to quantities in the checkout is respecting the limits - #4005 by @NyanKiyoshi\n- Fix country area choices - #4008 by @fowczarek\n- Fix price_range_as_dict function - #3999 by @zodiacfireworks\n- Fix the product listing not showing in the voucher when there were products selected - #4062 by @NyanKiyoshi\n- Fix crash in Dashboard 1.0 when updating an order address's phone number - #4061 by @NyanKiyoshi\n- Reduce the time of tests execution by using dummy password hasher - #4083 by @korycins\n- Set up explicit **hash** function - #3979 by @akjanik\n- Unit tests use none as media root - #3975 by @korycins\n- Update file field styles with materializecss template filter - #3998 by @zodiacfireworks\n- New translations:\n  - Albanian\n  - Colombian Spanish\n  - Lithuanian\n\n## 2.5.0\n\n### API\n\n- Add query to fetch draft orders - #3809 by @michaljelonek\n- Add bulk delete mutations - #3838 by @michaljelonek\n- Add `languageCode` enum to API - #3819 by @michaljelonek, #3854 by @jxltom\n- Duplicate address instances in checkout mutations - #3866 by @pawelzar\n- Restrict access to `orders` query for unauthorized users - #3861 by @pawelzar\n- Support setting address as default in address mutations - #3787 by @jxltom\n- Fix phone number validation in GraphQL when country prefix not given - #3905 by @patrys\n- Report pretty stack traces in DEBUG mode - #3918 by @patrys\n\n### Core\n\n- Drop support for Django 2.1 and Django 1.11 (previous LTS) - #3929 by @patrys\n- Fulfillment of digital products - #3868 by @korycins\n- Introduce avatars for staff accounts - #3878 by @pawelzar\n- Refactor the account avatars path from a relative to absolute - #3938 by @NyanKiyoshi\n\n### Dashboard 2.0\n\n- Add translations section - #3884 by @dominik-zeglen\n- Add light/dark theme - #3856 by @dominik-zeglen\n- Add customer's address book view - #3826 by @dominik-zeglen\n- Add \"Add variant\" button on the variant details page = #3914 by @dominik-zeglen\n- Add back arrows in \"Configure\" subsections - #3917 by @dominik-zeglen\n- Display avatars in staff views - #3922 by @dominik-zeglen\n- Prevent user from changing his own status and permissions - #3922 by @dominik-zeglen\n- Fix crashing product create view - #3837, #3910 by @dominik-zeglen\n- Fix layout in staff members details page - #3857 by @dominik-zeglen\n- Fix unfocusing rich text editor - #3902 by @dominik-zeglen\n- Improve accessibility - #3856 by @dominik-zeglen\n\n### Other notable changes\n\n- Improve user and staff management in dashboard 1.0 - #3781 by @jxltom\n- Fix default product tax rate in Dashboard 1.0 - #3880 by @pawelzar\n- Fix logo in docs - #3928 by @michaljelonek\n- Fix name of logo file - #3867 by @jxltom\n- Fix variants for juices in example data - #3926 by @michaljelonek\n- Fix alignment of the cart dropdown on new bootstrap version - #3937 by @NyanKiyoshi\n- Refactor the account avatars path from a relative to absolute - #3938 by @NyanKiyoshi\n- New translations:\n  - Armenian\n  - Portuguese\n  - Swahili\n  - Thai\n\n## 2.4.0\n\n### API\n\n- Add model translations support in GraphQL API - #3789 by @michaljelonek\n- Add mutations to manage addresses for authenticated customers - #3772 by @Kwaidan00, @maarcingebala\n- Add mutation to apply vouchers in checkout - #3739 by @Kwaidan00\n- Add thumbnail field to `OrderLine` type - #3737 by @michaljelonek\n- Add a query to fetch order by token - #3740 by @michaljelonek\n- Add city choices and city area type to address validator API - #3788 by @jxltom\n- Fix access to unpublished objects in API - #3724 by @Kwaidan00\n- Fix bug where errors are not returned when creating fulfillment with a non-existent order line - #3777 by @jxltom\n- Fix `productCreate` mutation when no product type was provided - #3804 by @michaljelonek\n- Enable database search in products query - #3736 by @michaljelonek\n- Use authenticated user's email as default email in creating checkout - #3726 by @jxltom\n- Generate voucher code if it wasn't provided in mutation - #3717 by @Kwaidan00\n- Improve limitation of vouchers by country - #3707 by @michaljelonek\n- Only include canceled fulfillments for staff in fulfillment API - #3778 by @jxltom\n- Support setting address as when creating customer address #3782 by @jxltom\n- Fix generating slug from title - #3816 by @maarcingebala\n- Add `variant` field to `OrderLine` type - #3820 by @maarcingebala\n\n### Core\n\n- Add JSON fields to store rich-text content - #3756 by @michaljelonek\n- Add function to recalculate total order weight - #3755 by @Kwaidan00, @maarcingebala\n- Unify cart creation logic in API and Django views - #3761, #3790 by @maarcingebala\n- Unify payment creation logic in API and Django views - #3715 by @maarcingebala\n- Support partially charged and refunded payments - #3735 by @jxltom\n- Support partial fulfillment of ordered items - #3754 by @jxltom\n- Fix applying discounts when a sale has no end date - #3595 by @cprinos\n\n### Dashboard 2.0\n\n- Add \"Discounts\" section - #3654 by @dominik-zeglen\n- Add \"Pages\" section; introduce Draftail WYSIWYG editor - #3751 by @dominik-zeglen\n- Add \"Shipping Methods\" section - #3770 by @dominik-zeglen\n- Add support for date and datetime components - #3708 by @dominik-zeglen\n- Restyle app layout - #3811 by @dominik-zeglen\n\n### Other notable changes\n\n- Unify model field names related to models' public access - `publication_date` and `is_published` - #3706 by @michaljelonek\n- Improve filter orders by payment status - #3749 @jxltom\n- Refactor translations in emails - #3701 by @Kwaidan00\n- Use exact image versions in docker-compose - #3742 by @ashishnitinpatil\n- Sort order payment and history in descending order - #3747 by @jxltom\n- Disable style-loader in dev mode - #3720 by @jxltom\n- Add ordering to shipping method - #3806 by @michaljelonek\n- Add missing type definition for dashboard 2.0 - #3776 by @jxltom\n- Add header and footer for checkout success pages #3752 by @jxltom\n- Add instructions for using local assets in Docker - #3723 by @michaljelonek\n- Update S3 deployment documentation to include CORS configuration note - #3743 by @NyanKiyoshi\n- Fix missing migrations for is_published field of product and page model - #3757 by @jxltom\n- Fix problem with l10n in Braintree payment gateway template - #3691 by @Kwaidan00\n- Fix bug where payment is not filtered from active ones when creating payment - #3732 by @jxltom\n- Fix incorrect cart badge location - #3786 by @jxltom\n- Fix storefront styles after bootstrap is updated to 4.3.1 - #3753 by @jxltom\n- Fix logo size in different browser and devices with different sizes - #3722 by @jxltom\n- Rename dumpdata file `db.json` to `populatedb_data.json` - #3810 by @maarcingebala\n- Prefetch collections for product availability - #3813 by @michaljelonek\n- Bump django-graphql-jwt - #3814 by @michaljelonek\n- Fix generating slug from title - #3816 by @maarcingebala\n- New translations:\n  - Estonian\n  - Indonesian\n\n## 2.3.1\n\n- Fix access to private variant fields in API - #3773 by maarcingebala\n- Limit access of quantity and allocated quantity to staff in GraphQL API #3780 by @jxltom\n\n## 2.3.0\n\n### API\n\n- Return user's last checkout in the `User` type - #3578 by @fowczarek\n- Automatically assign checkout to the logged in user - #3587 by @fowczarek\n- Expose `chargeTaxesOnShipping` field in the `Shop` type - #3603 by @fowczarek\n- Expose list of enabled payment gateways - #3639 by @fowczarek\n- Validate uploaded files in a unified way - #3633 by @fowczarek\n- Add mutation to trigger fetching tax rates - #3622 by @fowczarek\n- Use USERNAME_FIELD instead of hard-code email field when resolving user - #3577 by @jxltom\n- Require variant and quantity fields in `CheckoutLineInput` type - #3592 by @jxltom\n- Preserve order of nodes in `get_nodes_or_error` function - #3632 by @jxltom\n- Add list mutations for `Voucher` and `Sale` models - #3669 by @michaljelonek\n- Use proper type for countries in `Voucher` type - #3664 by @michaljelonek\n- Require email in when creating checkout in API - #3667 by @michaljelonek\n- Unify returning errors in the `tokenCreate` mutation - #3666 by @michaljelonek\n- Use `Date` field in Sale/Voucher inputs - #3672 by @michaljelonek\n- Refactor checkout mutations - #3610 by @fowczarek\n- Refactor `clean_instance`, so it does not returns errors anymore - #3597 by @akjanik\n- Handle GraphqQL syntax errors - #3576 by @jxltom\n\n### Core\n\n- Refactor payments architecture - #3519 by @michaljelonek\n- Improve Docker and `docker-compose` configuration - #3657 by @michaljelonek\n- Allow setting payment status manually for dummy gateway in Storefront 1.0 - #3648 by @jxltom\n- Infer default transaction kind from operation type - #3646 by @jxltom\n- Get correct payment status for order without any payments - #3605 by @jxltom\n- Add default ordering by `id` for `CartLine` model - #3593 by @jxltom\n- Fix \"set password\" email sent to customer created in the dashboard - #3688 by @Kwaidan00\n\n### Dashboard 2.0\n\n- \ufe0fAdd taxes section - #3622 by @dominik-zeglen\n- Add drag'n'drop image upload - #3611 by @dominik-zeglen\n- Unify grid handling - #3520 by @dominik-zeglen\n- Add component generator - #3670 by @dominik-zeglen\n- Throw Typescript errors while snapshotting - #3611 by @dominik-zeglen\n- Simplify mutation's error checking - #3589 by @dominik-zeglen\n- Fix order cancelling - #3624 by @dominik-zeglen\n- Fix logo placement - #3602 by @dominik-zeglen\n\n### Other notable changes\n\n- Register Celery task for updating exchange rates - #3599 by @jxltom\n- Fix handling different attributes with the same slug - #3626 by @jxltom\n- Add missing migrations for tax rate choices - #3629 by @jxltom\n- Fix `TypeError` on calling `get_client_token` - #3660 by @michaljelonek\n- Make shipping required as default when creating product types - #3655 by @jxltom\n- Display payment status on customer's account page in Storefront 1.0 - #3637 by @jxltom\n- Make order fields sequence in Dashboard 1.0 same as in Dashboard 2.0 - #3606 by @jxltom\n- Fix returning products for homepage for the currently viewing user - #3598 by @jxltom\n- Allow filtering payments by status in Dashboard 1.0 - #3608 by @jxltom\n- Fix typo in the definition of order status - #3649 by @jxltom\n- Add margin for order notes section - #3650 by @jxltom\n- Fix logo position - #3609, #3616 by @jxltom\n- Storefront visual improvements - #3696 by @piotrgrundas\n- Fix product list price filter - #3697 by @Kwaidan00\n- Redirect to success page after successful payment - #3693 by @Kwaidan00\n\n## 2.2.0\n\n### API\n\n- Use `PermissionEnum` as input parameter type for `permissions` field - #3434 by @maarcingebala\n- Add \"authorize\" and \"charge\" mutations for payments - #3426 by @jxltom\n- Add alt text to product thumbnails and background images of collections and categories - #3429 by @fowczarek\n- Fix passing decimal arguments = #3457 by @fowczarek\n- Allow sorting products by the update date - #3470 by @jxltom\n- Validate and clear the shipping method in draft order mutations - #3472 by @fowczarek\n- Change tax rate field to choice field - #3478 by @fowczarek\n- Allow filtering attributes by collections - #3508 by @maarcingebala\n- Resolve to `None` when empty object ID was passed as mutation argument - #3497 by @maarcingebala\n- Change `errors` field type from [Error] to [Error!] - #3489 by @fowczarek\n- Support creating default variant for product types that don't use multiple variants - #3505 by @fowczarek\n- Validate SKU when creating a default variant - #3555 by @fowczarek\n- Extract enums to separate files - #3523 by @maarcingebala\n\n### Core\n\n- Add Stripe payment gateway - #3408 by @jxltom\n- Add `first_name` and `last_name` fields to the `User` model - #3101 by @fowczarek\n- Improve several payment validations - #3418 by @jxltom\n- Optimize payments related database queries - #3455 by @jxltom\n- Add publication date to collections - #3369 by @k-brk\n- Fix hard-coded site name in order PDFs - #3526 by @NyanKiyoshi\n- Update favicons to the new style - #3483 by @dominik-zeglen\n- Fix migrations for default currency - #3235 by @bykof\n- Remove Elasticsearch from `docker-compose.yml` - #3482 by @maarcingebala\n- Resort imports in tests - #3471 by @jxltom\n- Fix the no shipping orders payment crash on Stripe - #3550 by @NyanKiyoshi\n- Bump backend dependencies - #3557 by @maarcingebala. This PR removes security issue CVE-2019-3498 which was present in Django 2.1.4. Saleor however wasn't vulnerable to this issue as it doesn't use the affected `django.views.defaults.page_not_found()` view.\n- Generate random data using the default currency - #3512 by @stephenmoloney\n- New translations:\n  - Catalan\n  - Serbian\n\n### Dashboard 2.0\n\n- Restyle product selection dialogs - #3499 by @dominik-zeglen, @maarcingebala\n- Fix minor visual bugs in Dashboard 2.0 - #3433 by @dominik-zeglen\n- Display warning if order draft has missing data - #3431 by @dominik-zeglen\n- Add description field to collections - #3435 by @dominik-zeglen\n- Add query batching - #3443 by @dominik-zeglen\n- Use autocomplete fields in country selection - #3443 by @dominik-zeglen\n- Add alt text to categories and collections - #3461 by @dominik-zeglen\n- Use first and last name of a customer or staff member in UI - #3247 by @Bonifacy1, @dominik-zeglen\n- Show error page if an object was not found - #3463 by @dominik-zeglen\n- Fix simple product's inventory data saving bug - #3474 by @dominik-zeglen\n- Replace `thumbnailUrl` with `thumbnail { url }` - #3484 by @dominik-zeglen\n- Change \"Feature on Homepage\" switch behavior - #3481 by @dominik-zeglen\n- Expand payment section in order view - #3502 by @dominik-zeglen\n- Change TypeScript loader to speed up the build process - #3545 by @patrys\n\n### Bugfixes\n\n- Do not show `Pay For Order` if order is partly paid since partial payment is not supported - #3398 by @jxltom\n- Fix attribute filters in the products category view - #3535 by @fowczarek\n- Fix storybook dependencies conflict - #3544 by @dominik-zeglen\n\n## 2.1.0\n\n### API\n\n- Change selected connection fields to lists - #3307 by @fowczarek\n- Require pagination in connections - #3352 by @maarcingebala\n- Replace Graphene view with a custom one - #3263 by @patrys\n- Change `sortBy` parameter to use enum type - #3345 by @fowczarek\n- Add `me` query to fetch data of a logged-in user - #3202, #3316 by @fowczarek\n- Add `canFinalize` field to the Order type - #3356 by @fowczarek\n- Extract resolvers and mutations to separate files - #3248 by @fowczarek\n- Add VAT tax rates field to country - #3392 by @michaljelonek\n- Allow creating orders without users - #3396 by @fowczarek\n\n### Core\n\n- Add Razorpay payment gatway - #3205 by @NyanKiyoshi\n- Use standard tax rate as a default tax rate value - #3340 by @fowczarek\n- Add description field to the Collection model - #3275 by @fowczarek\n- Enforce the POST method on VAT rates fetching - #3337 by @NyanKiyoshi\n- Generate thumbnails for category/collection background images - #3270 by @NyanKiyoshi\n- Add warm-up support in product image creation mutation - #3276 by @NyanKiyoshi\n- Fix error in the `populatedb` script when running it not from the project root - #3272 by @NyanKiyoshi\n- Make Webpack rebuilds fast - #3290 by @patrys\n- Skip installing Chromium to make deployment faster - #3227 by @jxltom\n- Add default test runner - #3258 by @jxltom\n- Add Transifex client to Pipfile - #3321 by @jxltom\n- Remove additional pytest arguments in tox - #3338 by @jxltom\n- Remove test warnings - #3339 by @jxltom\n- Remove runtime warning when product has discount - #3310 by @jxltom\n- Remove `django-graphene-jwt` warnings - #3228 by @jxltom\n- Disable deprecated warnings - #3229 by @jxltom\n- Add `AWS_S3_ENDPOINT_URL` setting to support DigitalOcean spaces. - #3281 by @hairychris\n- Add `.gitattributes` file to hide diffs for generated files on Github - #3055 by @NyanKiyoshi\n- Add database sequence reset to `populatedb` - #3406 by @michaljelonek\n- Get authorized amount from succeeded auth transactions - #3417 by @jxltom\n- Resort imports by `isort` - #3412 by @jxltom\n\n### Dashboard 2.0\n\n- Add confirmation modal when leaving view with unsaved changes - #3375 by @dominik-zeglen\n- Add dialog loading and error states - #3359 by @dominik-zeglen\n- Split paths and urls - #3350 by @dominik-zeglen\n- Derive state from props in forms - #3360 by @dominik-zeglen\n- Apply debounce to autocomplete fields - #3351 by @dominik-zeglen\n- Use Apollo signatures - #3353 by @dominik-zeglen\n- Add order note field in the order details view - #3346 by @dominik-zeglen\n- Add app-wide progress bar - #3312 by @dominik-zeglen\n- Ensure that all queries are built on top of TypedQuery - #3309 by @dominik-zeglen\n- Close modal windows automatically - #3296 by @dominik-zeglen\n- Move URLs to separate files - #3295 by @dominik-zeglen\n- Add basic filters for products and orders list - #3237 by @Bonifacy1\n- Fetch default currency from API - #3280 by @dominik-zeglen\n- Add `displayName` property to components - #3238 by @Bonifacy1\n- Add window titles - #3279 by @dominik-zeglen\n- Add paginator component - #3265 by @dominik-zeglen\n- Update Material UI to 3.6 - #3387 by @patrys\n- Upgrade React, Apollo, Webpack and Babel - #3393 by @patrys\n- Add pagination for required connections - #3411 by @dominik-zeglen\n\n### Bugfixes\n\n- Fix language codes - #3311 by @jxltom\n- Fix resolving empty attributes list - #3293 by @maarcingebala\n- Fix range filters not being applied - #3385 by @michaljelonek\n- Remove timeout for updating image height - #3344 by @jxltom\n- Return error if checkout was not found - #3289 by @maarcingebala\n- Solve an auto-resize conflict between Materialize and medium-editor - #3367 by @adonig\n- Fix calls to `ngettext_lazy` - #3380 by @patrys\n- Filter preauthorized order from succeeded transactions - #3399 by @jxltom\n- Fix incorrect country code in fixtures - #3349 by @bingimar\n- Fix updating background image of a collection - #3362 by @fowczarek & @dominik-zeglen\n\n### Docs\n\n- Document settings related to generating thumbnails on demand - #3329 by @NyanKiyoshi\n- Improve documentation for Heroku deployment - #3170 by @raybesiga\n- Update documentation on Docker deployment - #3326 by @jxltom\n- Document payment gateway configuration - #3376 by @NyanKiyoshi\n\n## 2.0.0\n\n### API\n\n- Add mutation to delete a customer; add `isActive` field in `customerUpdate` mutation - #3177 by @maarcingebala\n- Add mutations to manage authorization keys - #3082 by @maarcingebala\n- Add queries for dashboard homepage - #3146 by @maarcingebala\n- Allows user to unset homepage collection - #3140 by @oldPadavan\n- Use enums as permission codes - #3095 by @the-bionic\n- Return absolute image URLs - #3182 by @maarcingebala\n- Add `backgroundImage` field to `CategoryInput` - #3153 by @oldPadavan\n- Add `dateJoined` and `lastLogin` fields in `User` type - #3169 by @maarcingebala\n- Separate `parent` input field from `CategoryInput` - #3150 by @akjanik\n- Remove duplicated field in Order type - #3180 by @maarcingebala\n- Handle empty `backgroundImage` field in API - #3159 by @maarcingebala\n- Generate name-based slug in collection mutations - #3145 by @akjanik\n- Remove products field from `collectionUpdate` mutation - #3141 by @oldPadavan\n- Change `items` field in `Menu` type from connection to list - #3032 by @oldPadavan\n- Make `Meta.description` required in `BaseMutation` - #3034 by @oldPadavan\n- Apply `textwrap.dedent` to GraphQL descriptions - #3167 by @fowczarek\n\n### Dashboard 2.0\n\n- Add collection management - #3135 by @dominik-zeglen\n- Add customer management - #3176 by @dominik-zeglen\n- Add homepage view - #3155, #3178 by @Bonifacy1 and @dominik-zeglen\n- Add product type management - #3052 by @dominik-zeglen\n- Add site settings management - #3071 by @dominik-zeglen\n- Escape node IDs in URLs - #3115 by @dominik-zeglen\n- Restyle categories section - #3072 by @Bonifacy1\n\n### Other\n\n- Change relation between `ProductType` and `Attribute` models - #3097 by @maarcingebala\n- Remove `quantity-allocated` generation in `populatedb` script - #3084 by @MartinSeibert\n- Handle `Money` serialization - #3131 by @Pacu2\n- Do not collect unnecessary static files - #3050 by @jxltom\n- Remove host mounted volume in `docker-compose` - #3091 by @tiangolo\n- Remove custom services names in `docker-compose` - #3092 by @tiangolo\n- Replace COUNTRIES with countries.countries - #3079 by @neeraj1909\n- Installing dev packages in docker since tests are needed - #3078 by @jxltom\n- Remove comparing string in address-form-panel template - #3074 by @tomcio1205\n- Move updating variant names to a Celery task - #3189 by @fowczarek\n\n### Bugfixes\n\n- Fix typo in `clean_input` method - #3100 by @the-bionic\n- Fix typo in `ShippingMethod` model - #3099 by @the-bionic\n- Remove duplicated variable declaration - #3094 by @the-bionic\n\n### Docs\n\n- Add createdb note to getting started for Windows - #3106 by @ajostergaard\n- Update docs on pipenv - #3045 by @jxltom\n", "from typing import List, Optional, Tuple\n\nimport graphene\nfrom django.conf import settings\nfrom django.core.exceptions import ObjectDoesNotExist, ValidationError\nfrom django.db import transaction\nfrom django.db.models import Prefetch\nfrom graphql_jwt.exceptions import PermissionDenied\n\nfrom ...account.error_codes import AccountErrorCode\nfrom ...checkout import models\nfrom ...checkout.error_codes import CheckoutErrorCode\nfrom ...checkout.utils import (\n    abort_order_data,\n    add_promo_code_to_checkout,\n    add_variant_to_checkout,\n    change_billing_address_in_checkout,\n    change_shipping_address_in_checkout,\n    clean_checkout,\n    create_order,\n    get_user_checkout,\n    get_valid_shipping_methods_for_checkout,\n    prepare_order_data,\n    recalculate_checkout_discount,\n    remove_promo_code_from_checkout,\n)\nfrom ...core import analytics\nfrom ...core.exceptions import InsufficientStock\nfrom ...core.permissions import OrderPermissions\nfrom ...core.taxes import TaxError\nfrom ...core.utils.url import validate_storefront_url\nfrom ...discount import models as voucher_model\nfrom ...payment import PaymentError, gateway, models as payment_models\nfrom ...payment.interface import AddressData\nfrom ...payment.utils import store_customer_id\nfrom ...product import models as product_models\nfrom ...warehouse.availability import check_stock_quantity, get_available_quantity\nfrom ..account.i18n import I18nMixin\nfrom ..account.types import AddressInput\nfrom ..core.mutations import (\n    BaseMutation,\n    ClearMetaBaseMutation,\n    ModelMutation,\n    UpdateMetaBaseMutation,\n)\nfrom ..core.types.common import CheckoutError\nfrom ..core.utils import from_global_id_strict_type\nfrom ..order.types import Order\nfrom ..product.types import ProductVariant\nfrom ..shipping.types import ShippingMethod\nfrom .types import Checkout, CheckoutLine\n\nERROR_DOES_NOT_SHIP = \"This checkout doesn't need shipping\"\n\n\ndef clean_shipping_method(\n    checkout: models.Checkout, method: Optional[models.ShippingMethod], discounts\n) -> bool:\n    \"\"\"Check if current shipping method is valid.\"\"\"\n\n    if not method:\n        # no shipping method was provided, it is valid\n        return True\n\n    if not checkout.is_shipping_required():\n        raise ValidationError(\n            ERROR_DOES_NOT_SHIP, code=CheckoutErrorCode.SHIPPING_NOT_REQUIRED.value\n        )\n\n    if not checkout.shipping_address:\n        raise ValidationError(\n            \"Cannot choose a shipping method for a checkout without the \"\n            \"shipping address.\",\n            code=CheckoutErrorCode.SHIPPING_ADDRESS_NOT_SET.value,\n        )\n\n    valid_methods = get_valid_shipping_methods_for_checkout(checkout, discounts)\n    return method in valid_methods\n\n\ndef update_checkout_shipping_method_if_invalid(checkout: models.Checkout, discounts):\n    # remove shipping method when empty checkout\n    if checkout.quantity == 0 or not checkout.is_shipping_required():\n        checkout.shipping_method = None\n        checkout.save(update_fields=[\"shipping_method\", \"last_change\"])\n\n    is_valid = clean_shipping_method(\n        checkout=checkout, method=checkout.shipping_method, discounts=discounts\n    )\n\n    if not is_valid:\n        cheapest_alternative = get_valid_shipping_methods_for_checkout(\n            checkout, discounts\n        ).first()\n        checkout.shipping_method = cheapest_alternative\n        checkout.save(update_fields=[\"shipping_method\", \"last_change\"])\n\n\ndef check_lines_quantity(variants, quantities, country):\n    \"\"\"Check if stock is sufficient for each line in the list of dicts.\"\"\"\n    for variant, quantity in zip(variants, quantities):\n        if quantity < 0:\n            raise ValidationError(\n                {\n                    \"quantity\": ValidationError(\n                        \"The quantity should be higher than zero.\",\n                        code=CheckoutErrorCode.ZERO_QUANTITY,\n                    )\n                }\n            )\n        if quantity > settings.MAX_CHECKOUT_LINE_QUANTITY:\n            raise ValidationError(\n                {\n                    \"quantity\": ValidationError(\n                        \"Cannot add more than %d times this item.\"\n                        \"\" % settings.MAX_CHECKOUT_LINE_QUANTITY,\n                        code=CheckoutErrorCode.QUANTITY_GREATER_THAN_LIMIT,\n                    )\n                }\n            )\n        try:\n            check_stock_quantity(variant, country, quantity)\n        except InsufficientStock as e:\n            available_quantity = get_available_quantity(e.item, country)\n            message = (\n                \"Could not add item \"\n                + \"%(item_name)s. Only %(remaining)d remaining in stock.\"\n                % {\n                    \"remaining\": available_quantity,\n                    \"item_name\": e.item.display_product(),\n                }\n            )\n            raise ValidationError({\"quantity\": ValidationError(message, code=e.code)})\n\n\nclass CheckoutLineInput(graphene.InputObjectType):\n    quantity = graphene.Int(required=True, description=\"The number of items purchased.\")\n    variant_id = graphene.ID(required=True, description=\"ID of the product variant.\")\n\n\nclass CheckoutCreateInput(graphene.InputObjectType):\n    lines = graphene.List(\n        CheckoutLineInput,\n        description=(\n            \"A list of checkout lines, each containing information about \"\n            \"an item in the checkout.\"\n        ),\n        required=True,\n    )\n    email = graphene.String(description=\"The customer's email address.\")\n    shipping_address = AddressInput(\n        description=(\n            \"The mailing address to where the checkout will be shipped. \"\n            \"Note: the address will be ignored if the checkout \"\n            \"doesn't contain shippable items.\"\n        )\n    )\n    billing_address = AddressInput(description=\"Billing address of the customer.\")\n\n\nclass CheckoutCreate(ModelMutation, I18nMixin):\n    created = graphene.Field(\n        graphene.Boolean,\n        description=(\n            \"Whether the checkout was created or the current active one was returned. \"\n            \"Refer to checkoutLinesAdd and checkoutLinesUpdate to merge a cart \"\n            \"with an active checkout.\"\n        ),\n    )\n\n    class Arguments:\n        input = CheckoutCreateInput(\n            required=True, description=\"Fields required to create checkout.\"\n        )\n\n    class Meta:\n        description = \"Create a new checkout.\"\n        model = models.Checkout\n        return_field_name = \"checkout\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def process_checkout_lines(\n        cls, lines, country\n    ) -> Tuple[List[product_models.ProductVariant], List[int]]:\n        variant_ids = [line.get(\"variant_id\") for line in lines]\n        variants = cls.get_nodes_or_error(\n            variant_ids,\n            \"variant_id\",\n            ProductVariant,\n            qs=product_models.ProductVariant.objects.prefetch_related(\n                \"product__product_type\"\n            ),\n        )\n        quantities = [line.get(\"quantity\") for line in lines]\n\n        check_lines_quantity(variants, quantities, country)\n\n        return variants, quantities\n\n    @classmethod\n    def retrieve_shipping_address(cls, user, data: dict) -> Optional[models.Address]:\n        if \"shipping_address\" in data:\n            return cls.validate_address(data[\"shipping_address\"])\n        if user.is_authenticated:\n            return user.default_shipping_address\n        return None\n\n    @classmethod\n    def retrieve_billing_address(cls, user, data: dict) -> Optional[models.Address]:\n        if \"billing_address\" in data:\n            return cls.validate_address(data[\"billing_address\"])\n        if user.is_authenticated:\n            return user.default_billing_address\n        return None\n\n    @classmethod\n    def clean_input(cls, info, instance: models.Checkout, data, input_cls=None):\n        cleaned_input = super().clean_input(info, instance, data)\n        user = info.context.user\n        country = info.context.country.code\n\n        # Resolve and process the lines, retrieving the variants and quantities\n        lines = data.pop(\"lines\", None)\n        if lines:\n            (\n                cleaned_input[\"variants\"],\n                cleaned_input[\"quantities\"],\n            ) = cls.process_checkout_lines(lines, country)\n\n        cleaned_input[\"shipping_address\"] = cls.retrieve_shipping_address(user, data)\n        cleaned_input[\"billing_address\"] = cls.retrieve_billing_address(user, data)\n\n        # Use authenticated user's email as default email\n        if user.is_authenticated:\n            email = data.pop(\"email\", None)\n            cleaned_input[\"email\"] = email or user.email\n\n        return cleaned_input\n\n    @classmethod\n    def save_addresses(cls, instance: models.Checkout, cleaned_input: dict):\n        shipping_address = cleaned_input.get(\"shipping_address\")\n        billing_address = cleaned_input.get(\"billing_address\")\n\n        updated_fields = [\"last_change\"]\n\n        if shipping_address and instance.is_shipping_required():\n            shipping_address.save()\n            instance.shipping_address = shipping_address.get_copy()\n            updated_fields.append(\"shipping_address\")\n        if billing_address:\n            billing_address.save()\n            instance.billing_address = billing_address.get_copy()\n            updated_fields.append(\"billing_address\")\n\n        # Note django will simply return if the list is empty\n        instance.save(update_fields=updated_fields)\n\n    @classmethod\n    @transaction.atomic()\n    def save(cls, info, instance: models.Checkout, cleaned_input):\n        # Create the checkout object\n        instance.save()\n        country = info.context.country\n        instance.set_country(country.code, commit=True)\n\n        # Retrieve the lines to create\n        variants = cleaned_input.get(\"variants\")\n        quantities = cleaned_input.get(\"quantities\")\n\n        # Create the checkout lines\n        if variants and quantities:\n            for variant, quantity in zip(variants, quantities):\n                try:\n                    add_variant_to_checkout(instance, variant, quantity)\n                except InsufficientStock as exc:\n                    raise ValidationError(\n                        f\"Insufficient product stock: {exc.item}\", code=exc.code\n                    )\n\n        # Save provided addresses and associate them to the checkout\n        cls.save_addresses(instance, cleaned_input)\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        user = info.context.user\n\n        # `perform_mutation` is overridden to properly get or create a checkout\n        # instance here and abort mutation if needed.\n        if user.is_authenticated:\n            checkout, _ = get_user_checkout(user)\n\n            if checkout is not None:\n                # If user has an active checkout, return it without any\n                # modifications.\n                return CheckoutCreate(checkout=checkout, created=False)\n\n            checkout = models.Checkout(user=user)\n        else:\n            checkout = models.Checkout()\n\n        cleaned_input = cls.clean_input(info, checkout, data.get(\"input\"))\n        checkout = cls.construct_instance(checkout, cleaned_input)\n        cls.clean_instance(info, checkout)\n        cls.save(info, checkout, cleaned_input)\n        cls._save_m2m(info, checkout, cleaned_input)\n        return CheckoutCreate(checkout=checkout, created=True)\n\n\nclass CheckoutLinesAdd(BaseMutation):\n    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")\n\n    class Arguments:\n        checkout_id = graphene.ID(description=\"The ID of the checkout.\", required=True)\n        lines = graphene.List(\n            CheckoutLineInput,\n            required=True,\n            description=(\n                \"A list of checkout lines, each containing information about \"\n                \"an item in the checkout.\"\n            ),\n        )\n\n    class Meta:\n        description = \"Adds a checkout line to the existing checkout.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id, lines, replace=False):\n        checkout = cls.get_node_or_error(\n            info, checkout_id, only_type=Checkout, field=\"checkout_id\"\n        )\n\n        variant_ids = [line.get(\"variant_id\") for line in lines]\n        variants = cls.get_nodes_or_error(variant_ids, \"variant_id\", ProductVariant)\n        quantities = [line.get(\"quantity\") for line in lines]\n\n        check_lines_quantity(variants, quantities, checkout.get_country())\n\n        if variants and quantities:\n            for variant, quantity in zip(variants, quantities):\n                try:\n                    add_variant_to_checkout(\n                        checkout, variant, quantity, replace=replace\n                    )\n                except InsufficientStock as exc:\n                    raise ValidationError(\n                        f\"Insufficient product stock: {exc.item}\", code=exc.code\n                    )\n\n        update_checkout_shipping_method_if_invalid(checkout, info.context.discounts)\n        recalculate_checkout_discount(checkout, info.context.discounts)\n\n        return CheckoutLinesAdd(checkout=checkout)\n\n\nclass CheckoutLinesUpdate(CheckoutLinesAdd):\n    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")\n\n    class Meta:\n        description = \"Updates checkout line in the existing checkout.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, root, info, checkout_id, lines):\n        return super().perform_mutation(root, info, checkout_id, lines, replace=True)\n\n\nclass CheckoutLineDelete(BaseMutation):\n    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")\n\n    class Arguments:\n        checkout_id = graphene.ID(description=\"The ID of the checkout.\", required=True)\n        line_id = graphene.ID(description=\"ID of the checkout line to delete.\")\n\n    class Meta:\n        description = \"Deletes a CheckoutLine.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id, line_id):\n        checkout = cls.get_node_or_error(\n            info, checkout_id, only_type=Checkout, field=\"checkout_id\"\n        )\n        line = cls.get_node_or_error(\n            info, line_id, only_type=CheckoutLine, field=\"line_id\"\n        )\n\n        if line and line in checkout.lines.all():\n            line.delete()\n\n        update_checkout_shipping_method_if_invalid(checkout, info.context.discounts)\n        recalculate_checkout_discount(checkout, info.context.discounts)\n\n        return CheckoutLineDelete(checkout=checkout)\n\n\nclass CheckoutCustomerAttach(BaseMutation):\n    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")\n\n    class Arguments:\n        checkout_id = graphene.ID(required=True, description=\"ID of the checkout.\")\n        customer_id = graphene.ID(\n            required=False,\n            description=(\n                \"The ID of the customer. DEPRECATED: This field is deprecated and will \"\n                \"be removed in Saleor 2.11. To identify a customer you should \"\n                \"authenticate with JWT token.\"\n            ),\n        )\n\n    class Meta:\n        description = \"Sets the customer as the owner of the checkout.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def check_permissions(cls, context):\n        return context.user.is_authenticated\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id, customer_id=None):\n        checkout = cls.get_node_or_error(\n            info, checkout_id, only_type=Checkout, field=\"checkout_id\"\n        )\n\n        # Check if provided customer_id matches with the authenticated user and raise\n        # error if it doesn't. This part can be removed when `customer_id` field is\n        # removed.\n        if customer_id:\n            current_user_id = graphene.Node.to_global_id(\"User\", info.context.user.id)\n            if current_user_id != customer_id:\n                raise PermissionDenied()\n\n        checkout.user = info.context.user\n        checkout.save(update_fields=[\"user\", \"last_change\"])\n        return CheckoutCustomerAttach(checkout=checkout)\n\n\nclass CheckoutCustomerDetach(BaseMutation):\n    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")\n\n    class Arguments:\n        checkout_id = graphene.ID(description=\"Checkout ID.\", required=True)\n\n    class Meta:\n        description = \"Removes the user assigned as the owner of the checkout.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def check_permissions(cls, context):\n        return context.user.is_authenticated\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id):\n        checkout = cls.get_node_or_error(\n            info, checkout_id, only_type=Checkout, field=\"checkout_id\"\n        )\n\n        # Raise error if the current user doesn't own the checkout of the given ID.\n        if checkout.user and checkout.user != info.context.user:\n            raise PermissionDenied()\n\n        checkout.user = None\n        checkout.save(update_fields=[\"user\", \"last_change\"])\n        return CheckoutCustomerDetach(checkout=checkout)\n\n\nclass CheckoutShippingAddressUpdate(BaseMutation, I18nMixin):\n    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")\n\n    class Arguments:\n        checkout_id = graphene.ID(required=True, description=\"ID of the checkout.\")\n        shipping_address = AddressInput(\n            required=True,\n            description=\"The mailing address to where the checkout will be shipped.\",\n        )\n\n    class Meta:\n        description = \"Update shipping address in the existing checkout.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id, shipping_address):\n        pk = from_global_id_strict_type(checkout_id, Checkout, field=\"checkout_id\")\n\n        try:\n            checkout = models.Checkout.objects.prefetch_related(\n                \"lines__variant__product__product_type\"\n            ).get(pk=pk)\n        except ObjectDoesNotExist:\n            raise ValidationError(\n                {\n                    \"checkout_id\": ValidationError(\n                        f\"Couldn't resolve to a node: {checkout_id}\",\n                        code=CheckoutErrorCode.NOT_FOUND,\n                    )\n                }\n            )\n\n        if not checkout.is_shipping_required():\n            raise ValidationError(\n                {\n                    \"shipping_address\": ValidationError(\n                        ERROR_DOES_NOT_SHIP,\n                        code=CheckoutErrorCode.SHIPPING_NOT_REQUIRED,\n                    )\n                }\n            )\n\n        shipping_address = cls.validate_address(\n            shipping_address, instance=checkout.shipping_address, info=info\n        )\n\n        update_checkout_shipping_method_if_invalid(checkout, info.context.discounts)\n\n        with transaction.atomic():\n            shipping_address.save()\n            change_shipping_address_in_checkout(checkout, shipping_address)\n        recalculate_checkout_discount(checkout, info.context.discounts)\n\n        return CheckoutShippingAddressUpdate(checkout=checkout)\n\n\nclass CheckoutBillingAddressUpdate(CheckoutShippingAddressUpdate):\n    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")\n\n    class Arguments:\n        checkout_id = graphene.ID(required=True, description=\"ID of the checkout.\")\n        billing_address = AddressInput(\n            required=True, description=\"The billing address of the checkout.\"\n        )\n\n    class Meta:\n        description = \"Update billing address in the existing checkout.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id, billing_address):\n        checkout = cls.get_node_or_error(\n            info, checkout_id, only_type=Checkout, field=\"checkout_id\"\n        )\n\n        billing_address = cls.validate_address(\n            billing_address, instance=checkout.billing_address, info=info\n        )\n        with transaction.atomic():\n            billing_address.save()\n            change_billing_address_in_checkout(checkout, billing_address)\n        return CheckoutBillingAddressUpdate(checkout=checkout)\n\n\nclass CheckoutEmailUpdate(BaseMutation):\n    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")\n\n    class Arguments:\n        checkout_id = graphene.ID(description=\"Checkout ID.\")\n        email = graphene.String(required=True, description=\"email.\")\n\n    class Meta:\n        description = \"Updates email address in the existing checkout object.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id, email):\n        checkout = cls.get_node_or_error(\n            info, checkout_id, only_type=Checkout, field=\"checkout_id\"\n        )\n\n        checkout.email = email\n        cls.clean_instance(info, checkout)\n        checkout.save(update_fields=[\"email\", \"last_change\"])\n        return CheckoutEmailUpdate(checkout=checkout)\n\n\nclass CheckoutShippingMethodUpdate(BaseMutation):\n    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")\n\n    class Arguments:\n        checkout_id = graphene.ID(description=\"Checkout ID.\")\n        shipping_method_id = graphene.ID(required=True, description=\"Shipping method.\")\n\n    class Meta:\n        description = \"Updates the shipping address of the checkout.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id, shipping_method_id):\n        pk = from_global_id_strict_type(\n            checkout_id, only_type=Checkout, field=\"checkout_id\"\n        )\n\n        try:\n            checkout = models.Checkout.objects.prefetch_related(\n                \"lines__variant__product__collections\",\n                \"lines__variant__product__product_type\",\n            ).get(pk=pk)\n        except ObjectDoesNotExist:\n            raise ValidationError(\n                {\n                    \"checkout_id\": ValidationError(\n                        f\"Couldn't resolve to a node: {checkout_id}\",\n                        code=CheckoutErrorCode.NOT_FOUND,\n                    )\n                }\n            )\n\n        if not checkout.is_shipping_required():\n            raise ValidationError(\n                {\n                    \"shipping_method\": ValidationError(\n                        ERROR_DOES_NOT_SHIP,\n                        code=CheckoutErrorCode.SHIPPING_NOT_REQUIRED,\n                    )\n                }\n            )\n\n        shipping_method = cls.get_node_or_error(\n            info,\n            shipping_method_id,\n            only_type=ShippingMethod,\n            field=\"shipping_method_id\",\n        )\n\n        shipping_method_is_valid = clean_shipping_method(\n            checkout=checkout, method=shipping_method, discounts=info.context.discounts\n        )\n\n        if not shipping_method_is_valid:\n            raise ValidationError(\n                {\n                    \"shipping_method\": ValidationError(\n                        \"This shipping method is not applicable.\",\n                        code=CheckoutErrorCode.SHIPPING_METHOD_NOT_APPLICABLE,\n                    )\n                }\n            )\n\n        checkout.shipping_method = shipping_method\n        checkout.save(update_fields=[\"shipping_method\", \"last_change\"])\n        recalculate_checkout_discount(checkout, info.context.discounts)\n\n        return CheckoutShippingMethodUpdate(checkout=checkout)\n\n\nclass CheckoutComplete(BaseMutation):\n    order = graphene.Field(Order, description=\"Placed order.\")\n\n    class Arguments:\n        checkout_id = graphene.ID(description=\"Checkout ID.\", required=True)\n        store_source = graphene.Boolean(\n            default_value=False,\n            description=(\n                \"Determines whether to store the payment source for future usage.\"\n            ),\n        )\n        redirect_url = graphene.String(\n            required=False,\n            description=(\n                \"URL of a view where users should be redirected to \"\n                \"see the order details. URL in RFC 1808 format.\"\n            ),\n        )\n\n    class Meta:\n        description = (\n            \"Completes the checkout. As a result a new order is created and \"\n            \"a payment charge is made. This action requires a successful \"\n            \"payment before it can be performed.\"\n        )\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id, store_source, **data):\n        checkout = cls.get_node_or_error(\n            info,\n            checkout_id,\n            only_type=Checkout,\n            field=\"checkout_id\",\n            qs=models.Checkout.objects.prefetch_related(\n                \"gift_cards\",\n                \"lines\",\n                Prefetch(\n                    \"payments\",\n                    queryset=payment_models.Payment.objects.prefetch_related(\n                        \"order\", \"order__lines\"\n                    ),\n                ),\n            ).select_related(\"shipping_method\", \"shipping_method__shipping_zone\"),\n        )\n\n        discounts = info.context.discounts\n        user = info.context.user\n        clean_checkout(checkout, discounts)\n\n        payment = checkout.get_last_active_payment()\n\n        with transaction.atomic():\n            try:\n                order_data = prepare_order_data(\n                    checkout=checkout,\n                    tracking_code=analytics.get_client_id(info.context),\n                    discounts=discounts,\n                )\n            except InsufficientStock as e:\n                raise ValidationError(\n                    f\"Insufficient product stock: {e.item}\", code=e.code\n                )\n            except voucher_model.NotApplicable:\n                raise ValidationError(\n                    \"Voucher not applicable\",\n                    code=CheckoutErrorCode.VOUCHER_NOT_APPLICABLE,\n                )\n            except TaxError as tax_error:\n                return ValidationError(\n                    \"Unable to calculate taxes - %s\" % str(tax_error),\n                    code=CheckoutErrorCode.TAX_ERROR,\n                )\n\n        billing_address = order_data[\"billing_address\"]\n        shipping_address = order_data.get(\"shipping_address\", None)\n\n        billing_address = AddressData(**billing_address.as_data())\n\n        if shipping_address is not None:\n            shipping_address = AddressData(**shipping_address.as_data())\n\n        try:\n            txn = gateway.process_payment(\n                payment=payment, token=payment.token, store_source=store_source\n            )\n\n            if not txn.is_success:\n                raise PaymentError(txn.error)\n\n        except PaymentError as e:\n            abort_order_data(order_data)\n            raise ValidationError(str(e), code=CheckoutErrorCode.PAYMENT_ERROR)\n\n        if txn.customer_id and user.is_authenticated:\n            store_customer_id(user, payment.gateway, txn.customer_id)\n\n        redirect_url = data.get(\"redirect_url\", \"\")\n        if redirect_url:\n            try:\n                validate_storefront_url(redirect_url)\n            except ValidationError as error:\n                raise ValidationError(\n                    {\"redirect_url\": error}, code=AccountErrorCode.INVALID\n                )\n\n        # create the order into the database\n        order = create_order(\n            checkout=checkout,\n            order_data=order_data,\n            user=user,\n            redirect_url=redirect_url,\n        )\n\n        # remove checkout after order is successfully paid\n        checkout.delete()\n\n        # return the success response with the newly created order data\n        return CheckoutComplete(order=order)\n\n\nclass CheckoutAddPromoCode(BaseMutation):\n    checkout = graphene.Field(\n        Checkout, description=\"The checkout with the added gift card or voucher.\"\n    )\n\n    class Arguments:\n        checkout_id = graphene.ID(description=\"Checkout ID.\", required=True)\n        promo_code = graphene.String(\n            description=\"Gift card code or voucher code.\", required=True\n        )\n\n    class Meta:\n        description = \"Adds a gift card or a voucher to a checkout.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id, promo_code):\n        checkout = cls.get_node_or_error(\n            info, checkout_id, only_type=Checkout, field=\"checkout_id\"\n        )\n        add_promo_code_to_checkout(checkout, promo_code, info.context.discounts)\n        return CheckoutAddPromoCode(checkout=checkout)\n\n\nclass CheckoutRemovePromoCode(BaseMutation):\n    checkout = graphene.Field(\n        Checkout, description=\"The checkout with the removed gift card or voucher.\"\n    )\n\n    class Arguments:\n        checkout_id = graphene.ID(description=\"Checkout ID.\", required=True)\n        promo_code = graphene.String(\n            description=\"Gift card code or voucher code.\", required=True\n        )\n\n    class Meta:\n        description = \"Remove a gift card or a voucher from a checkout.\"\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, checkout_id, promo_code):\n        checkout = cls.get_node_or_error(\n            info, checkout_id, only_type=Checkout, field=\"checkout_id\"\n        )\n        remove_promo_code_from_checkout(checkout, promo_code)\n        return CheckoutRemovePromoCode(checkout=checkout)\n\n\nclass CheckoutUpdateMeta(UpdateMetaBaseMutation):\n    class Meta:\n        description = \"Updates metadata for checkout.\"\n        permissions = (OrderPermissions.MANAGE_ORDERS,)\n        model = models.Checkout\n        public = True\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n\nclass CheckoutUpdatePrivateMeta(UpdateMetaBaseMutation):\n    class Meta:\n        description = \"Updates private metadata for checkout.\"\n        permissions = (OrderPermissions.MANAGE_ORDERS,)\n        model = models.Checkout\n        public = False\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n\nclass CheckoutClearMeta(ClearMetaBaseMutation):\n    class Meta:\n        description = \"Clear metadata for checkout.\"\n        permissions = (OrderPermissions.MANAGE_ORDERS,)\n        model = models.Checkout\n        public = True\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n\n\nclass CheckoutClearPrivateMeta(ClearMetaBaseMutation):\n    class Meta:\n        description = \"Clear private metadata for checkout.\"\n        permissions = (OrderPermissions.MANAGE_ORDERS,)\n        model = models.Checkout\n        public = False\n        error_type_class = CheckoutError\n        error_type_field = \"checkout_errors\"\n", "schema {\n  query: Query\n  mutation: Mutation\n}\n\ntype AccountAddressCreate {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n  address: Address\n}\n\ntype AccountAddressDelete {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n  address: Address\n}\n\ntype AccountAddressUpdate {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n  address: Address\n}\n\ntype AccountDelete {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ntype AccountError {\n  field: String\n  message: String\n  code: AccountErrorCode\n}\n\nenum AccountErrorCode {\n  ACTIVATE_OWN_ACCOUNT\n  ACTIVATE_SUPERUSER_ACCOUNT\n  ASSIGN_NON_STAFF_MEMBER\n  DEACTIVATE_OWN_ACCOUNT\n  DEACTIVATE_SUPERUSER_ACCOUNT\n  DELETE_NON_STAFF_USER\n  DELETE_OWN_ACCOUNT\n  DELETE_STAFF_ACCOUNT\n  DELETE_SUPERUSER_ACCOUNT\n  GRAPHQL_ERROR\n  INVALID\n  INVALID_PASSWORD\n  NOT_FOUND\n  PASSWORD_ENTIRELY_NUMERIC\n  PASSWORD_TOO_COMMON\n  PASSWORD_TOO_SHORT\n  PASSWORD_TOO_SIMILAR\n  REQUIRED\n  UNIQUE\n}\n\ninput AccountInput {\n  firstName: String\n  lastName: String\n  defaultBillingAddress: AddressInput\n  defaultShippingAddress: AddressInput\n}\n\ntype AccountRegister {\n  errors: [Error!]\n  requiresConfirmation: Boolean\n  accountErrors: [AccountError!]\n  user: User\n}\n\ninput AccountRegisterInput {\n  email: String!\n  password: String!\n  redirectUrl: String!\n}\n\ntype AccountRequestDeletion {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n}\n\ntype AccountSetDefaultAddress {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n}\n\ntype AccountUpdate {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ntype AccountUpdateMeta {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ntype Address implements Node {\n  id: ID!\n  firstName: String!\n  lastName: String!\n  companyName: String!\n  streetAddress1: String!\n  streetAddress2: String!\n  city: String!\n  cityArea: String!\n  postalCode: String!\n  country: CountryDisplay!\n  countryArea: String!\n  phone: String\n  isDefaultShippingAddress: Boolean\n  isDefaultBillingAddress: Boolean\n}\n\ntype AddressCreate {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n  address: Address\n}\n\ntype AddressDelete {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n  address: Address\n}\n\ninput AddressInput {\n  firstName: String\n  lastName: String\n  companyName: String\n  streetAddress1: String\n  streetAddress2: String\n  city: String\n  cityArea: String\n  postalCode: String\n  country: CountryCode\n  countryArea: String\n  phone: String\n}\n\ntype AddressSetDefault {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n}\n\nenum AddressTypeEnum {\n  BILLING\n  SHIPPING\n}\n\ntype AddressUpdate {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n  address: Address\n}\n\ntype AddressValidationData {\n  countryCode: String\n  countryName: String\n  addressFormat: String\n  addressLatinFormat: String\n  allowedFields: [String]\n  requiredFields: [String]\n  upperFields: [String]\n  countryAreaType: String\n  countryAreaChoices: [ChoiceValue]\n  cityType: String\n  cityChoices: [ChoiceValue]\n  cityAreaType: String\n  cityAreaChoices: [ChoiceValue]\n  postalCodeType: String\n  postalCodeMatchers: [String]\n  postalCodeExamples: [String]\n  postalCodePrefix: String\n}\n\ntype AssignNavigation {\n  errors: [Error!]\n  menu: Menu\n  menuErrors: [MenuError!]\n}\n\ntype Attribute implements Node {\n  id: ID!\n  productTypes(before: String, after: String, first: Int, last: Int): ProductTypeCountableConnection!\n  productVariantTypes(before: String, after: String, first: Int, last: Int): ProductTypeCountableConnection!\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  inputType: AttributeInputTypeEnum\n  name: String\n  slug: String\n  values: [AttributeValue]\n  valueRequired: Boolean!\n  visibleInStorefront: Boolean!\n  filterableInStorefront: Boolean!\n  filterableInDashboard: Boolean!\n  availableInGrid: Boolean!\n  translation(languageCode: LanguageCodeEnum!): AttributeTranslation\n  storefrontSearchPosition: Int!\n}\n\ntype AttributeAssign {\n  errors: [Error!]\n  productType: ProductType\n  productErrors: [ProductError!]\n}\n\ninput AttributeAssignInput {\n  id: ID!\n  type: AttributeTypeEnum!\n}\n\ntype AttributeBulkDelete {\n  errors: [Error!]\n  count: Int!\n  productErrors: [ProductError!]\n}\n\ntype AttributeClearMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  attribute: Attribute\n}\n\ntype AttributeClearPrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  attribute: Attribute\n}\n\ntype AttributeCountableConnection {\n  pageInfo: PageInfo!\n  edges: [AttributeCountableEdge!]!\n  totalCount: Int\n}\n\ntype AttributeCountableEdge {\n  node: Attribute!\n  cursor: String!\n}\n\ntype AttributeCreate {\n  errors: [Error!]\n  attribute: Attribute\n  productErrors: [ProductError!]\n}\n\ninput AttributeCreateInput {\n  inputType: AttributeInputTypeEnum\n  name: String!\n  slug: String\n  values: [AttributeValueCreateInput]\n  valueRequired: Boolean\n  isVariantOnly: Boolean\n  visibleInStorefront: Boolean\n  filterableInStorefront: Boolean\n  filterableInDashboard: Boolean\n  storefrontSearchPosition: Int\n  availableInGrid: Boolean\n}\n\ntype AttributeDelete {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  attribute: Attribute\n}\n\ninput AttributeFilterInput {\n  valueRequired: Boolean\n  isVariantOnly: Boolean\n  visibleInStorefront: Boolean\n  filterableInStorefront: Boolean\n  filterableInDashboard: Boolean\n  availableInGrid: Boolean\n  search: String\n  ids: [ID]\n  inCollection: ID\n  inCategory: ID\n}\n\ninput AttributeInput {\n  slug: String!\n  value: String\n  values: [String]\n}\n\nenum AttributeInputTypeEnum {\n  DROPDOWN\n  MULTISELECT\n}\n\ntype AttributeReorderValues {\n  errors: [Error!]\n  attribute: Attribute\n  productErrors: [ProductError!]\n}\n\nenum AttributeSortField {\n  NAME\n  SLUG\n  VALUE_REQUIRED\n  IS_VARIANT_ONLY\n  VISIBLE_IN_STOREFRONT\n  FILTERABLE_IN_STOREFRONT\n  FILTERABLE_IN_DASHBOARD\n  DASHBOARD_VARIANT_POSITION\n  DASHBOARD_PRODUCT_POSITION\n  STOREFRONT_SEARCH_POSITION\n  AVAILABLE_IN_GRID\n}\n\ninput AttributeSortingInput {\n  direction: OrderDirection!\n  field: AttributeSortField!\n}\n\ntype AttributeTranslatableContent implements Node {\n  id: ID!\n  name: String!\n  translation(languageCode: LanguageCodeEnum!): AttributeTranslation\n  attribute: Attribute\n}\n\ntype AttributeTranslate {\n  errors: [Error!]\n  attribute: Attribute\n}\n\ntype AttributeTranslation implements Node {\n  id: ID!\n  name: String!\n  language: LanguageDisplay!\n}\n\nenum AttributeTypeEnum {\n  PRODUCT\n  VARIANT\n}\n\ntype AttributeUnassign {\n  errors: [Error!]\n  productType: ProductType\n  productErrors: [ProductError!]\n}\n\ntype AttributeUpdate {\n  errors: [Error!]\n  attribute: Attribute\n  productErrors: [ProductError!]\n}\n\ninput AttributeUpdateInput {\n  name: String\n  slug: String\n  removeValues: [ID]\n  addValues: [AttributeValueCreateInput]\n  valueRequired: Boolean\n  isVariantOnly: Boolean\n  visibleInStorefront: Boolean\n  filterableInStorefront: Boolean\n  filterableInDashboard: Boolean\n  storefrontSearchPosition: Int\n  availableInGrid: Boolean\n}\n\ntype AttributeUpdateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  attribute: Attribute\n}\n\ntype AttributeUpdatePrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  attribute: Attribute\n}\n\ntype AttributeValue implements Node {\n  id: ID!\n  name: String\n  slug: String\n  type: AttributeValueType\n  translation(languageCode: LanguageCodeEnum!): AttributeValueTranslation\n  inputType: AttributeInputTypeEnum\n}\n\ntype AttributeValueBulkDelete {\n  errors: [Error!]\n  count: Int!\n  productErrors: [ProductError!]\n}\n\ntype AttributeValueCreate {\n  errors: [Error!]\n  attribute: Attribute\n  productErrors: [ProductError!]\n  attributeValue: AttributeValue\n}\n\ninput AttributeValueCreateInput {\n  name: String!\n}\n\ntype AttributeValueDelete {\n  errors: [Error!]\n  attribute: Attribute\n  productErrors: [ProductError!]\n  attributeValue: AttributeValue\n}\n\ninput AttributeValueInput {\n  id: ID\n  values: [String]!\n}\n\ntype AttributeValueTranslatableContent implements Node {\n  id: ID!\n  name: String!\n  translation(languageCode: LanguageCodeEnum!): AttributeValueTranslation\n  attributeValue: AttributeValue\n}\n\ntype AttributeValueTranslate {\n  errors: [Error!]\n  attributeValue: AttributeValue\n}\n\ntype AttributeValueTranslation implements Node {\n  id: ID!\n  name: String!\n  language: LanguageDisplay!\n}\n\nenum AttributeValueType {\n  COLOR\n  GRADIENT\n  URL\n  STRING\n}\n\ntype AttributeValueUpdate {\n  errors: [Error!]\n  attribute: Attribute\n  productErrors: [ProductError!]\n  attributeValue: AttributeValue\n}\n\ntype AuthorizationKey {\n  name: AuthorizationKeyType!\n  key: String!\n}\n\ntype AuthorizationKeyAdd {\n  errors: [Error!]\n  authorizationKey: AuthorizationKey\n  shop: Shop\n  shopErrors: [ShopError!]\n}\n\ntype AuthorizationKeyDelete {\n  errors: [Error!]\n  authorizationKey: AuthorizationKey\n  shop: Shop\n  shopErrors: [ShopError!]\n}\n\ninput AuthorizationKeyInput {\n  key: String!\n  password: String!\n}\n\nenum AuthorizationKeyType {\n  FACEBOOK\n  GOOGLE_OAUTH2\n}\n\ntype BulkProductError {\n  field: String\n  message: String\n  code: ProductErrorCode\n  index: Int\n}\n\ninput CatalogueInput {\n  products: [ID]\n  categories: [ID]\n  collections: [ID]\n}\n\ntype Category implements Node {\n  seoTitle: String\n  seoDescription: String\n  id: ID!\n  name: String!\n  description: String!\n  descriptionJson: JSONString!\n  slug: String!\n  parent: Category\n  level: Int!\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  ancestors(before: String, after: String, first: Int, last: Int): CategoryCountableConnection\n  products(before: String, after: String, first: Int, last: Int): ProductCountableConnection\n  url: String\n  children(before: String, after: String, first: Int, last: Int): CategoryCountableConnection\n  backgroundImage(size: Int): Image\n  translation(languageCode: LanguageCodeEnum!): CategoryTranslation\n}\n\ntype CategoryBulkDelete {\n  errors: [Error!]\n  count: Int!\n  productErrors: [ProductError!]\n}\n\ntype CategoryClearMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  category: Category\n}\n\ntype CategoryClearPrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  category: Category\n}\n\ntype CategoryCountableConnection {\n  pageInfo: PageInfo!\n  edges: [CategoryCountableEdge!]!\n  totalCount: Int\n}\n\ntype CategoryCountableEdge {\n  node: Category!\n  cursor: String!\n}\n\ntype CategoryCreate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  category: Category\n}\n\ntype CategoryDelete {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  category: Category\n}\n\ninput CategoryFilterInput {\n  search: String\n  ids: [ID]\n}\n\ninput CategoryInput {\n  description: String\n  descriptionJson: JSONString\n  name: String\n  slug: String\n  seo: SeoInput\n  backgroundImage: Upload\n  backgroundImageAlt: String\n}\n\nenum CategorySortField {\n  NAME\n  PRODUCT_COUNT\n  SUBCATEGORY_COUNT\n}\n\ninput CategorySortingInput {\n  direction: OrderDirection!\n  field: CategorySortField!\n}\n\ntype CategoryTranslatableContent implements Node {\n  seoTitle: String\n  seoDescription: String\n  id: ID!\n  name: String!\n  description: String!\n  descriptionJson: JSONString!\n  translation(languageCode: LanguageCodeEnum!): CategoryTranslation\n  category: Category\n}\n\ntype CategoryTranslate {\n  errors: [Error!]\n  category: Category\n}\n\ntype CategoryTranslation implements Node {\n  seoTitle: String\n  seoDescription: String\n  id: ID!\n  name: String!\n  description: String!\n  descriptionJson: JSONString!\n  language: LanguageDisplay!\n}\n\ntype CategoryUpdate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  category: Category\n}\n\ntype CategoryUpdateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  category: Category\n}\n\ntype CategoryUpdatePrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  category: Category\n}\n\ntype Checkout implements Node {\n  created: DateTime!\n  lastChange: DateTime!\n  user: User\n  token: UUID!\n  quantity: Int!\n  billingAddress: Address\n  shippingAddress: Address\n  shippingMethod: ShippingMethod\n  note: String!\n  discount: Money\n  discountName: String\n  translatedDiscountName: String\n  voucherCode: String\n  giftCards: [GiftCard]\n  id: ID!\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  availableShippingMethods: [ShippingMethod]!\n  availablePaymentGateways: [PaymentGateway]!\n  email: String!\n  isShippingRequired: Boolean!\n  lines: [CheckoutLine]\n  shippingPrice: TaxedMoney\n  subtotalPrice: TaxedMoney\n  totalPrice: TaxedMoney\n}\n\ntype CheckoutAddPromoCode {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutBillingAddressUpdate {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutClearMeta {\n  errors: [Error!]\n  checkoutErrors: [CheckoutError!]\n  checkout: Checkout\n}\n\ntype CheckoutClearPrivateMeta {\n  errors: [Error!]\n  checkoutErrors: [CheckoutError!]\n  checkout: Checkout\n}\n\ntype CheckoutComplete {\n  errors: [Error!]\n  order: Order\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutCountableConnection {\n  pageInfo: PageInfo!\n  edges: [CheckoutCountableEdge!]!\n  totalCount: Int\n}\n\ntype CheckoutCountableEdge {\n  node: Checkout!\n  cursor: String!\n}\n\ntype CheckoutCreate {\n  errors: [Error!]\n  created: Boolean\n  checkoutErrors: [CheckoutError!]\n  checkout: Checkout\n}\n\ninput CheckoutCreateInput {\n  lines: [CheckoutLineInput]!\n  email: String\n  shippingAddress: AddressInput\n  billingAddress: AddressInput\n}\n\ntype CheckoutCustomerAttach {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutCustomerDetach {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutEmailUpdate {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutError {\n  field: String\n  message: String\n  code: CheckoutErrorCode\n}\n\nenum CheckoutErrorCode {\n  BILLING_ADDRESS_NOT_SET\n  CHECKOUT_NOT_FULLY_PAID\n  GRAPHQL_ERROR\n  INSUFFICIENT_STOCK\n  INVALID\n  INVALID_SHIPPING_METHOD\n  NOT_FOUND\n  PAYMENT_ERROR\n  QUANTITY_GREATER_THAN_LIMIT\n  REQUIRED\n  SHIPPING_ADDRESS_NOT_SET\n  SHIPPING_METHOD_NOT_APPLICABLE\n  SHIPPING_METHOD_NOT_SET\n  SHIPPING_NOT_REQUIRED\n  TAX_ERROR\n  UNIQUE\n  VOUCHER_NOT_APPLICABLE\n  ZERO_QUANTITY\n}\n\ntype CheckoutLine implements Node {\n  id: ID!\n  variant: ProductVariant!\n  quantity: Int!\n  totalPrice: TaxedMoney\n  requiresShipping: Boolean\n}\n\ntype CheckoutLineCountableConnection {\n  pageInfo: PageInfo!\n  edges: [CheckoutLineCountableEdge!]!\n  totalCount: Int\n}\n\ntype CheckoutLineCountableEdge {\n  node: CheckoutLine!\n  cursor: String!\n}\n\ntype CheckoutLineDelete {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ninput CheckoutLineInput {\n  quantity: Int!\n  variantId: ID!\n}\n\ntype CheckoutLinesAdd {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutLinesUpdate {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutPaymentCreate {\n  errors: [Error!]\n  checkout: Checkout\n  payment: Payment\n  paymentErrors: [PaymentError!]\n}\n\ntype CheckoutRemovePromoCode {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutShippingAddressUpdate {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutShippingMethodUpdate {\n  errors: [Error!]\n  checkout: Checkout\n  checkoutErrors: [CheckoutError!]\n}\n\ntype CheckoutUpdateMeta {\n  errors: [Error!]\n  checkoutErrors: [CheckoutError!]\n  checkout: Checkout\n}\n\ntype CheckoutUpdatePrivateMeta {\n  errors: [Error!]\n  checkoutErrors: [CheckoutError!]\n  checkout: Checkout\n}\n\ntype ChoiceValue {\n  raw: String\n  verbose: String\n}\n\ntype Collection implements Node {\n  seoTitle: String\n  seoDescription: String\n  id: ID!\n  name: String!\n  description: String!\n  descriptionJson: JSONString!\n  publicationDate: Date\n  isPublished: Boolean!\n  slug: String!\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  products(before: String, after: String, first: Int, last: Int): ProductCountableConnection\n  backgroundImage(size: Int): Image\n  translation(languageCode: LanguageCodeEnum!): CollectionTranslation\n}\n\ntype CollectionAddProducts {\n  errors: [Error!]\n  collection: Collection\n  productErrors: [ProductError!]\n}\n\ntype CollectionBulkDelete {\n  errors: [Error!]\n  count: Int!\n  productErrors: [ProductError!]\n}\n\ntype CollectionBulkPublish {\n  errors: [Error!]\n  count: Int!\n  productErrors: [ProductError!]\n}\n\ntype CollectionClearMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  collection: Collection\n}\n\ntype CollectionClearPrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  collection: Collection\n}\n\ntype CollectionCountableConnection {\n  pageInfo: PageInfo!\n  edges: [CollectionCountableEdge!]!\n  totalCount: Int\n}\n\ntype CollectionCountableEdge {\n  node: Collection!\n  cursor: String!\n}\n\ntype CollectionCreate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  collection: Collection\n}\n\ninput CollectionCreateInput {\n  isPublished: Boolean\n  name: String\n  slug: String\n  description: String\n  descriptionJson: JSONString\n  backgroundImage: Upload\n  backgroundImageAlt: String\n  seo: SeoInput\n  publicationDate: Date\n  products: [ID]\n}\n\ntype CollectionDelete {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  collection: Collection\n}\n\ninput CollectionFilterInput {\n  published: CollectionPublished\n  search: String\n  ids: [ID]\n}\n\ninput CollectionInput {\n  isPublished: Boolean\n  name: String\n  slug: String\n  description: String\n  descriptionJson: JSONString\n  backgroundImage: Upload\n  backgroundImageAlt: String\n  seo: SeoInput\n  publicationDate: Date\n}\n\nenum CollectionPublished {\n  PUBLISHED\n  HIDDEN\n}\n\ntype CollectionRemoveProducts {\n  errors: [Error!]\n  collection: Collection\n  productErrors: [ProductError!]\n}\n\ntype CollectionReorderProducts {\n  errors: [Error!]\n  collection: Collection\n  productErrors: [ProductError!]\n}\n\nenum CollectionSortField {\n  NAME\n  AVAILABILITY\n  PRODUCT_COUNT\n}\n\ninput CollectionSortingInput {\n  direction: OrderDirection!\n  field: CollectionSortField!\n}\n\ntype CollectionTranslatableContent implements Node {\n  seoTitle: String\n  seoDescription: String\n  id: ID!\n  name: String!\n  description: String!\n  descriptionJson: JSONString!\n  translation(languageCode: LanguageCodeEnum!): CollectionTranslation\n  collection: Collection\n}\n\ntype CollectionTranslate {\n  errors: [Error!]\n  collection: Collection\n}\n\ntype CollectionTranslation implements Node {\n  seoTitle: String\n  seoDescription: String\n  id: ID!\n  name: String!\n  description: String!\n  descriptionJson: JSONString!\n  language: LanguageDisplay!\n}\n\ntype CollectionUpdate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  collection: Collection\n}\n\ntype CollectionUpdateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  collection: Collection\n}\n\ntype CollectionUpdatePrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  collection: Collection\n}\n\ntype ConfigurationItem {\n  name: String!\n  value: String\n  type: ConfigurationTypeFieldEnum\n  helpText: String\n  label: String\n}\n\ninput ConfigurationItemInput {\n  name: String!\n  value: String\n}\n\nenum ConfigurationTypeFieldEnum {\n  STRING\n  BOOLEAN\n  SECRET\n  PASSWORD\n}\n\ntype ConfirmAccount {\n  errors: [Error!]\n}\n\ntype ConfirmEmailChange {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n}\n\nenum CountryCode {\n  AF\n  AX\n  AL\n  DZ\n  AS\n  AD\n  AO\n  AI\n  AQ\n  AG\n  AR\n  AM\n  AW\n  AU\n  AT\n  AZ\n  BS\n  BH\n  BD\n  BB\n  BY\n  BE\n  BZ\n  BJ\n  BM\n  BT\n  BO\n  BQ\n  BA\n  BW\n  BV\n  BR\n  IO\n  BN\n  BG\n  BF\n  BI\n  CV\n  KH\n  CM\n  CA\n  KY\n  CF\n  TD\n  CL\n  CN\n  CX\n  CC\n  CO\n  KM\n  CG\n  CD\n  CK\n  CR\n  CI\n  HR\n  CU\n  CW\n  CY\n  CZ\n  DK\n  DJ\n  DM\n  DO\n  EC\n  EG\n  SV\n  GQ\n  ER\n  EE\n  SZ\n  ET\n  EU\n  FK\n  FO\n  FJ\n  FI\n  FR\n  GF\n  PF\n  TF\n  GA\n  GM\n  GE\n  DE\n  GH\n  GI\n  GR\n  GL\n  GD\n  GP\n  GU\n  GT\n  GG\n  GN\n  GW\n  GY\n  HT\n  HM\n  VA\n  HN\n  HK\n  HU\n  IS\n  IN\n  ID\n  IR\n  IQ\n  IE\n  IM\n  IL\n  IT\n  JM\n  JP\n  JE\n  JO\n  KZ\n  KE\n  KI\n  KW\n  KG\n  LA\n  LV\n  LB\n  LS\n  LR\n  LY\n  LI\n  LT\n  LU\n  MO\n  MG\n  MW\n  MY\n  MV\n  ML\n  MT\n  MH\n  MQ\n  MR\n  MU\n  YT\n  MX\n  FM\n  MD\n  MC\n  MN\n  ME\n  MS\n  MA\n  MZ\n  MM\n  NA\n  NR\n  NP\n  NL\n  NC\n  NZ\n  NI\n  NE\n  NG\n  NU\n  NF\n  KP\n  MK\n  MP\n  NO\n  OM\n  PK\n  PW\n  PS\n  PA\n  PG\n  PY\n  PE\n  PH\n  PN\n  PL\n  PT\n  PR\n  QA\n  RE\n  RO\n  RU\n  RW\n  BL\n  SH\n  KN\n  LC\n  MF\n  PM\n  VC\n  WS\n  SM\n  ST\n  SA\n  SN\n  RS\n  SC\n  SL\n  SG\n  SX\n  SK\n  SI\n  SB\n  SO\n  ZA\n  GS\n  KR\n  SS\n  ES\n  LK\n  SD\n  SR\n  SJ\n  SE\n  CH\n  SY\n  TW\n  TJ\n  TZ\n  TH\n  TL\n  TG\n  TK\n  TO\n  TT\n  TN\n  TR\n  TM\n  TC\n  TV\n  UG\n  UA\n  AE\n  GB\n  UM\n  US\n  UY\n  UZ\n  VU\n  VE\n  VN\n  VG\n  VI\n  WF\n  EH\n  YE\n  ZM\n  ZW\n}\n\ntype CountryDisplay {\n  code: String!\n  country: String!\n  vat: VAT\n}\n\ntype CreateToken {\n  token: String\n  errors: [Error]!\n  user: User\n}\n\ntype CreditCard {\n  brand: String!\n  firstDigits: String!\n  lastDigits: String!\n  expMonth: Int!\n  expYear: Int!\n}\n\ntype CustomerBulkDelete {\n  errors: [Error!]\n  count: Int!\n  accountErrors: [AccountError!]\n}\n\ntype CustomerCreate {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ntype CustomerDelete {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ntype CustomerEvent implements Node {\n  id: ID!\n  date: DateTime\n  type: CustomerEventsEnum\n  user(id: ID): User\n  message: String\n  count: Int\n  order: Order\n  orderLine: OrderLine\n}\n\nenum CustomerEventsEnum {\n  ACCOUNT_CREATED\n  PASSWORD_RESET_LINK_SENT\n  PASSWORD_RESET\n  EMAIL_CHANGED_REQUEST\n  PASSWORD_CHANGED\n  EMAIL_CHANGED\n  PLACED_ORDER\n  NOTE_ADDED_TO_ORDER\n  DIGITAL_LINK_DOWNLOADED\n  CUSTOMER_DELETED\n  NAME_ASSIGNED\n  EMAIL_ASSIGNED\n  NOTE_ADDED\n}\n\ninput CustomerFilterInput {\n  dateJoined: DateRangeInput\n  moneySpent: PriceRangeInput\n  numberOfOrders: IntRangeInput\n  placedOrders: DateRangeInput\n  search: String\n}\n\ninput CustomerInput {\n  defaultBillingAddress: AddressInput\n  defaultShippingAddress: AddressInput\n  firstName: String\n  lastName: String\n  email: String\n  isActive: Boolean\n  note: String\n}\n\ntype CustomerUpdate {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\nscalar Date\n\ninput DateRangeInput {\n  gte: Date\n  lte: Date\n}\n\nscalar DateTime\n\ninput DateTimeRangeInput {\n  gte: DateTime\n  lte: DateTime\n}\n\nscalar Decimal\n\ntype DigitalContent implements Node {\n  useDefaultSettings: Boolean!\n  automaticFulfillment: Boolean!\n  productVariant: ProductVariant!\n  contentFile: String!\n  maxDownloads: Int\n  urlValidDays: Int\n  urls: [DigitalContentUrl]\n  id: ID!\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n}\n\ntype DigitalContentCountableConnection {\n  pageInfo: PageInfo!\n  edges: [DigitalContentCountableEdge!]!\n  totalCount: Int\n}\n\ntype DigitalContentCountableEdge {\n  node: DigitalContent!\n  cursor: String!\n}\n\ntype DigitalContentCreate {\n  errors: [Error!]\n  variant: ProductVariant\n  content: DigitalContent\n  productErrors: [ProductError!]\n}\n\ntype DigitalContentDelete {\n  errors: [Error!]\n  variant: ProductVariant\n  productErrors: [ProductError!]\n}\n\ninput DigitalContentInput {\n  useDefaultSettings: Boolean!\n  maxDownloads: Int\n  urlValidDays: Int\n  automaticFulfillment: Boolean\n}\n\ntype DigitalContentUpdate {\n  errors: [Error!]\n  variant: ProductVariant\n  content: DigitalContent\n  productErrors: [ProductError!]\n}\n\ninput DigitalContentUploadInput {\n  useDefaultSettings: Boolean!\n  maxDownloads: Int\n  urlValidDays: Int\n  automaticFulfillment: Boolean\n  contentFile: Upload!\n}\n\ntype DigitalContentUrl implements Node {\n  token: UUID!\n  content: DigitalContent!\n  created: DateTime!\n  downloadNum: Int!\n  id: ID!\n  url: String\n}\n\ntype DigitalContentUrlCreate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  digitalContentUrl: DigitalContentUrl\n}\n\ninput DigitalContentUrlCreateInput {\n  content: ID!\n}\n\nenum DiscountStatusEnum {\n  ACTIVE\n  EXPIRED\n  SCHEDULED\n}\n\nenum DiscountValueTypeEnum {\n  FIXED\n  PERCENTAGE\n}\n\ntype Domain {\n  host: String!\n  sslEnabled: Boolean!\n  url: String!\n}\n\ntype DraftOrderBulkDelete {\n  errors: [Error!]\n  count: Int!\n  orderErrors: [OrderError!]\n}\n\ntype DraftOrderComplete {\n  errors: [Error!]\n  order: Order\n  orderErrors: [OrderError!]\n}\n\ntype DraftOrderCreate {\n  errors: [Error!]\n  orderErrors: [OrderError!]\n  order: Order\n}\n\ninput DraftOrderCreateInput {\n  billingAddress: AddressInput\n  user: ID\n  userEmail: String\n  discount: Decimal\n  shippingAddress: AddressInput\n  shippingMethod: ID\n  voucher: ID\n  customerNote: String\n  lines: [OrderLineCreateInput]\n}\n\ntype DraftOrderDelete {\n  errors: [Error!]\n  orderErrors: [OrderError!]\n  order: Order\n}\n\ninput DraftOrderInput {\n  billingAddress: AddressInput\n  user: ID\n  userEmail: String\n  discount: Decimal\n  shippingAddress: AddressInput\n  shippingMethod: ID\n  voucher: ID\n  customerNote: String\n}\n\ntype DraftOrderLineDelete {\n  errors: [Error!]\n  order: Order\n  orderLine: OrderLine\n  orderErrors: [OrderError!]\n}\n\ntype DraftOrderLineUpdate {\n  errors: [Error!]\n  order: Order\n  orderErrors: [OrderError!]\n  orderLine: OrderLine\n}\n\ntype DraftOrderLinesBulkDelete {\n  errors: [Error!]\n  count: Int!\n  orderErrors: [OrderError!]\n}\n\ntype DraftOrderLinesCreate {\n  errors: [Error!]\n  order: Order\n  orderLines: [OrderLine!]\n  orderErrors: [OrderError!]\n}\n\ntype DraftOrderUpdate {\n  errors: [Error!]\n  orderErrors: [OrderError!]\n  order: Order\n}\n\ntype Error {\n  field: String\n  message: String\n}\n\ntype ExtensionsError {\n  field: String\n  message: String\n  code: ExtensionsErrorCode\n}\n\nenum ExtensionsErrorCode {\n  GRAPHQL_ERROR\n  INVALID\n  PLUGIN_MISCONFIGURED\n  NOT_FOUND\n  REQUIRED\n  UNIQUE\n}\n\ntype Fulfillment implements Node {\n  id: ID!\n  fulfillmentOrder: Int!\n  status: FulfillmentStatus!\n  trackingNumber: String!\n  created: DateTime!\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  lines: [FulfillmentLine]\n  statusDisplay: String\n}\n\ntype FulfillmentCancel {\n  errors: [Error!]\n  fulfillment: Fulfillment\n  order: Order\n  orderErrors: [OrderError!]\n}\n\ninput FulfillmentCancelInput {\n  restock: Boolean\n}\n\ntype FulfillmentClearMeta {\n  errors: [Error!]\n  fulfillment: Fulfillment\n}\n\ntype FulfillmentClearPrivateMeta {\n  errors: [Error!]\n  fulfillment: Fulfillment\n}\n\ntype FulfillmentCreate {\n  errors: [Error!]\n  fulfillment: Fulfillment\n  order: Order\n  orderErrors: [OrderError!]\n}\n\ninput FulfillmentCreateInput {\n  trackingNumber: String\n  notifyCustomer: Boolean\n  lines: [FulfillmentLineInput]!\n}\n\ntype FulfillmentLine implements Node {\n  id: ID!\n  quantity: Int!\n  orderLine: OrderLine\n}\n\ninput FulfillmentLineInput {\n  orderLineId: ID\n  quantity: Int\n}\n\nenum FulfillmentStatus {\n  FULFILLED\n  CANCELED\n}\n\ntype FulfillmentUpdateMeta {\n  errors: [Error!]\n  fulfillment: Fulfillment\n}\n\ntype FulfillmentUpdatePrivateMeta {\n  errors: [Error!]\n  fulfillment: Fulfillment\n}\n\ntype FulfillmentUpdateTracking {\n  errors: [Error!]\n  fulfillment: Fulfillment\n  order: Order\n  orderErrors: [OrderError!]\n}\n\ninput FulfillmentUpdateTrackingInput {\n  trackingNumber: String\n  notifyCustomer: Boolean = false\n}\n\ntype GatewayConfigLine {\n  field: String!\n  value: String\n}\n\nscalar GenericScalar\n\ntype Geolocalization {\n  country: CountryDisplay\n}\n\ntype GiftCard implements Node {\n  code: String\n  user: User\n  created: DateTime!\n  startDate: Date!\n  endDate: Date\n  lastUsedOn: DateTime\n  isActive: Boolean!\n  initialBalance: Money\n  currentBalance: Money\n  id: ID!\n  displayCode: String\n}\n\ntype GiftCardActivate {\n  errors: [Error!]\n  giftCard: GiftCard\n  giftCardErrors: [GiftCardError!]\n}\n\ntype GiftCardCountableConnection {\n  pageInfo: PageInfo!\n  edges: [GiftCardCountableEdge!]!\n  totalCount: Int\n}\n\ntype GiftCardCountableEdge {\n  node: GiftCard!\n  cursor: String!\n}\n\ntype GiftCardCreate {\n  errors: [Error!]\n  giftCardErrors: [GiftCardError!]\n  giftCard: GiftCard\n}\n\ninput GiftCardCreateInput {\n  startDate: Date\n  endDate: Date\n  balance: Decimal\n  userEmail: String\n  code: String\n}\n\ntype GiftCardDeactivate {\n  errors: [Error!]\n  giftCard: GiftCard\n  giftCardErrors: [GiftCardError!]\n}\n\ntype GiftCardError {\n  field: String\n  message: String\n  code: GiftCardErrorCode\n}\n\nenum GiftCardErrorCode {\n  ALREADY_EXISTS\n  GRAPHQL_ERROR\n  INVALID\n  NOT_FOUND\n  REQUIRED\n  UNIQUE\n}\n\ntype GiftCardUpdate {\n  errors: [Error!]\n  giftCardErrors: [GiftCardError!]\n  giftCard: GiftCard\n}\n\ninput GiftCardUpdateInput {\n  startDate: Date\n  endDate: Date\n  balance: Decimal\n  userEmail: String\n}\n\ntype Group implements Node {\n  id: ID!\n  name: String!\n  permissions: [PermissionDisplay]\n  users: [User]\n}\n\ntype GroupCountableConnection {\n  pageInfo: PageInfo!\n  edges: [GroupCountableEdge!]!\n  totalCount: Int\n}\n\ntype GroupCountableEdge {\n  node: Group!\n  cursor: String!\n}\n\ntype HomepageCollectionUpdate {\n  errors: [Error!]\n  shop: Shop\n  shopErrors: [ShopError!]\n}\n\ntype Image {\n  url: String!\n  alt: String\n}\n\ninput IntRangeInput {\n  gte: Int\n  lte: Int\n}\n\nscalar JSONString\n\nenum LanguageCodeEnum {\n  AR\n  AZ\n  BG\n  BN\n  CA\n  CS\n  DA\n  DE\n  EL\n  EN\n  ES\n  ES_CO\n  ET\n  FA\n  FR\n  HI\n  HU\n  HY\n  ID\n  IS\n  IT\n  JA\n  KO\n  LT\n  MN\n  NB\n  NL\n  PL\n  PT\n  PT_BR\n  RO\n  RU\n  SK\n  SQ\n  SR\n  SW\n  SV\n  TH\n  TR\n  UK\n  VI\n  ZH_HANS\n  ZH_HANT\n}\n\ntype LanguageDisplay {\n  code: LanguageCodeEnum!\n  language: String!\n}\n\ntype Margin {\n  start: Int\n  stop: Int\n}\n\ntype Menu implements Node {\n  id: ID!\n  name: String!\n  items: [MenuItem]\n}\n\ntype MenuBulkDelete {\n  errors: [Error!]\n  count: Int!\n  menuErrors: [MenuError!]\n}\n\ntype MenuCountableConnection {\n  pageInfo: PageInfo!\n  edges: [MenuCountableEdge!]!\n  totalCount: Int\n}\n\ntype MenuCountableEdge {\n  node: Menu!\n  cursor: String!\n}\n\ntype MenuCreate {\n  errors: [Error!]\n  menuErrors: [MenuError!]\n  menu: Menu\n}\n\ninput MenuCreateInput {\n  name: String!\n  items: [MenuItemInput]\n}\n\ntype MenuDelete {\n  errors: [Error!]\n  menuErrors: [MenuError!]\n  menu: Menu\n}\n\ntype MenuError {\n  field: String\n  message: String\n  code: MenuErrorCode\n}\n\nenum MenuErrorCode {\n  CANNOT_ASSIGN_NODE\n  GRAPHQL_ERROR\n  INVALID\n  INVALID_MENU_ITEM\n  NO_MENU_ITEM_PROVIDED\n  NOT_FOUND\n  REQUIRED\n  TOO_MANY_MENU_ITEMS\n  UNIQUE\n}\n\ninput MenuFilterInput {\n  search: String\n}\n\ninput MenuInput {\n  name: String\n}\n\ntype MenuItem implements Node {\n  id: ID!\n  name: String!\n  menu: Menu!\n  parent: MenuItem\n  category: Category\n  collection: Collection\n  page: Page\n  level: Int!\n  children: [MenuItem]\n  url: String\n  translation(languageCode: LanguageCodeEnum!): MenuItemTranslation\n}\n\ntype MenuItemBulkDelete {\n  errors: [Error!]\n  count: Int!\n  menuErrors: [MenuError!]\n}\n\ntype MenuItemCountableConnection {\n  pageInfo: PageInfo!\n  edges: [MenuItemCountableEdge!]!\n  totalCount: Int\n}\n\ntype MenuItemCountableEdge {\n  node: MenuItem!\n  cursor: String!\n}\n\ntype MenuItemCreate {\n  errors: [Error!]\n  menuErrors: [MenuError!]\n  menuItem: MenuItem\n}\n\ninput MenuItemCreateInput {\n  name: String!\n  url: String\n  category: ID\n  collection: ID\n  page: ID\n  menu: ID!\n  parent: ID\n}\n\ntype MenuItemDelete {\n  errors: [Error!]\n  menuErrors: [MenuError!]\n  menuItem: MenuItem\n}\n\ninput MenuItemFilterInput {\n  search: String\n}\n\ninput MenuItemInput {\n  name: String\n  url: String\n  category: ID\n  collection: ID\n  page: ID\n}\n\ntype MenuItemMove {\n  errors: [Error!]\n  menu: Menu\n  menuErrors: [MenuError!]\n}\n\ninput MenuItemMoveInput {\n  itemId: ID!\n  parentId: ID\n  sortOrder: Int\n}\n\ninput MenuItemSortingInput {\n  direction: OrderDirection!\n  field: MenuItemsSortField!\n}\n\ntype MenuItemTranslatableContent implements Node {\n  id: ID!\n  name: String!\n  translation(languageCode: LanguageCodeEnum!): MenuItemTranslation\n  menuItem: MenuItem\n}\n\ntype MenuItemTranslate {\n  errors: [Error!]\n  menuItem: MenuItem\n}\n\ntype MenuItemTranslation implements Node {\n  id: ID!\n  name: String!\n  language: LanguageDisplay!\n}\n\ntype MenuItemUpdate {\n  errors: [Error!]\n  menuErrors: [MenuError!]\n  menuItem: MenuItem\n}\n\nenum MenuItemsSortField {\n  NAME\n}\n\nenum MenuSortField {\n  NAME\n  ITEMS_COUNT\n}\n\ninput MenuSortingInput {\n  direction: OrderDirection!\n  field: MenuSortField!\n}\n\ntype MenuUpdate {\n  errors: [Error!]\n  menuErrors: [MenuError!]\n  menu: Menu\n}\n\ntype MetaClientStore {\n  name: String!\n  metadata: [MetaItem]!\n}\n\ninput MetaInput {\n  namespace: String!\n  clientName: String!\n  key: String!\n  value: String!\n}\n\ntype MetaItem {\n  key: String!\n  value: String!\n}\n\ninput MetaPath {\n  namespace: String!\n  clientName: String!\n  key: String!\n}\n\ntype MetaStore {\n  namespace: String!\n  clients: [MetaClientStore]!\n}\n\ntype Money {\n  currency: String!\n  amount: Float!\n  localized: String! @deprecated(reason: \"DEPRECATED: Will be removed in Saleor 2.11. Price formatting according to the current locale should be handled by the frontend client.\")\n}\n\ntype MoneyRange {\n  start: Money\n  stop: Money\n}\n\ninput MoveProductInput {\n  productId: ID!\n  sortOrder: Int\n}\n\ntype Mutation {\n  wishlistAddProduct(productId: ID!): WishlistAddProductMutation\n  wishlistRemoveProduct(productId: ID!): WishlistRemoveProductMutation\n  wishlistAddVariant(variantId: ID!): WishlistAddProductVariantMutation\n  wishlistRemoveVariant(variantId: ID!): WishlistRemoveProductVariantMutation\n  webhookCreate(input: WebhookCreateInput!): WebhookCreate\n  webhookDelete(id: ID!): WebhookDelete\n  webhookUpdate(id: ID!, input: WebhookUpdateInput!): WebhookUpdate\n  createWarehouse(input: WarehouseCreateInput!): WarehouseCreate\n  updateWarehouse(id: ID!, input: WarehouseUpdateInput!): WarehouseUpdate\n  deleteWarehouse(id: ID!): WarehouseDelete\n  createStock(input: StockInput!): StockCreate\n  updateStock(id: ID!, input: StockInput!): StockUpdate\n  deleteStock(id: ID!): StockDelete\n  bulkDeleteStock(ids: [ID]!): StockBulkDelete\n  authorizationKeyAdd(input: AuthorizationKeyInput!, keyType: AuthorizationKeyType!): AuthorizationKeyAdd\n  authorizationKeyDelete(keyType: AuthorizationKeyType!): AuthorizationKeyDelete\n  staffNotificationRecipientCreate(input: StaffNotificationRecipientInput!): StaffNotificationRecipientCreate\n  staffNotificationRecipientUpdate(id: ID!, input: StaffNotificationRecipientInput!): StaffNotificationRecipientUpdate\n  staffNotificationRecipientDelete(id: ID!): StaffNotificationRecipientDelete\n  homepageCollectionUpdate(collection: ID): HomepageCollectionUpdate\n  shopDomainUpdate(input: SiteDomainInput): ShopDomainUpdate\n  shopSettingsUpdate(input: ShopSettingsInput!): ShopSettingsUpdate\n  shopFetchTaxRates: ShopFetchTaxRates\n  shopSettingsTranslate(input: ShopSettingsTranslationInput!, languageCode: LanguageCodeEnum!): ShopSettingsTranslate\n  shopAddressUpdate(input: AddressInput): ShopAddressUpdate\n  shippingPriceCreate(input: ShippingPriceInput!): ShippingPriceCreate\n  shippingPriceDelete(id: ID!): ShippingPriceDelete\n  shippingPriceBulkDelete(ids: [ID]!): ShippingPriceBulkDelete\n  shippingPriceUpdate(id: ID!, input: ShippingPriceInput!): ShippingPriceUpdate\n  shippingPriceTranslate(id: ID!, input: NameTranslationInput!, languageCode: LanguageCodeEnum!): ShippingPriceTranslate\n  shippingZoneCreate(input: ShippingZoneInput!): ShippingZoneCreate\n  shippingZoneDelete(id: ID!): ShippingZoneDelete\n  shippingZoneBulkDelete(ids: [ID]!): ShippingZoneBulkDelete\n  shippingZoneUpdate(id: ID!, input: ShippingZoneInput!): ShippingZoneUpdate\n  attributeCreate(input: AttributeCreateInput!): AttributeCreate\n  attributeDelete(id: ID!): AttributeDelete\n  attributeBulkDelete(ids: [ID]!): AttributeBulkDelete\n  attributeAssign(operations: [AttributeAssignInput]!, productTypeId: ID!): AttributeAssign\n  attributeUnassign(attributeIds: [ID]!, productTypeId: ID!): AttributeUnassign\n  attributeUpdate(id: ID!, input: AttributeUpdateInput!): AttributeUpdate\n  attributeTranslate(id: ID!, input: NameTranslationInput!, languageCode: LanguageCodeEnum!): AttributeTranslate\n  attributeUpdateMetadata(id: ID!, input: MetaInput!): AttributeUpdateMeta\n  attributeClearMetadata(id: ID!, input: MetaPath!): AttributeClearMeta\n  attributeUpdatePrivateMetadata(id: ID!, input: MetaInput!): AttributeUpdatePrivateMeta\n  attributeClearPrivateMetadata(id: ID!, input: MetaPath!): AttributeClearPrivateMeta\n  attributeValueCreate(attribute: ID!, input: AttributeValueCreateInput!): AttributeValueCreate\n  attributeValueDelete(id: ID!): AttributeValueDelete\n  attributeValueBulkDelete(ids: [ID]!): AttributeValueBulkDelete\n  attributeValueUpdate(id: ID!, input: AttributeValueCreateInput!): AttributeValueUpdate\n  attributeValueTranslate(id: ID!, input: NameTranslationInput!, languageCode: LanguageCodeEnum!): AttributeValueTranslate\n  attributeReorderValues(attributeId: ID!, moves: [ReorderInput]!): AttributeReorderValues\n  categoryCreate(input: CategoryInput!, parent: ID): CategoryCreate\n  categoryDelete(id: ID!): CategoryDelete\n  categoryBulkDelete(ids: [ID]!): CategoryBulkDelete\n  categoryUpdate(id: ID!, input: CategoryInput!): CategoryUpdate\n  categoryTranslate(id: ID!, input: TranslationInput!, languageCode: LanguageCodeEnum!): CategoryTranslate\n  categoryUpdateMetadata(id: ID!, input: MetaInput!): CategoryUpdateMeta\n  categoryClearMetadata(id: ID!, input: MetaPath!): CategoryClearMeta\n  categoryUpdatePrivateMetadata(id: ID!, input: MetaInput!): CategoryUpdatePrivateMeta\n  categoryClearPrivateMetadata(id: ID!, input: MetaPath!): CategoryClearPrivateMeta\n  collectionAddProducts(collectionId: ID!, products: [ID]!): CollectionAddProducts\n  collectionCreate(input: CollectionCreateInput!): CollectionCreate\n  collectionDelete(id: ID!): CollectionDelete\n  collectionReorderProducts(collectionId: ID!, moves: [MoveProductInput]!): CollectionReorderProducts\n  collectionBulkDelete(ids: [ID]!): CollectionBulkDelete\n  collectionBulkPublish(ids: [ID]!, isPublished: Boolean!): CollectionBulkPublish\n  collectionRemoveProducts(collectionId: ID!, products: [ID]!): CollectionRemoveProducts\n  collectionUpdate(id: ID!, input: CollectionInput!): CollectionUpdate\n  collectionTranslate(id: ID!, input: TranslationInput!, languageCode: LanguageCodeEnum!): CollectionTranslate\n  collectionUpdateMetadata(id: ID!, input: MetaInput!): CollectionUpdateMeta\n  collectionClearMetadata(id: ID!, input: MetaPath!): CollectionClearMeta\n  collectionUpdatePrivateMetadata(id: ID!, input: MetaInput!): CollectionUpdatePrivateMeta\n  collectionClearPrivateMetadata(id: ID!, input: MetaPath!): CollectionClearPrivateMeta\n  productCreate(input: ProductCreateInput!): ProductCreate\n  productDelete(id: ID!): ProductDelete\n  productBulkDelete(ids: [ID]!): ProductBulkDelete\n  productBulkPublish(ids: [ID]!, isPublished: Boolean!): ProductBulkPublish\n  productUpdate(id: ID!, input: ProductInput!): ProductUpdate\n  productTranslate(id: ID!, input: TranslationInput!, languageCode: LanguageCodeEnum!): ProductTranslate\n  productUpdateMetadata(id: ID!, input: MetaInput!): ProductUpdateMeta\n  productClearMetadata(id: ID!, input: MetaPath!): ProductClearMeta\n  productUpdatePrivateMetadata(id: ID!, input: MetaInput!): ProductUpdatePrivateMeta\n  productClearPrivateMetadata(id: ID!, input: MetaPath!): ProductClearPrivateMeta\n  productImageCreate(input: ProductImageCreateInput!): ProductImageCreate\n  productImageDelete(id: ID!): ProductImageDelete\n  productImageBulkDelete(ids: [ID]!): ProductImageBulkDelete\n  productImageReorder(imagesIds: [ID]!, productId: ID!): ProductImageReorder\n  productImageUpdate(id: ID!, input: ProductImageUpdateInput!): ProductImageUpdate\n  productTypeCreate(input: ProductTypeInput!): ProductTypeCreate\n  productTypeDelete(id: ID!): ProductTypeDelete\n  productTypeBulkDelete(ids: [ID]!): ProductTypeBulkDelete\n  productTypeUpdate(id: ID!, input: ProductTypeInput!): ProductTypeUpdate\n  productTypeReorderAttributes(moves: [ReorderInput]!, productTypeId: ID!, type: AttributeTypeEnum!): ProductTypeReorderAttributes\n  productTypeUpdateMetadata(id: ID!, input: MetaInput!): ProductTypeUpdateMeta\n  productTypeClearMetadata(id: ID!, input: MetaPath!): ProductTypeClearMeta\n  productTypeUpdatePrivateMetadata(id: ID!, input: MetaInput!): ProductTypeUpdatePrivateMeta\n  productTypeClearPrivateMetadata(id: ID!, input: MetaPath!): ProductTypeClearPrivateMeta\n  digitalContentCreate(input: DigitalContentUploadInput!, variantId: ID!): DigitalContentCreate\n  digitalContentDelete(variantId: ID!): DigitalContentDelete\n  digitalContentUpdate(input: DigitalContentInput!, variantId: ID!): DigitalContentUpdate\n  digitalContentUrlCreate(input: DigitalContentUrlCreateInput!): DigitalContentUrlCreate\n  productVariantCreate(input: ProductVariantCreateInput!): ProductVariantCreate\n  productVariantDelete(id: ID!): ProductVariantDelete\n  productVariantBulkCreate(product: ID!, variants: [ProductVariantBulkCreateInput]!): ProductVariantBulkCreate\n  productVariantBulkDelete(ids: [ID]!): ProductVariantBulkDelete\n  productVariantUpdate(id: ID!, input: ProductVariantInput!): ProductVariantUpdate\n  productVariantTranslate(id: ID!, input: NameTranslationInput!, languageCode: LanguageCodeEnum!): ProductVariantTranslate\n  productVariantUpdateMetadata(id: ID!, input: MetaInput!): ProductVariantUpdateMeta\n  productVariantClearMetadata(id: ID!, input: MetaPath!): ProductVariantClearMeta\n  productVariantUpdatePrivateMetadata(id: ID!, input: MetaInput!): ProductVariantUpdatePrivateMeta\n  productVariantClearPrivateMetadata(id: ID!, input: MetaPath!): ProductVariantClearPrivateMeta\n  variantImageAssign(imageId: ID!, variantId: ID!): VariantImageAssign\n  variantImageUnassign(imageId: ID!, variantId: ID!): VariantImageUnassign\n  paymentCapture(amount: Decimal, paymentId: ID!): PaymentCapture\n  paymentRefund(amount: Decimal, paymentId: ID!): PaymentRefund\n  paymentVoid(paymentId: ID!): PaymentVoid\n  paymentSecureConfirm(paymentId: ID!): PaymentSecureConfirm\n  pageCreate(input: PageInput!): PageCreate\n  pageDelete(id: ID!): PageDelete\n  pageBulkDelete(ids: [ID]!): PageBulkDelete\n  pageBulkPublish(ids: [ID]!, isPublished: Boolean!): PageBulkPublish\n  pageUpdate(id: ID!, input: PageInput!): PageUpdate\n  pageTranslate(id: ID!, input: PageTranslationInput!, languageCode: LanguageCodeEnum!): PageTranslate\n  draftOrderComplete(id: ID!): DraftOrderComplete\n  draftOrderCreate(input: DraftOrderCreateInput!): DraftOrderCreate\n  draftOrderDelete(id: ID!): DraftOrderDelete\n  draftOrderBulkDelete(ids: [ID]!): DraftOrderBulkDelete\n  draftOrderLinesBulkDelete(ids: [ID]!): DraftOrderLinesBulkDelete\n  draftOrderLinesCreate(id: ID!, input: [OrderLineCreateInput]!): DraftOrderLinesCreate\n  draftOrderLineDelete(id: ID!): DraftOrderLineDelete\n  draftOrderLineUpdate(id: ID!, input: OrderLineInput!): DraftOrderLineUpdate\n  draftOrderUpdate(id: ID!, input: DraftOrderInput!): DraftOrderUpdate\n  orderAddNote(order: ID!, input: OrderAddNoteInput!): OrderAddNote\n  orderCancel(id: ID!, restock: Boolean!): OrderCancel\n  orderCapture(amount: Decimal!, id: ID!): OrderCapture\n  orderClearPrivateMeta(id: ID!, input: MetaPath!): OrderClearPrivateMeta\n  orderClearMeta(input: MetaPath!, token: UUID!): OrderClearMeta\n  orderFulfillmentCancel(id: ID!, input: FulfillmentCancelInput!): FulfillmentCancel\n  orderFulfillmentCreate(input: FulfillmentCreateInput!, order: ID): FulfillmentCreate\n  orderFulfillmentUpdateTracking(id: ID!, input: FulfillmentUpdateTrackingInput!): FulfillmentUpdateTracking\n  orderFulfillmentClearMeta(id: ID!, input: MetaPath!): FulfillmentClearMeta\n  orderFulfillmentClearPrivateMeta(id: ID!, input: MetaPath!): FulfillmentClearPrivateMeta\n  orderFulfillmentUpdateMeta(id: ID!, input: MetaInput!): FulfillmentUpdateMeta\n  orderFulfillmentUpdatePrivateMeta(id: ID!, input: MetaInput!): FulfillmentUpdatePrivateMeta\n  orderMarkAsPaid(id: ID!): OrderMarkAsPaid\n  orderRefund(amount: Decimal!, id: ID!): OrderRefund\n  orderUpdate(id: ID!, input: OrderUpdateInput!): OrderUpdate\n  orderUpdateMeta(input: MetaInput!, token: UUID!): OrderUpdateMeta\n  orderUpdatePrivateMeta(id: ID!, input: MetaInput!): OrderUpdatePrivateMeta\n  orderUpdateShipping(order: ID!, input: OrderUpdateShippingInput): OrderUpdateShipping\n  orderVoid(id: ID!): OrderVoid\n  orderBulkCancel(ids: [ID]!, restock: Boolean!): OrderBulkCancel\n  assignNavigation(menu: ID, navigationType: NavigationType!): AssignNavigation\n  menuCreate(input: MenuCreateInput!): MenuCreate\n  menuDelete(id: ID!): MenuDelete\n  menuBulkDelete(ids: [ID]!): MenuBulkDelete\n  menuUpdate(id: ID!, input: MenuInput!): MenuUpdate\n  menuItemCreate(input: MenuItemCreateInput!): MenuItemCreate\n  menuItemDelete(id: ID!): MenuItemDelete\n  menuItemBulkDelete(ids: [ID]!): MenuItemBulkDelete\n  menuItemUpdate(id: ID!, input: MenuItemInput!): MenuItemUpdate\n  menuItemTranslate(id: ID!, input: NameTranslationInput!, languageCode: LanguageCodeEnum!): MenuItemTranslate\n  menuItemMove(menu: ID!, moves: [MenuItemMoveInput]!): MenuItemMove\n  giftCardActivate(id: ID!): GiftCardActivate\n  giftCardCreate(input: GiftCardCreateInput!): GiftCardCreate\n  giftCardDeactivate(id: ID!): GiftCardDeactivate\n  giftCardUpdate(id: ID!, input: GiftCardUpdateInput!): GiftCardUpdate\n  pluginUpdate(id: ID!, input: PluginUpdateInput!): PluginUpdate\n  saleCreate(input: SaleInput!): SaleCreate\n  saleDelete(id: ID!): SaleDelete\n  saleBulkDelete(ids: [ID]!): SaleBulkDelete\n  saleUpdate(id: ID!, input: SaleInput!): SaleUpdate\n  saleCataloguesAdd(id: ID!, input: CatalogueInput!): SaleAddCatalogues\n  saleCataloguesRemove(id: ID!, input: CatalogueInput!): SaleRemoveCatalogues\n  saleTranslate(id: ID!, input: NameTranslationInput!, languageCode: LanguageCodeEnum!): SaleTranslate\n  voucherCreate(input: VoucherInput!): VoucherCreate\n  voucherDelete(id: ID!): VoucherDelete\n  voucherBulkDelete(ids: [ID]!): VoucherBulkDelete\n  voucherUpdate(id: ID!, input: VoucherInput!): VoucherUpdate\n  voucherCataloguesAdd(id: ID!, input: CatalogueInput!): VoucherAddCatalogues\n  voucherCataloguesRemove(id: ID!, input: CatalogueInput!): VoucherRemoveCatalogues\n  voucherTranslate(id: ID!, input: NameTranslationInput!, languageCode: LanguageCodeEnum!): VoucherTranslate\n  tokenCreate(email: String!, password: String!): CreateToken\n  tokenRefresh(token: String!): Refresh\n  tokenVerify(token: String!): VerifyToken\n  checkoutAddPromoCode(checkoutId: ID!, promoCode: String!): CheckoutAddPromoCode\n  checkoutBillingAddressUpdate(billingAddress: AddressInput!, checkoutId: ID!): CheckoutBillingAddressUpdate\n  checkoutComplete(checkoutId: ID!, redirectUrl: String, storeSource: Boolean = false): CheckoutComplete\n  checkoutCreate(input: CheckoutCreateInput!): CheckoutCreate\n  checkoutCustomerAttach(checkoutId: ID!, customerId: ID): CheckoutCustomerAttach\n  checkoutCustomerDetach(checkoutId: ID!): CheckoutCustomerDetach\n  checkoutEmailUpdate(checkoutId: ID, email: String!): CheckoutEmailUpdate\n  checkoutLineDelete(checkoutId: ID!, lineId: ID): CheckoutLineDelete\n  checkoutLinesAdd(checkoutId: ID!, lines: [CheckoutLineInput]!): CheckoutLinesAdd\n  checkoutLinesUpdate(checkoutId: ID!, lines: [CheckoutLineInput]!): CheckoutLinesUpdate\n  checkoutRemovePromoCode(checkoutId: ID!, promoCode: String!): CheckoutRemovePromoCode\n  checkoutPaymentCreate(checkoutId: ID!, input: PaymentInput!): CheckoutPaymentCreate\n  checkoutShippingAddressUpdate(checkoutId: ID!, shippingAddress: AddressInput!): CheckoutShippingAddressUpdate\n  checkoutShippingMethodUpdate(checkoutId: ID, shippingMethodId: ID!): CheckoutShippingMethodUpdate\n  checkoutUpdateMetadata(id: ID!, input: MetaInput!): CheckoutUpdateMeta\n  checkoutClearMetadata(id: ID!, input: MetaPath!): CheckoutClearMeta\n  checkoutUpdatePrivateMetadata(id: ID!, input: MetaInput!): CheckoutUpdatePrivateMeta\n  checkoutClearPrivateMetadata(id: ID!, input: MetaPath!): CheckoutClearPrivateMeta\n  requestPasswordReset(email: String!, redirectUrl: String!): RequestPasswordReset\n  confirmAccount(email: String!, token: String!): ConfirmAccount\n  setPassword(token: String!, email: String!, password: String!): SetPassword\n  passwordChange(newPassword: String!, oldPassword: String!): PasswordChange\n  requestEmailChange(newEmail: String!, password: String!, redirectUrl: String!): RequestEmailChange\n  confirmEmailChange(token: String!): ConfirmEmailChange\n  accountAddressCreate(input: AddressInput!, type: AddressTypeEnum): AccountAddressCreate\n  accountAddressUpdate(id: ID!, input: AddressInput!): AccountAddressUpdate\n  accountAddressDelete(id: ID!): AccountAddressDelete\n  accountSetDefaultAddress(id: ID!, type: AddressTypeEnum!): AccountSetDefaultAddress\n  accountRegister(input: AccountRegisterInput!): AccountRegister\n  accountUpdate(input: AccountInput!): AccountUpdate\n  accountRequestDeletion(redirectUrl: String!): AccountRequestDeletion\n  accountDelete(token: String!): AccountDelete\n  accountUpdateMeta(input: MetaInput!): AccountUpdateMeta\n  addressCreate(input: AddressInput!, userId: ID!): AddressCreate\n  addressUpdate(id: ID!, input: AddressInput!): AddressUpdate\n  addressDelete(id: ID!): AddressDelete\n  addressSetDefault(addressId: ID!, type: AddressTypeEnum!, userId: ID!): AddressSetDefault\n  customerCreate(input: UserCreateInput!): CustomerCreate\n  customerUpdate(id: ID!, input: CustomerInput!): CustomerUpdate\n  customerDelete(id: ID!): CustomerDelete\n  customerBulkDelete(ids: [ID]!): CustomerBulkDelete\n  staffCreate(input: StaffCreateInput!): StaffCreate\n  staffUpdate(id: ID!, input: StaffInput!): StaffUpdate\n  staffDelete(id: ID!): StaffDelete\n  staffBulkDelete(ids: [ID]!): StaffBulkDelete\n  userAvatarUpdate(image: Upload!): UserAvatarUpdate\n  userAvatarDelete: UserAvatarDelete\n  userBulkSetActive(ids: [ID]!, isActive: Boolean!): UserBulkSetActive\n  userUpdateMetadata(id: ID!, input: MetaInput!): UserUpdateMeta\n  userClearMetadata(id: ID!, input: MetaPath!): UserClearMeta\n  userUpdatePrivateMetadata(id: ID!, input: MetaInput!): UserUpdatePrivateMeta\n  userClearPrivateMetadata(id: ID!, input: MetaPath!): UserClearPrivateMeta\n  serviceAccountCreate(input: ServiceAccountInput!): ServiceAccountCreate\n  serviceAccountUpdate(id: ID!, input: ServiceAccountInput!): ServiceAccountUpdate\n  serviceAccountDelete(id: ID!): ServiceAccountDelete\n  serviceAccountUpdatePrivateMetadata(id: ID!, input: MetaInput!): ServiceAccountUpdatePrivateMeta\n  serviceAccountClearPrivateMetadata(id: ID!, input: MetaPath!): ServiceAccountClearPrivateMeta\n  serviceAccountTokenCreate(input: ServiceAccountTokenInput!): ServiceAccountTokenCreate\n  serviceAccountTokenDelete(id: ID!): ServiceAccountTokenDelete\n  permissionGroupCreate(input: PermissionGroupCreateInput!): PermissionGroupCreate\n  permissionGroupUpdate(id: ID!, input: PermissionGroupInput!): PermissionGroupUpdate\n  permissionGroupDelete(id: ID!): PermissionGroupDelete\n  permissionGroupAssignUsers(id: ID!, input: UsersInput!): PermissionGroupAssignUsers\n  permissionGroupUnassignUsers(id: ID!, input: UsersInput!): PermissionGroupUnassignUsers\n}\n\ninput NameTranslationInput {\n  name: String\n}\n\ntype Navigation {\n  main: Menu\n  secondary: Menu\n}\n\nenum NavigationType {\n  MAIN\n  SECONDARY\n}\n\ninterface Node {\n  id: ID!\n}\n\ntype Order implements Node {\n  id: ID!\n  created: DateTime!\n  status: OrderStatus!\n  user: User\n  languageCode: String!\n  trackingClientId: String!\n  billingAddress: Address\n  shippingAddress: Address\n  shippingMethod: ShippingMethod\n  shippingMethodName: String\n  shippingPrice: TaxedMoney\n  token: String!\n  voucher: Voucher\n  giftCards: [GiftCard]\n  discount: Money\n  discountName: String!\n  translatedDiscountName: String!\n  displayGrossPrices: Boolean!\n  customerNote: String!\n  weight: Weight\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  fulfillments: [Fulfillment]!\n  lines: [OrderLine]!\n  actions: [OrderAction]!\n  availableShippingMethods: [ShippingMethod]\n  number: String\n  isPaid: Boolean\n  paymentStatus: PaymentChargeStatusEnum\n  paymentStatusDisplay: String\n  payments: [Payment]\n  total: TaxedMoney\n  subtotal: TaxedMoney\n  statusDisplay: String\n  canFinalize: Boolean!\n  totalAuthorized: Money\n  totalCaptured: Money\n  events: [OrderEvent]\n  totalBalance: Money!\n  userEmail: String\n  isShippingRequired: Boolean!\n}\n\nenum OrderAction {\n  CAPTURE\n  MARK_AS_PAID\n  REFUND\n  VOID\n}\n\ntype OrderAddNote {\n  errors: [Error!]\n  order: Order\n  event: OrderEvent\n  orderErrors: [OrderError!]\n}\n\ninput OrderAddNoteInput {\n  message: String\n}\n\ntype OrderBulkCancel {\n  errors: [Error!]\n  count: Int!\n  orderErrors: [OrderError!]\n}\n\ntype OrderCancel {\n  errors: [Error!]\n  order: Order\n  orderErrors: [OrderError!]\n}\n\ntype OrderCapture {\n  errors: [Error!]\n  order: Order\n  orderErrors: [OrderError!]\n}\n\ntype OrderClearMeta {\n  errors: [Error!]\n  order: Order\n}\n\ntype OrderClearPrivateMeta {\n  errors: [Error!]\n  order: Order\n}\n\ntype OrderCountableConnection {\n  pageInfo: PageInfo!\n  edges: [OrderCountableEdge!]!\n  totalCount: Int\n}\n\ntype OrderCountableEdge {\n  node: Order!\n  cursor: String!\n}\n\nenum OrderDirection {\n  ASC\n  DESC\n}\n\ninput OrderDraftFilterInput {\n  customer: String\n  created: DateRangeInput\n  search: String\n}\n\ntype OrderError {\n  field: String\n  message: String\n  code: OrderErrorCode\n}\n\nenum OrderErrorCode {\n  CANNOT_CANCEL_FULFILLMENT\n  CANNOT_CANCEL_ORDER\n  CANNOT_DELETE\n  CANNOT_REFUND\n  CAPTURE_INACTIVE_PAYMENT\n  NOT_EDITABLE\n  FULFILL_ORDER_LINE\n  GRAPHQL_ERROR\n  INVALID\n  NOT_FOUND\n  ORDER_NO_SHIPPING_ADDRESS\n  PAYMENT_ERROR\n  PAYMENT_MISSING\n  REQUIRED\n  SHIPPING_METHOD_NOT_APPLICABLE\n  SHIPPING_METHOD_REQUIRED\n  UNIQUE\n  VOID_INACTIVE_PAYMENT\n  ZERO_QUANTITY\n}\n\ntype OrderEvent implements Node {\n  id: ID!\n  date: DateTime\n  type: OrderEventsEnum\n  user(id: ID): User\n  message: String\n  email: String\n  emailType: OrderEventsEmailsEnum\n  amount: Float\n  paymentId: String\n  paymentGateway: String\n  quantity: Int\n  composedId: String\n  orderNumber: String\n  oversoldItems: [String]\n  lines: [OrderEventOrderLineObject]\n  fulfilledItems: [FulfillmentLine]\n}\n\ntype OrderEventCountableConnection {\n  pageInfo: PageInfo!\n  edges: [OrderEventCountableEdge!]!\n  totalCount: Int\n}\n\ntype OrderEventCountableEdge {\n  node: OrderEvent!\n  cursor: String!\n}\n\ntype OrderEventOrderLineObject {\n  quantity: Int\n  orderLine: OrderLine\n  itemName: String\n}\n\nenum OrderEventsEmailsEnum {\n  PAYMENT_CONFIRMATION\n  SHIPPING_CONFIRMATION\n  TRACKING_UPDATED\n  ORDER_CONFIRMATION\n  FULFILLMENT_CONFIRMATION\n  DIGITAL_LINKS\n}\n\nenum OrderEventsEnum {\n  DRAFT_CREATED\n  DRAFT_ADDED_PRODUCTS\n  DRAFT_REMOVED_PRODUCTS\n  PLACED\n  PLACED_FROM_DRAFT\n  OVERSOLD_ITEMS\n  CANCELED\n  ORDER_MARKED_AS_PAID\n  ORDER_FULLY_PAID\n  UPDATED_ADDRESS\n  EMAIL_SENT\n  PAYMENT_CAPTURED\n  PAYMENT_REFUNDED\n  PAYMENT_VOIDED\n  PAYMENT_FAILED\n  FULFILLMENT_CANCELED\n  FULFILLMENT_RESTOCKED_ITEMS\n  FULFILLMENT_FULFILLED_ITEMS\n  TRACKING_UPDATED\n  NOTE_ADDED\n  OTHER\n}\n\ninput OrderFilterInput {\n  paymentStatus: [PaymentChargeStatusEnum]\n  status: [OrderStatusFilter]\n  customer: String\n  created: DateRangeInput\n  search: String\n}\n\ntype OrderLine implements Node {\n  id: ID!\n  productName: String!\n  variantName: String!\n  productSku: String!\n  isShippingRequired: Boolean!\n  quantity: Int!\n  quantityFulfilled: Int!\n  taxRate: Float!\n  digitalContentUrl: DigitalContentUrl\n  thumbnail(size: Int): Image\n  unitPrice: TaxedMoney\n  variant: ProductVariant\n  translatedProductName: String!\n  translatedVariantName: String!\n}\n\ninput OrderLineCreateInput {\n  quantity: Int!\n  variantId: ID!\n}\n\ninput OrderLineInput {\n  quantity: Int!\n}\n\ntype OrderMarkAsPaid {\n  errors: [Error!]\n  order: Order\n  orderErrors: [OrderError!]\n}\n\ntype OrderRefund {\n  errors: [Error!]\n  order: Order\n  orderErrors: [OrderError!]\n}\n\nenum OrderSortField {\n  NUMBER\n  CREATION_DATE\n  CUSTOMER\n  PAYMENT\n  FULFILLMENT_STATUS\n  TOTAL\n}\n\ninput OrderSortingInput {\n  direction: OrderDirection!\n  field: OrderSortField!\n}\n\nenum OrderStatus {\n  DRAFT\n  UNFULFILLED\n  PARTIALLY_FULFILLED\n  FULFILLED\n  CANCELED\n}\n\nenum OrderStatusFilter {\n  READY_TO_FULFILL\n  READY_TO_CAPTURE\n  UNFULFILLED\n  PARTIALLY_FULFILLED\n  FULFILLED\n  CANCELED\n}\n\ntype OrderUpdate {\n  errors: [Error!]\n  orderErrors: [OrderError!]\n  order: Order\n}\n\ninput OrderUpdateInput {\n  billingAddress: AddressInput\n  userEmail: String\n  shippingAddress: AddressInput\n}\n\ntype OrderUpdateMeta {\n  errors: [Error!]\n  order: Order\n}\n\ntype OrderUpdatePrivateMeta {\n  errors: [Error!]\n  order: Order\n}\n\ntype OrderUpdateShipping {\n  errors: [Error!]\n  order: Order\n  orderErrors: [OrderError!]\n}\n\ninput OrderUpdateShippingInput {\n  shippingMethod: ID\n}\n\ntype OrderVoid {\n  errors: [Error!]\n  order: Order\n  orderErrors: [OrderError!]\n}\n\ntype Page implements Node {\n  seoTitle: String\n  seoDescription: String\n  id: ID!\n  title: String!\n  content: String!\n  contentJson: JSONString!\n  publicationDate: Date\n  isPublished: Boolean!\n  slug: String!\n  created: DateTime!\n  translation(languageCode: LanguageCodeEnum!): PageTranslation\n}\n\ntype PageBulkDelete {\n  errors: [Error!]\n  count: Int!\n}\n\ntype PageBulkPublish {\n  errors: [Error!]\n  count: Int!\n}\n\ntype PageCountableConnection {\n  pageInfo: PageInfo!\n  edges: [PageCountableEdge!]!\n  totalCount: Int\n}\n\ntype PageCountableEdge {\n  node: Page!\n  cursor: String!\n}\n\ntype PageCreate {\n  errors: [Error!]\n  page: Page\n}\n\ntype PageDelete {\n  errors: [Error!]\n  page: Page\n}\n\ninput PageFilterInput {\n  search: String\n}\n\ntype PageInfo {\n  hasNextPage: Boolean!\n  hasPreviousPage: Boolean!\n  startCursor: String\n  endCursor: String\n}\n\ninput PageInput {\n  slug: String\n  title: String\n  content: String\n  contentJson: JSONString\n  isPublished: Boolean\n  publicationDate: String\n  seo: SeoInput\n}\n\nenum PageSortField {\n  TITLE\n  SLUG\n  VISIBILITY\n  CREATION_DATE\n  PUBLICATION_DATE\n}\n\ninput PageSortingInput {\n  direction: OrderDirection!\n  field: PageSortField!\n}\n\ntype PageTranslatableContent implements Node {\n  seoTitle: String\n  seoDescription: String\n  id: ID!\n  title: String!\n  content: String!\n  contentJson: JSONString!\n  translation(languageCode: LanguageCodeEnum!): PageTranslation\n  page: Page\n}\n\ntype PageTranslate {\n  errors: [Error!]\n  page: PageTranslatableContent\n}\n\ntype PageTranslation implements Node {\n  seoTitle: String\n  seoDescription: String\n  id: ID!\n  title: String!\n  content: String!\n  contentJson: JSONString!\n  language: LanguageDisplay!\n}\n\ninput PageTranslationInput {\n  seoTitle: String\n  seoDescription: String\n  title: String\n  content: String\n  contentJson: JSONString\n}\n\ntype PageUpdate {\n  errors: [Error!]\n  page: Page\n}\n\ntype PasswordChange {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n}\n\ntype Payment implements Node {\n  id: ID!\n  gateway: String!\n  isActive: Boolean!\n  created: DateTime!\n  modified: DateTime!\n  token: String!\n  checkout: Checkout\n  order: Order\n  billingEmail: String!\n  customerIpAddress: String\n  extraData: String!\n  chargeStatus: PaymentChargeStatusEnum!\n  actions: [OrderAction]!\n  total: Money\n  capturedAmount: Money\n  billingAddress: Address\n  transactions: [Transaction]\n  availableCaptureAmount: Money\n  availableRefundAmount: Money\n  creditCard: CreditCard\n}\n\ntype PaymentCapture {\n  errors: [Error!]\n  payment: Payment\n  paymentErrors: [PaymentError!]\n}\n\nenum PaymentChargeStatusEnum {\n  NOT_CHARGED\n  PARTIALLY_CHARGED\n  FULLY_CHARGED\n  PARTIALLY_REFUNDED\n  FULLY_REFUNDED\n}\n\ntype PaymentCountableConnection {\n  pageInfo: PageInfo!\n  edges: [PaymentCountableEdge!]!\n  totalCount: Int\n}\n\ntype PaymentCountableEdge {\n  node: Payment!\n  cursor: String!\n}\n\ntype PaymentError {\n  field: String\n  message: String\n  code: PaymentErrorCode\n}\n\nenum PaymentErrorCode {\n  BILLING_ADDRESS_NOT_SET\n  GRAPHQL_ERROR\n  INVALID\n  NOT_FOUND\n  PARTIAL_PAYMENT_NOT_ALLOWED\n  PAYMENT_ERROR\n  REQUIRED\n  UNIQUE\n}\n\ntype PaymentGateway {\n  name: String!\n  config: [GatewayConfigLine!]!\n}\n\ninput PaymentInput {\n  gateway: String!\n  token: String!\n  amount: Decimal\n  billingAddress: AddressInput\n}\n\ntype PaymentRefund {\n  errors: [Error!]\n  payment: Payment\n  paymentErrors: [PaymentError!]\n}\n\ntype PaymentSecureConfirm {\n  errors: [Error!]\n  payment: Payment\n  paymentErrors: [PaymentError!]\n}\n\ntype PaymentSource {\n  gateway: String!\n  creditCardInfo: CreditCard\n}\n\ntype PaymentVoid {\n  errors: [Error!]\n  payment: Payment\n  paymentErrors: [PaymentError!]\n}\n\ntype PermissionDisplay {\n  code: PermissionEnum!\n  name: String!\n}\n\nenum PermissionEnum {\n  MANAGE_USERS\n  MANAGE_STAFF\n  MANAGE_SERVICE_ACCOUNTS\n  MANAGE_DISCOUNTS\n  MANAGE_PLUGINS\n  MANAGE_GIFT_CARD\n  MANAGE_MENUS\n  MANAGE_ORDERS\n  MANAGE_PAGES\n  MANAGE_PRODUCTS\n  MANAGE_SHIPPING\n  MANAGE_SETTINGS\n  MANAGE_TRANSLATIONS\n  MANAGE_WEBHOOKS\n  MANAGE_CHECKOUTS\n}\n\ntype PermissionGroupAssignUsers {\n  errors: [Error!]\n  group: Group\n  accountErrors: [AccountError!]\n}\n\ntype PermissionGroupCreate {\n  errors: [Error!]\n  group: Group\n  accountErrors: [AccountError!]\n}\n\ninput PermissionGroupCreateInput {\n  name: String!\n  permissions: [PermissionEnum!]\n}\n\ntype PermissionGroupDelete {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  group: Group\n}\n\ninput PermissionGroupFilterInput {\n  search: String\n}\n\ninput PermissionGroupInput {\n  name: String\n  permissions: [PermissionEnum!]\n}\n\nenum PermissionGroupSortField {\n  NAME\n}\n\ninput PermissionGroupSortingInput {\n  direction: OrderDirection!\n  field: PermissionGroupSortField!\n}\n\ntype PermissionGroupUnassignUsers {\n  errors: [Error!]\n  group: Group\n  accountErrors: [AccountError!]\n}\n\ntype PermissionGroupUpdate {\n  errors: [Error!]\n  group: Group\n  accountErrors: [AccountError!]\n}\n\ntype Plugin implements Node {\n  name: String!\n  description: String!\n  active: Boolean!\n  configuration: [ConfigurationItem]\n  id: ID!\n}\n\ntype PluginCountableConnection {\n  pageInfo: PageInfo!\n  edges: [PluginCountableEdge!]!\n  totalCount: Int\n}\n\ntype PluginCountableEdge {\n  node: Plugin!\n  cursor: String!\n}\n\ninput PluginFilterInput {\n  active: Boolean\n  search: String\n}\n\nenum PluginSortField {\n  NAME\n  IS_ACTIVE\n}\n\ninput PluginSortingInput {\n  direction: OrderDirection!\n  field: PluginSortField!\n}\n\ntype PluginUpdate {\n  errors: [Error!]\n  plugin: Plugin\n  extensionsErrors: [ExtensionsError!]\n}\n\ninput PluginUpdateInput {\n  active: Boolean\n  configuration: [ConfigurationItemInput]\n}\n\ninput PriceRangeInput {\n  gte: Float\n  lte: Float\n}\n\ntype Product implements Node {\n  id: ID!\n  seoTitle: String\n  seoDescription: String\n  name: String!\n  description: String!\n  descriptionJson: JSONString!\n  publicationDate: Date\n  isPublished: Boolean!\n  productType: ProductType!\n  category: Category\n  updatedAt: DateTime\n  chargeTaxes: Boolean!\n  weight: Weight\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  url: String!\n  thumbnail(size: Int): Image\n  pricing: ProductPricingInfo\n  isAvailable: Boolean\n  basePrice: Money\n  minimalVariantPrice: Money\n  taxType: TaxType\n  attributes: [SelectedAttribute!]!\n  purchaseCost: MoneyRange\n  margin: Margin\n  imageById(id: ID): ProductImage\n  variants: [ProductVariant]\n  images: [ProductImage]\n  collections: [Collection]\n  translation(languageCode: LanguageCodeEnum!): ProductTranslation\n  slug: String!\n}\n\ntype ProductBulkDelete {\n  errors: [Error!]\n  count: Int!\n  productErrors: [ProductError!]\n}\n\ntype ProductBulkPublish {\n  errors: [Error!]\n  count: Int!\n  productErrors: [ProductError!]\n}\n\ntype ProductClearMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  product: Product\n}\n\ntype ProductClearPrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  product: Product\n}\n\ntype ProductCountableConnection {\n  pageInfo: PageInfo!\n  edges: [ProductCountableEdge!]!\n  totalCount: Int\n}\n\ntype ProductCountableEdge {\n  node: Product!\n  cursor: String!\n}\n\ntype ProductCreate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  product: Product\n}\n\ninput ProductCreateInput {\n  attributes: [AttributeValueInput]\n  publicationDate: Date\n  category: ID\n  chargeTaxes: Boolean\n  collections: [ID]\n  description: String\n  descriptionJson: JSONString\n  isPublished: Boolean\n  name: String\n  basePrice: Decimal\n  taxCode: String\n  seo: SeoInput\n  weight: WeightScalar\n  sku: String\n  quantity: Int\n  trackInventory: Boolean\n  productType: ID!\n}\n\ntype ProductDelete {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  product: Product\n}\n\ntype ProductError {\n  field: String\n  message: String\n  code: ProductErrorCode\n}\n\nenum ProductErrorCode {\n  ALREADY_EXISTS\n  ATTRIBUTE_ALREADY_ASSIGNED\n  ATTRIBUTE_CANNOT_BE_ASSIGNED\n  ATTRIBUTE_VARIANTS_DISABLED\n  GRAPHQL_ERROR\n  INVALID\n  NOT_PRODUCTS_IMAGE\n  NOT_FOUND\n  REQUIRED\n  UNIQUE\n  VARIANT_NO_DIGITAL_CONTENT\n}\n\ninput ProductFilterInput {\n  isPublished: Boolean\n  collections: [ID]\n  categories: [ID]\n  hasCategory: Boolean\n  price: PriceRangeInput\n  attributes: [AttributeInput]\n  stockAvailability: StockAvailability\n  productType: ID\n  search: String\n  minimalPrice: PriceRangeInput\n  productTypes: [ID]\n}\n\ntype ProductImage implements Node {\n  id: ID!\n  sortOrder: Int\n  alt: String!\n  url(size: Int): String!\n}\n\ntype ProductImageBulkDelete {\n  errors: [Error!]\n  count: Int!\n  productErrors: [ProductError!]\n}\n\ntype ProductImageCreate {\n  errors: [Error!]\n  product: Product\n  image: ProductImage\n  productErrors: [ProductError!]\n}\n\ninput ProductImageCreateInput {\n  alt: String\n  image: Upload!\n  product: ID!\n}\n\ntype ProductImageDelete {\n  errors: [Error!]\n  product: Product\n  image: ProductImage\n  productErrors: [ProductError!]\n}\n\ntype ProductImageReorder {\n  errors: [Error!]\n  product: Product\n  images: [ProductImage]\n  productErrors: [ProductError!]\n}\n\ntype ProductImageUpdate {\n  errors: [Error!]\n  product: Product\n  image: ProductImage\n  productErrors: [ProductError!]\n}\n\ninput ProductImageUpdateInput {\n  alt: String\n}\n\ninput ProductInput {\n  attributes: [AttributeValueInput]\n  publicationDate: Date\n  category: ID\n  chargeTaxes: Boolean\n  collections: [ID]\n  description: String\n  descriptionJson: JSONString\n  isPublished: Boolean\n  name: String\n  basePrice: Decimal\n  taxCode: String\n  seo: SeoInput\n  weight: WeightScalar\n  sku: String\n  quantity: Int\n  trackInventory: Boolean\n}\n\ninput ProductOrder {\n  direction: OrderDirection!\n  attributeId: ID\n  field: ProductOrderField\n}\n\nenum ProductOrderField {\n  NAME\n  PRICE\n  MINIMAL_PRICE\n  DATE\n  TYPE\n  PUBLISHED\n}\n\ntype ProductPricingInfo {\n  onSale: Boolean\n  discount: TaxedMoney\n  discountLocalCurrency: TaxedMoney\n  priceRange: TaxedMoneyRange\n  priceRangeUndiscounted: TaxedMoneyRange\n  priceRangeLocalCurrency: TaxedMoneyRange\n}\n\ntype ProductTranslatableContent implements Node {\n  id: ID!\n  seoTitle: String\n  seoDescription: String\n  name: String!\n  description: String!\n  descriptionJson: JSONString!\n  translation(languageCode: LanguageCodeEnum!): ProductTranslation\n  product: Product\n}\n\ntype ProductTranslate {\n  errors: [Error!]\n  product: Product\n}\n\ntype ProductTranslation implements Node {\n  id: ID!\n  seoTitle: String\n  seoDescription: String\n  name: String!\n  description: String!\n  descriptionJson: JSONString!\n  language: LanguageDisplay!\n}\n\ntype ProductType implements Node {\n  id: ID!\n  name: String!\n  hasVariants: Boolean!\n  isShippingRequired: Boolean!\n  isDigital: Boolean!\n  weight: Weight\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  products(before: String, after: String, first: Int, last: Int): ProductCountableConnection\n  taxRate: TaxRateType\n  taxType: TaxType\n  variantAttributes: [Attribute]\n  productAttributes: [Attribute]\n  availableAttributes(filter: AttributeFilterInput, before: String, after: String, first: Int, last: Int): AttributeCountableConnection\n}\n\ntype ProductTypeBulkDelete {\n  errors: [Error!]\n  count: Int!\n  productErrors: [ProductError!]\n}\n\ntype ProductTypeClearMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productType: ProductType\n}\n\ntype ProductTypeClearPrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productType: ProductType\n}\n\nenum ProductTypeConfigurable {\n  CONFIGURABLE\n  SIMPLE\n}\n\ntype ProductTypeCountableConnection {\n  pageInfo: PageInfo!\n  edges: [ProductTypeCountableEdge!]!\n  totalCount: Int\n}\n\ntype ProductTypeCountableEdge {\n  node: ProductType!\n  cursor: String!\n}\n\ntype ProductTypeCreate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productType: ProductType\n}\n\ntype ProductTypeDelete {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productType: ProductType\n}\n\nenum ProductTypeEnum {\n  DIGITAL\n  SHIPPABLE\n}\n\ninput ProductTypeFilterInput {\n  search: String\n  configurable: ProductTypeConfigurable\n  productType: ProductTypeEnum\n  ids: [ID]\n}\n\ninput ProductTypeInput {\n  name: String\n  hasVariants: Boolean\n  productAttributes: [ID]\n  variantAttributes: [ID]\n  isShippingRequired: Boolean\n  isDigital: Boolean\n  weight: WeightScalar\n  taxCode: String\n}\n\ntype ProductTypeReorderAttributes {\n  errors: [Error!]\n  productType: ProductType\n  productErrors: [ProductError!]\n}\n\nenum ProductTypeSortField {\n  NAME\n  DIGITAL\n  SHIPPING_REQUIRED\n}\n\ninput ProductTypeSortingInput {\n  direction: OrderDirection!\n  field: ProductTypeSortField!\n}\n\ntype ProductTypeUpdate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productType: ProductType\n}\n\ntype ProductTypeUpdateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productType: ProductType\n}\n\ntype ProductTypeUpdatePrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productType: ProductType\n}\n\ntype ProductUpdate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  product: Product\n}\n\ntype ProductUpdateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  product: Product\n}\n\ntype ProductUpdatePrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  product: Product\n}\n\ntype ProductVariant implements Node {\n  id: ID!\n  name: String!\n  sku: String!\n  product: Product!\n  trackInventory: Boolean!\n  weight: Weight\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  quantity: Int! @deprecated(reason: \"This field will be removed in Saleor 2.11. Use the stock field instead.\")\n  quantityAllocated: Int @deprecated(reason: \"This field will be removed in Saleor 2.11. Use the stock field instead.\")\n  stockQuantity: Int! @deprecated(reason: \"This field will be removed in Saleor 2.11. Use the stock field instead.\")\n  priceOverride: Money\n  pricing: VariantPricingInfo\n  isAvailable: Boolean @deprecated(reason: \"This field will be removed in Saleor 2.11. Use the stock field instead.\")\n  attributes: [SelectedAttribute!]!\n  costPrice: Money\n  margin: Int\n  quantityOrdered: Int\n  revenue(period: ReportingPeriod): TaxedMoney\n  images: [ProductImage]\n  translation(languageCode: LanguageCodeEnum!): ProductVariantTranslation\n  digitalContent: DigitalContent\n  stock(country: String): [Stock]\n}\n\ntype ProductVariantBulkCreate {\n  errors: [Error!]\n  count: Int!\n  productVariants: [ProductVariant!]!\n  bulkProductErrors: [BulkProductError!]\n}\n\ninput ProductVariantBulkCreateInput {\n  attributes: [AttributeValueInput]!\n  costPrice: Decimal\n  priceOverride: Decimal\n  sku: String!\n  quantity: Int\n  trackInventory: Boolean\n  weight: WeightScalar\n}\n\ntype ProductVariantBulkDelete {\n  errors: [Error!]\n  count: Int!\n  productErrors: [ProductError!]\n}\n\ntype ProductVariantClearMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productVariant: ProductVariant\n}\n\ntype ProductVariantClearPrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productVariant: ProductVariant\n}\n\ntype ProductVariantCountableConnection {\n  pageInfo: PageInfo!\n  edges: [ProductVariantCountableEdge!]!\n  totalCount: Int\n}\n\ntype ProductVariantCountableEdge {\n  node: ProductVariant!\n  cursor: String!\n}\n\ntype ProductVariantCreate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productVariant: ProductVariant\n}\n\ninput ProductVariantCreateInput {\n  attributes: [AttributeValueInput]!\n  costPrice: Decimal\n  priceOverride: Decimal\n  sku: String\n  quantity: Int\n  trackInventory: Boolean\n  weight: WeightScalar\n  product: ID!\n}\n\ntype ProductVariantDelete {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productVariant: ProductVariant\n}\n\ninput ProductVariantInput {\n  attributes: [AttributeValueInput]\n  costPrice: Decimal\n  priceOverride: Decimal\n  sku: String\n  quantity: Int\n  trackInventory: Boolean\n  weight: WeightScalar\n}\n\ntype ProductVariantTranslatableContent implements Node {\n  id: ID!\n  name: String!\n  translation(languageCode: LanguageCodeEnum!): ProductVariantTranslation\n  productVariant: ProductVariant\n}\n\ntype ProductVariantTranslate {\n  errors: [Error!]\n  productVariant: ProductVariant\n}\n\ntype ProductVariantTranslation implements Node {\n  id: ID!\n  name: String!\n  language: LanguageDisplay!\n}\n\ntype ProductVariantUpdate {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productVariant: ProductVariant\n}\n\ntype ProductVariantUpdateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productVariant: ProductVariant\n}\n\ntype ProductVariantUpdatePrivateMeta {\n  errors: [Error!]\n  productErrors: [ProductError!]\n  productVariant: ProductVariant\n}\n\ntype Query {\n  webhook(id: ID!): Webhook\n  webhooks(sortBy: WebhookSortingInput, filter: WebhookFilterInput, before: String, after: String, first: Int, last: Int): WebhookCountableConnection\n  webhookEvents: [WebhookEvent]\n  webhookSamplePayload(eventType: WebhookEventTypeEnum!): JSONString\n  warehouse(id: ID!): Warehouse\n  warehouses(filter: WarehouseFilterInput, before: String, after: String, first: Int, last: Int): WarehouseCountableConnection\n  translations(kind: TranslatableKinds!, before: String, after: String, first: Int, last: Int): TranslatableItemConnection\n  translation(id: ID!, kind: TranslatableKinds!): TranslatableItem\n  stock(id: ID!): Stock\n  stocks(filter: StockFilterInput, before: String, after: String, first: Int, last: Int): StockCountableConnection\n  shop: Shop\n  shippingZone(id: ID!): ShippingZone\n  shippingZones(before: String, after: String, first: Int, last: Int): ShippingZoneCountableConnection\n  digitalContent(id: ID!): DigitalContent\n  digitalContents(before: String, after: String, first: Int, last: Int): DigitalContentCountableConnection\n  attributes(filter: AttributeFilterInput, sortBy: AttributeSortingInput, before: String, after: String, first: Int, last: Int): AttributeCountableConnection\n  attribute(id: ID!): Attribute\n  categories(filter: CategoryFilterInput, sortBy: CategorySortingInput, level: Int, before: String, after: String, first: Int, last: Int): CategoryCountableConnection\n  category(id: ID!): Category\n  collection(id: ID!): Collection\n  collections(filter: CollectionFilterInput, sortBy: CollectionSortingInput, before: String, after: String, first: Int, last: Int): CollectionCountableConnection\n  product(id: ID!): Product\n  products(filter: ProductFilterInput, sortBy: ProductOrder, stockAvailability: StockAvailability, before: String, after: String, first: Int, last: Int): ProductCountableConnection\n  productType(id: ID!): ProductType\n  productTypes(filter: ProductTypeFilterInput, sortBy: ProductTypeSortingInput, before: String, after: String, first: Int, last: Int): ProductTypeCountableConnection\n  productVariant(id: ID!): ProductVariant\n  productVariants(ids: [ID], before: String, after: String, first: Int, last: Int): ProductVariantCountableConnection\n  reportProductSales(period: ReportingPeriod!, before: String, after: String, first: Int, last: Int): ProductVariantCountableConnection\n  payment(id: ID!): Payment\n  payments(before: String, after: String, first: Int, last: Int): PaymentCountableConnection\n  page(id: ID, slug: String): Page\n  pages(sortBy: PageSortingInput, filter: PageFilterInput, before: String, after: String, first: Int, last: Int): PageCountableConnection\n  homepageEvents(before: String, after: String, first: Int, last: Int): OrderEventCountableConnection\n  order(id: ID!): Order\n  orders(sortBy: OrderSortingInput, filter: OrderFilterInput, created: ReportingPeriod, status: OrderStatusFilter, before: String, after: String, first: Int, last: Int): OrderCountableConnection\n  draftOrders(sortBy: OrderSortingInput, filter: OrderDraftFilterInput, created: ReportingPeriod, before: String, after: String, first: Int, last: Int): OrderCountableConnection\n  ordersTotal(period: ReportingPeriod): TaxedMoney\n  orderByToken(token: UUID!): Order\n  menu(id: ID, name: String): Menu\n  menus(sortBy: MenuSortingInput, filter: MenuFilterInput, before: String, after: String, first: Int, last: Int): MenuCountableConnection\n  menuItem(id: ID!): MenuItem\n  menuItems(sortBy: MenuItemSortingInput, filter: MenuItemFilterInput, before: String, after: String, first: Int, last: Int): MenuItemCountableConnection\n  giftCard(id: ID!): GiftCard\n  giftCards(before: String, after: String, first: Int, last: Int): GiftCardCountableConnection\n  plugin(id: ID!): Plugin\n  plugins(filter: PluginFilterInput, sortBy: PluginSortingInput, before: String, after: String, first: Int, last: Int): PluginCountableConnection\n  sale(id: ID!): Sale\n  sales(filter: SaleFilterInput, sortBy: SaleSortingInput, query: String, before: String, after: String, first: Int, last: Int): SaleCountableConnection\n  voucher(id: ID!): Voucher\n  vouchers(filter: VoucherFilterInput, sortBy: VoucherSortingInput, query: String, before: String, after: String, first: Int, last: Int): VoucherCountableConnection\n  taxTypes: [TaxType]\n  checkout(token: UUID): Checkout\n  checkouts(before: String, after: String, first: Int, last: Int): CheckoutCountableConnection\n  checkoutLine(id: ID): CheckoutLine\n  checkoutLines(before: String, after: String, first: Int, last: Int): CheckoutLineCountableConnection\n  addressValidationRules(countryCode: CountryCode!, countryArea: String, city: String, cityArea: String): AddressValidationData\n  address(id: ID!): Address\n  customers(filter: CustomerFilterInput, sortBy: UserSortingInput, before: String, after: String, first: Int, last: Int): UserCountableConnection\n  permissionGroups(filter: PermissionGroupFilterInput, sortBy: PermissionGroupSortingInput, before: String, after: String, first: Int, last: Int): GroupCountableConnection\n  permissionGroup(id: ID!): Group\n  me: User\n  staffUsers(filter: StaffUserInput, sortBy: UserSortingInput, before: String, after: String, first: Int, last: Int): UserCountableConnection\n  serviceAccounts(filter: ServiceAccountFilterInput, sortBy: ServiceAccountSortingInput, before: String, after: String, first: Int, last: Int): ServiceAccountCountableConnection\n  serviceAccount(id: ID!): ServiceAccount\n  user(id: ID!): User\n  _entities(representations: [_Any]): [_Entity]\n  _service: _Service\n}\n\ntype ReducedRate {\n  rate: Float!\n  rateType: TaxRateType!\n}\n\ntype Refresh {\n  token: String\n  payload: GenericScalar\n}\n\ninput ReorderInput {\n  id: ID!\n  sortOrder: Int\n}\n\nenum ReportingPeriod {\n  TODAY\n  THIS_MONTH\n}\n\ntype RequestEmailChange {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n}\n\ntype RequestPasswordReset {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n}\n\ntype Sale implements Node {\n  id: ID!\n  name: String!\n  type: SaleType!\n  value: Float!\n  startDate: DateTime!\n  endDate: DateTime\n  categories(before: String, after: String, first: Int, last: Int): CategoryCountableConnection\n  collections(before: String, after: String, first: Int, last: Int): CollectionCountableConnection\n  products(before: String, after: String, first: Int, last: Int): ProductCountableConnection\n  translation(languageCode: LanguageCodeEnum!): SaleTranslation\n}\n\ntype SaleAddCatalogues {\n  errors: [Error!]\n  sale: Sale\n}\n\ntype SaleBulkDelete {\n  errors: [Error!]\n  count: Int!\n}\n\ntype SaleCountableConnection {\n  pageInfo: PageInfo!\n  edges: [SaleCountableEdge!]!\n  totalCount: Int\n}\n\ntype SaleCountableEdge {\n  node: Sale!\n  cursor: String!\n}\n\ntype SaleCreate {\n  errors: [Error!]\n  sale: Sale\n}\n\ntype SaleDelete {\n  errors: [Error!]\n  sale: Sale\n}\n\ninput SaleFilterInput {\n  status: [DiscountStatusEnum]\n  saleType: DiscountValueTypeEnum\n  started: DateTimeRangeInput\n  search: String\n}\n\ninput SaleInput {\n  name: String\n  type: DiscountValueTypeEnum\n  value: Decimal\n  products: [ID]\n  categories: [ID]\n  collections: [ID]\n  startDate: DateTime\n  endDate: DateTime\n}\n\ntype SaleRemoveCatalogues {\n  errors: [Error!]\n  sale: Sale\n}\n\nenum SaleSortField {\n  NAME\n  START_DATE\n  END_DATE\n  VALUE\n  TYPE\n}\n\ninput SaleSortingInput {\n  direction: OrderDirection!\n  field: SaleSortField!\n}\n\ntype SaleTranslatableContent implements Node {\n  id: ID!\n  name: String!\n  translation(languageCode: LanguageCodeEnum!): SaleTranslation\n  sale: Sale\n}\n\ntype SaleTranslate {\n  errors: [Error!]\n  sale: Sale\n}\n\ntype SaleTranslation implements Node {\n  id: ID!\n  name: String\n  language: LanguageDisplay!\n}\n\nenum SaleType {\n  FIXED\n  PERCENTAGE\n}\n\ntype SaleUpdate {\n  errors: [Error!]\n  sale: Sale\n}\n\ntype SelectedAttribute {\n  attribute: Attribute!\n  values: [AttributeValue]!\n}\n\ninput SeoInput {\n  title: String\n  description: String\n}\n\ntype ServiceAccount implements Node {\n  id: ID!\n  created: DateTime\n  isActive: Boolean\n  tokens: [ServiceAccountToken]\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  permissions: [PermissionDisplay]\n  name: String\n}\n\ntype ServiceAccountClearPrivateMeta {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  serviceAccount: ServiceAccount\n}\n\ntype ServiceAccountCountableConnection {\n  pageInfo: PageInfo!\n  edges: [ServiceAccountCountableEdge!]!\n  totalCount: Int\n}\n\ntype ServiceAccountCountableEdge {\n  node: ServiceAccount!\n  cursor: String!\n}\n\ntype ServiceAccountCreate {\n  errors: [Error!]\n  authToken: String\n  accountErrors: [AccountError!]\n  serviceAccount: ServiceAccount\n}\n\ntype ServiceAccountDelete {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  serviceAccount: ServiceAccount\n}\n\ninput ServiceAccountFilterInput {\n  search: String\n  isActive: Boolean\n}\n\ninput ServiceAccountInput {\n  name: String\n  isActive: Boolean\n  permissions: [PermissionEnum]\n}\n\nenum ServiceAccountSortField {\n  NAME\n  CREATION_DATE\n}\n\ninput ServiceAccountSortingInput {\n  direction: OrderDirection!\n  field: ServiceAccountSortField!\n}\n\ntype ServiceAccountToken implements Node {\n  name: String\n  authToken: String\n  id: ID!\n}\n\ntype ServiceAccountTokenCreate {\n  errors: [Error!]\n  authToken: String\n  accountErrors: [AccountError!]\n  serviceAccountToken: ServiceAccountToken\n}\n\ntype ServiceAccountTokenDelete {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  serviceAccountToken: ServiceAccountToken\n}\n\ninput ServiceAccountTokenInput {\n  name: String\n  serviceAccount: ID!\n}\n\ntype ServiceAccountUpdate {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  serviceAccount: ServiceAccount\n}\n\ntype ServiceAccountUpdatePrivateMeta {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  serviceAccount: ServiceAccount\n}\n\ntype SetPassword {\n  token: String\n  errors: [Error]!\n  user: User\n  accountErrors: [AccountError!]\n}\n\ntype ShippingError {\n  field: String\n  message: String\n  code: ShippingErrorCode\n}\n\nenum ShippingErrorCode {\n  ALREADY_EXISTS\n  GRAPHQL_ERROR\n  INVALID\n  MAX_LESS_THAN_MIN\n  NOT_FOUND\n  REQUIRED\n  UNIQUE\n}\n\ntype ShippingMethod implements Node {\n  id: ID!\n  name: String!\n  price: Money\n  minimumOrderPrice: Money\n  maximumOrderPrice: Money\n  minimumOrderWeight: Weight\n  maximumOrderWeight: Weight\n  type: ShippingMethodTypeEnum\n  translation(languageCode: LanguageCodeEnum!): ShippingMethodTranslation\n}\n\ntype ShippingMethodTranslatableContent implements Node {\n  id: ID!\n  name: String!\n  translation(languageCode: LanguageCodeEnum!): ShippingMethodTranslation\n  shippingMethod: ShippingMethod\n}\n\ntype ShippingMethodTranslation implements Node {\n  id: ID!\n  name: String\n  language: LanguageDisplay!\n}\n\nenum ShippingMethodTypeEnum {\n  PRICE\n  WEIGHT\n}\n\ntype ShippingPriceBulkDelete {\n  errors: [Error!]\n  count: Int!\n  shippingErrors: [ShippingError!]\n}\n\ntype ShippingPriceCreate {\n  errors: [Error!]\n  shippingZone: ShippingZone\n  shippingErrors: [ShippingError!]\n  shippingMethod: ShippingMethod\n}\n\ntype ShippingPriceDelete {\n  errors: [Error!]\n  shippingMethod: ShippingMethod\n  shippingZone: ShippingZone\n  shippingErrors: [ShippingError!]\n}\n\ninput ShippingPriceInput {\n  name: String\n  price: Decimal\n  minimumOrderPrice: Decimal\n  maximumOrderPrice: Decimal\n  minimumOrderWeight: WeightScalar\n  maximumOrderWeight: WeightScalar\n  type: ShippingMethodTypeEnum\n  shippingZone: ID\n}\n\ntype ShippingPriceTranslate {\n  errors: [Error!]\n  shippingMethod: ShippingMethod\n}\n\ntype ShippingPriceUpdate {\n  errors: [Error!]\n  shippingZone: ShippingZone\n  shippingErrors: [ShippingError!]\n  shippingMethod: ShippingMethod\n}\n\ntype ShippingZone implements Node {\n  id: ID!\n  name: String!\n  default: Boolean!\n  priceRange: MoneyRange\n  countries: [CountryDisplay]\n  shippingMethods: [ShippingMethod]\n}\n\ntype ShippingZoneBulkDelete {\n  errors: [Error!]\n  count: Int!\n  shippingErrors: [ShippingError!]\n}\n\ntype ShippingZoneCountableConnection {\n  pageInfo: PageInfo!\n  edges: [ShippingZoneCountableEdge!]!\n  totalCount: Int\n}\n\ntype ShippingZoneCountableEdge {\n  node: ShippingZone!\n  cursor: String!\n}\n\ntype ShippingZoneCreate {\n  errors: [Error!]\n  shippingZone: ShippingZone\n  shippingErrors: [ShippingError!]\n}\n\ntype ShippingZoneDelete {\n  errors: [Error!]\n  shippingErrors: [ShippingError!]\n  shippingZone: ShippingZone\n}\n\ninput ShippingZoneInput {\n  name: String\n  countries: [String]\n  default: Boolean\n}\n\ntype ShippingZoneUpdate {\n  errors: [Error!]\n  shippingZone: ShippingZone\n  shippingErrors: [ShippingError!]\n}\n\ntype Shop {\n  geolocalization: Geolocalization\n  authorizationKeys: [AuthorizationKey]!\n  countries(languageCode: LanguageCodeEnum): [CountryDisplay]!\n  currencies: [String]!\n  defaultCurrency: String!\n  defaultCountry: CountryDisplay\n  defaultMailSenderName: String\n  defaultMailSenderAddress: String\n  description: String\n  domain: Domain!\n  homepageCollection: Collection\n  languages: [LanguageDisplay]!\n  name: String!\n  navigation: Navigation\n  permissions: [PermissionDisplay]!\n  phonePrefixes: [String]!\n  headerText: String\n  includeTaxesInPrices: Boolean!\n  displayGrossPrices: Boolean!\n  chargeTaxesOnShipping: Boolean!\n  trackInventoryByDefault: Boolean\n  defaultWeightUnit: WeightUnitsEnum\n  translation(languageCode: LanguageCodeEnum!): ShopTranslation\n  automaticFulfillmentDigitalProducts: Boolean\n  defaultDigitalMaxDownloads: Int\n  defaultDigitalUrlValidDays: Int\n  companyAddress: Address\n  customerSetPasswordUrl: String\n  staffNotificationRecipients: [StaffNotificationRecipient]\n}\n\ntype ShopAddressUpdate {\n  errors: [Error!]\n  shop: Shop\n  shopErrors: [ShopError!]\n}\n\ntype ShopDomainUpdate {\n  errors: [Error!]\n  shop: Shop\n  shopErrors: [ShopError!]\n}\n\ntype ShopError {\n  field: String\n  message: String\n  code: ShopErrorCode\n}\n\nenum ShopErrorCode {\n  ALREADY_EXISTS\n  CANNOT_FETCH_TAX_RATES\n  GRAPHQL_ERROR\n  INVALID\n  NOT_FOUND\n  REQUIRED\n  UNIQUE\n}\n\ntype ShopFetchTaxRates {\n  errors: [Error!]\n  shop: Shop\n  shopErrors: [ShopError!]\n}\n\ninput ShopSettingsInput {\n  headerText: String\n  description: String\n  includeTaxesInPrices: Boolean\n  displayGrossPrices: Boolean\n  chargeTaxesOnShipping: Boolean\n  trackInventoryByDefault: Boolean\n  defaultWeightUnit: WeightUnitsEnum\n  automaticFulfillmentDigitalProducts: Boolean\n  defaultDigitalMaxDownloads: Int\n  defaultDigitalUrlValidDays: Int\n  defaultMailSenderName: String\n  defaultMailSenderAddress: String\n  customerSetPasswordUrl: String\n}\n\ntype ShopSettingsTranslate {\n  errors: [Error!]\n  shop: Shop\n}\n\ninput ShopSettingsTranslationInput {\n  headerText: String\n  description: String\n}\n\ntype ShopSettingsUpdate {\n  errors: [Error!]\n  shop: Shop\n  shopErrors: [ShopError!]\n}\n\ntype ShopTranslation implements Node {\n  id: ID!\n  headerText: String!\n  description: String!\n  language: LanguageDisplay!\n}\n\ninput SiteDomainInput {\n  domain: String\n  name: String\n}\n\ntype StaffBulkDelete {\n  errors: [Error!]\n  count: Int!\n  accountErrors: [AccountError!]\n}\n\ntype StaffCreate {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ninput StaffCreateInput {\n  firstName: String\n  lastName: String\n  email: String\n  isActive: Boolean\n  note: String\n  permissions: [PermissionEnum]\n  redirectUrl: String\n}\n\ntype StaffDelete {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ninput StaffInput {\n  firstName: String\n  lastName: String\n  email: String\n  isActive: Boolean\n  note: String\n  permissions: [PermissionEnum]\n}\n\nenum StaffMemberStatus {\n  ACTIVE\n  DEACTIVATED\n}\n\ntype StaffNotificationRecipient implements Node {\n  user: User\n  active: Boolean\n  id: ID!\n  email: String\n}\n\ntype StaffNotificationRecipientCreate {\n  errors: [Error!]\n  shopErrors: [ShopError!]\n  staffNotificationRecipient: StaffNotificationRecipient\n}\n\ntype StaffNotificationRecipientDelete {\n  errors: [Error!]\n  shopErrors: [ShopError!]\n  staffNotificationRecipient: StaffNotificationRecipient\n}\n\ninput StaffNotificationRecipientInput {\n  user: ID\n  email: String\n  active: Boolean\n}\n\ntype StaffNotificationRecipientUpdate {\n  errors: [Error!]\n  shopErrors: [ShopError!]\n  staffNotificationRecipient: StaffNotificationRecipient\n}\n\ntype StaffUpdate {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ninput StaffUserInput {\n  status: StaffMemberStatus\n  search: String\n}\n\ntype Stock implements Node {\n  warehouse: Warehouse!\n  productVariant: ProductVariant!\n  quantity: Int!\n  quantityAllocated: Int!\n  id: ID!\n  stockQuantity: Int!\n}\n\nenum StockAvailability {\n  IN_STOCK\n  OUT_OF_STOCK\n}\n\ntype StockBulkDelete {\n  errors: [Error!]\n  count: Int!\n  stockError: [StockError!]\n}\n\ntype StockCountableConnection {\n  pageInfo: PageInfo!\n  edges: [StockCountableEdge!]!\n  totalCount: Int\n}\n\ntype StockCountableEdge {\n  node: Stock!\n  cursor: String!\n}\n\ntype StockCreate {\n  errors: [Error!]\n  stockErrors: [StockError!]\n  stock: Stock\n}\n\ntype StockDelete {\n  errors: [Error!]\n  stock: Stock\n}\n\nenum StockErorrCode {\n  ALREADY_EXISTS\n  GRAPHQL_ERROR\n  INVALID\n  NOT_FOUND\n  REQUIRED\n  UNIQUE\n}\n\ntype StockError {\n  field: String\n  message: String\n  code: StockErorrCode\n}\n\ninput StockFilterInput {\n  quantity: Float\n  quantityAllocated: Float\n  search: String\n}\n\ninput StockInput {\n  productVariant: ID!\n  warehouse: ID!\n  quantity: Int\n}\n\ntype StockUpdate {\n  errors: [Error!]\n  stockError: [StockError!]\n  stock: Stock\n}\n\nenum TaxRateType {\n  ACCOMMODATION\n  ADMISSION_TO_CULTURAL_EVENTS\n  ADMISSION_TO_ENTERTAINMENT_EVENTS\n  ADMISSION_TO_SPORTING_EVENTS\n  ADVERTISING\n  AGRICULTURAL_SUPPLIES\n  BABY_FOODSTUFFS\n  BIKES\n  BOOKS\n  CHILDRENS_CLOTHING\n  DOMESTIC_FUEL\n  DOMESTIC_SERVICES\n  E_BOOKS\n  FOODSTUFFS\n  HOTELS\n  MEDICAL\n  NEWSPAPERS\n  PASSENGER_TRANSPORT\n  PHARMACEUTICALS\n  PROPERTY_RENOVATIONS\n  RESTAURANTS\n  SOCIAL_HOUSING\n  STANDARD\n  WATER\n  WINE\n}\n\ntype TaxType {\n  description: String\n  taxCode: String\n}\n\ntype TaxedMoney {\n  currency: String!\n  gross: Money!\n  net: Money!\n  tax: Money!\n}\n\ntype TaxedMoneyRange {\n  start: TaxedMoney\n  stop: TaxedMoney\n}\n\ntype Transaction implements Node {\n  id: ID!\n  created: DateTime!\n  payment: Payment!\n  token: String!\n  kind: TransactionKind!\n  isSuccess: Boolean!\n  error: TransactionError\n  gatewayResponse: JSONString!\n  amount: Money\n}\n\nenum TransactionError {\n  TRANSACTIONERROR_INCORRECT_NUMBER\n  TRANSACTIONERROR_INVALID_NUMBER\n  TRANSACTIONERROR_INCORRECT_CVV\n  TRANSACTIONERROR_INVALID_CVV\n  TRANSACTIONERROR_INCORRECT_ZIP\n  TRANSACTIONERROR_INCORRECT_ADDRESS\n  TRANSACTIONERROR_INVALID_EXPIRY_DATE\n  TRANSACTIONERROR_EXPIRED\n  TRANSACTIONERROR_PROCESSING_ERROR\n  TRANSACTIONERROR_DECLINED\n}\n\nenum TransactionKind {\n  AUTH\n  REFUND\n  CAPTURE\n  VOID\n  CONFIRM\n}\n\nunion TranslatableItem = ProductTranslatableContent | CollectionTranslatableContent | CategoryTranslatableContent | AttributeTranslatableContent | AttributeValueTranslatableContent | ProductVariantTranslatableContent | PageTranslatableContent | ShippingMethodTranslatableContent | SaleTranslatableContent | VoucherTranslatableContent | MenuItemTranslatableContent\n\ntype TranslatableItemConnection {\n  pageInfo: PageInfo!\n  edges: [TranslatableItemEdge!]!\n  totalCount: Int\n}\n\ntype TranslatableItemEdge {\n  node: TranslatableItem!\n  cursor: String!\n}\n\nenum TranslatableKinds {\n  ATTRIBUTE\n  ATTRIBUTE_VALUE\n  CATEGORY\n  COLLECTION\n  MENU_ITEM\n  PAGE\n  PRODUCT\n  SALE\n  SHIPPING_METHOD\n  VARIANT\n  VOUCHER\n}\n\ninput TranslationInput {\n  seoTitle: String\n  seoDescription: String\n  name: String\n  description: String\n  descriptionJson: JSONString\n}\n\nscalar UUID\n\nscalar Upload\n\ntype User implements Node {\n  id: ID!\n  lastLogin: DateTime\n  email: String!\n  firstName: String!\n  lastName: String!\n  isStaff: Boolean!\n  isActive: Boolean!\n  note: String\n  dateJoined: DateTime!\n  defaultShippingAddress: Address\n  defaultBillingAddress: Address\n  privateMeta: [MetaStore]!\n  meta: [MetaStore]!\n  addresses: [Address]\n  checkout: Checkout\n  giftCards(before: String, after: String, first: Int, last: Int): GiftCardCountableConnection\n  orders(before: String, after: String, first: Int, last: Int): OrderCountableConnection\n  permissions: [PermissionDisplay]\n  avatar(size: Int): Image\n  events: [CustomerEvent]\n  storedPaymentSources: [PaymentSource]\n  wishlist(before: String, after: String, first: Int, last: Int): WishlistItemCountableConnection\n}\n\ntype UserAvatarDelete {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n}\n\ntype UserAvatarUpdate {\n  errors: [Error!]\n  user: User\n  accountErrors: [AccountError!]\n}\n\ntype UserBulkSetActive {\n  errors: [Error!]\n  count: Int!\n  accountErrors: [AccountError!]\n}\n\ntype UserClearMeta {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ntype UserClearPrivateMeta {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ntype UserCountableConnection {\n  pageInfo: PageInfo!\n  edges: [UserCountableEdge!]!\n  totalCount: Int\n}\n\ntype UserCountableEdge {\n  node: User!\n  cursor: String!\n}\n\ninput UserCreateInput {\n  defaultBillingAddress: AddressInput\n  defaultShippingAddress: AddressInput\n  firstName: String\n  lastName: String\n  email: String\n  isActive: Boolean\n  note: String\n  redirectUrl: String\n}\n\nenum UserSortField {\n  FIRST_NAME\n  LAST_NAME\n  EMAIL\n  ORDER_COUNT\n}\n\ninput UserSortingInput {\n  direction: OrderDirection!\n  field: UserSortField!\n}\n\ntype UserUpdateMeta {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ntype UserUpdatePrivateMeta {\n  errors: [Error!]\n  accountErrors: [AccountError!]\n  user: User\n}\n\ninput UsersInput {\n  users: [ID!]!\n}\n\ntype VAT {\n  countryCode: String!\n  standardRate: Float\n  reducedRates: [ReducedRate]!\n}\n\ntype VariantImageAssign {\n  errors: [Error!]\n  productVariant: ProductVariant\n  image: ProductImage\n  productErrors: [ProductError!]\n}\n\ntype VariantImageUnassign {\n  errors: [Error!]\n  productVariant: ProductVariant\n  image: ProductImage\n  productErrors: [ProductError!]\n}\n\ntype VariantPricingInfo {\n  onSale: Boolean\n  discount: TaxedMoney\n  discountLocalCurrency: TaxedMoney\n  price: TaxedMoney\n  priceUndiscounted: TaxedMoney\n  priceLocalCurrency: TaxedMoney\n}\n\ntype VerifyToken {\n  payload: GenericScalar\n  user: User\n}\n\ntype Voucher implements Node {\n  id: ID!\n  name: String\n  type: VoucherTypeEnum!\n  code: String!\n  usageLimit: Int\n  used: Int!\n  startDate: DateTime!\n  endDate: DateTime\n  applyOncePerOrder: Boolean!\n  applyOncePerCustomer: Boolean!\n  discountValueType: DiscountValueTypeEnum!\n  discountValue: Float!\n  minSpent: Money\n  minCheckoutItemsQuantity: Int\n  categories(before: String, after: String, first: Int, last: Int): CategoryCountableConnection\n  collections(before: String, after: String, first: Int, last: Int): CollectionCountableConnection\n  products(before: String, after: String, first: Int, last: Int): ProductCountableConnection\n  countries: [CountryDisplay]\n  translation(languageCode: LanguageCodeEnum!): VoucherTranslation\n}\n\ntype VoucherAddCatalogues {\n  errors: [Error!]\n  voucher: Voucher\n}\n\ntype VoucherBulkDelete {\n  errors: [Error!]\n  count: Int!\n}\n\ntype VoucherCountableConnection {\n  pageInfo: PageInfo!\n  edges: [VoucherCountableEdge!]!\n  totalCount: Int\n}\n\ntype VoucherCountableEdge {\n  node: Voucher!\n  cursor: String!\n}\n\ntype VoucherCreate {\n  errors: [Error!]\n  voucher: Voucher\n}\n\ntype VoucherDelete {\n  errors: [Error!]\n  voucher: Voucher\n}\n\nenum VoucherDiscountType {\n  FIXED\n  PERCENTAGE\n  SHIPPING\n}\n\ninput VoucherFilterInput {\n  status: [DiscountStatusEnum]\n  timesUsed: IntRangeInput\n  discountType: [VoucherDiscountType]\n  started: DateTimeRangeInput\n  search: String\n}\n\ninput VoucherInput {\n  type: VoucherTypeEnum\n  name: String\n  code: String\n  startDate: DateTime\n  endDate: DateTime\n  discountValueType: DiscountValueTypeEnum\n  discountValue: Decimal\n  products: [ID]\n  collections: [ID]\n  categories: [ID]\n  minAmountSpent: Decimal\n  minCheckoutItemsQuantity: Int\n  countries: [String]\n  applyOncePerOrder: Boolean\n  applyOncePerCustomer: Boolean\n  usageLimit: Int\n}\n\ntype VoucherRemoveCatalogues {\n  errors: [Error!]\n  voucher: Voucher\n}\n\nenum VoucherSortField {\n  CODE\n  START_DATE\n  END_DATE\n  VALUE\n  TYPE\n  USAGE_LIMIT\n  MINIMUM_SPENT_AMOUNT\n}\n\ninput VoucherSortingInput {\n  direction: OrderDirection!\n  field: VoucherSortField!\n}\n\ntype VoucherTranslatableContent implements Node {\n  id: ID!\n  name: String\n  translation(languageCode: LanguageCodeEnum!): VoucherTranslation\n  voucher: Voucher\n}\n\ntype VoucherTranslate {\n  errors: [Error!]\n  voucher: Voucher\n}\n\ntype VoucherTranslation implements Node {\n  id: ID!\n  name: String\n  language: LanguageDisplay!\n}\n\nenum VoucherTypeEnum {\n  SHIPPING\n  ENTIRE_ORDER\n  SPECIFIC_PRODUCT\n}\n\ntype VoucherUpdate {\n  errors: [Error!]\n  voucher: Voucher\n}\n\ntype Warehouse implements Node {\n  id: ID!\n  name: String!\n  companyName: String!\n  shippingZones(before: String, after: String, first: Int, last: Int): ShippingZoneCountableConnection!\n  address: Address!\n  email: String!\n}\n\ninput WarehouseAddressInput {\n  streetAddress1: String!\n  streetAddress2: String\n  city: String!\n  cityArea: String\n  postalCode: String\n  country: CountryCode!\n  countryArea: String\n  phone: String\n}\n\ntype WarehouseCountableConnection {\n  pageInfo: PageInfo!\n  edges: [WarehouseCountableEdge!]!\n  totalCount: Int\n}\n\ntype WarehouseCountableEdge {\n  node: Warehouse!\n  cursor: String!\n}\n\ntype WarehouseCreate {\n  errors: [Error!]\n  warehouseErrors: [WarehouseError!]\n  warehouse: Warehouse\n}\n\ninput WarehouseCreateInput {\n  name: String!\n  companyName: String\n  shippingZones: [ID]\n  email: String\n  address: WarehouseAddressInput!\n}\n\ntype WarehouseDelete {\n  errors: [Error!]\n  warehouseErrors: [WarehouseError!]\n  warehouse: Warehouse\n}\n\ntype WarehouseError {\n  field: String\n  message: String\n  code: WarehouseErrorCode\n}\n\nenum WarehouseErrorCode {\n  ALREADY_EXISTS\n  GRAPHQL_ERROR\n  INVALID\n  NOT_FOUND\n  REQUIRED\n  UNIQUE\n}\n\ninput WarehouseFilterInput {\n  search: String\n}\n\ntype WarehouseUpdate {\n  errors: [Error!]\n  warehouseErrors: [WarehouseError!]\n  warehouse: Warehouse\n}\n\ninput WarehouseUpdateInput {\n  name: String!\n  companyName: String\n  shippingZones: [ID]\n  email: String\n  address: WarehouseAddressInput\n}\n\ntype Webhook implements Node {\n  name: String\n  serviceAccount: ServiceAccount!\n  targetUrl: String!\n  isActive: Boolean!\n  secretKey: String\n  id: ID!\n  events: [WebhookEvent]\n}\n\ntype WebhookCountableConnection {\n  pageInfo: PageInfo!\n  edges: [WebhookCountableEdge!]!\n  totalCount: Int\n}\n\ntype WebhookCountableEdge {\n  node: Webhook!\n  cursor: String!\n}\n\ntype WebhookCreate {\n  errors: [Error!]\n  webhookErrors: [WebhookError!]\n  webhook: Webhook\n}\n\ninput WebhookCreateInput {\n  name: String\n  targetUrl: String\n  events: [WebhookEventTypeEnum]\n  serviceAccount: ID\n  isActive: Boolean\n  secretKey: String\n}\n\ntype WebhookDelete {\n  errors: [Error!]\n  webhook: Webhook\n  webhookErrors: [WebhookError!]\n}\n\ntype WebhookError {\n  field: String\n  message: String\n  code: WebhookErrorCode\n}\n\nenum WebhookErrorCode {\n  GRAPHQL_ERROR\n  INVALID\n  NOT_FOUND\n  REQUIRED\n  UNIQUE\n}\n\ntype WebhookEvent {\n  eventType: WebhookEventTypeEnum\n  name: String\n}\n\nenum WebhookEventTypeEnum {\n  ANY_EVENTS\n  ORDER_CREATED\n  ORDER_FULLY_PAID\n  ORDER_UPDATED\n  ORDER_CANCELLED\n  ORDER_FULFILLED\n  CUSTOMER_CREATED\n  PRODUCT_CREATED\n  CHECKOUT_QUANTITY_CHANGED\n}\n\ninput WebhookFilterInput {\n  search: String\n  isActive: Boolean\n}\n\nenum WebhookSortField {\n  NAME\n  SERVICE_ACCOUNT\n  TARGET_URL\n}\n\ninput WebhookSortingInput {\n  direction: OrderDirection!\n  field: WebhookSortField!\n}\n\ntype WebhookUpdate {\n  errors: [Error!]\n  webhook: Webhook\n  webhookErrors: [WebhookError!]\n}\n\ninput WebhookUpdateInput {\n  name: String\n  targetUrl: String\n  events: [WebhookEventTypeEnum]\n  serviceAccount: ID\n  isActive: Boolean\n  secretKey: String\n}\n\ntype Weight {\n  unit: String!\n  value: Float!\n}\n\nscalar WeightScalar\n\nenum WeightUnitsEnum {\n  KG\n  LB\n  OZ\n  G\n}\n\ntype Wishlist implements Node {\n  id: ID!\n  createdAt: DateTime!\n  items(before: String, after: String, first: Int, last: Int, id: ID): WishlistItemCountableConnection!\n}\n\ntype WishlistAddProductMutation {\n  errors: [Error!]\n  wishlist: [WishlistItem]\n  wishlistErrors: [WishlistError!]\n}\n\ntype WishlistAddProductVariantMutation {\n  errors: [Error!]\n  wishlist: [WishlistItem]\n  wishlistErrors: [WishlistError!]\n}\n\ntype WishlistError {\n  field: String\n  message: String\n  code: WishlistErrorCode\n}\n\nenum WishlistErrorCode {\n  GRAPHQL_ERROR\n  INVALID\n  NOT_FOUND\n  REQUIRED\n  UNIQUE\n}\n\ntype WishlistItem implements Node {\n  id: ID!\n  wishlist: Wishlist!\n  product: Product!\n  variants(before: String, after: String, first: Int, last: Int): ProductVariantCountableConnection!\n}\n\ntype WishlistItemCountableConnection {\n  pageInfo: PageInfo!\n  edges: [WishlistItemCountableEdge!]!\n  totalCount: Int\n}\n\ntype WishlistItemCountableEdge {\n  node: WishlistItem!\n  cursor: String!\n}\n\ntype WishlistRemoveProductMutation {\n  errors: [Error!]\n  wishlist: [WishlistItem]\n  wishlistErrors: [WishlistError!]\n}\n\ntype WishlistRemoveProductVariantMutation {\n  errors: [Error!]\n  wishlist: [WishlistItem]\n  wishlistErrors: [WishlistError!]\n}\n\nscalar _Any\n\nunion _Entity = Address | ServiceAccount | User | Group | ProductVariant | Product | ProductType | Collection | Category | ProductImage\n\ntype _Service {\n  sdl: String\n}\n", "import uuid\nfrom decimal import Decimal\nfrom unittest import mock\nfrom unittest.mock import ANY, patch\n\nimport graphene\nimport pytest\nfrom django.core.exceptions import ValidationError\nfrom prices import Money, TaxedMoney\n\nfrom saleor.account.models import User\nfrom saleor.checkout import calculations\nfrom saleor.checkout.error_codes import CheckoutErrorCode\nfrom saleor.checkout.models import Checkout\nfrom saleor.checkout.utils import clean_checkout, is_fully_paid\nfrom saleor.core.payments import PaymentInterface\nfrom saleor.core.taxes import zero_money\nfrom saleor.extensions.manager import ExtensionsManager\nfrom saleor.graphql.checkout.mutations import (\n    clean_shipping_method,\n    update_checkout_shipping_method_if_invalid,\n)\nfrom saleor.order.models import Order\nfrom saleor.payment import TransactionKind\nfrom saleor.payment.interface import GatewayResponse\nfrom saleor.shipping import ShippingMethodType\nfrom saleor.shipping.models import ShippingMethod\nfrom saleor.warehouse.models import Stock\nfrom tests.api.utils import assert_no_permission, get_graphql_content\n\n\n@pytest.fixture\ndef other_shipping_method(shipping_zone):\n    return ShippingMethod.objects.create(\n        name=\"DPD\",\n        minimum_order_price=Money(0, \"USD\"),\n        type=ShippingMethodType.PRICE_BASED,\n        price=Money(9, \"USD\"),\n        shipping_zone=shipping_zone,\n    )\n\n\n@pytest.fixture(autouse=True)\ndef setup_dummy_gateway(settings):\n    settings.PLUGINS = [\"saleor.payment.gateways.dummy.plugin.DummyGatewayPlugin\"]\n    return settings\n\n\ndef test_clean_shipping_method_after_shipping_address_changes_stay_the_same(\n    checkout_with_single_item, address, shipping_method, other_shipping_method\n):\n    \"\"\"Ensure the current shipping method applies to new address.\n\n    If it does, then it doesn't need to be changed.\n    \"\"\"\n\n    checkout = checkout_with_single_item\n    checkout.shipping_address = address\n\n    is_valid_method = clean_shipping_method(checkout, shipping_method, [])\n    assert is_valid_method is True\n\n\ndef test_clean_shipping_method_does_nothing_if_no_shipping_method(\n    checkout_with_single_item, address, other_shipping_method\n):\n    \"\"\"If no shipping method was selected, it shouldn't return an error.\"\"\"\n\n    checkout = checkout_with_single_item\n    checkout.shipping_address = address\n\n    is_valid_method = clean_shipping_method(checkout, None, [])\n    assert is_valid_method is True\n\n\ndef test_update_checkout_shipping_method_if_invalid(\n    checkout_with_single_item,\n    address,\n    shipping_method,\n    other_shipping_method,\n    shipping_zone_without_countries,\n):\n    \"\"\"If the shipping method is invalid, it should replace it.\"\"\"\n\n    checkout = checkout_with_single_item\n    checkout.shipping_address = address\n    checkout.shipping_method = shipping_method\n\n    shipping_method.shipping_zone = shipping_zone_without_countries\n    shipping_method.save(update_fields=[\"shipping_zone\"])\n\n    update_checkout_shipping_method_if_invalid(checkout, None)\n\n    assert checkout.shipping_method == other_shipping_method\n\n    # Ensure the checkout's shipping method was saved\n    checkout.refresh_from_db(fields=[\"shipping_method\"])\n    assert checkout.shipping_method == other_shipping_method\n\n\nMUTATION_CHECKOUT_CREATE = \"\"\"\n    mutation createCheckout($checkoutInput: CheckoutCreateInput!) {\n      checkoutCreate(input: $checkoutInput) {\n        created\n        checkout {\n          id\n          token\n          email\n          lines {\n            quantity\n          }\n        }\n        errors {\n          field\n          message\n        }\n        checkoutErrors {\n          field\n          message\n          code\n        }\n      }\n    }\n\"\"\"\n\n\ndef test_checkout_create(api_client, stock, graphql_address_data):\n    \"\"\"Create checkout object using GraphQL API.\"\"\"\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.id)\n    test_email = \"test@example.com\"\n    shipping_address = graphql_address_data\n    variables = {\n        \"checkoutInput\": {\n            \"lines\": [{\"quantity\": 1, \"variantId\": variant_id}],\n            \"email\": test_email,\n            \"shippingAddress\": shipping_address,\n        }\n    }\n    assert not Checkout.objects.exists()\n    response = api_client.post_graphql(MUTATION_CHECKOUT_CREATE, variables)\n    content = get_graphql_content(response)[\"data\"][\"checkoutCreate\"]\n\n    # Look at the flag to see whether a new checkout was created or not\n    assert content[\"created\"] is True\n\n    new_checkout = Checkout.objects.first()\n    assert new_checkout is not None\n    checkout_data = content[\"checkout\"]\n    assert checkout_data[\"token\"] == str(new_checkout.token)\n    assert new_checkout.lines.count() == 1\n    checkout_line = new_checkout.lines.first()\n    assert checkout_line.variant == variant\n    assert checkout_line.quantity == 1\n    assert new_checkout.shipping_address is not None\n    assert new_checkout.shipping_address.first_name == shipping_address[\"firstName\"]\n    assert new_checkout.shipping_address.last_name == shipping_address[\"lastName\"]\n    assert (\n        new_checkout.shipping_address.street_address_1\n        == shipping_address[\"streetAddress1\"]\n    )\n    assert (\n        new_checkout.shipping_address.street_address_2\n        == shipping_address[\"streetAddress2\"]\n    )\n    assert new_checkout.shipping_address.postal_code == shipping_address[\"postalCode\"]\n    assert new_checkout.shipping_address.country == shipping_address[\"country\"]\n    assert new_checkout.shipping_address.city == shipping_address[\"city\"].upper()\n\n\n@pytest.mark.parametrize(\n    \"quantity, expected_error_message, error_code\",\n    (\n        (\n            -1,\n            \"The quantity should be higher than zero.\",\n            CheckoutErrorCode.ZERO_QUANTITY,\n        ),\n        (\n            51,\n            \"Cannot add more than 50 times this item.\",\n            CheckoutErrorCode.QUANTITY_GREATER_THAN_LIMIT,\n        ),\n    ),\n)\ndef test_checkout_create_cannot_add_invalid_quantities(\n    api_client,\n    stock,\n    graphql_address_data,\n    quantity,\n    expected_error_message,\n    error_code,\n):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.id)\n    test_email = \"test@example.com\"\n    shipping_address = graphql_address_data\n    variables = {\n        \"checkoutInput\": {\n            \"lines\": [{\"quantity\": quantity, \"variantId\": variant_id}],\n            \"email\": test_email,\n            \"shippingAddress\": shipping_address,\n        }\n    }\n    assert not Checkout.objects.exists()\n    response = api_client.post_graphql(MUTATION_CHECKOUT_CREATE, variables)\n    content = get_graphql_content(response)[\"data\"][\"checkoutCreate\"]\n    assert content[\"errors\"]\n    assert content[\"errors\"] == [\n        {\"field\": \"quantity\", \"message\": expected_error_message}\n    ]\n\n    assert content[\"checkoutErrors\"] == [\n        {\n            \"field\": \"quantity\",\n            \"message\": expected_error_message,\n            \"code\": error_code.name,\n        }\n    ]\n\n\ndef test_checkout_create_reuse_checkout(checkout, user_api_client, stock):\n    # assign user to the checkout\n    checkout.user = user_api_client.user\n    checkout.save()\n    variant = stock.product_variant\n\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.id)\n    variables = {\"checkoutInput\": {\"lines\": [{\"quantity\": 1, \"variantId\": variant_id}]}}\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_CREATE, variables)\n    content = get_graphql_content(response)[\"data\"][\"checkoutCreate\"]\n\n    # Look at the flag to see whether a new checkout was created or not\n    assert not content[\"created\"]\n\n    # assert that existing checkout was reused and returned by mutation\n    checkout_data = content[\"checkout\"]\n    assert checkout_data[\"token\"] == str(checkout.token)\n\n    # if checkout was reused it should be returned unmodified (e.g. without\n    # adding new lines that was passed)\n    assert checkout_data[\"lines\"] == []\n\n\ndef test_checkout_create_required_email(api_client, stock):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.id)\n    variables = {\n        \"checkoutInput\": {\n            \"lines\": [{\"quantity\": 1, \"variantId\": variant_id}],\n            \"email\": \"\",\n        }\n    }\n\n    response = api_client.post_graphql(MUTATION_CHECKOUT_CREATE, variables)\n    content = get_graphql_content(response)\n\n    errors = content[\"data\"][\"checkoutCreate\"][\"errors\"]\n    assert errors\n    assert errors[0][\"field\"] == \"email\"\n    assert errors[0][\"message\"] == \"This field cannot be blank.\"\n\n    checkout_errors = content[\"data\"][\"checkoutCreate\"][\"checkoutErrors\"]\n    assert checkout_errors[0][\"code\"] == CheckoutErrorCode.REQUIRED.name\n\n\ndef test_checkout_create_default_email_for_logged_in_customer(user_api_client, stock):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.id)\n    variables = {\"checkoutInput\": {\"lines\": [{\"quantity\": 1, \"variantId\": variant_id}]}}\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_CREATE, variables)\n    customer = user_api_client.user\n    content = get_graphql_content(response)\n    new_checkout = Checkout.objects.first()\n    assert new_checkout is not None\n    checkout_data = content[\"data\"][\"checkoutCreate\"][\"checkout\"]\n    assert checkout_data[\"email\"] == str(customer.email)\n    assert new_checkout.user.id == customer.id\n    assert new_checkout.email == customer.email\n\n\ndef test_checkout_create_logged_in_customer(user_api_client, stock):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.id)\n    variables = {\n        \"checkoutInput\": {\n            \"email\": user_api_client.user.email,\n            \"lines\": [{\"quantity\": 1, \"variantId\": variant_id}],\n        }\n    }\n    assert not Checkout.objects.exists()\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_CREATE, variables)\n    content = get_graphql_content(response)\n    new_checkout = Checkout.objects.first()\n    assert new_checkout is not None\n    checkout_data = content[\"data\"][\"checkoutCreate\"][\"checkout\"]\n    assert checkout_data[\"token\"] == str(new_checkout.token)\n    checkout_user = new_checkout.user\n    customer = user_api_client.user\n    assert customer.id == checkout_user.id\n    assert customer.default_shipping_address_id != new_checkout.shipping_address_id\n    assert (\n        customer.default_shipping_address.as_data()\n        == new_checkout.shipping_address.as_data()\n    )\n    assert customer.default_billing_address_id != new_checkout.billing_address_id\n    assert (\n        customer.default_billing_address.as_data()\n        == new_checkout.billing_address.as_data()\n    )\n    assert customer.email == new_checkout.email\n\n\ndef test_checkout_create_logged_in_customer_custom_email(user_api_client, stock):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.id)\n    customer = user_api_client.user\n    custom_email = \"custom@example.com\"\n    variables = {\n        \"checkoutInput\": {\n            \"lines\": [{\"quantity\": 1, \"variantId\": variant_id}],\n            \"email\": custom_email,\n        }\n    }\n    assert not Checkout.objects.exists()\n    assert not custom_email == customer.email\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_CREATE, variables)\n    content = get_graphql_content(response)\n    new_checkout = Checkout.objects.first()\n    assert new_checkout is not None\n    checkout_data = content[\"data\"][\"checkoutCreate\"][\"checkout\"]\n    assert checkout_data[\"token\"] == str(new_checkout.token)\n    checkout_user = new_checkout.user\n    assert customer.id == checkout_user.id\n    assert new_checkout.email == custom_email\n\n\ndef test_checkout_create_logged_in_customer_custom_addresses(\n    user_api_client, stock, graphql_address_data\n):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.id)\n    shipping_address = graphql_address_data\n    billing_address = graphql_address_data\n    variables = {\n        \"checkoutInput\": {\n            \"email\": user_api_client.user.email,\n            \"lines\": [{\"quantity\": 1, \"variantId\": variant_id}],\n            \"shippingAddress\": shipping_address,\n            \"billingAddress\": billing_address,\n        }\n    }\n    assert not Checkout.objects.exists()\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_CREATE, variables)\n    content = get_graphql_content(response)\n    new_checkout = Checkout.objects.first()\n    assert new_checkout is not None\n    checkout_data = content[\"data\"][\"checkoutCreate\"][\"checkout\"]\n    assert checkout_data[\"token\"] == str(new_checkout.token)\n    checkout_user = new_checkout.user\n    customer = user_api_client.user\n    assert customer.id == checkout_user.id\n    assert not (\n        customer.default_shipping_address_id == new_checkout.shipping_address_id\n    )\n    assert not (customer.default_billing_address_id == new_checkout.billing_address_id)\n    assert new_checkout.shipping_address.first_name == shipping_address[\"firstName\"]\n    assert new_checkout.billing_address.first_name == billing_address[\"firstName\"]\n\n\ndef test_checkout_create_check_lines_quantity(\n    user_api_client, stock, graphql_address_data\n):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.id)\n    test_email = \"test@example.com\"\n    shipping_address = graphql_address_data\n    variables = {\n        \"checkoutInput\": {\n            \"lines\": [{\"quantity\": 3, \"variantId\": variant_id}],\n            \"email\": test_email,\n            \"shippingAddress\": shipping_address,\n        }\n    }\n    assert not Checkout.objects.exists()\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_CREATE, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutCreate\"]\n    assert data[\"errors\"][0][\"message\"] == (\n        \"Could not add item Test product (SKU_A). Only 2 remaining in stock.\"\n    )\n    assert data[\"errors\"][0][\"field\"] == \"quantity\"\n\n\n@pytest.fixture\ndef expected_dummy_gateway():\n    return {\n        \"name\": \"Dummy\",\n        \"config\": [{\"field\": \"store_customer_card\", \"value\": \"false\"}],\n    }\n\n\ndef test_checkout_available_payment_gateways(\n    api_client, checkout_with_item, expected_dummy_gateway\n):\n    query = \"\"\"\n    query getCheckout($token: UUID!) {\n        checkout(token: $token) {\n           availablePaymentGateways {\n               name\n               config {\n                   field\n                   value\n               }\n           }\n        }\n    }\n    \"\"\"\n    variables = {\"token\": str(checkout_with_item.token)}\n    response = api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkout\"]\n    assert data[\"availablePaymentGateways\"] == [expected_dummy_gateway]\n\n\ndef test_checkout_available_shipping_methods(\n    api_client, checkout_with_item, address, shipping_zone\n):\n    checkout_with_item.shipping_address = address\n    checkout_with_item.save()\n\n    query = \"\"\"\n    query getCheckout($token: UUID!) {\n        checkout(token: $token) {\n            availableShippingMethods {\n                name\n            }\n        }\n    }\n    \"\"\"\n    variables = {\"token\": checkout_with_item.token}\n    response = api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkout\"]\n\n    shipping_method = shipping_zone.shipping_methods.first()\n    assert data[\"availableShippingMethods\"] == [{\"name\": shipping_method.name}]\n\n\n@pytest.mark.parametrize(\n    \"expected_price_type, expected_price, display_gross_prices\",\n    ((\"gross\", 13, True), (\"net\", 10, False)),\n)\ndef test_checkout_available_shipping_methods_with_price_displayed(\n    expected_price_type,\n    expected_price,\n    display_gross_prices,\n    monkeypatch,\n    api_client,\n    checkout_with_item,\n    address,\n    shipping_zone,\n    site_settings,\n):\n    shipping_method = shipping_zone.shipping_methods.first()\n    taxed_price = TaxedMoney(net=Money(10, \"USD\"), gross=Money(13, \"USD\"))\n    apply_taxes_to_shipping_mock = mock.Mock(return_value=taxed_price)\n    monkeypatch.setattr(\n        ExtensionsManager, \"apply_taxes_to_shipping\", apply_taxes_to_shipping_mock\n    )\n    site_settings.display_gross_prices = display_gross_prices\n    site_settings.save()\n    checkout_with_item.shipping_address = address\n    checkout_with_item.save()\n\n    query = \"\"\"\n    query getCheckout($token: UUID!) {\n        checkout(token: $token) {\n            availableShippingMethods {\n                name\n                price {\n                    amount\n                }\n            }\n        }\n    }\n    \"\"\"\n    variables = {\"token\": checkout_with_item.token}\n    response = api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkout\"]\n\n    apply_taxes_to_shipping_mock.assert_called_once_with(\n        shipping_method.price, mock.ANY\n    )\n    assert data[\"availableShippingMethods\"] == [\n        {\"name\": \"DHL\", \"price\": {\"amount\": expected_price}}\n    ]\n\n\ndef test_checkout_no_available_shipping_methods_without_address(\n    api_client, checkout_with_item\n):\n    query = \"\"\"\n    query getCheckout($token: UUID!) {\n        checkout(token: $token) {\n            availableShippingMethods {\n                name\n            }\n        }\n    }\n    \"\"\"\n    variables = {\"token\": checkout_with_item.token}\n    response = api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkout\"]\n\n    assert data[\"availableShippingMethods\"] == []\n\n\ndef test_checkout_no_available_shipping_methods_without_lines(api_client, checkout):\n    query = \"\"\"\n    query getCheckout($token: UUID!) {\n        checkout(token: $token) {\n            availableShippingMethods {\n                name\n            }\n        }\n    }\n    \"\"\"\n    variables = {\"token\": checkout.token}\n    response = api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkout\"]\n\n    assert data[\"availableShippingMethods\"] == []\n\n\nMUTATION_CHECKOUT_LINES_ADD = \"\"\"\n    mutation checkoutLinesAdd(\n            $checkoutId: ID!, $lines: [CheckoutLineInput!]!) {\n        checkoutLinesAdd(checkoutId: $checkoutId, lines: $lines) {\n            checkout {\n                token\n                lines {\n                    quantity\n                    variant {\n                        id\n                    }\n                }\n            }\n            errors {\n                field\n                message\n            }\n        }\n    }\"\"\"\n\n\n@mock.patch(\n    \"saleor.graphql.checkout.mutations.update_checkout_shipping_method_if_invalid\",\n    wraps=update_checkout_shipping_method_if_invalid,\n)\ndef test_checkout_lines_add(\n    mocked_update_shipping_method, user_api_client, checkout_with_item, stock\n):\n    variant = stock.product_variant\n    checkout = checkout_with_item\n    line = checkout.lines.first()\n    assert line.quantity == 3\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.pk)\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    variables = {\n        \"checkoutId\": checkout_id,\n        \"lines\": [{\"variantId\": variant_id, \"quantity\": 1}],\n    }\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_ADD, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutLinesAdd\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    line = checkout.lines.latest(\"pk\")\n    assert line.variant == variant\n    assert line.quantity == 1\n\n    mocked_update_shipping_method.assert_called_once_with(checkout, mock.ANY)\n\n\ndef test_checkout_lines_add_too_many(user_api_client, checkout_with_item, stock):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.pk)\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout_with_item.pk)\n\n    variables = {\n        \"checkoutId\": checkout_id,\n        \"lines\": [{\"variantId\": variant_id, \"quantity\": 51}],\n    }\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_ADD, variables)\n    content = get_graphql_content(response)[\"data\"][\"checkoutLinesAdd\"]\n\n    assert content[\"errors\"]\n    assert content[\"errors\"] == [\n        {\"field\": \"quantity\", \"message\": \"Cannot add more than 50 times this item.\"}\n    ]\n\n\ndef test_checkout_lines_add_empty_checkout(user_api_client, checkout, stock):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.pk)\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    variables = {\n        \"checkoutId\": checkout_id,\n        \"lines\": [{\"variantId\": variant_id, \"quantity\": 1}],\n    }\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_ADD, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutLinesAdd\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    line = checkout.lines.first()\n    assert line.variant == variant\n    assert line.quantity == 1\n\n\ndef test_checkout_lines_add_check_lines_quantity(user_api_client, checkout, stock):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.pk)\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    variables = {\n        \"checkoutId\": checkout_id,\n        \"lines\": [{\"variantId\": variant_id, \"quantity\": 3}],\n    }\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_ADD, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutLinesAdd\"]\n    assert data[\"errors\"][0][\"message\"] == (\n        \"Could not add item Test product (SKU_A). Only 2 remaining in stock.\"\n    )\n    assert data[\"errors\"][0][\"field\"] == \"quantity\"\n\n\ndef test_checkout_lines_invalid_variant_id(user_api_client, checkout, stock):\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.pk)\n    invalid_variant_id = \"InvalidId\"\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    variables = {\n        \"checkoutId\": checkout_id,\n        \"lines\": [\n            {\"variantId\": variant_id, \"quantity\": 1},\n            {\"variantId\": invalid_variant_id, \"quantity\": 3},\n        ],\n    }\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_ADD, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutLinesAdd\"]\n    error_msg = \"Could not resolve to a node with the global id list of '%s'.\"\n    assert data[\"errors\"][0][\"message\"] == error_msg % [invalid_variant_id]\n    assert data[\"errors\"][0][\"field\"] == \"variantId\"\n\n\nMUTATION_CHECKOUT_LINES_UPDATE = \"\"\"\n    mutation checkoutLinesUpdate(\n            $checkoutId: ID!, $lines: [CheckoutLineInput!]!) {\n        checkoutLinesUpdate(checkoutId: $checkoutId, lines: $lines) {\n            checkout {\n                token\n                lines {\n                    quantity\n                    variant {\n                        id\n                    }\n                }\n            }\n            errors {\n                field\n                message\n            }\n        }\n    }\n    \"\"\"\n\n\n@mock.patch(\n    \"saleor.graphql.checkout.mutations.update_checkout_shipping_method_if_invalid\",\n    wraps=update_checkout_shipping_method_if_invalid,\n)\ndef test_checkout_lines_update(\n    mocked_update_shipping_method, user_api_client, checkout_with_item\n):\n    checkout = checkout_with_item\n    assert checkout.lines.count() == 1\n    line = checkout.lines.first()\n    variant = line.variant\n    assert line.quantity == 3\n\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.pk)\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    variables = {\n        \"checkoutId\": checkout_id,\n        \"lines\": [{\"variantId\": variant_id, \"quantity\": 1}],\n    }\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_UPDATE, variables)\n    content = get_graphql_content(response)\n\n    data = content[\"data\"][\"checkoutLinesUpdate\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    assert checkout.lines.count() == 1\n    line = checkout.lines.first()\n    assert line.variant == variant\n    assert line.quantity == 1\n\n    mocked_update_shipping_method.assert_called_once_with(checkout, mock.ANY)\n\n\ndef test_checkout_lines_update_invalid_checkout_id(user_api_client):\n    variables = {\"checkoutId\": \"test\", \"lines\": []}\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_UPDATE, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutLinesUpdate\"]\n    assert data[\"errors\"][0][\"field\"] == \"checkoutId\"\n\n\ndef test_checkout_lines_update_check_lines_quantity(\n    user_api_client, checkout_with_item\n):\n    checkout = checkout_with_item\n    line = checkout.lines.first()\n    variant = line.variant\n\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.pk)\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    variables = {\n        \"checkoutId\": checkout_id,\n        \"lines\": [{\"variantId\": variant_id, \"quantity\": 10}],\n    }\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_UPDATE, variables)\n    content = get_graphql_content(response)\n\n    data = content[\"data\"][\"checkoutLinesUpdate\"]\n    assert data[\"errors\"][0][\"message\"] == (\n        \"Could not add item Test product (123). Only 9 remaining in stock.\"\n    )\n    assert data[\"errors\"][0][\"field\"] == \"quantity\"\n\n\ndef test_checkout_lines_update_with_chosen_shipping(\n    user_api_client, checkout, stock, address, shipping_method\n):\n    checkout.shipping_address = address\n    checkout.shipping_method = shipping_method\n    checkout.save()\n\n    variant = stock.product_variant\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.pk)\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    variables = {\n        \"checkoutId\": checkout_id,\n        \"lines\": [{\"variantId\": variant_id, \"quantity\": 1}],\n    }\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_UPDATE, variables)\n    content = get_graphql_content(response)\n\n    data = content[\"data\"][\"checkoutLinesUpdate\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    assert checkout.quantity == 1\n\n\nMUTATION_CHECKOUT_LINES_DELETE = \"\"\"\n    mutation checkoutLineDelete($checkoutId: ID!, $lineId: ID!) {\n        checkoutLineDelete(checkoutId: $checkoutId, lineId: $lineId) {\n            checkout {\n                token\n                lines {\n                    quantity\n                    variant {\n                        id\n                    }\n                }\n            }\n            errors {\n                field\n                message\n            }\n        }\n    }\n\"\"\"\n\n\n@mock.patch(\n    \"saleor.graphql.checkout.mutations.update_checkout_shipping_method_if_invalid\",\n    wraps=update_checkout_shipping_method_if_invalid,\n)\ndef test_checkout_line_delete(\n    mocked_update_shipping_method, user_api_client, checkout_with_item\n):\n    checkout = checkout_with_item\n    assert checkout.lines.count() == 1\n    line = checkout.lines.first()\n    assert line.quantity == 3\n\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n    line_id = graphene.Node.to_global_id(\"CheckoutLine\", line.pk)\n\n    variables = {\"checkoutId\": checkout_id, \"lineId\": line_id}\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_DELETE, variables)\n    content = get_graphql_content(response)\n\n    data = content[\"data\"][\"checkoutLineDelete\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    assert checkout.lines.count() == 0\n    mocked_update_shipping_method.assert_called_once_with(checkout, mock.ANY)\n\n\n@mock.patch(\n    \"saleor.graphql.checkout.mutations.update_checkout_shipping_method_if_invalid\",\n    wraps=update_checkout_shipping_method_if_invalid,\n)\ndef test_checkout_line_delete_by_zero_quantity(\n    mocked_update_shipping_method, user_api_client, checkout_with_item\n):\n    checkout = checkout_with_item\n    assert checkout.lines.count() == 1\n    line = checkout.lines.first()\n    variant = line.variant\n    assert line.quantity == 3\n\n    variant_id = graphene.Node.to_global_id(\"ProductVariant\", variant.pk)\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    variables = {\n        \"checkoutId\": checkout_id,\n        \"lines\": [{\"variantId\": variant_id, \"quantity\": 0}],\n    }\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_LINES_UPDATE, variables)\n    content = get_graphql_content(response)\n\n    data = content[\"data\"][\"checkoutLinesUpdate\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    assert checkout.lines.count() == 0\n    mocked_update_shipping_method.assert_called_once_with(checkout, mock.ANY)\n\n\ndef test_checkout_customer_attach(\n    api_client, user_api_client, checkout_with_item, customer_user\n):\n    checkout = checkout_with_item\n    assert checkout.user is None\n\n    query = \"\"\"\n        mutation checkoutCustomerAttach($checkoutId: ID!, $customerId: ID!) {\n            checkoutCustomerAttach(\n                    checkoutId: $checkoutId, customerId: $customerId) {\n                checkout {\n                    token\n                }\n                errors {\n                    field\n                    message\n                }\n            }\n        }\n    \"\"\"\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n    customer_id = graphene.Node.to_global_id(\"User\", customer_user.pk)\n    variables = {\"checkoutId\": checkout_id, \"customerId\": customer_id}\n\n    # Mutation should fail for unauthenticated customers\n    response = api_client.post_graphql(query, variables)\n    assert_no_permission(response)\n\n    # Mutation should succeed for authenticated customer\n    response = user_api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutCustomerAttach\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    assert checkout.user == customer_user\n\n    # Mutation with ID of a different user should fail as well\n    other_customer = User.objects.create_user(\"othercustomer@example.com\", \"password\")\n    variables[\"customerId\"] = graphene.Node.to_global_id(\"User\", other_customer.pk)\n    response = user_api_client.post_graphql(query, variables)\n    assert_no_permission(response)\n\n\nMUTATION_CHECKOUT_CUSTOMER_DETACH = \"\"\"\n    mutation checkoutCustomerDetach($checkoutId: ID!) {\n        checkoutCustomerDetach(checkoutId: $checkoutId) {\n            checkout {\n                token\n            }\n            errors {\n                field\n                message\n            }\n        }\n    }\n    \"\"\"\n\n\ndef test_checkout_customer_detach(user_api_client, checkout_with_item, customer_user):\n    checkout = checkout_with_item\n    checkout.user = customer_user\n    checkout.save(update_fields=[\"user\"])\n\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n    variables = {\"checkoutId\": checkout_id}\n\n    # Mutation should succeed if the user owns this checkout.\n    response = user_api_client.post_graphql(\n        MUTATION_CHECKOUT_CUSTOMER_DETACH, variables\n    )\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutCustomerDetach\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    assert checkout.user is None\n\n    # Mutation should fail when user calling it doesn't own the checkout.\n    other_user = User.objects.create_user(\"othercustomer@example.com\", \"password\")\n    checkout.user = other_user\n    checkout.save()\n    response = user_api_client.post_graphql(\n        MUTATION_CHECKOUT_CUSTOMER_DETACH, variables\n    )\n    assert_no_permission(response)\n\n\nMUTATION_CHECKOUT_SHIPPING_ADDRESS_UPDATE = \"\"\"\n    mutation checkoutShippingAddressUpdate(\n            $checkoutId: ID!, $shippingAddress: AddressInput!) {\n        checkoutShippingAddressUpdate(\n                checkoutId: $checkoutId, shippingAddress: $shippingAddress) {\n            checkout {\n                token,\n                id\n            },\n            errors {\n                field,\n                message,\n            }\n            checkoutErrors {\n                field\n                message\n                code\n            }\n        }\n    }\"\"\"\n\n\n@mock.patch(\n    \"saleor.graphql.checkout.mutations.update_checkout_shipping_method_if_invalid\",\n    wraps=update_checkout_shipping_method_if_invalid,\n)\ndef test_checkout_shipping_address_update(\n    mocked_update_shipping_method,\n    user_api_client,\n    checkout_with_item,\n    graphql_address_data,\n):\n    checkout = checkout_with_item\n    assert checkout.shipping_address is None\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    shipping_address = graphql_address_data\n    variables = {\"checkoutId\": checkout_id, \"shippingAddress\": shipping_address}\n\n    response = user_api_client.post_graphql(\n        MUTATION_CHECKOUT_SHIPPING_ADDRESS_UPDATE, variables\n    )\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutShippingAddressUpdate\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    assert checkout.shipping_address is not None\n    assert checkout.shipping_address.first_name == shipping_address[\"firstName\"]\n    assert checkout.shipping_address.last_name == shipping_address[\"lastName\"]\n    assert (\n        checkout.shipping_address.street_address_1 == shipping_address[\"streetAddress1\"]\n    )\n    assert (\n        checkout.shipping_address.street_address_2 == shipping_address[\"streetAddress2\"]\n    )\n    assert checkout.shipping_address.postal_code == shipping_address[\"postalCode\"]\n    assert checkout.shipping_address.country == shipping_address[\"country\"]\n    assert checkout.shipping_address.city == shipping_address[\"city\"].upper()\n    mocked_update_shipping_method.assert_called_once_with(checkout, mock.ANY)\n\n\ndef test_checkout_shipping_address_with_invalid_phone_number_returns_error(\n    user_api_client, checkout_with_item, graphql_address_data\n):\n    checkout = checkout_with_item\n    assert checkout.shipping_address is None\n\n    shipping_address = graphql_address_data\n    shipping_address[\"phone\"] = \"+33600000\"\n\n    response = get_graphql_content(\n        user_api_client.post_graphql(\n            MUTATION_CHECKOUT_SHIPPING_ADDRESS_UPDATE,\n            {\n                \"checkoutId\": graphene.Node.to_global_id(\"Checkout\", checkout.pk),\n                \"shippingAddress\": shipping_address,\n            },\n        )\n    )[\"data\"][\"checkoutShippingAddressUpdate\"]\n    assert response[\"errors\"] == [\n        {\"field\": \"phone\", \"message\": \"'+33600000' is not a valid phone number.\"}\n    ]\n    assert response[\"checkoutErrors\"] == [\n        {\n            \"field\": \"phone\",\n            \"message\": \"'+33600000' is not a valid phone number.\",\n            \"code\": CheckoutErrorCode.INVALID.name,\n        }\n    ]\n\n\n@pytest.mark.parametrize(\n    \"number\", [\"+48321321888\", \"+44 (113) 892-1113\", \"00 44 (0) 20 7839 1377\"]\n)\ndef test_checkout_shipping_address_update_with_phone_country_prefix(\n    number, user_api_client, checkout_with_item, graphql_address_data\n):\n    checkout = checkout_with_item\n    assert checkout.shipping_address is None\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    shipping_address = graphql_address_data\n    shipping_address[\"phone\"] = number\n    variables = {\"checkoutId\": checkout_id, \"shippingAddress\": shipping_address}\n\n    response = user_api_client.post_graphql(\n        MUTATION_CHECKOUT_SHIPPING_ADDRESS_UPDATE, variables\n    )\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutShippingAddressUpdate\"]\n    assert not data[\"errors\"]\n\n\ndef test_checkout_shipping_address_update_without_phone_country_prefix(\n    user_api_client, checkout_with_item, graphql_address_data\n):\n    checkout = checkout_with_item\n    assert checkout.shipping_address is None\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    shipping_address = graphql_address_data\n    shipping_address[\"phone\"] = \"+1-202-555-0132\"\n    variables = {\"checkoutId\": checkout_id, \"shippingAddress\": shipping_address}\n\n    response = user_api_client.post_graphql(\n        MUTATION_CHECKOUT_SHIPPING_ADDRESS_UPDATE, variables\n    )\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutShippingAddressUpdate\"]\n    assert not data[\"errors\"]\n\n\ndef test_checkout_billing_address_update(\n    user_api_client, checkout_with_item, graphql_address_data\n):\n    checkout = checkout_with_item\n    assert checkout.shipping_address is None\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    query = \"\"\"\n    mutation checkoutBillingAddressUpdate(\n            $checkoutId: ID!, $billingAddress: AddressInput!) {\n        checkoutBillingAddressUpdate(\n                checkoutId: $checkoutId, billingAddress: $billingAddress) {\n            checkout {\n                token,\n                id\n            },\n            errors {\n                field,\n                message\n            }\n        }\n    }\n    \"\"\"\n    billing_address = graphql_address_data\n\n    variables = {\"checkoutId\": checkout_id, \"billingAddress\": billing_address}\n\n    response = user_api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutBillingAddressUpdate\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    assert checkout.billing_address is not None\n    assert checkout.billing_address.first_name == billing_address[\"firstName\"]\n    assert checkout.billing_address.last_name == billing_address[\"lastName\"]\n    assert (\n        checkout.billing_address.street_address_1 == billing_address[\"streetAddress1\"]\n    )\n    assert (\n        checkout.billing_address.street_address_2 == billing_address[\"streetAddress2\"]\n    )\n    assert checkout.billing_address.postal_code == billing_address[\"postalCode\"]\n    assert checkout.billing_address.country == billing_address[\"country\"]\n    assert checkout.billing_address.city == billing_address[\"city\"].upper()\n\n\nCHECKOUT_EMAIL_UPDATE_MUTATION = \"\"\"\n    mutation checkoutEmailUpdate($checkoutId: ID!, $email: String!) {\n        checkoutEmailUpdate(checkoutId: $checkoutId, email: $email) {\n            checkout {\n                id,\n                email\n            },\n            errors {\n                field,\n                message\n            }\n            checkoutErrors {\n                field,\n                message\n                code\n            }\n        }\n    }\n\"\"\"\n\n\ndef test_checkout_email_update(user_api_client, checkout_with_item):\n    checkout = checkout_with_item\n    assert not checkout.email\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n\n    email = \"test@example.com\"\n    variables = {\"checkoutId\": checkout_id, \"email\": email}\n\n    response = user_api_client.post_graphql(CHECKOUT_EMAIL_UPDATE_MUTATION, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutEmailUpdate\"]\n    assert not data[\"errors\"]\n    checkout.refresh_from_db()\n    assert checkout.email == email\n\n\ndef test_checkout_email_update_validation(user_api_client, checkout_with_item):\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout_with_item.pk)\n    variables = {\"checkoutId\": checkout_id, \"email\": \"\"}\n\n    response = user_api_client.post_graphql(CHECKOUT_EMAIL_UPDATE_MUTATION, variables)\n    content = get_graphql_content(response)\n\n    errors = content[\"data\"][\"checkoutEmailUpdate\"][\"errors\"]\n    assert errors\n    assert errors[0][\"field\"] == \"email\"\n    assert errors[0][\"message\"] == \"This field cannot be blank.\"\n\n    checkout_errors = content[\"data\"][\"checkoutEmailUpdate\"][\"checkoutErrors\"]\n    assert checkout_errors[0][\"code\"] == CheckoutErrorCode.REQUIRED.name\n\n\nMUTATION_CHECKOUT_COMPLETE = \"\"\"\n    mutation checkoutComplete($checkoutId: ID!, $redirectUrl: String) {\n        checkoutComplete(checkoutId: $checkoutId, redirectUrl: $redirectUrl) {\n            order {\n                id,\n                token\n            },\n            errors {\n                field,\n                message\n            }\n        }\n    }\n    \"\"\"\n\n\n@pytest.mark.integration\ndef test_checkout_complete(\n    user_api_client,\n    checkout_with_gift_card,\n    gift_card,\n    payment_dummy,\n    address,\n    shipping_method,\n):\n\n    assert not gift_card.last_used_on\n\n    checkout = checkout_with_gift_card\n    checkout.shipping_address = address\n    checkout.shipping_method = shipping_method\n    checkout.billing_address = address\n    checkout.store_meta(namespace=\"PUBLIC\", client=\"PLUGIN\", item={\"accepted\": \"true\"})\n    checkout.store_private_meta(\n        namespace=\"PRIVATE\", client=\"PLUGIN\", item={\"accepted\": \"true\"}\n    )\n    checkout.save()\n\n    checkout_line = checkout.lines.first()\n    checkout_line_quantity = checkout_line.quantity\n    checkout_line_variant = checkout_line.variant\n\n    gift_current_balance = checkout.get_total_gift_cards_balance()\n    total = calculations.checkout_total(checkout)\n    payment = payment_dummy\n    payment.is_active = True\n    payment.order = None\n    payment.total = total.gross.amount\n    payment.currency = total.gross.currency\n    payment.checkout = checkout\n    payment.save()\n    assert not payment.transactions.exists()\n\n    orders_count = Order.objects.count()\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n    variables = {\"checkoutId\": checkout_id, \"redirectUrl\": \"https://www.example.com\"}\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_COMPLETE, variables)\n\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutComplete\"]\n    assert not data[\"errors\"]\n\n    order_token = data[\"order\"][\"token\"]\n    assert Order.objects.count() == orders_count + 1\n    order = Order.objects.first()\n    assert order.token == order_token\n    assert order.total.gross == total.gross - gift_current_balance\n    assert order.meta == checkout.meta\n    assert order.private_meta == checkout.private_meta\n\n    order_line = order.lines.first()\n    assert checkout_line_quantity == order_line.quantity\n    assert checkout_line_variant == order_line.variant\n    assert order.shipping_address == address\n    assert order.shipping_method == checkout.shipping_method\n    assert order.payments.exists()\n    order_payment = order.payments.first()\n    assert order_payment == payment\n    assert payment.transactions.count() == 1\n\n    gift_card.refresh_from_db()\n    assert gift_card.current_balance == zero_money()\n    assert gift_card.last_used_on\n\n    assert not Checkout.objects.filter(\n        pk=checkout.pk\n    ).exists(), \"Checkout should have been deleted\"\n\n\nERROR_GATEWAY_RESPONSE = GatewayResponse(\n    is_success=False,\n    action_required=False,\n    kind=TransactionKind.CAPTURE,\n    amount=Decimal(0),\n    currency=\"usd\",\n    transaction_id=\"1234\",\n    error=\"ERROR\",\n)\n\n\ndef _process_payment_transaction_returns_error(*args, **kwards):\n    return ERROR_GATEWAY_RESPONSE\n\n\ndef _process_payment_raise_error(*args, **kwargs):\n    raise Exception(\"Oops! Something went wrong.\")\n\n\n@pytest.fixture(\n    params=[_process_payment_raise_error, _process_payment_transaction_returns_error]\n)\ndef error_side_effect(request):\n    return request.param\n\n\n@pytest.fixture\ndef fake_manager(mocker):\n    return mocker.Mock(spec=PaymentInterface)\n\n\n@pytest.fixture\ndef mock_get_manager(mocker, fake_manager):\n    mgr = mocker.patch(\n        \"saleor.payment.gateway.get_extensions_manager\",\n        autospec=True,\n        return_value=fake_manager,\n    )\n    yield fake_manager\n    mgr.assert_called_once()\n\n\ndef test_checkout_complete_does_not_delete_checkout_after_unsuccessful_payment(\n    mock_get_manager,\n    error_side_effect,\n    user_api_client,\n    checkout_with_voucher,\n    voucher,\n    payment_dummy,\n    address,\n    shipping_method,\n):\n    mock_get_manager.process_payment.side_effect = error_side_effect\n    expected_voucher_usage_count = voucher.used\n    checkout = checkout_with_voucher\n    checkout.shipping_address = address\n    checkout.shipping_method = shipping_method\n    checkout.billing_address = address\n    checkout.save()\n\n    taxed_total = calculations.checkout_total(checkout)\n    payment = payment_dummy\n    payment.is_active = True\n    payment.order = None\n    payment.total = taxed_total.gross.amount\n    payment.currency = taxed_total.gross.currency\n    payment.checkout = checkout\n    payment.save()\n    assert not payment.transactions.exists()\n\n    orders_count = Order.objects.count()\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n    variables = {\"checkoutId\": checkout_id, \"redirectUrl\": \"https://www.example.com\"}\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_COMPLETE, variables)\n    get_graphql_content(response)\n\n    assert Order.objects.count() == orders_count\n\n    payment.refresh_from_db(fields=[\"order\"])\n    transaction = payment.transactions.get()\n    assert transaction.error\n    assert payment.order is None\n\n    # ensure the voucher usage count was not incremented\n    voucher.refresh_from_db(fields=[\"used\"])\n    assert voucher.used == expected_voucher_usage_count\n\n    assert Checkout.objects.filter(\n        pk=checkout.pk\n    ).exists(), \"Checkout should not have been deleted\"\n\n\ndef test_checkout_complete_invalid_checkout_id(user_api_client):\n    checkout_id = \"invalidId\"\n    variables = {\"checkoutId\": checkout_id, \"redirectUrl\": \"https://www.example.com\"}\n    orders_count = Order.objects.count()\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_COMPLETE, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutComplete\"]\n    assert data[\"errors\"][0][\"message\"] == \"Couldn't resolve to a node: invalidId\"\n    assert data[\"errors\"][0][\"field\"] == \"checkoutId\"\n    assert orders_count == Order.objects.count()\n\n\ndef test_checkout_complete_no_payment(\n    user_api_client, checkout_with_item, address, shipping_method\n):\n    checkout = checkout_with_item\n    checkout.shipping_address = address\n    checkout.shipping_method = shipping_method\n    checkout.billing_address = address\n    checkout.save()\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n    variables = {\"checkoutId\": checkout_id, \"redirectUrl\": \"https://www.example.com\"}\n    orders_count = Order.objects.count()\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_COMPLETE, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutComplete\"]\n    assert data[\"errors\"][0][\"message\"] == (\n        \"Provided payment methods can not cover the checkout's total amount\"\n    )\n    assert orders_count == Order.objects.count()\n\n\ndef test_checkout_complete_insufficient_stock(\n    user_api_client, checkout_with_item, address, payment_dummy, shipping_method\n):\n    checkout = checkout_with_item\n    checkout_line = checkout.lines.first()\n    stock = Stock.objects.get(product_variant=checkout_line.variant)\n    quantity_available = stock.quantity_available\n    checkout_line.quantity = quantity_available + 1\n    checkout_line.save()\n    checkout.shipping_address = address\n    checkout.shipping_method = shipping_method\n    checkout.billing_address = address\n    checkout.save()\n    total = calculations.checkout_total(checkout)\n    payment = payment_dummy\n    payment.is_active = True\n    payment.order = None\n    payment.total = total.gross.amount\n    payment.currency = total.gross.currency\n    payment.checkout = checkout\n    payment.save()\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n    variables = {\"checkoutId\": checkout_id, \"redirectUrl\": \"https://www.example.com\"}\n    orders_count = Order.objects.count()\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_COMPLETE, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutComplete\"]\n    assert data[\"errors\"][0][\"message\"] == \"Insufficient product stock: 123\"\n    assert orders_count == Order.objects.count()\n\n\ndef test_checkout_complete_without_redirect_url(\n    user_api_client,\n    checkout_with_gift_card,\n    gift_card,\n    payment_dummy,\n    address,\n    shipping_method,\n):\n\n    assert not gift_card.last_used_on\n\n    checkout = checkout_with_gift_card\n    checkout.shipping_address = address\n    checkout.shipping_method = shipping_method\n    checkout.billing_address = address\n    checkout.save()\n\n    checkout_line = checkout.lines.first()\n    checkout_line_quantity = checkout_line.quantity\n    checkout_line_variant = checkout_line.variant\n\n    gift_current_balance = checkout.get_total_gift_cards_balance()\n    total = calculations.checkout_total(checkout)\n    payment = payment_dummy\n    payment.is_active = True\n    payment.order = None\n    payment.total = total.gross.amount\n    payment.currency = total.gross.currency\n    payment.checkout = checkout\n    payment.save()\n    assert not payment.transactions.exists()\n\n    orders_count = Order.objects.count()\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n    variables = {\"checkoutId\": checkout_id}\n    response = user_api_client.post_graphql(MUTATION_CHECKOUT_COMPLETE, variables)\n\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkoutComplete\"]\n    assert not data[\"errors\"]\n\n    order_token = data[\"order\"][\"token\"]\n    assert Order.objects.count() == orders_count + 1\n    order = Order.objects.first()\n    assert order.token == order_token\n    assert order.total.gross == total.gross - gift_current_balance\n\n    order_line = order.lines.first()\n    assert checkout_line_quantity == order_line.quantity\n    assert checkout_line_variant == order_line.variant\n    assert order.shipping_address == address\n    assert order.shipping_method == checkout.shipping_method\n    assert order.payments.exists()\n    order_payment = order.payments.first()\n    assert order_payment == payment\n    assert payment.transactions.count() == 1\n\n    gift_card.refresh_from_db()\n    assert gift_card.current_balance == zero_money()\n    assert gift_card.last_used_on\n\n    assert not Checkout.objects.filter(\n        pk=checkout.pk\n    ).exists(), \"Checkout should have been deleted\"\n\n\ndef test_fetch_checkout_by_token(user_api_client, checkout_with_item):\n    query = \"\"\"\n    query getCheckout($token: UUID!) {\n        checkout(token: $token) {\n           token,\n           lines {\n                variant {\n                    product {\n                        name\n                    }\n                }\n           }\n        }\n    }\n    \"\"\"\n    variables = {\"token\": str(checkout_with_item.token)}\n    response = user_api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkout\"]\n    assert data[\"token\"] == str(checkout_with_item.token)\n    assert len(data[\"lines\"]) == checkout_with_item.lines.count()\n\n\ndef test_fetch_checkout_invalid_token(user_api_client):\n    query = \"\"\"\n        query getCheckout($token: UUID!) {\n            checkout(token: $token) {\n                token\n            }\n        }\n    \"\"\"\n    variables = {\"token\": str(uuid.uuid4())}\n    response = user_api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkout\"]\n    assert data is None\n\n\ndef test_checkout_prices(user_api_client, checkout_with_item):\n    query = \"\"\"\n    query getCheckout($token: UUID!) {\n        checkout(token: $token) {\n           token,\n           totalPrice {\n                currency\n                gross {\n                    amount\n                }\n            }\n            subtotalPrice {\n                currency\n                gross {\n                    amount\n                }\n            }\n           lines {\n                totalPrice {\n                    currency\n                    gross {\n                        amount\n                    }\n                }\n           }\n        }\n    }\n    \"\"\"\n    variables = {\"token\": str(checkout_with_item.token)}\n    response = user_api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    data = content[\"data\"][\"checkout\"]\n    assert data[\"token\"] == str(checkout_with_item.token)\n    assert len(data[\"lines\"]) == checkout_with_item.lines.count()\n    total = calculations.checkout_total(checkout_with_item)\n    assert data[\"totalPrice\"][\"gross\"][\"amount\"] == (total.gross.amount)\n    subtotal = calculations.checkout_subtotal(checkout_with_item)\n    assert data[\"subtotalPrice\"][\"gross\"][\"amount\"] == (subtotal.gross.amount)\n\n\nMUTATION_UPDATE_SHIPPING_METHOD = \"\"\"\n    mutation checkoutShippingMethodUpdate(\n            $checkoutId:ID!, $shippingMethodId:ID!){\n        checkoutShippingMethodUpdate(\n            checkoutId:$checkoutId, shippingMethodId:$shippingMethodId) {\n            errors {\n                field\n                message\n            }\n            checkout {\n                id\n            }\n        }\n    }\n\"\"\"\n\n\n@pytest.mark.parametrize(\"is_valid_shipping_method\", (True, False))\n@patch(\"saleor.graphql.checkout.mutations.clean_shipping_method\")\ndef test_checkout_shipping_method_update(\n    mock_clean_shipping,\n    staff_api_client,\n    shipping_method,\n    checkout_with_item,\n    is_valid_shipping_method,\n):\n    checkout = checkout_with_item\n    query = MUTATION_UPDATE_SHIPPING_METHOD\n    mock_clean_shipping.return_value = is_valid_shipping_method\n\n    checkout_id = graphene.Node.to_global_id(\"Checkout\", checkout.pk)\n    method_id = graphene.Node.to_global_id(\"ShippingMethod\", shipping_method.id)\n\n    response = staff_api_client.post_graphql(\n        query, {\"checkoutId\": checkout_id, \"shippingMethodId\": method_id}\n    )\n    data = get_graphql_content(response)[\"data\"][\"checkoutShippingMethodUpdate\"]\n\n    checkout.refresh_from_db()\n\n    mock_clean_shipping.assert_called_once_with(\n        checkout=checkout, method=shipping_method, discounts=ANY\n    )\n\n    if is_valid_shipping_method:\n        assert not data[\"errors\"]\n        assert data[\"checkout\"][\"id\"] == checkout_id\n        assert checkout.shipping_method == shipping_method\n    else:\n        assert data[\"errors\"] == [\n            {\n                \"field\": \"shippingMethod\",\n                \"message\": \"This shipping method is not applicable.\",\n            }\n        ]\n        assert checkout.shipping_method is None\n\n\ndef test_query_checkout_line(checkout_with_item, user_api_client):\n    query = \"\"\"\n    query checkoutLine($id: ID) {\n        checkoutLine(id: $id) {\n            id\n        }\n    }\n    \"\"\"\n    checkout = checkout_with_item\n    line = checkout.lines.first()\n    line_id = graphene.Node.to_global_id(\"CheckoutLine\", line.pk)\n    variables = {\"id\": line_id}\n    response = user_api_client.post_graphql(query, variables)\n    content = get_graphql_content(response)\n    received_id = content[\"data\"][\"checkoutLine\"][\"id\"]\n    assert received_id == line_id\n\n\ndef test_query_checkouts(\n    checkout_with_item, staff_api_client, permission_manage_orders\n):\n    query = \"\"\"\n    {\n        checkouts(first: 20) {\n            edges {\n                node {\n                    token\n                }\n            }\n        }\n    }\n    \"\"\"\n    checkout = checkout_with_item\n    response = staff_api_client.post_graphql(\n        query, {}, permissions=[permission_manage_orders]\n    )\n    content = get_graphql_content(response)\n    received_checkout = content[\"data\"][\"checkouts\"][\"edges\"][0][\"node\"]\n    assert str(checkout.token) == received_checkout[\"token\"]\n\n\ndef test_query_checkout_lines(\n    checkout_with_item, staff_api_client, permission_manage_orders\n):\n    query = \"\"\"\n    {\n        checkoutLines(first: 20) {\n            edges {\n                node {\n                    id\n                }\n            }\n        }\n    }\n    \"\"\"\n    checkout = checkout_with_item\n    response = staff_api_client.post_graphql(\n        query, permissions=[permission_manage_orders]\n    )\n    content = get_graphql_content(response)\n    lines = content[\"data\"][\"checkoutLines\"][\"edges\"]\n    checkout_lines_ids = [line[\"node\"][\"id\"] for line in lines]\n    expected_lines_ids = [\n        graphene.Node.to_global_id(\"CheckoutLine\", item.pk) for item in checkout\n    ]\n    assert expected_lines_ids == checkout_lines_ids\n\n\ndef test_clean_checkout(checkout_with_item, payment_dummy, address, shipping_method):\n    checkout = checkout_with_item\n    checkout.shipping_address = address\n    checkout.shipping_method = shipping_method\n    checkout.billing_address = address\n    checkout.save()\n    total = calculations.checkout_total(checkout)\n    payment = payment_dummy\n    payment.is_active = True\n    payment.order = None\n    payment.total = total.gross.amount\n    payment.currency = total.gross.currency\n    payment.checkout = checkout\n    payment.save()\n    # Shouldn't raise any errors\n    clean_checkout(checkout, None)\n\n\ndef test_clean_checkout_no_shipping_method(checkout_with_item, address):\n    checkout = checkout_with_item\n    checkout.shipping_address = address\n    checkout.save()\n\n    with pytest.raises(ValidationError) as e:\n        clean_checkout(checkout, None)\n\n    msg = \"Shipping method is not set\"\n    assert e.value.error_list[0].message == msg\n\n\ndef test_clean_checkout_no_shipping_address(checkout_with_item, shipping_method):\n    checkout = checkout_with_item\n    checkout.shipping_method = shipping_method\n    checkout.save()\n\n    with pytest.raises(ValidationError) as e:\n        clean_checkout(checkout, None)\n    msg = \"Shipping address is not set\"\n    assert e.value.error_list[0].message == msg\n\n\ndef test_clean_checkout_invalid_shipping_method(\n    checkout_with_item, address, shipping_zone_without_countries\n):\n    checkout = checkout_with_item\n    checkout.shipping_address = address\n    shipping_method = shipping_zone_without_countries.shipping_methods.first()\n    checkout.shipping_method = shipping_method\n    checkout.save()\n\n    with pytest.raises(ValidationError) as e:\n        clean_checkout(checkout, None)\n\n    msg = \"Shipping method is not valid for your shipping address\"\n    assert e.value.error_list[0].message == msg\n\n\ndef test_clean_checkout_no_billing_address(\n    checkout_with_item, address, shipping_method\n):\n    checkout = checkout_with_item\n    checkout.shipping_address = address\n    checkout.shipping_method = shipping_method\n    checkout.save()\n\n    with pytest.raises(ValidationError) as e:\n        clean_checkout(checkout, None)\n    msg = \"Billing address is not set\"\n    assert e.value.error_list[0].message == msg\n\n\ndef test_clean_checkout_no_payment(checkout_with_item, shipping_method, address):\n    checkout = checkout_with_item\n    checkout.shipping_address = address\n    checkout.shipping_method = shipping_method\n    checkout.billing_address = address\n    checkout.save()\n\n    with pytest.raises(ValidationError) as e:\n        clean_checkout(checkout, None)\n\n    msg = \"Provided payment methods can not cover the checkout's total amount\"\n    assert e.value.error_list[0].message == msg\n\n\ndef test_is_fully_paid(checkout_with_item, payment_dummy):\n    checkout = checkout_with_item\n    total = calculations.checkout_total(checkout)\n    payment = payment_dummy\n    payment.is_active = True\n    payment.order = None\n    payment.total = total.gross.amount\n    payment.currency = total.gross.currency\n    payment.checkout = checkout\n    payment.save()\n    is_paid = is_fully_paid(checkout, None)\n    assert is_paid\n\n\ndef test_is_fully_paid_many_payments(checkout_with_item, payment_dummy):\n    checkout = checkout_with_item\n    total = calculations.checkout_total(checkout)\n    payment = payment_dummy\n    payment.is_active = True\n    payment.order = None\n    payment.total = total.gross.amount - 1\n    payment.currency = total.gross.currency\n    payment.checkout = checkout\n    payment.save()\n    payment2 = payment_dummy\n    payment2.pk = None\n    payment2.is_active = True\n    payment2.order = None\n    payment2.total = 1\n    payment2.currency = total.gross.currency\n    payment2.checkout = checkout\n    payment2.save()\n    is_paid = is_fully_paid(checkout, None)\n    assert is_paid\n\n\ndef test_is_fully_paid_partially_paid(checkout_with_item, payment_dummy):\n    checkout = checkout_with_item\n    total = calculations.checkout_total(checkout)\n    payment = payment_dummy\n    payment.is_active = True\n    payment.order = None\n    payment.total = total.gross.amount - 1\n    payment.currency = total.gross.currency\n    payment.checkout = checkout\n    payment.save()\n    is_paid = is_fully_paid(checkout, None)\n    assert not is_paid\n\n\ndef test_is_fully_paid_no_payment(checkout_with_item):\n    checkout = checkout_with_item\n    is_paid = is_fully_paid(checkout, None)\n    assert not is_paid\n"], "filenames": ["CHANGELOG.md", "saleor/graphql/checkout/mutations.py", "saleor/graphql/schema.graphql", "tests/api/test_checkout.py"], "buggy_code_start_loc": [56, 7, 2291, 10], "buggy_code_end_loc": [56, 442, 2292, 915], "fixing_code_start_loc": [57, 8, 2291, 11], "fixing_code_end_loc": [58, 470, 2292, 939], "type": "CWE-306", "message": "An issue was discovered in Mirumee Saleor 2.x before 2.9.1. Incorrect access control in the checkoutCustomerAttach mutations allows attackers to attach their checkouts to any user ID and consequently leak user data (e.g., name, address, and previous orders of any other customer).", "other": {"cve": {"id": "CVE-2020-7964", "sourceIdentifier": "cve@mitre.org", "published": "2020-01-24T20:15:11.050", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Mirumee Saleor 2.x before 2.9.1. Incorrect access control in the checkoutCustomerAttach mutations allows attackers to attach their checkouts to any user ID and consequently leak user data (e.g., name, address, and previous orders of any other customer)."}, {"lang": "es", "value": "Se detect\u00f3 un problema en Mirumee Saleor versiones 2.x anteriores a 2.9.1. Un control de acceso incorrecto en las mutaciones de la funci\u00f3n checkoutCustomerAttach, permiten a atacantes adjuntar sus pagos a cualquier ID de usuario y, en consecuencia, filtrar datos del usuario (por ejemplo, nombre, direcci\u00f3n y pedidos anteriores de cualquier otro cliente)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-306"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mirumee:saleor:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.9.1", "matchCriteriaId": "53F3DA54-64C9-4FBA-B2BF-429748FA0AE8"}]}]}], "references": [{"url": "https://github.com/mirumee/saleor/commit/233b8890c60fa6d90daf99e4d90fea85867732c3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/mirumee/saleor/releases/tag/2.9.1", "source": "cve@mitre.org", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/mirumee/saleor/commit/233b8890c60fa6d90daf99e4d90fea85867732c3"}}