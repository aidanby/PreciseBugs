{"buggy_code": ["/*****************************************************************************\n * Linux PPP over L2TP (PPPoX/PPPoL2TP) Sockets\n *\n * PPPoX    --- Generic PPP encapsulation socket family\n * PPPoL2TP --- PPP over L2TP (RFC 2661)\n *\n * Version:\t2.0.0\n *\n * Authors:\tJames Chapman (jchapman@katalix.com)\n *\n * Based on original work by Martijn van Oosterhout <kleptog@svana.org>\n *\n * License:\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n */\n\n/* This driver handles only L2TP data frames; control frames are handled by a\n * userspace application.\n *\n * To send data in an L2TP session, userspace opens a PPPoL2TP socket and\n * attaches it to a bound UDP socket with local tunnel_id / session_id and\n * peer tunnel_id / session_id set. Data can then be sent or received using\n * regular socket sendmsg() / recvmsg() calls. Kernel parameters of the socket\n * can be read or modified using ioctl() or [gs]etsockopt() calls.\n *\n * When a PPPoL2TP socket is connected with local and peer session_id values\n * zero, the socket is treated as a special tunnel management socket.\n *\n * Here's example userspace code to create a socket for sending/receiving data\n * over an L2TP session:-\n *\n *\tstruct sockaddr_pppol2tp sax;\n *\tint fd;\n *\tint session_fd;\n *\n *\tfd = socket(AF_PPPOX, SOCK_DGRAM, PX_PROTO_OL2TP);\n *\n *\tsax.sa_family = AF_PPPOX;\n *\tsax.sa_protocol = PX_PROTO_OL2TP;\n *\tsax.pppol2tp.fd = tunnel_fd;\t// bound UDP socket\n *\tsax.pppol2tp.addr.sin_addr.s_addr = addr->sin_addr.s_addr;\n *\tsax.pppol2tp.addr.sin_port = addr->sin_port;\n *\tsax.pppol2tp.addr.sin_family = AF_INET;\n *\tsax.pppol2tp.s_tunnel  = tunnel_id;\n *\tsax.pppol2tp.s_session = session_id;\n *\tsax.pppol2tp.d_tunnel  = peer_tunnel_id;\n *\tsax.pppol2tp.d_session = peer_session_id;\n *\n *\tsession_fd = connect(fd, (struct sockaddr *)&sax, sizeof(sax));\n *\n * A pppd plugin that allows PPP traffic to be carried over L2TP using\n * this driver is available from the OpenL2TP project at\n * http://openl2tp.sourceforge.net.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jiffies.h>\n\n#include <linux/netdevice.h>\n#include <linux/net.h>\n#include <linux/inetdevice.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/ip.h>\n#include <linux/udp.h>\n#include <linux/if_pppox.h>\n#include <linux/if_pppol2tp.h>\n#include <net/sock.h>\n#include <linux/ppp_channel.h>\n#include <linux/ppp_defs.h>\n#include <linux/ppp-ioctl.h>\n#include <linux/file.h>\n#include <linux/hash.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/l2tp.h>\n#include <linux/nsproxy.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/dst.h>\n#include <net/ip.h>\n#include <net/udp.h>\n#include <net/xfrm.h>\n#include <net/inet_common.h>\n\n#include <asm/byteorder.h>\n#include <linux/atomic.h>\n\n#include \"l2tp_core.h\"\n\n#define PPPOL2TP_DRV_VERSION\t\"V2.0\"\n\n/* Space for UDP, L2TP and PPP headers */\n#define PPPOL2TP_HEADER_OVERHEAD\t40\n\n/* Number of bytes to build transmit L2TP headers.\n * Unfortunately the size is different depending on whether sequence numbers\n * are enabled.\n */\n#define PPPOL2TP_L2TP_HDR_SIZE_SEQ\t\t10\n#define PPPOL2TP_L2TP_HDR_SIZE_NOSEQ\t\t6\n\n/* Private data of each session. This data lives at the end of struct\n * l2tp_session, referenced via session->priv[].\n */\nstruct pppol2tp_session {\n\tint\t\t\towner;\t\t/* pid that opened the socket */\n\n\tstruct sock\t\t*sock;\t\t/* Pointer to the session\n\t\t\t\t\t\t * PPPoX socket */\n\tstruct sock\t\t*tunnel_sock;\t/* Pointer to the tunnel UDP\n\t\t\t\t\t\t * socket */\n\tint\t\t\tflags;\t\t/* accessed by PPPIOCGFLAGS.\n\t\t\t\t\t\t * Unused. */\n};\n\nstatic int pppol2tp_xmit(struct ppp_channel *chan, struct sk_buff *skb);\n\nstatic const struct ppp_channel_ops pppol2tp_chan_ops = {\n\t.start_xmit =  pppol2tp_xmit,\n};\n\nstatic const struct proto_ops pppol2tp_ops;\n\n/* Helpers to obtain tunnel/session contexts from sockets.\n */\nstatic inline struct l2tp_session *pppol2tp_sock_to_session(struct sock *sk)\n{\n\tstruct l2tp_session *session;\n\n\tif (sk == NULL)\n\t\treturn NULL;\n\n\tsock_hold(sk);\n\tsession = (struct l2tp_session *)(sk->sk_user_data);\n\tif (session == NULL) {\n\t\tsock_put(sk);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(session->magic != L2TP_SESSION_MAGIC);\n\nout:\n\treturn session;\n}\n\n/*****************************************************************************\n * Receive data handling\n *****************************************************************************/\n\nstatic int pppol2tp_recv_payload_hook(struct sk_buff *skb)\n{\n\t/* Skip PPP header, if present.\t In testing, Microsoft L2TP clients\n\t * don't send the PPP header (PPP header compression enabled), but\n\t * other clients can include the header. So we cope with both cases\n\t * here. The PPP header is always FF03 when using L2TP.\n\t *\n\t * Note that skb->data[] isn't dereferenced from a u16 ptr here since\n\t * the field may be unaligned.\n\t */\n\tif (!pskb_may_pull(skb, 2))\n\t\treturn 1;\n\n\tif ((skb->data[0] == 0xff) && (skb->data[1] == 0x03))\n\t\tskb_pull(skb, 2);\n\n\treturn 0;\n}\n\n/* Receive message. This is the recvmsg for the PPPoL2TP socket.\n */\nstatic int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len,\n\t\t\t    int flags)\n{\n\tint err;\n\tstruct sk_buff *skb;\n\tstruct sock *sk = sock->sk;\n\n\terr = -EIO;\n\tif (sk->sk_state & PPPOX_BOUND)\n\t\tgoto end;\n\n\terr = 0;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto end;\n\n\tif (len > skb->len)\n\t\tlen = skb->len;\n\telse if (len < skb->len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);\n\tif (likely(err == 0))\n\t\terr = len;\n\n\tkfree_skb(skb);\nend:\n\treturn err;\n}\n\nstatic void pppol2tp_recv(struct l2tp_session *session, struct sk_buff *skb, int data_len)\n{\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\tstruct sock *sk = NULL;\n\n\t/* If the socket is bound, send it in to PPP's input queue. Otherwise\n\t * queue it on the session socket.\n\t */\n\tsk = ps->sock;\n\tif (sk == NULL)\n\t\tgoto no_sock;\n\n\tif (sk->sk_state & PPPOX_BOUND) {\n\t\tstruct pppox_sock *po;\n\t\tl2tp_dbg(session, PPPOL2TP_MSG_DATA,\n\t\t\t \"%s: recv %d byte data frame, passing to ppp\\n\",\n\t\t\t session->name, data_len);\n\n\t\t/* We need to forget all info related to the L2TP packet\n\t\t * gathered in the skb as we are going to reuse the same\n\t\t * skb for the inner packet.\n\t\t * Namely we need to:\n\t\t * - reset xfrm (IPSec) information as it applies to\n\t\t *   the outer L2TP packet and not to the inner one\n\t\t * - release the dst to force a route lookup on the inner\n\t\t *   IP packet since skb->dst currently points to the dst\n\t\t *   of the UDP tunnel\n\t\t * - reset netfilter information as it doesn't apply\n\t\t *   to the inner packet either\n\t\t */\n\t\tsecpath_reset(skb);\n\t\tskb_dst_drop(skb);\n\t\tnf_reset(skb);\n\n\t\tpo = pppox_sk(sk);\n\t\tppp_input(&po->chan, skb);\n\t} else {\n\t\tl2tp_dbg(session, PPPOL2TP_MSG_DATA,\n\t\t\t \"%s: recv %d byte data frame, passing to L2TP socket\\n\",\n\t\t\t session->name, data_len);\n\n\t\tif (sock_queue_rcv_skb(sk, skb) < 0) {\n\t\t\tatomic_long_inc(&session->stats.rx_errors);\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\n\treturn;\n\nno_sock:\n\tl2tp_info(session, PPPOL2TP_MSG_DATA, \"%s: no socket\\n\", session->name);\n\tkfree_skb(skb);\n}\n\nstatic void pppol2tp_session_sock_hold(struct l2tp_session *session)\n{\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\n\tif (ps->sock)\n\t\tsock_hold(ps->sock);\n}\n\nstatic void pppol2tp_session_sock_put(struct l2tp_session *session)\n{\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\n\tif (ps->sock)\n\t\tsock_put(ps->sock);\n}\n\n/************************************************************************\n * Transmit handling\n ***********************************************************************/\n\n/* This is the sendmsg for the PPPoL2TP pppol2tp_session socket.  We come here\n * when a user application does a sendmsg() on the session socket. L2TP and\n * PPP headers must be inserted into the user's data.\n */\nstatic int pppol2tp_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,\n\t\t\t    size_t total_len)\n{\n\tstatic const unsigned char ppph[2] = { 0xff, 0x03 };\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint error;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct pppol2tp_session *ps;\n\tint uhlen;\n\n\terror = -ENOTCONN;\n\tif (sock_flag(sk, SOCK_DEAD) || !(sk->sk_state & PPPOX_CONNECTED))\n\t\tgoto error;\n\n\t/* Get session and tunnel contexts */\n\terror = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto error;\n\n\tps = l2tp_session_priv(session);\n\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\tif (tunnel == NULL)\n\t\tgoto error_put_sess;\n\n\tuhlen = (tunnel->encap == L2TP_ENCAPTYPE_UDP) ? sizeof(struct udphdr) : 0;\n\n\t/* Allocate a socket buffer */\n\terror = -ENOMEM;\n\tskb = sock_wmalloc(sk, NET_SKB_PAD + sizeof(struct iphdr) +\n\t\t\t   uhlen + session->hdr_len +\n\t\t\t   sizeof(ppph) + total_len,\n\t\t\t   0, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto error_put_sess_tun;\n\n\t/* Reserve space for headers. */\n\tskb_reserve(skb, NET_SKB_PAD);\n\tskb_reset_network_header(skb);\n\tskb_reserve(skb, sizeof(struct iphdr));\n\tskb_reset_transport_header(skb);\n\tskb_reserve(skb, uhlen);\n\n\t/* Add PPP header */\n\tskb->data[0] = ppph[0];\n\tskb->data[1] = ppph[1];\n\tskb_put(skb, 2);\n\n\t/* Copy user data into skb */\n\terror = memcpy_fromiovec(skb_put(skb, total_len), m->msg_iov,\n\t\t\t\t total_len);\n\tif (error < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto error_put_sess_tun;\n\t}\n\n\tlocal_bh_disable();\n\tl2tp_xmit_skb(session, skb, session->hdr_len);\n\tlocal_bh_enable();\n\n\tsock_put(ps->tunnel_sock);\n\tsock_put(sk);\n\n\treturn total_len;\n\nerror_put_sess_tun:\n\tsock_put(ps->tunnel_sock);\nerror_put_sess:\n\tsock_put(sk);\nerror:\n\treturn error;\n}\n\n/* Transmit function called by generic PPP driver.  Sends PPP frame\n * over PPPoL2TP socket.\n *\n * This is almost the same as pppol2tp_sendmsg(), but rather than\n * being called with a msghdr from userspace, it is called with a skb\n * from the kernel.\n *\n * The supplied skb from ppp doesn't have enough headroom for the\n * insertion of L2TP, UDP and IP headers so we need to allocate more\n * headroom in the skb. This will create a cloned skb. But we must be\n * careful in the error case because the caller will expect to free\n * the skb it supplied, not our cloned skb. So we take care to always\n * leave the original skb unfreed if we return an error.\n */\nstatic int pppol2tp_xmit(struct ppp_channel *chan, struct sk_buff *skb)\n{\n\tstatic const u8 ppph[2] = { 0xff, 0x03 };\n\tstruct sock *sk = (struct sock *) chan->private;\n\tstruct sock *sk_tun;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct pppol2tp_session *ps;\n\tint uhlen, headroom;\n\n\tif (sock_flag(sk, SOCK_DEAD) || !(sk->sk_state & PPPOX_CONNECTED))\n\t\tgoto abort;\n\n\t/* Get session and tunnel contexts from the socket */\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto abort;\n\n\tps = l2tp_session_priv(session);\n\tsk_tun = ps->tunnel_sock;\n\tif (sk_tun == NULL)\n\t\tgoto abort_put_sess;\n\ttunnel = l2tp_sock_to_tunnel(sk_tun);\n\tif (tunnel == NULL)\n\t\tgoto abort_put_sess;\n\n\tuhlen = (tunnel->encap == L2TP_ENCAPTYPE_UDP) ? sizeof(struct udphdr) : 0;\n\theadroom = NET_SKB_PAD +\n\t\t   sizeof(struct iphdr) + /* IP header */\n\t\t   uhlen +\t\t/* UDP header (if L2TP_ENCAPTYPE_UDP) */\n\t\t   session->hdr_len +\t/* L2TP header */\n\t\t   sizeof(ppph);\t/* PPP header */\n\tif (skb_cow_head(skb, headroom))\n\t\tgoto abort_put_sess_tun;\n\n\t/* Setup PPP header */\n\t__skb_push(skb, sizeof(ppph));\n\tskb->data[0] = ppph[0];\n\tskb->data[1] = ppph[1];\n\n\tlocal_bh_disable();\n\tl2tp_xmit_skb(session, skb, session->hdr_len);\n\tlocal_bh_enable();\n\n\tsock_put(sk_tun);\n\tsock_put(sk);\n\treturn 1;\n\nabort_put_sess_tun:\n\tsock_put(sk_tun);\nabort_put_sess:\n\tsock_put(sk);\nabort:\n\t/* Free the original skb */\n\tkfree_skb(skb);\n\treturn 1;\n}\n\n/*****************************************************************************\n * Session (and tunnel control) socket create/destroy.\n *****************************************************************************/\n\n/* Called by l2tp_core when a session socket is being closed.\n */\nstatic void pppol2tp_session_close(struct l2tp_session *session)\n{\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\tstruct sock *sk = ps->sock;\n\tstruct socket *sock = sk->sk_socket;\n\n\tBUG_ON(session->magic != L2TP_SESSION_MAGIC);\n\n\tif (sock) {\n\t\tinet_shutdown(sock, 2);\n\t\t/* Don't let the session go away before our socket does */\n\t\tl2tp_session_inc_refcount(session);\n\t}\n}\n\n/* Really kill the session socket. (Called from sock_put() if\n * refcnt == 0.)\n */\nstatic void pppol2tp_session_destruct(struct sock *sk)\n{\n\tstruct l2tp_session *session = sk->sk_user_data;\n\tif (session) {\n\t\tsk->sk_user_data = NULL;\n\t\tBUG_ON(session->magic != L2TP_SESSION_MAGIC);\n\t\tl2tp_session_dec_refcount(session);\n\t}\n}\n\n/* Called when the PPPoX socket (session) is closed.\n */\nstatic int pppol2tp_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tint error;\n\n\tif (!sk)\n\t\treturn 0;\n\n\terror = -EBADF;\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_DEAD) != 0)\n\t\tgoto error;\n\n\tpppox_unbind_sock(sk);\n\n\t/* Signal the death of the socket. */\n\tsk->sk_state = PPPOX_DEAD;\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\n\tsession = pppol2tp_sock_to_session(sk);\n\n\t/* Purge any queued data */\n\tif (session != NULL) {\n\t\t__l2tp_session_unhash(session);\n\t\tl2tp_session_queue_purge(session);\n\t\tsock_put(sk);\n\t}\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n\n\trelease_sock(sk);\n\n\t/* This will delete the session context via\n\t * pppol2tp_session_destruct() if the socket's refcnt drops to\n\t * zero.\n\t */\n\tsock_put(sk);\n\n\treturn 0;\n\nerror:\n\trelease_sock(sk);\n\treturn error;\n}\n\nstatic struct proto pppol2tp_sk_proto = {\n\t.name\t  = \"PPPOL2TP\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct pppox_sock),\n};\n\nstatic int pppol2tp_backlog_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\n\trc = l2tp_udp_encap_recv(sk, skb);\n\tif (rc)\n\t\tkfree_skb(skb);\n\n\treturn NET_RX_SUCCESS;\n}\n\n/* socket() handler. Initialize a new struct sock.\n */\nstatic int pppol2tp_create(struct net *net, struct socket *sock)\n{\n\tint error = -ENOMEM;\n\tstruct sock *sk;\n\n\tsk = sk_alloc(net, PF_PPPOX, GFP_KERNEL, &pppol2tp_sk_proto);\n\tif (!sk)\n\t\tgoto out;\n\n\tsock_init_data(sock, sk);\n\n\tsock->state  = SS_UNCONNECTED;\n\tsock->ops    = &pppol2tp_ops;\n\n\tsk->sk_backlog_rcv = pppol2tp_backlog_recv;\n\tsk->sk_protocol\t   = PX_PROTO_OL2TP;\n\tsk->sk_family\t   = PF_PPPOX;\n\tsk->sk_state\t   = PPPOX_NONE;\n\tsk->sk_type\t   = SOCK_STREAM;\n\tsk->sk_destruct\t   = pppol2tp_session_destruct;\n\n\terror = 0;\n\nout:\n\treturn error;\n}\n\n#if defined(CONFIG_L2TP_DEBUGFS) || defined(CONFIG_L2TP_DEBUGFS_MODULE)\nstatic void pppol2tp_show(struct seq_file *m, void *arg)\n{\n\tstruct l2tp_session *session = arg;\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\n\tif (ps) {\n\t\tstruct pppox_sock *po = pppox_sk(ps->sock);\n\t\tif (po)\n\t\t\tseq_printf(m, \"   interface %s\\n\", ppp_dev_name(&po->chan));\n\t}\n}\n#endif\n\n/* connect() handler. Attach a PPPoX socket to a tunnel UDP socket\n */\nstatic int pppol2tp_connect(struct socket *sock, struct sockaddr *uservaddr,\n\t\t\t    int sockaddr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_pppol2tp *sp = (struct sockaddr_pppol2tp *) uservaddr;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct l2tp_session *session = NULL;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct pppol2tp_session *ps;\n\tstruct dst_entry *dst;\n\tstruct l2tp_session_cfg cfg = { 0, };\n\tint error = 0;\n\tu32 tunnel_id, peer_tunnel_id;\n\tu32 session_id, peer_session_id;\n\tint ver = 2;\n\tint fd;\n\n\tlock_sock(sk);\n\n\terror = -EINVAL;\n\tif (sp->sa_protocol != PX_PROTO_OL2TP)\n\t\tgoto end;\n\n\t/* Check for already bound sockets */\n\terror = -EBUSY;\n\tif (sk->sk_state & PPPOX_CONNECTED)\n\t\tgoto end;\n\n\t/* We don't supporting rebinding anyway */\n\terror = -EALREADY;\n\tif (sk->sk_user_data)\n\t\tgoto end; /* socket is already attached */\n\n\t/* Get params from socket address. Handle L2TPv2 and L2TPv3.\n\t * This is nasty because there are different sockaddr_pppol2tp\n\t * structs for L2TPv2, L2TPv3, over IPv4 and IPv6. We use\n\t * the sockaddr size to determine which structure the caller\n\t * is using.\n\t */\n\tpeer_tunnel_id = 0;\n\tif (sockaddr_len == sizeof(struct sockaddr_pppol2tp)) {\n\t\tfd = sp->pppol2tp.fd;\n\t\ttunnel_id = sp->pppol2tp.s_tunnel;\n\t\tpeer_tunnel_id = sp->pppol2tp.d_tunnel;\n\t\tsession_id = sp->pppol2tp.s_session;\n\t\tpeer_session_id = sp->pppol2tp.d_session;\n\t} else if (sockaddr_len == sizeof(struct sockaddr_pppol2tpv3)) {\n\t\tstruct sockaddr_pppol2tpv3 *sp3 =\n\t\t\t(struct sockaddr_pppol2tpv3 *) sp;\n\t\tver = 3;\n\t\tfd = sp3->pppol2tp.fd;\n\t\ttunnel_id = sp3->pppol2tp.s_tunnel;\n\t\tpeer_tunnel_id = sp3->pppol2tp.d_tunnel;\n\t\tsession_id = sp3->pppol2tp.s_session;\n\t\tpeer_session_id = sp3->pppol2tp.d_session;\n\t} else if (sockaddr_len == sizeof(struct sockaddr_pppol2tpin6)) {\n\t\tstruct sockaddr_pppol2tpin6 *sp6 =\n\t\t\t(struct sockaddr_pppol2tpin6 *) sp;\n\t\tfd = sp6->pppol2tp.fd;\n\t\ttunnel_id = sp6->pppol2tp.s_tunnel;\n\t\tpeer_tunnel_id = sp6->pppol2tp.d_tunnel;\n\t\tsession_id = sp6->pppol2tp.s_session;\n\t\tpeer_session_id = sp6->pppol2tp.d_session;\n\t} else if (sockaddr_len == sizeof(struct sockaddr_pppol2tpv3in6)) {\n\t\tstruct sockaddr_pppol2tpv3in6 *sp6 =\n\t\t\t(struct sockaddr_pppol2tpv3in6 *) sp;\n\t\tver = 3;\n\t\tfd = sp6->pppol2tp.fd;\n\t\ttunnel_id = sp6->pppol2tp.s_tunnel;\n\t\tpeer_tunnel_id = sp6->pppol2tp.d_tunnel;\n\t\tsession_id = sp6->pppol2tp.s_session;\n\t\tpeer_session_id = sp6->pppol2tp.d_session;\n\t} else {\n\t\terror = -EINVAL;\n\t\tgoto end; /* bad socket address */\n\t}\n\n\t/* Don't bind if tunnel_id is 0 */\n\terror = -EINVAL;\n\tif (tunnel_id == 0)\n\t\tgoto end;\n\n\ttunnel = l2tp_tunnel_find(sock_net(sk), tunnel_id);\n\n\t/* Special case: create tunnel context if session_id and\n\t * peer_session_id is 0. Otherwise look up tunnel using supplied\n\t * tunnel id.\n\t */\n\tif ((session_id == 0) && (peer_session_id == 0)) {\n\t\tif (tunnel == NULL) {\n\t\t\tstruct l2tp_tunnel_cfg tcfg = {\n\t\t\t\t.encap = L2TP_ENCAPTYPE_UDP,\n\t\t\t\t.debug = 0,\n\t\t\t};\n\t\t\terror = l2tp_tunnel_create(sock_net(sk), fd, ver, tunnel_id, peer_tunnel_id, &tcfg, &tunnel);\n\t\t\tif (error < 0)\n\t\t\t\tgoto end;\n\t\t}\n\t} else {\n\t\t/* Error if we can't find the tunnel */\n\t\terror = -ENOENT;\n\t\tif (tunnel == NULL)\n\t\t\tgoto end;\n\n\t\t/* Error if socket is not prepped */\n\t\tif (tunnel->sock == NULL)\n\t\t\tgoto end;\n\t}\n\n\tif (tunnel->recv_payload_hook == NULL)\n\t\ttunnel->recv_payload_hook = pppol2tp_recv_payload_hook;\n\n\tif (tunnel->peer_tunnel_id == 0)\n\t\ttunnel->peer_tunnel_id = peer_tunnel_id;\n\n\t/* Create session if it doesn't already exist. We handle the\n\t * case where a session was previously created by the netlink\n\t * interface by checking that the session doesn't already have\n\t * a socket and its tunnel socket are what we expect. If any\n\t * of those checks fail, return EEXIST to the caller.\n\t */\n\tsession = l2tp_session_find(sock_net(sk), tunnel, session_id);\n\tif (session == NULL) {\n\t\t/* Default MTU must allow space for UDP/L2TP/PPP\n\t\t * headers.\n\t\t */\n\t\tcfg.mtu = cfg.mru = 1500 - PPPOL2TP_HEADER_OVERHEAD;\n\n\t\t/* Allocate and initialize a new session context. */\n\t\tsession = l2tp_session_create(sizeof(struct pppol2tp_session),\n\t\t\t\t\t      tunnel, session_id,\n\t\t\t\t\t      peer_session_id, &cfg);\n\t\tif (session == NULL) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto end;\n\t\t}\n\t} else {\n\t\tps = l2tp_session_priv(session);\n\t\terror = -EEXIST;\n\t\tif (ps->sock != NULL)\n\t\t\tgoto end;\n\n\t\t/* consistency checks */\n\t\tif (ps->tunnel_sock != tunnel->sock)\n\t\t\tgoto end;\n\t}\n\n\t/* Associate session with its PPPoL2TP socket */\n\tps = l2tp_session_priv(session);\n\tps->owner\t     = current->pid;\n\tps->sock\t     = sk;\n\tps->tunnel_sock = tunnel->sock;\n\n\tsession->recv_skb\t= pppol2tp_recv;\n\tsession->session_close\t= pppol2tp_session_close;\n#if defined(CONFIG_L2TP_DEBUGFS) || defined(CONFIG_L2TP_DEBUGFS_MODULE)\n\tsession->show\t\t= pppol2tp_show;\n#endif\n\n\t/* We need to know each time a skb is dropped from the reorder\n\t * queue.\n\t */\n\tsession->ref = pppol2tp_session_sock_hold;\n\tsession->deref = pppol2tp_session_sock_put;\n\n\t/* If PMTU discovery was enabled, use the MTU that was discovered */\n\tdst = sk_dst_get(tunnel->sock);\n\tif (dst != NULL) {\n\t\tu32 pmtu = dst_mtu(__sk_dst_get(tunnel->sock));\n\t\tif (pmtu != 0)\n\t\t\tsession->mtu = session->mru = pmtu -\n\t\t\t\tPPPOL2TP_HEADER_OVERHEAD;\n\t\tdst_release(dst);\n\t}\n\n\t/* Special case: if source & dest session_id == 0x0000, this\n\t * socket is being created to manage the tunnel. Just set up\n\t * the internal context for use by ioctl() and sockopt()\n\t * handlers.\n\t */\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terror = 0;\n\t\tgoto out_no_ppp;\n\t}\n\n\t/* The only header we need to worry about is the L2TP\n\t * header. This size is different depending on whether\n\t * sequence numbers are enabled for the data channel.\n\t */\n\tpo->chan.hdrlen = PPPOL2TP_L2TP_HDR_SIZE_NOSEQ;\n\n\tpo->chan.private = sk;\n\tpo->chan.ops\t = &pppol2tp_chan_ops;\n\tpo->chan.mtu\t = session->mtu;\n\n\terror = ppp_register_net_channel(sock_net(sk), &po->chan);\n\tif (error)\n\t\tgoto end;\n\nout_no_ppp:\n\t/* This is how we get the session context from the socket. */\n\tsk->sk_user_data = session;\n\tsk->sk_state = PPPOX_CONNECTED;\n\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: created\\n\",\n\t\t  session->name);\n\nend:\n\trelease_sock(sk);\n\n\treturn error;\n}\n\n#ifdef CONFIG_L2TP_V3\n\n/* Called when creating sessions via the netlink interface.\n */\nstatic int pppol2tp_session_create(struct net *net, u32 tunnel_id, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg)\n{\n\tint error;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct l2tp_session *session;\n\tstruct pppol2tp_session *ps;\n\n\ttunnel = l2tp_tunnel_find(net, tunnel_id);\n\n\t/* Error if we can't find the tunnel */\n\terror = -ENOENT;\n\tif (tunnel == NULL)\n\t\tgoto out;\n\n\t/* Error if tunnel socket is not prepped */\n\tif (tunnel->sock == NULL)\n\t\tgoto out;\n\n\t/* Check that this session doesn't already exist */\n\terror = -EEXIST;\n\tsession = l2tp_session_find(net, tunnel, session_id);\n\tif (session != NULL)\n\t\tgoto out;\n\n\t/* Default MTU values. */\n\tif (cfg->mtu == 0)\n\t\tcfg->mtu = 1500 - PPPOL2TP_HEADER_OVERHEAD;\n\tif (cfg->mru == 0)\n\t\tcfg->mru = cfg->mtu;\n\n\t/* Allocate and initialize a new session context. */\n\terror = -ENOMEM;\n\tsession = l2tp_session_create(sizeof(struct pppol2tp_session),\n\t\t\t\t      tunnel, session_id,\n\t\t\t\t      peer_session_id, cfg);\n\tif (session == NULL)\n\t\tgoto out;\n\n\tps = l2tp_session_priv(session);\n\tps->tunnel_sock = tunnel->sock;\n\n\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: created\\n\",\n\t\t  session->name);\n\n\terror = 0;\n\nout:\n\treturn error;\n}\n\n#endif /* CONFIG_L2TP_V3 */\n\n/* getname() support.\n */\nstatic int pppol2tp_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t    int *usockaddr_len, int peer)\n{\n\tint len = 0;\n\tint error = 0;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct sock *sk = sock->sk;\n\tstruct inet_sock *inet;\n\tstruct pppol2tp_session *pls;\n\n\terror = -ENOTCONN;\n\tif (sk == NULL)\n\t\tgoto end;\n\tif (sk->sk_state != PPPOX_CONNECTED)\n\t\tgoto end;\n\n\terror = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\n\tpls = l2tp_session_priv(session);\n\ttunnel = l2tp_sock_to_tunnel(pls->tunnel_sock);\n\tif (tunnel == NULL) {\n\t\terror = -EBADF;\n\t\tgoto end_put_sess;\n\t}\n\n\tinet = inet_sk(tunnel->sock);\n\tif ((tunnel->version == 2) && (tunnel->sock->sk_family == AF_INET)) {\n\t\tstruct sockaddr_pppol2tp sp;\n\t\tlen = sizeof(sp);\n\t\tmemset(&sp, 0, len);\n\t\tsp.sa_family\t= AF_PPPOX;\n\t\tsp.sa_protocol\t= PX_PROTO_OL2TP;\n\t\tsp.pppol2tp.fd  = tunnel->fd;\n\t\tsp.pppol2tp.pid = pls->owner;\n\t\tsp.pppol2tp.s_tunnel = tunnel->tunnel_id;\n\t\tsp.pppol2tp.d_tunnel = tunnel->peer_tunnel_id;\n\t\tsp.pppol2tp.s_session = session->session_id;\n\t\tsp.pppol2tp.d_session = session->peer_session_id;\n\t\tsp.pppol2tp.addr.sin_family = AF_INET;\n\t\tsp.pppol2tp.addr.sin_port = inet->inet_dport;\n\t\tsp.pppol2tp.addr.sin_addr.s_addr = inet->inet_daddr;\n\t\tmemcpy(uaddr, &sp, len);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if ((tunnel->version == 2) &&\n\t\t   (tunnel->sock->sk_family == AF_INET6)) {\n\t\tstruct sockaddr_pppol2tpin6 sp;\n\n\t\tlen = sizeof(sp);\n\t\tmemset(&sp, 0, len);\n\t\tsp.sa_family\t= AF_PPPOX;\n\t\tsp.sa_protocol\t= PX_PROTO_OL2TP;\n\t\tsp.pppol2tp.fd  = tunnel->fd;\n\t\tsp.pppol2tp.pid = pls->owner;\n\t\tsp.pppol2tp.s_tunnel = tunnel->tunnel_id;\n\t\tsp.pppol2tp.d_tunnel = tunnel->peer_tunnel_id;\n\t\tsp.pppol2tp.s_session = session->session_id;\n\t\tsp.pppol2tp.d_session = session->peer_session_id;\n\t\tsp.pppol2tp.addr.sin6_family = AF_INET6;\n\t\tsp.pppol2tp.addr.sin6_port = inet->inet_dport;\n\t\tmemcpy(&sp.pppol2tp.addr.sin6_addr, &tunnel->sock->sk_v6_daddr,\n\t\t       sizeof(tunnel->sock->sk_v6_daddr));\n\t\tmemcpy(uaddr, &sp, len);\n\t} else if ((tunnel->version == 3) &&\n\t\t   (tunnel->sock->sk_family == AF_INET6)) {\n\t\tstruct sockaddr_pppol2tpv3in6 sp;\n\n\t\tlen = sizeof(sp);\n\t\tmemset(&sp, 0, len);\n\t\tsp.sa_family\t= AF_PPPOX;\n\t\tsp.sa_protocol\t= PX_PROTO_OL2TP;\n\t\tsp.pppol2tp.fd  = tunnel->fd;\n\t\tsp.pppol2tp.pid = pls->owner;\n\t\tsp.pppol2tp.s_tunnel = tunnel->tunnel_id;\n\t\tsp.pppol2tp.d_tunnel = tunnel->peer_tunnel_id;\n\t\tsp.pppol2tp.s_session = session->session_id;\n\t\tsp.pppol2tp.d_session = session->peer_session_id;\n\t\tsp.pppol2tp.addr.sin6_family = AF_INET6;\n\t\tsp.pppol2tp.addr.sin6_port = inet->inet_dport;\n\t\tmemcpy(&sp.pppol2tp.addr.sin6_addr, &tunnel->sock->sk_v6_daddr,\n\t\t       sizeof(tunnel->sock->sk_v6_daddr));\n\t\tmemcpy(uaddr, &sp, len);\n#endif\n\t} else if (tunnel->version == 3) {\n\t\tstruct sockaddr_pppol2tpv3 sp;\n\t\tlen = sizeof(sp);\n\t\tmemset(&sp, 0, len);\n\t\tsp.sa_family\t= AF_PPPOX;\n\t\tsp.sa_protocol\t= PX_PROTO_OL2TP;\n\t\tsp.pppol2tp.fd  = tunnel->fd;\n\t\tsp.pppol2tp.pid = pls->owner;\n\t\tsp.pppol2tp.s_tunnel = tunnel->tunnel_id;\n\t\tsp.pppol2tp.d_tunnel = tunnel->peer_tunnel_id;\n\t\tsp.pppol2tp.s_session = session->session_id;\n\t\tsp.pppol2tp.d_session = session->peer_session_id;\n\t\tsp.pppol2tp.addr.sin_family = AF_INET;\n\t\tsp.pppol2tp.addr.sin_port = inet->inet_dport;\n\t\tsp.pppol2tp.addr.sin_addr.s_addr = inet->inet_daddr;\n\t\tmemcpy(uaddr, &sp, len);\n\t}\n\n\t*usockaddr_len = len;\n\n\tsock_put(pls->tunnel_sock);\nend_put_sess:\n\tsock_put(sk);\n\terror = 0;\n\nend:\n\treturn error;\n}\n\n/****************************************************************************\n * ioctl() handlers.\n *\n * The PPPoX socket is created for L2TP sessions: tunnels have their own UDP\n * sockets. However, in order to control kernel tunnel features, we allow\n * userspace to create a special \"tunnel\" PPPoX socket which is used for\n * control only.  Tunnel PPPoX sockets have session_id == 0 and simply allow\n * the user application to issue L2TP setsockopt(), getsockopt() and ioctl()\n * calls.\n ****************************************************************************/\n\nstatic void pppol2tp_copy_stats(struct pppol2tp_ioc_stats *dest,\n\t\t\t\tstruct l2tp_stats *stats)\n{\n\tdest->tx_packets = atomic_long_read(&stats->tx_packets);\n\tdest->tx_bytes = atomic_long_read(&stats->tx_bytes);\n\tdest->tx_errors = atomic_long_read(&stats->tx_errors);\n\tdest->rx_packets = atomic_long_read(&stats->rx_packets);\n\tdest->rx_bytes = atomic_long_read(&stats->rx_bytes);\n\tdest->rx_seq_discards = atomic_long_read(&stats->rx_seq_discards);\n\tdest->rx_oos_packets = atomic_long_read(&stats->rx_oos_packets);\n\tdest->rx_errors = atomic_long_read(&stats->rx_errors);\n}\n\n/* Session ioctl helper.\n */\nstatic int pppol2tp_session_ioctl(struct l2tp_session *session,\n\t\t\t\t  unsigned int cmd, unsigned long arg)\n{\n\tstruct ifreq ifr;\n\tint err = 0;\n\tstruct sock *sk;\n\tint val = (int) arg;\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\tstruct l2tp_tunnel *tunnel = session->tunnel;\n\tstruct pppol2tp_ioc_stats stats;\n\n\tl2tp_dbg(session, PPPOL2TP_MSG_CONTROL,\n\t\t \"%s: pppol2tp_session_ioctl(cmd=%#x, arg=%#lx)\\n\",\n\t\t session->name, cmd, arg);\n\n\tsk = ps->sock;\n\tsock_hold(sk);\n\n\tswitch (cmd) {\n\tcase SIOCGIFMTU:\n\t\terr = -ENXIO;\n\t\tif (!(sk->sk_state & PPPOX_CONNECTED))\n\t\t\tbreak;\n\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&ifr, (void __user *) arg, sizeof(struct ifreq)))\n\t\t\tbreak;\n\t\tifr.ifr_mtu = session->mtu;\n\t\tif (copy_to_user((void __user *) arg, &ifr, sizeof(struct ifreq)))\n\t\t\tbreak;\n\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: get mtu=%d\\n\",\n\t\t\t  session->name, session->mtu);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase SIOCSIFMTU:\n\t\terr = -ENXIO;\n\t\tif (!(sk->sk_state & PPPOX_CONNECTED))\n\t\t\tbreak;\n\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&ifr, (void __user *) arg, sizeof(struct ifreq)))\n\t\t\tbreak;\n\n\t\tsession->mtu = ifr.ifr_mtu;\n\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: set mtu=%d\\n\",\n\t\t\t  session->name, session->mtu);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGMRU:\n\t\terr = -ENXIO;\n\t\tif (!(sk->sk_state & PPPOX_CONNECTED))\n\t\t\tbreak;\n\n\t\terr = -EFAULT;\n\t\tif (put_user(session->mru, (int __user *) arg))\n\t\t\tbreak;\n\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: get mru=%d\\n\",\n\t\t\t  session->name, session->mru);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCSMRU:\n\t\terr = -ENXIO;\n\t\tif (!(sk->sk_state & PPPOX_CONNECTED))\n\t\t\tbreak;\n\n\t\terr = -EFAULT;\n\t\tif (get_user(val, (int __user *) arg))\n\t\t\tbreak;\n\n\t\tsession->mru = val;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: set mru=%d\\n\",\n\t\t\t  session->name, session->mru);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGFLAGS:\n\t\terr = -EFAULT;\n\t\tif (put_user(ps->flags, (int __user *) arg))\n\t\t\tbreak;\n\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: get flags=%d\\n\",\n\t\t\t  session->name, ps->flags);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCSFLAGS:\n\t\terr = -EFAULT;\n\t\tif (get_user(val, (int __user *) arg))\n\t\t\tbreak;\n\t\tps->flags = val;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: set flags=%d\\n\",\n\t\t\t  session->name, ps->flags);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGL2TPSTATS:\n\t\terr = -ENXIO;\n\t\tif (!(sk->sk_state & PPPOX_CONNECTED))\n\t\t\tbreak;\n\n\t\tmemset(&stats, 0, sizeof(stats));\n\t\tstats.tunnel_id = tunnel->tunnel_id;\n\t\tstats.session_id = session->session_id;\n\t\tpppol2tp_copy_stats(&stats, &session->stats);\n\t\tif (copy_to_user((void __user *) arg, &stats,\n\t\t\t\t sizeof(stats)))\n\t\t\tbreak;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: get L2TP stats\\n\",\n\t\t\t  session->name);\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOSYS;\n\t\tbreak;\n\t}\n\n\tsock_put(sk);\n\n\treturn err;\n}\n\n/* Tunnel ioctl helper.\n *\n * Note the special handling for PPPIOCGL2TPSTATS below. If the ioctl data\n * specifies a session_id, the session ioctl handler is called. This allows an\n * application to retrieve session stats via a tunnel socket.\n */\nstatic int pppol2tp_tunnel_ioctl(struct l2tp_tunnel *tunnel,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tint err = 0;\n\tstruct sock *sk;\n\tstruct pppol2tp_ioc_stats stats;\n\n\tl2tp_dbg(tunnel, PPPOL2TP_MSG_CONTROL,\n\t\t \"%s: pppol2tp_tunnel_ioctl(cmd=%#x, arg=%#lx)\\n\",\n\t\t tunnel->name, cmd, arg);\n\n\tsk = tunnel->sock;\n\tsock_hold(sk);\n\n\tswitch (cmd) {\n\tcase PPPIOCGL2TPSTATS:\n\t\terr = -ENXIO;\n\t\tif (!(sk->sk_state & PPPOX_CONNECTED))\n\t\t\tbreak;\n\n\t\tif (copy_from_user(&stats, (void __user *) arg,\n\t\t\t\t   sizeof(stats))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (stats.session_id != 0) {\n\t\t\t/* resend to session ioctl handler */\n\t\t\tstruct l2tp_session *session =\n\t\t\t\tl2tp_session_find(sock_net(sk), tunnel, stats.session_id);\n\t\t\tif (session != NULL)\n\t\t\t\terr = pppol2tp_session_ioctl(session, cmd, arg);\n\t\t\telse\n\t\t\t\terr = -EBADR;\n\t\t\tbreak;\n\t\t}\n#ifdef CONFIG_XFRM\n\t\tstats.using_ipsec = (sk->sk_policy[0] || sk->sk_policy[1]) ? 1 : 0;\n#endif\n\t\tpppol2tp_copy_stats(&stats, &tunnel->stats);\n\t\tif (copy_to_user((void __user *) arg, &stats, sizeof(stats))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tl2tp_info(tunnel, PPPOL2TP_MSG_CONTROL, \"%s: get L2TP stats\\n\",\n\t\t\t  tunnel->name);\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOSYS;\n\t\tbreak;\n\t}\n\n\tsock_put(sk);\n\n\treturn err;\n}\n\n/* Main ioctl() handler.\n * Dispatch to tunnel or session helpers depending on the socket.\n */\nstatic int pppol2tp_ioctl(struct socket *sock, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct pppol2tp_session *ps;\n\tint err;\n\n\tif (!sk)\n\t\treturn 0;\n\n\terr = -EBADF;\n\tif (sock_flag(sk, SOCK_DEAD) != 0)\n\t\tgoto end;\n\n\terr = -ENOTCONN;\n\tif ((sk->sk_user_data == NULL) ||\n\t    (!(sk->sk_state & (PPPOX_CONNECTED | PPPOX_BOUND))))\n\t\tgoto end;\n\n\t/* Get session context from the socket */\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\n\t/* Special case: if session's session_id is zero, treat ioctl as a\n\t * tunnel ioctl\n\t */\n\tps = l2tp_session_priv(session);\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\n\t\terr = pppol2tp_tunnel_ioctl(tunnel, cmd, arg);\n\t\tsock_put(ps->tunnel_sock);\n\t\tgoto end_put_sess;\n\t}\n\n\terr = pppol2tp_session_ioctl(session, cmd, arg);\n\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}\n\n/*****************************************************************************\n * setsockopt() / getsockopt() support.\n *\n * The PPPoX socket is created for L2TP sessions: tunnels have their own UDP\n * sockets. In order to control kernel tunnel features, we allow userspace to\n * create a special \"tunnel\" PPPoX socket which is used for control only.\n * Tunnel PPPoX sockets have session_id == 0 and simply allow the user\n * application to issue L2TP setsockopt(), getsockopt() and ioctl() calls.\n *****************************************************************************/\n\n/* Tunnel setsockopt() helper.\n */\nstatic int pppol2tp_tunnel_setsockopt(struct sock *sk,\n\t\t\t\t      struct l2tp_tunnel *tunnel,\n\t\t\t\t      int optname, int val)\n{\n\tint err = 0;\n\n\tswitch (optname) {\n\tcase PPPOL2TP_SO_DEBUG:\n\t\ttunnel->debug = val;\n\t\tl2tp_info(tunnel, PPPOL2TP_MSG_CONTROL, \"%s: set debug=%x\\n\",\n\t\t\t  tunnel->name, tunnel->debug);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n/* Session setsockopt helper.\n */\nstatic int pppol2tp_session_setsockopt(struct sock *sk,\n\t\t\t\t       struct l2tp_session *session,\n\t\t\t\t       int optname, int val)\n{\n\tint err = 0;\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\n\tswitch (optname) {\n\tcase PPPOL2TP_SO_RECVSEQ:\n\t\tif ((val != 0) && (val != 1)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsession->recv_seq = val ? -1 : 0;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: set recv_seq=%d\\n\",\n\t\t\t  session->name, session->recv_seq);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_SENDSEQ:\n\t\tif ((val != 0) && (val != 1)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsession->send_seq = val ? -1 : 0;\n\t\t{\n\t\t\tstruct sock *ssk      = ps->sock;\n\t\t\tstruct pppox_sock *po = pppox_sk(ssk);\n\t\t\tpo->chan.hdrlen = val ? PPPOL2TP_L2TP_HDR_SIZE_SEQ :\n\t\t\t\tPPPOL2TP_L2TP_HDR_SIZE_NOSEQ;\n\t\t}\n\t\tl2tp_session_set_header_len(session, session->tunnel->version);\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: set send_seq=%d\\n\",\n\t\t\t  session->name, session->send_seq);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_LNSMODE:\n\t\tif ((val != 0) && (val != 1)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsession->lns_mode = val ? -1 : 0;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: set lns_mode=%d\\n\",\n\t\t\t  session->name, session->lns_mode);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_DEBUG:\n\t\tsession->debug = val;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: set debug=%x\\n\",\n\t\t\t  session->name, session->debug);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_REORDERTO:\n\t\tsession->reorder_timeout = msecs_to_jiffies(val);\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: set reorder_timeout=%d\\n\",\n\t\t\t  session->name, session->reorder_timeout);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n/* Main setsockopt() entry point.\n * Does API checks, then calls either the tunnel or session setsockopt\n * handler, according to whether the PPPoL2TP socket is a for a regular\n * session or the special tunnel type.\n */\nstatic int pppol2tp_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct pppol2tp_session *ps;\n\tint val;\n\tint err;\n\n\tif (level != SOL_PPPOL2TP)\n\t\treturn udp_prot.setsockopt(sk, level, optname, optval, optlen);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\terr = -ENOTCONN;\n\tif (sk->sk_user_data == NULL)\n\t\tgoto end;\n\n\t/* Get session context from the socket */\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\n\t/* Special case: if session_id == 0x0000, treat as operation on tunnel\n\t */\n\tps = l2tp_session_priv(session);\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\n\t\terr = pppol2tp_tunnel_setsockopt(sk, tunnel, optname, val);\n\t\tsock_put(ps->tunnel_sock);\n\t} else\n\t\terr = pppol2tp_session_setsockopt(sk, session, optname, val);\n\n\terr = 0;\n\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}\n\n/* Tunnel getsockopt helper. Called with sock locked.\n */\nstatic int pppol2tp_tunnel_getsockopt(struct sock *sk,\n\t\t\t\t      struct l2tp_tunnel *tunnel,\n\t\t\t\t      int optname, int *val)\n{\n\tint err = 0;\n\n\tswitch (optname) {\n\tcase PPPOL2TP_SO_DEBUG:\n\t\t*val = tunnel->debug;\n\t\tl2tp_info(tunnel, PPPOL2TP_MSG_CONTROL, \"%s: get debug=%x\\n\",\n\t\t\t  tunnel->name, tunnel->debug);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n/* Session getsockopt helper. Called with sock locked.\n */\nstatic int pppol2tp_session_getsockopt(struct sock *sk,\n\t\t\t\t       struct l2tp_session *session,\n\t\t\t\t       int optname, int *val)\n{\n\tint err = 0;\n\n\tswitch (optname) {\n\tcase PPPOL2TP_SO_RECVSEQ:\n\t\t*val = session->recv_seq;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: get recv_seq=%d\\n\", session->name, *val);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_SENDSEQ:\n\t\t*val = session->send_seq;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: get send_seq=%d\\n\", session->name, *val);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_LNSMODE:\n\t\t*val = session->lns_mode;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: get lns_mode=%d\\n\", session->name, *val);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_DEBUG:\n\t\t*val = session->debug;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: get debug=%d\\n\",\n\t\t\t  session->name, *val);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_REORDERTO:\n\t\t*val = (int) jiffies_to_msecs(session->reorder_timeout);\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: get reorder_timeout=%d\\n\", session->name, *val);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t}\n\n\treturn err;\n}\n\n/* Main getsockopt() entry point.\n * Does API checks, then calls either the tunnel or session getsockopt\n * handler, according to whether the PPPoX socket is a for a regular session\n * or the special tunnel type.\n */\nstatic int pppol2tp_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tint val, len;\n\tint err;\n\tstruct pppol2tp_session *ps;\n\n\tif (level != SOL_PPPOL2TP)\n\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlen = min_t(unsigned int, len, sizeof(int));\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\terr = -ENOTCONN;\n\tif (sk->sk_user_data == NULL)\n\t\tgoto end;\n\n\t/* Get the session context */\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\n\t/* Special case: if session_id == 0x0000, treat as operation on tunnel */\n\tps = l2tp_session_priv(session);\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\n\t\terr = pppol2tp_tunnel_getsockopt(sk, tunnel, optname, &val);\n\t\tsock_put(ps->tunnel_sock);\n\t} else\n\t\terr = pppol2tp_session_getsockopt(sk, session, optname, &val);\n\n\terr = -EFAULT;\n\tif (put_user(len, optlen))\n\t\tgoto end_put_sess;\n\n\tif (copy_to_user((void __user *) optval, &val, len))\n\t\tgoto end_put_sess;\n\n\terr = 0;\n\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}\n\n/*****************************************************************************\n * /proc filesystem for debug\n * Since the original pppol2tp driver provided /proc/net/pppol2tp for\n * L2TPv2, we dump only L2TPv2 tunnels and sessions here.\n *****************************************************************************/\n\nstatic unsigned int pppol2tp_net_id;\n\n#ifdef CONFIG_PROC_FS\n\nstruct pppol2tp_seq_data {\n\tstruct seq_net_private p;\n\tint tunnel_idx;\t\t\t/* current tunnel */\n\tint session_idx;\t\t/* index of session within current tunnel */\n\tstruct l2tp_tunnel *tunnel;\n\tstruct l2tp_session *session;\t/* NULL means get next tunnel */\n};\n\nstatic void pppol2tp_next_tunnel(struct net *net, struct pppol2tp_seq_data *pd)\n{\n\tfor (;;) {\n\t\tpd->tunnel = l2tp_tunnel_find_nth(net, pd->tunnel_idx);\n\t\tpd->tunnel_idx++;\n\n\t\tif (pd->tunnel == NULL)\n\t\t\tbreak;\n\n\t\t/* Ignore L2TPv3 tunnels */\n\t\tif (pd->tunnel->version < 3)\n\t\t\tbreak;\n\t}\n}\n\nstatic void pppol2tp_next_session(struct net *net, struct pppol2tp_seq_data *pd)\n{\n\tpd->session = l2tp_session_find_nth(pd->tunnel, pd->session_idx);\n\tpd->session_idx++;\n\n\tif (pd->session == NULL) {\n\t\tpd->session_idx = 0;\n\t\tpppol2tp_next_tunnel(net, pd);\n\t}\n}\n\nstatic void *pppol2tp_seq_start(struct seq_file *m, loff_t *offs)\n{\n\tstruct pppol2tp_seq_data *pd = SEQ_START_TOKEN;\n\tloff_t pos = *offs;\n\tstruct net *net;\n\n\tif (!pos)\n\t\tgoto out;\n\n\tBUG_ON(m->private == NULL);\n\tpd = m->private;\n\tnet = seq_file_net(m);\n\n\tif (pd->tunnel == NULL)\n\t\tpppol2tp_next_tunnel(net, pd);\n\telse\n\t\tpppol2tp_next_session(net, pd);\n\n\t/* NULL tunnel and session indicates end of list */\n\tif ((pd->tunnel == NULL) && (pd->session == NULL))\n\t\tpd = NULL;\n\nout:\n\treturn pd;\n}\n\nstatic void *pppol2tp_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn NULL;\n}\n\nstatic void pppol2tp_seq_stop(struct seq_file *p, void *v)\n{\n\t/* nothing to do */\n}\n\nstatic void pppol2tp_seq_tunnel_show(struct seq_file *m, void *v)\n{\n\tstruct l2tp_tunnel *tunnel = v;\n\n\tseq_printf(m, \"\\nTUNNEL '%s', %c %d\\n\",\n\t\t   tunnel->name,\n\t\t   (tunnel == tunnel->sock->sk_user_data) ? 'Y' : 'N',\n\t\t   atomic_read(&tunnel->ref_count) - 1);\n\tseq_printf(m, \" %08x %ld/%ld/%ld %ld/%ld/%ld\\n\",\n\t\t   tunnel->debug,\n\t\t   atomic_long_read(&tunnel->stats.tx_packets),\n\t\t   atomic_long_read(&tunnel->stats.tx_bytes),\n\t\t   atomic_long_read(&tunnel->stats.tx_errors),\n\t\t   atomic_long_read(&tunnel->stats.rx_packets),\n\t\t   atomic_long_read(&tunnel->stats.rx_bytes),\n\t\t   atomic_long_read(&tunnel->stats.rx_errors));\n}\n\nstatic void pppol2tp_seq_session_show(struct seq_file *m, void *v)\n{\n\tstruct l2tp_session *session = v;\n\tstruct l2tp_tunnel *tunnel = session->tunnel;\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\tstruct pppox_sock *po = pppox_sk(ps->sock);\n\tu32 ip = 0;\n\tu16 port = 0;\n\n\tif (tunnel->sock) {\n\t\tstruct inet_sock *inet = inet_sk(tunnel->sock);\n\t\tip = ntohl(inet->inet_saddr);\n\t\tport = ntohs(inet->inet_sport);\n\t}\n\n\tseq_printf(m, \"  SESSION '%s' %08X/%d %04X/%04X -> \"\n\t\t   \"%04X/%04X %d %c\\n\",\n\t\t   session->name, ip, port,\n\t\t   tunnel->tunnel_id,\n\t\t   session->session_id,\n\t\t   tunnel->peer_tunnel_id,\n\t\t   session->peer_session_id,\n\t\t   ps->sock->sk_state,\n\t\t   (session == ps->sock->sk_user_data) ?\n\t\t   'Y' : 'N');\n\tseq_printf(m, \"   %d/%d/%c/%c/%s %08x %u\\n\",\n\t\t   session->mtu, session->mru,\n\t\t   session->recv_seq ? 'R' : '-',\n\t\t   session->send_seq ? 'S' : '-',\n\t\t   session->lns_mode ? \"LNS\" : \"LAC\",\n\t\t   session->debug,\n\t\t   jiffies_to_msecs(session->reorder_timeout));\n\tseq_printf(m, \"   %hu/%hu %ld/%ld/%ld %ld/%ld/%ld\\n\",\n\t\t   session->nr, session->ns,\n\t\t   atomic_long_read(&session->stats.tx_packets),\n\t\t   atomic_long_read(&session->stats.tx_bytes),\n\t\t   atomic_long_read(&session->stats.tx_errors),\n\t\t   atomic_long_read(&session->stats.rx_packets),\n\t\t   atomic_long_read(&session->stats.rx_bytes),\n\t\t   atomic_long_read(&session->stats.rx_errors));\n\n\tif (po)\n\t\tseq_printf(m, \"   interface %s\\n\", ppp_dev_name(&po->chan));\n}\n\nstatic int pppol2tp_seq_show(struct seq_file *m, void *v)\n{\n\tstruct pppol2tp_seq_data *pd = v;\n\n\t/* display header on line 1 */\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(m, \"PPPoL2TP driver info, \" PPPOL2TP_DRV_VERSION \"\\n\");\n\t\tseq_puts(m, \"TUNNEL name, user-data-ok session-count\\n\");\n\t\tseq_puts(m, \" debug tx-pkts/bytes/errs rx-pkts/bytes/errs\\n\");\n\t\tseq_puts(m, \"  SESSION name, addr/port src-tid/sid \"\n\t\t\t \"dest-tid/sid state user-data-ok\\n\");\n\t\tseq_puts(m, \"   mtu/mru/rcvseq/sendseq/lns debug reorderto\\n\");\n\t\tseq_puts(m, \"   nr/ns tx-pkts/bytes/errs rx-pkts/bytes/errs\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Show the tunnel or session context.\n\t */\n\tif (pd->session == NULL)\n\t\tpppol2tp_seq_tunnel_show(m, pd->tunnel);\n\telse\n\t\tpppol2tp_seq_session_show(m, pd->session);\n\nout:\n\treturn 0;\n}\n\nstatic const struct seq_operations pppol2tp_seq_ops = {\n\t.start\t\t= pppol2tp_seq_start,\n\t.next\t\t= pppol2tp_seq_next,\n\t.stop\t\t= pppol2tp_seq_stop,\n\t.show\t\t= pppol2tp_seq_show,\n};\n\n/* Called when our /proc file is opened. We allocate data for use when\n * iterating our tunnel / session contexts and store it in the private\n * data of the seq_file.\n */\nstatic int pppol2tp_proc_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open_net(inode, file, &pppol2tp_seq_ops,\n\t\t\t    sizeof(struct pppol2tp_seq_data));\n}\n\nstatic const struct file_operations pppol2tp_proc_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= pppol2tp_proc_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release_net,\n};\n\n#endif /* CONFIG_PROC_FS */\n\n/*****************************************************************************\n * Network namespace\n *****************************************************************************/\n\nstatic __net_init int pppol2tp_init_net(struct net *net)\n{\n\tstruct proc_dir_entry *pde;\n\tint err = 0;\n\n\tpde = proc_create(\"pppol2tp\", S_IRUGO, net->proc_net,\n\t\t\t  &pppol2tp_proc_fops);\n\tif (!pde) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\nout:\n\treturn err;\n}\n\nstatic __net_exit void pppol2tp_exit_net(struct net *net)\n{\n\tremove_proc_entry(\"pppol2tp\", net->proc_net);\n}\n\nstatic struct pernet_operations pppol2tp_net_ops = {\n\t.init = pppol2tp_init_net,\n\t.exit = pppol2tp_exit_net,\n\t.id   = &pppol2tp_net_id,\n};\n\n/*****************************************************************************\n * Init and cleanup\n *****************************************************************************/\n\nstatic const struct proto_ops pppol2tp_ops = {\n\t.family\t\t= AF_PPPOX,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= pppol2tp_release,\n\t.bind\t\t= sock_no_bind,\n\t.connect\t= pppol2tp_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= sock_no_accept,\n\t.getname\t= pppol2tp_getname,\n\t.poll\t\t= datagram_poll,\n\t.listen\t\t= sock_no_listen,\n\t.shutdown\t= sock_no_shutdown,\n\t.setsockopt\t= pppol2tp_setsockopt,\n\t.getsockopt\t= pppol2tp_getsockopt,\n\t.sendmsg\t= pppol2tp_sendmsg,\n\t.recvmsg\t= pppol2tp_recvmsg,\n\t.mmap\t\t= sock_no_mmap,\n\t.ioctl\t\t= pppox_ioctl,\n};\n\nstatic const struct pppox_proto pppol2tp_proto = {\n\t.create\t\t= pppol2tp_create,\n\t.ioctl\t\t= pppol2tp_ioctl,\n\t.owner\t\t= THIS_MODULE,\n};\n\n#ifdef CONFIG_L2TP_V3\n\nstatic const struct l2tp_nl_cmd_ops pppol2tp_nl_cmd_ops = {\n\t.session_create\t= pppol2tp_session_create,\n\t.session_delete\t= l2tp_session_delete,\n};\n\n#endif /* CONFIG_L2TP_V3 */\n\nstatic int __init pppol2tp_init(void)\n{\n\tint err;\n\n\terr = register_pernet_device(&pppol2tp_net_ops);\n\tif (err)\n\t\tgoto out;\n\n\terr = proto_register(&pppol2tp_sk_proto, 0);\n\tif (err)\n\t\tgoto out_unregister_pppol2tp_pernet;\n\n\terr = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);\n\tif (err)\n\t\tgoto out_unregister_pppol2tp_proto;\n\n#ifdef CONFIG_L2TP_V3\n\terr = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);\n\tif (err)\n\t\tgoto out_unregister_pppox;\n#endif\n\n\tpr_info(\"PPPoL2TP kernel driver, %s\\n\", PPPOL2TP_DRV_VERSION);\n\nout:\n\treturn err;\n\n#ifdef CONFIG_L2TP_V3\nout_unregister_pppox:\n\tunregister_pppox_proto(PX_PROTO_OL2TP);\n#endif\nout_unregister_pppol2tp_proto:\n\tproto_unregister(&pppol2tp_sk_proto);\nout_unregister_pppol2tp_pernet:\n\tunregister_pernet_device(&pppol2tp_net_ops);\n\tgoto out;\n}\n\nstatic void __exit pppol2tp_exit(void)\n{\n#ifdef CONFIG_L2TP_V3\n\tl2tp_nl_unregister_ops(L2TP_PWTYPE_PPP);\n#endif\n\tunregister_pppox_proto(PX_PROTO_OL2TP);\n\tproto_unregister(&pppol2tp_sk_proto);\n\tunregister_pernet_device(&pppol2tp_net_ops);\n}\n\nmodule_init(pppol2tp_init);\nmodule_exit(pppol2tp_exit);\n\nMODULE_AUTHOR(\"James Chapman <jchapman@katalix.com>\");\nMODULE_DESCRIPTION(\"PPP over L2TP over UDP\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(PPPOL2TP_DRV_VERSION);\nMODULE_ALIAS(\"pppox-proto-\" __stringify(PX_PROTO_OL2TP));\n"], "fixing_code": ["/*****************************************************************************\n * Linux PPP over L2TP (PPPoX/PPPoL2TP) Sockets\n *\n * PPPoX    --- Generic PPP encapsulation socket family\n * PPPoL2TP --- PPP over L2TP (RFC 2661)\n *\n * Version:\t2.0.0\n *\n * Authors:\tJames Chapman (jchapman@katalix.com)\n *\n * Based on original work by Martijn van Oosterhout <kleptog@svana.org>\n *\n * License:\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n */\n\n/* This driver handles only L2TP data frames; control frames are handled by a\n * userspace application.\n *\n * To send data in an L2TP session, userspace opens a PPPoL2TP socket and\n * attaches it to a bound UDP socket with local tunnel_id / session_id and\n * peer tunnel_id / session_id set. Data can then be sent or received using\n * regular socket sendmsg() / recvmsg() calls. Kernel parameters of the socket\n * can be read or modified using ioctl() or [gs]etsockopt() calls.\n *\n * When a PPPoL2TP socket is connected with local and peer session_id values\n * zero, the socket is treated as a special tunnel management socket.\n *\n * Here's example userspace code to create a socket for sending/receiving data\n * over an L2TP session:-\n *\n *\tstruct sockaddr_pppol2tp sax;\n *\tint fd;\n *\tint session_fd;\n *\n *\tfd = socket(AF_PPPOX, SOCK_DGRAM, PX_PROTO_OL2TP);\n *\n *\tsax.sa_family = AF_PPPOX;\n *\tsax.sa_protocol = PX_PROTO_OL2TP;\n *\tsax.pppol2tp.fd = tunnel_fd;\t// bound UDP socket\n *\tsax.pppol2tp.addr.sin_addr.s_addr = addr->sin_addr.s_addr;\n *\tsax.pppol2tp.addr.sin_port = addr->sin_port;\n *\tsax.pppol2tp.addr.sin_family = AF_INET;\n *\tsax.pppol2tp.s_tunnel  = tunnel_id;\n *\tsax.pppol2tp.s_session = session_id;\n *\tsax.pppol2tp.d_tunnel  = peer_tunnel_id;\n *\tsax.pppol2tp.d_session = peer_session_id;\n *\n *\tsession_fd = connect(fd, (struct sockaddr *)&sax, sizeof(sax));\n *\n * A pppd plugin that allows PPP traffic to be carried over L2TP using\n * this driver is available from the OpenL2TP project at\n * http://openl2tp.sourceforge.net.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jiffies.h>\n\n#include <linux/netdevice.h>\n#include <linux/net.h>\n#include <linux/inetdevice.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/ip.h>\n#include <linux/udp.h>\n#include <linux/if_pppox.h>\n#include <linux/if_pppol2tp.h>\n#include <net/sock.h>\n#include <linux/ppp_channel.h>\n#include <linux/ppp_defs.h>\n#include <linux/ppp-ioctl.h>\n#include <linux/file.h>\n#include <linux/hash.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/l2tp.h>\n#include <linux/nsproxy.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/dst.h>\n#include <net/ip.h>\n#include <net/udp.h>\n#include <net/xfrm.h>\n#include <net/inet_common.h>\n\n#include <asm/byteorder.h>\n#include <linux/atomic.h>\n\n#include \"l2tp_core.h\"\n\n#define PPPOL2TP_DRV_VERSION\t\"V2.0\"\n\n/* Space for UDP, L2TP and PPP headers */\n#define PPPOL2TP_HEADER_OVERHEAD\t40\n\n/* Number of bytes to build transmit L2TP headers.\n * Unfortunately the size is different depending on whether sequence numbers\n * are enabled.\n */\n#define PPPOL2TP_L2TP_HDR_SIZE_SEQ\t\t10\n#define PPPOL2TP_L2TP_HDR_SIZE_NOSEQ\t\t6\n\n/* Private data of each session. This data lives at the end of struct\n * l2tp_session, referenced via session->priv[].\n */\nstruct pppol2tp_session {\n\tint\t\t\towner;\t\t/* pid that opened the socket */\n\n\tstruct sock\t\t*sock;\t\t/* Pointer to the session\n\t\t\t\t\t\t * PPPoX socket */\n\tstruct sock\t\t*tunnel_sock;\t/* Pointer to the tunnel UDP\n\t\t\t\t\t\t * socket */\n\tint\t\t\tflags;\t\t/* accessed by PPPIOCGFLAGS.\n\t\t\t\t\t\t * Unused. */\n};\n\nstatic int pppol2tp_xmit(struct ppp_channel *chan, struct sk_buff *skb);\n\nstatic const struct ppp_channel_ops pppol2tp_chan_ops = {\n\t.start_xmit =  pppol2tp_xmit,\n};\n\nstatic const struct proto_ops pppol2tp_ops;\n\n/* Helpers to obtain tunnel/session contexts from sockets.\n */\nstatic inline struct l2tp_session *pppol2tp_sock_to_session(struct sock *sk)\n{\n\tstruct l2tp_session *session;\n\n\tif (sk == NULL)\n\t\treturn NULL;\n\n\tsock_hold(sk);\n\tsession = (struct l2tp_session *)(sk->sk_user_data);\n\tif (session == NULL) {\n\t\tsock_put(sk);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(session->magic != L2TP_SESSION_MAGIC);\n\nout:\n\treturn session;\n}\n\n/*****************************************************************************\n * Receive data handling\n *****************************************************************************/\n\nstatic int pppol2tp_recv_payload_hook(struct sk_buff *skb)\n{\n\t/* Skip PPP header, if present.\t In testing, Microsoft L2TP clients\n\t * don't send the PPP header (PPP header compression enabled), but\n\t * other clients can include the header. So we cope with both cases\n\t * here. The PPP header is always FF03 when using L2TP.\n\t *\n\t * Note that skb->data[] isn't dereferenced from a u16 ptr here since\n\t * the field may be unaligned.\n\t */\n\tif (!pskb_may_pull(skb, 2))\n\t\treturn 1;\n\n\tif ((skb->data[0] == 0xff) && (skb->data[1] == 0x03))\n\t\tskb_pull(skb, 2);\n\n\treturn 0;\n}\n\n/* Receive message. This is the recvmsg for the PPPoL2TP socket.\n */\nstatic int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len,\n\t\t\t    int flags)\n{\n\tint err;\n\tstruct sk_buff *skb;\n\tstruct sock *sk = sock->sk;\n\n\terr = -EIO;\n\tif (sk->sk_state & PPPOX_BOUND)\n\t\tgoto end;\n\n\terr = 0;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto end;\n\n\tif (len > skb->len)\n\t\tlen = skb->len;\n\telse if (len < skb->len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);\n\tif (likely(err == 0))\n\t\terr = len;\n\n\tkfree_skb(skb);\nend:\n\treturn err;\n}\n\nstatic void pppol2tp_recv(struct l2tp_session *session, struct sk_buff *skb, int data_len)\n{\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\tstruct sock *sk = NULL;\n\n\t/* If the socket is bound, send it in to PPP's input queue. Otherwise\n\t * queue it on the session socket.\n\t */\n\tsk = ps->sock;\n\tif (sk == NULL)\n\t\tgoto no_sock;\n\n\tif (sk->sk_state & PPPOX_BOUND) {\n\t\tstruct pppox_sock *po;\n\t\tl2tp_dbg(session, PPPOL2TP_MSG_DATA,\n\t\t\t \"%s: recv %d byte data frame, passing to ppp\\n\",\n\t\t\t session->name, data_len);\n\n\t\t/* We need to forget all info related to the L2TP packet\n\t\t * gathered in the skb as we are going to reuse the same\n\t\t * skb for the inner packet.\n\t\t * Namely we need to:\n\t\t * - reset xfrm (IPSec) information as it applies to\n\t\t *   the outer L2TP packet and not to the inner one\n\t\t * - release the dst to force a route lookup on the inner\n\t\t *   IP packet since skb->dst currently points to the dst\n\t\t *   of the UDP tunnel\n\t\t * - reset netfilter information as it doesn't apply\n\t\t *   to the inner packet either\n\t\t */\n\t\tsecpath_reset(skb);\n\t\tskb_dst_drop(skb);\n\t\tnf_reset(skb);\n\n\t\tpo = pppox_sk(sk);\n\t\tppp_input(&po->chan, skb);\n\t} else {\n\t\tl2tp_dbg(session, PPPOL2TP_MSG_DATA,\n\t\t\t \"%s: recv %d byte data frame, passing to L2TP socket\\n\",\n\t\t\t session->name, data_len);\n\n\t\tif (sock_queue_rcv_skb(sk, skb) < 0) {\n\t\t\tatomic_long_inc(&session->stats.rx_errors);\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\n\treturn;\n\nno_sock:\n\tl2tp_info(session, PPPOL2TP_MSG_DATA, \"%s: no socket\\n\", session->name);\n\tkfree_skb(skb);\n}\n\nstatic void pppol2tp_session_sock_hold(struct l2tp_session *session)\n{\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\n\tif (ps->sock)\n\t\tsock_hold(ps->sock);\n}\n\nstatic void pppol2tp_session_sock_put(struct l2tp_session *session)\n{\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\n\tif (ps->sock)\n\t\tsock_put(ps->sock);\n}\n\n/************************************************************************\n * Transmit handling\n ***********************************************************************/\n\n/* This is the sendmsg for the PPPoL2TP pppol2tp_session socket.  We come here\n * when a user application does a sendmsg() on the session socket. L2TP and\n * PPP headers must be inserted into the user's data.\n */\nstatic int pppol2tp_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,\n\t\t\t    size_t total_len)\n{\n\tstatic const unsigned char ppph[2] = { 0xff, 0x03 };\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint error;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct pppol2tp_session *ps;\n\tint uhlen;\n\n\terror = -ENOTCONN;\n\tif (sock_flag(sk, SOCK_DEAD) || !(sk->sk_state & PPPOX_CONNECTED))\n\t\tgoto error;\n\n\t/* Get session and tunnel contexts */\n\terror = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto error;\n\n\tps = l2tp_session_priv(session);\n\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\tif (tunnel == NULL)\n\t\tgoto error_put_sess;\n\n\tuhlen = (tunnel->encap == L2TP_ENCAPTYPE_UDP) ? sizeof(struct udphdr) : 0;\n\n\t/* Allocate a socket buffer */\n\terror = -ENOMEM;\n\tskb = sock_wmalloc(sk, NET_SKB_PAD + sizeof(struct iphdr) +\n\t\t\t   uhlen + session->hdr_len +\n\t\t\t   sizeof(ppph) + total_len,\n\t\t\t   0, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto error_put_sess_tun;\n\n\t/* Reserve space for headers. */\n\tskb_reserve(skb, NET_SKB_PAD);\n\tskb_reset_network_header(skb);\n\tskb_reserve(skb, sizeof(struct iphdr));\n\tskb_reset_transport_header(skb);\n\tskb_reserve(skb, uhlen);\n\n\t/* Add PPP header */\n\tskb->data[0] = ppph[0];\n\tskb->data[1] = ppph[1];\n\tskb_put(skb, 2);\n\n\t/* Copy user data into skb */\n\terror = memcpy_fromiovec(skb_put(skb, total_len), m->msg_iov,\n\t\t\t\t total_len);\n\tif (error < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto error_put_sess_tun;\n\t}\n\n\tlocal_bh_disable();\n\tl2tp_xmit_skb(session, skb, session->hdr_len);\n\tlocal_bh_enable();\n\n\tsock_put(ps->tunnel_sock);\n\tsock_put(sk);\n\n\treturn total_len;\n\nerror_put_sess_tun:\n\tsock_put(ps->tunnel_sock);\nerror_put_sess:\n\tsock_put(sk);\nerror:\n\treturn error;\n}\n\n/* Transmit function called by generic PPP driver.  Sends PPP frame\n * over PPPoL2TP socket.\n *\n * This is almost the same as pppol2tp_sendmsg(), but rather than\n * being called with a msghdr from userspace, it is called with a skb\n * from the kernel.\n *\n * The supplied skb from ppp doesn't have enough headroom for the\n * insertion of L2TP, UDP and IP headers so we need to allocate more\n * headroom in the skb. This will create a cloned skb. But we must be\n * careful in the error case because the caller will expect to free\n * the skb it supplied, not our cloned skb. So we take care to always\n * leave the original skb unfreed if we return an error.\n */\nstatic int pppol2tp_xmit(struct ppp_channel *chan, struct sk_buff *skb)\n{\n\tstatic const u8 ppph[2] = { 0xff, 0x03 };\n\tstruct sock *sk = (struct sock *) chan->private;\n\tstruct sock *sk_tun;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct pppol2tp_session *ps;\n\tint uhlen, headroom;\n\n\tif (sock_flag(sk, SOCK_DEAD) || !(sk->sk_state & PPPOX_CONNECTED))\n\t\tgoto abort;\n\n\t/* Get session and tunnel contexts from the socket */\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto abort;\n\n\tps = l2tp_session_priv(session);\n\tsk_tun = ps->tunnel_sock;\n\tif (sk_tun == NULL)\n\t\tgoto abort_put_sess;\n\ttunnel = l2tp_sock_to_tunnel(sk_tun);\n\tif (tunnel == NULL)\n\t\tgoto abort_put_sess;\n\n\tuhlen = (tunnel->encap == L2TP_ENCAPTYPE_UDP) ? sizeof(struct udphdr) : 0;\n\theadroom = NET_SKB_PAD +\n\t\t   sizeof(struct iphdr) + /* IP header */\n\t\t   uhlen +\t\t/* UDP header (if L2TP_ENCAPTYPE_UDP) */\n\t\t   session->hdr_len +\t/* L2TP header */\n\t\t   sizeof(ppph);\t/* PPP header */\n\tif (skb_cow_head(skb, headroom))\n\t\tgoto abort_put_sess_tun;\n\n\t/* Setup PPP header */\n\t__skb_push(skb, sizeof(ppph));\n\tskb->data[0] = ppph[0];\n\tskb->data[1] = ppph[1];\n\n\tlocal_bh_disable();\n\tl2tp_xmit_skb(session, skb, session->hdr_len);\n\tlocal_bh_enable();\n\n\tsock_put(sk_tun);\n\tsock_put(sk);\n\treturn 1;\n\nabort_put_sess_tun:\n\tsock_put(sk_tun);\nabort_put_sess:\n\tsock_put(sk);\nabort:\n\t/* Free the original skb */\n\tkfree_skb(skb);\n\treturn 1;\n}\n\n/*****************************************************************************\n * Session (and tunnel control) socket create/destroy.\n *****************************************************************************/\n\n/* Called by l2tp_core when a session socket is being closed.\n */\nstatic void pppol2tp_session_close(struct l2tp_session *session)\n{\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\tstruct sock *sk = ps->sock;\n\tstruct socket *sock = sk->sk_socket;\n\n\tBUG_ON(session->magic != L2TP_SESSION_MAGIC);\n\n\tif (sock) {\n\t\tinet_shutdown(sock, 2);\n\t\t/* Don't let the session go away before our socket does */\n\t\tl2tp_session_inc_refcount(session);\n\t}\n}\n\n/* Really kill the session socket. (Called from sock_put() if\n * refcnt == 0.)\n */\nstatic void pppol2tp_session_destruct(struct sock *sk)\n{\n\tstruct l2tp_session *session = sk->sk_user_data;\n\tif (session) {\n\t\tsk->sk_user_data = NULL;\n\t\tBUG_ON(session->magic != L2TP_SESSION_MAGIC);\n\t\tl2tp_session_dec_refcount(session);\n\t}\n}\n\n/* Called when the PPPoX socket (session) is closed.\n */\nstatic int pppol2tp_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tint error;\n\n\tif (!sk)\n\t\treturn 0;\n\n\terror = -EBADF;\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_DEAD) != 0)\n\t\tgoto error;\n\n\tpppox_unbind_sock(sk);\n\n\t/* Signal the death of the socket. */\n\tsk->sk_state = PPPOX_DEAD;\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\n\tsession = pppol2tp_sock_to_session(sk);\n\n\t/* Purge any queued data */\n\tif (session != NULL) {\n\t\t__l2tp_session_unhash(session);\n\t\tl2tp_session_queue_purge(session);\n\t\tsock_put(sk);\n\t}\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n\n\trelease_sock(sk);\n\n\t/* This will delete the session context via\n\t * pppol2tp_session_destruct() if the socket's refcnt drops to\n\t * zero.\n\t */\n\tsock_put(sk);\n\n\treturn 0;\n\nerror:\n\trelease_sock(sk);\n\treturn error;\n}\n\nstatic struct proto pppol2tp_sk_proto = {\n\t.name\t  = \"PPPOL2TP\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct pppox_sock),\n};\n\nstatic int pppol2tp_backlog_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\n\trc = l2tp_udp_encap_recv(sk, skb);\n\tif (rc)\n\t\tkfree_skb(skb);\n\n\treturn NET_RX_SUCCESS;\n}\n\n/* socket() handler. Initialize a new struct sock.\n */\nstatic int pppol2tp_create(struct net *net, struct socket *sock)\n{\n\tint error = -ENOMEM;\n\tstruct sock *sk;\n\n\tsk = sk_alloc(net, PF_PPPOX, GFP_KERNEL, &pppol2tp_sk_proto);\n\tif (!sk)\n\t\tgoto out;\n\n\tsock_init_data(sock, sk);\n\n\tsock->state  = SS_UNCONNECTED;\n\tsock->ops    = &pppol2tp_ops;\n\n\tsk->sk_backlog_rcv = pppol2tp_backlog_recv;\n\tsk->sk_protocol\t   = PX_PROTO_OL2TP;\n\tsk->sk_family\t   = PF_PPPOX;\n\tsk->sk_state\t   = PPPOX_NONE;\n\tsk->sk_type\t   = SOCK_STREAM;\n\tsk->sk_destruct\t   = pppol2tp_session_destruct;\n\n\terror = 0;\n\nout:\n\treturn error;\n}\n\n#if defined(CONFIG_L2TP_DEBUGFS) || defined(CONFIG_L2TP_DEBUGFS_MODULE)\nstatic void pppol2tp_show(struct seq_file *m, void *arg)\n{\n\tstruct l2tp_session *session = arg;\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\n\tif (ps) {\n\t\tstruct pppox_sock *po = pppox_sk(ps->sock);\n\t\tif (po)\n\t\t\tseq_printf(m, \"   interface %s\\n\", ppp_dev_name(&po->chan));\n\t}\n}\n#endif\n\n/* connect() handler. Attach a PPPoX socket to a tunnel UDP socket\n */\nstatic int pppol2tp_connect(struct socket *sock, struct sockaddr *uservaddr,\n\t\t\t    int sockaddr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_pppol2tp *sp = (struct sockaddr_pppol2tp *) uservaddr;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct l2tp_session *session = NULL;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct pppol2tp_session *ps;\n\tstruct dst_entry *dst;\n\tstruct l2tp_session_cfg cfg = { 0, };\n\tint error = 0;\n\tu32 tunnel_id, peer_tunnel_id;\n\tu32 session_id, peer_session_id;\n\tint ver = 2;\n\tint fd;\n\n\tlock_sock(sk);\n\n\terror = -EINVAL;\n\tif (sp->sa_protocol != PX_PROTO_OL2TP)\n\t\tgoto end;\n\n\t/* Check for already bound sockets */\n\terror = -EBUSY;\n\tif (sk->sk_state & PPPOX_CONNECTED)\n\t\tgoto end;\n\n\t/* We don't supporting rebinding anyway */\n\terror = -EALREADY;\n\tif (sk->sk_user_data)\n\t\tgoto end; /* socket is already attached */\n\n\t/* Get params from socket address. Handle L2TPv2 and L2TPv3.\n\t * This is nasty because there are different sockaddr_pppol2tp\n\t * structs for L2TPv2, L2TPv3, over IPv4 and IPv6. We use\n\t * the sockaddr size to determine which structure the caller\n\t * is using.\n\t */\n\tpeer_tunnel_id = 0;\n\tif (sockaddr_len == sizeof(struct sockaddr_pppol2tp)) {\n\t\tfd = sp->pppol2tp.fd;\n\t\ttunnel_id = sp->pppol2tp.s_tunnel;\n\t\tpeer_tunnel_id = sp->pppol2tp.d_tunnel;\n\t\tsession_id = sp->pppol2tp.s_session;\n\t\tpeer_session_id = sp->pppol2tp.d_session;\n\t} else if (sockaddr_len == sizeof(struct sockaddr_pppol2tpv3)) {\n\t\tstruct sockaddr_pppol2tpv3 *sp3 =\n\t\t\t(struct sockaddr_pppol2tpv3 *) sp;\n\t\tver = 3;\n\t\tfd = sp3->pppol2tp.fd;\n\t\ttunnel_id = sp3->pppol2tp.s_tunnel;\n\t\tpeer_tunnel_id = sp3->pppol2tp.d_tunnel;\n\t\tsession_id = sp3->pppol2tp.s_session;\n\t\tpeer_session_id = sp3->pppol2tp.d_session;\n\t} else if (sockaddr_len == sizeof(struct sockaddr_pppol2tpin6)) {\n\t\tstruct sockaddr_pppol2tpin6 *sp6 =\n\t\t\t(struct sockaddr_pppol2tpin6 *) sp;\n\t\tfd = sp6->pppol2tp.fd;\n\t\ttunnel_id = sp6->pppol2tp.s_tunnel;\n\t\tpeer_tunnel_id = sp6->pppol2tp.d_tunnel;\n\t\tsession_id = sp6->pppol2tp.s_session;\n\t\tpeer_session_id = sp6->pppol2tp.d_session;\n\t} else if (sockaddr_len == sizeof(struct sockaddr_pppol2tpv3in6)) {\n\t\tstruct sockaddr_pppol2tpv3in6 *sp6 =\n\t\t\t(struct sockaddr_pppol2tpv3in6 *) sp;\n\t\tver = 3;\n\t\tfd = sp6->pppol2tp.fd;\n\t\ttunnel_id = sp6->pppol2tp.s_tunnel;\n\t\tpeer_tunnel_id = sp6->pppol2tp.d_tunnel;\n\t\tsession_id = sp6->pppol2tp.s_session;\n\t\tpeer_session_id = sp6->pppol2tp.d_session;\n\t} else {\n\t\terror = -EINVAL;\n\t\tgoto end; /* bad socket address */\n\t}\n\n\t/* Don't bind if tunnel_id is 0 */\n\terror = -EINVAL;\n\tif (tunnel_id == 0)\n\t\tgoto end;\n\n\ttunnel = l2tp_tunnel_find(sock_net(sk), tunnel_id);\n\n\t/* Special case: create tunnel context if session_id and\n\t * peer_session_id is 0. Otherwise look up tunnel using supplied\n\t * tunnel id.\n\t */\n\tif ((session_id == 0) && (peer_session_id == 0)) {\n\t\tif (tunnel == NULL) {\n\t\t\tstruct l2tp_tunnel_cfg tcfg = {\n\t\t\t\t.encap = L2TP_ENCAPTYPE_UDP,\n\t\t\t\t.debug = 0,\n\t\t\t};\n\t\t\terror = l2tp_tunnel_create(sock_net(sk), fd, ver, tunnel_id, peer_tunnel_id, &tcfg, &tunnel);\n\t\t\tif (error < 0)\n\t\t\t\tgoto end;\n\t\t}\n\t} else {\n\t\t/* Error if we can't find the tunnel */\n\t\terror = -ENOENT;\n\t\tif (tunnel == NULL)\n\t\t\tgoto end;\n\n\t\t/* Error if socket is not prepped */\n\t\tif (tunnel->sock == NULL)\n\t\t\tgoto end;\n\t}\n\n\tif (tunnel->recv_payload_hook == NULL)\n\t\ttunnel->recv_payload_hook = pppol2tp_recv_payload_hook;\n\n\tif (tunnel->peer_tunnel_id == 0)\n\t\ttunnel->peer_tunnel_id = peer_tunnel_id;\n\n\t/* Create session if it doesn't already exist. We handle the\n\t * case where a session was previously created by the netlink\n\t * interface by checking that the session doesn't already have\n\t * a socket and its tunnel socket are what we expect. If any\n\t * of those checks fail, return EEXIST to the caller.\n\t */\n\tsession = l2tp_session_find(sock_net(sk), tunnel, session_id);\n\tif (session == NULL) {\n\t\t/* Default MTU must allow space for UDP/L2TP/PPP\n\t\t * headers.\n\t\t */\n\t\tcfg.mtu = cfg.mru = 1500 - PPPOL2TP_HEADER_OVERHEAD;\n\n\t\t/* Allocate and initialize a new session context. */\n\t\tsession = l2tp_session_create(sizeof(struct pppol2tp_session),\n\t\t\t\t\t      tunnel, session_id,\n\t\t\t\t\t      peer_session_id, &cfg);\n\t\tif (session == NULL) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto end;\n\t\t}\n\t} else {\n\t\tps = l2tp_session_priv(session);\n\t\terror = -EEXIST;\n\t\tif (ps->sock != NULL)\n\t\t\tgoto end;\n\n\t\t/* consistency checks */\n\t\tif (ps->tunnel_sock != tunnel->sock)\n\t\t\tgoto end;\n\t}\n\n\t/* Associate session with its PPPoL2TP socket */\n\tps = l2tp_session_priv(session);\n\tps->owner\t     = current->pid;\n\tps->sock\t     = sk;\n\tps->tunnel_sock = tunnel->sock;\n\n\tsession->recv_skb\t= pppol2tp_recv;\n\tsession->session_close\t= pppol2tp_session_close;\n#if defined(CONFIG_L2TP_DEBUGFS) || defined(CONFIG_L2TP_DEBUGFS_MODULE)\n\tsession->show\t\t= pppol2tp_show;\n#endif\n\n\t/* We need to know each time a skb is dropped from the reorder\n\t * queue.\n\t */\n\tsession->ref = pppol2tp_session_sock_hold;\n\tsession->deref = pppol2tp_session_sock_put;\n\n\t/* If PMTU discovery was enabled, use the MTU that was discovered */\n\tdst = sk_dst_get(tunnel->sock);\n\tif (dst != NULL) {\n\t\tu32 pmtu = dst_mtu(__sk_dst_get(tunnel->sock));\n\t\tif (pmtu != 0)\n\t\t\tsession->mtu = session->mru = pmtu -\n\t\t\t\tPPPOL2TP_HEADER_OVERHEAD;\n\t\tdst_release(dst);\n\t}\n\n\t/* Special case: if source & dest session_id == 0x0000, this\n\t * socket is being created to manage the tunnel. Just set up\n\t * the internal context for use by ioctl() and sockopt()\n\t * handlers.\n\t */\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terror = 0;\n\t\tgoto out_no_ppp;\n\t}\n\n\t/* The only header we need to worry about is the L2TP\n\t * header. This size is different depending on whether\n\t * sequence numbers are enabled for the data channel.\n\t */\n\tpo->chan.hdrlen = PPPOL2TP_L2TP_HDR_SIZE_NOSEQ;\n\n\tpo->chan.private = sk;\n\tpo->chan.ops\t = &pppol2tp_chan_ops;\n\tpo->chan.mtu\t = session->mtu;\n\n\terror = ppp_register_net_channel(sock_net(sk), &po->chan);\n\tif (error)\n\t\tgoto end;\n\nout_no_ppp:\n\t/* This is how we get the session context from the socket. */\n\tsk->sk_user_data = session;\n\tsk->sk_state = PPPOX_CONNECTED;\n\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: created\\n\",\n\t\t  session->name);\n\nend:\n\trelease_sock(sk);\n\n\treturn error;\n}\n\n#ifdef CONFIG_L2TP_V3\n\n/* Called when creating sessions via the netlink interface.\n */\nstatic int pppol2tp_session_create(struct net *net, u32 tunnel_id, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg)\n{\n\tint error;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct l2tp_session *session;\n\tstruct pppol2tp_session *ps;\n\n\ttunnel = l2tp_tunnel_find(net, tunnel_id);\n\n\t/* Error if we can't find the tunnel */\n\terror = -ENOENT;\n\tif (tunnel == NULL)\n\t\tgoto out;\n\n\t/* Error if tunnel socket is not prepped */\n\tif (tunnel->sock == NULL)\n\t\tgoto out;\n\n\t/* Check that this session doesn't already exist */\n\terror = -EEXIST;\n\tsession = l2tp_session_find(net, tunnel, session_id);\n\tif (session != NULL)\n\t\tgoto out;\n\n\t/* Default MTU values. */\n\tif (cfg->mtu == 0)\n\t\tcfg->mtu = 1500 - PPPOL2TP_HEADER_OVERHEAD;\n\tif (cfg->mru == 0)\n\t\tcfg->mru = cfg->mtu;\n\n\t/* Allocate and initialize a new session context. */\n\terror = -ENOMEM;\n\tsession = l2tp_session_create(sizeof(struct pppol2tp_session),\n\t\t\t\t      tunnel, session_id,\n\t\t\t\t      peer_session_id, cfg);\n\tif (session == NULL)\n\t\tgoto out;\n\n\tps = l2tp_session_priv(session);\n\tps->tunnel_sock = tunnel->sock;\n\n\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: created\\n\",\n\t\t  session->name);\n\n\terror = 0;\n\nout:\n\treturn error;\n}\n\n#endif /* CONFIG_L2TP_V3 */\n\n/* getname() support.\n */\nstatic int pppol2tp_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t    int *usockaddr_len, int peer)\n{\n\tint len = 0;\n\tint error = 0;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct sock *sk = sock->sk;\n\tstruct inet_sock *inet;\n\tstruct pppol2tp_session *pls;\n\n\terror = -ENOTCONN;\n\tif (sk == NULL)\n\t\tgoto end;\n\tif (sk->sk_state != PPPOX_CONNECTED)\n\t\tgoto end;\n\n\terror = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\n\tpls = l2tp_session_priv(session);\n\ttunnel = l2tp_sock_to_tunnel(pls->tunnel_sock);\n\tif (tunnel == NULL) {\n\t\terror = -EBADF;\n\t\tgoto end_put_sess;\n\t}\n\n\tinet = inet_sk(tunnel->sock);\n\tif ((tunnel->version == 2) && (tunnel->sock->sk_family == AF_INET)) {\n\t\tstruct sockaddr_pppol2tp sp;\n\t\tlen = sizeof(sp);\n\t\tmemset(&sp, 0, len);\n\t\tsp.sa_family\t= AF_PPPOX;\n\t\tsp.sa_protocol\t= PX_PROTO_OL2TP;\n\t\tsp.pppol2tp.fd  = tunnel->fd;\n\t\tsp.pppol2tp.pid = pls->owner;\n\t\tsp.pppol2tp.s_tunnel = tunnel->tunnel_id;\n\t\tsp.pppol2tp.d_tunnel = tunnel->peer_tunnel_id;\n\t\tsp.pppol2tp.s_session = session->session_id;\n\t\tsp.pppol2tp.d_session = session->peer_session_id;\n\t\tsp.pppol2tp.addr.sin_family = AF_INET;\n\t\tsp.pppol2tp.addr.sin_port = inet->inet_dport;\n\t\tsp.pppol2tp.addr.sin_addr.s_addr = inet->inet_daddr;\n\t\tmemcpy(uaddr, &sp, len);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if ((tunnel->version == 2) &&\n\t\t   (tunnel->sock->sk_family == AF_INET6)) {\n\t\tstruct sockaddr_pppol2tpin6 sp;\n\n\t\tlen = sizeof(sp);\n\t\tmemset(&sp, 0, len);\n\t\tsp.sa_family\t= AF_PPPOX;\n\t\tsp.sa_protocol\t= PX_PROTO_OL2TP;\n\t\tsp.pppol2tp.fd  = tunnel->fd;\n\t\tsp.pppol2tp.pid = pls->owner;\n\t\tsp.pppol2tp.s_tunnel = tunnel->tunnel_id;\n\t\tsp.pppol2tp.d_tunnel = tunnel->peer_tunnel_id;\n\t\tsp.pppol2tp.s_session = session->session_id;\n\t\tsp.pppol2tp.d_session = session->peer_session_id;\n\t\tsp.pppol2tp.addr.sin6_family = AF_INET6;\n\t\tsp.pppol2tp.addr.sin6_port = inet->inet_dport;\n\t\tmemcpy(&sp.pppol2tp.addr.sin6_addr, &tunnel->sock->sk_v6_daddr,\n\t\t       sizeof(tunnel->sock->sk_v6_daddr));\n\t\tmemcpy(uaddr, &sp, len);\n\t} else if ((tunnel->version == 3) &&\n\t\t   (tunnel->sock->sk_family == AF_INET6)) {\n\t\tstruct sockaddr_pppol2tpv3in6 sp;\n\n\t\tlen = sizeof(sp);\n\t\tmemset(&sp, 0, len);\n\t\tsp.sa_family\t= AF_PPPOX;\n\t\tsp.sa_protocol\t= PX_PROTO_OL2TP;\n\t\tsp.pppol2tp.fd  = tunnel->fd;\n\t\tsp.pppol2tp.pid = pls->owner;\n\t\tsp.pppol2tp.s_tunnel = tunnel->tunnel_id;\n\t\tsp.pppol2tp.d_tunnel = tunnel->peer_tunnel_id;\n\t\tsp.pppol2tp.s_session = session->session_id;\n\t\tsp.pppol2tp.d_session = session->peer_session_id;\n\t\tsp.pppol2tp.addr.sin6_family = AF_INET6;\n\t\tsp.pppol2tp.addr.sin6_port = inet->inet_dport;\n\t\tmemcpy(&sp.pppol2tp.addr.sin6_addr, &tunnel->sock->sk_v6_daddr,\n\t\t       sizeof(tunnel->sock->sk_v6_daddr));\n\t\tmemcpy(uaddr, &sp, len);\n#endif\n\t} else if (tunnel->version == 3) {\n\t\tstruct sockaddr_pppol2tpv3 sp;\n\t\tlen = sizeof(sp);\n\t\tmemset(&sp, 0, len);\n\t\tsp.sa_family\t= AF_PPPOX;\n\t\tsp.sa_protocol\t= PX_PROTO_OL2TP;\n\t\tsp.pppol2tp.fd  = tunnel->fd;\n\t\tsp.pppol2tp.pid = pls->owner;\n\t\tsp.pppol2tp.s_tunnel = tunnel->tunnel_id;\n\t\tsp.pppol2tp.d_tunnel = tunnel->peer_tunnel_id;\n\t\tsp.pppol2tp.s_session = session->session_id;\n\t\tsp.pppol2tp.d_session = session->peer_session_id;\n\t\tsp.pppol2tp.addr.sin_family = AF_INET;\n\t\tsp.pppol2tp.addr.sin_port = inet->inet_dport;\n\t\tsp.pppol2tp.addr.sin_addr.s_addr = inet->inet_daddr;\n\t\tmemcpy(uaddr, &sp, len);\n\t}\n\n\t*usockaddr_len = len;\n\n\tsock_put(pls->tunnel_sock);\nend_put_sess:\n\tsock_put(sk);\n\terror = 0;\n\nend:\n\treturn error;\n}\n\n/****************************************************************************\n * ioctl() handlers.\n *\n * The PPPoX socket is created for L2TP sessions: tunnels have their own UDP\n * sockets. However, in order to control kernel tunnel features, we allow\n * userspace to create a special \"tunnel\" PPPoX socket which is used for\n * control only.  Tunnel PPPoX sockets have session_id == 0 and simply allow\n * the user application to issue L2TP setsockopt(), getsockopt() and ioctl()\n * calls.\n ****************************************************************************/\n\nstatic void pppol2tp_copy_stats(struct pppol2tp_ioc_stats *dest,\n\t\t\t\tstruct l2tp_stats *stats)\n{\n\tdest->tx_packets = atomic_long_read(&stats->tx_packets);\n\tdest->tx_bytes = atomic_long_read(&stats->tx_bytes);\n\tdest->tx_errors = atomic_long_read(&stats->tx_errors);\n\tdest->rx_packets = atomic_long_read(&stats->rx_packets);\n\tdest->rx_bytes = atomic_long_read(&stats->rx_bytes);\n\tdest->rx_seq_discards = atomic_long_read(&stats->rx_seq_discards);\n\tdest->rx_oos_packets = atomic_long_read(&stats->rx_oos_packets);\n\tdest->rx_errors = atomic_long_read(&stats->rx_errors);\n}\n\n/* Session ioctl helper.\n */\nstatic int pppol2tp_session_ioctl(struct l2tp_session *session,\n\t\t\t\t  unsigned int cmd, unsigned long arg)\n{\n\tstruct ifreq ifr;\n\tint err = 0;\n\tstruct sock *sk;\n\tint val = (int) arg;\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\tstruct l2tp_tunnel *tunnel = session->tunnel;\n\tstruct pppol2tp_ioc_stats stats;\n\n\tl2tp_dbg(session, PPPOL2TP_MSG_CONTROL,\n\t\t \"%s: pppol2tp_session_ioctl(cmd=%#x, arg=%#lx)\\n\",\n\t\t session->name, cmd, arg);\n\n\tsk = ps->sock;\n\tsock_hold(sk);\n\n\tswitch (cmd) {\n\tcase SIOCGIFMTU:\n\t\terr = -ENXIO;\n\t\tif (!(sk->sk_state & PPPOX_CONNECTED))\n\t\t\tbreak;\n\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&ifr, (void __user *) arg, sizeof(struct ifreq)))\n\t\t\tbreak;\n\t\tifr.ifr_mtu = session->mtu;\n\t\tif (copy_to_user((void __user *) arg, &ifr, sizeof(struct ifreq)))\n\t\t\tbreak;\n\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: get mtu=%d\\n\",\n\t\t\t  session->name, session->mtu);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase SIOCSIFMTU:\n\t\terr = -ENXIO;\n\t\tif (!(sk->sk_state & PPPOX_CONNECTED))\n\t\t\tbreak;\n\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&ifr, (void __user *) arg, sizeof(struct ifreq)))\n\t\t\tbreak;\n\n\t\tsession->mtu = ifr.ifr_mtu;\n\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: set mtu=%d\\n\",\n\t\t\t  session->name, session->mtu);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGMRU:\n\t\terr = -ENXIO;\n\t\tif (!(sk->sk_state & PPPOX_CONNECTED))\n\t\t\tbreak;\n\n\t\terr = -EFAULT;\n\t\tif (put_user(session->mru, (int __user *) arg))\n\t\t\tbreak;\n\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: get mru=%d\\n\",\n\t\t\t  session->name, session->mru);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCSMRU:\n\t\terr = -ENXIO;\n\t\tif (!(sk->sk_state & PPPOX_CONNECTED))\n\t\t\tbreak;\n\n\t\terr = -EFAULT;\n\t\tif (get_user(val, (int __user *) arg))\n\t\t\tbreak;\n\n\t\tsession->mru = val;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: set mru=%d\\n\",\n\t\t\t  session->name, session->mru);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGFLAGS:\n\t\terr = -EFAULT;\n\t\tif (put_user(ps->flags, (int __user *) arg))\n\t\t\tbreak;\n\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: get flags=%d\\n\",\n\t\t\t  session->name, ps->flags);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCSFLAGS:\n\t\terr = -EFAULT;\n\t\tif (get_user(val, (int __user *) arg))\n\t\t\tbreak;\n\t\tps->flags = val;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: set flags=%d\\n\",\n\t\t\t  session->name, ps->flags);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGL2TPSTATS:\n\t\terr = -ENXIO;\n\t\tif (!(sk->sk_state & PPPOX_CONNECTED))\n\t\t\tbreak;\n\n\t\tmemset(&stats, 0, sizeof(stats));\n\t\tstats.tunnel_id = tunnel->tunnel_id;\n\t\tstats.session_id = session->session_id;\n\t\tpppol2tp_copy_stats(&stats, &session->stats);\n\t\tif (copy_to_user((void __user *) arg, &stats,\n\t\t\t\t sizeof(stats)))\n\t\t\tbreak;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: get L2TP stats\\n\",\n\t\t\t  session->name);\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOSYS;\n\t\tbreak;\n\t}\n\n\tsock_put(sk);\n\n\treturn err;\n}\n\n/* Tunnel ioctl helper.\n *\n * Note the special handling for PPPIOCGL2TPSTATS below. If the ioctl data\n * specifies a session_id, the session ioctl handler is called. This allows an\n * application to retrieve session stats via a tunnel socket.\n */\nstatic int pppol2tp_tunnel_ioctl(struct l2tp_tunnel *tunnel,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tint err = 0;\n\tstruct sock *sk;\n\tstruct pppol2tp_ioc_stats stats;\n\n\tl2tp_dbg(tunnel, PPPOL2TP_MSG_CONTROL,\n\t\t \"%s: pppol2tp_tunnel_ioctl(cmd=%#x, arg=%#lx)\\n\",\n\t\t tunnel->name, cmd, arg);\n\n\tsk = tunnel->sock;\n\tsock_hold(sk);\n\n\tswitch (cmd) {\n\tcase PPPIOCGL2TPSTATS:\n\t\terr = -ENXIO;\n\t\tif (!(sk->sk_state & PPPOX_CONNECTED))\n\t\t\tbreak;\n\n\t\tif (copy_from_user(&stats, (void __user *) arg,\n\t\t\t\t   sizeof(stats))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (stats.session_id != 0) {\n\t\t\t/* resend to session ioctl handler */\n\t\t\tstruct l2tp_session *session =\n\t\t\t\tl2tp_session_find(sock_net(sk), tunnel, stats.session_id);\n\t\t\tif (session != NULL)\n\t\t\t\terr = pppol2tp_session_ioctl(session, cmd, arg);\n\t\t\telse\n\t\t\t\terr = -EBADR;\n\t\t\tbreak;\n\t\t}\n#ifdef CONFIG_XFRM\n\t\tstats.using_ipsec = (sk->sk_policy[0] || sk->sk_policy[1]) ? 1 : 0;\n#endif\n\t\tpppol2tp_copy_stats(&stats, &tunnel->stats);\n\t\tif (copy_to_user((void __user *) arg, &stats, sizeof(stats))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tl2tp_info(tunnel, PPPOL2TP_MSG_CONTROL, \"%s: get L2TP stats\\n\",\n\t\t\t  tunnel->name);\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOSYS;\n\t\tbreak;\n\t}\n\n\tsock_put(sk);\n\n\treturn err;\n}\n\n/* Main ioctl() handler.\n * Dispatch to tunnel or session helpers depending on the socket.\n */\nstatic int pppol2tp_ioctl(struct socket *sock, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct pppol2tp_session *ps;\n\tint err;\n\n\tif (!sk)\n\t\treturn 0;\n\n\terr = -EBADF;\n\tif (sock_flag(sk, SOCK_DEAD) != 0)\n\t\tgoto end;\n\n\terr = -ENOTCONN;\n\tif ((sk->sk_user_data == NULL) ||\n\t    (!(sk->sk_state & (PPPOX_CONNECTED | PPPOX_BOUND))))\n\t\tgoto end;\n\n\t/* Get session context from the socket */\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\n\t/* Special case: if session's session_id is zero, treat ioctl as a\n\t * tunnel ioctl\n\t */\n\tps = l2tp_session_priv(session);\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\n\t\terr = pppol2tp_tunnel_ioctl(tunnel, cmd, arg);\n\t\tsock_put(ps->tunnel_sock);\n\t\tgoto end_put_sess;\n\t}\n\n\terr = pppol2tp_session_ioctl(session, cmd, arg);\n\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}\n\n/*****************************************************************************\n * setsockopt() / getsockopt() support.\n *\n * The PPPoX socket is created for L2TP sessions: tunnels have their own UDP\n * sockets. In order to control kernel tunnel features, we allow userspace to\n * create a special \"tunnel\" PPPoX socket which is used for control only.\n * Tunnel PPPoX sockets have session_id == 0 and simply allow the user\n * application to issue L2TP setsockopt(), getsockopt() and ioctl() calls.\n *****************************************************************************/\n\n/* Tunnel setsockopt() helper.\n */\nstatic int pppol2tp_tunnel_setsockopt(struct sock *sk,\n\t\t\t\t      struct l2tp_tunnel *tunnel,\n\t\t\t\t      int optname, int val)\n{\n\tint err = 0;\n\n\tswitch (optname) {\n\tcase PPPOL2TP_SO_DEBUG:\n\t\ttunnel->debug = val;\n\t\tl2tp_info(tunnel, PPPOL2TP_MSG_CONTROL, \"%s: set debug=%x\\n\",\n\t\t\t  tunnel->name, tunnel->debug);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n/* Session setsockopt helper.\n */\nstatic int pppol2tp_session_setsockopt(struct sock *sk,\n\t\t\t\t       struct l2tp_session *session,\n\t\t\t\t       int optname, int val)\n{\n\tint err = 0;\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\n\tswitch (optname) {\n\tcase PPPOL2TP_SO_RECVSEQ:\n\t\tif ((val != 0) && (val != 1)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsession->recv_seq = val ? -1 : 0;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: set recv_seq=%d\\n\",\n\t\t\t  session->name, session->recv_seq);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_SENDSEQ:\n\t\tif ((val != 0) && (val != 1)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsession->send_seq = val ? -1 : 0;\n\t\t{\n\t\t\tstruct sock *ssk      = ps->sock;\n\t\t\tstruct pppox_sock *po = pppox_sk(ssk);\n\t\t\tpo->chan.hdrlen = val ? PPPOL2TP_L2TP_HDR_SIZE_SEQ :\n\t\t\t\tPPPOL2TP_L2TP_HDR_SIZE_NOSEQ;\n\t\t}\n\t\tl2tp_session_set_header_len(session, session->tunnel->version);\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: set send_seq=%d\\n\",\n\t\t\t  session->name, session->send_seq);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_LNSMODE:\n\t\tif ((val != 0) && (val != 1)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsession->lns_mode = val ? -1 : 0;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: set lns_mode=%d\\n\",\n\t\t\t  session->name, session->lns_mode);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_DEBUG:\n\t\tsession->debug = val;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: set debug=%x\\n\",\n\t\t\t  session->name, session->debug);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_REORDERTO:\n\t\tsession->reorder_timeout = msecs_to_jiffies(val);\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: set reorder_timeout=%d\\n\",\n\t\t\t  session->name, session->reorder_timeout);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n/* Main setsockopt() entry point.\n * Does API checks, then calls either the tunnel or session setsockopt\n * handler, according to whether the PPPoL2TP socket is a for a regular\n * session or the special tunnel type.\n */\nstatic int pppol2tp_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct pppol2tp_session *ps;\n\tint val;\n\tint err;\n\n\tif (level != SOL_PPPOL2TP)\n\t\treturn -EINVAL;\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\terr = -ENOTCONN;\n\tif (sk->sk_user_data == NULL)\n\t\tgoto end;\n\n\t/* Get session context from the socket */\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\n\t/* Special case: if session_id == 0x0000, treat as operation on tunnel\n\t */\n\tps = l2tp_session_priv(session);\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\n\t\terr = pppol2tp_tunnel_setsockopt(sk, tunnel, optname, val);\n\t\tsock_put(ps->tunnel_sock);\n\t} else\n\t\terr = pppol2tp_session_setsockopt(sk, session, optname, val);\n\n\terr = 0;\n\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}\n\n/* Tunnel getsockopt helper. Called with sock locked.\n */\nstatic int pppol2tp_tunnel_getsockopt(struct sock *sk,\n\t\t\t\t      struct l2tp_tunnel *tunnel,\n\t\t\t\t      int optname, int *val)\n{\n\tint err = 0;\n\n\tswitch (optname) {\n\tcase PPPOL2TP_SO_DEBUG:\n\t\t*val = tunnel->debug;\n\t\tl2tp_info(tunnel, PPPOL2TP_MSG_CONTROL, \"%s: get debug=%x\\n\",\n\t\t\t  tunnel->name, tunnel->debug);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n/* Session getsockopt helper. Called with sock locked.\n */\nstatic int pppol2tp_session_getsockopt(struct sock *sk,\n\t\t\t\t       struct l2tp_session *session,\n\t\t\t\t       int optname, int *val)\n{\n\tint err = 0;\n\n\tswitch (optname) {\n\tcase PPPOL2TP_SO_RECVSEQ:\n\t\t*val = session->recv_seq;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: get recv_seq=%d\\n\", session->name, *val);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_SENDSEQ:\n\t\t*val = session->send_seq;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: get send_seq=%d\\n\", session->name, *val);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_LNSMODE:\n\t\t*val = session->lns_mode;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: get lns_mode=%d\\n\", session->name, *val);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_DEBUG:\n\t\t*val = session->debug;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: get debug=%d\\n\",\n\t\t\t  session->name, *val);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_REORDERTO:\n\t\t*val = (int) jiffies_to_msecs(session->reorder_timeout);\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: get reorder_timeout=%d\\n\", session->name, *val);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t}\n\n\treturn err;\n}\n\n/* Main getsockopt() entry point.\n * Does API checks, then calls either the tunnel or session getsockopt\n * handler, according to whether the PPPoX socket is a for a regular session\n * or the special tunnel type.\n */\nstatic int pppol2tp_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tint val, len;\n\tint err;\n\tstruct pppol2tp_session *ps;\n\n\tif (level != SOL_PPPOL2TP)\n\t\treturn -EINVAL;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlen = min_t(unsigned int, len, sizeof(int));\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\terr = -ENOTCONN;\n\tif (sk->sk_user_data == NULL)\n\t\tgoto end;\n\n\t/* Get the session context */\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\n\t/* Special case: if session_id == 0x0000, treat as operation on tunnel */\n\tps = l2tp_session_priv(session);\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\n\t\terr = pppol2tp_tunnel_getsockopt(sk, tunnel, optname, &val);\n\t\tsock_put(ps->tunnel_sock);\n\t} else\n\t\terr = pppol2tp_session_getsockopt(sk, session, optname, &val);\n\n\terr = -EFAULT;\n\tif (put_user(len, optlen))\n\t\tgoto end_put_sess;\n\n\tif (copy_to_user((void __user *) optval, &val, len))\n\t\tgoto end_put_sess;\n\n\terr = 0;\n\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}\n\n/*****************************************************************************\n * /proc filesystem for debug\n * Since the original pppol2tp driver provided /proc/net/pppol2tp for\n * L2TPv2, we dump only L2TPv2 tunnels and sessions here.\n *****************************************************************************/\n\nstatic unsigned int pppol2tp_net_id;\n\n#ifdef CONFIG_PROC_FS\n\nstruct pppol2tp_seq_data {\n\tstruct seq_net_private p;\n\tint tunnel_idx;\t\t\t/* current tunnel */\n\tint session_idx;\t\t/* index of session within current tunnel */\n\tstruct l2tp_tunnel *tunnel;\n\tstruct l2tp_session *session;\t/* NULL means get next tunnel */\n};\n\nstatic void pppol2tp_next_tunnel(struct net *net, struct pppol2tp_seq_data *pd)\n{\n\tfor (;;) {\n\t\tpd->tunnel = l2tp_tunnel_find_nth(net, pd->tunnel_idx);\n\t\tpd->tunnel_idx++;\n\n\t\tif (pd->tunnel == NULL)\n\t\t\tbreak;\n\n\t\t/* Ignore L2TPv3 tunnels */\n\t\tif (pd->tunnel->version < 3)\n\t\t\tbreak;\n\t}\n}\n\nstatic void pppol2tp_next_session(struct net *net, struct pppol2tp_seq_data *pd)\n{\n\tpd->session = l2tp_session_find_nth(pd->tunnel, pd->session_idx);\n\tpd->session_idx++;\n\n\tif (pd->session == NULL) {\n\t\tpd->session_idx = 0;\n\t\tpppol2tp_next_tunnel(net, pd);\n\t}\n}\n\nstatic void *pppol2tp_seq_start(struct seq_file *m, loff_t *offs)\n{\n\tstruct pppol2tp_seq_data *pd = SEQ_START_TOKEN;\n\tloff_t pos = *offs;\n\tstruct net *net;\n\n\tif (!pos)\n\t\tgoto out;\n\n\tBUG_ON(m->private == NULL);\n\tpd = m->private;\n\tnet = seq_file_net(m);\n\n\tif (pd->tunnel == NULL)\n\t\tpppol2tp_next_tunnel(net, pd);\n\telse\n\t\tpppol2tp_next_session(net, pd);\n\n\t/* NULL tunnel and session indicates end of list */\n\tif ((pd->tunnel == NULL) && (pd->session == NULL))\n\t\tpd = NULL;\n\nout:\n\treturn pd;\n}\n\nstatic void *pppol2tp_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn NULL;\n}\n\nstatic void pppol2tp_seq_stop(struct seq_file *p, void *v)\n{\n\t/* nothing to do */\n}\n\nstatic void pppol2tp_seq_tunnel_show(struct seq_file *m, void *v)\n{\n\tstruct l2tp_tunnel *tunnel = v;\n\n\tseq_printf(m, \"\\nTUNNEL '%s', %c %d\\n\",\n\t\t   tunnel->name,\n\t\t   (tunnel == tunnel->sock->sk_user_data) ? 'Y' : 'N',\n\t\t   atomic_read(&tunnel->ref_count) - 1);\n\tseq_printf(m, \" %08x %ld/%ld/%ld %ld/%ld/%ld\\n\",\n\t\t   tunnel->debug,\n\t\t   atomic_long_read(&tunnel->stats.tx_packets),\n\t\t   atomic_long_read(&tunnel->stats.tx_bytes),\n\t\t   atomic_long_read(&tunnel->stats.tx_errors),\n\t\t   atomic_long_read(&tunnel->stats.rx_packets),\n\t\t   atomic_long_read(&tunnel->stats.rx_bytes),\n\t\t   atomic_long_read(&tunnel->stats.rx_errors));\n}\n\nstatic void pppol2tp_seq_session_show(struct seq_file *m, void *v)\n{\n\tstruct l2tp_session *session = v;\n\tstruct l2tp_tunnel *tunnel = session->tunnel;\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\tstruct pppox_sock *po = pppox_sk(ps->sock);\n\tu32 ip = 0;\n\tu16 port = 0;\n\n\tif (tunnel->sock) {\n\t\tstruct inet_sock *inet = inet_sk(tunnel->sock);\n\t\tip = ntohl(inet->inet_saddr);\n\t\tport = ntohs(inet->inet_sport);\n\t}\n\n\tseq_printf(m, \"  SESSION '%s' %08X/%d %04X/%04X -> \"\n\t\t   \"%04X/%04X %d %c\\n\",\n\t\t   session->name, ip, port,\n\t\t   tunnel->tunnel_id,\n\t\t   session->session_id,\n\t\t   tunnel->peer_tunnel_id,\n\t\t   session->peer_session_id,\n\t\t   ps->sock->sk_state,\n\t\t   (session == ps->sock->sk_user_data) ?\n\t\t   'Y' : 'N');\n\tseq_printf(m, \"   %d/%d/%c/%c/%s %08x %u\\n\",\n\t\t   session->mtu, session->mru,\n\t\t   session->recv_seq ? 'R' : '-',\n\t\t   session->send_seq ? 'S' : '-',\n\t\t   session->lns_mode ? \"LNS\" : \"LAC\",\n\t\t   session->debug,\n\t\t   jiffies_to_msecs(session->reorder_timeout));\n\tseq_printf(m, \"   %hu/%hu %ld/%ld/%ld %ld/%ld/%ld\\n\",\n\t\t   session->nr, session->ns,\n\t\t   atomic_long_read(&session->stats.tx_packets),\n\t\t   atomic_long_read(&session->stats.tx_bytes),\n\t\t   atomic_long_read(&session->stats.tx_errors),\n\t\t   atomic_long_read(&session->stats.rx_packets),\n\t\t   atomic_long_read(&session->stats.rx_bytes),\n\t\t   atomic_long_read(&session->stats.rx_errors));\n\n\tif (po)\n\t\tseq_printf(m, \"   interface %s\\n\", ppp_dev_name(&po->chan));\n}\n\nstatic int pppol2tp_seq_show(struct seq_file *m, void *v)\n{\n\tstruct pppol2tp_seq_data *pd = v;\n\n\t/* display header on line 1 */\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(m, \"PPPoL2TP driver info, \" PPPOL2TP_DRV_VERSION \"\\n\");\n\t\tseq_puts(m, \"TUNNEL name, user-data-ok session-count\\n\");\n\t\tseq_puts(m, \" debug tx-pkts/bytes/errs rx-pkts/bytes/errs\\n\");\n\t\tseq_puts(m, \"  SESSION name, addr/port src-tid/sid \"\n\t\t\t \"dest-tid/sid state user-data-ok\\n\");\n\t\tseq_puts(m, \"   mtu/mru/rcvseq/sendseq/lns debug reorderto\\n\");\n\t\tseq_puts(m, \"   nr/ns tx-pkts/bytes/errs rx-pkts/bytes/errs\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Show the tunnel or session context.\n\t */\n\tif (pd->session == NULL)\n\t\tpppol2tp_seq_tunnel_show(m, pd->tunnel);\n\telse\n\t\tpppol2tp_seq_session_show(m, pd->session);\n\nout:\n\treturn 0;\n}\n\nstatic const struct seq_operations pppol2tp_seq_ops = {\n\t.start\t\t= pppol2tp_seq_start,\n\t.next\t\t= pppol2tp_seq_next,\n\t.stop\t\t= pppol2tp_seq_stop,\n\t.show\t\t= pppol2tp_seq_show,\n};\n\n/* Called when our /proc file is opened. We allocate data for use when\n * iterating our tunnel / session contexts and store it in the private\n * data of the seq_file.\n */\nstatic int pppol2tp_proc_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open_net(inode, file, &pppol2tp_seq_ops,\n\t\t\t    sizeof(struct pppol2tp_seq_data));\n}\n\nstatic const struct file_operations pppol2tp_proc_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= pppol2tp_proc_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release_net,\n};\n\n#endif /* CONFIG_PROC_FS */\n\n/*****************************************************************************\n * Network namespace\n *****************************************************************************/\n\nstatic __net_init int pppol2tp_init_net(struct net *net)\n{\n\tstruct proc_dir_entry *pde;\n\tint err = 0;\n\n\tpde = proc_create(\"pppol2tp\", S_IRUGO, net->proc_net,\n\t\t\t  &pppol2tp_proc_fops);\n\tif (!pde) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\nout:\n\treturn err;\n}\n\nstatic __net_exit void pppol2tp_exit_net(struct net *net)\n{\n\tremove_proc_entry(\"pppol2tp\", net->proc_net);\n}\n\nstatic struct pernet_operations pppol2tp_net_ops = {\n\t.init = pppol2tp_init_net,\n\t.exit = pppol2tp_exit_net,\n\t.id   = &pppol2tp_net_id,\n};\n\n/*****************************************************************************\n * Init and cleanup\n *****************************************************************************/\n\nstatic const struct proto_ops pppol2tp_ops = {\n\t.family\t\t= AF_PPPOX,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= pppol2tp_release,\n\t.bind\t\t= sock_no_bind,\n\t.connect\t= pppol2tp_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= sock_no_accept,\n\t.getname\t= pppol2tp_getname,\n\t.poll\t\t= datagram_poll,\n\t.listen\t\t= sock_no_listen,\n\t.shutdown\t= sock_no_shutdown,\n\t.setsockopt\t= pppol2tp_setsockopt,\n\t.getsockopt\t= pppol2tp_getsockopt,\n\t.sendmsg\t= pppol2tp_sendmsg,\n\t.recvmsg\t= pppol2tp_recvmsg,\n\t.mmap\t\t= sock_no_mmap,\n\t.ioctl\t\t= pppox_ioctl,\n};\n\nstatic const struct pppox_proto pppol2tp_proto = {\n\t.create\t\t= pppol2tp_create,\n\t.ioctl\t\t= pppol2tp_ioctl,\n\t.owner\t\t= THIS_MODULE,\n};\n\n#ifdef CONFIG_L2TP_V3\n\nstatic const struct l2tp_nl_cmd_ops pppol2tp_nl_cmd_ops = {\n\t.session_create\t= pppol2tp_session_create,\n\t.session_delete\t= l2tp_session_delete,\n};\n\n#endif /* CONFIG_L2TP_V3 */\n\nstatic int __init pppol2tp_init(void)\n{\n\tint err;\n\n\terr = register_pernet_device(&pppol2tp_net_ops);\n\tif (err)\n\t\tgoto out;\n\n\terr = proto_register(&pppol2tp_sk_proto, 0);\n\tif (err)\n\t\tgoto out_unregister_pppol2tp_pernet;\n\n\terr = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);\n\tif (err)\n\t\tgoto out_unregister_pppol2tp_proto;\n\n#ifdef CONFIG_L2TP_V3\n\terr = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);\n\tif (err)\n\t\tgoto out_unregister_pppox;\n#endif\n\n\tpr_info(\"PPPoL2TP kernel driver, %s\\n\", PPPOL2TP_DRV_VERSION);\n\nout:\n\treturn err;\n\n#ifdef CONFIG_L2TP_V3\nout_unregister_pppox:\n\tunregister_pppox_proto(PX_PROTO_OL2TP);\n#endif\nout_unregister_pppol2tp_proto:\n\tproto_unregister(&pppol2tp_sk_proto);\nout_unregister_pppol2tp_pernet:\n\tunregister_pernet_device(&pppol2tp_net_ops);\n\tgoto out;\n}\n\nstatic void __exit pppol2tp_exit(void)\n{\n#ifdef CONFIG_L2TP_V3\n\tl2tp_nl_unregister_ops(L2TP_PWTYPE_PPP);\n#endif\n\tunregister_pppox_proto(PX_PROTO_OL2TP);\n\tproto_unregister(&pppol2tp_sk_proto);\n\tunregister_pernet_device(&pppol2tp_net_ops);\n}\n\nmodule_init(pppol2tp_init);\nmodule_exit(pppol2tp_exit);\n\nMODULE_AUTHOR(\"James Chapman <jchapman@katalix.com>\");\nMODULE_DESCRIPTION(\"PPP over L2TP over UDP\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(PPPOL2TP_DRV_VERSION);\nMODULE_ALIAS(\"pppox-proto-\" __stringify(PX_PROTO_OL2TP));\n"], "filenames": ["net/l2tp/l2tp_ppp.c"], "buggy_code_start_loc": [1368], "buggy_code_end_loc": [1495], "fixing_code_start_loc": [1368], "fixing_code_end_loc": [1495], "type": "CWE-269", "message": "The PPPoL2TP feature in net/l2tp/l2tp_ppp.c in the Linux kernel through 3.15.6 allows local users to gain privileges by leveraging data-structure differences between an l2tp socket and an inet socket.", "other": {"cve": {"id": "CVE-2014-4943", "sourceIdentifier": "cve@mitre.org", "published": "2014-07-19T19:55:08.230", "lastModified": "2020-08-14T18:09:04.653", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The PPPoL2TP feature in net/l2tp/l2tp_ppp.c in the Linux kernel through 3.15.6 allows local users to gain privileges by leveraging data-structure differences between an l2tp socket and an inet socket."}, {"lang": "es", "value": "La funcionalidad PPPoL2TP en net/l2tp/l2tp_ppp.c en el kernel de Linux hasta 3.15.6 permite a usuarios locales ganar privilegios mediante el aprovechamiento de diferencias de la estructura de datos entre un socket l2tp y un socket inet."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.15.6", "matchCriteriaId": "6FB1F826-C65B-4FA4-B3F8-65EAB7799410"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:11.4:*:*:*:*:*:*:*", "matchCriteriaId": "DE554781-1EB9-446E-911F-6C11970C47F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:11:sp3:*:*:*:*:*:*", "matchCriteriaId": "3ED68ADD-BBDA-4485-BC76-58F011D72311"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp2:*:*:ltss:*:*:*", "matchCriteriaId": "CB6476C7-03F2-4939-AB85-69AA524516D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp3:*:*:*:*:*:*", "matchCriteriaId": "8B072472-B463-4647-885D-E40B0115C810"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp3:*:*:*:vmware:*:*", "matchCriteriaId": "2470C6E8-2024-4CF5-9982-CFF50E88EAE9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:6.2:*:*:*:*:*:*:*", "matchCriteriaId": "AD6D0378-F0F4-4AAA-80AF-8287C790EC96"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=3cf521f7dc87c031617fd47e4b7aa2593c2f3daf", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://linux.oracle.com/errata/ELSA-2014-0924.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://linux.oracle.com/errata/ELSA-2014-3047.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://linux.oracle.com/errata/ELSA-2014-3048.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-10/msg00006.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-10/msg00007.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-03/msg00010.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-03/msg00025.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://openwall.com/lists/oss-security/2014/07/17/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-1025.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://secunia.com/advisories/59790", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2014/dsa-2992", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.exploit-db.com/exploits/36267", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1030610", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1119458", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/94665", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/3cf521f7dc87c031617fd47e4b7aa2593c2f3daf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/3cf521f7dc87c031617fd47e4b7aa2593c2f3daf"}}