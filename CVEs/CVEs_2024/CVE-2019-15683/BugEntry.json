{"buggy_code": ["/*\n * auth.c - deal with authentication.\n *\n * This file implements authentication when setting up an RFB connection.\n */\n\n/*\n *  Copyright (C) 2010, 2012-2019 D. R. Commander.  All Rights Reserved.\n *  Copyright (C) 2010 University Corporation for Atmospheric Research.\n *                     All Rights Reserved.\n *  Copyright (C) 2003-2006 Constantin Kaplinsky.  All Rights Reserved.\n *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n *  USA.\n */\n\n#ifndef _POSIX_PTHREAD_SEMANTICS\n#define _POSIX_PTHREAD_SEMANTICS\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"rfb.h\"\n#include \"windowstr.h\"\n\n\nchar *rfbAuthPasswdFile = NULL;\n\nstatic void rfbSendSecurityType(rfbClientPtr cl, int securityType);\nstatic void rfbSendSecurityTypeList(rfbClientPtr cl);\nstatic void rfbSendTunnelingCaps(rfbClientPtr cl);\nstatic void rfbSendAuthCaps(rfbClientPtr cl);\n\nstatic void rfbVncAuthSendChallenge(rfbClientPtr cl);\nstatic void rfbVeNCryptAuthenticate(rfbClientPtr cl);\n\n#define AUTH_DEFAULT_CONF_FILE  \\\n  CMAKE_INSTALL_FULL_SYSCONFDIR \"/turbovncserver-security.conf\"\n#ifdef XVNC_AuthPAM\n#define AUTH_DEFAULT_PAM_SERVICE_NAME \"turbovnc\"\n#endif\n\n#define MAX_USER_LEN 64\n#define MAX_PWD_LEN 64\n\nchar *rfbAuthConfigFile = AUTH_DEFAULT_CONF_FILE;\nBool rfbAuthDisableRemoteResize = FALSE;\nBool rfbAuthDisableRevCon = FALSE;\nBool rfbAuthDisableCBSend = FALSE;\nBool rfbAuthDisableCBRecv = FALSE;\nBool rfbAuthDisableHTTP = FALSE;\nBool rfbAuthDisableX11TCP = FALSE;\n\nstatic int nSecTypesEnabled = 0;\nstatic int preferenceLimit = 1;  /* Force one iteration of the loop in\n                                    rfbSendAuthCaps() */\n\nchar *rfbAuthOTPValue = NULL;\nint rfbAuthOTPValueLen = 0;\n#if USETLS\nchar *rfbAuthX509Cert = NULL;\nchar *rfbAuthX509Key = NULL;\nchar *rfbAuthCipherSuites = NULL;\n#endif\n\n\nstatic void AuthNoneStartFunc(rfbClientPtr cl)\n{\n  rfbClientAuthSucceeded(cl, rfbAuthNone);\n}\n\nstatic void AuthNoneRspFunc(rfbClientPtr cl)\n{\n}\n\n\n#ifdef XVNC_AuthPAM\n\n#include <pwd.h>\n\nstatic char *pamServiceName = AUTH_DEFAULT_PAM_SERVICE_NAME;\n\ntypedef struct UserList {\n  struct UserList *next;\n  const char *name;\n  Bool viewOnly;\n} UserList;\n\nstatic UserList *userACL = NULL;\nBool rfbAuthUserACL = FALSE;\n\n\nvoid rfbAuthAddUser(const char *name, Bool viewOnly)\n{\n  UserList *p = (UserList *)rfbAlloc(sizeof(UserList));\n\n  rfbLog(\"Adding user '%s' to ACL with %s privileges\\n\", name,\n         viewOnly ? \" view-only\" : \"full control\");\n  p->next = userACL;\n  p->name = name;\n  p->viewOnly = viewOnly;\n  userACL = p;\n}\n\n\nvoid rfbAuthRevokeUser(const char *name)\n{\n  UserList **prev = &userACL;\n  UserList *p;\n\n  rfbLog(\"Removing user '%s' from ACL\\n\", name);\n  while (*prev != NULL) {\n    p = *prev;\n    if (!strcmp(p->name, name)) {\n      *prev = p->next;\n      free((void *)p->name);\n      free(p);\n      return;\n    }\n\n    prev = &p->next;\n  }\n}\n\n\nstatic void AuthPAMUserPwdStartFunc(rfbClientPtr cl)\n{\n  cl->state = RFB_AUTHENTICATION;\n}\n\n\nstatic void AuthPAMUserPwdRspFunc(rfbClientPtr cl)\n{\n  CARD32 userLen;\n  CARD32 pwdLen;\n  char userBuf[MAX_USER_LEN + 1];\n  char pwdBuf[MAX_PWD_LEN + 1];\n  int n;\n  const char *emsg;\n\n  n = ReadExact(cl, (char *)&userLen, sizeof(userLen));\n  if (n <= 0) {\n    if (n != 0)\n      rfbLogPerror(\"AuthPAMUserPwdRspFunc: read error\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  userLen = Swap32IfLE(userLen);\n  n = ReadExact(cl, (char *)&pwdLen, sizeof(pwdLen));\n  if (n <= 0) {\n    if (n != 0)\n      rfbLogPerror(\"AuthPAMUserPwdRspFunc: read error\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  pwdLen = Swap32IfLE(pwdLen);\n  if ((userLen > MAX_USER_LEN) || (pwdLen > MAX_PWD_LEN)) {\n    rfbLogPerror(\"AuthPAMUserPwdRspFunc: excessively large user name or password in response\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  n = ReadExact(cl, userBuf, userLen);\n  if (n <= 0) {\n    if (n != 0)\n      rfbLogPerror(\"AuthPAMUserPwdRspFunc: error reading user name\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  userBuf[userLen] = '\\0';\n  n = ReadExact(cl, pwdBuf, pwdLen);\n  if (n <= 0) {\n    if (n != 0)\n      rfbLogPerror(\"AuthPAMUserPwdRspFunc: error reading password\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  pwdBuf[pwdLen] = '\\0';\n  if (rfbAuthUserACL) {\n    UserList *p = userACL;\n\n    if (p == NULL)\n      rfbLog(\"WARNING: User ACL is empty.  No users will be allowed to log in with Unix Login authentication.\\n\");\n\n    while (p != NULL) {\n      if (!strcmp(p->name, userBuf))\n        break;\n      p = p->next;\n    }\n\n    if (p == NULL) {\n      rfbLog(\"User '%s' is not in the ACL and has been denied access\\n\",\n             userBuf);\n      rfbClientAuthFailed(cl, \"User denied access\");\n      return;\n    }\n\n    cl->viewOnly = p->viewOnly;\n  } else {\n    struct passwd pbuf;\n    struct passwd *pw;\n    char buf[256];\n\n    if (getpwuid_r(getuid(), &pbuf, buf, sizeof(buf), &pw) != 0)\n      FatalError(\"AuthPAMUserPwdRspFunc: getpwuid_r failed: %s\",\n                 strerror(errno));\n\n    if (strcmp(pbuf.pw_name, userBuf)) {\n      rfbLog(\"User '%s' denied access (not the session owner)\\n\", userBuf);\n      rfbLog(\"  Enable user ACL to grant access to other users.\\n\");\n      rfbClientAuthFailed(cl, \"User denied access\");\n      return;\n    }\n  }\n\n  if (rfbPAMAuthenticate(cl, pamServiceName, userBuf, pwdBuf, &emsg))\n    rfbClientAuthSucceeded(cl, rfbAuthUnixLogin);\n  else\n    rfbClientAuthFailed(cl, (char *)emsg);\n}\n\n#endif\n\n\ntypedef struct {\n  const char *name;\n  int protocolMinorVer;\n  Bool advertise;\n  CARD8 securityType;\n} RFBSecTypeData;\n\nstatic RFBSecTypeData secTypeNone =\n  { \"none\",    3, TRUE, rfbSecTypeNone };\nstatic RFBSecTypeData secTypeVncAuth =\n  { \"vncauth\", 3, TRUE, rfbSecTypeVncAuth };\nstatic RFBSecTypeData secTypeTight =\n  { \"tight\",   7, TRUE, rfbSecTypeTight };\nstatic RFBSecTypeData secTypeVeNCrypt =\n  { \"vencrypt\", 7, TRUE, rfbSecTypeVeNCrypt };\n\nstatic RFBSecTypeData *rfbSecTypes[] = {\n  &secTypeNone, &secTypeVncAuth, &secTypeVeNCrypt, &secTypeTight, NULL\n};\n\ntypedef void (*AuthFunc) (rfbClientPtr cl);\n\ntypedef struct {\n  int authType;\n  CARD8 vendorSignature[4];\n  CARD8 nameSignature[8];\n  AuthFunc startFunc;\n  AuthFunc rspFunc;\n} AuthCapData;\n\nstatic AuthCapData authCapNone =\n  { rfbAuthNone, rfbStandardVendor, sig_rfbAuthNone, AuthNoneStartFunc,\n    AuthNoneRspFunc };\n\nstatic AuthCapData authCapVncAuth =\n  { rfbAuthVNC, rfbStandardVendor, sig_rfbAuthVNC, rfbVncAuthSendChallenge,\n    rfbVncAuthProcessResponse };\n\nstatic AuthCapData authCapVeNCrypt =\n  { rfbAuthVeNCrypt, rfbVeNCryptVendor, sig_rfbAuthVeNCrypt,\n    rfbVeNCryptAuthenticate, AuthNoneRspFunc };\n\n#ifdef XVNC_AuthPAM\nstatic AuthCapData authCapUnixLogin =\n  { rfbAuthUnixLogin, rfbTightVncVendor, sig_rfbAuthUnixLogin,\n    AuthPAMUserPwdStartFunc, AuthPAMUserPwdRspFunc };\n#endif\n\nstatic AuthCapData *authCaps[] = {\n  &authCapNone, &authCapVncAuth, &authCapVeNCrypt,\n#ifdef XVNC_AuthPAM\n  &authCapUnixLogin,\n#endif\n  NULL\n};\n\ntypedef struct {\n  const char *name;\n  Bool enabled;\n  Bool permitted;\n  int preference;\n  Bool requiredData;\n  RFBSecTypeData *rfbSecType;\n  AuthCapData *authCap;\n  int subType;\n} SecTypeData;\n\n/*\n * Set the \"permitted\" member to TRUE if you want the security type to be\n * available by default.  The value of the \"permitted-security-types\" config\n * file option will take precedence over the defaults below.\n *\n * We permit the rfbAuthNone security type by default for backward\n * compatibility and only enable it when either explicitly told to do so or if\n * it is permitted and no other security types were specified on the command\n * line.\n */\nstatic SecTypeData secTypes[] = {\n#if USETLS\n/*  name         enabled  permitted  preference  requiredData */\n  { \"tlsnone\",   FALSE,   TRUE,      -1,         FALSE,\n/*  secType           authCap            subType */\n    &secTypeVeNCrypt, &authCapVeNCrypt,  rfbVeNCryptTLSNone },\n\n  { \"tlsvnc\",    TRUE,    TRUE,      -1,         TRUE,\n    &secTypeVeNCrypt, &authCapVeNCrypt,  rfbVeNCryptTLSVnc },\n\n  { \"tlsotp\",    TRUE,    TRUE,      -1,         TRUE,\n    &secTypeVeNCrypt, &authCapVeNCrypt,  rfbVeNCryptTLSVnc },\n\n#ifdef XVNC_AuthPAM\n  { \"tlsplain\",  TRUE,    TRUE,      -1,         TRUE,\n    &secTypeVeNCrypt, &authCapVeNCrypt,  rfbVeNCryptTLSPlain },\n#endif\n\n  { \"x509none\",  FALSE,   TRUE,      -1,         FALSE,\n    &secTypeVeNCrypt, &authCapVeNCrypt,  rfbVeNCryptX509None },\n\n  { \"x509vnc\",   TRUE,    TRUE,      -1,         TRUE,\n    &secTypeVeNCrypt, &authCapVeNCrypt,  rfbVeNCryptX509Vnc },\n\n  { \"x509otp\",   TRUE,    TRUE,      -1,         TRUE,\n    &secTypeVeNCrypt, &authCapVeNCrypt,  rfbVeNCryptX509Vnc },\n\n#ifdef XVNC_AuthPAM\n  { \"x509plain\", TRUE,    TRUE,      -1,         TRUE,\n    &secTypeVeNCrypt, &authCapVeNCrypt,  rfbVeNCryptX509Plain },\n#endif\n#endif\n\n  { \"none\",      FALSE,   TRUE,      -1,         FALSE,\n    &secTypeNone,     &authCapNone,      rfbSecTypeNone },\n\n  { \"vnc\",       TRUE,    TRUE,      -1,         TRUE,\n    &secTypeVncAuth,  &authCapVncAuth,   rfbSecTypeVncAuth },\n\n  { \"otp\",       TRUE,    TRUE,      -1,         TRUE,\n    &secTypeVncAuth,  &authCapVncAuth,   rfbSecTypeVncAuth },\n\n#ifdef XVNC_AuthPAM\n  { \"unixlogin\", TRUE,    TRUE,      -1,         TRUE,\n    &secTypeTight,    &authCapUnixLogin, -1 },\n\n  { \"plain\",     TRUE,    TRUE,      -1,         TRUE,\n    &secTypeVeNCrypt, &authCapVeNCrypt,  rfbVeNCryptPlain },\n#endif\n\n  { NULL }\n};\n\n\nBool rfbOptOtpAuth(void)\n{\n  SecTypeData *s;\n\n  for (s = secTypes; s->name != NULL; s++) {\n    if (!strcmp(&s->name[strlen(s->name) - 3], \"otp\") && s->enabled)\n      return TRUE;\n  }\n\n  return FALSE;\n}\n\n\nBool rfbOptPamAuth(void)\n{\n  SecTypeData *s;\n\n  for (s = secTypes; s->name != NULL; s++) {\n    if ((!strcmp(s->name, \"unixlogin\") ||\n         !strcmp(&s->name[strlen(s->name) - 5], \"plain\")) && s->enabled)\n      return TRUE;\n  }\n\n  return FALSE;\n}\n\n\nBool rfbOptRfbAuth(void)\n{\n  SecTypeData *s;\n\n  for (s = secTypes; s->name != NULL; s++) {\n    if (!strcmp(&s->name[strlen(s->name) - 3], \"vnc\") && s->enabled)\n      return TRUE;\n  }\n\n  return FALSE;\n}\n\n\nvoid rfbAuthParseCommandLine(char *securityTypes)\n{\n  char *p1 = securityTypes, *p2 = securityTypes;\n  SecTypeData *s;\n\n  for (s = secTypes; s->name != NULL; s++)\n    s->enabled = FALSE;\n\n  do {\n    *p2 = *p1;\n    if (!isspace(*p2))\n      p2++;\n  } while (*p1++ != 0);\n\n  while (TRUE) {\n    p1 = strtok_r(securityTypes, \",\", &p2);\n    securityTypes = NULL;\n    if (p1 == NULL)\n      break;\n\n    for (s = secTypes; s->name != NULL; s++) {\n      if (!strcasecmp(s->name, p1)) {\n        s->enabled = TRUE;\n        break;\n      }\n    }\n\n    if (s->name == NULL)\n      FatalError(\"ERROR: Unknown security type '%s'\", p1);\n  }\n}\n\n\nstatic void setSecTypes(char *buf, Bool backwardCompatible)\n{\n  char *saveptr = NULL;\n  char *p;\n  SecTypeData *s;\n\n  preferenceLimit = 0;\n  for (s = secTypes; s->name != NULL; s++) {\n    s->permitted = FALSE;\n    s->preference = -1;\n    s->rfbSecType->advertise = FALSE;\n  }\n\n  while (TRUE) {\n    p = strtok_r(buf, \",\", &saveptr);\n    buf = NULL;\n    if (p == NULL)\n      break;\n\n    for (s = secTypes; s->name != NULL; s++) {\n      if (backwardCompatible && s->rfbSecType == &secTypeVeNCrypt)\n        continue;\n      if (!strcasecmp(s->name, p) ||\n          (backwardCompatible && !strcasecmp(s->name, \"unixlogin\") &&\n           !strcasecmp(p, \"pam-userpwd\")))\n        break;\n    }\n\n    if (s->name == NULL)\n      FatalError(\"ERROR: Unknown security type name '%s'\", p);\n\n    s->permitted = TRUE;\n    s->preference = preferenceLimit++;\n  }\n}\n\n\nvoid rfbAuthListAvailableSecurityTypes(void)\n{\n  SecTypeData *s;\n  int chars = 23;\n\n  ErrorF(\"                       Available security types (case-insensitive):\\n\");\n  ErrorF(\"                       \");\n  for (s = secTypes; s->name != NULL; s++) {\n    ErrorF(\"%s\", s->name);  chars += strlen(s->name);\n    if ((s + 1)->name != NULL) {\n      ErrorF(\", \");  chars += 2;\n      if (chars + strlen((s + 1)->name) > 77) {\n        ErrorF(\"\\n                       \");\n        chars = 23;\n      }\n    }\n  }\n  ErrorF(\"\\n\");\n}\n\n\nstatic void ReadConfigFile(void)\n{\n  FILE *fp;\n  char buf[256], buf2[256];\n  int line;\n  int len;\n  int n, i, j;\n  struct stat sb;\n\n  if ((fp = fopen(rfbAuthConfigFile, \"r\")) == NULL)\n    return;\n\n  if (fstat(fileno(fp), &sb) == -1)\n    FatalError(\"rfbAuthInit: ERROR: fstat %s: %s\", rfbAuthConfigFile,\n               strerror(errno));\n\n  if ((sb.st_uid != 0) && (sb.st_uid != getuid()))\n    FatalError(\"ERROR: %s must be owned by you or by root\", rfbAuthConfigFile);\n\n  if (sb.st_mode & (S_IWGRP | S_IWOTH))\n    FatalError(\"ERROR: %s cannot have group or global write permissions\",\n               rfbAuthConfigFile);\n\n  rfbLog(\"Using security configuration file %s\\n\", rfbAuthConfigFile);\n  for (line = 0; fgets(buf, sizeof(buf), fp) != NULL; line++) {\n    len = strlen(buf) - 1;\n    if (buf[len] != '\\n' && strlen(buf) == 256)\n      FatalError(\"ERROR in %s: line %d is too long!\", rfbAuthConfigFile,\n                 line + 1);\n\n    buf[len] = '\\0';\n\n    for (i = 0, j = 0; i < len; i++) {\n      if (buf[i] != ' ' && buf[i] != '\\t')\n        buf2[j++] = buf[i];\n    }\n    len = j;\n    buf2[len] = '\\0';\n    if (len < 1) continue;\n\n    if (!strcmp(buf2, \"no-remote-resize\")) {\n      rfbAuthDisableRemoteResize = TRUE;\n      continue;\n    }\n\n    if (!strcmp(buf2, \"no-reverse-connections\")) {\n      rfbAuthDisableRevCon = TRUE;\n      continue;\n    }\n\n    if (!strcmp(buf2, \"no-remote-connections\")) {\n      interface.s_addr = htonl(INADDR_LOOPBACK);\n      interface6 = in6addr_loopback;\n      continue;\n    }\n\n    if (!strcmp(buf2, \"no-clipboard-send\")) {\n      rfbAuthDisableCBSend = TRUE;\n      continue;\n    }\n\n    if (!strcmp(buf2, \"no-clipboard-recv\")) {\n      rfbAuthDisableCBRecv = TRUE;\n      continue;\n    }\n\n    if (!strcmp(buf2, \"no-httpd\")) {\n      rfbAuthDisableHTTP = TRUE;\n      continue;\n    }\n\n    if (!strcmp(buf2, \"no-x11-tcp-connections\")) {\n      rfbAuthDisableX11TCP = TRUE;\n      continue;\n    }\n\n#ifdef XVNC_AuthPAM\n    if (!strcmp(buf2, \"no-pam-sessions\")) {\n      rfbAuthDisablePAMSession = TRUE;\n      continue;\n    }\n\n    if (!strcmp(buf2, \"enable-user-acl\")) {\n      rfbAuthUserACL = TRUE;\n      continue;\n    }\n\n    n = 17;\n    if (!strncmp(buf2, \"pam-service-name=\", n)) {\n      if (buf2[n] == '\\0')\n        FatalError(\"ERROR in %s: pam-service-name is empty!\",\n                   rfbAuthConfigFile);\n\n      if ((pamServiceName = strdup(&buf2[n])) == NULL)\n        FatalError(\"rfbAuthInit strdup: %s\", strerror(errno));\n\n      continue;\n    }\n#endif\n\n    /* permitted-auth-methods provides backward compatibility with TurboVNC\n       2.0.x and earlier.  It can only be used to enable non-VeNCrypt\n       security types. */\n    n = 23;\n    if (!strncmp(buf2, \"permitted-auth-methods=\", n)) {\n      if (buf2[n] == '\\0')\n        FatalError(\"ERROR in %s: permitted-auth-methods is empty!\",\n                   rfbAuthConfigFile);\n\n      setSecTypes(&buf2[n], TRUE);\n      continue;\n    }\n\n    /* permitted-security-types was introduced in TurboVNC 2.1. */\n    n = 25;\n    if (!strncmp(buf2, \"permitted-security-types=\", n)) {\n      if (buf2[n] == '\\0')\n        FatalError(\"ERROR in %s: permitted-security-types is empty!\",\n                   rfbAuthConfigFile);\n\n      setSecTypes(&buf2[n], FALSE);\n      continue;\n    }\n\n#ifdef USETLS\n    n = 24;\n    if (!strncmp(buf2, \"permitted-cipher-suites=\", n)) {\n      if (buf2[n] == '\\0')\n        FatalError(\"ERROR in %s: permitted-cipher-suites is empty!\",\n                   rfbAuthConfigFile);\n\n      if ((rfbAuthCipherSuites = strdup(&buf2[n])) == NULL)\n        FatalError(\"rfbAuthInit strdup: %s\", strerror(errno));\n\n      continue;\n    }\n#endif\n\n    n = 17;\n    if (!strncmp(buf2, \"max-idle-timeout=\", n)) {\n      int t;\n\n      if (buf2[n] == '\\0')\n        FatalError(\"ERROR in %s: max-idle-timeout is empty!\",\n                   rfbAuthConfigFile);\n\n      if (sscanf(&buf2[n], \"%d\", &t) < 1 || t <= 0)\n        FatalError(\"ERROR in %s: max-idle-timeout value must be > 0!\",\n                   rfbAuthConfigFile);\n\n      rfbMaxIdleTimeout = (CARD32)t;\n      continue;\n    }\n\n    n = 17;\n    if (!strncmp(buf2, \"max-desktop-size=\", n)) {\n      int w = -1, h = -1;\n\n      if (buf2[n] == '\\0')\n        FatalError(\"ERROR in %s: max-desktop-size is empty!\",\n                   rfbAuthConfigFile);\n\n      if (sscanf(&buf2[n], \"%dx%d\", &w, &h) < 2 || w <= 0 || h <= 0)\n        FatalError(\"ERROR in %s: max-desktop-size value is incorrect.\",\n                   rfbAuthConfigFile);\n\n      if (w == 0) w = MAXSHORT;\n      if (h == 0) h = MAXSHORT;\n      rfbMaxWidth = (CARD32)w;\n      rfbMaxHeight = (CARD32)h;\n      continue;\n    }\n\n    if (buf2[0] != '#')\n      rfbLog(\"WARNING: unrecognized security config line '%s'\\n\", buf);\n  }\n\n  fclose(fp);\n}\n\n\nvoid rfbAuthInit(void)\n{\n  SecTypeData *s;\n  int nSelected = 0;\n\n  ReadConfigFile();\n\n  for (s = secTypes; s->name != NULL; s++) {\n    if (s->enabled) {\n      nSelected++;\n      if (!s->permitted) {\n        rfbLog(\"WARNING: security type '%s' is not permitted\\n\", s->name);\n        s->enabled = FALSE;\n        continue;\n      }\n    }\n\n    if (s->enabled) {\n      nSecTypesEnabled++;\n      rfbLog(\"Enabled security type '%s'\\n\", s->name);\n      if (!s->rfbSecType->advertise) {\n        s->rfbSecType->advertise = TRUE;\n        rfbLog(\"Advertising security type '%s' to viewers\\n\",\n               s->rfbSecType->name);\n      }\n    }\n  }\n\n  if (nSelected == 0) {\n    /* No security type was selected.  See if we should enable the rfbAuthNone\n       security type. */\n    for (s = secTypes; s->name != NULL; s++) {\n      if (!s->requiredData) {\n        if (s->permitted) {\n          nSecTypesEnabled++;\n          s->enabled = TRUE;\n          s->rfbSecType->advertise = TRUE;\n          rfbLog(\"Enabled security type '%s'\\n\", s->name);\n          rfbLog(\"Advertising security type '%s' to viewers\\n\",\n                 s->rfbSecType->name);\n        }\n      } else {\n        s->rfbSecType->advertise = FALSE;\n      }\n    }\n  }\n\n#ifndef XVNC_AuthPAM\n  if (rfbOptPamAuth())\n    rfbLog(\"WARNING: PAM support is not compiled in.\\n\");\n#endif\n\n  if (nSecTypesEnabled == 0) {\n    for (s = secTypes; s->name != NULL; s++) {\n      if (s->permitted)\n        rfbLog(\"NOTICE: %s is a permitted security type\\n\", s->name);\n    }\n\n    FatalError(\"ERROR: no security types enabled!\");\n  } else {\n    /* Do not advertise rfbAuthNone if any other security type is enabled */\n    for (s = secTypes; s->name != NULL; s++) {\n      if (s->enabled && strcmp(s->name, \"none\"))\n        secTypeNone.advertise = FALSE;\n    }\n  }\n\n#ifdef XVNC_AuthPAM\n  if (rfbOptPamAuth() && rfbAuthUserACL) {\n    struct passwd pbuf;\n    struct passwd *pw;\n    char buf[256];\n    char *n;\n\n    if (getpwuid_r(getuid(), &pbuf, buf, sizeof(buf), &pw) != 0)\n      FatalError(\"AuthPAMUserPwdRspFunc: limit-user enabled and getpwuid_r failed: %s\",\n                 strerror(errno));\n\n    n = (char *)rfbAlloc(strlen(pbuf.pw_name));\n    strcpy(n, pbuf.pw_name);\n    rfbAuthAddUser(n, FALSE);\n  }\n#endif\n}\n\n\nvoid rfbAuthProcessResponse(rfbClientPtr cl)\n{\n  AuthCapData **p;\n  AuthCapData *c;\n\n  for (p = authCaps; *p != NULL; p++) {\n    c = *p;\n    if (cl->selectedAuthType == c->authType) {\n      c->rspFunc(cl);\n      return;\n    }\n  }\n\n  rfbLog(\"rfbAuthProcessResponse: authType assertion failed\\n\");\n  rfbCloseClient(cl);\n}\n\n\n/*\n * rfbAuthNewClient is called right after negotiating the protocol version.\n * Depending on the protocol version, we send either a code for the\n * authentication scheme to be used (protocol 3.3) or a list of possible\n * \"security types\" (protocol 3.7 and above.)\n */\n\nvoid rfbAuthNewClient(rfbClientPtr cl)\n{\n  RFBSecTypeData **p;\n  RFBSecTypeData *r;\n\n  if (rfbAuthIsBlocked()) {\n    rfbLog(\"Too many authentication failures - client rejected\\n\");\n    rfbClientConnFailed(cl, \"Too many authentication failures\");\n    return;\n  }\n\n  if (cl->protocol_minor_ver >= 7) {\n    rfbSendSecurityTypeList(cl);\n    return;\n  }\n\n  /* Make sure we use only RFB 3.3-compatible security types */\n  for (p = rfbSecTypes; *p != NULL; p++) {\n    r = *p;\n    if (r->advertise && (r->protocolMinorVer < 7))\n      break;\n  }\n\n  if (*p == NULL) {\n    rfbLog(\"VNC authentication disabled - RFB 3.3 client rejected\\n\");\n    rfbClientConnFailed(cl, \"Your viewer cannot handle required security types\");\n    return;\n  }\n\n  cl->selectedAuthType = r->securityType;\n  rfbSendSecurityType(cl, r->securityType);\n}\n\n\n/*\n * Tell the client which security type will be used (protocol 3.3)\n */\n\nstatic void rfbSendSecurityType(rfbClientPtr cl, int securityType)\n{\n  CARD32 value32;\n\n  value32 = Swap32IfLE(securityType);\n  if (WriteExact(cl, (char *)&value32, 4) < 0) {\n    rfbLogPerror(\"rfbSendSecurityType: write\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  switch (securityType) {\n    case rfbSecTypeNone:\n      /* Dispatch client input to rfbProcessClientInitMessage() */\n      cl->state = RFB_INITIALISATION;\n      break;\n    case rfbSecTypeVncAuth:\n      /* Begin the Standard VNC authentication procedure */\n      rfbVncAuthSendChallenge(cl);\n      break;\n    default:\n      rfbLogPerror(\"rfbSendSecurityType: assertion failed\");\n      rfbCloseClient(cl);\n  }\n}\n\n\n/*\n * Advertise our supported security types (protocol 3.7 and above)\n */\n\nstatic void rfbSendSecurityTypeList(rfbClientPtr cl)\n{\n  int i, j, n;\n  SecTypeData *s;\n  RFBSecTypeData *r;\n  Bool tightAdvertised = FALSE;\n\n  /*\n   * When no preference order was set using \"permitted-security-types\", the\n   * default value of preferenceLimit (1) will cause us to execute the\n   * outer loop once.  In this case, the s->preference members will all\n   * be the default value (-1), and we skip the order testing.\n   */\n  n = 0;\n  for (i = 0; i < preferenceLimit; i++) {\n    for (s = secTypes; s->name != NULL; s++) {\n      if (((s->preference != -1) && (i != s->preference)) || !s->enabled)\n        continue;\n\n      r = s->rfbSecType;\n\n      if (n > MAX_SECURITY_TYPES)\n        FatalError(\"rfbSendSecurityTypeList: # enabled security types > MAX_SECURITY_TYPES\");\n\n      /*\n       * Check whether we have already advertised this security type\n       */\n      for (j = 0; j < n; j++) {\n        if (cl->securityTypes[j + 1] == r->securityType)\n          break;\n      }\n\n      if (j < n)\n        continue;\n\n      if (r->advertise && (cl->protocol_minor_ver >= r->protocolMinorVer)) {\n        cl->securityTypes[++n] = r->securityType;\n        if (r->securityType == rfbSecTypeTight)\n          tightAdvertised = TRUE;\n      }\n    }\n  }\n\n  if (n == 0)\n    FatalError(\"rfbSendSecurityTypeList: no security types enabled! This should not have happened!\");\n\n  if (!tightAdvertised) {\n    /*\n     * Make sure to advertise the Tight security type, in order to allow\n     * TightVNC-compatible clients to enable other (non-auth) Tight\n     * extensions.\n     */\n    if (n > MAX_SECURITY_TYPES)\n      FatalError(\"rfbSendSecurityTypeList: # enabled security types > MAX_SECURITY_TYPES\");\n\n    rfbLog(\"rfbSendSecurityTypeList: advertise sectype tight\\n\");\n    cl->securityTypes[++n] = rfbSecTypeTight;\n  }\n\n  cl->securityTypes[0] = (CARD8)n;\n\n  /* Send the list */\n  if (WriteExact(cl, (char *)cl->securityTypes, n + 1) < 0) {\n    rfbLogPerror(\"rfbSendSecurityTypeList: write\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  /* Dispatch client input to rfbProcessClientSecurityType() */\n  cl->state = RFB_SECURITY_TYPE;\n}\n\n\n#define WRITE(data, size)  \\\n  if (WriteExact(cl, (char *)data, size) <= 0) {  \\\n    rfbLogPerror(\"rfbVeNCryptAuthenticate: write\");  \\\n    rfbCloseClient(cl);  \\\n    return;  \\\n  }\n\n#define READ(data, size)  \\\n  if (ReadExact(cl, (char *)data, size) <= 0) {  \\\n    rfbLogPerror(\"rfbVeNCryptAuthenticate: read\");  \\\n    rfbCloseClient(cl);  \\\n    return;  \\\n  }\n\n#if USETLS\n#define TLS_INIT(anon)  \\\n  if ((ctx = rfbssl_init(cl, anon)) == NULL) {  \\\n    reply = 0;  \\\n    WRITE(&reply, 1);  \\\n    rfbClientAuthFailed(cl, rfbssl_geterr());  \\\n    return;  \\\n  }  \\\n  reply = 1;  \\\n  WRITE(&reply, 1);  \\\n  cl->sslctx = ctx;  \\\n  if ((ret = rfbssl_accept(cl)) < 0) {  \\\n    rfbCloseClient(cl);  \\\n    return;  \\\n  } else if (ret == 1) {  \\\n    rfbLog(\"Deferring TLS handshake\\n\");  \\\n    cl->state = RFB_TLS_HANDSHAKE;  \\\n    return;  \\\n  }\n\n\nvoid rfbAuthTLSHandshake(rfbClientPtr cl)\n{\n  int ret;\n\n  if ((ret = rfbssl_accept(cl)) < 0) {\n    rfbCloseClient(cl);\n    return;\n  } else if (ret == 1)\n    return;\n\n  switch (cl->selectedAuthType) {\n    case rfbAuthNone:\n      rfbClientAuthSucceeded(cl, rfbAuthNone);\n      break;\n    case rfbAuthVNC:\n      rfbVncAuthSendChallenge(cl);\n      break;\n#ifdef XVNC_AuthPAM\n    case rfbAuthUnixLogin:\n      AuthPAMUserPwdRspFunc(cl);\n      break;\n#endif\n  }\n}\n#endif\n\n\nvoid rfbVeNCryptAuthenticate(rfbClientPtr cl)\n{\n  struct {\n    CARD8 major, minor;\n  } serverVersion = { 0, 2 }, clientVersion = { 0, 0 };\n  CARD8 reply, count = 0;\n  int i, j;\n  SecTypeData *s;\n  CARD32 subTypes[MAX_VENCRYPT_SUBTYPES], chosenType = 0;\n#if USETLS\n  rfbSslCtx *ctx;\n  int ret;\n#endif\n\n  WRITE(&serverVersion.major, 1);\n  WRITE(&serverVersion.minor, 1);\n  rfbUncorkSock(cl->sock);\n  rfbCorkSock(cl->sock);\n  READ(&clientVersion, 2);\n\n  if (clientVersion.major == 0 && clientVersion.minor < 2) {\n    reply = 0xFF;\n    WRITE(&reply, 1);\n    rfbCloseClient(cl);\n    return;\n  } else {\n    reply = 0;\n    WRITE(&reply, 1);\n  }\n\n  memset(subTypes, 0, sizeof(CARD32) * MAX_VENCRYPT_SUBTYPES);\n  for (i = 0; i < preferenceLimit; i++) {\n    for (s = secTypes; s->name != NULL; s++) {\n      if (((s->preference != -1) && (i != s->preference)) || !s->enabled ||\n          s->subType == -1)\n        continue;\n\n      if (count > MAX_VENCRYPT_SUBTYPES)\n        FatalError(\"rfbVeNCryptAuthenticate: # enabled subtypes > MAX_VENCRYPT_SUBTYPES\");\n\n      /* Check whether we have already advertised this subtype */\n      for (j = 0; j < count; j++) {\n        if (subTypes[j] == s->subType)\n          break;\n      }\n      if (j < count)\n        continue;\n\n      subTypes[count++] = s->subType;\n    }\n  }\n\n  WRITE(&count, 1);\n  if (count > 0) {\n    for (i = 0; i < count; i++) {\n      CARD32 subType = Swap32IfLE(subTypes[i]);\n      WRITE(&subType, sizeof(CARD32));\n    }\n  }\n\n  rfbUncorkSock(cl->sock);\n  rfbCorkSock(cl->sock);\n  READ(&chosenType, sizeof(CARD32));\n  chosenType = Swap32IfLE(chosenType);\n\n  for (i = 0; i < count; i++) {\n    if (chosenType == subTypes[i])\n      break;\n  }\n  rfbLog(\"Client requested VeNCrypt sub-type %d\\n\", chosenType);\n  if (chosenType == 0 || chosenType == rfbSecTypeVeNCrypt || i >= count) {\n    rfbLog(\"Requested VeNCrypt sub-type not supported\\n\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  cl->selectedAuthType = chosenType;\n  switch (chosenType) {\n    case rfbAuthNone:\n      rfbClientAuthSucceeded(cl, rfbAuthNone);\n      break;\n    case rfbAuthVNC:\n      rfbVncAuthSendChallenge(cl);\n      break;\n#ifdef XVNC_AuthPAM\n    case rfbVeNCryptPlain:\n      AuthPAMUserPwdRspFunc(cl);\n      break;\n#endif\n#if USETLS\n    case rfbVeNCryptTLSNone:\n      cl->selectedAuthType = rfbAuthNone;\n      TLS_INIT(TRUE);\n      rfbClientAuthSucceeded(cl, rfbAuthNone);\n      break;\n    case rfbVeNCryptTLSVnc:\n      cl->selectedAuthType = rfbAuthVNC;\n      TLS_INIT(TRUE);\n      rfbVncAuthSendChallenge(cl);\n      break;\n#ifdef XVNC_AuthPAM\n    case rfbVeNCryptTLSPlain:\n      cl->selectedAuthType = rfbAuthUnixLogin;\n      TLS_INIT(TRUE);\n      AuthPAMUserPwdRspFunc(cl);\n      break;\n#endif\n    case rfbVeNCryptX509None:\n      cl->selectedAuthType = rfbAuthNone;\n      TLS_INIT(FALSE);\n      rfbClientAuthSucceeded(cl, rfbAuthNone);\n      break;\n    case rfbVeNCryptX509Vnc:\n      cl->selectedAuthType = rfbAuthVNC;\n      TLS_INIT(FALSE);\n      rfbVncAuthSendChallenge(cl);\n      break;\n#ifdef XVNC_AuthPAM\n    case rfbVeNCryptX509Plain:\n      cl->selectedAuthType = rfbAuthUnixLogin;\n      TLS_INIT(FALSE);\n      AuthPAMUserPwdRspFunc(cl);\n      break;\n#endif\n#endif\n    default:\n      FatalError(\"rfbVeNCryptAuthenticate: chosen type is invalid (this should never occur)\");\n  }\n}\n\n\n/*\n * Read the security type chosen by the client (protocol 3.7 and above)\n */\n\nvoid rfbProcessClientSecurityType(rfbClientPtr cl)\n{\n  int n, count, i;\n  CARD8 chosenType;\n\n  /* Read the security type */\n  n = ReadExact(cl, (char *)&chosenType, 1);\n  if (n <= 0) {\n    if (n == 0)\n      rfbLog(\"rfbProcessClientSecurityType: client gone\\n\");\n    else\n      rfbLogPerror(\"rfbProcessClientSecurityType: read\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  /* Make sure it was present in the list sent by the server */\n  count = (int)cl->securityTypes[0];\n  for (i = 1; i <= count; i++) {\n    if (chosenType == cl->securityTypes[i])\n      break;\n  }\n  if (i > count) {\n    rfbLog(\"rfbProcessClientSecurityType: wrong security type requested\\n\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  cl->selectedAuthType = chosenType;\n  switch (chosenType) {\n    case rfbSecTypeNone:\n      /* No authentication needed */\n      rfbClientAuthSucceeded(cl, rfbAuthNone);\n      break;\n    case rfbSecTypeVncAuth:\n      /* Begin the Standard VNC authentication procedure */\n      rfbVncAuthSendChallenge(cl);\n      break;\n    case rfbSecTypeTight:\n      /* The viewer supports TightVNC extensions */\n      rfbLog(\"Enabling TightVNC protocol extensions\\n\");\n      /* Switch to protocol 3.7t/3.8t */\n      cl->protocol_tightvnc = TRUE;\n      /* Advertise our tunneling capabilities */\n      rfbSendTunnelingCaps(cl);\n      break;\n    case rfbSecTypeVeNCrypt:\n      /* The viewer supports VeNCrypt extensions */\n      rfbLog(\"Enabling VeNCrypt protocol extensions\\n\");\n      rfbVeNCryptAuthenticate(cl);\n      break;\n    default:\n      rfbLog(\"rfbProcessClientSecurityType: unknown authentication scheme\\n\");\n      rfbCloseClient(cl);\n      break;\n  }\n}\n\n\n/*\n * Send the list of our tunneling capabilities (protocol 3.7t/3.8t)\n */\n\nstatic void rfbSendTunnelingCaps(rfbClientPtr cl)\n{\n  rfbTunnelingCapsMsg caps;\n  CARD32 nTypes = 0;            /* We don't support tunneling yet */\n\n  caps.nTunnelTypes = Swap32IfLE(nTypes);\n  if (WriteExact(cl, (char *)&caps, sz_rfbTunnelingCapsMsg) < 0) {\n    rfbLogPerror(\"rfbSendTunnelingCaps: write\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  if (nTypes)\n    /* Dispatch client input to rfbProcessClientTunnelingType() */\n    cl->state = RFB_TUNNELING_TYPE;\n  else\n    rfbSendAuthCaps(cl);\n}\n\n\n/*\n * Read tunneling type requested by the client (protocol 3.7t/3.8t)\n *\n * NOTE: Currently we don't support tunneling, and this function can never be\n * called.\n */\n\nvoid rfbProcessClientTunnelingType(rfbClientPtr cl)\n{\n  /* If we were called, then something's really wrong. */\n  rfbLog(\"rfbProcessClientTunnelingType: not implemented\\n\");\n  rfbCloseClient(cl);\n}\n\n\n/*\n * Send the list of our authentication capabilities to the client\n * (protocol 3.7t/3.8t)\n */\n\nstatic void rfbSendAuthCaps(rfbClientPtr cl)\n{\n  rfbAuthenticationCapsMsg caps;\n  rfbCapabilityInfo caplist[MAX_AUTH_CAPS];\n  int count = 0;\n  int j;\n  SecTypeData *s;\n  AuthCapData *c;\n  rfbCapabilityInfo *pcap;\n  char tempstr[9];\n\n  if (!cl->reverseConnection) {\n    int i;\n\n    /*\n     * When no preference order was set using \"permitted-security-types\",\n     * the default value of preferenceLimit (1) will cause us to execute\n     * the outer loop once.  In this case, the s->preference members will\n     * all be the default value (-1), and we skip the order testing.\n     */\n    for (i = 0; i < preferenceLimit; i++) {\n      for (s = secTypes; s->name != NULL; s++) {\n        if (((s->preference != -1) && (i != s->preference)) || !s->enabled)\n          continue;\n\n        c = s->authCap;\n\n        if (count > MAX_AUTH_CAPS)\n          FatalError(\"rfbSendAuthCaps: # enabled security types > MAX_AUTH_CAPS\");\n\n        /*\n         * Check to see if we have already advertised this auth cap.\n         * VNC password and OTP both use the VNC authentication cap.\n         */\n        for (j = 0; j < count; j++) {\n          if (cl->authCaps[j] == c->authType)\n            break;\n        }\n\n        if (j < count)\n          continue;\n\n        pcap = &caplist[count];\n        pcap->code = Swap32IfLE(c->authType);\n        memcpy(pcap->vendorSignature, c->vendorSignature,\n               sz_rfbCapabilityInfoVendor);\n        memcpy(pcap->nameSignature, c->nameSignature,\n               sz_rfbCapabilityInfoName);\n        cl->authCaps[count] = c->authType;\n        strncpy(tempstr, (char *)pcap->nameSignature, 8);\n        tempstr[8] = 0;\n        rfbLog(\"Advertising Tight auth cap '%s'\\n\", tempstr);\n        count++;\n      }\n    }\n\n    if (count == 0)\n      FatalError(\"rfbSendAuthCaps: authentication required but no security types enabled! This should not have happened!\");\n  }\n\n  cl->nAuthCaps = count;\n  caps.nAuthTypes = Swap32IfLE((CARD32)count);\n  if (WriteExact(cl, (char *)&caps, sz_rfbAuthenticationCapsMsg) < 0) {\n    rfbLogPerror(\"rfbSendAuthCaps: write\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  if (count) {\n    if (WriteExact(cl, (char *)&caplist[0], count *sz_rfbCapabilityInfo) < 0) {\n      rfbLogPerror(\"rfbSendAuthCaps: write\");\n      rfbCloseClient(cl);\n      return;\n    }\n    /* Dispatch client input to rfbProcessClientAuthType() */\n    cl->state = RFB_AUTH_TYPE;\n  } else {\n    /* No authentication needed */\n    rfbClientAuthSucceeded(cl, rfbAuthNone);\n    cl->state = RFB_INITIALISATION;\n  }\n}\n\n\n/*\n * Read client's preferred authentication type (protocol 3.7t/3.8t)\n */\n\nvoid rfbProcessClientAuthType(rfbClientPtr cl)\n{\n  CARD32 auth_type;\n  int n, i;\n  AuthCapData **p;\n  AuthCapData *c;\n\n  /* Read authentication type selected by the client */\n  n = ReadExact(cl, (char *)&auth_type, sizeof(auth_type));\n  if (n <= 0) {\n    if (n == 0)\n      rfbLog(\"rfbProcessClientAuthType: client gone\\n\");\n    else\n      rfbLogPerror(\"rfbProcessClientAuthType: read\");\n    rfbCloseClient(cl);\n    return;\n  }\n  auth_type = Swap32IfLE(auth_type);\n\n  /* Make sure it was present in the list sent by the server */\n  for (i = 0; i < cl->nAuthCaps; i++) {\n    if (auth_type == cl->authCaps[i])\n      break;\n  }\n  if (i >= cl->nAuthCaps) {\n    rfbLog(\"rfbProcessClientAuthType: wrong authentication type requested\\n\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  for (p = authCaps; *p != NULL; p++) {\n    c = *p;\n    if (auth_type == c->authType) {\n      cl->selectedAuthType = auth_type;\n      c->startFunc(cl);\n      return;\n    }\n  }\n\n  rfbLog(\"rfbProcessClientAuthType: unknown authentication scheme\\n\");\n  rfbCloseClient(cl);\n}\n\n\n/*\n * Send the authentication challenge\n */\n\nstatic void rfbVncAuthSendChallenge(rfbClientPtr cl)\n{\n  vncRandomBytes(cl->authChallenge);\n  if (WriteExact(cl, (char *)cl->authChallenge, CHALLENGESIZE) < 0) {\n    rfbLogPerror(\"rfbVncAuthSendChallenge: write\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  /* Dispatch client input to rfbVncAuthProcessResponse() */\n  cl->state = RFB_AUTHENTICATION;\n}\n\n\nstatic Bool CheckResponse(rfbClientPtr cl, int numPasswords,\n                          char *passwdFullControl, char *passwdViewOnly,\n                          CARD8 *response)\n{\n  Bool ok = FALSE;\n  CARD8 encryptedChallenge1[CHALLENGESIZE];\n  CARD8 encryptedChallenge2[CHALLENGESIZE];\n\n  memcpy(encryptedChallenge1, cl->authChallenge, CHALLENGESIZE);\n  vncEncryptBytes(encryptedChallenge1, passwdFullControl);\n  memcpy(encryptedChallenge2, cl->authChallenge, CHALLENGESIZE);\n  vncEncryptBytes(encryptedChallenge2,\n                  (numPasswords == 2) ? passwdViewOnly : passwdFullControl);\n\n  /* Delete the passwords from memory */\n  memset(passwdFullControl, 0, MAXPWLEN + 1);\n  memset(passwdViewOnly, 0, MAXPWLEN + 1);\n\n  if (memcmp(encryptedChallenge1, response, CHALLENGESIZE) == 0) {\n    rfbLog(\"Full-control authentication enabled for %s\\n\", cl->host);\n    ok = TRUE;\n    cl->viewOnly = FALSE;\n\n  } else if (memcmp(encryptedChallenge2, response, CHALLENGESIZE) == 0) {\n    rfbLog(\"View-only authentication enabled for %s\\n\", cl->host);\n    ok = TRUE;\n    cl->viewOnly = TRUE;\n  }\n\n  return ok;\n}\n\n\n/*\n * rfbVncAuthProcessResponse is called when the client sends its\n * authentication response.\n */\n\nvoid rfbVncAuthProcessResponse(rfbClientPtr cl)\n{\n  char passwdFullControl[MAXPWLEN + 1] = \"\\0\";\n  char passwdViewOnly[MAXPWLEN + 1] = \"\\0\";\n  int numPasswords;\n  Bool ok;\n  int n;\n  CARD8 response[CHALLENGESIZE];\n\n  n = ReadExact(cl, (char *)response, CHALLENGESIZE);\n  if (n <= 0) {\n    if (n != 0)\n      rfbLogPerror(\"rfbVncAuthProcessResponse: read\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  ok = FALSE;\n  if (rfbOptOtpAuth()) {\n    if (rfbAuthOTPValue == NULL) {\n      if (nSecTypesEnabled == 1) {\n        rfbClientAuthFailed(cl, \"The one-time password has not been set on the server\");\n        return;\n      }\n\n    } else {\n      memcpy(passwdFullControl, rfbAuthOTPValue, MAXPWLEN);\n      passwdFullControl[MAXPWLEN] = '\\0';\n      numPasswords = rfbAuthOTPValueLen / MAXPWLEN;\n      if (numPasswords > 1) {\n        memcpy(passwdViewOnly, rfbAuthOTPValue + MAXPWLEN, MAXPWLEN);\n        passwdViewOnly[MAXPWLEN] = '\\0';\n      }\n\n      ok = CheckResponse(cl, numPasswords, passwdFullControl, passwdViewOnly,\n                         response);\n      if (ok) {\n        memset(rfbAuthOTPValue, 0, rfbAuthOTPValueLen);\n        free(rfbAuthOTPValue);\n        rfbAuthOTPValue = NULL;\n      }\n    }\n  }\n\n  if ((ok == FALSE) && rfbOptRfbAuth()) {\n    if (!rfbAuthPasswdFile) {\n      rfbClientAuthFailed(cl, \"No VNC password file specified on the server (did you forget -rfbauth?)\");\n      return;\n    }\n\n    numPasswords = vncDecryptPasswdFromFile2(rfbAuthPasswdFile,\n                                             passwdFullControl,\n                                             passwdViewOnly);\n    if (numPasswords == 0) {\n      rfbLog(\"rfbVncAuthProcessResponse: could not get password from %s\\n\",\n             rfbAuthPasswdFile);\n\n      if (nSecTypesEnabled == 1) {\n        rfbClientAuthFailed(cl, \"The server could not read the VNC password file\");\n        return;\n      }\n    }\n\n    ok = CheckResponse(cl, numPasswords, passwdFullControl, passwdViewOnly,\n                       response);\n  }\n\n  if (ok) {\n    rfbAuthUnblock();\n    rfbClientAuthSucceeded(cl, rfbAuthVNC);\n  } else {\n    rfbLog(\"rfbVncAuthProcessResponse: authentication failed from %s\\n\",\n           cl->host);\n    if (rfbAuthConsiderBlocking())\n      rfbClientAuthFailed(cl, \"Authentication failed.  Too many tries\");\n    else\n      rfbClientAuthFailed(cl, \"Authentication failed\");\n  }\n}\n\n\n/*\n * rfbClientConnFailed is called when a client connection has failed before\n * the authentication stage.\n */\n\nvoid rfbClientConnFailed(rfbClientPtr cl, char *reason)\n{\n  int headerLen, reasonLen;\n  char buf[8];\n  CARD32 *buf32 = (CARD32 *)buf;\n\n  headerLen = (cl->protocol_minor_ver >= 7) ? 1 : 4;\n  reasonLen = strlen(reason);\n  buf32[0] = 0;\n  buf32[1] = Swap32IfLE(reasonLen);\n\n  if (WriteExact(cl, buf, headerLen) < 0 || WriteExact(cl, buf + 4, 4) < 0 ||\n      WriteExact(cl, reason, reasonLen) < 0)\n    rfbLogPerror(\"rfbClientConnFailed: write\");\n\n  rfbCloseClient(cl);\n}\n\n\n/*\n * rfbClientAuthFailed is called on authentication failure.  Sending a reason\n * string is defined in RFB 3.8 and above.\n */\n\nvoid rfbClientAuthFailed(rfbClientPtr cl, char *reason)\n{\n  int reasonLen;\n  char buf[8];\n  CARD32 *buf32 = (CARD32 *)buf;\n\n  if (cl->protocol_minor_ver < 8)\n    reason = NULL;              /* invalidate the pointer */\n\n  reasonLen = (reason == NULL) ? 0 : strlen(reason);\n  buf32[0] = Swap32IfLE(rfbAuthFailed);\n  buf32[1] = Swap32IfLE(reasonLen);\n\n  if (reasonLen == 0) {\n    if (WriteExact(cl, buf, 4) < 0)\n      rfbLogPerror(\"rfbClientAuthFailed: write\");\n  } else {\n    if (WriteExact(cl, buf, 8) < 0 || WriteExact(cl, reason, reasonLen) < 0)\n      rfbLogPerror(\"rfbClientAuthFailed: write\");\n  }\n\n  rfbCloseClient(cl);\n}\n\n\n/*\n * rfbClientAuthSucceeded is called on successful authentication.  It just\n * sends rfbAuthOK and dispatches client input to\n * rfbProcessClientInitMessage().  However, the rfbAuthOK message is not sent\n * if authentication was not required and the protocol version is 3.7 or lower.\n */\n\nvoid rfbClientAuthSucceeded(rfbClientPtr cl, CARD32 authType)\n{\n  CARD32 authResult;\n\n  if (cl->protocol_minor_ver >= 8 || authType == rfbAuthVNC) {\n    authResult = Swap32IfLE(rfbAuthOK);\n    if (WriteExact(cl, (char *)&authResult, 4) < 0) {\n      rfbLogPerror(\"rfbClientAuthSucceeded: write\");\n      rfbCloseClient(cl);\n      return;\n    }\n  }\n\n  /* Dispatch client input to rfbProcessClientInitMessage() */\n  cl->state = RFB_INITIALISATION;\n}\n\n\n/*********************************************************************\n * Functions to prevent too many successive authentication failures.\n *\n * FIXME: This should be performed separately for each client.\n */\n\n/* Maximum authentication failures before blocking connections */\n#define MAX_AUTH_TRIES 5\n\n/* Delay in ms.  This doubles for each failure over MAX_AUTH_TRIES. */\n#define AUTH_TOO_MANY_BASE_DELAY 10 * 1000\n\nstatic int rfbAuthTries = 0;\nstatic Bool rfbAuthTooManyTries = FALSE;\nstatic OsTimerPtr timer = NULL;\n\n\n/*\n * This function should not be called directly.  It is called by setting a\n * timer in rfbAuthConsiderBlocking().\n */\n\nstatic CARD32 rfbAuthReenable(OsTimerPtr timer, CARD32 now, pointer arg)\n{\n  rfbAuthTooManyTries = FALSE;\n  return 0;\n}\n\n\n/*\n * This function should be called after each authentication failure.  The\n * return value will be true if there were too many failures.\n */\n\nBool rfbAuthConsiderBlocking(void)\n{\n  int i;\n\n  rfbAuthTries++;\n\n  if (rfbAuthTries >= MAX_AUTH_TRIES) {\n    CARD32 delay = AUTH_TOO_MANY_BASE_DELAY;\n\n    for (i = MAX_AUTH_TRIES; i < rfbAuthTries; i++)\n      delay *= 2;\n    timer = TimerSet(timer, 0, delay, rfbAuthReenable, NULL);\n    rfbAuthTooManyTries = TRUE;\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\n\n/*\n * This function should be called after a successful authentication.  It\n * resets the counter of authentication failures.  Note that it's not necessary\n * to clear the rfbAuthTooManyTries flag, as it will be reset by the timer\n * function.\n */\n\nvoid rfbAuthUnblock(void)\n{\n  rfbAuthTries = 0;\n}\n\n\n/*\n * This function should be called before authentication.  The return value will\n * be true if there were too many authentication failures, and the server\n * should not allow another try.\n */\n\nBool rfbAuthIsBlocked(void)\n{\n  return rfbAuthTooManyTries;\n}\n", "/*\n * rfbserver.c - deal with server-side of the RFB protocol.\n */\n\n/*\n *  Copyright (C) 2009-2019 D. R. Commander.  All Rights Reserved.\n *  Copyright (C) 2010 University Corporation for Atmospheric Research.\n *                     All Rights Reserved.\n *  Copyright (C) 2005-2008 Sun Microsystems, Inc.  All Rights Reserved.\n *  Copyright (C) 2004 Landmark Graphics Corporation.  All Rights Reserved.\n *  Copyright (C) 2000-2006 Constantin Kaplinsky.  All Rights Reserved.\n *  Copyright (C) 2000 Tridia Corporation.  All Rights Reserved.\n *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n *  USA.\n */\n\n#ifdef HAVE_DIX_CONFIG_H\n#include <dix-config.h>\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <arpa/inet.h>\n#include \"windowstr.h\"\n#include \"rfb.h\"\n#include \"sprite.h\"\n\n/* #define GII_DEBUG */\n\nchar updateBuf[UPDATE_BUF_SIZE];\nint ublen;\n\nrfbClientPtr rfbClientHead = NULL;\nrfbClientPtr pointerClient = NULL;  /* Mutex for pointer events */\n\nBool rfbAlwaysShared = FALSE;\nBool rfbNeverShared = FALSE;\nBool rfbDontDisconnect = TRUE;\nBool rfbViewOnly = FALSE;  /* run server in view only mode - Ehud Karni SW */\nBool rfbSyncCutBuffer = TRUE;\nBool rfbCongestionControl = TRUE;\ndouble rfbAutoLosslessRefresh = 0.0;\nint rfbALRQualityLevel = -1;\nint rfbALRSubsampLevel = TVNC_1X;\nint rfbCombineRect = 100;\nint rfbICEBlockSize = 256;\nBool rfbInterframeDebug = FALSE;\nint rfbMaxWidth = MAXSHORT, rfbMaxHeight = MAXSHORT;\nint rfbMaxClipboard = MAX_CUTTEXT_LEN;\nBool rfbVirtualTablet = FALSE;\nBool rfbMT = TRUE;\nint rfbNumThreads = 0;\n\nstatic rfbClientPtr rfbNewClient(int sock);\nstatic void rfbProcessClientProtocolVersion(rfbClientPtr cl);\nstatic void rfbProcessClientInitMessage(rfbClientPtr cl);\nstatic void rfbSendInteractionCaps(rfbClientPtr cl);\nstatic void rfbProcessClientNormalMessage(rfbClientPtr cl);\nstatic Bool rfbSendCopyRegion(rfbClientPtr cl, RegionPtr reg, int dx, int dy);\nstatic Bool rfbSendLastRectMarker(rfbClientPtr cl);\nBool rfbSendDesktopSize(rfbClientPtr cl);\nBool rfbSendExtDesktopSize(rfbClientPtr cl);\n\n\n/*\n * Session capture\n */\n\nchar *captureFile = NULL;\n\nstatic void WriteCapture(int captureFD, char *buf, int len)\n{\n  if (write(captureFD, buf, len) < len)\n    rfbLogPerror(\"WriteCapture: Could not write to capture file\");\n}\n\n\n/*\n * Idle timeout\n */\n\nCARD32 rfbMaxIdleTimeout = 0;\nCARD32 rfbIdleTimeout = 0;\nstatic double idleTimeout = -1.0;\n\nvoid IdleTimerSet(void)\n{\n  idleTimeout = gettime() + (double)rfbIdleTimeout;\n}\n\nstatic void IdleTimerCancel(void)\n{\n  idleTimeout = -1.0;\n}\n\nvoid IdleTimerCheck(void)\n{\n  if (idleTimeout >= 0.0 && gettime() >= idleTimeout)\n    FatalError(\"TurboVNC session has been idle for %u seconds.  Exiting.\",\n               (unsigned int)rfbIdleTimeout);\n}\n\n\n/*\n * Profiling stuff\n */\n\nstatic BOOL rfbProfile = FALSE;\nstatic double tUpdate = 0., tStart = -1., tElapsed, mpixels = 0.,\n  idmpixels = 0.;\nstatic unsigned long iter = 0;\nunsigned long long sendBytes = 0;\n\ndouble gettime(void)\n{\n  struct timeval __tv;\n\n  gettimeofday(&__tv, (struct timezone *)NULL);\n  return (double)__tv.tv_sec + (double)__tv.tv_usec * 0.000001;\n}\n\n\n/*\n * Auto Lossless Refresh\n */\n\nstatic Bool putImageOnly = TRUE, alrCopyRect = TRUE;\n\nstatic CARD32 alrCallback(OsTimerPtr timer, CARD32 time, pointer arg)\n{\n  RegionRec copyRegionSave, modifiedRegionSave, requestedRegionSave,\n    ifRegionSave;\n  rfbClientPtr cl = (rfbClientPtr)arg;\n  int tightCompressLevelSave, tightQualityLevelSave, copyDXSave, copyDYSave,\n    tightSubsampLevelSave;\n  RegionRec tmpRegion;\n\n  REGION_INIT(pScreen, &tmpRegion, NullBox, 0);\n  if (putImageOnly && !cl->firstUpdate)\n    REGION_INTERSECT(pScreen, &tmpRegion, &cl->alrRegion, &cl->lossyRegion);\n  else\n    REGION_COPY(pScreen, &tmpRegion, &cl->lossyRegion);\n  if (cl->firstUpdate) cl->firstUpdate = FALSE;\n\n  if (REGION_NOTEMPTY(pScreen, &tmpRegion)) {\n\n    tightCompressLevelSave = cl->tightCompressLevel;\n    tightQualityLevelSave = cl->tightQualityLevel;\n    tightSubsampLevelSave = cl->tightSubsampLevel;\n    copyDXSave = cl->copyDX;\n    copyDYSave = cl->copyDY;\n    REGION_INIT(pScreen, &copyRegionSave, NullBox, 0);\n    REGION_COPY(pScreen, &copyRegionSave, &cl->copyRegion);\n    REGION_INIT(pScreen, &modifiedRegionSave, NullBox, 0);\n    REGION_COPY(pScreen, &modifiedRegionSave, &cl->modifiedRegion);\n    REGION_INIT(pScreen, &requestedRegionSave, NullBox, 0);\n    REGION_COPY(pScreen, &requestedRegionSave, &cl->requestedRegion);\n    REGION_INIT(pScreen, &ifRegionSave, NullBox, 0);\n    REGION_COPY(pScreen, &ifRegionSave, &cl->ifRegion);\n\n    cl->tightCompressLevel = 1;\n    cl->tightQualityLevel = rfbALRQualityLevel;\n    cl->tightSubsampLevel = rfbALRSubsampLevel;\n    cl->copyDX = cl->copyDY = 0;\n    REGION_EMPTY(pScreen, &cl->copyRegion);\n    REGION_EMPTY(pScreen, &cl->modifiedRegion);\n    REGION_UNION(pScreen, &cl->modifiedRegion, &cl->modifiedRegion,\n                 &tmpRegion);\n    REGION_EMPTY(pScreen, &cl->requestedRegion);\n    REGION_UNION(pScreen, &cl->requestedRegion, &cl->requestedRegion,\n                 &tmpRegion);\n    if (cl->compareFB) {\n      REGION_EMPTY(pScreen, &cl->ifRegion);\n      REGION_UNION(pScreen, &cl->ifRegion, &cl->ifRegion, &tmpRegion);\n    }\n\n    if (!rfbSendFramebufferUpdate(cl)) return 0;\n\n    REGION_EMPTY(pScreen, &cl->lossyRegion);\n    REGION_EMPTY(pScreen, &cl->alrRegion);\n    cl->tightCompressLevel = tightCompressLevelSave;\n    cl->tightQualityLevel = tightQualityLevelSave;\n    cl->tightSubsampLevel = tightSubsampLevelSave;\n    cl->copyDX = copyDXSave;\n    cl->copyDY = copyDYSave;\n    REGION_COPY(pScreen, &cl->copyRegion, &copyRegionSave);\n    REGION_COPY(pScreen, &cl->modifiedRegion, &modifiedRegionSave);\n    REGION_COPY(pScreen, &cl->requestedRegion, &requestedRegionSave);\n    REGION_UNINIT(pScreen, &copyRegionSave);\n    REGION_UNINIT(pScreen, &modifiedRegionSave);\n    REGION_UNINIT(pScreen, &requestedRegionSave);\n    if (cl->compareFB) {\n      REGION_COPY(pScreen, &cl->ifRegion, &ifRegionSave);\n      REGION_UNINIT(pScreen, &ifRegionSave);\n    }\n  }\n\n  REGION_UNINIT(pScreen, &tmpRegion);\n  return 0;\n}\n\n\nstatic CARD32 updateCallback(OsTimerPtr timer, CARD32 time, pointer arg)\n{\n  rfbClientPtr cl = (rfbClientPtr)arg;\n\n  rfbSendFramebufferUpdate(cl);\n  return 0;\n}\n\n\n/*\n * Interframe comparison\n */\n\nint rfbInterframe = -1;  /* -1 = auto (determined by compression level) */\n\nBool InterframeOn(rfbClientPtr cl)\n{\n  if (!cl->compareFB) {\n    if (!(cl->compareFB =\n          (char *)malloc(rfbFB.paddedWidthInBytes * rfbFB.height))) {\n      rfbLogPerror(\"InterframeOn: couldn't allocate comparison buffer\");\n      return FALSE;\n    }\n    memset(cl->compareFB, 0, rfbFB.paddedWidthInBytes * rfbFB.height);\n    REGION_INIT(pScreen, &cl->ifRegion, NullBox, 0);\n    cl->firstCompare = TRUE;\n    rfbLog(\"Interframe comparison enabled\\n\");\n  }\n  cl->fb = cl->compareFB;\n  return TRUE;\n}\n\nvoid InterframeOff(rfbClientPtr cl)\n{\n  if (cl->compareFB) {\n    free(cl->compareFB);\n    REGION_UNINIT(pScreen, &cl->ifRegion);\n    rfbLog(\"Interframe comparison disabled\\n\");\n  }\n  cl->compareFB = NULL;\n  cl->fb = rfbFB.pfbMemory;\n}\n\n\n/*\n * Map of quality levels to provide compatibility with TightVNC/TigerVNC\n * clients\n */\n\nstatic int JPEG_QUAL[10] = {\n  15, 29, 41, 42, 62, 77, 79, 86, 92, 100\n};\n\nstatic int JPEG_SUBSAMP[10] = {\n  1, 1, 1, 2, 2, 2, 0, 0, 0, 0\n};\n\n\n/*\n * rfbNewClientConnection is called from sockets.c when a new connection\n * comes in.\n */\n\nvoid rfbNewClientConnection(int sock)\n{\n  rfbNewClient(sock);\n}\n\n\n/*\n * rfbReverseConnection is called to make an outward connection to a\n * \"listening\" RFB client.\n */\n\nrfbClientPtr rfbReverseConnection(char *host, int port, int id)\n{\n  int sock;\n  rfbClientPtr cl;\n\n  if (rfbAuthDisableRevCon) {\n    rfbLog(\"Reverse connections disabled\\n\");\n    return (rfbClientPtr)NULL;\n  }\n\n  if ((sock = rfbConnect(host, port)) < 0)\n    return (rfbClientPtr)NULL;\n\n  if (id > 0) {\n    rfbClientRec cl;\n    char temps[250];\n    memset(temps, 0, 250);\n    snprintf(temps, 250, \"ID:%d\", id);\n    rfbLog(\"UltraVNC Repeater Mode II ID is %d\\n\", id);\n    cl.sock = sock;\n    if (WriteExact(&cl, temps, 250) < 0) {\n      rfbLogPerror(\"rfbReverseConnection: write\");\n      rfbCloseSock(sock);\n      return NULL;\n    }\n  }\n\n  cl = rfbNewClient(sock);\n\n  if (cl)\n    cl->reverseConnection = TRUE;\n\n  return cl;\n}\n\n\n/*\n * rfbNewClient is called when a new connection has been made by whatever\n * means.\n */\n\nstatic rfbClientPtr rfbNewClient(int sock)\n{\n  rfbProtocolVersionMsg pv;\n  rfbClientPtr cl;\n  BoxRec box;\n  rfbSockAddr addr;\n  socklen_t addrlen = sizeof(struct sockaddr_storage);\n  char addrStr[INET6_ADDRSTRLEN];\n  char *env = NULL;\n  int np = sysconf(_SC_NPROCESSORS_CONF);\n\n  if (rfbClientHead == NULL)\n    /* no other clients - make sure we don't think any keys are pressed */\n    KbdReleaseAllKeys();\n\n  cl = (rfbClientPtr)rfbAlloc0(sizeof(rfbClientRec));\n\n  if (rfbClientHead == NULL && captureFile) {\n    cl->captureFD = open(captureFile, O_CREAT | O_EXCL | O_WRONLY,\n                         S_IRUSR | S_IWUSR);\n    if (cl->captureFD < 0)\n      rfbLogPerror(\"Could not open capture file\");\n    else\n      rfbLog(\"Opened capture file %s\\n\", captureFile);\n  } else\n    cl->captureFD = -1;\n\n  cl->sock = sock;\n  getpeername(sock, &addr.u.sa, &addrlen);\n  cl->host = strdup(sockaddr_string(&addr, addrStr, INET6_ADDRSTRLEN));\n\n  /* Dispatch client input to rfbProcessClientProtocolVersion(). */\n  cl->state = RFB_PROTOCOL_VERSION;\n\n  cl->preferredEncoding = rfbEncodingTight;\n  cl->correMaxWidth = 48;\n  cl->correMaxHeight = 48;\n\n  REGION_INIT(pScreen, &cl->copyRegion, NullBox, 0);\n\n  box.x1 = box.y1 = 0;\n  box.x2 = rfbFB.width;\n  box.y2 = rfbFB.height;\n  REGION_INIT(pScreen, &cl->modifiedRegion, &box, 0);\n\n  REGION_INIT(pScreen, &cl->requestedRegion, NullBox, 0);\n\n  cl->deferredUpdateStart = gettime();\n\n  cl->format = rfbServerFormat;\n  cl->translateFn = rfbTranslateNone;\n\n  cl->tightCompressLevel = TIGHT_DEFAULT_COMPRESSION;\n  cl->tightSubsampLevel = TIGHT_DEFAULT_SUBSAMP;\n  cl->tightQualityLevel = -1;\n  cl->imageQualityLevel = -1;\n\n  cl->next = rfbClientHead;\n  cl->prev = NULL;\n  if (rfbClientHead)\n    rfbClientHead->prev = cl;\n  rfbClientHead = cl;\n\n  rfbResetStats(cl);\n\n  cl->zlibCompressLevel = 5;\n\n  sprintf(pv, rfbProtocolVersionFormat, 3, 8);\n\n  if (WriteExact(cl, pv, sz_rfbProtocolVersionMsg) < 0) {\n    rfbLogPerror(\"rfbNewClient: write\");\n    rfbCloseClient(cl);\n    return NULL;\n  }\n\n  if ((env = getenv(\"TVNC_PROFILE\")) != NULL && !strcmp(env, \"1\"))\n    rfbProfile = TRUE;\n\n  if ((env = getenv(\"TVNC_ICEDEBUG\")) != NULL && !strcmp(env, \"1\"))\n    rfbInterframeDebug = TRUE;\n\n  if ((env = getenv(\"TVNC_ICEBLOCKSIZE\")) != NULL) {\n    int iceBlockSize = atoi(env);\n    if (iceBlockSize >= 0) rfbICEBlockSize = iceBlockSize;\n  }\n\n  if ((env = getenv(\"TVNC_COMBINERECT\")) != NULL) {\n    int combine = atoi(env);\n    if (combine > 0 && combine <= 65000) rfbCombineRect = combine;\n  }\n\n  cl->firstUpdate = TRUE;\n  /* The TigerVNC Viewer won't enable remote desktop resize until it receives\n     a desktop resize message from the server, so we give it one with the\n     first FBU. */\n  cl->reason = rfbEDSReasonServer;\n  cl->result = rfbEDSResultSuccess;\n\n  if (rfbAutoLosslessRefresh > 0.0) {\n    REGION_INIT(pScreen, &cl->lossyRegion, NullBox, 0);\n    if ((env = getenv(\"TVNC_ALRALL\")) != NULL && !strcmp(env, \"1\"))\n      putImageOnly = FALSE;\n    if ((env = getenv(\"TVNC_ALRCOPYRECT\")) != NULL && !strcmp(env, \"0\"))\n      alrCopyRect = FALSE;\n    REGION_INIT(pScreen, &cl->alrRegion, NullBox, 0);\n    REGION_INIT(pScreen, &cl->alrEligibleRegion, NullBox, 0);\n  }\n\n  if ((env = getenv(\"TVNC_MT\")) != NULL && !strcmp(env, \"0\"))\n    rfbMT = FALSE;\n\n  if ((env = getenv(\"TVNC_NTHREADS\")) != NULL && strlen(env) >= 1) {\n    int temp = atoi(env);\n    if (temp >= 1 && temp <= MAX_ENCODING_THREADS)\n      rfbNumThreads = temp;\n    else\n      rfbLog(\"WARNING: Invalid value of TVNC_NTHREADS (%s) ignored\\n\", env);\n  }\n\n  if (np == -1 && rfbMT) {\n    rfbLog(\"WARNING: Could not determine CPU count.  Multithreaded encoding disabled.\\n\");\n    rfbMT = FALSE;\n  }\n  if (!rfbMT) rfbNumThreads = 1;\n  else if (rfbNumThreads < 1) rfbNumThreads = min(np, 4);\n  if (rfbNumThreads > np) {\n    rfbLog(\"NOTICE: Encoding thread count has been clamped to CPU count\\n\");\n    rfbNumThreads = np;\n  }\n\n  if (rfbIdleTimeout > 0)\n    IdleTimerCancel();\n\n  cl->baseRTT = cl->minRTT = (unsigned)-1;\n  gettimeofday(&cl->lastWrite, NULL);\n  REGION_INIT(pScreen, &cl->cuRegion, NullBox, 0);\n\n  if (rfbInterframe == 1) {\n    if (!InterframeOn(cl)) {\n      rfbCloseClient(cl);\n      return NULL;\n    }\n  } else\n    InterframeOff(cl);\n\n  return cl;\n}\n\n\n/*\n * rfbClientConnectionGone is called from sockets.c just after a connection\n * has gone away.\n */\n\nvoid rfbClientConnectionGone(rfbClientPtr cl)\n{\n  int i;\n\n  if (cl->prev)\n    cl->prev->next = cl->next;\n  else\n    rfbClientHead = cl->next;\n  if (cl->next)\n    cl->next->prev = cl->prev;\n\n  TimerFree(cl->alrTimer);\n  TimerFree(cl->deferredUpdateTimer);\n  TimerFree(cl->updateTimer);\n  TimerFree(cl->congestionTimer);\n\n#ifdef XVNC_AuthPAM\n  rfbPAMEnd(cl);\n#endif\n  if (cl->login != NULL) {\n    rfbLog(\"Client %s (%s) gone\\n\", cl->login, cl->host);\n    free(cl->login);\n  } else {\n    rfbLog(\"Client %s gone\\n\", cl->host);\n  }\n  free(cl->host);\n\n  ShutdownTightThreads();\n\n  if (rfbAutoLosslessRefresh > 0.0) {\n    REGION_UNINIT(pScreen, &cl->lossyRegion);\n    REGION_UNINIT(pScreen, &cl->alrRegion);\n    REGION_UNINIT(pScreen, &cl->alrEligibleRegion);\n  }\n\n  /* Release the compression state structures if any. */\n  if (cl->compStreamInited == TRUE)\n    deflateEnd(&(cl->compStream));\n\n  for (i = 0; i < 4; i++) {\n    if (cl->zsActive[i])\n      deflateEnd(&cl->zsStruct[i]);\n  }\n\n  if (pointerClient == cl)\n    pointerClient = NULL;\n\n  REGION_UNINIT(pScreen, &cl->copyRegion);\n  REGION_UNINIT(pScreen, &cl->modifiedRegion);\n\n  rfbPrintStats(cl);\n\n  if (cl->translateLookupTable) free(cl->translateLookupTable);\n\n  rfbFreeZrleData(cl);\n\n  if (cl->cutText)\n    free(cl->cutText);\n\n  InterframeOff(cl);\n\n  i = cl->numDevices;\n  while (i-- > 0)\n    RemoveExtInputDevice(cl, 0);\n\n  if (cl->captureFD >= 0)\n    close(cl->captureFD);\n\n  free(cl);\n\n  if (rfbClientHead == NULL && rfbIdleTimeout > 0)\n    IdleTimerSet();\n}\n\n\n/*\n * rfbProcessClientMessage is called when there is data to read from a client.\n */\n\nvoid rfbProcessClientMessage(rfbClientPtr cl)\n{\n  rfbCorkSock(cl->sock);\n\n  if (cl->pendingSyncFence) {\n    cl->syncFence = TRUE;\n    cl->pendingSyncFence = FALSE;\n  }\n\n  switch (cl->state) {\n    case RFB_PROTOCOL_VERSION:\n      rfbProcessClientProtocolVersion(cl);\n      break;\n    case RFB_SECURITY_TYPE:     /* protocol versions 3.7 and above */\n      rfbProcessClientSecurityType(cl);\n      break;\n    case RFB_TUNNELING_TYPE:    /* protocol versions 3.7t, 3.8t */\n      rfbProcessClientTunnelingType(cl);\n      break;\n    case RFB_AUTH_TYPE:         /* protocol versions 3.7t, 3.8t */\n      rfbProcessClientAuthType(cl);\n      break;\n#if USETLS\n    case RFB_TLS_HANDSHAKE:\n      rfbAuthTLSHandshake(cl);\n      break;\n#endif\n    case RFB_AUTHENTICATION:\n      rfbAuthProcessResponse(cl);\n      break;\n    case RFB_INITIALISATION:\n      rfbInitFlowControl(cl);\n      rfbProcessClientInitMessage(cl);\n      break;\n    default:\n      rfbProcessClientNormalMessage(cl);\n  }\n\n  CHECK_CLIENT_PTR(cl, return)\n\n  if (cl->syncFence) {\n    if (!rfbSendFence(cl, cl->fenceFlags, cl->fenceDataLen, cl->fenceData))\n      return;\n    cl->syncFence = FALSE;\n  }\n\n  rfbUncorkSock(cl->sock);\n}\n\n\n/*\n * rfbProcessClientProtocolVersion is called when the client sends its\n * protocol version.\n */\n\nstatic void rfbProcessClientProtocolVersion(rfbClientPtr cl)\n{\n  rfbProtocolVersionMsg pv;\n  int n, major, minor;\n\n  if ((n = ReadExact(cl, pv, sz_rfbProtocolVersionMsg)) <= 0) {\n    if (n == 0)\n      rfbLog(\"rfbProcessClientProtocolVersion: client gone\\n\");\n    else\n      rfbLogPerror(\"rfbProcessClientProtocolVersion: read\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  pv[sz_rfbProtocolVersionMsg] = 0;\n  if (sscanf(pv, rfbProtocolVersionFormat, &major, &minor) != 2) {\n    rfbLog(\"rfbProcessClientProtocolVersion: not a valid RFB client\\n\");\n    rfbCloseClient(cl);\n    return;\n  }\n  if (major != 3) {\n    rfbLog(\"Unsupported protocol version %d.%d\\n\", major, minor);\n    rfbCloseClient(cl);\n    return;\n  }\n\n  /* Always use one of the three standard versions of the RFB protocol. */\n  cl->protocol_minor_ver = minor;\n\n  if (minor > 8)                        /* buggy client */\n    cl->protocol_minor_ver = 8;\n  else if (minor > 3 && minor < 7)      /* non-standard client */\n    cl->protocol_minor_ver = 3;\n  else if (minor < 3)                   /* ancient client */\n    cl->protocol_minor_ver = 3;\n\n  if (cl->protocol_minor_ver != minor)\n    rfbLog(\"Non-standard protocol version 3.%d, using 3.%d instead\\n\", minor,\n           cl->protocol_minor_ver);\n  else\n    rfbLog(\"Using protocol version 3.%d\\n\", cl->protocol_minor_ver);\n\n  /* TightVNC protocol extensions are not enabled yet. */\n  cl->protocol_tightvnc = FALSE;\n\n  rfbAuthNewClient(cl);\n}\n\n\n/*\n * rfbProcessClientInitMessage is called when the client sends its\n * initialisation message.\n */\n\nstatic void rfbProcessClientInitMessage(rfbClientPtr cl)\n{\n  rfbClientInitMsg ci;\n  char buf[256];\n  rfbServerInitMsg *si = (rfbServerInitMsg *)buf;\n  int len, n;\n  rfbClientPtr otherCl, nextCl;\n\n  if ((n = ReadExact(cl, (char *)&ci, sz_rfbClientInitMsg)) <= 0) {\n    if (n == 0)\n      rfbLog(\"rfbProcessClientInitMessage: client gone\\n\");\n    else\n      rfbLogPerror(\"rfbProcessClientInitMessage: read\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  si->framebufferWidth = Swap16IfLE(rfbFB.width);\n  si->framebufferHeight = Swap16IfLE(rfbFB.height);\n  si->format = rfbServerFormat;\n  si->format.redMax = Swap16IfLE(si->format.redMax);\n  si->format.greenMax = Swap16IfLE(si->format.greenMax);\n  si->format.blueMax = Swap16IfLE(si->format.blueMax);\n\n  if (strlen(desktopName) > 128)        /* sanity check on desktop name len */\n    desktopName[128] = 0;\n\n  sprintf(buf + sz_rfbServerInitMsg, \"%s\", desktopName);\n\n  len = strlen(buf + sz_rfbServerInitMsg);\n  si->nameLength = Swap32IfLE(len);\n\n  if (WriteExact(cl, buf, sz_rfbServerInitMsg + len) < 0) {\n    rfbLogPerror(\"rfbProcessClientInitMessage: write\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  if (cl->protocol_tightvnc)\n    rfbSendInteractionCaps(cl);  /* protocol 3.7t */\n\n  /* Dispatch client input to rfbProcessClientNormalMessage(). */\n  cl->state = RFB_NORMAL;\n\n  if (!cl->reverseConnection &&\n      (rfbNeverShared || (!rfbAlwaysShared && !ci.shared))) {\n\n    if (rfbDontDisconnect) {\n      for (otherCl = rfbClientHead; otherCl; otherCl = otherCl->next) {\n        if ((otherCl != cl) && (otherCl->state == RFB_NORMAL)) {\n          rfbLog(\"-dontdisconnect: Not shared & existing client\\n\");\n          rfbLog(\"  refusing new client %s\\n\", cl->host);\n          rfbCloseClient(cl);\n          return;\n        }\n      }\n    } else {\n      for (otherCl = rfbClientHead; otherCl; otherCl = nextCl) {\n        nextCl = otherCl->next;\n        if ((otherCl != cl) && (otherCl->state == RFB_NORMAL)) {\n          rfbLog(\"Not shared - closing connection to client %s\\n\",\n                 otherCl->host);\n          rfbCloseClient(otherCl);\n        }\n      }\n    }\n  }\n}\n\n\n/*\n * rfbSendInteractionCaps is called after sending the server\n * initialisation message, only if TightVNC protocol extensions were\n * enabled (protocol versions 3.7t, 3.8t). In this function, we send\n * the lists of supported protocol messages and encodings.\n */\n\n/* Update these constants on changing capability lists below! */\n#define N_SMSG_CAPS  0\n#define N_CMSG_CAPS  0\n#define N_ENC_CAPS  17\n\nvoid rfbSendInteractionCaps(rfbClientPtr cl)\n{\n  rfbInteractionCapsMsg intr_caps;\n  rfbCapabilityInfo enc_list[N_ENC_CAPS];\n  int i;\n\n  /* Fill in the header structure sent prior to capability lists. */\n  intr_caps.nServerMessageTypes = Swap16IfLE(N_SMSG_CAPS);\n  intr_caps.nClientMessageTypes = Swap16IfLE(N_CMSG_CAPS);\n  intr_caps.nEncodingTypes = Swap16IfLE(N_ENC_CAPS);\n  intr_caps.pad = 0;\n\n  /* Supported server->client message types. */\n  /* For future file transfer support:\n  i = 0;\n  SetCapInfo(&smsg_list[i++], rfbFileListData,           rfbTightVncVendor);\n  SetCapInfo(&smsg_list[i++], rfbFileDownloadData,       rfbTightVncVendor);\n  SetCapInfo(&smsg_list[i++], rfbFileUploadCancel,       rfbTightVncVendor);\n  SetCapInfo(&smsg_list[i++], rfbFileDownloadFailed,     rfbTightVncVendor);\n  if (i != N_SMSG_CAPS) {\n    rfbLog(\"rfbSendInteractionCaps: assertion failed, i != N_SMSG_CAPS\\n\");\n    rfbCloseClient(cl);\n    return;\n  }\n  */\n\n  /* Supported client->server message types. */\n  /* For future file transfer support:\n  i = 0;\n  SetCapInfo(&cmsg_list[i++], rfbFileListRequest,        rfbTightVncVendor);\n  SetCapInfo(&cmsg_list[i++], rfbFileDownloadRequest,    rfbTightVncVendor);\n  SetCapInfo(&cmsg_list[i++], rfbFileUploadRequest,      rfbTightVncVendor);\n  SetCapInfo(&cmsg_list[i++], rfbFileUploadData,         rfbTightVncVendor);\n  SetCapInfo(&cmsg_list[i++], rfbFileDownloadCancel,     rfbTightVncVendor);\n  SetCapInfo(&cmsg_list[i++], rfbFileUploadFailed,       rfbTightVncVendor);\n  if (i != N_CMSG_CAPS) {\n    rfbLog(\"rfbSendInteractionCaps: assertion failed, i != N_CMSG_CAPS\\n\");\n    rfbCloseClient(cl);\n    return;\n  }\n  */\n\n  /* Encoding types. */\n  i = 0;\n  SetCapInfo(&enc_list[i++],  rfbEncodingCopyRect,       rfbStandardVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingRRE,            rfbStandardVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingCoRRE,          rfbStandardVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingHextile,        rfbStandardVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingZlib,           rfbTridiaVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingZRLE,           rfbTridiaVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingZYWRLE,         rfbTridiaVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingTight,          rfbTightVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingCompressLevel0, rfbTightVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingQualityLevel0,  rfbTightVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingFineQualityLevel0, rfbTurboVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingSubsamp1X,         rfbTurboVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingXCursor,        rfbTightVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingRichCursor,     rfbTightVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingPointerPos,     rfbTightVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingLastRect,       rfbTightVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbGIIServer,              rfbGIIVendor);\n  if (i != N_ENC_CAPS) {\n    rfbLog(\"rfbSendInteractionCaps: assertion failed, i != N_ENC_CAPS\\n\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  /* Send header and capability lists */\n  if (WriteExact(cl, (char *)&intr_caps,\n                 sz_rfbInteractionCapsMsg) < 0 ||\n      WriteExact(cl, (char *)&enc_list[0],\n                 sz_rfbCapabilityInfo * N_ENC_CAPS) < 0) {\n    rfbLogPerror(\"rfbSendInteractionCaps: write\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  /* Dispatch client input to rfbProcessClientNormalMessage(). */\n  cl->state = RFB_NORMAL;\n}\n\n\n/*\n * rfbProcessClientNormalMessage is called when the client has sent a normal\n * protocol message.\n */\n\n#define READ(addr, numBytes)  \\\n  if ((n = ReadExact(cl, addr, numBytes)) <= 0) {  \\\n    if (n != 0)  \\\n      rfbLogPerror(\"rfbProcessClientNormalMessage: read\");  \\\n    rfbCloseClient(cl);  \\\n    return;  \\\n  }\n\n#define SKIP(numBytes)  \\\n  if ((n = SkipExact(cl, numBytes)) <= 0) {  \\\n    if (n != 0)  \\\n      rfbLogPerror(\"rfbProcessClientNormalMessage: skip\");  \\\n    rfbCloseClient(cl);  \\\n    return;  \\\n  }\n\nstatic void rfbProcessClientNormalMessage(rfbClientPtr cl)\n{\n  int n;\n  rfbClientToServerMsg msg;\n  char *str;\n\n  READ((char *)&msg, 1)\n\n  switch (msg.type) {\n\n    case rfbSetPixelFormat:\n\n      READ(((char *)&msg) + 1, sz_rfbSetPixelFormatMsg - 1)\n\n      cl->format.bitsPerPixel = msg.spf.format.bitsPerPixel;\n      cl->format.depth = msg.spf.format.depth;\n      cl->format.bigEndian = (msg.spf.format.bigEndian ? 1 : 0);\n      cl->format.trueColour = (msg.spf.format.trueColour ? 1 : 0);\n      cl->format.redMax = Swap16IfLE(msg.spf.format.redMax);\n      cl->format.greenMax = Swap16IfLE(msg.spf.format.greenMax);\n      cl->format.blueMax = Swap16IfLE(msg.spf.format.blueMax);\n      cl->format.redShift = msg.spf.format.redShift;\n      cl->format.greenShift = msg.spf.format.greenShift;\n      cl->format.blueShift = msg.spf.format.blueShift;\n\n      cl->readyForSetColourMapEntries = TRUE;\n\n      rfbSetTranslateFunction(cl);\n      return;\n\n    case rfbFixColourMapEntries:\n      READ(((char *)&msg) + 1, sz_rfbFixColourMapEntriesMsg - 1)\n      rfbLog(\"rfbProcessClientNormalMessage: FixColourMapEntries unsupported\\n\");\n      rfbCloseClient(cl);\n      return;\n\n    case rfbSetEncodings:\n    {\n      int i;\n      CARD32 enc;\n      Bool firstFence = !cl->enableFence;\n      Bool firstCU = !cl->enableCU;\n      Bool firstGII = !cl->enableGII;\n      Bool logTightCompressLevel = FALSE;\n\n      READ(((char *)&msg) + 1, sz_rfbSetEncodingsMsg - 1)\n\n      msg.se.nEncodings = Swap16IfLE(msg.se.nEncodings);\n\n      cl->preferredEncoding = -1;\n      cl->useCopyRect = FALSE;\n      cl->enableCursorShapeUpdates = FALSE;\n      cl->enableCursorPosUpdates = FALSE;\n      cl->enableLastRectEncoding = FALSE;\n      cl->tightCompressLevel = TIGHT_DEFAULT_COMPRESSION;\n      cl->tightSubsampLevel = TIGHT_DEFAULT_SUBSAMP;\n      cl->tightQualityLevel = -1;\n      cl->imageQualityLevel = -1;\n\n      for (i = 0; i < msg.se.nEncodings; i++) {\n        READ((char *)&enc, 4)\n        enc = Swap32IfLE(enc);\n\n        switch (enc) {\n\n          case rfbEncodingCopyRect:\n            cl->useCopyRect = TRUE;\n            break;\n          case rfbEncodingRaw:\n            if (cl->preferredEncoding == -1) {\n              cl->preferredEncoding = enc;\n              rfbLog(\"Using raw encoding for client %s\\n\", cl->host);\n            }\n            break;\n          case rfbEncodingRRE:\n            if (cl->preferredEncoding == -1) {\n              cl->preferredEncoding = enc;\n              rfbLog(\"Using rre encoding for client %s\\n\", cl->host);\n            }\n            break;\n          case rfbEncodingCoRRE:\n            if (cl->preferredEncoding == -1) {\n              cl->preferredEncoding = enc;\n              rfbLog(\"Using CoRRE encoding for client %s\\n\", cl->host);\n            }\n            break;\n          case rfbEncodingHextile:\n            if (cl->preferredEncoding == -1) {\n              cl->preferredEncoding = enc;\n              rfbLog(\"Using hextile encoding for client %s\\n\", cl->host);\n            }\n            break;\n          case rfbEncodingZlib:\n            if (cl->preferredEncoding == -1) {\n              cl->preferredEncoding = enc;\n              rfbLog(\"Using zlib encoding for client %s\\n\", cl->host);\n            }\n            break;\n          case rfbEncodingZRLE:\n            if (cl->preferredEncoding == -1) {\n              cl->preferredEncoding = enc;\n              rfbLog(\"Using ZRLE encoding for client %s\\n\", cl->host);\n            }\n            break;\n          case rfbEncodingZYWRLE:\n            if (cl->preferredEncoding == -1) {\n              cl->preferredEncoding = enc;\n              rfbLog(\"Using ZYWRLE encoding for client %s\\n\", cl->host);\n            }\n            break;\n          case rfbEncodingTight:\n            if (cl->preferredEncoding == -1) {\n              cl->preferredEncoding = enc;\n              rfbLog(\"Using tight encoding for client %s\\n\", cl->host);\n            }\n            break;\n          case rfbEncodingXCursor:\n            if (!cl->enableCursorShapeUpdates) {\n              rfbLog(\"Enabling X-style cursor updates for client %s\\n\",\n                     cl->host);\n              cl->enableCursorShapeUpdates = TRUE;\n              cl->useRichCursorEncoding = FALSE;\n              cl->cursorWasChanged = TRUE;\n            }\n            break;\n          case rfbEncodingRichCursor:\n            if (!cl->enableCursorShapeUpdates) {\n              rfbLog(\"Enabling full-color cursor updates for client %s\\n\",\n                     cl->host);\n              cl->enableCursorShapeUpdates = TRUE;\n              cl->useRichCursorEncoding = TRUE;\n              cl->cursorWasChanged = TRUE;\n            }\n            break;\n          case rfbEncodingPointerPos:\n            if (!cl->enableCursorPosUpdates) {\n              rfbLog(\"Enabling cursor position updates for client %s\\n\",\n                     cl->host);\n              cl->enableCursorPosUpdates = TRUE;\n              cl->cursorWasMoved = TRUE;\n              cl->cursorX = -1;\n              cl->cursorY = -1;\n            }\n            break;\n          case rfbEncodingLastRect:\n            if (!cl->enableLastRectEncoding) {\n              rfbLog(\"Enabling LastRect protocol extension for client %s\\n\",\n                     cl->host);\n              cl->enableLastRectEncoding = TRUE;\n            }\n            break;\n          case rfbEncodingFence:\n            if (!cl->enableFence) {\n              rfbLog(\"Enabling Fence protocol extension for client %s\\n\",\n                     cl->host);\n              cl->enableFence = TRUE;\n            }\n            break;\n          case rfbEncodingContinuousUpdates:\n            if (!cl->enableCU) {\n              rfbLog(\"Enabling Continuous Updates protocol extension for client %s\\n\",\n                     cl->host);\n              cl->enableCU = TRUE;\n            }\n            break;\n          case rfbEncodingNewFBSize:\n            if (!cl->enableDesktopSize) {\n              if (!rfbAuthDisableRemoteResize) {\n                rfbLog(\"Enabling Desktop Size protocol extension for client %s\\n\",\n                       cl->host);\n                cl->enableDesktopSize = TRUE;\n              } else\n                rfbLog(\"WARNING: Remote desktop resizing disabled per system policy.\\n\");\n            }\n            break;\n          case rfbEncodingExtendedDesktopSize:\n            if (!cl->enableExtDesktopSize) {\n              if (!rfbAuthDisableRemoteResize) {\n                rfbLog(\"Enabling Extended Desktop Size protocol extension for client %s\\n\",\n                       cl->host);\n                cl->enableExtDesktopSize = TRUE;\n              } else\n                rfbLog(\"WARNING: Remote desktop resizing disabled per system policy.\\n\");\n            }\n            break;\n          case rfbEncodingGII:\n            if (!cl->enableGII) {\n              rfbLog(\"Enabling GII extension for client %s\\n\", cl->host);\n              cl->enableGII = TRUE;\n            }\n            break;\n          default:\n            if (enc >= (CARD32)rfbEncodingCompressLevel0 &&\n                enc <= (CARD32)rfbEncodingCompressLevel9) {\n              cl->zlibCompressLevel = enc & 0x0F;\n              cl->tightCompressLevel = enc & 0x0F;\n              if (cl->preferredEncoding == rfbEncodingTight)\n                logTightCompressLevel = TRUE;\n              else\n                rfbLog(\"Using compression level %d for client %s\\n\",\n                       cl->tightCompressLevel, cl->host);\n              if (rfbInterframe == -1) {\n                if (cl->tightCompressLevel >= 5) {\n                  if (!InterframeOn(cl)) {\n                    rfbCloseClient(cl);\n                    return;\n                  }\n                } else\n                  InterframeOff(cl);\n              }\n            } else if (enc >= (CARD32)rfbEncodingSubsamp1X &&\n                       enc <= (CARD32)rfbEncodingSubsampGray) {\n              cl->tightSubsampLevel = enc & 0xFF;\n              rfbLog(\"Using JPEG subsampling %d for client %s\\n\",\n                     cl->tightSubsampLevel, cl->host);\n            } else if (enc >= (CARD32)rfbEncodingQualityLevel0 &&\n                       enc <= (CARD32)rfbEncodingQualityLevel9) {\n              cl->tightQualityLevel = JPEG_QUAL[enc & 0x0F];\n              cl->tightSubsampLevel = JPEG_SUBSAMP[enc & 0x0F];\n              cl->imageQualityLevel = enc & 0x0F;\n              if (cl->preferredEncoding == rfbEncodingTight)\n                rfbLog(\"Using JPEG subsampling %d, Q%d for client %s\\n\",\n                       cl->tightSubsampLevel, cl->tightQualityLevel, cl->host);\n              else\n                rfbLog(\"Using image quality level %d for client %s\\n\",\n                       cl->imageQualityLevel, cl->host);\n            } else if (enc >= (CARD32)rfbEncodingFineQualityLevel0 + 1 &&\n                       enc <= (CARD32)rfbEncodingFineQualityLevel100) {\n              cl->tightQualityLevel = enc & 0xFF;\n              rfbLog(\"Using JPEG quality %d for client %s\\n\",\n                     cl->tightQualityLevel, cl->host);\n            } else {\n              rfbLog(\"rfbProcessClientNormalMessage: ignoring unknown encoding %d (%x)\\n\",\n                     (int)enc, (int)enc);\n            }\n        }  /* switch (enc) */\n      }  /* for (i = 0; i < msg.se.nEncodings; i++) */\n\n      if (cl->preferredEncoding == -1)\n        cl->preferredEncoding = rfbEncodingTight;\n\n      if (cl->preferredEncoding == rfbEncodingTight && logTightCompressLevel)\n        rfbLog(\"Using Tight compression level %d for client %s\\n\",\n               rfbTightCompressLevel(cl), cl->host);\n\n      if (cl->enableCursorPosUpdates && !cl->enableCursorShapeUpdates) {\n        rfbLog(\"Disabling cursor position updates for client %s\\n\", cl->host);\n        cl->enableCursorPosUpdates = FALSE;\n      }\n\n      if (cl->enableFence && firstFence) {\n        if (!rfbSendFence(cl, rfbFenceFlagRequest, 0, NULL))\n          return;\n      }\n\n      if (cl->enableCU && cl->enableFence && firstCU) {\n        if (!rfbSendEndOfCU(cl))\n          return;\n      }\n\n      if (cl->enableGII && firstGII) {\n        /* Send GII server version message to all clients */\n        rfbGIIServerVersionMsg msg;\n\n        msg.type = rfbGIIServer;\n        /* We always send as big endian to make things easier on the Java\n           viewer. */\n        msg.endianAndSubType = rfbGIIVersion | rfbGIIBE;\n        msg.length = Swap16IfLE(sz_rfbGIIServerVersionMsg - 4);\n        msg.maximumVersion = msg.minimumVersion = Swap16IfLE(1);\n\n        if (WriteExact(cl, (char *)&msg, sz_rfbGIIServerVersionMsg) < 0) {\n          rfbLogPerror(\"rfbProcessClientNormalMessage: write\");\n          rfbCloseClient(cl);\n          return;\n        }\n      }\n\n      return;\n    }  /* rfbSetEncodings */\n\n    case rfbFramebufferUpdateRequest:\n    {\n      RegionRec tmpRegion;\n      BoxRec box;\n\n      READ(((char *)&msg) + 1, sz_rfbFramebufferUpdateRequestMsg - 1)\n\n      box.x1 = Swap16IfLE(msg.fur.x);\n      box.y1 = Swap16IfLE(msg.fur.y);\n      box.x2 = box.x1 + Swap16IfLE(msg.fur.w);\n      box.y2 = box.y1 + Swap16IfLE(msg.fur.h);\n      SAFE_REGION_INIT(pScreen, &tmpRegion, &box, 0);\n\n      if (!msg.fur.incremental || !cl->continuousUpdates)\n        REGION_UNION(pScreen, &cl->requestedRegion, &cl->requestedRegion,\n                     &tmpRegion);\n\n      if (!cl->readyForSetColourMapEntries) {\n        /* client hasn't sent a SetPixelFormat so is using server's */\n        cl->readyForSetColourMapEntries = TRUE;\n        if (!cl->format.trueColour) {\n          if (!rfbSetClientColourMap(cl, 0, 0)) {\n            REGION_UNINIT(pScreen, &tmpRegion);\n            return;\n          }\n        }\n      }\n\n      if (!msg.fur.incremental) {\n        REGION_UNION(pScreen, &cl->modifiedRegion, &cl->modifiedRegion,\n                     &tmpRegion);\n        REGION_SUBTRACT(pScreen, &cl->copyRegion, &cl->copyRegion, &tmpRegion);\n        REGION_UNION(pScreen, &cl->ifRegion, &cl->ifRegion, &tmpRegion);\n        cl->pendingExtDesktopResize = TRUE;\n      }\n\n      if (FB_UPDATE_PENDING(cl) &&\n          (!cl->deferredUpdateScheduled || rfbDeferUpdateTime == 0 ||\n           gettime() - cl->deferredUpdateStart >=\n           (double)rfbDeferUpdateTime)) {\n        if (rfbSendFramebufferUpdate(cl))\n          cl->deferredUpdateScheduled = FALSE;\n      }\n\n      REGION_UNINIT(pScreen, &tmpRegion);\n      return;\n    }\n\n    case rfbKeyEvent:\n\n      cl->rfbKeyEventsRcvd++;\n\n      READ(((char *)&msg) + 1, sz_rfbKeyEventMsg - 1)\n\n      if (!rfbViewOnly && !cl->viewOnly)\n        KeyEvent((KeySym)Swap32IfLE(msg.ke.key), msg.ke.down);\n\n      return;\n\n    case rfbPointerEvent:\n\n      cl->rfbPointerEventsRcvd++;\n\n      READ(((char *)&msg) + 1, sz_rfbPointerEventMsg - 1)\n\n      if (pointerClient && (pointerClient != cl))\n        return;\n\n      if (msg.pe.buttonMask == 0)\n        pointerClient = NULL;\n      else\n        pointerClient = cl;\n\n      if (!rfbViewOnly && !cl->viewOnly) {\n        cl->cursorX = (int)Swap16IfLE(msg.pe.x);\n        cl->cursorY = (int)Swap16IfLE(msg.pe.y);\n        PtrAddEvent(msg.pe.buttonMask, cl->cursorX, cl->cursorY, cl);\n      }\n      return;\n\n    case rfbClientCutText:\n    {\n      int ignoredBytes = 0;\n\n      READ(((char *)&msg) + 1, sz_rfbClientCutTextMsg - 1)\n\n      msg.cct.length = Swap32IfLE(msg.cct.length);\n      if (msg.cct.length > rfbMaxClipboard) {\n        rfbLog(\"Truncating %d-byte clipboard update to %d bytes.\\n\",\n               msg.cct.length, rfbMaxClipboard);\n        ignoredBytes = msg.cct.length - rfbMaxClipboard;\n        msg.cct.length = rfbMaxClipboard;\n      }\n\n      if (msg.cct.length <= 0) return;\n      str = (char *)malloc(msg.cct.length);\n      if (str == NULL) {\n        rfbLogPerror(\"rfbProcessClientNormalMessage: rfbClientCutText out of memory\");\n        rfbCloseClient(cl);\n        return;\n      }\n\n      if ((n = ReadExact(cl, str, msg.cct.length)) <= 0) {\n        if (n != 0)\n          rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n        free(str);\n        rfbCloseClient(cl);\n        return;\n      }\n\n      if (ignoredBytes > 0) {\n        if ((n = SkipExact(cl, ignoredBytes)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          free(str);\n          rfbCloseClient(cl);\n          return;\n        }\n      }\n\n      /* NOTE: We do not accept cut text from a view-only client */\n      if (!rfbViewOnly && !cl->viewOnly && !rfbAuthDisableCBRecv) {\n        vncClientCutText(str, msg.cct.length);\n        if (rfbSyncCutBuffer) rfbSetXCutText(str, msg.cct.length);\n      }\n\n      free(str);\n      return;\n    }\n\n    case rfbEnableContinuousUpdates:\n    {\n      BoxRec box;\n\n      READ(((char *)&msg) + 1, sz_rfbEnableContinuousUpdatesMsg - 1)\n\n      if (!cl->enableFence || !cl->enableCU) {\n        rfbLog(\"Ignoring request to enable continuous updates because the client does not\\n\");\n        rfbLog(\"support the flow control extensions.\\n\");\n        return;\n      }\n\n      box.x1 = Swap16IfLE(msg.ecu.x);\n      box.y1 = Swap16IfLE(msg.ecu.y);\n      box.x2 = box.x1 + Swap16IfLE(msg.ecu.w);\n      box.y2 = box.y1 + Swap16IfLE(msg.ecu.h);\n      SAFE_REGION_INIT(pScreen, &cl->cuRegion, &box, 0);\n\n      cl->continuousUpdates = msg.ecu.enable;\n      if (cl->continuousUpdates) {\n        REGION_EMPTY(pScreen, &cl->requestedRegion);\n        if (!rfbSendFramebufferUpdate(cl))\n          return;\n      } else {\n        if (!rfbSendEndOfCU(cl))\n          return;\n      }\n\n      rfbLog(\"Continuous updates %s\\n\",\n             cl->continuousUpdates ? \"enabled\" : \"disabled\");\n      return;\n    }\n\n    case rfbFence:\n    {\n      CARD32 flags;\n      char data[64];\n\n      READ(((char *)&msg) + 1, sz_rfbFenceMsg - 1)\n\n      flags = Swap32IfLE(msg.f.flags);\n\n      READ(data, msg.f.length)\n\n      if (msg.f.length > sizeof(data))\n        rfbLog(\"Ignoring fence.  Payload of %d bytes is too large.\\n\",\n               msg.f.length);\n      else\n        HandleFence(cl, flags, msg.f.length, data);\n      return;\n    }\n\n    #define EDSERROR(format, args...) {  \\\n      if (!strlen(errMsg))  \\\n        snprintf(errMsg, 256, \"Desktop resize ERROR: \"format\"\\n\", args);  \\\n      result = rfbEDSResultInvalid;  \\\n    }\n\n    case rfbSetDesktopSize:\n    {\n      int i;\n      struct xorg_list newScreens;\n      rfbClientPtr cl2;\n      int result = rfbEDSResultSuccess;\n      char errMsg[256] = \"\\0\";\n      ScreenPtr pScreen = screenInfo.screens[0];\n\n      READ(((char *)&msg) + 1, sz_rfbSetDesktopSizeMsg - 1)\n\n      if (msg.sds.numScreens < 1)\n        EDSERROR(\"Requested number of screens %d is invalid\",\n                 msg.sds.numScreens);\n\n      msg.sds.w = Swap16IfLE(msg.sds.w);\n      msg.sds.h = Swap16IfLE(msg.sds.h);\n      if (msg.sds.w < 1 || msg.sds.h < 1)\n        EDSERROR(\"Requested framebuffer dimensions %dx%d are invalid\",\n                 msg.sds.w, msg.sds.h);\n\n      xorg_list_init(&newScreens);\n      for (i = 0; i < msg.sds.numScreens; i++) {\n        rfbScreenInfo *screen = rfbNewScreen(0, 0, 0, 0, 0, 0);\n\n        READ((char *)&screen->s, sizeof(rfbScreenDesc))\n        screen->s.id = Swap32IfLE(screen->s.id);\n        screen->s.x = Swap16IfLE(screen->s.x);\n        screen->s.y = Swap16IfLE(screen->s.y);\n        screen->s.w = Swap16IfLE(screen->s.w);\n        screen->s.h = Swap16IfLE(screen->s.h);\n        screen->s.flags = Swap32IfLE(screen->s.flags);\n        if (screen->s.w < 1 || screen->s.h < 1)\n          EDSERROR(\"Screen 0x%.8x requested dimensions %dx%d are invalid\",\n                   (unsigned int)screen->s.id, screen->s.w, screen->s.h);\n        if (screen->s.x >= msg.sds.w || screen->s.y >= msg.sds.h ||\n            screen->s.x + screen->s.w > msg.sds.w ||\n            screen->s.y + screen->s.h > msg.sds.h)\n          EDSERROR(\"Screen 0x%.8x requested geometry %dx%d+%d+%d exceeds requested framebuffer dimensions\",\n                   (unsigned int)screen->s.id, screen->s.w, screen->s.h,\n                   screen->s.x, screen->s.y);\n        if (rfbFindScreenID(&newScreens, screen->s.id)) {\n          EDSERROR(\"Screen 0x%.8x duplicate ID\", (unsigned int)screen->s.id);\n          free(screen);\n        } else\n          rfbAddScreen(&newScreens, screen);\n      }\n\n      if (cl->viewOnly) {\n        rfbLog(\"NOTICE: Ignoring remote desktop resize request from a view-only client.\\n\");\n        result = rfbEDSResultProhibited;\n      } else if (result == rfbEDSResultSuccess) {\n        result = ResizeDesktop(pScreen, cl, msg.sds.w, msg.sds.h, &newScreens);\n        if (result == rfbEDSResultSuccess)\n          return;\n      } else\n        rfbLog(errMsg);\n\n      rfbRemoveScreens(&newScreens);\n\n      /* Send back the error only to the requesting client.  This loop is\n         necessary because the client may have been shut down as a result of\n         an error in ResizeDesktop(). */\n      for (cl2 = rfbClientHead; cl2; cl2 = cl2->next) {\n        if (cl2 == cl) {\n          cl2->pendingExtDesktopResize = TRUE;\n          cl2->reason = rfbEDSReasonClient;\n          cl2->result = result;\n          rfbSendFramebufferUpdate(cl2);\n          break;\n        }\n      }\n\n      return;\n    }\n\n    case rfbGIIClient:\n    {\n      CARD8 endianAndSubType, littleEndian, subType;\n\n      READ((char *)&endianAndSubType, 1);\n      littleEndian = (endianAndSubType & rfbGIIBE) ? 0 : 1;\n      subType = endianAndSubType & ~rfbGIIBE;\n\n      switch (subType) {\n\n        case rfbGIIVersion:\n\n          READ((char *)&msg.giicv.length, sz_rfbGIIClientVersionMsg - 2);\n          if (littleEndian != *(const char *)&rfbEndianTest) {\n            msg.giicv.length = Swap16(msg.giicv.length);\n            msg.giicv.version = Swap16(msg.giicv.version);\n          }\n          if (msg.giicv.length != sz_rfbGIIClientVersionMsg - 4 ||\n              msg.giicv.version < 1) {\n            rfbLog(\"ERROR: Malformed GII client version message\\n\");\n            rfbCloseClient(cl);\n            return;\n          }\n          rfbLog(\"Client supports GII version %d\\n\", msg.giicv.version);\n          break;\n\n        case rfbGIIDeviceCreate:\n        {\n          int i;\n          rfbDevInfo dev;\n          rfbGIIDeviceCreatedMsg dcmsg;\n\n          memset(&dev, 0, sizeof(dev));\n          dcmsg.deviceOrigin = 0;\n\n          READ((char *)&msg.giidc.length, sz_rfbGIIDeviceCreateMsg - 2);\n          if (littleEndian != *(const char *)&rfbEndianTest) {\n            msg.giidc.length = Swap16(msg.giidc.length);\n            msg.giidc.vendorID = Swap32(msg.giidc.vendorID);\n            msg.giidc.productID = Swap32(msg.giidc.productID);\n            msg.giidc.canGenerate = Swap32(msg.giidc.canGenerate);\n            msg.giidc.numRegisters = Swap32(msg.giidc.numRegisters);\n            msg.giidc.numValuators = Swap32(msg.giidc.numValuators);\n            msg.giidc.numButtons = Swap32(msg.giidc.numButtons);\n          }\n\n          rfbLog(\"GII Device Create: %s\\n\", msg.giidc.deviceName);\n#ifdef GII_DEBUG\n          rfbLog(\"    Vendor ID: %d\\n\", msg.giidc.vendorID);\n          rfbLog(\"    Product ID: %d\\n\", msg.giidc.productID);\n          rfbLog(\"    Event mask: %.8x\\n\", msg.giidc.canGenerate);\n          rfbLog(\"    Registers: %d\\n\", msg.giidc.numRegisters);\n          rfbLog(\"    Valuators: %d\\n\", msg.giidc.numValuators);\n          rfbLog(\"    Buttons: %d\\n\", msg.giidc.numButtons);\n#endif\n\n          if (msg.giidc.length != sz_rfbGIIDeviceCreateMsg - 4 +\n              msg.giidc.numValuators * sz_rfbGIIValuator) {\n            rfbLog(\"ERROR: Malformed GII device create message\\n\");\n            rfbCloseClient(cl);\n            return;\n          }\n\n          if (msg.giidc.numButtons > MAX_BUTTONS) {\n            rfbLog(\"GII device create ERROR: %d buttons exceeds max of %d\\n\",\n                   msg.giidc.numButtons, MAX_BUTTONS);\n            SKIP(msg.giidc.numValuators * sz_rfbGIIValuator);\n            goto sendMessage;\n          }\n          if (msg.giidc.numValuators > MAX_VALUATORS) {\n            rfbLog(\"GII device create ERROR: %d valuators exceeds max of %d\\n\",\n                   msg.giidc.numValuators, MAX_VALUATORS);\n            SKIP(msg.giidc.numValuators * sz_rfbGIIValuator);\n            goto sendMessage;\n          }\n\n          memcpy(&dev.name, msg.giidc.deviceName, 32);\n          dev.numButtons = msg.giidc.numButtons;\n          dev.numValuators = msg.giidc.numValuators;\n          dev.eventMask = msg.giidc.canGenerate;\n          dev.mode =\n            (dev.eventMask & rfbGIIValuatorAbsoluteMask) ? Absolute : Relative;\n          dev.productID = msg.giidc.productID;\n\n          if (dev.mode == Relative) {\n            rfbLog(\"GII device create ERROR: relative valuators not supported (yet)\\n\");\n            SKIP(msg.giidc.numValuators * sz_rfbGIIValuator);\n            goto sendMessage;\n          }\n\n          for (i = 0; i < dev.numValuators; i++) {\n            rfbGIIValuator *v = &dev.valuators[i];\n            READ((char *)v, sz_rfbGIIValuator);\n            if (littleEndian != *(const char *)&rfbEndianTest) {\n              v->index = Swap32(v->index);\n              v->rangeMin = Swap32((CARD32)v->rangeMin);\n              v->rangeCenter = Swap32((CARD32)v->rangeCenter);\n              v->rangeMax = Swap32((CARD32)v->rangeMax);\n              v->siUnit = Swap32(v->siUnit);\n              v->siAdd = Swap32((CARD32)v->siAdd);\n              v->siMul = Swap32((CARD32)v->siMul);\n              v->siDiv = Swap32((CARD32)v->siDiv);\n              v->siShift = Swap32((CARD32)v->siShift);\n            }\n\n#ifdef GII_DEBUG\n            rfbLog(\"    Valuator: %s (%s)\\n\", v->longName, v->shortName);\n            rfbLog(\"        Index: %d\\n\", v->index);\n            rfbLog(\"        Range: min = %d, center = %d, max = %d\\n\",\n                   v->rangeMin, v->rangeCenter, v->rangeMax);\n            rfbLog(\"        SI unit: %d\\n\", v->siUnit);\n            rfbLog(\"        SI add: %d\\n\", v->siAdd);\n            rfbLog(\"        SI multiply: %d\\n\", v->siMul);\n            rfbLog(\"        SI divide: %d\\n\", v->siDiv);\n            rfbLog(\"        SI shift: %d\\n\", v->siShift);\n#endif\n          }\n\n          for (i = 0; i < cl->numDevices; i++) {\n            if (!strcmp(dev.name, cl->devices[i].name)) {\n              rfbLog(\"Device \\'%s\\' already exists with GII device ID %d\\n\",\n                     dev.name, i + 1);\n              dcmsg.deviceOrigin = Swap32IfLE(i + 1);\n              goto sendMessage;\n            }\n          }\n\n          if (rfbVirtualTablet || AddExtInputDevice(&dev)) {\n            memcpy(&cl->devices[cl->numDevices], &dev, sizeof(dev));\n            cl->numDevices++;\n            dcmsg.deviceOrigin = Swap32IfLE(cl->numDevices);\n          }\n          rfbLog(\"GII device ID = %d\\n\", cl->numDevices);\n\n          sendMessage:\n          /* Send back a GII device created message */\n          dcmsg.type = rfbGIIServer;\n          /* We always send as big endian to make things easier on the Java\n             viewer. */\n          dcmsg.endianAndSubType = rfbGIIDeviceCreate | rfbGIIBE;\n          dcmsg.length = Swap16IfLE(sz_rfbGIIDeviceCreatedMsg - 4);\n\n          if (WriteExact(cl, (char *)&dcmsg, sz_rfbGIIDeviceCreatedMsg) < 0) {\n            rfbLogPerror(\"rfbProcessClientNormalMessage: write\");\n            rfbCloseClient(cl);\n            return;\n          }\n\n          break;\n        }\n\n        case rfbGIIDeviceDestroy:\n\n          READ((char *)&msg.giidd.length, sz_rfbGIIDeviceDestroyMsg - 2);\n          if (littleEndian != *(const char *)&rfbEndianTest) {\n            msg.giidd.length = Swap16(msg.giidd.length);\n            msg.giidd.deviceOrigin = Swap32(msg.giidd.deviceOrigin);\n          }\n          if (msg.giidd.length != sz_rfbGIIDeviceDestroyMsg - 4) {\n            rfbLog(\"ERROR: Malformed GII device create message\\n\");\n            rfbCloseClient(cl);\n            return;\n          }\n\n          RemoveExtInputDevice(cl, msg.giidd.deviceOrigin - 1);\n\n          break;\n\n        case rfbGIIEvent:\n        {\n          CARD16 length;\n\n          READ((char *)&length, sizeof(CARD16));\n          if (littleEndian != *(const char *)&rfbEndianTest)\n            length = Swap16(length);\n\n          while (length > 0) {\n            CARD8 eventSize, eventType;\n\n            READ((char *)&eventSize, 1);\n            READ((char *)&eventType, 1);\n\n            switch (eventType) {\n\n              case rfbGIIButtonPress:\n              case rfbGIIButtonRelease:\n              {\n                rfbGIIButtonEvent b;\n                rfbDevInfo *dev;\n\n                READ((char *)&b.pad, sz_rfbGIIButtonEvent - 2);\n                if (littleEndian != *(const char *)&rfbEndianTest) {\n                  b.deviceOrigin = Swap32(b.deviceOrigin);\n                  b.buttonNumber = Swap32(b.buttonNumber);\n                }\n                if (eventSize != sz_rfbGIIButtonEvent || b.deviceOrigin <= 0 ||\n                    b.buttonNumber < 1) {\n                  rfbLog(\"ERROR: Malformed GII button event\\n\");\n                  rfbCloseClient(cl);\n                  return;\n                }\n                if (eventSize > length) {\n                  rfbLog(\"ERROR: Malformed GII event message\\n\");\n                  rfbCloseClient(cl);\n                  return;\n                }\n                length -= eventSize;\n                if (b.deviceOrigin < 1 || b.deviceOrigin > cl->numDevices) {\n                  rfbLog(\"ERROR: GII button event from non-existent device %d\\n\",\n                         b.deviceOrigin);\n                  rfbCloseClient(cl);\n                  return;\n                }\n                dev = &cl->devices[b.deviceOrigin - 1];\n                if ((eventType == rfbGIIButtonPress &&\n                     (dev->eventMask & rfbGIIButtonPressMask) == 0) ||\n                    (eventType == rfbGIIButtonRelease &&\n                     (dev->eventMask & rfbGIIButtonReleaseMask) == 0)) {\n                  rfbLog(\"ERROR: Device %d can't generate GII button events\\n\",\n                         b.deviceOrigin);\n                  rfbCloseClient(cl);\n                  return;\n                }\n                if (b.buttonNumber > dev->numButtons) {\n                  rfbLog(\"ERROR: GII button %d event for device %d exceeds button count (%d)\\n\",\n                         b.buttonNumber, b.deviceOrigin, dev->numButtons);\n                  rfbCloseClient(cl);\n                  return;\n                }\n#ifdef GII_DEBUG\n                rfbLog(\"Device %d button %d %s\\n\", b.deviceOrigin,\n                       b.buttonNumber,\n                       eventType == rfbGIIButtonPress ? \"PRESS\" : \"release\");\n                fflush(stderr);\n#endif\n                ExtInputAddEvent(dev, eventType == rfbGIIButtonPress ?\n                                 ButtonPress : ButtonRelease, b.buttonNumber);\n                break;\n              }\n\n              case rfbGIIValuatorRelative:\n              case rfbGIIValuatorAbsolute:\n              {\n                rfbGIIValuatorEvent v;\n                int i;\n                rfbDevInfo *dev;\n\n                READ((char *)&v.pad, sz_rfbGIIValuatorEvent - 2);\n                if (littleEndian != *(const char *)&rfbEndianTest) {\n                  v.deviceOrigin = Swap32(v.deviceOrigin);\n                  v.first = Swap32(v.first);\n                  v.count = Swap32(v.count);\n                }\n                if (eventSize !=\n                    sz_rfbGIIValuatorEvent + sizeof(int) * v.count) {\n                  rfbLog(\"ERROR: Malformed GII valuator event\\n\");\n                  rfbCloseClient(cl);\n                  return;\n                }\n                if (eventSize > length) {\n                  rfbLog(\"ERROR: Malformed GII event message\\n\");\n                  rfbCloseClient(cl);\n                  return;\n                }\n                length -= eventSize;\n                if (v.deviceOrigin < 1 || v.deviceOrigin > cl->numDevices) {\n                  rfbLog(\"ERROR: GII valuator event from non-existent device %d\\n\",\n                         v.deviceOrigin);\n                  rfbCloseClient(cl);\n                  return;\n                }\n                dev = &cl->devices[v.deviceOrigin - 1];\n                if ((eventType == rfbGIIValuatorRelative &&\n                     (dev->eventMask & rfbGIIValuatorRelativeMask) == 0) ||\n                    (eventType == rfbGIIValuatorAbsolute &&\n                     (dev->eventMask & rfbGIIValuatorAbsoluteMask) == 0)) {\n                  rfbLog(\"ERROR: Device %d cannot generate GII valuator events\\n\",\n                         v.deviceOrigin);\n                  rfbCloseClient(cl);\n                  return;\n                }\n                if (v.first + v.count > dev->numValuators) {\n                  rfbLog(\"ERROR: GII valuator event for device %d exceeds valuator count (%d)\\n\",\n                         v.deviceOrigin, dev->numValuators);\n                  rfbCloseClient(cl);\n                  return;\n                }\n#ifdef GII_DEBUG\n                rfbLog(\"Device %d Valuator %s first=%d count=%d:\\n\",\n                       v.deviceOrigin,\n                       eventType == rfbGIIValuatorRelative ? \"rel\" : \"ABS\",\n                       v.first, v.count);\n#endif\n                for (i = v.first; i < v.first + v.count; i++) {\n                  READ((char *)&dev->values[i], sizeof(int));\n                  if (littleEndian != *(const char *)&rfbEndianTest)\n                    dev->values[i] = Swap32((CARD32)dev->values[i]);\n#ifdef GII_DEBUG\n                  fprintf(stderr, \"v[%d]=%d \", i, dev->values[i]);\n#endif\n                }\n#ifdef GII_DEBUG\n                fprintf(stderr, \"\\n\");\n#endif\n                if (v.count > 0) {\n                  dev->valFirst = v.first;\n                  dev->valCount = v.count;\n                  dev->mode = eventType == rfbGIIValuatorAbsolute ?\n                              Absolute : Relative;\n                  ExtInputAddEvent(dev, MotionNotify, 0);\n                }\n                break;\n              }\n              default:\n                rfbLog(\"ERROR: This server cannot handle GII event type %d\\n\",\n                       eventType);\n                rfbCloseClient(cl);\n                return;\n            }  /* switch (eventType) */\n          }  /* while (length > 0) */\n          if (length != 0) {\n            rfbLog(\"ERROR: Malformed GII event message\\n\");\n            rfbCloseClient(cl);\n            return;\n          }\n          break;\n        }  /* rfbGIIEvent */\n      }  /* switch (subType) */\n      return;\n    }  /* rfbGIIClient */\n\n    default:\n\n      rfbLog(\"rfbProcessClientNormalMessage: unknown message type %d\\n\",\n             msg.type);\n      rfbLog(\" ... closing connection\\n\");\n      rfbCloseClient(cl);\n      return;\n  }  /* switch (msg.type) */\n}\n\n\n/*\n * rfbSendFramebufferUpdate - send the currently pending framebuffer update to\n * the RFB client.\n */\n\nBool rfbSendFramebufferUpdate(rfbClientPtr cl)\n{\n  ScreenPtr pScreen = screenInfo.screens[0];\n  int i;\n  int nUpdateRegionRects;\n  rfbFramebufferUpdateMsg *fu = (rfbFramebufferUpdateMsg *)updateBuf;\n  RegionRec _updateRegion, *updateRegion = &_updateRegion, updateCopyRegion,\n    idRegion;\n  Bool emptyUpdateRegion = FALSE;\n  rfbClientPtr cl2;\n  int dx, dy;\n  Bool sendCursorShape = FALSE;\n  Bool sendCursorPos = FALSE;\n  double tUpdateStart = 0.0;\n\n  TimerCancel(cl->updateTimer);\n\n  /*\n   * We're in the middle of processing a command that's supposed to be\n   * synchronised. Allowing an update to slip out right now might violate\n   * that synchronisation.\n   */\n\n  if (cl->syncFence) return TRUE;\n\n  if (cl->state != RFB_NORMAL) return TRUE;\n\n  if (rfbProfile) {\n    tUpdateStart = gettime();\n    if (tStart < 0.) tStart = tUpdateStart;\n  }\n\n  /* Check that we actually have some space on the link and retry in a\n     bit if things are congested. */\n\n  if (rfbCongestionControl && rfbIsCongested(cl)) {\n    cl->updateTimer = TimerSet(cl->updateTimer, 0, 50, updateCallback, cl);\n    return TRUE;\n  }\n\n  /* In continuous mode, we will be outputting at least three distinct\n     messages.  We need to aggregate these in order to not clog up TCP's\n     congestion window. */\n\n  rfbCorkSock(cl->sock);\n\n  if (cl->pendingExtDesktopResize) {\n    if (!rfbSendExtDesktopSize(cl)) return FALSE;\n    cl->pendingExtDesktopResize = FALSE;\n  }\n\n  if (cl->pendingDesktopResize) {\n    if (!rfbSendDesktopSize(cl)) return FALSE;\n    cl->pendingDesktopResize = FALSE;\n  }\n\n  if (rfbFB.blockUpdates) {\n    rfbUncorkSock(cl->sock);\n    return TRUE;\n  }\n\n  /*\n   * If this client understands cursor shape updates, cursor should be\n   * removed from the framebuffer. Otherwise, make sure it's put up.\n   */\n\n  if (cl->enableCursorShapeUpdates) {\n    if (rfbFB.cursorIsDrawn)\n      rfbSpriteRemoveCursorAllDev(pScreen);\n    if (!rfbFB.cursorIsDrawn && cl->cursorWasChanged)\n      sendCursorShape = TRUE;\n  } else {\n    if (!rfbFB.cursorIsDrawn)\n      rfbSpriteRestoreCursorAllDev(pScreen);\n  }\n\n  /*\n   * Do we plan to send cursor position update?\n   */\n\n  if (cl->enableCursorPosUpdates && cl->cursorWasMoved)\n    sendCursorPos = TRUE;\n\n  /*\n   * The modifiedRegion may overlap the destination copyRegion.  We remove\n   * any overlapping bits from the copyRegion (since they'd only be\n   * overwritten anyway).\n   */\n\n  REGION_SUBTRACT(pScreen, &cl->copyRegion, &cl->copyRegion,\n                  &cl->modifiedRegion);\n\n  /*\n   * The client is interested in the region requestedRegion.  The region\n   * which should be updated now is the intersection of requestedRegion\n   * and the union of modifiedRegion and copyRegion.  If it's empty then\n   * no update is needed.\n   */\n\n  REGION_INIT(pScreen, updateRegion, NullBox, 0);\n  REGION_UNION(pScreen, updateRegion, &cl->copyRegion, &cl->modifiedRegion);\n\n  if (cl->continuousUpdates)\n    REGION_UNION(pScreen, &cl->requestedRegion, &cl->requestedRegion,\n                 &cl->cuRegion);\n\n  REGION_INTERSECT(pScreen, updateRegion, &cl->requestedRegion, updateRegion);\n\n  if (!REGION_NOTEMPTY(pScreen, updateRegion) && !sendCursorShape &&\n      !sendCursorPos) {\n    REGION_UNINIT(pScreen, updateRegion);\n    return TRUE;\n  }\n\n  /*\n   * We assume that the client doesn't have any pixel data outside the\n   * requestedRegion.  In other words, both the source and destination of a\n   * copy must lie within requestedRegion.  So the region we can send as a\n   * copy is the intersection of the copyRegion with both the requestedRegion\n   * and the requestedRegion translated by the amount of the copy.  We set\n   * updateCopyRegion to this.\n   */\n\n  REGION_INIT(pScreen, &updateCopyRegion, NullBox, 0);\n  REGION_INTERSECT(pScreen, &updateCopyRegion, &cl->copyRegion,\n                   &cl->requestedRegion);\n  REGION_TRANSLATE(pScreen, &cl->requestedRegion, cl->copyDX, cl->copyDY);\n  REGION_INTERSECT(pScreen, &updateCopyRegion, &updateCopyRegion,\n                   &cl->requestedRegion);\n  dx = cl->copyDX;\n  dy = cl->copyDY;\n\n  /*\n   * Next we remove updateCopyRegion from updateRegion so that updateRegion\n   * is the part of this update which is sent as ordinary pixel data (i.e not\n   * a copy).\n   */\n\n  REGION_SUBTRACT(pScreen, updateRegion, updateRegion, &updateCopyRegion);\n\n  /*\n   * Finally we leave modifiedRegion to be the remainder (if any) of parts of\n   * the screen which are modified but outside the requestedRegion.  We also\n   * empty both the requestedRegion and the copyRegion - note that we never\n   * carry over a copyRegion for a future update.\n   */\n\n  REGION_UNION(pScreen, &cl->modifiedRegion, &cl->modifiedRegion,\n               &cl->copyRegion);\n  REGION_SUBTRACT(pScreen, &cl->modifiedRegion, &cl->modifiedRegion,\n                  updateRegion);\n  REGION_SUBTRACT(pScreen, &cl->modifiedRegion, &cl->modifiedRegion,\n                  &updateCopyRegion);\n\n  REGION_EMPTY(pScreen, &cl->requestedRegion);\n  REGION_EMPTY(pScreen, &cl->copyRegion);\n  cl->copyDX = 0;\n  cl->copyDY = 0;\n\n  /*\n   * Now send the update.\n   */\n\n  if (REGION_NUM_RECTS(updateRegion) > rfbCombineRect) {\n    RegionRec combinedUpdateRegion;\n    REGION_INIT(pScreen, &combinedUpdateRegion,\n                REGION_EXTENTS(pScreen, updateRegion), 1);\n    REGION_UNINIT(pScreen, updateRegion);\n    REGION_INIT(pScreen, updateRegion,\n                REGION_EXTENTS(pScreen, &combinedUpdateRegion), 1);\n    REGION_UNINIT(pScreen, &combinedUpdateRegion);\n  }\n\n  if ((updateRegion->extents.x2 > pScreen->width ||\n       updateRegion->extents.y2 > pScreen->height) &&\n      REGION_NUM_RECTS(updateRegion) > 0) {\n    rfbLog(\"WARNING: Framebuffer update at %d,%d with dimensions %dx%d has been clipped to the screen boundaries\\n\",\n           updateRegion->extents.x1, updateRegion->extents.y1,\n           updateRegion->extents.x2 - updateRegion->extents.x1,\n           updateRegion->extents.y2 - updateRegion->extents.y1);\n    ClipToScreen(pScreen, updateRegion);\n  }\n\n  if (cl->compareFB) {\n    if ((cl->ifRegion.extents.x2 > pScreen->width ||\n         cl->ifRegion.extents.y2 > pScreen->height) &&\n        REGION_NUM_RECTS(&cl->ifRegion) > 0)\n      ClipToScreen(pScreen, &cl->ifRegion);\n\n    updateRegion = &cl->ifRegion;\n    emptyUpdateRegion = TRUE;\n    if (rfbInterframeDebug)\n      REGION_INIT(pScreen, &idRegion, NullBox, 0);\n    for (i = 0; i < REGION_NUM_RECTS(&_updateRegion); i++) {\n      int x = REGION_RECTS(&_updateRegion)[i].x1;\n      int y = REGION_RECTS(&_updateRegion)[i].y1;\n      int w = REGION_RECTS(&_updateRegion)[i].x2 - x;\n      int h = REGION_RECTS(&_updateRegion)[i].y2 - y;\n      int pitch = rfbFB.paddedWidthInBytes;\n      int ps = rfbServerFormat.bitsPerPixel / 8;\n      char *src = &rfbFB.pfbMemory[y * pitch + x * ps];\n      char *dst = &cl->compareFB[y * pitch + x * ps];\n      int row, col;\n      int hBlockSize = rfbICEBlockSize == 0 ? w : rfbICEBlockSize;\n      int vBlockSize = rfbICEBlockSize == 0 ? h : rfbICEBlockSize;\n\n      for (row = 0; row < h; row += vBlockSize) {\n        for (col = 0; col < w; col += hBlockSize) {\n\n          Bool different = FALSE;\n          int compareWidth = min(hBlockSize, w - col);\n          int compareHeight = min(vBlockSize, h - row);\n          int rows = compareHeight;\n          char *srcPtr = &src[row * pitch + col * ps];\n          char *dstPtr = &dst[row * pitch + col * ps];\n\n          while (rows--) {\n            if (cl->firstCompare ||\n                memcmp(srcPtr, dstPtr, compareWidth * ps)) {\n              memcpy(dstPtr, srcPtr, compareWidth * ps);\n              different = TRUE;\n            }\n            srcPtr += pitch;\n            dstPtr += pitch;\n          }\n          if (different || rfbInterframeDebug) {\n            RegionRec tmpRegion;\n            BoxRec box;\n            box.x1 = x + col;\n            box.y1 = y + row;\n            box.x2 = box.x1 + compareWidth;\n            box.y2 = box.y1 + compareHeight;\n\n            REGION_INIT(pScreen, &tmpRegion, &box, 1);\n            if (!different && rfbInterframeDebug &&\n                !RECT_IN_REGION(pScreen, &cl->ifRegion, &box)) {\n              int pad = pitch - compareWidth * ps;\n\n              dstPtr = &dst[row * pitch + col * ps];\n              REGION_UNION(pScreen, &idRegion, &idRegion, &tmpRegion);\n              rows = compareHeight;\n\n              while (rows--) {\n                char *endOfRow = &dstPtr[compareWidth * ps];\n                while (dstPtr < endOfRow)\n                  *dstPtr++ ^= 0xFF;\n                dstPtr += pad;\n              }\n            }\n            REGION_UNION(pScreen, &cl->ifRegion, &cl->ifRegion, &tmpRegion);\n            REGION_UNINIT(pScreen, &tmpRegion);\n          }\n          if (!different && rfbProfile) {\n            idmpixels += (double)(compareWidth * compareHeight) / 1000000.;\n            if (!rfbInterframeDebug)\n              mpixels += (double)(compareWidth * compareHeight) / 1000000.;\n          }\n        }\n      }\n    }\n    REGION_UNINIT(pScreen, &_updateRegion);\n    REGION_NULL(pScreen, &_updateRegion);\n    cl->firstCompare = FALSE;\n\n    /* The Windows TurboVNC Viewer (and probably some other VNC viewers as\n       well) will ignore any empty FBUs and stop sending FBURs when it\n       receives one.  If CU is not active, then this causes the viewer to\n       stop receiving updates until something else, such as a mouse cursor\n       change, triggers a new FBUR.  Thus, if the ICE culls all of the\n       pixels in this update, we send a 1-pixel FBU rather than an empty\n       one. */\n    if (REGION_NUM_RECTS(updateRegion) == 0) {\n      BoxRec box;\n      box.x1 = box.y1 = 0;\n      box.x2 = box.y2 = 1;\n      REGION_UNINIT(pScreen, updateRegion);\n      REGION_INIT(pScreen, updateRegion, &box, 1);\n    }\n  }\n\n  if (!rfbSendRTTPing(cl))\n    goto abort;\n\n  cl->rfbFramebufferUpdateMessagesSent++;\n\n  if (cl->preferredEncoding == rfbEncodingCoRRE) {\n    nUpdateRegionRects = 0;\n\n    for (i = 0; i < REGION_NUM_RECTS(updateRegion); i++) {\n      int x = REGION_RECTS(updateRegion)[i].x1;\n      int y = REGION_RECTS(updateRegion)[i].y1;\n      int w = REGION_RECTS(updateRegion)[i].x2 - x;\n      int h = REGION_RECTS(updateRegion)[i].y2 - y;\n      nUpdateRegionRects += (((w - 1) / cl->correMaxWidth + 1) *\n                             ((h - 1) / cl->correMaxHeight + 1));\n    }\n  } else if (cl->preferredEncoding == rfbEncodingZlib) {\n    nUpdateRegionRects = 0;\n\n    for (i = 0; i < REGION_NUM_RECTS(updateRegion); i++) {\n      int x = REGION_RECTS(updateRegion)[i].x1;\n      int y = REGION_RECTS(updateRegion)[i].y1;\n      int w = REGION_RECTS(updateRegion)[i].x2 - x;\n      int h = REGION_RECTS(updateRegion)[i].y2 - y;\n      nUpdateRegionRects += (((h - 1) / (ZLIB_MAX_SIZE(w) / w)) + 1);\n    }\n  } else if (cl->preferredEncoding == rfbEncodingTight) {\n    nUpdateRegionRects = 0;\n\n    for (i = 0; i < REGION_NUM_RECTS(updateRegion); i++) {\n      int x = REGION_RECTS(updateRegion)[i].x1;\n      int y = REGION_RECTS(updateRegion)[i].y1;\n      int w = REGION_RECTS(updateRegion)[i].x2 - x;\n      int h = REGION_RECTS(updateRegion)[i].y2 - y;\n      int n = rfbNumCodedRectsTight(cl, x, y, w, h);\n      if (n == 0) {\n        nUpdateRegionRects = 0xFFFF;\n        break;\n      }\n      nUpdateRegionRects += n;\n    }\n  } else {\n    nUpdateRegionRects = REGION_NUM_RECTS(updateRegion);\n  }\n\n  fu->type = rfbFramebufferUpdate;\n  if (nUpdateRegionRects != 0xFFFF) {\n    fu->nRects = Swap16IfLE(REGION_NUM_RECTS(&updateCopyRegion) +\n                            nUpdateRegionRects +\n                            !!sendCursorShape + !!sendCursorPos);\n  } else {\n    fu->nRects = 0xFFFF;\n  }\n  ublen = sz_rfbFramebufferUpdateMsg;\n\n  cl->captureEnable = TRUE;\n\n  if (sendCursorShape) {\n    cl->cursorWasChanged = FALSE;\n    if (!rfbSendCursorShape(cl, pScreen))\n      goto abort;\n  }\n\n  if (sendCursorPos) {\n    cl->cursorWasMoved = FALSE;\n    if (!rfbSendCursorPos(cl, pScreen))\n      goto abort;\n  }\n\n  if (REGION_NOTEMPTY(pScreen, &updateCopyRegion)) {\n    if (!rfbSendCopyRegion(cl, &updateCopyRegion, dx, dy))\n      goto abort;\n  }\n\n  REGION_UNINIT(pScreen, &updateCopyRegion);\n  REGION_NULL(pScreen, &updateCopyRegion);\n\n  for (i = 0; i < REGION_NUM_RECTS(updateRegion); i++) {\n    int x = REGION_RECTS(updateRegion)[i].x1;\n    int y = REGION_RECTS(updateRegion)[i].y1;\n    int w = REGION_RECTS(updateRegion)[i].x2 - x;\n    int h = REGION_RECTS(updateRegion)[i].y2 - y;\n\n    cl->rfbRawBytesEquivalent += (sz_rfbFramebufferUpdateRectHeader +\n                                 w * (cl->format.bitsPerPixel / 8) * h);\n\n    if (rfbProfile) mpixels += (double)w * (double)h / 1000000.;\n\n    switch (cl->preferredEncoding) {\n      case rfbEncodingRaw:\n        if (!rfbSendRectEncodingRaw(cl, x, y, w, h))\n          goto abort;\n        break;\n      case rfbEncodingRRE:\n        if (!rfbSendRectEncodingRRE(cl, x, y, w, h))\n          goto abort;\n        break;\n      case rfbEncodingCoRRE:\n        if (!rfbSendRectEncodingCoRRE(cl, x, y, w, h))\n          goto abort;\n        break;\n      case rfbEncodingHextile:\n        if (!rfbSendRectEncodingHextile(cl, x, y, w, h))\n          goto abort;\n        break;\n      case rfbEncodingZlib:\n        if (!rfbSendRectEncodingZlib(cl, x, y, w, h))\n          goto abort;\n        break;\n      case rfbEncodingZRLE:\n      case rfbEncodingZYWRLE:\n        if (!rfbSendRectEncodingZRLE(cl, x, y, w, h))\n          goto abort;\n        break;\n      case rfbEncodingTight:\n        if (!rfbSendRectEncodingTight(cl, x, y, w, h))\n          goto abort;\n        break;\n    }\n  }\n\n  if (cl->compareFB) {\n    if (rfbInterframeDebug) {\n      for (i = 0; i < REGION_NUM_RECTS(&idRegion); i++) {\n        int x = REGION_RECTS(&idRegion)[i].x1;\n        int y = REGION_RECTS(&idRegion)[i].y1;\n        int w = REGION_RECTS(&idRegion)[i].x2 - x;\n        int h = REGION_RECTS(&idRegion)[i].y2 - y, rows;\n        int pitch = rfbFB.paddedWidthInBytes;\n        int ps = rfbServerFormat.bitsPerPixel / 8;\n        char *src = &rfbFB.pfbMemory[y * pitch + x * ps];\n        char *dst = &cl->compareFB[y * pitch + x * ps];\n        rows = h;\n        while (rows--) {\n          memcpy(dst, src, w * ps);\n          src += pitch;\n          dst += pitch;\n        }\n      }\n      REGION_UNINIT(pScreen, &idRegion);\n      REGION_NULL(pScreen, &idRegion);\n    }\n    REGION_EMPTY(pScreen, updateRegion);\n  } else {\n    REGION_UNINIT(pScreen, updateRegion);\n    REGION_NULL(pScreen, updateRegion);\n  }\n\n  if (nUpdateRegionRects == 0xFFFF && !rfbSendLastRectMarker(cl))\n    goto abort;\n\n  if (!rfbSendUpdateBuf(cl))\n    goto abort;\n\n  cl->captureEnable = FALSE;\n\n  if (!rfbSendRTTPing(cl))\n    goto abort;\n\n  if (rfbProfile) {\n    tUpdate += gettime() - tUpdateStart;\n    tElapsed = gettime() - tStart;\n    iter++;\n\n    if (tElapsed > 5.) {\n      rfbLog(\"%.2f updates/sec,  %.2f Mpixels/sec,  %.3f Mbits/sec\\n\",\n             (double)iter / tElapsed, mpixels / tElapsed,\n             (double)sendBytes / 125000. / tElapsed);\n      rfbLog(\"Time/update:  Encode = %.3f ms,  Other = %.3f ms\\n\",\n             tUpdate / (double)iter * 1000.,\n             (tElapsed - tUpdate) / (double)iter * 1000.);\n      if (cl->compareFB) {\n        rfbLog(\"Identical Mpixels/sec:  %.2f  (%f %%)\\n\",\n               (double)idmpixels / tElapsed, idmpixels / mpixels * 100.0);\n        idmpixels = 0.;\n      }\n      tUpdate = 0.;\n      iter = 0;\n      mpixels = 0.;\n      sendBytes = 0;\n      tStart = gettime();\n    }\n  }\n\n  if (rfbAutoLosslessRefresh > 0.0 &&\n      (!putImageOnly || REGION_NOTEMPTY(pScreen, &cl->alrEligibleRegion) ||\n       cl->firstUpdate)) {\n    if (putImageOnly)\n      REGION_UNION(pScreen, &cl->alrRegion, &cl->alrRegion,\n                   &cl->alrEligibleRegion);\n    REGION_EMPTY(pScreen, &cl->alrEligibleRegion);\n    cl->alrTimer = TimerSet(cl->alrTimer, 0,\n                            (CARD32)(rfbAutoLosslessRefresh * 1000.0),\n                            alrCallback, cl);\n  }\n\n  rfbUncorkSock(cl->sock);\n  return TRUE;\n\n  abort:\n  if (!REGION_NIL(&updateCopyRegion))\n    REGION_UNINIT(pScreen, &updateCopyRegion);\n  if (rfbInterframeDebug && !REGION_NIL(&idRegion))\n    REGION_UNINIT(pScreen, &idRegion);\n  if (emptyUpdateRegion) {\n    /* Make sure cl hasn't been freed */\n    for (cl2 = rfbClientHead; cl2; cl2 = cl2->next) {\n      if (cl2 == cl) {\n        REGION_EMPTY(pScreen, updateRegion);\n        break;\n      }\n    }\n  } else if (!REGION_NIL(&_updateRegion)) {\n    REGION_UNINIT(pScreen, &_updateRegion);\n  }\n  return FALSE;\n}\n\n\n/*\n * Send the copy region as a string of CopyRect encoded rectangles.\n * The only slightly tricky thing is that we should send the messages in\n * the correct order so that an earlier CopyRect will not corrupt the source\n * of a later one.\n */\n\nstatic Bool rfbSendCopyRegion(rfbClientPtr cl, RegionPtr reg, int dx, int dy)\n{\n  int nrects, nrectsInBand, x_inc, y_inc, thisRect, firstInNextBand;\n  int x, y, w, h;\n  rfbFramebufferUpdateRectHeader rect;\n  rfbCopyRect cr;\n  ScreenPtr pScreen = screenInfo.screens[0];\n\n  nrects = REGION_NUM_RECTS(reg);\n\n  if (dx <= 0)\n    x_inc = 1;\n  else\n    x_inc = -1;\n\n  if (dy <= 0) {\n    thisRect = 0;\n    y_inc = 1;\n  } else {\n    thisRect = nrects - 1;\n    y_inc = -1;\n  }\n\n  /* If the source region intersects the lossy region, then we know that the\n     destination region is about to become lossy, so we add it to the lossy\n     region. */\n  if (rfbAutoLosslessRefresh > 0.0 && alrCopyRect &&\n      REGION_NOTEMPTY(pScreen, reg)) {\n    RegionRec tmpRegion;\n    REGION_INIT(pScreen, &tmpRegion, NullBox, 0);\n    REGION_COPY(pScreen, &tmpRegion, reg);\n    REGION_TRANSLATE(pScreen, &tmpRegion, -dx, -dy);\n    REGION_INTERSECT(pScreen, &tmpRegion, &cl->lossyRegion, &tmpRegion);\n    if (REGION_NOTEMPTY(pScreen, &tmpRegion)) {\n      REGION_UNION(pScreen, &cl->lossyRegion, &cl->lossyRegion, reg);\n      REGION_UNION(pScreen, &cl->alrEligibleRegion, &cl->alrEligibleRegion,\n                   reg);\n    }\n    REGION_UNINIT(pScreen, &tmpRegion);\n  }\n\n  if (reg->extents.x2 > pScreen->width || reg->extents.y2 > pScreen->height)\n    rfbLog(\"WARNING: CopyRect dest at %d,%d with dimensions %dx%d exceeds screen boundaries\\n\",\n           reg->extents.x1, reg->extents.y1,\n           reg->extents.x2 - reg->extents.x1,\n           reg->extents.y2 - reg->extents.y1);\n\n  while (nrects > 0) {\n\n    firstInNextBand = thisRect;\n    nrectsInBand = 0;\n\n    while ((nrects > 0) &&\n           (REGION_RECTS(reg)[firstInNextBand].y1 ==\n            REGION_RECTS(reg)[thisRect].y1)) {\n      firstInNextBand += y_inc;\n      nrects--;\n      nrectsInBand++;\n    }\n\n    if (x_inc != y_inc)\n      thisRect = firstInNextBand - y_inc;\n\n    while (nrectsInBand > 0) {\n      if ((ublen + sz_rfbFramebufferUpdateRectHeader + sz_rfbCopyRect) >\n          UPDATE_BUF_SIZE) {\n        if (!rfbSendUpdateBuf(cl))\n          return FALSE;\n      }\n\n      x = REGION_RECTS(reg)[thisRect].x1;\n      y = REGION_RECTS(reg)[thisRect].y1;\n      w = REGION_RECTS(reg)[thisRect].x2 - x;\n      h = REGION_RECTS(reg)[thisRect].y2 - y;\n\n      if (cl->compareFB) {\n        int pitch = rfbFB.paddedWidthInBytes;\n        int ps = rfbServerFormat.bitsPerPixel / 8, rows = h;\n        char *src = &rfbFB.pfbMemory[y * pitch + x * ps];\n        char *dst = &cl->compareFB[y * pitch + x * ps];\n        while (rows--) {\n          memcpy(dst, src, w * ps);\n          src += pitch;\n          dst += pitch;\n        }\n        src = &rfbFB.pfbMemory[(y - dy) * pitch + (x - dx) * ps];\n        dst = &cl->compareFB[(y - dy) * pitch + (x - dx) * ps];\n        rows = h;\n        while (rows--) {\n          memcpy(dst, src, w * ps);\n          src += pitch;\n          dst += pitch;\n        }\n      }\n\n      rect.r.x = Swap16IfLE(x);\n      rect.r.y = Swap16IfLE(y);\n      rect.r.w = Swap16IfLE(w);\n      rect.r.h = Swap16IfLE(h);\n      rect.encoding = Swap32IfLE(rfbEncodingCopyRect);\n\n      memcpy(&updateBuf[ublen], (char *)&rect,\n             sz_rfbFramebufferUpdateRectHeader);\n      ublen += sz_rfbFramebufferUpdateRectHeader;\n\n      cr.srcX = Swap16IfLE(x - dx);\n      cr.srcY = Swap16IfLE(y - dy);\n\n      memcpy(&updateBuf[ublen], (char *)&cr, sz_rfbCopyRect);\n      ublen += sz_rfbCopyRect;\n\n      cl->rfbRectanglesSent[rfbEncodingCopyRect]++;\n      cl->rfbBytesSent[rfbEncodingCopyRect] +=\n        sz_rfbFramebufferUpdateRectHeader + sz_rfbCopyRect;\n\n      thisRect += x_inc;\n      nrectsInBand--;\n    }\n\n    thisRect = firstInNextBand;\n  }\n\n  return TRUE;\n}\n\n\n/*\n * Send a given rectangle in raw encoding (rfbEncodingRaw).\n */\n\nBool rfbSendRectEncodingRaw(rfbClientPtr cl, int x, int y, int w, int h)\n{\n  rfbFramebufferUpdateRectHeader rect;\n  int nlines;\n  int bytesPerLine = w * (cl->format.bitsPerPixel / 8);\n  char *fbptr =\n    (cl->fb + (rfbFB.paddedWidthInBytes * y) + (x * (rfbFB.bitsPerPixel / 8)));\n\n  /* Flush the buffer to guarantee correct alignment for translateFn(). */\n  if (ublen > 0) {\n    if (!rfbSendUpdateBuf(cl))\n      return FALSE;\n  }\n\n  rect.r.x = Swap16IfLE(x);\n  rect.r.y = Swap16IfLE(y);\n  rect.r.w = Swap16IfLE(w);\n  rect.r.h = Swap16IfLE(h);\n  rect.encoding = Swap32IfLE(rfbEncodingRaw);\n\n  memcpy(&updateBuf[ublen], (char *)&rect, sz_rfbFramebufferUpdateRectHeader);\n  ublen += sz_rfbFramebufferUpdateRectHeader;\n\n  cl->rfbRectanglesSent[rfbEncodingRaw]++;\n  cl->rfbBytesSent[rfbEncodingRaw] +=\n    sz_rfbFramebufferUpdateRectHeader + bytesPerLine * h;\n\n  nlines = (UPDATE_BUF_SIZE - ublen) / bytesPerLine;\n\n  while (TRUE) {\n    if (nlines > h)\n      nlines = h;\n\n    (*cl->translateFn) (cl->translateLookupTable, &rfbServerFormat,\n                        &cl->format, fbptr, &updateBuf[ublen],\n                        rfbFB.paddedWidthInBytes, w, nlines);\n\n    ublen += nlines * bytesPerLine;\n    h -= nlines;\n\n    if (h == 0)         /* rect fitted in buffer, do next one */\n      return TRUE;\n\n    /* buffer full - flush partial rect and do another nlines */\n\n    if (!rfbSendUpdateBuf(cl))\n      return FALSE;\n\n    fbptr += (rfbFB.paddedWidthInBytes * nlines);\n\n    nlines = (UPDATE_BUF_SIZE - ublen) / bytesPerLine;\n    if (nlines == 0) {\n      rfbLog(\"rfbSendRectEncodingRaw: send buffer too small for %d bytes per line\\n\",\n             bytesPerLine);\n      rfbCloseClient(cl);\n      return FALSE;\n    }\n  }\n}\n\n\n/*\n * Send an empty rectangle with encoding field set to value of\n * rfbEncodingLastRect to notify client that this is the last\n * rectangle in framebuffer update (\"LastRect\" extension of RFB\n * protocol).\n */\n\nstatic Bool rfbSendLastRectMarker(rfbClientPtr cl)\n{\n  rfbFramebufferUpdateRectHeader rect;\n\n  if (ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE) {\n    if (!rfbSendUpdateBuf(cl))\n      return FALSE;\n  }\n\n  rect.encoding = Swap32IfLE(rfbEncodingLastRect);\n  rect.r.x = 0;\n  rect.r.y = 0;\n  rect.r.w = 0;\n  rect.r.h = 0;\n\n  memcpy(&updateBuf[ublen], (char *)&rect, sz_rfbFramebufferUpdateRectHeader);\n  ublen += sz_rfbFramebufferUpdateRectHeader;\n\n  cl->rfbLastRectMarkersSent++;\n  cl->rfbLastRectBytesSent += sz_rfbFramebufferUpdateRectHeader;\n\n  return TRUE;\n}\n\n\n/*\n * Send the contents of updateBuf.  Returns 1 if successful, -1 if\n * not (errno should be set).\n */\n\nBool rfbSendUpdateBuf(rfbClientPtr cl)\n{\n  /*\n  int i;\n  for (i = 0; i < ublen; i++) {\n    fprintf(stderr, \"%02x \", ((unsigned char *)updateBuf)[i]);\n  }\n  fprintf(stderr, \"\\n\");\n  */\n\n  if (ublen > 0 && WriteExact(cl, updateBuf, ublen) < 0) {\n    rfbLogPerror(\"rfbSendUpdateBuf: write\");\n    rfbCloseClient(cl);\n    return FALSE;\n  }\n\n  if (cl->captureEnable && cl->captureFD >= 0 && ublen > 0)\n    WriteCapture(cl->captureFD, updateBuf, ublen);\n\n  ublen = 0;\n  return TRUE;\n}\n\n\n/*\n * rfbSendSetColourMapEntries sends a SetColourMapEntries message to the\n * client, using values from the currently installed colormap.\n */\n\nBool rfbSendSetColourMapEntries(rfbClientPtr cl, int firstColour, int nColours)\n{\n  char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];\n  rfbSetColourMapEntriesMsg *scme = (rfbSetColourMapEntriesMsg *)buf;\n  CARD16 *rgb = (CARD16 *)(&buf[sz_rfbSetColourMapEntriesMsg]);\n  EntryPtr pent;\n  int i, len;\n\n  scme->type = rfbSetColourMapEntries;\n\n  scme->firstColour = Swap16IfLE(firstColour);\n  scme->nColours = Swap16IfLE(nColours);\n\n  len = sz_rfbSetColourMapEntriesMsg;\n\n  pent = (EntryPtr)&rfbInstalledColormap->red[firstColour];\n  for (i = 0; i < nColours; i++) {\n    if (pent->fShared) {\n      rgb[i * 3] = Swap16IfLE(pent->co.shco.red->color);\n      rgb[i * 3 + 1] = Swap16IfLE(pent->co.shco.green->color);\n      rgb[i * 3 + 2] = Swap16IfLE(pent->co.shco.blue->color);\n    } else {\n      rgb[i * 3] = Swap16IfLE(pent->co.local.red);\n      rgb[i * 3 + 1] = Swap16IfLE(pent->co.local.green);\n      rgb[i * 3 + 2] = Swap16IfLE(pent->co.local.blue);\n    }\n    pent++;\n  }\n\n  len += nColours * 3 * 2;\n\n  if (WriteExact(cl, buf, len) < 0) {\n    rfbLogPerror(\"rfbSendSetColourMapEntries: write\");\n    rfbCloseClient(cl);\n    return FALSE;\n  }\n\n  if (cl->captureFD >= 0)\n    WriteCapture(cl->captureFD, buf, len);\n\n  return TRUE;\n}\n\n\n/*\n * rfbSendBell sends a Bell message to all the clients.\n */\n\nvoid rfbSendBell(void)\n{\n  rfbClientPtr cl, nextCl;\n  rfbBellMsg b;\n\n  for (cl = rfbClientHead; cl; cl = nextCl) {\n    nextCl = cl->next;\n    if (cl->state != RFB_NORMAL)\n      continue;\n    b.type = rfbBell;\n    if (WriteExact(cl, (char *)&b, sz_rfbBellMsg) < 0) {\n      rfbLogPerror(\"rfbSendBell: write\");\n      rfbCloseClient(cl);\n      continue;\n    }\n    if (cl->captureFD >= 0)\n      WriteCapture(cl->captureFD, (char *)&b, sz_rfbBellMsg);\n  }\n}\n\n\n/*\n * rfbSendServerCutText sends a ServerCutText message to all the clients.\n */\n\nvoid rfbSendServerCutText(char *str, int len)\n{\n  rfbClientPtr cl, nextCl;\n  rfbServerCutTextMsg sct;\n\n  if (rfbViewOnly || rfbAuthDisableCBSend || !str || len <= 0)\n    return;\n\n  for (cl = rfbClientHead; cl; cl = nextCl) {\n    nextCl = cl->next;\n    if (cl->state != RFB_NORMAL || cl->viewOnly)\n      continue;\n    if (cl->cutTextLen == len && cl->cutText && !memcmp(cl->cutText, str, len))\n      continue;\n    if (cl->cutText)\n      free(cl->cutText);\n    cl->cutText = rfbAlloc(len);\n    memcpy(cl->cutText, str, len);\n    cl->cutTextLen = len;\n    memset(&sct, 0, sz_rfbServerCutTextMsg);\n    sct.type = rfbServerCutText;\n    sct.length = Swap32IfLE(len);\n    if (WriteExact(cl, (char *)&sct, sz_rfbServerCutTextMsg) < 0) {\n      rfbLogPerror(\"rfbSendServerCutText: write\");\n      rfbCloseClient(cl);\n      continue;\n    }\n    if (WriteExact(cl, str, len) < 0) {\n      rfbLogPerror(\"rfbSendServerCutText: write\");\n      rfbCloseClient(cl);\n      continue;\n    }\n    if (cl->captureFD >= 0)\n      WriteCapture(cl->captureFD, str, len);\n  }\n  LogMessage(X_DEBUG, \"Sent server clipboard: '%.*s%s' (%d bytes)\\n\",\n             len <= 20 ? len : 20, str, len <= 20 ? \"\" : \"...\", len);\n}\n\n\n/*\n * rfbSendDesktopSize sends a DesktopSize message to a specific client.\n */\n\nBool rfbSendDesktopSize(rfbClientPtr cl)\n{\n  rfbFramebufferUpdateRectHeader rh;\n  rfbFramebufferUpdateMsg fu;\n\n  if (!cl->enableDesktopSize)\n    return TRUE;\n\n  memset(&fu, 0, sz_rfbFramebufferUpdateMsg);\n  fu.type = rfbFramebufferUpdate;\n  fu.nRects = Swap16IfLE(1);\n  if (WriteExact(cl, (char *)&fu, sz_rfbFramebufferUpdateMsg) < 0) {\n    rfbLogPerror(\"rfbSendDesktopSize: write\");\n    rfbCloseClient(cl);\n    return FALSE;\n  }\n\n  rh.encoding = Swap32IfLE(rfbEncodingNewFBSize);\n  rh.r.x = rh.r.y = 0;\n  rh.r.w = Swap16IfLE(rfbFB.width);\n  rh.r.h = Swap16IfLE(rfbFB.height);\n  if (WriteExact(cl, (char *)&rh, sz_rfbFramebufferUpdateRectHeader) < 0) {\n    rfbLogPerror(\"rfbSendDesktopSize: write\");\n    rfbCloseClient(cl);\n    return FALSE;\n  }\n\n  return TRUE;\n}\n\n\n/*\n * rfbSendExtDesktopSize sends an extended desktop size message to a specific\n * client.\n */\n\nBool rfbSendExtDesktopSize(rfbClientPtr cl)\n{\n  rfbFramebufferUpdateRectHeader rh;\n  rfbFramebufferUpdateMsg fu;\n  CARD8 numScreens[4] = { 0, 0, 0, 0 };\n  rfbScreenInfo *iter;\n  BOOL fakeScreen = FALSE;\n\n  if (!cl->enableExtDesktopSize)\n    return TRUE;\n  /* Error messages can only be sent with the EDS extension */\n  if (!cl->enableExtDesktopSize && cl->result != rfbEDSResultSuccess)\n    return TRUE;\n\n  memset(&fu, 0, sz_rfbFramebufferUpdateMsg);\n  fu.type = rfbFramebufferUpdate;\n  fu.nRects = Swap16IfLE(1);\n  if (WriteExact(cl, (char *)&fu, sz_rfbFramebufferUpdateMsg) < 0) {\n    rfbLogPerror(\"rfbSendExtDesktopSize: write\");\n    rfbCloseClient(cl);\n    return FALSE;\n  }\n\n  /* Send the ExtendedDesktopSize message, if the client supports it.\n     The TigerVNC Viewer, in particular, requires this, or it won't\n     enable remote desktop resize. */\n  rh.encoding = Swap32IfLE(rfbEncodingExtendedDesktopSize);\n  rh.r.x = Swap16IfLE(cl->reason);\n  rh.r.y = Swap16IfLE(cl->result);\n  rh.r.w = Swap16IfLE(rfbFB.width);\n  rh.r.h = Swap16IfLE(rfbFB.height);\n  if (WriteExact(cl, (char *)&rh, sz_rfbFramebufferUpdateRectHeader) < 0) {\n    rfbLogPerror(\"rfbSendExtDesktopSize: write\");\n    rfbCloseClient(cl);\n    return FALSE;\n  }\n\n  xorg_list_for_each_entry(iter, &rfbScreens, entry) {\n    if (iter->output->crtc && iter->output->crtc->mode)\n      numScreens[0]++;\n  }\n  if (numScreens[0] < 1) {\n    numScreens[0] = 1;\n    fakeScreen = TRUE;\n  }\n\n  if (WriteExact(cl, (char *)numScreens, 4) < 0) {\n    rfbLogPerror(\"rfbSendExtDesktopSize: write\");\n    rfbCloseClient(cl);\n    return FALSE;\n  }\n\n  if (fakeScreen) {\n    rfbScreenInfo screen = *xorg_list_first_entry(&rfbScreens, rfbScreenInfo,\n                                                  entry);\n    screen.s.id = Swap32IfLE(screen.s.id);\n    screen.s.x = screen.s.y = 0;\n    screen.s.w = Swap16IfLE(rfbFB.width);\n    screen.s.h = Swap16IfLE(rfbFB.height);\n    screen.s.flags = Swap32IfLE(screen.s.flags);\n    if (WriteExact(cl, (char *)&screen.s, sz_rfbScreenDesc) < 0) {\n      rfbLogPerror(\"rfbSendExtDesktopSize: write\");\n      rfbCloseClient(cl);\n      return FALSE;\n    }\n  } else {\n    xorg_list_for_each_entry(iter, &rfbScreens, entry) {\n      rfbScreenInfo screen = *iter;\n\n      if (screen.output->crtc && screen.output->crtc->mode) {\n        screen.s.id = Swap32IfLE(screen.s.id);\n        screen.s.x = Swap16IfLE(screen.s.x);\n        screen.s.y = Swap16IfLE(screen.s.y);\n        screen.s.w = Swap16IfLE(screen.s.w);\n        screen.s.h = Swap16IfLE(screen.s.h);\n        screen.s.flags = Swap32IfLE(screen.s.flags);\n        if (WriteExact(cl, (char *)&screen.s, sz_rfbScreenDesc) < 0) {\n          rfbLogPerror(\"rfbSendExtDesktopSize: write\");\n          rfbCloseClient(cl);\n          return FALSE;\n        }\n      }\n    }\n  }\n\n  return TRUE;\n}\n\n\n/*****************************************************************************\n *\n * UDP can be used for keyboard and pointer events when the underlying\n * network is highly reliable.  This is really here to support ORL's\n * videotile, whose TCP implementation doesn't like sending lots of small\n * packets (such as 100s of pen readings per second!).\n */\n\nvoid rfbNewUDPConnection(int sock)\n{\n  if (write(sock, &ptrAcceleration, 1) < 0)\n    rfbLogPerror(\"rfbNewUDPConnection: write\");\n}\n\n/*\n * Because UDP is a message based service, we can't read the first byte and\n * then the rest of the packet separately like we do with TCP.  We will always\n * get a whole packet delivered in one go, so we ask read() for the maximum\n * number of bytes we can possibly get.\n */\n\nvoid rfbProcessUDPInput(int sock)\n{\n  int n;\n  rfbClientToServerMsg msg;\n\n  if ((n = read(sock, (char *)&msg, sizeof(msg))) <= 0) {\n    if (n < 0)\n      rfbLogPerror(\"rfbProcessUDPInput: read\");\n    rfbDisconnectUDPSock();\n    return;\n  }\n\n  switch (msg.type) {\n    case rfbKeyEvent:\n      if (n != sz_rfbKeyEventMsg) {\n        rfbLog(\"rfbProcessUDPInput: key event incorrect length\\n\");\n        rfbDisconnectUDPSock();\n        return;\n      }\n      if (!rfbViewOnly)\n        KeyEvent((KeySym)Swap32IfLE(msg.ke.key), msg.ke.down);\n      break;\n\n    case rfbPointerEvent:\n      if (n != sz_rfbPointerEventMsg) {\n        rfbLog(\"rfbProcessUDPInput: ptr event incorrect length\\n\");\n        rfbDisconnectUDPSock();\n        return;\n      }\n      if (!rfbViewOnly)\n        PtrAddEvent(msg.pe.buttonMask, Swap16IfLE(msg.pe.x),\n                    Swap16IfLE(msg.pe.y), 0);\n      break;\n\n    default:\n      rfbLog(\"rfbProcessUDPInput: unknown message type %d\\n\", msg.type);\n      rfbDisconnectUDPSock();\n  }\n}\n"], "fixing_code": ["/*\n * auth.c - deal with authentication.\n *\n * This file implements authentication when setting up an RFB connection.\n */\n\n/*\n *  Copyright (C) 2010, 2012-2019 D. R. Commander.  All Rights Reserved.\n *  Copyright (C) 2010 University Corporation for Atmospheric Research.\n *                     All Rights Reserved.\n *  Copyright (C) 2003-2006 Constantin Kaplinsky.  All Rights Reserved.\n *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n *  USA.\n */\n\n#ifndef _POSIX_PTHREAD_SEMANTICS\n#define _POSIX_PTHREAD_SEMANTICS\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"rfb.h\"\n#include \"windowstr.h\"\n\n\nchar *rfbAuthPasswdFile = NULL;\n\nstatic void rfbSendSecurityType(rfbClientPtr cl, int securityType);\nstatic void rfbSendSecurityTypeList(rfbClientPtr cl);\nstatic void rfbSendTunnelingCaps(rfbClientPtr cl);\nstatic void rfbSendAuthCaps(rfbClientPtr cl);\n\nstatic void rfbVncAuthSendChallenge(rfbClientPtr cl);\nstatic void rfbVeNCryptAuthenticate(rfbClientPtr cl);\n\n#define AUTH_DEFAULT_CONF_FILE  \\\n  CMAKE_INSTALL_FULL_SYSCONFDIR \"/turbovncserver-security.conf\"\n#ifdef XVNC_AuthPAM\n#define AUTH_DEFAULT_PAM_SERVICE_NAME \"turbovnc\"\n#endif\n\n#define MAX_USER_LEN 64\n#define MAX_PWD_LEN 64\n\nchar *rfbAuthConfigFile = AUTH_DEFAULT_CONF_FILE;\nBool rfbAuthDisableRemoteResize = FALSE;\nBool rfbAuthDisableRevCon = FALSE;\nBool rfbAuthDisableCBSend = FALSE;\nBool rfbAuthDisableCBRecv = FALSE;\nBool rfbAuthDisableHTTP = FALSE;\nBool rfbAuthDisableX11TCP = FALSE;\n\nstatic int nSecTypesEnabled = 0;\nstatic int preferenceLimit = 1;  /* Force one iteration of the loop in\n                                    rfbSendAuthCaps() */\n\nchar *rfbAuthOTPValue = NULL;\nint rfbAuthOTPValueLen = 0;\n#if USETLS\nchar *rfbAuthX509Cert = NULL;\nchar *rfbAuthX509Key = NULL;\nchar *rfbAuthCipherSuites = NULL;\n#endif\n\n\nstatic void AuthNoneStartFunc(rfbClientPtr cl)\n{\n  rfbClientAuthSucceeded(cl, rfbAuthNone);\n}\n\nstatic void AuthNoneRspFunc(rfbClientPtr cl)\n{\n}\n\n\n#ifdef XVNC_AuthPAM\n\n#include <pwd.h>\n\nstatic char *pamServiceName = AUTH_DEFAULT_PAM_SERVICE_NAME;\n\ntypedef struct UserList {\n  struct UserList *next;\n  const char *name;\n  Bool viewOnly;\n} UserList;\n\nstatic UserList *userACL = NULL;\nBool rfbAuthUserACL = FALSE;\n\n\nvoid rfbAuthAddUser(const char *name, Bool viewOnly)\n{\n  UserList *p = (UserList *)rfbAlloc(sizeof(UserList));\n\n  rfbLog(\"Adding user '%s' to ACL with %s privileges\\n\", name,\n         viewOnly ? \" view-only\" : \"full control\");\n  p->next = userACL;\n  p->name = name;\n  p->viewOnly = viewOnly;\n  userACL = p;\n}\n\n\nvoid rfbAuthRevokeUser(const char *name)\n{\n  UserList **prev = &userACL;\n  UserList *p;\n\n  rfbLog(\"Removing user '%s' from ACL\\n\", name);\n  while (*prev != NULL) {\n    p = *prev;\n    if (!strcmp(p->name, name)) {\n      *prev = p->next;\n      free((void *)p->name);\n      free(p);\n      return;\n    }\n\n    prev = &p->next;\n  }\n}\n\n\nstatic void AuthPAMUserPwdStartFunc(rfbClientPtr cl)\n{\n  cl->state = RFB_AUTHENTICATION;\n}\n\n\nstatic void AuthPAMUserPwdRspFunc(rfbClientPtr cl)\n{\n  CARD32 userLen;\n  CARD32 pwdLen;\n  char userBuf[MAX_USER_LEN + 1];\n  char pwdBuf[MAX_PWD_LEN + 1];\n  int n;\n  const char *emsg;\n\n  n = ReadExact(cl, (char *)&userLen, sizeof(userLen));\n  if (n <= 0) {\n    if (n != 0)\n      rfbLogPerror(\"AuthPAMUserPwdRspFunc: read error\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  userLen = Swap32IfLE(userLen);\n  n = ReadExact(cl, (char *)&pwdLen, sizeof(pwdLen));\n  if (n <= 0) {\n    if (n != 0)\n      rfbLogPerror(\"AuthPAMUserPwdRspFunc: read error\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  pwdLen = Swap32IfLE(pwdLen);\n  if ((userLen > MAX_USER_LEN) || (pwdLen > MAX_PWD_LEN)) {\n    rfbLogPerror(\"AuthPAMUserPwdRspFunc: excessively large user name or password in response\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  n = ReadExact(cl, userBuf, userLen);\n  if (n <= 0) {\n    if (n != 0)\n      rfbLogPerror(\"AuthPAMUserPwdRspFunc: error reading user name\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  userBuf[userLen] = '\\0';\n  n = ReadExact(cl, pwdBuf, pwdLen);\n  if (n <= 0) {\n    if (n != 0)\n      rfbLogPerror(\"AuthPAMUserPwdRspFunc: error reading password\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  pwdBuf[pwdLen] = '\\0';\n  if (rfbAuthUserACL) {\n    UserList *p = userACL;\n\n    if (p == NULL)\n      rfbLog(\"WARNING: User ACL is empty.  No users will be allowed to log in with Unix Login authentication.\\n\");\n\n    while (p != NULL) {\n      if (!strcmp(p->name, userBuf))\n        break;\n      p = p->next;\n    }\n\n    if (p == NULL) {\n      rfbLog(\"User '%s' is not in the ACL and has been denied access\\n\",\n             userBuf);\n      rfbClientAuthFailed(cl, \"User denied access\");\n      return;\n    }\n\n    cl->viewOnly = p->viewOnly;\n  } else {\n    struct passwd pbuf;\n    struct passwd *pw;\n    char buf[256];\n\n    if (getpwuid_r(getuid(), &pbuf, buf, sizeof(buf), &pw) != 0)\n      FatalError(\"AuthPAMUserPwdRspFunc: getpwuid_r failed: %s\",\n                 strerror(errno));\n\n    if (strcmp(pbuf.pw_name, userBuf)) {\n      rfbLog(\"User '%s' denied access (not the session owner)\\n\", userBuf);\n      rfbLog(\"  Enable user ACL to grant access to other users.\\n\");\n      rfbClientAuthFailed(cl, \"User denied access\");\n      return;\n    }\n  }\n\n  if (rfbPAMAuthenticate(cl, pamServiceName, userBuf, pwdBuf, &emsg))\n    rfbClientAuthSucceeded(cl, rfbAuthUnixLogin);\n  else\n    rfbClientAuthFailed(cl, (char *)emsg);\n}\n\n#endif\n\n\ntypedef struct {\n  const char *name;\n  int protocolMinorVer;\n  Bool advertise;\n  CARD8 securityType;\n} RFBSecTypeData;\n\nstatic RFBSecTypeData secTypeNone =\n  { \"none\",    3, TRUE, rfbSecTypeNone };\nstatic RFBSecTypeData secTypeVncAuth =\n  { \"vncauth\", 3, TRUE, rfbSecTypeVncAuth };\nstatic RFBSecTypeData secTypeTight =\n  { \"tight\",   7, TRUE, rfbSecTypeTight };\nstatic RFBSecTypeData secTypeVeNCrypt =\n  { \"vencrypt\", 7, TRUE, rfbSecTypeVeNCrypt };\n\nstatic RFBSecTypeData *rfbSecTypes[] = {\n  &secTypeNone, &secTypeVncAuth, &secTypeVeNCrypt, &secTypeTight, NULL\n};\n\ntypedef void (*AuthFunc) (rfbClientPtr cl);\n\ntypedef struct {\n  int authType;\n  CARD8 vendorSignature[4];\n  CARD8 nameSignature[8];\n  AuthFunc startFunc;\n  AuthFunc rspFunc;\n} AuthCapData;\n\nstatic AuthCapData authCapNone =\n  { rfbAuthNone, rfbStandardVendor, sig_rfbAuthNone, AuthNoneStartFunc,\n    AuthNoneRspFunc };\n\nstatic AuthCapData authCapVncAuth =\n  { rfbAuthVNC, rfbStandardVendor, sig_rfbAuthVNC, rfbVncAuthSendChallenge,\n    rfbVncAuthProcessResponse };\n\nstatic AuthCapData authCapVeNCrypt =\n  { rfbAuthVeNCrypt, rfbVeNCryptVendor, sig_rfbAuthVeNCrypt,\n    rfbVeNCryptAuthenticate, AuthNoneRspFunc };\n\n#ifdef XVNC_AuthPAM\nstatic AuthCapData authCapUnixLogin =\n  { rfbAuthUnixLogin, rfbTightVncVendor, sig_rfbAuthUnixLogin,\n    AuthPAMUserPwdStartFunc, AuthPAMUserPwdRspFunc };\n#endif\n\nstatic AuthCapData *authCaps[] = {\n  &authCapNone, &authCapVncAuth, &authCapVeNCrypt,\n#ifdef XVNC_AuthPAM\n  &authCapUnixLogin,\n#endif\n  NULL\n};\n\ntypedef struct {\n  const char *name;\n  Bool enabled;\n  Bool permitted;\n  int preference;\n  Bool requiredData;\n  RFBSecTypeData *rfbSecType;\n  AuthCapData *authCap;\n  int subType;\n} SecTypeData;\n\n/*\n * Set the \"permitted\" member to TRUE if you want the security type to be\n * available by default.  The value of the \"permitted-security-types\" config\n * file option will take precedence over the defaults below.\n *\n * We permit the rfbAuthNone security type by default for backward\n * compatibility and only enable it when either explicitly told to do so or if\n * it is permitted and no other security types were specified on the command\n * line.\n */\nstatic SecTypeData secTypes[] = {\n#if USETLS\n/*  name         enabled  permitted  preference  requiredData */\n  { \"tlsnone\",   FALSE,   TRUE,      -1,         FALSE,\n/*  secType           authCap            subType */\n    &secTypeVeNCrypt, &authCapVeNCrypt,  rfbVeNCryptTLSNone },\n\n  { \"tlsvnc\",    TRUE,    TRUE,      -1,         TRUE,\n    &secTypeVeNCrypt, &authCapVeNCrypt,  rfbVeNCryptTLSVnc },\n\n  { \"tlsotp\",    TRUE,    TRUE,      -1,         TRUE,\n    &secTypeVeNCrypt, &authCapVeNCrypt,  rfbVeNCryptTLSVnc },\n\n#ifdef XVNC_AuthPAM\n  { \"tlsplain\",  TRUE,    TRUE,      -1,         TRUE,\n    &secTypeVeNCrypt, &authCapVeNCrypt,  rfbVeNCryptTLSPlain },\n#endif\n\n  { \"x509none\",  FALSE,   TRUE,      -1,         FALSE,\n    &secTypeVeNCrypt, &authCapVeNCrypt,  rfbVeNCryptX509None },\n\n  { \"x509vnc\",   TRUE,    TRUE,      -1,         TRUE,\n    &secTypeVeNCrypt, &authCapVeNCrypt,  rfbVeNCryptX509Vnc },\n\n  { \"x509otp\",   TRUE,    TRUE,      -1,         TRUE,\n    &secTypeVeNCrypt, &authCapVeNCrypt,  rfbVeNCryptX509Vnc },\n\n#ifdef XVNC_AuthPAM\n  { \"x509plain\", TRUE,    TRUE,      -1,         TRUE,\n    &secTypeVeNCrypt, &authCapVeNCrypt,  rfbVeNCryptX509Plain },\n#endif\n#endif\n\n  { \"none\",      FALSE,   TRUE,      -1,         FALSE,\n    &secTypeNone,     &authCapNone,      rfbSecTypeNone },\n\n  { \"vnc\",       TRUE,    TRUE,      -1,         TRUE,\n    &secTypeVncAuth,  &authCapVncAuth,   rfbSecTypeVncAuth },\n\n  { \"otp\",       TRUE,    TRUE,      -1,         TRUE,\n    &secTypeVncAuth,  &authCapVncAuth,   rfbSecTypeVncAuth },\n\n#ifdef XVNC_AuthPAM\n  { \"unixlogin\", TRUE,    TRUE,      -1,         TRUE,\n    &secTypeTight,    &authCapUnixLogin, -1 },\n\n  { \"plain\",     TRUE,    TRUE,      -1,         TRUE,\n    &secTypeVeNCrypt, &authCapVeNCrypt,  rfbVeNCryptPlain },\n#endif\n\n  { NULL }\n};\n\n\nBool rfbOptOtpAuth(void)\n{\n  SecTypeData *s;\n\n  for (s = secTypes; s->name != NULL; s++) {\n    if (!strcmp(&s->name[strlen(s->name) - 3], \"otp\") && s->enabled)\n      return TRUE;\n  }\n\n  return FALSE;\n}\n\n\nBool rfbOptPamAuth(void)\n{\n  SecTypeData *s;\n\n  for (s = secTypes; s->name != NULL; s++) {\n    if ((!strcmp(s->name, \"unixlogin\") ||\n         strstr(s->name, \"plain\")) && s->enabled)\n      return TRUE;\n  }\n\n  return FALSE;\n}\n\n\nBool rfbOptRfbAuth(void)\n{\n  SecTypeData *s;\n\n  for (s = secTypes; s->name != NULL; s++) {\n    if (!strcmp(&s->name[strlen(s->name) - 3], \"vnc\") && s->enabled)\n      return TRUE;\n  }\n\n  return FALSE;\n}\n\n\nvoid rfbAuthParseCommandLine(char *securityTypes)\n{\n  char *p1 = securityTypes, *p2 = securityTypes;\n  SecTypeData *s;\n\n  for (s = secTypes; s->name != NULL; s++)\n    s->enabled = FALSE;\n\n  do {\n    *p2 = *p1;\n    if (!isspace(*p2))\n      p2++;\n  } while (*p1++ != 0);\n\n  while (TRUE) {\n    p1 = strtok_r(securityTypes, \",\", &p2);\n    securityTypes = NULL;\n    if (p1 == NULL)\n      break;\n\n    for (s = secTypes; s->name != NULL; s++) {\n      if (!strcasecmp(s->name, p1)) {\n        s->enabled = TRUE;\n        break;\n      }\n    }\n\n    if (s->name == NULL)\n      FatalError(\"ERROR: Unknown security type '%s'\", p1);\n  }\n}\n\n\nstatic void setSecTypes(char *buf, Bool backwardCompatible)\n{\n  char *saveptr = NULL;\n  char *p;\n  SecTypeData *s;\n\n  preferenceLimit = 0;\n  for (s = secTypes; s->name != NULL; s++) {\n    s->permitted = FALSE;\n    s->preference = -1;\n    s->rfbSecType->advertise = FALSE;\n  }\n\n  while (TRUE) {\n    p = strtok_r(buf, \",\", &saveptr);\n    buf = NULL;\n    if (p == NULL)\n      break;\n\n    for (s = secTypes; s->name != NULL; s++) {\n      if (backwardCompatible && s->rfbSecType == &secTypeVeNCrypt)\n        continue;\n      if (!strcasecmp(s->name, p) ||\n          (backwardCompatible && !strcasecmp(s->name, \"unixlogin\") &&\n           !strcasecmp(p, \"pam-userpwd\")))\n        break;\n    }\n\n    if (s->name == NULL)\n      FatalError(\"ERROR: Unknown security type name '%s'\", p);\n\n    s->permitted = TRUE;\n    s->preference = preferenceLimit++;\n  }\n}\n\n\nvoid rfbAuthListAvailableSecurityTypes(void)\n{\n  SecTypeData *s;\n  int chars = 23;\n\n  ErrorF(\"                       Available security types (case-insensitive):\\n\");\n  ErrorF(\"                       \");\n  for (s = secTypes; s->name != NULL; s++) {\n    ErrorF(\"%s\", s->name);  chars += strlen(s->name);\n    if ((s + 1)->name != NULL) {\n      ErrorF(\", \");  chars += 2;\n      if (chars + strlen((s + 1)->name) > 77) {\n        ErrorF(\"\\n                       \");\n        chars = 23;\n      }\n    }\n  }\n  ErrorF(\"\\n\");\n}\n\n\nstatic void ReadConfigFile(void)\n{\n  FILE *fp;\n  char buf[256], buf2[256];\n  int line;\n  int len;\n  int n, i, j;\n  struct stat sb;\n\n  if ((fp = fopen(rfbAuthConfigFile, \"r\")) == NULL)\n    return;\n\n  if (fstat(fileno(fp), &sb) == -1)\n    FatalError(\"rfbAuthInit: ERROR: fstat %s: %s\", rfbAuthConfigFile,\n               strerror(errno));\n\n  if ((sb.st_uid != 0) && (sb.st_uid != getuid()))\n    FatalError(\"ERROR: %s must be owned by you or by root\", rfbAuthConfigFile);\n\n  if (sb.st_mode & (S_IWGRP | S_IWOTH))\n    FatalError(\"ERROR: %s cannot have group or global write permissions\",\n               rfbAuthConfigFile);\n\n  rfbLog(\"Using security configuration file %s\\n\", rfbAuthConfigFile);\n  for (line = 0; fgets(buf, sizeof(buf), fp) != NULL; line++) {\n    len = strlen(buf) - 1;\n    if (buf[len] != '\\n' && strlen(buf) == 256)\n      FatalError(\"ERROR in %s: line %d is too long!\", rfbAuthConfigFile,\n                 line + 1);\n\n    buf[len] = '\\0';\n\n    for (i = 0, j = 0; i < len; i++) {\n      if (buf[i] != ' ' && buf[i] != '\\t')\n        buf2[j++] = buf[i];\n    }\n    len = j;\n    buf2[len] = '\\0';\n    if (len < 1) continue;\n\n    if (!strcmp(buf2, \"no-remote-resize\")) {\n      rfbAuthDisableRemoteResize = TRUE;\n      continue;\n    }\n\n    if (!strcmp(buf2, \"no-reverse-connections\")) {\n      rfbAuthDisableRevCon = TRUE;\n      continue;\n    }\n\n    if (!strcmp(buf2, \"no-remote-connections\")) {\n      interface.s_addr = htonl(INADDR_LOOPBACK);\n      interface6 = in6addr_loopback;\n      continue;\n    }\n\n    if (!strcmp(buf2, \"no-clipboard-send\")) {\n      rfbAuthDisableCBSend = TRUE;\n      continue;\n    }\n\n    if (!strcmp(buf2, \"no-clipboard-recv\")) {\n      rfbAuthDisableCBRecv = TRUE;\n      continue;\n    }\n\n    if (!strcmp(buf2, \"no-httpd\")) {\n      rfbAuthDisableHTTP = TRUE;\n      continue;\n    }\n\n    if (!strcmp(buf2, \"no-x11-tcp-connections\")) {\n      rfbAuthDisableX11TCP = TRUE;\n      continue;\n    }\n\n#ifdef XVNC_AuthPAM\n    if (!strcmp(buf2, \"no-pam-sessions\")) {\n      rfbAuthDisablePAMSession = TRUE;\n      continue;\n    }\n\n    if (!strcmp(buf2, \"enable-user-acl\")) {\n      rfbAuthUserACL = TRUE;\n      continue;\n    }\n\n    n = 17;\n    if (!strncmp(buf2, \"pam-service-name=\", n)) {\n      if (buf2[n] == '\\0')\n        FatalError(\"ERROR in %s: pam-service-name is empty!\",\n                   rfbAuthConfigFile);\n\n      if ((pamServiceName = strdup(&buf2[n])) == NULL)\n        FatalError(\"rfbAuthInit strdup: %s\", strerror(errno));\n\n      continue;\n    }\n#endif\n\n    /* permitted-auth-methods provides backward compatibility with TurboVNC\n       2.0.x and earlier.  It can only be used to enable non-VeNCrypt\n       security types. */\n    n = 23;\n    if (!strncmp(buf2, \"permitted-auth-methods=\", n)) {\n      if (buf2[n] == '\\0')\n        FatalError(\"ERROR in %s: permitted-auth-methods is empty!\",\n                   rfbAuthConfigFile);\n\n      setSecTypes(&buf2[n], TRUE);\n      continue;\n    }\n\n    /* permitted-security-types was introduced in TurboVNC 2.1. */\n    n = 25;\n    if (!strncmp(buf2, \"permitted-security-types=\", n)) {\n      if (buf2[n] == '\\0')\n        FatalError(\"ERROR in %s: permitted-security-types is empty!\",\n                   rfbAuthConfigFile);\n\n      setSecTypes(&buf2[n], FALSE);\n      continue;\n    }\n\n#ifdef USETLS\n    n = 24;\n    if (!strncmp(buf2, \"permitted-cipher-suites=\", n)) {\n      if (buf2[n] == '\\0')\n        FatalError(\"ERROR in %s: permitted-cipher-suites is empty!\",\n                   rfbAuthConfigFile);\n\n      if ((rfbAuthCipherSuites = strdup(&buf2[n])) == NULL)\n        FatalError(\"rfbAuthInit strdup: %s\", strerror(errno));\n\n      continue;\n    }\n#endif\n\n    n = 17;\n    if (!strncmp(buf2, \"max-idle-timeout=\", n)) {\n      int t;\n\n      if (buf2[n] == '\\0')\n        FatalError(\"ERROR in %s: max-idle-timeout is empty!\",\n                   rfbAuthConfigFile);\n\n      if (sscanf(&buf2[n], \"%d\", &t) < 1 || t <= 0)\n        FatalError(\"ERROR in %s: max-idle-timeout value must be > 0!\",\n                   rfbAuthConfigFile);\n\n      rfbMaxIdleTimeout = (CARD32)t;\n      continue;\n    }\n\n    n = 17;\n    if (!strncmp(buf2, \"max-desktop-size=\", n)) {\n      int w = -1, h = -1;\n\n      if (buf2[n] == '\\0')\n        FatalError(\"ERROR in %s: max-desktop-size is empty!\",\n                   rfbAuthConfigFile);\n\n      if (sscanf(&buf2[n], \"%dx%d\", &w, &h) < 2 || w <= 0 || h <= 0)\n        FatalError(\"ERROR in %s: max-desktop-size value is incorrect.\",\n                   rfbAuthConfigFile);\n\n      if (w == 0) w = MAXSHORT;\n      if (h == 0) h = MAXSHORT;\n      rfbMaxWidth = (CARD32)w;\n      rfbMaxHeight = (CARD32)h;\n      continue;\n    }\n\n    if (buf2[0] != '#')\n      rfbLog(\"WARNING: unrecognized security config line '%s'\\n\", buf);\n  }\n\n  fclose(fp);\n}\n\n\nvoid rfbAuthInit(void)\n{\n  SecTypeData *s;\n  int nSelected = 0;\n\n  ReadConfigFile();\n\n  for (s = secTypes; s->name != NULL; s++) {\n    if (s->enabled) {\n      nSelected++;\n      if (!s->permitted) {\n        rfbLog(\"WARNING: security type '%s' is not permitted\\n\", s->name);\n        s->enabled = FALSE;\n        continue;\n      }\n    }\n\n    if (s->enabled) {\n      nSecTypesEnabled++;\n      rfbLog(\"Enabled security type '%s'\\n\", s->name);\n      if (!s->rfbSecType->advertise) {\n        s->rfbSecType->advertise = TRUE;\n        rfbLog(\"Advertising security type '%s' to viewers\\n\",\n               s->rfbSecType->name);\n      }\n    }\n  }\n\n  if (nSelected == 0) {\n    /* No security type was selected.  See if we should enable the rfbAuthNone\n       security type. */\n    for (s = secTypes; s->name != NULL; s++) {\n      if (!s->requiredData) {\n        if (s->permitted) {\n          nSecTypesEnabled++;\n          s->enabled = TRUE;\n          s->rfbSecType->advertise = TRUE;\n          rfbLog(\"Enabled security type '%s'\\n\", s->name);\n          rfbLog(\"Advertising security type '%s' to viewers\\n\",\n                 s->rfbSecType->name);\n        }\n      } else {\n        s->rfbSecType->advertise = FALSE;\n      }\n    }\n  }\n\n#ifndef XVNC_AuthPAM\n  if (rfbOptPamAuth())\n    rfbLog(\"WARNING: PAM support is not compiled in.\\n\");\n#endif\n\n  if (nSecTypesEnabled == 0) {\n    for (s = secTypes; s->name != NULL; s++) {\n      if (s->permitted)\n        rfbLog(\"NOTICE: %s is a permitted security type\\n\", s->name);\n    }\n\n    FatalError(\"ERROR: no security types enabled!\");\n  } else {\n    /* Do not advertise rfbAuthNone if any other security type is enabled */\n    for (s = secTypes; s->name != NULL; s++) {\n      if (s->enabled && strcmp(s->name, \"none\"))\n        secTypeNone.advertise = FALSE;\n    }\n  }\n\n#ifdef XVNC_AuthPAM\n  if (rfbOptPamAuth() && rfbAuthUserACL) {\n    struct passwd pbuf;\n    struct passwd *pw;\n    char buf[256];\n    char *n;\n\n    if (getpwuid_r(getuid(), &pbuf, buf, sizeof(buf), &pw) != 0)\n      FatalError(\"AuthPAMUserPwdRspFunc: limit-user enabled and getpwuid_r failed: %s\",\n                 strerror(errno));\n\n    n = (char *)rfbAlloc(strlen(pbuf.pw_name));\n    strcpy(n, pbuf.pw_name);\n    rfbAuthAddUser(n, FALSE);\n  }\n#endif\n}\n\n\nvoid rfbAuthProcessResponse(rfbClientPtr cl)\n{\n  AuthCapData **p;\n  AuthCapData *c;\n\n  for (p = authCaps; *p != NULL; p++) {\n    c = *p;\n    if (cl->selectedAuthType == c->authType) {\n      c->rspFunc(cl);\n      return;\n    }\n  }\n\n  rfbLog(\"rfbAuthProcessResponse: authType assertion failed\\n\");\n  rfbCloseClient(cl);\n}\n\n\n/*\n * rfbAuthNewClient is called right after negotiating the protocol version.\n * Depending on the protocol version, we send either a code for the\n * authentication scheme to be used (protocol 3.3) or a list of possible\n * \"security types\" (protocol 3.7 and above.)\n */\n\nvoid rfbAuthNewClient(rfbClientPtr cl)\n{\n  RFBSecTypeData **p;\n  RFBSecTypeData *r;\n\n  if (rfbAuthIsBlocked()) {\n    rfbLog(\"Too many authentication failures - client rejected\\n\");\n    rfbClientConnFailed(cl, \"Too many authentication failures\");\n    return;\n  }\n\n  if (cl->protocol_minor_ver >= 7) {\n    rfbSendSecurityTypeList(cl);\n    return;\n  }\n\n  /* Make sure we use only RFB 3.3-compatible security types */\n  for (p = rfbSecTypes; *p != NULL; p++) {\n    r = *p;\n    if (r->advertise && (r->protocolMinorVer < 7))\n      break;\n  }\n\n  if (*p == NULL) {\n    rfbLog(\"VNC authentication disabled - RFB 3.3 client rejected\\n\");\n    rfbClientConnFailed(cl, \"Your viewer cannot handle required security types\");\n    return;\n  }\n\n  cl->selectedAuthType = r->securityType;\n  rfbSendSecurityType(cl, r->securityType);\n}\n\n\n/*\n * Tell the client which security type will be used (protocol 3.3)\n */\n\nstatic void rfbSendSecurityType(rfbClientPtr cl, int securityType)\n{\n  CARD32 value32;\n\n  value32 = Swap32IfLE(securityType);\n  if (WriteExact(cl, (char *)&value32, 4) < 0) {\n    rfbLogPerror(\"rfbSendSecurityType: write\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  switch (securityType) {\n    case rfbSecTypeNone:\n      /* Dispatch client input to rfbProcessClientInitMessage() */\n      cl->state = RFB_INITIALISATION;\n      break;\n    case rfbSecTypeVncAuth:\n      /* Begin the Standard VNC authentication procedure */\n      rfbVncAuthSendChallenge(cl);\n      break;\n    default:\n      rfbLogPerror(\"rfbSendSecurityType: assertion failed\");\n      rfbCloseClient(cl);\n  }\n}\n\n\n/*\n * Advertise our supported security types (protocol 3.7 and above)\n */\n\nstatic void rfbSendSecurityTypeList(rfbClientPtr cl)\n{\n  int i, j, n;\n  SecTypeData *s;\n  RFBSecTypeData *r;\n  Bool tightAdvertised = FALSE;\n\n  /*\n   * When no preference order was set using \"permitted-security-types\", the\n   * default value of preferenceLimit (1) will cause us to execute the\n   * outer loop once.  In this case, the s->preference members will all\n   * be the default value (-1), and we skip the order testing.\n   */\n  n = 0;\n  for (i = 0; i < preferenceLimit; i++) {\n    for (s = secTypes; s->name != NULL; s++) {\n      if (((s->preference != -1) && (i != s->preference)) || !s->enabled)\n        continue;\n\n      r = s->rfbSecType;\n\n      if (n > MAX_SECURITY_TYPES)\n        FatalError(\"rfbSendSecurityTypeList: # enabled security types > MAX_SECURITY_TYPES\");\n\n      /*\n       * Check whether we have already advertised this security type\n       */\n      for (j = 0; j < n; j++) {\n        if (cl->securityTypes[j + 1] == r->securityType)\n          break;\n      }\n\n      if (j < n)\n        continue;\n\n      if (r->advertise && (cl->protocol_minor_ver >= r->protocolMinorVer)) {\n        cl->securityTypes[++n] = r->securityType;\n        if (r->securityType == rfbSecTypeTight)\n          tightAdvertised = TRUE;\n      }\n    }\n  }\n\n  if (n == 0)\n    FatalError(\"rfbSendSecurityTypeList: no security types enabled! This should not have happened!\");\n\n  if (!tightAdvertised) {\n    /*\n     * Make sure to advertise the Tight security type, in order to allow\n     * TightVNC-compatible clients to enable other (non-auth) Tight\n     * extensions.\n     */\n    if (n > MAX_SECURITY_TYPES)\n      FatalError(\"rfbSendSecurityTypeList: # enabled security types > MAX_SECURITY_TYPES\");\n\n    rfbLog(\"rfbSendSecurityTypeList: advertise sectype tight\\n\");\n    cl->securityTypes[++n] = rfbSecTypeTight;\n  }\n\n  cl->securityTypes[0] = (CARD8)n;\n\n  /* Send the list */\n  if (WriteExact(cl, (char *)cl->securityTypes, n + 1) < 0) {\n    rfbLogPerror(\"rfbSendSecurityTypeList: write\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  /* Dispatch client input to rfbProcessClientSecurityType() */\n  cl->state = RFB_SECURITY_TYPE;\n}\n\n\n#define WRITE(data, size)  \\\n  if (WriteExact(cl, (char *)data, size) <= 0) {  \\\n    rfbLogPerror(\"rfbVeNCryptAuthenticate: write\");  \\\n    rfbCloseClient(cl);  \\\n    return;  \\\n  }\n\n#define READ(data, size)  \\\n  if (ReadExact(cl, (char *)data, size) <= 0) {  \\\n    rfbLogPerror(\"rfbVeNCryptAuthenticate: read\");  \\\n    rfbCloseClient(cl);  \\\n    return;  \\\n  }\n\n#if USETLS\n#define TLS_INIT(anon)  \\\n  if ((ctx = rfbssl_init(cl, anon)) == NULL) {  \\\n    reply = 0;  \\\n    WRITE(&reply, 1);  \\\n    rfbClientAuthFailed(cl, rfbssl_geterr());  \\\n    return;  \\\n  }  \\\n  reply = 1;  \\\n  WRITE(&reply, 1);  \\\n  cl->sslctx = ctx;  \\\n  if ((ret = rfbssl_accept(cl)) < 0) {  \\\n    rfbCloseClient(cl);  \\\n    return;  \\\n  } else if (ret == 1) {  \\\n    rfbLog(\"Deferring TLS handshake\\n\");  \\\n    cl->state = RFB_TLS_HANDSHAKE;  \\\n    return;  \\\n  }\n\n\nvoid rfbAuthTLSHandshake(rfbClientPtr cl)\n{\n  int ret;\n\n  if ((ret = rfbssl_accept(cl)) < 0) {\n    rfbCloseClient(cl);\n    return;\n  } else if (ret == 1)\n    return;\n\n  switch (cl->selectedAuthType) {\n    case rfbAuthNone:\n      rfbClientAuthSucceeded(cl, rfbAuthNone);\n      break;\n    case rfbAuthVNC:\n      rfbVncAuthSendChallenge(cl);\n      break;\n#ifdef XVNC_AuthPAM\n    case rfbAuthUnixLogin:\n      AuthPAMUserPwdRspFunc(cl);\n      break;\n#endif\n  }\n}\n#endif\n\n\nvoid rfbVeNCryptAuthenticate(rfbClientPtr cl)\n{\n  struct {\n    CARD8 major, minor;\n  } serverVersion = { 0, 2 }, clientVersion = { 0, 0 };\n  CARD8 reply, count = 0;\n  int i, j;\n  SecTypeData *s;\n  CARD32 subTypes[MAX_VENCRYPT_SUBTYPES], chosenType = 0;\n#if USETLS\n  rfbSslCtx *ctx;\n  int ret;\n#endif\n\n  WRITE(&serverVersion.major, 1);\n  WRITE(&serverVersion.minor, 1);\n  rfbUncorkSock(cl->sock);\n  rfbCorkSock(cl->sock);\n  READ(&clientVersion, 2);\n\n  if (clientVersion.major == 0 && clientVersion.minor < 2) {\n    reply = 0xFF;\n    WRITE(&reply, 1);\n    rfbCloseClient(cl);\n    return;\n  } else {\n    reply = 0;\n    WRITE(&reply, 1);\n  }\n\n  memset(subTypes, 0, sizeof(CARD32) * MAX_VENCRYPT_SUBTYPES);\n  for (i = 0; i < preferenceLimit; i++) {\n    for (s = secTypes; s->name != NULL; s++) {\n      if (((s->preference != -1) && (i != s->preference)) || !s->enabled ||\n          s->subType == -1)\n        continue;\n\n      if (count > MAX_VENCRYPT_SUBTYPES)\n        FatalError(\"rfbVeNCryptAuthenticate: # enabled subtypes > MAX_VENCRYPT_SUBTYPES\");\n\n      /* Check whether we have already advertised this subtype */\n      for (j = 0; j < count; j++) {\n        if (subTypes[j] == s->subType)\n          break;\n      }\n      if (j < count)\n        continue;\n\n      subTypes[count++] = s->subType;\n    }\n  }\n\n  WRITE(&count, 1);\n  if (count > 0) {\n    for (i = 0; i < count; i++) {\n      CARD32 subType = Swap32IfLE(subTypes[i]);\n      WRITE(&subType, sizeof(CARD32));\n    }\n  }\n\n  rfbUncorkSock(cl->sock);\n  rfbCorkSock(cl->sock);\n  READ(&chosenType, sizeof(CARD32));\n  chosenType = Swap32IfLE(chosenType);\n\n  for (i = 0; i < count; i++) {\n    if (chosenType == subTypes[i])\n      break;\n  }\n  rfbLog(\"Client requested VeNCrypt sub-type %d\\n\", chosenType);\n  if (chosenType == 0 || chosenType == rfbSecTypeVeNCrypt || i >= count) {\n    rfbLog(\"Requested VeNCrypt sub-type not supported\\n\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  cl->selectedAuthType = chosenType;\n  switch (chosenType) {\n    case rfbAuthNone:\n      rfbClientAuthSucceeded(cl, rfbAuthNone);\n      break;\n    case rfbAuthVNC:\n      rfbVncAuthSendChallenge(cl);\n      break;\n#ifdef XVNC_AuthPAM\n    case rfbVeNCryptPlain:\n      AuthPAMUserPwdRspFunc(cl);\n      break;\n#endif\n#if USETLS\n    case rfbVeNCryptTLSNone:\n      cl->selectedAuthType = rfbAuthNone;\n      TLS_INIT(TRUE);\n      rfbClientAuthSucceeded(cl, rfbAuthNone);\n      break;\n    case rfbVeNCryptTLSVnc:\n      cl->selectedAuthType = rfbAuthVNC;\n      TLS_INIT(TRUE);\n      rfbVncAuthSendChallenge(cl);\n      break;\n#ifdef XVNC_AuthPAM\n    case rfbVeNCryptTLSPlain:\n      cl->selectedAuthType = rfbAuthUnixLogin;\n      TLS_INIT(TRUE);\n      AuthPAMUserPwdRspFunc(cl);\n      break;\n#endif\n    case rfbVeNCryptX509None:\n      cl->selectedAuthType = rfbAuthNone;\n      TLS_INIT(FALSE);\n      rfbClientAuthSucceeded(cl, rfbAuthNone);\n      break;\n    case rfbVeNCryptX509Vnc:\n      cl->selectedAuthType = rfbAuthVNC;\n      TLS_INIT(FALSE);\n      rfbVncAuthSendChallenge(cl);\n      break;\n#ifdef XVNC_AuthPAM\n    case rfbVeNCryptX509Plain:\n      cl->selectedAuthType = rfbAuthUnixLogin;\n      TLS_INIT(FALSE);\n      AuthPAMUserPwdRspFunc(cl);\n      break;\n#endif\n#endif\n    default:\n      FatalError(\"rfbVeNCryptAuthenticate: chosen type is invalid (this should never occur)\");\n  }\n}\n\n\n/*\n * Read the security type chosen by the client (protocol 3.7 and above)\n */\n\nvoid rfbProcessClientSecurityType(rfbClientPtr cl)\n{\n  int n, count, i;\n  CARD8 chosenType;\n\n  /* Read the security type */\n  n = ReadExact(cl, (char *)&chosenType, 1);\n  if (n <= 0) {\n    if (n == 0)\n      rfbLog(\"rfbProcessClientSecurityType: client gone\\n\");\n    else\n      rfbLogPerror(\"rfbProcessClientSecurityType: read\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  /* Make sure it was present in the list sent by the server */\n  count = (int)cl->securityTypes[0];\n  for (i = 1; i <= count; i++) {\n    if (chosenType == cl->securityTypes[i])\n      break;\n  }\n  if (i > count) {\n    rfbLog(\"rfbProcessClientSecurityType: wrong security type requested\\n\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  cl->selectedAuthType = chosenType;\n  switch (chosenType) {\n    case rfbSecTypeNone:\n      /* No authentication needed */\n      rfbClientAuthSucceeded(cl, rfbAuthNone);\n      break;\n    case rfbSecTypeVncAuth:\n      /* Begin the Standard VNC authentication procedure */\n      rfbVncAuthSendChallenge(cl);\n      break;\n    case rfbSecTypeTight:\n      /* The viewer supports TightVNC extensions */\n      rfbLog(\"Enabling TightVNC protocol extensions\\n\");\n      /* Switch to protocol 3.7t/3.8t */\n      cl->protocol_tightvnc = TRUE;\n      /* Advertise our tunneling capabilities */\n      rfbSendTunnelingCaps(cl);\n      break;\n    case rfbSecTypeVeNCrypt:\n      /* The viewer supports VeNCrypt extensions */\n      rfbLog(\"Enabling VeNCrypt protocol extensions\\n\");\n      rfbVeNCryptAuthenticate(cl);\n      break;\n    default:\n      rfbLog(\"rfbProcessClientSecurityType: unknown authentication scheme\\n\");\n      rfbCloseClient(cl);\n      break;\n  }\n}\n\n\n/*\n * Send the list of our tunneling capabilities (protocol 3.7t/3.8t)\n */\n\nstatic void rfbSendTunnelingCaps(rfbClientPtr cl)\n{\n  rfbTunnelingCapsMsg caps;\n  CARD32 nTypes = 0;            /* We don't support tunneling yet */\n\n  caps.nTunnelTypes = Swap32IfLE(nTypes);\n  if (WriteExact(cl, (char *)&caps, sz_rfbTunnelingCapsMsg) < 0) {\n    rfbLogPerror(\"rfbSendTunnelingCaps: write\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  if (nTypes)\n    /* Dispatch client input to rfbProcessClientTunnelingType() */\n    cl->state = RFB_TUNNELING_TYPE;\n  else\n    rfbSendAuthCaps(cl);\n}\n\n\n/*\n * Read tunneling type requested by the client (protocol 3.7t/3.8t)\n *\n * NOTE: Currently we don't support tunneling, and this function can never be\n * called.\n */\n\nvoid rfbProcessClientTunnelingType(rfbClientPtr cl)\n{\n  /* If we were called, then something's really wrong. */\n  rfbLog(\"rfbProcessClientTunnelingType: not implemented\\n\");\n  rfbCloseClient(cl);\n}\n\n\n/*\n * Send the list of our authentication capabilities to the client\n * (protocol 3.7t/3.8t)\n */\n\nstatic void rfbSendAuthCaps(rfbClientPtr cl)\n{\n  rfbAuthenticationCapsMsg caps;\n  rfbCapabilityInfo caplist[MAX_AUTH_CAPS];\n  int count = 0;\n  int j;\n  SecTypeData *s;\n  AuthCapData *c;\n  rfbCapabilityInfo *pcap;\n  char tempstr[9];\n\n  if (!cl->reverseConnection) {\n    int i;\n\n    /*\n     * When no preference order was set using \"permitted-security-types\",\n     * the default value of preferenceLimit (1) will cause us to execute\n     * the outer loop once.  In this case, the s->preference members will\n     * all be the default value (-1), and we skip the order testing.\n     */\n    for (i = 0; i < preferenceLimit; i++) {\n      for (s = secTypes; s->name != NULL; s++) {\n        if (((s->preference != -1) && (i != s->preference)) || !s->enabled)\n          continue;\n\n        c = s->authCap;\n\n        if (count > MAX_AUTH_CAPS)\n          FatalError(\"rfbSendAuthCaps: # enabled security types > MAX_AUTH_CAPS\");\n\n        /*\n         * Check to see if we have already advertised this auth cap.\n         * VNC password and OTP both use the VNC authentication cap.\n         */\n        for (j = 0; j < count; j++) {\n          if (cl->authCaps[j] == c->authType)\n            break;\n        }\n\n        if (j < count)\n          continue;\n\n        pcap = &caplist[count];\n        pcap->code = Swap32IfLE(c->authType);\n        memcpy(pcap->vendorSignature, c->vendorSignature,\n               sz_rfbCapabilityInfoVendor);\n        memcpy(pcap->nameSignature, c->nameSignature,\n               sz_rfbCapabilityInfoName);\n        cl->authCaps[count] = c->authType;\n        strncpy(tempstr, (char *)pcap->nameSignature, 8);\n        tempstr[8] = 0;\n        rfbLog(\"Advertising Tight auth cap '%s'\\n\", tempstr);\n        count++;\n      }\n    }\n\n    if (count == 0)\n      FatalError(\"rfbSendAuthCaps: authentication required but no security types enabled! This should not have happened!\");\n  }\n\n  cl->nAuthCaps = count;\n  caps.nAuthTypes = Swap32IfLE((CARD32)count);\n  if (WriteExact(cl, (char *)&caps, sz_rfbAuthenticationCapsMsg) < 0) {\n    rfbLogPerror(\"rfbSendAuthCaps: write\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  if (count) {\n    if (WriteExact(cl, (char *)&caplist[0], count *sz_rfbCapabilityInfo) < 0) {\n      rfbLogPerror(\"rfbSendAuthCaps: write\");\n      rfbCloseClient(cl);\n      return;\n    }\n    /* Dispatch client input to rfbProcessClientAuthType() */\n    cl->state = RFB_AUTH_TYPE;\n  } else {\n    /* No authentication needed */\n    rfbClientAuthSucceeded(cl, rfbAuthNone);\n    cl->state = RFB_INITIALISATION;\n  }\n}\n\n\n/*\n * Read client's preferred authentication type (protocol 3.7t/3.8t)\n */\n\nvoid rfbProcessClientAuthType(rfbClientPtr cl)\n{\n  CARD32 auth_type;\n  int n, i;\n  AuthCapData **p;\n  AuthCapData *c;\n\n  /* Read authentication type selected by the client */\n  n = ReadExact(cl, (char *)&auth_type, sizeof(auth_type));\n  if (n <= 0) {\n    if (n == 0)\n      rfbLog(\"rfbProcessClientAuthType: client gone\\n\");\n    else\n      rfbLogPerror(\"rfbProcessClientAuthType: read\");\n    rfbCloseClient(cl);\n    return;\n  }\n  auth_type = Swap32IfLE(auth_type);\n\n  /* Make sure it was present in the list sent by the server */\n  for (i = 0; i < cl->nAuthCaps; i++) {\n    if (auth_type == cl->authCaps[i])\n      break;\n  }\n  if (i >= cl->nAuthCaps) {\n    rfbLog(\"rfbProcessClientAuthType: wrong authentication type requested\\n\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  for (p = authCaps; *p != NULL; p++) {\n    c = *p;\n    if (auth_type == c->authType) {\n      cl->selectedAuthType = auth_type;\n      c->startFunc(cl);\n      return;\n    }\n  }\n\n  rfbLog(\"rfbProcessClientAuthType: unknown authentication scheme\\n\");\n  rfbCloseClient(cl);\n}\n\n\n/*\n * Send the authentication challenge\n */\n\nstatic void rfbVncAuthSendChallenge(rfbClientPtr cl)\n{\n  vncRandomBytes(cl->authChallenge);\n  if (WriteExact(cl, (char *)cl->authChallenge, CHALLENGESIZE) < 0) {\n    rfbLogPerror(\"rfbVncAuthSendChallenge: write\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  /* Dispatch client input to rfbVncAuthProcessResponse() */\n  cl->state = RFB_AUTHENTICATION;\n}\n\n\nstatic Bool CheckResponse(rfbClientPtr cl, int numPasswords,\n                          char *passwdFullControl, char *passwdViewOnly,\n                          CARD8 *response)\n{\n  Bool ok = FALSE;\n  CARD8 encryptedChallenge1[CHALLENGESIZE];\n  CARD8 encryptedChallenge2[CHALLENGESIZE];\n\n  memcpy(encryptedChallenge1, cl->authChallenge, CHALLENGESIZE);\n  vncEncryptBytes(encryptedChallenge1, passwdFullControl);\n  memcpy(encryptedChallenge2, cl->authChallenge, CHALLENGESIZE);\n  vncEncryptBytes(encryptedChallenge2,\n                  (numPasswords == 2) ? passwdViewOnly : passwdFullControl);\n\n  /* Delete the passwords from memory */\n  memset(passwdFullControl, 0, MAXPWLEN + 1);\n  memset(passwdViewOnly, 0, MAXPWLEN + 1);\n\n  if (memcmp(encryptedChallenge1, response, CHALLENGESIZE) == 0) {\n    rfbLog(\"Full-control authentication enabled for %s\\n\", cl->host);\n    ok = TRUE;\n    cl->viewOnly = FALSE;\n\n  } else if (memcmp(encryptedChallenge2, response, CHALLENGESIZE) == 0) {\n    rfbLog(\"View-only authentication enabled for %s\\n\", cl->host);\n    ok = TRUE;\n    cl->viewOnly = TRUE;\n  }\n\n  return ok;\n}\n\n\n/*\n * rfbVncAuthProcessResponse is called when the client sends its\n * authentication response.\n */\n\nvoid rfbVncAuthProcessResponse(rfbClientPtr cl)\n{\n  char passwdFullControl[MAXPWLEN + 1] = \"\\0\";\n  char passwdViewOnly[MAXPWLEN + 1] = \"\\0\";\n  int numPasswords;\n  Bool ok;\n  int n;\n  CARD8 response[CHALLENGESIZE];\n\n  n = ReadExact(cl, (char *)response, CHALLENGESIZE);\n  if (n <= 0) {\n    if (n != 0)\n      rfbLogPerror(\"rfbVncAuthProcessResponse: read\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  ok = FALSE;\n  if (rfbOptOtpAuth()) {\n    if (rfbAuthOTPValue == NULL) {\n      if (nSecTypesEnabled == 1) {\n        rfbClientAuthFailed(cl, \"The one-time password has not been set on the server\");\n        return;\n      }\n\n    } else {\n      memcpy(passwdFullControl, rfbAuthOTPValue, MAXPWLEN);\n      passwdFullControl[MAXPWLEN] = '\\0';\n      numPasswords = rfbAuthOTPValueLen / MAXPWLEN;\n      if (numPasswords > 1) {\n        memcpy(passwdViewOnly, rfbAuthOTPValue + MAXPWLEN, MAXPWLEN);\n        passwdViewOnly[MAXPWLEN] = '\\0';\n      }\n\n      ok = CheckResponse(cl, numPasswords, passwdFullControl, passwdViewOnly,\n                         response);\n      if (ok) {\n        memset(rfbAuthOTPValue, 0, rfbAuthOTPValueLen);\n        free(rfbAuthOTPValue);\n        rfbAuthOTPValue = NULL;\n      }\n    }\n  }\n\n  if ((ok == FALSE) && rfbOptRfbAuth()) {\n    if (!rfbAuthPasswdFile) {\n      rfbClientAuthFailed(cl, \"No VNC password file specified on the server (did you forget -rfbauth?)\");\n      return;\n    }\n\n    numPasswords = vncDecryptPasswdFromFile2(rfbAuthPasswdFile,\n                                             passwdFullControl,\n                                             passwdViewOnly);\n    if (numPasswords == 0) {\n      rfbLog(\"rfbVncAuthProcessResponse: could not get password from %s\\n\",\n             rfbAuthPasswdFile);\n\n      if (nSecTypesEnabled == 1) {\n        rfbClientAuthFailed(cl, \"The server could not read the VNC password file\");\n        return;\n      }\n    }\n\n    ok = CheckResponse(cl, numPasswords, passwdFullControl, passwdViewOnly,\n                       response);\n  }\n\n  if (ok) {\n    rfbAuthUnblock();\n    rfbClientAuthSucceeded(cl, rfbAuthVNC);\n  } else {\n    rfbLog(\"rfbVncAuthProcessResponse: authentication failed from %s\\n\",\n           cl->host);\n    if (rfbAuthConsiderBlocking())\n      rfbClientAuthFailed(cl, \"Authentication failed.  Too many tries\");\n    else\n      rfbClientAuthFailed(cl, \"Authentication failed\");\n  }\n}\n\n\n/*\n * rfbClientConnFailed is called when a client connection has failed before\n * the authentication stage.\n */\n\nvoid rfbClientConnFailed(rfbClientPtr cl, char *reason)\n{\n  int headerLen, reasonLen;\n  char buf[8];\n  CARD32 *buf32 = (CARD32 *)buf;\n\n  headerLen = (cl->protocol_minor_ver >= 7) ? 1 : 4;\n  reasonLen = strlen(reason);\n  buf32[0] = 0;\n  buf32[1] = Swap32IfLE(reasonLen);\n\n  if (WriteExact(cl, buf, headerLen) < 0 || WriteExact(cl, buf + 4, 4) < 0 ||\n      WriteExact(cl, reason, reasonLen) < 0)\n    rfbLogPerror(\"rfbClientConnFailed: write\");\n\n  rfbCloseClient(cl);\n}\n\n\n/*\n * rfbClientAuthFailed is called on authentication failure.  Sending a reason\n * string is defined in RFB 3.8 and above.\n */\n\nvoid rfbClientAuthFailed(rfbClientPtr cl, char *reason)\n{\n  int reasonLen;\n  char buf[8];\n  CARD32 *buf32 = (CARD32 *)buf;\n\n  if (cl->protocol_minor_ver < 8)\n    reason = NULL;              /* invalidate the pointer */\n\n  reasonLen = (reason == NULL) ? 0 : strlen(reason);\n  buf32[0] = Swap32IfLE(rfbAuthFailed);\n  buf32[1] = Swap32IfLE(reasonLen);\n\n  if (reasonLen == 0) {\n    if (WriteExact(cl, buf, 4) < 0)\n      rfbLogPerror(\"rfbClientAuthFailed: write\");\n  } else {\n    if (WriteExact(cl, buf, 8) < 0 || WriteExact(cl, reason, reasonLen) < 0)\n      rfbLogPerror(\"rfbClientAuthFailed: write\");\n  }\n\n  rfbCloseClient(cl);\n}\n\n\n/*\n * rfbClientAuthSucceeded is called on successful authentication.  It just\n * sends rfbAuthOK and dispatches client input to\n * rfbProcessClientInitMessage().  However, the rfbAuthOK message is not sent\n * if authentication was not required and the protocol version is 3.7 or lower.\n */\n\nvoid rfbClientAuthSucceeded(rfbClientPtr cl, CARD32 authType)\n{\n  CARD32 authResult;\n\n  if (cl->protocol_minor_ver >= 8 || authType == rfbAuthVNC) {\n    authResult = Swap32IfLE(rfbAuthOK);\n    if (WriteExact(cl, (char *)&authResult, 4) < 0) {\n      rfbLogPerror(\"rfbClientAuthSucceeded: write\");\n      rfbCloseClient(cl);\n      return;\n    }\n  }\n\n  /* Dispatch client input to rfbProcessClientInitMessage() */\n  cl->state = RFB_INITIALISATION;\n}\n\n\n/*********************************************************************\n * Functions to prevent too many successive authentication failures.\n *\n * FIXME: This should be performed separately for each client.\n */\n\n/* Maximum authentication failures before blocking connections */\n#define MAX_AUTH_TRIES 5\n\n/* Delay in ms.  This doubles for each failure over MAX_AUTH_TRIES. */\n#define AUTH_TOO_MANY_BASE_DELAY 10 * 1000\n\nstatic int rfbAuthTries = 0;\nstatic Bool rfbAuthTooManyTries = FALSE;\nstatic OsTimerPtr timer = NULL;\n\n\n/*\n * This function should not be called directly.  It is called by setting a\n * timer in rfbAuthConsiderBlocking().\n */\n\nstatic CARD32 rfbAuthReenable(OsTimerPtr timer, CARD32 now, pointer arg)\n{\n  rfbAuthTooManyTries = FALSE;\n  return 0;\n}\n\n\n/*\n * This function should be called after each authentication failure.  The\n * return value will be true if there were too many failures.\n */\n\nBool rfbAuthConsiderBlocking(void)\n{\n  int i;\n\n  rfbAuthTries++;\n\n  if (rfbAuthTries >= MAX_AUTH_TRIES) {\n    CARD32 delay = AUTH_TOO_MANY_BASE_DELAY;\n\n    for (i = MAX_AUTH_TRIES; i < rfbAuthTries; i++)\n      delay *= 2;\n    timer = TimerSet(timer, 0, delay, rfbAuthReenable, NULL);\n    rfbAuthTooManyTries = TRUE;\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\n\n/*\n * This function should be called after a successful authentication.  It\n * resets the counter of authentication failures.  Note that it's not necessary\n * to clear the rfbAuthTooManyTries flag, as it will be reset by the timer\n * function.\n */\n\nvoid rfbAuthUnblock(void)\n{\n  rfbAuthTries = 0;\n}\n\n\n/*\n * This function should be called before authentication.  The return value will\n * be true if there were too many authentication failures, and the server\n * should not allow another try.\n */\n\nBool rfbAuthIsBlocked(void)\n{\n  return rfbAuthTooManyTries;\n}\n", "/*\n * rfbserver.c - deal with server-side of the RFB protocol.\n */\n\n/*\n *  Copyright (C) 2009-2019 D. R. Commander.  All Rights Reserved.\n *  Copyright (C) 2010 University Corporation for Atmospheric Research.\n *                     All Rights Reserved.\n *  Copyright (C) 2005-2008 Sun Microsystems, Inc.  All Rights Reserved.\n *  Copyright (C) 2004 Landmark Graphics Corporation.  All Rights Reserved.\n *  Copyright (C) 2000-2006 Constantin Kaplinsky.  All Rights Reserved.\n *  Copyright (C) 2000 Tridia Corporation.  All Rights Reserved.\n *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n *  USA.\n */\n\n#ifdef HAVE_DIX_CONFIG_H\n#include <dix-config.h>\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <arpa/inet.h>\n#include \"windowstr.h\"\n#include \"rfb.h\"\n#include \"sprite.h\"\n\n/* #define GII_DEBUG */\n\nchar updateBuf[UPDATE_BUF_SIZE];\nint ublen;\n\nrfbClientPtr rfbClientHead = NULL;\nrfbClientPtr pointerClient = NULL;  /* Mutex for pointer events */\n\nBool rfbAlwaysShared = FALSE;\nBool rfbNeverShared = FALSE;\nBool rfbDontDisconnect = TRUE;\nBool rfbViewOnly = FALSE;  /* run server in view only mode - Ehud Karni SW */\nBool rfbSyncCutBuffer = TRUE;\nBool rfbCongestionControl = TRUE;\ndouble rfbAutoLosslessRefresh = 0.0;\nint rfbALRQualityLevel = -1;\nint rfbALRSubsampLevel = TVNC_1X;\nint rfbCombineRect = 100;\nint rfbICEBlockSize = 256;\nBool rfbInterframeDebug = FALSE;\nint rfbMaxWidth = MAXSHORT, rfbMaxHeight = MAXSHORT;\nint rfbMaxClipboard = MAX_CUTTEXT_LEN;\nBool rfbVirtualTablet = FALSE;\nBool rfbMT = TRUE;\nint rfbNumThreads = 0;\n\nstatic rfbClientPtr rfbNewClient(int sock);\nstatic void rfbProcessClientProtocolVersion(rfbClientPtr cl);\nstatic void rfbProcessClientInitMessage(rfbClientPtr cl);\nstatic void rfbSendInteractionCaps(rfbClientPtr cl);\nstatic void rfbProcessClientNormalMessage(rfbClientPtr cl);\nstatic Bool rfbSendCopyRegion(rfbClientPtr cl, RegionPtr reg, int dx, int dy);\nstatic Bool rfbSendLastRectMarker(rfbClientPtr cl);\nBool rfbSendDesktopSize(rfbClientPtr cl);\nBool rfbSendExtDesktopSize(rfbClientPtr cl);\n\n\n/*\n * Session capture\n */\n\nchar *captureFile = NULL;\n\nstatic void WriteCapture(int captureFD, char *buf, int len)\n{\n  if (write(captureFD, buf, len) < len)\n    rfbLogPerror(\"WriteCapture: Could not write to capture file\");\n}\n\n\n/*\n * Idle timeout\n */\n\nCARD32 rfbMaxIdleTimeout = 0;\nCARD32 rfbIdleTimeout = 0;\nstatic double idleTimeout = -1.0;\n\nvoid IdleTimerSet(void)\n{\n  idleTimeout = gettime() + (double)rfbIdleTimeout;\n}\n\nstatic void IdleTimerCancel(void)\n{\n  idleTimeout = -1.0;\n}\n\nvoid IdleTimerCheck(void)\n{\n  if (idleTimeout >= 0.0 && gettime() >= idleTimeout)\n    FatalError(\"TurboVNC session has been idle for %u seconds.  Exiting.\",\n               (unsigned int)rfbIdleTimeout);\n}\n\n\n/*\n * Profiling stuff\n */\n\nstatic BOOL rfbProfile = FALSE;\nstatic double tUpdate = 0., tStart = -1., tElapsed, mpixels = 0.,\n  idmpixels = 0.;\nstatic unsigned long iter = 0;\nunsigned long long sendBytes = 0;\n\ndouble gettime(void)\n{\n  struct timeval __tv;\n\n  gettimeofday(&__tv, (struct timezone *)NULL);\n  return (double)__tv.tv_sec + (double)__tv.tv_usec * 0.000001;\n}\n\n\n/*\n * Auto Lossless Refresh\n */\n\nstatic Bool putImageOnly = TRUE, alrCopyRect = TRUE;\n\nstatic CARD32 alrCallback(OsTimerPtr timer, CARD32 time, pointer arg)\n{\n  RegionRec copyRegionSave, modifiedRegionSave, requestedRegionSave,\n    ifRegionSave;\n  rfbClientPtr cl = (rfbClientPtr)arg;\n  int tightCompressLevelSave, tightQualityLevelSave, copyDXSave, copyDYSave,\n    tightSubsampLevelSave;\n  RegionRec tmpRegion;\n\n  REGION_INIT(pScreen, &tmpRegion, NullBox, 0);\n  if (putImageOnly && !cl->firstUpdate)\n    REGION_INTERSECT(pScreen, &tmpRegion, &cl->alrRegion, &cl->lossyRegion);\n  else\n    REGION_COPY(pScreen, &tmpRegion, &cl->lossyRegion);\n  if (cl->firstUpdate) cl->firstUpdate = FALSE;\n\n  if (REGION_NOTEMPTY(pScreen, &tmpRegion)) {\n\n    tightCompressLevelSave = cl->tightCompressLevel;\n    tightQualityLevelSave = cl->tightQualityLevel;\n    tightSubsampLevelSave = cl->tightSubsampLevel;\n    copyDXSave = cl->copyDX;\n    copyDYSave = cl->copyDY;\n    REGION_INIT(pScreen, &copyRegionSave, NullBox, 0);\n    REGION_COPY(pScreen, &copyRegionSave, &cl->copyRegion);\n    REGION_INIT(pScreen, &modifiedRegionSave, NullBox, 0);\n    REGION_COPY(pScreen, &modifiedRegionSave, &cl->modifiedRegion);\n    REGION_INIT(pScreen, &requestedRegionSave, NullBox, 0);\n    REGION_COPY(pScreen, &requestedRegionSave, &cl->requestedRegion);\n    REGION_INIT(pScreen, &ifRegionSave, NullBox, 0);\n    REGION_COPY(pScreen, &ifRegionSave, &cl->ifRegion);\n\n    cl->tightCompressLevel = 1;\n    cl->tightQualityLevel = rfbALRQualityLevel;\n    cl->tightSubsampLevel = rfbALRSubsampLevel;\n    cl->copyDX = cl->copyDY = 0;\n    REGION_EMPTY(pScreen, &cl->copyRegion);\n    REGION_EMPTY(pScreen, &cl->modifiedRegion);\n    REGION_UNION(pScreen, &cl->modifiedRegion, &cl->modifiedRegion,\n                 &tmpRegion);\n    REGION_EMPTY(pScreen, &cl->requestedRegion);\n    REGION_UNION(pScreen, &cl->requestedRegion, &cl->requestedRegion,\n                 &tmpRegion);\n    if (cl->compareFB) {\n      REGION_EMPTY(pScreen, &cl->ifRegion);\n      REGION_UNION(pScreen, &cl->ifRegion, &cl->ifRegion, &tmpRegion);\n    }\n\n    if (!rfbSendFramebufferUpdate(cl)) return 0;\n\n    REGION_EMPTY(pScreen, &cl->lossyRegion);\n    REGION_EMPTY(pScreen, &cl->alrRegion);\n    cl->tightCompressLevel = tightCompressLevelSave;\n    cl->tightQualityLevel = tightQualityLevelSave;\n    cl->tightSubsampLevel = tightSubsampLevelSave;\n    cl->copyDX = copyDXSave;\n    cl->copyDY = copyDYSave;\n    REGION_COPY(pScreen, &cl->copyRegion, &copyRegionSave);\n    REGION_COPY(pScreen, &cl->modifiedRegion, &modifiedRegionSave);\n    REGION_COPY(pScreen, &cl->requestedRegion, &requestedRegionSave);\n    REGION_UNINIT(pScreen, &copyRegionSave);\n    REGION_UNINIT(pScreen, &modifiedRegionSave);\n    REGION_UNINIT(pScreen, &requestedRegionSave);\n    if (cl->compareFB) {\n      REGION_COPY(pScreen, &cl->ifRegion, &ifRegionSave);\n      REGION_UNINIT(pScreen, &ifRegionSave);\n    }\n  }\n\n  REGION_UNINIT(pScreen, &tmpRegion);\n  return 0;\n}\n\n\nstatic CARD32 updateCallback(OsTimerPtr timer, CARD32 time, pointer arg)\n{\n  rfbClientPtr cl = (rfbClientPtr)arg;\n\n  rfbSendFramebufferUpdate(cl);\n  return 0;\n}\n\n\n/*\n * Interframe comparison\n */\n\nint rfbInterframe = -1;  /* -1 = auto (determined by compression level) */\n\nBool InterframeOn(rfbClientPtr cl)\n{\n  if (!cl->compareFB) {\n    if (!(cl->compareFB =\n          (char *)malloc(rfbFB.paddedWidthInBytes * rfbFB.height))) {\n      rfbLogPerror(\"InterframeOn: couldn't allocate comparison buffer\");\n      return FALSE;\n    }\n    memset(cl->compareFB, 0, rfbFB.paddedWidthInBytes * rfbFB.height);\n    REGION_INIT(pScreen, &cl->ifRegion, NullBox, 0);\n    cl->firstCompare = TRUE;\n    rfbLog(\"Interframe comparison enabled\\n\");\n  }\n  cl->fb = cl->compareFB;\n  return TRUE;\n}\n\nvoid InterframeOff(rfbClientPtr cl)\n{\n  if (cl->compareFB) {\n    free(cl->compareFB);\n    REGION_UNINIT(pScreen, &cl->ifRegion);\n    rfbLog(\"Interframe comparison disabled\\n\");\n  }\n  cl->compareFB = NULL;\n  cl->fb = rfbFB.pfbMemory;\n}\n\n\n/*\n * Map of quality levels to provide compatibility with TightVNC/TigerVNC\n * clients\n */\n\nstatic int JPEG_QUAL[10] = {\n  15, 29, 41, 42, 62, 77, 79, 86, 92, 100\n};\n\nstatic int JPEG_SUBSAMP[10] = {\n  1, 1, 1, 2, 2, 2, 0, 0, 0, 0\n};\n\n\n/*\n * rfbNewClientConnection is called from sockets.c when a new connection\n * comes in.\n */\n\nvoid rfbNewClientConnection(int sock)\n{\n  rfbNewClient(sock);\n}\n\n\n/*\n * rfbReverseConnection is called to make an outward connection to a\n * \"listening\" RFB client.\n */\n\nrfbClientPtr rfbReverseConnection(char *host, int port, int id)\n{\n  int sock;\n  rfbClientPtr cl;\n\n  if (rfbAuthDisableRevCon) {\n    rfbLog(\"Reverse connections disabled\\n\");\n    return (rfbClientPtr)NULL;\n  }\n\n  if ((sock = rfbConnect(host, port)) < 0)\n    return (rfbClientPtr)NULL;\n\n  if (id > 0) {\n    rfbClientRec cl;\n    char temps[250];\n    memset(temps, 0, 250);\n    snprintf(temps, 250, \"ID:%d\", id);\n    rfbLog(\"UltraVNC Repeater Mode II ID is %d\\n\", id);\n    cl.sock = sock;\n    if (WriteExact(&cl, temps, 250) < 0) {\n      rfbLogPerror(\"rfbReverseConnection: write\");\n      rfbCloseSock(sock);\n      return NULL;\n    }\n  }\n\n  cl = rfbNewClient(sock);\n\n  if (cl)\n    cl->reverseConnection = TRUE;\n\n  return cl;\n}\n\n\n/*\n * rfbNewClient is called when a new connection has been made by whatever\n * means.\n */\n\nstatic rfbClientPtr rfbNewClient(int sock)\n{\n  rfbProtocolVersionMsg pv;\n  rfbClientPtr cl;\n  BoxRec box;\n  rfbSockAddr addr;\n  socklen_t addrlen = sizeof(struct sockaddr_storage);\n  char addrStr[INET6_ADDRSTRLEN];\n  char *env = NULL;\n  int np = sysconf(_SC_NPROCESSORS_CONF);\n\n  if (rfbClientHead == NULL)\n    /* no other clients - make sure we don't think any keys are pressed */\n    KbdReleaseAllKeys();\n\n  cl = (rfbClientPtr)rfbAlloc0(sizeof(rfbClientRec));\n\n  if (rfbClientHead == NULL && captureFile) {\n    cl->captureFD = open(captureFile, O_CREAT | O_EXCL | O_WRONLY,\n                         S_IRUSR | S_IWUSR);\n    if (cl->captureFD < 0)\n      rfbLogPerror(\"Could not open capture file\");\n    else\n      rfbLog(\"Opened capture file %s\\n\", captureFile);\n  } else\n    cl->captureFD = -1;\n\n  cl->sock = sock;\n  getpeername(sock, &addr.u.sa, &addrlen);\n  cl->host = strdup(sockaddr_string(&addr, addrStr, INET6_ADDRSTRLEN));\n\n  /* Dispatch client input to rfbProcessClientProtocolVersion(). */\n  cl->state = RFB_PROTOCOL_VERSION;\n\n  cl->preferredEncoding = rfbEncodingTight;\n  cl->correMaxWidth = 48;\n  cl->correMaxHeight = 48;\n\n  REGION_INIT(pScreen, &cl->copyRegion, NullBox, 0);\n\n  box.x1 = box.y1 = 0;\n  box.x2 = rfbFB.width;\n  box.y2 = rfbFB.height;\n  REGION_INIT(pScreen, &cl->modifiedRegion, &box, 0);\n\n  REGION_INIT(pScreen, &cl->requestedRegion, NullBox, 0);\n\n  cl->deferredUpdateStart = gettime();\n\n  cl->format = rfbServerFormat;\n  cl->translateFn = rfbTranslateNone;\n\n  cl->tightCompressLevel = TIGHT_DEFAULT_COMPRESSION;\n  cl->tightSubsampLevel = TIGHT_DEFAULT_SUBSAMP;\n  cl->tightQualityLevel = -1;\n  cl->imageQualityLevel = -1;\n\n  cl->next = rfbClientHead;\n  cl->prev = NULL;\n  if (rfbClientHead)\n    rfbClientHead->prev = cl;\n  rfbClientHead = cl;\n\n  rfbResetStats(cl);\n\n  cl->zlibCompressLevel = 5;\n\n  sprintf(pv, rfbProtocolVersionFormat, 3, 8);\n\n  if (WriteExact(cl, pv, sz_rfbProtocolVersionMsg) < 0) {\n    rfbLogPerror(\"rfbNewClient: write\");\n    rfbCloseClient(cl);\n    return NULL;\n  }\n\n  if ((env = getenv(\"TVNC_PROFILE\")) != NULL && !strcmp(env, \"1\"))\n    rfbProfile = TRUE;\n\n  if ((env = getenv(\"TVNC_ICEDEBUG\")) != NULL && !strcmp(env, \"1\"))\n    rfbInterframeDebug = TRUE;\n\n  if ((env = getenv(\"TVNC_ICEBLOCKSIZE\")) != NULL) {\n    int iceBlockSize = atoi(env);\n    if (iceBlockSize >= 0) rfbICEBlockSize = iceBlockSize;\n  }\n\n  if ((env = getenv(\"TVNC_COMBINERECT\")) != NULL) {\n    int combine = atoi(env);\n    if (combine > 0 && combine <= 65000) rfbCombineRect = combine;\n  }\n\n  cl->firstUpdate = TRUE;\n  /* The TigerVNC Viewer won't enable remote desktop resize until it receives\n     a desktop resize message from the server, so we give it one with the\n     first FBU. */\n  cl->reason = rfbEDSReasonServer;\n  cl->result = rfbEDSResultSuccess;\n\n  if (rfbAutoLosslessRefresh > 0.0) {\n    REGION_INIT(pScreen, &cl->lossyRegion, NullBox, 0);\n    if ((env = getenv(\"TVNC_ALRALL\")) != NULL && !strcmp(env, \"1\"))\n      putImageOnly = FALSE;\n    if ((env = getenv(\"TVNC_ALRCOPYRECT\")) != NULL && !strcmp(env, \"0\"))\n      alrCopyRect = FALSE;\n    REGION_INIT(pScreen, &cl->alrRegion, NullBox, 0);\n    REGION_INIT(pScreen, &cl->alrEligibleRegion, NullBox, 0);\n  }\n\n  if ((env = getenv(\"TVNC_MT\")) != NULL && !strcmp(env, \"0\"))\n    rfbMT = FALSE;\n\n  if ((env = getenv(\"TVNC_NTHREADS\")) != NULL && strlen(env) >= 1) {\n    int temp = atoi(env);\n    if (temp >= 1 && temp <= MAX_ENCODING_THREADS)\n      rfbNumThreads = temp;\n    else\n      rfbLog(\"WARNING: Invalid value of TVNC_NTHREADS (%s) ignored\\n\", env);\n  }\n\n  if (np == -1 && rfbMT) {\n    rfbLog(\"WARNING: Could not determine CPU count.  Multithreaded encoding disabled.\\n\");\n    rfbMT = FALSE;\n  }\n  if (!rfbMT) rfbNumThreads = 1;\n  else if (rfbNumThreads < 1) rfbNumThreads = min(np, 4);\n  if (rfbNumThreads > np) {\n    rfbLog(\"NOTICE: Encoding thread count has been clamped to CPU count\\n\");\n    rfbNumThreads = np;\n  }\n\n  if (rfbIdleTimeout > 0)\n    IdleTimerCancel();\n\n  cl->baseRTT = cl->minRTT = (unsigned)-1;\n  gettimeofday(&cl->lastWrite, NULL);\n  REGION_INIT(pScreen, &cl->cuRegion, NullBox, 0);\n\n  if (rfbInterframe == 1) {\n    if (!InterframeOn(cl)) {\n      rfbCloseClient(cl);\n      return NULL;\n    }\n  } else\n    InterframeOff(cl);\n\n  return cl;\n}\n\n\n/*\n * rfbClientConnectionGone is called from sockets.c just after a connection\n * has gone away.\n */\n\nvoid rfbClientConnectionGone(rfbClientPtr cl)\n{\n  int i;\n\n  if (cl->prev)\n    cl->prev->next = cl->next;\n  else\n    rfbClientHead = cl->next;\n  if (cl->next)\n    cl->next->prev = cl->prev;\n\n  TimerFree(cl->alrTimer);\n  TimerFree(cl->deferredUpdateTimer);\n  TimerFree(cl->updateTimer);\n  TimerFree(cl->congestionTimer);\n\n#ifdef XVNC_AuthPAM\n  rfbPAMEnd(cl);\n#endif\n  if (cl->login != NULL) {\n    rfbLog(\"Client %s (%s) gone\\n\", cl->login, cl->host);\n    free(cl->login);\n  } else {\n    rfbLog(\"Client %s gone\\n\", cl->host);\n  }\n  free(cl->host);\n\n  ShutdownTightThreads();\n\n  if (rfbAutoLosslessRefresh > 0.0) {\n    REGION_UNINIT(pScreen, &cl->lossyRegion);\n    REGION_UNINIT(pScreen, &cl->alrRegion);\n    REGION_UNINIT(pScreen, &cl->alrEligibleRegion);\n  }\n\n  /* Release the compression state structures if any. */\n  if (cl->compStreamInited == TRUE)\n    deflateEnd(&(cl->compStream));\n\n  for (i = 0; i < 4; i++) {\n    if (cl->zsActive[i])\n      deflateEnd(&cl->zsStruct[i]);\n  }\n\n  if (pointerClient == cl)\n    pointerClient = NULL;\n\n  REGION_UNINIT(pScreen, &cl->copyRegion);\n  REGION_UNINIT(pScreen, &cl->modifiedRegion);\n\n  rfbPrintStats(cl);\n\n  if (cl->translateLookupTable) free(cl->translateLookupTable);\n\n  rfbFreeZrleData(cl);\n\n  if (cl->cutText)\n    free(cl->cutText);\n\n  InterframeOff(cl);\n\n  i = cl->numDevices;\n  while (i-- > 0)\n    RemoveExtInputDevice(cl, 0);\n\n  if (cl->captureFD >= 0)\n    close(cl->captureFD);\n\n  free(cl);\n\n  if (rfbClientHead == NULL && rfbIdleTimeout > 0)\n    IdleTimerSet();\n}\n\n\n/*\n * rfbProcessClientMessage is called when there is data to read from a client.\n */\n\nvoid rfbProcessClientMessage(rfbClientPtr cl)\n{\n  rfbCorkSock(cl->sock);\n\n  if (cl->pendingSyncFence) {\n    cl->syncFence = TRUE;\n    cl->pendingSyncFence = FALSE;\n  }\n\n  switch (cl->state) {\n    case RFB_PROTOCOL_VERSION:\n      rfbProcessClientProtocolVersion(cl);\n      break;\n    case RFB_SECURITY_TYPE:     /* protocol versions 3.7 and above */\n      rfbProcessClientSecurityType(cl);\n      break;\n    case RFB_TUNNELING_TYPE:    /* protocol versions 3.7t, 3.8t */\n      rfbProcessClientTunnelingType(cl);\n      break;\n    case RFB_AUTH_TYPE:         /* protocol versions 3.7t, 3.8t */\n      rfbProcessClientAuthType(cl);\n      break;\n#if USETLS\n    case RFB_TLS_HANDSHAKE:\n      rfbAuthTLSHandshake(cl);\n      break;\n#endif\n    case RFB_AUTHENTICATION:\n      rfbAuthProcessResponse(cl);\n      break;\n    case RFB_INITIALISATION:\n      rfbInitFlowControl(cl);\n      rfbProcessClientInitMessage(cl);\n      break;\n    default:\n      rfbProcessClientNormalMessage(cl);\n  }\n\n  CHECK_CLIENT_PTR(cl, return)\n\n  if (cl->syncFence) {\n    if (!rfbSendFence(cl, cl->fenceFlags, cl->fenceDataLen, cl->fenceData))\n      return;\n    cl->syncFence = FALSE;\n  }\n\n  rfbUncorkSock(cl->sock);\n}\n\n\n/*\n * rfbProcessClientProtocolVersion is called when the client sends its\n * protocol version.\n */\n\nstatic void rfbProcessClientProtocolVersion(rfbClientPtr cl)\n{\n  rfbProtocolVersionMsg pv;\n  int n, major, minor;\n\n  if ((n = ReadExact(cl, pv, sz_rfbProtocolVersionMsg)) <= 0) {\n    if (n == 0)\n      rfbLog(\"rfbProcessClientProtocolVersion: client gone\\n\");\n    else\n      rfbLogPerror(\"rfbProcessClientProtocolVersion: read\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  pv[sz_rfbProtocolVersionMsg] = 0;\n  if (sscanf(pv, rfbProtocolVersionFormat, &major, &minor) != 2) {\n    rfbLog(\"rfbProcessClientProtocolVersion: not a valid RFB client\\n\");\n    rfbCloseClient(cl);\n    return;\n  }\n  if (major != 3) {\n    rfbLog(\"Unsupported protocol version %d.%d\\n\", major, minor);\n    rfbCloseClient(cl);\n    return;\n  }\n\n  /* Always use one of the three standard versions of the RFB protocol. */\n  cl->protocol_minor_ver = minor;\n\n  if (minor > 8)                        /* buggy client */\n    cl->protocol_minor_ver = 8;\n  else if (minor > 3 && minor < 7)      /* non-standard client */\n    cl->protocol_minor_ver = 3;\n  else if (minor < 3)                   /* ancient client */\n    cl->protocol_minor_ver = 3;\n\n  if (cl->protocol_minor_ver != minor)\n    rfbLog(\"Non-standard protocol version 3.%d, using 3.%d instead\\n\", minor,\n           cl->protocol_minor_ver);\n  else\n    rfbLog(\"Using protocol version 3.%d\\n\", cl->protocol_minor_ver);\n\n  /* TightVNC protocol extensions are not enabled yet. */\n  cl->protocol_tightvnc = FALSE;\n\n  rfbAuthNewClient(cl);\n}\n\n\n/*\n * rfbProcessClientInitMessage is called when the client sends its\n * initialisation message.\n */\n\nstatic void rfbProcessClientInitMessage(rfbClientPtr cl)\n{\n  rfbClientInitMsg ci;\n  char buf[256];\n  rfbServerInitMsg *si = (rfbServerInitMsg *)buf;\n  int len, n;\n  rfbClientPtr otherCl, nextCl;\n\n  if ((n = ReadExact(cl, (char *)&ci, sz_rfbClientInitMsg)) <= 0) {\n    if (n == 0)\n      rfbLog(\"rfbProcessClientInitMessage: client gone\\n\");\n    else\n      rfbLogPerror(\"rfbProcessClientInitMessage: read\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  si->framebufferWidth = Swap16IfLE(rfbFB.width);\n  si->framebufferHeight = Swap16IfLE(rfbFB.height);\n  si->format = rfbServerFormat;\n  si->format.redMax = Swap16IfLE(si->format.redMax);\n  si->format.greenMax = Swap16IfLE(si->format.greenMax);\n  si->format.blueMax = Swap16IfLE(si->format.blueMax);\n\n  if (strlen(desktopName) > 128)        /* sanity check on desktop name len */\n    desktopName[128] = 0;\n\n  sprintf(buf + sz_rfbServerInitMsg, \"%s\", desktopName);\n\n  len = strlen(buf + sz_rfbServerInitMsg);\n  si->nameLength = Swap32IfLE(len);\n\n  if (WriteExact(cl, buf, sz_rfbServerInitMsg + len) < 0) {\n    rfbLogPerror(\"rfbProcessClientInitMessage: write\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  if (cl->protocol_tightvnc)\n    rfbSendInteractionCaps(cl);  /* protocol 3.7t */\n\n  /* Dispatch client input to rfbProcessClientNormalMessage(). */\n  cl->state = RFB_NORMAL;\n\n  if (!cl->reverseConnection &&\n      (rfbNeverShared || (!rfbAlwaysShared && !ci.shared))) {\n\n    if (rfbDontDisconnect) {\n      for (otherCl = rfbClientHead; otherCl; otherCl = otherCl->next) {\n        if ((otherCl != cl) && (otherCl->state == RFB_NORMAL)) {\n          rfbLog(\"-dontdisconnect: Not shared & existing client\\n\");\n          rfbLog(\"  refusing new client %s\\n\", cl->host);\n          rfbCloseClient(cl);\n          return;\n        }\n      }\n    } else {\n      for (otherCl = rfbClientHead; otherCl; otherCl = nextCl) {\n        nextCl = otherCl->next;\n        if ((otherCl != cl) && (otherCl->state == RFB_NORMAL)) {\n          rfbLog(\"Not shared - closing connection to client %s\\n\",\n                 otherCl->host);\n          rfbCloseClient(otherCl);\n        }\n      }\n    }\n  }\n}\n\n\n/*\n * rfbSendInteractionCaps is called after sending the server\n * initialisation message, only if TightVNC protocol extensions were\n * enabled (protocol versions 3.7t, 3.8t). In this function, we send\n * the lists of supported protocol messages and encodings.\n */\n\n/* Update these constants on changing capability lists below! */\n#define N_SMSG_CAPS  0\n#define N_CMSG_CAPS  0\n#define N_ENC_CAPS  17\n\nvoid rfbSendInteractionCaps(rfbClientPtr cl)\n{\n  rfbInteractionCapsMsg intr_caps;\n  rfbCapabilityInfo enc_list[N_ENC_CAPS];\n  int i;\n\n  /* Fill in the header structure sent prior to capability lists. */\n  intr_caps.nServerMessageTypes = Swap16IfLE(N_SMSG_CAPS);\n  intr_caps.nClientMessageTypes = Swap16IfLE(N_CMSG_CAPS);\n  intr_caps.nEncodingTypes = Swap16IfLE(N_ENC_CAPS);\n  intr_caps.pad = 0;\n\n  /* Supported server->client message types. */\n  /* For future file transfer support:\n  i = 0;\n  SetCapInfo(&smsg_list[i++], rfbFileListData,           rfbTightVncVendor);\n  SetCapInfo(&smsg_list[i++], rfbFileDownloadData,       rfbTightVncVendor);\n  SetCapInfo(&smsg_list[i++], rfbFileUploadCancel,       rfbTightVncVendor);\n  SetCapInfo(&smsg_list[i++], rfbFileDownloadFailed,     rfbTightVncVendor);\n  if (i != N_SMSG_CAPS) {\n    rfbLog(\"rfbSendInteractionCaps: assertion failed, i != N_SMSG_CAPS\\n\");\n    rfbCloseClient(cl);\n    return;\n  }\n  */\n\n  /* Supported client->server message types. */\n  /* For future file transfer support:\n  i = 0;\n  SetCapInfo(&cmsg_list[i++], rfbFileListRequest,        rfbTightVncVendor);\n  SetCapInfo(&cmsg_list[i++], rfbFileDownloadRequest,    rfbTightVncVendor);\n  SetCapInfo(&cmsg_list[i++], rfbFileUploadRequest,      rfbTightVncVendor);\n  SetCapInfo(&cmsg_list[i++], rfbFileUploadData,         rfbTightVncVendor);\n  SetCapInfo(&cmsg_list[i++], rfbFileDownloadCancel,     rfbTightVncVendor);\n  SetCapInfo(&cmsg_list[i++], rfbFileUploadFailed,       rfbTightVncVendor);\n  if (i != N_CMSG_CAPS) {\n    rfbLog(\"rfbSendInteractionCaps: assertion failed, i != N_CMSG_CAPS\\n\");\n    rfbCloseClient(cl);\n    return;\n  }\n  */\n\n  /* Encoding types. */\n  i = 0;\n  SetCapInfo(&enc_list[i++],  rfbEncodingCopyRect,       rfbStandardVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingRRE,            rfbStandardVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingCoRRE,          rfbStandardVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingHextile,        rfbStandardVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingZlib,           rfbTridiaVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingZRLE,           rfbTridiaVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingZYWRLE,         rfbTridiaVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingTight,          rfbTightVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingCompressLevel0, rfbTightVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingQualityLevel0,  rfbTightVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingFineQualityLevel0, rfbTurboVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingSubsamp1X,         rfbTurboVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingXCursor,        rfbTightVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingRichCursor,     rfbTightVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingPointerPos,     rfbTightVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbEncodingLastRect,       rfbTightVncVendor);\n  SetCapInfo(&enc_list[i++],  rfbGIIServer,              rfbGIIVendor);\n  if (i != N_ENC_CAPS) {\n    rfbLog(\"rfbSendInteractionCaps: assertion failed, i != N_ENC_CAPS\\n\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  /* Send header and capability lists */\n  if (WriteExact(cl, (char *)&intr_caps,\n                 sz_rfbInteractionCapsMsg) < 0 ||\n      WriteExact(cl, (char *)&enc_list[0],\n                 sz_rfbCapabilityInfo * N_ENC_CAPS) < 0) {\n    rfbLogPerror(\"rfbSendInteractionCaps: write\");\n    rfbCloseClient(cl);\n    return;\n  }\n\n  /* Dispatch client input to rfbProcessClientNormalMessage(). */\n  cl->state = RFB_NORMAL;\n}\n\n\n/*\n * rfbProcessClientNormalMessage is called when the client has sent a normal\n * protocol message.\n */\n\n#define READ(addr, numBytes)  \\\n  if ((n = ReadExact(cl, addr, numBytes)) <= 0) {  \\\n    if (n != 0)  \\\n      rfbLogPerror(\"rfbProcessClientNormalMessage: read\");  \\\n    rfbCloseClient(cl);  \\\n    return;  \\\n  }\n\n#define SKIP(numBytes)  \\\n  if ((n = SkipExact(cl, numBytes)) <= 0) {  \\\n    if (n != 0)  \\\n      rfbLogPerror(\"rfbProcessClientNormalMessage: skip\");  \\\n    rfbCloseClient(cl);  \\\n    return;  \\\n  }\n\nstatic void rfbProcessClientNormalMessage(rfbClientPtr cl)\n{\n  int n;\n  rfbClientToServerMsg msg;\n  char *str;\n\n  READ((char *)&msg, 1)\n\n  switch (msg.type) {\n\n    case rfbSetPixelFormat:\n\n      READ(((char *)&msg) + 1, sz_rfbSetPixelFormatMsg - 1)\n\n      cl->format.bitsPerPixel = msg.spf.format.bitsPerPixel;\n      cl->format.depth = msg.spf.format.depth;\n      cl->format.bigEndian = (msg.spf.format.bigEndian ? 1 : 0);\n      cl->format.trueColour = (msg.spf.format.trueColour ? 1 : 0);\n      cl->format.redMax = Swap16IfLE(msg.spf.format.redMax);\n      cl->format.greenMax = Swap16IfLE(msg.spf.format.greenMax);\n      cl->format.blueMax = Swap16IfLE(msg.spf.format.blueMax);\n      cl->format.redShift = msg.spf.format.redShift;\n      cl->format.greenShift = msg.spf.format.greenShift;\n      cl->format.blueShift = msg.spf.format.blueShift;\n\n      cl->readyForSetColourMapEntries = TRUE;\n\n      rfbSetTranslateFunction(cl);\n      return;\n\n    case rfbFixColourMapEntries:\n      READ(((char *)&msg) + 1, sz_rfbFixColourMapEntriesMsg - 1)\n      rfbLog(\"rfbProcessClientNormalMessage: FixColourMapEntries unsupported\\n\");\n      rfbCloseClient(cl);\n      return;\n\n    case rfbSetEncodings:\n    {\n      int i;\n      CARD32 enc;\n      Bool firstFence = !cl->enableFence;\n      Bool firstCU = !cl->enableCU;\n      Bool firstGII = !cl->enableGII;\n      Bool logTightCompressLevel = FALSE;\n\n      READ(((char *)&msg) + 1, sz_rfbSetEncodingsMsg - 1)\n\n      msg.se.nEncodings = Swap16IfLE(msg.se.nEncodings);\n\n      cl->preferredEncoding = -1;\n      cl->useCopyRect = FALSE;\n      cl->enableCursorShapeUpdates = FALSE;\n      cl->enableCursorPosUpdates = FALSE;\n      cl->enableLastRectEncoding = FALSE;\n      cl->tightCompressLevel = TIGHT_DEFAULT_COMPRESSION;\n      cl->tightSubsampLevel = TIGHT_DEFAULT_SUBSAMP;\n      cl->tightQualityLevel = -1;\n      cl->imageQualityLevel = -1;\n\n      for (i = 0; i < msg.se.nEncodings; i++) {\n        READ((char *)&enc, 4)\n        enc = Swap32IfLE(enc);\n\n        switch (enc) {\n\n          case rfbEncodingCopyRect:\n            cl->useCopyRect = TRUE;\n            break;\n          case rfbEncodingRaw:\n            if (cl->preferredEncoding == -1) {\n              cl->preferredEncoding = enc;\n              rfbLog(\"Using raw encoding for client %s\\n\", cl->host);\n            }\n            break;\n          case rfbEncodingRRE:\n            if (cl->preferredEncoding == -1) {\n              cl->preferredEncoding = enc;\n              rfbLog(\"Using rre encoding for client %s\\n\", cl->host);\n            }\n            break;\n          case rfbEncodingCoRRE:\n            if (cl->preferredEncoding == -1) {\n              cl->preferredEncoding = enc;\n              rfbLog(\"Using CoRRE encoding for client %s\\n\", cl->host);\n            }\n            break;\n          case rfbEncodingHextile:\n            if (cl->preferredEncoding == -1) {\n              cl->preferredEncoding = enc;\n              rfbLog(\"Using hextile encoding for client %s\\n\", cl->host);\n            }\n            break;\n          case rfbEncodingZlib:\n            if (cl->preferredEncoding == -1) {\n              cl->preferredEncoding = enc;\n              rfbLog(\"Using zlib encoding for client %s\\n\", cl->host);\n            }\n            break;\n          case rfbEncodingZRLE:\n            if (cl->preferredEncoding == -1) {\n              cl->preferredEncoding = enc;\n              rfbLog(\"Using ZRLE encoding for client %s\\n\", cl->host);\n            }\n            break;\n          case rfbEncodingZYWRLE:\n            if (cl->preferredEncoding == -1) {\n              cl->preferredEncoding = enc;\n              rfbLog(\"Using ZYWRLE encoding for client %s\\n\", cl->host);\n            }\n            break;\n          case rfbEncodingTight:\n            if (cl->preferredEncoding == -1) {\n              cl->preferredEncoding = enc;\n              rfbLog(\"Using tight encoding for client %s\\n\", cl->host);\n            }\n            break;\n          case rfbEncodingXCursor:\n            if (!cl->enableCursorShapeUpdates) {\n              rfbLog(\"Enabling X-style cursor updates for client %s\\n\",\n                     cl->host);\n              cl->enableCursorShapeUpdates = TRUE;\n              cl->useRichCursorEncoding = FALSE;\n              cl->cursorWasChanged = TRUE;\n            }\n            break;\n          case rfbEncodingRichCursor:\n            if (!cl->enableCursorShapeUpdates) {\n              rfbLog(\"Enabling full-color cursor updates for client %s\\n\",\n                     cl->host);\n              cl->enableCursorShapeUpdates = TRUE;\n              cl->useRichCursorEncoding = TRUE;\n              cl->cursorWasChanged = TRUE;\n            }\n            break;\n          case rfbEncodingPointerPos:\n            if (!cl->enableCursorPosUpdates) {\n              rfbLog(\"Enabling cursor position updates for client %s\\n\",\n                     cl->host);\n              cl->enableCursorPosUpdates = TRUE;\n              cl->cursorWasMoved = TRUE;\n              cl->cursorX = -1;\n              cl->cursorY = -1;\n            }\n            break;\n          case rfbEncodingLastRect:\n            if (!cl->enableLastRectEncoding) {\n              rfbLog(\"Enabling LastRect protocol extension for client %s\\n\",\n                     cl->host);\n              cl->enableLastRectEncoding = TRUE;\n            }\n            break;\n          case rfbEncodingFence:\n            if (!cl->enableFence) {\n              rfbLog(\"Enabling Fence protocol extension for client %s\\n\",\n                     cl->host);\n              cl->enableFence = TRUE;\n            }\n            break;\n          case rfbEncodingContinuousUpdates:\n            if (!cl->enableCU) {\n              rfbLog(\"Enabling Continuous Updates protocol extension for client %s\\n\",\n                     cl->host);\n              cl->enableCU = TRUE;\n            }\n            break;\n          case rfbEncodingNewFBSize:\n            if (!cl->enableDesktopSize) {\n              if (!rfbAuthDisableRemoteResize) {\n                rfbLog(\"Enabling Desktop Size protocol extension for client %s\\n\",\n                       cl->host);\n                cl->enableDesktopSize = TRUE;\n              } else\n                rfbLog(\"WARNING: Remote desktop resizing disabled per system policy.\\n\");\n            }\n            break;\n          case rfbEncodingExtendedDesktopSize:\n            if (!cl->enableExtDesktopSize) {\n              if (!rfbAuthDisableRemoteResize) {\n                rfbLog(\"Enabling Extended Desktop Size protocol extension for client %s\\n\",\n                       cl->host);\n                cl->enableExtDesktopSize = TRUE;\n              } else\n                rfbLog(\"WARNING: Remote desktop resizing disabled per system policy.\\n\");\n            }\n            break;\n          case rfbEncodingGII:\n            if (!cl->enableGII) {\n              rfbLog(\"Enabling GII extension for client %s\\n\", cl->host);\n              cl->enableGII = TRUE;\n            }\n            break;\n          default:\n            if (enc >= (CARD32)rfbEncodingCompressLevel0 &&\n                enc <= (CARD32)rfbEncodingCompressLevel9) {\n              cl->zlibCompressLevel = enc & 0x0F;\n              cl->tightCompressLevel = enc & 0x0F;\n              if (cl->preferredEncoding == rfbEncodingTight)\n                logTightCompressLevel = TRUE;\n              else\n                rfbLog(\"Using compression level %d for client %s\\n\",\n                       cl->tightCompressLevel, cl->host);\n              if (rfbInterframe == -1) {\n                if (cl->tightCompressLevel >= 5) {\n                  if (!InterframeOn(cl)) {\n                    rfbCloseClient(cl);\n                    return;\n                  }\n                } else\n                  InterframeOff(cl);\n              }\n            } else if (enc >= (CARD32)rfbEncodingSubsamp1X &&\n                       enc <= (CARD32)rfbEncodingSubsampGray) {\n              cl->tightSubsampLevel = enc & 0xFF;\n              rfbLog(\"Using JPEG subsampling %d for client %s\\n\",\n                     cl->tightSubsampLevel, cl->host);\n            } else if (enc >= (CARD32)rfbEncodingQualityLevel0 &&\n                       enc <= (CARD32)rfbEncodingQualityLevel9) {\n              cl->tightQualityLevel = JPEG_QUAL[enc & 0x0F];\n              cl->tightSubsampLevel = JPEG_SUBSAMP[enc & 0x0F];\n              cl->imageQualityLevel = enc & 0x0F;\n              if (cl->preferredEncoding == rfbEncodingTight)\n                rfbLog(\"Using JPEG subsampling %d, Q%d for client %s\\n\",\n                       cl->tightSubsampLevel, cl->tightQualityLevel, cl->host);\n              else\n                rfbLog(\"Using image quality level %d for client %s\\n\",\n                       cl->imageQualityLevel, cl->host);\n            } else if (enc >= (CARD32)rfbEncodingFineQualityLevel0 + 1 &&\n                       enc <= (CARD32)rfbEncodingFineQualityLevel100) {\n              cl->tightQualityLevel = enc & 0xFF;\n              rfbLog(\"Using JPEG quality %d for client %s\\n\",\n                     cl->tightQualityLevel, cl->host);\n            } else {\n              rfbLog(\"rfbProcessClientNormalMessage: ignoring unknown encoding %d (%x)\\n\",\n                     (int)enc, (int)enc);\n            }\n        }  /* switch (enc) */\n      }  /* for (i = 0; i < msg.se.nEncodings; i++) */\n\n      if (cl->preferredEncoding == -1)\n        cl->preferredEncoding = rfbEncodingTight;\n\n      if (cl->preferredEncoding == rfbEncodingTight && logTightCompressLevel)\n        rfbLog(\"Using Tight compression level %d for client %s\\n\",\n               rfbTightCompressLevel(cl), cl->host);\n\n      if (cl->enableCursorPosUpdates && !cl->enableCursorShapeUpdates) {\n        rfbLog(\"Disabling cursor position updates for client %s\\n\", cl->host);\n        cl->enableCursorPosUpdates = FALSE;\n      }\n\n      if (cl->enableFence && firstFence) {\n        if (!rfbSendFence(cl, rfbFenceFlagRequest, 0, NULL))\n          return;\n      }\n\n      if (cl->enableCU && cl->enableFence && firstCU) {\n        if (!rfbSendEndOfCU(cl))\n          return;\n      }\n\n      if (cl->enableGII && firstGII) {\n        /* Send GII server version message to all clients */\n        rfbGIIServerVersionMsg msg;\n\n        msg.type = rfbGIIServer;\n        /* We always send as big endian to make things easier on the Java\n           viewer. */\n        msg.endianAndSubType = rfbGIIVersion | rfbGIIBE;\n        msg.length = Swap16IfLE(sz_rfbGIIServerVersionMsg - 4);\n        msg.maximumVersion = msg.minimumVersion = Swap16IfLE(1);\n\n        if (WriteExact(cl, (char *)&msg, sz_rfbGIIServerVersionMsg) < 0) {\n          rfbLogPerror(\"rfbProcessClientNormalMessage: write\");\n          rfbCloseClient(cl);\n          return;\n        }\n      }\n\n      return;\n    }  /* rfbSetEncodings */\n\n    case rfbFramebufferUpdateRequest:\n    {\n      RegionRec tmpRegion;\n      BoxRec box;\n\n      READ(((char *)&msg) + 1, sz_rfbFramebufferUpdateRequestMsg - 1)\n\n      box.x1 = Swap16IfLE(msg.fur.x);\n      box.y1 = Swap16IfLE(msg.fur.y);\n      box.x2 = box.x1 + Swap16IfLE(msg.fur.w);\n      box.y2 = box.y1 + Swap16IfLE(msg.fur.h);\n      SAFE_REGION_INIT(pScreen, &tmpRegion, &box, 0);\n\n      if (!msg.fur.incremental || !cl->continuousUpdates)\n        REGION_UNION(pScreen, &cl->requestedRegion, &cl->requestedRegion,\n                     &tmpRegion);\n\n      if (!cl->readyForSetColourMapEntries) {\n        /* client hasn't sent a SetPixelFormat so is using server's */\n        cl->readyForSetColourMapEntries = TRUE;\n        if (!cl->format.trueColour) {\n          if (!rfbSetClientColourMap(cl, 0, 0)) {\n            REGION_UNINIT(pScreen, &tmpRegion);\n            return;\n          }\n        }\n      }\n\n      if (!msg.fur.incremental) {\n        REGION_UNION(pScreen, &cl->modifiedRegion, &cl->modifiedRegion,\n                     &tmpRegion);\n        REGION_SUBTRACT(pScreen, &cl->copyRegion, &cl->copyRegion, &tmpRegion);\n        REGION_UNION(pScreen, &cl->ifRegion, &cl->ifRegion, &tmpRegion);\n        cl->pendingExtDesktopResize = TRUE;\n      }\n\n      if (FB_UPDATE_PENDING(cl) &&\n          (!cl->deferredUpdateScheduled || rfbDeferUpdateTime == 0 ||\n           gettime() - cl->deferredUpdateStart >=\n           (double)rfbDeferUpdateTime)) {\n        if (rfbSendFramebufferUpdate(cl))\n          cl->deferredUpdateScheduled = FALSE;\n      }\n\n      REGION_UNINIT(pScreen, &tmpRegion);\n      return;\n    }\n\n    case rfbKeyEvent:\n\n      cl->rfbKeyEventsRcvd++;\n\n      READ(((char *)&msg) + 1, sz_rfbKeyEventMsg - 1)\n\n      if (!rfbViewOnly && !cl->viewOnly)\n        KeyEvent((KeySym)Swap32IfLE(msg.ke.key), msg.ke.down);\n\n      return;\n\n    case rfbPointerEvent:\n\n      cl->rfbPointerEventsRcvd++;\n\n      READ(((char *)&msg) + 1, sz_rfbPointerEventMsg - 1)\n\n      if (pointerClient && (pointerClient != cl))\n        return;\n\n      if (msg.pe.buttonMask == 0)\n        pointerClient = NULL;\n      else\n        pointerClient = cl;\n\n      if (!rfbViewOnly && !cl->viewOnly) {\n        cl->cursorX = (int)Swap16IfLE(msg.pe.x);\n        cl->cursorY = (int)Swap16IfLE(msg.pe.y);\n        PtrAddEvent(msg.pe.buttonMask, cl->cursorX, cl->cursorY, cl);\n      }\n      return;\n\n    case rfbClientCutText:\n    {\n      int ignoredBytes = 0;\n\n      READ(((char *)&msg) + 1, sz_rfbClientCutTextMsg - 1)\n\n      msg.cct.length = Swap32IfLE(msg.cct.length);\n      if (msg.cct.length > rfbMaxClipboard) {\n        rfbLog(\"Truncating %d-byte clipboard update to %d bytes.\\n\",\n               msg.cct.length, rfbMaxClipboard);\n        ignoredBytes = msg.cct.length - rfbMaxClipboard;\n        msg.cct.length = rfbMaxClipboard;\n      }\n\n      if (msg.cct.length <= 0) return;\n      str = (char *)malloc(msg.cct.length);\n      if (str == NULL) {\n        rfbLogPerror(\"rfbProcessClientNormalMessage: rfbClientCutText out of memory\");\n        rfbCloseClient(cl);\n        return;\n      }\n\n      if ((n = ReadExact(cl, str, msg.cct.length)) <= 0) {\n        if (n != 0)\n          rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n        free(str);\n        rfbCloseClient(cl);\n        return;\n      }\n\n      if (ignoredBytes > 0) {\n        if ((n = SkipExact(cl, ignoredBytes)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          free(str);\n          rfbCloseClient(cl);\n          return;\n        }\n      }\n\n      /* NOTE: We do not accept cut text from a view-only client */\n      if (!rfbViewOnly && !cl->viewOnly && !rfbAuthDisableCBRecv) {\n        vncClientCutText(str, msg.cct.length);\n        if (rfbSyncCutBuffer) rfbSetXCutText(str, msg.cct.length);\n      }\n\n      free(str);\n      return;\n    }\n\n    case rfbEnableContinuousUpdates:\n    {\n      BoxRec box;\n\n      READ(((char *)&msg) + 1, sz_rfbEnableContinuousUpdatesMsg - 1)\n\n      if (!cl->enableFence || !cl->enableCU) {\n        rfbLog(\"Ignoring request to enable continuous updates because the client does not\\n\");\n        rfbLog(\"support the flow control extensions.\\n\");\n        return;\n      }\n\n      box.x1 = Swap16IfLE(msg.ecu.x);\n      box.y1 = Swap16IfLE(msg.ecu.y);\n      box.x2 = box.x1 + Swap16IfLE(msg.ecu.w);\n      box.y2 = box.y1 + Swap16IfLE(msg.ecu.h);\n      SAFE_REGION_INIT(pScreen, &cl->cuRegion, &box, 0);\n\n      cl->continuousUpdates = msg.ecu.enable;\n      if (cl->continuousUpdates) {\n        REGION_EMPTY(pScreen, &cl->requestedRegion);\n        if (!rfbSendFramebufferUpdate(cl))\n          return;\n      } else {\n        if (!rfbSendEndOfCU(cl))\n          return;\n      }\n\n      rfbLog(\"Continuous updates %s\\n\",\n             cl->continuousUpdates ? \"enabled\" : \"disabled\");\n      return;\n    }\n\n    case rfbFence:\n    {\n      CARD32 flags;\n      char data[64];\n\n      READ(((char *)&msg) + 1, sz_rfbFenceMsg - 1)\n\n      flags = Swap32IfLE(msg.f.flags);\n\n      if (msg.f.length > sizeof(data)) {\n        rfbLog(\"Ignoring fence.  Payload of %d bytes is too large.\\n\",\n               msg.f.length);\n        SKIP(msg.f.length)\n      } else {\n        READ(data, msg.f.length)\n        HandleFence(cl, flags, msg.f.length, data);\n      }\n\n      return;\n    }\n\n    #define EDSERROR(format, args...) {  \\\n      if (!strlen(errMsg))  \\\n        snprintf(errMsg, 256, \"Desktop resize ERROR: \"format\"\\n\", args);  \\\n      result = rfbEDSResultInvalid;  \\\n    }\n\n    case rfbSetDesktopSize:\n    {\n      int i;\n      struct xorg_list newScreens;\n      rfbClientPtr cl2;\n      int result = rfbEDSResultSuccess;\n      char errMsg[256] = \"\\0\";\n      ScreenPtr pScreen = screenInfo.screens[0];\n\n      READ(((char *)&msg) + 1, sz_rfbSetDesktopSizeMsg - 1)\n\n      if (msg.sds.numScreens < 1)\n        EDSERROR(\"Requested number of screens %d is invalid\",\n                 msg.sds.numScreens);\n\n      msg.sds.w = Swap16IfLE(msg.sds.w);\n      msg.sds.h = Swap16IfLE(msg.sds.h);\n      if (msg.sds.w < 1 || msg.sds.h < 1)\n        EDSERROR(\"Requested framebuffer dimensions %dx%d are invalid\",\n                 msg.sds.w, msg.sds.h);\n\n      xorg_list_init(&newScreens);\n      for (i = 0; i < msg.sds.numScreens; i++) {\n        rfbScreenInfo *screen = rfbNewScreen(0, 0, 0, 0, 0, 0);\n\n        READ((char *)&screen->s, sizeof(rfbScreenDesc))\n        screen->s.id = Swap32IfLE(screen->s.id);\n        screen->s.x = Swap16IfLE(screen->s.x);\n        screen->s.y = Swap16IfLE(screen->s.y);\n        screen->s.w = Swap16IfLE(screen->s.w);\n        screen->s.h = Swap16IfLE(screen->s.h);\n        screen->s.flags = Swap32IfLE(screen->s.flags);\n        if (screen->s.w < 1 || screen->s.h < 1)\n          EDSERROR(\"Screen 0x%.8x requested dimensions %dx%d are invalid\",\n                   (unsigned int)screen->s.id, screen->s.w, screen->s.h);\n        if (screen->s.x >= msg.sds.w || screen->s.y >= msg.sds.h ||\n            screen->s.x + screen->s.w > msg.sds.w ||\n            screen->s.y + screen->s.h > msg.sds.h)\n          EDSERROR(\"Screen 0x%.8x requested geometry %dx%d+%d+%d exceeds requested framebuffer dimensions\",\n                   (unsigned int)screen->s.id, screen->s.w, screen->s.h,\n                   screen->s.x, screen->s.y);\n        if (rfbFindScreenID(&newScreens, screen->s.id)) {\n          EDSERROR(\"Screen 0x%.8x duplicate ID\", (unsigned int)screen->s.id);\n          free(screen);\n        } else\n          rfbAddScreen(&newScreens, screen);\n      }\n\n      if (cl->viewOnly) {\n        rfbLog(\"NOTICE: Ignoring remote desktop resize request from a view-only client.\\n\");\n        result = rfbEDSResultProhibited;\n      } else if (result == rfbEDSResultSuccess) {\n        result = ResizeDesktop(pScreen, cl, msg.sds.w, msg.sds.h, &newScreens);\n        if (result == rfbEDSResultSuccess)\n          return;\n      } else\n        rfbLog(errMsg);\n\n      rfbRemoveScreens(&newScreens);\n\n      /* Send back the error only to the requesting client.  This loop is\n         necessary because the client may have been shut down as a result of\n         an error in ResizeDesktop(). */\n      for (cl2 = rfbClientHead; cl2; cl2 = cl2->next) {\n        if (cl2 == cl) {\n          cl2->pendingExtDesktopResize = TRUE;\n          cl2->reason = rfbEDSReasonClient;\n          cl2->result = result;\n          rfbSendFramebufferUpdate(cl2);\n          break;\n        }\n      }\n\n      return;\n    }\n\n    case rfbGIIClient:\n    {\n      CARD8 endianAndSubType, littleEndian, subType;\n\n      READ((char *)&endianAndSubType, 1);\n      littleEndian = (endianAndSubType & rfbGIIBE) ? 0 : 1;\n      subType = endianAndSubType & ~rfbGIIBE;\n\n      switch (subType) {\n\n        case rfbGIIVersion:\n\n          READ((char *)&msg.giicv.length, sz_rfbGIIClientVersionMsg - 2);\n          if (littleEndian != *(const char *)&rfbEndianTest) {\n            msg.giicv.length = Swap16(msg.giicv.length);\n            msg.giicv.version = Swap16(msg.giicv.version);\n          }\n          if (msg.giicv.length != sz_rfbGIIClientVersionMsg - 4 ||\n              msg.giicv.version < 1) {\n            rfbLog(\"ERROR: Malformed GII client version message\\n\");\n            rfbCloseClient(cl);\n            return;\n          }\n          rfbLog(\"Client supports GII version %d\\n\", msg.giicv.version);\n          break;\n\n        case rfbGIIDeviceCreate:\n        {\n          int i;\n          rfbDevInfo dev;\n          rfbGIIDeviceCreatedMsg dcmsg;\n\n          memset(&dev, 0, sizeof(dev));\n          dcmsg.deviceOrigin = 0;\n\n          READ((char *)&msg.giidc.length, sz_rfbGIIDeviceCreateMsg - 2);\n          if (littleEndian != *(const char *)&rfbEndianTest) {\n            msg.giidc.length = Swap16(msg.giidc.length);\n            msg.giidc.vendorID = Swap32(msg.giidc.vendorID);\n            msg.giidc.productID = Swap32(msg.giidc.productID);\n            msg.giidc.canGenerate = Swap32(msg.giidc.canGenerate);\n            msg.giidc.numRegisters = Swap32(msg.giidc.numRegisters);\n            msg.giidc.numValuators = Swap32(msg.giidc.numValuators);\n            msg.giidc.numButtons = Swap32(msg.giidc.numButtons);\n          }\n\n          rfbLog(\"GII Device Create: %s\\n\", msg.giidc.deviceName);\n#ifdef GII_DEBUG\n          rfbLog(\"    Vendor ID: %d\\n\", msg.giidc.vendorID);\n          rfbLog(\"    Product ID: %d\\n\", msg.giidc.productID);\n          rfbLog(\"    Event mask: %.8x\\n\", msg.giidc.canGenerate);\n          rfbLog(\"    Registers: %d\\n\", msg.giidc.numRegisters);\n          rfbLog(\"    Valuators: %d\\n\", msg.giidc.numValuators);\n          rfbLog(\"    Buttons: %d\\n\", msg.giidc.numButtons);\n#endif\n\n          if (msg.giidc.length != sz_rfbGIIDeviceCreateMsg - 4 +\n              msg.giidc.numValuators * sz_rfbGIIValuator) {\n            rfbLog(\"ERROR: Malformed GII device create message\\n\");\n            rfbCloseClient(cl);\n            return;\n          }\n\n          if (msg.giidc.numButtons > MAX_BUTTONS) {\n            rfbLog(\"GII device create ERROR: %d buttons exceeds max of %d\\n\",\n                   msg.giidc.numButtons, MAX_BUTTONS);\n            SKIP(msg.giidc.numValuators * sz_rfbGIIValuator);\n            goto sendMessage;\n          }\n          if (msg.giidc.numValuators > MAX_VALUATORS) {\n            rfbLog(\"GII device create ERROR: %d valuators exceeds max of %d\\n\",\n                   msg.giidc.numValuators, MAX_VALUATORS);\n            SKIP(msg.giidc.numValuators * sz_rfbGIIValuator);\n            goto sendMessage;\n          }\n\n          memcpy(&dev.name, msg.giidc.deviceName, 32);\n          dev.numButtons = msg.giidc.numButtons;\n          dev.numValuators = msg.giidc.numValuators;\n          dev.eventMask = msg.giidc.canGenerate;\n          dev.mode =\n            (dev.eventMask & rfbGIIValuatorAbsoluteMask) ? Absolute : Relative;\n          dev.productID = msg.giidc.productID;\n\n          if (dev.mode == Relative) {\n            rfbLog(\"GII device create ERROR: relative valuators not supported (yet)\\n\");\n            SKIP(msg.giidc.numValuators * sz_rfbGIIValuator);\n            goto sendMessage;\n          }\n\n          for (i = 0; i < dev.numValuators; i++) {\n            rfbGIIValuator *v = &dev.valuators[i];\n            READ((char *)v, sz_rfbGIIValuator);\n            if (littleEndian != *(const char *)&rfbEndianTest) {\n              v->index = Swap32(v->index);\n              v->rangeMin = Swap32((CARD32)v->rangeMin);\n              v->rangeCenter = Swap32((CARD32)v->rangeCenter);\n              v->rangeMax = Swap32((CARD32)v->rangeMax);\n              v->siUnit = Swap32(v->siUnit);\n              v->siAdd = Swap32((CARD32)v->siAdd);\n              v->siMul = Swap32((CARD32)v->siMul);\n              v->siDiv = Swap32((CARD32)v->siDiv);\n              v->siShift = Swap32((CARD32)v->siShift);\n            }\n\n#ifdef GII_DEBUG\n            rfbLog(\"    Valuator: %s (%s)\\n\", v->longName, v->shortName);\n            rfbLog(\"        Index: %d\\n\", v->index);\n            rfbLog(\"        Range: min = %d, center = %d, max = %d\\n\",\n                   v->rangeMin, v->rangeCenter, v->rangeMax);\n            rfbLog(\"        SI unit: %d\\n\", v->siUnit);\n            rfbLog(\"        SI add: %d\\n\", v->siAdd);\n            rfbLog(\"        SI multiply: %d\\n\", v->siMul);\n            rfbLog(\"        SI divide: %d\\n\", v->siDiv);\n            rfbLog(\"        SI shift: %d\\n\", v->siShift);\n#endif\n          }\n\n          for (i = 0; i < cl->numDevices; i++) {\n            if (!strcmp(dev.name, cl->devices[i].name)) {\n              rfbLog(\"Device \\'%s\\' already exists with GII device ID %d\\n\",\n                     dev.name, i + 1);\n              dcmsg.deviceOrigin = Swap32IfLE(i + 1);\n              goto sendMessage;\n            }\n          }\n\n          if (rfbVirtualTablet || AddExtInputDevice(&dev)) {\n            memcpy(&cl->devices[cl->numDevices], &dev, sizeof(dev));\n            cl->numDevices++;\n            dcmsg.deviceOrigin = Swap32IfLE(cl->numDevices);\n          }\n          rfbLog(\"GII device ID = %d\\n\", cl->numDevices);\n\n          sendMessage:\n          /* Send back a GII device created message */\n          dcmsg.type = rfbGIIServer;\n          /* We always send as big endian to make things easier on the Java\n             viewer. */\n          dcmsg.endianAndSubType = rfbGIIDeviceCreate | rfbGIIBE;\n          dcmsg.length = Swap16IfLE(sz_rfbGIIDeviceCreatedMsg - 4);\n\n          if (WriteExact(cl, (char *)&dcmsg, sz_rfbGIIDeviceCreatedMsg) < 0) {\n            rfbLogPerror(\"rfbProcessClientNormalMessage: write\");\n            rfbCloseClient(cl);\n            return;\n          }\n\n          break;\n        }\n\n        case rfbGIIDeviceDestroy:\n\n          READ((char *)&msg.giidd.length, sz_rfbGIIDeviceDestroyMsg - 2);\n          if (littleEndian != *(const char *)&rfbEndianTest) {\n            msg.giidd.length = Swap16(msg.giidd.length);\n            msg.giidd.deviceOrigin = Swap32(msg.giidd.deviceOrigin);\n          }\n          if (msg.giidd.length != sz_rfbGIIDeviceDestroyMsg - 4) {\n            rfbLog(\"ERROR: Malformed GII device create message\\n\");\n            rfbCloseClient(cl);\n            return;\n          }\n\n          RemoveExtInputDevice(cl, msg.giidd.deviceOrigin - 1);\n\n          break;\n\n        case rfbGIIEvent:\n        {\n          CARD16 length;\n\n          READ((char *)&length, sizeof(CARD16));\n          if (littleEndian != *(const char *)&rfbEndianTest)\n            length = Swap16(length);\n\n          while (length > 0) {\n            CARD8 eventSize, eventType;\n\n            READ((char *)&eventSize, 1);\n            READ((char *)&eventType, 1);\n\n            switch (eventType) {\n\n              case rfbGIIButtonPress:\n              case rfbGIIButtonRelease:\n              {\n                rfbGIIButtonEvent b;\n                rfbDevInfo *dev;\n\n                READ((char *)&b.pad, sz_rfbGIIButtonEvent - 2);\n                if (littleEndian != *(const char *)&rfbEndianTest) {\n                  b.deviceOrigin = Swap32(b.deviceOrigin);\n                  b.buttonNumber = Swap32(b.buttonNumber);\n                }\n                if (eventSize != sz_rfbGIIButtonEvent || b.deviceOrigin <= 0 ||\n                    b.buttonNumber < 1) {\n                  rfbLog(\"ERROR: Malformed GII button event\\n\");\n                  rfbCloseClient(cl);\n                  return;\n                }\n                if (eventSize > length) {\n                  rfbLog(\"ERROR: Malformed GII event message\\n\");\n                  rfbCloseClient(cl);\n                  return;\n                }\n                length -= eventSize;\n                if (b.deviceOrigin < 1 || b.deviceOrigin > cl->numDevices) {\n                  rfbLog(\"ERROR: GII button event from non-existent device %d\\n\",\n                         b.deviceOrigin);\n                  rfbCloseClient(cl);\n                  return;\n                }\n                dev = &cl->devices[b.deviceOrigin - 1];\n                if ((eventType == rfbGIIButtonPress &&\n                     (dev->eventMask & rfbGIIButtonPressMask) == 0) ||\n                    (eventType == rfbGIIButtonRelease &&\n                     (dev->eventMask & rfbGIIButtonReleaseMask) == 0)) {\n                  rfbLog(\"ERROR: Device %d can't generate GII button events\\n\",\n                         b.deviceOrigin);\n                  rfbCloseClient(cl);\n                  return;\n                }\n                if (b.buttonNumber > dev->numButtons) {\n                  rfbLog(\"ERROR: GII button %d event for device %d exceeds button count (%d)\\n\",\n                         b.buttonNumber, b.deviceOrigin, dev->numButtons);\n                  rfbCloseClient(cl);\n                  return;\n                }\n#ifdef GII_DEBUG\n                rfbLog(\"Device %d button %d %s\\n\", b.deviceOrigin,\n                       b.buttonNumber,\n                       eventType == rfbGIIButtonPress ? \"PRESS\" : \"release\");\n                fflush(stderr);\n#endif\n                ExtInputAddEvent(dev, eventType == rfbGIIButtonPress ?\n                                 ButtonPress : ButtonRelease, b.buttonNumber);\n                break;\n              }\n\n              case rfbGIIValuatorRelative:\n              case rfbGIIValuatorAbsolute:\n              {\n                rfbGIIValuatorEvent v;\n                int i;\n                rfbDevInfo *dev;\n\n                READ((char *)&v.pad, sz_rfbGIIValuatorEvent - 2);\n                if (littleEndian != *(const char *)&rfbEndianTest) {\n                  v.deviceOrigin = Swap32(v.deviceOrigin);\n                  v.first = Swap32(v.first);\n                  v.count = Swap32(v.count);\n                }\n                if (eventSize !=\n                    sz_rfbGIIValuatorEvent + sizeof(int) * v.count) {\n                  rfbLog(\"ERROR: Malformed GII valuator event\\n\");\n                  rfbCloseClient(cl);\n                  return;\n                }\n                if (eventSize > length) {\n                  rfbLog(\"ERROR: Malformed GII event message\\n\");\n                  rfbCloseClient(cl);\n                  return;\n                }\n                length -= eventSize;\n                if (v.deviceOrigin < 1 || v.deviceOrigin > cl->numDevices) {\n                  rfbLog(\"ERROR: GII valuator event from non-existent device %d\\n\",\n                         v.deviceOrigin);\n                  rfbCloseClient(cl);\n                  return;\n                }\n                dev = &cl->devices[v.deviceOrigin - 1];\n                if ((eventType == rfbGIIValuatorRelative &&\n                     (dev->eventMask & rfbGIIValuatorRelativeMask) == 0) ||\n                    (eventType == rfbGIIValuatorAbsolute &&\n                     (dev->eventMask & rfbGIIValuatorAbsoluteMask) == 0)) {\n                  rfbLog(\"ERROR: Device %d cannot generate GII valuator events\\n\",\n                         v.deviceOrigin);\n                  rfbCloseClient(cl);\n                  return;\n                }\n                if (v.first + v.count > dev->numValuators) {\n                  rfbLog(\"ERROR: GII valuator event for device %d exceeds valuator count (%d)\\n\",\n                         v.deviceOrigin, dev->numValuators);\n                  rfbCloseClient(cl);\n                  return;\n                }\n#ifdef GII_DEBUG\n                rfbLog(\"Device %d Valuator %s first=%d count=%d:\\n\",\n                       v.deviceOrigin,\n                       eventType == rfbGIIValuatorRelative ? \"rel\" : \"ABS\",\n                       v.first, v.count);\n#endif\n                for (i = v.first; i < v.first + v.count; i++) {\n                  READ((char *)&dev->values[i], sizeof(int));\n                  if (littleEndian != *(const char *)&rfbEndianTest)\n                    dev->values[i] = Swap32((CARD32)dev->values[i]);\n#ifdef GII_DEBUG\n                  fprintf(stderr, \"v[%d]=%d \", i, dev->values[i]);\n#endif\n                }\n#ifdef GII_DEBUG\n                fprintf(stderr, \"\\n\");\n#endif\n                if (v.count > 0) {\n                  dev->valFirst = v.first;\n                  dev->valCount = v.count;\n                  dev->mode = eventType == rfbGIIValuatorAbsolute ?\n                              Absolute : Relative;\n                  ExtInputAddEvent(dev, MotionNotify, 0);\n                }\n                break;\n              }\n              default:\n                rfbLog(\"ERROR: This server cannot handle GII event type %d\\n\",\n                       eventType);\n                rfbCloseClient(cl);\n                return;\n            }  /* switch (eventType) */\n          }  /* while (length > 0) */\n          if (length != 0) {\n            rfbLog(\"ERROR: Malformed GII event message\\n\");\n            rfbCloseClient(cl);\n            return;\n          }\n          break;\n        }  /* rfbGIIEvent */\n      }  /* switch (subType) */\n      return;\n    }  /* rfbGIIClient */\n\n    default:\n\n      rfbLog(\"rfbProcessClientNormalMessage: unknown message type %d\\n\",\n             msg.type);\n      rfbLog(\" ... closing connection\\n\");\n      rfbCloseClient(cl);\n      return;\n  }  /* switch (msg.type) */\n}\n\n\n/*\n * rfbSendFramebufferUpdate - send the currently pending framebuffer update to\n * the RFB client.\n */\n\nBool rfbSendFramebufferUpdate(rfbClientPtr cl)\n{\n  ScreenPtr pScreen = screenInfo.screens[0];\n  int i;\n  int nUpdateRegionRects;\n  rfbFramebufferUpdateMsg *fu = (rfbFramebufferUpdateMsg *)updateBuf;\n  RegionRec _updateRegion, *updateRegion = &_updateRegion, updateCopyRegion,\n    idRegion;\n  Bool emptyUpdateRegion = FALSE;\n  rfbClientPtr cl2;\n  int dx, dy;\n  Bool sendCursorShape = FALSE;\n  Bool sendCursorPos = FALSE;\n  double tUpdateStart = 0.0;\n\n  TimerCancel(cl->updateTimer);\n\n  /*\n   * We're in the middle of processing a command that's supposed to be\n   * synchronised. Allowing an update to slip out right now might violate\n   * that synchronisation.\n   */\n\n  if (cl->syncFence) return TRUE;\n\n  if (cl->state != RFB_NORMAL) return TRUE;\n\n  if (rfbProfile) {\n    tUpdateStart = gettime();\n    if (tStart < 0.) tStart = tUpdateStart;\n  }\n\n  /* Check that we actually have some space on the link and retry in a\n     bit if things are congested. */\n\n  if (rfbCongestionControl && rfbIsCongested(cl)) {\n    cl->updateTimer = TimerSet(cl->updateTimer, 0, 50, updateCallback, cl);\n    return TRUE;\n  }\n\n  /* In continuous mode, we will be outputting at least three distinct\n     messages.  We need to aggregate these in order to not clog up TCP's\n     congestion window. */\n\n  rfbCorkSock(cl->sock);\n\n  if (cl->pendingExtDesktopResize) {\n    if (!rfbSendExtDesktopSize(cl)) return FALSE;\n    cl->pendingExtDesktopResize = FALSE;\n  }\n\n  if (cl->pendingDesktopResize) {\n    if (!rfbSendDesktopSize(cl)) return FALSE;\n    cl->pendingDesktopResize = FALSE;\n  }\n\n  if (rfbFB.blockUpdates) {\n    rfbUncorkSock(cl->sock);\n    return TRUE;\n  }\n\n  /*\n   * If this client understands cursor shape updates, cursor should be\n   * removed from the framebuffer. Otherwise, make sure it's put up.\n   */\n\n  if (cl->enableCursorShapeUpdates) {\n    if (rfbFB.cursorIsDrawn)\n      rfbSpriteRemoveCursorAllDev(pScreen);\n    if (!rfbFB.cursorIsDrawn && cl->cursorWasChanged)\n      sendCursorShape = TRUE;\n  } else {\n    if (!rfbFB.cursorIsDrawn)\n      rfbSpriteRestoreCursorAllDev(pScreen);\n  }\n\n  /*\n   * Do we plan to send cursor position update?\n   */\n\n  if (cl->enableCursorPosUpdates && cl->cursorWasMoved)\n    sendCursorPos = TRUE;\n\n  /*\n   * The modifiedRegion may overlap the destination copyRegion.  We remove\n   * any overlapping bits from the copyRegion (since they'd only be\n   * overwritten anyway).\n   */\n\n  REGION_SUBTRACT(pScreen, &cl->copyRegion, &cl->copyRegion,\n                  &cl->modifiedRegion);\n\n  /*\n   * The client is interested in the region requestedRegion.  The region\n   * which should be updated now is the intersection of requestedRegion\n   * and the union of modifiedRegion and copyRegion.  If it's empty then\n   * no update is needed.\n   */\n\n  REGION_INIT(pScreen, updateRegion, NullBox, 0);\n  REGION_UNION(pScreen, updateRegion, &cl->copyRegion, &cl->modifiedRegion);\n\n  if (cl->continuousUpdates)\n    REGION_UNION(pScreen, &cl->requestedRegion, &cl->requestedRegion,\n                 &cl->cuRegion);\n\n  REGION_INTERSECT(pScreen, updateRegion, &cl->requestedRegion, updateRegion);\n\n  if (!REGION_NOTEMPTY(pScreen, updateRegion) && !sendCursorShape &&\n      !sendCursorPos) {\n    REGION_UNINIT(pScreen, updateRegion);\n    return TRUE;\n  }\n\n  /*\n   * We assume that the client doesn't have any pixel data outside the\n   * requestedRegion.  In other words, both the source and destination of a\n   * copy must lie within requestedRegion.  So the region we can send as a\n   * copy is the intersection of the copyRegion with both the requestedRegion\n   * and the requestedRegion translated by the amount of the copy.  We set\n   * updateCopyRegion to this.\n   */\n\n  REGION_INIT(pScreen, &updateCopyRegion, NullBox, 0);\n  REGION_INTERSECT(pScreen, &updateCopyRegion, &cl->copyRegion,\n                   &cl->requestedRegion);\n  REGION_TRANSLATE(pScreen, &cl->requestedRegion, cl->copyDX, cl->copyDY);\n  REGION_INTERSECT(pScreen, &updateCopyRegion, &updateCopyRegion,\n                   &cl->requestedRegion);\n  dx = cl->copyDX;\n  dy = cl->copyDY;\n\n  /*\n   * Next we remove updateCopyRegion from updateRegion so that updateRegion\n   * is the part of this update which is sent as ordinary pixel data (i.e not\n   * a copy).\n   */\n\n  REGION_SUBTRACT(pScreen, updateRegion, updateRegion, &updateCopyRegion);\n\n  /*\n   * Finally we leave modifiedRegion to be the remainder (if any) of parts of\n   * the screen which are modified but outside the requestedRegion.  We also\n   * empty both the requestedRegion and the copyRegion - note that we never\n   * carry over a copyRegion for a future update.\n   */\n\n  REGION_UNION(pScreen, &cl->modifiedRegion, &cl->modifiedRegion,\n               &cl->copyRegion);\n  REGION_SUBTRACT(pScreen, &cl->modifiedRegion, &cl->modifiedRegion,\n                  updateRegion);\n  REGION_SUBTRACT(pScreen, &cl->modifiedRegion, &cl->modifiedRegion,\n                  &updateCopyRegion);\n\n  REGION_EMPTY(pScreen, &cl->requestedRegion);\n  REGION_EMPTY(pScreen, &cl->copyRegion);\n  cl->copyDX = 0;\n  cl->copyDY = 0;\n\n  /*\n   * Now send the update.\n   */\n\n  if (REGION_NUM_RECTS(updateRegion) > rfbCombineRect) {\n    RegionRec combinedUpdateRegion;\n    REGION_INIT(pScreen, &combinedUpdateRegion,\n                REGION_EXTENTS(pScreen, updateRegion), 1);\n    REGION_UNINIT(pScreen, updateRegion);\n    REGION_INIT(pScreen, updateRegion,\n                REGION_EXTENTS(pScreen, &combinedUpdateRegion), 1);\n    REGION_UNINIT(pScreen, &combinedUpdateRegion);\n  }\n\n  if ((updateRegion->extents.x2 > pScreen->width ||\n       updateRegion->extents.y2 > pScreen->height) &&\n      REGION_NUM_RECTS(updateRegion) > 0) {\n    rfbLog(\"WARNING: Framebuffer update at %d,%d with dimensions %dx%d has been clipped to the screen boundaries\\n\",\n           updateRegion->extents.x1, updateRegion->extents.y1,\n           updateRegion->extents.x2 - updateRegion->extents.x1,\n           updateRegion->extents.y2 - updateRegion->extents.y1);\n    ClipToScreen(pScreen, updateRegion);\n  }\n\n  if (cl->compareFB) {\n    if ((cl->ifRegion.extents.x2 > pScreen->width ||\n         cl->ifRegion.extents.y2 > pScreen->height) &&\n        REGION_NUM_RECTS(&cl->ifRegion) > 0)\n      ClipToScreen(pScreen, &cl->ifRegion);\n\n    updateRegion = &cl->ifRegion;\n    emptyUpdateRegion = TRUE;\n    if (rfbInterframeDebug)\n      REGION_INIT(pScreen, &idRegion, NullBox, 0);\n    for (i = 0; i < REGION_NUM_RECTS(&_updateRegion); i++) {\n      int x = REGION_RECTS(&_updateRegion)[i].x1;\n      int y = REGION_RECTS(&_updateRegion)[i].y1;\n      int w = REGION_RECTS(&_updateRegion)[i].x2 - x;\n      int h = REGION_RECTS(&_updateRegion)[i].y2 - y;\n      int pitch = rfbFB.paddedWidthInBytes;\n      int ps = rfbServerFormat.bitsPerPixel / 8;\n      char *src = &rfbFB.pfbMemory[y * pitch + x * ps];\n      char *dst = &cl->compareFB[y * pitch + x * ps];\n      int row, col;\n      int hBlockSize = rfbICEBlockSize == 0 ? w : rfbICEBlockSize;\n      int vBlockSize = rfbICEBlockSize == 0 ? h : rfbICEBlockSize;\n\n      for (row = 0; row < h; row += vBlockSize) {\n        for (col = 0; col < w; col += hBlockSize) {\n\n          Bool different = FALSE;\n          int compareWidth = min(hBlockSize, w - col);\n          int compareHeight = min(vBlockSize, h - row);\n          int rows = compareHeight;\n          char *srcPtr = &src[row * pitch + col * ps];\n          char *dstPtr = &dst[row * pitch + col * ps];\n\n          while (rows--) {\n            if (cl->firstCompare ||\n                memcmp(srcPtr, dstPtr, compareWidth * ps)) {\n              memcpy(dstPtr, srcPtr, compareWidth * ps);\n              different = TRUE;\n            }\n            srcPtr += pitch;\n            dstPtr += pitch;\n          }\n          if (different || rfbInterframeDebug) {\n            RegionRec tmpRegion;\n            BoxRec box;\n            box.x1 = x + col;\n            box.y1 = y + row;\n            box.x2 = box.x1 + compareWidth;\n            box.y2 = box.y1 + compareHeight;\n\n            REGION_INIT(pScreen, &tmpRegion, &box, 1);\n            if (!different && rfbInterframeDebug &&\n                !RECT_IN_REGION(pScreen, &cl->ifRegion, &box)) {\n              int pad = pitch - compareWidth * ps;\n\n              dstPtr = &dst[row * pitch + col * ps];\n              REGION_UNION(pScreen, &idRegion, &idRegion, &tmpRegion);\n              rows = compareHeight;\n\n              while (rows--) {\n                char *endOfRow = &dstPtr[compareWidth * ps];\n                while (dstPtr < endOfRow)\n                  *dstPtr++ ^= 0xFF;\n                dstPtr += pad;\n              }\n            }\n            REGION_UNION(pScreen, &cl->ifRegion, &cl->ifRegion, &tmpRegion);\n            REGION_UNINIT(pScreen, &tmpRegion);\n          }\n          if (!different && rfbProfile) {\n            idmpixels += (double)(compareWidth * compareHeight) / 1000000.;\n            if (!rfbInterframeDebug)\n              mpixels += (double)(compareWidth * compareHeight) / 1000000.;\n          }\n        }\n      }\n    }\n    REGION_UNINIT(pScreen, &_updateRegion);\n    REGION_NULL(pScreen, &_updateRegion);\n    cl->firstCompare = FALSE;\n\n    /* The Windows TurboVNC Viewer (and probably some other VNC viewers as\n       well) will ignore any empty FBUs and stop sending FBURs when it\n       receives one.  If CU is not active, then this causes the viewer to\n       stop receiving updates until something else, such as a mouse cursor\n       change, triggers a new FBUR.  Thus, if the ICE culls all of the\n       pixels in this update, we send a 1-pixel FBU rather than an empty\n       one. */\n    if (REGION_NUM_RECTS(updateRegion) == 0) {\n      BoxRec box;\n      box.x1 = box.y1 = 0;\n      box.x2 = box.y2 = 1;\n      REGION_UNINIT(pScreen, updateRegion);\n      REGION_INIT(pScreen, updateRegion, &box, 1);\n    }\n  }\n\n  if (!rfbSendRTTPing(cl))\n    goto abort;\n\n  cl->rfbFramebufferUpdateMessagesSent++;\n\n  if (cl->preferredEncoding == rfbEncodingCoRRE) {\n    nUpdateRegionRects = 0;\n\n    for (i = 0; i < REGION_NUM_RECTS(updateRegion); i++) {\n      int x = REGION_RECTS(updateRegion)[i].x1;\n      int y = REGION_RECTS(updateRegion)[i].y1;\n      int w = REGION_RECTS(updateRegion)[i].x2 - x;\n      int h = REGION_RECTS(updateRegion)[i].y2 - y;\n      nUpdateRegionRects += (((w - 1) / cl->correMaxWidth + 1) *\n                             ((h - 1) / cl->correMaxHeight + 1));\n    }\n  } else if (cl->preferredEncoding == rfbEncodingZlib) {\n    nUpdateRegionRects = 0;\n\n    for (i = 0; i < REGION_NUM_RECTS(updateRegion); i++) {\n      int x = REGION_RECTS(updateRegion)[i].x1;\n      int y = REGION_RECTS(updateRegion)[i].y1;\n      int w = REGION_RECTS(updateRegion)[i].x2 - x;\n      int h = REGION_RECTS(updateRegion)[i].y2 - y;\n      nUpdateRegionRects += (((h - 1) / (ZLIB_MAX_SIZE(w) / w)) + 1);\n    }\n  } else if (cl->preferredEncoding == rfbEncodingTight) {\n    nUpdateRegionRects = 0;\n\n    for (i = 0; i < REGION_NUM_RECTS(updateRegion); i++) {\n      int x = REGION_RECTS(updateRegion)[i].x1;\n      int y = REGION_RECTS(updateRegion)[i].y1;\n      int w = REGION_RECTS(updateRegion)[i].x2 - x;\n      int h = REGION_RECTS(updateRegion)[i].y2 - y;\n      int n = rfbNumCodedRectsTight(cl, x, y, w, h);\n      if (n == 0) {\n        nUpdateRegionRects = 0xFFFF;\n        break;\n      }\n      nUpdateRegionRects += n;\n    }\n  } else {\n    nUpdateRegionRects = REGION_NUM_RECTS(updateRegion);\n  }\n\n  fu->type = rfbFramebufferUpdate;\n  if (nUpdateRegionRects != 0xFFFF) {\n    fu->nRects = Swap16IfLE(REGION_NUM_RECTS(&updateCopyRegion) +\n                            nUpdateRegionRects +\n                            !!sendCursorShape + !!sendCursorPos);\n  } else {\n    fu->nRects = 0xFFFF;\n  }\n  ublen = sz_rfbFramebufferUpdateMsg;\n\n  cl->captureEnable = TRUE;\n\n  if (sendCursorShape) {\n    cl->cursorWasChanged = FALSE;\n    if (!rfbSendCursorShape(cl, pScreen))\n      goto abort;\n  }\n\n  if (sendCursorPos) {\n    cl->cursorWasMoved = FALSE;\n    if (!rfbSendCursorPos(cl, pScreen))\n      goto abort;\n  }\n\n  if (REGION_NOTEMPTY(pScreen, &updateCopyRegion)) {\n    if (!rfbSendCopyRegion(cl, &updateCopyRegion, dx, dy))\n      goto abort;\n  }\n\n  REGION_UNINIT(pScreen, &updateCopyRegion);\n  REGION_NULL(pScreen, &updateCopyRegion);\n\n  for (i = 0; i < REGION_NUM_RECTS(updateRegion); i++) {\n    int x = REGION_RECTS(updateRegion)[i].x1;\n    int y = REGION_RECTS(updateRegion)[i].y1;\n    int w = REGION_RECTS(updateRegion)[i].x2 - x;\n    int h = REGION_RECTS(updateRegion)[i].y2 - y;\n\n    cl->rfbRawBytesEquivalent += (sz_rfbFramebufferUpdateRectHeader +\n                                 w * (cl->format.bitsPerPixel / 8) * h);\n\n    if (rfbProfile) mpixels += (double)w * (double)h / 1000000.;\n\n    switch (cl->preferredEncoding) {\n      case rfbEncodingRaw:\n        if (!rfbSendRectEncodingRaw(cl, x, y, w, h))\n          goto abort;\n        break;\n      case rfbEncodingRRE:\n        if (!rfbSendRectEncodingRRE(cl, x, y, w, h))\n          goto abort;\n        break;\n      case rfbEncodingCoRRE:\n        if (!rfbSendRectEncodingCoRRE(cl, x, y, w, h))\n          goto abort;\n        break;\n      case rfbEncodingHextile:\n        if (!rfbSendRectEncodingHextile(cl, x, y, w, h))\n          goto abort;\n        break;\n      case rfbEncodingZlib:\n        if (!rfbSendRectEncodingZlib(cl, x, y, w, h))\n          goto abort;\n        break;\n      case rfbEncodingZRLE:\n      case rfbEncodingZYWRLE:\n        if (!rfbSendRectEncodingZRLE(cl, x, y, w, h))\n          goto abort;\n        break;\n      case rfbEncodingTight:\n        if (!rfbSendRectEncodingTight(cl, x, y, w, h))\n          goto abort;\n        break;\n    }\n  }\n\n  if (cl->compareFB) {\n    if (rfbInterframeDebug) {\n      for (i = 0; i < REGION_NUM_RECTS(&idRegion); i++) {\n        int x = REGION_RECTS(&idRegion)[i].x1;\n        int y = REGION_RECTS(&idRegion)[i].y1;\n        int w = REGION_RECTS(&idRegion)[i].x2 - x;\n        int h = REGION_RECTS(&idRegion)[i].y2 - y, rows;\n        int pitch = rfbFB.paddedWidthInBytes;\n        int ps = rfbServerFormat.bitsPerPixel / 8;\n        char *src = &rfbFB.pfbMemory[y * pitch + x * ps];\n        char *dst = &cl->compareFB[y * pitch + x * ps];\n        rows = h;\n        while (rows--) {\n          memcpy(dst, src, w * ps);\n          src += pitch;\n          dst += pitch;\n        }\n      }\n      REGION_UNINIT(pScreen, &idRegion);\n      REGION_NULL(pScreen, &idRegion);\n    }\n    REGION_EMPTY(pScreen, updateRegion);\n  } else {\n    REGION_UNINIT(pScreen, updateRegion);\n    REGION_NULL(pScreen, updateRegion);\n  }\n\n  if (nUpdateRegionRects == 0xFFFF && !rfbSendLastRectMarker(cl))\n    goto abort;\n\n  if (!rfbSendUpdateBuf(cl))\n    goto abort;\n\n  cl->captureEnable = FALSE;\n\n  if (!rfbSendRTTPing(cl))\n    goto abort;\n\n  if (rfbProfile) {\n    tUpdate += gettime() - tUpdateStart;\n    tElapsed = gettime() - tStart;\n    iter++;\n\n    if (tElapsed > 5.) {\n      rfbLog(\"%.2f updates/sec,  %.2f Mpixels/sec,  %.3f Mbits/sec\\n\",\n             (double)iter / tElapsed, mpixels / tElapsed,\n             (double)sendBytes / 125000. / tElapsed);\n      rfbLog(\"Time/update:  Encode = %.3f ms,  Other = %.3f ms\\n\",\n             tUpdate / (double)iter * 1000.,\n             (tElapsed - tUpdate) / (double)iter * 1000.);\n      if (cl->compareFB) {\n        rfbLog(\"Identical Mpixels/sec:  %.2f  (%f %%)\\n\",\n               (double)idmpixels / tElapsed, idmpixels / mpixels * 100.0);\n        idmpixels = 0.;\n      }\n      tUpdate = 0.;\n      iter = 0;\n      mpixels = 0.;\n      sendBytes = 0;\n      tStart = gettime();\n    }\n  }\n\n  if (rfbAutoLosslessRefresh > 0.0 &&\n      (!putImageOnly || REGION_NOTEMPTY(pScreen, &cl->alrEligibleRegion) ||\n       cl->firstUpdate)) {\n    if (putImageOnly)\n      REGION_UNION(pScreen, &cl->alrRegion, &cl->alrRegion,\n                   &cl->alrEligibleRegion);\n    REGION_EMPTY(pScreen, &cl->alrEligibleRegion);\n    cl->alrTimer = TimerSet(cl->alrTimer, 0,\n                            (CARD32)(rfbAutoLosslessRefresh * 1000.0),\n                            alrCallback, cl);\n  }\n\n  rfbUncorkSock(cl->sock);\n  return TRUE;\n\n  abort:\n  if (!REGION_NIL(&updateCopyRegion))\n    REGION_UNINIT(pScreen, &updateCopyRegion);\n  if (rfbInterframeDebug && !REGION_NIL(&idRegion))\n    REGION_UNINIT(pScreen, &idRegion);\n  if (emptyUpdateRegion) {\n    /* Make sure cl hasn't been freed */\n    for (cl2 = rfbClientHead; cl2; cl2 = cl2->next) {\n      if (cl2 == cl) {\n        REGION_EMPTY(pScreen, updateRegion);\n        break;\n      }\n    }\n  } else if (!REGION_NIL(&_updateRegion)) {\n    REGION_UNINIT(pScreen, &_updateRegion);\n  }\n  return FALSE;\n}\n\n\n/*\n * Send the copy region as a string of CopyRect encoded rectangles.\n * The only slightly tricky thing is that we should send the messages in\n * the correct order so that an earlier CopyRect will not corrupt the source\n * of a later one.\n */\n\nstatic Bool rfbSendCopyRegion(rfbClientPtr cl, RegionPtr reg, int dx, int dy)\n{\n  int nrects, nrectsInBand, x_inc, y_inc, thisRect, firstInNextBand;\n  int x, y, w, h;\n  rfbFramebufferUpdateRectHeader rect;\n  rfbCopyRect cr;\n  ScreenPtr pScreen = screenInfo.screens[0];\n\n  nrects = REGION_NUM_RECTS(reg);\n\n  if (dx <= 0)\n    x_inc = 1;\n  else\n    x_inc = -1;\n\n  if (dy <= 0) {\n    thisRect = 0;\n    y_inc = 1;\n  } else {\n    thisRect = nrects - 1;\n    y_inc = -1;\n  }\n\n  /* If the source region intersects the lossy region, then we know that the\n     destination region is about to become lossy, so we add it to the lossy\n     region. */\n  if (rfbAutoLosslessRefresh > 0.0 && alrCopyRect &&\n      REGION_NOTEMPTY(pScreen, reg)) {\n    RegionRec tmpRegion;\n    REGION_INIT(pScreen, &tmpRegion, NullBox, 0);\n    REGION_COPY(pScreen, &tmpRegion, reg);\n    REGION_TRANSLATE(pScreen, &tmpRegion, -dx, -dy);\n    REGION_INTERSECT(pScreen, &tmpRegion, &cl->lossyRegion, &tmpRegion);\n    if (REGION_NOTEMPTY(pScreen, &tmpRegion)) {\n      REGION_UNION(pScreen, &cl->lossyRegion, &cl->lossyRegion, reg);\n      REGION_UNION(pScreen, &cl->alrEligibleRegion, &cl->alrEligibleRegion,\n                   reg);\n    }\n    REGION_UNINIT(pScreen, &tmpRegion);\n  }\n\n  if (reg->extents.x2 > pScreen->width || reg->extents.y2 > pScreen->height)\n    rfbLog(\"WARNING: CopyRect dest at %d,%d with dimensions %dx%d exceeds screen boundaries\\n\",\n           reg->extents.x1, reg->extents.y1,\n           reg->extents.x2 - reg->extents.x1,\n           reg->extents.y2 - reg->extents.y1);\n\n  while (nrects > 0) {\n\n    firstInNextBand = thisRect;\n    nrectsInBand = 0;\n\n    while ((nrects > 0) &&\n           (REGION_RECTS(reg)[firstInNextBand].y1 ==\n            REGION_RECTS(reg)[thisRect].y1)) {\n      firstInNextBand += y_inc;\n      nrects--;\n      nrectsInBand++;\n    }\n\n    if (x_inc != y_inc)\n      thisRect = firstInNextBand - y_inc;\n\n    while (nrectsInBand > 0) {\n      if ((ublen + sz_rfbFramebufferUpdateRectHeader + sz_rfbCopyRect) >\n          UPDATE_BUF_SIZE) {\n        if (!rfbSendUpdateBuf(cl))\n          return FALSE;\n      }\n\n      x = REGION_RECTS(reg)[thisRect].x1;\n      y = REGION_RECTS(reg)[thisRect].y1;\n      w = REGION_RECTS(reg)[thisRect].x2 - x;\n      h = REGION_RECTS(reg)[thisRect].y2 - y;\n\n      if (cl->compareFB) {\n        int pitch = rfbFB.paddedWidthInBytes;\n        int ps = rfbServerFormat.bitsPerPixel / 8, rows = h;\n        char *src = &rfbFB.pfbMemory[y * pitch + x * ps];\n        char *dst = &cl->compareFB[y * pitch + x * ps];\n        while (rows--) {\n          memcpy(dst, src, w * ps);\n          src += pitch;\n          dst += pitch;\n        }\n        src = &rfbFB.pfbMemory[(y - dy) * pitch + (x - dx) * ps];\n        dst = &cl->compareFB[(y - dy) * pitch + (x - dx) * ps];\n        rows = h;\n        while (rows--) {\n          memcpy(dst, src, w * ps);\n          src += pitch;\n          dst += pitch;\n        }\n      }\n\n      rect.r.x = Swap16IfLE(x);\n      rect.r.y = Swap16IfLE(y);\n      rect.r.w = Swap16IfLE(w);\n      rect.r.h = Swap16IfLE(h);\n      rect.encoding = Swap32IfLE(rfbEncodingCopyRect);\n\n      memcpy(&updateBuf[ublen], (char *)&rect,\n             sz_rfbFramebufferUpdateRectHeader);\n      ublen += sz_rfbFramebufferUpdateRectHeader;\n\n      cr.srcX = Swap16IfLE(x - dx);\n      cr.srcY = Swap16IfLE(y - dy);\n\n      memcpy(&updateBuf[ublen], (char *)&cr, sz_rfbCopyRect);\n      ublen += sz_rfbCopyRect;\n\n      cl->rfbRectanglesSent[rfbEncodingCopyRect]++;\n      cl->rfbBytesSent[rfbEncodingCopyRect] +=\n        sz_rfbFramebufferUpdateRectHeader + sz_rfbCopyRect;\n\n      thisRect += x_inc;\n      nrectsInBand--;\n    }\n\n    thisRect = firstInNextBand;\n  }\n\n  return TRUE;\n}\n\n\n/*\n * Send a given rectangle in raw encoding (rfbEncodingRaw).\n */\n\nBool rfbSendRectEncodingRaw(rfbClientPtr cl, int x, int y, int w, int h)\n{\n  rfbFramebufferUpdateRectHeader rect;\n  int nlines;\n  int bytesPerLine = w * (cl->format.bitsPerPixel / 8);\n  char *fbptr =\n    (cl->fb + (rfbFB.paddedWidthInBytes * y) + (x * (rfbFB.bitsPerPixel / 8)));\n\n  /* Flush the buffer to guarantee correct alignment for translateFn(). */\n  if (ublen > 0) {\n    if (!rfbSendUpdateBuf(cl))\n      return FALSE;\n  }\n\n  rect.r.x = Swap16IfLE(x);\n  rect.r.y = Swap16IfLE(y);\n  rect.r.w = Swap16IfLE(w);\n  rect.r.h = Swap16IfLE(h);\n  rect.encoding = Swap32IfLE(rfbEncodingRaw);\n\n  memcpy(&updateBuf[ublen], (char *)&rect, sz_rfbFramebufferUpdateRectHeader);\n  ublen += sz_rfbFramebufferUpdateRectHeader;\n\n  cl->rfbRectanglesSent[rfbEncodingRaw]++;\n  cl->rfbBytesSent[rfbEncodingRaw] +=\n    sz_rfbFramebufferUpdateRectHeader + bytesPerLine * h;\n\n  nlines = (UPDATE_BUF_SIZE - ublen) / bytesPerLine;\n\n  while (TRUE) {\n    if (nlines > h)\n      nlines = h;\n\n    (*cl->translateFn) (cl->translateLookupTable, &rfbServerFormat,\n                        &cl->format, fbptr, &updateBuf[ublen],\n                        rfbFB.paddedWidthInBytes, w, nlines);\n\n    ublen += nlines * bytesPerLine;\n    h -= nlines;\n\n    if (h == 0)         /* rect fitted in buffer, do next one */\n      return TRUE;\n\n    /* buffer full - flush partial rect and do another nlines */\n\n    if (!rfbSendUpdateBuf(cl))\n      return FALSE;\n\n    fbptr += (rfbFB.paddedWidthInBytes * nlines);\n\n    nlines = (UPDATE_BUF_SIZE - ublen) / bytesPerLine;\n    if (nlines == 0) {\n      rfbLog(\"rfbSendRectEncodingRaw: send buffer too small for %d bytes per line\\n\",\n             bytesPerLine);\n      rfbCloseClient(cl);\n      return FALSE;\n    }\n  }\n}\n\n\n/*\n * Send an empty rectangle with encoding field set to value of\n * rfbEncodingLastRect to notify client that this is the last\n * rectangle in framebuffer update (\"LastRect\" extension of RFB\n * protocol).\n */\n\nstatic Bool rfbSendLastRectMarker(rfbClientPtr cl)\n{\n  rfbFramebufferUpdateRectHeader rect;\n\n  if (ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE) {\n    if (!rfbSendUpdateBuf(cl))\n      return FALSE;\n  }\n\n  rect.encoding = Swap32IfLE(rfbEncodingLastRect);\n  rect.r.x = 0;\n  rect.r.y = 0;\n  rect.r.w = 0;\n  rect.r.h = 0;\n\n  memcpy(&updateBuf[ublen], (char *)&rect, sz_rfbFramebufferUpdateRectHeader);\n  ublen += sz_rfbFramebufferUpdateRectHeader;\n\n  cl->rfbLastRectMarkersSent++;\n  cl->rfbLastRectBytesSent += sz_rfbFramebufferUpdateRectHeader;\n\n  return TRUE;\n}\n\n\n/*\n * Send the contents of updateBuf.  Returns 1 if successful, -1 if\n * not (errno should be set).\n */\n\nBool rfbSendUpdateBuf(rfbClientPtr cl)\n{\n  /*\n  int i;\n  for (i = 0; i < ublen; i++) {\n    fprintf(stderr, \"%02x \", ((unsigned char *)updateBuf)[i]);\n  }\n  fprintf(stderr, \"\\n\");\n  */\n\n  if (ublen > 0 && WriteExact(cl, updateBuf, ublen) < 0) {\n    rfbLogPerror(\"rfbSendUpdateBuf: write\");\n    rfbCloseClient(cl);\n    return FALSE;\n  }\n\n  if (cl->captureEnable && cl->captureFD >= 0 && ublen > 0)\n    WriteCapture(cl->captureFD, updateBuf, ublen);\n\n  ublen = 0;\n  return TRUE;\n}\n\n\n/*\n * rfbSendSetColourMapEntries sends a SetColourMapEntries message to the\n * client, using values from the currently installed colormap.\n */\n\nBool rfbSendSetColourMapEntries(rfbClientPtr cl, int firstColour, int nColours)\n{\n  char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];\n  rfbSetColourMapEntriesMsg *scme = (rfbSetColourMapEntriesMsg *)buf;\n  CARD16 *rgb = (CARD16 *)(&buf[sz_rfbSetColourMapEntriesMsg]);\n  EntryPtr pent;\n  int i, len;\n\n  scme->type = rfbSetColourMapEntries;\n\n  scme->firstColour = Swap16IfLE(firstColour);\n  scme->nColours = Swap16IfLE(nColours);\n\n  len = sz_rfbSetColourMapEntriesMsg;\n\n  pent = (EntryPtr)&rfbInstalledColormap->red[firstColour];\n  for (i = 0; i < nColours; i++) {\n    if (pent->fShared) {\n      rgb[i * 3] = Swap16IfLE(pent->co.shco.red->color);\n      rgb[i * 3 + 1] = Swap16IfLE(pent->co.shco.green->color);\n      rgb[i * 3 + 2] = Swap16IfLE(pent->co.shco.blue->color);\n    } else {\n      rgb[i * 3] = Swap16IfLE(pent->co.local.red);\n      rgb[i * 3 + 1] = Swap16IfLE(pent->co.local.green);\n      rgb[i * 3 + 2] = Swap16IfLE(pent->co.local.blue);\n    }\n    pent++;\n  }\n\n  len += nColours * 3 * 2;\n\n  if (WriteExact(cl, buf, len) < 0) {\n    rfbLogPerror(\"rfbSendSetColourMapEntries: write\");\n    rfbCloseClient(cl);\n    return FALSE;\n  }\n\n  if (cl->captureFD >= 0)\n    WriteCapture(cl->captureFD, buf, len);\n\n  return TRUE;\n}\n\n\n/*\n * rfbSendBell sends a Bell message to all the clients.\n */\n\nvoid rfbSendBell(void)\n{\n  rfbClientPtr cl, nextCl;\n  rfbBellMsg b;\n\n  for (cl = rfbClientHead; cl; cl = nextCl) {\n    nextCl = cl->next;\n    if (cl->state != RFB_NORMAL)\n      continue;\n    b.type = rfbBell;\n    if (WriteExact(cl, (char *)&b, sz_rfbBellMsg) < 0) {\n      rfbLogPerror(\"rfbSendBell: write\");\n      rfbCloseClient(cl);\n      continue;\n    }\n    if (cl->captureFD >= 0)\n      WriteCapture(cl->captureFD, (char *)&b, sz_rfbBellMsg);\n  }\n}\n\n\n/*\n * rfbSendServerCutText sends a ServerCutText message to all the clients.\n */\n\nvoid rfbSendServerCutText(char *str, int len)\n{\n  rfbClientPtr cl, nextCl;\n  rfbServerCutTextMsg sct;\n\n  if (rfbViewOnly || rfbAuthDisableCBSend || !str || len <= 0)\n    return;\n\n  for (cl = rfbClientHead; cl; cl = nextCl) {\n    nextCl = cl->next;\n    if (cl->state != RFB_NORMAL || cl->viewOnly)\n      continue;\n    if (cl->cutTextLen == len && cl->cutText && !memcmp(cl->cutText, str, len))\n      continue;\n    if (cl->cutText)\n      free(cl->cutText);\n    cl->cutText = rfbAlloc(len);\n    memcpy(cl->cutText, str, len);\n    cl->cutTextLen = len;\n    memset(&sct, 0, sz_rfbServerCutTextMsg);\n    sct.type = rfbServerCutText;\n    sct.length = Swap32IfLE(len);\n    if (WriteExact(cl, (char *)&sct, sz_rfbServerCutTextMsg) < 0) {\n      rfbLogPerror(\"rfbSendServerCutText: write\");\n      rfbCloseClient(cl);\n      continue;\n    }\n    if (WriteExact(cl, str, len) < 0) {\n      rfbLogPerror(\"rfbSendServerCutText: write\");\n      rfbCloseClient(cl);\n      continue;\n    }\n    if (cl->captureFD >= 0)\n      WriteCapture(cl->captureFD, str, len);\n  }\n  LogMessage(X_DEBUG, \"Sent server clipboard: '%.*s%s' (%d bytes)\\n\",\n             len <= 20 ? len : 20, str, len <= 20 ? \"\" : \"...\", len);\n}\n\n\n/*\n * rfbSendDesktopSize sends a DesktopSize message to a specific client.\n */\n\nBool rfbSendDesktopSize(rfbClientPtr cl)\n{\n  rfbFramebufferUpdateRectHeader rh;\n  rfbFramebufferUpdateMsg fu;\n\n  if (!cl->enableDesktopSize)\n    return TRUE;\n\n  memset(&fu, 0, sz_rfbFramebufferUpdateMsg);\n  fu.type = rfbFramebufferUpdate;\n  fu.nRects = Swap16IfLE(1);\n  if (WriteExact(cl, (char *)&fu, sz_rfbFramebufferUpdateMsg) < 0) {\n    rfbLogPerror(\"rfbSendDesktopSize: write\");\n    rfbCloseClient(cl);\n    return FALSE;\n  }\n\n  rh.encoding = Swap32IfLE(rfbEncodingNewFBSize);\n  rh.r.x = rh.r.y = 0;\n  rh.r.w = Swap16IfLE(rfbFB.width);\n  rh.r.h = Swap16IfLE(rfbFB.height);\n  if (WriteExact(cl, (char *)&rh, sz_rfbFramebufferUpdateRectHeader) < 0) {\n    rfbLogPerror(\"rfbSendDesktopSize: write\");\n    rfbCloseClient(cl);\n    return FALSE;\n  }\n\n  return TRUE;\n}\n\n\n/*\n * rfbSendExtDesktopSize sends an extended desktop size message to a specific\n * client.\n */\n\nBool rfbSendExtDesktopSize(rfbClientPtr cl)\n{\n  rfbFramebufferUpdateRectHeader rh;\n  rfbFramebufferUpdateMsg fu;\n  CARD8 numScreens[4] = { 0, 0, 0, 0 };\n  rfbScreenInfo *iter;\n  BOOL fakeScreen = FALSE;\n\n  if (!cl->enableExtDesktopSize)\n    return TRUE;\n  /* Error messages can only be sent with the EDS extension */\n  if (!cl->enableExtDesktopSize && cl->result != rfbEDSResultSuccess)\n    return TRUE;\n\n  memset(&fu, 0, sz_rfbFramebufferUpdateMsg);\n  fu.type = rfbFramebufferUpdate;\n  fu.nRects = Swap16IfLE(1);\n  if (WriteExact(cl, (char *)&fu, sz_rfbFramebufferUpdateMsg) < 0) {\n    rfbLogPerror(\"rfbSendExtDesktopSize: write\");\n    rfbCloseClient(cl);\n    return FALSE;\n  }\n\n  /* Send the ExtendedDesktopSize message, if the client supports it.\n     The TigerVNC Viewer, in particular, requires this, or it won't\n     enable remote desktop resize. */\n  rh.encoding = Swap32IfLE(rfbEncodingExtendedDesktopSize);\n  rh.r.x = Swap16IfLE(cl->reason);\n  rh.r.y = Swap16IfLE(cl->result);\n  rh.r.w = Swap16IfLE(rfbFB.width);\n  rh.r.h = Swap16IfLE(rfbFB.height);\n  if (WriteExact(cl, (char *)&rh, sz_rfbFramebufferUpdateRectHeader) < 0) {\n    rfbLogPerror(\"rfbSendExtDesktopSize: write\");\n    rfbCloseClient(cl);\n    return FALSE;\n  }\n\n  xorg_list_for_each_entry(iter, &rfbScreens, entry) {\n    if (iter->output->crtc && iter->output->crtc->mode)\n      numScreens[0]++;\n  }\n  if (numScreens[0] < 1) {\n    numScreens[0] = 1;\n    fakeScreen = TRUE;\n  }\n\n  if (WriteExact(cl, (char *)numScreens, 4) < 0) {\n    rfbLogPerror(\"rfbSendExtDesktopSize: write\");\n    rfbCloseClient(cl);\n    return FALSE;\n  }\n\n  if (fakeScreen) {\n    rfbScreenInfo screen = *xorg_list_first_entry(&rfbScreens, rfbScreenInfo,\n                                                  entry);\n    screen.s.id = Swap32IfLE(screen.s.id);\n    screen.s.x = screen.s.y = 0;\n    screen.s.w = Swap16IfLE(rfbFB.width);\n    screen.s.h = Swap16IfLE(rfbFB.height);\n    screen.s.flags = Swap32IfLE(screen.s.flags);\n    if (WriteExact(cl, (char *)&screen.s, sz_rfbScreenDesc) < 0) {\n      rfbLogPerror(\"rfbSendExtDesktopSize: write\");\n      rfbCloseClient(cl);\n      return FALSE;\n    }\n  } else {\n    xorg_list_for_each_entry(iter, &rfbScreens, entry) {\n      rfbScreenInfo screen = *iter;\n\n      if (screen.output->crtc && screen.output->crtc->mode) {\n        screen.s.id = Swap32IfLE(screen.s.id);\n        screen.s.x = Swap16IfLE(screen.s.x);\n        screen.s.y = Swap16IfLE(screen.s.y);\n        screen.s.w = Swap16IfLE(screen.s.w);\n        screen.s.h = Swap16IfLE(screen.s.h);\n        screen.s.flags = Swap32IfLE(screen.s.flags);\n        if (WriteExact(cl, (char *)&screen.s, sz_rfbScreenDesc) < 0) {\n          rfbLogPerror(\"rfbSendExtDesktopSize: write\");\n          rfbCloseClient(cl);\n          return FALSE;\n        }\n      }\n    }\n  }\n\n  return TRUE;\n}\n\n\n/*****************************************************************************\n *\n * UDP can be used for keyboard and pointer events when the underlying\n * network is highly reliable.  This is really here to support ORL's\n * videotile, whose TCP implementation doesn't like sending lots of small\n * packets (such as 100s of pen readings per second!).\n */\n\nvoid rfbNewUDPConnection(int sock)\n{\n  if (write(sock, &ptrAcceleration, 1) < 0)\n    rfbLogPerror(\"rfbNewUDPConnection: write\");\n}\n\n/*\n * Because UDP is a message based service, we can't read the first byte and\n * then the rest of the packet separately like we do with TCP.  We will always\n * get a whole packet delivered in one go, so we ask read() for the maximum\n * number of bytes we can possibly get.\n */\n\nvoid rfbProcessUDPInput(int sock)\n{\n  int n;\n  rfbClientToServerMsg msg;\n\n  if ((n = read(sock, (char *)&msg, sizeof(msg))) <= 0) {\n    if (n < 0)\n      rfbLogPerror(\"rfbProcessUDPInput: read\");\n    rfbDisconnectUDPSock();\n    return;\n  }\n\n  switch (msg.type) {\n    case rfbKeyEvent:\n      if (n != sz_rfbKeyEventMsg) {\n        rfbLog(\"rfbProcessUDPInput: key event incorrect length\\n\");\n        rfbDisconnectUDPSock();\n        return;\n      }\n      if (!rfbViewOnly)\n        KeyEvent((KeySym)Swap32IfLE(msg.ke.key), msg.ke.down);\n      break;\n\n    case rfbPointerEvent:\n      if (n != sz_rfbPointerEventMsg) {\n        rfbLog(\"rfbProcessUDPInput: ptr event incorrect length\\n\");\n        rfbDisconnectUDPSock();\n        return;\n      }\n      if (!rfbViewOnly)\n        PtrAddEvent(msg.pe.buttonMask, Swap16IfLE(msg.pe.x),\n                    Swap16IfLE(msg.pe.y), 0);\n      break;\n\n    default:\n      rfbLog(\"rfbProcessUDPInput: unknown message type %d\\n\", msg.type);\n      rfbDisconnectUDPSock();\n  }\n}\n"], "filenames": ["unix/Xvnc/programs/Xserver/hw/vnc/auth.c", "unix/Xvnc/programs/Xserver/hw/vnc/rfbserver.c"], "buggy_code_start_loc": [396, 1317], "buggy_code_end_loc": [397, 1323], "fixing_code_start_loc": [396, 1317], "fixing_code_end_loc": [397, 1326], "type": "CWE-787", "message": "TurboVNC server code contains stack buffer overflow vulnerability in commit prior to cea98166008301e614e0d36776bf9435a536136e. This could possibly result into remote code execution, since stack frame is not protected with stack canary. This attack appear to be exploitable via network connectivity. To exploit this vulnerability authorization on server is required. These issues have been fixed in commit cea98166008301e614e0d36776bf9435a536136e.", "other": {"cve": {"id": "CVE-2019-15683", "sourceIdentifier": "vulnerability@kaspersky.com", "published": "2019-10-29T19:15:18.203", "lastModified": "2019-11-05T16:46:51.467", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TurboVNC server code contains stack buffer overflow vulnerability in commit prior to cea98166008301e614e0d36776bf9435a536136e. This could possibly result into remote code execution, since stack frame is not protected with stack canary. This attack appear to be exploitable via network connectivity. To exploit this vulnerability authorization on server is required. These issues have been fixed in commit cea98166008301e614e0d36776bf9435a536136e."}, {"lang": "es", "value": "El c\u00f3digo del servidor TurboVNC contiene una vulnerabilidad de desbordamiento del b\u00fafer de la pila en el commit anterior a cea98166008301e614e0d36776bf9435a536136e. Esto podr\u00eda resultar en la ejecuci\u00f3n de c\u00f3digo remota, ya que la trama de la pila no est\u00e1 protegida con una pila canary. Este ataque parece ser explotable por medio de la conectividad de la red. Para explotar esta vulnerabilidad es requerida una autorizaci\u00f3n en el servidor. Estos problemas han sido solucionados en el commit cea98166008301e614e0d36776bf9435a536136e."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "vulnerability@kaspersky.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-121"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:turbovnc:turbovnc:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.3", "matchCriteriaId": "C369DEF2-15BE-46B1-A0A1-79C073B81192"}]}]}], "references": [{"url": "https://github.com/TurboVNC/turbovnc/commit/cea98166008301e614e0d36776bf9435a536136e", "source": "vulnerability@kaspersky.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/TurboVNC/turbovnc/commit/cea98166008301e614e0d36776bf9435a536136e"}}