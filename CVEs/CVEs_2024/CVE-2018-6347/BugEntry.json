{"buggy_code": ["/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n#include <proxygen/lib/http/codec/HTTP2Codec.h>\n#include <proxygen/lib/http/codec/HTTP2Constants.h>\n#include <proxygen/lib/http/codec/CodecUtil.h>\n#include <proxygen/lib/utils/Logging.h>\n#include <proxygen/lib/utils/Base64.h>\n\n#include <folly/Conv.h>\n#include <folly/Random.h>\n#include <folly/ThreadLocal.h>\n#include <folly/io/Cursor.h>\n#include <folly/tracing/ScopedTraceSection.h>\n#include <type_traits>\n\nusing namespace proxygen::compress;\nusing namespace folly::io;\nusing namespace folly;\n\nusing std::string;\n\nnamespace {\nstd::string base64url_encode(ByteRange range) {\n  return proxygen::Base64::urlEncode(range);\n}\n\nstd::string base64url_decode(const std::string& str) {\n  return proxygen::Base64::urlDecode(str);\n}\n\n}\n\nnamespace proxygen {\n\n\nHTTP2Codec::HTTP2Codec(TransportDirection direction)\n    : HTTPParallelCodec(direction),\n      headerCodec_(direction),\n      frameState_(direction == TransportDirection::DOWNSTREAM\n                  ? FrameState::UPSTREAM_CONNECTION_PREFACE\n                  : FrameState::DOWNSTREAM_CONNECTION_PREFACE) {\n\n  const auto maxHeaderListSize = egressSettings_.getSetting(\n    SettingsId::MAX_HEADER_LIST_SIZE);\n  if (maxHeaderListSize) {\n    headerCodec_.setMaxUncompressed(maxHeaderListSize->value);\n  }\n\n  VLOG(4) << \"creating \" << getTransportDirectionString(direction)\n          << \" HTTP/2 codec\";\n}\n\nHTTP2Codec::~HTTP2Codec() {}\n\n// HTTPCodec API\n\nsize_t HTTP2Codec::onIngress(const folly::IOBuf& buf) {\n  // TODO: ensure only 1 parse at a time on stack.\n  FOLLY_SCOPED_TRACE_SECTION(\"HTTP2Codec - onIngress\");\n\n  Cursor cursor(&buf);\n  size_t parsed = 0;\n  ErrorCode connError = ErrorCode::NO_ERROR;\n  for (auto bufLen = cursor.totalLength();\n       connError == ErrorCode::NO_ERROR;\n       bufLen = cursor.totalLength()) {\n    if (frameState_ == FrameState::UPSTREAM_CONNECTION_PREFACE) {\n      if (bufLen >= http2::kConnectionPreface.length()) {\n        auto test = cursor.readFixedString(http2::kConnectionPreface.length());\n        parsed += http2::kConnectionPreface.length();\n        if (test != http2::kConnectionPreface) {\n          goawayErrorMessage_ = \"missing connection preface\";\n          VLOG(4) << goawayErrorMessage_;\n          connError = ErrorCode::PROTOCOL_ERROR;\n        }\n        frameState_ = FrameState::FRAME_HEADER;\n      } else {\n        break;\n      }\n    } else if (frameState_ == FrameState::FRAME_HEADER ||\n               frameState_ == FrameState::DOWNSTREAM_CONNECTION_PREFACE) {\n      // Waiting to parse the common frame header\n      if (bufLen >= http2::kFrameHeaderSize) {\n        connError = parseFrameHeader(cursor, curHeader_);\n        parsed += http2::kFrameHeaderSize;\n        if (frameState_ == FrameState::DOWNSTREAM_CONNECTION_PREFACE &&\n            curHeader_.type != http2::FrameType::SETTINGS) {\n          goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: got invalid connection preface frame type=\",\n              getFrameTypeString(curHeader_.type), \"(\", curHeader_.type, \")\",\n              \" for streamID=\", curHeader_.stream);\n          VLOG(4) << goawayErrorMessage_;\n          connError = ErrorCode::PROTOCOL_ERROR;\n        }\n        if (curHeader_.length > maxRecvFrameSize()) {\n          VLOG(4) << \"Excessively large frame len=\" << curHeader_.length;\n          connError = ErrorCode::FRAME_SIZE_ERROR;\n        }\n\n        if (callback_) {\n          callback_->onFrameHeader(\n            curHeader_.stream,\n            curHeader_.flags,\n            curHeader_.length,\n            static_cast<uint8_t>(curHeader_.type));\n        }\n\n        frameState_ = (curHeader_.type == http2::FrameType::DATA) ?\n          FrameState::DATA_FRAME_DATA : FrameState::FRAME_DATA;\n        pendingDataFrameBytes_ = curHeader_.length;\n        pendingDataFramePaddingBytes_ = 0;\n#ifndef NDEBUG\n        receivedFrameCount_++;\n#endif\n      } else {\n        break;\n      }\n    } else if (frameState_ == FrameState::DATA_FRAME_DATA && bufLen > 0 &&\n               (bufLen < curHeader_.length ||\n                pendingDataFrameBytes_ < curHeader_.length)) {\n      // FrameState::DATA_FRAME_DATA with partial data only\n      size_t dataParsed = 0;\n      connError = parseDataFrameData(cursor, bufLen, dataParsed);\n      if (dataParsed == 0 && pendingDataFrameBytes_ > 0) {\n        // We received only the padding byte, we will wait for more\n        break;\n      } else {\n        parsed += dataParsed;\n        if (pendingDataFrameBytes_ == 0) {\n          frameState_ = FrameState::FRAME_HEADER;\n        }\n      }\n    } else { // FrameState::FRAME_DATA\n             // or FrameState::DATA_FRAME_DATA with all data available\n      // Already parsed the common frame header\n      const auto frameLen = curHeader_.length;\n      if (bufLen >= frameLen) {\n        connError = parseFrame(cursor);\n        parsed += curHeader_.length;\n        frameState_ = FrameState::FRAME_HEADER;\n      } else {\n        break;\n      }\n    }\n  }\n  checkConnectionError(connError, &buf);\n  return parsed;\n}\n\nErrorCode HTTP2Codec::parseFrame(folly::io::Cursor& cursor) {\n  FOLLY_SCOPED_TRACE_SECTION(\"HTTP2Codec - parseFrame\");\n  if (expectedContinuationStream_ != 0 &&\n       (curHeader_.type != http2::FrameType::CONTINUATION ||\n        expectedContinuationStream_ != curHeader_.stream)) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: while expected CONTINUATION with stream=\",\n        expectedContinuationStream_, \", received streamID=\", curHeader_.stream,\n        \" of type=\", getFrameTypeString(curHeader_.type));\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  if (expectedContinuationStream_ == 0 &&\n      curHeader_.type == http2::FrameType::CONTINUATION) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: unexpected CONTINUATION received with streamID=\",\n        curHeader_.stream);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  if (frameAffectsCompression(curHeader_.type) &&\n      curHeaderBlock_.chainLength() + curHeader_.length >\n      egressSettings_.getSetting(SettingsId::MAX_HEADER_LIST_SIZE, 0)) {\n    // this may be off by up to the padding length (max 255), but\n    // these numbers are already so generous, and we're comparing the\n    // max-uncompressed to the actual compressed size.  Let's fail\n    // before buffering.\n\n    // TODO(t6513634): it would be nicer to stream-process this header\n    // block to keep the connection state consistent without consuming\n    // memory, and fail just the request per the HTTP/2 spec (section\n    // 10.3)\n    goawayErrorMessage_ = folly::to<string>(\n      \"Failing connection due to excessively large headers\");\n    LOG(ERROR) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n\n  expectedContinuationStream_ =\n    (frameAffectsCompression(curHeader_.type) &&\n     !(curHeader_.flags & http2::END_HEADERS)) ? curHeader_.stream : 0;\n\n  switch (curHeader_.type) {\n    case http2::FrameType::DATA:\n      return parseAllData(cursor);\n    case http2::FrameType::HEADERS:\n      return parseHeaders(cursor);\n    case http2::FrameType::PRIORITY:\n      return parsePriority(cursor);\n    case http2::FrameType::RST_STREAM:\n      return parseRstStream(cursor);\n    case http2::FrameType::SETTINGS:\n      return parseSettings(cursor);\n    case http2::FrameType::PUSH_PROMISE:\n      return parsePushPromise(cursor);\n    case http2::FrameType::EX_HEADERS:\n      if (ingressSettings_.getSetting(SettingsId::ENABLE_EX_HEADERS, 0)) {\n        return parseExHeaders(cursor);\n      } else {\n        VLOG(2) << \"EX_HEADERS not enabled, ignoring the frame\";\n        break;\n      }\n    case http2::FrameType::PING:\n      return parsePing(cursor);\n    case http2::FrameType::GOAWAY:\n      return parseGoaway(cursor);\n    case http2::FrameType::WINDOW_UPDATE:\n      return parseWindowUpdate(cursor);\n    case http2::FrameType::CONTINUATION:\n      return parseContinuation(cursor);\n    case http2::FrameType::ALTSVC:\n      // fall through, unimplemented\n      break;\n    case http2::FrameType::CERTIFICATE_REQUEST:\n      return parseCertificateRequest(cursor);\n    case http2::FrameType::CERTIFICATE:\n      return parseCertificate(cursor);\n    default:\n      // Implementations MUST ignore and discard any frame that has a\n      // type that is unknown\n      break;\n  }\n\n  // Landing here means unknown, unimplemented or ignored frame.\n  VLOG(2) << \"Skipping frame (type=\" << (uint8_t)curHeader_.type << \")\";\n  cursor.skip(curHeader_.length);\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::handleEndStream() {\n  if (curHeader_.type != http2::FrameType::HEADERS &&\n      curHeader_.type != http2::FrameType::EX_HEADERS &&\n      curHeader_.type != http2::FrameType::CONTINUATION &&\n      curHeader_.type != http2::FrameType::DATA) {\n    return ErrorCode::NO_ERROR;\n  }\n\n  // do we need to handle case where this stream has already aborted via\n  // another callback (onHeadersComplete/onBody)?\n  pendingEndStreamHandling_ |= (curHeader_.flags & http2::END_STREAM);\n\n  // with a websocket upgrade, we need to send message complete cb to\n  // mirror h1x codec's behavior. when the stream closes, we need to\n  // send another callback to clean up the stream's resources.\n  if (ingressWebsocketUpgrade_) {\n    ingressWebsocketUpgrade_ = false;\n    deliverCallbackIfAllowed(&HTTPCodec::Callback::onMessageComplete,\n                             \"onMessageComplete\", curHeader_.stream, true);\n  }\n\n  if (pendingEndStreamHandling_ && expectedContinuationStream_ == 0) {\n    pendingEndStreamHandling_ = false;\n    deliverCallbackIfAllowed(&HTTPCodec::Callback::onMessageComplete,\n                             \"onMessageComplete\", curHeader_.stream, false);\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseAllData(Cursor& cursor) {\n  std::unique_ptr<IOBuf> outData;\n  uint16_t padding = 0;\n  VLOG(10) << \"parsing all frame DATA bytes for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  auto ret = http2::parseData(cursor, curHeader_, outData, padding);\n  RETURN_IF_ERROR(ret);\n\n  if (callback_ && (padding > 0 || (outData && !outData->empty()))) {\n    if (!outData) {\n      outData = std::make_unique<IOBuf>();\n    }\n    deliverCallbackIfAllowed(&HTTPCodec::Callback::onBody, \"onBody\",\n                             curHeader_.stream, std::move(outData), padding);\n  }\n  return handleEndStream();\n}\n\nErrorCode HTTP2Codec::parseDataFrameData(Cursor& cursor,\n                                         size_t bufLen,\n                                         size_t& parsed) {\n  FOLLY_SCOPED_TRACE_SECTION(\"HTTP2Codec - parseDataFrameData\");\n  if (bufLen == 0) {\n    VLOG(10) << \"No data to parse\";\n    return ErrorCode::NO_ERROR;\n  }\n\n  std::unique_ptr<IOBuf> outData;\n  uint16_t padding = 0;\n  VLOG(10) << \"parsing DATA frame data for stream=\" << curHeader_.stream <<\n    \" frame data length=\" << curHeader_.length << \" pendingDataFrameBytes_=\" <<\n    pendingDataFrameBytes_ << \" pendingDataFramePaddingBytes_=\" <<\n    pendingDataFramePaddingBytes_ << \" bufLen=\" << bufLen <<\n    \" parsed=\" << parsed;\n  // Parse the padding information only the first time\n  if (pendingDataFrameBytes_ == curHeader_.length &&\n    pendingDataFramePaddingBytes_ == 0) {\n    if (frameHasPadding(curHeader_) && bufLen == 1) {\n      // We need to wait for more bytes otherwise we won't be able to pass\n      // the correct padding to the first onBody call\n      return ErrorCode::NO_ERROR;\n    }\n    const auto ret = http2::parseDataBegin(cursor, curHeader_, parsed, padding);\n    RETURN_IF_ERROR(ret);\n    if (padding > 0) {\n      pendingDataFramePaddingBytes_ = padding - 1;\n      pendingDataFrameBytes_--;\n      bufLen--;\n      parsed++;\n    }\n    VLOG(10) << \"out padding=\" << padding << \" pendingDataFrameBytes_=\" <<\n      pendingDataFrameBytes_ << \" pendingDataFramePaddingBytes_=\" <<\n      pendingDataFramePaddingBytes_ << \" bufLen=\" << bufLen <<\n      \" parsed=\" << parsed;\n  }\n  if (bufLen > 0) {\n    // Check if we have application data to parse\n    if (pendingDataFrameBytes_ > pendingDataFramePaddingBytes_) {\n      const size_t pendingAppData =\n        pendingDataFrameBytes_ - pendingDataFramePaddingBytes_;\n      const size_t toClone = std::min(pendingAppData, bufLen);\n      cursor.clone(outData, toClone);\n      bufLen -= toClone;\n      pendingDataFrameBytes_ -= toClone;\n      parsed += toClone;\n      VLOG(10) << \"parsed some app data, pendingDataFrameBytes_=\" <<\n        pendingDataFrameBytes_ << \" pendingDataFramePaddingBytes_=\" <<\n        pendingDataFramePaddingBytes_ << \" bufLen=\" << bufLen <<\n        \" parsed=\" << parsed;\n    }\n    // Check if we have padding bytes to parse\n    if (bufLen > 0 && pendingDataFramePaddingBytes_ > 0) {\n      size_t toSkip = 0;\n      auto ret = http2::parseDataEnd(cursor, bufLen,\n                                     pendingDataFramePaddingBytes_, toSkip);\n      RETURN_IF_ERROR(ret);\n      pendingDataFrameBytes_ -= toSkip;\n      pendingDataFramePaddingBytes_ -= toSkip;\n      parsed += toSkip;\n      VLOG(10) << \"parsed some padding, pendingDataFrameBytes_=\" <<\n        pendingDataFrameBytes_ << \" pendingDataFramePaddingBytes_=\" <<\n        pendingDataFramePaddingBytes_ << \" bufLen=\" << bufLen <<\n        \" parsed=\" << parsed;\n    }\n  }\n\n  if (callback_ && (padding > 0 || (outData && !outData->empty()))) {\n    if (!outData) {\n      outData = std::make_unique<IOBuf>();\n    }\n    deliverCallbackIfAllowed(&HTTPCodec::Callback::onBody, \"onBody\",\n                             curHeader_.stream, std::move(outData), padding);\n  }\n  return (pendingDataFrameBytes_ > 0) ? ErrorCode::NO_ERROR : handleEndStream();\n}\n\n\nErrorCode HTTP2Codec::parseHeaders(Cursor& cursor) {\n  FOLLY_SCOPED_TRACE_SECTION(\"HTTP2Codec - parseHeaders\");\n  folly::Optional<http2::PriorityUpdate> priority;\n  std::unique_ptr<IOBuf> headerBuf;\n  VLOG(4) << \"parsing HEADERS frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  auto err = http2::parseHeaders(cursor, curHeader_, priority, headerBuf);\n  RETURN_IF_ERROR(err);\n  if (transportDirection_ == TransportDirection::DOWNSTREAM) {\n    RETURN_IF_ERROR(\n        checkNewStream(curHeader_.stream, true /* trailersAllowed */));\n  }\n  err = parseHeadersImpl(cursor, std::move(headerBuf), priority, folly::none,\n                         folly::none);\n  return err;\n}\n\nErrorCode HTTP2Codec::parseExHeaders(Cursor& cursor) {\n  FOLLY_SCOPED_TRACE_SECTION(\"HTTP2Codec - parseExHeaders\");\n  HTTPCodec::ExAttributes exAttributes;\n  folly::Optional<http2::PriorityUpdate> priority;\n  std::unique_ptr<IOBuf> headerBuf;\n  VLOG(4) << \"parsing ExHEADERS frame for stream=\" << curHeader_.stream\n          << \" length=\" << curHeader_.length;\n  auto err = http2::parseExHeaders(\n      cursor, curHeader_, exAttributes, priority, headerBuf);\n  RETURN_IF_ERROR(err);\n  if (isRequest(curHeader_.stream)) {\n    RETURN_IF_ERROR(\n        checkNewStream(curHeader_.stream, false /* trailersAllowed */));\n  }\n  return parseHeadersImpl(cursor, std::move(headerBuf), priority, folly::none,\n                          exAttributes);\n}\n\nErrorCode HTTP2Codec::parseContinuation(Cursor& cursor) {\n  std::unique_ptr<IOBuf> headerBuf;\n  VLOG(4) << \"parsing CONTINUATION frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  auto err = http2::parseContinuation(cursor, curHeader_, headerBuf);\n  RETURN_IF_ERROR(err);\n  err = parseHeadersImpl(cursor, std::move(headerBuf),\n                         folly::none, folly::none, folly::none);\n  return err;\n}\n\nErrorCode HTTP2Codec::parseHeadersImpl(\n    Cursor& /*cursor*/,\n    std::unique_ptr<IOBuf> headerBuf,\n    const folly::Optional<http2::PriorityUpdate>& priority,\n    const folly::Optional<uint32_t>& promisedStream,\n    const folly::Optional<ExAttributes>& exAttributes) {\n  curHeaderBlock_.append(std::move(headerBuf));\n  std::unique_ptr<HTTPMessage> msg;\n  if (curHeader_.flags & http2::END_HEADERS) {\n    auto errorCode =\n        parseHeadersDecodeFrames(priority, promisedStream, exAttributes, msg);\n    if (errorCode.hasValue()) {\n      return errorCode.value();\n    }\n  }\n\n  // if we're not parsing CONTINUATION, then it's start of new header block\n  if (curHeader_.type != http2::FrameType::CONTINUATION) {\n    headerBlockFrameType_ = curHeader_.type;\n  }\n\n  // Report back what we've parsed\n  if (callback_) {\n    auto concurError = parseHeadersCheckConcurrentStreams(priority);\n    if (concurError.hasValue()) {\n      return concurError.value();\n    }\n    uint32_t headersCompleteStream = curHeader_.stream;\n    bool trailers = parsingTrailers();\n    bool allHeaderFramesReceived =\n        (curHeader_.flags & http2::END_HEADERS) &&\n        (headerBlockFrameType_ == http2::FrameType::HEADERS);\n    if (allHeaderFramesReceived && !trailers) {\n      // Only deliver onMessageBegin once per stream.\n      // For responses with CONTINUATION, this will be delayed until\n      // the frame with the END_HEADERS flag set.\n      if (!deliverCallbackIfAllowed(&HTTPCodec::Callback::onMessageBegin,\n                                    \"onMessageBegin\",\n                                    curHeader_.stream,\n                                    msg.get())) {\n        return handleEndStream();\n      }\n   } else if (curHeader_.type == http2::FrameType::EX_HEADERS) {\n      if (!deliverCallbackIfAllowed(&HTTPCodec::Callback::onExMessageBegin,\n                                    \"onExMessageBegin\",\n                                    curHeader_.stream,\n                                    exAttributes->controlStream,\n                                    exAttributes->unidirectional,\n                                    msg.get())) {\n        return handleEndStream();\n      }\n    } else if (curHeader_.type == http2::FrameType::PUSH_PROMISE) {\n      DCHECK(promisedStream);\n      if (!deliverCallbackIfAllowed(&HTTPCodec::Callback::onPushMessageBegin,\n                                    \"onPushMessageBegin\", *promisedStream,\n                                    curHeader_.stream, msg.get())) {\n        return handleEndStream();\n      }\n      headersCompleteStream = *promisedStream;\n    }\n\n    if (curHeader_.flags & http2::END_HEADERS && msg) {\n      if (!(curHeader_.flags & http2::END_STREAM)) {\n        // If it there are DATA frames coming, consider it chunked\n        msg->setIsChunked(true);\n      }\n      if (trailers) {\n        VLOG(4) << \"Trailers complete for streamId=\" << headersCompleteStream\n                << \" direction=\" << transportDirection_;\n        auto trailerHeaders =\n            std::make_unique<HTTPHeaders>(msg->extractHeaders());\n        msg.reset();\n        callback_->onTrailersComplete(headersCompleteStream,\n                                      std::move(trailerHeaders));\n      } else {\n        callback_->onHeadersComplete(headersCompleteStream, std::move(msg));\n      }\n    }\n    return handleEndStream();\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nfolly::Optional<ErrorCode> HTTP2Codec::parseHeadersDecodeFrames(\n    const folly::Optional<http2::PriorityUpdate>& priority,\n    const folly::Optional<uint32_t>& promisedStream,\n    const folly::Optional<ExAttributes>& exAttributes,\n    std::unique_ptr<HTTPMessage>& msg) {\n  // decompress headers\n  Cursor headerCursor(curHeaderBlock_.front());\n  bool isReq = false;\n  if (promisedStream) {\n    isReq = true;\n  } else if (exAttributes) {\n    isReq = isRequest(curHeader_.stream);\n  } else {\n    isReq = transportDirection_ == TransportDirection::DOWNSTREAM;\n  }\n\n  // Validate circular dependencies.\n  if (priority && (curHeader_.stream == priority->streamDependency)) {\n    streamError(\n        folly::to<string>(\"Circular dependency for txn=\", curHeader_.stream),\n        ErrorCode::PROTOCOL_ERROR,\n        curHeader_.type == http2::FrameType::HEADERS);\n    return ErrorCode::NO_ERROR;\n  }\n\n  decodeInfo_.init(isReq, parsingDownstreamTrailers_);\n  if (priority) {\n    decodeInfo_.msg->setHTTP2Priority(\n        std::make_tuple(priority->streamDependency,\n                        priority->exclusive,\n                        priority->weight));\n  }\n\n  headerCodec_.decodeStreaming(\n      headerCursor, curHeaderBlock_.chainLength(), this);\n  msg = std::move(decodeInfo_.msg);\n  // Saving this in case we need to log it on error\n  auto g = folly::makeGuard([this] { curHeaderBlock_.move(); });\n  // Check decoding error\n  if (decodeInfo_.decodeError != HPACK::DecodeError::NONE) {\n    static const std::string decodeErrorMessage =\n        \"Failed decoding header block for stream=\";\n    // Avoid logging header blocks that have failed decoding due to being\n    // excessively large.\n    if (decodeInfo_.decodeError != HPACK::DecodeError::HEADERS_TOO_LARGE) {\n      LOG(ERROR) << decodeErrorMessage << curHeader_.stream\n                 << \" header block=\";\n      VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);\n    } else {\n      LOG(ERROR) << decodeErrorMessage << curHeader_.stream;\n    }\n\n    if (msg) {\n      // print the partial message\n      msg->dumpMessage(3);\n    }\n    return ErrorCode::COMPRESSION_ERROR;\n  }\n\n  // Check parsing error\n  if (decodeInfo_.parsingError != \"\") {\n    LOG(ERROR) << \"Failed parsing header list for stream=\" << curHeader_.stream\n               << \", error=\" << decodeInfo_.parsingError << \", header block=\";\n    VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);\n    HTTPException err(HTTPException::Direction::INGRESS,\n                      folly::to<std::string>(\"HTTP2Codec stream error: \",\n                                             \"stream=\",\n                                             curHeader_.stream,\n                                             \" status=\",\n                                             400,\n                                             \" error: \",\n                                             decodeInfo_.parsingError));\n    err.setHttpStatusCode(400);\n    callback_->onError(curHeader_.stream, err, true);\n    return ErrorCode::NO_ERROR;\n  }\n\n  return folly::Optional<ErrorCode>();\n}\n\nfolly::Optional<ErrorCode> HTTP2Codec::parseHeadersCheckConcurrentStreams(\n    const folly::Optional<http2::PriorityUpdate>& priority) {\n  if (curHeader_.type == http2::FrameType::HEADERS ||\n      curHeader_.type == http2::FrameType::EX_HEADERS) {\n    if (curHeader_.flags & http2::PRIORITY) {\n      DCHECK(priority);\n      // callback_->onPriority(priority.get());\n    }\n\n    // callback checks total number of streams is smaller than settings max\n    if (callback_->numIncomingStreams() >=\n        egressSettings_.getSetting(SettingsId::MAX_CONCURRENT_STREAMS,\n                                   std::numeric_limits<int32_t>::max())) {\n      streamError(folly::to<string>(\"Exceeded max_concurrent_streams\"),\n                  ErrorCode::REFUSED_STREAM, true);\n      return ErrorCode::NO_ERROR;\n    }\n  }\n  return folly::Optional<ErrorCode>();\n}\n\nvoid HTTP2Codec::onHeader(const folly::fbstring& name,\n                          const folly::fbstring& value) {\n  if (decodeInfo_.onHeader(name, value)) {\n    if (name == \"user-agent\" && userAgent_.empty()) {\n      userAgent_ = value.toStdString();\n    }\n  } else {\n    VLOG(4) << \"dir=\" << uint32_t(transportDirection_) <<\n      decodeInfo_.parsingError << \" codec=\" << headerCodec_;\n  }\n}\n\nvoid HTTP2Codec::onHeadersComplete(HTTPHeaderSize decodedSize,\n                                   bool /*acknowledge*/) {\n  decodeInfo_.onHeadersComplete(decodedSize);\n  decodeInfo_.msg->setAdvancedProtocolString(http2::kProtocolString);\n\n  HTTPMessage* msg = decodeInfo_.msg.get();\n  HTTPRequestVerifier& verifier = decodeInfo_.verifier;\n  if ((transportDirection_ == TransportDirection::DOWNSTREAM) &&\n      verifier.hasUpgradeProtocol() &&\n      (*msg->getUpgradeProtocol() == headers::kWebsocketString) &&\n      msg->getMethod() == HTTPMethod::CONNECT) {\n    msg->setIngressWebsocketUpgrade();\n    ingressWebsocketUpgrade_ = true;\n  } else {\n    auto it = upgradedStreams_.find(curHeader_.stream);\n    if (it != upgradedStreams_.end()) {\n      upgradedStreams_.erase(curHeader_.stream);\n      // a websocket upgrade was sent on this stream.\n      if (msg->getStatusCode() != 200) {\n        decodeInfo_.parsingError =\n          folly::to<string>(\"Invalid response code to a websocket upgrade: \",\n                            msg->getStatusCode());\n        return;\n      }\n      msg->setIngressWebsocketUpgrade();\n    }\n  }\n}\n\nvoid HTTP2Codec::onDecodeError(HPACK::DecodeError decodeError) {\n  decodeInfo_.decodeError = decodeError;\n}\n\nErrorCode HTTP2Codec::parsePriority(Cursor& cursor) {\n  VLOG(4) << \"parsing PRIORITY frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  http2::PriorityUpdate pri;\n  auto err = http2::parsePriority(cursor, curHeader_, pri);\n  RETURN_IF_ERROR(err);\n  if (curHeader_.stream == pri.streamDependency) {\n    streamError(folly::to<string>(\"Circular dependency for txn=\",\n                                  curHeader_.stream),\n                ErrorCode::PROTOCOL_ERROR, false);\n    return ErrorCode::NO_ERROR;\n  }\n  deliverCallbackIfAllowed(&HTTPCodec::Callback::onPriority, \"onPriority\",\n                           curHeader_.stream,\n                           std::make_tuple(pri.streamDependency,\n                                           pri.exclusive,\n                                           pri.weight));\n  return ErrorCode::NO_ERROR;\n}\n\nsize_t HTTP2Codec::addPriorityNodes(\n    PriorityQueue& queue,\n    folly::IOBufQueue& writeBuf,\n    uint8_t maxLevel) {\n  HTTPCodec::StreamID parent = 0;\n  size_t bytes = 0;\n  while (maxLevel--) {\n    auto id = createStream();\n    virtualPriorityNodes_.push_back(id);\n    queue.addPriorityNode(id, parent);\n    bytes += generatePriority(writeBuf, id, std::make_tuple(parent, false, 0));\n    parent = id;\n  }\n  return bytes;\n}\n\nErrorCode HTTP2Codec::parseRstStream(Cursor& cursor) {\n  // rst for stream in idle state - protocol error\n  VLOG(4) << \"parsing RST_STREAM frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  upgradedStreams_.erase(curHeader_.stream);\n  ErrorCode statusCode = ErrorCode::NO_ERROR;\n  auto err = http2::parseRstStream(cursor, curHeader_, statusCode);\n  RETURN_IF_ERROR(err);\n  if (statusCode == ErrorCode::PROTOCOL_ERROR) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: RST_STREAM with code=\", getErrorCodeString(statusCode),\n        \" for streamID=\", curHeader_.stream, \" user-agent=\", userAgent_);\n    VLOG(2) << goawayErrorMessage_;\n  }\n  deliverCallbackIfAllowed(&HTTPCodec::Callback::onAbort, \"onAbort\",\n                           curHeader_.stream, statusCode);\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseSettings(Cursor& cursor) {\n  VLOG(4) << \"parsing SETTINGS frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  std::deque<SettingPair> settings;\n  auto err = http2::parseSettings(cursor, curHeader_, settings);\n  RETURN_IF_ERROR(err);\n  if (curHeader_.flags & http2::ACK) {\n    handleSettingsAck();\n    return ErrorCode::NO_ERROR;\n  }\n  return handleSettings(settings);\n}\n\nvoid HTTP2Codec::handleSettingsAck() {\n  if (pendingTableMaxSize_) {\n    headerCodec_.setDecoderHeaderTableMaxSize(*pendingTableMaxSize_);\n    pendingTableMaxSize_ = folly::none;\n  }\n  if (callback_) {\n    callback_->onSettingsAck();\n  }\n}\n\nErrorCode HTTP2Codec::handleSettings(const std::deque<SettingPair>& settings) {\n  SettingsList settingsList;\n  for (auto& setting: settings) {\n    switch (setting.first) {\n      case SettingsId::HEADER_TABLE_SIZE:\n      {\n        uint32_t tableSize = setting.second;\n        if (setting.second > http2::kMaxHeaderTableSize) {\n          VLOG(2) << \"Limiting table size from \" << tableSize << \" to \" <<\n            http2::kMaxHeaderTableSize;\n          tableSize = http2::kMaxHeaderTableSize;\n        }\n        headerCodec_.setEncoderHeaderTableSize(tableSize);\n      }\n      break;\n      case SettingsId::ENABLE_PUSH:\n        if ((setting.second != 0 && setting.second != 1) ||\n            (setting.second == 1 &&\n             transportDirection_ == TransportDirection::UPSTREAM)) {\n          goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: ENABLE_PUSH invalid setting=\", setting.second,\n              \" for streamID=\", curHeader_.stream);\n          VLOG(4) << goawayErrorMessage_;\n          return ErrorCode::PROTOCOL_ERROR;\n        }\n        break;\n      case SettingsId::MAX_CONCURRENT_STREAMS:\n        break;\n      case SettingsId::INITIAL_WINDOW_SIZE:\n        if (setting.second > http2::kMaxWindowUpdateSize) {\n          goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: INITIAL_WINDOW_SIZE invalid size=\", setting.second,\n              \" for streamID=\", curHeader_.stream);\n          VLOG(4) << goawayErrorMessage_;\n          return ErrorCode::PROTOCOL_ERROR;\n        }\n        break;\n      case SettingsId::MAX_FRAME_SIZE:\n        if (setting.second < http2::kMaxFramePayloadLengthMin ||\n            setting.second > http2::kMaxFramePayloadLength) {\n          goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: MAX_FRAME_SIZE invalid size=\", setting.second,\n              \" for streamID=\", curHeader_.stream);\n          VLOG(4) << goawayErrorMessage_;\n          return ErrorCode::PROTOCOL_ERROR;\n        }\n        ingressSettings_.setSetting(SettingsId::MAX_FRAME_SIZE, setting.second);\n        break;\n      case SettingsId::MAX_HEADER_LIST_SIZE:\n        break;\n      case SettingsId::ENABLE_EX_HEADERS:\n      {\n        auto ptr = egressSettings_.getSetting(SettingsId::ENABLE_EX_HEADERS);\n        if (ptr && ptr->value > 0) {\n          VLOG(4) << getTransportDirectionString(getTransportDirection())\n                  << \" got ENABLE_EX_HEADERS=\" << setting.second;\n          if (setting.second != 0 && setting.second != 1) {\n            goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: invalid ENABLE_EX_HEADERS=\", setting.second,\n              \" for streamID=\", curHeader_.stream);\n            VLOG(4) << goawayErrorMessage_;\n            return ErrorCode::PROTOCOL_ERROR;\n          }\n          break;\n        } else {\n          // egress ENABLE_EX_HEADERS is disabled, consider the ingress\n          // ENABLE_EX_HEADERS as unknown setting, and ignore it.\n          continue;\n        }\n      }\n      case SettingsId::ENABLE_CONNECT_PROTOCOL:\n        if (setting.second > 1) {\n          goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: ENABLE_CONNECT_PROTOCOL invalid number=\",\n              setting.second, \" for streamID=\", curHeader_.stream);\n          VLOG(4) << goawayErrorMessage_;\n          return ErrorCode::PROTOCOL_ERROR;\n        }\n        break;\n      case SettingsId::THRIFT_CHANNEL_ID:\n      case SettingsId::THRIFT_CHANNEL_ID_DEPRECATED:\n        break;\n      case SettingsId::SETTINGS_HTTP_CERT_AUTH:\n        break;\n      default:\n        continue; // ignore unknown setting\n    }\n    ingressSettings_.setSetting(setting.first, setting.second);\n    settingsList.push_back(*ingressSettings_.getSetting(setting.first));\n  }\n  if (callback_) {\n    callback_->onSettings(settingsList);\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parsePushPromise(Cursor& cursor) {\n  // stream id must be idle - protocol error\n  // assoc-stream-id=closed/unknown - protocol error, unless rst_stream sent\n\n  /*\n   * What does \"must handle\" mean in the following context?  I have to\n   * accept this as a valid pushed resource?\n\n    However, an endpoint that has sent RST_STREAM on the associated\n    stream MUST handle PUSH_PROMISE frames that might have been\n    created before the RST_STREAM frame is received and processed.\n  */\n  if (transportDirection_ != TransportDirection::UPSTREAM) {\n    goawayErrorMessage_ = folly::to<string>(\n      \"Received PUSH_PROMISE on DOWNSTREAM codec\");\n    VLOG(2) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  if (egressSettings_.getSetting(SettingsId::ENABLE_PUSH, -1) != 1) {\n    goawayErrorMessage_ = folly::to<string>(\n      \"Received PUSH_PROMISE on codec with push disabled\");\n    VLOG(2) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  VLOG(4) << \"parsing PUSH_PROMISE frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  uint32_t promisedStream;\n  std::unique_ptr<IOBuf> headerBlockFragment;\n  auto err = http2::parsePushPromise(cursor, curHeader_, promisedStream,\n                                     headerBlockFragment);\n  RETURN_IF_ERROR(err);\n  RETURN_IF_ERROR(checkNewStream(promisedStream, false /* trailersAllowed */));\n  err = parseHeadersImpl(cursor, std::move(headerBlockFragment), folly::none,\n                         promisedStream, folly::none);\n  return err;\n}\n\nErrorCode HTTP2Codec::parsePing(Cursor& cursor) {\n  VLOG(4) << \"parsing PING frame length=\" << curHeader_.length;\n  uint64_t opaqueData = 0;\n  auto err = http2::parsePing(cursor, curHeader_, opaqueData);\n  RETURN_IF_ERROR(err);\n  if (callback_) {\n    if (curHeader_.flags & http2::ACK) {\n      callback_->onPingReply(opaqueData);\n    } else {\n      callback_->onPingRequest(opaqueData);\n    }\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseGoaway(Cursor& cursor) {\n  VLOG(4) << \"parsing GOAWAY frame length=\" << curHeader_.length;\n  uint32_t lastGoodStream = 0;\n  ErrorCode statusCode = ErrorCode::NO_ERROR;\n  std::unique_ptr<IOBuf> debugData;\n\n  auto err = http2::parseGoaway(cursor, curHeader_, lastGoodStream, statusCode,\n                                debugData);\n  if (statusCode != ErrorCode::NO_ERROR) {\n    VLOG(2) << \"Goaway error statusCode=\" << getErrorCodeString(statusCode)\n            << \" lastStream=\" << lastGoodStream\n            << \" user-agent=\" << userAgent_ <<  \" debugData=\" <<\n      ((debugData) ? string((char*)debugData->data(), debugData->length()):\n       empty_string);\n  }\n  RETURN_IF_ERROR(err);\n  if (lastGoodStream < ingressGoawayAck_) {\n    ingressGoawayAck_ = lastGoodStream;\n    // Drain all streams <= lastGoodStream\n    // and abort streams > lastGoodStream\n    if (callback_) {\n      callback_->onGoaway(lastGoodStream, statusCode, std::move(debugData));\n    }\n  } else {\n    LOG(WARNING) << \"Received multiple GOAWAY with increasing ack\";\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseWindowUpdate(Cursor& cursor) {\n  VLOG(4) << \"parsing WINDOW_UPDATE frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  uint32_t delta = 0;\n  auto err = http2::parseWindowUpdate(cursor, curHeader_, delta);\n  RETURN_IF_ERROR(err);\n  if (delta == 0) {\n    VLOG(4) << \"Invalid 0 length delta for stream=\" << curHeader_.stream;\n    if (curHeader_.stream == 0) {\n      goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: invalid/0 length delta for streamID=\",\n        curHeader_.stream);\n      return ErrorCode::PROTOCOL_ERROR;\n    } else {\n      // Parsing a zero delta window update should cause a protocol error\n      // and send a rst stream\n      goawayErrorMessage_ = folly::to<string>(\n        \"parseWindowUpdate Invalid 0 length\");\n      VLOG(4) << goawayErrorMessage_;\n      streamError(folly::to<std::string>(\"streamID=\", curHeader_.stream,\n                                         \" with HTTP2Codec stream error: \",\n                                         \"window update delta=\", delta),\n                  ErrorCode::PROTOCOL_ERROR);\n      return ErrorCode::PROTOCOL_ERROR;\n    }\n  }\n  // if window exceeds 2^31-1, connection/stream error flow control error\n  // must be checked in session/txn\n  deliverCallbackIfAllowed(&HTTPCodec::Callback::onWindowUpdate,\n                           \"onWindowUpdate\", curHeader_.stream, delta);\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseCertificateRequest(Cursor& cursor) {\n  VLOG(4) << \"parsing CERTIFICATE_REQUEST frame length=\" << curHeader_.length;\n  uint16_t requestId = 0;\n  std::unique_ptr<IOBuf> authRequest;\n\n  auto err = http2::parseCertificateRequest(\n      cursor, curHeader_, requestId, authRequest);\n  RETURN_IF_ERROR(err);\n  if (callback_) {\n    callback_->onCertificateRequest(requestId, std::move(authRequest));\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseCertificate(Cursor& cursor) {\n  VLOG(4) << \"parsing CERTIFICATE frame length=\" << curHeader_.length;\n  uint16_t certId = 0;\n  std::unique_ptr<IOBuf> authData;\n  auto err = http2::parseCertificate(cursor, curHeader_, certId, authData);\n  RETURN_IF_ERROR(err);\n  if (curAuthenticatorBlock_.empty()) {\n    curCertId_ = certId;\n  } else if (certId != curCertId_) {\n    // Received CERTIFICATE frame with different Cert-ID.\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  curAuthenticatorBlock_.append(std::move(authData));\n  if (curAuthenticatorBlock_.chainLength() > http2::kMaxAuthenticatorBufSize) {\n    // Received excessively long authenticator.\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  if (!(curHeader_.flags & http2::TO_BE_CONTINUED)) {\n    auto authenticator = curAuthenticatorBlock_.move();\n    if (callback_) {\n      callback_->onCertificate(certId, std::move(authenticator));\n    } else {\n      curAuthenticatorBlock_.clear();\n    }\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::checkNewStream(uint32_t streamId, bool trailersAllowed) {\n  if (streamId == 0) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: received streamID=\", streamId,\n        \" as invalid new stream for lastStreamID_=\", lastStreamID_);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  parsingDownstreamTrailers_ = trailersAllowed && (streamId <= lastStreamID_);\n  if (parsingDownstreamTrailers_) {\n    VLOG(4) << \"Parsing downstream trailers streamId=\" << streamId;\n  }\n\n  if (sessionClosing_ != ClosingState::CLOSED) {\n    lastStreamID_ = streamId;\n  }\n\n  if (isInitiatedStream(streamId)) {\n    // this stream should be initiated by us, not by peer\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: invalid new stream received with streamID=\", streamId);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  } else {\n    return ErrorCode::NO_ERROR;\n  }\n}\n\nsize_t HTTP2Codec::generateConnectionPreface(folly::IOBufQueue& writeBuf) {\n  if (transportDirection_ == TransportDirection::UPSTREAM) {\n    VLOG(4) << \"generating connection preface\";\n    writeBuf.append(http2::kConnectionPreface);\n    return http2::kConnectionPreface.length();\n  }\n  return 0;\n}\n\nbool HTTP2Codec::onIngressUpgradeMessage(const HTTPMessage& msg) {\n  if (!HTTPParallelCodec::onIngressUpgradeMessage(msg)) {\n    return false;\n  }\n  if (msg.getHeaders().getNumberOfValues(http2::kProtocolSettingsHeader) != 1) {\n    VLOG(4) << __func__ << \" with no HTTP2-Settings\";\n    return false;\n  }\n\n  const auto& settingsHeader = msg.getHeaders().getSingleOrEmpty(\n    http2::kProtocolSettingsHeader);\n  if (settingsHeader.empty()) {\n    return true;\n  }\n\n  auto decoded = base64url_decode(settingsHeader);\n\n  // Must be well formed Base64Url and not too large\n  if (decoded.empty() || decoded.length() > http2::kMaxFramePayloadLength) {\n    VLOG(4) << __func__ << \" failed to decode HTTP2-Settings\";\n    return false;\n  }\n  std::unique_ptr<IOBuf> decodedBuf = IOBuf::wrapBuffer(decoded.data(),\n                                                        decoded.length());\n  IOBufQueue settingsQueue{IOBufQueue::cacheChainLength()};\n  settingsQueue.append(std::move(decodedBuf));\n  Cursor c(settingsQueue.front());\n  std::deque<SettingPair> settings;\n  // downcast is ok because of above length check\n  http2::FrameHeader frameHeader{\n    (uint32_t)settingsQueue.chainLength(), 0, http2::FrameType::SETTINGS, 0, 0};\n  auto err = http2::parseSettings(c, frameHeader, settings);\n  if (err != ErrorCode::NO_ERROR) {\n    VLOG(4) << __func__ << \" bad settings frame\";\n    return false;\n  }\n\n  if (handleSettings(settings) != ErrorCode::NO_ERROR) {\n    VLOG(4) << __func__ << \" handleSettings failed\";\n    return false;\n  }\n\n  return true;\n}\n\nvoid HTTP2Codec::generateHeader(folly::IOBufQueue& writeBuf,\n                                StreamID stream,\n                                const HTTPMessage& msg,\n                                bool eom,\n                                HTTPHeaderSize* size) {\n  generateHeaderImpl(writeBuf,\n                     stream,\n                     msg,\n                     folly::none, /* assocStream */\n                     folly::none, /* controlStream */\n                     eom,\n                     size);\n}\n\nvoid HTTP2Codec::generatePushPromise(folly::IOBufQueue& writeBuf,\n                                     StreamID stream,\n                                     const HTTPMessage& msg,\n                                     StreamID assocStream,\n                                     bool eom,\n                                     HTTPHeaderSize* size) {\n  generateHeaderImpl(writeBuf,\n                     stream,\n                     msg,\n                     assocStream,\n                     folly::none, /* controlStream */\n                     eom,\n                     size);\n}\n\nvoid HTTP2Codec::generateExHeader(folly::IOBufQueue& writeBuf,\n                                  StreamID stream,\n                                  const HTTPMessage& msg,\n                                  const HTTPCodec::ExAttributes& exAttributes,\n                                  bool eom,\n                                  HTTPHeaderSize* size) {\n  generateHeaderImpl(writeBuf,\n                     stream,\n                     msg,\n                     folly::none, /* assocStream */\n                     exAttributes,\n                     eom,\n                     size);\n}\n\nvoid HTTP2Codec::generateHeaderImpl(\n    folly::IOBufQueue& writeBuf,\n    StreamID stream,\n    const HTTPMessage& msg,\n    const folly::Optional<StreamID>& assocStream,\n    const folly::Optional<HTTPCodec::ExAttributes>& exAttributes,\n    bool eom,\n    HTTPHeaderSize* size) {\n  if (assocStream) {\n    CHECK(!exAttributes);\n    VLOG(4) << \"generating PUSH_PROMISE for stream=\" << stream;\n  } else if (exAttributes) {\n    CHECK(!assocStream);\n    VLOG(4) << \"generating ExHEADERS for stream=\" << stream\n            << \" with control stream=\" << exAttributes->controlStream\n            << \" unidirectional=\" << exAttributes->unidirectional;\n  } else {\n    VLOG(4) << \"generating HEADERS for stream=\" << stream;\n  }\n\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"Suppressing HEADERS/PROMISE for stream=\" << stream <<\n      \" ingressGoawayAck_=\" << ingressGoawayAck_;\n    if (size) {\n      size->uncompressed = 0;\n      size->compressed = 0;\n    }\n    return;\n  }\n\n  if (msg.isRequest()) {\n    DCHECK(transportDirection_ == TransportDirection::UPSTREAM ||\n           assocStream || exAttributes);\n    if (msg.isEgressWebsocketUpgrade()) {\n      upgradedStreams_.insert(stream);\n    }\n  } else {\n    DCHECK(transportDirection_ == TransportDirection::DOWNSTREAM ||\n           exAttributes);\n  }\n\n  std::vector<std::string> temps;\n  auto allHeaders = CodecUtil::prepareMessageForCompression(msg, temps);\n  auto out = encodeHeaders(msg.getHeaders(), allHeaders, size);\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(out));\n  auto maxFrameSize = maxSendFrameSize();\n  if (queue.chainLength() > 0) {\n    folly::Optional<http2::PriorityUpdate> pri;\n    auto res = msg.getHTTP2Priority();\n    auto remainingFrameSize = maxFrameSize;\n    if (res) {\n      pri = http2::PriorityUpdate{std::get<0>(*res), std::get<1>(*res),\n                                  std::get<2>(*res)};\n      DCHECK_GE(remainingFrameSize, http2::kFramePrioritySize)\n        << \"no enough space for priority? frameHeadroom=\" << remainingFrameSize;\n      remainingFrameSize -= http2::kFramePrioritySize;\n    }\n    auto chunk = queue.split(std::min(remainingFrameSize, queue.chainLength()));\n\n    bool endHeaders = queue.chainLength() == 0;\n\n    if (assocStream) {\n      DCHECK_EQ(transportDirection_, TransportDirection::DOWNSTREAM);\n      DCHECK(!eom);\n      generateHeaderCallbackWrapper(stream, http2::FrameType::PUSH_PROMISE,\n                                    http2::writePushPromise(writeBuf,\n                                                            *assocStream,\n                                                            stream,\n                                                            std::move(chunk),\n                                                            http2::kNoPadding,\n                                                            endHeaders));\n    } else if (exAttributes) {\n      generateHeaderCallbackWrapper(\n        stream,\n        http2::FrameType::EX_HEADERS,\n        http2::writeExHeaders(writeBuf,\n                              std::move(chunk),\n                              stream,\n                              *exAttributes,\n                              pri,\n                              http2::kNoPadding,\n                              eom,\n                              endHeaders));\n    } else {\n      generateHeaderCallbackWrapper(stream, http2::FrameType::HEADERS,\n                                    http2::writeHeaders(writeBuf,\n                                                        std::move(chunk),\n                                                        stream,\n                                                        pri,\n                                                        http2::kNoPadding,\n                                                        eom,\n                                                        endHeaders));\n    }\n\n    if (!endHeaders) {\n      generateContinuation(writeBuf, queue, stream, maxFrameSize);\n    }\n  }\n}\n\nvoid HTTP2Codec::generateContinuation(folly::IOBufQueue& writeBuf,\n                                      folly::IOBufQueue& queue,\n                                      StreamID stream,\n                                      size_t maxFrameSize) {\n  bool endHeaders = false;\n  while (!endHeaders) {\n    auto chunk = queue.split(std::min(maxFrameSize, queue.chainLength()));\n    endHeaders = (queue.chainLength() == 0);\n    VLOG(4) << \"generating CONTINUATION for stream=\" << stream;\n    generateHeaderCallbackWrapper(\n        stream,\n        http2::FrameType::CONTINUATION,\n        http2::writeContinuation(\n            writeBuf, stream, endHeaders, std::move(chunk)));\n  }\n}\n\nstd::unique_ptr<folly::IOBuf> HTTP2Codec::encodeHeaders(\n    const HTTPHeaders& headers,\n    std::vector<compress::Header>& allHeaders,\n    HTTPHeaderSize* size) {\n  headerCodec_.setEncodeHeadroom(http2::kFrameHeaderSize +\n                                 http2::kFrameHeadersBaseMaxSize);\n  auto out = headerCodec_.encode(allHeaders);\n  if (size) {\n    *size = headerCodec_.getEncodedSize();\n  }\n\n  if (headerCodec_.getEncodedSize().uncompressed >\n      ingressSettings_.getSetting(SettingsId::MAX_HEADER_LIST_SIZE,\n                                  std::numeric_limits<uint32_t>::max())) {\n    // The remote side told us they don't want headers this large...\n    // but this function has no mechanism to fail\n    string serializedHeaders;\n    headers.forEach(\n      [&serializedHeaders] (const string& name, const string& value) {\n        serializedHeaders = folly::to<string>(serializedHeaders, \"\\\\n\", name,\n                                              \":\", value);\n      });\n    LOG(ERROR) << \"generating HEADERS frame larger than peer maximum nHeaders=\"\n               << headers.size() << \" all headers=\"\n               << serializedHeaders;\n  }\n  return out;\n}\n\nsize_t HTTP2Codec::generateHeaderCallbackWrapper(StreamID stream,\n                                                 http2::FrameType type,\n                                                 size_t length) {\n  if (callback_) {\n    callback_->onGenerateFrameHeader(stream,\n                                     static_cast<uint8_t>(type),\n                                     length);\n  }\n  return length;\n}\n\nsize_t HTTP2Codec::generateBody(folly::IOBufQueue& writeBuf,\n                                StreamID stream,\n                                std::unique_ptr<folly::IOBuf> chain,\n                                folly::Optional<uint8_t> padding,\n                                bool eom) {\n  // todo: generate random padding for everything?\n  size_t written = 0;\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"Suppressing DATA for stream=\" << stream << \" ingressGoawayAck_=\"\n            << ingressGoawayAck_;\n    return 0;\n  }\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(chain));\n  size_t maxFrameSize = maxSendFrameSize();\n  while (queue.chainLength() > maxFrameSize) {\n    auto chunk = queue.split(maxFrameSize);\n    written += generateHeaderCallbackWrapper(\n                  stream,\n                  http2::FrameType::DATA,\n                  http2::writeData(writeBuf,\n                                   std::move(chunk),\n                                   stream,\n                                   padding,\n                                   false,\n                                   reuseIOBufHeadroomForData_));\n  }\n\n  return written + generateHeaderCallbackWrapper(\n                      stream,\n                      http2::FrameType::DATA,\n                      http2::writeData(writeBuf,\n                                       queue.move(),\n                                       stream,\n                                       padding,\n                                       eom,\n                                       reuseIOBufHeadroomForData_));\n}\n\nsize_t HTTP2Codec::generateChunkHeader(folly::IOBufQueue& /*writeBuf*/,\n                                       StreamID /*stream*/,\n                                       size_t /*length*/) {\n  // HTTP/2 has no chunk headers\n  return 0;\n}\n\nsize_t HTTP2Codec::generateChunkTerminator(folly::IOBufQueue& /*writeBuf*/,\n                                           StreamID /*stream*/) {\n  // HTTP/2 has no chunk terminators\n  return 0;\n}\n\nsize_t HTTP2Codec::generateTrailers(folly::IOBufQueue& writeBuf,\n                                    StreamID stream,\n                                    const HTTPHeaders& trailers) {\n  std::vector<compress::Header> allHeaders;\n  CodecUtil::appendHeaders(trailers, allHeaders, HTTP_HEADER_NONE);\n\n  HTTPHeaderSize size;\n  auto out = encodeHeaders(trailers, allHeaders, &size);\n\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(out));\n  auto maxFrameSize = maxSendFrameSize();\n  if (queue.chainLength() > 0) {\n    folly::Optional<http2::PriorityUpdate> pri;\n    auto remainingFrameSize = maxFrameSize;\n    auto chunk = queue.split(std::min(remainingFrameSize, queue.chainLength()));\n    bool endHeaders = queue.chainLength() == 0;\n    generateHeaderCallbackWrapper(stream,\n                                  http2::FrameType::HEADERS,\n                                  http2::writeHeaders(writeBuf,\n                                                      std::move(chunk),\n                                                      stream,\n                                                      pri,\n                                                      http2::kNoPadding,\n                                                      true /*eom*/,\n                                                      endHeaders));\n\n    if (!endHeaders) {\n      generateContinuation(writeBuf, queue, stream, maxFrameSize);\n    }\n  }\n\n  return size.compressed;\n}\n\nsize_t HTTP2Codec::generateEOM(folly::IOBufQueue& writeBuf,\n                               StreamID stream) {\n  VLOG(4) << \"sending EOM for stream=\" << stream;\n  upgradedStreams_.erase(stream);\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"suppressed EOM for stream=\" << stream << \" ingressGoawayAck_=\"\n            << ingressGoawayAck_;\n    return 0;\n  }\n  return generateHeaderCallbackWrapper(\n            stream,\n            http2::FrameType::DATA,\n            http2::writeData(writeBuf,\n                             nullptr,\n                             stream,\n                             http2::kNoPadding,\n                             true,\n                             reuseIOBufHeadroomForData_));\n}\n\nsize_t HTTP2Codec::generateRstStream(folly::IOBufQueue& writeBuf,\n                                     StreamID stream,\n                                     ErrorCode statusCode) {\n  VLOG(4) << \"sending RST_STREAM for stream=\" << stream\n          << \" with code=\" << getErrorCodeString(statusCode);\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"suppressed RST_STREAM for stream=\" << stream\n            << \" ingressGoawayAck_=\" << ingressGoawayAck_;\n    return 0;\n  }\n  // Suppress any EOM callback for the current frame.\n  if (stream == curHeader_.stream) {\n    curHeader_.flags &= ~http2::END_STREAM;\n    pendingEndStreamHandling_ = false;\n    ingressWebsocketUpgrade_ = false;\n  }\n  upgradedStreams_.erase(stream);\n\n  if (statusCode == ErrorCode::PROTOCOL_ERROR) {\n    VLOG(2) << \"sending RST_STREAM with code=\" << getErrorCodeString(statusCode)\n            << \" for stream=\" << stream << \" user-agent=\" << userAgent_;\n  }\n  auto code = http2::errorCodeToReset(statusCode);\n  return generateHeaderCallbackWrapper(stream, http2::FrameType::RST_STREAM,\n                                       http2::writeRstStream(writeBuf, stream, code));\n}\n\nsize_t HTTP2Codec::generateGoaway(folly::IOBufQueue& writeBuf,\n                                  StreamID lastStream,\n                                  ErrorCode statusCode,\n                                  std::unique_ptr<folly::IOBuf> debugData) {\n  DCHECK_LE(lastStream, egressGoawayAck_) << \"Cannot increase last good stream\";\n  egressGoawayAck_ = lastStream;\n  if (sessionClosing_ == ClosingState::CLOSED) {\n    VLOG(4) << \"Not sending GOAWAY for closed session\";\n    return 0;\n  }\n  switch (sessionClosing_) {\n    case ClosingState::OPEN:\n    case ClosingState::OPEN_WITH_GRACEFUL_DRAIN_ENABLED:\n      if (lastStream == std::numeric_limits<int32_t>::max() &&\n          statusCode == ErrorCode::NO_ERROR) {\n        sessionClosing_ = ClosingState::FIRST_GOAWAY_SENT;\n      } else {\n        // The user of this codec decided not to do the double goaway\n        // drain, or this is not a graceful shutdown\n        sessionClosing_ = ClosingState::CLOSED;\n      }\n      break;\n    case ClosingState::FIRST_GOAWAY_SENT:\n      sessionClosing_ = ClosingState::CLOSED;\n      break;\n    case ClosingState::CLOSING:\n    case ClosingState::CLOSED:\n      LOG(FATAL) << \"unreachable\";\n  }\n\n  VLOG(4) << \"Sending GOAWAY with last acknowledged stream=\"\n          << lastStream << \" with code=\" << getErrorCodeString(statusCode);\n  if (statusCode == ErrorCode::PROTOCOL_ERROR) {\n    VLOG(2) << \"sending GOAWAY with last acknowledged stream=\" << lastStream\n            << \" with code=\" << getErrorCodeString(statusCode)\n            << \" user-agent=\" << userAgent_;\n  }\n\n  auto code = http2::errorCodeToGoaway(statusCode);\n  return generateHeaderCallbackWrapper(\n            0,\n            http2::FrameType::GOAWAY,\n            http2::writeGoaway(writeBuf,\n                              lastStream,\n                              code,\n                              std::move(debugData)));\n}\n\nsize_t HTTP2Codec::generatePingRequest(folly::IOBufQueue& writeBuf) {\n  // should probably let the caller specify when integrating with session\n  // we know HTTPSession sets up events to track ping latency\n  uint64_t opaqueData = folly::Random::rand64();\n  VLOG(4) << \"Generating ping request with opaqueData=\" << opaqueData;\n  return generateHeaderCallbackWrapper(0, http2::FrameType::PING,\n                                       http2::writePing(writeBuf, opaqueData, false /* no ack */));\n}\n\nsize_t HTTP2Codec::generatePingReply(folly::IOBufQueue& writeBuf,\n                                     uint64_t uniqueID) {\n  VLOG(4) << \"Generating ping reply with opaqueData=\" << uniqueID;\n  return generateHeaderCallbackWrapper(0, http2::FrameType::PING,\n                                       http2::writePing(writeBuf, uniqueID, true /* ack */));\n}\n\nsize_t HTTP2Codec::generateSettings(folly::IOBufQueue& writeBuf) {\n  std::deque<SettingPair> settings;\n  for (auto& setting: egressSettings_.getAllSettings()) {\n    switch (setting.id) {\n      case SettingsId::HEADER_TABLE_SIZE:\n        if (pendingTableMaxSize_) {\n          LOG(ERROR) << \"Can't have more than one settings in flight, skipping\";\n          continue;\n        } else {\n          pendingTableMaxSize_ = setting.value;\n        }\n        break;\n      case SettingsId::ENABLE_PUSH:\n        if (transportDirection_ == TransportDirection::DOWNSTREAM) {\n          // HTTP/2 spec says downstream must not send this flag\n          // HTTP2Codec uses it to determine if push features are enabled\n          continue;\n        } else {\n          CHECK(setting.value == 0 || setting.value == 1);\n        }\n        break;\n      case SettingsId::MAX_CONCURRENT_STREAMS:\n      case SettingsId::INITIAL_WINDOW_SIZE:\n      case SettingsId::MAX_FRAME_SIZE:\n        break;\n      case SettingsId::MAX_HEADER_LIST_SIZE:\n        headerCodec_.setMaxUncompressed(setting.value);\n        break;\n      case SettingsId::ENABLE_EX_HEADERS:\n        CHECK(setting.value == 0 || setting.value == 1);\n        if (setting.value == 0) {\n          continue; // just skip the experimental setting if disabled\n        } else {\n          VLOG(4) << \"generating ENABLE_EX_HEADERS=\" << setting.value;\n        }\n        break;\n      case SettingsId::ENABLE_CONNECT_PROTOCOL:\n        if (setting.value == 0) {\n          continue;\n        }\n        break;\n      case SettingsId::THRIFT_CHANNEL_ID:\n      case SettingsId::THRIFT_CHANNEL_ID_DEPRECATED:\n        break;\n      default:\n        LOG(ERROR) << \"ignore unknown settingsId=\"\n                   << std::underlying_type<SettingsId>::type(setting.id)\n                   << \" value=\" << setting.value;\n        continue;\n    }\n\n    settings.push_back(SettingPair(setting.id, setting.value));\n  }\n  VLOG(4) << getTransportDirectionString(getTransportDirection())\n          << \" generating \" << (unsigned)settings.size() << \" settings\";\n  return generateHeaderCallbackWrapper(0, http2::FrameType::SETTINGS,\n                                       http2::writeSettings(writeBuf, settings));\n}\n\nvoid HTTP2Codec::requestUpgrade(HTTPMessage& request) {\n  static folly::ThreadLocalPtr<HTTP2Codec> defaultCodec;\n  if (!defaultCodec.get()) {\n    defaultCodec.reset(new HTTP2Codec(TransportDirection::UPSTREAM));\n  }\n\n  auto& headers = request.getHeaders();\n  headers.set(HTTP_HEADER_UPGRADE, http2::kProtocolCleartextString);\n  if (!request.checkForHeaderToken(HTTP_HEADER_CONNECTION, \"Upgrade\", false)) {\n    headers.add(HTTP_HEADER_CONNECTION, \"Upgrade\");\n  }\n  IOBufQueue writeBuf{IOBufQueue::cacheChainLength()};\n  defaultCodec->generateSettings(writeBuf);\n  // fake an ack since defaultCodec gets reused\n  defaultCodec->handleSettingsAck();\n  writeBuf.trimStart(http2::kFrameHeaderSize);\n  auto buf = writeBuf.move();\n  buf->coalesce();\n  headers.set(http2::kProtocolSettingsHeader,\n              base64url_encode(folly::ByteRange(buf->data(), buf->length())));\n  if (!request.checkForHeaderToken(HTTP_HEADER_CONNECTION,\n                                   http2::kProtocolSettingsHeader.c_str(),\n                                   false)) {\n    headers.add(HTTP_HEADER_CONNECTION, http2::kProtocolSettingsHeader);\n  }\n}\n\nsize_t HTTP2Codec::generateSettingsAck(folly::IOBufQueue& writeBuf) {\n  VLOG(4) << getTransportDirectionString(getTransportDirection())\n          << \" generating settings ack\";\n  return generateHeaderCallbackWrapper(0, http2::FrameType::SETTINGS,\n                                       http2::writeSettingsAck(writeBuf));\n}\n\nsize_t HTTP2Codec::generateWindowUpdate(folly::IOBufQueue& writeBuf,\n                                        StreamID stream,\n                                        uint32_t delta) {\n  VLOG(4) << \"generating window update for stream=\" << stream\n          << \": Processed \" << delta << \" bytes\";\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"suppressed WINDOW_UPDATE for stream=\" << stream\n            << \" ingressGoawayAck_=\" << ingressGoawayAck_;\n    return 0;\n  }\n  return generateHeaderCallbackWrapper(stream, http2::FrameType::WINDOW_UPDATE,\n                                       http2::writeWindowUpdate(writeBuf, stream, delta));\n}\n\nsize_t HTTP2Codec::generatePriority(folly::IOBufQueue& writeBuf,\n                                    StreamID stream,\n                                    const HTTPMessage::HTTPPriority& pri) {\n  VLOG(4) << \"generating priority for stream=\" << stream;\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"suppressed PRIORITY for stream=\" << stream\n            << \" ingressGoawayAck_=\" << ingressGoawayAck_;\n    return 0;\n  }\n  return generateHeaderCallbackWrapper(\n            stream,\n            http2::FrameType::PRIORITY,\n            http2::writePriority(writeBuf, stream,\n                                 {std::get<0>(pri),\n                                   std::get<1>(pri),\n                                   std::get<2>(pri)}));\n}\n\nsize_t HTTP2Codec::generateCertificateRequest(\n    folly::IOBufQueue& writeBuf,\n    uint16_t requestId,\n    std::unique_ptr<folly::IOBuf> certificateRequestData) {\n  VLOG(4) << \"generating CERTIFICATE_REQUEST with Request-ID=\" << requestId;\n  return http2::writeCertificateRequest(\n      writeBuf, requestId, std::move(certificateRequestData));\n}\n\nsize_t HTTP2Codec::generateCertificate(folly::IOBufQueue& writeBuf,\n                                       uint16_t certId,\n                                       std::unique_ptr<folly::IOBuf> certData) {\n  size_t written = 0;\n  VLOG(4) << \"sending CERTIFICATE with Cert-ID=\" << certId << \"for stream=0\";\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(certData));\n  // The maximum size of an autenticator fragment, combined with the Cert-ID can\n  // not exceed the maximal allowable size of a sent frame.\n  size_t maxChunkSize = maxSendFrameSize() - sizeof(certId);\n  while (queue.chainLength() > maxChunkSize) {\n    auto chunk = queue.splitAtMost(maxChunkSize);\n    written +=\n        http2::writeCertificate(writeBuf, certId, std::move(chunk), true);\n  }\n  return written +\n         http2::writeCertificate(writeBuf, certId, queue.move(), false);\n}\n\nbool HTTP2Codec::checkConnectionError(ErrorCode err, const folly::IOBuf* buf) {\n  if (err != ErrorCode::NO_ERROR) {\n    LOG(ERROR) << \"Connection error \" << getErrorCodeString(err)\n               << \" with ingress=\";\n    VLOG(3) << IOBufPrinter::printHexFolly(buf, true);\n    if (callback_) {\n      std::string errorDescription = goawayErrorMessage_.empty() ?\n        \"Connection error\" : goawayErrorMessage_;\n      HTTPException ex(HTTPException::Direction::INGRESS_AND_EGRESS,\n                       errorDescription);\n      ex.setCodecStatusCode(err);\n      callback_->onError(0, ex, false);\n    }\n    return true;\n  }\n  return false;\n}\n\nvoid HTTP2Codec::streamError(const std::string& msg, ErrorCode code,\n                             bool newTxn) {\n  HTTPException error(HTTPException::Direction::INGRESS_AND_EGRESS,\n                      msg);\n  error.setCodecStatusCode(code);\n  if (callback_) {\n    callback_->onError(curHeader_.stream, error, newTxn);\n  }\n}\n\nHTTPCodec::StreamID\nHTTP2Codec::mapPriorityToDependency(uint8_t priority) const {\n  // If the priority is out of the maximum index of virtual nodes array, we\n  // return the lowest level virtual node as a punishment of not setting\n  // priority correctly.\n  return virtualPriorityNodes_.empty()\n    ? 0\n    : virtualPriorityNodes_[\n        std::min(priority, uint8_t(virtualPriorityNodes_.size() - 1))];\n}\n\nbool HTTP2Codec::parsingTrailers() const {\n  // HEADERS frame is used for request/response headers and trailers.\n  // Per spec, specific role of HEADERS frame is determined by it's postion\n  // within the stream. We don't keep full stream state in this codec,\n  // thus using heuristics to distinguish between headers/trailers.\n  // For DOWNSTREAM case, request headers HEADERS frame would be creating\n  // new stream, thus HEADERS on existing stream ID are considered trailers\n  // (see checkNewStream).\n  // For UPSTREAM case, response headers are required to have status code,\n  // thus if no status code we consider that trailers.\n  if (curHeader_.type == http2::FrameType::HEADERS ||\n      curHeader_.type == http2::FrameType::CONTINUATION) {\n    if (transportDirection_ == TransportDirection::DOWNSTREAM) {\n      return parsingDownstreamTrailers_;\n    } else {\n      return !decodeInfo_.hasStatus();\n    }\n  }\n  return false;\n}\n}\n", "/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n#include <proxygen/lib/http/codec/test/HTTPParallelCodecTest.h>\n#include <proxygen/lib/http/codec/test/MockHTTPCodec.h>\n#include <folly/io/Cursor.h>\n#include <proxygen/lib/http/codec/HTTP2Codec.h>\n#include <proxygen/lib/http/codec/test/HTTP2FramerTest.h>\n#include <proxygen/lib/http/HTTPHeaderSize.h>\n#include <proxygen/lib/http/HTTPMessage.h>\n\n#include <folly/portability/GTest.h>\n#include <folly/portability/GMock.h>\n#include <random>\n\nusing namespace proxygen;\nusing namespace proxygen::compress;\nusing namespace folly;\nusing namespace folly::io;\nusing namespace std;\nusing namespace testing;\n\nTEST(HTTP2CodecConstantsTest, HTTPContantsAreCommonHeaders) {\n  // The purpose of this test is to verify some basic assumptions that should\n  // never change but to make clear that the following http2 header constants\n  // map to the respective common headers.  Should this test ever fail, the\n  // H2Codec would need to be updated in the corresponding places when creating\n  // compress/Header objects.\n  EXPECT_EQ(HTTPCommonHeaders::hash(headers::kMethod),\n            HTTP_HEADER_COLON_METHOD);\n  EXPECT_EQ(HTTPCommonHeaders::hash(headers::kScheme),\n            HTTP_HEADER_COLON_SCHEME);\n  EXPECT_EQ(HTTPCommonHeaders::hash(headers::kPath),\n            HTTP_HEADER_COLON_PATH);\n  EXPECT_EQ(\n    HTTPCommonHeaders::hash(headers::kAuthority),\n    HTTP_HEADER_COLON_AUTHORITY);\n  EXPECT_EQ(HTTPCommonHeaders::hash(headers::kStatus),\n            HTTP_HEADER_COLON_STATUS);\n}\n\nclass HTTP2CodecTest : public HTTPParallelCodecTest {\n public:\n\n  HTTP2CodecTest()\n    :HTTPParallelCodecTest(upstreamCodec_, downstreamCodec_) {}\n\n  void SetUp() override {\n    HTTPParallelCodecTest::SetUp();\n  }\n  void testHeaderListSize(bool oversized);\n  void testFrameSizeLimit(bool oversized);\n\n protected:\n  HTTP2Codec upstreamCodec_{TransportDirection::UPSTREAM};\n  HTTP2Codec downstreamCodec_{TransportDirection::DOWNSTREAM};\n};\n\nTEST_F(HTTP2CodecTest, IgnoreUnknownSettings) {\n  auto numSettings = downstreamCodec_.getIngressSettings()->getNumSettings();\n  std::deque<SettingPair> settings;\n  for (uint32_t i = 200; i < (200 + 1024); i++) {\n    settings.push_back(SettingPair(SettingsId(i), i));\n  }\n  http2::writeSettings(output_, settings);\n  parse();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_EQ(numSettings,\n            downstreamCodec_.getIngressSettings()->getNumSettings());\n}\n\nTEST_F(HTTP2CodecTest, NoExHeaders) {\n  // do not emit ENABLE_EX_HEADERS setting, if disabled\n  SetUpUpstreamTest();\n\n  EXPECT_EQ(callbacks_.settings, 0);\n  EXPECT_EQ(callbacks_.numSettings, 0);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n\n  parseUpstream();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  // only 3 standard settings: HEADER_TABLE_SIZE, ENABLE_PUSH, MAX_FRAME_SIZE.\n  EXPECT_EQ(callbacks_.numSettings, 3);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n}\n\nTEST_F(HTTP2CodecTest, IgnoreExHeadersSetting) {\n  // disable EX_HEADERS on egress\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 0);\n  auto ptr = downstreamCodec_.getEgressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(0, ptr->value);\n\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(nullptr, ptr);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n\n  // attempt to enable EX_HEADERS on ingress\n  http2::writeSettings(output_,\n                      {SettingPair(SettingsId::ENABLE_EX_HEADERS, 1)});\n  parse();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(nullptr, ptr);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n\n  // attempt to disable EX_HEADERS on ingress\n  callbacks_.reset();\n  http2::writeSettings(output_,\n                      {SettingPair(SettingsId::ENABLE_EX_HEADERS, 0)});\n  parse();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(nullptr, ptr);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n}\n\nTEST_F(HTTP2CodecTest, EnableExHeadersSetting) {\n  // enable EX_HEADERS on egress\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n\n  auto ptr = downstreamCodec_.getEgressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(1, ptr->value);\n\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(nullptr, ptr);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n\n  // attempt to enable EX_HEADERS on ingress\n  http2::writeSettings(output_,\n                      {SettingPair(SettingsId::ENABLE_EX_HEADERS, 1)});\n  parse();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(1, ptr->value);\n  EXPECT_EQ(true, downstreamCodec_.supportsExTransactions());\n\n  // attempt to disable EX_HEADERS on ingress\n  callbacks_.reset();\n  http2::writeSettings(output_,\n                      {SettingPair(SettingsId::ENABLE_EX_HEADERS, 0)});\n  parse();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(0, ptr->value);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n}\n\nTEST_F(HTTP2CodecTest, InvalidExHeadersSetting) {\n  // enable EX_HEADERS on egress\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n\n  // attempt to set a invalid ENABLE_EX_HEADERS value\n  http2::writeSettings(output_,\n                      {SettingPair(SettingsId::ENABLE_EX_HEADERS, 110)});\n  parse();\n\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, BasicHeader) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  req.getHeaders().add(\"tab-hdr\", \"coolio\\tv2\");\n  // Connection header will get dropped\n  req.getHeaders().add(HTTP_HEADER_CONNECTION, \"Love\");\n  req.setSecure(true);\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  parse();\n  callbacks_.expectMessage(true, 3, \"/guacamole\");\n  EXPECT_TRUE(callbacks_.msg->isSecure());\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(\"coolio\", headers.getSingleOrEmpty(HTTP_HEADER_USER_AGENT));\n  EXPECT_EQ(\"coolio\\tv2\", headers.getSingleOrEmpty(\"tab-hdr\"));\n  EXPECT_EQ(\"www.foo.com\", headers.getSingleOrEmpty(HTTP_HEADER_HOST));\n}\n\nTEST_F(HTTP2CodecTest, RequestFromServer) {\n  // this is to test EX_HEADERS frame, which carrys the HTTP request initiated\n  // by server side\n  upstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n  SetUpUpstreamTest();\n  proxygen::http2::writeSettings(\n      output_, {{proxygen::SettingsId::ENABLE_EX_HEADERS, 1}});\n\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  req.getHeaders().add(\"tab-hdr\", \"coolio\\tv2\");\n  // Connection header will get dropped\n  req.getHeaders().add(HTTP_HEADER_CONNECTION, \"Love\");\n  req.setSecure(true);\n\n  HTTPCodec::StreamID stream = folly::Random::rand32(10, 1024) * 2;\n  HTTPCodec::StreamID controlStream = folly::Random::rand32(10, 1024) * 2 + 1;\n  upstreamCodec_.generateExHeader(output_, stream, req,\n                                  HTTPCodec::ExAttributes(controlStream, true),\n                                  true);\n\n  parseUpstream();\n  EXPECT_EQ(controlStream, callbacks_.controlStreamId);\n  EXPECT_TRUE(callbacks_.isUnidirectional);\n  callbacks_.expectMessage(true, 3, \"/guacamole\");\n  EXPECT_TRUE(callbacks_.msg->isSecure());\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(\"coolio\", headers.getSingleOrEmpty(HTTP_HEADER_USER_AGENT));\n  EXPECT_EQ(\"coolio\\tv2\", headers.getSingleOrEmpty(\"tab-hdr\"));\n  EXPECT_EQ(\"www.foo.com\", headers.getSingleOrEmpty(HTTP_HEADER_HOST));\n}\n\nTEST_F(HTTP2CodecTest, ResponseFromClient) {\n  // this is to test EX_HEADERS frame, which carrys the HTTP response replied by\n  // client side\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n  proxygen::http2::writeSettings(\n      output_, {{proxygen::SettingsId::ENABLE_EX_HEADERS, 1}});\n\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n\n  HTTPCodec::StreamID stream = folly::Random::rand32(10, 1024) * 2;\n  HTTPCodec::StreamID controlStream = folly::Random::rand32(10, 1024) * 2 + 1;\n  downstreamCodec_.generateExHeader(output_, stream, resp,\n    HTTPCodec::ExAttributes(controlStream, true), true);\n\n  parse();\n  EXPECT_EQ(controlStream, callbacks_.controlStreamId);\n  EXPECT_TRUE(callbacks_.isUnidirectional);\n  EXPECT_EQ(\"OK\", callbacks_.msg->getStatusMessage());\n  callbacks_.expectMessage(true, 2, 200);\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(\"OK\", callbacks_.msg->getStatusMessage());\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n}\n\nTEST_F(HTTP2CodecTest, ExHeadersWithPriority) {\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n  proxygen::http2::writeSettings(\n      output_, {{proxygen::SettingsId::ENABLE_EX_HEADERS, 1}});\n\n  auto req = getGetRequest();\n  auto pri = HTTPMessage::HTTPPriority(0, false, 7);\n  req.setHTTP2Priority(pri);\n  upstreamCodec_.generateExHeader(output_, 3, req,\n                                  HTTPCodec::ExAttributes(1, true));\n\n  parse();\n  EXPECT_EQ(callbacks_.msg->getHTTP2Priority(), pri);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, IgnoreExHeadersIfNotEnabled) {\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 0);\n\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  downstreamCodec_.generateExHeader(output_, 3, req,\n                                    HTTPCodec::ExAttributes(1, true));\n\n  parse();\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadHeaders) {\n  static const std::string v1(\"GET\");\n  static const std::string v2(\"/\");\n  static const std::string v3(\"http\");\n  static const std::string v4(\"foo.com\");\n  static const vector<proxygen::compress::Header> reqHeaders = {\n    Header::makeHeaderForTest(headers::kMethod, v1),\n    Header::makeHeaderForTest(headers::kPath, v2),\n    Header::makeHeaderForTest(headers::kScheme, v3),\n    Header::makeHeaderForTest(headers::kAuthority, v4),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  HTTPCodec::StreamID stream = 1;\n  // missing fields (missing authority is OK)\n  for (size_t i = 0; i < reqHeaders.size(); i++, stream += 2) {\n    std::vector<proxygen::compress::Header> allHeaders = reqHeaders;\n    allHeaders.erase(allHeaders.begin() + i);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n  // dup fields\n  std::string v(\"foomonkey\");\n  for (size_t i = 0; i < reqHeaders.size(); i++, stream += 2) {\n    std::vector<proxygen::compress::Header> allHeaders = reqHeaders;\n    auto h = allHeaders[i];\n    h.value = &v;\n    allHeaders.push_back(h);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 7);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadPseudoHeaders) {\n  static const std::string v1(\"POST\");\n  static const std::string v2(\"http\");\n  static const std::string n3(\"foo\");\n  static const std::string v3(\"bar\");\n  static const std::string v4(\"/\");\n  static const vector<proxygen::compress::Header> reqHeaders = {\n    Header::makeHeaderForTest(headers::kMethod, v1),\n    Header::makeHeaderForTest(headers::kScheme, v2),\n    Header::makeHeaderForTest(n3, v3),\n    Header::makeHeaderForTest(headers::kPath, v4),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  HTTPCodec::StreamID stream = 1;\n  std::vector<proxygen::compress::Header> allHeaders = reqHeaders;\n  auto encodedHeaders = headerCodec.encode(allHeaders);\n  http2::writeHeaders(output_,\n                      std::move(encodedHeaders),\n                      stream,\n                      folly::none,\n                      http2::kNoPadding,\n                      true,\n                      true);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadHeaderValues) {\n  static const std::string v1(\"--1\");\n  static const std::string v2(\"\\13\\10protocol-attack\");\n  static const std::string v3(\"\\13\");\n  static const std::string v4(\"abc.com\\\\13\\\\10\");\n  static const vector<proxygen::compress::Header> reqHeaders = {\n    Header::makeHeaderForTest(headers::kMethod, v1),\n    Header::makeHeaderForTest(headers::kPath, v2),\n    Header::makeHeaderForTest(headers::kScheme, v3),\n    Header::makeHeaderForTest(headers::kAuthority, v4),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  HTTPCodec::StreamID stream = 1;\n  for (size_t i = 0; i < reqHeaders.size(); i++, stream += 2) {\n    std::vector<proxygen::compress::Header> allHeaders;\n    allHeaders.push_back(reqHeaders[i]);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 4);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\n/**\n * Ingress bytes with an empty header name\n */\nconst uint8_t kBufEmptyHeader[] = {\n  0x00, 0x00, 0x1d, 0x01, 0x04, 0x00, 0x00, 0x00, 0x01, 0x82,\n  0x87, 0x44, 0x87, 0x62, 0x6b, 0x46, 0x41, 0xd2, 0x7a, 0x0b,\n  0x41, 0x89, 0xf1, 0xe3, 0xc2, 0xf2, 0x9c, 0xeb, 0x90, 0xf4,\n  0xff, 0x40, 0x80, 0x84, 0x2d, 0x35, 0xa7, 0xd7\n};\n\nTEST_F(HTTP2CodecTest, EmptyHeaderName) {\n  output_.append(IOBuf::copyBuffer(kBufEmptyHeader, sizeof(kBufEmptyHeader)));\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicConnect) {\n  std::string authority = \"myhost:1234\";\n  HTTPMessage request;\n  request.setMethod(HTTPMethod::CONNECT);\n  request.getHeaders().add(proxygen::HTTP_HEADER_HOST, authority);\n  upstreamCodec_.generateHeader(output_, 1, request, false /* eom */);\n\n  parse();\n  callbacks_.expectMessage(false, 1, \"\");\n  EXPECT_EQ(HTTPMethod::CONNECT, callbacks_.msg->getMethod());\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(authority, headers.getSingleOrEmpty(proxygen::HTTP_HEADER_HOST));\n}\n\nTEST_F(HTTP2CodecTest, BadConnect) {\n  std::string v1 = \"CONNECT\";\n  std::string v2 = \"somehost:576\";\n  std::vector<proxygen::compress::Header> goodHeaders = {\n    Header::makeHeaderForTest(headers::kMethod, v1),\n    Header::makeHeaderForTest(headers::kAuthority, v2),\n  };\n\n  // See https://tools.ietf.org/html/rfc7540#section-8.3\n  std::string v3 = \"/foobar\";\n  std::vector<proxygen::compress::Header> badHeaders = {\n    Header::makeHeaderForTest(headers::kScheme, headers::kHttp),\n    Header::makeHeaderForTest(headers::kPath, v3),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  HTTPCodec::StreamID stream = 1;\n\n  for (size_t i = 0; i < badHeaders.size(); i++, stream += 2) {\n    auto allHeaders = goodHeaders;\n    allHeaders.push_back(badHeaders[i]);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, badHeaders.size());\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nvoid HTTP2CodecTest::testHeaderListSize(bool oversized) {\n  if (oversized) {\n    auto settings = downstreamCodec_.getEgressSettings();\n    settings->setSetting(SettingsId::MAX_HEADER_LIST_SIZE, 37);\n  }\n\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  req.getHeaders().add(\"x-long-long-header\",\n                       \"supercalafragalisticexpialadoshus\");\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  parse();\n  // session error\n  EXPECT_EQ(callbacks_.messageBegin, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.headersComplete, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.messageComplete, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, oversized ? 1 : 0);\n}\n\nvoid HTTP2CodecTest::testFrameSizeLimit(bool oversized) {\n  HTTPMessage req = getBigGetRequest(\"/guacamole\");\n  auto settings = downstreamCodec_.getEgressSettings();\n\n  parse(); // consume preface\n  if (oversized) {\n    // trick upstream for sending a 2x bigger HEADERS frame\n    settings->setSetting(SettingsId::MAX_FRAME_SIZE,\n                         http2::kMaxFramePayloadLengthMin * 2);\n    downstreamCodec_.generateSettings(output_);\n    parseUpstream();\n  }\n\n  settings->setSetting(SettingsId::MAX_FRAME_SIZE,\n                       http2::kMaxFramePayloadLengthMin);\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  parse();\n  // session error\n  EXPECT_EQ(callbacks_.messageBegin, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.headersComplete, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.messageComplete, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, oversized ? 1 : 0);\n}\n\nTEST_F(HTTP2CodecTest, NormalSizeHeader) {\n  testHeaderListSize(false);\n}\n\nTEST_F(HTTP2CodecTest, OversizedHeader) {\n  testHeaderListSize(true);\n}\n\nTEST_F(HTTP2CodecTest, NormalSizeFrame) {\n  testFrameSizeLimit(false);\n}\n\nTEST_F(HTTP2CodecTest, OversizedFrame) {\n  testFrameSizeLimit(true);\n}\n\nTEST_F(HTTP2CodecTest, BigHeaderCompressed) {\n  SetUpUpstreamTest();\n  auto settings = downstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::MAX_HEADER_LIST_SIZE, 37);\n  downstreamCodec_.generateSettings(output_);\n  parseUpstream();\n\n  SetUp();\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  parse();\n  // session error\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\n\nTEST_F(HTTP2CodecTest, BasicHeaderReply) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n  downstreamCodec_.generateEOM(output_, 1);\n\n  parseUpstream();\n  callbacks_.expectMessage(true, 2, 200);\n  const auto& headers = callbacks_.msg->getHeaders();\n  // HTTP/2 doesnt support serialization - instead you get the default\n  EXPECT_EQ(\"OK\", callbacks_.msg->getStatusMessage());\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n}\n\nTEST_F(HTTP2CodecTest, BadHeadersReply) {\n  static const std::string v1(\"200\");\n  static const vector<proxygen::compress::Header> respHeaders = {\n    Header::makeHeaderForTest(headers::kStatus, v1),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::DOWNSTREAM);\n  HTTPCodec::StreamID stream = 1;\n  // missing fields (missing authority is OK)\n  for (size_t i = 0; i < respHeaders.size(); i++, stream += 2) {\n    std::vector<proxygen::compress::Header> allHeaders = respHeaders;\n    allHeaders.erase(allHeaders.begin() + i);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n  // dup fields\n  std::string v(\"foomonkey\");\n  for (size_t i = 0; i < respHeaders.size(); i++, stream += 2) {\n    std::vector<proxygen::compress::Header> allHeaders = respHeaders;\n    auto h = allHeaders[i];\n    h.value = &v;\n    allHeaders.push_back(h);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 2);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, Cookies) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(\"Cookie\", \"chocolate-chip=1\");\n  req.getHeaders().add(\"Cookie\", \"rainbow-chip=2\");\n  req.getHeaders().add(\"Cookie\", \"butterscotch=3\");\n  req.getHeaders().add(\"Cookie\", \"oatmeal-raisin=4\");\n  req.setSecure(true);\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  parse();\n  callbacks_.expectMessage(false, 2, \"/guacamole\");\n  EXPECT_EQ(callbacks_.msg->getCookie(\"chocolate-chip\"), \"1\");\n  EXPECT_EQ(callbacks_.msg->getCookie(\"rainbow-chip\"), \"2\");\n  EXPECT_EQ(callbacks_.msg->getCookie(\"butterscotch\"), \"3\");\n  EXPECT_EQ(callbacks_.msg->getCookie(\"oatmeal-raisin\"), \"4\");\n}\n\nTEST_F(HTTP2CodecTest, BasicContinuation) {\n  HTTPMessage req = getBigGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  parse();\n  callbacks_.expectMessage(false, -1, \"/\");\n#ifndef NDEBUG\n  EXPECT_GT(downstreamCodec_.getReceivedFrameCount(), 1);\n#endif\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(\"coolio\", headers.getSingleOrEmpty(HTTP_HEADER_USER_AGENT));\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicContinuationEndStream) {\n  // CONTINUATION with END_STREAM flag set on the preceding HEADERS frame\n  HTTPMessage req = getBigGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  parse();\n  callbacks_.expectMessage(true, -1, \"/\");\n#ifndef NDEBUG\n  EXPECT_GT(downstreamCodec_.getReceivedFrameCount(), 1);\n#endif\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(\"coolio\", headers.getSingleOrEmpty(HTTP_HEADER_USER_AGENT));\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadContinuation) {\n  // CONTINUATION with no preceding HEADERS\n  auto fakeHeaders = makeBuf(5);\n  http2::writeContinuation(output_, 3, true, std::move(fakeHeaders));\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, MissingContinuation) {\n  IOBufQueue output(IOBufQueue::cacheChainLength());\n  HTTPMessage req = getBigGetRequest();\n\n  upstreamCodec_.generateHeader(output_, 1, req);\n  // empirically determined the size of continuation frame, and strip it\n  output_.trimEnd(http2::kFrameHeaderSize + 4134);\n\n  // insert a non-continuation (but otherwise valid) frame\n  http2::writeGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 2);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, MissingContinuationBadFrame) {\n  IOBufQueue output(IOBufQueue::cacheChainLength());\n  HTTPMessage req = getBigGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  // empirically determined the size of continuation frame, and fake it\n  output_.trimEnd(http2::kFrameHeaderSize + 4134);\n\n  // insert an invalid frame\n  auto frame = makeBuf(http2::kFrameHeaderSize + 4134);\n  *((uint32_t *)frame->writableData()) = 0xfa000000;\n  output_.append(std::move(frame));\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 2);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, BadContinuationStream) {\n  HTTPMessage req = getBigGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  // empirically determined the size of continuation frame, and fake it\n  output_.trimEnd(http2::kFrameHeaderSize + 4134);\n  auto fakeHeaders = makeBuf(4134);\n  http2::writeContinuation(output_, 3, true, std::move(fakeHeaders));\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 2);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, FrameTooLarge) {\n  writeFrameHeaderManual(output_, 1 << 15, 0, 0, 1);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n  EXPECT_TRUE(callbacks_.lastParseError->hasCodecStatusCode());\n  EXPECT_EQ(callbacks_.lastParseError->getCodecStatusCode(),\n            ErrorCode::FRAME_SIZE_ERROR);\n}\n\nTEST_F(HTTP2CodecTest, UnknownFrameType) {\n  HTTPMessage req = getGetRequest();\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n\n  // unknown frame type 17\n  writeFrameHeaderManual(output_, 17, 37, 0, 1);\n  output_.append(\"wicked awesome!!!\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  parse();\n  callbacks_.expectMessage(false, 2, \"\"); // + host\n}\n\nTEST_F(HTTP2CodecTest, JunkAfterConnError) {\n  HTTPMessage req = getGetRequest();\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n\n  // write headers frame for stream 0\n  writeFrameHeaderManual(output_, 0, (uint8_t)http2::FrameType::HEADERS, 0, 0);\n  // now write a valid headers frame, should never be parsed\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, BasicData) {\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  upstreamCodec_.generateBody(output_, 2, std::move(buf),\n                              HTTPCodec::NoPadding, true);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, 5);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), data);\n}\n\nTEST_F(HTTP2CodecTest, LongData) {\n  // Hack the max frame size artificially low\n  HTTPSettings* settings = (HTTPSettings*)upstreamCodec_.getIngressSettings();\n  settings->setSetting(SettingsId::MAX_FRAME_SIZE, 16);\n  auto buf = makeBuf(100);\n  upstreamCodec_.generateBody(output_, 1, buf->clone(), HTTPCodec::NoPadding,\n                              true);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 7);\n  EXPECT_EQ(callbacks_.bodyLength, 100);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), buf->moveToFbString());\n}\n\nTEST_F(HTTP2CodecTest, MalformedPaddingLength) {\n  const uint8_t badInput[] = {0x50, 0x52, 0x49, 0x20, 0x2a, 0x20, 0x48, 0x54,\n                              0x54, 0x50, 0x2f, 0x32, 0x2e, 0x30, 0x0d, 0x0a,\n                              0x0d, 0x0a, 0x53, 0x4d, 0x0d, 0x0a, 0x0d, 0x0a,\n                              0x00, 0x00, 0x7e, 0x00, 0x6f, 0x6f, 0x6f, 0x6f,\n                              // The padding length byte below is 0x82 (130\n                              // in decimal) which is greater than the length\n                              // specified by the header's length field, 126\n                              0x01, 0x82, 0x87, 0x44, 0x87, 0x92, 0x97, 0x92,\n                              0x92, 0x92, 0x7a, 0x0b, 0x41, 0x89, 0xf1, 0xe3,\n                              0xc0, 0xf2, 0x9c, 0xdd, 0x90, 0xf4, 0xff, 0x40,\n                              0x80, 0x84, 0x2d, 0x35, 0xa7, 0xd7};\n  output_.clear();\n  output_.append(badInput, sizeof(badInput));\n  EXPECT_EQ(output_.chainLength(), sizeof(badInput));\n\n  EXPECT_FALSE(parse());\n}\n\nTEST_F(HTTP2CodecTest, MalformedPadding) {\n  const uint8_t badInput[] = {\n    0x00, 0x00, 0x0d, 0x01, 0xbe, 0x63, 0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x73,\n    0x00, 0x00, 0x06, 0x08, 0x72, 0x00, 0x24, 0x00, 0xfa, 0x4d, 0x0d\n  };\n  output_.append(badInput, sizeof(badInput));\n\n  EXPECT_FALSE(parse());\n}\n\nTEST_F(HTTP2CodecTest, NoAppByte) {\n  const uint8_t noAppByte[] = {0x50, 0x52, 0x49, 0x20, 0x2a, 0x20, 0x48, 0x54,\n                               0x54, 0x50, 0x2f, 0x32, 0x2e, 0x30, 0x0d, 0x0a,\n                               0x0d, 0x0a, 0x53, 0x4d, 0x0d, 0x0a, 0x0d, 0x0a,\n                               0x00, 0x00, 0x56, 0x00, 0x5d, 0x00, 0x00, 0x00,\n                               0x01, 0x55, 0x00};\n  output_.clear();\n  output_.append(noAppByte, sizeof(noAppByte));\n  EXPECT_EQ(output_.chainLength(), sizeof(noAppByte));\n\n  EXPECT_TRUE(parse());\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, DataFramePartialDataOnFrameHeaderCall) {\n  using namespace testing;\n  NiceMock<MockHTTPCodecCallback> mockCallback;\n  EXPECT_CALL(mockCallback, onFrameHeader(_, _, _, _, _));\n\n  const size_t bufSize = 10;\n  auto buf = makeBuf(bufSize);\n  const size_t padding = 10;\n  upstreamCodec_.generateBody(output_, 1, buf->clone(), padding, true);\n  EXPECT_EQ(output_.chainLength(), 54);\n\n  downstreamCodec_.setCallback(&mockCallback);\n\n  auto ingress = output_.move();\n  ingress->coalesce();\n  // Copy partial byte to a new buffer\n  auto ingress1 = IOBuf::copyBuffer(ingress->data(), 34);\n  downstreamCodec_.onIngress(*ingress1);\n}\n\nTEST_F(HTTP2CodecTest, DataFramePartialDataWithNoAppByte) {\n  const size_t bufSize = 10;\n  auto buf = makeBuf(bufSize);\n  const size_t padding = 10;\n  upstreamCodec_.generateBody(output_, 1, buf->clone(), padding, true);\n  EXPECT_EQ(output_.chainLength(), 54);\n\n  auto ingress = output_.move();\n  ingress->coalesce();\n  // Copy up to the padding length byte to a new buffer\n  auto ingress1 = IOBuf::copyBuffer(ingress->data(), 34);\n  size_t parsed = downstreamCodec_.onIngress(*ingress1);\n  // The 34th byte is the padding length byte which should not be parsed\n  EXPECT_EQ(parsed, 33);\n  // Copy from the padding length byte to the end\n  auto ingress2 = IOBuf::copyBuffer(ingress->data() + 33, 21);\n  parsed = downstreamCodec_.onIngress(*ingress2);\n  // The padding length byte should be parsed this time along with 10 bytes of\n  // application data and 10 bytes of padding\n  EXPECT_EQ(parsed, 21);\n\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, bufSize);\n  // Total padding is the padding length byte and the padding bytes\n  EXPECT_EQ(callbacks_.paddingBytes, padding + 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), buf->moveToFbString());\n}\n\nTEST_F(HTTP2CodecTest, BasicRst) {\n  upstreamCodec_.generateRstStream(output_, 2, ErrorCode::ENHANCE_YOUR_CALM);\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.aborts, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicRstInvalidCode) {\n  upstreamCodec_.generateRstStream(output_, 2, ErrorCode::_SPDY_INVALID_STREAM);\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.aborts, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicPing) {\n  upstreamCodec_.generatePingRequest(output_);\n  upstreamCodec_.generatePingReply(output_, 17);\n\n  uint64_t pingReq;\n  parse([&] (IOBuf* ingress) {\n      folly::io::Cursor c(ingress);\n      c.skip(http2::kFrameHeaderSize + http2::kConnectionPreface.length());\n      pingReq = c.read<uint64_t>();\n    });\n\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.recvPingRequest, pingReq);\n  EXPECT_EQ(callbacks_.recvPingReply, 17);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicWindow) {\n  // This test would fail if the codec had window state\n  upstreamCodec_.generateWindowUpdate(output_, 0, 10);\n  upstreamCodec_.generateWindowUpdate(output_, 0, http2::kMaxWindowUpdateSize);\n  upstreamCodec_.generateWindowUpdate(output_, 1, 12);\n  upstreamCodec_.generateWindowUpdate(output_, 1, http2::kMaxWindowUpdateSize);\n\n  parse();\n  EXPECT_EQ(callbacks_.windowUpdateCalls, 4);\n  EXPECT_EQ(callbacks_.windowUpdates[0],\n            std::vector<uint32_t>({10, http2::kMaxWindowUpdateSize}));\n  EXPECT_EQ(callbacks_.windowUpdates[1],\n            std::vector<uint32_t>({12, http2::kMaxWindowUpdateSize}));\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, ZeroWindow) {\n  auto streamID = HTTPCodec::StreamID(1);\n  // First generate a frame with delta=1 so as to pass the checks, and then\n  // hack the frame so that delta=0 without modifying other checks\n  upstreamCodec_.generateWindowUpdate(output_, streamID, 1);\n  output_.trimEnd(http2::kFrameWindowUpdateSize);\n  QueueAppender appender(&output_, http2::kFrameWindowUpdateSize);\n  appender.writeBE<uint32_t>(0);\n\n  parse();\n  // This test doesn't ensure that RST_STREAM is generated\n  EXPECT_EQ(callbacks_.windowUpdateCalls, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.lastParseError->getCodecStatusCode(),\n      ErrorCode::PROTOCOL_ERROR);\n}\n\nTEST_F(HTTP2CodecTest, BasicGoaway) {\n  std::unique_ptr<folly::IOBuf> debugData =\n    folly::IOBuf::copyBuffer(\"debugData\");\n  upstreamCodec_.generateGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM,\n                                std::move(debugData));\n\n  parse();\n  EXPECT_EQ(callbacks_.goaways, 1);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), \"debugData\");\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadGoaway) {\n  std::unique_ptr<folly::IOBuf> debugData =\n    folly::IOBuf::copyBuffer(\"debugData\");\n  upstreamCodec_.generateGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM,\n                                std::move(debugData));\n  EXPECT_DEATH_NO_CORE(upstreamCodec_.generateGoaway(\n                         output_, 27, ErrorCode::ENHANCE_YOUR_CALM), \".*\");\n}\n\nTEST_F(HTTP2CodecTest, DoubleGoaway) {\n  parse();\n  SetUpUpstreamTest();\n  downstreamCodec_.generateGoaway(output_, std::numeric_limits<int32_t>::max(),\n                                  ErrorCode::NO_ERROR);\n  EXPECT_TRUE(downstreamCodec_.isWaitingToDrain());\n  EXPECT_TRUE(downstreamCodec_.isReusable());\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(2));\n  downstreamCodec_.generateGoaway(output_, 0, ErrorCode::NO_ERROR);\n  EXPECT_FALSE(downstreamCodec_.isWaitingToDrain());\n  EXPECT_FALSE(downstreamCodec_.isReusable());\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_FALSE(downstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(2));\n\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(2));\n  parseUpstream();\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_FALSE(upstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(2));\n  EXPECT_EQ(callbacks_.goaways, 2);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n\n  upstreamCodec_.generateGoaway(output_, 0, ErrorCode::NO_ERROR);\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_FALSE(upstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_FALSE(upstreamCodec_.isStreamIngressEgressAllowed(2));\n  parse();\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_FALSE(downstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_FALSE(downstreamCodec_.isStreamIngressEgressAllowed(2));\n}\n\nTEST_F(HTTP2CodecTest, DoubleGoawayWithError) {\n  SetUpUpstreamTest();\n  std::unique_ptr<folly::IOBuf> debugData =\n    folly::IOBuf::copyBuffer(\"debugData\");\n  downstreamCodec_.generateGoaway(output_, std::numeric_limits<int32_t>::max(),\n                                  ErrorCode::ENHANCE_YOUR_CALM,\n                                  std::move(debugData));\n  EXPECT_FALSE(downstreamCodec_.isWaitingToDrain());\n  EXPECT_FALSE(downstreamCodec_.isReusable());\n  auto ret = downstreamCodec_.generateGoaway(output_, 0,\n                                             ErrorCode::NO_ERROR);\n  EXPECT_EQ(ret, 0);\n\n  parseUpstream();\n  EXPECT_EQ(callbacks_.goaways, 1);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), \"debugData\");\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, GoawayHandling) {\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::ENABLE_PUSH, 1);\n  upstreamCodec_.generateSettings(output_);\n\n  // send request\n  HTTPMessage req = getGetRequest();\n  HTTPHeaderSize size;\n  size.uncompressed = size.compressed = 0;\n  upstreamCodec_.generateHeader(output_, 1, req, true, &size);\n  EXPECT_GT(size.uncompressed, 0);\n  parse();\n  callbacks_.expectMessage(true, 1, \"/\");\n  callbacks_.reset();\n\n  SetUpUpstreamTest();\n  // drain after this message\n  downstreamCodec_.generateGoaway(output_, 1, ErrorCode::NO_ERROR);\n  parseUpstream();\n  // upstream cannot generate id > 1\n  upstreamCodec_.generateHeader(output_, 3, req, false, &size);\n  EXPECT_EQ(size.uncompressed, 0);\n  upstreamCodec_.generateWindowUpdate(output_, 3, 100);\n  upstreamCodec_.generateBody(output_, 3, makeBuf(10), HTTPCodec::NoPadding,\n                              false);\n  upstreamCodec_.generatePriority(output_, 3,\n                                  HTTPMessage::HTTPPriority(0, true, 1));\n  upstreamCodec_.generateEOM(output_, 3);\n  upstreamCodec_.generateRstStream(output_, 3, ErrorCode::CANCEL);\n  EXPECT_EQ(output_.chainLength(), 0);\n\n  // send a push promise that will be rejected by downstream\n  req.getHeaders().add(\"foomonkey\", \"george\");\n  downstreamCodec_.generatePushPromise(output_, 2, req, 1, false, &size);\n  EXPECT_GT(size.uncompressed, 0);\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  // send a push response that will be ignored\n  downstreamCodec_.generateHeader(output_, 2, resp, false, &size);\n  // window update for push doesn't make any sense, but whatever\n  downstreamCodec_.generateWindowUpdate(output_, 2, 100);\n  downstreamCodec_.generateBody(output_, 2, makeBuf(10), HTTPCodec::NoPadding,\n                                false);\n  writeFrameHeaderManual(output_, 20, (uint8_t)http2::FrameType::DATA, 0, 2);\n  output_.append(makeBuf(10));\n\n  // tell the upstream no pushing, and parse the first batch\n  IOBufQueue dummy;\n  upstreamCodec_.generateGoaway(dummy, 0, ErrorCode::NO_ERROR);\n  parseUpstream();\n\n  output_.append(makeBuf(10));\n  downstreamCodec_.generatePriority(output_, 2,\n                                    HTTPMessage::HTTPPriority(0, true, 1));\n  downstreamCodec_.generateEOM(output_, 2);\n  downstreamCodec_.generateRstStream(output_, 2, ErrorCode::CANCEL);\n\n  // send a response that will be accepted, headers should be ok\n  downstreamCodec_.generateHeader(output_, 1, resp, true, &size);\n  EXPECT_GT(size.uncompressed, 0);\n\n  // parse the remainder\n  parseUpstream();\n  callbacks_.expectMessage(true, 1, 200);\n}\n\nTEST_F(HTTP2CodecTest, GoawayReply) {\n  upstreamCodec_.generateGoaway(output_, 0, ErrorCode::NO_ERROR);\n\n  parse();\n  EXPECT_EQ(callbacks_.goaways, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n  downstreamCodec_.generateEOM(output_, 1);\n  parseUpstream();\n  callbacks_.expectMessage(true, 1, 200);\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n}\n\nTEST_F(HTTP2CodecTest, BasicSetting) {\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::MAX_CONCURRENT_STREAMS, 37);\n  settings->setSetting(SettingsId::INITIAL_WINDOW_SIZE, 12345);\n  upstreamCodec_.generateSettings(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.maxStreams, 37);\n  EXPECT_EQ(callbacks_.windowSize, 12345);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, SettingsAck) {\n  upstreamCodec_.generateSettingsAck(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 0);\n  EXPECT_EQ(callbacks_.settingsAcks, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadSettings) {\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::INITIAL_WINDOW_SIZE, 0xffffffff);\n  upstreamCodec_.generateSettings(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, BadPushSettings) {\n  auto settings = downstreamCodec_.getEgressSettings();\n  settings->clearSettings();\n  settings->setSetting(SettingsId::ENABLE_PUSH, 0);\n  SetUpUpstreamTest();\n\n  parseUpstream([&] (IOBuf* ingress) {\n      EXPECT_EQ(ingress->computeChainDataLength(), http2::kFrameHeaderSize);\n    });\n  EXPECT_FALSE(upstreamCodec_.supportsPushTransactions());\n  // Only way to disable push for downstreamCodec_ is to read\n  // ENABLE_PUSH:0 from client\n  EXPECT_TRUE(downstreamCodec_.supportsPushTransactions());\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\n\nTEST_F(HTTP2CodecTest, SettingsTableSize) {\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::HEADER_TABLE_SIZE, 8192);\n  upstreamCodec_.generateSettings(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  downstreamCodec_.generateSettingsAck(output_);\n  parseUpstream();\n\n  callbacks_.reset();\n\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  SetUpUpstreamTest();\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  parseUpstream();\n  callbacks_.expectMessage(false, 2, 200);\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n}\n\nTEST_F(HTTP2CodecTest, BadSettingsTableSize) {\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::HEADER_TABLE_SIZE, 8192);\n  // This sets the max decoder table size to 8k\n  upstreamCodec_.generateSettings(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n\n  callbacks_.reset();\n\n  // Attempt to set a new max table size.  This is a no-op because the first,\n  // setting is unacknowledged.  The upstream encoder will up the table size to\n  // 8k per the first settings frame and the HPACK codec will send a code to\n  // update the decoder.\n  settings->setSetting(SettingsId::HEADER_TABLE_SIZE, 4096);\n\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  SetUpUpstreamTest();\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  parseUpstream();\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n}\n\nTEST_F(HTTP2CodecTest, SettingsTableSizeEarlyShrink) {\n  // Lower size to 2k\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::HEADER_TABLE_SIZE, 2048);\n  upstreamCodec_.generateSettings(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  downstreamCodec_.generateSettingsAck(output_);\n  // Parsing SETTINGS ack updates upstream decoder to 2k\n  parseUpstream();\n\n  callbacks_.reset();\n\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  SetUpUpstreamTest();\n  // downstream encoder will send TSU/2k\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  // sets pending table size to 512, but doesn't update it yet\n  settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::HEADER_TABLE_SIZE, 512);\n  IOBufQueue tmp{IOBufQueue::cacheChainLength()};\n  upstreamCodec_.generateSettings(tmp);\n\n  // Previous code would barf here, since TSU/2k is a violation of the current\n  // max=512\n  parseUpstream();\n  callbacks_.expectMessage(false, 2, 200);\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n}\n\nTEST_F(HTTP2CodecTest, BasicPriority) {\n  auto pri = HTTPMessage::HTTPPriority(0, true, 1);\n  upstreamCodec_.generatePriority(output_, 1, pri);\n\n  EXPECT_TRUE(parse());\n  EXPECT_EQ(callbacks_.priority, pri);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadHeaderPriority) {\n  HTTPMessage req = getGetRequest();\n  req.setHTTP2Priority(HTTPMessage::HTTPPriority(0, false, 7));\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  // hack ingress with cirular dep\n  EXPECT_TRUE(parse([&] (IOBuf* ingress) {\n        folly::io::RWPrivateCursor c(ingress);\n        c.skip(http2::kFrameHeaderSize + http2::kConnectionPreface.length());\n        c.writeBE<uint32_t>(1);\n      }));\n\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, DuplicateBadHeaderPriority) {\n  // Sent an initial header with a circular dependency\n  HTTPMessage req = getGetRequest();\n  req.setHTTP2Priority(HTTPMessage::HTTPPriority(0, false, 7));\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  // Hack ingress with circular dependency.\n  EXPECT_TRUE(parse([&](IOBuf* ingress) {\n    folly::io::RWPrivateCursor c(ingress);\n    c.skip(http2::kFrameHeaderSize + http2::kConnectionPreface.length());\n    c.writeBE<uint32_t>(1);\n  }));\n\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n\n  // On the same stream, send another request.\n  HTTPMessage nextRequest = getGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, nextRequest, true /* eom */);\n  parse();\n  EXPECT_EQ(callbacks_.streamErrors, 2);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadPriority) {\n  auto pri = HTTPMessage::HTTPPriority(0, true, 1);\n  upstreamCodec_.generatePriority(output_, 1, pri);\n\n  // hack ingress with cirular dep\n  EXPECT_TRUE(parse([&] (IOBuf* ingress) {\n        folly::io::RWPrivateCursor c(ingress);\n        c.skip(http2::kFrameHeaderSize + http2::kConnectionPreface.length());\n        c.writeBE<uint32_t>(1);\n      }));\n\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nclass DummyQueue: public HTTPCodec::PriorityQueue {\n public:\n  DummyQueue() {}\n  ~DummyQueue() override {}\n  void addPriorityNode(HTTPCodec::StreamID id, HTTPCodec::StreamID) override {\n    nodes_.push_back(id);\n  }\n\n  std::vector<HTTPCodec::StreamID> nodes_;\n};\n\nTEST_F(HTTP2CodecTest, VirtualNodes) {\n  DummyQueue queue;\n  uint8_t level = 30;\n  upstreamCodec_.addPriorityNodes(queue, output_, level);\n\n  EXPECT_TRUE(parse());\n  for (int i = 0; i < level; i++) {\n    EXPECT_EQ(queue.nodes_[i], upstreamCodec_.mapPriorityToDependency(i));\n  }\n\n  // Out-of-range priorites are mapped to the lowest level of virtual nodes.\n  EXPECT_EQ(queue.nodes_[level - 1],\n            upstreamCodec_.mapPriorityToDependency(level));\n  EXPECT_EQ(queue.nodes_[level - 1],\n            upstreamCodec_.mapPriorityToDependency(level + 1));\n}\n\nTEST_F(HTTP2CodecTest, BasicPushPromise) {\n  upstreamCodec_.generateSettings(output_);\n  parse();\n  EXPECT_FALSE(upstreamCodec_.supportsPushTransactions());\n  EXPECT_FALSE(downstreamCodec_.supportsPushTransactions());\n\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::ENABLE_PUSH, 1);\n  upstreamCodec_.generateSettings(output_);\n  parse();\n  EXPECT_TRUE(upstreamCodec_.supportsPushTransactions());\n  EXPECT_TRUE(downstreamCodec_.supportsPushTransactions());\n\n  SetUpUpstreamTest();\n\n  HTTPCodec::StreamID assocStream = 7;\n  for (auto i = 0; i < 2; i++) {\n    // Push promise\n    HTTPCodec::StreamID pushStream = downstreamCodec_.createStream();\n    HTTPMessage req = getGetRequest();\n    req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n    downstreamCodec_.generatePushPromise(output_, pushStream, req, assocStream);\n\n    parseUpstream();\n    callbacks_.expectMessage(false, 2, \"/\"); // + host\n    EXPECT_EQ(callbacks_.assocStreamId, assocStream);\n    EXPECT_EQ(callbacks_.headersCompleteId, pushStream);\n    auto& headers = callbacks_.msg->getHeaders();\n    EXPECT_EQ(\"coolio\", headers.getSingleOrEmpty(HTTP_HEADER_USER_AGENT));\n    callbacks_.reset();\n\n    // Actual reply headers\n    HTTPMessage resp;\n    resp.setStatusCode(200);\n    resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"text/plain\");\n    downstreamCodec_.generateHeader(output_, pushStream, resp);\n\n    parseUpstream();\n    callbacks_.expectMessage(false, 2, 200);\n    EXPECT_EQ(callbacks_.headersCompleteId, pushStream);\n    EXPECT_EQ(callbacks_.assocStreamId, 0);\n    EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n    EXPECT_EQ(\"text/plain\", callbacks_.msg->getHeaders().getSingleOrEmpty(\n                  HTTP_HEADER_CONTENT_TYPE));\n    callbacks_.reset();\n  }\n}\n\nTEST_F(HTTP2CodecTest, BadPushPromise) {\n  // ENABLE_PUSH is now 0 by default\n  SetUpUpstreamTest();\n  HTTPMessage req = getGetRequest();\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  downstreamCodec_.generatePushPromise(output_, 2, req, 1);\n\n  parseUpstream();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.assocStreamId, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, BasicCertificateRequest) {\n  uint16_t requestId = 17;\n  std::unique_ptr<folly::IOBuf> authRequest =\n      folly::IOBuf::copyBuffer(\"authRequestData\");\n  upstreamCodec_.generateCertificateRequest(\n      output_, requestId, std::move(authRequest));\n\n  parse();\n  EXPECT_EQ(callbacks_.certificateRequests, 1);\n  EXPECT_EQ(callbacks_.lastCertRequestId, requestId);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), \"authRequestData\");\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicCertificate) {\n  uint16_t certId = 17;\n  std::unique_ptr<folly::IOBuf> authenticator =\n      folly::IOBuf::copyBuffer(\"authenticatorData\");\n  upstreamCodec_.generateCertificate(output_, certId, std::move(authenticator));\n\n  parse();\n  EXPECT_EQ(callbacks_.certificates, 1);\n  EXPECT_EQ(callbacks_.lastCertId, certId);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), \"authenticatorData\");\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadServerPreface) {\n  output_.move();\n  downstreamCodec_.generateWindowUpdate(output_, 0, 10);\n  parseUpstream();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.assocStreamId, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, Normal1024Continuation) {\n  HTTPMessage req = getGetRequest();\n  string bigval(8691, '!');\n  bigval.append(8691, ' ');\n  req.getHeaders().add(\"x-headr\", bigval);\n  req.setHTTP2Priority(HTTPMessage::HTTPPriority(0, false, 7));\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  parse();\n  callbacks_.expectMessage(false, -1, \"/\");\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(bigval, headers.getSingleOrEmpty(\"x-headr\"));\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n\n  upstreamCodec_.generateSettingsAck(output_);\n  parse();\n  EXPECT_EQ(callbacks_.settingsAcks, 1);\n}\n\nTEST_F(HTTP2CodecTest, StreamIdOverflow) {\n  HTTP2Codec codec(TransportDirection::UPSTREAM);\n\n  HTTPCodec::StreamID streamId;\n  codec.setNextEgressStreamId(std::numeric_limits<int32_t>::max() - 10);\n  while (codec.isReusable()) {\n    streamId = codec.createStream();\n  }\n  EXPECT_EQ(streamId, std::numeric_limits<int32_t>::max() - 2);\n}\n\nTEST_F(HTTP2CodecTest, TestMultipleDifferentContentLengthHeaders) {\n  // Generate a POST request with two Content-Length headers\n  // NOTE: getPostRequest already adds the content-length\n  HTTPMessage req = getPostRequest();\n  req.getHeaders().add(HTTP_HEADER_CONTENT_LENGTH, \"300\");\n  EXPECT_EQ(req.getHeaders().getNumberOfValues(HTTP_HEADER_CONTENT_LENGTH), 2);\n\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n  parse();\n\n  // Check that the request fails before the codec finishes parsing the headers\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.lastParseError->getHttpStatusCode(), 400);\n}\n\nTEST_F(HTTP2CodecTest, TestMultipleIdenticalContentLengthHeaders) {\n  // Generate a POST request with two Content-Length headers\n  // NOTE: getPostRequest already adds the content-length\n  HTTPMessage req = getPostRequest();\n  req.getHeaders().add(\"content-length\", \"200\");\n  EXPECT_EQ(req.getHeaders().getNumberOfValues(\"content-length\"), 2);\n\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n  parse();\n\n  // Check that the headers parsing completes correctly\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n}\n\nTEST_F(HTTP2CodecTest, CleartextUpgrade) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  HTTP2Codec::requestUpgrade(req);\n  EXPECT_EQ(req.getHeaders().getSingleOrEmpty(HTTP_HEADER_UPGRADE), \"h2c\");\n  EXPECT_TRUE(req.checkForHeaderToken(HTTP_HEADER_CONNECTION,\n                                      \"Upgrade\", false));\n  EXPECT_TRUE(req.checkForHeaderToken(\n                HTTP_HEADER_CONNECTION,\n                http2::kProtocolSettingsHeader.c_str(), false));\n  EXPECT_GT(\n    req.getHeaders().getSingleOrEmpty(http2::kProtocolSettingsHeader).length(),\n    0);\n}\n\nTEST_F(HTTP2CodecTest, HTTP2SettingsSuccess) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n\n  // empty settings\n  req.getHeaders().add(http2::kProtocolSettingsHeader, \"\");\n  EXPECT_TRUE(downstreamCodec_.onIngressUpgradeMessage(req));\n\n  // real settings (overwrites empty)\n  HTTP2Codec::requestUpgrade(req);\n  EXPECT_TRUE(downstreamCodec_.onIngressUpgradeMessage(req));\n}\n\nTEST_F(HTTP2CodecTest, HTTP2SettingsFailure) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  // no settings\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n\n  HTTPHeaders& headers = req.getHeaders();\n\n  // Not base64_url settings\n  headers.set(http2::kProtocolSettingsHeader, \"????\");\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n  headers.set(http2::kProtocolSettingsHeader, \"AAA\");\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n\n  // Too big\n  string bigSettings((http2::kMaxFramePayloadLength + 1) * 4 / 3, 'A');\n  headers.set(http2::kProtocolSettingsHeader, bigSettings);\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n\n  // Malformed (not a multiple of 6)\n  headers.set(http2::kProtocolSettingsHeader, \"AAAA\");\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n\n  // Two headers\n  headers.set(http2::kProtocolSettingsHeader, \"AAAAAAAA\");\n  headers.add(http2::kProtocolSettingsHeader, \"AAAAAAAA\");\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n}\n\nTEST_F(HTTP2CodecTest, HTTP2EnableConnect) {\n  SetUpUpstreamTest();\n  // egress settings have no connect settings.\n  auto ws_enable = upstreamCodec_.getEgressSettings()->getSetting(\n      SettingsId::ENABLE_CONNECT_PROTOCOL);\n  // enable connect settings, and check.\n  upstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_CONNECT_PROTOCOL, 1);\n  ws_enable = upstreamCodec_.getEgressSettings()->getSetting(\n      SettingsId::ENABLE_CONNECT_PROTOCOL);\n  EXPECT_EQ(ws_enable->value, 1);\n  // generateSettings.\n  // pass the buffer to be parsed by the codec and check for ingress settings.\n  upstreamCodec_.generateSettings(output_);\n  parseUpstream();\n  EXPECT_EQ(1, upstreamCodec_.peerHasWebsockets());\n}\n\nTEST_F(HTTP2CodecTest, WebsocketUpgrade) {\n  HTTPMessage req = getGetRequest(\"/apples\");\n  req.setSecure(true);\n  req.setEgressWebsocketUpgrade();\n\n  upstreamCodec_.generateHeader(output_, 1, req, false);\n  parse();\n\n  EXPECT_TRUE(callbacks_.msg->isIngressWebsocketUpgrade());\n  EXPECT_NE(nullptr, callbacks_.msg->getUpgradeProtocol());\n  EXPECT_EQ(headers::kWebsocketString, *callbacks_.msg->getUpgradeProtocol());\n}\n\nTEST_F(HTTP2CodecTest, WebsocketBadHeader) {\n  const std::string kConnect{\"CONNECT\"};\n  const std::string kWebsocketPath{\"/websocket\"};\n  const std::string kSchemeHttps{\"https\"};\n  vector<proxygen::compress::Header> reqHeaders = {\n    Header::makeHeaderForTest(headers::kMethod, kConnect),\n    Header::makeHeaderForTest(headers::kProtocol, headers::kWebsocketString),\n  };\n  vector<proxygen::compress::Header> optionalHeaders = {\n    Header::makeHeaderForTest(headers::kPath, kWebsocketPath),\n    Header::makeHeaderForTest(headers::kScheme, kSchemeHttps),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  int stream = 1;\n  for (size_t i = 0; i < optionalHeaders.size(); ++i, stream += 2) {\n    auto headers = reqHeaders;\n    headers.push_back(optionalHeaders[i]);\n    auto encodedHeaders = headerCodec.encode(headers);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        false,\n                        true);\n    parse();\n  }\n\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, optionalHeaders.size());\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, WebsocketDupProtocol) {\n  const std::string kConnect{\"CONNECT\"};\n  const std::string kWebsocketPath{\"/websocket\"};\n  const std::string kSchemeHttps{\"https\"};\n  vector<proxygen::compress::Header> headers = {\n    Header::makeHeaderForTest(headers::kMethod, kConnect),\n    Header::makeHeaderForTest(headers::kProtocol, headers::kWebsocketString),\n    Header::makeHeaderForTest(headers::kProtocol, headers::kWebsocketString),\n    Header::makeHeaderForTest(headers::kPath, kWebsocketPath),\n    Header::makeHeaderForTest(headers::kScheme, kSchemeHttps),\n  };\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  auto encodedHeaders = headerCodec.encode(headers);\n  http2::writeHeaders(output_,\n                      std::move(encodedHeaders),\n                      1,\n                      folly::none,\n                      http2::kNoPadding,\n                      false,\n                      true);\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, WebsocketIncorrectResponse) {\n  parse();\n  SetUpUpstreamTest();\n  parseUpstream();\n\n  output_.clear();\n  HTTPMessage req = getGetRequest(\"/apples\");\n  req.setSecure(true);\n  req.setEgressWebsocketUpgrade();\n  upstreamCodec_.generateHeader(output_, 1, req, false);\n  parse();\n\n  output_.clear();\n  HTTPMessage resp;\n  resp.setStatusCode(201);\n  resp.setStatusMessage(\"OK\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n  parseUpstream();\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, TestAllEgressFrameTypeCallbacks) {\n  class CallbackTypeTracker {\n    std::set<uint8_t> types;\n  public:\n    void add(uint8_t, uint8_t type, uint64_t, uint16_t) {\n      types.insert(type);\n    }\n\n    bool isAllFrameTypesReceived() {\n      http2::FrameType expectedTypes[] = {\n        http2::FrameType::DATA,\n        http2::FrameType::HEADERS,\n        http2::FrameType::PRIORITY,\n        http2::FrameType::RST_STREAM,\n        http2::FrameType::SETTINGS,\n        http2::FrameType::PUSH_PROMISE,\n        http2::FrameType::PING,\n        http2::FrameType::GOAWAY,\n        http2::FrameType::WINDOW_UPDATE,\n        http2::FrameType::CONTINUATION,\n        http2::FrameType::EX_HEADERS,\n      };\n\n      for(http2::FrameType type: expectedTypes) {\n        EXPECT_TRUE(types.find(static_cast<uint8_t>(type)) != types.end())\n          << \"callback missing for type \" << static_cast<uint8_t>(type);\n      }\n      return types.size() == (sizeof(expectedTypes)/sizeof(http2::FrameType));\n    }\n  };\n\n  CallbackTypeTracker callbackTypeTracker;\n\n  NiceMock<MockHTTPCodecCallback> mockCallback;\n  upstreamCodec_.setCallback(&mockCallback);\n  downstreamCodec_.setCallback(&mockCallback);\n  EXPECT_CALL(mockCallback, onGenerateFrameHeader(_, _, _, _)).\n    WillRepeatedly(Invoke(&callbackTypeTracker, &CallbackTypeTracker::add));\n\n  // DATA frame\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  upstreamCodec_.generateBody(output_, 2, std::move(buf),\n                              HTTPCodec::NoPadding, true);\n\n  HTTPHeaderSize size;\n  size.uncompressed = size.compressed = 0;\n  HTTPMessage req = getGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req, true, &size);\n\n  upstreamCodec_.generatePriority(output_, 3,\n                                  HTTPMessage::HTTPPriority(0, true, 1));\n  upstreamCodec_.generateRstStream(output_, 2, ErrorCode::ENHANCE_YOUR_CALM);\n  upstreamCodec_.generateSettings(output_);\n  downstreamCodec_.generatePushPromise(output_, 2, req, 1);\n  upstreamCodec_.generatePingRequest(output_);\n\n  std::unique_ptr<folly::IOBuf> debugData =\n      folly::IOBuf::copyBuffer(\"debugData\");\n  upstreamCodec_.generateGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM,\n                                std::move(debugData));\n\n  upstreamCodec_.generateWindowUpdate(output_, 0, 10);\n\n  HTTPCodec::StreamID stream = folly::Random::rand32(10, 1024) * 2;\n  HTTPCodec::StreamID controlStream = folly::Random::rand32(10, 1024) * 2 + 1;\n  downstreamCodec_.generateExHeader(output_, stream, req,\n    HTTPCodec::ExAttributes(controlStream, true));\n\n  // Tests the continuation frame\n  req = getBigGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  EXPECT_TRUE(callbackTypeTracker.isAllFrameTypesReceived());\n}\n\nTEST_F(HTTP2CodecTest, Trailers) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  upstreamCodec_.generateBody(\n      output_, 1, std::move(buf), HTTPCodec::NoPadding, false /* eom */);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  upstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parse();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, 5);\n  EXPECT_EQ(callbacks_.trailers, 1);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 3);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersWithPseudoHeaders) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  upstreamCodec_.generateBody(\n      output_, 1, std::move(buf), HTTPCodec::NoPadding, false /* eom */);\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  std::string post(\"POST\");\n  std::vector<proxygen::compress::Header> trailers = {\n      Header::makeHeaderForTest(headers::kMethod, post)};\n  auto encodedTrailers = headerCodec.encode(trailers);\n  http2::writeHeaders(output_,\n                      std::move(encodedTrailers),\n                      1,\n                      folly::none,\n                      http2::kNoPadding,\n                      true,\n                      true);\n\n  parse();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, 5);\n  EXPECT_EQ(callbacks_.trailers, 0);\n  EXPECT_EQ(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, TrailersNoBody) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  upstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parse();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.bodyLength, 0);\n  EXPECT_EQ(callbacks_.trailers, 1);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 2);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersContinuation) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  trailers.add(\"x-huge-trailer\",\n               std::string(http2::kMaxFramePayloadLengthMin, '!'));\n  upstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parse();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_NE(callbacks_.msg, nullptr);\n  EXPECT_EQ(callbacks_.trailers, 1);\n  EXPECT_NE(callbacks_.msg->getTrailers(), nullptr);\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(std::string(http2::kMaxFramePayloadLengthMin, '!'),\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-huge-trailer\"));\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 3);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersReply) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  downstreamCodec_.generateBody(\n      output_, 1, std::move(buf), HTTPCodec::NoPadding, false);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  trailers.add(\"x-trailer-2\", \"chicken-kyiv\");\n  downstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parseUpstream();\n\n  callbacks_.expectMessage(true, 2, 200);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, 5);\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n  EXPECT_EQ(1, callbacks_.trailers);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(\"chicken-kyiv\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-2\"));\n#ifndef NDEBUG\n  EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 4);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersReplyWithNoData) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  downstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parseUpstream();\n\n  callbacks_.expectMessage(true, 2, 200);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.bodyLength, 0);\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n  EXPECT_EQ(1, callbacks_.trailers);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n#ifndef NDEBUG\n  EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 3);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersReplyWithPseudoHeaders) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  downstreamCodec_.generateBody(\n      output_, 1, std::move(buf), HTTPCodec::NoPadding, false);\n\n  HPACKCodec headerCodec(TransportDirection::DOWNSTREAM);\n  std::string post(\"POST\");\n  std::vector<proxygen::compress::Header> trailers = {\n      Header::makeHeaderForTest(headers::kMethod, post)};\n  auto encodedTrailers = headerCodec.encode(trailers);\n  http2::writeHeaders(output_,\n                      std::move(encodedTrailers),\n                      1,\n                      folly::none,\n                      http2::kNoPadding,\n                      true,\n                      true);\n  parseUpstream();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.trailers, 0);\n  EXPECT_EQ(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, TrailersReplyContinuation) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  trailers.add(\"x-huge-trailer\",\n               std::string(http2::kMaxFramePayloadLengthMin, '!'));\n  downstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parseUpstream();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_NE(callbacks_.msg, nullptr);\n  EXPECT_EQ(callbacks_.msg->getStatusCode(), 200);\n  EXPECT_EQ(1, callbacks_.trailers);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(std::string(http2::kMaxFramePayloadLengthMin, '!'),\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-huge-trailer\"));\n#ifndef NDEBUG\n  EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 4);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersReplyMissingContinuation) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  trailers.add(\"x-huge-trailer\",\n               std::string(http2::kMaxFramePayloadLengthMin, '!'));\n  downstreamCodec_.generateTrailers(output_, 1, trailers);\n  // empirically determined the size of continuation frame, and strip it\n  output_.trimEnd(http2::kFrameHeaderSize + 4132);\n\n  // insert a non-continuation (but otherwise valid) frame\n  http2::writeGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM);\n\n  parseUpstream();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n#ifndef NDEBUG\n  EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 4);\n#endif\n}\n", "/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n#include <string>\n#include <vector>\n\n#include <folly/Conv.h>\n#include <folly/Range.h>\n#include <folly/futures/Promise.h>\n#include <folly/io/Cursor.h>\n#include <folly/io/async/EventBase.h>\n#include <folly/io/async/EventBaseManager.h>\n#include <folly/io/async/TimeoutManager.h>\n#include <folly/io/async/test/MockAsyncTransport.h>\n#include <folly/portability/GTest.h>\n#include <proxygen/lib/http/codec/HTTPCodecFactory.h>\n#include <proxygen/lib/http/codec/test/TestUtils.h>\n#include <proxygen/lib/http/session/HTTPDirectResponseHandler.h>\n#include <proxygen/lib/http/session/HTTPDownstreamSession.h>\n#include <proxygen/lib/http/session/HTTPSession.h>\n#include <proxygen/lib/http/session/test/HTTPSessionMocks.h>\n#include <proxygen/lib/http/session/test/HTTPSessionTest.h>\n#include <proxygen/lib/http/session/test/MockByteEventTracker.h>\n#include <proxygen/lib/http/session/test/TestUtils.h>\n#include <proxygen/lib/test/TestAsyncTransport.h>\n#include <wangle/acceptor/ConnectionManager.h>\n\nusing namespace folly::io;\nusing namespace wangle;\nusing namespace folly;\nusing namespace proxygen;\nusing namespace std;\nusing namespace testing;\nusing namespace std::chrono;\nusing folly::Promise;\n\ntemplate <typename C>\nclass HTTPDownstreamTest : public testing::Test {\n public:\n  explicit HTTPDownstreamTest(\n    std::vector<int64_t> flowControl = { -1, -1, -1 },\n    bool startImmediately = true)\n    : eventBase_(),\n      transport_(new TestAsyncTransport(&eventBase_)),\n      transactionTimeouts_(makeTimeoutSet(&eventBase_)),\n      flowControl_(flowControl) {\n    EXPECT_CALL(mockController_, getGracefulShutdownTimeout())\n      .WillRepeatedly(Return(std::chrono::milliseconds(0)));\n    EXPECT_CALL(mockController_, attachSession(_))\n      .WillRepeatedly(Invoke([&] (HTTPSessionBase* session) {\n        session->setPrioritySampled(true);\n      }));\n    HTTPSession::setDefaultReadBufferLimit(65536);\n    auto codec = makeServerCodec<typename C::Codec>(C::version);\n    rawCodec_ = codec.get();\n\n    // If the codec is H2, getHeaderIndexingStrategy will be called when setting\n    // up the codec\n    if (rawCodec_->getProtocol() == CodecProtocol::HTTP_2) {\n      EXPECT_CALL(mockController_, getHeaderIndexingStrategy())\n        .WillOnce(\n          Return(&testH2IndexingStrat_)\n      );\n    }\n\n    httpSession_ = new HTTPDownstreamSession(\n      transactionTimeouts_.get(),\n      std::move(AsyncTransportWrapper::UniquePtr(transport_)),\n      localAddr, peerAddr,\n      &mockController_,\n      std::move(codec),\n      mockTransportInfo /* no stats for now */,\n      nullptr);\n    for (auto& param: flowControl) {\n      if (param < 0) {\n        param = rawCodec_->getDefaultWindowSize();\n      }\n    }\n\n    // Ensure the H2 header indexing strategy was setup correctly if applicable\n    if (rawCodec_->getProtocol() == CodecProtocol::HTTP_2) {\n      HTTP2Codec* recastedCodec = dynamic_cast<HTTP2Codec*>(rawCodec_);\n      EXPECT_EQ(\n        recastedCodec->getHeaderIndexingStrategy(), &testH2IndexingStrat_);\n    }\n\n    httpSession_->setFlowControl(flowControl[0], flowControl[1],\n                                 flowControl[2]);\n    httpSession_->setEgressSettings({{ SettingsId::MAX_CONCURRENT_STREAMS, 80 },\n                                     { SettingsId::HEADER_TABLE_SIZE, 5555 },\n                                     { SettingsId::ENABLE_PUSH, 1 },\n                                     { SettingsId::ENABLE_EX_HEADERS, 1 }});\n    if (startImmediately) {\n      httpSession_->startNow();\n    }\n    clientCodec_ = makeClientCodec<typename C::Codec>(C::version);\n    if (clientCodec_->getProtocol() == CodecProtocol::HTTP_2) {\n      clientCodec_->getEgressSettings()->setSetting(\n        SettingsId::ENABLE_EX_HEADERS, 1);\n    }\n    clientCodec_->generateConnectionPreface(requests_);\n    clientCodec_->setCallback(&callbacks_);\n  }\n\n  HTTPCodec::StreamID sendRequest(const std::string& url = \"/\",\n                                  int8_t priority = 0,\n                                  bool eom = true) {\n    auto req = getGetRequest();\n    req.setURL(url);\n    req.setPriority(priority);\n    return sendRequest(req, eom);\n  }\n\n  HTTPCodec::StreamID sendRequest(const HTTPMessage& req, bool eom = true) {\n    auto streamID = clientCodec_->createStream();\n    clientCodec_->generateHeader(requests_, streamID, req, eom);\n    return streamID;\n  }\n\n  HTTPCodec::StreamID sendHeader() {\n    return sendRequest(\"/\", 0, false);\n  }\n\n  Promise<Unit> sendRequestLater(HTTPMessage req, bool eof=false) {\n    Promise<Unit> reqp;\n    reqp.getFuture().then(&eventBase_, [=] {\n        sendRequest(req);\n        transport_->addReadEvent(requests_, milliseconds(0));\n        if (eof) {\n          transport_->addReadEOF(milliseconds(0));\n        }\n      });\n    return reqp;\n  }\n\n  void SetUp() override {\n    folly::EventBaseManager::get()->clearEventBase();\n    HTTPSession::setDefaultWriteBufferLimit(65536);\n    HTTP2PriorityQueue::setNodeLifetime(std::chrono::milliseconds(2));\n  }\n\n  void cleanup() {\n    EXPECT_CALL(mockController_, detachSession(_));\n    httpSession_->dropConnection();\n  }\n\n\n  std::unique_ptr<testing::StrictMock<MockHTTPHandler>>\n  addSimpleStrictHandler() {\n    std::unique_ptr<testing::StrictMock<MockHTTPHandler>> handler =\n      std::make_unique<testing::StrictMock<MockHTTPHandler>>();\n\n    // The ownership model here is suspect, but assume the callers won't destroy\n    // handler before it's requested\n    auto rawHandler = handler.get();\n    EXPECT_CALL(mockController_, getRequestHandler(testing::_, testing::_))\n      .WillOnce(testing::Return(rawHandler))\n      .RetiresOnSaturation();\n\n    EXPECT_CALL(*handler, setTransaction(testing::_))\n      .WillOnce(testing::SaveArg<0>(&handler->txn_));\n\n    return handler;\n  }\n\n  std::unique_ptr<testing::NiceMock<MockHTTPHandler>>\n  addSimpleNiceHandler() {\n    std::unique_ptr<testing::NiceMock<MockHTTPHandler>> handler =\n      std::make_unique<testing::NiceMock<MockHTTPHandler>>();\n\n    // See comment above\n    auto rawHandler = handler.get();\n    EXPECT_CALL(mockController_, getRequestHandler(testing::_, testing::_))\n      .WillOnce(testing::Return(rawHandler))\n      .RetiresOnSaturation();\n\n    EXPECT_CALL(*handler, setTransaction(testing::_))\n      .WillOnce(testing::SaveArg<0>(&handler->txn_));\n\n    return handler;\n  }\n\n  void onEOMTerminateHandlerExpectShutdown(MockHTTPHandler& handler) {\n    handler.expectEOM([&] { handler.terminate(); });\n    handler.expectDetachTransaction();\n    expectDetachSession();\n  }\n\n  void expectDetachSession() {\n    EXPECT_CALL(mockController_, detachSession(testing::_));\n  }\n\n  void addSingleByteReads(const char* data, milliseconds delay={}) {\n    for (const char* p = data; *p != '\\0'; ++p) {\n      transport_->addReadEvent(p, 1, delay);\n    }\n  }\n\n  void flushRequestsAndLoop(\n    bool eof=false, milliseconds eofDelay=milliseconds(0),\n    milliseconds initialDelay=milliseconds(0),\n    std::function<void()> extraEventsFn = std::function<void()>()) {\n    flushRequests(eof, eofDelay, initialDelay, extraEventsFn);\n    eventBase_.loop();\n  }\n\n  void flushRequestsAndLoopN(uint64_t n,\n    bool eof=false, milliseconds eofDelay=milliseconds(0),\n    milliseconds initialDelay=milliseconds(0),\n    std::function<void()> extraEventsFn = std::function<void()>()) {\n    flushRequests(eof, eofDelay, initialDelay, extraEventsFn);\n    for (uint64_t i = 0; i < n; i++) {\n      eventBase_.loopOnce();\n    }\n  }\n\n  void flushRequests(\n    bool eof=false, milliseconds eofDelay=milliseconds(0),\n    milliseconds initialDelay=milliseconds(0),\n    std::function<void()> extraEventsFn = std::function<void()>()) {\n    transport_->addReadEvent(requests_, initialDelay);\n    if (extraEventsFn) {\n      extraEventsFn();\n    }\n    if (eof) {\n      transport_->addReadEOF(eofDelay);\n    }\n    transport_->startReadEvents();\n  }\n\n  void testSimpleUpgrade(\n    const std::string& upgradeHeader,\n    CodecProtocol expectedProtocol,\n    const std::string& expectedUpgradeHeader);\n\n  void gracefulShutdown() {\n    folly::DelayedDestruction::DestructorGuard g(httpSession_);\n    clientCodec_->generateGoaway(this->requests_, 0, ErrorCode::NO_ERROR);\n    expectDetachSession();\n    flushRequestsAndLoop(true);\n  }\n\n  void testPriorities(uint32_t numPriorities);\n\n  void testChunks(bool trailers);\n\n  void expect101(CodecProtocol expectedProtocol,\n                 const std::string& expectedUpgrade,\n                 bool expect100 = false) {\n    NiceMock<MockHTTPCodecCallback> callbacks;\n\n    EXPECT_CALL(callbacks, onMessageBegin(_, _));\n    EXPECT_CALL(callbacks, onNativeProtocolUpgrade(_, _, _, _))\n      .WillOnce(\n        Invoke([this, expectedUpgrade] (HTTPCodec::StreamID,\n                                        CodecProtocol,\n                                        const std::string&,\n                                        HTTPMessage& msg) {\n             EXPECT_EQ(msg.getStatusCode(), 101);\n             EXPECT_EQ(msg.getStatusMessage(), \"Switching Protocols\");\n             EXPECT_EQ(msg.getHeaders().getSingleOrEmpty(HTTP_HEADER_UPGRADE),\n                       expectedUpgrade);\n             // also connection and date\n             EXPECT_EQ(msg.getHeaders().size(), 3);\n             breakParseOutput_ = true;\n             return true;\n               }));\n    // this comes before 101, but due to gmock this is backwards\n    if (expect100) {\n      EXPECT_CALL(callbacks, onMessageBegin(_, _))\n        .RetiresOnSaturation();\n      EXPECT_CALL(callbacks, onHeadersComplete(_, _))\n        .WillOnce(Invoke([] (HTTPCodec::StreamID,\n                             std::shared_ptr<HTTPMessage> msg) {\n                 LOG(INFO) << \"100 headers\";\n                 EXPECT_EQ(msg->getStatusCode(), 100);\n                         }))\n        .RetiresOnSaturation();\n      EXPECT_CALL(callbacks, onMessageComplete(_, _))\n        .RetiresOnSaturation();\n    }\n    clientCodec_->setCallback(&callbacks);\n    parseOutput(*clientCodec_);\n    clientCodec_ = HTTPCodecFactory::getCodec(expectedProtocol,\n                                              TransportDirection::UPSTREAM);\n  }\n  void expectResponse(uint32_t code = 200,\n                      ErrorCode errorCode = ErrorCode::NO_ERROR,\n                      bool expect100 = false, bool expectGoaway = false) {\n    expectResponses(1, code, errorCode, expect100, expectGoaway);\n  }\n  void expectResponses(uint32_t n, uint32_t code = 200,\n                       ErrorCode errorCode = ErrorCode::NO_ERROR,\n                       bool expect100 = false, bool expectGoaway = false) {\n    clientCodec_->setCallback(&callbacks_);\n    if (isParallelCodecProtocol(clientCodec_->getProtocol())) {\n      EXPECT_CALL(callbacks_, onSettings(_))\n        .WillOnce(Invoke([this] (const SettingsList& settings) {\n              if (flowControl_[0] > 0) {\n                bool foundInitialWindow = false;\n                for (const auto& setting: settings) {\n                  if (setting.id == SettingsId::INITIAL_WINDOW_SIZE) {\n                    EXPECT_EQ(flowControl_[0], setting.value);\n                    foundInitialWindow = true;\n                  }\n                }\n                EXPECT_TRUE(foundInitialWindow);\n              }\n            }));\n    }\n    if (flowControl_[2] > 0) {\n      int64_t sessionDelta =\n        flowControl_[2] - clientCodec_->getDefaultWindowSize();\n      if (clientCodec_->supportsSessionFlowControl() && sessionDelta) {\n        EXPECT_CALL(callbacks_, onWindowUpdate(0, sessionDelta));\n      }\n    }\n    if (flowControl_[1] > 0) {\n      size_t initWindow = flowControl_[0] > 0 ?\n        flowControl_[0] : clientCodec_->getDefaultWindowSize();\n      int64_t streamDelta = flowControl_[1] - initWindow;\n      if (clientCodec_->supportsStreamFlowControl() && streamDelta) {\n        EXPECT_CALL(callbacks_, onWindowUpdate(1, streamDelta));\n      }\n    }\n\n    if (expectGoaway) {\n      EXPECT_CALL(callbacks_, onGoaway(HTTPCodec::StreamID(1),\n                                      ErrorCode::NO_ERROR, _));\n    }\n\n    for (uint32_t i = 0; i < n; i++) {\n      uint8_t times = (expect100) ? 2 : 1;\n      EXPECT_CALL(callbacks_, onMessageBegin(_, _))\n        .Times(times).RetiresOnSaturation();\n      EXPECT_CALL(callbacks_, onHeadersComplete(_, _))\n        .WillOnce(Invoke([code] (HTTPCodec::StreamID,\n                                 std::shared_ptr<HTTPMessage> msg) {\n                           EXPECT_EQ(msg->getStatusCode(), code);\n                         }));\n      if (expect100) {\n        EXPECT_CALL(callbacks_, onHeadersComplete(_, _))\n          .WillOnce(Invoke([] (HTTPCodec::StreamID,\n                               std::shared_ptr<HTTPMessage> msg) {\n                             EXPECT_EQ(msg->getStatusCode(), 100);\n                           }))\n          .RetiresOnSaturation();\n      }\n      if (errorCode != ErrorCode::NO_ERROR) {\n        EXPECT_CALL(callbacks_, onAbort(_, _))\n          .WillOnce(Invoke([errorCode] (HTTPCodec::StreamID,\n                                        ErrorCode error) {\n                             EXPECT_EQ(error, errorCode);\n                         }));\n      }\n      EXPECT_CALL(callbacks_, onBody(_, _, _)).RetiresOnSaturation();\n      EXPECT_CALL(callbacks_, onMessageComplete(_, _)).RetiresOnSaturation();\n    }\n    parseOutput(*clientCodec_);\n  }\n\n  void parseOutput(HTTPCodec& clientCodec) {\n    auto writeEvents = transport_->getWriteEvents();\n    while (!breakParseOutput_ &&\n           (!writeEvents->empty() || !parseOutputStream_.empty())) {\n      if (!writeEvents->empty()) {\n        auto event = writeEvents->front();\n        auto vec = event->getIoVec();\n        for (size_t i = 0; i < event->getCount(); i++) {\n          parseOutputStream_.append(\n            IOBuf::copyBuffer(vec[i].iov_base, vec[i].iov_len));\n        }\n        writeEvents->pop_front();\n      }\n      uint32_t consumed = clientCodec.onIngress(*parseOutputStream_.front());\n      parseOutputStream_.split(consumed);\n    }\n    if (!breakParseOutput_) {\n      EXPECT_EQ(parseOutputStream_.chainLength(), 0);\n    }\n    breakParseOutput_ = false;\n  }\n\n  void resumeWritesInLoop() {\n    eventBase_.runInLoop([this] { transport_->resumeWrites(); });\n  }\n\n  void resumeWritesAfterDelay(milliseconds delay) {\n    eventBase_.runAfterDelay([this] { transport_->resumeWrites(); },\n                             delay.count());\n  }\n\n  MockByteEventTracker* setMockByteEventTracker() {\n    auto byteEventTracker = new MockByteEventTracker(nullptr);\n    httpSession_->setByteEventTracker(\n      std::unique_ptr<ByteEventTracker>(byteEventTracker));\n    EXPECT_CALL(*byteEventTracker, preSend(_, _, _))\n      .WillRepeatedly(Return(0));\n    EXPECT_CALL(*byteEventTracker, drainByteEvents())\n      .WillRepeatedly(Return(0));\n    EXPECT_CALL(*byteEventTracker, processByteEvents(_, _))\n      .WillRepeatedly(Invoke([]\n                             (std::shared_ptr<ByteEventTracker> self,\n                              uint64_t bytesWritten) {\n                               return self->ByteEventTracker::processByteEvents(\n                                 self,\n                                 bytesWritten);\n                             }));\n\n    return byteEventTracker;\n  }\n\n protected:\n  EventBase eventBase_;\n  TestAsyncTransport* transport_;  // invalid once httpSession_ is destroyed\n  folly::HHWheelTimer::UniquePtr transactionTimeouts_;\n  std::vector<int64_t> flowControl_;\n  StrictMock<MockController> mockController_;\n  HTTPDownstreamSession* httpSession_;\n  IOBufQueue requests_{IOBufQueue::cacheChainLength()};\n  unique_ptr<HTTPCodec> clientCodec_;\n  NiceMock<MockHTTPCodecCallback> callbacks_;\n  IOBufQueue parseOutputStream_{IOBufQueue::cacheChainLength()};\n  bool breakParseOutput_{false};\n  typename C::Codec* rawCodec_{nullptr};\n  HeaderIndexingStrategy testH2IndexingStrat_;\n};\n\n// Uses TestAsyncTransport\nusing HTTPDownstreamSessionTest = HTTPDownstreamTest<HTTP1xCodecPair>;\nusing SPDY3DownstreamSessionTest = HTTPDownstreamTest<SPDY3CodecPair>;\nnamespace {\nclass HTTP2DownstreamSessionTest : public HTTPDownstreamTest<HTTP2CodecPair> {\n public:\n  HTTP2DownstreamSessionTest()\n      : HTTPDownstreamTest<HTTP2CodecPair>() {}\n\n  void SetUp() override {\n    HTTPDownstreamTest<HTTP2CodecPair>::SetUp();\n  }\n\n  void SetupControlStream(HTTPCodec::StreamID cStreamId) {\n    // enable EX_HEADERS\n    clientCodec_->getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n    clientCodec_->generateSettings(requests_);\n    // create a control stream\n    clientCodec_->generateHeader(requests_, cStreamId, getGetRequest(\"/cc\"),\n                                 true, nullptr);\n  }\n\n  void TearDown() override {\n  }\n};\n}\n\nnamespace {\nclass HTTP2DownstreamSessionEarlyShutdownTest :\npublic HTTPDownstreamTest<HTTP2CodecPair> {\n public:\n  HTTP2DownstreamSessionEarlyShutdownTest()\n      : HTTPDownstreamTest<HTTP2CodecPair>({-1, -1, -1}, false) {}\n\n  void SetUp() override {\n    HTTPDownstreamTest<HTTP2CodecPair>::SetUp();\n  }\n\n  void TearDown() override {\n  }\n};\n}\n\nTEST_F(HTTP2DownstreamSessionEarlyShutdownTest, EarlyShutdown) {\n  folly::DelayedDestruction::DestructorGuard g(httpSession_);\n\n  // Try shutting down the session and then starting it. This should be properly\n  // handled by the HTTPSession such that no HTTP/2 frames are sent in the\n  // wrong order.\n  StrictMock<MockHTTPCodecCallback> callbacks;\n  clientCodec_->setCallback(&callbacks);\n  EXPECT_CALL(callbacks, onFrameHeader(_, _, _, _, _)).Times(2);\n  EXPECT_CALL(callbacks, onSettings(_)).Times(1);\n  EXPECT_CALL(callbacks, onGoaway(_, _, _)).Times(1);\n  expectDetachSession();\n  httpSession_->notifyPendingShutdown();\n  httpSession_->startNow();\n  eventBase_.loop();\n  parseOutput(*clientCodec_);\n}\n\nTEST_F(HTTPDownstreamSessionTest, ImmediateEof) {\n  // Send EOF without any request data\n  EXPECT_CALL(mockController_, getRequestHandler(_, _)).Times(0);\n  expectDetachSession();\n\n  flushRequestsAndLoop(true, milliseconds(0));\n}\n\nTEST_F(HTTPDownstreamSessionTest, Http10NoHeaders) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleNiceHandler();\n  handler->expectHeaders([&] (std::shared_ptr<HTTPMessage> msg) {\n      EXPECT_FALSE(msg->getIsChunked());\n      EXPECT_FALSE(msg->getIsUpgraded());\n      EXPECT_EQ(\"/\", msg->getURL());\n      EXPECT_EQ(\"/\", msg->getPath());\n      EXPECT_EQ(\"\", msg->getQueryString());\n      EXPECT_EQ(1, msg->getHTTPVersion().first);\n      EXPECT_EQ(0, msg->getHTTPVersion().second);\n    });\n  onEOMTerminateHandlerExpectShutdown(*handler);\n\n  auto req = getGetRequest();\n  req.setHTTPVersion(1, 0);\n  sendRequest(req);\n  flushRequestsAndLoop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, Http10NoHeadersEof) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleNiceHandler();\n  handler->expectHeaders([&] (std::shared_ptr<HTTPMessage> msg) {\n      EXPECT_FALSE(msg->getIsChunked());\n      EXPECT_FALSE(msg->getIsUpgraded());\n      EXPECT_EQ(\"http://example.com/foo?bar\", msg->getURL());\n      EXPECT_EQ(\"/foo\", msg->getPath());\n      EXPECT_EQ(\"bar\", msg->getQueryString());\n      EXPECT_EQ(1, msg->getHTTPVersion().first);\n      EXPECT_EQ(0, msg->getHTTPVersion().second);\n    });\n  onEOMTerminateHandlerExpectShutdown(*handler);\n\n  const char *req = \"GET http://example.com/foo?bar HTTP/1.0\\r\\n\\r\\n\";\n  requests_.append(req, strlen(req));\n  flushRequestsAndLoop(true, milliseconds(0));\n}\n\nTEST_F(HTTPDownstreamSessionTest, SingleBytes) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleNiceHandler();\n  handler->expectHeaders([&] (std::shared_ptr<HTTPMessage> msg) {\n      const HTTPHeaders& hdrs = msg->getHeaders();\n      EXPECT_EQ(2, hdrs.size());\n      EXPECT_TRUE(hdrs.exists(\"host\"));\n      EXPECT_TRUE(hdrs.exists(\"connection\"));\n\n      EXPECT_FALSE(msg->getIsChunked());\n      EXPECT_FALSE(msg->getIsUpgraded());\n      EXPECT_EQ(\"/somepath.php?param=foo\", msg->getURL());\n      EXPECT_EQ(\"/somepath.php\", msg->getPath());\n      EXPECT_EQ(\"param=foo\", msg->getQueryString());\n      EXPECT_EQ(1, msg->getHTTPVersion().first);\n      EXPECT_EQ(1, msg->getHTTPVersion().second);\n    });\n  onEOMTerminateHandlerExpectShutdown(*handler);\n\n  addSingleByteReads(\"GET /somepath.php?param=foo HTTP/1.1\\r\\n\"\n                     \"Host: example.com\\r\\n\"\n                     \"Connection: close\\r\\n\"\n                     \"\\r\\n\");\n  transport_->addReadEOF(milliseconds(0));\n  transport_->startReadEvents();\n  eventBase_.loop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, SingleBytesWithBody) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleNiceHandler();\n  handler->expectHeaders([&] (std::shared_ptr<HTTPMessage> msg) {\n      const HTTPHeaders& hdrs = msg->getHeaders();\n      EXPECT_EQ(3, hdrs.size());\n      EXPECT_TRUE(hdrs.exists(\"host\"));\n      EXPECT_TRUE(hdrs.exists(\"content-length\"));\n      EXPECT_TRUE(hdrs.exists(\"myheader\"));\n\n      EXPECT_FALSE(msg->getIsChunked());\n      EXPECT_FALSE(msg->getIsUpgraded());\n      EXPECT_EQ(\"/somepath.php?param=foo\", msg->getURL());\n      EXPECT_EQ(\"/somepath.php\", msg->getPath());\n      EXPECT_EQ(\"param=foo\", msg->getQueryString());\n      EXPECT_EQ(1, msg->getHTTPVersion().first);\n      EXPECT_EQ(1, msg->getHTTPVersion().second);\n    });\n  EXPECT_CALL(*handler, onBody(_))\n    .WillOnce(ExpectString(\"1\"))\n    .WillOnce(ExpectString(\"2\"))\n    .WillOnce(ExpectString(\"3\"))\n    .WillOnce(ExpectString(\"4\"))\n    .WillOnce(ExpectString(\"5\"));\n  onEOMTerminateHandlerExpectShutdown(*handler);\n\n  addSingleByteReads(\"POST /somepath.php?param=foo HTTP/1.1\\r\\n\"\n                     \"Host: example.com\\r\\n\"\n                     \"MyHeader: FooBar\\r\\n\"\n                     \"Content-Length: 5\\r\\n\"\n                     \"\\r\\n\"\n                     \"12345\");\n  transport_->addReadEOF(milliseconds(0));\n  transport_->startReadEvents();\n  eventBase_.loop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, SplitBody) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleNiceHandler();\n  handler->expectHeaders([&] (std::shared_ptr<HTTPMessage> msg) {\n      const HTTPHeaders& hdrs = msg->getHeaders();\n      EXPECT_EQ(2, hdrs.size());\n    });\n  EXPECT_CALL(*handler, onBody(_))\n    .WillOnce(ExpectString(\"12345\"))\n    .WillOnce(ExpectString(\"abcde\"));\n  onEOMTerminateHandlerExpectShutdown(*handler);\n\n  transport_->addReadEvent(\"POST / HTTP/1.1\\r\\n\"\n                           \"Host: example.com\\r\\n\"\n                           \"Content-Length: 10\\r\\n\"\n                           \"\\r\\n\"\n                           \"12345\", milliseconds(0));\n  transport_->addReadEvent(\"abcde\", milliseconds(5));\n  transport_->addReadEOF(milliseconds(0));\n  transport_->startReadEvents();\n  eventBase_.loop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, PostChunked) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleNiceHandler();\n  handler->expectHeaders([&] (std::shared_ptr<HTTPMessage> msg) {\n      const HTTPHeaders& hdrs = msg->getHeaders();\n      EXPECT_EQ(3, hdrs.size());\n      EXPECT_TRUE(hdrs.exists(\"host\"));\n      EXPECT_TRUE(hdrs.exists(\"content-type\"));\n      EXPECT_TRUE(hdrs.exists(\"transfer-encoding\"));\n      EXPECT_TRUE(msg->getIsChunked());\n      EXPECT_FALSE(msg->getIsUpgraded());\n      EXPECT_EQ(\"http://example.com/cgi-bin/foo.aspx?abc&def\",\n                msg->getURL());\n      EXPECT_EQ(\"/cgi-bin/foo.aspx\", msg->getPath());\n      EXPECT_EQ(\"abc&def\", msg->getQueryString());\n      EXPECT_EQ(1, msg->getHTTPVersion().first);\n      EXPECT_EQ(1, msg->getHTTPVersion().second);\n    });\n  EXPECT_CALL(*handler, onChunkHeader(3));\n  EXPECT_CALL(*handler, onBody(_))\n    .WillOnce(ExpectString(\"bar\"));\n  EXPECT_CALL(*handler, onChunkComplete());\n  EXPECT_CALL(*handler, onChunkHeader(0x22));\n  EXPECT_CALL(*handler, onBody(_))\n    .WillOnce(ExpectString(\"0123456789abcdef\\nfedcba9876543210\\n\"));\n  EXPECT_CALL(*handler, onChunkComplete());\n  EXPECT_CALL(*handler, onChunkHeader(3));\n  EXPECT_CALL(*handler, onBody(_))\n    .WillOnce(ExpectString(\"foo\"));\n  EXPECT_CALL(*handler, onChunkComplete());\n  onEOMTerminateHandlerExpectShutdown(*handler);\n\n  transport_->addReadEvent(\"POST http://example.com/cgi-bin/foo.aspx?abc&def \"\n                           \"HTTP/1.1\\r\\n\"\n                           \"Host: example.com\\r\\n\"\n                           \"Content-Type: text/pla\", milliseconds(0));\n  transport_->addReadEvent(\"in; charset=utf-8\\r\\n\"\n                           \"Transfer-encoding: chunked\\r\\n\"\n                           \"\\r\", milliseconds(2));\n  transport_->addReadEvent(\"\\n\"\n                           \"3\\r\\n\"\n                           \"bar\\r\\n\"\n                           \"22\\r\\n\"\n                           \"0123456789abcdef\\n\"\n                           \"fedcba9876543210\\n\"\n                           \"\\r\\n\"\n                           \"3\\r\", milliseconds(3));\n  transport_->addReadEvent(\"\\n\"\n                           \"foo\\r\\n\"\n                           \"0\\r\\n\\r\\n\", milliseconds(1));\n  transport_->startReadEvents();\n  eventBase_.loop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, MultiMessage) {\n  InSequence enforceOrder;\n\n  auto handler1 = addSimpleNiceHandler();\n  handler1->expectHeaders();\n  EXPECT_CALL(*handler1, onBody(_))\n    .WillOnce(ExpectString(\"foo\"))\n    .WillOnce(ExpectString(\"bar9876\"));\n  handler1->expectEOM([&] { handler1->sendReply(); });\n  handler1->expectDetachTransaction();\n\n  auto handler2 = addSimpleNiceHandler();\n  handler2->expectHeaders();\n  EXPECT_CALL(*handler2, onChunkHeader(0xa));\n  EXPECT_CALL(*handler2, onBody(_))\n    .WillOnce(ExpectString(\"some \"))\n    .WillOnce(ExpectString(\"data\\n\"));\n  EXPECT_CALL(*handler2, onChunkComplete());\n  onEOMTerminateHandlerExpectShutdown(*handler2);\n\n  transport_->addReadEvent(\"POST / HTTP/1.1\\r\\n\"\n                           \"Host: example.com\\r\\n\"\n                           \"Content-Length: 10\\r\\n\"\n                           \"\\r\\n\"\n                           \"foo\", milliseconds(0));\n  transport_->addReadEvent(\"bar9876\"\n                           \"POST /foo HTTP/1.1\\r\\n\"\n                           \"Host: exa\", milliseconds(2));\n  transport_->addReadEvent(\"mple.com\\r\\n\"\n                           \"Connection: close\\r\\n\"\n                           \"Trans\", milliseconds(0));\n  transport_->addReadEvent(\"fer-encoding: chunked\\r\\n\"\n                           \"\\r\\n\", milliseconds(2));\n  transport_->addReadEvent(\"a\\r\\nsome \", milliseconds(0));\n  transport_->addReadEvent(\"data\\n\\r\\n0\\r\\n\\r\\n\", milliseconds(2));\n  transport_->addReadEOF(milliseconds(0));\n  transport_->startReadEvents();\n  eventBase_.loop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, Connect) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleStrictHandler();\n  // Send HTTP 200 OK to accept the CONNECT request\n  handler->expectHeaders([&handler] {\n      handler->sendHeaders(200, 100);\n    });\n\n  EXPECT_CALL(*handler, onUpgrade(_));\n\n  // Data should be received using onBody\n  EXPECT_CALL(*handler, onBody(_))\n    .WillOnce(ExpectString(\"12345\"))\n    .WillOnce(ExpectString(\"abcde\"));\n  onEOMTerminateHandlerExpectShutdown(*handler);\n\n  transport_->addReadEvent(\"CONNECT test HTTP/1.1\\r\\n\"\n                           \"\\r\\n\"\n                           \"12345\", milliseconds(0));\n  transport_->addReadEvent(\"abcde\", milliseconds(5));\n  transport_->addReadEOF(milliseconds(0));\n  transport_->startReadEvents();\n  eventBase_.loop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, ConnectRejected) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleStrictHandler();\n  // Send HTTP 400 to reject the CONNECT request\n  handler->expectHeaders([&handler] {\n      handler->sendReplyCode(400);\n    });\n\n  onEOMTerminateHandlerExpectShutdown(*handler);\n\n  transport_->addReadEvent(\"CONNECT test HTTP/1.1\\r\\n\"\n                           \"\\r\\n\"\n                           \"12345\", milliseconds(0));\n  transport_->addReadEvent(\"abcde\", milliseconds(5));\n  transport_->addReadEOF(milliseconds(0));\n  transport_->startReadEvents();\n  eventBase_.loop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, HttpUpgrade) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleStrictHandler();\n  // Send HTTP 101 Switching Protocls to accept the upgrade request\n  handler->expectHeaders([&handler] {\n      handler->sendHeaders(101, 100);\n    });\n\n  // Send the response in the new protocol after upgrade\n  EXPECT_CALL(*handler, onUpgrade(_))\n      .WillOnce(Invoke([&handler](UpgradeProtocol /*protocol*/) {\n        handler->sendReplyCode(100);\n      }));\n\n  onEOMTerminateHandlerExpectShutdown(*handler);\n\n  HTTPMessage req = getGetRequest();\n  req.getHeaders().add(HTTP_HEADER_UPGRADE, \"TEST/1.0\");\n  req.getHeaders().add(HTTP_HEADER_CONNECTION, \"upgrade\");\n  sendRequest(req);\n  flushRequestsAndLoop(true, milliseconds(0));\n}\n\nTEST(HTTPDownstreamTest, ParseErrorNoTxn) {\n  // 1) Get a parse error on SYN_STREAM for streamID == 1\n  // 2) Expect that the codec should be asked to generate an abort on\n  //    streamID==1\n  EventBase evb;\n\n  // Setup the controller and its expecations.\n  NiceMock<MockController> mockController;\n\n  // Setup the codec, its callbacks, and its expectations.\n  auto codec = makeDownstreamParallelCodec();\n  HTTPCodec::Callback* codecCallback = nullptr;\n  EXPECT_CALL(*codec, setCallback(_))\n    .WillRepeatedly(SaveArg<0>(&codecCallback));\n  // Expect egress abort for streamID == 1\n  EXPECT_CALL(*codec, generateRstStream(_, 1, _));\n\n  // Setup transport\n  bool transportGood = true;\n  auto transport = newMockTransport(&evb);\n  EXPECT_CALL(*transport, good())\n    .WillRepeatedly(ReturnPointee(&transportGood));\n  EXPECT_CALL(*transport, closeNow())\n    .WillRepeatedly(Assign(&transportGood, false));\n  EXPECT_CALL(*transport, writeChain(_, _, _))\n    .WillRepeatedly(\n      Invoke([&] (folly::AsyncTransportWrapper::WriteCallback* callback,\n                  const shared_ptr<IOBuf>&, WriteFlags) {\n               callback->writeSuccess();\n             }));\n\n  // Create the downstream session, thus initializing codecCallback\n  auto transactionTimeouts = makeInternalTimeoutSet(&evb);\n  auto session = new HTTPDownstreamSession(\n    transactionTimeouts.get(),\n    AsyncTransportWrapper::UniquePtr(transport),\n    localAddr, peerAddr,\n    &mockController, std::move(codec),\n    mockTransportInfo,\n    nullptr);\n  session->startNow();\n  HTTPException ex(HTTPException::Direction::INGRESS_AND_EGRESS, \"foo\");\n  ex.setProxygenError(kErrorParseHeader);\n  ex.setCodecStatusCode(ErrorCode::REFUSED_STREAM);\n  codecCallback->onError(HTTPCodec::StreamID(1), ex, true);\n\n  // cleanup\n  session->dropConnection();\n  evb.loop();\n}\n\nTEST(HTTPDownstreamTest, ByteEventsDrained) {\n  // Test that byte events are drained before socket is closed\n  EventBase evb;\n\n  NiceMock<MockController> mockController;\n  auto codec = makeDownstreamParallelCodec();\n  auto byteEventTracker = new MockByteEventTracker(nullptr);\n  auto transport = newMockTransport(&evb);\n  auto transactionTimeouts = makeInternalTimeoutSet(&evb);\n\n  // Create the downstream session\n  auto session = new HTTPDownstreamSession(\n    transactionTimeouts.get(),\n    AsyncTransportWrapper::UniquePtr(transport),\n    localAddr, peerAddr,\n    &mockController, std::move(codec),\n    mockTransportInfo,\n    nullptr);\n  session->setByteEventTracker(\n      std::unique_ptr<ByteEventTracker>(byteEventTracker));\n\n  InSequence enforceOrder;\n\n  session->startNow();\n\n  // Byte events should be drained first\n  EXPECT_CALL(*byteEventTracker, drainByteEvents())\n    .Times(1);\n  EXPECT_CALL(*transport, closeNow())\n    .Times(AtLeast(1));\n\n  // Close the socket\n  session->dropConnection();\n  evb.loop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, HttpWithAckTiming) {\n  // This is to test cases where holding a byte event to a finished HTTP/1.1\n  // transaction does not masquerade as HTTP pipelining.\n  auto byteEventTracker = setMockByteEventTracker();\n  InSequence enforceOrder;\n\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1] () {\n      handler1->sendChunkedReplyWithBody(200, 100, 100, false);\n    });\n  // Hold a pending byte event\n  EXPECT_CALL(*byteEventTracker, addLastByteEvent(_, _))\n      .WillOnce(Invoke([] (HTTPTransaction* txn,\n                           uint64_t /*byteNo*/) {\n                         txn->incrementPendingByteEvents();\n                       }));\n  sendRequest();\n  flushRequestsAndLoop();\n  expectResponse();\n\n  // Send the secode request after receiving the first response (eg: clearly\n  // not pipelined)\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&handler2] () {\n      handler2->sendChunkedReplyWithBody(200, 100, 100, false);\n    });\n  // This txn processed and destroyed before txn1\n  EXPECT_CALL(*byteEventTracker, addLastByteEvent(_, _));\n  handler2->expectDetachTransaction();\n\n  sendRequest();\n  flushRequestsAndLoop();\n  expectResponse();\n\n  // Now clear the pending byte event (simulate ack) and the first txn\n  // goes away too\n  handler1->expectDetachTransaction();\n  handler1->txn_->decrementPendingByteEvents();\n  gracefulShutdown();\n}\n\nTEST_F(HTTPDownstreamSessionTest, TestOnContentMismatch) {\n  // Test the behavior when the reported content-length on the header\n  // is different from the actual length of the body.\n  // The expectation is simply to log the behavior, such as:\n  // \".. HTTPTransaction.cpp ] Content-Length/body mismatch: expected: .. \"\n  folly::EventBase base;\n  InSequence enforceOrder;\n  auto handler1 = addSimpleNiceHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1] () {\n        // over-estimate the content-length on the header\n        handler1->sendHeaders(200, 105);\n        handler1->sendBody(100);\n        handler1->txn_->sendEOM();\n      });\n  sendRequest();\n  flushRequestsAndLoop();\n\n  auto handler2 = addSimpleNiceHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&handler2] () {\n        // under-estimate the content-length on the header\n        handler2->sendHeaders(200, 95);\n        handler2->sendBody(100);\n        handler2->txn_->sendEOM();\n      });\n  sendRequest();\n  flushRequestsAndLoop();\n  gracefulShutdown();\n}\n\nTEST_F(HTTPDownstreamSessionTest, HttpWithAckTimingPipeline) {\n  // Test a real pipelining case as well.  First request is done waiting for\n  // ack, then receive two pipelined requests.\n  auto byteEventTracker = setMockByteEventTracker();\n  InSequence enforceOrder;\n\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1] () {\n      handler1->sendChunkedReplyWithBody(200, 100, 100, false);\n    });\n  EXPECT_CALL(*byteEventTracker, addLastByteEvent(_, _))\n      .WillOnce(Invoke([] (HTTPTransaction* txn,\n                           uint64_t /*byteNo*/) {\n                         txn->incrementPendingByteEvents();\n                       }));\n  sendRequest();\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&handler2] () {\n      handler2->sendChunkedReplyWithBody(200, 100, 100, false);\n    });\n  EXPECT_CALL(*byteEventTracker, addLastByteEvent(_, _));\n  handler2->expectDetachTransaction();\n\n  sendRequest();\n  sendRequest();\n  auto handler3 = addSimpleStrictHandler();\n  handler3->expectHeaders();\n  handler3->expectEOM([&handler3] () {\n      handler3->sendChunkedReplyWithBody(200, 100, 100, false);\n    });\n  EXPECT_CALL(*byteEventTracker, addLastByteEvent(_, _));\n  handler3->expectDetachTransaction();\n  flushRequestsAndLoop();\n  expectResponses(3);\n  handler1->expectDetachTransaction();\n  handler1->txn_->decrementPendingByteEvents();\n  gracefulShutdown();\n}\n\n/*\n * The sequence of streams are generated in the following order:\n * - [client --> server] regular request 1st stream (getGetRequest())\n * - [server --> client] respond 1st stream (res, 100 bytes, without EOM)\n * - [server --> client] request 2nd stream (pub, 200 bytes, EOM)\n * - [client --> server] respond 2nd stream (OK, EOM)\n * - [client --> server] EOM on the 1st stream\n */\nTEST_F(HTTP2DownstreamSessionTest, ExheaderFromServer) {\n  auto cStreamId = HTTPCodec::StreamID(1);\n  SetupControlStream(cStreamId);\n\n  // Create a dummy request and a dummy response messages\n  auto pub = getGetRequest(\"/sub/fyi\");\n  // set up the priority for fun\n  pub.setHTTP2Priority(std::make_tuple(0, false, 7));\n\n  InSequence handlerSequence;\n  auto cHandler = addSimpleStrictHandler();\n  StrictMock<MockHTTPHandler> pubHandler;\n\n  cHandler->expectHeaders([&] {\n      cHandler->txn_->pauseIngress();\n      // Generate response for the control stream\n      cHandler->txn_->sendHeaders(getResponse(200, 0));\n      cHandler->txn_->sendBody(makeBuf(100));\n\n      auto* pubTxn = cHandler->txn_->newExTransaction(&pubHandler);\n      // Generate a pub request (encapsulated in EX_HEADERS frame)\n      pubTxn->sendHeaders(pub);\n      pubTxn->sendBody(makeBuf(200));\n      pubTxn->sendEOM();\n    });\n\n  EXPECT_CALL(pubHandler, setTransaction(_));\n  EXPECT_CALL(callbacks_, onSettings(_))\n    .WillOnce(InvokeWithoutArgs([&] {\n          clientCodec_->generateSettingsAck(requests_);\n        }));\n  EXPECT_CALL(callbacks_, onMessageBegin(cStreamId, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(cStreamId, _));\n  EXPECT_CALL(callbacks_, onExMessageBegin(2, _, _, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(2, _));\n  EXPECT_CALL(callbacks_, onMessageComplete(2, _));\n\n  EXPECT_CALL(pubHandler, onHeadersComplete(_));\n  EXPECT_CALL(pubHandler, onEOM());\n  EXPECT_CALL(pubHandler, detachTransaction());\n\n  EXPECT_CALL(*cHandler, onEOM());\n  EXPECT_CALL(*cHandler, detachTransaction());\n\n  transport_->addReadEvent(requests_, milliseconds(0));\n  transport_->startReadEvents();\n\n  eventBase_.runAfterDelay([&] {\n      parseOutput(*clientCodec_);\n      // send a response from client to server\n      clientCodec_->generateExHeader(requests_, 2, getResponse(200, 0),\n                                     HTTPCodec::ExAttributes(cStreamId, false),\n                                     true, nullptr);\n      transport_->addReadEvent(requests_, milliseconds(0));\n      transport_->startReadEvents();\n      parseOutput(*clientCodec_);\n      cHandler->txn_->resumeIngress();\n      cHandler->txn_->sendEOM();\n      transport_->addReadEOF(milliseconds(0));\n    }, 100);\n\n  HTTPSession::DestructorGuard g(httpSession_);\n  expectDetachSession();\n  eventBase_.loop();\n}\n\n/*\n * The sequence of streams are generated in the following order:\n * - [client --> server] regular request on control stream 1\n * - [client --> server] Pub request on stream 3\n * - [server --> client] response on stream 1 (OK, )\n * - [server --> client] response on stream 3 (OK, EOM)\n * - [server --> client] response on stream 1 (EOM)\n */\nTEST_F(HTTP2DownstreamSessionTest, ExheaderFromClient) {\n  auto cStreamId = HTTPCodec::StreamID(1);\n  SetupControlStream(cStreamId);\n\n  // generate an EX_HEADERS\n  auto exStreamId = cStreamId + 2;\n  clientCodec_->generateExHeader(requests_, exStreamId, getGetRequest(\"/pub\"),\n                                 HTTPCodec::ExAttributes(cStreamId, false),\n                                 true, nullptr);\n\n  auto cHandler = addSimpleStrictHandler();\n  cHandler->expectHeaders([&] {\n      // send back the response for control stream, but EOM\n      cHandler->txn_->sendHeaders(getResponse(200, 0));\n    });\n  EXPECT_CALL(*cHandler, onEOM());\n\n  StrictMock<MockHTTPHandler> pubHandler;\n  EXPECT_CALL(*cHandler, onExTransaction(_))\n    .WillOnce(Invoke([&pubHandler] (HTTPTransaction* exTxn) {\n          exTxn->setHandler(&pubHandler);\n          pubHandler.txn_ = exTxn;\n        }));\n\n  InSequence handlerSequence;\n  EXPECT_CALL(pubHandler, setTransaction(_));\n  pubHandler.expectHeaders([&] {\n      // send back the response for the pub request\n      pubHandler.txn_->sendHeadersWithEOM(getResponse(200, 0));\n    });\n  EXPECT_CALL(pubHandler, onEOM());\n  EXPECT_CALL(pubHandler, detachTransaction());\n  cHandler->expectDetachTransaction();\n\n  EXPECT_CALL(callbacks_, onMessageBegin(cStreamId, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(cStreamId, _));\n  EXPECT_CALL(callbacks_, onExMessageBegin(exStreamId, _, _, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(exStreamId, _));\n  EXPECT_CALL(callbacks_, onMessageComplete(exStreamId, _));\n  EXPECT_CALL(callbacks_, onMessageComplete(cStreamId, _));\n\n  transport_->addReadEvent(requests_, milliseconds(0));\n  transport_->startReadEvents();\n  transport_->addReadEOF(milliseconds(0));\n  eventBase_.loop();\n\n  HTTPSession::DestructorGuard g(httpSession_);\n  expectDetachSession();\n  cHandler->txn_->sendEOM();\n  eventBase_.loop();\n  parseOutput(*clientCodec_);\n}\n\n/*\n * The sequence of streams are generated in the following order:\n * - [client --> server] regular request 1st stream (getGetRequest())\n * - [server --> client] request 2nd stream (unidirectional)\n * - [server --> client] response + EOM on the 1st stream\n */\nTEST_F(HTTP2DownstreamSessionTest, UnidirectionalExTransaction) {\n  auto cStreamId = HTTPCodec::StreamID(1);\n  SetupControlStream(cStreamId);\n  InSequence handlerSequence;\n  auto cHandler = addSimpleStrictHandler();\n  StrictMock<MockHTTPHandler> uniHandler;\n\n  cHandler->expectHeaders([&] {\n      auto* uniTxn = cHandler->txn_->newExTransaction(&uniHandler, true);\n      EXPECT_TRUE(uniTxn->isIngressComplete());\n      uniTxn->sendHeaders(getGetRequest(\"/uni\"));\n      uniTxn->sendEOM();\n\n      // close control stream\n      cHandler->txn_->sendHeadersWithEOM(getResponse(200, 0));\n    });\n\n  EXPECT_CALL(uniHandler, setTransaction(_));\n  EXPECT_CALL(*cHandler, onEOM());\n  EXPECT_CALL(uniHandler, detachTransaction());\n  EXPECT_CALL(*cHandler, detachTransaction());\n\n  transport_->addReadEvent(requests_, milliseconds(0));\n  transport_->startReadEvents();\n  eventBase_.runAfterDelay([&] {\n      transport_->addReadEOF(milliseconds(0));\n    }, 100);\n\n  HTTPSession::DestructorGuard g(httpSession_);\n  expectDetachSession();\n  eventBase_.loop();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, PauseResumeControlStream) {\n  auto cStreamId = HTTPCodec::StreamID(1);\n  SetupControlStream(cStreamId);\n\n  // generate an EX_HEADERS\n  clientCodec_->generateExHeader(requests_, cStreamId + 2, getGetRequest(),\n                                 HTTPCodec::ExAttributes(cStreamId, false),\n                                 true, nullptr);\n\n  auto cHandler = addSimpleStrictHandler();\n  cHandler->expectHeaders([&] {\n      cHandler->txn_->pauseIngress();\n      // send back the response for control stream, but EOM\n      cHandler->txn_->sendHeaders(getResponse(200, 0));\n    });\n  EXPECT_CALL(*cHandler, onEOM());\n\n  StrictMock<MockHTTPHandler> pubHandler;\n  EXPECT_CALL(*cHandler, onExTransaction(_))\n    .WillOnce(Invoke([&pubHandler] (HTTPTransaction* exTxn) {\n          exTxn->setHandler(&pubHandler);\n          pubHandler.txn_ = exTxn;\n        }));\n\n  InSequence handlerSequence;\n  EXPECT_CALL(pubHandler, setTransaction(_));\n  pubHandler.expectHeaders([&] {\n      // send back the response for the pub request\n      pubHandler.txn_->sendHeadersWithEOM(getResponse(200, 0));\n    });\n  EXPECT_CALL(pubHandler, onEOM());\n  EXPECT_CALL(pubHandler, detachTransaction());\n  cHandler->expectDetachTransaction();\n\n  EXPECT_CALL(callbacks_, onMessageBegin(cStreamId, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(cStreamId, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(cStreamId + 2, _));\n  EXPECT_CALL(callbacks_, onMessageComplete(cStreamId + 2, _));\n  EXPECT_CALL(callbacks_, onMessageComplete(cStreamId, _));\n\n  HTTPSession::DestructorGuard g(httpSession_);\n  transport_->addReadEvent(requests_, milliseconds(0));\n  transport_->addReadEOF(milliseconds(0));\n  transport_->startReadEvents();\n  eventBase_.loop();\n\n  cHandler->txn_->resumeIngress();\n  cHandler->txn_->sendEOM();\n  eventBase_.loop();\n\n  expectDetachSession();\n  parseOutput(*clientCodec_);\n}\n\nTEST_F(HTTP2DownstreamSessionTest, InvalidControlStream) {\n  auto cStreamId = HTTPCodec::StreamID(1);\n  SetupControlStream(cStreamId);\n\n  // generate an EX_HEADERS, but with a non-existing control stream\n  clientCodec_->generateExHeader(requests_, cStreamId + 2, getGetRequest(),\n                                 HTTPCodec::ExAttributes(cStreamId + 4, false),\n                                 true, nullptr);\n\n  auto cHandler = addSimpleStrictHandler();\n  InSequence handlerSequence;\n  cHandler->expectHeaders([&] {\n      // send back the response for control stream, but EOM\n      cHandler->txn_->sendHeaders(getResponse(200, 0));\n    });\n  EXPECT_CALL(*cHandler, onExTransaction(_)).Times(0);\n  EXPECT_CALL(*cHandler, onEOM());\n  cHandler->expectDetachTransaction();\n\n  EXPECT_CALL(callbacks_, onMessageBegin(cStreamId, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(cStreamId, _));\n  EXPECT_CALL(callbacks_, onAbort(cStreamId + 2, _));\n\n  HTTPSession::DestructorGuard g(httpSession_);\n  transport_->addReadEvent(requests_, milliseconds(0));\n  transport_->addReadEOF(milliseconds(0));\n  transport_->startReadEvents();\n  eventBase_.loop();\n\n  cHandler->txn_->sendEOM();\n  eventBase_.loop();\n\n  expectDetachSession();\n  parseOutput(*clientCodec_);\n}\n\nTEST_F(HTTP2DownstreamSessionTest, SetByteEventTracker) {\n  InSequence enforceOrder;\n\n  // Send two requests with writes paused, which will queue several byte events,\n  // including last byte events which are holding a reference to the\n  // transaction.\n  transport_->pauseWrites();\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1] () {\n      handler1->sendReplyWithBody(200, 100);\n    });\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&handler2] () {\n      handler2->sendReplyWithBody(200, 100);\n    });\n\n  sendRequest();\n  sendRequest();\n  // Resume writes from the loop callback\n  eventBase_.runInLoop([this] {\n      transport_->resumeWrites();\n    });\n\n  // Graceful shutdown will notify of GOAWAY\n  EXPECT_CALL(*handler1, onGoaway(ErrorCode::NO_ERROR));\n  EXPECT_CALL(*handler2, onGoaway(ErrorCode::NO_ERROR));\n  // The original byteEventTracker will process the last byte event of the\n  // first transaction, and detach by deleting the event.  Swap out the tracker.\n  handler1->expectDetachTransaction([this] {\n      auto tracker = std::make_unique<ByteEventTracker>(httpSession_);\n      httpSession_->setByteEventTracker(std::move(tracker));\n    });\n  // handler2 should also be detached immediately because the new\n  // ByteEventTracker continues procesing where the old one left off.\n  handler2->expectDetachTransaction();\n  gracefulShutdown();\n}\n\nTEST_F(HTTPDownstreamSessionTest, TestTrackedByteEventTracker) {\n  auto byteEventTracker = setMockByteEventTracker();\n  InSequence enforceOrder;\n\n  auto handler1 = addSimpleStrictHandler();\n  size_t bytesToSend = 200;\n  size_t expectedTrackedByteOffset = bytesToSend + 99;\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1, &bytesToSend] () {\n    handler1->sendHeaders(200, 200);\n    handler1->sendBodyWithLastByteTracking(bytesToSend);\n    handler1->txn_->sendEOM();\n    });\n\n  EXPECT_CALL(*byteEventTracker,\n    addTrackedByteEvent(_, expectedTrackedByteOffset))\n      .WillOnce(Invoke([] (HTTPTransaction* txn,\n                           uint64_t /*byteNo*/) {\n                         txn->incrementPendingByteEvents();\n                       }));\n  sendRequest();\n  flushRequestsAndLoop();\n  handler1->expectDetachTransaction();\n  handler1->txn_->decrementPendingByteEvents();\n  gracefulShutdown();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, Trailers) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders();\n  handler->expectEOM([&handler]() {\n    handler->sendReplyWithBody(\n        200, 100, true /* keepalive */, true /* sendEOM */, true /*trailers*/);\n  });\n  handler->expectDetachTransaction();\n\n  HTTPSession::DestructorGuard g(httpSession_);\n  sendRequest();\n  flushRequestsAndLoop(true, milliseconds(0));\n\n  EXPECT_CALL(callbacks_, onMessageBegin(1, _)).Times(1);\n  EXPECT_CALL(callbacks_, onHeadersComplete(1, _)).Times(1);\n  EXPECT_CALL(callbacks_, onBody(1, _, _));\n  EXPECT_CALL(callbacks_, onTrailersComplete(1, _));\n  EXPECT_CALL(callbacks_, onMessageComplete(1, _));\n\n  parseOutput(*clientCodec_);\n  expectDetachSession();\n}\n\nTEST_F(HTTPDownstreamSessionTest, Trailers) {\n  testChunks(true);\n}\n\nTEST_F(HTTPDownstreamSessionTest, ExplicitChunks) {\n  testChunks(false);\n}\n\ntemplate <class C>\nvoid HTTPDownstreamTest<C>::testChunks(bool trailers) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders();\n  handler->expectEOM([&handler, trailers] () {\n      handler->sendChunkedReplyWithBody(200, 100, 17, trailers);\n    });\n  handler->expectDetachTransaction();\n\n  HTTPSession::DestructorGuard g(httpSession_);\n  sendRequest();\n  flushRequestsAndLoop(true, milliseconds(0));\n\n  EXPECT_CALL(callbacks_, onMessageBegin(1, _))\n    .Times(1);\n  EXPECT_CALL(callbacks_, onHeadersComplete(1, _))\n    .Times(1);\n  for (int i = 0; i < 6; i++) {\n    EXPECT_CALL(callbacks_, onChunkHeader(1, _));\n    EXPECT_CALL(callbacks_, onBody(1, _, _));\n    EXPECT_CALL(callbacks_, onChunkComplete(1));\n  }\n  if (trailers) {\n    EXPECT_CALL(callbacks_, onTrailersComplete(1, _));\n  }\n  EXPECT_CALL(callbacks_, onMessageComplete(1, _));\n\n  parseOutput(*clientCodec_);\n  expectDetachSession();\n}\n\nTEST_F(HTTPDownstreamSessionTest, HttpDrain) {\n  InSequence enforceOrder;\n\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders([this, &handler1] {\n      handler1->sendHeaders(200, 100);\n      httpSession_->notifyPendingShutdown();\n    });\n  handler1->expectEOM([&handler1] {\n      handler1->sendBody(100);\n      handler1->txn_->sendEOM();\n    });\n  handler1->expectDetachTransaction();\n\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders([&handler2] {\n      handler2->sendHeaders(200, 100);\n    });\n  handler2->expectEOM([&handler2] {\n          handler2->sendBody(100);\n          handler2->txn_->sendEOM();\n    });\n  handler2->expectDetachTransaction();\n\n  expectDetachSession();\n\n  sendRequest();\n  sendRequest();\n  flushRequestsAndLoop();\n}\n\n// 1) receive full request\n// 2) notify pending shutdown\n// 3) wait for session read timeout -> should be ignored\n// 4) response completed\nTEST_F(HTTPDownstreamSessionTest, HttpDrainLongRunning) {\n  InSequence enforceSequence;\n\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders([this, &handler] {\n      httpSession_->notifyPendingShutdown();\n      eventBase_.tryRunAfterDelay([this] {\n          // simulate read timeout\n          httpSession_->timeoutExpired();\n        }, 100);\n      eventBase_.tryRunAfterDelay([&handler] {\n          handler->sendReplyWithBody(200, 100);\n        }, 200);\n    });\n  handler->expectEOM();\n  handler->expectDetachTransaction();\n\n  expectDetachSession();\n\n  sendRequest();\n  flushRequestsAndLoop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, EarlyAbort) {\n  StrictMock<MockHTTPHandler> handler;\n\n  InSequence enforceOrder;\n  EXPECT_CALL(mockController_, getRequestHandler(_, _))\n    .WillOnce(Return(&handler));\n\n  EXPECT_CALL(handler, setTransaction(_))\n    .WillOnce(Invoke([&] (HTTPTransaction* txn) {\n          handler.txn_ = txn;\n          handler.txn_->sendAbort();\n        }));\n  handler.expectDetachTransaction();\n  expectDetachSession();\n\n  addSingleByteReads(\"GET /somepath.php?param=foo HTTP/1.1\\r\\n\"\n                     \"Host: example.com\\r\\n\"\n                     \"Connection: close\\r\\n\"\n                     \"\\r\\n\");\n  transport_->addReadEOF(milliseconds(0));\n  transport_->startReadEvents();\n  eventBase_.loop();\n}\n\nTEST_F(SPDY3DownstreamSessionTest, HttpPausedBuffered) {\n  IOBufQueue rst{IOBufQueue::cacheChainLength()};\n  auto s = sendRequest();\n  clientCodec_->generateRstStream(rst, s, ErrorCode::CANCEL);\n  sendRequest();\n\n  InSequence handlerSequence;\n  auto handler1 = addSimpleNiceHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1, this] {\n      transport_->pauseWrites();\n      handler1->sendHeaders(200, 65536 * 2);\n      handler1->sendBody(65536 * 2);\n    });\n  handler1->expectEgressPaused();\n  auto handler2 = addSimpleNiceHandler();\n  handler2->expectEgressPaused();\n  handler2->expectHeaders();\n  handler2->expectEOM([&] {\n      eventBase_.runInLoop([&] {\n          transport_->addReadEvent(rst, milliseconds(0)); });\n    });\n  handler1->expectError([&] (const HTTPException& ex) {\n      ASSERT_EQ(ex.getProxygenError(), kErrorStreamAbort);\n      resumeWritesInLoop();\n    });\n  handler1->expectDetachTransaction();\n  handler2->expectEgressResumed([&] {\n      handler2->sendReplyWithBody(200, 32768);\n    });\n  handler2->expectDetachTransaction([this] {\n      eventBase_.runInLoop([&] { transport_->addReadEOF(milliseconds(0)); });\n    });\n  expectDetachSession();\n\n  flushRequestsAndLoop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, HttpWritesDrainingTimeout) {\n  sendRequest();\n  sendHeader();\n\n  InSequence handlerSequence;\n  auto handler1 = addSimpleNiceHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1, this] {\n      transport_->pauseWrites();\n      handler1->sendHeaders(200, 1000);\n    });\n  handler1->expectError([&] (const HTTPException& ex) {\n      ASSERT_EQ(ex.getProxygenError(), kErrorWriteTimeout);\n      ASSERT_EQ(\n        folly::to<std::string>(\"WriteTimeout on transaction id: \",\n                               handler1->txn_->getID()),\n        std::string(ex.what()));\n      handler1->txn_->sendAbort();\n    });\n  handler1->expectDetachTransaction();\n  expectDetachSession();\n\n  flushRequestsAndLoop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, HttpRateLimitNormal) {\n  // The rate-limiting code grabs the event base from the EventBaseManager,\n  // so we need to set it.\n  folly::EventBaseManager::get()->setEventBase(&eventBase_, false);\n\n  // Create a request\n  sendRequest();\n\n  InSequence handlerSequence;\n\n  // Set a low rate-limit on the transaction\n  auto handler1 = addSimpleNiceHandler();\n  handler1->expectHeaders([&] {\n      uint32_t rateLimit_kbps = 640;\n      handler1->txn_->setEgressRateLimit(rateLimit_kbps * 1024);\n    });\n  // Send a somewhat big response that we know will get rate-limited\n  handler1->expectEOM([&handler1] {\n      // At 640kbps, this should take slightly over 800ms\n      uint32_t rspLengthBytes = 100000;\n      handler1->sendHeaders(200, rspLengthBytes);\n      handler1->sendBody(rspLengthBytes);\n      handler1->txn_->sendEOM();\n    });\n  handler1->expectDetachTransaction();\n\n  // Keep the session around even after the event base loop completes so we can\n  // read the counters on a valid object.\n  HTTPSession::DestructorGuard g(httpSession_);\n  flushRequestsAndLoop();\n\n  proxygen::TimePoint timeFirstWrite =\n    transport_->getWriteEvents()->front()->getTime();\n  proxygen::TimePoint timeLastWrite =\n    transport_->getWriteEvents()->back()->getTime();\n  int64_t writeDuration =\n    (int64_t)millisecondsBetween(timeLastWrite, timeFirstWrite).count();\n  EXPECT_GE(writeDuration, 800);\n\n  cleanup();\n}\n\nTEST_F(SPDY3DownstreamSessionTest, SpdyRateLimitNormal) {\n  // The rate-limiting code grabs the event base from the EventBaseManager,\n  // so we need to set it.\n  folly::EventBaseManager::get()->setEventBase(&eventBase_, false);\n\n  clientCodec_->getEgressSettings()->setSetting(SettingsId::INITIAL_WINDOW_SIZE,\n                                                100000);\n  clientCodec_->generateSettings(requests_);\n  sendRequest();\n\n  InSequence handlerSequence;\n  auto handler1 = addSimpleNiceHandler();\n  handler1->expectHeaders([&] {\n      uint32_t rateLimit_kbps = 640;\n      handler1->txn_->setEgressRateLimit(rateLimit_kbps * 1024);\n    });\n\n  handler1->expectEOM([&handler1] {\n      // At 640kbps, this should take slightly over 800ms\n      uint32_t rspLengthBytes = 100000;\n      handler1->sendHeaders(200, rspLengthBytes);\n      handler1->sendBody(rspLengthBytes);\n      handler1->txn_->sendEOM();\n    });\n  handler1->expectDetachTransaction();\n\n  // Keep the session around even after the event base loop completes so we can\n  // read the counters on a valid object.\n  HTTPSession::DestructorGuard g(httpSession_);\n  flushRequestsAndLoop(true, milliseconds(50));\n\n  proxygen::TimePoint timeFirstWrite =\n    transport_->getWriteEvents()->front()->getTime();\n  proxygen::TimePoint timeLastWrite =\n    transport_->getWriteEvents()->back()->getTime();\n  int64_t writeDuration =\n    (int64_t)millisecondsBetween(timeLastWrite, timeFirstWrite).count();\n  EXPECT_GE(writeDuration, 800);\n  expectDetachSession();\n}\n\n/**\n * This test will reset the connection while the server is waiting around\n * to send more bytes (so as to keep under the rate limit).\n */\nTEST_F(SPDY3DownstreamSessionTest, SpdyRateLimitRst) {\n  // The rate-limiting code grabs the event base from the EventBaseManager,\n  // so we need to set it.\n  folly::EventBaseManager::get()->setEventBase(&eventBase_, false);\n\n  IOBufQueue rst{IOBufQueue::cacheChainLength()};\n  clientCodec_->getEgressSettings()->setSetting(SettingsId::INITIAL_WINDOW_SIZE,\n                                                100000);\n  clientCodec_->generateSettings(requests_);\n  auto streamID = sendRequest();\n  clientCodec_->generateRstStream(rst, streamID, ErrorCode::CANCEL);\n\n  InSequence handlerSequence;\n  auto handler1 = addSimpleNiceHandler();\n  handler1->expectHeaders([&] {\n      uint32_t rateLimit_kbps = 640;\n      handler1->txn_->setEgressRateLimit(rateLimit_kbps * 1024);\n    });\n  handler1->expectEOM([&handler1] {\n      uint32_t rspLengthBytes = 100000;\n      handler1->sendHeaders(200, rspLengthBytes);\n      handler1->sendBody(rspLengthBytes);\n      handler1->txn_->sendEOM();\n    });\n  handler1->expectError();\n  handler1->expectDetachTransaction();\n  expectDetachSession();\n\n  flushRequestsAndLoop(true, milliseconds(50), milliseconds(0), [&] {\n      transport_->addReadEvent(rst, milliseconds(10));\n    });\n}\n\n// Send a 1.0 request, egress the EOM with the last body chunk on a paused\n// socket, and let it timeout.  dropConnection()\n// to removeTransaction with writesDraining_=true\nTEST_F(HTTPDownstreamSessionTest, WriteTimeout) {\n  HTTPMessage req = getGetRequest();\n  req.setHTTPVersion(1, 0);\n  sendRequest(req);\n\n  InSequence handlerSequence;\n  auto handler1 = addSimpleNiceHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1, this] {\n      handler1->sendHeaders(200, 100);\n      eventBase_.tryRunAfterDelay([&handler1, this] {\n          transport_->pauseWrites();\n          handler1->sendBody(100);\n          handler1->txn_->sendEOM();\n        }, 50);\n    });\n  handler1->expectError([&] (const HTTPException& ex) {\n      ASSERT_EQ(ex.getProxygenError(), kErrorWriteTimeout);\n      ASSERT_EQ(folly::to<std::string>(\"WriteTimeout on transaction id: \",\n                                       handler1->txn_->getID()),\n                std::string(ex.what()));\n    });\n  handler1->expectDetachTransaction();\n\n  expectDetachSession();\n\n  flushRequestsAndLoop();\n}\n\n// Send an abort from the write timeout path while pipelining\nTEST_F(HTTPDownstreamSessionTest, WriteTimeoutPipeline) {\n  const char* buf = \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\"\n    \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\";\n  requests_.append(buf, strlen(buf));\n\n  InSequence handlerSequence;\n  auto handler1 = addSimpleNiceHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1, this] {\n      handler1->sendHeaders(200, 100);\n      eventBase_.tryRunAfterDelay([&handler1, this] {\n          transport_->pauseWrites();\n          handler1->sendBody(100);\n          handler1->txn_->sendEOM();\n        }, 50);\n    });\n  auto handler2 = addSimpleNiceHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM();\n  handler1->expectError([&] (const HTTPException& ex) {\n      ASSERT_EQ(ex.getProxygenError(), kErrorWriteTimeout);\n      ASSERT_EQ(folly::to<std::string>(\"WriteTimeout on transaction id: \",\n                                       handler1->txn_->getID()),\n                std::string(ex.what()));\n      handler1->txn_->sendAbort();\n    });\n  handler2->expectError([&] (const HTTPException& ex) {\n      ASSERT_EQ(ex.getProxygenError(), kErrorWriteTimeout);\n      ASSERT_EQ(folly::to<std::string>(\"WriteTimeout on transaction id: \",\n                                       handler2->txn_->getID()),\n                std::string(ex.what()));\n      handler2->txn_->sendAbort();\n    });\n  handler2->expectDetachTransaction();\n  handler1->expectDetachTransaction();\n  expectDetachSession();\n\n  flushRequestsAndLoop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, BodyPacketization) {\n  HTTPMessage req = getGetRequest();\n  req.setHTTPVersion(1, 0);\n  req.setWantsKeepalive(false);\n  sendRequest(req);\n\n  InSequence handlerSequence;\n  auto handler1 = addSimpleNiceHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1] {\n      handler1->sendReplyWithBody(200, 32768);\n    });\n  handler1->expectDetachTransaction();\n\n  expectDetachSession();\n\n  // Keep the session around even after the event base loop completes so we can\n  // read the counters on a valid object.\n  HTTPSession::DestructorGuard g(httpSession_);\n  flushRequestsAndLoop();\n\n  EXPECT_EQ(transport_->getWriteEvents()->size(), 1);\n}\n\nTEST_F(HTTPDownstreamSessionTest, HttpMalformedPkt1) {\n  // Create a HTTP connection and keep sending just '\\n' to the HTTP1xCodec.\n  std::string data(90000, '\\n');\n  requests_.append(data.data(), data.length());\n\n  expectDetachSession();\n\n  flushRequestsAndLoop(true, milliseconds(0));\n}\n\nTEST_F(HTTPDownstreamSessionTest, BigExplcitChunkWrite) {\n  // even when the handler does a massive write, the transport only gets small\n  // writes\n  sendRequest();\n\n  auto handler = addSimpleNiceHandler();\n  handler->expectHeaders([&handler] {\n      handler->sendHeaders(200, 100, false);\n      size_t len = 16 * 1024 * 1024;\n      handler->txn_->sendChunkHeader(len);\n      auto chunk = makeBuf(len);\n      handler->txn_->sendBody(std::move(chunk));\n      handler->txn_->sendChunkTerminator();\n      handler->txn_->sendEOM();\n    });\n  handler->expectDetachTransaction();\n\n  expectDetachSession();\n\n  // Keep the session around even after the event base loop completes so we can\n  // read the counters on a valid object.\n  HTTPSession::DestructorGuard g(httpSession_);\n  flushRequestsAndLoop();\n\n  EXPECT_GT(transport_->getWriteEvents()->size(), 250);\n}\n\n\n// ==== upgrade tests ====\n\n// Test upgrade to a protocol unknown to HTTPSession\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNonNative) {\n  auto handler = addSimpleStrictHandler();\n\n  handler->expectHeaders([&handler] {\n      handler->sendHeaders(101, 0, true, {{\"Upgrade\", \"blarf\"}});\n    });\n  EXPECT_CALL(*handler, onUpgrade(UpgradeProtocol::TCP));\n  handler->expectEOM([&handler] {\n      handler->txn_->sendEOM();\n    });\n  handler->expectDetachTransaction();\n\n  sendRequest(getUpgradeRequest(\"blarf\"));\n  expectDetachSession();\n  flushRequestsAndLoop(true);\n}\n\n// Test upgrade to a protocol unknown to HTTPSession, but don't switch\n// protocols\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNonNativeIgnore) {\n  auto handler = addSimpleStrictHandler();\n\n  handler->expectHeaders([&handler] {\n      handler->sendReplyWithBody(200, 100);\n    });\n  handler->expectEOM();\n  handler->expectDetachTransaction();\n\n  sendRequest(getUpgradeRequest(\"blarf\"));\n\n  expectDetachSession();\n  flushRequestsAndLoop(true);\n}\n\n\n// Test upgrade to a protocol unknown to HTTPSession\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNonNativePipeline) {\n  auto handler1 = addSimpleStrictHandler();\n\n  handler1->expectHeaders([&handler1] (std::shared_ptr<HTTPMessage> msg) {\n      EXPECT_EQ(msg->getHeaders().getSingleOrEmpty(HTTP_HEADER_UPGRADE),\n                \"blarf\");\n      handler1->sendReplyWithBody(200, 100);\n    });\n  handler1->expectEOM();\n  handler1->expectDetachTransaction();\n\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders([&handler2] {\n      handler2->sendReplyWithBody(200, 100);\n    });\n  handler2->expectEOM();\n  handler2->expectDetachTransaction();\n\n  sendRequest(getUpgradeRequest(\"blarf\"));\n  transport_->addReadEvent(\"GET / HTTP/1.1\\r\\n\"\n                           \"\\r\\n\");\n  expectDetachSession();\n  flushRequestsAndLoop(true);\n}\n\n// Helper that does a simple upgrade test - request an upgrade, receive a 101\n// and an upgraded response\ntemplate <class C>\nvoid HTTPDownstreamTest<C>::testSimpleUpgrade(\n  const std::string& upgradeHeader,\n  CodecProtocol expectedProtocol,\n  const std::string& expectedUpgradeHeader) {\n  this->rawCodec_->setAllowedUpgradeProtocols({expectedUpgradeHeader});\n\n  auto handler = addSimpleStrictHandler();\n\n  HeaderIndexingStrategy testH2IndexingStrat;\n  handler->expectHeaders();\n  EXPECT_CALL(mockController_, onSessionCodecChange(httpSession_));\n  handler->expectEOM(\n    [&handler, expectedProtocol, expectedUpgradeHeader, &testH2IndexingStrat] {\n      EXPECT_FALSE(handler->txn_->getSetupTransportInfo().secure);\n      EXPECT_EQ(*handler->txn_->getSetupTransportInfo().appProtocol,\n                expectedUpgradeHeader);\n      if (expectedProtocol == CodecProtocol::HTTP_2) {\n        const HTTP2Codec* codec = dynamic_cast<const HTTP2Codec*>(\n          &handler->txn_->getTransport().getCodec());\n        ASSERT_NE(codec, nullptr);\n        EXPECT_EQ(codec->getHeaderIndexingStrategy(), &testH2IndexingStrat);\n      }\n      handler->sendReplyWithBody(200, 100);\n    });\n  handler->expectDetachTransaction();\n\n  if (expectedProtocol == CodecProtocol::HTTP_2) {\n    EXPECT_CALL(mockController_, getHeaderIndexingStrategy())\n      .WillOnce(\n        Return(&testH2IndexingStrat)\n    );\n  }\n\n  HTTPMessage req = getUpgradeRequest(upgradeHeader);\n  if (upgradeHeader == http2::kProtocolCleartextString) {\n    HTTP2Codec::requestUpgrade(req);\n  }\n  sendRequest(req);\n  flushRequestsAndLoop();\n\n  expect101(expectedProtocol, expectedUpgradeHeader);\n  expectResponse();\n\n  gracefulShutdown();\n}\n\n// Upgrade to SPDY/3\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNative3) {\n  testSimpleUpgrade(\"spdy/3\", CodecProtocol::SPDY_3, \"spdy/3\");\n}\n\n// Upgrade to SPDY/3.1\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNative31) {\n  testSimpleUpgrade(\"spdy/3.1\", CodecProtocol::SPDY_3_1, \"spdy/3.1\");\n}\n\n// Upgrade to HTTP/2\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativeH2) {\n  testSimpleUpgrade(\"h2c\", CodecProtocol::HTTP_2, \"h2c\");\n}\n\nclass HTTPDownstreamSessionUpgradeFlowControlTest :\n      public HTTPDownstreamSessionTest {\n public:\n  HTTPDownstreamSessionUpgradeFlowControlTest()\n      : HTTPDownstreamSessionTest({100000, 105000, 110000}) {}\n};\n\n// Upgrade to HTTP/2, with non-default flow control settings\nTEST_F(HTTPDownstreamSessionUpgradeFlowControlTest, UpgradeH2Flowcontrol) {\n  testSimpleUpgrade(\"h2c\", CodecProtocol::HTTP_2, \"h2c\");\n}\n\n// Upgrade to SPDY/3.1 with a non-native proto in the list\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativeUnknown) {\n  // This is maybe weird, the client asked for non-native as first choice,\n  // but we go native\n  testSimpleUpgrade(\"blarf, spdy/3.1, spdy/3\",\n                    CodecProtocol::SPDY_3_1, \"spdy/3.1\");\n}\n\n// Upgrade header with extra whitespace\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativeWhitespace) {\n  testSimpleUpgrade(\" \\tspdy/3.1\\t , spdy/3\",\n                    CodecProtocol::SPDY_3_1, \"spdy/3.1\");\n}\n\n// Upgrade header with random junk\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativeJunk) {\n  testSimpleUpgrade(\",,,,   ,,\\t~^%$(*&@(@$^^*(,spdy/3\",\n                    CodecProtocol::SPDY_3, \"spdy/3\");\n}\n\n// Attempt to upgrade on second txn\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativeTxn2) {\n  this->rawCodec_->setAllowedUpgradeProtocols({\"spdy/3\"});\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1] {\n      handler1->sendReplyWithBody(200, 100);\n    });\n  handler1->expectDetachTransaction();\n  sendRequest(getGetRequest());\n  flushRequestsAndLoop();\n  expectResponse();\n\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&handler2] {\n      handler2->sendReplyWithBody(200, 100);\n    });\n  handler2->expectDetachTransaction();\n\n  sendRequest(getUpgradeRequest(\"spdy/3\"));\n  flushRequestsAndLoop();\n  expectResponse();\n  gracefulShutdown();\n}\n\n// Upgrade on POST\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativePost) {\n  this->rawCodec_->setAllowedUpgradeProtocols({\"spdy/3\"});\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders();\n  handler->expectBody();\n  EXPECT_CALL(mockController_, onSessionCodecChange(httpSession_));\n  handler->expectEOM([&handler] {\n      handler->sendReplyWithBody(200, 100);\n    });\n  handler->expectDetachTransaction();\n\n  HTTPMessage req = getUpgradeRequest(\"spdy/3\", HTTPMethod::POST, 10);\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateBody(requests_, streamID, makeBuf(10),\n                             HTTPCodec::NoPadding, true);\n  // cheat and not sending EOM, it's a no-op\n  flushRequestsAndLoop();\n  expect101(CodecProtocol::SPDY_3, \"spdy/3\");\n  expectResponse();\n  gracefulShutdown();\n}\n\n// Upgrade on POST with a reply that comes before EOM, don't switch protocols\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativePostEarlyResp) {\n  this->rawCodec_->setAllowedUpgradeProtocols({\"spdy/3\"});\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders([&handler] {\n      handler->sendReplyWithBody(200, 100);\n    });\n  handler->expectBody();\n  handler->expectEOM();\n  handler->expectDetachTransaction();\n\n  HTTPMessage req = getUpgradeRequest(\"spdy/3\", HTTPMethod::POST, 10);\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateBody(requests_, streamID, makeBuf(10),\n                             HTTPCodec::NoPadding, true);\n  flushRequestsAndLoop();\n  expectResponse();\n  gracefulShutdown();\n}\n\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativePostEarlyPartialResp) {\n  this->rawCodec_->setAllowedUpgradeProtocols({\"spdy/3\"});\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders([&handler] {\n      handler->sendHeaders(200, 100);\n    });\n  handler->expectBody();\n  handler->expectEOM([&handler] {\n      handler->sendBody(100);\n      handler->txn_->sendEOM();\n    });\n  handler->expectDetachTransaction();\n\n  HTTPMessage req = getUpgradeRequest(\"spdy/3\", HTTPMethod::POST, 10);\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateBody(requests_, streamID, makeBuf(10),\n                             HTTPCodec::NoPadding, true);\n  flushRequestsAndLoop();\n  expectResponse();\n  gracefulShutdown();\n}\n\n// Upgrade but with a pipelined HTTP request.  It is parsed as SPDY and\n// rejected\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativeExtra) {\n  this->rawCodec_->setAllowedUpgradeProtocols({\"spdy/3\"});\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders();\n  EXPECT_CALL(mockController_, onSessionCodecChange(httpSession_));\n  handler->expectEOM([&handler] {\n      handler->sendReplyWithBody(200, 100);\n    });\n  handler->expectDetachTransaction();\n\n  sendRequest(getUpgradeRequest(\"spdy/3\"));\n  // It's a fatal to send this out on the HTTP1xCodec, so hack it manually\n  transport_->addReadEvent(\"GET / HTTP/1.1\\r\\n\"\n                           \"Upgrade: spdy/3\\r\\n\"\n                           \"\\r\\n\");\n  flushRequestsAndLoop();\n  expect101(CodecProtocol::SPDY_3, \"spdy/3\");\n  expectResponse(200, ErrorCode::_SPDY_INVALID_STREAM);\n  gracefulShutdown();\n}\n\n// Upgrade on POST with Expect: 100-Continue.  If the 100 goes out\n// before the EOM is parsed, the 100 will be in HTTP.  This should be the normal\n// case since the client *should* wait a bit for the 100 continue to come back\n// before sending the POST.  But if the 101 is delayed beyond EOM, the 101\n// will come via SPDY.\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativePost100) {\n  this->rawCodec_->setAllowedUpgradeProtocols({\"spdy/3\"});\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders([&handler] {\n      handler->sendHeaders(100, 0);\n    });\n  handler->expectBody();\n  EXPECT_CALL(mockController_, onSessionCodecChange(httpSession_));\n  handler->expectEOM([&handler] {\n      handler->sendReplyWithBody(200, 100);\n    });\n  handler->expectDetachTransaction();\n\n  HTTPMessage req = getUpgradeRequest(\"spdy/3\", HTTPMethod::POST, 10);\n  req.getHeaders().add(HTTP_HEADER_EXPECT, \"100-continue\");\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateBody(requests_, streamID, makeBuf(10),\n                             HTTPCodec::NoPadding, true);\n  flushRequestsAndLoop();\n  expect101(CodecProtocol::SPDY_3, \"spdy/3\", true /* expect 100 continue */);\n  expectResponse();\n  gracefulShutdown();\n}\n\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativePost100Late) {\n  this->rawCodec_->setAllowedUpgradeProtocols({\"spdy/3\"});\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders();\n  handler->expectBody();\n  EXPECT_CALL(mockController_, onSessionCodecChange(httpSession_));\n  handler->expectEOM([&handler] {\n      handler->sendHeaders(100, 0);\n      handler->sendReplyWithBody(200, 100);\n    });\n  handler->expectDetachTransaction();\n\n  HTTPMessage req = getUpgradeRequest(\"spdy/3\", HTTPMethod::POST, 10);\n  req.getHeaders().add(HTTP_HEADER_EXPECT, \"100-continue\");\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateBody(requests_, streamID, makeBuf(10),\n                             HTTPCodec::NoPadding, true);\n  flushRequestsAndLoop();\n  expect101(CodecProtocol::SPDY_3, \"spdy/3\");\n  expectResponse(200, ErrorCode::NO_ERROR, true /* expect 100 via SPDY */);\n  gracefulShutdown();\n}\n\n\nTEST_F(SPDY3DownstreamSessionTest, SpdyPrio) {\n  testPriorities(8);\n\n  cleanup();\n}\n\n// Test sending a GOAWAY while the downstream session is still processing\n// the request that was an upgrade.  The reply GOAWAY should have last good\n// stream = 1, not 0.\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeGoawayDrain) {\n  this->rawCodec_->setAllowedUpgradeProtocols({\"h2c\"});\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders();\n  handler->expectBody();\n  EXPECT_CALL(mockController_, onSessionCodecChange(httpSession_));\n  handler->expectEOM();\n  handler->expectGoaway();\n  handler->expectDetachTransaction();\n\n  EXPECT_CALL(mockController_, getHeaderIndexingStrategy())\n    .WillOnce(\n      Return(&testH2IndexingStrat_)\n  );\n\n  HTTPMessage req = getUpgradeRequest(\"h2c\", HTTPMethod::POST, 10);\n  HTTP2Codec::requestUpgrade(req);\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateBody(requests_, streamID, makeBuf(10),\n                             HTTPCodec::NoPadding, true);\n  // cheat and not sending EOM, it's a no-op\n\n  flushRequestsAndLoop();\n  expect101(CodecProtocol::HTTP_2, \"h2c\");\n  clientCodec_->generateConnectionPreface(requests_);\n  clientCodec_->generateGoaway(requests_, 0, ErrorCode::NO_ERROR);\n  flushRequestsAndLoop();\n  eventBase_.runInLoop([&handler] {\n      handler->sendReplyWithBody(200, 100);\n    });\n  HTTPSession::DestructorGuard g(httpSession_);\n  eventBase_.loop();\n  expectResponse(200, ErrorCode::NO_ERROR, false, true);\n  expectDetachSession();\n}\n\ntemplate <class C>\nvoid HTTPDownstreamTest<C>::testPriorities(uint32_t numPriorities) {\n  uint32_t iterations = 10;\n  uint32_t maxPriority = numPriorities - 1;\n  std::vector<std::unique_ptr<testing::NiceMock<MockHTTPHandler>>> handlers;\n  for (int pri = numPriorities - 1; pri >= 0; pri--) {\n    for (uint32_t i = 0; i < iterations; i++) {\n      sendRequest(\"/\", pri * (8 / numPriorities));\n      InSequence handlerSequence;\n      auto handler = addSimpleNiceHandler();\n      auto rawHandler = handler.get();\n      handlers.push_back(std::move(handler));\n      rawHandler->expectHeaders();\n      rawHandler->expectEOM([rawHandler] {\n          rawHandler->sendReplyWithBody(200, 1000);\n        });\n      rawHandler->expectDetachTransaction([] {  });\n    }\n  }\n\n  auto buf = requests_.move();\n  buf->coalesce();\n  requests_.append(std::move(buf));\n\n  flushRequestsAndLoop();\n\n  std::list<HTTPCodec::StreamID> streams;\n  EXPECT_CALL(callbacks_, onMessageBegin(_, _))\n    .Times(iterations * numPriorities);\n  EXPECT_CALL(callbacks_, onHeadersComplete(_, _))\n    .Times(iterations * numPriorities);\n  // body is variable and hence ignored\n  EXPECT_CALL(callbacks_, onMessageComplete(_, _))\n      .Times(iterations * numPriorities)\n      .WillRepeatedly(Invoke([&](HTTPCodec::StreamID stream, bool /*upgrade*/) {\n        streams.push_back(stream);\n      }));\n\n  parseOutput(*clientCodec_);\n\n  // transactions finish in priority order (higher streamIDs first)\n  EXPECT_EQ(streams.size(), iterations * numPriorities);\n  auto txn = streams.begin();\n  for (int band = maxPriority; band >= 0; band--) {\n    auto upperID = iterations * 2 * (band + 1);\n    auto lowerID = iterations * 2 * band;\n    for (uint32_t i = 0; i < iterations; i++) {\n      EXPECT_LE(lowerID, (uint32_t)*txn);\n      EXPECT_GE(upperID, (uint32_t)*txn);\n      ++txn;\n    }\n  }\n}\n\n// Verifies that the read timeout is not running when no ingress is expected/\n// required to proceed\nTEST_F(SPDY3DownstreamSessionTest, SpdyTimeout) {\n  sendRequest();\n  sendRequest();\n\n  httpSession_->setWriteBufferLimit(512);\n\n  InSequence handlerSequence;\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders([this] { transport_->pauseWrites(); });\n  handler1->expectEOM([&] {\n      handler1->sendHeaders(200, 1000);\n      handler1->sendBody(1000);\n    });\n  handler1->expectEgressPaused();\n  auto handler2 = addSimpleStrictHandler();\n  // handler2 is paused before it gets headers\n  handler2->expectEgressPaused();\n  handler2->expectHeaders();\n  handler2->expectEOM([this] {\n      // This transaction should start egress paused.  We've received the\n      // EOM, so the timeout shouldn't be running delay 400ms and resume\n      // writes, this keeps txn1 from getting a write timeout\n      resumeWritesAfterDelay(milliseconds(400));\n    });\n  handler1->expectEgressResumed([&handler1] { handler1->txn_->sendEOM(); });\n  handler2->expectEgressResumed([&handler2, this] {\n      // delay an additional 200ms.  The total 600ms delay shouldn't fire\n      // onTimeout\n      eventBase_.tryRunAfterDelay([&handler2] {\n          handler2->sendReplyWithBody(200, 400); }, 200\n        );\n    });\n  handler1->expectDetachTransaction();\n  handler2->expectDetachTransaction();\n\n  flushRequestsAndLoop(false, milliseconds(0), milliseconds(10));\n\n  cleanup();\n}\n\n// Verifies that the read timer is running while a transaction is blocked\n// on a window update\nTEST_F(SPDY3DownstreamSessionTest, SpdyTimeoutWin) {\n  clientCodec_->getEgressSettings()->setSetting(SettingsId::INITIAL_WINDOW_SIZE,\n                                                500);\n  clientCodec_->generateSettings(requests_);\n  auto streamID = sendRequest();\n\n  InSequence handlerSequence;\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders();\n  handler->expectEOM([&] {\n      handler->sendReplyWithBody(200, 1000);\n    });\n  handler->expectEgressPaused();\n  handler->expectError([&] (const HTTPException& ex) {\n      ASSERT_EQ(ex.getProxygenError(), kErrorWriteTimeout);\n      ASSERT_EQ(\n        folly::to<std::string>(\"ingress timeout, streamID=\", streamID),\n        std::string(ex.what()));\n      handler->terminate();\n    });\n  handler->expectDetachTransaction();\n\n  flushRequestsAndLoop();\n\n  cleanup();\n}\n\nTYPED_TEST_CASE_P(HTTPDownstreamTest);\n\nTYPED_TEST_P(HTTPDownstreamTest, TestWritesDraining) {\n  auto badCodec =\n    makeServerCodec<typename TypeParam::Codec>(TypeParam::version);\n  this->sendRequest();\n  badCodec->generatePushPromise(this->requests_, 2 /* bad */, getGetRequest(),\n                                1);\n\n  this->expectDetachSession();\n\n  InSequence handlerSequence;\n  auto handler1 = this->addSimpleNiceHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM();\n  handler1->expectError([&](const HTTPException& ex) {\n    ASSERT_EQ(ex.getProxygenError(), kErrorEOF);\n    ASSERT_TRUE(\n        folly::StringPiece(ex.what()).startsWith(\"Shutdown transport: EOF\"))\n        << ex.what();\n  });\n  handler1->expectDetachTransaction();\n\n  this->flushRequestsAndLoop();\n}\n\nTYPED_TEST_P(HTTPDownstreamTest, TestBodySizeLimit) {\n  this->clientCodec_->generateWindowUpdate(this->requests_, 0, 65536);\n  this->sendRequest();\n  this->sendRequest();\n\n  InSequence handlerSequence;\n  auto handler1 = this->addSimpleNiceHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM();\n  auto handler2 = this->addSimpleNiceHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&] {\n      handler1->sendReplyWithBody(200, 33000);\n      handler2->sendReplyWithBody(200, 33000);\n    });\n  handler1->expectDetachTransaction();\n  handler2->expectDetachTransaction();\n\n  this->flushRequestsAndLoop();\n\n  std::list<HTTPCodec::StreamID> streams;\n  EXPECT_CALL(this->callbacks_, onMessageBegin(1, _));\n  EXPECT_CALL(this->callbacks_, onHeadersComplete(1, _));\n  EXPECT_CALL(this->callbacks_, onMessageBegin(3, _));\n  EXPECT_CALL(this->callbacks_, onHeadersComplete(3, _));\n  for (uint32_t i = 0; i < 8; i++) {\n    EXPECT_CALL(this->callbacks_, onBody(1, _, _));\n    EXPECT_CALL(this->callbacks_, onBody(3, _, _));\n  }\n  EXPECT_CALL(this->callbacks_, onBody(1, _, _));\n  EXPECT_CALL(this->callbacks_, onMessageComplete(1, _));\n  EXPECT_CALL(this->callbacks_, onBody(3, _, _));\n  EXPECT_CALL(this->callbacks_, onMessageComplete(3, _));\n\n  this->parseOutput(*this->clientCodec_);\n\n  this->cleanup();\n}\n\n#define IF_HTTP2(X) \\\n  if (this->clientCodec_->getProtocol() == CodecProtocol::HTTP_2) { X; }\n\nTYPED_TEST_P(HTTPDownstreamTest, TestUniformPauseState) {\n  this->httpSession_->setWriteBufferLimit(12000);\n  this->clientCodec_->getEgressSettings()->setSetting(\n    SettingsId::INITIAL_WINDOW_SIZE, 1000000);\n  this->clientCodec_->generateSettings(this->requests_);\n  this->clientCodec_->generateWindowUpdate(this->requests_, 0, 1000000);\n  this->sendRequest(\"/\", 1);\n  this->sendRequest(\"/\", 1);\n  this->sendRequest(\"/\", 2);\n\n  InSequence handlerSequence;\n  auto handler1 = this->addSimpleStrictHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM();\n  auto handler2 = this->addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&] {\n      handler1->sendHeaders(200, 24002);\n      // triggers pause of all txns\n      this->transport_->pauseWrites();\n      handler1->txn_->sendBody(std::move(makeBuf(12001)));\n      this->resumeWritesAfterDelay(milliseconds(50));\n    });\n  handler1->expectEgressPaused();\n  handler2->expectEgressPaused();\n  auto handler3 = this->addSimpleStrictHandler();\n  handler3->expectEgressPaused();\n  handler3->expectHeaders();\n  handler3->expectEOM();\n\n  handler1->expectEgressResumed([&] {\n      // resume does not trigger another pause,\n      handler1->txn_->sendBody(std::move(makeBuf(12001)));\n    });\n  // handler2 gets a fair shot, handler3 is not resumed\n  // HTTP/2 priority is not implemented, so handler3 is like another 0 pri txn\n  handler2->expectEgressResumed();\n  IF_HTTP2(handler3->expectEgressResumed());\n  handler1->expectEgressPaused();\n  handler2->expectEgressPaused();\n  IF_HTTP2(handler3->expectEgressPaused());\n\n  handler1->expectEgressResumed();\n  handler2->expectEgressResumed([&] {\n      handler2->sendHeaders(200, 12001);\n      handler2->txn_->sendBody(std::move(makeBuf(12001)));\n      this->transport_->pauseWrites();\n      this->resumeWritesAfterDelay(milliseconds(50));\n    });\n  // handler3 not resumed\n  IF_HTTP2(handler3->expectEgressResumed());\n\n  handler1->expectEgressPaused();\n  handler2->expectEgressPaused();\n  IF_HTTP2(handler3->expectEgressPaused());\n\n  handler1->expectEgressResumed();\n  handler2->expectEgressResumed([&] {\n      handler1->txn_->sendEOM();\n      handler2->txn_->sendEOM();\n    });\n  handler3->expectEgressResumed([&] {\n      handler3->txn_->sendAbort();\n    });\n\n  handler3->expectDetachTransaction();\n  handler1->expectDetachTransaction();\n  handler2->expectDetachTransaction();\n\n  this->flushRequestsAndLoop();\n\n  this->cleanup();\n}\n\n// Test exceeding the MAX_CONCURRENT_STREAMS setting.  The txn should get\n// REFUSED_STREAM, and other streams can complete normally\nTYPED_TEST_P(HTTPDownstreamTest, TestMaxTxns) {\n  auto settings = this->rawCodec_->getEgressSettings();\n  auto maxTxns = settings->getSetting(SettingsId::MAX_CONCURRENT_STREAMS,\n                                      100);\n  std::list<unique_ptr<StrictMock<MockHTTPHandler>>> handlers;\n  {\n    InSequence enforceOrder;\n    for (auto i = 0U; i < maxTxns; i++) {\n      this->sendRequest();\n      auto handler = this->addSimpleStrictHandler();\n      handler->expectHeaders();\n      handler->expectEOM();\n      handlers.push_back(std::move(handler));\n    }\n    auto streamID = this->sendRequest();\n    this->clientCodec_->generateGoaway(this->requests_, 0, ErrorCode::NO_ERROR);\n\n    for (auto& handler: handlers) {\n      EXPECT_CALL(*handler, onGoaway(ErrorCode::NO_ERROR));\n    }\n\n    this->flushRequestsAndLoop();\n\n    EXPECT_CALL(this->callbacks_, onSettings(_));\n    EXPECT_CALL(this->callbacks_, onAbort(streamID, ErrorCode::REFUSED_STREAM));\n\n    this->parseOutput(*this->clientCodec_);\n  }\n  // handlers can finish out of order?\n  for (auto& handler: handlers) {\n    handler->sendReplyWithBody(200, 100);\n    handler->expectDetachTransaction();\n  }\n  this->expectDetachSession();\n  this->eventBase_.loop();\n}\n\n// Set max streams=1\n// send two spdy requests a few ms apart.\n// Block writes\n// generate a complete response for txn=1 before parsing txn=3\n// HTTPSession should allow the txn=3 to be served rather than refusing it\nTEST_F(SPDY3DownstreamSessionTest, SpdyMaxConcurrentStreams) {\n  HTTPMessage req = getGetRequest();\n  req.setHTTPVersion(1, 0);\n  req.setWantsKeepalive(false);\n  sendRequest(req);\n  auto req2p = sendRequestLater(req, true);\n\n  httpSession_->setEgressSettings({{\n        SettingsId::MAX_CONCURRENT_STREAMS, 1}});\n\n  InSequence handlerSequence;\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1, req, this, &req2p] {\n      transport_->pauseWrites();\n      handler1->sendReplyWithBody(200, 100);\n      req2p.setValue();\n    });\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&handler2, this] {\n      handler2->sendReplyWithBody(200, 100);\n      resumeWritesInLoop();\n    });\n  handler1->expectDetachTransaction();\n  handler2->expectDetachTransaction();\n\n  expectDetachSession();\n\n  flushRequestsAndLoop();\n}\n\nREGISTER_TYPED_TEST_CASE_P(HTTPDownstreamTest,\n                           TestWritesDraining, TestBodySizeLimit,\n                           TestUniformPauseState, TestMaxTxns);\n\ntypedef ::testing::Types<SPDY3CodecPair, SPDY3_1CodecPair,\n                         HTTP2CodecPair> ParallelCodecs;\nINSTANTIATE_TYPED_TEST_CASE_P(ParallelCodecs,\n                              HTTPDownstreamTest,\n                              ParallelCodecs);\n\nclass SPDY31DownstreamTest : public HTTPDownstreamTest<SPDY3_1CodecPair> {\n public:\n  SPDY31DownstreamTest()\n      : HTTPDownstreamTest<SPDY3_1CodecPair>({-1, -1,\n            2 * spdy::kInitialWindow}) {}\n};\n\nTEST_F(SPDY31DownstreamTest, TestSessionFlowControl) {\n  eventBase_.loopOnce();\n\n  InSequence sequence;\n  EXPECT_CALL(callbacks_, onSettings(_));\n  EXPECT_CALL(callbacks_, onWindowUpdate(0, spdy::kInitialWindow));\n  parseOutput(*clientCodec_);\n\n  cleanup();\n}\n\nTEST_F(SPDY3DownstreamSessionTest, TestEOFOnBlockedStream) {\n  sendRequest();\n\n  auto handler1 = addSimpleStrictHandler();\n\n  InSequence handlerSequence;\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1] {\n      handler1->sendReplyWithBody(200, 80000);\n    });\n  handler1->expectEgressPaused();\n\n  handler1->expectError([&] (const HTTPException& ex) {\n      // Not optimal to have a different error code here than the session\n      // flow control case, but HTTPException direction is immutable and\n      // building another one seems not future proof.\n      EXPECT_EQ(ex.getDirection(), HTTPException::Direction::INGRESS);\n    });\n  handler1->expectDetachTransaction();\n\n  expectDetachSession();\n\n  flushRequestsAndLoop(true, milliseconds(10));\n}\n\nTEST_F(SPDY31DownstreamTest, TestEOFOnBlockedSession) {\n  sendRequest();\n  sendRequest();\n\n  InSequence handlerSequence;\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1] {\n      handler1->sendHeaders(200, 40000);\n      handler1->sendBody(32769);\n    });\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&handler2, this] {\n      handler2->sendHeaders(200, 40000);\n      handler2->sendBody(32768);\n      eventBase_.runInLoop([this] { transport_->addReadEOF(milliseconds(0)); });\n    });\n\n  handler1->expectEgressPaused();\n  handler2->expectEgressPaused();\n  handler1->expectEgressResumed();\n  handler2->expectEgressResumed();\n  handler1->expectError([&] (const HTTPException& ex) {\n      EXPECT_EQ(ex.getDirection(),\n                HTTPException::Direction::INGRESS_AND_EGRESS);\n    });\n  handler1->expectDetachTransaction();\n  handler2->expectError([&] (const HTTPException& ex) {\n      EXPECT_EQ(ex.getDirection(),\n                HTTPException::Direction::INGRESS_AND_EGRESS);\n    });\n  handler2->expectDetachTransaction();\n\n  expectDetachSession();\n\n  flushRequestsAndLoop();\n}\n\n\nTEST_F(SPDY3DownstreamSessionTest, NewTxnEgressPaused) {\n  // Send 1 request with prio=0\n  // Have egress pause while sending the first response\n  // Send a second request with prio=1\n  //   -- the new txn should start egress paused\n  // Finish the body and eom both responses\n  // Unpause egress\n  // The first txn should complete first\n\n  sendRequest(\"/\", 0);\n  auto req2 = getGetRequest();\n  req2.setPriority(1);\n  auto req2p = sendRequestLater(req2, true);\n\n  unique_ptr<StrictMock<MockHTTPHandler>> handler1;\n  unique_ptr<StrictMock<MockHTTPHandler>> handler2;\n\n  httpSession_->setWriteBufferLimit(200); // lower the per session buffer limit\n  {\n    InSequence handlerSequence;\n    handler1 = addSimpleStrictHandler();\n    handler1->expectHeaders();\n    handler1->expectEOM([&handler1, this, &req2p] {\n        this->transport_->pauseWrites();\n        handler1->sendHeaders(200, 1000);\n        handler1->sendBody(100); // headers + 100 bytes - over the limit\n        req2p.setValue();\n      });\n    handler1->expectEgressPaused([] { LOG(INFO) << \"paused 1\"; });\n\n    handler2 = addSimpleStrictHandler();\n    handler2->expectEgressPaused(); // starts paused\n    handler2->expectHeaders();\n    handler2->expectEOM([&] {\n        // Technically shouldn't send while handler is egress paused, but meh.\n        handler1->sendBody(900);\n        handler1->txn_->sendEOM();\n        handler2->sendReplyWithBody(200, 1000);\n        resumeWritesInLoop();\n      });\n    handler1->expectDetachTransaction();\n    handler2->expectDetachTransaction();\n  }\n  HTTPSession::DestructorGuard g(httpSession_);\n  flushRequestsAndLoop();\n\n  std::list<HTTPCodec::StreamID> streams;\n  EXPECT_CALL(callbacks_, onMessageBegin(_, _))\n    .Times(2);\n  EXPECT_CALL(callbacks_, onHeadersComplete(_, _))\n    .Times(2);\n  // body is variable and hence ignored;\n  EXPECT_CALL(callbacks_, onMessageComplete(_, _))\n      .WillRepeatedly(Invoke([&](HTTPCodec::StreamID stream, bool /*upgrade*/) {\n        streams.push_back(stream);\n      }));\n  parseOutput(*clientCodec_);\n\n  cleanup();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, ZeroDeltaWindowUpdate) {\n  // generateHeader() will create a session and a transaction\n  auto streamID = sendHeader();\n  // First generate a frame with delta=1 so as to pass the checks, and then\n  // hack the frame so that delta=0 without modifying other checks\n  clientCodec_->generateWindowUpdate(requests_, streamID, 1);\n  requests_.trimEnd(http2::kFrameWindowUpdateSize);\n  QueueAppender appender(&requests_, http2::kFrameWindowUpdateSize);\n  appender.writeBE<uint32_t>(0);\n\n  auto handler = addSimpleStrictHandler();\n\n  InSequence handlerSequence;\n  handler->expectHeaders();\n  handler->expectError([&] (const HTTPException& ex) {\n      ASSERT_EQ(ex.getCodecStatusCode(), ErrorCode::PROTOCOL_ERROR);\n      ASSERT_EQ(\n        \"streamID=1 with HTTP2Codec stream error: window update delta=0\",\n        std::string(ex.what()));\n    });\n  handler->expectDetachTransaction();\n  expectDetachSession();\n\n  flushRequestsAndLoop();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, PaddingFlowControl) {\n  // generateHeader() will create a session and a transaction\n  auto streamID = sendHeader();\n  // This sends a total of 33kb including padding, so we should get a session\n  // and stream window update\n  for (auto i = 0; i < 129; i++) {\n    clientCodec_->generateBody(requests_, streamID, makeBuf(1), 255, false);\n  }\n\n  auto handler = addSimpleStrictHandler();\n\n  InSequence handlerSequence;\n  handler->expectHeaders([&] {\n      handler->txn_->pauseIngress();\n      eventBase_.runAfterDelay([&] { handler->txn_->resumeIngress(); },\n                               100);\n    });\n  EXPECT_CALL(*handler, onBody(_))\n    .Times(129);\n  handler->expectError();\n  handler->expectDetachTransaction();\n\n  HTTPSession::DestructorGuard g(httpSession_);\n  flushRequestsAndLoop(false, milliseconds(0), milliseconds(0), [&] {\n      clientCodec_->generateRstStream(requests_, streamID, ErrorCode::CANCEL);\n      clientCodec_->generateGoaway(requests_, 0, ErrorCode::NO_ERROR);\n      transport_->addReadEvent(requests_, milliseconds(110));\n    });\n\n  std::list<HTTPCodec::StreamID> streams;\n  EXPECT_CALL(callbacks_, onWindowUpdate(0, _));\n  EXPECT_CALL(callbacks_, onWindowUpdate(1, _));\n  parseOutput(*clientCodec_);\n  expectDetachSession();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, GracefulDrainOnTimeout) {\n  InSequence handlerSequence;\n  std::chrono::milliseconds gracefulTimeout(200);\n  httpSession_->enableDoubleGoawayDrain();\n  EXPECT_CALL(mockController_, getGracefulShutdownTimeout())\n    .WillOnce(InvokeWithoutArgs([&] {\n          // Once session asks for graceful shutdown timeout, expect the client\n          // to receive the first GOAWAY\n          eventBase_.runInLoop([&] {\n              EXPECT_CALL(callbacks_,\n                          onGoaway(std::numeric_limits<int32_t>::max(),\n                                   ErrorCode::NO_ERROR, _));\n              parseOutput(*clientCodec_);\n            });\n          return gracefulTimeout;\n        }));\n\n\n  // Simulate ConnectionManager idle timeout\n  eventBase_.runAfterDelay([&] { httpSession_->timeoutExpired(); },\n                           transactionTimeouts_->getDefaultTimeout().count());\n  HTTPSession::DestructorGuard g(httpSession_);\n  auto start = getCurrentTime();\n  eventBase_.loop();\n  auto finish = getCurrentTime();\n  auto minDuration =\n    gracefulTimeout + transactionTimeouts_->getDefaultTimeout();\n  EXPECT_GE((finish - start).count(), minDuration.count());\n  EXPECT_CALL(callbacks_, onGoaway(0, ErrorCode::NO_ERROR, _));\n  parseOutput(*clientCodec_);\n  expectDetachSession();\n}\n\n/*\n * The sequence of streams are generated in the following order:\n * - [client --> server] request 1st stream (getGetRequest())\n * - [server --> client] respond 1st stream (res with length 100)\n * - [server --> client] request 2nd stream (req)\n * - [server --> client] respond 2nd stream (res with length 200 + EOM)\n * - [client --> server] RST_STREAM on the 1st stream\n */\nTEST_F(HTTP2DownstreamSessionTest, ServerPush) {\n  // Create a dummy request and a dummy response messages\n  HTTPMessage req, res;\n  req.getHeaders().set(\"HOST\", \"www.foo.com\");\n  req.setURL(\"https://www.foo.com/\");\n  res.setStatusCode(200);\n  res.setStatusMessage(\"Ohai\");\n\n  // enable server push\n  clientCodec_->getEgressSettings()->setSetting(SettingsId::ENABLE_PUSH, 1);\n  clientCodec_->generateSettings(requests_);\n  // generateHeader() will create a session and a transaction\n  auto assocStreamId = HTTPCodec::StreamID(1);\n  clientCodec_->generateHeader(requests_, assocStreamId, getGetRequest(),\n                               false, nullptr);\n\n  auto handler = addSimpleStrictHandler();\n  StrictMock<MockHTTPPushHandler> pushHandler;\n\n  InSequence handlerSequence;\n  handler->expectHeaders([&] {\n      // Generate response for the associated stream\n      handler->txn_->sendHeaders(res);\n      handler->txn_->sendBody(makeBuf(100));\n      handler->txn_->pauseIngress();\n\n      auto* pushTxn = handler->txn_->newPushedTransaction(&pushHandler);\n      ASSERT_NE(pushTxn, nullptr);\n      // Generate a push request (PUSH_PROMISE)\n      auto outgoingStreams = httpSession_->getNumOutgoingStreams();\n      pushTxn->sendHeaders(req);\n      EXPECT_EQ(httpSession_->getNumOutgoingStreams(), outgoingStreams);\n      // Generate a push response\n      auto pri = handler->txn_->getPriority();\n      res.setHTTP2Priority(std::make_tuple(pri.streamDependency,\n                                           pri.exclusive, pri.weight));\n      pushTxn->sendHeaders(res);\n      EXPECT_EQ(httpSession_->getNumOutgoingStreams(), outgoingStreams + 1);\n      pushTxn->sendBody(makeBuf(200));\n      pushTxn->sendEOM();\n\n      eventBase_.runAfterDelay([&] { handler->txn_->resumeIngress(); },\n                               100);\n    });\n  EXPECT_CALL(pushHandler, setTransaction(_))\n    .WillOnce(Invoke([&] (HTTPTransaction* txn) {\n          pushHandler.txn_ = txn; }));\n  EXPECT_CALL(pushHandler, detachTransaction());\n  handler->expectError();\n  handler->expectDetachTransaction();\n\n  transport_->addReadEvent(requests_, milliseconds(0));\n  clientCodec_->generateRstStream(requests_, assocStreamId, ErrorCode::CANCEL);\n  clientCodec_->generateGoaway(requests_, 2, ErrorCode::NO_ERROR);\n  transport_->addReadEvent(requests_, milliseconds(200));\n  transport_->startReadEvents();\n  HTTPSession::DestructorGuard g(httpSession_);\n  eventBase_.loop();\n\n  EXPECT_CALL(callbacks_, onMessageBegin(1, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(1, _));\n  EXPECT_CALL(callbacks_, onPushMessageBegin(2, 1, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(2, _));\n  EXPECT_CALL(callbacks_, onMessageBegin(2, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(2, _));\n  EXPECT_CALL(callbacks_, onMessageComplete(2, _));\n\n  parseOutput(*clientCodec_);\n  expectDetachSession();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, ServerPushAbortPaused) {\n  // Create a dummy request and a dummy response messages\n  HTTPMessage req, res;\n  req.getHeaders().set(\"HOST\", \"www.foo.com\");\n  req.setURL(\"https://www.foo.com/\");\n  res.setStatusCode(200);\n  res.setStatusMessage(\"Ohai\");\n\n  // enable server push\n  clientCodec_->getEgressSettings()->setSetting(SettingsId::ENABLE_PUSH, 1);\n  clientCodec_->generateSettings(requests_);\n  // generateHeader() will create a session and a transaction\n  auto assocStreamId = HTTPCodec::StreamID(1);\n  clientCodec_->generateHeader(requests_, assocStreamId, getGetRequest(),\n                               false, nullptr);\n\n  auto handler = addSimpleStrictHandler();\n  StrictMock<MockHTTPPushHandler> pushHandler;\n\n  InSequence handlerSequence;\n  handler->expectHeaders([&] {\n      // Generate response for the associated stream\n      this->transport_->pauseWrites();\n      handler->txn_->sendHeaders(res);\n      handler->txn_->sendBody(makeBuf(100));\n      handler->txn_->pauseIngress();\n\n      auto* pushTxn = handler->txn_->newPushedTransaction(&pushHandler);\n      ASSERT_NE(pushTxn, nullptr);\n      // Generate a push request (PUSH_PROMISE)\n      pushTxn->sendHeaders(req);\n    });\n  EXPECT_CALL(pushHandler, setTransaction(_))\n    .WillOnce(Invoke([&] (HTTPTransaction* txn) {\n          pushHandler.txn_ = txn; }));\n  EXPECT_CALL(pushHandler, onError(_));\n  EXPECT_CALL(pushHandler, detachTransaction());\n  handler->expectError();\n  handler->expectDetachTransaction();\n\n  transport_->addReadEvent(requests_, milliseconds(0));\n  // Cancels everything\n  clientCodec_->generateRstStream(requests_, assocStreamId, ErrorCode::CANCEL);\n  transport_->addReadEvent(requests_, milliseconds(10));\n  transport_->startReadEvents();\n  HTTPSession::DestructorGuard g(httpSession_);\n  eventBase_.loop();\n\n  parseOutput(*clientCodec_);\n  expectDetachSession();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestPriorityWeightsTinyRatio) {\n  // Create a transaction with egress and a ratio small enough that\n  // ratio*4096 < 1.\n  //\n  //     root\n  //     /  \\                                                 level 1\n  //   256   1 (no egress)\n  //        / \\                                               level 2\n  //      256  1  <-- has ratio (1/257)^2\n  InSequence enforceOrder;\n  auto req1 = getGetRequest();\n  auto req2 = getGetRequest();\n  req1.setHTTP2Priority(HTTPMessage::HTTPPriority{0, false, 255});\n  req2.setHTTP2Priority(HTTPMessage::HTTPPriority{0, false, 0});\n\n  sendRequest(req1);\n  auto id2 = sendRequest(req2);\n  req1.setHTTP2Priority(HTTPMessage::HTTPPriority{id2, false, 255});\n  req2.setHTTP2Priority(HTTPMessage::HTTPPriority{id2, false, 0});\n  sendRequest(req1);\n  sendRequest(req2);\n\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&] {\n      handler1->sendReplyWithBody(200, 4 * 1024);\n    });\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM();\n  auto handler3 = addSimpleStrictHandler();\n  handler3->expectHeaders();\n  handler3->expectEOM([&] {\n      handler3->sendReplyWithBody(200, 15);\n    });\n  auto handler4 = addSimpleStrictHandler();\n  handler4->expectHeaders();\n  handler4->expectEOM([&] {\n      handler4->sendReplyWithBody(200, 1);\n    });\n\n  handler1->expectDetachTransaction([&] {\n      HTTPTransaction::PrioritySampleSummary summary;\n      EXPECT_EQ(handler1->txn_->getPrioritySampleSummary(summary), true);\n      EXPECT_EQ(handler1->txn_->getTransport().getHTTP2PrioritiesEnabled(),\n                true);\n      // id1 had no egress when id2 was running, so id1 was contending only with\n      // id3 and id4. Average number of contentions for id1 is 3\n      EXPECT_EQ(summary.contentions_.byTransactionBytes_, 3);\n      EXPECT_EQ(summary.contentions_.bySessionBytes_, 3);\n      // this is a first level transaction, depth == 1\n      EXPECT_EQ(summary.depth_.byTransactionBytes_, 1);\n      EXPECT_EQ(summary.depth_.bySessionBytes_, 1);\n      // the expected relative weight is 256/257 ~= 0.9961\n      EXPECT_GT(summary.expected_weight_, 0.996);\n      EXPECT_LT(summary.expected_weight_, 0.9962);\n      // the measured relative weight is 4096/(4096+15) ~= 0.99635\n      // This value is higher than the expected relative weight of 0.9961.\n      // Due to the arithmetical rounding to the lowest integer, the measured\n      // relative weight tends to be higher for transactions with high relative\n      // weights and lower for transactions with the low relative weights.\n      EXPECT_GT(summary.measured_weight_, 0.9963);\n      EXPECT_LT(summary.measured_weight_, 0.9964);\n    });\n  handler3->expectDetachTransaction([&] {\n      HTTPTransaction::PrioritySampleSummary summary;\n      EXPECT_EQ(handler3->txn_->getPrioritySampleSummary(summary), true);\n      EXPECT_EQ(handler3->txn_->getTransport().getHTTP2PrioritiesEnabled(),\n                true);\n      // Similarly, id3 was contenting with id1 and id4\n      // Average number of contentions for id3 is 3\n      EXPECT_EQ(summary.contentions_.byTransactionBytes_, 3);\n      EXPECT_EQ(summary.contentions_.bySessionBytes_, 3);\n      // this is a second level transaction where parent has\n      // no egress, depth == 2\n      EXPECT_EQ(summary.depth_.byTransactionBytes_, 2);\n      EXPECT_EQ(summary.depth_.bySessionBytes_, 2);\n      // the expected relative weight should be\n      // 1/257 * 256/257 ~= 0.00388. However, in the calculation of the\n      // allowed bytes to send we rounding to the lowest positive integer.\n      // Therefore, the measured relative weight tends to be less than\n      // it should be.  In this example, the allowed bytes sent is\n      // 4096 * 0.00388 ~= 15.89, which is rounded to 15. Hence the measured\n      // relative weight is 15/(4096+15) ~= 0.00365\n      EXPECT_GT(summary.expected_weight_, 0.00388);\n      EXPECT_LT(summary.expected_weight_, 0.0039);\n      EXPECT_GT(summary.measured_weight_, 0.00364);\n      EXPECT_LT(summary.measured_weight_, 0.00366);\n    });\n  handler4->expectDetachTransaction([&] {\n      HTTPTransaction::PrioritySampleSummary summary;\n      EXPECT_EQ(handler4->txn_->getPrioritySampleSummary(summary), true);\n      EXPECT_EQ(handler4->txn_->getTransport().getHTTP2PrioritiesEnabled(),\n                true);\n      // This is the priority-based blocking situation. id4 was blocked by\n      // higher priority transactions id1 and id3. Only when id1 and id3\n      // finished, id4 had a chance to transfer its data.\n      // Average contention number weighted by transaction bytes is 1, which\n      // means that when id4 had a chance to transfer bytes it did not contend\n      // with any other transactions.\n      // id4 was waiting for id1 and id3 during transfer of 4256 bytes (encoded)\n      // after which it tranferred 10 bytes (encoded) without contention.\n      // Therefore, the average number contentions weighted by session bytes is\n      // (4111*3 + 1*1)/(4111 + 1) = 12334/4112 ~= 2.999\n      // The difference in average contentions weighted by transaction and\n      // session bytes tells that id4 was mostly blocked by rather than blocking\n      // other transactions.\n      EXPECT_EQ(summary.contentions_.byTransactionBytes_, 1);\n      EXPECT_GT(summary.contentions_.bySessionBytes_, 2.99);\n      EXPECT_LT(summary.contentions_.bySessionBytes_, 3.00);\n      // this is a second level transaction where parent has\n      // no egress, depth == 2\n      EXPECT_EQ(summary.depth_.byTransactionBytes_, 2);\n      EXPECT_EQ(summary.depth_.bySessionBytes_, 2);\n      // the expected relative weight should be\n      // 1/257 * 1/257 ~= 0.000015.\n      // Because no bytes of this transaction were sent during the previous\n      // egress, the expected relative weight was calculated as:\n      // (0*4111 + 1*1)/(4111 + 1) ~= 0.000243\n      EXPECT_GT(summary.expected_weight_, 0.000243);\n      EXPECT_LT(summary.expected_weight_, 0.000244);\n      // The measured weight is (0+1)/(4111+1)  ~= 0.000243\n      // The difference between the theoretical value of 0.000015 and the\n      // measured one is not because of the arithmetical rounding, but because\n      // all other transactions are completed and the relative waight for the\n      // only survived transaction was elevated to 1.0\n      EXPECT_GT(summary.measured_weight_, 0.000243);\n      EXPECT_LT(summary.measured_weight_, 0.000244);\n      handler2->txn_->sendAbort();\n    });\n  handler2->expectDetachTransaction();\n  flushRequestsAndLoop();\n  httpSession_->closeWhenIdle();\n  expectDetachSession();\n  eventBase_.loop();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestPriorityDependentTransactions) {\n  // Create a dependent transaction to test the priority blocked by dependency.\n  // ratio*4096 < 1.\n  //\n  //     root\n  //      \\                                                 level 1\n  //      16\n  //       \\                                                level 2\n  //       16\n  InSequence enforceOrder;\n  auto req1 = getGetRequest();\n  req1.setHTTP2Priority(HTTPMessage::HTTPPriority{0, false, 15});\n  auto id1 = sendRequest(req1);\n\n  auto req2 = getGetRequest();\n  req2.setHTTP2Priority(HTTPMessage::HTTPPriority{id1, false, 15});\n  sendRequest(req2);\n\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&] {\n      handler1->sendReplyWithBody(200, 1024);\n    });\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&] {\n      handler2->sendReplyWithBody(200, 1024);\n    });\n\n  handler1->expectDetachTransaction([&] {\n      HTTPTransaction::PrioritySampleSummary summary;\n      EXPECT_EQ(handler1->txn_->getPrioritySampleSummary(summary), true);\n      EXPECT_EQ(handler1->txn_->getTransport().getHTTP2PrioritiesEnabled(),\n                true);\n      // id1 is contending with id2 during the entire transfer.\n      // Average number of contentions for id1 is 2 in both cases.\n      // The same number of average contentions weighted by both transaction\n      // and session bytes tells that id1 was not blocked by any other\n      // transaction during the entire transfer.\n      EXPECT_EQ(summary.contentions_.byTransactionBytes_, 2);\n      EXPECT_EQ(summary.contentions_.bySessionBytes_, 2);\n      // this is a first level transaction, depth == 1\n      EXPECT_EQ(summary.depth_.byTransactionBytes_, 1);\n      EXPECT_EQ(summary.depth_.bySessionBytes_, 1);\n      // dependent transaction is blocked, the parent is egressing on 100%\n      EXPECT_EQ(summary.expected_weight_, 1);\n      EXPECT_EQ(summary.measured_weight_, 1);\n    });\n  handler2->expectDetachTransaction([&] {\n      HTTPTransaction::PrioritySampleSummary summary;\n      EXPECT_EQ(handler2->txn_->getPrioritySampleSummary(summary), true);\n      EXPECT_EQ(handler2->txn_->getTransport().getHTTP2PrioritiesEnabled(),\n                true);\n      // This is the dependency-based blocking. id2 is blocked by id1.\n      // When id2 had a chance to transfer bytes, it was no longer contended\n      // with any other transaction. Hence the average contention weighted by\n      // transaction bytes is 1.\n      // The average number of contentions weighted by the session bytes is\n      // computed as (1024*2 + 1024*1)/(1024 + 1024) = 3072/2048 = 1.5\n      EXPECT_EQ(summary.contentions_.byTransactionBytes_, 1);\n      EXPECT_EQ(summary.contentions_.bySessionBytes_, 1.5);\n      // The transaction transferred bytes only when its parent transaction\n      // completed. At that time its level decreased to 1. The average depth\n      // weighted by session bytes is (2*1024 + 1*1024)/(2048) = 1.5.\n      EXPECT_EQ(summary.depth_.byTransactionBytes_, 1);\n      EXPECT_EQ(summary.depth_.bySessionBytes_, 1.5);\n      // this dependent transaction was bloted, so it was egressiong only 1/2\n      // of the session bytes.\n      EXPECT_EQ(summary.expected_weight_, 0.5);\n      EXPECT_EQ(summary.measured_weight_, 0.5);\n      handler2->txn_->sendAbort();\n    });\n  flushRequestsAndLoop();\n  httpSession_->closeWhenIdle();\n  expectDetachSession();\n  eventBase_.loop();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestDisablePriorities) {\n  // turn off HTTP2 priorities\n  httpSession_->setHTTP2PrioritiesEnabled(false);\n\n  InSequence enforceOrder;\n  HTTPMessage req1 = getGetRequest();\n  req1.setHTTP2Priority(HTTPMessage::HTTPPriority{0, false, 0});\n  sendRequest(req1);\n\n  HTTPMessage req2 = getGetRequest();\n  req2.setHTTP2Priority(HTTPMessage::HTTPPriority{0, false, 255});\n  sendRequest(req2);\n\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&] {\n      handler1->sendReplyWithBody(200, 4 * 1024);\n    });\n\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&] {\n      handler2->sendReplyWithBody(200, 4 * 1024);\n    });\n\n  // expecting handler 1 to finish first irrespective of\n  // request 2 having higher weight\n  handler1->expectDetachTransaction();\n  handler2->expectDetachTransaction();\n\n  flushRequestsAndLoop();\n  httpSession_->closeWhenIdle();\n  expectDetachSession();\n  eventBase_.loop();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestPriorityWeights) {\n  // virtual priority node with pri=4\n  auto priGroupID = clientCodec_->createStream();\n  clientCodec_->generatePriority(\n    requests_, priGroupID, HTTPMessage::HTTPPriority(0, false, 3));\n  // Both txn's are at equal pri=16\n  auto id1 = sendRequest();\n  auto id2 = sendRequest();\n\n  auto handler1 = addSimpleStrictHandler();\n\n  handler1->expectHeaders();\n  handler1->expectEOM([&] {\n      handler1->sendHeaders(200, 12 * 1024);\n      handler1->txn_->sendBody(makeBuf(4 * 1024));\n    });\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&] {\n      handler2->sendHeaders(200, 12 * 1024);\n      handler2->txn_->sendBody(makeBuf(4 * 1024));\n    });\n\n  // twice- once to send and once to receive\n  flushRequestsAndLoopN(2);\n  EXPECT_CALL(callbacks_, onSettings(_));\n  EXPECT_CALL(callbacks_, onMessageBegin(id1, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(id1, _));\n  EXPECT_CALL(callbacks_, onMessageBegin(id2, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(id2, _));\n  EXPECT_CALL(callbacks_, onBody(id1, _, _))\n    .WillOnce(ExpectBodyLen(4 * 1024));\n  EXPECT_CALL(callbacks_, onBody(id2, _, _))\n    .WillOnce(ExpectBodyLen(4 * 1024));\n  parseOutput(*clientCodec_);\n\n  // update handler2 to be in the pri-group (which has lower weight)\n  clientCodec_->generatePriority(\n    requests_, id2, HTTPMessage::HTTPPriority(priGroupID, false, 15));\n\n  eventBase_.runInLoop([&] {\n      handler1->txn_->sendBody(makeBuf(4 * 1024));\n      handler2->txn_->sendBody(makeBuf(4 * 1024));\n    });\n  flushRequestsAndLoopN(2);\n\n  EXPECT_CALL(callbacks_, onBody(id1, _, _))\n    .WillOnce(ExpectBodyLen(4 * 1024));\n  EXPECT_CALL(callbacks_, onBody(id2, _, _))\n    .WillOnce(ExpectBodyLen(1 * 1024))\n    .WillOnce(ExpectBodyLen(3 * 1024));\n  parseOutput(*clientCodec_);\n\n  // update vnode weight to match txn1 weight\n  clientCodec_->generatePriority(requests_, priGroupID,\n                                 HTTPMessage::HTTPPriority(0, false, 15));\n  eventBase_.runInLoop([&] {\n      handler1->txn_->sendBody(makeBuf(4 * 1024));\n      handler1->txn_->sendEOM();\n      handler2->txn_->sendBody(makeBuf(4 * 1024));\n      handler2->txn_->sendEOM();\n    });\n  handler1->expectDetachTransaction();\n  handler2->expectDetachTransaction();\n  flushRequestsAndLoopN(2);\n\n  // expect 32/32\n  EXPECT_CALL(callbacks_, onBody(id1, _, _))\n    .WillOnce(ExpectBodyLen(4 * 1024));\n  EXPECT_CALL(callbacks_, onMessageComplete(id1, _));\n  EXPECT_CALL(callbacks_, onBody(id2, _, _))\n    .WillOnce(ExpectBodyLen(4 * 1024));\n  EXPECT_CALL(callbacks_, onMessageComplete(id2, _));\n  parseOutput(*clientCodec_);\n\n  httpSession_->closeWhenIdle();\n  expectDetachSession();\n  this->eventBase_.loop();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestPriorityWeightsTinyWindow) {\n  httpSession_->setWriteBufferLimit(2 * 65536);\n  InSequence enforceOrder;\n  auto id1 = sendRequest();\n  auto id2 = sendRequest();\n\n  auto handler1 = addSimpleStrictHandler();\n\n  handler1->expectHeaders();\n  handler1->expectEOM([&] {\n      handler1->sendReplyWithBody(200, 32 * 1024);\n    });\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&] {\n      handler2->sendReplyWithBody(200, 32 * 1024);\n    });\n\n  handler1->expectDetachTransaction();\n\n  // twice- once to send and once to receive\n  flushRequestsAndLoopN(2);\n  EXPECT_CALL(callbacks_, onSettings(_));\n  EXPECT_CALL(callbacks_, onMessageBegin(id1, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(id1, _));\n  EXPECT_CALL(callbacks_, onMessageBegin(id2, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(id2, _));\n  for (auto i = 0; i < 7; i++) {\n    EXPECT_CALL(callbacks_, onBody(id1, _, _))\n      .WillOnce(ExpectBodyLen(4 * 1024));\n    EXPECT_CALL(callbacks_, onBody(id2, _, _))\n      .WillOnce(ExpectBodyLen(4 * 1024));\n  }\n  EXPECT_CALL(callbacks_, onBody(id1, _, _))\n    .WillOnce(ExpectBodyLen(4 * 1024 - 1));\n  EXPECT_CALL(callbacks_, onBody(id2, _, _))\n    .WillOnce(ExpectBodyLen(4 * 1024 - 1));\n  EXPECT_CALL(callbacks_, onBody(id1, _, _))\n    .WillOnce(ExpectBodyLen(1));\n  EXPECT_CALL(callbacks_, onMessageComplete(id1, _));\n  parseOutput(*clientCodec_);\n\n  // open the window\n  clientCodec_->generateWindowUpdate(requests_, 0, 100);\n  handler2->expectDetachTransaction();\n  flushRequestsAndLoopN(2);\n\n  EXPECT_CALL(callbacks_, onBody(id2, _, _))\n    .WillOnce(ExpectBodyLen(1));\n  EXPECT_CALL(callbacks_, onMessageComplete(id2, _));\n  parseOutput(*clientCodec_);\n\n  httpSession_->closeWhenIdle();\n  expectDetachSession();\n  this->eventBase_.loop();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestShortContentLength) {\n  auto req = getPostRequest(10);\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateBody(requests_, streamID, makeBuf(20),\n                             HTTPCodec::NoPadding, true);\n  auto handler1 = addSimpleStrictHandler();\n\n  InSequence enforceOrder;\n  handler1->expectHeaders();\n  handler1->expectError([&handler1] (const HTTPException& ex) {\n      EXPECT_EQ(ex.getProxygenError(), kErrorParseBody);\n      handler1->txn_->sendAbort();\n    });\n  handler1->expectDetachTransaction();\n  flushRequestsAndLoop();\n\n  gracefulShutdown();\n}\n\n/**\n * If handler chooses to untie itself with transaction during onError,\n * detachTransaction shouldn't be expected\n */\nTEST_F(HTTP2DownstreamSessionTest, TestBadContentLengthUntieHandler) {\n  auto req = getPostRequest(10);\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateBody(\n      requests_,\n      streamID,\n      makeBuf(20),\n      HTTPCodec::NoPadding,\n      true);\n  auto handler1 = addSimpleStrictHandler();\n\n  InSequence enforceOrder;\n  handler1->expectHeaders();\n  handler1->expectError([&] (const HTTPException&) {\n      if (handler1->txn_) {\n        handler1->txn_->setHandler(nullptr);\n      }\n      handler1->txn_ = nullptr;\n    });\n  flushRequestsAndLoop();\n\n  gracefulShutdown();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestLongContentLength) {\n  auto req = getPostRequest(30);\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateBody(requests_, streamID, makeBuf(20),\n                             HTTPCodec::NoPadding, true);\n  auto handler1 = addSimpleStrictHandler();\n\n  InSequence enforceOrder;\n  handler1->expectHeaders();\n  handler1->expectBody();\n  handler1->expectError([&handler1] (const HTTPException& ex) {\n      EXPECT_EQ(ex.getProxygenError(), kErrorParseBody);\n      handler1->txn_->sendAbort();\n    });\n  handler1->expectDetachTransaction();\n  flushRequestsAndLoop();\n\n  gracefulShutdown();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestMalformedContentLength) {\n  auto req = getPostRequest();\n  req.getHeaders().set(HTTP_HEADER_CONTENT_LENGTH, \"malformed\");\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateBody(requests_, streamID, makeBuf(20),\n                             HTTPCodec::NoPadding, true);\n  auto handler1 = addSimpleStrictHandler();\n\n  InSequence enforceOrder;\n  handler1->expectHeaders();\n  handler1->expectBody();\n  handler1->expectEOM([&handler1] {\n      handler1->sendReplyWithBody(200, 100);\n    });\n  handler1->expectDetachTransaction();\n  flushRequestsAndLoop();\n\n  gracefulShutdown();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestHeadContentLength) {\n  InSequence enforceOrder;\n  auto req = getGetRequest();\n  req.setMethod(HTTPMethod::HEAD);\n  sendRequest(req);\n  auto handler1 = addSimpleStrictHandler();\n\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1] {\n      handler1->sendHeaders(200, 100);\n      // no body for head\n      handler1->txn_->sendEOM();\n    });\n  handler1->expectDetachTransaction();\n  flushRequestsAndLoop();\n\n  gracefulShutdown();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, Test304ContentLength) {\n  InSequence enforceOrder;\n  auto req = getGetRequest();\n  req.setMethod(HTTPMethod::HEAD);\n  sendRequest(req);\n  auto handler1 = addSimpleStrictHandler();\n\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1] {\n      handler1->sendHeaders(304, 100);\n      handler1->txn_->sendEOM();\n    });\n  handler1->expectDetachTransaction();\n  flushRequestsAndLoop();\n\n  gracefulShutdown();\n}\n\n// chunked with wrong content-length\nTEST_F(HTTPDownstreamSessionTest, HttpShortContentLength) {\n  InSequence enforceOrder;\n  auto req = getPostRequest(10);\n  req.setIsChunked(true);\n  req.getHeaders().add(HTTP_HEADER_TRANSFER_ENCODING, \"chunked\");\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateChunkHeader(requests_, streamID, 20);\n  clientCodec_->generateBody(requests_, streamID, makeBuf(20),\n                             HTTPCodec::NoPadding, false);\n  clientCodec_->generateChunkTerminator(requests_, streamID);\n  clientCodec_->generateEOM(requests_, streamID);\n  auto handler1 = addSimpleStrictHandler();\n\n  handler1->expectHeaders();\n  EXPECT_CALL(*handler1, onChunkHeader(20));\n\n  handler1->expectError([&handler1] (const HTTPException& ex) {\n      EXPECT_EQ(ex.getProxygenError(), kErrorParseBody);\n      handler1->txn_->sendAbort();\n    });\n  handler1->expectDetachTransaction();\n  expectDetachSession();\n  flushRequestsAndLoop();\n\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestSessionStallByFlowControl) {\n  NiceMock<MockHTTPSessionStats> stats;\n  // By default the send and receive windows are 64K each.\n  // If we use only a single transaction, that transaction\n  // will be paused on reaching 64K. Therefore, to pause the session,\n  // it is used 2 transactions each sending 32K.\n\n  // Make write buffer limit exceding 64K, for example 128K\n  httpSession_->setWriteBufferLimit(128 * 1024);\n  httpSession_->setSessionStats(&stats);\n\n  InSequence enforceOrder;\n  sendRequest();\n  sendRequest();\n\n  auto handler1 = addSimpleStrictHandler();\n\n  handler1->expectHeaders();\n  handler1->expectEOM([&] {\n      handler1->sendReplyWithBody(200, 32 * 1024);\n    });\n\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&] {\n      handler2->sendReplyWithBody(200, 32 * 1024);\n    });\n\n  EXPECT_CALL(stats, recordSessionStalled()).Times(1);\n\n  handler1->expectDetachTransaction();\n\n  // twice- once to send and once to receive\n  flushRequestsAndLoopN(2);\n\n  // open the window\n  clientCodec_->generateWindowUpdate(requests_, 0, 100);\n  handler2->expectDetachTransaction();\n  flushRequestsAndLoopN(2);\n\n  httpSession_->closeWhenIdle();\n  expectDetachSession();\n  flushRequestsAndLoop();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestTransactionStallByFlowControl) {\n  StrictMock<MockHTTPSessionStats> stats;\n\n  httpSession_->setSessionStats(&stats);\n\n  // Set the client side stream level flow control wind to 500 bytes,\n  // and try to send 1000 bytes through it.\n  // Then the flow control kicks in and stalls the transaction.\n  clientCodec_->getEgressSettings()->setSetting(SettingsId::INITIAL_WINDOW_SIZE,\n                                                500);\n  clientCodec_->generateSettings(requests_);\n\n  auto streamID = sendRequest();\n\n  EXPECT_CALL(stats, recordTransactionOpened());\n\n  InSequence handlerSequence;\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders();\n  handler->expectEOM([&] {\n      handler->sendReplyWithBody(200, 1000);\n    });\n\n  EXPECT_CALL(stats, recordTransactionStalled());\n  handler->expectEgressPaused();\n\n  handler->expectError([&] (const HTTPException& ex) {\n      ASSERT_EQ(ex.getProxygenError(), kErrorWriteTimeout);\n      ASSERT_EQ(\n        folly::to<std::string>(\"ingress timeout, streamID=\", streamID),\n        std::string(ex.what()));\n      handler->terminate();\n    });\n\n  handler->expectDetachTransaction();\n\n  EXPECT_CALL(stats, recordTransactionClosed());\n\n  flushRequestsAndLoop();\n  gracefulShutdown();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestTransactionNotStallByFlowControl) {\n  StrictMock<MockHTTPSessionStats> stats;\n\n  httpSession_->setSessionStats(&stats);\n\n  clientCodec_->getEgressSettings()->setSetting(SettingsId::INITIAL_WINDOW_SIZE,\n                                                500);\n  clientCodec_->generateSettings(requests_);\n\n  sendRequest();\n\n  EXPECT_CALL(stats, recordTransactionOpened());\n\n  InSequence handlerSequence;\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders();\n  handler->expectEOM([&] {\n      handler->sendReplyWithBody(200, 500);\n    });\n\n  // The egtress paused is notified due to existing logics,\n  // but egress transaction should not be counted as stalled by flow control,\n  // because there is nore more bytes to send\n  handler->expectEgressPaused();\n\n  handler->expectDetachTransaction();\n\n  EXPECT_CALL(stats, recordTransactionClosed());\n\n  flushRequestsAndLoop();\n  gracefulShutdown();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestSetEgressSettings) {\n  SettingsList settings = {{ SettingsId::HEADER_TABLE_SIZE, 5555 },\n                           { SettingsId::MAX_FRAME_SIZE, 16384 },\n                           { SettingsId::ENABLE_PUSH, 1 }};\n\n  const HTTPSettings* codecSettings = rawCodec_->getEgressSettings();\n  for (const auto& setting: settings) {\n    const HTTPSetting* currSetting = codecSettings->getSetting(setting.id);\n    if (currSetting) {\n      EXPECT_EQ(setting.value, currSetting->value);\n    }\n  }\n\n  flushRequestsAndLoop();\n  gracefulShutdown();\n}\n", "/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n#pragma once\n\n#include <folly/portability/GMock.h>\n#include <proxygen/lib/http/HTTPMessage.h>\n#include <proxygen/lib/http/codec/test/TestUtils.h>\n#include <proxygen/lib/http/session/HTTPDownstreamSession.h>\n#include <proxygen/lib/http/session/HTTPSessionController.h>\n#include <proxygen/lib/http/session/HTTPSessionStats.h>\n#include <proxygen/lib/http/session/HTTPTransaction.h>\n\n#define GMOCK_NOEXCEPT_METHOD0(m, F) GMOCK_METHOD0_(, noexcept, , m, F)\n#define GMOCK_NOEXCEPT_METHOD1(m, F) GMOCK_METHOD1_(, noexcept, , m, F)\n\nnamespace proxygen {\n\nclass HTTPHandlerBase {\n public:\n  HTTPHandlerBase() {\n  }\n  HTTPHandlerBase(HTTPTransaction* txn, HTTPMessage* msg)\n      : txn_(txn), msg_(msg) {\n  }\n\n  void terminate() {\n    txn_->sendAbort();\n  }\n\n  void sendRequest() {\n    sendRequest(getGetRequest());\n  }\n\n  void sendRequest(HTTPMessage req) {\n    // this copies but it's test code meh\n    txn_->sendHeaders(req);\n    txn_->sendEOM();\n  }\n\n  using HeaderMap = std::map<std::string, std::string>;\n  void sendHeaders(uint32_t code,\n                   uint32_t content_length,\n                   bool keepalive = true,\n                   HeaderMap headers = HeaderMap()) {\n    HTTPMessage reply;\n    reply.setStatusCode(code);\n    reply.setHTTPVersion(1, 1);\n    reply.setWantsKeepalive(keepalive);\n    reply.getHeaders().add(HTTP_HEADER_CONTENT_LENGTH,\n                           folly::to<std::string>(content_length));\n    for (auto& nv : headers) {\n      reply.getHeaders().add(nv.first, nv.second);\n    }\n    txn_->sendHeaders(reply);\n  }\n\n  void sendReply() {\n    sendReplyCode(200);\n  }\n\n  void sendReplyCode(uint32_t code) {\n    sendHeaders(code, 0, true);\n    txn_->sendEOM();\n  }\n\n  void sendBody(uint32_t content_length) {\n    while (content_length > 0) {\n      uint32_t toSend = std::min(content_length, uint32_t(4096));\n      char buf[toSend];\n      memset(buf, 'a', toSend);\n      txn_->sendBody(folly::IOBuf::copyBuffer(buf, toSend));\n      content_length -= toSend;\n    }\n  }\n\n  void sendBodyWithLastByteTracking(uint32_t content_length) {\n    txn_->setLastByteFlushedTrackingEnabled(true);\n    sendBody(content_length);\n  }\n\n  void sendReplyWithBody(uint32_t code,\n                         uint32_t content_length,\n                         bool keepalive = true,\n                         bool sendEOM = true,\n                         bool hasTrailers = false) {\n    sendHeaders(code, content_length, keepalive);\n    sendBody(content_length);\n    if (hasTrailers) {\n      HTTPHeaders trailers;\n      trailers.add(\"X-Trailer1\", \"Foo\");\n      txn_->sendTrailers(trailers);\n    }\n    if (sendEOM) {\n      txn_->sendEOM();\n    }\n  }\n\n  void sendEOM() {\n    txn_->sendEOM();\n  }\n\n  void sendChunkedReplyWithBody(uint32_t code,\n                                uint32_t content_length,\n                                uint32_t chunkSize,\n                                bool hasTrailers,\n                                bool sendEOM = true) {\n    HTTPMessage reply;\n    reply.setStatusCode(code);\n    reply.setHTTPVersion(1, 1);\n    reply.setIsChunked(true);\n    txn_->sendHeaders(reply);\n    while (content_length > 0) {\n      uint32_t toSend = std::min(content_length, chunkSize);\n      char buf[toSend];\n      memset(buf, 'a', toSend);\n      txn_->sendChunkHeader(toSend);\n      txn_->sendBody(folly::IOBuf::copyBuffer(buf, toSend));\n      txn_->sendChunkTerminator();\n      content_length -= toSend;\n    }\n    if (hasTrailers) {\n      HTTPHeaders trailers;\n      trailers.add(\"X-Trailer1\", \"Foo\");\n      txn_->sendTrailers(trailers);\n    }\n    if (sendEOM) {\n      txn_->sendEOM();\n    }\n  }\n\n  HTTPTransaction* txn_{nullptr};\n  std::shared_ptr<HTTPMessage> msg_;\n};\n\nclass MockHTTPHandler\n    : public HTTPHandlerBase\n    , public HTTPTransaction::Handler {\n public:\n  MockHTTPHandler() {\n  }\n  MockHTTPHandler(HTTPTransaction& txn,\n                  HTTPMessage* msg,\n                  const folly::SocketAddress&)\n      : HTTPHandlerBase(&txn, msg) {\n  }\n\n  GMOCK_NOEXCEPT_METHOD1(setTransaction, void(HTTPTransaction* txn));\n\n  GMOCK_NOEXCEPT_METHOD0(detachTransaction, void());\n\n  void onHeadersComplete(std::unique_ptr<HTTPMessage> msg) noexcept override {\n    onHeadersComplete(std::shared_ptr<HTTPMessage>(msg.release()));\n  }\n\n  GMOCK_NOEXCEPT_METHOD1(onHeadersComplete,\n                         void(std::shared_ptr<HTTPMessage> msg));\n\n  void onBody(std::unique_ptr<folly::IOBuf> chain) noexcept override {\n    onBody(std::shared_ptr<folly::IOBuf>(chain.release()));\n  }\n  GMOCK_NOEXCEPT_METHOD1(onBody, void(std::shared_ptr<folly::IOBuf> chain));\n\n  GMOCK_NOEXCEPT_METHOD1(onChunkHeader, void(size_t length));\n\n  GMOCK_NOEXCEPT_METHOD0(onChunkComplete, void());\n\n  void onTrailers(std::unique_ptr<HTTPHeaders> trailers) noexcept override {\n    onTrailers(std::shared_ptr<HTTPHeaders>(trailers.release()));\n  }\n\n  GMOCK_NOEXCEPT_METHOD1(onTrailers,\n                         void(std::shared_ptr<HTTPHeaders> trailers));\n\n  GMOCK_NOEXCEPT_METHOD0(onEOM, void());\n\n  GMOCK_NOEXCEPT_METHOD1(onUpgrade, void(UpgradeProtocol protocol));\n\n  GMOCK_NOEXCEPT_METHOD1(onError, void(const HTTPException& error));\n\n  GMOCK_NOEXCEPT_METHOD1(onGoaway, void(ErrorCode));\n\n  GMOCK_NOEXCEPT_METHOD0(onEgressPaused, void());\n\n  GMOCK_NOEXCEPT_METHOD0(onEgressResumed, void());\n\n  GMOCK_NOEXCEPT_METHOD1(onPushedTransaction, void(HTTPTransaction*));\n\n  GMOCK_NOEXCEPT_METHOD1(onExTransaction, void(HTTPTransaction*));\n\n  void expectTransaction(std::function<void(HTTPTransaction* txn)> callback) {\n    EXPECT_CALL(*this, setTransaction(testing::_))\n        .WillOnce(testing::Invoke(callback))\n        .RetiresOnSaturation();\n  }\n\n  void expectTransaction(HTTPTransaction** pTxn = nullptr) {\n    EXPECT_CALL(*this, setTransaction(testing::_))\n        .WillOnce(testing::SaveArg<0>(pTxn ? pTxn : &txn_));\n  }\n\n  void expectHeaders(std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onHeadersComplete(testing::_))\n          .WillOnce(testing::InvokeWithoutArgs(callback))\n          .RetiresOnSaturation();\n    } else {\n      EXPECT_CALL(*this, onHeadersComplete(testing::_));\n    }\n  }\n\n  void expectHeaders(std::function<void(std::shared_ptr<HTTPMessage>)> cb) {\n    EXPECT_CALL(*this, onHeadersComplete(testing::_))\n        .WillOnce(testing::Invoke(cb))\n        .RetiresOnSaturation();\n  }\n\n  void expectTrailers(\n      std::function<void(std::shared_ptr<HTTPHeaders> trailers)> cb) {\n    EXPECT_CALL(*this, onTrailers(testing::_))\n        .WillOnce(testing::Invoke(cb))\n        .RetiresOnSaturation();\n  }\n\n  void expectChunkHeader(\n      std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onChunkHeader(testing::_))\n          .WillOnce(testing::InvokeWithoutArgs(callback));\n    } else {\n      EXPECT_CALL(*this, onChunkHeader(testing::_));\n    }\n  }\n\n  void expectBody(std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onBody(testing::_))\n          .WillOnce(testing::InvokeWithoutArgs(callback));\n    } else {\n      EXPECT_CALL(*this, onBody(testing::_));\n    }\n  }\n\n  void expectBody(std::function<void(std::shared_ptr<folly::IOBuf>)> callback) {\n    EXPECT_CALL(*this, onBody(testing::_)).WillOnce(testing::Invoke(callback));\n  }\n\n  void expectChunkComplete(\n      std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onChunkComplete())\n          .WillOnce(testing::InvokeWithoutArgs(callback));\n    } else {\n      EXPECT_CALL(*this, onChunkComplete());\n    }\n  }\n\n  void expectEOM(std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onEOM()).WillOnce(testing::Invoke(callback));\n    } else {\n      EXPECT_CALL(*this, onEOM());\n    }\n  }\n\n  void expectEgressPaused(\n      std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onEgressPaused()).WillOnce(testing::Invoke(callback));\n    } else {\n      EXPECT_CALL(*this, onEgressPaused());\n    }\n  }\n\n  void expectEgressResumed(\n      std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onEgressResumed()).WillOnce(testing::Invoke(callback));\n    } else {\n      EXPECT_CALL(*this, onEgressResumed());\n    }\n  }\n\n  void expectError(std::function<void(const HTTPException& ex)> callback =\n                       std::function<void(const HTTPException& ex)>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onError(testing::_))\n          .WillOnce(testing::Invoke(callback));\n    } else {\n      EXPECT_CALL(*this, onError(testing::_));\n    }\n  }\n\n  void expectGoaway(std::function<void(ErrorCode)> callback =\n                        std::function<void(ErrorCode)>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onGoaway(testing::_))\n          .WillOnce(testing::Invoke(callback));\n    } else {\n      EXPECT_CALL(*this, onGoaway(testing::_));\n    }\n  }\n\n  void expectDetachTransaction(\n      std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, detachTransaction())\n          .WillOnce(testing::Invoke(callback));\n    } else {\n      EXPECT_CALL(*this, detachTransaction());\n    }\n  }\n};\n\nclass MockHTTPPushHandler\n    : public HTTPHandlerBase\n    , public HTTPTransaction::PushHandler {\n public:\n  MockHTTPPushHandler() {\n  }\n  MockHTTPPushHandler(HTTPTransaction& txn,\n                      HTTPMessage* msg,\n                      const folly::SocketAddress&)\n      : HTTPHandlerBase(&txn, msg) {\n  }\n\n  GMOCK_NOEXCEPT_METHOD1(setTransaction, void(HTTPTransaction* txn));\n\n  GMOCK_NOEXCEPT_METHOD0(detachTransaction, void());\n\n  GMOCK_NOEXCEPT_METHOD1(onError, void(const HTTPException& error));\n\n  GMOCK_NOEXCEPT_METHOD1(onGoaway, void(ErrorCode));\n\n  GMOCK_NOEXCEPT_METHOD0(onEgressPaused, void());\n\n  GMOCK_NOEXCEPT_METHOD0(onEgressResumed, void());\n\n  void sendPushHeaders(const std::string& path,\n                       const std::string& host,\n                       uint32_t content_length,\n                       http2::PriorityUpdate pri) {\n    HTTPMessage push;\n    push.setURL(path);\n    push.getHeaders().set(HTTP_HEADER_HOST, host);\n    push.getHeaders().add(HTTP_HEADER_CONTENT_LENGTH,\n                          folly::to<std::string>(content_length));\n    push.setHTTP2Priority(\n        std::make_tuple(pri.streamDependency, pri.exclusive, pri.weight));\n    txn_->sendHeaders(push);\n  }\n};\n\nclass MockController : public HTTPSessionController {\n public:\n  MOCK_METHOD2(getRequestHandler,\n               HTTPTransactionHandler*(HTTPTransaction&, HTTPMessage* msg));\n\n  MOCK_METHOD3(getParseErrorHandler,\n               HTTPTransactionHandler*(HTTPTransaction*,\n                                       const HTTPException&,\n                                       const folly::SocketAddress&));\n\n  MOCK_METHOD2(getTransactionTimeoutHandler,\n               HTTPTransactionHandler*(HTTPTransaction* txn,\n                                       const folly::SocketAddress&));\n\n  MOCK_METHOD1(attachSession, void(HTTPSessionBase*));\n  MOCK_METHOD1(detachSession, void(const HTTPSessionBase*));\n  MOCK_METHOD1(onSessionCodecChange, void(HTTPSessionBase*));\n  MOCK_CONST_METHOD0(getGracefulShutdownTimeout, std::chrono::milliseconds());\n\n  MOCK_CONST_METHOD0(getHeaderIndexingStrategy,\n                     const HeaderIndexingStrategy*());\n};\n\nclass MockUpstreamController : public HTTPUpstreamSessionController {\n public:\n  MOCK_METHOD1(attachSession, void(HTTPSessionBase*));\n  MOCK_METHOD1(detachSession, void(const HTTPSessionBase*));\n  MOCK_METHOD1(onSessionCodecChange, void(HTTPSessionBase*));\n\n  MOCK_CONST_METHOD0(getHeaderIndexingStrategy,\n                     const HeaderIndexingStrategy*());\n};\n\nACTION_P(ExpectString, expected) {\n  std::string bodystr((const char*)arg0->data(), arg0->length());\n  EXPECT_EQ(bodystr, expected);\n}\n\nACTION_P(ExpectBodyLen, expectedLen) {\n  EXPECT_EQ(arg1->computeChainDataLength(), expectedLen);\n}\n\nclass MockHTTPSessionInfoCallback : public HTTPSession::InfoCallback {\n public:\n  MOCK_METHOD1(onCreate, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onTransportReady, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onConnectionError, void(const HTTPSessionBase&));\n  MOCK_METHOD2(onIngressError, void(const HTTPSessionBase&, ProxygenError));\n  MOCK_METHOD0(onIngressEOF, void());\n  MOCK_METHOD2(onRead, void(const HTTPSessionBase&, size_t));\n  MOCK_METHOD2(onWrite, void(const HTTPSessionBase&, size_t));\n  MOCK_METHOD1(onRequestBegin, void(const HTTPSessionBase&));\n  MOCK_METHOD2(onRequestEnd, void(const HTTPSessionBase&, uint32_t));\n  MOCK_METHOD1(onActivateConnection, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onDeactivateConnection, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onDestroy, void(const HTTPSessionBase&));\n  MOCK_METHOD2(onIngressMessage,\n               void(const HTTPSessionBase&, const HTTPMessage&));\n  MOCK_METHOD1(onIngressLimitExceeded, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onIngressPaused, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onTransactionDetached, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onPingReplySent, void(int64_t));\n  MOCK_METHOD0(onPingReplyReceived, void());\n  MOCK_METHOD1(onSettingsOutgoingStreamsFull, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onSettingsOutgoingStreamsNotFull, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onFlowControlWindowClosed, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onEgressBuffered, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onEgressBufferCleared, void(const HTTPSessionBase&));\n  MOCK_METHOD2(onSettings, void(const HTTPSessionBase&, const SettingsList&));\n  MOCK_METHOD1(onSettingsAck, void(const HTTPSessionBase&));\n};\n\nclass DummyHTTPSessionStats : public HTTPSessionStats {\n public:\n  void recordTransactionOpened() noexcept override{};\n  void recordTransactionClosed() noexcept override{};\n  void recordTransactionsServed(uint64_t) noexcept override{};\n  void recordSessionReused() noexcept override{};\n  // virtual void recordSessionIdleTime(std::chrono::seconds) noexcept {};\n  void recordTransactionStalled() noexcept override{};\n  void recordSessionStalled() noexcept override{};\n\n  void recordTTLBAExceedLimit() noexcept override{};\n  void recordTTLBAIOBSplitByEom() noexcept override{};\n  void recordTTLBANotFound() noexcept override{};\n  void recordTTLBAReceived() noexcept override{};\n  void recordTTLBATimeout() noexcept override{};\n  void recordTTLBAEomPassed() noexcept override{};\n  void recordTTLBATracked() noexcept override{};\n};\n\nclass MockHTTPSessionStats : public DummyHTTPSessionStats {\n public:\n  MockHTTPSessionStats() {\n  }\n  GMOCK_NOEXCEPT_METHOD0(recordTransactionOpened, void());\n  GMOCK_NOEXCEPT_METHOD0(recordTransactionClosed, void());\n  GMOCK_NOEXCEPT_METHOD1(recordTransactionsServed, void(uint64_t));\n  GMOCK_NOEXCEPT_METHOD0(recordSessionReused, void());\n  GMOCK_NOEXCEPT_METHOD1(recordSessionIdleTime, void(std::chrono::seconds));\n  GMOCK_NOEXCEPT_METHOD0(recordTransactionStalled, void());\n  GMOCK_NOEXCEPT_METHOD0(recordSessionStalled, void());\n};\n\n} // namespace proxygen\n"], "fixing_code": ["/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n#include <proxygen/lib/http/codec/HTTP2Codec.h>\n#include <proxygen/lib/http/codec/HTTP2Constants.h>\n#include <proxygen/lib/http/codec/CodecUtil.h>\n#include <proxygen/lib/utils/Logging.h>\n#include <proxygen/lib/utils/Base64.h>\n\n#include <folly/Conv.h>\n#include <folly/Random.h>\n#include <folly/ThreadLocal.h>\n#include <folly/io/Cursor.h>\n#include <folly/tracing/ScopedTraceSection.h>\n#include <type_traits>\n\nusing namespace proxygen::compress;\nusing namespace folly::io;\nusing namespace folly;\n\nusing std::string;\n\nnamespace {\nstd::string base64url_encode(ByteRange range) {\n  return proxygen::Base64::urlEncode(range);\n}\n\nstd::string base64url_decode(const std::string& str) {\n  return proxygen::Base64::urlDecode(str);\n}\n\n}\n\nnamespace proxygen {\n\n\nHTTP2Codec::HTTP2Codec(TransportDirection direction)\n    : HTTPParallelCodec(direction),\n      headerCodec_(direction),\n      frameState_(direction == TransportDirection::DOWNSTREAM\n                  ? FrameState::UPSTREAM_CONNECTION_PREFACE\n                  : FrameState::DOWNSTREAM_CONNECTION_PREFACE) {\n\n  const auto maxHeaderListSize = egressSettings_.getSetting(\n    SettingsId::MAX_HEADER_LIST_SIZE);\n  if (maxHeaderListSize) {\n    headerCodec_.setMaxUncompressed(maxHeaderListSize->value);\n  }\n\n  VLOG(4) << \"creating \" << getTransportDirectionString(direction)\n          << \" HTTP/2 codec\";\n}\n\nHTTP2Codec::~HTTP2Codec() {}\n\n// HTTPCodec API\n\nsize_t HTTP2Codec::onIngress(const folly::IOBuf& buf) {\n  // TODO: ensure only 1 parse at a time on stack.\n  FOLLY_SCOPED_TRACE_SECTION(\"HTTP2Codec - onIngress\");\n\n  Cursor cursor(&buf);\n  size_t parsed = 0;\n  ErrorCode connError = ErrorCode::NO_ERROR;\n  for (auto bufLen = cursor.totalLength();\n       connError == ErrorCode::NO_ERROR;\n       bufLen = cursor.totalLength()) {\n    if (frameState_ == FrameState::UPSTREAM_CONNECTION_PREFACE) {\n      if (bufLen >= http2::kConnectionPreface.length()) {\n        auto test = cursor.readFixedString(http2::kConnectionPreface.length());\n        parsed += http2::kConnectionPreface.length();\n        if (test != http2::kConnectionPreface) {\n          goawayErrorMessage_ = \"missing connection preface\";\n          VLOG(4) << goawayErrorMessage_;\n          connError = ErrorCode::PROTOCOL_ERROR;\n        }\n        frameState_ = FrameState::FRAME_HEADER;\n      } else {\n        break;\n      }\n    } else if (frameState_ == FrameState::FRAME_HEADER ||\n               frameState_ == FrameState::DOWNSTREAM_CONNECTION_PREFACE) {\n      // Waiting to parse the common frame header\n      if (bufLen >= http2::kFrameHeaderSize) {\n        connError = parseFrameHeader(cursor, curHeader_);\n        parsed += http2::kFrameHeaderSize;\n        if (frameState_ == FrameState::DOWNSTREAM_CONNECTION_PREFACE &&\n            curHeader_.type != http2::FrameType::SETTINGS) {\n          goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: got invalid connection preface frame type=\",\n              getFrameTypeString(curHeader_.type), \"(\", curHeader_.type, \")\",\n              \" for streamID=\", curHeader_.stream);\n          VLOG(4) << goawayErrorMessage_;\n          connError = ErrorCode::PROTOCOL_ERROR;\n        }\n        if (curHeader_.length > maxRecvFrameSize()) {\n          VLOG(4) << \"Excessively large frame len=\" << curHeader_.length;\n          connError = ErrorCode::FRAME_SIZE_ERROR;\n        }\n\n        if (callback_) {\n          callback_->onFrameHeader(\n            curHeader_.stream,\n            curHeader_.flags,\n            curHeader_.length,\n            static_cast<uint8_t>(curHeader_.type));\n        }\n\n        frameState_ = (curHeader_.type == http2::FrameType::DATA) ?\n          FrameState::DATA_FRAME_DATA : FrameState::FRAME_DATA;\n        pendingDataFrameBytes_ = curHeader_.length;\n        pendingDataFramePaddingBytes_ = 0;\n#ifndef NDEBUG\n        receivedFrameCount_++;\n#endif\n      } else {\n        break;\n      }\n    } else if (frameState_ == FrameState::DATA_FRAME_DATA && bufLen > 0 &&\n               (bufLen < curHeader_.length ||\n                pendingDataFrameBytes_ < curHeader_.length)) {\n      // FrameState::DATA_FRAME_DATA with partial data only\n      size_t dataParsed = 0;\n      connError = parseDataFrameData(cursor, bufLen, dataParsed);\n      if (dataParsed == 0 && pendingDataFrameBytes_ > 0) {\n        // We received only the padding byte, we will wait for more\n        break;\n      } else {\n        parsed += dataParsed;\n        if (pendingDataFrameBytes_ == 0) {\n          frameState_ = FrameState::FRAME_HEADER;\n        }\n      }\n    } else { // FrameState::FRAME_DATA\n             // or FrameState::DATA_FRAME_DATA with all data available\n      // Already parsed the common frame header\n      const auto frameLen = curHeader_.length;\n      if (bufLen >= frameLen) {\n        connError = parseFrame(cursor);\n        parsed += curHeader_.length;\n        frameState_ = FrameState::FRAME_HEADER;\n      } else {\n        break;\n      }\n    }\n  }\n  checkConnectionError(connError, &buf);\n  return parsed;\n}\n\nErrorCode HTTP2Codec::parseFrame(folly::io::Cursor& cursor) {\n  FOLLY_SCOPED_TRACE_SECTION(\"HTTP2Codec - parseFrame\");\n  if (expectedContinuationStream_ != 0 &&\n       (curHeader_.type != http2::FrameType::CONTINUATION ||\n        expectedContinuationStream_ != curHeader_.stream)) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: while expected CONTINUATION with stream=\",\n        expectedContinuationStream_, \", received streamID=\", curHeader_.stream,\n        \" of type=\", getFrameTypeString(curHeader_.type));\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  if (expectedContinuationStream_ == 0 &&\n      curHeader_.type == http2::FrameType::CONTINUATION) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: unexpected CONTINUATION received with streamID=\",\n        curHeader_.stream);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  if (frameAffectsCompression(curHeader_.type) &&\n      curHeaderBlock_.chainLength() + curHeader_.length >\n      egressSettings_.getSetting(SettingsId::MAX_HEADER_LIST_SIZE, 0)) {\n    // this may be off by up to the padding length (max 255), but\n    // these numbers are already so generous, and we're comparing the\n    // max-uncompressed to the actual compressed size.  Let's fail\n    // before buffering.\n\n    // TODO(t6513634): it would be nicer to stream-process this header\n    // block to keep the connection state consistent without consuming\n    // memory, and fail just the request per the HTTP/2 spec (section\n    // 10.3)\n    goawayErrorMessage_ = folly::to<string>(\n      \"Failing connection due to excessively large headers\");\n    LOG(ERROR) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n\n  expectedContinuationStream_ =\n    (frameAffectsCompression(curHeader_.type) &&\n     !(curHeader_.flags & http2::END_HEADERS)) ? curHeader_.stream : 0;\n\n  switch (curHeader_.type) {\n    case http2::FrameType::DATA:\n      return parseAllData(cursor);\n    case http2::FrameType::HEADERS:\n      return parseHeaders(cursor);\n    case http2::FrameType::PRIORITY:\n      return parsePriority(cursor);\n    case http2::FrameType::RST_STREAM:\n      return parseRstStream(cursor);\n    case http2::FrameType::SETTINGS:\n      return parseSettings(cursor);\n    case http2::FrameType::PUSH_PROMISE:\n      return parsePushPromise(cursor);\n    case http2::FrameType::EX_HEADERS:\n      if (ingressSettings_.getSetting(SettingsId::ENABLE_EX_HEADERS, 0)) {\n        return parseExHeaders(cursor);\n      } else {\n        VLOG(2) << \"EX_HEADERS not enabled, ignoring the frame\";\n        break;\n      }\n    case http2::FrameType::PING:\n      return parsePing(cursor);\n    case http2::FrameType::GOAWAY:\n      return parseGoaway(cursor);\n    case http2::FrameType::WINDOW_UPDATE:\n      return parseWindowUpdate(cursor);\n    case http2::FrameType::CONTINUATION:\n      return parseContinuation(cursor);\n    case http2::FrameType::ALTSVC:\n      // fall through, unimplemented\n      break;\n    case http2::FrameType::CERTIFICATE_REQUEST:\n      return parseCertificateRequest(cursor);\n    case http2::FrameType::CERTIFICATE:\n      return parseCertificate(cursor);\n    default:\n      // Implementations MUST ignore and discard any frame that has a\n      // type that is unknown\n      break;\n  }\n\n  // Landing here means unknown, unimplemented or ignored frame.\n  VLOG(2) << \"Skipping frame (type=\" << (uint8_t)curHeader_.type << \")\";\n  cursor.skip(curHeader_.length);\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::handleEndStream() {\n  if (curHeader_.type != http2::FrameType::HEADERS &&\n      curHeader_.type != http2::FrameType::EX_HEADERS &&\n      curHeader_.type != http2::FrameType::CONTINUATION &&\n      curHeader_.type != http2::FrameType::DATA) {\n    return ErrorCode::NO_ERROR;\n  }\n\n  // do we need to handle case where this stream has already aborted via\n  // another callback (onHeadersComplete/onBody)?\n  pendingEndStreamHandling_ |= (curHeader_.flags & http2::END_STREAM);\n\n  // with a websocket upgrade, we need to send message complete cb to\n  // mirror h1x codec's behavior. when the stream closes, we need to\n  // send another callback to clean up the stream's resources.\n  if (ingressWebsocketUpgrade_) {\n    ingressWebsocketUpgrade_ = false;\n    deliverCallbackIfAllowed(&HTTPCodec::Callback::onMessageComplete,\n                             \"onMessageComplete\", curHeader_.stream, true);\n  }\n\n  if (pendingEndStreamHandling_ && expectedContinuationStream_ == 0) {\n    pendingEndStreamHandling_ = false;\n    deliverCallbackIfAllowed(&HTTPCodec::Callback::onMessageComplete,\n                             \"onMessageComplete\", curHeader_.stream, false);\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseAllData(Cursor& cursor) {\n  std::unique_ptr<IOBuf> outData;\n  uint16_t padding = 0;\n  VLOG(10) << \"parsing all frame DATA bytes for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  auto ret = http2::parseData(cursor, curHeader_, outData, padding);\n  RETURN_IF_ERROR(ret);\n\n  if (callback_ && (padding > 0 || (outData && !outData->empty()))) {\n    if (!outData) {\n      outData = std::make_unique<IOBuf>();\n    }\n    deliverCallbackIfAllowed(&HTTPCodec::Callback::onBody, \"onBody\",\n                             curHeader_.stream, std::move(outData), padding);\n  }\n  return handleEndStream();\n}\n\nErrorCode HTTP2Codec::parseDataFrameData(Cursor& cursor,\n                                         size_t bufLen,\n                                         size_t& parsed) {\n  FOLLY_SCOPED_TRACE_SECTION(\"HTTP2Codec - parseDataFrameData\");\n  if (bufLen == 0) {\n    VLOG(10) << \"No data to parse\";\n    return ErrorCode::NO_ERROR;\n  }\n\n  std::unique_ptr<IOBuf> outData;\n  uint16_t padding = 0;\n  VLOG(10) << \"parsing DATA frame data for stream=\" << curHeader_.stream <<\n    \" frame data length=\" << curHeader_.length << \" pendingDataFrameBytes_=\" <<\n    pendingDataFrameBytes_ << \" pendingDataFramePaddingBytes_=\" <<\n    pendingDataFramePaddingBytes_ << \" bufLen=\" << bufLen <<\n    \" parsed=\" << parsed;\n  // Parse the padding information only the first time\n  if (pendingDataFrameBytes_ == curHeader_.length &&\n    pendingDataFramePaddingBytes_ == 0) {\n    if (frameHasPadding(curHeader_) && bufLen == 1) {\n      // We need to wait for more bytes otherwise we won't be able to pass\n      // the correct padding to the first onBody call\n      return ErrorCode::NO_ERROR;\n    }\n    const auto ret = http2::parseDataBegin(cursor, curHeader_, parsed, padding);\n    RETURN_IF_ERROR(ret);\n    if (padding > 0) {\n      pendingDataFramePaddingBytes_ = padding - 1;\n      pendingDataFrameBytes_--;\n      bufLen--;\n      parsed++;\n    }\n    VLOG(10) << \"out padding=\" << padding << \" pendingDataFrameBytes_=\" <<\n      pendingDataFrameBytes_ << \" pendingDataFramePaddingBytes_=\" <<\n      pendingDataFramePaddingBytes_ << \" bufLen=\" << bufLen <<\n      \" parsed=\" << parsed;\n  }\n  if (bufLen > 0) {\n    // Check if we have application data to parse\n    if (pendingDataFrameBytes_ > pendingDataFramePaddingBytes_) {\n      const size_t pendingAppData =\n        pendingDataFrameBytes_ - pendingDataFramePaddingBytes_;\n      const size_t toClone = std::min(pendingAppData, bufLen);\n      cursor.clone(outData, toClone);\n      bufLen -= toClone;\n      pendingDataFrameBytes_ -= toClone;\n      parsed += toClone;\n      VLOG(10) << \"parsed some app data, pendingDataFrameBytes_=\" <<\n        pendingDataFrameBytes_ << \" pendingDataFramePaddingBytes_=\" <<\n        pendingDataFramePaddingBytes_ << \" bufLen=\" << bufLen <<\n        \" parsed=\" << parsed;\n    }\n    // Check if we have padding bytes to parse\n    if (bufLen > 0 && pendingDataFramePaddingBytes_ > 0) {\n      size_t toSkip = 0;\n      auto ret = http2::parseDataEnd(cursor, bufLen,\n                                     pendingDataFramePaddingBytes_, toSkip);\n      RETURN_IF_ERROR(ret);\n      pendingDataFrameBytes_ -= toSkip;\n      pendingDataFramePaddingBytes_ -= toSkip;\n      parsed += toSkip;\n      VLOG(10) << \"parsed some padding, pendingDataFrameBytes_=\" <<\n        pendingDataFrameBytes_ << \" pendingDataFramePaddingBytes_=\" <<\n        pendingDataFramePaddingBytes_ << \" bufLen=\" << bufLen <<\n        \" parsed=\" << parsed;\n    }\n  }\n\n  if (callback_ && (padding > 0 || (outData && !outData->empty()))) {\n    if (!outData) {\n      outData = std::make_unique<IOBuf>();\n    }\n    deliverCallbackIfAllowed(&HTTPCodec::Callback::onBody, \"onBody\",\n                             curHeader_.stream, std::move(outData), padding);\n  }\n  return (pendingDataFrameBytes_ > 0) ? ErrorCode::NO_ERROR : handleEndStream();\n}\n\n\nErrorCode HTTP2Codec::parseHeaders(Cursor& cursor) {\n  FOLLY_SCOPED_TRACE_SECTION(\"HTTP2Codec - parseHeaders\");\n  folly::Optional<http2::PriorityUpdate> priority;\n  std::unique_ptr<IOBuf> headerBuf;\n  VLOG(4) << \"parsing HEADERS frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  auto err = http2::parseHeaders(cursor, curHeader_, priority, headerBuf);\n  RETURN_IF_ERROR(err);\n  if (transportDirection_ == TransportDirection::DOWNSTREAM) {\n    RETURN_IF_ERROR(\n        checkNewStream(curHeader_.stream, true /* trailersAllowed */));\n  }\n  err = parseHeadersImpl(cursor, std::move(headerBuf), priority, folly::none,\n                         folly::none);\n  return err;\n}\n\nErrorCode HTTP2Codec::parseExHeaders(Cursor& cursor) {\n  FOLLY_SCOPED_TRACE_SECTION(\"HTTP2Codec - parseExHeaders\");\n  HTTPCodec::ExAttributes exAttributes;\n  folly::Optional<http2::PriorityUpdate> priority;\n  std::unique_ptr<IOBuf> headerBuf;\n  VLOG(4) << \"parsing ExHEADERS frame for stream=\" << curHeader_.stream\n          << \" length=\" << curHeader_.length;\n  auto err = http2::parseExHeaders(\n      cursor, curHeader_, exAttributes, priority, headerBuf);\n  RETURN_IF_ERROR(err);\n  if (isRequest(curHeader_.stream)) {\n    RETURN_IF_ERROR(\n        checkNewStream(curHeader_.stream, false /* trailersAllowed */));\n  }\n  return parseHeadersImpl(cursor, std::move(headerBuf), priority, folly::none,\n                          exAttributes);\n}\n\nErrorCode HTTP2Codec::parseContinuation(Cursor& cursor) {\n  std::unique_ptr<IOBuf> headerBuf;\n  VLOG(4) << \"parsing CONTINUATION frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  auto err = http2::parseContinuation(cursor, curHeader_, headerBuf);\n  RETURN_IF_ERROR(err);\n  err = parseHeadersImpl(cursor, std::move(headerBuf),\n                         folly::none, folly::none, folly::none);\n  return err;\n}\n\nErrorCode HTTP2Codec::parseHeadersImpl(\n    Cursor& /*cursor*/,\n    std::unique_ptr<IOBuf> headerBuf,\n    const folly::Optional<http2::PriorityUpdate>& priority,\n    const folly::Optional<uint32_t>& promisedStream,\n    const folly::Optional<ExAttributes>& exAttributes) {\n  curHeaderBlock_.append(std::move(headerBuf));\n  std::unique_ptr<HTTPMessage> msg;\n  if (curHeader_.flags & http2::END_HEADERS) {\n    auto errorCode =\n        parseHeadersDecodeFrames(priority, promisedStream, exAttributes, msg);\n    if (errorCode.hasValue()) {\n      return errorCode.value();\n    }\n  }\n\n  // if we're not parsing CONTINUATION, then it's start of new header block\n  if (curHeader_.type != http2::FrameType::CONTINUATION) {\n    headerBlockFrameType_ = curHeader_.type;\n  }\n\n  // Report back what we've parsed\n  if (callback_) {\n    auto concurError = parseHeadersCheckConcurrentStreams(priority);\n    if (concurError.hasValue()) {\n      return concurError.value();\n    }\n    uint32_t headersCompleteStream = curHeader_.stream;\n    bool trailers = parsingTrailers();\n    bool allHeaderFramesReceived =\n        (curHeader_.flags & http2::END_HEADERS) &&\n        (headerBlockFrameType_ == http2::FrameType::HEADERS);\n    if (allHeaderFramesReceived && !trailers) {\n      // Only deliver onMessageBegin once per stream.\n      // For responses with CONTINUATION, this will be delayed until\n      // the frame with the END_HEADERS flag set.\n      if (!deliverCallbackIfAllowed(&HTTPCodec::Callback::onMessageBegin,\n                                    \"onMessageBegin\",\n                                    curHeader_.stream,\n                                    msg.get())) {\n        return handleEndStream();\n      }\n   } else if (curHeader_.type == http2::FrameType::EX_HEADERS) {\n      if (!deliverCallbackIfAllowed(&HTTPCodec::Callback::onExMessageBegin,\n                                    \"onExMessageBegin\",\n                                    curHeader_.stream,\n                                    exAttributes->controlStream,\n                                    exAttributes->unidirectional,\n                                    msg.get())) {\n        return handleEndStream();\n      }\n    } else if (curHeader_.type == http2::FrameType::PUSH_PROMISE) {\n      DCHECK(promisedStream);\n      if (!deliverCallbackIfAllowed(&HTTPCodec::Callback::onPushMessageBegin,\n                                    \"onPushMessageBegin\", *promisedStream,\n                                    curHeader_.stream, msg.get())) {\n        return handleEndStream();\n      }\n      headersCompleteStream = *promisedStream;\n    }\n\n    if (curHeader_.flags & http2::END_HEADERS && msg) {\n      if (!(curHeader_.flags & http2::END_STREAM)) {\n        // If it there are DATA frames coming, consider it chunked\n        msg->setIsChunked(true);\n      }\n      if (trailers) {\n        VLOG(4) << \"Trailers complete for streamId=\" << headersCompleteStream\n                << \" direction=\" << transportDirection_;\n        auto trailerHeaders =\n            std::make_unique<HTTPHeaders>(msg->extractHeaders());\n        msg.reset();\n        callback_->onTrailersComplete(headersCompleteStream,\n                                      std::move(trailerHeaders));\n      } else {\n        callback_->onHeadersComplete(headersCompleteStream, std::move(msg));\n      }\n    }\n    return handleEndStream();\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nfolly::Optional<ErrorCode> HTTP2Codec::parseHeadersDecodeFrames(\n    const folly::Optional<http2::PriorityUpdate>& priority,\n    const folly::Optional<uint32_t>& promisedStream,\n    const folly::Optional<ExAttributes>& exAttributes,\n    std::unique_ptr<HTTPMessage>& msg) {\n  // decompress headers\n  Cursor headerCursor(curHeaderBlock_.front());\n  bool isReq = false;\n  if (promisedStream) {\n    isReq = true;\n  } else if (exAttributes) {\n    isReq = isRequest(curHeader_.stream);\n  } else {\n    isReq = transportDirection_ == TransportDirection::DOWNSTREAM;\n  }\n\n  // Validate circular dependencies.\n  if (priority && (curHeader_.stream == priority->streamDependency)) {\n    streamError(\n        folly::to<string>(\"Circular dependency for txn=\", curHeader_.stream),\n        ErrorCode::PROTOCOL_ERROR,\n        curHeader_.type == http2::FrameType::HEADERS);\n    return ErrorCode::NO_ERROR;\n  }\n\n  decodeInfo_.init(isReq, parsingDownstreamTrailers_);\n  if (priority) {\n    decodeInfo_.msg->setHTTP2Priority(\n        std::make_tuple(priority->streamDependency,\n                        priority->exclusive,\n                        priority->weight));\n  }\n\n  headerCodec_.decodeStreaming(\n      headerCursor, curHeaderBlock_.chainLength(), this);\n  msg = std::move(decodeInfo_.msg);\n  // Saving this in case we need to log it on error\n  auto g = folly::makeGuard([this] { curHeaderBlock_.move(); });\n  // Check decoding error\n  if (decodeInfo_.decodeError != HPACK::DecodeError::NONE) {\n    static const std::string decodeErrorMessage =\n        \"Failed decoding header block for stream=\";\n    // Avoid logging header blocks that have failed decoding due to being\n    // excessively large.\n    if (decodeInfo_.decodeError != HPACK::DecodeError::HEADERS_TOO_LARGE) {\n      LOG(ERROR) << decodeErrorMessage << curHeader_.stream\n                 << \" header block=\";\n      VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);\n    } else {\n      LOG(ERROR) << decodeErrorMessage << curHeader_.stream;\n    }\n\n    if (msg) {\n      // print the partial message\n      msg->dumpMessage(3);\n    }\n    return ErrorCode::COMPRESSION_ERROR;\n  }\n\n  // Check parsing error\n  if (decodeInfo_.parsingError != \"\") {\n    LOG(ERROR) << \"Failed parsing header list for stream=\" << curHeader_.stream\n               << \", error=\" << decodeInfo_.parsingError << \", header block=\";\n    VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);\n    HTTPException err(HTTPException::Direction::INGRESS,\n                      folly::to<std::string>(\"HTTP2Codec stream error: \",\n                                             \"stream=\",\n                                             curHeader_.stream,\n                                             \" status=\",\n                                             400,\n                                             \" error: \",\n                                             decodeInfo_.parsingError));\n    err.setHttpStatusCode(400);\n    callback_->onError(curHeader_.stream, err, true);\n    return ErrorCode::NO_ERROR;\n  }\n\n  return folly::Optional<ErrorCode>();\n}\n\nfolly::Optional<ErrorCode> HTTP2Codec::parseHeadersCheckConcurrentStreams(\n    const folly::Optional<http2::PriorityUpdate>& priority) {\n  if (curHeader_.type == http2::FrameType::HEADERS ||\n      curHeader_.type == http2::FrameType::EX_HEADERS) {\n    if (curHeader_.flags & http2::PRIORITY) {\n      DCHECK(priority);\n      // callback_->onPriority(priority.get());\n    }\n\n    // callback checks total number of streams is smaller than settings max\n    if (callback_->numIncomingStreams() >=\n        egressSettings_.getSetting(SettingsId::MAX_CONCURRENT_STREAMS,\n                                   std::numeric_limits<int32_t>::max())) {\n      streamError(folly::to<string>(\"Exceeded max_concurrent_streams\"),\n                  ErrorCode::REFUSED_STREAM, true);\n      return ErrorCode::NO_ERROR;\n    }\n  }\n  return folly::Optional<ErrorCode>();\n}\n\nvoid HTTP2Codec::onHeader(const folly::fbstring& name,\n                          const folly::fbstring& value) {\n  if (decodeInfo_.onHeader(name, value)) {\n    if (name == \"user-agent\" && userAgent_.empty()) {\n      userAgent_ = value.toStdString();\n    }\n  } else {\n    VLOG(4) << \"dir=\" << uint32_t(transportDirection_) <<\n      decodeInfo_.parsingError << \" codec=\" << headerCodec_;\n  }\n}\n\nvoid HTTP2Codec::onHeadersComplete(HTTPHeaderSize decodedSize,\n                                   bool /*acknowledge*/) {\n  decodeInfo_.onHeadersComplete(decodedSize);\n  decodeInfo_.msg->setAdvancedProtocolString(http2::kProtocolString);\n\n  HTTPMessage* msg = decodeInfo_.msg.get();\n  HTTPRequestVerifier& verifier = decodeInfo_.verifier;\n  if ((transportDirection_ == TransportDirection::DOWNSTREAM) &&\n      verifier.hasUpgradeProtocol() &&\n      (*msg->getUpgradeProtocol() == headers::kWebsocketString) &&\n      msg->getMethod() == HTTPMethod::CONNECT) {\n    msg->setIngressWebsocketUpgrade();\n    ingressWebsocketUpgrade_ = true;\n  } else {\n    auto it = upgradedStreams_.find(curHeader_.stream);\n    if (it != upgradedStreams_.end()) {\n      upgradedStreams_.erase(curHeader_.stream);\n      // a websocket upgrade was sent on this stream.\n      if (msg->getStatusCode() != 200) {\n        decodeInfo_.parsingError =\n          folly::to<string>(\"Invalid response code to a websocket upgrade: \",\n                            msg->getStatusCode());\n        return;\n      }\n      msg->setIngressWebsocketUpgrade();\n    }\n  }\n}\n\nvoid HTTP2Codec::onDecodeError(HPACK::DecodeError decodeError) {\n  decodeInfo_.decodeError = decodeError;\n}\n\nErrorCode HTTP2Codec::parsePriority(Cursor& cursor) {\n  VLOG(4) << \"parsing PRIORITY frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  http2::PriorityUpdate pri;\n  auto err = http2::parsePriority(cursor, curHeader_, pri);\n  RETURN_IF_ERROR(err);\n  if (curHeader_.stream == pri.streamDependency) {\n    streamError(folly::to<string>(\"Circular dependency for txn=\",\n                                  curHeader_.stream),\n                ErrorCode::PROTOCOL_ERROR, false);\n    return ErrorCode::NO_ERROR;\n  }\n  deliverCallbackIfAllowed(&HTTPCodec::Callback::onPriority, \"onPriority\",\n                           curHeader_.stream,\n                           std::make_tuple(pri.streamDependency,\n                                           pri.exclusive,\n                                           pri.weight));\n  return ErrorCode::NO_ERROR;\n}\n\nsize_t HTTP2Codec::addPriorityNodes(\n    PriorityQueue& queue,\n    folly::IOBufQueue& writeBuf,\n    uint8_t maxLevel) {\n  HTTPCodec::StreamID parent = 0;\n  size_t bytes = 0;\n  while (maxLevel--) {\n    auto id = createStream();\n    virtualPriorityNodes_.push_back(id);\n    queue.addPriorityNode(id, parent);\n    bytes += generatePriority(writeBuf, id, std::make_tuple(parent, false, 0));\n    parent = id;\n  }\n  return bytes;\n}\n\nErrorCode HTTP2Codec::parseRstStream(Cursor& cursor) {\n  // rst for stream in idle state - protocol error\n  VLOG(4) << \"parsing RST_STREAM frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  upgradedStreams_.erase(curHeader_.stream);\n  ErrorCode statusCode = ErrorCode::NO_ERROR;\n  auto err = http2::parseRstStream(cursor, curHeader_, statusCode);\n  RETURN_IF_ERROR(err);\n  if (statusCode == ErrorCode::PROTOCOL_ERROR) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: RST_STREAM with code=\", getErrorCodeString(statusCode),\n        \" for streamID=\", curHeader_.stream, \" user-agent=\", userAgent_);\n    VLOG(2) << goawayErrorMessage_;\n  }\n  deliverCallbackIfAllowed(&HTTPCodec::Callback::onAbort, \"onAbort\",\n                           curHeader_.stream, statusCode);\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseSettings(Cursor& cursor) {\n  VLOG(4) << \"parsing SETTINGS frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  std::deque<SettingPair> settings;\n  auto err = http2::parseSettings(cursor, curHeader_, settings);\n  RETURN_IF_ERROR(err);\n  if (curHeader_.flags & http2::ACK) {\n    handleSettingsAck();\n    return ErrorCode::NO_ERROR;\n  }\n  return handleSettings(settings);\n}\n\nvoid HTTP2Codec::handleSettingsAck() {\n  if (pendingTableMaxSize_) {\n    headerCodec_.setDecoderHeaderTableMaxSize(*pendingTableMaxSize_);\n    pendingTableMaxSize_ = folly::none;\n  }\n  if (callback_) {\n    callback_->onSettingsAck();\n  }\n}\n\nErrorCode HTTP2Codec::handleSettings(const std::deque<SettingPair>& settings) {\n  SettingsList settingsList;\n  for (auto& setting: settings) {\n    switch (setting.first) {\n      case SettingsId::HEADER_TABLE_SIZE:\n      {\n        uint32_t tableSize = setting.second;\n        if (setting.second > http2::kMaxHeaderTableSize) {\n          VLOG(2) << \"Limiting table size from \" << tableSize << \" to \" <<\n            http2::kMaxHeaderTableSize;\n          tableSize = http2::kMaxHeaderTableSize;\n        }\n        headerCodec_.setEncoderHeaderTableSize(tableSize);\n      }\n      break;\n      case SettingsId::ENABLE_PUSH:\n        if ((setting.second != 0 && setting.second != 1) ||\n            (setting.second == 1 &&\n             transportDirection_ == TransportDirection::UPSTREAM)) {\n          goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: ENABLE_PUSH invalid setting=\", setting.second,\n              \" for streamID=\", curHeader_.stream);\n          VLOG(4) << goawayErrorMessage_;\n          return ErrorCode::PROTOCOL_ERROR;\n        }\n        break;\n      case SettingsId::MAX_CONCURRENT_STREAMS:\n        break;\n      case SettingsId::INITIAL_WINDOW_SIZE:\n        if (setting.second > http2::kMaxWindowUpdateSize) {\n          goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: INITIAL_WINDOW_SIZE invalid size=\", setting.second,\n              \" for streamID=\", curHeader_.stream);\n          VLOG(4) << goawayErrorMessage_;\n          return ErrorCode::PROTOCOL_ERROR;\n        }\n        break;\n      case SettingsId::MAX_FRAME_SIZE:\n        if (setting.second < http2::kMaxFramePayloadLengthMin ||\n            setting.second > http2::kMaxFramePayloadLength) {\n          goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: MAX_FRAME_SIZE invalid size=\", setting.second,\n              \" for streamID=\", curHeader_.stream);\n          VLOG(4) << goawayErrorMessage_;\n          return ErrorCode::PROTOCOL_ERROR;\n        }\n        ingressSettings_.setSetting(SettingsId::MAX_FRAME_SIZE, setting.second);\n        break;\n      case SettingsId::MAX_HEADER_LIST_SIZE:\n        break;\n      case SettingsId::ENABLE_EX_HEADERS:\n      {\n        auto ptr = egressSettings_.getSetting(SettingsId::ENABLE_EX_HEADERS);\n        if (ptr && ptr->value > 0) {\n          VLOG(4) << getTransportDirectionString(getTransportDirection())\n                  << \" got ENABLE_EX_HEADERS=\" << setting.second;\n          if (setting.second != 0 && setting.second != 1) {\n            goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: invalid ENABLE_EX_HEADERS=\", setting.second,\n              \" for streamID=\", curHeader_.stream);\n            VLOG(4) << goawayErrorMessage_;\n            return ErrorCode::PROTOCOL_ERROR;\n          }\n          break;\n        } else {\n          // egress ENABLE_EX_HEADERS is disabled, consider the ingress\n          // ENABLE_EX_HEADERS as unknown setting, and ignore it.\n          continue;\n        }\n      }\n      case SettingsId::ENABLE_CONNECT_PROTOCOL:\n        if (setting.second > 1) {\n          goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: ENABLE_CONNECT_PROTOCOL invalid number=\",\n              setting.second, \" for streamID=\", curHeader_.stream);\n          VLOG(4) << goawayErrorMessage_;\n          return ErrorCode::PROTOCOL_ERROR;\n        }\n        break;\n      case SettingsId::THRIFT_CHANNEL_ID:\n      case SettingsId::THRIFT_CHANNEL_ID_DEPRECATED:\n        break;\n      case SettingsId::SETTINGS_HTTP_CERT_AUTH:\n        break;\n      default:\n        continue; // ignore unknown setting\n    }\n    ingressSettings_.setSetting(setting.first, setting.second);\n    settingsList.push_back(*ingressSettings_.getSetting(setting.first));\n  }\n  if (callback_) {\n    callback_->onSettings(settingsList);\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parsePushPromise(Cursor& cursor) {\n  // stream id must be idle - protocol error\n  // assoc-stream-id=closed/unknown - protocol error, unless rst_stream sent\n\n  /*\n   * What does \"must handle\" mean in the following context?  I have to\n   * accept this as a valid pushed resource?\n\n    However, an endpoint that has sent RST_STREAM on the associated\n    stream MUST handle PUSH_PROMISE frames that might have been\n    created before the RST_STREAM frame is received and processed.\n  */\n  if (transportDirection_ != TransportDirection::UPSTREAM) {\n    goawayErrorMessage_ = folly::to<string>(\n      \"Received PUSH_PROMISE on DOWNSTREAM codec\");\n    VLOG(2) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  if (egressSettings_.getSetting(SettingsId::ENABLE_PUSH, -1) != 1) {\n    goawayErrorMessage_ = folly::to<string>(\n      \"Received PUSH_PROMISE on codec with push disabled\");\n    VLOG(2) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  VLOG(4) << \"parsing PUSH_PROMISE frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  uint32_t promisedStream;\n  std::unique_ptr<IOBuf> headerBlockFragment;\n  auto err = http2::parsePushPromise(cursor, curHeader_, promisedStream,\n                                     headerBlockFragment);\n  RETURN_IF_ERROR(err);\n  RETURN_IF_ERROR(checkNewStream(promisedStream, false /* trailersAllowed */));\n  err = parseHeadersImpl(cursor, std::move(headerBlockFragment), folly::none,\n                         promisedStream, folly::none);\n  return err;\n}\n\nErrorCode HTTP2Codec::parsePing(Cursor& cursor) {\n  VLOG(4) << \"parsing PING frame length=\" << curHeader_.length;\n  uint64_t opaqueData = 0;\n  auto err = http2::parsePing(cursor, curHeader_, opaqueData);\n  RETURN_IF_ERROR(err);\n  if (callback_) {\n    if (curHeader_.flags & http2::ACK) {\n      callback_->onPingReply(opaqueData);\n    } else {\n      callback_->onPingRequest(opaqueData);\n    }\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseGoaway(Cursor& cursor) {\n  VLOG(4) << \"parsing GOAWAY frame length=\" << curHeader_.length;\n  uint32_t lastGoodStream = 0;\n  ErrorCode statusCode = ErrorCode::NO_ERROR;\n  std::unique_ptr<IOBuf> debugData;\n\n  auto err = http2::parseGoaway(cursor, curHeader_, lastGoodStream, statusCode,\n                                debugData);\n  if (statusCode != ErrorCode::NO_ERROR) {\n    VLOG(2) << \"Goaway error statusCode=\" << getErrorCodeString(statusCode)\n            << \" lastStream=\" << lastGoodStream\n            << \" user-agent=\" << userAgent_ <<  \" debugData=\" <<\n      ((debugData) ? string((char*)debugData->data(), debugData->length()):\n       empty_string);\n  }\n  RETURN_IF_ERROR(err);\n  if (lastGoodStream < ingressGoawayAck_) {\n    ingressGoawayAck_ = lastGoodStream;\n    // Drain all streams <= lastGoodStream\n    // and abort streams > lastGoodStream\n    if (callback_) {\n      callback_->onGoaway(lastGoodStream, statusCode, std::move(debugData));\n    }\n  } else {\n    LOG(WARNING) << \"Received multiple GOAWAY with increasing ack\";\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseWindowUpdate(Cursor& cursor) {\n  VLOG(4) << \"parsing WINDOW_UPDATE frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  uint32_t delta = 0;\n  auto err = http2::parseWindowUpdate(cursor, curHeader_, delta);\n  RETURN_IF_ERROR(err);\n  if (delta == 0) {\n    VLOG(4) << \"Invalid 0 length delta for stream=\" << curHeader_.stream;\n    if (curHeader_.stream == 0) {\n      goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: invalid/0 length delta for streamID=\",\n        curHeader_.stream);\n      return ErrorCode::PROTOCOL_ERROR;\n    } else {\n      // Parsing a zero delta window update should cause a protocol error\n      // and send a rst stream\n      goawayErrorMessage_ = folly::to<string>(\n        \"parseWindowUpdate Invalid 0 length\");\n      VLOG(4) << goawayErrorMessage_;\n      streamError(folly::to<std::string>(\"streamID=\", curHeader_.stream,\n                                         \" with HTTP2Codec stream error: \",\n                                         \"window update delta=\", delta),\n                  ErrorCode::PROTOCOL_ERROR);\n      return ErrorCode::PROTOCOL_ERROR;\n    }\n  }\n  // if window exceeds 2^31-1, connection/stream error flow control error\n  // must be checked in session/txn\n  deliverCallbackIfAllowed(&HTTPCodec::Callback::onWindowUpdate,\n                           \"onWindowUpdate\", curHeader_.stream, delta);\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseCertificateRequest(Cursor& cursor) {\n  VLOG(4) << \"parsing CERTIFICATE_REQUEST frame length=\" << curHeader_.length;\n  uint16_t requestId = 0;\n  std::unique_ptr<IOBuf> authRequest;\n\n  auto err = http2::parseCertificateRequest(\n      cursor, curHeader_, requestId, authRequest);\n  RETURN_IF_ERROR(err);\n  if (callback_) {\n    callback_->onCertificateRequest(requestId, std::move(authRequest));\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseCertificate(Cursor& cursor) {\n  VLOG(4) << \"parsing CERTIFICATE frame length=\" << curHeader_.length;\n  uint16_t certId = 0;\n  std::unique_ptr<IOBuf> authData;\n  auto err = http2::parseCertificate(cursor, curHeader_, certId, authData);\n  RETURN_IF_ERROR(err);\n  if (curAuthenticatorBlock_.empty()) {\n    curCertId_ = certId;\n  } else if (certId != curCertId_) {\n    // Received CERTIFICATE frame with different Cert-ID.\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  curAuthenticatorBlock_.append(std::move(authData));\n  if (curAuthenticatorBlock_.chainLength() > http2::kMaxAuthenticatorBufSize) {\n    // Received excessively long authenticator.\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  if (!(curHeader_.flags & http2::TO_BE_CONTINUED)) {\n    auto authenticator = curAuthenticatorBlock_.move();\n    if (callback_) {\n      callback_->onCertificate(certId, std::move(authenticator));\n    } else {\n      curAuthenticatorBlock_.clear();\n    }\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::checkNewStream(uint32_t streamId, bool trailersAllowed) {\n  if (streamId == 0) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: received streamID=\", streamId,\n        \" as invalid new stream for lastStreamID_=\", lastStreamID_);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  parsingDownstreamTrailers_ = trailersAllowed && (streamId <= lastStreamID_);\n  if (parsingDownstreamTrailers_) {\n    VLOG(4) << \"Parsing downstream trailers streamId=\" << streamId;\n  }\n\n  if (sessionClosing_ != ClosingState::CLOSED && streamId > lastStreamID_) {\n    lastStreamID_ = streamId;\n  }\n\n  if (isInitiatedStream(streamId)) {\n    // this stream should be initiated by us, not by peer\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: invalid new stream received with streamID=\", streamId);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  } else {\n    return ErrorCode::NO_ERROR;\n  }\n}\n\nsize_t HTTP2Codec::generateConnectionPreface(folly::IOBufQueue& writeBuf) {\n  if (transportDirection_ == TransportDirection::UPSTREAM) {\n    VLOG(4) << \"generating connection preface\";\n    writeBuf.append(http2::kConnectionPreface);\n    return http2::kConnectionPreface.length();\n  }\n  return 0;\n}\n\nbool HTTP2Codec::onIngressUpgradeMessage(const HTTPMessage& msg) {\n  if (!HTTPParallelCodec::onIngressUpgradeMessage(msg)) {\n    return false;\n  }\n  if (msg.getHeaders().getNumberOfValues(http2::kProtocolSettingsHeader) != 1) {\n    VLOG(4) << __func__ << \" with no HTTP2-Settings\";\n    return false;\n  }\n\n  const auto& settingsHeader = msg.getHeaders().getSingleOrEmpty(\n    http2::kProtocolSettingsHeader);\n  if (settingsHeader.empty()) {\n    return true;\n  }\n\n  auto decoded = base64url_decode(settingsHeader);\n\n  // Must be well formed Base64Url and not too large\n  if (decoded.empty() || decoded.length() > http2::kMaxFramePayloadLength) {\n    VLOG(4) << __func__ << \" failed to decode HTTP2-Settings\";\n    return false;\n  }\n  std::unique_ptr<IOBuf> decodedBuf = IOBuf::wrapBuffer(decoded.data(),\n                                                        decoded.length());\n  IOBufQueue settingsQueue{IOBufQueue::cacheChainLength()};\n  settingsQueue.append(std::move(decodedBuf));\n  Cursor c(settingsQueue.front());\n  std::deque<SettingPair> settings;\n  // downcast is ok because of above length check\n  http2::FrameHeader frameHeader{\n    (uint32_t)settingsQueue.chainLength(), 0, http2::FrameType::SETTINGS, 0, 0};\n  auto err = http2::parseSettings(c, frameHeader, settings);\n  if (err != ErrorCode::NO_ERROR) {\n    VLOG(4) << __func__ << \" bad settings frame\";\n    return false;\n  }\n\n  if (handleSettings(settings) != ErrorCode::NO_ERROR) {\n    VLOG(4) << __func__ << \" handleSettings failed\";\n    return false;\n  }\n\n  return true;\n}\n\nvoid HTTP2Codec::generateHeader(folly::IOBufQueue& writeBuf,\n                                StreamID stream,\n                                const HTTPMessage& msg,\n                                bool eom,\n                                HTTPHeaderSize* size) {\n  generateHeaderImpl(writeBuf,\n                     stream,\n                     msg,\n                     folly::none, /* assocStream */\n                     folly::none, /* controlStream */\n                     eom,\n                     size);\n}\n\nvoid HTTP2Codec::generatePushPromise(folly::IOBufQueue& writeBuf,\n                                     StreamID stream,\n                                     const HTTPMessage& msg,\n                                     StreamID assocStream,\n                                     bool eom,\n                                     HTTPHeaderSize* size) {\n  generateHeaderImpl(writeBuf,\n                     stream,\n                     msg,\n                     assocStream,\n                     folly::none, /* controlStream */\n                     eom,\n                     size);\n}\n\nvoid HTTP2Codec::generateExHeader(folly::IOBufQueue& writeBuf,\n                                  StreamID stream,\n                                  const HTTPMessage& msg,\n                                  const HTTPCodec::ExAttributes& exAttributes,\n                                  bool eom,\n                                  HTTPHeaderSize* size) {\n  generateHeaderImpl(writeBuf,\n                     stream,\n                     msg,\n                     folly::none, /* assocStream */\n                     exAttributes,\n                     eom,\n                     size);\n}\n\nvoid HTTP2Codec::generateHeaderImpl(\n    folly::IOBufQueue& writeBuf,\n    StreamID stream,\n    const HTTPMessage& msg,\n    const folly::Optional<StreamID>& assocStream,\n    const folly::Optional<HTTPCodec::ExAttributes>& exAttributes,\n    bool eom,\n    HTTPHeaderSize* size) {\n  if (assocStream) {\n    CHECK(!exAttributes);\n    VLOG(4) << \"generating PUSH_PROMISE for stream=\" << stream;\n  } else if (exAttributes) {\n    CHECK(!assocStream);\n    VLOG(4) << \"generating ExHEADERS for stream=\" << stream\n            << \" with control stream=\" << exAttributes->controlStream\n            << \" unidirectional=\" << exAttributes->unidirectional;\n  } else {\n    VLOG(4) << \"generating HEADERS for stream=\" << stream;\n  }\n\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"Suppressing HEADERS/PROMISE for stream=\" << stream <<\n      \" ingressGoawayAck_=\" << ingressGoawayAck_;\n    if (size) {\n      size->uncompressed = 0;\n      size->compressed = 0;\n    }\n    return;\n  }\n\n  if (msg.isRequest()) {\n    DCHECK(transportDirection_ == TransportDirection::UPSTREAM ||\n           assocStream || exAttributes);\n    if (msg.isEgressWebsocketUpgrade()) {\n      upgradedStreams_.insert(stream);\n    }\n  } else {\n    DCHECK(transportDirection_ == TransportDirection::DOWNSTREAM ||\n           exAttributes);\n  }\n\n  std::vector<std::string> temps;\n  auto allHeaders = CodecUtil::prepareMessageForCompression(msg, temps);\n  auto out = encodeHeaders(msg.getHeaders(), allHeaders, size);\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(out));\n  auto maxFrameSize = maxSendFrameSize();\n  if (queue.chainLength() > 0) {\n    folly::Optional<http2::PriorityUpdate> pri;\n    auto res = msg.getHTTP2Priority();\n    auto remainingFrameSize = maxFrameSize;\n    if (res) {\n      pri = http2::PriorityUpdate{std::get<0>(*res), std::get<1>(*res),\n                                  std::get<2>(*res)};\n      DCHECK_GE(remainingFrameSize, http2::kFramePrioritySize)\n        << \"no enough space for priority? frameHeadroom=\" << remainingFrameSize;\n      remainingFrameSize -= http2::kFramePrioritySize;\n    }\n    auto chunk = queue.split(std::min(remainingFrameSize, queue.chainLength()));\n\n    bool endHeaders = queue.chainLength() == 0;\n\n    if (assocStream) {\n      DCHECK_EQ(transportDirection_, TransportDirection::DOWNSTREAM);\n      DCHECK(!eom);\n      generateHeaderCallbackWrapper(stream, http2::FrameType::PUSH_PROMISE,\n                                    http2::writePushPromise(writeBuf,\n                                                            *assocStream,\n                                                            stream,\n                                                            std::move(chunk),\n                                                            http2::kNoPadding,\n                                                            endHeaders));\n    } else if (exAttributes) {\n      generateHeaderCallbackWrapper(\n        stream,\n        http2::FrameType::EX_HEADERS,\n        http2::writeExHeaders(writeBuf,\n                              std::move(chunk),\n                              stream,\n                              *exAttributes,\n                              pri,\n                              http2::kNoPadding,\n                              eom,\n                              endHeaders));\n    } else {\n      generateHeaderCallbackWrapper(stream, http2::FrameType::HEADERS,\n                                    http2::writeHeaders(writeBuf,\n                                                        std::move(chunk),\n                                                        stream,\n                                                        pri,\n                                                        http2::kNoPadding,\n                                                        eom,\n                                                        endHeaders));\n    }\n\n    if (!endHeaders) {\n      generateContinuation(writeBuf, queue, stream, maxFrameSize);\n    }\n  }\n}\n\nvoid HTTP2Codec::generateContinuation(folly::IOBufQueue& writeBuf,\n                                      folly::IOBufQueue& queue,\n                                      StreamID stream,\n                                      size_t maxFrameSize) {\n  bool endHeaders = false;\n  while (!endHeaders) {\n    auto chunk = queue.split(std::min(maxFrameSize, queue.chainLength()));\n    endHeaders = (queue.chainLength() == 0);\n    VLOG(4) << \"generating CONTINUATION for stream=\" << stream;\n    generateHeaderCallbackWrapper(\n        stream,\n        http2::FrameType::CONTINUATION,\n        http2::writeContinuation(\n            writeBuf, stream, endHeaders, std::move(chunk)));\n  }\n}\n\nstd::unique_ptr<folly::IOBuf> HTTP2Codec::encodeHeaders(\n    const HTTPHeaders& headers,\n    std::vector<compress::Header>& allHeaders,\n    HTTPHeaderSize* size) {\n  headerCodec_.setEncodeHeadroom(http2::kFrameHeaderSize +\n                                 http2::kFrameHeadersBaseMaxSize);\n  auto out = headerCodec_.encode(allHeaders);\n  if (size) {\n    *size = headerCodec_.getEncodedSize();\n  }\n\n  if (headerCodec_.getEncodedSize().uncompressed >\n      ingressSettings_.getSetting(SettingsId::MAX_HEADER_LIST_SIZE,\n                                  std::numeric_limits<uint32_t>::max())) {\n    // The remote side told us they don't want headers this large...\n    // but this function has no mechanism to fail\n    string serializedHeaders;\n    headers.forEach(\n      [&serializedHeaders] (const string& name, const string& value) {\n        serializedHeaders = folly::to<string>(serializedHeaders, \"\\\\n\", name,\n                                              \":\", value);\n      });\n    LOG(ERROR) << \"generating HEADERS frame larger than peer maximum nHeaders=\"\n               << headers.size() << \" all headers=\"\n               << serializedHeaders;\n  }\n  return out;\n}\n\nsize_t HTTP2Codec::generateHeaderCallbackWrapper(StreamID stream,\n                                                 http2::FrameType type,\n                                                 size_t length) {\n  if (callback_) {\n    callback_->onGenerateFrameHeader(stream,\n                                     static_cast<uint8_t>(type),\n                                     length);\n  }\n  return length;\n}\n\nsize_t HTTP2Codec::generateBody(folly::IOBufQueue& writeBuf,\n                                StreamID stream,\n                                std::unique_ptr<folly::IOBuf> chain,\n                                folly::Optional<uint8_t> padding,\n                                bool eom) {\n  // todo: generate random padding for everything?\n  size_t written = 0;\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"Suppressing DATA for stream=\" << stream << \" ingressGoawayAck_=\"\n            << ingressGoawayAck_;\n    return 0;\n  }\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(chain));\n  size_t maxFrameSize = maxSendFrameSize();\n  while (queue.chainLength() > maxFrameSize) {\n    auto chunk = queue.split(maxFrameSize);\n    written += generateHeaderCallbackWrapper(\n                  stream,\n                  http2::FrameType::DATA,\n                  http2::writeData(writeBuf,\n                                   std::move(chunk),\n                                   stream,\n                                   padding,\n                                   false,\n                                   reuseIOBufHeadroomForData_));\n  }\n\n  return written + generateHeaderCallbackWrapper(\n                      stream,\n                      http2::FrameType::DATA,\n                      http2::writeData(writeBuf,\n                                       queue.move(),\n                                       stream,\n                                       padding,\n                                       eom,\n                                       reuseIOBufHeadroomForData_));\n}\n\nsize_t HTTP2Codec::generateChunkHeader(folly::IOBufQueue& /*writeBuf*/,\n                                       StreamID /*stream*/,\n                                       size_t /*length*/) {\n  // HTTP/2 has no chunk headers\n  return 0;\n}\n\nsize_t HTTP2Codec::generateChunkTerminator(folly::IOBufQueue& /*writeBuf*/,\n                                           StreamID /*stream*/) {\n  // HTTP/2 has no chunk terminators\n  return 0;\n}\n\nsize_t HTTP2Codec::generateTrailers(folly::IOBufQueue& writeBuf,\n                                    StreamID stream,\n                                    const HTTPHeaders& trailers) {\n  VLOG(4) << \"generating TRAILERS for stream=\" << stream;\n  std::vector<compress::Header> allHeaders;\n  CodecUtil::appendHeaders(trailers, allHeaders, HTTP_HEADER_NONE);\n\n  HTTPHeaderSize size;\n  auto out = encodeHeaders(trailers, allHeaders, &size);\n\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(out));\n  auto maxFrameSize = maxSendFrameSize();\n  if (queue.chainLength() > 0) {\n    folly::Optional<http2::PriorityUpdate> pri;\n    auto remainingFrameSize = maxFrameSize;\n    auto chunk = queue.split(std::min(remainingFrameSize, queue.chainLength()));\n    bool endHeaders = queue.chainLength() == 0;\n    generateHeaderCallbackWrapper(stream,\n                                  http2::FrameType::HEADERS,\n                                  http2::writeHeaders(writeBuf,\n                                                      std::move(chunk),\n                                                      stream,\n                                                      pri,\n                                                      http2::kNoPadding,\n                                                      true /*eom*/,\n                                                      endHeaders));\n\n    if (!endHeaders) {\n      generateContinuation(writeBuf, queue, stream, maxFrameSize);\n    }\n  }\n\n  return size.compressed;\n}\n\nsize_t HTTP2Codec::generateEOM(folly::IOBufQueue& writeBuf,\n                               StreamID stream) {\n  VLOG(4) << \"sending EOM for stream=\" << stream;\n  upgradedStreams_.erase(stream);\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"suppressed EOM for stream=\" << stream << \" ingressGoawayAck_=\"\n            << ingressGoawayAck_;\n    return 0;\n  }\n  return generateHeaderCallbackWrapper(\n            stream,\n            http2::FrameType::DATA,\n            http2::writeData(writeBuf,\n                             nullptr,\n                             stream,\n                             http2::kNoPadding,\n                             true,\n                             reuseIOBufHeadroomForData_));\n}\n\nsize_t HTTP2Codec::generateRstStream(folly::IOBufQueue& writeBuf,\n                                     StreamID stream,\n                                     ErrorCode statusCode) {\n  VLOG(4) << \"sending RST_STREAM for stream=\" << stream\n          << \" with code=\" << getErrorCodeString(statusCode);\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"suppressed RST_STREAM for stream=\" << stream\n            << \" ingressGoawayAck_=\" << ingressGoawayAck_;\n    return 0;\n  }\n  // Suppress any EOM callback for the current frame.\n  if (stream == curHeader_.stream) {\n    curHeader_.flags &= ~http2::END_STREAM;\n    pendingEndStreamHandling_ = false;\n    ingressWebsocketUpgrade_ = false;\n  }\n  upgradedStreams_.erase(stream);\n\n  if (statusCode == ErrorCode::PROTOCOL_ERROR) {\n    VLOG(2) << \"sending RST_STREAM with code=\" << getErrorCodeString(statusCode)\n            << \" for stream=\" << stream << \" user-agent=\" << userAgent_;\n  }\n  auto code = http2::errorCodeToReset(statusCode);\n  return generateHeaderCallbackWrapper(stream, http2::FrameType::RST_STREAM,\n                                       http2::writeRstStream(writeBuf, stream, code));\n}\n\nsize_t HTTP2Codec::generateGoaway(folly::IOBufQueue& writeBuf,\n                                  StreamID lastStream,\n                                  ErrorCode statusCode,\n                                  std::unique_ptr<folly::IOBuf> debugData) {\n  DCHECK_LE(lastStream, egressGoawayAck_) << \"Cannot increase last good stream\";\n  egressGoawayAck_ = lastStream;\n  if (sessionClosing_ == ClosingState::CLOSED) {\n    VLOG(4) << \"Not sending GOAWAY for closed session\";\n    return 0;\n  }\n  switch (sessionClosing_) {\n    case ClosingState::OPEN:\n    case ClosingState::OPEN_WITH_GRACEFUL_DRAIN_ENABLED:\n      if (lastStream == std::numeric_limits<int32_t>::max() &&\n          statusCode == ErrorCode::NO_ERROR) {\n        sessionClosing_ = ClosingState::FIRST_GOAWAY_SENT;\n      } else {\n        // The user of this codec decided not to do the double goaway\n        // drain, or this is not a graceful shutdown\n        sessionClosing_ = ClosingState::CLOSED;\n      }\n      break;\n    case ClosingState::FIRST_GOAWAY_SENT:\n      sessionClosing_ = ClosingState::CLOSED;\n      break;\n    case ClosingState::CLOSING:\n    case ClosingState::CLOSED:\n      LOG(FATAL) << \"unreachable\";\n  }\n\n  VLOG(4) << \"Sending GOAWAY with last acknowledged stream=\"\n          << lastStream << \" with code=\" << getErrorCodeString(statusCode);\n  if (statusCode == ErrorCode::PROTOCOL_ERROR) {\n    VLOG(2) << \"sending GOAWAY with last acknowledged stream=\" << lastStream\n            << \" with code=\" << getErrorCodeString(statusCode)\n            << \" user-agent=\" << userAgent_;\n  }\n\n  auto code = http2::errorCodeToGoaway(statusCode);\n  return generateHeaderCallbackWrapper(\n            0,\n            http2::FrameType::GOAWAY,\n            http2::writeGoaway(writeBuf,\n                              lastStream,\n                              code,\n                              std::move(debugData)));\n}\n\nsize_t HTTP2Codec::generatePingRequest(folly::IOBufQueue& writeBuf) {\n  // should probably let the caller specify when integrating with session\n  // we know HTTPSession sets up events to track ping latency\n  uint64_t opaqueData = folly::Random::rand64();\n  VLOG(4) << \"Generating ping request with opaqueData=\" << opaqueData;\n  return generateHeaderCallbackWrapper(0, http2::FrameType::PING,\n                                       http2::writePing(writeBuf, opaqueData, false /* no ack */));\n}\n\nsize_t HTTP2Codec::generatePingReply(folly::IOBufQueue& writeBuf,\n                                     uint64_t uniqueID) {\n  VLOG(4) << \"Generating ping reply with opaqueData=\" << uniqueID;\n  return generateHeaderCallbackWrapper(0, http2::FrameType::PING,\n                                       http2::writePing(writeBuf, uniqueID, true /* ack */));\n}\n\nsize_t HTTP2Codec::generateSettings(folly::IOBufQueue& writeBuf) {\n  std::deque<SettingPair> settings;\n  for (auto& setting: egressSettings_.getAllSettings()) {\n    switch (setting.id) {\n      case SettingsId::HEADER_TABLE_SIZE:\n        if (pendingTableMaxSize_) {\n          LOG(ERROR) << \"Can't have more than one settings in flight, skipping\";\n          continue;\n        } else {\n          pendingTableMaxSize_ = setting.value;\n        }\n        break;\n      case SettingsId::ENABLE_PUSH:\n        if (transportDirection_ == TransportDirection::DOWNSTREAM) {\n          // HTTP/2 spec says downstream must not send this flag\n          // HTTP2Codec uses it to determine if push features are enabled\n          continue;\n        } else {\n          CHECK(setting.value == 0 || setting.value == 1);\n        }\n        break;\n      case SettingsId::MAX_CONCURRENT_STREAMS:\n      case SettingsId::INITIAL_WINDOW_SIZE:\n      case SettingsId::MAX_FRAME_SIZE:\n        break;\n      case SettingsId::MAX_HEADER_LIST_SIZE:\n        headerCodec_.setMaxUncompressed(setting.value);\n        break;\n      case SettingsId::ENABLE_EX_HEADERS:\n        CHECK(setting.value == 0 || setting.value == 1);\n        if (setting.value == 0) {\n          continue; // just skip the experimental setting if disabled\n        } else {\n          VLOG(4) << \"generating ENABLE_EX_HEADERS=\" << setting.value;\n        }\n        break;\n      case SettingsId::ENABLE_CONNECT_PROTOCOL:\n        if (setting.value == 0) {\n          continue;\n        }\n        break;\n      case SettingsId::THRIFT_CHANNEL_ID:\n      case SettingsId::THRIFT_CHANNEL_ID_DEPRECATED:\n        break;\n      default:\n        LOG(ERROR) << \"ignore unknown settingsId=\"\n                   << std::underlying_type<SettingsId>::type(setting.id)\n                   << \" value=\" << setting.value;\n        continue;\n    }\n\n    settings.push_back(SettingPair(setting.id, setting.value));\n  }\n  VLOG(4) << getTransportDirectionString(getTransportDirection())\n          << \" generating \" << (unsigned)settings.size() << \" settings\";\n  return generateHeaderCallbackWrapper(0, http2::FrameType::SETTINGS,\n                                       http2::writeSettings(writeBuf, settings));\n}\n\nvoid HTTP2Codec::requestUpgrade(HTTPMessage& request) {\n  static folly::ThreadLocalPtr<HTTP2Codec> defaultCodec;\n  if (!defaultCodec.get()) {\n    defaultCodec.reset(new HTTP2Codec(TransportDirection::UPSTREAM));\n  }\n\n  auto& headers = request.getHeaders();\n  headers.set(HTTP_HEADER_UPGRADE, http2::kProtocolCleartextString);\n  if (!request.checkForHeaderToken(HTTP_HEADER_CONNECTION, \"Upgrade\", false)) {\n    headers.add(HTTP_HEADER_CONNECTION, \"Upgrade\");\n  }\n  IOBufQueue writeBuf{IOBufQueue::cacheChainLength()};\n  defaultCodec->generateSettings(writeBuf);\n  // fake an ack since defaultCodec gets reused\n  defaultCodec->handleSettingsAck();\n  writeBuf.trimStart(http2::kFrameHeaderSize);\n  auto buf = writeBuf.move();\n  buf->coalesce();\n  headers.set(http2::kProtocolSettingsHeader,\n              base64url_encode(folly::ByteRange(buf->data(), buf->length())));\n  if (!request.checkForHeaderToken(HTTP_HEADER_CONNECTION,\n                                   http2::kProtocolSettingsHeader.c_str(),\n                                   false)) {\n    headers.add(HTTP_HEADER_CONNECTION, http2::kProtocolSettingsHeader);\n  }\n}\n\nsize_t HTTP2Codec::generateSettingsAck(folly::IOBufQueue& writeBuf) {\n  VLOG(4) << getTransportDirectionString(getTransportDirection())\n          << \" generating settings ack\";\n  return generateHeaderCallbackWrapper(0, http2::FrameType::SETTINGS,\n                                       http2::writeSettingsAck(writeBuf));\n}\n\nsize_t HTTP2Codec::generateWindowUpdate(folly::IOBufQueue& writeBuf,\n                                        StreamID stream,\n                                        uint32_t delta) {\n  VLOG(4) << \"generating window update for stream=\" << stream\n          << \": Processed \" << delta << \" bytes\";\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"suppressed WINDOW_UPDATE for stream=\" << stream\n            << \" ingressGoawayAck_=\" << ingressGoawayAck_;\n    return 0;\n  }\n  return generateHeaderCallbackWrapper(stream, http2::FrameType::WINDOW_UPDATE,\n                                       http2::writeWindowUpdate(writeBuf, stream, delta));\n}\n\nsize_t HTTP2Codec::generatePriority(folly::IOBufQueue& writeBuf,\n                                    StreamID stream,\n                                    const HTTPMessage::HTTPPriority& pri) {\n  VLOG(4) << \"generating priority for stream=\" << stream;\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"suppressed PRIORITY for stream=\" << stream\n            << \" ingressGoawayAck_=\" << ingressGoawayAck_;\n    return 0;\n  }\n  return generateHeaderCallbackWrapper(\n            stream,\n            http2::FrameType::PRIORITY,\n            http2::writePriority(writeBuf, stream,\n                                 {std::get<0>(pri),\n                                   std::get<1>(pri),\n                                   std::get<2>(pri)}));\n}\n\nsize_t HTTP2Codec::generateCertificateRequest(\n    folly::IOBufQueue& writeBuf,\n    uint16_t requestId,\n    std::unique_ptr<folly::IOBuf> certificateRequestData) {\n  VLOG(4) << \"generating CERTIFICATE_REQUEST with Request-ID=\" << requestId;\n  return http2::writeCertificateRequest(\n      writeBuf, requestId, std::move(certificateRequestData));\n}\n\nsize_t HTTP2Codec::generateCertificate(folly::IOBufQueue& writeBuf,\n                                       uint16_t certId,\n                                       std::unique_ptr<folly::IOBuf> certData) {\n  size_t written = 0;\n  VLOG(4) << \"sending CERTIFICATE with Cert-ID=\" << certId << \"for stream=0\";\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(certData));\n  // The maximum size of an autenticator fragment, combined with the Cert-ID can\n  // not exceed the maximal allowable size of a sent frame.\n  size_t maxChunkSize = maxSendFrameSize() - sizeof(certId);\n  while (queue.chainLength() > maxChunkSize) {\n    auto chunk = queue.splitAtMost(maxChunkSize);\n    written +=\n        http2::writeCertificate(writeBuf, certId, std::move(chunk), true);\n  }\n  return written +\n         http2::writeCertificate(writeBuf, certId, queue.move(), false);\n}\n\nbool HTTP2Codec::checkConnectionError(ErrorCode err, const folly::IOBuf* buf) {\n  if (err != ErrorCode::NO_ERROR) {\n    LOG(ERROR) << \"Connection error \" << getErrorCodeString(err)\n               << \" with ingress=\";\n    VLOG(3) << IOBufPrinter::printHexFolly(buf, true);\n    if (callback_) {\n      std::string errorDescription = goawayErrorMessage_.empty() ?\n        \"Connection error\" : goawayErrorMessage_;\n      HTTPException ex(HTTPException::Direction::INGRESS_AND_EGRESS,\n                       errorDescription);\n      ex.setCodecStatusCode(err);\n      callback_->onError(0, ex, false);\n    }\n    return true;\n  }\n  return false;\n}\n\nvoid HTTP2Codec::streamError(const std::string& msg, ErrorCode code,\n                             bool newTxn) {\n  HTTPException error(HTTPException::Direction::INGRESS_AND_EGRESS,\n                      msg);\n  error.setCodecStatusCode(code);\n  if (callback_) {\n    callback_->onError(curHeader_.stream, error, newTxn);\n  }\n}\n\nHTTPCodec::StreamID\nHTTP2Codec::mapPriorityToDependency(uint8_t priority) const {\n  // If the priority is out of the maximum index of virtual nodes array, we\n  // return the lowest level virtual node as a punishment of not setting\n  // priority correctly.\n  return virtualPriorityNodes_.empty()\n    ? 0\n    : virtualPriorityNodes_[\n        std::min(priority, uint8_t(virtualPriorityNodes_.size() - 1))];\n}\n\nbool HTTP2Codec::parsingTrailers() const {\n  // HEADERS frame is used for request/response headers and trailers.\n  // Per spec, specific role of HEADERS frame is determined by it's postion\n  // within the stream. We don't keep full stream state in this codec,\n  // thus using heuristics to distinguish between headers/trailers.\n  // For DOWNSTREAM case, request headers HEADERS frame would be creating\n  // new stream, thus HEADERS on existing stream ID are considered trailers\n  // (see checkNewStream).\n  // For UPSTREAM case, response headers are required to have status code,\n  // thus if no status code we consider that trailers.\n  if (curHeader_.type == http2::FrameType::HEADERS ||\n      curHeader_.type == http2::FrameType::CONTINUATION) {\n    if (transportDirection_ == TransportDirection::DOWNSTREAM) {\n      return parsingDownstreamTrailers_;\n    } else {\n      return !decodeInfo_.hasStatus();\n    }\n  }\n  return false;\n}\n}\n", "/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n#include <proxygen/lib/http/codec/test/HTTPParallelCodecTest.h>\n#include <proxygen/lib/http/codec/test/MockHTTPCodec.h>\n#include <folly/io/Cursor.h>\n#include <proxygen/lib/http/codec/HTTP2Codec.h>\n#include <proxygen/lib/http/codec/test/HTTP2FramerTest.h>\n#include <proxygen/lib/http/HTTPHeaderSize.h>\n#include <proxygen/lib/http/HTTPMessage.h>\n\n#include <folly/portability/GTest.h>\n#include <folly/portability/GMock.h>\n#include <random>\n\nusing namespace proxygen;\nusing namespace proxygen::compress;\nusing namespace folly;\nusing namespace folly::io;\nusing namespace std;\nusing namespace testing;\n\nTEST(HTTP2CodecConstantsTest, HTTPContantsAreCommonHeaders) {\n  // The purpose of this test is to verify some basic assumptions that should\n  // never change but to make clear that the following http2 header constants\n  // map to the respective common headers.  Should this test ever fail, the\n  // H2Codec would need to be updated in the corresponding places when creating\n  // compress/Header objects.\n  EXPECT_EQ(HTTPCommonHeaders::hash(headers::kMethod),\n            HTTP_HEADER_COLON_METHOD);\n  EXPECT_EQ(HTTPCommonHeaders::hash(headers::kScheme),\n            HTTP_HEADER_COLON_SCHEME);\n  EXPECT_EQ(HTTPCommonHeaders::hash(headers::kPath),\n            HTTP_HEADER_COLON_PATH);\n  EXPECT_EQ(\n    HTTPCommonHeaders::hash(headers::kAuthority),\n    HTTP_HEADER_COLON_AUTHORITY);\n  EXPECT_EQ(HTTPCommonHeaders::hash(headers::kStatus),\n            HTTP_HEADER_COLON_STATUS);\n}\n\nclass HTTP2CodecTest : public HTTPParallelCodecTest {\n public:\n\n  HTTP2CodecTest()\n    :HTTPParallelCodecTest(upstreamCodec_, downstreamCodec_) {}\n\n  void SetUp() override {\n    HTTPParallelCodecTest::SetUp();\n  }\n  void testHeaderListSize(bool oversized);\n  void testFrameSizeLimit(bool oversized);\n\n protected:\n  HTTP2Codec upstreamCodec_{TransportDirection::UPSTREAM};\n  HTTP2Codec downstreamCodec_{TransportDirection::DOWNSTREAM};\n};\n\nTEST_F(HTTP2CodecTest, IgnoreUnknownSettings) {\n  auto numSettings = downstreamCodec_.getIngressSettings()->getNumSettings();\n  std::deque<SettingPair> settings;\n  for (uint32_t i = 200; i < (200 + 1024); i++) {\n    settings.push_back(SettingPair(SettingsId(i), i));\n  }\n  http2::writeSettings(output_, settings);\n  parse();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_EQ(numSettings,\n            downstreamCodec_.getIngressSettings()->getNumSettings());\n}\n\nTEST_F(HTTP2CodecTest, NoExHeaders) {\n  // do not emit ENABLE_EX_HEADERS setting, if disabled\n  SetUpUpstreamTest();\n\n  EXPECT_EQ(callbacks_.settings, 0);\n  EXPECT_EQ(callbacks_.numSettings, 0);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n\n  parseUpstream();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  // only 3 standard settings: HEADER_TABLE_SIZE, ENABLE_PUSH, MAX_FRAME_SIZE.\n  EXPECT_EQ(callbacks_.numSettings, 3);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n}\n\nTEST_F(HTTP2CodecTest, IgnoreExHeadersSetting) {\n  // disable EX_HEADERS on egress\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 0);\n  auto ptr = downstreamCodec_.getEgressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(0, ptr->value);\n\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(nullptr, ptr);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n\n  // attempt to enable EX_HEADERS on ingress\n  http2::writeSettings(output_,\n                      {SettingPair(SettingsId::ENABLE_EX_HEADERS, 1)});\n  parse();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(nullptr, ptr);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n\n  // attempt to disable EX_HEADERS on ingress\n  callbacks_.reset();\n  http2::writeSettings(output_,\n                      {SettingPair(SettingsId::ENABLE_EX_HEADERS, 0)});\n  parse();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(nullptr, ptr);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n}\n\nTEST_F(HTTP2CodecTest, EnableExHeadersSetting) {\n  // enable EX_HEADERS on egress\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n\n  auto ptr = downstreamCodec_.getEgressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(1, ptr->value);\n\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(nullptr, ptr);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n\n  // attempt to enable EX_HEADERS on ingress\n  http2::writeSettings(output_,\n                      {SettingPair(SettingsId::ENABLE_EX_HEADERS, 1)});\n  parse();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(1, ptr->value);\n  EXPECT_EQ(true, downstreamCodec_.supportsExTransactions());\n\n  // attempt to disable EX_HEADERS on ingress\n  callbacks_.reset();\n  http2::writeSettings(output_,\n                      {SettingPair(SettingsId::ENABLE_EX_HEADERS, 0)});\n  parse();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(0, ptr->value);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n}\n\nTEST_F(HTTP2CodecTest, InvalidExHeadersSetting) {\n  // enable EX_HEADERS on egress\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n\n  // attempt to set a invalid ENABLE_EX_HEADERS value\n  http2::writeSettings(output_,\n                      {SettingPair(SettingsId::ENABLE_EX_HEADERS, 110)});\n  parse();\n\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, BasicHeader) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  req.getHeaders().add(\"tab-hdr\", \"coolio\\tv2\");\n  // Connection header will get dropped\n  req.getHeaders().add(HTTP_HEADER_CONNECTION, \"Love\");\n  req.setSecure(true);\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  parse();\n  callbacks_.expectMessage(true, 3, \"/guacamole\");\n  EXPECT_TRUE(callbacks_.msg->isSecure());\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(\"coolio\", headers.getSingleOrEmpty(HTTP_HEADER_USER_AGENT));\n  EXPECT_EQ(\"coolio\\tv2\", headers.getSingleOrEmpty(\"tab-hdr\"));\n  EXPECT_EQ(\"www.foo.com\", headers.getSingleOrEmpty(HTTP_HEADER_HOST));\n}\n\nTEST_F(HTTP2CodecTest, RequestFromServer) {\n  // this is to test EX_HEADERS frame, which carrys the HTTP request initiated\n  // by server side\n  upstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n  SetUpUpstreamTest();\n  proxygen::http2::writeSettings(\n      output_, {{proxygen::SettingsId::ENABLE_EX_HEADERS, 1}});\n\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  req.getHeaders().add(\"tab-hdr\", \"coolio\\tv2\");\n  // Connection header will get dropped\n  req.getHeaders().add(HTTP_HEADER_CONNECTION, \"Love\");\n  req.setSecure(true);\n\n  HTTPCodec::StreamID stream = folly::Random::rand32(10, 1024) * 2;\n  HTTPCodec::StreamID controlStream = folly::Random::rand32(10, 1024) * 2 + 1;\n  upstreamCodec_.generateExHeader(output_, stream, req,\n                                  HTTPCodec::ExAttributes(controlStream, true),\n                                  true);\n\n  parseUpstream();\n  EXPECT_EQ(controlStream, callbacks_.controlStreamId);\n  EXPECT_TRUE(callbacks_.isUnidirectional);\n  callbacks_.expectMessage(true, 3, \"/guacamole\");\n  EXPECT_TRUE(callbacks_.msg->isSecure());\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(\"coolio\", headers.getSingleOrEmpty(HTTP_HEADER_USER_AGENT));\n  EXPECT_EQ(\"coolio\\tv2\", headers.getSingleOrEmpty(\"tab-hdr\"));\n  EXPECT_EQ(\"www.foo.com\", headers.getSingleOrEmpty(HTTP_HEADER_HOST));\n}\n\nTEST_F(HTTP2CodecTest, ResponseFromClient) {\n  // this is to test EX_HEADERS frame, which carrys the HTTP response replied by\n  // client side\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n  proxygen::http2::writeSettings(\n      output_, {{proxygen::SettingsId::ENABLE_EX_HEADERS, 1}});\n\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n\n  HTTPCodec::StreamID stream = folly::Random::rand32(10, 1024) * 2;\n  HTTPCodec::StreamID controlStream = folly::Random::rand32(10, 1024) * 2 + 1;\n  downstreamCodec_.generateExHeader(output_, stream, resp,\n    HTTPCodec::ExAttributes(controlStream, true), true);\n\n  parse();\n  EXPECT_EQ(controlStream, callbacks_.controlStreamId);\n  EXPECT_TRUE(callbacks_.isUnidirectional);\n  EXPECT_EQ(\"OK\", callbacks_.msg->getStatusMessage());\n  callbacks_.expectMessage(true, 2, 200);\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(\"OK\", callbacks_.msg->getStatusMessage());\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n}\n\nTEST_F(HTTP2CodecTest, ExHeadersWithPriority) {\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n  proxygen::http2::writeSettings(\n      output_, {{proxygen::SettingsId::ENABLE_EX_HEADERS, 1}});\n\n  auto req = getGetRequest();\n  auto pri = HTTPMessage::HTTPPriority(0, false, 7);\n  req.setHTTP2Priority(pri);\n  upstreamCodec_.generateExHeader(output_, 3, req,\n                                  HTTPCodec::ExAttributes(1, true));\n\n  parse();\n  EXPECT_EQ(callbacks_.msg->getHTTP2Priority(), pri);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, IgnoreExHeadersIfNotEnabled) {\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 0);\n\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  downstreamCodec_.generateExHeader(output_, 3, req,\n                                    HTTPCodec::ExAttributes(1, true));\n\n  parse();\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadHeaders) {\n  static const std::string v1(\"GET\");\n  static const std::string v2(\"/\");\n  static const std::string v3(\"http\");\n  static const std::string v4(\"foo.com\");\n  static const vector<proxygen::compress::Header> reqHeaders = {\n    Header::makeHeaderForTest(headers::kMethod, v1),\n    Header::makeHeaderForTest(headers::kPath, v2),\n    Header::makeHeaderForTest(headers::kScheme, v3),\n    Header::makeHeaderForTest(headers::kAuthority, v4),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  HTTPCodec::StreamID stream = 1;\n  // missing fields (missing authority is OK)\n  for (size_t i = 0; i < reqHeaders.size(); i++, stream += 2) {\n    std::vector<proxygen::compress::Header> allHeaders = reqHeaders;\n    allHeaders.erase(allHeaders.begin() + i);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n  // dup fields\n  std::string v(\"foomonkey\");\n  for (size_t i = 0; i < reqHeaders.size(); i++, stream += 2) {\n    std::vector<proxygen::compress::Header> allHeaders = reqHeaders;\n    auto h = allHeaders[i];\n    h.value = &v;\n    allHeaders.push_back(h);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 7);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadPseudoHeaders) {\n  static const std::string v1(\"POST\");\n  static const std::string v2(\"http\");\n  static const std::string n3(\"foo\");\n  static const std::string v3(\"bar\");\n  static const std::string v4(\"/\");\n  static const vector<proxygen::compress::Header> reqHeaders = {\n    Header::makeHeaderForTest(headers::kMethod, v1),\n    Header::makeHeaderForTest(headers::kScheme, v2),\n    Header::makeHeaderForTest(n3, v3),\n    Header::makeHeaderForTest(headers::kPath, v4),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  HTTPCodec::StreamID stream = 1;\n  std::vector<proxygen::compress::Header> allHeaders = reqHeaders;\n  auto encodedHeaders = headerCodec.encode(allHeaders);\n  http2::writeHeaders(output_,\n                      std::move(encodedHeaders),\n                      stream,\n                      folly::none,\n                      http2::kNoPadding,\n                      true,\n                      true);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadHeaderValues) {\n  static const std::string v1(\"--1\");\n  static const std::string v2(\"\\13\\10protocol-attack\");\n  static const std::string v3(\"\\13\");\n  static const std::string v4(\"abc.com\\\\13\\\\10\");\n  static const vector<proxygen::compress::Header> reqHeaders = {\n    Header::makeHeaderForTest(headers::kMethod, v1),\n    Header::makeHeaderForTest(headers::kPath, v2),\n    Header::makeHeaderForTest(headers::kScheme, v3),\n    Header::makeHeaderForTest(headers::kAuthority, v4),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  HTTPCodec::StreamID stream = 1;\n  for (size_t i = 0; i < reqHeaders.size(); i++, stream += 2) {\n    std::vector<proxygen::compress::Header> allHeaders;\n    allHeaders.push_back(reqHeaders[i]);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 4);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\n/**\n * Ingress bytes with an empty header name\n */\nconst uint8_t kBufEmptyHeader[] = {\n  0x00, 0x00, 0x1d, 0x01, 0x04, 0x00, 0x00, 0x00, 0x01, 0x82,\n  0x87, 0x44, 0x87, 0x62, 0x6b, 0x46, 0x41, 0xd2, 0x7a, 0x0b,\n  0x41, 0x89, 0xf1, 0xe3, 0xc2, 0xf2, 0x9c, 0xeb, 0x90, 0xf4,\n  0xff, 0x40, 0x80, 0x84, 0x2d, 0x35, 0xa7, 0xd7\n};\n\nTEST_F(HTTP2CodecTest, EmptyHeaderName) {\n  output_.append(IOBuf::copyBuffer(kBufEmptyHeader, sizeof(kBufEmptyHeader)));\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicConnect) {\n  std::string authority = \"myhost:1234\";\n  HTTPMessage request;\n  request.setMethod(HTTPMethod::CONNECT);\n  request.getHeaders().add(proxygen::HTTP_HEADER_HOST, authority);\n  upstreamCodec_.generateHeader(output_, 1, request, false /* eom */);\n\n  parse();\n  callbacks_.expectMessage(false, 1, \"\");\n  EXPECT_EQ(HTTPMethod::CONNECT, callbacks_.msg->getMethod());\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(authority, headers.getSingleOrEmpty(proxygen::HTTP_HEADER_HOST));\n}\n\nTEST_F(HTTP2CodecTest, BadConnect) {\n  std::string v1 = \"CONNECT\";\n  std::string v2 = \"somehost:576\";\n  std::vector<proxygen::compress::Header> goodHeaders = {\n    Header::makeHeaderForTest(headers::kMethod, v1),\n    Header::makeHeaderForTest(headers::kAuthority, v2),\n  };\n\n  // See https://tools.ietf.org/html/rfc7540#section-8.3\n  std::string v3 = \"/foobar\";\n  std::vector<proxygen::compress::Header> badHeaders = {\n    Header::makeHeaderForTest(headers::kScheme, headers::kHttp),\n    Header::makeHeaderForTest(headers::kPath, v3),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  HTTPCodec::StreamID stream = 1;\n\n  for (size_t i = 0; i < badHeaders.size(); i++, stream += 2) {\n    auto allHeaders = goodHeaders;\n    allHeaders.push_back(badHeaders[i]);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, badHeaders.size());\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nvoid HTTP2CodecTest::testHeaderListSize(bool oversized) {\n  if (oversized) {\n    auto settings = downstreamCodec_.getEgressSettings();\n    settings->setSetting(SettingsId::MAX_HEADER_LIST_SIZE, 37);\n  }\n\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  req.getHeaders().add(\"x-long-long-header\",\n                       \"supercalafragalisticexpialadoshus\");\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  parse();\n  // session error\n  EXPECT_EQ(callbacks_.messageBegin, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.headersComplete, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.messageComplete, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, oversized ? 1 : 0);\n}\n\nvoid HTTP2CodecTest::testFrameSizeLimit(bool oversized) {\n  HTTPMessage req = getBigGetRequest(\"/guacamole\");\n  auto settings = downstreamCodec_.getEgressSettings();\n\n  parse(); // consume preface\n  if (oversized) {\n    // trick upstream for sending a 2x bigger HEADERS frame\n    settings->setSetting(SettingsId::MAX_FRAME_SIZE,\n                         http2::kMaxFramePayloadLengthMin * 2);\n    downstreamCodec_.generateSettings(output_);\n    parseUpstream();\n  }\n\n  settings->setSetting(SettingsId::MAX_FRAME_SIZE,\n                       http2::kMaxFramePayloadLengthMin);\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  parse();\n  // session error\n  EXPECT_EQ(callbacks_.messageBegin, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.headersComplete, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.messageComplete, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, oversized ? 1 : 0);\n}\n\nTEST_F(HTTP2CodecTest, NormalSizeHeader) {\n  testHeaderListSize(false);\n}\n\nTEST_F(HTTP2CodecTest, OversizedHeader) {\n  testHeaderListSize(true);\n}\n\nTEST_F(HTTP2CodecTest, NormalSizeFrame) {\n  testFrameSizeLimit(false);\n}\n\nTEST_F(HTTP2CodecTest, OversizedFrame) {\n  testFrameSizeLimit(true);\n}\n\nTEST_F(HTTP2CodecTest, BigHeaderCompressed) {\n  SetUpUpstreamTest();\n  auto settings = downstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::MAX_HEADER_LIST_SIZE, 37);\n  downstreamCodec_.generateSettings(output_);\n  parseUpstream();\n\n  SetUp();\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  parse();\n  // session error\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\n\nTEST_F(HTTP2CodecTest, BasicHeaderReply) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n  downstreamCodec_.generateEOM(output_, 1);\n\n  parseUpstream();\n  callbacks_.expectMessage(true, 2, 200);\n  const auto& headers = callbacks_.msg->getHeaders();\n  // HTTP/2 doesnt support serialization - instead you get the default\n  EXPECT_EQ(\"OK\", callbacks_.msg->getStatusMessage());\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n}\n\nTEST_F(HTTP2CodecTest, BadHeadersReply) {\n  static const std::string v1(\"200\");\n  static const vector<proxygen::compress::Header> respHeaders = {\n    Header::makeHeaderForTest(headers::kStatus, v1),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::DOWNSTREAM);\n  HTTPCodec::StreamID stream = 1;\n  // missing fields (missing authority is OK)\n  for (size_t i = 0; i < respHeaders.size(); i++, stream += 2) {\n    std::vector<proxygen::compress::Header> allHeaders = respHeaders;\n    allHeaders.erase(allHeaders.begin() + i);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n  // dup fields\n  std::string v(\"foomonkey\");\n  for (size_t i = 0; i < respHeaders.size(); i++, stream += 2) {\n    std::vector<proxygen::compress::Header> allHeaders = respHeaders;\n    auto h = allHeaders[i];\n    h.value = &v;\n    allHeaders.push_back(h);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 2);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, Cookies) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(\"Cookie\", \"chocolate-chip=1\");\n  req.getHeaders().add(\"Cookie\", \"rainbow-chip=2\");\n  req.getHeaders().add(\"Cookie\", \"butterscotch=3\");\n  req.getHeaders().add(\"Cookie\", \"oatmeal-raisin=4\");\n  req.setSecure(true);\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  parse();\n  callbacks_.expectMessage(false, 2, \"/guacamole\");\n  EXPECT_EQ(callbacks_.msg->getCookie(\"chocolate-chip\"), \"1\");\n  EXPECT_EQ(callbacks_.msg->getCookie(\"rainbow-chip\"), \"2\");\n  EXPECT_EQ(callbacks_.msg->getCookie(\"butterscotch\"), \"3\");\n  EXPECT_EQ(callbacks_.msg->getCookie(\"oatmeal-raisin\"), \"4\");\n}\n\nTEST_F(HTTP2CodecTest, BasicContinuation) {\n  HTTPMessage req = getBigGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  parse();\n  callbacks_.expectMessage(false, -1, \"/\");\n#ifndef NDEBUG\n  EXPECT_GT(downstreamCodec_.getReceivedFrameCount(), 1);\n#endif\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(\"coolio\", headers.getSingleOrEmpty(HTTP_HEADER_USER_AGENT));\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicContinuationEndStream) {\n  // CONTINUATION with END_STREAM flag set on the preceding HEADERS frame\n  HTTPMessage req = getBigGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  parse();\n  callbacks_.expectMessage(true, -1, \"/\");\n#ifndef NDEBUG\n  EXPECT_GT(downstreamCodec_.getReceivedFrameCount(), 1);\n#endif\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(\"coolio\", headers.getSingleOrEmpty(HTTP_HEADER_USER_AGENT));\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadContinuation) {\n  // CONTINUATION with no preceding HEADERS\n  auto fakeHeaders = makeBuf(5);\n  http2::writeContinuation(output_, 3, true, std::move(fakeHeaders));\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, MissingContinuation) {\n  IOBufQueue output(IOBufQueue::cacheChainLength());\n  HTTPMessage req = getBigGetRequest();\n\n  upstreamCodec_.generateHeader(output_, 1, req);\n  // empirically determined the size of continuation frame, and strip it\n  output_.trimEnd(http2::kFrameHeaderSize + 4134);\n\n  // insert a non-continuation (but otherwise valid) frame\n  http2::writeGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 2);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, MissingContinuationBadFrame) {\n  IOBufQueue output(IOBufQueue::cacheChainLength());\n  HTTPMessage req = getBigGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  // empirically determined the size of continuation frame, and fake it\n  output_.trimEnd(http2::kFrameHeaderSize + 4134);\n\n  // insert an invalid frame\n  auto frame = makeBuf(http2::kFrameHeaderSize + 4134);\n  *((uint32_t *)frame->writableData()) = 0xfa000000;\n  output_.append(std::move(frame));\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 2);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, BadContinuationStream) {\n  HTTPMessage req = getBigGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  // empirically determined the size of continuation frame, and fake it\n  output_.trimEnd(http2::kFrameHeaderSize + 4134);\n  auto fakeHeaders = makeBuf(4134);\n  http2::writeContinuation(output_, 3, true, std::move(fakeHeaders));\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 2);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, FrameTooLarge) {\n  writeFrameHeaderManual(output_, 1 << 15, 0, 0, 1);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n  EXPECT_TRUE(callbacks_.lastParseError->hasCodecStatusCode());\n  EXPECT_EQ(callbacks_.lastParseError->getCodecStatusCode(),\n            ErrorCode::FRAME_SIZE_ERROR);\n}\n\nTEST_F(HTTP2CodecTest, UnknownFrameType) {\n  HTTPMessage req = getGetRequest();\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n\n  // unknown frame type 17\n  writeFrameHeaderManual(output_, 17, 37, 0, 1);\n  output_.append(\"wicked awesome!!!\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  parse();\n  callbacks_.expectMessage(false, 2, \"\"); // + host\n}\n\nTEST_F(HTTP2CodecTest, JunkAfterConnError) {\n  HTTPMessage req = getGetRequest();\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n\n  // write headers frame for stream 0\n  writeFrameHeaderManual(output_, 0, (uint8_t)http2::FrameType::HEADERS, 0, 0);\n  // now write a valid headers frame, should never be parsed\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, BasicData) {\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  upstreamCodec_.generateBody(output_, 2, std::move(buf),\n                              HTTPCodec::NoPadding, true);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, 5);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), data);\n}\n\nTEST_F(HTTP2CodecTest, LongData) {\n  // Hack the max frame size artificially low\n  HTTPSettings* settings = (HTTPSettings*)upstreamCodec_.getIngressSettings();\n  settings->setSetting(SettingsId::MAX_FRAME_SIZE, 16);\n  auto buf = makeBuf(100);\n  upstreamCodec_.generateBody(output_, 1, buf->clone(), HTTPCodec::NoPadding,\n                              true);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 7);\n  EXPECT_EQ(callbacks_.bodyLength, 100);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), buf->moveToFbString());\n}\n\nTEST_F(HTTP2CodecTest, MalformedPaddingLength) {\n  const uint8_t badInput[] = {0x50, 0x52, 0x49, 0x20, 0x2a, 0x20, 0x48, 0x54,\n                              0x54, 0x50, 0x2f, 0x32, 0x2e, 0x30, 0x0d, 0x0a,\n                              0x0d, 0x0a, 0x53, 0x4d, 0x0d, 0x0a, 0x0d, 0x0a,\n                              0x00, 0x00, 0x7e, 0x00, 0x6f, 0x6f, 0x6f, 0x6f,\n                              // The padding length byte below is 0x82 (130\n                              // in decimal) which is greater than the length\n                              // specified by the header's length field, 126\n                              0x01, 0x82, 0x87, 0x44, 0x87, 0x92, 0x97, 0x92,\n                              0x92, 0x92, 0x7a, 0x0b, 0x41, 0x89, 0xf1, 0xe3,\n                              0xc0, 0xf2, 0x9c, 0xdd, 0x90, 0xf4, 0xff, 0x40,\n                              0x80, 0x84, 0x2d, 0x35, 0xa7, 0xd7};\n  output_.clear();\n  output_.append(badInput, sizeof(badInput));\n  EXPECT_EQ(output_.chainLength(), sizeof(badInput));\n\n  EXPECT_FALSE(parse());\n}\n\nTEST_F(HTTP2CodecTest, MalformedPadding) {\n  const uint8_t badInput[] = {\n    0x00, 0x00, 0x0d, 0x01, 0xbe, 0x63, 0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x73,\n    0x00, 0x00, 0x06, 0x08, 0x72, 0x00, 0x24, 0x00, 0xfa, 0x4d, 0x0d\n  };\n  output_.append(badInput, sizeof(badInput));\n\n  EXPECT_FALSE(parse());\n}\n\nTEST_F(HTTP2CodecTest, NoAppByte) {\n  const uint8_t noAppByte[] = {0x50, 0x52, 0x49, 0x20, 0x2a, 0x20, 0x48, 0x54,\n                               0x54, 0x50, 0x2f, 0x32, 0x2e, 0x30, 0x0d, 0x0a,\n                               0x0d, 0x0a, 0x53, 0x4d, 0x0d, 0x0a, 0x0d, 0x0a,\n                               0x00, 0x00, 0x56, 0x00, 0x5d, 0x00, 0x00, 0x00,\n                               0x01, 0x55, 0x00};\n  output_.clear();\n  output_.append(noAppByte, sizeof(noAppByte));\n  EXPECT_EQ(output_.chainLength(), sizeof(noAppByte));\n\n  EXPECT_TRUE(parse());\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, DataFramePartialDataOnFrameHeaderCall) {\n  using namespace testing;\n  NiceMock<MockHTTPCodecCallback> mockCallback;\n  EXPECT_CALL(mockCallback, onFrameHeader(_, _, _, _, _));\n\n  const size_t bufSize = 10;\n  auto buf = makeBuf(bufSize);\n  const size_t padding = 10;\n  upstreamCodec_.generateBody(output_, 1, buf->clone(), padding, true);\n  EXPECT_EQ(output_.chainLength(), 54);\n\n  downstreamCodec_.setCallback(&mockCallback);\n\n  auto ingress = output_.move();\n  ingress->coalesce();\n  // Copy partial byte to a new buffer\n  auto ingress1 = IOBuf::copyBuffer(ingress->data(), 34);\n  downstreamCodec_.onIngress(*ingress1);\n}\n\nTEST_F(HTTP2CodecTest, DataFramePartialDataWithNoAppByte) {\n  const size_t bufSize = 10;\n  auto buf = makeBuf(bufSize);\n  const size_t padding = 10;\n  upstreamCodec_.generateBody(output_, 1, buf->clone(), padding, true);\n  EXPECT_EQ(output_.chainLength(), 54);\n\n  auto ingress = output_.move();\n  ingress->coalesce();\n  // Copy up to the padding length byte to a new buffer\n  auto ingress1 = IOBuf::copyBuffer(ingress->data(), 34);\n  size_t parsed = downstreamCodec_.onIngress(*ingress1);\n  // The 34th byte is the padding length byte which should not be parsed\n  EXPECT_EQ(parsed, 33);\n  // Copy from the padding length byte to the end\n  auto ingress2 = IOBuf::copyBuffer(ingress->data() + 33, 21);\n  parsed = downstreamCodec_.onIngress(*ingress2);\n  // The padding length byte should be parsed this time along with 10 bytes of\n  // application data and 10 bytes of padding\n  EXPECT_EQ(parsed, 21);\n\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, bufSize);\n  // Total padding is the padding length byte and the padding bytes\n  EXPECT_EQ(callbacks_.paddingBytes, padding + 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), buf->moveToFbString());\n}\n\nTEST_F(HTTP2CodecTest, BasicRst) {\n  upstreamCodec_.generateRstStream(output_, 2, ErrorCode::ENHANCE_YOUR_CALM);\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.aborts, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicRstInvalidCode) {\n  upstreamCodec_.generateRstStream(output_, 2, ErrorCode::_SPDY_INVALID_STREAM);\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.aborts, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicPing) {\n  upstreamCodec_.generatePingRequest(output_);\n  upstreamCodec_.generatePingReply(output_, 17);\n\n  uint64_t pingReq;\n  parse([&] (IOBuf* ingress) {\n      folly::io::Cursor c(ingress);\n      c.skip(http2::kFrameHeaderSize + http2::kConnectionPreface.length());\n      pingReq = c.read<uint64_t>();\n    });\n\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.recvPingRequest, pingReq);\n  EXPECT_EQ(callbacks_.recvPingReply, 17);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicWindow) {\n  // This test would fail if the codec had window state\n  upstreamCodec_.generateWindowUpdate(output_, 0, 10);\n  upstreamCodec_.generateWindowUpdate(output_, 0, http2::kMaxWindowUpdateSize);\n  upstreamCodec_.generateWindowUpdate(output_, 1, 12);\n  upstreamCodec_.generateWindowUpdate(output_, 1, http2::kMaxWindowUpdateSize);\n\n  parse();\n  EXPECT_EQ(callbacks_.windowUpdateCalls, 4);\n  EXPECT_EQ(callbacks_.windowUpdates[0],\n            std::vector<uint32_t>({10, http2::kMaxWindowUpdateSize}));\n  EXPECT_EQ(callbacks_.windowUpdates[1],\n            std::vector<uint32_t>({12, http2::kMaxWindowUpdateSize}));\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, ZeroWindow) {\n  auto streamID = HTTPCodec::StreamID(1);\n  // First generate a frame with delta=1 so as to pass the checks, and then\n  // hack the frame so that delta=0 without modifying other checks\n  upstreamCodec_.generateWindowUpdate(output_, streamID, 1);\n  output_.trimEnd(http2::kFrameWindowUpdateSize);\n  QueueAppender appender(&output_, http2::kFrameWindowUpdateSize);\n  appender.writeBE<uint32_t>(0);\n\n  parse();\n  // This test doesn't ensure that RST_STREAM is generated\n  EXPECT_EQ(callbacks_.windowUpdateCalls, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.lastParseError->getCodecStatusCode(),\n      ErrorCode::PROTOCOL_ERROR);\n}\n\nTEST_F(HTTP2CodecTest, BasicGoaway) {\n  std::unique_ptr<folly::IOBuf> debugData =\n    folly::IOBuf::copyBuffer(\"debugData\");\n  upstreamCodec_.generateGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM,\n                                std::move(debugData));\n\n  parse();\n  EXPECT_EQ(callbacks_.goaways, 1);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), \"debugData\");\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadGoaway) {\n  std::unique_ptr<folly::IOBuf> debugData =\n    folly::IOBuf::copyBuffer(\"debugData\");\n  upstreamCodec_.generateGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM,\n                                std::move(debugData));\n  EXPECT_DEATH_NO_CORE(upstreamCodec_.generateGoaway(\n                         output_, 27, ErrorCode::ENHANCE_YOUR_CALM), \".*\");\n}\n\nTEST_F(HTTP2CodecTest, DoubleGoaway) {\n  parse();\n  SetUpUpstreamTest();\n  downstreamCodec_.generateGoaway(output_, std::numeric_limits<int32_t>::max(),\n                                  ErrorCode::NO_ERROR);\n  EXPECT_TRUE(downstreamCodec_.isWaitingToDrain());\n  EXPECT_TRUE(downstreamCodec_.isReusable());\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(2));\n  downstreamCodec_.generateGoaway(output_, 0, ErrorCode::NO_ERROR);\n  EXPECT_FALSE(downstreamCodec_.isWaitingToDrain());\n  EXPECT_FALSE(downstreamCodec_.isReusable());\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_FALSE(downstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(2));\n\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(2));\n  parseUpstream();\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_FALSE(upstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(2));\n  EXPECT_EQ(callbacks_.goaways, 2);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n\n  upstreamCodec_.generateGoaway(output_, 0, ErrorCode::NO_ERROR);\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_FALSE(upstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_FALSE(upstreamCodec_.isStreamIngressEgressAllowed(2));\n  parse();\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_FALSE(downstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_FALSE(downstreamCodec_.isStreamIngressEgressAllowed(2));\n}\n\nTEST_F(HTTP2CodecTest, DoubleGoawayWithError) {\n  SetUpUpstreamTest();\n  std::unique_ptr<folly::IOBuf> debugData =\n    folly::IOBuf::copyBuffer(\"debugData\");\n  downstreamCodec_.generateGoaway(output_, std::numeric_limits<int32_t>::max(),\n                                  ErrorCode::ENHANCE_YOUR_CALM,\n                                  std::move(debugData));\n  EXPECT_FALSE(downstreamCodec_.isWaitingToDrain());\n  EXPECT_FALSE(downstreamCodec_.isReusable());\n  auto ret = downstreamCodec_.generateGoaway(output_, 0,\n                                             ErrorCode::NO_ERROR);\n  EXPECT_EQ(ret, 0);\n\n  parseUpstream();\n  EXPECT_EQ(callbacks_.goaways, 1);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), \"debugData\");\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, GoawayHandling) {\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::ENABLE_PUSH, 1);\n  upstreamCodec_.generateSettings(output_);\n\n  // send request\n  HTTPMessage req = getGetRequest();\n  HTTPHeaderSize size;\n  size.uncompressed = size.compressed = 0;\n  upstreamCodec_.generateHeader(output_, 1, req, true, &size);\n  EXPECT_GT(size.uncompressed, 0);\n  parse();\n  callbacks_.expectMessage(true, 1, \"/\");\n  callbacks_.reset();\n\n  SetUpUpstreamTest();\n  // drain after this message\n  downstreamCodec_.generateGoaway(output_, 1, ErrorCode::NO_ERROR);\n  parseUpstream();\n  // upstream cannot generate id > 1\n  upstreamCodec_.generateHeader(output_, 3, req, false, &size);\n  EXPECT_EQ(size.uncompressed, 0);\n  upstreamCodec_.generateWindowUpdate(output_, 3, 100);\n  upstreamCodec_.generateBody(output_, 3, makeBuf(10), HTTPCodec::NoPadding,\n                              false);\n  upstreamCodec_.generatePriority(output_, 3,\n                                  HTTPMessage::HTTPPriority(0, true, 1));\n  upstreamCodec_.generateEOM(output_, 3);\n  upstreamCodec_.generateRstStream(output_, 3, ErrorCode::CANCEL);\n  EXPECT_EQ(output_.chainLength(), 0);\n\n  // send a push promise that will be rejected by downstream\n  req.getHeaders().add(\"foomonkey\", \"george\");\n  downstreamCodec_.generatePushPromise(output_, 2, req, 1, false, &size);\n  EXPECT_GT(size.uncompressed, 0);\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  // send a push response that will be ignored\n  downstreamCodec_.generateHeader(output_, 2, resp, false, &size);\n  // window update for push doesn't make any sense, but whatever\n  downstreamCodec_.generateWindowUpdate(output_, 2, 100);\n  downstreamCodec_.generateBody(output_, 2, makeBuf(10), HTTPCodec::NoPadding,\n                                false);\n  writeFrameHeaderManual(output_, 20, (uint8_t)http2::FrameType::DATA, 0, 2);\n  output_.append(makeBuf(10));\n\n  // tell the upstream no pushing, and parse the first batch\n  IOBufQueue dummy;\n  upstreamCodec_.generateGoaway(dummy, 0, ErrorCode::NO_ERROR);\n  parseUpstream();\n\n  output_.append(makeBuf(10));\n  downstreamCodec_.generatePriority(output_, 2,\n                                    HTTPMessage::HTTPPriority(0, true, 1));\n  downstreamCodec_.generateEOM(output_, 2);\n  downstreamCodec_.generateRstStream(output_, 2, ErrorCode::CANCEL);\n\n  // send a response that will be accepted, headers should be ok\n  downstreamCodec_.generateHeader(output_, 1, resp, true, &size);\n  EXPECT_GT(size.uncompressed, 0);\n\n  // parse the remainder\n  parseUpstream();\n  callbacks_.expectMessage(true, 1, 200);\n}\n\nTEST_F(HTTP2CodecTest, GoawayReply) {\n  upstreamCodec_.generateGoaway(output_, 0, ErrorCode::NO_ERROR);\n\n  parse();\n  EXPECT_EQ(callbacks_.goaways, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n  downstreamCodec_.generateEOM(output_, 1);\n  parseUpstream();\n  callbacks_.expectMessage(true, 1, 200);\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n}\n\nTEST_F(HTTP2CodecTest, BasicSetting) {\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::MAX_CONCURRENT_STREAMS, 37);\n  settings->setSetting(SettingsId::INITIAL_WINDOW_SIZE, 12345);\n  upstreamCodec_.generateSettings(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.maxStreams, 37);\n  EXPECT_EQ(callbacks_.windowSize, 12345);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, SettingsAck) {\n  upstreamCodec_.generateSettingsAck(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 0);\n  EXPECT_EQ(callbacks_.settingsAcks, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadSettings) {\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::INITIAL_WINDOW_SIZE, 0xffffffff);\n  upstreamCodec_.generateSettings(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, BadPushSettings) {\n  auto settings = downstreamCodec_.getEgressSettings();\n  settings->clearSettings();\n  settings->setSetting(SettingsId::ENABLE_PUSH, 0);\n  SetUpUpstreamTest();\n\n  parseUpstream([&] (IOBuf* ingress) {\n      EXPECT_EQ(ingress->computeChainDataLength(), http2::kFrameHeaderSize);\n    });\n  EXPECT_FALSE(upstreamCodec_.supportsPushTransactions());\n  // Only way to disable push for downstreamCodec_ is to read\n  // ENABLE_PUSH:0 from client\n  EXPECT_TRUE(downstreamCodec_.supportsPushTransactions());\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\n\nTEST_F(HTTP2CodecTest, SettingsTableSize) {\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::HEADER_TABLE_SIZE, 8192);\n  upstreamCodec_.generateSettings(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  downstreamCodec_.generateSettingsAck(output_);\n  parseUpstream();\n\n  callbacks_.reset();\n\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  SetUpUpstreamTest();\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  parseUpstream();\n  callbacks_.expectMessage(false, 2, 200);\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n}\n\nTEST_F(HTTP2CodecTest, BadSettingsTableSize) {\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::HEADER_TABLE_SIZE, 8192);\n  // This sets the max decoder table size to 8k\n  upstreamCodec_.generateSettings(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n\n  callbacks_.reset();\n\n  // Attempt to set a new max table size.  This is a no-op because the first,\n  // setting is unacknowledged.  The upstream encoder will up the table size to\n  // 8k per the first settings frame and the HPACK codec will send a code to\n  // update the decoder.\n  settings->setSetting(SettingsId::HEADER_TABLE_SIZE, 4096);\n\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  SetUpUpstreamTest();\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  parseUpstream();\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n}\n\nTEST_F(HTTP2CodecTest, SettingsTableSizeEarlyShrink) {\n  // Lower size to 2k\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::HEADER_TABLE_SIZE, 2048);\n  upstreamCodec_.generateSettings(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  downstreamCodec_.generateSettingsAck(output_);\n  // Parsing SETTINGS ack updates upstream decoder to 2k\n  parseUpstream();\n\n  callbacks_.reset();\n\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  SetUpUpstreamTest();\n  // downstream encoder will send TSU/2k\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  // sets pending table size to 512, but doesn't update it yet\n  settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::HEADER_TABLE_SIZE, 512);\n  IOBufQueue tmp{IOBufQueue::cacheChainLength()};\n  upstreamCodec_.generateSettings(tmp);\n\n  // Previous code would barf here, since TSU/2k is a violation of the current\n  // max=512\n  parseUpstream();\n  callbacks_.expectMessage(false, 2, 200);\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n}\n\nTEST_F(HTTP2CodecTest, BasicPriority) {\n  auto pri = HTTPMessage::HTTPPriority(0, true, 1);\n  upstreamCodec_.generatePriority(output_, 1, pri);\n\n  EXPECT_TRUE(parse());\n  EXPECT_EQ(callbacks_.priority, pri);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadHeaderPriority) {\n  HTTPMessage req = getGetRequest();\n  req.setHTTP2Priority(HTTPMessage::HTTPPriority(0, false, 7));\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  // hack ingress with cirular dep\n  EXPECT_TRUE(parse([&] (IOBuf* ingress) {\n        folly::io::RWPrivateCursor c(ingress);\n        c.skip(http2::kFrameHeaderSize + http2::kConnectionPreface.length());\n        c.writeBE<uint32_t>(1);\n      }));\n\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, DuplicateBadHeaderPriority) {\n  // Sent an initial header with a circular dependency\n  HTTPMessage req = getGetRequest();\n  req.setHTTP2Priority(HTTPMessage::HTTPPriority(0, false, 7));\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  // Hack ingress with circular dependency.\n  EXPECT_TRUE(parse([&](IOBuf* ingress) {\n    folly::io::RWPrivateCursor c(ingress);\n    c.skip(http2::kFrameHeaderSize + http2::kConnectionPreface.length());\n    c.writeBE<uint32_t>(1);\n  }));\n\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n\n  // On the same stream, send another request.\n  HTTPMessage nextRequest = getGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, nextRequest, true /* eom */);\n  parse();\n  EXPECT_EQ(callbacks_.streamErrors, 2);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadPriority) {\n  auto pri = HTTPMessage::HTTPPriority(0, true, 1);\n  upstreamCodec_.generatePriority(output_, 1, pri);\n\n  // hack ingress with cirular dep\n  EXPECT_TRUE(parse([&] (IOBuf* ingress) {\n        folly::io::RWPrivateCursor c(ingress);\n        c.skip(http2::kFrameHeaderSize + http2::kConnectionPreface.length());\n        c.writeBE<uint32_t>(1);\n      }));\n\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nclass DummyQueue: public HTTPCodec::PriorityQueue {\n public:\n  DummyQueue() {}\n  ~DummyQueue() override {}\n  void addPriorityNode(HTTPCodec::StreamID id, HTTPCodec::StreamID) override {\n    nodes_.push_back(id);\n  }\n\n  std::vector<HTTPCodec::StreamID> nodes_;\n};\n\nTEST_F(HTTP2CodecTest, VirtualNodes) {\n  DummyQueue queue;\n  uint8_t level = 30;\n  upstreamCodec_.addPriorityNodes(queue, output_, level);\n\n  EXPECT_TRUE(parse());\n  for (int i = 0; i < level; i++) {\n    EXPECT_EQ(queue.nodes_[i], upstreamCodec_.mapPriorityToDependency(i));\n  }\n\n  // Out-of-range priorites are mapped to the lowest level of virtual nodes.\n  EXPECT_EQ(queue.nodes_[level - 1],\n            upstreamCodec_.mapPriorityToDependency(level));\n  EXPECT_EQ(queue.nodes_[level - 1],\n            upstreamCodec_.mapPriorityToDependency(level + 1));\n}\n\nTEST_F(HTTP2CodecTest, BasicPushPromise) {\n  upstreamCodec_.generateSettings(output_);\n  parse();\n  EXPECT_FALSE(upstreamCodec_.supportsPushTransactions());\n  EXPECT_FALSE(downstreamCodec_.supportsPushTransactions());\n\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::ENABLE_PUSH, 1);\n  upstreamCodec_.generateSettings(output_);\n  parse();\n  EXPECT_TRUE(upstreamCodec_.supportsPushTransactions());\n  EXPECT_TRUE(downstreamCodec_.supportsPushTransactions());\n\n  SetUpUpstreamTest();\n\n  HTTPCodec::StreamID assocStream = 7;\n  for (auto i = 0; i < 2; i++) {\n    // Push promise\n    HTTPCodec::StreamID pushStream = downstreamCodec_.createStream();\n    HTTPMessage req = getGetRequest();\n    req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n    downstreamCodec_.generatePushPromise(output_, pushStream, req, assocStream);\n\n    parseUpstream();\n    callbacks_.expectMessage(false, 2, \"/\"); // + host\n    EXPECT_EQ(callbacks_.assocStreamId, assocStream);\n    EXPECT_EQ(callbacks_.headersCompleteId, pushStream);\n    auto& headers = callbacks_.msg->getHeaders();\n    EXPECT_EQ(\"coolio\", headers.getSingleOrEmpty(HTTP_HEADER_USER_AGENT));\n    callbacks_.reset();\n\n    // Actual reply headers\n    HTTPMessage resp;\n    resp.setStatusCode(200);\n    resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"text/plain\");\n    downstreamCodec_.generateHeader(output_, pushStream, resp);\n\n    parseUpstream();\n    callbacks_.expectMessage(false, 2, 200);\n    EXPECT_EQ(callbacks_.headersCompleteId, pushStream);\n    EXPECT_EQ(callbacks_.assocStreamId, 0);\n    EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n    EXPECT_EQ(\"text/plain\", callbacks_.msg->getHeaders().getSingleOrEmpty(\n                  HTTP_HEADER_CONTENT_TYPE));\n    callbacks_.reset();\n  }\n}\n\nTEST_F(HTTP2CodecTest, BadPushPromise) {\n  // ENABLE_PUSH is now 0 by default\n  SetUpUpstreamTest();\n  HTTPMessage req = getGetRequest();\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  downstreamCodec_.generatePushPromise(output_, 2, req, 1);\n\n  parseUpstream();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.assocStreamId, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, BasicCertificateRequest) {\n  uint16_t requestId = 17;\n  std::unique_ptr<folly::IOBuf> authRequest =\n      folly::IOBuf::copyBuffer(\"authRequestData\");\n  upstreamCodec_.generateCertificateRequest(\n      output_, requestId, std::move(authRequest));\n\n  parse();\n  EXPECT_EQ(callbacks_.certificateRequests, 1);\n  EXPECT_EQ(callbacks_.lastCertRequestId, requestId);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), \"authRequestData\");\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicCertificate) {\n  uint16_t certId = 17;\n  std::unique_ptr<folly::IOBuf> authenticator =\n      folly::IOBuf::copyBuffer(\"authenticatorData\");\n  upstreamCodec_.generateCertificate(output_, certId, std::move(authenticator));\n\n  parse();\n  EXPECT_EQ(callbacks_.certificates, 1);\n  EXPECT_EQ(callbacks_.lastCertId, certId);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), \"authenticatorData\");\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadServerPreface) {\n  output_.move();\n  downstreamCodec_.generateWindowUpdate(output_, 0, 10);\n  parseUpstream();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.assocStreamId, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, Normal1024Continuation) {\n  HTTPMessage req = getGetRequest();\n  string bigval(8691, '!');\n  bigval.append(8691, ' ');\n  req.getHeaders().add(\"x-headr\", bigval);\n  req.setHTTP2Priority(HTTPMessage::HTTPPriority(0, false, 7));\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  parse();\n  callbacks_.expectMessage(false, -1, \"/\");\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(bigval, headers.getSingleOrEmpty(\"x-headr\"));\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n\n  upstreamCodec_.generateSettingsAck(output_);\n  parse();\n  EXPECT_EQ(callbacks_.settingsAcks, 1);\n}\n\nTEST_F(HTTP2CodecTest, StreamIdOverflow) {\n  HTTP2Codec codec(TransportDirection::UPSTREAM);\n\n  HTTPCodec::StreamID streamId;\n  codec.setNextEgressStreamId(std::numeric_limits<int32_t>::max() - 10);\n  while (codec.isReusable()) {\n    streamId = codec.createStream();\n  }\n  EXPECT_EQ(streamId, std::numeric_limits<int32_t>::max() - 2);\n}\n\nTEST_F(HTTP2CodecTest, TestMultipleDifferentContentLengthHeaders) {\n  // Generate a POST request with two Content-Length headers\n  // NOTE: getPostRequest already adds the content-length\n  HTTPMessage req = getPostRequest();\n  req.getHeaders().add(HTTP_HEADER_CONTENT_LENGTH, \"300\");\n  EXPECT_EQ(req.getHeaders().getNumberOfValues(HTTP_HEADER_CONTENT_LENGTH), 2);\n\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n  parse();\n\n  // Check that the request fails before the codec finishes parsing the headers\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.lastParseError->getHttpStatusCode(), 400);\n}\n\nTEST_F(HTTP2CodecTest, TestMultipleIdenticalContentLengthHeaders) {\n  // Generate a POST request with two Content-Length headers\n  // NOTE: getPostRequest already adds the content-length\n  HTTPMessage req = getPostRequest();\n  req.getHeaders().add(\"content-length\", \"200\");\n  EXPECT_EQ(req.getHeaders().getNumberOfValues(\"content-length\"), 2);\n\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n  parse();\n\n  // Check that the headers parsing completes correctly\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n}\n\nTEST_F(HTTP2CodecTest, CleartextUpgrade) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  HTTP2Codec::requestUpgrade(req);\n  EXPECT_EQ(req.getHeaders().getSingleOrEmpty(HTTP_HEADER_UPGRADE), \"h2c\");\n  EXPECT_TRUE(req.checkForHeaderToken(HTTP_HEADER_CONNECTION,\n                                      \"Upgrade\", false));\n  EXPECT_TRUE(req.checkForHeaderToken(\n                HTTP_HEADER_CONNECTION,\n                http2::kProtocolSettingsHeader.c_str(), false));\n  EXPECT_GT(\n    req.getHeaders().getSingleOrEmpty(http2::kProtocolSettingsHeader).length(),\n    0);\n}\n\nTEST_F(HTTP2CodecTest, HTTP2SettingsSuccess) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n\n  // empty settings\n  req.getHeaders().add(http2::kProtocolSettingsHeader, \"\");\n  EXPECT_TRUE(downstreamCodec_.onIngressUpgradeMessage(req));\n\n  // real settings (overwrites empty)\n  HTTP2Codec::requestUpgrade(req);\n  EXPECT_TRUE(downstreamCodec_.onIngressUpgradeMessage(req));\n}\n\nTEST_F(HTTP2CodecTest, HTTP2SettingsFailure) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  // no settings\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n\n  HTTPHeaders& headers = req.getHeaders();\n\n  // Not base64_url settings\n  headers.set(http2::kProtocolSettingsHeader, \"????\");\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n  headers.set(http2::kProtocolSettingsHeader, \"AAA\");\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n\n  // Too big\n  string bigSettings((http2::kMaxFramePayloadLength + 1) * 4 / 3, 'A');\n  headers.set(http2::kProtocolSettingsHeader, bigSettings);\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n\n  // Malformed (not a multiple of 6)\n  headers.set(http2::kProtocolSettingsHeader, \"AAAA\");\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n\n  // Two headers\n  headers.set(http2::kProtocolSettingsHeader, \"AAAAAAAA\");\n  headers.add(http2::kProtocolSettingsHeader, \"AAAAAAAA\");\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n}\n\nTEST_F(HTTP2CodecTest, HTTP2EnableConnect) {\n  SetUpUpstreamTest();\n  // egress settings have no connect settings.\n  auto ws_enable = upstreamCodec_.getEgressSettings()->getSetting(\n      SettingsId::ENABLE_CONNECT_PROTOCOL);\n  // enable connect settings, and check.\n  upstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_CONNECT_PROTOCOL, 1);\n  ws_enable = upstreamCodec_.getEgressSettings()->getSetting(\n      SettingsId::ENABLE_CONNECT_PROTOCOL);\n  EXPECT_EQ(ws_enable->value, 1);\n  // generateSettings.\n  // pass the buffer to be parsed by the codec and check for ingress settings.\n  upstreamCodec_.generateSettings(output_);\n  parseUpstream();\n  EXPECT_EQ(1, upstreamCodec_.peerHasWebsockets());\n}\n\nTEST_F(HTTP2CodecTest, WebsocketUpgrade) {\n  HTTPMessage req = getGetRequest(\"/apples\");\n  req.setSecure(true);\n  req.setEgressWebsocketUpgrade();\n\n  upstreamCodec_.generateHeader(output_, 1, req, false);\n  parse();\n\n  EXPECT_TRUE(callbacks_.msg->isIngressWebsocketUpgrade());\n  EXPECT_NE(nullptr, callbacks_.msg->getUpgradeProtocol());\n  EXPECT_EQ(headers::kWebsocketString, *callbacks_.msg->getUpgradeProtocol());\n}\n\nTEST_F(HTTP2CodecTest, WebsocketBadHeader) {\n  const std::string kConnect{\"CONNECT\"};\n  const std::string kWebsocketPath{\"/websocket\"};\n  const std::string kSchemeHttps{\"https\"};\n  vector<proxygen::compress::Header> reqHeaders = {\n    Header::makeHeaderForTest(headers::kMethod, kConnect),\n    Header::makeHeaderForTest(headers::kProtocol, headers::kWebsocketString),\n  };\n  vector<proxygen::compress::Header> optionalHeaders = {\n    Header::makeHeaderForTest(headers::kPath, kWebsocketPath),\n    Header::makeHeaderForTest(headers::kScheme, kSchemeHttps),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  int stream = 1;\n  for (size_t i = 0; i < optionalHeaders.size(); ++i, stream += 2) {\n    auto headers = reqHeaders;\n    headers.push_back(optionalHeaders[i]);\n    auto encodedHeaders = headerCodec.encode(headers);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        false,\n                        true);\n    parse();\n  }\n\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, optionalHeaders.size());\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, WebsocketDupProtocol) {\n  const std::string kConnect{\"CONNECT\"};\n  const std::string kWebsocketPath{\"/websocket\"};\n  const std::string kSchemeHttps{\"https\"};\n  vector<proxygen::compress::Header> headers = {\n    Header::makeHeaderForTest(headers::kMethod, kConnect),\n    Header::makeHeaderForTest(headers::kProtocol, headers::kWebsocketString),\n    Header::makeHeaderForTest(headers::kProtocol, headers::kWebsocketString),\n    Header::makeHeaderForTest(headers::kPath, kWebsocketPath),\n    Header::makeHeaderForTest(headers::kScheme, kSchemeHttps),\n  };\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  auto encodedHeaders = headerCodec.encode(headers);\n  http2::writeHeaders(output_,\n                      std::move(encodedHeaders),\n                      1,\n                      folly::none,\n                      http2::kNoPadding,\n                      false,\n                      true);\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, WebsocketIncorrectResponse) {\n  parse();\n  SetUpUpstreamTest();\n  parseUpstream();\n\n  output_.clear();\n  HTTPMessage req = getGetRequest(\"/apples\");\n  req.setSecure(true);\n  req.setEgressWebsocketUpgrade();\n  upstreamCodec_.generateHeader(output_, 1, req, false);\n  parse();\n\n  output_.clear();\n  HTTPMessage resp;\n  resp.setStatusCode(201);\n  resp.setStatusMessage(\"OK\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n  parseUpstream();\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, TestAllEgressFrameTypeCallbacks) {\n  class CallbackTypeTracker {\n    std::set<uint8_t> types;\n  public:\n    void add(uint8_t, uint8_t type, uint64_t, uint16_t) {\n      types.insert(type);\n    }\n\n    bool isAllFrameTypesReceived() {\n      http2::FrameType expectedTypes[] = {\n        http2::FrameType::DATA,\n        http2::FrameType::HEADERS,\n        http2::FrameType::PRIORITY,\n        http2::FrameType::RST_STREAM,\n        http2::FrameType::SETTINGS,\n        http2::FrameType::PUSH_PROMISE,\n        http2::FrameType::PING,\n        http2::FrameType::GOAWAY,\n        http2::FrameType::WINDOW_UPDATE,\n        http2::FrameType::CONTINUATION,\n        http2::FrameType::EX_HEADERS,\n      };\n\n      for(http2::FrameType type: expectedTypes) {\n        EXPECT_TRUE(types.find(static_cast<uint8_t>(type)) != types.end())\n          << \"callback missing for type \" << static_cast<uint8_t>(type);\n      }\n      return types.size() == (sizeof(expectedTypes)/sizeof(http2::FrameType));\n    }\n  };\n\n  CallbackTypeTracker callbackTypeTracker;\n\n  NiceMock<MockHTTPCodecCallback> mockCallback;\n  upstreamCodec_.setCallback(&mockCallback);\n  downstreamCodec_.setCallback(&mockCallback);\n  EXPECT_CALL(mockCallback, onGenerateFrameHeader(_, _, _, _)).\n    WillRepeatedly(Invoke(&callbackTypeTracker, &CallbackTypeTracker::add));\n\n  // DATA frame\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  upstreamCodec_.generateBody(output_, 2, std::move(buf),\n                              HTTPCodec::NoPadding, true);\n\n  HTTPHeaderSize size;\n  size.uncompressed = size.compressed = 0;\n  HTTPMessage req = getGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req, true, &size);\n\n  upstreamCodec_.generatePriority(output_, 3,\n                                  HTTPMessage::HTTPPriority(0, true, 1));\n  upstreamCodec_.generateRstStream(output_, 2, ErrorCode::ENHANCE_YOUR_CALM);\n  upstreamCodec_.generateSettings(output_);\n  downstreamCodec_.generatePushPromise(output_, 2, req, 1);\n  upstreamCodec_.generatePingRequest(output_);\n\n  std::unique_ptr<folly::IOBuf> debugData =\n      folly::IOBuf::copyBuffer(\"debugData\");\n  upstreamCodec_.generateGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM,\n                                std::move(debugData));\n\n  upstreamCodec_.generateWindowUpdate(output_, 0, 10);\n\n  HTTPCodec::StreamID stream = folly::Random::rand32(10, 1024) * 2;\n  HTTPCodec::StreamID controlStream = folly::Random::rand32(10, 1024) * 2 + 1;\n  downstreamCodec_.generateExHeader(output_, stream, req,\n    HTTPCodec::ExAttributes(controlStream, true));\n\n  // Tests the continuation frame\n  req = getBigGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  EXPECT_TRUE(callbackTypeTracker.isAllFrameTypesReceived());\n}\n\nTEST_F(HTTP2CodecTest, Trailers) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  upstreamCodec_.generateBody(\n      output_, 1, std::move(buf), HTTPCodec::NoPadding, false /* eom */);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  upstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parse();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, 5);\n  EXPECT_EQ(callbacks_.trailers, 1);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 3);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersWithPseudoHeaders) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  upstreamCodec_.generateBody(\n      output_, 1, std::move(buf), HTTPCodec::NoPadding, false /* eom */);\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  std::string post(\"POST\");\n  std::vector<proxygen::compress::Header> trailers = {\n      Header::makeHeaderForTest(headers::kMethod, post)};\n  auto encodedTrailers = headerCodec.encode(trailers);\n  http2::writeHeaders(output_,\n                      std::move(encodedTrailers),\n                      1,\n                      folly::none,\n                      http2::kNoPadding,\n                      true,\n                      true);\n\n  parse();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, 5);\n  EXPECT_EQ(callbacks_.trailers, 0);\n  EXPECT_EQ(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, TrailersNoBody) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  upstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parse();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.bodyLength, 0);\n  EXPECT_EQ(callbacks_.trailers, 1);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 2);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersContinuation) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  trailers.add(\"x-huge-trailer\",\n               std::string(http2::kMaxFramePayloadLengthMin, '!'));\n  upstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parse();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_NE(callbacks_.msg, nullptr);\n  EXPECT_EQ(callbacks_.trailers, 1);\n  EXPECT_NE(callbacks_.msg->getTrailers(), nullptr);\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(std::string(http2::kMaxFramePayloadLengthMin, '!'),\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-huge-trailer\"));\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 3);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersReply) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  downstreamCodec_.generateBody(\n      output_, 1, std::move(buf), HTTPCodec::NoPadding, false);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  trailers.add(\"x-trailer-2\", \"chicken-kyiv\");\n  downstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parseUpstream();\n\n  callbacks_.expectMessage(true, 2, 200);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, 5);\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n  EXPECT_EQ(1, callbacks_.trailers);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(\"chicken-kyiv\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-2\"));\n#ifndef NDEBUG\n  EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 4);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersReplyWithNoData) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  downstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parseUpstream();\n\n  callbacks_.expectMessage(true, 2, 200);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.bodyLength, 0);\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n  EXPECT_EQ(1, callbacks_.trailers);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n#ifndef NDEBUG\n  EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 3);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersReplyWithPseudoHeaders) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  downstreamCodec_.generateBody(\n      output_, 1, std::move(buf), HTTPCodec::NoPadding, false);\n\n  HPACKCodec headerCodec(TransportDirection::DOWNSTREAM);\n  std::string post(\"POST\");\n  std::vector<proxygen::compress::Header> trailers = {\n      Header::makeHeaderForTest(headers::kMethod, post)};\n  auto encodedTrailers = headerCodec.encode(trailers);\n  http2::writeHeaders(output_,\n                      std::move(encodedTrailers),\n                      1,\n                      folly::none,\n                      http2::kNoPadding,\n                      true,\n                      true);\n  parseUpstream();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.trailers, 0);\n  EXPECT_EQ(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, TrailersReplyContinuation) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  trailers.add(\"x-huge-trailer\",\n               std::string(http2::kMaxFramePayloadLengthMin, '!'));\n  downstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parseUpstream();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_NE(callbacks_.msg, nullptr);\n  EXPECT_EQ(callbacks_.msg->getStatusCode(), 200);\n  EXPECT_EQ(1, callbacks_.trailers);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(std::string(http2::kMaxFramePayloadLengthMin, '!'),\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-huge-trailer\"));\n#ifndef NDEBUG\n  EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 4);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersReplyMissingContinuation) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  trailers.add(\"x-huge-trailer\",\n               std::string(http2::kMaxFramePayloadLengthMin, '!'));\n  downstreamCodec_.generateTrailers(output_, 1, trailers);\n  // empirically determined the size of continuation frame, and strip it\n  output_.trimEnd(http2::kFrameHeaderSize + 4132);\n\n  // insert a non-continuation (but otherwise valid) frame\n  http2::writeGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM);\n\n  parseUpstream();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n#ifndef NDEBUG\n  EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 4);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersNotLatest) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n  upstreamCodec_.generateHeader(output_, 3, req);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  upstreamCodec_.generateTrailers(output_, 1, trailers);\n  upstreamCodec_.generateHeader(output_, 3, req);\n\n  parse();\n\n  EXPECT_EQ(callbacks_.messageBegin, 2);\n  EXPECT_EQ(callbacks_.headersComplete, 2);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.trailers, 1);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n", "/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n#include <string>\n#include <vector>\n\n#include <folly/Conv.h>\n#include <folly/Range.h>\n#include <folly/futures/Promise.h>\n#include <folly/io/Cursor.h>\n#include <folly/io/async/EventBase.h>\n#include <folly/io/async/EventBaseManager.h>\n#include <folly/io/async/TimeoutManager.h>\n#include <folly/io/async/test/MockAsyncTransport.h>\n#include <folly/portability/GTest.h>\n#include <proxygen/lib/http/codec/HTTPCodecFactory.h>\n#include <proxygen/lib/http/codec/test/TestUtils.h>\n#include <proxygen/lib/http/session/HTTPDirectResponseHandler.h>\n#include <proxygen/lib/http/session/HTTPDownstreamSession.h>\n#include <proxygen/lib/http/session/HTTPSession.h>\n#include <proxygen/lib/http/session/test/HTTPSessionMocks.h>\n#include <proxygen/lib/http/session/test/HTTPSessionTest.h>\n#include <proxygen/lib/http/session/test/MockByteEventTracker.h>\n#include <proxygen/lib/http/session/test/TestUtils.h>\n#include <proxygen/lib/test/TestAsyncTransport.h>\n#include <wangle/acceptor/ConnectionManager.h>\n\nusing namespace folly::io;\nusing namespace wangle;\nusing namespace folly;\nusing namespace proxygen;\nusing namespace std;\nusing namespace testing;\nusing namespace std::chrono;\nusing folly::Promise;\n\ntemplate <typename C>\nclass HTTPDownstreamTest : public testing::Test {\n public:\n  explicit HTTPDownstreamTest(\n    std::vector<int64_t> flowControl = { -1, -1, -1 },\n    bool startImmediately = true)\n    : eventBase_(),\n      transport_(new TestAsyncTransport(&eventBase_)),\n      transactionTimeouts_(makeTimeoutSet(&eventBase_)),\n      flowControl_(flowControl) {\n    EXPECT_CALL(mockController_, getGracefulShutdownTimeout())\n      .WillRepeatedly(Return(std::chrono::milliseconds(0)));\n    EXPECT_CALL(mockController_, attachSession(_))\n      .WillRepeatedly(Invoke([&] (HTTPSessionBase* session) {\n        session->setPrioritySampled(true);\n      }));\n    HTTPSession::setDefaultReadBufferLimit(65536);\n    auto codec = makeServerCodec<typename C::Codec>(C::version);\n    rawCodec_ = codec.get();\n\n    // If the codec is H2, getHeaderIndexingStrategy will be called when setting\n    // up the codec\n    if (rawCodec_->getProtocol() == CodecProtocol::HTTP_2) {\n      EXPECT_CALL(mockController_, getHeaderIndexingStrategy())\n        .WillOnce(\n          Return(&testH2IndexingStrat_)\n      );\n    }\n\n    httpSession_ = new HTTPDownstreamSession(\n      transactionTimeouts_.get(),\n      std::move(AsyncTransportWrapper::UniquePtr(transport_)),\n      localAddr, peerAddr,\n      &mockController_,\n      std::move(codec),\n      mockTransportInfo /* no stats for now */,\n      nullptr);\n    for (auto& param: flowControl) {\n      if (param < 0) {\n        param = rawCodec_->getDefaultWindowSize();\n      }\n    }\n\n    // Ensure the H2 header indexing strategy was setup correctly if applicable\n    if (rawCodec_->getProtocol() == CodecProtocol::HTTP_2) {\n      HTTP2Codec* recastedCodec = dynamic_cast<HTTP2Codec*>(rawCodec_);\n      EXPECT_EQ(\n        recastedCodec->getHeaderIndexingStrategy(), &testH2IndexingStrat_);\n    }\n\n    httpSession_->setFlowControl(flowControl[0], flowControl[1],\n                                 flowControl[2]);\n    httpSession_->setEgressSettings({{ SettingsId::MAX_CONCURRENT_STREAMS, 80 },\n                                     { SettingsId::HEADER_TABLE_SIZE, 5555 },\n                                     { SettingsId::ENABLE_PUSH, 1 },\n                                     { SettingsId::ENABLE_EX_HEADERS, 1 }});\n    if (startImmediately) {\n      httpSession_->startNow();\n    }\n    clientCodec_ = makeClientCodec<typename C::Codec>(C::version);\n    if (clientCodec_->getProtocol() == CodecProtocol::HTTP_2) {\n      clientCodec_->getEgressSettings()->setSetting(\n        SettingsId::ENABLE_EX_HEADERS, 1);\n    }\n    clientCodec_->generateConnectionPreface(requests_);\n    clientCodec_->setCallback(&callbacks_);\n  }\n\n  HTTPCodec::StreamID sendRequest(const std::string& url = \"/\",\n                                  int8_t priority = 0,\n                                  bool eom = true) {\n    auto req = getGetRequest();\n    req.setURL(url);\n    req.setPriority(priority);\n    return sendRequest(req, eom);\n  }\n\n  HTTPCodec::StreamID sendRequest(const HTTPMessage& req, bool eom = true) {\n    auto streamID = clientCodec_->createStream();\n    clientCodec_->generateHeader(requests_, streamID, req, eom);\n    return streamID;\n  }\n\n  HTTPCodec::StreamID sendHeader() {\n    return sendRequest(\"/\", 0, false);\n  }\n\n  Promise<Unit> sendRequestLater(HTTPMessage req, bool eof=false) {\n    Promise<Unit> reqp;\n    reqp.getFuture().then(&eventBase_, [=] {\n        sendRequest(req);\n        transport_->addReadEvent(requests_, milliseconds(0));\n        if (eof) {\n          transport_->addReadEOF(milliseconds(0));\n        }\n      });\n    return reqp;\n  }\n\n  void SetUp() override {\n    folly::EventBaseManager::get()->clearEventBase();\n    HTTPSession::setDefaultWriteBufferLimit(65536);\n    HTTP2PriorityQueue::setNodeLifetime(std::chrono::milliseconds(2));\n  }\n\n  void cleanup() {\n    EXPECT_CALL(mockController_, detachSession(_));\n    httpSession_->dropConnection();\n  }\n\n\n  std::unique_ptr<testing::StrictMock<MockHTTPHandler>>\n  addSimpleStrictHandler() {\n    std::unique_ptr<testing::StrictMock<MockHTTPHandler>> handler =\n      std::make_unique<testing::StrictMock<MockHTTPHandler>>();\n\n    // The ownership model here is suspect, but assume the callers won't destroy\n    // handler before it's requested\n    auto rawHandler = handler.get();\n    EXPECT_CALL(mockController_, getRequestHandler(testing::_, testing::_))\n      .WillOnce(testing::Return(rawHandler))\n      .RetiresOnSaturation();\n\n    EXPECT_CALL(*handler, setTransaction(testing::_))\n      .WillOnce(testing::SaveArg<0>(&handler->txn_));\n\n    return handler;\n  }\n\n  std::unique_ptr<testing::NiceMock<MockHTTPHandler>>\n  addSimpleNiceHandler() {\n    std::unique_ptr<testing::NiceMock<MockHTTPHandler>> handler =\n      std::make_unique<testing::NiceMock<MockHTTPHandler>>();\n\n    // See comment above\n    auto rawHandler = handler.get();\n    EXPECT_CALL(mockController_, getRequestHandler(testing::_, testing::_))\n      .WillOnce(testing::Return(rawHandler))\n      .RetiresOnSaturation();\n\n    EXPECT_CALL(*handler, setTransaction(testing::_))\n      .WillOnce(testing::SaveArg<0>(&handler->txn_));\n\n    return handler;\n  }\n\n  void onEOMTerminateHandlerExpectShutdown(MockHTTPHandler& handler) {\n    handler.expectEOM([&] { handler.terminate(); });\n    handler.expectDetachTransaction();\n    expectDetachSession();\n  }\n\n  void expectDetachSession() {\n    EXPECT_CALL(mockController_, detachSession(testing::_));\n  }\n\n  void addSingleByteReads(const char* data, milliseconds delay={}) {\n    for (const char* p = data; *p != '\\0'; ++p) {\n      transport_->addReadEvent(p, 1, delay);\n    }\n  }\n\n  void flushRequestsAndLoop(\n    bool eof=false, milliseconds eofDelay=milliseconds(0),\n    milliseconds initialDelay=milliseconds(0),\n    std::function<void()> extraEventsFn = std::function<void()>()) {\n    flushRequests(eof, eofDelay, initialDelay, extraEventsFn);\n    eventBase_.loop();\n  }\n\n  void flushRequestsAndLoopN(uint64_t n,\n    bool eof=false, milliseconds eofDelay=milliseconds(0),\n    milliseconds initialDelay=milliseconds(0),\n    std::function<void()> extraEventsFn = std::function<void()>()) {\n    flushRequests(eof, eofDelay, initialDelay, extraEventsFn);\n    for (uint64_t i = 0; i < n; i++) {\n      eventBase_.loopOnce();\n    }\n  }\n\n  void flushRequests(\n    bool eof=false, milliseconds eofDelay=milliseconds(0),\n    milliseconds initialDelay=milliseconds(0),\n    std::function<void()> extraEventsFn = std::function<void()>()) {\n    transport_->addReadEvent(requests_, initialDelay);\n    if (extraEventsFn) {\n      extraEventsFn();\n    }\n    if (eof) {\n      transport_->addReadEOF(eofDelay);\n    }\n    transport_->startReadEvents();\n  }\n\n  void testSimpleUpgrade(\n    const std::string& upgradeHeader,\n    CodecProtocol expectedProtocol,\n    const std::string& expectedUpgradeHeader);\n\n  void gracefulShutdown() {\n    folly::DelayedDestruction::DestructorGuard g(httpSession_);\n    clientCodec_->generateGoaway(this->requests_, 0, ErrorCode::NO_ERROR);\n    expectDetachSession();\n    flushRequestsAndLoop(true);\n  }\n\n  void testPriorities(uint32_t numPriorities);\n\n  void testChunks(bool trailers);\n\n  void expect101(CodecProtocol expectedProtocol,\n                 const std::string& expectedUpgrade,\n                 bool expect100 = false) {\n    NiceMock<MockHTTPCodecCallback> callbacks;\n\n    EXPECT_CALL(callbacks, onMessageBegin(_, _));\n    EXPECT_CALL(callbacks, onNativeProtocolUpgrade(_, _, _, _))\n      .WillOnce(\n        Invoke([this, expectedUpgrade] (HTTPCodec::StreamID,\n                                        CodecProtocol,\n                                        const std::string&,\n                                        HTTPMessage& msg) {\n             EXPECT_EQ(msg.getStatusCode(), 101);\n             EXPECT_EQ(msg.getStatusMessage(), \"Switching Protocols\");\n             EXPECT_EQ(msg.getHeaders().getSingleOrEmpty(HTTP_HEADER_UPGRADE),\n                       expectedUpgrade);\n             // also connection and date\n             EXPECT_EQ(msg.getHeaders().size(), 3);\n             breakParseOutput_ = true;\n             return true;\n               }));\n    // this comes before 101, but due to gmock this is backwards\n    if (expect100) {\n      EXPECT_CALL(callbacks, onMessageBegin(_, _))\n        .RetiresOnSaturation();\n      EXPECT_CALL(callbacks, onHeadersComplete(_, _))\n        .WillOnce(Invoke([] (HTTPCodec::StreamID,\n                             std::shared_ptr<HTTPMessage> msg) {\n                 LOG(INFO) << \"100 headers\";\n                 EXPECT_EQ(msg->getStatusCode(), 100);\n                         }))\n        .RetiresOnSaturation();\n      EXPECT_CALL(callbacks, onMessageComplete(_, _))\n        .RetiresOnSaturation();\n    }\n    clientCodec_->setCallback(&callbacks);\n    parseOutput(*clientCodec_);\n    clientCodec_ = HTTPCodecFactory::getCodec(expectedProtocol,\n                                              TransportDirection::UPSTREAM);\n  }\n  void expectResponse(uint32_t code = 200,\n                      ErrorCode errorCode = ErrorCode::NO_ERROR,\n                      bool expect100 = false, bool expectGoaway = false) {\n    expectResponses(1, code, errorCode, expect100, expectGoaway);\n  }\n  void expectResponses(uint32_t n, uint32_t code = 200,\n                       ErrorCode errorCode = ErrorCode::NO_ERROR,\n                       bool expect100 = false, bool expectGoaway = false) {\n    clientCodec_->setCallback(&callbacks_);\n    if (isParallelCodecProtocol(clientCodec_->getProtocol())) {\n      EXPECT_CALL(callbacks_, onSettings(_))\n        .WillOnce(Invoke([this] (const SettingsList& settings) {\n              if (flowControl_[0] > 0) {\n                bool foundInitialWindow = false;\n                for (const auto& setting: settings) {\n                  if (setting.id == SettingsId::INITIAL_WINDOW_SIZE) {\n                    EXPECT_EQ(flowControl_[0], setting.value);\n                    foundInitialWindow = true;\n                  }\n                }\n                EXPECT_TRUE(foundInitialWindow);\n              }\n            }));\n    }\n    if (flowControl_[2] > 0) {\n      int64_t sessionDelta =\n        flowControl_[2] - clientCodec_->getDefaultWindowSize();\n      if (clientCodec_->supportsSessionFlowControl() && sessionDelta) {\n        EXPECT_CALL(callbacks_, onWindowUpdate(0, sessionDelta));\n      }\n    }\n    if (flowControl_[1] > 0) {\n      size_t initWindow = flowControl_[0] > 0 ?\n        flowControl_[0] : clientCodec_->getDefaultWindowSize();\n      int64_t streamDelta = flowControl_[1] - initWindow;\n      if (clientCodec_->supportsStreamFlowControl() && streamDelta) {\n        EXPECT_CALL(callbacks_, onWindowUpdate(1, streamDelta));\n      }\n    }\n\n    if (expectGoaway) {\n      EXPECT_CALL(callbacks_, onGoaway(HTTPCodec::StreamID(1),\n                                      ErrorCode::NO_ERROR, _));\n    }\n\n    for (uint32_t i = 0; i < n; i++) {\n      uint8_t times = (expect100) ? 2 : 1;\n      EXPECT_CALL(callbacks_, onMessageBegin(_, _))\n        .Times(times).RetiresOnSaturation();\n      EXPECT_CALL(callbacks_, onHeadersComplete(_, _))\n        .WillOnce(Invoke([code] (HTTPCodec::StreamID,\n                                 std::shared_ptr<HTTPMessage> msg) {\n                           EXPECT_EQ(msg->getStatusCode(), code);\n                         }));\n      if (expect100) {\n        EXPECT_CALL(callbacks_, onHeadersComplete(_, _))\n          .WillOnce(Invoke([] (HTTPCodec::StreamID,\n                               std::shared_ptr<HTTPMessage> msg) {\n                             EXPECT_EQ(msg->getStatusCode(), 100);\n                           }))\n          .RetiresOnSaturation();\n      }\n      if (errorCode != ErrorCode::NO_ERROR) {\n        EXPECT_CALL(callbacks_, onAbort(_, _))\n          .WillOnce(Invoke([errorCode] (HTTPCodec::StreamID,\n                                        ErrorCode error) {\n                             EXPECT_EQ(error, errorCode);\n                         }));\n      }\n      EXPECT_CALL(callbacks_, onBody(_, _, _)).RetiresOnSaturation();\n      EXPECT_CALL(callbacks_, onMessageComplete(_, _)).RetiresOnSaturation();\n    }\n    parseOutput(*clientCodec_);\n  }\n\n  void parseOutput(HTTPCodec& clientCodec) {\n    auto writeEvents = transport_->getWriteEvents();\n    while (!breakParseOutput_ &&\n           (!writeEvents->empty() || !parseOutputStream_.empty())) {\n      if (!writeEvents->empty()) {\n        auto event = writeEvents->front();\n        auto vec = event->getIoVec();\n        for (size_t i = 0; i < event->getCount(); i++) {\n          parseOutputStream_.append(\n            IOBuf::copyBuffer(vec[i].iov_base, vec[i].iov_len));\n        }\n        writeEvents->pop_front();\n      }\n      uint32_t consumed = clientCodec.onIngress(*parseOutputStream_.front());\n      parseOutputStream_.split(consumed);\n    }\n    if (!breakParseOutput_) {\n      EXPECT_EQ(parseOutputStream_.chainLength(), 0);\n    }\n    breakParseOutput_ = false;\n  }\n\n  void resumeWritesInLoop() {\n    eventBase_.runInLoop([this] { transport_->resumeWrites(); });\n  }\n\n  void resumeWritesAfterDelay(milliseconds delay) {\n    eventBase_.runAfterDelay([this] { transport_->resumeWrites(); },\n                             delay.count());\n  }\n\n  MockByteEventTracker* setMockByteEventTracker() {\n    auto byteEventTracker = new MockByteEventTracker(nullptr);\n    httpSession_->setByteEventTracker(\n      std::unique_ptr<ByteEventTracker>(byteEventTracker));\n    EXPECT_CALL(*byteEventTracker, preSend(_, _, _))\n      .WillRepeatedly(Return(0));\n    EXPECT_CALL(*byteEventTracker, drainByteEvents())\n      .WillRepeatedly(Return(0));\n    EXPECT_CALL(*byteEventTracker, processByteEvents(_, _))\n      .WillRepeatedly(Invoke([]\n                             (std::shared_ptr<ByteEventTracker> self,\n                              uint64_t bytesWritten) {\n                               return self->ByteEventTracker::processByteEvents(\n                                 self,\n                                 bytesWritten);\n                             }));\n\n    return byteEventTracker;\n  }\n\n protected:\n  EventBase eventBase_;\n  TestAsyncTransport* transport_;  // invalid once httpSession_ is destroyed\n  folly::HHWheelTimer::UniquePtr transactionTimeouts_;\n  std::vector<int64_t> flowControl_;\n  StrictMock<MockController> mockController_;\n  HTTPDownstreamSession* httpSession_;\n  IOBufQueue requests_{IOBufQueue::cacheChainLength()};\n  unique_ptr<HTTPCodec> clientCodec_;\n  NiceMock<MockHTTPCodecCallback> callbacks_;\n  IOBufQueue parseOutputStream_{IOBufQueue::cacheChainLength()};\n  bool breakParseOutput_{false};\n  typename C::Codec* rawCodec_{nullptr};\n  HeaderIndexingStrategy testH2IndexingStrat_;\n};\n\n// Uses TestAsyncTransport\nusing HTTPDownstreamSessionTest = HTTPDownstreamTest<HTTP1xCodecPair>;\nusing SPDY3DownstreamSessionTest = HTTPDownstreamTest<SPDY3CodecPair>;\nnamespace {\nclass HTTP2DownstreamSessionTest : public HTTPDownstreamTest<HTTP2CodecPair> {\n public:\n  HTTP2DownstreamSessionTest()\n      : HTTPDownstreamTest<HTTP2CodecPair>() {}\n\n  void SetUp() override {\n    HTTPDownstreamTest<HTTP2CodecPair>::SetUp();\n  }\n\n  void SetupControlStream(HTTPCodec::StreamID cStreamId) {\n    // enable EX_HEADERS\n    clientCodec_->getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n    clientCodec_->generateSettings(requests_);\n    // create a control stream\n    clientCodec_->generateHeader(requests_, cStreamId, getGetRequest(\"/cc\"),\n                                 true, nullptr);\n  }\n\n  void TearDown() override {\n  }\n};\n}\n\nnamespace {\nclass HTTP2DownstreamSessionEarlyShutdownTest :\npublic HTTPDownstreamTest<HTTP2CodecPair> {\n public:\n  HTTP2DownstreamSessionEarlyShutdownTest()\n      : HTTPDownstreamTest<HTTP2CodecPair>({-1, -1, -1}, false) {}\n\n  void SetUp() override {\n    HTTPDownstreamTest<HTTP2CodecPair>::SetUp();\n  }\n\n  void TearDown() override {\n  }\n};\n}\n\nTEST_F(HTTP2DownstreamSessionEarlyShutdownTest, EarlyShutdown) {\n  folly::DelayedDestruction::DestructorGuard g(httpSession_);\n\n  // Try shutting down the session and then starting it. This should be properly\n  // handled by the HTTPSession such that no HTTP/2 frames are sent in the\n  // wrong order.\n  StrictMock<MockHTTPCodecCallback> callbacks;\n  clientCodec_->setCallback(&callbacks);\n  EXPECT_CALL(callbacks, onFrameHeader(_, _, _, _, _)).Times(2);\n  EXPECT_CALL(callbacks, onSettings(_)).Times(1);\n  EXPECT_CALL(callbacks, onGoaway(_, _, _)).Times(1);\n  expectDetachSession();\n  httpSession_->notifyPendingShutdown();\n  httpSession_->startNow();\n  eventBase_.loop();\n  parseOutput(*clientCodec_);\n}\n\nTEST_F(HTTPDownstreamSessionTest, ImmediateEof) {\n  // Send EOF without any request data\n  EXPECT_CALL(mockController_, getRequestHandler(_, _)).Times(0);\n  expectDetachSession();\n\n  flushRequestsAndLoop(true, milliseconds(0));\n}\n\nTEST_F(HTTPDownstreamSessionTest, Http10NoHeaders) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleNiceHandler();\n  handler->expectHeaders([&] (std::shared_ptr<HTTPMessage> msg) {\n      EXPECT_FALSE(msg->getIsChunked());\n      EXPECT_FALSE(msg->getIsUpgraded());\n      EXPECT_EQ(\"/\", msg->getURL());\n      EXPECT_EQ(\"/\", msg->getPath());\n      EXPECT_EQ(\"\", msg->getQueryString());\n      EXPECT_EQ(1, msg->getHTTPVersion().first);\n      EXPECT_EQ(0, msg->getHTTPVersion().second);\n    });\n  onEOMTerminateHandlerExpectShutdown(*handler);\n\n  auto req = getGetRequest();\n  req.setHTTPVersion(1, 0);\n  sendRequest(req);\n  flushRequestsAndLoop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, Http10NoHeadersEof) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleNiceHandler();\n  handler->expectHeaders([&] (std::shared_ptr<HTTPMessage> msg) {\n      EXPECT_FALSE(msg->getIsChunked());\n      EXPECT_FALSE(msg->getIsUpgraded());\n      EXPECT_EQ(\"http://example.com/foo?bar\", msg->getURL());\n      EXPECT_EQ(\"/foo\", msg->getPath());\n      EXPECT_EQ(\"bar\", msg->getQueryString());\n      EXPECT_EQ(1, msg->getHTTPVersion().first);\n      EXPECT_EQ(0, msg->getHTTPVersion().second);\n    });\n  onEOMTerminateHandlerExpectShutdown(*handler);\n\n  const char *req = \"GET http://example.com/foo?bar HTTP/1.0\\r\\n\\r\\n\";\n  requests_.append(req, strlen(req));\n  flushRequestsAndLoop(true, milliseconds(0));\n}\n\nTEST_F(HTTPDownstreamSessionTest, SingleBytes) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleNiceHandler();\n  handler->expectHeaders([&] (std::shared_ptr<HTTPMessage> msg) {\n      const HTTPHeaders& hdrs = msg->getHeaders();\n      EXPECT_EQ(2, hdrs.size());\n      EXPECT_TRUE(hdrs.exists(\"host\"));\n      EXPECT_TRUE(hdrs.exists(\"connection\"));\n\n      EXPECT_FALSE(msg->getIsChunked());\n      EXPECT_FALSE(msg->getIsUpgraded());\n      EXPECT_EQ(\"/somepath.php?param=foo\", msg->getURL());\n      EXPECT_EQ(\"/somepath.php\", msg->getPath());\n      EXPECT_EQ(\"param=foo\", msg->getQueryString());\n      EXPECT_EQ(1, msg->getHTTPVersion().first);\n      EXPECT_EQ(1, msg->getHTTPVersion().second);\n    });\n  onEOMTerminateHandlerExpectShutdown(*handler);\n\n  addSingleByteReads(\"GET /somepath.php?param=foo HTTP/1.1\\r\\n\"\n                     \"Host: example.com\\r\\n\"\n                     \"Connection: close\\r\\n\"\n                     \"\\r\\n\");\n  transport_->addReadEOF(milliseconds(0));\n  transport_->startReadEvents();\n  eventBase_.loop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, SingleBytesWithBody) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleNiceHandler();\n  handler->expectHeaders([&] (std::shared_ptr<HTTPMessage> msg) {\n      const HTTPHeaders& hdrs = msg->getHeaders();\n      EXPECT_EQ(3, hdrs.size());\n      EXPECT_TRUE(hdrs.exists(\"host\"));\n      EXPECT_TRUE(hdrs.exists(\"content-length\"));\n      EXPECT_TRUE(hdrs.exists(\"myheader\"));\n\n      EXPECT_FALSE(msg->getIsChunked());\n      EXPECT_FALSE(msg->getIsUpgraded());\n      EXPECT_EQ(\"/somepath.php?param=foo\", msg->getURL());\n      EXPECT_EQ(\"/somepath.php\", msg->getPath());\n      EXPECT_EQ(\"param=foo\", msg->getQueryString());\n      EXPECT_EQ(1, msg->getHTTPVersion().first);\n      EXPECT_EQ(1, msg->getHTTPVersion().second);\n    });\n  EXPECT_CALL(*handler, onBody(_))\n    .WillOnce(ExpectString(\"1\"))\n    .WillOnce(ExpectString(\"2\"))\n    .WillOnce(ExpectString(\"3\"))\n    .WillOnce(ExpectString(\"4\"))\n    .WillOnce(ExpectString(\"5\"));\n  onEOMTerminateHandlerExpectShutdown(*handler);\n\n  addSingleByteReads(\"POST /somepath.php?param=foo HTTP/1.1\\r\\n\"\n                     \"Host: example.com\\r\\n\"\n                     \"MyHeader: FooBar\\r\\n\"\n                     \"Content-Length: 5\\r\\n\"\n                     \"\\r\\n\"\n                     \"12345\");\n  transport_->addReadEOF(milliseconds(0));\n  transport_->startReadEvents();\n  eventBase_.loop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, SplitBody) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleNiceHandler();\n  handler->expectHeaders([&] (std::shared_ptr<HTTPMessage> msg) {\n      const HTTPHeaders& hdrs = msg->getHeaders();\n      EXPECT_EQ(2, hdrs.size());\n    });\n  EXPECT_CALL(*handler, onBody(_))\n    .WillOnce(ExpectString(\"12345\"))\n    .WillOnce(ExpectString(\"abcde\"));\n  onEOMTerminateHandlerExpectShutdown(*handler);\n\n  transport_->addReadEvent(\"POST / HTTP/1.1\\r\\n\"\n                           \"Host: example.com\\r\\n\"\n                           \"Content-Length: 10\\r\\n\"\n                           \"\\r\\n\"\n                           \"12345\", milliseconds(0));\n  transport_->addReadEvent(\"abcde\", milliseconds(5));\n  transport_->addReadEOF(milliseconds(0));\n  transport_->startReadEvents();\n  eventBase_.loop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, PostChunked) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleNiceHandler();\n  handler->expectHeaders([&] (std::shared_ptr<HTTPMessage> msg) {\n      const HTTPHeaders& hdrs = msg->getHeaders();\n      EXPECT_EQ(3, hdrs.size());\n      EXPECT_TRUE(hdrs.exists(\"host\"));\n      EXPECT_TRUE(hdrs.exists(\"content-type\"));\n      EXPECT_TRUE(hdrs.exists(\"transfer-encoding\"));\n      EXPECT_TRUE(msg->getIsChunked());\n      EXPECT_FALSE(msg->getIsUpgraded());\n      EXPECT_EQ(\"http://example.com/cgi-bin/foo.aspx?abc&def\",\n                msg->getURL());\n      EXPECT_EQ(\"/cgi-bin/foo.aspx\", msg->getPath());\n      EXPECT_EQ(\"abc&def\", msg->getQueryString());\n      EXPECT_EQ(1, msg->getHTTPVersion().first);\n      EXPECT_EQ(1, msg->getHTTPVersion().second);\n    });\n  EXPECT_CALL(*handler, onChunkHeader(3));\n  EXPECT_CALL(*handler, onBody(_))\n    .WillOnce(ExpectString(\"bar\"));\n  EXPECT_CALL(*handler, onChunkComplete());\n  EXPECT_CALL(*handler, onChunkHeader(0x22));\n  EXPECT_CALL(*handler, onBody(_))\n    .WillOnce(ExpectString(\"0123456789abcdef\\nfedcba9876543210\\n\"));\n  EXPECT_CALL(*handler, onChunkComplete());\n  EXPECT_CALL(*handler, onChunkHeader(3));\n  EXPECT_CALL(*handler, onBody(_))\n    .WillOnce(ExpectString(\"foo\"));\n  EXPECT_CALL(*handler, onChunkComplete());\n  onEOMTerminateHandlerExpectShutdown(*handler);\n\n  transport_->addReadEvent(\"POST http://example.com/cgi-bin/foo.aspx?abc&def \"\n                           \"HTTP/1.1\\r\\n\"\n                           \"Host: example.com\\r\\n\"\n                           \"Content-Type: text/pla\", milliseconds(0));\n  transport_->addReadEvent(\"in; charset=utf-8\\r\\n\"\n                           \"Transfer-encoding: chunked\\r\\n\"\n                           \"\\r\", milliseconds(2));\n  transport_->addReadEvent(\"\\n\"\n                           \"3\\r\\n\"\n                           \"bar\\r\\n\"\n                           \"22\\r\\n\"\n                           \"0123456789abcdef\\n\"\n                           \"fedcba9876543210\\n\"\n                           \"\\r\\n\"\n                           \"3\\r\", milliseconds(3));\n  transport_->addReadEvent(\"\\n\"\n                           \"foo\\r\\n\"\n                           \"0\\r\\n\\r\\n\", milliseconds(1));\n  transport_->startReadEvents();\n  eventBase_.loop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, MultiMessage) {\n  InSequence enforceOrder;\n\n  auto handler1 = addSimpleNiceHandler();\n  handler1->expectHeaders();\n  EXPECT_CALL(*handler1, onBody(_))\n    .WillOnce(ExpectString(\"foo\"))\n    .WillOnce(ExpectString(\"bar9876\"));\n  handler1->expectEOM([&] { handler1->sendReply(); });\n  handler1->expectDetachTransaction();\n\n  auto handler2 = addSimpleNiceHandler();\n  handler2->expectHeaders();\n  EXPECT_CALL(*handler2, onChunkHeader(0xa));\n  EXPECT_CALL(*handler2, onBody(_))\n    .WillOnce(ExpectString(\"some \"))\n    .WillOnce(ExpectString(\"data\\n\"));\n  EXPECT_CALL(*handler2, onChunkComplete());\n  onEOMTerminateHandlerExpectShutdown(*handler2);\n\n  transport_->addReadEvent(\"POST / HTTP/1.1\\r\\n\"\n                           \"Host: example.com\\r\\n\"\n                           \"Content-Length: 10\\r\\n\"\n                           \"\\r\\n\"\n                           \"foo\", milliseconds(0));\n  transport_->addReadEvent(\"bar9876\"\n                           \"POST /foo HTTP/1.1\\r\\n\"\n                           \"Host: exa\", milliseconds(2));\n  transport_->addReadEvent(\"mple.com\\r\\n\"\n                           \"Connection: close\\r\\n\"\n                           \"Trans\", milliseconds(0));\n  transport_->addReadEvent(\"fer-encoding: chunked\\r\\n\"\n                           \"\\r\\n\", milliseconds(2));\n  transport_->addReadEvent(\"a\\r\\nsome \", milliseconds(0));\n  transport_->addReadEvent(\"data\\n\\r\\n0\\r\\n\\r\\n\", milliseconds(2));\n  transport_->addReadEOF(milliseconds(0));\n  transport_->startReadEvents();\n  eventBase_.loop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, Connect) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleStrictHandler();\n  // Send HTTP 200 OK to accept the CONNECT request\n  handler->expectHeaders([&handler] {\n      handler->sendHeaders(200, 100);\n    });\n\n  EXPECT_CALL(*handler, onUpgrade(_));\n\n  // Data should be received using onBody\n  EXPECT_CALL(*handler, onBody(_))\n    .WillOnce(ExpectString(\"12345\"))\n    .WillOnce(ExpectString(\"abcde\"));\n  onEOMTerminateHandlerExpectShutdown(*handler);\n\n  transport_->addReadEvent(\"CONNECT test HTTP/1.1\\r\\n\"\n                           \"\\r\\n\"\n                           \"12345\", milliseconds(0));\n  transport_->addReadEvent(\"abcde\", milliseconds(5));\n  transport_->addReadEOF(milliseconds(0));\n  transport_->startReadEvents();\n  eventBase_.loop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, ConnectRejected) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleStrictHandler();\n  // Send HTTP 400 to reject the CONNECT request\n  handler->expectHeaders([&handler] {\n      handler->sendReplyCode(400);\n    });\n\n  onEOMTerminateHandlerExpectShutdown(*handler);\n\n  transport_->addReadEvent(\"CONNECT test HTTP/1.1\\r\\n\"\n                           \"\\r\\n\"\n                           \"12345\", milliseconds(0));\n  transport_->addReadEvent(\"abcde\", milliseconds(5));\n  transport_->addReadEOF(milliseconds(0));\n  transport_->startReadEvents();\n  eventBase_.loop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, HttpUpgrade) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleStrictHandler();\n  // Send HTTP 101 Switching Protocls to accept the upgrade request\n  handler->expectHeaders([&handler] {\n      handler->sendHeaders(101, 100);\n    });\n\n  // Send the response in the new protocol after upgrade\n  EXPECT_CALL(*handler, onUpgrade(_))\n      .WillOnce(Invoke([&handler](UpgradeProtocol /*protocol*/) {\n        handler->sendReplyCode(100);\n      }));\n\n  onEOMTerminateHandlerExpectShutdown(*handler);\n\n  HTTPMessage req = getGetRequest();\n  req.getHeaders().add(HTTP_HEADER_UPGRADE, \"TEST/1.0\");\n  req.getHeaders().add(HTTP_HEADER_CONNECTION, \"upgrade\");\n  sendRequest(req);\n  flushRequestsAndLoop(true, milliseconds(0));\n}\n\nTEST(HTTPDownstreamTest, ParseErrorNoTxn) {\n  // 1) Get a parse error on SYN_STREAM for streamID == 1\n  // 2) Expect that the codec should be asked to generate an abort on\n  //    streamID==1\n  EventBase evb;\n\n  // Setup the controller and its expecations.\n  NiceMock<MockController> mockController;\n\n  // Setup the codec, its callbacks, and its expectations.\n  auto codec = makeDownstreamParallelCodec();\n  HTTPCodec::Callback* codecCallback = nullptr;\n  EXPECT_CALL(*codec, setCallback(_))\n    .WillRepeatedly(SaveArg<0>(&codecCallback));\n  // Expect egress abort for streamID == 1\n  EXPECT_CALL(*codec, generateRstStream(_, 1, _));\n\n  // Setup transport\n  bool transportGood = true;\n  auto transport = newMockTransport(&evb);\n  EXPECT_CALL(*transport, good())\n    .WillRepeatedly(ReturnPointee(&transportGood));\n  EXPECT_CALL(*transport, closeNow())\n    .WillRepeatedly(Assign(&transportGood, false));\n  EXPECT_CALL(*transport, writeChain(_, _, _))\n    .WillRepeatedly(\n      Invoke([&] (folly::AsyncTransportWrapper::WriteCallback* callback,\n                  const shared_ptr<IOBuf>&, WriteFlags) {\n               callback->writeSuccess();\n             }));\n\n  // Create the downstream session, thus initializing codecCallback\n  auto transactionTimeouts = makeInternalTimeoutSet(&evb);\n  auto session = new HTTPDownstreamSession(\n    transactionTimeouts.get(),\n    AsyncTransportWrapper::UniquePtr(transport),\n    localAddr, peerAddr,\n    &mockController, std::move(codec),\n    mockTransportInfo,\n    nullptr);\n  session->startNow();\n  HTTPException ex(HTTPException::Direction::INGRESS_AND_EGRESS, \"foo\");\n  ex.setProxygenError(kErrorParseHeader);\n  ex.setCodecStatusCode(ErrorCode::REFUSED_STREAM);\n  codecCallback->onError(HTTPCodec::StreamID(1), ex, true);\n\n  // cleanup\n  session->dropConnection();\n  evb.loop();\n}\n\nTEST(HTTPDownstreamTest, ByteEventsDrained) {\n  // Test that byte events are drained before socket is closed\n  EventBase evb;\n\n  NiceMock<MockController> mockController;\n  auto codec = makeDownstreamParallelCodec();\n  auto byteEventTracker = new MockByteEventTracker(nullptr);\n  auto transport = newMockTransport(&evb);\n  auto transactionTimeouts = makeInternalTimeoutSet(&evb);\n\n  // Create the downstream session\n  auto session = new HTTPDownstreamSession(\n    transactionTimeouts.get(),\n    AsyncTransportWrapper::UniquePtr(transport),\n    localAddr, peerAddr,\n    &mockController, std::move(codec),\n    mockTransportInfo,\n    nullptr);\n  session->setByteEventTracker(\n      std::unique_ptr<ByteEventTracker>(byteEventTracker));\n\n  InSequence enforceOrder;\n\n  session->startNow();\n\n  // Byte events should be drained first\n  EXPECT_CALL(*byteEventTracker, drainByteEvents())\n    .Times(1);\n  EXPECT_CALL(*transport, closeNow())\n    .Times(AtLeast(1));\n\n  // Close the socket\n  session->dropConnection();\n  evb.loop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, HttpWithAckTiming) {\n  // This is to test cases where holding a byte event to a finished HTTP/1.1\n  // transaction does not masquerade as HTTP pipelining.\n  auto byteEventTracker = setMockByteEventTracker();\n  InSequence enforceOrder;\n\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1] () {\n      handler1->sendChunkedReplyWithBody(200, 100, 100, false);\n    });\n  // Hold a pending byte event\n  EXPECT_CALL(*byteEventTracker, addLastByteEvent(_, _))\n      .WillOnce(Invoke([] (HTTPTransaction* txn,\n                           uint64_t /*byteNo*/) {\n                         txn->incrementPendingByteEvents();\n                       }));\n  sendRequest();\n  flushRequestsAndLoop();\n  expectResponse();\n\n  // Send the secode request after receiving the first response (eg: clearly\n  // not pipelined)\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&handler2] () {\n      handler2->sendChunkedReplyWithBody(200, 100, 100, false);\n    });\n  // This txn processed and destroyed before txn1\n  EXPECT_CALL(*byteEventTracker, addLastByteEvent(_, _));\n  handler2->expectDetachTransaction();\n\n  sendRequest();\n  flushRequestsAndLoop();\n  expectResponse();\n\n  // Now clear the pending byte event (simulate ack) and the first txn\n  // goes away too\n  handler1->expectDetachTransaction();\n  handler1->txn_->decrementPendingByteEvents();\n  gracefulShutdown();\n}\n\nTEST_F(HTTPDownstreamSessionTest, TestOnContentMismatch) {\n  // Test the behavior when the reported content-length on the header\n  // is different from the actual length of the body.\n  // The expectation is simply to log the behavior, such as:\n  // \".. HTTPTransaction.cpp ] Content-Length/body mismatch: expected: .. \"\n  folly::EventBase base;\n  InSequence enforceOrder;\n  auto handler1 = addSimpleNiceHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1] () {\n        // over-estimate the content-length on the header\n        handler1->sendHeaders(200, 105);\n        handler1->sendBody(100);\n        handler1->txn_->sendEOM();\n      });\n  sendRequest();\n  flushRequestsAndLoop();\n\n  auto handler2 = addSimpleNiceHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&handler2] () {\n        // under-estimate the content-length on the header\n        handler2->sendHeaders(200, 95);\n        handler2->sendBody(100);\n        handler2->txn_->sendEOM();\n      });\n  sendRequest();\n  flushRequestsAndLoop();\n  gracefulShutdown();\n}\n\nTEST_F(HTTPDownstreamSessionTest, HttpWithAckTimingPipeline) {\n  // Test a real pipelining case as well.  First request is done waiting for\n  // ack, then receive two pipelined requests.\n  auto byteEventTracker = setMockByteEventTracker();\n  InSequence enforceOrder;\n\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1] () {\n      handler1->sendChunkedReplyWithBody(200, 100, 100, false);\n    });\n  EXPECT_CALL(*byteEventTracker, addLastByteEvent(_, _))\n      .WillOnce(Invoke([] (HTTPTransaction* txn,\n                           uint64_t /*byteNo*/) {\n                         txn->incrementPendingByteEvents();\n                       }));\n  sendRequest();\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&handler2] () {\n      handler2->sendChunkedReplyWithBody(200, 100, 100, false);\n    });\n  EXPECT_CALL(*byteEventTracker, addLastByteEvent(_, _));\n  handler2->expectDetachTransaction();\n\n  sendRequest();\n  sendRequest();\n  auto handler3 = addSimpleStrictHandler();\n  handler3->expectHeaders();\n  handler3->expectEOM([&handler3] () {\n      handler3->sendChunkedReplyWithBody(200, 100, 100, false);\n    });\n  EXPECT_CALL(*byteEventTracker, addLastByteEvent(_, _));\n  handler3->expectDetachTransaction();\n  flushRequestsAndLoop();\n  expectResponses(3);\n  handler1->expectDetachTransaction();\n  handler1->txn_->decrementPendingByteEvents();\n  gracefulShutdown();\n}\n\n/*\n * The sequence of streams are generated in the following order:\n * - [client --> server] regular request 1st stream (getGetRequest())\n * - [server --> client] respond 1st stream (res, 100 bytes, without EOM)\n * - [server --> client] request 2nd stream (pub, 200 bytes, EOM)\n * - [client --> server] respond 2nd stream (OK, EOM)\n * - [client --> server] EOM on the 1st stream\n */\nTEST_F(HTTP2DownstreamSessionTest, ExheaderFromServer) {\n  auto cStreamId = HTTPCodec::StreamID(1);\n  SetupControlStream(cStreamId);\n\n  // Create a dummy request and a dummy response messages\n  auto pub = getGetRequest(\"/sub/fyi\");\n  // set up the priority for fun\n  pub.setHTTP2Priority(std::make_tuple(0, false, 7));\n\n  InSequence handlerSequence;\n  auto cHandler = addSimpleStrictHandler();\n  StrictMock<MockHTTPHandler> pubHandler;\n\n  cHandler->expectHeaders([&] {\n      cHandler->txn_->pauseIngress();\n      // Generate response for the control stream\n      cHandler->txn_->sendHeaders(getResponse(200, 0));\n      cHandler->txn_->sendBody(makeBuf(100));\n\n      auto* pubTxn = cHandler->txn_->newExTransaction(&pubHandler);\n      // Generate a pub request (encapsulated in EX_HEADERS frame)\n      pubTxn->sendHeaders(pub);\n      pubTxn->sendBody(makeBuf(200));\n      pubTxn->sendEOM();\n    });\n\n  EXPECT_CALL(pubHandler, setTransaction(_));\n  EXPECT_CALL(callbacks_, onSettings(_))\n    .WillOnce(InvokeWithoutArgs([&] {\n          clientCodec_->generateSettingsAck(requests_);\n        }));\n  EXPECT_CALL(callbacks_, onMessageBegin(cStreamId, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(cStreamId, _));\n  EXPECT_CALL(callbacks_, onExMessageBegin(2, _, _, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(2, _));\n  EXPECT_CALL(callbacks_, onMessageComplete(2, _));\n\n  EXPECT_CALL(pubHandler, onHeadersComplete(_));\n  EXPECT_CALL(pubHandler, onEOM());\n  EXPECT_CALL(pubHandler, detachTransaction());\n\n  EXPECT_CALL(*cHandler, onEOM());\n  EXPECT_CALL(*cHandler, detachTransaction());\n\n  transport_->addReadEvent(requests_, milliseconds(0));\n  transport_->startReadEvents();\n\n  eventBase_.runAfterDelay([&] {\n      parseOutput(*clientCodec_);\n      // send a response from client to server\n      clientCodec_->generateExHeader(requests_, 2, getResponse(200, 0),\n                                     HTTPCodec::ExAttributes(cStreamId, false),\n                                     true, nullptr);\n      transport_->addReadEvent(requests_, milliseconds(0));\n      transport_->startReadEvents();\n      parseOutput(*clientCodec_);\n      cHandler->txn_->resumeIngress();\n      cHandler->txn_->sendEOM();\n      transport_->addReadEOF(milliseconds(0));\n    }, 100);\n\n  HTTPSession::DestructorGuard g(httpSession_);\n  expectDetachSession();\n  eventBase_.loop();\n}\n\n/*\n * The sequence of streams are generated in the following order:\n * - [client --> server] regular request on control stream 1\n * - [client --> server] Pub request on stream 3\n * - [server --> client] response on stream 1 (OK, )\n * - [server --> client] response on stream 3 (OK, EOM)\n * - [server --> client] response on stream 1 (EOM)\n */\nTEST_F(HTTP2DownstreamSessionTest, ExheaderFromClient) {\n  auto cStreamId = HTTPCodec::StreamID(1);\n  SetupControlStream(cStreamId);\n\n  // generate an EX_HEADERS\n  auto exStreamId = cStreamId + 2;\n  clientCodec_->generateExHeader(requests_, exStreamId, getGetRequest(\"/pub\"),\n                                 HTTPCodec::ExAttributes(cStreamId, false),\n                                 true, nullptr);\n\n  auto cHandler = addSimpleStrictHandler();\n  cHandler->expectHeaders([&] {\n      // send back the response for control stream, but EOM\n      cHandler->txn_->sendHeaders(getResponse(200, 0));\n    });\n  EXPECT_CALL(*cHandler, onEOM());\n\n  StrictMock<MockHTTPHandler> pubHandler;\n  EXPECT_CALL(*cHandler, onExTransaction(_))\n    .WillOnce(Invoke([&pubHandler] (HTTPTransaction* exTxn) {\n          exTxn->setHandler(&pubHandler);\n          pubHandler.txn_ = exTxn;\n        }));\n\n  InSequence handlerSequence;\n  EXPECT_CALL(pubHandler, setTransaction(_));\n  pubHandler.expectHeaders([&] {\n      // send back the response for the pub request\n      pubHandler.txn_->sendHeadersWithEOM(getResponse(200, 0));\n    });\n  EXPECT_CALL(pubHandler, onEOM());\n  EXPECT_CALL(pubHandler, detachTransaction());\n  cHandler->expectDetachTransaction();\n\n  EXPECT_CALL(callbacks_, onMessageBegin(cStreamId, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(cStreamId, _));\n  EXPECT_CALL(callbacks_, onExMessageBegin(exStreamId, _, _, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(exStreamId, _));\n  EXPECT_CALL(callbacks_, onMessageComplete(exStreamId, _));\n  EXPECT_CALL(callbacks_, onMessageComplete(cStreamId, _));\n\n  transport_->addReadEvent(requests_, milliseconds(0));\n  transport_->startReadEvents();\n  transport_->addReadEOF(milliseconds(0));\n  eventBase_.loop();\n\n  HTTPSession::DestructorGuard g(httpSession_);\n  expectDetachSession();\n  cHandler->txn_->sendEOM();\n  eventBase_.loop();\n  parseOutput(*clientCodec_);\n}\n\n/*\n * The sequence of streams are generated in the following order:\n * - [client --> server] regular request 1st stream (getGetRequest())\n * - [server --> client] request 2nd stream (unidirectional)\n * - [server --> client] response + EOM on the 1st stream\n */\nTEST_F(HTTP2DownstreamSessionTest, UnidirectionalExTransaction) {\n  auto cStreamId = HTTPCodec::StreamID(1);\n  SetupControlStream(cStreamId);\n  InSequence handlerSequence;\n  auto cHandler = addSimpleStrictHandler();\n  StrictMock<MockHTTPHandler> uniHandler;\n\n  cHandler->expectHeaders([&] {\n      auto* uniTxn = cHandler->txn_->newExTransaction(&uniHandler, true);\n      EXPECT_TRUE(uniTxn->isIngressComplete());\n      uniTxn->sendHeaders(getGetRequest(\"/uni\"));\n      uniTxn->sendEOM();\n\n      // close control stream\n      cHandler->txn_->sendHeadersWithEOM(getResponse(200, 0));\n    });\n\n  EXPECT_CALL(uniHandler, setTransaction(_));\n  EXPECT_CALL(*cHandler, onEOM());\n  EXPECT_CALL(uniHandler, detachTransaction());\n  EXPECT_CALL(*cHandler, detachTransaction());\n\n  transport_->addReadEvent(requests_, milliseconds(0));\n  transport_->startReadEvents();\n  eventBase_.runAfterDelay([&] {\n      transport_->addReadEOF(milliseconds(0));\n    }, 100);\n\n  HTTPSession::DestructorGuard g(httpSession_);\n  expectDetachSession();\n  eventBase_.loop();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, PauseResumeControlStream) {\n  auto cStreamId = HTTPCodec::StreamID(1);\n  SetupControlStream(cStreamId);\n\n  // generate an EX_HEADERS\n  clientCodec_->generateExHeader(requests_, cStreamId + 2, getGetRequest(),\n                                 HTTPCodec::ExAttributes(cStreamId, false),\n                                 true, nullptr);\n\n  auto cHandler = addSimpleStrictHandler();\n  cHandler->expectHeaders([&] {\n      cHandler->txn_->pauseIngress();\n      // send back the response for control stream, but EOM\n      cHandler->txn_->sendHeaders(getResponse(200, 0));\n    });\n  EXPECT_CALL(*cHandler, onEOM());\n\n  StrictMock<MockHTTPHandler> pubHandler;\n  EXPECT_CALL(*cHandler, onExTransaction(_))\n    .WillOnce(Invoke([&pubHandler] (HTTPTransaction* exTxn) {\n          exTxn->setHandler(&pubHandler);\n          pubHandler.txn_ = exTxn;\n        }));\n\n  InSequence handlerSequence;\n  EXPECT_CALL(pubHandler, setTransaction(_));\n  pubHandler.expectHeaders([&] {\n      // send back the response for the pub request\n      pubHandler.txn_->sendHeadersWithEOM(getResponse(200, 0));\n    });\n  EXPECT_CALL(pubHandler, onEOM());\n  EXPECT_CALL(pubHandler, detachTransaction());\n  cHandler->expectDetachTransaction();\n\n  EXPECT_CALL(callbacks_, onMessageBegin(cStreamId, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(cStreamId, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(cStreamId + 2, _));\n  EXPECT_CALL(callbacks_, onMessageComplete(cStreamId + 2, _));\n  EXPECT_CALL(callbacks_, onMessageComplete(cStreamId, _));\n\n  HTTPSession::DestructorGuard g(httpSession_);\n  transport_->addReadEvent(requests_, milliseconds(0));\n  transport_->addReadEOF(milliseconds(0));\n  transport_->startReadEvents();\n  eventBase_.loop();\n\n  cHandler->txn_->resumeIngress();\n  cHandler->txn_->sendEOM();\n  eventBase_.loop();\n\n  expectDetachSession();\n  parseOutput(*clientCodec_);\n}\n\nTEST_F(HTTP2DownstreamSessionTest, InvalidControlStream) {\n  auto cStreamId = HTTPCodec::StreamID(1);\n  SetupControlStream(cStreamId);\n\n  // generate an EX_HEADERS, but with a non-existing control stream\n  clientCodec_->generateExHeader(requests_, cStreamId + 2, getGetRequest(),\n                                 HTTPCodec::ExAttributes(cStreamId + 4, false),\n                                 true, nullptr);\n\n  auto cHandler = addSimpleStrictHandler();\n  InSequence handlerSequence;\n  cHandler->expectHeaders([&] {\n      // send back the response for control stream, but EOM\n      cHandler->txn_->sendHeaders(getResponse(200, 0));\n    });\n  EXPECT_CALL(*cHandler, onExTransaction(_)).Times(0);\n  EXPECT_CALL(*cHandler, onEOM());\n  cHandler->expectDetachTransaction();\n\n  EXPECT_CALL(callbacks_, onMessageBegin(cStreamId, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(cStreamId, _));\n  EXPECT_CALL(callbacks_, onAbort(cStreamId + 2, _));\n\n  HTTPSession::DestructorGuard g(httpSession_);\n  transport_->addReadEvent(requests_, milliseconds(0));\n  transport_->addReadEOF(milliseconds(0));\n  transport_->startReadEvents();\n  eventBase_.loop();\n\n  cHandler->txn_->sendEOM();\n  eventBase_.loop();\n\n  expectDetachSession();\n  parseOutput(*clientCodec_);\n}\n\nTEST_F(HTTP2DownstreamSessionTest, SetByteEventTracker) {\n  InSequence enforceOrder;\n\n  // Send two requests with writes paused, which will queue several byte events,\n  // including last byte events which are holding a reference to the\n  // transaction.\n  transport_->pauseWrites();\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1] () {\n      handler1->sendReplyWithBody(200, 100);\n    });\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&handler2] () {\n      handler2->sendReplyWithBody(200, 100);\n    });\n\n  sendRequest();\n  sendRequest();\n  // Resume writes from the loop callback\n  eventBase_.runInLoop([this] {\n      transport_->resumeWrites();\n    });\n\n  // Graceful shutdown will notify of GOAWAY\n  EXPECT_CALL(*handler1, onGoaway(ErrorCode::NO_ERROR));\n  EXPECT_CALL(*handler2, onGoaway(ErrorCode::NO_ERROR));\n  // The original byteEventTracker will process the last byte event of the\n  // first transaction, and detach by deleting the event.  Swap out the tracker.\n  handler1->expectDetachTransaction([this] {\n      auto tracker = std::make_unique<ByteEventTracker>(httpSession_);\n      httpSession_->setByteEventTracker(std::move(tracker));\n    });\n  // handler2 should also be detached immediately because the new\n  // ByteEventTracker continues procesing where the old one left off.\n  handler2->expectDetachTransaction();\n  gracefulShutdown();\n}\n\nTEST_F(HTTPDownstreamSessionTest, TestTrackedByteEventTracker) {\n  auto byteEventTracker = setMockByteEventTracker();\n  InSequence enforceOrder;\n\n  auto handler1 = addSimpleStrictHandler();\n  size_t bytesToSend = 200;\n  size_t expectedTrackedByteOffset = bytesToSend + 99;\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1, &bytesToSend] () {\n    handler1->sendHeaders(200, 200);\n    handler1->sendBodyWithLastByteTracking(bytesToSend);\n    handler1->txn_->sendEOM();\n    });\n\n  EXPECT_CALL(*byteEventTracker,\n    addTrackedByteEvent(_, expectedTrackedByteOffset))\n      .WillOnce(Invoke([] (HTTPTransaction* txn,\n                           uint64_t /*byteNo*/) {\n                         txn->incrementPendingByteEvents();\n                       }));\n  sendRequest();\n  flushRequestsAndLoop();\n  handler1->expectDetachTransaction();\n  handler1->txn_->decrementPendingByteEvents();\n  gracefulShutdown();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, Trailers) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders();\n  handler->expectEOM([&handler]() {\n    handler->sendReplyWithBody(\n        200, 100, true /* keepalive */, true /* sendEOM */, true /*trailers*/);\n  });\n  handler->expectDetachTransaction();\n\n  HTTPSession::DestructorGuard g(httpSession_);\n  sendRequest();\n  flushRequestsAndLoop(true, milliseconds(0));\n\n  EXPECT_CALL(callbacks_, onMessageBegin(1, _)).Times(1);\n  EXPECT_CALL(callbacks_, onHeadersComplete(1, _)).Times(1);\n  EXPECT_CALL(callbacks_, onBody(1, _, _));\n  EXPECT_CALL(callbacks_, onTrailersComplete(1, _));\n  EXPECT_CALL(callbacks_, onMessageComplete(1, _));\n\n  parseOutput(*clientCodec_);\n  expectDetachSession();\n}\n\nTEST_F(HTTPDownstreamSessionTest, Trailers) {\n  testChunks(true);\n}\n\nTEST_F(HTTPDownstreamSessionTest, ExplicitChunks) {\n  testChunks(false);\n}\n\ntemplate <class C>\nvoid HTTPDownstreamTest<C>::testChunks(bool trailers) {\n  InSequence enforceOrder;\n\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders();\n  handler->expectEOM([&handler, trailers] () {\n      handler->sendChunkedReplyWithBody(200, 100, 17, trailers);\n    });\n  handler->expectDetachTransaction();\n\n  HTTPSession::DestructorGuard g(httpSession_);\n  sendRequest();\n  flushRequestsAndLoop(true, milliseconds(0));\n\n  EXPECT_CALL(callbacks_, onMessageBegin(1, _))\n    .Times(1);\n  EXPECT_CALL(callbacks_, onHeadersComplete(1, _))\n    .Times(1);\n  for (int i = 0; i < 6; i++) {\n    EXPECT_CALL(callbacks_, onChunkHeader(1, _));\n    EXPECT_CALL(callbacks_, onBody(1, _, _));\n    EXPECT_CALL(callbacks_, onChunkComplete(1));\n  }\n  if (trailers) {\n    EXPECT_CALL(callbacks_, onTrailersComplete(1, _));\n  }\n  EXPECT_CALL(callbacks_, onMessageComplete(1, _));\n\n  parseOutput(*clientCodec_);\n  expectDetachSession();\n}\n\nTEST_F(HTTPDownstreamSessionTest, HttpDrain) {\n  InSequence enforceOrder;\n\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders([this, &handler1] {\n      handler1->sendHeaders(200, 100);\n      httpSession_->notifyPendingShutdown();\n    });\n  handler1->expectEOM([&handler1] {\n      handler1->sendBody(100);\n      handler1->txn_->sendEOM();\n    });\n  handler1->expectDetachTransaction();\n\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders([&handler2] {\n      handler2->sendHeaders(200, 100);\n    });\n  handler2->expectEOM([&handler2] {\n          handler2->sendBody(100);\n          handler2->txn_->sendEOM();\n    });\n  handler2->expectDetachTransaction();\n\n  expectDetachSession();\n\n  sendRequest();\n  sendRequest();\n  flushRequestsAndLoop();\n}\n\n// 1) receive full request\n// 2) notify pending shutdown\n// 3) wait for session read timeout -> should be ignored\n// 4) response completed\nTEST_F(HTTPDownstreamSessionTest, HttpDrainLongRunning) {\n  InSequence enforceSequence;\n\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders([this, &handler] {\n      httpSession_->notifyPendingShutdown();\n      eventBase_.tryRunAfterDelay([this] {\n          // simulate read timeout\n          httpSession_->timeoutExpired();\n        }, 100);\n      eventBase_.tryRunAfterDelay([&handler] {\n          handler->sendReplyWithBody(200, 100);\n        }, 200);\n    });\n  handler->expectEOM();\n  handler->expectDetachTransaction();\n\n  expectDetachSession();\n\n  sendRequest();\n  flushRequestsAndLoop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, EarlyAbort) {\n  StrictMock<MockHTTPHandler> handler;\n\n  InSequence enforceOrder;\n  EXPECT_CALL(mockController_, getRequestHandler(_, _))\n    .WillOnce(Return(&handler));\n\n  EXPECT_CALL(handler, setTransaction(_))\n    .WillOnce(Invoke([&] (HTTPTransaction* txn) {\n          handler.txn_ = txn;\n          handler.txn_->sendAbort();\n        }));\n  handler.expectDetachTransaction();\n  expectDetachSession();\n\n  addSingleByteReads(\"GET /somepath.php?param=foo HTTP/1.1\\r\\n\"\n                     \"Host: example.com\\r\\n\"\n                     \"Connection: close\\r\\n\"\n                     \"\\r\\n\");\n  transport_->addReadEOF(milliseconds(0));\n  transport_->startReadEvents();\n  eventBase_.loop();\n}\n\nTEST_F(SPDY3DownstreamSessionTest, HttpPausedBuffered) {\n  IOBufQueue rst{IOBufQueue::cacheChainLength()};\n  auto s = sendRequest();\n  clientCodec_->generateRstStream(rst, s, ErrorCode::CANCEL);\n  sendRequest();\n\n  InSequence handlerSequence;\n  auto handler1 = addSimpleNiceHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1, this] {\n      transport_->pauseWrites();\n      handler1->sendHeaders(200, 65536 * 2);\n      handler1->sendBody(65536 * 2);\n    });\n  handler1->expectEgressPaused();\n  auto handler2 = addSimpleNiceHandler();\n  handler2->expectEgressPaused();\n  handler2->expectHeaders();\n  handler2->expectEOM([&] {\n      eventBase_.runInLoop([&] {\n          transport_->addReadEvent(rst, milliseconds(0)); });\n    });\n  handler1->expectError([&] (const HTTPException& ex) {\n      ASSERT_EQ(ex.getProxygenError(), kErrorStreamAbort);\n      resumeWritesInLoop();\n    });\n  handler1->expectDetachTransaction();\n  handler2->expectEgressResumed([&] {\n      handler2->sendReplyWithBody(200, 32768);\n    });\n  handler2->expectDetachTransaction([this] {\n      eventBase_.runInLoop([&] { transport_->addReadEOF(milliseconds(0)); });\n    });\n  expectDetachSession();\n\n  flushRequestsAndLoop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, HttpWritesDrainingTimeout) {\n  sendRequest();\n  sendHeader();\n\n  InSequence handlerSequence;\n  auto handler1 = addSimpleNiceHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1, this] {\n      transport_->pauseWrites();\n      handler1->sendHeaders(200, 1000);\n    });\n  handler1->expectError([&] (const HTTPException& ex) {\n      ASSERT_EQ(ex.getProxygenError(), kErrorWriteTimeout);\n      ASSERT_EQ(\n        folly::to<std::string>(\"WriteTimeout on transaction id: \",\n                               handler1->txn_->getID()),\n        std::string(ex.what()));\n      handler1->txn_->sendAbort();\n    });\n  handler1->expectDetachTransaction();\n  expectDetachSession();\n\n  flushRequestsAndLoop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, HttpRateLimitNormal) {\n  // The rate-limiting code grabs the event base from the EventBaseManager,\n  // so we need to set it.\n  folly::EventBaseManager::get()->setEventBase(&eventBase_, false);\n\n  // Create a request\n  sendRequest();\n\n  InSequence handlerSequence;\n\n  // Set a low rate-limit on the transaction\n  auto handler1 = addSimpleNiceHandler();\n  handler1->expectHeaders([&] {\n      uint32_t rateLimit_kbps = 640;\n      handler1->txn_->setEgressRateLimit(rateLimit_kbps * 1024);\n    });\n  // Send a somewhat big response that we know will get rate-limited\n  handler1->expectEOM([&handler1] {\n      // At 640kbps, this should take slightly over 800ms\n      uint32_t rspLengthBytes = 100000;\n      handler1->sendHeaders(200, rspLengthBytes);\n      handler1->sendBody(rspLengthBytes);\n      handler1->txn_->sendEOM();\n    });\n  handler1->expectDetachTransaction();\n\n  // Keep the session around even after the event base loop completes so we can\n  // read the counters on a valid object.\n  HTTPSession::DestructorGuard g(httpSession_);\n  flushRequestsAndLoop();\n\n  proxygen::TimePoint timeFirstWrite =\n    transport_->getWriteEvents()->front()->getTime();\n  proxygen::TimePoint timeLastWrite =\n    transport_->getWriteEvents()->back()->getTime();\n  int64_t writeDuration =\n    (int64_t)millisecondsBetween(timeLastWrite, timeFirstWrite).count();\n  EXPECT_GE(writeDuration, 800);\n\n  cleanup();\n}\n\nTEST_F(SPDY3DownstreamSessionTest, SpdyRateLimitNormal) {\n  // The rate-limiting code grabs the event base from the EventBaseManager,\n  // so we need to set it.\n  folly::EventBaseManager::get()->setEventBase(&eventBase_, false);\n\n  clientCodec_->getEgressSettings()->setSetting(SettingsId::INITIAL_WINDOW_SIZE,\n                                                100000);\n  clientCodec_->generateSettings(requests_);\n  sendRequest();\n\n  InSequence handlerSequence;\n  auto handler1 = addSimpleNiceHandler();\n  handler1->expectHeaders([&] {\n      uint32_t rateLimit_kbps = 640;\n      handler1->txn_->setEgressRateLimit(rateLimit_kbps * 1024);\n    });\n\n  handler1->expectEOM([&handler1] {\n      // At 640kbps, this should take slightly over 800ms\n      uint32_t rspLengthBytes = 100000;\n      handler1->sendHeaders(200, rspLengthBytes);\n      handler1->sendBody(rspLengthBytes);\n      handler1->txn_->sendEOM();\n    });\n  handler1->expectDetachTransaction();\n\n  // Keep the session around even after the event base loop completes so we can\n  // read the counters on a valid object.\n  HTTPSession::DestructorGuard g(httpSession_);\n  flushRequestsAndLoop(true, milliseconds(50));\n\n  proxygen::TimePoint timeFirstWrite =\n    transport_->getWriteEvents()->front()->getTime();\n  proxygen::TimePoint timeLastWrite =\n    transport_->getWriteEvents()->back()->getTime();\n  int64_t writeDuration =\n    (int64_t)millisecondsBetween(timeLastWrite, timeFirstWrite).count();\n  EXPECT_GE(writeDuration, 800);\n  expectDetachSession();\n}\n\n/**\n * This test will reset the connection while the server is waiting around\n * to send more bytes (so as to keep under the rate limit).\n */\nTEST_F(SPDY3DownstreamSessionTest, SpdyRateLimitRst) {\n  // The rate-limiting code grabs the event base from the EventBaseManager,\n  // so we need to set it.\n  folly::EventBaseManager::get()->setEventBase(&eventBase_, false);\n\n  IOBufQueue rst{IOBufQueue::cacheChainLength()};\n  clientCodec_->getEgressSettings()->setSetting(SettingsId::INITIAL_WINDOW_SIZE,\n                                                100000);\n  clientCodec_->generateSettings(requests_);\n  auto streamID = sendRequest();\n  clientCodec_->generateRstStream(rst, streamID, ErrorCode::CANCEL);\n\n  InSequence handlerSequence;\n  auto handler1 = addSimpleNiceHandler();\n  handler1->expectHeaders([&] {\n      uint32_t rateLimit_kbps = 640;\n      handler1->txn_->setEgressRateLimit(rateLimit_kbps * 1024);\n    });\n  handler1->expectEOM([&handler1] {\n      uint32_t rspLengthBytes = 100000;\n      handler1->sendHeaders(200, rspLengthBytes);\n      handler1->sendBody(rspLengthBytes);\n      handler1->txn_->sendEOM();\n    });\n  handler1->expectError();\n  handler1->expectDetachTransaction();\n  expectDetachSession();\n\n  flushRequestsAndLoop(true, milliseconds(50), milliseconds(0), [&] {\n      transport_->addReadEvent(rst, milliseconds(10));\n    });\n}\n\n// Send a 1.0 request, egress the EOM with the last body chunk on a paused\n// socket, and let it timeout.  dropConnection()\n// to removeTransaction with writesDraining_=true\nTEST_F(HTTPDownstreamSessionTest, WriteTimeout) {\n  HTTPMessage req = getGetRequest();\n  req.setHTTPVersion(1, 0);\n  sendRequest(req);\n\n  InSequence handlerSequence;\n  auto handler1 = addSimpleNiceHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1, this] {\n      handler1->sendHeaders(200, 100);\n      eventBase_.tryRunAfterDelay([&handler1, this] {\n          transport_->pauseWrites();\n          handler1->sendBody(100);\n          handler1->txn_->sendEOM();\n        }, 50);\n    });\n  handler1->expectError([&] (const HTTPException& ex) {\n      ASSERT_EQ(ex.getProxygenError(), kErrorWriteTimeout);\n      ASSERT_EQ(folly::to<std::string>(\"WriteTimeout on transaction id: \",\n                                       handler1->txn_->getID()),\n                std::string(ex.what()));\n    });\n  handler1->expectDetachTransaction();\n\n  expectDetachSession();\n\n  flushRequestsAndLoop();\n}\n\n// Send an abort from the write timeout path while pipelining\nTEST_F(HTTPDownstreamSessionTest, WriteTimeoutPipeline) {\n  const char* buf = \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\"\n    \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\";\n  requests_.append(buf, strlen(buf));\n\n  InSequence handlerSequence;\n  auto handler1 = addSimpleNiceHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1, this] {\n      handler1->sendHeaders(200, 100);\n      eventBase_.tryRunAfterDelay([&handler1, this] {\n          transport_->pauseWrites();\n          handler1->sendBody(100);\n          handler1->txn_->sendEOM();\n        }, 50);\n    });\n  auto handler2 = addSimpleNiceHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM();\n  handler1->expectError([&] (const HTTPException& ex) {\n      ASSERT_EQ(ex.getProxygenError(), kErrorWriteTimeout);\n      ASSERT_EQ(folly::to<std::string>(\"WriteTimeout on transaction id: \",\n                                       handler1->txn_->getID()),\n                std::string(ex.what()));\n      handler1->txn_->sendAbort();\n    });\n  handler2->expectError([&] (const HTTPException& ex) {\n      ASSERT_EQ(ex.getProxygenError(), kErrorWriteTimeout);\n      ASSERT_EQ(folly::to<std::string>(\"WriteTimeout on transaction id: \",\n                                       handler2->txn_->getID()),\n                std::string(ex.what()));\n      handler2->txn_->sendAbort();\n    });\n  handler2->expectDetachTransaction();\n  handler1->expectDetachTransaction();\n  expectDetachSession();\n\n  flushRequestsAndLoop();\n}\n\nTEST_F(HTTPDownstreamSessionTest, BodyPacketization) {\n  HTTPMessage req = getGetRequest();\n  req.setHTTPVersion(1, 0);\n  req.setWantsKeepalive(false);\n  sendRequest(req);\n\n  InSequence handlerSequence;\n  auto handler1 = addSimpleNiceHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1] {\n      handler1->sendReplyWithBody(200, 32768);\n    });\n  handler1->expectDetachTransaction();\n\n  expectDetachSession();\n\n  // Keep the session around even after the event base loop completes so we can\n  // read the counters on a valid object.\n  HTTPSession::DestructorGuard g(httpSession_);\n  flushRequestsAndLoop();\n\n  EXPECT_EQ(transport_->getWriteEvents()->size(), 1);\n}\n\nTEST_F(HTTPDownstreamSessionTest, HttpMalformedPkt1) {\n  // Create a HTTP connection and keep sending just '\\n' to the HTTP1xCodec.\n  std::string data(90000, '\\n');\n  requests_.append(data.data(), data.length());\n\n  expectDetachSession();\n\n  flushRequestsAndLoop(true, milliseconds(0));\n}\n\nTEST_F(HTTPDownstreamSessionTest, BigExplcitChunkWrite) {\n  // even when the handler does a massive write, the transport only gets small\n  // writes\n  sendRequest();\n\n  auto handler = addSimpleNiceHandler();\n  handler->expectHeaders([&handler] {\n      handler->sendHeaders(200, 100, false);\n      size_t len = 16 * 1024 * 1024;\n      handler->txn_->sendChunkHeader(len);\n      auto chunk = makeBuf(len);\n      handler->txn_->sendBody(std::move(chunk));\n      handler->txn_->sendChunkTerminator();\n      handler->txn_->sendEOM();\n    });\n  handler->expectDetachTransaction();\n\n  expectDetachSession();\n\n  // Keep the session around even after the event base loop completes so we can\n  // read the counters on a valid object.\n  HTTPSession::DestructorGuard g(httpSession_);\n  flushRequestsAndLoop();\n\n  EXPECT_GT(transport_->getWriteEvents()->size(), 250);\n}\n\n\n// ==== upgrade tests ====\n\n// Test upgrade to a protocol unknown to HTTPSession\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNonNative) {\n  auto handler = addSimpleStrictHandler();\n\n  handler->expectHeaders([&handler] {\n      handler->sendHeaders(101, 0, true, {{\"Upgrade\", \"blarf\"}});\n    });\n  EXPECT_CALL(*handler, onUpgrade(UpgradeProtocol::TCP));\n  handler->expectEOM([&handler] {\n      handler->txn_->sendEOM();\n    });\n  handler->expectDetachTransaction();\n\n  sendRequest(getUpgradeRequest(\"blarf\"));\n  expectDetachSession();\n  flushRequestsAndLoop(true);\n}\n\n// Test upgrade to a protocol unknown to HTTPSession, but don't switch\n// protocols\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNonNativeIgnore) {\n  auto handler = addSimpleStrictHandler();\n\n  handler->expectHeaders([&handler] {\n      handler->sendReplyWithBody(200, 100);\n    });\n  handler->expectEOM();\n  handler->expectDetachTransaction();\n\n  sendRequest(getUpgradeRequest(\"blarf\"));\n\n  expectDetachSession();\n  flushRequestsAndLoop(true);\n}\n\n\n// Test upgrade to a protocol unknown to HTTPSession\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNonNativePipeline) {\n  auto handler1 = addSimpleStrictHandler();\n\n  handler1->expectHeaders([&handler1] (std::shared_ptr<HTTPMessage> msg) {\n      EXPECT_EQ(msg->getHeaders().getSingleOrEmpty(HTTP_HEADER_UPGRADE),\n                \"blarf\");\n      handler1->sendReplyWithBody(200, 100);\n    });\n  handler1->expectEOM();\n  handler1->expectDetachTransaction();\n\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders([&handler2] {\n      handler2->sendReplyWithBody(200, 100);\n    });\n  handler2->expectEOM();\n  handler2->expectDetachTransaction();\n\n  sendRequest(getUpgradeRequest(\"blarf\"));\n  transport_->addReadEvent(\"GET / HTTP/1.1\\r\\n\"\n                           \"\\r\\n\");\n  expectDetachSession();\n  flushRequestsAndLoop(true);\n}\n\n// Helper that does a simple upgrade test - request an upgrade, receive a 101\n// and an upgraded response\ntemplate <class C>\nvoid HTTPDownstreamTest<C>::testSimpleUpgrade(\n  const std::string& upgradeHeader,\n  CodecProtocol expectedProtocol,\n  const std::string& expectedUpgradeHeader) {\n  this->rawCodec_->setAllowedUpgradeProtocols({expectedUpgradeHeader});\n\n  auto handler = addSimpleStrictHandler();\n\n  HeaderIndexingStrategy testH2IndexingStrat;\n  handler->expectHeaders();\n  EXPECT_CALL(mockController_, onSessionCodecChange(httpSession_));\n  handler->expectEOM(\n    [&handler, expectedProtocol, expectedUpgradeHeader, &testH2IndexingStrat] {\n      EXPECT_FALSE(handler->txn_->getSetupTransportInfo().secure);\n      EXPECT_EQ(*handler->txn_->getSetupTransportInfo().appProtocol,\n                expectedUpgradeHeader);\n      if (expectedProtocol == CodecProtocol::HTTP_2) {\n        const HTTP2Codec* codec = dynamic_cast<const HTTP2Codec*>(\n          &handler->txn_->getTransport().getCodec());\n        ASSERT_NE(codec, nullptr);\n        EXPECT_EQ(codec->getHeaderIndexingStrategy(), &testH2IndexingStrat);\n      }\n      handler->sendReplyWithBody(200, 100);\n    });\n  handler->expectDetachTransaction();\n\n  if (expectedProtocol == CodecProtocol::HTTP_2) {\n    EXPECT_CALL(mockController_, getHeaderIndexingStrategy())\n      .WillOnce(\n        Return(&testH2IndexingStrat)\n    );\n  }\n\n  HTTPMessage req = getUpgradeRequest(upgradeHeader);\n  if (upgradeHeader == http2::kProtocolCleartextString) {\n    HTTP2Codec::requestUpgrade(req);\n  }\n  sendRequest(req);\n  flushRequestsAndLoop();\n\n  expect101(expectedProtocol, expectedUpgradeHeader);\n  expectResponse();\n\n  gracefulShutdown();\n}\n\n// Upgrade to SPDY/3\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNative3) {\n  testSimpleUpgrade(\"spdy/3\", CodecProtocol::SPDY_3, \"spdy/3\");\n}\n\n// Upgrade to SPDY/3.1\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNative31) {\n  testSimpleUpgrade(\"spdy/3.1\", CodecProtocol::SPDY_3_1, \"spdy/3.1\");\n}\n\n// Upgrade to HTTP/2\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativeH2) {\n  testSimpleUpgrade(\"h2c\", CodecProtocol::HTTP_2, \"h2c\");\n}\n\nclass HTTPDownstreamSessionUpgradeFlowControlTest :\n      public HTTPDownstreamSessionTest {\n public:\n  HTTPDownstreamSessionUpgradeFlowControlTest()\n      : HTTPDownstreamSessionTest({100000, 105000, 110000}) {}\n};\n\n// Upgrade to HTTP/2, with non-default flow control settings\nTEST_F(HTTPDownstreamSessionUpgradeFlowControlTest, UpgradeH2Flowcontrol) {\n  testSimpleUpgrade(\"h2c\", CodecProtocol::HTTP_2, \"h2c\");\n}\n\n// Upgrade to SPDY/3.1 with a non-native proto in the list\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativeUnknown) {\n  // This is maybe weird, the client asked for non-native as first choice,\n  // but we go native\n  testSimpleUpgrade(\"blarf, spdy/3.1, spdy/3\",\n                    CodecProtocol::SPDY_3_1, \"spdy/3.1\");\n}\n\n// Upgrade header with extra whitespace\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativeWhitespace) {\n  testSimpleUpgrade(\" \\tspdy/3.1\\t , spdy/3\",\n                    CodecProtocol::SPDY_3_1, \"spdy/3.1\");\n}\n\n// Upgrade header with random junk\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativeJunk) {\n  testSimpleUpgrade(\",,,,   ,,\\t~^%$(*&@(@$^^*(,spdy/3\",\n                    CodecProtocol::SPDY_3, \"spdy/3\");\n}\n\n// Attempt to upgrade on second txn\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativeTxn2) {\n  this->rawCodec_->setAllowedUpgradeProtocols({\"spdy/3\"});\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1] {\n      handler1->sendReplyWithBody(200, 100);\n    });\n  handler1->expectDetachTransaction();\n  sendRequest(getGetRequest());\n  flushRequestsAndLoop();\n  expectResponse();\n\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&handler2] {\n      handler2->sendReplyWithBody(200, 100);\n    });\n  handler2->expectDetachTransaction();\n\n  sendRequest(getUpgradeRequest(\"spdy/3\"));\n  flushRequestsAndLoop();\n  expectResponse();\n  gracefulShutdown();\n}\n\n// Upgrade on POST\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativePost) {\n  this->rawCodec_->setAllowedUpgradeProtocols({\"spdy/3\"});\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders();\n  handler->expectBody();\n  EXPECT_CALL(mockController_, onSessionCodecChange(httpSession_));\n  handler->expectEOM([&handler] {\n      handler->sendReplyWithBody(200, 100);\n    });\n  handler->expectDetachTransaction();\n\n  HTTPMessage req = getUpgradeRequest(\"spdy/3\", HTTPMethod::POST, 10);\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateBody(requests_, streamID, makeBuf(10),\n                             HTTPCodec::NoPadding, true);\n  // cheat and not sending EOM, it's a no-op\n  flushRequestsAndLoop();\n  expect101(CodecProtocol::SPDY_3, \"spdy/3\");\n  expectResponse();\n  gracefulShutdown();\n}\n\n// Upgrade on POST with a reply that comes before EOM, don't switch protocols\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativePostEarlyResp) {\n  this->rawCodec_->setAllowedUpgradeProtocols({\"spdy/3\"});\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders([&handler] {\n      handler->sendReplyWithBody(200, 100);\n    });\n  handler->expectBody();\n  handler->expectEOM();\n  handler->expectDetachTransaction();\n\n  HTTPMessage req = getUpgradeRequest(\"spdy/3\", HTTPMethod::POST, 10);\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateBody(requests_, streamID, makeBuf(10),\n                             HTTPCodec::NoPadding, true);\n  flushRequestsAndLoop();\n  expectResponse();\n  gracefulShutdown();\n}\n\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativePostEarlyPartialResp) {\n  this->rawCodec_->setAllowedUpgradeProtocols({\"spdy/3\"});\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders([&handler] {\n      handler->sendHeaders(200, 100);\n    });\n  handler->expectBody();\n  handler->expectEOM([&handler] {\n      handler->sendBody(100);\n      handler->txn_->sendEOM();\n    });\n  handler->expectDetachTransaction();\n\n  HTTPMessage req = getUpgradeRequest(\"spdy/3\", HTTPMethod::POST, 10);\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateBody(requests_, streamID, makeBuf(10),\n                             HTTPCodec::NoPadding, true);\n  flushRequestsAndLoop();\n  expectResponse();\n  gracefulShutdown();\n}\n\n// Upgrade but with a pipelined HTTP request.  It is parsed as SPDY and\n// rejected\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativeExtra) {\n  this->rawCodec_->setAllowedUpgradeProtocols({\"spdy/3\"});\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders();\n  EXPECT_CALL(mockController_, onSessionCodecChange(httpSession_));\n  handler->expectEOM([&handler] {\n      handler->sendReplyWithBody(200, 100);\n    });\n  handler->expectDetachTransaction();\n\n  sendRequest(getUpgradeRequest(\"spdy/3\"));\n  // It's a fatal to send this out on the HTTP1xCodec, so hack it manually\n  transport_->addReadEvent(\"GET / HTTP/1.1\\r\\n\"\n                           \"Upgrade: spdy/3\\r\\n\"\n                           \"\\r\\n\");\n  flushRequestsAndLoop();\n  expect101(CodecProtocol::SPDY_3, \"spdy/3\");\n  expectResponse(200, ErrorCode::_SPDY_INVALID_STREAM);\n  gracefulShutdown();\n}\n\n// Upgrade on POST with Expect: 100-Continue.  If the 100 goes out\n// before the EOM is parsed, the 100 will be in HTTP.  This should be the normal\n// case since the client *should* wait a bit for the 100 continue to come back\n// before sending the POST.  But if the 101 is delayed beyond EOM, the 101\n// will come via SPDY.\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativePost100) {\n  this->rawCodec_->setAllowedUpgradeProtocols({\"spdy/3\"});\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders([&handler] {\n      handler->sendHeaders(100, 0);\n    });\n  handler->expectBody();\n  EXPECT_CALL(mockController_, onSessionCodecChange(httpSession_));\n  handler->expectEOM([&handler] {\n      handler->sendReplyWithBody(200, 100);\n    });\n  handler->expectDetachTransaction();\n\n  HTTPMessage req = getUpgradeRequest(\"spdy/3\", HTTPMethod::POST, 10);\n  req.getHeaders().add(HTTP_HEADER_EXPECT, \"100-continue\");\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateBody(requests_, streamID, makeBuf(10),\n                             HTTPCodec::NoPadding, true);\n  flushRequestsAndLoop();\n  expect101(CodecProtocol::SPDY_3, \"spdy/3\", true /* expect 100 continue */);\n  expectResponse();\n  gracefulShutdown();\n}\n\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeNativePost100Late) {\n  this->rawCodec_->setAllowedUpgradeProtocols({\"spdy/3\"});\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders();\n  handler->expectBody();\n  EXPECT_CALL(mockController_, onSessionCodecChange(httpSession_));\n  handler->expectEOM([&handler] {\n      handler->sendHeaders(100, 0);\n      handler->sendReplyWithBody(200, 100);\n    });\n  handler->expectDetachTransaction();\n\n  HTTPMessage req = getUpgradeRequest(\"spdy/3\", HTTPMethod::POST, 10);\n  req.getHeaders().add(HTTP_HEADER_EXPECT, \"100-continue\");\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateBody(requests_, streamID, makeBuf(10),\n                             HTTPCodec::NoPadding, true);\n  flushRequestsAndLoop();\n  expect101(CodecProtocol::SPDY_3, \"spdy/3\");\n  expectResponse(200, ErrorCode::NO_ERROR, true /* expect 100 via SPDY */);\n  gracefulShutdown();\n}\n\n\nTEST_F(SPDY3DownstreamSessionTest, SpdyPrio) {\n  testPriorities(8);\n\n  cleanup();\n}\n\n// Test sending a GOAWAY while the downstream session is still processing\n// the request that was an upgrade.  The reply GOAWAY should have last good\n// stream = 1, not 0.\nTEST_F(HTTPDownstreamSessionTest, HttpUpgradeGoawayDrain) {\n  this->rawCodec_->setAllowedUpgradeProtocols({\"h2c\"});\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders();\n  handler->expectBody();\n  EXPECT_CALL(mockController_, onSessionCodecChange(httpSession_));\n  handler->expectEOM();\n  handler->expectGoaway();\n  handler->expectDetachTransaction();\n\n  EXPECT_CALL(mockController_, getHeaderIndexingStrategy())\n    .WillOnce(\n      Return(&testH2IndexingStrat_)\n  );\n\n  HTTPMessage req = getUpgradeRequest(\"h2c\", HTTPMethod::POST, 10);\n  HTTP2Codec::requestUpgrade(req);\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateBody(requests_, streamID, makeBuf(10),\n                             HTTPCodec::NoPadding, true);\n  // cheat and not sending EOM, it's a no-op\n\n  flushRequestsAndLoop();\n  expect101(CodecProtocol::HTTP_2, \"h2c\");\n  clientCodec_->generateConnectionPreface(requests_);\n  clientCodec_->generateGoaway(requests_, 0, ErrorCode::NO_ERROR);\n  flushRequestsAndLoop();\n  eventBase_.runInLoop([&handler] {\n      handler->sendReplyWithBody(200, 100);\n    });\n  HTTPSession::DestructorGuard g(httpSession_);\n  eventBase_.loop();\n  expectResponse(200, ErrorCode::NO_ERROR, false, true);\n  expectDetachSession();\n}\n\ntemplate <class C>\nvoid HTTPDownstreamTest<C>::testPriorities(uint32_t numPriorities) {\n  uint32_t iterations = 10;\n  uint32_t maxPriority = numPriorities - 1;\n  std::vector<std::unique_ptr<testing::NiceMock<MockHTTPHandler>>> handlers;\n  for (int pri = numPriorities - 1; pri >= 0; pri--) {\n    for (uint32_t i = 0; i < iterations; i++) {\n      sendRequest(\"/\", pri * (8 / numPriorities));\n      InSequence handlerSequence;\n      auto handler = addSimpleNiceHandler();\n      auto rawHandler = handler.get();\n      handlers.push_back(std::move(handler));\n      rawHandler->expectHeaders();\n      rawHandler->expectEOM([rawHandler] {\n          rawHandler->sendReplyWithBody(200, 1000);\n        });\n      rawHandler->expectDetachTransaction([] {  });\n    }\n  }\n\n  auto buf = requests_.move();\n  buf->coalesce();\n  requests_.append(std::move(buf));\n\n  flushRequestsAndLoop();\n\n  std::list<HTTPCodec::StreamID> streams;\n  EXPECT_CALL(callbacks_, onMessageBegin(_, _))\n    .Times(iterations * numPriorities);\n  EXPECT_CALL(callbacks_, onHeadersComplete(_, _))\n    .Times(iterations * numPriorities);\n  // body is variable and hence ignored\n  EXPECT_CALL(callbacks_, onMessageComplete(_, _))\n      .Times(iterations * numPriorities)\n      .WillRepeatedly(Invoke([&](HTTPCodec::StreamID stream, bool /*upgrade*/) {\n        streams.push_back(stream);\n      }));\n\n  parseOutput(*clientCodec_);\n\n  // transactions finish in priority order (higher streamIDs first)\n  EXPECT_EQ(streams.size(), iterations * numPriorities);\n  auto txn = streams.begin();\n  for (int band = maxPriority; band >= 0; band--) {\n    auto upperID = iterations * 2 * (band + 1);\n    auto lowerID = iterations * 2 * band;\n    for (uint32_t i = 0; i < iterations; i++) {\n      EXPECT_LE(lowerID, (uint32_t)*txn);\n      EXPECT_GE(upperID, (uint32_t)*txn);\n      ++txn;\n    }\n  }\n}\n\n// Verifies that the read timeout is not running when no ingress is expected/\n// required to proceed\nTEST_F(SPDY3DownstreamSessionTest, SpdyTimeout) {\n  sendRequest();\n  sendRequest();\n\n  httpSession_->setWriteBufferLimit(512);\n\n  InSequence handlerSequence;\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders([this] { transport_->pauseWrites(); });\n  handler1->expectEOM([&] {\n      handler1->sendHeaders(200, 1000);\n      handler1->sendBody(1000);\n    });\n  handler1->expectEgressPaused();\n  auto handler2 = addSimpleStrictHandler();\n  // handler2 is paused before it gets headers\n  handler2->expectEgressPaused();\n  handler2->expectHeaders();\n  handler2->expectEOM([this] {\n      // This transaction should start egress paused.  We've received the\n      // EOM, so the timeout shouldn't be running delay 400ms and resume\n      // writes, this keeps txn1 from getting a write timeout\n      resumeWritesAfterDelay(milliseconds(400));\n    });\n  handler1->expectEgressResumed([&handler1] { handler1->txn_->sendEOM(); });\n  handler2->expectEgressResumed([&handler2, this] {\n      // delay an additional 200ms.  The total 600ms delay shouldn't fire\n      // onTimeout\n      eventBase_.tryRunAfterDelay([&handler2] {\n          handler2->sendReplyWithBody(200, 400); }, 200\n        );\n    });\n  handler1->expectDetachTransaction();\n  handler2->expectDetachTransaction();\n\n  flushRequestsAndLoop(false, milliseconds(0), milliseconds(10));\n\n  cleanup();\n}\n\n// Verifies that the read timer is running while a transaction is blocked\n// on a window update\nTEST_F(SPDY3DownstreamSessionTest, SpdyTimeoutWin) {\n  clientCodec_->getEgressSettings()->setSetting(SettingsId::INITIAL_WINDOW_SIZE,\n                                                500);\n  clientCodec_->generateSettings(requests_);\n  auto streamID = sendRequest();\n\n  InSequence handlerSequence;\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders();\n  handler->expectEOM([&] {\n      handler->sendReplyWithBody(200, 1000);\n    });\n  handler->expectEgressPaused();\n  handler->expectError([&] (const HTTPException& ex) {\n      ASSERT_EQ(ex.getProxygenError(), kErrorWriteTimeout);\n      ASSERT_EQ(\n        folly::to<std::string>(\"ingress timeout, streamID=\", streamID),\n        std::string(ex.what()));\n      handler->terminate();\n    });\n  handler->expectDetachTransaction();\n\n  flushRequestsAndLoop();\n\n  cleanup();\n}\n\nTYPED_TEST_CASE_P(HTTPDownstreamTest);\n\nTYPED_TEST_P(HTTPDownstreamTest, TestWritesDraining) {\n  auto badCodec =\n    makeServerCodec<typename TypeParam::Codec>(TypeParam::version);\n  this->sendRequest();\n  badCodec->generatePushPromise(this->requests_, 2 /* bad */, getGetRequest(),\n                                1);\n\n  this->expectDetachSession();\n\n  InSequence handlerSequence;\n  auto handler1 = this->addSimpleNiceHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM();\n  handler1->expectError([&](const HTTPException& ex) {\n    ASSERT_EQ(ex.getProxygenError(), kErrorEOF);\n    ASSERT_TRUE(\n        folly::StringPiece(ex.what()).startsWith(\"Shutdown transport: EOF\"))\n        << ex.what();\n  });\n  handler1->expectDetachTransaction();\n\n  this->flushRequestsAndLoop();\n}\n\nTYPED_TEST_P(HTTPDownstreamTest, TestBodySizeLimit) {\n  this->clientCodec_->generateWindowUpdate(this->requests_, 0, 65536);\n  this->sendRequest();\n  this->sendRequest();\n\n  InSequence handlerSequence;\n  auto handler1 = this->addSimpleNiceHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM();\n  auto handler2 = this->addSimpleNiceHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&] {\n      handler1->sendReplyWithBody(200, 33000);\n      handler2->sendReplyWithBody(200, 33000);\n    });\n  handler1->expectDetachTransaction();\n  handler2->expectDetachTransaction();\n\n  this->flushRequestsAndLoop();\n\n  std::list<HTTPCodec::StreamID> streams;\n  EXPECT_CALL(this->callbacks_, onMessageBegin(1, _));\n  EXPECT_CALL(this->callbacks_, onHeadersComplete(1, _));\n  EXPECT_CALL(this->callbacks_, onMessageBegin(3, _));\n  EXPECT_CALL(this->callbacks_, onHeadersComplete(3, _));\n  for (uint32_t i = 0; i < 8; i++) {\n    EXPECT_CALL(this->callbacks_, onBody(1, _, _));\n    EXPECT_CALL(this->callbacks_, onBody(3, _, _));\n  }\n  EXPECT_CALL(this->callbacks_, onBody(1, _, _));\n  EXPECT_CALL(this->callbacks_, onMessageComplete(1, _));\n  EXPECT_CALL(this->callbacks_, onBody(3, _, _));\n  EXPECT_CALL(this->callbacks_, onMessageComplete(3, _));\n\n  this->parseOutput(*this->clientCodec_);\n\n  this->cleanup();\n}\n\n#define IF_HTTP2(X) \\\n  if (this->clientCodec_->getProtocol() == CodecProtocol::HTTP_2) { X; }\n\nTYPED_TEST_P(HTTPDownstreamTest, TestUniformPauseState) {\n  this->httpSession_->setWriteBufferLimit(12000);\n  this->clientCodec_->getEgressSettings()->setSetting(\n    SettingsId::INITIAL_WINDOW_SIZE, 1000000);\n  this->clientCodec_->generateSettings(this->requests_);\n  this->clientCodec_->generateWindowUpdate(this->requests_, 0, 1000000);\n  this->sendRequest(\"/\", 1);\n  this->sendRequest(\"/\", 1);\n  this->sendRequest(\"/\", 2);\n\n  InSequence handlerSequence;\n  auto handler1 = this->addSimpleStrictHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM();\n  auto handler2 = this->addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&] {\n      handler1->sendHeaders(200, 24002);\n      // triggers pause of all txns\n      this->transport_->pauseWrites();\n      handler1->txn_->sendBody(std::move(makeBuf(12001)));\n      this->resumeWritesAfterDelay(milliseconds(50));\n    });\n  handler1->expectEgressPaused();\n  handler2->expectEgressPaused();\n  auto handler3 = this->addSimpleStrictHandler();\n  handler3->expectEgressPaused();\n  handler3->expectHeaders();\n  handler3->expectEOM();\n\n  handler1->expectEgressResumed([&] {\n      // resume does not trigger another pause,\n      handler1->txn_->sendBody(std::move(makeBuf(12001)));\n    });\n  // handler2 gets a fair shot, handler3 is not resumed\n  // HTTP/2 priority is not implemented, so handler3 is like another 0 pri txn\n  handler2->expectEgressResumed();\n  IF_HTTP2(handler3->expectEgressResumed());\n  handler1->expectEgressPaused();\n  handler2->expectEgressPaused();\n  IF_HTTP2(handler3->expectEgressPaused());\n\n  handler1->expectEgressResumed();\n  handler2->expectEgressResumed([&] {\n      handler2->sendHeaders(200, 12001);\n      handler2->txn_->sendBody(std::move(makeBuf(12001)));\n      this->transport_->pauseWrites();\n      this->resumeWritesAfterDelay(milliseconds(50));\n    });\n  // handler3 not resumed\n  IF_HTTP2(handler3->expectEgressResumed());\n\n  handler1->expectEgressPaused();\n  handler2->expectEgressPaused();\n  IF_HTTP2(handler3->expectEgressPaused());\n\n  handler1->expectEgressResumed();\n  handler2->expectEgressResumed([&] {\n      handler1->txn_->sendEOM();\n      handler2->txn_->sendEOM();\n    });\n  handler3->expectEgressResumed([&] {\n      handler3->txn_->sendAbort();\n    });\n\n  handler3->expectDetachTransaction();\n  handler1->expectDetachTransaction();\n  handler2->expectDetachTransaction();\n\n  this->flushRequestsAndLoop();\n\n  this->cleanup();\n}\n\n// Test exceeding the MAX_CONCURRENT_STREAMS setting.  The txn should get\n// REFUSED_STREAM, and other streams can complete normally\nTYPED_TEST_P(HTTPDownstreamTest, TestMaxTxns) {\n  auto settings = this->rawCodec_->getEgressSettings();\n  auto maxTxns = settings->getSetting(SettingsId::MAX_CONCURRENT_STREAMS,\n                                      100);\n  std::list<unique_ptr<StrictMock<MockHTTPHandler>>> handlers;\n  {\n    InSequence enforceOrder;\n    for (auto i = 0U; i < maxTxns; i++) {\n      this->sendRequest();\n      auto handler = this->addSimpleStrictHandler();\n      handler->expectHeaders();\n      handler->expectEOM();\n      handlers.push_back(std::move(handler));\n    }\n    auto streamID = this->sendRequest();\n    this->clientCodec_->generateGoaway(this->requests_, 0, ErrorCode::NO_ERROR);\n\n    for (auto& handler: handlers) {\n      EXPECT_CALL(*handler, onGoaway(ErrorCode::NO_ERROR));\n    }\n\n    this->flushRequestsAndLoop();\n\n    EXPECT_CALL(this->callbacks_, onSettings(_));\n    EXPECT_CALL(this->callbacks_, onAbort(streamID, ErrorCode::REFUSED_STREAM));\n\n    this->parseOutput(*this->clientCodec_);\n  }\n  // handlers can finish out of order?\n  for (auto& handler: handlers) {\n    handler->sendReplyWithBody(200, 100);\n    handler->expectDetachTransaction();\n  }\n  this->expectDetachSession();\n  this->eventBase_.loop();\n}\n\n// Set max streams=1\n// send two spdy requests a few ms apart.\n// Block writes\n// generate a complete response for txn=1 before parsing txn=3\n// HTTPSession should allow the txn=3 to be served rather than refusing it\nTEST_F(SPDY3DownstreamSessionTest, SpdyMaxConcurrentStreams) {\n  HTTPMessage req = getGetRequest();\n  req.setHTTPVersion(1, 0);\n  req.setWantsKeepalive(false);\n  sendRequest(req);\n  auto req2p = sendRequestLater(req, true);\n\n  httpSession_->setEgressSettings({{\n        SettingsId::MAX_CONCURRENT_STREAMS, 1}});\n\n  InSequence handlerSequence;\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1, req, this, &req2p] {\n      transport_->pauseWrites();\n      handler1->sendReplyWithBody(200, 100);\n      req2p.setValue();\n    });\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&handler2, this] {\n      handler2->sendReplyWithBody(200, 100);\n      resumeWritesInLoop();\n    });\n  handler1->expectDetachTransaction();\n  handler2->expectDetachTransaction();\n\n  expectDetachSession();\n\n  flushRequestsAndLoop();\n}\n\nREGISTER_TYPED_TEST_CASE_P(HTTPDownstreamTest,\n                           TestWritesDraining, TestBodySizeLimit,\n                           TestUniformPauseState, TestMaxTxns);\n\ntypedef ::testing::Types<SPDY3CodecPair, SPDY3_1CodecPair,\n                         HTTP2CodecPair> ParallelCodecs;\nINSTANTIATE_TYPED_TEST_CASE_P(ParallelCodecs,\n                              HTTPDownstreamTest,\n                              ParallelCodecs);\n\nclass SPDY31DownstreamTest : public HTTPDownstreamTest<SPDY3_1CodecPair> {\n public:\n  SPDY31DownstreamTest()\n      : HTTPDownstreamTest<SPDY3_1CodecPair>({-1, -1,\n            2 * spdy::kInitialWindow}) {}\n};\n\nTEST_F(SPDY31DownstreamTest, TestSessionFlowControl) {\n  eventBase_.loopOnce();\n\n  InSequence sequence;\n  EXPECT_CALL(callbacks_, onSettings(_));\n  EXPECT_CALL(callbacks_, onWindowUpdate(0, spdy::kInitialWindow));\n  parseOutput(*clientCodec_);\n\n  cleanup();\n}\n\nTEST_F(SPDY3DownstreamSessionTest, TestEOFOnBlockedStream) {\n  sendRequest();\n\n  auto handler1 = addSimpleStrictHandler();\n\n  InSequence handlerSequence;\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1] {\n      handler1->sendReplyWithBody(200, 80000);\n    });\n  handler1->expectEgressPaused();\n\n  handler1->expectError([&] (const HTTPException& ex) {\n      // Not optimal to have a different error code here than the session\n      // flow control case, but HTTPException direction is immutable and\n      // building another one seems not future proof.\n      EXPECT_EQ(ex.getDirection(), HTTPException::Direction::INGRESS);\n    });\n  handler1->expectDetachTransaction();\n\n  expectDetachSession();\n\n  flushRequestsAndLoop(true, milliseconds(10));\n}\n\nTEST_F(SPDY31DownstreamTest, TestEOFOnBlockedSession) {\n  sendRequest();\n  sendRequest();\n\n  InSequence handlerSequence;\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1] {\n      handler1->sendHeaders(200, 40000);\n      handler1->sendBody(32769);\n    });\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&handler2, this] {\n      handler2->sendHeaders(200, 40000);\n      handler2->sendBody(32768);\n      eventBase_.runInLoop([this] { transport_->addReadEOF(milliseconds(0)); });\n    });\n\n  handler1->expectEgressPaused();\n  handler2->expectEgressPaused();\n  handler1->expectEgressResumed();\n  handler2->expectEgressResumed();\n  handler1->expectError([&] (const HTTPException& ex) {\n      EXPECT_EQ(ex.getDirection(),\n                HTTPException::Direction::INGRESS_AND_EGRESS);\n    });\n  handler1->expectDetachTransaction();\n  handler2->expectError([&] (const HTTPException& ex) {\n      EXPECT_EQ(ex.getDirection(),\n                HTTPException::Direction::INGRESS_AND_EGRESS);\n    });\n  handler2->expectDetachTransaction();\n\n  expectDetachSession();\n\n  flushRequestsAndLoop();\n}\n\n\nTEST_F(SPDY3DownstreamSessionTest, NewTxnEgressPaused) {\n  // Send 1 request with prio=0\n  // Have egress pause while sending the first response\n  // Send a second request with prio=1\n  //   -- the new txn should start egress paused\n  // Finish the body and eom both responses\n  // Unpause egress\n  // The first txn should complete first\n\n  sendRequest(\"/\", 0);\n  auto req2 = getGetRequest();\n  req2.setPriority(1);\n  auto req2p = sendRequestLater(req2, true);\n\n  unique_ptr<StrictMock<MockHTTPHandler>> handler1;\n  unique_ptr<StrictMock<MockHTTPHandler>> handler2;\n\n  httpSession_->setWriteBufferLimit(200); // lower the per session buffer limit\n  {\n    InSequence handlerSequence;\n    handler1 = addSimpleStrictHandler();\n    handler1->expectHeaders();\n    handler1->expectEOM([&handler1, this, &req2p] {\n        this->transport_->pauseWrites();\n        handler1->sendHeaders(200, 1000);\n        handler1->sendBody(100); // headers + 100 bytes - over the limit\n        req2p.setValue();\n      });\n    handler1->expectEgressPaused([] { LOG(INFO) << \"paused 1\"; });\n\n    handler2 = addSimpleStrictHandler();\n    handler2->expectEgressPaused(); // starts paused\n    handler2->expectHeaders();\n    handler2->expectEOM([&] {\n        // Technically shouldn't send while handler is egress paused, but meh.\n        handler1->sendBody(900);\n        handler1->txn_->sendEOM();\n        handler2->sendReplyWithBody(200, 1000);\n        resumeWritesInLoop();\n      });\n    handler1->expectDetachTransaction();\n    handler2->expectDetachTransaction();\n  }\n  HTTPSession::DestructorGuard g(httpSession_);\n  flushRequestsAndLoop();\n\n  std::list<HTTPCodec::StreamID> streams;\n  EXPECT_CALL(callbacks_, onMessageBegin(_, _))\n    .Times(2);\n  EXPECT_CALL(callbacks_, onHeadersComplete(_, _))\n    .Times(2);\n  // body is variable and hence ignored;\n  EXPECT_CALL(callbacks_, onMessageComplete(_, _))\n      .WillRepeatedly(Invoke([&](HTTPCodec::StreamID stream, bool /*upgrade*/) {\n        streams.push_back(stream);\n      }));\n  parseOutput(*clientCodec_);\n\n  cleanup();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, ZeroDeltaWindowUpdate) {\n  // generateHeader() will create a session and a transaction\n  auto streamID = sendHeader();\n  // First generate a frame with delta=1 so as to pass the checks, and then\n  // hack the frame so that delta=0 without modifying other checks\n  clientCodec_->generateWindowUpdate(requests_, streamID, 1);\n  requests_.trimEnd(http2::kFrameWindowUpdateSize);\n  QueueAppender appender(&requests_, http2::kFrameWindowUpdateSize);\n  appender.writeBE<uint32_t>(0);\n\n  auto handler = addSimpleStrictHandler();\n\n  InSequence handlerSequence;\n  handler->expectHeaders();\n  handler->expectError([&] (const HTTPException& ex) {\n      ASSERT_EQ(ex.getCodecStatusCode(), ErrorCode::PROTOCOL_ERROR);\n      ASSERT_EQ(\n        \"streamID=1 with HTTP2Codec stream error: window update delta=0\",\n        std::string(ex.what()));\n    });\n  handler->expectDetachTransaction();\n  expectDetachSession();\n\n  flushRequestsAndLoop();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, PaddingFlowControl) {\n  // generateHeader() will create a session and a transaction\n  auto streamID = sendHeader();\n  // This sends a total of 33kb including padding, so we should get a session\n  // and stream window update\n  for (auto i = 0; i < 129; i++) {\n    clientCodec_->generateBody(requests_, streamID, makeBuf(1), 255, false);\n  }\n\n  auto handler = addSimpleStrictHandler();\n\n  InSequence handlerSequence;\n  handler->expectHeaders([&] {\n      handler->txn_->pauseIngress();\n      eventBase_.runAfterDelay([&] { handler->txn_->resumeIngress(); },\n                               100);\n    });\n  EXPECT_CALL(*handler, onBody(_))\n    .Times(129);\n  handler->expectError();\n  handler->expectDetachTransaction();\n\n  HTTPSession::DestructorGuard g(httpSession_);\n  flushRequestsAndLoop(false, milliseconds(0), milliseconds(0), [&] {\n      clientCodec_->generateRstStream(requests_, streamID, ErrorCode::CANCEL);\n      clientCodec_->generateGoaway(requests_, 0, ErrorCode::NO_ERROR);\n      transport_->addReadEvent(requests_, milliseconds(110));\n    });\n\n  std::list<HTTPCodec::StreamID> streams;\n  EXPECT_CALL(callbacks_, onWindowUpdate(0, _));\n  EXPECT_CALL(callbacks_, onWindowUpdate(1, _));\n  parseOutput(*clientCodec_);\n  expectDetachSession();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, GracefulDrainOnTimeout) {\n  InSequence handlerSequence;\n  std::chrono::milliseconds gracefulTimeout(200);\n  httpSession_->enableDoubleGoawayDrain();\n  EXPECT_CALL(mockController_, getGracefulShutdownTimeout())\n    .WillOnce(InvokeWithoutArgs([&] {\n          // Once session asks for graceful shutdown timeout, expect the client\n          // to receive the first GOAWAY\n          eventBase_.runInLoop([&] {\n              EXPECT_CALL(callbacks_,\n                          onGoaway(std::numeric_limits<int32_t>::max(),\n                                   ErrorCode::NO_ERROR, _));\n              parseOutput(*clientCodec_);\n            });\n          return gracefulTimeout;\n        }));\n\n\n  // Simulate ConnectionManager idle timeout\n  eventBase_.runAfterDelay([&] { httpSession_->timeoutExpired(); },\n                           transactionTimeouts_->getDefaultTimeout().count());\n  HTTPSession::DestructorGuard g(httpSession_);\n  auto start = getCurrentTime();\n  eventBase_.loop();\n  auto finish = getCurrentTime();\n  auto minDuration =\n    gracefulTimeout + transactionTimeouts_->getDefaultTimeout();\n  EXPECT_GE((finish - start).count(), minDuration.count());\n  EXPECT_CALL(callbacks_, onGoaway(0, ErrorCode::NO_ERROR, _));\n  parseOutput(*clientCodec_);\n  expectDetachSession();\n}\n\n/*\n * The sequence of streams are generated in the following order:\n * - [client --> server] request 1st stream (getGetRequest())\n * - [server --> client] respond 1st stream (res with length 100)\n * - [server --> client] request 2nd stream (req)\n * - [server --> client] respond 2nd stream (res with length 200 + EOM)\n * - [client --> server] RST_STREAM on the 1st stream\n */\nTEST_F(HTTP2DownstreamSessionTest, ServerPush) {\n  // Create a dummy request and a dummy response messages\n  HTTPMessage req, res;\n  req.getHeaders().set(\"HOST\", \"www.foo.com\");\n  req.setURL(\"https://www.foo.com/\");\n  res.setStatusCode(200);\n  res.setStatusMessage(\"Ohai\");\n\n  // enable server push\n  clientCodec_->getEgressSettings()->setSetting(SettingsId::ENABLE_PUSH, 1);\n  clientCodec_->generateSettings(requests_);\n  // generateHeader() will create a session and a transaction\n  auto assocStreamId = HTTPCodec::StreamID(1);\n  clientCodec_->generateHeader(requests_, assocStreamId, getGetRequest(),\n                               false, nullptr);\n\n  auto handler = addSimpleStrictHandler();\n  StrictMock<MockHTTPPushHandler> pushHandler;\n\n  InSequence handlerSequence;\n  handler->expectHeaders([&] {\n      // Generate response for the associated stream\n      handler->txn_->sendHeaders(res);\n      handler->txn_->sendBody(makeBuf(100));\n      handler->txn_->pauseIngress();\n\n      auto* pushTxn = handler->txn_->newPushedTransaction(&pushHandler);\n      ASSERT_NE(pushTxn, nullptr);\n      // Generate a push request (PUSH_PROMISE)\n      auto outgoingStreams = httpSession_->getNumOutgoingStreams();\n      pushTxn->sendHeaders(req);\n      EXPECT_EQ(httpSession_->getNumOutgoingStreams(), outgoingStreams);\n      // Generate a push response\n      auto pri = handler->txn_->getPriority();\n      res.setHTTP2Priority(std::make_tuple(pri.streamDependency,\n                                           pri.exclusive, pri.weight));\n      pushTxn->sendHeaders(res);\n      EXPECT_EQ(httpSession_->getNumOutgoingStreams(), outgoingStreams + 1);\n      pushTxn->sendBody(makeBuf(200));\n      pushTxn->sendEOM();\n\n      eventBase_.runAfterDelay([&] { handler->txn_->resumeIngress(); },\n                               100);\n    });\n  EXPECT_CALL(pushHandler, setTransaction(_))\n    .WillOnce(Invoke([&] (HTTPTransaction* txn) {\n          pushHandler.txn_ = txn; }));\n  EXPECT_CALL(pushHandler, detachTransaction());\n  handler->expectError();\n  handler->expectDetachTransaction();\n\n  transport_->addReadEvent(requests_, milliseconds(0));\n  clientCodec_->generateRstStream(requests_, assocStreamId, ErrorCode::CANCEL);\n  clientCodec_->generateGoaway(requests_, 2, ErrorCode::NO_ERROR);\n  transport_->addReadEvent(requests_, milliseconds(200));\n  transport_->startReadEvents();\n  HTTPSession::DestructorGuard g(httpSession_);\n  eventBase_.loop();\n\n  EXPECT_CALL(callbacks_, onMessageBegin(1, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(1, _));\n  EXPECT_CALL(callbacks_, onPushMessageBegin(2, 1, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(2, _));\n  EXPECT_CALL(callbacks_, onMessageBegin(2, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(2, _));\n  EXPECT_CALL(callbacks_, onMessageComplete(2, _));\n\n  parseOutput(*clientCodec_);\n  expectDetachSession();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, ServerPushAbortPaused) {\n  // Create a dummy request and a dummy response messages\n  HTTPMessage req, res;\n  req.getHeaders().set(\"HOST\", \"www.foo.com\");\n  req.setURL(\"https://www.foo.com/\");\n  res.setStatusCode(200);\n  res.setStatusMessage(\"Ohai\");\n\n  // enable server push\n  clientCodec_->getEgressSettings()->setSetting(SettingsId::ENABLE_PUSH, 1);\n  clientCodec_->generateSettings(requests_);\n  // generateHeader() will create a session and a transaction\n  auto assocStreamId = HTTPCodec::StreamID(1);\n  clientCodec_->generateHeader(requests_, assocStreamId, getGetRequest(),\n                               false, nullptr);\n\n  auto handler = addSimpleStrictHandler();\n  StrictMock<MockHTTPPushHandler> pushHandler;\n\n  InSequence handlerSequence;\n  handler->expectHeaders([&] {\n      // Generate response for the associated stream\n      this->transport_->pauseWrites();\n      handler->txn_->sendHeaders(res);\n      handler->txn_->sendBody(makeBuf(100));\n      handler->txn_->pauseIngress();\n\n      auto* pushTxn = handler->txn_->newPushedTransaction(&pushHandler);\n      ASSERT_NE(pushTxn, nullptr);\n      // Generate a push request (PUSH_PROMISE)\n      pushTxn->sendHeaders(req);\n    });\n  EXPECT_CALL(pushHandler, setTransaction(_))\n    .WillOnce(Invoke([&] (HTTPTransaction* txn) {\n          pushHandler.txn_ = txn; }));\n  EXPECT_CALL(pushHandler, onError(_));\n  EXPECT_CALL(pushHandler, detachTransaction());\n  handler->expectError();\n  handler->expectDetachTransaction();\n\n  transport_->addReadEvent(requests_, milliseconds(0));\n  // Cancels everything\n  clientCodec_->generateRstStream(requests_, assocStreamId, ErrorCode::CANCEL);\n  transport_->addReadEvent(requests_, milliseconds(10));\n  transport_->startReadEvents();\n  HTTPSession::DestructorGuard g(httpSession_);\n  eventBase_.loop();\n\n  parseOutput(*clientCodec_);\n  expectDetachSession();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestPriorityWeightsTinyRatio) {\n  // Create a transaction with egress and a ratio small enough that\n  // ratio*4096 < 1.\n  //\n  //     root\n  //     /  \\                                                 level 1\n  //   256   1 (no egress)\n  //        / \\                                               level 2\n  //      256  1  <-- has ratio (1/257)^2\n  InSequence enforceOrder;\n  auto req1 = getGetRequest();\n  auto req2 = getGetRequest();\n  req1.setHTTP2Priority(HTTPMessage::HTTPPriority{0, false, 255});\n  req2.setHTTP2Priority(HTTPMessage::HTTPPriority{0, false, 0});\n\n  sendRequest(req1);\n  auto id2 = sendRequest(req2);\n  req1.setHTTP2Priority(HTTPMessage::HTTPPriority{id2, false, 255});\n  req2.setHTTP2Priority(HTTPMessage::HTTPPriority{id2, false, 0});\n  sendRequest(req1);\n  sendRequest(req2);\n\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&] {\n      handler1->sendReplyWithBody(200, 4 * 1024);\n    });\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM();\n  auto handler3 = addSimpleStrictHandler();\n  handler3->expectHeaders();\n  handler3->expectEOM([&] {\n      handler3->sendReplyWithBody(200, 15);\n    });\n  auto handler4 = addSimpleStrictHandler();\n  handler4->expectHeaders();\n  handler4->expectEOM([&] {\n      handler4->sendReplyWithBody(200, 1);\n    });\n\n  handler1->expectDetachTransaction([&] {\n      HTTPTransaction::PrioritySampleSummary summary;\n      EXPECT_EQ(handler1->txn_->getPrioritySampleSummary(summary), true);\n      EXPECT_EQ(handler1->txn_->getTransport().getHTTP2PrioritiesEnabled(),\n                true);\n      // id1 had no egress when id2 was running, so id1 was contending only with\n      // id3 and id4. Average number of contentions for id1 is 3\n      EXPECT_EQ(summary.contentions_.byTransactionBytes_, 3);\n      EXPECT_EQ(summary.contentions_.bySessionBytes_, 3);\n      // this is a first level transaction, depth == 1\n      EXPECT_EQ(summary.depth_.byTransactionBytes_, 1);\n      EXPECT_EQ(summary.depth_.bySessionBytes_, 1);\n      // the expected relative weight is 256/257 ~= 0.9961\n      EXPECT_GT(summary.expected_weight_, 0.996);\n      EXPECT_LT(summary.expected_weight_, 0.9962);\n      // the measured relative weight is 4096/(4096+15) ~= 0.99635\n      // This value is higher than the expected relative weight of 0.9961.\n      // Due to the arithmetical rounding to the lowest integer, the measured\n      // relative weight tends to be higher for transactions with high relative\n      // weights and lower for transactions with the low relative weights.\n      EXPECT_GT(summary.measured_weight_, 0.9963);\n      EXPECT_LT(summary.measured_weight_, 0.9964);\n    });\n  handler3->expectDetachTransaction([&] {\n      HTTPTransaction::PrioritySampleSummary summary;\n      EXPECT_EQ(handler3->txn_->getPrioritySampleSummary(summary), true);\n      EXPECT_EQ(handler3->txn_->getTransport().getHTTP2PrioritiesEnabled(),\n                true);\n      // Similarly, id3 was contenting with id1 and id4\n      // Average number of contentions for id3 is 3\n      EXPECT_EQ(summary.contentions_.byTransactionBytes_, 3);\n      EXPECT_EQ(summary.contentions_.bySessionBytes_, 3);\n      // this is a second level transaction where parent has\n      // no egress, depth == 2\n      EXPECT_EQ(summary.depth_.byTransactionBytes_, 2);\n      EXPECT_EQ(summary.depth_.bySessionBytes_, 2);\n      // the expected relative weight should be\n      // 1/257 * 256/257 ~= 0.00388. However, in the calculation of the\n      // allowed bytes to send we rounding to the lowest positive integer.\n      // Therefore, the measured relative weight tends to be less than\n      // it should be.  In this example, the allowed bytes sent is\n      // 4096 * 0.00388 ~= 15.89, which is rounded to 15. Hence the measured\n      // relative weight is 15/(4096+15) ~= 0.00365\n      EXPECT_GT(summary.expected_weight_, 0.00388);\n      EXPECT_LT(summary.expected_weight_, 0.0039);\n      EXPECT_GT(summary.measured_weight_, 0.00364);\n      EXPECT_LT(summary.measured_weight_, 0.00366);\n    });\n  handler4->expectDetachTransaction([&] {\n      HTTPTransaction::PrioritySampleSummary summary;\n      EXPECT_EQ(handler4->txn_->getPrioritySampleSummary(summary), true);\n      EXPECT_EQ(handler4->txn_->getTransport().getHTTP2PrioritiesEnabled(),\n                true);\n      // This is the priority-based blocking situation. id4 was blocked by\n      // higher priority transactions id1 and id3. Only when id1 and id3\n      // finished, id4 had a chance to transfer its data.\n      // Average contention number weighted by transaction bytes is 1, which\n      // means that when id4 had a chance to transfer bytes it did not contend\n      // with any other transactions.\n      // id4 was waiting for id1 and id3 during transfer of 4256 bytes (encoded)\n      // after which it tranferred 10 bytes (encoded) without contention.\n      // Therefore, the average number contentions weighted by session bytes is\n      // (4111*3 + 1*1)/(4111 + 1) = 12334/4112 ~= 2.999\n      // The difference in average contentions weighted by transaction and\n      // session bytes tells that id4 was mostly blocked by rather than blocking\n      // other transactions.\n      EXPECT_EQ(summary.contentions_.byTransactionBytes_, 1);\n      EXPECT_GT(summary.contentions_.bySessionBytes_, 2.99);\n      EXPECT_LT(summary.contentions_.bySessionBytes_, 3.00);\n      // this is a second level transaction where parent has\n      // no egress, depth == 2\n      EXPECT_EQ(summary.depth_.byTransactionBytes_, 2);\n      EXPECT_EQ(summary.depth_.bySessionBytes_, 2);\n      // the expected relative weight should be\n      // 1/257 * 1/257 ~= 0.000015.\n      // Because no bytes of this transaction were sent during the previous\n      // egress, the expected relative weight was calculated as:\n      // (0*4111 + 1*1)/(4111 + 1) ~= 0.000243\n      EXPECT_GT(summary.expected_weight_, 0.000243);\n      EXPECT_LT(summary.expected_weight_, 0.000244);\n      // The measured weight is (0+1)/(4111+1)  ~= 0.000243\n      // The difference between the theoretical value of 0.000015 and the\n      // measured one is not because of the arithmetical rounding, but because\n      // all other transactions are completed and the relative waight for the\n      // only survived transaction was elevated to 1.0\n      EXPECT_GT(summary.measured_weight_, 0.000243);\n      EXPECT_LT(summary.measured_weight_, 0.000244);\n      handler2->txn_->sendAbort();\n    });\n  handler2->expectDetachTransaction();\n  flushRequestsAndLoop();\n  httpSession_->closeWhenIdle();\n  expectDetachSession();\n  eventBase_.loop();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestPriorityDependentTransactions) {\n  // Create a dependent transaction to test the priority blocked by dependency.\n  // ratio*4096 < 1.\n  //\n  //     root\n  //      \\                                                 level 1\n  //      16\n  //       \\                                                level 2\n  //       16\n  InSequence enforceOrder;\n  auto req1 = getGetRequest();\n  req1.setHTTP2Priority(HTTPMessage::HTTPPriority{0, false, 15});\n  auto id1 = sendRequest(req1);\n\n  auto req2 = getGetRequest();\n  req2.setHTTP2Priority(HTTPMessage::HTTPPriority{id1, false, 15});\n  sendRequest(req2);\n\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&] {\n      handler1->sendReplyWithBody(200, 1024);\n    });\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&] {\n      handler2->sendReplyWithBody(200, 1024);\n    });\n\n  handler1->expectDetachTransaction([&] {\n      HTTPTransaction::PrioritySampleSummary summary;\n      EXPECT_EQ(handler1->txn_->getPrioritySampleSummary(summary), true);\n      EXPECT_EQ(handler1->txn_->getTransport().getHTTP2PrioritiesEnabled(),\n                true);\n      // id1 is contending with id2 during the entire transfer.\n      // Average number of contentions for id1 is 2 in both cases.\n      // The same number of average contentions weighted by both transaction\n      // and session bytes tells that id1 was not blocked by any other\n      // transaction during the entire transfer.\n      EXPECT_EQ(summary.contentions_.byTransactionBytes_, 2);\n      EXPECT_EQ(summary.contentions_.bySessionBytes_, 2);\n      // this is a first level transaction, depth == 1\n      EXPECT_EQ(summary.depth_.byTransactionBytes_, 1);\n      EXPECT_EQ(summary.depth_.bySessionBytes_, 1);\n      // dependent transaction is blocked, the parent is egressing on 100%\n      EXPECT_EQ(summary.expected_weight_, 1);\n      EXPECT_EQ(summary.measured_weight_, 1);\n    });\n  handler2->expectDetachTransaction([&] {\n      HTTPTransaction::PrioritySampleSummary summary;\n      EXPECT_EQ(handler2->txn_->getPrioritySampleSummary(summary), true);\n      EXPECT_EQ(handler2->txn_->getTransport().getHTTP2PrioritiesEnabled(),\n                true);\n      // This is the dependency-based blocking. id2 is blocked by id1.\n      // When id2 had a chance to transfer bytes, it was no longer contended\n      // with any other transaction. Hence the average contention weighted by\n      // transaction bytes is 1.\n      // The average number of contentions weighted by the session bytes is\n      // computed as (1024*2 + 1024*1)/(1024 + 1024) = 3072/2048 = 1.5\n      EXPECT_EQ(summary.contentions_.byTransactionBytes_, 1);\n      EXPECT_EQ(summary.contentions_.bySessionBytes_, 1.5);\n      // The transaction transferred bytes only when its parent transaction\n      // completed. At that time its level decreased to 1. The average depth\n      // weighted by session bytes is (2*1024 + 1*1024)/(2048) = 1.5.\n      EXPECT_EQ(summary.depth_.byTransactionBytes_, 1);\n      EXPECT_EQ(summary.depth_.bySessionBytes_, 1.5);\n      // this dependent transaction was bloted, so it was egressiong only 1/2\n      // of the session bytes.\n      EXPECT_EQ(summary.expected_weight_, 0.5);\n      EXPECT_EQ(summary.measured_weight_, 0.5);\n      handler2->txn_->sendAbort();\n    });\n  flushRequestsAndLoop();\n  httpSession_->closeWhenIdle();\n  expectDetachSession();\n  eventBase_.loop();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestDisablePriorities) {\n  // turn off HTTP2 priorities\n  httpSession_->setHTTP2PrioritiesEnabled(false);\n\n  InSequence enforceOrder;\n  HTTPMessage req1 = getGetRequest();\n  req1.setHTTP2Priority(HTTPMessage::HTTPPriority{0, false, 0});\n  sendRequest(req1);\n\n  HTTPMessage req2 = getGetRequest();\n  req2.setHTTP2Priority(HTTPMessage::HTTPPriority{0, false, 255});\n  sendRequest(req2);\n\n  auto handler1 = addSimpleStrictHandler();\n  handler1->expectHeaders();\n  handler1->expectEOM([&] {\n      handler1->sendReplyWithBody(200, 4 * 1024);\n    });\n\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&] {\n      handler2->sendReplyWithBody(200, 4 * 1024);\n    });\n\n  // expecting handler 1 to finish first irrespective of\n  // request 2 having higher weight\n  handler1->expectDetachTransaction();\n  handler2->expectDetachTransaction();\n\n  flushRequestsAndLoop();\n  httpSession_->closeWhenIdle();\n  expectDetachSession();\n  eventBase_.loop();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestPriorityWeights) {\n  // virtual priority node with pri=4\n  auto priGroupID = clientCodec_->createStream();\n  clientCodec_->generatePriority(\n    requests_, priGroupID, HTTPMessage::HTTPPriority(0, false, 3));\n  // Both txn's are at equal pri=16\n  auto id1 = sendRequest();\n  auto id2 = sendRequest();\n\n  auto handler1 = addSimpleStrictHandler();\n\n  handler1->expectHeaders();\n  handler1->expectEOM([&] {\n      handler1->sendHeaders(200, 12 * 1024);\n      handler1->txn_->sendBody(makeBuf(4 * 1024));\n    });\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&] {\n      handler2->sendHeaders(200, 12 * 1024);\n      handler2->txn_->sendBody(makeBuf(4 * 1024));\n    });\n\n  // twice- once to send and once to receive\n  flushRequestsAndLoopN(2);\n  EXPECT_CALL(callbacks_, onSettings(_));\n  EXPECT_CALL(callbacks_, onMessageBegin(id1, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(id1, _));\n  EXPECT_CALL(callbacks_, onMessageBegin(id2, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(id2, _));\n  EXPECT_CALL(callbacks_, onBody(id1, _, _))\n    .WillOnce(ExpectBodyLen(4 * 1024));\n  EXPECT_CALL(callbacks_, onBody(id2, _, _))\n    .WillOnce(ExpectBodyLen(4 * 1024));\n  parseOutput(*clientCodec_);\n\n  // update handler2 to be in the pri-group (which has lower weight)\n  clientCodec_->generatePriority(\n    requests_, id2, HTTPMessage::HTTPPriority(priGroupID, false, 15));\n\n  eventBase_.runInLoop([&] {\n      handler1->txn_->sendBody(makeBuf(4 * 1024));\n      handler2->txn_->sendBody(makeBuf(4 * 1024));\n    });\n  flushRequestsAndLoopN(2);\n\n  EXPECT_CALL(callbacks_, onBody(id1, _, _))\n    .WillOnce(ExpectBodyLen(4 * 1024));\n  EXPECT_CALL(callbacks_, onBody(id2, _, _))\n    .WillOnce(ExpectBodyLen(1 * 1024))\n    .WillOnce(ExpectBodyLen(3 * 1024));\n  parseOutput(*clientCodec_);\n\n  // update vnode weight to match txn1 weight\n  clientCodec_->generatePriority(requests_, priGroupID,\n                                 HTTPMessage::HTTPPriority(0, false, 15));\n  eventBase_.runInLoop([&] {\n      handler1->txn_->sendBody(makeBuf(4 * 1024));\n      handler1->txn_->sendEOM();\n      handler2->txn_->sendBody(makeBuf(4 * 1024));\n      handler2->txn_->sendEOM();\n    });\n  handler1->expectDetachTransaction();\n  handler2->expectDetachTransaction();\n  flushRequestsAndLoopN(2);\n\n  // expect 32/32\n  EXPECT_CALL(callbacks_, onBody(id1, _, _))\n    .WillOnce(ExpectBodyLen(4 * 1024));\n  EXPECT_CALL(callbacks_, onMessageComplete(id1, _));\n  EXPECT_CALL(callbacks_, onBody(id2, _, _))\n    .WillOnce(ExpectBodyLen(4 * 1024));\n  EXPECT_CALL(callbacks_, onMessageComplete(id2, _));\n  parseOutput(*clientCodec_);\n\n  httpSession_->closeWhenIdle();\n  expectDetachSession();\n  this->eventBase_.loop();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestPriorityWeightsTinyWindow) {\n  httpSession_->setWriteBufferLimit(2 * 65536);\n  InSequence enforceOrder;\n  auto id1 = sendRequest();\n  auto id2 = sendRequest();\n\n  auto handler1 = addSimpleStrictHandler();\n\n  handler1->expectHeaders();\n  handler1->expectEOM([&] {\n      handler1->sendReplyWithBody(200, 32 * 1024);\n    });\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&] {\n      handler2->sendReplyWithBody(200, 32 * 1024);\n    });\n\n  handler1->expectDetachTransaction();\n\n  // twice- once to send and once to receive\n  flushRequestsAndLoopN(2);\n  EXPECT_CALL(callbacks_, onSettings(_));\n  EXPECT_CALL(callbacks_, onMessageBegin(id1, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(id1, _));\n  EXPECT_CALL(callbacks_, onMessageBegin(id2, _));\n  EXPECT_CALL(callbacks_, onHeadersComplete(id2, _));\n  for (auto i = 0; i < 7; i++) {\n    EXPECT_CALL(callbacks_, onBody(id1, _, _))\n      .WillOnce(ExpectBodyLen(4 * 1024));\n    EXPECT_CALL(callbacks_, onBody(id2, _, _))\n      .WillOnce(ExpectBodyLen(4 * 1024));\n  }\n  EXPECT_CALL(callbacks_, onBody(id1, _, _))\n    .WillOnce(ExpectBodyLen(4 * 1024 - 1));\n  EXPECT_CALL(callbacks_, onBody(id2, _, _))\n    .WillOnce(ExpectBodyLen(4 * 1024 - 1));\n  EXPECT_CALL(callbacks_, onBody(id1, _, _))\n    .WillOnce(ExpectBodyLen(1));\n  EXPECT_CALL(callbacks_, onMessageComplete(id1, _));\n  parseOutput(*clientCodec_);\n\n  // open the window\n  clientCodec_->generateWindowUpdate(requests_, 0, 100);\n  handler2->expectDetachTransaction();\n  flushRequestsAndLoopN(2);\n\n  EXPECT_CALL(callbacks_, onBody(id2, _, _))\n    .WillOnce(ExpectBodyLen(1));\n  EXPECT_CALL(callbacks_, onMessageComplete(id2, _));\n  parseOutput(*clientCodec_);\n\n  httpSession_->closeWhenIdle();\n  expectDetachSession();\n  this->eventBase_.loop();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestShortContentLength) {\n  auto req = getPostRequest(10);\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateBody(requests_, streamID, makeBuf(20),\n                             HTTPCodec::NoPadding, true);\n  auto handler1 = addSimpleStrictHandler();\n\n  InSequence enforceOrder;\n  handler1->expectHeaders();\n  handler1->expectError([&handler1] (const HTTPException& ex) {\n      EXPECT_EQ(ex.getProxygenError(), kErrorParseBody);\n      handler1->txn_->sendAbort();\n    });\n  handler1->expectDetachTransaction();\n  flushRequestsAndLoop();\n\n  gracefulShutdown();\n}\n\n/**\n * If handler chooses to untie itself with transaction during onError,\n * detachTransaction shouldn't be expected\n */\nTEST_F(HTTP2DownstreamSessionTest, TestBadContentLengthUntieHandler) {\n  auto req = getPostRequest(10);\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateBody(\n      requests_,\n      streamID,\n      makeBuf(20),\n      HTTPCodec::NoPadding,\n      true);\n  auto handler1 = addSimpleStrictHandler();\n\n  InSequence enforceOrder;\n  handler1->expectHeaders();\n  handler1->expectError([&] (const HTTPException&) {\n      if (handler1->txn_) {\n        handler1->txn_->setHandler(nullptr);\n      }\n      handler1->txn_ = nullptr;\n    });\n  flushRequestsAndLoop();\n\n  gracefulShutdown();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestLongContentLength) {\n  auto req = getPostRequest(30);\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateBody(requests_, streamID, makeBuf(20),\n                             HTTPCodec::NoPadding, true);\n  auto handler1 = addSimpleStrictHandler();\n\n  InSequence enforceOrder;\n  handler1->expectHeaders();\n  handler1->expectBody();\n  handler1->expectError([&handler1] (const HTTPException& ex) {\n      EXPECT_EQ(ex.getProxygenError(), kErrorParseBody);\n      handler1->txn_->sendAbort();\n    });\n  handler1->expectDetachTransaction();\n  flushRequestsAndLoop();\n\n  gracefulShutdown();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestMalformedContentLength) {\n  auto req = getPostRequest();\n  req.getHeaders().set(HTTP_HEADER_CONTENT_LENGTH, \"malformed\");\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateBody(requests_, streamID, makeBuf(20),\n                             HTTPCodec::NoPadding, true);\n  auto handler1 = addSimpleStrictHandler();\n\n  InSequence enforceOrder;\n  handler1->expectHeaders();\n  handler1->expectBody();\n  handler1->expectEOM([&handler1] {\n      handler1->sendReplyWithBody(200, 100);\n    });\n  handler1->expectDetachTransaction();\n  flushRequestsAndLoop();\n\n  gracefulShutdown();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestHeadContentLength) {\n  InSequence enforceOrder;\n  auto req = getGetRequest();\n  req.setMethod(HTTPMethod::HEAD);\n  sendRequest(req);\n  auto handler1 = addSimpleStrictHandler();\n\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1] {\n      handler1->sendHeaders(200, 100);\n      // no body for head\n      handler1->txn_->sendEOM();\n    });\n  handler1->expectDetachTransaction();\n  flushRequestsAndLoop();\n\n  gracefulShutdown();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, Test304ContentLength) {\n  InSequence enforceOrder;\n  auto req = getGetRequest();\n  req.setMethod(HTTPMethod::HEAD);\n  sendRequest(req);\n  auto handler1 = addSimpleStrictHandler();\n\n  handler1->expectHeaders();\n  handler1->expectEOM([&handler1] {\n      handler1->sendHeaders(304, 100);\n      handler1->txn_->sendEOM();\n    });\n  handler1->expectDetachTransaction();\n  flushRequestsAndLoop();\n\n  gracefulShutdown();\n}\n\n// chunked with wrong content-length\nTEST_F(HTTPDownstreamSessionTest, HttpShortContentLength) {\n  InSequence enforceOrder;\n  auto req = getPostRequest(10);\n  req.setIsChunked(true);\n  req.getHeaders().add(HTTP_HEADER_TRANSFER_ENCODING, \"chunked\");\n  auto streamID = sendRequest(req, false);\n  clientCodec_->generateChunkHeader(requests_, streamID, 20);\n  clientCodec_->generateBody(requests_, streamID, makeBuf(20),\n                             HTTPCodec::NoPadding, false);\n  clientCodec_->generateChunkTerminator(requests_, streamID);\n  clientCodec_->generateEOM(requests_, streamID);\n  auto handler1 = addSimpleStrictHandler();\n\n  handler1->expectHeaders();\n  EXPECT_CALL(*handler1, onChunkHeader(20));\n\n  handler1->expectError([&handler1] (const HTTPException& ex) {\n      EXPECT_EQ(ex.getProxygenError(), kErrorParseBody);\n      handler1->txn_->sendAbort();\n    });\n  handler1->expectDetachTransaction();\n  expectDetachSession();\n  flushRequestsAndLoop();\n\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestSessionStallByFlowControl) {\n  NiceMock<MockHTTPSessionStats> stats;\n  // By default the send and receive windows are 64K each.\n  // If we use only a single transaction, that transaction\n  // will be paused on reaching 64K. Therefore, to pause the session,\n  // it is used 2 transactions each sending 32K.\n\n  // Make write buffer limit exceding 64K, for example 128K\n  httpSession_->setWriteBufferLimit(128 * 1024);\n  httpSession_->setSessionStats(&stats);\n\n  InSequence enforceOrder;\n  sendRequest();\n  sendRequest();\n\n  auto handler1 = addSimpleStrictHandler();\n\n  handler1->expectHeaders();\n  handler1->expectEOM([&] {\n      handler1->sendReplyWithBody(200, 32 * 1024);\n    });\n\n  auto handler2 = addSimpleStrictHandler();\n  handler2->expectHeaders();\n  handler2->expectEOM([&] {\n      handler2->sendReplyWithBody(200, 32 * 1024);\n    });\n\n  EXPECT_CALL(stats, recordSessionStalled()).Times(1);\n\n  handler1->expectDetachTransaction();\n\n  // twice- once to send and once to receive\n  flushRequestsAndLoopN(2);\n\n  // open the window\n  clientCodec_->generateWindowUpdate(requests_, 0, 100);\n  handler2->expectDetachTransaction();\n  flushRequestsAndLoopN(2);\n\n  httpSession_->closeWhenIdle();\n  expectDetachSession();\n  flushRequestsAndLoop();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestTransactionStallByFlowControl) {\n  StrictMock<MockHTTPSessionStats> stats;\n\n  httpSession_->setSessionStats(&stats);\n\n  // Set the client side stream level flow control wind to 500 bytes,\n  // and try to send 1000 bytes through it.\n  // Then the flow control kicks in and stalls the transaction.\n  clientCodec_->getEgressSettings()->setSetting(SettingsId::INITIAL_WINDOW_SIZE,\n                                                500);\n  clientCodec_->generateSettings(requests_);\n\n  auto streamID = sendRequest();\n\n  EXPECT_CALL(stats, recordTransactionOpened());\n\n  InSequence handlerSequence;\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders();\n  handler->expectEOM([&] {\n      handler->sendReplyWithBody(200, 1000);\n    });\n\n  EXPECT_CALL(stats, recordTransactionStalled());\n  handler->expectEgressPaused();\n\n  handler->expectError([&] (const HTTPException& ex) {\n      ASSERT_EQ(ex.getProxygenError(), kErrorWriteTimeout);\n      ASSERT_EQ(\n        folly::to<std::string>(\"ingress timeout, streamID=\", streamID),\n        std::string(ex.what()));\n      handler->terminate();\n    });\n\n  handler->expectDetachTransaction();\n\n  EXPECT_CALL(stats, recordTransactionClosed());\n\n  flushRequestsAndLoop();\n  gracefulShutdown();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestTransactionNotStallByFlowControl) {\n  StrictMock<MockHTTPSessionStats> stats;\n\n  httpSession_->setSessionStats(&stats);\n\n  clientCodec_->getEgressSettings()->setSetting(SettingsId::INITIAL_WINDOW_SIZE,\n                                                500);\n  clientCodec_->generateSettings(requests_);\n\n  sendRequest();\n\n  EXPECT_CALL(stats, recordTransactionOpened());\n\n  InSequence handlerSequence;\n  auto handler = addSimpleStrictHandler();\n  handler->expectHeaders();\n  handler->expectEOM([&] {\n      handler->sendReplyWithBody(200, 500);\n    });\n\n  // The egtress paused is notified due to existing logics,\n  // but egress transaction should not be counted as stalled by flow control,\n  // because there is nore more bytes to send\n  handler->expectEgressPaused();\n\n  handler->expectDetachTransaction();\n\n  EXPECT_CALL(stats, recordTransactionClosed());\n\n  flushRequestsAndLoop();\n  gracefulShutdown();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestSetEgressSettings) {\n  SettingsList settings = {{ SettingsId::HEADER_TABLE_SIZE, 5555 },\n                           { SettingsId::MAX_FRAME_SIZE, 16384 },\n                           { SettingsId::ENABLE_PUSH, 1 }};\n\n  const HTTPSettings* codecSettings = rawCodec_->getEgressSettings();\n  for (const auto& setting: settings) {\n    const HTTPSetting* currSetting = codecSettings->getSetting(setting.id);\n    if (currSetting) {\n      EXPECT_EQ(setting.value, currSetting->value);\n    }\n  }\n\n  flushRequestsAndLoop();\n  gracefulShutdown();\n}\n\nTEST_F(HTTP2DownstreamSessionTest, TestDuplicateRequestStream) {\n  // Send the following:\n  // HEADERS id=1\n  // HEADERS id=2\n  // HEADERS id=1 (trailers)\n  // HEADERS id=2 -> contains pseudo-headers after EOM so ignored\n  auto handler2 = addSimpleStrictHandler();\n  auto handler1 = addSimpleStrictHandler();\n  auto streamID1 = sendRequest(\"/withtrailers\", 0, false);\n  auto streamID2 = sendRequest();\n  HTTPHeaders trailers;\n  trailers.add(\"Foo\", \"Bar\");\n  clientCodec_->generateTrailers(requests_, streamID1, trailers);\n  clientCodec_->generateEOM(requests_, streamID1);\n\n  clientCodec_->generateHeader(requests_, streamID2, getGetRequest(), false);\n  handler1->expectHeaders();\n  handler2->expectHeaders();\n  handler2->expectEOM();\n  handler1->expectTrailers();\n  handler1->expectEOM([&] {\n      handler1->sendReplyWithBody(200, 100);\n      // 2 got an error after EOM, which gets ignored - need a response to\n      // cleanly terminate it\n      handler2->sendReplyWithBody(200, 100);\n    });\n  handler1->expectDetachTransaction();\n  handler2->expectDetachTransaction();\n  flushRequestsAndLoop();\n  gracefulShutdown();\n}\n", "/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n#pragma once\n\n#include <folly/portability/GMock.h>\n#include <proxygen/lib/http/HTTPMessage.h>\n#include <proxygen/lib/http/codec/test/TestUtils.h>\n#include <proxygen/lib/http/session/HTTPDownstreamSession.h>\n#include <proxygen/lib/http/session/HTTPSessionController.h>\n#include <proxygen/lib/http/session/HTTPSessionStats.h>\n#include <proxygen/lib/http/session/HTTPTransaction.h>\n\n#define GMOCK_NOEXCEPT_METHOD0(m, F) GMOCK_METHOD0_(, noexcept, , m, F)\n#define GMOCK_NOEXCEPT_METHOD1(m, F) GMOCK_METHOD1_(, noexcept, , m, F)\n\nnamespace proxygen {\n\nclass HTTPHandlerBase {\n public:\n  HTTPHandlerBase() {\n  }\n  HTTPHandlerBase(HTTPTransaction* txn, HTTPMessage* msg)\n      : txn_(txn), msg_(msg) {\n  }\n\n  void terminate() {\n    txn_->sendAbort();\n  }\n\n  void sendRequest() {\n    sendRequest(getGetRequest());\n  }\n\n  void sendRequest(HTTPMessage req) {\n    // this copies but it's test code meh\n    txn_->sendHeaders(req);\n    txn_->sendEOM();\n  }\n\n  using HeaderMap = std::map<std::string, std::string>;\n  void sendHeaders(uint32_t code,\n                   uint32_t content_length,\n                   bool keepalive = true,\n                   HeaderMap headers = HeaderMap()) {\n    HTTPMessage reply;\n    reply.setStatusCode(code);\n    reply.setHTTPVersion(1, 1);\n    reply.setWantsKeepalive(keepalive);\n    reply.getHeaders().add(HTTP_HEADER_CONTENT_LENGTH,\n                           folly::to<std::string>(content_length));\n    for (auto& nv : headers) {\n      reply.getHeaders().add(nv.first, nv.second);\n    }\n    txn_->sendHeaders(reply);\n  }\n\n  void sendReply() {\n    sendReplyCode(200);\n  }\n\n  void sendReplyCode(uint32_t code) {\n    sendHeaders(code, 0, true);\n    txn_->sendEOM();\n  }\n\n  void sendBody(uint32_t content_length) {\n    while (content_length > 0) {\n      uint32_t toSend = std::min(content_length, uint32_t(4096));\n      char buf[toSend];\n      memset(buf, 'a', toSend);\n      txn_->sendBody(folly::IOBuf::copyBuffer(buf, toSend));\n      content_length -= toSend;\n    }\n  }\n\n  void sendBodyWithLastByteTracking(uint32_t content_length) {\n    txn_->setLastByteFlushedTrackingEnabled(true);\n    sendBody(content_length);\n  }\n\n  void sendReplyWithBody(uint32_t code,\n                         uint32_t content_length,\n                         bool keepalive = true,\n                         bool sendEOM = true,\n                         bool hasTrailers = false) {\n    sendHeaders(code, content_length, keepalive);\n    sendBody(content_length);\n    if (hasTrailers) {\n      HTTPHeaders trailers;\n      trailers.add(\"X-Trailer1\", \"Foo\");\n      txn_->sendTrailers(trailers);\n    }\n    if (sendEOM) {\n      txn_->sendEOM();\n    }\n  }\n\n  void sendEOM() {\n    txn_->sendEOM();\n  }\n\n  void sendChunkedReplyWithBody(uint32_t code,\n                                uint32_t content_length,\n                                uint32_t chunkSize,\n                                bool hasTrailers,\n                                bool sendEOM = true) {\n    HTTPMessage reply;\n    reply.setStatusCode(code);\n    reply.setHTTPVersion(1, 1);\n    reply.setIsChunked(true);\n    txn_->sendHeaders(reply);\n    while (content_length > 0) {\n      uint32_t toSend = std::min(content_length, chunkSize);\n      char buf[toSend];\n      memset(buf, 'a', toSend);\n      txn_->sendChunkHeader(toSend);\n      txn_->sendBody(folly::IOBuf::copyBuffer(buf, toSend));\n      txn_->sendChunkTerminator();\n      content_length -= toSend;\n    }\n    if (hasTrailers) {\n      HTTPHeaders trailers;\n      trailers.add(\"X-Trailer1\", \"Foo\");\n      txn_->sendTrailers(trailers);\n    }\n    if (sendEOM) {\n      txn_->sendEOM();\n    }\n  }\n\n  HTTPTransaction* txn_{nullptr};\n  std::shared_ptr<HTTPMessage> msg_;\n};\n\nclass MockHTTPHandler\n    : public HTTPHandlerBase\n    , public HTTPTransaction::Handler {\n public:\n  MockHTTPHandler() {\n  }\n  MockHTTPHandler(HTTPTransaction& txn,\n                  HTTPMessage* msg,\n                  const folly::SocketAddress&)\n      : HTTPHandlerBase(&txn, msg) {\n  }\n\n  GMOCK_NOEXCEPT_METHOD1(setTransaction, void(HTTPTransaction* txn));\n\n  GMOCK_NOEXCEPT_METHOD0(detachTransaction, void());\n\n  void onHeadersComplete(std::unique_ptr<HTTPMessage> msg) noexcept override {\n    onHeadersComplete(std::shared_ptr<HTTPMessage>(msg.release()));\n  }\n\n  GMOCK_NOEXCEPT_METHOD1(onHeadersComplete,\n                         void(std::shared_ptr<HTTPMessage> msg));\n\n  void onBody(std::unique_ptr<folly::IOBuf> chain) noexcept override {\n    onBody(std::shared_ptr<folly::IOBuf>(chain.release()));\n  }\n  GMOCK_NOEXCEPT_METHOD1(onBody, void(std::shared_ptr<folly::IOBuf> chain));\n\n  GMOCK_NOEXCEPT_METHOD1(onChunkHeader, void(size_t length));\n\n  GMOCK_NOEXCEPT_METHOD0(onChunkComplete, void());\n\n  void onTrailers(std::unique_ptr<HTTPHeaders> trailers) noexcept override {\n    onTrailers(std::shared_ptr<HTTPHeaders>(trailers.release()));\n  }\n\n  GMOCK_NOEXCEPT_METHOD1(onTrailers,\n                         void(std::shared_ptr<HTTPHeaders> trailers));\n\n  GMOCK_NOEXCEPT_METHOD0(onEOM, void());\n\n  GMOCK_NOEXCEPT_METHOD1(onUpgrade, void(UpgradeProtocol protocol));\n\n  GMOCK_NOEXCEPT_METHOD1(onError, void(const HTTPException& error));\n\n  GMOCK_NOEXCEPT_METHOD1(onGoaway, void(ErrorCode));\n\n  GMOCK_NOEXCEPT_METHOD0(onEgressPaused, void());\n\n  GMOCK_NOEXCEPT_METHOD0(onEgressResumed, void());\n\n  GMOCK_NOEXCEPT_METHOD1(onPushedTransaction, void(HTTPTransaction*));\n\n  GMOCK_NOEXCEPT_METHOD1(onExTransaction, void(HTTPTransaction*));\n\n  void expectTransaction(std::function<void(HTTPTransaction* txn)> callback) {\n    EXPECT_CALL(*this, setTransaction(testing::_))\n        .WillOnce(testing::Invoke(callback))\n        .RetiresOnSaturation();\n  }\n\n  void expectTransaction(HTTPTransaction** pTxn = nullptr) {\n    EXPECT_CALL(*this, setTransaction(testing::_))\n        .WillOnce(testing::SaveArg<0>(pTxn ? pTxn : &txn_));\n  }\n\n  void expectHeaders(std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onHeadersComplete(testing::_))\n          .WillOnce(testing::InvokeWithoutArgs(callback))\n          .RetiresOnSaturation();\n    } else {\n      EXPECT_CALL(*this, onHeadersComplete(testing::_));\n    }\n  }\n\n  void expectHeaders(std::function<void(std::shared_ptr<HTTPMessage>)> cb) {\n    EXPECT_CALL(*this, onHeadersComplete(testing::_))\n        .WillOnce(testing::Invoke(cb))\n        .RetiresOnSaturation();\n  }\n\n  void expectTrailers(\n      std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onTrailers(testing::_))\n          .WillOnce(testing::InvokeWithoutArgs(callback))\n          .RetiresOnSaturation();\n    } else {\n      EXPECT_CALL(*this, onTrailers(testing::_));\n    }\n  }\n\n  void expectTrailers(\n      std::function<void(std::shared_ptr<HTTPHeaders> trailers)> cb) {\n    EXPECT_CALL(*this, onTrailers(testing::_))\n        .WillOnce(testing::Invoke(cb))\n        .RetiresOnSaturation();\n  }\n\n  void expectChunkHeader(\n      std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onChunkHeader(testing::_))\n          .WillOnce(testing::InvokeWithoutArgs(callback));\n    } else {\n      EXPECT_CALL(*this, onChunkHeader(testing::_));\n    }\n  }\n\n  void expectBody(std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onBody(testing::_))\n          .WillOnce(testing::InvokeWithoutArgs(callback));\n    } else {\n      EXPECT_CALL(*this, onBody(testing::_));\n    }\n  }\n\n  void expectBody(std::function<void(std::shared_ptr<folly::IOBuf>)> callback) {\n    EXPECT_CALL(*this, onBody(testing::_)).WillOnce(testing::Invoke(callback));\n  }\n\n  void expectChunkComplete(\n      std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onChunkComplete())\n          .WillOnce(testing::InvokeWithoutArgs(callback));\n    } else {\n      EXPECT_CALL(*this, onChunkComplete());\n    }\n  }\n\n  void expectEOM(std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onEOM()).WillOnce(testing::Invoke(callback));\n    } else {\n      EXPECT_CALL(*this, onEOM());\n    }\n  }\n\n  void expectEgressPaused(\n      std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onEgressPaused()).WillOnce(testing::Invoke(callback));\n    } else {\n      EXPECT_CALL(*this, onEgressPaused());\n    }\n  }\n\n  void expectEgressResumed(\n      std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onEgressResumed()).WillOnce(testing::Invoke(callback));\n    } else {\n      EXPECT_CALL(*this, onEgressResumed());\n    }\n  }\n\n  void expectError(std::function<void(const HTTPException& ex)> callback =\n                       std::function<void(const HTTPException& ex)>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onError(testing::_))\n          .WillOnce(testing::Invoke(callback));\n    } else {\n      EXPECT_CALL(*this, onError(testing::_));\n    }\n  }\n\n  void expectGoaway(std::function<void(ErrorCode)> callback =\n                        std::function<void(ErrorCode)>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onGoaway(testing::_))\n          .WillOnce(testing::Invoke(callback));\n    } else {\n      EXPECT_CALL(*this, onGoaway(testing::_));\n    }\n  }\n\n  void expectDetachTransaction(\n      std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, detachTransaction())\n          .WillOnce(testing::Invoke(callback));\n    } else {\n      EXPECT_CALL(*this, detachTransaction());\n    }\n  }\n};\n\nclass MockHTTPPushHandler\n    : public HTTPHandlerBase\n    , public HTTPTransaction::PushHandler {\n public:\n  MockHTTPPushHandler() {\n  }\n  MockHTTPPushHandler(HTTPTransaction& txn,\n                      HTTPMessage* msg,\n                      const folly::SocketAddress&)\n      : HTTPHandlerBase(&txn, msg) {\n  }\n\n  GMOCK_NOEXCEPT_METHOD1(setTransaction, void(HTTPTransaction* txn));\n\n  GMOCK_NOEXCEPT_METHOD0(detachTransaction, void());\n\n  GMOCK_NOEXCEPT_METHOD1(onError, void(const HTTPException& error));\n\n  GMOCK_NOEXCEPT_METHOD1(onGoaway, void(ErrorCode));\n\n  GMOCK_NOEXCEPT_METHOD0(onEgressPaused, void());\n\n  GMOCK_NOEXCEPT_METHOD0(onEgressResumed, void());\n\n  void sendPushHeaders(const std::string& path,\n                       const std::string& host,\n                       uint32_t content_length,\n                       http2::PriorityUpdate pri) {\n    HTTPMessage push;\n    push.setURL(path);\n    push.getHeaders().set(HTTP_HEADER_HOST, host);\n    push.getHeaders().add(HTTP_HEADER_CONTENT_LENGTH,\n                          folly::to<std::string>(content_length));\n    push.setHTTP2Priority(\n        std::make_tuple(pri.streamDependency, pri.exclusive, pri.weight));\n    txn_->sendHeaders(push);\n  }\n};\n\nclass MockController : public HTTPSessionController {\n public:\n  MOCK_METHOD2(getRequestHandler,\n               HTTPTransactionHandler*(HTTPTransaction&, HTTPMessage* msg));\n\n  MOCK_METHOD3(getParseErrorHandler,\n               HTTPTransactionHandler*(HTTPTransaction*,\n                                       const HTTPException&,\n                                       const folly::SocketAddress&));\n\n  MOCK_METHOD2(getTransactionTimeoutHandler,\n               HTTPTransactionHandler*(HTTPTransaction* txn,\n                                       const folly::SocketAddress&));\n\n  MOCK_METHOD1(attachSession, void(HTTPSessionBase*));\n  MOCK_METHOD1(detachSession, void(const HTTPSessionBase*));\n  MOCK_METHOD1(onSessionCodecChange, void(HTTPSessionBase*));\n  MOCK_CONST_METHOD0(getGracefulShutdownTimeout, std::chrono::milliseconds());\n\n  MOCK_CONST_METHOD0(getHeaderIndexingStrategy,\n                     const HeaderIndexingStrategy*());\n};\n\nclass MockUpstreamController : public HTTPUpstreamSessionController {\n public:\n  MOCK_METHOD1(attachSession, void(HTTPSessionBase*));\n  MOCK_METHOD1(detachSession, void(const HTTPSessionBase*));\n  MOCK_METHOD1(onSessionCodecChange, void(HTTPSessionBase*));\n\n  MOCK_CONST_METHOD0(getHeaderIndexingStrategy,\n                     const HeaderIndexingStrategy*());\n};\n\nACTION_P(ExpectString, expected) {\n  std::string bodystr((const char*)arg0->data(), arg0->length());\n  EXPECT_EQ(bodystr, expected);\n}\n\nACTION_P(ExpectBodyLen, expectedLen) {\n  EXPECT_EQ(arg1->computeChainDataLength(), expectedLen);\n}\n\nclass MockHTTPSessionInfoCallback : public HTTPSession::InfoCallback {\n public:\n  MOCK_METHOD1(onCreate, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onTransportReady, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onConnectionError, void(const HTTPSessionBase&));\n  MOCK_METHOD2(onIngressError, void(const HTTPSessionBase&, ProxygenError));\n  MOCK_METHOD0(onIngressEOF, void());\n  MOCK_METHOD2(onRead, void(const HTTPSessionBase&, size_t));\n  MOCK_METHOD2(onWrite, void(const HTTPSessionBase&, size_t));\n  MOCK_METHOD1(onRequestBegin, void(const HTTPSessionBase&));\n  MOCK_METHOD2(onRequestEnd, void(const HTTPSessionBase&, uint32_t));\n  MOCK_METHOD1(onActivateConnection, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onDeactivateConnection, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onDestroy, void(const HTTPSessionBase&));\n  MOCK_METHOD2(onIngressMessage,\n               void(const HTTPSessionBase&, const HTTPMessage&));\n  MOCK_METHOD1(onIngressLimitExceeded, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onIngressPaused, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onTransactionDetached, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onPingReplySent, void(int64_t));\n  MOCK_METHOD0(onPingReplyReceived, void());\n  MOCK_METHOD1(onSettingsOutgoingStreamsFull, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onSettingsOutgoingStreamsNotFull, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onFlowControlWindowClosed, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onEgressBuffered, void(const HTTPSessionBase&));\n  MOCK_METHOD1(onEgressBufferCleared, void(const HTTPSessionBase&));\n  MOCK_METHOD2(onSettings, void(const HTTPSessionBase&, const SettingsList&));\n  MOCK_METHOD1(onSettingsAck, void(const HTTPSessionBase&));\n};\n\nclass DummyHTTPSessionStats : public HTTPSessionStats {\n public:\n  void recordTransactionOpened() noexcept override{};\n  void recordTransactionClosed() noexcept override{};\n  void recordTransactionsServed(uint64_t) noexcept override{};\n  void recordSessionReused() noexcept override{};\n  // virtual void recordSessionIdleTime(std::chrono::seconds) noexcept {};\n  void recordTransactionStalled() noexcept override{};\n  void recordSessionStalled() noexcept override{};\n\n  void recordTTLBAExceedLimit() noexcept override{};\n  void recordTTLBAIOBSplitByEom() noexcept override{};\n  void recordTTLBANotFound() noexcept override{};\n  void recordTTLBAReceived() noexcept override{};\n  void recordTTLBATimeout() noexcept override{};\n  void recordTTLBAEomPassed() noexcept override{};\n  void recordTTLBATracked() noexcept override{};\n};\n\nclass MockHTTPSessionStats : public DummyHTTPSessionStats {\n public:\n  MockHTTPSessionStats() {\n  }\n  GMOCK_NOEXCEPT_METHOD0(recordTransactionOpened, void());\n  GMOCK_NOEXCEPT_METHOD0(recordTransactionClosed, void());\n  GMOCK_NOEXCEPT_METHOD1(recordTransactionsServed, void(uint64_t));\n  GMOCK_NOEXCEPT_METHOD0(recordSessionReused, void());\n  GMOCK_NOEXCEPT_METHOD1(recordSessionIdleTime, void(std::chrono::seconds));\n  GMOCK_NOEXCEPT_METHOD0(recordTransactionStalled, void());\n  GMOCK_NOEXCEPT_METHOD0(recordSessionStalled, void());\n};\n\n} // namespace proxygen\n"], "filenames": ["proxygen/lib/http/codec/HTTP2Codec.cpp", "proxygen/lib/http/codec/test/HTTP2CodecTest.cpp", "proxygen/lib/http/session/test/HTTPDownstreamSessionTest.cpp", "proxygen/lib/http/session/test/HTTPSessionMocks.h"], "buggy_code_start_loc": [990, 2147, 3570, 221], "buggy_code_end_loc": [1315, 2147, 3570, 221], "fixing_code_start_loc": [990, 2148, 3571, 222], "fixing_code_end_loc": [1317, 2173, 3603, 233], "type": "CWE-20", "message": "An issue in the Proxygen handling of HTTP2 parsing of headers/trailers can lead to a denial-of-service attack. This affects Proxygen prior to v2018.12.31.00.", "other": {"cve": {"id": "CVE-2018-6347", "sourceIdentifier": "cve-assign@fb.com", "published": "2018-12-31T22:29:00.687", "lastModified": "2019-10-09T23:41:47.893", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue in the Proxygen handling of HTTP2 parsing of headers/trailers can lead to a denial-of-service attack. This affects Proxygen prior to v2018.12.31.00."}, {"lang": "es", "value": "Un problema en la manera en la que Proxygen maneja el an\u00e1lisis HTTP2 de cabeceras/trailers puede provocar un ataque de denegaci\u00f3n de servicio (DoS). Esto afecta a las versiones de Proxygen anteriores a la v2018.12.31.00."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:proxygen_project:proxygen:*:*:*:*:*:*:*:*", "versionEndExcluding": "2018.12.31.00", "matchCriteriaId": "10DFD5FA-DC03-4C1A-A8F7-70BA5998141D"}]}]}], "references": [{"url": "https://github.com/facebook/proxygen/commit/223e0aa6bc7590e86af1e917185a2e0efe160711", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/facebook/proxygen/commit/223e0aa6bc7590e86af1e917185a2e0efe160711"}}