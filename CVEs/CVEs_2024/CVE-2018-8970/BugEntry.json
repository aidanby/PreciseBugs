{"buggy_code": ["/* $OpenBSD: x509_vpm.c,v 1.16 2017/12/09 07:09:25 deraadt Exp $ */\n/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL\n * project 2004.\n */\n/* ====================================================================\n * Copyright (c) 2004 The OpenSSL Project.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n *\n * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For written permission, please contact\n *    licensing@OpenSSL.org.\n *\n * 5. Products derived from this software may not be called \"OpenSSL\"\n *    nor may \"OpenSSL\" appear in their names without prior written\n *    permission of the OpenSSL Project.\n *\n * 6. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n *\n * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * ====================================================================\n *\n * This product includes cryptographic software written by Eric Young\n * (eay@cryptsoft.com).  This product includes software written by Tim\n * Hudson (tjh@cryptsoft.com).\n *\n */\n\n#include <stdio.h>\n#include <string.h>\n\n#include <openssl/buffer.h>\n#include <openssl/crypto.h>\n#include <openssl/lhash.h>\n#include <openssl/stack.h>\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n\n#include \"vpm_int.h\"\n\n/* X509_VERIFY_PARAM functions */\n\nint X509_VERIFY_PARAM_set1_email(X509_VERIFY_PARAM *param, const char *email,\n    size_t emaillen);\nint X509_VERIFY_PARAM_set1_ip(X509_VERIFY_PARAM *param, const unsigned char *ip,\n    size_t iplen);\n\n#define SET_HOST 0\n#define ADD_HOST 1\n\nstatic void\nstr_free(char *s)\n{\n    free(s);\n}\n\n#define string_stack_free(sk) sk_OPENSSL_STRING_pop_free(sk, str_free)\n\n\n/*\n * Post 1.0.1 sk function \"deep_copy\".  For the moment we simply make\n * these take void * and use them directly without a glorious blob of\n * obfuscating macros of dubious value in front of them. All this in\n * preparation for a rototilling of safestack.h (likely inspired by\n * this).\n */\nstatic void *\nsk_deep_copy(void *sk_void, void *copy_func_void, void *free_func_void)\n{\n\t_STACK *sk = sk_void;\n\tvoid *(*copy_func)(void *) = copy_func_void;\n\tvoid (*free_func)(void *) = free_func_void;\n\t_STACK *ret = sk_dup(sk);\n\tsize_t i;\n\n\tif (ret == NULL)\n\t\treturn NULL;\n\n\tfor (i = 0; i < ret->num; i++) {\n\t\tif (ret->data[i] == NULL)\n\t\t\tcontinue;\n\t\tret->data[i] = copy_func(ret->data[i]);\n\t\tif (ret->data[i] == NULL) {\n\t\t\tsize_t j;\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tif (ret->data[j] != NULL)\n\t\t\t\t\tfree_func(ret->data[j]);\n\t\t\t}\n\t\t\tsk_free(ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int\nint_x509_param_set_hosts(X509_VERIFY_PARAM_ID *id, int mode,\n    const char *name, size_t namelen)\n{\n\tchar *copy;\n\n\t/*\n\t * Refuse names with embedded NUL bytes.\n\t * XXX: Do we need to push an error onto the error stack?\n\t */\n\tif (name && memchr(name, '\\0', namelen))\n\t\treturn 0;\n\n\tif (mode == SET_HOST && id->hosts) {\n\t\tstring_stack_free(id->hosts);\n\t\tid->hosts = NULL;\n\t}\n\tif (name == NULL || namelen == 0)\n\t\treturn 1;\n\tcopy = strndup(name, namelen);\n\tif (copy == NULL)\n\t\treturn 0;\n\n\tif (id->hosts == NULL &&\n\t    (id->hosts = sk_OPENSSL_STRING_new_null()) == NULL) {\n\t\tfree(copy);\n\t\treturn 0;\n\t}\n\n\tif (!sk_OPENSSL_STRING_push(id->hosts, copy)) {\n\t\tfree(copy);\n\t\tif (sk_OPENSSL_STRING_num(id->hosts) == 0) {\n\t\t\tsk_OPENSSL_STRING_free(id->hosts);\n\t\t\tid->hosts = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void\nx509_verify_param_zero(X509_VERIFY_PARAM *param)\n{\n\tX509_VERIFY_PARAM_ID *paramid;\n\tif (!param)\n\t\treturn;\n\tparam->name = NULL;\n\tparam->purpose = 0;\n\tparam->trust = 0;\n\t/*param->inh_flags = X509_VP_FLAG_DEFAULT;*/\n\tparam->inh_flags = 0;\n\tparam->flags = 0;\n\tparam->depth = -1;\n\tif (param->policies) {\n\t\tsk_ASN1_OBJECT_pop_free(param->policies, ASN1_OBJECT_free);\n\t\tparam->policies = NULL;\n\t}\n\tparamid = param->id;\n\tif (paramid->hosts) {\n\t\tstring_stack_free(paramid->hosts);\n\t\tparamid->hosts = NULL;\n\t}\n\tfree(paramid->peername);\n\tparamid->peername = NULL;\n\tfree(paramid->email);\n\tparamid->email = NULL;\n\tparamid->emaillen = 0;\n\tfree(paramid->ip);\n\tparamid->ip = NULL;\n\tparamid->iplen = 0;\n}\n\nX509_VERIFY_PARAM *\nX509_VERIFY_PARAM_new(void)\n{\n\tX509_VERIFY_PARAM *param;\n\tX509_VERIFY_PARAM_ID *paramid;\n\tparam = calloc(1, sizeof(X509_VERIFY_PARAM));\n\tif (param == NULL)\n\t\treturn NULL;\n\tparamid = calloc (1, sizeof(X509_VERIFY_PARAM_ID));\n\tif (paramid == NULL) {\n\t\tfree(param);\n\t\treturn NULL;\n\t}\n\tparam->id = paramid;\n\tx509_verify_param_zero(param);\n\treturn param;\n}\n\nvoid\nX509_VERIFY_PARAM_free(X509_VERIFY_PARAM *param)\n{\n\tif (param == NULL)\n\t\treturn;\n\tx509_verify_param_zero(param);\n\tfree(param->id);\n\tfree(param);\n}\n\n/* This function determines how parameters are \"inherited\" from one structure\n * to another. There are several different ways this can happen.\n *\n * 1. If a child structure needs to have its values initialized from a parent\n *    they are simply copied across. For example SSL_CTX copied to SSL.\n * 2. If the structure should take on values only if they are currently unset.\n *    For example the values in an SSL structure will take appropriate value\n *    for SSL servers or clients but only if the application has not set new\n *    ones.\n *\n * The \"inh_flags\" field determines how this function behaves.\n *\n * Normally any values which are set in the default are not copied from the\n * destination and verify flags are ORed together.\n *\n * If X509_VP_FLAG_DEFAULT is set then anything set in the source is copied\n * to the destination. Effectively the values in \"to\" become default values\n * which will be used only if nothing new is set in \"from\".\n *\n * If X509_VP_FLAG_OVERWRITE is set then all value are copied across whether\n * they are set or not. Flags is still Ored though.\n *\n * If X509_VP_FLAG_RESET_FLAGS is set then the flags value is copied instead\n * of ORed.\n *\n * If X509_VP_FLAG_LOCKED is set then no values are copied.\n *\n * If X509_VP_FLAG_ONCE is set then the current inh_flags setting is zeroed\n * after the next call.\n */\n\n/* Macro to test if a field should be copied from src to dest */\n\n#define test_x509_verify_param_copy(field, def) \\\n\t(to_overwrite || \\\n\t\t((src->field != def) && (to_default || (dest->field == def))))\n\n/* As above but for ID fields */\n\n#define test_x509_verify_param_copy_id(idf, def) \\\n\ttest_x509_verify_param_copy(id->idf, def)\n\n/* Macro to test and copy a field if necessary */\n\n#define x509_verify_param_copy(field, def) \\\n\tif (test_x509_verify_param_copy(field, def)) \\\n\t\tdest->field = src->field\n\nint\nX509_VERIFY_PARAM_inherit(X509_VERIFY_PARAM *dest, const X509_VERIFY_PARAM *src)\n{\n\tunsigned long inh_flags;\n\tint to_default, to_overwrite;\n\tX509_VERIFY_PARAM_ID *id;\n\n\tif (!src)\n\t\treturn 1;\n\tid = src->id;\n\tinh_flags = dest->inh_flags | src->inh_flags;\n\n\tif (inh_flags & X509_VP_FLAG_ONCE)\n\t\tdest->inh_flags = 0;\n\n\tif (inh_flags & X509_VP_FLAG_LOCKED)\n\t\treturn 1;\n\n\tif (inh_flags & X509_VP_FLAG_DEFAULT)\n\t\tto_default = 1;\n\telse\n\t\tto_default = 0;\n\n\tif (inh_flags & X509_VP_FLAG_OVERWRITE)\n\t\tto_overwrite = 1;\n\telse\n\t\tto_overwrite = 0;\n\n\tx509_verify_param_copy(purpose, 0);\n\tx509_verify_param_copy(trust, 0);\n\tx509_verify_param_copy(depth, -1);\n\n\t/* If overwrite or check time not set, copy across */\n\n\tif (to_overwrite || !(dest->flags & X509_V_FLAG_USE_CHECK_TIME)) {\n\t\tdest->check_time = src->check_time;\n\t\tdest->flags &= ~X509_V_FLAG_USE_CHECK_TIME;\n\t\t/* Don't need to copy flag: that is done below */\n\t}\n\n\tif (inh_flags & X509_VP_FLAG_RESET_FLAGS)\n\t\tdest->flags = 0;\n\n\tdest->flags |= src->flags;\n\n\tif (test_x509_verify_param_copy(policies, NULL)) {\n\t\tif (!X509_VERIFY_PARAM_set1_policies(dest, src->policies))\n\t\t\treturn 0;\n\t}\n\n\t/* Copy the host flags if and only if we're copying the host list */\n\tif (test_x509_verify_param_copy_id(hosts, NULL)) {\n\t\tif (dest->id->hosts) {\n\t\t\tstring_stack_free(dest->id->hosts);\n\t\t\tdest->id->hosts = NULL;\n\t\t}\n\t\tif (id->hosts) {\n\t\t\tdest->id->hosts =\n\t\t\t    sk_deep_copy(id->hosts, strdup, str_free);\n\t\t\tif (dest->id->hosts == NULL)\n\t\t\t\treturn 0;\n\t\t\tdest->id->hostflags = id->hostflags;\n\t\t}\n\t}\n\n\tif (test_x509_verify_param_copy_id(email, NULL)) {\n\t\tif (!X509_VERIFY_PARAM_set1_email(dest, id->email,\n\t\t    id->emaillen))\n\t\t\treturn 0;\n\t}\n\n\tif (test_x509_verify_param_copy_id(ip, NULL)) {\n\t\tif (!X509_VERIFY_PARAM_set1_ip(dest, id->ip, id->iplen))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nint\nX509_VERIFY_PARAM_set1(X509_VERIFY_PARAM *to, const X509_VERIFY_PARAM *from)\n{\n\tunsigned long save_flags = to->inh_flags;\n\tint ret;\n\n\tto->inh_flags |= X509_VP_FLAG_DEFAULT;\n\tret = X509_VERIFY_PARAM_inherit(to, from);\n\tto->inh_flags = save_flags;\n\treturn ret;\n}\n\nstatic int\nint_x509_param_set1(char **pdest, size_t *pdestlen,  const char *src,\n    size_t srclen)\n{\n\tchar *tmp;\n\tif (src) {\n\t\tif (srclen == 0) {\n\t\t\tif ((tmp = strdup(src)) == NULL)\n\t\t\t\treturn 0;\n\t\t\tsrclen = strlen(src);\n\t\t} else {\n\t\t\tif ((tmp = malloc(srclen)) == NULL)\n\t\t\t\treturn 0;\n\t\t\tmemcpy(tmp, src, srclen);\n\t\t}\n\t} else {\n\t\ttmp = NULL;\n\t\tsrclen = 0;\n\t}\n\tif (*pdest)\n\t\tfree(*pdest);\n\t*pdest = tmp;\n\tif (pdestlen)\n\t\t*pdestlen = srclen;\n\treturn 1;\n}\n\nint\nX509_VERIFY_PARAM_set1_name(X509_VERIFY_PARAM *param, const char *name)\n{\n\tfree(param->name);\n\tparam->name = NULL;\n\tif (name == NULL)\n\t\treturn 1;\n\tparam->name = strdup(name);\n\tif (param->name)\n\t\treturn 1;\n\treturn 0;\n}\n\nint\nX509_VERIFY_PARAM_set_flags(X509_VERIFY_PARAM *param, unsigned long flags)\n{\n\tparam->flags |= flags;\n\tif (flags & X509_V_FLAG_POLICY_MASK)\n\t\tparam->flags |= X509_V_FLAG_POLICY_CHECK;\n\treturn 1;\n}\n\nint\nX509_VERIFY_PARAM_clear_flags(X509_VERIFY_PARAM *param, unsigned long flags)\n{\n\tparam->flags &= ~flags;\n\treturn 1;\n}\n\nunsigned long\nX509_VERIFY_PARAM_get_flags(X509_VERIFY_PARAM *param)\n{\n\treturn param->flags;\n}\n\nint\nX509_VERIFY_PARAM_set_purpose(X509_VERIFY_PARAM *param, int purpose)\n{\n\treturn X509_PURPOSE_set(&param->purpose, purpose);\n}\n\nint\nX509_VERIFY_PARAM_set_trust(X509_VERIFY_PARAM *param, int trust)\n{\n\treturn X509_TRUST_set(&param->trust, trust);\n}\n\nvoid\nX509_VERIFY_PARAM_set_depth(X509_VERIFY_PARAM *param, int depth)\n{\n\tparam->depth = depth;\n}\n\nvoid\nX509_VERIFY_PARAM_set_time(X509_VERIFY_PARAM *param, time_t t)\n{\n\tparam->check_time = t;\n\tparam->flags |= X509_V_FLAG_USE_CHECK_TIME;\n}\n\nint\nX509_VERIFY_PARAM_add0_policy(X509_VERIFY_PARAM *param, ASN1_OBJECT *policy)\n{\n\tif (!param->policies) {\n\t\tparam->policies = sk_ASN1_OBJECT_new_null();\n\t\tif (!param->policies)\n\t\t\treturn 0;\n\t}\n\tif (!sk_ASN1_OBJECT_push(param->policies, policy))\n\t\treturn 0;\n\treturn 1;\n}\n\nint\nX509_VERIFY_PARAM_set1_policies(X509_VERIFY_PARAM *param,\n    STACK_OF(ASN1_OBJECT) *policies)\n{\n\tint i;\n\tASN1_OBJECT *oid, *doid;\n\n\tif (!param)\n\t\treturn 0;\n\tif (param->policies)\n\t\tsk_ASN1_OBJECT_pop_free(param->policies, ASN1_OBJECT_free);\n\n\tif (!policies) {\n\t\tparam->policies = NULL;\n\t\treturn 1;\n\t}\n\n\tparam->policies = sk_ASN1_OBJECT_new_null();\n\tif (!param->policies)\n\t\treturn 0;\n\n\tfor (i = 0; i < sk_ASN1_OBJECT_num(policies); i++) {\n\t\toid = sk_ASN1_OBJECT_value(policies, i);\n\t\tdoid = OBJ_dup(oid);\n\t\tif (!doid)\n\t\t\treturn 0;\n\t\tif (!sk_ASN1_OBJECT_push(param->policies, doid)) {\n\t\t\tASN1_OBJECT_free(doid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tparam->flags |= X509_V_FLAG_POLICY_CHECK;\n\treturn 1;\n}\n\nint\nX509_VERIFY_PARAM_set1_host(X509_VERIFY_PARAM *param,\n    const char *name, size_t namelen)\n{\n\treturn int_x509_param_set_hosts(param->id, SET_HOST, name, namelen);\n}\n\nint\nX509_VERIFY_PARAM_add1_host(X509_VERIFY_PARAM *param,\n    const char *name, size_t namelen)\n{\n\treturn int_x509_param_set_hosts(param->id, ADD_HOST, name, namelen);\n}\n\nvoid\nX509_VERIFY_PARAM_set_hostflags(X509_VERIFY_PARAM *param, unsigned int flags)\n{\n\tparam->id->hostflags = flags;\n}\n\nchar *\nX509_VERIFY_PARAM_get0_peername(X509_VERIFY_PARAM *param)\n{\n\treturn param->id->peername;\n}\n\nint\nX509_VERIFY_PARAM_set1_email(X509_VERIFY_PARAM *param,  const char *email,\n    size_t emaillen)\n{\n\treturn int_x509_param_set1(&param->id->email, &param->id->emaillen,\n\t    email, emaillen);\n}\n\nint\nX509_VERIFY_PARAM_set1_ip(X509_VERIFY_PARAM *param, const unsigned char *ip,\n    size_t iplen)\n{\n\tif (iplen != 0 && iplen != 4 && iplen != 16)\n\t\treturn 0;\n\treturn int_x509_param_set1((char **)&param->id->ip, &param->id->iplen,\n\t    (char *)ip, iplen);\n}\n\nint\nX509_VERIFY_PARAM_set1_ip_asc(X509_VERIFY_PARAM *param, const char *ipasc)\n{\n\tunsigned char ipout[16];\n\tsize_t iplen;\n\n\tiplen = (size_t)a2i_ipadd(ipout, ipasc);\n\tif (iplen == 0)\n\t\treturn 0;\n\treturn X509_VERIFY_PARAM_set1_ip(param, ipout, iplen);\n}\n\nint\nX509_VERIFY_PARAM_get_depth(const X509_VERIFY_PARAM *param)\n{\n\treturn param->depth;\n}\n\nconst char *\nX509_VERIFY_PARAM_get0_name(const X509_VERIFY_PARAM *param)\n{\n\treturn param->name;\n}\n\nstatic const X509_VERIFY_PARAM_ID _empty_id = { NULL };\n\n#define vpm_empty_id (X509_VERIFY_PARAM_ID *)&_empty_id\n\n/*\n * Default verify parameters: these are used for various applications and can\n * be overridden by the user specified table.\n */\n\nstatic const X509_VERIFY_PARAM default_table[] = {\n\t{\n\t\t.name = \"default\",\n\t\t.depth = 100,\n\t\t.trust = 0,  /* XXX This is not the default trust value */\n\t\t.id = vpm_empty_id\n\t},\n\t{\n\t\t.name = \"pkcs7\",\n\t\t.purpose = X509_PURPOSE_SMIME_SIGN,\n\t\t.trust = X509_TRUST_EMAIL,\n\t\t.depth = -1,\n\t\t.id = vpm_empty_id\n\t},\n\t{\n\t\t.name = \"smime_sign\",\n\t\t.purpose = X509_PURPOSE_SMIME_SIGN,\n\t\t.trust = X509_TRUST_EMAIL,\n\t\t.depth =  -1,\n\t\t.id = vpm_empty_id\n\t},\n\t{\n\t\t.name = \"ssl_client\",\n\t\t.purpose = X509_PURPOSE_SSL_CLIENT,\n\t\t.trust = X509_TRUST_SSL_CLIENT,\n\t\t.depth = -1,\n\t\t.id = vpm_empty_id\n\t},\n\t{\n\t\t.name = \"ssl_server\",\n\t\t.purpose = X509_PURPOSE_SSL_SERVER,\n\t\t.trust = X509_TRUST_SSL_SERVER,\n\t\t.depth = -1,\n\t\t.id = vpm_empty_id\n\t}\n};\n\nstatic STACK_OF(X509_VERIFY_PARAM) *param_table = NULL;\n\nstatic int\nparam_cmp(const X509_VERIFY_PARAM * const *a,\n    const X509_VERIFY_PARAM * const *b)\n{\n\treturn strcmp((*a)->name, (*b)->name);\n}\n\nint\nX509_VERIFY_PARAM_add0_table(X509_VERIFY_PARAM *param)\n{\n\tX509_VERIFY_PARAM *ptmp;\n\tif (!param_table) {\n\t\tparam_table = sk_X509_VERIFY_PARAM_new(param_cmp);\n\t\tif (!param_table)\n\t\t\treturn 0;\n\t} else {\n\t\tsize_t idx;\n\n\t\tif ((idx = sk_X509_VERIFY_PARAM_find(param_table, param))\n\t\t    != -1) {\n\t\t\tptmp = sk_X509_VERIFY_PARAM_value(param_table,\n\t\t\t    idx);\n\t\t\tX509_VERIFY_PARAM_free(ptmp);\n\t\t\t(void)sk_X509_VERIFY_PARAM_delete(param_table,\n\t\t\t    idx);\n\t\t}\n\t}\n\tif (!sk_X509_VERIFY_PARAM_push(param_table, param))\n\t\treturn 0;\n\treturn 1;\n}\n\nint\nX509_VERIFY_PARAM_get_count(void)\n{\n\tint num = sizeof(default_table) / sizeof(X509_VERIFY_PARAM);\n\tif (param_table)\n\t\tnum += sk_X509_VERIFY_PARAM_num(param_table);\n\treturn num;\n}\n\nconst\nX509_VERIFY_PARAM *X509_VERIFY_PARAM_get0(int id)\n{\n\tint num = sizeof(default_table) / sizeof(X509_VERIFY_PARAM);\n\tif (id < num)\n\t\treturn default_table + id;\n\treturn sk_X509_VERIFY_PARAM_value(param_table, id - num);\n}\n\nconst\nX509_VERIFY_PARAM *X509_VERIFY_PARAM_lookup(const char *name)\n{\n\tX509_VERIFY_PARAM pm;\n\tunsigned int i, limit;\n\n\tpm.name = (char *)name;\n\tif (param_table) {\n\t\tsize_t idx;\n\t\tif ((idx = sk_X509_VERIFY_PARAM_find(param_table, &pm)) != -1)\n\t\t\treturn sk_X509_VERIFY_PARAM_value(param_table, idx);\n\t}\n\n\tlimit = sizeof(default_table) / sizeof(X509_VERIFY_PARAM);\n\tfor (i = 0; i < limit; i++) {\n\t\tif (strcmp(default_table[i].name, name) == 0) {\n\t\t\treturn &default_table[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nvoid\nX509_VERIFY_PARAM_table_cleanup(void)\n{\n\tif (param_table)\n\t\tsk_X509_VERIFY_PARAM_pop_free(param_table,\n\t\t    X509_VERIFY_PARAM_free);\n\tparam_table = NULL;\n}\n"], "fixing_code": ["/* $OpenBSD: x509_vpm.c,v 1.17 2018/03/22 15:54:46 beck Exp $ */\n/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL\n * project 2004.\n */\n/* ====================================================================\n * Copyright (c) 2004 The OpenSSL Project.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n *\n * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For written permission, please contact\n *    licensing@OpenSSL.org.\n *\n * 5. Products derived from this software may not be called \"OpenSSL\"\n *    nor may \"OpenSSL\" appear in their names without prior written\n *    permission of the OpenSSL Project.\n *\n * 6. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n *\n * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * ====================================================================\n *\n * This product includes cryptographic software written by Eric Young\n * (eay@cryptsoft.com).  This product includes software written by Tim\n * Hudson (tjh@cryptsoft.com).\n *\n */\n\n#include <stdio.h>\n#include <string.h>\n\n#include <openssl/buffer.h>\n#include <openssl/crypto.h>\n#include <openssl/lhash.h>\n#include <openssl/stack.h>\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n\n#include \"vpm_int.h\"\n\n/* X509_VERIFY_PARAM functions */\n\nint X509_VERIFY_PARAM_set1_email(X509_VERIFY_PARAM *param, const char *email,\n    size_t emaillen);\nint X509_VERIFY_PARAM_set1_ip(X509_VERIFY_PARAM *param, const unsigned char *ip,\n    size_t iplen);\n\n#define SET_HOST 0\n#define ADD_HOST 1\n\nstatic void\nstr_free(char *s)\n{\n    free(s);\n}\n\n#define string_stack_free(sk) sk_OPENSSL_STRING_pop_free(sk, str_free)\n\n\n/*\n * Post 1.0.1 sk function \"deep_copy\".  For the moment we simply make\n * these take void * and use them directly without a glorious blob of\n * obfuscating macros of dubious value in front of them. All this in\n * preparation for a rototilling of safestack.h (likely inspired by\n * this).\n */\nstatic void *\nsk_deep_copy(void *sk_void, void *copy_func_void, void *free_func_void)\n{\n\t_STACK *sk = sk_void;\n\tvoid *(*copy_func)(void *) = copy_func_void;\n\tvoid (*free_func)(void *) = free_func_void;\n\t_STACK *ret = sk_dup(sk);\n\tsize_t i;\n\n\tif (ret == NULL)\n\t\treturn NULL;\n\n\tfor (i = 0; i < ret->num; i++) {\n\t\tif (ret->data[i] == NULL)\n\t\t\tcontinue;\n\t\tret->data[i] = copy_func(ret->data[i]);\n\t\tif (ret->data[i] == NULL) {\n\t\t\tsize_t j;\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tif (ret->data[j] != NULL)\n\t\t\t\t\tfree_func(ret->data[j]);\n\t\t\t}\n\t\t\tsk_free(ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int\nint_x509_param_set_hosts(X509_VERIFY_PARAM_ID *id, int mode,\n    const char *name, size_t namelen)\n{\n\tchar *copy;\n\n\tif (name != NULL && namelen == 0)\n\t\tnamelen = strlen(name);\n\t/*\n\t * Refuse names with embedded NUL bytes.\n\t * XXX: Do we need to push an error onto the error stack?\n\t */\n\tif (name && memchr(name, '\\0', namelen))\n\t\treturn 0;\n\n\tif (mode == SET_HOST && id->hosts) {\n\t\tstring_stack_free(id->hosts);\n\t\tid->hosts = NULL;\n\t}\n\tif (name == NULL || namelen == 0)\n\t\treturn 1;\n\tcopy = strndup(name, namelen);\n\tif (copy == NULL)\n\t\treturn 0;\n\n\tif (id->hosts == NULL &&\n\t    (id->hosts = sk_OPENSSL_STRING_new_null()) == NULL) {\n\t\tfree(copy);\n\t\treturn 0;\n\t}\n\n\tif (!sk_OPENSSL_STRING_push(id->hosts, copy)) {\n\t\tfree(copy);\n\t\tif (sk_OPENSSL_STRING_num(id->hosts) == 0) {\n\t\t\tsk_OPENSSL_STRING_free(id->hosts);\n\t\t\tid->hosts = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void\nx509_verify_param_zero(X509_VERIFY_PARAM *param)\n{\n\tX509_VERIFY_PARAM_ID *paramid;\n\tif (!param)\n\t\treturn;\n\tparam->name = NULL;\n\tparam->purpose = 0;\n\tparam->trust = 0;\n\t/*param->inh_flags = X509_VP_FLAG_DEFAULT;*/\n\tparam->inh_flags = 0;\n\tparam->flags = 0;\n\tparam->depth = -1;\n\tif (param->policies) {\n\t\tsk_ASN1_OBJECT_pop_free(param->policies, ASN1_OBJECT_free);\n\t\tparam->policies = NULL;\n\t}\n\tparamid = param->id;\n\tif (paramid->hosts) {\n\t\tstring_stack_free(paramid->hosts);\n\t\tparamid->hosts = NULL;\n\t}\n\tfree(paramid->peername);\n\tparamid->peername = NULL;\n\tfree(paramid->email);\n\tparamid->email = NULL;\n\tparamid->emaillen = 0;\n\tfree(paramid->ip);\n\tparamid->ip = NULL;\n\tparamid->iplen = 0;\n}\n\nX509_VERIFY_PARAM *\nX509_VERIFY_PARAM_new(void)\n{\n\tX509_VERIFY_PARAM *param;\n\tX509_VERIFY_PARAM_ID *paramid;\n\tparam = calloc(1, sizeof(X509_VERIFY_PARAM));\n\tif (param == NULL)\n\t\treturn NULL;\n\tparamid = calloc (1, sizeof(X509_VERIFY_PARAM_ID));\n\tif (paramid == NULL) {\n\t\tfree(param);\n\t\treturn NULL;\n\t}\n\tparam->id = paramid;\n\tx509_verify_param_zero(param);\n\treturn param;\n}\n\nvoid\nX509_VERIFY_PARAM_free(X509_VERIFY_PARAM *param)\n{\n\tif (param == NULL)\n\t\treturn;\n\tx509_verify_param_zero(param);\n\tfree(param->id);\n\tfree(param);\n}\n\n/* This function determines how parameters are \"inherited\" from one structure\n * to another. There are several different ways this can happen.\n *\n * 1. If a child structure needs to have its values initialized from a parent\n *    they are simply copied across. For example SSL_CTX copied to SSL.\n * 2. If the structure should take on values only if they are currently unset.\n *    For example the values in an SSL structure will take appropriate value\n *    for SSL servers or clients but only if the application has not set new\n *    ones.\n *\n * The \"inh_flags\" field determines how this function behaves.\n *\n * Normally any values which are set in the default are not copied from the\n * destination and verify flags are ORed together.\n *\n * If X509_VP_FLAG_DEFAULT is set then anything set in the source is copied\n * to the destination. Effectively the values in \"to\" become default values\n * which will be used only if nothing new is set in \"from\".\n *\n * If X509_VP_FLAG_OVERWRITE is set then all value are copied across whether\n * they are set or not. Flags is still Ored though.\n *\n * If X509_VP_FLAG_RESET_FLAGS is set then the flags value is copied instead\n * of ORed.\n *\n * If X509_VP_FLAG_LOCKED is set then no values are copied.\n *\n * If X509_VP_FLAG_ONCE is set then the current inh_flags setting is zeroed\n * after the next call.\n */\n\n/* Macro to test if a field should be copied from src to dest */\n\n#define test_x509_verify_param_copy(field, def) \\\n\t(to_overwrite || \\\n\t\t((src->field != def) && (to_default || (dest->field == def))))\n\n/* As above but for ID fields */\n\n#define test_x509_verify_param_copy_id(idf, def) \\\n\ttest_x509_verify_param_copy(id->idf, def)\n\n/* Macro to test and copy a field if necessary */\n\n#define x509_verify_param_copy(field, def) \\\n\tif (test_x509_verify_param_copy(field, def)) \\\n\t\tdest->field = src->field\n\nint\nX509_VERIFY_PARAM_inherit(X509_VERIFY_PARAM *dest, const X509_VERIFY_PARAM *src)\n{\n\tunsigned long inh_flags;\n\tint to_default, to_overwrite;\n\tX509_VERIFY_PARAM_ID *id;\n\n\tif (!src)\n\t\treturn 1;\n\tid = src->id;\n\tinh_flags = dest->inh_flags | src->inh_flags;\n\n\tif (inh_flags & X509_VP_FLAG_ONCE)\n\t\tdest->inh_flags = 0;\n\n\tif (inh_flags & X509_VP_FLAG_LOCKED)\n\t\treturn 1;\n\n\tif (inh_flags & X509_VP_FLAG_DEFAULT)\n\t\tto_default = 1;\n\telse\n\t\tto_default = 0;\n\n\tif (inh_flags & X509_VP_FLAG_OVERWRITE)\n\t\tto_overwrite = 1;\n\telse\n\t\tto_overwrite = 0;\n\n\tx509_verify_param_copy(purpose, 0);\n\tx509_verify_param_copy(trust, 0);\n\tx509_verify_param_copy(depth, -1);\n\n\t/* If overwrite or check time not set, copy across */\n\n\tif (to_overwrite || !(dest->flags & X509_V_FLAG_USE_CHECK_TIME)) {\n\t\tdest->check_time = src->check_time;\n\t\tdest->flags &= ~X509_V_FLAG_USE_CHECK_TIME;\n\t\t/* Don't need to copy flag: that is done below */\n\t}\n\n\tif (inh_flags & X509_VP_FLAG_RESET_FLAGS)\n\t\tdest->flags = 0;\n\n\tdest->flags |= src->flags;\n\n\tif (test_x509_verify_param_copy(policies, NULL)) {\n\t\tif (!X509_VERIFY_PARAM_set1_policies(dest, src->policies))\n\t\t\treturn 0;\n\t}\n\n\t/* Copy the host flags if and only if we're copying the host list */\n\tif (test_x509_verify_param_copy_id(hosts, NULL)) {\n\t\tif (dest->id->hosts) {\n\t\t\tstring_stack_free(dest->id->hosts);\n\t\t\tdest->id->hosts = NULL;\n\t\t}\n\t\tif (id->hosts) {\n\t\t\tdest->id->hosts =\n\t\t\t    sk_deep_copy(id->hosts, strdup, str_free);\n\t\t\tif (dest->id->hosts == NULL)\n\t\t\t\treturn 0;\n\t\t\tdest->id->hostflags = id->hostflags;\n\t\t}\n\t}\n\n\tif (test_x509_verify_param_copy_id(email, NULL)) {\n\t\tif (!X509_VERIFY_PARAM_set1_email(dest, id->email,\n\t\t    id->emaillen))\n\t\t\treturn 0;\n\t}\n\n\tif (test_x509_verify_param_copy_id(ip, NULL)) {\n\t\tif (!X509_VERIFY_PARAM_set1_ip(dest, id->ip, id->iplen))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nint\nX509_VERIFY_PARAM_set1(X509_VERIFY_PARAM *to, const X509_VERIFY_PARAM *from)\n{\n\tunsigned long save_flags = to->inh_flags;\n\tint ret;\n\n\tto->inh_flags |= X509_VP_FLAG_DEFAULT;\n\tret = X509_VERIFY_PARAM_inherit(to, from);\n\tto->inh_flags = save_flags;\n\treturn ret;\n}\n\nstatic int\nint_x509_param_set1(char **pdest, size_t *pdestlen,  const char *src,\n    size_t srclen)\n{\n\tchar *tmp;\n\tif (src) {\n\t\tif (srclen == 0) {\n\t\t\tif ((tmp = strdup(src)) == NULL)\n\t\t\t\treturn 0;\n\t\t\tsrclen = strlen(src);\n\t\t} else {\n\t\t\tif ((tmp = malloc(srclen)) == NULL)\n\t\t\t\treturn 0;\n\t\t\tmemcpy(tmp, src, srclen);\n\t\t}\n\t} else {\n\t\ttmp = NULL;\n\t\tsrclen = 0;\n\t}\n\tif (*pdest)\n\t\tfree(*pdest);\n\t*pdest = tmp;\n\tif (pdestlen)\n\t\t*pdestlen = srclen;\n\treturn 1;\n}\n\nint\nX509_VERIFY_PARAM_set1_name(X509_VERIFY_PARAM *param, const char *name)\n{\n\tfree(param->name);\n\tparam->name = NULL;\n\tif (name == NULL)\n\t\treturn 1;\n\tparam->name = strdup(name);\n\tif (param->name)\n\t\treturn 1;\n\treturn 0;\n}\n\nint\nX509_VERIFY_PARAM_set_flags(X509_VERIFY_PARAM *param, unsigned long flags)\n{\n\tparam->flags |= flags;\n\tif (flags & X509_V_FLAG_POLICY_MASK)\n\t\tparam->flags |= X509_V_FLAG_POLICY_CHECK;\n\treturn 1;\n}\n\nint\nX509_VERIFY_PARAM_clear_flags(X509_VERIFY_PARAM *param, unsigned long flags)\n{\n\tparam->flags &= ~flags;\n\treturn 1;\n}\n\nunsigned long\nX509_VERIFY_PARAM_get_flags(X509_VERIFY_PARAM *param)\n{\n\treturn param->flags;\n}\n\nint\nX509_VERIFY_PARAM_set_purpose(X509_VERIFY_PARAM *param, int purpose)\n{\n\treturn X509_PURPOSE_set(&param->purpose, purpose);\n}\n\nint\nX509_VERIFY_PARAM_set_trust(X509_VERIFY_PARAM *param, int trust)\n{\n\treturn X509_TRUST_set(&param->trust, trust);\n}\n\nvoid\nX509_VERIFY_PARAM_set_depth(X509_VERIFY_PARAM *param, int depth)\n{\n\tparam->depth = depth;\n}\n\nvoid\nX509_VERIFY_PARAM_set_time(X509_VERIFY_PARAM *param, time_t t)\n{\n\tparam->check_time = t;\n\tparam->flags |= X509_V_FLAG_USE_CHECK_TIME;\n}\n\nint\nX509_VERIFY_PARAM_add0_policy(X509_VERIFY_PARAM *param, ASN1_OBJECT *policy)\n{\n\tif (!param->policies) {\n\t\tparam->policies = sk_ASN1_OBJECT_new_null();\n\t\tif (!param->policies)\n\t\t\treturn 0;\n\t}\n\tif (!sk_ASN1_OBJECT_push(param->policies, policy))\n\t\treturn 0;\n\treturn 1;\n}\n\nint\nX509_VERIFY_PARAM_set1_policies(X509_VERIFY_PARAM *param,\n    STACK_OF(ASN1_OBJECT) *policies)\n{\n\tint i;\n\tASN1_OBJECT *oid, *doid;\n\n\tif (!param)\n\t\treturn 0;\n\tif (param->policies)\n\t\tsk_ASN1_OBJECT_pop_free(param->policies, ASN1_OBJECT_free);\n\n\tif (!policies) {\n\t\tparam->policies = NULL;\n\t\treturn 1;\n\t}\n\n\tparam->policies = sk_ASN1_OBJECT_new_null();\n\tif (!param->policies)\n\t\treturn 0;\n\n\tfor (i = 0; i < sk_ASN1_OBJECT_num(policies); i++) {\n\t\toid = sk_ASN1_OBJECT_value(policies, i);\n\t\tdoid = OBJ_dup(oid);\n\t\tif (!doid)\n\t\t\treturn 0;\n\t\tif (!sk_ASN1_OBJECT_push(param->policies, doid)) {\n\t\t\tASN1_OBJECT_free(doid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tparam->flags |= X509_V_FLAG_POLICY_CHECK;\n\treturn 1;\n}\n\nint\nX509_VERIFY_PARAM_set1_host(X509_VERIFY_PARAM *param,\n    const char *name, size_t namelen)\n{\n\treturn int_x509_param_set_hosts(param->id, SET_HOST, name, namelen);\n}\n\nint\nX509_VERIFY_PARAM_add1_host(X509_VERIFY_PARAM *param,\n    const char *name, size_t namelen)\n{\n\treturn int_x509_param_set_hosts(param->id, ADD_HOST, name, namelen);\n}\n\nvoid\nX509_VERIFY_PARAM_set_hostflags(X509_VERIFY_PARAM *param, unsigned int flags)\n{\n\tparam->id->hostflags = flags;\n}\n\nchar *\nX509_VERIFY_PARAM_get0_peername(X509_VERIFY_PARAM *param)\n{\n\treturn param->id->peername;\n}\n\nint\nX509_VERIFY_PARAM_set1_email(X509_VERIFY_PARAM *param,  const char *email,\n    size_t emaillen)\n{\n\treturn int_x509_param_set1(&param->id->email, &param->id->emaillen,\n\t    email, emaillen);\n}\n\nint\nX509_VERIFY_PARAM_set1_ip(X509_VERIFY_PARAM *param, const unsigned char *ip,\n    size_t iplen)\n{\n\tif (iplen != 0 && iplen != 4 && iplen != 16)\n\t\treturn 0;\n\treturn int_x509_param_set1((char **)&param->id->ip, &param->id->iplen,\n\t    (char *)ip, iplen);\n}\n\nint\nX509_VERIFY_PARAM_set1_ip_asc(X509_VERIFY_PARAM *param, const char *ipasc)\n{\n\tunsigned char ipout[16];\n\tsize_t iplen;\n\n\tiplen = (size_t)a2i_ipadd(ipout, ipasc);\n\tif (iplen == 0)\n\t\treturn 0;\n\treturn X509_VERIFY_PARAM_set1_ip(param, ipout, iplen);\n}\n\nint\nX509_VERIFY_PARAM_get_depth(const X509_VERIFY_PARAM *param)\n{\n\treturn param->depth;\n}\n\nconst char *\nX509_VERIFY_PARAM_get0_name(const X509_VERIFY_PARAM *param)\n{\n\treturn param->name;\n}\n\nstatic const X509_VERIFY_PARAM_ID _empty_id = { NULL };\n\n#define vpm_empty_id (X509_VERIFY_PARAM_ID *)&_empty_id\n\n/*\n * Default verify parameters: these are used for various applications and can\n * be overridden by the user specified table.\n */\n\nstatic const X509_VERIFY_PARAM default_table[] = {\n\t{\n\t\t.name = \"default\",\n\t\t.depth = 100,\n\t\t.trust = 0,  /* XXX This is not the default trust value */\n\t\t.id = vpm_empty_id\n\t},\n\t{\n\t\t.name = \"pkcs7\",\n\t\t.purpose = X509_PURPOSE_SMIME_SIGN,\n\t\t.trust = X509_TRUST_EMAIL,\n\t\t.depth = -1,\n\t\t.id = vpm_empty_id\n\t},\n\t{\n\t\t.name = \"smime_sign\",\n\t\t.purpose = X509_PURPOSE_SMIME_SIGN,\n\t\t.trust = X509_TRUST_EMAIL,\n\t\t.depth =  -1,\n\t\t.id = vpm_empty_id\n\t},\n\t{\n\t\t.name = \"ssl_client\",\n\t\t.purpose = X509_PURPOSE_SSL_CLIENT,\n\t\t.trust = X509_TRUST_SSL_CLIENT,\n\t\t.depth = -1,\n\t\t.id = vpm_empty_id\n\t},\n\t{\n\t\t.name = \"ssl_server\",\n\t\t.purpose = X509_PURPOSE_SSL_SERVER,\n\t\t.trust = X509_TRUST_SSL_SERVER,\n\t\t.depth = -1,\n\t\t.id = vpm_empty_id\n\t}\n};\n\nstatic STACK_OF(X509_VERIFY_PARAM) *param_table = NULL;\n\nstatic int\nparam_cmp(const X509_VERIFY_PARAM * const *a,\n    const X509_VERIFY_PARAM * const *b)\n{\n\treturn strcmp((*a)->name, (*b)->name);\n}\n\nint\nX509_VERIFY_PARAM_add0_table(X509_VERIFY_PARAM *param)\n{\n\tX509_VERIFY_PARAM *ptmp;\n\tif (!param_table) {\n\t\tparam_table = sk_X509_VERIFY_PARAM_new(param_cmp);\n\t\tif (!param_table)\n\t\t\treturn 0;\n\t} else {\n\t\tsize_t idx;\n\n\t\tif ((idx = sk_X509_VERIFY_PARAM_find(param_table, param))\n\t\t    != -1) {\n\t\t\tptmp = sk_X509_VERIFY_PARAM_value(param_table,\n\t\t\t    idx);\n\t\t\tX509_VERIFY_PARAM_free(ptmp);\n\t\t\t(void)sk_X509_VERIFY_PARAM_delete(param_table,\n\t\t\t    idx);\n\t\t}\n\t}\n\tif (!sk_X509_VERIFY_PARAM_push(param_table, param))\n\t\treturn 0;\n\treturn 1;\n}\n\nint\nX509_VERIFY_PARAM_get_count(void)\n{\n\tint num = sizeof(default_table) / sizeof(X509_VERIFY_PARAM);\n\tif (param_table)\n\t\tnum += sk_X509_VERIFY_PARAM_num(param_table);\n\treturn num;\n}\n\nconst\nX509_VERIFY_PARAM *X509_VERIFY_PARAM_get0(int id)\n{\n\tint num = sizeof(default_table) / sizeof(X509_VERIFY_PARAM);\n\tif (id < num)\n\t\treturn default_table + id;\n\treturn sk_X509_VERIFY_PARAM_value(param_table, id - num);\n}\n\nconst\nX509_VERIFY_PARAM *X509_VERIFY_PARAM_lookup(const char *name)\n{\n\tX509_VERIFY_PARAM pm;\n\tunsigned int i, limit;\n\n\tpm.name = (char *)name;\n\tif (param_table) {\n\t\tsize_t idx;\n\t\tif ((idx = sk_X509_VERIFY_PARAM_find(param_table, &pm)) != -1)\n\t\t\treturn sk_X509_VERIFY_PARAM_value(param_table, idx);\n\t}\n\n\tlimit = sizeof(default_table) / sizeof(X509_VERIFY_PARAM);\n\tfor (i = 0; i < limit; i++) {\n\t\tif (strcmp(default_table[i].name, name) == 0) {\n\t\t\treturn &default_table[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nvoid\nX509_VERIFY_PARAM_table_cleanup(void)\n{\n\tif (param_table)\n\t\tsk_X509_VERIFY_PARAM_pop_free(param_table,\n\t\t    X509_VERIFY_PARAM_free);\n\tparam_table = NULL;\n}\n"], "filenames": ["src/lib/libcrypto/x509/x509_vpm.c"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [132], "fixing_code_start_loc": [1], "fixing_code_end_loc": [135], "type": "CWE-295", "message": "The int_x509_param_set_hosts function in lib/libcrypto/x509/x509_vpm.c in LibreSSL 2.7.0 before 2.7.1 does not support a certain special case of a zero name length, which causes silent omission of hostname verification, and consequently allows man-in-the-middle attackers to spoof servers and obtain sensitive information via a crafted certificate. NOTE: the LibreSSL documentation indicates that this special case is supported, but the BoringSSL documentation does not.", "other": {"cve": {"id": "CVE-2018-8970", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-24T21:29:00.227", "lastModified": "2018-04-24T16:40:13.967", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The int_x509_param_set_hosts function in lib/libcrypto/x509/x509_vpm.c in LibreSSL 2.7.0 before 2.7.1 does not support a certain special case of a zero name length, which causes silent omission of hostname verification, and consequently allows man-in-the-middle attackers to spoof servers and obtain sensitive information via a crafted certificate. NOTE: the LibreSSL documentation indicates that this special case is supported, but the BoringSSL documentation does not."}, {"lang": "es", "value": "La funci\u00f3n int_x509_param_set_hosts en lib/libcrypto/x509/x509_vpm.c en LibreSSL, en versiones 2.7.0 anteriores a la 2.7.1 no soporta determinados casos especiales de una longitud de nombre cero. Esto provoca una omisi\u00f3n silenciosa de la verificaci\u00f3n del nombre de host y, en consecuencia, permite que atacantes Man-in-the-Middle (MitM) suplanten servidores y obtengan informaci\u00f3n sensible mediante un certificado manipulado. NOTA: la documentaci\u00f3n de LibreSSL indica que el programa soporta este caso especial, pero la documentaci\u00f3n de BoringSSL no."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:libressl:2.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "39DDFDEF-AD05-444B-8BCE-018EC7393F76"}]}]}], "references": [{"url": "https://boringssl.googlesource.com/boringssl/+/e759a9cd84198613199259dbed401f4951747cff", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://ftp.openbsd.org/pub/OpenBSD/LibreSSL/libressl-2.7.1-relnotes.txt", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/libressl-portable/openbsd/commit/0654414afcce51a16d35d05060190a3ec4618d42", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libressl-portable/openbsd/commit/0654414afcce51a16d35d05060190a3ec4618d42"}}